head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.6
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.26.0.6
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.10
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.10
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.8
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.12
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.11.0.10
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.8
	OPENBSD_2_8:1.11.0.6
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	0Dp7Dy9FuNZesYo2;

1.26
date	2015.01.16.00.03.38;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	waQzIVMqUqjBDjYt;

1.25
date	2014.11.23.04.34.48;	author guenther;	state Exp;
branches;
next	1.24;
commitid	LIj2x3qvN0HcH7BW;

1.24
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.01.19.32.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.18.00.46.48;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.07.07.57.36;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.05.22.21.41.58;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	98.11.22.23.29.37;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.06.23.22.21.49;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.04.01.18.11.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.31.10.09.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.06.18.49.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.18.48.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.40.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.35.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.13.31.58;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@/*	$OpenBSD: swap.c,v 1.26 2015/01/16 00:03:38 deraadt Exp $	*/
/*	$NetBSD: swap.c,v 1.9 1998/12/26 07:05:08 marc Exp $	*/

/*-
 * Copyright (c) 1997 Matthew R. Green.  All rights reserved.
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/signal.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/swap.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>

#include "systat.h"


static	long blocksize;
static	int hlen, nswap, rnswap;
static	struct swapent *swap_devices;

void print_sw(void);
int read_sw(void);
int select_sw(void);
static void showswap(int i);
static void showtotal(void);


field_def fields_sw[] = {
	{"DISK", 6, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"BLOCKS", 5, 10, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"USED", 5, 10, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"", 40, 80, 1, FLD_ALIGN_BAR, -1, 0, 0, 100},
};

#define FLD_SW_NAME	FIELD_ADDR(fields_sw,0)
#define FLD_SW_BLOCKS	FIELD_ADDR(fields_sw,1)
#define FLD_SW_USED	FIELD_ADDR(fields_sw,2)
#define FLD_SW_BAR	FIELD_ADDR(fields_sw,3)

/* Define views */
field_def *view_sw_0[] = {
	FLD_SW_NAME, FLD_SW_BLOCKS, FLD_SW_USED, FLD_SW_BAR, NULL
};


/* Define view managers */
struct view_manager swap_mgr = {
	"Swap", select_sw, read_sw, NULL, print_header,
	print_sw, keyboard_callback, NULL, NULL
};

field_view views_sw[] = {
	{view_sw_0, "swap", '6', &swap_mgr},
	{NULL, NULL, 0, NULL}
};


int
select_sw(void)
{
	if (swap_devices == NULL || nswap == 0)
		num_disp = 1;
	else
		num_disp = nswap;
	if (nswap > 1)
		num_disp++;
	return (0);
}

int
read_sw(void)
{
	num_disp = 1;

	nswap = swapctl(SWAP_NSWAP, 0, 0);

	if (nswap < 0)
		error("error: %s", strerror(errno));
	if (nswap == 0)
		return 0;

	if (swap_devices)
		(void)free(swap_devices);

	swap_devices = calloc(nswap, sizeof(*swap_devices));
	if (swap_devices == NULL)
		return 0;

	rnswap = swapctl(SWAP_STATS, (void *)swap_devices, nswap);
	if (rnswap < 0 || nswap != rnswap)
		return 0;

	num_disp = nswap;
	if (nswap > 1)
		num_disp++;

	return 0;
}


void
print_sw(void)
{
	int n, count = 0;

	if (swap_devices == NULL || nswap == 0) {
		print_fld_str(FLD_SW_BAR, "No swap devices");
		return;
	}


	for (n = dispstart; n < num_disp; n++) {
		if (n >= nswap)
			showtotal();
		else
			showswap(n);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}

}

int
initswap(void)
{
	field_view *v;

	char *bs = getbsize(&hlen, &blocksize);

	FLD_SW_BLOCKS->title = strdup(bs);

	for (v = views_sw; v->name != NULL; v++)
		add_view(v);

	return(1);
}


static void
showswap(int i)
{
	int d, used, xsize;
	struct	swapent *sep;
	char	*p;

	d = blocksize / 512;

	sep = &swap_devices[i];

	p = strrchr(sep->se_path, '/');
	p = p ? p+1 : sep->se_path;

	print_fld_str(FLD_SW_NAME, p);
	
	xsize = sep->se_nblks;
	used = sep->se_inuse;

	print_fld_uint(FLD_SW_BLOCKS, xsize / d);
	print_fld_uint(FLD_SW_USED, used / d);
	print_fld_bar(FLD_SW_BAR, 100 * used / xsize);

	end_line();
}

static void
showtotal(void)
{
	struct	swapent *sep;
	int	d, i, avail, used, xsize, mfree;

	d = blocksize / 512;
	mfree = avail = 0;

	for (sep = swap_devices, i = 0; i < nswap; i++, sep++) {
		xsize = sep->se_nblks;
		used = sep->se_inuse;
		avail += xsize;
		mfree += xsize - used;
	}
	used = avail - mfree;

	print_fld_str(FLD_SW_NAME, "Total");
	print_fld_uint(FLD_SW_BLOCKS, avail / d);
	print_fld_uint(FLD_SW_USED, used / d);
	print_fld_bar(FLD_SW_BAR, 100 * used / avail);

	end_line();
}
@


1.26
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.25 2014/11/23 04:34:48 guenther Exp $	*/
d118 1
a118 1
	swap_devices = (struct swapent *)calloc(nswap, sizeof(*swap_devices));
@


1.25
log
@<sys/buf.h> isn't actually needed here

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.24 2012/12/05 23:20:26 deraadt Exp $	*/
d34 2
a35 1
#include <sys/param.h>
@


1.24
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.23 2011/03/02 06:48:17 jasper Exp $	*/
a34 1
#include <sys/buf.h>
@


1.23
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.22 2008/12/07 02:56:06 canacar Exp $	*/
a33 1
#include <sys/cdefs.h>
@


1.22
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.21 2008/06/12 22:26:01 canacar Exp $	*/
d69 4
a72 6
#define FIELD_ADDR(x) (&fields_sw[x])

#define FLD_SW_NAME	FIELD_ADDR(0)
#define FLD_SW_BLOCKS	FIELD_ADDR(1)
#define FLD_SW_USED	FIELD_ADDR(2)
#define FLD_SW_BAR	FIELD_ADDR(3)
@


1.21
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.20 2007/09/01 19:32:19 deraadt Exp $	*/
d179 1
a179 1
	int div, used, xsize;
d183 1
a183 1
	div = blocksize / 512;
d195 2
a196 2
	print_fld_uint(FLD_SW_BLOCKS, xsize / div);
	print_fld_uint(FLD_SW_USED, used / div);
d206 1
a206 1
	int	div, i, avail, used, xsize, free;
d208 2
a209 2
	div = blocksize / 512;
	free = avail = 0;
d215 1
a215 1
		free += xsize - used;
d217 1
a217 1
	used = avail - free;
d220 2
a221 2
	print_fld_uint(FLD_SW_BLOCKS, avail / div);
	print_fld_uint(FLD_SW_USED, used / div);
@


1.20
log
@malloc(n * m) -> calloc(n, m); from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.19 2007/02/25 18:21:24 deraadt Exp $	*/
a33 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)swap.c	8.3 (Berkeley) 4/29/95";
#endif
static char rcsid[] = "$OpenBSD: swap.c,v 1.19 2007/02/25 18:21:24 deraadt Exp $";
#endif /* not lint */

d49 1
a49 1
#include "extern.h"
a52 1
static	int first = 1;
d55 37
a91 5
WINDOW *
openswap(void)
{
	return (subwin(stdscr, LINES-1-2, 0, 2, 0));
}
a92 9
void
closeswap(WINDOW *w)
{
	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
}
a93 1
/* do nothing */
d95 1
a95 1
initswap(void)
d97 7
a103 1
	return (1);
d106 2
a107 2
void
fetchswap(void)
d109 1
a109 1
	int	update_label = 0;
a110 1
	first = 0;
d112 1
d116 1
a116 2
		return;
	update_label = (nswap != rnswap);
d120 1
d123 1
a123 1
		/* XXX */ ;	/* XXX systat doesn't do errors! */
d126 8
a133 6
	if (nswap < 0)
		/* XXX */ ;	/* XXX systat doesn't do errors! */
	if (nswap != rnswap)
		/* XXX */ ;	/* XXX systat doesn't do errors! */
	if (update_label)
		labelswap();
d136 1
d138 1
a138 1
labelswap(void)
d140 1
a140 2
	char	*header;
	int	row;
d142 2
a143 7
	row = 0;
	wmove(wnd, row, 0);
	wclrtobot(wnd);
	if (first)
		fetchswap();
	if (nswap == 0) {
		mvwprintw(wnd, row++, 0, "No swap");
d146 27
a172 4
	header = getbsize(&hlen, &blocksize);
	mvwprintw(wnd, row++, 0, "%-5s%*s%9s  %55s",
	    "Disk", hlen, header, "Used",
	    "/0%  /10% /20% /30% /40% /50% /60% /70% /80% /90% /100%");
d175 3
a177 2
void
showswap(void)
d179 1
a179 1
	int	col, div, i, j, avail, used, xsize, free;
a183 4
	free = avail = 0;
	for (sep = swap_devices, i = 0; i < nswap; i++, sep++) {
		if (sep == NULL)
			continue;
d185 16
a200 2
		p = strrchr(sep->se_path, '/');
		p = p ? p+1 : sep->se_path;
d202 5
a206 1
		mvwprintw(wnd, i + 1, 0, "%-5s", p);
d208 2
a209 2
		col = 5;
		mvwprintw(wnd, i + 1, col, "%*d", hlen, sep->se_nblks / div);
d211 1
a211 1
		col += hlen;
a215 13
		mvwprintw(wnd, i + 1, col, "%9d  ", used / div);
		for (j = (100 * used / xsize + 1) / 2; j > 0; j--)
			waddch(wnd, 'X');
		wclrtoeol(wnd);
	}
	/* do total if necessary */
	if (nswap > 1) {
		used = avail - free;
		mvwprintw(wnd, i + 1, 0, "%-5s%*d%9d  ",
		    "Total", hlen, avail / div, used / div);
		for (j = (100 * used / avail + 1) / 2; j > 0; j--)
			waddch(wnd, 'X');
		wclrtoeol(wnd);
d217 8
@


1.19
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.18 2006/03/31 04:10:59 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.18 2006/03/31 04:10:59 deraadt Exp $";
d101 1
a101 1
	swap_devices = (struct swapent *)malloc(nswap * sizeof(*swap_devices));
@


1.18
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.17 2003/06/03 02:56:17 millert Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.17 2003/06/03 02:56:17 millert Exp $";
d66 1
a66 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.16 2002/06/18 00:46:48 deraadt Exp $	*/
d38 1
a38 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.16 2002/06/18 00:46:48 deraadt Exp $";
a56 2

void showspace(char *header, int hlen, long blocksize);
@


1.16
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.15 2002/02/16 21:27:54 millert Exp $	*/
d17 1
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d38 1
a38 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.15 2002/02/16 21:27:54 millert Exp $";
@


1.15
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.14 2001/12/07 09:18:08 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.14 2001/12/07 09:18:08 deraadt Exp $";
d70 1
a70 1
openswap()
d76 1
a76 2
closeswap(w)
	WINDOW *w;
d87 1
a87 1
initswap()
d93 1
a93 1
fetchswap()
d121 1
a121 1
labelswap()
d142 2
a143 1
showswap() {
@


1.14
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.12 2001/11/23 22:20:06 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.12 2001/11/23 22:20:06 deraadt Exp $";
d62 1
a62 1
void showspace __P((char *header, int hlen, long blocksize));
@


1.13
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.11 1999/05/22 21:41:58 weingart Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.11 1999/05/22 21:41:58 weingart Exp $";
a43 1

@


1.12
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@d45 1
@


1.11
log
@Merge for new vmswap code largely from netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.10 1998/11/22 23:29:37 kstailey Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.10 1998/11/22 23:29:37 kstailey Exp $";
a43 1

@


1.10
log
@now "Total" column can shrink
@
text
@d1 2
a2 2
/*	$OpenBSD: swap.c,v 1.9 1997/06/23 22:21:49 millert Exp $	*/
/*	$NetBSD: swap.c,v 1.5 1996/05/10 23:16:38 thorpej Exp $	*/
d5 1
d42 1
a42 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.9 1997/06/23 22:21:49 millert Exp $";
a44 3
/*
 * swapinfo - based on a program of the same name by Kevin Lahey
 */
d46 1
a50 1
#include <sys/map.h>
d52 1
a53 2
#include <kvm.h>
#include <nlist.h>
d57 1
a62 1
extern char *getbsize __P((int *headerlenp, long *blocksizep));
d65 4
a68 33
struct nlist syms[] = {
	{ "_swapmap" },	/* list of free swap areas */
#define VM_SWAPMAP	0
	{ "_nswapmap" },/* size of the swap map */
#define VM_NSWAPMAP	1
	{ "_swdevt" },	/* list of swap devices and sizes */
#define VM_SWDEVT	2
	{ "_nswap" },	/* size of largest swap device */
#define VM_NSWAP	3
	{ "_nswdev" },	/* number of swap devices */
#define VM_NSWDEV	4
	{ "_dmmax" },	/* maximum size of a swap block */
#define VM_DMMAX	5
	{ 0 }
};

static int nswap, nswdev, dmmax, nswapmap;
static struct swdevt *sw;
static long *perdev, blocksize;
static struct map *swapmap, *kswapmap;
static struct mapent *mpp;
static int nfree, hlen;

#define	SVAR(var) __STRING(var)	/* to force expansion */
#define	KGET(idx, var) \
	KGET1(idx, &var, sizeof(var), SVAR(var))
#define	KGET1(idx, p, s, msg) \
	KGET2(syms[idx].n_value, p, s, msg)
#define	KGET2(addr, p, s, msg) \
	if (kvm_read(kd, addr, p, s) != s) { \
		error("cannot read %s: %s", msg, kvm_geterr(kd)); \
		return (0); \
	}
d87 1
a90 33
	int i;
	char msgbuf[BUFSIZ];
	static int once = 0;

	if (once)
		return (1);
	if (kvm_nlist(kd, syms)) {
		strcpy(msgbuf, "systat: swap: cannot find");
		for (i = 0; syms[i].n_name != NULL; i++) {
			if (syms[i].n_value == 0) {
				if (strlen(msgbuf) + strlen(syms[i].n_name) +2 >
				    sizeof (msgbuf))
					continue;
				strcat(msgbuf, " ");
				strcat(msgbuf, syms[i].n_name);
			}
		}
		error(msgbuf);
		return (0);
	}
	KGET(VM_NSWAP, nswap);
	KGET(VM_NSWDEV, nswdev);
	KGET(VM_DMMAX, dmmax);
	KGET(VM_NSWAPMAP, nswapmap);
	KGET(VM_SWAPMAP, kswapmap);	/* kernel `swapmap' is a pointer */
	if ((sw = malloc(nswdev * sizeof(*sw))) == NULL ||
	    (perdev = malloc(nswdev * sizeof(*perdev))) == NULL ||
	    (mpp = malloc(nswapmap * sizeof(*mpp))) == NULL) {
		error("swap malloc");
		return (0);
	}
	KGET1(VM_SWDEVT, sw, nswdev * sizeof(*sw), "swdevt");
	once = 1;
d97 9
a105 2
	struct mapent *mp;
	int s, e, i;
d107 13
a119 43
	s = nswapmap * sizeof(*mpp);
	mp = mpp;
	if (kvm_read(kd, (long)kswapmap, mp, s) != s)
		error("cannot read swapmap: %s", kvm_geterr(kd));

	/* first entry in map is `struct map'; rest are mapent's */
	swapmap = (struct map *)mp;
	if (nswapmap != swapmap->m_limit - (struct mapent *)kswapmap)
		error("panic: swap: nswapmap goof");

	/*
	 * Count up swap space.
	 */
	nfree = 0;
	bzero(perdev, nswdev * sizeof(*perdev));
	for (mp++; mp->m_addr != 0; mp++) {
		s = mp->m_addr;			/* start of swap region */
		e = mp->m_addr + mp->m_size;	/* end of region */
		nfree += mp->m_size;

		/*
		 * Swap space is split up among the configured disks.
		 * The first dmmax blocks of swap space some from the
		 * first disk, the next dmmax blocks from the next, 
		 * and so on.  The list of free space joins adjacent
		 * free blocks, ignoring device boundries.  If we want
		 * to keep track of this information per device, we'll
		 * just have to extract it ourselves.
		 */

		/* calculate first device on which this falls */
		i = (s / dmmax) % nswdev;
		while (s < e) {		/* XXX this is inefficient */
			int bound = roundup(s + 1, dmmax);

			if (bound > e)
				bound = e;
			perdev[i] += bound - s;
			if (++i >= nswdev)
				i = 0;
			s = bound;
		}
	}
d125 2
a126 2
	char *header, *p;
	int row, i;
d129 8
a136 1
	wmove(wnd, row, 0); wclrtobot(wnd);
a140 4
	for (i = 0; i < nswdev; i++) {
		p = devname(sw[i].sw_dev, S_IFBLK);
		mvwprintw(wnd, i + 1, 0, "%-5s", p == NULL ? "??" : p);
	}
d144 4
a147 3
showswap()
{
	int col, div, i, j, avail, npfree, used, xsize, xfree;
d150 10
a159 2
	avail = npfree = 0;
	for (i = 0; i < nswdev; i++) {
d161 2
a162 1
		mvwprintw(wnd, i + 1, col, "%*d", hlen, sw[i].sw_nblks / div);
d164 4
a167 12
		/*
		 * Don't report statistics for partitions which have not
		 * yet been activated via swapon(8).
		 */
		if (!sw[i].sw_freed) {
			mvwprintw(wnd, i + 1, col + 8,
			    "0  *** not available for swapping ***");
			continue;
		}
		xsize = sw[i].sw_nblks;
		xfree = perdev[i];
		used = xsize - xfree;
a168 1
		wclrtoeol(wnd);
d171 1
a171 2
		npfree++;
		avail += xsize;
d173 3
a175 6
	/* 
	 * If only one partition has been set up via swapon(8), we don't
	 * need to bother with totals.
	 */
	if (npfree > 1) {
		used = avail - nfree;
a177 1
		wclrtoeol(wnd);
d180 1
@


1.9
log
@Cleanup by Theo and myself.  CMDLINE changed to long to make
command line work on 64bit platforms.  This is somewhat bogus
and is really just a temporary workaround (there may be a curses bug).
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.8 1997/04/01 18:11:58 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.8 1997/04/01 18:11:58 deraadt Exp $";
d265 1
@


1.8
log
@zap extra XXX if swap goes down; paul@@wit387304.student.utwente.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.7 1997/01/31 10:09:36 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.7 1997/01/31 10:09:36 deraadt Exp $";
d81 1
a81 1
	0
d119 1
d230 1
a230 1
	int col, row, div, i, j, avail, npfree, used, xsize, xfree;
@


1.7
log
@stop crash from walking off end of malloc'd page. i hunted this bug before
and didn't find it. fix from paul@@wit387304.student.utwente.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.6 1996/08/06 18:49:05 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.6 1996/08/06 18:49:05 deraadt Exp $";
d250 1
@


1.6
log
@whoops
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.5 1996/08/06 18:48:16 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.5 1996/08/06 18:48:16 deraadt Exp $";
d88 1
a88 1
static struct mapent *mp;
d148 1
a148 1
	    (mp = malloc(nswapmap * sizeof(*mp))) == NULL) {
d160 1
d163 2
a164 1
	s = nswapmap * sizeof(*mp);
@


1.5
log
@avoid buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.4 1996/06/26 05:40:11 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.4 1996/06/26 05:40:11 deraadt Exp $";
d131 1
a131 1
				if (strlen(msgbuf) strlen(syms[i].n_name) +2 >
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: swap.c,v 1.5 1996/05/10 23:16:38 thorpej Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: swap.c,v 1.5 1996/05/10 23:16:38 thorpej Exp $";
d131 3
@


1.3
log
@libutil
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: swap.c,v 1.5 1996/05/10 23:16:38 thorpej Exp $";
@


1.2
log
@Fix a bit, so it's now compiles.
needs more work to do disk stats the way vmstat do.
@
text
@d1 1
a1 1
/*	$NetBSD: swap.c,v 1.4 1995/08/31 22:20:19 jtc Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: swap.c,v 1.4 1995/08/31 22:20:19 jtc Exp $";
a65 2

extern kvm_t	*kd;
@


1.1
log
@Initial revision
@
text
@d67 1
a67 1
kvm_t	*kd;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
