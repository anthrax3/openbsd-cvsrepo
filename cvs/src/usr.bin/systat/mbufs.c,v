head	1.41;
access;
symbols
	OPENBSD_6_1:1.41.0.6
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.32.0.14
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.14
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2016.04.04.16.26.00;	author sthen;	state Exp;
branches;
next	1.40;
commitid	NOQPmnaJyaxPCccu;

1.40
date	2015.04.18.09.32.59;	author jsg;	state Exp;
branches;
next	1.39;
commitid	FPFfymGoym9isFLa;

1.39
date	2015.01.20.18.26.57;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	qRSGCXxt7yQIBAcS;

1.38
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	waQzIVMqUqjBDjYt;

1.37
date	2014.11.06.12.50.55;	author dlg;	state Exp;
branches;
next	1.36;
commitid	EQh8ErJ4zFhY4Cv3;

1.36
date	2014.10.20.07.06.00;	author jsg;	state Exp;
branches;
next	1.35;
commitid	o3zmcsOzYpVkyhsf;

1.35
date	2014.07.08.05.35.19;	author dlg;	state Exp;
branches;
next	1.34;
commitid	0QJleeeWqZmC5anF;

1.34
date	2014.07.02.00.12.34;	author dlg;	state Exp;
branches;
next	1.33;
commitid	zNbAzxmEBZMksTSx;

1.33
date	2014.06.13.07.31.18;	author mpi;	state Exp;
branches;
next	1.32;
commitid	J8b2xv3HsT6DZkMr;

1.32
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2010.11.05.10.07.30;	author claudio;	state Exp;
branches;
next	1.30;

1.30
date	2010.11.02.10.24.34;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.23.10.49.55;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.01.05.30.13;	author blambert;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.01.03.09.48;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.23.21.44.33;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.23.21.30.14;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.20.20.30.41;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.29.21.51.54;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.27.09.18.37;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.31.05.37.24;	author canacar;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.18.19.46.39;	author canacar;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.17.08.21.43;	author canacar;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.16.33.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.03.22.25.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.18.00.46.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.09.05.16.20;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.07.07.57.35;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.04.16.48.34;	author ericj;	state Exp;
branches;
next	1.4;

1.4
date	97.12.19.09.03.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.08;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.02.19.40.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Add sys/queue.h where it's needed. Unbreak userland following recent
removal from mbuf.h.  ok mpi@@
@
text
@/*	$OpenBSD: mbufs.c,v 1.40 2015/04/18 09:32:59 jsg Exp $ */
/*
 * Copyright (c) 2008 Can Erkin Acar <canacar@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/signal.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/queue.h>
#include <sys/mbuf.h>
#include <sys/pool.h>
#include <net/if.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <err.h>
#include <errno.h>
#include <ifaddrs.h>
#include <stdlib.h>
#include <string.h>

#include "systat.h"

/* pool info */
int mbpool_index = -1;
int mclpools_index[MCLPOOLS];
int mclpool_count = 0;
struct kinfo_pool mbpool;
u_int mcllivelocks, mcllivelocks_cur, mcllivelocks_diff;

/* interfaces */
static int num_ifs = 0;
struct if_info {
	char name[16];
	struct if_rxrinfo data;
} *interfaces = NULL;

static int sock;

void print_mb(void);
int read_mb(void);
int select_mb(void);
static void showmbuf(struct if_info *, int, int);

/* Define fields */
field_def fields_mbuf[] = {
	{"IFACE", 8, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"RXDELAY", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"TXDELAY", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"LIVELOCKS", 5, 10, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"SIZE", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"ALIVE", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"LWM", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"HWM", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"CWM", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
};


#define FLD_MB_IFACE	FIELD_ADDR(fields_mbuf,0)
#define FLD_MB_RXDELAY	FIELD_ADDR(fields_mbuf,1)
#define FLD_MB_TXDELAY	FIELD_ADDR(fields_mbuf,2)
#define FLD_MB_LLOCKS	FIELD_ADDR(fields_mbuf,3)
#define FLD_MB_MSIZE	FIELD_ADDR(fields_mbuf,4)
#define FLD_MB_MALIVE	FIELD_ADDR(fields_mbuf,5)
#define FLD_MB_MLWM	FIELD_ADDR(fields_mbuf,6)
#define FLD_MB_MHWM	FIELD_ADDR(fields_mbuf,7)
#define FLD_MB_MCWM	FIELD_ADDR(fields_mbuf,8)


/* Define views */
field_def *view_mbuf[] = {
	FLD_MB_IFACE,
	FLD_MB_LLOCKS, FLD_MB_MSIZE, FLD_MB_MALIVE, FLD_MB_MLWM, FLD_MB_MHWM,
	FLD_MB_MCWM, NULL
};

/* Define view managers */

struct view_manager mbuf_mgr = {
	"Mbufs", select_mb, read_mb, NULL, print_header,
	print_mb, keyboard_callback, NULL, NULL
};

field_view views_mb[] = {
	{view_mbuf, "mbufs", '4', &mbuf_mgr},
	{NULL, NULL, 0, NULL}
};


int
initmembufs(void)
{
	struct if_rxring_info *ifr;
	field_view *v;
	int i, mib[4], npools;
	struct kinfo_pool pool;
	char pname[32];
	size_t size;

	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == -1) {
		err(1, "socket()");
		/* NOTREACHED */
	}

	/* set up the "System" interface */

	interfaces = calloc(1, sizeof(*interfaces));
	if (interfaces == NULL)
		err(1, "calloc: interfaces");

	ifr = calloc(MCLPOOLS, sizeof(*ifr));
	if (ifr == NULL)
		err(1, "calloc: system pools");

	strlcpy(interfaces[0].name, "System", sizeof(interfaces[0].name));
	interfaces[0].data.ifri_total = MCLPOOLS;
	interfaces[0].data.ifri_entries = ifr;
	num_ifs = 1;

	/* go through all pools to identify mbuf and cluster pools */

	mib[0] = CTL_KERN;
	mib[1] = KERN_POOL;
	mib[2] = KERN_POOL_NPOOLS;
	size = sizeof(npools);

	if (sysctl(mib, 3, &npools, &size, NULL, 0) < 0) {
		err(1, "sysctl(KERN_POOL_NPOOLS)");
		/* NOTREACHED */
	}

	for (i = 1; i <= npools; i++) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_POOL;
		mib[2] = KERN_POOL_NAME;
		mib[3] = i;
		size = sizeof(pname);
		if (sysctl(mib, 4, &pname, &size, NULL, 0) < 0) {
			continue;
		}

		if (strcmp(pname, "mbufpl") == 0) {
			mbpool_index = i;
			continue;
		}

		if (strncmp(pname, "mcl", 3) != 0)
			continue;

		if (mclpool_count == MCLPOOLS) {
			warnx("mbufs: Too many mcl* pools");
			break;
		}

		mib[2] = KERN_POOL_POOL;
		size = sizeof(pool);

		if (sysctl(mib, 4, &pool, &size, NULL, 0) < 0) {
			err(1, "sysctl(KERN_POOL_POOL, %d)", i);
			/* NOTREACHED */
		}

		snprintf(ifr[mclpool_count].ifr_name,
		    sizeof(ifr[mclpool_count].ifr_name), "%dk",
		    pool.pr_size / 1024);
		ifr[mclpool_count].ifr_size = pool.pr_size;

		mclpools_index[mclpool_count++] = i;
	}

	if (mclpool_count != MCLPOOLS)
		warnx("mbufs: Unable to read all %d mcl* pools", MCLPOOLS);

	/* add view to the engine */
	for (v = views_mb; v->name != NULL; v++)
		add_view(v);

	/* finally read it once */
	read_mb();

	return(1);
}

int
select_mb(void)
{
	num_disp = 0;
	return (0);
}

int
read_mb(void)
{
	struct kinfo_pool pool;
	struct ifaddrs *ifap = NULL, *ifa;
	struct if_info *ifi;
	struct if_rxring_info *ifr;
	int mib[4];
	int i, p, nif, ret = 1, rv;
	u_int rings;
	size_t size;

	mib[0] = CTL_KERN;
	mib[1] = KERN_NETLIVELOCKS;
	size = sizeof(mcllivelocks_cur);
	if (sysctl(mib, 2, &mcllivelocks_cur, &size, NULL, 0) < 0 &&
	    errno != EOPNOTSUPP) {
		error("sysctl(KERN_NETLIVELOCKS)");
		goto exit;
	}
	mcllivelocks_diff = mcllivelocks_cur - mcllivelocks;
	mcllivelocks = mcllivelocks_cur;

	num_disp = 0;
	if (getifaddrs(&ifap)) {
		error("getifaddrs: %s", strerror(errno));
		return (1);
	}

	nif = 1;
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL ||
		    ifa->ifa_addr->sa_family != AF_LINK)
			continue;

		nif++;
	}

	if (num_ifs < nif) {
		ifi = reallocarray(interfaces, nif, sizeof(*interfaces));
		if (ifi == NULL) {
			error("reallocarray: %d interfaces", nif);
			goto exit;
		}

		interfaces = ifi;
		while (num_ifs < nif)
			memset(&interfaces[num_ifs++], 0, sizeof(*interfaces));
	}

	/* Fill in the "real" interfaces */
	ifi = interfaces + 1;

	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
		if (ifa->ifa_addr == NULL ||
		    ifa->ifa_addr->sa_family != AF_LINK)
			continue;
			
		strlcpy(ifi->name, ifa->ifa_name, sizeof(ifi->name));
		for (;;) {
			struct ifreq ifreq;
			rings = ifi->data.ifri_total;

			memset(&ifreq, 0, sizeof(ifreq));
			strlcpy(ifreq.ifr_name, ifa->ifa_name,
			    sizeof(ifreq.ifr_name));
			ifreq.ifr_data = (caddr_t)&ifi->data;

			rv = ioctl(sock, SIOCGIFRXR, &ifreq);
			if (rv == -1) {
				if (errno == ENOTTY) {
					free(ifi->data.ifri_entries);
					ifi->data.ifri_total = 0;
					ifi->data.ifri_entries = NULL;
					break;
				}

				error("ioctl(SIOCGIFRXR) %s", strerror(errno));
				break;
			}

			if (rings >= ifi->data.ifri_total)
				break;  

			ifr = reallocarray(ifi->data.ifri_entries,
			    ifi->data.ifri_total, sizeof(*ifr));
			if (ifr == NULL) {
				ifi->data.ifri_total = rings;
				error("reallocarray: %u rings",
				    ifi->data.ifri_total);
				goto exit;
			}

			ifi->data.ifri_entries = ifr;
		}

		ifi++;
	}

	/* Fill in the "System" entry from pools */

	mib[0] = CTL_KERN;
	mib[1] = KERN_POOL;
	mib[2] = KERN_POOL_POOL;
	mib[3] = mbpool_index;
	size = sizeof(mbpool);

	if (sysctl(mib, 4, &mbpool, &size, NULL, 0) < 0) {
		error("sysctl(KERN_POOL_POOL, %d)", mib[3]);
		goto exit;
	}

	for (i = 0; i < mclpool_count; i++) {
		ifr = &interfaces[0].data.ifri_entries[i];

		mib[3] = mclpools_index[i];
		size = sizeof(pool);

		if (sysctl(mib, 4, &pool, &size, NULL, 0) < 0) {
			error("sysctl(KERN_POOL_POOL, %d)", mib[3]);
			continue;
		}

		ifr->ifr_info.rxr_alive = pool.pr_nget - pool.pr_nput;
		ifr->ifr_info.rxr_hwm = pool.pr_hiwat;
	}

	num_disp = 1;
	ret = 0;

	for (i = 0; i < num_ifs; i++) {
		struct if_info *ifi = &interfaces[i];
		int pnd = num_disp;
		for (p = 0; p < ifi->data.ifri_total; p++) {
			ifr = &ifi->data.ifri_entries[p];
			if (ifr->ifr_info.rxr_alive == 0)
				continue;
			num_disp++;
		}
		if (i && pnd == num_disp)
			num_disp++;
	}

 exit:
	if (ifap)
		freeifaddrs(ifap);
	return (ret);
}

void
print_mb(void)
{
	int i, p, n, count = 0;

	showmbuf(interfaces, -1, 1);

	for (n = i = 0; i < num_ifs; i++) {
		struct if_info *ifi = &interfaces[i];
		int pcnt = count;
		int showif = i;

		if (maxprint > 0 && count >= maxprint)
			return;

		for (p = 0; p < ifi->data.ifri_total; p++) {
			struct if_rxring_info *ifr = &ifi->data.ifri_entries[p];
			if (ifr->ifr_info.rxr_alive == 0)
				continue;
			if (n++ >= dispstart) {
				showmbuf(ifi, p, showif);
				showif = 0;
				count++;
			}
		}

		if (i && pcnt == count) {
			/* only print the first line */
			if (n++ >= dispstart) {
				showmbuf(ifi, -1, 1);
				count++;
			}
		}
	}
}


static void
showmbuf(struct if_info *ifi, int p, int showif)
{
	if (showif)
		print_fld_str(FLD_MB_IFACE, ifi->name);

	if (p == -1 && ifi == interfaces) {
		print_fld_uint(FLD_MB_LLOCKS, mcllivelocks_diff);
		print_fld_size(FLD_MB_MSIZE, mbpool.pr_size);
		print_fld_size(FLD_MB_MALIVE, mbpool.pr_nget - mbpool.pr_nput);
		print_fld_size(FLD_MB_MHWM, mbpool.pr_hiwat);
	}

	if (p >= 0 && p < mclpool_count) {
		struct if_rxring_info *ifr = &ifi->data.ifri_entries[p];
		struct if_rxring *rxr= &ifr->ifr_info;
		print_fld_uint(FLD_MB_MSIZE, ifr->ifr_size);
		print_fld_uint(FLD_MB_MALIVE, rxr->rxr_alive);
		if (rxr->rxr_lwm)
			print_fld_size(FLD_MB_MLWM, rxr->rxr_lwm);
		if (rxr->rxr_hwm)
			print_fld_size(FLD_MB_MHWM, rxr->rxr_hwm);
		if (rxr->rxr_cwm)
			print_fld_size(FLD_MB_MCWM, rxr->rxr_cwm);
	}

	end_line();
}
@


1.40
log
@Avoid calling freeifaddrs() with an uninitialised pointer in an
error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.39 2015/01/20 18:26:57 deraadt Exp $ */
d21 1
@


1.39
log
@Adjust <sys/param.h> comments regarding use of use of MSIZE, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.38 2015/01/16 00:03:37 deraadt Exp $ */
d207 1
a207 1
	struct ifaddrs *ifap, *ifa;
d347 2
a348 1
	freeifaddrs(ifap);
@


1.38
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.37 2014/11/06 12:50:55 dlg Exp $ */
a17 1
#include <sys/param.h>	/* MSIZE */
@


1.37
log
@i renamed the mbuf pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.36 2014/10/20 07:06:00 jsg Exp $ */
d17 3
a19 2
#include <sys/param.h>
#include <sys/types.h>
@


1.36
log
@fix if (statement);
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.35 2014/07/08 05:35:19 dlg Exp $ */
d154 1
a154 1
		if (strcmp(pname, "mbpl") == 0) {
@


1.35
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.34 2014/07/02 00:12:34 dlg Exp $ */
d338 1
a338 1
			if (ifr->ifr_info.rxr_alive == 0);
@


1.34
log
@info about pools is currently given to userland by copying each
pools struct out. however, struct pool in the kernel contains lots
of things that userland probably isnt interested in, like actual
mutexes, and probably shouldnt get easy access to, like pointers
to kernel memory via all the lists/trees.

this implements a kinfo_pool structure that has only the data that
userland needs to know about. it cuts the sysctl code over to
building it from struct pool as required and copying that out
instead, and cuts userland over to only handling kinfo_pool.

the only problem with this is vmstat, which can read kernel images
via kvm, which needs some understanding of struct pool. to cope,
the struct pool definition is guarded by if defined(_KERNEL) ||
defined(_LIBKVM) as inspired by sysctl which needs to do the same
thing sometimes. struct pool itself is generally not visible to
userland though, which is good.

matthew@@ suggested struct kinfo_pool instead of struct pool_info.
the kinfo prefix has precedent.
lots of people liked this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.33 2014/06/13 07:31:18 mpi Exp $ */
d24 2
d35 3
a37 8

/* pool info for mcl* pools */
struct mclpool_info {
	char title[16];
	int pool_offset;
	int size;
} mclpools[MCLPOOLS];

a38 1
int mbpool_index = -1;
d43 1
a43 1
static int num_ifs;
d46 1
a46 1
	struct if_data data;
d49 2
a55 1

d104 1
d111 21
a132 1
	bzero(mclpools, sizeof(mclpools));
d175 2
a176 4
		mclpools[mclpool_count].size = pool.pr_size;
		mclpools[mclpool_count].pool_offset = i;
		snprintf(mclpools[mclpool_count].title,
		    sizeof(mclpools[0].title), "%dk",
d178 1
d180 1
a180 1
		mclpool_count++;
a189 1

d209 1
d211 2
a212 1
	int i, p, nif, ret = 1;
d233 7
a239 10
	for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next)
		if (ifa->ifa_addr && ifa->ifa_addr->sa_family == AF_LINK)
			nif++;

	if (interfaces == NULL || num_ifs < nif) {
		size_t len = sizeof(*ifi) * nif;
		if (nif > SIZE_MAX / sizeof(*ifi)) {
			error("overflow allocting %u interfaces", nif);
			goto exit;
		}
d241 2
a242 1
		ifi = realloc(interfaces, len);
d244 1
a244 2
			error("realloc: out of memory allocating %lld bytes",
			      (long long) len);
d249 2
a250 1
		num_ifs = nif;
d262 36
a298 4
		if (ifa->ifa_data)
			memcpy(&ifi->data, ifa->ifa_data, sizeof(ifi->data));
		else
			bzero(&ifi->data, sizeof(ifi->data));
a302 2
	bzero(interfaces, sizeof(interfaces[0]));
	strlcpy(interfaces[0].name, "System", sizeof(interfaces[0].name));
d316 1
a316 1
		struct mclpool *mp = &interfaces[0].data.ifi_mclpool[i];
d318 1
a318 1
		mib[3] = mclpools[i].pool_offset;
d326 2
a327 3
		mp->mcl_livelocks = mcllivelocks;
		mp->mcl_alive = pool.pr_nget - pool.pr_nput;
		mp->mcl_hwm = pool.pr_hiwat;
d336 3
a338 3
		for (p = 0; p < mclpool_count; p++) {
			struct mclpool *mp = &ifi->data.ifi_mclpool[p];
			if (mp->mcl_alive == 0)
d366 3
a368 3
		for (p = 0; p < mclpool_count; p++) {
			struct mclpool *mp = &ifi->data.ifi_mclpool[p];
			if (mp->mcl_alive == 0)
a383 2


d402 10
a411 14
		struct mclpool *mp = &ifi->data.ifi_mclpool[p];
		int livelocks_diff;

		livelocks_diff = mp->mcl_livelocks - mcllivelocks;
		if (livelocks_diff)
			print_fld_uint(FLD_MB_LLOCKS, livelocks_diff);
		print_fld_str(FLD_MB_MSIZE, mclpools[p].title);
		print_fld_uint(FLD_MB_MALIVE, mp->mcl_alive);
		if (mp->mcl_lwm)
			print_fld_size(FLD_MB_MLWM, mp->mcl_lwm);
		if (mp->mcl_hwm)
			print_fld_size(FLD_MB_MHWM, mp->mcl_hwm);
		if (mp->mcl_cwm)
			print_fld_size(FLD_MB_MCWM, mp->mcl_cwm);
@


1.33
log
@Now that the water marks are updated on a per-pool basis indicate in
the LIVELOCKS column if there is a pending (deferred) update.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.32 2011/03/02 06:48:17 jasper Exp $ */
d43 1
a43 1
struct pool mbpool;
d109 1
a109 1
	struct pool pool;
d150 1
a150 1
		size = sizeof(struct pool);
d190 1
a190 1
	struct pool pool;
d262 1
a262 1
	size = sizeof(struct pool);
d273 1
a273 1
		size = sizeof(struct pool);
@


1.32
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.31 2010/11/05 10:07:30 claudio Exp $ */
a86 3
#if NOTYET
	FLD_MB_RXDELAY, FLD_MB_TXDELAY,
#endif
d280 1
a357 5
#if NOTYET
	print_fld_uint(FLD_MB_RXDELAY, ifi->data.ifi_rxdelay);
	print_fld_uint(FLD_MB_TXDELAY, ifi->data.ifi_txdelay);
#endif

d360 1
d362 3
@


1.31
log
@Print relativ number of livelocks that happend between two systat
updates instead of showing absolut figures. Makes it easier to
estimate the "livelockyness" of a system.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.30 2010/11/02 10:24:34 dlg Exp $ */
d73 9
a81 11
#define FIELD_ADDR(x) (&fields_mbuf[x])

#define FLD_MB_IFACE	FIELD_ADDR(0)
#define FLD_MB_RXDELAY	FIELD_ADDR(1)
#define FLD_MB_TXDELAY	FIELD_ADDR(2)
#define FLD_MB_LLOCKS	FIELD_ADDR(3)
#define FLD_MB_MSIZE	FIELD_ADDR(4)
#define FLD_MB_MALIVE	FIELD_ADDR(5)
#define FLD_MB_MLWM	FIELD_ADDR(6)
#define FLD_MB_MHWM	FIELD_ADDR(7)
#define FLD_MB_MCWM	FIELD_ADDR(8)
@


1.30
log
@expose the kernels network livelock counter
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.29 2010/09/23 10:49:55 dlg Exp $ */
d44 1
a44 1
u_int mcllivelocks = 0;
d204 2
a205 2
	size = sizeof(mcllivelocks);
	if (sysctl(mib, 2, &mcllivelocks, &size, NULL, 0) < 0 &&
d210 2
d356 1
a356 1
		print_fld_uint(FLD_MB_LLOCKS, mcllivelocks);
@


1.29
log
@tweak the mclgeti algorithm to behave better under load.

instead of letting hardware rings grow on every interrupt, restrict
it so it can only grow once per softclock tick. we can only punish
the rings on softclock ticks, so it make sense to only grow on
softclock tick boundaries too.

the rings are now punished after >1 lost softclock tick rather than
>2. mclgeti is now more aggressive at detecting livelock.

the rings get punished by an 8th, rather than by half.

we now allow the rings to be punished again even if the system is
already considered in livelock.

without this diff a livelocked system will have its rx ring sizes
scale up and down very rapidly, while holding the rings low for too
long. this affected throughput significantly.

discussed and tested heavily at j2k10. there are still some games
with softnet we can play, but this is a good first step.

"put it in" and ok deraadt@@
ok claudio@@ krw@@ henning@@ mcbride@@

if we find out that it sucks we can pull it out again later. till then
we'll run with it and see how it goes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.28 2010/08/01 05:30:13 blambert Exp $ */
d44 1
d202 9
d354 1
a362 2
	if (ifi->data.ifi_livelocks)
		print_fld_size(FLD_MB_LLOCKS, ifi->data.ifi_livelocks);
@


1.28
log
@don't rely on mbuf.h to pull in pool.h here either

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.27 2010/08/01 03:09:48 chl Exp $ */
a351 1
#endif
d354 1
@


1.27
log
@fix use of uninitialized variable.

reported by gcc.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.26 2009/11/23 21:44:33 henning Exp $ */
d22 1
@


1.26
log
@args, not that file
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.24 2009/04/20 20:30:41 chl Exp $ */
d257 1
a257 1
		error("sysctl(KERN_POOL_POOL, %d)", i);
@


1.25
log
@no more natpass
@
text
@a61 1
	{"CURTX", 3, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
d76 6
a81 7
#define FLD_MB_CURTX	FIELD_ADDR(3)
#define FLD_MB_LLOCKS	FIELD_ADDR(4)
#define FLD_MB_MSIZE	FIELD_ADDR(5)
#define FLD_MB_MALIVE	FIELD_ADDR(6)
#define FLD_MB_MLWM	FIELD_ADDR(7)
#define FLD_MB_MHWM	FIELD_ADDR(8)
#define FLD_MB_MCWM	FIELD_ADDR(9)
d90 2
a91 2
	FLD_MB_CURTX, FLD_MB_LLOCKS, FLD_MB_MSIZE, FLD_MB_MALIVE, FLD_MB_MLWM,
	FLD_MB_MHWM, FLD_MB_MCWM, NULL
a346 2
	if (showif && p != -1)
		print_fld_uint(FLD_MB_CURTX, ifi->data.ifi_maxtx);
@


1.24
log
@remove unneeded argument to warnx()
remove unused variable
kill some extra blank lines

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.23 2009/03/29 21:51:54 kettenis Exp $ */
d62 1
d77 7
a83 6
#define FLD_MB_LLOCKS	FIELD_ADDR(3)
#define FLD_MB_MSIZE	FIELD_ADDR(4)
#define FLD_MB_MALIVE	FIELD_ADDR(5)
#define FLD_MB_MLWM	FIELD_ADDR(6)
#define FLD_MB_MHWM	FIELD_ADDR(7)
#define FLD_MB_MCWM	FIELD_ADDR(8)
d92 2
a93 2
	FLD_MB_LLOCKS, FLD_MB_MSIZE, FLD_MB_MALIVE, FLD_MB_MLWM, FLD_MB_MHWM,
	FLD_MB_MCWM, NULL
d349 2
@


1.23
log
@Make sure systat mbufs prints the interface name even if an interface only
allocates clusters larger than 2k.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.22 2009/01/27 09:18:37 dlg Exp $ */
d148 1
a148 1
			warnx("mbufs: Too many mcl* pools", i);
a338 2
	int i;

a347 2


a369 2


@


1.22
log
@fix the mbuf view to cope with the recent change to the mclgeti allocator.

from canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.20 2008/12/18 19:46:39 canacar Exp $ */
d54 1
a54 2
static void
showmbuf(struct if_info *, int);
d302 1
a302 1
	showmbuf(interfaces, -1);
d307 2
d317 2
a318 1
				showmbuf(ifi, p);
d326 1
a326 1
				showmbuf(ifi, -1);
d337 1
a337 1
showmbuf(struct if_info *ifi, int p)
d341 1
a341 1
	if (p == -1 || (p == 0 && ifi != interfaces)) {
a342 1
	}
@


1.21
log
@Skip missing pool indices instead of printing errors.
@
text
@d68 1
d82 1
d92 1
a92 1
	NULL
a272 1
		mp->mcl_size = pool.pr_size;
a284 2
			if (mp->mcl_size != (ushort)mclpools[p].size)
				break;
a312 2
			if (mp->mcl_size != (ushort)mclpools[p].size)
				break;
d367 2
@


1.20
log
@Print the interface livelocks if non-zero. From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.19 2008/12/17 08:21:43 canacar Exp $ */
d135 1
a135 2
			err(1, "sysctl(KERN_POOL_POOLNAME, %d)", i);
			/* NOTREACHED */
@


1.19
log
@Rewrite the 'mbuf' page to display mbuf usage information from system pools
and mbuf cluster statistics collected for each interface. More useful than
earlier bar graphs about mbuf types. Requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a342 2


a357 1
	print_fld_size(FLD_MB_LLOCKS, ifi->data.ifi_txdelay);
d359 2
@


1.18
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 3
a3 6
/*	$OpenBSD: mbufs.c,v 1.17 2007/02/25 18:21:24 deraadt Exp $	*/
/*	$NetBSD: mbufs.c,v 1.2 1995/01/20 08:52:02 jtc Exp $	*/

/*-
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
d5 3
a7 11
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d9 7
a15 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a16 1

d19 2
d22 1
a22 1
#include <sys/sysctl.h>
d24 3
d29 1
a29 2
#include <err.h>
#include <paths.h>
d33 18
d54 2
a55 1
static void showmbuf(int);
a56 1
static struct mbstat mb;
d58 10
a67 15
char *mtnames[] = {
	"free",
	"data",
	"headers",
	"sockets",
	"pcbs",
	"routes",
	"hosts",
	"arps",
	"socknames",
	"zombies",
	"sockopts",
	"frags",
	"rights",
	"ifaddrs",
a69 2
#define NUM_TYPES (sizeof(mb.m_mtypes) / sizeof(mb.m_mtypes[0]))
#define	NNAMES	(sizeof (mtnames) / sizeof (mtnames[0]))
d71 1
a71 2
int mb_index[NUM_TYPES];
int mbuf_cnt = 0;
d73 8
a81 11
field_def fields_mb[] = {
	{"TYPE", 6, 16, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"VALUE", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"", 40, 80, 1, FLD_ALIGN_BAR, -1, 0, 0, 60},
};

#define FIELD_ADDR(x) (&fields_mb[x])

#define FLD_MB_NAME	FIELD_ADDR(0)
#define FLD_MB_VALUE	FIELD_ADDR(1)
#define FLD_MB_BAR	FIELD_ADDR(2)
d84 7
a90 2
field_def *view_mb_0[] = {
	FLD_MB_NAME, FLD_MB_VALUE, FLD_MB_BAR, NULL
d93 1
a94 1
/* Define view managers */
d101 1
a101 1
	{view_mb_0, "mbufs", '4', &mbuf_mgr},
d107 1
a107 1
select_mb(void)
d109 8
a116 1
	int i, w = 50;
d118 60
a178 3
	for (i = 0; i < NUM_TYPES; i++)
		if (w < (5 * mb.m_mtypes[i] / 4))
			w = 5 * mb.m_mtypes[i] / 4;
d180 2
a181 2
	w -= w % 10;
	FLD_MB_BAR->arg = w;
d183 4
d193 56
a248 2
	int mib[2], i;
	size_t size = sizeof (mb);
d251 15
a265 1
	mib[1] = KERN_MBSTAT;
d267 8
a274 3
	if (sysctl(mib, 2, &mb, &size, NULL, 0) < 0) {
		error("sysctl(KERN_MBSTAT) failed");
		return 1;
d277 2
a278 2
	mbuf_cnt = 0;
	memset(mb_index, 0, sizeof(mb_index));
d280 13
a292 3
	for (i = 0; i < NUM_TYPES; i++) {
		if (mb.m_mtypes[i])
			mb_index[mbuf_cnt++] = i;
d295 3
a297 3
	num_disp = mbuf_cnt;

	return 0;
a299 1

d303 1
a303 1
	int n, count = 0;
d305 5
a309 3
	for (n = dispstart; n < num_disp; n++) {
		showmbuf(n);
		count++;
d311 1
a311 3
			break;
	}
}
d313 19
a331 4
int
initmembufs(void)
{
	field_view *v;
a332 2
	for (v = views_mb; v->name != NULL; v++)
		add_view(v);
d334 1
a334 1
	return(1);
d339 1
a339 1
showmbuf(int m)
a342 1
	i = mb_index[m];
a343 4
	if (i < NNAMES)
		print_fld_str(FLD_MB_NAME, mtnames[i]);
	else
		print_fld_uint(FLD_MB_NAME, i);
d345 28
a372 2
	print_fld_uint(FLD_MB_VALUE, mb.m_mtypes[i]);
	print_fld_bar(FLD_MB_BAR, mb.m_mtypes[i]);
@


1.17
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.16 2006/03/31 04:10:59 deraadt Exp $	*/
a32 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)mbufs.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.16 2006/03/31 04:10:59 deraadt Exp $";
#endif /* not lint */

d43 6
a48 1
#include "extern.h"
d69 1
d72 36
a107 2
WINDOW *
openmbufs(void)
d109 11
a119 1
	return (subwin(stdscr, LINES-1-2, 0, 2, 0));
d122 2
a123 2
void
closembufs(WINDOW *w)
d125 22
a146 5
	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
a148 8
void
labelmbufs(void)
{
	wmove(wnd, 0, 0);
	wclrtoeol(wnd);
	mvwaddstr(wnd, 0, 10,
	    "/0   /5   /10  /15  /20  /25  /30  /35  /40  /45  /50  /55  /60");
}
d151 1
a151 1
showmbufs(void)
d153 1
a153 2
	int i, j, max, ind;
	char buf[13];
d155 4
a158 8
	for (j = 0; j < wnd->_maxy; j++) {
		max = 0, ind = -1;
		for (i = 0; i < wnd->_maxy; i++)
			if (mb.m_mtypes[i] > max) {
				max = mb.m_mtypes[i];
				ind = i;
			}
		if (max == 0)
a159 17
		if (j > NNAMES)
			mvwprintw(wnd, 1+j, 0, "%10d", ind);
		else
			mvwprintw(wnd, 1+j, 0, "%-10.10s", mtnames[ind]);
		wmove(wnd, 1 + j, 10);
		if (max > 60) {
			snprintf(buf, sizeof buf, " %d", max);
			max = 60;
			while (max--)
				waddch(wnd, 'X');
			waddstr(wnd, buf);
		} else {
			while (max--)
				waddch(wnd, 'X');
			wclrtoeol(wnd);
		}
		mb.m_mtypes[ind] = 0;
a160 2
	wmove(wnd, 1+j, 0);
	wclrtobot(wnd);
d163 4
d168 2
a169 5
void
fetchmbufs(void)
{
	int mib[2];
	size_t size = sizeof (mb);
d171 1
a171 4
	mib[0] = CTL_KERN;
	mib[1] = KERN_MBSTAT;
	if (sysctl(mib, 2, &mb, &size, NULL, 0) < 0)
		err(1, "sysctl(KERN_MBSTAT) failed");
d174 3
a176 2
int
initmbufs(void)
d178 13
a190 1
	return (1);
d192 2
@


1.16
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.15 2004/07/09 16:33:15 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.15 2004/07/09 16:33:15 deraadt Exp $";
d76 1
a76 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
@


1.15
log
@post-mortem stuff can go away here too
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.14 2004/07/03 22:25:15 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.14 2004/07/03 22:25:15 deraadt Exp $";
d92 2
a93 1
	wmove(wnd, 0, 0); wclrtoeol(wnd);
d101 1
a101 1
	int i, j, max, index;
d105 1
a105 1
		max = 0, index = -1;
d109 1
a109 1
				index = i;
d114 1
a114 1
			mvwprintw(wnd, 1+j, 0, "%10d", index);
d116 1
a116 1
			mvwprintw(wnd, 1+j, 0, "%-10.10s", mtnames[index]);
d129 1
a129 1
		mb.m_mtypes[index] = 0;
d131 2
a132 1
	wmove(wnd, 1+j, 0); wclrtobot(wnd);
@


1.14
log
@move sysctl comment on namelist[] entry
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.13 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.13 2003/06/03 02:56:17 millert Exp $";
a46 1
#include <nlist.h>
d52 1
a52 1
static struct mbstat *mb;
a102 2
	if (mb == 0)
		return;
d106 2
a107 2
			if (mb->m_mtypes[i] > max) {
				max = mb->m_mtypes[i];
d128 1
a128 1
		mb->m_mtypes[index] = 0;
a132 5
static struct nlist namelist[] = {
#define	X_MBSTAT	0			/* sysctl */
	{ "_mbstat" },
	{ "" }
};
d134 2
a135 2
int
initmbufs(void)
d137 2
a138 1
	int ret;
d140 4
a143 15
	if (kd != NULL) {
		if (namelist[X_MBSTAT].n_type == 0) {
			if ((ret = kvm_nlist(kd, namelist)) == -1)
				errx(1, "%s", kvm_geterr(kd));
			else if (ret)
				nlisterr(namelist);
			if (namelist[X_MBSTAT].n_type == 0) {
				error("namelist on %s failed", _PATH_UNIX);
				return(0);
			}
		}
	}
	if (mb == 0)
		mb = (struct mbstat *)calloc(1, sizeof (*mb));
	return(1);
d146 2
a147 2
void
fetchmbufs(void)
d149 1
a149 13
	int mib[2];
	size_t size = sizeof (*mb);

	if (kd == NULL) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_MBSTAT;
		if (sysctl(mib, 2, mb, &size, NULL, 0) < 0)
			err(1, "sysctl(KERN_MBSTAT) failed");
	} else {
		if (namelist[X_MBSTAT].n_type == 0)
			return;
		NREAD(X_MBSTAT, mb, size);
	}
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.12 2002/06/19 08:45:52 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.12 2002/06/19 08:45:52 deraadt Exp $";
d137 2
a138 2
#define	X_MBSTAT	0
	{ "_mbstat" },			/* sysctl */
@


1.12
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.11 2002/06/18 00:46:47 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.11 2002/06/18 00:46:47 deraadt Exp $";
@


1.11
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.10 2002/06/09 05:16:20 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.10 2002/06/09 05:16:20 angelos Exp $";
d142 1
a142 1
	{ "_mbstat" },
@


1.10
log
@Use sysctl for mbstat
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.9 2001/12/07 09:18:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.9 2001/12/07 09:18:08 deraadt Exp $";
d79 1
a79 1
openmbufs()
d85 1
a85 2
closembufs(w)
	WINDOW *w;
d95 1
a95 1
labelmbufs()
d103 1
a103 1
showmbufs()
d147 1
a147 1
initmbufs()
d169 1
a169 1
fetchmbufs()
@


1.9
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.7 2001/11/23 22:20:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.7 2001/11/23 22:20:06 deraadt Exp $";
d47 1
d152 1
a152 5
	if (namelist[X_MBSTAT].n_type == 0) {
		if ((ret = kvm_nlist(kd, namelist)) == -1)
			errx(1, "%s", kvm_geterr(kd));
		else if (ret)
			nlisterr(namelist);
d154 8
a161 2
			error("namelist on %s failed", _PATH_UNIX);
			return(0);
d172 13
a184 3
	if (namelist[X_MBSTAT].n_type == 0)
		return;
	NREAD(X_MBSTAT, mb, sizeof (*mb));
@


1.8
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.6 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.6 2001/11/19 19:02:16 mpech Exp $";
d51 1
d111 1
a111 1
		max = 0, index = -1; 
@


1.7
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@a50 1
#include <err.h>
d110 1
a110 1
		max = 0, index = -1;
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.5 2001/05/04 16:48:34 ericj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.5 2001/05/04 16:48:34 ericj Exp $";
d51 1
d111 1
a111 1
		max = 0, index = -1; 
@


1.5
log
@
handle kvm_nlist() failing, from pr#1798.
Patch similar to the one submitted by <peterw@@documenta.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.4 1997/12/19 09:03:32 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.4 1997/12/19 09:03:32 deraadt Exp $";
d104 1
a104 1
	register int i, j, max, index;
@


1.4
log
@bye bye sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.3 1996/06/26 05:40:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.3 1996/06/26 05:40:08 deraadt Exp $";
d148 2
d151 3
a153 1
		if (kvm_nlist(kd, namelist)) {
a154 2
			return(0);
		}
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: mbufs.c,v 1.2 1995/01/20 08:52:02 jtc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mbufs.c,v 1.2 1995/01/20 08:52:02 jtc Exp $";
d105 1
a105 1
	char buf[10];
d124 1
a124 1
			sprintf(buf, " %d", max);
@


1.2
log
@it compiles w/ new curses
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: mbufs.c,v 1.2 1995/01/20 08:52:02 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d108 1
a108 1
	for (j = 0; j < wnd->maxy; j++) {
d110 1
a110 1
		for (i = 0; i < wnd->maxy; i++)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
