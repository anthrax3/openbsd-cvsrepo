head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.12
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.8
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8;
locks; strict;
comment	@ * @;


1.30
date	2015.01.16.00.03.38;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	waQzIVMqUqjBDjYt;

1.29
date	2014.10.08.04.10.04;	author doug;	state Exp;
branches;
next	1.28;
commitid	cpW0LtZf9XzHlFrl;

1.28
date	2014.07.09.08.04.45;	author jasper;	state Exp;
branches;
next	1.27;
commitid	ytTWZNy76UyKFHXr;

1.27
date	2012.09.20.20.11.58;	author yuo;	state Exp;
branches;
next	1.26;

1.26
date	2011.09.16.20.52.48;	author yuo;	state Exp;
branches;
next	1.25;

1.25
date	2011.09.16.15.44.31;	author yuo;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2010.04.21.19.40.59;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.21.04.07.13;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.20.20.49.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.20.19.44.07;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.15.04.57.29;	author yuo;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.14.15.29.19;	author cnst;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.25.20.45.43;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.25.20.40.33;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.25.20.39.02;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.29.04.51.59;	author cnst;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.23.14.48.22;	author ckuethe;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.23.06.56.40;	author ckuethe;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.23.01.10.38;	author ckuethe;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.04.21.17.37;	author deanna;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.25.22.36.40;	author steven;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.24.04.01.05;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.23.22.55.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.23.22.24.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.23.22.09.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.02.23.22.02.58;	author deanna;	state Exp;
branches;
next	;


desc
@@


1.30
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@/*	$OpenBSD: sensors.c,v 1.29 2014/10/08 04:10:04 doug Exp $	*/

/*
 * Copyright (c) 2007 Deanna Phillips <deanna@@openbsd.org>
 * Copyright (c) 2003 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2006 Constantine A. Murenin <cnst+openbsd@@bugmail.mojo.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include <sys/types.h>
#include <sys/signal.h>
#include <sys/sysctl.h>
#include <sys/sensors.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "systat.h"

struct sensor sensor;
struct sensordev sensordev;

struct sensinfo {
	int sn_dev;
	struct sensor sn_sensor;
};
#define sn_type sn_sensor.type
#define sn_numt sn_sensor.numt
#define sn_desc sn_sensor.desc
#define sn_status sn_sensor.status
#define sn_value sn_sensor.value

#define SYSTAT_MAXSENSORDEVICES 1024
char *devnames[SYSTAT_MAXSENSORDEVICES];

#define ADD_ALLOC 100
static size_t sensor_cnt = 0;
static size_t num_alloc = 0;
static struct sensinfo *sensors = NULL;

static char *fmttime(double);
static void showsensor(struct sensinfo *s);

void print_sn(void);
int read_sn(void);
int select_sn(void);

const char *drvstat[] = {
	NULL,
	"empty", "ready", "powering up", "online", "idle", "active",
	"rebuilding", "powering down", "failed", "degraded"
};


field_def fields_sn[] = {
	{"SENSOR", 16, 32, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"VALUE", 16, 20, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"STATUS", 5, 8, 1, FLD_ALIGN_CENTER, -1, 0, 0, 0},
	{"DESCRIPTION", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0}
};

#define FLD_SN_SENSOR	FIELD_ADDR(fields_sn,0)
#define FLD_SN_VALUE	FIELD_ADDR(fields_sn,1)
#define FLD_SN_STATUS	FIELD_ADDR(fields_sn,2)
#define FLD_SN_DESCR	FIELD_ADDR(fields_sn,3)

/* Define views */
field_def *view_sn_0[] = {
	FLD_SN_SENSOR, FLD_SN_VALUE, FLD_SN_STATUS, FLD_SN_DESCR, NULL
};


/* Define view managers */
struct view_manager sensors_mgr = {
	"Sensors", select_sn, read_sn, NULL, print_header,
	print_sn, keyboard_callback, NULL, NULL
};

field_view views_sn[] = {
	{view_sn_0, "sensors", '3', &sensors_mgr},
	{NULL, NULL, 0, NULL}
};

struct sensinfo *
next_sn(void)
{
	if (num_alloc <= sensor_cnt) {
		struct sensinfo *s;
		size_t a = num_alloc + ADD_ALLOC;
		if (a < num_alloc)
			return NULL;
		s = reallocarray(sensors, a, sizeof(struct sensinfo));
		if (s == NULL)
			return NULL;
		sensors = s;
		num_alloc = a;
	}

	return &sensors[sensor_cnt++];
}


int
select_sn(void)
{
	num_disp = sensor_cnt;
	return (0);
}

int
read_sn(void)
{
	enum sensor_type type;
	size_t		 slen, sdlen;
	int		 mib[5], dev, numt;
	struct sensinfo	*s;

	mib[0] = CTL_HW;
	mib[1] = HW_SENSORS;

	sensor_cnt = 0;

	for (dev = 0; dev < SYSTAT_MAXSENSORDEVICES; dev++) {
		mib[2] = dev;
		sdlen = sizeof(struct sensordev);
		if (sysctl(mib, 3, &sensordev, &sdlen, NULL, 0) == -1) {
			if (errno == ENOENT)
				break;
			if (errno == ENXIO)
				continue;
			error("sysctl: %s", strerror(errno));
		}

		if (devnames[dev] && strcmp(devnames[dev], sensordev.xname)) {
			free(devnames[dev]);
			devnames[dev] = NULL;
		}
		if (devnames[dev] == NULL)
			devnames[dev] = strdup(sensordev.xname);

		for (type = 0; type < SENSOR_MAX_TYPES; type++) {
			mib[3] = type;
			for (numt = 0; numt < sensordev.maxnumt[type]; numt++) {
				mib[4] = numt;
				slen = sizeof(struct sensor);
				if (sysctl(mib, 5, &sensor, &slen, NULL, 0)
				    == -1) {
					if (errno != ENOENT)
						error("sysctl: %s", strerror(errno));
					continue;
				}
				if (sensor.flags & SENSOR_FINVALID)
					continue;

				s = next_sn();
				s->sn_sensor = sensor;
				s->sn_dev = dev;
			}
		}
	}

	num_disp = sensor_cnt;
	return 0;
}


void
print_sn(void)
{
	int n, count = 0;

	for (n = dispstart; n < num_disp; n++) {
		showsensor(sensors + n);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}

int
initsensors(void)
{
	field_view *v;

	memset(devnames, 0, sizeof(devnames));

	for (v = views_sn; v->name != NULL; v++)
		add_view(v);

	return(1);
}

static void
showsensor(struct sensinfo *s)
{
	tb_start();
	tbprintf("%s.%s%d", devnames[s->sn_dev],
		 sensor_type_s[s->sn_type], s->sn_numt);
	print_fld_tb(FLD_SN_SENSOR);

	if (s->sn_desc[0] != '\0')
		print_fld_str(FLD_SN_DESCR, s->sn_desc);

	tb_start();

	switch (s->sn_type) {
	case SENSOR_TEMP:
		tbprintf("%10.2f degC",
		    (s->sn_value - 273150000) / 1000000.0);
		break;
	case SENSOR_FANRPM:
		tbprintf("%11lld RPM", s->sn_value);
		break;
	case SENSOR_VOLTS_DC:
		tbprintf("%10.2f V DC",
		    s->sn_value / 1000000.0);
		break;
	case SENSOR_VOLTS_AC:
		tbprintf("%10.2f V AC",
		    s->sn_value / 1000000.0);
		break;
	case SENSOR_OHMS:
		tbprintf("%11lld ohm", s->sn_value);
		break;
	case SENSOR_WATTS:
		tbprintf("%10.2f W", s->sn_value / 1000000.0);
		break;
	case SENSOR_AMPS:
		tbprintf("%10.2f A", s->sn_value / 1000000.0);
		break;
	case SENSOR_WATTHOUR:
		tbprintf("%12.2f Wh", s->sn_value / 1000000.0);
		break;
	case SENSOR_AMPHOUR:
		tbprintf("%10.2f Ah", s->sn_value / 1000000.0);
		break;
	case SENSOR_INDICATOR:
		tbprintf("%15s", s->sn_value ? "On" : "Off");
		break;
	case SENSOR_INTEGER:
		tbprintf("%11lld raw", s->sn_value);
		break;
	case SENSOR_PERCENT:
		tbprintf("%14.2f%%", s->sn_value / 1000.0);
		break;
	case SENSOR_LUX:
		tbprintf("%15.2f lx", s->sn_value / 1000000.0);
		break;
	case SENSOR_DRIVE:
		if (0 < s->sn_value &&
		    s->sn_value < sizeof(drvstat)/sizeof(drvstat[0])) {
			tbprintf("%15s", drvstat[s->sn_value]);
			break;
		}
		break;
	case SENSOR_TIMEDELTA:
		tbprintf("%15s", fmttime(s->sn_value / 1000000000.0));
		break;
	case SENSOR_HUMIDITY:
		tbprintf("%3.2f%%", s->sn_value / 1000.0);
		break;
	case SENSOR_FREQ:
		tbprintf("%11.2f Hz", s->sn_value / 1000000.0);
		break;
	case SENSOR_ANGLE:
		tbprintf("%3.4f degrees", s->sn_value / 1000000.0);
		break;
	case SENSOR_DISTANCE:
		tbprintf("%.2f mm", s->sn_value / 1000.0);
		break;
	case SENSOR_PRESSURE:
		tbprintf("%.2f Pa", s->sn_value / 1000.0);
		break;
	case SENSOR_ACCEL:
		tbprintf("%2.4f m/s^2", s->sn_value / 1000000.0);
		break;
	default:
		tbprintf("%10lld", s->sn_value);
		break;
	}

	print_fld_tb(FLD_SN_VALUE);

	switch (s->sn_status) {
	case SENSOR_S_UNSPEC:
		break;
	case SENSOR_S_UNKNOWN:
		print_fld_str(FLD_SN_STATUS, "unknown");
		break;
	case SENSOR_S_WARN:
		print_fld_str(FLD_SN_STATUS, "WARNING");
		break;
	case SENSOR_S_CRIT:
		print_fld_str(FLD_SN_STATUS, "CRITICAL");
		break;
	case SENSOR_S_OK:
		print_fld_str(FLD_SN_STATUS, "OK");
		break;
	}
	end_line();
}

#define SECS_PER_DAY 86400
#define SECS_PER_HOUR 3600
#define SECS_PER_MIN 60

static char *
fmttime(double in)
{
	int signbit = 1;
	int tiny = 0;
	char *unit;
#define LEN 32
	static char outbuf[LEN];

	if (in < 0){
		signbit = -1;
		in *= -1;
	}

	if (in >= SECS_PER_DAY ){
		unit = "days";
		in /= SECS_PER_DAY;
	} else if (in >= SECS_PER_HOUR ){
		unit = "hr";
		in /= SECS_PER_HOUR;
	} else if (in >= SECS_PER_MIN ){
		unit = "min";
		in /= SECS_PER_MIN;
	} else if (in >= 1 ){
		unit = "s";
		/* in *= 1; */ /* no op */
	} else if (in == 0 ){ /* direct comparisons to floats are scary */
		unit = "s";
	} else if (in >= 1e-3 ){
		unit = "ms";
		in *= 1e3;
	} else if (in >= 1e-6 ){
		unit = "us";
		in *= 1e6;
	} else if (in >= 1e-9 ){
		unit = "ns";
		in *= 1e9;
	} else {
		unit = "ps";
		if (in < 1e-13)
			tiny = 1;
		in *= 1e12;
	}

	snprintf(outbuf, LEN, 
	    tiny ? "%s%f %s" : "%s%.3f %s", 
	    signbit == -1 ? "-" : "", in, unit);

	return outbuf;
}
@


1.29
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.28 2014/07/09 08:04:45 jasper Exp $	*/
d22 2
a23 1
#include <sys/param.h>
@


1.28
log
@instead of printf() use tbprintf() like elsewhere in systat.

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.27 2012/09/20 20:11:58 yuo Exp $	*/
d105 1
a105 1
		s = realloc(sensors, a * sizeof(struct sensinfo));
@


1.27
log
@add more sensor types to sensor framework.
 - Pressure (10^-3 Pa)
 - distance (10^-6 m)
 - acceleration (10^-6 m/s^2)

ok deraadt@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.26 2011/09/16 20:52:48 yuo Exp $	*/
d282 1
a282 1
		printf("%.2f mm", s->sn_value / 1000.0);
d285 1
a285 1
		printf("%.2f Pa", s->sn_value / 1000.0);
d288 1
a288 1
		printf("%2.4f m/s^2", s->sn_value / 1000000.0);
@


1.26
log
@reorder SENSOR_* in switch() and add missing cases.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.25 2011/09/16 15:44:31 yuo Exp $	*/
d280 9
@


1.25
log
@apply following changes to sensor framework:
- change accuracy of SENSOR_FREQ from Hz to muHz
- add SENSOR_VOLTS_AC entry to userland programs

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.24 2011/03/02 06:48:17 jasper Exp $	*/
d227 4
d235 2
a236 3
	case SENSOR_VOLTS_DC:
		tbprintf("%10.2f V DC",
		    s->sn_value / 1000000.0);
d244 6
a270 6
		break;
	case SENSOR_WATTHOUR:
		tbprintf("%12.2f Wh", s->sn_value / 1000000.0);
		break;
	case SENSOR_AMPHOUR:
		tbprintf("%10.2f Ah", s->sn_value / 1000000.0);
@


1.24
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.23 2010/04/21 19:40:59 deraadt Exp $	*/
d227 4
d273 1
a273 1
		tbprintf("%11lld Hz", s->sn_value);
@


1.23
log
@scale angle by 1000000 to permit min.sec accuracy
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.22 2010/04/21 04:07:13 deraadt Exp $	*/
d75 4
a78 6
#define FIELD_ADDR(x) (&fields_sn[x])

#define FLD_SN_SENSOR	FIELD_ADDR(0)
#define FLD_SN_VALUE	FIELD_ADDR(1)
#define FLD_SN_STATUS	FIELD_ADDR(2)
#define FLD_SN_DESCR	FIELD_ADDR(3)
@


1.22
log
@Add the "angle" sensor, measured in degrees; from Luis Pinto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.21 2010/04/20 20:49:35 deraadt Exp $	*/
d274 1
a274 1
		tbprintf("%10lld deg", s->sn_value);
@


1.21
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.20 2010/04/20 19:44:07 oga Exp $	*/
d272 3
@


1.20
log
@Add "frequency" type for sensors. (and teach userland how to print that
type).  Measured in Hz.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.19 2010/04/15 04:57:29 yuo Exp $	*/
d46 2
a47 1
char *devnames[MAXSENSORDEVICES];
d138 1
a138 1
	for (dev = 0; dev < MAXSENSORDEVICES; dev++) {
d142 5
a146 3
			if (errno != ENOENT)
				error("sysctl: %s", strerror(errno));
			continue;
@


1.19
log
@add SENSOR_HUMIDITY to sensor framework to handle humidity values

ok kettenis@@ xsa@@ sobrado@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.18 2009/08/14 15:29:19 cnst Exp $	*/
d266 3
@


1.18
log
@SENSOR_WATTS;  ok canacar deraadt kettenis henning
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.17 2009/06/25 20:45:43 deraadt Exp $	*/
d263 3
@


1.17
log
@the rule is not to use nitems() in userland yet
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.16 2009/06/25 20:40:33 okan Exp $	*/
d229 3
@


1.16
log
@sync the SENSOR_DRIVE_* names with sysctl(8)'s

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.15 2009/06/25 20:39:02 okan Exp $	*/
d247 1
a247 1
		    s->sn_value < nitems(drvstat)) {
@


1.15
log
@use the nitems() macro where appropriate

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.14 2008/12/07 02:56:06 canacar Exp $	*/
d62 2
a63 2
	"empty", "ready", "powerup", "online", "idle", "active",
	"rebuild", "powerdown", "fail", "pfail"
@


1.14
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.13 2008/06/12 22:26:01 canacar Exp $	*/
d247 1
a247 1
		    s->sn_value < sizeof(drvstat)/sizeof(drvstat[0])) {
@


1.13
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.12 2007/07/29 04:51:59 cnst Exp $	*/
d336 1
a336 1
	    tiny ? "%s%lf %s" : "%s%.3lf %s", 
@


1.12
log
@zap redundant code; ok deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.11 2007/03/23 14:48:22 ckuethe Exp $	*/
d30 1
a30 1

a31 1
#include "extern.h"
a34 3
int row, sensor_cnt;
void printline(void);
static char * fmttime(double);
d36 64
a99 2
WINDOW *
opensensors(void)
d101 13
a113 1
	return (subwin(stdscr, LINES-1-1, 0, 1, 0));
a115 9
void
closesensors(WINDOW *w)
{
	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
}
d117 2
a118 2
void
labelsensors(void)
d120 2
a121 6
	wmove(wnd, 0, 0);
	wclrtobot(wnd);
	mvwaddstr(wnd, 1, 0, "Sensor");
	mvwaddstr(wnd, 1, 34, "Value");
	mvwaddstr(wnd, 1, 45, "Status");
	mvwaddstr(wnd, 1, 58, "Description");
d124 2
a125 2
void
fetchsensors(void)
d130 1
a133 2
	slen = sizeof(struct sensor);
	sdlen = sizeof(struct sensordev);
a134 1
	row = 2;
a136 3
	wmove(wnd, row, 0);
	wclrtobot(wnd);

d139 1
d142 1
a142 1
				warn("sysctl");
d145 8
d157 1
d161 1
a161 1
						warn("sysctl");
d166 4
a169 2
				sensor_cnt++;
				printline();
d173 3
a177 5
const char *drvstat[] = {
	NULL,
	"empty", "ready", "powerup", "online", "idle", "active",
	"rebuild", "powerdown", "fail", "pfail"
};
d180 1
a180 1
showsensors(void)
d182 8
a189 2
	if (sensor_cnt == 0)
		mvwaddstr(wnd, row, 0, "No sensors found.");
d195 8
a202 1
	return (1);
d205 2
a206 2
void
printline(void)
d208 11
a218 3
	mvwprintw(wnd, row, 0, "%s.%s%d", sensordev.xname,
	    sensor_type_s[sensor.type], sensor.numt);
	switch (sensor.type) {
d220 2
a221 2
		mvwprintw(wnd, row, 24, "%10.2f degC",
		    (sensor.value - 273150000) / 1000000.0);
d224 1
a224 1
		mvwprintw(wnd, row, 24, "%11lld RPM", sensor.value);
d227 2
a228 2
		mvwprintw(wnd, row, 24, "%10.2f V DC",
		    sensor.value / 1000000.0);
d231 1
a231 1
		mvwprintw(wnd, row, 24, "%10.2f A", sensor.value / 1000000.0);
d234 1
a234 1
		mvwprintw(wnd, row, 24, "%15s", sensor.value? "On" : "Off");
d237 1
a237 1
		mvwprintw(wnd, row, 24, "%11lld raw", sensor.value);
d240 1
a240 1
		mvwprintw(wnd, row, 24, "%14.2f%%", sensor.value / 1000.0);
d243 1
a243 1
		mvwprintw(wnd, row, 24, "%15.2f lx", sensor.value / 1000000.0);
d246 3
a248 3
		if (0 < sensor.value &&
		    sensor.value < sizeof(drvstat)/sizeof(drvstat[0])) {
			mvwprintw(wnd, row, 24, "%15s", drvstat[sensor.value]);
d253 1
a253 1
		mvwprintw(wnd, row, 24, "%15s", fmttime(sensor.value / 1000000000.0));
d256 1
a256 1
		mvwprintw(wnd, row, 24, "%12.2f Wh", sensor.value / 1000000.0);
d259 1
a259 1
		mvwprintw(wnd, row, 24, "%10.2f Ah", sensor.value / 1000000.0);
d262 1
a262 1
		mvwprintw(wnd, row, 24, "%10lld", sensor.value);
a264 2
	if (sensor.desc[0] != '\0')
		mvwprintw(wnd, row, 58, "(%s)", sensor.desc);
d266 3
a268 1
	switch (sensor.status) {
d272 1
a272 1
		mvwaddstr(wnd, row, 45, "unknown");
d275 1
a275 1
		mvwaddstr(wnd, row, 45, "WARNING");
d278 1
a278 1
		mvwaddstr(wnd, row, 45, "CRITICAL");
d281 1
a281 1
		mvwaddstr(wnd, row, 45, "OK");
d284 1
a284 1
	row++;
@


1.11
log
@use the proper abbreviation for second: "s"
requested by deanna, naddy, otto, steven
ok deanna, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.10 2007/03/23 06:56:40 ckuethe Exp $	*/
a29 1
#include <string.h>
d105 1
a105 2
				if (sensor_cnt > 0)
					printline();
a119 1
	row = 2;
a126 1
	fetchsensors();
d182 1
a182 1
	if (strlen(sensor.desc) >= 1)
@


1.10
log
@display a timedelta of 0 in seconds, not some other unit.
requested by otto, ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.9 2007/03/23 01:10:38 ckuethe Exp $	*/
d236 1
a236 1
		unit = "sec";
d239 1
a239 1
		unit = "sec";
d241 1
a241 1
		unit = "mS";
d244 1
a244 1
		unit = "uS";
d247 1
a247 1
		unit = "nS";
d250 1
a250 1
		unit = "pS";
@


1.9
log
@Add a routine to scale timedelta sensors to more meaningful units,
like fmt_scaled(3) does. Ranges from picoseconds to days.

Also removes a couple of unneeded curses operations.

ok deanna, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sensors.c,v 1.8 2007/03/04 21:17:37 deanna Exp $	*/
d238 2
@


1.8
log
@Clear the display so that the lines don't get overwritten with
hotplugged devices.  Noticed by, similar fix proposed, mbalmer

- Add missing CVS tag; constantine

- Handle SENSOR_S_UNSPEC (do nothing for now).

All discussed with Constanine and mbalmer; ok mbalmer.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d39 1
a136 2
	wmove(wnd, row, 0);
	wclrtoeol(wnd);
d174 1
a174 2
		mvwprintw(wnd, row, 24, "%10.6f secs",
		    sensor.value / 1000000000.0);
d206 53
@


1.7
log
@add missing include, and int return value.

ok deraadt, deanna
@
text
@d1 2
d81 4
d192 2
@


1.6
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d28 1
d124 1
@


1.5
log
@some cleanups, i agree; Murenin
@
text
@d40 1
a40 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
@


1.4
log
@add missing copyright; Constantine
@
text
@d58 1
a58 1
	mvwaddstr(wnd, 1, 0, "Device");
d180 1
a180 1
	if (sensor.desc && strlen(sensor.desc) >= 1)
@


1.3
log
@leave unspecified fields blank; ok deanna
also, fix two logic errors in switches.
@
text
@d4 1
@


1.2
log
@knf
@
text
@d164 1
a174 1
		/* FALLTHROUGH */
d177 1
d179 1
a179 4
	if (sensor.desc != NULL && strlen(sensor.desc) < 1)
		mvwprintw(wnd, row, 58, "(%s%d)",
		    sensor_type_s[sensor.type], sensor.numt);
	else
d184 1
a184 1
		mvwaddstr(wnd, row++, 45, "unknown");
d187 1
a187 1
		mvwaddstr(wnd, row++, 45, "WARNING");
d190 1
a190 1
		mvwaddstr(wnd, row++, 45, "CRITICAL");
d192 2
a193 3
		/* FALLTHROUGH */
	default:
		mvwaddstr(wnd, row++, 45, "OK");
d196 1
@


1.1
log
@Add a display for hardware sensors, available with :sensors.

ok deraadt, jmc
@
text
@d88 1
a88 1
				if (sysctl(mib, 5, &sensor, &slen, NULL, 0) 
d105 3
a107 2
        NULL, "empty", "ready", "powerup", "online", "idle", "active",
        "rebuild", "powerdown", "fail", "pfail"
d131 1
a131 1
	switch(sensor.type) {
d159 2
a160 2
		if (0 < sensor.value && sensor.value <  
		    sizeof(drvstat)/sizeof(drvstat[0])) {
d178 1
a178 1
	if ((sensor.desc != NULL) && strlen(sensor.desc) < 1)
d183 1
a198 1
	
@

