head	1.66;
access;
symbols
	OPENBSD_6_0:1.64.0.4
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.61.0.2
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.6
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.59.0.10
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.8
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.6
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.4
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.57.0.4
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.2
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.31.0.4
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.30.0.4
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.2
	OPENBSD_3_6_BASE:1.30
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.14
	OPENBSD_2_8:1.14.0.12
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.10
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.14.0.8
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.6
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.4
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.66
date	2016.10.13.11.22.46;	author otto;	state Exp;
branches;
next	1.65;
commitid	WiIC4rgKswwHnN8W;

1.65
date	2016.10.13.05.46.20;	author tedu;	state Exp;
branches;
next	1.64;
commitid	MITMrKEyyhrMMFQK;

1.64
date	2016.01.02.15.02.05;	author benno;	state Exp;
branches;
next	1.63;
commitid	klJ7LUZanojdv2cy;

1.63
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	6b2lLILbgCR1fvia;

1.62
date	2015.03.12.01.03.00;	author claudio;	state Exp;
branches;
next	1.61;
commitid	0MoFRWiboJGvZpKs;

1.61
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	waQzIVMqUqjBDjYt;

1.60
date	2013.09.07.11.43.50;	author reyk;	state Exp;
branches;
next	1.59;

1.59
date	2011.04.05.07.35.32;	author mpf;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.31.06.12.34;	author lum;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.16.05.22.48;	author lum;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.02.13.30.03;	author lum;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.21.17.07.38;	author sthen;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.25.20.45.43;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.25.20.39.02;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.19.07.48.45;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.08.06.38.27;	author canacar;	state Exp;
branches;
next	1.50;

1.50
date	2008.11.05.15.48.44;	author canacar;	state Exp;
branches;
next	1.49;

1.49
date	2008.11.04.19.00.08;	author espie;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.02.06.23.28;	author canacar;	state Exp;
branches;
next	1.47;

1.47
date	2008.11.01.00.41.11;	author canacar;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.31.06.50.09;	author canacar;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.31.06.06.46;	author canacar;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.13.06.20.48;	author jmc;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.08.20.07.49;	author matthieu;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.31.04.24.11;	author canacar;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.12.06.20.47;	author canacar;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.13.10.06.14;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.13.01.24.55;	author canacar;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.21.21.15.37;	author cnst;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.24.06.32.08;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.05.09.17.09.22;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.12.05.07.52;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2005.07.04.01.54.10;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.26.19.22.30;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2004.04.14.19.53.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.17.20.58.39;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.17.20.22.50;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.04.00.50.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.18.00.46.37;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.19.19.39.39;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.07.57.35;	author pvalchev;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.28.20.28.08;	author ericj;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.04.23.35.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.04.16.48.34;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	97.11.04.12.20.19;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.25.19.05.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.25.21.05.44;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.06.23.22.21.47;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.06.16.19.10.15;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.43.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.12.22.03.26.07;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.08.10.41.01;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.08.06.20.41.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.18.48.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.40.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.35.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.21.23.44.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.66
log
@tweak previous; hostname is alredy available plus some better formatting
in case line numbers and/or PAUSED is shown; ok tedu@@
@
text
@/* $Id: main.c,v 1.65 2016/10/13 05:46:20 tedu Exp $	 */
/*
 * Copyright (c) 2001, 2007 Can Erkin Acar
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/sysctl.h>


#include <ctype.h>
#include <curses.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <utmp.h>

#include "engine.h"
#include "systat.h"

#define TIMEPOS (80 - 8 - 20 - 1)

double	dellave;

kvm_t	*kd;
char	*nlistf = NULL;
char	*memf = NULL;
double	avenrun[3];
double	naptime = 5.0;
int	verbose = 1;		/* to report kvm read errs */
int	nflag = 1;
int	ut, hz, stathz;
char    hostname[HOST_NAME_MAX+1];
WINDOW  *wnd;
int	CMDLINE;
char	timebuf[26];
char	uloadbuf[TIMEPOS];


int  ucount(void);
void usage(void);

/* command prompt */

void cmd_delay(const char *);
void cmd_count(const char *);
void cmd_compat(const char *);

struct command cm_compat = {"Command", cmd_compat};
struct command cm_delay = {"Seconds to delay", cmd_delay};
struct command cm_count = {"Number of lines to display", cmd_count};


/* display functions */

int
print_header(void)
{
	time_t now;
	int start = dispstart + 1, end = dispstart + maxprint;
	char tmpbuf[TIMEPOS];
	char header[MAX_LINE_BUF];

	if (end > num_disp)
		end = num_disp;

	tb_start();

	if (!paused) {
		char *ctim;

		getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0]));

		snprintf(uloadbuf, sizeof(uloadbuf),
		    "%4d users Load %.2f %.2f %.2f", 
		    ucount(), avenrun[0], avenrun[1], avenrun[2]);

		time(&now);
		ctim = ctime(&now);
		ctim[11+8] = '\0';
		strlcpy(timebuf, ctim + 11, sizeof(timebuf));
	}

	if (num_disp && (start > 1 || end != num_disp))
		snprintf(tmpbuf, sizeof(tmpbuf),
		    "%s (%u-%u of %u) %s", uloadbuf, start, end, num_disp,
		    paused ? "PAUSED" : "");
	else
		snprintf(tmpbuf, sizeof(tmpbuf), 
		    "%s %s", uloadbuf,
		    paused ? "PAUSED" : "");
		
	snprintf(header, sizeof(header), "%-*s %19.19s %s", TIMEPOS - 1,
	    tmpbuf, hostname, timebuf);

	if (rawmode)
		printf("\n\n%s\n", header);
	else
		mvprintw(0, 0, "%s", header);

	return (1);
}

/* compatibility functions, rearrange later */
void
error(const char *fmt, ...)
{
	va_list ap;
	char buf[MAX_LINE_BUF];

	va_start(ap, fmt);
	vsnprintf(buf, sizeof buf, fmt, ap);
	va_end(ap);

	message_set(buf);
}

void
nlisterr(struct nlist namelist[])
{
	int i, n;

	n = 0;
	clear();
	mvprintw(2, 10, "systat: nlist: can't find following symbols:");
	for (i = 0;
	    namelist[i].n_name != NULL && *namelist[i].n_name != '\0'; i++)
		if (namelist[i].n_value == 0)
			mvprintw(2 + ++n, 10, "%s", namelist[i].n_name);
	move(CMDLINE, 0);
	clrtoeol();
	refresh();
	endwin();
	exit(1);
}

void
die(void)
{
	if (!rawmode)
		endwin();
	exit(0);
}


int
prefix(char *s1, char *s2)
{

	while (*s1 == *s2) {
		if (*s1 == '\0')
			return (1);
		s1++, s2++;
	}
	return (*s1 == '\0');
}

/* calculate number of users on the system */
int
ucount(void)
{
	int nusers = 0;
	struct	utmp utmp;

	if (ut < 0)
		return (0);
	lseek(ut, (off_t)0, SEEK_SET);
	while (read(ut, &utmp, sizeof(utmp)))
		if (utmp.ut_name[0] != '\0')
			nusers++;

	return (nusers);
}

/* main program functions */

void
usage(void)
{
	extern char *__progname;
	fprintf(stderr, "usage: %s [-aBbiNn] [-d count] "
	    "[-s delay] [-w width] [view] [delay]\n", __progname);
	exit(1);
}

void
show_view(void)
{
	if (rawmode)
		return;

	tb_start();
	tbprintf("%s %g", curr_view->name, naptime);
	tb_end();
	message_set(tmp_buf);
}

void
add_view_tb(field_view *v)
{
	if (curr_view == v)
		tbprintf("[%s] ", v->name);
	else
		tbprintf("%s ", v->name);
}

void
show_help(void)
{
	if (rawmode)
		return;

	tb_start();
	foreach_view(add_view_tb);
	tb_end();
	message_set(tmp_buf);
}

void
cmd_compat(const char *buf)
{
	const char *s;

	if (strcasecmp(buf, "help") == 0) {
		show_help();
		need_update = 1;
		return;
	}
	if (strcasecmp(buf, "quit") == 0 || strcasecmp(buf, "q") == 0) {
		gotsig_close = 1;
		return;
	}
	if (strcasecmp(buf, "stop") == 0) {
		paused = 1;
		gotsig_alarm = 1;
		return;
	}
	if (strncasecmp(buf, "start", 5) == 0) {
		paused = 0;
		gotsig_alarm = 1;
		cmd_delay(buf + 5);
		return;
	}

	for (s = buf; *s && strchr("0123456789+-.eE", *s) != NULL; s++)
		;
	if (*s) {
		if (set_view(buf))
			error("Invalid/ambiguous view: %s", buf);
	} else
		cmd_delay(buf);
}

void
cmd_delay(const char *buf)
{
	double del;
	del = atof(buf);

	if (del > 0) {
		udelay = (useconds_t)(del * 1000000);
		gotsig_alarm = 1;
		naptime = del;
	}
}

void
cmd_count(const char *buf)
{
	const char *errstr;

	maxprint = strtonum(buf, 1, lines - HEADER_LINES, &errstr);
	if (errstr)
		maxprint = lines - HEADER_LINES;
}


int
keyboard_callback(int ch)
{
	switch (ch) {
	case '?':
		/* FALLTHROUGH */
	case 'h':
		show_help();
		need_update = 1;
		break;
	case CTRL_G:
		show_view();
		need_update = 1;
		break;
	case 'l':
		command_set(&cm_count, NULL);
		break;
	case 's':
		command_set(&cm_delay, NULL);
		break;
	case ',':
		separate_thousands = !separate_thousands;
		gotsig_alarm = 1;
		break;
	case ':':
		command_set(&cm_compat, NULL);
		break;
	default:
		return 0;
	};

	return 1;
}

void
initialize(void)
{
	engine_initialize();

	initvmstat();
	initpigs();
	initifstat();
	initiostat();
	initsensors();
	initmembufs();
	initnetstat();
	initswap();
	initpftop();
	initpf();
	initpool();
	initmalloc();
	initnfs();
	initcpu();
}

void
gethz(void)
{
	struct clockinfo cinf;
	size_t  size = sizeof(cinf);
	int	mib[2];

	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	if (sysctl(mib, 2, &cinf, &size, NULL, 0) == -1)
		return;
	stathz = cinf.stathz;
	hz = cinf.hz;
}

int
main(int argc, char *argv[])
{
	char errbuf[_POSIX2_LINE_MAX];
	const char *errstr;
	extern char *optarg;
	extern int optind;
	double delay = 5;

	char *viewstr = NULL;

	gid_t gid;
	int countmax = 0;
	int maxlines = 0;

	int ch;

	ut = open(_PATH_UTMP, O_RDONLY);
	if (ut < 0) {
		warn("No utmp");
	}

	kd = kvm_openfiles(NULL, NULL, NULL, KVM_NO_FILES, errbuf);

	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");

	while ((ch = getopt(argc, argv, "BNabd:ins:w:")) != -1) {
		switch (ch) {
		case 'a':
			maxlines = -1;
			break;
		case 'B':
			averageonly = 1;
			if (countmax < 2)
				countmax = 2;
			/* FALLTHROUGH */
		case 'b':
			rawmode = 1;
			interactive = 0;
			break;
		case 'd':
			countmax = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-d %s: %s", optarg, errstr);
			break;
		case 'i':
			interactive = 1;
			break;
		case 'N':
			nflag = 0;
			break;
		case 'n':
			/* this is a noop, -n is the default */
			nflag = 1;
			break;
		case 's':
			delay = atof(optarg);
			if (delay <= 0)
				delay = 5;
			break;
		case 'w':
			rawwidth = strtonum(optarg, 1, MAX_LINE_BUF-1, &errstr);
			if (errstr)
				errx(1, "-w %s: %s", optarg, errstr);
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}

	if (kd == NULL)
		warnx("kvm_openfiles: %s", errbuf);

	argc -= optind;
	argv += optind;

	if (argc == 1) {
		double del = atof(argv[0]);
		if (del == 0)
			viewstr = argv[0];
		else
			delay = del;
	} else if (argc == 2) {
		viewstr = argv[0];
		delay = atof(argv[1]);
		if (delay <= 0)
			delay = 5;
	}

	udelay = (useconds_t)(delay * 1000000.0);
	if (udelay < 1)
		udelay = 1;

	naptime = (double)udelay / 1000000.0;

	gethostname(hostname, sizeof (hostname));
	gethz();

	initialize();

	set_order(NULL);
	if (viewstr && set_view(viewstr)) {
		fprintf(stderr, "Unknown/ambiguous view name: %s\n", viewstr);
		return 1;
	}

	if (check_termcap()) {
		rawmode = 1;
		interactive = 0;
	}

	setup_term(maxlines);

	if (rawmode && countmax == 0)
		countmax = 1;

	gotsig_alarm = 1;

	engine_loop(countmax);

	return 0;
}
@


1.65
log
@add the hostname to the display. started by otto, then deraadt. ok deraadt
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.64 2016/01/02 15:02:05 benno Exp $	 */
d55 1
a55 1
#define TIMEPOS 55
a69 1
char	hostbuf[26];
d109 1
a109 1
		    "%5d users    Load %.2f %.2f %.2f", 
a111 2
		gethostname(hostbuf, sizeof hostbuf);

d127 2
a128 1
	snprintf(header, sizeof(header), "%-45s%25.25s %s", tmpbuf, hostbuf, timebuf);
@


1.64
log
@garbage collect unsused variable
found by evh -AT- riseup -DOT- net, ok florian@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.63 2015/04/18 18:28:38 deraadt Exp $	 */
d70 1
d105 2
d113 2
d116 3
a118 1
		strlcpy(timebuf, ctime(&now), sizeof(timebuf));
d130 1
a130 1
	snprintf(header, sizeof(header), "%-55s%s", tmpbuf, timebuf);
@


1.63
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.62 2015/03/12 01:03:00 claudio Exp $	 */
a299 1
	int ms;
@


1.62
log
@Switch the netstat view of systat to use the same kvm_getfiles()
function similar to netstat(1). The output still shows the same
info but may be a bit differently sorted. Also it will now show
connections that are not UDP or TCP.  This was the last bit of
systat that needed kvm access and so now systat no longer needs
to be setgid kmem.
With this commit OpenBSD is officially setgid kmem free and an
almost 10 year journey finally comes to an end.
OK deraadt@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.61 2015/01/16 00:03:37 deraadt Exp $	 */
d299 1
a300 1
	ms = atoi(buf);
d302 2
a303 1
	if (ms <= 0 || ms > lines - HEADER_LINES)
a304 2
	else
		maxprint = ms;
d382 1
d421 3
a423 3
			countmax = atoi(optarg);
			if (countmax < 0)
				countmax = 0;
d441 3
a443 5
			rawwidth = atoi(optarg);
			if (rawwidth < 1)
				rawwidth = DEFAULT_WIDTH;
			if (rawwidth >= MAX_LINE_BUF)
				rawwidth = MAX_LINE_BUF - 1;
@


1.61
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.60 2013/09/07 11:43:50 reyk Exp $	 */
d400 1
a400 1
	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
@


1.60
log
@Add a new screen "cpu" that simply lists the usage of each CPU core.
Also add a new -B command line flag that works like -b but waits some
cycles before dumping anything to the console.

With much help from jmc@@
OK jj@@ lambert@@ jmc@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.59 2011/04/05 07:35:32 mpf Exp $	 */
a33 1
#include <sys/param.h>
d67 1
a67 1
char    hostname[MAXHOSTNAMELEN];
@


1.59
log
@Add support to display numbers with thousands separators
and to switch the ifstat view to Bits/s.
This allows us to see live network throughput in units
like MBit/s, which is more practical.
OK sthen@@, manpage OK jmc@@, "put it in" deraadt@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.58 2011/03/31 06:12:34 lum Exp $	 */
d211 1
a211 1
	fprintf(stderr, "usage: %s [-abiNn] [-d count] "
d362 1
d407 1
a407 1
	while ((ch = getopt(argc, argv, "Nabd:ins:w:")) != -1) {
d412 5
@


1.58
log
@Make the top line of systat stop updating, along with the rest of the data
when 'p' is pressed.
ok nicm@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.57 2010/07/16 05:22:48 lum Exp $	 */
d329 4
@


1.57
log
@Make the terminal checking capability of systat better.
Checks taken from top(1) screen.c/init_termcap()
ok canacar@@ sthen@@ nicm@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.56 2010/07/02 13:30:03 lum Exp $	 */
d56 2
d71 2
a73 1
#define TIMEPOS 55
d96 2
a97 1
	char tbuf[26];
d104 2
a105 1
	getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0]));
d107 3
a109 6
	time(&now);
	strlcpy(tbuf, ctime(&now), sizeof tbuf);
	tbprintf("   %d users", ucount());
	tbprintf("    Load %.2f %.2f %.2f", avenrun[0], avenrun[1], avenrun[2]);
	if (num_disp && (start > 1 || end != num_disp))
		tbprintf("  (%u-%u of %u)", start, end, num_disp);
d111 3
a113 2
	if (paused)
		tbprintf(" PAUSED");
d115 15
a129 6
	if (rawmode) {
		printf("\n\n%-55s%s\n", tmp_buf, tbuf);
	} else {
		mvprintw(0, 0, "%s", tmp_buf);
		mvprintw(0, TIMEPOS, "%s", tbuf);
	}
@


1.56
log
@Allow systat to print date and time when in rawmode.
ok canacar@@ millert@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.55 2009/07/21 17:07:38 sthen Exp $	 */
d468 1
a468 1
	if (!isatty(STDOUT_FILENO)) {
@


1.55
log
@Allow systat(1) to resolve names by adding a new -N flag. (The default was
changed some time ago). Noticed by landry@@, discussed with canacar@@ and others.
ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.54 2009/06/25 20:45:43 deraadt Exp $	 */
d112 3
a114 3
	if (rawmode)
		printf("\n\n%s\n", tmp_buf);
	else
d116 2
a117 3

	mvprintw(0, TIMEPOS, "%s", tbuf);

@


1.54
log
@the rule is not to use nitems() in userland yet
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.53 2009/06/25 20:39:02 okan Exp $	 */
d200 1
a200 1
	fprintf(stderr, "usage: %s [-abin] [-d count] "
d391 1
a391 1
	while ((ch = getopt(argc, argv, "abd:ins:w:")) != -1) {
d408 3
d412 1
@


1.53
log
@use the nitems() macro where appropriate

ok canacar@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.52 2009/06/19 07:48:45 jasper Exp $	 */
d100 1
a100 1
	getloadavg(avenrun, nitems(avenrun));
@


1.52
log
@- add two new views to systat, 'nfsserver' and 'nfsclient'.
output is similar to nfsstat(1), but it allows for better monitoring/debugging

tricked into by and "i love this" thib@@
ok canacar@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.51 2008/11/08 06:38:27 canacar Exp $	 */
d100 1
a100 1
	getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0]));
@


1.51
log
@Add malloc and buckets views that display kernel malloc statistics similar
to vmstat -m
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.50 2008/11/05 15:48:44 canacar Exp $	 */
d346 1
@


1.50
log
@Fix some function prototypes, remove unused variables and commented out code
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.49 2008/11/04 19:00:08 espie Exp $	 */
d345 1
@


1.49
log
@spelling: ambigious -> ambiguous
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.48 2008/11/02 06:23:28 canacar Exp $	 */
d72 3
d91 1
a91 3
	struct tm *tp;
	time_t t, now;
	order_type *ordering;
a92 1
	extern int ucount();
a99 11
#if 0
	if (curr_mgr && curr_mgr->sort_fn != NULL) {
		ordering = curr_mgr->order_curr;
		if (ordering != NULL) {
			tbprintf(", Order: %s", ordering->name);
			if (sortdir < 0 && ordering->func != NULL)
				tbprintf(" (rev)");
		}
	}
#endif

d197 1
a197 1
usage()
a228 2
	int line = 0;

@


1.48
log
@Add a view that displays pool(9) information. Idea and ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.47 2008/11/01 00:41:11 canacar Exp $	 */
d281 1
a281 1
			error("Invalid/ambigious view: %s", buf);
d472 1
a472 1
		fprintf(stderr, "Unknown/ambigious view name: %s\n", viewstr);
@


1.47
log
@Remove disabled help text code and -S command, both leftovers from pftop,
skip the correct number of bytes after the 'start' command.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.46 2008/10/31 06:50:09 canacar Exp $	 */
d357 1
@


1.46
log
@Implement start and stop commands as documented,
explicitly pass the command buffer to the command functions.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.45 2008/10/31 06:06:46 canacar Exp $	 */
a248 42

#if 0
	erase();
	mvprintw(line, 2, "Systat Help");
	line += 2;
	mvprintw(line,    5, " h  - Help (this page)");
	mvprintw(line++, 40, " l  - set number of Lines");
	mvprintw(line,    5, " p  - Pause display");
	mvprintw(line++, 40, " s  - Set update interval");
	mvprintw(line,    5, " v  - next View");
	mvprintw(line++, 40, " q  - Quit");
	line++;
	mvprintw(line++, 5, "0-7 - select view directly");
	mvprintw(line++, 5, "SPC - update immediately");
	mvprintw(line++, 5, "^L  - refresh display");
	line++;
	mvprintw(line++, 5, "cursor keys - scroll display");
	line++;
	mvprintw(line++,  3, "Netstat specific keys::");
	mvprintw(line,    5, " t  - toggle TCP display");
	mvprintw(line++, 40, " u  - toggle UDP display");
	mvprintw(line++,  5, " n  - toggle Name resolution");
	line++;
	mvprintw(line++,  3, "Ifstat specific keys::");
	mvprintw(line,    5, " r  - initialize RUN mode");
	mvprintw(line++, 40, " b  - set BOOT mode");
	mvprintw(line,    5, " t  - set TIME mode (default)");
	line++;
	line++;
	mvprintw(line++,  3, "VMstat specific keys::");
	mvprintw(line,    5, " r  - initialize RUN mode");
	mvprintw(line++, 40, " b  - set BOOT mode");
	mvprintw(line,    5, " t  - set TIME mode (default)");
	mvprintw(line++, 40, " z  - zero in RUN mode");
	line++;
	mvprintw(line++, 6, "press any key to continue ...");

	while (getch() == ERR) {
		if (gotsig_close)
			break;
	}
#endif
d273 1
a273 1
		cmd_delay(buf + 6);
d401 1
a401 1
	while ((ch = getopt(argc, argv, "abd:ins:S:w:")) != -1) {
a424 5
			break;
		case 'S':
			dispstart = atoi(optarg);
			if (dispstart < 0)
				dispstart = 0;
@


1.45
log
@make ^G display the current view and refresh interval as documented.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.44 2008/08/13 06:20:48 jmc Exp $	 */
d74 3
a76 3
void cmd_delay(void);
void cmd_count(void);
void cmd_compat(void);
d294 1
a294 1
cmd_compat(void)
d296 1
a296 1
	char *s;
d298 1
a298 1
	if (strcasecmp(cmdbuf, "help") == 0) {
d303 1
a303 1
	if (strcasecmp(cmdbuf, "quit") == 0 || strcasecmp(cmdbuf, "q") == 0) {
d307 11
d319 1
a319 1
	for (s = cmdbuf; *s && strchr("0123456789+-.eE", *s) != NULL; s++)
d322 2
a323 2
		if (set_view(cmdbuf))
			error("Invalid/ambigious view: %s", cmdbuf);
d325 1
a325 1
		cmd_delay();
d329 1
a329 1
cmd_delay(void)
d332 1
a332 1
	del = atof(cmdbuf);
d342 1
a342 1
cmd_count(void)
d345 1
a345 1
	ms = atoi(cmdbuf);
@


1.44
log
@-S currently does nothing useful, so remove it from
SYNOPSIS and usage(); after some discussion with canacar
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.43 2008/08/08 20:07:49 matthieu Exp $	 */
d216 11
d351 4
@


1.43
log
@Small step towards fixing documentation:
- sync usage() with reality. Remove the -h option that does nothing.
- don't complain about kvm_openfiles() error in case of incorrect usage.
- add basic descriptions of the new options and views in the manual
  page. More is needed...
with help from jmc@@ and sobrado@@. ok sobrado@@.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.42 2008/07/31 04:24:11 canacar Exp $	 */
d211 1
a211 1
	fprintf(stderr, "usage: %s [-abin] [-d count] [-S start] "
@


1.42
log
@Do not allow negative or zero delay values from the command line,
use the same check as the -s option. Noticed by johan@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.41 2008/07/12 06:20:47 canacar Exp $	 */
d211 2
a212 2
	fprintf(stderr, "usage: %s [-abhir] [-c cache] [-d cnt]", __progname);
	fprintf(stderr, " [-o field] [-s time] [-w width] [view] [num]\n");
a411 2
	if (kd == NULL)
		warnx("kvm_openfiles: %s", errbuf);
d417 1
a417 1
	while ((ch = getopt(argc, argv, "abd:hins:S:w:")) != -1) {
a453 2
		case 'h':
			/* FALLTHROUGH */
d459 3
@


1.41
log
@Add ':q' as an alias to ':quit', to match old behaviour. Initial patch
from dlg@@, this is a simpler version.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.40 2008/06/13 10:06:14 deraadt Exp $	 */
d476 2
@


1.40
log
@compile on older gcc; no decl after code
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.39 2008/06/13 01:24:55 canacar Exp $	 */
d292 1
a292 1
	if (strcasecmp(cmdbuf, "quit") == 0) {
@


1.39
log
@Set 'naptime' which is used by the interface page in differential mode.
Also remove a debugging message while there.
reported by claudio@@
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.38 2008/06/12 22:26:01 canacar Exp $	 */
d89 1
a89 1
	time_t t;
d91 3
a93 3

	int start = dispstart + 1;
	int end = dispstart + maxprint;
a111 3
	extern int ucount();
	char tbuf[26];
	time_t now;
@


1.38
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $Id$	 */
d314 1
a314 1
	error("delay: %g", del);
d318 1
d444 1
a444 1
			if (delay < 0)
d484 2
@


1.37
log
@fix -Wall warning about unused variable `errstr', which was introduced in the previous revision; ok deraadt, otto, tedu
@
text
@d1 5
a5 6
/*	$OpenBSD: main.c,v 1.36 2007/04/24 06:32:08 tedu Exp $	*/
/*	$NetBSD: main.c,v 1.8 1996/05/10 23:16:36 thorpej Exp $	*/

/*-
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
a9 8
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d11 20
a30 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d33 1
a33 13
#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1992, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)main.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: main.c,v 1.36 2007/04/24 06:32:08 tedu Exp $";
#endif /* not lint */

d37 3
d41 4
a44 1
#include <nlist.h>
a45 1
#include <ctype.h>
d47 1
d49 1
a51 3
#include <stdlib.h>
#include <limits.h>
#include <stdarg.h>
d53 1
a54 1
#include "extern.h"
d64 1
a64 1
int	nflag = 0;
d70 11
a80 1
WINDOW *wload;			/* one line window for load average */
d82 2
a83 1
static void usage(void);
d86 1
a86 1
main(int argc, char *argv[])
d88 11
a98 3
	char errbuf[_POSIX2_LINE_MAX];
	gid_t gid;
	int ch;
d100 8
a107 4
	ut = open(_PATH_UTMP, O_RDONLY);
	if (ut < 0) {
		error("No utmp");
		exit(1);
d109 1
d111 11
a121 5
	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
	if (kd == NULL) {
		error("%s", errbuf);
		exit(1);
	}
d123 2
a124 3
	gid = getgid();
	if (setresgid(gid, gid, gid) == -1)
		err(1, "setresgid");
d126 4
a129 6
	while ((ch = getopt(argc, argv, "nw:")) != -1)
		switch (ch) {
		case 'n':
			nflag = 1;
			break;
		case 'w':
d131 1
a131 9
			naptime = strtod(optarg, NULL);
			if (naptime < 0.09 || naptime > 1000.0)
				errx(1, "invalid interval: %s", optarg);
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
a132 18
	while (argc > 0) {
		if (isdigit(argv[0][0])) {
			naptime = strtod(argv[0], NULL);
			if (naptime < 0.09 || naptime > 1000.0)
				naptime = 5.0;
		} else {
			struct cmdtab *p;

			p = lookup(&argv[0][0]);
			if (p == (struct cmdtab *)-1)
				errx(1, "ambiguous request: %s", &argv[0][0]);
			if (p == 0)
				errx(1, "unknown request: %s", &argv[0][0]);
			curcmd = p;
		}
		argc--;
		argv++;
	}
d134 1
a134 48
	signal(SIGINT, sigdie);
	siginterrupt(SIGINT, 1);
	signal(SIGQUIT, sigdie);
	siginterrupt(SIGQUIT, 1);
	signal(SIGTERM, sigdie);
	siginterrupt(SIGTERM, 1);
	signal(SIGTSTP, sigtstp);
	siginterrupt(SIGTSTP, 1);

	/*
	 * Initialize display.  Load average appears in a one line
	 * window of its own.  Current command's display appears in
	 * an overlapping sub-window of stdscr configured by the display
	 * routines to minimize update work by curses.
	 */
	if (initscr() == NULL) {
		warnx("couldn't initialize screen");
		exit(0);
	}

	CMDLINE = LINES - 1;
	wnd = (*curcmd->c_open)();
	if (wnd == NULL) {
		warnx("couldn't initialize display");
		die();
	}
	wload = newwin(1, 0, 1, 20);
	if (wload == NULL) {
		warnx("couldn't set up load average window");
		die();
	}
	gethostname(hostname, sizeof (hostname));
	gethz();
	(*curcmd->c_init)();
	curcmd->c_flags |= CF_INIT;
	labels();

	dellave = 0.0;

	signal(SIGALRM, sigdisplay);
	siginterrupt(SIGALRM, 1);
	signal(SIGWINCH, sigwinch);
	siginterrupt(SIGWINCH, 1);
	gotdisplay = 1;
	noecho();
	crmode();
	keyboard();
	/*NOTREACHED*/
d137 1
d139 1
a139 1
gethz(void)
d141 6
a146 3
	struct clockinfo cinf;
	size_t  size = sizeof(cinf);
	int	mib[2];
d148 1
a148 6
	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	if (sysctl(mib, 2, &cinf, &size, NULL, 0) == -1)
		return;
	stathz = cinf.stathz;
	hz = cinf.hz;
d151 2
a152 2
static void
usage(void)
d154 13
a166 1
	fprintf(stderr, "usage: systat [-n] [-w wait] [display] [refresh-interval]\n");
a169 1

d171 1
a171 1
labels(void)
d173 3
a175 7
	if (curcmd->c_flags & CF_LOADAV)
		mvprintw(0, 2 + 4, "users    Load");
	(*curcmd->c_label)();
#ifdef notdef
	mvprintw(21, 25, "CPU usage on %s", hostname);
#endif
	refresh();
d178 3
a180 3
/*ARGSUSED*/
void
sigdisplay(int signo)
d182 7
a188 1
	gotdisplay = 1;
d191 3
a193 2
void
display(void)
d195 2
a196 7
	/* Get the load average over the last minute. */
	(void) getloadavg(avenrun, sizeof(avenrun) / sizeof(avenrun[0]));
	(*curcmd->c_fetch)();
	if (curcmd->c_flags & CF_LOADAV) {
		extern int ucount();
		char tbuf[26];
		time_t now;
d198 6
a203 2
		time(&now);
		strlcpy(tbuf, ctime(&now), sizeof tbuf);
d205 1
a205 13
		putint(ucount(), 0, 2, 3);
		putfloat(avenrun[0], 0, 2 + 17, 6, 2, 0);
		putfloat(avenrun[1], 0, 2 + 23, 6, 2, 0);
		putfloat(avenrun[2], 0, 2 + 29, 6, 2, 0);
		mvaddstr(0, 2 + 53, tbuf);
	}
	(*curcmd->c_refresh)();
	if (curcmd->c_flags & CF_LOADAV)
		wrefresh(wload);
	wrefresh(wnd);
	move(CMDLINE, 0);
	refresh();
	ualarm(naptime * 1000000, 0);
d208 2
d211 1
a211 1
load(void)
d213 4
a216 5

	(void) getloadavg(avenrun, sizeof(avenrun)/sizeof(avenrun[0]));
	mvprintw(CMDLINE, 0, "%4.1f %4.1f %4.1f",
	    avenrun[0], avenrun[1], avenrun[2]);
	clrtoeol();
a218 4
volatile sig_atomic_t gotdie;
volatile sig_atomic_t gotdisplay;
volatile sig_atomic_t gotwinch;
volatile sig_atomic_t gottstp;
a219 1
/*ARGSUSED*/
d221 1
a221 1
sigdie(int signo)
d223 4
a226 1
	gotdie = 1;
a228 1
/*ARGSUSED*/
d230 1
a230 1
sigtstp(int signo)
d232 51
a282 1
	gottstp = 1;
d286 1
a286 1
die(void)
d288 30
a317 5
	if (wnd) {
		move(CMDLINE, 0);
		clrtoeol();
		refresh();
		endwin();
a318 1
	exit(0);
a320 1
/*ARGSUSED*/
d322 1
a322 1
sigwinch(int signo)
d324 7
a330 1
	gotwinch = 1;
d333 3
a335 2
void
error(const char *fmt, ...)
d337 22
a358 3
	va_list ap;
	char buf[255];
	int oy, ox;
d360 15
a374 15
	va_start(ap, fmt);
	if (wnd) {
		getyx(stdscr, oy, ox);
		(void) vsnprintf(buf, sizeof buf, fmt, ap);
		clrtoeol();
		standout();
		mvaddstr(CMDLINE, 0, buf);
		standend();
		move(oy, ox);
		refresh();
	} else {
		(void) vfprintf(stderr, fmt, ap);
		fprintf(stderr, "\n");
	}
	va_end(ap);
d378 1
a378 1
nlisterr(struct nlist namelist[])
d380 3
a382 1
	int i, n;
d384 6
a389 12
	n = 0;
	clear();
	mvprintw(2, 10, "systat: nlist: can't find following symbols:");
	for (i = 0;
	    namelist[i].n_name != NULL && *namelist[i].n_name != '\0'; i++)
		if (namelist[i].n_value == 0)
			mvprintw(2 + ++n, 10, "%s", namelist[i].n_name);
	move(CMDLINE, 0);
	clrtoeol();
	refresh();
	endwin();
	exit(1);
a391 1
/* calculate number of users on the system */
d393 1
a393 1
ucount(void)
d395 111
a505 2
	int nusers = 0;
	struct	utmp utmp;
d507 1
a507 6
	if (ut < 0)
		return (0);
	lseek(ut, (off_t)0, SEEK_SET);
	while (read(ut, &utmp, sizeof(utmp)))
		if (utmp.ut_name[0] != '\0')
			nusers++;
d509 1
a509 1
	return (nusers);
@


1.36
log
@support non-integral refresh intervals, possibly as low as 0.1s.
this makes it more useful for real time display of fast changing stats
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.35 2007/02/25 18:21:24 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.35 2007/02/25 18:21:24 deraadt Exp $";
a85 1
	const char *errstr;
@


1.35
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.34 2006/05/09 17:09:22 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.34 2006/05/09 17:09:22 deraadt Exp $";
d70 1
a70 1
u_int	naptime = 5;
d112 4
a115 3
			naptime = (u_int)strtonum(optarg, 1, 1000, &errstr);
			if (errstr)
				errx(1, "interval %s: %s", errstr, optarg);
d125 3
a127 3
			naptime = (u_int)strtonum(argv[0], 1, 1000, &errstr);
			if (errstr)
				naptime = 5;
d260 1
a260 1
	alarm(naptime);
@


1.34
log
@delay time of 0 should be invalid; evol@@online.ptt.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.33 2006/04/12 05:07:52 ray Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.33 2006/04/12 05:07:52 ray Exp $";
d56 1
d73 1
a73 1
int	hz, stathz;
a84 1
	int ch;
d88 7
d167 1
a167 1
	wload = newwin(1, 0, 3, 20);
d217 2
a218 5
	if (curcmd->c_flags & CF_LOADAV) {
		mvaddstr(2, 20,
		    "/0   /1   /2   /3   /4   /5   /6   /7   /8   /9   /10");
		mvaddstr(3, 5, "Load Average");
	}
a235 3
	int i, j;
	chtype c;

d240 12
a251 17
		j = 5.0*avenrun[0] + 0.5;
		dellave -= avenrun[0];
		if (dellave >= 0.0)
			c = '<';
		else {
			c = '>';
			dellave = -dellave;
		}
		if (dellave < 0.05)
			c = '|';
		dellave = avenrun[0];
		wmove(wload, 0, 0);
		wclrtoeol(wload);
		for (i = (j > 50) ? 50 : j; i > 0; i--)
			waddch(wload, c);
		if (j > 50)
			wprintw(wload, " %4.1f", avenrun[0]);
d351 17
@


1.33
log
@Improve error message.

Found by Florin Iamandi <florin dot i at tiscali dot it>.

OK tedu@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.32 2006/03/31 04:10:59 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.32 2006/03/31 04:10:59 deraadt Exp $";
d105 1
a105 1
			naptime = (u_int)strtonum(optarg, 0, 1000, &errstr);
d117 1
a117 1
			naptime = (u_int)strtonum(argv[0], 0, 1000, &errstr);
@


1.32
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.31 2005/07/04 01:54:10 djm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.31 2005/07/04 01:54:10 djm Exp $";
d107 1
a107 1
				errx(1, "interval <= 0: %s", errstr);
@


1.31
log
@make these use setres[ug]id for simple privilege dropping;
ok deraadt@@ millert@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.30 2004/04/26 19:22:30 itojun Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.30 2004/04/26 19:22:30 itojun Exp $";
a67 1
sig_t	sigtstpdfl;
d69 1
a69 2
int	col;
int	naptime = 5;
a72 2
char    c;
char    *namp;
d75 1
a75 1
long	CMDLINE;
d86 1
d105 3
a107 2
			if ((naptime = atoi(optarg)) <= 0)
				errx(1, "interval <= 0.");
d117 2
a118 2
			naptime = atoi(argv[0]);
			if (naptime <= 0)
d222 1
d224 1
a224 2
sigdisplay(signo)
	int signo;
d233 1
d261 1
a261 1
	move(CMDLINE, col);
d281 1
d288 1
d307 1
@


1.30
log
@add -n flag (do not reverse-lookup).  pb and deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.29 2004/04/14 19:53:04 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.29 2004/04/14 19:53:04 deraadt Exp $";
d90 1
d98 3
a100 2
	setegid(getgid());
	setgid(getgid());
@


1.29
log
@wakeup after ^Z did not continue redraws and such.  use own ^Z handler.
ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.28 2003/12/17 20:58:39 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.28 2003/12/17 20:58:39 jmc Exp $";
d73 1
d100 1
a100 1
	while ((ch = getopt(argc, argv, "w:")) != -1)
d102 3
d202 1
a202 1
	fprintf(stderr, "usage: systat [-w wait] [display] [refresh-interval]\n");
@


1.28
log
@- add -w to options description
- document default refresh interval
- sync usage() with SYNOPSIS

inspired by PR 3608;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.26 2003/06/03 02:56:17 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.26 2003/06/03 02:56:17 millert Exp $";
d136 2
d274 1
d277 1
a277 2
sigdie(signo)
	int signo;
d280 6
@


1.27
log
@remove old -M and -N; 3608
@
text
@d196 1
a196 2
	fprintf(stderr,
	    "usage: systat [-w wait] [iostat|mbufs|netstat|pigs|swap|vmstat]\n");
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2002/08/04 00:50:42 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.25 2002/08/04 00:50:42 deraadt Exp $";
a195 1
	fprintf(stderr, "usage: systat [-M core] [-N system] [-w wait]\n");
d197 1
a197 1
	    "              [iostat|mbufs|netstat|pigs|swap|vmstat]\n");
@


1.25
log
@kvm gid revocation earlier
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2002/06/18 00:46:37 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: main.c,v 1.24 2002/06/18 00:46:37 deraadt Exp $";
@


1.24
log
@revoke privs after kvm_openfiles
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2002/02/19 19:39:39 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.23 2002/02/19 19:39:39 millert Exp $";
d94 9
a132 8
	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
	if (kd == NULL) {
		error("%s", errbuf);
		exit(1);
	}

	setegid(getgid());
	setgid(getgid());
@


1.23
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.22 2002/02/16 21:27:54 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.22 2002/02/16 21:27:54 millert Exp $";
d89 1
a89 3
main(argc, argv)
	int argc;
	char **argv;
d95 1
a95 1
		switch(ch) {
d130 3
d146 1
a146 2
	if (initscr() == NULL)
	{
d182 1
a182 1
gethz()
d197 1
a197 1
usage()
d207 1
a207 1
labels()
d265 1
a265 1
load()
d286 1
a286 1
die()
d298 1
a298 2
sigwinch(signo)
	int signo;
d328 1
a328 2
nlisterr(namelist)
	struct nlist namelist[];
@


1.22
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2001/12/07 09:18:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.21 2001/12/07 09:18:08 deraadt Exp $";
d62 1
a303 8

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#ifdef __STDC__
a305 6
#else
void
error(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
d310 1
a310 1
#ifdef __STDC__
a311 4
#else
	va_start(ap);
#endif

@


1.21
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2001/11/28 20:28:08 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.19 2001/11/28 20:28:08 ericj Exp $";
d85 1
a85 1
static void usage __P((void));
@


1.20
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2001/11/19 19:02:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2001/11/19 19:02:16 mpech Exp $";
d51 1
d66 1
a66 9
static struct nlist namelist[] = {
#define X_FIRST		0
#define	X_HZ		0
	{ "_hz" },
#define	X_STATHZ		1
	{ "_stathz" },
	{ "" }
};
static double     dellave;
d68 2
a69 1
kvm_t *kd;
a70 1
char	*nlistf = NULL;
d72 2
a73 2
double avenrun[3];
int     col;
d75 2
a76 2
int     verbose = 1;                    /* to report kvm read errs */
int     hz, stathz;
d83 1
a83 1
static	WINDOW *wload;			/* one line window for load average */
d92 1
a92 1
	int ch, ret;
d95 1
a95 1
	while ((ch = getopt(argc, argv, "M:N:w:")) != -1)
d97 9
a105 24
                case 'M':
                        memf = optarg;
                        break;
                case 'N':
                        nlistf = optarg;
                        break;
                case 'w':
                        if ((naptime = atoi(optarg)) <= 0)
                                errx(1, "interval <= 0.");
                        break;
                case '?':
                default:
                        usage();
                }
        argc -= optind;
        argv += optind;
        /*
         * Discard setgid privileges if not the running kernel so that bad
         * guys can't print interesting stuff from kernel memory.
         */
        if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
                setgid(getgid());
	}
d122 2
a123 1
		argc--, argv++;
d125 1
a125 1
	kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf);
d131 6
a136 10
	if ((ret = kvm_nlist(kd, namelist)) == -1) 
		errx(1, "%s", kvm_geterr(kd));
	else if (ret)
		nlisterr(namelist);

	if (namelist[X_FIRST].n_type == 0)
		errx(1, "couldn't read namelist");
	signal(SIGINT, die);
	signal(SIGQUIT, die);
	signal(SIGTERM, die);
d154 1
a154 1
		die(0);
d159 1
a159 1
		die(0);
d162 1
a162 2
	NREAD(X_HZ, &hz, LONG);
	NREAD(X_STATHZ, &stathz, LONG);
d169 5
a173 3
	signal(SIGALRM, display);
	signal(SIGWINCH, resize);
	display(0);
d180 15
d221 1
a221 1
display(signo)
d224 6
d247 2
a248 1
		wmove(wload, 0, 0); wclrtoeol(wload);
d273 4
d278 1
a278 1
die(signo)
d281 6
d297 1
a297 1
resize(signo)
d300 1
a300 8
	sigset_t mask, oldmask;

	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	clearok(curscr, TRUE);
	wrefresh(curscr);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
@


1.19
log
@
remove unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2001/11/23 22:20:06 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.18 2001/11/23 22:20:06 deraadt Exp $";
a50 1
#include <sys/sysctl.h>
d65 9
a73 1
double	dellave;
d75 2
a76 1
kvm_t	*kd;
a77 1
char	*memf = NULL;
d79 2
a80 2
double	avenrun[3];
int	col;
d82 2
a83 2
int	verbose = 1;		/* to report kvm read errs */
int	hz, stathz;
d90 1
a90 1
WINDOW *wload;			/* one line window for load average */
d99 1
a99 1
	int ch;
d102 1
a102 1
	while ((ch = getopt(argc, argv, "w:")) != -1)
d104 24
a127 9
		case 'w':
			if ((naptime = atoi(optarg)) <= 0)
				errx(1, "interval <= 0.");
			break;
		default:
			usage();
		}
	argc -= optind;
	argv += optind;
d144 1
a144 2
		argc--;
		argv++;
d146 1
a146 1
	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
d152 10
a161 6
	signal(SIGINT, sigdie);
	siginterrupt(SIGINT, 1);
	signal(SIGQUIT, sigdie);
	siginterrupt(SIGQUIT, 1);
	signal(SIGTERM, sigdie);
	siginterrupt(SIGTERM, 1);
d179 1
a179 1
		die();
d184 1
a184 1
		die();
d187 2
a188 1
	gethz();
d195 3
a197 5
	signal(SIGALRM, sigdisplay);
	siginterrupt(SIGALRM, 1);
	signal(SIGWINCH, sigwinch);
	siginterrupt(SIGWINCH, 1);
	gotdisplay = 1;
a203 15
void
gethz()
{
	struct clockinfo cinf;
	size_t  size = sizeof(cinf);
	int	mib[2];

	mib[0] = CTL_KERN;
	mib[1] = KERN_CLOCKRATE;
	if (sysctl(mib, 2, &cinf, &size, NULL, 0) == -1)
		return;
	stathz = cinf.stathz;
	hz = cinf.hz;
}

d230 1
a230 1
sigdisplay(signo)
a232 6
	gotdisplay = 1;
}

void
display(void)
{
d250 1
a250 2
		wmove(wload, 0, 0);
		wclrtoeol(wload);
a274 4
volatile sig_atomic_t gotdie;
volatile sig_atomic_t gotdisplay;
volatile sig_atomic_t gotwinch;

d276 1
a276 1
sigdie(signo)
a278 6
	gotdie = 1;
}

void
die()
{
d289 1
a289 1
sigwinch(signo)
d292 8
a299 1
	gotwinch = 1;
@


1.18
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2001/11/19 19:02:16 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.17 2001/11/19 19:02:16 mpech Exp $";
d92 1
a92 1
	int ch, ret;
@


1.17
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2001/09/04 23:35:59 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.16 2001/09/04 23:35:59 millert Exp $";
d51 1
d66 1
a66 9
static struct nlist namelist[] = {
#define X_FIRST		0
#define	X_HZ		0
	{ "_hz" },
#define	X_STATHZ		1
	{ "_stathz" },
	{ "" }
};
static double     dellave;
d68 2
a69 1
kvm_t *kd;
a70 1
char	*nlistf = NULL;
d72 2
a73 2
double avenrun[3];
int     col;
d75 2
a76 2
int     verbose = 1;                    /* to report kvm read errs */
int     hz, stathz;
d83 1
a83 1
static	WINDOW *wload;			/* one line window for load average */
d95 1
a95 1
	while ((ch = getopt(argc, argv, "M:N:w:")) != -1)
d97 9
a105 24
                case 'M':
                        memf = optarg;
                        break;
                case 'N':
                        nlistf = optarg;
                        break;
                case 'w':
                        if ((naptime = atoi(optarg)) <= 0)
                                errx(1, "interval <= 0.");
                        break;
                case '?':
                default:
                        usage();
                }
        argc -= optind;
        argv += optind;
        /*
         * Discard setgid privileges if not the running kernel so that bad
         * guys can't print interesting stuff from kernel memory.
         */
        if (nlistf != NULL || memf != NULL) {
		setegid(getgid());
                setgid(getgid());
	}
d122 2
a123 1
		argc--, argv++;
d125 1
a125 1
	kd = kvm_openfiles(nlistf, memf, NULL, O_RDONLY, errbuf);
d131 6
a136 10
	if ((ret = kvm_nlist(kd, namelist)) == -1) 
		errx(1, "%s", kvm_geterr(kd));
	else if (ret)
		nlisterr(namelist);

	if (namelist[X_FIRST].n_type == 0)
		errx(1, "couldn't read namelist");
	signal(SIGINT, die);
	signal(SIGQUIT, die);
	signal(SIGTERM, die);
d154 1
a154 1
		die(0);
d159 1
a159 1
		die(0);
d162 1
a162 2
	NREAD(X_HZ, &hz, LONG);
	NREAD(X_STATHZ, &stathz, LONG);
d169 5
a173 3
	signal(SIGALRM, display);
	signal(SIGWINCH, resize);
	display(0);
d180 15
d221 1
a221 1
display(signo)
d224 6
d247 2
a248 1
		wmove(wload, 0, 0); wclrtoeol(wload);
d273 4
d278 1
a278 1
die(signo)
d281 6
d297 1
a297 1
resize(signo)
d300 1
a300 8
	sigset_t mask, oldmask;

	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigprocmask(SIG_BLOCK, &mask, &oldmask);
	clearok(curscr, TRUE);
	wrefresh(curscr);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
@


1.16
log
@Replace the deprecated BSD sigsetmask/sigblock/sigpause functions with their POSIX counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2001/05/04 16:48:34 ericj Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.15 2001/05/04 16:48:34 ericj Exp $";
d233 1
a233 1
	register int i, j;
@


1.15
log
@
handle kvm_nlist() failing, from pr#1798.
Patch similar to the one submitted by <peterw@@documenta.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 1997/11/04 12:20:19 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.14 1997/11/04 12:20:19 kstailey Exp $";
d292 1
a292 1
	int oldmask;
d294 3
a296 2
#define mask(s) (1 << ((s) - 1))
	oldmask = sigblock(mask(SIGALRM));
d299 1
a299 2
	sigsetmask(oldmask);
#undef mask
@


1.14
log
@simple SIGWINCH handler; deals only with window size changes >= 80x24
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 1997/08/25 19:05:26 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.13 1997/08/25 19:05:26 deraadt Exp $";
d99 1
a99 1
	int ch;
d151 4
a154 1
	if (kvm_nlist(kd, namelist)) {
d156 1
a156 2
		exit(1);
	}
@


1.13
log
@when getting interrupt, clean up curses only if curses was active
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 1997/07/25 21:05:44 mickey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.12 1997/07/25 21:05:44 mickey Exp $";
d194 1
d285 15
@


1.12
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 1997/06/23 22:21:47 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.11 1997/06/23 22:21:47 millert Exp $";
d276 6
a281 4
	move(CMDLINE, 0);
	clrtoeol();
	refresh();
	endwin();
@


1.11
log
@Cleanup by Theo and myself.  CMDLINE changed to long to make
command line work on 64bit platforms.  This is somewhat bogus
and is really just a temporary workaround (there may be a curses bug).
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 1997/06/16 19:10:15 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.10 1997/06/16 19:10:15 kstailey Exp $";
d283 1
a283 1
#if __STDC__
d289 1
a289 1
#if __STDC__
d302 1
a302 1
#if __STDC__
@


1.10
log
@You can't store a double in an int and then do tests for the fractional part
miss thing!  Also, make more sensitive to digital decay.  Now "<<<" will
show up in load average display.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 1997/01/15 23:43:17 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.9 1997/01/15 23:43:17 millert Exp $";
d55 1
d59 1
d88 1
a88 1
int     CMDLINE;
d92 1
a92 1
static void usage();
@


1.9
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/12/22 03:26:07 tholo Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1996/12/22 03:26:07 tholo Exp $";
d71 1
a71 1
static int     dellave;
d242 1
a242 1
		if (dellave < 0.1)
@


1.8
log
@Deal with _POSIX_SAVED_IDS when relinquishing privileges
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.7 1996/08/08 10:41:01 niklas Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.7 1996/08/08 10:41:01 niklas Exp $";
d100 1
a100 1
	while ((ch = getopt(argc, argv, "M:N:w:")) != EOF)
@


1.7
log
@Clarify usage printout
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 1996/08/06 20:41:19 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.6 1996/08/06 20:41:19 deraadt Exp $";
d122 2
a123 1
        if (nlistf != NULL || memf != NULL)
d125 1
@


1.6
log
@_POSIX2_LINE_MAX errbuf for kvm_openfiles()
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 1996/08/06 18:48:15 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.5 1996/08/06 18:48:15 deraadt Exp $";
d201 2
@


1.5
log
@avoid buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1996/06/26 05:40:08 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.4 1996/06/26 05:40:08 deraadt Exp $";
d58 1
d98 1
a98 1
	char errbuf[80];
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 1996/05/10 23:16:36 thorpej Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: main.c,v 1.8 1996/05/10 23:16:36 thorpej Exp $";
d303 1
a303 1
		(void) vsprintf(buf, fmt, ap);
@


1.3
log
@libutil
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: main.c,v 1.8 1996/05/10 23:16:36 thorpej Exp $";
@


1.2
log
@sync to netbsd 960418
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.7 1996/03/21 18:04:25 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.7 1996/03/21 18:04:25 jtc Exp $";
d56 1
d72 2
d88 2
d95 1
d98 25
a122 1
	argc--, argv++;
d124 5
a128 1
		if (argv[0][0] == '-') {
d131 1
a131 1
			p = lookup(&argv[0][1]);
d133 1
a133 1
				errx(1, "ambiguous request: %s", &argv[0][1]);
d135 1
a135 1
				errx(1, "unknown request: %s", &argv[0][1]);
a136 4
		} else {
			naptime = atoi(argv[0]);
			if (naptime <= 0)
				naptime = 5;
d140 1
a140 1
	kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
d194 8
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: main.c,v 1.6 1995/05/06 06:25:07 jtc Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: main.c,v 1.6 1995/05/06 06:25:07 jtc Exp $";
d85 1
a85 1
void
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
