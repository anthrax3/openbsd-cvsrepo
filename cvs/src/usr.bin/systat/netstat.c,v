head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.8
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.6
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.39.0.6
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.6
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.4
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.6
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2015.03.12.01.03.00;	author claudio;	state Exp;
branches;
next	1.44;
commitid	0MoFRWiboJGvZpKs;

1.44
date	2015.01.20.18.26.57;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	qRSGCXxt7yQIBAcS;

1.43
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	waQzIVMqUqjBDjYt;

1.42
date	2014.10.24.10.18.49;	author schwarze;	state Exp;
branches;
next	1.41;
commitid	AnkaVNznnIFStJal;

1.41
date	2014.10.08.04.10.04;	author doug;	state Exp;
branches;
next	1.40;
commitid	cpW0LtZf9XzHlFrl;

1.40
date	2014.08.14.12.55.50;	author mpi;	state Exp;
branches;
next	1.39;
commitid	gdOWXDzOPG8ZFusi;

1.39
date	2013.12.25.01.46.00;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.24.22.26.20;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.20.06.55.24;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.30.14.35.50;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.22.12.33.29;	author giovanni;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.19.04.20;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.10.17.12.00;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.09.29.21.59.28;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.26.19.22.30;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.18.00.46.47;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.07.07.57.35;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.28.05.36.18;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.22.14.57.20;	author lebel;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.16.48.34;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.24.13.17.08;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.05.11.04.22;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	99.12.08.10.50.04;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.12.19.09.36.50;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.12.19.09.22.55;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.12.19.09.03.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.06.23.22.21.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.01.17.07.13.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.08.06.18.48.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.27.14.55.25;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.02.19.40.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Switch the netstat view of systat to use the same kvm_getfiles()
function similar to netstat(1). The output still shows the same
info but may be a bit differently sorted. Also it will now show
connections that are not UDP or TCP.  This was the last bit of
systat that needed kvm access and so now systat no longer needs
to be setgid kmem.
With this commit OpenBSD is officially setgid kmem free and an
almost 10 year journey finally comes to an end.
OK deraadt@@
@
text
@/*	$OpenBSD: netstat.c,v 1.44 2015/01/20 18:26:57 deraadt Exp $	*/
/*	$NetBSD: netstat.c,v 1.3 1995/06/18 23:53:07 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * netstat
 */

#include <kvm.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#define _KERNEL
#include <sys/file.h>
#undef _KERNEL

#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/tcp_seq.h>
#define TCPSTATES
#include <netinet/tcp_fsm.h>
#include <arpa/inet.h>

#include <netdb.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <err.h>
#include <nlist.h>
#include <paths.h>
#include "systat.h"
#include "engine.h"

#define	TCP	0x1
#define	UDP	0x2
#define	OTHER	0x4

struct netinfo {
	union {
		struct	in_addr nif_laddr;	/* local address */
		struct	in6_addr nif_laddr6;	/* local address */
	} l;
	union {
		struct	in_addr	nif_faddr;	/* foreign address */
		struct	in6_addr nif_faddr6;	/* foreign address */
	} f;
	long	nif_rcvcc;		/* rcv buffer character count */
	long	nif_sndcc;		/* snd buffer character count */
	short	nif_lport;		/* local port */
	short	nif_fport;		/* foreign port */
	short	nif_state;		/* tcp state */
	short	nif_family;
	short	nif_proto;		/* protocol */
	short	nif_ipproto;
};

#define nif_laddr  l.nif_laddr
#define nif_laddr6 l.nif_laddr6
#define nif_faddr  f.nif_faddr
#define nif_faddr6 f.nif_faddr6

static void enter(struct kinfo_file *);
static int kf_comp(const void *, const void *);
static void inetprint(struct in_addr *, int, char *, field_def *);
static void inet6print(struct in6_addr *, int, char *, field_def *);
static void shownetstat(struct netinfo *p);

void print_ns(void);
int read_ns(void);
int select_ns(void);
int ns_keyboard_callback(int);

#define	streq(a,b)	(strcmp(a,b)==0)

static	int aflag = 0;

#define ADD_ALLOC  1000

int protos;

struct netinfo *netinfos = NULL;
size_t num_ns = 0;
static size_t num_alloc = 0;


field_def fields_ns[] = {
	{"LOCAL ADDRESS", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"FOREIGN ADDRESS", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"PROTO", 4, 9, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"RECV-Q", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"SEND-Q", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"STATE", 5, 11, 6, FLD_ALIGN_LEFT, -1, 0, 0, 0},
};

#define FLD_NS_LOCAL	FIELD_ADDR(fields_ns,0)
#define FLD_NS_FOREIGN	FIELD_ADDR(fields_ns,1)
#define FLD_NS_PROTO	FIELD_ADDR(fields_ns,2)
#define FLD_NS_RECV_Q	FIELD_ADDR(fields_ns,3)
#define FLD_NS_SEND_Q	FIELD_ADDR(fields_ns,4)
#define FLD_NS_STATE	FIELD_ADDR(fields_ns,5)

/* Define views */
field_def *view_ns_0[] = {
	FLD_NS_LOCAL, FLD_NS_FOREIGN, FLD_NS_PROTO,
	FLD_NS_RECV_Q, FLD_NS_SEND_Q, FLD_NS_STATE, NULL
};

/* Define view managers */
struct view_manager netstat_mgr = {
	"Netstat", select_ns, read_ns, NULL, print_header,
	print_ns, ns_keyboard_callback, NULL, NULL
};

field_view views_ns[] = {
	{view_ns_0, "netstat", '0', &netstat_mgr},
	{NULL, NULL, 0, NULL}
};




struct netinfo *
next_ns(void)
{
	if (num_alloc <= num_ns) {
		struct netinfo *ni;
		size_t a = num_alloc + ADD_ALLOC;
		if (a < num_alloc)
			return NULL;
		ni = reallocarray(netinfos, a, sizeof(*ni));
		if (ni == NULL)
			return NULL;
		netinfos = ni;
		num_alloc = a;
	}

	return &netinfos[num_ns++];
}

static void
enter(struct kinfo_file *kf)
{
#define s6_addr32 __u6_addr.__u6_addr32
	struct netinfo *p;

	/* first filter out unwanted sockets */
	if (kf->so_family != AF_INET && kf->so_family != AF_INET6)
		return;

	switch (kf->so_protocol) {
	case IPPROTO_TCP:
		if ((protos & TCP) == 0)
			return;
		break;
	case IPPROTO_UDP:
		if ((protos & UDP) == 0)
			return;
		break;
	default:
		if ((protos & OTHER) == 0)
			return;
		break;
	}

	if (!aflag) {
		struct in6_addr faddr6;

		switch (kf->so_family) {
		case AF_INET:
			if (kf->inp_faddru[0] == INADDR_ANY)
				return;
			break;
		case AF_INET6:
			faddr6.s6_addr32[0] = kf->inp_faddru[0];
			faddr6.s6_addr32[1] = kf->inp_faddru[1];
			faddr6.s6_addr32[2] = kf->inp_faddru[2];
			faddr6.s6_addr32[3] = kf->inp_faddru[3];
			if (IN6_IS_ADDR_UNSPECIFIED(&faddr6))
				return;
			break;
		}
	}

	/* finally enter the socket to the table */
	p = next_ns();
	if (p == NULL) {
		error("Out of Memory!");
		return;
	}

	p->nif_lport = kf->inp_lport;
	p->nif_fport = kf->inp_fport;
	p->nif_proto = kf->so_protocol;
	p->nif_ipproto = kf->inp_proto;

	switch (kf->so_family) {
	case AF_INET:
		p->nif_family = AF_INET;
		p->nif_laddr.s_addr = kf->inp_laddru[0];
		p->nif_faddr.s_addr = kf->inp_faddru[0];
		break;
	case AF_INET6:
		p->nif_family = AF_INET6;
		p->nif_laddr6.s6_addr32[0] = kf->inp_laddru[0];
		p->nif_laddr6.s6_addr32[1] = kf->inp_laddru[1];
		p->nif_laddr6.s6_addr32[2] = kf->inp_laddru[2];
		p->nif_laddr6.s6_addr32[3] = kf->inp_laddru[3];
		p->nif_faddr6.s6_addr32[0] = kf->inp_faddru[0];
		p->nif_faddr6.s6_addr32[1] = kf->inp_faddru[1];
		p->nif_faddr6.s6_addr32[2] = kf->inp_faddru[2];
		p->nif_faddr6.s6_addr32[3] = kf->inp_faddru[3];
		break;
	}

	p->nif_rcvcc = kf->so_rcv_cc;
	p->nif_sndcc = kf->so_snd_cc;
	p->nif_state = kf->t_state;
#undef s6_addr32
}


/* netstat callback functions */

int
select_ns(void)
{
	num_disp = num_ns;
	return (0);
}

static int type_map[] = { -1, 2, 3, 1, 4, 5 };

static int
kf_comp(const void *a, const void *b)
{
	const struct kinfo_file *ka = a, *kb = b;

	if (ka->so_family != kb->so_family) {
		/* AF_INET < AF_INET6 < AF_LOCAL */
		if (ka->so_family == AF_INET)
			return (-1);
		if (ka->so_family == AF_LOCAL)
			return (1);
		if (kb->so_family == AF_LOCAL)
			return (-1);
		return (1);
	}
	if (ka->so_family == AF_LOCAL) {
		if (type_map[ka->so_type] < type_map[kb->so_type])
			return (-1);
		if (type_map[ka->so_type] > type_map[kb->so_type])
			return (1);
	} else if (ka->so_family == AF_INET || ka->so_family == AF_INET6) {
		if (ka->so_protocol < kb->so_protocol)
			return (-1);
		if (ka->so_protocol > kb->so_protocol)
			return (1);
		if (ka->so_type == SOCK_DGRAM || ka->so_type == SOCK_STREAM) {
			/* order sockets by remote port desc */
			if (ka->inp_fport > kb->inp_fport)
				return (-1);
			if (ka->inp_fport < kb->inp_fport)
				return (1);
		} else if (ka->so_type == SOCK_RAW) {
			if (ka->inp_proto > kb->inp_proto)
				return (-1);
			if (ka->inp_proto < kb->inp_proto)
				return (1);
		}
	}
	return (0);
}


int
read_ns(void)
{
	struct kinfo_file *kf;
	int i, fcnt;

	if (kd == NULL) {
		error("Failed to initialize KVM!");
		return (0);
	}
	kf = kvm_getfiles(kd, KERN_FILE_BYFILE, DTYPE_SOCKET,
	    sizeof(*kf), &fcnt);
	if (kf == NULL) {
		error("Out of Memory!");
		return (0);
	}

	/* sort sockets by AF, proto and type */
	qsort(kf, fcnt, sizeof(*kf), kf_comp);

	num_ns = 0;

	for (i = 0; i < fcnt; i++)
		enter(&kf[i]);

	num_disp = num_ns;
	return 0;
}

void
print_ns(void)
{
	int n, count = 0;

	for (n = dispstart; n < num_disp; n++) {
		shownetstat(netinfos + n);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}


int
initnetstat(void)
{
	field_view *v;

	protos = TCP|UDP|OTHER;
	for (v = views_ns; v->name != NULL; v++)
		add_view(v);

	return(1);
}

static void
shownetstat(struct netinfo *p)
{
	char *proto = NULL;

	switch (p->nif_proto) {
	case IPPROTO_TCP:
		proto = "tcp";
		break;
	case IPPROTO_UDP:
		proto = "udp";
		break;
	}

	switch (p->nif_family) {
	case AF_INET:
		inetprint(&p->nif_laddr, p->nif_lport,
			  proto, FLD_NS_LOCAL);
		inetprint(&p->nif_faddr, p->nif_fport,
			  proto, FLD_NS_FOREIGN);
		break;
	case AF_INET6:
		inet6print(&p->nif_laddr6, p->nif_lport,
			   proto, FLD_NS_LOCAL);
		inet6print(&p->nif_faddr6, p->nif_fport,
			   proto, FLD_NS_FOREIGN);
		break;
	}
 
	tb_start();
	switch (p->nif_proto) {
	case IPPROTO_TCP:
	case IPPROTO_UDP:
		tbprintf(proto);
		if (p->nif_family == AF_INET6)
			tbprintf("6");
		break;
	case IPPROTO_DIVERT:
		tbprintf("divert");
		if (p->nif_family == AF_INET6)
			tbprintf("6");
		break;
	default:
		tbprintf("%d", p->nif_ipproto);
		break;
	}

	print_fld_tb(FLD_NS_PROTO);

	print_fld_size(FLD_NS_RECV_Q, p->nif_rcvcc);
	print_fld_size(FLD_NS_SEND_Q, p->nif_sndcc);

	if (p->nif_proto == IPPROTO_TCP) {
		if (p->nif_state < 0 || p->nif_state >= TCP_NSTATES)
			print_fld_uint(FLD_NS_STATE, p->nif_state);
		else
			print_fld_str(FLD_NS_STATE, tcpstates[p->nif_state]);
	}
	end_line();
}

/*
 * Pretty print an Internet address (net address + port).
 * If the nflag was specified, use numbers instead of names.
 */
static void
inetprint(struct in_addr *in, int port, char *proto, field_def *fld)
{
	struct servent *sp = 0;

	tb_start();
	tbprintf("%s", inetname(*in));

	if (!nflag && port)
		sp = getservbyport(port, proto);
	if (sp || port == 0)
		tbprintf(":%s", sp ? sp->s_name : "*");
	else
		tbprintf(":%d", ntohs((u_short)port));

	print_fld_tb(fld);
}

static void
inet6print(struct in6_addr *in6, int port, char *proto, field_def *fld)
{
	struct servent *sp = 0;

	tb_start();

	tbprintf("%s", inet6name(in6));
	if (!nflag && port)
		sp = getservbyport(port, proto);
	if (sp || port == 0)
		tbprintf(":%s", sp ? sp->s_name : "*");
	else
		tbprintf(":%d", ntohs((u_short)port));

	print_fld_tb(fld);
}

int
ns_keyboard_callback(int ch)
{
	switch (ch) {
	case 'a':
		aflag = !aflag;
		gotsig_alarm = 1;
		break;
	case 'n':
		nflag = !nflag;
		gotsig_alarm = 1;
		break;
	case 'o':
		protos ^= OTHER;
		gotsig_alarm = 1;
		break;
	case 'r':
		aflag = 0;
		nflag = 1;
		protos = TCP|UDP;
		gotsig_alarm = 1;
		break;
	case 't':
		protos ^= TCP;
		gotsig_alarm = 1;
		break;
	case 'u':
		protos ^= UDP;
		gotsig_alarm = 1;
		break;
	default:
		return keyboard_callback(ch);
	};

	return 1;
}

@


1.44
log
@Adjust <sys/param.h> comments regarding use of use of MSIZE, or
delete <sys/param.h> if now possible
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.43 2015/01/16 00:03:37 deraadt Exp $	*/
d37 3
a39 1
#include <sys/signal.h>
d41 3
a43 3
#include <sys/socketvar.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
a45 6
#include <net/route.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp_var.h>
#include <netinet/ip_var.h>
a49 4
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
d53 1
d62 4
a74 1
	char	*nif_proto;		/* protocol */
d81 2
d90 2
a91 1
static void enter(struct inpcb *, struct socket *, int, char *);
a104 7
static struct nlist namelist[] = {
#define	X_TCBTABLE	0		/* no sysctl */
	{ "_tcbtable" },
#define	X_UDBTABLE	1		/* no sysctl */
	{ "_udbtable" },
	{ "" },
};
a106 1

d169 1
a169 1
enter(struct inpcb *inp, struct socket *so, int state, char *proto)
d171 1
d174 39
d219 12
a230 7
	p->nif_lport = inp->inp_lport;
	p->nif_fport = inp->inp_fport;
	p->nif_proto = proto;
	
	if (inp->inp_flags & INP_IPV6) {
		p->nif_laddr6 = inp->inp_laddr6;
		p->nif_faddr6 = inp->inp_faddr6;
d232 9
a240 4
	} else {
		p->nif_laddr = inp->inp_laddr;
		p->nif_faddr = inp->inp_faddr;
		p->nif_family = AF_INET;
d243 4
a246 3
	p->nif_rcvcc = so->so_rcv.sb_cc;
	p->nif_sndcc = so->so_snd.sb_cc;
	p->nif_state = state;
d255 43
a297 3
	if (kd == NULL) {
		num_disp = 1;
		return (0);
a298 1
	num_disp = num_ns;
d302 1
d306 2
a307 7
	struct inpcbtable pcbtable;
	struct inpcb *next, *prev;
	struct inpcb inpcb, prevpcb;
	struct socket sockb;
	struct tcpcb tcpcb;
	void *off;
	int istcp;
d310 1
d313 9
d325 2
a326 54
	if (namelist[X_TCBTABLE].n_value == 0)
		return 0;

	if (protos & TCP) {
		off = NPTR(X_TCBTABLE);
		istcp = 1;
	} else if (protos & UDP) {
		off = NPTR(X_UDBTABLE);
		istcp = 0;
	} else {
		error("No protocols to display");
		return 0;
	}

again:
	KREAD(off, &pcbtable, sizeof (struct inpcbtable));

	prev = NULL;
	next = TAILQ_FIRST(&pcbtable.inpt_queue);

	while (next != NULL) {
		KREAD(next, &inpcb, sizeof (inpcb));
		if (prev != NULL) {
			KREAD(prev, &prevpcb, sizeof (prevpcb));
			if (TAILQ_NEXT(&prevpcb, inp_queue) != next) {
				error("Kernel state in transition");
				return 0;
			}
		}
		prev = next;
		next = TAILQ_NEXT(&inpcb, inp_queue);

		if (!aflag) {
			if (!(inpcb.inp_flags & INP_IPV6) &&
			    inet_lnaof(inpcb.inp_faddr) == INADDR_ANY)
				continue;
			if ((inpcb.inp_flags & INP_IPV6) &&
			    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_faddr6))
				continue;
		}
		KREAD(inpcb.inp_socket, &sockb, sizeof (sockb));
		if (istcp) {
			KREAD(inpcb.inp_ppcb, &tcpcb, sizeof (tcpcb));
			if (!aflag && tcpcb.t_state <= TCPS_LISTEN)
				continue;
			enter(&inpcb, &sockb, tcpcb.t_state, "tcp");
		} else
			enter(&inpcb, &sockb, 0, "udp");
	}
	if (istcp && (protos & UDP)) {
		istcp = 0;
		off = NPTR(X_UDBTABLE);
		goto again;
	}
a336 7
	if (kd == NULL) {
		print_fld_str(FLD_NS_LOCAL, "Failed to initialize KVM!");
		print_fld_str(FLD_NS_FOREIGN, "Failed to initialize KVM!");
		end_line();
		return;
	}

a349 14
	int ret;

	if (kd) {
		if ((ret = kvm_nlist(kd, namelist)) == -1)
			errx(1, "%s", kvm_geterr(kd));
		else if (ret)
			nlisterr(namelist);

		if (namelist[X_TCBTABLE].n_value == 0) {
			error("No symbols in namelist");
			return(0);
		}
	}
	protos = TCP|UDP;
d351 1
d361 11
d375 1
a375 1
			  p->nif_proto, FLD_NS_LOCAL);
d377 1
a377 1
			  p->nif_proto, FLD_NS_FOREIGN);
d381 1
a381 1
			   p->nif_proto, FLD_NS_LOCAL);
d383 1
a383 1
			   p->nif_proto, FLD_NS_FOREIGN);
d388 16
a403 3
	tbprintf("%s", p->nif_proto);
	if (p->nif_family == AF_INET6)
		tbprintf("6");
d410 1
a410 1
	if (streq(p->nif_proto, "tcp")) {
a459 12
kvm_ckread(void *a, void *b, size_t l)
{
	if (kvm_read(kd, (u_long)a, b, l) != l) {
		if (verbose)
			error("error reading kmem\n");
		return (0);
	} else
		return (1);
}


int
d469 4
@


1.43
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.42 2014/10/24 10:18:49 schwarze Exp $	*/
a36 1
#include <sys/param.h>	/* MSIZE */
@


1.42
log
@This tool doesn't actually support networks(5).
So remove the call to setnetent(3) which is a no-op
here (except for consuming a file descriptor)
and the call sethostent(3) which is a no-op in general.
Also remove the misleading reference to networks(5) from the manual.
OK okan@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.41 2014/10/08 04:10:04 doug Exp $	*/
d36 3
a38 1
#include <sys/param.h>
@


1.41
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.40 2014/08/14 12:55:50 mpi Exp $	*/
a211 1
	static int init = 0;
a215 7

	if (!init) {
		sethostent(1);
		setnetent(1);
		init = 1;
	}

@


1.40
log
@No need for <netinet/in_systm.h> nor <netinet/tcpip.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.39 2013/12/25 01:46:00 tedu Exp $	*/
d166 1
a166 1
		ni = realloc(netinfos, a * sizeof(*ni));
@


1.39
log
@final circleq to tailq fix. restore the previous pointer check by reading
the previous value again and checking prev.next is still next.
maybe ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.38 2013/12/24 22:26:20 tedu Exp $	*/
a43 1
#include <netinet/in_systm.h>
a49 1
#include <netinet/tcpip.h>
a54 1
#include <netinet/tcp_debug.h>
@


1.38
log
@more fixing after circleq conversion. a better fix to check the prev
pointer is forthcoming.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.37 2013/12/20 02:04:09 krw Exp $	*/
d235 2
a236 2
	struct inpcb *next;
	struct inpcb inpcb;
d265 1
d270 8
@


1.37
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.36 2013/03/20 06:55:24 deraadt Exp $	*/
d235 1
a235 1
	struct inpcb *head, *prev, *next;
a264 1
	prev = head = (struct inpcb *)&((struct inpcbtable *)off)->inpt_queue;
d267 1
a267 1
	while (next != head) {
a268 5
		if (TAILQ_PREV(&inpcb, inpthead, inp_queue) != prev) {
			error("Kernel state in transition");
			return 0;
		}
		prev = next;
@


1.36
log
@Do not expose a kernel address.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.35 2012/01/30 14:35:50 okan Exp $	*/
d266 1
a266 1
	next = CIRCLEQ_FIRST(&pcbtable.inpt_queue);
d270 1
a270 1
		if (CIRCLEQ_PREV(&inpcb, inp_queue) != prev) {
d275 1
a275 1
		next = CIRCLEQ_NEXT(&inpcb, inp_queue);
@


1.35
log
@- allow the default to only show all non-listneing scokets, which matches
  the manpage and what netstat(1) does, sans the aflag (-a).
- allow one to use 'a' to toggle the above (include listening or not).
- implement [r]eset to reset all toggles to default (all/tcp/udp).
- document a/n/r/t/u toggles.

ok henning@@ sthen@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.34 2011/03/02 06:48:17 jasper Exp $	*/
d432 1
a432 1
			error("error reading kmem at %x\n", a);
@


1.34
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.33 2010/07/22 12:33:29 giovanni Exp $	*/
d279 1
a279 1
			    inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
d282 1
a282 1
			    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6))
d288 2
d443 4
d449 6
@


1.33
log
@
Let systat -N states resolve network addresses
help and ok sthen@@ lum@@
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.32 2008/12/07 02:56:06 canacar Exp $	*/
d134 6
a139 8
#define FIELD_ADDR(x) (&fields_ns[x])

#define FLD_NS_LOCAL	FIELD_ADDR(0)
#define FLD_NS_FOREIGN	FIELD_ADDR(1)
#define FLD_NS_PROTO	FIELD_ADDR(2)
#define FLD_NS_RECV_Q	FIELD_ADDR(3)
#define FLD_NS_SEND_Q	FIELD_ADDR(4)
#define FLD_NS_STATE	FIELD_ADDR(5)
@


1.32
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.31 2008/06/12 22:26:01 canacar Exp $	*/
a94 1
static const char *inetname(struct in_addr);
a95 1
static const char *inet6name(struct in6_addr *);
a424 47
}

static const char *
inet6name(struct in6_addr *in6)
{
	static char line[NI_MAXHOST];
	struct sockaddr_in6 sin6;
	int flags;

	flags = nflag ? NI_NUMERICHOST : 0;
	if (IN6_IS_ADDR_UNSPECIFIED(in6))
		return "*";
	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *in6;
	if (getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
	    line, sizeof(line), NULL, 0, flags) == 0)
		return line;
	return "?";
}

static const char *
inetname(struct in_addr in)
{
	static char line[NI_MAXHOST];
	struct sockaddr_in si;
	int flags, e;

	flags = nflag ? NI_NUMERICHOST : 0;
	if (in.s_addr == INADDR_ANY)
		return "*";

	memset(&si, 0, sizeof(si));
	si.sin_family = AF_INET;
	si.sin_len = sizeof(struct sockaddr_in);
	si.sin_addr = in;

	e = getnameinfo((struct sockaddr *)&si, si.sin_len,
			line, sizeof(line), NULL, 0, flags);

	if (e == 0)
		return line;

	error("Lookup: %s", gai_strerror(e));

	return "?";
@


1.31
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.30 2007/02/25 18:21:24 deraadt Exp $	*/
d453 1
a453 1
	struct sockaddr_in sin;
d460 4
a463 4
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof(struct sockaddr_in);
	sin.sin_addr = in;
d465 1
a465 1
	e = getnameinfo((struct sockaddr *)&sin, sin.sin_len,
@


1.30
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.29 2006/03/31 04:10:59 deraadt Exp $	*/
a32 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)netstat.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: netstat.c,v 1.29 2006/03/31 04:10:59 deraadt Exp $";
#endif /* not lint */

d69 24
a92 1
#include "extern.h"
d96 1
a96 1
static void inetprint(struct in_addr *, int, char *);
d98 7
a104 1
static void inet6print(struct in6_addr *, int, char *);
a106 1
#define	YMAX(w)		((w)->_maxy-1)
d108 48
a155 7
WINDOW *
opennetstat(void)
{
	sethostent(1);
	setnetent(1);
	return (subwin(stdscr, LINES-1-2, 0, 2, 0));
}
d157 3
a159 18
struct netinfo {
	struct	netinfo *nif_forw, *nif_prev;
	int	nif_family;
	short	nif_line;		/* line on screen */
	short	nif_seen;		/* 0 when not present in list */
	short	nif_flags;
#define	NIF_LACHG	0x1		/* local address changed */
#define	NIF_FACHG	0x2		/* foreign address changed */
	short	nif_state;		/* tcp state */
	char	*nif_proto;		/* protocol */
	struct	in_addr nif_laddr;	/* local address */
	struct	in6_addr nif_laddr6;	/* local address */
	long	nif_lport;		/* local port */
	struct	in_addr	nif_faddr;	/* foreign address */
	struct	in6_addr nif_faddr6;	/* foreign address */
	long	nif_fport;		/* foreign port */
	long	nif_rcvcc;		/* rcv buffer character count */
	long	nif_sndcc;		/* snd buffer character count */
a161 3
static struct {
	struct	netinfo *nif_forw, *nif_prev;
} netcb;
a162 2
static	int aflag = 0;
static	int lastrow = 1;
d164 21
a184 2
void
closenetstat(WINDOW *w)
d188 4
a191 13
	endhostent();
	endnetent();
	p = (struct netinfo *)netcb.nif_forw;
	while (p != (struct netinfo *)&netcb) {
		if (p->nif_line != -1)
			lastrow--;
		p->nif_line = -1;
		p = p->nif_forw;
	}
	if (w != NULL) {
		wclear(w);
		wrefresh(w);
		delwin(w);
d193 18
d213 2
a214 7
static struct nlist namelist[] = {
#define	X_TCBTABLE	0		/* no sysctl */
	{ "_tcbtable" },
#define	X_UDBTABLE	1		/* no sysctl */
	{ "_udbtable" },
	{ "" },
};
d217 1
a217 1
initnetstat(void)
d219 5
a223 1
	int ret;
d225 4
a228 7
	if ((ret = kvm_nlist(kd, namelist)) == -1)
		errx(1, "%s", kvm_geterr(kd));
	else if (ret)
		nlisterr(namelist);
	if (namelist[X_TCBTABLE].n_value == 0) {
		error("No symbols in namelist");
		return(0);
d230 3
a232 3
	netcb.nif_forw = netcb.nif_prev = (struct netinfo *)&netcb;
	protos = TCP|UDP;
	return(1);
d235 2
a236 2
void
fetchnetstat(void)
a239 1
	struct netinfo *p;
d246 6
d253 3
a255 4
		return;
	for (p = netcb.nif_forw; p != (struct netinfo *)&netcb; p = p->nif_forw)
		p->nif_seen = 0;
	if (protos&TCP) {
d258 1
a258 1
	} else if (protos&UDP) {
d263 1
a263 1
		return;
d265 1
d268 1
d271 1
a274 5
			printf("prev = %p, head = %p, next = %p, inpcb...prev = %p\n",
			    prev, head, next, CIRCLEQ_PREV(&inpcb, inp_queue));
			p = netcb.nif_forw;
			for (; p != (struct netinfo *)&netcb; p = p->nif_forw)
				p->nif_seen = 1;
d276 1
a276 1
			return;
a288 4
		if (nhosts && !checkhost(&inpcb))
			continue;
		if (nports && !checkport(&inpcb))
			continue;
d296 1
a296 1
	if (istcp && (protos&UDP)) {
d301 3
d306 2
a307 2
static void
enter(struct inpcb *inp, struct socket *so, int state, char *proto)
d309 1
a309 1
	struct netinfo *p;
d311 5
a315 31
	/*
	 * Only take exact matches, any sockets with
	 * previously unbound addresses will be deleted
	 * below in the display routine because they
	 * will appear as ``not seen'' in the kernel
	 * data structures.
	 */
	for (p = netcb.nif_forw; p != (struct netinfo *)&netcb; p = p->nif_forw) {
		if (p->nif_family == AF_INET && (inp->inp_flags & INP_IPV6))
			continue;
		if (p->nif_family == AF_INET6 && !(inp->inp_flags & INP_IPV6))
			continue;
		if (!streq(proto, p->nif_proto))
			continue;
		if (p->nif_family == AF_INET) {
			if (p->nif_lport != inp->inp_lport ||
			    p->nif_laddr.s_addr != inp->inp_laddr.s_addr)
				continue;
			if (p->nif_faddr.s_addr == inp->inp_faddr.s_addr &&
			    p->nif_fport == inp->inp_fport)
				break;

		} else if (p->nif_family == AF_INET6) {
			if (p->nif_lport != inp->inp_lport ||
			    !IN6_ARE_ADDR_EQUAL(&p->nif_laddr6, &inp->inp_laddr6))
				continue;
			if (IN6_ARE_ADDR_EQUAL(&p->nif_faddr6, &inp->inp_faddr6) &&
			    p->nif_fport == inp->inp_fport)
				break;
		} else
			continue;
d317 6
a322 23
	if (p == (struct netinfo *)&netcb) {
		if ((p = malloc(sizeof(*p))) == NULL) {
			error("Out of memory");
			return;
		}
		p->nif_prev = (struct netinfo *)&netcb;
		p->nif_forw = netcb.nif_forw;
		netcb.nif_forw->nif_prev = p;
		netcb.nif_forw = p;
		p->nif_line = -1;
		p->nif_lport = inp->inp_lport;
		p->nif_fport = inp->inp_fport;
		p->nif_proto = proto;
		p->nif_flags = NIF_LACHG|NIF_FACHG;
		if (inp->inp_flags & INP_IPV6) {
			p->nif_laddr6 = inp->inp_laddr6;
			p->nif_faddr6 = inp->inp_faddr6;
			p->nif_family = AF_INET6;
		} else {
			p->nif_laddr = inp->inp_laddr;
			p->nif_faddr = inp->inp_faddr;
			p->nif_family = AF_INET;
		}
a323 4
	p->nif_rcvcc = so->so_rcv.sb_cc;
	p->nif_sndcc = so->so_snd.sb_cc;
	p->nif_state = state;
	p->nif_seen = 1;
a325 7
/* column locations */
#define	LADDR	0
#define	FADDR	LADDR+23
#define	PROTO	FADDR+23
#define	RCVCC	PROTO+6
#define	SNDCC	RCVCC+7
#define	STATE	SNDCC+7
d327 5
d333 17
a349 13
void
labelnetstat(void)
{
	if (namelist[X_TCBTABLE].n_type == 0)
		return;
	wmove(wnd, 0, 0);
	wclrtobot(wnd);
	mvwaddstr(wnd, 0, LADDR, "Local Address");
	mvwaddstr(wnd, 0, FADDR, "Foreign Address");
	mvwaddstr(wnd, 0, PROTO, "Proto");
	mvwaddstr(wnd, 0, RCVCC, "Recv-Q");
	mvwaddstr(wnd, 0, SNDCC, "Send-Q");
	mvwaddstr(wnd, 0, STATE, "(state)");
d352 2
a353 2
void
shownetstat(void)
d355 30
a384 90
	struct netinfo *p, *q;

	/*
	 * First, delete any connections that have gone
	 * away and adjust the position of connections
	 * below to reflect the deleted line.
	 */
	p = netcb.nif_forw;
	while (p != (struct netinfo *)&netcb) {
		if (p->nif_line == -1 || p->nif_seen) {
			p = p->nif_forw;
			continue;
		}
		wmove(wnd, p->nif_line, 0);
		wdeleteln(wnd);
		q = netcb.nif_forw;
		for (; q != (struct netinfo *)&netcb; q = q->nif_forw)
			if (q != p && q->nif_line > p->nif_line) {
				q->nif_line--;
				/* this shouldn't be necessary */
				q->nif_flags |= NIF_LACHG|NIF_FACHG;
			}
		lastrow--;
		q = p->nif_forw;
		p->nif_prev->nif_forw = p->nif_forw;
		p->nif_forw->nif_prev = p->nif_prev;
		free(p);
		p = q;
	}
	/*
	 * Update existing connections and add new ones.
	 */
	for (p = netcb.nif_forw; p != (struct netinfo *)&netcb; p = p->nif_forw) {
		if (p->nif_line == -1) {
			/*
			 * Add a new entry if possible.
			 */
			if (lastrow > YMAX(wnd))
				continue;
			p->nif_line = lastrow++;
			p->nif_flags |= NIF_LACHG|NIF_FACHG;
		}
		if (p->nif_flags & NIF_LACHG) {
			wmove(wnd, p->nif_line, LADDR);
			switch (p->nif_family) {
			case AF_INET:
				inetprint(&p->nif_laddr, p->nif_lport,
				    p->nif_proto);
				break;
			case AF_INET6:
				inet6print(&p->nif_laddr6, p->nif_lport,
				    p->nif_proto);
				break;
			}
			p->nif_flags &= ~NIF_LACHG;
		}
		if (p->nif_flags & NIF_FACHG) {
			wmove(wnd, p->nif_line, FADDR);
			switch (p->nif_family) {
			case AF_INET:
				inetprint(&p->nif_faddr, p->nif_fport,
				    p->nif_proto);
				break;
			case AF_INET6:
				inet6print(&p->nif_faddr6, p->nif_fport,
				    p->nif_proto);
				break;
			}
			p->nif_flags &= ~NIF_FACHG;
		}
		mvwaddstr(wnd, p->nif_line, PROTO, p->nif_proto);
		if (p->nif_family == AF_INET6)
			waddstr(wnd, "6");
		mvwprintw(wnd, p->nif_line, RCVCC, "%6d", p->nif_rcvcc);
		mvwprintw(wnd, p->nif_line, SNDCC, "%6d", p->nif_sndcc);
		if (streq(p->nif_proto, "tcp")) {
			if (p->nif_state < 0 || p->nif_state >= TCP_NSTATES)
				mvwprintw(wnd, p->nif_line, STATE, "%d",
				    p->nif_state);
			else
				mvwaddstr(wnd, p->nif_line, STATE,
				    tcpstates[p->nif_state]);
		}
		wclrtoeol(wnd);
	}
	if (lastrow < YMAX(wnd)) {
		wmove(wnd, lastrow, 0);
		wclrtobot(wnd);
		wmove(wnd, YMAX(wnd), 0);
		wdeleteln(wnd);	/* XXX */
d386 1
d394 1
a394 1
inetprint(struct in_addr *in, int port, char *proto)
a396 1
	char line[80], *cp;
d398 3
a400 2
	snprintf(line, sizeof line, "%.*s.", 16, inetname(*in));
	cp = strchr(line, '\0');
d404 1
a404 2
		snprintf(cp, sizeof line - strlen(cp), "%.8s",
		    sp ? sp->s_name : "*");
d406 3
a408 8
		snprintf(cp, sizeof line - strlen(cp), "%d",
		    ntohs((u_short)port));
	/* pad to full column to clear any garbage */
	cp = strchr(line, '\0');
	while (cp - line < 22 && cp - line < sizeof line-1)
		*cp++ = ' ';
	*cp = '\0';
	waddstr(wnd, line);
d412 1
a412 1
inet6print(struct in6_addr *in6, int port, char *proto)
a414 1
	char line[80], *cp;
d416 3
a418 2
	snprintf(line, sizeof line, "%.*s.", 16, inet6name(in6));
	cp = strchr(line, '\0');
d422 1
a422 2
		snprintf(cp, sizeof line - strlen(cp), "%.8s",
		    sp ? sp->s_name : "*");
d424 1
a424 9
		snprintf(cp, sizeof line - strlen(cp), "%d",
		    ntohs((u_short)port));
	/* pad to full column to clear any garbage */
	cp = strchr(line, '\0');
	while (cp - line < 22 && cp - line < sizeof line-1)
		*cp++ = ' ';
	*cp = '\0';
	waddstr(wnd, line);
}
d426 1
a426 39
/*
 * Construct an Internet address representation.
 * If the nflag has been supplied, give
 * numeric value, otherwise try for symbolic name.
 */
static const char *
inetname(struct in_addr in)
{
	char *cp = 0;
	static char line[50];
	struct hostent *hp;
	struct netent *np;

	if (!nflag && in.s_addr != INADDR_ANY) {
		int net = inet_netof(in);
		int lna = inet_lnaof(in);

		if (lna == INADDR_ANY) {
			np = getnetbyaddr(net, AF_INET);
			if (np)
				cp = np->n_name;
		}
		if (cp == 0) {
			hp = gethostbyaddr(&in, sizeof (in), AF_INET);
			if (hp)
				cp = hp->h_name;
		}
	}
	if (in.s_addr == INADDR_ANY) {
		strlcpy(line, "*", sizeof line);
	} else if (cp) {
		strlcpy(line, cp, sizeof line);
	} else {
		in.s_addr = ntohl(in.s_addr);
#define C(x)	((x) & 0xff)
		snprintf(line, sizeof line, "%u.%u.%u.%u", C(in.s_addr >> 24),
		    C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
	}
	return (line);
d449 39
d489 1
a489 1
cmdnetstat(char *cmd, char *args)
d491 16
a506 1
	struct netinfo *p;
d508 1
a508 29
	if (prefix(cmd, "all")) {
		aflag = !aflag;
		goto fixup;
	}
	if  (prefix(cmd, "numbers") || prefix(cmd, "names")) {
		int new;

		new = prefix(cmd, "numbers");
		if (new == nflag)
			return (1);
		p = netcb.nif_forw;
		for (; p != (struct netinfo *)&netcb; p = p->nif_forw) {
			if (p->nif_line == -1)
				continue;
			p->nif_flags |= NIF_LACHG|NIF_FACHG;
		}
		nflag = new;
		wclear(wnd);
		labelnetstat();
		goto redisplay;
	}
	if (!netcmd(cmd, args))
		return (0);
fixup:
	fetchnetstat();
redisplay:
	shownetstat();
	refresh();
	return (1);
d510 1
@


1.29
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.28 2005/10/17 19:04:20 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.28 2005/10/17 19:04:20 otto Exp $";
d92 1
a92 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
@


1.28
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.27 2005/05/10 17:12:00 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.27 2005/05/10 17:12:00 deraadt Exp $";
d320 2
a321 1
	wmove(wnd, 0, 0); wclrtobot(wnd);
d346 2
a347 1
		wmove(wnd, p->nif_line, 0); wdeleteln(wnd);
d380 1
a380 1
					p->nif_proto);
d384 1
a384 1
					p->nif_proto);
d394 1
a394 1
					p->nif_proto);
d398 1
a398 1
					p->nif_proto);
d419 4
a422 2
		wmove(wnd, lastrow, 0); wclrtobot(wnd);
		wmove(wnd, YMAX(wnd), 0); wdeleteln(wnd);	/* XXX */
d501 1
a501 1
			hp = gethostbyaddr((char *)&in, sizeof (in), AF_INET);
@


1.27
log
@correct v6 handling; yanovich@@psc.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.26 2004/09/29 21:59:28 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.26 2004/09/29 21:59:28 deraadt Exp $";
d198 1
a198 1
	next = pcbtable.inpt_queue.cqh_first;
d201 1
a201 1
		if (inpcb.inp_queue.cqe_prev != prev) {
d203 1
a203 1
			    prev, head, next, inpcb.inp_queue.cqe_prev);
d211 1
a211 1
		next = inpcb.inp_queue.cqe_next;
@


1.26
log
@always compile in INET6 support
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.25 2004/04/26 19:22:30 itojun Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.25 2004/04/26 19:22:30 itojun Exp $";
a211 3

		if (inpcb.inp_flags & INP_IPV6)
			continue;
@


1.25
log
@add -n flag (do not reverse-lookup).  pb and deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.24 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.24 2003/06/03 02:56:17 millert Exp $";
a80 1
#ifdef INET6
a82 1
#endif
a105 1
#ifdef INET6
a106 1
#endif
a108 1
#ifdef INET6
a109 1
#endif
a212 1
#ifndef INET6
a214 1
#endif
a219 1
#ifdef INET6
a222 1
#endif
a254 1
#ifdef INET6
a258 1
#endif
d269 1
a269 3
		}
#ifdef INET6
		else if (p->nif_family == AF_INET6) {
d276 1
a276 3
		}
#endif
		else
a292 1
#ifdef INET6
d297 1
a297 3
		} else
#endif
		{
a382 1
#ifdef INET6
a386 1
#endif
a396 1
#ifdef INET6
a400 1
#endif
a404 1
#ifdef INET6
a406 1
#endif
a452 1
#ifdef INET6
a475 1
#endif
a517 1
#ifdef INET6
a536 1
#endif
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.23 2002/06/19 08:45:52 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.23 2002/06/19 08:45:52 deraadt Exp $";
a125 1
static	int nflag = 0;
d553 1
a553 4
	if (nflag)
		flags = NI_NUMERICHOST;
	else
		flags = 0;
@


1.23
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.22 2002/06/18 00:46:47 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.22 2002/06/18 00:46:47 deraadt Exp $";
@


1.22
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.21 2002/02/16 21:27:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.21 2002/02/16 21:27:54 millert Exp $";
d155 1
a155 1
#define	X_TCBTABLE	0
d157 1
a157 1
#define	X_UDBTABLE	1
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.20 2001/12/07 09:18:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.20 2001/12/07 09:18:08 deraadt Exp $";
d94 1
a94 1
opennetstat()
d134 1
a134 2
closenetstat(w)
	WINDOW *w;
d163 1
a163 1
initnetstat()
d181 1
a181 1
fetchnetstat()
d213 2
a214 1
printf("prev = %p, head = %p, next = %p, inpcb...prev = %p\n", prev, head, next, inpcb.inp_queue.cqe_prev);
d258 1
a258 5
enter(inp, so, state, proto)
	struct inpcb *inp;
	struct socket *so;
	int state;
	char *proto;
d343 1
a343 1
labelnetstat()
d357 1
a357 1
shownetstat()
d460 1
a460 4
inetprint(in, port, proto)
	struct in_addr *in;
	int port;
	char *proto;
d485 1
a485 4
inet6print(in6, port, proto)
	struct in6_addr *in6;
	int port;
	char *proto;
d515 1
a515 2
inetname(in)
	struct in_addr in;
d552 1
a552 2
inet6name(in6)
	struct in6_addr *in6;
d576 1
a576 2
cmdnetstat(cmd, args)
	char *cmd, *args;
@


1.20
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.18 2001/11/23 22:20:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.18 2001/11/23 22:20:06 deraadt Exp $";
d82 3
a84 3
static void enter __P((struct inpcb *, struct socket *, int, char *));
static const char *inetname __P((struct in_addr));
static void inetprint __P((struct in_addr *, int, char *));
d86 2
a87 2
static const char *inet6name __P((struct in6_addr *));
static void inet6print __P((struct in6_addr *, int, char *));
@


1.19
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.17 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.17 2001/11/19 19:02:16 mpech Exp $";
d135 1
a135 1
        WINDOW *w;
d148 1
a148 1
        if (w != NULL) {
d198 1
a198 1
		off = NPTR(X_TCBTABLE); 
d200 2
a201 3
	}
	else if (protos&UDP) {
		off = NPTR(X_UDBTABLE); 
d203 1
a203 2
	}
	else {
d230 2
a231 2
			if (!(inpcb.inp_flags & INP_IPV6)
			 && inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
d234 2
a235 2
			if ((inpcb.inp_flags & INP_IPV6)
			 && IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6))
d323 1
a323 2
		}
		else
d357 1
a357 1
	mvwaddstr(wnd, 0, STATE, "(state)"); 
d443 1
a443 1
		if (streq(p->nif_proto, "tcp"))
d450 1
d521 1
a521 1
 * If the nflag has been supplied, give 
d556 1
a556 1
			C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
d581 1
a581 1
			line, sizeof(line), NULL, 0, flags) == 0)
@


1.18
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@d135 1
a135 1
	WINDOW *w;
d148 1
a148 1
	if (w != NULL) {
d198 1
a198 1
		off = NPTR(X_TCBTABLE);
d200 3
a202 2
	} else if (protos&UDP) {
		off = NPTR(X_UDBTABLE);
d204 2
a205 1
	} else {
d232 2
a233 2
			if (!(inpcb.inp_flags & INP_IPV6) &&
			    inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
d236 2
a237 2
			if ((inpcb.inp_flags & INP_IPV6) &&
			    IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6))
d325 2
a326 1
		} else
d360 1
a360 1
	mvwaddstr(wnd, 0, STATE, "(state)");
d446 1
a446 1
		if (streq(p->nif_proto, "tcp")) {
a452 1
		}
d523 1
a523 1
 * If the nflag has been supplied, give
d558 1
a558 1
		    C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
d583 1
a583 1
	    line, sizeof(line), NULL, 0, flags) == 0)
@


1.17
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.16 2001/07/28 05:36:18 pvalchev Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.16 2001/07/28 05:36:18 pvalchev Exp $";
d135 1
a135 1
        WINDOW *w;
d148 1
a148 1
        if (w != NULL) {
d198 1
a198 1
		off = NPTR(X_TCBTABLE); 
d200 2
a201 3
	}
	else if (protos&UDP) {
		off = NPTR(X_UDBTABLE); 
d203 1
a203 2
	}
	else {
d230 2
a231 2
			if (!(inpcb.inp_flags & INP_IPV6)
			 && inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
d234 2
a235 2
			if ((inpcb.inp_flags & INP_IPV6)
			 && IN6_IS_ADDR_UNSPECIFIED(&inpcb.inp_laddr6))
d323 1
a323 2
		}
		else
d357 1
a357 1
	mvwaddstr(wnd, 0, STATE, "(state)"); 
d443 1
a443 1
		if (streq(p->nif_proto, "tcp"))
d450 1
d521 1
a521 1
 * If the nflag has been supplied, give 
d556 1
a556 1
			C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
d581 1
a581 1
			line, sizeof(line), NULL, 0, flags) == 0)
@


1.16
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.15 2001/06/22 14:57:20 lebel Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.15 2001/06/22 14:57:20 lebel Exp $";
d137 1
a137 1
	register struct netinfo *p;
d185 2
a186 2
	register struct inpcb *head, *prev, *next;
	register struct netinfo *p;
d261 2
a262 2
	register struct inpcb *inp;
	register struct socket *so;
d266 1
a266 1
	register struct netinfo *p;
d366 1
a366 1
	register struct netinfo *p, *q;
d467 1
a467 1
	register struct in_addr *in;
d495 1
a495 1
	register struct in6_addr *in6;
d593 1
a593 1
	register struct netinfo *p;
@


1.15
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.14 2001/05/04 16:48:34 ericj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.14 2001/05/04 16:48:34 ericj Exp $";
d76 1
d216 1
a216 1
printf("prev = %x, head = %x, next = %x, inpcb...prev = %x\n", prev, head, next, inpcb.inp_queue.cqe_prev);
@


1.14
log
@
handle kvm_nlist() failing, from pr#1798.
Patch similar to the one submitted by <peterw@@documenta.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.13 2000/05/24 13:17:08 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.13 2000/05/24 13:17:08 itojun Exp $";
d550 1
a550 2
		strncpy(line, "*", sizeof line-1);
		line[sizeof line-1] = '\0';
d552 1
a552 2
		strncpy(line, cp, sizeof line-1);
		line[sizeof line-1] = '\0';
@


1.13
log
@correct type to be passed to IN6_ARE_ADDR_EQUAL macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.12 2000/01/05 11:04:22 itojun Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.12 2000/01/05 11:04:22 itojun Exp $";
d165 5
a169 1
	if (kvm_nlist(kd, namelist)) {
a170 2
		return(0);
	}
@


1.12
log
@IPv6 support.  commands under "netstat" are all IPv6-aware.
const checks in netstat.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.11 1999/12/08 10:50:04 angelos Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.11 1999/12/08 10:50:04 angelos Exp $";
d295 1
a295 1
			if (IN6_ARE_ADDR_EQUAL(&p->nif_faddr, &inp->inp_faddr) &&
@


1.11
log
@Fix compile conflict with the new IPv6 code (namespace pollution).
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.10 1997/12/19 09:36:50 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.10 1997/12/19 09:36:50 deraadt Exp $";
d82 1
a82 1
static char *inetname __P((struct in_addr));
d84 4
d102 1
d111 3
d116 3
a130 2
static	void enter(), inetprint();
static	char *inetname();
d223 2
a224 1
		if (!aflag && inet_lnaof(inpcb.inp_laddr) == INADDR_ANY)
d226 12
d272 7
a278 3
	for (p = netcb.nif_forw;
	     p != (struct netinfo *)&netcb;
	     p = p->nif_forw) {
d281 20
a300 2
		if (p->nif_lport != inp->inp_lport ||
		    p->nif_laddr.s_addr != inp->inp_laddr.s_addr)
a301 3
		if (p->nif_faddr.s_addr == inp->inp_faddr.s_addr &&
		    p->nif_fport == inp->inp_fport)
			break;
a312 1
		p->nif_laddr = inp->inp_laddr;
a313 1
		p->nif_faddr = inp->inp_faddr;
d317 13
d394 1
a394 3
	for (p = netcb.nif_forw;
	     p != (struct netinfo *)&netcb;
	     p = p->nif_forw) {
d406 12
a417 1
			inetprint(&p->nif_laddr, p->nif_lport, p->nif_proto);
d422 12
a433 1
			inetprint(&p->nif_faddr, p->nif_fport, p->nif_proto);
d437 4
d489 29
d523 1
a523 1
static char *
d561 26
@


1.10
log
@careful
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.9 1997/12/19 09:22:55 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.9 1997/12/19 09:22:55 deraadt Exp $";
d97 4
a100 4
	struct	netinfo *ni_forw, *ni_prev;
	short	ni_line;		/* line on screen */
	short	ni_seen;		/* 0 when not present in list */
	short	ni_flags;
d103 8
a110 8
	short	ni_state;		/* tcp state */
	char	*ni_proto;		/* protocol */
	struct	in_addr ni_laddr;	/* local address */
	long	ni_lport;		/* local port */
	struct	in_addr	ni_faddr;	/* foreign address */
	long	ni_fport;		/* foreign port */
	long	ni_rcvcc;		/* rcv buffer character count */
	long	ni_sndcc;		/* snd buffer character count */
d114 1
a114 1
	struct	netinfo *ni_forw, *ni_prev;
d131 1
a131 1
	p = (struct netinfo *)netcb.ni_forw;
d133 1
a133 1
		if (p->ni_line != -1)
d135 2
a136 2
		p->ni_line = -1;
		p = p->ni_forw;
d164 1
a164 1
	netcb.ni_forw = netcb.ni_prev = (struct netinfo *)&netcb;
d183 2
a184 2
	for (p = netcb.ni_forw; p != (struct netinfo *)&netcb; p = p->ni_forw)
		p->ni_seen = 0;
d205 3
a207 3
			p = netcb.ni_forw;
			for (; p != (struct netinfo *)&netcb; p = p->ni_forw)
				p->ni_seen = 1;
d250 4
a253 2
	for (p = netcb.ni_forw; p != (struct netinfo *)&netcb; p = p->ni_forw) {
		if (!streq(proto, p->ni_proto))
d255 2
a256 2
		if (p->ni_lport != inp->inp_lport ||
		    p->ni_laddr.s_addr != inp->inp_laddr.s_addr)
d258 2
a259 2
		if (p->ni_faddr.s_addr == inp->inp_faddr.s_addr &&
		    p->ni_fport == inp->inp_fport)
d267 16
a282 16
		p->ni_prev = (struct netinfo *)&netcb;
		p->ni_forw = netcb.ni_forw;
		netcb.ni_forw->ni_prev = p;
		netcb.ni_forw = p;
		p->ni_line = -1;
		p->ni_laddr = inp->inp_laddr;
		p->ni_lport = inp->inp_lport;
		p->ni_faddr = inp->inp_faddr;
		p->ni_fport = inp->inp_fport;
		p->ni_proto = proto;
		p->ni_flags = NIF_LACHG|NIF_FACHG;
	}
	p->ni_rcvcc = so->so_rcv.sb_cc;
	p->ni_sndcc = so->so_snd.sb_cc;
	p->ni_state = state;
	p->ni_seen = 1;
d318 1
a318 1
	p = netcb.ni_forw;
d320 2
a321 2
		if (p->ni_line == -1 || p->ni_seen) {
			p = p->ni_forw;
d324 5
a328 5
		wmove(wnd, p->ni_line, 0); wdeleteln(wnd);
		q = netcb.ni_forw;
		for (; q != (struct netinfo *)&netcb; q = q->ni_forw)
			if (q != p && q->ni_line > p->ni_line) {
				q->ni_line--;
d330 1
a330 1
				q->ni_flags |= NIF_LACHG|NIF_FACHG;
d333 3
a335 3
		q = p->ni_forw;
		p->ni_prev->ni_forw = p->ni_forw;
		p->ni_forw->ni_prev = p->ni_prev;
d342 4
a345 2
	for (p = netcb.ni_forw; p != (struct netinfo *)&netcb; p = p->ni_forw) {
		if (p->ni_line == -1) {
d351 2
a352 2
			p->ni_line = lastrow++;
			p->ni_flags |= NIF_LACHG|NIF_FACHG;
d354 4
a357 4
		if (p->ni_flags & NIF_LACHG) {
			wmove(wnd, p->ni_line, LADDR);
			inetprint(&p->ni_laddr, p->ni_lport, p->ni_proto);
			p->ni_flags &= ~NIF_LACHG;
d359 4
a362 4
		if (p->ni_flags & NIF_FACHG) {
			wmove(wnd, p->ni_line, FADDR);
			inetprint(&p->ni_faddr, p->ni_fport, p->ni_proto);
			p->ni_flags &= ~NIF_FACHG;
d364 7
a370 7
		mvwaddstr(wnd, p->ni_line, PROTO, p->ni_proto);
		mvwprintw(wnd, p->ni_line, RCVCC, "%6d", p->ni_rcvcc);
		mvwprintw(wnd, p->ni_line, SNDCC, "%6d", p->ni_sndcc);
		if (streq(p->ni_proto, "tcp"))
			if (p->ni_state < 0 || p->ni_state >= TCP_NSTATES)
				mvwprintw(wnd, p->ni_line, STATE, "%d",
				    p->ni_state);
d372 2
a373 2
				mvwaddstr(wnd, p->ni_line, STATE,
				    tcpstates[p->ni_state]);
d473 3
a475 3
		p = netcb.ni_forw;
		for (; p != (struct netinfo *)&netcb; p = p->ni_forw) {
			if (p->ni_line == -1)
d477 1
a477 1
			p->ni_flags |= NIF_LACHG|NIF_FACHG;
@


1.9
log
@proactive buffer blocks
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.8 1997/12/19 09:03:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.8 1997/12/19 09:03:33 deraadt Exp $";
d403 1
a403 1
	while (cp - line < 22)
@


1.8
log
@bye bye sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.7 1997/06/23 22:21:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.7 1997/06/23 22:21:48 millert Exp $";
d438 7
a444 5
	if (in.s_addr == INADDR_ANY)
		strcpy(line, "*");
	else if (cp)
		strncpy(line, cp, sizeof line);
	else {
@


1.7
log
@Cleanup by Theo and myself.  CMDLINE changed to long to make
command line work on 64bit platforms.  This is somewhat bogus
and is really just a temporary workaround (there may be a curses bug).
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.6 1997/01/17 07:13:26 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.6 1997/01/17 07:13:26 millert Exp $";
d391 1
a391 1
	sprintf(line, "%.*s.", 16, inetname(*in));
d396 2
a397 1
		sprintf(cp, "%.8s", sp ? sp->s_name : "*");
d399 2
a400 1
		sprintf(cp, "%d", ntohs((u_short)port));
d445 1
a445 1
		sprintf(line, "%u.%u.%u.%u", C(in.s_addr >> 24),
@


1.6
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.5 1996/08/06 18:48:15 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.5 1996/08/06 18:48:15 deraadt Exp $";
d71 1
@


1.5
log
@avoid buf oflows
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.4 1996/07/27 14:55:25 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.4 1996/07/27 14:55:25 deraadt Exp $";
d388 1
a388 1
	char line[80], *cp, *index();
d391 1
a391 1
	cp = index(line, '\0');
d399 1
a399 1
	cp = index(line, '\0');
@


1.4
log
@refresh screen better; freebsd pr#1425; from fn
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.3 1996/06/26 05:40:09 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.3 1996/06/26 05:40:09 deraadt Exp $";
d438 1
a438 1
		strcpy(line, cp);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: netstat.c,v 1.3 1995/06/18 23:53:07 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: netstat.c,v 1.3 1995/06/18 23:53:07 cgd Exp $";
d471 2
@


1.2
log
@it compiles w/ new curses
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: netstat.c,v 1.3 1995/06/18 23:53:07 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d84 1
a84 1
#define	YMAX(w)		((w)->maxy-1)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
