head	1.30;
access;
symbols
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.23.0.10
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.8
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.09.12.15.59.36;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	MYZfc1sszQnIuPd4;

1.29
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	waQzIVMqUqjBDjYt;

1.28
date	2014.10.08.04.10.04;	author doug;	state Exp;
branches;
next	1.27;
commitid	cpW0LtZf9XzHlFrl;

1.27
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.26;
commitid	uuiU9j2I8AUx0fez;

1.26
date	2013.06.02.06.23.17;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.10.03.20.59;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.02.15.19.35;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.12.34.22;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.01.19.05.25;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.08.19.28.56;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.18.00.46.48;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.07.07.57.35;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.28.05.36.18;	author pvalchev;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.04.16.48.34;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.18.17.59.55;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.12.19.09.03.33;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.06.23.22.21.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.10;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.02.19.40.16;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@use sysctl() to get FSCALE value; ok guenther
@
text
@/*	$OpenBSD: pigs.c,v 1.29 2015/01/16 00:03:37 deraadt Exp $	*/
/*	$NetBSD: pigs.c,v 1.3 1995/04/29 05:54:50 cgd Exp $	*/

/*-
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Pigs display from Bill Reeves at Lucasfilm
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/signal.h>
#include <sys/proc.h>
#include <sys/resource.h>
#include <sys/sched.h>
#include <sys/sysctl.h>
#include <sys/time.h>

#include <curses.h>
#include <math.h>
#include <pwd.h>
#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "systat.h"

int compar(const void *, const void *);
void print_pg(void);
int read_pg(void);
int select_pg(void);
void showpigs(int k);

static struct kinfo_proc *procbase = NULL;
static int nproc, pigs_cnt, *pb_indices = NULL;
static int onproc = -1;

static long stime[CPUSTATES];
static double  lccpu;
struct loadavg sysload;



field_def fields_pg[] = {
	{"USER", 6, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"NAME", 10, 24, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"PID", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"CPU", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"", 30, 60, 1, FLD_ALIGN_BAR, -1, 0, 0, 100},
};

#define FLD_PG_USER	FIELD_ADDR(fields_pg,0)
#define FLD_PG_NAME	FIELD_ADDR(fields_pg,1)
#define FLD_PG_PID	FIELD_ADDR(fields_pg,2)
#define FLD_PG_VALUE	FIELD_ADDR(fields_pg,3)
#define FLD_PG_BAR	FIELD_ADDR(fields_pg,4)

/* Define views */
field_def *view_pg_0[] = {
	FLD_PG_PID, FLD_PG_USER, FLD_PG_NAME, FLD_PG_VALUE, FLD_PG_BAR, NULL
};


/* Define view managers */
struct view_manager pigs_mgr = {
	"Pigs", select_pg, read_pg, NULL, print_header,
	print_pg, keyboard_callback, NULL, NULL
};

field_view views_pg[] = {
	{view_pg_0, "pigs", '5', &pigs_mgr},
	{NULL, NULL, 0, NULL}
};

int	fscale;

#define pctdouble(p) ((double)(p) / fscale)

typedef long pctcpu;

int
select_pg(void)
{
	int mib[] = { CTL_KERN, KERN_FSCALE };
	size_t size = sizeof(fscale);

        if (sysctl(mib, sizeof(mib) / sizeof(mib[0]),
            &fscale, &size, NULL, 0) < 0)
                return (-1);
	num_disp = pigs_cnt;
	return (0);
}


int
getprocs(void)
{
	size_t size;
	int mib[6] = {CTL_KERN, KERN_PROC, KERN_PROC_KTHREAD, 0, sizeof(struct kinfo_proc), 0};
	
	int st;

	free(procbase);
	procbase = NULL;

	st = sysctl(mib, 6, NULL, &size, NULL, 0);
	if (st == -1)
		return (1);

	size = 5 * size / 4;		/* extra slop */
	if ((procbase = malloc(size + 1)) == NULL)
		return (1);

	mib[5] = (int)(size / sizeof(struct kinfo_proc));
	st = sysctl(mib, 6, procbase, &size, NULL, 0);
	if (st == -1)
		return (1);

	nproc = (int)(size / sizeof(struct kinfo_proc));
	return (0);
}


int
read_pg(void)
{
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	long ctimes[CPUSTATES];
	double t;
	int i, k;
	size_t size;

	num_disp = pigs_cnt = 0;

	if (getprocs()) {
		error("Failed to read process info!");
		return 1;
	}

	if (nproc > onproc) {
		int *p;
		p = reallocarray(pb_indices, nproc + 1, sizeof(int));
		if (p == NULL) {
			error("Out of Memory!");
			return 1;
		}
		pb_indices = p;
		onproc = nproc;
	}

	memset(&procbase[nproc], 0, sizeof(*procbase));

	for (i = 0; i <= nproc; i++)
		pb_indices[i] = i;

	/*
	 * and for the imaginary "idle" process
	 */
	size = sizeof(ctimes);
	sysctl(cp_time_mib, 2, &ctimes, &size, NULL, 0);

	t = 0;
	for (i = 0; i < CPUSTATES; i++)
		t += ctimes[i] - stime[i];
	if (t == 0.0)
		t = 1.0;

	procbase[nproc].p_pctcpu = (ctimes[CP_IDLE] - stime[CP_IDLE]) / t / pctdouble(1);
	for (i = 0; i < CPUSTATES; i++)
		stime[i] = ctimes[i];

	qsort(pb_indices, nproc + 1, sizeof (int), compar);

	pigs_cnt = 0;
	for (k = 0; k < nproc + 1; k++) {
		int j = pb_indices[k];
		if (pctdouble(procbase[j].p_pctcpu) < 0.01)
			break;
		pigs_cnt++;
	}

	num_disp = pigs_cnt;
	return 0;
}


void
print_pg(void)
{
	int n, count = 0;

	for (n = dispstart; n < num_disp; n++) {
		showpigs(pb_indices[n]);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}

int
initpigs(void)
{
	static int sysload_mib[] = {CTL_VM, VM_LOADAVG};
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int ccpu_mib[] = { CTL_KERN, KERN_CCPU };
	field_view *v;
	size_t size;
	fixpt_t ccpu;

	size = sizeof(stime);
	sysctl(cp_time_mib, 2, &stime, &size, NULL, 0);

	size = sizeof(sysload);
	sysctl(sysload_mib, 2, &sysload, &size, NULL, 0);

	size = sizeof(ccpu);
	sysctl(ccpu_mib, 2, &ccpu, &size, NULL, 0);

	lccpu = log((double) ccpu / sysload.fscale);

	for (v = views_pg; v->name != NULL; v++)
		add_view(v);

	return(1);
}

void
showpigs(int k)
{
	struct kinfo_proc *kp;
	double value;
	char *uname, *pname;

	if (procbase == NULL)
		return;

	value = pctdouble(procbase[k].p_pctcpu) * 100;

	kp = &procbase[k];
	if (kp->p_comm[0] == '\0') {
		uname = "";
		pname = "<idle>";
	} else {
		uname = user_from_uid(kp->p_uid, 0);
		pname = kp->p_comm;
		print_fld_uint(FLD_PG_PID, kp->p_pid);
	}

	tb_start();
	tbprintf("%.2f", value);
	print_fld_tb(FLD_PG_VALUE);

	print_fld_str(FLD_PG_NAME, pname);
	print_fld_str(FLD_PG_USER, uname);
	print_fld_bar(FLD_PG_BAR, value);

	end_line();
}


int
compar(const void *a, const void *b)
{
	int i1 = *((int *)a);
	int i2 = *((int *)b);

	return procbase[i1].p_pctcpu > 
		procbase[i2].p_pctcpu ? -1 : 1;
}

@


1.29
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.28 2014/10/08 04:10:04 doug Exp $	*/
d101 1
d103 3
a105 12
#ifdef FSCALE
# define FIXED_LOADAVG FSCALE
# define FIXED_PCTCPU FSCALE
#endif

#ifdef FIXED_PCTCPU
  typedef long pctcpu;
# define pctdouble(p) ((double)(p) / FIXED_PCTCPU)
#else
typedef double pctcpu;
# define pctdouble(p) (p)
#endif
d110 6
@


1.28
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.27 2014/09/15 19:08:21 miod Exp $	*/
d37 2
a38 1
#include <sys/param.h>
@


1.27
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.26 2013/06/02 06:23:17 guenther Exp $	*/
d169 1
a169 1
		p = realloc(pb_indices, (nproc + 1) * sizeof(int));
@


1.26
log
@<sys/dir.h> isn't needed here
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.25 2011/04/10 03:20:59 guenther Exp $	*/
d38 1
a38 1
#include <sys/dkstat.h>
d40 2
a42 2
#include <sys/proc.h>
#include <sys/sysctl.h>
@


1.25
log
@Switch back from KERN_PROC2/kinfo_proc2 to KERN_PROC/kinfo_proc now
that we've got name we want for the API we want

"ZAP!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.24 2011/03/02 06:48:17 jasper Exp $	*/
a39 1
#include <sys/dir.h>
@


1.24
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.23 2008/12/07 02:56:06 canacar Exp $	*/
d60 1
a60 1
static struct kinfo_proc2 *procbase = NULL;
d127 1
a127 1
	int mib[6] = {CTL_KERN, KERN_PROC2, KERN_PROC_KTHREAD, 0, sizeof(struct kinfo_proc2), 0};
d142 1
a142 1
	mib[5] = (int)(size / sizeof(struct kinfo_proc2));
d147 1
a147 1
	nproc = (int)(size / sizeof(struct kinfo_proc2));
d258 1
a258 1
	struct kinfo_proc2 *kp;
@


1.23
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.22 2008/06/12 22:26:01 canacar Exp $	*/
d78 5
a82 7
#define FIELD_ADDR(x) (&fields_pg[x])

#define FLD_PG_USER	FIELD_ADDR(0)
#define FLD_PG_NAME	FIELD_ADDR(1)
#define FLD_PG_PID	FIELD_ADDR(2)
#define FLD_PG_VALUE	FIELD_ADDR(3)
#define FLD_PG_BAR	FIELD_ADDR(4)
@


1.22
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.21 2007/09/02 15:19:35 deraadt Exp $	*/
d158 1
a158 1
	long ctime[CPUSTATES];
d189 2
a190 2
	size = sizeof(ctime);
	sysctl(cp_time_mib, 2, &ctime, &size, NULL, 0);
d194 1
a194 1
		t += ctime[i] - stime[i];
d198 1
a198 1
	procbase[nproc].p_pctcpu = (ctime[CP_IDLE] - stime[CP_IDLE]) / t / pctdouble(1);
d200 1
a200 1
		stime[i] = ctime[i];
d206 2
a207 2
		int i = pb_indices[k];
		if (pctdouble(procbase[i].p_pctcpu) < 0.01)
@


1.21
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.20 2007/02/25 18:21:24 deraadt Exp $	*/
a32 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)pigs.c	8.2 (Berkeley) 9/23/93";
#endif
static char rcsid[] = "$OpenBSD: pigs.c,v 1.20 2007/02/25 18:21:24 deraadt Exp $";
#endif /* not lint */

a51 1
#include "extern.h"
d55 8
a62 6

static int nproc;
static struct p_times {
	float pt_pctcpu;
	struct kinfo_proc2 *pt_kp;
} *pt;
d66 3
d70 49
a118 2
WINDOW *
openpigs(void)
d120 2
a121 1
	return (subwin(stdscr, LINES-1-2, 0, 2, 0));
d124 3
a126 2
void
closepigs(WINDOW *w)
d128 23
a150 5
	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
d154 2
a155 2
void
showpigs(void)
d157 7
a163 5
	int i, j, y, k;
	struct kinfo_proc2 *kp;
	float total;
	int factor;
	char *uname, *pname, pidname[30];
d165 3
a167 7
	if (pt == NULL)
		return;
	/* Accumulate the percent of cpu per user. */
	total = 0.0;
	for (i = 0; i <= nproc; i++) {
		/* Accumulate the percentage. */
		total += pt[i].pt_pctcpu;
d170 6
a175 17
	if (total < 1.0)
		total = 1.0;
	factor = 50.0/total;

	qsort(pt, nproc + 1, sizeof (struct p_times), compar);
	y = 1;
	i = nproc + 1;
	if (i > wnd->_maxy-1)
		i = wnd->_maxy-1;
	for (k = 0; i > 0 && pt[k].pt_pctcpu > 0.01; i--, y++, k++) {
		kp = pt[k].pt_kp;
		if (kp == NULL) {
			uname = "";
			pname = "<idle>";
		} else {
			uname = user_from_uid(kp->p_uid, 0);
			pname = kp->p_comm;
d177 2
a178 8
		wmove(wnd, y, 0);
		wclrtoeol(wnd);
		mvwaddstr(wnd, y, 0, uname);
		snprintf(pidname, sizeof pidname, "%10.10s", pname);
		mvwaddstr(wnd, y, 9, pidname);
		wmove(wnd, y, 20);
		for (j = pt[k].pt_pctcpu*factor + 0.5; j > 0; j--)
			waddch(wnd, 'X');
d180 34
a213 1
	wmove(wnd, y, 0); wclrtobot(wnd);
d216 13
a228 1
struct loadavg sysload;
d236 1
d241 1
a241 1
	(void) sysctl(cp_time_mib, 2, &stime, &size, NULL, 0);
d244 1
a244 1
	(void) sysctl(sysload_mib, 2, &sysload, &size, NULL, 0);
d247 1
a247 1
	(void) sysctl(ccpu_mib, 2, &ccpu, &size, NULL, 0);
d251 3
d258 1
a258 1
fetchpigs(void)
d260 3
a262 8
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int lastnproc = 0;
	struct kinfo_proc2 *kpp;
	long ctime[CPUSTATES];
	double t;
	int i;
	size_t size;
	float *pctp;
d264 1
a264 5
	kpp = kvm_getproc2(kd, KERN_PROC_KTHREAD, 0, sizeof(*kpp), &nproc);
	if (kpp == NULL) {
		error("%s", kvm_geterr(kd));
		if (pt)
			free(pt);
d266 11
a277 25
	if (nproc > lastnproc) {
		free(pt);
		if ((pt = calloc(nproc + 1, sizeof(struct p_times))) == NULL) {
			error("Out of memory");
			die();
		}
	}
	lastnproc = nproc;
	/*
	 * calculate %cpu for each proc
	 */
	for (i = 0; i < nproc; i++) {
		pt[i].pt_kp = &kpp[i];
		pctp = &pt[i].pt_pctcpu;
		if (kpp->p_swtime == 0)
			*pctp = 0;
		else
			*pctp = ((double) kpp->p_pctcpu / sysload.fscale) /
			    (1.0 - exp(kpp->p_swtime * lccpu));
	}
	/*
	 * and for the imaginary "idle" process
	 */
	size = sizeof(ctime);
	(void) sysctl(cp_time_mib, 2, &ctime, &size, NULL, 0);
d279 9
a287 9
	t = 0;
	for (i = 0; i < CPUSTATES; i++)
		t += ctime[i] - stime[i];
	if (t == 0.0)
		t = 1.0;
	pt[nproc].pt_kp = NULL;
	pt[nproc].pt_pctcpu = (ctime[CP_IDLE] - stime[CP_IDLE]) / t;
	for (i = 0; i < CPUSTATES; i++)
		stime[i] = ctime[i];
a289 8
void
labelpigs(void)
{
	wmove(wnd, 0, 0);
	wclrtoeol(wnd);
	mvwaddstr(wnd, 0, 20,
	    "/0   /10  /20  /30  /40  /50  /60  /70  /80  /90  /100");
}
d294 5
a298 2
	return (((struct p_times *)a)->pt_pctcpu >
	    ((struct p_times *)b)->pt_pctcpu) ? -1 : 1;
d300 1
@


1.20
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.19 2006/11/29 12:34:22 miod Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.19 2006/11/29 12:34:22 miod Exp $";
d184 1
a184 2
		if ((pt =
		    malloc((nproc + 1) * sizeof(struct p_times))) == NULL) {
@


1.19
log
@Do not test for processes being swapped out since this can't happen anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.18 2006/03/31 04:10:59 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.18 2006/03/31 04:10:59 deraadt Exp $";
d76 1
a76 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
@


1.18
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.17 2006/02/01 19:05:25 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.17 2006/02/01 19:05:25 otto Exp $";
d197 1
a197 1
		if (kpp->p_swtime == 0 || (kpp->p_flag & P_INMEM) == 0)
@


1.17
log
@double semicolon; from Daniel Matic in PR 4929
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.16 2004/01/08 19:28:56 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.16 2004/01/08 19:28:56 millert Exp $";
d232 2
a233 2
	return (((struct p_times *) a)->pt_pctcpu >
	    ((struct p_times *) b)->pt_pctcpu)? -1: 1;
@


1.16
log
@Convert to kvm_getproc2(); ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.15 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.15 2003/06/03 02:56:17 millert Exp $";
d173 1
a173 1
	float *pctp;;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.14 2002/06/18 00:46:48 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.14 2002/06/18 00:46:48 deraadt Exp $";
d67 1
a67 1
	struct kinfo_proc *pt_kp;
d94 1
a94 1
	struct	eproc *ep;
d118 2
a119 1
		if (pt[k].pt_kp == NULL) {
d123 2
a124 3
			ep = &pt[k].pt_kp->kp_eproc;
			uname = user_from_uid(ep->e_ucred.cr_uid, 0);
			pname = pt[k].pt_kp->kp_proc.p_comm;
d168 1
a168 1
	struct kinfo_proc *kpp;
a169 1
	float time;
d173 1
a173 2
	struct proc *pp;
	float *pctp;
d175 2
a176 1
	if ((kpp = kvm_getprocs(kd, KERN_PROC_KTHREAD, 0, &nproc)) == NULL) {
a195 1
		pp = &kpp[i].kp_proc;
d197 1
a197 2
		time = pp->p_swtime;
		if (time == 0 || (pp->p_flag & P_INMEM) == 0)
d200 2
a201 2
			*pctp = ((double) pp->p_pctcpu /
			    sysload.fscale) / (1.0 - exp(time * lccpu));
@


1.14
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.13 2002/02/16 21:27:54 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.13 2002/02/16 21:27:54 millert Exp $";
@


1.13
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.12 2001/12/07 09:18:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.12 2001/12/07 09:18:08 deraadt Exp $";
d78 1
a78 1
openpigs()
d84 1
a84 2
closepigs(w)
	WINDOW *w;
d95 1
a95 1
showpigs()
d113 1
a113 1
 		total = 1.0;
d145 1
a145 1
initpigs()
d168 1
a168 1
fetchpigs()
d228 1
a228 1
labelpigs()
d237 1
a237 2
compar(a, b)
	const void *a, *b;
d240 1
a240 1
		((struct p_times *) b)->pt_pctcpu)? -1: 1;
@


1.12
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.10 2001/11/23 22:20:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.10 2001/11/23 22:20:06 deraadt Exp $";
d66 1
a66 1
int compar __P((const void *, const void *));
@


1.11
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.9 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.9 2001/11/19 19:02:16 mpech Exp $";
d50 1
a57 1
#include <nlist.h>
a74 1
static int     fscale;
d117 1
a117 1
        qsort(pt, nproc + 1, sizeof (struct p_times), compar);
d126 1
a126 2
		}
		else {
d143 1
a143 11
static struct nlist namelist[] = {
#define X_FIRST		0
#define X_CPTIME	0
	{ "_cp_time" },
#define X_CCPU          1
	{ "_ccpu" },
#define X_FSCALE        2
	{ "_fscale" },

	{ "" }
};
d148 4
a152 1
	int ret;
d154 10
a163 14
	if (namelist[X_FIRST].n_type == 0) {
		if ((ret = kvm_nlist(kd, namelist)) == -1)
			errx(1, "%s", kvm_geterr(kd));
		else if (ret)
			nlisterr(namelist);
		if (namelist[X_FIRST].n_type == 0) {
			error("namelist failed");
			return(0);
		}
	}
	KREAD(NPTR(X_CPTIME), stime, sizeof (stime));
	NREAD(X_CCPU, &ccpu, LONG);
	NREAD(X_FSCALE,  &fscale, LONG);
	lccpu = log((double) ccpu / fscale);
d171 6
d178 1
a178 1
	float time;
a180 4
	struct kinfo_proc *kpp;
	long ctime[CPUSTATES];
	double t;
	static int lastnproc = 0;
a181 2
	if (namelist[X_FIRST].n_type == 0)
		return;
d193 1
a193 1
			die(0);
d208 2
a209 2
			*pctp = ((double) pp->p_pctcpu / 
					fscale) / (1.0 - exp(time * lccpu));
d214 3
a216 1
	KREAD(NPTR(X_CPTIME), ctime, sizeof (ctime));
@


1.10
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@a49 1
#include <sys/resource.h>
d57 1
d75 1
d118 1
a118 1
	qsort(pt, nproc + 1, sizeof (struct p_times), compar);
d127 2
a128 1
		} else {
d145 11
a155 1
struct loadavg sysload;
a159 4
	static int sysload_mib[] = {CTL_VM, VM_LOADAVG};
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int ccpu_mib[] = { CTL_KERN, KERN_CCPU };
	size_t size;
d161 1
d163 14
a176 10
	size = sizeof(stime);
	(void) sysctl(cp_time_mib, 2, &stime, &size, NULL, 0);

	size = sizeof(sysload);
	(void) sysctl(sysload_mib, 2, &sysload, &size, NULL, 0);

	size = sizeof(ccpu);
	(void) sysctl(ccpu_mib, 2, &ccpu, &size, NULL, 0);

	lccpu = log((double) ccpu / sysload.fscale);
d184 4
a187 2
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int lastnproc = 0;
a189 1
	float time;
d191 1
a191 4
	int i;
	size_t size;
	struct proc *pp;
	float *pctp;
d193 2
d206 1
a206 1
			die();
d221 2
a222 2
			*pctp = ((double) pp->p_pctcpu /
			    sysload.fscale) / (1.0 - exp(time * lccpu));
d227 1
a227 3
	size = sizeof(ctime);
	(void) sysctl(cp_time_mib, 2, &ctime, &size, NULL, 0);

@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.8 2001/07/28 05:36:18 pvalchev Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.8 2001/07/28 05:36:18 pvalchev Exp $";
d50 1
a57 1
#include <nlist.h>
a74 1
static int     fscale;
d117 1
a117 1
        qsort(pt, nproc + 1, sizeof (struct p_times), compar);
d126 1
a126 2
		}
		else {
d143 1
a143 11
static struct nlist namelist[] = {
#define X_FIRST		0
#define X_CPTIME	0
	{ "_cp_time" },
#define X_CCPU          1
	{ "_ccpu" },
#define X_FSCALE        2
	{ "_fscale" },

	{ "" }
};
d148 4
a152 1
	int ret;
d154 10
a163 14
	if (namelist[X_FIRST].n_type == 0) {
		if ((ret = kvm_nlist(kd, namelist)) == -1)
			errx(1, "%s", kvm_geterr(kd));
		else if (ret)
			nlisterr(namelist);
		if (namelist[X_FIRST].n_type == 0) {
			error("namelist failed");
			return(0);
		}
	}
	KREAD(NPTR(X_CPTIME), stime, sizeof (stime));
	NREAD(X_CCPU, &ccpu, LONG);
	NREAD(X_FSCALE,  &fscale, LONG);
	lccpu = log((double) ccpu / fscale);
d171 6
d178 1
a178 1
	float time;
a180 4
	struct kinfo_proc *kpp;
	long ctime[CPUSTATES];
	double t;
	static int lastnproc = 0;
a181 2
	if (namelist[X_FIRST].n_type == 0)
		return;
d193 1
a193 1
			die(0);
d208 2
a209 2
			*pctp = ((double) pp->p_pctcpu / 
					fscale) / (1.0 - exp(time * lccpu));
d214 3
a216 1
	KREAD(NPTR(X_CPTIME), ctime, sizeof (ctime));
@


1.8
log
@Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.7 2001/05/04 16:48:34 ericj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.7 2001/05/04 16:48:34 ericj Exp $";
d99 1
a99 1
	register int i, j, y, k;
d184 4
a187 4
	register int i;
	register float time;
	register struct proc *pp;
	register float *pctp;
@


1.7
log
@
handle kvm_nlist() failing, from pr#1798.
Patch similar to the one submitted by <peterw@@documenta.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.6 2000/06/18 17:59:55 niklas Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.6 2000/06/18 17:59:55 niklas Exp $";
d59 1
@


1.6
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.5 1997/12/19 09:03:33 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.5 1997/12/19 09:03:33 deraadt Exp $";
d160 1
d163 3
a165 1
		if (kvm_nlist(kd, namelist)) {
a166 2
		        return(0);
		}
@


1.5
log
@bye bye sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.4 1997/06/23 22:21:48 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.4 1997/06/23 22:21:48 millert Exp $";
d193 1
a193 1
	if ((kpp = kvm_getprocs(kd, KERN_PROC_ALL, 0, &nproc)) == NULL) {
@


1.4
log
@Cleanup by Theo and myself.  CMDLINE changed to long to make
command line work on 64bit platforms.  This is somewhat bogus
and is really just a temporary workaround (there may be a curses bug).
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.3 1996/06/26 05:40:10 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.3 1996/06/26 05:40:10 deraadt Exp $";
d135 1
a135 1
		sprintf(pidname, "%10.10s", pname);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: pigs.c,v 1.3 1995/04/29 05:54:50 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: pigs.c,v 1.3 1995/04/29 05:54:50 cgd Exp $";
d135 1
a135 1
		sprintf(pidname, "%10.10s", pname, 0);
@


1.2
log
@it compiles w/ new curses
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: pigs.c,v 1.3 1995/04/29 05:54:50 cgd Exp $";
@


1.1
log
@Initial revision
@
text
@d119 2
a120 2
	if (i > wnd->maxy-1)
		i = wnd->maxy-1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
