head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.2
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.45.0.12
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.8
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.4
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.45.0.6
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.42.0.8
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.6
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.40.0.6
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.4
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.23.0.10
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.10
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2017.04.16.14.24.03;	author beck;	state Exp;
branches;
next	1.46;
commitid	cOEDfkCsmOFfFww7;

1.46
date	2017.04.02.00.27.44;	author beck;	state Exp;
branches;
next	1.45;
commitid	H0BBNcmbzz7o0bPK;

1.45
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	waQzIVMqUqjBDjYt;

1.44
date	2014.11.23.04.34.48;	author guenther;	state Exp;
branches;
next	1.43;
commitid	LIj2x3qvN0HcH7BW;

1.43
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.42;
commitid	uuiU9j2I8AUx0fez;

1.42
date	2013.07.09.15.37.43;	author beck;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.11.19.01.20;	author beck;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.19.14.48.04;	author beck;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.06.00.11.57;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.09.14.38.36;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.06.17.52.39;	author jasper;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.01.18.03.06;	author naddy;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.22.08.05.02;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.07.17.16.27;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.13.08.18.47;	author canacar;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.12.17.53.49;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.30.05.20.58;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.29.21.17.27;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.27.10.28.25;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.15.22.56.12;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.02.18.20.41;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.16.01.57.04;	author tdeval;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.18.00.46.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.07.07.57.35;	author pvalchev;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.12.12.03.03;	author heko;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.07.20.47.25;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.12.19.09.03.32;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.15.14.41.06;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.23.22.21.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.04.04.42.42;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.06.18.50.50;	author maja;	state Exp;
branches;
next	1.5;

1.5
date	96.06.26.05.40.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.02.19.40.14;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.35.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Statistics for high memory flips in the buffer cache
nits from deraadt@@
ok krw@@ guenther@@ kettenis@@
@
text
@/*	$OpenBSD: iostat.c,v 1.46 2017/04/02 00:27:44 beck Exp $	*/
/*	$NetBSD: iostat.c,v 1.5 1996/05/10 23:16:35 thorpej Exp $	*/

/*
 * Copyright (c) 1980, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mount.h>
#include <sys/signal.h>
#include <sys/sched.h>
#include <sys/sysctl.h>
#include <sys/time.h>

#include <string.h>
#include <stdlib.h>
#include <paths.h>
#include "systat.h"

#include "dkstats.h"
extern struct _disk	cur, last;
struct bcachestats	bclast, bccur;

static double etime;

void showtotal(void);
void showdrive(int);
void print_io(void);
int read_io(void);
int select_io(void);
void showbcache(void);

#define ATIME(x,y) ((double)x[y].tv_sec + \
        ((double)x[y].tv_usec / (double)1000000))


field_def fields_io[] = {
	{"DEVICE", 8, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"READ", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"WRITE", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"RTPS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"WTPS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"SEC", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"", 8, 19, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"STATS", 12, 15, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0}
};

#define FLD_IO_DEVICE	FIELD_ADDR(fields_io,0)
#define FLD_IO_READ	FIELD_ADDR(fields_io,1)
#define FLD_IO_WRITE	FIELD_ADDR(fields_io,2)
#define FLD_IO_RTPS	FIELD_ADDR(fields_io,3)
#define FLD_IO_WTPS	FIELD_ADDR(fields_io,4)
#define FLD_IO_SEC	FIELD_ADDR(fields_io,5)

/* This is a hack that stuffs bcache statistics to the last two columns! */
#define FLD_IO_SVAL	FIELD_ADDR(fields_io,6)
#define FLD_IO_SSTR	FIELD_ADDR(fields_io,7)

/* Define views */
field_def *view_io_0[] = {
	FLD_IO_DEVICE, FLD_IO_READ, FLD_IO_WRITE, FLD_IO_RTPS,
	FLD_IO_WTPS, FLD_IO_SEC, FLD_IO_SVAL, FLD_IO_SSTR, NULL
};


/* Define view managers */
struct view_manager iostat_mgr = {
	"Iostat", select_io, read_io, NULL, print_header,
	print_io, keyboard_callback, NULL, NULL
};


field_view views_io[] = {
	{view_io_0, "iostat", '2', &iostat_mgr},
	{NULL, NULL, 0, NULL}
};


int
select_io(void)
{
	num_disp = cur.dk_ndrive + 1;
	return (0);
}

int
read_io(void)
{
	int mib[3];
	size_t size;

	dkreadstats();
	dkswap();
	num_disp = cur.dk_ndrive + 1;

	bclast = bccur;
	mib[0] = CTL_VFS;
	mib[1] = VFS_GENERIC;
	mib[2] = VFS_BCACHESTAT;
	size = sizeof(bccur);

	if (sysctl(mib, 3, &bccur, &size, NULL, 0) < 0)
		error("cannot get vfs.bcachestat");

	if (bclast.numbufs == 0)
		bclast = bccur;

	return 0;
}


void
print_io(void)
{
	int n, count = 0;

	int curr;
	etime = naptime;

	/* XXX engine internals: save and restore curr_line for bcache */
	curr = curr_line;

	for (n = dispstart; n < num_disp - 1; n++) {
		showdrive(n);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}


	if (maxprint == 0 || count < maxprint)
		showtotal();

	curr_line = curr;
	showbcache();
}

int
initiostat(void)
{
	field_view *v;

	dkinit(1);
	dkreadstats();

	bzero(&bccur, sizeof(bccur));

	for (v = views_io; v->name != NULL; v++)
		add_view(v);

	return(1);
}

void
showtotal(void)
{
	double rsum, wsum, rtsum, wtsum, mssum;
	int dn;

	rsum = wsum = rtsum = wtsum = mssum = 0.0;

	for (dn = 0; dn < cur.dk_ndrive; dn++) {
		rsum += cur.dk_rbytes[dn] / etime;
		wsum += cur.dk_wbytes[dn] / etime;
		rtsum += cur.dk_rxfer[dn] / etime;
		wtsum += cur.dk_wxfer[dn] / etime;
		mssum += ATIME(cur.dk_time, dn) / etime;
	}

	print_fld_str(FLD_IO_DEVICE, "Totals");
	print_fld_size(FLD_IO_READ, rsum);
	print_fld_size(FLD_IO_WRITE, wsum);
	print_fld_size(FLD_IO_RTPS, rtsum);
	print_fld_size(FLD_IO_WTPS, wtsum);
	print_fld_float(FLD_IO_SEC, mssum, 1);

	end_line();
}

void
showdrive(int dn)
{
	print_fld_str(FLD_IO_DEVICE, cur.dk_name[dn]);
	print_fld_size(FLD_IO_READ, cur.dk_rbytes[dn]/etime);
	print_fld_size(FLD_IO_WRITE, cur.dk_wbytes[dn]/ etime);
	print_fld_size(FLD_IO_RTPS, cur.dk_rxfer[dn] / etime);
	print_fld_size(FLD_IO_WTPS, cur.dk_wxfer[dn] / etime);
	print_fld_float(FLD_IO_SEC, ATIME(cur.dk_time, dn) / etime, 1);

	end_line();
}

void
showbcache(void)
{
	print_fld_str(FLD_IO_SSTR, "total pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.numbufpages);
	end_line();

	print_fld_str(FLD_IO_SSTR, "dma pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.dmapages);
	end_line();

	print_fld_str(FLD_IO_SSTR, "dirty pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.numdirtypages);
	end_line();

	print_fld_str(FLD_IO_SSTR, "delwri bufs");
	print_fld_ssize(FLD_IO_SVAL, bccur.delwribufs);
	end_line();

	print_fld_str(FLD_IO_SSTR, "busymap bufs");
	print_fld_ssize(FLD_IO_SVAL, bccur.busymapped);
	end_line();

	print_fld_str(FLD_IO_SSTR, "avail kvaslots");
	print_fld_ssize(FLD_IO_SVAL, bccur.kvaslots_avail);
	end_line();

	print_fld_str(FLD_IO_SSTR, "kvaslots");
	print_fld_ssize(FLD_IO_SVAL, bccur.kvaslots);
	end_line();

	print_fld_str(FLD_IO_SSTR, "pending writes");
	print_fld_ssize(FLD_IO_SVAL, bccur.pendingwrites);
	end_line();

	print_fld_str(FLD_IO_SSTR, "pending reads");
	print_fld_ssize(FLD_IO_SVAL, bccur.pendingreads);
	end_line();

	print_fld_str(FLD_IO_SSTR, "cache hits");
	print_fld_ssize(FLD_IO_SVAL, bccur.cachehits - bclast.cachehits);
	end_line();

	print_fld_str(FLD_IO_SSTR, "high flips");
	print_fld_ssize(FLD_IO_SVAL, bccur.highflips - bclast.highflips);
	end_line();

	print_fld_str(FLD_IO_SSTR, "high flops");
	print_fld_ssize(FLD_IO_SVAL, bccur.highflops - bclast.highflops);
	end_line();

	print_fld_str(FLD_IO_SSTR, "dma flips");
	print_fld_ssize(FLD_IO_SVAL, bccur.dmaflips - bclast.dmaflips);
	end_line();
}
@


1.46
log
@Make dma range buffer cache pages visible in systat io
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.45 2015/01/16 00:03:37 deraadt Exp $	*/
d259 12
@


1.45
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.44 2014/11/23 04:34:48 guenther Exp $	*/
d223 4
@


1.44
log
@<sys/buf.h> isn't actually needed here

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.43 2014/09/15 19:08:21 miod Exp $	*/
d33 1
a33 1
#include <sys/param.h>
d35 1
@


1.43
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.42 2013/07/09 15:37:43 beck Exp $	*/
a33 1
#include <sys/buf.h>
@


1.42
log
@back out the cache flipper temporarily to work out of tree.
will come back soon.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.40 2011/09/19 14:48:04 beck Exp $	*/
a33 1
#include <sys/dkstat.h>
d35 3
a38 2
#include <sys/sysctl.h>
#include <sys/mount.h>
@


1.41
log
@High memory page flipping for the buffer cache.

This change splits the buffer cache free lists into lists of dma reachable
buffers and high memory buffers based on the ranges returned by pmemrange.
Buffers move from dma to high memory as they age, but are flipped to dma
reachable memory if IO is needed to/from and high mem buffer. The total
amount of buffers  allocated is now bufcachepercent of both the dma and
the high memory region.

This change allows the use of large buffer caches on amd64 using more than
4 GB of memory

ok tedu@@ krw@@ - testing by many.
@
text
@a224 4
	print_fld_str(FLD_IO_SSTR, "dma pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.dmapages);
	end_line();

@


1.40
log
@clean up buffer cache statistics somewhat to
remove some now useless statistics, and add some
relevant ones regarding kva usage in the cache.

make systat io and show bcstats in ddb both show
these counters.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.39 2011/07/06 00:11:57 beck Exp $	*/
d223 4
@


1.39
log
@add a couple of fields needed for buffer flipping, and change systat to
show useful info in systat io instead of goo
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.38 2011/03/02 06:48:17 jasper Exp $	*/
d225 14
a238 2
	print_fld_str(FLD_IO_SSTR, "dma pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.dmapages);
d241 2
a242 2
	print_fld_str(FLD_IO_SSTR, "dirty pages");
	print_fld_ssize(FLD_IO_SVAL, bccur.numdirtypages);
@


1.38
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.37 2009/08/09 14:38:36 art Exp $	*/
d221 1
a221 9
	print_fld_str(FLD_IO_SSTR, "numbufs");
	print_fld_ssize(FLD_IO_SVAL, bccur.numbufs);
	end_line();

	print_fld_str(FLD_IO_SSTR, "freebufs");
	print_fld_ssize(FLD_IO_SVAL, bccur.freebufs);
	end_line();

	print_fld_str(FLD_IO_SSTR, "numbufpages");
d225 2
a226 2
	print_fld_str(FLD_IO_SSTR, "numfreepages");
	print_fld_ssize(FLD_IO_SVAL, bccur.numfreepages);
d229 1
a229 1
	print_fld_str(FLD_IO_SSTR, "numdirtypages");
d233 1
a233 5
	print_fld_str(FLD_IO_SSTR, "numcleanpages");
	print_fld_ssize(FLD_IO_SVAL, bccur.numcleanpages);
	end_line();

	print_fld_str(FLD_IO_SSTR, "pendingwrites");
d237 1
a237 1
	print_fld_str(FLD_IO_SSTR, "pendingreads");
d241 1
a241 9
	print_fld_str(FLD_IO_SSTR, "numwrites");
	print_fld_ssize(FLD_IO_SVAL, bccur.numwrites - bclast.numwrites);
	end_line();

	print_fld_str(FLD_IO_SSTR, "numreads");
	print_fld_ssize(FLD_IO_SVAL, bccur.numreads - bclast.numreads);
	end_line();

	print_fld_str(FLD_IO_SSTR, "cachehits");
a242 4
	end_line();

	print_fld_str(FLD_IO_SSTR, "busymapped");
	print_fld_ssize(FLD_IO_SVAL, bccur.busymapped);
@


1.37
log
@Show the busy and mapped pages in iostat.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.36 2009/06/06 17:52:39 jasper Exp $	*/
d73 6
a78 8
#define FIELD_ADDR(x) (&fields_io[x])

#define FLD_IO_DEVICE	FIELD_ADDR(0)
#define FLD_IO_READ	FIELD_ADDR(1)
#define FLD_IO_WRITE	FIELD_ADDR(2)
#define FLD_IO_RTPS	FIELD_ADDR(3)
#define FLD_IO_WTPS	FIELD_ADDR(4)
#define FLD_IO_SEC	FIELD_ADDR(5)
d81 2
a82 2
#define FLD_IO_SVAL	FIELD_ADDR(6)
#define FLD_IO_SSTR	FIELD_ADDR(7)
@


1.36
log
@- remove unused macro from iostat.c
- minor space nit in engine.c

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.35 2008/12/07 02:56:06 canacar Exp $	*/
d265 4
@


1.35
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.34 2008/12/01 18:03:06 naddy Exp $	*/
a218 7


#define ENDLINE do {					\
		count++;				\
 		if (maxprint > 0 && count >= maxprint)	\
			return;				\
	} while(0)
@


1.34
log
@Add a function to print a floating point field and use this to fix the
SEConds field in the iostat view.
ok and help canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.33 2008/07/22 08:05:02 thib Exp $	*/
d144 1
a144 1
	int i, curr;
a229 2
	int count = 0;

@


1.33
log
@change the bcachestats structures members to int64_t's and do the
printing in systat with the new print_fld_ssize() function.

"same diff I wrote" deraadt@@
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.32 2008/07/07 17:16:27 thib Exp $	*/
d202 1
a202 1
	print_fld_size(FLD_IO_SEC, mssum);
d215 1
a215 1
	print_fld_size(FLD_IO_SEC, ATIME(cur.dk_time, dn) / etime);
@


1.32
log
@
bcachestats got bumbed too u_int64_t's and I forgot about
munging systat to handle the field with;

pointed out by mickey

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.31 2008/06/13 08:18:47 canacar Exp $	*/
d233 1
a233 1
	print_fld_size(FLD_IO_SVAL, bccur.numbufs);
d237 1
a237 1
	print_fld_size(FLD_IO_SVAL, bccur.freebufs);
d241 1
a241 1
	print_fld_size(FLD_IO_SVAL, bccur.numbufpages);
d245 1
a245 1
	print_fld_size(FLD_IO_SVAL, bccur.numfreepages);
d249 1
a249 1
	print_fld_size(FLD_IO_SVAL, bccur.numdirtypages);
d253 1
a253 1
	print_fld_size(FLD_IO_SVAL, bccur.numcleanpages);
d257 1
a257 1
	print_fld_size(FLD_IO_SVAL, bccur.pendingwrites);
d261 1
a261 1
	print_fld_size(FLD_IO_SVAL, bccur.pendingreads);
d265 1
a265 1
	print_fld_size(FLD_IO_SVAL, bccur.numwrites - bclast.numwrites);
d269 1
a269 1
	print_fld_size(FLD_IO_SVAL, bccur.numreads - bclast.numreads);
d273 1
a273 1
	print_fld_size(FLD_IO_SVAL, bccur.cachehits - bclast.cachehits);
@


1.31
log
@Use refresh interval for rate calculation instead of the broken elapsed
time computation.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.30 2008/06/12 22:26:01 canacar Exp $	*/
d69 1
a69 1
	{"", 8, 10, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
@


1.30
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.28 2007/05/30 05:20:58 otto Exp $	*/
d145 1
a145 10

	etime = 0.0;
	for (i = 0; i < CPUSTATES; i++)
		etime += cur.cp_time[i];

	if (etime == 0.0)
		etime = 1.0;

	etime /= (float) hz;

@


1.29
log
@make bcachestats visible in systat io - from mickey.
ok thib@@
@
text
@a32 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)iostat.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: iostat.c,v 1.28 2007/05/30 05:20:58 otto Exp $";
#endif /* not lint */

a43 1
#include "extern.h"
d51 6
a56 1
static void numlabels(void);
a60 3
#define NFMT "%-6.6s  %8.0f %8.0f  %6.0f %6.0f  %4.1f"
#define SFMT "%-6.6s  %8s %8s  %6s %6s  %4s"
#define	BCSCOL	50
d62 42
a103 6
WINDOW *
openiostat(void)
{
	bzero(&bccur, sizeof(bccur));
	return (subwin(stdscr, LINES-1-1, 0, 1, 0));
}
a104 9
void
closeiostat(WINDOW *w)
{
	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
}
d107 1
a107 1
initiostat(void)
d109 2
a110 3
	dkinit(1);
	dkreadstats();
	return (1);
d113 2
a114 2
void
fetchiostat(void)
a118 2
	if (cur.dk_ndrive == 0)
		return;
d120 2
d128 1
d130 2
a131 1
		mvwaddstr(wnd, 20, 0, "cannot get vfs.bcachestat");
d134 2
a137 17
void
labeliostat(void)
{
	mvwprintw(wnd, 1, 0, SFMT, "Device", "rKBytes", "wKBytes", "rtps",
	    "wtps", "sec");
	mvwprintw(wnd, 1, BCSCOL + 16, "numbufs");
	mvwprintw(wnd, 2, BCSCOL + 16, "freebufs");
	mvwprintw(wnd, 3, BCSCOL + 16, "numbufpages");
	mvwprintw(wnd, 4, BCSCOL + 16, "numfreepages");
	mvwprintw(wnd, 5, BCSCOL + 16, "numdirtypages");
	mvwprintw(wnd, 6, BCSCOL + 16, "numcleanpages");
	mvwprintw(wnd, 7, BCSCOL + 16, "pendingwrites");
	mvwprintw(wnd, 8, BCSCOL + 16, "pendingreads");
	mvwprintw(wnd, 9, BCSCOL + 16, "numwrites");
	mvwprintw(wnd, 10, BCSCOL + 16, "numreads");
	mvwprintw(wnd, 11, BCSCOL + 16, "cachehits");
}
d140 1
a140 1
showiostat(void)
d142 1
a142 1
	int i;
d144 1
a144 1
	dkswap();
d147 1
a147 1
	for (i = 0; i < CPUSTATES; i++) {
a148 1
	}
a154 2
	if (last.dk_ndrive != cur.dk_ndrive)
		labeliostat();
d156 27
a182 2
	if (cur.dk_ndrive == 0)
		return;
d184 2
a185 1
	numlabels();
d187 1
a187 38
	mvwprintw(wnd, 1, BCSCOL, "%15ld", bccur.numbufs);
	mvwprintw(wnd, 2, BCSCOL, "%15ld", bccur.freebufs);
	mvwprintw(wnd, 3, BCSCOL, "%15ld", bccur.numbufpages);
	if (bccur.numfreepages)
		mvwprintw(wnd, 4, BCSCOL, "%15ld", bccur.numfreepages);
	else
		mvwprintw(wnd, 4, BCSCOL, "%15s", "");
	if (bccur.numdirtypages)
		mvwprintw(wnd, 5, BCSCOL, "%15ld", bccur.numdirtypages);
	else
		mvwprintw(wnd, 5, BCSCOL, "%15s", "");
	if (bccur.numcleanpages)
		mvwprintw(wnd, 6, BCSCOL, "%15ld", bccur.numcleanpages);
	else
		mvwprintw(wnd, 6, BCSCOL, "%15s", "");
	if (bccur.pendingwrites)
		mvwprintw(wnd, 7, BCSCOL, "%15ld", bccur.pendingwrites);
	else
		mvwprintw(wnd, 7, BCSCOL, "%15s", "");
	if (bccur.pendingreads)
		mvwprintw(wnd, 8, BCSCOL, "%15ld", bccur.pendingreads);
	else
		mvwprintw(wnd, 8, BCSCOL, "%15s", "");
	if (bccur.numwrites - bclast.numwrites)
		mvwprintw(wnd, 9, BCSCOL, "%15ld",
		    bccur.numwrites - bclast.numwrites);
	else
		mvwprintw(wnd, 9, BCSCOL, "%15s", "");
	if (bccur.numreads - bclast.numreads)
		mvwprintw(wnd, 10, BCSCOL, "%15ld",
		    bccur.numreads - bclast.numreads);
	else
		mvwprintw(wnd, 10, BCSCOL, "%15s", "");
	if (bccur.cachehits - bclast.cachehits)
		mvwprintw(wnd, 11, BCSCOL, "%15ld",
		    bccur.cachehits - bclast.cachehits);
	else
		mvwprintw(wnd, 11, BCSCOL, "%15s", "");
d191 1
a191 1
numlabels(void)
d194 1
a194 10
	int row, dn;

	row = 2;
	wmove(wnd, 0, 0);
	wclrtoeol(wnd);

	if (cur.dk_ndrive == 0) {
		mvwaddstr(wnd, row, 0, "No drives attached.");
		return;
	}
a203 7
		mvwprintw(wnd, row++, 0, NFMT,
		    cur.dk_name[dn],
		    cur.dk_rbytes[dn] / 1024.0 / etime,
		    cur.dk_wbytes[dn] / 1024.0 / etime,
		    cur.dk_rxfer[dn] / etime,
		    cur.dk_wxfer[dn] / etime,
		    ATIME(cur.dk_time, dn) / etime);
d205 22
a226 2
	mvwprintw(wnd, row++, 0, NFMT,
	    "Totals", rsum / 1024.0, wsum / 1024.0, rtsum, wtsum, mssum);
d229 9
a237 2
int
cmdiostat(char *cmd, char *args)
d239 45
a283 4
	wclear(wnd);
	labeliostat();
	refresh();
	return (1);
@


1.28
log
@rename msec to the less confusing sec and improve the description in
the man page.  ok dlg@@ and jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.27 2007/02/25 18:21:24 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.27 2007/02/25 18:21:24 deraadt Exp $";
d44 2
d55 1
d64 3
a66 2
#define NFMT "%-8.8s  %14.0f %14.0f  %10.0f %10.0f  %10.1f"
#define SFMT "%-8.8s  %14s %14s  %10s %10s  %10s"
d71 1
d96 3
d102 10
d119 11
d156 39
@


1.27
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.26 2006/06/29 21:17:27 dlg Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.26 2006/06/29 21:17:27 dlg Exp $";
d100 1
a100 1
	    "wtps", "msec");
@


1.26
log
@change bytes to kilobytes so i dont have to think about where megabytes
start.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.25 2006/06/27 10:28:25 dlg Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.25 2006/06/27 10:28:25 dlg Exp $";
d67 1
a67 1
	return (subwin(stdscr, LINES-1-5, 0, 5, 0));
@


1.25
log
@basically replace the iostat view with something that looks like the ifstat
view. noone seemed particularly attached to the last one, so this is
going in.

from deanna phillips
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.24 2006/03/31 04:10:59 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.24 2006/03/31 04:10:59 deraadt Exp $";
d58 5
a62 6
#define ATIME(x,y) (					\
        (double)x[y].tv_sec +				\
        ((double)x[y].tv_usec / (double)1000000)	\
             )
#define NFMT "%-8.8s %12.0f %14.0f %10.0f %10.0f %10.1f"
#define SFMT "%6s %14s %14s %10s %10s %10s"
d99 1
a99 1
	mvwprintw(wnd, 1, 0, SFMT, "Device", "rbytes", "wbytes", "rtps",
d148 1
a148 1
		wsum += cur.dk_wbytes[dn] /etime;
d154 2
a155 2
		    cur.dk_rbytes[dn] / etime,
		    cur.dk_wbytes[dn] / etime,
d161 1
a161 1
	    "Totals", rsum, wsum, rtsum, wtsum, mssum);
@


1.24
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.23 2004/02/15 22:56:12 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.23 2004/02/15 22:56:12 tedu Exp $";
d54 1
a54 11
static  int linesperregion;
static  double etime;
static  int numbers = 0;		/* default display bar graphs */
static  int secs = 0;			/* default seconds shown */
static	int split = 0;			/* whether to split r/w stats */

static int barlabels(int);
static void histogram(double, int, double);
static int numlabels(int);
static int stats(int, int, int);
static void stat1(int, int);
d56 8
a96 2
#define	INSET	10

d100 2
a101 61
	int row;

	row = 0;
	wmove(wnd, row, 0); wclrtobot(wnd);
	mvwaddstr(wnd, row++, INSET,
	    "/0   /10  /20  /30  /40  /50  /60  /70  /80  /90  /100");
	mvwaddstr(wnd, row++, 0, "cpu  user|");
	mvwaddstr(wnd, row++, 0, "     nice|");
	mvwaddstr(wnd, row++, 0, "   system|");
	mvwaddstr(wnd, row++, 0, "interrupt|");
	mvwaddstr(wnd, row++, 0, "     idle|");
	if (numbers)
		row = numlabels(row + 1);
	else
		row = barlabels(row + 1);
}

static int
numlabels(int row)
{
	int i, col, regions, ndrives;

	if (cur.dk_ndrive == 0) {
		mvwaddstr(wnd, row++, INSET, "No drives attached.");
		return (row);
	}
#define COLWIDTH	(split ? 30 : 17)
#define DRIVESPERLINE	((wnd->_maxx - INSET) / COLWIDTH)
	for (ndrives = 0, i = 0; i < cur.dk_ndrive; i++)
		if (cur.dk_select[i])
			ndrives++;
	regions = howmany(ndrives, DRIVESPERLINE);
	/*
	 * Deduct -regions for blank line after each scrolling region.
	 */
	linesperregion = (wnd->_maxy - row - regions) / regions;
	/*
	 * Minimum region contains space for two
	 * label lines and one line of statistics.
	 */
	if (linesperregion < 3)
		linesperregion = 3;
	col = INSET;
	for (i = 0; i < cur.dk_ndrive; i++)
		if (cur.dk_select[i] /*&& cur.dk_bytes[i] != 0.0*/) {
			if (col + COLWIDTH >= wnd->_maxx) {
				col = INSET, row += linesperregion + 1;
				if (row > wnd->_maxy - (linesperregion + 1))
					break;
			}
			mvwaddstr(wnd, row, col + 4, cur.dk_name[i]);
			if (split)
				mvwaddstr(wnd, row + 1, col, " rKBps wKBps "
				    "rtps wtps  sec");
			else
				mvwaddstr(wnd, row + 1, col, " KBps tps  sec");
			col += COLWIDTH;
		}
	if (col)
		row += linesperregion + 1;
	return (row);
a103 34
static int
barlabels(int row)
{
	int i;

	if (cur.dk_ndrive == 0) {
		mvwaddstr(wnd, row++, INSET, "No drives attached.");
		return (row);
	}
	mvwaddstr(wnd, row++, INSET,
	    "/0   /10  /20  /30  /40  /50  /60  /70  /80  /90  /100");
	linesperregion = 2 + secs;
	for (i = 0; i < dk_ndrive; i++)
		if (cur.dk_select[i] /*&& cur.dk_bytes[i] != 0.0*/) {
			if (row > wnd->_maxy - linesperregion)
				break;
			if (split) {
				mvwprintw(wnd, row++, 0, "%4.4s rKps|",
				    cur.dk_name[i]);
				mvwaddstr(wnd, row++, 0, "     wKps|");
				mvwaddstr(wnd, row++, 0, "     rtps|");
				mvwaddstr(wnd, row++, 0, "     wtps|");
			} else {
				mvwprintw(wnd, row++, 0, "%4.4s  Kps|",
				    cur.dk_name[i]);
				mvwaddstr(wnd, row++, 0, "      tps|");
			}
			if (secs)
				mvwaddstr(wnd, row++, 0, "     msec|");
		}
	return (row);
}


d107 1
a107 1
	int i, row, col;
d111 1
a111 1
	etime = 0;
d115 1
d118 1
a119 7
	row = 1;

	/*
	 * Interrupt CPU state not calculated yet.
	 */
	for (i = 0; i < CPUSTATES; i++)
		stat1(row++, i);
d127 1
a127 29
	if (!numbers) {
		row += 2;
		for (i = 0; i < cur.dk_ndrive; i++)
			if (cur.dk_select[i] /*&& cur.dk_bytes[i] != 0.0*/) {
				if (row > wnd->_maxy - linesperregion)
					break;
				row = stats(row, INSET, i);
			}
		return;
	}
	col = INSET;
	wmove(wnd, row + linesperregion, 0);
	wdeleteln(wnd);
	wmove(wnd, row + 3, 0);
	winsertln(wnd);
	for (i = 0; i < cur.dk_ndrive; i++)
		if (cur.dk_select[i] /*&& cur.dk_bytes[i] != 0.0*/) {
			if (col + COLWIDTH >= wnd->_maxx) {
				col = INSET, row += linesperregion + 1;
				if (row > wnd->_maxy - (linesperregion + 1))
					break;
				wmove(wnd, row + linesperregion, 0);
				wdeleteln(wnd);
				wmove(wnd, row + 3, 0);
				winsertln(wnd);
			}
			(void) stats(row + 3, col, i);
			col += COLWIDTH;
		}
d130 2
a131 2
static int
stats(int row, int col, int dn)
d133 2
a134 1
	double atime, rwords, wwords;
d136 7
a142 33
	/* time busy in disk activity */
	atime = (double)cur.dk_time[dn].tv_sec +
		((double)cur.dk_time[dn].tv_usec / (double)1000000);

	rwords = cur.dk_rbytes[dn] / 1024.0;	/* # of K read */
	wwords = cur.dk_wbytes[dn] / 1024.0;	/* # of K written */
	if (numbers) {
		if (split)
			mvwprintw(wnd, row, col, "%6.0f%6.0f%5.0f%5.0f%5.1f",
			    rwords / etime, wwords / etime, cur.dk_rxfer[dn] /
			    etime, cur.dk_wxfer[dn] / etime, atime / etime);
		else
			mvwprintw(wnd, row, col, "%5.0f%4.0f%5.1f",
			    (rwords + wwords) / etime,
			    (cur.dk_rxfer[dn] + cur.dk_wxfer[dn]) / etime,
			    atime / etime);
		return (row);
	}
	if (split) {
		wmove(wnd, row++, col);
		histogram(rwords / etime, 50, 0.5);
		wmove(wnd, row++, col);
		histogram(wwords / etime, 50, 0.5);
		wmove(wnd, row++, col);
		histogram(cur.dk_rxfer[dn] / etime, 50, 0.5);
		wmove(wnd, row++, col);
		histogram(cur.dk_wxfer[dn] / etime, 50, 0.5);
	} else {
		wmove(wnd, row++, col);
		histogram((rwords + wwords) / etime, 50, 0.5);
		wmove(wnd, row++, col);
		histogram((cur.dk_rxfer[dn] + cur.dk_wxfer[dn]) / etime, 50,
		    0.5);
a143 7
	if (secs) {
		wmove(wnd, row++, col);
		atime *= 1000;	/* In milliseconds */
		histogram(atime / etime, 50, 0.5);
	}
	return (row);
}
d145 1
a145 5
static void
stat1(int row, int o)
{
	int i;
	double tim;
d147 13
a159 20
	tim = 0;
	for (i = 0; i < CPUSTATES; i++)
		tim += cur.cp_time[i];
	if (tim == 0.0)
		tim = 1.0;
	wmove(wnd, row, INSET);
#define CPUSCALE	0.5
	histogram(100.0 * cur.cp_time[o] / tim, 50, CPUSCALE);
}

static void
histogram(double val, int colwidth, double scale)
{
	int v = (int)(val * scale + 0.5);
	int factor = 1;
	int y, x;

	while (v > colwidth) {
		v = (v + 5) / 10;
		factor *= 10;
d161 2
a162 5
	getyx(wnd, y, x);
	wclrtoeol(wnd);
	whline(wnd, 'X', v);
	if (factor != 1)
		mvwprintw(wnd, y, x + colwidth + 1, "* %d ", factor);
a167 11

	if (prefix(cmd, "secs"))
		secs = !secs;
	else if (prefix(cmd, "numbers"))
		numbers = 1;
	else if (prefix(cmd, "bars"))
		numbers = 0;
	else if (prefix(cmd, "split"))
		split = ~split;
	else if (!dkcmd(cmd, args))
		return (0);
@


1.23
log
@'split' command for iostat mode
from Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.22 2004/02/15 02:45:47 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.22 2004/02/15 02:45:47 tedu Exp $";
d311 1
a311 1
	double time;
d313 1
a313 1
	time = 0;
d315 3
a317 3
		time += cur.cp_time[i];
	if (time == 0.0)
		time = 1.0;
d320 1
a320 1
	histogram(100.0 * cur.cp_time[o] / time, 50, CPUSCALE);
@


1.22
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.21 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.21 2003/06/03 02:56:17 millert Exp $";
d58 1
d130 1
a130 1
#define COLWIDTH	17
d155 5
a159 1
			mvwaddstr(wnd, row + 1, col, " KBps tps  sec");
d183 11
a193 2
			mvwprintw(wnd, row++, 0, "%4.4s  Kps|", cur.dk_name[i]);
			mvwaddstr(wnd, row++, 0, "      tps|");
d263 1
a263 1
	double atime, words;
d269 2
a270 2
	/* # of K transferred */
	words = (cur.dk_rbytes[dn] + cur.dk_wbytes[dn]) / 1024.0;
d272 9
a280 3
		mvwprintw(wnd, row, col, "%5.0f%4.0f%5.1f",
		    words / etime, (cur.dk_rxfer[dn] + cur.dk_wxfer[dn]) /
		    etime, atime / etime);
d283 16
a298 4
	wmove(wnd, row++, col);
	histogram(words / etime, 50, 0.5);
	wmove(wnd, row++, col);
	histogram((cur.dk_rxfer[dn] + cur.dk_wxfer[dn]) / etime, 50, 0.5);
d351 2
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.20 2003/02/02 18:20:41 henning Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.20 2003/02/02 18:20:41 henning Exp $";
d255 2
a256 1
	words = cur.dk_bytes[dn] / 1024.0;	/* # of K transferred */
d259 2
a260 1
		    words / etime, cur.dk_xfer[dn] / etime, atime / etime);
d266 1
a266 1
	histogram(cur.dk_xfer[dn] / etime, 50, 0.5);
@


1.20
log
@When disk activity exceeds 100kB/s divide length of bar by 10s and report
factor on RHS screen.

from netbsd (dsl@@)

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.19 2002/12/16 01:57:04 tdeval Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.19 2002/12/16 01:57:04 tdeval Exp $";
@


1.19
log
@Make systat(1), iostat(8) and vmstat(8) automatically update their disk
statistics when a device is added/removed.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.18 2002/06/18 00:46:47 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.18 2002/06/18 00:46:47 deraadt Exp $";
d296 7
a302 13
	char buf[10];
	int k;
	int v = (int)(val * scale) + 0.5;

	k = MIN(v, colwidth);
	if (v > colwidth) {
		snprintf(buf, sizeof buf, "%4.1f", val);
		k -= strlen(buf);
		while (k--)
			waddch(wnd, 'X');
		waddstr(wnd, buf);
		wclrtoeol(wnd);
		return;
d304 1
a304 2
	while (k--)
		waddch(wnd, 'X');
d306 3
@


1.18
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.17 2002/02/16 21:27:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.17 2002/02/16 21:27:54 millert Exp $";
d56 1
a56 1
extern struct _disk	cur;
d97 1
a97 1
	if (dk_ndrive == 0)
d129 1
a129 1
	if (dk_ndrive == 0) {
d135 1
a135 1
	for (ndrives = 0, i = 0; i < dk_ndrive; i++)
d150 1
a150 1
	for (i = 0; i < dk_ndrive; i++)
d171 1
a171 1
	if (dk_ndrive == 0) {
d213 4
a216 1
	if (dk_ndrive == 0)
d221 1
a221 1
		for (i = 0; i < dk_ndrive; i++)
d234 1
a234 1
	for (i = 0; i < dk_ndrive; i++)
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.16 2001/12/07 09:18:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.16 2001/12/07 09:18:08 deraadt Exp $";
d71 1
a71 1
openiostat()
d77 1
a77 2
closeiostat(w)
	WINDOW *w;
d87 1
a87 1
initiostat()
d95 1
a95 1
fetchiostat()
d105 1
a105 1
labeliostat()
d125 1
a125 2
numlabels(row)
	int row;
d167 1
a167 2
barlabels(row)
	int row;
d192 1
a192 1
showiostat()
d199 1
a199 1
	for(i = 0; i < CPUSTATES; i++) {
d248 1
a248 2
stats(row, col, dn)
	int row, col, dn;
d275 1
a275 2
stat1(row, o)
	int row, o;
d291 1
a291 4
histogram(val, colwidth, scale)
	double val;
	int colwidth;
	double scale;
d313 1
a313 2
cmdiostat(cmd, args)
	char *cmd, *args;
@


1.16
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.14 2001/11/23 22:20:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.14 2001/11/23 22:20:06 deraadt Exp $";
d63 5
a67 5
static int barlabels __P((int));
static void histogram __P((double, int, double));
static int numlabels __P((int));
static int stats __P((int, int, int));
static void stat1 __P((int, int));
@


1.15
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.13 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.13 2001/11/19 19:02:16 mpech Exp $";
a50 1
#include <nlist.h>
d212 1
a212 1
	 */ 
@


1.14
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@d51 1
d213 1
a213 1
	 */
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.12 2001/08/12 12:03:03 heko Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.12 2001/08/12 12:03:03 heko Exp $";
a50 1
#include <nlist.h>
d212 1
a212 1
	 */ 
@


1.12
log
@#(endif|else) foo is incorrect, make it #endif /* foo */
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.11 2000/07/07 20:47:25 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.11 2000/07/07 20:47:25 deraadt Exp $";
d198 1
a198 1
	register int i, row, col;
d283 1
a283 1
	register int i;
d303 2
a304 2
	register int k;
	register int v = (int)(val * scale) + 0.5;
@


1.11
log
@fixed formatting in numlabels; danh
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.10 1997/12/19 09:03:32 deraadt Exp $	*/
d41 2
a42 2
static char rcsid[] = "$OpenBSD: iostat.c,v 1.10 1997/12/19 09:03:32 deraadt Exp $";
#endif not lint
@


1.10
log
@bye bye sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.9 1997/07/15 14:41:06 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.9 1997/07/15 14:41:06 kstailey Exp $";
d136 1
a136 1
#define COLWIDTH	14
d152 1
a152 1
	col = 0;
d155 2
a156 2
			if (col + COLWIDTH >= wnd->_maxx - INSET) {
				col = 0, row += linesperregion + 1;
d161 1
a161 1
			mvwaddstr(wnd, row + 1, col, "Kps tps  sec");
d230 1
a230 1
	col = 0;
d238 1
a238 1
				col = 0, row += linesperregion + 1;
d263 1
a263 1
		mvwprintw(wnd, row, col, "%3.0f%4.0f%5.1f",
@


1.9
log
@initxxx() routines return 1 on success, not zero.
(ob-theo-style-commit-comment: "Argh! *sigh* not-nice!")
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.8 1997/06/23 22:21:47 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.8 1997/06/23 22:21:47 millert Exp $";
d308 1
a308 1
		sprintf(buf, "%4.1f", val);
@


1.8
log
@Cleanup by Theo and myself.  CMDLINE changed to long to make
command line work on 64bit platforms.  This is somewhat bogus
and is really just a temporary workaround (there may be a curses bug).
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.7 1997/02/04 04:42:42 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.7 1997/02/04 04:42:42 kstailey Exp $";
d93 1
a93 1
	return 0;
@


1.7
log
@display CPU stats on iostat screen even if diskless
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.6 1997/01/06 18:50:50 maja Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.6 1997/01/06 18:50:50 maja Exp $";
d93 1
a197 1
	register u_int64_t t;
@


1.6
log
@Allow device names to be four characters (eg mcd0 or acd0). -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.5 1996/06/26 05:40:07 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.5 1996/06/26 05:40:07 deraadt Exp $";
a109 4
	if (dk_ndrive == 0) {
		error("No drives defined.");
		return;
	}
d131 4
d174 4
a199 2
	if (dk_ndrive == 0)
		return;
d216 4
@


1.5
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: iostat.c,v 1.5 1996/05/10 23:16:35 thorpej Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: iostat.c,v 1.5 1996/05/10 23:16:35 thorpej Exp $";
d181 1
a181 1
			mvwprintw(wnd, row++, 0, "%3.3s   Kps|", cur.dk_name[i]);
@


1.4
log
@it compiles w/ new curses
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: iostat.c,v 1.5 1996/05/10 23:16:35 thorpej Exp $";
@


1.3
log
@libutil
@
text
@d135 1
a135 1
#define DRIVESPERLINE	((wnd->maxx - INSET) / COLWIDTH)
d143 1
a143 1
	linesperregion = (wnd->maxy - row - regions) / regions;
d153 1
a153 1
			if (col + COLWIDTH >= wnd->maxx - INSET) {
d155 1
a155 1
				if (row > wnd->maxy - (linesperregion + 1))
d178 1
a178 1
			if (row > wnd->maxy - linesperregion)
d217 1
a217 1
				if (row > wnd->maxy - linesperregion)
d230 1
a230 1
			if (col + COLWIDTH >= wnd->maxx) {
d232 1
a232 1
				if (row > wnd->maxy - (linesperregion + 1))
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: iostat.c,v 1.4 1996/03/15 22:19:25 ragge Exp $	*/
a38 1
static char rcsid[] = "$NetBSD: iostat.c,v 1.4 1996/03/15 22:19:25 ragge Exp $";
d40 1
a40 1
static char rcsid[] = "$OpenBSD$";
d46 1
d55 2
a56 28
static struct nlist namelist[] = {
#define X_DK_BUSY	0
	{ "_dk_busy" },
#define X_DK_TIME	1
	{ "_dk_time" },
#define X_DK_XFER	2
	{ "_dk_xfer" },
#define X_DK_WDS	3
	{ "_dk_wds" },
#define X_DK_SEEK	4
	{ "_dk_seek" },
#define X_CP_TIME	5
	{ "_cp_time" },
#ifdef tahoe
#define	X_VBDINIT	(X_CP_TIME+1)
	{ "_vbdinit" },
#endif
	{ "" },
};

static struct {
	int	dk_busy;
	long	cp_time[CPUSTATES];
	long	*dk_time;
	long	*dk_wds;
	long	*dk_seek;
	long	*dk_xfer;
} s, s1;
d61 1
a61 1
static  int msps = 0;			/* default ms/seek shown */
d90 2
a91 23
	if (namelist[X_DK_BUSY].n_type == 0) {
		if (kvm_nlist(kd, namelist)) {
			nlisterr(namelist);
			return(0);
		}
		if (namelist[X_DK_BUSY].n_type == 0) {
			error("Disk init information isn't in namelist");
			return(0);
		}
	}
	if (! dkinit())
		return(0);
	if (dk_ndrive) {
#define	allocate(e, t) \
    s./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    s1./**/e = (t *)calloc(dk_ndrive, sizeof (t));
		allocate(dk_time, long);
		allocate(dk_wds, long);
		allocate(dk_seek, long);
		allocate(dk_xfer, long);
#undef allocate
	}
	return(1);
d97 1
a97 1
	if (namelist[X_DK_BUSY].n_type == 0)
d99 1
a99 6
	NREAD(X_DK_BUSY, &s.dk_busy, LONG);
	NREAD(X_DK_TIME, s.dk_time, dk_ndrive * LONG);
	NREAD(X_DK_XFER, s.dk_xfer, dk_ndrive * LONG);
	NREAD(X_DK_WDS, s.dk_wds, dk_ndrive * LONG);
	NREAD(X_DK_SEEK, s.dk_seek, dk_ndrive * LONG);
	NREAD(X_CP_TIME, s.cp_time, sizeof s.cp_time);
d109 2
a110 2
	if (namelist[X_DK_BUSY].n_type == 0) {
		error("No dk_busy defined.");
d137 1
a137 1
		if (dk_select[i])
d152 1
a152 1
		if (dk_select[i] && dk_mspw[i] != 0.0) {
d158 2
a159 2
			mvwaddstr(wnd, row, col + 4, dr_name[i]);
			mvwaddstr(wnd, row + 1, col, "bps tps msps");
d174 2
a175 2
	    "/0   /5   /10  /15  /20  /25  /30  /35  /40  /45  /50");
	linesperregion = 2 + msps;
d177 1
a177 1
		if (dk_select[i] && dk_mspw[i] != 0.0) {
d180 1
a180 1
			mvwprintw(wnd, row++, 0, "%3.3s   bps|", dr_name[i]);
d182 2
a183 2
			if (msps)
				mvwaddstr(wnd, row++, 0, "     msps|");
d192 1
a192 1
	register long t;
d195 1
a195 1
	if (namelist[X_DK_BUSY].n_type == 0)
d197 2
a198 4
	for (i = 0; i < dk_ndrive; i++) {
#define X(fld)	t = s.fld[i]; s.fld[i] -= s1.fld[i]; s1.fld[i] = t
		X(dk_xfer); X(dk_seek); X(dk_wds); X(dk_time);
	}
d201 1
a201 2
		X(cp_time);
		etime += s.cp_time[i];
d216 1
a216 1
			if (dk_select[i] && dk_mspw[i] != 0.0) {
d229 1
a229 1
		if (dk_select[i] && dk_mspw[i] != 0.0) {
d248 5
a252 1
	double atime, words, xtime, itime;
d254 1
a254 9
	atime = s.dk_time[dn];
	atime /= (float) hz;
	words = s.dk_wds[dn]*32.0;	/* number of words transferred */
	xtime = dk_mspw[dn]*words;	/* transfer time */
	itime = atime - xtime;		/* time not transferring */
	if (xtime < 0)
		itime += xtime, xtime = 0;
	if (itime < 0)
		xtime += itime, itime = 0;
d257 1
a257 2
		    words / 512 / etime, s.dk_xfer[dn] / etime,
		    s.dk_seek[dn] ? itime * 1000. / s.dk_seek[dn] : 0.0);
d261 1
a261 1
	histogram(words / 512 / etime, 50, 1.0);
d263 2
a264 2
	histogram(s.dk_xfer[dn] / etime, 50, 1.0);
	if (msps) {
d266 2
a267 2
		histogram(s.dk_seek[dn] ? itime * 1000. / s.dk_seek[dn] : 0,
		   50, 1.0);
d281 1
a281 1
		time += s.cp_time[i];
d286 1
a286 1
	histogram(100.0 * s.cp_time[o] / time, 50, CPUSCALE);
d306 1
d319 2
a320 2
	if (prefix(cmd, "msps"))
		msps = !msps;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: iostat.c,v 1.3 1995/05/17 15:51:47 mycroft Exp $	*/
d40 1
d42 1
a42 1
static char rcsid[] = "$NetBSD: iostat.c,v 1.3 1995/05/17 15:51:47 mycroft Exp $";
a68 6
#ifdef vax
#define X_MBDINIT	(X_CP_TIME+1)
	{ "_mbdinit" },
#define X_UBDINIT	(X_CP_TIME+2)
	{ "_ubdinit" },
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
