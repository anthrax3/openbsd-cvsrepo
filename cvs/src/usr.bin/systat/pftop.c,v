head	1.40;
access;
symbols
	OPENBSD_6_1:1.35.0.4
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.34.0.2
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.8
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.40
date	2017.07.19.12.58.31;	author mikeb;	state Exp;
branches;
next	1.39;
commitid	iahjnsaS3YMAv0Za;

1.39
date	2017.05.22.14.51.10;	author mikeb;	state Exp;
branches;
next	1.38;
commitid	IOMXtBjY7db1D7hP;

1.38
date	2017.05.16.22.29.07;	author mikeb;	state Exp;
branches;
next	1.37;
commitid	GtKw9Yc8Zuw7dJOl;

1.37
date	2017.05.03.14.01.29;	author mikeb;	state Exp;
branches;
next	1.36;
commitid	lvaI9qSAqkwq7hrX;

1.36
date	2017.04.26.15.50.59;	author mikeb;	state Exp;
branches;
next	1.35;
commitid	8pGFYJ6mUEgndXbS;

1.35
date	2016.12.18.19.39.30;	author jasper;	state Exp;
branches;
next	1.34;
commitid	QzVCthDv9HNPIH4z;

1.34
date	2016.04.13.05.25.45;	author jasper;	state Exp;
branches;
next	1.33;
commitid	DU1kLToKcIegeUhw;

1.33
date	2016.01.16.03.30.26;	author canacar;	state Exp;
branches;
next	1.32;
commitid	f9790JrBS1aXEyQy;

1.32
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	0Dp7Dy9FuNZesYo2;

1.31
date	2015.02.09.02.00.38;	author jsg;	state Exp;
branches;
next	1.30;
commitid	PDHTW6EodCH7XtEV;

1.30
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	waQzIVMqUqjBDjYt;

1.29
date	2014.10.11.04.30.56;	author doug;	state Exp;
branches;
next	1.28;
commitid	QwH6tTHmqZo9h5gv;

1.28
date	2014.05.09.21.03.43;	author sthen;	state Exp;
branches;
next	1.27;

1.27
date	2014.05.03.11.11.15;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.26.11.28.49;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.26.11.27.23;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.18.11.36.06;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2014.02.11.01.07.21;	author pelikan;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.19.23.45.34;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.12.12.17.32;	author henning;	state Exp;
branches;
next	1.20;

1.20
date	2011.10.13.18.32.30;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.05.15.07.46;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2011.02.06.05.20.25;	author lum;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.28.16.08.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.22.12.33.29;	author giovanni;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.23.21.30.14;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2009.07.14.17.58.14;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.10.03.42.58;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.23.12.58.44;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.06.12.08.26;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.04.03.29.53;	author canacar;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.01.22.50.39;	author mcbride;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.05.15.48.44;	author canacar;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.08.15.11.13;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.01.23.30.08;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.16.10.23.39;	author canacar;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.29.08.42.15;	author mcbride;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.13.23.47.17;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Allow HFSC classes to use flow queues

The FQ-CoDel related configuration (flows, quantum) becomes available
for the regular bandwidth queue.  Internally the kernel will pick the
FQ-CoDel for use as a queue manager for the specified class instead of
the FIFO.

Discussed with and OK henning@@ at d2k17 as a part of a larger diff.
@
text
@/* $OpenBSD: pftop.c,v 1.39 2017/05/22 14:51:10 mikeb Exp $	 */
/*
 * Copyright (c) 2001, 2007 Can Erkin Acar
 * Copyright (c) 2001 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <net/hfsc.h>

#include <ctype.h>
#include <curses.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <stdarg.h>

#include "systat.h"
#include "engine.h"
#include "cache.h"

extern const char *tcpstates[];

#define MIN_NUM_STATES 1024
#define NUM_STATE_INC  1024

#define DEFAULT_CACHE_SIZE 10000

/* XXX must also check type before use */
#define PT_ADDR(x) (&(x)->addr.v.a.addr)

/* XXX must also check type before use */
#define PT_MASK(x) (&(x)->addr.v.a.mask)

#define PT_NOROUTE(x) ((x)->addr.type == PF_ADDR_NOROUTE)

/* view management */
int select_states(void);
int read_states(void);
void sort_states(void);
void print_states(void);

int select_rules(void);
int read_rules(void);
void print_rules(void);

int select_queues(void);
int read_queues(void);
void print_queues(void);

void update_cache(void);

/* qsort callbacks */
int sort_size_callback(const void *s1, const void *s2);
int sort_exp_callback(const void *s1, const void *s2);
int sort_pkt_callback(const void *s1, const void *s2);
int sort_age_callback(const void *s1, const void *s2);
int sort_sa_callback(const void *s1, const void *s2);
int sort_sp_callback(const void *s1, const void *s2);
int sort_da_callback(const void *s1, const void *s2);
int sort_dp_callback(const void *s1, const void *s2);
int sort_rate_callback(const void *s1, const void *s2);
int sort_peak_callback(const void *s1, const void *s2);
int pf_dev = -1;

struct sc_ent **state_cache = NULL;
struct pfsync_state *state_buf = NULL;
int state_buf_len = 0;
u_int32_t *state_ord = NULL;
u_int32_t num_states = 0;
u_int32_t num_states_all = 0;
u_int32_t num_rules = 0;
u_int32_t num_queues = 0;
int cachestates = 0;

char *filter_string = NULL;

#define MIN_LABEL_SIZE 5
#define ANCHOR_FLD_SIZE 12

/* Define fields */
field_def fields[] = {
	{"SRC", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"DEST", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"GW", 20, 45, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"STATE", 5, 23, 18, FLD_ALIGN_COLUMN, -1, 0, 0, 0},
	{"AGE", 5, 9, 4, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"EXP", 5, 9, 4, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"PR ", 4, 9, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"DIR", 1, 3, 2, FLD_ALIGN_CENTER, -1, 0, 0, 0},
	{"PKTS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"BYTES", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"RULE", 2, 4, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"LABEL", MIN_LABEL_SIZE, MIN_LABEL_SIZE, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"STATES", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"EVAL", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"ACTION", 1, 8, 4, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"LOG", 1, 3, 2, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"QUICK", 1, 1, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"KS", 1, 1, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"IF", 4, 7, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"INFO", 40, 80, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"MAX", 3, 5, 2, FLD_ALIGN_RIGHT, -1, 0, 0},
	{"RATE", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"AVG", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"PEAK", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"ANCHOR", 6, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0},
	{"QUEUE", 15, 30, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"BW/FL", 4, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"SCH", 3, 4, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"DROP_P", 6, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"DROP_B", 6, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"QLEN", 4, 4, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"BORROW", 4, 6, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"SUSPENDS", 4, 6, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"P/S", 3, 7, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"B/S", 4, 7, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0}
};


/* for states */
#define FLD_SRC     FIELD_ADDR(fields,0)
#define FLD_DEST    FIELD_ADDR(fields,1)
#define FLD_GW      FIELD_ADDR(fields,2)
#define FLD_STATE   FIELD_ADDR(fields,3)
#define FLD_AGE     FIELD_ADDR(fields,4)
#define FLD_EXP     FIELD_ADDR(fields,5)
/* common */
#define FLD_PROTO   FIELD_ADDR(fields,6)
#define FLD_DIR     FIELD_ADDR(fields,7)
#define FLD_PKTS    FIELD_ADDR(fields,8)
#define FLD_BYTES   FIELD_ADDR(fields,9)
#define FLD_RULE    FIELD_ADDR(fields,10)
/* for rules */
#define FLD_LABEL   FIELD_ADDR(fields,11)
#define FLD_STATS   FIELD_ADDR(fields,12)
#define FLD_EVAL    FIELD_ADDR(fields,13)
#define FLD_ACTION  FIELD_ADDR(fields,14)
#define FLD_LOG     FIELD_ADDR(fields,15)
#define FLD_QUICK   FIELD_ADDR(fields,16)
#define FLD_KST     FIELD_ADDR(fields,17)
#define FLD_IF      FIELD_ADDR(fields,18)
#define FLD_RINFO   FIELD_ADDR(fields,19)
#define FLD_STMAX   FIELD_ADDR(fields,20)
/* other */
#define FLD_SI      FIELD_ADDR(fields,21)    /* instantaneous speed */
#define FLD_SA      FIELD_ADDR(fields,22)    /* average speed */
#define FLD_SP      FIELD_ADDR(fields,23)    /* peak speed */
#define FLD_ANCHOR  FIELD_ADDR(fields,24)
/* for queues */
#define FLD_QUEUE   FIELD_ADDR(fields,25)
#define FLD_BANDW   FIELD_ADDR(fields,26)
#define FLD_SCHED   FIELD_ADDR(fields,27)
#define FLD_DROPP   FIELD_ADDR(fields,28)
#define FLD_DROPB   FIELD_ADDR(fields,29)
#define FLD_QLEN    FIELD_ADDR(fields,30)
#define FLD_BORR    FIELD_ADDR(fields,31)
#define FLD_SUSP    FIELD_ADDR(fields,32)
#define FLD_PKTSPS  FIELD_ADDR(fields,33)
#define FLD_BYTESPS FIELD_ADDR(fields,34)

/* Define views */
field_def *view0[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST, FLD_STATE,
	FLD_AGE, FLD_EXP, FLD_PKTS, FLD_BYTES, NULL
};

field_def *view1[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST, FLD_GW, FLD_STATE, FLD_AGE,
	FLD_EXP, FLD_PKTS, FLD_BYTES, FLD_SI, FLD_SP, FLD_SA, FLD_RULE, NULL
};

field_def *view2[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST, FLD_STATE, FLD_AGE, FLD_EXP,
	FLD_PKTS, FLD_BYTES, FLD_SI, FLD_SP, FLD_SA, FLD_RULE, FLD_GW, NULL
};

field_def *view3[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST, FLD_AGE, FLD_EXP, FLD_PKTS,
	FLD_BYTES, FLD_STATE, FLD_SI, FLD_SP, FLD_SA, FLD_RULE, FLD_GW, NULL
};

field_def *view4[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST, FLD_PKTS, FLD_BYTES, FLD_STATE,
	FLD_AGE, FLD_EXP, FLD_SI, FLD_SP, FLD_SA, FLD_RULE, FLD_GW, NULL
};

field_def *view5[] = {
	FLD_RULE, FLD_ANCHOR, FLD_ACTION, FLD_DIR, FLD_LOG, FLD_QUICK, FLD_IF,
	FLD_PROTO, FLD_KST, FLD_PKTS, FLD_BYTES, FLD_STATS, FLD_STMAX,
	FLD_RINFO, NULL
};

field_def *view6[] = {
	FLD_RULE, FLD_LABEL, FLD_PKTS, FLD_BYTES, FLD_STATS, FLD_STMAX,
	FLD_ACTION, FLD_DIR, FLD_LOG, FLD_QUICK, FLD_IF, FLD_PROTO,
	FLD_ANCHOR, FLD_KST, NULL
};

field_def *view7[] = {
	FLD_PROTO, FLD_DIR, FLD_SRC, FLD_DEST,  FLD_SI, FLD_SP, FLD_SA,
	FLD_BYTES, FLD_STATE, FLD_PKTS, FLD_AGE, FLD_EXP, FLD_RULE, FLD_GW, NULL
};

field_def *view8[] = {
	FLD_QUEUE, FLD_BANDW, FLD_SCHED, FLD_PKTS, FLD_BYTES,
	FLD_DROPP, FLD_DROPB, FLD_QLEN, FLD_BORR, FLD_SUSP, FLD_PKTSPS,
	FLD_BYTESPS, NULL
};

/* Define orderings */
order_type order_list[] = {
	{"none", "none", 'N', NULL},
	{"bytes", "bytes", 'B', sort_size_callback},
	{"expiry", "exp", 'E', sort_exp_callback},
	{"packets", "pkt", 'P', sort_pkt_callback},
	{"age", "age", 'A', sort_age_callback},
	{"source addr", "src", 'F', sort_sa_callback},
	{"dest. addr", "dest", 'T', sort_da_callback},
	{"source port", "sport", 'S', sort_sp_callback},
	{"dest. port", "dport", 'D', sort_dp_callback},
	{"rate", "rate", 'R', sort_rate_callback},
	{"peak", "peak", 'K', sort_peak_callback},
	{NULL, NULL, 0, NULL}
};

/* Define view managers */
struct view_manager state_mgr = {
	"States", select_states, read_states, sort_states, print_header,
	print_states, keyboard_callback, order_list, NULL
};

struct view_manager rule_mgr = {
	"Rules", select_rules, read_rules, NULL, print_header,
	print_rules, keyboard_callback, NULL, NULL
};

struct view_manager queue_mgr = {
	"Queues", select_queues, read_queues, NULL, print_header,
	print_queues, keyboard_callback, NULL, NULL
};

field_view views[] = {
	{view2, "states", '8', &state_mgr},
	{view5, "rules", '9', &rule_mgr},
	{view8, "queues", 'Q', &queue_mgr},
	{NULL, NULL, 0, NULL}
};

/* queue structures from pfctl */

struct queue_stats {
	struct hfsc_class_stats	 data;
	int			 valid;
	struct timeval		 timestamp;
};

struct pfctl_queue_node {
	TAILQ_ENTRY(pfctl_queue_node)	entries;
	struct pf_queuespec		qs;
	struct queue_stats		qstats;
	struct queue_stats		qstats_last;
	int				depth;
};
TAILQ_HEAD(qnodes, pfctl_queue_node) qnodes = TAILQ_HEAD_INITIALIZER(qnodes);

/* ordering functions */

int
sort_size_callback(const void *s1, const void *s2)
{
	u_int64_t b1 = COUNTER(state_buf[* (u_int32_t *) s1].bytes[0]) + 
		COUNTER(state_buf[* (u_int32_t *) s1].bytes[1]);
	u_int64_t b2 = COUNTER(state_buf[* (u_int32_t *) s2].bytes[0]) + 
		COUNTER(state_buf[* (u_int32_t *) s2].bytes[1]);
	if (b2 > b1)
		return sortdir;
	if (b2 < b1)
		return -sortdir;
	return 0;
}

int
sort_pkt_callback(const void *s1, const void *s2)
{
	u_int64_t p1 = COUNTER(state_buf[* (u_int32_t *) s1].packets[0]) + 
		COUNTER(state_buf[* (u_int32_t *) s1].packets[1]);
	u_int64_t p2 = COUNTER(state_buf[* (u_int32_t *) s2].packets[0]) + 
		COUNTER(state_buf[* (u_int32_t *) s2].packets[1]);
	if (p2 > p1)
		return sortdir;
	if (p2 < p1)
		return -sortdir;
	return 0;
}

int
sort_age_callback(const void *s1, const void *s2)
{
	if (ntohl(state_buf[* (u_int32_t *) s2].creation) >
	    ntohl(state_buf[* (u_int32_t *) s1].creation))
		return sortdir;
	if (ntohl(state_buf[* (u_int32_t *) s2].creation) <
	    ntohl(state_buf[* (u_int32_t *) s1].creation))
		return -sortdir;
	return 0;
}

int
sort_exp_callback(const void *s1, const void *s2)
{
	if (ntohl(state_buf[* (u_int32_t *) s2].expire) >
	    ntohl(state_buf[* (u_int32_t *) s1].expire))
		return sortdir;
	if (ntohl(state_buf[* (u_int32_t *) s2].expire) <
	    ntohl(state_buf[* (u_int32_t *) s1].expire))
		return -sortdir;
	return 0;
}

int
sort_rate_callback(const void *s1, const void *s2)
{
	struct sc_ent *e1 = state_cache[* (u_int32_t *) s1];
	struct sc_ent *e2 = state_cache[* (u_int32_t *) s2];

	if (e1 == NULL)
		return sortdir;
	if (e2 == NULL)
		return -sortdir;

	if (e2->rate > e1 -> rate)
		return sortdir;
	if (e2->rate < e1 -> rate)
		return -sortdir;
	return 0;
}

int
sort_peak_callback(const void *s1, const void *s2)
{
	struct sc_ent *e1 = state_cache[* (u_int32_t *) s1];
	struct sc_ent *e2 = state_cache[* (u_int32_t *) s2];

	if (e2 == NULL)
		return -sortdir;
	if (e1 == NULL || e2 == NULL)
		return 0;

	if (e2->peak > e1 -> peak)
		return sortdir;
	if (e2->peak < e1 -> peak)
		return -sortdir;
	return 0;
}

int
compare_addr(int af, const struct pf_addr *a, const struct pf_addr *b)
{
	switch (af) {
	case AF_INET:
		if (ntohl(a->addr32[0]) > ntohl(b->addr32[0]))
			return 1;
		if (a->addr32[0] != b->addr32[0])
			return -1;
		break;
	case AF_INET6:
		if (ntohl(a->addr32[0]) > ntohl(b->addr32[0]))
			return 1;
		if (a->addr32[0] != b->addr32[0])
			return -1;
		if (ntohl(a->addr32[1]) > ntohl(b->addr32[1]))
			return 1;
		if (a->addr32[1] != b->addr32[1])
			return -1;
		if (ntohl(a->addr32[2]) > ntohl(b->addr32[2]))
			return 1;
		if (a->addr32[2] != b->addr32[2])
			return -1;
		if (ntohl(a->addr32[3]) > ntohl(b->addr32[3]))
			return 1;
		if (a->addr32[3] != b->addr32[3])
			return -1;
		break;
	}

	return 0;
}

static __inline int
sort_addr_callback(const struct pfsync_state *s1,
		   const struct pfsync_state *s2, int dir)
{
	const struct pf_addr *aa, *ab;
	u_int16_t pa, pb;
	int af, side, ret, ii, io;

	side = s1->direction == PF_IN ? PF_SK_STACK : PF_SK_WIRE;

	if (s1->key[side].af > s2->key[side].af)
		return sortdir;
	if (s1->key[side].af < s2->key[side].af)
		return -sortdir;

	ii = io = 0;

	if (dir == PF_OUT)	/* looking for source addr */
		io = 1;
	else			/* looking for dest addr */
		ii = 1;

	if (s1->key[PF_SK_STACK].af != s1->key[PF_SK_WIRE].af) {
		dir = PF_OUT;
		side = PF_SK_STACK;
	} else {
		dir = s1->direction;
		side = PF_SK_WIRE;
	}

	if (dir == PF_IN) {
		aa = &s1->key[PF_SK_STACK].addr[ii];
		pa =  s1->key[PF_SK_STACK].port[ii];
		af = s1->key[PF_SK_STACK].af;
	} else {
		aa = &s1->key[side].addr[io];
		pa =  s1->key[side].port[io];
		af = s1->key[side].af;
	}

	if (s2->key[PF_SK_STACK].af != s2->key[PF_SK_WIRE].af) {
		dir = PF_OUT;
		side = PF_SK_STACK;
	} else {
		dir = s2->direction;
		side = PF_SK_WIRE;
	}

	if (dir == PF_IN) {
		ab = &s2->key[PF_SK_STACK].addr[ii];
		pb =  s2->key[PF_SK_STACK].port[ii];
		af = s1->key[PF_SK_STACK].af;
	} else {
		ab = &s2->key[side].addr[io];
		pb =  s2->key[side].port[io];
		af = s1->key[side].af;
	}

	ret = compare_addr(af, aa, ab);
	if (ret)
		return ret * sortdir;

	if (ntohs(pa) > ntohs(pb))
		return sortdir;
	return -sortdir;
}

static __inline int
sort_port_callback(const struct pfsync_state *s1,
		   const struct pfsync_state *s2, int dir)
{
	const struct pf_addr *aa, *ab;
	u_int16_t pa, pb;
	int af, side, ret, ii, io;

	side = s1->direction == PF_IN ? PF_SK_STACK : PF_SK_WIRE;

	if (s1->key[side].af > s2->key[side].af)
		return sortdir;
	if (s1->key[side].af < s2->key[side].af)
		return -sortdir;

	ii = io = 0;

	if (dir == PF_OUT)	/* looking for source addr */
		io = 1;
	else			/* looking for dest addr */
		ii = 1;

	if (s1->key[PF_SK_STACK].af != s1->key[PF_SK_WIRE].af) {
		dir = PF_OUT;
		side = PF_SK_STACK;
	} else {
		dir = s1->direction;
		side = PF_SK_WIRE;
	}

	if (dir == PF_IN) {
		aa = &s1->key[PF_SK_STACK].addr[ii];
		pa =  s1->key[PF_SK_STACK].port[ii];
		af = s1->key[PF_SK_STACK].af;
	} else {
		aa = &s1->key[side].addr[io];
		pa =  s1->key[side].port[io];
		af = s1->key[side].af;
	}

	if (s2->key[PF_SK_STACK].af != s2->key[PF_SK_WIRE].af) {
		dir = PF_OUT;
		side = PF_SK_STACK;
	} else {
		dir = s2->direction;
		side = PF_SK_WIRE;
	}

	if (dir == PF_IN) {
		ab = &s2->key[PF_SK_STACK].addr[ii];
		pb =  s2->key[PF_SK_STACK].port[ii];
		af = s1->key[PF_SK_STACK].af;
	} else {
		ab = &s2->key[side].addr[io];
		pb =  s2->key[side].port[io];
		af = s1->key[side].af;
	}


	if (ntohs(pa) > ntohs(pb))
		return sortdir;
	if (ntohs(pa) < ntohs(pb))
		return - sortdir;

	ret = compare_addr(af, aa, ab);
	if (ret)
		return ret * sortdir;
	return -sortdir;
}

int
sort_sa_callback(const void *p1, const void *p2)
{
	struct pfsync_state *s1 = state_buf + (* (u_int32_t *) p1);
	struct pfsync_state *s2 = state_buf + (* (u_int32_t *) p2);
	return sort_addr_callback(s1, s2, PF_OUT);
}

int
sort_da_callback(const void *p1, const void *p2)
{
	struct pfsync_state *s1 = state_buf + (* (u_int32_t *) p1);
	struct pfsync_state *s2 = state_buf + (* (u_int32_t *) p2);
	return sort_addr_callback(s1, s2, PF_IN);
}

int
sort_sp_callback(const void *p1, const void *p2)
{
	struct pfsync_state *s1 = state_buf + (* (u_int32_t *) p1);
	struct pfsync_state *s2 = state_buf + (* (u_int32_t *) p2);
	return sort_port_callback(s1, s2, PF_OUT);
}

int
sort_dp_callback(const void *p1, const void *p2)
{
	struct pfsync_state *s1 = state_buf + (* (u_int32_t *) p1);
	struct pfsync_state *s2 = state_buf + (* (u_int32_t *) p2);
	return sort_port_callback(s1, s2, PF_IN);
}

void
sort_states(void)
{
	order_type *ordering;

	if (curr_mgr == NULL)
		return;

	ordering = curr_mgr->order_curr;

	if (ordering == NULL)
		return;
	if (ordering->func == NULL)
		return;
	if (state_buf == NULL)
		return;
	if (num_states <= 0)
		return;

	mergesort(state_ord, num_states, sizeof(u_int32_t), ordering->func);
}

/* state management functions */

void
alloc_buf(int ns)
{
	int len;

	if (ns < MIN_NUM_STATES)
		ns = MIN_NUM_STATES;

	len = ns;

	if (len >= state_buf_len) {
		len += NUM_STATE_INC;
		state_buf = reallocarray(state_buf, len,
		    sizeof(struct pfsync_state));
		state_ord = reallocarray(state_ord, len, sizeof(u_int32_t));
		state_cache = reallocarray(state_cache, len,
		    sizeof(struct sc_ent *));
		if (state_buf == NULL || state_ord == NULL ||
		    state_cache == NULL)
			err(1, "realloc");
		state_buf_len = len;
	}
}

int
select_states(void)
{
	num_disp = num_states;
	return (0);
}

int
read_states(void)
{
	struct pfioc_states ps;
	int n;

	if (pf_dev == -1)
		return -1;

	for (;;) {
		int sbytes = state_buf_len * sizeof(struct pfsync_state);

		ps.ps_len = sbytes;
		ps.ps_buf = (char *) state_buf;

		if (ioctl(pf_dev, DIOCGETSTATES, &ps) < 0) {
			error("DIOCGETSTATES");
		}
		num_states_all = ps.ps_len / sizeof(struct pfsync_state);

		if (ps.ps_len < sbytes)
			break;

		alloc_buf(num_states_all);
	}

	num_states =  num_states_all;
	for (n = 0; n<num_states_all; n++)
		state_ord[n] = n;

	if (cachestates) {
		for (n = 0; n < num_states; n++)
			state_cache[n] = cache_state(state_buf + n);
		cache_endupdate();
	}

	num_disp = num_states;
	return 0;
}

int
unmask(struct pf_addr * m, u_int8_t af)
{
	int i = 31, j = 0, b = 0, msize;
	u_int32_t tmp;

	if (af == AF_INET)
		msize = 1;
	else
		msize = 4;
	while (j < msize && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < msize) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}

/* display functions */

void
tb_print_addr(struct pf_addr * addr, struct pf_addr * mask, int af)
{
		switch (af) {
		case AF_INET: {
			tbprintf("%s", inetname(addr->v4));
			break;
		}
		case AF_INET6: {
			tbprintf("%s", inet6name(&addr->v6));
			break;
		}
	}

	if (mask != NULL) {
		if (!PF_AZERO(mask, af))
			tbprintf("/%u", unmask(mask, af));
	}
}

void
print_fld_host2(field_def *fld, struct pfsync_state_key *ks,
		struct pfsync_state_key *kn, int idx)
{
	struct pf_addr *as = &ks->addr[idx];
	struct pf_addr *an = &kn->addr[idx];

	u_int16_t ps = ntohs(ks->port[idx]);
	u_int16_t pn = ntohs(kn->port[idx]);

	int asf = ks->af;
	int anf = kn->af;

	if (fld == NULL)
		return;

	if (fld->width < 3) {
		print_fld_str(fld, "*");
		return;
	}

	tb_start();
	tb_print_addr(as, NULL, asf);

	if (asf == AF_INET)
		tbprintf(":%u", ps);
	else
		tbprintf("[%u]", ps);

	print_fld_tb(fld);

	if (asf != anf || PF_ANEQ(as, an, asf) || ps != pn) {
		tb_start();
		tb_print_addr(an, NULL, anf);

		if (anf == AF_INET)
			tbprintf(":%u", pn);
		else
			tbprintf("[%u]", pn);
		print_fld_tb(FLD_GW);
	}

}

void
print_fld_state(field_def *fld, unsigned int proto,
		unsigned int s1, unsigned int s2)
{
	int len;

	if (fld == NULL)
		return;

	len = fld->width;
	if (len < 1)
		return;

	tb_start();

	if (proto == IPPROTO_TCP) {
		if (s1 <= TCPS_TIME_WAIT && s2 <= TCPS_TIME_WAIT)
			tbprintf("%s:%s", tcpstates[s1], tcpstates[s2]);
#ifdef PF_TCPS_PROXY_SRC
		else if (s1 == PF_TCPS_PROXY_SRC ||
			   s2 == PF_TCPS_PROXY_SRC)
			tbprintf("PROXY:SRC\n");
		else if (s1 == PF_TCPS_PROXY_DST ||
			 s2 == PF_TCPS_PROXY_DST)
			tbprintf("PROXY:DST\n");
#endif
		else
			tbprintf("<BAD STATE LEVELS>");
	} else if (proto == IPPROTO_UDP && s1 < PFUDPS_NSTATES &&
		   s2 < PFUDPS_NSTATES) {
		const char *states[] = PFUDPS_NAMES;
		tbprintf("%s:%s", states[s1], states[s2]);
	} else if (proto != IPPROTO_ICMP && s1 < PFOTHERS_NSTATES &&
		   s2 < PFOTHERS_NSTATES) {
		/* XXX ICMP doesn't really have state levels */
		const char *states[] = PFOTHERS_NAMES;
		tbprintf("%s:%s", states[s1], states[s2]);
	} else {
		tbprintf("%u:%u", s1, s2);
	}

	if (strlen(tmp_buf) > len) {
		tb_start();
		tbprintf("%u:%u", s1, s2);
	}

	print_fld_tb(fld);
}

int
print_state(struct pfsync_state * s, struct sc_ent * ent)
{
	struct pfsync_state_peer *src, *dst;
	struct protoent *p;
	u_int64_t sz;
	int afto, dir;

	afto = s->key[PF_SK_STACK].af == s->key[PF_SK_WIRE].af ? 0 : 1;
	dir = afto ? PF_OUT : s->direction;

	if (dir == PF_OUT) {
		src = &s->src;
		dst = &s->dst;
	} else {
		src = &s->dst;
		dst = &s->src;
	}

	p = getprotobynumber(s->proto);

	if (p != NULL)
		print_fld_str(FLD_PROTO, p->p_name);
	else
		print_fld_uint(FLD_PROTO, s->proto);

	if (dir == PF_OUT) {
		print_fld_host2(FLD_SRC,
		    &s->key[afto ? PF_SK_STACK : PF_SK_WIRE],
		    &s->key[PF_SK_STACK], 1);
		print_fld_host2(FLD_DEST,
		    &s->key[afto ? PF_SK_STACK : PF_SK_WIRE],
		    &s->key[afto ? PF_SK_WIRE : PF_SK_STACK], 0);
	} else {
		print_fld_host2(FLD_SRC, &s->key[PF_SK_STACK],
		    &s->key[PF_SK_WIRE], 0);
		print_fld_host2(FLD_DEST, &s->key[PF_SK_STACK],
		    &s->key[PF_SK_WIRE], 1);
	}

	if (dir == PF_OUT)
		print_fld_str(FLD_DIR, "Out");
	else
		print_fld_str(FLD_DIR, "In");

	print_fld_state(FLD_STATE, s->proto, src->state, dst->state);
	print_fld_age(FLD_AGE, ntohl(s->creation));
	print_fld_age(FLD_EXP, ntohl(s->expire));

	sz = COUNTER(s->bytes[0]) + COUNTER(s->bytes[1]);

	print_fld_size(FLD_PKTS, COUNTER(s->packets[0]) +
		       COUNTER(s->packets[1]));
	print_fld_size(FLD_BYTES, sz);
	print_fld_rate(FLD_SA, (s->creation) ?
		       ((double)sz/(double)ntohl(s->creation)) : -1);

	print_fld_uint(FLD_RULE, ntohl(s->rule));
	if (cachestates && ent != NULL) {
		print_fld_rate(FLD_SI, ent->rate);
		print_fld_rate(FLD_SP, ent->peak);
	}

	end_line();
	return 1;
}

void
print_states(void)
{
	int n, count = 0;

	for (n = dispstart; n < num_disp; n++) {
		count += print_state(state_buf + state_ord[n],
				     state_cache[state_ord[n]]);
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}

/* rule display */

struct pf_rule *rules = NULL;
u_int32_t alloc_rules = 0;

int
select_rules(void)
{
	num_disp = num_rules;
	return (0);
}


void
add_rule_alloc(u_int32_t nr)
{
	if (nr == 0)
		return;

	num_rules += nr;

	if (rules == NULL) {
		rules = reallocarray(NULL, num_rules, sizeof(struct pf_rule));
		if (rules == NULL)
			err(1, "malloc");
		alloc_rules = num_rules;
	} else if (num_rules > alloc_rules) {
		rules = reallocarray(rules, num_rules, sizeof(struct pf_rule));
		if (rules == NULL)
			err(1, "realloc");
		alloc_rules = num_rules;
	}
}

int label_length;

int
read_anchor_rules(char *anchor)
{
	struct pfioc_rule pr;
	u_int32_t nr, num, off;
	int len;

	if (pf_dev < 0)
		return (-1);

	memset(&pr, 0, sizeof(pr));
	strlcpy(pr.anchor, anchor, sizeof(pr.anchor));

	if (ioctl(pf_dev, DIOCGETRULES, &pr)) {
		error("anchor %s: %s", anchor, strerror(errno));
		return (-1);
	}

	off = num_rules;
	num = pr.nr;
	add_rule_alloc(num);

	for (nr = 0; nr < num; ++nr) {
		pr.nr = nr;
		if (ioctl(pf_dev, DIOCGETRULE, &pr)) {
			error("DIOCGETRULE: %s", strerror(errno));
			return (-1);
		}
		/* XXX overload pr.anchor, to store a pointer to
		 * anchor name */
		pr.rule.anchor = (struct pf_anchor *) anchor;
		len = strlen(pr.rule.label);
		if (len > label_length)
			label_length = len;
		rules[off + nr] = pr.rule;
	}

	return (num);
}

struct anchor_name {
	char name[PATH_MAX];
	struct anchor_name *next;
	u_int32_t ref;
};

struct anchor_name *anchor_root = NULL;
struct anchor_name *anchor_end = NULL;
struct anchor_name *anchor_free = NULL;

struct anchor_name*
alloc_anchor_name(const char *path)
{
	struct anchor_name *a;

	a = anchor_free;
	if (a == NULL) {
		a = malloc(sizeof(struct anchor_name));
		if (a == NULL)
			return (NULL);
	} else
		anchor_free = a->next;

	if (anchor_root == NULL)
		anchor_end = a;

	a->next = anchor_root;
	anchor_root = a;

	a->ref = 0;
	strlcpy(a->name, path, sizeof(a->name));
	return (a);
}

void
reset_anchor_names(void)
{
	if (anchor_end == NULL)
		return;

	anchor_end->next = anchor_free;
	anchor_free = anchor_root;
	anchor_root = anchor_end = NULL;
}

struct pfioc_ruleset ruleset;
char *rs_end = NULL;

int
read_rulesets(const char *path)
{
	char *pre;
	struct anchor_name *a;
	u_int32_t nr, ns;
	int len;

	if (path == NULL)
		ruleset.path[0] = '\0';
	else if (strlcpy(ruleset.path, path, sizeof(ruleset.path)) >= 
	    sizeof(ruleset.path))
		 return (-1);

	/* a persistent storage for anchor names */
	a = alloc_anchor_name(ruleset.path);
	if (a == NULL)
		return (-1);

	len = read_anchor_rules(a->name);
	if (len < 0)
		return (-1);

	a->ref += len;

	if (ioctl(pf_dev, DIOCGETRULESETS, &ruleset)) {
		error("DIOCGETRULESETS: %s", strerror(errno));
		return (-1);
	}

	ns = ruleset.nr;

	if (rs_end == NULL)
		rs_end = ruleset.path + sizeof(ruleset.path);

	/* 'pre' tracks the previous level on the anchor */
	pre = strchr(ruleset.path, 0);
	len = rs_end - pre;
	if (len < 1)
		return (-1);
	--len;

	for (nr = 0; nr < ns; ++nr) {
		ruleset.nr = nr;
		if (ioctl(pf_dev, DIOCGETRULESET, &ruleset)) {
			error("DIOCGETRULESET: %s", strerror(errno));
			return (-1);
		}
		*pre = '/';
		if (strlcpy(pre + 1, ruleset.name, len) < len)
			read_rulesets(ruleset.path);
		*pre = '\0';
	}

	return (0);
}

void
compute_anchor_field(void)
{
	struct anchor_name *a;
	int sum, cnt, mx, nx;
	sum = cnt = mx = 0;

	for (a = anchor_root; a != NULL; a = a->next, cnt++) {
		int len;
		if (a->ref == 0)
			continue;
		len = strlen(a->name);
		sum += len;
		if (len > mx)
			mx = len;
	}

	nx = sum/cnt;
	if (nx < ANCHOR_FLD_SIZE)
		nx = (mx < ANCHOR_FLD_SIZE) ? mx : ANCHOR_FLD_SIZE;

	if (FLD_ANCHOR->max_width != mx ||
	    FLD_ANCHOR->norm_width != nx) {
		FLD_ANCHOR->max_width = mx;
		FLD_ANCHOR->norm_width = nx;
		field_setup();
		need_update = 1;
	}
}

int
read_rules(void)
{
	int ret, nw, mw;
	num_rules = 0;

	if (pf_dev == -1)
		return (-1);

	label_length = MIN_LABEL_SIZE;

	reset_anchor_names();
	ret = read_rulesets(NULL);
	compute_anchor_field();

	nw = mw = label_length;
	if (nw > 16)
		nw = 16;

	if (FLD_LABEL->norm_width != nw || 
	    FLD_LABEL->max_width != mw) {
		FLD_LABEL->norm_width = nw;
		FLD_LABEL->max_width = mw;
		field_setup();
		need_update = 1;
	}

	num_disp = num_rules;
	return (ret);
}

void
tb_print_addrw(struct pf_addr_wrap *addr, struct pf_addr *mask, u_int8_t af)
{
	switch (addr->type) {
	case PF_ADDR_ADDRMASK:
		tb_print_addr(&addr->v.a.addr, mask, af);
		break;
	case  PF_ADDR_NOROUTE:
		tbprintf("noroute");
		break;
	case PF_ADDR_DYNIFTL:
		tbprintf("(%s)", addr->v.ifname);
		break;
	case PF_ADDR_TABLE:
		tbprintf("<%s>", addr->v.tblname);
		break;
	default:
		tbprintf("UNKNOWN");
		break;
	}
}

void
tb_print_op(u_int8_t op, const char *a1, const char *a2)
{
	if (op == PF_OP_IRG)
		tbprintf("%s >< %s ", a1, a2);
	else if (op == PF_OP_XRG)
		tbprintf("%s <> %s ", a1, a2);
	else if (op == PF_OP_RRG)
		tbprintf("%s:%s ", a1, a2);
	else if (op == PF_OP_EQ)
		tbprintf("= %s ", a1);
	else if (op == PF_OP_NE)
		tbprintf("!= %s ", a1);
	else if (op == PF_OP_LT)
		tbprintf("< %s ", a1);
	else if (op == PF_OP_LE)
		tbprintf("<= %s ", a1);
	else if (op == PF_OP_GT)
		tbprintf("> %s ", a1);
	else if (op == PF_OP_GE)
		tbprintf(">= %s ", a1);
}

void
tb_print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, char *proto)
{
	char a1[6], a2[6];
	struct servent *s = getservbyport(p1, proto);

	p1 = ntohs(p1);
	p2 = ntohs(p2);
	snprintf(a1, sizeof(a1), "%u", p1);
	snprintf(a2, sizeof(a2), "%u", p2);
	tbprintf("port ");
	if (s != NULL && (op == PF_OP_EQ || op == PF_OP_NE))
		tb_print_op(op, s->s_name, a2);
	else
		tb_print_op(op, a1, a2);
}

void
tb_print_fromto(struct pf_rule_addr *src, struct pf_rule_addr *dst,
		u_int8_t af, u_int8_t proto)
{
	if (
	    PF_AZERO(PT_ADDR(src), AF_INET6) &&
	    PF_AZERO(PT_ADDR(dst), AF_INET6) &&
	    ! PT_NOROUTE(src) && ! PT_NOROUTE(dst) &&
	    PF_AZERO(PT_MASK(src), AF_INET6) &&
	    PF_AZERO(PT_MASK(dst), AF_INET6) &&
	    !src->port_op && !dst->port_op)
		tbprintf("all ");
	else {
		tbprintf("from ");
		if (PT_NOROUTE(src))
			tbprintf("no-route ");
		else if (PF_AZERO(PT_ADDR(src), AF_INET6) &&
			 PF_AZERO(PT_MASK(src), AF_INET6))
			tbprintf("any ");
		else {
			if (src->neg)
				tbprintf("! ");
			tb_print_addrw(&src->addr, PT_MASK(src), af);
			tbprintf(" ");
		}
		if (src->port_op)
			tb_print_port(src->port_op, src->port[0],
				      src->port[1],
				      proto == IPPROTO_TCP ? "tcp" : "udp");

		tbprintf("to ");
		if (PT_NOROUTE(dst))
			tbprintf("no-route ");
		else if (PF_AZERO(PT_ADDR(dst), AF_INET6) &&
			 PF_AZERO(PT_MASK(dst), AF_INET6))
			tbprintf("any ");
		else {
			if (dst->neg)
				tbprintf("! ");
			tb_print_addrw(&dst->addr, PT_MASK(dst), af);
			tbprintf(" ");
		}
		if (dst->port_op)
			tb_print_port(dst->port_op, dst->port[0],
				      dst->port[1],
				      proto == IPPROTO_TCP ? "tcp" : "udp");
	}
}

void
tb_print_ugid(u_int8_t op, unsigned u1, unsigned u2,
	      const char *t, unsigned umax)
{
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", u1);
	snprintf(a2, sizeof(a2), "%u", u2);

	tbprintf("%s ", t);
	if (u1 == umax && (op == PF_OP_EQ || op == PF_OP_NE))
		tb_print_op(op, "unknown", a2);
	else
		tb_print_op(op, a1, a2);
}

void
tb_print_flags(u_int8_t f)
{
	const char *tcpflags = "FSRPAUEW";
	int i;

	for (i = 0; tcpflags[i]; ++i)
		if (f & (1 << i))
			tbprintf("%c", tcpflags[i]);
}

void
print_rule(struct pf_rule *pr)
{
	static const char *actiontypes[] = { "Pass", "Block", "Scrub",
	    "no Scrub", "Nat", "no Nat", "Binat", "no Binat", "Rdr",
	    "no Rdr", "SynProxy Block", "Defer", "Match" };
	int numact = sizeof(actiontypes) / sizeof(char *);

	static const char *routetypes[] = { "", "fastroute", "route-to",
	    "dup-to", "reply-to" };

	int numroute = sizeof(routetypes) / sizeof(char *);

	if (pr == NULL) return;

	print_fld_str(FLD_LABEL, pr->label);
	print_fld_size(FLD_STATS, pr->states_tot);

	print_fld_size(FLD_PKTS, pr->packets[0] + pr->packets[1]);
	print_fld_size(FLD_BYTES, pr->bytes[0] + pr->bytes[1]);

	print_fld_uint(FLD_RULE, pr->nr);
	if (pr->direction == PF_OUT)
		print_fld_str(FLD_DIR, "Out");
	else if (pr->direction == PF_IN)
		print_fld_str(FLD_DIR, "In");
	else
		print_fld_str(FLD_DIR, "Any");

	if (pr->quick)
		print_fld_str(FLD_QUICK, "Quick");

	if (pr->keep_state == PF_STATE_NORMAL)
		print_fld_str(FLD_KST, "Keep");
	else if (pr->keep_state == PF_STATE_MODULATE)
		print_fld_str(FLD_KST, "Mod");
	else if (pr->keep_state == PF_STATE_SYNPROXY)
		print_fld_str(FLD_KST, "Syn");
	if (pr->log == 1)
		print_fld_str(FLD_LOG, "Log");
	else if (pr->log == 2)
		print_fld_str(FLD_LOG, "All");

	if (pr->action >= numact)
		print_fld_uint(FLD_ACTION, pr->action);
	else print_fld_str(FLD_ACTION, actiontypes[pr->action]);

	if (pr->proto) {
		struct protoent *p = getprotobynumber(pr->proto);

		if (p != NULL)
			print_fld_str(FLD_PROTO, p->p_name);
		else
			print_fld_uint(FLD_PROTO, pr->proto);
	}

	if (pr->ifname[0]) {
		tb_start();
		if (pr->ifnot)
			tbprintf("!");
		tbprintf("%s", pr->ifname);
		print_fld_tb(FLD_IF);
	}
	if (pr->max_states)
		print_fld_uint(FLD_STMAX, pr->max_states);

	/* print info field */

	tb_start();

	if (pr->action == PF_DROP) {
		if (pr->rule_flag & PFRULE_RETURNRST)
			tbprintf("return-rst ");
#ifdef PFRULE_RETURN
		else if (pr->rule_flag & PFRULE_RETURN)
			tbprintf("return ");
#endif
#ifdef PFRULE_RETURNICMP
		else if (pr->rule_flag & PFRULE_RETURNICMP)
			tbprintf("return-icmp ");
#endif
		else
			tbprintf("drop ");
	}

	if (pr->rt > 0 && pr->rt < numroute) {
		tbprintf("%s ", routetypes[pr->rt]);
	}

	if (pr->af) {
		if (pr->af == AF_INET)
			tbprintf("inet ");
		else
			tbprintf("inet6 ");
	}

	tb_print_fromto(&pr->src, &pr->dst, pr->af, pr->proto);

	if (pr->uid.op)
		tb_print_ugid(pr->uid.op, pr->uid.uid[0], pr->uid.uid[1],
		        "user", UID_MAX);
	if (pr->gid.op)
		tb_print_ugid(pr->gid.op, pr->gid.gid[0], pr->gid.gid[1],
		        "group", GID_MAX);

	if (pr->action == PF_PASS &&
	    (pr->proto == 0 || pr->proto == IPPROTO_TCP) &&
	    (pr->flags != TH_SYN || pr->flagset != (TH_SYN | TH_ACK) )) {
		tbprintf("flags ");
		if (pr->flags || pr->flagset) {
			tb_print_flags(pr->flags);
			tbprintf("/");
			tb_print_flags(pr->flagset);
		} else
			tbprintf("any ");
	}

	tbprintf(" ");

	if (pr->tos)
		tbprintf("tos 0x%2.2x ", pr->tos);
#ifdef PFRULE_FRAGMENT
	if (pr->rule_flag & PFRULE_FRAGMENT)
		tbprintf("fragment ");
#endif
#ifdef PFRULE_NODF
	if (pr->rule_flag & PFRULE_NODF)
		tbprintf("no-df ");
#endif
#ifdef PFRULE_RANDOMID
	if (pr->rule_flag & PFRULE_RANDOMID)
		tbprintf("random-id ");
#endif
	if (pr->min_ttl)
		tbprintf("min-ttl %d ", pr->min_ttl);
	if (pr->max_mss)
		tbprintf("max-mss %d ", pr->max_mss);
	if (pr->allow_opts)
		tbprintf("allow-opts ");

	/* XXX more missing */

	if (pr->qname[0] && pr->pqname[0])
		tbprintf("queue(%s, %s) ", pr->qname, pr->pqname);
	else if (pr->qname[0])
		tbprintf("queue %s ", pr->qname);

	if (pr->tagname[0])
		tbprintf("tag %s ", pr->tagname);
	if (pr->match_tagname[0]) {
		if (pr->match_tag_not)
			tbprintf("! ");
		tbprintf("tagged %s ", pr->match_tagname);
	}

	print_fld_tb(FLD_RINFO);

	/* XXX anchor field overloaded with anchor name */
	print_fld_str(FLD_ANCHOR, (char *)pr->anchor);
	tb_end();

	end_line();
}

void
print_rules(void)
{
	u_int32_t n, count = 0;

	for (n = dispstart; n < num_rules; n++) {
		print_rule(rules + n);
		count ++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}

/* queue display */
struct pfctl_queue_node *
pfctl_find_queue_node(const char *qname, const char *ifname)
{
	struct pfctl_queue_node	*node;

	TAILQ_FOREACH(node, &qnodes, entries)
		if (!strcmp(node->qs.qname, qname)
		    && !(strcmp(node->qs.ifname, ifname)))
			return (node);
	return (NULL);
}

void
pfctl_insert_queue_node(const struct pf_queuespec qs,
    const struct queue_stats qstats)
{
	struct pfctl_queue_node	*node, *parent;

	node = calloc(1, sizeof(struct pfctl_queue_node));
	if (node == NULL)
		err(1, "pfctl_insert_queue_node: calloc");
	memcpy(&node->qs, &qs, sizeof(qs));
	memcpy(&node->qstats, &qstats, sizeof(qstats));

	if (node->qs.parent[0]) {
		parent = pfctl_find_queue_node(node->qs.parent,
		    node->qs.ifname);
		if (parent)
			node->depth = parent->depth + 1;
	}

	TAILQ_INSERT_TAIL(&qnodes, node, entries);
}

int
pfctl_update_qstats(void)
{
	struct pfctl_queue_node	*node;
	struct pfioc_queue	 pq;
	struct pfioc_qstats	 pqs;
	u_int32_t		 mnr, nr;
	struct queue_stats	 qstats;
	static u_int32_t	 last_ticket;

	memset(&pq, 0, sizeof(pq));
	memset(&pqs, 0, sizeof(pqs));
	memset(&qstats, 0, sizeof(qstats));

	if (pf_dev < 0)
		return (-1);

	if (ioctl(pf_dev, DIOCGETQUEUES, &pq)) {
		error("DIOCGETQUEUES: %s", strerror(errno));
		return (-1);
	}

	/* if a new set is found, start over */
	if (pq.ticket != last_ticket)
		while ((node = TAILQ_FIRST(&qnodes)) != NULL) {
			TAILQ_REMOVE(&qnodes, node, entries);
			free(node);
		}
	last_ticket = pq.ticket;

	num_queues = mnr = pq.nr;
	for (nr = 0; nr < mnr; ++nr) {
		pqs.nr = nr;
		pqs.ticket = pq.ticket;
		pqs.buf = &qstats.data;
		pqs.nbytes = sizeof(qstats.data);
		if (ioctl(pf_dev, DIOCGETQSTATS, &pqs)) {
			error("DIOCGETQSTATS: %s", strerror(errno));
			return (-1);
		}
		qstats.valid = 1;
		gettimeofday(&qstats.timestamp, NULL);
		if ((node = pfctl_find_queue_node(pqs.queue.qname,
		    pqs.queue.ifname)) != NULL) {
			memcpy(&node->qstats_last, &node->qstats,
			    sizeof(struct queue_stats));
			memcpy(&node->qstats, &qstats,
			    sizeof(struct queue_stats));
		} else {
			pfctl_insert_queue_node(pqs.queue, qstats);
		}
	}
	return (0);
}

int
select_queues(void)
{
	num_disp = num_queues;
	return (0);
}

int
read_queues(void)
{
	num_disp = num_queues = 0;

	if (pfctl_update_qstats() < 0)
		return (-1);
	num_disp = num_queues;

	return(0);
}

double
calc_interval(struct timeval *cur_time, struct timeval *last_time)
{
	double	sec;

	sec = (double)(cur_time->tv_sec - last_time->tv_sec) +
	    (double)(cur_time->tv_usec - last_time->tv_usec) / 1000000;

	return (sec);
}

double
calc_rate(u_int64_t new_bytes, u_int64_t last_bytes, double interval)
{
	double	rate;

	rate = (double)(new_bytes - last_bytes) / interval;
	return (rate);
}

double
calc_pps(u_int64_t new_pkts, u_int64_t last_pkts, double interval)
{
	double	pps;

	pps = (double)(new_pkts - last_pkts) / interval;
	return (pps);
}

void
print_queue_node(struct pfctl_queue_node *node)
{
	u_int	rate, rtmp;
	int 	i;
	double	interval, pps, bps;
	static const char unit[] = " KMG";

	tb_start();
	for (i = 0; i < node->depth; i++)
		tbprintf(" ");
	tbprintf("%s", node->qs.qname);
	if (i == 0 && node->qs.ifname[0])
		tbprintf(" on %s ", node->qs.ifname);
	print_fld_tb(FLD_QUEUE);

	// XXX: missing min, max, burst
	tb_start();
	rate = node->qs.linkshare.m2.absolute;
	for (i = 0; rate > 9999 && i <= 3; i++) {
		rtmp = rate / 1000;
		if (rtmp <= 9999)
			rtmp += (rate % 1000) / 500;
		rate = rtmp;
	}
	if (rate == 0 && (node->qs.flags & PFQS_FLOWQUEUE)) {
		/*
		 * XXX We're abusing the fact that 'flows' in
		 * the fqcodel_stats structure is at the same
		 * spot as the 'period' in hfsc_class_stats.
		 */
		tbprintf("%u", node->qstats.data.period);
	} else
		tbprintf("%u%c", rate, unit[i]);
	print_fld_tb(FLD_BANDW);

	print_fld_str(FLD_SCHED, node->qs.flags & PFQS_FLOWQUEUE ?
	    "flow" : "fifo");

	if (node->qstats.valid && node->qstats_last.valid)
		interval = calc_interval(&node->qstats.timestamp,
		    &node->qstats_last.timestamp);
	else
		interval = 0;

	print_fld_size(FLD_PKTS, node->qstats.data.xmit_cnt.packets);
	print_fld_size(FLD_BYTES, node->qstats.data.xmit_cnt.bytes);
	print_fld_size(FLD_DROPP, node->qstats.data.drop_cnt.packets);
	print_fld_size(FLD_DROPB, node->qstats.data.drop_cnt.bytes);
	print_fld_size(FLD_QLEN, node->qstats.data.qlength);

	if (interval > 0) {
		pps = calc_pps(node->qstats.data.xmit_cnt.packets,
		    node->qstats_last.data.xmit_cnt.packets, interval);
		bps = calc_rate(node->qstats.data.xmit_cnt.bytes,
		    node->qstats_last.data.xmit_cnt.bytes, interval);

		tb_start();
		if (pps > 0 && pps < 1)
			tbprintf("%-3.1lf", pps);
		else
			tbprintf("%u", (unsigned int)pps);

		print_fld_tb(FLD_PKTSPS);
		print_fld_bw(FLD_BYTESPS, bps);
	}
}

void
print_queues(void)
{
	uint32_t n, count, start;
	struct pfctl_queue_node *node;

	n = count = 0;
	start = dispstart;

	TAILQ_FOREACH(node, &qnodes, entries) {
		if (n < start) {
			n++;
			continue;
		}
		print_queue_node(node);
		end_line();
		count++;
		if (maxprint > 0 && count >= maxprint)
			return;
	}
}

/* main program functions */

void
update_cache(void)
{
	static int pstate = -1;
	if (pstate == cachestates)
		return;

	pstate = cachestates;
	if (cachestates) {
		show_field(FLD_SI);
		show_field(FLD_SP);
		gotsig_alarm = 1;
	} else {
		hide_field(FLD_SI);
		hide_field(FLD_SP);
		need_update = 1;
	}
	field_setup();
}

int
initpftop(void)
{
	struct pf_status status;
	field_view *v;
	int cachesize = DEFAULT_CACHE_SIZE;

	v = views;
	while(v->name != NULL)
		add_view(v++);

	pf_dev = open("/dev/pf", O_RDONLY);
	if (pf_dev == -1) {
		alloc_buf(0);
	} else if (ioctl(pf_dev, DIOCGETSTATUS, &status)) {
		warn("DIOCGETSTATUS");
		alloc_buf(0);
	} else
		alloc_buf(status.states);

	/* initialize cache with given size */
	if (cache_init(cachesize))
		warnx("Failed to initialize cache.");
	else if (interactive && cachesize > 0)
		cachestates = 1;

	update_cache();

	show_field(FLD_STMAX);
	show_field(FLD_ANCHOR);

	return (1);
}
@


1.39
log
@Support for displaying flow queues alongside H-FSC

This (ab)uses the fact that node->qstats.data.period field in
hfsc_class_stats structure is at the same offset as the 'flows'
field in fqcodel_stats.

While here make use of a presently empty field "SCH" to display
the queue management policy (flow or fifo) which is not strictly
a scheduler, but it will hopefully become descriptive and useful
later. This distinguishes flow queues from the regular HFSC ones.

OK sthen, visa
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.38 2017/05/16 22:29:07 mikeb Exp $	 */
d1626 8
a1633 1
	if (node->qs.flags & PFQS_FLOWQUEUE) {
d1640 1
a1640 8
	} else {
		rate = node->qs.linkshare.m2.absolute;
		for (i = 0; rate > 9999 && i <= 3; i++) {
			rtmp = rate / 1000;
			if (rtmp <= 9999)
				rtmp += (rate % 1000) / 500;
			rate = rtmp;
		}
a1641 1
	}
@


1.38
log
@Improve the precision of displayed bandwidth values

Carl Mascott has reported the issue and helped with the fix.  OK tb
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.37 2017/05/03 14:01:29 mikeb Exp $	 */
d151 1
a151 1
	{"BW", 4, 5, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
d1626 16
a1641 6
	rate = node->qs.linkshare.m2.absolute;
	for (i = 0; rate > 9999 && i <= 3; i++) {
		rtmp = rate / 1000;
		if (rtmp <= 9999)
			rtmp += (rate % 1000) / 500;
		rate = rtmp;
a1642 1
	tbprintf("%u%c", rate, unit[i]);
d1644 3
@


1.37
log
@Remove unused PRIO column from the queueing display;  ok sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.36 2017/04/26 15:50:59 mikeb Exp $	 */
d1611 1
a1611 1
	u_int	rate;
d1627 6
a1632 2
	for (i = 0; rate >= 1000 && i <= 3; i++)
		rate /= 1000;
@


1.36
log
@Perform H-FSC root queue allocation in the kernel

Since only leaf queues can have packets assigned to them,
H-FSC requires the user specified root queue to have a
parent.  To simplify userland tools and the configuration
interface, the kernel can be leveraged to set it up.

ok henning
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.35 2016/12/18 19:39:30 jasper Exp $	 */
a152 1
	{"PRIO", 1, 4, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
d196 7
a202 8
#define FLD_PRIO    FIELD_ADDR(fields,28)
#define FLD_DROPP   FIELD_ADDR(fields,29)
#define FLD_DROPB   FIELD_ADDR(fields,30)
#define FLD_QLEN    FIELD_ADDR(fields,31)
#define FLD_BORR    FIELD_ADDR(fields,32)
#define FLD_SUSP    FIELD_ADDR(fields,33)
#define FLD_PKTSPS  FIELD_ADDR(fields,34)
#define FLD_BYTESPS FIELD_ADDR(fields,35)
d248 1
a248 1
	FLD_QUEUE, FLD_BANDW, FLD_SCHED, FLD_PRIO, FLD_PKTS, FLD_BYTES,
@


1.35
log
@increase width of interface column in the pf rules view by 2 chars, so that 'vetherXY' fits

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.34 2016/04/13 05:25:45 jasper Exp $	 */
d1547 11
a1557 16
		if (pqs.queue.qname[0] != '_') {
			if (pqs.queue.parent[0] && pqs.queue.parent[0] == '_')
				pqs.queue.parent[0] = '\0';
			qstats.valid = 1;
			gettimeofday(&qstats.timestamp, NULL);
			if ((node = pfctl_find_queue_node(pqs.queue.qname,
			    pqs.queue.ifname)) != NULL) {
				memcpy(&node->qstats_last, &node->qstats,
				    sizeof(struct queue_stats));
				memcpy(&node->qstats, &qstats,
				    sizeof(struct queue_stats));
			} else {
				pfctl_insert_queue_node(pqs.queue, qstats);
			}
		} else
			num_queues--;
@


1.34
log
@remove dumpfilter related code; it's a leftover from pftop-proper and not used
in systat

ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.33 2016/01/16 03:30:26 canacar Exp $	 */
d143 1
a143 1
	{"IF", 4, 6, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
@


1.33
log
@fix a number of minor issues in the state view:

1. peak and rate computations were using uint32 size which caused
the fields from working for states that transferred more than 4GB
also fix an unnecessary cast to double found while looking for the bug.

2. When creating new cache entries for existing states, start time from
0 rather than the current time to prevent a "spike" in rate and peak.
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.32 2015/08/20 22:32:42 deraadt Exp $	 */
a118 1
int dumpfilter = 0;
a681 8
	}

	if (dumpfilter) {
		int fd = open("state.dmp", O_WRONLY|O_CREAT|O_EXCL, 0);
		if (fd > 0) {
			write(fd, state_buf, ps.ps_len);
			close(fd);
		}
@


1.32
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.31 2015/02/09 02:00:38 jsg Exp $	 */
d899 1
a899 1
		       ((double)sz/ntohl((double)s->creation)) : -1);
@


1.31
log
@Correct a test so synproxy states will display as "Syn" instead of
modulate states displaying as "Syn".

ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.30 2015/01/16 00:03:37 deraadt Exp $	 */
d1017 1
a1017 1
		a = (struct anchor_name *)malloc(sizeof(struct anchor_name));
@


1.30
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.29 2014/10/11 04:30:56 doug Exp $	 */
d1340 1
a1340 2
#ifdef PF_STATE_SYNPROXY
	else if (pr->keep_state == PF_STATE_MODULATE)
a1341 1
#endif
@


1.29
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.28 2014/05/09 21:03:43 sthen Exp $	 */
d57 1
d1001 1
a1001 1
	char name[MAXPATHLEN];
@


1.28
log
@print interface name with queues in "systat q"; ok henning
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.27 2014/05/03 11:11:15 chl Exp $	 */
d639 5
a643 4
		state_buf = realloc(state_buf, len * sizeof(struct pfsync_state));
		state_ord = realloc(state_ord, len * sizeof(u_int32_t));
		state_cache = realloc(state_cache, 
				      len * sizeof(struct sc_ent *));
d945 1
a945 1
		rules = malloc(num_rules * sizeof(struct pf_rule));
d950 1
a950 1
		rules = realloc(rules, num_rules * sizeof(struct pf_rule));
@


1.27
log
@remove unused variables

ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.26 2014/04/26 11:28:49 sthen Exp $	 */
d1636 2
@


1.26
log
@fix whitespace
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.25 2014/04/26 11:27:23 sthen Exp $	 */
a1585 3
	static int first_read = 1;
	struct pfctl_queue_node *node;
	int inserts;
@


1.25
log
@Only remove queues from the TAILQ when the ticket changes; fixes PPS/BPS
displays for queues in "systat q". From Arto Jonsson.
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.24 2014/04/18 11:36:06 henning Exp $	 */
d375 1
a375 1
	
d393 1
a393 1
	
d430 1
a430 1
	
d449 1
a449 1
       	ii = io = 0;
d516 1
a516 1
       	ii = io = 0;
d732 2
a733 2
        	switch (af) {
        	case AF_INET: {
d736 2
a737 2
        	}
        	case AF_INET6: {
d740 1
a740 1
        	}
d798 1
a798 1
	
d805 1
a805 1
	
d1255 1
a1255 1
		
d1472 1
a1472 1
	
@


1.24
log
@no more altq
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.22 2014/01/19 23:45:34 henning Exp $	 */
a1590 4
	while ((node = TAILQ_FIRST(&qnodes)) != NULL) {
		TAILQ_REMOVE(&qnodes, node, entries);
		free(node);
	}
d1594 1
a1594 1
	
@


1.23
log
@Stop leaking megabytes of memory at every queue refresh.

ok krw
@
text
@a43 5
#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>

a114 1
u_int32_t num_altqs = 0;
a293 26

/* altq structures from pfctl */

union class_stats {
	class_stats_t		cbq_stats;
	struct priq_classstats	priq_stats;
	struct hfsc_classstats	hfsc_stats;
};

struct altq_stats {
	union class_stats	 data;
	struct timeval		 timestamp;
	u_int8_t		 valid;
};

struct pf_altq_node {
	struct pf_altq		 altq;
	struct pf_altq_node	*next;
	struct pf_altq_node	*children;
	struct pf_altq_node	*next_flat;
	struct altq_stats	 qstats;
	struct altq_stats	 qstats_last;
	u_int8_t		 depth;
	u_int8_t		 visited;
};

a1481 77

struct pf_altq_node *
pfctl_find_altq_node(struct pf_altq_node *root, const char *qname,
    const char *ifname)
{
	struct pf_altq_node	*node, *child;

	for (node = root; node != NULL; node = node->next) {
		if (!strcmp(node->altq.qname, qname)
		    && !(strcmp(node->altq.ifname, ifname)))
			return (node);
		if (node->children != NULL) {
			child = pfctl_find_altq_node(node->children, qname,
			    ifname);
			if (child != NULL)
				return (child);
		}
	}
	return (NULL);
}

void
pfctl_insert_altq_node(struct pf_altq_node **root,
    const struct pf_altq altq, const struct altq_stats qstats)
{
	struct pf_altq_node	*node;

	node = calloc(1, sizeof(struct pf_altq_node));
	if (node == NULL)
		err(1, "pfctl_insert_altq_node: calloc");
	memcpy(&node->altq, &altq, sizeof(struct pf_altq));
	memcpy(&node->qstats, &qstats, sizeof(qstats));
	node->next = node->children = node->next_flat = NULL;
	node->depth = 0;
	node->visited = 1;

	if (*root == NULL)
		*root = node;
	else if (!altq.parent[0]) {
		struct pf_altq_node	*prev = *root;

		while (prev->next != NULL)
			prev = prev->next;
		prev->next = node;
	} else {
		struct pf_altq_node	*parent;

		parent = pfctl_find_altq_node(*root, altq.parent, altq.ifname);
		if (parent == NULL)
			errx(1, "parent %s not found", altq.parent);
		node->depth = parent->depth+1;
		if (parent->children == NULL)
			parent->children = node;
		else {
			struct pf_altq_node *prev = parent->children;

			while (prev->next != NULL)
				prev = prev->next;
			prev->next = node;
		}
	}
}

void
pfctl_set_next_flat(struct pf_altq_node *node, struct pf_altq_node *up)
{
	while (node) {
		struct pf_altq_node *next = node->next ? node->next : up;
		if (node->children) {
			node->next_flat = node->children;
			pfctl_set_next_flat(node->children, next);
		} else
			node->next_flat = next;
		node = node->next;
	}
}

a1576 111
pfctl_update_altqstats(struct pf_altq_node **root, int *inserts)
{
	struct pf_altq_node	*node;
	struct pfioc_altq	 pa;
	struct pfioc_altqstats	 pq;
	u_int32_t		 nr;
	struct altq_stats	 qstats;
	u_int32_t		 nr_queues;
	int			 ret = 0;

	*inserts = 0;
	memset(&pa, 0, sizeof(pa));
	memset(&pq, 0, sizeof(pq));
	memset(&qstats, 0, sizeof(qstats));

	if (pf_dev < 0)
		return (-1);

	if (ioctl(pf_dev, DIOCGETALTQS, &pa)) {
		error("DIOCGETALTQS: %s", strerror(errno));
		return (-1);
	}

	num_altqs = nr_queues = pa.nr;
	for (nr = 0; nr < nr_queues; ++nr) {
		pa.nr = nr;
		if (ioctl(pf_dev, DIOCGETALTQ, &pa)) {
			error("DIOCGETALTQ: %s", strerror(errno));
			ret = -1;
			break;
		}
		if (pa.altq.qid > 0) {
			pq.nr = nr;
			pq.ticket = pa.ticket;
			pq.buf = &qstats;
			pq.nbytes = sizeof(qstats);
			if (ioctl(pf_dev, DIOCGETALTQSTATS, &pq)) {
				error("DIOCGETALTQSTATS: %s", strerror(errno));
				ret = -1;
				break;
			}
			qstats.valid = 1;
			gettimeofday(&qstats.timestamp, NULL);
			if ((node = pfctl_find_altq_node(*root, pa.altq.qname,
			    pa.altq.ifname)) != NULL) {
				/* update altq data too as bandwidth may have changed */
				memcpy(&node->altq, &pa.altq, sizeof(struct pf_altq));
				memcpy(&node->qstats_last, &node->qstats,
				    sizeof(struct altq_stats));
				memcpy(&node->qstats, &qstats,
				    sizeof(qstats));
				node->visited = 1;
			} else {
				pfctl_insert_altq_node(root, pa.altq, qstats);
				*inserts = 1;
			}
		}
		else
			--num_altqs;
	}

	pfctl_set_next_flat(*root, NULL);

	return (ret);
}

void
pfctl_free_altq_node(struct pf_altq_node *node)
{
	while (node != NULL) {
		struct pf_altq_node	*prev;

		if (node->children != NULL)
			pfctl_free_altq_node(node->children);
		prev = node;
		node = node->next;
		free(prev);
	}
}

void
pfctl_mark_all_unvisited(struct pf_altq_node *root)
{
 	if (root != NULL) {
		struct pf_altq_node	*node = root;
		while (node != NULL) {
		        node->visited = 0;
		        node = node->next_flat;
		}
	}
}

int
pfctl_have_unvisited(struct pf_altq_node *root)
{
 	if (root == NULL)
 		return(0);
 	else {
		struct pf_altq_node	*node = root;
		while (node != NULL) {
		        if (node->visited == 0)
		        	return(1);
			node = node->next_flat;
		}
		return(0);
	}
}

struct pf_altq_node	*altq_root = NULL;

int
d1579 1
a1579 1
	num_disp = num_queues + num_altqs;
d1589 1
a1589 5
	num_disp = num_altqs = num_queues = 0;

	pfctl_mark_all_unvisited(altq_root);
	if (pfctl_update_altqstats(&altq_root, &inserts))
		return (-1);
d1597 1
a1597 15
	
	/* Allow inserts only on first read;
	 * on subsequent reads clear and reload
	 */
	if (first_read == 0 &&
	    (inserts != 0 || pfctl_have_unvisited(altq_root) != 0)) {
		pfctl_free_altq_node(altq_root);
		altq_root = NULL;
		first_read = 1;
		if (pfctl_update_altqstats(&altq_root, &inserts))
			return (-1);
	}
	
	first_read = 0;
	num_disp = num_queues + num_altqs;
a1630 102
#define DEFAULT_PRIORITY	1

void
print_altqueue(struct pf_altq_node *node)
{
	u_int8_t d;
	double	interval, pps, bps;
	pps = bps = 0;

	tb_start();
	for (d = 0; d < node->depth; d++)
		tbprintf(" ");
	tbprintf(node->altq.qname);
	print_fld_tb(FLD_QUEUE);

	if (node->altq.scheduler == ALTQT_CBQ ||
	    node->altq.scheduler == ALTQT_HFSC
		)
		print_fld_bw(FLD_BANDW, (double)node->altq.bandwidth);
	
	if (node->altq.priority != DEFAULT_PRIORITY)
		print_fld_uint(FLD_PRIO,
			       node->altq.priority);
	
	if (node->qstats.valid && node->qstats_last.valid)
		interval = calc_interval(&node->qstats.timestamp,
					 &node->qstats_last.timestamp);
	else
		interval = 0;

	switch (node->altq.scheduler) {
	case ALTQT_CBQ:
		print_fld_str(FLD_SCHED, "cbq");
		print_fld_size(FLD_PKTS,
			       node->qstats.data.cbq_stats.xmit_cnt.packets);
		print_fld_size(FLD_BYTES,
			       node->qstats.data.cbq_stats.xmit_cnt.bytes);
		print_fld_size(FLD_DROPP,
			       node->qstats.data.cbq_stats.drop_cnt.packets);
		print_fld_size(FLD_DROPB,
			       node->qstats.data.cbq_stats.drop_cnt.bytes);
		print_fld_size(FLD_QLEN, node->qstats.data.cbq_stats.qcnt);
		print_fld_size(FLD_BORR, node->qstats.data.cbq_stats.borrows);
		print_fld_size(FLD_SUSP, node->qstats.data.cbq_stats.delays);
		if (interval > 0) {
			pps = calc_pps(node->qstats.data.cbq_stats.xmit_cnt.packets,
				       node->qstats_last.data.cbq_stats.xmit_cnt.packets, interval);
			bps = calc_rate(node->qstats.data.cbq_stats.xmit_cnt.bytes,
					node->qstats_last.data.cbq_stats.xmit_cnt.bytes, interval);
		}
		break;
	case ALTQT_PRIQ:
		print_fld_str(FLD_SCHED, "priq");
		print_fld_size(FLD_PKTS,
			       node->qstats.data.priq_stats.xmitcnt.packets);
		print_fld_size(FLD_BYTES,
			       node->qstats.data.priq_stats.xmitcnt.bytes);
		print_fld_size(FLD_DROPP,
			       node->qstats.data.priq_stats.dropcnt.packets);
		print_fld_size(FLD_DROPB,
			       node->qstats.data.priq_stats.dropcnt.bytes);
		print_fld_size(FLD_QLEN, node->qstats.data.priq_stats.qlength);
		if (interval > 0) {
			pps = calc_pps(node->qstats.data.priq_stats.xmitcnt.packets,
				       node->qstats_last.data.priq_stats.xmitcnt.packets, interval);
			bps = calc_rate(node->qstats.data.priq_stats.xmitcnt.bytes,
					node->qstats_last.data.priq_stats.xmitcnt.bytes, interval);
		}
		break;
	case ALTQT_HFSC:
		print_fld_str(FLD_SCHED, "hfsc");
		print_fld_size(FLD_PKTS,
				node->qstats.data.hfsc_stats.xmit_cnt.packets);
		print_fld_size(FLD_BYTES,
				node->qstats.data.hfsc_stats.xmit_cnt.bytes);
		print_fld_size(FLD_DROPP,
				node->qstats.data.hfsc_stats.drop_cnt.packets);
		print_fld_size(FLD_DROPB,
				node->qstats.data.hfsc_stats.drop_cnt.bytes);
		print_fld_size(FLD_QLEN, node->qstats.data.hfsc_stats.qlength);
		if (interval > 0) {
			pps = calc_pps(node->qstats.data.hfsc_stats.xmit_cnt.packets,
					node->qstats_last.data.hfsc_stats.xmit_cnt.packets, interval);
			bps = calc_rate(node->qstats.data.hfsc_stats.xmit_cnt.bytes,
					node->qstats_last.data.hfsc_stats.xmit_cnt.bytes, interval);
		}
		break;
	}

	/* if (node->altq.scheduler != ALTQT_HFSC && interval > 0) { */
	if (node->altq.scheduler && interval > 0) {
		tb_start();
		if (pps > 0 && pps < 1)
			tbprintf("%-3.1lf", pps);
		else
			tbprintf("%u", (unsigned int) pps);
		
		print_fld_tb(FLD_PKTSPS);
		print_fld_bw(FLD_BYTESPS, bps);
	}
}

a1685 1
	struct pf_altq_node *altqnode = altq_root;
a1700 13
	}

	start -= n;
	for (n = 0; n < start; n++)
		altqnode = altqnode->next_flat;

	for (; n < num_altqs; n++) {
		print_altqueue(altqnode);
		altqnode = altqnode->next_flat;
		end_line();
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
@


1.22
log
@newqueue support for the queue view, code mostly from pfctl. lifting done
by Arto Jonsson <ajonsson at kapsi dot fi>, many thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.20 2011/10/13 18:32:30 claudio Exp $	 */
d1649 1
a1649 1
		while ((node = TAILQ_FIRST(&qnodes)) != NULL)
d1651 2
d1815 1
a1815 1
	while ((node = TAILQ_FIRST(&qnodes)) != NULL)
d1817 2
@


1.21
log
@adopt to queueing changes
@
text
@d49 2
d120 1
d309 1
a309 1
struct queue_stats {
d320 2
a321 2
	struct queue_stats	 qstats;
	struct queue_stats	 qstats_last;
d326 16
d1537 1
a1537 1
    const struct pf_altq altq, const struct queue_stats qstats)
d1591 92
d1684 1
a1684 1
pfctl_update_qstats(struct pf_altq_node **root, int *inserts)
d1690 1
a1690 1
	struct queue_stats	 qstats;
d1707 1
a1707 1
	num_queues = nr_queues = pa.nr;
d1720 2
a1721 2
			if (ioctl(pf_dev, DIOCGETQSTATS, &pq)) {
				error("DIOCGETQSTATS: %s", strerror(errno));
d1732 1
a1732 1
				    sizeof(struct queue_stats));
d1742 1
a1742 1
			--num_queues;
d1797 1
a1797 1
	num_disp = num_queues;
d1805 1
d1807 2
a1808 2
	num_disp = num_queues = 0;
	
d1810 6
a1815 1
	if (pfctl_update_qstats(&altq_root, &inserts))
d1826 1
a1826 1
		if (pfctl_update_qstats(&altq_root, &inserts))
d1831 1
a1831 1
	num_disp = num_queues;
d1868 1
a1868 1
print_queue(struct pf_altq_node *node)
d1968 51
d2021 18
a2038 2
	u_int32_t n, count = 0;
	struct pf_altq_node *node = altq_root;
d2040 3
a2042 2
	for (n = 0; n < dispstart; n++)
		node = node->next_flat;
d2044 3
a2046 3
	for (; n < num_disp; n++) {
		print_queue(node);
		node = node->next_flat;
d2048 1
a2048 1
		count ++;
@


1.20
log
@Teach some userland tools about NAT64. I think this is mostly from mikeb@@
OK mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.19 2011/04/05 15:07:46 sthen Exp $	 */
d1577 1
a1577 1
	struct pfioc_qstats	 pq;
@


1.19
log
@the tree builds better when you don't use PF_FASTROUTE
ok henning@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.18 2011/03/02 06:48:17 jasper Exp $	 */
d453 1
a453 1
	int af, ret, ii, io;
d455 1
a455 1
	af = s1->af;
d457 1
a457 1
	if (af > s2->af)
d459 1
a459 1
	if (af < s2->af)
d461 1
a461 1
	
d468 10
a477 2
	
	if (s1->direction == PF_IN) {
d480 10
d491 2
a492 2
		aa = &s1->key[PF_SK_WIRE].addr[io];
		pa =  s1->key[PF_SK_WIRE].port[io];
d495 1
a495 1
	if (s2->direction == PF_IN) {
d498 1
d500 3
a502 2
		ab = &s2->key[PF_SK_WIRE].addr[io];
		pb =  s2->key[PF_SK_WIRE].port[io];
d520 1
a520 3
	int af, ret, ii, io;

	af = s1->af;
d522 1
d524 1
a524 1
	if (af > s2->af)
d526 1
a526 1
	if (af < s2->af)
d528 1
a528 1
	
d535 10
a544 2
	
	if (s1->direction == PF_IN) {
d547 1
d549 3
a551 2
		aa = &s1->key[PF_SK_WIRE].addr[io];
		pa =  s1->key[PF_SK_WIRE].port[io];
d554 9
a562 1
	if (s2->direction == PF_IN) {
d565 1
d567 3
a569 2
		ab = &s2->key[PF_SK_WIRE].addr[io];
		pb =  s2->key[PF_SK_WIRE].port[io];
d764 1
a764 1
		struct pfsync_state_key *kn, int idx, int af)
d772 3
d784 1
a784 1
	tb_print_addr(as, NULL, af);
d786 1
a786 1
	if (af == AF_INET)
d793 1
a793 1
	if (PF_ANEQ(as, an, af) || ps != pn) {
d795 1
a795 1
		tb_print_addr(an, NULL, af);
d797 1
a797 1
		if (af == AF_INET)
d861 4
d866 1
a866 1
	if (s->direction == PF_OUT) {
d881 7
a887 5
	if (s->direction == PF_OUT) {
		print_fld_host2(FLD_SRC, &s->key[PF_SK_WIRE],
		    &s->key[PF_SK_STACK], 1, s->af);
		print_fld_host2(FLD_DEST, &s->key[PF_SK_WIRE],
		    &s->key[PF_SK_STACK], 0, s->af);
d890 1
a890 1
		    &s->key[PF_SK_WIRE], 0, s->af);
d892 1
a892 1
		    &s->key[PF_SK_WIRE], 1, s->af);
d895 1
a895 1
	if (s->direction == PF_OUT)
@


1.18
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.17 2011/02/06 05:20:25 lum Exp $	 */
a1355 2
		if (pr->rt != PF_FASTROUTE)
			tbprintf("... ");
@


1.17
log
@Remove duplicated prototypes.
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pftop.c,v 1.16 2010/10/28 16:08:10 deraadt Exp $	 */
a166 2
#define FIELD_ADDR(x) (&fields[x])

d168 6
a173 6
#define FLD_SRC     FIELD_ADDR(0)
#define FLD_DEST    FIELD_ADDR(1)
#define FLD_GW      FIELD_ADDR(2)
#define FLD_STATE   FIELD_ADDR(3)
#define FLD_AGE     FIELD_ADDR(4)
#define FLD_EXP     FIELD_ADDR(5)
d175 5
a179 5
#define FLD_PROTO   FIELD_ADDR(6)
#define FLD_DIR     FIELD_ADDR(7)
#define FLD_PKTS    FIELD_ADDR(8)
#define FLD_BYTES   FIELD_ADDR(9)
#define FLD_RULE    FIELD_ADDR(10)
d181 10
a190 10
#define FLD_LABEL   FIELD_ADDR(11)
#define FLD_STATS   FIELD_ADDR(12)
#define FLD_EVAL    FIELD_ADDR(13)
#define FLD_ACTION  FIELD_ADDR(14)
#define FLD_LOG     FIELD_ADDR(15)
#define FLD_QUICK   FIELD_ADDR(16)
#define FLD_KST     FIELD_ADDR(17)
#define FLD_IF      FIELD_ADDR(18)
#define FLD_RINFO   FIELD_ADDR(19)
#define FLD_STMAX   FIELD_ADDR(20)
d192 4
a195 4
#define FLD_SI      FIELD_ADDR(21)    /* instantaneous speed */
#define FLD_SA      FIELD_ADDR(22)    /* average speed */
#define FLD_SP      FIELD_ADDR(23)    /* peak speed */
#define FLD_ANCHOR  FIELD_ADDR(24)
d197 11
a207 11
#define FLD_QUEUE   FIELD_ADDR(25)
#define FLD_BANDW   FIELD_ADDR(26)
#define FLD_SCHED   FIELD_ADDR(27)
#define FLD_PRIO    FIELD_ADDR(28)
#define FLD_DROPP   FIELD_ADDR(29)
#define FLD_DROPB   FIELD_ADDR(30)
#define FLD_QLEN    FIELD_ADDR(31)
#define FLD_BORR    FIELD_ADDR(32)
#define FLD_SUSP    FIELD_ADDR(33)
#define FLD_PKTSPS  FIELD_ADDR(34)
#define FLD_BYTESPS FIELD_ADDR(35)
@


1.16
log
@cleanup ;;
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.15 2010/07/22 12:33:29 giovanni Exp $	 */
a89 3

int print_header(void);
int keyboard_callback(int ch);
@


1.15
log
@
Let systat -N states resolve network addresses
help and ok sthen@@ lum@@
ok canacar@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.14 2009/11/23 21:30:14 henning Exp $	 */
d483 1
a483 1
		ab = &s2->key[PF_SK_STACK].addr[ii];;
d486 1
a486 1
		ab = &s2->key[PF_SK_WIRE].addr[io];;
d531 1
a531 1
		ab = &s2->key[PF_SK_STACK].addr[ii];;
d534 1
a534 1
		ab = &s2->key[PF_SK_WIRE].addr[io];;
@


1.14
log
@no more natpass
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.13 2009/07/14 17:58:14 jsg Exp $	 */
d711 10
a720 5
	static char buf[48];
	const char *bf;

	bf = inet_ntop(af, addr, buf, sizeof(buf));
	tbprintf("%s", bf);
@


1.13
log
@use static for inline so compilers with c99 inline semantics
generate the same linkage as those with c89 semantics.

ok sthen@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.12 2009/06/10 03:42:58 canacar Exp $	 */
a1337 3

	if (pr->natpass)
		tbprintf("pass ");
@


1.12
log
@Revert part of the earlier commit that displayed garbage instead of
the action column values. reported by jmc@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.11 2009/04/23 12:58:44 henning Exp $	 */
d452 1
a452 1
__inline int
d499 1
a499 1
__inline int
@


1.11
log
@sync actiontypes (pass, block etc) with pfvar so that match rules are
displayed correctly (actually thsi was out of sync for more than just match)
From: Craig Barraclough <craigba at afnsecurity dot com>
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.10 2009/04/06 12:08:26 henning Exp $	 */
d1312 1
a1312 2
		printf("%u ", pr->action);
/*	if (pr->action >= numact)
d1315 1
a1315 1
*/
@


1.10
log
@scrub rules gone
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.9 2009/04/04 03:29:53 canacar Exp $	 */
d1270 3
a1272 2
	static const char *actiontypes[] = { "Pass", "Block", "Scrub", "Nat",
	    "no Nat", "Binat", "no Binat", "Rdr", "no Rdr" };
d1312 2
a1313 1
	if (pr->action >= numact)
d1316 1
a1316 1

@


1.9
log
@Fix the byte order of the rule field in state view.
Reported by Kamil Mielcarek
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.8 2009/01/01 22:50:39 mcbride Exp $	 */
d1413 1
a1413 17
	if (pr->action == PF_SCRUB) {
#ifdef PFRULE_REASSEMBLE_TCP
		if (pr->rule_flag & PFRULE_REASSEMBLE_TCP)
			tbprintf("reassemble tcp ");
#endif
#ifdef PFRULE_FRAGDROP
		if (pr->rule_flag & PFRULE_FRAGDROP)
			tbprintf("fragment drop-ovl ");
		else
#endif
#ifdef PFRULE_FRAGCROP
		if (pr->rule_flag & PFRULE_FRAGCROP)
			tbprintf("fragment crop ");
		else
#endif
			tbprintf("fragment reassemble ");
	}
@


1.8
log
@Unclutter 'systate rules' by printing the flags option using the minimal
pf.conf syntax (flags S/SA is implicit).

ok henning canacar
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.7 2008/11/05 15:48:44 canacar Exp $	 */
d864 1
a864 1
	print_fld_uint(FLD_RULE, s->rule);
@


1.7
log
@Fix some function prototypes, remove unused variables and commented out code
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.6 2008/10/08 15:11:13 canacar Exp $	 */
d39 1
d1378 10
a1387 5
	if (pr->flags || pr->flagset) {
		tbprintf(" flags ");
		tb_print_flags(pr->flags);
		tbprintf("/");
		tb_print_flags(pr->flagset);
@


1.6
log
@Fix the order of traversal when printing the queues. Properly places
child queues under their respective interface root queues. Reported
by jared r r spiegel via PR 5861.
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.5 2008/09/01 23:30:08 sthen Exp $	 */
d97 2
d1584 1
a1584 1
				// update altq data too as bandwidth may have changed
d1667 3
a1669 2
	// Allow inserts only on first read;
	// on subsequent reads clear and reload
d1838 1
a1838 1
update_cache()
d1857 1
a1857 1
void
d1887 2
@


1.5
log
@Display direction In/Out/Any for rule display, not just In/Out.
ok canacar@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.4 2008/07/16 10:23:39 canacar Exp $	 */
d61 1
d1520 13
a1532 6
	if (*root != node) {
		struct pf_altq_node	*prev_flat = *root;
		while (prev_flat->next_flat != NULL) {
			prev_flat = prev_flat->next_flat;
		}
		prev_flat->next_flat = node;
d1545 1
d1559 1
d1565 2
a1566 1
			return (-1);
d1575 2
a1576 1
				return (-1);
d1597 4
a1600 1
	return (0);
@


1.4
log
@Cleanup #define maze leftover from pftop compatibility.
Pointed out by mcbride@@, makes sense henning@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.3 2008/06/29 08:42:15 mcbride Exp $	 */
d1284 7
a1290 1
	print_fld_str(FLD_DIR, pr->direction == PF_OUT ? "Out" : "In");
@


1.3
log
@Simplify state creation code; merge state import/export code between pfsync
and the state-related pf(4) ioctls, and make functions in state creation and
destruction paths more robust in error conditions.

All values in struct pfsync_state now in network byte order, as with pfsync.

testing by david
ok henning, systat parts ok canacar
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.2 2008/06/13 23:47:17 canacar Exp $	 */
a32 2
#include "config.h"

a42 1
#ifdef HAVE_ALTQ
a46 1
#endif
a70 24
#ifndef HAVE_PROTO_NAMES
/* UDP state enumeration */
#define PFUDPS_NSTATES		3	/* number of state levels */

#define PFUDPS_NAMES { \
	"NO TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}

/* Other protocol state enumeration */
#define PFOTHERS_NSTATES	3	/* number of state levels */

#define PFOTHERS_NAMES { \
	"NO TRAFFIC", \
	"SINGLE", \
	"MULTIPLE", \
	NULL \
}
#endif

#ifdef HAVE_ADDR_WRAP
#ifdef HAVE_ADDR_TYPE
a72 6
#else
#define PT_ADDR(x) (&(x)->addr.addr)
#endif
#else
#define PT_ADDR(x) (&(x)->addr)
#endif
a73 2
#ifdef HAVE_ADDR_MASK
#ifdef HAVE_ADDR_TYPE
a75 6
#else
#define PT_MASK(x) (&(x)->addr.mask)
#endif
#else
#define PT_MASK(x) (&(x)->mask)
#endif
a76 2
#ifdef HAVE_STATE_NOROUTE
#ifdef HAVE_ADDR_TYPE
a77 6
#else
#define PT_NOROUTE(x) ((x)->noroute)
#endif
#else
#define PT_NOROUTE(x) (0)
#endif
a91 1
#ifdef HAVE_ALTQ
a94 1
#endif
d110 1
a110 1
pf_state_t *state_buf = NULL;
a121 4
#ifndef HAVE_RULE_LABELS
#define PF_RULE_LABEL_SIZE 20
#endif

d147 1
a147 1
	{"MAX", 3, 5, 2, FLD_ALIGN_RIGHT, -1, 0, FLD_FLAG_HIDDEN, 0},
d151 1
a151 1
	{"ANCHOR", 6, 16, 1, FLD_ALIGN_LEFT, -1, 0, FLD_FLAG_HIDDEN, 0},
a285 1
#ifdef HAVE_ALTQ
a289 1
#endif
a300 1
#ifdef HAVE_ALTQ
a322 1
#endif /* HAVE_ALTQ */
a329 1
#ifdef HAVE_INOUT_COUNT
a333 4
#else
	u_int64_t b1 = COUNTER(state_buf[* (u_int32_t *) s1].bytes);
	u_int64_t b2 = COUNTER(state_buf[* (u_int32_t *) s2].bytes);
#endif
a343 1
#ifdef HAVE_INOUT_COUNT
a347 4
#else
	u_int64_t p1 = COUNTER(state_buf[* (u_int32_t *) s1].packets);
	u_int64_t p2 = COUNTER(state_buf[* (u_int32_t *) s2].packets);
#endif
d448 3
a450 8
#ifdef HAVE_PFSYNC_KEY

#ifdef __GNUC__
__inline__
#endif
int
sort_addr_callback(const pf_state_t *s1,
		   const pf_state_t *s2, int dir)
d495 3
a497 6
#ifdef __GNUC__
__inline__
#endif
int
sort_port_callback(const pf_state_t *s1,
		   const pf_state_t *s2, int dir)
a545 5
#else	/* HAVE_PFSYNC_KEY */

#ifdef __GNUC__
__inline__
#endif
d547 1
a547 2
sort_addr_callback(const pf_state_t *s1,
		   const pf_state_t *s2, int dir)
d549 3
a551 29
	const pf_state_host_t *a, *b;
	int af, ret;

	af = s1->af;

	if (af > s2->af)
		return sortdir;
	if (af < s2->af)
		return -sortdir;
	
	if (s1->direction == dir) {
		a = &s1->lan;
	} else {
		a = &s1->ext;
	}

	if (s2->direction == dir) {
		b = &s2->lan;
	} else {
		b = &s2->ext;
	}

	ret = compare_addr(af, &a->addr, &b->addr);
	if (ret)
		return ret * sortdir;

	if (ntohs(a->port) > ntohs(b->port))
		return sortdir;
	return -sortdir;
a553 3
#ifdef __GNUC__
__inline__
#endif
d555 1
a555 37
sort_port_callback(const pf_state_t *s1,
		   const pf_state_t *s2, int dir)
{
	const pf_state_host_t *a, *b;
	int af;

	af = s1->af;

	if (af > s2->af)
		return sortdir;
	if (af < s2->af)
		return -sortdir;
	
	if (s1->direction == dir) {
		a = &s1->lan;
	} else {
		a = &s1->ext;
	}

	if (s2->direction == dir) {
		b = &s2->lan;
	} else {
		b = &s2->ext;
	 }

	if (ntohs(a->port) > ntohs(b->port))
		return sortdir;
	if (ntohs(a->port) < ntohs(b->port))
		return -sortdir;

	if (compare_addr(af, &a->addr, &b->addr) > 0)
		return sortdir;
	return -sortdir;
}
#endif	/* HAVE_PFSYNC_KEY */

int sort_sa_callback(const void *p1, const void *p2)
d557 2
a558 9
	pf_state_t *s1 = state_buf + (* (u_int32_t *) p1);
	pf_state_t *s2 = state_buf + (* (u_int32_t *) p2);
	return sort_addr_callback(s1, s2, PF_OUT);
}

int sort_da_callback(const void *p1, const void *p2)
{
	pf_state_t *s1 = state_buf + (* (u_int32_t *) p1);
	pf_state_t *s2 = state_buf + (* (u_int32_t *) p2);
d565 2
a566 2
	pf_state_t *s1 = state_buf + (* (u_int32_t *) p1);
	pf_state_t *s2 = state_buf + (* (u_int32_t *) p2);
d573 2
a574 2
	pf_state_t *s1 = state_buf + (* (u_int32_t *) p1);
	pf_state_t *s2 = state_buf + (* (u_int32_t *) p2);
d614 1
a614 1
		state_buf = realloc(state_buf, len * sizeof(pf_state_t));
d642 1
a642 1
		int sbytes = state_buf_len * sizeof(pf_state_t);
d650 1
a650 1
		num_states_all = ps.ps_len / sizeof(pf_state_t);
d718 1
a718 1
#ifdef HAVE_PFSYNC_KEY
a758 25
#else
void
print_fld_host(field_def *fld, pf_state_host_t * h, int af)
{
	u_int16_t p = ntohs(h->port);

	if (fld == NULL)
		return;

	if (fld->width < 3) {
		print_fld_str(fld, "*");
		return;
	}

	tb_start();
	tb_print_addr(&h->addr, NULL, af);

	if (af == AF_INET)
		tbprintf(":%u", p);
	else
		tbprintf("[%u]", p);

	print_fld_tb(fld);
}
#endif
d810 1
a810 1
print_state(pf_state_t * s, struct sc_ent * ent)
d812 1
a812 1
	pf_state_peer_t *src, *dst;
d814 1
a830 1
#ifdef HAVE_PFSYNC_KEY
a841 14
#else
	if (s->direction == PF_OUT) {
		print_fld_host(FLD_SRC, &s->lan, s->af);
		print_fld_host(FLD_DEST, &s->ext, s->af);
	} else {
		print_fld_host(FLD_SRC, &s->ext, s->af);
		print_fld_host(FLD_DEST, &s->lan, s->af);
	}

	if (PF_ANEQ(&s->lan.addr, &s->gwy.addr, s->af) ||
	    (s->lan.port != s->gwy.port)) {
		print_fld_host(FLD_GW, &s->gwy, s->af);
	}
#endif
d851 6
a856 13
#ifdef HAVE_INOUT_COUNT
	{
		u_int64_t sz = COUNTER(s->bytes[0]) + COUNTER(s->bytes[1]);

		print_fld_size(FLD_PKTS, COUNTER(s->packets[0]) +
			       COUNTER(s->packets[1]));
		print_fld_size(FLD_BYTES, sz);
		print_fld_rate(FLD_SA, (s->creation) ?
			       ((double)sz/ntohl((double)s->creation)) : -1);
	}
#else
	print_fld_size(FLD_PKTS, s->packets);
	print_fld_size(FLD_BYTES, s->bytes);
d858 1
a858 1
		       ((double)s->bytes/ntohl((double)s->creation)) : -1);
a859 2
#endif
#ifdef HAVE_PFSYNC_STATE
a860 5
#else
#ifdef HAVE_RULE_NUMBER
	print_fld_uint(FLD_RULE, s->rule.nr);
#endif
#endif
a916 1
#ifdef HAVE_RULE_LABELS
a917 1
#endif
d924 1
a929 1
#ifdef HAVE_RULESETS
d931 1
a931 1
#endif
a946 1
#ifdef HAVE_RULESETS
d950 3
a952 8
#endif
#ifdef HAVE_RULE_LABELS
		{
			int len = strlen(pr.rule.label);
			if (len > label_length)
				label_length = len;
		}
#endif
a958 1
#ifdef HAVE_RULESETS
a1092 1
#endif
d1097 1
a1097 1
	int ret;
a1102 1
#ifdef HAVE_RULE_LABELS
a1103 1
#endif
a1104 1
#ifdef HAVE_RULESETS
a1107 3
#else
	ret = read_anchor_rules(NULL);
#endif
d1109 10
a1118 14
#ifdef HAVE_RULE_LABELS
	{
		int nw, mw;
		nw = mw = label_length;
		if (nw > 16)
			nw = 16;

		if (FLD_LABEL->norm_width != nw || 
		    FLD_LABEL->max_width != mw) {
			FLD_LABEL->norm_width = nw;
			FLD_LABEL->max_width = mw;
			field_setup();
			need_update = 1;
		}
a1119 1
#endif
a1124 1
#ifdef HAVE_ADDR_WRAP
a1127 1
#ifdef HAVE_ADDR_TYPE
a1144 6
#else
	if (addr->addr_dyn != NULL)
		tbprintf("(%s)", addr->addr.pfa.ifname);
	else
		tb_print_addr(&addr->addr, mask, af);
#endif
a1145 1
#endif
a1153 1
#ifdef HAVE_OP_RRG
a1155 1
#endif
a1206 1
#ifdef HAVE_NEG
a1207 3
#else
			if (src->not)
#endif
a1208 1
#ifdef HAVE_ADDR_WRAP
a1209 3
#else
			tb_print_addr(&src->addr, PT_MASK(src), af);
#endif
a1223 1
#ifdef HAVE_NEG
a1224 3
#else
			if (dst->not)
#endif
a1225 1
#ifdef HAVE_ADDR_WRAP
a1226 3
#else
			tb_print_addr(&dst->addr, PT_MASK(dst), af);
#endif
a1235 1
#ifdef HAVE_RULE_UGID
a1250 1
#endif
a1269 1
#ifdef HAVE_PF_ROUTE
a1273 1
#endif
a1276 1
#ifdef HAVE_RULE_LABELS
a1277 3
#endif
#ifdef HAVE_RULE_STATES
#ifdef HAVE_PFSYNC_KEY
a1278 4
#else
	print_fld_size(FLD_STATS, pr->states);
#endif
#endif
a1279 1
#ifdef HAVE_INOUT_COUNT_RULES
d1282 1
a1282 4
#else
	print_fld_size(FLD_PKTS, pr->packets);
	print_fld_size(FLD_BYTES, pr->bytes);
#endif
a1315 1
#ifdef HAVE_RULE_IFNOT
a1317 1
#endif
a1320 1
#ifdef HAVE_MAX_STATES
d1323 1
a1323 1
#endif
a1327 1
#ifdef HAVE_RULE_NATPASS
d1330 1
a1330 1
#endif
a1345 1
#ifdef HAVE_PF_ROUTE
d1351 1
a1351 1
#endif
d1360 1
a1360 1
#ifdef HAVE_RULE_UGID
a1366 1
#endif
a1376 1
#ifdef HAVE_RULE_TOS
a1378 1
#endif
a1392 1
#ifdef HAVE_MAX_MSS
a1394 1
#endif
a1415 1
#ifdef HAVE_ALTQ	
d1420 1
a1420 2
#endif
#ifdef HAVE_TAGS
d1428 1
a1428 1
#endif
a1430 1
#ifdef HAVE_RULESETS
a1432 1
#endif
a1452 2
#ifdef HAVE_ALTQ

a1810 2
#endif /* HAVE_ALTQ */

a1860 1
#ifdef HAVE_MAX_STATES
a1861 2
#endif
#ifdef HAVE_RULESETS
a1862 2
#endif

@


1.2
log
@Do not print a warning if /dev/pf can not be opened.
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.1 2008/06/12 22:26:01 canacar Exp $	 */
d428 2
a429 2
	if (state_buf[* (u_int32_t *) s2].creation >
	    state_buf[* (u_int32_t *) s1].creation)
d431 2
a432 2
	if (state_buf[* (u_int32_t *) s2].creation <
	    state_buf[* (u_int32_t *) s1].creation)
d440 2
a441 2
	if (state_buf[* (u_int32_t *) s2].expire >
	    state_buf[* (u_int32_t *) s1].expire)
d443 2
a444 2
	if (state_buf[* (u_int32_t *) s2].expire <
	    state_buf[* (u_int32_t *) s1].expire)
d1044 2
a1045 2
	print_fld_age(FLD_AGE, s->creation);
	print_fld_age(FLD_EXP, s->expire);
d1053 2
a1054 2
		print_fld_rate(FLD_SA, (s->creation > 0) ?
			       ((double)sz/(double)s->creation) : -1);
d1059 2
a1060 2
	print_fld_rate(FLD_SA, (s->creation > 0) ?
		       ((double)s->bytes/(double)s->creation) : -1);
@


1.1
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/* $Id: pftop.c,v 1.92 2008/06/12 01:39:32 canacar Exp $	 */
a2137 1
		warn("open(\"/dev/pf\")");
@

