head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2016.03.12.12.45.27;	author sthen;	state Exp;
branches;
next	1.10;
commitid	Ipk6iXXruFGtRHYt;

1.10
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	waQzIVMqUqjBDjYt;

1.9
date	2014.10.08.04.10.04;	author doug;	state Exp;
branches;
next	1.8;
commitid	cpW0LtZf9XzHlFrl;

1.8
date	2014.08.14.08.10.30;	author mpi;	state Exp;
branches;
next	1.7;
commitid	P2Yi9etIKcIRvYPW;

1.7
date	2014.07.02.00.12.34;	author dlg;	state Exp;
branches;
next	1.6;
commitid	zNbAzxmEBZMksTSx;

1.6
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.31.05.37.24;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.07.07.46.05;	author canacar;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.05.16.03.02;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.07.14.16;	author canacar;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.06.23.28;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Use 12 chars for pool name in "systat pool" to match vmstat -m.  ok stefan@@
@
text
@/*	$OpenBSD: pool.c,v 1.10 2015/01/16 00:03:37 deraadt Exp $	*/
/*
 * Copyright (c) 2008 Can Erkin Acar <canacar@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/signal.h>
#include <sys/sysctl.h>
#include <sys/pool.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "systat.h"

void print_pool(void);
int  read_pool(void);
void  sort_pool(void);
int  select_pool(void);
void showpool(int k);
int pool_keyboard_callback(int);

/* qsort callbacks */
int sort_name_callback(const void *s1, const void *s2);
int sort_req_callback(const void *s1, const void *s2);
int sort_psize_callback(const void *s1, const void *s2);
int sort_npage_callback(const void *s1, const void *s2);

struct pool_info {
	char name[32];
	struct kinfo_pool pool;
};


int print_all = 0;
int num_pools = 0;
struct pool_info *pools = NULL;


field_def fields_pool[] = {
	{"NAME", 12, 32, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"SIZE", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"REQUESTS", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"FAIL", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"INUSE", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"PGREQ", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"PGREL", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"NPAGE", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"HIWAT", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"MINPG", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"MAXPG", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"IDLE", 8, 24, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0}
};


#define FLD_POOL_NAME	FIELD_ADDR(fields_pool,0)
#define FLD_POOL_SIZE	FIELD_ADDR(fields_pool,1)
#define FLD_POOL_REQS	FIELD_ADDR(fields_pool,2)
#define FLD_POOL_FAIL	FIELD_ADDR(fields_pool,3)
#define FLD_POOL_INUSE	FIELD_ADDR(fields_pool,4)
#define FLD_POOL_PGREQ	FIELD_ADDR(fields_pool,5)
#define FLD_POOL_PGREL	FIELD_ADDR(fields_pool,6)
#define FLD_POOL_NPAGE	FIELD_ADDR(fields_pool,7)
#define FLD_POOL_HIWAT	FIELD_ADDR(fields_pool,8)
#define FLD_POOL_MINPG	FIELD_ADDR(fields_pool,9)
#define FLD_POOL_MAXPG	FIELD_ADDR(fields_pool,10)
#define FLD_POOL_IDLE	FIELD_ADDR(fields_pool,11)

/* Define views */
field_def *view_pool_0[] = {
	FLD_POOL_NAME, FLD_POOL_SIZE, FLD_POOL_REQS, FLD_POOL_FAIL,
	FLD_POOL_INUSE, FLD_POOL_PGREQ, FLD_POOL_PGREL, FLD_POOL_NPAGE,
	FLD_POOL_HIWAT, FLD_POOL_MINPG, FLD_POOL_MAXPG, FLD_POOL_IDLE, NULL
};

order_type pool_order_list[] = {
	{"name", "name", 'N', sort_name_callback},
	{"requests", "requests", 'Q', sort_req_callback},
	{"size", "size", 'Z', sort_psize_callback},
	{"npages", "npages", 'P', sort_npage_callback},
	{NULL, NULL, 0, NULL}
};

/* Define view managers */
struct view_manager pool_mgr = {
	"Pool", select_pool, read_pool, sort_pool, print_header,
	print_pool, pool_keyboard_callback, pool_order_list, pool_order_list
};

field_view views_pool[] = {
	{view_pool_0, "pool", '5', &pool_mgr},
	{NULL, NULL, 0, NULL}
};


int
sort_name_callback(const void *s1, const void *s2)
{
	struct pool_info *p1, *p2;
	p1 = (struct pool_info *)s1;
	p2 = (struct pool_info *)s2;

	return strcmp(p1->name, p2->name) * sortdir;
}

int
sort_req_callback(const void *s1, const void *s2)
{
	struct pool_info *p1, *p2;
	p1 = (struct pool_info *)s1;
	p2 = (struct pool_info *)s2;

	if (p1->pool.pr_nget <  p2->pool.pr_nget)
		return sortdir;
	if (p1->pool.pr_nget >  p2->pool.pr_nget)
		return -sortdir;

	return sort_name_callback(s1, s2);
}

int
sort_npage_callback(const void *s1, const void *s2)
{
	struct pool_info *p1, *p2;
	p1 = (struct pool_info *)s1;
	p2 = (struct pool_info *)s2;

	if (p1->pool.pr_npages <  p2->pool.pr_npages)
		return sortdir;
	if (p1->pool.pr_npages >  p2->pool.pr_npages)
		return -sortdir;

	return sort_name_callback(s1, s2);
}

int
sort_psize_callback(const void *s1, const void *s2)
{
	struct pool_info *p1, *p2;
	size_t ps1, ps2;

	p1 = (struct pool_info *)s1;
	p2 = (struct pool_info *)s2;

	ps1  = (size_t)(p1->pool.pr_nget - p1->pool.pr_nput) *
	    (size_t)p1->pool.pr_size;
	ps2  = (size_t)(p2->pool.pr_nget - p2->pool.pr_nput) *
	    (size_t)p2->pool.pr_size;

	if (ps1 <  ps2)
		return sortdir;
	if (ps1 >  ps2)
		return -sortdir;

	return sort_npage_callback(s1, s2);
}

void
sort_pool(void)
{
	order_type *ordering;

	if (curr_mgr == NULL)
		return;

	ordering = curr_mgr->order_curr;

	if (ordering == NULL)
		return;
	if (ordering->func == NULL)
		return;
	if (pools == NULL)
		return;
	if (num_pools <= 0)
		return;

	mergesort(pools, num_pools, sizeof(struct pool_info), ordering->func);
}

int
select_pool(void)
{
	num_disp = num_pools;
	return (0);
}

int
read_pool(void)
{
	int mib[4], np, i;
	size_t size;

	mib[0] = CTL_KERN;
	mib[1] = KERN_POOL;
	mib[2] = KERN_POOL_NPOOLS;
	size = sizeof(np);

	if (sysctl(mib, 3, &np, &size, NULL, 0) < 0) {
		error("sysctl(npools): %s", strerror(errno));
		return (-1);
	}

	if (np <= 0) {
		num_pools = 0;
		return (0);
	}

	if (np > num_pools || pools == NULL) {
		struct pool_info *p = reallocarray(pools, np, sizeof(*pools));
		if (p == NULL) {
			error("realloc: %s", strerror(errno));
			return (-1);
		}
		pools = p;
		num_pools = np;
	}

	num_disp = num_pools;

	for (i = 0; i < num_pools; i++) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_POOL;
		mib[2] = KERN_POOL_POOL;
		mib[3] = i + 1;
		size = sizeof(pools[i].pool);
		if (sysctl(mib, 4, &pools[i].pool, &size, NULL, 0) < 0) {
			memset(&pools[i], 0, sizeof(pools[i]));
			num_disp--;
			continue;
		}
		mib[2] = KERN_POOL_NAME;
		size = sizeof(pools[i].name);
		if (sysctl(mib, 4, &pools[i].name, &size, NULL, 0) < 0) {
			snprintf(pools[i].name, size, "#%d#", mib[3]);
		}
	}

	if (i != num_pools) {
		memset(pools, 0, sizeof(*pools) * num_pools);
		return (-1);
	}

	return 0;
}


void
print_pool(void)
{
	struct pool_info *p;
	int i, n, count = 0;

	if (pools == NULL)
		return;

	for (n = i = 0; i < num_pools; i++) {
		p = &pools[i];
		if (p->name[0] == 0)
			continue;

		if (!print_all &&
		   (p->pool.pr_nget == 0 && p->pool.pr_npagealloc == 0))
			continue;

		if (n++ < dispstart)
			continue;
		showpool(i);
		count++;
		if (maxprint > 0 && count >= maxprint)
			break;
	}
}

int
initpool(void)
{
	field_view *v;

	for (v = views_pool; v->name != NULL; v++)
		add_view(v);

	read_pool();

	return(0);
}

void
showpool(int k)
{
	struct pool_info *p = pools + k;

	if (k < 0 || k >= num_pools)
		return;

	print_fld_str(FLD_POOL_NAME, p->name);
	print_fld_uint(FLD_POOL_SIZE, p->pool.pr_size);

	print_fld_size(FLD_POOL_REQS, p->pool.pr_nget);
	print_fld_size(FLD_POOL_FAIL, p->pool.pr_nfail);
	print_fld_ssize(FLD_POOL_INUSE, p->pool.pr_nget - p->pool.pr_nput);
	print_fld_size(FLD_POOL_PGREQ, p->pool.pr_npagealloc);
	print_fld_size(FLD_POOL_PGREL, p->pool.pr_npagefree);

	print_fld_size(FLD_POOL_NPAGE, p->pool.pr_npages);
	print_fld_size(FLD_POOL_HIWAT, p->pool.pr_hiwat);
	print_fld_size(FLD_POOL_MINPG, p->pool.pr_minpages);

	if (p->pool.pr_maxpages == UINT_MAX)
		print_fld_str(FLD_POOL_MAXPG, "inf");
	else
		print_fld_size(FLD_POOL_MAXPG, p->pool.pr_maxpages);

	print_fld_size(FLD_POOL_IDLE, p->pool.pr_nidle);

	end_line();
}

int
pool_keyboard_callback(int ch)
{
	switch (ch) {
	case 'A':
		print_all ^= 1;
		gotsig_alarm = 1;
	default:
		return keyboard_callback(ch);
	};

	return (1);
}
@


1.10
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.9 2014/10/08 04:10:04 doug Exp $	*/
d54 1
a54 1
	{"NAME", 11, 32, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
@


1.9
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.8 2014/08/14 08:10:30 mpi Exp $	*/
d19 1
a19 1
#include <sys/param.h>
d25 1
@


1.8
log
@Show only active pools by default, pressing 'A' shows all of them.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.7 2014/07/02 00:12:34 dlg Exp $	*/
d221 1
a221 1
		struct pool_info *p = realloc(pools, sizeof(*pools) * np);
@


1.7
log
@info about pools is currently given to userland by copying each
pools struct out. however, struct pool in the kernel contains lots
of things that userland probably isnt interested in, like actual
mutexes, and probably shouldnt get easy access to, like pointers
to kernel memory via all the lists/trees.

this implements a kinfo_pool structure that has only the data that
userland needs to know about. it cuts the sysctl code over to
building it from struct pool as required and copying that out
instead, and cuts userland over to only handling kinfo_pool.

the only problem with this is vmstat, which can read kernel images
via kvm, which needs some understanding of struct pool. to cope,
the struct pool definition is guarded by if defined(_KERNEL) ||
defined(_LIBKVM) as inspired by sysctl which needs to do the same
thing sometimes. struct pool itself is generally not visible to
userland though, which is good.

matthew@@ suggested struct kinfo_pool instead of struct pool_info.
the kinfo prefix has precedent.
lots of people liked this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.6 2011/03/02 06:48:17 jasper Exp $	*/
d33 1
d47 1
d99 1
a99 1
	print_pool, keyboard_callback, pool_order_list, pool_order_list
d262 1
d269 2
a270 1
		if (pools[i].name[0] == 0)
d272 5
d328 14
@


1.6
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.5 2008/12/31 05:37:24 canacar Exp $	*/
d42 1
a42 1
	struct pool pool;
d235 1
a235 1
		size = sizeof(struct pool);
@


1.5
log
@Skip missing pool indices instead of printing errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.4 2008/12/07 07:46:05 canacar Exp $	*/
d66 12
a77 14
#define FIELD_ADDR(x) (&fields_pool[x])

#define FLD_POOL_NAME	FIELD_ADDR(0)
#define FLD_POOL_SIZE	FIELD_ADDR(1)
#define FLD_POOL_REQS	FIELD_ADDR(2)
#define FLD_POOL_FAIL	FIELD_ADDR(3)
#define FLD_POOL_INUSE	FIELD_ADDR(4)
#define FLD_POOL_PGREQ	FIELD_ADDR(5)
#define FLD_POOL_PGREL	FIELD_ADDR(6)
#define FLD_POOL_NPAGE	FIELD_ADDR(7)
#define FLD_POOL_HIWAT	FIELD_ADDR(8)
#define FLD_POOL_MINPG	FIELD_ADDR(9)
#define FLD_POOL_MAXPG	FIELD_ADDR(10)
#define FLD_POOL_IDLE	FIELD_ADDR(11)
@


1.4
log
@Add option to order the pool view by size and number of pages columns.
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.3 2008/11/05 16:03:02 chl Exp $	*/
d230 2
d239 3
a241 2
			error("sysctl(pool): %s", strerror(errno));
			break;
d246 1
a246 2
			error("sysctl(pool_name): %s", strerror(errno));
			break;
d262 1
a262 1
	int n, count = 0;
d267 6
a272 2
	for (n = dispstart; n < num_disp; n++) {
		showpool(n);
@


1.3
log
@add missing header needed by strcmp/strerror/memset functions.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.2 2008/11/02 07:14:16 canacar Exp $	*/
d37 2
d91 2
d131 37
@


1.2
log
@Add the option to sort by requests to the pool view, and document
the hotkeys 'o' to select and 'r' to reverse column orderings.
@
text
@d1 1
a1 1
/*	$OpenBSD: pool.c,v 1.1 2008/11/02 06:23:28 canacar Exp $	*/
d24 1
@


1.1
log
@Add a view that displays pool(9) information. Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
d86 2
a87 1
	{"name", "name", 0, sort_name_callback},
d110 16
a125 1
	return strcmp(p1->name, p2->name);
d147 1
a147 1
	qsort(pools, num_pools, sizeof(struct pool_info), ordering->func);
@

