head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.10
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.8
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.4
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.4.0.2
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.23
date	2015.01.16.00.03.37;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	waQzIVMqUqjBDjYt;

1.22
date	2014.10.08.04.10.04;	author doug;	state Exp;
branches;
next	1.21;
commitid	cpW0LtZf9XzHlFrl;

1.21
date	2014.06.23.03.46.16;	author guenther;	state Exp;
branches;
next	1.20;
commitid	uXnRK9VvnFZsAqfW;

1.20
date	2011.04.05.07.35.32;	author mpf;	state Exp;
branches;
next	1.19;

1.19
date	2011.03.02.06.48.17;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.05.14.31.44;	author lum;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.23.01.51.41;	author canacar;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.13.23.45.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.26.06.39.47;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.25.15.53.12;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.03.20.29.21;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.11;

1.11
date	2007.09.05.20.31.34;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.14.23.07.44;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.19.21.15;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.02.08.16.51;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.31.18.19.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.23.29.41;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.13.09.52.20;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.25.23.08.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.16.09.52.33;	author markus;	state Exp;
branches;
next	;


desc
@@


1.23
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@/*	$OpenBSD: if.c,v 1.22 2014/10/08 04:10:04 doug Exp $ */
/*
 * Copyright (c) 2004 Markus Friedl <markus@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>	/* roundup */
#include <sys/signal.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "systat.h"

static  enum state { BOOT, TIME, RUN } state = TIME;

struct ifstat {
	char		ifs_name[IFNAMSIZ];	/* interface name */
	char		ifs_description[IFDESCRSIZE];
	struct ifcount	ifs_cur;
	struct ifcount	ifs_old;
	struct ifcount	ifs_now;
	char		ifs_flag;
} *ifstats;

static	int nifs = 0;
static int num_ifs = 0;
static int show_bits = 0;

void print_if(void);
int read_if(void);
int select_if(void);
int if_keyboard_callback(int);

void fetchifstat(void);
static void showifstat(struct ifstat *);
static void showtotal(void);
static void rt_getaddrinfo(struct sockaddr *, int, struct sockaddr **);


/* Define fields */
field_def fields_if[] = {
	{"IFACE", 8, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"STATE", 4, 6, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
	{"IPKTS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"IBYTES", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"IERRS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"OPKTS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"OBYTES", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"OERRS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"COLLS", 5, 8, 1, FLD_ALIGN_RIGHT, -1, 0, 0, 0},
	{"DESC", 14, 64, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
};


#define FLD_IF_IFACE	FIELD_ADDR(fields_if,0)
#define FLD_IF_STATE	FIELD_ADDR(fields_if,1)
#define FLD_IF_IPKTS	FIELD_ADDR(fields_if,2)
#define FLD_IF_IBYTES	FIELD_ADDR(fields_if,3)
#define FLD_IF_IERRS	FIELD_ADDR(fields_if,4)
#define FLD_IF_OPKTS	FIELD_ADDR(fields_if,5)
#define FLD_IF_OBYTES	FIELD_ADDR(fields_if,6)
#define FLD_IF_OERRS	FIELD_ADDR(fields_if,7)
#define FLD_IF_COLLS	FIELD_ADDR(fields_if,8)
#define FLD_IF_DESC	FIELD_ADDR(fields_if,9)


/* Define views */
field_def *view_if_0[] = {
	FLD_IF_IFACE, FLD_IF_STATE, FLD_IF_DESC, FLD_IF_IPKTS,
	FLD_IF_IBYTES, FLD_IF_IERRS, FLD_IF_OPKTS, FLD_IF_OBYTES,
	FLD_IF_OERRS, FLD_IF_COLLS, NULL
};

/* Define view managers */

struct view_manager ifstat_mgr = {
	"Ifstat", select_if, read_if, NULL, print_header,
	print_if, if_keyboard_callback, NULL, NULL
};

field_view views_if[] = {
	{view_if_0, "ifstat", '1', &ifstat_mgr},
	{NULL, NULL, 0, NULL}
};


int
initifstat(void)
{
	field_view *v;
	read_if();
	for (v = views_if; v->name != NULL; v++)
		add_view(v);

	return(1);
}

#define UPDATE(x, y) do { \
		ifs->ifs_now.x = ifm.y; \
		ifs->ifs_cur.x = ifs->ifs_now.x - ifs->ifs_old.x; \
		if (state == TIME) {\
			ifs->ifs_old.x = ifs->ifs_now.x; \
			ifs->ifs_cur.x /= naptime; \
		} \
		sum.x += ifs->ifs_cur.x; \
	} while(0)


void
rt_getaddrinfo(struct sockaddr *sa, int addrs, struct sockaddr **info)
{
	int i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			info[i] = sa;
			sa = (struct sockaddr *) ((char *)(sa) +
			    roundup(sa->sa_len, sizeof(long)));
		} else
			info[i] = NULL;
	}
}



int
select_if(void)
{
	num_disp = num_ifs + 1;
	return (0);
}

int
read_if(void)
{
	fetchifstat();
	num_disp = num_ifs + 1;

	return 0;
}

void
print_if(void)
{
	int n, i, count = 0;

	for (n = 0, i = 0; n < nifs; n++) {
		if (ifstats[n].ifs_name[0] == '\0')
			continue;
		if (i++ < dispstart)
			continue;
		if (i == num_disp)
			break;
		showifstat(ifstats + n);
		if (maxprint > 0 && ++count >= maxprint)
			return;
	}
	showtotal();
}


void
fetchifstat(void)
{
	struct ifstat *newstats, *ifs;
	struct if_msghdr ifm;
	struct sockaddr *info[RTAX_MAX];
	struct sockaddr_dl *sdl;
	char *buf, *next, *lim;
	int mib[6], i;
	size_t need;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = 0;
	mib[4] = NET_RT_IFLIST;
	mib[5] = 0;

	if (sysctl(mib, 6, NULL, &need, NULL, 0) == -1)
		return;
	if ((buf = malloc(need)) == NULL)
		return;
	if (sysctl(mib, 6, buf, &need, NULL, 0) == -1) {
		free(buf);
		return;
	}

	bzero(&sum, sizeof(sum));
	num_ifs = 0;

	lim = buf + need;
	for (next = buf; next < lim; next += ifm.ifm_msglen) {
		bcopy(next, &ifm, sizeof ifm);
		if (ifm.ifm_version != RTM_VERSION ||
		    ifm.ifm_type != RTM_IFINFO ||
		    !(ifm.ifm_addrs & RTA_IFP))
			continue;
		if (ifm.ifm_index >= nifs) {
			if ((newstats = reallocarray(ifstats, ifm.ifm_index + 4,
			    sizeof(struct ifstat))) == NULL)
				continue;
			ifstats = newstats;
			for (; nifs < ifm.ifm_index + 4; nifs++)
				bzero(&ifstats[nifs], sizeof(*ifstats));
		}
		ifs = &ifstats[ifm.ifm_index];
		if (ifs->ifs_name[0] == '\0') {
			bzero(&info, sizeof(info));
			rt_getaddrinfo(
			    (struct sockaddr *)((struct if_msghdr *)next + 1),
			    ifm.ifm_addrs, info);
			sdl = (struct sockaddr_dl *)info[RTAX_IFP];

			if (sdl && sdl->sdl_family == AF_LINK &&
			    sdl->sdl_nlen > 0) {
				struct ifreq ifrdesc;
				char ifdescr[IFDESCRSIZE];
				int s;

				bcopy(sdl->sdl_data, ifs->ifs_name,
				      sdl->sdl_nlen);
				ifs->ifs_name[sdl->sdl_nlen] = '\0';

				/* Get the interface description */
				memset(&ifrdesc, 0, sizeof(ifrdesc));
				strlcpy(ifrdesc.ifr_name, ifs->ifs_name,
					sizeof(ifrdesc.ifr_name));
				ifrdesc.ifr_data = (caddr_t)&ifdescr;

				s = socket(AF_INET, SOCK_DGRAM, 0);
				if (s != -1) {
					if (ioctl(s, SIOCGIFDESCR, &ifrdesc) == 0)
						strlcpy(ifs->ifs_description,
						    ifrdesc.ifr_data,
						    sizeof(ifs->ifs_description));
					close(s);
				}
			}
			if (ifs->ifs_name[0] == '\0')
				continue;
		}
		num_ifs++;
		UPDATE(ifc_ip, ifm_data.ifi_ipackets);
		UPDATE(ifc_ib, ifm_data.ifi_ibytes);
		UPDATE(ifc_ie, ifm_data.ifi_ierrors);
		UPDATE(ifc_op, ifm_data.ifi_opackets);
		UPDATE(ifc_ob, ifm_data.ifi_obytes);
		UPDATE(ifc_oe, ifm_data.ifi_oerrors);
		UPDATE(ifc_co, ifm_data.ifi_collisions);
		ifs->ifs_cur.ifc_flags = ifm.ifm_flags;
		ifs->ifs_cur.ifc_state = ifm.ifm_data.ifi_link_state;
		ifs->ifs_flag++;
	}

	/* remove unreferenced interfaces */
	for (i = 0; i < nifs; i++) {
		ifs = &ifstats[i];
		if (ifs->ifs_flag)
			ifs->ifs_flag = 0;
		else
			ifs->ifs_name[0] = '\0';
	}

	free(buf);
}


static void
showifstat(struct ifstat *ifs)
{
	int conv = show_bits ? 8 : 1;
	int div = show_bits ? 1000 : 1024;

	print_fld_str(FLD_IF_IFACE, ifs->ifs_name);

	tb_start();
	tbprintf("%s", ifs->ifs_cur.ifc_flags & IFF_UP ?
		 "up" : "dn");

	switch (ifs->ifs_cur.ifc_state) {
	case LINK_STATE_UP:
	case LINK_STATE_HALF_DUPLEX:
	case LINK_STATE_FULL_DUPLEX:
		tbprintf(":U");
		break;
	case LINK_STATE_DOWN:
		tbprintf (":D");
		break;
	}

	print_fld_tb(FLD_IF_STATE);

	print_fld_str(FLD_IF_DESC, ifs->ifs_description);

	print_fld_sdiv(FLD_IF_IBYTES, ifs->ifs_cur.ifc_ib * conv, div);
	print_fld_size(FLD_IF_IPKTS, ifs->ifs_cur.ifc_ip);
	print_fld_size(FLD_IF_IERRS, ifs->ifs_cur.ifc_ie);

	print_fld_sdiv(FLD_IF_OBYTES, ifs->ifs_cur.ifc_ob * conv, div);
	print_fld_size(FLD_IF_OPKTS, ifs->ifs_cur.ifc_op);
	print_fld_size(FLD_IF_OERRS, ifs->ifs_cur.ifc_oe);

	print_fld_size(FLD_IF_COLLS, ifs->ifs_cur.ifc_co);

	end_line();
}

static void
showtotal(void)
{
	int conv = show_bits ? 8 : 1;
	int div = show_bits ? 1000 : 1024;

	print_fld_str(FLD_IF_IFACE, "Totals");

	print_fld_sdiv(FLD_IF_IBYTES, sum.ifc_ib * conv, div);
	print_fld_size(FLD_IF_IPKTS, sum.ifc_ip);
	print_fld_size(FLD_IF_IERRS, sum.ifc_ie);

	print_fld_sdiv(FLD_IF_OBYTES, sum.ifc_ob * conv, div);
	print_fld_size(FLD_IF_OPKTS, sum.ifc_op);
	print_fld_size(FLD_IF_OERRS, sum.ifc_oe);

	print_fld_size(FLD_IF_COLLS, sum.ifc_co);

	end_line();

}

int
if_keyboard_callback(int ch)
{
	struct ifstat *ifs;

	switch (ch) {
	case 'r':
		for (ifs = ifstats; ifs < ifstats + nifs; ifs++)
			ifs->ifs_old = ifs->ifs_now;
		state = RUN;
		gotsig_alarm = 1;

		break;
	case 'b':
		state = BOOT;
		for (ifs = ifstats; ifs < ifstats + nifs; ifs++)
			bzero(&ifs->ifs_old, sizeof(ifs->ifs_old));
		gotsig_alarm = 1;
		break;
	case 'B':
		show_bits = !show_bits;
		if (show_bits) {
			FLD_IF_IBYTES->title = "IBITS";
			FLD_IF_OBYTES->title = "OBITS";
		} else {
			FLD_IF_IBYTES->title = "IBYTES";
			FLD_IF_OBYTES->title = "OBYTES";
		}
		gotsig_alarm = 1;
		break;
	case 't':
		state = TIME;
		gotsig_alarm = 1;
		break;
	default:
		return keyboard_callback(ch);
	};

	return 1;
}

@


1.22
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.21 2014/06/23 03:46:16 guenther Exp $ */
d18 2
a19 2
#include <sys/param.h>
#include <sys/types.h>
@


1.21
log
@The second level of the CTL_NET sysctl is a PF_*, not an AF_*

inconsistent usage in route(8) noted by Gregor Best (gbe (at) ring0.de)
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.20 2011/04/05 07:35:32 mpf Exp $ */
d220 2
a221 2
			if ((newstats = realloc(ifstats, (ifm.ifm_index + 4)
			    * sizeof(struct ifstat))) == NULL)
@


1.20
log
@Add support to display numbers with thousands separators
and to switch the ifstat view to Bits/s.
This allows us to see live network throughput in units
like MBit/s, which is more practical.
OK sthen@@, manpage OK jmc@@, "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.19 2011/03/02 06:48:17 jasper Exp $ */
d194 1
a194 1
	mib[1] = AF_ROUTE;
@


1.19
log
@- use a common FIELD_ADDR macro, instead of rolling 78 identical copies.

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.18 2010/07/05 14:31:44 lum Exp $ */
d47 1
d292 3
d316 1
a316 1
	print_fld_size(FLD_IF_IBYTES, ifs->ifs_cur.ifc_ib);
d320 1
a320 1
	print_fld_size(FLD_IF_OBYTES, ifs->ifs_cur.ifc_ob);
d332 3
d337 1
a337 1
	print_fld_size(FLD_IF_IBYTES, sum.ifc_ib);
d341 1
a341 1
	print_fld_size(FLD_IF_OBYTES, sum.ifc_ob);
d368 11
@


1.18
log
@Add prototype and remove unused variable.
ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.17 2009/11/23 01:51:41 canacar Exp $ */
d74 10
a83 12
#define FIELD_ADDR(x) (&fields_if[x])

#define FLD_IF_IFACE	FIELD_ADDR(0)
#define FLD_IF_STATE	FIELD_ADDR(1)
#define FLD_IF_IPKTS	FIELD_ADDR(2)
#define FLD_IF_IBYTES	FIELD_ADDR(3)
#define FLD_IF_IERRS	FIELD_ADDR(4)
#define FLD_IF_OPKTS	FIELD_ADDR(5)
#define FLD_IF_OBYTES	FIELD_ADDR(6)
#define FLD_IF_OERRS	FIELD_ADDR(7)
#define FLD_IF_COLLS	FIELD_ADDR(8)
#define FLD_IF_DESC	FIELD_ADDR(9)
@


1.17
log
@Properly handle interfaces deleted from the middle of the list.
Reported by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.16 2009/08/13 23:45:35 deraadt Exp $ */
d56 1
a190 1
	static int s = -1;
@


1.16
log
@there are louder and louder moans about the inability to see packet
rates at the same time as interrupt counts, so sneak them into the
bottom corner of the vmstat screen
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.15 2009/06/26 06:39:47 jasper Exp $ */
d42 1
d191 1
a191 1
	int mib[6];
d274 1
d276 10
@


1.15
log
@- include two missing headers in if.c
- add missing parenthesis in nfs.c

ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.14 2009/06/25 15:53:12 claudio Exp $ */
a35 12
struct ifcount {
	u_int64_t	ifc_ib;			/* input bytes */
	u_int64_t	ifc_ip;			/* input packets */
	u_int64_t	ifc_ie;			/* input errors */
	u_int64_t	ifc_ob;			/* output bytes */
	u_int64_t	ifc_op;			/* output packets */
	u_int64_t	ifc_oe;			/* output errors */
	u_int64_t	ifc_co;			/* collisions */
	int		ifc_flags;		/* up / down */
	int		ifc_state;		/* link state */
} sum;

d52 1
a52 1
static void fetchifstat(void);
d181 1
a181 1
static void
@


1.14
log
@Check RTM_VERSION even on sysctl data.
Tested and OK sthen@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.13 2009/04/03 20:29:21 deraadt Exp $ */
d17 1
d26 1
d30 1
@


1.13
log
@Show interface description names in "systat if 1"; some help from canacar
sthen likes it
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.12 2008/06/12 22:26:01 canacar Exp $ */
d224 3
a226 2
		if (ifm.ifm_type != RTM_IFINFO ||
		   !(ifm.ifm_addrs & RTA_IFP))
@


1.12
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.11 2007/09/05 20:31:34 mk Exp $ */
d24 1
d47 1
d69 1
a69 1
	{"STATE", 10, 16, 1, FLD_ALIGN_LEFT, -1, 0, 0, 0},
d77 1
d92 1
d97 3
a99 3
	FLD_IF_IFACE, FLD_IF_STATE, FLD_IF_IPKTS, FLD_IF_IBYTES,
	FLD_IF_IERRS, FLD_IF_OPKTS, FLD_IF_OBYTES, FLD_IF_OERRS,
	FLD_IF_COLLS, NULL
d198 1
d241 25
a265 6
			if ((sdl = (struct sockaddr_dl *)info[RTAX_IFP])) {
				if (sdl->sdl_family == AF_LINK &&
				    sdl->sdl_nlen > 0) {
					bcopy(sdl->sdl_data, ifs->ifs_name,
					    sdl->sdl_nlen);
					ifs->ifs_name[sdl->sdl_nlen] = '\0';
d307 2
@


1.11
log
@Cope with if counters being u_int64_t now here, too.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.10 2007/04/14 23:07:44 tedu Exp $ */
a28 1
#include "extern.h"
d52 1
d54 55
a108 1
const char	*showlinkstate(int);
a109 17
WINDOW *
openifstat(void)
{

	return (subwin(stdscr, LINES-1-1, 0, 1, 0));
}

void
closeifstat(WINDOW *w)
{

	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
}
d114 4
a118 1
	fetchifstat();
d148 18
d167 20
d214 1
d223 2
a224 2
			if ((newstats = realloc(ifstats, (ifm.ifm_index + 4) *
			    sizeof(struct ifstat))) == NULL)
d228 1
a228 1
				ifstats[nifs].ifs_name[0] = '\0';
d247 1
a260 1
#define INSET 0
d262 2
a263 2
void
labelifstat(void)
d265 1
d267 3
a269 15
	wmove(wnd, 0, 0);
	wclrtobot(wnd);

	mvwaddstr(wnd, 1, INSET, "Iface");
	mvwaddstr(wnd, 1, INSET+9, "State");
	mvwaddstr(wnd, 1, INSET+19, "Ibytes");
	mvwaddstr(wnd, 1, INSET+29, "Ipkts");
	mvwaddstr(wnd, 1, INSET+36, "Ierrs");
	mvwaddstr(wnd, 1, INSET+48, "Obytes");
	mvwaddstr(wnd, 1, INSET+58, "Opkts");
	mvwaddstr(wnd, 1, INSET+65, "Oerrs");
	mvwaddstr(wnd, 1, INSET+74, "Colls");
}

#define FMT "%-8.8s %2s%2s  %10llu %8llu %6llu   %10llu %8llu %6llu   %6llu "
d271 1
a271 4
const char *
showlinkstate(int state)
{
	switch (state) {
d275 2
a276 1
		return (":U");
d278 2
a279 4
		return (":D");
	case LINK_STATE_UNKNOWN:
	default:
		return ("");
d281 14
d297 2
a298 2
void
showifstat(void)
d300 13
a312 2
	int row;
	struct ifstat *ifs;
a313 28
	row = 2;
	wmove(wnd, 0, 0);
	wclrtoeol(wnd);
	for (ifs = ifstats; ifs < ifstats + nifs; ifs++) {
		if (ifs->ifs_name[0] == '\0')
			continue;
		mvwprintw(wnd, row++, INSET, FMT,
		    ifs->ifs_name,
		    ifs->ifs_cur.ifc_flags & IFF_UP ? "up" : "dn",
		    showlinkstate(ifs->ifs_cur.ifc_state),
		    ifs->ifs_cur.ifc_ib,
		    ifs->ifs_cur.ifc_ip,
		    ifs->ifs_cur.ifc_ie,
		    ifs->ifs_cur.ifc_ob,
		    ifs->ifs_cur.ifc_op,
		    ifs->ifs_cur.ifc_oe,
		    ifs->ifs_cur.ifc_co);
	}
	mvwprintw(wnd, row++, INSET, FMT,
	    "Totals",
	    "", "",
	    sum.ifc_ib,
	    sum.ifc_ip,
	    sum.ifc_ie,
	    sum.ifc_ob,
	    sum.ifc_op,
	    sum.ifc_oe,
	    sum.ifc_co);
d317 1
a317 1
cmdifstat(char *cmd, char *args)
d321 4
a324 4
	if (prefix(cmd, "run")) {
		if (state != RUN)
			for (ifs = ifstats; ifs < ifstats + nifs; ifs++)
				ifs->ifs_old = ifs->ifs_now;
d326 4
a329 3
		return (1);
	}
	if (prefix(cmd, "boot")) {
d333 3
a335 3
		return (1);
	}
	if (prefix(cmd, "time")) {
d337 7
a343 9
		return (1);
	}
	if (prefix(cmd, "zero")) {
		if (state == RUN)
			for (ifs = ifstats; ifs < ifstats + nifs; ifs++)
				ifs->ifs_old = ifs->ifs_now;
		return (1);
	}
	return (1);
d345 1
@


1.10
log
@naptime is already extern in extern.h, don't do it again
found by mike erdely
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.9 2007/02/25 18:21:24 deraadt Exp $ */
d34 7
a40 7
	u_long		ifc_ib;			/* input bytes */
	u_long		ifc_ip;			/* input packets */
	u_long		ifc_ie;			/* input errors */
	u_long		ifc_ob;			/* output bytes */
	u_long		ifc_op;			/* output packets */
	u_long		ifc_oe;			/* output errors */
	u_long		ifc_co;			/* collisions */
d201 1
a201 1
#define FMT "%-8.8s %2s%2s  %10lu %8lu %6lu   %10lu %8lu %6lu   %6lu "
@


1.9
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.8 2006/11/28 19:21:15 reyk Exp $ */
a52 1
extern	u_int naptime;
@


1.8
log
@add additional link states to report the half duplex / full duplex
state, if known by the driver. this is required to check the full
duplex state without depending on the ifmedia ioctl which can't be
called in the kernel without process context.

ok henning@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.7 2006/06/02 08:16:51 claudio Exp $ */
d61 1
a61 1
	return (subwin(stdscr, LINES-5-1, 0, 5, 0));
d215 1
@


1.7
log
@Show interface state and link state in ifstat output. Idea and OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.6 2006/03/31 18:19:44 deraadt Exp $ */
d209 2
@


1.6
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.5 2006/03/31 04:10:59 deraadt Exp $ */
d41 2
d55 2
d176 2
d191 6
a196 5
	mvwaddstr(wnd, 1, INSET, "Interfaces");
	mvwaddstr(wnd, 1, INSET+15, "Ibytes");
	mvwaddstr(wnd, 1, INSET+27, "Ipkts");
	mvwaddstr(wnd, 1, INSET+34, "Ierrs");
	mvwaddstr(wnd, 1, INSET+46, "Obytes");
d202 14
a215 1
#define FMT "%-10.10s %10lu %10lu %6lu   %10lu %10lu %6lu   %6lu "
d231 2
d243 1
@


1.5
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.4 2006/01/10 23:29:41 dlg Exp $ */
d196 1
a196 1
	
@


1.4
log
@fix the time view of the interface stats so that is shows the average
over the refresh interval (like the manpage says it should) instead of
the total.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.3 2005/12/13 09:52:20 dlg Exp $ */
d26 1
d51 1
a51 1
extern	int naptime;
d113 1
a113 1
	int mib[6], i;
d182 2
a183 1
	wmove(wnd, 0, 0); wclrtobot(wnd);
d204 2
a205 1
	wmove(wnd, 0, 0); wclrtoeol(wnd);
@


1.3
log
@sdl->sdl_data does not contain a nul terminated string, so use bcopy and
terminate it manually rather than use strlcpy to get the interface name.
fixes output on my sparc and sparc64s.

ok markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.2 2004/11/25 23:08:13 deraadt Exp $ */
d50 1
d81 4
a85 2
		if (state == TIME) \
			ifs->ifs_old.x = ifs->ifs_now.x; \
@


1.2
log
@fix on alpha.  the lack of BWX by default, and assumptions of alignment
keep biting us hard for structures that happen to have been plopped at
unaligned objects.  terrible decisions made at DEC ages ago, and compounded
by terrible gcc decisions cause us to make workarounds all the time.
showed by markus, found by David Berghoff
@
text
@d1 1
a1 1
/*	$OpenBSD: if.c,v 1.1 2004/11/16 09:52:33 markus Exp $ */
d152 5
a156 4
				    sdl->sdl_nlen > 0)
					strlcpy(ifs->ifs_name,
					    sdl->sdl_data,
					    sizeof(ifs->ifs_name));
@


1.1
log
@print network interface stats with 'systat ifstat'; ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: $ */
d78 1
a78 1
		ifs->ifs_now.x = ifm->y; \
d105 1
a105 1
	struct if_msghdr *ifm;
d131 4
a134 4
	for (next = buf; next < lim; next += ifm->ifm_msglen) {
		ifm = (struct if_msghdr *)next;
		if (ifm->ifm_type != RTM_IFINFO ||
		   !(ifm->ifm_addrs & RTA_IFP))
d136 2
a137 2
		if (ifm->ifm_index >= nifs) {
			if ((newstats = realloc(ifstats, (ifm->ifm_index + 4) *
d141 1
a141 1
			for (; nifs < ifm->ifm_index + 4; nifs++)
d144 1
a144 1
		ifs = &ifstats[ifm->ifm_index];
d147 3
a149 2
			rt_getaddrinfo((struct sockaddr *)(ifm + 1),
			    ifm->ifm_addrs, info);
@

