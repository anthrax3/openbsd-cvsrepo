head	1.82;
access;
symbols
	OPENBSD_6_1:1.82.0.4
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.73.0.10
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.8
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.6
	OPENBSD_5_0:1.73.0.4
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.73.0.2
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.72.0.4
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.69.0.4
	OPENBSD_4_6_BASE:1.69
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.65.0.2
	OPENBSD_4_4_BASE:1.65
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.62.0.4
	OPENBSD_4_2_BASE:1.62
	OPENBSD_4_1:1.62.0.2
	OPENBSD_4_1_BASE:1.62
	OPENBSD_4_0:1.60.0.2
	OPENBSD_4_0_BASE:1.60
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.54.0.2
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.52.0.2
	OPENBSD_3_6_BASE:1.52
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.41.0.2
	OPENBSD_3_4_BASE:1.41
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.36.0.2
	OPENBSD_3_2_BASE:1.36
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	OPENBSD_3_0:1.25.0.2
	OPENBSD_3_0_BASE:1.25
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.6
	OPENBSD_2_8:1.21.0.4
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2016.12.18.23.36.32;	author krw;	state Exp;
branches;
next	1.81;
commitid	2kCXlleniNffeHM5;

1.81
date	2016.08.24.03.13.45;	author guenther;	state Exp;
branches;
next	1.80;
commitid	AyeFIn869BnF7M99;

1.80
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	0Dp7Dy9FuNZesYo2;

1.79
date	2015.01.16.00.03.38;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	waQzIVMqUqjBDjYt;

1.78
date	2014.11.23.04.34.48;	author guenther;	state Exp;
branches;
next	1.77;
commitid	LIj2x3qvN0HcH7BW;

1.77
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.76;
commitid	uuiU9j2I8AUx0fez;

1.76
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2013.10.31.02.00.11;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.14.20.39.25;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2010.11.19.18.35.16;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2009.08.14.14.41.55;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2009.08.13.23.45.35;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.05.03.05.01.54;	author drahn;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.30.05.35.22;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2008.12.07.02.56.06;	author canacar;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.01.00.56.25;	author canacar;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.13.10.06.14;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.12.22.26.01;	author canacar;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.01.19.32.19;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.25.18.21.24;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.13.19.03.51;	author otto;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.14.01.14.56;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.14.01.08.15;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.31.18.19.44;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.31.04.10.59;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.28.09.03.46;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.28.00.24.04;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.04.08.54.33;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.23.21.10.21;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.09.16.32.54;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.28.01.45.51;	author aaron;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.11.06.31.32;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.11.06.30.31;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.11.05.55.43;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.22.18.06.12;	author henning;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.23.04.15.27;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.15.22.56.12;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.16.07.09.09;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.15.20.01.32;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.04.14.04.45.45;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.08.00.53.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.28.21.29.07;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.16.01.57.04;	author tdeval;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.19.08.45.52;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.18.00.46.48;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.29.17.28.12;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.16.00.18.09;	author tdeval;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.07.09.18.08;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.07.07.57.36;	author pvalchev;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.23.22.20.06;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.18.23.56.49;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.06.19.20.15;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.28.05.17.55;	author weingart;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.06.16.49;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.22.14.57.21;	author lebel;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.04.16.48.34;	author ericj;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.22.21.24.02;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.10.26.15.43.22;	author art;	state Exp;
branches;
next	1.19;

1.19
date	99.10.26.15.13.54;	author art;	state Exp;
branches;
next	1.18;

1.18
date	99.06.16.10.18.30;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	98.12.19.06.34.22;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.07.13.02.11.42;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.06.12.22.09.23;	author marc;	state Exp;
branches;
next	1.14;

1.14
date	97.12.19.09.34.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.12.19.09.22.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.19.09.03.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.24.16.19.42;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.11.22.20.07.56;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.11.22.14.19.23;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.11.22.13.07.37;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.07.29.04.51.43;	author flipk;	state Exp;
branches;
next	1.6;

1.6
date	97.07.29.04.47.13;	author flipk;	state Exp;
branches;
next	1.5;

1.5
date	96.12.20.00.17.29;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.26.05.40.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.20.47.00;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.10;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.82
log
@Remove statements that have no effect from X(), Y() and Z() #define's.
Leftovers from the re-engining of systat eight years ago. Makes gcc
quieter.

ok otto@@ deraadt@@
@
text
@/*	$OpenBSD: vmstat.c,v 1.81 2016/08/24 03:13:45 guenther Exp $	*/
/*	$NetBSD: vmstat.c,v 1.5 1996/05/10 23:16:40 thorpej Exp $	*/

/*-
 * Copyright (c) 1983, 1989, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Cursed vmstat -- from Robert Elz.
 */

#include <sys/param.h>	/* MAXCOMLEN */
#include <sys/types.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/sched.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/vmmeter.h>

#include <ctype.h>
#include <errno.h>
#include <err.h>
#include <paths.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "systat.h"
#include "dkstats.h"

#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

static struct Info {
	long	time[CPUSTATES];
	struct	uvmexp uvmexp;
	struct	vmtotal Total;
	struct	nchstats nchstats;
	long	nchcount;
	uint64_t *intrcnt;
} s, s1, s2, s3, z;

extern struct _disk	cur;

#define	cnt s.Cnt
#define oldcnt s1.Cnt
#define	total s.Total
#define	nchtotal s.nchstats
#define	oldnchtotal s1.nchstats

static	enum state { BOOT, TIME, RUN } state = TIME;

static void allocinfo(struct Info *);
static void copyinfo(struct Info *, struct Info *);
static float cputime(int);
static void dinfo(int, int);
static void getinfo(struct Info *);
void putint(int, int, int, int);
void putintmk(int, int, int, int);
void putuint64(u_int64_t, int, int, int);
void putfloat(double, int, int, int, int, int);
int ucount(void);

void print_vm(void);
int read_vm(void);
int select_vm(void);
int vm_keyboard_callback(int);

static	time_t t;
static	double etime;
static	float hertz;
static	int nintr;
static	long *intrloc;
static	char **intrname;
static	int nextintsrow;

WINDOW *
openkre(void)
{
	return (subwin(stdscr, LINES-1-1, 0, 1, 0));
}

void
closekre(WINDOW *w)
{

	if (w == NULL)
		return;
	wclear(w);
	wrefresh(w);
	delwin(w);
}

/*
 * These constants define where the major pieces are laid out
 */
#define STATROW		 0	/* uses 1 row and 68 cols */
#define STATCOL		 2
#define MEMROW		 2	/* uses 4 rows and 34 cols */
#define MEMCOL		 0
#define PAGEROW		 2	/* uses 4 rows and 26 cols */
#define PAGECOL		37
#define INTSROW		 2	/* uses all rows to bottom and 17 cols */
#define INTSCOL		63
#define PROCSROW	 7	/* uses 2 rows and 20 cols */
#define PROCSCOL	 0
#define GENSTATROW	 7	/* uses 2 rows and 35 cols */
#define GENSTATCOL	16
#define VMSTATROW	 7	/* uses 18 rows and 12 cols */
#define VMSTATCOL	48
#define GRAPHROW	10	/* uses 3 rows and 51 cols */
#define GRAPHCOL	 0
#define NAMEIROW	14	/* uses 3 rows and 49 cols */
#define NAMEICOL	 0
#define DISKROW		18	/* uses 5 rows and 50 cols (for 9 drives) */
#define DISKCOL		 0

#define	DRIVESPACE	45	/* max space for drives */


field_def *view_vm_0[] = {
	NULL
};

/* Define view managers */
struct view_manager vmstat_mgr = {
	"VMstat", select_vm, read_vm, NULL, print_header,
	print_vm, vm_keyboard_callback, NULL, NULL
};

field_view views_vm[] = {
	{view_vm_0, "vmstat", '7', &vmstat_mgr},
	{NULL, NULL, 0, NULL}
};

int
initvmstat(void)
{
	field_view *v;
	int mib[4], i;
	size_t size;

	hertz = stathz;
	if (!dkinit(1))
		return(0);

	mib[0] = CTL_KERN;
	mib[1] = KERN_INTRCNT;
	mib[2] = KERN_INTRCNT_NUM;
	size = sizeof(nintr);
	if (sysctl(mib, 3, &nintr, &size, NULL, 0) < 0)
		return (-1);

	intrloc = calloc(nintr, sizeof(long));
	intrname = calloc(nintr, sizeof(char *));

	for (i = 0; i < nintr; i++) {
		char name[128];

		mib[0] = CTL_KERN;
		mib[1] = KERN_INTRCNT;
		mib[2] = KERN_INTRCNT_NAME;
		mib[3] = i;
		size = sizeof(name);
		if (sysctl(mib, 4, name, &size, NULL, 0) < 0)
			return (-1);

		intrname[i] = strdup(name);
		if (intrname[i] == NULL)
			return (-1);
	}

	nextintsrow = INTSROW + 2;
	allocinfo(&s);
	allocinfo(&s1);
	allocinfo(&s2);
	allocinfo(&s3);
	allocinfo(&z);

	getinfo(&s2);
	copyinfo(&z, &s1);

	for (v = views_vm; v->name != NULL; v++)
		add_view(v);

	return(1);
}

void
fetchkre(void)
{
	getinfo(&s3);
}

void
labelkre(void)
{
	int i, j, l;

	mvprintw(MEMROW, MEMCOL,     "            memory totals (in KB)");
	mvprintw(MEMROW + 1, MEMCOL, "           real   virtual     free");
	mvprintw(MEMROW + 2, MEMCOL, "Active");
	mvprintw(MEMROW + 3, MEMCOL, "All");

	mvprintw(PAGEROW, PAGECOL, "        PAGING   SWAPPING ");
	mvprintw(PAGEROW + 1, PAGECOL, "        in  out   in  out ");
	mvprintw(PAGEROW + 2, PAGECOL, "ops");
	mvprintw(PAGEROW + 3, PAGECOL, "pages");

	mvprintw(INTSROW, INTSCOL + 3, " Interrupts");
	mvprintw(INTSROW + 1, INTSCOL + 9, "total");

	mvprintw(LINES - 3, INTSCOL + 9, "IPKTS");
	mvprintw(LINES - 2, INTSCOL + 9, "OPKTS");

	mvprintw(VMSTATROW + 0, VMSTATCOL + 10, "forks");
	mvprintw(VMSTATROW + 1, VMSTATCOL + 10, "fkppw");
	mvprintw(VMSTATROW + 2, VMSTATCOL + 10, "fksvm");
	mvprintw(VMSTATROW + 3, VMSTATCOL + 10, "pwait");
	mvprintw(VMSTATROW + 4, VMSTATCOL + 10, "relck");
	mvprintw(VMSTATROW + 5, VMSTATCOL + 10, "rlkok");
	mvprintw(VMSTATROW + 6, VMSTATCOL + 10, "noram");
	mvprintw(VMSTATROW + 7, VMSTATCOL + 10, "ndcpy");
	mvprintw(VMSTATROW + 8, VMSTATCOL + 10, "fltcp");
	mvprintw(VMSTATROW + 9, VMSTATCOL + 10, "zfod");
	mvprintw(VMSTATROW + 10, VMSTATCOL + 10, "cow");
	mvprintw(VMSTATROW + 11, VMSTATCOL + 10, "fmin");
	mvprintw(VMSTATROW + 12, VMSTATCOL + 10, "ftarg");
	mvprintw(VMSTATROW + 13, VMSTATCOL + 10, "itarg");
	mvprintw(VMSTATROW + 14, VMSTATCOL + 10, "wired");
	mvprintw(VMSTATROW + 15, VMSTATCOL + 10, "pdfre");
	if (LINES - 1 > VMSTATROW + 16)
		mvprintw(VMSTATROW + 16, VMSTATCOL + 10, "pdscn");
	if (LINES - 1 > VMSTATROW + 17)
		mvprintw(VMSTATROW + 17, VMSTATCOL + 10, "pzidle");
	if (LINES - 1 > VMSTATROW + 18)
		mvprintw(VMSTATROW + 18, VMSTATCOL + 10, "kmapent");

	mvprintw(GENSTATROW, GENSTATCOL, "   Csw   Trp   Sys   Int   Sof  Flt");

	mvprintw(GRAPHROW, GRAPHCOL,
	    "    . %%Int    . %%Sys    . %%Usr    . %%Nic    . %%Idle");
	mvprintw(PROCSROW, PROCSCOL, "Proc:r  d  s  w");
	mvprintw(GRAPHROW + 1, GRAPHCOL,
	    "|    |    |    |    |    |    |    |    |    |    |");

	mvprintw(NAMEIROW, NAMEICOL,
	    "Namei         Sys-cache    Proc-cache    No-cache");
	mvprintw(NAMEIROW + 1, NAMEICOL,
	    "    Calls     hits    %%    hits     %%    miss   %%");
	mvprintw(DISKROW, DISKCOL, "Disks");
	mvprintw(DISKROW + 1, DISKCOL, "seeks");
	mvprintw(DISKROW + 2, DISKCOL, "xfers");
	mvprintw(DISKROW + 3, DISKCOL, "speed");
	mvprintw(DISKROW + 4, DISKCOL, "  sec");
	for (i = 0, j = 0; i < cur.dk_ndrive && j < DRIVESPACE; i++)
		if (cur.dk_select[i] && (j + strlen(dr_name[i])) < DRIVESPACE) {
			l = MAXIMUM(5, strlen(dr_name[i]));
			mvprintw(DISKROW, DISKCOL + 5 + j,
			    " %*s", l, dr_name[i]);
			j += 1 + l;
		}
	for (i = 0; i < nintr; i++) {
		if (intrloc[i] == 0)
			continue;
		mvprintw(intrloc[i], INTSCOL + 9, "%-8.8s", intrname[i]);
	}
}

#define X(fld)	{s.fld[i]-=s1.fld[i];}
#define Y(fld)	{s.fld -= s1.fld;}
#define Z(fld)	{s.nchstats.fld -= s1.nchstats.fld;}
#define PUTRATE(fld, l, c, w) \
	do { \
		Y(fld); \
		putint((int)((float)s.fld/etime + 0.5), l, c, w); \
	} while (0)
#define MAXFAIL 5

static	char cpuchar[CPUSTATES] = { '|', '=', '>', '-', ' ' };
static	char cpuorder[CPUSTATES] = { CP_INTR, CP_SYS, CP_USER, CP_NICE, CP_IDLE };

void
showkre(void)
{
	float f1, f2;
	int psiz;
	u_int64_t inttotal, intcnt;
	int i, l, c;
	static int failcnt = 0, first_run = 0;

	if (state == TIME) {
		if (!first_run) {
			first_run = 1;
			return;
		}
	}
	etime = 0;
	for (i = 0; i < CPUSTATES; i++) {
		X(time);
		etime += s.time[i];
	}
	if (etime < 5.0) {	/* < 5 ticks - ignore this trash */
		if (failcnt++ >= MAXFAIL) {
			error("The alternate system clock has died!");
			failcnt = 0;
		}
		return;
	}
	failcnt = 0;
	etime /= hertz;
	inttotal = 0;
	for (i = 0; i < nintr; i++) {
		if (s.intrcnt[i] == 0)
			continue;
		if (intrloc[i] == 0) {
			if (nextintsrow == LINES)
				continue;
			intrloc[i] = nextintsrow++;
			mvprintw(intrloc[i], INTSCOL + 9, "%-8.8s",
			    intrname[i]);
		}
		t = intcnt = s.intrcnt[i];
		s.intrcnt[i] -= s1.intrcnt[i];
		intcnt = (u_int64_t)((float)s.intrcnt[i]/etime + 0.5);
		inttotal += intcnt;
		putuint64(intcnt, intrloc[i], INTSCOL, 8);
	}
	putuint64(inttotal, INTSROW + 1, INTSCOL, 8);
	Z(ncs_goodhits); Z(ncs_badhits); Z(ncs_miss);
	Z(ncs_long); Z(ncs_pass2); Z(ncs_2passes);
	s.nchcount = nchtotal.ncs_goodhits + nchtotal.ncs_badhits +
	    nchtotal.ncs_miss + nchtotal.ncs_long;

	putint(sum.ifc_ip, LINES - 3, INTSCOL, 8);
	putint(sum.ifc_op, LINES - 2, INTSCOL, 8);

	psiz = 0;
	f2 = 0.0;

	for (c = 0; c < CPUSTATES; c++) {
		i = cpuorder[c];
		f1 = cputime(i);
		f2 += f1;
		l = (int) ((f2 + 1.0) / 2.0) - psiz;
		putfloat(f1, GRAPHROW, GRAPHCOL + 1 + (10 * c), 5, 1, 0);
		move(GRAPHROW + 2, psiz);
		psiz += l;
		while (l-- > 0)
			addch(cpuchar[c]);
	}

#define pgtokb(pg)	((pg) * (s.uvmexp.pagesize / 1024))

	putint(pgtokb(s.uvmexp.active), MEMROW + 2, MEMCOL + 7, 8);
	putint(pgtokb(s.uvmexp.active + s.uvmexp.swpginuse),    /* XXX */
	    MEMROW + 2, MEMCOL + 17, 8);
	putint(pgtokb(s.uvmexp.npages - s.uvmexp.free), MEMROW + 3, MEMCOL + 7, 8);
	putint(pgtokb(s.uvmexp.npages - s.uvmexp.free + s.uvmexp.swpginuse),
	    MEMROW + 3, MEMCOL + 17, 8);
	putint(pgtokb(s.uvmexp.free), MEMROW + 2, MEMCOL + 26, 8);
	putint(pgtokb(s.uvmexp.free + s.uvmexp.swpages - s.uvmexp.swpginuse),
	    MEMROW + 3, MEMCOL + 26, 8);
	putint(total.t_rq - 1, PROCSROW + 1, PROCSCOL + 3, 3);

	putint(total.t_dw, PROCSROW + 1, PROCSCOL + 6, 3);
	putint(total.t_sl, PROCSROW + 1, PROCSCOL + 9, 3);
	putint(total.t_sw, PROCSROW + 1, PROCSCOL + 12, 3);
	PUTRATE(uvmexp.forks, VMSTATROW + 0, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.forks_ppwait, VMSTATROW + 1, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.forks_sharevm, VMSTATROW + 2, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.fltpgwait, VMSTATROW + 3, VMSTATCOL + 4, 5);
	PUTRATE(uvmexp.fltrelck, VMSTATROW + 4, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.fltrelckok, VMSTATROW + 5, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.fltnoram, VMSTATROW + 6, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.fltamcopy, VMSTATROW + 7, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.flt_prcopy, VMSTATROW + 8, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.flt_przero, VMSTATROW + 9, VMSTATCOL + 3, 6);
	PUTRATE(uvmexp.flt_acow, VMSTATROW + 10, VMSTATCOL, 9);
	putint(s.uvmexp.freemin, VMSTATROW + 11, VMSTATCOL, 9);
	putint(s.uvmexp.freetarg, VMSTATROW + 12, VMSTATCOL, 9);
	putint(s.uvmexp.inactarg, VMSTATROW + 13, VMSTATCOL, 9);
	putint(s.uvmexp.wired, VMSTATROW + 14, VMSTATCOL, 9);
	PUTRATE(uvmexp.pdfreed, VMSTATROW + 15, VMSTATCOL, 9);
	if (LINES - 1 > VMSTATROW + 16)
		PUTRATE(uvmexp.pdscans, VMSTATROW + 16, VMSTATCOL, 9);
	if (LINES - 1 > VMSTATROW + 17)
		PUTRATE(uvmexp.zeropages, VMSTATROW + 17, VMSTATCOL, 9);
	if (LINES - 1 > VMSTATROW + 18)
		putint(s.uvmexp.kmapent, VMSTATROW + 18, VMSTATCOL, 9);

	PUTRATE(uvmexp.pageins, PAGEROW + 2, PAGECOL + 5, 5);
	PUTRATE(uvmexp.pdpageouts, PAGEROW + 2, PAGECOL + 10, 5);
	PUTRATE(uvmexp.pgswapin, PAGEROW + 3, PAGECOL + 5, 5);
	PUTRATE(uvmexp.pgswapout, PAGEROW + 3, PAGECOL + 10, 5);

	PUTRATE(uvmexp.swtch, GENSTATROW + 1, GENSTATCOL, 6);
	PUTRATE(uvmexp.traps, GENSTATROW + 1, GENSTATCOL + 6, 6);
	PUTRATE(uvmexp.syscalls, GENSTATROW + 1, GENSTATCOL + 12, 6);
	PUTRATE(uvmexp.intrs, GENSTATROW + 1, GENSTATCOL + 18, 6);
	PUTRATE(uvmexp.softs, GENSTATROW + 1, GENSTATCOL + 24, 6);
	PUTRATE(uvmexp.faults, GENSTATROW + 1, GENSTATCOL + 30, 5);
	mvprintw(DISKROW, DISKCOL + 5, "                              ");
	for (i = 0, c = 0; i < cur.dk_ndrive && c < DRIVESPACE; i++)
		if (cur.dk_select[i] && (c + strlen(dr_name[i])) < DRIVESPACE) {
			l = MAXIMUM(5, strlen(dr_name[i]));
			mvprintw(DISKROW, DISKCOL + 5 + c,
			    " %*s", l, dr_name[i]);
			c += 1 + l;
			dinfo(i, c);
		}
	/* and pad the DRIVESPACE */
	l = DRIVESPACE - c;
	for (i = 0; i < 5; i++)
		mvprintw(DISKROW + i, DISKCOL + 5 + c, "%*s", l, "");

	putint(s.nchcount, NAMEIROW + 2, NAMEICOL, 9);
	putint(nchtotal.ncs_goodhits, NAMEIROW + 2, NAMEICOL + 10, 8);
#define nz(x)	((x) ? (x) : 1)
	putfloat(nchtotal.ncs_goodhits * 100.0 / nz(s.nchcount),
	    NAMEIROW + 2, NAMEICOL + 19, 4, 0, 1);
	putint(nchtotal.ncs_pass2, NAMEIROW + 2, NAMEICOL + 24, 7);
	putfloat(nchtotal.ncs_pass2 * 100.0 / nz(s.nchcount),
	    NAMEIROW + 2, NAMEICOL + 33, 4, 0, 1);
	putint(nchtotal.ncs_miss + nchtotal.ncs_long - nchtotal.ncs_pass2,
	   NAMEIROW + 2, NAMEICOL + 38, 7);
	putfloat((nchtotal.ncs_miss + nchtotal.ncs_long - nchtotal.ncs_pass2) *
	    100.0 / nz(s.nchcount), NAMEIROW + 2, NAMEICOL + 45, 4, 0, 1);
#undef nz

}

int
vm_keyboard_callback(int ch)
{
	switch(ch) {
	case 'r':
		copyinfo(&s2, &s1);
		state = RUN;
		break;
	case 'b':
		state = BOOT;
		copyinfo(&z, &s1);
		break;
	case 't':
		state = TIME;
		break;
	case 'z':
		if (state == RUN)
			getinfo(&s1);
		break;
	}
	return (keyboard_callback(ch));
}


static float
cputime(int indx)
{
	double tm;
	int i;

	tm = 0;
	for (i = 0; i < CPUSTATES; i++)
		tm += s.time[i];
	if (tm == 0.0)
		tm = 1.0;
	return (s.time[indx] * 100.0 / tm);
}

void
putint(int n, int l, int c, int w)
{
	char b[128];

	move(l, c);
	if (n == 0) {
		while (w-- > 0)
			addch(' ');
		return;
	}
	snprintf(b, sizeof b, "%*d", w, n);
	if (strlen(b) > w) {
		while (w-- > 0)
			addch('*');
		return;
	}
	addstr(b);
}

void
putintmk(int n, int l, int c, int w)
{
	char b[128];

	move(l, c);
	if (n == 0) {
		while (w-- > 0)
			addch(' ');
		return;
	}
	if (n > 9999 * 1024)
		snprintf(b, sizeof b, "%*dG", w - 1, n / 1024 / 1024);
	else if (n > 9999)
		snprintf(b, sizeof b, "%*dM", w - 1, n / 1024);
	else
		snprintf(b, sizeof b, "%*dK", w - 1, n);
	if (strlen(b) > w) {
		while (w-- > 0)
			addch('*');
		return;
	}
	addstr(b);
}

void
putuint64(u_int64_t n, int l, int c, int w)
{
	char b[128];

	move(l, c);
	if (n == 0) {
		while (w-- > 0)
			addch(' ');
		return;
	}
	snprintf(b, sizeof b, "%*llu", w, n);
	if (strlen(b) > w) {
		while (w-- > 0)
			addch('*');
		return;
	}
	addstr(b);
}

void
putfloat(double f, int l, int c, int w, int d, int nz)
{
	char b[128];

	move(l, c);
	if (nz && f == 0.0) {
		while (--w >= 0)
			addch(' ');
		return;
	}
	snprintf(b, sizeof b, "%*.*f", w, d, f);
	if (strlen(b) > w) {
		while (--w >= 0)
			addch('*');
		return;
	}
	addstr(b);
}

static void
getinfo(struct Info *si)
{
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int nchstats_mib[2] = { CTL_KERN, KERN_NCHSTATS };
	static int uvmexp_mib[2] = { CTL_VM, VM_UVMEXP };
	static int vmtotal_mib[2] = { CTL_VM, VM_METER };
	int mib[4], i;
	size_t size;

	dkreadstats();

	for (i = 0; i < nintr; i++) {
		mib[0] = CTL_KERN;
		mib[1] = KERN_INTRCNT;
		mib[2] = KERN_INTRCNT_CNT;
		mib[3] = i;
		size = sizeof(si->intrcnt[i]);
		if (sysctl(mib, 4, &si->intrcnt[i], &size, NULL, 0) < 0) {
			si->intrcnt[i] = 0;
		}
	}

	size = sizeof(si->time);
	if (sysctl(cp_time_mib, 2, &si->time, &size, NULL, 0) < 0) {
		error("Can't get KERN_CPTIME: %s\n", strerror(errno));
		memset(&si->time, 0, sizeof(si->time));
	}

	size = sizeof(si->nchstats);
	if (sysctl(nchstats_mib, 2, &si->nchstats, &size, NULL, 0) < 0) {
		error("Can't get KERN_NCHSTATS: %s\n", strerror(errno));
		memset(&si->nchstats, 0, sizeof(si->nchstats));
	}

	size = sizeof(si->uvmexp);
	if (sysctl(uvmexp_mib, 2, &si->uvmexp, &size, NULL, 0) < 0) {
		error("Can't get VM_UVMEXP: %s\n", strerror(errno));
		memset(&si->uvmexp, 0, sizeof(si->uvmexp));
	}

	size = sizeof(si->Total);
	if (sysctl(vmtotal_mib, 2, &si->Total, &size, NULL, 0) < 0) {
		error("Can't get VM_METER: %s\n", strerror(errno));
		memset(&si->Total, 0, sizeof(si->Total));
	}
}

static void
allocinfo(struct Info *si)
{
	memset(si, 0, sizeof(*si));
	si->intrcnt = calloc(nintr, sizeof(*si->intrcnt));
	if (si->intrcnt == NULL)
		errx(2, "out of memory");
}

static void
copyinfo(struct Info *from, struct Info *to)
{
	uint64_t *intrcnt;

	intrcnt = to->intrcnt;
	*to = *from;
	memcpy(to->intrcnt = intrcnt, from->intrcnt, nintr * sizeof(*intrcnt));
}

static void
dinfo(int dn, int c)
{
	double words, atime;

	c += DISKCOL;

	/* time busy in disk activity */
	atime = (double)cur.dk_time[dn].tv_sec +
	    ((double)cur.dk_time[dn].tv_usec / (double)1000000);

	/* # of K transferred */
	words = (cur.dk_rbytes[dn] + cur.dk_wbytes[dn]) / 1024.0;

	putint((int)((float)cur.dk_seek[dn]/etime+0.5), DISKROW + 1, c, 5);
	putint((int)((float)(cur.dk_rxfer[dn] + cur.dk_wxfer[dn])/etime+0.5),
	    DISKROW + 2, c, 5);
	putintmk((int)(words/etime + 0.5), DISKROW + 3, c, 5);
	putfloat(atime/etime, DISKROW + 4, c, 5, 1, 1);
}



int
select_vm(void)
{
	num_disp = 0;
	return (0);
}

int
read_vm(void)
{
	if (state == TIME)
		copyinfo(&s3, &s1);
	fetchkre();
	fetchifstat();
	if (state == TIME)
		dkswap();
	num_disp = 0;
	return 0;
}


void
print_vm(void)
{
	copyinfo(&s3, &s);
	labelkre();
	showkre();
}
@


1.81
log
@Convert quad_t to int64_t and %q to %ll
Convert bzero() to memset() and bcopy() to memcpy()

ok natano@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.80 2015/08/20 22:32:42 deraadt Exp $	*/
d297 3
a299 3
#define X(fld)	{s.fld[i]; s.fld[i]-=s1.fld[i];}
#define Y(fld)	{s.fld; s.fld -= s1.fld;}
#define Z(fld)	{s.nchstats.fld; s.nchstats.fld -= s1.nchstats.fld;}
@


1.80
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.79 2015/01/16 00:03:38 deraadt Exp $	*/
d67 1
a67 1
	u_quad_t *intrcnt;
d609 1
a609 1
		bzero(&si->time, sizeof(si->time));
d615 1
a615 1
		bzero(&si->nchstats, sizeof(si->nchstats));
d621 1
a621 1
		bzero(&si->uvmexp, sizeof(si->uvmexp));
d627 1
a627 1
		bzero(&si->Total, sizeof(si->Total));
d635 1
a635 1
	si->intrcnt = calloc(nintr, sizeof(u_quad_t));
d643 1
a643 1
	u_quad_t *intrcnt;
d647 1
a647 1
	bcopy(from->intrcnt, to->intrcnt = intrcnt, nintr * sizeof (u_quad_t));
@


1.79
log
@first batch of programs adapting to the namespace cleanup
(pfvar.h nameser.h proc.h ucred.h)
ok guenther millert, and some review from doug as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.78 2014/11/23 04:34:48 guenther Exp $	*/
d635 1
a635 1
	si->intrcnt = (u_quad_t *) calloc(nintr, sizeof(u_quad_t));
@


1.78
log
@<sys/buf.h> isn't actually needed here

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.77 2014/09/15 19:08:21 miod Exp $	*/
d37 2
a38 1
#include <sys/param.h>
d57 3
a69 1
#include "dkstats.h"
d285 1
a285 1
			l = MAX(5, strlen(dr_name[i]));
d433 1
a433 1
			l = MAX(5, strlen(dr_name[i]));
@


1.77
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.76 2014/04/08 14:04:11 mpi Exp $	*/
a37 1
#include <sys/buf.h>
@


1.76
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.75 2013/10/31 02:00:11 deraadt Exp $	*/
a37 1
#include <sys/dkstat.h>
d39 3
d43 1
a44 4
#include <sys/sysctl.h>
#include <sys/proc.h>
#include <sys/namei.h>
#include <sys/sysctl.h>
@


1.75
log
@sometimes we find .h we no longer need
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.74 2013/05/14 20:39:25 miod Exp $	*/
d46 1
a46 2

#include <uvm/uvm_extern.h>
@


1.74
log
@Don't display swapin/swapout uvmexp fields
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.73 2010/11/19 18:35:16 mikeb Exp $	*/
d42 1
a42 1
#include <sys/user.h>
d50 1
@


1.73
log
@Make KERN_CPTIME return an avarage number of ticks across all CPUs
tedu agreed with an idea, tested by Luis Useche and me; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.72 2009/10/27 23:59:44 deraadt Exp $	*/
a419 2
	PUTRATE(uvmexp.swapins, PAGEROW + 2, PAGECOL + 15, 5);
	PUTRATE(uvmexp.swapouts, PAGEROW + 2, PAGECOL + 20, 5);
@


1.72
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.71 2009/08/14 14:41:55 deraadt Exp $	*/
a161 2
int ncpu = 1;

d169 1
a169 7
	mib[0] = CTL_HW;
	mib[1] = HW_NCPU;
	size = sizeof(ncpu);
	if (sysctl(mib, 2, &ncpu, &size, NULL, 0) < 0)
		return (-1);

	hertz = stathz ? stathz : hz;
a337 1
	etime /= ncpu;
@


1.71
log
@tie IPKTS/OPKTS to bottom corner for smaller screens
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.70 2009/08/13 23:45:35 deraadt Exp $	*/
a31 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)vmstat.c	8.2 (Berkeley) 1/12/94";
#endif
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.70 2009/08/13 23:45:35 deraadt Exp $";
#endif /* not lint */
@


1.70
log
@there are louder and louder moans about the inability to see packet
rates at the same time as interrupt counts, so sneak them into the
bottom corner of the vmstat screen
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.69 2009/05/03 05:01:54 drahn Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.69 2009/05/03 05:01:54 drahn Exp $";
d254 2
a255 4
	if (LINES - 1 > VMSTATROW + 17)
		mvprintw(VMSTATROW + 17, INTSCOL + 9, "IPKTS");
	if (LINES - 1 > VMSTATROW + 18)
		mvprintw(VMSTATROW + 18, INTSCOL + 9, "OPKTS");
d377 2
a378 4
	if (LINES - 1 > VMSTATROW + 17)
		putint(sum.ifc_ip, VMSTATROW + 17, INTSCOL, 8);
	if (LINES - 1 > VMSTATROW + 18)
		putint(sum.ifc_op, VMSTATROW + 18, INTSCOL, 8);
@


1.69
log
@Hinge at the natural rollover point 9999x instead of 1024x when switching to
the next unit K->M->G. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.68 2009/03/30 05:35:22 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.68 2009/03/30 05:35:22 deraadt Exp $";
d254 5
d379 5
d478 1
d707 1
@


1.68
log
@allow the disk transfer speed numbers to show useable numbers when disks
get really fast; ok canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.67 2008/12/07 02:56:06 canacar Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.67 2008/12/07 02:56:06 canacar Exp $";
d539 1
a539 1
	if (n > 1024 * 1024)
d541 1
a541 1
	else if (n > 1024)
@


1.67
log
@Warning cleanup including unused variables and shadowed names
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.66 2008/11/01 00:56:25 canacar Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.66 2008/11/01 00:56:25 canacar Exp $";
d92 1
d292 1
a292 1
	mvprintw(DISKROW + 3, DISKCOL, "Kbyte");
d529 25
d677 1
a677 1
	putint((int)(words/etime + 0.5), DISKROW + 3, c, 5);
@


1.66
log
@Improve reporting of cache misses in the vmstat view. Previously
the misses field may report negative values. The hit/miss numbers
does not exactly reflect the statistics collected by the kernel
but this is close enough.

Report & patch from Bjorn Anderss, input from beck@@ and thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.65 2008/06/13 10:06:14 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.65 2008/06/13 10:06:14 deraadt Exp $";
d496 1
a496 1
	double t;
d499 1
a499 1
	t = 0;
d501 4
a504 4
		t += s.time[i];
	if (t == 0.0)
		t = 1.0;
	return (s.time[indx] * 100.0 / t);
d568 1
a568 1
getinfo(struct Info *s)
d584 3
a586 3
		size = sizeof(s->intrcnt[i]);
		if (sysctl(mib, 4, &s->intrcnt[i], &size, NULL, 0) < 0) {
			s->intrcnt[i] = 0;
d590 2
a591 2
	size = sizeof(s->time);
	if (sysctl(cp_time_mib, 2, &s->time, &size, NULL, 0) < 0) {
d593 1
a593 1
		bzero(&s->time, sizeof(s->time));
d596 2
a597 2
	size = sizeof(s->nchstats);
	if (sysctl(nchstats_mib, 2, &s->nchstats, &size, NULL, 0) < 0) {
d599 1
a599 1
		bzero(&s->nchstats, sizeof(s->nchstats));
d602 2
a603 2
	size = sizeof(s->uvmexp);
	if (sysctl(uvmexp_mib, 2, &s->uvmexp, &size, NULL, 0) < 0) {
d605 1
a605 1
		bzero(&s->uvmexp, sizeof(s->uvmexp));
d608 2
a609 2
	size = sizeof(s->Total);
	if (sysctl(vmtotal_mib, 2, &s->Total, &size, NULL, 0) < 0) {
d611 1
a611 1
		bzero(&s->Total, sizeof(s->Total));
d616 1
a616 1
allocinfo(struct Info *s)
d618 3
a620 3
	memset(s, 0, sizeof(*s));
	s->intrcnt = (u_quad_t *) calloc(nintr, sizeof(u_quad_t));
	if (s->intrcnt == NULL)
@


1.65
log
@compile on older gcc; no decl after code
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.64 2008/06/12 22:26:01 canacar Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.64 2008/06/12 22:26:01 canacar Exp $";
d462 1
a462 1
	putint(nchtotal.ncs_miss - nchtotal.ncs_pass2,
d464 1
a464 1
	putfloat((nchtotal.ncs_miss - nchtotal.ncs_pass2) *
@


1.64
log
@New display engine for systat, based on pftop. Adds new views for pf
(status, state, rule, queue). While all displays work, some keyboard
comands are not implemented yet. Other features include better handling
of display resize and scrolling for long views. Committing now to fix
the remaining issues in the tree.
Testing and comments by otto@@ and harding@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.63 2007/09/01 19:32:19 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.63 2007/09/01 19:32:19 deraadt Exp $";
d173 1
a222 2
	field_view *v;
	
@


1.63
log
@malloc(n * m) -> calloc(n, m); from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.62 2007/02/25 18:21:24 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.62 2007/02/25 18:21:24 deraadt Exp $";
a64 1
#include "extern.h"
d73 1
a73 1
} s, s1, s2, z;
d96 5
d152 16
d171 1
a171 1
initkre(void)
d216 1
d220 7
a226 1
	copyinfo(&s2, &s1);
d233 1
a233 1
	getinfo(&s);
d308 3
a310 4
#define X(fld)	{t=s.fld[i]; s.fld[i]-=s1.fld[i]; if (state==TIME) s1.fld[i]=t;}
#define Y(fld)	{t = s.fld; s.fld -= s1.fld; if (state == TIME) s1.fld = t;}
#define Z(fld)	{t = s.nchstats.fld; s.nchstats.fld -= s1.nchstats.fld; \
	if (state == TIME) s1.nchstats.fld = t;}
a330 1
		dkswap();
d343 1
a343 5
			clear();
			mvprintw(2, 10, "The alternate system clock has died!");
			mvprintw(3, 10, "Reverting to ``pigs'' display.");
			move(CMDLINE, 0);
			refresh();
a344 2
			sleep(5);
			command("pigs");
a363 2
		if (state == TIME)
			s1.intrcnt[i] = intcnt;
a372 2
	if (state == TIME)
		s1.nchcount = s.nchcount;
d471 1
a471 1
cmdkre(char *cmd, char *args)
d473 2
a474 2

	if (prefix(cmd, "run")) {
d477 2
a478 3
		return (1);
	}
	if (prefix(cmd, "boot")) {
d481 2
a482 3
		return (1);
	}
	if (prefix(cmd, "time")) {
d484 2
a485 3
		return (1);
	}
	if (prefix(cmd, "zero")) {
d488 1
a488 1
		return (1);
d490 1
a490 1
	return (dkcmd(cmd, args));
d493 1
d619 1
a619 1

d654 30
@


1.62
log
@use the 1 line load line from 'systat vm' on all the other displays, giving
them more room.  much cleaner, and it is less code too; ok deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.61 2006/11/13 19:03:51 otto Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.61 2006/11/13 19:03:51 otto Exp $";
d607 1
a607 1
	s->intrcnt = (u_quad_t *) malloc(nintr * sizeof(u_quad_t));
@


1.61
log
@fix macro abuse leading to stray numbers in the vm display.
ok a whole lot of devs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.60 2006/04/14 01:14:56 dlg Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.60 2006/04/14 01:14:56 dlg Exp $";
a61 1
#include <utmp.h>
d92 4
a95 4
static void putint(int, int, int, int);
static void putuint64(u_int64_t, int, int, int);
static void putfloat(double, int, int, int, int, int);
static int ucount(void);
a96 2
static	int ut;
static	char buf[26];
a104 2
struct	utmp utmp;

d108 1
a108 5

	ut = open(_PATH_UTMP, O_RDONLY);
	if (ut < 0)
		error("No utmp");
	return (stdscr);
a114 1
	(void) close(ut);
d119 1
a121 1

a205 4
	time_t now;

	time(&now);
	strlcpy(buf, ctime(&now), sizeof buf);
a213 2
	clear();
	mvprintw(STATROW, STATCOL + 4, "users    Load");
a373 5
	putint(ucount(), STATROW, STATCOL, 3);
	putfloat(avenrun[0], STATROW, STATCOL + 17, 6, 2, 0);
	putfloat(avenrun[1], STATROW, STATCOL + 23, 6, 2, 0);
	putfloat(avenrun[2], STATROW, STATCOL + 29, 6, 2, 0);
	mvaddstr(STATROW, STATCOL + 53, buf);
a480 16
/* calculate number of users on the system */
static int
ucount(void)
{
	int nusers = 0;

	if (ut < 0)
		return (0);
	while (read(ut, &utmp, sizeof(utmp)))
		if (utmp.ut_name[0] != '\0')
			nusers++;

	lseek(ut, 0, SEEK_SET);
	return (nusers);
}

d495 1
a495 1
static void
d515 1
a515 1
static void
d535 1
a535 1
static void
@


1.60
log
@remove comments that says we dont count intr time and remove some code that
fudges the output to stay clean when intr time wasnt shown. not needed
since we show it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.59 2006/04/14 01:08:15 dlg Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.59 2006/04/14 01:08:15 dlg Exp $";
d302 4
a305 2
	Y(fld); \
	putint((int)((float)s.fld/etime + 0.5), l, c, w)
@


1.59
log
@show cpu time spent in interrupts. ive been wanting this for years.

tweaks by deraadt@@ ok by many
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.58 2006/03/31 18:19:44 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.58 2006/03/31 18:19:44 deraadt Exp $";
a375 3
	/*
	 * Last CPU state not calculated yet.
	 */
a386 10

	/*
	 * The above code does not account for time in the CP_INTR state.
	 * Thus the total may be less than 100%.  If the total is less than
	 * the previous total old data may be left on the graph.  The graph
	 * assumes one character position for every 2 percentage points for
	 * a total of 50 positions.  Ensure all positions have been filled.
	 */
	while ( psiz++ <= 50 )
		addch(' ');
@


1.58
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.57 2006/03/31 04:10:59 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.57 2006/03/31 04:10:59 deraadt Exp $";
d269 1
a269 1
	    "    . %% Sys    . %% User    . %% Nice    . %% Idle");
d306 2
a307 2
static	char cpuchar[CPUSTATES] = { '=' , '>', '-', ' ' };
static	char cpuorder[CPUSTATES] = { CP_SYS, CP_USER, CP_NICE, CP_IDLE };
d379 1
a379 1
	for (c = 0; c < CPUSTATES - 1; c++) {
d384 1
a384 5
		if (c == 0)
			putfloat(f1, GRAPHROW, GRAPHCOL + 1, 5, 1, 0);
		else
			putfloat(f1, GRAPHROW, GRAPHCOL + 12 * c,
			    5, 1, 0);
@


1.57
log
@fairly simple cleanup, lots of testing done
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.56 2006/03/28 09:03:46 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.56 2006/03/28 09:03:46 mickey Exp $";
d188 1
a188 1
 
@


1.56
log
@give more space to the memory columns in vm page; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.55 2005/09/28 00:24:04 pedro Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.55 2005/09/28 00:24:04 pedro Exp $";
d92 1
a92 1
static void getinfo(struct Info *, enum state);
d163 1
a163 1
	int mib[4], i, ret;
d208 1
a208 1
	getinfo(&s2, RUN);
d220 1
a220 1
	getinfo(&s, state);
d511 1
a511 1
			getinfo(&s1, RUN);
d608 1
a608 1
getinfo(struct Info *s, enum state st)
@


1.55
log
@- when we run out of static kernel map entries, grab a fresh page using
  the uvm_km_page allocator and use it instead of calling panic()
- add a counter to uvmexp so we can keep track of how many map entries
  we have in use

idea from tedu@@, long ago, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.54 2005/04/04 08:54:33 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.54 2005/04/04 08:54:33 deraadt Exp $";
d137 1
a137 1
#define MEMROW		 2	/* uses 4 rows and 31 cols */
d230 2
a231 2
	mvprintw(MEMROW, MEMCOL,     "          memory totals (in KB)");
	mvprintw(MEMROW + 1, MEMCOL, "         real   virtual    free");
d412 1
a412 1
	putint(pgtokb(s.uvmexp.active), MEMROW + 2, MEMCOL + 6, 7);
d414 2
a415 2
	    MEMROW + 2, MEMCOL + 16, 7);
	putint(pgtokb(s.uvmexp.npages - s.uvmexp.free), MEMROW + 3, MEMCOL + 6, 7);
d417 2
a418 2
	    MEMROW + 3, MEMCOL + 16, 7);
	putint(pgtokb(s.uvmexp.free), MEMROW + 2, MEMCOL + 24, 7);
d420 1
a420 1
	    MEMROW + 3, MEMCOL + 24, 7);
@


1.54
log
@nlist.h not needed
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.53 2004/09/23 21:10:21 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.53 2004/09/23 21:10:21 deraadt Exp $";
d147 1
a147 1
#define VMSTATROW	 7	/* uses 17 rows and 12 cols */
d263 2
d446 2
@


1.53
log
@adapt to KERN_INTRCNT_CNT returning a quad, from danh (imported now to
avoid tree breakage)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.52 2004/07/09 16:32:54 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.52 2004/07/09 16:32:54 deraadt Exp $";
a57 1
#include <nlist.h>
@


1.52
log
@remove post-mortem stuff (sysctl only here)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.51 2004/06/28 01:45:51 aaron Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.51 2004/06/28 01:45:51 aaron Exp $";
d75 1
a75 1
	int	*intrcnt;
d95 1
d312 2
a313 1
	int psiz, inttotal;
d356 7
a362 4
		X(intrcnt);
		l = (int)((float)s.intrcnt[i]/etime + 0.5);
		inttotal += l;
		putint(l, intrloc[i], INTSCOL, 8);
d364 1
a364 1
	putint(inttotal, INTSROW + 1, INTSCOL, 8);
d565 20
d622 1
a622 1
		if (sysctl(mib, 4, &s->intrcnt[i], &size, NULL, 0) < 0)
d624 1
d656 1
a656 1
	s->intrcnt = (int *) malloc(nintr * sizeof(int));
d664 1
a664 1
	int *intrcnt;
d668 1
a668 1
	bcopy(from->intrcnt, to->intrcnt = intrcnt, nintr * sizeof (int));
@


1.51
log
@Remove special #if defined(__i386__) code from systat and vmstat.  We now use
sysctl to fetch interrupt counters on all architectures.  Also add new '-z'
flag to vmstat which means show all devices, even those that have not yet
generated an interrupt.  deraadt@@ tholo@@ drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.50 2004/06/11 06:31:32 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.50 2004/06/11 06:31:32 deraadt Exp $";
a131 12
static struct nlist namelist[] = {
#define	X_INTRNAMES	0		/* no sysctl */
	{ "_intrnames" },
#define	X_EINTRNAMES	1		/* no sysctl */
	{ "_eintrnames" },
#define	X_INTRCNT	2		/* no sysctl */
	{ "_intrcnt" },
#define	X_EINTRCNT	3		/* no sysctl */
	{ "_eintrcnt" },
	{ "" },
};

a164 11

	if (namelist[0].n_type == 0) {
		if ((ret = kvm_nlist(kd, namelist)) == -1)
			errx(1, "%s", kvm_geterr(kd));
		else if (ret > 1)
			nlisterr(namelist);
		if (namelist[0].n_type == 0) {
			error("No namelist");
			return(0);
		}
	}
@


1.50
log
@divide etime by ncpu
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.48 2004/06/11 05:55:43 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.48 2004/06/11 05:55:43 deraadt Exp $";
a65 6
#if defined(__i386__)
#define	_KERNEL
#include <machine/psl.h>
#undef _KERNEL
#endif

a140 6
#if defined(__i386__)
#define	X_INTRHAND	4		/* no sysctl */
	{ "_intrhand" },
#define	X_APICINTRHAND	5		/* no sysctl */
	{ "_apic_intrhand" },
#endif
d175 2
a176 3
	char *intrnamebuf, *cp;
	size_t size = sizeof(ncpu);
	int mib[2], i, ret;
a180 4
#if defined(__i386__)
		else if (ret == 1 && namelist[X_APICINTRHAND].n_value != 0)
			nlisterr(namelist);
#endif
d191 3
a193 2
	if (sysctl(mib, 2, &ncpu, &size, NULL, 0) == -1)
                return (-1);
d198 33
a230 90
	if (nintr == 0) {
#if defined(__i386__)
		struct intrhand *intrhand[16], *ihp, ih;
		struct intrhand *apicintrhand[256];
		char iname[16];
		int namelen, n;

		NREAD(X_INTRHAND, intrhand, sizeof(intrhand));
		for (namelen = 0, i = 0; i < 16; i++) {
			ihp = intrhand[i];
			while (ihp) {
				nintr++;
				KREAD(ihp, &ih, sizeof(ih));
				KREAD(ih.ih_what, iname, 16);
				namelen += strlen(iname) + 1;
				ihp = ih.ih_next;
			}
		}
		if (namelist[X_APICINTRHAND].n_value) {
			NREAD(X_APICINTRHAND, apicintrhand, sizeof(apicintrhand));
			for (namelen = 0, i = 0; i < 256; i++) {
				ihp = apicintrhand[i];
				while (ihp) {
					nintr++;
					KREAD(ihp, &ih, sizeof(ih));
					KREAD(ih.ih_what, iname, 16);
					namelen += strlen(iname) + 1;
					printf("apic handler %x %s\n", i, iname);
					ihp = ih.ih_next;
				}
			}
		}		
		intrloc = calloc(nintr, sizeof (long));
		intrname = calloc(nintr, sizeof (char *));
		cp = intrnamebuf = malloc(namelen);
		for (i = 0, n = 0; i < 16; i++) {
			ihp = intrhand[i];
			while (ihp) {
				KREAD(ihp, &ih, sizeof(ih));
				KREAD(ih.ih_what, iname, 16);
				intrname[n++] = cp;
				strlcpy(cp, iname, intrnamebuf + namelen - cp);
				cp += strlen(iname) + 1;
				ihp = ih.ih_next;
			}
		}
		if (namelist[X_APICINTRHAND].n_value) {
			for (i = 0, n = 0; i < 256; i++) {
				ihp = apicintrhand[i];
				while (ihp) {
					KREAD(ihp, &ih, sizeof(ih));
					KREAD(ih.ih_what, iname, 16);
					intrname[n++] = cp;
					strlcpy(cp, iname, intrnamebuf + namelen - cp);
					cp += strlen(iname) + 1;
					ihp = ih.ih_next;
				}
			}
		}
#else
		nintr = (namelist[X_EINTRCNT].n_value -
		    namelist[X_INTRCNT].n_value) / sizeof (int);
		intrloc = calloc(nintr, sizeof (long));
		intrname = calloc(nintr, sizeof (long));
		intrnamebuf = malloc(namelist[X_EINTRNAMES].n_value -
		    namelist[X_INTRNAMES].n_value);
		if (intrnamebuf == 0 || intrname == 0 || intrloc == 0) {
			error("Out of memory\n");
			if (intrnamebuf)
				free(intrnamebuf);
			if (intrname)
				free(intrname);
			if (intrloc)
				free(intrloc);
			nintr = 0;
			return(0);
		}
		NREAD(X_INTRNAMES, intrnamebuf, NVAL(X_EINTRNAMES) -
		    NVAL(X_INTRNAMES));
		for (cp = intrnamebuf, i = 0; i < nintr; i++) {
			intrname[i] = cp;
			cp += strlen(cp) + 1;
		}
#endif
		nextintsrow = INTSROW + 2;
		allocinfo(&s);
		allocinfo(&s1);
		allocinfo(&s2);
		allocinfo(&z);
	}
d609 1
a610 5
#if defined(__i386__)
	struct intrhand *intrhand[16], *ihp, ih;
	struct intrhand *apicintrhand[256];
	int i, n;
#endif
d613 9
a621 9
#if defined(__i386__)
	NREAD(X_INTRHAND, intrhand, sizeof(intrhand));
	for (i = 0, n = 0; i < 16; i++) {
		ihp = intrhand[i];
		while (ihp) {
			KREAD(ihp, &ih, sizeof(ih));
			s->intrcnt[n++] = ih.ih_count;
			ihp = ih.ih_next;
		}
d623 1
a623 14
	if (namelist[X_APICINTRHAND].n_value) {
		NREAD(X_APICINTRHAND, apicintrhand, sizeof(apicintrhand));
		for (i = 0, n = 0; i < 256; i++) {
			ihp = apicintrhand[i];
			while (ihp) {
				KREAD(ihp, &ih, sizeof(ih));
				s->intrcnt[n++] = ih.ih_count;
				ihp = ih.ih_next;
			}
		}
	}
#else
	NREAD(X_INTRCNT, s->intrcnt, nintr * sizeof(int));
#endif
@


1.49
log
@oops
@
text
@d182 2
d188 2
a189 1
	int i, ret;
d205 6
d438 1
@


1.48
log
@on i386 machines, attempt to peek inside apic_intrhand[] as well, so that
MP machines get interrupt counters.  will be replaced by a MI subsystem
one day.  most code from drahn, few final bugs fixed by me
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.48 2004/06/11 05:53:58 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.48 2004/06/11 05:53:58 deraadt Exp $";
d192 1
a192 1
		else if (ret > 1 && namelist[X_APICINTRHAND].n_value == 0)
d195 1
a195 1
		else if (ret)
@


1.47
log
@with modern disks data transfers rates above 10000 kByte/s are seen
regularily, make the disk columns a little wider so it doesn't run into
the neighboring column, theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.46 2004/04/23 04:15:27 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.46 2004/04/23 04:15:27 tedu Exp $";
d150 2
d191 4
d208 1
d223 14
d251 13
d675 1
d688 11
@


1.46
log
@don't print stats until they're stable, prevents seeing weird stuff in
disk columns.  tested by jolan@@.  from pedro martelletto
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.45 2004/02/15 22:56:12 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.45 2004/02/15 22:56:12 tedu Exp $";
d336 1
a336 1
			l = MAX(4, strlen(dr_name[i]));
d509 1
a509 1
			l = MAX(4, strlen(dr_name[i]));
@


1.45
log
@'split' command for iostat mode
from Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.44 2004/02/15 02:45:47 tedu Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.44 2004/02/15 02:45:47 tedu Exp $";
d366 1
a366 1
	static int failcnt = 0;
d368 1
a368 1
	if (state == TIME)
d370 5
@


1.44
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.43 2003/10/16 07:09:09 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.43 2003/10/16 07:09:09 mickey Exp $";
d329 1
a329 1
	mvprintw(DISKROW, DISKCOL, "Discs");
@


1.43
log
@duh
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.42 2003/10/15 20:01:32 mickey Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.42 2003/10/15 20:01:32 mickey Exp $";
d708 2
a709 1
	words = cur.dk_bytes[dn] / 1024.0;	/* # of K transferred */
d712 2
a713 1
	putint((int)((float)cur.dk_xfer[dn]/etime+0.5), DISKROW + 2, c, 5);
@


1.42
log
@also print the  uvmexp.zeropages if there is space in vm screen
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.41 2003/06/03 02:56:17 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.41 2003/06/03 02:56:17 millert Exp $";
d486 1
a486 1
		PUTRATE(uvmexp.zeropages, VMSTATROW + 16, VMSTATCOL, 9);
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.40 2003/04/14 04:45:45 deraadt Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.40 2003/04/14 04:45:45 deraadt Exp $";
d314 2
d485 2
@


1.40
log
@remove old comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.39 2003/04/08 00:53:09 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.39 2003/04/08 00:53:09 deraadt Exp $";
@


1.39
log
@string cleaning; ok tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.38 2003/02/28 21:29:07 jason Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.38 2003/02/28 21:29:07 jason Exp $";
a227 1
				/* XXX strcpy is safe, sized & malloc'd buffer */
@


1.38
log
@intrcnt's are ints not longs (at least according to the new kern.intrcnt stuff)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.37 2002/12/16 01:57:04 tdeval Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.37 2002/12/16 01:57:04 tdeval Exp $";
d216 1
a216 1
				namelen += 1 + strlen(iname);
d223 1
a223 1
		for (namelen = 0, i = 0, n = 0; i < 16; i++) {
d229 3
a231 2
				strcpy(intrname[n++] = intrnamebuf + namelen, iname);
				namelen += 1 + strlen(iname);
@


1.37
log
@Make systat(1), iostat(8) and vmstat(8) automatically update their disk
statistics when a device is added/removed.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.36 2002/06/19 08:45:52 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.36 2002/06/19 08:45:52 deraadt Exp $";
d85 1
a85 1
	long	*intrcnt;
d236 1
a236 1
		    namelist[X_INTRCNT].n_value) / sizeof (long);
d651 1
a651 1
	NREAD(X_INTRCNT, s->intrcnt, nintr * sizeof(long));
d682 1
a682 1
	s->intrcnt = (long *) malloc(nintr * sizeof(long));
d690 1
a690 1
	long *intrcnt;
@


1.36
log
@mark which nlist[] kmem entries are not needed in the sysctl case, and which are
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.35 2002/06/18 00:46:48 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.35 2002/06/18 00:46:48 deraadt Exp $";
d336 2
a337 2
	for (i = 0, j = 0; i < dk_ndrive && j < DRIVESPACE; i++)
		if (dk_select[i] && (j + strlen(dr_name[i])) < DRIVESPACE) {
d502 2
a503 2
	for (i = 0, c = 0; i < dk_ndrive && c < DRIVESPACE; i++)
		if (dk_select[i] && (c + strlen(dr_name[i])) < DRIVESPACE) {
@


1.35
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.34 2002/04/29 17:28:12 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.34 2002/04/29 17:28:12 millert Exp $";
d143 1
a143 1
#define	X_INTRNAMES	0
d145 1
a145 1
#define	X_EINTRNAMES	1
d147 1
a147 1
#define	X_INTRCNT	2
d149 1
a149 1
#define	X_EINTRCNT	3
d152 1
a152 1
#define	X_INTRHAND	4
@


1.34
log
@Fix 32bit int oflow when there is > 2GB vm; peters AT telia DOT net
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.33 2002/02/16 21:27:54 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.33 2002/02/16 21:27:54 millert Exp $";
d121 1
a121 1
openkre()
d131 1
a131 2
closekre(w)
	WINDOW *w;
d143 1
a143 3
#define	X_HZ		0
	{ "_hz" },
#define	X_INTRNAMES	1
d145 1
a145 1
#define	X_EINTRNAMES	2
d147 1
a147 1
#define	X_INTRCNT	3
d149 1
a149 1
#define	X_EINTRCNT	4
d152 1
a152 1
#define	X_INTRHAND	5
d185 1
a185 1
initkre()
d271 1
a271 1
fetchkre()
d281 1
a281 1
labelkre()
d350 2
a351 2
#define X(fld)	{t=s.fld[i]; s.fld[i]-=s1.fld[i]; if(state==TIME) s1.fld[i]=t;}
#define Y(fld)	{t = s.fld; s.fld -= s1.fld; if(state == TIME) s1.fld = t;}
d353 1
a353 1
	if(state == TIME) s1.nchstats.fld = t;}
d363 1
a363 1
showkre()
d373 1
a373 1
	for(i = 0; i < CPUSTATES; i++) {
d510 1
a510 1
	/* and pad the DRIVESPACE */ 
d531 1
a531 2
cmdkre(cmd, args)
	char *cmd, *args;
d558 1
a558 1
ucount()
d573 1
a573 2
cputime(indx)
	int indx;
d587 1
a587 2
putint(n, l, c, w)
	int n, l, c, w;
d607 1
a607 3
putfloat(f, l, c, w, d, nz)
	double f;
	int l, c, w, d, nz;
d627 1
a627 3
getinfo(s, st)
	struct Info *s;
	enum state st;
d679 1
a679 2
allocinfo(s)
	struct Info *s;
d688 1
a688 2
copyinfo(from, to)
	struct Info *from, *to;
d698 1
a698 2
dinfo(dn, c)
	int dn, c;
@


1.33
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.32 2002/02/16 00:18:09 tdeval Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.32 2002/02/16 00:18:09 tdeval Exp $";
d456 1
a456 1
#define pgtokb(pg)	((pg) * s.uvmexp.pagesize / 1024)
@


1.32
log
@Some disk names are longer than 4.  Cope with that.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.31 2001/12/07 09:18:08 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.31 2001/12/07 09:18:08 deraadt Exp $";
d99 8
a106 8
static void allocinfo __P((struct Info *));
static void copyinfo __P((struct Info *, struct Info *));
static float cputime __P((int));
static void dinfo __P((int, int));
static void getinfo __P((struct Info *, enum state));
static void putint __P((int, int, int, int));
static void putfloat __P((double, int, int, int, int, int));
static int ucount __P((void));
@


1.31
log
@move back.  pvalchev -- the bug was quite obscure
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.29 2001/11/23 22:20:06 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.29 2001/11/23 22:20:06 deraadt Exp $";
d185 1
a185 7
#define	DRIVESPACE	 9	/* max # for space */

#if DK_NDRIVE > DRIVESPACE
#define	MAXDRIVES	DRIVESPACE	 /* max # to display */
#else
#define	MAXDRIVES	DK_NDRIVE	 /* max # to display */
#endif
d286 1
a286 1
	int i, j;
d339 6
a344 6
	j = 0;
	for (i = 0; i < dk_ndrive && j < MAXDRIVES; i++)
		if (dk_select[i]) {
			mvprintw(DISKROW, DISKCOL + 5 + 5 * j,
			    " %4.4s", dr_name[j]);
			j++;
d505 7
a511 5
	for (i = 0, c = 0; i < dk_ndrive && c < MAXDRIVES; i++)
		if (dk_select[i]) {
			mvprintw(DISKROW, DISKCOL + 5 + 5 * c,
			    " %4.4s", dr_name[i]);
			dinfo(i, ++c);
d513 5
d715 1
a715 1
	c = DISKCOL + c * 5;
@


1.30
log
@back out latest changes which cause problems on alpha/sparc64 until
they are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.28 2001/11/19 19:02:16 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.28 2001/11/19 19:02:16 mpech Exp $";
a90 1

a119 1

d144 3
a146 7
#define X_CPTIME	0
	{ "_cp_time" },
#define X_UVMEXP	1
	{ "_uvmexp" },
#define	X_NCHSTATS	2
	{ "_nchstats" },
#define	X_INTRNAMES	3
d148 1
a148 1
#define	X_EINTRNAMES	4
d150 1
a150 1
#define	X_INTRCNT	5
d152 1
a152 1
#define	X_EINTRCNT	6
d155 1
a155 1
#define	X_INTRHAND	7
a197 1
	static int once = 0;
d210 1
a210 1
	if (! dkinit(1))
a211 9
	if (dk_ndrive && !once) {
#define	allocate(e, t) \
    s./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    s1./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    s2./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    z./**/e = (t *)calloc(dk_ndrive, sizeof (t));
		once = 1;
#undef allocate
	}
d237 1
a237 1
				/* XXX strcpy is safe, sized & malloc'd buffer */ 
d245 1
a245 1
			namelist[X_INTRCNT].n_value) / sizeof (long);
d249 1
a249 1
			namelist[X_INTRNAMES].n_value);
d262 1
a262 1
			NVAL(X_INTRNAMES));
d331 1
a331 1
		"    . %% Sys    . %% User    . %% Nice    . %% Idle");
d334 1
a334 1
		"|    |    |    |    |    |    |    |    |    |    |");
d337 1
a337 1
		"Namei         Sys-cache    Proc-cache    No-cache");
d339 1
a339 1
		"    Calls     hits    %%    hits     %%    miss   %%");
d349 1
a349 1
				" %4.4s", dr_name[j]);
a378 1
	
d410 1
a410 1
				intrname[i]);
d428 1
a428 1
	/* 
d440 1
a440 1
				5, 1, 0);
d462 1
a462 1
#define pgtokb(pg)     ((pg) * s.uvmexp.pagesize / 1024)
d514 1
a514 1
				" %4.4s", dr_name[i]);
d521 1
a521 1
	   NAMEIROW + 2, NAMEICOL + 19, 4, 0, 1);
d524 1
a524 1
	   NAMEIROW + 2, NAMEICOL + 33, 4, 0, 1);
d528 1
a528 1
	   100.0 / nz(s.nchcount), NAMEIROW + 2, NAMEICOL + 45, 4, 0, 1);
d638 4
a641 1
	int mib[2];
a642 1
	extern int errno;
a648 3
	NREAD(X_CPTIME, s->time, sizeof s->time);
	NREAD(X_UVMEXP, &s->uvmexp, sizeof s->uvmexp);
	NREAD(X_NCHSTATS, &s->nchstats, sizeof s->nchstats);
d660 1
a660 1
	NREAD(X_INTRCNT, s->intrcnt, nintr * LONG);
d662 18
d681 2
a682 4
	mib[0] = CTL_VM;
	mib[1] = VM_METER;
	if (sysctl(mib, 2, &s->Total, &size, NULL, 0) < 0) {
		error("Can't get kernel info: %s\n", strerror(errno));
d718 1
a718 1
		((double)cur.dk_time[dn].tv_usec / (double)1000000);
@


1.29
log
@fix signal races.  use sysctl() instead of kvm where possible, and then KNF
the hell out of it; checked by miod
@
text
@d91 1
d121 1
d146 7
a152 1
#define	X_INTRNAMES	0
d154 1
a154 1
#define	X_EINTRNAMES	1
d156 1
a156 1
#define	X_INTRCNT	2
d158 1
a158 1
#define	X_EINTRCNT	3
d161 1
a161 1
#define	X_INTRHAND	4
d204 1
d217 1
a217 1
	if (!dkinit(1))
d219 9
d253 1
a253 1
				/* XXX strcpy is safe, sized & malloc'd buffer */
d261 1
a261 1
		    namelist[X_INTRCNT].n_value) / sizeof (long);
d265 1
a265 1
		    namelist[X_INTRNAMES].n_value);
d278 1
a278 1
		    NVAL(X_INTRNAMES));
d347 1
a347 1
	    "    . %% Sys    . %% User    . %% Nice    . %% Idle");
d350 1
a350 1
	    "|    |    |    |    |    |    |    |    |    |    |");
d353 1
a353 1
	    "Namei         Sys-cache    Proc-cache    No-cache");
d355 1
a355 1
	    "    Calls     hits    %%    hits     %%    miss   %%");
d365 1
a365 1
			    " %4.4s", dr_name[j]);
d395 1
d427 1
a427 1
			    intrname[i]);
d445 1
a445 1
	/*
d457 1
a457 1
			    5, 1, 0);
d479 1
a479 1
#define pgtokb(pg)	((pg) * s.uvmexp.pagesize / 1024)
d531 1
a531 1
			    " %4.4s", dr_name[i]);
d538 1
a538 1
	    NAMEIROW + 2, NAMEICOL + 19, 4, 0, 1);
d541 1
a541 1
	    NAMEIROW + 2, NAMEICOL + 33, 4, 0, 1);
d545 1
a545 1
	    100.0 / nz(s.nchcount), NAMEIROW + 2, NAMEICOL + 45, 4, 0, 1);
d655 1
a655 4
	static int cp_time_mib[] = { CTL_KERN, KERN_CPTIME };
	static int nchstats_mib[2] = { CTL_KERN, KERN_NCHSTATS };
	static int uvmexp_mib[2] = { CTL_VM, VM_UVMEXP };
	static int vmtotal_mib[2] = { CTL_VM, VM_METER };
d657 1
d664 3
d678 1
a678 1
	NREAD(X_INTRCNT, s->intrcnt, nintr * sizeof(long));
a679 18
	size = sizeof(s->time);
	if (sysctl(cp_time_mib, 2, &s->time, &size, NULL, 0) < 0) {
		error("Can't get KERN_CPTIME: %s\n", strerror(errno));
		bzero(&s->time, sizeof(s->time));
	}

	size = sizeof(s->nchstats);
	if (sysctl(nchstats_mib, 2, &s->nchstats, &size, NULL, 0) < 0) {
		error("Can't get KERN_NCHSTATS: %s\n", strerror(errno));
		bzero(&s->nchstats, sizeof(s->nchstats));
	}

	size = sizeof(s->uvmexp);
	if (sysctl(uvmexp_mib, 2, &s->uvmexp, &size, NULL, 0) < 0) {
		error("Can't get VM_UVMEXP: %s\n", strerror(errno));
		bzero(&s->uvmexp, sizeof(s->uvmexp));
	}

d681 4
a684 2
	if (sysctl(vmtotal_mib, 2, &s->Total, &size, NULL, 0) < 0) {
		error("Can't get VM_METER: %s\n", strerror(errno));
d720 1
a720 1
	    ((double)cur.dk_time[dn].tv_usec / (double)1000000);
@


1.28
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.27 2001/11/18 23:56:49 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.27 2001/11/18 23:56:49 deraadt Exp $";
a90 1

a119 1

d144 1
a144 7
#define X_CPTIME	0
	{ "_cp_time" },
#define X_UVMEXP	1
	{ "_uvmexp" },
#define	X_NCHSTATS	2
	{ "_nchstats" },
#define	X_INTRNAMES	3
d146 1
a146 1
#define	X_EINTRNAMES	4
d148 1
a148 1
#define	X_INTRCNT	5
d150 1
a150 1
#define	X_EINTRCNT	6
d153 1
a153 1
#define	X_INTRHAND	7
a195 1
	static int once = 0;
d208 1
a208 1
	if (! dkinit(1))
a209 9
	if (dk_ndrive && !once) {
#define	allocate(e, t) \
    s./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    s1./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    s2./**/e = (t *)calloc(dk_ndrive, sizeof (t)); \
    z./**/e = (t *)calloc(dk_ndrive, sizeof (t));
		once = 1;
#undef allocate
	}
d235 1
a235 1
				/* XXX strcpy is safe, sized & malloc'd buffer */ 
d243 1
a243 1
			namelist[X_INTRCNT].n_value) / sizeof (long);
d247 1
a247 1
			namelist[X_INTRNAMES].n_value);
d260 1
a260 1
			NVAL(X_INTRNAMES));
d329 1
a329 1
		"    . %% Sys    . %% User    . %% Nice    . %% Idle");
d332 1
a332 1
		"|    |    |    |    |    |    |    |    |    |    |");
d335 1
a335 1
		"Namei         Sys-cache    Proc-cache    No-cache");
d337 1
a337 1
		"    Calls     hits    %%    hits     %%    miss   %%");
d347 1
a347 1
				" %4.4s", dr_name[j]);
a376 1
	
d408 1
a408 1
				intrname[i]);
d426 1
a426 1
	/* 
d438 1
a438 1
				5, 1, 0);
d460 1
a460 1
#define pgtokb(pg)     ((pg) * s.uvmexp.pagesize / 1024)
d512 1
a512 1
				" %4.4s", dr_name[i]);
d519 1
a519 1
	   NAMEIROW + 2, NAMEICOL + 19, 4, 0, 1);
d522 1
a522 1
	   NAMEIROW + 2, NAMEICOL + 33, 4, 0, 1);
d526 1
a526 1
	   100.0 / nz(s.nchcount), NAMEIROW + 2, NAMEICOL + 45, 4, 0, 1);
d636 4
a639 1
	int mib[2];
a640 1
	extern int errno;
a646 3
	NREAD(X_CPTIME, s->time, sizeof s->time);
	NREAD(X_UVMEXP, &s->uvmexp, sizeof s->uvmexp);
	NREAD(X_NCHSTATS, &s->nchstats, sizeof s->nchstats);
d658 1
a658 1
	NREAD(X_INTRCNT, s->intrcnt, nintr * LONG);
d660 18
d679 2
a680 4
	mib[0] = CTL_VM;
	mib[1] = VM_METER;
	if (sysctl(mib, 2, &s->Total, &size, NULL, 0) < 0) {
		error("Can't get kernel info: %s\n", strerror(errno));
d716 1
a716 1
		((double)cur.dk_time[dn].tv_usec / (double)1000000);
@


1.27
log
@slightly expand the Csw/Trp/Sys/Int/Sof spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.26 2001/11/06 19:20:15 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.26 2001/11/06 19:20:15 art Exp $";
d308 1
a308 1
	register int i, j;
d580 1
a580 1
	register int nusers = 0;
d597 1
a597 1
	register int i;
d701 1
a701 1
	register struct Info *from, *to;
@


1.26
log
@New vm includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.25 2001/08/28 05:17:55 weingart Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.25 2001/08/28 05:17:55 weingart Exp $";
d180 2
a181 2
#define GENSTATROW	 7	/* uses 2 rows and 30 cols */
#define GENSTATCOL	20
d344 1
a344 1
	mvprintw(GENSTATROW, GENSTATCOL, "  Csw  Trp  Sys  Int  Sof  Flt");
d521 6
a526 6
	PUTRATE(uvmexp.swtch, GENSTATROW + 1, GENSTATCOL, 5);
	PUTRATE(uvmexp.traps, GENSTATROW + 1, GENSTATCOL + 5, 5);
	PUTRATE(uvmexp.syscalls, GENSTATROW + 1, GENSTATCOL + 10, 5);
	PUTRATE(uvmexp.intrs, GENSTATROW + 1, GENSTATCOL + 15, 5);
	PUTRATE(uvmexp.softs, GENSTATROW + 1, GENSTATCOL + 20, 5);
	PUTRATE(uvmexp.faults, GENSTATROW + 1, GENSTATCOL + 25, 5);
@


1.25
log
@Add information on number/percentage of namei calls missed the cache.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.24 2001/06/27 06:16:49 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.24 2001/06/27 06:16:49 art Exp $";
a56 1
#include <vm/vm.h>
@


1.24
log
@UVM is no longer an option
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.23 2001/06/22 14:57:21 lebel Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.23 2001/06/22 14:57:21 lebel Exp $";
d187 1
a187 1
#define NAMEIROW	14	/* uses 3 rows and 38 cols */
d353 2
a354 1
	mvprintw(NAMEIROW, NAMEICOL, "Namei         Sys-cache     Proc-cache");
d356 1
a356 1
		"    Calls     hits    %%     hits     %%");
d536 1
a536 1
	putint(nchtotal.ncs_goodhits, NAMEIROW + 2, NAMEICOL + 9, 9);
d540 1
a540 1
	putint(nchtotal.ncs_pass2, NAMEIROW + 2, NAMEICOL + 23, 9);
d542 5
a546 1
	   NAMEIROW + 2, NAMEICOL + 34, 4, 0, 1);
@


1.23
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.22 2001/05/04 16:48:34 ericj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.22 2001/05/04 16:48:34 ericj Exp $";
a58 1
#if defined(UVM)
a59 1
#endif
a81 1
#if defined(UVM)
a82 3
#else
	struct	vmmeter Cnt;
#endif
a148 1
#if defined(UVM)
a150 4
#else
#define X_CNT		1
	{ "_cnt" },
#endif
a312 1
#if defined(UVM)
a321 14
#else

	mvprintw(MEMROW, MEMCOL, "Mem:KB  REAL        VIRTUAL");
	mvprintw(MEMROW + 1, MEMCOL, "      Tot Share    Tot  Share");
	mvprintw(MEMROW + 2, MEMCOL, "Act");
	mvprintw(MEMROW + 3, MEMCOL, "All");

	mvprintw(MEMROW + 1, MEMCOL + 32, "Free");

	mvprintw(PAGEROW, PAGECOL,     "        PAGING   SWAPPING ");
	mvprintw(PAGEROW + 1, PAGECOL, "        in  out   in  out ");
	mvprintw(PAGEROW + 2, PAGECOL, "count");
	mvprintw(PAGEROW + 3, PAGECOL, "pages");
#endif
a325 1
#if defined(UVM)
a343 20
#else
	mvprintw(VMSTATROW + 0, VMSTATCOL + 10, "cow");
	mvprintw(VMSTATROW + 1, VMSTATCOL + 10, "objlk");
	mvprintw(VMSTATROW + 2, VMSTATCOL + 10, "objht");
	mvprintw(VMSTATROW + 3, VMSTATCOL + 10, "zfod");
	mvprintw(VMSTATROW + 4, VMSTATCOL + 10, "nzfod");
	mvprintw(VMSTATROW + 5, VMSTATCOL + 10, "%%zfod");
	mvprintw(VMSTATROW + 6, VMSTATCOL + 10, "kern");
	mvprintw(VMSTATROW + 7, VMSTATCOL + 10, "wire");
	mvprintw(VMSTATROW + 8, VMSTATCOL + 10, "act");
	mvprintw(VMSTATROW + 9, VMSTATCOL + 10, "inact");
	mvprintw(VMSTATROW + 10, VMSTATCOL + 10, "free");
	mvprintw(VMSTATROW + 11, VMSTATCOL + 10, "daefr");
	mvprintw(VMSTATROW + 12, VMSTATCOL + 10, "prcfr");
	mvprintw(VMSTATROW + 13, VMSTATCOL + 10, "react");
	mvprintw(VMSTATROW + 14, VMSTATCOL + 10, "scan");
	mvprintw(VMSTATROW + 15, VMSTATCOL + 10, "hdrev");
	if (LINES - 1 > VMSTATROW + 16)
		mvprintw(VMSTATROW + 16, VMSTATCOL + 10, "intrn");
#endif
a348 1
#if defined(UVM)
a349 3
#else
	mvprintw(PROCSROW, PROCSCOL, "Proc:r  d  s  w  p");
#endif
a478 1
#if defined(UVM)
a479 3
#else
#define pgtokb(pg)     ((pg) * cnt.v_page_size / 1024)
#endif
a480 1
#if defined(UVM)
a489 11
#else
	putint(pgtokb(total.t_arm), MEMROW + 2, MEMCOL + 3, 6);
	putint(pgtokb(total.t_armshr), MEMROW + 2, MEMCOL + 9, 6);
	putint(pgtokb(total.t_avm), MEMROW + 2, MEMCOL + 15, 7);
	putint(pgtokb(total.t_avmshr), MEMROW + 2, MEMCOL + 22, 7);
	putint(pgtokb(total.t_rm), MEMROW + 3, MEMCOL + 3, 6);
	putint(pgtokb(total.t_rmshr), MEMROW + 3, MEMCOL + 9, 6);
	putint(pgtokb(total.t_vm), MEMROW + 3, MEMCOL + 15, 7);
	putint(pgtokb(total.t_vmshr), MEMROW + 3, MEMCOL + 22, 7);
	putint(pgtokb(total.t_free), MEMROW + 2, MEMCOL + 30, 6);
#endif
a494 4
#if !defined(UVM)
	putint(total.t_pw, PROCSROW + 1, PROCSCOL + 15, 3);
#endif
#if defined(UVM)
a526 36
#else
	PUTRATE(Cnt.v_cow_faults, VMSTATROW + 0, VMSTATCOL + 3, 6);
	PUTRATE(Cnt.v_lookups, VMSTATROW + 1, VMSTATCOL + 3, 6);
	PUTRATE(Cnt.v_hits, VMSTATROW + 2, VMSTATCOL + 3, 6);
	PUTRATE(Cnt.v_zfod, VMSTATROW + 3, VMSTATCOL + 4, 5);
	PUTRATE(Cnt.v_nzfod, VMSTATROW + 4, VMSTATCOL + 3, 6);
	putfloat(cnt.v_nzfod == 0 ? 0.0 : (100.0 * cnt.v_zfod / cnt.v_nzfod),
		 VMSTATROW + 5, VMSTATCOL + 2, 7, 2, 1);
	putint(pgtokb(cnt.v_kernel_pages), VMSTATROW + 6, VMSTATCOL, 9);
	putint(pgtokb(cnt.v_wire_count), VMSTATROW + 7, VMSTATCOL, 9);
	putint(pgtokb(cnt.v_active_count), VMSTATROW + 8, VMSTATCOL, 9);
	putint(pgtokb(cnt.v_inactive_count), VMSTATROW + 9, VMSTATCOL, 9);
	putint(pgtokb(cnt.v_free_count), VMSTATROW + 10, VMSTATCOL, 9);
	PUTRATE(Cnt.v_dfree, VMSTATROW + 11, VMSTATCOL, 9);
	PUTRATE(Cnt.v_pfree, VMSTATROW + 12, VMSTATCOL, 9);
	PUTRATE(Cnt.v_reactivated, VMSTATROW + 13, VMSTATCOL, 9);
	PUTRATE(Cnt.v_scan, VMSTATROW + 14, VMSTATCOL, 9);
	PUTRATE(Cnt.v_rev, VMSTATROW + 15, VMSTATCOL, 9);
	if (LINES - 1 > VMSTATROW + 16) {
		PUTRATE(Cnt.v_intrans, VMSTATROW + 16, VMSTATCOL, 9);
	}
	PUTRATE(Cnt.v_pageins, PAGEROW + 2, PAGECOL + 5, 5);
	PUTRATE(Cnt.v_pageouts, PAGEROW + 2, PAGECOL + 10, 5);
	PUTRATE(Cnt.v_swpin, PAGEROW + 2, PAGECOL + 15, 5);	/* - */
	PUTRATE(Cnt.v_swpout, PAGEROW + 2, PAGECOL + 20, 5);	/* - */
	PUTRATE(Cnt.v_pgpgin, PAGEROW + 3, PAGECOL + 5, 5);	/* ? */
	PUTRATE(Cnt.v_pgpgout, PAGEROW + 3, PAGECOL + 10, 5);	/* ? */
	PUTRATE(Cnt.v_pswpin, PAGEROW + 3, PAGECOL + 15, 5);	/* - */
	PUTRATE(Cnt.v_pswpout, PAGEROW + 3, PAGECOL + 20, 5);	/* - */
	PUTRATE(Cnt.v_swtch, GENSTATROW + 1, GENSTATCOL, 5);
	PUTRATE(Cnt.v_trap, GENSTATROW + 1, GENSTATCOL + 5, 5);
	PUTRATE(Cnt.v_syscall, GENSTATROW + 1, GENSTATCOL + 10, 5);
	PUTRATE(Cnt.v_intr, GENSTATROW + 1, GENSTATCOL + 15, 5);
	PUTRATE(Cnt.v_soft, GENSTATROW + 1, GENSTATCOL + 20, 5);
	PUTRATE(Cnt.v_faults, GENSTATROW + 1, GENSTATCOL + 25, 5);
#endif
a660 1
#if defined(UVM)
a661 3
#else
	NREAD(X_CNT, &s->Cnt, sizeof s->Cnt);
#endif
@


1.22
log
@
handle kvm_nlist() failing, from pr#1798.
Patch similar to the one submitted by <peterw@@documenta.com.au>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.21 2000/02/22 21:24:02 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.21 2000/02/22 21:24:02 deraadt Exp $";
d313 1
a313 2
	strncpy(buf, ctime(&now), sizeof buf-1);
	buf[sizeof buf-1] = '\0';
@


1.21
log
@_total is no longer a symbol in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.20 1999/10/26 15:43:22 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.20 1999/10/26 15:43:22 art Exp $";
d215 1
a215 1
	int i;
d219 3
a221 1
		if (kvm_nlist(kd, namelist)) {
a222 2
			return(0);
		}
@


1.20
log
@Fix printing of interrupts with UVM.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.19 1999/10/26 15:13:54 art Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.19 1999/10/26 15:13:54 art Exp $";
d162 1
a162 3
#define X_TOTAL		2
	{ "_total" },
#define	X_NCHSTATS	3
d164 1
a164 1
#define	X_INTRNAMES	4
d166 1
a166 1
#define	X_EINTRNAMES	5
d168 1
a168 1
#define	X_INTRCNT	6
d170 1
a170 1
#define	X_EINTRCNT	7
d173 1
a173 1
#define	X_INTRHAND	8
@


1.19
log
@support UVM. (much code from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.18 1999/06/16 10:18:30 espie Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.18 1999/06/16 10:18:30 espie Exp $";
d352 3
a374 3
	mvprintw(INTSROW, INTSCOL + 3, " Interrupts");
	mvprintw(INTSROW + 1, INTSCOL + 9, "total");

@


1.18
log
@Fixed i386 -> __i386__
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.17 1998/12/19 06:34:22 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.17 1998/12/19 06:34:22 deraadt Exp $";
d59 4
d84 3
d88 1
d155 4
d161 1
d327 12
d350 1
d352 20
d393 1
d399 5
a403 1
	mvprintw(PROCSROW, PROCSCOL, "Proc:r  p  d  s  w");
d533 17
a549 1
#define pgtokb(pg)	((pg) * cnt.v_page_size / 1024)
d559 1
d561 41
a601 4
	putint(total.t_pw, PROCSROW + 1, PROCSCOL + 6, 3);
	putint(total.t_dw, PROCSROW + 1, PROCSCOL + 9, 3);
	putint(total.t_sl, PROCSROW + 1, PROCSCOL + 12, 3);
	putint(total.t_sw, PROCSROW + 1, PROCSCOL + 15, 3);
d636 1
d771 3
d775 1
@


1.17
log
@move Act Free field over one
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.16 1998/07/13 02:11:42 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.16 1998/07/13 02:11:42 millert Exp $";
d69 1
a69 1
#if defined(i386)
d161 1
a161 1
#if defined(i386)
d230 1
a230 1
#if defined(i386)
d658 1
a658 1
#if defined(i386)
d667 1
a667 1
#if defined(i386)
@


1.16
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.15 1998/06/12 22:09:23 marc Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.15 1998/06/12 22:09:23 marc Exp $";
d176 1
a176 1
#define PAGECOL		36
d319 1
a319 1
	mvprintw(MEMROW + 1, MEMCOL + 31, "Free");
d491 1
a491 1
	putint(pgtokb(total.t_free), MEMROW + 2, MEMCOL + 29, 6);
@


1.15
log
@fix vm load display
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.14 1997/12/19 09:34:46 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.14 1997/12/19 09:34:46 deraadt Exp $";
d588 1
a588 1
	lseek(ut, 0L, L_SET);
@


1.14
log
@comment this strncpy is safe
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.13 1997/12/19 09:22:56 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.13 1997/12/19 09:22:56 deraadt Exp $";
d466 10
@


1.13
log
@proactive buffer blocks
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.12 1997/12/19 09:03:34 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.12 1997/12/19 09:03:34 deraadt Exp $";
d254 1
@


1.12
log
@bye bye sprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.11 1997/11/24 16:19:42 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.11 1997/11/24 16:19:42 kstailey Exp $";
d301 2
a302 1
	strcpy(buf, ctime(&now));
@


1.11
log
@Deal with the fact that PUTRATE() is a macro that contains braces by
surrounding it with braces after an ``if ()''.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.10 1997/11/22 20:07:56 mickey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.10 1997/11/22 20:07:56 mickey Exp $";
d607 1
a607 1
	sprintf(b, "%*d", w, n);
d629 1
a629 1
	sprintf(b, "%*.*f", w, d, f);
@


1.10
log
@remove unused kernel vars
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.9 1997/11/22 14:19:23 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.9 1997/11/22 14:19:23 kstailey Exp $";
d502 1
a502 1
	if (LINES - 1 > VMSTATROW + 16)
d504 1
@


1.9
log
@back out 1.8, will fix in another way.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.8 1997/11/22 13:07:37 kstailey Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.8 1997/11/22 13:07:37 kstailey Exp $";
d151 1
a151 11
#define	X_DK_BUSY	3
	{ "_dk_busy" },
#define	X_DK_TIME	4
	{ "_dk_time" },
#define	X_DK_XFER	5
	{ "_dk_xfer" },
#define	X_DK_WDS	6
	{ "_dk_wds" },
#define	X_DK_SEEK	7
	{ "_dk_seek" },
#define	X_NCHSTATS	8
d153 1
a153 1
#define	X_INTRNAMES	9
d155 1
a155 1
#define	X_EINTRNAMES	10
d157 1
a157 1
#define	X_INTRCNT	11
d159 1
a159 1
#define	X_EINTRCNT	12
d162 1
a162 1
#define	X_INTRHAND	13
@


1.8
log
@Make vmstat mode display actually fit in 80x24.
Exploits fact that swap display is always blank.
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.7 1997/07/29 04:51:43 flipk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.7 1997/07/29 04:51:43 flipk Exp $";
d193 1
a193 1
#define VMSTATROW	 6	/* uses 17 rows and 12 cols */
@


1.7
log
@delete accidental #if 0
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.6 1997/07/29 04:47:13 flipk Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.6 1997/07/29 04:47:13 flipk Exp $";
d193 1
a193 1
#define VMSTATROW	 7	/* uses 17 rows and 12 cols */
@


1.6
log
@1) display full time string in 'vmstat' display so you can tell
   the difference between an inactive display and a hung machine.
2) Update the man page for 'vmstat' to reflect reality (and actually
   explain all those vm abbreviations).

netbsd PR bin/2756 (Jonathan Stone <jonathan@@DSG.Stanford.EDU>
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.5 1996/12/20 00:17:29 downsj Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.5 1996/12/20 00:17:29 downsj Exp $";
a311 3
#if 0
	buf[16] = '\0';
#endif
@


1.5
log
@support four letter device names
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.4 1996/06/26 05:40:12 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.4 1996/06/26 05:40:12 deraadt Exp $";
d312 1
d314 1
@


1.4
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: vmstat.c,v 1.5 1996/05/10 23:16:40 thorpej Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: vmstat.c,v 1.5 1996/05/10 23:16:40 thorpej Exp $";
d377 1
a377 1
				"  %3.3s", dr_name[j]);
d533 1
a533 1
				"  %3.3s", dr_name[i]);
@


1.3
log
@Show interrupt counts on i386.
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.5 1996/05/10 23:16:40 thorpej Exp $";
@


1.2
log
@libutil
@
text
@d68 6
d170 4
d239 30
d292 1
d655 4
d664 11
d676 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vmstat.c,v 1.4 1995/04/29 05:54:55 cgd Exp $	*/
d40 1
a40 1
static char rcsid[] = "$NetBSD: vmstat.c,v 1.4 1995/04/29 05:54:55 cgd Exp $";
a74 5
	long	*dk_time;
	long	*dk_wds;
	long	*dk_seek;
	long	*dk_xfer;
	int	dk_busy;
d80 4
d217 1
a217 1
	if (! dkinit())
a224 4
		allocate(dk_time, long);
		allocate(dk_wds, long);
		allocate(dk_seek, long);
		allocate(dk_xfer, long);
d329 2
a330 2
	mvprintw(DISKROW + 3, DISKCOL, " blks");
	mvprintw(DISKROW + 4, DISKCOL, " msps");
d365 3
a367 3
	for (i = 0; i < dk_ndrive; i++) {
		X(dk_xfer); X(dk_seek); X(dk_wds); X(dk_time);
	}
d615 1
a617 5
	NREAD(X_DK_BUSY, &s->dk_busy, LONG);
	NREAD(X_DK_TIME, s->dk_time, dk_ndrive * LONG);
	NREAD(X_DK_XFER, s->dk_xfer, dk_ndrive * LONG);
	NREAD(X_DK_WDS, s->dk_wds, dk_ndrive * LONG);
	NREAD(X_DK_SEEK, s->dk_seek, dk_ndrive * LONG);
a642 1
	long *time, *wds, *seek, *xfer;
d645 1
a645 7
	/*
	 * time, wds, seek, and xfer are malloc'd so we have to
	 * save the pointers before the structure copy and then 
	 * copy by hand.
	 */
	time = to->dk_time; wds = to->dk_wds; seek = to->dk_seek;
	xfer = to->dk_xfer; intrcnt = to->intrcnt;
a646 4
	bcopy(from->dk_time, to->dk_time = time, dk_ndrive * sizeof (long));
	bcopy(from->dk_wds, to->dk_wds = wds, dk_ndrive * sizeof (long));
	bcopy(from->dk_seek, to->dk_seek = seek, dk_ndrive * sizeof (long));
	bcopy(from->dk_xfer, to->dk_xfer = xfer, dk_ndrive * sizeof (long));
d654 1
a654 1
	double words, atime, itime, xtime;
d657 11
a667 16
	atime = s.dk_time[dn];
	atime /= hertz;
	words = s.dk_wds[dn]*32.0;	/* number of words transferred */
	xtime = dk_mspw[dn]*words;	/* transfer time */
	itime = atime - xtime;		/* time not transferring */
	if (xtime < 0)
		itime += xtime, xtime = 0;
	if (itime < 0)
		xtime += itime, itime = 0;
	putint((int)((float)s.dk_seek[dn]/etime+0.5), DISKROW + 1, c, 5);
	putint((int)((float)s.dk_xfer[dn]/etime+0.5), DISKROW + 2, c, 5);
	putint((int)(words/etime/512.0 + 0.5), DISKROW + 3, c, 5);
	if (s.dk_seek[dn])
		putfloat(itime*1000.0/s.dk_seek[dn], DISKROW + 4, c, 5, 1, 1);
	else
		putint(0, DISKROW + 4, c, 5);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
