head	1.30;
access;
symbols
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.10
	OPENBSD_5_0:1.20.0.8
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.6
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.4
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.12.03.12.23.15;	author schwarze;	state Exp;
branches;
next	1.29;
commitid	RLUvzaxIukokxO3G;

1.29
date	2015.11.14.17.03.02;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	QuocyD1732yPsFV6;

1.28
date	2015.11.10.14.42.41;	author schwarze;	state Exp;
branches;
next	1.27;
commitid	0UiGprp3bvHfjuHx;

1.27
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	sbrB3Q5CNxcwZpfU;

1.26
date	2015.10.06.03.26.31;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	Lfyj7uTLxK4mkfCr;

1.25
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	0Dp7Dy9FuNZesYo2;

1.24
date	2014.10.08.04.07.24;	author doug;	state Exp;
branches;
next	1.23;
commitid	C3nkFnlL6Xs2yVLE;

1.23
date	2013.11.15.15.47.53;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.03.19.26.24;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.14.20.51.47;	author sobrado;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.02.15.19.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.17.09.45.00;	author moritz;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.15.13.19.14;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.15.01.36.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.14.23.08.47;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.14.17.12.51;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.14.17.01.41;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.13.20.08.21;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.16.16.57.14;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.22.20.50;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.03.02.56.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.28.03.56.46;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.12.04.12.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.38.47;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.21.21.37.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.03;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.03;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.30
log
@UTF-8 support: In a UTF-8 locale, properly align columns in the
presence of zero-width and double-width characters and replace
non-printable codepoints and invalid bytes with ASCII question
marks.  No change in the C/POSIX locale.
As a side effect, get rid of all pointer to pointer variables
and simplify some of the code.

Partially based on ideas from tedu@@.
Feedback and OK czarkoff@@, OK tedu@@.
@
text
@/*	$OpenBSD: rs.c,v 1.29 2015/11/14 17:03:02 schwarze Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *	rs - reshape a data array
 *	Author:  John Kunze, Office of Comp. Affairs, UCB
 *		BEWARE: lots of unfinished edges
 */

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct	entry {
	int	 w;  /* Display width. */
	char	*s;  /* Multibyte string. */
};

long	flags;
#define	TRANSPOSE	000001
#define	MTRANSPOSE	000002
#define	ONEPERLINE	000004
#define	ONEISEPONLY	000010
#define	ONEOSEPONLY	000020
#define	NOTRIMENDCOL	000040
#define	SQUEEZE		000100
#define	SHAPEONLY	000200
#define	DETAILSHAPE	000400
#define	RIGHTADJUST	001000
#define	NULLPAD		002000
#define	RECYCLE		004000
#define	SKIPPRINT	010000
#define ONEPERCHAR	0100000
#define NOARGS		0200000

short	*colwidths;
int	nelem;
struct entry *elem;
struct entry *endelem;
char	*curline;
int	allocsize = BUFSIZ;
int	irows, icols;
int	orows, ocols;
int	maxwidth;
int	skip;
int	propgutter;
char	isep = ' ', osep = ' ';
int	owidth = 80, gutter = 2;

int	  mbsavis(char **, const char *);

void	  usage(void);
void	  getargs(int, char *[]);
void	  getfile(void);
int	  get_line(void);
struct entry *getptrs(struct entry *);
void	  prepfile(void);
void	  prints(struct entry *, int);
void	  putfile(void);

#define INCR(ep) do {			\
	if (++ep >= endelem)		\
		ep = getptrs(ep);	\
} while(0)

int
main(int argc, char *argv[])
{
	setlocale(LC_CTYPE, "");

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	getargs(argc, argv);
	getfile();
	if (flags & SHAPEONLY) {
		printf("%d %d\n", irows, icols);
		exit(0);
	}
	prepfile();
	putfile();
	exit(0);
}

void
getfile(void)
{
	const char delim[2] = { isep, '\0' };
	char *p;
	struct entry *ep;
	int multisep = (flags & ONEISEPONLY ? 0 : 1);
	int nullpad = flags & NULLPAD;
	struct entry *padto;

	curline = NULL;
	while (skip--) {
		if (get_line() == EOF)
			return;
		if (flags & SKIPPRINT)
			puts(curline);
	}
	if (get_line() == EOF)
		return;
	if (flags & NOARGS && strlen(curline) < (size_t)owidth)
		flags |= ONEPERLINE;
	if (flags & ONEPERLINE)
		icols = 1;
	else				/* count cols on first line */
		for (p = curline; *p != '\0'; p++) {
			if (*p == isep && multisep)
				continue;
			icols++;
			while (*p && *p != isep)
				p++;
		}
	ep = getptrs(NULL);
	p = curline;
	do {
		if (flags & ONEPERLINE) {
			ep->w = mbsavis(&ep->s, curline);
			if (maxwidth < ep->w)
				maxwidth = ep->w;
			INCR(ep);		/* prepare for next entry */
			irows++;
			continue;
		}
		p = curline;
		while (p != NULL && *p != '\0') {
			if (*p == isep) {
				p++;
				if (multisep)
					continue;
				ep->s = "";	/* empty column */
				ep->w = 0;
			} else
				ep->w = mbsavis(&ep->s, strsep(&p, delim));
			if (maxwidth < ep->w)
				maxwidth = ep->w;
			INCR(ep);		/* prepare for next entry */
		}
		irows++;			/* update row count */
		if (nullpad) {			/* pad missing entries */
			padto = elem + irows * icols;
			while (ep < padto) {
				ep->s = "";
				ep->w = 0;
				INCR(ep);
			}
		}
	} while (get_line() != EOF);
	nelem = ep - elem;
}

void
putfile(void)
{
	struct entry *ep;
	int i, j, n;

	ep = elem;
	if (flags & TRANSPOSE) {
		for (i = 0; i < orows; i++) {
			for (j = i; j < nelem; j += orows)
				prints(ep + j, (j - i) / orows);
			putchar('\n');
		}
	} else {
		for (n = 0, i = 0; i < orows && n < nelem; i++) {
			for (j = 0; j < ocols; j++) {
				if (n++ >= nelem)
					break;
				prints(ep++, j);
			}
			putchar('\n');
		}
	}
}

void
prints(struct entry *ep, int col)
{
	int n;

	n = (flags & ONEOSEPONLY ? 1 : colwidths[col] - ep->w);
	if (flags & RIGHTADJUST)
		while (n-- > 0)
			putchar(osep);
	fputs(ep->s, stdout);
	while (n-- > 0)
		putchar(osep);
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-CcSs[x]] [-GgKkw N] [-EeHhjmnTtyz] [rows [cols]]\n",
	    __progname);
	exit(1);
}

void
prepfile(void)
{
	struct entry *ep;
	int  i;
	int  j;
	struct entry *lp;
	int colw;
	int max = 0;
	int n;

	if (!nelem)
		exit(0);
	gutter += maxwidth * propgutter / 100.0;
	colw = maxwidth + gutter;
	if (flags & MTRANSPOSE) {
		orows = icols;
		ocols = irows;
	}
	else if (orows == 0 && ocols == 0) {	/* decide rows and cols */
		ocols = owidth / colw;
		if (ocols == 0) {
			warnx("Display width %d is less than column width %d",
			    owidth, colw);
			ocols = 1;
		}
		if (ocols > nelem)
			ocols = nelem;
		orows = nelem / ocols + (nelem % ocols ? 1 : 0);
	}
	else if (orows == 0)			/* decide on rows */
		orows = nelem / ocols + (nelem % ocols ? 1 : 0);
	else if (ocols == 0)			/* decide on cols */
		ocols = nelem / orows + (nelem % orows ? 1 : 0);
	while ((lp = elem + orows * ocols) > endelem)
	     (void)getptrs(NULL);
	if (flags & RECYCLE) {
		for (ep = elem + nelem; ep < lp; ep++)
			memcpy(ep, ep - nelem, sizeof(*ep));
		nelem = lp - elem;
	}
	if (!(colwidths = calloc(ocols, sizeof(short))))
		errx(1, "malloc:  No gutter space");
	if (flags & SQUEEZE) {
		for (ep = elem, i = 0; i < ocols; i++) {
			max = 0;
			if (flags & TRANSPOSE) {
				for (j = 0; j < orows; j++, ep++)
					if (ep->w > max)
						max = ep->w;
			} else {
				for (j = i; j < nelem; j += ocols)
					if (ep[j].w > max)
						max = ep[j].w;
			}
			colwidths[i] = max + gutter;
		}
	} else {
		for (i = 0; i < ocols; i++)
			colwidths[i] = colw;
	}
	if (!(flags & NOTRIMENDCOL)) {
		if (flags & RIGHTADJUST)
			colwidths[0] -= gutter;
		else
			colwidths[ocols - 1] = 0;
	}
	n = orows * ocols;
	if (n > nelem && (flags & RECYCLE))
		nelem = n;
}

int
get_line(void)
{
	static	size_t	 cursz;
	static	ssize_t	 curlen;

	if (irows > 0 && flags & DETAILSHAPE)
		printf(" %zd line %d\n", curlen, irows);

	if ((curlen = getline(&curline, &cursz, stdin)) == EOF) {
		if (ferror(stdin))
			err(1, NULL);
		return EOF;
	}
	if (curlen > 0 && curline[curlen - 1] == '\n')
		curline[--curlen] = '\0';

	return 0;
}

struct entry *
getptrs(struct entry *sp)
{
	struct entry *p;
	int newsize;

	newsize = allocsize * 2;
	p = reallocarray(elem, newsize, sizeof(*p));
	if (p == NULL)
		err(1, "no memory");

	allocsize = newsize;
	sp = sp == NULL ? p : p + (sp - elem);
	elem = p;
	endelem = elem + allocsize;
	return(sp);
}

void
getargs(int ac, char *av[])
{
	int ch;
	const char *errstr;

	if (ac == 1)
		flags |= NOARGS | TRANSPOSE;
	while ((ch = getopt(ac, av, "c::C::s::S::k:K:g:G:w:tTeEnyjhHmz")) != -1) {
		switch (ch) {
		case 'T':
			flags |= MTRANSPOSE;
			/* FALLTHROUGH */
		case 't':
			flags |= TRANSPOSE;
			break;
		case 'c':		/* input col. separator */
			flags |= ONEISEPONLY;
			/* FALLTHROUGH */
		case 's':		/* one or more allowed */
			if (optarg == NULL)
				isep = '\t';	/* default is ^I */
			else if (optarg[1] != '\0')
				usage();	/* single char only */
			else
				isep = *optarg;
			break;
		case 'C':
			flags |= ONEOSEPONLY;
			/* FALLTHROUGH */
		case 'S':
			if (optarg == NULL)
				osep = '\t';	/* default is ^I */
			else if (optarg[1] != '\0')
				usage();	/* single char only */
			else
				osep = *optarg;
			break;
		case 'w':		/* window width, default 80 */
			owidth = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr) {
				warnx("width %s", errstr);
				usage();
			}
			break;
		case 'K':			/* skip N lines */
			flags |= SKIPPRINT;
			/* FALLTHROUGH */
		case 'k':			/* skip, do not print */
			skip = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("skip value %s", errstr);
				usage();
			}
			if (skip == 0)
				skip = 1;
			break;
		case 'm':
			flags |= NOTRIMENDCOL;
			break;
		case 'g':		/* gutter width */
			gutter = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("gutter width %s", errstr);
				usage();
			}
			break;
		case 'G':
			propgutter = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr) {
				warnx("gutter proportion %s", errstr);
				usage();
			}
			break;
		case 'e':		/* each line is an entry */
			flags |= ONEPERLINE;
			break;
		case 'E':
			flags |= ONEPERCHAR;
			break;
		case 'j':			/* right adjust */
			flags |= RIGHTADJUST;
			break;
		case 'n':	/* null padding for missing values */
			flags |= NULLPAD;
			break;
		case 'y':
			flags |= RECYCLE;
			break;
		case 'H':			/* print shape only */
			flags |= DETAILSHAPE;
			/* FALLTHROUGH */
		case 'h':
			flags |= SHAPEONLY;
			break;
		case 'z':			/* squeeze col width */
			flags |= SQUEEZE;
			break;
		default:
			usage();
		}
	}
	ac -= optind;
	av += optind;

	switch (ac) {
	case 2:
		ocols = strtonum(av[1], 0, INT_MAX, &errstr);
		if (errstr) {
			warnx("columns value %s", errstr);
			usage();
		}
		/* FALLTHROUGH */
	case 1:
		orows = strtonum(av[0], 0, INT_MAX, &errstr);
		if (errstr) {
			warnx("columns value %s", errstr);
			usage();
		}
		/* FALLTHROUGH */
	case 0:
		break;
	default:
		usage();
	}
}
@


1.29
log
@Fix the obvious bug that with -z, every column was at least as wide
as the previous one.  While here, shorten the -z code by one line.
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.28 2015/11/10 14:42:41 schwarze Exp $	*/
d42 1
d48 5
d72 2
a73 2
char	**elem;
char	**endelem;
a75 1
ssize_t	curlen;
d78 1
a78 1
ssize_t	maxlen;
d84 2
d90 1
a90 1
char	**getptrs(char **);
d92 1
a92 1
void	  prints(char *, int);
d103 2
d122 1
d124 1
a124 2
	char *endp;
	char **ep = NULL;
d127 1
a127 1
	char **padto;
d129 1
d138 1
a138 1
	if (flags & NOARGS && curlen < owidth)
d143 1
a143 1
		for (p = curline, endp = curline + curlen; p < endp; p++) {
d150 1
a150 1
	ep = getptrs(elem);
d154 3
a156 1
			*ep = curline;
a157 2
			if (maxlen < curlen)
				maxlen = curlen;
d161 12
a172 12
		for (p = curline, endp = curline + curlen; p < endp; p++) {
			if (*p == isep && multisep)
				continue;	/* eat up column separators */
			if (*p == isep)		/* must be an empty column */
				*ep = "";
			else			/* store column entry */
				*ep = p;
			while (p < endp && *p != isep)
				p++;		/* find end of entry */
			*p = '\0';		/* mark end of entry */
			if (maxlen < p - *ep)	/* update maxlen */
				maxlen = p - *ep;
d179 2
a180 1
				*ep = "";
a184 1
	*ep = NULL;				/* mark end of pointers */
d191 1
a191 1
	char **ep;
d198 1
a198 1
				prints(ep[j], (j - i) / orows);
d206 1
a206 1
				prints(*ep++, j);
d214 1
a214 1
prints(char *s, int col)
a216 1
	char *p = s;
d218 1
a218 3
	while (*p)
		p++;
	n = (flags & ONEOSEPONLY ? 1 : colwidths[col] - (p - s));
d222 1
a222 2
	for (p = s; *p; p++)
		putchar(*p);
d241 1
a241 1
	char **ep;
d244 1
a244 1
	char **lp;
d251 2
a252 2
	gutter += maxlen * propgutter / 100.0;
	colw = maxlen + gutter;
d272 2
a273 5
	lp = elem + orows * ocols;
	while (lp > endelem) {
		getptrs(elem + nelem);
		lp = elem + orows * ocols;
	}
d276 1
a276 1
			*ep = *(ep - nelem);
d285 3
a287 3
				for (j = 0; j < orows; j++)
					if ((n = strlen(*ep++)) > max)
						max = n;
d290 2
a291 2
					if ((n = strlen(ep[j])) > max)
						max = n;
d311 1
a311 1
get_line(void)	/* get line; maintain curline, curlen; manage storage */
d313 2
a314 2
	static	char	*ibuf = NULL;
	static	size_t	 ibufsz = 0;
d319 1
a319 1
	if ((curlen = getline(&ibuf, &ibufsz, stdin)) == EOF) {
d324 2
a325 7
	if (curlen > 0 && ibuf[curlen - 1] == '\n')
		ibuf[--curlen] = '\0';

	if (skip >= 0 || flags & SHAPEONLY)
		curline = ibuf;
	else if ((curline = strdup(ibuf)) == NULL)
		err(1, NULL);
d330 2
a331 2
char **
getptrs(char **sp)
d333 1
a333 1
	char **p;
d337 1
a337 1
	p = reallocarray(elem, newsize, sizeof(char *));
d342 1
a342 1
	sp += p - elem;
@


1.28
log
@With -H, do not overrun your static buffer on files longer than 4 kB.
With -K, do not print bogus blank lines in case of premature EOF.

While here, completely rewrite get_line() in a modern style using
getline(3), ferror(3), strdup(3), and ssize_t for line lengths.
Completely get rid of the static buffer.
I wouldn't be very surprised if this fixes even more bugs
than the two ones mentioned above.

OK (and "amazing") deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.27 2015/10/09 01:37:08 deraadt Exp $	*/
d279 3
a281 2
		if (flags & TRANSPOSE)
			for (ep = elem, i = 0; i < ocols; i++) {
d285 1
a285 4
				colwidths[i] = max + gutter;
			}
		else
			for (ep = elem, i = 0; i < ocols; i++) {
a288 1
				colwidths[i] = max + gutter;
d290 2
@


1.27
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.26 2015/10/06 03:26:31 deraadt Exp $	*/
d70 1
a70 1
int	curlen;
d73 1
a73 1
int	maxlen;
d121 2
a122 1
		get_line();
d126 2
a127 1
	get_line();
a307 3
#define	BSIZE	2048
char	ibuf[BSIZE];		/* two screenfuls should do */

d311 13
a323 4
	static	int putlength;
	static	char *endblock = ibuf + BSIZE;
	char *p;
	int c, i;
d325 1
a325 1
	if (!irows) {
d327 4
a330 18
		putlength = flags & DETAILSHAPE;
	}
	else if (skip <= 0) {			/* don't waste storage */
		curline += curlen + 1;
		if (putlength)		/* print length, recycle storage */
			printf(" %d line %d\n", curlen, irows);
	}
	if (!putlength && endblock - curline < BUFSIZ) {   /* need storage */
		if (!(curline = malloc(BSIZE)))
			errx(1, "File too large");
		endblock = curline + BSIZE;
	}
	for (p = curline, i = 1; i < BUFSIZ; *p++ = c, i++)
		if ((c = getchar()) == EOF || c == '\n')
			break;
	*p = '\0';
	curlen = i - 1;
	return(c);
@


1.26
log
@data processing stdin to stdout; tame "stdout"
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.25 2015/08/20 22:32:41 deraadt Exp $	*/
d96 2
a97 2
	if (tame("stdio", NULL) == -1)
		err(1, "tame");
@


1.25
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.24 2014/10/08 04:07:24 doug Exp $	*/
d96 3
@


1.24
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the size argument with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.23 2013/11/15 15:47:53 millert Exp $	*/
d271 1
a271 1
	if (!(colwidths = (short *) calloc(ocols, sizeof(short))))
d324 1
a324 1
		if (!(curline = (char *) malloc(BSIZE)))
@


1.23
log
@Include unistd.h as it is the standard location for getopt().
From Eitan Adler
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.22 2012/12/03 19:26:24 otto Exp $	*/
d343 1
a343 1
	p = realloc(elem, newsize * sizeof(char *));
@


1.22
log
@don't try to stuff ptr differences into an int; from Arto Jonsson; ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.21 2012/03/04 04:05:15 fgsch Exp $	*/
d45 1
@


1.21
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.20 2009/10/27 23:59:42 deraadt Exp $	*/
d339 1
a339 1
	int newsize, gap;
d346 2
a347 1
	gap = p - elem;
a348 2
	allocsize = newsize;
	sp += gap;
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.19 2009/10/14 20:51:47 sobrado Exp $	*/
d81 1
a81 1
int	  getline(void);
d117 1
a117 1
		getline();
d121 1
a121 1
	getline();
d167 1
a167 1
	} while (getline() != EOF);
d306 1
a306 1
getline(void)	/* get line; maintain curline, curlen; manage storage */
@


1.19
log
@sort flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.18 2007/09/02 15:19:34 deraadt Exp $	*/
a30 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)rs.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: rs.c,v 1.18 2007/09/02 15:19:34 deraadt Exp $";
#endif
#endif /* not lint */
@


1.18
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.17 2006/04/17 09:45:00 moritz Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.17 2006/04/17 09:45:00 moritz Exp $";
d235 1
a235 1
	    "usage: %s [-CcSs[x]] [-KkGgw N] [-EeHhjmnTtyz] [rows [cols]]\n",
@


1.17
log
@Three undocumented options got lost in the conversion to getopt(3).
Remove their remaining code, since they were not working before.

Initial diff from Steffen Wendzel.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.16 2005/05/15 13:19:14 jmc Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.16 2005/05/15 13:19:14 jmc Exp $";
d284 1
a284 1
	if (!(colwidths = (short *) malloc(ocols * sizeof(short))))
@


1.16
log
@oops. grasp of alphabet...slipping...
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.15 2005/05/15 01:36:13 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.15 2005/05/15 01:36:13 millert Exp $";
a73 2
#define	ICOLBOUNDS	020000
#define	OCOLBOUNDS	040000
a77 3
short	*cord;
short	*icbd;
short	*ocbd;
a95 1
char	 *getlist(short **, char *);
a465 11
		case 'o':			/* col order */
			getlist(&cord, optarg);
			break;
		case 'b':
			flags |= ICOLBOUNDS;
			getlist(&icbd, optarg);
			break;
		case 'B':
			flags |= OCOLBOUNDS;
			getlist(&ocbd, optarg);
			break;
d480 1
d487 1
a492 41
}

char *
getlist(short **list, char *p)
{
	int count = 1;
	char *t, *ep;
	long l;

	for (t = p + 1; *t; t++) {
		if (!isdigit(*t)) {
			warnx("option -%c requires a list of unsigned numbers separated by commas", *t);
			usage();
		}
		count++;
		while (*t && isdigit(*t))
			t++;
		if (*t != ',')
			break;
	}
	if (!(*list = (short *) malloc(count * sizeof(short))))
		errx(1, "No list space");
	count = 0;
	for (t = p + 1; *t; t++) {
		errno = 0;
		l = strtol(t, &ep, 10);
		if (t == ep)
			break;		/* can't happen */
		if ((errno == ERANGE && (l == LONG_MAX || l == LONG_MIN)) ||
		    (l > SHRT_MAX || l < SHRT_MIN)) {
			warnx("list value out of range");
			usage();
		}
		(*list)[count++] = (short)l;
		printf("++ %d ", (*list)[count-1]);
		fflush(stdout);
		if (*(t = ep) != ',')
			break;
	}
	(*list)[count] = 0;
	return(t - 1);
@


1.15
log
@Make usage/SYNOPSIS saner and sort the options.  With jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.14 2005/05/14 23:08:47 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.14 2005/05/14 23:08:47 millert Exp $";
d241 1
a241 1
	    "usage: %s [-csCS[x]] [-kKgGw N] [-tTeEnyjhHmz] [rows [cols]]\n",
@


1.14
log
@Replace homegrown getnum() with strtonum() and replace atoi() with
strtonum() and strtol().
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.13 2005/05/14 17:12:51 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.13 2005/05/14 17:12:51 millert Exp $";
d241 1
a241 1
	    "usage: %s [-[csCS][x][kKgGw][N]tTeEnyjhHm] [rows [cols]]\n",
@


1.13
log
@kill commented out code
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.12 2005/05/14 17:01:41 millert Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: rs.c,v 1.12 2005/05/14 17:01:41 millert Exp $";
d54 2
a101 1
char	 *getnum(int *, char *, int);
d378 1
d413 3
a415 3
			getnum(&owidth, optarg, 0);
			if (owidth <= 0) {
				warnx("width must be a positive integer");
d423 6
a428 2
			getnum(&skip, optarg, 0);
			if (!skip)
d434 6
a439 2
		case 'g':		/* gutter space */
			getnum(&gutter, optarg, 0);
d442 5
a446 1
			getnum(&propgutter, optarg, 0);
d492 5
a496 1
		ocols = atoi(av[1]);
d498 5
a502 1
		orows = atoi(av[0]);
d514 2
a515 1
	char *t;
d532 10
a541 1
		(*list)[count++] = atoi(t);
d544 1
a544 3
		while (*t && isdigit(*t))
			t++;
		if (*t != ',')
a548 22
}

/* num = number p points to; if (strict) complain */
/* returns pointer to end of num */
char *
getnum(int *num, char *p, int strict)
{
	char *t = p;

	if (!isdigit(*++t)) {
		if (strict || *t == '-' || *t == '+') {
			warnx("option -%c requires an unsigned integer", *p);
			usage();
		}
		*num = 0;
		return(p);
	}
	*num = atoi(t);
	while (*++t)
		if (!isdigit(*t))
			break;
	return(--t);
@


1.12
log
@make this use getopt()
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.11 2004/03/13 20:08:21 tedu Exp $	*/
d42 1
a42 1
static const char rcsid[] = "$OpenBSD: jot.c,v 1.18 2005/04/11 16:31:20 deraadt Exp $";
d306 1
a306 13
	}
	/*	for (i = 0; i < orows; i++) {
			for (j = i; j < nelem; j += orows)
				prints(ep[j], (j - i) / orows);
			putchar('\n');
		}
	else
		for (i = 0; i < orows; i++) {
			for (j = 0; j < ocols; j++)
				prints(*ep++, j);
			putchar('\n');
		}*/
	else
d309 1
a318 3
	/*for (i = 0; i < ocols; i++)
		fprintf(stderr, "%d ",colwidths[i]);
	fprintf(stderr, "is colwidths, nelem %d\n", nelem);*/
a341 2
		/*ww = endblock-curline; tt += ww;*/
		/*printf("#wasted %d total %d\n",ww,tt);*/
a344 1
		/*printf("#endb %d curline %d\n",endblock,curline);*/
a457 3
		/*case 'p':
			ipagespace = atoi(++p);	(default is 1)
			break;*/
a475 2
	/*if (!osep)
		osep = isep;*/
a476 2
	/*case 3:
		opages = atoi(av[2]);*/
@


1.11
log
@use NULL for pointers.  from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.10 2003/10/16 16:57:14 tedu Exp $	*/
d33 1
a33 1
static char copyright[] =
d39 5
a43 1
static char sccsid[] = "@@(#)rs.c	8.1 (Berkeley) 6/6/93";
d95 1
a95 1
void	  usage(char *, char *);
d235 1
a235 1
usage(char *msg, char *s)
d237 2
a238 1
	warnx(msg, s);
d240 2
a241 1
"Usage:  rs [ -[csCS][x][kKgGw][N]tTeEnyjhHm ] [ rows [ cols ] ]\n");
d393 1
a393 1
	char *p;
d395 1
a395 1
	if (ac == 1) {
d397 95
d493 3
a495 85
	while (--ac && **++av == '-')
		for (p = *av+1; *p; p++)
			switch (*p) {
			case 'T':
				flags |= MTRANSPOSE;
			case 't':
				flags |= TRANSPOSE;
				break;
			case 'c':		/* input col. separator */
				flags |= ONEISEPONLY;
			case 's':		/* one or more allowed */
				if (p[1])
					isep = *++p;
				else
					isep = '\t';	/* default is ^I */
				break;
			case 'C':
				flags |= ONEOSEPONLY;
			case 'S':
				if (p[1])
					osep = *++p;
				else
					osep = '\t';	/* default is ^I */
				break;
			case 'w':		/* window width, default 80 */
				p = getnum(&owidth, p, 0);
				if (owidth <= 0)
				usage("Width must be a positive integer", "");
				break;
			case 'K':			/* skip N lines */
				flags |= SKIPPRINT;
			case 'k':			/* skip, do not print */
				p = getnum(&skip, p, 0);
				if (!skip)
					skip = 1;
				break;
			case 'm':
				flags |= NOTRIMENDCOL;
				break;
			case 'g':		/* gutter space */
				p = getnum(&gutter, p, 0);
				break;
			case 'G':
				p = getnum(&propgutter, p, 0);
				break;
			case 'e':		/* each line is an entry */
				flags |= ONEPERLINE;
				break;
			case 'E':
				flags |= ONEPERCHAR;
				break;
			case 'j':			/* right adjust */
				flags |= RIGHTADJUST;
				break;
			case 'n':	/* null padding for missing values */
				flags |= NULLPAD;
				break;
			case 'y':
				flags |= RECYCLE;
				break;
			case 'H':			/* print shape only */
				flags |= DETAILSHAPE;
			case 'h':
				flags |= SHAPEONLY;
				break;
			case 'z':			/* squeeze col width */
				flags |= SQUEEZE;
				break;
			/*case 'p':
				ipagespace = atoi(++p);	(default is 1)
				break;*/
			case 'o':			/* col order */
				p = getlist(&cord, p);
				break;
			case 'b':
				flags |= ICOLBOUNDS;
				p = getlist(&icbd, p);
				break;
			case 'B':
				flags |= OCOLBOUNDS;
				p = getlist(&ocbd, p);
				break;
			default:
				usage("Bad flag:  %.1s", p);
			}
d508 1
a508 1
		usage("Too many arguments.", "");
d519 4
a522 2
		if (!isdigit(*t))
			usage("Option %.1s requires a list of unsigned numbers separated by commas", t);
d553 4
a556 2
		if (strict || *t == '-' || *t == '+')
			usage("Option %.1s requires an unsigned integer", p);
@


1.10
log
@better realloc.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.9 2003/06/10 22:20:50 deraadt Exp $	*/
d126 1
a126 1
	char **ep = 0;
d183 1
a183 1
	*ep = 0;				/* mark end of pointers */
@


1.9
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.8 2003/06/03 02:56:15 millert Exp $	*/
d369 1
d371 3
a373 3
	allocsize += allocsize;
	p = (char **)realloc(elem, allocsize * sizeof(char *));
	if (p == (char **)0)
d376 5
a380 2
	sp += (p - elem);
	endelem = (elem = p) + allocsize;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.7 2002/02/16 21:27:52 millert Exp $	*/
d108 1
a108 3
main(argc, argv)
	int argc;
	char *argv[];
d122 1
a122 1
getfile()
d188 1
a188 1
putfile()
d213 1
a213 3
prints(s, col)
	char *s;
	int col;
d231 1
a231 2
usage(msg, s)
	char *msg, *s;
d240 1
a240 1
prepfile()
d333 1
a333 1
getline()	/* get line; maintain curline, curlen; manage storage */
d366 1
a366 2
getptrs(sp)
	char **sp;
d381 1
a381 3
getargs(ac, av)
	int ac;
	char *av[];
d490 1
a490 3
getlist(list, p)
	short **list;
	char *p;
d520 2
d523 1
a523 3
getnum(num, p, strict)	/* num = number p points to; if (strict) complain */
	int *num, strict;	/* returns pointer to end of num */
	char *p;
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.6 2001/11/19 19:02:16 mpech Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.5 2001/10/28 03:56:46 deraadt Exp $	*/
d95 10
a104 10
void	  usage __P((char *, char *));
void	  getargs __P((int, char *[]));
void	  getfile __P((void));
int	  getline __P((void));
char	 *getlist __P((short **, char *));
char	 *getnum __P((int *, char *, int));
char	**getptrs __P((char **));
void	  prepfile __P((void));
void	  prints __P((char *, int));
void	  putfile __P((void));
@


1.5
log
@fix -z; jarle@@uninett.no
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.4 1997/09/12 04:12:54 millert Exp $	*/
d130 3
a132 3
	register char *p;
	register char *endp;
	register char **ep = 0;
d196 2
a197 2
	register char **ep;
	register int i, j, n;
d223 2
a224 2
	register int n;
	register char *p = s;
d251 3
a253 3
	register char **ep;
	register int  i;
	register int  j;
d346 2
a347 2
	register char *p;
	register int c, i;
d378 1
a378 1
	register char **p;
d395 1
a395 1
	register char *p;
d506 2
a507 2
	register int count = 1;
	register char *t;
d539 1
a539 1
	register char *t = p;
@


1.4
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: rs.c,v 1.3 1996/06/26 05:38:47 deraadt Exp $	*/
d303 1
a303 1
			for (i = 0; i < ocols; i++) {
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
d270 2
a271 1
			warnx("Display width %d is less than column width %d\n", owidth, colw);
@


1.2
log
@avoid divide-by-zero trap when specifying small widths
do not overrun entry array when printing output tables
cleanup storage allocation for entries
use err/warn etc.
@
text
@d1 2
@


1.1
log
@Initial revision
@
text
@d92 1
a92 1
void	  error __P((char *, char *));
d103 5
d156 2
a157 1
			*ep++ = curline;
d175 1
a175 1
			ep++;			/* prepare for next entry */
d180 4
a183 2
			while  (ep < padto)
				*ep++ = "";
a184 2
	if (ep > endelem)			/* if low on pointers */
		ep = getptrs(ep);		/* get some more */
d194 1
a194 1
	register int i, j;
d197 1
a197 1
	if (flags & TRANSPOSE)
d203 5
a207 3
	else
		for (i = 0; i < orows; i++) {
			for (j = 0; j < ocols; j++)
d209 1
d212 1
d236 1
a236 1
error(msg, s)
d239 1
a239 2
	fprintf(stderr, "rs:  ");
	fprintf(stderr, msg, s);
d241 1
a241 1
"\nUsage:  rs [ -[csCS][x][kKgGw][N]tTeEnyjhHm ] [ rows [ cols ] ]\n");
d266 4
a269 2
		if (ocols == 0)
			fprintf(stderr, "Display width %d is less than column width %d\n", owidth, colw);
d289 1
a289 1
		error("malloc:  No gutter space", "");
d358 1
a358 1
			error("File too large", "");
d374 1
a374 1
	register char **p, **ep;
d376 8
a383 18
	for (;;) {
		allocsize += allocsize;
		if (!(p = (char **) malloc(allocsize * sizeof(char *)))) {
			perror("rs");
			exit(1);
		}
		if ((endelem = p + allocsize - icols) <= p) {
			free(p);
			continue;
		}
		if (elem != 0)
			free(elem);
		ep = elem;
		elem = p;
		while (ep < sp)
			*p++ = *ep++;
		return(p);
	}
d423 1
a423 1
				error("Width must be a positive integer", "");
d479 1
a479 1
				error("Bad flag:  %.1s", p);
d493 1
a493 1
		error("Too many arguments.  What do you mean by `%s'?", av[3]);
d507 1
a507 1
			error("Option %.1s requires a list of unsigned numbers separated by commas", t);
d515 1
a515 1
		error("No list space", "");
d539 1
a539 1
			error("Option %.1s requires an unsigned integer", p);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
