head	1.74;
access;
symbols
	OPENBSD_6_2_BASE:1.74
	OPENBSD_6_1:1.74.0.12
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.8
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.4
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.74.0.6
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.73.0.6
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.73.0.4
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.72.0.16
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.14
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.12
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.10
	OPENBSD_5_0:1.72.0.8
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.72.0.6
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.72.0.4
	OPENBSD_4_8_BASE:1.72
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.71.0.4
	OPENBSD_4_6_BASE:1.71
	OPENBSD_4_5:1.69.0.2
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.57.0.4
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.56.0.4
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.56.0.2
	OPENBSD_4_0_BASE:1.56
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.39.0.4
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.4
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.74
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	Uu5nFG3wCl0LACBb;

1.73
date	2013.11.20.20.54.34;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2010.03.01.02.09.44;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2009.06.09.22.20.44;	author jmc;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.03.00.45.59;	author naddy;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.07.20.21.13;	author naddy;	state Exp;
branches;
next	1.68;

1.68
date	2008.10.29.00.07.07;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.30.10.41.38;	author fgsch;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.13.12.21.19;	author av;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.08.07.26.40;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.23.21.33.32;	author av;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.30.23.35.39;	author av;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.22.21.04.01;	author av;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.11.21.59.25;	author av;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.08.21.40.58;	author av;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.06.10.16.52;	author av;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.07.23.27.50;	author fgsch;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.26.03.00.03;	author mjc;	state Exp;
branches;
next	1.56;

1.56
date	2006.08.25.04.38.32;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.24.19.35.55;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.16.17.06.04;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.15.23.49.58;	author mjc;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.06.23.22.28;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.01.07.53.01;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.01.07.12.18;	author mjc;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.01.06.32.17;	author mjc;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.31.01.14.41;	author mjc;	state Exp;
branches;
next	1.47;

1.47
date	2006.01.20.00.58.32;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2006.01.11.01.29.07;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.10.19.59.11;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.09.05.48.35;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.09.04.05.43;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.09.00.20.31;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.31.19.51.15;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.21.15.50.38;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.22.10.21.26;	author robert;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.09.11.02.32;	author alek;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.08.21.16.02;	author alek;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.04.18.30.38;	author moritz;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.14.22.21.30;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.30.11.59.03;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.16.12.10.55;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.14.07.32.58;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.31.08.47.31;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.06.20.50.05;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.18.09.42.33;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.13.05.48.38;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.24.20.03.07;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.18.22.17.04;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.18.20.18.31;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.22.03.43.37;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.21.17.43.48;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.20.13.40.57;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.17.19.42.30;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.28.03.57.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.14.00.01.56;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.22.14.26.36;	author lebel;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.24.11.35.42;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.24.11.34.10;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	99.12.15.05.33.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.12.20.23.53.35;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.07.09.20.10.26;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	98.07.09.19.09.59;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	98.04.25.04.41.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	97.05.01.12.40.28;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.03.19.03.21.49;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	97.03.09.01.34.27;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	97.02.26.02.08.44;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	97.02.23.02.29.02;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.24.08.20.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.24.06.32.16;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.23.23.42.29;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: cdio.c,v 1.73 2013/11/20 20:54:34 deraadt Exp $	*/

/*  Copyright (c) 1995 Serge V. Vakulenko
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Serge V. Vakulenko.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Compact Disc Control Utility by Serge V. Vakulenko <vak@@cronyx.ru>.
 * Based on the non-X based CD player by Jean-Marc Zucconi and
 * Andrey A. Chernov.
 *
 * Fixed and further modified on 5-Sep-1995 by Jukka Ukkonen <jau@@funet.fi>.
 *
 * 11-Sep-1995: Jukka A. Ukkonen <jau@@funet.fi>
 *              A couple of further fixes to my own earlier "fixes".
 *
 * 18-Sep-1995: Jukka A. Ukkonen <jau@@funet.fi>
 *              Added an ability to specify addresses relative to the
 *              beginning of a track. This is in fact a variation of
 *              doing the simple play_msf() call.
 *
 * 11-Oct-1995: Serge V.Vakulenko <vak@@cronyx.ru>
 *              New eject algorithm.
 *              Some code style reformatting.
 *
 * $FreeBSD: cdcontrol.c,v 1.13 1996/06/25 21:01:27 ache Exp $
 */

#include <sys/param.h>	/* isset */
#include <sys/file.h>
#include <sys/cdio.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/scsiio.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <histedit.h>
#include <util.h>
#include <vis.h>

#include "extern.h"

#define ASTS_INVALID    0x00  /* Audio status byte not valid */
#define ASTS_PLAYING    0x11  /* Audio play operation in progress */
#define ASTS_PAUSED     0x12  /* Audio play operation paused */
#define ASTS_COMPLETED  0x13  /* Audio play operation successfully completed */
#define ASTS_ERROR      0x14  /* Audio play operation stopped due to error */
#define ASTS_VOID       0x15  /* No current audio status to return */

#ifndef DEFAULT_CD_DRIVE
#  define DEFAULT_CD_DRIVE  "cd0"
#endif

#define CMD_DEBUG       1
#define CMD_DEVICE      2
#define CMD_EJECT       3
#define CMD_HELP        4
#define CMD_INFO        5
#define CMD_PAUSE       6
#define CMD_PLAY        7
#define CMD_QUIT        8
#define CMD_RESUME      9
#define CMD_STOP        10
#define CMD_VOLUME      11
#define CMD_CLOSE       12
#define CMD_RESET       13
#define CMD_SET         14
#define CMD_STATUS      15
#define CMD_NEXT	16
#define CMD_PREV	17
#define CMD_REPLAY	18
#define CMD_CDDB	19
#define CMD_CDID	20
#define CMD_BLANK	21
#define CMD_CDRIP	22
#define CMD_CDPLAY	23

struct cmdtab {
	int command;
	char *name;
	int min;
	char *args;
} cmdtab[] = {
{ CMD_BLANK,	"blank",	1, "" },
{ CMD_CDDB,	"cddbinfo",     2, "[n]" },
{ CMD_CDID,	"cdid",		3, "" },
{ CMD_CDPLAY,	"cdplay",	3, "[track1-trackN ...]" },
{ CMD_CDRIP,	"cdrip",	3, "[track1-trackN ...]" },
{ CMD_CLOSE,    "close",        1, "" },
{ CMD_DEBUG,    "debug",        3, "on | off" },
{ CMD_DEVICE,   "device",       1, "devname" },
{ CMD_EJECT,    "eject",        1, "" },
{ CMD_QUIT,	"exit",		2, "" },
{ CMD_HELP,     "?",            1, 0 },
{ CMD_HELP,     "help",         1, "" },
{ CMD_INFO,     "info",         1, "" },
{ CMD_NEXT,	"next",		1, "" },
{ CMD_PAUSE,    "pause",        2, "" },
{ CMD_PLAY,     "play",         1, "[track1[.index1] [track2[.index2]]]" },
{ CMD_PLAY,     "play",         1, "[[tr1] m1:s1[.f1] [tr2] [m2:s2[.f2]]]" },
{ CMD_PLAY,     "play",         1, "[#block [len]]" },
{ CMD_PREV,	"previous",	2, "" },
{ CMD_QUIT,     "quit",         1, "" },
{ CMD_REPLAY,	"replay",	3, "" },
{ CMD_RESET,    "reset",        4, "" },
{ CMD_RESUME,   "resume",       1, "" },
{ CMD_SET,      "set",          2, "lba | msf" },
{ CMD_STATUS,   "status",       1, "" },
{ CMD_STOP,     "stop",         3, "" },
{ CMD_VOLUME,   "volume",       1, "left_channel right_channel" },
{ CMD_VOLUME,   "volume",       1, "left | right | mono | stereo | mute" },
{ 0, 0, 0, 0}
};

struct cd_toc_entry *toc_buffer;

char		*cdname;
int		fd = -1;
int		writeperm = 0;
u_int8_t	mediacap[MMC_FEATURE_MAX / NBBY];
int		verbose = 1;
int		msf = 1;
const char	*cddb_host;
char		**track_names;

EditLine	*el = NULL;	/* line-editing structure */
History		*hist = NULL;	/* line-editing history */
void		switch_el(void);

extern char	*__progname;

int		setvol(int, int);
int		read_toc_entrys(int);
int		play_msf(int, int, int, int, int, int);
int		play_track(int, int, int, int);
int		status(int *, int *, int *, int *);
int		is_wave(int);
__dead void	tao(int argc, char **argv);
int		play(char *arg);
int		info(char *arg);
int		cddbinfo(char *arg);
int		pstatus(char *arg);
int		play_next(char *arg);
int		play_prev(char *arg);
int		play_same(char *arg);
char		*input(int *);
char		*prompt(void);
void		prtrack(struct cd_toc_entry *e, int lastflag, char *name);
void		lba2msf(unsigned long lba, u_char *m, u_char *s, u_char *f);
unsigned int	msf2lba(u_char m, u_char s, u_char f);
int		play_blocks(int blk, int len);
int		run(int cmd, char *arg);
char		*parse(char *buf, int *cmd);
void		help(void);
void		usage(void);
char		*strstatus(int);
int		cdid(void);
void		addmsf(u_int *, u_int *, u_int *, u_char, u_char, u_char);
int		cmpmsf(u_char, u_char, u_char, u_char, u_char, u_char);
void		toc2msf(u_int, u_char *, u_char *, u_char *);

void
help(void)
{
	struct cmdtab *c;
	char *s, n;
	int i;

	for (c = cmdtab; c->name; ++c) {
		if (!c->args)
			continue;
		printf("\t");
		for (i = c->min, s = c->name; *s; s++, i--) {
			if (i > 0)
				n = toupper((unsigned char)*s);
			else
				n = *s;
			putchar(n);
		}
		if (*c->args)
			printf(" %s", c->args);
		printf("\n");
	}
	printf("\n\tThe word \"play\" is not required for the play commands.\n");
	printf("\tThe plain target address is taken as a synonym for play.\n");
}

void
usage(void)
{
	fprintf(stderr, "usage: %s [-sv] [-d host:port] [-f device] [command args ...]\n",
	    __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int ch, cmd;
	char *arg;

	cdname = getenv("DISC");
	if (!cdname)
		cdname = getenv("CDROM");

	cddb_host = getenv("CDDB");
	if (!cddb_host)
		cddb_host = "freedb.freedb.org";

	while ((ch = getopt(argc, argv, "svd:f:")) != -1)
		switch (ch) {
		case 's':
			verbose = 0;
			break;
		case 'v':
			verbose++;
			break;
		case 'f':
			cdname = optarg;
			break;
		case 'd':
			cddb_host = optarg;
			break;
		default:
			usage();
		}

	argc -= optind;
	argv += optind;

	if (argc > 0 && ! strcasecmp(*argv, "help"))
		usage();

	if (!cdname) {
		cdname = DEFAULT_CD_DRIVE;
		if (verbose > 1)
			fprintf(stderr,
			    "No CD device name specified. Defaulting to %s.\n",
			    cdname);
	}

	if (argc > 0 && !strcasecmp(*argv, "tao")) {
		tao(argc, argv);
		/* NOTREACHED */
	}
	if (argc > 0) {
		char buf[80], *p;
		int len;

		for (p=buf; argc-->0; ++argv) {
			len = snprintf(p, buf + sizeof buf - p,
			   "%s%s", (p > buf) ? " " : "", *argv);

			if (len == -1 || len >= buf + sizeof buf - p)
				errx(1, "argument list too long.");

			p += len;
		}
		arg = parse(buf, &cmd);
		return (run(cmd, arg));
	}

	if (verbose == 1)
		verbose = isatty(0);

	if (verbose) {
		printf("Compact Disc Control utility, version %s\n", VERSION);
		printf("Type `?' for command list\n\n");
	}

	switch_el();

	for (;;) {
		arg = input(&cmd);
		if (run(cmd, arg) < 0) {
			if (verbose)
				warn(NULL);
			close(fd);
			fd = -1;
		}
		fflush(stdout);
	}
}

int
run(int cmd, char *arg)
{
	int l, r, rc;
	static char newcdname[PATH_MAX];

	switch (cmd) {

	case CMD_QUIT:
		switch_el();
		exit(0);

	case CMD_INFO:
		if (!open_cd(cdname, 0))
			return (0);

		return info(arg);

	case CMD_CDDB:
		if (!open_cd(cdname, 0))
			return (0);

		return cddbinfo(arg);

	case CMD_CDID:
		if (!open_cd(cdname, 0))
			return (0);
		return cdid();

	case CMD_STATUS:
		if (!open_cd(cdname, 0))
			return (0);

		return pstatus(arg);

	case CMD_PAUSE:
		if (!open_cd(cdname, 0))
			return (0);

		return ioctl(fd, CDIOCPAUSE);

	case CMD_RESUME:
		if (!open_cd(cdname, 0))
			return (0);

		return ioctl(fd, CDIOCRESUME);

	case CMD_STOP:
		if (!open_cd(cdname, 0))
			return (0);

		rc = ioctl(fd, CDIOCSTOP);

		(void) ioctl(fd, CDIOCALLOW);

		return (rc);

	case CMD_RESET:
		if (!open_cd(cdname, 0))
			return (0);

		rc = ioctl(fd, CDIOCRESET);
		if (rc < 0)
			return rc;
		close(fd);
		fd = -1;
		return (0);

	case CMD_DEBUG:
		if (!open_cd(cdname, 0))
			return (0);

		if (!strcasecmp(arg, "on"))
			return ioctl(fd, CDIOCSETDEBUG);

		if (!strcasecmp(arg, "off"))
			return ioctl(fd, CDIOCCLRDEBUG);

		printf("%s: Invalid command arguments\n", __progname);

		return (0);

	case CMD_DEVICE:
		/* close old device */
		if (fd > -1) {
			(void) ioctl(fd, CDIOCALLOW);
			close(fd);
			fd = -1;
		}

		if (strlen(arg) == 0) {
			printf("%s: Invalid parameter\n", __progname);
			return (0);
		}

		/* open new device */
		if (!open_cd(arg, 0))
			return (0);
		(void) strlcpy(newcdname, arg, sizeof(newcdname));
		cdname = newcdname;
		return (1);

	case CMD_EJECT:
		if (!open_cd(cdname, 0))
			return (0);

		(void) ioctl(fd, CDIOCALLOW);
		rc = ioctl(fd, CDIOCEJECT);
		if (rc < 0)
			return (rc);
#if defined(__OpenBSD__)
		close(fd);
		fd = -1;
#endif
		if (track_names)
			free_names(track_names);
		track_names = NULL;
		return (0);

	case CMD_CLOSE:
#if defined(CDIOCCLOSE)
		if (!open_cd(cdname, 0))
			return (0);

		(void) ioctl(fd, CDIOCALLOW);
		rc = ioctl(fd, CDIOCCLOSE);
		if (rc < 0)
			return (rc);
		close(fd);
		fd = -1;
		return (0);
#else
		printf("%s: Command not yet supported\n", __progname);
		return (0);
#endif

	case CMD_PLAY:
		if (!open_cd(cdname, 0))
			return (0);

		while (isspace((unsigned char)*arg))
			arg++;

		return play(arg);

	case CMD_SET:
		if (!strcasecmp(arg, "msf"))
			msf = 1;
		else if (!strcasecmp(arg, "lba"))
			msf = 0;
		else
			printf("%s: Invalid command arguments\n", __progname);
		return (0);

	case CMD_VOLUME:
		if (!open_cd(cdname, 0))
			return (0);

		if (!strncasecmp(arg, "left", strlen(arg)))
			return ioctl(fd, CDIOCSETLEFT);

		if (!strncasecmp(arg, "right", strlen(arg)))
			return ioctl(fd, CDIOCSETRIGHT);

		if (!strncasecmp(arg, "mono", strlen(arg)))
			return ioctl(fd, CDIOCSETMONO);

		if (!strncasecmp(arg, "stereo", strlen(arg)))
			return ioctl(fd, CDIOCSETSTEREO);

		if (!strncasecmp(arg, "mute", strlen(arg)))
			return ioctl(fd, CDIOCSETMUTE);

		if (2 != sscanf(arg, "%d%d", &l, &r)) {
			printf("%s: Invalid command arguments\n", __progname);
			return (0);
		}

		return setvol(l, r);

	case CMD_NEXT:
		if (!open_cd(cdname, 0))
			return (0);

		return play_next(arg);

	case CMD_PREV:
		if (!open_cd(cdname, 0))
			return (0);

		return play_prev(arg);

	case CMD_REPLAY:
		if (!open_cd(cdname, 0))
			return 0;

		return play_same(arg);
	case CMD_BLANK:
		if (!open_cd(cdname, 1))
			return 0;

		if (get_media_capabilities(mediacap, 1) == -1) {
			warnx("Can't determine media type");
			return (0);
		}
		if (isset(mediacap, MMC_FEATURE_CDRW_WRITE) == 0 &&
		    get_media_type() != MEDIATYPE_CDRW) {
			warnx("The media doesn't support blanking");
			return (0);
		}

		return blank();
	case CMD_CDRIP:
		if (!open_cd(cdname, 0))
			return (0);

		while (isspace((unsigned char)*arg))
			arg++;

		return cdrip(arg);
	case CMD_CDPLAY:
		if (!open_cd(cdname, 0))
			return (0);

		while (isspace((unsigned char)*arg))
			arg++;

		return cdplay(arg);
	default:
	case CMD_HELP:
		help();
		return (0);

	}
}

/*
 * Check if audio file has RIFF WAVE format. If not, we assume it's just PCM.
 */
int
is_wave(int fd)
{
	char buf[WAVHDRLEN];
	int rv;

	rv = 0;
	if (read(fd, buf, sizeof(buf)) == sizeof(buf)) {
		if (memcmp(buf, "RIFF", 4) == 0 &&
		    memcmp(buf + 8, "WAVE", 4) == 0)
			rv = 1;
	}

	return (rv);
}

__dead void
tao(int argc, char **argv)
{
	struct stat sb;
	struct track_info *cur_track;
	struct track_info *tr;
	off_t availblk, needblk = 0;
	u_int blklen;
	u_int ntracks = 0;
	char type;
	int ch, speed;
	const char *errstr;

	if (argc == 1)
		usage();

	SLIST_INIT(&tracks);
	type = 'd';
	speed = DRIVE_SPEED_OPTIMAL;
	blklen = 2048;
	while (argc > 1) {
		tr = malloc(sizeof(struct track_info));
		if (tr == NULL)
			err(1, "tao");

		optreset = 1;
		optind = 1;
		while ((ch = getopt(argc, argv, "ads:")) != -1) {
			switch (ch) {
			case 'a':
				type = 'a';
				blklen = 2352;
				break;
			case 'd':
				type = 'd';
				blklen = 2048;
				break;
			case 's':
				if (strcmp(optarg, "auto") == 0) {
					speed = DRIVE_SPEED_OPTIMAL;
				} else if (strcmp(optarg, "max") == 0) {
					speed = DRIVE_SPEED_MAX;
				} else {
					speed = (int)strtonum(optarg, 1,
					    CD_MAX_SPEED, &errstr);
					if (errstr != NULL) {
						errx(1,
						    "incorrect speed value");
					}
				}
				break;
			default:
				usage();
				/* NOTREACHED */
			}
		}

		if (speed != DRIVE_SPEED_OPTIMAL && speed != DRIVE_SPEED_MAX)
			tr->speed = CD_SPEED_TO_KBPS(speed, blklen);
		else
			tr->speed = speed;

		tr->type = type;
		tr->blklen = blklen;
		argc -= optind;
		argv += optind;
		if (argv[0] == NULL)
			usage();
		tr->file = argv[0];
		tr->fd = open(tr->file, O_RDONLY, 0640);
		if (tr->fd == -1)
			err(1, "cannot open file %s", tr->file);
		if (fstat(tr->fd, &sb) == -1)
			err(1, "cannot stat file %s", tr->file);
		tr->sz = sb.st_size;
		tr->off = 0;
		if (tr->type == 'a') {
			if (is_wave(tr->fd)) {
				tr->sz -= WAVHDRLEN;
				tr->off = WAVHDRLEN;
			}
		}
		if (SLIST_EMPTY(&tracks))
			SLIST_INSERT_HEAD(&tracks, tr, track_list);
		else
			SLIST_INSERT_AFTER(cur_track, tr, track_list);
		cur_track = tr;
	}

	if (!open_cd(cdname, 1))
		exit(1);
	if (get_media_capabilities(mediacap, 1) == -1)
		errx(1, "Can't determine media type");
	if (isset(mediacap, MMC_FEATURE_CD_TAO) == 0)
		errx(1, "The media can't be written in TAO mode");

	get_disc_size(&availblk);
	SLIST_FOREACH(tr, &tracks, track_list) {
		needblk += tr->sz/tr->blklen;
		ntracks++;
	}
	needblk += (ntracks - 1) * 150; /* transition area between tracks */
	if (needblk > availblk)
		errx(1, "Only %llu of the required %llu blocks available",
		    availblk, needblk);
	if (writetao(&tracks) != 0)
		exit(1);
	else
		exit(0);
}

int
play(char *arg)
{
	struct ioc_toc_header h;
	unsigned char tm, ts, tf;
	unsigned int tr1, tr2, m1, m2, s1, s2, f1, f2, i1, i2;
	unsigned int blk, len, n;
	char c;
	int rc;

	rc = ioctl(fd, CDIOREADTOCHEADER, &h);

	if (rc < 0)
		return (rc);

	if (h.starting_track > h.ending_track) {
		printf("TOC starting_track > TOC ending_track\n");
		return (0);
	}

	n = h.ending_track - h.starting_track + 1;
	rc = read_toc_entrys((n + 1) * sizeof (struct cd_toc_entry));

	if (rc < 0)
		return (rc);

	/*
	 * Truncate trailing white space. Then by adding %c to the end of the
	 * sscanf() formats we catch any errant trailing characters.
	 */
	rc = strlen(arg) - 1;
	while (rc >= 0 && isspace((unsigned char)arg[rc])) {
		arg[rc] = '\0';
		rc--;
	}

	if (!arg || ! *arg) {
		/* Play the whole disc */
		return (play_track(h.starting_track, 1, h.ending_track, 1));
	}

	if (strchr(arg, '#')) {
		/* Play block #blk [ len ] */
		if (2 != sscanf(arg, "#%u%u%c", &blk, &len, &c) &&
		    1 != sscanf(arg, "#%u%c", &blk, &c)) {
			printf("%s: Invalid command arguments\n", __progname);
			return (0);
		}

		if (len == 0) {
			if (msf)
				len = msf2lba(toc_buffer[n].addr.msf.minute,
				    toc_buffer[n].addr.msf.second,
				    toc_buffer[n].addr.msf.frame) - blk;
			else
				len = toc_buffer[n].addr.lba - blk;
		}
		return play_blocks(blk, len);
	}

	if (strchr(arg, ':') == NULL) {
		/*
		 * Play track tr1[.i1] [tr2[.i2]]
		 */
		if (4 == sscanf(arg, "%u.%u%u.%u%c", &tr1, &i1, &tr2, &i2, &c))
			goto play_track;

		i2 = 1;
		if (3 == sscanf(arg, "%u.%u%u%c", &tr1, &i1, &tr2, &c))
			goto play_track;

		i1 = 1;
		if (3 == sscanf(arg, "%u%u.%u%c", &tr1, &tr2, &i2, &c))
			goto play_track;

		tr2 = 0;
		i2 = 1;
		if (2 == sscanf(arg, "%u.%u%c", &tr1, &i1, &c))
			goto play_track;

		i1 = i2 = 1;
		if (2 == sscanf(arg, "%u%u%c", &tr1, &tr2, &c))
			goto play_track;

		i1 = i2 = 1;
		tr2 = 0;
		if (1 == sscanf(arg, "%u%c", &tr1, &c))
			goto play_track;

		printf("%s: Invalid command arguments\n", __progname);
		return (0);

play_track:
		if (tr1 > n || tr2 > n) {
			printf("Track number must be between 0 and %u\n", n);
			return (0);
		} else if (tr2 == 0)
			tr2 = h.ending_track;

		if (tr1 > tr2) {
			printf("starting_track > ending_track\n");
			return (0);
		}

		return (play_track(tr1, i1, tr2, i2));
	}

	/*
	 * Play MSF [tr1] m1:s1[.f1] [tr2] [m2:s2[.f2]]
	 *
	 * Start Time		End Time
	 * ----------		--------
	 * tr1 m1:s1.f1		tr2 m2:s2.f2
	 * tr1 m1:s1   		tr2 m2:s2.f2
	 * tr1 m1:s1.f1		tr2 m2:s2
	 * tr1 m1:s1   		tr2 m2:s2
	 *     m1:s1.f1		tr2 m2:s2.f2
	 *     m1:s1   		tr2 m2:s2.f2
	 *     m1:s1.f1		tr2 m2:s2
	 *     m1:s1   		tr2 m2:s2
	 * tr1 m1:s1.f1		    m2:s2.f2
	 * tr1 m1:s1   		    m2:s2.f2
	 * tr1 m1:s1.f1		    m2:s2
	 * tr1 m1:s1  		    m2:s2
	 *     m1:s1.f1		    m2:s2.f2
	 *     m1:s1       	    m2:s2.f2
	 *     m1:s1.f1  	    m2:s2
	 *     m1:s1     	    m2:s2
	 * tr1 m1:s1.f1		tr2
	 * tr1 m1:s1    	tr2
	 *     m1:s1.f1  	tr2
	 *     m1:s1      	tr2
	 * tr1 m1:s1.f1		<end of disc>
	 * tr1 m1:s1    	<end of disc>
	 *     m1:s1.f1  	<end of disc>
	 *     m1:s1      	<end of disc>
	 */

	/* tr1 m1:s1.f1		tr2 m2:s2.f2 */
	if (8 == sscanf(arg, "%u%u:%u.%u%u%u:%u.%u%c",
	    &tr1, &m1, &s1, &f1, &tr2, &m2, &s2, &f2, &c))
		goto play_msf;

	/* tr1 m1:s1   		tr2 m2:s2.f2 */
	f1 = 0;
	if (7 == sscanf(arg, "%u%u:%u%u%u:%u.%u%c",
	    &tr1, &m1, &s1, &tr2, &m2, &s2, &f2, &c))
		goto play_msf;

	/* tr1 m1:s1.f1		tr2 m2:s2 */
	f2 =0;
	if (7 == sscanf(arg, "%u%u:%u.%u%u%u:%u%c",
	    &tr1, &m1, &s1, &f1, &tr2, &m2, &s2, &c))
		goto play_msf;

	/*     m1:s1.f1		tr2 m2:s2.f2 */
	tr1 = 0;
	if (7 == sscanf(arg, "%u:%u.%u%u%u:%u.%u%c",
	    &m1, &s1, &f1, &tr2, &m2, &s2, &f2, &c))
		goto play_msf;

	/* tr1 m1:s1.f1		    m2:s2.f2 */
	tr2 = 0;
	if (7 == sscanf(arg, "%u%u:%u.%u%u:%u.%u%c",
	    &tr1, &m1, &s1, &f1, &m2, &s2, &f2, &c))
		goto play_msf;

	/*     m1:s1   		tr2 m2:s2.f2 */
	tr1 = f1 = 0;
	if (6 == sscanf(arg, "%u:%u%u%u:%u.%u%c",
	    &m1, &s1, &tr2, &m2, &s2, &f2, &c))
		goto play_msf;

	/*     m1:s1.f1		tr2 m2:s2 */
	tr1 = f2 = 0;
	if (6 == sscanf(arg, "%u:%u.%u%u%u:%u%c",
	    &m1, &s1, &f1, &tr2, &m2, &s2, &c))
		goto play_msf;

	/*     m1:s1.f1		    m2:s2.f2 */
	tr1 = tr2 = 0;
	if (6 == sscanf(arg, "%u:%u.%u%u:%u.%u%c",
	    &m1, &s1, &f1, &m2, &s2, &f2, &c))
		goto play_msf;

	/* tr1 m1:s1.f1		    m2:s2 */
	tr2 = f2 = 0;
	if (6 == sscanf(arg, "%u%u:%u.%u%u:%u%c",
	    &tr1, &m1, &s1, &f1, &m2, &s2, &c))
		goto play_msf;

	/* tr1 m1:s1   		    m2:s2.f2 */
	tr2 = f1 = 0;
	if (6 == sscanf(arg, "%u%u:%u%u:%u.%u%c",
	    &tr1, &m1, &s1, &m2, &s2, &f2, &c))
		goto play_msf;

	/* tr1 m1:s1   		tr2 m2:s2 */
	f1 = f2 = 0;
	if (6 == sscanf(arg, "%u%u:%u%u%u:%u%c",
	    &tr1, &m1, &s1, &tr2, &m2, &s2, &c))
		goto play_msf;

	/*     m1:s1   		tr2 m2:s2 */
	tr1 = f1 = f2 = 0;
	if (5 == sscanf(arg, "%u:%u%u%u:%u%c", &m1, &s1, &tr2, &m2, &s2, &c))
		goto play_msf;

	/* tr1 m1:s1  		    m2:s2 */
	f1 = tr2 = f2 = 0;
	if (5 == sscanf(arg, "%u%u:%u%u:%u%c", &tr1, &m1, &s1, &m2, &s2, &c))
		goto play_msf;

	/*     m1:s1       	    m2:s2.f2 */
	tr1 = f1 = tr2 = 0;
	if (5 == sscanf(arg, "%u:%u%u:%u.%u%c", &m1, &s1, &m2, &s2, &f2, &c))
		goto play_msf;

	/*     m1:s1.f1  	    m2:s2 */
	tr1 = tr2 = f2 = 0;
	if (5 == sscanf(arg, "%u:%u.%u%u:%u%c", &m1, &s1, &f1, &m2, &s2, &c))
		goto play_msf;

	/* tr1 m1:s1.f1		tr2 */
	m2 = s2 = f2 = 0;
	if (5 == sscanf(arg, "%u%u:%u.%u%u%c", &tr1, &m1, &s1, &f1, &tr2, &c))
		goto play_msf;

	/*     m1:s1     	    m2:s2 */
	tr1 = f1 = tr2 = f2 = 0;
	if (4 == sscanf(arg, "%u:%u%u:%u%c", &m1, &s1, &m2, &s2, &c))
		goto play_msf;

	/* tr1 m1:s1.f1		<end of disc> */
	tr2 = m2 = s2 = f2 = 0;
	if (4 == sscanf(arg, "%u%u:%u.%u%c", &tr1, &m1, &s1, &f1, &c))
		goto play_msf;

	/* tr1 m1:s1    	tr2 */
	f1 = m2 = s2 = f2 = 0;
	if (4 == sscanf(arg, "%u%u:%u%u%c", &tr1, &m1, &s1, &tr2, &c))
		goto play_msf;

	/*     m1:s1.f1  	tr2 */
	tr1 = m2 = s2 = f2 = 0;
	if (4 == sscanf(arg, "%u%u:%u%u%c", &m1, &s1, &f1, &tr2, &c))
		goto play_msf;

	/*     m1:s1.f1  	<end of disc> */
	tr1 = tr2 = m2 = s2 = f2 = 0;
	if (3 == sscanf(arg, "%u:%u.%u%c", &m1, &s1, &f1, &c))
		goto play_msf;

	/* tr1 m1:s1    	<end of disc> */
	f1 = tr2 = m2 = s2 = f2 = 0;
	if (3 == sscanf(arg, "%u%u:%u%c", &tr1, &m1, &s1, &c))
		goto play_msf;

	/*     m1:s1      	tr2 */
	tr1 = f1 = m2 = s2 = f2 = 0;
	if (3 == sscanf(arg, "%u:%u%u%c", &m1, &s1, &tr2, &c))
		goto play_msf;

	/*     m1:s1      	<end of disc> */
	tr1 = f1 = tr2 = m2 = s2 = f2 = 0;
	if (2 == sscanf(arg, "%u:%u%c", &m1, &s1, &c))
		goto play_msf;

	printf("%s: Invalid command arguments\n", __progname);
	return (0);

play_msf:
	if (tr1 > n || tr2 > n) {
		printf("Track number must be between 0 and %u\n", n);
		return (0);
	} else if (m1 > 99 || m2 > 99) {
		printf("Minutes must be between 0 and 99\n");
		return (0);
	} else if (s1 > 59 || s2 > 59) {
		printf("Seconds must be between 0 and 59\n");
		return (0);
	} if (f1 > 74 || f2 > 74) {
		printf("Frames number must be between 0 and 74\n");
		return (0);
	}

	if (tr1 > 0) {
		/*
		 * Start time is relative to tr1, Add start time of tr1
		 * to (m1,s1,f1) to yield absolute start time.
		 */
		toc2msf(tr1, &tm, &ts, &tf);
		addmsf(&m1, &s1, &f1, tm, ts, tf);

		/* Compare (m1,s1,f1) to start time of next track. */
		toc2msf(tr1+1, &tm, &ts, &tf);
		if (cmpmsf(m1, s1, f1, tm, ts, tf) == 1) {
			printf("Track %u is not that long.\n", tr1);
			return (0);
		}
	}

	toc2msf(n+1, &tm, &ts, &tf);
	if (cmpmsf(m1, s1, f1, tm, ts, tf) == 1) {
		printf("Start time is after end of disc.\n");
		return (0);
	}

	if (tr2 > 0) {
		/*
		 * End time is relative to tr2, Add start time of tr2
		 * to (m2,s2,f2) to yield absolute end time.
		 */
		toc2msf(tr2, &tm, &ts, &tf);
		addmsf(&m2, &s2, &f2, tm, ts, tf);

		/* Compare (m2,s2,f2) to start time of next track. */
		toc2msf(tr2+1, &tm, &ts, &tf);
		if (cmpmsf(m2, s2, f2, tm, ts, tf) == 1) {
			printf("Track %u is not that long.\n", tr2);
			return (0);
		}
	}

	toc2msf(n+1, &tm, &ts, &tf);

	if (!(tr2 || m2 || s2 || f2)) {
		/* Play to end of disc. */
		m2 = tm;
		s2 = ts;
		f2 = tf;
	} else if (cmpmsf(m2, s2, f2, tm, ts, tf) == 1) {
		printf("End time is after end of disc.\n");
		return (0);
	}

	if (cmpmsf(m1, s1, f1, m2, s2, f2) == 1) {
		printf("Start time is after end time.\n");
		return (0);
	}

	return play_msf(m1, s1, f1, m2, s2, f2);
}

/* ARGSUSED */
int
play_prev(char *arg)
{
	int trk, min, sec, frm, rc;
	struct ioc_toc_header h;

	if (status(&trk, &min, &sec, &frm) >= 0) {
		trk--;

		rc = ioctl(fd, CDIOREADTOCHEADER, &h);
		if (rc < 0) {
			warn("getting toc header");
			return (rc);
		}

		if (trk < h.starting_track)
			return play_track(h.starting_track, 1,
			    h.ending_track + 1, 1);
		return play_track(trk, 1, h.ending_track, 1);
	}

	return (0);
}

/* ARGSUSED */
int
play_same(char *arg)
{
	int trk, min, sec, frm, rc;
	struct ioc_toc_header h;

	if (status (&trk, &min, &sec, &frm) >= 0) {
		rc = ioctl(fd, CDIOREADTOCHEADER, &h);
		if (rc < 0) {
			warn("getting toc header");
			return (rc);
		}

		return play_track(trk, 1, h.ending_track, 1);
	}

	return (0);
}

/* ARGSUSED */
int
play_next(char *arg)
{
	int trk, min, sec, frm, rc;
	struct ioc_toc_header h;

	if (status(&trk, &min, &sec, &frm) >= 0) {
		trk++;
		rc = ioctl(fd, CDIOREADTOCHEADER, &h);
		if (rc < 0) {
			warn("getting toc header");
			return (rc);
		}

		if (trk > h.ending_track) {
			printf("%s: end of CD\n", __progname);

			rc = ioctl(fd, CDIOCSTOP);

			(void) ioctl(fd, CDIOCALLOW);

			return (rc);
		}

		return play_track(trk, 1, h.ending_track, 1);
	}

	return (0);
}

char *
strstatus(int sts)
{
	switch (sts) {
	case ASTS_INVALID:
		return ("invalid");
	case ASTS_PLAYING:
		return ("playing");
	case ASTS_PAUSED:
		return ("paused");
	case ASTS_COMPLETED:
		return ("completed");
	case ASTS_ERROR:
		return ("error");
	case ASTS_VOID:
		return ("void");
	default:
		return ("??");
	}
}

/* ARGSUSED */
int
pstatus(char *arg)
{
	struct ioc_vol v;
	struct ioc_read_subchannel ss;
	struct cd_sub_channel_info data;
	int rc, trk, m, s, f;
	char vis_catalog[1 + 4 * 15];

	rc = status(&trk, &m, &s, &f);
	if (rc >= 0) {
		if (verbose) {
			if (track_names)
				printf("Audio status = %d<%s>, "
				    "current track = %d (%s)\n"
				    "\tcurrent position = %d:%02d.%02d\n",
				    rc, strstatus(rc), trk,
				    trk ? track_names[trk-1] : "", m, s, f);
			else
				printf("Audio status = %d<%s>, "
				    "current track = %d, "
				    "current position = %d:%02d.%02d\n",
				    rc, strstatus(rc), trk, m, s, f);
		} else
			printf("%d %d %d:%02d.%02d\n", rc, trk, m, s, f);
	} else
		printf("No current status info available\n");

	bzero(&ss, sizeof (ss));
	ss.data = &data;
	ss.data_len = sizeof (data);
	ss.address_format = msf ? CD_MSF_FORMAT : CD_LBA_FORMAT;
	ss.data_format = CD_MEDIA_CATALOG;
	rc = ioctl(fd, CDIOCREADSUBCHANNEL, (char *) &ss);
	if (rc >= 0) {
		printf("Media catalog is %sactive",
		ss.data->what.media_catalog.mc_valid ? "": "in");
		if (ss.data->what.media_catalog.mc_valid &&
		    ss.data->what.media_catalog.mc_number[0]) {
			strvisx(vis_catalog,
			    (char *)ss.data->what.media_catalog.mc_number,
			    15, VIS_SAFE);
			printf(", number \"%.15s\"", vis_catalog);
		}
		putchar('\n');
	} else
		printf("No media catalog info available\n");

	rc = ioctl(fd, CDIOCGETVOL, &v);
	if (rc >= 0) {
		if (verbose)
			printf("Left volume = %d, right volume = %d\n",
			    v.vol[0], v.vol[1]);
		else
			printf("%d %d\n", v.vol[0], v.vol[1]);
	} else
		printf("No volume level info available\n");
	return(0);
}

int
cdid(void)
{
	unsigned long id;
	struct ioc_toc_header h;
	int rc, n;

	rc = ioctl(fd, CDIOREADTOCHEADER, &h);
	if (rc == -1) {
		warn("getting toc header");
		return (rc);
	}

	n = h.ending_track - h.starting_track + 1;
	rc = read_toc_entrys((n + 1) * sizeof (struct cd_toc_entry));
	if (rc < 0)
		return (rc);

	id = cddb_discid(n, toc_buffer);
	if (id) {
		if (verbose)
			printf("CDID=");
		printf("%08lx\n", id);
	}
	return id ? 0 : 1;
}

/* ARGSUSED */
int
info(char *arg)
{
	struct ioc_toc_header h;
	int rc, i, n;

	if (get_media_capabilities(mediacap, 1) == -1)
		errx(1, "Can't determine media type");

	rc = ioctl(fd, CDIOREADTOCHEADER, &h);
	if (rc >= 0) {
		if (verbose)
			printf("Starting track = %d, ending track = %d, TOC size = %d bytes\n",
			    h.starting_track, h.ending_track, h.len);
		else
			printf("%d %d %d\n", h.starting_track,
			    h.ending_track, h.len);
	} else {
		warn("getting toc header");
		return (rc);
	}

	n = h.ending_track - h.starting_track + 1;
	rc = read_toc_entrys((n + 1) * sizeof (struct cd_toc_entry));
	if (rc < 0)
		return (rc);

	if (verbose) {
		printf("track     start  duration   block  length   type\n");
		printf("-------------------------------------------------\n");
	}

	for (i = 0; i < n; i++) {
		printf("%5d  ", toc_buffer[i].track);
		prtrack(toc_buffer + i, 0, NULL);
	}
	printf("%5d  ", toc_buffer[n].track);
	prtrack(toc_buffer + n, 1, NULL);
	return (0);
}

int
cddbinfo(char *arg)
{
	struct ioc_toc_header h;
	int rc, i, n;

	rc = ioctl(fd, CDIOREADTOCHEADER, &h);
	if (rc == -1) {
		warn("getting toc header");
		return (rc);
	}

	n = h.ending_track - h.starting_track + 1;
	rc = read_toc_entrys((n + 1) * sizeof (struct cd_toc_entry));
	if (rc < 0)
		return (rc);

	if (track_names)
		free_names(track_names);
	track_names = NULL;

	track_names = cddb(cddb_host, n, toc_buffer, arg);
	if (!track_names)
		return(0);

	printf("-------------------------------------------------\n");

	for (i = 0; i < n; i++) {
		printf("%5d  ", toc_buffer[i].track);
		prtrack(toc_buffer + i, 0, track_names[i]);
	}
	printf("%5d  ", toc_buffer[n].track);
	prtrack(toc_buffer + n, 1, "");
	return (0);
}

void
lba2msf(unsigned long lba, u_char *m, u_char *s, u_char *f)
{
	lba += 150;		/* block start offset */
	lba &= 0xffffff;	/* negative lbas use only 24 bits */
	*m = lba / (60 * 75);
	lba %= (60 * 75);
	*s = lba / 75;
	*f = lba % 75;
}

unsigned int
msf2lba(u_char m, u_char s, u_char f)
{
	return (((m * 60) + s) * 75 + f) - 150;
}

unsigned long
entry2time(struct cd_toc_entry *e)
{
	int block;
	u_char m, s, f;

	if (msf) {
		return (e->addr.msf.minute * 60 + e->addr.msf.second);
	} else {
		block = e->addr.lba;
		lba2msf(block, &m, &s, &f);
		return (m*60+s);
	}
}

unsigned long
entry2frames(struct cd_toc_entry *e)
{
	int block;
	unsigned char m, s, f;

	if (msf) {
		return e->addr.msf.frame + e->addr.msf.second * 75 +
		    e->addr.msf.minute * 60 * 75;
	} else {
		block = e->addr.lba;
		lba2msf(block, &m, &s, &f);
		return f + s * 75 + m * 60 * 75;
	}
}

void
prtrack(struct cd_toc_entry *e, int lastflag, char *name)
{
	int block, next, len;
	u_char m, s, f;

	if (msf) {
		if (!name || lastflag)
			/* Print track start */
			printf("%2d:%02d.%02d  ", e->addr.msf.minute,
			    e->addr.msf.second, e->addr.msf.frame);

		block = msf2lba(e->addr.msf.minute, e->addr.msf.second,
			e->addr.msf.frame);
	} else {
		block = e->addr.lba;
		if (!name || lastflag) {
			lba2msf(block, &m, &s, &f);
			/* Print track start */
			printf("%2d:%02d.%02d  ", m, s, f);
		}
	}
	if (lastflag) {
		if (!name)
			/* Last track -- print block */
			printf("       -  %6d       -      -\n", block);
		else
			printf("\n");
		return;
	}

	if (msf)
		next = msf2lba(e[1].addr.msf.minute, e[1].addr.msf.second,
			e[1].addr.msf.frame);
	else
		next = e[1].addr.lba;
	len = next - block;
	lba2msf(len - 150, &m, &s, &f);

	if (name)
		printf("%2d:%02d.%02d  %s\n", m, s, f, name);
	/* Print duration, block, length, type */
	else
		printf("%2d:%02d.%02d  %6d  %6d  %5s\n", m, s, f, block, len,
		    (e->control & 4) ? "data" : "audio");
}

int
play_track(int tstart, int istart, int tend, int iend)
{
	struct ioc_play_track t;

	t.start_track = tstart;
	t.start_index = istart;
	t.end_track = tend;
	t.end_index = iend;

	return ioctl(fd, CDIOCPLAYTRACKS, &t);
}

int
play_blocks(int blk, int len)
{
	struct ioc_play_blocks  t;

	t.blk = blk;
	t.len = len;

	return ioctl(fd, CDIOCPLAYBLOCKS, &t);
}

int
setvol(int left, int right)
{
	struct ioc_vol  v;

	v.vol[0] = left;
	v.vol[1] = right;
	v.vol[2] = 0;
	v.vol[3] = 0;

	return ioctl(fd, CDIOCSETVOL, &v);
}

int
read_toc_entrys(int len)
{
	struct ioc_read_toc_entry t;

	if (toc_buffer) {
		free(toc_buffer);
		toc_buffer = 0;
	}

	toc_buffer = malloc(len);

	if (!toc_buffer) {
		errno = ENOMEM;
		return (-1);
	}

	t.address_format = msf ? CD_MSF_FORMAT : CD_LBA_FORMAT;
	t.starting_track = 0;
	t.data_len = len;
	t.data = toc_buffer;

	return (ioctl(fd, CDIOREADTOCENTRYS, (char *) &t));
}

int
play_msf(int start_m, int start_s, int start_f, int end_m, int end_s, int end_f)
{
	struct ioc_play_msf a;

	a.start_m = start_m;
	a.start_s = start_s;
	a.start_f = start_f;
	a.end_m = end_m;
	a.end_s = end_s;
	a.end_f = end_f;

	return ioctl(fd, CDIOCPLAYMSF, (char *) &a);
}

int
status(int *trk, int *min, int *sec, int *frame)
{
	struct ioc_read_subchannel s;
	struct cd_sub_channel_info data;
	u_char mm, ss, ff;

	bzero(&s, sizeof (s));
	s.data = &data;
	s.data_len = sizeof (data);
	s.address_format = msf ? CD_MSF_FORMAT : CD_LBA_FORMAT;
	s.data_format = CD_CURRENT_POSITION;

	if (ioctl(fd, CDIOCREADSUBCHANNEL, (char *) &s) < 0)
		return -1;

	*trk = s.data->what.position.track_number;
	if (msf) {
		*min = s.data->what.position.reladdr.msf.minute;
		*sec = s.data->what.position.reladdr.msf.second;
		*frame = s.data->what.position.reladdr.msf.frame;
	} else {
		/*
		 * NOTE: CDIOCREADSUBCHANNEL does not put the lba info into
		 * host order like CDIOREADTOCENTRYS does.
		 */
		lba2msf(betoh32(s.data->what.position.reladdr.lba), &mm, &ss,
		    &ff);
		*min = mm;
		*sec = ss;
		*frame = ff;
	}

	return s.data->header.audio_status;
}

char *
input(int *cmd)
{
	char *buf;
	int siz = 0;
	char *p;
	HistEvent hev;

	do {
		if ((buf = (char *) el_gets(el, &siz)) == NULL || !siz) {
			*cmd = CMD_QUIT;
			fprintf(stderr, "\r\n");
			return (0);
		}
		if (strlen(buf) > 1)
			history(hist, &hev, H_ENTER, buf);
		p = parse(buf, cmd);
	} while (!p);
	return (p);
}

char *
parse(char *buf, int *cmd)
{
	struct cmdtab *c;
	char *p;
	size_t len;

	for (p=buf; isspace((unsigned char)*p); p++)
		continue;

	if (isdigit((unsigned char)*p) ||
	    (p[0] == '#' && isdigit((unsigned char)p[1]))) {
		*cmd = CMD_PLAY;
		return (p);
	}

	for (buf = p; *p && ! isspace((unsigned char)*p); p++)
		continue;

	len = p - buf;
	if (!len)
		return (0);

	if (*p) {		/* It must be a spacing character! */
		char *q;

		*p++ = 0;
		for (q=p; *q && *q != '\n' && *q != '\r'; q++)
			continue;
		*q = 0;
	}

	*cmd = -1;
	for (c=cmdtab; c->name; ++c) {
		/* Is it an exact match? */
		if (!strcasecmp(buf, c->name)) {
			*cmd = c->command;
			break;
		}

		/* Try short hand forms then... */
		if (len >= c->min && ! strncasecmp(buf, c->name, len)) {
			if (*cmd != -1 && *cmd != c->command) {
				fprintf(stderr, "Ambiguous command\n");
				return (0);
			}
			*cmd = c->command;
		}
	}

	if (*cmd == -1) {
		fprintf(stderr, "%s: Invalid command, enter ``help'' for commands.\n",
		    __progname);
		return (0);
	}

	while (isspace((unsigned char)*p))
		p++;
	return p;
}

int
open_cd(char *dev, int needwrite)
{
	char *realdev;
	int tries;

	if (fd > -1) {
		if (needwrite && !writeperm) {
			close(fd);
			fd = -1;
		} else
			return (1);
	}

	for (tries = 0; fd < 0 && tries < 10; tries++) {
		if (needwrite)
			fd = opendev(dev, O_RDWR, OPENDEV_PART, &realdev);
		else
			fd = opendev(dev, O_RDONLY, OPENDEV_PART, &realdev);
		if (fd < 0) {
			if (errno == ENXIO) {
				/*  ENXIO has an overloaded meaning here.
				 *  The original "Device not configured" should
				 *  be interpreted as "No disc in drive %s". */
				warnx("No disc in drive %s.", realdev);
				return (0);
			} else if (errno != EIO) {
				/*  EIO may simply mean the device is not ready
				 *  yet which is common with CD changers. */
				warn("Can't open %s", realdev);
				return (0);
			}
		}
		sleep(1);
	}
	if (fd < 0) {
		warn("Can't open %s", realdev);
		return (0);
	}
	writeperm = needwrite;
	return (1);
}

char *
prompt(void)
{
	return (verbose ? "cdio> " : "");
}

void
switch_el(void)
{
	HistEvent hev;

	if (el == NULL && hist == NULL) {
		el = el_init(__progname, stdin, stdout, stderr);
		hist = history_init();
		history(hist, &hev, H_SETSIZE, 100);
		el_set(el, EL_HIST, history, hist);
		el_set(el, EL_EDITOR, "emacs");
		el_set(el, EL_PROMPT, prompt);
		el_set(el, EL_SIGNAL, 1);
		el_source(el, NULL);

	} else {
		if (hist != NULL) {
			history_end(hist);
			hist = NULL;
		}
		if (el != NULL) {
			el_end(el);
			el = NULL;
		}
	}
}

void
addmsf(u_int *m, u_int *s, u_int *f, u_char m_inc, u_char s_inc, u_char f_inc)
{
	*f += f_inc;
	if (*f > 75) {
		*s += *f / 75;
		*f %= 75;
	}

	*s += s_inc;
	if (*s > 60) {
		*m += *s / 60;
		*s %= 60;
	}

	*m += m_inc;
}

int
cmpmsf(u_char m1, u_char s1, u_char f1, u_char m2, u_char s2, u_char f2)
{
	if (m1 > m2)
		return (1);
	else if (m1 < m2)
		return (-1);

	if (s1 > s2)
		return (1);
	else if (s1 < s2)
		return (-1);

	if  (f1 > f2)
		return (1);
	else if (f1 < f2)
		return (-1);

	return (0);
}

void
toc2msf(u_int track, u_char *m, u_char *s, u_char *f)
{
	struct cd_toc_entry *ctep;

	ctep = &toc_buffer[track - 1];

	if (msf) {
		*m = ctep->addr.msf.minute;
		*s = ctep->addr.msf.second;
		*f = ctep->addr.msf.frame;
	} else
		lba2msf(ctep->addr.lba, m, s, f);
}
@


1.73
log
@unsigned char casts where neccessary
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.72 2010/03/01 02:09:44 krw Exp $	*/
d55 1
a55 1
#include <sys/param.h>
d70 1
d323 1
a323 1
	static char newcdname[MAXPATHLEN];
@


1.72
log
@Add printing of current profile and feature information to 'info'
command with -v. Make a second -v cause printing of raw feature
data and a full list of profiles. A few minor tweaks to the feature
bitmap handling. Helps in debugging media problems in cdio.

Suggestions from fgsch@@, man page fixes from jmc@@ as usual.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.71 2009/06/09 22:20:44 jmc Exp $	*/
d208 1
a208 1
				n = toupper(*s);
d458 1
a458 1
		while (isspace(*arg))
d534 1
a534 1
		while (isspace(*arg))
d542 1
a542 1
		while (isspace(*arg))
d715 1
a715 1
	while (rc >= 0 && isspace(arg[rc])) {
d1527 1
a1527 1
	for (p=buf; isspace(*p); p++)
d1530 2
a1531 1
	if (isdigit(*p) || (p[0] == '#' && isdigit(p[1]))) {
d1536 1
a1536 1
	for (buf = p; *p && ! isspace(*p); p++)
d1576 1
a1576 1
	while (isspace(*p))
@


1.71
log
@try to get "play" right; help/ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.70 2009/06/03 00:45:59 naddy Exp $	*/
d153 1
a153 1
int		mediacap[MMC_FEATURE_MAX / 8];
d249 1
a249 1
			verbose = 2;
d269 1
a269 1
		if (verbose == 2)
d1219 3
@


1.70
log
@Synchronize man page and help output.
From a least of details by sobrado@@; input by jmc@@ who still isn't happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.69 2009/02/07 20:21:13 naddy Exp $	*/
d132 2
a133 2
{ CMD_PLAY,     "play",         1, "[track1[.index1]] track2[.index2]" },
{ CMD_PLAY,     "play",         1, "[tr1] m1:s1[.f1] [tr2] [m2:s2[.f2]]" },
@


1.69
log
@Restore the original help output: capitalize the characters that
are required to uniquely identify a command.
Three characters are required for the cdplay and cdrip commands.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.68 2008/10/29 00:07:07 deraadt Exp $	*/
d117 5
d126 1
d132 1
a132 1
{ CMD_PLAY,     "play",         1, "track1[.index1] [track2[.index2]]" },
d137 1
d140 1
a140 2
{ CMD_REPLAY,	"replay",	3, "" },
{ CMD_SET,      "set",          2, "msf | lba" },
d143 2
a144 7
{ CMD_VOLUME,   "volume",       1, "<l> <r> | left | right | mute | mono | stereo" },
{ CMD_CDDB,	"cddbinfo",     2, "[n]" },
{ CMD_CDID,	"cdid",		3, "" },
{ CMD_QUIT,	"exit",		2, "" },
{ CMD_BLANK,	"blank",	1, "" },
{ CMD_CDRIP,	"cdrip",	3, "[[track1-trackN] ...]" },
{ CMD_CDPLAY,	"cdplay",	3, "[[track1-trackN] ...]" },
@


1.68
log
@no need to warn about using the default device; Thomas Pfaff
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.67 2008/08/30 10:41:38 fgsch Exp $	*/
d114 1
a114 1
	unsigned int min;
d142 2
a143 2
{ CMD_CDRIP,	"cdrip",	1, "[[track1-trackN] ...]" },
{ CMD_CDPLAY,	"cdplay",	1, "[[track1-trackN] ...]" },
d199 1
a199 1
	u_int i;
@


1.67
log
@use a bitmap to store the features. simplify the code a bit and allow for
future work.  ok av@@ a similar diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.66 2008/08/13 12:21:19 av Exp $	*/
d268 4
a271 2
		fprintf(stderr,
		    "No CD device name specified. Defaulting to %s.\n", cdname);
@


1.66
log
@Old drives (reported Giovanni Bechis <bigionews@@snb.it>) don't report CD-RW
write feature. Add additional check for media type before blanking.
The patch fixes problem for Giovanni.
ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.65 2008/08/08 07:26:40 fgsch Exp $	*/
d152 1
a152 1
int		mediacap = 0;
d516 1
a516 1
		if (get_media_capabilities(&mediacap) == -1) {
d520 1
a520 1
		if ((mediacap & MEDIACAP_CDRW_WRITE) == 0 &&
d661 1
a661 1
	if (get_media_capabilities(&mediacap) == -1)
d663 1
a663 1
	if ((mediacap & MEDIACAP_TAO) == 0)
@


1.65
log
@o use definitions from cd.h
o remove unused function prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.64 2008/07/23 21:33:32 av Exp $	*/
d520 2
a521 1
		if ((mediacap & MEDIACAP_CDRW_WRITE) == 0) {
@


1.64
log
@we really need unsigned in arithmetic operations.
comments by fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.63 2008/06/30 23:35:39 av Exp $	*/
a167 1
int		get_vol(int *, int *);
@


1.63
log
@set speed for writing tracks in TAO.
ok and tweaks by fgsch
manual page by jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.62 2008/06/22 21:04:01 av Exp $	*/
d1519 1
a1519 1
	int len;
@


1.62
log
@Automatically distinguish between CD-DA track and WAVE audio file writing them
in TAO mode. For WAVE files we should skip header.

ok and comments by fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.61 2008/06/11 21:59:25 av Exp $	*/
d152 1
d170 1
a170 1
int		is_wave(int fd);
d319 1
a319 1
	int l, r, rc, cap;
d517 1
a517 1
		if (get_media_capabilities(&cap) == -1) {
d521 1
a521 1
		if ((cap & MEDIACAP_CDRW_WRITE) == 0) {
d580 2
a581 1
	int ch, cap;
d588 1
a594 1
		tr->type = type;
d597 1
a597 1
		while ((ch = getopt(argc, argv, "ad")) != -1) {
d607 14
d627 5
d661 1
a661 1
	if (get_media_capabilities(&cap) == -1)
d663 1
a663 1
	if ((cap & MEDIACAP_TAO) == 0)
@


1.61
log
@move tao code from main() into its own function before adding features.
requested and ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.60 2008/06/08 21:40:58 av Exp $	*/
d169 1
d550 19
d624 7
a630 2
		if (tr->type == 'a')
			tr->sz -= WAVHDRLEN;
@


1.60
log
@check whether media supports TAO or blanking.
It makes error output nicer, e.g.: "The media can't be written in TAO mode"
instead of "cdio: Only 0 of the required _N_ blocks available"
ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.59 2008/06/06 10:16:52 av Exp $	*/
d169 1
a231 8
	struct stat sb;
	struct track_info *cur_track;
	struct track_info *tr;
	off_t availblk, needblk = 0;
	u_int blklen;
	u_int ntracks = 0;
	char type;
	int cap;
d271 3
a273 67
	if (argc > 0 && ! strcasecmp(*argv, "tao")) {
		if (argc == 1)
			usage();
		SLIST_INIT(&tracks);
		type = 'd';
		blklen = 2048;
		while (argc > 1) {
			tr = malloc(sizeof(struct track_info));
			tr->type = type;
			optreset = 1;
			optind = 1;
			while ((ch = getopt(argc, argv, "ad")) != -1) {
				switch (ch) {
				case 'a':
					type = 'a';
					blklen = 2352;
					break;
				case 'd':
					type = 'd';
					blklen = 2048;
					break;
				default:
					usage();
				}
			}
			tr->type = type;
			tr->blklen = blklen;
			argc -= optind;
			argv += optind;
			if (argv[0] == NULL)
				usage();
			tr->file = argv[0];
			tr->fd = open(tr->file, O_RDONLY, 0640);
			if (tr->fd == -1)
				err(1, "cannot open file %s", tr->file);
			if (fstat(tr->fd, &sb) == -1)
				err(1, "cannot stat file %s", tr->file);
			tr->sz = sb.st_size;
			if (tr->type == 'a')
				tr->sz -= WAVHDRLEN;
			if (SLIST_EMPTY(&tracks))
				SLIST_INSERT_HEAD(&tracks, tr, track_list);
			else
				SLIST_INSERT_AFTER(cur_track, tr, track_list);
			cur_track = tr;
		}
		if (!open_cd(cdname, 1))
			exit(1);

		if (get_media_capabilities(&cap) == -1)
			errx(1, "Can't determine media type");
		if ((cap & MEDIACAP_TAO) == 0)
			errx(1, "The media can't be written in TAO mode");

		get_disc_size(&availblk);
		SLIST_FOREACH(tr, &tracks, track_list) {
			needblk += tr->sz/tr->blklen;
			ntracks++;
		}
		needblk += (ntracks - 1) * 150; /* transition area between tracks */
		if (needblk > availblk)
			errx(1, "Only %llu of the required %llu blocks available",
			    availblk, needblk);
		if (writetao(&tracks) != 0)
			exit(1);
		else
			exit(0);
d547 86
@


1.59
log
@Make open_cd() remember open mode. "blank" doesn't have to check for EPERM
anymore.
idea by jakemsr
ok jakemsr ratchov fgsch (with tweaks)
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.58 2008/05/07 23:27:50 fgsch Exp $	*/
d238 1
d326 6
d388 1
a388 1
	int l, r, rc;
d585 9
@


1.58
log
@correct duration by taking the pre-gap into account; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.57 2007/05/26 03:00:03 mjc Exp $	*/
d151 1
d391 1
a391 1
		if (fd < 0 && ! open_cd(cdname, 0))
d397 1
a397 1
		if (fd < 0 && ! open_cd(cdname, 0))
d403 1
a403 1
		if (fd < 0 && ! open_cd(cdname, 0))
d408 1
a408 1
		if (fd < 0 && ! open_cd(cdname, 0))
d414 1
a414 1
		if (fd < 0 && ! open_cd(cdname, 0))
d420 1
a420 1
		if (fd < 0 && ! open_cd(cdname, 0))
d426 1
a426 1
		if (fd < 0 && ! open_cd(cdname, 0))
d436 1
a436 1
		if (fd < 0 && ! open_cd(cdname, 0))
d447 1
a447 1
		if (fd < 0 && ! open_cd(cdname, 0))
d481 1
a481 1
		if (fd < 0 && ! open_cd(cdname, 0))
d499 1
a499 1
		if (fd < 0 && ! open_cd(cdname, 0))
d515 1
a515 1
		if (fd < 0 && ! open_cd(cdname, 0))
d533 1
a533 1
		if (fd < 0 && !open_cd(cdname, 0))
d559 1
a559 1
		if (fd < 0 && ! open_cd(cdname, 0))
d565 1
a565 1
		if (fd < 0 && ! open_cd(cdname, 0))
d571 1
a571 1
		if (fd < 0 && ! open_cd(cdname, 0))
d576 1
a576 1
		if (fd < 0 && ! open_cd(cdname, 1))
d581 1
a581 1
		if (fd < 0 && ! open_cd(cdname, 0))
d589 1
a589 1
		if (fd < 0 && ! open_cd(cdname, 0))
d1503 7
a1509 2
	if (fd > -1)
		return (1);
d1536 1
@


1.57
log
@cdrip and cdplay commands from Alexey Vatchenko
incorporating some manpage suggestions from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.56 2006/08/25 04:38:32 deraadt Exp $	*/
d1292 1
a1292 1
	lba2msf(len, &m, &s, &f);
@


1.56
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.55 2006/08/24 19:35:55 deraadt Exp $	*/
d108 2
d142 2
d579 16
@


1.55
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.54 2006/06/16 17:06:04 deraadt Exp $	*/
d229 1
a229 1
	off_t availblk,needblk = 0;
d328 1
a328 1
			    availblk,needblk);
@


1.54
log
@lint cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.53 2006/06/15 23:49:58 mjc Exp $	*/
d327 2
a328 2
			errx(1,"Only %llu of the required %llu blocks available",
			     availblk,needblk);
@


1.53
log
@put fd into track's struct so we can fail earlier
'looks good' pat@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.52 2006/06/06 23:22:28 deraadt Exp $	*/
d192 1
a192 1
	int i;
d194 1
a194 1
	for (c=cmdtab; c->name; ++c) {
@


1.52
log
@minor cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.51 2006/06/01 07:53:01 deraadt Exp $	*/
d304 5
a308 4
			if (stat(tr->file, &sb) != 0) {
				warn("cannot stat file %s",tr->file);
				return (-1);
			}
d313 1
a313 1
				SLIST_INSERT_HEAD(&tracks,tr,track_list);
d315 1
a315 1
				SLIST_INSERT_AFTER(cur_track,tr,track_list);
@


1.51
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.50 2006/06/01 07:12:18 mjc Exp $	*/
d136 1
a136 1
{ CMD_CDDB,   	"cddbinfo",     2, "[n]" },
d143 1
a143 1
struct cd_toc_entry     *toc_buffer;
d146 5
a150 5
int             fd = -1;
int             verbose = 1;
int             msf = 1;
const char 	*cddb_host;
char            **track_names;
d152 2
a153 2
EditLine       *el = NULL;	/* line-editing structure */
History	       *hist = NULL;	/* line-editing history */
d156 1
a156 1
extern char     *__progname;
d158 10
a167 10
int             setvol(int, int);
int             read_toc_entrys(int);
int             play_msf(int, int, int, int, int, int);
int             play_track(int, int, int, int);
int             get_vol(int *, int *);
int             status(int *, int *, int *, int *);
int             play(char *arg);
int             info(char *arg);
int             cddbinfo(char *arg);
int             pstatus(char *arg);
d171 1
a171 1
char            *input(int *);
d173 7
a179 7
void            prtrack(struct cd_toc_entry *e, int lastflag, char *name);
void            lba2msf(unsigned long lba, u_char *m, u_char *s, u_char *f);
unsigned int    msf2lba(u_char m, u_char s, u_char f);
int             play_blocks(int blk, int len);
int             run(int cmd, char *arg);
char            *parse(char *buf, int *cmd);
void 		help(void);
d181 1
a181 1
char 		*strstatus(int);
d1063 3
a1065 3
		    	strvisx(vis_catalog,
			   (char *)ss.data->what.media_catalog.mc_number,
			   15, VIS_SAFE);
d1076 1
a1076 1
				v.vol[0], v.vol[1]);
d1450 2
a1451 2
  			*cmd = c->command;
  			break;
@


1.50
log
@add checks for disc size before we set out trying to burn 4gb
onto an unsuspecting cdr
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.49 2006/06/01 06:32:17 mjc Exp $	*/
d195 1
a195 1
		if (! c->args)
d235 1
a235 1
	if (! cdname)
d266 1
a266 1
	if (! cdname) {
d317 1
a317 1
		if (! open_cd(cdname, 1))
d444 1
a444 1
		if (! strcasecmp(arg, "on"))
d447 1
a447 1
		if (! strcasecmp(arg, "off"))
d468 1
a468 1
		if (! open_cd(arg, 0))
d618 1
a618 1
	if (! arg || ! *arg) {
d943 1
a943 1
			return play_track(h.starting_track, 1, 
d1358 1
a1358 1
int 
d1434 1
a1434 1
	if (! len)
d1449 1
a1449 1
		if (! strcasecmp(buf, c->name)) {
@


1.49
log
@better command line usage as suggested by deraadt@@
ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.48 2006/05/31 01:14:41 mjc Exp $	*/
d229 3
d277 1
d287 1
d291 1
d298 1
d309 2
d319 9
@


1.48
log
@add rewritable blanking and track-at-once burning support

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.47 2006/01/20 00:58:32 krw Exp $	*/
d59 1
d61 1
d150 1
a150 2
char		**track_names;
char            *track_types;
a163 1
int             open_cd(char *, int);
d226 4
d270 25
a294 8
		optreset = 1;
		optind = 0;
		while ((ch = getopt(argc, argv, "t:")) != -1) {
			switch (ch) {
			case 't':
				track_types = optarg;
				break;
			default:
d296 4
d301 6
a306 1

a307 4
		argc -= optind;
		argv += optind;
		if (argc == 0)
			usage();
d310 1
a310 1
		if (writetao(argc,argv) != 0)
a314 1

@


1.47
log
@Clean up command line parsing, don't accept trailing garbage, add in
missing command line forms, zero variables that will not be filled in
by a particular sscanf() call. Make 'play tr1 m1:s1 m2:s2' play from
the point in time 'tr1 m1:s1' to the point in time 'm2:s2', instead of
from 'tr1 m1:s1' for a period of m2:s2. Documenting this command is next.

Closes last issues Juha Erkilla pointed out in PR #4957. Tested by
Juha.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.46 2006/01/11 01:29:07 krw Exp $	*/
d59 1
d105 1
d137 1
d149 1
d163 1
a163 1
int             open_cd(char *);
d265 25
d342 1
a342 1
		if (fd < 0 && ! open_cd(cdname))
d348 1
a348 1
		if (fd < 0 && ! open_cd(cdname))
d354 1
a354 1
		if (fd < 0 && ! open_cd(cdname))
d359 1
a359 1
		if (fd < 0 && ! open_cd(cdname))
d365 1
a365 1
		if (fd < 0 && ! open_cd(cdname))
d371 1
a371 1
		if (fd < 0 && ! open_cd(cdname))
d377 1
a377 1
		if (fd < 0 && ! open_cd(cdname))
d387 1
a387 1
		if (fd < 0 && ! open_cd(cdname))
d398 1
a398 1
		if (fd < 0 && ! open_cd(cdname))
d425 1
a425 1
		if (!open_cd(arg))
d432 1
a432 1
		if (fd < 0 && ! open_cd(cdname))
d450 1
a450 1
		if (fd < 0 && ! open_cd(cdname))
d466 1
a466 1
		if (fd < 0 && ! open_cd(cdname))
d484 1
a484 1
		if (fd < 0 && !open_cd(cdname))
d510 1
a510 1
		if (fd < 0 && ! open_cd(cdname))
d516 1
a516 1
		if (fd < 0 && ! open_cd(cdname))
d522 1
a522 1
		if (fd < 0 && ! open_cd(cdname))
d526 5
d1433 1
a1433 1
open_cd(char *dev)
d1442 4
a1445 1
		fd = opendev(dev, O_RDONLY, OPENDEV_PART, &realdev);
@


1.46
log
@Whitespace nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.45 2006/01/10 19:59:11 krw Exp $	*/
a119 1
{ CMD_PLAY,     "play",         1, "min1:sec1[.fram1] [min2:sec2[.fram2]]" },
d121 1
a121 1
{ CMD_PLAY,     "play",         1, "tr1 m1:s1[.f1] [[tr2] [m2:s2[.f2]]]" },
d473 1
a473 1
		if (2 != sscanf(arg, "%d %d", &l, &r)) {
d509 5
a513 1
	int rc, n, start, end = 0, istart = 1, iend = 1;
d520 5
d531 10
d543 1
a543 2
		return (play_track(h.starting_track, 1,
		    h.ending_track, 1));
d548 5
a552 5
		int blk, len = 0;

		if (2 != sscanf(arg, "#%d%d", &blk, &len) &&
		    1 != sscanf(arg, "#%d", &blk))
			goto Clean_up;
d565 1
a565 1
	if (strchr(arg, ':')) {
d567 1
a567 6
		 * Play MSF m1:s1 [ .f1 ] [ m2:s2 [ .f2 ] ]
		 *
		 * Will now also undestand timed addresses relative
		 * to the beginning of a track in the form...
		 *
		 *      tr1 m1:s1[.f1] [[tr2] [m2:s2[.f2]]]
d569 31
a599 71
		int tr1, tr2;
		unsigned int m1, m2, s1, s2, f1, f2;
		unsigned char tm, ts, tf;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (8 == sscanf(arg, "%d %u:%u.%u %d %u:%u.%u",
		    &tr1, &m1, &s1, &f1, &tr2, &m2, &s2, &f2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (7 == sscanf(arg, "%d %u:%u %d %u:%u.%u",
		    &tr1, &m1, &s1, &tr2, &m2, &s2, &f2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (7 == sscanf(arg, "%d %u:%u.%u %d %u:%u",
		    &tr1, &m1, &s1, &f1, &tr2, &m2, &s2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (7 == sscanf(arg, "%d %u:%u.%u %u:%u.%u",
		    &tr1, &m1, &s1, &f1, &m2, &s2, &f2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (6 == sscanf(arg, "%d %u:%u.%u %u:%u",
		    &tr1, &m1, &s1, &f1, &m2, &s2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (6 == sscanf(arg, "%d %u:%u %u:%u.%u",
		    &tr1, &m1, &s1, &m2, &s2, &f2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (6 == sscanf(arg, "%d %u:%u.%u %d %u",
		    &tr1, &m1, &s1, &f1, &tr2, &m2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (5 == sscanf(arg, "%d %u:%u %u:%u", &tr1, &m1, &s1, &m2, &s2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (5 == sscanf(arg, "%d %u:%u %d %u",
		    &tr1, &m1, &s1, &tr2, &m2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (5 == sscanf(arg, "%d %u:%u.%u %d",
		    &tr1, &m1, &s1, &f1, &tr2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (4 == sscanf(arg, "%d %u:%u %u", &tr1, &m1, &s1, &tr2))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (4 == sscanf(arg, "%d %u:%u.%u", &tr1, &m1, &s1, &f1))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		if (3 == sscanf(arg, "%d %u:%u", &tr1, &m1, &s1))
			goto Play_Relative_Addresses;

		tr2 = m2 = s2 = f2 = f1 = 0;
		goto Try_Absolute_Timed_Addresses;

Play_Relative_Addresses:
		if (tr1 < 1 || tr1 > n) {
			printf("Track %d not found\n", tr1);
d601 5
a605 2
		} else if (tr2 < 0 || tr2 > n) {
			printf("Track %d not found\n", tr2);
d609 187
a795 1
		/* Change (m1,s1,f1) from tr1 to disc relative. */
d802 1
a802 1
			printf("Track %d is not that long.\n", tr1);
d805 7
d813 13
a825 50
		if (!(tr2 || m2 || s2 || f2)) {
			/* No end time specified. Play to end of disc. */
			toc2msf(n+1, &tm, &ts, &tf);
			m2 = tm;
			s2 = ts;
			f2 = tf;
		} else if (tr2 != 0) {
			/*
			 * End time specified relative to tr2. Change
			 * (m2,s2,f2) from tr2 to disc relative.
			 */
			toc2msf(tr2, &tm, &ts, &tf);
			addmsf(&m2, &s2, &f2, tm, ts, tf);
			/* Compare (m2,s2,f2) to start time of next track. */
			toc2msf(tr2+1, &tm, &ts, &tf);
			if (cmpmsf(m2, s2, f2, tm, ts, tf) == 1) {
				printf("Track %d is not that long.\n", tr2);
				return (0);
			}
		} else {
			/*
			 * Duration rather than end time specified. Change
			 * (m2,s2,f2) from (m1,s1,f1) to disc relative.
			 */
			addmsf(&m2, &s2, &f2, m1, s1, f1);
			/* Compare (m2,s2,f2) to end of disc. */
			toc2msf(tr2+1, &tm, &ts, &tf);
			if (cmpmsf(m2, s2, f2, tm, ts, tf) == 1) {
				printf("Disc is not that long.\n");
				return (0);
			}
		}

		return (play_msf(m1, s1, f1, m2, s2, f2));

Try_Absolute_Timed_Addresses:
		if (6 != sscanf(arg, "%u:%u.%u%u:%u.%u",
		    &m1, &s1, &f1, &m2, &s2, &f2) &&
		    5 != sscanf(arg, "%u:%u.%u%u:%u", &m1, &s1, &f1, &m2, &s2) &&
		    5 != sscanf(arg, "%u:%u%u:%u.%u", &m1, &s1, &m2, &s2, &f2) &&
		    3 != sscanf(arg, "%u:%u.%u", &m1, &s1, &f1) &&
		    4 != sscanf(arg, "%u:%u%u:%u", &m1, &s1, &m2, &s2) &&
		    2 != sscanf(arg, "%u:%u", &m1, &s1))
			goto Clean_up;

		if (m2 == 0) {
			toc2msf(n+1, &tm, &ts, &tf);
			m2 = tm;
			s2 = ts;
			f2 = tf;
d827 3
d831 8
a838 1
		return play_msf(m1, s1, f1, m2, s2, f2);
d841 4
a844 14
	/*
	 * Play track trk1 [ .idx1 ] [ trk2 [ .idx2 ] ]
	 */
	if (4 != sscanf(arg, "%d.%d%d.%d", &start, &istart, &end, &iend) &&
	    3 != sscanf(arg, "%d.%d%d", &start, &istart, &end) &&
	    3 != sscanf(arg, "%d%d.%d", &start, &end, &iend) &&
	    2 != sscanf(arg, "%d.%d", &start, &istart) &&
	    2 != sscanf(arg, "%d%d", &start, &end) &&
	    1 != sscanf(arg, "%d", &start))
		goto Clean_up;

	if (end == 0)
		end = h.ending_track;
	return (play_track(start, istart, end, iend));
d846 1
a846 3
Clean_up:
	printf("%s: Invalid command arguments\n", __progname);
	return (0);
@


1.45
log
@Fix issues with relative times, especially track # vs TOC index
confusion, noted by Juha Erkkila in PR #4957. Make code a lot clearer.
Error out on out of range track numbers.

Tested by Juha.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.44 2006/01/09 05:48:35 krw Exp $	*/
d243 1
a243 1
	    	case 'd':
d249 1
a249 1
	
d525 1
a525 2
		
		return (play_track(h.starting_track, 1, 
d1048 1
a1048 1
	    	}
d1226 1
a1226 1
  
d1246 1
a1246 1
  		}
d1255 1
a1255 1
  		}
@


1.44
log
@Add cmpmsf(). Use it to eliminate repeated code. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.43 2006/01/09 04:05:43 krw Exp $	*/
d627 11
a637 4
		if (tr1 <= 0)
			tr1 = 1;
		else if (tr1 > n)
			tr1 = n;
d639 1
a640 1

d646 18
a663 14
		tr1--;

		addmsf(&m1, &s1, &f1, tm, ts, tf);

		if (tr2 <= 0) {
			if (m2 || s2 || f2) {
				tr2 = tr1;
				addmsf(&m2, &s2, &f2, m1, s1, f1);
			} else {
				tr2 = n;
				toc2msf(tr2+1, &tm, &ts, &tf);
				m2 = tm;
				s2 = ts;
				f2 = tf;
a664 3
		} else if (tr2 > n) {
			tr2 = n;
			m2 = s2 = f2 = 0;
d666 6
a671 2
			if (m2 || s2 || f2)
				tr2--;
d673 4
a676 1
			addmsf(&m2, &s2, &f2, tm, ts, tf);
a678 6
		toc2msf(n+1, &tm, &ts, &tf);

		if (tr2 < n && cmpmsf(m2, s2, f2, tm, ts, tf) == 1) {
			printf("The playing time of the disc is not that long.\n");
			return (0);
		}
@


1.43
log
@Bring in toc2msf() from NetBSD's cdplay. Use it to eliminate repeated
code. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.42 2006/01/09 00:20:31 krw Exp $	*/
d181 1
d634 1
a634 5
		if ((m1 > tm)
		    || ((m1 == tm)
		    && ((s1 > ts)
		    || ((s1 == ts)
		    && (f1 > tf))))) {
d666 1
a666 6
		if ((tr2 < n)
		    && ((m2 > tm)
		    || ((m2 == tm)
		    && ((s2 > ts)
		    || ((s2 == ts)
		    && (f2 > tf)))))) {
d1344 21
@


1.42
log
@Bring in addmsf() from NetBSD's cdplay. Use it to eliminate repeated
manual calculation. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.41 2005/12/31 19:51:15 krw Exp $	*/
d181 1
d631 2
a632 6
		if (msf) {
			tm = toc_buffer[tr1].addr.msf.minute;
			ts = toc_buffer[tr1].addr.msf.second;
			tf = toc_buffer[tr1].addr.msf.frame;
		} else
			lba2msf(toc_buffer[tr1].addr.lba, &tm, &ts, &tf);
d652 4
a655 11
				if (msf) {
					m2 = toc_buffer[n].addr.msf.minute;
					s2 = toc_buffer[n].addr.msf.second;
					f2 = toc_buffer[n].addr.msf.frame;
				} else {
					lba2msf(toc_buffer[n].addr.lba, &tm,
					    &ts, &tf);
					m2 = tm;
					s2 = ts;
					f2 = tf;
				}
d663 1
a663 7
			if (msf) {
				tm = toc_buffer[tr2].addr.msf.minute;
				ts = toc_buffer[tr2].addr.msf.second;
				tf = toc_buffer[tr2].addr.msf.frame;
			} else
				lba2msf(toc_buffer[tr2].addr.lba, &tm, &ts,
				    &tf);
d667 2
a668 6
		if (msf) {
			tm = toc_buffer[n].addr.msf.minute;
			ts = toc_buffer[n].addr.msf.second;
			tf = toc_buffer[n].addr.msf.frame;
		} else
			lba2msf(toc_buffer[n].addr.lba, &tm, &ts, &tf);
d691 4
a694 10
			if (msf) {
				m2 = toc_buffer[n].addr.msf.minute;
				s2 = toc_buffer[n].addr.msf.second;
				f2 = toc_buffer[n].addr.msf.frame;
			} else {
				lba2msf(toc_buffer[n].addr.lba, &tm, &ts, &tf);
				m2 = tm;
				s2 = ts;
				f2 = tf;
			}
d696 1
d1352 15
@


1.41
log
@CDIOCREADTOCENTRYS adjusts lba information into host order, so there
is no need to to ntohl() on it again. CDIOCREADSUBCHANNEL does not
put lba info into host order so just change that to a betoh32().

Noted by Juha Erkkila in PR #4957.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.40 2005/12/21 15:50:38 millert Exp $	*/
d180 1
d647 1
a647 13
		f1 += tf;
		if (f1 >= 75) {
			s1 += f1 / 75;
			f1 %= 75;
		}

		s1 += ts;
		if (s1 >= 60) {
			m1 += s1 / 60;
			s1 %= 60;
		}

		m1 += tm;
d652 1
a652 13
				f2 += f1;
				if (f2 >= 75) {
					s2 += f2 / 75;
					f2 %= 75;
				}

				s2 += s1;
				if (s2 > 60) {
					m2 += s2 / 60;
					s2 %= 60;
				}

				m2 += m1;
d680 1
a680 13
			f2 += tf;
			if (f2 >= 75) {
				s2 += f2 / 75;
				f2 %= 75;
			}

			s2 += ts;
			if (s2 > 60) {
				m2 += s2 / 60;
				s2 %= 60;
			}

			m2 += tm;
d1359 18
@


1.40
log
@Remove an ambiguiity and make 'e' short for "eject".  The short form
for "exit" is still "ex".  OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.39 2005/01/22 10:21:26 robert Exp $	*/
d541 1
a541 1
				len = ntohl(toc_buffer[n].addr.lba) - blk;
d634 1
a634 2
			lba2msf(ntohl(toc_buffer[tr1].addr.lba),
				&tm, &ts, &tf);
d683 2
a684 2
					lba2msf(ntohl(toc_buffer[n].addr.lba),
						&tm, &ts, &tf);
d701 2
a702 2
				lba2msf(ntohl(toc_buffer[tr2].addr.lba),
					&tm, &ts, &tf);
d723 1
a723 2
			lba2msf(ntohl(toc_buffer[n].addr.lba),
				&tm, &ts, &tf);
d751 1
a751 2
				lba2msf(ntohl(toc_buffer[n].addr.lba),
					&tm, &ts, &tf);
d1066 1
a1066 1
		block = ntohl(e->addr.lba);
d1082 1
a1082 1
		block = ntohl(e->addr.lba);
d1103 1
a1103 1
		block = ntohl(e->addr.lba);
d1123 1
a1123 1
		next = ntohl(e[1].addr.lba);
d1234 6
a1239 2
		lba2msf(ntohl(s.data->what.position.reladdr.lba),
		    &mm, &ss, &ff);
@


1.39
log
@add an exit command as an alias of quit; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.38 2005/01/09 11:02:32 alek Exp $	*/
d135 1
a135 1
{ CMD_QUIT,	"exit",		1, "" },
@


1.38
log
@Better error message for `device' command without arguments.

help & ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.37 2005/01/08 21:16:02 alek Exp $	*/
d135 1
@


1.37
log
@New shortcuts for commands device (d) and debug (deb)

go ahead espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.36 2005/01/04 18:30:38 moritz Exp $	*/
d385 5
@


1.36
log
@add snprintf sanity check.

ok millert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.35 2004/09/14 22:21:30 deraadt Exp $	*/
d112 1
a112 1
{ CMD_DEBUG,    "debug",        1, "on | off" },
@


1.35
log
@sprinkle some ARGSUSED for table driven functions
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.34 2004/07/30 11:59:03 jmc Exp $	*/
d266 1
a266 1
			if (len >= buf + sizeof buf - p)
@


1.34
log
@- sort options
- missing full stop
- uppercase `id'
- add SEE ALSO; suggested by Alexey E. Suslikov
- add `-d host:port' to usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.33 2004/01/16 12:10:55 espie Exp $	*/
d777 1
d802 1
d822 1
d874 1
d915 1
a915 1
			   ss.data->what.media_catalog.mc_number,
d962 1
@


1.33
log
@fix printf formats, unsigned wants %u
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.32 2004/01/14 07:32:58 miod Exp $	*/
d209 1
a209 1
	fprintf(stderr, "usage: %s [-sv] [-f device] [command args ...]\n",
@


1.32
log
@A more classical and more readable getopt() loop, no functional change.
ok espie@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.31 2003/10/31 08:47:31 otto Exp $	*/
d554 1
a554 1
		if (8 == sscanf(arg, "%d %d:%d.%d %d %d:%d.%d",
d559 1
a559 1
		if (7 == sscanf(arg, "%d %d:%d %d %d:%d.%d",
d564 1
a564 1
		if (7 == sscanf(arg, "%d %d:%d.%d %d %d:%d",
d569 1
a569 1
		if (7 == sscanf(arg, "%d %d:%d.%d %d:%d.%d",
d574 1
a574 1
		if (6 == sscanf(arg, "%d %d:%d.%d %d:%d",
d579 1
a579 1
		if (6 == sscanf(arg, "%d %d:%d %d:%d.%d",
d584 1
a584 1
		if (6 == sscanf(arg, "%d %d:%d.%d %d %d",
d589 1
a589 1
		if (5 == sscanf(arg, "%d %d:%d %d:%d", &tr1, &m1, &s1, &m2, &s2))
d593 1
a593 1
		if (5 == sscanf(arg, "%d %d:%d %d %d",
d598 1
a598 1
		if (5 == sscanf(arg, "%d %d:%d.%d %d",
d603 1
a603 1
		if (4 == sscanf(arg, "%d %d:%d %d", &tr1, &m1, &s1, &tr2))
d607 1
a607 1
		if (4 == sscanf(arg, "%d %d:%d.%d", &tr1, &m1, &s1, &f1))
d611 1
a611 1
		if (3 == sscanf(arg, "%d %d:%d", &tr1, &m1, &s1))
d732 1
a732 1
		if (6 != sscanf(arg, "%d:%d.%d%d:%d.%d",
d734 5
a738 5
		    5 != sscanf(arg, "%d:%d.%d%d:%d", &m1, &s1, &f1, &m2, &s2) &&
		    5 != sscanf(arg, "%d:%d%d:%d.%d", &m1, &s1, &m2, &s2, &f2) &&
		    3 != sscanf(arg, "%d:%d.%d", &m1, &s1, &f1) &&
		    4 != sscanf(arg, "%d:%d%d:%d", &m1, &s1, &m2, &s2) &&
		    2 != sscanf(arg, "%d:%d", &m1, &s1))
@


1.31
log
@New libedit api changes.

Tested by djm@@, mouring@@, jmc@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.30 2003/06/10 22:20:45 deraadt Exp $	*/
d217 1
a217 1
	int cmd;
d228 2
a229 4
	for (;;) {
		switch (getopt(argc, argv, "svd:f:")) {
		case -1:
			break;
d232 1
a232 1
			continue;
d235 1
a235 1
			continue;
d238 1
a238 1
			continue;
d241 1
a241 1
			continue;
d245 1
a245 2
		break;
	}
@


1.30
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.29 2003/04/06 20:50:05 krw Exp $	*/
d1245 1
d1254 1
a1254 1
			history(hist, H_ENTER, buf);
d1363 2
d1366 1
a1366 1
		el = el_init(__progname, stdin, stdout);
d1368 1
a1368 1
		history(hist, H_EVENT, 100);
@


1.29
log
@Replace a strcpy and associated code with a snprintf whose return
value is checked.

Replace an unhelpful usage() with a relevant error message if the
argument buffer overflows.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.28 2003/02/18 09:42:33 jmc Exp $	*/
d181 1
a181 1
help()
d207 1
a207 1
usage()
d935 1
a935 1
cdid()
@


1.28
log
@copyrights added;

Serge V. Vakulenko

thanks espie@@ for help
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.27 2003/02/13 05:48:38 fgsch Exp $	*/
d266 2
a267 1
			len = strlen(*argv);
d269 2
a270 2
			if (p + len >= buf + sizeof (buf) - 1)
				usage();
a271 4
			if (p > buf)
				*p++ = ' ';

			strcpy(p, *argv);	/* ok */
a273 1
		*p = 0;
@


1.27
log
@add libedit support.
from Pedro Bastos <pbastos at grad dot inf dot puc-rio dot br>, minus
SMALL support. minor change by me.
millert@@ ok.
@
text
@d1 32
a32 1
/*	$OpenBSD: cdio.c,v 1.24 2002/04/18 20:18:31 espie Exp $	*/
@


1.26
log
@- Add missing cdid command to cdio.1.
- Remove ambiguity between cddbinfo and cdid commands, so CD matches
  cddbinfo and CDI cdid.
millert@@ ok.
@
text
@d24 5
d36 1
d39 1
a39 4
#include <sys/param.h>
#include <sys/file.h>
#include <sys/cdio.h>
#include <sys/ioctl.h>
a41 1

d116 4
d137 1
d259 2
d282 1
d1215 2
a1216 1
	static char buf[80];
d1220 1
a1220 3
		if (verbose)
			fprintf(stderr, "%s> ", __progname);
		if (!fgets(buf, sizeof (buf), stdin)) {
d1225 2
d1324 31
@


1.25
log
@Reuse cddb code to support FreeBSD new cdid command.
(who knows ? scripts might use it).
ok fgs@@, pval@@
@
text
@d101 1
a101 1
{ CMD_CDID,	"cdid",		2, "" },
@


1.24
log
@Add cddb support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.23 2002/03/22 03:43:37 espie Exp $	*/
d70 1
d100 2
a101 1
{ CMD_CDDB,   	"cddbinfo",       2, "[n]" },
d140 1
d287 5
d895 27
@


1.23
log
@Add missing prototypes.
Convert lba2msf definition to ANSI-style, so that it matches the prototype

Old-style function declarations undergo argument promotion, and thus:

void
f(a)
	char a;
{}

actually matches
void f(int a);
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.22 2002/03/21 17:43:48 espie Exp $	*/
d37 1
a38 1
#define VERSION "2.0"
d69 1
d74 1
a74 1
	unsigned  min;
d99 2
a100 1
{ 0, }
d109 2
d123 1
d129 1
a129 1
void            prtrack(struct cd_toc_entry *e, int lastflag);
d174 1
a174 3
main(argc, argv)
	int argc;
	char **argv;
d183 4
d188 1
a188 1
		switch (getopt(argc, argv, "svf:")) {
d200 3
d262 1
a262 3
run(cmd, arg)
	int cmd;
	char *arg;
d278 6
d364 3
d456 1
a456 2
play(arg)
	char *arg;
d507 2
a508 2
		unsigned tr1, tr2;
		unsigned m1, m2, s1, s2, f1, f2;
d576 1
a576 1
		if (! tr1)
d613 1
a613 1
		if (! tr2) {
d736 1
a736 2
play_prev(arg)
	char *arg;
d760 1
a760 2
play_same(arg)
	char *arg;
d779 1
a779 2
play_next(arg)
	char *arg;
d809 1
a809 2
strstatus(sts)
	int sts;
d830 1
a830 2
pstatus(arg)
	char *arg;
d840 13
a852 4
		if (verbose)
			printf("Audio status = %d<%s>, current track = %d, current position = %d:%02d.%02d\n",
			    rc, strstatus(rc), trk, m, s, f);
		else
d890 1
a890 2
info(arg)
	char *arg;
d920 37
a956 1
		prtrack(toc_buffer + i, 0);
d959 1
a959 1
	prtrack(toc_buffer + n, 1);
d964 1
a964 5
lba2msf(lba, m, s, f)
	unsigned long lba;
	u_char *m;
	u_char *s;
	u_char *f;
d980 31
d1012 1
a1012 3
prtrack(e, lastflag)
	struct cd_toc_entry *e;
	int lastflag;
d1018 4
a1021 3
		/* Print track start */
		printf("%2d:%02d.%02d  ", e->addr.msf.minute,
			e->addr.msf.second, e->addr.msf.frame);
d1027 5
a1031 3
		lba2msf(block, &m, &s, &f);
		/* Print track start */
		printf("%2d:%02d.%02d  ", m, s, f);
d1034 5
a1038 2
		/* Last track -- print block */
		printf("       -  %6d       -      -\n", block);
d1050 2
d1053 3
a1055 2
	printf("%2d:%02d.%02d  %6d  %6d  %5s\n", m, s, f, block, len,
	    (e->control & 4) ? "data" : "audio");
d1059 1
a1059 5
play_track(tstart, istart, tend, iend)
	int tstart;
	int istart;
	int tend;
	int iend;
d1072 1
a1072 3
play_blocks(blk, len)
	int blk;
	int len;
d1083 1
a1083 3
setvol(left, right)
	int left;
	int right;
d1096 1
a1096 2
read_toc_entrys(len)
	int len;
d1121 1
a1121 7
play_msf(start_m, start_s, start_f, end_m, end_s, end_f)
	int start_m;
	int start_s;
	int start_f;
	int end_m;
	int end_s;
	int end_f;
d1136 1
a1136 5
status(trk, min, sec, frame)
	int *trk;
	int *min;
	int *sec;
	int *frame;
d1168 1
a1168 2
input(cmd)
	int *cmd;
d1187 1
a1187 3
parse(buf, cmd)
	char *buf;
	int *cmd;
d1247 1
a1247 2
open_cd(dev)
	char *dev;
@


1.22
log
@getopt returns -1, not EOF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.21 2002/03/20 13:40:57 espie Exp $	*/
d130 3
d924 1
a924 4
msf2lba(m, s, f)
	u_char m;
	u_char s;
	u_char f;
@


1.21
log
@style(9)
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.20 2002/02/17 19:42:30 millert Exp $	*/
d179 1
a179 1
		case EOF:
@


1.20
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.19 2002/02/16 21:27:44 millert Exp $	*/
d1061 2
a1062 1
int status(trk, min, sec, frame)
@


1.19
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.18 2001/10/28 03:57:59 deraadt Exp $	*/
d125 1
a125 2
void            lba2msf __P((unsigned long lba,
                            u_char *m, u_char *s, u_char *f));
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.17 2001/08/14 00:01:56 espie Exp $	*/
d110 15
a124 15
int             setvol __P((int, int));
int             read_toc_entrys __P((int));
int             play_msf __P((int, int, int, int, int, int));
int             play_track __P((int, int, int, int));
int             get_vol __P((int *, int *));
int             status __P((int *, int *, int *, int *));
int             open_cd __P((char *));
int             play __P((char *arg));
int             info __P((char *arg));
int             pstatus __P((char *arg));
int		play_next __P((char *arg));
int		play_prev __P((char *arg));
int		play_same __P((char *arg));
char            *input __P((int *));
void            prtrack __P((struct cd_toc_entry *e, int lastflag));
d127 4
a130 4
unsigned int    msf2lba __P((u_char m, u_char s, u_char f));
int             play_blocks __P((int blk, int len));
int             run __P((int cmd, char *arg));
char            *parse __P((char *buf, int *cmd));
@


1.17
log
@Stop fucking up display on Depeche Mode.
Ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.16 2001/06/22 14:26:36 lebel Exp $	*/
d132 2
a133 1
void help ()
d151 2
a152 2
			printf (" %s", c->args);
		printf ("\n");
d154 2
a155 2
	printf ("\n\tThe word \"play\" is not required for the play commands.\n");
	printf ("\tThe plain target address is taken as a synonym for play.\n");
d158 2
a159 1
void usage ()
d161 3
a163 3
	(void)fprintf(stderr,
	    "usage: %s [-sv] [-f device] [command args ...]\n", __progname);
	exit (1);
d166 2
a167 1
int main (argc, argv)
d174 1
a174 1
	cdname = getenv ("DISC");
d176 1
a176 1
		cdname = getenv ("CDROM");
d179 1
a179 1
		switch (getopt (argc, argv, "svf:")) {
d192 1
a192 1
			usage ();
d199 2
a200 2
	if (argc > 0 && ! strcasecmp (*argv, "help"))
		usage ();
d204 2
a205 2
		fprintf (stderr,
			 "No CD device name specified. Defaulting to %s.\n", cdname);
d213 1
a213 1
			len = strlen (*argv);
d216 1
a216 1
				usage ();
d221 1
a221 1
			strcpy (p, *argv);	/* ok */
d225 2
a226 2
		arg = parse (buf, &cmd);
		return (run (cmd, arg));
d230 1
a230 1
		verbose = isatty (0);
d233 2
a234 2
		printf ("Compact Disc Control utility, version %s\n", VERSION);
		printf ("Type `?' for command list\n\n");
d238 2
a239 2
		arg = input (&cmd);
		if (run (cmd, arg) < 0) {
d241 2
a242 2
				warn (NULL);
			close (fd);
d245 1
a245 1
		fflush (stdout);
d249 2
a250 1
int run (cmd, arg)
d260 1
a260 1
		exit (0);
d263 1
a263 1
		if (fd < 0 && ! open_cd (cdname))
d266 1
a266 1
		return info (arg);
d269 1
a269 1
		if (fd < 0 && ! open_cd (cdname))
d272 1
a272 1
		return pstatus (arg);
d275 1
a275 1
		if (fd < 0 && ! open_cd (cdname))
d278 1
a278 1
		return ioctl (fd, CDIOCPAUSE);
d281 1
a281 1
		if (fd < 0 && ! open_cd (cdname))
d284 1
a284 1
		return ioctl (fd, CDIOCRESUME);
d287 1
a287 1
		if (fd < 0 && ! open_cd (cdname))
d290 1
a290 1
		rc = ioctl (fd, CDIOCSTOP);
d292 1
a292 1
		(void) ioctl (fd, CDIOCALLOW);
d297 1
a297 1
		if (fd < 0 && ! open_cd (cdname))
d300 1
a300 1
		rc = ioctl (fd, CDIOCRESET);
d308 1
a308 1
		if (fd < 0 && ! open_cd (cdname))
d311 2
a312 2
		if (! strcasecmp (arg, "on"))
			return ioctl (fd, CDIOCSETDEBUG);
d314 2
a315 2
		if (! strcasecmp (arg, "off"))
			return ioctl (fd, CDIOCCLRDEBUG);
d317 1
a317 1
		printf ("%s: Invalid command arguments\n", __progname);
d324 1
a324 1
			(void) ioctl (fd, CDIOCALLOW);
d330 1
a330 1
		if (!open_cd (arg))
d337 1
a337 1
		if (fd < 0 && ! open_cd (cdname))
d340 2
a341 2
		(void) ioctl (fd, CDIOCALLOW);
		rc = ioctl (fd, CDIOCEJECT);
d352 1
a352 1
		if (fd < 0 && ! open_cd (cdname))
d355 2
a356 2
		(void) ioctl (fd, CDIOCALLOW);
		rc = ioctl (fd, CDIOCCLOSE);
d363 1
a363 1
		printf ("%s: Command not yet supported\n", __progname);
d368 1
a368 1
		if (fd < 0 && ! open_cd (cdname))
d371 1
a371 1
		while (isspace (*arg))
d374 1
a374 1
		return play (arg);
d377 1
a377 1
		if (! strcasecmp (arg, "msf"))
d379 1
a379 1
		else if (! strcasecmp (arg, "lba"))
d382 1
a382 1
			printf ("%s: Invalid command arguments\n", __progname);
d386 1
a386 1
		if (fd < 0 && !open_cd (cdname))
d389 2
a390 2
		if (! strncasecmp (arg, "left", strlen(arg)))
			return ioctl (fd, CDIOCSETLEFT);
d392 2
a393 2
		if (! strncasecmp (arg, "right", strlen(arg)))
			return ioctl (fd, CDIOCSETRIGHT);
d395 2
a396 2
		if (! strncasecmp (arg, "mono", strlen(arg)))
			return ioctl (fd, CDIOCSETMONO);
d398 2
a399 2
		if (! strncasecmp (arg, "stereo", strlen(arg)))
			return ioctl (fd, CDIOCSETSTEREO);
d401 2
a402 2
		if (! strncasecmp (arg, "mute", strlen(arg)))
			return ioctl (fd, CDIOCSETMUTE);
d404 2
a405 2
		if (2 != sscanf (arg, "%d %d", &l, &r)) {
			printf ("%s: Invalid command arguments\n", __progname);
d409 1
a409 1
		return setvol (l, r);
d411 3
a413 3
        case CMD_NEXT:
                if (fd < 0 && ! open_cd (cdname))
                        return (0);
d415 1
a415 1
                return play_next (arg);
d417 3
a419 3
        case CMD_PREV:
                if (fd < 0 && ! open_cd (cdname))
                        return (0);
d421 1
a421 1
                return play_prev (arg);
d424 1
a424 1
		if (fd < 0 && ! open_cd (cdname))
d427 1
a427 1
		return play_same (arg);
d430 1
a430 1
		help ();
d436 2
a437 1
int play (arg)
d443 1
a443 1
	rc = ioctl (fd, CDIOREADTOCHEADER, &h);
d449 1
a449 1
	rc = read_toc_entrys ((n + 1) * sizeof (struct cd_toc_entry));
d456 1
a456 1
	        
d458 1
a458 1
				   h.ending_track, 1));
d461 1
a461 1
	if (strchr (arg, '#')) {
d465 2
a466 2
		if (2 != sscanf (arg, "#%d%d", &blk, &len) &&
		    1 != sscanf (arg, "#%d", &blk))
d471 3
a473 3
				len = msf2lba (toc_buffer[n].addr.msf.minute,
					       toc_buffer[n].addr.msf.second,
					       toc_buffer[n].addr.msf.frame) - blk;
d477 1
a477 1
		return play_blocks (blk, len);
d480 1
a480 1
	if (strchr (arg, ':')) {
d494 1
a494 1
		if (8 == sscanf (arg, "%d %d:%d.%d %d %d:%d.%d",
d499 1
a499 1
		if (7 == sscanf (arg, "%d %d:%d %d %d:%d.%d",
d504 1
a504 1
		if (7 == sscanf (arg, "%d %d:%d.%d %d %d:%d",
d509 1
a509 1
		if (7 == sscanf (arg, "%d %d:%d.%d %d:%d.%d",
d514 1
a514 1
		if (6 == sscanf (arg, "%d %d:%d.%d %d:%d",
d519 1
a519 1
		if (6 == sscanf (arg, "%d %d:%d %d:%d.%d",
d524 1
a524 1
		if (6 == sscanf (arg, "%d %d:%d.%d %d %d",
d529 1
a529 1
		if (5 == sscanf (arg, "%d %d:%d %d:%d", &tr1, &m1, &s1, &m2, &s2))
d533 1
a533 1
		if (5 == sscanf (arg, "%d %d:%d %d %d",
d538 1
a538 1
		if (5 == sscanf (arg, "%d %d:%d.%d %d",
d543 1
a543 1
		if (4 == sscanf (arg, "%d %d:%d %d", &tr1, &m1, &s1, &tr2))
d547 1
a547 1
		if (4 == sscanf (arg, "%d %d:%d.%d", &tr1, &m1, &s1, &f1))
d551 1
a551 1
		if (3 == sscanf (arg, "%d %d:%d", &tr1, &m1, &s1))
d575 1
a575 1
			printf ("Track %d is not that long.\n", tr1);
d666 1
a666 1
			printf ("The playing time of the disc is not that long.\n");
d669 1
a669 1
		return (play_msf (m1, s1, f1, m2, s2, f2));
d672 7
a678 7
		if (6 != sscanf (arg, "%d:%d.%d%d:%d.%d",
			&m1, &s1, &f1, &m2, &s2, &f2) &&
		    5 != sscanf (arg, "%d:%d.%d%d:%d", &m1, &s1, &f1, &m2, &s2) &&
		    5 != sscanf (arg, "%d:%d%d:%d.%d", &m1, &s1, &m2, &s2, &f2) &&
		    3 != sscanf (arg, "%d:%d.%d", &m1, &s1, &f1) &&
		    4 != sscanf (arg, "%d:%d%d:%d", &m1, &s1, &m2, &s2) &&
		    2 != sscanf (arg, "%d:%d", &m1, &s1))
d694 1
a694 1
		return play_msf (m1, s1, f1, m2, s2, f2);
d700 6
a705 6
	if (4 != sscanf (arg, "%d.%d%d.%d", &start, &istart, &end, &iend) &&
	    3 != sscanf (arg, "%d.%d%d", &start, &istart, &end) &&
	    3 != sscanf (arg, "%d%d.%d", &start, &end, &iend) &&
	    2 != sscanf (arg, "%d.%d", &start, &istart) &&
	    2 != sscanf (arg, "%d%d", &start, &end) &&
	    1 != sscanf (arg, "%d", &start))
d710 1
a710 1
	return (play_track (start, istart, end, iend));
d713 1
a713 1
	printf ("%s: Invalid command arguments\n", __progname);
d717 3
a719 2
int play_prev (arg)
        char *arg;
d721 2
a722 2
        int trk, min, sec, frm, rc;
        struct ioc_toc_header h;
d724 2
a725 3
        if (status (&trk, &min, &sec, &frm) >= 0)
        {
                trk--;
d727 5
a731 6
                rc = ioctl (fd, CDIOREADTOCHEADER, &h);
                if (rc < 0)
                {
                        warn ("getting toc header");
                        return (rc);
                }
d733 5
a737 3
                if (trk < h.starting_track)
                  return play_track (h.starting_track, 1, 
				     h.ending_track + 1, 1);
d739 1
a739 4
                return play_track (trk, 1, h.ending_track, 1);
        }

        return (0);
d742 2
a743 1
int play_same (arg)
d746 2
a747 2
        int trk, min, sec, frm, rc;
        struct ioc_toc_header h;
d749 6
a754 8
        if (status (&trk, &min, &sec, &frm) >= 0)
        {
                rc = ioctl (fd, CDIOREADTOCHEADER, &h);
                if (rc < 0)
                {
                        warn ("getting toc header");
                        return (rc);
                }
d756 2
a757 2
                return play_track (trk, 1, h.ending_track, 1);
        }
d759 1
a759 1
        return (0);
d762 2
a763 1
int play_next (arg)
d769 1
a769 2
	if (status (&trk, &min, &sec, &frm) >= 0)
	{
d771 3
a773 4
		rc = ioctl (fd, CDIOREADTOCHEADER, &h);
		if (rc < 0)
		{
			warn ("getting toc header");
d777 1
a777 2
		if (trk > h.ending_track)
		{
d780 1
a780 1
			rc = ioctl (fd, CDIOCSTOP);
d782 1
a782 1
			(void) ioctl (fd, CDIOCALLOW);
d787 1
a787 1
		return play_track (trk, 1, h.ending_track, 1);
d793 2
a794 1
char *strstatus (sts)
d798 14
a811 7
	case ASTS_INVALID:   return ("invalid");
	case ASTS_PLAYING:   return ("playing");
	case ASTS_PAUSED:    return ("paused");
	case ASTS_COMPLETED: return ("completed");
	case ASTS_ERROR:     return ("error");
	case ASTS_VOID:      return ("void");
	default:             return ("??");
d815 2
a816 1
int pstatus (arg)
d825 1
a825 1
	rc = status (&trk, &m, &s, &f);
d828 2
a829 2
			printf ("Audio status = %d<%s>, current track = %d, current position = %d:%02d.%02d\n",
				rc, strstatus (rc), trk, m, s, f);
d831 1
a831 1
			printf ("%d %d %d:%02d.%02d\n", rc, trk, m, s, f);
d833 1
a833 1
		printf ("No current status info available\n");
d835 1
a835 1
	bzero (&ss, sizeof (ss));
d840 1
a840 1
	rc = ioctl (fd, CDIOCREADSUBCHANNEL, (char *) &ss);
d855 1
a855 1
	rc = ioctl (fd, CDIOCGETVOL, &v);
d858 1
a858 1
			printf ("Left volume = %d, right volume = %d\n",
d861 1
a861 1
			printf ("%d %d\n", v.vol[0], v.vol[1]);
d863 1
a863 1
		printf ("No volume level info available\n");
d867 2
a868 1
int info (arg)
d874 1
a874 1
	rc = ioctl (fd, CDIOREADTOCHEADER, &h);
d877 2
a878 2
			printf ("Starting track = %d, ending track = %d, TOC size = %d bytes\n",
				h.starting_track, h.ending_track, h.len);
d880 2
a881 2
			printf ("%d %d %d\n", h.starting_track,
				h.ending_track, h.len);
d883 1
a883 1
		warn ("getting toc header");
d888 1
a888 1
	rc = read_toc_entrys ((n + 1) * sizeof (struct cd_toc_entry));
d893 2
a894 2
		printf ("track     start  duration   block  length   type\n");
		printf ("-------------------------------------------------\n");
d898 2
a899 2
		printf ("%5d  ", toc_buffer[i].track);
		prtrack (toc_buffer + i, 0);
d901 2
a902 2
	printf ("%5d  ", toc_buffer[n].track);
	prtrack (toc_buffer + n, 1);
d906 2
a907 1
void lba2msf (lba, m, s, f)
d913 2
a914 2
	lba += 150;                     /* block start offset */
	lba &= 0xffffff;                /* negative lbas use only 24 bits */
d921 2
a922 1
unsigned int msf2lba (m, s, f)
d930 2
a931 1
void prtrack (e, lastflag)
d940 1
a940 1
		printf ("%2d:%02d.%02d  ", e->addr.msf.minute,
d943 1
a943 1
		block = msf2lba (e->addr.msf.minute, e->addr.msf.second,
d949 1
a949 1
		printf ("%2d:%02d.%02d  ", m, s, f);
d953 1
a953 1
		printf ("       -  %6d       -      -\n", block);
d958 1
a958 1
		next = msf2lba (e[1].addr.msf.minute, e[1].addr.msf.second,
d963 1
a963 1
	lba2msf (len, &m, &s, &f);
d966 2
a967 2
	printf ("%2d:%02d.%02d  %6d  %6d  %5s\n", m, s, f, block, len,
		(e->control & 4) ? "data" : "audio");
d970 2
a971 1
int play_track (tstart, istart, tend, iend)
d984 1
a984 1
	return ioctl (fd, CDIOCPLAYTRACKS, &t);
d987 2
a988 1
int play_blocks (blk, len)
d997 1
a997 1
	return ioctl (fd, CDIOCPLAYBLOCKS, &t);
d1000 2
a1001 1
int setvol (left, right)
d1012 1
a1012 1
	return ioctl (fd, CDIOCSETVOL, &v);
d1015 2
a1016 1
int read_toc_entrys (len)
d1022 2
a1023 2
	  free(toc_buffer);
	  toc_buffer = 0;
d1026 1
a1026 1
	toc_buffer = malloc (len);
d1029 2
a1030 2
	  errno = ENOMEM;
	  return (-1);
d1038 1
a1038 1
	return (ioctl (fd, CDIOREADTOCENTRYS, (char *) &t));
d1041 2
a1042 1
int play_msf (start_m, start_s, start_f, end_m, end_s, end_f)
d1050 1
a1050 1
	struct ioc_play_msf     a;
d1059 1
a1059 1
	return ioctl (fd, CDIOCPLAYMSF, (char *) &a);
d1062 1
a1062 1
int status (trk, min, sec, frame)
d1072 1
a1072 1
	bzero (&s, sizeof (s));
d1078 1
a1078 1
	if (ioctl (fd, CDIOCREADSUBCHANNEL, (char *) &s) < 0)
d1088 1
a1088 1
			&mm, &ss, &ff);
d1097 2
a1098 1
char *input (cmd)
d1106 2
a1107 2
			fprintf (stderr, "%s> ", __progname);
		if (! fgets (buf, sizeof (buf), stdin)) {
d1109 1
a1109 1
			fprintf (stderr, "\r\n");
d1112 2
a1113 2
		p = parse (buf, cmd);
	} while (! p);
d1117 2
a1118 1
char *parse (buf, cmd)
d1126 1
a1126 1
	for (p=buf; isspace (*p); p++)
d1129 1
a1129 1
	if (isdigit (*p) || (p[0] == '#' && isdigit (p[1]))) {
d1134 1
a1134 1
	for (buf = p; *p && ! isspace (*p); p++)
d1141 1
a1141 1
	if (*p) {                       /* It must be a spacing character! */
d1153 1
a1153 1
		if (! strcasecmp (buf, c->name)) {
d1159 1
a1159 1
		if (len >= c->min && ! strncasecmp (buf, c->name, len)) {
d1161 1
a1161 1
				fprintf (stderr, "Ambiguous command\n");
d1169 2
a1170 2
		fprintf (stderr, "%s: Invalid command, enter ``help'' for commands.\n",
			__progname);
d1174 1
a1174 1
	while (isspace (*p))
d1179 2
a1180 1
int open_cd (dev)
d1196 1
a1196 1
				warnx ("No disc in drive %s.", realdev);
d1201 1
a1201 1
				warn ("Can't open %s", realdev);
d1205 1
a1205 1
		sleep (1);
d1208 1
a1208 1
		warn ("Can't open %s", realdev);
@


1.16
log
@use strlcpy vs strncpy+a[len-1]='\0'
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.15 2000/12/24 11:35:42 aaron Exp $	*/
d25 2
d32 1
a32 2
#include <err.h>
#include <errno.h>
d814 1
d836 6
a841 3
		    ss.data->what.media_catalog.mc_number[0])
			printf(", number \"%.15s\"",
			       ss.data->what.media_catalog.mc_number);
@


1.15
log
@Get rid of undocumented -h option.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.14 2000/12/24 11:34:10 aaron Exp $	*/
d327 1
a327 2
		(void) strncpy(newcdname, arg, sizeof(newcdname) - 1);
		newcdname[sizeof(newcdname) - 1] = '\0';
@


1.14
log
@Get rid of ugly usage() output. People can read the man page to get a command
list. Sync the usage() with the man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.13 1999/12/15 05:33:56 deraadt Exp $	*/
d175 1
a175 1
		switch (getopt (argc, argv, "svhf:")) {
a186 1
		case 'h':
@


1.13
log
@overflow safe
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.12 1998/12/20 23:53:35 millert Exp $	*/
d158 2
a159 9
	printf ("Usage:\n\t%s [ -vs ] [ -f disc ] [ command args... ]\n", __progname);
	printf ("Options:\n");
	printf ("\t-v       - verbose mode\n");
	printf ("\t-s       - silent mode\n");
	printf ("\t-f disc  - a block device name such as /dev/cd0c\n");
	printf ("\tDISC - shell variable with device name\n");
	printf ("\tCDROM - shell variable checked if DISC isn't sent\n");
	printf ("Commands:\n");
	help ();
@


1.12
log
@If open of device fails, try up to 10 times.  Useful for CD changers that take a while to switch between logical units
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.11 1998/07/09 20:10:26 csapuntz Exp $	*/
d225 1
a225 1
			strcpy (p, *argv);
@


1.11
log
@

Play CDs with more than 100 tracks
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.10 1998/07/09 19:09:59 csapuntz Exp $	*/
d1167 1
d1172 18
a1189 1
	fd = opendev(dev, O_RDONLY, OPENDEV_PART, &realdev);
a1190 7
		if ((errno == ENXIO) || (errno == EIO)) {
			/*  ENXIO has an overloaded meaning here.
			 *  The original "Device not configured" should
			 *  be interpreted as "No disc in drive %s". */
			warnx ("No disc in drive %s.", realdev);
			return (0);
		}
@


1.10
log
@

Fix for "play" command on CDs whose last table of contents entry is
clipped (for whatever reason). Couple minor bug fixes.

Noticed by John Jannotti
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.9 1998/04/25 04:41:29 millert Exp $	*/
d100 1
a100 1
struct cd_toc_entry     toc_buffer[100];
d1007 12
@


1.9
log
@Add "dev" command to switch to a new device.  Handy for cd changers
that show up as multiple luns.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.8 1997/05/01 12:40:28 downsj Exp $	*/
d163 2
a164 1
	printf ("\tMUSIC_CD - shell variable with device name\n");
d459 3
a461 11
		if (msf)
			return
			  play_blocks (msf2lba (toc_buffer[0].addr.msf.minute,
						toc_buffer[0].addr.msf.second,
						toc_buffer[0].addr.msf.frame),
				       msf2lba (toc_buffer[n].addr.msf.minute,
						toc_buffer[n].addr.msf.second,
						toc_buffer[n].addr.msf.frame));
		else
			return play_blocks (ntohl (toc_buffer[0].addr.lba),
					    ntohl (toc_buffer[n].addr.lba));
d712 1
a712 1
		end = n;
@


1.8
log
@CDIOCSETSTEREO -> CDIOCSETSTERIO, go@@cclub.tutcc.tut.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.7 1997/03/19 03:21:49 angelos Exp $	*/
d30 1
d32 1
d51 17
a67 16
#define CMD_EJECT       2
#define CMD_HELP        3
#define CMD_INFO        4
#define CMD_PAUSE       5
#define CMD_PLAY        6
#define CMD_QUIT        7
#define CMD_RESUME      8
#define CMD_STOP        9
#define CMD_VOLUME      10
#define CMD_CLOSE       11
#define CMD_RESET       12
#define CMD_SET         13
#define CMD_STATUS      14
#define CMD_NEXT	15
#define CMD_PREV	16
#define CMD_REPLAY	17
d77 1
d115 1
a115 1
int             open_cd __P((void));
d244 1
a244 1
				perror (__progname);
d257 1
d265 1
a265 1
		if (fd < 0 && ! open_cd ())
d271 1
a271 1
		if (fd < 0 && ! open_cd ())
d277 1
a277 1
		if (fd < 0 && ! open_cd ())
d283 1
a283 1
		if (fd < 0 && ! open_cd ())
d289 1
a289 1
		if (fd < 0 && ! open_cd ())
d299 1
a299 1
		if (fd < 0 && ! open_cd ())
d310 1
a310 1
		if (fd < 0 && ! open_cd ())
d323 16
d340 1
a340 1
		if (fd < 0 && ! open_cd ())
d355 1
a355 1
		if (fd < 0 && ! open_cd ())
d371 1
a371 1
		if (fd < 0 && ! open_cd ())
d389 1
a389 1
		if (fd < 0 && !open_cd ())
d415 1
a415 1
                if (fd < 0 && ! open_cd ())
d421 1
a421 1
                if (fd < 0 && ! open_cd ())
d427 1
a427 1
		if (fd < 0 && ! open_cd ())
d740 1
a740 1
                        perror ("getting toc header");
d765 1
a765 1
                        perror ("getting toc header");
d787 1
a787 1
			perror ("getting toc header");
d831 1
a831 1
	if (rc >= 0)
d837 1
a837 1
	else
d858 1
a858 1
	if (rc >= 0)
d864 1
a864 1
	else
d884 1
a884 1
		perror ("getting toc header");
d1158 2
a1159 1
int open_cd ()
d1161 1
a1161 1
	char *dev;
d1166 1
a1166 1
	fd = opendev(cdname, O_RDONLY, OPENDEV_PART, &dev);
d1172 1
a1172 1
			fprintf (stderr, "%s: No disc in drive %s.\n", __progname, dev);
d1175 2
a1176 2
		perror (dev);
		exit (1);
@


1.7
log
@Fixed minor bug with next/prev/replay commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.6 1997/03/09 01:34:27 angelos Exp $	*/
a379 1
#if defined(CDIOCSETSTERIO)
d381 1
a381 6
			return ioctl (fd, CDIOCSETSTERIO);
#else
			printf ("%s: Command argument not yet supported\n",
				__progname);
			return (0);
#endif
@


1.6
log
@Added the "replay" command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.5 1997/02/26 02:08:44 angelos Exp $	*/
d731 1
a731 1
				     h.starting_track + 1, 1);
d733 1
a733 1
                return play_track (trk, 1, trk + 1, 1);
d754 1
a754 1
                return play_track (trk, 1, trk + 1, 1);
d787 1
a787 1
		return play_track (trk, 1, trk + 1, 1);
@


1.5
log
@Next/Prev commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.4 1997/02/23 02:29:02 niklas Exp $	*/
d64 1
d88 1
d117 1
d411 5
d732 21
@


1.4
log
@All audio CDs does not start at block 0
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.3 1996/08/24 08:20:21 deraadt Exp $	*/
d62 2
d77 1
d83 1
d113 2
d396 12
d701 60
@


1.3
log
@cd0 not /dev/cd0
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.2 1996/08/24 06:32:16 downsj Exp $	*/
d418 7
a424 3
			return play_blocks (0, msf2lba (toc_buffer[n].addr.msf.minute,
							toc_buffer[n].addr.msf.second,
							toc_buffer[n].addr.msf.frame));
d426 2
a427 1
			return play_blocks (0, ntohl(toc_buffer[n].addr.lba));
@


1.2
log
@opendev() is smart, we're not.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.c,v 1.1 1996/08/23 23:42:29 downsj Exp $	*/
d45 1
a45 1
#  define DEFAULT_CD_DRIVE  "/dev/cd0"
@


1.1
log
@A renamed and moved cdcontrol from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
a45 5
#  define DEFAULT_CD_DRIVE  "/dev/cd0c"
#endif

#ifndef DEFAULT_CD_PARTITION
#  define DEFAULT_CD_PARTITION  "d"
@
