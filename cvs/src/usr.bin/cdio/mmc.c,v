head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.16
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.14
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.12
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.10
	OPENBSD_5_0:1.28.0.8
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.26.0.6
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16;
locks; strict;
comment	@ * @;


1.30
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Uu5nFG3wCl0LACBb;

1.29
date	2013.11.12.17.57.34;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.01.02.09.44;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.04.07.43.26;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.30.10.41.38;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.13.12.21.19;	author av;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.08.07.26.40;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.23.21.33.32;	author av;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.30.23.35.39;	author av;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.22.21.04.01;	author av;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.08.21.01.24;	author av;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.06.10.16.52;	author av;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.30.17.41.30;	author av;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.31.21.21.11;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.28.02.36.43;	author mjc;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.26.03.48.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.27.02.43.18;	author mjc;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.02.02.30;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.21.21.53.36;	author mjc;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.15.23.49.58;	author mjc;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.06.23.22.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.06.22.18.11;	author mjc;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.06.20.48.07;	author mjc;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.01.07.53.01;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.01.07.12.18;	author mjc;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.01.06.32.17;	author mjc;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.31.23.01.15;	author mjc;	state Exp;
branches;
next	1.3;

1.3
date	2006.05.31.07.51.47;	author mjc;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.31.03.12.28;	author mjc;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.31.01.14.41;	author mjc;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@/*	$OpenBSD: mmc.c,v 1.29 2013/11/12 17:57:34 deraadt Exp $	*/
/*
 * Copyright (c) 2006 Michael Coulter <mjc@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/limits.h>
#include <sys/types.h>
#include <sys/scsiio.h>
#include <sys/param.h>	/* setbit, isset */
#include <scsi/cd.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "extern.h"

extern int fd;
extern u_int8_t mediacap[];
extern char *cdname;
extern int verbose;

#define SCSI_GET_CONFIGURATION		0x46

#define MMC_FEATURE_HDR_LEN		8

static const struct {
	u_int16_t id;
	char *name;
} mmc_feature[] = {
	{ 0x0000, "Profile List" },
	{ 0x0001, "Core" },
	{ 0x0002, "Morphing" },
	{ 0x0003, "Removable Medium" },
	{ 0x0004, "Write Protect" },
	{ 0x0010, "Random Readable" },
	{ 0x001d, "Multi-Read" },
	{ 0x001e, "CD Read" },
	{ 0x001f, "DVD Read" },
	{ 0x0020, "Random Writable" },
	{ 0x0021, "Incremental Streaming Writable" },
	{ 0x0022, "Sector Erasable" },
	{ 0x0023, "Formattable" },
	{ 0x0024, "Hardware Defect Management" },
	{ 0x0025, "Write Once" },
	{ 0x0026, "Restricted Overwrite" },
	{ 0x0027, "CD-RW CAV Write" },
	{ 0x0028, "MRW" },
	{ 0x0029, "Enhanced Defect Reporting" },
	{ 0x002a, "DVD+RW" },
	{ 0x002b, "DVD+R" },
	{ 0x002c, "Rigid Restricted Overwrite" },
	{ 0x002d, "CD Track at Once (TAO)" },
	{ 0x002e, "CD Mastering (Session at Once)" },
	{ 0x002f, "DVD-RW Write" },
	{ 0x0030, "DDCD-ROM (Legacy)" },
	{ 0x0031, "DDCD-R (Legacy)" },
	{ 0x0032, "DDCD-RW (Legacy)" },
	{ 0x0033, "Layer Jump Recording" },
	{ 0x0037, "CD-RW Media Write Support" },
	{ 0x0038, "BD-R Pseudo-Overwrite (POW)" },
	{ 0x003a, "DVD+RW Dual Layer" },
	{ 0x003b, "DVD+R Dual Layer" },
	{ 0x0040, "BD Read" },
	{ 0x0041, "BD Write" },
	{ 0x0042, "Timely Safe Recording (TSR)" },
	{ 0x0050, "HD DVD Read" },
	{ 0x0051, "HD DVD Write" },
	{ 0x0080, "Hybrid Disc" },
	{ 0x0100, "Power Management" },
	{ 0x0101, "S.M.A.R.T." },
	{ 0x0102, "Embedded Changer" },
	{ 0x0103, "CD Audio External Play (Legacy)" },
	{ 0x0104, "Microcode Upgrade" },
	{ 0x0105, "Timeout" },
	{ 0x0106, "DVD CSS" },
	{ 0x0107, "Real Time Streaming" },
	{ 0x0108, "Drive Serial Number" },
	{ 0x0109, "Media Serial Number" },
	{ 0x010a, "Disc Control Blocks (DCBs)" },
	{ 0x010b, "DVD CPRM" },
	{ 0x010c, "Firmware Information" },
	{ 0x010d, "AACS" },
	{ 0x0110, "VCPS" },
	{ 0, NULL }
};

static const struct {
	u_int16_t id;
	char *name;
} mmc_profile[] = {
	{ 0x0001, "Re-writable disk, capable of changing behaviour" },
	{ 0x0002, "Re-writable, with removable media" },
	{ 0x0003, "Magneto-Optical disk with sector erase capability" },
	{ 0x0004, "Optical write once" },
	{ 0x0005, "Advance Storage -- Magneto-Optical" },
	{ 0x0008, "Read only Compact Disc" },
	{ 0x0009, "Write once Compact Disc" },
	{ 0x000a, "Re-writable Compact Disc" },
	{ 0x0010, "Read only DVD" },
	{ 0x0011, "Write once DVD using Sequential recording" },
	{ 0x0012, "Re-writable DVD" },
	{ 0x0013, "Re-recordable DVD using Restricted Overwrite" },
	{ 0x0014, "Re-recordable DVD using Sequential recording" },
	{ 0x0015, "Dual Layer DVD-R using Sequential recording" },
	{ 0x0016, "Dual Layer DVD-R using Layer Jump recording" },
	{ 0x001a, "DVD+ReWritable" },
	{ 0x001b, "DVD+Recordable" },
	{ 0x0020, "DDCD-ROM" },
	{ 0x0021, "DDCD-R" },
	{ 0x0022, "DDCD-RW" },
	{ 0x002a, "DVD+Rewritable Dual Layer" },
	{ 0x002b, "DVD+Recordable Dual Layer" },
	{ 0x003e, "Blu-ray Disc ROM" },
	{ 0x003f, "Blu-ray Disc Recordable -- Sequential Recording Mode" },
	{ 0x0040, "Blu-ray Disc Recordable -- Random Recording Mode" },
	{ 0x0041, "Blu-ray Disc Rewritable" },
	{ 0x004e, "Read-only HD DVD" },
	{ 0x004f, "Write-once HD DVD" },
	{ 0x0050, "Rewritable HD DVD" },
	{ 0, NULL }
};

int
get_media_type(void)
{
	scsireq_t scr;
	char buf[32];
	u_char disctype;
	int rv, error;

	rv = MEDIATYPE_UNKNOWN;
	memset(buf, 0, sizeof(buf));
	memset(&scr, 0, sizeof(scr));

	scr.cmd[0] = READ_TOC;
	scr.cmd[1] = 0x2;	/* MSF */
	scr.cmd[2] = 0x4;	/* ATIP */
	scr.cmd[8] = 0x20;

	scr.flags = SCCMD_ESCAPE | SCCMD_READ;
	scr.databuf = buf;
	scr.datalen = sizeof(buf);
	scr.cmdlen = 10;
	scr.timeout = 120000;
	scr.senselen = SENSEBUFLEN;

	error = ioctl(fd, SCIOCCOMMAND, &scr);
	if (error != -1 && scr.retsts == SCCMD_OK && scr.datalen_used > 7) {
		disctype = (buf[6] >> 6) & 0x1;
		if (disctype == 0)
			rv = MEDIATYPE_CDR;
		else if (disctype == 1)
			rv = MEDIATYPE_CDRW;
	}

	return (rv);
}

int
get_media_capabilities(u_int8_t *cap, int rt)
{
	scsireq_t scr;
	u_char buf[4096];
	u_int32_t i, dlen;
	u_int16_t feature, profile, tmp;
	u_int8_t feature_len;
	int current, error, j, k;

	memset(cap, 0, MMC_FEATURE_MAX / NBBY);
	memset(buf, 0, sizeof(buf));
	memset(&scr, 0, sizeof(scr));

	scr.cmd[0] = SCSI_GET_CONFIGURATION;
	scr.cmd[1] = rt;
	tmp = htobe16(sizeof(buf));
	memcpy(scr.cmd + 7, &tmp, sizeof(u_int16_t));

	scr.flags = SCCMD_ESCAPE | SCCMD_READ;
	scr.databuf = buf;
	scr.datalen = sizeof(buf);
	scr.cmdlen = 10;
	scr.timeout = 120000;
	scr.senselen = SENSEBUFLEN;

	error = ioctl(fd, SCIOCCOMMAND, &scr);
	if (error == -1 || scr.retsts != SCCMD_OK)
		return (-1);
	if (scr.datalen_used < MMC_FEATURE_HDR_LEN)
		return (-1);	/* Can't get the header. */

	/* Include the whole header in the length. */
	dlen = betoh32(*(u_int32_t *)buf) + 4;
	if (dlen > scr.datalen_used)
		dlen = scr.datalen_used;

	if (verbose > 1)
		printf("Features:\n");
	for (i = MMC_FEATURE_HDR_LEN; i + 3 < dlen; i += feature_len) {
		feature_len = buf[i + 3] + 4;
		if (feature_len + i > dlen)
			break;

		feature = betoh16(*(u_int16_t *)(buf + i));
		if (feature >= MMC_FEATURE_MAX)
			break;

		if (verbose > 1) {
			printf("0x%04x", feature);
			for (j = 0; mmc_feature[j].name != NULL; j++)
				if (feature == mmc_feature[j].id)
					break;
			if (mmc_feature[j].name == NULL)
				printf(" <Undocumented>");
			else
				printf(" %s", mmc_feature[j].name);
			if (feature_len > 4)
				printf(" (%d bytes of data)", feature_len - 4);
			printf("\n");
			if (verbose > 2) {
				printf("    ");
				for (j = i; j < i + feature_len; j++) {
					printf("%02x", buf[j]);
					if ((j + 1) == (i + feature_len))
						printf("\n");
					else if ((j > i) && ((j - i + 1) % 16
					    == 0))
						printf("\n    ");
					else if ((j - i) == 3)
						printf("|");
					else
						printf(" ");
				}
			}
		}
		if (feature == 0 && verbose > 1) {
			if (verbose > 2)
				printf("    Profiles:\n");
			for (j = i + 4; j < i + feature_len; j += 4) {
				profile = betoh16(*(u_int16_t *)(buf+j));
				current = buf[j+2] == 1;
				if (verbose < 3 && !current)
					continue;
				if (current)
					printf("  * ");
				else
					printf("    ");
				printf("0x%04x", profile);
				for (k = 0; mmc_profile[k].name != NULL; k++)
					if (profile == mmc_profile[k].id)
						break;
				if (mmc_profile[k].name == NULL)
					printf(" <Undocumented>");
				else
					printf(" %s", mmc_profile[k].name);
				printf(" %s\n", current ? "[Current Profile]" :
				    "" );
			}
		}
		setbit(cap, feature);
	}

	return (0);
}

static int
set_speed(int wspeed)
{
	scsireq_t scr;
	int r;

	memset(&scr, 0, sizeof(scr));
	scr.cmd[0] = SET_CD_SPEED;
	scr.cmd[1] = (isset(mediacap, MMC_FEATURE_CDRW_CAV)) != 0;
	*(u_int16_t *)(scr.cmd + 2) = htobe16(DRIVE_SPEED_OPTIMAL);
	*(u_int16_t *)(scr.cmd + 4) = htobe16(wspeed);

	scr.cmdlen = 12;
	scr.datalen = 0;
	scr.timeout = 120000;
	scr.flags = SCCMD_ESCAPE;
	scr.senselen = SENSEBUFLEN;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
blank(void)
{
	struct scsi_blank *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_blank *)scr.cmd;
	scb->opcode = BLANK;
	scb->byte2 |= BLANK_MINIMAL;
	scr.cmdlen = sizeof(*scb);
	scr.datalen = 0;
	scr.timeout = 120000;
	scr.flags = SCCMD_ESCAPE;
	scr.senselen = SENSEBUFLEN;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
unit_ready(void)
{
	struct scsi_test_unit_ready *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_test_unit_ready *)scr.cmd;
	scb->opcode = TEST_UNIT_READY;
	scr.cmdlen = sizeof(*scb);
	scr.datalen = 0;
	scr.timeout = 120000;
	scr.flags = SCCMD_ESCAPE;
	scr.senselen = SENSEBUFLEN;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
synchronize_cache(void)
{
	struct scsi_synchronize_cache *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_synchronize_cache *)scr.cmd;
	scb->opcode = SYNCHRONIZE_CACHE;
	scr.cmdlen = sizeof(*scb);
	scr.datalen = 0;
	scr.timeout = 120000;
	scr.flags = SCCMD_ESCAPE;
	scr.senselen = SENSEBUFLEN;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
close_session(void)
{
	struct scsi_close_track *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_close_track *)scr.cmd;
	scb->opcode = CLOSE_TRACK;
	scb->closefunc = CT_CLOSE_SESS;
	scr.cmdlen = sizeof(*scb);
	scr.datalen = 0;
	scr.timeout = 120000;
	scr.flags = SCCMD_ESCAPE;
	scr.senselen = SENSEBUFLEN;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
writetao(struct track_head *thp)
{
	u_char modebuf[70], bdlen;
	struct track_info *tr;
	int r, track = 0;

	if ((r = mode_sense_write(modebuf)) != SCCMD_OK) {
		warnx("mode sense failed: %d", r);
		return (r);
	}
	bdlen = modebuf[7];
	modebuf[2+8+bdlen] |= 0x40; /* Buffer Underrun Free Enable */
	modebuf[2+8+bdlen] |= 0x01; /* change write type to TAO */

	SLIST_FOREACH(tr, thp, track_list) {
		track++;
		switch (tr->type) {
		case 'd':
			modebuf[3+8+bdlen] = 0x04; /* track mode = data */
			modebuf[4+8+bdlen] = 0x08; /* 2048 block track mode */
			modebuf[8+8+bdlen] = 0x00; /* turn off XA */
			break;
		case 'a':
			modebuf[3+8+bdlen] = 0x00; /* track mode = audio */
			modebuf[4+8+bdlen] = 0x00; /* 2352 block track mode */
			modebuf[8+8+bdlen] = 0x00; /* turn off XA */
			break;
		default:
			warn("impossible tracktype detected");
			break;
		}
		while (unit_ready() != SCCMD_OK)
			continue;
		if ((r = mode_select_write(modebuf)) != SCCMD_OK) {
			warnx("mode select failed: %d", r);
			return (r);
		}

		set_speed(tr->speed);
		writetrack(tr, track);
		synchronize_cache();
	}
	fprintf(stderr, "Closing session.\n");
	close_session();
	return (0);
}

int
writetrack(struct track_info *tr, int track)
{
	struct timeval tv, otv, atv;
	u_char databuf[65536], nblk;
	u_int end_lba, lba, tmp;
	scsireq_t scr;
	int r;

	nblk = 65535/tr->blklen;
	bzero(&scr, sizeof(scr));
	scr.timeout = 300000;
	scr.cmd[0] = WRITE_BIG;
	scr.cmd[1] = 0x00;
	scr.cmd[8] = nblk; /* Transfer length in blocks (LSB) */
	scr.cmdlen = 10;
	scr.databuf = (caddr_t)databuf;
	scr.datalen = nblk * tr->blklen;
	scr.senselen = SENSEBUFLEN;
	scr.flags = SCCMD_ESCAPE|SCCMD_WRITE;

	timerclear(&otv);
	atv.tv_sec = 1;
	atv.tv_usec = 0;

	if (get_nwa(&lba) != SCCMD_OK) {
		warnx("cannot get next writable address");
		return (-1);
	}
	tmp = htobe32(lba); /* update lba in cdb */
	memcpy(&scr.cmd[2], &tmp, sizeof(tmp));

	if (tr->sz / tr->blklen + 1 > UINT_MAX || tr->sz < tr->blklen) {
		warnx("file %s has invalid size", tr->file);
		return (-1);
	}
	if (tr->sz % tr->blklen) {
		warnx("file %s is not multiple of block length %d",
		    tr->file, tr->blklen);
		end_lba = tr->sz / tr->blklen + lba + 1;
	} else {
		end_lba = tr->sz / tr->blklen + lba;
	}
	if (lseek(tr->fd, tr->off, SEEK_SET) == -1)
		err(1, "seek failed for file %s", tr->file);
	while (lba < end_lba && nblk != 0) {
		while (lba + nblk <= end_lba) {
			read(tr->fd, databuf, nblk * tr->blklen);
			scr.cmd[8] = nblk;
			scr.datalen = nblk * tr->blklen;
again:
			r = ioctl(fd, SCIOCCOMMAND, &scr);
			if (r != 0) {
				printf("\r%60s", "");
				warn("ioctl failed while attempting to write");
				return (-1);
			}
			if (scr.retsts == SCCMD_SENSE && scr.sense[2] == 0x2) {
				usleep(1000);
				goto again;
			}
			if (scr.retsts != SCCMD_OK) {
				printf("\r%60s", "");
				warnx("ioctl returned bad status while "
				    "attempting to write: %d",
				    scr.retsts);
				return (r);
			}
			lba += nblk;

			gettimeofday(&tv, NULL);
			if (lba == end_lba || timercmp(&tv, &otv, >)) {
				fprintf(stderr,
				    "\rtrack %02d '%c' %08u/%08u %3d%%",
				    track, tr->type,
				    lba, end_lba, 100 * lba / end_lba);
				timeradd(&tv, &atv, &otv);
			}
			tmp = htobe32(lba); /* update lba in cdb */
			memcpy(&scr.cmd[2], &tmp, sizeof(tmp));
		}
		nblk--;
	}
	printf("\n");
	close(tr->fd);
	return (0);
}

int
mode_sense_write(unsigned char buf[])
{
	struct scsi_mode_sense_big *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_mode_sense_big *)scr.cmd;
	scb->opcode = MODE_SENSE_BIG;
	/* XXX: need to set disable block descriptors and check SCSI drive */
	scb->page = WRITE_PARAM_PAGE;
	scb->length[1] = 0x46; /* 16 for the header + size from pg. 89 mmc-r10a.pdf */
	scr.cmdlen = sizeof(*scb);
	scr.timeout = 4000;
	scr.senselen = SENSEBUFLEN;
	scr.datalen= 0x46;
	scr.flags = SCCMD_ESCAPE|SCCMD_READ;
	scr.databuf = (caddr_t)buf;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
mode_select_write(unsigned char buf[])
{
	struct scsi_mode_select_big *scb;
	scsireq_t scr;
	int r;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_mode_select_big *)scr.cmd;
	scb->opcode = MODE_SELECT_BIG;

	/*
	 * INF-8020 says bit 4 in byte 2 is '1'
	 * INF-8090 refers to it as 'PF(1)' then doesn't
	 * describe it.
	 */
	scb->byte2 = 0x10;
	scb->length[1] = 2 + buf[1] + 256 * buf[0];
	scr.timeout = 4000;
	scr.senselen = SENSEBUFLEN;
	scr.cmdlen = sizeof(*scb);
	scr.datalen = 2 + buf[1] + 256 * buf[0];
	scr.flags = SCCMD_ESCAPE|SCCMD_WRITE;
	scr.databuf = (caddr_t)buf;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	return (r == 0 ? scr.retsts : -1);
}

int
get_disc_size(off_t *availblk)
{
	u_char databuf[28];
	struct scsi_read_track_info *scb;
	scsireq_t scr;
	int r, tmp;

	bzero(&scr, sizeof(scr));
	scb = (struct scsi_read_track_info *)scr.cmd;
	scr.timeout = 4000;
	scr.senselen = SENSEBUFLEN;
	scb->opcode = READ_TRACK_INFO;
	scb->addrtype = RTI_TRACK;
	scb->addr[3] = 1;
	scb->data_len[1] = 0x1c;
	scr.cmdlen = sizeof(*scb);
	scr.datalen= 0x1c;
	scr.flags = SCCMD_ESCAPE|SCCMD_READ;
	scr.databuf = (caddr_t)databuf;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	memcpy(&tmp, &databuf[16], sizeof(tmp));
	*availblk = betoh32(tmp);
	return (r == 0 ? scr.retsts : -1);
}

int
get_nwa(int *nwa)
{
	u_char databuf[28];
	scsireq_t scr;
	int r, tmp;

	bzero(&scr, sizeof(scr));
	scr.timeout = 4000;
	scr.senselen = SENSEBUFLEN;
	scr.cmd[0] = READ_TRACK_INFO;
	scr.cmd[1] = 0x01;
	scr.cmd[5] = 0xff; /* Invisible Track */
	scr.cmd[7] = 0x00;
	scr.cmd[8] = 0x1c;
	scr.cmdlen = 10;
	scr.datalen= 0x1c;
	scr.flags = SCCMD_ESCAPE|SCCMD_READ;
	scr.databuf = (caddr_t)databuf;

	r = ioctl(fd, SCIOCCOMMAND, &scr);
	memcpy(&tmp, &databuf[12], sizeof(tmp));
	*nwa = betoh32(tmp);
	return (r == 0 ? scr.retsts : -1);
}
@


1.29
log
@bring prototypes into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.28 2010/03/01 02:09:44 krw Exp $	*/
d21 1
a21 1
#include <sys/param.h>
@


1.28
log
@Add printing of current profile and feature information to 'info'
command with -v. Make a second -v cause printing of raw feature
data and a full list of profiles. A few minor tweaks to the feature
bitmap handling. Helps in debugging media problems in cdio.

Suggestions from fgsch@@, man page fixes from jmc@@ as usual.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.27 2009/12/04 07:43:26 claudio Exp $	*/
d281 1
a281 1
int
@


1.27
log
@Do not write 16bit values directly to odd addresses - strict alignment
architectures don't like that. Makes cd blanking on sparc64 possible.
OK deraadt@@, krw@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.26 2008/08/30 10:41:38 fgsch Exp $	*/
d34 1
a34 1
extern int mediacap[];
d36 1
d42 97
d164 1
a164 1
	if (error != -1 && scr.retsts == 0 && scr.datalen_used > 7) {
d176 1
a176 1
get_media_capabilities(int *cap, int rt)
d181 1
a181 1
	u_int16_t feature, tmp;
d183 1
a183 1
	int error;
d185 1
a185 1
	memset(cap, 0, MMC_FEATURE_MAX / 8);
d202 1
a202 1
	if (error == -1 || scr.retsts != 0)
d212 2
d223 52
@


1.26
log
@use a bitmap to store the features. simplify the code a bit and allow for
future work.  ok av@@ a similar diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.25 2008/08/13 12:21:19 av Exp $	*/
d83 1
a83 1
	u_int16_t feature;
d93 2
a94 1
	*(u_int16_t *)(scr.cmd + 7) = htobe16(sizeof(buf));
@


1.25
log
@Old drives (reported Giovanni Bechis <bigionews@@snb.it>) don't report CD-RW
write feature. Add additional check for media type before blanking.
The patch fixes problem for Giovanni.
ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.24 2008/08/08 07:26:40 fgsch Exp $	*/
d21 1
d34 1
a34 1
extern int mediacap;
d39 1
a39 3
#define MMC_FEATURE_CDRW_CAV		0x27
#define MMC_FEATURE_CD_TAO		0x2d
#define MMC_FEATURE_CDRW_WRITE		0x37
d78 1
a78 1
get_media_capabilities(int *cap)
d82 3
a85 2
	u_int32_t i, dsz;
	u_int16_t feature;
d87 1
a87 1
	*cap = 0;
d92 2
a93 2
	scr.cmd[1] = 1;	/* enumerate only "current" features */
	*(u_int16_t *)(scr.cmd + 7) = betoh16(sizeof(buf));
d105 12
a116 2
	if (scr.datalen_used < 8)
		return (-1);	/* can't get header */
a117 9
	dsz = betoh32(*(u_int32_t *)buf);
	if (dsz > scr.datalen_used - 4)
		dsz = scr.datalen_used - 4;

	dsz += 4;	/* total size of bufer for all features */
	i = 8;
	while (i <= dsz - 4) {
		if (dsz - i < (u_int32_t)buf[i + 3] + 4)
			break;	/* partial feature descriptor */
d119 2
d122 1
a122 8
		if (feature == MMC_FEATURE_CDRW_CAV)
			*cap |= MEDIACAP_CDRW_CAV;
		else if (feature == MMC_FEATURE_CD_TAO)
			*cap |= MEDIACAP_TAO;
		else if (feature == MMC_FEATURE_CDRW_WRITE)
			*cap |= MEDIACAP_CDRW_WRITE;

		i += 4 + buf[i + 3];
d136 1
a136 1
	scr.cmd[1] = (mediacap & MEDIACAP_CDRW_CAV) != 0;
@


1.24
log
@o use definitions from cd.h
o remove unused function prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: mmc.c,v 1.23 2008/07/23 21:33:32 av Exp $	*/
d41 36
@


1.23
log
@we really need unsigned in arithmetic operations.
comments by fgsch
@
text
@d1 1
a1 2
/* $OpenBSD: mmc.c,v 1.22 2008/06/30 23:35:39 av Exp $ */

a36 1
#define SCSI_SET_SPEED			0xbb
d103 1
a103 1
	scr.cmd[0] = SCSI_SET_SPEED;
d426 1
a426 1
	scr.cmd[0] = 0x52; /* READ TRACK INFO */
@


1.22
log
@set speed for writing tracks in TAO.
ok and tweaks by fgsch
manual page by jmc
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.21 2008/06/22 21:04:01 av Exp $ */
d48 1
a48 1
	char buf[4096];
d81 1
a81 1
		if (dsz - i < 4 + buf[i + 3])
@


1.21
log
@Automatically distinguish between CD-DA track and WAVE audio file writing them
in TAO mode. For WAVE files we should skip header.

ok and comments by fgsch
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.20 2008/06/08 21:01:24 av Exp $ */
d34 1
d38 1
d40 1
d85 3
a87 1
		if (feature == MMC_FEATURE_CD_TAO)
d99 22
d240 2
@


1.20
log
@add ability to determine media capabilities (what we can do with media).
ok fgsch
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.19 2008/06/06 10:16:52 av Exp $ */
d264 2
a265 4
	if (tr->type == 'a') {
		if (lseek(tr->fd, WAVHDRLEN, SEEK_SET) == -1)
			err(1, "seek failed for file %s", tr->file);
	}
@


1.19
log
@Make open_cd() remember open mode. "blank" doesn't have to check for EPERM
anymore.
idea by jakemsr
ok jakemsr ratchov fgsch (with tweaks)
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.18 2008/05/30 17:41:30 av Exp $ */
d35 57
@


1.18
log
@cdio's blank command blanked CD twise. Fixed.
ok jakemsr krw millert ratchov
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.17 2007/07/31 21:21:11 deraadt Exp $ */
a53 7
	if (r == -1 && errno == EPERM) {
		close(fd);
		fd = -1;
		if (!open_cd(cdname, 1))
			return (-1);
		r = ioctl(fd, SCIOCCOMMAND, &scr);
	}
@


1.17
log
@make rip code work like mmc code for how it does progress reports (use
a timer, so that stderr does not get splattered); tested by xsa and others
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.16 2006/08/28 02:36:43 mjc Exp $ */
d59 1
a60 1
	r = ioctl(fd, SCIOCCOMMAND, &scr);
@


1.16
log
@fix up disc size check.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.15 2006/08/26 03:48:50 deraadt Exp $ */
d226 1
a226 1
				printf("%60s\r", "");
d235 1
a235 1
				printf("%60s\r", "");
d246 1
a246 1
				    "track %02d '%c' %08u/%08u %3d%%\r",
@


1.15
log
@print updates on the same line, per second, as we go along writing, in
the following form:
    track 01 'd' 00328891/00328891 100%
checked lots, but nobody replied to my mail...
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.14 2006/06/27 02:43:18 mjc Exp $ */
d328 2
a329 2
	scb->addr[1] = 1;
	scb->data_len[3] = 0x1c;
@


1.14
log
@add message on session close
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.13 2006/06/27 02:02:30 deraadt Exp $ */
d128 1
a128 1
	u_char modebuf[70];
d130 1
a130 2
	u_char bdlen;
	int r;
d141 1
d160 1
a160 1
			warnx("mode select failed: %d",r);
d163 1
a163 1
		writetrack(tr);
d166 1
a166 1
	fprintf(stderr,"Closing session.\n");
d172 1
a172 1
writetrack(struct track_info *tr)
d174 3
a176 1
	u_char databuf[65536];
a177 2
	u_int end_lba, lba;
	u_int tmp;
a178 1
	u_char nblk;
d192 4
d204 1
a204 1
		warnx("file %s has invalid size",tr->file);
d226 1
a226 1
				printf("\r");
d235 1
a235 1
				printf("\r");
d242 9
a250 2
			fprintf(stderr,"\rLBA: %08u/%08u",
			    lba, end_lba);
d320 1
a320 1
	int r,tmp;
d346 1
a346 1
	int r,tmp;
@


1.13
log
@improve output during cd writing; ok mjc
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.12 2006/06/21 21:53:36 mjc Exp $ */
d166 1
a166 1
	fprintf(stderr,"\n");
@


1.12
log
@retry if sense code indicates not ready. fixes writing for drives
that issue long write in progress if the write buffer is full.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.11 2006/06/15 23:49:58 mjc Exp $ */
d215 1
a215 1
	while ((lba < end_lba) && (nblk != 0)) {
d223 1
d232 1
d239 2
a240 1
			fprintf(stderr,"\rLBA: 0x%06x/0x%06x",lba,end_lba);
d246 1
@


1.11
log
@put fd into track's struct so we can fail earlier
'looks good' pat@@
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.10 2006/06/06 23:22:28 deraadt Exp $ */
d220 1
d225 4
@


1.10
log
@minor cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.9 2006/06/06 22:18:11 mjc Exp $ */
d178 1
a178 1
	int r,rfd;
a210 1
	rfd = open(tr->file, O_RDONLY, 0640);
d212 2
a213 2
		if (lseek(rfd, WAVHDRLEN, SEEK_SET) == -1)
			err(1, "seek failed");
d217 1
a217 1
			read(rfd, databuf, nblk * tr->blklen);
d238 1
a238 1
	close(rfd);
@


1.9
log
@zap another magic number
spotted by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.8 2006/06/06 20:48:07 mjc Exp $ */
d277 6
a282 5
/*
 * INF-8020 says bit 4 in byte 2 is '1'
 * INF-8090 refers to it as 'PF(1)' then doesn't
 * describe it. 
 */
@


1.8
log
@make use of new structs and defines in cd.h
dispells some magic numbers
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.7 2006/06/01 07:53:01 deraadt Exp $ */
d184 1
a184 1
	scr.cmd[0] = 0x2a;
@


1.7
log
@minor tweaks
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.6 2006/06/01 07:12:18 mjc Exp $ */
d22 3
d39 1
d44 4
a47 3
	scr.cmd[0] = 0xa1;
	scr.cmd[1] = 0x01;
	scr.cmdlen = 12;
d67 1
d72 3
a74 2
	scr.cmd[0] = 0x00;
	scr.cmdlen = 6;
d87 1
d92 3
a94 2
	scr.cmd[0] = 0x35;
	scr.cmdlen = 10;
d107 1
d112 4
a115 4
	scr.cmd[0] = 0x5b;
	scr.cmd[2] = 0x02; /* close session */
	scr.cmd[5] = 0x00; /* track number */
	scr.cmdlen = 10;
d246 1
d251 6
a258 6
	scr.cmd[0] = 0x5a;
	scr.cmd[1] = 0x00;
	scr.cmd[2] = 0x05; /* Write parameters mode page */
	scr.cmd[7] = 0x00;
	scr.cmd[8] = 0x46; /* 16 for the header + size from pg. 89 mmc-r10a.pdf */
	scr.cmdlen = 10;
d270 1
d275 9
d286 1
a286 6
	scr.cmd[0] = 0x55;
	scr.cmd[1] = 0x10; /* pages aren't vendor specific */
	scr.cmd[2] = 0x00;
	scr.cmd[7] = 0x00;
	scr.cmd[8] = 2 + buf[1] + 256 * buf[0];
	scr.cmdlen = 10;
d299 1
d304 1
d307 5
a311 6
	scr.cmd[0] = 0x52; /* READ TRACK INFO */
	scr.cmd[1] = 0x01;
	scr.cmd[5] = 0x01; /* Track 01 */
	scr.cmd[7] = 0x00;
	scr.cmd[8] = 0x1c;
	scr.cmdlen = 10;
@


1.6
log
@add checks for disc size before we set out trying to burn 4gb
onto an unsuspecting cdr
@
text
@d1 2
a2 1
/* $OpenBSD: mmc.c,v 1.5 2006/06/01 06:32:17 mjc Exp $ */
a29 1
extern int errno;
d52 1
a52 1
		if (! open_cd(cdname, 1))
a112 1

d120 1
a121 1
	u_char bdlen;
d132 1
a132 1
		switch(tr->type) {
d195 2
a196 1
		warnx("file %s is not multiple of block length %d", tr->file, tr->blklen);
d217 3
a219 1
				warnx("ioctl returned bad status while attempting to write: %d", scr.retsts);
d248 1
a248 1
	scr.datalen= 0x46; 
d295 1
a295 1
	scr.datalen= 0x1c; 
d321 1
a321 1
	scr.datalen= 0x1c; 
@


1.5
log
@better command line usage as suggested by deraadt@@
ok @@deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.4 2006/05/31 23:01:15 mjc Exp $ */
a28 1
#define WAVHDRLEN 44
a137 1
			tr->blklen = 2048;
a142 1
			tr->blklen = 2352;
a194 2
	if (tr->type == 'a')
		tr->sz -= WAVHDRLEN;
d274 26
@


1.4
log
@bogus value in cdb. excess cut n' paste.
@
text
@d1 1
a1 1
/* $OpenBSD: mmc.c,v 1.3 2006/05/31 07:51:47 mjc Exp $ */
a19 1
#include <sys/stat.h>
a32 1
extern char *track_types;
d118 1
a118 1
writetao(int ntracks, char *track_files[])
d121 2
a122 3
	u_int blklen;
	u_int t;
	int i,r;
d124 1
a124 3
	
	if (track_types == NULL)
		track_types = strdup("d");
d133 3
a135 2
	for (i = 0, t = 0; t < ntracks; t++) {
		if (track_types[i] == 'd') {
d139 3
a141 2
			blklen = 2048;
		} else if (track_types[i] == 'a') {
d145 5
a149 4
			blklen = 2352;
		} else {
			warnx("invalid track type specified");
			return (1);
d157 1
a157 1
		writetrack(track_files[t], blklen, t, track_types[i]);
a158 2
		if (track_types[i+1] != '\0')
			i++;
a160 1
	synchronize_cache();
d166 1
a166 1
writetrack(char *file, u_int blklen, u_int trackno, char type)
a168 1
	struct stat sb;
d175 1
a175 1
	nblk = 65535/blklen;
d183 1
a183 1
	scr.datalen = nblk * blklen;
d194 2
a195 6
	if (stat(file, &sb) != 0) {
		warn("cannot stat file %s",file);
		return (-1);
	}
	if (sb.st_size / blklen + 1 > UINT_MAX || sb.st_size < blklen) {
		warnx("file %s has invalid size",file);
d198 5
a202 5
	if (type == 'a')
		sb.st_size -= WAVHDRLEN;
	if (sb.st_size % blklen) {
		warnx("file %s is not multiple of block length %d",file,blklen);
		end_lba = sb.st_size / blklen + lba + 1;
d204 1
a204 1
		end_lba = sb.st_size / blklen + lba;
d206 2
a207 2
	rfd = open(file, O_RDONLY, 0640);
	if (type == 'a') {
d213 1
a213 1
			read(rfd, databuf, nblk * blklen);
d215 1
a215 1
			scr.datalen = nblk * blklen;
@


1.3
log
@add license block
spotted by Dries Schellekens
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a304 1
	scr.cmd[2] = 0x05; /* Write parameters mode page */
@


1.2
log
@when blanking, if fd is already open read-only, re-open read/write
@
text
@d1 17
@


1.1
log
@add rewritable blanking and track-at-once burning support

ok deraadt@@
@
text
@d6 1
d14 1
d16 1
d34 7
@

