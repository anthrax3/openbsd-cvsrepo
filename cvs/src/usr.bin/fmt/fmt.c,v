head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.2
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.30.0.10
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.8
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.6
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.4
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.2
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.12
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.8
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.6
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.23.0.8
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.13.0.4
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2017.02.20.15.48.00;	author schwarze;	state Exp;
branches;
next	1.37;
commitid	DbTxMmSDY0QAGSVU;

1.37
date	2017.02.19.23.45.46;	author schwarze;	state Exp;
branches;
next	1.36;
commitid	H9lNZUHYQAIZj0oy;

1.36
date	2016.01.07.18.02.43;	author schwarze;	state Exp;
branches;
next	1.35;
commitid	dA6U1moDqPIVxR9x;

1.35
date	2015.12.31.16.10.31;	author millert;	state Exp;
branches;
next	1.34;
commitid	7gE8T9Z0cAp6A2Lk;

1.34
date	2015.12.15.16.26.17;	author schwarze;	state Exp;
branches;
next	1.33;
commitid	DivyAt8oybSdtYD7;

1.33
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	sbrB3Q5CNxcwZpfU;

1.32
date	2015.10.05.06.21.15;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	oPFoV6gojsVJYHlQ;

1.31
date	2015.10.05.06.17.05;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	GijuBsAt3gdZM8xE;

1.30
date	2013.11.26.13.18.55;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.17.04.26.28;	author lum;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.15.11.43.45;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.29.21.59.04;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.29.20.09.27;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.08.23.34.43;	author cloder;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.29.16.59.46;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.01.23.14.19;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.01.15.34.26;	author grange;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.29.00.33.06;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.28.22.01.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.12.05.17.05;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.25.15.35.42;	author pjanzen;	state Exp;
branches;
next	1.15;

1.15
date	99.12.30.18.00.42;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	99.12.15.05.34.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.12.14.21.50.32;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.12.14.21.48.10;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.04.25.23.07.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.04.25.23.02.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.02.16.07.54.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.01.15.31.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.09.23.11.54.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.02.08.10.23.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.27.04.06.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.26.03.56.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.12.35;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.15;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@* Hoist Copyright notice to the top, don't hide it in the middle.
* Add Copyright and license for my changes, and for pjanzen@@'s in 2000.
* Comply with the obnoxious license condition that we must list changes
in the source code.
* Delete a fragment of an ancient RCS change log listing changes by
Gareth McCaughan himself.  The license does NOT require us to keep that,
and it does not contain interesting information, not even for historians.

OK pjanzen@@ deraadt@@
@
text
@/*	$OpenBSD: fmt.c,v 1.37 2017/02/19 23:45:46 schwarze Exp $	*/
/*
 * This file is a derived work.
 * The changes are covered by the following Copyright and license:
 *
 * Copyright (c) 2015, 2016 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2000 Paul Janzen <pjanzen@@foatdi.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *
 * The unchanged parts are covered by the following Copyright and license:
 *
 * Copyright (c) 1997 Gareth McCaughan. All rights reserved.
 *
 * Redistribution and use of this code, in source or binary forms,
 * with or without modification, are permitted subject to the following
 * conditions:
 *
 *  - Redistribution of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *  - If you distribute modified source code it must also include
 *    a notice saying that it has been modified, and giving a brief
 *    description of what changes have been made.
 *
 * Disclaimer: I am not responsible for the results of using this code.
 *             If it formats your hard disc, sends obscene messages to
 *             your boss and kills your children then that's your problem
 *             not mine. I give absolutely no warranty of any sort as to
 *             what the program will do, and absolutely refuse to be held
 *             liable for any consequences of your using it.
 *             Thank you. Have a nice day.
 *
 *
 * Brief overview of the changes made by OpenBSD:
 * Added UTF-8 support (2016).
 * Added pledge(2) support (2015).
 * ANSI function syntax and KNF (2004).
 * Added -w option (2000).
 * Some minor changes can be seen in the public OpenBSD CVS repository.
 */

/* Sensible version of fmt
 *
 * Syntax: fmt [ options ] [ goal [ max ] ] [ filename ... ]
 *
 * Since the documentation for the original fmt is so poor, here
 * is an accurate description of what this one does. It's usually
 * the same. The *mechanism* used may differ from that suggested
 * here. Note that we are *not* entirely compatible with fmt,
 * because fmt gets so many things wrong.
 *
 * 1. Tabs are expanded, assuming 8-space tab stops.
 *    If the `-t <n>' option is given, we assume <n>-space
 *    tab stops instead.
 *    Trailing blanks are removed from all lines.
 *    x\b == nothing, for any x other than \b.
 *    Other control characters are simply stripped. This
 *    includes \r.
 * 2. Each line is split into leading whitespace and
 *    everything else. Maximal consecutive sequences of
 *    lines with the same leading whitespace are considered
 *    to form paragraphs, except that a blank line is always
 *    a paragraph to itself.
 *    If the `-p' option is given then the first line of a
 *    paragraph is permitted to have indentation different
 *    from that of the other lines.
 *    If the `-m' option is given then a line that looks
 *    like a mail message header, if it is not immediately
 *    preceded by a non-blank non-message-header line, is
 *    taken to start a new paragraph, which also contains
 *    any subsequent lines with non-empty leading whitespace.
 *    Unless the `-n' option is given, lines beginning with
 *    a . (dot) are not formatted.
 * 3. The "everything else" is split into words; a word
 *    includes its trailing whitespace, and a word at the
 *    end of a line is deemed to be followed by a single
 *    space, or two spaces if it ends with a sentence-end
 *    character. (See the `-d' option for how to change that.)
 *    If the `-s' option has been given, then a word's trailing
 *    whitespace is replaced by what it would have had if it
 *    had occurred at end of line.
 * 4. Each paragraph is sent to standard output as follows.
 *    We output the leading whitespace, and then enough words
 *    to make the line length as near as possible to the goal
 *    without exceeding the maximum. (If a single word would
 *    exceed the maximum, we output that anyway.) Of course
 *    the trailing whitespace of the last word is ignored.
 *    We then emit a newline and start again if there are any
 *    words left.
 *    Note that for a blank line this translates as "We emit
 *    a newline".
 *    If the `-l <n>' option is given, then leading whitespace
 *    is modified slightly: <n> spaces are replaced by a tab.
 *    Indented paragraphs (see above under `-p') make matters
 *    more complicated than this suggests. Actually every paragraph
 *    has two `leading whitespace' values; the value for the first
 *    line, and the value for the most recent line. (While processing
 *    the first line, the two are equal. When `-p' has not been
 *    given, they are always equal.) The leading whitespace
 *    actually output is that of the first line (for the first
 *    line of *output*) or that of the most recent line (for
 *    all other lines of output).
 *    When `-m' has been given, message header paragraphs are
 *    taken as having first-leading-whitespace empty and
 *    subsequent-leading-whitespace two spaces.
 *
 * Multiple input files are formatted one at a time, so that a file
 * never ends in the middle of a line.
 *
 * There's an alternative mode of operation, invoked by giving
 * the `-c' option. In that case we just center every line,
 * and most of the other options are ignored. This should
 * really be in a separate program, but we must stay compatible
 * with old `fmt'.
 *
 * QUERY: Should `-m' also try to do the right thing with quoted text?
 * QUERY: `-b' to treat backslashed whitespace as old `fmt' does?
 * QUERY: Option meaning `never join lines'?
 * QUERY: Option meaning `split in mid-word to avoid overlong lines'?
 * (Those last two might not be useful, since we have `fold'.)
 *
 * Differences from old `fmt':
 *
 *   - We have many more options. Options that aren't understood
 *     generate a lengthy usage message, rather than being
 *     treated as filenames.
 *   - Even with `-m', our handling of message headers is
 *     significantly different. (And much better.)
 *   - We don't treat `\ ' as non-word-breaking.
 *   - Downward changes of indentation start new paragraphs
 *     for us, as well as upward. (I think old `fmt' behaves
 *     in the way it does in order to allow indented paragraphs,
 *     but this is a broken way of making indented paragraphs
 *     behave right.)
 *   - Given the choice of going over or under |goal_length|
 *     by the same amount, we go over; old `fmt' goes under.
 *   - We treat `?' as ending a sentence, and not `:'. Old `fmt'
 *     does the reverse.
 *   - We return approved return codes. Old `fmt' returns
 *     1 for some errors, and *the number of unopenable files*
 *     when that was all that went wrong.
 *   - We have fewer crashes and more helpful error messages.
 *   - We don't turn spaces into tabs at starts of lines unless
 *     specifically requested.
 *   - New `fmt' is somewhat smaller and slightly faster than
 *     old `fmt'.
 *
 * Bugs:
 *
 *   None known. There probably are some, though.
 *
 * Portability:
 *
 *   I believe this code to be pretty portable. It does require
 *   that you have `getopt'. If you need to include "getopt.h"
 *   for this (e.g., if your system didn't come with `getopt'
 *   and you installed it yourself) then you should arrange for
 *   NEED_getopt_h to be #defined.
 *
 *   Everything here should work OK even on nasty 16-bit
 *   machines and nice 64-bit ones. However, it's only really
 *   been tested on my FreeBSD machine. Your mileage may vary.
 */

#include <ctype.h>
#include <err.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <wchar.h>
#include <wctype.h>

/* Something that, we hope, will never be a genuine line length,
 * indentation etc.
 */
#define SILLY ((size_t)-1)

/* I used to use |strtoul| for this, but (1) not all systems have it
 * and (2) it's probably better to use |strtol| to detect negative
 * numbers better.
 * If |fussyp==0| then we don't complain about non-numbers
 * (returning 0 instead), but we do complain about bad numbers.
 */
static size_t
get_positive(const char *s, const char *err_mess, int fussyP)
{
	char *t;
	long result = strtol(s, &t, 0);

	if (*t) {
		if (fussyP)
			goto Lose;
		else
			return 0;
	}
	if (result <= 0) {
Lose:
		errx(1, "%s", err_mess);
	}

	return (size_t) result;
}

/* Global variables */

static int centerP = 0;				/* Try to center lines? */
static size_t goal_length = 0;			/* Target length for output lines */
static size_t max_length = 0;			/* Maximum length for output lines */
static int coalesce_spaces_P = 0;		/* Coalesce multiple whitespace -> ' ' ? */
static int allow_indented_paragraphs = 0;	/* Can first line have diff. ind.? */
static int tab_width = 8;			/* Number of spaces per tab stop */
static size_t output_tab_width = 0;		/* Ditto, when squashing leading spaces */
static const char *sentence_enders = ".?!";	/* Double-space after these */
static int grok_mail_headers = 0;		/* treat embedded mail headers magically? */
static int format_troff = 0;			/* Format troff? */

static int n_errors = 0;			/* Number of failed files. */
static size_t x;				/* Horizontal position in output line */
static size_t x0;				/* Ditto, ignoring leading whitespace */
static size_t pending_spaces;			/* Spaces to add before next word */
static int output_in_paragraph = 0;		/* Any of current para written out yet? */

/* Prototypes */

static void	process_named_file(const char *);
static void	process_stream(FILE *, const char *);
static size_t	indent_length(const char *);
static int	might_be_header(const char *);
static void	new_paragraph(size_t);
static void	output_word(size_t, size_t, const char *, int, int, int);
static void	output_indent(size_t);
static void	center_stream(FILE *, const char *);
static char	*get_line(FILE *);
static void	*xrealloc(void *, size_t);
void		usage(void);

#define ERRS(x) (x >= 127 ? 127 : ++x)

/* Here is perhaps the right place to mention that this code is
 * all in top-down order. Hence, |main| comes first.
 */
int
main(int argc, char *argv[])
{
	int ch;			/* used for |getopt| processing */

	(void)setlocale(LC_CTYPE, "");

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	/* 1. Grok parameters. */
	while ((ch = getopt(argc, argv, "0123456789cd:hl:mnpst:w:")) != -1) {
		switch (ch) {
		case 'c':
			centerP = 1;
			break;
		case 'd':
			sentence_enders = optarg;
			break;
		case 'l':
			output_tab_width
				= get_positive(optarg, "output tab width must be positive", 1);
			break;
		case 'm':
			grok_mail_headers = 1;
			break;
		case 'n':
			format_troff = 1;
			break;
		case 'p':
			allow_indented_paragraphs = 1;
			break;
		case 's':
			coalesce_spaces_P = 1;
			break;
		case 't':
			tab_width = get_positive(optarg, "tab width must be positive", 1);
			break;
		case 'w':
			goal_length = get_positive(optarg, "width must be positive", 1);
			max_length = goal_length;
			break;
		case '0': case '1': case '2': case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			/* XXX  this is not a stylistically approved use of getopt() */
			if (goal_length == 0) {
				char *p;

				p = argv[optind - 1];
				if (p[0] == '-' && p[1] == ch && !p[2])
					goal_length = get_positive(++p, "width must be nonzero", 1);
				else
					goal_length = get_positive(argv[optind]+1,
							"width must be nonzero", 1);
				max_length = goal_length;
			}
			break;
		case 'h':
		default:
			usage();
			/* NOT REACHED */
		}
	}

	argc -= optind;
	argv += optind;

	/* [ goal [ maximum ] ] */
	if (argc > 0 && goal_length == 0 &&
	    (goal_length = get_positive(*argv,"goal length must be positive", 0)) != 0) {
		--argc;
		++argv;
		if (argc > 0 && (max_length = get_positive(*argv,"max length must be positive", 0)) != 0) {
			--argc;
			++argv;
			if (max_length < goal_length)
				errx(1, "max length must be >= goal length");
		}
	}

	if (goal_length == 0)
		goal_length = 65;
	if (max_length == 0)
		max_length = goal_length+10;

	/* 2. Process files. */

	if (argc > 0) {
		while (argc-- > 0)
			process_named_file(*argv++);
	} else {
		if (pledge("stdio", NULL) == -1)
			err(1, "pledge");
		process_stream(stdin, "standard input");
	}

	/* We're done. */
	return n_errors;

}

/* Process a single file, given its name.
 */
static void
process_named_file(const char *name)
{
	FILE *f;

	if ((f = fopen(name, "r")) == NULL) {
		warn("%s", name);
		ERRS(n_errors);
	} else {
		process_stream(f, name);
		fclose(f);
	}
}

/* Types of mail header continuation lines:
 */
typedef enum {
	hdr_ParagraphStart	= -1,
	hdr_NonHeader		= 0,
	hdr_Header		= 1,
	hdr_Continuation	= 2
} HdrType;

/* Process a stream. This is where the real work happens,
 * except that centering is handled separately.
 */
static void
process_stream(FILE *stream, const char *name)
{
	const char *wordp, *cp;
	wchar_t wc;
	size_t np;
	size_t last_indent = SILLY;	/* how many spaces in last indent? */
	size_t para_line_number = 0;	/* how many lines already read in this para? */
	size_t first_indent = SILLY;	/* indentation of line 0 of paragraph */
	int wcl;			/* number of bytes in wide character */
	int wcw;			/* display width of wide character */
	int word_length;		/* number of bytes in word */
	int word_width;			/* display width of word */
	int space_width;		/* display width of space after word */
	int line_width;			/* display width of line */
	HdrType prev_header_type = hdr_ParagraphStart;
	HdrType header_type;

	/* ^-- header_type of previous line; -1 at para start */
	const char *line;

	if (centerP) {
		center_stream(stream, name);
		return;
	}

	while ((line = get_line(stream)) != NULL) {
		np = indent_length(line);
		header_type = hdr_NonHeader;
		if (grok_mail_headers && prev_header_type != hdr_NonHeader) {
			if (np == 0 && might_be_header(line))
				header_type = hdr_Header;
			else if (np > 0 && prev_header_type>hdr_NonHeader)
				header_type = hdr_Continuation;
		}

		/* We need a new paragraph if and only if:
		 *   this line is blank,
		 *   OR it's a troff request,
		 *   OR it's a mail header,
		 *   OR it's not a mail header AND the last line was one,
		 *   OR the indentation has changed
		 *      AND the line isn't a mail header continuation line
		 *      AND this isn't the second line of an indented paragraph.
		 */
		if (*line == '\0' || (*line == '.' && !format_troff) ||
		    header_type == hdr_Header ||
		    (header_type == hdr_NonHeader && prev_header_type > hdr_NonHeader) ||
		    (np != last_indent && header_type != hdr_Continuation &&
		    (!allow_indented_paragraphs || para_line_number != 1)) ) {
			new_paragraph(np);
			para_line_number = 0;
			first_indent = np;
			last_indent = np;

			/* nroff compatibility */
			if (*line == '.' && !format_troff) {
				puts(line);
				continue;
			}
			if (header_type == hdr_Header)
				last_indent = 2;	/* for cont. lines */
			if (*line == '\0') {
				putchar('\n');
				prev_header_type = hdr_ParagraphStart;
				continue;
			} else {
				/* If this is an indented paragraph other than a mail header
				 * continuation, set |last_indent|.
				 */
				if (np != last_indent && header_type != hdr_Continuation)
					last_indent = np;
			}
			prev_header_type = header_type;
		}

		line_width = np;
		for (wordp = line; *wordp != '\0'; wordp = cp) {
			word_length = 0;
			word_width = space_width = 0;
			for (cp = wordp; *cp != '\0'; cp += wcl) {
				wcl = mbtowc(&wc, cp, MB_CUR_MAX);
				if (wcl == -1) {
					(void)mbtowc(NULL, NULL, MB_CUR_MAX);
					wc = L'?';
					wcl = 1;
					wcw = 1;
				} else if (wc == L'\t')
					wcw = (line_width / tab_width + 1) *
					    tab_width - line_width;
				else if ((wcw = wcwidth(wc)) == -1)
					wcw = 1;
				if (iswblank(wc) && wc != 0xa0) {
					/* Skip whitespace at start of line. */
					if (word_length == 0) {
						wordp += wcl;
						continue;
					}
					/* Count whitespace after word. */
					space_width += wcw;
				} else {
					/* Detect end of word. */
					if (space_width > 0)
						break;
					/* Measure word. */
					word_length += wcl;
					word_width += wcw;
				}
				line_width += wcw;
			}

			/* Send the word to the output machinery. */
			output_word(first_indent, last_indent, wordp,
			    word_length, word_width, space_width);
		}
		++para_line_number;
	}

	new_paragraph(0);
	if (ferror(stream)) {
		warn("%s", name);
		ERRS(n_errors);
	}
}

/* How long is the indent on this line?
 */
static size_t
indent_length(const char *line)
{
	size_t n = 0;

	for (;;) {
		switch(*line++) {
		case ' ':
			++n;
			continue;
		case '\t':
			n = (n / tab_width + 1) * tab_width;
			continue;
		default:
			break;
		}
		break;
	}
	return n;
}

/* Might this line be a mail header?
 * We deem a line to be a possible header if it matches the
 * Perl regexp /^[A-Z][-A-Za-z0-9]*:\s/. This is *not* the same
 * as in RFC whatever-number-it-is; we want to be gratuitously
 * conservative to avoid mangling ordinary civilised text.
 */
static int
might_be_header(const char *line)
{

	if (!isupper((unsigned char)*line++))
		return 0;
	while (isalnum((unsigned char)*line) || *line == '-')
		++line;
	return (*line == ':' && isspace((unsigned char)line[1]));
}

/* Begin a new paragraph with an indent of |indent| spaces.
 */
static void
new_paragraph(size_t indent)
{

	if (x0 > 0)
		putchar('\n');
	x = indent;
	x0 = 0;
	pending_spaces = 0;
	output_in_paragraph = 0;
}

/* Output spaces or tabs for leading indentation.
 */
static void
output_indent(size_t n_spaces)
{

	if (n_spaces == 0)
		return;
	if (output_tab_width) {
		while (n_spaces >= output_tab_width) {
			putchar('\t');
			n_spaces -= output_tab_width;
		}
	}
	while (n_spaces-- > 0)
		putchar(' ');
}

/* Output a single word.
 * indent0 and indent1 are the indents to use on the first and subsequent
 * lines of a paragraph. They'll often be the same, of course.
 */
static void
output_word(size_t indent0, size_t indent1, const char *word,
    int length, int width, int spaces)
{
	size_t new_x = x + pending_spaces + width;

	/* If either |spaces==0| (at end of line) or |coalesce_spaces_P|
	 * (squashing internal whitespace), then add just one space;
	 * except that if the last character was a sentence-ender we
	 * actually add two spaces.
	 */
	if (coalesce_spaces_P || spaces == 0)
		spaces = strchr(sentence_enders, word[length-1]) ? 2 : 1;

	if (x0 == 0)
		output_indent(output_in_paragraph ? indent1 : indent0);
	else if (new_x > max_length || x >= goal_length ||
	    (new_x > goal_length && new_x-goal_length > goal_length-x)) {
		putchar('\n');
		output_indent(indent1);
		x0 = 0;
		x = indent1;
	} else {
		x0 += pending_spaces;
		x += pending_spaces;
		while (pending_spaces--)
			putchar(' ');
	}
	x0 += width;
	x += width;
	while(length--)
		putchar(*word++);
	pending_spaces = spaces;
	output_in_paragraph = 1;
}

/* Process a stream, but just center its lines rather than trying to
 * format them neatly.
 */
static void
center_stream(FILE *stream, const char *name)
{
	char *line, *cp;
	wchar_t wc;
	size_t l;	/* Display width of the line. */
	int wcw;	/* Display width of one character. */
	int wcl;	/* Length in bytes of one character. */

	while ((line = get_line(stream)) != NULL) {
		l = 0;
		for (cp = line; *cp != '\0'; cp += wcl) {
			if (*cp == '\t')
				*cp = ' ';
			if ((wcl = mbtowc(&wc, cp, MB_CUR_MAX)) == -1) {
				(void)mbtowc(NULL, NULL, MB_CUR_MAX);
				*cp = '?';
				wcl = 1;
				wcw = 1;
			} else if ((wcw = wcwidth(wc)) == -1)
				wcw = 1;
			if (l == 0 && iswspace(wc))
				line += wcl;
			else
				l += wcw;
		}
		while (l < goal_length) {
			putchar(' ');
			l += 2;
		}
		puts(line);
	}

	if (ferror(stream)) {
		warn("%s", name);
		ERRS(n_errors);
	}
}

/* Get a single line from a stream.  Strip control
 * characters and trailing whitespace, and handle backspaces.
 * Return the address of the buffer containing the line.
 * This can cope with arbitrarily long lines, and with lines
 * without terminating \n.
 * If there are no characters left or an error happens, we
 * return NULL.
 */
static char *
get_line(FILE *stream)
{
	int ch;
	int troff = 0;
	static char *buf = NULL;
	static size_t length = 0;
	size_t len = 0;

	if (buf == NULL) {
		length = 100;
		buf = xrealloc(NULL, length);
	}

	while ((ch = getc(stream)) != '\n' && ch != EOF) {
		if ((len == 0) && (ch == '.' && !format_troff))
			troff = 1;
		if (troff || ch == '\t' || !iscntrl(ch)) {
			if (len >= length) {
				length *= 2;
				buf = xrealloc(buf, length);
			}
			buf[len++] = ch;
		} else if (ch == '\b') {
			if (len)
				--len;
		}
	}
	while (len > 0 && isspace((unsigned char)buf[len-1]))
		--len;
	buf[len] = '\0';
	return (len > 0 || ch != EOF) ? buf : NULL;
}

/* (Re)allocate some memory, exiting with an error if we can't.
 */
static void *
xrealloc(void *ptr, size_t nbytes)
{
	void *p;

	p  = realloc(ptr, nbytes);
	if (p == NULL)
		errx(1, "out of memory");
	return p;
}

void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
		"usage: %s [-cmnps] [-d chars] [-l number] [-t number]\n"
		"\t[goal [maximum] | -width | -w width] [file ...]\n",
			__progname);
	exit (1);
}
@


1.37
log
@Do not break the line at U+00A0 NO-BREAK SPACE.
Bug pointed out by Eric dot Pruitt at gmail dot com on misc@@.
OK millert@@ bentley@@
@
text
@d1 52
a52 1
/*	$OpenBSD: fmt.c,v 1.36 2016/01/07 18:02:43 schwarze Exp $	*/
a174 45
 */

/* Copyright (c) 1997 Gareth McCaughan. All rights reserved.
 *
 * Redistribution and use of this code, in source or binary forms,
 * with or without modification, are permitted subject to the following
 * conditions:
 *
 *  - Redistribution of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *  - If you distribute modified source code it must also include
 *    a notice saying that it has been modified, and giving a brief
 *    description of what changes have been made.
 *
 * Disclaimer: I am not responsible for the results of using this code.
 *             If it formats your hard disc, sends obscene messages to
 *             your boss and kills your children then that's your problem
 *             not mine. I give absolutely no warranty of any sort as to
 *             what the program will do, and absolutely refuse to be held
 *             liable for any consequences of your using it.
 *             Thank you. Have a nice day.
 */

/* RCS change log:
 * Revision 1.5  1998/03/02 18:02:21  gjm11
 * Minor changes for portability.
 *
 * Revision 1.4  1997/10/01 11:51:28  gjm11
 * Repair broken indented-paragraph handling.
 * Add mail message header stuff.
 * Improve comments and layout.
 * Make usable with non-BSD systems.
 * Add revision display to usage message.
 *
 * Revision 1.3  1997/09/30 16:24:47  gjm11
 * Add copyright notice, rcsid string and log message.
 *
 * Revision 1.2  1997/09/30 16:13:39  gjm11
 * Add options: -d <chars>, -l <width>, -p, -s, -t <width>, -h .
 * Parse options with `getopt'. Clean up code generally.
 * Make comments more accurate.
 *
 * Revision 1.1  1997/09/30 11:29:57  gjm11
 * Initial revision
@


1.36
log
@UTF-8 support for fmt -c.

This implies two small changes in behaviour:
1. Let fmt -c replace invalid bytes with ASCII question marks
just like when called without -c.
2. On lines to be centered, replace each tab with a single blank,
simply because there is no useful way to define the meaning of a
tab on such a line.  Having the width of a tab depend on what is
to the right of it would be completely crazy (and complicate the
code a lot), and otherwise, tabs on adjacent lines of different
length wouldn't align anyway.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.35 2015/12/31 16:10:31 millert Exp $	*/
d471 1
a471 1
				if (iswblank(wc)) {
@


1.35
log
@Remove use of sysexits.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.34 2015/12/15 16:26:17 schwarze Exp $	*/
d622 5
a626 2
	char *line;
	size_t l;
d629 16
a644 3
		while (isspace((unsigned char)*line))
			++line;
		l = strlen(line);
@


1.34
log
@UTF-8 support; does not yet handle the -c option.
No longer expand tabs up front in get_line(), their width depends on the
width of characters earlier on the line.  Always NUL-terminate the input
buffer for easier and safer handling.  Get rid of the hand-rolled output
buffer, just let stdio do its work.
OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.33 2015/10/09 01:37:07 deraadt Exp $	*/
a176 1
#include <sysexits.h>
d206 1
a206 1
		errx(EX_USAGE, "%s", err_mess);
d326 1
a326 1
				errx(EX_USAGE, "max length must be >= goal length");
d693 1
a693 1
		errx(EX_OSERR, "out of memory");
@


1.33
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.32 2015/10/05 06:21:15 deraadt Exp $	*/
d179 2
a226 1
static char *output_buffer = NULL;		/* Output line will be built here */
d236 1
a236 1
static size_t	indent_length(const char *, size_t);
d238 2
a239 2
static void	new_paragraph(size_t, size_t);
static void	output_word(size_t, size_t, const char *, size_t, size_t);
d242 1
a242 1
static char	*get_line(FILE *, size_t *);
a245 1
#define XMALLOC(x) xrealloc(0, x)
a334 1
	output_buffer = XMALLOC(max_length+1);	/* really needn't be longer */
d383 2
a384 1
	size_t n;
d389 6
a399 1
	size_t length;
d406 2
a407 2
	while ((line = get_line(stream, &length)) != NULL) {
		np = indent_length(line, length);
d425 1
a425 1
		if (length == 0 || (line[0] == '.' && !format_troff) ||
d430 1
a430 1
			new_paragraph(output_in_paragraph ? last_indent : first_indent, np);
d436 2
a437 2
			if (length > 0 && line[0] == '.' && !format_troff) {
				printf("%.*s\n", (int)length, line);
d442 1
a442 1
			if (length == 0) {
d456 35
a490 9
		n = np;
		while (n < length) {
			/* Find word end and count spaces after it */
			size_t word_length = 0, space_length = 0;
			while (n+word_length < length && line[n+word_length] != ' ')
				++word_length;
			space_length = word_length;
			while (n+space_length < length && line[n+space_length] == ' ')
				++space_length;
d492 2
a493 3
			output_word(first_indent, last_indent,
				line+n, word_length, space_length-word_length);
			n += space_length;
d498 1
a498 1
	new_paragraph(output_in_paragraph ? last_indent : first_indent, 0);
d508 1
a508 1
indent_length(const char *line, size_t length)
d512 13
a524 2
	while (n < length && *line++ == ' ')
		++n;
d548 1
a548 1
new_paragraph(size_t old_indent, size_t indent)
d551 1
a551 4
	if (x0) {
		if (old_indent > 0)
			output_indent(old_indent);
		fwrite(output_buffer, 1, x0, stdout);
a552 1
	}
d565 2
d577 1
a577 1
/* Output a single word, or add it to the buffer.
d582 2
a583 1
output_word(size_t indent0, size_t indent1, const char *word, size_t length, size_t spaces)
d585 1
a585 2
	size_t new_x = x + pending_spaces + length;
	size_t indent = output_in_paragraph ? indent1 : indent0;
d595 9
a603 5
	if (new_x <= goal_length) {
		/* After adding the word we still aren't at the goal length,
		 * so clearly we add it to the buffer rather than outputing it.
		 */
		memset(output_buffer+x0, ' ', pending_spaces);
d606 2
a607 40
		memcpy(output_buffer+x0, word, length);
		x0 += length;
		x += length;
		pending_spaces = spaces;
	} else {
		/* Adding the word takes us past the goal. Print the line-so-far,
		 * and the word too iff either (1) the lsf is empty or (2) that
		 * makes us nearer the goal but doesn't take us over the limit,
		 * or (3) the word on its own takes us over the limit.
		 * In case (3) we put a newline in between.
		 */
		if (indent > 0)
			output_indent(indent);
		fwrite(output_buffer, 1, x0, stdout);
		if (x0 == 0 || (new_x <= max_length && new_x-goal_length <= goal_length-x)) {
			printf("%*s", (int)pending_spaces, "");
			goto write_out_word;
		} else {
			/* If the word takes us over the limit on its own, just
			 * spit it out and don't bother buffering it.
			 */
			if (indent+length > max_length) {
				putchar('\n');
				if (indent > 0)
					output_indent(indent);
write_out_word:
				fwrite(word, 1, length, stdout);
				x0 = 0;
				x = indent1;
				pending_spaces = 0;
			} else {
				memcpy(output_buffer, word, length);
				x0 = length;
				x = length+indent1;
				pending_spaces = spaces;
			}
		}

		putchar('\n');
		output_in_paragraph = 1;
d609 6
a623 1
	size_t length;
d626 2
a627 3
	while ((line = get_line(stream, &length)) != 0) {
		l = length;
		while (l > 0 && isspace(*line)) {
d629 1
a629 5
			--l;
		}

		length = l;

d634 1
a634 3

		fwrite(line, 1, length, stdout);
		putchar('\n');
d643 1
a643 1
/* Get a single line from a stream. Expand tabs, strip control
d645 1
a645 2
 * Return the address of the buffer containing the line, and
 * put the length of the line in |lengthp|.
d649 1
a649 3
 * return 0.
 * Don't confuse |spaces_pending| here with the global
 * |pending_spaces|.
d652 1
a652 1
get_line(FILE *stream, size_t *lengthp)
a658 1
	size_t spaces_pending = 0;
d662 1
a662 1
		buf = XMALLOC(length);
d666 1
a666 1
		if ((len + spaces_pending == 0) && (ch == '.' && !format_troff))
d668 2
a669 4
		if (ch == ' ') {
			++spaces_pending;
		} else if (troff || !iscntrl(ch)) {
			while (len + spaces_pending >= length) {
a672 5

			while (spaces_pending > 0) {
				--spaces_pending;
				buf[len++] = ' ';
			}
a673 2
		} else if (ch == '\t') {
			spaces_pending += tab_width - (len+spaces_pending)%tab_width;
d679 4
a682 3

	*lengthp = len;
	return (len > 0 || ch != EOF) ? buf : 0;
@


1.32
log
@use the normal -1 check for tame failure
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.31 2015/10/05 06:17:05 deraadt Exp $	*/
d258 2
a259 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d343 2
a344 2
		if (tame("stdio", NULL) == -1)
			err(1, "tame");
@


1.31
log
@tame "stdio rpath" is enough for the general case, which opens file
after file from argv.  If it is discovered to be reading from stdin only,
go to tame "stdio"
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.30 2013/11/26 13:18:55 deraadt Exp $	*/
d343 1
a343 1
		if (tame("stdio", NULL) != 0)
@


1.30
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.29 2012/01/17 04:26:28 lum Exp $	*/
d258 3
d343 2
@


1.29
log
@Change the exit value on errors to be more 4.4BSD like. Use the sum of
errors up to a maximum of 127, then to do not increment anymore,
though programme execution continues.

Use 127 as a maximum because error codes above this are:

1. bad because of signed bugs in programs.
2. used as the traditional shell $? representation of "kill by signal"
   where $? = 128 + signal.

(from deraadt@@ and guenther@@ respectively)
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.28 2012/01/15 11:43:45 schwarze Exp $	*/
d236 1
a236 1
static int	might_be_header(const unsigned char *);
d388 1
a388 1
	char *line;
d489 1
a489 1
might_be_header(const unsigned char *line)
d492 1
a492 1
	if (!isupper(*line++))
d494 1
a494 1
	while (isalnum(*line) || *line == '-')
d496 1
a496 1
	return (*line == ':' && isspace(line[1]));
@


1.28
log
@Document the EXIT STATUS and remove an outdated related comment.

While here,
* as usual, the "first appeared" clause requires fixing, and
* mention the date of the original implementation,
using information from the CSRG archive CD 1.

Triggered by a question asked by lum@@, feedback and ok jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.27 2009/10/27 23:59:38 deraadt Exp $	*/
d246 1
d344 1
a344 1
	return n_errors ? EX_NOINPUT : 0;
d357 1
a357 1
		++n_errors;
d466 1
a466 1
		++n_errors;
d631 1
a631 1
		++n_errors;
@


1.27
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.26 2007/03/20 03:50:39 tedu Exp $	*/
d224 1
a224 1
static int n_errors = 0;			/* Number of failed files. Return on exit. */
@


1.26
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.25 2006/11/29 21:59:04 jmc Exp $	*/
a169 7

#ifndef lint
static const char rcsid[] =
  "$OpenBSD: fmt.c,v 1.25 2006/11/29 21:59:04 jmc Exp $";
static const char copyright[] =
  "Copyright (c) 1997 Gareth McCaughan. All rights reserved.\n";
#endif /* not lint */
@


1.25
log
@trim usage(); ok millert deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.24 2006/11/29 20:09:27 jmc Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.24 2006/11/29 20:09:27 jmc Exp $";
d500 1
a500 1
	while (*line && (isalnum(*line) || *line == '-'))
@


1.24
log
@- sync synopsis and usage()
- sort options
- avoid line split
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.23 2005/03/08 23:34:43 cloder Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.23 2005/03/08 23:34:43 cloder Exp $";
d714 3
a716 12
		"Usage:   %s [-cmnps] [-d chars] [-l number] [-t number]\n"
		"             [goal [maximum] | -width | -w width] [file ...]\n"
		"Options: -c     center each line instead of formatting\n"
		"         -d <chars> double-space after <chars> at line end\n"
		"         -l <n> turn each <n> spaces at start of line into a tab\n"
		"         -m     try to make sure mail header lines stay separate\n"
		"         -n     format lines beginning with a dot\n"
		"         -p     allow indented paragraphs\n"
		"         -s     coalesce whitespace inside lines\n"
		"         -t <n> have tabs every <n> columns\n"
		"         -w <n> set maximum width to <n>\n"
		"         goal   set target width to goal\n", __progname);
@


1.23
log
@weeping the tree for printf(s) where printf("%s",s) should be used.
This is a regression introduced during conversion from perror(3) to err(3)
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.22 2004/06/29 16:59:46 mickey Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.22 2004/06/29 16:59:46 mickey Exp $";
d714 2
a715 2
		"Usage:   %s [-cmps] [-d chars] [-l num] [-t num]\n"
		"             [-w width | -width | goal [maximum]] [file ...]\n"
@


1.22
log
@use warn() instead of perror; err*() are used already
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.21 2004/04/01 23:14:19 tedu Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.21 2004/04/01 23:14:19 tedu Exp $";
d362 1
a362 1
		warn(name);
d471 1
a471 1
		warn(name);
d636 1
a636 1
		warn(name);
@


1.21
log
@knf and ansi, mostly from joris vink
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.20 2003/12/01 15:34:26 grange Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.20 2003/12/01 15:34:26 grange Exp $";
d362 1
a362 1
		perror(name);
d471 1
a471 1
		perror(name);
d636 1
a636 1
		perror(name);
d711 1
d714 1
a714 1
		"Usage:   fmt [-cmps] [-d chars] [-l num] [-t num]\n"
d725 2
a726 2
		"         goal   set target width to goal\n");
	exit (0);
a727 1

@


1.20
log
@Format string fixes from art's amd64 tree.
ok rohee@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.19 2001/11/29 00:33:06 millert Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.19 2001/11/29 00:33:06 millert Exp $";
d199 17
a215 6
get_positive(const char *s, const char *err_mess, int fussyP) {
  char *t;
  long result = strtol(s,&t,0);
  if (*t) { if (fussyP) goto Lose; else return 0; }
  if (result<=0) { Lose: errx(EX_USAGE, "%s", err_mess); }
  return (size_t) result;
d220 17
a236 17
static int centerP=0;		/* Try to center lines? */
static size_t goal_length=0;	/* Target length for output lines */
static size_t max_length=0;	/* Maximum length for output lines */
static int coalesce_spaces_P=0;	/* Coalesce multiple whitespace -> ' ' ? */
static int allow_indented_paragraphs=0;	/* Can first line have diff. ind.? */
static int tab_width=8;		/* Number of spaces per tab stop */
static size_t output_tab_width=0;	/* Ditto, when squashing leading spaces */
static const char *sentence_enders=".?!";	/* Double-space after these */
static int grok_mail_headers=0;	/* treat embedded mail headers magically? */
static int format_troff=0;	/* Format troff? */

static int n_errors=0;		/* Number of failed files. Return on exit. */
static char *output_buffer=0;	/* Output line will be built here */
static size_t x;		/* Horizontal position in output line */
static size_t x0;		/* Ditto, ignoring leading whitespace */
static size_t pending_spaces;	/* Spaces to add before next word */
static int output_in_paragraph=0;	/* Any of current para written out yet? */
d240 11
a250 10
static void process_named_file(const char *);
static void     process_stream(FILE *, const char *);
static size_t    indent_length(const char *, size_t);
static int     might_be_header(const unsigned char *);
static void      new_paragraph(size_t, size_t);
static void        output_word(size_t, size_t, const char *, size_t, size_t);
static void      output_indent(size_t);
static void      center_stream(FILE *, const char *);
static char *         get_line(FILE *, size_t *);
static void *         xrealloc(void *, size_t);
d252 1
a252 1
#define XMALLOC(x) xrealloc(0,x)
d258 90
a347 99
main(int argc, char *argv[]) {
  int ch;			/* used for |getopt| processing */


  (void)setlocale(LC_CTYPE, "");

  /* 1. Grok parameters. */

  while ((ch = getopt(argc, argv, "0123456789cd:hl:mnpst:w:")) != -1)
  switch(ch) {
    case 'c':
      centerP = 1;
      continue;
    case 'd':
      sentence_enders = optarg;
      continue;
    case 'l':
      output_tab_width
        = get_positive(optarg, "output tab width must be positive", 1);
      continue;
    case 'm':
      grok_mail_headers = 1;
      continue;
    case 'n':
      format_troff = 1;
      continue;
    case 'p':
      allow_indented_paragraphs = 1;
      continue;
    case 's':
      coalesce_spaces_P = 1;
      continue;
    case 't':
      tab_width = get_positive(optarg, "tab width must be positive", 1);
      continue;
    case 'w':
      goal_length = get_positive(optarg, "width must be positive", 1);
      max_length = goal_length;
      continue;
    case '0': case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9':
    /* XXX  this is not a stylistically approved use of getopt() */
      if (goal_length==0) {
        char *p;
        p = argv[optind - 1];
        if (p[0] == '-' && p[1] == ch && !p[2])
             goal_length = get_positive(++p, "width must be nonzero", 1);
        else
             goal_length = get_positive(argv[optind]+1,
                 "width must be nonzero", 1);
        max_length = goal_length;
      }
      continue;
    case 'h': default:
      fprintf(stderr,
"Usage:   fmt [-cmps] [-d chars] [-l num] [-t num]\n"
"             [-w width | -width | goal [maximum]] [file ...]\n"
"Options: -c     center each line instead of formatting\n"
"         -d <chars> double-space after <chars> at line end\n"
"         -l <n> turn each <n> spaces at start of line into a tab\n"
"         -m     try to make sure mail header lines stay separate\n"
"         -n     format lines beginning with a dot\n"
"         -p     allow indented paragraphs\n"
"         -s     coalesce whitespace inside lines\n"
"         -t <n> have tabs every <n> columns\n"
"         -w <n> set maximum width to <n>\n"
"         goal   set target width to goal\n");
      exit(ch=='h' ? 0 : EX_USAGE);
  }
  argc -= optind; argv += optind;

  /* [ goal [ maximum ] ] */

  if (argc>0 && goal_length==0
      && (goal_length=get_positive(*argv,"goal length must be positive", 0))
         != 0) {
    --argc; ++argv;
    if (argc>0
        && (max_length=get_positive(*argv,"max length must be positive", 0))
           != 0) {
      --argc; ++argv;
      if (max_length<goal_length)
        errx(EX_USAGE, "max length must be >= goal length");
    }
  }
  if (goal_length==0) goal_length = 65;
  if (max_length==0) max_length = goal_length+10;
  output_buffer = XMALLOC(max_length+1);	/* really needn't be longer */

  /* 2. Process files. */

  if (argc>0) {
    while (argc-->0) process_named_file(*argv++);
  }
  else {
    process_stream(stdin, "standard input");
  }

  /* We're done. */
d349 2
a350 1
  return n_errors ? EX_NOINPUT : 0;
d357 11
a367 7
process_named_file(const char *name) {
  FILE *f=fopen(name, "r");
  if (!f) { perror(name); ++n_errors; }
  else {
    process_stream(f, name);
    fclose(f);
  }
d373 4
a376 4
  hdr_ParagraphStart = -1,
  hdr_NonHeader      = 0,
  hdr_Header         = 1,
  hdr_Continuation   = 2
d383 10
a392 5
process_stream(FILE *stream, const char *name) {
  size_t last_indent=SILLY;	/* how many spaces in last indent? */
  size_t para_line_number=0;	/* how many lines already read in this para? */
  size_t first_indent=SILLY;	/* indentation of line 0 of paragraph */
  HdrType prev_header_type=hdr_ParagraphStart;
d394 2
a395 2
  char *line;
  size_t length;
d397 77
a473 71
  if (centerP) { center_stream(stream, name); return; }
  while ((line=get_line(stream,&length)) != NULL) {
    size_t np=indent_length(line, length);
    { HdrType header_type=hdr_NonHeader;
      if (grok_mail_headers && prev_header_type!=hdr_NonHeader) {
        if (np==0 && might_be_header(line))
          header_type = hdr_Header;
        else if (np>0 && prev_header_type>hdr_NonHeader)
          header_type = hdr_Continuation;
      }
      /* We need a new paragraph if and only if:
       *   this line is blank,
       *   OR it's a troff request,
       *   OR it's a mail header,
       *   OR it's not a mail header AND the last line was one,
       *   OR the indentation has changed
       *      AND the line isn't a mail header continuation line
       *      AND this isn't the second line of an indented paragraph.
       */
      if ( length==0
           || (line[0]=='.' && !format_troff)
           || header_type==hdr_Header
           || (header_type==hdr_NonHeader && prev_header_type>hdr_NonHeader)
           || (np!=last_indent
               && header_type != hdr_Continuation
               && (!allow_indented_paragraphs || para_line_number != 1)) ) {
        new_paragraph(output_in_paragraph ? last_indent : first_indent, np);
        para_line_number = 0;
        first_indent = np;
        last_indent = np;
        /* nroff compatibility */
        if (length>0 && line[0]=='.' && !format_troff) {
          printf("%.*s\n", (int)length, line);
          continue;
        }
        if (header_type==hdr_Header) last_indent=2;	/* for cont. lines */
        if (length==0) {
          putchar('\n');
          prev_header_type=hdr_ParagraphStart;
          continue;
        }
      }
      else {
        /* If this is an indented paragraph other than a mail header
         * continuation, set |last_indent|.
         */
        if (np != last_indent && header_type != hdr_Continuation)
          last_indent=np;
      }
      prev_header_type = header_type;
    }

    { size_t n=np;
      while (n<length) {
        /* Find word end and count spaces after it */
        size_t word_length=0, space_length=0;
        while (n+word_length < length && line[n+word_length] != ' ')
          ++word_length;
        space_length = word_length;
        while (n+space_length < length && line[n+space_length] == ' ')
          ++space_length;
        /* Send the word to the output machinery. */
        output_word(first_indent, last_indent,
                    line+n, word_length, space_length-word_length);
        n += space_length;
      }
    }
    ++para_line_number;
  }
  new_paragraph(output_in_paragraph ? last_indent : first_indent, 0);
  if (ferror(stream)) { perror(name); ++n_errors; }
d479 7
a485 4
indent_length(const char *line, size_t length) {
  size_t n=0;
  while (n<length && *line++ == ' ') ++n;
  return n;
d495 8
a502 4
might_be_header(const unsigned char *line) {
  if (!isupper(*line++)) return 0;
  while (*line && (isalnum(*line) || *line=='-')) ++line;
  return (*line==':' && isspace(line[1]));
d508 13
a520 8
new_paragraph(size_t old_indent, size_t indent) {
  if (x0) {
    if (old_indent>0) output_indent(old_indent);
    fwrite(output_buffer, 1, x0, stdout);
    putchar('\n');
  }
  x=indent; x0=0; pending_spaces=0;
  output_in_paragraph = 0;
d526 11
a536 8
output_indent(size_t n_spaces) {
  if (output_tab_width) {
    while (n_spaces >= output_tab_width) {
      putchar('\t');
      n_spaces -= output_tab_width;
    }
  }
  while (n_spaces-- > 0) putchar(' ');
d544 45
a588 42
output_word(size_t indent0, size_t indent1, const char *word, size_t length, size_t spaces) {
  size_t new_x = x+pending_spaces+length;
  size_t indent = output_in_paragraph ? indent1 : indent0;

  /* If either |spaces==0| (at end of line) or |coalesce_spaces_P|
   * (squashing internal whitespace), then add just one space;
   * except that if the last character was a sentence-ender we
   * actually add two spaces.
   */
  if (coalesce_spaces_P || spaces==0)
    spaces = strchr(sentence_enders, word[length-1]) ? 2 : 1;

  if (new_x<=goal_length) {
    /* After adding the word we still aren't at the goal length,
     * so clearly we add it to the buffer rather than outputing it.
     */
    memset(output_buffer+x0, ' ', pending_spaces);
    x0 += pending_spaces; x += pending_spaces;
    memcpy(output_buffer+x0, word, length);
    x0 += length; x += length;
    pending_spaces = spaces;
  }
  else {
    /* Adding the word takes us past the goal. Print the line-so-far,
     * and the word too iff either (1) the lsf is empty or (2) that
     * makes us nearer the goal but doesn't take us over the limit,
     * or (3) the word on its own takes us over the limit.
     * In case (3) we put a newline in between.
     */
    if (indent>0) output_indent(indent);
    fwrite(output_buffer, 1, x0, stdout);
    if (x0==0 || (new_x <= max_length && new_x-goal_length <= goal_length-x)) {
      printf("%*s", (int)pending_spaces, "");
      goto write_out_word;
    }
    else {
      /* If the word takes us over the limit on its own, just
       * spit it out and don't bother buffering it.
       */
      if (indent+length > max_length) {
        putchar('\n');
        if (indent>0) output_indent(indent);
d590 15
a604 11
        fwrite(word, 1, length, stdout);
        x0 = 0; x = indent1; pending_spaces = 0;
      }
      else {
        memcpy(output_buffer, word, length);
        x0 = length; x = length+indent1; pending_spaces = spaces;
      }
    }
    putchar('\n');
    output_in_paragraph = 1;
  }
d611 28
a638 12
center_stream(FILE *stream, const char *name) {
  char *line;
  size_t length;
  while ((line=get_line(stream, &length)) != 0) {
    size_t l=length;
    while (l>0 && isspace(*line)) { ++line; --l; }
    length=l;
    while (l<goal_length) { putchar(' '); l+=2; }
    fwrite(line, 1, length, stdout);
    putchar('\n');
  }
  if (ferror(stream)) { perror(name); ++n_errors; }
d653 40
a692 25
get_line(FILE *stream, size_t *lengthp) {
  static char *buf=NULL;
  static size_t length=0;
  size_t len=0;
  int ch;
  size_t spaces_pending=0;
  int troff=0;

  if (buf==NULL) { length=100; buf=XMALLOC(length); }
  while ((ch=getc(stream)) != '\n' && ch != EOF) {
    if (len+spaces_pending==0 && ch=='.' && !format_troff) troff=1;
    if (ch==' ') ++spaces_pending;
    else if (troff || !iscntrl(ch)) {
      while (len+spaces_pending >= length) {
        length*=2; buf=xrealloc(buf, length);
      }
      while (spaces_pending > 0) { --spaces_pending; buf[len++]=' '; }
      buf[len++] = ch;
    }
    else if (ch=='\t')
      spaces_pending += tab_width - (len+spaces_pending)%tab_width;
    else if (ch=='\b') { if (len) --len; }
  }
  *lengthp=len;
  return (len>0 || ch!=EOF) ? buf : 0;
d698 28
a725 4
xrealloc(void *ptr, size_t nbytes) {
  void *p = realloc(ptr, nbytes);
  if (p == NULL) errx(EX_OSERR, "out of memory");
  return p;
d727 1
@


1.19
log
@Restore historic behavior:
 o don't fmt lines that start with '.' to avoid hosing *roff
 o add -n flag to disable above behavior (undocumented feature in old fmt)
Patch from Ruslan Ermilov (FreeBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.18 2001/11/28 22:01:42 millert Exp $	*/
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.18 2001/11/28 22:01:42 millert Exp $";
d203 1
a203 1
  if (result<=0) { Lose: errx(EX_USAGE, err_mess); }
@


1.18
log
@from FreeBSD:
Some KNF
Call setlocale()
Remove some silliness for non-BSD systems
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.17 2001/07/12 05:17:05 deraadt Exp $	*/
d33 2
d173 1
a173 1
  "$OpenBSD: fmt.c,v 1.17 2001/07/12 05:17:05 deraadt Exp $";
d218 1
d254 1
a254 1
  while ((ch = getopt(argc, argv, "0123456789cd:hl:mpst:w:")) != -1)
d269 3
d307 1
d396 1
d404 1
d414 5
d602 1
d606 1
d608 1
a608 1
    else if (!iscntrl(ch)) {
@


1.17
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.16 2000/06/25 15:35:42 pjanzen Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.16 2000/06/25 15:35:42 pjanzen Exp $";
a175 32
/* Cater for BSD and non-BSD systems.
 * I hate the C preprocessor.
 */

#undef HAVE_errx
#undef HAVE_sysexits

#ifdef unix
# include <sys/param.h>
# ifdef BSD
#  define HAVE_errx
#  if BSD >= 199306
#   define HAVE_sysexits
#  endif
# endif
#endif

#ifdef HAVE_errx
# include <err.h>
#else
# define errx(rc,str) { fprintf(stderr,"fmt: %s\n",str); exit(rc); }
#endif

#ifdef HAVE_sysexits
# include <sysexits.h>
#else
# define EX_USAGE 1
# define EX_NOINPUT 1
# define EX_SOFTWARE 1
# define EX_OSERR 1
#endif

d177 2
d182 2
a183 4

#ifdef NEED_getopt_h
# include "getopt.h"
#endif
d196 2
a197 1
size_t get_positive(const char *s, const char *err_mess, int fussyP) {
a204 8
/* Just for the sake of linguistic purity: */

#ifdef BRITISH
# define CENTER "centre"
#else
# define CENTER "center"
#endif

d213 2
a214 2
static int output_tab_width=0;	/* Ditto, when squashing leading spaces */
static char *sentence_enders=".?!";	/* Double-space after these */
d226 10
a235 10
static void process_named_file (const char *);
static void     process_stream (FILE *, const char *);
static size_t    indent_length (const char *, size_t);
static int     might_be_header (const char *);
static void      new_paragraph (size_t, size_t);
static void        output_word (size_t, size_t, const char *, size_t, size_t);
static void      output_indent (size_t);
static void      center_stream (FILE *, const char *);
static char *         get_line (FILE *, size_t *);
static void *         xrealloc (void *, size_t);
d246 3
d257 1
a257 2
      sentence_enders = XMALLOC(strlen(optarg)+1);
      strcpy(sentence_enders, optarg);	/* ok */
d297 1
a297 1
"Options: -c     " CENTER " each line instead of formatting\n"
d459 1
a459 1
might_be_header(const char *line) {
@


1.16
log
@allow 'fmt -w width' and 'fmt -width'.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.15 1999/12/30 18:00:42 provos Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.15 1999/12/30 18:00:42 provos Exp $";
d565 1
a565 1
      printf("%*s", pending_spaces, "");
@


1.15
log
@dont strip off international characters; fixes pr/1020
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.14 1999/12/15 05:34:33 deraadt Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.14 1999/12/15 05:34:33 deraadt Exp $";
d287 2
a288 1
  while ((ch = getopt(argc, argv, "cd:hl:mpst:")) != -1) switch(ch) {
d312 18
d332 2
a333 1
"Usage:   fmt [-cmps] [-d chars] [-l num] [-t num] [goal [maximum]] [file...]\n"
d340 3
a342 1
"         -t <n> have tabs every <n> columns\n");
d349 1
a349 1
  if (argc>0
@


1.14
log
@safe strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.13 1998/12/14 21:50:32 millert Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.13 1998/12/14 21:50:32 millert Exp $";
d607 1
a607 1
    else if (isprint(ch)) {
@


1.13
log
@adjust argv and argc correctly when reading max from command line
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.12 1998/12/14 21:48:10 millert Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.12 1998/12/14 21:48:10 millert Exp $";
d293 1
a293 1
      strcpy(sentence_enders, optarg);
@


1.12
log
@pasto that caused goal and max params not to work
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.11 1998/04/25 23:07:16 millert Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.11 1998/04/25 23:07:16 millert Exp $";
d334 1
@


1.11
log
@getopt(3) returns -1 on end of args, not EOF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.10 1998/04/25 23:02:28 millert Exp $	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.10 1998/04/25 23:02:28 millert Exp $";
d332 1
a332 1
        && (goal_length=get_positive(*argv,"max length must be positive", 0))
@


1.10
log
@fmt(1) rewrite by Gareth McCaughan.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d171 1
a171 1
  "$OpenBSD: fmt.c,v 1.5 1998/03/02 18:02:21 gjm11 Exp $";
d287 1
a287 1
  while ((ch = getopt(argc, argv, "cd:hl:mpst:")) != EOF) switch(ch) {
@


1.9
log
@use abs() on the width for compat with other versions of fmt that accept -width; ross
@
text
@d1 1
a1 2
/*	$OpenBSD: fmt.c,v 1.8 1997/10/01 15:31:03 millert Exp $	*/
/*	$NetBSD: fmt.c,v 1.4 1995/09/01 01:29:41 jtc Exp $	*/
d3 128
a130 8
/*
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
d132 35
a166 22
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d170 4
a173 3
static char copyright[] =
"@@(#) Copyright (c) 1980, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
d176 25
a200 3
#ifndef lint
#if 0
static char sccsid[] = "@@(#)fmt.c	8.1 (Berkeley) 7/20/93";
d202 4
a205 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.8 1997/10/01 15:31:03 millert Exp $";
a206 1
#endif /* not lint */
a208 2
#include <err.h>
#include <locale.h>
d213 6
a218 49
#ifdef	__GNUC__
#define inline	__inline
#else	/* !__GNUC__ */
#define inline
#endif	/* !__GNUC__ */

/*
 * fmt -- format the concatenation of input files or standard input
 * onto standard output.  Designed for use with Mail ~|
 *
 * Syntax : fmt [ goal [ max ] ] [ name ... ]
 * Authors: Kurt Shoens (UCB) 12/7/78;
 *          Liz Allen (UMCP) 2/24/83 [Addition of goal length concept].
 */

/* LIZ@@UOM 6/18/85 -- Don't need LENGTH any more.
 * #define	LENGTH	72		Max line length in output
 */
#define	NOSTR	((char *) 0)	/* Null string pointer for lint */

/* LIZ@@UOM 6/18/85 --New variables goal_length and max_length */
#define GOAL_LENGTH 65
#define MAX_LENGTH 75
int	goal_length;		/* Target or goal line length in output */
int	max_length;		/* Max line length in output */
int	pfx;			/* Current leading blank count */
int	lineno;			/* Current input line */
int	mark;			/* Last place we saw a head line */
int	center;			/* Did they ask to center lines? */

char	*headnames[] = {"To", "Subject", "Cc", 0};

void fmt __P((FILE *));
void setout __P((void));
void prefix __P((char *));
void split __P((char *));
void pack __P((char *, int));
void oflush __P((void));
void tabulate __P((char *));
void leadin __P((void));
char *savestr __P((char *));
inline char *extstr __P((char *, int *, int));
int  ispref __P((char *, char *));
int  ishead __P((char *));

/*
 * Drive the whole formatter by managing input files.  Also,
 * cause initialization of the output stuff and flush it out
 * at the end.
d220 1
d222 12
a233 459
int
main(argc, argv)
	int argc;
	char **argv;
{
	register FILE *fi;
	register int errs = 0;
	int number;		/* LIZ@@UOM 6/18/85 */

	(void) setlocale(LC_CTYPE, "");

	goal_length = GOAL_LENGTH;
	max_length = MAX_LENGTH;
	setout();
	lineno = 1;
	mark = -10;
	/*
	 * LIZ@@UOM 6/18/85 -- Check for goal and max length arguments
	 */
	if (argc > 1 && !strcmp(argv[1], "-c")) {
		center++;
		argc--;
		argv++;
	}
	if (argc > 1 && (1 == (sscanf(argv[1], "%d", &number)))) {
		argv++;
		argc--;
		goal_length = abs(number);
		if (argc > 1 && (1 == (sscanf(argv[1], "%d", &number)))) {
			argv++;
			argc--;
			max_length = abs(number);
		}
	}
	if (max_length <= goal_length)
		errx(1, "Max length (%d) must be greater than goal length: %d",
		     max_length, goal_length);
	if (argc < 2) {
		fmt(stdin);
		oflush();
		exit(0);
	}
	while (--argc) {
		if ((fi = fopen(*++argv, "r")) == NULL) {
			perror(*argv);
			errs++;
			continue;
		}
		fmt(fi);
		fclose(fi);
	}
	oflush();
	exit(errs);
}

/*
 * Read up characters from the passed input file, forming lines,
 * doing ^H processing, expanding tabs, stripping trailing blanks,
 * and sending each line down for analysis.
 */
void
fmt(fi)
	FILE *fi;
{
	static char *linebuf, *canonb;
	static int lbufsize, cbufsize;
	register char *cp, *cp2, cc;
	register int c, col;
#define CHUNKSIZE 1024

	canonb = malloc(CHUNKSIZE);
	if (canonb == 0)
		errx(1, "Ran out of memory");

	if (center) {
		register int len;

		linebuf = extstr(linebuf, &lbufsize, NULL);
		for (;;) {
			len = 0;
			for (;;) {
				if (!fgets(linebuf + len, lbufsize - len, fi))
					break;
				len = strlen(linebuf);
				if (linebuf[len-1] == '\n' || feof(fi))
					break;
				linebuf = extstr(linebuf, &lbufsize, NULL);
			}
			if (len == 0)
				return;
			cp = linebuf;
			while (*cp && isspace(*cp))
				cp++;
			cp2 = cp + strlen(cp) - 1;
			while (cp2 > cp && isspace(*cp2))
				cp2--;
			if (cp == cp2)
				putchar('\n');
			col = cp2 - cp;
			for (c = 0; c < (goal_length-col)/2; c++)
				putchar(' ');
			while (cp <= cp2)
				putchar(*cp++);
			putchar('\n');
		}
	}
	c = getc(fi);
	while (c != EOF) {
		/*
		 * Collect a line, doing ^H processing.
		 * Leave tabs for now.
		 */
		cp = linebuf;
		while (c != '\n' && c != EOF) {
			if (cp - linebuf >= lbufsize) {
				int offset = cp - linebuf;
				linebuf = extstr(linebuf, &lbufsize, NULL);
				cp = linebuf + offset;
			}
			if (c == '\b') {
				if (cp > linebuf)
					cp--;
				c = getc(fi);
				continue;
			}
			if (!isprint(c) && c != '\t') {
				c = getc(fi);
				continue;
			}
			*cp++ = c;
			c = getc(fi);
		}

		/*
		 * Toss anything remaining on the input line.
		 */
		while (c != '\n' && c != EOF)
			c = getc(fi);

		if (cp != NULL) {
			*cp = '\0';
		} else {
			putchar('\n');
			c = getc(fi);
			continue;
		}

		/*
		 * Expand tabs on the way to canonb.
		 */
		col = 0;
		cp = linebuf;
		cp2 = canonb;
		while ((cc = *cp++)) {
			if (cc != '\t') {
				col++;
				if (cp2 - canonb >= cbufsize) {
					int offset = cp2 - canonb;
					canonb = extstr(canonb, &cbufsize, NULL);
					cp2 = canonb + offset;
				}
				*cp2++ = cc;
				continue;
			}
			do {
				if (cp2 - canonb >= cbufsize) {
					int offset = cp2 - canonb;
					canonb = extstr(canonb, &cbufsize, NULL);
					cp2 = canonb + offset;
				}
				*cp2++ = ' ';
				col++;
			} while ((col & 07) != 0);
		}

		/*
		 * Swipe trailing blanks from the line.
		 */
		for (cp2--; cp2 >= canonb && *cp2 == ' '; cp2--)
			;
		*++cp2 = '\0';
		prefix(canonb);
		if (c != EOF)
			c = getc(fi);
	}
}

/*
 * Take a line devoid of tabs and other garbage and determine its
 * blank prefix.  If the indent changes, call for a linebreak.
 * If the input line is blank, echo the blank line on the output.
 * Finally, if the line minus the prefix is a mail header, try to keep
 * it on a line by itself.
 */
void
prefix(line)
	char line[];
{
	register char *cp, **hp;
	register int np, h;

	if (*line == '\0') {
		oflush();
		putchar('\n');
		return;
	}
	for (cp = line; *cp == ' '; cp++)
		;
	np = cp - line;

	/*
	 * The following horrible expression attempts to avoid linebreaks
	 * when the indent changes due to a paragraph.
	 */
	if (np != pfx && (np > pfx || abs(pfx-np) > 8))
		oflush();
	if ((h = ishead(cp)))
		oflush(), mark = lineno;
	if (lineno - mark < 3 && lineno - mark > 0)
		for (hp = &headnames[0]; *hp != NULL; hp++)
			if (ispref(*hp, cp)) {
				h = 1;
				oflush();
				break;
			}
	if (!h && (h = (*cp == '.')))
		oflush();
	pfx = np;
	if (h)
		pack(cp, strlen(cp));
	else
		split(cp);
	if (h)
		oflush();
	lineno++;
}

/*
 * Split up the passed line into output "words" which are
 * maximal strings of non-blanks with the blank separation
 * attached at the end.  Pass these words along to the output
 * line packer.
 */
void
split(line)
	char line[];
{
	register char *cp, *cp2;
	static char *word;
	static int wordsize;
	int wordl;		/* LIZ@@UOM 6/18/85 */

	if (strlen(line) >= wordsize)
		word = extstr(word, &wordsize, strlen(line) + 1);

	cp = line;
	while (*cp) {
		cp2 = word;
		wordl = 0;	/* LIZ@@UOM 6/18/85 */

		/*
		 * Collect a 'word,' allowing it to contain escaped white
		 * space.
		 */
		while (*cp && *cp != ' ') {
			if (*cp == '\\' && isspace(cp[1]))
				*cp2++ = *cp++, wordl++;
			*cp2++ = *cp++;
			wordl++;/* LIZ@@UOM 6/18/85 */
		}

		/*
		 * Guarantee a space at end of line. Two spaces after end of
		 * sentence punctuation.
		 */
		if (*cp == '\0') {
			*cp2++ = ' ';
			if (strchr(".:!", cp[-1]))
				*cp2++ = ' ';
		}
		while (*cp == ' ')
			*cp2++ = *cp++;
		*cp2 = '\0';
		/*
		 * LIZ@@UOM 6/18/85 pack(word);
		 */
		pack(word, wordl);
	}
}

/*
 * Output section.
 * Build up line images from the words passed in.  Prefix
 * each line with correct number of blanks.  The buffer "outbuf"
 * contains the current partial line image, including prefixed blanks.
 * "outp" points to the next available space therein.  When outp is NOSTR,
 * there ain't nothing in there yet.  At the bottom of this whole mess,
 * leading tabs are reinserted.
 */
static char *outbuf;			/* Sandbagged output line image */
static int   obufsize;			/* Size of outbuf */
static char *outp;			/* Pointer in above */

/*
 * Initialize the output section.
 */
void
setout()
{
	outp = NOSTR;
}

/*
 * Pack a word onto the output line.  If this is the beginning of
 * the line, push on the appropriately-sized string of blanks first.
 * If the word won't fit on the current line, flush and begin a new
 * line.  If the word is too long to fit all by itself on a line,
 * just give it its own and hope for the best.
 *
 * LIZ@@UOM 6/18/85 -- If the new word will fit in at less than the
 *	goal length, take it.  If not, then check to see if the line
 *	will be over the max length; if so put the word on the next
 *	line.  If not, check to see if the line will be closer to the
 *	goal length with or without the word and take it or put it on
 *	the next line accordingly.
 */

/*
 * LIZ@@UOM 6/18/85 -- pass in the length of the word as well
 * pack(word)
 *	char word[];
 */
void
pack(word, wl)
	char word[];
	int wl;
{
	register char *cp;
	register int s, t;

	if (outp == NOSTR)
		leadin();
	/*
	 * LIZ@@UOM 6/18/85 -- change condition to check goal_length; s is the
	 * length of the line before the word is added; t is now the length
	 * of the line after the word is added
	 *	t = strlen(word);
	 *	if (t+s <= LENGTH)
	 */
	s = outp - outbuf;
	t = wl + s;
	if (t + 1 > obufsize) {
		outbuf = extstr(outbuf, &obufsize, t + 1);
		outp = outbuf + s;
	}
	if ((t <= goal_length) ||
	    ((t <= max_length) && (t - goal_length <= goal_length - s))) {
		/*
		 * In like flint!
		 */
		for (cp = word; *cp; *outp++ = *cp++)
			;
		return;
	}
	if (s > pfx) {
		oflush();
		leadin();
	}
	for (cp = word; *cp; *outp++ = *cp++)
		;
}

/*
 * If there is anything on the current output line, send it on
 * its way.  Set outp to NOSTR to indicate the absence of the current
 * line prefix.
 */
void
oflush()
{
	if (outp == NOSTR)
		return;
	*outp = '\0';
	tabulate(outbuf);
	outp = NOSTR;
}

/*
 * Take the passed line buffer, insert leading tabs where possible, and
 * output on standard output (finally).
 */
void
tabulate(line)
	char line[];
{
	register char *cp;
	register int b, t;

	/*
	 * Toss trailing blanks in the output line.
	 */
	cp = line + strlen(line) - 1;
	while (cp >= line && *cp == ' ')
		cp--;
	*++cp = '\0';

	/*
	 * Count the leading blank space and tabulate.
	 */
	for (cp = line; *cp == ' '; cp++)
		;
	b = cp-line;
	t = b >> 3;
	b &= 07;
	if (t > 0)
		do
			putc('\t', stdout);
		while (--t);
	if (b > 0)
		do
			putc(' ', stdout);
		while (--b);
	while (*cp)
		putc(*cp++, stdout);
	putc('\n', stdout);
}

/*
 * Initialize the output line with the appropriate number of
 * leading blanks.
 */
void
leadin()
{
	register int b;
	register char *cp;

	if (obufsize == 0 || (outp != NULL && outp - outbuf <= pfx))
		outbuf = extstr(outbuf, &obufsize, pfx);
	for (b = 0, cp = outbuf; b < pfx; b++)
		*cp++ = ' ';
	outp = cp;
}

/*
 * Save a string in dynamic space.
 * This little goodie is needed for
 * a headline detector in head.c
 */
char *
savestr(str)
	char str[];
{
	char *top;

	top = strdup(str);
	if (top == NOSTR)
		errx(1, "Ran out of memory");
	return (top);
d236 44
a279 2
/*
 * Is s1 a prefix of s2??
d282 346
a627 23
ispref(s1, s2)
	register char *s1, *s2;
{

	while (*s1++ == *s2)
		;
	return (*s1 == '\0');
}

inline char *
extstr(str, size, gsize)
	char *str;
	int *size;
	int gsize;
{
	do {
		*size += CHUNKSIZE;
	} while (gsize && *size < gsize);

	if ((str = realloc(str, *size)) == NULL)
		errx(1, "Ran out of memory");
	
	return(str);
@


1.8
log
@Fix bug where fmt allows backslashed whitespace inside words, but it only
counts each such as one character long, gjm11@@dpmms.cam.ac.uk.
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.7 1997/09/23 11:54:00 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.7 1997/09/23 11:54:00 deraadt Exp $";
d136 1
a136 1
		goal_length = number;
d140 1
a140 1
			max_length = number;
@


1.7
log
@avoid crash when dealing with ^M lines; roberte@@MEP.Ruhr-Uni-Bochum.de
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.6 1997/02/08 10:23:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.6 1997/02/08 10:23:39 deraadt Exp $";
d375 1
a375 1
				*cp2++ = *cp++;
@


1.6
log
@inline to avoid warning
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.5 1997/01/27 04:06:49 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.5 1997/01/27 04:06:49 millert Exp $";
d178 4
@


1.5
log
@No more static buffers.  We can operate on any sized files now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.4 1997/01/26 03:56:52 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.4 1997/01/26 03:56:52 millert Exp $";
d99 1
a99 1
char *extstr __P((char *, int *, int));
@


1.4
log
@Dynamic buffering to handle arbitrary line length and center option from FreeBSD
I also cleaned it up to pass -Wall and check malloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.3 1997/01/17 07:12:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.3 1997/01/17 07:12:35 millert Exp $";
d58 6
d99 1
d173 2
a174 1
	static char *linebuf = 0, *canonb = 0;
a177 1
	static int lbufsize = 0, cbufsize = 0;
d180 3
a182 2
		if ((linebuf = malloc(BUFSIZ)) == NOSTR)
			errx(1, "Ran out of memory");
d184 10
a193 2
			cp = fgets(linebuf, BUFSIZ, fi);
			if (!cp)
d195 1
d221 1
a221 4
				lbufsize += CHUNKSIZE;
				linebuf = realloc(linebuf, lbufsize);
				if(linebuf == 0)
					abort();
d263 1
a263 4
					cbufsize += CHUNKSIZE;
					canonb = realloc(canonb, cbufsize);
					if(canonb == 0)
						abort();
d272 1
a272 4
					cbufsize += CHUNKSIZE;
					canonb = realloc(canonb, cbufsize);
					if(canonb == 0)
						abort();
d324 1
a324 1
		for (hp = &headnames[0]; *hp != (char *) 0; hp++)
d335 2
a336 1
	else	split(cp);
d353 2
a354 1
	char word[BUFSIZ];
d357 3
d404 3
a406 2
char	outbuf[BUFSIZ];			/* Sandbagged output line image */
char	*outp;				/* Pointer in above */
d456 4
d465 2
a466 1
		for (cp = word; *cp; *outp++ = *cp++);
d473 2
a474 1
	for (cp = word; *cp; *outp++ = *cp++);
d542 2
d577 16
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.2 1996/06/26 05:33:21 deraadt Exp $	*/
d46 2
a48 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.2 1996/06/26 05:33:21 deraadt Exp $";
d51 3
a56 1
#include <ctype.h>
d80 1
d84 12
d102 1
d111 2
d119 1
a119 1
	 * LIZ@@UOM 6/18/85 -- Check for goal and max length arguments 
d121 5
d136 3
a138 5
	if (max_length <= goal_length) {
		fprintf(stderr, "Max length must be greater than %s\n",
			"goal length");
		exit(1);
	}
d162 1
d166 2
a167 2
	char linebuf[BUFSIZ], canonb[BUFSIZ];
	register char *cp, *cp2;
d169 2
d172 22
d201 9
a209 1
		while (c != '\n' && c != EOF && cp-linebuf < BUFSIZ-1) {
d216 1
a216 1
			if ((c < ' ' || c >= 0177) && c != '\t') {
a222 1
		*cp = '\0';
d229 9
a237 1
		
d244 2
a245 2
		while (c = *cp++) {
			if (c != '\t') {
d247 9
a255 2
				if (cp2-canonb < BUFSIZ-1)
					*cp2++ = c;
d259 9
a267 2
				if (cp2-canonb < BUFSIZ-1)
					*cp2++ = ' ';
d291 1
d298 1
a298 1
	if (strlen(line) == 0) {
d313 1
a313 1
	if (h = ishead(cp))
d339 1
d354 1
a354 1
		 * space. 
d365 1
a365 1
		 * sentence punctuation. 
d376 1
a376 1
		 * LIZ@@UOM 6/18/85 pack(word); 
d397 1
d423 2
a424 1
pack(word,wl)
d438 1
a438 1
	 *	if (t+s <= LENGTH) 
d445 1
a445 1
		 * In like flint! 
d462 1
d476 1
d490 1
a490 1
	
d516 1
d536 1
a536 1
	register char *top;
d538 3
a540 6
	top = malloc(strlen(str) + 1);
	if (top == NOSTR) {
		fprintf(stderr, "fmt:  Ran out of memory\n");
		exit(1);
	}
	strcpy(top, str);
d547 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: fmt.c,v 1.4 1995/09/01 01:29:41 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: fmt.c,v 1.4 1995/09/01 01:29:41 jtc Exp $";
d291 1
a291 1
			if (index(".:!", cp[-1]))
@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: fmt.c,v 1.4 1995/09/01 01:29:41 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
