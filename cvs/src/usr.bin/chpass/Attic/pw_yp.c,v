head	1.24;
access;
symbols
	OPENBSD_5_8:1.23.0.26
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.18
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.22
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.20
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.16
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.10
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.12.0.8
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.11.26.19.01.47;	author deraadt;	state dead;
branches;
next	1.23;
commitid	0NbTNVgy2y455HVw;

1.23
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.15.21.43.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.31.00.29.13;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.11.07.13.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.17.07.37.04;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.27.19.02.40;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.29.09.23.25;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	99.12.15.21.31.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.09.29.02.40.28;	author alex;	state Exp;
branches;
next	1.10;

1.10
date	99.08.06.20.41.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.08.03.17.09.47;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.03.30.06.59.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.14.11.05.11;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.02.13.17.28.40;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.13.50.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.01.55.33;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.30.13.09.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.31.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Delete YP password related code.  As a result, these can also be
pledged.  Keep an eye out for regressions, because they could be
uncomfortable.
ok beck semarie
@
text
@/*	$OpenBSD: pw_yp.c,v 1.23 2009/10/27 23:59:36 deraadt Exp $	*/
/*	$NetBSD: pw_yp.c,v 1.5 1995/03/26 04:55:33 glass Exp $	*/

/*
 * Copyright (c) 1988 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef	YP

#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <time.h>
#include <pwd.h>
#include <err.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <rpc/rpc.h>
#include <rpcsvc/yp_prot.h>
#include <rpcsvc/ypclnt.h>
#define passwd yp_passwd_rec
#include <rpcsvc/yppasswd.h>
#undef passwd
#include "chpass.h"

extern char *__progname;

static char *domain;

int
pw_yp(struct passwd *pw, uid_t uid)
{
	char uidbuf[20], gidbuf[20], *master, *p;
	int r, rpcport, status, alen;
	struct yppasswd yppasswd;
	struct timeval tv;
	CLIENT *client;

	/*
	 * Get local domain
	 */
	if (!domain && (r = yp_get_default_domain(&domain))) {
		fprintf(stderr, "%s: can't get local YP domain. Reason: %s\n",
		    __progname, yperr_string(r));
		return(0);
	}

	/*
	 * Find the host for the passwd map; it should be running
	 * the daemon.
	 */
	if ((r = yp_master(domain, "passwd.byname", &master)) != 0) {
		fprintf(stderr,
		    "%s: can't find the master YP server. Reason: %s\n",
		    __progname, yperr_string(r));
		return(0);
	}

	/*
	 * Ask the portmapper for the port of the daemon.
	 */
	if ((rpcport = getrpcport(master, YPPASSWDPROG, YPPASSWDPROC_UPDATE,
	    IPPROTO_UDP)) == 0) {
		fprintf(stderr,
		    "%s: master YP server not running yppasswd daemon.\n",
		    __progname);
		fprintf(stderr,	"\tCan't change password.\n");
		return(0);
	}

	/*
	 * Be sure the port is privileged
	 */
	if (rpcport >= IPPORT_RESERVED) {
		(void)fprintf(stderr,
		    "%s: yppasswd daemon running on an invalid port.\n",
		    __progname);
		return(0);
	}

	/* prompt for old password */
	bzero(&yppasswd, sizeof yppasswd);
	yppasswd.oldpass = "none";
	yppasswd.oldpass = getpass("Old password:");
	if (!yppasswd.oldpass) {
		(void)fprintf(stderr, "Cancelled.\n");
		return(0);
	}

	for (alen = 0, p = pw->pw_gecos; *p; p++)
		if (*p == '&')
			alen = alen + strlen(pw->pw_name) - 1;
	(void)snprintf(uidbuf, sizeof uidbuf, "%u", pw->pw_uid);
	(void)snprintf(gidbuf, sizeof gidbuf, "%u", pw->pw_gid);

	if (strlen(pw->pw_name) + 1 + strlen(pw->pw_passwd) + 1 +
	    strlen(uidbuf) + 1 + strlen(gidbuf) + 1 +
	    strlen(pw->pw_gecos) + alen + 1 + strlen(pw->pw_dir) + 1 +
	    strlen(pw->pw_shell) >= 1023) {
		warnx("entries too long");
		return (0);
	}

	/* tell rpc.yppasswdd */
	yppasswd.newpw.pw_name	= pw->pw_name;
	yppasswd.newpw.pw_passwd= pw->pw_passwd;
	yppasswd.newpw.pw_uid	= pw->pw_uid;
	yppasswd.newpw.pw_gid	= pw->pw_gid;
	yppasswd.newpw.pw_gecos = pw->pw_gecos;
	yppasswd.newpw.pw_dir	= pw->pw_dir;
	yppasswd.newpw.pw_shell	= pw->pw_shell;

	client = clnt_create(master, YPPASSWDPROG, YPPASSWDVERS, "udp");
	if (client==NULL) {
		fprintf(stderr, "can't contact yppasswdd on %s: Reason: %s\n",
		    master, yperr_string(YPERR_YPBIND));
		return(1);
	}
	client->cl_auth = authunix_create_default();
	tv.tv_sec = 5;
	tv.tv_usec = 0;
	r = clnt_call(client, YPPASSWDPROC_UPDATE,
	    xdr_yppasswd, &yppasswd, xdr_int, &status, tv);
	if (r) {
		fprintf(stderr, "%s: rpc to yppasswdd failed. %d\n",
		    __progname, r);
		clnt_destroy(client);
		return(1);
	} else if (status) {
		printf("Couldn't change YP password information.\n");
		clnt_destroy(client);
		return(1);
	}
	printf("The YP password information has been changed on %s, the master YP passwd server.\n", master);

	clnt_destroy(client);
	return(0);
}

static char *
pwskip(char *p)
{
	while (*p && *p != ':' && *p != '\n')
		++p;
	if (*p)
		*p++ = 0;
	return (p);
}

static struct passwd *
interpret(struct passwd *pwent, char *line, const int secure)
{
	char	*p = line;

	pwent->pw_passwd = "*";
	pwent->pw_uid = 0;
	pwent->pw_gid = 0;
	pwent->pw_gecos = "";
	pwent->pw_dir = "";
	pwent->pw_shell = "";
	pwent->pw_change = 0;
	pwent->pw_expire = 0;
	pwent->pw_class = "";

	/* line without colon separators is no good, so ignore it */
	if (!strchr(p,':'))
		return(NULL);

	pwent->pw_name = p;
	p = pwskip(p);
	pwent->pw_passwd = p;
	p = pwskip(p);
	pwent->pw_uid = (uid_t)strtoul(p, NULL, 10);
	p = pwskip(p);
	pwent->pw_gid = (gid_t)strtoul(p, NULL, 10);
	p = pwskip(p);
	if (secure == 1) {
		pwent->pw_class = p;
		p = pwskip(p);
		pwent->pw_change = (time_t)strtoul(p, NULL, 10);
		p = pwskip(p);
		pwent->pw_expire = (time_t)strtoul(p, NULL, 10);
		p = pwskip(p);
	}
	pwent->pw_gecos = p;
	p = pwskip(p);
	pwent->pw_dir = p;
	p = pwskip(p);
	pwent->pw_shell = p;
	while (*p && *p != '\n')
		p++;
	*p = '\0';
	return (pwent);
}

static char *__yplin;

struct passwd *
ypgetpwnam(char *nam)
{
	static struct passwd pwent;
	int reason, vallen, secure = 0;
	char *val;

	/*
	 * Get local domain
	 */
	if (!domain && (reason = yp_get_default_domain(&domain))) {
		fprintf(stderr, "%s: can't get local YP domain. Reason: %s\n",
		    __progname, yperr_string(reason));
		exit(1);
	}

	if (!yp_match(domain, "master.passwd.byname", nam, strlen(nam),
	    &val, &vallen))
		secure = 1;
	else if (yp_match(domain, "passwd.byname", nam, strlen(nam),
	    &val, &vallen))
		return (NULL);

	val[vallen] = '\0';
	if (__yplin)
		free(__yplin);
	if (!(__yplin = malloc(vallen + 1)))
		err(1, NULL);
	strlcpy(__yplin, val, vallen + 1);
	free(val);

	return(interpret(&pwent, __yplin, secure));
}

struct passwd *
ypgetpwuid(uid_t uid)
{
	static struct passwd pwent;
	int reason, vallen, secure = 0;
	char namebuf[16], *val;

	if (!domain && (reason = yp_get_default_domain(&domain))) {
		fprintf(stderr, "%s: can't get local YP domain. Reason: %s\n",
		    __progname, yperr_string(reason));
		exit(1);
	}

	snprintf(namebuf, sizeof namebuf, "%u", (u_int)uid);
	if (!yp_match(domain, "master.passwd.byuid", namebuf, strlen(namebuf),
	    &val, &vallen))
		secure = 1;
	else if (yp_match(domain, "passwd.byuid", namebuf, strlen(namebuf),
	    &val, &vallen))
		return (NULL);

	val[vallen] = '\0';
	if (__yplin)
		free(__yplin);
	if (!(__yplin = malloc(vallen + 1)))
		err(1, NULL);
	strlcpy(__yplin, val, vallen + 1);
	free(val);

	return(interpret(&pwent, __yplin, secure));
}

#endif	/* YP */
@


1.23
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.22 2009/02/15 21:43:40 deraadt Exp $	*/
@


1.22
log
@in a secure YP context, a chpass would whack the user's password to *
which is clearly not the intent.  PR 4177, fix from schwarze@@usta.de
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.21 2006/03/31 00:29:13 deraadt Exp $	*/
a31 7
#ifndef lint
#if 0
static char sccsid[] = "@@(#)pw_yp.c	1.0 2/2/93";
#else
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.21 2006/03/31 00:29:13 deraadt Exp $";
#endif
#endif /* not lint */
@


1.21
log
@tiny bits of lint
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.20 2005/04/11 07:13:03 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.20 2005/04/11 07:13:03 deraadt Exp $";
d184 1
a184 1
interpret(struct passwd *pwent, char *line)
d199 1
a199 1
	if(!strchr(p,':'))
d210 8
d235 1
a235 1
	int reason, vallen;
d247 5
a251 6
	reason = yp_match(domain, "passwd.byname", nam, strlen(nam),
	    &val, &vallen);
	switch(reason) {
	case 0:
		break;
	default:
d253 1
a253 1
	}
d262 1
a262 1
	return(interpret(&pwent, __yplin));
d269 1
a269 1
	int reason, vallen;
d279 5
a283 6
	reason = yp_match(domain, "passwd.byuid", namebuf, strlen(namebuf),
	    &val, &vallen);
	switch(reason) {
	case 0:
		break;
	default:
d285 1
a285 1
	}
d294 1
a294 1
	return(interpret(&pwent, __yplin));
@


1.20
log
@move two snprintf out so easier to audit
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.19 2003/07/02 21:04:09 deraadt Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.19 2003/07/02 21:04:09 deraadt Exp $";
a245 1
		break;
d250 1
a250 1
	if (!(__yplin = (char *)malloc(vallen + 1)))
a278 1
		break;
d283 1
a283 1
	if (!(__yplin = (char *)malloc(vallen + 1)))
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.18 2003/06/03 02:56:06 millert Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.18 2003/06/03 02:56:06 millert Exp $";
d66 1
a66 1
	char buf[11], *master, *p;
d126 3
d130 1
a130 2
	    strlen((snprintf(buf, sizeof buf, "%u", pw->pw_uid), buf)) + 1 +
	    strlen((snprintf(buf, sizeof buf, "%u", pw->pw_gid), buf)) + 1 +
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.17 2003/04/17 07:37:04 pvalchev Exp $	*/
d36 1
a36 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.17 2003/04/17 07:37:04 pvalchev Exp $";
d57 1
@


1.17
log
@%u is 11 chars, not 10; ok miod deraadt millert tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.16 2002/06/27 19:02:40 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d36 1
a36 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.16 2002/06/27 19:02:40 deraadt Exp $";
@


1.16
log
@cleanup; mpech & millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.15 2002/06/04 00:09:08 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.15 2002/06/04 00:09:08 deraadt Exp $";
d69 1
a69 1
	char buf[10], *master, *p;
@


1.15
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.14 2002/05/29 09:23:25 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.14 2002/05/29 09:23:25 deraadt Exp $";
d53 1
d67 1
a67 3
pw_yp(pw, uid)
	struct passwd *pw;
	uid_t uid;
d69 1
a69 3
	char *master;
	char *p;
	char buf[10];
d74 1
a74 2
	extern char *getpass();
	
d125 1
a125 1
	
d141 1
a141 1
	yppasswd.newpw.pw_uid 	= pw->pw_uid;
d175 1
a175 2
pwskip(p)
	char *p;
d185 1
a185 3
interpret(pwent, line)
	struct passwd *pwent;
	char *line;
d198 1
a198 1
	
d225 1
a225 2
ypgetpwnam(nam)
	char *nam;
d228 1
d230 1
a230 2
	int reason, vallen;
	
d254 1
a254 1
	strcpy(__yplin, val);	/* ok */
d261 1
a261 2
ypgetpwuid(uid)
	uid_t uid;
a263 1
	char *val;
d265 2
a266 2
	char namebuf[16];
	
d273 1
a273 1
	snprintf(namebuf, sizeof namebuf, "%u", uid);
d288 1
a288 1
	strcpy(__yplin, val);	/* ok */
@


1.14
log
@more snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.13 2001/11/19 19:02:13 mpech Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.13 2001/11/19 19:02:13 mpech Exp $";
d112 1
a112 1
	 * Be sure the port is priviledged
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.12 1999/12/15 21:31:42 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.12 1999/12/15 21:31:42 deraadt Exp $";
d134 2
a135 2
	    strlen((sprintf(buf, "%u", pw->pw_uid), buf)) + 1 +
	    strlen((sprintf(buf, "%u", pw->pw_gid), buf)) + 1 +
d283 1
a283 1
	sprintf(namebuf, "%u", uid);
@


1.12
log
@these strcpy are fine
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.11 1999/09/29 02:40:28 alex Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.11 1999/09/29 02:40:28 alex Exp $";
d180 1
a180 1
	register char *p;
d194 1
a194 1
	register char	*p = line;
@


1.11
log
@Check malloc(3) return.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.10 1999/08/06 20:41:06 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.10 1999/08/06 20:41:06 deraadt Exp $";
d262 1
a262 1
	strcpy(__yplin, val);
d298 1
a298 1
	strcpy(__yplin, val);
@


1.10
log
@uid_t and gid_t, and use %u
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.9 1998/08/03 17:09:47 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.9 1998/08/03 17:09:47 millert Exp $";
d260 2
a261 1
	__yplin = (char *)malloc(vallen + 1);
d296 2
a297 1
	__yplin = (char *)malloc(vallen + 1);
@


1.9
log
@use __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.8 1998/03/30 06:59:32 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.8 1998/03/30 06:59:32 deraadt Exp $";
d134 2
a135 2
	    strlen((sprintf(buf, "%d", pw->pw_uid), buf)) + 1 +
	    strlen((sprintf(buf, "%d", pw->pw_gid), buf)) + 1 +
d282 1
a282 1
	sprintf(namebuf, "%d", uid);
@


1.8
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.7 1997/02/14 11:05:11 niklas Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.7 1997/02/14 11:05:11 niklas Exp $";
d61 1
a61 1
extern char *progname;
d84 1
a84 1
		    progname, yperr_string(r));
d95 1
a95 1
		    progname, yperr_string(r));
d106 1
a106 1
		    progname);
d117 1
a117 1
		    progname);
d163 2
a164 1
		fprintf(stderr, "%s: rpc to yppasswdd failed. %d\n", progname, r);
d244 1
a244 1
		    progname, yperr_string(reason));
d278 1
a278 1
		    progname, yperr_string(reason));
@


1.7
log
@#include <stdlib.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.6 1997/02/13 17:28:40 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.6 1997/02/13 17:28:40 deraadt Exp $";
d51 1
d65 1
d71 1
a71 1
	char *pp, *p;
a193 1
	register int	c;
@


1.6
log
@fix YP and non-YP cases to exit/warn nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.5 1996/08/31 13:50:19 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.5 1996/08/31 13:50:19 deraadt Exp $";
d52 1
@


1.5
log
@constrain & expansion to LINE_MAX for safety
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.4 1996/08/31 01:55:33 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.4 1996/08/31 01:55:33 deraadt Exp $";
d152 1
a152 1
		return(0);
d162 1
a162 1
		return(0);
d166 1
a166 1
		return(0);
d171 1
a171 1
	return(1);
@


1.4
log
@kill leaks; help from das33@@cornell.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.3 1996/08/30 13:09:41 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.3 1996/08/30 13:09:41 deraadt Exp $";
d68 3
a70 2
	char *pp;
	int r, rpcport, status;
d127 12
d147 1
a147 1
	
@


1.3
log
@buf oflow; found by oliver fixed by me
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.2 1996/06/26 05:31:58 deraadt Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.2 1996/06/26 05:31:58 deraadt Exp $";
d148 1
d152 1
d157 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: pw_yp.c,v 1.5 1995/03/26 04:55:33 glass Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: pw_yp.c,v 1.5 1995/03/26 04:55:33 glass Exp $";
d210 2
a216 1
	static char line[1024];
d239 4
a242 1
	strcpy(line, val);
d245 1
a245 1
	return(interpret(&pwent, line));
a252 1
	static char line[1024];
d274 4
a277 1
	strcpy(line, val);
d280 1
a280 1
	return(interpret(&pwent, line));
@


1.1
log
@Initial revision
@
text
@d1 1
d40 1
a40 1
static char rcsid[] = "$NetBSD: pw_yp.c,v 1.5 1995/03/26 04:55:33 glass Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
