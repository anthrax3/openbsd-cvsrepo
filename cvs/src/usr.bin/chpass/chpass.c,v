head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.6
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.39.0.8
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.4
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.2
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.8
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.6
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.4
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.31.0.6
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.4
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.26.0.4
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2015.11.26.19.01.47;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	0NbTNVgy2y455HVw;

1.42
date	2015.11.18.19.26.45;	author tedu;	state Exp;
branches;
next	1.41;
commitid	vDRlMfzdpjdPVCAt;

1.41
date	2015.01.16.06.40.06;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	Uu5nFG3wCl0LACBb;

1.40
date	2014.10.26.20.38.13;	author guenther;	state Exp;
branches;
next	1.39;
commitid	kIglsEMRWqE0Zw0s;

1.39
date	2013.04.18.16.23.25;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2012.06.20.21.32.27;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.27.23.59.36;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.08.21.30.15;	author sobrado;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.19.19.16.04;	author tobias;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.27.07.22.33;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.15.08.14.21;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.12.20.43.10;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.10.20.05.48;	author wilfried;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.20.23.21.23;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.26.00.33.58;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.01.01.01.28;	author avsm;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.03.02.56.06;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.31.22.08.41;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.27.22.02.08;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.27.19.16.50;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.27.19.02.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.44;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.27.02.57.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.16.18.29.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.16.16.14.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.15.20.47.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.26.01.29.43;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.21.13.36.14;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.12.05.20.18.35;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.08.03.17.09.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.08.02.03.35.07;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.05.29.16.37.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.03.30.06.59.28;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.06.17.20.49.55;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.13.17.28.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.15.23.42.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.20.23.45.50;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.23.05.40.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.01.55.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.31.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.22.11.35.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.44.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.44.59;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Delete YP password related code.  As a result, these can also be
pledged.  Keep an eye out for regressions, because they could be
uncomfortable.
ok beck semarie
@
text
@/*	$OpenBSD: chpass.c,v 1.42 2015/11/18 19:26:45 tedu Exp $	*/
/*	$NetBSD: chpass.c,v 1.8 1996/05/15 21:50:43 jtc Exp $	*/

/*-
 * Copyright (c) 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <paths.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <util.h>

#include "chpass.h"

extern char *__progname;

enum { NEWSH, LOADENTRY, EDITENTRY } op;
uid_t uid;

void	baduser(void);
void	kbintr(int);
void	usage(void);

int
main(int argc, char *argv[])
{
	struct passwd *pw = NULL, *opw = NULL, lpw;
	int i, ch, pfd, tfd, dfd;
	char *tz, *arg = NULL;
	sigset_t fullset;

	/* We need to use the system timezone for date conversions. */
	if ((tz = getenv("TZ")) != NULL) {
	    unsetenv("TZ");
	    tzset();
	    setenv("TZ", tz, 1);
	}

	op = EDITENTRY;
	while ((ch = getopt(argc, argv, "a:s:")) != -1)
		switch(ch) {
		case 'a':
			op = LOADENTRY;
			arg = optarg;
			break;
		case 's':
			op = NEWSH;
			arg = optarg;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	uid = getuid();

	if (op == EDITENTRY || op == NEWSH)
		switch(argc) {
		case 0:
			pw = getpwuid_shadow(uid);
			if (!pw)
				errx(1, "unknown user: uid %u", uid);
			break;
		case 1:
			pw = getpwnam_shadow(*argv);
			if (!pw)
				errx(1, "unknown user: %s", *argv);
			if (uid && uid != pw->pw_uid)
				baduser();
			break;
		default:
			usage();
		}

	if (op == LOADENTRY) {
		if (argc != 0)
			errx(1, "option -a does not accept user argument");
		if (uid)
			baduser();
		pw = &lpw;
		if (!pw_scan(arg, pw, NULL))
			exit(1);
		opw = getpwnam_shadow(pw->pw_name);
	}
	if (opw == NULL && (opw = pw_dup(pw)) == NULL)
		err(1, NULL);

	/* Edit the user passwd information if requested. */
	if (op == EDITENTRY) {
		char tempname[] = _PATH_VARTMP "pw.XXXXXXXXXX";
		int edit_status;

		if ((pw = pw_dup(pw)) == NULL)
			pw_error(NULL, 1, 1);
		dfd = mkostemp(tempname, O_CLOEXEC);
		if (dfd == -1)
			pw_error(tempname, 1, 1);
		display(tempname, dfd, pw);

		if (pledge("stdio rpath wpath cpath id proc exec",
		    NULL) == -1)
			err(1, "pledge");

		edit_status = edit(tempname, pw);
		close(dfd);
		unlink(tempname);

		switch (edit_status) {
		case EDIT_OK:
			break;
		case EDIT_NOCHANGE:
			pw_error(NULL, 0, 0);
			break;
		case EDIT_ERROR:
		default:
			pw_error(tempname, 1, 1);
			break;
		}
	}

	if (op == NEWSH) {
		if (pledge("stdio rpath wpath cpath id proc exec",
		    NULL) == -1)
			err(1, "pledge");

		/* protect p_shell -- it thinks NULL is /bin/sh */
		if (!arg[0])
			usage();
		if (p_shell(arg, pw, NULL))
			pw_error(NULL, 0, 1);
	}

	/* Drop user's real uid and block all signals to avoid a DoS. */
	setuid(0);
	sigfillset(&fullset);
	sigdelset(&fullset, SIGINT);
	sigprocmask(SIG_BLOCK, &fullset, NULL);

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
		err(1, "pledge");

	/* Get the passwd lock file and open the passwd file for reading. */
	pw_init();
	for (i = 1; (tfd = pw_lock(0)) == -1; i++) {
		if (i == 4)
			(void)fputs("Attempting to lock password file, "
			    "please wait or press ^C to abort", stderr);
		(void)signal(SIGINT, kbintr);
		if (i % 16 == 0)
			fputc('.', stderr);
		usleep(250000);
		(void)signal(SIGINT, SIG_IGN);
	}
	if (i >= 4)
		fputc('\n', stderr);
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY|O_CLOEXEC, 0);
	if (pfd == -1)
		pw_error(_PATH_MASTERPASSWD, 1, 1);

	/* Copy the passwd file to the lock file, updating pw. */
	pw_copy(pfd, tfd, pw, opw);

	/* If username changed we need to rebuild the entire db. */
	arg = !strcmp(opw->pw_name, pw->pw_name) ? pw->pw_name : NULL;

	/* Now finish the passwd file update. */
	if (pw_mkdb(arg, 0) == -1)
		pw_error(NULL, 0, 1);
	exit(0);
}

void
baduser(void)
{

	errx(1, "%s", strerror(EACCES));
}

/* ARGSUSED */
void
kbintr(int signo)
{
	struct iovec iv[5];

	iv[0].iov_base = "\n";
	iv[0].iov_len = 1;
	iv[1].iov_base = __progname;
	iv[1].iov_len = strlen(__progname);
	iv[2].iov_base = ": ";
	iv[2].iov_len = 2;
	iv[3].iov_base = _PATH_MASTERPASSWD;
	iv[3].iov_len = sizeof(_PATH_MASTERPASSWD) - 1;
	iv[4].iov_base = " unchanged\n";
	iv[4].iov_len = 11;
	writev(STDERR_FILENO, iv, 5);

	_exit(1);
}

void
usage(void)
{

	(void)fprintf(stderr, "usage: %s [-s newshell] [user]\n", __progname);
	(void)fprintf(stderr, "       %s -a list\n", __progname);
	exit(1);
}
@


1.42
log
@needs _shadow so it can rewrite the master.passwd file
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.41 2015/01/16 06:40:06 deraadt Exp $	*/
a55 4
#ifdef	YP
int	use_yp;
int	force_yp = 0;
#endif
a68 3
#ifdef	YP
	use_yp = _yp_check(NULL);
#endif
d77 1
a77 1
	while ((ch = getopt(argc, argv, "a:s:ly")) != -1)
a86 12
#ifdef	YP
		case 'l':
			use_yp = 0;
			break;
		case 'y':
			if (!use_yp) {
				warnx("YP not in use.");
				usage();
			}
			force_yp = 1;
			break;
#endif
a93 4
#ifdef	YP
	if (op == LOADENTRY && use_yp)
		errx(1, "cannot load using YP, use -l to load local.");
#endif
a99 6
#ifdef	YP
			if (pw && !force_yp)
				use_yp = 0;
			else if (use_yp)
				pw = ypgetpwuid(uid);
#endif	/* YP */
a104 6
#ifdef	YP
			if (pw && !force_yp)
				use_yp = 0;
			else if (use_yp)
				pw = ypgetpwnam(*argv);
#endif	/* YP */
d138 5
d161 4
d178 3
d199 2
a200 16
#ifdef	YP
	if (use_yp) {
		if (pw_yp(pw, uid))
			pw_error(NULL, 0, 1);
		else {
			pw_abort();
			exit(0);
		}
	} else
#endif	/* YP */
	{
		/* Copy the passwd file to the lock file, updating pw. */
		pw_copy(pfd, tfd, pw, opw);

		/* If username changed we need to rebuild the entire db. */
		arg = !strcmp(opw->pw_name, pw->pw_name) ? pw->pw_name : NULL;
d202 2
a203 4
		/* Now finish the passwd file update. */
		if (pw_mkdb(arg, 0) == -1)
			pw_error(NULL, 0, 1);
	}
d205 3
a242 7
#ifdef	YP
	(void)fprintf(stderr,
	    "usage: %s [-l%s] [-s newshell] [user]\n",
	    __progname, use_yp ? "y" : "");
	(void)fprintf(stderr,
	    "       %s [-l] -a list\n", __progname);
#else
a244 1
#endif
@


1.41
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.40 2014/10/26 20:38:13 guenther Exp $	*/
d122 1
a122 1
			pw = getpwuid(uid);
d133 1
a133 1
			pw = getpwnam(*argv);
d157 1
a157 1
		opw = getpwnam(pw->pw_name);
@


1.40
log
@Prefer mkostemp(O_CLOEXEC) over mkstemp()+fcntl(F_SETFD)
Prefer fopen("re") over fopen("r")+fcntl(F_SETFD)

ok otto@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.39 2013/04/18 16:23:25 okan Exp $	*/
a32 1
#include <sys/param.h>
@


1.39
log
@- use FD_CLOEXEC instead of 1
- use O_CLOEXEC with open() instead of open/fcntl

from David Hill

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.38 2012/06/20 21:32:27 schwarze Exp $	*/
d170 2
a171 2
		dfd = mkstemp(tempname);
		if (dfd == -1 || fcntl(dfd, F_SETFD, FD_CLOEXEC) == -1)
@


1.38
log
@Correct English just like jsing@@ did it in passwd/local_passwd.c rev. 1.38
on April 27, 2008.  While here, fix a typo and drop an obsolete BUGS section.

"my typo so OK millert@@ :-)" and OK jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.37 2009/10/27 23:59:36 deraadt Exp $	*/
d171 1
a171 1
		if (dfd == -1 || fcntl(dfd, F_SETFD, 1) == -1)
d219 2
a220 2
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY, 0);
	if (pfd == -1 || fcntl(pfd, F_SETFD, 1) == -1)
@


1.37
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.36 2008/07/08 21:30:15 sobrado Exp $	*/
d209 1
a209 1
			(void)fputs("Attempting lock password file, "
@


1.36
log
@fix double "usage:"
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.35 2008/06/19 19:16:04 tobias Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1988, 1993, 1994\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)chpass.c	8.4 (Berkeley) 4/2/94";
#else
static char rcsid[] = "$OpenBSD: chpass.c,v 1.35 2008/06/19 19:16:04 tobias Exp $";
#endif
#endif /* not lint */
@


1.35
log
@Moved the unset of TZ environment variable out of atot into main, removing
an unused static var and test out of atot.

With input by jsing and millert, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.34 2007/03/27 07:22:33 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.34 2007/03/27 07:22:33 jmc Exp $";
d299 1
a299 1
	    "usage: %s [-l] -a list\n", __progname);
d302 1
a302 1
	(void)fprintf(stderr, "usage: %s -a list\n", __progname);
@


1.34
log
@-a requires a separate synopsis;
from Daniel Polak via henning

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.33 2007/01/15 08:14:21 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.33 2007/01/15 08:14:21 otto Exp $";
d85 1
a85 1
	char *arg = NULL;
d91 6
@


1.33
log
@Fix -a when given an entry with an already existing user. Also, give
error message if a user arg has been given with -a. Noted by Dan
Brosemer. ok millert@@ jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.32 2005/12/12 20:43:10 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.32 2005/12/12 20:43:10 deraadt Exp $";
d290 1
a290 1
	    "usage: %s [-l%s] [-a list] [-s newshell] [user]\n",
d292 2
d295 2
a296 2
	(void)fprintf(stderr, "usage: %s [-a list] [-s newshell] [user]\n",
	    __progname);
@


1.32
log
@ARGSUSED on signal handler
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.31 2004/05/10 20:05:48 wilfried Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.31 2004/05/10 20:05:48 wilfried Exp $";
d83 1
a83 1
	struct passwd *pw = NULL, *opw, lpw;
d159 2
d166 1
d168 1
a168 1
	if ((opw = pw_dup(pw)) == NULL)
@


1.31
log
@unbreak chsh, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.30 2004/04/20 23:21:23 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.30 2004/04/20 23:21:23 millert Exp $";
d260 1
@


1.30
log
@Adapt to new pw_copy() API, closes PR 3698.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.29 2003/11/26 00:33:58 espie Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.29 2003/11/26 00:33:58 espie Exp $";
a157 8
	if (op == NEWSH) {
		/* protect p_shell -- it thinks NULL is /bin/sh */
		if (!arg[0])
			usage();
		if (p_shell(arg, pw, NULL))
			pw_error(NULL, 0, 1);
	}

d194 8
@


1.29
log
@This is ISO C, use string concatenation, instead of bogus use of __CONCAT.
(hint: "a" and "b" can't be pasted as a valid C token...)
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.28 2003/07/01 01:01:28 avsm Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.28 2003/07/01 01:01:28 avsm Exp $";
d83 1
a83 1
	struct passwd *pw = NULL, lpw;
d173 2
d181 2
d240 4
a243 1
		pw_copy(pfd, tfd, pw);
d246 1
a246 1
		if (pw_mkdb(pw->pw_name, 0) == -1)
@


1.28
log
@- no need for pathnames.h, just use <paths.h> instead
- bump mktemp randomness slightly from 8 -> 10
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.27 2003/06/03 02:56:06 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.27 2003/06/03 02:56:06 millert Exp $";
d176 1
a176 1
		char tempname[] = __CONCAT(_PATH_VARTMP,"pw.XXXXXXXXXX");
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.26 2002/07/31 22:08:41 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.26 2002/07/31 22:08:41 millert Exp $";
d56 1
a65 1
#include "pathnames.h"
d176 1
a176 1
		char tempname[] = __CONCAT(_PATH_VARTMP,"pw.XXXXXXXX");
@


1.26
log
@When I got removed the use of atexit() I missed the fact that edit()
calls pw_error() which in turn calls exit().  Now edit() returns
its status so the temp file gets cleaned up nicely if the user makes
no changes or if an error occurred.  Problem noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.25 2002/06/27 22:02:08 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.25 2002/06/27 22:02:08 deraadt Exp $";
@


1.25
log
@move protos
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.24 2002/06/27 19:16:50 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.24 2002/06/27 19:16:50 millert Exp $";
d181 1
d187 1
a187 1
		edit(tempname, pw);
d190 12
@


1.24
log
@There is absolutely no reason for the "tempname" or dfd variables
to exist outside the scope of the 'op == EDITENTRY' code block.
This allows us to get rid of the atexit() call and tempcleanup().
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.23 2002/06/27 19:02:40 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.23 2002/06/27 19:02:40 deraadt Exp $";
d71 2
a74 3

extern char *__progname;

d76 2
a77 5
int use_yp;
int force_yp = 0;
extern struct passwd *ypgetpwnam(), *ypgetpwuid();
int _yp_check(char **);
int pw_yp(struct passwd *, uid_t);
@


1.23
log
@cleanup; mpech & millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.22 2002/03/14 06:51:41 mpech Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.22 2002/03/14 06:51:41 mpech Exp $";
a70 1
char tempname[] = __CONCAT(_PATH_VARTMP,"pw.XXXXXXXX");
a84 1
void	tempcleanup(void);
d184 2
a188 1
		atexit(tempcleanup);
d191 2
a248 7
tempcleanup(void)
{

	unlink(tempname);
}

void
a263 3

	if (op == EDITENTRY)
		unlink(tempname);
@


1.22
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.21 2002/02/16 21:27:44 millert Exp $	*/
d46 2
a47 2
#else 
static char rcsid[] = "$OpenBSD: chpass.c,v 1.21 2002/02/16 21:27:44 millert Exp $";
d91 1
a91 3
main(argc, argv)
	int argc;
	char **argv;
d93 1
a93 1
	struct passwd *pw, lpw;
d95 1
a95 1
	char *arg;
d134 1
a134 1
		errx(1, "cannot load entry using NIS.\n\tUse the -l flag to load local.");
d241 1
a241 1
baduser()
d248 1
a248 1
tempcleanup()
d255 1
a255 2
kbintr(signo)
	int signo;
d278 1
a278 1
usage()
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.20 2001/08/27 02:57:07 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.20 2001/08/27 02:57:07 millert Exp $";
d151 1
a151 1
				errx(1, "unknown user: uid %u\n", uid);
@


1.20
log
@Instead of prompting the user whether or not they wish to continue to
wait for the lock on password file just tell the user to interrupt with
^C.  This simplifies the locking loop a bit.

Update man page to this effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.19 2001/08/16 18:29:27 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.19 2001/08/16 18:29:27 millert Exp $";
d81 2
a82 2
int _yp_check __P((char **));
int pw_yp __P((struct passwd *, uid_t));
d85 4
a88 4
void	baduser __P((void));
void	tempcleanup __P((void));
void	kbintr __P((int));
void	usage __P((void));
@


1.19
log
@extra arg to pw_mkdb
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.18 2001/08/16 16:14:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.18 2001/08/16 16:14:35 millert Exp $";
a56 1
#include <ctype.h>
d96 1
a96 1
	int ch, pfd, tfd, dfd;
a97 1
	char *s = NULL;
d204 6
a209 7
	for (;;) {
		int i, c, d;

		for (i = 0; i < (s ? 64 : 8) && (tfd = pw_lock(0)) == -1; i++) {
			if (i == 0)
				(void)fputs("Please wait", stderr);
			(void)signal(SIGINT, kbintr);
d211 1
a211 20
			usleep(250000);
			(void)signal(SIGINT, SIG_IGN);
		}
		if (i)
			fputc('\n', stderr);
		if (tfd != -1)
			break;

		/* Unable to lock passwd file, let the user decide. */
		if (errno == EEXIST) {
			if (s == NULL)
				s = "The passwd file is busy,";
			else
				s = "The passwd file is still busy,";
		} else
			s = "Unable to open passwd temp file,";
		(void)fprintf(stderr,
		    "%s do you want to wait until it is available? [y/n] ", s);
		(void)signal(SIGINT, kbintr);
		c = getchar();
a212 5
		if (c != '\n')
			while ((d = getchar()) != '\n' && d != EOF)
				;
		if (tolower(c) != 'y')
			pw_error(NULL, 0, 1);
d214 2
@


1.18
log
@At Theo's request only print 'Please wait' if don't get the lock
on the first try.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.17 2001/08/15 20:47:53 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.17 2001/08/15 20:47:53 millert Exp $";
d260 1
a260 1
		if (pw_mkdb(pw->pw_name) == -1)
@


1.17
log
@Move locking of the passwd file *after* we have gotten a new password
from the user.  Set real/effective/saved uids to 0 and block all signals
so the lock cannot be kept longer than necessary.  If we cannot lock,
try again every 1/4 second for 2 seconds and then ask the user what
they wish to do (keep trying, quit).

Same as in local_passwd.c but here we need to remove a temp file
in the SIGINT handler because _exit() doesn't call atexit() routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.16 2000/11/26 01:29:43 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.16 2000/11/26 01:29:43 millert Exp $";
a208 1
		(void)fputs("Please wait", stderr);
d210 2
d217 2
a218 1
		fputc('\n', stderr);
@


1.16
log
@Update for pw_mkdb(3) interface change.  All but vipw and userdel can
specify a username (and thus avoid rebuilding the while database).
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.15 2000/11/21 13:36:14 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.15 2000/11/21 13:36:14 aaron Exp $";
d52 1
d55 1
a55 1
#include <sys/resource.h>
d62 1
d73 1
d88 1
a95 1
	enum { NEWSH, LOADENTRY, EDITENTRY } op;
d99 2
a187 13
	/* Get the passwd lock file and open the passwd file for reading. */
	pw_init();
	tfd = pw_lock(0);
	if (tfd == -1 || fcntl(tfd, F_SETFD, 1) == -1) {
		if (errno == EEXIST)
			errx(1, "the passwd file is busy.");
		else
			err(1, "can't open passwd temp file");
	}
	pfd = open(_PATH_MASTERPASSWD, O_RDONLY, 0);
	if (pfd == -1 || fcntl(pfd, F_SETFD, 1) == -1)
		pw_error(_PATH_MASTERPASSWD, 1, 1);

d198 45
d245 1
a245 1
		if (pw_yp(pw, uid)) {
d247 1
a247 2
			exit(1);
		} else {
d277 24
@


1.15
log
@Sync usage() output with man page; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.14 1999/12/05 20:18:35 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.14 1999/12/05 20:18:35 millert Exp $";
d222 1
a222 1
		if (pw_mkdb() == -1)
@


1.14
log
@Fix temp file unlinking.  We use atexit() since the libutil passwd
routines do their own exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.13 1998/08/03 17:09:46 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.13 1998/08/03 17:09:46 millert Exp $";
d248 3
a250 2
	(void)fprintf(stderr, "usage: %s [-a list] [-s shell] [-l]%s [user]\n",
	    __progname, use_yp?" [-y]":"");
d252 1
a252 1
	(void)fprintf(stderr, "usage: %s [-a list] [-s shell] [user]\n",
@


1.13
log
@use __progname
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.11 1998/05/29 16:37:51 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.11 1998/05/29 16:37:51 millert Exp $";
d70 1
a70 1
char *tempname;
d84 1
d95 1
a95 1
	char *arg, tempname[] = __CONCAT(_PATH_VARTMP,"pw.XXXXXXXX");
d201 1
a203 1
		(void)unlink(tempname);
d234 7
@


1.12
log
@add close on exec flag to all opens
@
text
@a69 1
char *progname = "chpass";
d73 2
d240 2
a241 1
	(void)fprintf(stderr, "usage: chpass [-a list] [-s shell] [-l]%s [user]\n", use_yp?" [-y]":"");
d243 2
a244 1
	(void)fprintf(stderr, "usage: chpass [-a list] [-s shell] [user]\n");
@


1.11
log
@put temp file _PATH_VARTMP
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.10 1998/03/30 06:59:28 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.10 1998/03/30 06:59:28 deraadt Exp $";
d184 1
a184 1
	if (tfd < 0) {
d191 1
a191 1
	if (pfd < 0)
d197 1
a197 1
		if (dfd < 0)
d220 1
a220 1
		if (pw_mkdb() < 0)
@


1.10
log
@Y2K fixes from Andreas.Gunnarsson@@emw.ericsson.se; culled from various places
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.9 1997/06/17 20:49:55 kstailey Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.9 1997/06/17 20:49:55 kstailey Exp $";
d93 1
a93 1
	char *arg, tempname[] = "/etc/pw.XXXXXX";
@


1.9
log
@(foo *)NULL -> NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.8 1997/02/13 17:28:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.8 1997/02/13 17:28:39 deraadt Exp $";
d78 2
@


1.8
log
@fix YP and non-YP cases to exit/warn nicely
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.7 1997/01/15 23:42:18 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.7 1997/01/15 23:42:18 millert Exp $";
d167 2
a168 2
		if (p_shell(arg, pw, (ENTRY *)NULL))
			pw_error((char *)NULL, 0, 1);
d175 1
a175 1
		if (!pw_scan(arg, pw, (int *)NULL))
d205 1
a205 1
			pw_error((char *)NULL, 0, 1);
d219 1
a219 1
			pw_error((char *)NULL, 0, 1);
@


1.7
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.6 1996/10/20 23:45:50 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.6 1996/10/20 23:45:50 millert Exp $";
d213 3
d217 4
a220 6
	/* Copy the passwd file to the lock file, updating pw. */
	pw_copy(pfd, tfd, pw);

	/* Now finish the passwd file update. */
	if (pw_mkdb() < 0)
		pw_error((char *)NULL, 0, 1);
@


1.6
log
@better error message if unable to create password temp file.
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.5 1996/09/23 05:40:47 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.5 1996/09/23 05:40:47 deraadt Exp $";
d98 1
a98 1
	while ((ch = getopt(argc, argv, "a:s:ly")) != EOF)
@


1.5
log
@pw_abort() after yp change, does unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.4 1996/08/31 01:55:32 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.4 1996/08/31 01:55:32 deraadt Exp $";
d182 6
a187 2
	if (tfd < 0)
		errx(1, "the passwd file is busy.");
@


1.4
log
@kill leaks; help from das33@@cornell.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.3 1996/06/26 05:31:54 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.3 1996/06/26 05:31:54 deraadt Exp $";
d203 2
a204 1
		} else
d206 1
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: chpass.c,v 1.8 1996/05/15 21:50:43 jtc Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: chpass.c,v 1.8 1996/05/15 21:50:43 jtc Exp $";
d200 1
a200 1
		if (pw_yp(pw, uid))
d202 2
a203 1
		else
d205 1
a205 2
	}
	else
@


1.2
log
@libutil
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: chpass.c,v 1.8 1996/05/15 21:50:43 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: chpass.c,v 1.7 1995/07/28 07:01:32 phil Exp $	*/
d46 1
a46 1
static char rcsid[] = "$NetBSD: chpass.c,v 1.7 1995/07/28 07:01:32 phil Exp $";
d64 1
a64 4

#include <pw_scan.h>
#include <pw_util.h>
#include "pw_copy.h"
d89 2
a90 2
	int ch, pfd, tfd;
	char *arg;
d178 1
a178 25
	/*
	 * The temporary file/file descriptor usage is a little tricky here.
	 * 1:	We start off with two fd's, one for the master password
	 *	file (used to lock everything), and one for a temporary file.
	 * 2:	Display() gets an fp for the temporary file, and copies the
	 *	user's information into it.  It then gives the temporary file
	 *	to the user and closes the fp, closing the underlying fd.
	 * 3:	The user edits the temporary file some number of times.
	 * 4:	Verify() gets an fp for the temporary file, and verifies the
	 *	contents.  It can't use an fp derived from the step #2 fd,
	 *	because the user's editor may have created a new instance of
	 *	the file.  Once the file is verified, its contents are stored
	 *	in a password structure.  The verify routine closes the fp,
	 *	closing the underlying fd.
	 * 5:	Delete the temporary file.
	 * 6:	Get a new temporary file/fd.  Pw_copy() gets an fp for it
	 *	file and copies the master password file into it, replacing
	 *	the user record with a new one.  We can't use the first
	 *	temporary file for this because it was owned by the user.
	 *	Pw_copy() closes its fp, flushing the data and closing the
	 *	underlying file descriptor.  We can't close the master
	 *	password fp, or we'd lose the lock.
	 * 7:	Call pw_mkdb() (which renames the temporary file) and exit.
	 *	The exit closes the master passwd fp/fd.
	 */
d180 6
a185 2
	pfd = pw_lock();
	tfd = pw_tmp();
d187 1
d189 5
a193 2
		display(tfd, pw);
		edit(pw);
a194 1
		tfd = pw_tmp();
d196 1
a196 1
		
a198 1
		(void)unlink(tempname);
d206 2
d210 2
a211 1
	if (!pw_mkdb())
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
