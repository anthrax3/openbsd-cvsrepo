head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.4
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.18
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.14
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.12
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.10
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.8
	OPENBSD_5_0:1.26.0.6
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.14
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.12
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.10
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.8
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.6
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.6
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.05.03.09.51.39;	author mestre;	state Exp;
branches;
next	1.33;
commitid	CaQOrlCeSyj26bDl;

1.33
date	2015.12.01.00.00.19;	author millert;	state Exp;
branches;
next	1.32;
commitid	Iih0SkfIYIKA9h95;

1.32
date	2015.10.12.14.33.13;	author tim;	state Exp;
branches;
next	1.31;
commitid	VzsVi0IjGALKpyix;

1.31
date	2015.10.09.21.59.34;	author tim;	state Exp;
branches;
next	1.30;
commitid	DVoiJg7RFqjToPA4;

1.30
date	2015.10.09.20.24.37;	author tim;	state Exp;
branches;
next	1.29;
commitid	nbaVm1GCLdJy124s;

1.29
date	2015.10.09.20.14.35;	author tim;	state Exp;
branches;
next	1.28;
commitid	wSBl5J59WbAkC8oI;

1.28
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	6b2lLILbgCR1fvia;

1.27
date	2014.03.20.20.39.13;	author naddy;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.11.20.20.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.28.13.07.26;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.12.16.13.46;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.06.21.45.44;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.06.21.39.31;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.27.23.37.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.04.18.18.20;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.10.18.24.40;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.06.23.34.33;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.28.17.32.04;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.20.17.12.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.12.04.21.27.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.12.04.21.20.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.03.06.20.27.41;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	99.03.06.20.19.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.17.05.48.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.11.22.03.24.36;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.11.03.18.57.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.10.30.01.09.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.10.14.20.45.23;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.29.21.28.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.29.04.33.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.15.41.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.39.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.07;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.07;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Use the safe idiom of cleaning sensitive data from memory with explicit_bzero,
instead of relying on other methods, after readpassphrase. Some programs on
this diff won't benefit that much since it happens near the terminal path, but
someone might copy the unsafe idiom to another program and place it where it
may leak sensitive data.

Discussed aeons ago with tb@@, OK deraadt@@ and beck@@
@
text
@/*	$OpenBSD: skey.c,v 1.33 2015/12/01 00:00:19 millert Exp $	*/
/*
 * OpenBSD S/Key (skey.c)
 *
 * Authors:
 *          Neil M. Haller <nmh@@thumper.bellcore.com>
 *          Philip R. Karn <karn@@chicago.qualcomm.com>
 *          John S. Walden <jsw@@thumper.bellcore.com>
 *          Scott Chasin <chasin@@crimelab.com>
 *          Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 *
 * Stand-alone program for computing responses to S/Key challenges.
 * Takes the iteration count and seed as command line args, prompts
 * for the user's key, and produces both word and hex format responses.
 *
 * Usage example:
 *	>skey 88 ka9q2
 *	Enter password:
 *	OMEN US HORN OMIT BACK AHOY
 *	>
 *
 */

#include <err.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <readpassphrase.h>
#include <skey.h>

void usage();

extern char *__progname;

int
main(int argc, char *argv[])
{
	int     n, i, cnt = 1, pass = 0, hexmode = 0;
	char    passwd[SKEY_MAX_PW_LEN+1], key[SKEY_BINKEY_SIZE];
	char	buf[33], *seed, *slash, *algo;
	const char *errstr;

	if (pledge("stdio tty", NULL) == -1)
		err(1, "pledge");

	/* If we were called as otp-METHOD, set algorithm based on that */
	if (strncmp(__progname, "otp-", 4) == 0) {
		algo = __progname + 4;
		if (skey_set_algorithm(algo) == NULL)
			errx(1, "Unknown hash algorithm %s", algo);
	}

	for (i = 1; i < argc && argv[i][0] == '-' && strcmp(argv[i], "--");) {
		if (argv[i][2] == '\0') {
			/* Single character switch */
			switch (argv[i][1]) {
			case 'n':
				if (++i == argc)
					usage();
				cnt = strtonum(argv[i], 1, SKEY_MAX_SEQ -1, &errstr);
				if (errstr)
					usage();
				break;
			case 'p':
				if (++i == argc)
					usage();
				if (strlcpy(passwd, argv[i], sizeof(passwd)) >=
				    sizeof(passwd))
					errx(1, "Password too long");
				pass = 1;
				break;
			case 'x':
				hexmode = 1;
				break;
			default:
				usage();
			}
		} else {
			/* Multi character switches are hash types */
			if (skey_set_algorithm(&argv[i][1]) == NULL) {
				warnx("Unknown hash algorithm %s", &argv[i][1]);
				usage();
			}
		}
		i++;
	}

	if (argc > i + 2)
		usage();

	/* Could be in the form <number>/<seed> */
	if (argc <= i + 1) {
		/* look for / in it */
		if (argc <= i)
			usage();
		slash = strchr(argv[i], '/');
		if (slash == NULL)
			usage();
		*slash++ = '\0';
		seed = slash;

		n = strtonum(argv[i], 0, SKEY_MAX_SEQ, &errstr);
		if (errstr) {
			warnx("%s: %s", argv[i], errstr);
			usage();
		}
	} else {
		n = strtonum(argv[i], 0, SKEY_MAX_SEQ, &errstr);
		if (errstr) {
			warnx("%s: %s", argv[i], errstr);
			usage();
		}
		seed = argv[++i];
	}

	/* Get user's secret passphrase */
	if (!pass && (readpassphrase("Enter secret passphrase: ", passwd,
	    sizeof(passwd), 0) == NULL || passwd[0] == '\0'))
		exit(1);

	/* Crunch seed and passphrase into starting key */
	if (keycrunch(key, seed, passwd) != 0) {
		explicit_bzero(passwd, sizeof(passwd));
		errx(1, "key crunch failed");
	}

	explicit_bzero(passwd, sizeof(passwd));

	if (cnt == 1) {
		while (n-- != 0)
			f(key);
		(void)puts(hexmode ? put8(buf, key) : btoe(buf, key));
	} else {
		for (i = 0; i <= n - cnt; i++)
			f(key);
		for (; i <= n; i++) {
			if (hexmode)
				(void)printf("%d: %s\n", i, put8(buf, key));
			else
				(void)printf("%d: %-29s\n", i, btoe(buf, key));
			f(key);
		}
	}
	exit(0);
}

void
usage(void)
{
	fprintf(stderr,
	    "usage: %s [-x] [-md5 | -rmd160 | -sha1] [-n count]\n\t"
	    "[-p passphrase] <sequence#>[/] key\n", __progname);
	exit(1);
}
@


1.33
log
@We no longer need pledge "wpath" since "tty" allows read-write on
/dev/tty.
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.32 2015/10/12 14:33:13 tim Exp $	*/
d125 2
a126 1
	if (keycrunch(key, seed, passwd) != 0)
d128 3
@


1.32
log
@Pledge "stdio wpath tty"; "awesome" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.31 2015/10/09 21:59:34 tim Exp $	*/
d46 1
a46 1
	if (pledge("stdio wpath tty", NULL) == -1)
@


1.31
log
@Remove telnet warnings. Civilization has reached a point where they are no
longer relevant.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.30 2015/10/09 20:24:37 tim Exp $	*/
d45 3
@


1.30
log
@Use __progname rather than argv[0]; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.29 2015/10/09 20:14:35 tim Exp $	*/
d117 3
a119 7
	if (!pass) {
		fputs("Reminder - Do not use this program while"
		    " logged in via telnet.\n", stderr);
		if (readpassphrase("Enter secret passphrase: ", passwd,
		    sizeof(passwd), 0) == NULL || passwd[0] == '\0')
			exit(1);
	}
@


1.29
log
@Replace readpass(3) with readpassphrase(3). This was the only use of
readpass(3) in base...

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.28 2015/04/18 18:28:38 deraadt Exp $	*/
d34 3
a36 1
void    usage(char *);
d43 1
a43 1
	char	buf[33], *seed, *slash;
d47 4
a50 8
	if ((slash = strrchr(argv[0], '/')))
		slash++;
	else
		slash = argv[0];
	if (strncmp(slash, "otp-", 4) == 0) {
		slash += 4;
		if (skey_set_algorithm(slash) == NULL)
			errx(1, "Unknown hash algorithm %s", slash);
d59 1
a59 1
					usage(argv[0]);
d62 1
a62 1
					usage(argv[0]);
d66 1
a66 1
					usage(argv[0]);
d76 1
a76 1
				usage(argv[0]);
d82 1
a82 1
				usage(argv[0]);
d89 1
a89 1
		usage(argv[0]);
d95 1
a95 1
			usage(argv[0]);
d98 1
a98 1
			usage(argv[0]);
d105 1
a105 1
			usage(argv[0]);
d111 1
a111 1
			usage(argv[0]);
d148 1
a148 1
usage(char *s)
d152 1
a152 1
	    "[-p passphrase] <sequence#>[/] key\n", s);
@


1.28
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.27 2014/03/20 20:39:13 naddy Exp $	*/
d25 2
a29 1
#include <err.h>
d31 1
a31 1
#include <limits.h>
d122 2
a123 3
		(void)fputs("Enter secret passphrase: ", stderr);
		readpass(passwd, sizeof(passwd));
		if (passwd[0] == '\0')
@


1.27
log
@Remove the (non-default) MD4 hash algorithm from S/Key.
ok millert, man pages ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.26 2010/04/11 20:20:29 millert Exp $	*/
d30 1
d41 1
d61 3
a63 1
				cnt = atoi(argv[i]);
d103 3
a105 5
		if ((n = atoi(argv[i])) < 0) {
			warnx("%d not positive", n);
			usage(argv[0]);
		} else if (n > SKEY_MAX_SEQ) {
			warnx("%d is larger than max (%d)", n, SKEY_MAX_SEQ);
d109 3
a111 5
		if ((n = atoi(argv[i])) < 0) {
			warnx("%d not positive", n);
			usage(argv[0]);
		} else if (n > SKEY_MAX_SEQ) {
			warnx("%d is larger than max (%d)", n, SKEY_MAX_SEQ);
@


1.26
log
@Fix typo in line ending; from Antti Harri
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.25 2010/02/28 13:07:26 millert Exp $	*/
d153 1
a153 1
	    "usage: %s [-x] [-md4 | -md5 | -rmd160 | -sha1] [-n count]\n\t"
@


1.25
log
@In -x mode, if count was > 1 we would print both the hex and ascii versions
of the response (for count == 1 only the hex version was printed).  Make
things consistent and match the docs by only printing the hex mode even
if count > 1.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.24 2008/11/12 16:13:46 sobrado Exp $	*/
d142 1
a142 1
				(void)printf("%d: %-29s\b", i, btoe(buf, key));
@


1.24
log
@Usage -> usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.23 2005/07/06 21:45:44 jmc Exp $	*/
a138 1
			(void)printf("%d: %-29s", i, btoe(buf, key));
d140 3
a142 2
				(void)printf("  %s", put8(buf, key));
			putchar('\n');
@


1.23
log
@alter spacing of usage() so we don;t get a line break if skey is
invoked as otp-rmd160;
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.22 2005/07/06 21:39:31 jmc Exp $	*/
d153 1
a153 1
	    "Usage: %s [-x] [-md4 | -md5 | -rmd160 | -sha1] [-n count]\n\t"
@


1.22
log
@- tidy up SYNOPSIS
- sort options
- sync usage()
- other small tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.21 2004/12/27 23:37:48 deraadt Exp $	*/
d153 2
a154 2
	    "Usage: %s [-x] [-md4 | -md5 | -rmd160 | -sha1] [-n count] "
	    "[-p passphrase]\n\t<sequence#>[/] key\n", s);
@


1.21
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.20 2004/06/04 18:18:20 otto Exp $	*/
d153 2
a154 2
	    "Usage: %s [-x] [-md4|-md5|-sha1|-rmd160] [-n count] "
	    "[-p passphrase] <sequence#>[/] key\n", s);
@


1.20
log
@Consistently use "secret passphrase" for the passphrase made up by the user
and "one-time password" for the generated passwords.
ok jmc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.19 2003/06/10 18:24:40 deraadt Exp $	*/
d123 1
a123 1
		if (passwd[0] == '\0') 
@


1.19
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.18 2002/05/06 23:34:33 millert Exp $	*/
d117 1
a117 1
	/* Get user's secret password */
d121 1
a121 1
		(void)fputs("Enter secret password: ", stderr);
d127 1
a127 1
	/* Crunch seed and password into starting key */
d154 1
a154 1
	    "[-p password] <sequence#>[/] key\n", s);
@


1.18
log
@Kill/adjust r(login|exec)d? references now that those are no longer in
the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.17 2002/02/16 21:27:52 millert Exp $	*/
d35 1
a35 3
main(argc, argv)
	int	argc;
	char	*argv[];
d119 2
a120 1
		(void)fputs("Reminder - Do not use this program while logged in via telnet.\n", stderr);
d150 1
a150 2
usage(s)
	char *s;
d152 3
a154 1
	(void)fprintf(stderr, "Usage: %s [-x] [-md4|-md5|-sha1|-rmd160] [-n count] [-p password] <sequence#>[/] key\n", s);
@


1.17
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.16 2001/12/28 17:32:04 millert Exp $	*/
d121 1
a121 1
		(void)fputs("Reminder - Do not use this program while logged in via telnet or rlogin.\n", stderr);
@


1.16
log
@Fix hex mode (-x), based on patch from David Gullasch
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.15 2001/06/20 17:12:30 millert Exp $	*/
d32 1
a32 1
void    usage __P((char *));
@


1.15
log
@cosmetic changes and mention RFC2289 which supercedes RFC1938
@
text
@d1 1
a1 1
/*	$OpenBSD: skey.c,v 1.14 1999/12/04 21:27:18 deraadt Exp $	*/
d140 1
d142 2
a143 4
				(void)printf("%d: %-29s  %s\n", i,
				    btoe(buf, key), put8(buf, key));
			else
				(void)printf("%d: %-29s\n", i, btoe(buf, key));
@


1.14
log
@oops
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.13 1999/12/04 21:20:20 deraadt Exp $*/
d3 1
a3 1
 * S/KEY v1.1b (skey.c)
d10 1
d45 1
a45 1
	    slash++;
d47 1
a47 1
	    slash = argv[0];
d59 1
a59 1
				if (i + 1 == argc)
d61 1
a61 1
				cnt = atoi(argv[++i]);
d64 1
a64 1
				if (i + 1 == argc)
d66 1
a66 1
				if (strlcpy(passwd, argv[++i], sizeof(passwd)) >=
d153 1
a153 1
	char   *s;
@


1.13
log
@oflow
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.12 1999/03/06 20:27:41 millert Exp $*/
d65 1
a65 1
				if (strlcpy(passwd, argv[++i], sizeof(passwd)) >
@


1.12
log
@back out changes that should not have escaped my local tree
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.10 1997/07/17 05:48:40 millert Exp $*/
d65 3
a67 1
				(void)strcpy(passwd, argv[++i]);
@


1.11
log
@add missing reference to infocmp
@
text
@d40 1
a40 1
	char	bufs[33], bufh[33], *seed, *slash;
d132 1
a132 1
		(void)puts(hexmode ? put8(bufh, key) : btoe(bufs, key));
d139 1
a139 1
				    btoe(bufs, key), put8(bufh, key));
d141 1
a141 1
				(void)printf("%d: %-29s\n", i, btoe(bufs, key));
@


1.10
log
@Add RIPEMD-160 (rmd160) support to OTP (s/key).
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.9 1996/11/22 03:24:36 millert Exp $*/
d40 1
a40 1
	char	buf[33], *seed, *slash;
d132 1
a132 1
		(void)puts(hexmode ? put8(buf, key) : btoe(buf, key));
d139 1
a139 1
				    btoe(buf, key), put8(buf, key));
d141 1
a141 1
				(void)printf("%d: %-29s\n", i, btoe(buf, key));
@


1.9
log
@fix thinko wrt otp-* handling
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.8 1996/11/03 18:57:14 millert Exp $*/
d152 1
a152 1
	(void)fprintf(stderr, "Usage: %s [-x] [-md4|-md5|-sha1] [-n count] [-p password] <sequence#>[/] key\n", s);
@


1.8
log
@Use new length/size macros.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.7 1996/10/30 01:09:23 millert Exp $*/
d43 8
a50 3
	if (strncmp(argv[0], "otp-", 4) == 0) {
		if (skey_set_algorithm(&argv[0][4]) == NULL)
			errx(1, "Unknown hash algorithm %s", &argv[0][4]);
d107 1
a107 1
			warnx("%s not positive", argv[i]);
@


1.7
log
@Give usage and exit if user gave us too many args.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.6 1996/10/14 20:45:23 millert Exp $*/
d39 2
a40 1
	char    passwd[256], key[8], buf[33], *seed, *slash;
d94 4
a97 1
			warnx("%s not positive", argv[i]);
d103 3
@


1.6
log
@Exit on empty "secret password" like skeyinit does.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.5 1996/09/29 21:28:38 millert Exp $*/
d77 3
@


1.5
log
@Towards RFC 1938 compliance.  Works with new libskey and supports SHA.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.4 1996/09/29 04:33:58 millert Exp $*/
d106 2
a108 1
	rip(passwd);
@


1.4
log
@Added support for MD4/MD5 as an argument.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.3 1996/09/27 15:41:36 millert Exp $*/
d41 4
a44 19
	while ((i = getopt(argc, argv, "n:p:x45")) != EOF) {
		switch (i) {
		case 'n':
			cnt = atoi(optarg);
			break;
		case 'p':
			strcpy(passwd, optarg);
			pass = 1;
			break;
		case 'x':
			hexmode = 1;
			break;
		case '4':
			skey_set_MDX(4);
			break;
		case '5':
			skey_set_MDX(5);
			break;
		}
d47 27
a73 8
	/* check for md4/md5 argument */
	if (argv[optind]) {
		if (strcmp(argv[optind], "MD4") == 0) {
			skey_set_MDX(4);
			optind++;
		} else if (strcmp(argv[optind], "MD5") == 0) {
			skey_set_MDX(5);
			optind++;
d75 1
d78 2
a79 2
	/* could be in the form <number>/<seed> */
	if (argc <= optind + 1) {
d81 1
a81 1
		if (argc <= optind)
d83 1
a83 1
		slash = strchr(argv[optind], '/');
d89 2
a90 2
		if ((n = atoi(argv[optind])) < 0) {
			warnx("%s not positive", argv[optind]);
d94 2
a95 2
		if ((n = atoi(argv[optind])) < 0) {
			warnx("%s not positive", argv[optind]);
d98 1
a98 1
		seed = argv[++optind];
d136 1
a136 1
	(void)fprintf(stderr, "Usage: %s [-x] [-4|-5] [-n count] [-p password] [MD4|MD5] sequence# [/] key", s);
@


1.3
log
@Now can both MD4 and MD5 skey's.
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.2 1996/06/26 05:39:20 deraadt Exp $*/
d62 11
a73 1

d131 1
a131 1
	(void)fprintf(stderr, "Usage: %s [-x] [-4|-5] [-n count] [-p password ] sequence# [/] key", s);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/* * $OpenBSD: skey.c,v 1.1.1.1 1995/10/18 08:46:07 deraadt Exp $*/
a23 1
#include <sys/cdefs.h>
d27 3
a29 4
#include <fcntl.h>
#include <sgtty.h>
#include "md4.h"
#include "skey.h"
d38 1
a38 1
	int     n, cnt, i, pass = 0;
a39 2
	extern int optind;
	extern char *optarg;
d41 1
a41 3
	cnt = 1;

	while ((i = getopt(argc, argv, "n:p:")) != EOF) {
d50 9
d75 1
a75 1
			fprintf(stderr, "%s not positive\n", argv[optind]);
a78 1

d80 1
a80 1
			fprintf(stderr, "%s not positive\n", argv[optind]);
d88 2
a89 1
		fprintf(stderr, "Enter secret password: ");
d95 3
a97 4
	if (keycrunch(key, seed, passwd) != 0) {
		fprintf(stderr, "%s: key crunch failed\n", argv[0]);
		exit(1);
	}
d101 1
a101 4
		printf("%s\n", btoe(buf, key));
#ifdef	HEXIN
		printf("%s\n", put8(buf, key));
#endif
d106 5
a110 5
#ifdef	HEXIN
			printf("%d: %-29s  %s\n", i, btoe(buf, key), put8(buf, key));
#else
			printf("%d: %-29s\n", i, btoe(buf, key));
#endif
d121 1
a121 3

	fprintf(stderr,
	    "Usage: %s [-n count] [-p password ] sequence# [/] key\n", s);
@


1.1
log
@Initial revision
@
text
@d1 1
a21 1
 * $Id: skey.c,v 1.3 1995/06/05 19:55:40 pk Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
