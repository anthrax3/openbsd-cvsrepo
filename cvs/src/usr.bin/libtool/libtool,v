head	1.42;
access;
symbols
	OPENBSD_6_0:1.42.0.10
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.6
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.8
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.8
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.4
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37;
locks; strict;
comment	@# @;


1.42
date	2014.03.19.02.16.22;	author afresh1;	state Exp;
branches;
next	1.41;

1.41
date	2014.03.06.08.58.43;	author ajacoutot;	state Exp;
branches;
next	1.40;

1.40
date	2013.02.02.13.45.11;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2013.02.01.05.21.20;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.27.10.11.23;	author espie;	state Exp;
branches;
next	1.37;

1.37
date	2012.07.11.08.33.45;	author espie;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.10.13.32.10;	author espie;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.10.12.24.45;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.10.09.51.32;	author espie;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.09.23.13.29;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.09.21.52.03;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.09.18.40.53;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.09.17.52.21;	author espie;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.09.13.38.37;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.09.12.53.05;	author espie;	state Exp;
branches;
next	1.27;

1.27
date	2012.07.09.10.52.26;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.09.10.34.52;	author espie;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.09.10.17.04;	author espie;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.08.12.29.21;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.08.10.42.25;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.08.09.36.31;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2012.07.07.21.45.15;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.07.21.42.22;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.07.21.29.14;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.07.21.09.27;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.07.18.21.56;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.07.18.08.11;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.07.16.48.53;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2012.07.06.19.18.49;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.06.11.30.40;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.04.15.08.40;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.04.15.03.49;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.04.12.39.34;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.01.17.22.47;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.01.17.22.28;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.28.18.24.42;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.27.10.33.51;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.27.09.34.09;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.24.20.56.57;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.24.13.44.53;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.19.18.56.07;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.19.09.30.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove lexical $_ from libtool in preparation for perl 5.18

OK and additional changes from espie@@
@
text
@#!/usr/bin/perl
# $OpenBSD: libtool,v 1.41 2014/03/06 08:58:43 ajacoutot Exp $

# Copyright (c) 2007-2010 Steven Mestdagh <steven@@openbsd.org>
# Copyright (c) 2012 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;
use feature qw(say switch state);
use Cwd qw(getcwd);
use File::Glob ':glob';

use LT::Trace;
use LT::Exec;
use LT::Util;
use LT::Getopt;

$SIG{__DIE__} = sub {
	require Carp;

	my $message = pop @@_;
	$message =~ s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $message;
	die &Carp::longmess;
};

package LT::OSConfig;

use Config;
use LT::Util;

my @@picflags =qw(-fPIC -DPIC);

sub new
{
	    my $class = shift;
	    # XXX: incomplete
	    my $self = bless {
		machine_arch => $Config{ARCH},
		ltdir => $ltdir,
		version => $version,
		objdir => $ltdir, 
		build_old_libs => 'yes',
		pic_flags => join(' ', @@picflags),
	    }, $class;
	    ($self->{gnu_arch} = $self->{machine_arch}) =~ s/amd64/x86_64/;

	    if (grep { $_ eq $self->{machine_arch} } qw(vax)) {
		$self->{build_libtool_libs} = 'yes';
		$self->{noshared} = 1;
	    } else {
		$self->{build_libtool_libs} = 'no';
		$self->{noshared} = 0;
	    }
	    if (grep { $_ eq $self->{machine_arch} } qw(vax)) {
		$self->{elf} = 0;
	    } else {
		$self->{elf} = 1;
	    }

	    return $self;
}

sub noshared
{
	my $self = shift;
	return $self->{noshared};
}

sub host
{
	my $self = shift;
	if (!defined $self->{osversion}) {
		chomp($self->{osversion} = `uname -r`);
	}
	return "$self->{gnu_arch}-unknown-openbsd$self->{osversion}";
}

# XXX
sub picflags
{
	my $self = shift;
	return \@@picflags;
}

sub sharedflag
{
	return '-shared';
}

sub version
{
	my $self = shift;
	return $self->{version};
}

sub dump
{
	my $self = shift;
	for my $key (sort keys %$self) {
		say "$key=$self->{$key}";
	}
}

package LT::Mode;
use LT::Util;

sub new
{
	my ($class, $origin) = @@_;
	bless {origin => $origin }, $class;
}

sub load_subclass
{
	my ($self, $class) = @@_;
	local $SIG{__DIE__} = 'DEFAULT';
	eval "require $class;";
	if ($@@) {
		unless ($@@ =~ m/^Can't locate .* in \@@INC/) {
			say STDERR $@@;
			exit 1;
		}
	}
}

my $mode_maker = { compile => 'LT::Mode::Compile', 
	clean => 'LT::Mode::Clean',
	execute => 'LT::Mode::Execute',
	finish => 'LT::Mode::Finish',
	install => 'LT::Mode::Install',
	link => 'LT::Mode::Link',
	uninstall => 'LT::Mode::Uninstall' };

sub factory
{
	my ($class, $mode, $origin) = @@_;
	my $s = $mode_maker->{$mode};
	if ($s) {
		$class->load_subclass($s);
		return $s->new($origin);
	} else {
		shortdie "Mode=$mode not implemented yet.\n";
	}
}

sub help
{
}

sub help_all
{
	my $class = shift;
	for my $s (sort values %$mode_maker) {
		$class->load_subclass($s);
		$s->help;
	}
}

package LT::Mode::Empty;
our @@ISA = qw(LT::Mode);
sub run
{
	exit 0;
}

package LT::Mode::Clean;
our @@ISA = qw(LT::Mode::Empty);
sub help
{
	print <<"EOH";

Usage: $0 --mode=clean RM [RM-Option]... FILE...
has not been implemented.
It should remove files from the build directory.
EOH
}

package LT::Mode::Execute;
our @@ISA = qw(LT::Mode);
sub run
{
	my ($class, $ltprog, $gp, $ltconfig) = @@_;
	# XXX check whether this is right
	LT::Exec->silent_run;
	LT::Exec->execute(@@$ltprog, @@main::ARGV);
}

sub help
{
	print <<"EOH";

Usage: $0 --mode=execute COMMAND  [ARGS...]
Run a program after setting correct library path.
EOH
}


package LT::Mode::Finish;
our @@ISA = qw(LT::Mode::Empty);
sub help
{
	print <<"EOH";

Usage: $0 --mode=finish [LIBDIR}...
Complete the installation of libtool libraries.
Not needed for our usage.
EOH
}

package LT::Mode::Uninstall;
our @@ISA = qw(LT::Mode::Empty);
sub help
{
	print <<"EOH";

Usage: $0 --mode=uninstall RM [RM-OPTION]... FILE...
has not been implemented
It should remove libraries from an installation directory.
EOH
}

package LT::Options;
use LT::Util;
our @@ISA = qw(LT::Getopt);

my @@valid_modes = qw(compile clean execute finish install link uninstall);

my @@known_tags = qw(disable-shared disable-static CC CXX F77 FC GO GCJ RC);

sub new
{
	my $class = shift;
	my $o = bless {}, $class;
	return $o;
}

sub add_tag
{
	my ($self, $value) = @@_;
	if ($value =~ m/[^\-\w,\/]/) {
		shortdie "invalid tag name: $value"; 
		exit 1;
	} 
	if (grep {$value eq $_} @@known_tags) {
		$self->{tags}{$value} = 1;
	} else {
		say STDERR "ignoring unknown tag: $value";
	}
}

sub has_tag
{
	my ($self, $tag) = @@_;
	return defined $self->{tags}{$tag};
}

sub is_abreviated_mode
{
	my ($self, $arg) = @@_;
	return undef if !$arg;
	for my $m (@@valid_modes) {
		next if length $arg > length $m;
		if ($arg eq substr($m, 0, length $arg)) {
			return LT::Mode->factory($m, $arg);
		}
	}
	return undef;
}

# XXX this should always fail if we are libtool2 !
# try to guess libtool mode when it is not specified
sub guess_implicit_mode
{
	my ($self, $ltprog) = @@_;
	my $m;
	for my $a (@@$ltprog) {
	   if ($a =~ m/(install([.-](sh|check))?|cp)$/) {
		$m = LT::Mode->factory('install', "implicit $a");
	   } elsif ($a =~ m/cc|c\+\+/) {	# XXX improve test
		if (grep { $_ eq '-c' } @@ARGV) {
			$m = LT::Mode->factory('compile', "implicit");
		} else {
			$m = LT::Mode->factory('link',  "implicit");
		}
	   }
	}
	return $m;
}

sub valid_modes
{
	my $self = shift;
	return join(' ', @@valid_modes);
}

package main;

my $ltconfig = LT::OSConfig->new;
my $cwd = getcwd();
my $mode;
my $verbose = 1;
my $help = 0;


# XXX compat game to satisfy both libtool 1 and libtool 2
unless ($ARGV[0] eq 'install' && $ARGV[1] =~ m/^-[bcCdpSsBfgmo]/) {
	if ($mode = LT::Options->is_abreviated_mode($ARGV[0])) {
		shift @@ARGV;
	}
}

# just to be clear:
# when building a library:
# 	* -R libdir records libdir in dependency_libs
# 	* -rpath is the path where the (shared) library will be installed
# when building a program:
# 	* both -R libdir and -rpath libdir add libdir to the run-time path
# -Wl,-rpath,libdir will bypass libtool.

my $gp = LT::Options->new;
$gp->handle_options(
    '-config' => \&config,
    '-debug|x' => sub { 
		    LT::Trace->set(1); 
		    LT::Exec->verbose_run;
		},
    '-dry-run|-dryrun|n' => sub { LT::Exec->dry_run; },
    '-features' => sub {
		say "host: ", $ltconfig->host;
		say "enable shared libraries" unless $ltconfig->noshared;
		say "enable static libraries";
		exit 0;
	    },
    '-finish' => sub { $mode = LT::Mode->factory('finish', '--finish'); },
    '-help|?|h' => sub { $help = 1; },
    '-help-all' => sub { basic_help(); LT::Mode->help_all; exit 0; },
    '-mode=' => sub {
		    $mode = LT::Mode->factory($_[2], "--mode=$_[2]");
		},
    '-quiet|-silent|-no-verbose' => sub { $verbose = 0; },
    '-verbose|-no-silent|-no-quiet|v' => sub {$verbose = 1;},
    '-tag=' => sub { $gp->add_tag($_[2]); },
    '-version' => sub { 
		    say "libtool (not (GNU libtool)) ", $ltconfig->version;
		    exit 0;
		},
    '-no-warning|-no-warn' => sub {},
    # ignored
    '-preserve-dup-deps',
    '-dlopen=|dlopen=@@',
);

if ($help) {
	basic_help();
	if ($mode) {
		$mode->help;
	}
	exit 0;
}
if ($verbose) {
	LT::Exec->verbose_run;
}

# what are we going to run (cc, c++, ...)
my $ltprog = [];
# deal with multi-arg ltprog
tsay {"ARGV = \"@@ARGV\""};
while (@@ARGV) {
	# just read arguments until the next option...
	if ($ARGV[0] =~ m/^\-/) { last; }
	# XXX improve checks
	if ($ARGV[0] =~ m/^\S+\.la/) { last; }
	my $arg = shift @@ARGV;
	push @@$ltprog, $arg;
	tsay {"arg = \"$arg\""};
	# if the current argument is an install program, stop immediately
	if ($arg =~ /cp$/) { last; }
	if ($arg =~ /install([-.](sh|check))?$/) { last; }
}
tsay {"ltprog = \"@@$ltprog\""};

# XXX compat game to satisfy both libtool 1 and libtool 2
# let libtool install work as both libtool 1 and libtool 2
if (@@$ltprog == 0 && defined $mode && $mode->{origin} eq 'install') {
	$ltprog = [ 'install' ];
}

if (@@$ltprog == 0) { die "No libtool command given.\n" .
			 "Use `libtool --help' for more information.\n" };
# make ltprog a list of elements without whitespace (prevent exec errors)
my @@tmp_ltprog = @@$ltprog;
@@$ltprog = ();
for my $el (@@tmp_ltprog) {
	my @@parts = split /\s+/, $el;
	push @@$ltprog, @@parts;
}

if (!defined $mode) {
	$mode = $gp->guess_implicit_mode($ltprog);
	tsay {"implicit mode: ", $mode->{origin}} if $mode;
}

if (!defined $mode) {
	shortdie "no explicit mode, couldn't figure out implicit mode\n";
}

if (!$mode->isa("LT::Mode::Execute")) {
	if ($gp->dlopen)  {
		shortdie "Error: -dlopen FILE  in generic libtool options is an error in non execute mode";
	}
}

# from here, options may be intermixed with arguments

$mode->run($ltprog, $gp, $ltconfig);

if (LT::Exec->performed == 0) {
	die "No commands to execute.\n"
}

###########################################################################

sub basic_help
{
	print <<EOF
Usage: $0 [options]
--config - print configuration
--debug - turn on debugging output
--dry-run - don't do anything, only show what would be done
--help - this message
--mode=MODE - use operation mode MODE
--quiet - do not print informational messages
--silent - same as `--quiet'
--tag=TAG - specify a configuration variable TAG
--version - print version of libtool
EOF
;
}

sub config
{
	$ltconfig->dump;
	exit 0;
}

@


1.41
log
@Also accept "install-check" as an install script. This part will
probably be reworked and simplified in the future anyway...

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.40 2013/02/02 13:45:11 brad Exp $
d33 3
a35 3
	my $_ = pop @@_;
	s/(.*)( at .*? line .*?\n$)/$1/s;
	push @@_, $_;
@


1.40
log
@m68k has switched to ELF.

ok miod@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.39 2013/02/01 05:21:20 brad Exp $
d290 1
a290 1
	   if ($a =~ m/(install([.-]sh)?|cp)$/) {
d391 1
a391 1
	if ($arg =~ /install([-.]sh)?$/) { last; }
@


1.39
log
@m88k has switched to ELF and has shared libs.

ok miod@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.38 2012/10/27 10:11:23 espie Exp $
d67 1
a67 1
	    if (grep { $_ eq $self->{machine_arch} } qw(m68k vax)) {
@


1.38
log
@mark elf architectures as well
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.37 2012/07/11 08:33:45 espie Exp $
d60 1
a60 1
	    if (grep { $_ eq $self->{machine_arch} } qw(m88k vax)) {
d67 1
a67 1
	    if (grep { $_ eq $self->{machine_arch} } qw(m68k m88k vax)) {
@


1.37
log
@nit: bless object early so we can use methods on it
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.36 2012/07/10 13:32:10 espie Exp $
d66 5
@


1.36
log
@bye-bye Getopt::Long
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.35 2012/07/10 12:24:45 espie Exp $
d50 1
a50 1
	    my $self = {
d57 1
a57 1
	    };
d68 1
a68 1
	    bless $self, $class;
@


1.35
log
@clean-up shit, pull some of LT::Util into ltconfig object
make that a somewhat more "real" object...
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.34 2012/07/10 09:51:32 espie Exp $
a262 12
}

sub getoptions
{
	my $o = shift;
	require Getopt::Long;
	my $p = Getopt::Long::Parser->new;
	$p->configure('no_ignore_case',
	    'pass_through',
	    'no_auto_abbrev',
	    'permute');
	$p->getoptions(@@_);
@


1.34
log
@more config, sort stuff for easier spotting
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.33 2012/07/09 23:13:29 espie Exp $
d44 2
d48 22
a69 19
    my $class = shift;
    # XXX: incomplete
    my $self = {
	machine_arch => $Config{ARCH},
	ltdir => $ltdir,
	version => $version,
	objdir => $ltdir, 
	build_old_libs => 'yes',
	pic_flags => join(' ', @@picflags),
    };
    ($self->{gnu_arch} = $self->{machine_arch}) =~ s/amd64/x86_64/;

    if (grep { $_ eq $self->{machine_arch} } qw(m88k vax)) {
	$self->{build_libtool_libs} = 'yes';
	$self->{noshared} = 1;
    } else {
	$self->{build_libtool_libs} = 'no';
	$self->{noshared} = 0;
    }
d71 31
a101 1
    bless $self, $class;
d190 1
a190 1
	my ($class, $ltprog, $gp, $noshared) = @@_;
d349 2
a350 4
		my $v = `uname -r`;
		chomp $v;
		say "host: $ltconfig->{gnu_arch}-unknown-openbsd$v";
		say "enable shared libraries" unless $ltconfig->{noshared};
d364 1
a364 1
		    say "libtool (not (GNU libtool)) $ltconfig->{version}";
d435 1
a435 1
$mode->run($ltprog, $gp, $ltconfig->{noshared});
@


1.33
log
@--config had better match more stupid shit.
should fix devel/avr
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.32 2012/07/09 21:52:03 espie Exp $
a23 1
use File::Path;
d53 1
d59 1
d62 1
d72 2
a73 2
	while (my ($key, $value) = each(%$self)) {
		print "$key=$value\n";
@


1.32
log
@start ditching Getopt::Long, only LT::Mode::Link uses it, so make it
autoload only when absolutely required.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.31 2012/07/09 18:40:53 espie Exp $
d53 1
d71 1
a71 1
		print "$key = $value\n";
@


1.31
log
@more compat shit for libtool1/libtool2 schizophrenia
should fix print/pdflib
found out by jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.30 2012/07/09 17:52:21 espie Exp $
a192 1
use Getopt::Long;
d203 1
a203 7
	my $o = bless { gp => Getopt::Long::Parser->new }, $class;
# require_order so we stop parsing at the first non-option or argument,
# instead of parsing the whole ARGV.
	$o->{gp}->configure('no_ignore_case',
	    'pass_through',
	    'no_auto_abbrev',
	    'require_order');
a226 6
sub configure
{
	my $o = shift;
	$o->{gp}->configure(@@_);
}

d230 7
a236 1
	$o->{gp}->getoptions(@@_);
a397 1
$gp->configure('permute');
@


1.30
log
@a bit more scaffolding to distinguish between syntax errors during compilation
and non existent files (which is normal here).
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.29 2012/07/09 13:38:37 espie Exp $
d293 8
a308 4
if ($mode = LT::Options->is_abreviated_mode($ARGV[0])) {
	shift @@ARGV;
}

d378 1
@


1.29
log
@create mode objects thru factory always: uniform require.
use getopt array mode for simpler test
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.28 2012/07/09 12:53:05 espie Exp $
d83 13
d107 4
a110 3
	if (defined $mode_maker->{$mode}) {
		eval "require $mode_maker->{$mode};";
		return $mode_maker->{$mode}->new($origin);
d122 4
a125 4
	for my $class (sort values %$mode_maker) {
		# XXX autoload *if needed*.
		eval "require $class; ";
		$class->help;
@


1.28
log
@somehow, the require is not enough for inheritance to work correctly ?
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.27 2012/07/09 10:52:26 espie Exp $
a79 2
	# XXX autoload *if needed*.
	eval "require $class; ";
d95 1
a114 7
package LT::Mode::Compile;
our @@ISA = qw(LT::Mode);
package LT::Mode::Install;
our @@ISA = qw(LT::Mode);
package LT::Mode::Link;
our @@ISA = qw(LT::Mode);

d253 1
a253 1
		$m = LT::Mode::Install->new("implicit $a");
d256 1
a256 1
			$m = LT::Mode::Compile->new("implicit");
d258 1
a258 1
			$m = LT::Mode::Link->new("implicit");
d307 1
a307 1
    '-finish' => sub { $mode = LT::Mode::Finish->new('--finish'); },
d380 1
a380 1
	if ($gp->dlopen > 0)  {
@


1.27
log
@implement help-all
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.26 2012/07/09 10:34:52 espie Exp $
d116 7
d329 3
a331 2
# -preserve-dup-deps
# dlopen|-dlopen
d381 10
@


1.26
log
@framework for handling  help better
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.25 2012/07/09 10:17:04 espie Exp $
d109 1
a109 1
	for my $class (values %$mode_maker) {
d125 10
d145 10
d157 9
d169 9
@


1.25
log
@match main libtool options better
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.24 2012/07/08 12:29:21 jasper Exp $
d103 13
a121 2
package LT::Mode::Compile;
our @@ISA = qw(LT::Mode);
a124 1

a137 6
package LT::Mode::Install;
our @@ISA = qw(LT::Mode);

package LT::Mode::Link;
our @@ISA = qw(LT::Mode);

a235 4
use subs qw(
	help
	);

d240 1
d271 2
a272 1
    '-help|-help-all?|h' => \&help, # does not return
d283 1
a283 1
    '-no-warning|-no-warn' -> sub {},
d288 7
d348 1
a348 1
sub help
a362 1
	exit 0;
@


1.24
log
@- move some more stuff into OSConfig
- zap references to variables that don't exist anymore

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.23 2012/07/08 10:42:25 espie Exp $
d254 31
a284 27
$gp->handle_options('-config' => \&config,
		'-debug|x' => sub { 
				LT::Trace->set(1); 
				LT::Exec->verbose_run;
			    },
		'-dry-run|-dryrun|n' => sub { LT::Exec->dry_run; },
		'-features' => sub {
			    my $v = `uname -r`;
			    chomp $v;
			    say "host: $ltconfig->{gnu_arch}-unknown-openbsd$v";
			    say "enable shared libraries" unless $ltconfig->{noshared};
			    say "enable static libraries";
			    exit 0;
			},
		'-finish' => sub { $mode = LT::Mode::Finish->new('--finish'); },
		'-help|?|h' => \&help, # does not return
		'-mode=' => sub {
				$mode = LT::Mode->factory($_[2], "--mode=$_[2]");
			    },
		'-quiet|-silent|-no-verbose' => sub { $verbose = 0; },
		'-verbose|-no-silent|-no-quiet|v' => sub {$verbose = 1;},
		'-tag=' => sub { $gp->add_tag($_[2]); },
		'-version' => sub { 
				say "libtool (not (GNU libtool)) $ltconfig->{version}";
				exit 0;
			    },
	);
@


1.23
log
@a few big changes
- start using our options parser for main libtool options
- put link related stuff into their own module.
Long term, some unification should happen.
- shortdie for cases where we  know libtool is not at fault.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.22 2012/07/08 09:36:31 jasper Exp $
d52 2
d277 2
a278 2
				say "libtool (not (GNU libtool)) $version" ; 
				exit 0; 
@


1.22
log
@- move noshared handling to LT::OSConfig
- remove unused $libinstdir variable

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.21 2012/07/07 21:45:15 jasper Exp $
d22 1
a22 2
use Cwd qw(getcwd abs_path);
use File::Basename;
d29 1
d73 1
d97 1
a97 3
		# XXX invokved from getopt, can't die yet.
		say STDERR "Mode=$mode not implemented yet.\n";
		exit 1;
d137 2
d161 1
a161 2
		# XXX stupid Getopt pre-empts die !
		say STDERR "invalid tag name: $value"; 
a230 1
	create_symlinks
a231 1
	notyet
d252 3
a254 3
$gp->getoptions('config' => \&config,
		'debug' => sub { 
				LT::Trace->set($_[1]); 
d257 2
a258 2
		'dry-run|n' => sub { LT::Exec->dry_run; },
		'features' => sub {
d266 4
a269 4
		'finish' => sub { $mode = LT::Mode::Finish->new('--finish'); },
		'help' => \&help, # does not return
		'mode=s{1}' => sub {
				$mode = LT::Mode->factory($_[1], "--mode=$_[1]");
d271 4
a274 4
		'quiet' => sub { $verbose = 0; },
		'silent' => sub { $verbose = 0; },
		'tag=s{1}' => sub { $gp->add_tag($_[1]); },
		'version' => sub { 
a350 5
sub notyet
{
	die "Option not implemented yet.\n";
}

a354 35
}

sub create_symlinks
{
	my ($dir, $libs) = @@_;
	if (! -d $dir) {
		mkdir($dir) or die "Cannot mkdir($dir) : $!\n";
	}

	foreach my $l (values %$libs) {
		my $f = $l->{fullpath};
		next if !defined $f;
		next if $f =~ m/\.a$/;
		my $libnames = [];
		if (defined $l->{lafile}) {
			require LT::LaFile;
			my $lainfo = LT::LaFile->parse($l->{lafile});
			my $librarynames = $lainfo->stringize('library_names');
			@@$libnames = split /\s/, $librarynames;
			$libnames = reverse_zap_duplicates_ref($libnames);
		} else {
			push @@$libnames, basename($f);
		}	
		foreach my $libfile (@@$libnames) {
			my $link = "$dir/$libfile";
			tsay {"ln -s $f $link"};
			next if -f $link;
			my $p = abs_path($f);
			if (!symlink($p, $link)) {
				die "Cannot create symlink($p, $link): $!\n"
				    unless  $!{EEXIST};
			}
		}
	}
	return $dir;
@


1.21
log
@calling help() is not an error, so just return 0.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.20 2012/07/07 21:42:22 jasper Exp $
d54 7
a236 1
my @@no_shared_archs = qw(m88k vax);
a237 2
my $instlibdir = $ENV{LIBDIR} // '/usr/local/lib';

a248 7
# build static/shared objects?
my $noshared = 0;
if (grep { $_ eq $ltconfig->{machine_arch} } @@no_shared_archs) {
	$noshared = 1;
}


d264 1
a264 1
			    say "enable shared libraries" unless $noshared;
d327 1
a327 1
$mode->run($ltprog, $gp, $noshared);
@


1.20
log
@add a dump method, simplifying the --config call
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.19 2012/07/07 21:29:14 espie Exp $
d353 1
a353 1
	exit 1;
@


1.19
log
@make $mode into an actual object.
cheat a bit by auto-loading corresponding code if needed.
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.18 2012/07/07 21:09:27 jasper Exp $
d57 8
d363 1
a363 3
	while ( my ($key, $value) = each(%$ltconfig) ) {
		print "$key = $value\n";
	}
@


1.18
log
@- since we're storing the config variables in an object now, just walk the
object to print the config, instead of printing the values manually
- add gnu_arch to OSConfig while here
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.17 2012/07/07 18:21:56 espie Exp $
d50 1
a50 1
	machine_arch => $Config{'ARCH'},
d53 1
a53 1
    ($self->{gnu_arch} = $self->{'machine_arch'}) =~ s/amd64/x86_64/;
d57 64
d125 1
d181 1
a181 1
			return $m;
a186 10
sub is_valid_mode
{
	my ($self, $mode) = @@_;
	if (defined $mode) {
		return grep {$_ eq $mode} @@valid_modes;
	} else {
		return 0;
	}
}

d195 1
a195 1
		$m = 'install';
d198 1
a198 1
			$m = 'compile';
d200 1
a200 1
			$m = 'link';
d224 1
a224 1
my $instlibdir = $ENV{'LIBDIR'} // '/usr/local/lib';
d239 1
a239 1
if (grep { $_ eq $ltconfig->{'machine_arch'} } @@no_shared_archs) {
d263 1
a263 1
		'finish' => sub { $mode = 'finish'; },
d265 3
a267 1
		'mode=s{1}' => \$mode,
d301 2
a302 2
if (@@$ltprog == 0 && defined $mode && $mode eq 'install') {
	$ltprog = [ $mode ];
d316 1
a316 6
	tsay {"implicit mode: ", $mode} if $mode;
}

if (!$gp->is_valid_mode($mode)) {
	say STDERR "$0: $mode: invalid argument for --mode" if defined $mode;
	die "MODE must be one of: ", $gp->valid_modes, "\n";
d322 1
a322 20
if ($mode eq 'compile') {
	require LT::Mode::Compile;
	LT::Mode::Compile->run($ltprog, $gp, $noshared);
} elsif ($mode eq 'install') {
	require LT::Mode::Install;
	LT::Mode::Install->run($ltprog);

} elsif ($mode eq 'link') {
	require LT::Mode::Link;
	LT::Mode::Link->run($ltprog, $gp, $noshared);
} elsif ($mode eq 'finish' || $mode eq 'clean' || $mode eq 'uninstall') {
	# don't do anything
	exit 0;
} elsif ($mode eq 'execute') {
	# XXX check whether this is right
	LT::Exec->silent_run;
	LT::Exec->execute(@@$ltprog, @@ARGV);
} else {
	die "MODE=$mode not implemented yet.\n";
}
@


1.17
log
@streamlined code
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.16 2012/07/07 18:08:11 jasper Exp $
d43 1
d48 2
a49 1
    bless {
d51 4
a54 1
    }, $class;
a167 1
(my $gnu_arch = $ltconfig->{'machine_arch'}) =~ s/amd64/x86_64/;
d203 1
a203 1
			    say "host: $gnu_arch-unknown-openbsd$v";
a319 1
# XXX incomplete
d322 3
a324 3
	print "objdir=$ltdir\n";
	print "arch=$ltconfig->{'machine_arch'}\n";
	print "...\n";
@


1.16
log
@- add LT::OSConfig which'll be used to keep all the configuration values
- also fix a case where // should be used.

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.15 2012/07/07 16:48:53 jasper Exp $
d47 1
a47 1
    my $self = {
d49 1
a49 3
    };
    bless $self, $class;
    return $self;
d161 1
a161 2
#my $config = LT::OSConfig->new();
my $ltconfig = LT::OSConfig->new();
@


1.15
log
@re-add correctly handling no arguments

ok espie@@
cvs: ----------------------------------------------------------------------
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.14 2012/07/06 19:18:49 espie Exp $
d40 14
d163 2
a164 3


use Config;
d166 1
a166 2
my $machine_arch = $Config{'ARCH'};
(my $gnu_arch = $machine_arch) =~ s/amd64/x86_64/;
d168 1
a168 2
my $instlibdir = '/usr/local/lib';
$instlibdir = $ENV{'LIBDIR'} if defined $ENV{'LIBDIR'};
d183 1
a183 1
if (grep { $_ eq $machine_arch } @@no_shared_archs) {
d323 1
a323 1
	print "arch=$machine_arch\n";
@


1.14
log
@fix print/pdflib
nasty side-effect of partial libtool2 compat
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.13 2012/07/06 11:30:40 espie Exp $
d95 1
@


1.13
log
@add my copyright, since I'm going to do yet MORE changes...
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.12 2012/07/04 15:08:40 espie Exp $
d228 6
@


1.12
log
@zap duplicate decl
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.11 2012/07/04 15:03:49 espie Exp $
d5 1
@


1.11
log
@zap, now a method
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.10 2012/07/04 12:39:34 espie Exp $
a158 2

my %opts;		# options passed to libtool
@


1.10
log
@- start cleaning up options handling: put things into a separate package
that encapsulates accesses to Getopt::Long (which is badly suited for us
actually)
- simplify LT::Trace syntax
- implement --tag checks that mimic actual libtool
- add libtool comp support, as per libtool2
(but keep implicit modes as per libtool1)
- prevent shell code in nm execution

okay jasper@@, steven@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.9 2012/07/01 17:22:47 espie Exp $
a142 1
	guess_implicit_mode
@


1.9
log
@oops
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.8 2012/07/01 17:22:28 espie Exp $
a24 1
use Getopt::Long;
a29 2

package main;
d39 101
a153 1
my @@valid_modes = qw(clean compile execute finish install link uninstall);
a158 1
our $D = 0;		# debug flag
a161 1
my @@tags;		# list of --tag options passed to libtool
d177 6
a182 8
my $gp = new Getopt::Long::Parser;
# require_order so we stop parsing at the first non-option or argument,
# instead of parsing the whole ARGV.
$gp->configure(	'no_ignore_case',
		'pass_through',
		'no_auto_abbrev',
		'require_order'
	);
d184 13
a196 3
		'debug' => \$D,
		'dry-run|n' => sub { LT::Exec->dry_run },
		'features' => \&notyet,
d202 5
a206 2
		'tag=s{1}' => \@@tags,
		'version' => sub { say "libtool (not (GNU libtool)) $version" ; exit(0); },
d209 1
a209 1
if ($verbose || $D) {
d212 1
d216 1
a216 1
LT::Trace::debug {"ARGV = @@ARGV\n"};
d224 1
a224 1
	LT::Trace::debug {"arg = \"$arg\"\n"};
d229 1
a229 1
LT::Trace::debug {"ltprog = \"@@$ltprog\"\n"};
d240 8
a247 8
# check mode and guess it if needed
if (!($mode && grep { $_ eq $mode } @@valid_modes)) {
	$mode = guess_implicit_mode($ltprog);
	if ($mode) {
		LT::Trace::debug {"implicit mode: $mode\n"};
	} else {
		die "MODE must be one of:\n@@valid_modes\n";
	}
d255 1
a255 1
	LT::Mode::Compile->run($ltprog, $gp, \@@tags, $noshared);
d262 1
a262 1
	LT::Mode::Link->run($ltprog, $gp, \@@tags, $noshared);
d335 1
a335 1
			LT::Trace::debug {"ln -s $f $link\n"};
a346 18
# try to guess libtool mode when it is not specified
sub guess_implicit_mode
{
	my $ltprog = shift;
	my $m = 0;
	for my $a (@@$ltprog) {
	   if ($a =~ m/(install([.-]sh)?|cp)$/) {
		$m = 'install';
	   } elsif ($a =~ m/cc|c\+\+/) {	# XXX improve test
		if (grep { $_ eq '-c' } @@ARGV) {
			$m = 'compile';
		} else {
			$m = 'link';
		}
	   }
	}
	return $m;
}
@


1.8
log
@fix again -j4 properly
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.7 2012/06/28 18:24:42 espie Exp $
d233 1
a233 1
				    unless  $!{EEXIST}
@


1.7
log
@a few minor cleanup and performance tweaks (is_wrapper doesn't need to
scan large binary files)
okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.6 2012/06/27 10:33:51 jasper Exp $
d231 4
a234 3
			symlink($p, $link) or
			    die "Cannot create symlink($p, $link): $!\n"
			    	unless  $!{EEXIST};
@


1.6
log
@- extend an error message to hint to --help for a list of options

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.5 2012/06/27 09:34:09 jasper Exp $
d207 1
a207 3
	my $dir = shift;
	my $libs = shift;

d209 1
a209 1
		mkdir $dir or die "Cannot create directory: $!\n";
d211 1
d214 2
a215 2
		next if (!defined $f);
		next if ($f =~ m/\.a$/);
d229 5
a233 6
			if (! -f $link) {
				my $p = abs_path($f);
				if (!symlink($p, $link)) {
					die "Cannot create symlink($p, $link): $!\n" unless $!{EEXIST};
				}
			}
d236 1
@


1.5
log
@- add a description of --tag

ok espie@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.4 2012/06/24 20:56:57 espie Exp $
d123 2
a124 1
if (@@$ltprog == 0) { die "No libtool command given.\n" };
@


1.4
log
@work-around for obvious race condition with make -j4.
problem discovered by matthieu@@.
This is only a stop-gap work-around !
the real fix is a wee little bit more complex...
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.3 2012/06/24 13:44:53 espie Exp $
d183 1
a183 1
--tag -
@


1.3
log
@clean-up the mess: move modes into separate files,
this makes dependencies more apparent.
This should also speed libtool up a bit, since it won't load all the code
all the time, but only the parts that are actually needed (to wit "compile
mode" which is much smaller).

okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.2 2012/06/19 18:56:07 espie Exp $
d227 7
a233 3
			LT::Trace::debug {"ln -s $f $dir/$libfile\n"};
			if (! -f "$dir/$libfile") {
				symlink abs_path($f), "$dir/$libfile" or die "Cannot create symlink: $!\n";
@


1.2
log
@avoid shell code errors
unneeded eval
okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.1 2012/06/19 09:30:44 espie Exp $
d26 1
a26 1
use Getopt::Std;
a28 1
use LT::Parser;
d33 9
a44 2
	generate_objlist
	get_search_dirs
a47 3
	parse_version_info
	process_deplibs
	is_wrapper
a52 6
use constant {
	OBJECT	=> 0,
	LIBRARY	=> 1,
	PROGRAM	=> 2,
};

a56 1
my @@valid_src = qw(asm c cc cpp cxx f s);
a58 1
my @@libsearchdirs;
a76 3
my $static = 1;
my $shared = 0;
my $convenience = 0;
d146 5
a150 2
	require LT::LoFile;
	my $lofile = LT::LoFile->new;
a151 105
	$gp->getoptions('o=s'		=> \$opts{'o'},
			'prefer-pic'	=> \$opts{'prefer-pic'},
			'prefer-non-pic'=> \$opts{'prefer-non-pic'},
			'static'	=> \$opts{'static'},
			);
	# XXX options ignored: -prefer-pic and -prefer-non-pic
	my $pic = 0;
	my $nonpic = 1;
	# assume we need to build pic objects
	$pic = 1 if (!$noshared);
	$nonpic = 0 if ($pic && grep { $_ eq 'disable-static' } @@tags);
	$pic = 0 if ($nonpic && grep { $_ eq 'disable-shared' } @@tags);
	$nonpic = 1 if ($opts{'static'});

	my ($outfile, $odir, $ofile, $srcfile, $srcext);
	# XXX check whether -c flag is present and if not, die?
	if ($opts{'o'}) {
		# fix extension if needed
		($outfile = $opts{'o'}) =~ s/\.o$/.lo/;
		$odir = dirname $outfile;
		$ofile = basename $outfile;
	} else {
		# XXX sometimes no -o flag is present and we need another way
		my $srcre = join '|', @@valid_src;
		my $found = 0;
		foreach my $a (@@ARGV) {
			if ($a =~ m/\.($srcre)$/i) {
				$srcfile = $a;
				$srcext = $1;
				$found = 1;
				last;
			}
		}
		$found or die "Cannot find source file in command\n";
		# the output file ends up in the current directory
		$odir = '.';
		($ofile = basename $srcfile) =~ s/\.($srcext)$/.lo/i;
		$outfile = "$odir/$ofile";
	}
	LT::Trace::debug {"srcfile = $srcfile\n"} if $srcfile;
	LT::Trace::debug {"outfile = $outfile\n"};
	(my $nonpicobj = $ofile) =~ s/\.lo$/.o/;
	my $picobj = "$ltdir/$nonpicobj";

	$lofile->{picobj} = $picobj if $pic;
	$lofile->{nonpicobj} = $nonpicobj if $nonpic;
	$lofile->compile($ltprog, $odir, \@@ARGV);
	$lofile->write($outfile);
} elsif ($mode eq 'install') {
	# we just parse the options in order to find the actual arguments
	my @@argvcopy = @@ARGV;
	my %install_opts;
	LT::Trace::debug {"ltprog[-1]  = $$ltprog[-1]\n"};
	if ($$ltprog[-1] =~ m/install([.-]sh)?$/) {
		getopts('BbCcdf:g:m:o:pSs', \%install_opts);
		if (@@ARGV < 2 && (!defined $install_opts{'d'} && @@ARGV == 1)) {
			die "Wrong number of arguments for install\n";
		}
	} elsif ($$ltprog[-1] =~ m/cp$/) {
		getopts('HLPRfipr', \%install_opts);
		if (@@ARGV < 2) {
			die "Wrong number of arguments for install\n";
		}
	} else {
		die "Unsupported install program $$ltprog[-1]\n";
	}
	my @@instopts = @@argvcopy[0 .. (@@argvcopy - @@ARGV - 1)];
	my $dst = pop @@ARGV;
	my @@src = @@ARGV;
	my $dstdir;
	if (-d $dst) {
		$dstdir = $dst;
	} else {
		# dst is not a directory, i.e. a file
		if (@@src > 1) {
			# XXX not really libtool's task to check this
			die "Multiple source files combined with file destination.\n";
		} else {
			$dstdir = dirname $dst;
		}
	}
	foreach my $s (@@src) {
		my $dstfile = basename $s;
		# resolve symbolic links, so we don't try to test later
		# whether the symlink is a program wrapper etc.
		if (-l $s) {
			$s = readlink($s) or die "Cannot readlink $s: $!\n";
		}
		my $srcdir = dirname $s;
		my $srcfile = basename $s;
		LT::Trace::debug {"srcdir = $srcdir\nsrcfile = $srcfile\n"};
		LT::Trace::debug {"dstdir = $dstdir\ndstfile = $dstfile\n"};
		if ($srcfile =~ m/^\S+\.la$/) {
			require LT::LaFile;
			LT::LaFile->install($s, $dstdir, $ltprog, \@@instopts, $install_opts{'s'});
		} elsif (-f "$srcdir/$ltdir/$srcfile" && is_wrapper($s)) {
			require LT::Program;
			LT::Program->install($s, $dst, $ltprog, \@@instopts);
		} else {
			LT::Exec->$mode(@@$ltprog, @@instopts, $s, $dst);
		}
	}
	if (defined $install_opts{'d'}) {
		LT::Exec->$mode(@@$ltprog, @@instopts, @@ARGV);
	}
d153 2
a154 234
	my $cmd;
	my @@Ropts;		# -R options on the command line
	my @@Rresolved;		# -R options originating from .la resolution
	my @@RPopts;		# -rpath options
	my $deplibs = [];	# list of dependent libraries (both -L and -l flags)
	my $libdirs = [];	# list of libdirs
	my $libs = {};		# libraries
	my $dirs = {};		# paths to find libraries
	# put a priority in the dir hash
	# always look here
	$dirs->{'/usr/lib'} = 3;

	$gp->getoptions('all-static'		=> \$opts{'all-static'},
			'avoid-version'		=> \$opts{'avoid-version'},
			'dlopen=s{1}'		=> \$opts{'dlopen'},
			'dlpreopen=s{1}'	=> \$opts{'dlpreopen'},
			'export-dynamic'	=> \$opts{'export-dynamic'},
			'export-symbols=s'	=> \$opts{'export-symbols'},
			'export-symbols-regex=s'=> \$opts{'export-symbols-regex'},
			'module'		=> \$opts{'module'},
			'no-fast-install'	=> \$opts{'no-fast-install'},
			'no-install'		=> \$opts{'no-install'},
			'no-undefined'		=> \$opts{'no-undefined'},
			'o=s'			=> \$opts{'o'},
			'objectlist=s'		=> \$opts{'objectlist'},
			'precious-files-regex=s'=> \$opts{'precious-files-regex'},
			'prefer-pic'		=> \$opts{'prefer-pic'},
			'prefer-non-pic'	=> \$opts{'prefer-non-pic'},
			'release=s'		=> \$opts{'release'},
			'rpath=s'		=> \@@RPopts,
			'R=s'			=> \@@Ropts,
			'shrext=s'		=> \$opts{'shrext'},
			'static'		=> \$opts{'static'},
			'thread-safe'		=> \$opts{'thread-safe'},
			'version-info=s{1}'	=> \$opts{'version-info'},
			'version_info=s{1}'	=> \$opts{'version-info'},
			'version-number=s{1}'	=> \$opts{'version-info'},
		);
	# XXX options ignored: dlopen, dlpreopen, no-fast-install,
	# 	no-install, no-undefined, precious-files-regex,
	# 	shrext, thread-safe, prefer-pic, prefer-non-pic

	@@libsearchdirs = get_search_dirs();
	# add the .libs dir as well in case people try to link directly
	# with the real library instead of the .la library
	push @@libsearchdirs, './.libs';

	my $outfile = $opts{'o'};
	if (!$outfile) {
		die "No output file given.\n";
	}
	LT::Trace::debug {"outfile = $outfile\n"};
	my $odir = dirname $outfile;
	my $ofile = basename $outfile;

	# what are we linking?
	my $linkmode = PROGRAM;
	if ($ofile =~ m/\.l?a$/) {
		$linkmode = LIBRARY;
	}
	LT::Trace::debug {"linkmode: $linkmode\n"};

	# eat multiple version-info arguments, we only accept the first.
	map { $_ = '' if ($_ =~ m/\d+:\d+:\d+/); } @@ARGV;

	my @@objs;
	my @@sobjs;
	if ($opts{'objectlist'}) {
		my $objectlist = $opts{'objectlist'};
		open(my $ol, '<', $objectlist) or die "Cannot open $objectlist: $!\n";
		my @@objlist = <$ol>;
		for (@@objlist) { chomp; }
		generate_objlist(\@@objs, \@@sobjs, \@@objlist);
	} else {
		generate_objlist(\@@objs, \@@sobjs, \@@ARGV);
	}
	LT::Trace::debug {"objs = @@objs\n"};
	LT::Trace::debug {"sobjs = @@sobjs\n"};

	my $parser = LT::Parser->new(\@@ARGV);
	$parser->{result} = [];

	if ($linkmode == PROGRAM) {
		require LT::Program;
		my $program = LT::Program->new;
		$program->{outfilepath} = $outfile;
		# XXX give higher priority to dirs of not installed libs
		if ($opts{'export-dynamic'}) {
			push(@@{$parser->{args}}, "-Wl,-E");
		}

		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
		LT::Trace::debug {"end parse_linkargs1\n"};
		LT::Trace::debug {"deplibs = @@$deplibs\n"};

		$program->{objlist} = \@@objs;
		if (@@objs == 0) {
		        if (@@sobjs > 0) {
				LT::Trace::debug {"no non-pic libtool objects found, trying pic objects...\n"};
				$program->{objlist} = \@@sobjs;
			} elsif (@@sobjs == 0) {
				LT::Trace::debug {"no libtool objects of any kind found\n"};
				LT::Trace::debug {"hoping for real objects in ARGV...\n"};
			}
		}
		my $RPdirs = [];
		@@$RPdirs = (@@Ropts, @@RPopts, @@Rresolved);
		$program->{RPdirs} = $RPdirs;

		$program->link($ltprog, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
	} elsif ($linkmode == LIBRARY) {
		require LT::LaFile;
		my $lainfo = LT::LaFile->new;

		$shared = 1 if ($opts{'version-info'} ||
				$opts{'avoid-version'} ||
				$opts{'module'});
		if (!@@RPopts) {
			$convenience = 1;
			$noshared = 1;
			$static = 1;
			$shared = 0;
		} else {
			$shared = 1;
		}
		if ($ofile =~ m/\.a$/ && !$convenience) {
			$ofile =~ s/\.a$/.la/;
			$outfile =~ s/\.a$/.la/;
		}
		(my $libname = $ofile) =~ s/\.l?a$//;	# remove extension
		my $staticlib = $libname.'.a';
		my $sharedlib = $libname.'.so';
		my $sharedlib_symlink;

		if ($opts{'static'} || $opts{'all-static'}) {
			$shared = 0;
			$static = 1;
		}
		$shared = 0 if $noshared;

		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
		LT::Trace::debug {"end parse_linkargs1\n"};
		LT::Trace::debug {"deplibs = @@$deplibs\n"};

		my $sover = '0.0';
		my $origver = 'unknown';
		# environment overrides -version-info
		(my $envlibname = $libname) =~ s/[.+-]/_/g;
		my ($current, $revision, $age) = (0, 0, 0);
		if ($opts{'version-info'}) {
			($current, $revision, $age) = parse_version_info($opts{'version-info'});
			$origver = "$current.$revision";
			$sover = $origver;
		}
		if ($ENV{"${envlibname}_ltversion"}) {
			# this takes priority over the previous
			$sover = $ENV{"${envlibname}_ltversion"};
			($current, $revision) = split /\./, $sover;
			$age = 0;
		}
		if (defined $opts{'release'}) {
			$sharedlib_symlink = $sharedlib;
 			$sharedlib = $libname.'-'.$opts{'release'}.'.so';
		}
		if ($opts{'avoid-version'} ||
			(defined $opts{'release'} && !$opts{'version-info'})) {
			# don't add a version in these cases
		} else {
			$sharedlib .= ".$sover";
			if (defined $opts{'release'}) {
				$sharedlib_symlink .= ".$sover";
			}
		}

		# XXX add error condition somewhere...
		$static = 0 if ($shared && grep { $_ eq 'disable-static' } @@tags);
		$shared = 0 if ($static && grep { $_ eq 'disable-shared' } @@tags);

		LT::Trace::debug {"SHARED: $shared\nSTATIC: $static\n"};

		$lainfo->{'libname'} = $libname;
		if ($shared) {
			$lainfo->{'dlname'} = $sharedlib;
			$lainfo->{'library_names'} = $sharedlib;
			$lainfo->{'library_names'} .= " $sharedlib_symlink"
				if (defined $opts{'release'});
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
			LT::Trace::debug {"sharedlib: $sharedlib\n"};
			$lainfo->{'current'} = $current;
			$lainfo->{'revision'} = $revision;
			$lainfo->{'age'} = $age;
		}
		if ($static) {
			$lainfo->{'old_library'} = $staticlib;
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($convenience && @@sobjs > 0) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
			LT::Trace::debug {($convenience ? "convenience" : "static")." lib: $staticlib\n"};
		}
		$lainfo->{'installed'} = 'no';
		$lainfo->{'shouldnotlink'} = $opts{'module'} ? 'yes' : 'no';
		map { $_ = "-R$_" } @@Ropts;
		unshift @@$deplibs, @@Ropts if (@@Ropts);
		LT::Trace::debug {"deplibs = @@$deplibs\n"};
		my $finaldeplibs = reverse_zap_duplicates_ref($deplibs);
		LT::Trace::debug {"finaldeplibs = @@$finaldeplibs\n"};
		$lainfo->set('dependency_libs', "@@$finaldeplibs");
		if (@@RPopts) {
			if (@@RPopts > 1) {
				LT::Trace::debug {"more than 1 -rpath option given, taking the first: ", $RPopts[0], "\n"};
			}
			$lainfo->{'libdir'} = $RPopts[0];
		}
		if (!($convenience && $ofile =~ m/\.a$/)) {
			$lainfo->write($outfile, $ofile);
			unlink("$odir/$ltdir/$ofile");
			symlink("../$ofile", "$odir/$ltdir/$ofile");
		}
		my $lai = "$odir/$ltdir/$ofile".'i';
		if ($shared) {
			my $pdeplibs = process_deplibs($finaldeplibs);
			if (defined $pdeplibs) {
				$lainfo->set('dependency_libs', "@@$pdeplibs");
			}
			if (! $opts{'module'}) {
				$lainfo->write_shared_libs_log($origver);
			}
		}
		$lainfo->{'installed'} = 'yes';
		# write .lai file (.la file that will be installed)
		$lainfo->write($lai, $ofile);
	}
d161 1
a161 1
	LT::Exec->$mode(@@$ltprog, @@ARGV);
a203 16
# convert 4:5:8 into a list of numbers
sub parse_version_info
{
	my $vinfo = shift;

	if ($vinfo =~ m/^(\d+):(\d+):(\d+)$/) {
		return ($1, $2, $3);
	} elsif ($vinfo =~ m/^(\d+):(\d+)$/) {
		return ($1, $2, 0);
	} elsif ($vinfo =~ m/^(\d+)$/) {
		return ($1, 0, 0);
	} else {
		die "Error parsing -version-info $vinfo\n";
	}
}

d224 1
a224 1
			push @@$libnames, basename $f;
a234 89
# prepare dependency_libs information for the .la file which is installed
# i.e. remove any .libs directories and use the final libdir for all the
# .la files
sub process_deplibs
{
	my $linkflags = shift;

	my $result;

	foreach my $lf (@@$linkflags) {
		if ($lf =~ m/-L\S+\Q$ltdir\E$/) {
		} elsif ($lf =~ m/-L\./) {
		} elsif ($lf =~ m/\/\S+\/(\S+\.la)/) {
			my $lafile = $1;
			require LT::LaFile;
			my $libdir = LT::LaFile->parse($lf)->{'libdir'};
			if ($libdir eq '') {
				# this drops libraries which will not be
				# installed
				# XXX improve checks when adding to deplibs
				say "warning: $lf dropped from deplibs";
			} else {
				$lf = $libdir.'/'.$lafile;
				push @@$result, $lf;
			}
		} else {
			push @@$result, $lf;
		}
	}
	return $result;
}

# populate arrays of non-pic and pic objects and remove these from @@ARGV
sub generate_objlist
{
	my $objs = shift;
	my $sobjs = shift;
	my $objsource = shift;

	my $result = [];
	foreach my $a (@@$objsource) {
		if ($a =~ m/\S+\.lo$/) {
			require LT::LoFile;
			my $ofile = basename $a;
			my $odir = dirname $a;
			my $loinfo = LT::LoFile->parse($a);
			if ($loinfo->{'non_pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'non_pic_object'};
				push @@$objs, $o;
			}
			if ($loinfo->{'pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'pic_object'};
				push @@$sobjs, $o;
			}
		} elsif ($a =~ m/\S+\.o$/) {
			push @@$objs, $a;
		} else {
			push @@$result, $a;
		}
	}
	@@$objsource = @@$result;
}

# XXX reuse code from SharedLibs.pm instead
sub get_search_dirs
{
	my @@libsearchdirs;
	open(my $fh, '-|', '/sbin/ldconfig -r');
	if (defined $fh) {
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/o) {
				foreach my $d (split(/\:/o, $1)) {
					push @@libsearchdirs, $d;
				}
				last;
			}
		}
		close($fh);
	} else {
		die "Can't run ldconfig\n";
        }
	return @@libsearchdirs;
}


a252 10

sub is_wrapper
{
#	my $self = shift;
	my $program = shift;

	open(my $pw, '<', $program) or die "Cannot open $program: $!\n";
	return grep { m/wrapper\sfor/ } <$pw>;
}

@


1.1
log
@add libtool to base, okay deraadt@@, jasper@@, millert@@...
(as requested by matthieu@@ so we can work on xenocara).
@
text
@d2 1
a2 1
# $OpenBSD: libtool,v 1.34 2011/11/16 10:56:57 jasper Exp $
d707 1
a707 1
	return eval(grep { m/wrapper\sfor/ } <$pw>);
@

