head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.2
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.12.0.14
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.10
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.6
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11;
locks; strict;
comment	@# @;


1.13
date	2017.05.27.10.35.41;	author zhuk;	state Exp;
branches;
next	1.12;
commitid	hA90sMMApRSjfsIs;

1.12
date	2014.03.19.02.16.22;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.12.12.20.06;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.10.11.39.52;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.09.21.59.18;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.09.21.38.38;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.09.17.53.15;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.09.13.37.39;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.08.18.28.34;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.08.11.17.12;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.08.10.42.25;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.08.10.26.46;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.08.10.12.19;	author espie;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Make libtool handle --tag=... inside command line.

Unbreaks (and changes PLIST) multimedia/lives under Clang, and maybe others.

okay espie@@
@
text
@# $OpenBSD: Getopt.pm,v 1.12 2014/03/19 02:16:22 afresh1 Exp $

# Copyright (c) 2012 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

use strict;
use warnings;

package Option;
sub factory
{
	my ($class, $o) = @@_;
	if ($o =~ m/^(.)$/) {
		return Option::Short->new($1);
	} elsif ($o =~ m/^(.)\:$/) {
		return Option::ShortArg->new($1);
	} elsif ($o =~ m/^(\-?.)(?:\:\!|\!\:)$/) {
		return Option::LongArg0->new($1);
	} elsif ($o =~ m/^(\-?.)\!$/) {
		return Option::Long->new($1);
	} elsif ($o =~ m/^(\-?.*)\=$/) {
		return Option::LongArg->new($1);
	} elsif ($o =~ m/^(\-?.*)\:$/) {
		return Option::LongArg0->new($1);
	} elsif ($o =~ m/^(\-?.*)$/) {
		return Option::Long->new($1);
	}
}

sub new
{
	my ($class, $v) = @@_;
	bless \$v, $class;
}

sub setup
{
	my ($self, $opts, $isarray) = @@_;
	$opts->add_option_accessor($$self, $isarray);
	return $self;
}

package Option::Short;
our @@ISA = qw(Option);

sub match
{
	my ($self, $arg, $opts, $canonical, $code) = @@_;
	if ($arg =~ m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, 1, $arg);
		return 1;
	}
	if ($arg =~ m/^(\-\Q$$self\E)(.*)$/) {
		unshift(@@main::ARGV, "-$2");
		&$code($opts, $canonical, 1, $1);
		return 1;
	}
	return 0;
}

package Option::ShortArg;
our @@ISA = qw(Option::Short);

sub match
{
	my ($self, $arg, $opts, $canonical, $code) = @@_;
	if ($arg =~ m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, (shift @@main::ARGV), $arg);
		return 1;
	}
	if ($arg =~ m/^(\-\Q$$self\E)(.*)$/) {
		&$code($opts, $canonical, $2, $1);
		return 1;
	}
	return 0;
}

package Option::Long;
our @@ISA = qw(Option);

sub match
{
	my ($self, $arg, $opts, $canonical, $code) = @@_;
	if ($arg =~ m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, 1, $arg);
		return 1;
	}
	return 0;
}

package Option::LongArg0;
our @@ISA = qw(Option::Long);
sub match
{
	my ($self, $arg, $opts, $canonical, $code) = @@_;
	if ($arg =~ m/^\-\Q$$self\E$/) {
		if (@@main::ARGV > 0) {
			&$code($opts, $canonical, (shift @@main::ARGV), $arg);
			return 1;
		} else {
			die "Missing argument  for option -$$self\n";
		}
	}
	return 0;
}

package Option::LongArg;
our @@ISA = qw(Option::LongArg0);

sub match
{
	my ($self, $arg, $opts, $canonical, $code) = @@_;
	if ($self->SUPER::match($arg, $opts, $canonical, $code)) {
		return 1;
	}
	if ($arg =~ m/^(-\Q$$self\E)\=(.*)$/) {
		&$code($opts, $canonical, $2, $1);
		return 1;
	}
	return 0;
}

package Option::Regexp;
sub new
{
	my ($class, $re, $code) = @@_;
	bless {re => $re, code => $code}, $class;
}

sub setup
{
	return shift;
}

sub match
{
	my ($self, $arg, $opts) = @@_;
	if (my @@l = ($arg =~ m/^$self->{re}$/)) {
		&{$self->{code}}(@@l);
		return 1;
	} else {
		return 0;
	}
}

package Options;

sub new
{
	my ($class, $string, $code) = @@_;

	if (ref($string) eq 'Regexp') {
		return Option::Regexp->new($string, $code);
	}
	my @@alternates = split(/\|/, $string);

	bless {alt => [map { Option->factory($_); } @@alternates], code => $code}, $class;
}

sub setup
{
	my ($self, $allopts, $isarray) = @@_;
	$self->{alt}[0]->setup($allopts, $isarray);
	return $self;
}

sub match
{
	my ($self, $arg, $opts) = @@_;

	my $canonical = ${$self->{alt}[0]};
	for my $s (@@{$self->{alt}}) {
		if ($s->match($arg, $opts, $canonical, $self->{code})) {
			return 1;
		}
	}
	return 0;
}

# seems I spend my life rewriting option handlers, not surprisingly...
package LT::Getopt;
use LT::Util;


# parsing an option 'all-static' will automatically add an
# accessor $self->all_static   that maps to the option.

sub add_option_accessor
{
	my ($self, $option, $isarray) = @@_;
	my $access = $option;
	$access =~ s/^\-//;
	$access =~ s/-/_/g;
	my $actual = $isarray ? 
		sub {
		    my $self = shift;
		    $self->{opt}{$option} //= [];
		    if (wantarray) {
			    return @@{$self->{opt}{$option}};
		    } else {
			    return scalar @@{$self->{opt}{$option}};
		    }
		} : sub {
		    my $self = shift;
		    return $self->{opt}{$option};
		};
	my $callpkg = ref($self);
	unless ($self->can($access)) {
		no strict 'refs';
		*{$callpkg."::$access"} = $actual;
	}
}

sub create_options
{
	my ($self, @@l) = @@_;
	my @@options = ();
	# first pass creates accessors
	push(@@l, '-tag=', sub { $self->add_tag($_[2]); });
	while (my $opt = shift @@l) {
		my $isarray = ($opt =~ s/\@@$//);
		# default code or not
		my $code;
		if (@@l > 0 && ref($l[0]) eq 'CODE') {
			$code = shift @@l;
		} else {
			if ($isarray) {
				$code = sub {
				    my ($object, $canonical, $value) = @@_;
				    push(@@{$object->{opt}{$canonical}}, $value);
				};
			} else {
				$code = sub {
				    my ($object, $canonical, $value) = @@_;
				    $object->{opt}{$canonical} = $value;
				};
			}
		}
		push(@@options, Options->new($opt, $code)->setup($self, $isarray));
	}
	return @@options;
}

sub handle_options
{
	my ($self, @@l) = @@_;

	my @@options = $self->create_options(@@l);

MAINLOOP:
	while (@@main::ARGV > 0) {
		my $arg = shift @@main::ARGV;
		if ($arg =~ m/^\-\-$/) {
			last;
		}
		if ($arg =~ m/^\-/) {
			for my $opt (@@options) {
				if ($opt->match($arg, $self)) {
					next MAINLOOP;
				}
			}
			shortdie "Unknown option $arg\n";
		} else {
			unshift(@@main::ARGV, $arg);
			last;
		}
	}
}

sub handle_permuted_options
{
	my ($self, @@l) = @@_;

	my @@options = $self->create_options(@@l);

	$self->{kept} = [];

MAINLOOP2:
	while (@@main::ARGV > 0) {
		my $arg = shift @@main::ARGV;
		if ($arg =~ m/^\-\-$/) {
			next;   # XXX ?
		}
		if ($arg =~ m/^\-/) {
			for my $opt (@@options) {
				if ($opt->match($arg, $self)) {
					next MAINLOOP2;
				}
			}
		}
		$self->keep_for_later($arg);
	}
	@@main::ARGV = @@{$self->{kept}};
}

sub keep_for_later
{
	my ($self, @@args) = @@_;
	push(@@{$self->{kept}}, @@args);
}

sub new
{
	my $class = shift;
	bless {}, $class;
}

1;
@


1.12
log
@Remove lexical $_ from libtool in preparation for perl 5.18

OK and additional changes from espie@@
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.11 2012/07/12 12:20:06 espie Exp $
d231 1
@


1.11
log
@allow "long options" to be one letter, enforce with !

make sure -L dir will error out.

"cute" gnu libtool: -x c    will vanish from linker arguments, but only
in library linking-mode.
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.10 2012/07/10 11:39:52 espie Exp $
d24 2
a25 2
	my ($class, $_) = @@_;
	if (m/^(.)$/) {
d27 1
a27 1
	} elsif (m/^(.)\:$/) {
d29 1
a29 1
	} elsif (m/^(\-?.)(?:\:\!|\!\:)$/) {
d31 1
a31 1
	} elsif (m/^(\-?.)\!$/) {
d33 1
a33 1
	} elsif (m/^(\-?.*)\=$/) {
d35 1
a35 1
	} elsif (m/^(\-?.*)\:$/) {
d37 1
a37 1
	} elsif (m/^(\-?.*)$/) {
d60 3
a62 3
	my ($self, $_, $opts, $canonical, $code) = @@_;
	if (m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, 1, $_);
d65 1
a65 1
	if (m/^(\-\Q$$self\E)(.*)$/) {
d78 3
a80 3
	my ($self, $_, $opts, $canonical, $code) = @@_;
	if (m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, (shift @@main::ARGV), $_);
d83 1
a83 1
	if (m/^(\-\Q$$self\E)(.*)$/) {
d95 3
a97 3
	my ($self, $_, $opts, $canonical, $code) = @@_;
	if (m/^\-\Q$$self\E$/) {
		&$code($opts, $canonical, 1, $_);
d107 2
a108 2
	my ($self, $_, $opts, $canonical, $code) = @@_;
	if (m/^\-\Q$$self\E$/) {
d110 1
a110 1
			&$code($opts, $canonical, (shift @@main::ARGV), $_);
d124 2
a125 2
	my ($self, $_, $opts, $canonical, $code) = @@_;
	if ($self->SUPER::match($_, $opts, $canonical, $code)) {
d128 1
a128 1
	if (m/^(-\Q$$self\E)\=(.*)$/) {
d263 2
a264 2
		my $_ = shift @@main::ARGV;
		if (m/^\-\-$/) {
d267 1
a267 1
		if (m/^\-/) {
d269 1
a269 1
				if ($opt->match($_, $self)) {
d273 1
a273 1
			shortdie "Unknown option $_\n";
d275 1
a275 1
			unshift(@@main::ARGV, $_);
d291 2
a292 2
		my $_ = shift @@main::ARGV;
		if (m/^\-\-$/) {
d295 1
a295 1
		if (m/^\-/) {
d297 1
a297 1
				if ($opt->match($_, $self)) {
d302 1
a302 1
		$self->keep_for_later($_);
@


1.10
log
@pass the option string along as a 4th parameter, in cases canonical is
not all that matters (e.g., -fpie and friends)
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.9 2012/07/09 21:59:18 espie Exp $
d29 4
@


1.9
log
@longarg:
means longoption with a separate parameter, like for -Xcompiler
(won't work as -Xcompiler=value)
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.8 2012/07/09 21:38:38 espie Exp $
d58 1
a58 1
		&$code($opts, $canonical, 1);
d61 3
a63 3
	if (m/^\-\Q$$self\E(.*)$/) {
		unshift(@@main::ARGV, "-$1");
		&$code($opts, $canonical, 1);
d76 1
a76 1
		&$code($opts, $canonical, (shift @@main::ARGV));
d79 2
a80 2
	if (m/^\-\Q$$self\E(.*)$/) {
		&$code($opts, $canonical, $1);
d93 1
a93 1
		&$code($opts, $canonical, 1);
d106 1
a106 1
			&$code($opts, $canonical, (shift @@main::ARGV));
d124 2
a125 2
	if (m/^-\Q$$self\E\=(.*)$/) {
		&$code($opts, $canonical, $1);
@


1.8
log
@extend option parser a bit more: if we pass it a regexp, then we match
that regexp.

for permuted mode, expose the "future" arguments so we can tinker with them
directly.

Use that to support -Wc,* and -Xcompiler
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.7 2012/07/09 17:53:15 espie Exp $
d31 2
d99 1
a99 1
package Option::LongArg;
a100 1

d111 12
@


1.7
log
@finally, also do accessors for short options. Turns out to be useful.
fix the array accessor...
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.6 2012/07/09 13:37:39 espie Exp $
d118 23
d147 3
d270 2
a271 1
	my @@kept = ();
d285 1
a285 1
		push(@@kept, $_);
d287 7
a293 1
	@@main::ARGV = @@kept;
@


1.6
log
@tweak auto-accessor for arrays to be more useful
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.5 2012/07/08 18:28:34 espie Exp $
a41 2
package Option::Short;
our @@ISA = qw(Option);
d44 3
a46 1
	# short options don't make accessors
d49 3
a86 7
sub setup
{
	my ($self, $opts, $isarray) = @@_;
	$opts->add_option_accessor($$self, $isarray);
	return $self;
}

d131 2
a132 2
	my ($self, $allopts) = @@_;
	$self->{alt}[0]->setup($allopts);
d166 1
@


1.5
log
@pass @@  (array) information along to auto-make simpler accessors
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.4 2012/07/08 11:17:12 espie Exp $
d170 5
a174 1
		    return @@{$self->{opt}{$option}};
@


1.4
log
@preparation for handling  permuted options
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.3 2012/07/08 10:42:25 espie Exp $
d86 2
a87 2
	my ($self, $opts) = @@_;
	$opts->add_option_accessor($$self);
d94 1
a94 1
	if (m/^\-$$self$/) {
d163 1
a163 1
	my ($self, $option) = @@_;
d167 8
a174 4
	my $actual = sub {
		my $self = shift;
		return $self->{opt}{$option};
	};
d188 1
d194 1
a194 1
			if ($opt =~ s/\@@$//) {
d206 1
a206 1
		push(@@options, Options->new($opt, $code)->setup($self));
@


1.3
log
@a few big changes
- start using our options parser for main libtool options
- put link related stuff into their own module.
Long term, some unification should happen.
- shortdie for cases where we  know libtool is not at fault.
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.2 2012/07/08 10:26:46 espie Exp $
d178 1
a178 1
sub handle_options
a180 1

d203 8
d230 25
@


1.2
log
@stupid
@
text
@d1 1
a1 1
# $OpenBSD: Getopt.pm,v 1.1 2012/07/08 10:12:19 espie Exp $
d155 1
d217 1
a217 1
			die "Unknown option $_\n";
@


1.1
log
@specialized option handler that will make things simpler
@
text
@d1 1
a1 1
# $OpenBSD$
d219 1
@

