head	1.36;
access;
symbols
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20;
locks; strict;
comment	@# @;


1.36
date	2017.07.23.09.48.53;	author zhuk;	state Exp;
branches;
next	1.35;
commitid	NCPitpuKxE1Hssi6;

1.35
date	2017.04.25.21.13.15;	author sthen;	state Exp;
branches;
next	1.34;
commitid	wTiWhFVjX3Tj1Srj;

1.34
date	2016.12.25.13.46.18;	author zhuk;	state Exp;
branches;
next	1.33;
commitid	YD64g2Luro4kX4og;

1.33
date	2016.11.03.10.23.01;	author ajacoutot;	state Exp;
branches;
next	1.32;
commitid	wpZTm4sbFarT2b5Y;

1.32
date	2016.08.02.16.09.55;	author jca;	state Exp;
branches;
next	1.31;
commitid	ChWb6pFrtymWiTJQ;

1.31
date	2016.04.27.09.50.57;	author ajacoutot;	state Exp;
branches;
next	1.30;
commitid	loLe39Kt9uKUUi2D;

1.30
date	2015.09.21.08.49.06;	author ajacoutot;	state Exp;
branches;
next	1.29;
commitid	zDE9nB2bikY6RPKh;

1.29
date	2014.04.27.18.08.35;	author zhuk;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.20.17.34.26;	author zhuk;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.16.14.39.06;	author zhuk;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.16.10.31.27;	author zhuk;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.19.02.16.22;	author afresh1;	state Exp;
branches;
next	1.24;

1.24
date	2013.01.10.21.34.29;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2012.11.09.10.55.01;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2012.08.27.11.00.27;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.04.14.26.02;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2012.07.18.09.33.16;	author espie;	state Exp;
branches;
next	1.19;

1.19
date	2012.07.13.13.25.12;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	2012.07.13.11.56.12;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2012.07.12.17.07.12;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2012.07.12.12.35.21;	author espie;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.12.12.20.06;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2012.07.12.11.59.38;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2012.07.12.11.52.50;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2012.07.11.14.17.08;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2012.07.11.14.12.44;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2012.07.11.13.54.48;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.11.08.35.47;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2012.07.10.16.41.01;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2012.07.10.13.32.10;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2012.07.10.12.24.45;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.09.10.52.26;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.09.10.34.52;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2012.07.04.12.39.34;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.28.18.24.42;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.24.13.44.53;	author espie;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Recognize '-weak' in our libtool, helps at least xine-lib to build.

okay aja@@
@
text
@# ex:ts=8 sw=4:
# $OpenBSD: Link.pm,v 1.35 2017/04/25 21:13:15 sthen Exp $
#
# Copyright (c) 2007-2010 Steven Mestdagh <steven@@openbsd.org>
# Copyright (c) 2012 Marc Espie <espie@@openbsd.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
use strict;
use warnings;
use feature qw(say);

# supplement OSConfig with stuff needed.
package LT::OSConfig;
require LT::UList;

my $search_dir_list = LT::UList->new;
my $search_dir_obj = tied(@@$search_dir_list);

sub fillup_search_dirs
{
	return if @@$search_dir_list;
	open(my $fh, '-|', '/sbin/ldconfig -r');
	if (!defined $fh) {
		die "Can't run ldconfig\n";
	}
	while (<$fh>) {
		if (m/^\s*search directories:\s*(.*?)\s*$/o) {
			push @@$search_dir_list, split(/\:/o, $1);
			last;
		}
	}
	close($fh);
}

sub search_dirs
{
	my $self = shift;
	$self->fillup_search_dirs;
	return @@$search_dir_list;
}

sub is_search_dir
{
	my ($self, $dir) = @@_;
	$self->fillup_search_dirs;
	return $search_dir_obj->exists($dir);
}


# let's add the libsearchdirs and -R options there
package LT::Options;

sub add_libsearchdir
{
	my $self = shift;
	push(@@{$self->{libsearchdir}}, @@_);
}

sub libsearchdirs
{
	my $self = shift;
	return @@{$self->{libsearchdir}};
}

# -R options originating from .la resolution
sub add_R
{
	my $self = shift;
	push(@@{$self->{Rresolved}}, @@_);
}

sub Rresolved
{
	my $self = shift;
	$self->{Rresolved} //= [];
	return @@{$self->{Rresolved}};
}

package LT::Mode::Link;
our @@ISA = qw(LT::Mode);

use LT::Util;
use LT::Trace;
use LT::Library;
use File::Basename;

use constant {
	OBJECT	=> 0, # unused ?
	LIBRARY	=> 1,
	PROGRAM	=> 2,
};

sub help
{
	print <<"EOH";

Usage: $0 --mode=link LINK-COMMAND ...
Link object files and libraries into a library or a program
EOH
}

my $shared = 0;
my $static = 1;

sub run
{
	my ($class, $ltprog, $gp, $ltconfig) = @@_;

	my $noshared  = $ltconfig->noshared;
	my $cmd;
	my $libdirs = LT::UList->new;		# list of libdirs
	my $libs = LT::Library::Stash->new;	# libraries
	my $dirs = LT::UList->new('/usr/lib');	# paths to search for libraries,
						# /usr/lib is always there

	$gp->handle_permuted_options(
	    'all-static',
	    'allow-undefined', # we don't care about THAT one
	    'avoid-version',
	    'bindir:',
	    'dlopen:',
	    'dlpreopen:',
	    'export-dynamic',
	    'export-symbols:',
	    '-export-symbols:', sub { shortdie "the option is -export-symbols.\n--export-symbols will be ignored by gnu libtool"; },
	    'export-symbols-regex:',
	    'module',
	    'no-fast-install',
	    'no-install',
	    'no-undefined',
	    '-no-undefined',
	    'o:!@@',
	    'objectlist:',
	    'precious-files-regex:',
	    'prefer-pic',
	    'prefer-non-pic',
	    'release:',
	    'rpath:@@',
	    'L:!', sub { shortdie "libtool does not allow spaces in -L dir\n"},
	    'R:@@',
	    'shrext:',
	    'static',
	    'static-libtool-libs',
	    'thread-safe', # XXX and --thread-safe ?
	    'version-info:',
	    'version-number:',
	    'weak',
	    );

	# XXX options ignored: bindir, dlopen, dlpreopen, no-fast-install,
	#	no-install, no-undefined, precious-files-regex,
	#	shrext, thread-safe, prefer-pic, prefer-non-pic,
	#	static-libtool-libs

	my @@RPopts = $gp->rpath;	 # -rpath options
	my @@Ropts = $gp->R;		 # -R options on the command line

	# add the .libs dir as well in case people try to link directly
	# with the real library instead of the .la library
	$gp->add_libsearchdir(LT::OSConfig->search_dirs, './.libs');

	if (!$gp->o) {
		shortdie "No output file given.\n";
	}
	if ($gp->o > 1) {
		shortdie "Multiple output files given.\n";
	}

	my $outfile = ($gp->o)[0];
	tsay {"outfile = $outfile"};
	my $odir = dirname($outfile);
	my $ofile = basename($outfile);

	# what are we linking?
	my $linkmode = PROGRAM;
	if ($ofile =~ m/\.l?a$/) {
		$linkmode = LIBRARY;
		$gp->handle_permuted_options('x:!');
	}
	tsay {"linkmode: $linkmode"};

	my @@objs;
	my @@sobjs;
	if ($gp->objectlist) {
		my $objectlist = $gp->objectlist;
		open(my $ol, '<', $objectlist) or die "Cannot open $objectlist: $!\n";
		my @@objlist = <$ol>;
		for (@@objlist) { chomp; }
		generate_objlist(\@@objs, \@@sobjs, \@@objlist);
	} else {
		generate_objlist(\@@objs, \@@sobjs, \@@ARGV);
	}
	tsay {"objs = @@objs"};
	tsay {"sobjs = @@sobjs"};

	my $deplibs = LT::UList->new;	# list of dependent libraries (both -L and -l flags)
	my $parser = LT::Parser->new(\@@ARGV);

	if ($linkmode == PROGRAM) {
		require LT::Mode::Link::Program;
		my $program = LT::Program->new;
		$program->{outfilepath} = $outfile;
		# XXX give higher priority to dirs of not installed libs
		if ($gp->export_dynamic) {
			push(@@{$parser->{args}}, "-Wl,-E");
		}

		$parser->parse_linkargs1($deplibs, $gp, $dirs, $libs);
		tsay {"end parse_linkargs1"};
		tsay {"deplibs = @@$deplibs"};

		$program->{objlist} = \@@objs;
		if (@@objs == 0) {
			if (@@sobjs > 0) {
				tsay {"no non-pic libtool objects found, trying pic objects..."};
				$program->{objlist} = \@@sobjs;
			} elsif (@@sobjs == 0) {
				tsay {"no libtool objects of any kind found"};
				tsay {"hoping for real objects in ARGV..."};
			}
		}
		my $RPdirs = LT::UList->new(@@Ropts, @@RPopts, $gp->Rresolved);
		$program->{RPdirs} = $RPdirs;

		$program->link($ltprog, $ltconfig, $dirs, $libs, $deplibs, $libdirs, $parser, $gp);
	} elsif ($linkmode == LIBRARY) {
		my $convenience = 0;
		require LT::Mode::Link::Library;
		my $lainfo = LT::LaFile->new;

		$shared = 1 if ($gp->version_info ||
				$gp->avoid_version ||
				$gp->module);
		if (!@@RPopts) {
			$convenience = 1;
			$noshared = 1;
			$static = 1;
			$shared = 0;
		} else {
			$shared = 1;
		}
		if ($ofile =~ m/\.a$/ && !$convenience) {
			$ofile =~ s/\.a$/.la/;
			$outfile =~ s/\.a$/.la/;
		}
		(my $libname = $ofile) =~ s/\.l?a$//;	# remove extension
		my $staticlib = $libname.'.a';
		my $sharedlib = $libname.'.so';
		my $sharedlib_symlink;

		if ($gp->static || $gp->all_static) {
			$shared = 0;
			$static = 1;
		}
		$shared = 0 if $noshared;

		$parser->parse_linkargs1($deplibs, $gp, $dirs, $libs);
		tsay {"end parse_linkargs1"};
		tsay {"deplibs = @@$deplibs"};

		my $sover = '0.0';
		my $origver = 'unknown';
		# environment overrides -version-info
		(my $envlibname = $libname) =~ s/[.+-]/_/g;
		my ($current, $revision, $age) = (0, 0, 0);
		if ($gp->version_info) {
			($current, $revision, $age) = parse_version_info($gp->version_info);
			$origver = "$current.$revision";
			$sover = $origver;
		}
		if ($ENV{"${envlibname}_ltversion"}) {
			# this takes priority over the previous
			$sover = $ENV{"${envlibname}_ltversion"};
			($current, $revision) = split /\./, $sover;
			$age = 0;
		}
		if (defined $gp->release) {
			$sharedlib_symlink = $sharedlib;
			$sharedlib = $libname.'-'.$gp->release.'.so';
		}
		if ($gp->avoid_version ||
			(defined $gp->release && !$gp->version_info)) {
			# don't add a version in these cases
		} else {
			$sharedlib .= ".$sover";
			if (defined $gp->release) {
				$sharedlib_symlink .= ".$sover";
			}
		}

		# XXX add error condition somewhere...
		$static = 0 if $shared && $gp->has_tag('disable-static');
		$shared = 0 if $static && $gp->has_tag('disable-shared');

		tsay {"SHARED: $shared\nSTATIC: $static"};

		$lainfo->{libname} = $libname;
		if ($shared) {
			$lainfo->{dlname} = $sharedlib;
			$lainfo->{library_names} = $sharedlib;
			$lainfo->{library_names} .= " $sharedlib_symlink"
				if defined $gp->release;
			$lainfo->link($ltprog, $ltconfig, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $libdirs, $parser, $gp);
			tsay {"sharedlib: $sharedlib"};
			$lainfo->{current} = $current;
			$lainfo->{revision} = $revision;
			$lainfo->{age} = $age;
		}
		if ($static) {
			$lainfo->{old_library} = $staticlib;
			$lainfo->link($ltprog, $ltconfig, $ofile, $staticlib, $odir, 0, ($convenience && @@sobjs > 0) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $libdirs, $parser, $gp);
			tsay {($convenience ? "convenience" : "static"),
			    " lib: $staticlib"};
		}
		$lainfo->{installed} = 'no';
		$lainfo->{shouldnotlink} = $gp->module ? 'yes' : 'no';
		map { $_ = "-R$_" } @@Ropts;
		unshift @@$deplibs, @@Ropts if @@Ropts;
		tsay {"deplibs = @@$deplibs"};
		$lainfo->set('dependency_libs', "@@$deplibs");
		if (@@RPopts) {
			if (@@RPopts > 1) {
				tsay {"more than 1 -rpath option given, ",
				    "taking the first: ", $RPopts[0]};
			}
			$lainfo->{libdir} = $RPopts[0];
		}
		if (!($convenience && $ofile =~ m/\.a$/)) {
			$lainfo->write($outfile, $ofile);
			unlink("$odir/$ltdir/$ofile");
			symlink("../$ofile", "$odir/$ltdir/$ofile");
		}
		my $lai = "$odir/$ltdir/$ofile".'i';
		if ($shared) {
			my $pdeplibs = process_deplibs($deplibs);
			if (defined $pdeplibs) {
				$lainfo->set('dependency_libs', "@@$pdeplibs");
			}
			if (! $gp->module) {
				$lainfo->write_shared_libs_log($origver);
			}
		}
		$lainfo->{'installed'} = 'yes';
		# write .lai file (.la file that will be installed)
		$lainfo->write($lai, $ofile);
	}
}

# populate arrays of non-pic and pic objects and remove these from @@ARGV
sub generate_objlist
{
	my $objs = shift;
	my $sobjs = shift;
	my $objsource = shift;

	my $result = [];
	foreach my $a (@@$objsource) {
		if ($a =~ m/\S+\.lo$/) {
			require LT::LoFile;
			my $ofile = basename($a);
			my $odir = dirname($a);
			my $loinfo = LT::LoFile->parse($a);
			if ($loinfo->{'non_pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'non_pic_object'};
				push @@$objs, $o;
			}
			if ($loinfo->{'pic_object'}) {
				my $o;
				$o .= "$odir/" if ($odir ne '.');
				$o .= $loinfo->{'pic_object'};
				push @@$sobjs, $o;
			}
		} elsif ($a =~ m/\S+\.o$/) {
			push @@$objs, $a;
		} else {
			push @@$result, $a;
		}
	}
	@@$objsource = @@$result;
}

# convert 4:5:8 into a list of numbers
sub parse_version_info
{
	my $vinfo = shift;

	if ($vinfo =~ m/^(\d+):(\d+):(\d+)$/) {
		return ($1, $2, $3);
	} elsif ($vinfo =~ m/^(\d+):(\d+)$/) {
		return ($1, $2, 0);
	} elsif ($vinfo =~ m/^(\d+)$/) {
		return ($1, 0, 0);
	} else {
		die "Error parsing -version-info $vinfo\n";
	}
}

# prepare dependency_libs information for the .la file which is installed
# i.e. remove any .libs directories and use the final libdir for all the
# .la files
sub process_deplibs
{
	my $linkflags = shift;

	my $result;

	foreach my $lf (@@$linkflags) {
		if ($lf =~ m/-L\S+\Q$ltdir\E$/) {
		} elsif ($lf =~ m/-L\./) {
		} elsif ($lf =~ m/\/\S+\/(\S+\.la)/) {
			my $lafile = $1;
			require LT::LaFile;
			my $libdir = LT::LaFile->parse($lf)->{'libdir'};
			if ($libdir eq '') {
				# this drops libraries which will not be
				# installed
				# XXX improve checks when adding to deplibs
				say "warning: $lf dropped from deplibs";
			} else {
				push @@$result, $libdir.'/'.$lafile;
			}
		} else {
			push @@$result, $lf;
		}
	}
	return $result;
}

package LT::Parser;
use File::Basename;
use Cwd qw(abs_path);
use LT::UList;
use LT::Util;
use LT::Trace;

my $calls = 0;

sub build_cache
{
	my ($self, $lainfo, $level) = @@_;
	my $o = $lainfo->{cached} = {
	    deplibs => LT::UList->new,
	    libdirs => LT::UList->new,
	    result => LT::UList->new
	};
	$self->internal_resolve_la($o, $lainfo->deplib_list,
	    $level+1);
	push(@@{$o->{deplibs}}, @@{$lainfo->deplib_list});
	if ($lainfo->{libdir} ne '') {
		push(@@{$o->{libdirs}}, $lainfo->{libdir});
	}
}

sub internal_resolve_la
{
	my ($self, $o, $args, $level) = @@_;
	$level //= 0;
	tsay {"resolve level: $level"};
	$o->{pthread} = 0;
	foreach my $arg (@@$args) {
# XXX still needed?
		if ($arg eq '-pthread') {
			$o->{pthread}++;
			next;
		}
		push(@@{$o->{result}}, $arg);
		next unless $arg =~ m/\.la$/;
		require LT::LaFile;
		my $lainfo = LT::LaFile->parse($arg);
		if  (!exists $lainfo->{cached}) {
			$self->build_cache($lainfo, $level+1);
		}
		$o->{pthread} += $lainfo->{cached}{pthread};
		for my $e (qw(deplibs libdirs result)) {
LT::Trace::print { "Calls to resolve_la: $calls\n" } if $calls;
			push(@@{$o->{$e}}, @@{$lainfo->{cached}{$e}});
		}
	}
	$calls++;
}

END
{
	LT::Trace::print { "Calls to resolve_la: $calls\n" } if $calls;
}

# resolve .la files until a level with empty dependency_libs is reached.
sub resolve_la
{
	my ($self, $deplibs, $libdirs) = @@_;

	tsay {"argvstring (pre resolve_la): @@{$self->{args}}"};
	my $o = { result => [], deplibs => $deplibs, libdirs => $libdirs};

	$self->internal_resolve_la($o, $self->{args});

# XXX still needed?
	if ($o->{pthread}) {
		unshift(@@{$o->{result}}, '-pthread');
		unshift(@@{$o->{deplibs}}, '-pthread');
	}

	tsay {"argvstring (post resolve_la): @@{$self->{args}}"};
	$self->{args} = $o->{result};
}

# Find first library or .la file for given library name.
# Returns pair of (type, file path), or empty list on error.
sub find_first_lib
{
	my ($self, $lib, $dirs, $gp) = @@_;

	my $name = $lib->{key};
	require LT::LaFile;

	push(@@$dirs, $gp->libsearchdirs) if $gp;
	for my $sd(".", @@$dirs) {
		my $file = LT::LaFile->find($name, $sd);
		tsay {"    LT::LaFile->find($name, $sd) returned \"$file\""} if defined $file;
		return ('LT::LaFile', $file) if defined $file;

		$file = $lib->findbest($sd, $name);
		if (defined $file) {
			tsay {"found $name in $sd"};
			return ('LT::Library', $file);
		} else {
			# XXX find static library instead?
			$file = "$sd/lib$name.a";
			if (-f $file) {
				tsay {"found static $name in $sd"};
				return ('LT::Library', $file);
			}
		}
	}
	return ();
}

# parse link flags and arguments
# eliminate all -L and -l flags in the argument string and add the
# corresponding directories and library names to the dirs/libs hashes.
# fill deplibs, to be taken up as dependencies in the resulting .la file...
# set up a hash for library files which haven't been found yet.
# deplibs are formed by collecting the original -L/-l flags, plus
# any .la files passed on the command line, EXCEPT when the .la file
# does not point to a shared library.
# pass 1
# -Lfoo, -lfoo, foo.a, foo.la
# recursively find .la files corresponding to -l flags; if there is no .la
# file, just inspect the library file itself for any dependencies.
sub internal_parse_linkargs1
{
	my ($self, $deplibs, $gp, $dirs, $libs, $args, $level) = @@_;

	$level //= 0;
	tsay {"parse_linkargs1, level: $level"};
	tsay {"  args: @@$args"};
	my $result   = $self->{result};

	# first read all directories where we can search libraries
	foreach my $arg (@@$args) {
		if ($arg =~ m/^-L(.*)/) {
			push(@@$dirs, $1);
			# XXX could be not adding actually, this is UList
			tsay {"    adding $_ to deplibs"}
			    if $level == 0;
			push(@@$deplibs, $arg);
		}
	}
	foreach my $arg (@@$args) {
		tsay {"  processing $arg"};
		if (!$arg || $arg eq '' || $arg =~ m/^\s+$/) {
			# skip empty arguments
		} elsif ($arg =~ m/^-Wc,(.*)/) {
			push(@@$result, $1);
		} elsif ($arg eq '-Xcompiler') {
			next;
		} elsif ($arg eq '-pthread') {
			$self->{pthread} = 1;
		} elsif ($arg =~ m/^-L(.*)/) {
			# already read earlier, do nothing
		} elsif ($arg =~ m/^-R(.*)/) {
			# -R options originating from .la resolution
			# those from @@ARGV are in @@Ropts
			$gp->add_R($1);
		} elsif ($arg =~ m/^-l(\S+)/) {
			my @@largs = ();
			my $key = $1;
			if (!exists $libs->{$key}) {
				$libs->create($key);
				my ($type, $file) = $self->find_first_lib($libs->{$key}, $dirs, $gp);
				if (!defined $type) {
					say "warning: could not find a $key library";
					next;
				} elsif ($type eq 'LT::LaFile') {
					my $absla = abs_path($file);
					$libs->{$key}->{lafile} = $absla;
					tsay {"    adding $absla to deplibs"}
					    if $level == 0;
					push(@@$deplibs, $absla);
					push(@@$result, $file);
					next;
				} elsif ($type eq 'LT::Library') {
					$libs->{$key}->{fullpath} = $file;
					my @@deps = $libs->{$key}->inspect;
					# add RPATH dirs to our search_dirs in case the dependent
					# library is installed under a non-standard path
					my @@rpdirs = $libs->{$key}->findrpaths;
					foreach my $r (@@rpdirs) {
						if (!LT::OSConfig->is_search_dir($r)) {
							push @@$dirs, $r;
							$gp->add_R($r);
						}
					}
					foreach my $d (@@deps) {
						my $k = basename($d);
						# XXX will fail for (_pic)?\.a$
						$k =~ s/^(\S+)\.so.*$/$1/;
						$k =~ s/^lib//;
						push(@@largs, "-l$k");
					}
				} else {
					die "internal error: unsupported" .
					    " library type \"$type\"";
				}
			}
			tsay {"    adding $arg to deplibs"} if $level == 0;
			push(@@$deplibs, $arg);
			push(@@$result, $arg);
			my $dummy = []; # no need to add deplibs recursively
			$self->internal_parse_linkargs1($dummy, $gp, $dirs,
			    $libs, \@@largs, $level+1) if @@largs;
		} elsif ($arg =~ m/(\S+\/)*(\S+)\.a$/) {
			(my $key = $2) =~ s/^lib//;
			push(@@$dirs, abs_dir($arg));
			$libs->create($key)->{fullpath} = $arg;
			push(@@$result, $arg);
		} elsif ($arg =~ m/(\S+\/)*(\S+)\.la$/) {
			(my $key = $2) =~ s/^lib//;
			push(@@$dirs, abs_dir($arg));
			my $fulla = abs_path($arg);
			require LT::LaFile;
			my $lainfo = LT::LaFile->parse($fulla);
			my $dlname = $lainfo->{dlname};
			my $oldlib = $lainfo->{old_library};
			my $libdir = $lainfo->{libdir};
			if ($dlname ne '') {
				if (!exists $libs->{$key}) {
					$libs->create($key)->{lafile} = $fulla;
				}
			}
			push(@@$result, $arg);
			push(@@$deplibs, $fulla) if $libdir ne '';
		} elsif ($arg =~ m/(\S+\/)*(\S+)\.so(\.\d+){2}/) {
			(my $key = $2) =~ s/^lib//;
			push(@@$dirs, abs_dir($arg));
			$libs->create($key);
			# not really normal argument
			# -lfoo should be used instead, so convert it
			push(@@$result, "-l$key");
		} else {
			push(@@$result, $arg);
		}
	}
}

sub parse_linkargs1
{
	my ($self, $deplibs, $gp, $dirs, $libs, $args) = @@_;
	$self->{result} = [];
	$self->internal_parse_linkargs1($deplibs, $gp, $dirs, $libs,
	    $self->{args});
	push(@@$deplibs, '-pthread') if $self->{pthread};
	$self->{args} = $self->{result};
}

# pass 2
# -Lfoo, -lfoo, foo.a
# no recursion in pass 2
# fill orderedlibs array, which is the sequence of shared libraries
#   after resolving all .la
# (this list may contain duplicates)
# fill staticlibs array, which is the sequence of static and convenience
#   libraries
# XXX the variable $parser->{seen_la_shared} will register whether or not
#     a .la file is found which refers to a shared library and which is not
#     yet installed
#     this is used to decide where to link executables and create wrappers
sub parse_linkargs2
{
	my ($self, $gp, $orderedlibs, $staticlibs, $dirs, $libs) = @@_;
	tsay {"parse_linkargs2"};
	tsay {"  args: @@{$self->{args}}"};
	my $result = [];

	foreach my $arg (@@{$self->{args}}) {
		tsay {"  processing $arg"};
		if (!$arg || $arg eq '' || $arg =~ m/^\s+$/) {
			# skip empty arguments
		} elsif ($arg eq '-lc') {
			# don't link explicitly with libc (just remove -lc)
		} elsif ($arg eq '-pthread') {
			$self->{pthread} = 1;
		} elsif ($arg =~ m/^-L(.*)/) {
			push(@@$dirs, $1);
		} elsif ($arg =~ m/^-R(.*)/) {
			# -R options originating from .la resolution
			# those from @@ARGV are in @@Ropts
			$gp->add_R($1);
		} elsif ($arg =~ m/^-l(.*)/) {
			my @@largs = ();
			my $key = $1;
			$libs->create($key);
			push(@@$orderedlibs, $key);
		} elsif ($arg =~ m/(\S+\/)*(\S+)\.a$/) {
			(my $key = $2) =~ s/^lib//;
			$libs->create($key)->{fullpath} = $arg;
			push(@@$staticlibs, $arg);
		} elsif ($arg =~ m/(\S+\/)*(\S+)\.la$/) {
			(my $key = $2) =~ s/^lib//;
			my $d = abs_dir($arg);
			push(@@$dirs, $d);
			my $fulla = abs_path($arg);
			require LT::LaFile;
			my $lainfo = LT::LaFile->parse($fulla);
			my $dlname = $lainfo->stringize('dlname');
			my $oldlib = $lainfo->stringize('old_library');
			my $installed = $lainfo->stringize('installed');
			if ($dlname ne '' && $installed eq 'no') {
				tsay {"seen uninstalled la shared in $arg"};
				$self->{seen_la_shared} = 1;
			}
			if ($dlname eq '' && -f "$d/$ltdir/$oldlib") {
				push(@@$staticlibs, "$d/$ltdir/$oldlib");
			} else {
				if (!exists $libs->{$key}) {
					$libs->create($key)->{lafile} = $fulla;
				}
				push(@@$orderedlibs, $key);
			}
		} elsif ($arg =~ m/^-Wl,(\S+)$/) {
			# libtool accepts a list of -Wl options separated
			# by commas, and possibly with a trailing comma
			# which is not accepted by the linker
			my @@Wlflags = split(/,/, $1);
			foreach my $f (@@Wlflags) {
				push(@@$result, "-Wl,$f");
			}
		} else {
			push(@@$result, $arg);
		}
	}
	tsay {"end parse_linkargs2"};
	return $result;
}

sub new
{
	my ($class, $args) = @@_;
	bless { args => $args, pthread => 0 }, $class;
}

package LT::Linker;
use LT::Trace;
use LT::Util;
use File::Basename;
use Cwd qw(abs_path);

sub new
{
	my $class = shift;
	bless {}, $class;
}

sub create_symlinks
{
	my ($self, $dir, $libs) = @@_;
	if (! -d $dir) {
		mkdir($dir) or die "Cannot mkdir($dir) : $!\n";
	}

	foreach my $l (values %$libs) {
		my $f = $l->{fullpath};
		next if !defined $f;
		next if $f =~ m/\.a$/;
		my $libnames = LT::UList->new;
		if (defined $l->{lafile}) {
			require LT::LaFile;
			my $lainfo = LT::LaFile->parse($l->{lafile});
			my $librarynames = $lainfo->stringize('library_names');
			push @@$libnames, split(/\s/, $librarynames);
		} else {
			push @@$libnames, basename($f);
		}
		foreach my $libfile (@@$libnames) {
			my $link = "$dir/$libfile";
			tsay {"ln -s $f $link"};
			next if -f $link;
			my $p = abs_path($f);
			if (!symlink($p, $link)) {
				die "Cannot create symlink($p, $link): $!\n"
				    unless  $!{EEXIST};
			}
		}
	}
	return $dir;
}

sub common1
{
	my ($self, $parser, $gp, $deplibs, $libdirs, $dirs, $libs) = @@_;

	$parser->resolve_la($deplibs, $libdirs);
	my $orderedlibs = LT::UList->new;
	my $staticlibs = [];
	my $args = $parser->parse_linkargs2($gp, $orderedlibs, $staticlibs, $dirs,
	    $libs);

	my $tiedlibs = tied(@@$orderedlibs);
	my $ie = $tiedlibs->indexof("estdc++");
	my $is = $tiedlibs->indexof("stdc++");
	if (defined($ie) and defined($is)) {
		tsay {"stripping stdc++ from orderedlibs due to having estdc++ already; ie=$ie, is=$is"};
		# check what library comes later
		if ($ie < $is) {
			splice(@@$orderedlibs, $ie, 1);
			splice(@@$orderedlibs, $is, 1, "estdc++");
			$ie = $is;
		} else {
			splice(@@$orderedlibs, $is, 1);
		}
	}
	tsay {"staticlibs = \n", join("\n", @@$staticlibs)};
	tsay {"orderedlibs = @@$orderedlibs"};
	return ($staticlibs, $orderedlibs, $args);
}

sub infer_libparameter
{
	my ($self, $a, $k) = @@_;
	my $lib = basename($a);
	if ($lib =~ m/^lib(.*)\.so(\.\d+){2}$/) {
		$lib = $1;
	} elsif ($lib =~ m/^lib(.*)\.so$/) {
		say "warning: library filename $a has no version number";
		$lib = $1;
	} else {
		say "warning: cannot derive -l flag from library filename $a, assuming hash key -l$k";
		$lib = $k;
	}
	return "-l$lib";
}

sub export_symbols
{
	my ($self, $ltconfig, $base, $gp, @@o) = @@_;
	my $symbolsfile;
	my $comment;
	if ($gp->export_symbols) {
		$symbolsfile = $gp->export_symbols;
		$comment = "/* version script derived from $symbolsfile */\n\n";
	} elsif ($gp->export_symbols_regex) {
		($symbolsfile = $base) =~ s/\.la$/.exp/;
		LT::Archive->get_symbollist($symbolsfile, $gp->export_symbols_regex, \@@o);
		$comment = "/* version script generated from\n * ".join(' ', @@o)."\n * using regexp ".$gp->export_symbols_regex. " */\n\n";
	} else {
		return ();
	}
	my $scriptfile;
	($scriptfile = $base) =~ s/(\.la)?$/.ver/;
	if ($ltconfig->{elf}) {
		open my $fh, ">", $scriptfile or die;
		open my $fh2, '<', $symbolsfile or die;
		print $fh $comment;
		print $fh "{\n";
		my $first = 1;
		while (<$fh2>) {
			chomp;
			if ($first) {
				print $fh "\tglobal:\n";
				$first = 0;
			}
			print $fh "\t\t$_;\n";
		}
		print $fh "\tlocal:\n\t\t\*;\n};\n";
		close($fh);
		close($fh2);
		return ("--version-script", $scriptfile);
	} else {
		return ("-retain-symbols-file", $symbolsfile);
	}
}

1;

@


1.35
log
@Have libtool ignore 'static-libtool-libs'. Previously it was unsupported and
passed straight through to the compiler, which gcc doesn't mind, but clang is
unhappy about.  Suggestion/ok aja@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.34 2016/12/25 13:46:18 zhuk Exp $
d156 3
a158 1
	    'version-number:');
@


1.34
log
@Teach libtool how to deal with both -lestdc++ and -lstdc++ in command line.

This helps to avoid linking both libraries, making -lestdc++ the only one
there. The concrete example would be print/poppler port after Qt5 update,
which is coming right now.

This hack would go away together with libestdc++...

Kind support on all the way by aja@@, thanks!
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.33 2016/11/03 10:23:01 ajacoutot Exp $
d153 1
d159 3
a161 2
	# 	no-install, no-undefined, precious-files-regex,
	# 	shrext, thread-safe, prefer-pic, prefer-non-pic
@


1.33
log
@Also ignore --no-undefined (we already ignore -no-undefined) which is
starting to show up more and more.

ok jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.32 2016/08/02 16:09:55 jca Exp $
d825 15
@


1.32
log
@Ignore the -bindir option, meaningless on OpenBSD.

Lack of -bindir handling is not a problem right now because -bindir is
passed to cc(1) which ignores it, and because read(2) on /usr/local/bin
returns 0 right now, so ld(1) copes with it.  But there are plans to
make read(2) fail with EISDIR.

Input from and bulk builds thanks to ajacoutot@@, ok ajacoutot@@ espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.31 2016/04/27 09:50:57 ajacoutot Exp $
d141 1
@


1.31
log
@typo: wil -> will
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.30 2015/09/21 08:49:06 ajacoutot Exp $
d130 1
d156 1
a156 1
	# XXX options ignored: dlopen, dlpreopen, no-fast-install,
@


1.30
log
@Fix a couple of libtool issues:

* when looking for a library, also look for an unversioned solib before falling
  back to using the static one (which may not even exist)

* when a library has no libtool file (.la) with a proper dependency_libs entry,
  libtool(1) falls back to using objdump to determine the depencencies;
  however this works only if dependencies are in standard search paths; fix it
  by looking at the RPATH entry in objdump then add non standard dirs to
  search_dirs and -rpath

inputs from and ok espie@@, ok jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.29 2014/04/27 18:08:35 zhuk Exp $
d134 1
a134 1
	    '-export-symbols:', sub { shortdie "the option is -export-symbols.\n--export-symbols wil be ignored by gnu libtool"; },
@


1.29
log
@Fix library search order in our libtool.

Before, libtool first searched all directories for .la files, and if
search failed, switched to actual libraries (.so/.a). But the correct way
is to check each directory first for .la, then for .so/.a.

The problem was reported by ajacoutot@@ who verified that the patch fixes
his case and okay'ed the initial diff. And jasper@@'s bulk uncovered a bug
which is fixed now (verified by another bulk).
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.28 2014/04/20 17:34:26 zhuk Exp $
d611 9
@


1.28
log
@Style improvement based on espie@@'s feedback: provide and use
LT::UList->new() instead of calling tie() manually. As a bonus, few
extra lines in actual code go away.

okay espie@@ who still thinks that I test things _before_ commit
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.27 2014/04/16 14:39:06 zhuk Exp $
d513 31
d596 7
a602 5
				require LT::LaFile;
				my $lafile = LT::LaFile->find($key, $dirs);
				if ($lafile) {
					$libs->{$key}->{lafile} = $lafile;
					my $absla = abs_path($lafile);
d606 1
a606 1
					push(@@$result, $lafile);
d608 2
a609 2
				} else {
					$libs->{$key}->resolve_library($dirs, 1, 0, 'notyet', $gp);
d613 1
d618 3
@


1.27
log
@Whitespace tweaks before further tweaks; no objections from ajacoutot@@.
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.26 2014/04/16 10:31:27 zhuk Exp $
d26 2
a27 1
my $search_dir_obj = tie(my @@search_dir_list, 'LT::UList');
d31 1
a31 1
	return if @@search_dir_list;
d38 1
a38 1
			push @@search_dir_list, split(/\:/o, $1);
d49 1
a49 1
	return @@search_dir_list;
d121 1
a121 2
	my $libdirs = [];			# list of libdirs
	tie (@@$libdirs, 'LT::UList');
d123 2
a124 2
	my $dirs = [];				# paths to find libraries
	tie (@@$dirs, 'LT::UList', '/usr/lib');	# always look here
d200 1
a200 2
	my $deplibs = [];	# list of dependent libraries (both -L and -l flags)
	tie (@@$deplibs, 'LT::UList');
d226 1
a226 2
		tie(my @@temp, 'LT::UList', @@Ropts, @@RPopts, $gp->Rresolved);
		my $RPdirs = \@@temp;
d448 4
a451 4
	    deplibs => [], libdirs => [], result => [] };
	tie @@{$o->{deplibs}}, 'LT::UList';
	tie @@{$o->{libdirs}}, 'LT::UList';
	tie @@{$o->{result}},  'LT::UList';
d745 1
a745 2
		my $libnames = [];
		tie (@@$libnames, 'LT::UList');
d773 1
a773 2
	my $orderedlibs = [];
	tie(@@$orderedlibs, 'LT::UList');
@


1.26
log
@Make directory ordering in our libtool stable. Fixes quiet a few issues
ajacoutot@@, me and probably others were seeing. No fallout in bulk build.

Input from espie@@ and ajacoutot@@.
Prodding by ajacoutot@@
Bulk test by jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.25 2014/03/19 02:16:22 afresh1 Exp $
d454 1
a454 1
	$self->internal_resolve_la($o, $lainfo->deplib_list, 
d572 1
a572 1
					tsay {"    adding $absla to deplibs"} 
d592 1
a592 1
			$self->internal_parse_linkargs1($dummy, $gp, $dirs, 
d632 1
a632 1
	$self->internal_parse_linkargs1($deplibs, $gp, $dirs, $libs, 
d634 1
a634 1
    	push(@@$deplibs, '-pthread') if $self->{pthread};
d756 1
a756 1
		}	
d779 1
a779 1
	my $args = $parser->parse_linkargs2($gp, $orderedlibs, $staticlibs, $dirs, 
@


1.25
log
@Remove lexical $_ from libtool in preparation for perl 5.18

OK and additional changes from espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.24 2013/01/10 21:34:29 millert Exp $
d24 3
a27 1
my ($search_dir_hash, $search_dir_list);
d30 1
a30 3
	return if defined $search_dir_list;
	$search_dir_list = [];
	$search_dir_hash = {};
d37 1
a37 4
			foreach my $d (split(/\:/o, $1)) {
				push @@$search_dir_list, $d;
				$search_dir_hash->{$d} = 1;
			}
d48 1
a48 1
	return @@$search_dir_list;
d55 1
a55 1
	return $search_dir_hash->{$dir};
d120 5
a124 6
	my $libdirs = [];	# list of libdirs
	my $libs = LT::Library::Stash->new;		# libraries
	my $dirs = {};		# paths to find libraries
	# put a priority in the dir hash
	# always look here
	$dirs->{'/usr/lib'} = 3;
d201 1
d227 2
a228 2
		my $RPdirs = [];
		@@$RPdirs = (@@Ropts, @@RPopts, $gp->Rresolved);
d326 1
a326 3
		my $finaldeplibs = reverse_zap_duplicates_ref($deplibs);
		tsay {"finaldeplibs = @@$finaldeplibs"};
		$lainfo->set('dependency_libs', "@@$finaldeplibs");
d341 1
a341 1
			my $pdeplibs = process_deplibs($finaldeplibs);
d428 1
a428 2
				$lf = $libdir.'/'.$lafile;
				push @@$result, $lf;
d440 1
d450 4
a453 1
	    deplibs => [], libdirs => [], result => []};
a459 5
	for my $e (qw(deplibs libdirs result)) {
		if (@@{$o->{$e}} > 50) {
			$o->{$e} = reverse_zap_duplicates_ref($o->{$e});
		}
	}
d469 1
d483 1
d504 2
d539 5
a543 6
			if (!exists $dirs->{$1}) {
				$dirs->{$1} = 1;
				tsay {"    adding $arg to deplibs"} 
				    if $level == 0;
				push(@@$deplibs, $arg);
			}
d596 1
a596 1
			$dirs->{abs_dir($arg)} = 1;
d601 1
a601 1
			$dirs->{abs_dir($arg)} = 1;
d617 1
a617 1
			$dirs->{abs_dir($arg)} = 1;
d666 1
a666 3
			if (!exists $dirs->{$1}) {
				$dirs->{$1} = 1;
			}
d683 1
a683 1
			$dirs->{$d} = 1;
d748 1
d753 1
a753 2
			@@$libnames = split /\s/, $librarynames;
			$libnames = reverse_zap_duplicates_ref($libnames);
d777 1
a782 2
	$orderedlibs = reverse_zap_duplicates_ref($orderedlibs);
	tsay {"final orderedlibs = @@$orderedlibs"};
@


1.24
log
@Honor -Wc and -Xcompiler in link mode like GNU does.  OK espie@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.23 2012/11/09 10:55:01 espie Exp $
d475 2
a476 2
	foreach my $_ (@@$args) {
		if ($_ eq '-pthread') {
d480 2
a481 2
		push(@@{$o->{result}}, $_);
		next unless m/\.la$/;
d483 1
a483 1
		my $lainfo = LT::LaFile->parse($_);
d540 2
a541 2
	foreach my $_ (@@$args) {
		if (m/^-L(.*)/) {
d544 1
a544 1
				tsay {"    adding $_ to deplibs"} 
d546 1
a546 1
				push @@$deplibs, $_;
d550 3
a552 3
	foreach my $_ (@@$args) {
		tsay {"  processing $_"};
		if (!$_ || $_ eq '' || m/^\s+$/) {
d554 1
a554 1
		} elsif (m/^-Wc,(.*)/) {
d556 1
a556 1
		} elsif ($_ eq '-Xcompiler') {
d558 1
a558 1
		} elsif ($_ eq '-pthread') {
d560 1
a560 1
		} elsif (m/^-L(.*)/) {
d562 1
a562 1
		} elsif (m/^-R(.*)/) {
d566 1
a566 1
		} elsif (m/^-l(\S+)/) {
d578 2
a579 2
					push @@$deplibs, $absla;
					push @@$result, $lafile;
d592 3
a594 3
			tsay {"    adding $_ to deplibs"} if $level == 0;
			push @@$deplibs, $_;
			push(@@$result, $_);
d598 1
a598 1
		} elsif (m/(\S+\/)*(\S+)\.a$/) {
d600 4
a603 4
			$dirs->{abs_dir($_)} = 1;
			$libs->create($key)->{fullpath} = $_;
			push(@@$result, $_);
		} elsif (m/(\S+\/)*(\S+)\.la$/) {
d605 2
a606 2
			$dirs->{abs_dir($_)} = 1;
			my $fulla = abs_path($_);
d617 1
a617 1
			push(@@$result, $_);
d619 1
a619 1
		} elsif (m/(\S+\/)*(\S+)\.so(\.\d+){2}/) {
d621 1
a621 1
			$dirs->{abs_dir($_)} = 1;
d627 1
a627 1
			push(@@$result, $_);
d661 3
a663 3
	foreach my $_ (@@{$self->{args}}) {
		tsay {"  processing $_"};
		if (!$_ || $_ eq '' || m/^\s+$/) {
d665 1
a665 1
		} elsif ($_ eq '-lc') {
d667 1
a667 1
		} elsif ($_ eq '-pthread') {
d669 1
a669 1
		} elsif (m/^-L(.*)/) {
d673 1
a673 1
		} elsif (m/^-R(.*)/) {
d677 1
a677 1
		} elsif (m/^-l(.*)/) {
d681 2
a682 2
			push @@$orderedlibs, $key;
		} elsif (m/(\S+\/)*(\S+)\.a$/) {
d684 3
a686 3
			$libs->create($key)->{fullpath} = $_;
			push(@@$staticlibs, $_);
		} elsif (m/(\S+\/)*(\S+)\.la$/) {
d688 1
a688 1
			my $d = abs_dir($_);
d690 1
a690 1
			my $fulla = abs_path($_);
d697 1
a697 1
				tsay {"seen uninstalled la shared in $_"};
d701 1
a701 1
				push @@$staticlibs, "$d/$ltdir/$oldlib";
d706 1
a706 1
				push @@$orderedlibs, $key;
d708 1
a708 1
		} elsif (m/^-Wl,(\S+)$/) {
d717 1
a717 1
			push(@@$result, $_);
@


1.23
log
@*really* filter symbols on elf systems: introduce a new "export_symbols"
method that does all the work to produce the right options (one option,
so that the *.ver file contains all useful information).

Have to cater to regexp: in particular, make sure to nm on every object
and static library we might need, so we don't lose anything.

Allow for the result to be empty (since some projects use -export-symbols-regex
everywhere, *including on binaries with empty symbol lists*)

should now be clean portswise.

As usual, a non working option means lots of weird fuck-ups to fix first...

thx to millert@@ for the hint, aja,jasper,landry for comments and testing.
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.22 2012/08/27 11:00:27 espie Exp $
d554 4
@


1.22
log
@vax does not get -rpath-link, but it also does not really need it.

as found out by sebastia@@ and used during 5.2 vax package build...
no ill side-effects so far, so do this as a stopgap measure
(matthieu@@ reports that our libtool is not yet very good for static-only
arches).
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.21 2012/08/04 14:26:02 espie Exp $
d803 40
@


1.21
log
@zap nonsense code
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.20 2012/07/18 09:33:16 espie Exp $
d138 1
@


1.20
log
@style
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.19 2012/07/13 13:25:12 espie Exp $
a187 3

	# eat multiple version-info arguments, we only accept the first.
	map { $_ = '' if ($_ =~ m/\d+:\d+:\d+/); } @@ARGV;
@


1.19
log
@minor cleanup
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.18 2012/07/13 11:56:12 espie Exp $
d308 1
a308 1
		$lainfo->{'libname'} = $libname;
d310 3
a312 3
			$lainfo->{'dlname'} = $sharedlib;
			$lainfo->{'library_names'} = $sharedlib;
			$lainfo->{'library_names'} .= " $sharedlib_symlink"
d316 3
a318 3
			$lainfo->{'current'} = $current;
			$lainfo->{'revision'} = $revision;
			$lainfo->{'age'} = $age;
d321 1
a321 1
			$lainfo->{'old_library'} = $staticlib;
d339 1
a339 1
			$lainfo->{'libdir'} = $RPopts[0];
@


1.18
log
@move stuff around some more, do not load link parts unless we are actually
linking.

(and always load basic linker class when we're actually linking)


Start making a proper "library stash class".
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.17 2012/07/12 17:07:12 espie Exp $
d607 3
a609 3
			my $dlname = $lainfo->{'dlname'};
			my $oldlib = $lainfo->{'old_library'};
			my $libdir = $lainfo->{'libdir'};
d657 1
a657 2
	$self->{result} = [];
	my $result = $self->{result};
d719 1
a719 1
	return $self->{result};
@


1.17
log
@okay, now the parser module is totally part of Mode/Link.pm, no reason
for a separate file
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.16 2012/07/12 12:35:21 espie Exp $
d96 1
d124 1
a124 1
	my $libs = {};		# libraries
d210 1
a210 1
		require LT::Program;
d239 1
a239 1
		require LT::LaFile;
a448 1
use LT::Library;
d568 1
a568 1
				$libs->{$key} = LT::Library->new($key);
a597 3
			if (!exists $libs->{$key}) {
				$libs->{$key} = LT::Library->new($key);
			}
d599 1
a599 1
			$libs->{$key}->{fullpath} = $_;
d612 1
a612 2
					$libs->{$key} = LT::Library->new($key);
					$libs->{$key}->{lafile} = $fulla;
d620 1
a620 3
			if (!exists $libs->{$key}) {
				$libs->{$key} = LT::Library->new($key);
			}
d679 1
a679 3
			if (!exists $libs->{$key}) {
				$libs->{$key} = LT::Library->new($key);
			}
d683 1
a683 4
			if (!exists $libs->{$key}) {
				$libs->{$key} = LT::Library->new($key);
			}
			$libs->{$key}->{fullpath} = $_;
d703 1
a703 2
					$libs->{$key} = LT::Library->new($key);
					$libs->{$key}->{lafile} = $fulla;
d727 79
@


1.16
log
@match what stupid gnu libtool is doing, namely -o is not a short option
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.15 2012/07/12 12:20:06 espie Exp $
a94 1
use LT::Parser;
d444 296
@


1.15
log
@allow "long options" to be one letter, enforce with !

make sure -L dir will error out.

"cute" gnu libtool: -x c    will vanish from linker arguments, but only
in library linking-mode.
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.14 2012/07/12 11:59:38 espie Exp $
d143 1
a143 1
	    'o:@@',
@


1.14
log
@later
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.13 2012/07/12 11:52:50 espie Exp $
d150 1
a150 1
	   # 'L', sub { shortdie "libtool does not allow spaces in -L dir\n"},
d185 1
@


1.13
log
@match gnu-libtool: error out if -L dir is used instead of -Ldir
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.12 2012/07/11 14:17:08 espie Exp $
d150 1
a150 1
	    'L', sub { shortdie "libtool does not allow spaces in -L dir\n"},
@


1.12
log
@duh, idiot
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.11 2012/07/11 14:12:44 espie Exp $
d150 1
@


1.11
log
@must check release is defined, it CAN be 0.
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.10 2012/07/11 13:54:48 espie Exp $
d291 1
a291 1
			($gp->release && !$gp->version_info)) {
d295 1
a295 1
			if ($gp->release) {
d311 1
a311 1
				if $gp->release;
@


1.10
log
@try to make code vaguely sane
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.9 2012/07/11 08:35:47 espie Exp $
d286 1
a286 1
		if ($gp->release) {
@


1.9
log
@do the ldconfig search dir properly
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.8 2012/07/10 16:41:01 espie Exp $
a205 2
	$parser->{result} = [];

d216 1
a216 3
		$parser->parse_linkargs1($deplibs, $gp,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
d266 1
a266 3
		$parser->parse_linkargs1($deplibs, $gp,
				$dirs, $libs, $parser->{args}, 0);
		$parser->{args} = $parser->{result};
@


1.8
log
@ouch, Rresolved and libsearchdirs no longer live in main, so make them
part of $gp as they should be...

Oh, and create an actual linker object for later.
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.7 2012/07/10 13:32:10 espie Exp $
d22 40
d166 1
a166 1
	$gp->add_libsearchdir(get_search_dirs(), './.libs');
a363 21
}

# XXX reuse code from SharedLibs.pm instead
sub get_search_dirs
{
	my @@libsearchdirs;
	open(my $fh, '-|', '/sbin/ldconfig -r');
	if (defined $fh) {
		while (<$fh>) {
			if (m/^\s*search directories:\s*(.*?)\s*$/o) {
				foreach my $d (split(/\:/o, $1)) {
					push @@libsearchdirs, $d;
				}
				last;
			}
		}
		close($fh);
	} else {
		die "Can't run ldconfig\n";
        }
	return @@libsearchdirs;
@


1.7
log
@bye-bye Getopt::Long
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.6 2012/07/10 12:24:45 espie Exp $
d22 29
a75 1
my @@libsearchdirs;
a82 1
	my @@Rresolved;		# -R options originating from .la resolution
a123 1
	@@libsearchdirs = get_search_dirs();
d126 1
a126 1
	push @@libsearchdirs, './.libs';
d178 1
a178 1
		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
d195 1
a195 1
		@@$RPdirs = (@@Ropts, @@RPopts, @@Rresolved);
d230 1
a230 1
		$parser->parse_linkargs1($deplibs, \@@Rresolved, \@@libsearchdirs,
@


1.6
log
@clean-up shit, pull some of LT::Util into ltconfig object
make that a somewhat more "real" object...
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.5 2012/07/09 10:52:26 espie Exp $
a44 1
our %opts;
a54 1
	my @@Ropts;		# -R options on the command line
a55 1
	my @@RPopts;		# -rpath options
d63 27
a89 26
	$gp->getoptions('all-static'		=> \$opts{'all-static'},
			'avoid-version'		=> \$opts{'avoid-version'},
			'dlopen=s{1}'		=> \$opts{'dlopen'},
			'dlpreopen=s{1}'	=> \$opts{'dlpreopen'},
			'export-dynamic'	=> \$opts{'export-dynamic'},
			'export-symbols=s'	=> \$opts{'export-symbols'},
			'export-symbols-regex=s'=> \$opts{'export-symbols-regex'},
			'module'		=> \$opts{'module'},
			'no-fast-install'	=> \$opts{'no-fast-install'},
			'no-install'		=> \$opts{'no-install'},
			'no-undefined'		=> \$opts{'no-undefined'},
			'o=s'			=> \$opts{'o'},
			'objectlist=s'		=> \$opts{'objectlist'},
			'precious-files-regex=s'=> \$opts{'precious-files-regex'},
			'prefer-pic'		=> \$opts{'prefer-pic'},
			'prefer-non-pic'	=> \$opts{'prefer-non-pic'},
			'release=s'		=> \$opts{'release'},
			'rpath=s'		=> \@@RPopts,
			'R=s'			=> \@@Ropts,
			'shrext=s'		=> \$opts{'shrext'},
			'static'		=> \$opts{'static'},
			'thread-safe'		=> \$opts{'thread-safe'},
			'version-info=s{1}'	=> \$opts{'version-info'},
			'version_info=s{1}'	=> \$opts{'version-info'},
			'version-number=s{1}'	=> \$opts{'version-info'},
		);
d94 3
d102 2
a103 3
	my $outfile = $opts{'o'};
	if (!$outfile) {
		die "No output file given.\n";
d105 5
d126 2
a127 2
	if ($opts{'objectlist'}) {
		my $objectlist = $opts{'objectlist'};
d148 1
a148 1
		if ($opts{'export-dynamic'}) {
d172 1
a172 1
		$program->link($ltprog, $ltconfig, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
d178 3
a180 3
		$shared = 1 if ($opts{'version-info'} ||
				$opts{'avoid-version'} ||
				$opts{module});
d198 1
a198 1
		if ($opts{'static'} || $opts{'all-static'}) {
d215 2
a216 2
		if ($opts{'version-info'}) {
			($current, $revision, $age) = parse_version_info($opts{'version-info'});
d226 1
a226 1
		if (defined $opts{release}) {
d228 1
a228 1
			$sharedlib = $libname.'-'.$opts{release}.'.so';
d230 2
a231 2
		if ($opts{'avoid-version'} ||
			(defined $opts{release} && !$opts{'version-info'})) {
d235 1
a235 1
			if (defined $opts{release}) {
d251 2
a252 2
				if (defined $opts{release});
			$lainfo->link($ltprog, $ltconfig, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
d260 1
a260 1
			$lainfo->link($ltprog, $ltconfig, $ofile, $staticlib, $odir, 0, ($convenience && @@sobjs > 0) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
d265 1
a265 1
		$lainfo->{shouldnotlink} = $opts{module} ? 'yes' : 'no';
d267 1
a267 1
		unshift @@$deplibs, @@Ropts if (@@Ropts);
d290 1
a290 1
			if (! $opts{module}) {
@


1.5
log
@implement help-all
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.4 2012/07/09 10:34:52 espie Exp $
d52 1
a52 1
	my ($class, $ltprog, $gp, $noshared) = @@_;
d54 1
d167 1
a167 1
		$program->link($ltprog, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
d247 1
a247 1
			$lainfo->link($ltprog, $ofile, $sharedlib, $odir, 1, \@@sobjs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
d255 1
a255 1
			$lainfo->link($ltprog, $ofile, $staticlib, $odir, 0, ($convenience && @@sobjs > 0) ? \@@sobjs : \@@objs, $dirs, $libs, $deplibs, $libdirs, $parser, \%opts);
@


1.4
log
@framework for handling  help better
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.3 2012/07/04 12:39:34 espie Exp $
d36 8
@


1.3
log
@- start cleaning up options handling: put things into a separate package
that encapsulates accesses to Getopt::Long (which is badly suited for us
actually)
- simplify LT::Trace syntax
- implement --tag checks that mimic actual libtool
- add libtool comp support, as per libtool2
(but keep implicit modes as per libtool1)
- prevent shell code in nm execution

okay jasper@@, steven@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.2 2012/06/28 18:24:42 espie Exp $
d23 2
@


1.2
log
@a few minor cleanup and performance tweaks (is_wrapper doesn't need to
scan large binary files)
okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD: Link.pm,v 1.1 2012/06/24 13:44:53 espie Exp $
d25 1
d42 1
a42 1
	my ($class, $ltprog, $gp, $tags, $noshared) = @@_;
d94 1
a94 1
	LT::Trace::debug {"outfile = $outfile\n"};
d103 1
a103 1
	LT::Trace::debug {"linkmode: $linkmode\n"};
d119 2
a120 2
	LT::Trace::debug {"objs = @@objs\n"};
	LT::Trace::debug {"sobjs = @@sobjs\n"};
d139 2
a140 2
		LT::Trace::debug {"end parse_linkargs1\n"};
		LT::Trace::debug {"deplibs = @@$deplibs\n"};
d145 1
a145 1
				LT::Trace::debug {"no non-pic libtool objects found, trying pic objects...\n"};
d148 2
a149 2
				LT::Trace::debug {"no libtool objects of any kind found\n"};
				LT::Trace::debug {"hoping for real objects in ARGV...\n"};
d191 2
a192 2
		LT::Trace::debug {"end parse_linkargs1\n"};
		LT::Trace::debug {"deplibs = @@$deplibs\n"};
d225 2
a226 2
		$static = 0 if ($shared && grep { $_ eq 'disable-static' } @@$tags);
		$shared = 0 if ($static && grep { $_ eq 'disable-shared' } @@$tags);
d228 1
a228 1
		LT::Trace::debug {"SHARED: $shared\nSTATIC: $static\n"};
d237 1
a237 1
			LT::Trace::debug {"sharedlib: $sharedlib\n"};
d245 2
a246 1
			LT::Trace::debug {($convenience ? "convenience" : "static")." lib: $staticlib\n"};
d252 1
a252 1
		LT::Trace::debug {"deplibs = @@$deplibs\n"};
d254 1
a254 1
		LT::Trace::debug {"finaldeplibs = @@$finaldeplibs\n"};
d258 2
a259 1
				LT::Trace::debug {"more than 1 -rpath option given, taking the first: ", $RPopts[0], "\n"};
@


1.1
log
@clean-up the mess: move modes into separate files,
this makes dependencies more apparent.
This should also speed libtool up a bit, since it won't load all the code
all the time, but only the parts that are actually needed (to wit "compile
mode" which is much smaller).

okay jasper@@
@
text
@d2 1
a2 1
# $OpenBSD$
d313 2
a314 2
			my $ofile = basename $a;
			my $odir = dirname $a;
@

