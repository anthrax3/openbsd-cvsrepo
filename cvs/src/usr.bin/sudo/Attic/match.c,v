head	1.10;
access;
symbols
	OPENBSD_5_7:1.9.0.8
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.12
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.10
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.6
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.9;
commitid	8ra5qnWqy2bUhcZn;

1.9
date	2012.05.16.14.01.32;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.06.14.06.30;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.09.18.29.57;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.22.22.41.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.07.18.43.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1996, 1998-2005, 2007-2010
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#ifdef HAVE_FNMATCH
# include <fnmatch.h>
#endif /* HAVE_FNMATCH */
#ifdef HAVE_EXTENDED_GLOB
# include <glob.h>
#endif /* HAVE_EXTENDED_GLOB */
#ifdef HAVE_NETGROUP_H
# include <netgroup.h>
#endif /* HAVE_NETGROUP_H */
#include <ctype.h>
#include <pwd.h>
#include <grp.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#ifdef HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#include "sudo.h"
#include "interfaces.h"
#include "parse.h"
#include <gram.h>

#ifndef HAVE_FNMATCH
# include "emul/fnmatch.h"
#endif /* HAVE_FNMATCH */
#ifndef HAVE_EXTENDED_GLOB
# include "emul/glob.h"
#endif /* HAVE_EXTENDED_GLOB */
#ifdef USING_NONUNIX_GROUPS
# include "nonunix.h"
#endif /* USING_NONUNIX_GROUPS */

static struct member_list empty;

static int command_matches_dir __P((char *, size_t));
static int command_matches_glob __P((char *, char *));
static int command_matches_fnmatch __P((char *, char *));
static int command_matches_normal __P((char *, char *));

/*
 * Returns TRUE if string 's' contains meta characters.
 */
#define has_meta(s)	(strpbrk(s, "\\?*[]") != NULL)

/*
 * Check for user described by pw in a list of members.
 * Returns ALLOW, DENY or UNSPEC.
 */
static int
_userlist_matches(pw, list)
    struct passwd *pw;
    struct member_list *list;
{
    struct member *m;
    struct alias *a;
    int rval, matched = UNSPEC;

    tq_foreach_rev(list, m) {
	switch (m->type) {
	    case ALL:
		matched = !m->negated;
		break;
	    case NETGROUP:
		if (netgr_matches(m->name, NULL, NULL, pw->pw_name))
		    matched = !m->negated;
		break;
	    case USERGROUP:
		if (usergr_matches(m->name, pw->pw_name, pw))
		    matched = !m->negated;
		break;
	    case ALIAS:
		if ((a = alias_find(m->name, USERALIAS)) != NULL) {
		    rval = _userlist_matches(pw, &a->members);
		    if (rval != UNSPEC)
			matched = m->negated ? !rval : rval;
		    break;
		}
		/* FALLTHROUGH */
	    case WORD:
		if (userpw_matches(m->name, pw->pw_name, pw))
		    matched = !m->negated;
		break;
	}
	if (matched != UNSPEC)
	    break;
    }
    return(matched);
}

int
userlist_matches(pw, list)
    struct passwd *pw;
    struct member_list *list;
{
    alias_seqno++;
    return(_userlist_matches(pw, list));
}

/*
 * Check for user described by pw in a list of members.
 * If both lists are empty compare against def_runas_default.
 * Returns ALLOW, DENY or UNSPEC.
 */
static int
_runaslist_matches(user_list, group_list)
    struct member_list *user_list;
    struct member_list *group_list;
{
    struct member *m;
    struct alias *a;
    int rval;
    int user_matched = UNSPEC;
    int group_matched = UNSPEC;

    if (runas_pw != NULL) {
	/* If no runas user or runas group listed in sudoers, use default. */
	if (tq_empty(user_list) && tq_empty(group_list))
	    return(userpw_matches(def_runas_default, runas_pw->pw_name, runas_pw));

	tq_foreach_rev(user_list, m) {
	    switch (m->type) {
		case ALL:
		    user_matched = !m->negated;
		    break;
		case NETGROUP:
		    if (netgr_matches(m->name, NULL, NULL, runas_pw->pw_name))
			user_matched = !m->negated;
		    break;
		case USERGROUP:
		    if (usergr_matches(m->name, runas_pw->pw_name, runas_pw))
			user_matched = !m->negated;
		    break;
		case ALIAS:
		    if ((a = alias_find(m->name, RUNASALIAS)) != NULL) {
			rval = _runaslist_matches(&a->members, &empty);
			if (rval != UNSPEC)
			    user_matched = m->negated ? !rval : rval;
			break;
		    }
		    /* FALLTHROUGH */
		case WORD:
		    if (userpw_matches(m->name, runas_pw->pw_name, runas_pw))
			user_matched = !m->negated;
		    break;
	    }
	    if (user_matched != UNSPEC)
		break;
	}
    }

    if (runas_gr != NULL) {
	if (user_matched == UNSPEC) {
	    if (runas_pw == NULL || strcmp(runas_pw->pw_name, user_name) == 0)
		user_matched = ALLOW;	/* only changing group */
	}
	tq_foreach_rev(group_list, m) {
	    switch (m->type) {
		case ALL:
		    group_matched = !m->negated;
		    break;
		case ALIAS:
		    if ((a = alias_find(m->name, RUNASALIAS)) != NULL) {
			rval = _runaslist_matches(&a->members, &empty);
			if (rval != UNSPEC)
			    group_matched = m->negated ? !rval : rval;
			break;
		    }
		    /* FALLTHROUGH */
		case WORD:
		    if (group_matches(m->name, runas_gr))
			group_matched = !m->negated;
		    break;
	    }
	    if (group_matched != UNSPEC)
		break;
	}
    }

    if (user_matched == DENY || group_matched == DENY)
	return(DENY);
    if (user_matched == group_matched || runas_gr == NULL)
	return(user_matched);
    return(UNSPEC);
}

int
runaslist_matches(user_list, group_list)
    struct member_list *user_list;
    struct member_list *group_list;
{
    alias_seqno++;
    return(_runaslist_matches(user_list ? user_list : &empty,
	group_list ? group_list : &empty));
}

/*
 * Check for host and shost in a list of members.
 * Returns ALLOW, DENY or UNSPEC.
 */
static int
_hostlist_matches(list)
    struct member_list *list;
{
    struct member *m;
    struct alias *a;
    int rval, matched = UNSPEC;

    tq_foreach_rev(list, m) {
	switch (m->type) {
	    case ALL:
		matched = !m->negated;
		break;
	    case NETGROUP:
		if (netgr_matches(m->name, user_host, user_shost, NULL))
		    matched = !m->negated;
		break;
	    case NTWKADDR:
		if (addr_matches(m->name))
		    matched = !m->negated;
		break;
	    case ALIAS:
		if ((a = alias_find(m->name, HOSTALIAS)) != NULL) {
		    rval = _hostlist_matches(&a->members);
		    if (rval != UNSPEC)
			matched = m->negated ? !rval : rval;
		    break;
		}
		/* FALLTHROUGH */
	    case WORD:
		if (hostname_matches(user_shost, user_host, m->name))
		    matched = !m->negated;
		break;
	}
	if (matched != UNSPEC)
	    break;
    }
    return(matched);
}

int
hostlist_matches(list)
    struct member_list *list;
{
    alias_seqno++;
    return(_hostlist_matches(list));
}

/*
 * Check for cmnd and args in a list of members.
 * Returns ALLOW, DENY or UNSPEC.
 */
static int
_cmndlist_matches(list)
    struct member_list *list;
{
    struct member *m;
    int matched = UNSPEC;

    tq_foreach_rev(list, m) {
	matched = cmnd_matches(m);
	if (matched != UNSPEC)
	    break;
    }
    return(matched);
}

int
cmndlist_matches(list)
    struct member_list *list;
{
    alias_seqno++;
    return(_cmndlist_matches(list));
}

/*
 * Check cmnd and args.
 * Returns ALLOW, DENY or UNSPEC.
 */
int
cmnd_matches(m)
    struct member *m;
{
    struct alias *a;
    struct sudo_command *c;
    int rval, matched = UNSPEC;

    switch (m->type) {
	case ALL:
	    matched = !m->negated;
	    break;
	case ALIAS:
	    alias_seqno++;
	    if ((a = alias_find(m->name, CMNDALIAS)) != NULL) {
		rval = _cmndlist_matches(&a->members);
		if (rval != UNSPEC)
		    matched = m->negated ? !rval : rval;
	    }
	    break;
	case COMMAND:
	    c = (struct sudo_command *)m->name;
	    if (command_matches(c->cmnd, c->args))
		matched = !m->negated;
	    break;
    }
    return(matched);
}

/*
 * If path doesn't end in /, return TRUE iff cmnd & path name the same inode;
 * otherwise, return TRUE if user_cmnd names one of the inodes in path.
 */
int
command_matches(sudoers_cmnd, sudoers_args)
    char *sudoers_cmnd;
    char *sudoers_args;
{
    /* Check for pseudo-commands */
    if (sudoers_cmnd[0] != '/') {
	/*
	 * Return true if both sudoers_cmnd and user_cmnd are "sudoedit" AND
	 *  a) there are no args in sudoers OR
	 *  b) there are no args on command line and none req by sudoers OR
	 *  c) there are args in sudoers and on command line and they match
	 */
	if (strcmp(sudoers_cmnd, "sudoedit") != 0 ||
	    strcmp(user_cmnd, "sudoedit") != 0)
	    return(FALSE);
	if (!sudoers_args ||
	    (!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args &&
	     fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(sudoers_cmnd);
	    return(TRUE);
	} else
	    return(FALSE);
    }

    if (has_meta(sudoers_cmnd)) {
	/*
	 * If sudoers_cmnd has meta characters in it, we need to
	 * use glob(3) and/or fnmatch(3) to do the matching.
	 */
	if (def_fast_glob)
	    return(command_matches_fnmatch(sudoers_cmnd, sudoers_args));
	return(command_matches_glob(sudoers_cmnd, sudoers_args));
    }
    return(command_matches_normal(sudoers_cmnd, sudoers_args));
}

static int
command_matches_fnmatch(sudoers_cmnd, sudoers_args)
    char *sudoers_cmnd;
    char *sudoers_args;
{
    /*
     * Return true if fnmatch(3) succeeds AND
     *  a) there are no args in sudoers OR
     *  b) there are no args on command line and none required by sudoers OR
     *  c) there are args in sudoers and on command line and they match
     * else return false.
     */
    if (fnmatch(sudoers_cmnd, user_cmnd, FNM_PATHNAME) != 0)
	return(FALSE);
    if (!sudoers_args ||
	(!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	(sudoers_args &&
	 fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	if (safe_cmnd)
	    free(safe_cmnd);
	safe_cmnd = estrdup(user_cmnd);
	return(TRUE);
    } else
	return(FALSE);
}

static int
command_matches_glob(sudoers_cmnd, sudoers_args)
    char *sudoers_cmnd;
    char *sudoers_args;
{
    struct stat sudoers_stat;
    size_t dlen;
    char **ap, *base, *cp;
    glob_t gl;

    /*
     * First check to see if we can avoid the call to glob(3).
     * Short circuit if there are no meta chars in the command itself
     * and user_base and basename(sudoers_cmnd) don't match.
     */
    dlen = strlen(sudoers_cmnd);
    if (sudoers_cmnd[dlen - 1] != '/') {
	if ((base = strrchr(sudoers_cmnd, '/')) != NULL) {
	    base++;
	    if (!has_meta(base) && strcmp(user_base, base) != 0)
		return(FALSE);
	}
    }
    /*
     * Return true if we find a match in the glob(3) results AND
     *  a) there are no args in sudoers OR
     *  b) there are no args on command line and none required by sudoers OR
     *  c) there are args in sudoers and on command line and they match
     * else return false.
     */
#define GLOB_FLAGS	(GLOB_NOSORT | GLOB_MARK | GLOB_BRACE | GLOB_TILDE)
    if (glob(sudoers_cmnd, GLOB_FLAGS, NULL, &gl) != 0 || gl.gl_pathc == 0) {
	globfree(&gl);
	return(FALSE);
    }
    /* For each glob match, compare basename, st_dev and st_ino. */
    for (ap = gl.gl_pathv; (cp = *ap) != NULL; ap++) {
	/* If it ends in '/' it is a directory spec. */
	dlen = strlen(cp);
	if (cp[dlen - 1] == '/') {
	    if (command_matches_dir(cp, dlen))
		return(TRUE);
	    continue;
	}

	/* Only proceed if user_base and basename(cp) match */
	if ((base = strrchr(cp, '/')) != NULL)
	    base++;
	else
	    base = cp;
	if (strcmp(user_base, base) != 0 ||
	    stat(cp, &sudoers_stat) == -1)
	    continue;
	if (user_stat == NULL ||
	    (user_stat->st_dev == sudoers_stat.st_dev &&
	    user_stat->st_ino == sudoers_stat.st_ino)) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(cp);
	    break;
	}
    }
    globfree(&gl);
    if (cp == NULL)
	return(FALSE);

    if (!sudoers_args ||
	(!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	(sudoers_args &&
	 fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	efree(safe_cmnd);
	safe_cmnd = estrdup(user_cmnd);
	return(TRUE);
    }
    return(FALSE);
}

static int
command_matches_normal(sudoers_cmnd, sudoers_args)
    char *sudoers_cmnd;
    char *sudoers_args;
{
    struct stat sudoers_stat;
    char *base;
    size_t dlen;

    /* If it ends in '/' it is a directory spec. */
    dlen = strlen(sudoers_cmnd);
    if (sudoers_cmnd[dlen - 1] == '/')
	return(command_matches_dir(sudoers_cmnd, dlen));

    /* Only proceed if user_base and basename(sudoers_cmnd) match */
    if ((base = strrchr(sudoers_cmnd, '/')) == NULL)
	base = sudoers_cmnd;
    else
	base++;
    if (strcmp(user_base, base) != 0 ||
	stat(sudoers_cmnd, &sudoers_stat) == -1)
	return(FALSE);

    /*
     * Return true if inode/device matches AND
     *  a) there are no args in sudoers OR
     *  b) there are no args on command line and none req by sudoers OR
     *  c) there are args in sudoers and on command line and they match
     */
    if (user_stat != NULL &&
	(user_stat->st_dev != sudoers_stat.st_dev ||
	user_stat->st_ino != sudoers_stat.st_ino))
	return(FALSE);
    if (!sudoers_args ||
	(!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	(sudoers_args &&
	 fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	efree(safe_cmnd);
	safe_cmnd = estrdup(sudoers_cmnd);
	return(TRUE);
    }
    return(FALSE);
}

/*
 * Return TRUE if user_cmnd names one of the inodes in dir, else FALSE.
 */
static int
command_matches_dir(sudoers_dir, dlen)
    char *sudoers_dir;
    size_t dlen;
{
    struct stat sudoers_stat;
    struct dirent *dent;
    char buf[PATH_MAX];
    DIR *dirp;

    /*
     * Grot through directory entries, looking for user_base.
     */
    dirp = opendir(sudoers_dir);
    if (dirp == NULL)
	return(FALSE);

    if (strlcpy(buf, sudoers_dir, sizeof(buf)) >= sizeof(buf)) {
	closedir(dirp);
	return(FALSE);
    }
    while ((dent = readdir(dirp)) != NULL) {
	/* ignore paths > PATH_MAX (XXX - log) */
	buf[dlen] = '\0';
	if (strlcat(buf, dent->d_name, sizeof(buf)) >= sizeof(buf))
	    continue;

	/* only stat if basenames are the same */
	if (strcmp(user_base, dent->d_name) != 0 ||
	    stat(buf, &sudoers_stat) == -1)
	    continue;
	if (user_stat->st_dev == sudoers_stat.st_dev &&
	    user_stat->st_ino == sudoers_stat.st_ino) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(buf);
	    break;
	}
    }

    closedir(dirp);
    return(dent != NULL);
}

static int
addr_matches_if(n)
    char *n;
{
    int i;
    struct in_addr addr;
    struct interface *ifp;
#ifdef HAVE_IN6_ADDR
    struct in6_addr addr6;
    int j;
#endif
    int family;

#ifdef HAVE_IN6_ADDR
    if (inet_pton(AF_INET6, n, &addr6) > 0) {
	family = AF_INET6;
    } else
#endif
    {
	family = AF_INET;
	addr.s_addr = inet_addr(n);
    }

    for (i = 0; i < num_interfaces; i++) {
	ifp = &interfaces[i];
	if (ifp->family != family)
	    continue;
	switch (family) {
	    case AF_INET:
		if (ifp->addr.ip4.s_addr == addr.s_addr ||
		    (ifp->addr.ip4.s_addr & ifp->netmask.ip4.s_addr)
		    == addr.s_addr)
		    return(TRUE);
		break;
#ifdef HAVE_IN6_ADDR
	    case AF_INET6:
		if (memcmp(ifp->addr.ip6.s6_addr, addr6.s6_addr,
		    sizeof(addr6.s6_addr)) == 0)
		    return(TRUE);
		for (j = 0; j < sizeof(addr6.s6_addr); j++) {
		    if ((ifp->addr.ip6.s6_addr[j] & ifp->netmask.ip6.s6_addr[j]) != addr6.s6_addr[j])
			break;
		}
		if (j == sizeof(addr6.s6_addr))
		    return(TRUE);
		break;
#endif
	}
    }

    return(FALSE);
}

static int
addr_matches_if_netmask(n, m)
    char *n;
    char *m;
{
    int i;
    struct in_addr addr, mask;
    struct interface *ifp;
#ifdef HAVE_IN6_ADDR
    struct in6_addr addr6, mask6;
    int j;
#endif
    int family;

#ifdef HAVE_IN6_ADDR
    if (inet_pton(AF_INET6, n, &addr6) > 0)
	family = AF_INET6;
    else
#endif
    {
	family = AF_INET;
	addr.s_addr = inet_addr(n);
    }

    if (family == AF_INET) {
	if (strchr(m, '.'))
	    mask.s_addr = inet_addr(m);
	else {
	    i = 32 - atoi(m);
	    mask.s_addr = 0xffffffff;
	    mask.s_addr >>= i;
	    mask.s_addr <<= i;
	    mask.s_addr = htonl(mask.s_addr);
	}
    }
#ifdef HAVE_IN6_ADDR
    else {
	if (inet_pton(AF_INET6, m, &mask6) <= 0) {
	    j = atoi(m);
	    for (i = 0; i < 16; i++) {
		if (j < i * 8)
		    mask6.s6_addr[i] = 0;
		else if (i * 8 + 8 <= j)
		    mask6.s6_addr[i] = 0xff;
		else
		    mask6.s6_addr[i] = 0xff00 >> (j - i * 8);
	    }
	}
    }
#endif /* HAVE_IN6_ADDR */

    for (i = 0; i < num_interfaces; i++) {
	ifp = &interfaces[i];
	if (ifp->family != family)
	    continue;
	switch (family) {
	    case AF_INET:
		if ((ifp->addr.ip4.s_addr & mask.s_addr) == addr.s_addr)
		    return(TRUE);
		break;
#ifdef HAVE_IN6_ADDR
	    case AF_INET6:
		for (j = 0; j < sizeof(addr6.s6_addr); j++) {
		    if ((ifp->addr.ip6.s6_addr[j] & mask6.s6_addr[j]) != addr6.s6_addr[j])
			break;
		}
		if (j == sizeof(addr6.s6_addr))
		    return(TRUE);
		break;
#endif /* HAVE_IN6_ADDR */
	}
    }

    return(FALSE);
}

/*
 * Returns TRUE if "n" is one of our ip addresses or if
 * "n" is a network that we are on, else returns FALSE.
 */
int
addr_matches(n)
    char *n;
{
    char *m;
    int retval;

    /* If there's an explicit netmask, use it. */
    if ((m = strchr(n, '/'))) {
	*m++ = '\0';
	retval = addr_matches_if_netmask(n, m);
	*(m - 1) = '/';
    } else
	retval = addr_matches_if(n);

    return(retval);
}

/*
 * Returns TRUE if the hostname matches the pattern, else FALSE
 */
int
hostname_matches(shost, lhost, pattern)
    char *shost;
    char *lhost;
    char *pattern;
{
    if (has_meta(pattern)) {
	if (strchr(pattern, '.'))
	    return(!fnmatch(pattern, lhost, FNM_CASEFOLD));
	else
	    return(!fnmatch(pattern, shost, FNM_CASEFOLD));
    } else {
	if (strchr(pattern, '.'))
	    return(!strcasecmp(lhost, pattern));
	else
	    return(!strcasecmp(shost, pattern));
    }
}

/*
 *  Returns TRUE if the user/uid from sudoers matches the specified user/uid,
 *  else returns FALSE.
 */
int
userpw_matches(sudoers_user, user, pw)
    char *sudoers_user;
    char *user;
    struct passwd *pw;
{
    if (pw != NULL && *sudoers_user == '#') {
	uid_t uid = (uid_t) atoi(sudoers_user + 1);
	if (uid == pw->pw_uid)
	    return(TRUE);
    }
    return(strcmp(sudoers_user, user) == 0);
}

/*
 *  Returns TRUE if the group/gid from sudoers matches the specified group/gid,
 *  else returns FALSE.
 */
int
group_matches(sudoers_group, gr)
    char *sudoers_group;
    struct group *gr;
{
    if (*sudoers_group == '#') {
	gid_t gid = (gid_t) atoi(sudoers_group + 1);
	if (gid == gr->gr_gid)
	    return(TRUE);
    }
    return(strcmp(gr->gr_name, sudoers_group) == 0);
}

/*
 *  Returns TRUE if the given user belongs to the named group,
 *  else returns FALSE.
 */
int
usergr_matches(group, user, pw)
    char *group;
    char *user;
    struct passwd *pw;
{
    struct group *grp = NULL;
    char **cur;
    int i;

    /* make sure we have a valid usergroup, sudo style */
    if (*group++ != '%')
	return(FALSE);

#ifdef USING_NONUNIX_GROUPS
    if (*group == ':')
	return(sudo_nonunix_groupcheck(++group, user, pw));   
#endif /* USING_NONUNIX_GROUPS */

    /* look up user's primary gid in the passwd file */
    if (pw == NULL && (pw = sudo_getpwnam(user)) == NULL)
	goto try_supplementary;

    /* check against user's primary (passwd file) gid */
    if ((grp = sudo_getgrnam(group)) == NULL)
	goto try_supplementary;
    if (grp->gr_gid == pw->pw_gid)
	return(TRUE);

    /*
     * If we are matching the invoking or list user and that user has a
     * supplementary group vector, check it first.
     */
    if (strcmp(user, list_pw ? list_pw->pw_name : user_name) == 0) {
	for (i = 0; i < user_ngroups; i++)
	    if (grp->gr_gid == user_groups[i])
		return(TRUE);
    }

try_supplementary:
    if (grp != NULL && grp->gr_mem != NULL) {
	for (cur = grp->gr_mem; *cur; cur++)
	    if (strcmp(*cur, user) == 0)
		return(TRUE);
    }

#ifdef USING_NONUNIX_GROUPS
    /* not a Unix group, could be an AD group */
    if (sudo_nonunix_groupcheck_available() &&
	sudo_nonunix_groupcheck(group, user, pw))
    	return(TRUE);
#endif /* USING_NONUNIX_GROUPS */

    return(FALSE);
}

/*
 * Returns TRUE if "host" and "user" belong to the netgroup "netgr",
 * else return FALSE.  Either of "host", "shost" or "user" may be NULL
 * in which case that argument is not checked...
 *
 * XXX - swap order of host & shost
 */
int
netgr_matches(netgr, lhost, shost, user)
    char *netgr;
    char *lhost;
    char *shost;
    char *user;
{
    static char *domain;
#ifdef HAVE_GETDOMAINNAME
    static int initialized;
#endif

    /* make sure we have a valid netgroup, sudo style */
    if (*netgr++ != '+')
	return(FALSE);

#ifdef HAVE_GETDOMAINNAME
    /* get the domain name (if any) */
    if (!initialized) {
	domain = (char *) emalloc(MAXHOSTNAMELEN + 1);
	if (getdomainname(domain, MAXHOSTNAMELEN + 1) == -1 || *domain == '\0') {
	    efree(domain);
	    domain = NULL;
	}
	initialized = 1;
    }
#endif /* HAVE_GETDOMAINNAME */

#ifdef HAVE_INNETGR
    if (innetgr(netgr, lhost, user, domain))
	return(TRUE);
    else if (lhost != shost && innetgr(netgr, shost, user, domain))
	return(TRUE);
#endif /* HAVE_INNETGR */

    return(FALSE);
}
@


1.9
log
@Add missing break between AF_INET and AF_INET6 in addr_matches_if_netmask()
Addresses CVE 2012-2337
@
text
@@


1.8
log
@Fix NULL dereference with "sudo -g group" when the sudoers rule has
no runas user or group listed.
@
text
@d633 1
a633 1
	switch(family) {
d651 1
d714 1
a714 1
	switch(family) {
d718 1
d727 1
@


1.7
log
@Don't attempt to dereference gl_pathv if the gl_pathc returned by glob(3) is
zero.

ok deraadt@@, millert@@
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2005, 2007-2009
d174 3
a176 1
    int rval, matched = UNSPEC;
d178 4
a181 10
    if (runas_gr != NULL) {
	if (tq_empty(group_list))
	    return(DENY); /* group was specified but none in sudoers */
	if (runas_pw != NULL && strcmp(runas_pw->pw_name, user_name) &&
	    tq_empty(user_list))
	    return(DENY); /* user was specified but none in sudoers */
    }

    if (tq_empty(user_list) && tq_empty(group_list))
	return(userpw_matches(def_runas_default, runas_pw->pw_name, runas_pw));
a182 1
    if (runas_pw != NULL) {
d186 1
a186 1
		    matched = !m->negated;
d190 1
a190 1
			matched = !m->negated;
d194 1
a194 1
			matched = !m->negated;
d200 1
a200 1
			    matched = m->negated ? !rval : rval;
d206 1
a206 1
			matched = !m->negated;
d209 1
a209 1
	    if (matched != UNSPEC)
d215 4
d222 1
a222 1
		    matched = !m->negated;
d228 1
a228 1
			    matched = m->negated ? !rval : rval;
d234 1
a234 1
			matched = !m->negated;
d237 1
a237 1
	    if (matched != UNSPEC)
d242 5
a246 1
    return(matched);
@


1.6
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d468 1
a468 1
    if (glob(sudoers_cmnd, GLOB_FLAGS, NULL, &gl) != 0) {
@


1.5
log
@Check for pseudo-command by looking at the first character of the
command in sudoers instead of checking the user-supplied command
for a slash.
@
text
@a95 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: match.c,v 1.48 2009/11/23 15:56:14 millert Exp $";
#endif /* lint */

@


1.4
log
@update to sudo 1.7.2p2
@
text
@d382 1
a382 1
    if (strchr(user_cmnd, '/') == NULL) {
@


1.3
log
@Upgrade to sudo 1.7.2
@
text
@d97 1
a97 1
__unused static const char rcsid[] = "$Sudo: match.c,v 1.46 2009/05/27 00:49:07 millert Exp $";
d321 1
a321 1
    int rval, matched = UNSPEC;
d324 2
a325 3
	rval = cmnd_matches(m);
	if (rval != UNSPEC) {
	    matched = m->negated ? !rval : rval;
a326 1
	}
d581 2
a582 1
    if (strlcpy(buf, sudoers_dir, sizeof(buf)) >= sizeof(buf))
d584 1
@


1.2
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2005, 2007-2008
d92 3
d97 1
a97 1
__unused static const char rcsid[] = "$Sudo: match.c,v 1.42 2009/03/28 13:07:16 millert Exp $";
d180 7
a186 3
    /* Deny if user specified a group but there is no group in sudoers */
    if (runas_gr != NULL && tq_empty(group_list))
	return(DENY);
a814 1
 *  XXX - reduce the number of group lookups
d822 1
a822 1
    struct group *grp;
d830 5
d837 1
a837 1
	return(FALSE);
d839 1
d841 1
a841 3
	return(FALSE);

    /* check against user's primary (passwd file) gid */
d854 3
a856 1
    if (grp->gr_mem != NULL) {
d861 7
@


1.1
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d94 1
a94 1
__unused static const char rcsid[] = "$Sudo: match.c,v 1.38 2008/11/02 14:35:37 millert Exp $";
d100 3
d136 1
a136 1
		if ((a = find_alias(m->name, USERALIAS)) != NULL) {
d199 1
a199 1
		    if ((a = find_alias(m->name, RUNASALIAS)) != NULL) {
d223 1
a223 1
		    if ((a = find_alias(m->name, RUNASALIAS)) != NULL) {
d279 1
a279 1
		if ((a = find_alias(m->name, HOSTALIAS)) != NULL) {
d352 1
a352 1
	    if ((a = find_alias(m->name, CMNDALIAS)) != NULL) {
a375 5
    struct stat sudoers_stat;
    char **ap, *base, *cp;
    glob_t gl;
    size_t dlen;

a396 1
    dlen = strlen(sudoers_cmnd);
a397 4
    /*
     * If sudoers_cmnd has meta characters in it, we may need to
     * use glob(3) and fnmatch(3) to do the matching.
     */
d400 2
a401 3
	 * First check to see if we can avoid the call to glob(3).
	 * Short circuit if there are no meta chars in the command itself
	 * and user_base and basename(sudoers_cmnd) don't match.
d403 54
a456 6
	if (sudoers_cmnd[dlen - 1] != '/') {
	    if ((base = strrchr(sudoers_cmnd, '/')) != NULL) {
		base++;
		if (!has_meta(base) && strcmp(user_base, base) != 0)
		    return(FALSE);
	    }
d458 8
a465 7
	/*
	 * Return true if we find a match in the glob(3) results AND
	 *  a) there are no args in sudoers OR
	 *  b) there are no args on command line and none required by sudoers OR
	 *  c) there are args in sudoers and on command line and they match
	 * else return false.
	 */
d467 1
a467 30
	if (glob(sudoers_cmnd, GLOB_FLAGS, NULL, &gl) != 0) {
	    globfree(&gl);
	    return(FALSE);
	}
	/* For each glob match, compare basename, st_dev and st_ino. */
	for (ap = gl.gl_pathv; (cp = *ap) != NULL; ap++) {
	    /* If it ends in '/' it is a directory spec. */
	    dlen = strlen(cp);
	    if (cp[dlen - 1] == '/') {
		if (command_matches_dir(cp, dlen))
		    return(TRUE);
		continue;
	    }

	    /* Only proceed if user_base and basename(cp) match */
	    if ((base = strrchr(cp, '/')) != NULL)
		base++;
	    else
		base = cp;
	    if (strcmp(user_base, base) != 0 ||
		stat(cp, &sudoers_stat) == -1)
		continue;
	    if (user_stat == NULL ||
		(user_stat->st_dev == sudoers_stat.st_dev &&
		user_stat->st_ino == sudoers_stat.st_ino)) {
		efree(safe_cmnd);
		safe_cmnd = estrdup(cp);
		break;
	    }
	}
a468 11
	if (cp == NULL)
	    return(FALSE);

	if (!sudoers_args ||
	    (!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args &&
	     fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(user_cmnd);
	    return(TRUE);
	}
d470 3
a472 1
    } else {
d474 6
a479 2
	if (sudoers_cmnd[dlen - 1] == '/')
	    return(command_matches_dir(sudoers_cmnd, dlen));
d481 3
a483 3
	/* Only proceed if user_base and basename(sudoers_cmnd) match */
	if ((base = strrchr(sudoers_cmnd, '/')) == NULL)
	    base = sudoers_cmnd;
d485 1
a485 1
	    base++;
d487 5
a491 17
	    stat(sudoers_cmnd, &sudoers_stat) == -1)
	    return(FALSE);

	/*
	 * Return true if inode/device matches AND
	 *  a) there are no args in sudoers OR
	 *  b) there are no args on command line and none req by sudoers OR
	 *  c) there are args in sudoers and on command line and they match
	 */
	if (user_stat != NULL &&
	    (user_stat->st_dev != sudoers_stat.st_dev ||
	    user_stat->st_ino != sudoers_stat.st_ino))
	    return(FALSE);
	if (!sudoers_args ||
	    (!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args &&
	     fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
d493 2
a494 2
	    safe_cmnd = estrdup(sudoers_cmnd);
	    return(TRUE);
d496 48
d545 7
d553 1
@

