head	1.5;
access;
symbols
	OPENBSD_5_7:1.4.0.18
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.22
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.20
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.16
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.14
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.12
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.10
	OPENBSD_5_0:1.4.0.8
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.6
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.1.0.16
	OPENBSD_3_6_BASE:1.1
	OPENBSD_3_5:1.1.0.14
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.12
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.10
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.8
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.6
	OPENBSD_3_1_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_3_0:1.1.0.2;
locks; strict;
comment	@# @;


1.5
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.4;
commitid	8ra5qnWqy2bUhcZn;

1.4
date	2009.12.07.18.43.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.29.17.40.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;

1.1.4.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove sudo, it is now in ports.
@
text
@#!/usr/bin/perl -w
#
# Generate sudo_defs_table and associated defines
#
# Input should be formatted thusly:
#
# var_name
#	TYPE
#	description (or NULL)
#	array of struct def_values if TYPE == T_TUPLE

# Deal with optional -o (output) argument
if ($#ARGV > 0 && $ARGV[0] eq "-o") {
    shift;
    $header = $cfile = shift;
    $header .= '.h';
    $cfile .= '.c';
}
die "usage: $0 [input_file]\n" unless $#ARGV == -1 || $#ARGV == 0;

$infile = $ARGV[0] || "def_data.in";
if (!defined($header)) {
    $header = $infile;
    $header =~ s/(\.in)?$/.h/;
}
if (!defined($cfile)) {
    $cfile = $infile;
    $cfile =~ s/(\.in)?$/.c/;
}

open(IN, "<$infile") || die "$0: can't open $infile: $!\n";
open(HEADER, ">$header") || die "$0: can't open $header: $!\n";
open(CFILE, ">$cfile") || die "$0: can't open $cfile: $!\n";

$count = 0;
@@tuple_values = ( "never" );
@@records = ();
while(<IN>) {
    chomp;
    s/\s*#.*$//;
    next if /^\s*$/;

    if (/^\S/) {
	# Store previous record and begin new one
	$records[$count++] = [$var, $type, $desc, $values, $callback] if defined($var);

	$var = $_;
	$type = '';
	$desc = undef;
	$values = undef;
	$callback = undef;
	$field = 0;
    } else {
	$field++;
	s/^\s+//;
	s/\s+$//;
	if ($field == 1) {
	    # type
	    $type = $_;
	} elsif ($field == 2) {
	    # description
	    if ($_ eq "NULL") {
		$desc = "NULL";
	    } else {
		# Strip leading and trailing double quote and escape the rest
		s/^"//;
		s/"$//;
		s/"/\\"/g;
		$desc = "\"$_\"";
	    }
	} elsif ($field == 3 || $field == 4) {
	    if (s/^\*//) {
		$callback = $_;
	    } else {
		die "$0: syntax error near line $.\n" if $type !~ /^T_TUPLE/;
		$values = [ split ];
		foreach $v (@@$values) {
		    push(@@tuple_values, $v) unless grep(/^$v$/, @@tuple_values);
		}
	    }
	} else {
	    die "$0: syntax error near line $.\n";
	}
    }
}
$records[$count++] = [$var, $type, $desc, $values, $callback] if defined($var);

# Print out value arrays
for ($i = 0; $i < $count; $i++) {
    if (defined($records[$i]->[3])) {
	die "Values list specified for non-tupple\n" unless
	    $records[$i]->[1] =~ /^T_TUPLE/;
	printf CFILE "static struct def_values def_data_%s[] = {\n", $records[$i]->[0];
	foreach (@@{$records[$i]->[3]}) {
	    print CFILE "    { \"$_\", $_ },\n";
	}
	print CFILE "    { NULL, 0 },\n";
	print CFILE "};\n\n";
    }
}

# Print each record
print CFILE "struct sudo_defs_types sudo_defs_table[] = {\n    {\n";
for ($i = 0; $i < $count; $i++) {
    &print_record($records[$i], $i);
}
print CFILE "\tNULL, 0, NULL\n    }\n};\n";

# Print out def_tuple
if (@@tuple_values) {
    print HEADER "\nenum def_tupple {\n";
    for ($i = 0; $i <= $#tuple_values; $i++) {
	printf HEADER "\t%s%s\n", $tuple_values[$i],
	    $i != $#tuple_values ? "," : "";
    }
    print HEADER "};\n";
}

close(IN);
close(HEADER);
close(CFILE);

sub print_record {
    my ($rec, $recnum) = @@_;
    my ($i, $v, $defname);
    # each variable gets a macro to access its value
    for ($rec->[1]) {
	if    (/^T_U?INT/)  { $v = "ival"; }
	elsif (/^T_STR/)    { $v = "str"; }
	elsif (/^T_FLAG/)   { $v = "flag"; }
	elsif (/^T_MODE/)   { $v = "mode"; }
	elsif (/^T_LIST/)   { $v = "list"; }
	elsif (/^T_LOGFAC/) { $v = "ival"; }
	elsif (/^T_LOGPRI/) { $v = "ival"; }
	elsif (/^T_TUPLE/)  { $v = "tuple"; }
	else { die "$0: unknown defaults type: $type\n"; }
    }
    printf HEADER "#define %-23s (sudo_defs_table[$recnum].sd_un.${v})\n",
	"def_$rec->[0]";

    $defname = "I_" . uc($rec->[0]);
    printf HEADER "#define %-24s%d", $defname, $recnum;
    #print HEADER "\t/* $rec->[2] */" if defined($rec->[2]);
    print HEADER "\n";

    print CFILE "\t\"$rec->[0]\", $rec->[1],\n\t$rec->[2],\n";
    if (defined($rec->[3])) {
	printf CFILE "\tdef_data_$rec->[0],\n";
    } else {
	printf CFILE "\tNULL,\n";
    }
    printf CFILE "\t$rec->[4],\n" if defined($rec->[4]);
    print CFILE "    }, {\n";
}
@


1.4
log
@update to sudo 1.7.2p2
@
text
@@


1.3
log
@The last item in an enum should not have a trailing comma
@
text
@d19 1
a19 1
die "usage: $0 input_file\n" unless $#ARGV == 0;
d21 1
a21 1
$infile = $ARGV[0];
@


1.2
log
@Update to sudo 1.6.8p1
@
text
@d112 3
a114 2
    foreach (@@tuple_values) {
	print HEADER "\t$_,\n";
@


1.1
log
@Update to sudo 1.6.4
@
text
@d10 1
d19 1
a19 1
die "usage: $0 input_file" unless $#ARGV == 0;
d35 3
a37 3
print CFILE "struct sudo_defs_types sudo_defs_table[] = {\n    {\n";

$count = -1;
d40 1
a41 1
    next if /^\s*#/;
d44 2
a45 2
	# Print last record
	&print_record() if defined($var);
d48 5
a52 2
	($type, $desc) = (undef, undef);
	$count++;
d54 1
d57 24
a80 9
	die "$0: syntax error near line $.\n" if
	    defined($type) && defined($desc);
	next if /^NULL$/;
	if (defined($type)) {
	    # Strip leading and trailing double quote and escape the rest
	    s/^"//;
	    s/"$//;
	    s/"/\\"/g;
	    $desc = "\"$_\"";
d82 14
a95 1
	    $type = $_;
d97 2
d101 6
a106 1
&print_record();
d109 9
d123 20
a142 3
    $defname = "I_" . uc($var);
    printf HEADER "#define %-24s%d", $defname, $count;
    #print HEADER "\t/* $desc */" if defined($desc);
d145 8
a152 2
    $desc = "NULL" unless defined($desc);
    print CFILE "\t\"$var\", $type,\n\t$desc\n    }, {\n";
@


1.1.4.1
log
@update to sudo 1.6.5p1
@
text
@@


1.1.2.1
log
@update to sudo 1.6.5p1
@
text
@@

