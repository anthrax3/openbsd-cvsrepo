head	1.16;
access;
symbols
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.15;
commitid	8ra5qnWqy2bUhcZn;

1.15
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.29.17.29.05;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.02.14.39.44;	author millert;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2001.02.04.20.57.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.21.17.58.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.27.03.44.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.24.04.22.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.7.2.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.7.4.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1999-2005, 2007-2008
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
# ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <ctype.h>

#include "sudo.h"
#include "parse.h"
#include <gram.h>

/*
 * For converting between syslog numbers and strings.
 */
struct strmap {
    char *name;
    int num;
};

#ifdef LOG_NFACILITIES
static struct strmap facilities[] = {
#ifdef LOG_AUTHPRIV
	{ "authpriv",	LOG_AUTHPRIV },
#endif
	{ "auth",	LOG_AUTH },
	{ "daemon",	LOG_DAEMON },
	{ "user",	LOG_USER },
	{ "local0",	LOG_LOCAL0 },
	{ "local1",	LOG_LOCAL1 },
	{ "local2",	LOG_LOCAL2 },
	{ "local3",	LOG_LOCAL3 },
	{ "local4",	LOG_LOCAL4 },
	{ "local5",	LOG_LOCAL5 },
	{ "local6",	LOG_LOCAL6 },
	{ "local7",	LOG_LOCAL7 },
	{ NULL,		-1 }
};
#endif /* LOG_NFACILITIES */

static struct strmap priorities[] = {
	{ "alert",	LOG_ALERT },
	{ "crit",	LOG_CRIT },
	{ "debug",	LOG_DEBUG },
	{ "emerg",	LOG_EMERG },
	{ "err",	LOG_ERR },
	{ "info",	LOG_INFO },
	{ "notice",	LOG_NOTICE },
	{ "warning",	LOG_WARNING },
	{ NULL,		-1 }
};

/*
 * Local prototypes.
 */
static int store_int __P((char *, struct sudo_defs_types *, int));
static int store_list __P((char *, struct sudo_defs_types *, int));
static int store_mode __P((char *, struct sudo_defs_types *, int));
static int store_str __P((char *, struct sudo_defs_types *, int));
static int store_syslogfac __P((char *, struct sudo_defs_types *, int));
static int store_syslogpri __P((char *, struct sudo_defs_types *, int));
static int store_tuple __P((char *, struct sudo_defs_types *, int));
static int store_uint __P((char *, struct sudo_defs_types *, int));
static void list_op __P((char *, size_t, struct sudo_defs_types *, enum list_ops));
static const char *logfac2str __P((int));
static const char *logpri2str __P((int));

/*
 * Table describing compile-time and run-time options.
 */
#include <def_data.c>

/*
 * Print version and configure info.
 */
void
dump_defaults()
{
    struct sudo_defs_types *cur;
    struct list_member *item;
    struct def_values *def;

    for (cur = sudo_defs_table; cur->name; cur++) {
	if (cur->desc) {
	    switch (cur->type & T_MASK) {
		case T_FLAG:
		    if (cur->sd_un.flag)
			puts(cur->desc);
		    break;
		case T_STR:
		    if (cur->sd_un.str) {
			(void) printf(cur->desc, cur->sd_un.str);
			putchar('\n');
		    }
		    break;
		case T_LOGFAC:
		    if (cur->sd_un.ival) {
			(void) printf(cur->desc, logfac2str(cur->sd_un.ival));
			putchar('\n');
		    }
		    break;
		case T_LOGPRI:
		    if (cur->sd_un.ival) {
			(void) printf(cur->desc, logpri2str(cur->sd_un.ival));
			putchar('\n');
		    }
		    break;
		case T_UINT:
		case T_INT:
		    (void) printf(cur->desc, cur->sd_un.ival);
		    putchar('\n');
		    break;
		case T_MODE:
		    (void) printf(cur->desc, cur->sd_un.mode);
		    putchar('\n');
		    break;
		case T_LIST:
		    if (cur->sd_un.list) {
			puts(cur->desc);
			for (item = cur->sd_un.list; item; item = item->next)
			    printf("\t%s\n", item->value);
		    }
		    break;
		case T_TUPLE:
		    for (def = cur->values; def->sval; def++) {
			if (cur->sd_un.ival == def->ival) {
			    (void) printf(cur->desc, def->sval);
			    break;
			}
		    }
		    putchar('\n');
		    break;
	    }
	}
    }
}

/*
 * List each option along with its description.
 */
void
list_options()
{
    struct sudo_defs_types *cur;
    char *p;

    (void) puts("Available options in a sudoers ``Defaults'' line:\n");
    for (cur = sudo_defs_table; cur->name; cur++) {
	if (cur->name && cur->desc) {
	    switch (cur->type & T_MASK) {
		case T_FLAG:
		    (void) printf("%s: %s\n", cur->name, cur->desc);
		    break;
		default:
		    p = strrchr(cur->desc, ':');
		    if (p)
			(void) printf("%s: %.*s\n", cur->name,
			    (int) (p - cur->desc), cur->desc);
		    else
			(void) printf("%s: %s\n", cur->name, cur->desc);
		    break;
	    }
	}
    }
}

/*
 * Sets/clears an entry in the defaults structure
 * If a variable that takes a value is used in a boolean
 * context with op == 0, disable that variable.
 * Eg. you may want to turn off logging to a file for some hosts.
 * This is only meaningful for variables that are *optional*.
 */
int
set_default(var, val, op)
    char *var;
    char *val;
    int op;     /* TRUE or FALSE */
{
    struct sudo_defs_types *cur;
    int num;

    for (cur = sudo_defs_table, num = 0; cur->name; cur++, num++) {
	if (strcmp(var, cur->name) == 0)
	    break;
    }
    if (!cur->name) {
	warningx("unknown defaults entry `%s'", var);
	return(FALSE);
    }

    switch (cur->type & T_MASK) {
	case T_LOGFAC:
	    if (!store_syslogfac(val, cur, op)) {
		if (val)
		    warningx("value `%s' is invalid for option `%s'", val, var);
		else
		    warningx("no value specified for `%s'", var);
		return(FALSE);
	    }
	    break;
	case T_LOGPRI:
	    if (!store_syslogpri(val, cur, op)) {
		if (val)
		    warningx("value `%s' is invalid for option `%s'", val, var);
		else
		    warningx("no value specified for `%s'", var);
		return(FALSE);
	    }
	    break;
	case T_STR:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warningx("no value specified for `%s'", var);
		    return(FALSE);
		}
	    }
	    if (ISSET(cur->type, T_PATH) && val && *val != '/') {
		warningx("values for `%s' must start with a '/'", var);
		return(FALSE);
	    }
	    if (!store_str(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
	case T_INT:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warningx("no value specified for `%s'", var);
		    return(FALSE);
		}
	    }
	    if (!store_int(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
	case T_UINT:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warningx("no value specified for `%s'", var);
		    return(FALSE);
		}
	    }
	    if (!store_uint(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
	case T_MODE:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warningx("no value specified for `%s'", var);
		    return(FALSE);
		}
	    }
	    if (!store_mode(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
	case T_FLAG:
	    if (val) {
		warningx("option `%s' does not take a value", var);
		return(FALSE);
	    }
	    cur->sd_un.flag = op;

	    /* Special action for I_FQDN.  Move to own switch if we get more */
	    if (num == I_FQDN && op)
		set_fqdn();
	    break;
	case T_LIST:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warningx("no value specified for `%s'", var);
		    return(FALSE);
		}
	    }
	    if (!store_list(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
	case T_TUPLE:
	    if (!val && !ISSET(cur->type, T_BOOL)) {
		warningx("no value specified for `%s'", var);
		return(FALSE);
	    }
	    if (!store_tuple(val, cur, op)) {
		warningx("value `%s' is invalid for option `%s'", val, var);
		return(FALSE);
	    }
	    break;
    }

    return(TRUE);
}

/*
 * Set default options to compiled-in values.
 * Any of these may be overridden at runtime by a "Defaults" file.
 */
void
init_defaults()
{
    static int firsttime = 1;
    struct sudo_defs_types *def;

    /* Clear any old settings. */
    if (!firsttime) {
	for (def = sudo_defs_table; def->name; def++) {
	    switch (def->type & T_MASK) {
		case T_STR:
		    efree(def->sd_un.str);
		    def->sd_un.str = NULL;
		    break;
		case T_LIST:
		    list_op(NULL, 0, def, freeall);
		    break;
	    }
	    zero_bytes(&def->sd_un, sizeof(def->sd_un));
	}
    }

    /* First initialize the flags. */
#ifdef LONG_OTP_PROMPT
    def_long_otp_prompt = TRUE;
#endif
#ifdef IGNORE_DOT_PATH
    def_ignore_dot = TRUE;
#endif
#ifdef ALWAYS_SEND_MAIL
    def_mail_always = TRUE;
#endif
#ifdef SEND_MAIL_WHEN_NO_USER
    def_mail_no_user = TRUE;
#endif
#ifdef SEND_MAIL_WHEN_NO_HOST
    def_mail_no_host = TRUE;
#endif
#ifdef SEND_MAIL_WHEN_NOT_OK
    def_mail_no_perms = TRUE;
#endif
#ifdef USE_TTY_TICKETS
    def_tty_tickets = TRUE;
#endif
#ifndef NO_LECTURE
    def_lecture = once;
#endif
#ifndef NO_AUTHENTICATION
    def_authenticate = TRUE;
#endif
#ifndef NO_ROOT_SUDO
    def_root_sudo = TRUE;
#endif
#ifdef HOST_IN_LOG
    def_log_host = TRUE;
#endif
#ifdef SHELL_IF_NO_ARGS
    def_shell_noargs = TRUE;
#endif
#ifdef SHELL_SETS_HOME
    def_set_home = TRUE;
#endif
#ifndef DONT_LEAK_PATH_INFO
    def_path_info = TRUE;
#endif
#ifdef FQDN
    def_fqdn = TRUE;
#endif
#ifdef USE_INSULTS
    def_insults = TRUE;
#endif
#ifdef ENV_EDITOR
    def_env_editor = TRUE;
#endif
#ifdef _PATH_SUDO_ASKPASS
    def_askpass = estrdup(_PATH_SUDO_ASKPASS);
#endif
    def_sudoers_locale = estrdup("C");
    def_env_reset = TRUE;
    def_set_logname = TRUE;
    def_closefrom = STDERR_FILENO + 1;

    /* Syslog options need special care since they both strings and ints */
#if (LOGGING & SLOG_SYSLOG)
    (void) store_syslogfac(LOGFAC, &sudo_defs_table[I_SYSLOG], TRUE);
    (void) store_syslogpri(PRI_SUCCESS, &sudo_defs_table[I_SYSLOG_GOODPRI],
	TRUE);
    (void) store_syslogpri(PRI_FAILURE, &sudo_defs_table[I_SYSLOG_BADPRI],
	TRUE);
#endif

    /* Password flags also have a string and integer component. */
    (void) store_tuple("any", &sudo_defs_table[I_LISTPW], TRUE);
    (void) store_tuple("all", &sudo_defs_table[I_VERIFYPW], TRUE);

    /* Then initialize the int-like things. */
#ifdef SUDO_UMASK
    def_umask = SUDO_UMASK;
#else
    def_umask = 0777;
#endif
    def_loglinelen = MAXLOGFILELEN;
    def_timestamp_timeout = TIMEOUT;
    def_passwd_timeout = PASSWORD_TIMEOUT;
    def_passwd_tries = TRIES_FOR_PASSWORD;

    /* Now do the strings */
    def_mailto = estrdup(MAILTO);
    def_mailsub = estrdup(MAILSUBJECT);
    def_badpass_message = estrdup(INCORRECT_PASSWORD);
    def_timestampdir = estrdup(_PATH_SUDO_TIMEDIR);
    def_passprompt = estrdup(PASSPROMPT);
    def_runas_default = estrdup(RUNAS_DEFAULT);
#ifdef _PATH_SUDO_SENDMAIL
    def_mailerpath = estrdup(_PATH_SUDO_SENDMAIL);
    def_mailerflags = estrdup("-t");
#endif
#if (LOGGING & SLOG_FILE)
    def_logfile = estrdup(_PATH_SUDO_LOGFILE);
#endif
#ifdef EXEMPTGROUP
    def_exempt_group = estrdup(EXEMPTGROUP);
#endif
#ifdef SECURE_PATH
    def_secure_path = estrdup(SECURE_PATH);
#endif
    def_editor = estrdup(EDITOR);
#ifdef _PATH_SUDO_NOEXEC
    def_noexec_file = estrdup(_PATH_SUDO_NOEXEC);
#endif

    /* Finally do the lists (currently just environment tables). */
    init_envtables();

    firsttime = 0;
}

/*
 * Update the defaults based on what was set by sudoers.
 * Pass in a an OR'd list of which default types to update.
 */
int
update_defaults(what)
    int what;
{
    struct defaults *def;

    tq_foreach_fwd(&defaults, def) {
	switch (def->type) {
	    case DEFAULTS:
		if (ISSET(what, SETDEF_GENERIC) &&
		    !set_default(def->var, def->val, def->op))
		    return(FALSE);
		break;
	    case DEFAULTS_USER:
		if (ISSET(what, SETDEF_USER) &&
		    userlist_matches(sudo_user.pw, &def->binding) == ALLOW &&
		    !set_default(def->var, def->val, def->op))
		    return(FALSE);
		break;
	    case DEFAULTS_RUNAS:
		if (ISSET(what, SETDEF_RUNAS) &&
		    runaslist_matches(&def->binding, NULL) == ALLOW &&
		    !set_default(def->var, def->val, def->op))
		    return(FALSE);
		break;
	    case DEFAULTS_HOST:
		if (ISSET(what, SETDEF_HOST) &&
		    hostlist_matches(&def->binding) == ALLOW &&
		    !set_default(def->var, def->val, def->op))
		    return(FALSE);
		break;
	    case DEFAULTS_CMND:
		if (ISSET(what, SETDEF_CMND) &&
		    cmndlist_matches(&def->binding) == ALLOW &&
		    !set_default(def->var, def->val, def->op))
		    return(FALSE);
		break;
	}
    }
    return(TRUE);
}

static int
store_int(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    char *endp;
    long l;

    if (op == FALSE) {
	def->sd_un.ival = 0;
    } else {
	l = strtol(val, &endp, 10);
	if (*endp != '\0')
	    return(FALSE);
	/* XXX - should check against INT_MAX */
	def->sd_un.ival = (unsigned int)l;
    }
    if (def->callback)
	return(def->callback(val));
    return(TRUE);
}

static int
store_uint(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    char *endp;
    long l;

    if (op == FALSE) {
	def->sd_un.ival = 0;
    } else {
	l = strtol(val, &endp, 10);
	if (*endp != '\0' || l < 0)
	    return(FALSE);
	/* XXX - should check against INT_MAX */
	def->sd_un.ival = (unsigned int)l;
    }
    if (def->callback)
	return(def->callback(val));
    return(TRUE);
}

static int
store_tuple(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    struct def_values *v;

    /*
     * Since enums are really just ints we store the value as an ival.
     * In the future, there may be multiple enums for different tuple
     * types we want to avoid and special knowledge of the tuple type.
     * This does assume that the first entry in the tuple enum will
     * be the equivalent to a boolean "false".
     */
    if (!val) {
	def->sd_un.ival = (op == FALSE) ? 0 : 1;
    } else {
	for (v = def->values; v->sval != NULL; v++) {
	    if (strcmp(v->sval, val) == 0) {
		def->sd_un.ival = v->ival;
		break;
	    }
	}
	if (v->sval == NULL)
	    return(FALSE);
    }
    if (def->callback)
	return(def->callback(val));
    return(TRUE);
}

static int
store_str(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{

    efree(def->sd_un.str);
    if (op == FALSE)
	def->sd_un.str = NULL;
    else
	def->sd_un.str = estrdup(val);
    if (def->callback)
	return(def->callback(val));
    return(TRUE);
}

static int
store_list(str, def, op)
    char *str;
    struct sudo_defs_types *def;
    int op;
{
    char *start, *end;

    /* Remove all old members. */
    if (op == FALSE || op == TRUE)
	list_op(NULL, 0, def, freeall);

    /* Split str into multiple space-separated words and act on each one. */
    if (op != FALSE) {
	end = str;
	do {
	    /* Remove leading blanks, if nothing but blanks we are done. */
	    for (start = end; isblank(*start); start++)
		;
	    if (*start == '\0')
		break;

	    /* Find end position and perform operation. */
	    for (end = start; *end && !isblank(*end); end++)
		;
	    list_op(start, end - start, def, op == '-' ? delete : add);
	} while (*end++ != '\0');
    }
    return(TRUE);
}

static int
store_syslogfac(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    struct strmap *fac;

    if (op == FALSE) {
	def->sd_un.ival = FALSE;
	return(TRUE);
    }
#ifdef LOG_NFACILITIES
    if (!val)
	return(FALSE);
    for (fac = facilities; fac->name && strcmp(val, fac->name); fac++)
	;
    if (fac->name == NULL)
	return(FALSE);				/* not found */

    def->sd_un.ival = fac->num;
#else
    def->sd_un.ival = -1;
#endif /* LOG_NFACILITIES */
    return(TRUE);
}

static const char *
logfac2str(n)
    int n;
{
#ifdef LOG_NFACILITIES
    struct strmap *fac;

    for (fac = facilities; fac->name && fac->num != n; fac++)
	;
    return(fac->name);
#else
    return("default");
#endif /* LOG_NFACILITIES */
}

static int
store_syslogpri(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    struct strmap *pri;

    if (op == FALSE || !val)
	return(FALSE);

    for (pri = priorities; pri->name && strcmp(val, pri->name); pri++)
	;
    if (pri->name == NULL)
	return(FALSE);				/* not found */

    def->sd_un.ival = pri->num;
    return(TRUE);
}

static const char *
logpri2str(n)
    int n;
{
    struct strmap *pri;

    for (pri = priorities; pri->name && pri->num != n; pri++)
	;
    return(pri->name);
}

static int
store_mode(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    char *endp;
    long l;

    if (op == FALSE) {
	def->sd_un.mode = (mode_t)0777;
    } else {
	l = strtol(val, &endp, 8);
	if (*endp != '\0' || l < 0 || l > 0777)
	    return(FALSE);
	def->sd_un.mode = (mode_t)l;
    }
    if (def->callback)
	return(def->callback(val));
    return(TRUE);
}

static void
list_op(val, len, def, op)
    char *val;
    size_t len;
    struct sudo_defs_types *def;
    enum list_ops op;
{
    struct list_member *cur, *prev, *tmp;

    if (op == freeall) {
	for (cur = def->sd_un.list; cur; ) {
	    tmp = cur;
	    cur = tmp->next;
	    efree(tmp->value);
	    efree(tmp);
	}
	def->sd_un.list = NULL;
	return;
    }

    for (cur = def->sd_un.list, prev = NULL; cur; prev = cur, cur = cur->next) {
	if ((strncmp(cur->value, val, len) == 0 && cur->value[len] == '\0')) {

	    if (op == add)
		return;			/* already exists */

	    /* Delete node */
	    if (prev != NULL)
		prev->next = cur->next;
	    else
		def->sd_un.list = cur->next;
	    efree(cur->value);
	    efree(cur);
	    break;
	}
    }

    /* Add new node to the head of the list. */
    if (op == add) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = emalloc(len + 1);
	(void) memcpy(cur->value, val, len);
	cur->value[len] = '\0';
	cur->next = def->sd_un.list;
	def->sd_un.list = cur;
    }
}
@


1.15
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@@


1.14
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@a51 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: defaults.c,v 1.73 2008/11/09 14:13:12 millert Exp $";
#endif /* lint */

@


1.13
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d2 2
a3 1
 * Copyright (c) 1999-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
a45 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d49 2
d53 1
a53 1
__unused static const char rcsid[] = "$Sudo: defaults.c,v 1.48.2.5 2007/06/18 15:51:35 millert Exp $";
a95 2
extern int sudolineno;

d231 1
a231 2
	warnx("unknown defaults entry `%s' referenced near line %d",
	    var, sudolineno);
d239 1
a239 1
		    warnx("value `%s' is invalid for option `%s'", val, var);
d241 1
a241 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d248 1
a248 1
		    warnx("value `%s' is invalid for option `%s'", val, var);
d250 1
a250 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d258 1
a258 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d263 1
a263 1
		warnx("values for `%s' must start with a '/'", var);
d267 1
a267 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d275 1
a275 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d280 1
a280 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d288 1
a288 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d293 1
a293 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d301 1
a301 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d306 1
a306 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d312 1
a312 2
		warnx("option `%s' does not take a value on line %d",
		    var, sudolineno);
d325 1
a325 2
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
d330 1
a330 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d336 1
a336 2
		warnx("no value specified for `%s' on line %d",
		    var, sudolineno);
d340 1
a340 1
		warnx("value `%s' is invalid for option `%s'", val, var);
d359 1
a359 1
    /* Free any strings that were set. */
d361 1
a361 1
	for (def = sudo_defs_table; def->name; def++)
d371 2
d427 4
d433 1
d476 3
d487 12
a498 7
    /*
     * The following depend on the above values.
     * We use a pointer to the string so that if its
     * value changes we get the change.
     */
    if (user_runas == NULL)
	user_runas = &def_runas_default;
d500 34
a533 1
    firsttime = 0;
d698 1
a698 1
    return (fac->name);
d700 1
a700 1
    return ("default");
d732 1
a732 1
    return (pri->name);
@


1.12
log
@update to sudo 1.6.8p5
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001, 2003-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d21 1
a21 1
#include "config.h"
d55 1
a55 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.48 2004/06/06 23:58:10 millert Exp $";
d378 2
a379 4
		    if (def->sd_un.str) {
			free(def->sd_un.str);
			def->sd_un.str = NULL;
		    }
d439 1
d587 1
a587 2
    if (def->sd_un.str)
	free(def->sd_un.str);
d736 2
a737 2
	    free(tmp->value);
	    free(tmp);
d754 2
a755 2
	    free(cur->value);
	    free(cur);
@


1.11
log
@Update to sudo 1.6.8p1
@
text
@d348 4
a351 7
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!ISSET(cur->type, T_BOOL) || op != FALSE) {
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
		    return(FALSE);
		}
d564 2
a565 2
    if (op == FALSE) {
	def->sd_un.ival = 0;
d567 1
a567 1
	for (v = def->values; v != NULL; v++) {
d573 1
a573 1
	if (v == NULL)
@


1.10
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d2 1
a2 2
 * Copyright (c) 1999-2001, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d44 1
d55 1
a55 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.40 2003/04/16 00:42:09 millert Exp $";
d104 2
a105 1
static int store_uint __P((char *, struct sudo_defs_types *, int));
d109 2
a110 3
static int store_mode __P((char *, struct sudo_defs_types *, int));
static int store_pwflag __P((char *, struct sudo_defs_types *, int));
static int store_list __P((char *, struct sudo_defs_types *, int));
d112 2
d128 1
d138 5
d144 5
d150 2
a151 3
		case T_PWFLAG:
		    if (cur->sd_un.str) {
			(void) printf(cur->desc, cur->sd_un.str);
d171 9
a260 10
	case T_PWFLAG:
	    if (!store_pwflag(val, cur, op)) {
		if (val)
		    warnx("value `%s' is invalid for option `%s'", val, var);
		else
		    warnx("no value specified for `%s' on line %d",
			var, sudolineno);
		return(FALSE);
	    }
	    break;
d264 1
a264 1
		if (!(cur->type & T_BOOL) || op != FALSE) {
d270 1
a270 1
	    if ((cur->type & T_PATH) && val && *val != '/') {
d282 1
a282 1
		if (!(cur->type & T_BOOL) || op != FALSE) {
d296 1
a296 1
		if (!(cur->type & T_BOOL) || op != FALSE) {
d310 1
a310 1
		if (!(cur->type & T_BOOL) || op != FALSE) {
d336 1
a336 1
		if (!(cur->type & T_BOOL) || op != FALSE) {
d346 15
a380 3
		case T_LOGFAC:
		case T_LOGPRI:
		case T_PWFLAG:
d394 1
a394 1
    def_flag(I_LONG_OTP_PROMPT) = TRUE;
d397 1
a397 1
    def_flag(I_IGNORE_DOT) = TRUE;
d400 1
a400 1
    def_flag(I_MAIL_ALWAYS) = TRUE;
d403 1
a403 1
    def_flag(I_MAIL_NO_USER) = TRUE;
d406 1
a406 1
    def_flag(I_MAIL_NO_HOST) = TRUE;
d409 1
a409 1
    def_flag(I_MAIL_NO_PERMS) = TRUE;
d412 1
a412 1
    def_flag(I_TTY_TICKETS) = TRUE;
d415 1
a415 1
    def_flag(I_LECTURE) = TRUE;
d418 1
a418 1
    def_flag(I_AUTHENTICATE) = TRUE;
d421 1
a421 1
    def_flag(I_ROOT_SUDO) = TRUE;
d424 1
a424 1
    def_flag(I_LOG_HOST) = TRUE;
d427 1
a427 1
    def_flag(I_SHELL_NOARGS) = TRUE;
d430 1
a430 1
    def_flag(I_SET_HOME) = TRUE;
d433 1
a433 1
    def_flag(I_PATH_INFO) = TRUE;
d436 1
a436 1
    def_flag(I_FQDN) = TRUE;
d439 1
a439 1
    def_flag(I_INSULTS) = TRUE;
d442 1
a442 1
    def_flag(I_ENV_EDITOR) = TRUE;
d444 1
a444 1
    def_flag(I_SET_LOGNAME) = TRUE;
d456 2
a457 2
    (void) store_pwflag("any", &sudo_defs_table[I_LISTPW], TRUE);
    (void) store_pwflag("all", &sudo_defs_table[I_VERIFYPW], TRUE);
d461 1
a461 1
    def_mode(I_UMASK) = SUDO_UMASK;
d463 1
a463 1
    def_mode(I_UMASK) = 0777;
d465 4
a468 4
    def_ival(I_LOGLINELEN) = MAXLOGFILELEN;
    def_ival(I_TIMESTAMP_TIMEOUT) = TIMEOUT;
    def_ival(I_PASSWD_TIMEOUT) = PASSWORD_TIMEOUT;
    def_ival(I_PASSWD_TRIES) = TRIES_FOR_PASSWORD;
d471 6
a476 6
    def_str(I_MAILTO) = estrdup(MAILTO);
    def_str(I_MAILSUB) = estrdup(MAILSUBJECT);
    def_str(I_BADPASS_MESSAGE) = estrdup(INCORRECT_PASSWORD);
    def_str(I_TIMESTAMPDIR) = estrdup(_PATH_SUDO_TIMEDIR);
    def_str(I_PASSPROMPT) = estrdup(PASSPROMPT);
    def_str(I_RUNAS_DEFAULT) = estrdup(RUNAS_DEFAULT);
d478 2
a479 2
    def_str(I_MAILERPATH) = estrdup(_PATH_SUDO_SENDMAIL);
    def_str(I_MAILERFLAGS) = estrdup("-t");
d482 1
a482 1
    def_str(I_LOGFILE) = estrdup(_PATH_SUDO_LOGFILE);
d485 5
a489 1
    def_str(I_EXEMPT_GROUP) = estrdup(EXEMPTGROUP);
a490 1
    def_str(I_EDITOR) = estrdup(EDITOR);
d501 1
a501 1
	user_runas = &def_str(I_RUNAS_DEFAULT);
d524 2
d547 34
d597 2
d625 1
a625 1
	    for (end = start; *end && !isblank(*end); end++) 
d642 1
a642 4
	if (def->sd_un.str) {
	    free(def->sd_un.str);
	    def->sd_un.str = NULL;
	}
d653 1
a653 5
    /* Store both name and number. */
    if (def->sd_un.str)
	free(def->sd_un.str);
    def->sd_un.str = estrdup(fac->name);
    sudo_defs_table[I_LOGFAC].sd_un.ival = fac->num;
d655 1
a655 3
    if (def->sd_un.str)
	free(def->sd_un.str);
    def->sd_un.str = estrdup("default");
d660 15
a681 1
    struct sudo_defs_types *idef;
a684 6
    if (def == &sudo_defs_table[I_SYSLOG_GOODPRI])
	idef = &sudo_defs_table[I_GOODPRI];
    else if (def == &sudo_defs_table[I_SYSLOG_BADPRI])
	idef = &sudo_defs_table[I_BADPRI];
    else
	return(FALSE);
d691 1
a691 5
    /* Store both name and number. */
    if (def->sd_un.str)
	free(def->sd_un.str);
    def->sd_un.str = estrdup(pri->name);
    idef->sd_un.ival = pri->num;
d695 11
d723 2
a724 47
    return(TRUE);
}

static int
store_pwflag(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    int isub, flags;

    if (strcmp(def->name, "verifypw") == 0)
	isub = I_VERIFYPW_I;
    else
	isub = I_LISTPW_I;

    /* Handle !foo. */
    if (op == FALSE) {
	if (def->sd_un.str) {
	    free(def->sd_un.str);
	    def->sd_un.str = NULL;
	}
	def->sd_un.str = estrdup("never");
	sudo_defs_table[isub].sd_un.ival = PWCHECK_NEVER;
	return(TRUE);
    }
    if (!val)
	return(FALSE);

    /* Convert strings to integer values. */
    if (strcmp(val, "all") == 0)
	flags = PWCHECK_ALL;
    else if (strcmp(val, "any") == 0)
	flags = PWCHECK_ANY;
    else if (strcmp(val, "never") == 0)
	flags = PWCHECK_NEVER;
    else if (strcmp(val, "always") == 0)
	flags = PWCHECK_ALWAYS;
    else
	return(FALSE);

    /* Store both name and number. */
    if (def->sd_un.str)
	free(def->sd_un.str);
    def->sd_un.str = estrdup(val);
    sudo_defs_table[isub].sd_un.ival = flags;

@


1.9
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d33 4
d72 1
a72 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.39 2003/04/02 18:25:19 millert Exp $";
@


1.8
log
@Update to sudo 1.6.4
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d58 5
d68 1
a68 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.38 2001/12/30 18:40:09 millert Exp $";
d227 1
a227 2
	(void) fprintf(stderr,
	    "%s: unknown defaults entry `%s' referenced near line %d\n", Argv[0],
d236 1
a236 3
		    (void) fprintf(stderr,
			"%s: value '%s' is invalid for option '%s'\n", Argv[0],
			val, var);
d238 1
a238 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d246 1
a246 3
		    (void) fprintf(stderr,
			"%s: value '%s' is invalid for option '%s'\n", Argv[0],
			val, var);
d248 1
a248 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d256 1
a256 3
		    (void) fprintf(stderr,
			"%s: value '%s' is invalid for option '%s'\n", Argv[0],
			val, var);
d258 1
a258 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d267 1
a267 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d273 1
a273 3
		(void) fprintf(stderr,
		    "%s: values for `%s' must start with a '/'\n", Argv[0],
		    var);
d277 1
a277 3
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
d285 1
a285 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d291 1
a291 3
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
d299 1
a299 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d305 1
a305 3
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
d313 1
a313 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d319 1
a319 3
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
d325 2
a326 3
		(void) fprintf(stderr,
		    "%s: option `%s' does not take a value on line %d\n",
		    Argv[0], var, sudolineno);
d339 1
a339 2
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
d345 1
a345 3
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
@


1.7
log
@Update to sudo 1.6.3p7
Fixes negation of path-type Defaults entries in a boolean context.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 2
d41 6
a46 1
#include <stdlib.h>
d48 8
a55 1
#ifdef HAVE_UNISTD_H
d58 1
a58 8
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <sys/types.h>
#include <sys/param.h>
d63 1
a63 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.23 2000/03/22 23:40:09 millert Exp $";
d112 1
d118 2
d124 1
a124 153
struct sudo_defs_types sudo_defs_table[] = {
    {
	"syslog_ifac", T_INT, NULL
    }, {
	"syslog_igoodpri", T_INT, NULL
    }, {
	"syslog_ibadpri", T_INT, NULL
    }, {
	"syslog", T_LOGFAC|T_BOOL,
	"Syslog facility if syslog is being used for logging: %s"
    }, {
	"syslog_goodpri", T_LOGPRI,
	"Syslog priority to use when user authenticates successfully: %s"
    }, {
	"syslog_badpri", T_LOGPRI,
	"Syslog priority to use when user authenticates unsuccessfully: %s"
    }, {
	"long_otp_prompt", T_FLAG,
	"Put OTP prompt on its own line"
    }, {
	"ignore_dot", T_FLAG,
	"Ignore '.' in $PATH"
    }, {
	"mail_always", T_FLAG,
	"Always send mail when sudo is run"
    }, {
	"mail_no_user", T_FLAG,
	"Send mail if the user is not in sudoers"
    }, {
	"mail_no_host", T_FLAG,
	"Send mail if the user is not in sudoers for this host"
    }, {
	"mail_no_perms", T_FLAG,
	"Send mail if the user is not allowed to run a command"
    }, {
	"tty_tickets", T_FLAG,
	"Use a separate timestamp for each user/tty combo"
    }, {
	"lecture", T_FLAG,
	"Lecture user the first time they run sudo"
    }, {
	"authenticate", T_FLAG,
	"Require users to authenticate by default"
    }, {
	"root_sudo", T_FLAG,
	"Root may run sudo"
    }, {
	"log_host", T_FLAG,
	"Log the hostname in the (non-syslog) log file"
    }, {
	"log_year", T_FLAG,
	"Log the year in the (non-syslog) log file"
    }, {
	"shell_noargs", T_FLAG,
	"If sudo is invoked with no arguments, start a shell"
    }, {
	"set_home", T_FLAG,
	"Set $HOME to the target user when starting a shell with -s"
    }, {
	"path_info", T_FLAG,
	"Allow some information gathering to give useful error messages"
    }, {
	"fqdn", T_FLAG,
	"Require fully-qualified hsotnames in the sudoers file"
    }, {
	"insults", T_FLAG,
	"Insult the user when they enter an incorrect password"
    }, {
	"requiretty", T_FLAG,
	"Only allow the user to run sudo if they have a tty"
    }, {
	"env_editor", T_FLAG,
	"Visudo will honor the EDITOR environment variable"
    }, {
	"rootpw", T_FLAG,
	"Prompt for root's password, not the users's"
    }, {
	"runaspw", T_FLAG,
	"Prompt for the runas_default user's password, not the users's"
    }, {
	"targetpw", T_FLAG,
	"Prompt for the target user's password, not the users's"
    }, {
	"use_loginclass", T_FLAG,
	"Apply defaults in the target user's login class if there is one"
    }, {
	"set_logname", T_FLAG,
	"Set the LOGNAME and USER environment variables"
    }, {
	"loglinelen", T_INT|T_BOOL,
	"Length at which to wrap log file lines (0 for no wrap): %d"
    }, {
	"timestamp_timeout", T_INT|T_BOOL,
	"Authentication timestamp timeout: %d minutes"
    }, {
	"passwd_timeout", T_INT|T_BOOL,
	"Password prompt timeout: %d minutes"
    }, {
	"passwd_tries", T_INT,
	"Number of tries to enter a password: %d"
    }, {
	"umask", T_MODE|T_BOOL,
	"Umask to use or 0777 to use user's: 0%o"
    }, {
	"logfile", T_STR|T_BOOL|T_PATH,
	"Path to log file: %s"
    }, {
	"mailerpath", T_STR|T_BOOL|T_PATH,
	"Path to mail program: %s"
    }, {
	"mailerflags", T_STR|T_BOOL,
	"Flags for mail program: %s"
    }, {
	"mailto", T_STR|T_BOOL,
	"Address to send mail to: %s"
    }, {
	"mailsub", T_STR,
	"Subject line for mail messages: %s"
    }, {
	"badpass_message", T_STR,
	"Incorrect password message: %s"
    }, {
	"timestampdir", T_STR|T_PATH,
	"Path to authentication timestamp dir: %s"
    }, {
	"exempt_group", T_STR|T_BOOL,
	"Users in this group are exempt from password and PATH requirements: %s"
    }, {
	"passprompt", T_STR,
	"Default password prompt: %s"
    }, {
	"runas_default", T_STR,
	"Default user to run commands as: %s"
    }, {
	"secure_path", T_STR|T_BOOL,
	"Value to override user's $PATH with: %s"
    }, {
	"editor", T_STR|T_PATH,
	"Path to the editor for use by visudo: %s"
    }, {
	"listpw_i", T_INT, NULL
    }, {
	"verifypw_i", T_INT, NULL
    }, {
	"listpw", T_PWFLAG,
	"When to require a password for 'list' pseudocommand: %s"
    }, {
	"verifypw", T_PWFLAG,
	"When to require a password for 'verify' pseudocommand: %s"
    }, {
	NULL, 0, NULL
    }
};
d133 1
d151 1
d160 7
d191 2
a192 2
			(void) printf("%s: %.*s\n", cur->name, (int)(p - cur->desc),
			    cur->desc);
d308 17
d355 16
d399 3
d416 1
a416 1
    def_flag(I_MAIL_NOUSER) = TRUE;
d419 1
a419 1
    def_flag(I_MAIL_NOHOST) = TRUE;
d422 1
a422 1
    def_flag(I_MAIL_NOPERMS) = TRUE;
d457 1
a457 1
    def_flag(I_LOGNAME) = TRUE;
d461 5
a465 3
    (void) store_syslogfac(LOGFAC, &sudo_defs_table[I_LOGFACSTR], TRUE);
    (void) store_syslogpri(PRI_SUCCESS, &sudo_defs_table[I_GOODPRISTR], TRUE);
    (void) store_syslogpri(PRI_FAILURE, &sudo_defs_table[I_BADPRISTR], TRUE);
d469 2
a470 2
    (void) store_pwflag("any", &sudo_defs_table[I_LISTPWSTR], TRUE);
    (void) store_pwflag("all", &sudo_defs_table[I_VERIFYPWSTR], TRUE);
d478 4
a481 4
    def_ival(I_LOGLEN) = MAXLOGFILELEN;
    def_ival(I_TS_TIMEOUT) = TIMEOUT;
    def_ival(I_PW_TIMEOUT) = PASSWORD_TIMEOUT;
    def_ival(I_PW_TRIES) = TRIES_FOR_PASSWORD;
d483 1
a483 1
    /* Finally do the strings */
d486 1
a486 1
    def_str(I_BADPASS_MSG) = estrdup(INCORRECT_PASSWORD);
d489 3
a491 3
    def_str(I_RUNAS_DEF) = estrdup(RUNAS_DEFAULT);
#ifdef _PATH_SENDMAIL
    def_str(I_MAILERPATH) = estrdup(_PATH_SENDMAIL);
d498 1
a498 4
    def_str(I_EXEMPT_GRP) = estrdup(EXEMPTGROUP);
#endif
#ifdef SECURE_PATH
    def_str(I_SECURE_PATH) = estrdup(SECURE_PATH);
d502 3
d511 1
a511 1
	user_runas = &def_str(I_RUNAS_DEF);
d529 21
d575 31
d629 1
a629 1
    if (def->sd_un.str) {
a630 3
	closelog();
    }
    openlog(Argv[0], 0, fac->num);
d634 1
a634 1
    if (def->sd_un.str) {
a635 3
	closelog();
    }
    openlog(Argv[0], 0);
d652 1
a652 1
    if (def == &sudo_defs_table[I_GOODPRISTR])
d654 1
a654 1
    else if (def == &sudo_defs_table[I_BADPRISTR])
d701 1
a701 1
	isub = I_VERIFYPW;
d703 1
a703 1
	isub = I_LISTPW;
d737 48
@


1.7.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 4
# ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <ctype.h>
d56 1
a56 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.38 2001/12/30 18:40:09 millert Exp $";
a104 1
static int store_uint __P((char *, struct sudo_defs_types *, int));
a109 2
static int store_list __P((char *, struct sudo_defs_types *, int));
static void list_op __P((char *, size_t, struct sudo_defs_types *, enum list_ops));
d114 153
a266 1
#include <def_data.c>
a274 1
    struct list_member *item;
a291 1
		case T_UINT:
a299 7
		case T_LIST:
		    if (cur->sd_un.list) {
			puts(cur->desc);
			for (item = cur->sd_un.list; item; item = item->next)
			    printf("\t%s\n", item->value);
		    }
		    break;
d324 2
a325 2
			(void) printf("%s: %.*s\n", cur->name,
			    (int) (p - cur->desc), cur->desc);
a440 17
	case T_UINT:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!(cur->type & T_BOOL) || op != FALSE) {
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
			var, sudolineno);
		    return(FALSE);
		}
	    }
	    if (!store_uint(val, cur, op)) {
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
		return(FALSE);
	    }
	    break;
a470 16
	case T_LIST:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!(cur->type & T_BOOL) || op != FALSE) {
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
			var, sudolineno);
		    return(FALSE);
		}
	    }
	    if (!store_list(val, cur, op)) {
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
		return(FALSE);
	    }
a498 3
		case T_LIST:
		    list_op(NULL, 0, def, freeall);
		    break;
d513 1
a513 1
    def_flag(I_MAIL_NO_USER) = TRUE;
d516 1
a516 1
    def_flag(I_MAIL_NO_HOST) = TRUE;
d519 1
a519 1
    def_flag(I_MAIL_NO_PERMS) = TRUE;
d554 1
a554 1
    def_flag(I_SET_LOGNAME) = TRUE;
d558 3
a560 5
    (void) store_syslogfac(LOGFAC, &sudo_defs_table[I_SYSLOG], TRUE);
    (void) store_syslogpri(PRI_SUCCESS, &sudo_defs_table[I_SYSLOG_GOODPRI],
	TRUE);
    (void) store_syslogpri(PRI_FAILURE, &sudo_defs_table[I_SYSLOG_BADPRI],
	TRUE);
d564 2
a565 2
    (void) store_pwflag("any", &sudo_defs_table[I_LISTPW], TRUE);
    (void) store_pwflag("all", &sudo_defs_table[I_VERIFYPW], TRUE);
d573 4
a576 4
    def_ival(I_LOGLINELEN) = MAXLOGFILELEN;
    def_ival(I_TIMESTAMP_TIMEOUT) = TIMEOUT;
    def_ival(I_PASSWD_TIMEOUT) = PASSWORD_TIMEOUT;
    def_ival(I_PASSWD_TRIES) = TRIES_FOR_PASSWORD;
d578 1
a578 1
    /* Now do the strings */
d581 1
a581 1
    def_str(I_BADPASS_MESSAGE) = estrdup(INCORRECT_PASSWORD);
d584 3
a586 3
    def_str(I_RUNAS_DEFAULT) = estrdup(RUNAS_DEFAULT);
#ifdef _PATH_SUDO_SENDMAIL
    def_str(I_MAILERPATH) = estrdup(_PATH_SUDO_SENDMAIL);
d593 4
a596 1
    def_str(I_EXEMPT_GROUP) = estrdup(EXEMPTGROUP);
a599 3
    /* Finally do the lists (currently just environment tables). */
    init_envtables();

d606 1
a606 1
	user_runas = &def_str(I_RUNAS_DEFAULT);
a623 21
	if (*endp != '\0')
	    return(FALSE);
	/* XXX - should check against INT_MAX */
	def->sd_un.ival = (unsigned int)l;
    }
    return(TRUE);
}

static int
store_uint(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    char *endp;
    long l;

    if (op == FALSE) {
	def->sd_un.ival = 0;
    } else {
	l = strtol(val, &endp, 10);
a648 31
store_list(str, def, op)
    char *str;
    struct sudo_defs_types *def;
    int op;
{
    char *start, *end;

    /* Remove all old members. */
    if (op == FALSE || op == TRUE)
	list_op(NULL, 0, def, freeall);

    /* Split str into multiple space-separated words and act on each one. */
    if (op != FALSE) {
	end = str;
	do {
	    /* Remove leading blanks, if nothing but blanks we are done. */
	    for (start = end; isblank(*start); start++)
		;
	    if (*start == '\0')
		break;

	    /* Find end position and perform operation. */
	    for (end = start; *end && !isblank(*end); end++) 
		;
	    list_op(start, end - start, def, op == '-' ? delete : add);
	} while (*end++ != '\0');
    }
    return(TRUE);
}

static int
d672 1
a672 1
    if (def->sd_un.str)
d674 3
d680 1
a680 1
    if (def->sd_un.str)
d682 3
d701 1
a701 1
    if (def == &sudo_defs_table[I_SYSLOG_GOODPRI])
d703 1
a703 1
    else if (def == &sudo_defs_table[I_SYSLOG_BADPRI])
d750 1
a750 1
	isub = I_VERIFYPW_I;
d752 1
a752 1
	isub = I_LISTPW_I;
a785 48
}

static void
list_op(val, len, def, op)
    char *val;
    size_t len;
    struct sudo_defs_types *def;
    enum list_ops op;
{
    struct list_member *cur, *prev, *tmp;

    if (op == freeall) {
	for (cur = def->sd_un.list; cur; ) {
	    tmp = cur;
	    cur = tmp->next;
	    free(tmp->value);
	    free(tmp);
	}
	def->sd_un.list = NULL;
	return;
    }

    for (cur = def->sd_un.list, prev = NULL; cur; prev = cur, cur = cur->next) {
	if ((strncmp(cur->value, val, len) == 0 && cur->value[len] == '\0')) {

	    if (op == add)
		return;			/* already exists */

	    /* Delete node */
	    if (prev != NULL)
		prev->next = cur->next;
	    else
		def->sd_un.list = cur->next;
	    free(cur->value);
	    free(cur);
	    break;
	}
    }

    /* Add new node to the head of the list. */
    if (op == add) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = emalloc(len + 1);
	(void) memcpy(cur->value, val, len);
	cur->value[len] = '\0';
	cur->next = def->sd_un.list;
	def->sd_un.list = cur;
    }
@


1.7.4.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 4
# ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <ctype.h>
d56 1
a56 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.38 2001/12/30 18:40:09 millert Exp $";
a104 1
static int store_uint __P((char *, struct sudo_defs_types *, int));
a109 2
static int store_list __P((char *, struct sudo_defs_types *, int));
static void list_op __P((char *, size_t, struct sudo_defs_types *, enum list_ops));
d114 153
a266 1
#include <def_data.c>
a274 1
    struct list_member *item;
a291 1
		case T_UINT:
a299 7
		case T_LIST:
		    if (cur->sd_un.list) {
			puts(cur->desc);
			for (item = cur->sd_un.list; item; item = item->next)
			    printf("\t%s\n", item->value);
		    }
		    break;
d324 2
a325 2
			(void) printf("%s: %.*s\n", cur->name,
			    (int) (p - cur->desc), cur->desc);
a440 17
	case T_UINT:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!(cur->type & T_BOOL) || op != FALSE) {
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
			var, sudolineno);
		    return(FALSE);
		}
	    }
	    if (!store_uint(val, cur, op)) {
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
		return(FALSE);
	    }
	    break;
a470 16
	case T_LIST:
	    if (!val) {
		/* Check for bogus boolean usage or lack of a value. */
		if (!(cur->type & T_BOOL) || op != FALSE) {
		    (void) fprintf(stderr,
			"%s: no value specified for `%s' on line %d\n", Argv[0],
			var, sudolineno);
		    return(FALSE);
		}
	    }
	    if (!store_list(val, cur, op)) {
		(void) fprintf(stderr,
		    "%s: value '%s' is invalid for option '%s'\n", Argv[0],
		    val, var);
		return(FALSE);
	    }
a498 3
		case T_LIST:
		    list_op(NULL, 0, def, freeall);
		    break;
d513 1
a513 1
    def_flag(I_MAIL_NO_USER) = TRUE;
d516 1
a516 1
    def_flag(I_MAIL_NO_HOST) = TRUE;
d519 1
a519 1
    def_flag(I_MAIL_NO_PERMS) = TRUE;
d554 1
a554 1
    def_flag(I_SET_LOGNAME) = TRUE;
d558 3
a560 5
    (void) store_syslogfac(LOGFAC, &sudo_defs_table[I_SYSLOG], TRUE);
    (void) store_syslogpri(PRI_SUCCESS, &sudo_defs_table[I_SYSLOG_GOODPRI],
	TRUE);
    (void) store_syslogpri(PRI_FAILURE, &sudo_defs_table[I_SYSLOG_BADPRI],
	TRUE);
d564 2
a565 2
    (void) store_pwflag("any", &sudo_defs_table[I_LISTPW], TRUE);
    (void) store_pwflag("all", &sudo_defs_table[I_VERIFYPW], TRUE);
d573 4
a576 4
    def_ival(I_LOGLINELEN) = MAXLOGFILELEN;
    def_ival(I_TIMESTAMP_TIMEOUT) = TIMEOUT;
    def_ival(I_PASSWD_TIMEOUT) = PASSWORD_TIMEOUT;
    def_ival(I_PASSWD_TRIES) = TRIES_FOR_PASSWORD;
d578 1
a578 1
    /* Now do the strings */
d581 1
a581 1
    def_str(I_BADPASS_MESSAGE) = estrdup(INCORRECT_PASSWORD);
d584 3
a586 3
    def_str(I_RUNAS_DEFAULT) = estrdup(RUNAS_DEFAULT);
#ifdef _PATH_SUDO_SENDMAIL
    def_str(I_MAILERPATH) = estrdup(_PATH_SUDO_SENDMAIL);
d593 4
a596 1
    def_str(I_EXEMPT_GROUP) = estrdup(EXEMPTGROUP);
a599 3
    /* Finally do the lists (currently just environment tables). */
    init_envtables();

d606 1
a606 1
	user_runas = &def_str(I_RUNAS_DEFAULT);
a623 21
	if (*endp != '\0')
	    return(FALSE);
	/* XXX - should check against INT_MAX */
	def->sd_un.ival = (unsigned int)l;
    }
    return(TRUE);
}

static int
store_uint(val, def, op)
    char *val;
    struct sudo_defs_types *def;
    int op;
{
    char *endp;
    long l;

    if (op == FALSE) {
	def->sd_un.ival = 0;
    } else {
	l = strtol(val, &endp, 10);
a648 31
store_list(str, def, op)
    char *str;
    struct sudo_defs_types *def;
    int op;
{
    char *start, *end;

    /* Remove all old members. */
    if (op == FALSE || op == TRUE)
	list_op(NULL, 0, def, freeall);

    /* Split str into multiple space-separated words and act on each one. */
    if (op != FALSE) {
	end = str;
	do {
	    /* Remove leading blanks, if nothing but blanks we are done. */
	    for (start = end; isblank(*start); start++)
		;
	    if (*start == '\0')
		break;

	    /* Find end position and perform operation. */
	    for (end = start; *end && !isblank(*end); end++) 
		;
	    list_op(start, end - start, def, op == '-' ? delete : add);
	} while (*end++ != '\0');
    }
    return(TRUE);
}

static int
d672 1
a672 1
    if (def->sd_un.str)
d674 3
d680 1
a680 1
    if (def->sd_un.str)
d682 3
d701 1
a701 1
    if (def == &sudo_defs_table[I_SYSLOG_GOODPRI])
d703 1
a703 1
    else if (def == &sudo_defs_table[I_SYSLOG_BADPRI])
d750 1
a750 1
	isub = I_VERIFYPW_I;
d752 1
a752 1
	isub = I_LISTPW_I;
a785 48
}

static void
list_op(val, len, def, op)
    char *val;
    size_t len;
    struct sudo_defs_types *def;
    enum list_ops op;
{
    struct list_member *cur, *prev, *tmp;

    if (op == freeall) {
	for (cur = def->sd_un.list; cur; ) {
	    tmp = cur;
	    cur = tmp->next;
	    free(tmp->value);
	    free(tmp);
	}
	def->sd_un.list = NULL;
	return;
    }

    for (cur = def->sd_un.list, prev = NULL; cur; prev = cur, cur = cur->next) {
	if ((strncmp(cur->value, val, len) == 0 && cur->value[len] == '\0')) {

	    if (op == add)
		return;			/* already exists */

	    /* Delete node */
	    if (prev != NULL)
		prev->next = cur->next;
	    else
		def->sd_un.list = cur->next;
	    free(cur->value);
	    free(cur);
	    break;
	}
    }

    /* Add new node to the head of the list. */
    if (op == add) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = emalloc(len + 1);
	(void) memcpy(cur->value, val, len);
	cur->value[len] = '\0';
	cur->next = def->sd_un.list;
	def->sd_un.list = cur;
    }
@


1.6
log
@please the alpha
@
text
@d411 1
a411 1
	    if ((cur->type & T_PATH) && *val != '/') {
@


1.5
log
@A few updates from the sudo developement tree:
- Add bsd authentication support (currently disabled)
- Always check setenv() return value
- Fix umask disabling
@
text
@d324 1
a324 1
			(void) printf("%s: %.*s\n", cur->name, p - cur->desc,
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d734 1
a734 1
	if (*endp != '\0' || l < 0 || l >= 0777)
@


1.3
log
@sudo 1.6.2
@
text
@d56 1
a56 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.17 2000/01/17 23:46:24 millert Exp $";
d185 18
d251 3
a302 6

#ifdef ENV_EDITOR
    (void) printf("Default editor for visudo: %s\n", EDITOR);
#else
    (void) printf("Editor for visudo: %s\n", EDITOR);
#endif
d551 4
d598 1
d676 1
a676 1
    openlog("sudo", 0, fac->num);
d684 1
a684 1
    openlog("sudo", 0);
@


1.2
log
@sudo 1.6.1
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d56 1
a56 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.13 1999/12/02 20:31:24 millert Exp $";
d109 1
d116 1
a116 2
	"syslog_ifac", T_INT, { 0 },
	NULL
d118 1
a118 2
	"syslog_igoodpri", T_INT, { 0 },
	NULL
d120 1
a120 2
	"syslog_ibadpri", T_INT, { 0 },
	NULL
d122 1
a122 1
	"syslog", T_LOGFAC|T_BOOL, { 0 },
d125 1
a125 1
	"syslog_goodpri", T_LOGPRI, { 0 },
d128 1
a128 1
	"syslog_badpri", T_LOGPRI, { 0 },
d131 1
a131 1
	"long_otp_prompt", T_FLAG, { 0 },
d134 1
a134 1
	"ignore_dot", T_FLAG, { 0 },
d137 1
a137 1
	"mail_always", T_FLAG, { 0 },
d140 1
a140 1
	"mail_no_user", T_FLAG, { 0 },
d143 1
a143 1
	"mail_no_host", T_FLAG, { 0 },
d146 1
a146 1
	"mail_no_perms", T_FLAG, { 0 },
d149 1
a149 1
	"tty_tickets", T_FLAG, { 0 },
d152 1
a152 1
	"lecture", T_FLAG, { 0 },
d155 1
a155 1
	"authenticate", T_FLAG, { 0 },
d158 1
a158 1
	"root_sudo", T_FLAG, { 0 },
d161 1
a161 1
	"log_host", T_FLAG, { 0 },
d164 1
a164 1
	"log_year", T_FLAG, { 0 },
d167 4
a170 1
	"set_home", T_FLAG, { 0 },
d173 1
a173 1
	"path_info", T_FLAG, { 0 },
d176 1
a176 1
	"fqdn", T_FLAG, { 0 },
d179 1
a179 1
	"insults", T_FLAG, { 0 },
d182 1
a182 1
	"requiretty", T_FLAG, { 0 },
d185 1
a185 1
	"loglinelen", T_INT|T_BOOL, { 0 },
d188 1
a188 1
	"timestamp_timeout", T_INT|T_BOOL, { 0 },
d191 1
a191 1
	"passwd_timeout", T_INT|T_BOOL, { 0 },
d194 1
a194 1
	"passwd_tries", T_INT, { 0 },
d197 1
a197 1
	"umask", T_MODE|T_BOOL, { 0 },
d200 1
a200 1
	"logfile", T_STR|T_BOOL|T_PATH, { 0 },
d203 1
a203 1
	"mailerpath", T_STR|T_BOOL|T_PATH, { 0 },
d206 1
a206 1
	"mailerflags", T_STR|T_BOOL, { 0 },
d209 1
a209 1
	"mailto", T_STR|T_BOOL, { 0 },
d212 1
a212 1
	"mailsub", T_STR, { 0 },
d215 1
a215 1
	"badpass_message", T_STR, { 0 },
d218 1
a218 1
	"timestampdir", T_STR|T_PATH, { 0 },
d221 1
a221 1
	"exempt_group", T_STR|T_BOOL, { 0 },
d224 1
a224 1
	"passprompt", T_STR, { 0 },
d227 1
a227 1
	"runas_default", T_STR, { 0 },
d230 1
a230 1
	"secure_path", T_STR|T_BOOL, { 0 },
d233 11
a243 1
	NULL, 0, { 0 }, NULL
d265 1
d373 13
d478 1
d521 3
d544 4
d637 4
a640 2
	free(def->sd_un.str);
	def->sd_un.str = NULL;
d718 47
@


1.1
log
@Initial revision
@
text
@d56 1
a56 1
static const char rcsid[] = "$Sudo: defaults.c,v 1.12 1999/11/05 22:11:55 millert Exp $";
a168 3
	"shell_noargs", T_FLAG, { 0 },
	"If sudo is invoked with no arguments, start a shell"
    }, {
d321 1
d323 1
a323 1
    for (cur = sudo_defs_table; cur->name; cur++) {
d426 4
a494 3
#ifdef SHELL_IF_NO_ARGS
    def_flag(I_SHELL_NOARGS) = TRUE;
#endif
d617 1
a617 1
    if (def->sd_un.str)
d619 3
d625 1
a625 1
    if (def->sd_un.str)
d627 3
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
