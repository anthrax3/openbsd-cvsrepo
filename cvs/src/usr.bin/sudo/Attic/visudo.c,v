head	1.30;
access;
symbols
	OPENBSD_5_7:1.29.0.16
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.20
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.18
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.14
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.10
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.8
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.6
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.29;
commitid	8ra5qnWqy2bUhcZn;

1.29
date	2010.06.02.19.30.10;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.19.00.09.00;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.22.16.33.42;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.18.16.02.01;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.31.16.44.04;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.05.23.55.57;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.29.17.29.05;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.05.16.44.00;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.17.16.48.01;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.02.17.59.06;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.17.58.19;	author deraadt;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2000.12.15.14.36.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.15.04.10.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.04.01.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.05.14.01.15;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.27.03.44.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.24.04.22.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.9.4.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1996, 1998-2005, 2007-2009
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Lock the sudoers file for safe editing (ala vipw) and check for parse errors.
 */

#define _SUDO_MAIN

#ifdef __TANDEM
# include <floss.h>
#endif

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/time.h>
#ifndef __TANDEM
# include <sys/file.h>
#endif
#include <sys/wait.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <ctype.h>
#include <pwd.h>
#include <grp.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#if TIME_WITH_SYS_TIME
# include <time.h>
#endif
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
#ifndef HAVE_TIMESPEC
# include <emul/timespec.h>
#endif

#include "sudo.h"
#include "interfaces.h"
#include "parse.h"
#include "redblack.h"
#include <gram.h>

struct sudoersfile {
    char *path;
    char *tpath;
    int fd;
    int tfd;
    int modified;
    int doedit;
    struct sudoersfile *next;
};

/*
 * Function prototypes
 */
static RETSIGTYPE quit		__P((int));
static char *get_args		__P((char *));
static char *get_editor		__P((char **));
static void get_hostname	__P((void));
static char whatnow		__P((void));
static int check_aliases	__P((int, int));
static int check_syntax		__P((char *, int, int));
static int edit_sudoers		__P((struct sudoersfile *, char *, char *, int));
static int install_sudoers	__P((struct sudoersfile *, int));
static int print_unused		__P((void *, void *));
static int reparse_sudoers	__P((char *, char *, int, int));
static int run_command		__P((char *, char **));
static void print_selfref	__P((char *, int, int, int));
static void print_undefined	__P((char *, int, int, int));
static void setup_signals	__P((void));
static void usage		__P((void)) __attribute__((__noreturn__));

extern void yyerror		__P((const char *));
extern void yyrestart		__P((FILE *));

/*
 * External globals exported by the parser
 */
extern struct rbtree *aliases;
extern FILE *yyin;
extern char *sudoers, *errorfile;
extern int errorlineno, parse_error;
/* For getopt(3) */
extern char *optarg;
extern int optind;

/*
 * Globals
 */
int Argc;
char **Argv;
int num_interfaces;
struct interface *interfaces;
struct sudo_user sudo_user;
struct passwd *list_pw;
static struct sudoerslist {
    struct sudoersfile *first, *last;
} sudoerslist;
static struct rbtree *alias_freelist;

int
main(argc, argv)
    int argc;
    char **argv;
{
    struct sudoersfile *sp;
    char *args, *editor, *sudoers_path;
    int ch, checkonly, quiet, strict, oldperms;
#if defined(SUDO_DEVEL) && defined(__OpenBSD__)
    extern char *malloc_options;
    malloc_options = "AFGJPR";
#endif

    Argv = argv;
    if ((Argc = argc) < 1)
	usage();

    /*
     * Arg handling.
     */
    checkonly = oldperms = quiet = strict = FALSE;
    sudoers_path = _PATH_SUDOERS;
    while ((ch = getopt(argc, argv, "Vcf:sq")) != -1) {
	switch (ch) {
	    case 'V':
		(void) printf("%s version %s\n", getprogname(), PACKAGE_VERSION);
		exit(0);
	    case 'c':
		checkonly++;		/* check mode */
		break;
	    case 'f':
		sudoers_path = optarg;	/* sudoers file path */
		oldperms = TRUE;
		break;
	    case 's':
		strict++;		/* strict mode */
		break;
	    case 'q':
		quiet++;		/* quiet mode */
		break;
	    default:
		usage();
	}
    }
    argc -= optind;
    argv += optind;
    if (argc)
	usage();

    sudo_setpwent();
    sudo_setgrent();

    /* Mock up a fake sudo_user struct. */
    user_cmnd = "";
    if ((sudo_user.pw = sudo_getpwuid(getuid())) == NULL)
	errorx(1, "you don't exist in the passwd database");
    get_hostname();

    /* Setup defaults data structures. */
    init_defaults();

    if (checkonly)
	exit(check_syntax(sudoers_path, quiet, strict));

    /*
     * Parse the existing sudoers file(s) in quiet mode to highlight any
     * existing errors and to pull in editor and env_editor conf values.
     */
    if ((yyin = open_sudoers(sudoers_path, TRUE, NULL)) == NULL) {
	error(1, "%s", sudoers_path);
    }
    init_parser(sudoers_path, 0);
    yyparse();
    (void) update_defaults(SETDEF_GENERIC|SETDEF_HOST|SETDEF_USER);

    editor = get_editor(&args);

    /* Install signal handlers to clean up temp files if we are killed. */
    setup_signals();

    /* Edit the sudoers file(s) */
    tq_foreach_fwd(&sudoerslist, sp) {
	if (!sp->doedit)
	    continue;
	if (sp != tq_first(&sudoerslist)) {
	    printf("press return to edit %s: ", sp->path);
	    while ((ch = getchar()) != EOF && ch != '\n')
		    continue;
	}
	edit_sudoers(sp, editor, args, -1);
    }

    /* Check edited files for a parse error and re-edit any that fail. */
    reparse_sudoers(editor, args, strict, quiet);

    /* Install the sudoers temp files. */
    tq_foreach_fwd(&sudoerslist, sp) {
	if (!sp->modified)
	    (void) unlink(sp->tpath);
	else
	    (void) install_sudoers(sp, oldperms);
    }

    exit(0);
}

/*
 * Edit each sudoers file.
 * Returns TRUE on success, else FALSE.
 */
static int
edit_sudoers(sp, editor, args, lineno)
    struct sudoersfile *sp;
    char *editor, *args;
    int lineno;
{
    int tfd;				/* sudoers temp file descriptor */
    int modified;			/* was the file modified? */
    int ac;				/* argument count */
    char **av;				/* argument vector for run_command */
    char *cp;				/* scratch char pointer */
    char buf[PATH_MAX*2];		/* buffer used for copying files */
    char linestr[64];			/* string version of lineno */
    struct timespec ts1, ts2;		/* time before and after edit */
    struct timespec orig_mtim;		/* starting mtime of sudoers file */
    off_t orig_size;			/* starting size of sudoers file */
    ssize_t nread;			/* number of bytes read */
    struct stat sb;			/* stat buffer */

#ifdef HAVE_FSTAT
    if (fstat(sp->fd, &sb) == -1)
#else
    if (stat(sp->path, &sb) == -1)
#endif
	error(1, "can't stat %s", sp->path);
    orig_size = sb.st_size;
    orig_mtim.tv_sec = mtim_getsec(sb);
    orig_mtim.tv_nsec = mtim_getnsec(sb);

    /* Create the temp file if needed and set timestamp. */
    if (sp->tpath == NULL) {
	easprintf(&sp->tpath, "%s.tmp", sp->path);
	tfd = open(sp->tpath, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (tfd < 0)
	    error(1, "%s", sp->tpath);

	/* Copy sp->path -> sp->tpath and reset the mtime. */
	if (orig_size != 0) {
	    (void) lseek(sp->fd, (off_t)0, SEEK_SET);
	    while ((nread = read(sp->fd, buf, sizeof(buf))) > 0)
		if (write(tfd, buf, nread) != nread)
		    error(1, "write error");

	    /* Add missing newline at EOF if needed. */
	    if (nread > 0 && buf[nread - 1] != '\n') {
		buf[0] = '\n';
		write(tfd, buf, 1);
	    }
	}
	(void) close(tfd);
    }
    (void) touch(-1, sp->tpath, &orig_mtim);

    /* Find the length of the argument vector */
    ac = 3 + (lineno > 0);
    if (args) {
        int wasblank;

        ac++;
        for (wasblank = FALSE, cp = args; *cp; cp++) {
            if (isblank((unsigned char) *cp))
                wasblank = TRUE;
            else if (wasblank) {
                wasblank = FALSE;
                ac++;
            }
        }
    }

    /* Build up argument vector for the command */
    av = emalloc2(ac, sizeof(char *));
    if ((av[0] = strrchr(editor, '/')) != NULL)
	av[0]++;
    else
	av[0] = editor;
    ac = 1;
    if (lineno > 0) {
	(void) snprintf(linestr, sizeof(linestr), "+%d", lineno);
	av[ac++] = linestr;
    }
    if (args) {
	for ((cp = strtok(args, " \t")); cp; (cp = strtok(NULL, " \t")))
	    av[ac++] = cp;
    }
    av[ac++] = sp->tpath;
    av[ac++] = NULL;

    /*
     * Do the edit:
     *  We cannot check the editor's exit value against 0 since
     *  XPG4 specifies that vi's exit value is a function of the
     *  number of errors during editing (?!?!).
     */
    gettime(&ts1);
    if (run_command(editor, av) != -1) {
	gettime(&ts2);
	/*
	 * Sanity checks.
	 */
	if (stat(sp->tpath, &sb) < 0) {
	    warningx("cannot stat temporary file (%s), %s unchanged",
		sp->tpath, sp->path);
	    return(FALSE);
	}
	if (sb.st_size == 0 && orig_size != 0) {
	    warningx("zero length temporary file (%s), %s unchanged",
		sp->tpath, sp->path);
	    sp->modified = TRUE;
	    return(FALSE);
	}
    } else {
	warningx("editor (%s) failed, %s unchanged", editor, sp->path);
	return(FALSE);
    }

    /* Set modified bit if use changed the file. */
    modified = TRUE;
    if (orig_size == sb.st_size &&
	orig_mtim.tv_sec == mtim_getsec(sb) &&
	orig_mtim.tv_nsec == mtim_getnsec(sb)) {
	/*
	 * If mtime and size match but the user spent no measurable
	 * time in the editor we can't tell if the file was changed.
	 */
#ifdef HAVE_TIMESPECSUB2
	timespecsub(&ts1, &ts2);
#else
	timespecsub(&ts1, &ts2, &ts2);
#endif
	if (timespecisset(&ts2))
	    modified = FALSE;
    }

    /*
     * If modified in this edit session, mark as modified.
     */
    if (modified)
	sp->modified = modified;
    else
	warningx("%s unchanged", sp->tpath);

    return(TRUE);
}

/*
 * Parse sudoers after editing and re-edit any ones that caused a parse error.
 * Returns TRUE on success, else FALSE.
 */
static int
reparse_sudoers(editor, args, strict, quiet)
    char *editor, *args;
    int strict, quiet;
{
    struct sudoersfile *sp, *last;
    FILE *fp;
    int ch;

    /*
     * Parse the edited sudoers files and do sanity checking
     */
    do {
	sp = tq_first(&sudoerslist);
	last = tq_last(&sudoerslist);
	fp = fopen(sp->tpath, "r+");
	if (fp == NULL)
	    errorx(1, "can't re-open temporary file (%s), %s unchanged.",
		sp->tpath, sp->path);

	/* Clean slate for each parse */
	init_defaults();
	init_parser(sp->path, quiet);

	/* Parse the sudoers temp file */
	yyrestart(fp);
	if (yyparse() && !parse_error) {
	    warningx("unabled to parse temporary file (%s), unknown error",
		sp->tpath);
	    parse_error = TRUE;
	    errorfile = sp->path;
	}
	fclose(yyin);
	if (!parse_error && check_aliases(strict, quiet) != 0) {
	    parse_error = TRUE;
	    errorfile = sp->path;
	}

	/*
	 * Got an error, prompt the user for what to do now
	 */
	if (parse_error) {
	    switch (whatnow()) {
		case 'Q' :	parse_error = FALSE;	/* ignore parse error */
				break;
		case 'x' :	cleanup(0);
				exit(0);
				break;
	    }
	}
	if (parse_error) {
	    /* Edit file with the parse error */
	    tq_foreach_fwd(&sudoerslist, sp) {
		if (errorfile == NULL || strcmp(sp->path, errorfile) == 0) {
		    edit_sudoers(sp, editor, args, errorlineno);
		    break;
		}
	    }
	    if (sp == NULL)
		errorx(1, "internal error, can't find %s in list!", sudoers);
	}

	/* If any new #include directives were added, edit them too. */
	for (sp = last->next; sp != NULL; sp = sp->next) {
	    printf("press return to edit %s: ", sp->path);
	    while ((ch = getchar()) != EOF && ch != '\n')
		    continue;
	    edit_sudoers(sp, editor, args, errorlineno);
	}
    } while (parse_error);

    return(TRUE);
}

/*
 * Set the owner and mode on a sudoers temp file and
 * move it into place.  Returns TRUE on success, else FALSE.
 */
static int
install_sudoers(sp, oldperms)
    struct sudoersfile *sp;
    int oldperms;
{
    struct stat sb;

    /*
     * Change mode and ownership of temp file so when
     * we move it to sp->path things are kosher.
     */
    if (oldperms) {
	/* Use perms of the existing file.  */
#ifdef HAVE_FSTAT
	if (fstat(sp->fd, &sb) == -1)
#else
	if (stat(sp->path, &sb) == -1)
#endif
	    error(1, "can't stat %s", sp->path);
	(void) chown(sp->tpath, sb.st_uid, sb.st_gid);
	(void) chmod(sp->tpath, sb.st_mode & 0777);
    } else {
	if (chown(sp->tpath, SUDOERS_UID, SUDOERS_GID) != 0) {
	    warning("unable to set (uid, gid) of %s to (%d, %d)",
		sp->tpath, SUDOERS_UID, SUDOERS_GID);
	    return(FALSE);
	}
	if (chmod(sp->tpath, SUDOERS_MODE) != 0) {
	    warning("unable to change mode of %s to 0%o", sp->tpath,
		SUDOERS_MODE);
	    return(FALSE);
	}
    }

    /*
     * Now that sp->tpath is sane (parses ok) it needs to be
     * rename(2)'d to sp->path.  If the rename(2) fails we try using
     * mv(1) in case sp->tpath and sp->path are on different file systems.
     */
    if (rename(sp->tpath, sp->path) == 0) {
	efree(sp->tpath);
	sp->tpath = NULL;
    } else {
	if (errno == EXDEV) {
	    char *av[4];
	    warningx("%s and %s not on the same file system, using mv to rename",
	      sp->tpath, sp->path);

	    /* Build up argument vector for the command */
	    if ((av[0] = strrchr(_PATH_MV, '/')) != NULL)
		av[0]++;
	    else
		av[0] = _PATH_MV;
	    av[1] = sp->tpath;
	    av[2] = sp->path;
	    av[3] = NULL;

	    /* And run it... */
	    if (run_command(_PATH_MV, av)) {
		warningx("command failed: '%s %s %s', %s unchanged",
		    _PATH_MV, sp->tpath, sp->path, sp->path);
		(void) unlink(sp->tpath);
		efree(sp->tpath);
		sp->tpath = NULL;
		return(FALSE);
	    }
	    efree(sp->tpath);
	    sp->tpath = NULL;
	} else {
	    warning("error renaming %s, %s unchanged", sp->tpath, sp->path);
	    (void) unlink(sp->tpath);
	    return(FALSE);
	}
    }
    return(TRUE);
}

/* STUB */
void
set_fqdn()
{
    return;
}

/* STUB */
void
init_envtables()
{
    return;
}

/* STUB */
int
user_is_exempt()
{
    return(FALSE);
}

/* STUB */
void
sudo_setspent()
{
    return;
}

/* STUB */
void
sudo_endspent()
{
    return;
}

char *
sudo_getepw(pw)
    const struct passwd *pw;
{
    return (pw->pw_passwd);
}

/*
 * Assuming a parse error occurred, prompt the user for what they want
 * to do now.  Returns the first letter of their choice.
 */
static char
whatnow()
{
    int choice, c;

    for (;;) {
	(void) fputs("What now? ", stdout);
	choice = getchar();
	for (c = choice; c != '\n' && c != EOF;)
	    c = getchar();

	switch (choice) {
	    case EOF:
		choice = 'x';
		/* FALLTHROUGH */
	    case 'e':
	    case 'x':
	    case 'Q':
		return(choice);
	    default:
		(void) puts("Options are:");
		(void) puts("  (e)dit sudoers file again");
		(void) puts("  e(x)it without saving changes to sudoers file");
		(void) puts("  (Q)uit and save changes to sudoers file (DANGER!)\n");
	}
    }
}

/*
 * Install signal handlers for visudo.
 */
static void
setup_signals()
{
	sigaction_t sa;

	/*
	 * Setup signal handlers to cleanup nicely.
	 */
	zero_bytes(&sa, sizeof(sa));
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = quit;
	(void) sigaction(SIGTERM, &sa, NULL);
	(void) sigaction(SIGHUP, &sa, NULL);
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
}

static int
run_command(path, argv)
    char *path;
    char **argv;
{
    int status;
    pid_t pid, rv;

    switch (pid = fork()) {
	case -1:
	    error(1, "unable to run %s", path);
	    break;	/* NOTREACHED */
	case 0:
	    sudo_endpwent();
	    sudo_endgrent();
	    closefrom(STDERR_FILENO + 1);
	    execv(path, argv);
	    warning("unable to run %s", path);
	    _exit(127);
	    break;	/* NOTREACHED */
    }

    do {
#ifdef sudo_waitpid
	rv = sudo_waitpid(pid, &status, 0);
#else
	rv = wait(&status);
#endif
    } while (rv == -1 && errno == EINTR);

    if (rv == -1 || !WIFEXITED(status))
	return(-1);
    return(WEXITSTATUS(status));
}

static int
check_syntax(sudoers_path, quiet, strict)
    char *sudoers_path;
    int quiet;
    int strict;
{
    struct stat sb;
    int error;

    if ((yyin = fopen(sudoers_path, "r")) == NULL) {
	if (!quiet)
	    warning("unable to open %s", sudoers_path);
	exit(1);
    }
    init_parser(sudoers_path, quiet);
    if (yyparse() && !parse_error) {
	if (!quiet)
	    warningx("failed to parse %s file, unknown error", sudoers_path);
	parse_error = TRUE;
	errorfile = sudoers_path;
    }
    if (!parse_error && check_aliases(strict, quiet) != 0) {
	parse_error = TRUE;
	errorfile = sudoers_path;
    }
    error = parse_error;
    if (!quiet) {
	if (parse_error) {
	    if (errorlineno != -1)
		(void) printf("parse error in %s near line %d\n", errorfile,
		    errorlineno);
	    else
		(void) printf("parse error in %s\n", errorfile);
	} else {
	    (void) printf("%s: parsed OK\n", sudoers_path);
	}
    }
    /* Check mode and owner in strict mode. */
#ifdef HAVE_FSTAT
    if (strict && fstat(fileno(yyin), &sb) == 0)
#else
    if (strict && stat(sudoers_path, &sb) == 0)
#endif
    {
	if (sb.st_uid != SUDOERS_UID || sb.st_gid != SUDOERS_GID) {
	    error = TRUE;
	    if (!quiet) {
		fprintf(stderr, "%s: wrong owner (uid, gid) should be (%d, %d)\n",
		    sudoers_path, SUDOERS_UID, SUDOERS_GID);
		}
	}
	if ((sb.st_mode & 07777) != SUDOERS_MODE) {
	    error = TRUE;
	    if (!quiet) {
		fprintf(stderr, "%s: bad permissions, should be mode 0%o\n",
		    sudoers_path, SUDOERS_MODE);
	    }
	}
    }

    return(error);
}

/*
 * Used to open (and lock) the initial sudoers file and to also open
 * any subsequent files #included via a callback from the parser.
 */
FILE *
open_sudoers(path, doedit, keepopen)
    const char *path;
    int doedit;
    int *keepopen;
{
    struct sudoersfile *entry;
    FILE *fp;

    /* Check for existing entry */
    tq_foreach_fwd(&sudoerslist, entry) {
	if (strcmp(path, entry->path) == 0)
	    break;
    }
    if (entry == NULL) {
	entry = emalloc(sizeof(*entry));
	entry->path = estrdup(path);
	entry->modified = 0;
	entry->next = NULL;
	entry->fd = open(entry->path, O_RDWR | O_CREAT, SUDOERS_MODE);
	entry->tpath = NULL;
	entry->tfd = -1;
	entry->doedit = doedit;
	if (entry->fd == -1) {
	    warning("%s", entry->path);
	    efree(entry);
	    return(NULL);
	}
	if (!lock_file(entry->fd, SUDO_TLOCK))
	    errorx(1, "%s busy, try again later", entry->path);
	if ((fp = fdopen(entry->fd, "r")) == NULL)
	    error(1, "%s", entry->path);
	/* XXX - macro here? */
	if (sudoerslist.last == NULL)
	    sudoerslist.first = sudoerslist.last = entry;
	else {
	    sudoerslist.last->next = entry;
	    sudoerslist.last = entry;
	}
    } else {
	/* Already exists, open .tmp version if there is one. */
	if (entry->tpath != NULL) {
	    if ((fp = fopen(entry->tpath, "r")) == NULL)
		error(1, "%s", entry->tpath);
	} else {
	    if ((fp = fdopen(entry->fd, "r")) == NULL)
		error(1, "%s", entry->path);
	    rewind(fp);
	}
    }
    if (keepopen != NULL)
	*keepopen = TRUE;
    return(fp);
}

static char *
get_editor(args)
    char **args;
{
    char *Editor, *EditorArgs, *EditorPath, *UserEditor, *UserEditorArgs;

    /*
     * Check VISUAL and EDITOR environment variables to see which editor
     * the user wants to use (we may not end up using it though).
     * If the path is not fully-qualified, make it so and check that
     * the specified executable actually exists.
     */
    UserEditorArgs = NULL;
    if ((UserEditor = getenv("VISUAL")) == NULL || *UserEditor == '\0')
	UserEditor = getenv("EDITOR");
    if (UserEditor && *UserEditor == '\0')
	UserEditor = NULL;
    else if (UserEditor) {
	UserEditorArgs = get_args(UserEditor);
	if (find_path(UserEditor, &Editor, NULL, getenv("PATH")) == FOUND) {
	    UserEditor = Editor;
	} else {
	    if (def_env_editor) {
		/* If we are honoring $EDITOR this is a fatal error. */
		errorx(1, "specified editor (%s) doesn't exist!", UserEditor);
	    } else {
		/* Otherwise, just ignore $EDITOR. */
		UserEditor = NULL;
	    }
	}
    }

    /*
     * See if we can use the user's choice of editors either because
     * we allow any $EDITOR or because $EDITOR is in the allowable list.
     */
    Editor = EditorArgs = EditorPath = NULL;
    if (def_env_editor && UserEditor) {
	Editor = UserEditor;
	EditorArgs = UserEditorArgs;
    } else if (UserEditor) {
	struct stat editor_sb;
	struct stat user_editor_sb;
	char *base, *userbase;

	if (stat(UserEditor, &user_editor_sb) != 0) {
	    /* Should never happen since we already checked above. */
	    error(1, "unable to stat editor (%s)", UserEditor);
	}
	EditorPath = estrdup(def_editor);
	Editor = strtok(EditorPath, ":");
	do {
	    EditorArgs = get_args(Editor);
	    /*
	     * Both Editor and UserEditor should be fully qualified but
	     * check anyway...
	     */
	    if ((base = strrchr(Editor, '/')) == NULL)
		continue;
	    if ((userbase = strrchr(UserEditor, '/')) == NULL) {
		Editor = NULL;
		break;
	    }
	    base++, userbase++;

	    /*
	     * We compare the basenames first and then use stat to match
	     * for sure.
	     */
	    if (strcmp(base, userbase) == 0) {
		if (stat(Editor, &editor_sb) == 0 && S_ISREG(editor_sb.st_mode)
		    && (editor_sb.st_mode & 0000111) &&
		    editor_sb.st_dev == user_editor_sb.st_dev &&
		    editor_sb.st_ino == user_editor_sb.st_ino)
		    break;
	    }
	} while ((Editor = strtok(NULL, ":")));
    }

    /*
     * Can't use $EDITOR, try each element of def_editor until we
     * find one that exists, is regular, and is executable.
     */
    if (Editor == NULL || *Editor == '\0') {
	efree(EditorPath);
	EditorPath = estrdup(def_editor);
	Editor = strtok(EditorPath, ":");
	do {
	    EditorArgs = get_args(Editor);
	    if (sudo_goodpath(Editor, NULL))
		break;
	} while ((Editor = strtok(NULL, ":")));

	/* Bleah, none of the editors existed! */
	if (Editor == NULL || *Editor == '\0')
	    errorx(1, "no editor found (editor path = %s)", def_editor);
    }
    *args = EditorArgs;
    return(Editor);
}

/*
 * Split out any command line arguments and return them.
 */
static char *
get_args(cmnd)
    char *cmnd;
{
    char *args;

    args = cmnd;
    while (*args && !isblank((unsigned char) *args))
	args++;
    if (*args) {
	*args++ = '\0';
	while (*args && isblank((unsigned char) *args))
	    args++;
    }
    return(*args ? args : NULL);
}

/*
 * Look up the hostname and set user_host and user_shost.
 */
static void
get_hostname()
{
    char *p, thost[MAXHOSTNAMELEN + 1];

    if (gethostname(thost, sizeof(thost)) != 0) {
	user_host = user_shost = "localhost";
	return;
    }
    thost[sizeof(thost) - 1] = '\0';
    user_host = estrdup(thost);

    if ((p = strchr(user_host, '.'))) {
	*p = '\0';
	user_shost = estrdup(user_host);
	*p = '.';
    } else {
	user_shost = user_host;
    }
}

static int
alias_remove_recursive(name, type, strict, quiet)
    char *name;
    int type;
    int strict;
    int quiet;
{
    struct member *m;
    struct alias *a;
    int error = 0;

    if ((a = alias_find(name, type)) != NULL) {
	tq_foreach_fwd(&a->members, m) {
	    if (m->type == ALIAS) {
		if (strcmp(name, m->name) == 0) {
		    print_selfref(m->name, type, strict, quiet);
		    error = 1;
		} else {
		    if (!alias_remove_recursive(m->name, type, strict, quiet))
			error = 1;
		}
	    }
	}
    }
    alias_seqno++;
    a = alias_remove(name, type);
    if (a)
	rbinsert(alias_freelist, a);
    return(error);
}

/*
 * Iterate through the sudoers datastructures looking for undefined
 * aliases or unused aliases.
 */
static int
check_aliases(strict, quiet)
    int strict;
    int quiet;
{
    struct cmndspec *cs;
    struct member *m, *binding;
    struct privilege *priv;
    struct userspec *us;
    struct defaults *d;
    int atype, error = 0;

    alias_freelist = rbcreate(alias_compare);

    /* Forward check. */
    tq_foreach_fwd(&userspecs, us) {
	tq_foreach_fwd(&us->users, m) {
	    if (m->type == ALIAS) {
		alias_seqno++;
		if (alias_find(m->name, USERALIAS) == NULL) {
		    print_undefined(m->name, USERALIAS, strict, quiet);
		    error++;
		}
	    }
	}
	tq_foreach_fwd(&us->privileges, priv) {
	    tq_foreach_fwd(&priv->hostlist, m) {
		if (m->type == ALIAS) {
		    alias_seqno++;
		    if (alias_find(m->name, HOSTALIAS) == NULL) {
			print_undefined(m->name, HOSTALIAS, strict, quiet);
			error++;
		    }
		}
	    }
	    tq_foreach_fwd(&priv->cmndlist, cs) {
		tq_foreach_fwd(&cs->runasuserlist, m) {
		    if (m->type == ALIAS) {
			alias_seqno++;
			if (alias_find(m->name, RUNASALIAS) == NULL) {
			    print_undefined(m->name, RUNASALIAS, strict, quiet);
			    error++;
			}
		    }
		}
		if ((m = cs->cmnd)->type == ALIAS) {
		    alias_seqno++;
		    if (alias_find(m->name, CMNDALIAS) == NULL) {
			print_undefined(m->name, CMNDALIAS, strict, quiet);
			error++;
		    }
		}
	    }
	}
    }

    /* Reverse check (destructive) */
    tq_foreach_fwd(&userspecs, us) {
	tq_foreach_fwd(&us->users, m) {
	    if (m->type == ALIAS) {
		if (!alias_remove_recursive(m->name, USERALIAS, strict, quiet))
		    error++;
	    }
	}
	tq_foreach_fwd(&us->privileges, priv) {
	    tq_foreach_fwd(&priv->hostlist, m) {
		if (m->type == ALIAS)
		    if (!alias_remove_recursive(m->name, HOSTALIAS, strict, 
			quiet))
			error++;
	    }
	    tq_foreach_fwd(&priv->cmndlist, cs) {
		tq_foreach_fwd(&cs->runasuserlist, m) {
		    if (m->type == ALIAS)
			if (!alias_remove_recursive(m->name, RUNASALIAS,
			    strict, quiet))
			    error++;
		}
		if ((m = cs->cmnd)->type == ALIAS)
		    if (!alias_remove_recursive(m->name, CMNDALIAS, strict,
			quiet))
			error++;
	    }
	}
    }
    tq_foreach_fwd(&defaults, d) {
	switch (d->type) {
	    case DEFAULTS_HOST:
		atype = HOSTALIAS;
		break;
	    case DEFAULTS_USER:
		atype = USERALIAS;
		break;
	    case DEFAULTS_RUNAS:
		atype = RUNASALIAS;
		break;
	    case DEFAULTS_CMND:
		atype = CMNDALIAS;
		break;
	    default:
		continue; /* not an alias */
	}
	tq_foreach_fwd(&d->binding, binding) {
	    for (m = binding; m != NULL; m = m->next) {
		if (m->type == ALIAS)
		    if (!alias_remove_recursive(m->name, atype, strict, quiet))
			error++;
	    }
	}
    }
    rbdestroy(alias_freelist, alias_free);

    /* If all aliases were referenced we will have an empty tree. */
    if (!no_aliases() && !quiet)
	alias_apply(print_unused, strict ? "Error" : "Warning");

    return (strict ? error : 0);
}

static void
print_undefined(name, type, strict, quiet)
    char *name;
    int type;
    int strict;
    int quiet;
{
    if (!quiet) {
	warningx("%s: %s_Alias `%s' referenced but not defined",
	    strict ? "Error" : "Warning",
	    type == HOSTALIAS ? "Host" : type == CMNDALIAS ? "Cmnd" :
	    type == USERALIAS ? "User" : type == RUNASALIAS ? "Runas" :
	    "Unknown", name);
    }
}

static void
print_selfref(name, type, strict, quiet)
    char *name;
    int type;
    int strict;
    int quiet;
{
    if (!quiet) {
	warningx("%s: %s_Alias `%s' references self",
	    strict ? "Error" : "Warning",
	    type == HOSTALIAS ? "Host" : type == CMNDALIAS ? "Cmnd" :
	    type == USERALIAS ? "User" : type == RUNASALIAS ? "Runas" :
	    "Unknown", name);
    }
}

static int
print_unused(v1, v2)
    void *v1;
    void *v2;
{
    struct alias *a = (struct alias *)v1;
    char *prefix = (char *)v2;

    warningx("%s: unused %s_Alias %s", prefix,
	a->type == HOSTALIAS ? "Host" : a->type == CMNDALIAS ? "Cmnd" :
	a->type == USERALIAS ? "User" : a->type == RUNASALIAS ? "Runas" :
	"Unknown", a->name);
    return(0);
}

/*
 * Unlink any sudoers temp files that remain.
 */
void
cleanup(gotsignal)
    int gotsignal;
{
    struct sudoersfile *sp;

    tq_foreach_fwd(&sudoerslist, sp) {
	if (sp->tpath != NULL)
	    (void) unlink(sp->tpath);
    }
    if (!gotsignal) {
	sudo_endpwent();
	sudo_endgrent();
    }
}

/*
 * Unlink sudoers temp files (if any) and exit.
 */
static RETSIGTYPE
quit(signo)
    int signo;
{
    cleanup(signo);
#define	emsg	 " exiting due to signal.\n"
    write(STDERR_FILENO, getprogname(), strlen(getprogname()));
    write(STDERR_FILENO, emsg, sizeof(emsg) - 1);
    _exit(signo);
}

static void
usage()
{
    (void) fprintf(stderr, "usage: %s [-c] [-q] [-s] [-V] [-f sudoers]\n",
	getprogname());
    exit(1);
}
@


1.29
log
@Update to sudo 1.7.2p7
@
text
@@


1.28
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d114 2
a115 1
static void print_undefined	__P((char *name, int, int, int));
d431 1
a431 1
	if (yyparse() && parse_error != TRUE) {
d435 1
d438 1
a438 1
	if (check_aliases(strict, quiet) != 0)
d440 2
d705 1
a705 1
    if (yyparse() && parse_error != TRUE) {
d709 1
d711 3
a713 3
    if (!parse_error) {
	if (check_aliases(strict, quiet) != 0)
	    parse_error = TRUE;
d717 7
a723 4
	if (parse_error)
	    (void) printf("parse error in %s near line %d\n", errorfile,
		errorlineno);
	else
d725 1
d957 2
a958 2
static void
alias_remove_recursive(name, type)
d961 2
d966 1
d971 7
a977 1
		alias_remove_recursive(m->name, type);
d985 1
d1052 2
a1053 1
		(void) alias_remove_recursive(m->name, USERALIAS);
d1059 3
a1061 1
		    (void) alias_remove_recursive(m->name, HOSTALIAS);
d1066 3
a1068 1
			(void) alias_remove_recursive(m->name, RUNASALIAS);
d1071 3
a1073 1
		    (void) alias_remove_recursive(m->name, CMNDALIAS);
d1097 2
a1098 1
		    (void) alias_remove_recursive(m->name, atype);
d1105 1
a1105 3
    if (no_aliases())
	return(0);
    if (!quiet) {
d1107 2
a1108 2
    }
    return (strict ? 1 : 0);
d1120 16
@


1.27
log
@Upgrade to sudo 1.7.2
@
text
@a88 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.234 2009/05/25 12:02:42 millert Exp $";
#endif /* lint */

@


1.26
log
@Sync with sudo 1.7.1 final
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2005, 2007-2008
a87 1
#include "version.h"
d90 1
a90 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.231 2009/04/16 12:22:04 millert Exp $";
d95 1
a96 1
    char *tpath;
d99 1
d175 1
a175 1
		(void) printf("%s version %s\n", getprogname(), version);
d218 1
a218 1
    if ((yyin = open_sudoers(sudoers_path, NULL)) == NULL)
d220 1
d232 2
d753 1
a753 1
open_sudoers(path, keepopen)
d755 1
d773 2
@


1.25
log
@Update to sudo 1.7.1
@
text
@d91 1
a91 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.229 2009/04/05 16:25:04 millert Exp $";
d714 1
a714 1
	    (void) printf("parse error in %s near line %d\n", sudoers_path,
a784 2
	if (keepopen != NULL)
	    *keepopen = TRUE;
d793 1
d796 2
@


1.24
log
@sync with sudo repo
@
text
@d86 1
d91 1
a91 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.223 2008/11/22 15:12:26 millert Exp $";
d109 1
d111 1
a111 1
static int check_aliases	__P((int));
d118 1
d128 1
d148 1
d203 1
a203 1
    user_host = user_shost = user_cmnd = "";
d206 1
d437 1
a437 1
	if (check_aliases(strict) != 0)
d707 4
d922 45
d971 1
a971 1
check_aliases(strict)
d973 1
d982 2
d989 2
a990 3
		if (find_alias(m->name, USERALIAS) == NULL) {
		    warningx("%s: User_Alias `%s' referenced but not defined",
			strict ? "Error" : "Warning", m->name);
d999 2
a1000 3
		    if (find_alias(m->name, HOSTALIAS) == NULL) {
			warningx("%s: Host_Alias `%s' referenced but not defined",
			    strict ? "Error" : "Warning", m->name);
d1009 2
a1010 3
			if (find_alias(m->name, RUNASALIAS) == NULL) {
			    warningx("%s: Runas_Alias `%s' referenced but not defined",
				strict ? "Error" : "Warning", m->name);
d1017 2
a1018 3
		    if (find_alias(m->name, CMNDALIAS) == NULL) {
			warningx("%s: Cmnd_Alias `%s' referenced but not defined",
			    strict ? "Error" : "Warning", m->name);
d1029 3
a1031 2
	    if (m->type == ALIAS)
		(void) alias_remove(m->name, USERALIAS);
d1036 1
a1036 1
		    (void) alias_remove(m->name, HOSTALIAS);
d1041 1
a1041 1
			(void) alias_remove(m->name, RUNASALIAS);
d1044 1
a1044 1
		    (void) alias_remove(m->name, CMNDALIAS);
d1068 1
a1068 1
		    (void) alias_remove(m->name, atype);
d1072 1
d1077 3
a1079 1
    alias_apply(print_unused, strict ? "Error" : "Warning");
d1081 16
@


1.23
log
@fix check_aliases
@
text
@d90 1
a90 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.221 2008/11/18 15:50:53 millert Exp $";
d153 4
d920 1
a920 1
    struct member *m;
d923 2
a924 1
    int error = 0;
d993 25
@


1.22
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d90 1
a90 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.220 2008/11/09 20:18:22 millert Exp $";
d924 3
a926 2
	    if (m->type == USERALIAS) {
		if (find_alias(m->name, m->type) == NULL) {
d935 3
a937 2
		if (m->type == HOSTALIAS) {
		    if (find_alias(m->name, m->type) == NULL) {
d946 3
a948 2
		    if (m->type == RUNASALIAS) {
			if (find_alias(m->name, m->type) == NULL) {
d955 3
a957 2
		if ((m = cs->cmnd)->type == CMNDALIAS) {
		    if (find_alias(m->name, m->type) == NULL) {
d970 2
a971 2
	    if (m->type == USERALIAS)
		(void) alias_remove(m->name, m->type);
d975 2
a976 2
		if (m->type == HOSTALIAS)
		    (void) alias_remove(m->name, m->type);
d980 2
a981 2
		    if (m->type == RUNASALIAS)
			(void) alias_remove(m->name, m->type);
d983 2
a984 2
		if ((m = cs->cmnd)->type == CMNDALIAS)
		    (void) alias_remove(m->name, m->type);
@


1.21
log
@Update to sudo 1.6.9p17
@
text
@d2 2
a3 1
 * Copyright (c) 1996, 1998-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 1
a61 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d64 7
d74 5
a78 3
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
d84 3
d90 1
a90 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.166.2.11 2008/06/21 00:47:52 millert Exp $";
d95 1
d97 3
a99 3
    int fd;
    off_t orig_size;
    struct timespec orig_mtim;
d105 3
a107 1
static void usage		__P((void)) __attribute__((__noreturn__));
d109 7
a115 3
static RETSIGTYPE Exit		__P((int));
static void edit_sudoers	__P((struct sudoersfile *, char *, char *, int));
static void visudo		__P((struct sudoersfile *, char *, char *));
d117 1
a117 6
static void install_sudoers	__P((struct sudoersfile *, int));
static int check_syntax		__P(());
static int run_command		__P((char *, char **));
static char *get_args		__P((char *));
static char *get_editor		__P((char **));
static FILE *open_sudoers	__P((struct sudoersfile *));
d119 2
a120 9
int command_matches		__P((char *, char *));
int addr_matches		__P((char *));
int hostname_matches		__P((char *, char *, char *));
int netgr_matches		__P((char *, char *, char *, char *));
int usergr_matches		__P((char *, char *, struct passwd *));
int userpw_matches		__P((char *, char *, struct passwd *));
void init_parser		__P((void));
void yyerror			__P((char *));
void yyrestart			__P((FILE *));
d126 2
a127 4
extern int errorlineno;
extern int pedantic;
extern int quiet;

d135 1
d137 2
d140 4
a143 2
int Argc, parse_error = FALSE;
static struct sudoersfile sudoers;
d150 3
a152 10
    char *args, *editor;
    int ch, checkonly, n, oldperms;

    /* Initialize sudoers struct. */
    sudoers.path = _PATH_SUDOERS;
    sudoers.tpath = _PATH_SUDOERS_TMP;
    sudoers.fd = -1;

    /* Warn about aliases that are used before being defined. */
    pedantic = 1;
d161 2
a162 1
    checkonly = oldperms = FALSE;
d171 2
a172 3
	    case 'f':			/* sudoers file path */
		sudoers.path = optarg;
		easprintf(&sudoers.tpath, "%s.tmp", optarg);
d176 1
a176 1
		pedantic++;		/* strict mode */
d190 3
d195 2
a196 2
    if ((sudo_user.pw = getpwuid(getuid())) == NULL)
	errx(1, "you don't exist in the passwd database");
d202 1
a202 1
	exit(check_syntax());
d205 6
a210 8
     * Open and parse the existing sudoers file(s) in quiet mode to highlight
     * any existing errors and to pull in editor and env_editor conf values.
     */  
    if ((yyin = open_sudoers(&sudoers)) == NULL)
	err(1, "%s", sudoers.path);
    n = quiet;
    quiet = 1;
    init_parser();
d212 1
a212 2
    parse_error = FALSE;
    quiet = n;
a213 1
    /* Edit sudoers, check for parse errors and re-edit on failure. */
a214 1
    visudo(&sudoers, editor, args);
d216 23
a238 2
    /* Install the new sudoers file. */
    install_sudoers(&sudoers, oldperms);
d244 1
a244 1
 * Edit the sudoers file.
d247 1
a247 1
static void
d253 2
d258 1
d261 3
d266 33
a298 2
    /* Make timestamp on temp file match original. */
    (void) touch(-1, sp->tpath, &sp->orig_mtim);
d347 1
a347 1
	    warnx("cannot stat temporary file (%s), %s unchanged",
d349 1
a349 1
	    Exit(-1);
d351 2
a352 2
	if (sb.st_size == 0) {
	    warnx("zero length temporary file (%s), %s unchanged",
d354 2
a355 1
	    Exit(-1);
d358 2
a359 2
	warnx("editor (%s) failed, %s unchanged", editor, sp->path);
	Exit(-1);
d362 5
a366 4
    /* Check to see if the user changed the file. */
    if (sp->orig_size == sb.st_size &&
	sp->orig_mtim.tv_sec == mtim_getsec(sb) &&
	sp->orig_mtim.tv_nsec == mtim_getnsec(sb)) {
d376 2
a377 4
	if (timespecisset(&ts2)) {
	    warnx("%s unchanged", sp->tpath);
	    Exit(0);
	}
d379 10
d395 2
a396 3
static void
visudo(sp, editor, args)
    struct sudoersfile *sp;
d398 1
d400 2
d405 1
a405 1
     * Parse the edited sudoers file and do sanity checking
d408 5
a412 5
	edit_sudoers(sp, editor, args, errorlineno);

	yyin = fopen(sp->tpath, "r+");
	if (yyin == NULL) {
	    warnx("can't re-open temporary file (%s), %s unchanged.",
a413 7
	    Exit(-1);
	}

	/* Add missing newline at EOF if needed. */
	if (fseek(yyin, -1, SEEK_END) == 0 && (ch = fgetc(yyin)) != '\n')
	    fputc('\n', yyin);
	rewind(yyin);
a415 1
	user_runas = NULL;
d417 1
a417 1
	init_parser();
d420 1
a420 1
	yyrestart(yyin);
d422 1
a422 1
	    warnx("unabled to parse temporary file (%s), unknown error",
d427 2
d437 2
a438 1
		case 'x' :	Exit(0);
d442 19
d462 2
d470 1
a470 1
static void
d488 1
a488 1
	    err(1, "can't stat %s", sp->path);
d493 1
a493 1
	    warn("unable to set (uid, gid) of %s to (%d, %d)",
d495 1
a495 1
	    Exit(-1);
d498 3
a500 2
	    warn("unable to change mode of %s to 0%o", sp->tpath, SUDOERS_MODE);
	    Exit(-1);
d509 4
a512 1
    if (rename(sp->tpath, sp->path) != 0) {
d515 1
a515 1
	    warnx("%s and %s not on the same file system, using mv to rename",
d529 1
a529 1
		warnx("command failed: '%s %s %s', %s unchanged",
d531 4
a534 1
		Exit(-1);
d536 2
d539 3
a541 2
	    warn("error renaming %s, %s unchanged", sp->tpath, sp->path);
	    Exit(-1);
a543 11
}

/*
 * Dummy *_matches routines.
 * These exist to allow us to use the same parser as sudo(8).
 */
int
command_matches(path, sudoers_args)
    char *path;
    char *sudoers_args;
{
d547 3
a549 3
int
addr_matches(n)
    char *n;
d551 1
a551 1
    return(TRUE);
d554 3
a556 3
int
hostname_matches(s, l, p)
    char *s, *l, *p;
d558 1
a558 1
    return(TRUE);
d561 1
d563 1
a563 3
usergr_matches(g, u, pw)
    char *g, *u;
    struct passwd *pw;
d565 1
a565 1
    return(TRUE);
d568 3
a570 4
int
userpw_matches(s, u, pw)
    char *s, *u;
    struct passwd *pw;
d572 1
a572 8
    return(TRUE);
}

int
netgr_matches(n, h, sh, u)
    char *n, *h, *sh, *u;
{
    return(TRUE);
d575 1
d577 1
a577 1
set_fqdn()
d582 3
a584 24
int
set_runaspw(user)
    char *user;
{
    extern int sudolineno, used_runas;

    if (used_runas) {
	(void) fprintf(stderr,
	    "%s: runas_default set after old value is in use near line %d\n",
	    pedantic > 1 ? "Error" : "Warning", sudolineno);
	if (pedantic > 1)
	    yyerror(NULL);
    }
    return(TRUE);
}

int
user_is_exempt()
{
    return(TRUE);
}

void
init_envtables()
d586 1
a586 1
    return;
d632 1
d635 1
a635 1
	sa.sa_handler = Exit;
d652 1
a652 2
	    warn("unable to run %s", path);
	    Exit(-1);
d655 2
a656 1
	    endpwent();
d659 1
a659 1
	    warn("unable to run %s", path);
d678 4
a681 1
check_syntax()
d683 2
d686 1
a686 1
    if ((yyin = fopen(sudoers.path, "r")) == NULL) {
d688 1
a688 1
	    warn("unable to open %s", sudoers.path);
d691 1
a691 1
    init_parser();
d694 1
a694 1
	    warnx("failed to parse %s file, unknown error", sudoers.path);
d697 2
a698 1
    if (!quiet){
d700 1
a700 1
	    (void) printf("parse error in %s near line %d\n", sudoers.path,
d703 23
a725 1
	    (void) printf("%s file parsed OK\n", sudoers.path);
d728 1
a728 1
    return(parse_error == TRUE);
d731 8
a738 3
static FILE *
open_sudoers(sp)
    struct sudoersfile *sp;
d740 1
a740 2
    struct stat sb;
    ssize_t nread;
a741 2
    char buf[PATH_MAX*2];
    int tfd;
d743 38
a780 40
    /* Open and lock sudoers. */
    sp->fd = open(sp->path, O_RDWR | O_CREAT, SUDOERS_MODE);
    if (sp->fd == -1)
	err(1, "%s", sp->path);
    if (!lock_file(sp->fd, SUDO_TLOCK))
	errx(1, "%s busy, try again later", sp->path);
    if ((fp = fdopen(sp->fd, "r")) == NULL)
	err(1, "%s", sp->path);

    /* Stash sudoers size and mtime. */
#ifdef HAVE_FSTAT
    if (fstat(sp->fd, &sb) == -1)
#else
    if (stat(sp->path, &sb) == -1)
#endif
	err(1, "can't stat %s", sp->path);
    sp->orig_size = sb.st_size;
    sp->orig_mtim.tv_sec = mtim_getsec(sb);
    sp->orig_mtim.tv_nsec = mtim_getnsec(sb);

    /* Create the temp file. */
    tfd = open(sp->tpath, O_WRONLY | O_CREAT | O_TRUNC, 0600);
    if (tfd < 0)
	err(1, "%s", sp->tpath);

    /* Install signal handlers to clean up temp file if we are killed. */
    setup_signals();

    /* Copy sp->path -> sp->tpath. */
    if (sp->orig_size != 0) {
	while ((nread = read(sp->fd, buf, sizeof(buf))) > 0)
	    if (write(tfd, buf, nread) != nread) {
		warn("write error");
		Exit(-1);
	    }

	/* Add missing newline at EOF if needed. */
	if (nread > 0 && buf[nread - 1] != '\n') {
	    buf[0] = '\n';
	    write(tfd, buf, 1);
a782 3
    (void) close(tfd);
    rewind(fp);

d810 1
a810 2
		warnx("specified editor (%s) doesn't exist!", UserEditor);
		Exit(-1);
d833 1
a833 2
	    warn("unable to stat editor (%s)", UserEditor);
	    Exit(-1);
d880 2
a881 4
	if (Editor == NULL || *Editor == '\0') {
	    warnx("no editor found (editor path = %s)", def_editor);
	    Exit(-1);
	}
d908 2
a909 3
 * Unlink the sudoers temp file (if it exists) and exit.
 * Used in place of a normal exit() and as a signal handler.
 * A positive parameter indicates we were called as a signal handler.
d911 3
a913 3
static RETSIGTYPE
Exit(sig)
    int sig;
d915 90
a1004 1
#define	emsg	 " exiting due to signal.\n"
d1006 8
a1013 1
    (void) unlink(sudoers.tpath);
d1015 3
a1017 4
    if (sig > 0) {
	write(STDERR_FILENO, getprogname(), strlen(getprogname()));
	write(STDERR_FILENO, emsg, sizeof(emsg) - 1);
	_exit(sig);
d1019 18
a1036 1
    exit(-sig);
@


1.20
log
@update to sudo 1.6.9p5
@
text
@d81 1
a81 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.166.2.10 2007/09/01 13:39:13 millert Exp $";
d593 1
a593 6
    pid_t pid;
    sigset_t set, oset;

    (void) sigemptyset(&set);
    (void) sigaddset(&set, SIGCHLD);
    (void) sigprocmask(SIG_BLOCK, &set, &oset);
a600 1
	    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
d609 1
d611 1
a611 1
    pid = sudo_waitpid(pid, &status, 0);
d613 1
a613 1
    pid = wait(&status);
d615 1
d617 1
a617 3
    (void) sigprocmask(SIG_SETMASK, &oset, NULL);

    if (pid == -1 || !WIFEXITED(status))
@


1.19
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d81 1
a81 1
__unused static const char rcsid[] = "$Sudo: visudo.c,v 1.166.2.9 2007/07/22 19:21:01 millert Exp $";
d101 1
a101 1
static void install_sudoers	__P((struct sudoersfile *));
d144 1
a144 1
    int ch, checkonly, n;
d161 1
a161 1
    checkonly = 0;
d173 1
d219 1
a219 1
    install_sudoers(&sudoers);
d387 1
a387 1
install_sudoers(sp)
d389 1
d391 2
d397 20
a416 8
    if (chown(sp->tpath, SUDOERS_UID, SUDOERS_GID) != 0) {
	warn("unable to set (uid, gid) of %s to (%d, %d)",
	    sp->tpath, SUDOERS_UID, SUDOERS_GID);
	Exit(-1);
    }
    if (chmod(sp->tpath, SUDOERS_MODE) != 0) {
	warn("unable to change mode of %s to 0%o", sp->tpath, SUDOERS_MODE);
	Exit(-1);
@


1.18
log
@update to sudo 1.6.8p5
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d31 1
a31 1
#include "config.h"
d67 3
a69 1
#include <time.h>
d73 3
d81 1
a81 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.170 2004/09/08 15:48:23 millert Exp $";
d84 8
d95 1
a95 1
static void usage		__P((void));
d98 2
d101 2
d104 4
a107 1
static int check_syntax		__P((int));
d121 1
a121 1
extern FILE *yyin, *yyout;
a133 2
char *sudoers = _PATH_SUDOERS;
char *stmp = _PATH_SUDOERS_TMP;
d136 1
d143 7
a149 14
    char buf[PATH_MAX*2];		/* buffer used for copying files */
    char *Editor;			/* editor to use */
    char *UserEditor;			/* editor user wants to use */
    char *EditorPath;			/* colon-separated list of editors */
    char *av[4];			/* argument vector for run_command */
    int checkonly;			/* only check existing file? */
    int sudoers_fd;			/* sudoers file descriptor */
    int stmp_fd;			/* stmp file descriptor */
    int n;				/* length parameter */
    int ch;				/* getopt char */
    struct timespec ts1, ts2;		/* time before and after edit */
    struct timespec sudoers_mtim;	/* starting mtime of sudoers file */
    off_t sudoers_size;			/* starting size of sudoers file */
    struct stat sb;			/* stat buffer */
d170 3
a172 3
	    case 'f':
		sudoers = optarg;	/* sudoers file path */
		easprintf(&stmp, "%s.tmp", optarg);
d198 1
a198 1
	exit(check_syntax(quiet));
d201 15
a215 17
     * Open sudoers, lock it and stat it.
     * sudoers_fd must remain open throughout in order to hold the lock.
     */
    sudoers_fd = open(sudoers, O_RDWR | O_CREAT, SUDOERS_MODE);
    if (sudoers_fd == -1)
	err(1, "%s", sudoers);
    if (!lock_file(sudoers_fd, SUDO_TLOCK))
	errx(1, "sudoers file busy, try again later");
#ifdef HAVE_FSTAT
    if (fstat(sudoers_fd, &sb) == -1)
#else
    if (stat(sudoers, &sb) == -1)
#endif
	err(1, "can't stat %s", sudoers);
    sudoers_size = sb.st_size;
    sudoers_mtim.tv_sec = mtim_getsec(sb);
    sudoers_mtim.tv_nsec = mtim_getnsec(sb);
d217 2
a218 6
    /*
     * Open sudoers temp file.
     */
    stmp_fd = open(stmp, O_WRONLY | O_CREAT | O_TRUNC, 0600);
    if (stmp_fd < 0)
	err(1, "%s", stmp);
d220 2
a221 2
    /* Install signal handlers to clean up stmp if we are killed. */
    setup_signals();
d223 16
a238 5
    /* Copy sudoers -> stmp and reset the mtime */
    if (sudoers_size) {
	while ((n = read(sudoers_fd, buf, sizeof(buf))) > 0)
	    if (write(stmp_fd, buf, n) != n)
		err(1, "write error");
d240 2
a241 5
	/* Add missing newline at EOF if needed. */
	if (n > 0 && buf[n - 1] != '\n') {
	    buf[0] = '\n';
	    write(stmp_fd, buf, 1);
	}
d243 33
a275 16
	(void) touch(stmp_fd, stmp, &sudoers_mtim);
	(void) close(stmp_fd);

	/* Parse sudoers to pull in editor and env_editor conf values. */
	if ((yyin = fopen(stmp, "r"))) {
	    yyout = stdout;
	    n = quiet;
	    quiet = 1;
	    init_parser();
	    yyparse();
	    parse_error = FALSE;
	    quiet = n;
	    fclose(yyin);
	}
    } else
	(void) close(stmp_fd);
d278 4
a281 4
     * Check VISUAL and EDITOR environment variables to see which editor
     * the user wants to use (we may not end up using it though).
     * If the path is not fully-qualified, make it so and check that
     * the specified executable actually exists.
d283 10
a292 16
    if ((UserEditor = getenv("VISUAL")) == NULL || *UserEditor == '\0')
	UserEditor = getenv("EDITOR");
    if (UserEditor && *UserEditor == '\0')
	UserEditor = NULL;
    else if (UserEditor) {
	if (find_path(UserEditor, &Editor, NULL, getenv("PATH")) == FOUND) {
	    UserEditor = Editor;
	} else {
	    if (def_env_editor) {
		/* If we are honoring $EDITOR this is a fatal error. */
		warnx("specified editor (%s) doesn't exist!", UserEditor);
		Exit(-1);
	    } else {
		/* Otherwise, just ignore $EDITOR. */
		UserEditor = NULL;
	    }
d294 3
a296 17
    }

    /*
     * See if we can use the user's choice of editors either because
     * we allow any $EDITOR or because $EDITOR is in the allowable list.
     */
    Editor = EditorPath = NULL;
    if (def_env_editor && UserEditor)
	Editor = UserEditor;
    else if (UserEditor) {
	struct stat editor_sb;
	struct stat user_editor_sb;
	char *base, *userbase;

	if (stat(UserEditor, &user_editor_sb) != 0) {
	    /* Should never happen since we already checked above. */
	    warn("unable to stat editor (%s)", UserEditor);
d299 3
a301 27
	EditorPath = estrdup(def_editor);
	Editor = strtok(EditorPath, ":");
	do {
	    /*
	     * Both Editor and UserEditor should be fully qualified but
	     * check anyway...
	     */
	    if ((base = strrchr(Editor, '/')) == NULL)
		continue;
	    if ((userbase = strrchr(UserEditor, '/')) == NULL) {
		Editor = NULL;
		break;
	    }
	    base++, userbase++;

	    /*
	     * We compare the basenames first and then use stat to match
	     * for sure.
	     */
	    if (strcmp(base, userbase) == 0) {
		if (stat(Editor, &editor_sb) == 0 && S_ISREG(editor_sb.st_mode)
		    && (editor_sb.st_mode & 0000111) &&
		    editor_sb.st_dev == user_editor_sb.st_dev &&
		    editor_sb.st_ino == user_editor_sb.st_ino)
		    break;
	    }
	} while ((Editor = strtok(NULL, ":")));
d304 16
a319 18
    /*
     * Can't use $EDITOR, try each element of def_editor until we
     * find one that exists, is regular, and is executable.
     */
    if (Editor == NULL || *Editor == '\0') {
	if (EditorPath != NULL)
	    free(EditorPath);
	EditorPath = estrdup(def_editor);
	Editor = strtok(EditorPath, ":");
	do {
	    if (sudo_goodpath(Editor, NULL))
		break;
	} while ((Editor = strtok(NULL, ":")));

	/* Bleah, none of the editors existed! */
	if (Editor == NULL || *Editor == '\0') {
	    warnx("no editor found (editor path = %s)", def_editor);
	    Exit(-1);
d322 12
d336 1
a336 1
     * Edit the temp file and parse it (for sanity checking)
d339 1
a339 1
	char linestr[64];
d341 5
a345 9
	/* Build up argument vector for the command */
	if ((av[0] = strrchr(Editor, '/')) != NULL)
	    av[0]++;
	else
	    av[0] = Editor;
	n = 1;
	if (parse_error == TRUE) {
	    (void) snprintf(linestr, sizeof(linestr), "+%d", errorlineno);
	    av[n++] = linestr;
a346 2
	av[n++] = stmp;
	av[n++] = NULL;
d348 16
a363 56
	/*
	 * Do the edit:
	 *  We cannot check the editor's exit value against 0 since
	 *  XPG4 specifies that vi's exit value is a function of the
	 *  number of errors during editing (?!?!).
	 */
	gettime(&ts1);
	if (run_command(Editor, av) != -1) {
	    gettime(&ts2);
	    /*
	     * Sanity checks.
	     */
	    if (stat(stmp, &sb) < 0) {
		warnx("cannot stat temporary file (%s), %s unchanged",
		    stmp, sudoers);
		Exit(-1);
	    }
	    if (sb.st_size == 0) {
		warnx("zero length temporary file (%s), %s unchanged",
		    stmp, sudoers);
		Exit(-1);
	    }

	    /*
	     * Passed sanity checks so reopen stmp file and check
	     * for parse errors.
	     */
	    yyout = stdout;
	    yyin = fopen(stmp, "r+");
	    if (yyin == NULL) {
		warnx("can't re-open temporary file (%s), %s unchanged.",
		    stmp, sudoers);
		Exit(-1);
	    }

	    /* Add missing newline at EOF if needed. */
	    if (fseek(yyin, -1, SEEK_END) == 0 && (ch = fgetc(yyin)) != '\n')
		fputc('\n', yyin);
	    rewind(yyin);

	    /* Clean slate for each parse */
	    user_runas = NULL;
	    init_defaults();
	    init_parser();

	    /* Parse the sudoers temp file */
	    yyrestart(yyin);
	    if (yyparse() && parse_error != TRUE) {
		warnx("unabled to parse temporary file (%s), unknown error",
		    stmp);
		parse_error = TRUE;
	    }
	    fclose(yyin);
	} else {
	    warnx("editor (%s) failed, %s unchanged", Editor, sudoers);
	    Exit(-1);
d365 1
d370 1
a370 1
	if (parse_error == TRUE) {
d374 1
a374 3
		case 'x' :	if (sudoers_size == 0)
				    unlink(sudoers);
				Exit(0);
d378 2
a379 22
    } while (parse_error == TRUE);

    /*
     * If the user didn't change the temp file, just unlink it.
     */
    if (sudoers_size == sb.st_size &&
	sudoers_mtim.tv_sec == mtim_getsec(sb) &&
	sudoers_mtim.tv_nsec == mtim_getnsec(sb)) {
	/*
	 * If mtime and size match but the user spent no measurable
	 * time in the editor we can't tell if the file was changed.
	 */
#ifdef HAVE_TIMESPECSUB2
	timespecsub(&ts1, &ts2);
#else
	timespecsub(&ts1, &ts2, &ts2);
#endif
	if (timespecisset(&ts2)) {
	    warnx("sudoers file unchanged");
	    Exit(0);
	}
    }
d381 8
d391 1
a391 1
     * we move it to sudoers things are kosher.
d393 1
a393 1
    if (chown(stmp, SUDOERS_UID, SUDOERS_GID)) {
d395 1
a395 1
	    stmp, SUDOERS_UID, SUDOERS_GID);
d398 2
a399 2
    if (chmod(stmp, SUDOERS_MODE)) {
	warn("unable to change mode of %s to 0%o", stmp, SUDOERS_MODE);
d404 3
a406 3
     * Now that we have a sane stmp file (parses ok) it needs to be
     * rename(2)'d to sudoers.  If the rename(2) fails we try using
     * mv(1) in case stmp and sudoers are on different file systems.
d408 1
a408 1
    if (rename(stmp, sudoers)) {
d410 1
d412 1
a412 1
	      stmp, sudoers);
d419 2
a420 2
	    av[1] = stmp;
	    av[2] = sudoers;
d426 1
a426 1
		    _PATH_MV, stmp, sudoers, sudoers);
d430 1
a430 1
	    warn("error renaming %s, %s unchanged", stmp, sudoers);
a433 2

    exit(0);
d591 2
d613 1
a613 2
check_syntax(quiet)
    int quiet;
d616 1
a616 1
    if ((yyin = fopen(sudoers, "r")) == NULL) {
d618 1
a618 1
	    warn("unable to open %s", sudoers);
a620 1
    yyout = stdout;
d624 1
a624 1
	    warnx("failed to parse %s file, unknown error", sudoers);
d629 1
a629 1
	    (void) printf("parse error in %s near line %d\n", sudoers,
d632 1
a632 1
	    (void) printf("%s file parsed OK\n", sudoers);
d638 183
d832 1
a832 1
    (void) unlink(stmp);
d845 1
a845 1
    (void) fprintf(stderr, "usage: %s [-c] [-f sudoers] [-q] [-s] [-V]\n",
@


1.17
log
@Update to sudo 1.6.8p1
@
text
@d440 3
d444 1
@


1.16
log
@In Exit() when used as a signal handler, emsg is a pointer so
sizeof() is wrong so make it a #define instead.  Also avoid using
a negative exit value.  Found by aaron@@
@
text
@d2 1
a2 2
 * Copyright (c) 1996, 1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d27 4
d36 4
a39 1
#include <sys/file.h>
d76 1
a76 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.151 2003/04/16 00:42:10 millert Exp $";
d88 1
a88 1
int command_matches		__P((char *, char *, char *, char *));
d92 2
a93 1
int usergr_matches		__P((char *, char *));
d95 1
d117 1
a117 1
int parse_error = FALSE;
d124 1
a124 1
    char buf[MAXPATHLEN*2];		/* buffer used for copying files */
d134 4
a137 2
    time_t now;				/* time now */
    struct stat stmp_sb, sudoers_sb;	/* to check for changes */
d142 3
a144 1
    Argv = argv;			/* for warn/err */
d189 1
a189 1
     * Open sudoers, lock it and stat it.  
d198 1
a198 1
    if (fstat(sudoers_fd, &sudoers_sb) == -1)
d200 1
a200 1
    if (stat(sudoers, &sudoers_sb) == -1)
d203 3
d218 1
a218 1
    if (sudoers_sb.st_size) {
d229 1
a230 1
	(void) touch(stmp, sudoers_sb.st_mtime);
d247 1
a247 1
     * Check EDITOR and VISUAL environment variables to see which editor
d252 2
a253 2
    if ((UserEditor = getenv("EDITOR")) == NULL || *UserEditor == '\0')
	UserEditor = getenv("VISUAL");
d257 1
a257 1
	if (find_path(UserEditor, &Editor, getenv("PATH")) == FOUND) {
d260 1
a260 1
	    if (def_flag(I_ENV_EDITOR)) {
d276 1
a276 1
    if (def_flag(I_ENV_EDITOR) && UserEditor)
d288 1
a288 1
	EditorPath = estrdup(def_str(I_EDITOR));
d318 1
a318 1
     * Can't use $EDITOR, try each element of I_EDITOR until we
d324 1
a324 1
	EditorPath = estrdup(def_str(I_EDITOR));
d327 1
a327 1
	    if (sudo_goodpath(Editor))
d333 1
a333 1
	    warnx("no editor found (editor path = %s)", def_str(I_EDITOR));
d363 1
a363 1
	now = time(NULL);
d365 1
d369 1
a369 1
	    if (stat(stmp, &stmp_sb) < 0) {
d374 1
a374 1
	    if (stmp_sb.st_size == 0) {
d422 1
a422 1
		case 'x' :	if (sudoers_sb.st_size == 0)
d433 12
a444 4
    if (sudoers_sb.st_mtime != now && sudoers_sb.st_mtime == stmp_sb.st_mtime &&
	sudoers_sb.st_size == stmp_sb.st_size) {
	warnx("sudoers file unchanged");
	Exit(0);
d464 1
a464 1
     * mv(1) in case stmp and sudoers are on different filesystems.
d468 1
a468 1
	    warnx("%s and %s not on the same filesystem, using mv to rename",
d500 1
a500 3
command_matches(cmnd, cmnd_args, path, sudoers_args)
    char *cmnd;
    char *cmnd_args;
d522 1
a522 1
usergr_matches(g, u)
d524 9
d551 16
d664 3
a666 2
    /* XXX - should use WEXITSTATUS() */
    return(pid == -1 ? -1 : (status >> 8));
@


1.15
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d675 1
a675 1
    char *emsg = " exiting due to signal.\n";
d682 1
a682 1
	_exit(-sig);
@


1.14
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d33 4
d87 1
a87 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.150 2003/04/02 18:25:19 millert Exp $";
@


1.13
log
@update to what will soon be sudo 1.6.7
@
text
@d39 2
d67 5
d83 1
a83 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.149 2003/03/15 20:31:02 millert Exp $";
d145 1
a145 4
    /*
     * Parse command line options
     */
    Argv = argv;
d154 1
a154 1
		(void) printf("visudo version %s\n", version);
d180 2
a181 5
    if ((sudo_user.pw = getpwuid(getuid())) == NULL) {
	(void) fprintf(stderr, "%s: Can't find you in the passwd database.\n",
	    Argv[0]);
	exit(1);
    }
d194 4
a197 10
    if (sudoers_fd == -1) {
	(void) fprintf(stderr, "%s: %s: %s\n", Argv[0], sudoers,
	    strerror(errno));
	exit(1);
    }
    if (!lock_file(sudoers_fd, SUDO_TLOCK)) {
	(void) fprintf(stderr, "%s: sudoers file busy, try again later.\n",
	    Argv[0]);
	exit(1);
    }
d199 1
a199 1
    if (fstat(sudoers_fd, &sudoers_sb) == -1) {
d201 1
a201 1
    if (stat(sudoers, &sudoers_sb) == -1) {
d203 1
a203 4
	(void) fprintf(stderr, "%s: can't stat %s: %s\n",
	    Argv[0], sudoers, strerror(errno));
	exit(1);
    }
d209 2
a210 4
    if (stmp_fd < 0) {
	(void) fprintf(stderr, "%s: %s: %s\n", Argv[0], stmp, strerror(errno));
	exit(1);
    }
d218 2
a219 5
	    if (write(stmp_fd, buf, n) != n) {
		(void) fprintf(stderr, "%s: Write failed: %s\n", Argv[0],
		strerror(errno));
		Exit(-1);
	    }
d260 1
a260 3
		(void) fprintf(stderr,
		    "%s: specified editor (%s) doesn't exist!\n",
		    Argv[0], UserEditor);
d283 1
a283 2
	    (void) fprintf(stderr, "%s: unable to stat editor (%s): %s\n",
		Argv[0], UserEditor, strerror(errno));
d331 1
a331 2
	    (void) fprintf(stderr, "%s: no editor found (editor path = %s)\n",
		Argv[0], def_str(I_EDITOR));
d367 2
a368 3
		(void) fprintf(stderr,
		    "%s: Can't stat temporary file (%s), %s unchanged.\n",
		    Argv[0], stmp, sudoers);
d372 2
a373 3
		(void) fprintf(stderr,
		    "%s: Zero length temporary file (%s), %s unchanged.\n",
		    Argv[0], stmp, sudoers);
d384 2
a385 3
		(void) fprintf(stderr,
		    "%s: Can't re-open temporary file (%s), %s unchanged.\n",
		    Argv[0], stmp, sudoers);
d402 2
a403 3
		(void) fprintf(stderr,
		    "%s: Failed to parse temporary file (%s), unknown error.\n",
		    Argv[0], stmp);
d408 1
a408 3
	    (void) fprintf(stderr,
		"%s: Editor (%s) failed, %s unchanged.\n", Argv[0],
		    Editor, sudoers);
d432 1
a432 1
	(void) fprintf(stderr, "%s: sudoers file unchanged.\n", Argv[0]);
d441 2
a442 3
	(void) fprintf(stderr,
	    "%s: Unable to set (uid, gid) of %s to (%d, %d): %s\n",
	    Argv[0], stmp, SUDOERS_UID, SUDOERS_GID, strerror(errno));
d446 1
a446 3
	(void) fprintf(stderr,
	    "%s: Unable to change mode of %s to %o: %s\n",
	    Argv[0], stmp, SUDOERS_MODE, strerror(errno));
d457 2
a458 3
	    (void) fprintf(stderr,
	      "%s: %s and %s not on the same filesystem, using mv to rename.\n",
	      Argv[0], stmp, sudoers);
d471 2
a472 3
		(void) fprintf(stderr,
			       "%s: Command failed: '%s %s %s', %s unchanged.\n",
			       Argv[0], _PATH_MV, stmp, sudoers, sudoers);
d476 1
a476 2
	    (void) fprintf(stderr, "%s: Error renaming %s, %s unchanged: %s\n",
				   Argv[0], stmp, sudoers, strerror(errno));
d611 1
a611 2
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
d617 1
a617 2
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
d641 1
a641 2
	    (void) fprintf(stderr, "%s: unable to open %s: %s\n", Argv[0],
		sudoers, strerror(errno));
d648 1
a648 3
	    (void) fprintf(stderr,
		"%s: failed to parse %s file, unknown error.\n",
		Argv[0], sudoers);
d676 1
a676 1
	write(STDERR_FILENO, Argv[0], strlen(Argv[0]));
d687 1
a687 1
	Argv[0]);
@


1.12
log
@update to sudo 1.6.5p1, sigh
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d76 1
a76 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.146 2002/01/17 15:35:54 millert Exp $";
d234 6
d246 2
d251 1
a251 1
	    yyrestart(yyin);
d401 1
a401 4
	    if (parse_error)
		yyin = freopen(stmp, "r", yyin);
	    else
		yyin = fopen(stmp, "r");
d409 5
d419 2
a420 1
	    /* Parse the sudoers file */
d427 1
a446 1
	    yyrestart(yyin);	/* reset lexer */
@


1.11
log
@Update to sudo 1.6.4
@
text
@d76 1
a76 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.145 2001/12/14 19:52:48 millert Exp $";
d280 1
a280 1
    Editor = NULL;
a320 1
	free(EditorPath);
d328 2
@


1.10
log
@Change 2 Exit() -> exit()
Avoid stdio in Exit() and call _exit() if we are a signal handler.
We no longer print the signal number but the user can just check the
exit value for that.
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d41 5
d48 6
a53 1
#include <stdlib.h>
d55 7
a64 9
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
#include <malloc.h>
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
a70 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
a74 12
#ifndef STDC_HEADERS
#ifndef __GNUC__	/* gcc has its own malloc */
extern char *malloc	__P((size_t));
#endif /* __GNUC__ */
extern char *getenv	__P((const char *));
extern int stat		__P((const char *, struct stat *));
#endif /* !STDC_HEADERS */

#if defined(POSIX_SIGNALS) && !defined(SA_RESETHAND)
#define SA_RESETHAND    0
#endif /* POSIX_SIGNALS && !SA_RESETHAND */

d76 1
a76 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.126 2000/03/23 04:38:22 millert Exp $";
d86 2
d102 5
a116 1

d124 4
d131 1
d146 21
a166 8
    while (--argc) {
	if (!strcmp(argv[argc], "-V")) {
	    (void) printf("visudo version %s\n", version);
	    exit(0);
	} else if (!strcmp(argv[argc], "-s")) {
	    pedantic++;			/* strict mode */
	} else {
	    usage();
d169 4
d185 3
d250 4
a253 2
     * If we are allowing EDITOR and VISUAL envariables set Editor
     * base on whichever exists...
d255 88
a342 3
    if (!def_flag(I_ENV_EDITOR) ||
	(!(Editor = getenv("EDITOR")) && !(Editor = getenv("VISUAL"))))
	Editor = estrdup(def_str(I_EDITOR));
d348 15
d364 4
a367 1
	 * Build up a buffer to execute
a368 11
	if (strlen(Editor) + strlen(stmp) + 30 > sizeof(buf)) {
	    (void) fprintf(stderr, "%s: Buffer too short (line %d).\n",
			   Argv[0], __LINE__);
	    Exit(-1);
	}
	if (parse_error == TRUE)
	    (void) sprintf(buf, "%s +%d %s", Editor, errorlineno, stmp);
	else
	    (void) sprintf(buf, "%s %s", Editor, stmp);

	/* Do the edit -- some SYSV editors exit with 1 instead of 0 */
d370 1
a370 2
	n = system(buf);
	if (n != -1 && ((n >> 8) == 0 || (n >> 8) == 1)) {
d417 2
a418 2
		"%s: Editor (%s) failed with exit status %d, %s unchanged.\n",
		Argv[0], Editor, n, sudoers);
a470 2
	    char *tmpbuf;

d475 8
a482 9
	    /* Allocate just enough space for tmpbuf */
	    n = sizeof(char) * (strlen(_PATH_MV) + strlen(stmp) +
		  strlen(sudoers) + 4);
	    if ((tmpbuf = (char *) malloc(n)) == NULL) {
		(void) fprintf(stderr,
			      "%s: Cannot alocate memory, %s unchanged: %s\n",
			      Argv[0], sudoers, strerror(errno));
		Exit(-1);
	    }
d484 2
a485 3
	    /* Build up command and execute it */
	    (void) sprintf(tmpbuf, "%s %s %s", _PATH_MV, stmp, sudoers);
	    if (system(tmpbuf)) {
d487 2
a488 2
			       "%s: Command failed: '%s', %s unchanged.\n",
			       Argv[0], tmpbuf, sudoers);
a490 1
	    free(tmpbuf);
d549 12
d599 1
a599 3
#ifdef POSIX_SIGNALS
	struct sigaction action;		/* POSIX signal structure */
#endif /* POSIX_SIGNALS */
d604 39
a642 8
#ifdef POSIX_SIGNALS
	(void) memset((VOID *)&action, 0, sizeof(action));
	action.sa_handler = Exit;
	action.sa_flags = SA_RESETHAND;
	(void) sigaction(SIGTERM, &action, NULL);
	(void) sigaction(SIGHUP, &action, NULL);
	(void) sigaction(SIGINT, &action, NULL);
	(void) sigaction(SIGQUIT, &action, NULL);
d644 38
a681 5
	(void) signal(SIGTERM, Exit);
	(void) signal(SIGHUP, Exit);
	(void) signal(SIGINT, Exit);
	(void) signal(SIGQUIT, Exit);
#endif /* POSIX_SIGNALS */
d708 2
a709 1
    (void) fprintf(stderr, "usage: %s [-s] [-V]\n", Argv[0]);
@


1.9
log
@mark remaining signal races which are difficult to fix, and fix a few partially
@
text
@d173 1
a173 1
	Exit(-1);
d187 1
a187 1
	Exit(-1);
d502 1
a502 1
 * A positive parameter is considered to be a signal and is reported.
d508 2
d512 6
a517 4
    if (sig > 0)	/* XXX signal race */
	(void) fprintf(stderr, "%s exiting, caught signal %d.\n", Argv[0], sig);

    exit(-sig);		/* XXX for signal case, should be _exit() */
@


1.9.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a40 5
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/wait.h>
d43 1
a43 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
a44 7
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
d48 9
d63 4
d71 12
d84 1
a84 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.146 2002/01/17 15:35:54 millert Exp $";
a93 2
static int run_command		__P((char *, char **));
static int check_syntax		__P((int));
a107 5
extern int quiet;

/* For getopt(3) */
extern char *optarg;
extern int optind;
d118 1
a125 4
    char *UserEditor;			/* editor user wants to use */
    char *EditorPath;			/* colon-separated list of editors */
    char *av[4];			/* argument vector for run_command */
    int checkonly;			/* only check existing file? */
a128 1
    int ch;				/* getopt char */
d143 8
a150 21
    checkonly = 0;
    while ((ch = getopt(argc, argv, "Vcf:sq")) != -1) {
	switch (ch) {
	    case 'V':
		(void) printf("visudo version %s\n", version);
		exit(0);
	    case 'c':
		checkonly++;		/* check mode */
		break;
	    case 'f':
		sudoers = optarg;	/* sudoers file path */
		easprintf(&stmp, "%s.tmp", optarg);
		break;
	    case 's':
		pedantic++;		/* strict mode */
		break;
	    case 'q':
		quiet++;		/* quiet mode */
		break;
	    default:
		usage();
a152 4
    argc -= optind;
    argv += optind;
    if (argc)
	usage();
a164 3
    if (checkonly)
	exit(check_syntax(quiet));

d173 1
a173 1
	exit(1);
d187 1
a187 1
	exit(1);
d227 2
a228 29
     * Check EDITOR and VISUAL environment variables to see which editor
     * the user wants to use (we may not end up using it though).
     * If the path is not fully-qualified, make it so and check that
     * the specified executable actually exists.
     */
    if ((UserEditor = getenv("EDITOR")) == NULL || *UserEditor == '\0')
	UserEditor = getenv("VISUAL");
    if (UserEditor && *UserEditor == '\0')
	UserEditor = NULL;
    else if (UserEditor) {
	if (find_path(UserEditor, &Editor, getenv("PATH")) == FOUND) {
	    UserEditor = Editor;
	} else {
	    if (def_flag(I_ENV_EDITOR)) {
		/* If we are honoring $EDITOR this is a fatal error. */
		(void) fprintf(stderr,
		    "%s: specified editor (%s) doesn't exist!\n",
		    Argv[0], UserEditor);
		Exit(-1);
	    } else {
		/* Otherwise, just ignore $EDITOR. */
		UserEditor = NULL;
	    }
	}
    }

    /*
     * See if we can use the user's choice of editors either because
     * we allow any $EDITOR or because $EDITOR is in the allowable list.
d230 3
a232 42
    Editor = EditorPath = NULL;
    if (def_flag(I_ENV_EDITOR) && UserEditor)
	Editor = UserEditor;
    else if (UserEditor) {
	struct stat editor_sb;
	struct stat user_editor_sb;
	char *base, *userbase;

	if (stat(UserEditor, &user_editor_sb) != 0) {
	    /* Should never happen since we already checked above. */
	    (void) fprintf(stderr, "%s: unable to stat editor (%s): %s\n",
		Argv[0], UserEditor, strerror(errno));
	    Exit(-1);
	}
	EditorPath = estrdup(def_str(I_EDITOR));
	Editor = strtok(EditorPath, ":");
	do {
	    /*
	     * Both Editor and UserEditor should be fully qualified but
	     * check anyway...
	     */
	    if ((base = strrchr(Editor, '/')) == NULL)
		continue;
	    if ((userbase = strrchr(UserEditor, '/')) == NULL) {
		Editor = NULL;
		break;
	    }
	    base++, userbase++;

	    /*
	     * We compare the basenames first and then use stat to match
	     * for sure.
	     */
	    if (strcmp(base, userbase) == 0) {
		if (stat(Editor, &editor_sb) == 0 && S_ISREG(editor_sb.st_mode)
		    && (editor_sb.st_mode & 0000111) &&
		    editor_sb.st_dev == user_editor_sb.st_dev &&
		    editor_sb.st_ino == user_editor_sb.st_ino)
		    break;
	    }
	} while ((Editor = strtok(NULL, ":")));
    }
d235 1
a235 2
     * Can't use $EDITOR, try each element of I_EDITOR until we
     * find one that exists, is regular, and is executable.
d237 7
a243 14
    if (Editor == NULL || *Editor == '\0') {
	if (EditorPath != NULL)
	    free(EditorPath);
	EditorPath = estrdup(def_str(I_EDITOR));
	Editor = strtok(EditorPath, ":");
	do {
	    if (sudo_goodpath(Editor))
		break;
	} while ((Editor = strtok(NULL, ":")));

	/* Bleah, none of the editors existed! */
	if (Editor == NULL || *Editor == '\0') {
	    (void) fprintf(stderr, "%s: no editor found (editor path = %s)\n",
		Argv[0], def_str(I_EDITOR));
d246 2
a247 11
    }

    /*
     * Edit the temp file and parse it (for sanity checking)
     */
    do {
	char linestr[64];

	/* Build up argument vector for the command */
	if ((av[0] = strrchr(Editor, '/')) != NULL)
	    av[0]++;
d249 1
a249 8
	    av[0] = Editor;
	n = 1;
	if (parse_error == TRUE) {
	    (void) snprintf(linestr, sizeof(linestr), "+%d", errorlineno);
	    av[n++] = linestr;
	}
	av[n++] = stmp;
	av[n++] = NULL;
d251 1
a251 6
	/*
	 * Do the edit:
	 *  We cannot check the editor's exit value against 0 since
	 *  XPG4 specifies that vi's exit value is a function of the
	 *  number of errors during editing (?!?!).
	 */
d253 2
a254 1
	if (run_command(Editor, av) != -1) {
d301 2
a302 2
		"%s: Editor (%s) failed, %s unchanged.\n", Argv[0],
		    Editor, sudoers);
d355 2
d361 9
a369 8
	    /* Build up argument vector for the command */
	    if ((av[0] = strrchr(_PATH_MV, '/')) != NULL)
		av[0]++;
	    else
		av[0] = _PATH_MV;
	    av[1] = stmp;
	    av[2] = sudoers;
	    av[3] = NULL;
d371 3
a373 2
	    /* And run it... */
	    if (run_command(_PATH_MV, av)) {
d375 2
a376 2
			       "%s: Command failed: '%s %s %s', %s unchanged.\n",
			       Argv[0], _PATH_MV, stmp, sudoers, sudoers);
d379 1
a437 12
int
user_is_exempt()
{
    return(TRUE);
}

void
init_envtables()
{
    return;
}

d476 3
a478 1
	sigaction_t sa;
d483 8
a490 39
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = Exit;
	(void) sigaction(SIGTERM, &sa, NULL);
	(void) sigaction(SIGHUP, &sa, NULL);
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
}

static int
run_command(path, argv)
    char *path;
    char **argv;
{
    int status;
    pid_t pid;
    sigset_t set, oset;

    (void) sigemptyset(&set);
    (void) sigaddset(&set, SIGCHLD);
    (void) sigprocmask(SIG_BLOCK, &set, &oset);

    switch (pid = fork()) {
	case -1:
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
	    Exit(-1);
	    break;	/* NOTREACHED */
	case 0:
	    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
	    execv(path, argv);
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
	    _exit(127);
	    break;	/* NOTREACHED */
    }

#ifdef sudo_waitpid
    pid = sudo_waitpid(pid, &status, 0);
d492 5
a496 38
    pid = wait(&status);
#endif

    (void) sigprocmask(SIG_SETMASK, &oset, NULL);

    /* XXX - should use WEXITSTATUS() */
    return(pid == -1 ? -1 : (status >> 8));
}

static int
check_syntax(quiet)
    int quiet;
{

    if ((yyin = fopen(sudoers, "r")) == NULL) {
	if (!quiet)
	    (void) fprintf(stderr, "%s: unable to open %s: %s\n", Argv[0],
		sudoers, strerror(errno));
	exit(1);
    }
    yyout = stdout;
    init_parser();
    if (yyparse() && parse_error != TRUE) {
	if (!quiet)
	    (void) fprintf(stderr,
		"%s: failed to parse %s file, unknown error.\n",
		Argv[0], sudoers);
	parse_error = TRUE;
    }
    if (!quiet){
	if (parse_error)
	    (void) printf("parse error in %s near line %d\n", sudoers,
		errorlineno);
	else
	    (void) printf("%s file parsed OK\n", sudoers);
    }

    return(parse_error == TRUE);
d502 1
a502 1
 * A positive parameter indicates we were called as a signal handler.
d508 1
a508 1
    char *emsg = " exiting due to signal.\n";
d510 2
a511 1
    (void) unlink(stmp);
d513 1
a513 6
    if (sig > 0) {
	write(STDERR_FILENO, Argv[0], strlen(Argv[0]));
	write(STDERR_FILENO, emsg, sizeof(emsg) - 1);
	_exit(-sig);
    }
    exit(-sig);
d519 1
a519 2
    (void) fprintf(stderr, "usage: %s [-c] [-f sudoers] [-q] [-s] [-V]\n",
	Argv[0]);
@


1.9.4.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a40 5
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/wait.h>
d43 1
a43 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
a44 7
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
d48 9
d63 4
d71 12
d84 1
a84 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.146 2002/01/17 15:35:54 millert Exp $";
a93 2
static int run_command		__P((char *, char **));
static int check_syntax		__P((int));
a107 5
extern int quiet;

/* For getopt(3) */
extern char *optarg;
extern int optind;
d118 1
a125 4
    char *UserEditor;			/* editor user wants to use */
    char *EditorPath;			/* colon-separated list of editors */
    char *av[4];			/* argument vector for run_command */
    int checkonly;			/* only check existing file? */
a128 1
    int ch;				/* getopt char */
d143 8
a150 21
    checkonly = 0;
    while ((ch = getopt(argc, argv, "Vcf:sq")) != -1) {
	switch (ch) {
	    case 'V':
		(void) printf("visudo version %s\n", version);
		exit(0);
	    case 'c':
		checkonly++;		/* check mode */
		break;
	    case 'f':
		sudoers = optarg;	/* sudoers file path */
		easprintf(&stmp, "%s.tmp", optarg);
		break;
	    case 's':
		pedantic++;		/* strict mode */
		break;
	    case 'q':
		quiet++;		/* quiet mode */
		break;
	    default:
		usage();
a152 4
    argc -= optind;
    argv += optind;
    if (argc)
	usage();
a164 3
    if (checkonly)
	exit(check_syntax(quiet));

d173 1
a173 1
	exit(1);
d187 1
a187 1
	exit(1);
d227 2
a228 29
     * Check EDITOR and VISUAL environment variables to see which editor
     * the user wants to use (we may not end up using it though).
     * If the path is not fully-qualified, make it so and check that
     * the specified executable actually exists.
     */
    if ((UserEditor = getenv("EDITOR")) == NULL || *UserEditor == '\0')
	UserEditor = getenv("VISUAL");
    if (UserEditor && *UserEditor == '\0')
	UserEditor = NULL;
    else if (UserEditor) {
	if (find_path(UserEditor, &Editor, getenv("PATH")) == FOUND) {
	    UserEditor = Editor;
	} else {
	    if (def_flag(I_ENV_EDITOR)) {
		/* If we are honoring $EDITOR this is a fatal error. */
		(void) fprintf(stderr,
		    "%s: specified editor (%s) doesn't exist!\n",
		    Argv[0], UserEditor);
		Exit(-1);
	    } else {
		/* Otherwise, just ignore $EDITOR. */
		UserEditor = NULL;
	    }
	}
    }

    /*
     * See if we can use the user's choice of editors either because
     * we allow any $EDITOR or because $EDITOR is in the allowable list.
d230 3
a232 42
    Editor = EditorPath = NULL;
    if (def_flag(I_ENV_EDITOR) && UserEditor)
	Editor = UserEditor;
    else if (UserEditor) {
	struct stat editor_sb;
	struct stat user_editor_sb;
	char *base, *userbase;

	if (stat(UserEditor, &user_editor_sb) != 0) {
	    /* Should never happen since we already checked above. */
	    (void) fprintf(stderr, "%s: unable to stat editor (%s): %s\n",
		Argv[0], UserEditor, strerror(errno));
	    Exit(-1);
	}
	EditorPath = estrdup(def_str(I_EDITOR));
	Editor = strtok(EditorPath, ":");
	do {
	    /*
	     * Both Editor and UserEditor should be fully qualified but
	     * check anyway...
	     */
	    if ((base = strrchr(Editor, '/')) == NULL)
		continue;
	    if ((userbase = strrchr(UserEditor, '/')) == NULL) {
		Editor = NULL;
		break;
	    }
	    base++, userbase++;

	    /*
	     * We compare the basenames first and then use stat to match
	     * for sure.
	     */
	    if (strcmp(base, userbase) == 0) {
		if (stat(Editor, &editor_sb) == 0 && S_ISREG(editor_sb.st_mode)
		    && (editor_sb.st_mode & 0000111) &&
		    editor_sb.st_dev == user_editor_sb.st_dev &&
		    editor_sb.st_ino == user_editor_sb.st_ino)
		    break;
	    }
	} while ((Editor = strtok(NULL, ":")));
    }
d235 1
a235 2
     * Can't use $EDITOR, try each element of I_EDITOR until we
     * find one that exists, is regular, and is executable.
d237 7
a243 14
    if (Editor == NULL || *Editor == '\0') {
	if (EditorPath != NULL)
	    free(EditorPath);
	EditorPath = estrdup(def_str(I_EDITOR));
	Editor = strtok(EditorPath, ":");
	do {
	    if (sudo_goodpath(Editor))
		break;
	} while ((Editor = strtok(NULL, ":")));

	/* Bleah, none of the editors existed! */
	if (Editor == NULL || *Editor == '\0') {
	    (void) fprintf(stderr, "%s: no editor found (editor path = %s)\n",
		Argv[0], def_str(I_EDITOR));
d246 2
a247 11
    }

    /*
     * Edit the temp file and parse it (for sanity checking)
     */
    do {
	char linestr[64];

	/* Build up argument vector for the command */
	if ((av[0] = strrchr(Editor, '/')) != NULL)
	    av[0]++;
d249 1
a249 8
	    av[0] = Editor;
	n = 1;
	if (parse_error == TRUE) {
	    (void) snprintf(linestr, sizeof(linestr), "+%d", errorlineno);
	    av[n++] = linestr;
	}
	av[n++] = stmp;
	av[n++] = NULL;
d251 1
a251 6
	/*
	 * Do the edit:
	 *  We cannot check the editor's exit value against 0 since
	 *  XPG4 specifies that vi's exit value is a function of the
	 *  number of errors during editing (?!?!).
	 */
d253 2
a254 1
	if (run_command(Editor, av) != -1) {
d301 2
a302 2
		"%s: Editor (%s) failed, %s unchanged.\n", Argv[0],
		    Editor, sudoers);
d355 2
d361 9
a369 8
	    /* Build up argument vector for the command */
	    if ((av[0] = strrchr(_PATH_MV, '/')) != NULL)
		av[0]++;
	    else
		av[0] = _PATH_MV;
	    av[1] = stmp;
	    av[2] = sudoers;
	    av[3] = NULL;
d371 3
a373 2
	    /* And run it... */
	    if (run_command(_PATH_MV, av)) {
d375 2
a376 2
			       "%s: Command failed: '%s %s %s', %s unchanged.\n",
			       Argv[0], _PATH_MV, stmp, sudoers, sudoers);
d379 1
a437 12
int
user_is_exempt()
{
    return(TRUE);
}

void
init_envtables()
{
    return;
}

d476 3
a478 1
	sigaction_t sa;
d483 8
a490 39
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = Exit;
	(void) sigaction(SIGTERM, &sa, NULL);
	(void) sigaction(SIGHUP, &sa, NULL);
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
}

static int
run_command(path, argv)
    char *path;
    char **argv;
{
    int status;
    pid_t pid;
    sigset_t set, oset;

    (void) sigemptyset(&set);
    (void) sigaddset(&set, SIGCHLD);
    (void) sigprocmask(SIG_BLOCK, &set, &oset);

    switch (pid = fork()) {
	case -1:
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
	    Exit(-1);
	    break;	/* NOTREACHED */
	case 0:
	    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
	    execv(path, argv);
	    (void) fprintf(stderr,
		"%s: unable to run %s: %s\n", Argv[0], path, strerror(errno));
	    _exit(127);
	    break;	/* NOTREACHED */
    }

#ifdef sudo_waitpid
    pid = sudo_waitpid(pid, &status, 0);
d492 5
a496 38
    pid = wait(&status);
#endif

    (void) sigprocmask(SIG_SETMASK, &oset, NULL);

    /* XXX - should use WEXITSTATUS() */
    return(pid == -1 ? -1 : (status >> 8));
}

static int
check_syntax(quiet)
    int quiet;
{

    if ((yyin = fopen(sudoers, "r")) == NULL) {
	if (!quiet)
	    (void) fprintf(stderr, "%s: unable to open %s: %s\n", Argv[0],
		sudoers, strerror(errno));
	exit(1);
    }
    yyout = stdout;
    init_parser();
    if (yyparse() && parse_error != TRUE) {
	if (!quiet)
	    (void) fprintf(stderr,
		"%s: failed to parse %s file, unknown error.\n",
		Argv[0], sudoers);
	parse_error = TRUE;
    }
    if (!quiet){
	if (parse_error)
	    (void) printf("parse error in %s near line %d\n", sudoers,
		errorlineno);
	else
	    (void) printf("%s file parsed OK\n", sudoers);
    }

    return(parse_error == TRUE);
d502 1
a502 1
 * A positive parameter indicates we were called as a signal handler.
d508 1
a508 1
    char *emsg = " exiting due to signal.\n";
d510 2
a511 1
    (void) unlink(stmp);
d513 1
a513 6
    if (sig > 0) {
	write(STDERR_FILENO, Argv[0], strlen(Argv[0]));
	write(STDERR_FILENO, emsg, sizeof(emsg) - 1);
	_exit(-sig);
    }
    exit(-sig);
d519 1
a519 2
    (void) fprintf(stderr, "usage: %s [-c] [-f sudoers] [-q] [-s] [-V]\n",
	Argv[0]);
@


1.8
log
@If there was a syntax error and the user just wants to exit, unlink
sudoers if it is zero length since visudo probably just created it.
From the sudo cvs repo.
@
text
@d510 1
a510 1
    if (sig > 0)
d513 1
a513 1
    exit(-sig);
@


1.7
log
@'Q' means ignore parse error, not 'q'
@
text
@d313 3
a315 1
		case 'x' :	Exit(0);
@


1.6
log
@When opening /etc/sudoers for writing, use SUDOERS_MODE for the mode.
Otherwise if the user creates a new sudoers file, makes a syntax error,
and quits, sudoers will have a random file mode.  However, since it
is also zero-length, there is no information exposed.  Closes PR 1559.
@
text
@d311 1
a311 1
		case 'q' :	parse_error = FALSE;	/* ignore parse error */
@


1.5
log
@Update to sudo 1.6.3p4
@
text
@d169 1
a169 1
    sudoers_fd = open(sudoers, O_RDWR | O_CREAT);
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@a216 1
	    init_defaults();
d232 1
a232 1
	Editor = def_str(I_EDITOR);
d288 1
@


1.3
log
@sudo 1.6.2
@
text
@d84 1
a84 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.121 2000/01/19 19:07:24 millert Exp $";
d96 1
d125 1
a125 1
    char *Editor = EDITOR;		/* editor to use (default is EDITOR */
d162 2
a163 9
#ifdef ENV_EDITOR
    /*
     * If we are allowing EDITOR and VISUAL envariables set Editor
     * base on whichever exists...
     */
    if (!(Editor = getenv("EDITOR")))
	if (!(Editor = getenv("VISUAL")))
	    Editor = EDITOR;
#endif /* ENV_EDITOR */
d213 11
d228 8
d405 7
@


1.2
log
@sudo 1.6.1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d84 1
a84 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.117 1999/12/02 20:31:25 millert Exp $";
d96 1
a96 1
int netgr_matches		__P((char *, char *, char *));
d172 2
a173 1
     * Open sudoers temp file and grab a lock.
d175 5
a179 4
    stmp_fd = open(stmp, O_WRONLY | O_CREAT, 0600);
    if (stmp_fd < 0) {
	(void) fprintf(stderr, "%s: %s\n", Argv[0], strerror(errno));
	exit(1);
d181 1
a181 1
    if (!lock_file(stmp_fd, SUDO_TLOCK)) {
d186 2
a187 2
#ifdef HAVE_FTRUNCATE
    if (ftruncate(stmp_fd, 0) == -1) {
d189 1
a189 1
    if (truncate(stmp, 0) == -1) {
d191 2
a192 2
	(void) fprintf(stderr, "%s: can't truncate %s: %s\n", Argv[0],
	    stmp, strerror(errno));
d196 9
a207 11
    (void) memset(&sudoers_sb, 0, sizeof(sudoers_sb));
    if (stat(sudoers, &sudoers_sb) == -1 && errno != ENOENT) {
	(void) fprintf(stderr, "%s: %s\n", Argv[0], strerror(errno));
	Exit(-1);
    }
    sudoers_fd = open(sudoers, O_RDONLY);
    if (sudoers_fd == -1 && errno != ENOENT) {
	(void) fprintf(stderr, "%s: %s\n", Argv[0], strerror(errno));
	Exit(-1);
    }

d209 1
a209 1
    if (sudoers_fd != -1) {
d217 4
a220 4
	(void) close(sudoers_fd);
    }
    (void) close(stmp_fd);
    (void) touch(stmp, sudoers_sb.st_mtime);
d372 1
a372 1
    return(0);
d404 2
a405 2
netgr_matches(n, h, u)
    char *n, *h, *u;
d431 13
a443 7
	if (choice == 'e' || choice == 'x' || choice == 'Q')
	    break;
	else {
	    (void) puts("Options are:");
	    (void) puts("  (e)dit sudoers file again");
	    (void) puts("  e(x)it without saving changes to sudoers file");
	    (void) puts("  (Q)uit and save changes to sudoers file (DANGER!)\n");
a445 2

    return(choice);
@


1.1
log
@Initial revision
@
text
@d84 1
a84 1
static const char rcsid[] = "$Sudo: visudo.c,v 1.116 1999/11/09 20:12:20 millert Exp $";
d408 6
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
