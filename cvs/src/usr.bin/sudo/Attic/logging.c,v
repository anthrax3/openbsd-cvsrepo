head	1.25;
access;
symbols
	OPENBSD_5_7:1.24.0.18
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.22
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.20
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.16
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.14
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.12
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.10
	OPENBSD_5_0:1.24.0.8
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.24;
commitid	8ra5qnWqy2bUhcZn;

1.24
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2010.02.13.14.20.14;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.31.16.44.03;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.03.15.09.47;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.15.14.22.39;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.11.20.50.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.09.20.09.10;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.28.18.55.30;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.20.02.06.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.17.01.03.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.14.00.11.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.23.21.45.03;	author millert;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.02.19.15.13.42;	author millert;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.03.27.03.44.38;	author millert;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.2.2.1
date	2001.02.26.16.13.35;	author jason;	state Exp;
branches;
next	;

1.2.4.1
date	2001.02.23.17.10.48;	author jason;	state Exp;
branches;
next	;

1.3.2.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1994-1996, 1998-2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#ifdef __TANDEM
# include <floss.h>
#endif

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <grp.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>

#include "sudo.h"

static void do_syslog		__P((int, char *));
static void do_logfile		__P((char *));
static void send_mail		__P((char *));
static int should_mail		__P((int));
static char *get_timestr	__P((void));
static void mysyslog		__P((int, const char *, ...));
static char *new_logline	__P((const char *, int));

#define MAXSYSLOGTRIES	16	/* num of retries for broken syslogs */

/*
 * We do an openlog(3)/closelog(3) for each message because some
 * authentication methods (notably PAM) use syslog(3) for their
 * own nefarious purposes and may call openlog(3) and closelog(3).
 * Note that because we don't want to assume that all systems have
 * vsyslog(3) (HP-UX doesn't) "%m" will not be expanded.
 * Sadly this is a maze of #ifdefs.
 */
static void
#ifdef __STDC__
mysyslog(int pri, const char *fmt, ...)
#else
mysyslog(pri, fmt, va_alist)
    int pri;
    const char *fmt;
    va_dcl
#endif
{
#ifdef BROKEN_SYSLOG
    int i;
#endif
    char buf[MAXSYSLOGLEN+1];
    va_list ap;

#ifdef __STDC__
    va_start(ap, fmt);
#else
    va_start(ap);
#endif
#ifdef LOG_NFACILITIES
    openlog("sudo", 0, def_syslog);
#else
    openlog("sudo", 0);
#endif
    vsnprintf(buf, sizeof(buf), fmt, ap);
#ifdef BROKEN_SYSLOG
    /*
     * Some versions of syslog(3) don't guarantee success and return
     * an int (notably HP-UX < 10.0).  So, if at first we don't succeed,
     * try, try again...
     */
    for (i = 0; i < MAXSYSLOGTRIES; i++)
	if (syslog(pri, "%s", buf) == 0)
	    break;
#else
    syslog(pri, "%s", buf);
#endif /* BROKEN_SYSLOG */
    va_end(ap);
    closelog();
}

#define FMT_FIRST "%8s : %s"
#define FMT_CONTD "%8s : (command continued) %s"

/*
 * Log a message to syslog, pre-pending the username and splitting the
 * message into parts if it is longer than MAXSYSLOGLEN.
 */
static void
do_syslog(pri, msg)
    int pri;
    char *msg;
{
    size_t len, maxlen;
    char *p, *tmp, save;
    const char *fmt;

    /*
     * Log the full line, breaking into multiple syslog(3) calls if necessary
     */
    fmt = FMT_FIRST;
    maxlen = MAXSYSLOGLEN - (sizeof(FMT_FIRST) - 6 + strlen(user_name));
    for (p = msg; *p != '\0'; ) {
	len = strlen(p);
	if (len > maxlen) {
	    /*
	     * Break up the line into what will fit on one syslog(3) line
	     * Try to avoid breaking words into several lines if possible.
	     */
	    tmp = memrchr(p, ' ', maxlen);
	    if (tmp == NULL)
		tmp = p + maxlen;

	    /* NULL terminate line, but save the char to restore later */
	    save = *tmp;
	    *tmp = '\0';

	    mysyslog(pri, fmt, user_name, p);

	    *tmp = save;			/* restore saved character */

	    /* Advance p and eliminate leading whitespace */
	    for (p = tmp; *p == ' '; p++)
		;
	} else {
	    mysyslog(pri, fmt, user_name, p);
	    p += len;
	}
	fmt = FMT_CONTD;
	maxlen = MAXSYSLOGLEN - (sizeof(FMT_CONTD) - 6 + strlen(user_name));
    }
}

static void
do_logfile(msg)
    char *msg;
{
    char *full_line;
    char *beg, *oldend, *end;
    FILE *fp;
    mode_t oldmask;
    size_t maxlen;

    oldmask = umask(077);
    maxlen = def_loglinelen > 0 ? def_loglinelen : 0;
    fp = fopen(def_logfile, "a");
    (void) umask(oldmask);
    if (fp == NULL) {
	easprintf(&full_line, "Can't open log file: %s: %s",
	    def_logfile, strerror(errno));
	send_mail(full_line);
	efree(full_line);
    } else if (!lock_file(fileno(fp), SUDO_LOCK)) {
	easprintf(&full_line, "Can't lock log file: %s: %s",
	    def_logfile, strerror(errno));
	send_mail(full_line);
	efree(full_line);
    } else {
	if (def_loglinelen == 0) {
	    /* Don't pretty-print long log file lines (hard to grep) */
	    if (def_log_host)
		(void) fprintf(fp, "%s : %s : HOST=%s : %s\n", get_timestr(),
		    user_name, user_shost, msg);
	    else
		(void) fprintf(fp, "%s : %s : %s\n", get_timestr(),
		    user_name, msg);
	} else {
	    if (def_log_host)
		easprintf(&full_line, "%s : %s : HOST=%s : %s", get_timestr(),
		    user_name, user_shost, msg);
	    else
		easprintf(&full_line, "%s : %s : %s", get_timestr(),
		    user_name, msg);

	    /*
	     * Print out full_line with word wrap
	     */
	    beg = end = full_line;
	    while (beg) {
		oldend = end;
		end = strchr(oldend, ' ');

		if (maxlen > 0 && end) {
		    *end = '\0';
		    if (strlen(beg) > maxlen) {
			/* too far, need to back up & print the line */

			if (beg == (char *)full_line)
			    maxlen -= 4;	/* don't indent first line */

			*end = ' ';
			if (oldend != beg) {
			    /* rewind & print */
			    end = oldend-1;
			    while (*end == ' ')
				--end;
			    *(++end) = '\0';
			    (void) fprintf(fp, "%s\n    ", beg);
			    *end = ' ';
			} else {
			    (void) fprintf(fp, "%s\n    ", beg);
			}

			/* reset beg to point to the start of the new substr */
			beg = end;
			while (*beg == ' ')
			    ++beg;
		    } else {
			/* we still have room */
			*end = ' ';
		    }

		    /* remove leading whitespace */
		    while (*end == ' ')
			++end;
		} else {
		    /* final line */
		    (void) fprintf(fp, "%s\n", beg);
		    beg = NULL;			/* exit condition */
		}
	    }
	    efree(full_line);
	}
	(void) fflush(fp);
	(void) lock_file(fileno(fp), SUDO_UNLOCK);
	(void) fclose(fp);
    }
}

/*
 * Log and mail the denial message, optionally informing the user.
 */
void
log_denial(status, inform_user)
    int status;
    int inform_user;
{
    char *message;
    char *logline;

    /* Set error message. */
    if (ISSET(status, FLAG_NO_USER))
	message = "user NOT in sudoers";
    else if (ISSET(status, FLAG_NO_HOST))
	message = "user NOT authorized on host";
    else
	message = "command not allowed";

    logline = new_logline(message, 0);

    if (should_mail(status))
	send_mail(logline);	/* send mail based on status */

    /* Inform the user if they failed to authenticate.  */
    if (inform_user) {
	if (ISSET(status, FLAG_NO_USER))
	    (void) fprintf(stderr, "%s is not in the sudoers file.  %s",
		user_name, "This incident will be reported.\n");
	else if (ISSET(status, FLAG_NO_HOST))
	    (void) fprintf(stderr, "%s is not allowed to run sudo on %s.  %s",
		user_name, user_shost, "This incident will be reported.\n");
	else if (ISSET(status, FLAG_NO_CHECK))
	    (void) fprintf(stderr, "Sorry, user %s may not run sudo on %s.\n",
		user_name, user_shost);
	else
	    (void) fprintf(stderr,
		"Sorry, user %s is not allowed to execute '%s%s%s' as %s%s%s on %s.\n",
		user_name, user_cmnd, user_args ? " " : "",
		user_args ? user_args : "",
		list_pw ? list_pw->pw_name : runas_pw ?
		runas_pw->pw_name : user_name, runas_gr ? ":" : "",
		runas_gr ? runas_gr->gr_name : "", user_host);
    }

    /*
     * Log via syslog and/or a file.
     */
    if (def_syslog)
	do_syslog(def_syslog_badpri, logline);
    if (def_logfile)
	do_logfile(logline);

    efree(logline);
}

/*
 * Log and potentially mail the allowed command.
 */
void
log_allowed(status)
    int status;
{
    char *logline;

    logline = new_logline(NULL, 0);

    if (should_mail(status))
	send_mail(logline);	/* send mail based on status */

    /*
     * Log via syslog and/or a file.
     */
    if (def_syslog)
	do_syslog(def_syslog_goodpri, logline);
    if (def_logfile)
	do_logfile(logline);

    efree(logline);
}

void
#ifdef __STDC__
log_error(int flags, const char *fmt, ...)
#else
log_error(flags, fmt, va_alist)
    int flags;
    const char *fmt;
    va_dcl
#endif
{
    int serrno = errno;
    char *message;
    char *logline;
    va_list ap;
#ifdef __STDC__
    va_start(ap, fmt);
#else
    va_start(ap);
#endif

    /* Become root if we are not already to avoid user interference */
    set_perms(PERM_ROOT|PERM_NOEXIT);

    /* Expand printf-style format + args. */
    evasprintf(&message, fmt, ap);
    va_end(ap);

    if (ISSET(flags, MSG_ONLY))
	logline = message;
    else
	logline = new_logline(message, ISSET(flags, USE_ERRNO) ? serrno : 0);

    /*
     * Tell the user.
     */
    if (!ISSET(flags, NO_STDERR)) {
	if (ISSET(flags, USE_ERRNO))
	    warning("%s", message);
	else
	    warningx("%s", message);
    }
    if (logline != message)
        efree(message);

    /*
     * Send a copy of the error via mail.
     */
    if (!ISSET(flags, NO_MAIL))
	send_mail(logline);

    /*
     * Log to syslog and/or a file.
     */
    if (def_syslog)
	do_syslog(def_syslog_badpri, logline);
    if (def_logfile)
	do_logfile(logline);

    efree(logline);

    if (!ISSET(flags, NO_EXIT)) {
	cleanup(0);
	exit(1);
    }
}

#define MAX_MAILFLAGS	63

/*
 * Send a message to MAILTO user
 */
static void
send_mail(line)
    char *line;
{
    FILE *mail;
    char *p;
    int fd, pfd[2], status;
    pid_t pid, rv;
    sigaction_t sa;
#ifndef NO_ROOT_MAILER
    static char *root_envp[] = {
	"HOME=/",
	"PATH=/usr/bin:/bin",
	"LOGNAME=root",
	"USERNAME=root",
	"USER=root",
	NULL
    };
#endif

    /* Just return if mailer is disabled. */
    if (!def_mailerpath || !def_mailto)
	return;

    /* Fork and return, child will daemonize. */
    switch (pid = fork()) {
	case -1:
	    /* Error. */
	    error(1, "cannot fork");
	    break;
	case 0:
	    /* Child. */
	    switch (pid = fork()) {
		case -1:
		    /* Error. */
		    mysyslog(LOG_ERR, "cannot fork: %m");
		    _exit(1);
		case 0:
		    /* Grandchild continues below. */
		    break;
		default:
		    /* Parent will wait for us. */
		    _exit(0);
	    }
	    break;
	default:
	    /* Parent. */
	    do {
#ifdef HAVE_WAITPID
		rv = waitpid(pid, &status, 0);
#else
		rv = wait(&status);
#endif
	    } while (rv == -1 && errno == EINTR);
	    return;
    }

    /* Daemonize - disassociate from session/tty. */
#ifdef HAVE_SETSID
    if (setsid() == -1)
      warning("setsid");
#else
    setpgrp(0, 0);
# ifdef TIOCNOTTY
    if ((fd = open(_PATH_TTY, O_RDWR, 0644)) != -1) {
	ioctl(fd, TIOCNOTTY, NULL);
	close(fd);
    }
# endif
#endif
    chdir("/");
    if ((fd = open(_PATH_DEVNULL, O_RDWR, 0644)) != -1) {
	(void) dup2(fd, STDIN_FILENO);
	(void) dup2(fd, STDOUT_FILENO);
	(void) dup2(fd, STDERR_FILENO);
    }

    /* Close password, group and other fds so we don't leak. */
    sudo_endpwent();
    sudo_endgrent();
    closefrom(STDERR_FILENO + 1);

    /* Ignore SIGPIPE in case mailer exits prematurely (or is missing). */
    zero_bytes(&sa, sizeof(sa));
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = SIG_IGN;
    (void) sigaction(SIGPIPE, &sa, NULL);

    if (pipe(pfd) == -1) {
	mysyslog(LOG_ERR, "cannot open pipe: %m");
	_exit(1);
    }

    switch (pid = fork()) {
	case -1:
	    /* Error. */
	    mysyslog(LOG_ERR, "cannot fork: %m");
	    _exit(1);
	    break;
	case 0:
	    {
		char *argv[MAX_MAILFLAGS + 1];
		char *mpath, *mflags;
		int i;

		/* Child, set stdin to output side of the pipe */
		if (pfd[0] != STDIN_FILENO) {
		    (void) dup2(pfd[0], STDIN_FILENO);
		    (void) close(pfd[0]);
		}
		(void) close(pfd[1]);

		/* Build up an argv based the mailer path and flags */
		mflags = estrdup(def_mailerflags);
		mpath = estrdup(def_mailerpath);
		if ((argv[0] = strrchr(mpath, ' ')))
		    argv[0]++;
		else
		    argv[0] = mpath;

		i = 1;
		if ((p = strtok(mflags, " \t"))) {
		    do {
			argv[i] = p;
		    } while (++i < MAX_MAILFLAGS && (p = strtok(NULL, " \t")));
		}
		argv[i] = NULL;

		/*
		 * Depending on the config, either run the mailer as root
		 * (so user cannot kill it) or as the user (for the paranoid).
		 */
#ifndef NO_ROOT_MAILER
		set_perms(PERM_ROOT|PERM_NOEXIT);
		execve(mpath, argv, root_envp);
#else
		set_perms(PERM_FULL_USER|PERM_NOEXIT);
		execv(mpath, argv);
#endif /* NO_ROOT_MAILER */
		mysyslog(LOG_ERR, "cannot execute %s: %m", mpath);
		_exit(127);
	    }
	    break;
    }

    (void) close(pfd[0]);
    mail = fdopen(pfd[1], "w");

    /* Pipes are all setup, send message. */
    (void) fprintf(mail, "To: %s\nFrom: %s\nAuto-Submitted: %s\nSubject: ",
	def_mailto, def_mailfrom ? def_mailfrom : user_name, "auto-generated");
    for (p = def_mailsub; *p; p++) {
	/* Expand escapes in the subject */
	if (*p == '%' && *(p+1) != '%') {
	    switch (*(++p)) {
		case 'h':
		    (void) fputs(user_host, mail);
		    break;
		case 'u':
		    (void) fputs(user_name, mail);
		    break;
		default:
		    p--;
		    break;
	    }
	} else
	    (void) fputc(*p, mail);
    }
    (void) fprintf(mail, "\n\n%s : %s : %s : %s\n\n", user_host,
	get_timestr(), user_name, line);
    fclose(mail);
    do {
#ifdef HAVE_WAITPID
        rv = waitpid(pid, &status, 0);
#else
        rv = wait(&status);
#endif
    } while (rv == -1 && errno == EINTR);
    _exit(0);
}

/*
 * Determine whether we should send mail based on "status" and defaults options.
 */
static int
should_mail(status)
    int status;
{

    return(def_mail_always || ISSET(status, VALIDATE_ERROR) ||
	(def_mail_no_user && ISSET(status, FLAG_NO_USER)) ||
	(def_mail_no_host && ISSET(status, FLAG_NO_HOST)) ||
	(def_mail_no_perms && !ISSET(status, VALIDATE_OK)));
}

/*
 * Return an ascii string with the current date + time
 * Uses strftime() if available, else falls back to ctime().
 */
static char *
get_timestr()
{
    char *s;
    time_t now = time((time_t) 0);
#ifdef HAVE_STRFTIME
    static char buf[128];
    struct tm *timeptr;

    timeptr = localtime(&now);
    if (def_log_year)
	s = "%h %e %T %Y";
    else
	s = "%h %e %T";

    /* strftime() does not guarantee to NUL-terminate so we must check. */
    buf[sizeof(buf) - 1] = '\0';
    if (strftime(buf, sizeof(buf), s, timeptr) && buf[sizeof(buf) - 1] == '\0')
	return(buf);

#endif /* HAVE_STRFTIME */

    s = ctime(&now) + 4;		/* skip day of the week */
    if (def_log_year)
	s[20] = '\0';			/* avoid the newline */
    else
	s[15] = '\0';			/* don't care about year */

    return(s);
}

#define	LL_TTY_STR	"TTY="
#define	LL_CWD_STR	"PWD="		/* XXX - should be CWD= */
#define	LL_USER_STR	"USER="
#define	LL_GROUP_STR	"GROUP="
#define	LL_ENV_STR	"ENV="
#define	LL_CMND_STR	"COMMAND="

/*
 * Allocate and fill in a new logline.
 */
static char *
new_logline(message, serrno)
    const char *message;
    int serrno;
{
    size_t len = 0;
    char *evstr = NULL;
    char *errstr = NULL;
    char *line;

    /*
     * Compute line length
     */
    if (message != NULL)
	len += strlen(message) + 3;
    if (serrno) {
	errstr = strerror(serrno);
	len += strlen(errstr) + 3;
    }
    len += sizeof(LL_TTY_STR) + 2 + strlen(user_tty);
    len += sizeof(LL_CWD_STR) + 2 + strlen(user_cwd);
    if (runas_pw != NULL)
	len += sizeof(LL_USER_STR) + 2 + strlen(runas_pw->pw_name);
    if (runas_gr != NULL)
	len += sizeof(LL_GROUP_STR) + 2 + strlen(runas_gr->gr_name);
    if (sudo_user.env_vars != NULL) {
	size_t evlen = 0;
	struct list_member *cur;
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next)
	    evlen += strlen(cur->value) + 1;
	evstr = emalloc(evlen);
	evstr[0] = '\0';
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next) {
	    strlcat(evstr, cur->value, evlen);
	    strlcat(evstr, " ", evlen);	/* NOTE: last one will fail */
	}
	len += sizeof(LL_ENV_STR) + 2 + evlen;
    }
    len += sizeof(LL_CMND_STR) - 1 + strlen(user_cmnd);
    if (user_args != NULL)
	len += strlen(user_args) + 1;

    /*
     * Allocate and build up the line.
     */
    line = emalloc(++len);
    line[0] = '\0';

    if (message != NULL) {
	if (strlcat(line, message, len) >= len ||
	    strlcat(line, errstr ? " : " : " ; ", len) >= len)
	    goto toobig;
    }
    if (serrno) {
	if (strlcat(line, errstr, len) >= len ||
	    strlcat(line, " ; ", len) >= len)
	    goto toobig;
    }
    if (strlcat(line, LL_TTY_STR, len) >= len ||
	strlcat(line, user_tty, len) >= len ||
	strlcat(line, " ; ", len) >= len)
	goto toobig;
    if (strlcat(line, LL_CWD_STR, len) >= len ||
	strlcat(line, user_cwd, len) >= len ||
	strlcat(line, " ; ", len) >= len)
	goto toobig;
    if (runas_pw != NULL) {
	if (strlcat(line, LL_USER_STR, len) >= len ||
	    strlcat(line, runas_pw->pw_name, len) >= len ||
	    strlcat(line, " ; ", len) >= len)
	    goto toobig;
    }
    if (runas_gr != NULL) {
	if (strlcat(line, LL_GROUP_STR, len) >= len ||
	    strlcat(line, runas_gr->gr_name, len) >= len ||
	    strlcat(line, " ; ", len) >= len)
	    goto toobig;
    }
    if (evstr != NULL) {
	if (strlcat(line, LL_ENV_STR, len) >= len ||
	    strlcat(line, evstr, len) >= len ||
	    strlcat(line, " ; ", len) >= len)
	    goto toobig;
	efree(evstr);
    }
    if (strlcat(line, LL_CMND_STR, len) >= len ||
	strlcat(line, user_cmnd, len) >= len)
	goto toobig;
    if (user_args != NULL) {
	if (strlcat(line, " ", len) >= len ||
	    strlcat(line, user_args, len) >= len)
	    goto toobig;
    }

    return (line);
toobig:
    errorx(1, "internal error: insufficient space for log line");
}
@


1.24
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@@


1.23
log
@Update to sudo 1.7.2p3
@
text
@a59 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.205 2009/05/25 12:02:41 millert Exp $";
#endif /* lint */

@


1.22
log
@Upgrade to sudo 1.7.2
@
text
@d125 3
a139 2
    const char *fmt_first = "%8s : %s";
    const char *fmt_contd = "%8s : (command continued) %s";
d144 2
a145 2
    fmt = fmt_first;
    maxlen = MAXSYSLOGLEN - (sizeof(fmt_first) - 6 + strlen(user_name));
d172 2
a173 2
	fmt = fmt_contd;
	maxlen = MAXSYSLOGLEN - (sizeof(fmt_contd) - 6 + strlen(user_name));
d395 2
a396 1
    efree(message);
d412 1
a412 2
    if (logline != message)
	efree(logline);
@


1.21
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996, 1998-2008 Todd C. Miller <Todd.Miller@@courtesan.com>
d61 1
a61 1
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.203 2008/11/09 14:13:12 millert Exp $";
d374 1
a374 1
    set_perms(PERM_ROOT);
d558 1
a558 1
		set_perms(PERM_ROOT);
d561 1
a561 1
		set_perms(PERM_FULL_USER);
@


1.20
log
@Update to sudo 1.6.9p17
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2007 Todd C. Miller <Todd.Miller@@courtesan.com>
a50 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d52 1
d61 1
a61 1
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.168.2.16 2008/06/22 20:23:57 millert Exp $";
d67 1
a67 1
static void mail_auth		__P((int, char *));
d70 1
d273 1
a273 2
 * Two main functions, log_error() to log errors and log_auth() to
 * log allow/deny messages.
d276 1
a276 1
log_auth(status, inform_user)
a279 1
    char *evstr = NULL;
a281 6
    int pri;

    if (ISSET(status, VALIDATE_OK))
	pri = def_syslog_goodpri;
    else
	pri = def_syslog_badpri;
d283 3
a285 5
    /* Set error message, if any. */
    if (ISSET(status, VALIDATE_OK))
	message = "";
    else if (ISSET(status, FLAG_NO_USER))
	message = "user NOT in sudoers ; ";
d287 1
a287 3
	message = "user NOT authorized on host ; ";
    else if (ISSET(status, VALIDATE_NOT_OK))
	message = "command not allowed ; ";
d289 1
a289 1
	message = "unknown error ; ";
d291 1
a291 15
    if (sudo_user.env_vars != NULL) {
	size_t len = 7; /* " ; ENV=" */
	struct list_member *cur;
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next)
	    len += strlen(cur->value) + 1;
	evstr = emalloc(len);
	strlcpy(evstr, " ; ENV=", len);
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next) {
	    strlcat(evstr, cur->value, len);
	    strlcat(evstr, " ", len);		/* NOTE: last one will fail */
	}
    }
    easprintf(&logline, "%sTTY=%s ; PWD=%s ; USER=%s%s ; COMMAND=%s%s%s",
	message, user_tty, user_cwd, *user_runas, evstr ? evstr : "",
	user_cmnd, user_args ? " " : "", user_args ? user_args : "");
d293 2
a294 1
    mail_auth(status, logline);		/* send mail based on status */
d297 1
a297 1
    if (inform_user && ISSET(status, VALIDATE_NOT_OK)) {
d309 1
a309 1
		"Sorry, user %s is not allowed to execute '%s%s%s' as %s on %s.\n",
d311 4
a314 1
		user_args ? user_args : "", *user_runas, user_host);
d321 26
a346 1
	do_syslog(pri, logline);
a349 1
    efree(evstr);
a365 1
    char *evstr = NULL;
a379 13
    if (sudo_user.env_vars != NULL) {
	size_t len = 7; /* " ; ENV=" */
	struct list_member *cur;
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next)
	    len += strlen(cur->value) + 1;
	evstr = emalloc(len);
	strlcpy(evstr, " ; ENV=", len);
	for (cur = sudo_user.env_vars; cur != NULL; cur = cur->next) {
	    strlcat(evstr, cur->value, len);
	    strlcat(evstr, " ", len);		/* NOTE: last one will fail */
	}
    }

d382 2
a383 24
    else if (ISSET(flags, USE_ERRNO)) {
	if (user_args) {
	    easprintf(&logline,
		"%s: %s ; TTY=%s ; PWD=%s ; USER=%s%s ; COMMAND=%s %s",
		message, strerror(serrno), user_tty, user_cwd, *user_runas,
		evstr ? evstr : "", user_cmnd, user_args);
	} else {
	    easprintf(&logline,
		"%s: %s ; TTY=%s ; PWD=%s ; USER=%s%s ; COMMAND=%s", message,
		strerror(serrno), user_tty, user_cwd, *user_runas,
		evstr ? evstr : "", user_cmnd);
	}
    } else {
	if (user_args) {
	    easprintf(&logline,
		"%s ; TTY=%s ; PWD=%s ; USER=%s%s ; COMMAND=%s %s", message,
		user_tty, user_cwd, *user_runas, evstr ? evstr : "",
		user_cmnd, user_args);
	} else {
	    easprintf(&logline,
		"%s ; TTY=%s ; PWD=%s ; USER=%s%s ; COMMAND=%s", message,
		user_tty, user_cwd, *user_runas, evstr ? evstr : "", user_cmnd);
	}
    }
d388 7
a394 4
    if (ISSET(flags, USE_ERRNO))
	warn("%s", message);
    else
	warnx("%s", message);
a409 1
    efree(message);
d413 2
a414 1
    if (!ISSET(flags, NO_EXIT))
d416 1
d451 2
a452 2
	    /* Error */
	    err(1, "cannot fork");
d455 1
a455 1
	    /* Child */
d470 1
a470 1
	    /* Parent */
d484 1
a484 1
      warn("setsid");
d501 3
a503 2
    /* Close password and other fds so we don't leak. */
    endpwent();
d507 1
d573 1
a573 1
    /* Pipes are all setup, send message via sendmail. */
d575 1
a575 1
	def_mailto, user_name, "auto-generated");
d598 1
a598 1
	rv = waitpid(pid, &status, 0);
d600 1
a600 1
	rv = wait(&status);
d607 1
a607 1
 * Send mail based on the value of "status" and compile-time options.
d609 2
a610 2
static void
mail_auth(status, line)
a611 1
    char *line;
a612 1
    int mail_mask;
d614 4
a617 16
    /* If any of these bits are set in status, we send mail. */
    if (def_mail_always)
	mail_mask =
	    VALIDATE_ERROR|VALIDATE_OK|FLAG_NO_USER|FLAG_NO_HOST|VALIDATE_NOT_OK;
    else {
	mail_mask = VALIDATE_ERROR;
	if (def_mail_no_user)
	    SET(mail_mask, FLAG_NO_USER);
	if (def_mail_no_host)
	    SET(mail_mask, FLAG_NO_HOST);
	if (def_mail_no_perms)
	    SET(mail_mask, VALIDATE_NOT_OK);
    }

    if ((status & mail_mask) != 0)
	send_mail(line);
d653 109
@


1.19
log
@update to sudo 1.6.9p9
@
text
@d30 1
d60 1
d65 1
a65 1
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.168.2.13 2007/11/25 13:07:38 millert Exp $";
d463 3
a465 3
    int pfd[2];
    pid_t pid;
    sigset_t set, oset;
d481 32
a512 3
    (void) sigemptyset(&set);
    (void) sigaddset(&set, SIGCHLD);
    (void) sigprocmask(SIG_BLOCK, &set, &oset);
d514 34
a547 2
    if (pipe(pfd) == -1)
	err(1, "cannot open pipe");
d552 2
a553 1
	    err(1, "cannot fork");
a583 3
		/* Close password file so we don't leak the fd. */
		endpwent();

d595 1
d627 8
a634 4

    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
    /* If mailer is done, wait for it now.  If not, we'll get it later.  */
    reapchild(SIGCHLD);
a662 20
}

/*
 * SIGCHLD sig handler--wait for children as they die.
 */
RETSIGTYPE
reapchild(sig)
    int sig;
{
    int status, serrno = errno;
#ifdef sudo_waitpid
    pid_t pid;

    do {
	pid = sudo_waitpid(-1, &status, WNOHANG);
    } while (pid != 0 && (pid != -1 || errno == EINTR));
#else
    (void) wait(&status);
#endif
    errno = serrno;
@


1.18
log
@Update to sudo 1.6.9p4.  Basically IPv6 support and improved man pages.
@
text
@d63 1
a63 1
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.168.2.12 2007/08/08 20:07:45 millert Exp $";
d373 2
a374 3
    /* Become root if we are not already to avoid user control */
    if (geteuid() != 0)
	set_perms(PERM_ROOT);
@


1.17
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d63 1
a63 1
__unused static const char rcsid[] = "$Sudo: logging.c,v 1.168.2.11 2007/07/24 15:52:37 millert Exp $";
d138 2
a139 2
    const char fmt_first[] = "%8s : %s";
    const char fmt_contd[] = "%8s : (command continued) %s";
@


1.16
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d25 1
a25 1
#include "config.h"
d63 1
a63 1
static const char rcsid[] = "$Sudo: logging.c,v 1.168 2004/05/17 20:08:46 millert Exp $";
d135 5
a139 4
    size_t count;
    char *p;
    char *tmp;
    char save;
d144 5
a148 3
    for (p = msg, count = 0; *p && count < strlen(msg) / MAXSYSLOGLEN + 1;
	count++) {
	if (strlen(p) > MAXSYSLOGLEN) {
d151 1
a151 1
	     * Try to break on a word boundary if possible.
d153 3
a155 4
	    for (tmp = p + MAXSYSLOGLEN; tmp > p && *tmp != ' '; tmp--)
		;
	    if (tmp <= p)
		tmp = p + MAXSYSLOGLEN;
d161 1
a161 4
	    if (count == 0)
		mysyslog(pri, "%8s : %s", user_name, p);
	    else
		mysyslog(pri, "%8s : (command continued) %s", user_name, p);
d165 2
a166 2
	    /* Eliminate leading whitespace */
	    for (p = tmp; *p != ' ' && *p !='\0'; p++)
d169 2
a170 4
	    if (count == 0)
		mysyslog(pri, "%8s : %s", user_name, p);
	    else
		mysyslog(pri, "%8s : (command continued) %s", user_name, p);
d172 2
d195 1
a195 1
	free(full_line);
d200 1
a200 1
	free(full_line);
d265 1
a265 1
	    free(full_line);
d282 1
d304 15
a318 3
    easprintf(&logline, "%sTTY=%s ; PWD=%s ; USER=%s ; COMMAND=%s%s%s",
	message, user_tty, user_cwd, *user_runas, user_cmnd,
	user_args ? " " : "", user_args ? user_args : "");
d348 2
a349 1
    free(logline);
d356 3
a358 1
log_error(va_alist)
d365 1
a369 3
    int flags;
    const char *fmt;

a370 2
    flags = va_arg(ap, int);
    fmt = va_arg(ap, const char *);
d381 14
a394 1
    if (flags & MSG_ONLY)
d396 1
a396 1
    else if (flags & USE_ERRNO) {
d399 1
a399 1
		"%s: %s ; TTY=%s ; PWD=%s ; USER=%s ; COMMAND=%s %s",
d401 1
a401 1
		user_cmnd, user_args);
d404 3
a406 2
		"%s: %s ; TTY=%s ; PWD=%s ; USER=%s ; COMMAND=%s", message,
		strerror(serrno), user_tty, user_cwd, *user_runas, user_cmnd);
d411 3
a413 2
		"%s ; TTY=%s ; PWD=%s ; USER=%s ; COMMAND=%s %s", message,
		user_tty, user_cwd, *user_runas, user_cmnd, user_args);
d416 2
a417 2
		"%s ; TTY=%s ; PWD=%s ; USER=%s ; COMMAND=%s", message,
		user_tty, user_cwd, *user_runas, user_cmnd);
d424 1
a424 1
    if (flags & USE_ERRNO)
d432 1
a432 1
    if (!(flags & NO_MAIL))
d443 1
a443 1
    free(message);
d445 1
a445 1
	free(logline);
d447 1
a447 1
    if (!(flags & NO_EXIT))
d470 1
d529 1
a529 1
		set_perms(PERM_FULL_ROOT);
d544 2
a545 3
    (void) fprintf(mail, "Auto-Submitted: auto-generated\n"
	"To: %s\nFrom: %s\nSubject: ",
	def_mailto, user_name);
d567 1
a569 1
    (void) sigprocmask(SIG_SETMASK, &oset, NULL);
@


1.15
log
@Update to sudo 1.6.8p1
@
text
@d517 2
a518 1
    (void) fprintf(mail, "To: %s\nFrom: %s\nSubject: ",
@


1.14
log
@Also exit waitpid() loop when pid == 0.  Fixes a problem where the sudo
process would spin eating up CPU until sendmail finished when it has
to send mail.
@
text
@d2 1
a2 2
 * Copyright (c) 1994-1996,1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d21 4
d63 1
a63 1
static const char rcsid[] = "$Sudo: logging.c,v 1.161 2003/04/16 00:42:10 millert Exp $";
d105 1
a105 1
    openlog("sudo", 0, def_ival(I_LOGFAC));
d160 1
a160 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d162 1
a162 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d171 1
a171 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d173 1
a173 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d189 2
a190 2
    maxlen = def_ival(I_LOGLINELEN) > 0 ? def_ival(I_LOGLINELEN) : 0;
    fp = fopen(def_str(I_LOGFILE), "a");
d194 1
a194 1
	    def_str(I_LOGFILE), strerror(errno));
d199 1
a199 1
	    def_str(I_LOGFILE), strerror(errno));
d203 1
a203 1
	if (def_ival(I_LOGLINELEN) == 0) {
d205 1
a205 1
	    if (def_flag(I_LOG_HOST))
d212 1
a212 1
	    if (def_flag(I_LOG_HOST))
d287 2
a288 2
    if (status & VALIDATE_OK)
	pri = def_ival(I_GOODPRI);
d290 1
a290 1
	pri = def_ival(I_BADPRI);
d293 1
a293 1
    if (status & VALIDATE_OK)
d295 1
a295 1
    else if (status & FLAG_NO_USER)
d297 1
a297 1
    else if (status & FLAG_NO_HOST)
d299 1
a299 1
    else if (status & VALIDATE_NOT_OK)
d311 2
a312 2
    if (inform_user && (status & VALIDATE_NOT_OK)) {
	if (status & FLAG_NO_USER)
d315 1
a315 1
	else if (status & FLAG_NO_HOST)
d318 1
a318 1
	else if (status & FLAG_NO_CHECK)
d331 1
a331 1
    if (def_str(I_SYSLOG))
d333 1
a333 1
    if (def_str(I_LOGFILE))
d412 3
a414 3
    if (def_str(I_SYSLOG))
	do_syslog(def_ival(I_BADPRI), logline);
    if (def_str(I_LOGFILE))
d450 1
a450 1
    if (!def_str(I_MAILERPATH) || !def_str(I_MAILTO))
d479 2
a480 2
		mflags = estrdup(def_str(I_MAILERFLAGS));
		mpath = estrdup(def_str(I_MAILERPATH));
d518 2
a519 2
	def_str(I_MAILTO), user_name);
    for (p = def_str(I_MAILSUB); *p; p++) {
d556 1
a556 1
    if (def_flag(I_MAIL_ALWAYS))
d561 6
a566 6
	if (def_flag(I_MAIL_NO_USER))
	    mail_mask |= FLAG_NO_USER;
	if (def_flag(I_MAIL_NO_HOST))
	    mail_mask |= FLAG_NO_HOST;
	if (def_flag(I_MAIL_NO_PERMS))
	    mail_mask |= VALIDATE_NOT_OK;
d607 1
a607 1
    if (def_flag(I_LOG_YEAR))
d620 1
a620 1
    if (def_flag(I_LOG_YEAR))
@


1.13
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d595 2
d598 3
a600 3
#ifdef sudo_waitpid
    while (sudo_waitpid(-1, &status, WNOHANG) != -1 || errno == EINTR)
	;
@


1.12
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d33 4
d77 1
a77 1
static const char rcsid[] = "$Sudo: logging.c,v 1.160 2003/04/02 18:25:19 millert Exp $";
@


1.11
log
@g/c unused variable
@
text
@d60 5
d73 1
a73 1
static const char rcsid[] = "$Sudo: logging.c,v 1.159 2003/03/24 21:09:27 millert Exp $";
d115 1
a115 1
    openlog(Argv[0], 0, def_ival(I_LOGFAC));
d117 1
a117 1
    openlog(Argv[0], 0);
a407 1
    (void) fprintf(stderr, "%s: %s", Argv[0], message);
d409 3
a411 2
	(void) fprintf(stderr, ": %s", strerror(serrno));
    (void) fputc('\n', stderr);
d467 2
a468 5
    if (pipe(pfd) == -1) {
	(void) fprintf(stderr, "%s: cannot open pipe: %s\n",
	    Argv[0], strerror(errno));
	exit(1);
    }
d473 1
a473 3
	    (void) fprintf(stderr, "%s: cannot fork: %s\n",
		Argv[0], strerror(errno));
	    exit(1);
@


1.10
log
@Fix boolean thinko in SIGCHLD reaper and call reapchild after sending
mail instead of doing a conditional sudo_waitpid.
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.158 2003/03/20 02:04:32 millert Exp $";
d441 1
a441 1
    int pfd[2], status;
@


1.9
log
@update to what will soon be sudo 1.6.7
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.157 2003/03/15 20:31:02 millert Exp $";
d550 2
a551 4
    /* If mailer is done, wait for it now.  If not reapchild will get it.  */
#ifdef sudo_waitpid
    (void) sudo_waitpid(pid, &status, WNOHANG);
#endif
d593 1
a593 1
    while (sudo_waitpid(-1, &status, WNOHANG) != -1 && errno == EINTR)
@


1.8
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.153 2002/01/16 21:28:25 millert Exp $";
d140 1
a140 1
    int count;
d191 1
a191 1
    int maxlen = def_ival(I_LOGLINELEN);
d194 1
d369 1
a369 1
	set_perms(PERM_ROOT, 0);
d512 1
a512 1
		set_perms(PERM_FULL_ROOT, 0);
d515 1
a515 1
		set_perms(PERM_FULL_USER, 0);
@


1.7
log
@update to sudo 1.6.5
@
text
@d440 2
a441 1
    int pfd[2], pid, status;
@


1.6
log
@sync with sudo 1.6.4-final
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.152 2002/01/13 18:27:25 millert Exp $";
d442 9
d505 5
a509 1
		/* Run mailer as root so user cannot kill it. */
d511 3
d515 1
@


1.5
log
@Update to sudo 1.6.4
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.151 2001/12/14 23:33:38 millert Exp $";
d497 1
a497 1
		set_perms(PERM_ROOT, 0);
@


1.4
log
@Remove an errant ';' that caused a duplicate free().  Fix from my sudo
devel tree after prompting from Angelos who noticed this.
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 4
d43 6
a48 1
#include <stdlib.h>
d50 7
d58 1
a58 1
#include <unistd.h>
a59 6
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
a63 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>
d68 1
a68 1
static const char rcsid[] = "$Sudo: logging.c,v 1.140 2000/03/13 16:05:05 millert Exp $";
d76 1
d78 1
a78 5
#ifdef BROKEN_SYSLOG
# define MAXSYSLOGTRIES	16	/* num of retries for broken syslogs */
# define SYSLOG		syslog_wrapper

static void syslog_wrapper	__P((int, char *, char *, char *));
d81 6
a86 3
 * Some versions of syslog(3) don't guarantee success and return
 * an int (notably HP-UX < 10.0).  So, if at first we don't succeed,
 * try, try again...
d89 4
a92 1
syslog_wrapper(pri, fmt, ap)
d95 2
a96 1
    va_list ap;
d98 1
d100 3
d104 17
d122 1
a122 1
	if (vsyslog(pri, fmt, ap) == 0)
a123 1
}
d125 1
a125 1
# define SYSLOG		syslog
d127 3
d165 1
a165 1
		SYSLOG(pri, "%8.8s : %s", user_name, p);
d167 1
a167 1
		SYSLOG(pri, "%8.8s : (command continued) %s", user_name, p);
d176 1
a176 1
		SYSLOG(pri, "%8.8s : %s", user_name, p);
d178 1
a178 1
		SYSLOG(pri, "%8.8s : (command continued) %s", user_name, p);
d191 1
a191 1
    int maxlen = def_ival(I_LOGLEN);
d207 1
a207 1
	if (def_ival(I_LOGLEN) == 0) {
d335 1
a335 1
    if (def_str(I_LOGFACSTR))
d416 1
a416 1
    if (def_str(I_LOGFACSTR))
d421 3
a423 3
    free(logline);
    if (message != logline)
	free(message);
a440 1
#ifdef POSIX_SIGNALS
a441 3
#else
    int omask;
#endif /* POSIX_SIGNALS */
a446 1
#ifdef POSIX_SIGNALS
a449 3
#else
    omask = sigblock(sigmask(SIGCHLD));
#endif /* POSIX_SIGNALS */
d470 5
a474 1
		/* Child. */
a475 2
		(void) dup2(pfd[0], STDIN_FILENO);
		(void) close(pfd[0]);
d493 3
d504 1
a505 1
    (void) close(pfd[0]);
a534 1
#ifdef POSIX_SIGNALS
a535 3
#else
    (void) sigsetmask(omask);
#endif /* POSIX_SIGNALS */
d554 1
a554 1
	if (def_flag(I_MAIL_NOUSER))
d556 1
a556 1
	if (def_flag(I_MAIL_NOHOST))
d558 1
a558 1
	if (def_flag(I_MAIL_NOPERMS))
a580 3
#ifndef POSIX_SIGNALS
    (void) signal(SIGCHLD, reapchild);
#endif /* POSIX_SIGNALS */
@


1.4.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 3
a49 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d54 4
d62 1
a62 1
static const char rcsid[] = "$Sudo: logging.c,v 1.153 2002/01/16 21:28:25 millert Exp $";
a69 1
static void mysyslog		__P((int, const char *, ...));
d71 5
a75 1
#define MAXSYSLOGTRIES	16	/* num of retries for broken syslogs */
d78 3
a80 6
 * We do an openlog(3)/closelog(3) for each message because some
 * authentication methods (notably PAM) use syslog(3) for their
 * own nefarious purposes and may call openlog(3) and closelog(3).
 * Note that because we don't want to assume that all systems have
 * vsyslog(3) (HP-UX doesn't) "%m" will not be expanded.
 * Sadly this is a maze of #ifdefs.
d83 1
a83 4
#ifdef __STDC__
mysyslog(int pri, const char *fmt, ...)
#else
mysyslog(pri, fmt, va_alist)
d86 1
a86 2
    va_dcl
#endif
a87 1
#ifdef BROKEN_SYSLOG
a88 3
#endif
    char buf[MAXSYSLOGLEN+1];
    va_list ap;
a89 17
#ifdef __STDC__
    va_start(ap, fmt);
#else
    va_start(ap);
#endif
#ifdef LOG_NFACILITIES
    openlog(Argv[0], 0, def_ival(I_LOGFAC));
#else
    openlog(Argv[0], 0);
#endif
    vsnprintf(buf, sizeof(buf), fmt, ap);
#ifdef BROKEN_SYSLOG
    /*
     * Some versions of syslog(3) don't guarantee success and return
     * an int (notably HP-UX < 10.0).  So, if at first we don't succeed,
     * try, try again...
     */
d91 1
a91 1
	if (syslog(pri, "%s", buf) == 0)
d93 1
d95 1
a95 1
    syslog(pri, "%s", buf);
a96 3
    va_end(ap);
    closelog();
}
d132 1
a132 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d134 1
a134 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d143 1
a143 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d145 1
a145 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d158 1
a158 1
    int maxlen = def_ival(I_LOGLINELEN);
d174 1
a174 1
	if (def_ival(I_LOGLINELEN) == 0) {
d302 1
a302 1
    if (def_str(I_SYSLOG))
d383 1
a383 1
    if (def_str(I_SYSLOG))
d388 3
a390 3
    free(message);
    if (logline != message)
	free(logline);
d408 1
d410 3
a412 9
#ifndef NO_ROOT_MAILER
    static char *root_envp[] = {
	"HOME=/",
	"PATH=/usr/bin:/bin",
	"LOGNAME=root",
	"USER=root",
	NULL
    };
#endif
d418 1
d422 3
d445 1
a445 5
		/* Child, set stdin to output side of the pipe */
		if (pfd[0] != STDIN_FILENO) {
		    (void) dup2(pfd[0], STDIN_FILENO);
		    (void) close(pfd[0]);
		}
d447 2
d466 2
a467 12
		/* Close password file so we don't leak the fd. */
		endpwent();

		/*
		 * Depending on the config, either run the mailer as root
		 * (so user cannot kill it) or as the user (for the paranoid).
		 */
#ifndef NO_ROOT_MAILER
		set_perms(PERM_FULL_ROOT, 0);
		execve(mpath, argv, root_envp);
#else
		set_perms(PERM_FULL_USER, 0);
a468 1
#endif /* NO_ROOT_MAILER */
d474 1
a475 1
    mail = fdopen(pfd[1], "w");
d505 1
d507 3
d528 1
a528 1
	if (def_flag(I_MAIL_NO_USER))
d530 1
a530 1
	if (def_flag(I_MAIL_NO_HOST))
d532 1
a532 1
	if (def_flag(I_MAIL_NO_PERMS))
d555 3
@


1.3
log
@Update to sudo-1.6.3p6
@
text
@d389 1
a389 1
    if (message != logline);
@


1.3.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 3
a49 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d54 4
d62 1
a62 1
static const char rcsid[] = "$Sudo: logging.c,v 1.153 2002/01/16 21:28:25 millert Exp $";
a69 1
static void mysyslog		__P((int, const char *, ...));
d71 5
a75 1
#define MAXSYSLOGTRIES	16	/* num of retries for broken syslogs */
d78 3
a80 6
 * We do an openlog(3)/closelog(3) for each message because some
 * authentication methods (notably PAM) use syslog(3) for their
 * own nefarious purposes and may call openlog(3) and closelog(3).
 * Note that because we don't want to assume that all systems have
 * vsyslog(3) (HP-UX doesn't) "%m" will not be expanded.
 * Sadly this is a maze of #ifdefs.
d83 1
a83 4
#ifdef __STDC__
mysyslog(int pri, const char *fmt, ...)
#else
mysyslog(pri, fmt, va_alist)
d86 1
a86 2
    va_dcl
#endif
a87 1
#ifdef BROKEN_SYSLOG
a88 3
#endif
    char buf[MAXSYSLOGLEN+1];
    va_list ap;
a89 17
#ifdef __STDC__
    va_start(ap, fmt);
#else
    va_start(ap);
#endif
#ifdef LOG_NFACILITIES
    openlog(Argv[0], 0, def_ival(I_LOGFAC));
#else
    openlog(Argv[0], 0);
#endif
    vsnprintf(buf, sizeof(buf), fmt, ap);
#ifdef BROKEN_SYSLOG
    /*
     * Some versions of syslog(3) don't guarantee success and return
     * an int (notably HP-UX < 10.0).  So, if at first we don't succeed,
     * try, try again...
     */
d91 1
a91 1
	if (syslog(pri, "%s", buf) == 0)
d93 1
d95 1
a95 1
    syslog(pri, "%s", buf);
a96 3
    va_end(ap);
    closelog();
}
d132 1
a132 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d134 1
a134 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d143 1
a143 1
		mysyslog(pri, "%8.8s : %s", user_name, p);
d145 1
a145 1
		mysyslog(pri, "%8.8s : (command continued) %s", user_name, p);
d158 1
a158 1
    int maxlen = def_ival(I_LOGLINELEN);
d174 1
a174 1
	if (def_ival(I_LOGLINELEN) == 0) {
d302 1
a302 1
    if (def_str(I_SYSLOG))
d383 1
a383 1
    if (def_str(I_SYSLOG))
d388 3
a390 3
    free(message);
    if (logline != message)
	free(logline);
d408 1
d410 3
a412 9
#ifndef NO_ROOT_MAILER
    static char *root_envp[] = {
	"HOME=/",
	"PATH=/usr/bin:/bin",
	"LOGNAME=root",
	"USER=root",
	NULL
    };
#endif
d418 1
d422 3
d445 1
a445 5
		/* Child, set stdin to output side of the pipe */
		if (pfd[0] != STDIN_FILENO) {
		    (void) dup2(pfd[0], STDIN_FILENO);
		    (void) close(pfd[0]);
		}
d447 2
d466 2
a467 12
		/* Close password file so we don't leak the fd. */
		endpwent();

		/*
		 * Depending on the config, either run the mailer as root
		 * (so user cannot kill it) or as the user (for the paranoid).
		 */
#ifndef NO_ROOT_MAILER
		set_perms(PERM_FULL_ROOT, 0);
		execve(mpath, argv, root_envp);
#else
		set_perms(PERM_FULL_USER, 0);
a468 1
#endif /* NO_ROOT_MAILER */
d474 1
a475 1
    mail = fdopen(pfd[1], "w");
d505 1
d507 3
d528 1
a528 1
	if (def_flag(I_MAIL_NO_USER))
d530 1
a530 1
	if (def_flag(I_MAIL_NO_HOST))
d532 1
a532 1
	if (def_flag(I_MAIL_NO_PERMS))
d555 3
@


1.2
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d115 2
a116 1
    for (p = msg, count = 0; count < strlen(msg) / MAXSYSLOGLEN + 1; count++) {
d139 1
a139 1
	    for (p = tmp; *p != ' '; p++)
@


1.2.2.1
log
@Pull in patch from current:
Errata (039), Fix(millert):
Update to sudo-1.6.3p6
@
text
@d115 1
a115 2
    for (p = msg, count = 0; *p && count < strlen(msg) / MAXSYSLOGLEN + 1;
	count++) {
d138 1
a138 1
	    for (p = tmp; *p != ' ' && *p !='\0'; p++)
@


1.2.4.1
log
@Pull in patch from current:
Fix (millert):
Update to sudo-1.6.3p6
@
text
@d115 1
a115 2
    for (p = msg, count = 0; *p && count < strlen(msg) / MAXSYSLOGLEN + 1;
	count++) {
d138 1
a138 1
	    for (p = tmp; *p != ' ' && *p !='\0'; p++)
@


1.1
log
@Initial revision
@
text
@d62 1
a62 1
static const char rcsid[] = "$Sudo: logging.c,v 1.139 1999/10/09 05:01:48 millert Exp $";
d406 6
a411 1
    int pfd[2], pid;
d417 7
a423 1
    if ((pid = fork()) > 0) {	/* Child. */
d425 5
a429 2
	/* We do an explicit wait() later on... */
	(void) signal(SIGCHLD, SIG_IGN);
d431 4
a434 2
	if (pipe(pfd) == -1) {
	    (void) fprintf(stderr, "%s: cannot open pipe: %s\n",
d437 27
a463 1
	}
d465 7
a471 35
	switch (pid = fork()) {
	    case -1:
		/* Error. */
		/* XXX - parent will continue, return an exit val to
		   let parent know and abort? */
		(void) fprintf(stderr, "%s: cannot fork: %s\n",
		    Argv[0], strerror(errno));
		exit(1);
		break;
	    case 0:
		{
		    char *argv[MAX_MAILFLAGS + 1];
		    char *mpath, *mflags;
		    int i;

		    /* Grandchild. */
		    (void) close(pfd[1]);
		    (void) dup2(pfd[0], STDIN_FILENO);
		    (void) close(pfd[0]);

		    /* Build up an argv based the mailer path and flags */
		    mflags = estrdup(def_str(I_MAILERFLAGS));
		    mpath = estrdup(def_str(I_MAILERPATH));
		    if ((argv[0] = strrchr(mpath, ' ')))
			argv[0]++;
		    else
			argv[0] = mpath;

		    i = 1;
		    if ((p = strtok(mflags, " \t"))) {
			do {
			    argv[i] = p;
			} while (++i < MAX_MAILFLAGS && (p = strtok(NULL, " \t")));
		    }
		    argv[i] = NULL;
d473 2
a474 7
		    /* Run mailer as root so user cannot kill it. */
		    set_perms(PERM_ROOT, 0);
		    execv(mpath, argv);
		    _exit(127);
		}
		break;
	}
d476 23
a498 2
	mail = fdopen(pfd[1], "w");
	(void) close(pfd[0]);
d500 9
a508 33
	/* Pipes are all setup, send message via sendmail. */
	(void) fprintf(mail, "To: %s\nFrom: %s\nSubject: ",
	    def_str(I_MAILTO), user_name);
	for (p = def_str(I_MAILSUB); *p; p++) {
	    /* Expand escapes in the subject */
	    if (*p == '%' && *(p+1) != '%') {
		switch (*(++p)) {
		    case 'h':
			(void) fputs(user_host, mail);
			break;
		    case 'u':
			(void) fputs(user_name, mail);
			break;
		    default:
			p--;
			break;
		}
	    } else
		(void) fputc(*p, mail);
	}
	(void) fprintf(mail, "\n\n%s : %s : %s : %s\n\n", user_host,
	    get_timestr(), user_name, line);
	fclose(mail);
	reapchild(0);
	_exit(0);
    } else {
	/* Parent, just return unless there is an error. */
	if (pid == -1) {
	    (void) fprintf(stderr, "%s: cannot fork: %s\n",
		Argv[0], strerror(errno));
	    exit(1);
	}
    }
d549 1
a549 1
    while (sudo_waitpid(-1, &status, WNOHANG) != -1)
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
