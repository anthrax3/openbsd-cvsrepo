head	1.22;
access;
symbols
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.11.0.8
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.6
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@# @;


1.22
date	2008.11.14.11.58.08;	author millert;	state dead;
branches;
next	1.21;

1.21
date	2008.07.31.16.44.03;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.21.19.44.29;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.03.15.09.47;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.02.19.16.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.25.16.08.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.10.19.40.49;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.05.23.55.57;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.02.15.19.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.15.14.22.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.19.22.00.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.25.15.49.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.10.58.07;	author mpech;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.03.27.03.44.38;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2000.01.24.04.22.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.4.6.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;

1.9.6.1
date	2005.06.21.00.10.23;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2005.06.21.00.17.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@%{
/*
 * Copyright (c) 1996, 1998-2004, 2007
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * XXX - the whole opFOO naming thing is somewhat bogus.
 *
 * XXX - the way things are stored for printmatches is stupid,
 *       they should be stored as elements in an array and then
 *       list_matches() can format things the way it wants.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#if defined(YYBISON) && defined(HAVE_ALLOCA_H) && !defined(__GNUC__)
# include <alloca.h>
#endif /* YYBISON && HAVE_ALLOCA_H && !__GNUC__ */
#ifdef HAVE_LSEARCH
# include <search.h>
#endif /* HAVE_LSEARCH */
#include <limits.h>

#include "sudo.h"
#include "parse.h"

#ifndef HAVE_LSEARCH
#include "emul/search.h"
#endif /* HAVE_LSEARCH */

#ifndef lint
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.13 2008/02/27 20:34:42 millert Exp $";
#endif /* lint */

/*
 * We must define SIZE_MAX for yacc's skeleton.c.
 * If there is no SIZE_MAX or SIZE_T_MAX we have to assume that size_t
 * could be signed (as it is on SunOS 4.x).
 */
#ifndef SIZE_MAX
# ifdef SIZE_T_MAX
#  define SIZE_MAX	SIZE_T_MAX
# else
#  define SIZE_MAX	INT_MAX
# endif /* SIZE_T_MAX */
#endif /* SIZE_MAX */

/*
 * Globals
 */
extern int sudolineno, parse_error;
int errorlineno = -1;
int clearaliases = TRUE;
int printmatches = FALSE;
int pedantic = FALSE;
int keepall = FALSE;
int quiet = FALSE;
int used_runas = FALSE;

/*
 * Alias types
 */
#define HOST_ALIAS		 1
#define CMND_ALIAS		 2
#define USER_ALIAS		 3
#define RUNAS_ALIAS		 4

#define SETMATCH(_var, _val)	do { \
	if ((_var) == UNSPEC || (_val) != NOMATCH) \
	    (_var) = (_val); \
} while (0)

#define SETNMATCH(_var, _val)	do { \
	if ((_val) != NOMATCH) \
	    (_var) = ! (_val); \
	else if ((_var) == UNSPEC) \
	    (_var) = NOMATCH; \
} while (0)

#define	SETENV_RESET \
	if (setenv_ok == IMPLIED) setenv_ok = def_setenv ? TRUE : UNSPEC

/*
 * The matching stack, initial space allocated in init_parser().
 */
struct matchstack *match;
int top = 0, stacksize = 0;

#define push \
    do { \
	if (top >= stacksize) { \
	    while ((stacksize += STACKINCREMENT) < top); \
	    match = (struct matchstack *) erealloc3(match, stacksize, sizeof(struct matchstack)); \
	} \
	match[top].user   = UNSPEC; \
	match[top].cmnd   = UNSPEC; \
	match[top].host   = UNSPEC; \
	match[top].runas  = UNSPEC; \
	match[top].nopass = def_authenticate ? UNSPEC : TRUE; \
	match[top].noexec = def_noexec ? TRUE : UNSPEC; \
	match[top].setenv = def_setenv ? TRUE : UNSPEC; \
	match[top].role = NULL; \
	match[top].type = NULL; \
	top++; \
    } while (0)

#define pushcp \
    do { \
	if (top >= stacksize) { \
	    while ((stacksize += STACKINCREMENT) < top); \
	    match = (struct matchstack *) erealloc3(match, stacksize, sizeof(struct matchstack)); \
	} \
	match[top].user   = match[top-1].user; \
	match[top].cmnd   = match[top-1].cmnd; \
	match[top].host   = match[top-1].host; \
	match[top].runas  = match[top-1].runas; \
	match[top].nopass = match[top-1].nopass; \
	match[top].noexec = match[top-1].noexec; \
	match[top].setenv = match[top-1].setenv; \
	match[top].role   = estrdup(match[top-1].role); \
	match[top].type   = estrdup(match[top-1].type); \
	top++; \
    } while (0)

#define pop \
    do { \
	if (top == 0) \
	    yyerror("matching stack underflow"); \
	else { \
	    efree(match[top-1].role); \
	    efree(match[top-1].type); \
	    top--; \
	} \
    } while (0)


/*
 * For testing if foo_matches variable was set to TRUE or FALSE
 */
#define	MATCHED(_v)	((_v) >= 0)

/*
 * Shortcuts for append()
 */
#define append_cmnd(s, p) append(s, &cm_list[cm_list_len].cmnd, \
	&cm_list[cm_list_len].cmnd_len, &cm_list[cm_list_len].cmnd_size, p)

#define append_runas(s, p) append(s, &cm_list[cm_list_len].runas, \
	&cm_list[cm_list_len].runas_len, &cm_list[cm_list_len].runas_size, p)

#define append_role(s, p) append(s, &cm_list[cm_list_len].role, \
	&cm_list[cm_list_len].role_len, &cm_list[cm_list_len].role_size, p)

#define append_type(s, p) append(s, &cm_list[cm_list_len].type, \
	&cm_list[cm_list_len].type_len, &cm_list[cm_list_len].type_size, p)

#define append_entries(s, p) append(s, &ga_list[ga_list_len-1].entries, \
	&ga_list[ga_list_len-1].entries_len, \
	&ga_list[ga_list_len-1].entries_size, p)

/*
 * The stack for printmatches.  A list of allowed commands for the user.
 */
static struct command_match *cm_list = NULL;
static size_t cm_list_len = 0, cm_list_size = 0;

/*
 * List of Cmnd_Aliases and expansions for `sudo -l'
 */
static int in_alias = FALSE;
static size_t ga_list_len = 0, ga_list_size = 0;
static struct generic_alias *ga_list = NULL;

/*
 * Does this Defaults list pertain to this user?
 */
static int defaults_matches = FALSE;

/*
 * Local protoypes
 */
static int  add_alias		__P((char *, int, int));
static void append		__P((char *, char **, size_t *, size_t *, char *));
static void expand_ga_list	__P((void));
static void expand_match_list	__P((void));
static aliasinfo *find_alias	__P((char *, int));
static void more_aliases	__P((void));
       void init_parser		__P((void));
       void yyerror		__P((char *));

void
yyerror(s)
    char *s;
{
    /* Save the line the first error occurred on. */
    if (errorlineno == -1)
	errorlineno = sudolineno ? sudolineno - 1 : 0;
    if (s && !quiet) {
#ifndef TRACELEXER
	(void) fprintf(stderr, ">>> sudoers file: %s, line %d <<<\n", s,
	    sudolineno ? sudolineno - 1 : 0);
#else
	(void) fprintf(stderr, "<*> ");
#endif
    }
    parse_error = TRUE;
}
%}

%union {
    char *string;
    int BOOLEAN;
    struct sudo_command command;
    int tok;
    struct selinux_info seinfo;
}

%start file				/* special start symbol */
%token <command> COMMAND		/* absolute pathname w/ optional args */
%token <string>  ALIAS			/* an UPPERCASE alias name */
%token <string>	 DEFVAR			/* a Defaults variable name */
%token <string>  NTWKADDR		/* w.x.y.z or ipv6 address */
%token <string>  NETGROUP		/* a netgroup (+NAME) */
%token <string>  USERGROUP		/* a usergroup (%NAME) */
%token <string>  WORD			/* a word */
%token <tok>	 DEFAULTS		/* Defaults entry */
%token <tok>	 DEFAULTS_HOST		/* Host-specific defaults entry */
%token <tok>	 DEFAULTS_USER		/* User-specific defaults entry */
%token <tok>	 DEFAULTS_RUNAS		/* Runas-specific defaults entry */
%token <tok> 	 RUNAS			/* ( runas_list ) */
%token <tok> 	 NOPASSWD		/* no passwd req for command */
%token <tok> 	 PASSWD			/* passwd req for command (default) */
%token <tok> 	 NOEXEC			/* preload dummy execve() for cmnd */
%token <tok> 	 EXEC			/* don't preload dummy execve() */
%token <tok> 	 SETENV			/* user may set environment for cmnd */
%token <tok> 	 NOSETENV		/* user may not set environment */
%token <tok>	 ALL			/* ALL keyword */
%token <tok>	 COMMENT		/* comment and/or carriage return */
%token <tok>	 HOSTALIAS		/* Host_Alias keyword */
%token <tok>	 CMNDALIAS		/* Cmnd_Alias keyword */
%token <tok>	 USERALIAS		/* User_Alias keyword */
%token <tok>	 RUNASALIAS		/* Runas_Alias keyword */
%token <tok>	 ':' '=' ',' '!' '+' '-' /* union member tokens */
%token <tok>	 ERROR
%token <tok>	 TYPE			/* SELinux type */
%token <tok>	 ROLE			/* SELinux role */

/*
 * NOTE: these are not true booleans as there are actually 4 possible values:
 *        1) TRUE (positive match)
 *        0) FALSE (negative match due to a '!' somewhere)
 *       -1) NOMATCH (don't change the value of *_matches)
 *       -2) UNSPEC (uninitialized value)
 */
%type <BOOLEAN>	 cmnd
%type <BOOLEAN>	 host
%type <BOOLEAN>	 runasuser
%type <BOOLEAN>	 oprunasuser
%type <BOOLEAN>	 runaslist
%type <BOOLEAN>	 user
%type <seinfo>	 selinux
%type <string>	 rolespec
%type <string>	 typespec

%%

file		:	entry
		|	file entry
		;

entry		:	COMMENT
			    { ; }
                |       error COMMENT
			    { yyerrok; }
		|	{ push; } userlist privileges {
			    while (top && user_matches != TRUE)
				pop;
			}
		|	USERALIAS useraliases
			    { ; }
		|	HOSTALIAS hostaliases
			    { ; }
		|	CMNDALIAS cmndaliases
			    { ; }
		|	RUNASALIAS runasaliases
			    { ; }
		|	defaults_line
			    { ; }
		;

defaults_line	:	defaults_type defaults_list
		;

defaults_type	:	DEFAULTS {
			    defaults_matches = TRUE;
			}
		|	DEFAULTS_USER { push; } userlist {
			    defaults_matches = user_matches;
			    pop;
			}
		|	DEFAULTS_RUNAS { push; } runaslist {
			    defaults_matches = $3 == TRUE;
			    pop;
			}
		|	DEFAULTS_HOST { push; } hostlist {
			    defaults_matches = host_matches;
			    pop;
			}
		;

defaults_list	:	defaults_entry
		|	defaults_entry ',' defaults_list
		;

defaults_entry	:	DEFVAR {
			    if (defaults_matches == TRUE &&
				!set_default($1, NULL, TRUE)) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($1);
			}
		|	'!' DEFVAR {
			    if (defaults_matches == TRUE &&
				!set_default($2, NULL, FALSE)) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($2);
			}
		|	DEFVAR '=' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, TRUE)) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($1);
			    efree($3);
			}
		|	DEFVAR '+' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, '+')) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($1);
			    efree($3);
			}
		|	DEFVAR '-' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, '-')) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($1);
			    efree($3);
			}
		;

privileges	:	privilege
		|	privileges ':' privilege
		;

privilege	:	hostlist '=' cmndspeclist {
			    /*
			     * We already did a push if necessary in
			     * cmndspec so just reset some values so
			     * the next 'privilege' gets a clean slate.
			     */
			    host_matches = UNSPEC;
			    runas_matches = UNSPEC;
			    no_passwd = def_authenticate ? UNSPEC : TRUE;
			    no_execve = def_noexec ? TRUE : UNSPEC;
			    setenv_ok = def_setenv ? TRUE : UNSPEC;
#ifdef HAVE_SELINUX
			    efree(match[top-1].role);
			    match[top-1].role = NULL;
			    efree(match[top-1].type);
			    match[top-1].type = NULL;
#endif
			}
		;

ophost		:	host {
			    SETMATCH(host_matches, $1);
			}
		|	'!' host {
			    SETNMATCH(host_matches, $2);
			}
		;

host		:	ALL {
			    $$ = TRUE;
			}
		|	NTWKADDR {
			    if (addr_matches($1))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	NETGROUP {
			    if (netgr_matches($1, user_host, user_shost, NULL))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	WORD {
			    if (hostname_matches(user_shost, user_host, $1) == 0)
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	ALIAS {
			    aliasinfo *aip = find_alias($1, HOST_ALIAS);

			    /* could be an all-caps hostname */
			    if (aip)
				$$ = aip->val;
			    else if (strcasecmp(user_shost, $1) == 0)
				$$ = TRUE;
			    else {
				if (pedantic) {
				    (void) fprintf(stderr,
					"%s: undeclared Host_Alias `%s' referenced near line %d\n",
					(pedantic == 1) ? "Warning" : "Error", $1, sudolineno);
				    if (pedantic > 1) {
					yyerror(NULL);
					YYERROR;
				    }
				}
				$$ = NOMATCH;
			    }
			    efree($1);
			}
		;

cmndspeclist	:	cmndspec
		|	cmndspeclist ',' cmndspec
		;

cmndspec	:	{ SETENV_RESET; } runasspec selinux cmndtag opcmnd {
#ifdef HAVE_SELINUX
			    /* Replace inherited role/type as needed. */
			    if ($3.role != NULL) {
				efree(match[top-1].role);
				match[top-1].role = $3.role;
			    }
			    if ($3.type != NULL) {
				efree(match[top-1].type);
				match[top-1].type = $3.type;
			    }
#endif
			    /*
			     * Push the entry onto the stack if it is worth
			     * saving and reset cmnd_matches for next cmnd.
			     *
			     * We need to save at least one entry on
			     * the stack so sudoers_lookup() can tell that
			     * the user was listed in sudoers.  Also, we
			     * need to be able to tell whether or not a
			     * user was listed for this specific host.
			     *
			     * If keepall is set and the user matches then
			     * we need to keep entries around too...
			     */
			    if (MATCHED(user_matches) &&
				MATCHED(host_matches) &&
				MATCHED(cmnd_matches) &&
				MATCHED(runas_matches))
				pushcp;
			    else if (MATCHED(user_matches) && (top == 1 ||
				(top == 2 && MATCHED(host_matches) &&
				!MATCHED(match[0].host))))
				pushcp;
			    else if (user_matches == TRUE && keepall)
				pushcp;

			    cmnd_matches = UNSPEC;
			}
		;

opcmnd		:	cmnd {
			    SETMATCH(cmnd_matches, $1);
			}
		|	'!' {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries("!", ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_cmnd("!", NULL);
			    }
			} cmnd {
			    SETNMATCH(cmnd_matches, $3);
			}
		;

rolespec	:	ROLE '=' WORD {
#ifdef HAVE_SELINUX
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE && runas_matches == TRUE)
				append_role($3, NULL);
			    $$ = $3;
#else
			    free($3);
			    $$ = NULL;
#endif /* HAVE_SELINUX */
			}
		;

typespec	:	TYPE '=' WORD {
#ifdef HAVE_SELINUX
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE && runas_matches == TRUE)
				append_type($3, NULL);
			    $$ = $3;
#else
			    free($3);
			    $$ = NULL;
#endif /* HAVE_SELINUX */
			}
		;

selinux		:	/* empty */ {
#ifdef HAVE_SELINUX
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE && runas_matches == TRUE) {
				/* Inherit role. */
				cm_list[cm_list_len].role =
				    estrdup(cm_list[cm_list_len-1].role);
				cm_list[cm_list_len].role_len =
				    cm_list[cm_list_len-1].role_len;
				cm_list[cm_list_len].role_size =
				    cm_list[cm_list_len-1].role_len + 1;
				/* Inherit type. */
				cm_list[cm_list_len].type =
				    estrdup(cm_list[cm_list_len-1].type);
				cm_list[cm_list_len].type_len =
				    cm_list[cm_list_len-1].type_len;
				cm_list[cm_list_len].type_size =
				    cm_list[cm_list_len-1].type_len + 1;
			    }
#endif /* HAVE_SELINUX */
			    $$.role = NULL;
			    $$.type = NULL;
			}
		|	rolespec {
#ifdef HAVE_SELINUX
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE && runas_matches == TRUE) {
				/* Inherit type. */
				cm_list[cm_list_len].type =
				    estrdup(cm_list[cm_list_len-1].type);
				cm_list[cm_list_len].type_len =
				    cm_list[cm_list_len-1].type_len;
				cm_list[cm_list_len].type_size =
				    cm_list[cm_list_len-1].type_len + 1;
			    }
#endif /* HAVE_SELINUX */
			    $$.role = $1;
			    $$.type = NULL;
			}
		|	typespec {
#ifdef HAVE_SELINUX
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE && runas_matches == TRUE) {
				/* Inherit role. */
				cm_list[cm_list_len].role =
				    estrdup(cm_list[cm_list_len-1].role);
				cm_list[cm_list_len].role_len =
				    cm_list[cm_list_len-1].role_len;
				cm_list[cm_list_len].role_size =
				    cm_list[cm_list_len-1].role_len + 1;
			    }
#endif /* HAVE_SELINUX */
			    $$.type = $1;
			    $$.role = NULL;
			}
		|	rolespec typespec {
			    $$.role = $1;
			    $$.type = $2;
			}
		|	typespec rolespec {
			    $$.type = $1;
			    $$.role = $2;
			}
		;

runasspec	:	/* empty */ {
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE) {
				if (runas_matches == UNSPEC) {
				    cm_list[cm_list_len].runas_len = 0;
				} else {
				    /* Inherit runas data. */
				    cm_list[cm_list_len].runas =
					estrdup(cm_list[cm_list_len-1].runas);
				    cm_list[cm_list_len].runas_len =
					cm_list[cm_list_len-1].runas_len;
				    cm_list[cm_list_len].runas_size =
					cm_list[cm_list_len-1].runas_len + 1;
				}
			    }
			    /*
			     * If this is the first entry in a command list
			     * then check against default runas user.
			     */
			    if (runas_matches == UNSPEC) {
				runas_matches = userpw_matches(def_runas_default,
				    *user_runas, runas_pw) ? TRUE : NOMATCH;
			    }
			}
		|	RUNAS runaslist {
			    runas_matches = $2;
			}
		;

runaslist	:	oprunasuser { ; }
		|	runaslist ',' oprunasuser {
			    /* Later entries override earlier ones. */
			    if ($3 != NOMATCH)
				$$ = $3;
			    else
				$$ = $1;
			}
		;

oprunasuser	:	runasuser { ; }
		|	'!' {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries("!", ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas("!", ", ");
			    }
			} runasuser {
			    /* Set $$ to the negation of runasuser */
			    $$ = ($3 == NOMATCH ? NOMATCH : ! $3);
			}
		;

runasuser	:	WORD {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries($1, ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas($1, ", ");
			    }
			    if (userpw_matches($1, *user_runas, runas_pw))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			    used_runas = TRUE;
			}
		|	USERGROUP {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries($1, ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas($1, ", ");
			    }
			    if (usergr_matches($1, *user_runas, runas_pw))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			    used_runas = TRUE;
			}
		|	NETGROUP {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries($1, ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas($1, ", ");
			    }
			    if (netgr_matches($1, NULL, NULL, *user_runas))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			    used_runas = TRUE;
			}
		|	ALIAS {
			    aliasinfo *aip = find_alias($1, RUNAS_ALIAS);

			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries($1, ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas($1, ", ");
			    }
			    /* could be an all-caps username */
			    if (aip)
				$$ = aip->val;
			    else if (strcmp($1, *user_runas) == 0)
				$$ = TRUE;
			    else {
				if (pedantic) {
				    (void) fprintf(stderr,
					"%s: undeclared Runas_Alias `%s' referenced near line %d\n",
					(pedantic == 1) ? "Warning" : "Error", $1, sudolineno);
				    if (pedantic > 1) {
					yyerror(NULL);
					YYERROR;
				    }
				}
				$$ = NOMATCH;
			    }
			    efree($1);
			    used_runas = TRUE;
			}
		|	ALL {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries("ALL", ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE)
				    append_runas("ALL", ", ");
			    }
			    $$ = TRUE;
			}
		;

cmndtag		:	/* empty */ {
			    /* Inherit {NO,}{PASSWD,EXEC,SETENV} status. */
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE) {
				if (no_passwd == TRUE)
				    cm_list[cm_list_len].nopasswd = TRUE;
				else
				    cm_list[cm_list_len].nopasswd = FALSE;
				if (no_execve == TRUE)
				    cm_list[cm_list_len].noexecve = TRUE;
				else
				    cm_list[cm_list_len].noexecve = FALSE;
				if (setenv_ok == TRUE)
				    cm_list[cm_list_len].setenv = TRUE;
				else
				    cm_list[cm_list_len].setenv = FALSE;
			    }
			}
		|	cmndtag NOPASSWD {
			    no_passwd = TRUE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].nopasswd = TRUE;
			}
		|	cmndtag PASSWD {
			    no_passwd = FALSE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].nopasswd = FALSE;
			}
		|	cmndtag NOEXEC {
			    no_execve = TRUE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].noexecve = TRUE;
			}
		|	cmndtag EXEC {
			    no_execve = FALSE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].noexecve = FALSE;
			}
		|	cmndtag SETENV {
			    setenv_ok = TRUE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].setenv = TRUE;
			}
		|	cmndtag NOSETENV {
			    setenv_ok = FALSE;
			    if (printmatches == TRUE && host_matches == TRUE &&
				user_matches == TRUE)
				cm_list[cm_list_len].setenv = FALSE;
			}
		;

cmnd		:	ALL {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries("ALL", ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE) {
				    append_cmnd("ALL", NULL);
				    expand_match_list();
				}
			    }
			    /* sudo "ALL" implies the SETENV tag */
			    if (setenv_ok == UNSPEC)
				setenv_ok = IMPLIED;

			    efree(safe_cmnd);
			    safe_cmnd = NULL;
			    $$ = TRUE;
			}
		|	ALIAS {
			    aliasinfo *aip;

			    if (printmatches == TRUE) {
				if (in_alias == TRUE)
				    append_entries($1, ", ");
				else if (host_matches == TRUE &&
				    user_matches == TRUE) {
				    append_cmnd($1, NULL);
				    expand_match_list();
				}
			    }

			    if ((aip = find_alias($1, CMND_ALIAS)))
				$$ = aip->val;
			    else {
				if (pedantic) {
				    (void) fprintf(stderr,
					"%s: undeclared Cmnd_Alias `%s' referenced near line %d\n",
					(pedantic == 1) ? "Warning" : "Error", $1, sudolineno);
				    if (pedantic > 1) {
					yyerror(NULL);
					YYERROR;
				    }
				}
				$$ = NOMATCH;
			    }
			    efree($1);
			}
		|	 COMMAND {
			    if (printmatches == TRUE) {
				if (in_alias == TRUE) {
				    append_entries($1.cmnd, ", ");
				    if ($1.args)
					append_entries($1.args, " ");
				}
				if (host_matches == TRUE &&
				    user_matches == TRUE)  {
				    append_cmnd($1.cmnd, NULL);
				    if ($1.args)
					append_cmnd($1.args, " ");
				    expand_match_list();
				}
			    }

			    if (command_matches($1.cmnd, $1.args))
				$$ = TRUE;
			    else
				$$ = NOMATCH;

			    efree($1.cmnd);
			    efree($1.args);
			}
		;

hostaliases	:	hostalias
		|	hostaliases ':' hostalias
		;

hostalias	:	ALIAS { push; } '=' hostlist {
			    if ((MATCHED(host_matches) || pedantic) &&
				!add_alias($1, HOST_ALIAS, host_matches)) {
				yyerror(NULL);
				YYERROR;
			    }
			    pop;
			}
		;

hostlist	:	ophost
		|	hostlist ',' ophost
		;

cmndaliases	:	cmndalias
		|	cmndaliases ':' cmndalias
		;

cmndalias	:	ALIAS {
			    push;
			    if (printmatches == TRUE) {
				in_alias = TRUE;
				/* Allocate space for ga_list if necessary. */
				expand_ga_list();
				ga_list[ga_list_len-1].type = CMND_ALIAS;
				ga_list[ga_list_len-1].alias = estrdup($1);
			     }
			} '=' cmndlist {
			    if ((MATCHED(cmnd_matches) || pedantic) &&
				!add_alias($1, CMND_ALIAS, cmnd_matches)) {
				yyerror(NULL);
				YYERROR;
			    }
			    pop;
			    efree($1);

			    if (printmatches == TRUE)
				in_alias = FALSE;
			}
		;

cmndlist	:	opcmnd { ; }
		|	cmndlist ',' opcmnd
		;

runasaliases	:	runasalias
		|	runasaliases ':' runasalias
		;

runasalias	:	ALIAS {
			    if (printmatches == TRUE) {
				in_alias = TRUE;
				/* Allocate space for ga_list if necessary. */
				expand_ga_list();
				ga_list[ga_list_len-1].type = RUNAS_ALIAS;
				ga_list[ga_list_len-1].alias = estrdup($1);
			    }
			} '=' runaslist {
			    if (($4 != NOMATCH || pedantic) &&
				!add_alias($1, RUNAS_ALIAS, $4)) {
				yyerror(NULL);
				YYERROR;
			    }
			    efree($1);

			    if (printmatches == TRUE)
				in_alias = FALSE;
			}
		;

useraliases	:	useralias
		|	useraliases ':' useralias
		;

useralias	:	ALIAS { push; }	'=' userlist {
			    if ((MATCHED(user_matches) || pedantic) &&
				!add_alias($1, USER_ALIAS, user_matches)) {
				yyerror(NULL);
				YYERROR;
			    }
			    pop;
			    efree($1);
			}
		;

userlist	:	opuser
		|	userlist ',' opuser
		;

opuser		:	user {
			    SETMATCH(user_matches, $1);
			}
		|	'!' user {
			    SETNMATCH(user_matches, $2);
			}
		;

user		:	WORD {
			    if (userpw_matches($1, user_name, sudo_user.pw))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	USERGROUP {
			    if (usergr_matches($1, user_name, sudo_user.pw))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	NETGROUP {
			    if (netgr_matches($1, NULL, NULL, user_name))
				$$ = TRUE;
			    else
				$$ = NOMATCH;
			    efree($1);
			}
		|	ALIAS {
			    aliasinfo *aip = find_alias($1, USER_ALIAS);

			    /* could be an all-caps username */
			    if (aip)
				$$ = aip->val;
			    else if (strcmp($1, user_name) == 0)
				$$ = TRUE;
			    else {
				if (pedantic) {
				    (void) fprintf(stderr,
					"%s: undeclared User_Alias `%s' referenced near line %d\n",
					(pedantic == 1) ? "Warning" : "Error", $1, sudolineno);
				    if (pedantic > 1) {
					yyerror(NULL);
					YYERROR;
				    }
				}
				$$ = NOMATCH;
			    }
			    efree($1);
			}
		|	ALL {
			    $$ = TRUE;
			}
		;

%%

#define MOREALIASES (32)
aliasinfo *aliases = NULL;
size_t naliases = 0;
size_t nslots = 0;


/*
 * Compare two aliasinfo structures, strcmp() style.
 * Note that we do *not* compare their values.
 */
static int
aliascmp(a1, a2)
    const VOID *a1, *a2;
{
    int r;
    aliasinfo *ai1, *ai2;

    ai1 = (aliasinfo *) a1;
    ai2 = (aliasinfo *) a2;
    if ((r = strcmp(ai1->name, ai2->name)) == 0)
	r = ai1->type - ai2->type;

    return(r);
}

/*
 * Compare two generic_alias structures, strcmp() style.
 */
static int
genaliascmp(entry, key)
    const VOID *entry, *key;
{
    int r;
    struct generic_alias *ga1, *ga2;

    ga1 = (struct generic_alias *) key;
    ga2 = (struct generic_alias *) entry;
    if ((r = strcmp(ga1->alias, ga2->alias)) == 0)
	r = ga1->type - ga2->type;

    return(r);
}


/*
 * Adds the named alias of the specified type to the aliases list.
 */
static int
add_alias(alias, type, val)
    char *alias;
    int type;
    int val;
{
    aliasinfo ai, *aip;
    size_t onaliases;
    char s[512];

    if (naliases >= nslots)
	more_aliases();

    ai.type = type;
    ai.val = val;
    ai.name = estrdup(alias);
    onaliases = naliases;

    aip = (aliasinfo *) lsearch((VOID *)&ai, (VOID *)aliases, &naliases,
				sizeof(ai), aliascmp);
    if (aip == NULL) {
	(void) snprintf(s, sizeof(s), "Aliases corrupted defining alias `%s'",
			alias);
	yyerror(s);
	return(FALSE);
    }
    if (onaliases == naliases) {
	(void) snprintf(s, sizeof(s), "Alias `%s' already defined", alias);
	yyerror(s);
	return(FALSE);
    }

    return(TRUE);
}

/*
 * Searches for the named alias of the specified type.
 */
static aliasinfo *
find_alias(alias, type)
    char *alias;
    int type;
{
    aliasinfo ai;

    ai.name = alias;
    ai.type = type;

    return((aliasinfo *) lfind((VOID *)&ai, (VOID *)aliases, &naliases,
		 sizeof(ai), aliascmp));
}

/*
 * Allocates more space for the aliases list.
 */
static void
more_aliases()
{

    nslots += MOREALIASES;
    aliases = (aliasinfo *) erealloc3(aliases, nslots, sizeof(aliasinfo));
}

/*
 * Lists the contents of the aliases list.
 */
void
dumpaliases()
{
    size_t n;

    for (n = 0; n < naliases; n++) {
	if (aliases[n].val == -1)
	    continue;

	switch (aliases[n].type) {
	case HOST_ALIAS:
	    (void) puts("HOST_ALIAS");
	    break;

	case CMND_ALIAS:
	    (void) puts("CMND_ALIAS");
	    break;

	case USER_ALIAS:
	    (void) puts("USER_ALIAS");
	    break;

	case RUNAS_ALIAS:
	    (void) puts("RUNAS_ALIAS");
	    break;
	}
	(void) printf("\t%s: %d\n", aliases[n].name, aliases[n].val);
    }
}

/*
 * Lists the contents of cm_list and ga_list for `sudo -l'.
 */
void
list_matches()
{
    size_t count;
    char *p;
    struct generic_alias *ga, key;

    (void) printf("User %s may run the following commands on this host:\n",
	user_name);
    for (count = 0; count < cm_list_len; count++) {

	/* Print the runas list. */
	(void) fputs("    ", stdout);
	if (cm_list[count].runas) {
	    (void) putchar('(');
	    p = strtok(cm_list[count].runas, ", ");
	    do {
		if (p != cm_list[count].runas)
		    (void) fputs(", ", stdout);

		key.alias = p;
		key.type = RUNAS_ALIAS;
		if ((ga = (struct generic_alias *) lfind((VOID *) &key,
		    (VOID *) &ga_list[0], &ga_list_len, sizeof(key), genaliascmp)))
		    (void) fputs(ga->entries, stdout);
		else
		    (void) fputs(p, stdout);
	    } while ((p = strtok(NULL, ", ")));
	    (void) fputs(") ", stdout);
	} else {
	    (void) printf("(%s) ", def_runas_default);
	}

#ifdef HAVE_SELINUX
	/* SELinux role and type */
	if (cm_list[count].role != NULL)
	    (void) printf("ROLE=%s ", cm_list[count].role);
	if (cm_list[count].type != NULL)
	    (void) printf("TYPE=%s ", cm_list[count].type);
#endif

	/* Is execve(2) disabled? */
	if (cm_list[count].noexecve == TRUE && !def_noexec)
	    (void) fputs("NOEXEC: ", stdout);
	else if (cm_list[count].noexecve == FALSE && def_noexec)
	    (void) fputs("EXEC: ", stdout);

	/* Is a password required? */
	if (cm_list[count].nopasswd == TRUE && def_authenticate)
	    (void) fputs("NOPASSWD: ", stdout);
	else if (cm_list[count].nopasswd == FALSE && !def_authenticate)
	    (void) fputs("PASSWD: ", stdout);

	/* Is setenv enabled? */
	if (cm_list[count].setenv == TRUE && !def_setenv)
	    (void) fputs("SETENV: ", stdout);
	else if (cm_list[count].setenv == FALSE && def_setenv)
	    (void) fputs("NOSETENV: ", stdout);

	/* Print the actual command or expanded Cmnd_Alias. */
	key.alias = cm_list[count].cmnd;
	key.type = CMND_ALIAS;
	if ((ga = (struct generic_alias *) lfind((VOID *) &key,
	    (VOID *) &ga_list[0], &ga_list_len, sizeof(key), genaliascmp)))
	    (void) puts(ga->entries);
	else
	    (void) puts(cm_list[count].cmnd);
    }

    /* Be nice and free up space now that we are done. */
    for (count = 0; count < ga_list_len; count++) {
	efree(ga_list[count].alias);
	efree(ga_list[count].entries);
    }
    efree(ga_list);
    ga_list = NULL;

    for (count = 0; count < cm_list_len; count++) {
	efree(cm_list[count].runas);
	efree(cm_list[count].cmnd);
	efree(cm_list[count].role);
	efree(cm_list[count].type);
    }
    efree(cm_list);
    cm_list = NULL;
    cm_list_len = 0;
    cm_list_size = 0;
}

/*
 * Appends a source string to the destination, optionally prefixing a separator.
 */
static void
append(src, dstp, dst_len, dst_size, separator)
    char *src, **dstp;
    size_t *dst_len, *dst_size;
    char *separator;
{
    size_t src_len = strlen(src);
    char *dst = *dstp;

    /*
     * Only add the separator if there is something to separate from.
     * If the last char is a '!', don't apply the separator (XXX).
     */
    if (separator && dst && dst[*dst_len - 1] != '!')
	src_len += strlen(separator);
    else
	separator = NULL;

    /* Assumes dst will be NULL if not set. */
    if (dst == NULL) {
	dst = (char *) emalloc(BUFSIZ);
	*dst = '\0';
	*dst_size = BUFSIZ;
	*dst_len = 0;
	*dstp = dst;
    }

    /* Allocate more space if necessary. */
    if (*dst_size <= *dst_len + src_len) {
	while (*dst_size <= *dst_len + src_len)
	    *dst_size += BUFSIZ;

	dst = (char *) erealloc(dst, *dst_size);
	*dstp = dst;
    }

    /* Copy src -> dst adding a separator if appropriate and adjust len. */
    if (separator)
	(void) strlcat(dst, separator, *dst_size);
    (void) strlcat(dst, src, *dst_size);
    *dst_len += src_len;
}

/*
 * Frees up space used by the aliases list and resets the associated counters.
 */
void
reset_aliases()
{
    size_t n;

    if (aliases) {
	for (n = 0; n < naliases; n++)
	    efree(aliases[n].name);
	efree(aliases);
	aliases = NULL;
    }
    naliases = nslots = 0;
}

/*
 * Increments ga_list_len, allocating more space as necessary.
 */
static void
expand_ga_list()
{

    if (++ga_list_len >= ga_list_size) {
	while ((ga_list_size += STACKINCREMENT) < ga_list_len)
	    ;
	ga_list = (struct generic_alias *)
	    erealloc3(ga_list, ga_list_size, sizeof(struct generic_alias));
    }

    ga_list[ga_list_len - 1].entries = NULL;
}

/*
 * Increments cm_list_len, allocating more space as necessary.
 */
static void
expand_match_list()
{

    if (++cm_list_len >= cm_list_size) {
	while ((cm_list_size += STACKINCREMENT) < cm_list_len)
	    ;
	if (cm_list == NULL)
	    cm_list_len = 0;		/* start at 0 since it is a subscript */
	cm_list = (struct command_match *)
	    erealloc3(cm_list, cm_list_size, sizeof(struct command_match));
    }

    cm_list[cm_list_len].runas = cm_list[cm_list_len].cmnd = NULL;
    cm_list[cm_list_len].type = cm_list[cm_list_len].role = NULL;
    cm_list[cm_list_len].nopasswd = FALSE;
    cm_list[cm_list_len].noexecve = FALSE;
    cm_list[cm_list_len].setenv = FALSE;
}

/*
 * Frees up spaced used by a previous parser run and allocates new space
 * for various data structures.
 */
void
init_parser()
{

    /* Free up old data structures if we run the parser more than once. */
    if (match) {
	efree(match);
	match = NULL;
	top = 0;
	parse_error = FALSE;
	used_runas = FALSE;
	errorlineno = -1;
	sudolineno = 1;
    }

    /* Allocate space for the matching stack. */
    stacksize = STACKINCREMENT;
    match = (struct matchstack *) emalloc2(stacksize, sizeof(struct matchstack));

    /* Allocate space for the match list (for `sudo -l'). */
    if (printmatches == TRUE)
	expand_match_list();
}
@


1.21
log
@Update to sudo 1.6.9p17
@
text
@@


1.20
log
@update to sudo 1.6.9p12
@
text
@d73 1
a73 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.10 2008/01/16 23:20:53 millert Exp $";
d143 2
d161 2
d170 3
a172 1
	else \
d174 1
d192 6
d256 1
d286 2
d302 3
d416 6
d485 12
a496 1
cmndspec	:	{ SETENV_RESET; } runasspec cmndtag opcmnd {
d521 1
d542 91
d645 1
a645 1
					cm_list[cm_list_len-1].runas_size;
d1233 8
d1280 2
d1386 1
@


1.19
log
@update to sudo 1.6.9p9
@
text
@d63 1
d73 1
a73 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.9 2007/11/21 18:15:49 millert Exp $";
d75 13
@


1.18
log
@update to sudo 1.6.9p8
@
text
@d72 1
a72 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.8 2007/11/02 19:09:01 millert Exp $";
d107 3
d446 1
a446 1
cmndspec	:	runasspec cmndtag opcmnd {
d698 3
@


1.17
log
@Update to sudo 1.6.9p7
@
text
@d72 1
a72 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.7 2007/09/13 23:06:51 millert Exp $";
d508 2
a509 3
				runas_matches =
				    userpw_matches(def_runas_default,
					*user_runas, runas_pw);
@


1.16
log
@Use erealloc3() in more_aliases() instead of malloc/realloc.
@
text
@d72 1
a72 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.6 2007/08/13 16:30:02 millert Exp $";
@


1.15
log
@update to sudo 1.6.9p5
@
text
@a56 3
#if defined(HAVE_MALLOC_H) && !defined(STDC_HEADERS)
# include <malloc.h>
#endif /* HAVE_MALLOC_H && !STDC_HEADERS */
d198 1
a198 1
static int  more_aliases	__P((void));
d964 2
a965 6
    if (naliases >= nslots && !more_aliases()) {
	(void) snprintf(s, sizeof(s), "Out of memory defining alias `%s'",
			alias);
	yyerror(s);
	return(FALSE);
    }
d1009 1
a1009 1
static int
d1014 1
a1014 6
    if (nslots == MOREALIASES)
	aliases = (aliasinfo *) malloc(nslots * sizeof(aliasinfo));
    else
	aliases = (aliasinfo *) realloc(aliases, nslots * sizeof(aliasinfo));

    return(aliases != NULL);
@


1.14
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1022 1
a1022 1
	aliases = (aliasinfo *) calloc(nslots, sizeof(aliasinfo));
@


1.13
log
@Update to sudo 1.6.9p4.  Basically IPv6 support and improved man pages.
@
text
@d1022 1
a1022 1
	aliases = (aliasinfo *) malloc(nslots * sizeof(aliasinfo));
@


1.12
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d75 1
a75 1
__unused static const char rcsid[] = "$Sudo: parse.yacc,v 1.204.2.5 2007/07/09 21:53:01 millert Exp $";
d235 1
a235 1
%token <string>  NTWKADDR		/* w.x.y.z */
@


1.11
log
@Update to sudo 1.6.8p9
@
text
@d3 2
a4 1
 * Copyright (c) 1996, 1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d33 1
a33 1
#include "config.h"
d75 1
a75 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.204 2004/08/11 18:29:10 millert Exp $";
d128 1
d144 1
d248 2
d329 1
a329 1
			    free($1);
d337 1
a337 1
			    free($2);
d345 2
a346 2
			    free($1);
			    free($3);
d354 2
a355 2
			    free($1);
			    free($3);
d363 2
a364 2
			    free($1);
			    free($3);
d382 1
d402 1
a402 1
			    free($1);
d409 1
a409 1
			    free($1);
d416 1
a416 1
			    free($1);
d438 1
a438 1
			    free($1);
d558 1
a558 1
			    free($1);
d573 1
a573 1
			    free($1);
d588 1
a588 1
			    free($1);
d618 1
a618 1
			    free($1);
d634 1
a634 1
			    /* Inherit {NOPASSWD,PASSWD,NOEXEC,EXEC} status. */
d645 4
d675 12
d700 2
d731 1
a731 1
			    free($1);
d754 2
a755 3
			    free($1.cmnd);
			    if ($1.args)
				free($1.args);
d797 1
a797 1
			    free($1);
d826 1
a826 1
			    free($1);
d844 1
a844 1
			    free($1);
d865 1
a865 1
			    free($1);
d872 1
a872 1
			    free($1);
d879 1
a879 1
			    free($1);
d901 1
a901 1
			    free($1);
d1110 6
d1128 2
a1129 2
	free(ga_list[count].alias);
	free(ga_list[count].entries);
d1131 1
a1131 1
    free(ga_list);
d1135 2
a1136 2
	free(cm_list[count].runas);
	free(cm_list[count].cmnd);
d1138 1
a1138 1
    free(cm_list);
d1200 2
a1201 2
	    free(aliases[n].name);
	free(aliases);
d1243 1
d1256 1
a1256 1
	free(match);
@


1.10
log
@Update to sudo 1.6.8p1
@
text
@a678 4

			    if (safe_cmnd)
				free(safe_cmnd);
			    safe_cmnd = estrdup(user_cmnd);
@


1.10.2.1
log
@MFC:
Fix by millert@@

A race condition in Sudo's command pathname handling prior to
Sudo version 1.6.8p9 that could allow a user with Sudo privileges
to run arbitrary commands.

ok millert@@
@
text
@d679 4
@


1.9
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d3 1
a3 2
 * Copyright (c) 1996, 1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d5 3
a7 1
 * This code is derived from software contributed by Chris Jepeway.
d9 7
a15 26
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
d74 1
a74 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.188 2003/04/16 00:42:10 millert Exp $";
d87 1
d97 12
d121 6
a126 5
	match[top].user   = -1; \
	match[top].cmnd   = -1; \
	match[top].host   = -1; \
	match[top].runas  = -1; \
	match[top].nopass = def_flag(I_AUTHENTICATE) ? -1 : TRUE; \
d141 1
d146 1
a146 1
    { \
d151 7
a157 1
    }
d188 1
a188 1
static int defaults_matches = 0;
d243 2
d255 1
a255 1
 * NOTE: these are not true booleans as there are actually 3 possible values: 
d258 2
a259 1
 *       -1) No match (don't change the value of *_matches)
d373 4
a376 6
			    host_matches = -1;
			    runas_matches = -1;
			    if (def_flag(I_AUTHENTICATE))
				no_passwd = -1;
			    else
				no_passwd = TRUE;
d381 1
a381 2
			    if ($1 != -1)
				host_matches = $1;
d384 1
a384 2
			    if ($2 != -1)
				host_matches = ! $2;
d395 1
a395 1
				$$ = -1;
d402 1
a402 1
				$$ = -1;
d409 1
a409 1
				$$ = -1;
d430 1
a430 1
				$$ = -1;
d440 1
a440 1
cmndspec	:	runasspec nopasswd opcmnd {
d443 1
a443 1
			     * saving and clear cmnd_matches for next cmnd.
d454 4
a457 2
			    if (user_matches != -1 && host_matches != -1 &&
				cmnd_matches != -1 && runas_matches != -1)
d459 3
a461 3
			    else if (user_matches != -1 && (top == 1 ||
				(top == 2 && host_matches != -1 &&
				match[0].host == -1)))
d465 1
a465 1
			    cmnd_matches = -1;
d470 1
a470 2
			    if ($1 != -1)
				cmnd_matches = $1;
d481 1
a481 2
			    if ($3 != -1)
				cmnd_matches = ! $3;
d488 1
a488 1
				if (runas_matches == -1) {
d504 5
a508 3
			    if (runas_matches == -1)
				runas_matches = (strcmp(*user_runas,
				    def_str(I_RUNAS_DEFAULT)) == 0);
d511 1
a511 1
			    runas_matches = ($2 == TRUE ? TRUE : FALSE);
d518 1
a518 1
			    if ($3 != -1)
d536 1
a536 1
			    $$ = ($3 == -1 ? -1 : ! $3);
d548 1
a548 1
			    if (strcmp($1, *user_runas) == 0)
d551 1
a551 1
				$$ = -1;
d553 1
d563 1
a563 1
			    if (usergr_matches($1, *user_runas))
d566 1
a566 1
				$$ = -1;
d568 1
d581 1
a581 1
				$$ = -1;
d583 1
d610 1
a610 1
				$$ = -1;
d613 1
d627 2
a628 2
nopasswd	:	/* empty */ {
			    /* Inherit NOPASSWD/PASSWD status. */
d635 4
d641 1
a641 1
		|	NOPASSWD {
d647 1
a647 1
		|	PASSWD {
d653 12
d709 1
a709 1
				$$ = -1;
d729 1
a729 2
			    if (command_matches(user_cmnd, user_args,
				$1.cmnd, $1.args))
d732 1
a732 1
				$$ = -1;
d745 1
a745 1
			    if ((host_matches != -1 || pedantic) &&
d772 1
a772 1
			    if ((cmnd_matches != -1 || pedantic) &&
d802 1
a802 1
			    if (($4 != -1 || pedantic) &&
d819 1
a819 1
			    if ((user_matches != -1 || pedantic) &&
d834 1
a834 2
			    if ($1 != -1)
				user_matches = $1;
d837 1
a837 2
			    if ($2 != -1)
				user_matches = ! $2;
d842 1
a842 1
			    if (strcmp($1, user_name) == 0)
d845 1
a845 1
				$$ = -1;
d849 1
a849 1
			    if (usergr_matches($1, user_name))
d852 1
a852 1
				$$ = -1;
d859 1
a859 1
				$$ = -1;
d880 1
a880 1
				$$ = -1;
d1049 1
a1049 1
    size_t count; 
d1076 1
a1076 1
	    (void) printf("(%s) ", def_str(I_RUNAS_DEFAULT));
d1079 6
d1086 1
a1086 1
	if (cm_list[count].nopasswd == TRUE && def_flag(I_AUTHENTICATE))
d1088 1
a1088 1
	else if (cm_list[count].nopasswd == FALSE && !def_flag(I_AUTHENTICATE))
d1217 1
d1234 3
a1236 2
	errorlineno = -1;   
	sudolineno = 1;     
@


1.9.6.1
log
@MFC:
Fix by millert@@

A race condition in Sudo's command pathname handling prior to
Sudo version 1.6.8p9 that could allow a user with Sudo privileges
to run arbitrary commands.

ok millert@@
@
text
@d655 4
@


1.8
log
@update to what will soon be sudo 1.6.7
@
text
@d36 4
d92 1
a92 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.187 2003/03/15 20:31:02 millert Exp $";
@


1.7
log
@Update to sudo 1.6.6
@
text
@d3 1
a3 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d88 1
a88 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.180 2002/03/16 00:44:47 millert Exp $";
d120 1
a120 1
	    match = (struct matchstack *) erealloc(match, sizeof(struct matchstack) * stacksize); \
d134 1
a134 1
	    match = (struct matchstack *) erealloc(match, sizeof(struct matchstack) * stacksize); \
d232 1
d285 1
d294 4
d306 1
d351 1
d380 1
d530 1
d719 2
a720 1
				!add_alias($1, HOST_ALIAS, host_matches))
d722 1
d746 2
a747 1
				!add_alias($1, CMND_ALIAS, cmnd_matches))
d749 1
d776 2
a777 1
				!add_alias($1, RUNAS_ALIAS, $4))
d779 1
d793 2
a794 1
				!add_alias($1, USER_ALIAS, user_matches))
d796 1
d814 1
d850 2
a851 1
				    if (pedantic > 1)
d853 1
d1024 1
a1024 1
    int i; 
d1030 1
a1030 1
    for (i = 0; i < cm_list_len; i++) {
d1034 1
a1034 1
	if (cm_list[i].runas) {
d1036 1
a1036 1
	    p = strtok(cm_list[i].runas, ", ");
d1038 1
a1038 1
		if (p != cm_list[i].runas)
d1055 1
a1055 1
	if (cm_list[i].nopasswd == TRUE && def_flag(I_AUTHENTICATE))
d1057 1
a1057 1
	else if (cm_list[i].nopasswd == FALSE && !def_flag(I_AUTHENTICATE))
d1061 1
a1061 1
	key.alias = cm_list[i].cmnd;
d1067 1
a1067 1
	    (void) puts(cm_list[i].cmnd);
d1071 3
a1073 3
    for (i = 0; i < ga_list_len; i++) {
	free(ga_list[i].alias);
	free(ga_list[i].entries);
d1078 3
a1080 3
    for (i = 0; i < cm_list_len; i++) {
	free(cm_list[i].runas);
	free(cm_list[i].cmnd);
d1112 1
d1128 3
a1130 1
    dst += *dst_len;
a1131 4
    *dst = '\0';
    if (separator)
	(void) strcat(dst, separator);
    (void) strcat(dst, src);
d1162 1
a1162 1
	    erealloc(ga_list, sizeof(struct generic_alias) * ga_list_size);
d1181 1
a1181 1
	    erealloc(cm_list, sizeof(struct command_match) * cm_list_size);
d1208 1
a1208 1
    match = (struct matchstack *) emalloc(sizeof(struct matchstack) * stacksize);
@


1.6
log
@Update to sudo 1.6.4
@
text
@d6 1
a6 2
 * This code is derived from software contributed by Chris Jepeway
 * <jepeway@@cs.utk.edu>
d88 1
a88 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.179 2001/12/30 18:41:12 millert Exp $";
@


1.5
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok

p.s. Next commit will fix a typo in the sys/
@
text
@d3 1
a3 1
 * Copyright (c) 1996, 1998-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d48 3
d53 6
a58 1
#include <stdlib.h>
d60 7
d68 1
a68 1
#include <unistd.h>
a70 8
#include <sys/types.h>
#include <sys/param.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
d72 1
a72 1
#include <malloc.h>
d75 1
a75 1
#include <alloca.h>
d78 1
a78 1
#include <search.h>
d89 1
a89 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.173 2000/03/24 23:58:58 millert Exp $";
d101 1
d203 1
a203 1
    if (s) {
d225 1
d242 1
a242 1
%token <tok>	 ':' '=' ',' '!'	/* union member tokens */
d302 1
a302 1
defaults_entry	:	WORD {
d304 1
a304 1
				!set_default($1, NULL, 1)) {
d310 1
a310 1
		|	'!' WORD {
d312 1
a312 1
				!set_default($2, NULL, 0)) {
d318 19
a336 2
		|	WORD '=' WORD {
			    /* XXX - need to support quoted values */
d338 1
a338 1
				!set_default($1, $3, 1)) {
d492 1
a492 1
				    def_str(I_RUNAS_DEF)) == 0);
d1031 1
a1031 1
	    (void) printf("(%s) ", def_str(I_RUNAS_DEF));
@


1.5.2.1
log
@update to sudo 1.6.5p1
@
text
@d3 1
a3 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a47 3

#include <sys/types.h>
#include <sys/param.h>
d50 1
a50 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
a51 7
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
d53 1
a53 1
# include <unistd.h>
d56 8
d65 1
a65 1
# include <malloc.h>
d68 1
a68 1
# include <alloca.h>
d71 1
a71 1
# include <search.h>
d82 1
a82 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.179 2001/12/30 18:41:12 millert Exp $";
a93 1
int quiet = FALSE;
d195 1
a195 1
    if (s && !quiet) {
a216 1
%token <string>	 DEFVAR			/* a Defaults variable name */
d233 1
a233 1
%token <tok>	 ':' '=' ',' '!' '+' '-' /* union member tokens */
d293 1
a293 1
defaults_entry	:	DEFVAR {
d295 1
a295 1
				!set_default($1, NULL, TRUE)) {
d301 1
a301 1
		|	'!' DEFVAR {
d303 1
a303 1
				!set_default($2, NULL, FALSE)) {
d309 2
a310 19
		|	DEFVAR '=' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, TRUE)) {
				yyerror(NULL);
				YYERROR;
			    }
			    free($1);
			    free($3);
			}
		|	DEFVAR '+' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, '+')) {
				yyerror(NULL);
				YYERROR;
			    }
			    free($1);
			    free($3);
			}
		|	DEFVAR '-' WORD {
d312 1
a312 1
				!set_default($1, $3, '-')) {
d466 1
a466 1
				    def_str(I_RUNAS_DEFAULT)) == 0);
d1005 1
a1005 1
	    (void) printf("(%s) ", def_str(I_RUNAS_DEFAULT));
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d192 1
a192 1
    /* Save the line the first error occured on. */
@


1.4.6.1
log
@update to sudo 1.6.5p1
@
text
@d3 1
a3 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a47 3

#include <sys/types.h>
#include <sys/param.h>
d50 1
a50 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
a51 7
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
d53 1
a53 1
# include <unistd.h>
d56 8
d65 1
a65 1
# include <malloc.h>
d68 1
a68 1
# include <alloca.h>
d71 1
a71 1
# include <search.h>
d82 1
a82 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.179 2001/12/30 18:41:12 millert Exp $";
a93 1
int quiet = FALSE;
d192 1
a192 1
    /* Save the line the first error occurred on. */
d195 1
a195 1
    if (s && !quiet) {
a216 1
%token <string>	 DEFVAR			/* a Defaults variable name */
d233 1
a233 1
%token <tok>	 ':' '=' ',' '!' '+' '-' /* union member tokens */
d293 1
a293 1
defaults_entry	:	DEFVAR {
d295 1
a295 1
				!set_default($1, NULL, TRUE)) {
d301 1
a301 1
		|	'!' DEFVAR {
d303 1
a303 1
				!set_default($2, NULL, FALSE)) {
d309 2
a310 19
		|	DEFVAR '=' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, TRUE)) {
				yyerror(NULL);
				YYERROR;
			    }
			    free($1);
			    free($3);
			}
		|	DEFVAR '+' WORD {
			    if (defaults_matches == TRUE &&
				!set_default($1, $3, '+')) {
				yyerror(NULL);
				YYERROR;
			    }
			    free($1);
			    free($3);
			}
		|	DEFVAR '-' WORD {
d312 1
a312 1
				!set_default($1, $3, '-')) {
d466 1
a466 1
				    def_str(I_RUNAS_DEFAULT)) == 0);
d1005 1
a1005 1
	    (void) printf("(%s) ", def_str(I_RUNAS_DEFAULT));
@


1.3
log
@sudo 1.6.2
@
text
@d82 1
a82 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.170 2000/01/17 23:46:25 millert Exp $";
a217 1
%token <string>  FQHOST			/* foo.bar.com */
d294 2
a295 1
			    if (defaults_matches && !set_default($1, NULL, 1)) {
d302 2
a303 1
			    if (defaults_matches && !set_default($2, NULL, 0)) {
d311 2
a312 1
			    if (defaults_matches && !set_default($1, $3, 1)) {
d366 1
a366 8
			    if (strcasecmp(user_shost, $1) == 0)
				$$ = TRUE;
			    else
				$$ = -1;
			    free($1);
			}
		|	FQHOST {
			    if (strcasecmp(user_host, $1) == 0)
@


1.2
log
@sudo 1.6.1
@
text
@d3 1
a3 1
 * Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d82 1
a82 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.167 1999/12/05 19:06:09 millert Exp $";
d93 1
d357 1
a357 1
			    if (netgr_matches($1, user_host, NULL))
d415 3
d426 2
d538 1
a538 1
			    if (netgr_matches($1, NULL, *user_runas))
d792 1
a792 1
			    if (netgr_matches($1, NULL, user_name))
@


1.1
log
@Initial revision
@
text
@d82 1
a82 1
static const char rcsid[] = "$Sudo: parse.yacc,v 1.166 1999/10/07 21:20:57 millert Exp $";
d245 2
d467 3
a469 1
		|	RUNAS runaslist { ; }
d472 8
a479 2
runaslist	:	oprunasuser
		|	runaslist ',' oprunasuser
d482 1
a482 4
oprunasuser	:	runasuser {
			    if ($1 != -1)
				runas_matches = $1;
			}
d492 2
a493 2
			    if ($3 != -1)
				runas_matches = ! $3;
a726 1
			    push;
d735 2
a736 2
			    if ((runas_matches != -1 || pedantic) &&
				!add_alias($1, RUNAS_ALIAS, runas_matches))
a737 1
			    pop;
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
