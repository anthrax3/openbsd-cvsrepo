head	1.27;
access;
symbols
	OPENBSD_5_7:1.26.0.18
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.22
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.26;
commitid	8ra5qnWqy2bUhcZn;

1.26
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.13.14.20.14;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.09.14.03.06;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.08.16.50.05;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.31.16.44.03;	author millert;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2007.12.04.15.27.06;	author millert;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2007.10.25.16.08.12;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.05.23.55.57;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.15.14.22.39;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.08.02.02.10.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.25.15.49.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.08.15.44.25;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.13.21.58.52;	author millert;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2000.03.27.03.44.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.24.04.22.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.5.4.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.5.6.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;

1.18.2.1
date	2009.02.22.21.56.44;	author millert;	state Exp;
branches;
next	;

1.19.2.1
date	2009.02.22.21.56.32;	author millert;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 2004-2005, 2007-2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <ctype.h>
#include <pwd.h>
#include <grp.h>

#include "sudo.h"
#include "parse.h"
#include "lbuf.h"
#include <gram.h>

/* Characters that must be quoted in sudoers */
#define SUDOERS_QUOTED	":\\,=#\""

/* sudoers nsswitch routines */
struct sudo_nss sudo_nss_file = {
    &sudo_nss_file,
    NULL,
    sudo_file_open,
    sudo_file_close,
    sudo_file_parse,
    sudo_file_setdefs,
    sudo_file_lookup,
    sudo_file_display_cmnd,
    sudo_file_display_defaults,
    sudo_file_display_bound_defaults,
    sudo_file_display_privs
};

/*
 * Parser externs.
 */
extern FILE *yyin;
extern char *errorfile;
extern int errorlineno, parse_error;

/*
 * Local prototypes.
 */
static void print_member	__P((struct lbuf *, char *, int, int, int));
static int display_bound_defaults __P((int, struct lbuf *));

int
sudo_file_open(nss)
    struct sudo_nss *nss;
{
    if (def_ignore_local_sudoers)
	return(-1);
    nss->handle = open_sudoers(_PATH_SUDOERS, FALSE, NULL);
    return(nss->handle ? 0 : -1);
}

int
sudo_file_close(nss)
    struct sudo_nss *nss;
{
    /* Free parser data structures and close sudoers file. */
    init_parser(NULL, 0);
    if (nss->handle != NULL) {
	fclose(nss->handle);
	nss->handle = NULL;
	yyin = NULL;
    }
    return(0);
}

/*
 * Parse the specified sudoers file.
 */
int
sudo_file_parse(nss)
    struct sudo_nss *nss;
{
    if (nss->handle == NULL)
	return(-1);

    init_parser(_PATH_SUDOERS, 0);
    yyin = nss->handle;
    if (yyparse() != 0 || parse_error) {
	log_error(NO_EXIT, "parse error in %s near line %d",
	    errorfile, errorlineno);
	return(-1);
    }
    return(0);
}

/*
 * Wrapper around update_defaults() for nsswitch code.
 */
int
sudo_file_setdefs(nss)
    struct sudo_nss *nss;
{
    if (nss->handle == NULL)
	return(-1);

    if (!update_defaults(SETDEF_GENERIC|SETDEF_HOST|SETDEF_USER))
	return(-1);
    return(0);
}

/*
 * Look up the user in the parsed sudoers file and check to see if they are
 * allowed to run the specified command on this host as the target user.
 */
int
sudo_file_lookup(nss, validated, pwflag)
    struct sudo_nss *nss;
    int validated;
    int pwflag;
{
    int match, host_match, runas_match, cmnd_match;
    struct cmndspec *cs;
    struct cmndtag *tags = NULL;
    struct privilege *priv;
    struct userspec *us;

    if (nss->handle == NULL)
	return(validated);

    /*
     * Only check the actual command if pwflag is not set.
     * It is set for the "validate", "list" and "kill" pseudo-commands.
     * Always check the host and user.
     */
    if (pwflag) {
	int nopass;
	enum def_tupple pwcheck;

	pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;
	nopass = (pwcheck == all) ? TRUE : FALSE;

	if (list_pw == NULL)
	    SET(validated, FLAG_NO_CHECK);
	CLR(validated, FLAG_NO_USER);
	CLR(validated, FLAG_NO_HOST);
	match = DENY;
	tq_foreach_fwd(&userspecs, us) {
	    if (userlist_matches(sudo_user.pw, &us->users) != ALLOW)
		continue;
	    tq_foreach_fwd(&us->privileges, priv) {
		if (hostlist_matches(&priv->hostlist) != ALLOW)
		    continue;
		tq_foreach_fwd(&priv->cmndlist, cs) {
		    /* Only check the command when listing another user. */
		    if (user_uid == 0 || list_pw == NULL ||
			user_uid == list_pw->pw_uid ||
			cmnd_matches(cs->cmnd) == ALLOW)
			    match = ALLOW;
		    if ((pwcheck == any && cs->tags.nopasswd == TRUE) ||
			(pwcheck == all && cs->tags.nopasswd != TRUE))
			nopass = cs->tags.nopasswd;
		}
	    }
	}
	if (match == ALLOW || user_uid == 0) {
	    /* User has an entry for this host. */
	    SET(validated, VALIDATE_OK);
	} else if (match == DENY)
	    SET(validated, VALIDATE_NOT_OK);
	if (pwcheck == always && def_authenticate)
	    SET(validated, FLAG_CHECK_USER);
	else if (pwcheck == never || nopass == TRUE)
	    def_authenticate = FALSE;
	return(validated);
    }

    /* Need to be runas user while stat'ing things. */
    set_perms(PERM_RUNAS);

    match = UNSPEC;
    tq_foreach_rev(&userspecs, us) {
	if (userlist_matches(sudo_user.pw, &us->users) != ALLOW)
	    continue;
	CLR(validated, FLAG_NO_USER);
	tq_foreach_rev(&us->privileges, priv) {
	    host_match = hostlist_matches(&priv->hostlist);
	    if (host_match == ALLOW)
		CLR(validated, FLAG_NO_HOST);
	    else
		continue;
	    tq_foreach_rev(&priv->cmndlist, cs) {
		runas_match = runaslist_matches(&cs->runasuserlist,
		    &cs->runasgrouplist);
		if (runas_match == ALLOW) {
		    cmnd_match = cmnd_matches(cs->cmnd);
		    if (cmnd_match != UNSPEC) {
			match = cmnd_match;
			tags = &cs->tags;
#ifdef HAVE_SELINUX
			/* Set role and type if not specified on command line. */
			if (user_role == NULL)
			    user_role = cs->role ? estrdup(cs->role) : def_role;
			if (user_type == NULL)
			    user_type = cs->type ? estrdup(cs->type) : def_type;
#endif /* HAVE_SELINUX */
			goto matched2;
		    }
		}
	    }
	}
    }
    matched2:
    if (match == ALLOW) {
	SET(validated, VALIDATE_OK);
	CLR(validated, VALIDATE_NOT_OK);
	if (tags != NULL) {
	    if (tags->nopasswd != UNSPEC)
		def_authenticate = !tags->nopasswd;
	    if (tags->noexec != UNSPEC)
		def_noexec = tags->noexec;
	    if (tags->setenv != UNSPEC)
		def_setenv = tags->setenv;
	}
    } else if (match == DENY) {
	SET(validated, VALIDATE_NOT_OK);
	CLR(validated, VALIDATE_OK);
    }
    set_perms(PERM_ROOT);
    return(validated);
}

#define	TAG_CHANGED(t) \
	(cs->tags.t != UNSPEC && cs->tags.t != IMPLIED && cs->tags.t != tags->t)

static void
sudo_file_append_cmnd(cs, tags, lbuf)
    struct cmndspec *cs;
    struct cmndtag *tags;
    struct lbuf *lbuf;
{
    struct member *m;

#ifdef HAVE_SELINUX
    if (cs->role)
	lbuf_append(lbuf, "ROLE=", cs->role, " ", NULL);
    if (cs->type)
	lbuf_append(lbuf, "TYPE=", cs->type, " ", NULL);
#endif /* HAVE_SELINUX */
    if (TAG_CHANGED(setenv)) {
	lbuf_append(lbuf, cs->tags.setenv ? "SETENV: " :
	    "NOSETENV: ", NULL);
	tags->setenv = cs->tags.setenv;
    }
    if (TAG_CHANGED(noexec)) {
	lbuf_append(lbuf, cs->tags.noexec ? "NOEXEC: " :
	    "EXEC: ", NULL);
	tags->noexec = cs->tags.noexec;
    }
    if (TAG_CHANGED(nopasswd)) {
	lbuf_append(lbuf, cs->tags.nopasswd ? "NOPASSWD: " :
	    "PASSWD: ", NULL);
	tags->nopasswd = cs->tags.nopasswd;
    }
    m = cs->cmnd;
    print_member(lbuf, m->name, m->type, m->negated,
	CMNDALIAS);
}

static int
sudo_file_display_priv_short(pw, us, lbuf)
    struct passwd *pw;
    struct userspec *us;
    struct lbuf *lbuf;
{
    struct cmndspec *cs;
    struct member *m;
    struct privilege *priv;
    struct cmndtag tags;
    int nfound = 0;

    tq_foreach_fwd(&us->privileges, priv) {
	if (hostlist_matches(&priv->hostlist) != ALLOW)
	    continue;
	tags.noexec = UNSPEC;
	tags.setenv = UNSPEC;
	tags.nopasswd = UNSPEC;
	lbuf_append(lbuf, "    ", NULL);
	tq_foreach_fwd(&priv->cmndlist, cs) {
	    if (cs != tq_first(&priv->cmndlist))
		lbuf_append(lbuf, ", ", NULL);
	    lbuf_append(lbuf, "(", NULL);
	    if (!tq_empty(&cs->runasuserlist)) {
		tq_foreach_fwd(&cs->runasuserlist, m) {
		    if (m != tq_first(&cs->runasuserlist))
			lbuf_append(lbuf, ", ", NULL);
		    print_member(lbuf, m->name, m->type, m->negated,
			RUNASALIAS);
		}
	    } else if (tq_empty(&cs->runasgrouplist)) {
		lbuf_append(lbuf, def_runas_default, NULL);
	    } else {
		lbuf_append(lbuf, pw->pw_name, NULL);
	    }
	    if (!tq_empty(&cs->runasgrouplist)) {
		lbuf_append(lbuf, " : ", NULL);
		tq_foreach_fwd(&cs->runasgrouplist, m) {
		    if (m != tq_first(&cs->runasgrouplist))
			lbuf_append(lbuf, ", ", NULL);
		    print_member(lbuf, m->name, m->type, m->negated,
			RUNASALIAS);
		}
	    }
	    lbuf_append(lbuf, ") ", NULL);
	    sudo_file_append_cmnd(cs, &tags, lbuf);
	    nfound++;
	}
	lbuf_print(lbuf);		/* forces a newline */
    }
    return(nfound);
}

static int
sudo_file_display_priv_long(pw, us, lbuf)
    struct passwd *pw;
    struct userspec *us;
    struct lbuf *lbuf;
{
    struct cmndspec *cs;
    struct member *m;
    struct privilege *priv;
    struct cmndtag tags;
    int nfound = 0;

    tq_foreach_fwd(&us->privileges, priv) {
	if (hostlist_matches(&priv->hostlist) != ALLOW)
	    continue;
	tags.noexec = UNSPEC;
	tags.setenv = UNSPEC;
	tags.nopasswd = UNSPEC;
	lbuf_print(lbuf);	/* force a newline */
	lbuf_append(lbuf, "Sudoers entry:", NULL);
	lbuf_print(lbuf);
	tq_foreach_fwd(&priv->cmndlist, cs) {
	    lbuf_append(lbuf, "    RunAsUsers: ", NULL);
	    if (!tq_empty(&cs->runasuserlist)) {
		tq_foreach_fwd(&cs->runasuserlist, m) {
		    if (m != tq_first(&cs->runasuserlist))
			lbuf_append(lbuf, ", ", NULL);
		    print_member(lbuf, m->name, m->type, m->negated,
			RUNASALIAS);
		}
	    } else if (tq_empty(&cs->runasgrouplist)) {
		lbuf_append(lbuf, def_runas_default, NULL);
	    } else {
		lbuf_append(lbuf, pw->pw_name, NULL);
	    }
	    lbuf_print(lbuf);
	    if (!tq_empty(&cs->runasgrouplist)) {
		lbuf_append(lbuf, "    RunAsGroups: ", NULL);
		tq_foreach_fwd(&cs->runasgrouplist, m) {
		    if (m != tq_first(&cs->runasgrouplist))
			lbuf_append(lbuf, ", ", NULL);
		    print_member(lbuf, m->name, m->type, m->negated,
			RUNASALIAS);
		}
		lbuf_print(lbuf);
	    }
	    lbuf_append(lbuf, "    Commands: ", NULL);
	    lbuf_print(lbuf);
	    lbuf_append(lbuf, "\t", NULL);
	    sudo_file_append_cmnd(cs, &tags, lbuf);
	    lbuf_print(lbuf);
	    nfound++;
	}
    }
    return(nfound);
}

int
sudo_file_display_privs(nss, pw, lbuf)
    struct sudo_nss *nss;
    struct passwd *pw;
    struct lbuf *lbuf;
{
    struct userspec *us;
    int nfound = 0;

    if (nss->handle == NULL)
	return(-1);

    tq_foreach_fwd(&userspecs, us) {
	if (userlist_matches(pw, &us->users) != ALLOW)
	    continue;

	if (long_list)
	    nfound += sudo_file_display_priv_long(pw, us, lbuf);
	else
	    nfound += sudo_file_display_priv_short(pw, us, lbuf);
    }
    return(nfound);
}

/*
 * Display matching Defaults entries for the given user on this host.
 */
int
sudo_file_display_defaults(nss, pw, lbuf)
    struct sudo_nss *nss;
    struct passwd *pw;
    struct lbuf *lbuf;
{
    struct defaults *d;
    char *prefix = NULL;
    int nfound = 0;

    if (nss->handle == NULL)
	return(-1);

    if (lbuf->len == 0)
	prefix = "    ";
    else
	prefix = ", ";

    tq_foreach_fwd(&defaults, d) {
	switch (d->type) {
	    case DEFAULTS_HOST:
		if (hostlist_matches(&d->binding) != ALLOW)
		    continue;
		break;
	    case DEFAULTS_USER:
		if (userlist_matches(pw, &d->binding) != ALLOW)
		    continue;
		break;
	    case DEFAULTS_RUNAS:
	    case DEFAULTS_CMND:
		continue;
	}
	lbuf_append(lbuf, prefix, NULL);
	if (d->val != NULL) {
	    lbuf_append(lbuf, d->var, d->op == '+' ? "+=" :
		d->op == '-' ? "-=" : "=", NULL);
	    if (strpbrk(d->val, " \t") != NULL) {
		lbuf_append(lbuf, "\"", NULL);
		lbuf_append_quoted(lbuf, "\"", d->val, NULL);
		lbuf_append(lbuf, "\"", NULL);
	    } else
		lbuf_append_quoted(lbuf, SUDOERS_QUOTED, d->val, NULL);
	} else
	    lbuf_append(lbuf, d->op == FALSE ? "!" : "", d->var, NULL);
	prefix = ", ";
	nfound++;
    }

    return(nfound);
}

/*
 * Display Defaults entries that are per-runas or per-command
 */
int
sudo_file_display_bound_defaults(nss, pw, lbuf)
    struct sudo_nss *nss;
    struct passwd *pw;
    struct lbuf *lbuf;
{
    int nfound = 0;

    /* XXX - should only print ones that match what the user can do. */
    nfound += display_bound_defaults(DEFAULTS_RUNAS, lbuf);
    nfound += display_bound_defaults(DEFAULTS_CMND, lbuf);

    return(nfound);
}

/*
 * Display Defaults entries of the given type.
 */
static int
display_bound_defaults(dtype, lbuf)
    int dtype;
    struct lbuf *lbuf;
{
    struct defaults *d;
    struct member *m, *binding = NULL;
    char *dname, *dsep;
    int atype, nfound = 0;

    switch (dtype) {
	case DEFAULTS_HOST:
	    atype = HOSTALIAS;
	    dname = "host";
	    dsep = "@@";
	    break;
	case DEFAULTS_USER:
	    atype = USERALIAS;
	    dname = "user";
	    dsep = ":";
	    break;
	case DEFAULTS_RUNAS:
	    atype = RUNASALIAS;
	    dname = "runas";
	    dsep = ">";
	    break;
	case DEFAULTS_CMND:
	    atype = CMNDALIAS;
	    dname = "cmnd";
	    dsep = "!";
	    break;
	default:
	    return(-1);
    }
    /* printf("Per-%s Defaults entries:\n", dname); */
    tq_foreach_fwd(&defaults, d) {
	if (d->type != dtype)
	    continue;

	nfound++;
	if (binding != tq_first(&d->binding)) {
	    binding = tq_first(&d->binding);
	    lbuf_append(lbuf, "    Defaults", dsep, NULL);
	    for (m = binding; m != NULL; m = m->next) {
		if (m != binding)
		    lbuf_append(lbuf, ",", NULL);
		print_member(lbuf, m->name, m->type, m->negated, atype);
		lbuf_append(lbuf, " ", NULL);
	    }
	} else
	    lbuf_append(lbuf, ", ", NULL);
	if (d->val != NULL) {
	    lbuf_append(lbuf, d->var, d->op == '+' ? "+=" :
		d->op == '-' ? "-=" : "=", d->val, NULL);
	} else
	    lbuf_append(lbuf, d->op == FALSE ? "!" : "", d->var, NULL);
    }

    return(nfound);
}

int
sudo_file_display_cmnd(nss, pw)
    struct sudo_nss *nss;
    struct passwd *pw;
{
    struct cmndspec *cs;
    struct member *match;
    struct privilege *priv;
    struct userspec *us;
    int rval = 1;
    int host_match, runas_match, cmnd_match;

    if (nss->handle == NULL)
	return(rval);

    match = NULL;
    tq_foreach_rev(&userspecs, us) {
	if (userlist_matches(pw, &us->users) != ALLOW)
	    continue;

	tq_foreach_rev(&us->privileges, priv) {
	    host_match = hostlist_matches(&priv->hostlist);
	    if (host_match != ALLOW)
		continue;
	    tq_foreach_rev(&priv->cmndlist, cs) {
		runas_match = runaslist_matches(&cs->runasuserlist,
		    &cs->runasgrouplist);
		if (runas_match == ALLOW) {
		    cmnd_match = cmnd_matches(cs->cmnd);
		    if (cmnd_match != UNSPEC) {
			match = host_match && runas_match ?
			    cs->cmnd : NULL;
			goto matched;
		    }
		}
	    }
	}
    }
    matched:
    if (match != NULL && !match->negated) {
	printf("%s%s%s\n", safe_cmnd, user_args ? " " : "",
	    user_args ? user_args : "");
	rval = 0;
    }
    return(rval);
}

/*
 * Print the contents of a struct member to stdout
 */
static void
_print_member(lbuf, name, type, negated, alias_type)
    struct lbuf *lbuf;
    char *name;
    int type, negated, alias_type;
{
    struct alias *a;
    struct member *m;
    struct sudo_command *c;

    switch (type) {
	case ALL:
	    lbuf_append(lbuf, negated ? "!ALL" : "ALL", NULL);
	    break;
	case COMMAND:
	    c = (struct sudo_command *) name;
	    if (negated)
		lbuf_append(lbuf, "!", NULL);
	    lbuf_append_quoted(lbuf, SUDOERS_QUOTED, c->cmnd, NULL);
	    if (c->args) {
		lbuf_append(lbuf, " ", NULL);
		lbuf_append_quoted(lbuf, SUDOERS_QUOTED, c->args, NULL);
	    }
	    break;
	case ALIAS:
	    if ((a = alias_find(name, alias_type)) != NULL) {
		tq_foreach_fwd(&a->members, m) {
		    if (m != tq_first(&a->members))
			lbuf_append(lbuf, ", ", NULL);
		    _print_member(lbuf, m->name, m->type,
			negated ? !m->negated : m->negated, alias_type);
		}
		break;
	    }
	    /* FALLTHROUGH */
	default:
	    lbuf_append(lbuf, negated ? "!" : "", name, NULL);
	    break;
    }
}

static void
print_member(lbuf, name, type, negated, alias_type)
    struct lbuf *lbuf;
    char *name;
    int type, negated, alias_type;
{
    alias_seqno++;
    _print_member(lbuf, name, type, negated, alias_type);
}
@


1.26
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@@


1.25
log
@Update to sudo 1.7.2p3
@
text
@a50 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.242 2009/05/25 12:02:41 millert Exp $";
#endif /* lint */

@


1.24
log
@Upgrade to sudo 1.7.2
@
text
@d316 2
d369 2
d426 1
a426 3
	/* XXX - why only check the first privilege here? */
	if (userlist_matches(pw, &us->users) != ALLOW ||
	    hostlist_matches(&us->privileges.first->hostlist) != ALLOW)
@


1.23
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 2004-2005, 2007-2008 Todd C. Miller <Todd.Miller@@courtesan.com>
d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.239 2009/03/28 13:07:16 millert Exp $";
d92 1
a92 1
    nss->handle = open_sudoers(_PATH_SUDOERS, NULL);
d331 2
d334 1
a334 1
		lbuf_append(lbuf, def_runas_default, NULL);
d382 2
d385 1
a385 1
		lbuf_append(lbuf, def_runas_default, NULL);
@


1.22
log
@Better fix for rev 1.21
@
text
@d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.238 2008/12/09 13:49:55 millert Exp $";
d642 1
a642 1
	    if ((a = find_alias(name, alias_type)) != NULL) {
@


1.21
log
@Do not short circuit pseudo commands when we get a match since, depending
on the settings, we may need to examine all commands for tags.
@
text
@d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.236 2008/11/09 14:13:12 millert Exp $";
d170 1
a170 1
	int nopass = UNSPEC;
d174 1
d181 1
a181 1
	tq_foreach_rev(&userspecs, us) {
d184 1
a184 1
	    tq_foreach_rev(&us->privileges, priv) {
d187 1
a187 1
		tq_foreach_rev(&priv->cmndlist, cs) {
d193 2
a194 2
		    if ((pwcheck == any && nopass != TRUE) ||
			(pwcheck == all && nopass != FALSE))
@


1.20
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@a194 2
		    if (match == ALLOW)
			goto matched_pseudo;
a197 1
	matched_pseudo:
@


1.19
log
@Update to sudo 1.6.9p17
@
text
@d2 1
a2 2
 * Copyright (c) 1996, 1998-2005, 2007
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
a16 4
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
a22 2
#include <sys/socket.h>
#include <sys/stat.h>
a41 9
#ifdef HAVE_FNMATCH
# include <fnmatch.h>
#endif /* HAVE_FNMATCH */
#ifdef HAVE_EXTENDED_GLOB
# include <glob.h>
#endif /* HAVE_EXTENDED_GLOB */
#ifdef HAVE_NETGROUP_H
# include <netgroup.h>
#endif /* HAVE_NETGROUP_H */
a44 19
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#ifdef HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# ifdef HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# ifdef HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# ifdef HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif
d48 2
a49 8
#include "interfaces.h"

#ifndef HAVE_FNMATCH
# include "emul/fnmatch.h"
#endif /* HAVE_FNMATCH */
#ifndef HAVE_EXTENDED_GLOB
# include "emul/glob.h"
#endif /* HAVE_EXTENDED_GLOB */
d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.16 2008/02/09 14:44:48 millert Exp $";
d55 18
d74 1
a74 1
 * Globals
d76 3
a78 3
int parse_error = FALSE;
extern int keepall;
extern FILE *yyin, *yyout;
d81 1
a81 1
 * Prototypes
d83 26
a108 2
static int has_meta	__P((char *));
       void init_parser	__P((void));
d111 1
a111 2
 * Look up the user in the sudoers file and check to see if they are
 * allowed to run the specified command on this host as the target user.
d114 2
a115 2
sudoers_lookup(pwflag)
    int pwflag;
d117 2
a118 1
    int error, nopass;
d120 9
a128 4
    /* We opened _PATH_SUDOERS in check_sudoers() so just rewind it. */
    rewind(sudoers_fp);
    yyin = sudoers_fp;
    yyout = stdout;
d130 9
a138 2
    /* Allocate space for data structures in the parser. */
    init_parser();
d140 4
a143 3
    /* Keep more state for pseudo-commands so that listpw and verifypw work */
    if (pwflag > 0)
	keepall = TRUE;
d145 15
a159 12
    /* Need to be runas user while stat'ing things in the parser. */
    set_perms(PERM_RUNAS);
    error = yyparse();

    /* Close the sudoers file now that we are done with it. */
    (void) fclose(sudoers_fp);
    sudoers_fp = NULL;

    if (error || parse_error) {
	set_perms(PERM_ROOT);
	return(VALIDATE_ERROR);
    }
d161 2
a162 15
    /*
     * Assume the worst.  If the stack is empty the user was
     * not mentioned at all.
     */
    if (def_authenticate)
	error = VALIDATE_NOT_OK;
    else
	error = VALIDATE_NOT_OK | FLAG_NOPASS;
    if (pwflag) {
	SET(error, FLAG_NO_CHECK);
    } else {
	SET(error, FLAG_NO_HOST);
	if (!top)
	    SET(error, FLAG_NO_USER);
    }
a168 1
    nopass = -1;
d170 1
a170 1
	int found;
d175 23
a197 12
	if (pwcheck == always && def_authenticate)
	    nopass = FLAG_CHECK_USER;
	else if (pwcheck == never || !def_authenticate)
	    nopass = FLAG_NOPASS;
	found = 0;
	while (top) {
	    if (host_matches == TRUE) {
		found = 1;
		if (pwcheck == any && no_passwd == TRUE)
		    nopass = FLAG_NOPASS;
		else if (pwcheck == all && nopass != 0)
		    nopass = (no_passwd == TRUE) ? FLAG_NOPASS : 0;
a198 1
	    top--;
d200 35
a234 14
	if (found) {
	    set_perms(PERM_ROOT);
	    if (nopass == -1)
		nopass = 0;
	    return(VALIDATE_OK | nopass);
	}
    } else {
	while (top) {
	    if (host_matches == TRUE) {
		CLR(error, FLAG_NO_HOST);
		if (runas_matches == TRUE && cmnd_matches == TRUE) {
		    /*
		     * User was granted access to cmnd on host as user.
		     */
d236 7
a242 12
		    /* Set role and type if not specified on command line. */
		    if (user_role == NULL) {
			if (match[top-1].role != NULL)
			    user_role = match[top-1].role;
			else
			    user_role = def_role;
		    }
		    if (user_type == NULL) {
			if (match[top-1].type != NULL)
			    user_type = match[top-1].type;
			else
			    user_type = def_type;
a243 16
#endif
		    set_perms(PERM_ROOT);
		    return(VALIDATE_OK |
			(no_passwd == TRUE ? FLAG_NOPASS : 0) |
			(no_execve == TRUE ? FLAG_NOEXEC : 0) |
			(setenv_ok >= TRUE ? FLAG_SETENV : 0));
		} else if ((runas_matches == TRUE && cmnd_matches == FALSE) ||
		    (runas_matches == FALSE && cmnd_matches == TRUE)) {
		    /*
		     * User was explicitly denied access to cmnd on host.
		     */
		    set_perms(PERM_ROOT);
		    return(VALIDATE_NOT_OK |
			(no_passwd == TRUE ? FLAG_NOPASS : 0) |
			(no_execve == TRUE ? FLAG_NOEXEC : 0) |
			(setenv_ok >= TRUE ? FLAG_SETENV : 0));
a245 1
	    top--;
d248 16
d265 1
a265 7

    /*
     * The user was neither explicitly granted nor denied access.
     */
    if (nopass == -1)
	nopass = 0;
    return(error | nopass);
d268 2
a269 36
/*
 * If path doesn't end in /, return TRUE iff cmnd & path name the same inode;
 * otherwise, return TRUE if user_cmnd names one of the inodes in path.
 */
int
command_matches(sudoers_cmnd, sudoers_args)
    char *sudoers_cmnd;
    char *sudoers_args;
{
    struct stat sudoers_stat;
    struct dirent *dent;
    char **ap, *base, buf[PATH_MAX];
    glob_t gl;
    DIR *dirp;

    /* Check for pseudo-commands */
    if (strchr(user_cmnd, '/') == NULL) {
	/*
	 * Return true if both sudoers_cmnd and user_cmnd are "sudoedit" AND
	 *  a) there are no args in sudoers OR
	 *  b) there are no args on command line and none req by sudoers OR
	 *  c) there are args in sudoers and on command line and they match
	 */
	if (strcmp(sudoers_cmnd, "sudoedit") != 0 ||
	    strcmp(user_cmnd, "sudoedit") != 0)
	    return(FALSE);
	if (!sudoers_args ||
	    (!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args &&
	     fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(sudoers_cmnd);
	    return(TRUE);
	} else
	    return(FALSE);
    }
d271 7
a277 85
    /*
     * If sudoers_cmnd has meta characters in it, use fnmatch(3)
     * to do the matching.
     */
    if (has_meta(sudoers_cmnd)) {
	/*
	 * Return true if we find a match in the glob(3) results AND
	 *  a) there are no args in sudoers OR
	 *  b) there are no args on command line and none required by sudoers OR
	 *  c) there are args in sudoers and on command line and they match
	 * else return false.
	 *
	 * Could optimize patterns ending in "/*" to "/user_base"
	 */
#define GLOB_FLAGS	(GLOB_NOSORT | GLOB_MARK | GLOB_BRACE | GLOB_TILDE)
	if (glob(sudoers_cmnd, GLOB_FLAGS, NULL, &gl) != 0) {
	    globfree(&gl);
	    return(FALSE);
	}
	/* For each glob match, compare basename, st_dev and st_ino. */
	for (ap = gl.gl_pathv; *ap != NULL; ap++) {
	    /* only stat if basenames are the same */
	    if ((base = strrchr(*ap, '/')) != NULL)
		base++;
	    else
		base = *ap;
	    if (strcmp(user_base, base) != 0 ||
		stat(*ap, &sudoers_stat) == -1)
		continue;
	    if (user_stat->st_dev == sudoers_stat.st_dev &&
		user_stat->st_ino == sudoers_stat.st_ino) {
		efree(safe_cmnd);
		safe_cmnd = estrdup(*ap);
		break;
	    }
	}
	globfree(&gl);
	if (*ap == NULL)
	    return(FALSE);

	if (!sudoers_args ||
	    (!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args &&
	     fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
	    efree(safe_cmnd);
	    safe_cmnd = estrdup(user_cmnd);
	    return(TRUE);
	} else
	    return(FALSE);
    } else {
	size_t dlen = strlen(sudoers_cmnd);

	/*
	 * No meta characters
	 * Check to make sure this is not a directory spec (doesn't end in '/')
	 */
	if (sudoers_cmnd[dlen - 1] != '/') {
	    /* Only proceed if user_base and basename(sudoers_cmnd) match */
	    if ((base = strrchr(sudoers_cmnd, '/')) == NULL)
		base = sudoers_cmnd;
	    else
		base++;
	    if (strcmp(user_base, base) != 0 ||
		stat(sudoers_cmnd, &sudoers_stat) == -1)
		return(FALSE);

	    /*
	     * Return true if inode/device matches AND
	     *  a) there are no args in sudoers OR
	     *  b) there are no args on command line and none req by sudoers OR
	     *  c) there are args in sudoers and on command line and they match
	     */
	    if (user_stat->st_dev != sudoers_stat.st_dev ||
		user_stat->st_ino != sudoers_stat.st_ino)
		return(FALSE);
	    if (!sudoers_args ||
		(!user_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
		(sudoers_args &&
		 fnmatch(sudoers_args, user_args ? user_args : "", 0) == 0)) {
		efree(safe_cmnd);
		safe_cmnd = estrdup(sudoers_cmnd);
		return(TRUE);
	    } else
		return(FALSE);
	}
d279 25
a303 14
	/*
	 * Grot through sudoers_cmnd's directory entries, looking for user_base.
	 */
	dirp = opendir(sudoers_cmnd);
	if (dirp == NULL)
	    return(FALSE);

	if (strlcpy(buf, sudoers_cmnd, sizeof(buf)) >= sizeof(buf))
	    return(FALSE);
	while ((dent = readdir(dirp)) != NULL) {
	    /* ignore paths > PATH_MAX (XXX - log) */
	    buf[dlen] = '\0';
	    if (strlcat(buf, dent->d_name, sizeof(buf)) >= sizeof(buf))
		continue;
d305 39
a343 9
	    /* only stat if basenames are the same */
	    if (strcmp(user_base, dent->d_name) != 0 ||
		stat(buf, &sudoers_stat) == -1)
		continue;
	    if (user_stat->st_dev == sudoers_stat.st_dev &&
		user_stat->st_ino == sudoers_stat.st_ino) {
		efree(safe_cmnd);
		safe_cmnd = estrdup(buf);
		break;
d345 3
d349 1
a349 3

	closedir(dirp);
	return(dent != NULL);
d351 1
d355 4
a358 2
addr_matches_if(n)
    char *n;
d360 33
a392 38
    int i;
    struct in_addr addr;
    struct interface *ifp;
#ifdef HAVE_IN6_ADDR
    struct in6_addr addr6;
    int j;
#endif
    int family;

#ifdef HAVE_IN6_ADDR
    if (inet_pton(AF_INET6, n, &addr6) > 0) {
	family = AF_INET6;
    } else
#endif
    {
	family = AF_INET;
	addr.s_addr = inet_addr(n);
    }

    for (i = 0; i < num_interfaces; i++) {
	ifp = &interfaces[i];
	if (ifp->family != family)
	    continue;
	switch(family) {
	    case AF_INET:
		if (ifp->addr.ip4.s_addr == addr.s_addr ||
		    (ifp->addr.ip4.s_addr & ifp->netmask.ip4.s_addr)
		    == addr.s_addr)
		    return(TRUE);
		break;
#ifdef HAVE_IN6_ADDR
	    case AF_INET6:
		if (memcmp(ifp->addr.ip6.s6_addr, addr6.s6_addr,
		    sizeof(addr6.s6_addr)) == 0)
		    return(TRUE);
		for (j = 0; j < sizeof(addr6.s6_addr); j++) {
		    if ((ifp->addr.ip6.s6_addr[j] & ifp->netmask.ip6.s6_addr[j]) != addr6.s6_addr[j])
			break;
d394 8
a401 3
		if (j == sizeof(addr6.s6_addr))
		    return(TRUE);
#endif /* HAVE_IN6_ADDR */
d404 1
a404 2

    return(FALSE);
d407 8
a414 23
static int
addr_matches_if_netmask(n, m)
    char *n;
    char *m;
{
    int i;
    struct in_addr addr, mask;
    struct interface *ifp;
#ifdef HAVE_IN6_ADDR
    struct in6_addr addr6, mask6;
    int j;
#endif
    int family;

#ifdef HAVE_IN6_ADDR
    if (inet_pton(AF_INET6, n, &addr6) > 0)
	family = AF_INET6;
    else
#endif
    {
	family = AF_INET;
	addr.s_addr = inet_addr(n);
    }
d416 2
a417 26
    if (family == AF_INET) {
	if (strchr(m, '.'))
	    mask.s_addr = inet_addr(m);
	else {
	    i = 32 - atoi(m);
	    mask.s_addr = 0xffffffff;
	    mask.s_addr >>= i;
	    mask.s_addr <<= i;
	    mask.s_addr = htonl(mask.s_addr);
	}
    }
#ifdef HAVE_IN6_ADDR
    else {
	if (inet_pton(AF_INET6, m, &mask6) <= 0) {
	    j = atoi(m);
	    for (i = 0; i < 16; i++) {
		if (j < i * 8)
		    mask6.s6_addr[i] = 0;
		else if (i * 8 + 8 <= j)
		    mask6.s6_addr[i] = 0xff;
		else
		    mask6.s6_addr[i] = 0xff00 >> (j - i * 8);
	    }
	}
    }
#endif /* HAVE_IN6_ADDR */
d419 4
a422 3
    for (i = 0; i < num_interfaces; i++) {
	ifp = &interfaces[i];
	if (ifp->family != family)
d424 5
a428 14
	switch(family) {
	    case AF_INET:
		if ((ifp->addr.ip4.s_addr & mask.s_addr) == addr.s_addr)
		    return(TRUE);
#ifdef HAVE_IN6_ADDR
	    case AF_INET6:
		for (j = 0; j < sizeof(addr6.s6_addr); j++) {
		    if ((ifp->addr.ip6.s6_addr[j] & mask6.s6_addr[j]) != addr6.s6_addr[j])
			break;
		}
		if (j == sizeof(addr6.s6_addr))
		    return(TRUE);
#endif /* HAVE_IN6_ADDR */
	}
d430 1
a430 2

    return(FALSE);
d434 1
a434 2
 * Returns TRUE if "n" is one of our ip addresses or if
 * "n" is a network that we are on, else returns FALSE.
d437 4
a440 2
addr_matches(n)
    char *n;
d442 3
a444 2
    char *m;
    int retval;
d446 2
a447 7
    /* If there's an explicit netmask, use it. */
    if ((m = strchr(n, '/'))) {
	*m++ = '\0';
	retval = addr_matches_if_netmask(n, m);
	*(m - 1) = '/';
    } else
	retval = addr_matches_if(n);
d449 4
a452 2
    return(retval);
}
d454 28
a481 19
/*
 * Returns 0 if the hostname matches the pattern and non-zero otherwise.
 */
int
hostname_matches(shost, lhost, pattern)
    char *shost;
    char *lhost;
    char *pattern;
{
    if (has_meta(pattern)) {
	if (strchr(pattern, '.'))
	    return(fnmatch(pattern, lhost, FNM_CASEFOLD));
	else
	    return(fnmatch(pattern, shost, FNM_CASEFOLD));
    } else {
	if (strchr(pattern, '.'))
	    return(strcasecmp(lhost, pattern));
	else
	    return(strcasecmp(shost, pattern));
d483 2
d488 1
a488 2
 *  Returns TRUE if the user/uid from sudoers matches the specified user/uid,
 *  else returns FALSE.
d491 2
a492 3
userpw_matches(sudoers_user, user, pw)
    char *sudoers_user;
    char *user;
d494 1
d496 7
a502 6
    if (pw != NULL && *sudoers_user == '#') {
	uid_t uid = atoi(sudoers_user + 1);
	if (uid == pw->pw_uid)
	    return(1);
    }
    return(strcmp(sudoers_user, user) == 0);
d506 1
a506 3
 *  Returns TRUE if the given user belongs to the named group,
 *  else returns FALSE.
 *  XXX - reduce the number of passwd/group lookups
d508 4
a511 5
int
usergr_matches(group, user, pw)
    char *group;
    char *user;
    struct passwd *pw;
d513 33
a545 20
    struct group *grp;
    gid_t pw_gid;
    char **cur;
    int i;

    /* make sure we have a valid usergroup, sudo style */
    if (*group++ != '%')
	return(FALSE);

    /* look up user's primary gid in the passwd file */
    if (pw == NULL && (pw = getpwnam(user)) == NULL)
	return(FALSE);
    pw_gid = pw->pw_gid;

    if ((grp = getgrnam(group)) == NULL)
	return(FALSE);

    /* check against user's primary (passwd file) gid */
    if (grp->gr_gid == pw_gid)
	return(TRUE);
d547 17
a563 12
    /*
     * If the user has a supplementary group vector, check it first.
     */
    for (i = 0; i < user_ngroups; i++) {
	if (grp->gr_gid == user_groups[i])
	    return(TRUE);
    }
    if (grp->gr_mem != NULL) {
	for (cur = grp->gr_mem; *cur; cur++) {
	    if (strcmp(*cur, user) == 0)
		return(TRUE);
	}
d566 1
a566 1
    return(FALSE);
a568 5
/*
 * Returns TRUE if "host" and "user" belong to the netgroup "netgr",
 * else return FALSE.  Either of "host", "shost" or "user" may be NULL
 * in which case that argument is not checked...
 */
d570 35
a604 22
netgr_matches(netgr, host, shost, user)
    char *netgr;
    char *host;
    char *shost;
    char *user;
{
    static char *domain;
#ifdef HAVE_GETDOMAINNAME
    static int initialized;
#endif

    /* make sure we have a valid netgroup, sudo style */
    if (*netgr++ != '+')
	return(FALSE);

#ifdef HAVE_GETDOMAINNAME
    /* get the domain name (if any) */
    if (!initialized) {
	domain = (char *) emalloc(MAXHOSTNAMELEN);
	if (getdomainname(domain, MAXHOSTNAMELEN) == -1 || *domain == '\0') {
	    efree(domain);
	    domain = NULL;
a605 1
	initialized = 1;
d607 7
a613 10
#endif /* HAVE_GETDOMAINNAME */

#ifdef HAVE_INNETGR
    if (innetgr(netgr, host, user, domain))
	return(TRUE);
    else if (host != shost && innetgr(netgr, shost, user, domain))
	return(TRUE);
#endif /* HAVE_INNETGR */

    return(FALSE);
d617 1
a617 2
 * Returns TRUE if "s" has shell meta characters in it,
 * else returns FALSE.
d619 5
a623 3
static int
has_meta(s)
    char *s;
d625 32
a656 5
    char *t;
 
    for (t = s; *t; t++) {
	if (*t == '\\' || *t == '?' || *t == '*' || *t == '[' || *t == ']')
	    return(TRUE);
d658 10
a667 1
    return(FALSE);
@


1.19.2.1
log
@Fix for http://www.sudo.ws/sudo/alerts/group_vector.html
OK henning@@
@
text
@d624 3
a626 5
    if (strcmp(user, user_name) == 0) {
	for (i = 0; i < user_ngroups; i++) {
	    if (grp->gr_gid == user_groups[i])
		return(TRUE);
	}
@


1.18
log
@missing change from 1.6.9p9
@
text
@d93 1
a93 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.15 2007/12/04 15:26:40 millert Exp $";
d201 15
@


1.18.2.1
log
@Fix for http://www.sudo.ws/sudo/alerts/group_vector.html
OK henning@@
@
text
@d609 3
a611 5
    if (strcmp(user, user_name) == 0) {
	for (i = 0; i < user_ngroups; i++) {
	    if (grp->gr_gid == user_groups[i])
		return(TRUE);
	}
@


1.17
log
@Update to sudo 1.6.9p7
@
text
@d93 1
a93 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.14 2007/10/24 16:43:27 millert Exp $";
d205 1
a205 1
			(setenv_ok == TRUE ? FLAG_SETENV : 0));
d215 1
a215 1
			(setenv_ok == TRUE ? FLAG_SETENV : 0));
@


1.16
log
@update to sudo 1.6.9p5
@
text
@d93 1
a93 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.13 2007/08/25 02:37:11 millert Exp $";
d393 1
a393 1
#ifdef AF_INET6
d399 1
a399 1
#ifdef AF_INET6
d420 1
a420 1
#ifdef AF_INET6
d431 1
a431 1
#endif /* AF_INET6 */
d446 1
a446 1
#ifdef AF_INET6
d452 1
a452 1
#ifdef AF_INET6
d473 1
a473 1
#ifdef AF_INET6
d487 1
a487 1
#endif /* AF_INET6 */
d497 1
a497 1
#ifdef AF_INET6
d505 1
a505 1
#endif /* AF_INET6 */
@


1.15
log
@Update to sudo 1.6.9p4.  Basically IPv6 support and improved man pages.
@
text
@d93 1
a93 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.12 2007/08/13 16:30:02 millert Exp $";
d397 1
a397 1
    int family = AF_UNSPEC;
d403 1
a403 1
#else
a407 1
#endif
d450 1
a450 1
    int family = AF_UNSPEC;
d456 1
a456 1
#else
a460 1
#endif
@


1.14
log
@Fix off by one in group list matching.  Found by david@@
@
text
@d28 1
d93 1
a93 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.11 2007/08/02 02:09:10 millert Exp $";
d386 2
a387 6
/*
 * Returns TRUE if "n" is one of our ip addresses or if
 * "n" is a network that we are on, else returns FALSE.
 */
int
addr_matches(n)
d391 51
d443 2
d446 6
d453 7
a459 3
    /* If there's an explicit netmask, use it. */
    if ((m = strchr(n, '/'))) {
	*m++ = '\0';
d461 4
d474 16
a489 1
	*(m - 1) = '/';
d491 18
a508 11
	for (i = 0; i < num_interfaces; i++)
	    if ((interfaces[i].addr.s_addr & mask.s_addr) == addr.s_addr)
		return(TRUE);
    } else {
	addr.s_addr = inet_addr(n);

	for (i = 0; i < num_interfaces; i++)
	    if (interfaces[i].addr.s_addr == addr.s_addr ||
		(interfaces[i].addr.s_addr & interfaces[i].netmask.s_addr)
		== addr.s_addr)
		return(TRUE);
d512 22
@


1.13
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d92 1
a92 1
__unused static const char rcsid[] = "$Sudo: parse.c,v 1.160.2.10 2007/07/06 19:34:20 millert Exp $";
d482 1
a482 1
    int n;
d503 2
a504 2
    for (n = user_ngroups; n != 0; n--) {
	if (grp->gr_gid == user_groups[n])
@


1.12
log
@Update to sudo 1.6.8p1
@
text
@d2 2
a3 1
 * Copyright (c) 1996, 1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d24 1
a24 1
#include "config.h"
d51 3
d87 3
d92 1
a92 1
static const char rcsid[] = "$Sudo: parse.c,v 1.161 2004/08/24 18:01:13 millert Exp $";
a116 1
    enum def_tupple pwcheck;
d126 1
a126 1
    /* If pwcheck *could* be "all" or "any", keep more state. */
a143 9
     * The pw options may have changed during sudoers parse so we
     * wait until now to set this.
     */
    if (pwflag)
	pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;
    else
	pwcheck = 0;

    /*
d151 1
a151 1
    if (pwcheck) {
d167 3
d203 2
a204 1
			(no_execve == TRUE ? FLAG_NOEXEC : 0));
d213 2
a214 1
			(no_execve == TRUE ? FLAG_NOEXEC : 0));
d241 2
a242 1
    char buf[PATH_MAX];
d260 1
a260 2
	    if (safe_cmnd)
		free(safe_cmnd);
d273 1
a273 1
	 * Return true if fnmatch(3) succeeds AND
d278 2
d281 3
a283 1
	if (fnmatch(sudoers_cmnd, user_cmnd, FNM_PATHNAME) != 0)
d285 22
d311 1
a311 2
	    if (safe_cmnd)
		free(safe_cmnd);
a323 2
	    char *base;

d346 1
a346 2
		if (safe_cmnd)
		    free(safe_cmnd);
d374 1
a374 2
		if (safe_cmnd)
		    free(safe_cmnd);
d482 1
d500 5
a504 3
    /* check to see if user is explicitly listed in the group */
    for (cur = grp->gr_mem; *cur; cur++) {
	if (strcmp(*cur, user) == 0)
d507 6
d529 1
d531 2
a532 4
    static char *domain = (char *) -1;
#else
    static char *domain = NULL;
#endif /* HAVE_GETDOMAINNAME */
d540 1
a540 1
    if (domain == (char *) -1) {
d543 1
a543 1
	    free(domain);
d546 1
@


1.11
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d2 1
a2 2
 * Copyright (c) 1996, 1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 1
 * This code is derived from software contributed by Chris Jepeway.
d8 7
a14 26
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
d85 1
a85 1
static const char rcsid[] = "$Sudo: parse.c,v 1.142 2003/04/16 00:42:10 millert Exp $";
d109 2
a110 6
    int error;
    int pwcheck;
    int nopass;

    /* Become sudoers file owner */
    set_perms(PERM_SUDOERS);
d120 1
a120 1
    /* If pwcheck *could* be PWCHECK_ALL or PWCHECK_ANY, keep more state. */
d124 2
a125 2
    /* Need to be root while stat'ing things in the parser. */
    set_perms(PERM_ROOT);
d132 2
a133 1
    if (error || parse_error)
d135 1
d142 1
a142 1
	pwcheck = (pwflag == -1) ? PWCHECK_NEVER : def_ival(pwflag);
d150 1
a150 1
    if (def_flag(I_AUTHENTICATE))
d155 1
a155 1
	error |= FLAG_NO_CHECK;
d157 1
a157 1
	error |= FLAG_NO_HOST;
d159 1
a159 1
	    error |= FLAG_NO_USER;
d163 1
a163 1
     * Only check the actual command if pwcheck flag is not set.
d168 1
a168 1
    if (pwcheck) {
d171 3
a173 1
	if (pwcheck == PWCHECK_NEVER || !def_flag(I_AUTHENTICATE))
d179 1
a179 1
		if (pwcheck == PWCHECK_ANY && no_passwd == TRUE)
d181 1
a181 1
		else if (pwcheck == PWCHECK_ALL && nopass != 0)
d187 1
d195 18
a212 20
		error &= ~FLAG_NO_HOST;
		if (runas_matches == TRUE) {
		    if (cmnd_matches == TRUE) {
		    	/*
			 * User was granted access to cmnd on host.
		    	 * If no passwd required return as such.
			 */
		    	if (no_passwd == TRUE)
			    return(VALIDATE_OK | FLAG_NOPASS);
		    	else
			    return(VALIDATE_OK);
		    } else if (cmnd_matches == FALSE) {
			/*
			 * User was explicitly denied access to cmnd on host.
			 */
			if (no_passwd == TRUE)
			    return(VALIDATE_NOT_OK | FLAG_NOPASS);
			else
			    return(VALIDATE_NOT_OK);
		    }
d218 1
d221 1
a221 1
     * The user was not explicitly granted nor denied access.
d230 1
a230 1
 * otherwise, return TRUE if cmnd names one of the inodes in path.
d233 2
a234 4
command_matches(cmnd, cmnd_args, path, sudoers_args)
    char *cmnd;
    char *cmnd_args;
    char *path;
d237 3
a239 3
    int plen;
    static struct stat cst;
    struct stat pst;
a240 3
    struct dirent *dent;
    char buf[MAXPATHLEN];
    static char *cmnd_base;
d242 20
a261 9
    /* Don't bother with pseudo commands like "validate" */
    if (strchr(cmnd, '/') == NULL)
	return(FALSE);

    plen = strlen(path);

    /* Only need to stat cmnd once since it never changes */
    if (cst.st_dev == 0) {
	if (stat(cmnd, &cst) == -1)
a262 4
	if ((cmnd_base = strrchr(cmnd, '/')) == NULL)
	    cmnd_base = cmnd;
	else
	    cmnd_base++;
d266 2
a267 2
     * If the pathname has meta characters in it use fnmatch(3)
     * to do the matching
d269 1
a269 1
    if (has_meta(path)) {
d277 1
a277 1
	if (fnmatch(path, cmnd, FNM_PATHNAME) != 0)
d280 3
a282 3
	    (!cmnd_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
	    (sudoers_args && fnmatch(sudoers_args, cmnd_args ? cmnd_args : "",
	    0) == 0)) {
d290 2
d296 2
a297 2
	if (path[plen - 1] != '/') {
	    char *p;
d299 3
a301 3
	    /* Only proceed if the basenames of cmnd and path are the same */
	    if ((p = strrchr(path, '/')) == NULL)
		p = path;
d303 3
a305 2
		p++;
	    if (strcmp(cmnd_base, p) != 0 || stat(path, &pst) == -1)
d314 2
a315 1
	    if (cst.st_dev != pst.st_dev || cst.st_ino != pst.st_ino)
d318 1
a318 1
		(!cmnd_args && sudoers_args && !strcmp("\"\"", sudoers_args)) ||
d320 1
a320 1
		 fnmatch(sudoers_args, cmnd_args ? cmnd_args : "", 0) == 0)) {
d323 1
a323 1
		safe_cmnd = estrdup(path);
d330 1
a330 1
	 * Grot through path's directory entries, looking for cmnd.
d332 1
a332 1
	dirp = opendir(path);
d336 2
d339 3
a341 3
	    /* ignore paths > MAXPATHLEN (XXX - log) */
	    if (strlcpy(buf, path, sizeof(buf)) >= sizeof(buf) ||
		strlcat(buf, dent->d_name, sizeof(buf)) >= sizeof(buf))
d345 2
a346 1
	    if (strcmp(cmnd_base, dent->d_name) != 0 || stat(buf, &pst) == -1)
d348 2
a349 1
	    if (cst.st_dev == pst.st_dev && cst.st_ino == pst.st_ino) {
d428 18
d448 1
d451 1
a451 1
usergr_matches(group, user)
d454 1
d457 1
a457 1
    struct passwd *pw;
d464 2
a465 1
    if ((grp = getgrnam(group)) == NULL) 
d467 1
d469 1
a469 4
    /*
     * Check against user's real gid as well as group's user list
     */
    if ((pw = getpwnam(user)) == NULL)
d472 2
a473 1
    if (grp->gr_gid == pw->pw_gid)
d476 2
a477 1
    for (cur=grp->gr_mem; *cur; cur++) {
d537 1
a537 1
    
@


1.10
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d35 4
d103 1
a103 1
static const char rcsid[] = "$Sudo: parse.c,v 1.141 2003/04/02 18:25:19 millert Exp $";
@


1.9
log
@update to what will soon be sudo 1.6.7
@
text
@d63 1
a63 1
#endif /* HAVE_FNMATCH_H */
d99 1
a99 1
static const char rcsid[] = "$Sudo: parse.c,v 1.140 2003/03/15 20:31:02 millert Exp $";
@


1.8
log
@Update to sudo 1.6.6
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d99 1
a99 1
static const char rcsid[] = "$Sudo: parse.c,v 1.137 2002/03/16 00:44:47 millert Exp $";
d128 1
a128 1
    set_perms(PERM_SUDOERS, 0);
d143 1
a143 1
    set_perms(PERM_ROOT, 0);
d346 2
a347 1
	    if (plen + NAMLEN(dent) >= sizeof(buf))
a348 2
	    strcpy(buf, path);
	    strcat(buf, dent->d_name);
@


1.7
log
@sync with sudo 1.6.4rc2
@
text
@d5 1
a5 2
 * This code is derived from software contributed by Chris Jepeway
 * <jepeway@@cs.utk.edu>.
d99 1
a99 1
static const char rcsid[] = "$Sudo: parse.c,v 1.136 2002/01/08 15:00:18 millert Exp $";
@


1.6
log
@Update to sudo 1.6.4
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d100 1
a100 1
static const char rcsid[] = "$Sudo: parse.c,v 1.134 2001/12/14 19:52:48 millert Exp $";
@


1.5
log
@update to sudo 1.6.3p5
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d40 3
d46 5
d52 7
a61 6
#ifdef HAVE_STRING_H
# include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
# include <strings.h>
#endif /* HAVE_STRINGS_H */
a70 2
#include <sys/param.h>
#include <sys/types.h>
d74 1
a74 2
#include <sys/stat.h>
#if HAVE_DIRENT_H
d80 1
a80 1
# if HAVE_SYS_NDIR_H
d83 1
a83 1
# if HAVE_SYS_DIR_H
d86 1
a86 1
# if HAVE_NDIR_H
d100 1
a100 1
static const char rcsid[] = "$Sudo: parse.c,v 1.130 2000/03/23 04:38:19 millert Exp $";
d121 2
a122 2
sudoers_lookup(sudo_mode)
    int sudo_mode;
d126 1
d140 1
a140 2
    if (!(sudo_mode & MODE_RUN) && sudo_mode != MODE_KILL &&
	sudo_mode != MODE_INVALIDATE)
d158 4
a161 15
    switch (sudo_mode) {
	case MODE_VALIDATE:
	    pwcheck = def_ival(I_VERIFYPW);
	    break;
	case MODE_LIST:
	    pwcheck = def_ival(I_LISTPW);
	    break;
	case MODE_KILL:
	case MODE_INVALIDATE:
	    pwcheck = PWCHECK_NEVER;
	    break;
	default:
	    pwcheck = 0;
	    break;
}
d184 1
d186 1
a186 1
	int nopass, found;
a189 2
	else
	    nopass = -1;
d238 3
a240 1
    return(error);
d386 7
a392 2
	else
	    mask.s_addr = (1 << atoi(m)) - 1;	/* XXX - better way? */
@


1.5.4.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
a39 3
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
a42 5
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d44 3
a48 4
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d50 3
a52 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d62 2
d67 2
a68 1
#ifdef HAVE_DIRENT_H
d74 1
a74 1
# ifdef HAVE_SYS_NDIR_H
d77 1
a77 1
# ifdef HAVE_SYS_DIR_H
d80 1
a80 1
# ifdef HAVE_NDIR_H
d94 1
a94 1
static const char rcsid[] = "$Sudo: parse.c,v 1.136 2002/01/08 15:00:18 millert Exp $";
d115 2
a116 2
sudoers_lookup(pwflag)
    int pwflag;
a119 1
    int nopass;
d133 2
a134 1
    if (pwflag > 0)
d152 15
a166 4
    if (pwflag)
	pwcheck = (pwflag == -1) ? PWCHECK_NEVER : def_ival(pwflag);
    else
	pwcheck = 0;
a188 1
    nopass = -1;
d190 1
a190 1
	int found;
d194 2
d244 1
a244 3
    if (nopass == -1)
	nopass = 0;
    return(error | nopass);
d390 2
a391 7
	else {
	    i = 32 - atoi(m);
	    mask.s_addr = 0xffffffff;
	    mask.s_addr >>= i;
	    mask.s_addr <<= i;
	    mask.s_addr = htonl(mask.s_addr);
	}
@


1.5.6.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
a39 3
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
a42 5
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d44 3
a48 4
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d50 3
a52 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d62 2
d67 2
a68 1
#ifdef HAVE_DIRENT_H
d74 1
a74 1
# ifdef HAVE_SYS_NDIR_H
d77 1
a77 1
# ifdef HAVE_SYS_DIR_H
d80 1
a80 1
# ifdef HAVE_NDIR_H
d94 1
a94 1
static const char rcsid[] = "$Sudo: parse.c,v 1.136 2002/01/08 15:00:18 millert Exp $";
d115 2
a116 2
sudoers_lookup(pwflag)
    int pwflag;
a119 1
    int nopass;
d133 2
a134 1
    if (pwflag > 0)
d152 15
a166 4
    if (pwflag)
	pwcheck = (pwflag == -1) ? PWCHECK_NEVER : def_ival(pwflag);
    else
	pwcheck = 0;
a188 1
    nopass = -1;
d190 1
a190 1
	int found;
d194 2
d244 1
a244 3
    if (nopass == -1)
	nopass = 0;
    return(error | nopass);
d390 2
a391 7
	else {
	    i = 32 - atoi(m);
	    mask.s_addr = 0xffffffff;
	    mask.s_addr >>= i;
	    mask.s_addr <<= i;
	    mask.s_addr = htonl(mask.s_addr);
	}
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d115 2
a116 2
sudoers_lookup(pwflags)
    int pwflags;
d119 1
d132 3
a134 2
    /* For most pwflags to be useful we need to keep more state around. */
    if (pwflags && pwflags != PWCHECK_NEVER && pwflags != PWCHECK_ALWAYS)
d149 20
d176 1
a176 1
    if (pwflags) {
d185 1
a185 1
     * Only check the actual command if pwflags flag is not set.
d189 1
a189 1
    if (pwflags) {
d192 1
a192 1
	if (pwflags == PWCHECK_NEVER || !def_flag(I_AUTHENTICATE))
d200 1
a200 1
		if (pwflags == PWCHECK_ANY && no_passwd == TRUE)
d202 1
a202 1
		else if (pwflags == PWCHECK_ALL && nopass != 0)
@


1.3
log
@sudo 1.6.2
@
text
@d94 1
a94 1
static const char rcsid[] = "$Sudo: parse.c,v 1.127 2000/01/17 23:46:25 millert Exp $";
d389 22
d498 1
a498 1
    register char *t;
@


1.2
log
@sudo 1.6.1
@
text
@d2 1
a2 1
 * Copyright (c) 1996, 1998, 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d94 1
a94 1
static const char rcsid[] = "$Sudo: parse.c,v 1.123 1999/12/09 03:54:57 millert Exp $";
d101 1
d115 2
a116 2
sudoers_lookup(check_cmnd)
    int check_cmnd;
d131 4
d154 3
a156 1
    if (check_cmnd == TRUE) {
d160 1
a160 2
    } else
	error |= FLAG_NO_CHECK;
d163 2
a164 2
     * Only check the actual command if the check_cmnd flag is set.
     * It is not set for the "validate" and "list" pseudo-commands.
d167 8
a174 1
    if (check_cmnd == FALSE)
d177 5
a181 5
		/* User may always validate or list on allowed hosts */
		if (no_passwd == TRUE)
		    return(VALIDATE_OK | FLAG_NOPASS);
		else
		    return(VALIDATE_OK);
d185 6
a190 1
    else
d217 1
d427 1
a427 1
 * else return FALSE.  Either of "host" or "user" may be NULL
d431 1
a431 1
netgr_matches(netgr, host, user)
d434 1
d459 6
a464 2
    return(innetgr(netgr, host, user, domain));
#else
a465 1
#endif /* HAVE_INNETGR */
@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
#if defined(HAVE_FNMATCH) && defined(HAVE_FNMATCH_H)
d94 1
a94 1
static const char rcsid[] = "$Sudo: parse.c,v 1.121 1999/08/28 10:00:22 millert Exp $";
d145 4
a148 1
    error = VALIDATE_NOT_OK;
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
