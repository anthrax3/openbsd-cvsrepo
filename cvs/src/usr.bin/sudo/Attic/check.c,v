head	1.22;
access;
symbols
	OPENBSD_5_7:1.21.0.14
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.18
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.16
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.12
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.21;
commitid	8ra5qnWqy2bUhcZn;

1.21
date	2011.01.12.21.45.02;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.21.14.48.41;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.25.17.02.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.07.14.10.08;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.26.16.10.15;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.31.21.13.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.28.15.10.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.01.15.47.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.15.21.23.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.04.25.15.49.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.03.30.13.56.57;	author millert;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2000.06.05.14.01.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.27.03.44.38;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.18.17.20.22;	author millert;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.04.25.19.20.06;	author miod;	state Exp;
branches;
next	;

1.5.4.1
date	2002.01.18.16.14.44;	author millert;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.04.26.02.21.42;	author millert;	state Exp;
branches;
next	;

1.6.2.1
date	2002.04.25.19.59.22;	author millert;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1993-1996,1998-2005, 2007-2009
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#ifndef __TANDEM
# include <sys/file.h>
#endif
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>
#ifndef HAVE_TIMESPEC
# include <emul/timespec.h>
#endif

#include "sudo.h"

/* Status codes for timestamp_status() */
#define TS_CURRENT		0
#define TS_OLD			1
#define TS_MISSING		2
#define TS_NOFILE		3
#define TS_ERROR		4

/* Flags for timestamp_status() */
#define TS_MAKE_DIRS		1
#define TS_REMOVE		2

static void  build_timestamp	__P((char **, char **));
static int   timestamp_status	__P((char *, char *, char *, int));
static char *expand_prompt	__P((char *, char *, char *));
static void  lecture		__P((int));
static void  update_timestamp	__P((char *, char *));

/*
 * This function only returns if the user can successfully
 * verify who he/she is.
 */
void
check_user(validated, mode)
    int validated;
    int mode;
{
    char *timestampdir = NULL;
    char *timestampfile = NULL;
    char *prompt;
    int status;

    if (mode & MODE_INVALIDATE) {
	/* do not check or update timestamp */
	status = TS_ERROR;
    } else {
	/*
	 * Don't prompt for the root passwd or if the user is exempt.
	 * If the user is not changing uid/gid, no need for a password.
	 */
	if (user_uid == 0 || (user_uid == runas_pw->pw_uid &&
	    (!runas_gr || user_gid == runas_gr->gr_gid)) || user_is_exempt())
	    return;

	build_timestamp(&timestampdir, &timestampfile);
	status = timestamp_status(timestampdir, timestampfile, user_name,
	TS_MAKE_DIRS);
    }
    if (status != TS_CURRENT || ISSET(validated, FLAG_CHECK_USER)) {
	/* Bail out if we are non-interactive and a password is required */
	if (ISSET(mode, MODE_NONINTERACTIVE))
	    errorx(1, "sorry, a password is required to run %s", getprogname());

	/* If user specified -A, make sure we have an askpass helper. */
	if (ISSET(tgetpass_flags, TGP_ASKPASS)) {
	    if (user_askpass == NULL)
		log_error(NO_MAIL,
		    "no askpass program specified, try setting SUDO_ASKPASS");
	} else if (!ISSET(tgetpass_flags, TGP_STDIN)) {
	    /* If no tty but DISPLAY is set, use askpass if we have it. */
	    if (!user_ttypath && !tty_present()) {
		if (user_askpass && user_display && *user_display != '\0') {
		    SET(tgetpass_flags, TGP_ASKPASS);
		} else if (!def_visiblepw) {
		    log_error(NO_MAIL,
			"no tty present and no askpass program specified");
		}
	    }
	}

	if (!ISSET(tgetpass_flags, TGP_ASKPASS))
	    lecture(status);

	/* Expand any escapes in the prompt. */
	prompt = expand_prompt(user_prompt ? user_prompt : def_passprompt,
	    user_name, user_shost);

	verify_user(auth_pw, prompt);
    }
    /* Only update timestamp if user was validated. */
    if (status != TS_ERROR && ISSET(validated, VALIDATE_OK))
	update_timestamp(timestampdir, timestampfile);
    efree(timestampdir);
    efree(timestampfile);
}

/*
 * Standard sudo lecture.
 */
static void
lecture(status)
    int status;
{
    FILE *fp;
    char buf[BUFSIZ];
    ssize_t nread;

    if (def_lecture == never ||
	(def_lecture == once && status != TS_MISSING && status != TS_ERROR))
	return;

    if (def_lecture_file && (fp = fopen(def_lecture_file, "r")) != NULL) {
	while ((nread = fread(buf, sizeof(char), sizeof(buf), fp)) != 0)
	    fwrite(buf, nread, 1, stderr);
	fclose(fp);
    } else {
	(void) fputs("\n\
We trust you have received the usual lecture from the local System\n\
Administrator. It usually boils down to these three things:\n\
\n\
    #1) Respect the privacy of others.\n\
    #2) Think before you type.\n\
    #3) With great power comes great responsibility.\n\n",
    stderr);
    }
}

/*
 * Update the time on the timestamp file/dir or create it if necessary.
 */
static void
update_timestamp(timestampdir, timestampfile)
    char *timestampdir;
    char *timestampfile;
{
    if (timestamp_uid != 0)
	set_perms(PERM_TIMESTAMP);
    if (touch(-1, timestampfile ? timestampfile : timestampdir, NULL) == -1) {
	if (timestampfile) {
	    int fd = open(timestampfile, O_WRONLY|O_CREAT|O_TRUNC, 0600);

	    if (fd == -1)
		log_error(NO_EXIT|USE_ERRNO, "Can't open %s", timestampfile);
	    else
		close(fd);
	} else {
	    if (mkdir(timestampdir, 0700) == -1)
		log_error(NO_EXIT|USE_ERRNO, "Can't mkdir %s", timestampdir);
	}
    }
    if (timestamp_uid != 0)
	set_perms(PERM_ROOT);
}

/*
 * Expand %h and %u escapes in the prompt and pass back the dynamically
 * allocated result.  Returns the same string if there are no escapes.
 */
static char *
expand_prompt(old_prompt, user, host)
    char *old_prompt;
    char *user;
    char *host;
{
    size_t len, n;
    int subst;
    char *p, *np, *new_prompt, *endp;

    /* How much space do we need to malloc for the prompt? */
    subst = 0;
    for (p = old_prompt, len = strlen(old_prompt); *p; p++) {
	if (p[0] =='%') {
	    switch (p[1]) {
		case 'h':
		    p++;
		    len += strlen(user_shost) - 2;
		    subst = 1;
		    break;
		case 'H':
		    p++;
		    len += strlen(user_host) - 2;
		    subst = 1;
		    break;
		case 'p':
		    p++;
		    if (def_rootpw)
			    len += 2;
		    else if (def_targetpw || def_runaspw)
			    len += strlen(runas_pw->pw_name) - 2;
		    else
			    len += strlen(user_name) - 2;
		    subst = 1;
		    break;
		case 'u':
		    p++;
		    len += strlen(user_name) - 2;
		    subst = 1;
		    break;
		case 'U':
		    p++;
		    len += strlen(runas_pw->pw_name) - 2;
		    subst = 1;
		    break;
		case '%':
		    p++;
		    len--;
		    subst = 1;
		    break;
		default:
		    break;
	    }
	}
    }

    if (subst) {
	new_prompt = (char *) emalloc(++len);
	endp = new_prompt + len;
	for (p = old_prompt, np = new_prompt; *p; p++) {
	    if (p[0] =='%') {
		switch (p[1]) {
		    case 'h':
			p++;
			n = strlcpy(np, user_shost, np - endp);
			if (n >= np - endp)
			    goto oflow;
			np += n;
			continue;
		    case 'H':
			p++;
			n = strlcpy(np, user_host, np - endp);
			if (n >= np - endp)
			    goto oflow;
			np += n;
			continue;
		    case 'p':
			p++;
			if (def_rootpw)
				n = strlcpy(np, "root", np - endp);
			else if (def_targetpw || def_runaspw)
				n = strlcpy(np, runas_pw->pw_name, np - endp);
			else
				n = strlcpy(np, user_name, np - endp);
			if (n >= np - endp)
				goto oflow;
			np += n;
			continue;
		    case 'u':
			p++;
			n = strlcpy(np, user_name, np - endp);
			if (n >= np - endp)
			    goto oflow;
			np += n;
			continue;
		    case 'U':
			p++;
			n = strlcpy(np,  runas_pw->pw_name, np - endp);
			if (n >= np - endp)
			    goto oflow;
			np += n;
			continue;
		    case '%':
			/* convert %% -> % */
			p++;
			break;
		    default:
			/* no conversion */
			break;
		}
	    }
	    *np++ = *p;
	    if (np >= endp)
		goto oflow;
	}
	*np = '\0';
    } else
	new_prompt = old_prompt;

    return(new_prompt);

oflow:
    /* We pre-allocate enough space, so this should never happen. */
    errorx(1, "internal error, expand_prompt() overflow");
}

/*
 * Checks if the user is exempt from supplying a password.
 */
int
user_is_exempt()
{
    struct group *grp;
    char **gr_mem;

    if (!def_exempt_group)
	return(FALSE);

    if (!(grp = sudo_getgrnam(def_exempt_group)))
	return(FALSE);

    if (user_gid == grp->gr_gid)
	return(TRUE);

    for (gr_mem = grp->gr_mem; *gr_mem; gr_mem++) {
	if (strcmp(user_name, *gr_mem) == 0)
	    return(TRUE);
    }

    return(FALSE);
}

/*
 * Fills in timestampdir as well as timestampfile if using tty tickets.
 */
static void
build_timestamp(timestampdir, timestampfile)
    char **timestampdir;
    char **timestampfile;
{
    char *dirparent;
    int len;

    dirparent = def_timestampdir;
    len = easprintf(timestampdir, "%s/%s", dirparent, user_name);
    if (len >= PATH_MAX)
	log_error(0, "timestamp path too long: %s", *timestampdir);

    /*
     * Timestamp file may be a file in the directory or NUL to use
     * the directory as the timestamp.
     */
    if (def_tty_tickets) {
	char *p;

	if ((p = strrchr(user_tty, '/')))
	    p++;
	else
	    p = user_tty;
	if (def_targetpw)
	    len = easprintf(timestampfile, "%s/%s/%s:%s", dirparent, user_name,
		p, runas_pw->pw_name);
	else
	    len = easprintf(timestampfile, "%s/%s/%s", dirparent, user_name, p);
	if (len >= PATH_MAX)
	    log_error(0, "timestamp path too long: %s", *timestampfile);
    } else if (def_targetpw) {
	len = easprintf(timestampfile, "%s/%s/%s", dirparent, user_name,
	    runas_pw->pw_name);
	if (len >= PATH_MAX)
	    log_error(0, "timestamp path too long: %s", *timestampfile);
    } else
	*timestampfile = NULL;
}

/*
 * Check the timestamp file and directory and return their status.
 */
static int
timestamp_status(timestampdir, timestampfile, user, flags)
    char *timestampdir;
    char *timestampfile;
    char *user;
    int flags;
{
    struct stat sb;
    time_t now;
    char *dirparent = def_timestampdir;
    int status = TS_ERROR;		/* assume the worst */

    if (timestamp_uid != 0)
	set_perms(PERM_TIMESTAMP);

    /*
     * Sanity check dirparent and make it if it doesn't already exist.
     * We start out assuming the worst (that the dir is not sane) and
     * if it is ok upgrade the status to ``no timestamp file''.
     * Note that we don't check the parent(s) of dirparent for
     * sanity since the sudo dir is often just located in /tmp.
     */
    if (lstat(dirparent, &sb) == 0) {
	if (!S_ISDIR(sb.st_mode))
	    log_error(NO_EXIT, "%s exists but is not a directory (0%o)",
		dirparent, (unsigned int) sb.st_mode);
	else if (sb.st_uid != timestamp_uid)
	    log_error(NO_EXIT, "%s owned by uid %lu, should be uid %lu",
		dirparent, (unsigned long) sb.st_uid,
		(unsigned long) timestamp_uid);
	else if ((sb.st_mode & 0000022))
	    log_error(NO_EXIT,
		"%s writable by non-owner (0%o), should be mode 0700",
		dirparent, (unsigned int) sb.st_mode);
	else {
	    if ((sb.st_mode & 0000777) != 0700)
		(void) chmod(dirparent, 0700);
	    status = TS_MISSING;
	}
    } else if (errno != ENOENT) {
	log_error(NO_EXIT|USE_ERRNO, "can't stat %s", dirparent);
    } else {
	/* No dirparent, try to make one. */
	if (ISSET(flags, TS_MAKE_DIRS)) {
	    if (mkdir(dirparent, S_IRWXU))
		log_error(NO_EXIT|USE_ERRNO, "can't mkdir %s",
		    dirparent);
	    else
		status = TS_MISSING;
	}
    }
    if (status == TS_ERROR) {
	if (timestamp_uid != 0)
	    set_perms(PERM_ROOT);
	return(status);
    }

    /*
     * Sanity check the user's ticket dir.  We start by downgrading
     * the status to TS_ERROR.  If the ticket dir exists and is sane
     * this will be upgraded to TS_OLD.  If the dir does not exist,
     * it will be upgraded to TS_MISSING.
     */
    status = TS_ERROR;			/* downgrade status again */
    if (lstat(timestampdir, &sb) == 0) {
	if (!S_ISDIR(sb.st_mode)) {
	    if (S_ISREG(sb.st_mode)) {
		/* convert from old style */
		if (unlink(timestampdir) == 0)
		    status = TS_MISSING;
	    } else
		log_error(NO_EXIT, "%s exists but is not a directory (0%o)",
		    timestampdir, (unsigned int) sb.st_mode);
	} else if (sb.st_uid != timestamp_uid)
	    log_error(NO_EXIT, "%s owned by uid %lu, should be uid %lu",
		timestampdir, (unsigned long) sb.st_uid,
		(unsigned long) timestamp_uid);
	else if ((sb.st_mode & 0000022))
	    log_error(NO_EXIT,
		"%s writable by non-owner (0%o), should be mode 0700",
		timestampdir, (unsigned int) sb.st_mode);
	else {
	    if ((sb.st_mode & 0000777) != 0700)
		(void) chmod(timestampdir, 0700);
	    status = TS_OLD;		/* do date check later */
	}
    } else if (errno != ENOENT) {
	log_error(NO_EXIT|USE_ERRNO, "can't stat %s", timestampdir);
    } else
	status = TS_MISSING;

    /*
     * If there is no user ticket dir, AND we are in tty ticket mode,
     * AND the TS_MAKE_DIRS flag is set, create the user ticket dir.
     */
    if (status == TS_MISSING && timestampfile && ISSET(flags, TS_MAKE_DIRS)) {
	if (mkdir(timestampdir, S_IRWXU) == -1) {
	    status = TS_ERROR;
	    log_error(NO_EXIT|USE_ERRNO, "can't mkdir %s", timestampdir);
	}
    }

    /*
     * Sanity check the tty ticket file if it exists.
     */
    if (timestampfile && status != TS_ERROR) {
	if (status != TS_MISSING)
	    status = TS_NOFILE;			/* dir there, file missing */
	if (lstat(timestampfile, &sb) == 0) {
	    if (!S_ISREG(sb.st_mode)) {
		status = TS_ERROR;
		log_error(NO_EXIT, "%s exists but is not a regular file (0%o)",
		    timestampfile, (unsigned int) sb.st_mode);
	    } else {
		/* If bad uid or file mode, complain and kill the bogus file. */
		if (sb.st_uid != timestamp_uid) {
		    log_error(NO_EXIT,
			"%s owned by uid %lu, should be uid %lu",
			timestampfile, (unsigned long) sb.st_uid,
			(unsigned long) timestamp_uid);
		    (void) unlink(timestampfile);
		} else if ((sb.st_mode & 0000022)) {
		    log_error(NO_EXIT,
			"%s writable by non-owner (0%o), should be mode 0600",
			timestampfile, (unsigned int) sb.st_mode);
		    (void) unlink(timestampfile);
		} else {
		    /* If not mode 0600, fix it. */
		    if ((sb.st_mode & 0000777) != 0600)
			(void) chmod(timestampfile, 0600);

		    status = TS_OLD;	/* actually check mtime below */
		}
	    }
	} else if (errno != ENOENT) {
	    log_error(NO_EXIT|USE_ERRNO, "can't stat %s", timestampfile);
	    status = TS_ERROR;
	}
    }

    /*
     * If the file/dir exists and we are not removing it, check its mtime.
     */
    if (status == TS_OLD && !ISSET(flags, TS_REMOVE)) {
	/* Negative timeouts only expire manually (sudo -k). */
	if (def_timestamp_timeout < 0 && sb.st_mtime != 0)
	    status = TS_CURRENT;
	else {
	    /* XXX - should use timespec here */
	    now = time(NULL);
	    if (def_timestamp_timeout &&
		now - sb.st_mtime < 60 * def_timestamp_timeout) {
		/*
		 * Check for bogus time on the stampfile.  The clock may
		 * have been set back or someone could be trying to spoof us.
		 */
		if (sb.st_mtime > now + 60 * def_timestamp_timeout * 2) {
		    log_error(NO_EXIT,
			"timestamp too far in the future: %20.20s",
			4 + ctime(&sb.st_mtime));
		    if (timestampfile)
			(void) unlink(timestampfile);
		    else
			(void) rmdir(timestampdir);
		    status = TS_MISSING;
		} else
		    status = TS_CURRENT;
	    }
	}
    }

    if (timestamp_uid != 0)
	set_perms(PERM_ROOT);
    return(status);
}

/*
 * Remove the timestamp ticket file/dir.
 */
void
remove_timestamp(remove)
    int remove;
{
    struct timespec ts;
    char *timestampdir, *timestampfile, *path;
    int status;

    build_timestamp(&timestampdir, &timestampfile);
    status = timestamp_status(timestampdir, timestampfile, user_name,
	TS_REMOVE);
    if (status == TS_OLD || status == TS_CURRENT) {
	path = timestampfile ? timestampfile : timestampdir;
	if (remove) {
	    if (timestampfile)
		status = unlink(timestampfile);
	    else
		status = rmdir(timestampdir);
	    if (status == -1 && errno != ENOENT) {
		log_error(NO_EXIT, "can't remove %s (%s), will reset to Epoch",
		    path, strerror(errno));
		remove = FALSE;
	    }
	} else {
	    timespecclear(&ts);
	    if (touch(-1, path, &ts) == -1)
		error(1, "can't reset %s to Epoch", path);
	}
    }

    efree(timestampdir);
    efree(timestampfile);
}
@


1.21
log
@Backport fix from sudo 1.7.4p5; if -g specified w/o -u the target
user is considered to be different from the invoking user unless
the user's gid is the same as the target gid.
@
text
@@


1.20
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d96 6
a101 1
	if (user_uid == 0 || user_uid == runas_pw->pw_uid || user_is_exempt())
@


1.19
log
@Upgrade to sudo 1.7.2
@
text
@a60 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: check.c,v 1.247 2009/05/25 12:02:41 millert Exp $";
#endif /* lint */

@


1.18
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2005, 2007-2008
d62 1
a62 1
__unused static const char rcsid[] = "$Sudo: check.c,v 1.246 2009/02/24 13:04:39 millert Exp $";
@


1.17
log
@Even if neither stdin nor stdout are ttys we may still have /dev/tty
available to us.
@
text
@d62 1
a62 1
__unused static const char rcsid[] = "$Sudo: check.c,v 1.245 2008/11/25 17:01:34 millert Exp $";
d87 1
a87 1
check_user(validated, interactive)
d89 1
a89 1
    int interactive;
d96 6
a101 2
    if (user_uid == 0 || user_uid == runas_pw->pw_uid || user_is_exempt())
	return;
d103 2
a104 2
    build_timestamp(&timestampdir, &timestampfile);
    status = timestamp_status(timestampdir, timestampfile, user_name,
d106 1
d109 1
a109 1
	if (!interactive)
a146 1
 * TODO: allow the user to specify a file name instead.
@


1.16
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d62 1
a62 1
__unused static const char rcsid[] = "$Sudo: check.c,v 1.244 2008/11/11 18:28:08 millert Exp $";
d112 1
a112 1
	} else {
d114 1
a114 1
	    if (!user_ttypath && !ISSET(tgetpass_flags, TGP_STDIN)) {
@


1.15
log
@Update to sudo 1.6.9p11
@
text
@d2 2
a3 1
 * Copyright (c) 1993-1996,1998-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
a48 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d62 1
a62 1
__unused static const char rcsid[] = "$Sudo: check.c,v 1.223.2.10 2008/01/05 23:59:42 millert Exp $";
d87 1
a87 1
check_user(validated)
d89 1
d103 23
a125 1
	lecture(status);
d233 1
a233 1
			    len += strlen(*user_runas) - 2;
d245 1
a245 1
		    len += strlen(*user_runas) - 2;
d284 1
a284 1
				n = strlcpy(np, *user_runas, np - endp);
d300 1
a300 1
			n = strlcpy(np,  *user_runas, np - endp);
d326 1
a326 1
    errx(1, "internal error, expand_prompt() overflow");
d341 1
a341 1
    if (!(grp = getgrnam(def_exempt_group)))
d384 1
a384 1
		p, *user_runas);
d391 1
a391 1
	    *user_runas);
d606 1
a606 1
		err(1, "can't reset %s to Epoch", path);
@


1.14
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d66 1
a66 1
__unused static const char rcsid[] = "$Sudo: check.c,v 1.223.2.9 2007/07/06 19:52:13 millert Exp $";
d209 10
d258 12
@


1.13
log
@update to sudo 1.6.8p8
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d21 1
a21 1
#include "config.h"
d59 3
d66 1
a66 1
static const char rcsid[] = "$Sudo: check.c,v 1.226 2004/09/08 15:48:23 millert Exp $";
d76 4
d91 2
a92 2
check_user(override)
    int override;
d103 3
a105 2
    status = timestamp_status(timestampdir, timestampfile, user_name, TRUE);
    if (override || status != TS_CURRENT) {
d114 2
a115 1
    if (status != TS_ERROR)
d117 2
a118 3
    free(timestampdir);
    if (timestampfile)
	free(timestampfile);
d140 1
d361 1
a361 1
timestamp_status(timestampdir, timestampfile, user, make_dirs)
d365 1
a365 1
    int make_dirs;
d385 1
a385 1
		dirparent, sb.st_mode);
d393 1
a393 1
		dirparent, sb.st_mode);
d403 1
a403 1
	if (make_dirs) {
d432 1
a432 1
		    timestampdir, sb.st_mode);
d440 1
a440 1
		timestampdir, sb.st_mode);
d453 1
a453 1
     * AND the make_dirs flag is set, create the user ticket dir.
d455 1
a455 1
    if (status == TS_MISSING && timestampfile && make_dirs) {
d472 1
a472 1
		    timestampfile, sb.st_mode);
d484 1
a484 1
			timestampfile, sb.st_mode);
d501 1
a501 1
     * If the file/dir exists, check its mtime.
d503 1
a503 1
    if (status == TS_OLD) {
d548 2
a549 1
    status = timestamp_status(timestampdir, timestampfile, user_name, FALSE);
d569 2
a570 3
    free(timestampdir);
    if (timestampfile)
	free(timestampfile);
@


1.12
log
@Update to sudo 1.6.8p1
@
text
@d319 1
a319 1
	log_error(0, "timestamp path too long: %s", timestampdir);
d338 1
a338 1
	    log_error(0, "timestamp path too long: %s", timestampfile);
d343 1
a343 1
	    log_error(0, "timestamp path too long: %s", timestampfile);
d468 1
a468 1
			"%s owned by uid %ud, should be uid %lu",
@


1.11
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d2 1
a2 2
 * Copyright (c) 1993-1996,1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d26 3
a28 1
#include <sys/file.h>
d63 1
a63 1
static const char rcsid[] = "$Sudo: check.c,v 1.213 2003/04/16 00:42:09 millert Exp $";
d76 1
a76 1
static void  lecture		__P((void));
d81 1
a81 1
 * verify who he/she is.  
d84 2
a85 1
check_user()
d92 1
a92 1
    if (user_uid == 0 || user_is_exempt())
d97 2
a98 3
    if (status != TS_CURRENT) {
	if (status == TS_MISSING || status == TS_ERROR)
	    lecture();		/* first time through they get a lecture */
d101 1
a101 1
	prompt = expand_prompt(user_prompt ? user_prompt : def_str(I_PASSPROMPT),
d118 2
a119 1
lecture()
d121 7
d129 4
a132 1
    if (def_flag(I_LECTURE)) {
d135 1
a135 1
Administrator. It usually boils down to these two things:\n\
d137 4
a140 3
	#1) Respect the privacy of others.\n\
	#2) Think before you type.\n\n",
	stderr);
a151 1

d154 1
a154 1
    if (touch(timestampfile ? timestampfile : timestampdir, time(NULL)) == -1) {
d288 1
a288 1
    if (!def_str(I_EXEMPT_GROUP))
d291 1
a291 1
    if (!(grp = getgrnam(def_str(I_EXEMPT_GROUP))))
d316 1
a316 1
    dirparent = def_str(I_TIMESTAMPDIR);
d318 1
a318 1
    if (len >= MAXPATHLEN)
d325 1
a325 1
    if (def_flag(I_TTY_TICKETS)) {
d332 1
a332 1
	if (def_flag(I_TARGETPW))
d337 1
a337 1
	if (len >= MAXPATHLEN)
d339 1
a339 1
    } else if (def_flag(I_TARGETPW)) {
d342 1
a342 1
	if (len >= MAXPATHLEN)
d360 1
a360 1
    char *dirparent = def_str(I_TIMESTAMPDIR);
d496 1
a496 1
	if (def_ival(I_TIMESTAMP_TIMEOUT) < 0 && sb.st_mtime != 0)
d499 1
d501 2
a502 2
	    if (def_ival(I_TIMESTAMP_TIMEOUT) && 
		now - sb.st_mtime < 60 * def_ival(I_TIMESTAMP_TIMEOUT)) {
d507 1
a507 1
		if (sb.st_mtime > now + 60 * def_ival(I_TIMESTAMP_TIMEOUT) * 2) {
d534 2
a535 3
    char *timestampdir;
    char *timestampfile;
    char *ts;
d541 1
a541 1
	ts = timestampfile ? timestampfile : timestampdir;
d549 1
a549 1
		    ts, strerror(errno));
d552 4
a556 2
	if (!remove && touch(ts, 0) == -1)
	    err(1, "can't reset %s to Epoch", ts);
@


1.10
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d33 4
d79 1
a79 1
static const char rcsid[] = "$Sudo: check.c,v 1.212 2003/04/02 18:25:19 millert Exp $";
@


1.9
log
@Update to sudo 1.6.7p1; fixes false positives in the oflow detection
of expand_prompt() introduced in sudo 1.6.7.
@
text
@d60 5
d75 1
a75 1
static const char rcsid[] = "$Sudo: check.c,v 1.211 2003/04/01 14:58:55 millert Exp $";
d277 1
a277 3
    (void) fprintf(stderr, "%s: internal error, expand_prompt() overflow\n",
	Argv[0]);
    exit(1);
d549 1
a549 1
		log_error(NO_EXIT, "can't remove %s (%s), will reset to epoch",
d554 2
a555 4
	if (!remove && touch(ts, 0) == -1) {
	    (void) fprintf(stderr, "%s: can't reset %s to epoch: %s\n",
		Argv[0], ts, strerror(errno));
	}
@


1.8
log
@update to what will soon be sudo 1.6.7
@
text
@d70 1
a70 1
static const char rcsid[] = "$Sudo: check.c,v 1.210 2003/03/15 20:31:01 millert Exp $";
d219 1
a219 2
	*new_prompt = '\0';
	endp = new_prompt + len - 1;
d225 2
a226 1
			if ((n = strlcat(new_prompt, user_shost, len)) >= len)
d232 2
a233 1
			if ((n = strlcat(new_prompt, user_host, len)) >= len)
d239 2
a240 1
			if ((n = strlcat(new_prompt, user_name, len)) >= len)
d246 2
a247 1
			if ((n = strlcat(new_prompt, *user_runas, len)) >= len)
d260 1
a262 1
	    *np++ = *p;
@


1.7
log
@Update to sudo 1.6.6
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d70 1
a70 1
static const char rcsid[] = "$Sudo: check.c,v 1.203 2002/04/25 15:30:12 millert Exp $";
d148 2
d163 2
d177 1
a177 1
    size_t len;
d179 1
a179 1
    char *p, *np, *new_prompt, lastchar;
d183 30
a212 8
    for (p = old_prompt, len = strlen(old_prompt), lastchar = '\0'; *p; p++) {
	if (lastchar == '%') {
	    if (*p == 'h') {
		len += strlen(user_shost) - 2;
		subst = 1;
	    } else if (*p == 'u') {
		len += strlen(user_name) - 2;
		subst = 1;
a214 6

	if (lastchar == '%' && *p == '%') {
	    lastchar = '\0';
	    len--;
	} else
	    lastchar = *p;
d218 37
a254 12
	new_prompt = (char *) emalloc(len + 1);
	for (p = old_prompt, np = new_prompt, lastchar = '\0'; *p; p++) {
	    if (lastchar == '%' && (*p == 'h' || *p == 'u' || *p == '%')) {
		/* substitute user/host name */
		if (*p == 'h') {
		    np--;
		    strcpy(np, user_shost);
		    np += strlen(user_shost);
		} else if (*p == 'u') {
		    np--;
		    strcpy(np, user_name);
		    np += strlen(user_name);
d256 4
a259 7
	    } else
		*np++ = *p;

	    if (lastchar == '%' && *p == '%')
		lastchar = '\0';
	    else
		lastchar = *p;
d266 6
d358 3
d372 4
a375 3
	else if (sb.st_uid != 0)
	    log_error(NO_EXIT, "%s owned by uid %ld, should be owned by root",
		dirparent, (long) sb.st_uid);
d397 3
a399 1
    if (status == TS_ERROR)
d401 1
d419 4
a422 3
	} else if (sb.st_uid != 0)
	    log_error(NO_EXIT, "%s owned by uid %ld, should be owned by root",
		timestampdir, (long) sb.st_uid);
d461 1
a461 1
		if (sb.st_uid != 0) {
d463 3
a465 2
			"%s owned by uid %ld, should be owned by root",
			timestampfile, (long) sb.st_uid);
d516 2
@


1.6
log
@Update to sudo 1.6.4
@
text
@d70 1
a70 1
static const char rcsid[] = "$Sudo: check.c,v 1.202 2001/12/14 19:52:47 millert Exp $";
d199 1
a199 1
	for (p = old_prompt, np = new_prompt; *p; p++) {
d201 1
a201 1
		/* substiture user/host name */
@


1.6.2.1
log
@A bug in sudo may allow an attacker to corrupt the heap by specifying a
custom prompt.  errata entry #2
@
text
@d199 1
a199 1
	for (p = old_prompt, np = new_prompt, lastchar = '\0'; *p; p++) {
d201 1
a201 1
		/* substitute user/host name */
@


1.5
log
@Use stashed user_gid when checking against exempt gid since sudo
sets its gid to SUDOERS_GID, making getgid() return that, not the
real gid.  FIxes problem with setting exempt group == SUDOERS_GID.
Fix from Paul Kranenburg.
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 4
d43 6
a48 1
#include <stdlib.h>
d50 7
d58 1
a58 1
#include <unistd.h>
a59 6
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
a63 4
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
d70 1
a70 1
static const char rcsid[] = "$Sudo: check.c,v 1.194 2000/02/15 23:36:03 millert Exp $";
d235 1
a235 1
    if (!def_str(I_EXEMPT_GRP))
d238 1
a238 1
    if (!(grp = getgrnam(def_str(I_EXEMPT_GRP))))
d433 23
a455 18
	now = time(NULL);
	if (def_ival(I_TS_TIMEOUT) && 
	    now - sb.st_mtime < 60 * def_ival(I_TS_TIMEOUT)) {
	    /*
	     * Check for bogus time on the stampfile.  The clock may
	     * have been set back or someone could be trying to spoof us.
	     */
	    if (sb.st_mtime > now + 60 * def_ival(I_TS_TIMEOUT) * 2) {
		log_error(NO_EXIT,
		    "timestamp too far in the future: %20.20s",
		    4 + ctime(&sb.st_mtime));
		if (timestampfile)
		    (void) unlink(timestampfile);
		else
		    (void) rmdir(timestampdir);
		status = TS_MISSING;
	    } else
		status = TS_CURRENT;
@


1.5.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 3
a49 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d54 4
d64 1
a64 1
static const char rcsid[] = "$Sudo: check.c,v 1.202 2001/12/14 19:52:47 millert Exp $";
d229 1
a229 1
    if (!def_str(I_EXEMPT_GROUP))
d232 1
a232 1
    if (!(grp = getgrnam(def_str(I_EXEMPT_GROUP))))
d427 18
a444 23
	/* Negative timeouts only expire manually (sudo -k). */
	if (def_ival(I_TIMESTAMP_TIMEOUT) < 0 && sb.st_mtime != 0)
	    status = TS_CURRENT;
	else {
	    now = time(NULL);
	    if (def_ival(I_TIMESTAMP_TIMEOUT) && 
		now - sb.st_mtime < 60 * def_ival(I_TIMESTAMP_TIMEOUT)) {
		/*
		 * Check for bogus time on the stampfile.  The clock may
		 * have been set back or someone could be trying to spoof us.
		 */
		if (sb.st_mtime > now + 60 * def_ival(I_TIMESTAMP_TIMEOUT) * 2) {
		    log_error(NO_EXIT,
			"timestamp too far in the future: %20.20s",
			4 + ctime(&sb.st_mtime));
		    if (timestampfile)
			(void) unlink(timestampfile);
		    else
			(void) rmdir(timestampdir);
		    status = TS_MISSING;
		} else
		    status = TS_CURRENT;
	    }
@


1.5.2.2
log
@Errata #25, from millert@@
A bug in sudo may allow an attacker to corrupt the heap by specifying a
custom prompt.
@
text
@d199 1
a199 1
	for (p = old_prompt, np = new_prompt, lastchar = '\0'; *p; p++) {
d201 1
a201 1
		/* substitute user/host name */
@


1.5.4.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 4
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 3
a49 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d54 4
d64 1
a64 1
static const char rcsid[] = "$Sudo: check.c,v 1.202 2001/12/14 19:52:47 millert Exp $";
d229 1
a229 1
    if (!def_str(I_EXEMPT_GROUP))
d232 1
a232 1
    if (!(grp = getgrnam(def_str(I_EXEMPT_GROUP))))
d427 18
a444 23
	/* Negative timeouts only expire manually (sudo -k). */
	if (def_ival(I_TIMESTAMP_TIMEOUT) < 0 && sb.st_mtime != 0)
	    status = TS_CURRENT;
	else {
	    now = time(NULL);
	    if (def_ival(I_TIMESTAMP_TIMEOUT) && 
		now - sb.st_mtime < 60 * def_ival(I_TIMESTAMP_TIMEOUT)) {
		/*
		 * Check for bogus time on the stampfile.  The clock may
		 * have been set back or someone could be trying to spoof us.
		 */
		if (sb.st_mtime > now + 60 * def_ival(I_TIMESTAMP_TIMEOUT) * 2) {
		    log_error(NO_EXIT,
			"timestamp too far in the future: %20.20s",
			4 + ctime(&sb.st_mtime));
		    if (timestampfile)
			(void) unlink(timestampfile);
		    else
			(void) rmdir(timestampdir);
		    status = TS_MISSING;
		} else
		    status = TS_CURRENT;
	    }
@


1.5.4.2
log
@A bug in sudo may allow an attacker to corrupt the heap by specifying a
custom prompt.  errata entry #20
@
text
@d199 1
a199 1
	for (p = old_prompt, np = new_prompt, lastchar = '\0'; *p; p++) {
d201 1
a201 1
		/* substitute user/host name */
@


1.4
log
@Update to sudo 1.6.3p4
@
text
@d235 1
a235 1
    if (getgid() == grp->gr_gid)
@


1.3
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d105 1
a105 1
	verify_user(prompt);
d254 2
a255 1
    char *dirparent = def_str(I_TIMESTAMPDIR);
d257 9
d273 13
a285 9
	if (strlen(dirparent) + strlen(user_name) + strlen(p) + 3 > MAXPATHLEN)
	    log_error(0, "timestamp path too long: %s/%s/%s", dirparent,
		user_name, p);
	easprintf(timestampdir, "%s/%s", dirparent, user_name);
	easprintf(timestampfile, "%s/%s/%s", dirparent, user_name, p);
    } else {
	if (strlen(dirparent) + strlen(user_name) + 2 > MAXPATHLEN)
	    log_error(0, "timestamp path too long: %s/%s", dirparent, user_name);
	easprintf(timestampdir, "%s/%s", dirparent, user_name);
a286 1
    }
@


1.2
log
@sudo 1.6.1
@
text
@d64 1
a64 1
static const char rcsid[] = "$Sudo: check.c,v 1.193 1999/12/05 02:54:20 millert Exp $";
a73 1
       int   user_is_exempt	__P((void));
@


1.1
log
@Initial revision
@
text
@d64 1
a64 1
static const char rcsid[] = "$Sudo: check.c,v 1.192 1999/10/07 21:20:55 millert Exp $";
d460 1
a460 1
	    if (status == -1) {
d462 1
a462 1
		    strerror(errno), ts);
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
