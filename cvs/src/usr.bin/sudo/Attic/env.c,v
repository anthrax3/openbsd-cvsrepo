head	1.27;
access;
symbols
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.18
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.14
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.13.0.10
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_2_9:1.3.0.4
	OPENBSD_3_0:1.3.0.2;
locks; strict;
comment	@ * @;


1.27
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.26;
commitid	8ra5qnWqy2bUhcZn;

1.26
date	2015.02.10.12.59.01;	author millert;	state Exp;
branches;
next	1.25;
commitid	qN7FSJzA8nOOyheQ;

1.25
date	2014.04.24.16.29.48;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.08.21.11.31;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.02.19.30.10;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.24.13.55.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.31.16.44.03;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.01.22.36.04;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.29.22.07.09;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.06.15.56.27;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.05.23.31.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.17.18.14.06;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.12.16.37.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.08.20.55.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.25.15.49.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.16.18.09.13;	author millert;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2002.01.15.02.17.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	;

1.3.2.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;

1.3.4.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 2000-2005, 2007-2009
 *	Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <ctype.h>
#include <errno.h>
#include <pwd.h>

#include "sudo.h"

/*
 * Flags used in rebuild_env()
 */
#undef DID_TERM
#define DID_TERM	0x0001
#undef DID_PATH
#define DID_PATH	0x0002
#undef DID_HOME
#define DID_HOME	0x0004
#undef DID_SHELL
#define DID_SHELL	0x0008
#undef DID_LOGNAME
#define DID_LOGNAME	0x0010
#undef DID_USER
#define DID_USER    	0x0020
#undef DID_USERNAME
#define DID_USERNAME   	0x0040
#undef DID_MAX
#define DID_MAX    	0x00ff

#undef KEPT_TERM
#define KEPT_TERM	0x0100
#undef KEPT_PATH
#define KEPT_PATH	0x0200
#undef KEPT_HOME
#define KEPT_HOME	0x0400
#undef KEPT_SHELL
#define KEPT_SHELL	0x0800
#undef KEPT_LOGNAME
#define KEPT_LOGNAME	0x1000
#undef KEPT_USER
#define KEPT_USER    	0x2000
#undef KEPT_USERNAME
#define KEPT_USERNAME	0x4000
#undef KEPT_MAX
#define KEPT_MAX    	0xff00

#undef VNULL
#define	VNULL	(void *)NULL

struct environment {
    char **envp;		/* pointer to the new environment */
    size_t env_size;		/* size of new_environ in char **'s */
    size_t env_len;		/* number of slots used, not counting NULL */
};

/*
 * Prototypes
 */
void rebuild_env		__P((int, int));
static void sudo_setenv		__P((const char *, const char *, int));
static void sudo_putenv		__P((char *, int, int));

extern char **environ;		/* global environment */

/*
 * Copy of the sudo-managed environment.
 */
static struct environment env;

/*
 * Default table of "bad" variables to remove from the environment.
 * XXX - how to omit TERMCAP if it starts with '/'?
 */
static const char *initial_badenv_table[] = {
    "IFS",
    "CDPATH",
    "LOCALDOMAIN",
    "RES_OPTIONS",
    "HOSTALIASES",
    "NLSPATH",
    "PATH_LOCALE",
    "LD_*",
    "_RLD*",
#ifdef __hpux
    "SHLIB_PATH",
#endif /* __hpux */
#ifdef _AIX
    "LDR_*",
    "LIBPATH",
    "AUTHSTATE",
#endif
#ifdef __APPLE__
    "DYLD_*",
#endif
#ifdef HAVE_KERB4
    "KRB_CONF*",
    "KRBCONFDIR",
    "KRBTKFILE",
#endif /* HAVE_KERB4 */
#ifdef HAVE_KERB5
    "KRB5_CONFIG*",
    "KRB5_KTNAME",
#endif /* HAVE_KERB5 */
#ifdef HAVE_SECURID
    "VAR_ACE",
    "USR_ACE",
    "DLC_ACE",
#endif /* HAVE_SECURID */
    "TERMINFO",			/* terminfo, exclusive path to terminfo files */
    "TERMINFO_DIRS",		/* terminfo, path(s) to terminfo files */
    "TERMPATH",			/* termcap, path(s) to termcap files */
    "TERMCAP",			/* XXX - only if it starts with '/' */
    "ENV",			/* ksh, file to source before script runs */
    "BASH_ENV",			/* bash, file to source before script runs */
    "PS4",			/* bash, prefix for lines in xtrace mode */
    "GLOBIGNORE",		/* bash, globbing patterns to ignore */
    "SHELLOPTS",		/* bash, extra command line options */
    "JAVA_TOOL_OPTIONS",	/* java, extra command line options */
    "PERLIO_DEBUG ",		/* perl, debugging output file */
    "PERLLIB",			/* perl, search path for modules/includes */
    "PERL5LIB",			/* perl 5, search path for modules/includes */
    "PERL5OPT",			/* perl 5, extra command line options */
    "PERL5DB",			/* perl 5, command used to load debugger */
    "FPATH",			/* ksh, search path for functions */
    "NULLCMD",			/* zsh, command for null file redirection */
    "READNULLCMD",		/* zsh, command for null file redirection */
    "ZDOTDIR",			/* zsh, search path for dot files */
    "TMPPREFIX",		/* zsh, prefix for temporary files */
    "PYTHONHOME",		/* python, module search path */
    "PYTHONPATH",		/* python, search path */
    "PYTHONINSPECT",		/* python, allow inspection */
    "RUBYLIB",			/* ruby, library load path */
    "RUBYOPT",			/* ruby, extra command line options */
    NULL
};

/*
 * Default table of variables to check for '%' and '/' characters.
 */
static const char *initial_checkenv_table[] = {
    "COLORTERM",
    "LANG",
    "LANGUAGE",
    "LC_*",
    "LINGUAS",
    "TERM",
    "TZ",
    NULL
};

/*
 * Default table of variables to preserve in the environment.
 */
static const char *initial_keepenv_table[] = {
    "COLORS",
    "DISPLAY",
    "HOME",
    "HOSTNAME",
    "KRB5CCNAME",
    "LS_COLORS",
    "MAIL",
    "PATH",
    "PS1",
    "PS2",
    "XAUTHORITY",
    "XAUTHORIZATION",
    NULL
};

/*
 * Similar to setenv(3) but operates on sudo's private copy of the environment
 * (not environ) and it always overwrites.  The dupcheck param determines
 * whether we need to verify that the variable is not already set.
 */
static void
sudo_setenv(var, val, dupcheck)
    const char *var;
    const char *val;
    int dupcheck;
{
    char *estring;
    size_t esize;

    esize = strlen(var) + 1 + strlen(val) + 1;
    estring = emalloc(esize);

    /* Build environment string and insert it. */
    if (strlcpy(estring, var, esize) >= esize ||
	strlcat(estring, "=", esize) >= esize ||
	strlcat(estring, val, esize) >= esize) {

	errorx(1, "internal error, sudo_setenv() overflow");
    }
    sudo_putenv(estring, dupcheck, TRUE);
}

/*
 * Version of setenv(3) that uses our own environ pointer.
 * Will sync with environ as needed.
 */
int
setenv(var, val, overwrite)
    const char *var;
    const char *val;
    int overwrite;
{
    char *estring, *ep;
    const char *cp;
    size_t esize;

    if (!var || *var == '\0')
	return(EINVAL);

    /*
     * POSIX says a var name with '=' is an error but BSD
     * just ignores the '=' and anything after it.
     */
    for (cp = var; *cp && *cp != '='; cp++)
	;
    esize = (size_t)(cp - var) + 2;
    if (val) {
	esize += strlen(val);	/* glibc treats a NULL val as "" */
    }

    /* Allocate and fill in estring. */
    estring = ep = emalloc(esize);
    for (cp = var; *cp && *cp != '='; cp++)
	*ep++ = *cp;
    *ep++ = '=';
    if (val) {
	for (cp = val; *cp; cp++)
	    *ep++ = *cp;
    }
    *ep = '\0';

    /* Sync env.envp with environ as needed. */
    if (env.envp != environ) {
	char **ep;
	size_t len;

	for (ep = environ; *ep != NULL; ep++)
	    continue;
	len = ep - environ;
	if (len + 2 > env.env_size) {
	    efree(env.envp);
	    env.env_size = len + 2 + 128;
	    env.envp = emalloc2(env.env_size, sizeof(char *));
#ifdef ENV_DEBUG
	    memset(env.envp, 0, env.env_size * sizeof(char *));
#endif
	}
	memcpy(env.envp, environ, len * sizeof(char *));
	env.envp[len] = NULL;
	env.env_len = len;
	environ = env.envp;
#ifdef ENV_DEBUG
    } else {
	if (env.envp[env.env_len] != NULL)
	    errorx(1, "setenv: corrupted envp, len mismatch");
#endif
    }
    sudo_putenv(estring, TRUE, overwrite);
    return(0);
}

/*
 * Version of unsetenv(3) that uses our own environ pointer.
 * Will sync with environ as needed.
 */
#ifdef UNSETENV_VOID
void
#else
int
#endif
unsetenv(var)
    const char *var;
{
    char **ep;
    size_t len;

    if (var == NULL || *var == '\0' || strchr(var, '=') != NULL) {
	errno = EINVAL;
#ifdef UNSETENV_VOID
	return;
#else
	return(-1);
#endif
    }

    /* Make sure we are operating on the current environment. */
    /* XXX - this could be optimized to include the search */
    if (env.envp != environ) {
	for (ep = environ; *ep != NULL; ep++)
	    continue;
	len = ep - environ;
	if (len + 1 > env.env_size) {
	    efree(env.envp);
	    env.env_size = len + 1 + 128;
	    env.envp = emalloc2(env.env_size, sizeof(char *));
#ifdef ENV_DEBUG
	    memset(env.envp, 0, env.env_size * sizeof(char *));
#endif
	}
	memcpy(env.envp, environ, len * sizeof(char *));
	env.envp[len] = NULL;
	env.env_len = len;
	environ = env.envp;
#ifdef ENV_DEBUG
    } else {
	if (env.envp[env.env_len] != NULL)
	    errorx(1, "unsetenv: corrupted envp, len mismatch");
#endif
    }

    len = strlen(var);
    for (ep = env.envp; *ep != NULL;) {
	if (strncmp(var, *ep, len) == 0 && (*ep)[len] == '=') {
	    /* Found it; shift remainder + NULL over by one. */
	    char **cur = ep;
	    while ((*cur = *(cur + 1)) != NULL)
		cur++;
	    /* Keep going, could be multiple instances of the var. */
	} else {
	    ep++;
	}
    }
    env.env_len = ep - env.envp;
#ifndef UNSETENV_VOID
    return(0);
#endif
}

/*
 * Version of putenv(3) that uses our own environ pointer.
 * Will sync with environ as needed.
 */
int
#ifdef PUTENV_CONST
putenv(const char *string)
#else
putenv(string)
    char *string;
#endif
{
    if (strchr(string, '=') == NULL) {
	errno = EINVAL;
	return(-1);
    }
    /* Sync env.envp with environ as needed. */
    if (env.envp != environ) {
	char **ep;
	size_t len;

	for (ep = environ; *ep != NULL; ep++)
	    continue;
	len = ep - environ;
	if (len + 2 > env.env_size) {
	    efree(env.envp);
	    env.env_size = len + 2 + 128;
	    env.envp = emalloc2(env.env_size, sizeof(char *));
#ifdef ENV_DEBUG
	    memset(env.envp, 0, env.env_size * sizeof(char *));
#endif
	}
	memcpy(env.envp, environ, len * sizeof(char *));
	env.envp[len] = NULL;
	env.env_len = len;
	environ = env.envp;
#ifdef ENV_DEBUG
    } else {
	if (env.envp[env.env_len] != NULL)
	    errorx(1, "putenv: corrupted envp, len mismatch");
#endif
    }
    sudo_putenv((char *)string, TRUE, TRUE);
    return(0);
}

/*
 * Similar to putenv(3) but operates on sudo's private copy of the
 * environment (not environ) and it always overwrites.  The dupcheck param
 * determines whether we need to verify that the variable is not already set.
 * Will only overwrite an existing variable if overwrite is set.
 */
static void
sudo_putenv(str, dupcheck, overwrite)
    char *str;
    int dupcheck;
    int overwrite;
{
    char **ep;
    size_t len;
    int found = FALSE;

    /* Make sure there is room for the new entry plus a NULL. */
    if (env.env_len + 2 > env.env_size) {
	env.env_size += 128;
	env.envp = erealloc3(env.envp, env.env_size, sizeof(char *));
#ifdef ENV_DEBUG
	memset(env.envp + env.env_len, 0,
	    (env.env_size - env.env_len) * sizeof(char *));
#endif
	environ = env.envp;
    }

#ifdef ENV_DEBUG
    if (env.envp[env.env_len] != NULL)
	errorx(1, "sudo_putenv: corrupted envp, len mismatch");
#endif

    if (dupcheck) {
	len = (strchr(str, '=') - str) + 1;
	for (ep = env.envp; !found && *ep != NULL; ep++) {
	    if (strncmp(str, *ep, len) == 0) {
		if (overwrite)
		    *ep = str;
		found = TRUE;
	    }
	}
	/* Prune out duplicate variables. */
	if (found && overwrite) {
	    while (*ep != NULL) {
		if (strncmp(str, *ep, len) == 0) {
		    char **cur = ep;
		    while ((*cur = *(cur + 1)) != NULL)
			cur++;
		} else {
		    ep++;
		}
	    }
	    env.env_len = ep - env.envp;
	}
    }

    if (!found) {
	ep = env.envp + env.env_len;
	env.env_len++;
	*ep++ = str;
	*ep = NULL;
    }
}

/*
 * Check the env_delete blacklist.
 * Returns TRUE if the variable was found, else false.
 */
static int
matches_env_delete(var)
    const char *var;
{
    struct list_member *cur;
    size_t len;
    int iswild, match = FALSE;

    /* Skip anything listed in env_delete. */
    for (cur = def_env_delete; cur; cur = cur->next) {
	len = strlen(cur->value);
	/* Deal with '*' wildcard */
	if (cur->value[len - 1] == '*') {
	    len--;
	    iswild = TRUE;
	} else
	    iswild = FALSE;
	if (strncmp(cur->value, var, len) == 0 &&
	    (iswild || var[len] == '=')) {
	    match = TRUE;
	    break;
	}
    }
    return(match);
}

/*
 * Sanity-check the TZ environment variable.
 * On many systems it is possible to set this to a pathname.
 */
static int
tz_is_sane(tzval)
    const char *tzval;
{
    const char *cp;
    char lastch;

    /* tzcode treats a value beginning with a ':' as a path. */
    if (tzval[0] == ':')
	tzval++;

    /* Reject fully-qualified TZ that doesn't being with the zoneinfo dir. */
    if (tzval[0] == '/') {
#ifdef _PATH_ZONEINFO
	if (strncmp(tzval, _PATH_ZONEINFO, sizeof(_PATH_ZONEINFO) - 1) != 0 ||
	    tzval[sizeof(_PATH_ZONEINFO) - 1] != '/')
	    return FALSE;
#else
	/* Assume the worst. */
	return FALSE;
#endif
    }

    /*
     * Make sure TZ only contains printable non-space characters
     * and does not contain a '..' path element.
     */
    lastch = '/';
    for (cp = tzval; *cp != '\0'; cp++) {
	if (isspace((unsigned char)*cp) || !isprint((unsigned char)*cp))
	    return FALSE;
	if (lastch == '/' && cp[0] == '.' && cp[1] == '.' &&
	    (cp[2] == '/' || cp[2] == '\0'))
	    return FALSE;
	lastch = *cp;
    }

    /* Reject extra long TZ values (even if not a path). */
    if ((size_t)(cp - tzval) >= PATH_MAX)
	return FALSE;

    return TRUE;
}

/*
 * Apply the env_check list.
 * Returns TRUE if the variable is allowed, FALSE if denied
 * or -1 if no match.
 */
static int
matches_env_check(var)
    const char *var;
{
    struct list_member *cur;
    size_t len;
    int iswild, keepit = -1;

    for (cur = def_env_check; cur; cur = cur->next) {
	len = strlen(cur->value);
	/* Deal with '*' wildcard */
	if (cur->value[len - 1] == '*') {
	    len--;
	    iswild = TRUE;
	} else
	    iswild = FALSE;
	if (strncmp(cur->value, var, len) == 0 &&
	    (iswild || var[len] == '=')) {
	    if (strncmp(var, "TZ=", 3) == 0) {
		/* Special case for TZ */
		keepit = tz_is_sane(var + 3);
	    } else {
		keepit = !strpbrk(var, "/%");
	    }
	    break;
	}
    }
    return(keepit);
}

/*
 * Check the env_keep list.
 * Returns TRUE if the variable is allowed else FALSE.
 */
static int
matches_env_keep(var)
    const char *var;
{
    struct list_member *cur;
    size_t len;
    int iswild, keepit = FALSE;

    for (cur = def_env_keep; cur; cur = cur->next) {
	len = strlen(cur->value);
	/* Deal with '*' wildcard */
	if (cur->value[len - 1] == '*') {
	    len--;
	    iswild = TRUE;
	} else
	    iswild = FALSE;
	if (strncmp(cur->value, var, len) == 0 &&
	    (iswild || var[len] == '=')) {
	    keepit = TRUE;
	    break;
	}
    }
    return(keepit);
}

/*
 * Build a new environment and ether clear potentially dangerous
 * variables from the old one or start with a clean slate.
 * Also adds sudo-specific variables (SUDO_*).
 */
void
rebuild_env(sudo_mode, noexec)
    int sudo_mode;
    int noexec;
{
    char **old_envp, **ep, *cp, *ps1;
    char idbuf[MAX_UID_T_LEN];
    unsigned int didvar;

    /*
     * Either clean out the environment or reset to a safe default.
     */
    ps1 = NULL;
    didvar = 0;
    env.env_len = 0;
    env.env_size = 128;
    old_envp = env.envp;
    env.envp = emalloc2(env.env_size, sizeof(char *));
#ifdef ENV_DEBUG
    memset(env.envp, 0, env.env_size * sizeof(char *));
#endif
    if (def_env_reset || ISSET(sudo_mode, MODE_LOGIN_SHELL)) {
	/* Pull in vars we want to keep from the old environment. */
	for (ep = environ; *ep; ep++) {
	    int keepit;

	    /* Skip variables with values beginning with () (bash functions) */
	    if ((cp = strchr(*ep, '=')) != NULL) {
		if (strncmp(cp, "=() ", 3) == 0)
		    continue;
	    }

	    /*
	     * First check certain variables for '%' and '/' characters.
	     * If no match there, check the keep list.
	     * If nothing matched, we remove it from the environment.
	     */
	    keepit = matches_env_check(*ep);
	    if (keepit == -1)
		keepit = matches_env_keep(*ep);

	    /* For SUDO_PS1 -> PS1 conversion. */
	    if (strncmp(*ep, "SUDO_PS1=", 8) == 0)
		ps1 = *ep + 5;

	    if (keepit) {
		/* Preserve variable. */
		switch (**ep) {
		    case 'H':
			if (strncmp(*ep, "HOME=", 5) == 0)
			    SET(didvar, DID_HOME);
			break;
		    case 'L':
			if (strncmp(*ep, "LOGNAME=", 8) == 0)
			    SET(didvar, DID_LOGNAME);
			break;
		    case 'P':
			if (strncmp(*ep, "PATH=", 5) == 0)
			    SET(didvar, DID_PATH);
			break;
		    case 'S':
			if (strncmp(*ep, "SHELL=", 6) == 0)
			    SET(didvar, DID_SHELL);
			break;
		    case 'T':
			if (strncmp(*ep, "TERM=", 5) == 0)
			    SET(didvar, DID_TERM);
			break;
		    case 'U':
			if (strncmp(*ep, "USER=", 5) == 0)
			    SET(didvar, DID_USER);
			if (strncmp(*ep, "USERNAME=", 5) == 0)
			    SET(didvar, DID_USERNAME);
			break;
		}
		sudo_putenv(*ep, FALSE, FALSE);
	    }
	}
	didvar |= didvar << 8;		/* convert DID_* to KEPT_* */

	/*
	 * Add in defaults.  In -i mode these come from the runas user,
	 * otherwise they may be from the user's environment (depends
	 * on sudoers options).
	 */
	if (ISSET(sudo_mode, MODE_LOGIN_SHELL)) {
	    sudo_setenv("HOME", runas_pw->pw_dir, ISSET(didvar, DID_HOME));
	    sudo_setenv("SHELL", runas_pw->pw_shell, ISSET(didvar, DID_SHELL));
	    sudo_setenv("LOGNAME", runas_pw->pw_name,
		ISSET(didvar, DID_LOGNAME));
	    sudo_setenv("USER", runas_pw->pw_name, ISSET(didvar, DID_USER));
	    sudo_setenv("USERNAME", runas_pw->pw_name,
		ISSET(didvar, DID_USERNAME));
	} else {
	    if (!ISSET(didvar, DID_HOME))
		sudo_setenv("HOME", user_dir, FALSE);
	    if (!ISSET(didvar, DID_SHELL))
		sudo_setenv("SHELL", sudo_user.pw->pw_shell, FALSE);
	    if (!ISSET(didvar, DID_LOGNAME))
		sudo_setenv("LOGNAME", user_name, FALSE);
	    if (!ISSET(didvar, DID_USER))
		sudo_setenv("USER", user_name, FALSE);
	    if (!ISSET(didvar, DID_USERNAME))
		sudo_setenv("USERNAME", user_name, FALSE);
	}
    } else {
	/*
	 * Copy environ entries as long as they don't match env_delete or
	 * env_check.
	 */
	for (ep = environ; *ep; ep++) {
	    int okvar;

	    /* Skip variables with values beginning with () (bash functions) */
	    if ((cp = strchr(*ep, '=')) != NULL) {
		if (strncmp(cp, "=() ", 3) == 0)
		    continue;
	    }

	    /*
	     * First check variables against the blacklist in env_delete.
	     * If no match there check for '%' and '/' characters.
	     */
	    okvar = matches_env_delete(*ep) != TRUE;
	    if (okvar)
		okvar = matches_env_check(*ep) != FALSE;

	    if (okvar) {
		if (strncmp(*ep, "SUDO_PS1=", 9) == 0)
		    ps1 = *ep + 5;
		else if (strncmp(*ep, "PATH=", 5) == 0)
		    SET(didvar, DID_PATH);
		else if (strncmp(*ep, "TERM=", 5) == 0)
		    SET(didvar, DID_TERM);
		sudo_putenv(*ep, FALSE, FALSE);
	    }
	}
    }
    /* Replace the PATH envariable with a secure one? */
    if (def_secure_path && !user_is_exempt()) {
	sudo_setenv("PATH", def_secure_path, TRUE);
	SET(didvar, DID_PATH);
    }

    /* Set $USER, $LOGNAME and $USERNAME to target if "set_logname" is true. */
    /* XXX - not needed for MODE_LOGIN_SHELL */
    if (def_set_logname && runas_pw->pw_name) {
	if (!ISSET(didvar, KEPT_LOGNAME))
	    sudo_setenv("LOGNAME", runas_pw->pw_name, TRUE);
	if (!ISSET(didvar, KEPT_USER))
	    sudo_setenv("USER", runas_pw->pw_name, TRUE);
	if (!ISSET(didvar, KEPT_USERNAME))
	    sudo_setenv("USERNAME", runas_pw->pw_name, TRUE);
    }

    /* Set $HOME for `sudo -H'.  Only valid at PERM_FULL_RUNAS. */
    /* XXX - not needed for MODE_LOGIN_SHELL */
    if (runas_pw->pw_dir) {
	if (ISSET(sudo_mode, MODE_RESET_HOME) ||
	    (ISSET(sudo_mode, MODE_RUN) && (def_always_set_home ||
	    (ISSET(sudo_mode, MODE_SHELL) && def_set_home))))
	    sudo_setenv("HOME", runas_pw->pw_dir, TRUE);
    }

    /* Provide default values for $TERM and $PATH if they are not set. */
    if (!ISSET(didvar, DID_TERM))
	sudo_putenv("TERM=unknown", FALSE, FALSE);
    if (!ISSET(didvar, DID_PATH))
	sudo_setenv("PATH", _PATH_DEFPATH, FALSE);

    /*
     * Preload a noexec file?  For a list of LD_PRELOAD-alikes, see
     * http://www.fortran-2000.com/ArnaudRecipes/sharedlib.html
     * XXX - should prepend to original value, if any
     */
    if (noexec && def_noexec_file != NULL) {
#if defined(__darwin__) || defined(__APPLE__)
	sudo_setenv("DYLD_INSERT_LIBRARIES", def_noexec_file, TRUE);
	sudo_setenv("DYLD_FORCE_FLAT_NAMESPACE", "", TRUE);
#else
# if defined(__osf__) || defined(__sgi)
	easprintf(&cp, "%s:DEFAULT", def_noexec_file);
	sudo_setenv("_RLD_LIST", cp, TRUE);
	efree(cp);
# else
#  ifdef _AIX
	sudo_setenv("LDR_PRELOAD", def_noexec_file, TRUE);
#  else
	sudo_setenv("LD_PRELOAD", def_noexec_file, TRUE);
#  endif /* _AIX */
# endif /* __osf__ || __sgi */
#endif /* __darwin__ || __APPLE__ */
    }

    /* Set PS1 if SUDO_PS1 is set. */
    if (ps1 != NULL)
	sudo_putenv(ps1, TRUE, TRUE);

    /* Add the SUDO_COMMAND envariable (cmnd + args). */
    if (user_args) {
	easprintf(&cp, "%s %s", user_cmnd, user_args);
	sudo_setenv("SUDO_COMMAND", cp, TRUE);
	efree(cp);
    } else
	sudo_setenv("SUDO_COMMAND", user_cmnd, TRUE);

    /* Add the SUDO_USER, SUDO_UID, SUDO_GID environment variables. */
    sudo_setenv("SUDO_USER", user_name, TRUE);
    snprintf(idbuf, sizeof(idbuf), "%lu", (unsigned long) user_uid);
    sudo_setenv("SUDO_UID", idbuf, TRUE);
    snprintf(idbuf, sizeof(idbuf), "%lu", (unsigned long) user_gid);
    sudo_setenv("SUDO_GID", idbuf, TRUE);

    /* Install new environment. */
    environ = env.envp;
    efree(old_envp);
}

void
insert_env_vars(env_vars)
    struct list_member *env_vars;
{
    struct list_member *cur;

    if (env_vars == NULL)
	return;

    /* Add user-specified environment variables. */
    for (cur = env_vars; cur != NULL; cur = cur->next)
	putenv(cur->value);
}

/*
 * Validate the list of environment variables passed in on the command
 * line against env_delete, env_check, and env_keep.
 * Calls log_error() if any specified variables are not allowed.
 */
void
validate_env_vars(env_vars)
    struct list_member *env_vars;
{
    struct list_member *var;
    char *eq, *bad = NULL;
    size_t len, blen = 0, bsize = 0;
    int okvar;

    for (var = env_vars; var != NULL; var = var->next) {
	if (def_secure_path && !user_is_exempt() &&
	    strncmp(var->value, "PATH=", 5) == 0) {
	    okvar = FALSE;
	} else if (def_env_reset) {
	    okvar = matches_env_check(var->value);
	    if (okvar == -1)
		okvar = matches_env_keep(var->value);
	} else {
	    okvar = matches_env_delete(var->value) == FALSE;
	    if (okvar == TRUE)
		okvar = matches_env_check(var->value) != FALSE;
	}
	if (okvar == FALSE) {
	    /* Not allowed, add to error string, allocating as needed. */
	    if ((eq = strchr(var->value, '=')) != NULL)
		*eq = '\0';
	    len = strlen(var->value) + 2;
	    if (blen + len >= bsize) {
		do {
		    bsize += 1024;
		} while (blen + len >= bsize);
		bad = erealloc(bad, bsize);
		bad[blen] = '\0';
	    }
	    strlcat(bad, var->value, bsize);
	    strlcat(bad, ", ", bsize);
	    blen += len;
	    if (eq != NULL)
		*eq = '=';
	}
    }
    if (bad != NULL) {
	bad[blen - 2] = '\0';		/* remove trailing ", " */
	log_error(NO_MAIL,
	    "sorry, you are not allowed to set the following environment variables: %s", bad);
	/* NOTREACHED */
	efree(bad);
    }
}

/*
 * Read in /etc/environment ala AIX and Linux.
 * Lines may be in either of three formats:
 *  NAME=VALUE
 *  NAME="VALUE"
 *  NAME='VALUE'
 * with an optional "export" prefix so the shell can source the file.
 * Invalid lines, blank lines, or lines consisting solely of a comment
 * character are skipped.
 */
void
read_env_file(path, overwrite)
    const char *path;
    int overwrite;
{
    FILE *fp;
    char *cp, *var, *val;
    size_t var_len, val_len;

    if ((fp = fopen(path, "r")) == NULL)
	return;

    while ((var = sudo_parseln(fp)) != NULL) {
	/* Skip blank or comment lines */
	if (*var == '\0')
	    continue;

	/* Skip optional "export " */
	if (strncmp(var, "export", 6) == 0 && isspace((unsigned char) var[6])) {
	    var += 7;
	    while (isspace((unsigned char) *var)) {
		var++;
	    }
	}

	/* Must be of the form name=["']value['"] */
	for (val = var; *val != '\0' && *val != '='; val++)
	    ;
	if (var == val || *val != '=')
	    continue;
	var_len = (size_t)(val - var);
	val_len = strlen(++val);

	/* Strip leading and trailing single/double quotes */
	if ((val[0] == '\'' || val[0] == '\"') && val[0] == val[val_len - 1]) {
	    val[val_len - 1] = '\0';
	    val++;
	    val_len -= 2;
	}

	cp = emalloc(var_len + 1 + val_len + 1);
	memcpy(cp, var, var_len + 1); /* includes '=' */
	memcpy(cp + var_len + 1, val, val_len + 1); /* includes NUL */

	sudo_putenv(cp, TRUE, overwrite);
    }
    fclose(fp);
}

void
init_envtables()
{
    struct list_member *cur;
    const char **p;

    /* Fill in the "env_delete" list. */
    for (p = initial_badenv_table; *p; p++) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = estrdup(*p);
	cur->next = def_env_delete;
	def_env_delete = cur;
    }

    /* Fill in the "env_check" list. */
    for (p = initial_checkenv_table; *p; p++) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = estrdup(*p);
	cur->next = def_env_check;
	def_env_check = cur;
    }

    /* Fill in the "env_keep" list. */
    for (p = initial_keepenv_table; *p; p++) {
	cur = emalloc(sizeof(struct list_member));
	cur->value = estrdup(*p);
	cur->next = def_env_keep;
	def_env_keep = cur;
    }
}
@


1.26
log
@Sanity check TZ environment variable; backport from sudo 1.8.12
@
text
@@


1.25
log
@Fix logic inversion when checking environment variables on the
command line against the blacklist.  This is only a problem when
env_reset is disabled.  CVE 2014-0106
@
text
@d189 1
a206 1
    "TZ",
d516 48
d586 6
a591 1
	    keepit = !strpbrk(var, "/%");
@


1.24
log
@Update sudo to version 1.7.2p8
@
text
@d835 1
a835 1
	    if (okvar == FALSE)
@


1.23
log
@Update to sudo 1.7.2p7
@
text
@d320 1
a320 1
    char **ep = env.envp;
d323 1
a323 1
    if (strchr(var, '=') != NULL) {
d358 1
a358 1
    while (*ep != NULL) {
d360 4
a363 4
	    /* Found it; shift remainder + NULL over by one and update len. */
	    memmove(ep, ep + 1,
		(env.env_len - (ep - env.envp)) * sizeof(char *));
	    env.env_len--;
d369 1
d466 3
a468 3
		    memmove(ep, ep + 1,
			(env.env_len - (ep - env.envp)) * sizeof(char *));
		    env.env_len--;
d473 1
@


1.22
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d320 1
a320 1
    char **ep;
d358 1
a358 1
    for (ep = env.envp; *ep; ep++) {
d364 3
a366 1
	    break;
d434 1
d453 11
a463 2
	    len = (strchr(str, '=') - str) + 1;
	    for (ep = env.envp; *ep; ep++) {
d465 5
a469 3
		    if (overwrite)
			*ep = str;
		    return;
d472 4
a475 1
    } else
d477 4
a480 4

    env.env_len++;
    *ep++ = str;
    *ep = NULL;
@


1.21
log
@Make environment file parsing grok linux-style env files.
@
text
@a51 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: env.c,v 1.106 2009/06/23 18:24:42 millert Exp $";
#endif /* lint */

@


1.20
log
@Upgrade to sudo 1.7.2
@
text
@d46 1
d53 1
a53 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.105 2009/06/15 13:10:01 millert Exp $";
d853 5
a857 1
 * Lines are in the form of NAME=VALUE
d867 2
a868 1
    char *cp;
d873 1
a873 1
    while ((cp = sudo_parseln(fp)) != NULL) {
d875 1
a875 1
	if (*cp == '\0')
d878 12
a889 2
	/* Must be of the form name=value */
	if (strchr(cp, '=') == NULL)
d891 13
d905 1
a905 1
	sudo_putenv(estrdup(cp), TRUE, overwrite);
@


1.19
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2005, 2007-2008
d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.101 2009/03/11 23:01:10 millert Exp $";
d252 2
a253 1
    char *estring;
d256 12
a267 3
    if (strchr(var, '=') != NULL) {
	errno = EINVAL;
	return(-1);
d270 10
a279 2
    esize = strlen(var) + 1 + strlen(val) + 1;
    estring = emalloc(esize);
a280 7
    /* Build environment string and insert it. */
    if (strlcpy(estring, var, esize) >= esize ||
	strlcat(estring, "=", esize) >= esize ||
	strlcat(estring, val, esize) >= esize) {

	errorx(1, "internal error, setenv() overflow");
    }
@


1.18
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d46 1
d52 1
a52 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.94 2008/11/09 14:13:12 millert Exp $";
d105 2
a106 5
void sudo_setenv		__P((const char *, const char *, int));
void sudo_unsetenv		__P((const char *));
static void _sudo_setenv	__P((const char *, const char *, int));
static void insert_env		__P((char *, int, int));
static void sync_env		__P((void));
a215 23
 * Syncronize our private copy of the environment with what is
 * in environ.
 */
static void
sync_env()
{
    size_t evlen;
    char **ep;

    for (ep = environ; *ep != NULL; ep++)
	continue;
    evlen = ep - environ;
    if (evlen + 1 > env.env_size) {
	efree(env.envp);
	env.env_size = evlen + 1 + 128;
	env.envp = emalloc2(env.env_size, sizeof(char *));
    }
    memcpy(env.envp, environ, (evlen + 1) * sizeof(char *));
    env.env_len = evlen;
    environ = env.envp;
}

/*
d217 2
a218 2
 * and it always overwrites.  The dupcheck param determines whether we need
 * to verify that the variable is not already set.
d221 1
a221 1
_sudo_setenv(var, val, dupcheck)
d239 1
a239 1
    insert_env(estring, dupcheck, FALSE);
a241 1
#ifdef HAVE_LDAP
d243 2
a244 2
 * External version of sudo_setenv() that keeps things in sync with
 * the environ pointer.
d246 2
a247 2
void
sudo_setenv(var, val, dupcheck)
d250 1
a250 1
    int dupcheck;
d255 4
a258 3
    /* Make sure we are operating on the current environment. */
    if (env.envp != environ)
	sync_env();
d268 27
a294 1
	errorx(1, "internal error, sudo_setenv() overflow");
d296 2
a297 1
    insert_env(estring, dupcheck, TRUE);
a298 1
#endif /* HAVE_LDAP */
a299 1
#if defined(HAVE_LDAP) || defined(HAVE_AIXAUTH)
d301 2
a302 2
 * Similar to unsetenv(3) but operates on sudo's private copy of the
 * environment.
d304 1
d306 4
a309 1
sudo_unsetenv(var)
d312 11
a322 2
    char **nep;
    size_t varlen;
d325 23
a347 2
    if (env.envp != environ)
	sync_env();
d349 6
a354 6
    varlen = strlen(var);
    for (nep = env.envp; *nep; nep++) {
	if (strncmp(var, *nep, varlen) == 0 && (*nep)[varlen] == '=') {
	    /* Found it; move everything over by one and update len. */
	    memmove(nep, nep + 1,
		(env.env_len - (nep - env.envp)) * sizeof(char *));
d356 1
a356 1
	    return;
d359 3
a362 1
#endif /* HAVE_LDAP || HAVE_AIXAUTH */
d365 50
a414 1
 * Insert str into env.envp, assumes str has an '=' in it.
d417 1
a417 1
insert_env(str, dupcheck, dosync)
d420 1
a420 1
    int dosync;
d422 2
a423 2
    char **nep;
    size_t varlen;
d429 5
a433 2
	if (dosync)
	    environ = env.envp;
d436 5
d442 5
a446 6
	    varlen = (strchr(str, '=') - str) + 1;

	    for (nep = env.envp; *nep; nep++) {
		if (strncmp(str, *nep, varlen) == 0) {
		    if (dupcheck != -1)
			*nep = str;
d451 1
a451 1
	nep = env.envp + env.env_len;
d454 2
a455 2
    *nep++ = str;
    *nep = NULL;
d570 3
d627 1
a627 1
		insert_env(*ep, FALSE, FALSE);
d638 3
a640 3
	    _sudo_setenv("HOME", runas_pw->pw_dir, ISSET(didvar, DID_HOME));
	    _sudo_setenv("SHELL", runas_pw->pw_shell, ISSET(didvar, DID_SHELL));
	    _sudo_setenv("LOGNAME", runas_pw->pw_name,
d642 2
a643 2
	    _sudo_setenv("USER", runas_pw->pw_name, ISSET(didvar, DID_USER));
	    _sudo_setenv("USERNAME", runas_pw->pw_name,
d647 1
a647 1
		_sudo_setenv("HOME", user_dir, FALSE);
d649 1
a649 1
		_sudo_setenv("SHELL", sudo_user.pw->pw_shell, FALSE);
d651 1
a651 1
		_sudo_setenv("LOGNAME", user_name, FALSE);
d653 1
a653 1
		_sudo_setenv("USER", user_name, FALSE);
d655 1
a655 1
		_sudo_setenv("USERNAME", user_name, FALSE);
d686 1
a686 1
		insert_env(*ep, FALSE, FALSE);
d692 1
a692 1
	_sudo_setenv("PATH", def_secure_path, TRUE);
d700 1
a700 1
	    _sudo_setenv("LOGNAME", runas_pw->pw_name, TRUE);
d702 1
a702 1
	    _sudo_setenv("USER", runas_pw->pw_name, TRUE);
d704 1
a704 1
	    _sudo_setenv("USERNAME", runas_pw->pw_name, TRUE);
d713 1
a713 1
	    _sudo_setenv("HOME", runas_pw->pw_dir, TRUE);
d718 1
a718 1
	insert_env("TERM=unknown", FALSE, FALSE);
d720 1
a720 1
	_sudo_setenv("PATH", _PATH_DEFPATH, FALSE);
d729 2
a730 2
	_sudo_setenv("DYLD_INSERT_LIBRARIES", def_noexec_file, TRUE);
	_sudo_setenv("DYLD_FORCE_FLAT_NAMESPACE", "", TRUE);
d734 1
a734 1
	_sudo_setenv("_RLD_LIST", cp, TRUE);
d738 1
a738 1
	_sudo_setenv("LDR_PRELOAD", def_noexec_file, TRUE);
d740 1
a740 1
	_sudo_setenv("LD_PRELOAD", def_noexec_file, TRUE);
d748 1
a748 1
	insert_env(ps1, TRUE, FALSE);
d753 1
a753 1
	_sudo_setenv("SUDO_COMMAND", cp, TRUE);
d756 1
a756 1
	_sudo_setenv("SUDO_COMMAND", user_cmnd, TRUE);
d759 1
a759 1
    _sudo_setenv("SUDO_USER", user_name, TRUE);
d761 1
a761 1
    _sudo_setenv("SUDO_UID", idbuf, TRUE);
d763 1
a763 1
    _sudo_setenv("SUDO_GID", idbuf, TRUE);
a778 4
    /* Make sure we are operating on the current environment. */
    if (env.envp != environ)
	sync_env();

d781 1
a781 1
	insert_env(cur->value, TRUE, TRUE);
d846 1
a846 1
read_env_file(path, replace)
d848 1
a848 1
    int replace;
a855 4
    /* Make sure we are operating on the current environment. */
    if (env.envp != environ)
	sync_env();

d865 1
a865 1
	insert_env(estrdup(cp), replace ? TRUE : -1, TRUE);
@


1.17
log
@Update to sudo 1.6.9p17
@
text
@d2 2
a3 1
 * Copyright (c) 2000-2007 Todd C. Miller <Todd.Miller@@courtesan.com>
a45 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d51 1
a51 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.39.2.19 2008/06/21 19:04:07 millert Exp $";
d92 1
a92 1
#define	VNULL	(VOID *)NULL
d103 8
a110 3
char **rebuild_env		__P((char **, int, int));
static void insert_env		__P((char *, struct environment *, int));
static char *format_env		__P((char *, ...));
d137 1
d218 26
a243 1
 * Given a variable and value, allocate and format an environment string.
d245 5
a249 8
static char *
#ifdef __STDC__
format_env(char *var, ...)
#else
format_env(var, va_alist)
    char *var;
    va_dcl
#endif
a251 1
    char *val;
a252 1
    va_list ap;
d254 2
a255 10
#ifdef __STDC__
    va_start(ap, var);
#else
    va_start(ap);
#endif
    esize = strlen(var) + 2;
    while ((val = va_arg(ap, char *)) != NULL)
	esize += strlen(val);
    va_end(ap);
    estring = (char *) emalloc(esize);
d257 1
a257 1
    /* Store variable name and the '=' separator.  */
d259 2
a260 1
	strlcat(estring, "=", esize) >= esize) {
d262 1
a262 1
	errx(1, "internal error, format_env() overflow");
d264 2
d267 27
a293 9
    /* Now store the variable's value (if any) */
#ifdef __STDC__
    va_start(ap, var);
#else
    va_start(ap);
#endif
    while ((val = va_arg(ap, char *)) != NULL) {
	if (strlcat(estring, val, esize) >= esize)
	    errx(1, "internal error, format_env() overflow");
d295 15
a309 1
    va_end(ap);
d311 14
a324 1
    return(estring);
d326 1
d329 1
a329 1
 * Insert str into e->envp, assumes str has an '=' in it.
d332 1
a332 1
insert_env(str, e, dupcheck)
a333 1
    struct environment *e;
d335 1
d341 5
a345 3
    if (e->env_len + 2 > e->env_size) {
	e->env_size += 128;
	e->envp = erealloc3(e->envp, e->env_size, sizeof(char *));
d351 1
a351 1
	    for (nep = e->envp; *nep; nep++) {
d353 2
a354 1
		    *nep = str;
d359 1
a359 1
	nep = e->envp + e->env_len;
d361 1
a361 1
    e->env_len++;
d460 2
a461 3
char **
rebuild_env(envp, sudo_mode, noexec)
    char **envp;
d465 2
a466 1
    char **ep, *cp, *ps1;
d474 4
a477 1
    memset(&env, 0, sizeof(env));
d480 1
a480 1
	for (ep = envp; *ep; ep++) {
d532 1
a532 1
		insert_env(*ep, &env, 0);
d543 3
a545 5
	    insert_env(format_env("HOME", runas_pw->pw_dir, VNULL), &env,
		ISSET(didvar, DID_HOME));
	    insert_env(format_env("SHELL", runas_pw->pw_shell, VNULL), &env,
		ISSET(didvar, DID_SHELL));
	    insert_env(format_env("LOGNAME", runas_pw->pw_name, VNULL), &env,
d547 2
a548 3
	    insert_env(format_env("USER", runas_pw->pw_name, VNULL), &env,
		ISSET(didvar, DID_USER));
	    insert_env(format_env("USERNAME", runas_pw->pw_name, VNULL), &env,
d552 1
a552 1
		insert_env(format_env("HOME", user_dir, VNULL), &env, 0);
d554 1
a554 2
		insert_env(format_env("SHELL", sudo_user.pw->pw_shell, VNULL),
		    &env, 0);
d556 1
a556 1
		insert_env(format_env("LOGNAME", user_name, VNULL), &env, 0);
d558 1
a558 1
		insert_env(format_env("USER", user_name, VNULL), &env, 0);
d560 1
a560 1
		insert_env(format_env("USERNAME", user_name, VNULL), &env, 0);
d564 1
a564 1
	 * Copy envp entries as long as they don't match env_delete or
d567 1
a567 1
	for (ep = envp; *ep; ep++) {
d591 1
a591 1
		insert_env(*ep, &env, 0);
d595 3
a597 5

#ifdef SECURE_PATH
    /* Replace the PATH envariable with a secure one. */
    if (!user_is_exempt()) {
	insert_env(format_env("PATH", SECURE_PATH, VNULL), &env, 1);
a599 1
#endif
d605 1
a605 1
	    insert_env(format_env("LOGNAME", runas_pw->pw_name, VNULL), &env, 1);
d607 1
a607 1
	    insert_env(format_env("USER", runas_pw->pw_name, VNULL), &env, 1);
d609 1
a609 1
	    insert_env(format_env("USERNAME", runas_pw->pw_name, VNULL), &env, 1);
d618 1
a618 1
	    insert_env(format_env("HOME", runas_pw->pw_dir, VNULL), &env, 1);
d623 1
a623 1
	insert_env("TERM=unknown", &env, 0);
d625 1
a625 1
	insert_env(format_env("PATH", _PATH_DEFPATH, VNULL), &env, 0);
d634 2
a635 3
	insert_env(format_env("DYLD_INSERT_LIBRARIES", def_noexec_file, VNULL),
	    &env, 1);
	insert_env(format_env("DYLD_FORCE_FLAT_NAMESPACE", VNULL), &env, 1);
d638 3
a640 2
	insert_env(format_env("_RLD_LIST", def_noexec_file, ":DEFAULT", VNULL),
	    &env, 1);
d643 1
a643 1
	insert_env(format_env("LDR_PRELOAD", def_noexec_file, VNULL), &env, 1);
d645 1
a645 1
	insert_env(format_env("LD_PRELOAD", def_noexec_file, VNULL), &env, 1);
d652 2
a653 2
    if (ps1)
	insert_env(ps1, &env, 1);
d656 6
a661 5
    if (user_args)
	insert_env(format_env("SUDO_COMMAND", user_cmnd, " ", user_args, VNULL),
	    &env, 1);
    else
	insert_env(format_env("SUDO_COMMAND", user_cmnd, VNULL), &env, 1);
d664 9
a672 7
    insert_env(format_env("SUDO_USER", user_name, VNULL), &env, 1);
    easprintf(&cp, "SUDO_UID=%lu", (unsigned long) user_uid);
    insert_env(cp, &env, 1);
    easprintf(&cp, "SUDO_GID=%lu", (unsigned long) user_gid);
    insert_env(cp, &env, 1);

    return(env.envp);
d675 2
a676 3
char **
insert_env_vars(envp, env_vars)
    char **envp;
d682 1
a682 1
	return (envp);
d684 3
a686 18
    /*
     * Make sure we still own the environment and steal it back if not.
     */
    if (env.envp != envp) {
	size_t evlen;
	char **ep;

	for (ep = envp; *ep != NULL; ep++)
	    continue;
	evlen = ep - envp;
	if (evlen + 1 > env.env_size) {
	    efree(env.envp);
	    env.env_size = evlen + 1 + 128;
	    env.envp = emalloc2(env.env_size, sizeof(char *));
	}
	memcpy(env.envp, envp, (evlen + 1) * sizeof(char *));
	env.env_len = evlen;
    }
d690 1
a690 3
	insert_env(cur->value, &env, 1);

    return(env.envp);
d708 2
a709 2
#ifdef SECURE_PATH
	if (!user_is_exempt() && strncmp(var->value, "PATH=", 5) == 0) {
d711 1
a711 3
	} else
#endif
	if (def_env_reset) {
d746 35
@


1.16
log
@PYTHONINSPECT not PYTHONINSPEC; David Krause
@
text
@d55 1
a55 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.39.2.17 2007/07/31 18:04:31 millert Exp $";
d201 1
d409 1
a409 1
    if (def_env_reset) {
d540 1
d551 1
@


1.15
log
@use correct length when making a copy of environ
@
text
@d55 1
a55 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.39.2.16 2007/07/29 20:10:19 millert Exp $";
d176 1
a176 1
    "PYTHONINSPEC",		/* python, allow inspection */
@


1.14
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d55 1
a55 1
__unused static const char rcsid[] = "$Sudo: env.c,v 1.39.2.15 2007/07/09 19:15:43 millert Exp $";
d632 1
a632 1
	memcpy(env.envp, envp, evlen + 1);
@


1.13
log
@Fix setting of $USER when env_reset is enabled.
@
text
@d2 1
a2 1
 * Copyright (c) 2000-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d21 1
a21 1
#include "config.h"
d55 1
a55 1
static const char rcsid[] = "$Sudo: env.c,v 1.42 2004/09/08 15:57:49 millert Exp $";
d62 1
a62 1
#define DID_TERM	0x01
d64 1
a64 1
#define DID_PATH	0x02
d66 1
a66 1
#define DID_HOME	0x04
d68 1
a68 1
#define DID_SHELL	0x08
d70 1
a70 1
#define DID_LOGNAME	0x10
d72 22
a93 1
#define DID_USER    	0x20
d98 6
d108 1
a108 2
char **zero_env			__P((char **));
static void insert_env		__P((char *, int));
d112 5
d134 1
d136 1
a136 1
#endif /* _AIX */
d147 1
d154 3
a156 3
    "TERMINFO",
    "TERMINFO_DIRS",
    "TERMPATH",
d158 21
a178 2
    "ENV",
    "BASH_ENV",
d186 1
a186 1
    "LC_*",
d189 3
a194 4
static char **new_environ;	/* Modified copy of the environment */
static size_t env_size;		/* size of new_environ in char **'s */
static size_t env_len;		/* number of slots used, not counting NULL */

d196 1
a196 3
 * Zero out environment and replace with a minimal set of KRB5CCNAME
 * USER, LOGNAME, HOME, TZ, PATH (XXX - should just set path to default)
 * May set user_path, user_shell, and/or user_prompt as side effects.
d198 15
a212 77
char **
zero_env(envp)
    char **envp;
{
    static char *newenv[9];
    char **ep, **nep = newenv;
    char **ne_last = &newenv[(sizeof(newenv) / sizeof(newenv[0])) - 1];
    extern char *prev_user;

    for (ep = envp; *ep; ep++) {
	switch (**ep) {
	    case 'H':
		if (strncmp("HOME=", *ep, 5) == 0)
		    break;
		continue;
	    case 'K':
		if (strncmp("KRB5CCNAME=", *ep, 11) == 0)
		    break;
		continue;
	    case 'L':
		if (strncmp("LOGNAME=", *ep, 8) == 0)
		    break;
		continue;
	    case 'P':
		if (strncmp("PATH=", *ep, 5) == 0) {
		    user_path = *ep + 5;
		    /* XXX - set to sane default instead of user's? */
		    break;
		}
		continue;
	    case 'S':
		if (strncmp("SHELL=", *ep, 6) == 0)
		    user_shell = *ep + 6;
		else if (!user_prompt && strncmp("SUDO_PROMPT=", *ep, 12) == 0)
		    user_prompt = *ep + 12;
		else if (strncmp("SUDO_USER=", *ep, 10) == 0)
		    prev_user = *ep + 10;
		continue;
	    case 'T':
		if (strncmp("TZ=", *ep, 3) == 0)
		    break;
		continue;
	    case 'U':
		if (strncmp("USER=", *ep, 5) == 0)
		    break;
		continue;
	    default:
		continue;
	}

	/* Deal with multiply defined variables (take first instance) */
	for (nep = newenv; *nep; nep++) {
	    if (**nep == **ep)
		break;
	}
	if (*nep == NULL) {
	    if (nep < ne_last)
		*nep++ = *ep;
	    else
		errx(1, "internal error, attempt to write outside newenv");
	}
    }

#ifdef HAVE_LDAP
    /*
     * Prevent OpenLDAP from reading any user dotfiles
     * or files in the current directory.
     *
     */	     
    if (nep < ne_last)
	*nep++ = "LDAPNOINIT=1";
    else
	errx(1, "internal error, attempt to write outside newenv");
#endif

    return(&newenv[0]);
}
d265 1
a265 2
 * Insert str into new_environ, assumes str has an '=' in it.
 * NOTE: no other routines may modify new_environ, env_size, or env_len.
d268 1
a268 1
insert_env(str, dupcheck)
d270 1
d277 3
a279 3
    if (env_len + 2 > env_size) {
	env_size += 128;
	new_environ = erealloc3(new_environ, env_size, sizeof(char *));
d285 1
a285 1
	    for (nep = new_environ; *nep; nep++) {
d292 1
a292 1
	nep = &new_environ[env_len];
d294 1
a294 1
    env_len++;
d300 89
d400 1
a400 3
    int okvar, iswild, didvar;
    size_t len;
    struct list_member *cur;
d407 1
a408 2
	int keepit;

d411 1
a411 1
	    keepit = 0;
d419 8
a426 16
	    for (cur = def_env_keep; cur; cur = cur->next) {
		len = strlen(cur->value);
		/* Deal with '*' wildcard */
		if (cur->value[len - 1] == '*') {
		    len--;
		    iswild = 1;
		} else
		    iswild = 0;
		if (strncmp(cur->value, *ep, len) == 0 &&
		    (iswild || (*ep)[len] == '=')) {
		    /* We always preserve TERM, no special treatment needed. */
		    if (strncmp(*ep, "TERM=", 5) != 0)
			keepit = 1;
		    break;
		}
	    }
d439 8
d451 3
a453 3
		    case 'L':
			if (strncmp(*ep, "LOGNAME=", 8) == 0)
			    SET(didvar, DID_LOGNAME);
d458 2
d462 1
a462 10
		insert_env(*ep, 0);
	    } else {
		/* Preserve TERM and PATH, ignore anything else. */
		if (!ISSET(didvar, DID_TERM) && strncmp(*ep, "TERM=", 5) == 0) {
		    insert_env(*ep, 0);
		    SET(didvar, DID_TERM);
		} else if (!ISSET(didvar, DID_PATH) && strncmp(*ep, "PATH=", 5) == 0) {
		    insert_env(*ep, 0);
		    SET(didvar, DID_PATH);
		}
d465 1
d473 10
a482 4
	    insert_env(format_env("HOME", runas_pw->pw_dir, VNULL), 0);
	    insert_env(format_env("SHELL", runas_pw->pw_shell, VNULL), 0);
	    insert_env(format_env("LOGNAME", runas_pw->pw_name, VNULL), 0);
	    insert_env(format_env("USER", runas_pw->pw_name, VNULL), 0);
d485 1
a485 1
		insert_env(format_env("HOME", user_dir, VNULL), 0);
d487 2
a488 1
		insert_env(format_env("SHELL", sudo_user.pw->pw_shell, VNULL), 0);
d490 1
a490 1
		insert_env(format_env("LOGNAME", user_name, VNULL), 0);
d492 3
a494 1
		insert_env(format_env("USER", user_name, VNULL), 0);
d502 1
a502 1
	    okvar = 1;
d510 7
a516 30
	    /* Skip anything listed in env_delete. */
	    for (cur = def_env_delete; cur && okvar; cur = cur->next) {
		len = strlen(cur->value);
		/* Deal with '*' wildcard */
		if (cur->value[len - 1] == '*') {
		    len--;
		    iswild = 1;
		} else
		    iswild = 0;
		if (strncmp(cur->value, *ep, len) == 0 &&
		    (iswild || (*ep)[len] == '=')) {
		    okvar = 0;
		}
	    }

	    /* Check certain variables for '%' and '/' characters. */
	    for (cur = def_env_check; cur && okvar; cur = cur->next) {
		len = strlen(cur->value);
		/* Deal with '*' wildcard */
		if (cur->value[len - 1] == '*') {
		    len--;
		    iswild = 1;
		} else
		    iswild = 0;
		if (strncmp(cur->value, *ep, len) == 0 &&
		    (iswild || (*ep)[len] == '=') &&
		    strpbrk(*ep, "/%")) {
		    okvar = 0;
		}
	    }
d525 1
a525 1
		insert_env(*ep, 0);
a528 5
    /* Provide default values for $TERM and $PATH if they are not set. */
    if (!ISSET(didvar, DID_TERM))
	insert_env("TERM=unknown", 0);
    if (!ISSET(didvar, DID_PATH))
	insert_env(format_env("PATH", _PATH_DEFPATH, VNULL), 0);
d532 4
a535 1
    insert_env(format_env("PATH", SECURE_PATH, VNULL), 1);
d538 1
a538 1
    /* Set $USER and $LOGNAME to target if "set_logname" is true. */
d540 6
a545 2
	insert_env(format_env("LOGNAME", runas_pw->pw_name, VNULL), 1);
	insert_env(format_env("USER", runas_pw->pw_name, VNULL), 1);
d549 12
a560 2
    if (ISSET(sudo_mode, MODE_RESET_HOME) && runas_pw->pw_dir)
	insert_env(format_env("HOME", runas_pw->pw_dir, VNULL), 1);
d569 3
a571 2
	insert_env(format_env("DYLD_INSERT_LIBRARIES", def_noexec_file, VNULL), 1);
	insert_env(format_env("DYLD_FORCE_FLAT_NAMESPACE", VNULL), 1);
d574 2
a575 1
	insert_env(format_env("_RLD_LIST", def_noexec_file, ":DEFAULT", VNULL), 1);
d577 7
a583 3
	insert_env(format_env("LD_PRELOAD", def_noexec_file, VNULL), 1);
# endif
#endif
d588 1
a588 1
	insert_env(ps1, 1);
d592 2
a593 1
	insert_env(format_env("SUDO_COMMAND", user_cmnd, " ", user_args, VNULL), 1);
d595 1
a595 1
	insert_env(format_env("SUDO_COMMAND", user_cmnd, VNULL), 1);
d598 1
a598 1
    insert_env(format_env("SUDO_USER", user_name, VNULL), 1);
d600 1
a600 1
    insert_env(cp, 1);
d602 54
a655 1
    insert_env(cp, 1);
d657 41
a697 1
    return(new_environ);
d706 1
a706 1
    /* Fill in "env_delete" variable. */
d714 1
a714 1
    /* Fill in "env_check" variable. */
d720 8
@


1.12
log
@Update to Sudo 1.6.8p7
@
text
@d72 1
a72 1
#define DID_USER    	0x12
@


1.11
log
@Update to sudo 1.6.8p4
@
text
@d502 1
a502 1
    if (noexec && def_noexec_file != NULL)
d513 1
@


1.10
log
@Update to sudo 1.6.8p2
@
text
@d91 1
d145 1
a145 1
 * Zero out environment and replace with a minimal set of
d153 1
a153 1
    static char *newenv[8];
d155 1
d164 4
d204 6
a209 2
	if (*nep == NULL)
	    *nep++ = *ep;
d218 4
a221 1
    *nep++ = "LDAPNOINIT=1";
@


1.9
log
@Update to sudo 1.6.8p1
@
text
@d326 7
d414 6
@


1.8
log
@Update to 1.6.7p5
@
text
@d2 1
a2 2
 * Copyright (c) 2000-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d55 1
a55 1
static const char rcsid[] = "$Sudo: env.c,v 1.27 2003/04/16 00:42:09 millert Exp $";
d71 1
a71 1
#undef DID_USER    
d74 3
d80 1
a80 1
char **rebuild_env		__P((int, char **));
d83 1
a83 1
static char *format_env		__P((char *, char *));
d152 3
a154 2
    char **ep, **nep;
    static char *newenv[7];
d176 1
a176 1
		else if (!user_prompt && !strncmp("SUDO_PROMPT=", *ep, 12))
d178 2
d201 10
d218 4
a221 1
format_env(var, val)
d223 2
a224 1
    char *val;
d227 1
d229 1
d231 9
a239 1
    esize = strlen(var) + 1 + strlen(val) + 1;
d242 1
a242 1
    /* We pre-allocate enough space, so this should never overflow. */
d244 1
a244 2
	strlcat(estring, "=", esize) >= esize ||
	strlcat(estring, val, esize) >= esize) {
d249 12
d305 2
a306 1
rebuild_env(sudo_mode, envp)
d308 1
a308 1
    char **envp;
d320 1
a320 1
    if (def_flag(I_ENV_RESET)) {
d326 1
a326 1
	    for (cur = def_list(I_ENV_KEEP); cur; cur = cur->next) {
d352 1
a352 1
			    didvar |= DID_HOME;
d356 1
a356 1
			    didvar |= DID_SHELL;
d360 1
a360 1
			    didvar |= DID_LOGNAME;
d364 1
a364 1
			    didvar |= DID_USER;
d370 1
a370 1
		if (!(didvar & DID_TERM) && !strncmp(*ep, "TERM=", 5)) {
d372 2
a373 2
		    didvar |= DID_TERM;
		} else if (!(didvar & DID_PATH) && !strncmp(*ep, "PATH=", 5)) {
d375 1
a375 1
		    didvar |= DID_PATH;
d381 3
a383 2
	 * Add in defaults unless they were preserved from the
	 * user's environment.
d385 15
a399 8
	if (!(didvar & DID_HOME))
	    insert_env(format_env("HOME", user_dir), 0);
	if (!(didvar & DID_SHELL))
	    insert_env(format_env("SHELL", sudo_user.pw->pw_shell), 0);
	if (!(didvar & DID_LOGNAME))
	    insert_env(format_env("LOGNAME", user_name), 0);
	if (!(didvar & DID_USER))
	    insert_env(format_env("USER", user_name), 0);
d409 1
a409 1
	    for (cur = def_list(I_ENV_DELETE); cur && okvar; cur = cur->next) {
d424 1
a424 1
	    for (cur = def_list(I_ENV_CHECK); cur && okvar; cur = cur->next) {
d443 1
a443 1
		    didvar |= DID_PATH;
d445 1
a445 1
		    didvar |= DID_TERM;
d451 1
a451 1
    if (!(didvar & DID_TERM))
d453 2
a454 2
    if (!(didvar & DID_PATH))
	insert_env(format_env("PATH", _PATH_DEFPATH), 0);
d458 1
a458 1
    insert_env(format_env("PATH", SECURE_PATH), 1);
d462 3
a464 3
    if (def_flag(I_SET_LOGNAME) && runas_pw->pw_name) {
	insert_env(format_env("LOGNAME", runas_pw->pw_name), 1);
	insert_env(format_env("USER", runas_pw->pw_name), 1);
d467 20
a486 3
    /* Set $HOME for `sudo -H'.  Only valid at PERM_RUNAS. */
    if ((sudo_mode & MODE_RESET_HOME) && runas_pw->pw_dir)
	insert_env(format_env("HOME", runas_pw->pw_dir), 1);
d493 4
a496 5
    if (user_args) {
	easprintf(&cp, "SUDO_COMMAND=%s %s", user_cmnd, user_args);
	insert_env(cp, 1);
    } else
	insert_env(format_env("SUDO_COMMAND", user_cmnd), 1);
d499 1
a499 1
    insert_env(format_env("SUDO_USER", user_name), 1);
d518 2
a519 2
	cur->next = def_list(I_ENV_DELETE);
	def_list(I_ENV_DELETE) = cur;
d526 2
a527 2
	cur->next = def_list(I_ENV_CHECK);
	def_list(I_ENV_CHECK) = cur;
@


1.7
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d253 2
a254 2
    /* Make sure there is room for the new entry. */
    if (env_len + 1 > env_size) {
@


1.6
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d33 4
d73 1
a73 1
static const char rcsid[] = "$Sudo: env.c,v 1.26 2003/04/02 18:25:19 millert Exp $";
@


1.5
log
@update to what will soon be sudo 1.6.7
@
text
@d59 5
a64 1
#include <errno.h>
d69 1
a69 1
static const char rcsid[] = "$Sudo: env.c,v 1.25 2003/03/15 20:31:01 millert Exp $";
d120 1
a120 1
    "KRBCONFDIR"
d230 2
a231 3
	(void) fprintf(stderr, "%s: internal error, format_env() overflow\n",
	    Argv[0]);
	exit(1);
@


1.4
log
@Update to sudo 1.6.6
@
text
@d2 1
a2 1
 * Copyright (c) 2000, 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d65 1
a65 1
static const char rcsid[] = "$Sudo: env.c,v 1.16 2002/04/18 15:38:52 millert Exp $";
d69 1
a69 1
 * Flags used in env_reset()
d89 1
a89 1
static void insert_env		__P((char **, char *));
d96 1
a96 1
char *initial_badenv_table[] = {
d111 3
d139 1
a139 1
char *initial_checkenv_table[] = {
d146 4
d216 2
a217 2
    char *estring, *p;
    size_t varlen, vallen;
d219 11
a229 7
    varlen = strlen(var);
    vallen = strlen(val);
    p = estring = (char *) emalloc(varlen + vallen + 2);
    strcpy(p, var);
    p += varlen;
    *p++ = '=';
    strcpy(p, val);
d235 2
a236 2
 * Insert str into envp.
 * Assumes str has an '=' in it and does not check for available space!
d239 1
a239 2
insert_env(envp, str)
    char **envp;
d241 1
d243 1
a243 1
    char **ep;
d246 8
a253 1
    varlen = (strchr(str, '=') - str) + 1;
d255 12
a266 10
    for (ep = envp; *ep; ep++) {
	if (strncmp(str, *ep, varlen) == 0) {
	    *ep = str;
	    break;
	}
    }
    if (*ep == NULL) {
	*ep++ = str;
	*ep = NULL;
    }
d279 1
a279 1
    char **newenvp, **ep, **nep, *cp, *ps1;
d281 1
a281 1
    size_t env_size, len;
a283 4
    /* Count number of items in "env_keep" list (if any) */
    for (len = 0, cur = def_list(I_ENV_KEEP); cur; cur = cur->next)
	len++;

a291 4
	/* Alloc space for new environment. */
	env_size = 32 + len;
	nep = newenvp = (char **) emalloc(env_size * sizeof(char *));

d322 1
a322 1
			    break;
d326 1
a326 1
			    break;
d330 1
a330 1
			    break;
d334 1
a334 1
			    break;
d336 1
a336 1
		*nep++ = *ep;
d340 1
a340 1
		    *nep++ = *ep;
d343 1
a343 1
		    *nep++ = *ep;
d354 1
a354 1
	    *nep++ = format_env("HOME", user_dir);
d356 1
a356 1
	    *nep++ = format_env("SHELL", sudo_user.pw->pw_shell);
d358 1
a358 1
	    *nep++ = format_env("LOGNAME", user_name);
d360 1
a360 1
	    *nep++ = format_env("USER", user_name);
a361 5
	/* Alloc space for new environment. */
	for (env_size = 16 + len, ep = envp; *ep; ep++, env_size++)
	    ;
	nep = newenvp = (char **) emalloc(env_size * sizeof(char *));

d407 1
a407 1
		*nep++ = *ep;
d413 1
a413 1
	*nep++ = "TERM=unknown";
d415 1
a415 7
	*nep++ = format_env("PATH", _PATH_DEFPATH);
    *nep = NULL;

    /*
     * At this point we must use insert_env() to modify newenvp.
     * Access via 'nep' is not allowed (since we must check for dupes).
     */
d419 1
a419 1
    insert_env(newenvp, format_env("PATH", SECURE_PATH));
d424 2
a425 2
	insert_env(newenvp, format_env("LOGNAME", runas_pw->pw_name));
	insert_env(newenvp, format_env("USER", runas_pw->pw_name));
d430 1
a430 1
	insert_env(newenvp, format_env("HOME", runas_pw->pw_dir));
d434 1
a434 1
	insert_env(newenvp, ps1);
d439 1
a439 1
	insert_env(newenvp, cp);
d441 1
a441 1
	insert_env(newenvp, format_env("SUDO_COMMAND", user_cmnd));
d444 5
a448 13
    insert_env(newenvp, format_env("SUDO_USER", user_name));
    easprintf(&cp, "SUDO_UID=%ld", (long) user_uid);
    insert_env(newenvp, cp);
    easprintf(&cp, "SUDO_GID=%ld", (long) user_gid);
    insert_env(newenvp, cp);

    return(newenvp);
}

void
dump_badenv()
{
    struct list_member *cur;
d450 1
a450 7
    puts("Default table of environment variables to clear");
    for (cur = def_list(I_ENV_DELETE); cur; cur = cur->next)
	printf("\t%s\n", cur->value);

    puts("Default table of environment variables to sanity check");
    for (cur = def_list(I_ENV_CHECK); cur; cur = cur->next)
	printf("\t%s\n", cur->value);
d457 1
a457 1
    char **p;
@


1.3
log
@update to sudo 1.6.4p2
@
text
@d65 1
a65 1
static const char rcsid[] = "$Sudo: env.c,v 1.15 2002/01/15 23:43:58 millert Exp $";
d437 1
a437 2
	cp = emalloc(strlen(user_cmnd) + strlen(user_args) + 15);
	sprintf(cp, "SUDO_COMMAND=%s %s", user_cmnd, user_args);
d444 1
a444 2
    cp = emalloc(MAX_UID_T_LEN + 10);
    sprintf(cp, "SUDO_UID=%ld", (long) user_uid);
d446 1
a446 2
    cp = emalloc(MAX_UID_T_LEN + 10);
    sprintf(cp, "SUDO_GID=%ld", (long) user_gid);
@


1.3.4.1
log
@update to sudo 1.6.5p1
@
text
@@


1.3.2.1
log
@update to sudo 1.6.5p1
@
text
@@


1.2
log
@update to sudo 1.6.4p1
@
text
@d65 1
a65 1
static const char rcsid[] = "$Sudo: env.c,v 1.13 2001/12/31 05:53:23 millert Exp $";
d344 1
a344 1
	    *nep++ = format_env("SHELL", user_shell);
@


1.1
log
@Update to sudo 1.6.4
@
text
@d160 1
d164 1
d171 1
d173 1
a173 1
		if (strncmp("SHELL=", *ep, 6) == 0) {
d175 1
a175 2
		    continue;
		} else if (!user_prompt && !strncmp("SUDO_PROMPT=", *ep, 12)) {
d177 1
a177 2
		    continue;
		}
d181 1
d185 1
@

