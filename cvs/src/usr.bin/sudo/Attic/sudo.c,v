head	1.49;
access;
symbols
	OPENBSD_5_7:1.48.0.2
	OPENBSD_5_7_BASE:1.48
	OPENBSD_5_6:1.48.0.6
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.43.0.12
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.10
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.26.0.8
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.6
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.48;
commitid	8ra5qnWqy2bUhcZn;

1.48
date	2013.12.07.14.53.29;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.06.21.30.56;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.29.00.28.23;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.19.00.48.08;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.10.21.51.49;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.08.21.11.31;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.11.21.32.28;	author halex;	state Exp;
branches;
next	1.41;

1.41
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.07.18.43.10;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.09.00.14.52;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.22.16.33.42;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.15.05.11.39;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.31.16.44.03;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.21.01.16.52;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.03.15.09.48;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.17.04.26.04;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.05.23.55.57;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.15.14.22.39;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.19.22.00.08;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.31.21.13.43;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.31.18.53.33;	author millert;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.12.19.13.21;	author millert;	state Exp;
branches
	1.22.4.1;
next	1.21;

1.21
date	2003.12.23.02.19.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.01.15.47.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.25.15.49.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.16.18.09.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.15.02.17.03;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.14.00.11.44;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.08.15.44.25;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.23.21.46.17;	author millert;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.12.15.14.35.58;	author millert;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.11.21.17.58.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.13.21.58.52;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.05.14.01.15;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.28.23.17.43;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.27.03.44.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.24.04.22.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.10.2.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;

1.22.4.1
date	2005.06.21.00.10.23;	author brad;	state Exp;
branches;
next	;

1.24.2.1
date	2005.06.21.00.17.41;	author brad;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1993-1996, 1998-2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 *
 * For a brief history of sudo, please see the HISTORY file included
 * with this distribution.
 */

#define _SUDO_MAIN

#ifdef __TANDEM
# include <floss.h>
#endif

#include <config.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/socket.h>
#ifdef HAVE_SETRLIMIT
# include <sys/time.h>
# include <sys/resource.h>
#endif
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <grp.h>
#if TIME_WITH_SYS_TIME
# include <time.h>
#endif
#ifdef HAVE_SETLOCALE
# include <locale.h>
#endif
#include <netinet/in.h>
#include <netdb.h>
#if defined(HAVE_GETPRPWNAM) && defined(HAVE_SET_AUTH_PARAMETERS)
# ifdef __hpux
#  undef MAXINT
#  include <hpsecurity.h>
# else
#  include <sys/security.h>
# endif /* __hpux */
# include <prot.h>
#endif /* HAVE_GETPRPWNAM && HAVE_SET_AUTH_PARAMETERS */
#ifdef HAVE_LOGIN_CAP_H
# include <login_cap.h>
# ifndef LOGIN_DEFROOTCLASS
#  define LOGIN_DEFROOTCLASS	"daemon"
# endif
#endif
#ifdef HAVE_PROJECT_H
# include <project.h>
# include <sys/task.h>
#endif
#ifdef HAVE_SELINUX
# include <selinux/selinux.h>
#endif

#include <sudo_usage.h>
#include "sudo.h"
#include "lbuf.h"
#include "interfaces.h"

#ifdef USING_NONUNIX_GROUPS
# include "nonunix.h"
#endif

/*
 * Prototypes
 */
static void init_vars			__P((int, char **));
static int set_cmnd			__P((int));
static int parse_args			__P((int, char **));
static void initial_setup		__P((void));
static void set_loginclass		__P((struct passwd *));
static void set_project			__P((struct passwd *));
static void set_runasgr			__P((char *));
static void set_runaspw			__P((char *));
static void show_version		__P((void));
static void usage			__P((int))
					    __attribute__((__noreturn__));
static void usage_excl			__P((int))
					    __attribute__((__noreturn__));
static struct passwd *get_authpw	__P((void));
extern int sudo_edit			__P((int, char **, char **));
extern void rebuild_env			__P((int, int));
void validate_env_vars			__P((struct list_member *));
void insert_env_vars			__P((struct list_member *));

/*
 * Globals
 */
int Argc, NewArgc;
char **Argv, **NewArgv;
char *prev_user;
static int user_closefrom = -1;
struct sudo_user sudo_user;
struct passwd *auth_pw, *list_pw;
struct interface *interfaces;
int num_interfaces;
int tgetpass_flags;
int long_list;
uid_t timestamp_uid;
extern int errorlineno;
extern int parse_error;
extern char *errorfile;
#if defined(RLIMIT_CORE) && !defined(SUDO_DEVEL)
static struct rlimit corelimit;
#endif /* RLIMIT_CORE && !SUDO_DEVEL */
#ifdef HAVE_LOGIN_CAP_H
login_cap_t *lc;
#endif /* HAVE_LOGIN_CAP_H */
#ifdef HAVE_BSD_AUTH_H
char *login_style;
#endif /* HAVE_BSD_AUTH_H */
sigaction_t saved_sa_int, saved_sa_quit, saved_sa_tstp;
static char *runas_user;
static char *runas_group;
static struct sudo_nss_list *snl;

/* For getopt(3) */
extern char *optarg;
extern int optind;

int
main(argc, argv, envp)
    int argc;
    char **argv;
    char **envp;
{
    int sources = 0, validated;
    int fd, cmnd_status, sudo_mode, pwflag, rc = 0;
    sigaction_t sa;
    struct sudo_nss *nss;
#if defined(SUDO_DEVEL) && defined(__OpenBSD__)
    extern char *malloc_options;
    malloc_options = "AFGJPR";
#endif

#ifdef HAVE_SETLOCALE
    setlocale(LC_ALL, "");
#endif

    Argv = argv;
    if ((Argc = argc) < 1)
	usage(1);

    /* Must be done as the first thing... */
#if defined(HAVE_GETPRPWNAM) && defined(HAVE_SET_AUTH_PARAMETERS)
    (void) set_auth_parameters(Argc, Argv);
# ifdef HAVE_INITPRIVS
    initprivs();
# endif
#endif /* HAVE_GETPRPWNAM && HAVE_SET_AUTH_PARAMETERS */

    if (geteuid() != 0)
	errorx(1, "must be setuid root");

    /*
     * Signal setup:
     *	Ignore keyboard-generated signals so the user cannot interrupt
     *  us at some point and avoid the logging.
     *  Install handler to wait for children when they exit.
     */
    zero_bytes(&sa, sizeof(sa));
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_IGN;
    (void) sigaction(SIGINT, &sa, &saved_sa_int);
    (void) sigaction(SIGQUIT, &sa, &saved_sa_quit);
    (void) sigaction(SIGTSTP, &sa, &saved_sa_tstp);

    /*
     * Turn off core dumps and make sure fds 0-2 are open.
     */
    initial_setup();
    sudo_setpwent();
    sudo_setgrent();

    /* Parse our arguments. */
    sudo_mode = parse_args(Argc, Argv);

    /* Setup defaults data structures. */
    init_defaults();

    /* Load the list of local ip addresses and netmasks.  */
    load_interfaces();

    pwflag = 0;
    if (ISSET(sudo_mode, MODE_SHELL))
	user_cmnd = "shell";
    else if (ISSET(sudo_mode, MODE_EDIT))
	user_cmnd = "sudoedit";
    else {
	switch (sudo_mode) {
	    case MODE_VERSION:
		show_version();
		break;
	    case MODE_HELP:
		usage(0);
		break;
	    case MODE_VALIDATE:
	    case MODE_VALIDATE|MODE_INVALIDATE:
		user_cmnd = "validate";
		pwflag = I_VERIFYPW;
		break;
	    case MODE_KILL:
	    case MODE_INVALIDATE:
		user_cmnd = "kill";
		pwflag = -1;
		break;
	    case MODE_LISTDEFS:
		list_options();
		exit(0);
		break;
	    case MODE_LIST:
	    case MODE_LIST|MODE_INVALIDATE:
		user_cmnd = "list";
		pwflag = I_LISTPW;
		break;
	    case MODE_CHECK:
	    case MODE_CHECK|MODE_INVALIDATE:
		pwflag = I_LISTPW;
		break;
	}
    }

    /* Must have a command to run... */
    if (user_cmnd == NULL && NewArgc == 0)
	usage(1);

    init_vars(sudo_mode, envp);		/* XXX - move this later? */

#ifdef USING_NONUNIX_GROUPS
    sudo_nonunix_groupcheck_init();	/* initialise nonunix groups impl */
#endif /* USING_NONUNIX_GROUPS */

    /* Parse nsswitch.conf for sudoers order. */
    snl = sudo_read_nss();

    /* Open and parse sudoers, set global defaults */
    tq_foreach_fwd(snl, nss) {
	if (nss->open(nss) == 0 && nss->parse(nss) == 0) {
	    sources++;
	    nss->setdefs(nss);
	}
    }
    if (sources == 0)
	log_error(0, "no valid sudoers sources found, quitting");

    /* XXX - collect post-sudoers parse settings into a function */

    /*
     * Set runas passwd/group entries based on command line or sudoers.
     * Note that if runas_group was specified without runas_user we
     * defer setting runas_pw so the match routines know to ignore it.
     */
    if (runas_group != NULL) {
	set_runasgr(runas_group);
	if (runas_user != NULL)
	    set_runaspw(runas_user);
    } else
	set_runaspw(runas_user ? runas_user : def_runas_default);

    if (!update_defaults(SETDEF_RUNAS))
	log_error(NO_STDERR|NO_EXIT, "problem with defaults entries");

    /* Set login class if applicable. */
    set_loginclass(runas_pw ? runas_pw : sudo_user.pw);

    /* Update initial shell now that runas is set. */
    if (ISSET(sudo_mode, MODE_LOGIN_SHELL))
	NewArgv[0] = runas_pw->pw_shell;

    /* This goes after sudoers is parsed since it may have timestamp options. */
    if (sudo_mode == MODE_KILL || sudo_mode == MODE_INVALIDATE) {
	remove_timestamp((sudo_mode == MODE_KILL));
	cleanup(0);
	exit(0);
    }

    /* Is root even allowed to run sudo? */
    if (user_uid == 0 && !def_root_sudo) {
	(void) fprintf(stderr,
	    "Sorry, %s has been configured to not allow root to run it.\n",
	    getprogname());
	exit(1);
    }

    /* Check for -C overriding def_closefrom. */
    if (user_closefrom >= 0 && user_closefrom != def_closefrom) {
	if (!def_closefrom_override)
	    errorx(1, "you are not permitted to use the -C option");
	else
	    def_closefrom = user_closefrom;
    }

    cmnd_status = set_cmnd(sudo_mode);

#ifdef HAVE_SETLOCALE
    if (!setlocale(LC_ALL, def_sudoers_locale)) {
	warningx("unable to set locale to \"%s\", using \"C\"",
	    def_sudoers_locale);
	setlocale(LC_ALL, "C");
    }
#endif

    validated = FLAG_NO_USER | FLAG_NO_HOST;
    tq_foreach_fwd(snl, nss) {
	validated = nss->lookup(nss, validated, pwflag);

	if (ISSET(validated, VALIDATE_OK)) {
	    /* Handle "= auth" in netsvc.conf */
	    if (nss->ret_if_found)
		break;
	} else {
	    /* Handle [NOTFOUND=return] */
	    if (nss->ret_if_notfound)
		break;
	}
    }

    if (safe_cmnd == NULL)
	safe_cmnd = estrdup(user_cmnd);

#ifdef HAVE_SETLOCALE
    setlocale(LC_ALL, "");
#endif

    /* If only a group was specified, set runas_pw based on invoking user. */
    if (runas_pw == NULL)
	set_runaspw(user_name);

    /*
     * Look up the timestamp dir owner if one is specified.
     */
    if (def_timestampowner) {
	struct passwd *pw;

	if (*def_timestampowner == '#')
	    pw = sudo_getpwuid(atoi(def_timestampowner + 1));
	else
	    pw = sudo_getpwnam(def_timestampowner);
	if (!pw)
	    log_error(0, "timestamp owner (%s): No such user",
		def_timestampowner);
	timestamp_uid = pw->pw_uid;
    }

    /* If given the -P option, set the "preserve_groups" flag. */
    if (ISSET(sudo_mode, MODE_PRESERVE_GROUPS))
	def_preserve_groups = TRUE;

    /* If no command line args and "set_home" is not set, error out. */
    if (ISSET(sudo_mode, MODE_IMPLIED_SHELL) && !def_shell_noargs)
	usage(1);

    /* Bail if a tty is required and we don't have one.  */
    if (def_requiretty) {
	if ((fd = open(_PATH_TTY, O_RDWR|O_NOCTTY)) == -1) {
	    audit_failure(NewArgv, "no tty");
	    log_error(NO_MAIL, "sorry, you must have a tty to run sudo");
	} else
	    (void) close(fd);
    }

    /* Use askpass value from sudoers unless user specified their own. */
    if (def_askpass && !user_askpass)
	user_askpass = def_askpass;

    /* User may have overridden environment resetting via the -E flag. */
    if (ISSET(sudo_mode, MODE_PRESERVE_ENV) && def_setenv)
	def_env_reset = FALSE;

    /* Build a new environment that avoids any nasty bits. */
    rebuild_env(sudo_mode, def_noexec);

    /* Fill in passwd struct based on user we are authenticating as.  */
    auth_pw = get_authpw();

    /* Require a password if sudoers says so.  */
    if (def_authenticate)
	check_user(validated, sudo_mode);

    /* If run as root with SUDO_USER set, set sudo_user.pw to that user. */
    /* XXX - causes confusion when root is not listed in sudoers */
    if (sudo_mode & (MODE_RUN | MODE_EDIT) && prev_user != NULL) {
	if (user_uid == 0 && strcmp(prev_user, "root") != 0) {
	    struct passwd *pw;

	    if ((pw = sudo_getpwnam(prev_user)) != NULL)
		    sudo_user.pw = pw;
	}
    }

    if (ISSET(validated, VALIDATE_OK)) {
	/* Finally tell the user if the command did not exist. */
	if (cmnd_status == NOT_FOUND_DOT) {
	    audit_failure(NewArgv, "command in current directory");
	    errorx(1, "ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.", user_cmnd, user_cmnd, user_cmnd);
	} else if (cmnd_status == NOT_FOUND) {
	    audit_failure(NewArgv, "%s: command not found", user_cmnd);
	    errorx(1, "%s: command not found", user_cmnd);
	}

	/* If user specified env vars make sure sudoers allows it. */
	if (ISSET(sudo_mode, MODE_RUN) && !def_setenv) {
	    if (ISSET(sudo_mode, MODE_PRESERVE_ENV))
		log_error(NO_MAIL,
		    "sorry, you are not allowed to preserve the environment");
	    else
		validate_env_vars(sudo_user.env_vars);
	}

	log_allowed(validated);
	if (ISSET(sudo_mode, MODE_CHECK))
	    rc = display_cmnd(snl, list_pw ? list_pw : sudo_user.pw);
	else if (ISSET(sudo_mode, MODE_LIST))
	    display_privs(snl, list_pw ? list_pw : sudo_user.pw);

	/* Cleanup sudoers sources */
	tq_foreach_fwd(snl, nss)
	    nss->close(nss);

#ifdef USING_NONUNIX_GROUPS
	/* Finished with the groupcheck code */
	sudo_nonunix_groupcheck_cleanup();
#endif

	/* Deferred exit due to sudo_ldap_close() */
	if (ISSET(sudo_mode, (MODE_VALIDATE|MODE_CHECK|MODE_LIST)))
	    exit(rc);

	/*
	 * Set umask based on sudoers.
	 * If user's umask is more restrictive, OR in those bits too
	 * unless umask_override is set.
	 */
	if (def_umask != 0777) {
	    if (def_umask_override) {
		umask(def_umask);
	    } else {
		mode_t mask = umask(def_umask);
		mask |= def_umask;
		if (mask != def_umask)
		    umask(mask);
	    }
	}

	/* Restore coredumpsize resource limit. */
#if defined(RLIMIT_CORE) && !defined(SUDO_DEVEL)
	(void) setrlimit(RLIMIT_CORE, &corelimit);
#endif /* RLIMIT_CORE && !SUDO_DEVEL */

	/* Must audit before uid change. */
	audit_success(NewArgv);

	/* Become specified user or root if executing a command. */
	if (ISSET(sudo_mode, MODE_RUN))
	    set_perms(PERM_FULL_RUNAS);

	if (ISSET(sudo_mode, MODE_LOGIN_SHELL)) {
	    char *p;

	    /* Convert /bin/sh -> -sh so shell knows it is a login shell */
	    if ((p = strrchr(NewArgv[0], '/')) == NULL)
		p = NewArgv[0];
	    *p = '-';
	    NewArgv[0] = p;

	    /* Change to target user's homedir. */
	    if (chdir(runas_pw->pw_dir) == -1)
		warning("unable to change directory to %s", runas_pw->pw_dir);

#if defined(__linux__) || defined(_AIX)
	    /* Insert system-wide environment variables. */
	    read_env_file(_PATH_ENVIRONMENT, TRUE);
#endif
	}

	if (ISSET(sudo_mode, MODE_EDIT))
	    exit(sudo_edit(NewArgc, NewArgv, envp));

	/* Insert system-wide environment variables. */
	if (def_env_file)
	    read_env_file(def_env_file, FALSE);

	/* Insert user-specified environment variables. */
	insert_env_vars(sudo_user.env_vars);

	/* Restore signal handlers before we exec. */
	(void) sigaction(SIGINT, &saved_sa_int, NULL);
	(void) sigaction(SIGQUIT, &saved_sa_quit, NULL);
	(void) sigaction(SIGTSTP, &saved_sa_tstp, NULL);

	/* Close the password and group files and free up memory. */
	sudo_endpwent();
	sudo_endgrent();

	closefrom(def_closefrom);

#ifndef PROFILING
	if (ISSET(sudo_mode, MODE_BACKGROUND) && fork() > 0) {
	    syslog(LOG_AUTH|LOG_ERR, "fork");
	    exit(0);
	} else {
#ifdef HAVE_SELINUX
	    if (is_selinux_enabled() > 0 && user_role != NULL)
		selinux_exec(user_role, user_type, NewArgv,
		    ISSET(sudo_mode, MODE_LOGIN_SHELL));
#endif
	    execv(safe_cmnd, NewArgv);
	}
#else
	exit(0);
#endif /* PROFILING */
	/*
	 * If we got here then execve() failed...
	 */
	if (errno == ENOEXEC) {
	    NewArgv--;			/* at least one extra slot... */
	    NewArgv[0] = "sh";
	    NewArgv[1] = safe_cmnd;
	    execv(_PATH_BSHELL, NewArgv);
	}
	warning("unable to execute %s", safe_cmnd);
	exit(127);
    } else if (ISSET(validated, FLAG_NO_USER | FLAG_NO_HOST)) {
	audit_failure(NewArgv, "No user or host");
	log_denial(validated, 1);
	exit(1);
    } else {
	if (def_path_info) {
	    /*
	     * We'd like to not leak path info at all here, but that can
	     * *really* confuse the users.  To really close the leak we'd
	     * have to say "not allowed to run foo" even when the problem
	     * is just "no foo in path" since the user can trivially set
	     * their path to just contain a single dir.
	     */
	    log_denial(validated,
		!(cmnd_status == NOT_FOUND_DOT || cmnd_status == NOT_FOUND));
	    if (cmnd_status == NOT_FOUND)
		warningx("%s: command not found", user_cmnd);
	    else if (cmnd_status == NOT_FOUND_DOT)
		warningx("ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.", user_cmnd, user_cmnd, user_cmnd);
	} else {
	    /* Just tell the user they are not allowed to run foo. */
	    log_denial(validated, 1);
	}
	audit_failure(NewArgv, "validation failure");
	exit(1);
    }
    exit(0);	/* not reached */
}

/*
 * Initialize timezone, set umask, fill in ``sudo_user'' struct and
 * load the ``interfaces'' array.
 */
static void
init_vars(sudo_mode, envp)
    int sudo_mode;
    char **envp;
{
    char *p, **ep, thost[MAXHOSTNAMELEN + 1];
    int nohostname;

    /* Sanity check command from user. */
    if (user_cmnd == NULL && strlen(NewArgv[0]) >= PATH_MAX)
	errorx(1, "%s: File name too long", NewArgv[0]);

#ifdef HAVE_TZSET
    (void) tzset();		/* set the timezone if applicable */
#endif /* HAVE_TZSET */

    /* Default value for cmnd and cwd, overridden later. */
    if (user_cmnd == NULL)
	user_cmnd = NewArgv[0];
    (void) strlcpy(user_cwd, "unknown", sizeof(user_cwd));

    /*
     * We avoid gethostbyname() if possible since we don't want
     * sudo to block if DNS or NIS is hosed.
     * "host" is the (possibly fully-qualified) hostname and
     * "shost" is the unqualified form of the hostname.
     */
    nohostname = gethostname(thost, sizeof(thost));
    if (nohostname)
	user_host = user_shost = "localhost";
    else {
	thost[sizeof(thost) - 1] = '\0';
	user_host = estrdup(thost);
	if (def_fqdn) {
	    /* Defer call to set_fqdn() until log_error() is safe. */
	    user_shost = user_host;
	} else {
	    if ((p = strchr(user_host, '.'))) {
		*p = '\0';
		user_shost = estrdup(user_host);
		*p = '.';
	    } else {
		user_shost = user_host;
	    }
	}
    }

    if ((p = ttyname(STDIN_FILENO)) || (p = ttyname(STDOUT_FILENO)) ||
	(p = ttyname(STDERR_FILENO))) {
	user_tty = user_ttypath = estrdup(p);
	if (strncmp(user_tty, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
	    user_tty += sizeof(_PATH_DEV) - 1;
    } else
	user_tty = "unknown";

    for (ep = envp; *ep; ep++) {
	/* XXX - don't fill in if empty string */
	switch (**ep) {
	    case 'D':
		if (strncmp("DISPLAY=", *ep, 8) == 0)
		    user_display = *ep + 8;
		break;
	    case 'K':
		if (strncmp("KRB5CCNAME=", *ep, 11) == 0)
		    user_ccname = *ep + 11;
		break;
	    case 'P':
		if (strncmp("PATH=", *ep, 5) == 0)
		    user_path = *ep + 5;
		break;
	    case 'S':
		if (strncmp("SHELL=", *ep, 6) == 0)
		    user_shell = *ep + 6;
		else if (!user_prompt && strncmp("SUDO_PROMPT=", *ep, 12) == 0)
		    user_prompt = *ep + 12;
		else if (strncmp("SUDO_USER=", *ep, 10) == 0)
		    prev_user = *ep + 10;
		else if (strncmp("SUDO_ASKPASS=", *ep, 13) == 0)
		    user_askpass = *ep + 13;
		break;
	    }
    }

    /*
     * Get a local copy of the user's struct passwd with the shadow password
     * if necessary.  It is assumed that euid is 0 at this point so we
     * can read the shadow passwd file if necessary.
     */
    if ((sudo_user.pw = sudo_getpwuid(getuid())) == NULL) {
	/* Need to make a fake struct passwd for logging to work. */
	struct passwd pw;
	char pw_name[MAX_UID_T_LEN + 1];

	pw.pw_uid = getuid();
	(void) snprintf(pw_name, sizeof(pw_name), "%lu",
	    (unsigned long) pw.pw_uid);
	pw.pw_name = pw_name;
	sudo_user.pw = &pw;

	/*
	 * If we are in -k/-K mode, just spew to stderr.  It is not unusual for
	 * users to place "sudo -k" in a .logout file which can cause sudo to
	 * be run during reboot after the YP/NIS/NIS+/LDAP/etc daemon has died.
	 */
	if (sudo_mode == MODE_KILL || sudo_mode == MODE_INVALIDATE)
	    errorx(1, "unknown uid: %s", pw_name);
	log_error(0, "unknown uid: %s", pw_name);
    }
    if (user_shell == NULL || *user_shell == '\0')
	user_shell = estrdup(sudo_user.pw->pw_shell);

    /* It is now safe to use log_error() and set_perms() */

#ifdef HAVE_GETGROUPS
    if ((user_ngroups = getgroups(0, NULL)) > 0) {
	user_groups = emalloc2(user_ngroups, sizeof(GETGROUPS_T));
	if (getgroups(user_ngroups, user_groups) < 0)
	    log_error(USE_ERRNO|MSG_ONLY, "can't get group vector");
    } else
	user_ngroups = 0;
#endif

    if (def_fqdn)
	set_fqdn();			/* may call log_error() */

    if (nohostname)
	log_error(USE_ERRNO|MSG_ONLY, "can't get hostname");

    /*
     * Get current working directory.  Try as user, fall back to root.
     */
    set_perms(PERM_USER);
    if (!getcwd(user_cwd, sizeof(user_cwd))) {
	set_perms(PERM_ROOT);
	if (!getcwd(user_cwd, sizeof(user_cwd))) {
	    warningx("cannot get working directory");
	    (void) strlcpy(user_cwd, "unknown", sizeof(user_cwd));
	}
    } else
	set_perms(PERM_ROOT);

    /*
     * If we were given the '-e', '-i' or '-s' options we need to redo
     * NewArgv and NewArgc.
     */
    if (ISSET(sudo_mode, MODE_EDIT)) {
	NewArgv--;
	NewArgc++;
	NewArgv[0] = "sudoedit";
    } else if (ISSET(sudo_mode, MODE_SHELL)) {
	char **av;

	/* Allocate an extra slot for execve() failure (ENOEXEC). */
	av = (char **) emalloc2(5, sizeof(char *));
	av++;

	av[0] = user_shell;	/* may be updated later */
	if (NewArgc > 0) {
	    size_t size;
	    char *cmnd, *src, *dst, *end;
	    size = (size_t) (NewArgv[NewArgc - 1] - NewArgv[0]) +
		    strlen(NewArgv[NewArgc - 1]) + 1;
	    cmnd = emalloc(size);
	    src = NewArgv[0];
	    dst = cmnd;
	    for (end = src + size - 1; src < end; src++, dst++)
		*dst = *src == 0 ? ' ' : *src;
	    *dst = '\0';
	    av[1] = "-c";
	    av[2] = cmnd;
	    NewArgc = 2;
	}
	av[++NewArgc] = NULL;
	NewArgv = av;
    }
}

/*
 * Fill in user_cmnd, user_args, user_base and user_stat variables
 * and apply any command-specific defaults entries.
 */
static int
set_cmnd(sudo_mode)
    int sudo_mode;
{
    int rval;

    /* Set project if applicable. */
    set_project(runas_pw);

    /* Resolve the path and return. */
    rval = FOUND;
    user_stat = emalloc(sizeof(struct stat));
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
	if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) {
	    set_perms(PERM_RUNAS);
	    rval = find_path(NewArgv[0], &user_cmnd, user_stat, user_path);
	    set_perms(PERM_ROOT);
	    if (rval != FOUND) {
		/* Failed as root, try as invoking user. */
		set_perms(PERM_USER);
		rval = find_path(NewArgv[0], &user_cmnd, user_stat, user_path);
		set_perms(PERM_ROOT);
	    }
	}

	/* set user_args */
	if (NewArgc > 1) {
	    char *to, **from;
	    size_t size, n;

	    /* If we didn't realloc NewArgv it is contiguous so just count. */
	    if (!ISSET(sudo_mode, MODE_SHELL)) {
		size = (size_t) (NewArgv[NewArgc-1] - NewArgv[1]) +
			strlen(NewArgv[NewArgc-1]) + 1;
	    } else {
		for (size = 0, from = NewArgv + 1; *from; from++)
		    size += strlen(*from) + 1;
	    }

	    /* Alloc and build up user_args. */
	    user_args = (char *) emalloc(size);
	    for (to = user_args, from = NewArgv + 1; *from; from++) {
		n = strlcpy(to, *from, size - (to - user_args));
		if (n >= size - (to - user_args))
		    errorx(1, "internal error, init_vars() overflow");
		to += n;
		*to++ = ' ';
	    }
	    *--to = '\0';
	}
    }
    if ((user_base = strrchr(user_cmnd, '/')) != NULL)
	user_base++;
    else
	user_base = user_cmnd;

    if (!update_defaults(SETDEF_CMND))
	log_error(NO_STDERR|NO_EXIT, "problem with defaults entries");

    if (!runas_user && !runas_group)
	set_runaspw(def_runas_default);	/* may have been updated above */

    return(rval);
}

/*
 * Command line argument parsing.
 * Sets NewArgc and NewArgv which corresponds to the argc/argv we'll use
 * for the command to be run (if we are running one).
 */
static int
parse_args(argc, argv)
    int argc;
    char **argv;
{
    int mode = 0;		/* what mode is sudo to be run in? */
    int flags = 0;		/* mode flags */
    int valid_flags, ch;

    /* First, check to see if we were invoked as "sudoedit". */
    if (strcmp(getprogname(), "sudoedit") == 0)
	mode = MODE_EDIT;

    /* Returns true if the last option string was "--" */
#define got_end_of_args	(optind > 1 && argv[optind - 1][0] == '-' && \
	    argv[optind - 1][1] == '-' && argv[optind - 1][2] == '\0')

    /* Returns true if next option is an environment variable */
#define is_envar (optind < argc && argv[optind][0] != '/' && \
	    strchr(argv[optind], '=') != NULL)

    /* Flags allowed when running a command */
    valid_flags = MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|
		  MODE_LOGIN_SHELL|MODE_INVALIDATE|MODE_NONINTERACTIVE|
		  MODE_PRESERVE_GROUPS|MODE_SHELL;
    for (;;) {
	/*
	 * We disable arg permutation for GNU getopt().
	 * Some trickiness is required to allow environment variables
	 * to be interspersed with command line options.
	 */
	if ((ch = getopt(argc, argv, "+Aa:bC:c:Eeg:HhiKkLlnPp:r:Sst:U:u:Vv")) != -1) {
	    switch (ch) {
		case 'A':
		    SET(tgetpass_flags, TGP_ASKPASS);
		    break;
#ifdef HAVE_BSD_AUTH_H
		case 'a':
		    login_style = optarg;
		    break;
#endif
		case 'b':
		    SET(flags, MODE_BACKGROUND);
		    break;
		case 'C':
		    if ((user_closefrom = atoi(optarg)) < 3) {
			warningx("the argument to -C must be at least 3");
			usage(1);
		    }
		    break;
#ifdef HAVE_LOGIN_CAP_H
		case 'c':
		    login_class = optarg;
		    def_use_loginclass = TRUE;
		    break;
#endif
		case 'E':
		    SET(flags, MODE_PRESERVE_ENV);
		    break;
		case 'e':
		    if (mode && mode != MODE_EDIT)
			usage_excl(1);
		    mode = MODE_EDIT;
		    valid_flags = MODE_INVALIDATE|MODE_NONINTERACTIVE;
		    break;
		case 'g':
		    runas_group = optarg;
		    break;
		case 'H':
		    SET(flags, MODE_RESET_HOME);
		    break;
		case 'h':
		    if (mode && mode != MODE_HELP) {
			if (strcmp(getprogname(), "sudoedit") != 0)
			    usage_excl(1);
		    }
		    mode = MODE_HELP;
		    valid_flags = 0;
		    break;
		case 'i':
		    SET(flags, MODE_LOGIN_SHELL);
		    def_env_reset = TRUE;
		    break;
		case 'k':
		    SET(flags, MODE_INVALIDATE);
		    break;
		case 'K':
		    if (mode && mode != MODE_KILL)
			usage_excl(1);
		    mode = MODE_KILL;
		    valid_flags = 0;
		    break;
		case 'L':
		    if (mode && mode != MODE_LISTDEFS)
			usage_excl(1);
		    mode = MODE_LISTDEFS;
		    valid_flags = MODE_INVALIDATE|MODE_NONINTERACTIVE;
		    break;
		case 'l':
		    if (mode) {
			if (mode == MODE_LIST)
			    long_list = 1;
			else
			    usage_excl(1);
		    }
		    mode = MODE_LIST;
		    valid_flags = MODE_INVALIDATE|MODE_NONINTERACTIVE;
		    break;
		case 'n':
		    SET(flags, MODE_NONINTERACTIVE);
		    break;
		case 'P':
		    SET(flags, MODE_PRESERVE_GROUPS);
		    break;
		case 'p':
		    user_prompt = optarg;
		    def_passprompt_override = TRUE;
		    break;
#ifdef HAVE_SELINUX
		case 'r':
		    user_role = optarg;
		    break;
		case 't':
		    user_type = optarg;
		    break;
#endif
		case 'S':
		    SET(tgetpass_flags, TGP_STDIN);
		    break;
		case 's':
		    SET(flags, MODE_SHELL);
		    break;
		case 'U':
		    if ((list_pw = sudo_getpwnam(optarg)) == NULL)
			errorx(1, "unknown user: %s", optarg);
		    break;
		case 'u':
		    runas_user = optarg;
		    break;
		case 'v':
		    if (mode && mode != MODE_VALIDATE)
			usage_excl(1);
		    mode = MODE_VALIDATE;
		    valid_flags = MODE_INVALIDATE|MODE_NONINTERACTIVE;
		    break;
		case 'V':
		    if (mode && mode != MODE_VERSION)
			usage_excl(1);
		    mode = MODE_VERSION;
		    valid_flags = 0;
		    break;
		default:
		    usage(1);
	    }
	} else if (!got_end_of_args && is_envar) {
	    struct list_member *ev;

	    /* Store environment variable. */
	    ev = emalloc(sizeof(*ev));
	    ev->value = argv[optind];
	    ev->next = sudo_user.env_vars;
	    sudo_user.env_vars = ev;

	    /* Crank optind and resume getopt. */
	    optind++;
	} else {
	    /* Not an option or an environment variable -- we're done. */
	    break;
	}
    }

    NewArgc = argc - optind;
    NewArgv = argv + optind;

    if (!mode) {
	/* Defer -k mode setting until we know whether it is a flag or not */
	if (ISSET(flags, MODE_INVALIDATE) && NewArgc == 0) {
	    mode = MODE_INVALIDATE;	/* -k by itself */
	    CLR(flags, MODE_INVALIDATE);
	    valid_flags = 0;
	} else {
	    mode = MODE_RUN;		/* running a command */
	}
    }

    if (NewArgc > 0 && mode == MODE_LIST)
	mode = MODE_CHECK;

    if (ISSET(flags, MODE_LOGIN_SHELL)) {
	if (ISSET(flags, MODE_SHELL)) {
	    warningx("you may not specify both the `-i' and `-s' options");
	    usage(1);
	}
	if (ISSET(flags, MODE_PRESERVE_ENV)) {
	    warningx("you may not specify both the `-i' and `-E' options");
	    usage(1);
	}
	SET(flags, MODE_SHELL);
    }
    if ((flags & valid_flags) != flags)
	usage(1);
    if (mode == MODE_EDIT &&
       (ISSET(flags, MODE_PRESERVE_ENV) || sudo_user.env_vars != NULL)) {
	if (ISSET(mode, MODE_PRESERVE_ENV))
	    warningx("the `-E' option is not valid in edit mode");
	if (sudo_user.env_vars != NULL)
	    warningx("you may not specify environment variables in edit mode");
	usage(1);
    }
    if ((runas_user != NULL || runas_group != NULL) &&
	!ISSET(mode, MODE_EDIT | MODE_RUN | MODE_CHECK)) {
	usage(1);
    }
    if (list_pw != NULL && mode != MODE_LIST && mode != MODE_CHECK) {
	warningx("the `-U' option may only be used with the `-l' option");
	usage(1);
    }
    if (ISSET(tgetpass_flags, TGP_STDIN) && ISSET(tgetpass_flags, TGP_ASKPASS)) {
	warningx("the `-A' and `-S' options may not be used together");
	usage(1);
    }
    if ((NewArgc == 0 && mode == MODE_EDIT) ||
	(NewArgc > 0 && !ISSET(mode, MODE_RUN | MODE_EDIT | MODE_CHECK)))
	usage(1);
    if (NewArgc == 0 && mode == MODE_RUN && !ISSET(flags, MODE_SHELL))
	SET(flags, (MODE_IMPLIED_SHELL | MODE_SHELL));

    return(mode | flags);
}

/*
 * Open sudoers and sanity check mode/owner/type.
 * Returns a handle to the sudoers file or NULL on error.
 */
FILE *
open_sudoers(sudoers, doedit, keepopen)
    const char *sudoers;
    int doedit;
    int *keepopen;
{
    struct stat statbuf;
    FILE *fp = NULL;

    /*
     * Sanity checks on sudoers file.  Must be done as sudoers
     * file owner.  We already did a stat as root, so use that
     * data if we can't stat as sudoers file owner.
     */
    set_perms(PERM_SUDOERS);

    if (stat_sudoers(sudoers, &statbuf) != 0)
	log_error(USE_ERRNO|NO_EXIT, "can't stat %s", sudoers);
    else if (!S_ISREG(statbuf.st_mode))
	log_error(NO_EXIT, "%s is not a regular file", sudoers);
    else if ((statbuf.st_mode & 07777) != SUDOERS_MODE)
	log_error(NO_EXIT, "%s is mode 0%o, should be 0%o", sudoers,
	    (unsigned int) (statbuf.st_mode & 07777),
	    (unsigned int) SUDOERS_MODE);
    else if (statbuf.st_uid != SUDOERS_UID)
	log_error(NO_EXIT, "%s is owned by uid %lu, should be %lu", sudoers,
	    (unsigned long) statbuf.st_uid, (unsigned long) SUDOERS_UID);
    else if (statbuf.st_gid != SUDOERS_GID)
	log_error(NO_EXIT, "%s is owned by gid %lu, should be %lu", sudoers,
	    (unsigned long) statbuf.st_gid, (unsigned long) SUDOERS_GID);
    else if ((fp = fopen(sudoers, "r")) == NULL)
	log_error(USE_ERRNO|NO_EXIT, "can't open %s", sudoers);
    else {
	/*
	 * Make sure we can actually read sudoers so we can present the
	 * user with a reasonable error message (unlike the lexer).
	 */
	if (statbuf.st_size != 0 && fgetc(fp) == EOF) {
	    log_error(USE_ERRNO|NO_EXIT, "can't read %s", sudoers);
	    fclose(fp);
	    fp = NULL;
	}
    }

    if (fp != NULL) {
	rewind(fp);
	(void) fcntl(fileno(fp), F_SETFD, FD_CLOEXEC);
    }

    set_perms(PERM_ROOT);		/* change back to root */
    return(fp);
}

/*
 * Close all open files (except std*) and turn off core dumps.
 * Also sets the set_perms() pointer to the correct function.
 */
static void
initial_setup()
{
    int miss[3], devnull = -1;
#if defined(__linux__) || (defined(RLIMIT_CORE) && !defined(SUDO_DEVEL))
    struct rlimit rl;
#endif

#if defined(__linux__)
    /*
     * Unlimit the number of processes since Linux's setuid() will
     * apply resource limits when changing uid and return EAGAIN if
     * nproc would be violated by the uid switch.
     */
    rl.rlim_cur = rl.rlim_max = RLIM_INFINITY;
    if (setrlimit(RLIMIT_NPROC, &rl)) {
	if (getrlimit(RLIMIT_NPROC, &rl) == 0) {
	    rl.rlim_cur = rl.rlim_max;
	    (void)setrlimit(RLIMIT_NPROC, &rl);
	}
    }
#endif /* __linux__ */
#if defined(RLIMIT_CORE) && !defined(SUDO_DEVEL)
    /*
     * Turn off core dumps.
     */
    (void) getrlimit(RLIMIT_CORE, &corelimit);
    memcpy(&rl, &corelimit, sizeof(struct rlimit));
    rl.rlim_cur = 0;
    (void) setrlimit(RLIMIT_CORE, &rl);
#endif /* RLIMIT_CORE && !SUDO_DEVEL */

    /*
     * stdin, stdout and stderr must be open; set them to /dev/null
     * if they are closed and close all other fds.
     */
    miss[STDIN_FILENO] = fcntl(STDIN_FILENO, F_GETFL, 0) == -1;
    miss[STDOUT_FILENO] = fcntl(STDOUT_FILENO, F_GETFL, 0) == -1;
    miss[STDERR_FILENO] = fcntl(STDERR_FILENO, F_GETFL, 0) == -1;
    if (miss[STDIN_FILENO] || miss[STDOUT_FILENO] || miss[STDERR_FILENO]) {
	if ((devnull = open(_PATH_DEVNULL, O_RDWR, 0644)) != -1) {
	    if (miss[STDIN_FILENO])
		(void) dup2(devnull, STDIN_FILENO);
	    if (miss[STDOUT_FILENO])
		(void) dup2(devnull, STDOUT_FILENO);
	    if (miss[STDERR_FILENO])
		(void) dup2(devnull, STDERR_FILENO);
	    if (devnull > STDERR_FILENO)
		close(devnull);
	}
    }
}

#ifdef HAVE_LOGIN_CAP_H
static void
set_loginclass(pw)
    struct passwd *pw;
{
    int errflags;

    if (!def_use_loginclass)
	return;

    /*
     * Don't make it a fatal error if the user didn't specify the login
     * class themselves.  We do this because if login.conf gets
     * corrupted we want the admin to be able to use sudo to fix it.
     */
    if (login_class)
	errflags = NO_MAIL|MSG_ONLY;
    else
	errflags = NO_MAIL|MSG_ONLY|NO_EXIT;

    if (login_class && strcmp(login_class, "-") != 0) {
	if (user_uid != 0 && pw->pw_uid != 0)
	    errorx(1, "only root can use -c %s", login_class);
    } else {
	login_class = pw->pw_class;
	if (!login_class || !*login_class)
	    login_class =
		(pw->pw_uid == 0) ? LOGIN_DEFROOTCLASS : LOGIN_DEFCLASS;
    }

    /* Make sure specified login class is valid. */
    lc = login_getclass(login_class);
    if (!lc || !lc->lc_class || strcmp(lc->lc_class, login_class) != 0) {
	log_error(errflags, "unknown login class: %s", login_class);
	def_use_loginclass = FALSE;
    }
}
#else
static void
set_loginclass(pw)
    struct passwd *pw;
{
}
#endif /* HAVE_LOGIN_CAP_H */

#ifdef HAVE_PROJECT_H
static void
set_project(pw)
    struct passwd *pw;
{
    int errflags = NO_MAIL|MSG_ONLY|NO_EXIT;
    int errval;
    struct project proj;
    struct project *resultp = '\0';
    char buf[1024];

    /*
     * Collect the default project for the user and settaskid
     */
    setprojent();
    if (resultp = getdefaultproj(pw->pw_name, &proj, buf, sizeof(buf))) {
	errval = setproject(resultp->pj_name, pw->pw_name, TASK_NORMAL);
	if (errval != 0) {
	    switch(errval) {
	    case SETPROJ_ERR_TASK:
		if (errno == EAGAIN)
		    log_error(errflags, "resource control limit has been reached");
		else if (errno == ESRCH)
		    log_error(errflags, "user \"%s\" is not a member of "
			"project \"%s\"", pw->pw_name, resultp->pj_name);
		else if (errno == EACCES)
		    log_error(errflags, "the invoking task is final");
		else
		    log_error(errflags, "could not join project \"%s\"",
			resultp->pj_name);
		break;
	    case SETPROJ_ERR_POOL:
		if (errno == EACCES)
		    log_error(errflags, "no resource pool accepting "
			    "default bindings exists for project \"%s\"",
			    resultp->pj_name);
		else if (errno == ESRCH)
		    log_error(errflags, "specified resource pool does "
			    "not exist for project \"%s\"", resultp->pj_name);
		else
		    log_error(errflags, "could not bind to default "
			    "resource pool for project \"%s\"", resultp->pj_name);
		break;
	    default:
		if (errval <= 0) {
		    log_error(errflags, "setproject failed for project \"%s\"",
			resultp->pj_name);
		} else {
		    log_error(errflags, "warning, resource control assignment "
			"failed for project \"%s\"", resultp->pj_name);
		}
	    }
	}
    } else {
	log_error(errflags, "getdefaultproj() error: %s", strerror(errno));
    }
    endprojent();
}
#else
static void
set_project(pw)
    struct passwd *pw;
{
}
#endif /* HAVE_PROJECT_H */

/*
 * Look up the fully qualified domain name and set user_host and user_shost.
 */
void
set_fqdn()
{
#ifdef HAVE_GETADDRINFO
    struct addrinfo *res0, hint;
#else
    struct hostent *hp;
#endif
    char *p;

#ifdef HAVE_GETADDRINFO
    zero_bytes(&hint, sizeof(hint));
    hint.ai_family = PF_UNSPEC;
    hint.ai_flags = AI_CANONNAME;
    if (getaddrinfo(user_host, NULL, &hint, &res0) != 0) {
#else
    if (!(hp = gethostbyname(user_host))) {
#endif
	log_error(MSG_ONLY|NO_EXIT,
	    "unable to resolve host %s", user_host);
    } else {
	if (user_shost != user_host)
	    efree(user_shost);
	efree(user_host);
#ifdef HAVE_GETADDRINFO
	user_host = estrdup(res0->ai_canonname);
	freeaddrinfo(res0);
#else
	user_host = estrdup(hp->h_name);
#endif
    }
    if ((p = strchr(user_host, '.'))) {
	*p = '\0';
	user_shost = estrdup(user_host);
	*p = '.';
    } else {
	user_shost = user_host;
    }
}

/*
 * Get passwd entry for the user we are going to run commands as.
 * By default, this is "root".  Updates runas_pw as a side effect.
 */
static void
set_runaspw(user)
    char *user;
{
    if (*user == '#') {
	if ((runas_pw = sudo_getpwuid(atoi(user + 1))) == NULL)
	    runas_pw = sudo_fakepwnam(user, runas_gr ? runas_gr->gr_gid : 0);
    } else {
	if ((runas_pw = sudo_getpwnam(user)) == NULL) {
	    audit_failure(NewArgv, "unknown user: %s", user);
	    log_error(NO_MAIL|MSG_ONLY, "unknown user: %s", user);
	}
    }
}

/*
 * Get group entry for the group we are going to run commands as.
 * Updates runas_pw as a side effect.
 */
static void
set_runasgr(group)
    char *group;
{
    if (*group == '#') {
	if ((runas_gr = sudo_getgrgid(atoi(group + 1))) == NULL)
	    runas_gr = sudo_fakegrnam(group);
    } else {
	if ((runas_gr = sudo_getgrnam(group)) == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "unknown group: %s", group);
    }
}

/*
 * Get passwd entry for the user we are going to authenticate as.
 * By default, this is the user invoking sudo.  In the most common
 * case, this matches sudo_user.pw or runas_pw.
 */
static struct passwd *
get_authpw()
{
    struct passwd *pw;

    if (def_rootpw) {
	if ((pw = sudo_getpwuid(0)) == NULL)
	    log_error(0, "unknown uid: 0");
    } else if (def_runaspw) {
	if ((pw = sudo_getpwnam(def_runas_default)) == NULL)
	    log_error(0, "unknown user: %s", def_runas_default);
    } else if (def_targetpw) {
	if (runas_pw->pw_name == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "unknown uid: %lu",
		(unsigned long) runas_pw->pw_uid);
	pw = runas_pw;
    } else
	pw = sudo_user.pw;

    return(pw);
}

/*
 * Cleanup hook for error()/errorx()
 */
void
cleanup(gotsignal)
    int gotsignal;
{
    struct sudo_nss *nss;

    if (!gotsignal) {
	if (snl != NULL) {
	    tq_foreach_fwd(snl, nss)
		nss->close(nss);
	}
#ifdef USING_NONUNIX_GROUPS
	sudo_nonunix_groupcheck_cleanup();
#endif
	sudo_endpwent();
	sudo_endgrent();
    }
}

static void
show_version()
{
    (void) printf("Sudo version %s\n", PACKAGE_VERSION);
    if (getuid() == 0) {
	putchar('\n');
	(void) printf("Sudoers path: %s\n", _PATH_SUDOERS);
#ifdef HAVE_LDAP
# ifdef _PATH_NSSWITCH_CONF
	(void) printf("nsswitch path: %s\n", _PATH_NSSWITCH_CONF);
# endif
	(void) printf("ldap.conf path: %s\n", _PATH_LDAP_CONF);
	(void) printf("ldap.secret path: %s\n", _PATH_LDAP_SECRET);
#endif
	dump_auth_methods();
	dump_defaults();
	dump_interfaces();
    }
    exit(0);
}

/*
 * Tell which options are mutually exclusive and exit.
 */
static void
usage_excl(exit_val)
    int exit_val;
{
    warningx("Only one of the -e, -h, -i, -K, -l, -s, -v or -V options may be specified");
    usage(exit_val);
}

/*
 * Give usage message and exit.
 * The actual usage strings are in sudo_usage.h for configure substitution.
 */
static void
usage(exit_val)
    int exit_val;
{
    struct lbuf lbuf;
    char *uvec[6];
    int i, ulen;

    /*
     * Use usage vectors appropriate to the progname.
     */
    if (strcmp(getprogname(), "sudoedit") == 0) {
	uvec[0] = SUDO_USAGE5 + 3;
	uvec[1] = NULL;
    } else {
	uvec[0] = SUDO_USAGE1;
	uvec[1] = SUDO_USAGE2;
	uvec[2] = SUDO_USAGE3;
	uvec[3] = SUDO_USAGE4;
	uvec[4] = SUDO_USAGE5;
	uvec[5] = NULL;
    }

    /*
     * Print usage and wrap lines as needed, depending on the
     * tty width.
     */
    ulen = (int)strlen(getprogname()) + 8;
    lbuf_init(&lbuf, NULL, ulen, 0);
    for (i = 0; uvec[i] != NULL; i++) {
	lbuf_append(&lbuf, "usage: ", getprogname(), uvec[i], NULL);
	lbuf_print(&lbuf);
    }
    lbuf_destroy(&lbuf);
    exit(exit_val);
}
@


1.48
log
@When checking whether a user may change the login class, just check
pw_uid of the runas user, which was passed in to set_loginclass().
@
text
@@


1.47
log
@Back port remainder of use_loginclass fix from sudo 1.7.9.
@
text
@d1216 1
a1216 2
	if (user_uid != 0 &&
	    strcmp(runas_user ? runas_user : def_runas_default, "root") != 0)
@


1.46
log
@use FD_CLOEXEC instead of 1; from David Hill

ok otto
@
text
@d1202 3
d1226 1
d1230 1
a1230 2
	if (!lc)
	    lc = login_getclass(NULL);	/* needed for login_getstyle() later */
@


1.45
log
@Fix use_loginclass, backport from upstream.
@
text
@d1131 1
a1131 1
	(void) fcntl(fileno(fp), F_SETFD, 1);
@


1.44
log
@Remove obsolete code that used to change the mode of sudoers from
the old (pre-1.6) default.
@
text
@d308 1
a308 1
    set_loginclass(sudo_user.pw);
@


1.43
log
@Update sudo to version 1.7.2p8
@
text
@a1092 23
    int rootstat;

    /*
     * Fix the mode and group on sudoers file from old default.
     * Only works if file system is readable/writable by root.
     */
    if ((rootstat = stat_sudoers(sudoers, &statbuf)) == 0 &&
	SUDOERS_UID == statbuf.st_uid && SUDOERS_MODE != 0400 &&
	(statbuf.st_mode & 0007777) == 0400) {

	if (chmod(sudoers, SUDOERS_MODE) == 0) {
	    warningx("fixed mode on %s", sudoers);
	    SET(statbuf.st_mode, SUDOERS_MODE);
	    if (statbuf.st_gid != SUDOERS_GID) {
		if (chown(sudoers, (uid_t) -1, SUDOERS_GID) == 0) {
		    warningx("set group on %s", sudoers);
		    statbuf.st_gid = SUDOERS_GID;
		} else
		    warning("unable to set group on %s", sudoers);
	    }
	} else
	    warning("unable to fix mode on %s", sudoers);
    }
d1101 1
a1101 1
    if (rootstat != 0 && stat_sudoers(sudoers, &statbuf) != 0)
@


1.42
log
@Fix intended use of closefrom() so that we do indeed close fd 3 and up by
default and make -C work as expected.

fine by kettenis@@, beck@@, millert@@
@
text
@a361 5
#ifdef USING_NONUNIX_GROUPS
    /* Finished with the groupcheck code */
    sudo_nonunix_groupcheck_cleanup();
#endif

d464 5
d1447 3
@


1.41
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d539 1
a539 1
	closefrom(def_closefrom + 1);
@


1.40
log
@update to sudo 1.7.2p2
@
text
@a106 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: sudo.c,v 1.517 2009/05/27 00:49:07 millert Exp $";
#endif /* lint */

@


1.39
log
@Upgrade to sudo 1.7.2
@
text
@d651 2
a652 1
    if ((p = ttyname(STDIN_FILENO)) || (p = ttyname(STDOUT_FILENO))) {
d1143 1
a1143 1
	log_error(USE_ERRNO, "can't open %s", sudoers);
d1149 4
a1152 4
	if (statbuf.st_size != 0) {
	    if (fgetc(fp) == EOF)
		log_error(USE_ERRNO, "can't read %s", sudoers);
	    rewind(fp);
d1154 4
@


1.38
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996, 1998-2008 Todd C. Miller <Todd.Miller@@courtesan.com>
d102 4
a105 1
#include "version.h"
d108 1
a108 1
__unused static const char rcsid[] = "$Sudo: sudo.c,v 1.510 2009/03/10 20:44:05 millert Exp $";
d277 4
d365 6
d498 3
a547 1
	    audit_success(NewArgv);
a554 1
	    audit_success(NewArgv);
d843 1
a843 1
    if (!runas_user)
d1089 1
a1089 1
open_sudoers(sudoers, keepopen)
d1091 1
d1454 1
a1454 1
    (void) printf("Sudo version %s\n", version);
@


1.37
log
@Do not try to set the close on exec flag if we didn't actually open sudoers.
Fixes a crash when sudoers owenership is wrong found by thib@@
@
text
@d98 1
a99 1
#include "sudo_usage.h"
d105 1
a105 1
__unused static const char rcsid[] = "$Sudo: sudo.c,v 1.501 2009/01/09 00:13:37 millert Exp $";
d234 1
a234 1
    else
d243 1
d257 1
d262 1
d266 1
d348 9
a356 3
	/* Handle [NOTFOUND=return] */
	if (!ISSET(validated, VALIDATE_OK) && nss->ret_notfound)
	    break;
d395 2
a396 1
	if ((fd = open(_PATH_TTY, O_RDWR|O_NOCTTY)) == -1)
d398 1
a398 1
	else
d418 1
a418 1
	check_user(validated, !ISSET(sudo_mode, MODE_NONINTERACTIVE));
d433 2
a434 1
	if (cmnd_status == NOT_FOUND_DOT)
d436 2
a437 1
	else if (cmnd_status == NOT_FOUND)
d439 1
d451 1
a451 1
	if (sudo_mode == MODE_CHECK)
d453 1
a453 1
	else if (sudo_mode == MODE_LIST)
d461 1
a461 2
	if (sudo_mode == MODE_VALIDATE || sudo_mode == MODE_CHECK ||
	    sudo_mode == MODE_LIST)
d465 3
a467 2
	 * Override user's umask if configured to do so.
	 * If user's umask is more restrictive, OR in those bits too.
d470 8
a477 4
	    mode_t mask = umask(def_umask);
	    mask |= def_umask;
	    if (mask != def_umask)
		umask(mask);
d530 3
a532 1
	if (ISSET(sudo_mode, MODE_BACKGROUND) && fork() > 0)
d534 1
a534 1
	else {
d540 1
d554 2
a555 1
	} warning("unable to execute %s", safe_cmnd);
d558 1
d580 1
d693 1
a693 1
	if (sudo_mode & (MODE_INVALIDATE|MODE_KILL))
d829 3
d847 1
a847 1
    int ch;
d861 4
d903 1
d912 4
a915 2
		    if (mode && mode != MODE_HELP)
			usage_excl(1);
d917 1
d924 1
a924 3
		    if (mode && mode != MODE_INVALIDATE)
			usage_excl(1);
		    mode = MODE_INVALIDATE;
d930 1
d936 1
d946 1
d983 1
d989 1
d1014 10
a1023 2
    if (!mode)
	mode = MODE_RUN;
d1039 2
d1366 2
a1367 1
	if ((runas_pw = sudo_getpwnam(user)) == NULL)
d1369 1
d1464 1
a1464 1
    warningx("Only one of the -e, -h, -i, -k, -K, -l, -s, -v or -V options may be specified");
d1477 1
a1477 1
    char *uvec[5];
d1484 1
a1484 1
	uvec[0] = SUDO_USAGE4 + 3;
d1491 2
a1492 1
	uvec[4] = NULL;
@


1.36
log
@sync with sudo repo
@
text
@d105 1
a105 1
__unused static const char rcsid[] = "$Sudo: sudo.c,v 1.500 2008/11/18 15:57:09 millert Exp $";
d1080 1
a1080 1
    else if (statbuf.st_size != 0) {
d1083 1
a1083 1
	 * user with a reasonable error message.
d1085 6
a1090 3
	if (fgetc(fp) == EOF)
	    log_error(USE_ERRNO, "can't read %s", sudoers);
	rewind(fp);
a1091 1
    (void) fcntl(fileno(fp), F_SETFD, 1);
@


1.35
log
@classic C compatibility (no statements before decls)
@
text
@d105 1
a105 1
__unused static const char rcsid[] = "$Sudo: sudo.c,v 1.499 2008/11/11 18:28:08 millert Exp $";
@


1.34
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d174 1
a178 1
    struct sudo_nss *nss;
@


1.33
log
@Update to sudo 1.6.9p17
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2007 Todd C. Miller <Todd.Miller@@courtesan.com>
a61 5
#ifdef HAVE_ERR_H
# include <err.h>
#else
# include "emul/err.h"
#endif /* HAVE_ERR_H */
d99 2
d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.43 2008/07/02 10:28:43 millert Exp $";
d111 2
a112 1
static int init_vars			__P((int, char **));
a113 1
static void check_sudoers		__P((void));
d117 3
a123 1
static void usage_excl			__P((int));
d126 3
a128 7
extern void list_matches		__P((void));
extern char **rebuild_env		__P((char **, int, int));
extern void validate_env_vars		__P((struct list_member *));
extern char **insert_env_vars		__P((char **, struct list_member *));
extern struct passwd *sudo_getpwnam	__P((const char *));
extern struct passwd *sudo_getpwuid	__P((uid_t));
extern struct passwd *sudo_pwdup	__P((const struct passwd *));
d136 1
d138 1
a138 2
struct passwd *auth_pw;
FILE *sudoers_fp;
d142 1
d145 2
d157 7
a163 1

d171 2
a172 5
    int validated;
    int fd;
    int cmnd_status;
    int sudo_mode;
    int pwflag;
d174 5
a178 2
    extern int printmatches;
    extern char **environ;
d197 1
a197 1
	errx(1, "must be setuid root");
d205 1
d214 1
a214 1
     * Turn off core dumps and close open files.
d217 2
a218 1
    setpwent();
d237 1
a237 9
		(void) printf("Sudo version %s\n", version);
		if (getuid() == 0) {
		    putchar('\n');
		    (void) printf("Sudoers path: %s\n", _PATH_SUDOERS);
		    dump_auth_methods();
		    dump_defaults();
		    dump_interfaces();
		}
		exit(0);
d258 3
a260 1
		printmatches = 1;
d268 34
a301 1
    cmnd_status = init_vars(sudo_mode, environ);
d303 18
a320 2
#ifdef HAVE_LDAP
    validated = sudo_ldap_check(pwflag);
d322 6
a327 10
    /* Skip reading /etc/sudoers if LDAP told us to */
    if (!def_ignore_local_sudoers) {
	int v;

	check_sudoers();	/* check mode/owner on _PATH_SUDOERS */

	/* Local sudoers file overrides LDAP if we have a match. */
	v = sudoers_lookup(pwflag);
	if (validated == VALIDATE_ERROR || ISSET(v, VALIDATE_OK))
	    validated = v;
a328 2
#else
    check_sudoers();	/* check mode/owner on _PATH_SUDOERS */
d330 8
a337 2
    /* Validate the user but don't search for pseudo-commands. */
    validated = sudoers_lookup(pwflag);
d339 9
d351 8
d366 1
a366 1
	    pw = getpwuid(atoi(def_timestampowner + 1));
d368 1
a368 1
	    pw = getpwnam(def_timestampowner);
a374 18
    /* This goes after the sudoers parse since we honor sudoers options. */
    if (sudo_mode == MODE_KILL || sudo_mode == MODE_INVALIDATE) {
	remove_timestamp((sudo_mode == MODE_KILL));
	exit(0);
    }

    if (ISSET(validated, VALIDATE_ERROR))
	log_error(0, "parse error in %s near line %d", _PATH_SUDOERS,
	    errorlineno);

    /* Is root even allowed to run sudo? */
    if (user_uid == 0 && !def_root_sudo) {
	(void) fprintf(stderr,
	    "Sorry, %s has been configured to not allow root to run it.\n",
	    getprogname());
	exit(1);
    }

d391 6
a396 2
    /* User may have overriden environment resetting via the -E flag. */
    if (ISSET(sudo_mode, MODE_PRESERVE_ENV) && ISSET(validated, FLAG_SETENV))
d400 1
a400 1
    environ = rebuild_env(environ, sudo_mode, ISSET(validated, FLAG_NOEXEC));
d406 2
a407 2
    if (!ISSET(validated, FLAG_NOPASS))
	check_user(validated);
d410 3
a412 1
    if (user_uid == 0 && prev_user != NULL && strcmp(prev_user, "root") != 0) {
d415 1
a415 2
	    if ((pw = sudo_getpwnam(prev_user)) != NULL) {
		    efree(sudo_user.pw);
d417 1
a417 1
	    }
d422 4
a425 7
	if (cmnd_status == NOT_FOUND_DOT) {
	    warnx("ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.", user_cmnd, user_cmnd, user_cmnd);
	    exit(1);
	} else if (cmnd_status == NOT_FOUND) {
	    warnx("%s: command not found", user_cmnd);
	    exit(1);
	}
d428 1
a428 1
	if (ISSET(sudo_mode, MODE_RUN) && !ISSET(validated, FLAG_SETENV)) {
d436 24
a459 9
	log_auth(validated, 1);
	if (sudo_mode == MODE_VALIDATE)
	    exit(0);
	else if (sudo_mode == MODE_LIST) {
	    list_matches();
#ifdef HAVE_LDAP
	    sudo_ldap_list_matches();
#endif
	    exit(0);
a461 4
	/* Override user's umask if configured to do so. */
	if (def_umask != 0777)
	    (void) umask(def_umask);

a470 4
	/* Close the password and group files */
	endpwent();
	endgrent();

d482 6
a487 1
		warn("unable to change directory to %s", runas_pw->pw_dir);
d493 4
d498 1
a498 1
	environ = insert_env_vars(environ, sudo_user.env_vars);
d505 6
d517 1
a517 1
		selinux_exec(user_role, user_type, NewArgv, environ,
d520 1
a520 1
	    execve(safe_cmnd, NewArgv, environ);
d526 1
a526 1
	 * If we got here then the exec() failed...
d532 2
a533 3
	    execve(_PATH_BSHELL, NewArgv, environ);
	}
	warn("unable to execute %s", safe_cmnd);
d535 2
a536 2
    } else if (ISSET(validated, FLAG_NO_USER) || (validated & FLAG_NO_HOST)) {
	log_auth(validated, 1);
d538 1
a538 1
    } else if (ISSET(validated, VALIDATE_NOT_OK)) {
d547 1
a547 1
	    log_auth(validated,
d550 1
a550 1
		warnx("%s: command not found", user_cmnd);
d552 1
a552 1
		warnx("ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.", user_cmnd, user_cmnd, user_cmnd);
d555 1
a555 1
	    log_auth(validated, 1);
a557 4
    } else {
	/* should never get here */
	log_auth(validated, 1);
	exit(1);
d566 1
a566 1
static int
d571 2
a572 2
    char *p, **ep, thost[MAXHOSTNAMELEN];
    int nohostname, rval;
d576 1
a576 1
	errx(1, "%s: File name too long", NewArgv[0]);
d597 1
d621 1
d623 8
d642 2
a644 1

d670 2
a671 2
	    errx(1, "uid %s does not exist in the passwd file!", pw_name);
	log_error(0, "uid %s does not exist in the passwd file!", pw_name);
d674 1
a674 1
	user_shell = sudo_user.pw->pw_shell;
a692 6
    set_runaspw(*user_runas);		/* may call log_error() */
    if (*user_runas[0] == '#') {
	if (runas_pw->pw_name != *user_runas && runas_pw->pw_name[0])
	    *user_runas = estrdup(runas_pw->pw_name);
    }

d700 1
a700 1
	    warnx("cannot get working directory");
d710 6
a715 2
    if ((sudo_mode & (MODE_SHELL | MODE_EDIT))) {
	char **dst, **src = NewArgv;
d718 2
a719 10
	NewArgv = (char **) emalloc2((++NewArgc + 2), sizeof(char *));
	NewArgv++;
	if (ISSET(sudo_mode, MODE_EDIT))
	    NewArgv[0] = "sudoedit";
	else if (ISSET(sudo_mode, MODE_LOGIN_SHELL))
	    NewArgv[0] = runas_pw->pw_shell;
	else if (user_shell && *user_shell)
	    NewArgv[0] = user_shell;
	else
	    errx(1, "unable to determine shell");
d721 18
a738 3
	/* copy the args from NewArgv */
	for (dst = NewArgv + 1; (*dst = *src) != NULL; ++src, ++dst)
	    continue;
d740 1
d742 9
a750 2
    /* Set login class if applicable. */
    set_loginclass(sudo_user.pw);
d758 2
a759 3
    if (sudo_mode & (MODE_RUN | MODE_EDIT)) {
	if (ISSET(sudo_mode, MODE_RUN)) {
	    /* XXX - default_runas may be modified during parsing of sudoers */
d777 1
a777 1
	    if (!(sudo_mode & (MODE_SHELL | MODE_EDIT))) {
d790 1
a790 1
		    errx(1, "internal error, init_vars() overflow");
d802 3
d809 3
a811 1
 * Command line argument parsing, can't use getopt(3).
d818 3
a820 5
    int rval = MODE_RUN;		/* what mode is sudo to be run in? */
    int excl = 0;			/* exclusive arg, no others allowed */

    NewArgv = argv + 1;
    NewArgc = argc - 1;
d823 2
a824 5
    if (strcmp(getprogname(), "sudoedit") == 0) {
	rval = MODE_EDIT;
	excl = 'e';
    } else
	rval = MODE_RUN;
d826 7
a832 6
    while (NewArgc > 0) {
	if (NewArgv[0][0] == '-') {
	    if (NewArgv[0][1] != '\0' && NewArgv[0][2] != '\0') {
		warnx("please use single character options");
		usage(1);
	    }
d834 10
a843 21
	    switch (NewArgv[0][1]) {
		case 'p':
		    /* Must have an associated prompt. */
		    if (NewArgv[1] == NULL)
			usage(1);

		    user_prompt = NewArgv[1];
		    def_passprompt_override = TRUE;

		    NewArgc--;
		    NewArgv++;
		    break;
		case 'u':
		    /* Must have an associated runas user. */
		    if (NewArgv[1] == NULL)
			usage(1);

		    user_runas = &NewArgv[1];

		    NewArgc--;
		    NewArgv++;
d847 9
a855 2
		    /* Must have an associated authentication style. */
		    if (NewArgv[1] == NULL)
d857 1
a857 5

		    login_style = NewArgv[1];

		    NewArgc--;
		    NewArgv++;
a858 1
#endif
d861 1
a861 5
		    /* Must have an associated login class. */
		    if (NewArgv[1] == NULL)
			usage(1);

		    login_class = NewArgv[1];
a862 3

		    NewArgc--;
		    NewArgv++;
d865 2
a866 2
		case 'b':
		    SET(rval, MODE_BACKGROUND);
d869 1
a869 2
		    rval = MODE_EDIT;
		    if (excl && excl != 'e')
d871 7
a877 1
		    excl = 'e';
d879 2
a880 3
		case 'v':
		    rval = MODE_VALIDATE;
		    if (excl && excl != 'v')
d882 1
a882 1
		    excl = 'v';
d885 1
a885 1
		    SET(rval, (MODE_LOGIN_SHELL | MODE_SHELL));
a886 3
		    if (excl && excl != 'i')
			usage_excl(1);
		    excl = 'i';
d889 1
a889 2
		    rval = MODE_INVALIDATE;
		    if (excl && excl != 'k')
d891 1
a891 1
		    excl = 'k';
d894 1
a894 2
		    rval = MODE_KILL;
		    if (excl && excl != 'K')
d896 1
a896 1
		    excl = 'K';
d899 1
a899 2
		    rval = MODE_LISTDEFS;
		    if (excl && excl != 'L')
d901 1
a901 1
		    excl = 'L';
d904 7
a910 4
		    rval = MODE_LIST;
		    if (excl && excl != 'l')
			usage_excl(1);
		    excl = 'l';
d912 2
a913 5
		case 'V':
		    rval = MODE_VERSION;
		    if (excl && excl != 'V')
			usage_excl(1);
		    excl = 'V';
d915 2
a916 5
		case 'h':
		    rval = MODE_HELP;
		    if (excl && excl != 'h')
			usage_excl(1);
		    excl = 'h';
d918 3
a920 5
		case 's':
		    SET(rval, MODE_SHELL);
		    if (excl && excl != 's')
			usage_excl(1);
		    excl = 's';
d922 3
a924 2
		case 'H':
		    SET(rval, MODE_RESET_HOME);
d926 2
a927 2
		case 'P':
		    SET(rval, MODE_PRESERVE_GROUPS);
d929 1
d933 9
a941 2
		case 'E':
		    SET(rval, MODE_PRESERVE_ENV);
d943 4
a946 10
#ifdef HAVE_SELINUX
		case 'r':
		    /* Must have an associated SELinux role. */
		    if (NewArgv[1] == NULL)
			usage(1);

		    user_role = NewArgv[1];

		    NewArgc--;
		    NewArgv++;
d948 4
a951 9
		case 't':
		    /* Must have an associated SELinux type. */
		    if (NewArgv[1] == NULL)
			usage(1);

		    user_type = NewArgv[1];

		    NewArgc--;
		    NewArgv++;
a952 8
#endif
		case '-':
		    NewArgc--;
		    NewArgv++;
		    goto args_done;
		case '\0':
		    warnx("'-' requires an argument");
		    usage(1);
a953 1
		    warnx("illegal option `%s'", NewArgv[0]);
d956 1
a956 2
	} else if (NewArgv[0][0] != '/' && strchr(NewArgv[0], '=') != NULL) {
	    /* Could be an environment variable. */
d958 2
d961 1
a961 1
	    ev->value = NewArgv[0];
d964 3
d968 1
a968 1
	    /* Not an arg */
a970 2
	NewArgc--;
	NewArgv++;
a971 1
args_done:
d973 24
a996 4
    if (ISSET(rval, MODE_EDIT) &&
	(ISSET(rval, MODE_PRESERVE_ENV) || sudo_user.env_vars != NULL)) {
	if (ISSET(rval, MODE_PRESERVE_ENV))
	    warnx("the `-E' option is not valid in edit mode");
d998 5
a1002 1
	    warnx("you may not specify environment variables in edit mode");
d1005 2
a1006 2
    if (ISSET(rval, MODE_PRESERVE_ENV) && ISSET(rval, MODE_LOGIN_SHELL)) {
	warnx("you may not specify both the `-i' and `-E' options");
d1009 2
a1010 3
    if (user_runas != NULL && !ISSET(rval, (MODE_EDIT|MODE_RUN))) {
	if (excl != '\0')
	    warnx("the `-u' and '-%c' options may not be used together", excl);
d1013 2
a1014 2
    if ((NewArgc == 0 && (rval & MODE_EDIT)) ||
	(NewArgc > 0 && !(rval & (MODE_RUN | MODE_EDIT))))
d1016 2
a1017 2
    if (NewArgc == 0 && rval == MODE_RUN)
	SET(rval, (MODE_IMPLIED_SHELL | MODE_SHELL));
d1019 1
a1019 1
    return(rval);
d1023 2
a1024 2
 * Sanity check sudoers mode/owner/type.
 * Leaves a file pointer to the sudoers file open in ``fp''.
d1026 4
a1029 2
static void
check_sudoers()
d1032 2
a1033 1
    int rootstat, i;
d1039 1
a1039 1
    if ((rootstat = stat_sudoers(_PATH_SUDOERS, &statbuf)) == 0 &&
d1043 2
a1044 2
	if (chmod(_PATH_SUDOERS, SUDOERS_MODE) == 0) {
	    warnx("fixed mode on %s", _PATH_SUDOERS);
d1047 2
a1048 2
		if (!chown(_PATH_SUDOERS,(uid_t) -1,SUDOERS_GID)) {
		    warnx("set group on %s", _PATH_SUDOERS);
d1051 1
a1051 1
		    warn("unable to set group on %s", _PATH_SUDOERS);
d1054 1
a1054 1
	    warn("unable to fix mode on %s", _PATH_SUDOERS);
d1064 2
a1065 2
    if (rootstat != 0 && stat_sudoers(_PATH_SUDOERS, &statbuf) != 0)
	log_error(USE_ERRNO, "can't stat %s", _PATH_SUDOERS);
d1067 1
a1067 3
	log_error(0, "%s is not a regular file", _PATH_SUDOERS);
    else if (statbuf.st_size == 0)
	log_error(0, "%s is zero length", _PATH_SUDOERS);
d1069 1
a1069 1
	log_error(0, "%s is mode 0%o, should be 0%o", _PATH_SUDOERS,
d1073 1
a1073 1
	log_error(0, "%s is owned by uid %lu, should be %lu", _PATH_SUDOERS,
d1076 1
a1076 1
	log_error(0, "%s is owned by gid %lu, should be %lu", _PATH_SUDOERS,
d1078 10
a1087 17
    else {
	/* Solaris sometimes returns EAGAIN so try 10 times */
	for (i = 0; i < 10 ; i++) {
	    errno = 0;
	    if ((sudoers_fp = fopen(_PATH_SUDOERS, "r")) == NULL ||
		fgetc(sudoers_fp) == EOF) {
		if (sudoers_fp != NULL)
		    fclose(sudoers_fp);
		sudoers_fp = NULL;
		if (errno != EAGAIN && errno != EWOULDBLOCK)
		    break;
	    } else
		break;
	    sleep(1);
	}
	if (sudoers_fp == NULL)
	    log_error(USE_ERRNO, "can't open %s", _PATH_SUDOERS);
d1089 1
d1092 1
d1097 1
d1146 2
a1149 1
    closefrom(STDERR_FILENO + 1);
d1170 3
a1172 2
	if (strcmp(*user_runas, "root") != 0 && user_uid != 0)
	    errx(1, "only root can use -c %s", login_class);
d1275 1
a1275 1
    memset(&hint, 0, sizeof(hint));
d1308 1
a1308 1
int
d1312 6
a1317 4
    if (runas_pw != NULL) {
	if (user_runas != &def_runas_default)
	    return(TRUE);		/* don't override -u option */
	efree(runas_pw);
d1319 13
a1331 12
    if (*user == '#') {
	runas_pw = sudo_getpwuid(atoi(user + 1));
	if (runas_pw == NULL) {
	    runas_pw = emalloc(sizeof(struct passwd));
	    (void) memset((VOID *)runas_pw, 0, sizeof(struct passwd));
	    runas_pw->pw_uid = atoi(user + 1);
	    runas_pw->pw_name = user;
	    runas_pw->pw_passwd = "*";
	    runas_pw->pw_gecos = user;
	    runas_pw->pw_dir = "/";
	    runas_pw->pw_shell = estrdup(_PATH_BSHELL);
	}
d1333 2
a1334 3
	runas_pw = sudo_getpwnam(user);
	if (runas_pw == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "no passwd entry for %s!", user);
a1335 1
    return(TRUE);
d1349 2
a1350 4
	if (runas_pw->pw_uid == 0)
	    pw = runas_pw;
	else if ((pw = sudo_getpwuid(0)) == NULL)
	    log_error(0, "uid 0 does not exist in the passwd file!");
d1352 2
a1353 5
	if (strcmp(def_runas_default, *user_runas) == 0)
	    pw = runas_pw;
	else if ((pw = sudo_getpwnam(def_runas_default)) == NULL)
	    log_error(0, "user %s does not exist in the passwd file!",
		def_runas_default);
d1356 1
a1356 1
	    log_error(NO_MAIL|MSG_ONLY, "no passwd entry for %lu!",
d1366 40
d1412 1
a1412 1
    warnx("Only one of the -e, -h, i, -k, -K, -l, -s, -v or -V options may be used");
d1418 1
d1424 3
a1426 46
    char **p, **uvec[4];
    int i, linelen, linemax, ulen, plen;
    static char *uvec1[] = {
	" -h |",
	" -K |",
	" -k |",
	" -L |",
	" -l |",
	" -V |",
	" -v",
	NULL
    };
    static char *uvec2[] = {
	" [-bEHPS]",
#ifdef HAVE_BSD_AUTH_H
	" [-a auth_type]",
#endif
#ifdef HAVE_LOGIN_CAP_H
	" [-c class|-]",
#endif
#ifdef HAVE_SELINUX
	" [-r role]",
#endif
	" [-p prompt]",
#ifdef HAVE_SELINUX
	" [-t type]",
#endif
	" [-u username|#uid]",
	" [VAR=value]",
	" {-i | -s | <command>}",
	NULL
    };
    static char *uvec3[] = {
	" -e",
	" [-S]",
#ifdef HAVE_BSD_AUTH_H
	" [-a auth_type]",
#endif
#ifdef HAVE_LOGIN_CAP_H
	" [-c class|-]",
#endif
	" [-p prompt]",
	" [-u username|#uid]",
	" file ...",
	NULL
    };
d1432 1
a1432 1
	uvec[0] = uvec3 + 1;
d1435 5
a1439 4
	uvec[0] = uvec1;
	uvec[1] = uvec2;
	uvec[2] = uvec3;
	uvec[3] = NULL;
d1443 2
a1444 2
     * Print usage and wrap lines as needed.
     * Assumes an 80-character wide terminal, which is kind of bogus...
d1446 2
a1447 2
    ulen = (int)strlen(getprogname()) + 7;
    linemax = 80;
d1449 2
a1450 14
	printf("usage: %s", getprogname());
	linelen = linemax - ulen;
	for (p = uvec[i]; *p != NULL; p++) {
	    plen = (int)strlen(*p);
	    if (linelen >= plen || linelen == linemax - ulen) {
		fputs(*p, stdout);
		linelen -= plen;
	    } else {
		p--;
		linelen = linemax - ulen;
		printf("\n%*s", ulen, "");
	    }
	}
	putchar('\n');
d1452 1
@


1.32
log
@update to sudo 1.6.9p10
@
text
@d99 3
d108 1
a108 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.34 2007/12/13 14:12:49 millert Exp $";
d158 1
a158 1
sigaction_t saved_sa_int, saved_sa_quit, saved_sa_tstp, saved_sa_chld;
a206 2
    sa.sa_handler = reapchild;
    (void) sigaction(SIGCHLD, &sa, &saved_sa_chld);
d274 3
a276 4
    if (def_ignore_local_sudoers); /* skips */
    else if (ISSET(validated, VALIDATE_OK) && !printmatches); /* skips */
    else if (ISSET(validated, VALIDATE_OK) && printmatches)
    {
d279 4
a282 4
	/* User is found in LDAP and we want a list of all sudo commands the
	 * user can do, so consult sudoers but throw away result.
	 */
	sudoers_lookup(pwflag);
d284 5
a288 1
    else
a289 6
    {
	check_sudoers();	/* check mode/owner on _PATH_SUDOERS */

	/* Validate the user but don't search for pseudo-commands. */
	validated = sudoers_lookup(pwflag);
    }
a437 1
	(void) sigaction(SIGCHLD, &saved_sa_chld, NULL);
d442 6
a447 1
	else
d449 1
d616 4
a619 2
    if (*user_runas[0] == '#' && runas_pw->pw_name && runas_pw->pw_name[0])
	*user_runas = estrdup(runas_pw->pw_name);
d866 22
d923 4
a926 1

d1025 1
a1025 1
#if defined(RLIMIT_CORE) && !defined(SUDO_DEVEL)
d1027 1
d1029 15
d1243 5
d1327 3
d1331 3
@


1.31
log
@update to sudo 1.6.9p9
@
text
@d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.33 2007/12/02 17:13:52 millert Exp $";
d733 1
a733 1
	    if (NewArgv[0][1] != '\0' && NewArgv[0][2] != '\0')
d735 2
@


1.30
log
@Update to sudo 1.6.9p6
@
text
@d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.31 2007/09/13 23:06:51 millert Exp $";
d599 1
a599 1
	user_groups = emalloc2(user_ngroups, MAX(sizeof(gid_t), sizeof(int)));
d743 1
@


1.29
log
@update to sudo 1.6.9p5
@
text
@d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.30 2007/08/18 12:25:41 millert Exp $";
d543 3
a545 3
	if (strncmp(p, _PATH_DEV, sizeof(_PATH_DEV) - 1) == 0)
	    p += sizeof(_PATH_DEV) - 1;
	user_tty = estrdup(p);
@


1.28
log
@Update to sudo 1.6.9p4.  Basically IPv6 support and improved man pages.
@
text
@d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.29 2007/08/15 13:48:56 millert Exp $";
d1254 1
a1254 1
    int i, linelen, linemax, ulen;
d1256 7
a1262 1
	" -h | -K | -k | -L | -l | -V | -v",
d1314 1
a1315 1
	printf("usage: %s", getprogname());
d1317 2
a1318 1
	    if (linelen == linemax || (linelen -= strlen(*p)) >= 0) {
d1320 1
d1323 1
a1323 1
		linelen = linemax;
@


1.27
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d105 1
a105 1
__unused __unused static const char rcsid[] = "$Sudo: sudo.c,v 1.369.2.26 2007/07/22 19:21:01 millert Exp $";
d599 1
a599 1
	user_groups = emalloc2(user_ngroups, sizeof(gid_t));
a916 1
    char c;
d968 3
a970 1
		fread(&c, sizeof(c), 1, sudoers_fp) != 1) {
d1138 3
d1142 1
d1145 6
d1152 1
d1154 1
a1154 1
	    "unable to lookup %s via gethostbyname()", user_host);
d1159 4
d1164 1
@


1.26
log
@Update to sudo 1.6.8p9
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d30 1
a30 1
#include "config.h"
d72 6
a77 1
#include <time.h>
d95 4
d105 1
a105 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.370 2004/08/24 18:01:13 millert Exp $";
d111 1
a111 1
static int init_vars			__P((int));
d116 5
a120 1
static void usage			__P((int));
d123 1
a123 1
extern int sudo_edit			__P((int, char **));
d126 2
a127 1
extern char **zero_env			__P((char **));
a155 1
void (*set_perms) __P((int));
a168 1
    char **new_environ;
d173 4
a188 3
    /* Zero out the environment. */
    environ = zero_env(envp);

d208 1
a208 1
     * Turn off core dumps, close open files and setup set_perms().
d233 1
d267 1
a267 1
    cmnd_status = init_vars(sudo_mode);
d293 1
a293 17
	safe_cmnd = user_cmnd;

    /*
     * If we are using set_perms_posix() and the stay_setuid flag was not set,
     * set the real, effective and saved uids to 0 and use set_perms_nosuid()
     * instead of set_perms_posix().
     */
#if !defined(HAVE_SETRESUID) && !defined(HAVE_SETREUID) && \
    !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (!def_stay_setuid && set_perms == set_perms_posix) {
	if (setuid(0)) {
	    perror("setuid(0)");
	    exit(1);
	}
	set_perms = set_perms_nosuid;
    }
#endif
a336 5
    /* May need to set $HOME to target user if we are running a command. */
    if (ISSET(sudo_mode, MODE_RUN) && (def_always_set_home ||
	(ISSET(sudo_mode, MODE_SHELL) && def_set_home)))
	SET(sudo_mode, MODE_RESET_HOME);

d345 7
d357 1
a357 1
	check_user(ISSET(validated, FLAG_CHECK_USER));
d364 1
a364 1
		    free(sudo_user.pw);
a368 6
    /* Build a new environment that avoids any nasty bits if we have a cmnd. */
    if (ISSET(sudo_mode, MODE_RUN))
	new_environ = rebuild_env(envp, sudo_mode, ISSET(validated, FLAG_NOEXEC));
    else
	new_environ = envp;

d379 9
a415 3
	/* Install the real environment. */
	environ = new_environ;

d431 4
a434 1
	    exit(sudo_edit(NewArgc, NewArgv));
d446 1
a446 1
	    EXECV(safe_cmnd, NewArgv);	/* run the command */
d453 6
d497 1
a497 1
init_vars(sudo_mode)
d499 1
d501 1
a501 1
    char *p, thost[MAXHOSTNAMELEN];
d549 18
d597 9
d636 3
a638 1
	NewArgv = (char **) emalloc2((++NewArgc + 1), sizeof(char *));
d650 1
a650 1
	    ;
d656 3
d731 10
a740 4
    if (NewArgc == 0 && rval == MODE_RUN) {	/* no options and no command */
	SET(rval, (MODE_IMPLIED_SHELL | MODE_SHELL));
	return(rval);
    }
d742 1
a742 3
    while (NewArgc > 0 && NewArgv[0][0] == '-') {
	if (NewArgv[0][1] != '\0' && NewArgv[0][2] != '\0')
	    warnx("please use single character options");
d744 7
a750 5
	switch (NewArgv[0][1]) {
	    case 'p':
		/* Must have an associated prompt. */
		if (NewArgv[1] == NULL)
		    usage(1);
d752 1
a752 1
		user_prompt = NewArgv[1];
d754 3
a756 13
		NewArgc--;
		NewArgv++;
		break;
	    case 'u':
		/* Must have an associated runas user. */
		if (NewArgv[1] == NULL)
		    usage(1);

		user_runas = &NewArgv[1];

		NewArgc--;
		NewArgv++;
		break;
d758 4
a761 4
	    case 'a':
		/* Must have an associated authentication style. */
		if (NewArgv[1] == NULL)
		    usage(1);
d763 1
a763 1
		login_style = NewArgv[1];
d765 3
a767 3
		NewArgc--;
		NewArgv++;
		break;
d770 4
a773 4
	    case 'c':
		/* Must have an associated login class. */
		if (NewArgv[1] == NULL)
		    usage(1);
d775 2
a776 2
		login_class = NewArgv[1];
		def_use_loginclass = TRUE;
d778 3
a780 3
		NewArgc--;
		NewArgv++;
		break;
d782 97
a878 85
	    case 'b':
		SET(rval, MODE_BACKGROUND);
		break;
	    case 'e':
		rval = MODE_EDIT;
		if (excl && excl != 'e')
		    usage_excl(1);
		excl = 'e';
		break;
	    case 'v':
		rval = MODE_VALIDATE;
		if (excl && excl != 'v')
		    usage_excl(1);
		excl = 'v';
		break;
	    case 'i':
		SET(rval, (MODE_LOGIN_SHELL | MODE_SHELL));
		def_env_reset = TRUE;
		if (excl && excl != 'i')
		    usage_excl(1);
		excl = 'i';
		break;
	    case 'k':
		rval = MODE_INVALIDATE;
		if (excl && excl != 'k')
		    usage_excl(1);
		excl = 'k';
		break;
	    case 'K':
		rval = MODE_KILL;
		if (excl && excl != 'K')
		    usage_excl(1);
		excl = 'K';
		break;
	    case 'L':
		rval = MODE_LISTDEFS;
		if (excl && excl != 'L')
		    usage_excl(1);
		excl = 'L';
		break;
	    case 'l':
		rval = MODE_LIST;
		if (excl && excl != 'l')
		    usage_excl(1);
		excl = 'l';
		break;
	    case 'V':
		rval = MODE_VERSION;
		if (excl && excl != 'V')
		    usage_excl(1);
		excl = 'V';
		break;
	    case 'h':
		rval = MODE_HELP;
		if (excl && excl != 'h')
		    usage_excl(1);
		excl = 'h';
		break;
	    case 's':
		SET(rval, MODE_SHELL);
		if (excl && excl != 's')
		    usage_excl(1);
		excl = 's';
		break;
	    case 'H':
		SET(rval, MODE_RESET_HOME);
		break;
	    case 'P':
		SET(rval, MODE_PRESERVE_GROUPS);
		break;
	    case 'S':
		SET(tgetpass_flags, TGP_STDIN);
		break;
	    case '-':
		NewArgc--;
		NewArgv++;
		if (rval == MODE_RUN)
		    SET(rval, (MODE_IMPLIED_SHELL | MODE_SHELL));
		return(rval);
	    case '\0':
		warnx("'-' requires an argument");
		usage(1);
	    default:
		warnx("illegal option `%s'", NewArgv[0]);
		usage(1);
d883 10
a898 1

d902 2
d956 2
a957 1
	    (statbuf.st_mode & 07777), SUDOERS_MODE);
a985 1
 * Also sets the set_perms() pointer to the correct function.
d990 1
a1002 2
    closefrom(STDERR_FILENO + 1);

d1004 2
a1005 5
     * Make set_perms point to the correct function.
     * If we are using setresuid() or setreuid() we only need to set this
     * once.  If we are using POSIX saved uids we will switch to
     * set_perms_nosuid after sudoers has been parsed if the "stay_suid"
     * option is not set.
d1007 14
a1020 10
#if defined(HAVE_SETRESUID) || defined(HAVE_SETREUID)
    set_perms = set_perms_suid;
#else
# if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (sysconf(_SC_SAVED_IDS) == 1 && sysconf(_SC_VERSION) >= 199009)
	set_perms = set_perms_posix;
    else
# endif
	set_perms = set_perms_nosuid;
#endif /* HAVE_SETRESUID || HAVE_SETREUID */
d1065 66
d1145 2
a1146 2
	    free(user_shost);
	free(user_host);
d1169 1
a1169 1
	free(runas_pw);
d1225 1
a1225 1
    warnx("Only one of the -e, -h, -k, -K, -l, -s, -v or -V options may be used");
d1236 8
a1243 4
    char **p;
    int linelen, linemax, ulen;
    static char *uvec[] = {
	" [-HPSb]",
d1252 16
a1267 1
	" { -e file [...] | -i | -s | <command> }",
d1272 1
a1272 2
     * For sudoedit, replace the last entry in the usage vector.
     * For sudo, print the secondary usage.
d1275 2
a1276 4
	/* Replace the last entry in the usage vector. */
	for (p = uvec; p[1] != NULL; p++)
	    continue;
	*p = " file [...]";
d1278 4
a1281 2
	fprintf(stderr, "usage: %s -K | -L | -V | -h | -k | -l | -v\n",
	    getprogname());
d1285 1
a1285 1
     * Print the main usage and wrap lines as needed.
d1290 11
a1300 9
    linelen = linemax - ulen;
    printf("usage: %s", getprogname());
    for (p = uvec; *p != NULL; p++) {
	if (linelen == linemax || (linelen -= strlen(*p)) >= 0) {
	    fputs(*p, stdout);
	} else {
	    p--;
	    linelen = linemax;
	    printf("\n%*s", ulen, "");
d1302 1
a1303 1
    putchar('\n');
@


1.25
log
@update to sudo 1.6.8p8
@
text
@d278 2
a393 8
	}

	/* This *must* have been set if we got a match but... */
	if (safe_cmnd == NULL) {
	    log_error(MSG_ONLY,
		"internal error, safe_cmnd never got set for %s; %s",
		user_cmnd,
		"please report this error at http://courtesan.com/sudo/bugs/");
@


1.24
log
@Warn if the user tries to use the -u option w/o running a command.
@
text
@d904 1
a904 1
	    (unsigned long) statbuf.st_uid, SUDOERS_UID);
d907 1
a907 1
	    (unsigned long) statbuf.st_gid, SUDOERS_GID);
d1089 1
a1089 1
		runas_pw->pw_uid);
@


1.24.2.1
log
@MFC:
Fix by millert@@

A race condition in Sudo's command pathname handling prior to
Sudo version 1.6.8p9 that could allow a user with Sudo privileges
to run arbitrary commands.

ok millert@@
@
text
@a277 2
    if (safe_cmnd == NULL)
	safe_cmnd = user_cmnd;
d392 8
@


1.23
log
@Update to sudo 1.6.8p1
@
text
@d840 6
@


1.22
log
@Use closefrom() if it exists; from the sudo cvs repo
@
text
@d2 1
a2 2
 * Copyright (c) 1993-1996,1998-2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 3
a6 3
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
d8 7
a14 24
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d26 4
d96 1
a96 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.337 2003/04/16 00:42:10 millert Exp $";
d110 1
d112 1
a112 1
extern char **rebuild_env		__P((int, char **));
d116 1
d123 1
d141 1
d157 1
a157 1
    sigaction_t sa, saved_sa_int, saved_sa_quit, saved_sa_tstp, saved_sa_chld;
a160 1
    Argc = argc;
d162 2
d210 1
a210 1
    if (sudo_mode & MODE_SHELL)
d212 2
d231 1
a231 1
		pwflag = I_VERIFYPW_I;
d244 1
a244 1
		pwflag = I_LISTPW_I;
d255 19
a273 1
    check_sudoers();	/* check mode/owner on _PATH_SUDOERS */
d275 3
a277 2
    /* Validate the user but don't search for pseudo-commands. */
    validated = sudoers_lookup(pwflag);
d286 1
a286 1
    if (!def_flag(I_STAY_SETUID) && set_perms == set_perms_posix) {
a295 17
     * Look up runas user passwd struct.  If we are given a uid then
     * there may be no corresponding passwd(5) entry (which is OK).
     */
    if (**user_runas == '#') {
	runas_pw = sudo_getpwuid(atoi(*user_runas + 1));
	if (runas_pw == NULL) {
	    runas_pw = emalloc(sizeof(struct passwd));
	    (void) memset((VOID *)runas_pw, 0, sizeof(struct passwd));
	    runas_pw->pw_uid = atoi(*user_runas + 1);
	}
    } else {
	runas_pw = sudo_getpwnam(*user_runas);
	if (runas_pw == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "no passwd entry for %s!", *user_runas);
    }

    /*
d298 1
a298 1
    if (def_str(I_TIMESTAMPOWNER)) {
d301 2
a302 2
	if (*def_str(I_TIMESTAMPOWNER) == '#')
	    pw = getpwuid(atoi(def_str(I_TIMESTAMPOWNER) + 1));
d304 1
a304 1
	    pw = getpwnam(def_str(I_TIMESTAMPOWNER));
d307 1
a307 1
		def_str(I_TIMESTAMPOWNER));
d317 1
a317 1
    if (validated & VALIDATE_ERROR)
d322 1
a322 1
    if (user_uid == 0 && !def_flag(I_ROOT_SUDO)) {
d330 2
a331 2
    if (sudo_mode & MODE_PRESERVE_GROUPS)
	def_flag(I_PRESERVE_GROUPS) = TRUE;
d334 1
a334 1
    if ((sudo_mode & MODE_IMPLIED_SHELL) && !def_flag(I_SHELL_NOARGS))
d338 3
a340 3
    if ((sudo_mode & MODE_RUN) && (def_flag(I_ALWAYS_SET_HOME) ||
	((sudo_mode & MODE_SHELL) && def_flag(I_SET_HOME))))
	sudo_mode |= MODE_RESET_HOME;
d343 1
a343 1
    if (def_flag(I_REQUIRETTY)) {
d353 13
a365 3
    /* Require a password unless the NOPASS tag was set.  */
    if (!(validated & FLAG_NOPASS))
	check_user();
d367 5
a371 2
    /* Build up custom environment that avoids any nasty bits. */
    new_environ = rebuild_env(sudo_mode, envp);
d373 1
a373 1
    if (validated & VALIDATE_OK) {
d388 3
d403 2
a404 2
	if (def_ival(I_UMASK) != 0777)
	    (void) umask(def_mode(I_UMASK));
d411 3
a413 2
	/* Become specified user or root. */
	set_perms(PERM_RUNAS);
d419 1
a419 1
	/* Install the new environment. */
d422 17
d446 1
a446 1
	if ((sudo_mode & MODE_BACKGROUND) && fork() > 0)
d449 1
a449 1
	    EXEC(safe_cmnd, NewArgv);	/* run the command */
d458 1
a458 1
    } else if ((validated & FLAG_NO_USER) || (validated & FLAG_NO_HOST)) {
d461 2
a462 2
    } else if (validated & VALIDATE_NOT_OK) {
	if (def_flag(I_PATH_INFO)) {
d501 1
a501 1
    if (user_cmnd == NULL && strlen(NewArgv[0]) >= MAXPATHLEN)
d524 1
a524 1
	if (def_flag(I_FQDN)) {
d575 2
a576 5
    /*
     * Must defer set_fqdn() until it is safe to call log_error()
     */
    if (def_flag(I_FQDN))
	set_fqdn();
d581 4
d599 1
a599 1
     * If we were given the '-s' option (run shell) we need to redo
d602 1
a602 1
    if ((sudo_mode & MODE_SHELL)) {
d606 5
a610 1
	if (user_shell && *user_shell) {
d612 1
a612 1
	} else
d624 7
a630 7
    if ((sudo_mode & MODE_RUN)) {
	/* XXX - should call this as runas user, not root. */
	rval = find_path(NewArgv[0], &user_cmnd, user_path);
	if (rval != FOUND) {
	    /* Failed as root, try as invoking user. */
	    set_perms(PERM_USER);
	    rval = find_path(NewArgv[0], &user_cmnd, user_path);
d632 6
d645 2
a646 2
	    /* If MODE_SHELL not set then NewArgv is contiguous so just count */
	    if (!(sudo_mode & MODE_SHELL)) {
d654 1
a654 1
	    /* alloc and copy. */
d665 5
a669 2
    } else
	rval = FOUND;
d688 9
a696 2
    if (NewArgc == 0) {			/* no options and no command */
	rval |= (MODE_IMPLIED_SHELL | MODE_SHELL);
d744 1
a744 1
		def_flag(I_USE_LOGINCLASS) = TRUE;
d751 7
a757 1
		rval |= MODE_BACKGROUND;
d765 7
d809 1
a809 1
		rval |= MODE_SHELL;
d815 1
a815 1
		rval |= MODE_RESET_HOME;
d818 1
a818 1
		rval |= MODE_PRESERVE_GROUPS;
d821 1
a821 1
		tgetpass_flags |= TGP_STDIN;
d827 1
a827 1
		    rval |= (MODE_IMPLIED_SHELL | MODE_SHELL);
d840 2
a841 1
    if (NewArgc > 0 && !(rval & MODE_RUN))
d860 1
a860 1
     * Only works if filesystem is readable/writable by root.
d868 1
a868 1
	    statbuf.st_mode |= SUDOERS_MODE;
d1032 28
d1061 2
a1062 1
 * By default, this is the user invoking sudo...
d1069 4
a1072 2
    if (def_ival(I_ROOTPW)) {
	if ((pw = sudo_getpwuid(0)) == NULL)
d1074 4
a1077 2
    } else if (def_ival(I_RUNASPW)) {
	if ((pw = sudo_getpwnam(def_str(I_RUNAS_DEFAULT))) == NULL)
d1079 6
a1084 11
		def_str(I_RUNAS_DEFAULT));
    } else if (def_ival(I_TARGETPW)) {
	if (**user_runas == '#') {
	    if ((pw = sudo_getpwuid(atoi(*user_runas + 1))) == NULL)
		log_error(0, "uid %s does not exist in the passwd file!",
		    user_runas);
	} else {
	    if ((pw = sudo_getpwnam(*user_runas)) == NULL)
		log_error(0, "user %s does not exist in the passwd file!",
		    user_runas);
	}
d1098 1
a1098 2
    (void) fprintf(stderr,
	"Only one of the -h, -k, -K, -l, -s, -v or -V options may be used\n");
d1109 7
a1115 3

    (void) fprintf(stderr, "usage: sudo -V | -h | -L | -l | -v | -k | -K | %s",
	"[-H] [-P] [-S] [-b] [-p prompt]\n            [-u username/#uid] ");
d1117 1
a1117 1
    (void) fprintf(stderr, "[-c class] ");
d1119 38
a1156 4
#ifdef HAVE_BSD_AUTH_H
    (void) fprintf(stderr, "[-a auth_type] ");
#endif
    (void) fprintf(stderr, "-s | <command>\n");
@


1.22.4.1
log
@MFC:
Fix by millert@@

A race condition in Sudo's command pathname handling prior to
Sudo version 1.6.8p9 that could allow a user with Sudo privileges
to run arbitrary commands.

ok millert@@
@
text
@a298 2
    if (safe_cmnd == NULL)
	safe_cmnd = user_cmnd;
d381 8
@


1.21
log
@If we are in -k/-K mode, just spew to stderr.  It is not unusual
for users to place "sudo -k" in a .logout file which can cause sudo
to be run during reboot after ypbind has died.  Previously, this
would result in useless mail and logging.  Requested by mickey@@
@
text
@d865 1
a865 2
    int fd, maxfd;
#ifdef HAVE_SETRLIMIT
a866 1
#endif
a867 1
#if defined(RLIMIT_CORE) && !defined(SUDO_DEVEL)
d877 1
a877 17
    /*
     * Close any open fd's other than stdin, stdout and stderr.
     */
#ifdef HAVE_SYSCONF
    maxfd = sysconf(_SC_OPEN_MAX) - 1;
#else
    maxfd = getdtablesize() - 1;
#endif /* HAVE_SYSCONF */
#ifdef RLIMIT_NOFILE
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
	if (rl.rlim_max != RLIM_INFINITY && rl.rlim_max <= maxfd)
	    maxfd = rl.rlim_max - 1;
    }
#endif /* RLIMIT_NOFILE */

    for (fd = maxfd; fd > STDERR_FILENO; fd--)
	(void) close(fd);
@


1.20
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d532 8
a539 2
	log_error(0, "uid %lu does not exist in the passwd file!",
	    (unsigned long) pw.pw_uid);
@


1.19
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d34 4
d110 1
a110 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.335 2003/04/02 18:25:19 millert Exp $";
d145 1
a145 1
#endif /* RLIMIT_CORE */
d398 1
a398 1
#endif /* RLIMIT_CORE */
d869 2
a870 1
    rl.rlim_cur = rl.rlim_max = 0;
d872 1
a872 1
#endif /* RLIMIT_CORE */
@


1.18
log
@Update to sudo 1.6.7p1; fixes false positives in the oflow detection
of expand_prompt() introduced in sudo 1.6.7.
@
text
@d38 1
a38 1
#define _SUDO_SUDO_C
d72 5
d106 1
a106 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.334 2003/04/01 15:02:49 millert Exp $";
d113 1
a113 1
static int parse_args			__P((void));
d129 2
a130 4
int Argc;
char **Argv;
int NewArgc = 0;
char **NewArgv = NULL;
d133 1
a133 1
FILE *sudoers_fp = NULL;
d167 3
d172 1
a172 1
    (void) set_auth_parameters(argc, argv);
d181 2
a182 7
    Argv = argv;
    Argc = argc;

    if (geteuid() != 0) {
	(void) fprintf(stderr, "Sorry, %s must be setuid root.\n", Argv[0]);
	exit(1);
    }
d206 1
a206 1
    sudo_mode = parse_args();
d326 1
a326 1
	    Argv[0]);
d364 1
a364 1
	    (void) fprintf(stderr, "%s: ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.\n", Argv[0], user_cmnd, user_cmnd, user_cmnd);
d367 1
a367 2
	    (void) fprintf(stderr, "%s: %s: command not found\n", Argv[0],
		user_cmnd);
d423 1
a423 2
	(void) fprintf(stderr, "%s: unable to exec %s: %s\n",
	    Argv[0], safe_cmnd, strerror(errno));
d440 1
a440 2
		(void) fprintf(stderr, "%s: %s: command not found\n", Argv[0],
		    user_cmnd);
d442 1
a442 1
		(void) fprintf(stderr, "%s: ignoring `%s' found in '.'\nUse `sudo ./%s' if this is the `%s' you wish to run.\n", Argv[0], user_cmnd, user_cmnd, user_cmnd);
d468 2
a469 5
    if (user_cmnd == NULL && strlen(NewArgv[0]) >= MAXPATHLEN) {
	(void) fprintf(stderr, "%s: %s: Pathname too long\n", Argv[0],
	    NewArgv[0]);
	exit(1);
    }
d552 1
a552 2
	    (void) fprintf(stderr, "%s: Can't get working directory!\n",
			   Argv[0]);
d568 2
a569 4
	} else {
	    (void) fprintf(stderr, "%s: Unable to determine shell.", Argv[0]);
	    exit(1);
	}
d571 1
a571 1
	/* copy the args from Argv */
d608 2
a609 5
		if (n >= size - (to - user_args)) {
		    (void) fprintf(stderr,
			"%s: internal error, init_vars() overflow\n", Argv[0]);
		    exit(1);
		}
d625 3
a627 1
parse_args()
d632 2
a633 2
    NewArgv = Argv + 1;
    NewArgc = Argc - 1;
d641 2
a642 5
	if (NewArgv[0][1] != '\0' && NewArgv[0][2] != '\0') {
	    (void) fprintf(stderr, "%s: Please use single character options\n",
		Argv[0]);
	    usage(1);
	}
a651 1
		/* Shift Argv over and adjust Argc. */
a661 1
		/* Shift Argv over and adjust Argc. */
a672 1
		/* Shift Argv over and adjust Argc. */
a685 1
		/* Shift Argv over and adjust Argc. */
d757 1
a757 2
		(void) fprintf(stderr, "%s: '-' requires an argument\n",
		    Argv[0]);
d760 1
a760 2
		(void) fprintf(stderr, "%s: Illegal option %s\n", Argv[0],
		    NewArgv[0]);
d793 1
a793 2
	    (void) fprintf(stderr, "%s: fixed mode on %s\n",
		Argv[0], _PATH_SUDOERS);
d797 1
a797 2
		    (void) fprintf(stderr, "%s: set group on %s\n",
			Argv[0], _PATH_SUDOERS);
d799 2
a800 4
		} else {
		    (void) fprintf(stderr,"%s: Unable to set group on %s: %s\n",
			Argv[0], _PATH_SUDOERS, strerror(errno));
		}
d802 2
a803 4
	} else {
	    (void) fprintf(stderr, "%s: Unable to fix mode on %s: %s\n",
		Argv[0], _PATH_SUDOERS, strerror(errno));
	}
d924 2
a925 5
	if (strcmp(*user_runas, "root") != 0 && user_uid != 0) {
	    (void) fprintf(stderr, "%s: only root can use -c %s\n",
		Argv[0], login_class);
	    exit(1);
	}
@


1.17
log
@update to what will soon be sudo 1.6.7
@
text
@d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.333 2003/03/15 20:31:01 millert Exp $";
d616 1
a616 1
		if (n >= size) {
@


1.16
log
@Update to sudo 1.6.6
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.318 2002/01/15 23:43:59 millert Exp $";
d134 1
d145 1
a145 1
void (*set_perms) __P((int, int));
d160 1
a160 1
    sigaction_t sa;
d184 4
a187 2
     * Ignore keyboard-generated signals so the user cannot interrupt
     * us at some point and avoid the logging.
d192 5
a196 3
    (void) sigaction(SIGINT, &sa, NULL);
    (void) sigaction(SIGQUIT, &sa, NULL);
    (void) sigaction(SIGTSTP, &sa, NULL);
d199 1
a199 1
     * Setup signal handlers, turn off core dumps, and close open files.
a224 1
		    dump_badenv();
d263 2
a264 2
     * If we have POSIX saved uids and the stay_setuid flag was not set,
     * set the real, effective and saved uids to 0 and use set_perms_fallback()
d267 2
a268 1
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
d274 1
a274 1
	set_perms = set_perms_fallback;
d295 16
d323 3
a325 2
	(void) fputs("You are already root, you don't need to use sudo.\n",
	    stderr);
a386 8
	/* Reset signal handlers before we exec. */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
	(void) sigaction(SIGTSTP, &sa, NULL);

d397 1
a397 1
	set_perms(PERM_RUNAS, sudo_mode);
d406 6
d483 1
a483 1
    (void) strcpy(user_cwd, "unknown");
d528 2
a529 1
	(void) sprintf(pw_name, "%ld", (long) pw.pw_uid);
d533 2
a534 2
	log_error(0, "uid %ld does not exist in the passwd file!",
	    (long) pw.pw_uid);
d553 1
a553 1
    set_perms(PERM_USER, sudo_mode);
d555 1
a555 1
	set_perms(PERM_ROOT, sudo_mode);
d559 1
a559 1
	    (void) strcpy(user_cwd, "unknown");
d562 1
a562 1
	set_perms(PERM_ROOT, sudo_mode);
d571 1
a571 1
	NewArgv = (char **) emalloc (sizeof(char *) * (++NewArgc + 1));
d593 1
a593 1
	    set_perms(PERM_USER, sudo_mode);
d595 1
a595 1
	    set_perms(PERM_ROOT, sudo_mode);
d601 1
a601 1
	    size_t size;
d613 9
a621 4
	    to = user_args = (char *) emalloc(size);
	    for (from = NewArgv + 1; *from; from++) {
		(void) strcpy(to, *from);
		to += strlen(*from);
d638 1
a638 1
    int rval = MODE_RUN;		/* what mode is suod to be run in? */
d806 1
a806 1
    if ((rootstat = lstat(_PATH_SUDOERS, &statbuf)) == 0 &&
d835 1
a835 1
    set_perms(PERM_SUDOERS, 0);
d837 1
a837 1
    if (rootstat != 0 && lstat(_PATH_SUDOERS, &statbuf) != 0)
d847 2
a848 2
	log_error(0, "%s is owned by uid %ld, should be %d", _PATH_SUDOERS,
	    (long) statbuf.st_uid, SUDOERS_UID);
d850 2
a851 2
	log_error(0, "%s is owned by gid %ld, should be %d", _PATH_SUDOERS,
	    (long) statbuf.st_gid, SUDOERS_GID);
d869 1
a869 1
    set_perms(PERM_ROOT, 0);		/* change back to root */
a882 1
    sigaction_t sa;
d911 11
a921 8
    /* Catch children as they die... */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = reapchild;
    (void) sigaction(SIGCHLD, &sa, NULL);

    /* Set set_perms pointer to the correct function */
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
d925 3
a927 2
#endif
	set_perms = set_perms_fallback;
@


1.15
log
@update to sudo 1.6.4p2
@
text
@a372 3
	/* Close the password file */
	endpwent();

d384 4
@


1.14
log
@update to sudo 1.6.4p1
@
text
@d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.314 2002/01/13 18:29:23 millert Exp $";
d263 1
a263 1
#if defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
d315 3
a317 3
    /* May need to set $HOME to target user. */
    if (def_flag(I_ALWAYS_SET_HOME) ||
	((sudo_mode & MODE_SHELL) && def_flag(I_SET_HOME)))
d514 2
a515 1
    user_shell = sudo_user.pw->pw_shell;
d892 1
a892 1
#if defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
@


1.13
log
@sync with sudo 1.6.4-final
@
text
@a289 3
    /* Build up custom environment that avoids any nasty bits. */
    new_environ = rebuild_env(sudo_mode, envp);

d335 3
d953 8
a960 8
    if (def_flag(I_FQDN)) {
	if (!(hp = gethostbyname(user_host))) {
	    log_error(MSG_ONLY|NO_EXIT,
		"unable to lookup %s via gethostbyname()", user_host);
	} else {
	    free(user_host);
	    user_host = estrdup(hp->h_name);
	}
a961 2
    if (user_shost != user_host)
	free(user_shost);
@


1.12
log
@sync with sudo 1.6.4rc2
@
text
@d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.313 2002/01/08 15:00:18 millert Exp $";
d257 15
@


1.11
log
@Update to sudo 1.6.4
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.311 2001/12/15 00:45:13 millert Exp $";
d158 1
d275 2
a276 2
    /* Customize environment and get rid of any nasty bits. */
    environ = rebuild_env(sudo_mode, envp);
d372 3
@


1.10
log
@If we fail to lookup a login class, apply the default one.
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-2000 Todd C. Miller <Todd.Miller@@courtesan.com>
d42 8
d52 6
a57 1
#include <stdlib.h>
d59 10
d70 1
a70 1
#include <unistd.h>
a71 6
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
a77 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
a79 4
#ifdef HAVE_SETRLIMIT
#include <sys/time.h>
#include <sys/resource.h>
#endif
a99 4
#ifndef STDC_HEADERS
extern char *getenv	__P((char *));
#endif /* STDC_HEADERS */

d101 1
a101 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.278 2000/03/24 20:13:12 millert Exp $";
a104 8
 * Local type declarations
 */
struct env_table {
    char *name;
    int len;
};

/*
d107 5
a111 1
static int  parse_args			__P((void));
a113 6
static void check_sudoers		__P((void));
static int init_vars			__P((int));
static void set_loginclass		__P((struct passwd *));
static void add_env			__P((int));
static void clean_env			__P((char **, struct env_table *));
static void initial_setup		__P((void));
d115 4
a119 2
extern struct passwd *sudo_getpwnam	__P((const char *));
extern void list_matches		__P((void));
a134 1
static char *runas_homedir = NULL;	/* XXX */
d144 1
a144 27

/*
 * Table of "bad" envariables to remove and len for strncmp()
 */
static struct env_table badenv_table[] = {
    { "IFS=", 4 },
    { "LOCALDOMAIN=", 12 },
    { "RES_OPTIONS=", 12 },
    { "HOSTALIASES=", 12 },
    { "LD_", 3 },
    { "_RLD", 4 },
#ifdef __hpux
    { "SHLIB_PATH=", 11 },
#endif /* __hpux */
#ifdef _AIX
    { "LIBPATH=", 8 },
#endif /* _AIX */
#ifdef HAVE_KERB4
    { "KRB_CONF", 8 },
#endif /* HAVE_KERB4 */
#ifdef HAVE_KERB5
    { "KRB5_CONFIG", 11 },
#endif /* HAVE_KERB5 */
    { "ENV=", 4 },
    { "BASH_ENV=", 9 },
    { (char *) NULL, 0 }
};
d148 1
a148 1
main(argc, argv)
d151 1
d157 3
a159 5
#ifdef POSIX_SIGNALS
    sigset_t set, oset;
#else
    int omask;
#endif /* POSIX_SIGNALS */
a160 1
    extern int printmatches;
d170 3
d182 2
a183 2
     * Block signals so the user cannot interrupt us at some point and
     * avoid the logging.
d185 6
a190 9
#ifdef POSIX_SIGNALS
    (void) sigemptyset(&set);
    (void) sigaddset(&set, SIGINT);
    (void) sigaddset(&set, SIGQUIT);
    (void) sigaddset(&set, SIGTSTP);
    (void) sigprocmask(SIG_BLOCK, &set, &oset);
#else
    omask = sigblock(sigmask(SIGINT)|sigmask(SIGQUIT)|sigmask(SIGTSTP));
#endif /* POSIX_SIGNALS */
d196 1
a196 5

    /*
     * Set the prompt based on $SUDO_PROMPT (can be overridden by `-p')
     */
    user_prompt = getenv("SUDO_PROMPT");
d204 4
d218 2
d228 1
d233 1
d241 1
a249 2
    clean_env(environ, badenv_table);

d252 1
a252 1
    /* At this point, ruid == euid == 0 */
d254 2
a255 1
    check_sudoers();	/* check mode/owner on _PATH_SUDOERS */
d257 16
a272 1
    add_env(!(sudo_mode & MODE_SHELL));	/* add in SUDO_* envariables */
d274 2
a275 2
    /* Validate the user but don't search for pseudo-commands. */
    validated = sudoers_lookup(sudo_mode);
d294 4
d303 2
a304 1
    if ((sudo_mode & MODE_SHELL) && def_flag(I_SET_HOME))
d344 1
a344 1
		"internal error, cmnd_safe never got set for %s; %s",
d349 7
a355 2
	if (def_ival(I_LOGFACSTR))
	    closelog();
d357 2
a358 6
	/* Reset signal mask before we exec. */
#ifdef POSIX_SIGNALS
	(void) sigprocmask(SIG_SETMASK, &oset, NULL);
#else
	(void) sigsetmask(omask);
#endif /* POSIX_SIGNALS */
a363 4
	/* Replace the PATH envariable with a secure one. */
	if (def_str(I_SECURE_PATH) && !user_is_exempt())
	    sudo_setenv("PATH", def_str(I_SECURE_PATH));

a371 4
	/* Set $HOME for `sudo -H'.  Only valid at PERM_RUNAS. */
	if ((sudo_mode & MODE_RESET_HOME) && runas_homedir)
	    sudo_setenv("HOME", runas_homedir);

d385 1
a385 1
	exit(-1);
d427 1
d451 4
a454 4
    if ((gethostname(thost, sizeof(thost)))) {
	user_host = "localhost";
	log_error(USE_ERRNO|MSG_ONLY, "can't get hostname");
    } else
d456 3
a458 7
    if (def_flag(I_FQDN))
	set_fqdn();
    else {
	if ((p = strchr(user_host, '.'))) {
	    *p = '\0';
	    user_shost = estrdup(user_host);
	    *p = '.';
d460 7
a466 1
	    user_shost = user_host;
d495 1
d500 9
a522 6
     * Load the list of local ip addresses and netmasks into
     * the interfaces array.
     */
    load_interfaces();

    /*
d546 37
a582 4
    if ((sudo_mode & MODE_RUN))
	return(find_path(NewArgv[0], &user_cmnd));
    else
	return(FOUND);
d652 1
a652 1
		def_flag(I_LOGINCLASS) = TRUE;
d713 3
a744 64
 * Add sudo-specific variables into the environment.
 * Sets ``cmnd_args'' as a side effect.
 */
static void
add_env(contiguous)
    int contiguous;
{
    char idstr[MAX_UID_T_LEN + 1];
    size_t size;
    char *buf;

    /* Add the SUDO_COMMAND envariable (cmnd + args). */
    size = strlen(user_cmnd) + 1;
    if (NewArgc > 1) {
	char *to, **from;

	if (contiguous) {
	    size += (size_t) (NewArgv[NewArgc-1] - NewArgv[1]) +
		    strlen(NewArgv[NewArgc-1]) + 1;
	} else {
	    for (from = &NewArgv[1]; *from; from++)
		size += strlen(*from) + 1;
	}

	buf = (char *) emalloc(size);

	/*
	 * Copy the command and it's arguments info buf.
	 */
	(void) strcpy(buf, user_cmnd);
	to = buf + strlen(user_cmnd);
	for (from = &NewArgv[1]; *from; from++) {
	    *to++ = ' ';
	    (void) strcpy(to, *from);
	    to += strlen(*from);
	}
    } else {
	buf = user_cmnd;
    }
    sudo_setenv("SUDO_COMMAND", buf);
    if (NewArgc > 1)
	free(buf);

    /* Grab a pointer to the flat arg string from the environment. */
    if (NewArgc > 1 && (user_args = getenv("SUDO_COMMAND"))) {
	if ((user_args = strchr(user_args, ' ')))
	    user_args++;
	else
	    user_args = NULL;
    }

    /* Add the SUDO_USER, SUDO_UID, SUDO_GID environment variables. */
    sudo_setenv("SUDO_USER", user_name);
    (void) sprintf(idstr, "%ld", (long) user_uid);
    sudo_setenv("SUDO_UID", idstr);
    (void) sprintf(idstr, "%ld", (long) user_gid);
    sudo_setenv("SUDO_GID", idstr);

    /* Set PS1 if SUDO_PS1 is set. */
    if ((buf = getenv("SUDO_PS1")))
	sudo_setenv("PS1", buf);
}

/*
a825 170
 * Remove environment variables that match the entries in badenv_table.
 */
static void
clean_env(envp, badenv_table)
    char **envp;
    struct env_table *badenv_table;
{
    struct env_table *bad;
    char **cur;

    /*
     * Remove any envars that match entries in badenv_table.
     */
    for (cur = envp; *cur; cur++) {
	for (bad = badenv_table; bad->name; bad++) {
	    if (strncmp(*cur, bad->name, bad->len) == 0) {
		/* Got a match so remove it. */
		char **move;

		for (move = cur; *move; move++)
		    *move = *(move + 1);

		cur--;

		break;
	    }
	}
    }
}

/*
 * Set real and effective uids and gids based on perm.
 */
void
set_perms(perm, sudo_mode)
    int perm;
    int sudo_mode;
{
    struct passwd *pw;

    /*
     * First, set real & effective uids to root.
     * If perm is PERM_ROOT then we don't need to do anything else.
     */
    if (setuid(0)) {
	perror("setuid(0)");
	exit(1);
    }

    switch (perm) {
	case PERM_USER:
    	    	    	        (void) setgid(user_gid);

    	    	    	        if (seteuid(user_uid)) {
    	    	    	            perror("seteuid(user_uid)");
    	    	    	            exit(1);
    	    	    	        }
			      	break;
				
	case PERM_FULL_USER:
    	    	    	        (void) setgid(user_gid);

				if (setuid(user_uid)) {
				    perror("setuid(user_uid)");
				    exit(1);
				}
			      	break;

	case PERM_RUNAS:
				/* XXX - add group/gid support */
				if (**user_runas == '#') {
				    if (setuid(atoi(*user_runas + 1))) {
					(void) fprintf(stderr,
					    "%s: cannot set uid to %s: %s\n",
					    Argv[0], *user_runas, strerror(errno));
					exit(1);
				    }
				} else {
				    if (!(pw = getpwnam(*user_runas))) {
					(void) fprintf(stderr,
					    "%s: no passwd entry for %s!\n",
					    Argv[0], *user_runas);
					exit(1);
				    }

				    /* Set $USER and $LOGNAME to target user */
				    if (def_flag(I_LOGNAME)) {
					sudo_setenv("USER", pw->pw_name);
					sudo_setenv("LOGNAME", pw->pw_name);
				    }

#ifdef HAVE_LOGIN_CAP_H
				    if (def_flag(I_LOGINCLASS)) {
					/*
					 * setusercontext() will set uid/gid/etc
					 * for us so no need to do it below.
					 */
					if (setusercontext(lc, pw, pw->pw_uid,
					    LOGIN_SETUSER|LOGIN_SETGROUP|LOGIN_SETRESOURCES|LOGIN_SETPRIORITY))
					    log_error(
						NO_MAIL|USE_ERRNO|MSG_ONLY,
						"setusercontext() failed for login class %s",
						login_class);
					else
					    break;
				    }
#endif /* HAVE_LOGIN_CAP_H */

				    if (setgid(pw->pw_gid)) {
					(void) fprintf(stderr,
					    "%s: cannot set gid to %ld: %s\n",
					    Argv[0], (long) pw->pw_gid,
					    strerror(errno));
					exit(1);
				    }
#ifdef HAVE_INITGROUPS
				    /*
				     * Initialize group vector only if are
				     * going to run as a non-root user.
				     */
				    if (strcmp(*user_runas, "root") != 0 &&
					initgroups(*user_runas, pw->pw_gid)
					== -1) {
					(void) fprintf(stderr,
					    "%s: cannot set group vector: %s\n",
					    Argv[0], strerror(errno));
					exit(1);
				    }
#endif /* HAVE_INITGROUPS */
				    if (setuid(pw->pw_uid)) {
					(void) fprintf(stderr,
					    "%s: cannot set uid to %ld: %s\n",
					    Argv[0], (long) pw->pw_uid,
					    strerror(errno));
					exit(1);
				    }
				    if (sudo_mode & MODE_RESET_HOME)
					runas_homedir = pw->pw_dir;
				}
				break;

	case PERM_SUDOERS:
				if (setgid(SUDOERS_GID)) {
				    perror("setgid(SUDOERS_GID)");
				    exit(1);
				}

				/*
				 * If SUDOERS_UID == 0 and SUDOERS_MODE
				 * is group readable we use a non-zero
				 * uid in order to avoid NFS lossage.
				 * Using uid 1 is a bit bogus but should
				 * work on all OS's.
				 */
				if (SUDOERS_UID == 0) {
				    if ((SUDOERS_MODE & 040) && seteuid(1)) {
					perror("seteuid(1)");
					exit(1);
				    }
				} else {
				    if (seteuid(SUDOERS_UID)) {
					perror("seteuid(SUDOERS_UID)");
					exit(1);
				    }
				}
			      	break;
    }
}

/*
d827 1
d836 1
a836 3
#ifdef POSIX_SIGNALS
    struct sigaction sa;
#endif
d866 2
a867 2
#ifdef POSIX_SIGNALS
    (void) memset((VOID *)&sa, 0, sizeof(sa));
d870 8
a877 3
#else
    (void) signal(SIGCHLD, reapchild);
#endif /* POSIX_SIGNALS */
d913 2
a914 1
	lc = login_getclass(NULL);	/* Fall back on default login class */
d936 1
a936 1
	    log_error(USE_ERRNO|MSG_ONLY|NO_EXIT,
d967 1
a967 1
	if ((pw = sudo_getpwnam(def_str(I_RUNAS_DEF))) == NULL)
d969 1
a969 1
		def_str(I_RUNAS_DEF));
d1007 1
a1007 1
	"[-H] [-S] [-b] [-p prompt]\n            [-u username/#uid] ");
@


1.10.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
a41 8
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/socket.h>
#ifdef HAVE_SETRLIMIT
# include <sys/time.h>
# include <sys/resource.h>
#endif
d44 1
a44 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d46 3
d50 1
a50 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d52 3
a54 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d61 3
d66 4
d90 4
d95 1
a95 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.318 2002/01/15 23:43:59 millert Exp $";
d99 8
d109 4
d114 3
a116 2
static int parse_args			__P((void));
static void check_sudoers		__P((void));
a117 3
static void set_loginclass		__P((struct passwd *));
static void usage			__P((int));
static void usage_excl			__P((int));
d119 2
a121 4
extern char **rebuild_env		__P((int, char **));
extern char **zero_env			__P((char **));
extern struct passwd *sudo_getpwnam	__P((const char *));
extern struct passwd *sudo_getpwuid	__P((uid_t));
d137 1
d147 27
a173 1
void (*set_perms) __P((int, int));
d177 1
a177 1
main(argc, argv, envp)
a179 1
    char **envp;
d185 6
a190 3
    int pwflag;
    char **new_environ;
    sigaction_t sa;
a191 1
    extern char **environ;
a200 3
    /* Zero out the environment. */
    environ = zero_env(envp);

d210 2
a211 2
     * Ignore keyboard-generated signals so the user cannot interrupt
     * us at some point and avoid the logging.
d213 9
a221 6
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_IGN;
    (void) sigaction(SIGINT, &sa, NULL);
    (void) sigaction(SIGQUIT, &sa, NULL);
    (void) sigaction(SIGTSTP, &sa, NULL);
d227 5
a231 1
    setpwent();
a238 4
    /* Load the list of local ip addresses and netmasks.  */
    load_interfaces();

    pwflag = 0;
a248 2
		    dump_interfaces();
		    dump_badenv();
a256 1
		pwflag = I_VERIFYPW_I;
a260 1
		pwflag = -1;
a267 1
		pwflag = I_LISTPW_I;
d276 2
d280 2
d284 2
d287 1
a287 33
    validated = sudoers_lookup(pwflag);

    /*
     * If we have POSIX saved uids and the stay_setuid flag was not set,
     * set the real, effective and saved uids to 0 and use set_perms_fallback()
     * instead of set_perms_posix().
     */
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (!def_flag(I_STAY_SETUID) && set_perms == set_perms_posix) {
	if (setuid(0)) {
	    perror("setuid(0)");
	    exit(1);
	}
	set_perms = set_perms_fallback;
    }
#endif

    /*
     * Look up runas user passwd struct.  If we are given a uid then
     * there may be no corresponding passwd(5) entry (which is OK).
     */
    if (**user_runas == '#') {
	runas_pw = sudo_getpwuid(atoi(*user_runas + 1));
	if (runas_pw == NULL) {
	    runas_pw = emalloc(sizeof(struct passwd));
	    (void) memset((VOID *)runas_pw, 0, sizeof(struct passwd));
	    runas_pw->pw_uid = atoi(*user_runas + 1);
	}
    } else {
	runas_pw = sudo_getpwnam(*user_runas);
	if (runas_pw == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "no passwd entry for %s!", *user_runas);
    }
a305 4
    /* If given the -P option, set the "preserve_groups" flag. */
    if (sudo_mode & MODE_PRESERVE_GROUPS)
	def_flag(I_PRESERVE_GROUPS) = TRUE;

d310 2
a311 3
    /* May need to set $HOME to target user if we are running a command. */
    if ((sudo_mode & MODE_RUN) && (def_flag(I_ALWAYS_SET_HOME) ||
	((sudo_mode & MODE_SHELL) && def_flag(I_SET_HOME))))
a328 3
    /* Build up custom environment that avoids any nasty bits. */
    new_environ = rebuild_env(sudo_mode, envp);

d351 1
a351 1
		"internal error, safe_cmnd never got set for %s; %s",
d356 2
a357 7
	/* Reset signal handlers before we exec. */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
	(void) sigaction(SIGTSTP, &sa, NULL);
d359 6
a364 2
	/* Close the password file */
	endpwent();
d370 4
d382 3
a384 2
	/* Install the new environment. */
	environ = new_environ;
d399 1
a399 1
	exit(127);
a440 1
    int nohostname, rval;
d464 7
a470 3
    nohostname = gethostname(thost, sizeof(thost));
    if (nohostname)
	user_host = user_shost = "localhost";
d472 5
a476 3
	user_host = estrdup(thost);
	if (def_flag(I_FQDN)) {
	    /* Defer call to set_fqdn() until log_error() is safe. */
a477 8
	} else {
	    if ((p = strchr(user_host, '.'))) {
		*p = '\0';
		user_shost = estrdup(user_host);
		*p = '.';
	    } else {
		user_shost = user_host;
	    }
a505 2
    if (user_shell == NULL || *user_shell == '\0')
	user_shell = sudo_user.pw->pw_shell;
a509 9
     * Must defer set_fqdn() until it is safe to call log_error()
     */
    if (def_flag(I_FQDN))
	set_fqdn();

    if (nohostname)
	log_error(USE_ERRNO|MSG_ONLY, "can't get hostname");

    /*
d524 6
d553 4
a556 37
    if ((sudo_mode & MODE_RUN)) {
	/* XXX - should call this as runas user, not root. */
	rval = find_path(NewArgv[0], &user_cmnd, user_path);
	if (rval != FOUND) {
	    /* Failed as root, try as invoking user. */
	    set_perms(PERM_USER, sudo_mode);
	    rval = find_path(NewArgv[0], &user_cmnd, user_path);
	    set_perms(PERM_ROOT, sudo_mode);
	}

	/* set user_args */
	if (NewArgc > 1) {
	    char *to, **from;
	    size_t size;

	    /* If MODE_SHELL not set then NewArgv is contiguous so just count */
	    if (!(sudo_mode & MODE_SHELL)) {
		size = (size_t) (NewArgv[NewArgc-1] - NewArgv[1]) +
			strlen(NewArgv[NewArgc-1]) + 1;
	    } else {
		for (size = 0, from = NewArgv + 1; *from; from++)
		    size += strlen(*from) + 1;
	    }

	    /* alloc and copy. */
	    to = user_args = (char *) emalloc(size);
	    for (from = NewArgv + 1; *from; from++) {
		(void) strcpy(to, *from);
		to += strlen(*from);
		*to++ = ' ';
	    }
	    *--to = '\0';
	}
    } else
	rval = FOUND;

    return(rval);
d626 1
a626 1
		def_flag(I_USE_LOGINCLASS) = TRUE;
a686 3
	    case 'P':
		rval |= MODE_PRESERVE_GROUPS;
		break;
d716 64
d861 170
a1031 1
 * Also sets the set_perms() pointer to the correct function.
d1040 3
a1042 1
    sigaction_t sa;
d1072 2
a1073 2
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
d1076 3
a1078 8

    /* Set set_perms pointer to the correct function */
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (sysconf(_SC_SAVED_IDS) == 1 && sysconf(_SC_VERSION) >= 199009)
	set_perms = set_perms_posix;
    else
#endif
	set_perms = set_perms_fallback;
d1114 1
a1114 2
	if (!lc)
	    lc = login_getclass(NULL);	/* needed for login_getstyle() later */
d1134 8
a1141 8
    if (!(hp = gethostbyname(user_host))) {
	log_error(MSG_ONLY|NO_EXIT,
	    "unable to lookup %s via gethostbyname()", user_host);
    } else {
	if (user_shost != user_host)
	    free(user_shost);
	free(user_host);
	user_host = estrdup(hp->h_name);
d1143 2
d1167 1
a1167 1
	if ((pw = sudo_getpwnam(def_str(I_RUNAS_DEFAULT))) == NULL)
d1169 1
a1169 1
		def_str(I_RUNAS_DEFAULT));
d1207 1
a1207 1
	"[-H] [-P] [-S] [-b] [-p prompt]\n            [-u username/#uid] ");
@


1.9
log
@Give sensible error messaage for a zero-length sudoers file.
From the sudo cvs repo.
@
text
@d1112 1
a1112 1
    if (!lc || !lc->lc_class || strcmp(lc->lc_class, login_class) != 0)
d1114 2
@


1.9.2.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1993-1996,1998-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
a41 8
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/socket.h>
#ifdef HAVE_SETRLIMIT
# include <sys/time.h>
# include <sys/resource.h>
#endif
d44 1
a44 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d46 3
d50 1
a50 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d52 3
a54 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d61 3
d66 4
d90 4
d95 1
a95 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.318 2002/01/15 23:43:59 millert Exp $";
d99 8
d109 4
d114 3
a116 2
static int parse_args			__P((void));
static void check_sudoers		__P((void));
a117 3
static void set_loginclass		__P((struct passwd *));
static void usage			__P((int));
static void usage_excl			__P((int));
d119 2
a121 4
extern char **rebuild_env		__P((int, char **));
extern char **zero_env			__P((char **));
extern struct passwd *sudo_getpwnam	__P((const char *));
extern struct passwd *sudo_getpwuid	__P((uid_t));
d137 1
d147 27
a173 1
void (*set_perms) __P((int, int));
d177 1
a177 1
main(argc, argv, envp)
a179 1
    char **envp;
d185 6
a190 3
    int pwflag;
    char **new_environ;
    sigaction_t sa;
a191 1
    extern char **environ;
a200 3
    /* Zero out the environment. */
    environ = zero_env(envp);

d210 2
a211 2
     * Ignore keyboard-generated signals so the user cannot interrupt
     * us at some point and avoid the logging.
d213 9
a221 6
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_IGN;
    (void) sigaction(SIGINT, &sa, NULL);
    (void) sigaction(SIGQUIT, &sa, NULL);
    (void) sigaction(SIGTSTP, &sa, NULL);
d227 5
a231 1
    setpwent();
a238 4
    /* Load the list of local ip addresses and netmasks.  */
    load_interfaces();

    pwflag = 0;
a248 2
		    dump_interfaces();
		    dump_badenv();
a256 1
		pwflag = I_VERIFYPW_I;
a260 1
		pwflag = -1;
a267 1
		pwflag = I_LISTPW_I;
d276 2
d280 2
d284 2
d287 1
a287 33
    validated = sudoers_lookup(pwflag);

    /*
     * If we have POSIX saved uids and the stay_setuid flag was not set,
     * set the real, effective and saved uids to 0 and use set_perms_fallback()
     * instead of set_perms_posix().
     */
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (!def_flag(I_STAY_SETUID) && set_perms == set_perms_posix) {
	if (setuid(0)) {
	    perror("setuid(0)");
	    exit(1);
	}
	set_perms = set_perms_fallback;
    }
#endif

    /*
     * Look up runas user passwd struct.  If we are given a uid then
     * there may be no corresponding passwd(5) entry (which is OK).
     */
    if (**user_runas == '#') {
	runas_pw = sudo_getpwuid(atoi(*user_runas + 1));
	if (runas_pw == NULL) {
	    runas_pw = emalloc(sizeof(struct passwd));
	    (void) memset((VOID *)runas_pw, 0, sizeof(struct passwd));
	    runas_pw->pw_uid = atoi(*user_runas + 1);
	}
    } else {
	runas_pw = sudo_getpwnam(*user_runas);
	if (runas_pw == NULL)
	    log_error(NO_MAIL|MSG_ONLY, "no passwd entry for %s!", *user_runas);
    }
a305 4
    /* If given the -P option, set the "preserve_groups" flag. */
    if (sudo_mode & MODE_PRESERVE_GROUPS)
	def_flag(I_PRESERVE_GROUPS) = TRUE;

d310 2
a311 3
    /* May need to set $HOME to target user if we are running a command. */
    if ((sudo_mode & MODE_RUN) && (def_flag(I_ALWAYS_SET_HOME) ||
	((sudo_mode & MODE_SHELL) && def_flag(I_SET_HOME))))
a328 3
    /* Build up custom environment that avoids any nasty bits. */
    new_environ = rebuild_env(sudo_mode, envp);

d351 1
a351 1
		"internal error, safe_cmnd never got set for %s; %s",
d356 2
a357 7
	/* Reset signal handlers before we exec. */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = SA_RESTART;
	sa.sa_handler = SIG_DFL;
	(void) sigaction(SIGINT, &sa, NULL);
	(void) sigaction(SIGQUIT, &sa, NULL);
	(void) sigaction(SIGTSTP, &sa, NULL);
d359 6
a364 2
	/* Close the password file */
	endpwent();
d370 4
d382 3
a384 2
	/* Install the new environment. */
	environ = new_environ;
d399 1
a399 1
	exit(127);
a440 1
    int nohostname, rval;
d464 7
a470 3
    nohostname = gethostname(thost, sizeof(thost));
    if (nohostname)
	user_host = user_shost = "localhost";
d472 5
a476 3
	user_host = estrdup(thost);
	if (def_flag(I_FQDN)) {
	    /* Defer call to set_fqdn() until log_error() is safe. */
a477 8
	} else {
	    if ((p = strchr(user_host, '.'))) {
		*p = '\0';
		user_shost = estrdup(user_host);
		*p = '.';
	    } else {
		user_shost = user_host;
	    }
a505 2
    if (user_shell == NULL || *user_shell == '\0')
	user_shell = sudo_user.pw->pw_shell;
a509 9
     * Must defer set_fqdn() until it is safe to call log_error()
     */
    if (def_flag(I_FQDN))
	set_fqdn();

    if (nohostname)
	log_error(USE_ERRNO|MSG_ONLY, "can't get hostname");

    /*
d524 6
d553 4
a556 37
    if ((sudo_mode & MODE_RUN)) {
	/* XXX - should call this as runas user, not root. */
	rval = find_path(NewArgv[0], &user_cmnd, user_path);
	if (rval != FOUND) {
	    /* Failed as root, try as invoking user. */
	    set_perms(PERM_USER, sudo_mode);
	    rval = find_path(NewArgv[0], &user_cmnd, user_path);
	    set_perms(PERM_ROOT, sudo_mode);
	}

	/* set user_args */
	if (NewArgc > 1) {
	    char *to, **from;
	    size_t size;

	    /* If MODE_SHELL not set then NewArgv is contiguous so just count */
	    if (!(sudo_mode & MODE_SHELL)) {
		size = (size_t) (NewArgv[NewArgc-1] - NewArgv[1]) +
			strlen(NewArgv[NewArgc-1]) + 1;
	    } else {
		for (size = 0, from = NewArgv + 1; *from; from++)
		    size += strlen(*from) + 1;
	    }

	    /* alloc and copy. */
	    to = user_args = (char *) emalloc(size);
	    for (from = NewArgv + 1; *from; from++) {
		(void) strcpy(to, *from);
		to += strlen(*from);
		*to++ = ' ';
	    }
	    *--to = '\0';
	}
    } else
	rval = FOUND;

    return(rval);
d626 1
a626 1
		def_flag(I_USE_LOGINCLASS) = TRUE;
a686 3
	    case 'P':
		rval |= MODE_PRESERVE_GROUPS;
		break;
d716 64
d861 170
a1031 1
 * Also sets the set_perms() pointer to the correct function.
d1040 3
a1042 1
    sigaction_t sa;
d1072 2
a1073 2
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
d1076 3
a1078 8

    /* Set set_perms pointer to the correct function */
#if !defined(NO_SAVED_IDS) && defined(_SC_SAVED_IDS) && defined(_SC_VERSION)
    if (sysconf(_SC_SAVED_IDS) == 1 && sysconf(_SC_VERSION) >= 199009)
	set_perms = set_perms_posix;
    else
#endif
	set_perms = set_perms_fallback;
d1112 1
a1112 1
    if (!lc || !lc->lc_class || strcmp(lc->lc_class, login_class) != 0) {
a1113 3
	if (!lc)
	    lc = login_getclass(NULL);	/* needed for login_getstyle() later */
    }
d1132 8
a1139 8
    if (!(hp = gethostbyname(user_host))) {
	log_error(MSG_ONLY|NO_EXIT,
	    "unable to lookup %s via gethostbyname()", user_host);
    } else {
	if (user_shost != user_host)
	    free(user_shost);
	free(user_host);
	user_host = estrdup(hp->h_name);
d1141 2
d1165 1
a1165 1
	if ((pw = sudo_getpwnam(def_str(I_RUNAS_DEFAULT))) == NULL)
d1167 1
a1167 1
		def_str(I_RUNAS_DEFAULT));
d1205 1
a1205 1
	"[-H] [-P] [-S] [-b] [-p prompt]\n            [-u username/#uid] ");
@


1.8
log
@A few updates from the sudo developement tree:
- Add bsd authentication support (currently disabled)
- Always check setenv() return value
- Fix umask disabling
@
text
@d829 2
@


1.7
log
@update to sudo 1.6.3p5
@
text
@d79 1
a79 1
#ifdef HAVE_LOGINCAP
d114 1
a114 1
static int set_loginclass		__P((struct passwd *));
d141 6
d372 1
a372 5
	    if (sudo_setenv("PATH", def_str(I_SECURE_PATH))) {
		(void) fprintf(stderr, "%s: cannot allocate memory!\n",
		    Argv[0]);
		exit(1);
	    }
d384 1
a384 1
	    (void) sudo_setenv("HOME", runas_homedir);
d549 3
d606 14
a619 1
#ifdef HAVE_LOGINCAP
d755 1
a755 4
    if (sudo_setenv("SUDO_COMMAND", buf)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d767 2
a768 7
    /* Add the SUDO_USER environment variable. */
    if (sudo_setenv("SUDO_USER", user_name)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    /* Add the SUDO_UID environment variable. */
d770 1
a770 6
    if (sudo_setenv("SUDO_UID", idstr)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }

    /* Add the SUDO_GID environment variable. */
d772 1
a772 4
    if (sudo_setenv("SUDO_GID", idstr)) {
	(void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	exit(1);
    }
d776 1
a776 4
	if (sudo_setenv("PS1", buf)) {
	    (void) fprintf(stderr, "%s: cannot allocate memory!\n", Argv[0]);
	    exit(1);
	}
d946 2
a947 12
					if (sudo_setenv("USER", pw->pw_name)) {
					    (void) fprintf(stderr,
						"%s: cannot allocate memory!\n",
						Argv[0]);
					    exit(1);
					}
					if (sudo_setenv("LOGNAME", pw->pw_name)) {
					    (void) fprintf(stderr,
						"%s: cannot allocate memory!\n",
						Argv[0]);
					    exit(1);
					}
d950 1
d956 7
a962 1
					if (set_loginclass(pw) > 0)
d965 1
d1079 2
a1080 2
#ifdef HAVE_LOGINCAP
static int
a1083 1
    login_cap_t *lc;
d1110 1
a1110 1
    if (!lc || !lc->lc_class || strcmp(lc->lc_class, login_class) != 0) {
a1111 11
	return(0);
    }
    
    /* Set everything except the environment and umask.  */
    if (setusercontext(lc, pw, pw->pw_uid,
	LOGIN_SETUSER|LOGIN_SETGROUP|LOGIN_SETRESOURCES|LOGIN_SETPRIORITY) < 0)
	log_error(NO_MAIL|USE_ERRNO|MSG_ONLY,
	    "setusercontext() failed for login class %s", login_class);

    login_close(lc);
    return(1);
d1114 1
a1114 1
static int
a1117 1
    return(0);
d1119 1
a1119 1
#endif /* HAVE_LOGINCAP */
d1201 8
a1208 7
    (void) fprintf(stderr,
	"usage: %s -V | -h | -L | -l | -v | -k | -K | [-H] [-S] [-b]\n%*s",
	Argv[0], (int) strlen(Argv[0]) + 8, " ");
#ifdef HAVE_LOGINCAP
    (void) fprintf(stderr, "[-p prompt] [-u username/#uid] [-c class] -s | <command>\n");
#else
    (void) fprintf(stderr, "[-p prompt] [-u username/#uid] -s | <command>\n");
d1210 1
@


1.6
log
@Update to sudo 1.6.3p4
@
text
@a178 1
    int sudoers_flags;
a232 1
    sudoers_flags = 0;
a250 1
		sudoers_flags = def_ival(I_VERIFYPW);
a254 1
		sudoers_flags = PWCHECK_NEVER;
a262 1
		sudoers_flags = def_ival(I_LISTPW);
d281 1
a281 1
    validated = sudoers_lookup(sudoers_flags);
@


1.5
log
@Make the -H option work again.
@
text
@d118 1
a118 1
static void update_epasswd		__P((void));
d120 1
d131 1
d321 2
a322 2
    /* Update encrypted password in user_password if sudoers said to.  */
    update_epasswd();
d350 1
a350 1
		"internal error, safe_cmnd never got set for %s; %s",
d1172 2
a1173 2
 * If the sudoers file says to prompt for a different user's password,
 * update the encrypted password in user_passwd accordingly.
d1175 2
a1176 2
static void
update_epasswd()
a1179 1
    /* We may be configured to prompt for a password other than the user's */
d1181 1
a1181 1
	if ((pw = getpwuid(0)) == NULL)
a1182 2
	free(user_passwd);
	user_passwd = estrdup(sudo_getepw(pw));
d1184 1
a1184 1
	if ((pw = getpwnam(def_str(I_RUNAS_DEF))) == NULL)
a1186 2
	free(user_passwd);
	user_passwd = estrdup(sudo_getepw(pw));
d1189 1
a1189 1
	    if ((pw = getpwuid(atoi(*user_runas + 1))) == NULL)
d1193 1
a1193 1
	    if ((pw = getpwnam(*user_runas)) == NULL)
d1197 4
a1200 3
	free(user_passwd);
	user_passwd = estrdup(sudo_getepw(pw));
    }
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@a344 4
	/* Set $HOME for `sudo -H' */
	if ((sudo_mode & MODE_RESET_HOME) && runas_homedir)
	    (void) sudo_setenv("HOME", runas_homedir);

d348 1
a348 1
		"internal error, cmnd_safe never got set for %s; %s",
d382 4
@


1.3
log
@sudo 1.6.2
@
text
@d79 6
d95 1
a95 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.268 2000/01/17 23:46:25 millert Exp $";
d114 1
d118 1
a118 1
extern int  user_is_exempt		__P((void));
a130 1
static char *runas_homedir = NULL;	/* XXX */
d133 1
d135 4
d319 3
a344 3
	/* Become specified user or root. */
	set_perms(PERM_RUNAS, sudo_mode);

d379 8
d604 14
d672 3
d949 13
a961 5
				    if (sudo_setenv("USER", pw->pw_name)) {
					(void) fprintf(stderr,
					    "%s: cannot allocate memory!\n",
					    Argv[0]);
					exit(1);
d963 8
a970 5
				    if (sudo_setenv("LOGNAME", pw->pw_name)) {
					(void) fprintf(stderr,
					    "%s: cannot allocate memory!\n",
					    Argv[0]);
					exit(1);
d1052 1
d1085 55
d1170 36
d1225 1
a1225 1
	"usage: %s -V | -h | -L | -l | -v | -k | -K | -H | [-b] [-p prompt]\n%*s",
d1227 5
a1231 1
    (void) fprintf(stderr, "[-u username/#uid] -s | <command>\n");
@


1.2
log
@sudo 1.6.1
@
text
@d2 1
a2 1
 * Copyright (c) 1994-1996,1998-1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d89 1
a89 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.262 1999/12/09 04:04:47 millert Exp $";
d166 1
a166 1
    int check_cmnd;
d221 1
a221 1
    check_cmnd = 1;
d240 1
a240 1
		check_cmnd = 0;
d245 1
a245 1
		check_cmnd = 0;
d254 1
a254 1
		check_cmnd = 0;
d273 1
a273 1
    validated = sudoers_lookup(check_cmnd);
d292 4
a549 1
#ifdef SHELL_IF_NO_ARGS
d551 1
a551 1
	rval |= MODE_SHELL;
a553 1
#endif
a641 1
#ifdef SHELL_IF_NO_ARGS
d643 1
a643 2
		    rval |= MODE_SHELL;
#endif
d769 1
a1011 5
#ifdef RLIMIT_NOFILE
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
	maxfd = rl.rlim_max - 1;
    else
#endif /* RLIMIT_NOFILE */
d1013 1
a1013 1
	maxfd = sysconf(_SC_OPEN_MAX) - 1;
d1015 1
a1015 1
	maxfd = getdtablesize() - 1;
d1017 6
@


1.1
log
@Initial revision
@
text
@d89 1
a89 1
static const char rcsid[] = "$Sudo: sudo.c,v 1.258 1999/11/16 06:09:23 millert Exp $";
d166 1
d221 1
a221 9
    /* Initialize syslog(3) if we are using it. */
    if (def_str(I_LOGFACSTR)) {
#ifdef LOG_NFACILITIES
	openlog("sudo", 0, def_ival(I_LOGFAC));
#else
	openlog("sudo", 0);
#endif /* LOG_NFACILITIES */
    }

d240 1
d245 1
d254 1
d270 6
a280 6
    add_env(!(sudo_mode & MODE_SHELL));	/* add in SUDO_* envariables */

    /* Validate the user but don't search for pseudo-commands. */
    validated =
	sudoers_lookup((sudo_mode != MODE_VALIDATE && sudo_mode != MODE_LIST));

d292 4
a418 1
    struct hostent *hp;
d447 7
a453 4
    if (def_flag(I_FQDN)) {
	if (!(hp = gethostbyname(user_host))) {
	    log_error(USE_ERRNO|MSG_ONLY|NO_EXIT,
		"unable to lookup %s via gethostbyname()", user_host);
d455 1
a455 2
	    free(user_host);
	    user_host = estrdup(hp->h_name);
a457 7
    if ((p = strchr(user_host, '.'))) {
	*p = '\0';
	user_shost = estrdup(user_host);
	*p = '.';
    } else {
	user_shost = user_host;
    }
d546 2
a547 3
    if (Argc < 2) {			/* no options and no command */
	if (!def_flag(I_SHELL_NOARGS))
	    usage(1);
d551 1
d630 3
a632 2
		if (def_flag(I_SET_HOME))
		    rval |= MODE_RESET_HOME;
d640 2
a641 1
		if (def_flag(I_SHELL_NOARGS) && rval == MODE_RUN)
d643 1
d932 1
a932 1

d945 1
a945 1

d1036 29
d1072 1
a1072 1
	"Only one of the -v, -k, -K, -l, -V and -h options may be used\n");
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
