head	1.26;
access;
symbols
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.24.0.18
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.14
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.25;
commitid	8ra5qnWqy2bUhcZn;

1.25
date	2014.04.22.22.11.23;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.02.19.30.10;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.07.18.43.11;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.19.21.43.19;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.24.15.13.35;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.22.16.33.42;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.31.16.44.04;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.03.15.09.48;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.25.16.08.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.05.23.31.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.05.00.23.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.23.23.03.24;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.27.03.44.39;	author millert;	state Exp;
branches
	1.4.6.1
	1.4.8.1;
next	1.3;

1.3
date	2000.01.24.04.22.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.4.6.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.4.8.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1999-2005, 2007-2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <errno.h>

#ifdef HAVE_PAM_PAM_APPL_H
# include <pam/pam_appl.h>
#else
# include <security/pam_appl.h>
#endif

#ifdef HAVE_DGETTEXT
# include <libintl.h>
# if defined(__LINUX_PAM__)
#  define PAM_TEXT_DOMAIN	"Linux-PAM"
# elif defined(__sun__)
#  define PAM_TEXT_DOMAIN	"SUNW_OST_SYSOSPAM"
# endif
#endif

#include "sudo.h"
#include "sudo_auth.h"

/* Only OpenPAM and Linux PAM use const qualifiers. */
#if defined(_OPENPAM) || defined(OPENPAM_VERSION) || \
    defined(__LIBPAM_VERSION) || defined(__LINUX_PAM__)
# define PAM_CONST	const
#else
# define PAM_CONST
#endif

static int sudo_conv __P((int, PAM_CONST struct pam_message **,
			  struct pam_response **, void *));
static char *def_prompt = "Password:";
static int gotintr;

#ifndef PAM_DATA_SILENT
#define PAM_DATA_SILENT	0
#endif

static pam_handle_t *pamh;	/* global due to pam_prep_user() */

int
pam_init(pw, promptp, auth)
    struct passwd *pw;
    char **promptp;
    sudo_auth *auth;
{
    static struct pam_conv pam_conv;
    static int pam_status;

    /* Initial PAM setup */
    if (auth != NULL)
	auth->data = (void *) &pam_status;
    pam_conv.conv = sudo_conv;
    pam_status = pam_start("sudo", pw->pw_name, &pam_conv, &pamh);
    if (pam_status != PAM_SUCCESS) {
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL, "unable to initialize PAM");
	return(AUTH_FATAL);
    }

    /*
     * Set PAM_RUSER to the invoking user (the "from" user).
     * We set PAM_RHOST to avoid a bug in Solaris 7 and below.
     */
    (void) pam_set_item(pamh, PAM_RUSER, user_name);
    (void) pam_set_item(pamh, PAM_RHOST, user_host);

    /*
     * Some versions of pam_lastlog have a bug that
     * will cause a crash if PAM_TTY is not set so if
     * there is no tty, set PAM_TTY to the empty string.
     */
    if (user_ttypath == NULL)
	(void) pam_set_item(pamh, PAM_TTY, "");
    else
	(void) pam_set_item(pamh, PAM_TTY, user_ttypath);

    return(AUTH_SUCCESS);
}

int
pam_verify(pw, prompt, auth)
    struct passwd *pw;
    char *prompt;
    sudo_auth *auth;
{
    const char *s;
    int *pam_status = (int *) auth->data;

    def_prompt = prompt;	/* for sudo_conv */

    /* PAM_SILENT prevents the authentication service from generating output. */
    *pam_status = pam_authenticate(pamh, PAM_SILENT);
    switch (*pam_status) {
	case PAM_SUCCESS:
	    *pam_status = pam_acct_mgmt(pamh, PAM_SILENT);
	    switch (*pam_status) {
		case PAM_SUCCESS:
		    return(AUTH_SUCCESS);
		case PAM_AUTH_ERR:
		    log_error(NO_EXIT|NO_MAIL, "pam_acct_mgmt: %d",
			*pam_status);
		    return(AUTH_FAILURE);
		case PAM_NEW_AUTHTOK_REQD:
		    log_error(NO_EXIT|NO_MAIL, "%s, %s",
			"Account or password is expired",
			"reset your password and try again");
		    *pam_status = pam_chauthtok(pamh,
			PAM_CHANGE_EXPIRED_AUTHTOK);
		    if (*pam_status == PAM_SUCCESS)
			return(AUTH_SUCCESS);
		    if ((s = pam_strerror(pamh, *pam_status)))
			log_error(NO_EXIT|NO_MAIL, "pam_chauthtok: %s", s);
		    return(AUTH_FAILURE);
		case PAM_AUTHTOK_EXPIRED:
		    log_error(NO_EXIT|NO_MAIL,
			"Password expired, contact your system administrator");
		    return(AUTH_FATAL);
		case PAM_ACCT_EXPIRED:
		    log_error(NO_EXIT|NO_MAIL, "%s %s",
			"Account expired or PAM config lacks an \"account\"",
			"section for sudo, contact your system administrator");
		    return(AUTH_FATAL);
	    }
	    /* FALLTHROUGH */
	case PAM_AUTH_ERR:
	    if (gotintr) {
		/* error or ^C from tgetpass() */
		return(AUTH_INTR);
	    }
	case PAM_MAXTRIES:
	case PAM_PERM_DENIED:
	    return(AUTH_FAILURE);
	default:
	    if ((s = pam_strerror(pamh, *pam_status)))
		log_error(NO_EXIT|NO_MAIL, "pam_authenticate: %s", s);
	    return(AUTH_FATAL);
    }
}

int
pam_cleanup(pw, auth)
    struct passwd *pw;
    sudo_auth *auth;
{
    int *pam_status = (int *) auth->data;

    /* If successful, we can't close the session until pam_prep_user() */
    if (auth->status == AUTH_SUCCESS)
	return(AUTH_SUCCESS);

    *pam_status = pam_end(pamh, *pam_status | PAM_DATA_SILENT);
    return(*pam_status == PAM_SUCCESS ? AUTH_SUCCESS : AUTH_FAILURE);
}

int
pam_prep_user(pw)
    struct passwd *pw;
{
    int eval;

    if (pamh == NULL)
	pam_init(pw, NULL, NULL);

    /*
     * Update PAM_USER to reference the user we are running the command
     * as, as opposed to the user we authenticated as.
     */
    (void) pam_set_item(pamh, PAM_USER, pw->pw_name);

    /*
     * Set credentials (may include resource limits, device ownership, etc).
     * We don't check the return value here because in Linux-PAM 0.75
     * it returns the last saved return code, not the return code
     * for the setcred module.  Because we haven't called pam_authenticate(),
     * this is not set and so pam_setcred() returns PAM_PERM_DENIED.
     * We can't call pam_acct_mgmt() with Linux-PAM for a similar reason.
     */
    (void) pam_setcred(pamh, PAM_ESTABLISH_CRED);

#ifndef NO_PAM_SESSION
    /*
     * To fully utilize PAM sessions we would need to keep a
     * sudo process around until the command exits.  However, we
     * can at least cause pam_limits to be run by opening and then
     * immediately closing the session.
     */
    if ((eval = pam_open_session(pamh, 0)) != PAM_SUCCESS) {
	(void) pam_end(pamh, eval | PAM_DATA_SILENT);
	return(AUTH_FAILURE);
    }
    (void) pam_close_session(pamh, 0);
#endif

    if (pam_end(pamh, PAM_SUCCESS | PAM_DATA_SILENT) == PAM_SUCCESS)
	return(AUTH_SUCCESS);
    else
	return(AUTH_FAILURE);
}

/*
 * ``Conversation function'' for PAM.
 * XXX - does not handle PAM_BINARY_PROMPT
 */
static int
sudo_conv(num_msg, msg, response, appdata_ptr)
    int num_msg;
    PAM_CONST struct pam_message **msg;
    struct pam_response **response;
    void *appdata_ptr;
{
    struct pam_response *pr;
    PAM_CONST struct pam_message *pm;
    const char *prompt;
    char *pass;
    int n, flags, std_prompt;

    if ((*response = calloc(num_msg, sizeof(struct pam_response))) == NULL)
	return(PAM_SYSTEM_ERR);

    for (pr = *response, pm = *msg, n = num_msg; n--; pr++, pm++) {
	flags = tgetpass_flags;
	switch (pm->msg_style) {
	    case PAM_PROMPT_ECHO_ON:
		SET(flags, TGP_ECHO);
	    case PAM_PROMPT_ECHO_OFF:
		prompt = def_prompt;

		/* Is the sudo prompt standard? (If so, we'l just use PAM's) */
		std_prompt =  strncmp(def_prompt, "Password:", 9) == 0 &&
		    (def_prompt[9] == '\0' ||
		    (def_prompt[9] == ' ' && def_prompt[10] == '\0'));

		/* Only override PAM prompt if it matches /^Password: ?/ */
#if defined(PAM_TEXT_DOMAIN) && defined(HAVE_DGETTEXT)
		if (!def_passprompt_override && (std_prompt ||
		    (strcmp(pm->msg, dgettext(PAM_TEXT_DOMAIN, "Password: ")) &&
		    strcmp(pm->msg, dgettext(PAM_TEXT_DOMAIN, "Password:")))))
		    prompt = pm->msg;
#else
		if (!def_passprompt_override && (std_prompt ||
		    strncmp(pm->msg, "Password:", 9) || (pm->msg[9] != '\0'
		    && (pm->msg[9] != ' ' || pm->msg[10] != '\0'))))
		    prompt = pm->msg;
#endif
		/* Read the password unless interrupted. */
		pass = tgetpass(prompt, def_passwd_timeout * 60, flags);
		if (pass == NULL) {
		    /* We got ^C instead of a password; abort quickly. */
		    if (errno == EINTR)
			gotintr = 1;
#if defined(__darwin__) || defined(__APPLE__)
		    pass = "";
#else
		    goto err;
#endif
		}
		pr->resp = estrdup(pass);
		zero_bytes(pass, strlen(pass));
		break;
	    case PAM_TEXT_INFO:
		if (pm->msg)
		    (void) puts(pm->msg);
		break;
	    case PAM_ERROR_MSG:
		if (pm->msg) {
		    (void) fputs(pm->msg, stderr);
		    (void) fputc('\n', stderr);
		}
		break;
	    default:
		goto err;
	}
    }

    return(PAM_SUCCESS);

err:
    /* Zero and free allocated memory and return an error. */
    for (pr = *response, n = num_msg; n--; pr++) {
	if (pr->resp != NULL) {
	    zero_bytes(pr->resp, strlen(pr->resp));
	    free(pr->resp);
	    pr->resp = NULL;
	}
    }
    zero_bytes(*response, num_msg * sizeof(struct pam_response));
    free(*response);
    *response = NULL;
    return(gotintr ? PAM_AUTH_ERR : PAM_CONV_ERR);
}
@


1.25
log
@Use calloc() instead of malloc(n * s) followed by memset().  Not
actually used on OpenBSD but changed to avoid false positives in
audits.  From Jean-Philippe Ouellet.
@
text
@@


1.24
log
@Update to sudo 1.7.2p7
@
text
@d263 1
a263 1
    if ((*response = malloc(num_msg * sizeof(struct pam_response))) == NULL)
a264 1
    zero_bytes(*response, num_msg * sizeof(struct pam_response));
@


1.23
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@d69 2
a70 1
#if defined(_OPENPAM) || defined(__LIBPAM_VERSION) || defined(__LINUX_PAM__)
@


1.22
log
@update to sudo 1.7.2p2
@
text
@a74 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.69 2009/08/07 14:21:51 millert Exp $";
#endif /* lint */

@


1.21
log
@Upgrade to sudo 1.7.2
@
text
@d76 1
a76 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.68 2009/05/25 12:02:42 millert Exp $";
d108 8
d214 2
a215 3
     * Set PAM_USER to the user we are changing *to* and
     * set PAM_RUSER to the user we are coming *from*.
     * We set PAM_RHOST to avoid a bug in Solaris 7 and below.
a217 2
    (void) pam_set_item(pamh, PAM_RUSER, user_name);
    (void) pam_set_item(pamh, PAM_RHOST, user_host);
@


1.20
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005, 2007-2008 Todd C. Miller <Todd.Miller@@courtesan.com>
d76 1
a76 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.67 2009/02/25 12:21:11 millert Exp $";
@


1.19
log
@Sync some bits with sudo 1.7.0 final.
@
text
@d76 1
a76 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.66 2008/12/09 23:48:19 millert Exp $";
d81 1
a81 1
static char *def_prompt;
@


1.18
log
@Fix typo in sudoers man page (from Markus Lude)
Fix parsing error with lines that only contain a comment char
@
text
@d76 1
a76 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.65 2008/11/22 18:17:44 millert Exp $";
d262 1
a262 1
	return(PAM_CONV_ERR);
d334 1
a334 1
    return(PAM_CONV_ERR);
@


1.17
log
@sync with sudo repo
@
text
@d48 1
d76 1
a76 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.64 2008/11/09 14:13:13 millert Exp $";
d290 1
a290 1
		/* Read the password. */
d294 5
a298 1
		    gotintr = 1;
d300 1
@


1.16
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
d75 1
a75 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.62 2008/02/22 20:19:34 millert Exp $";
d81 1
d166 4
a258 1
    extern int nil_pw;
d293 1
a293 1
		    nil_pw = 1;
d297 1
a297 4
		if (*pr->resp == '\0')
		    nil_pw = 1;		/* empty password */
		else
		    zero_bytes(pass, strlen(pass));
@


1.15
log
@Update to sudo 1.6.9p17
@
text
@d75 1
a75 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.43.2.10 2008/02/22 20:19:45 millert Exp $";
d79 1
a79 1
			  struct pam_response **, VOID *));
d99 1
a99 1
	auth->data = (VOID *) &pam_status;
d247 1
a247 1
    VOID *appdata_ptr;
d269 1
a269 1
		std_prompt = strncmp(def_prompt, "Password:", 9) == 0 &&
@


1.14
log
@update to sudo 1.6.9p9
@
text
@d75 1
a75 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.43.2.9 2007/12/02 17:13:52 millert Exp $";
a259 5
    /* Is the sudo prompt standard? (If so, we'l just use PAM's) */
    std_prompt =  strncmp(def_prompt, "Password:", 9) == 0 &&
	(def_prompt[9] == '\0' ||
	(def_prompt[9] == ' ' && def_prompt[10] == '\0'));

d267 6
@


1.13
log
@Update to sudo 1.6.9p7
@
text
@d55 9
d75 1
a75 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.43.2.7 2007/10/09 00:06:06 millert Exp $";
d251 1
a251 1
    const char *p = def_prompt;
d253 1
a253 1
    int n, flags;
d260 5
d271 1
d273 11
a283 3
		if (strncmp(pm->msg, "Password:", 9) || (pm->msg[9] != '\0'
		    && (pm->msg[9] != ' ' || pm->msg[10] != '\0')))
		    p = pm->msg;
d285 1
a285 1
		pass = tgetpass(p, def_passwd_timeout * 60, flags);
@


1.12
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d66 1
a66 1
__unused static const char rcsid[] = "$Sudo: pam.c,v 1.43.2.4 2007/07/22 12:14:53 millert Exp $";
d102 1
a102 1
    if (strcmp(user_tty, "unknown") == 0)
d105 1
a105 1
	(void) pam_set_item(pamh, PAM_TTY, user_tty);
d193 1
d197 1
d209 1
d221 1
@


1.11
log
@Update to Sudo 1.6.8p7
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d21 1
a21 1
#include "config.h"
d59 1
a59 1
#if defined(_OPENPAM) || defined(__LIBPAM_VERSION)
d66 1
a66 1
static const char rcsid[] = "$Sudo: pam.c,v 1.43 2004/06/28 14:51:50 millert Exp $";
d97 8
a104 1
    if (strcmp(user_tty, "unknown"))
d185 2
d207 12
d259 6
a264 1
		pr->resp = estrdup(pass ? pass : "");
d281 1
a281 12
		/* Zero and free allocated memory and return an error. */
		for (pr = *response, n = num_msg; n--; pr++) {
		    if (pr->resp != NULL) {
			zero_bytes(pr->resp, strlen(pr->resp));
			free(pr->resp);
			pr->resp = NULL;
		    }
		}
		zero_bytes(*response, num_msg * sizeof(struct pam_response));
		free(*response);
		*response = NULL;
		return(PAM_CONV_ERR);
d286 14
@


1.10
log
@Update to sudo 1.6.8p1
@
text
@d94 1
a94 2
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL,
	    "unable to initialize PAM");
d127 1
a127 1
		    log_error(NO_EXIT|NO_MAIL, "%s, %s"
d130 2
a131 1
		    *pam_status = pam_chauthtok(pamh, PAM_CHANGE_EXPIRED_AUTHTOK);
d135 1
a135 1
			log_error(NO_EXIT|NO_MAIL, "pam_chauthtok: %s",s);
d137 4
d142 4
a145 6
		    log_error(NO_EXIT|NO_MAIL, "%s, %s"
			"Account or password is expired",
			"contact your system administrator");
		    /* FALLTHROUGH */
		default:
		    return(AUTH_FAILURE);
d147 1
d150 1
@


1.9
log
@Get rid of volatile variables that were a vain attempt to prevent the
compiler from optimizing away memset() calls.  Instead, add a new function,
zero_bytes(), to clear buffers with sensitive contents.
Taken from the sudo cvs repo, man.
@
text
@d2 1
a2 2
 * Copyright (c) 1999-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 11
a14 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d49 5
a53 1
#include <security/pam_appl.h>
d58 7
d66 1
a66 1
static const char rcsid[] = "$Sudo: pam.c,v 1.33 2003/04/16 00:42:10 millert Exp $";
d77 2
d86 1
a86 1
    pam_handle_t *pamh;
d89 2
d92 3
a94 2
    if (pam_start("sudo", pw->pw_name, &pam_conv, &pamh) != PAM_SUCCESS) {
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL, 
a100 1
    auth->data = (VOID *) pamh;
a109 1
    int error;
d111 1
a111 1
    pam_handle_t *pamh = (pam_handle_t *) auth->data;
d116 2
a117 2
    error = pam_authenticate(pamh, PAM_SILENT);
    switch (error) {
d119 26
a144 1
	    return(AUTH_SUCCESS);
d149 1
a149 1
	    if ((s = pam_strerror(pamh, error)))
d160 1
a160 2
    pam_handle_t *pamh = (pam_handle_t *) auth->data;
    int status = PAM_DATA_SILENT;
d162 3
a164 14
    /* Convert AUTH_FOO -> PAM_FOO as best we can. */
    /* XXX - store real value somewhere in auth->data and use it */
    switch (auth->status) {
	case AUTH_SUCCESS:
	    status |= PAM_SUCCESS;
	    break;
	case AUTH_FAILURE:
	    status |= PAM_AUTH_ERR;
	    break;
	case AUTH_FATAL:
	default:
	    status |= PAM_ABORT;
	    break;
    }
d166 2
a167 4
    if (pam_end(pamh, status) == PAM_SUCCESS)
	return(AUTH_SUCCESS);
    else
	return(AUTH_FAILURE);
d174 2
a175 2
    struct pam_conv pam_conv;
    pam_handle_t *pamh;
d177 5
a181 7
    /* We need to setup a new PAM session for the user we are changing *to*. */
    pam_conv.conv = sudo_conv;
    if (pam_start("sudo", pw->pw_name, &pam_conv, &pamh) != PAM_SUCCESS) {
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL, 
	    "unable to initialize PAM");
	return(AUTH_FATAL);
    }
a182 2
    if (strcmp(user_tty, "unknown"))
	(void) pam_set_item(pamh, PAM_TTY, user_tty);
d194 2
a195 2
    if (pam_end(pamh, PAM_SUCCESS) == PAM_SUCCESS)
	return(PAM_SUCCESS);
d226 1
a226 1
		flags |= TGP_ECHO;
d233 1
a233 1
		pass = tgetpass(p, def_ival(I_PASSWD_TIMEOUT) * 60, flags);
@


1.8
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d208 1
a208 1
    volatile struct pam_response *pr;
d211 1
a211 1
    volatile char *pass;
d217 1
a217 1
    (void) memset(*response, 0, num_msg * sizeof(struct pam_response));
d235 1
a235 1
		    memset(pass, 0, strlen(pass));
d251 1
a251 1
			(void) memset(pr->resp, 0, strlen(pr->resp));
d256 1
a256 2
		(void) memset(*response, 0,
		    num_msg * sizeof(struct pam_response));
@


1.7
log
@update to what will soon be sudo 1.6.7
@
text
@d33 4
d73 1
a73 1
static const char rcsid[] = "$Sudo: pam.c,v 1.32 2003/03/15 20:37:44 millert Exp $";
@


1.6
log
@update to sudo 1.6.5p2
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d69 1
a69 1
static const char rcsid[] = "$Sudo: pam.c,v 1.29 2002/01/22 16:43:23 millert Exp $";
d204 1
a204 1
    struct pam_response *pr;
d207 2
a208 2
    char *pass;
    int n;
d216 1
d219 1
a219 1
		tgetpass_flags |= TGP_ECHO;
d226 1
a226 2
		pass = tgetpass(p, def_ival(I_PASSWD_TIMEOUT) * 60,
		    tgetpass_flags);
@


1.5
log
@Update to sudo 1.6.4
@
text
@d69 1
a69 1
static const char rcsid[] = "$Sudo: pam.c,v 1.23 2001/12/31 17:18:12 millert Exp $";
a164 2
    const char *s;
    int error;
d177 9
a185 5
    /* Set credentials (may include resource limits, device ownership, etc). */
    if ((error = pam_setcred(pamh, PAM_ESTABLISH_CRED)) != PAM_SUCCESS) {
	if ((s = pam_strerror(pamh, error)))
	    log_error(NO_EXIT|NO_MAIL, "pam_setcred: %s", s);
    }
d187 3
a189 1
    if (pam_end(pamh, error) != PAM_SUCCESS)
a190 2

    return(error == PAM_SUCCESS ? AUTH_SUCCESS : AUTH_FAILURE);
d195 1
d207 2
d213 1
a213 1
    (void) memset((VOID *)*response, 0, num_msg * sizeof(struct pam_response));
d215 1
a215 1
    for (pr = *response, pm = *msg; num_msg--; pr++, pm++) {
d225 4
a228 3
		pr->resp = estrdup((char *) tgetpass(p,
		    def_ival(I_PASSWD_TIMEOUT) * 60, tgetpass_flags));
		if (pr->resp == NULL || *pr->resp == '\0')
d230 2
d244 10
a253 2
		/* Something odd happened */
		/* XXX - should free non-NULL response members */
a256 1
		break;
@


1.4
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 2
d41 6
a46 1
#include <stdlib.h>
d48 10
d59 1
a59 1
#include <unistd.h>
a60 8
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <sys/param.h>
#include <sys/types.h>
d69 1
a69 1
static const char rcsid[] = "$Sudo: pam.c,v 1.15 2000/02/27 03:49:06 millert Exp $";
d76 4
d96 3
d115 12
a126 9
    /* PAM_SILENT prevents error messages from going to syslog(3) */
    if ((error = pam_authenticate(pamh, PAM_SILENT)) == PAM_SUCCESS)
	return(AUTH_SUCCESS);

    /* Any error other than PAM_AUTH_ERR or PAM_MAXTRIES is probably fatal.  */
    if (error != PAM_AUTH_ERR && error != PAM_MAXTRIES) {
	if ((s = pam_strerror(pamh, error)))
	    log_error(NO_EXIT|NO_MAIL, "pam_authenticate: %s\n", s);
	return(AUTH_FATAL);
a127 1
    return(AUTH_FAILURE);
d136 1
d138 16
a153 1
    if (pam_end(pamh, (auth->status == AUTH_SUCCESS)) == PAM_SUCCESS)
d159 32
d221 2
a222 2
		    def_ival(I_PW_TIMEOUT) * 60, tgetpass_flags));
		if (*pr->resp == '\0')
@


1.4.6.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d60 1
a60 1
static const char rcsid[] = "$Sudo: pam.c,v 1.23 2001/12/31 17:18:12 millert Exp $";
a66 4
#ifndef PAM_DATA_SILENT
#define PAM_DATA_SILENT	0
#endif

a82 3
    if (strcmp(user_tty, "unknown"))
	(void) pam_set_item(pamh, PAM_TTY, user_tty);

d99 9
a107 12
    /* PAM_SILENT prevents the authentication service from generating output. */
    error = pam_authenticate(pamh, PAM_SILENT);
    switch (error) {
	case PAM_SUCCESS:
	    return(AUTH_SUCCESS);
	case PAM_AUTH_ERR:
	case PAM_MAXTRIES:
	    return(AUTH_FAILURE);
	default:
	    if ((s = pam_strerror(pamh, error)))
		log_error(NO_EXIT|NO_MAIL, "pam_authenticate: %s", s);
	    return(AUTH_FATAL);
d109 1
a117 1
    int status = PAM_DATA_SILENT;
d119 1
a119 16
    /* Convert AUTH_FOO -> PAM_FOO as best we can. */
    /* XXX - store real value somewhere in auth->data and use it */
    switch (auth->status) {
	case AUTH_SUCCESS:
	    status |= PAM_SUCCESS;
	    break;
	case AUTH_FAILURE:
	    status |= PAM_AUTH_ERR;
	    break;
	case AUTH_FATAL:
	default:
	    status |= PAM_ABORT;
	    break;
    }

    if (pam_end(pamh, status) == PAM_SUCCESS)
a124 32
int
pam_prep_user(pw)
    struct passwd *pw;
{
    struct pam_conv pam_conv;
    pam_handle_t *pamh;
    const char *s;
    int error;

    /* We need to setup a new PAM session for the user we are changing *to*. */
    pam_conv.conv = sudo_conv;
    if (pam_start("sudo", pw->pw_name, &pam_conv, &pamh) != PAM_SUCCESS) {
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL, 
	    "unable to initialize PAM");
	return(AUTH_FATAL);
    }
    (void) pam_set_item(pamh, PAM_RUSER, user_name);
    if (strcmp(user_tty, "unknown"))
	(void) pam_set_item(pamh, PAM_TTY, user_tty);

    /* Set credentials (may include resource limits, device ownership, etc). */
    if ((error = pam_setcred(pamh, PAM_ESTABLISH_CRED)) != PAM_SUCCESS) {
	if ((s = pam_strerror(pamh, error)))
	    log_error(NO_EXIT|NO_MAIL, "pam_setcred: %s", s);
    }

    if (pam_end(pamh, error) != PAM_SUCCESS)
	return(AUTH_FAILURE);

    return(error == PAM_SUCCESS ? AUTH_SUCCESS : AUTH_FAILURE);
}

d155 2
a156 2
		    def_ival(I_PASSWD_TIMEOUT) * 60, tgetpass_flags));
		if (pr->resp == NULL || *pr->resp == '\0')
@


1.4.8.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d60 1
a60 1
static const char rcsid[] = "$Sudo: pam.c,v 1.23 2001/12/31 17:18:12 millert Exp $";
a66 4
#ifndef PAM_DATA_SILENT
#define PAM_DATA_SILENT	0
#endif

a82 3
    if (strcmp(user_tty, "unknown"))
	(void) pam_set_item(pamh, PAM_TTY, user_tty);

d99 9
a107 12
    /* PAM_SILENT prevents the authentication service from generating output. */
    error = pam_authenticate(pamh, PAM_SILENT);
    switch (error) {
	case PAM_SUCCESS:
	    return(AUTH_SUCCESS);
	case PAM_AUTH_ERR:
	case PAM_MAXTRIES:
	    return(AUTH_FAILURE);
	default:
	    if ((s = pam_strerror(pamh, error)))
		log_error(NO_EXIT|NO_MAIL, "pam_authenticate: %s", s);
	    return(AUTH_FATAL);
d109 1
a117 1
    int status = PAM_DATA_SILENT;
d119 1
a119 16
    /* Convert AUTH_FOO -> PAM_FOO as best we can. */
    /* XXX - store real value somewhere in auth->data and use it */
    switch (auth->status) {
	case AUTH_SUCCESS:
	    status |= PAM_SUCCESS;
	    break;
	case AUTH_FAILURE:
	    status |= PAM_AUTH_ERR;
	    break;
	case AUTH_FATAL:
	default:
	    status |= PAM_ABORT;
	    break;
    }

    if (pam_end(pamh, status) == PAM_SUCCESS)
a124 32
int
pam_prep_user(pw)
    struct passwd *pw;
{
    struct pam_conv pam_conv;
    pam_handle_t *pamh;
    const char *s;
    int error;

    /* We need to setup a new PAM session for the user we are changing *to*. */
    pam_conv.conv = sudo_conv;
    if (pam_start("sudo", pw->pw_name, &pam_conv, &pamh) != PAM_SUCCESS) {
	log_error(USE_ERRNO|NO_EXIT|NO_MAIL, 
	    "unable to initialize PAM");
	return(AUTH_FATAL);
    }
    (void) pam_set_item(pamh, PAM_RUSER, user_name);
    if (strcmp(user_tty, "unknown"))
	(void) pam_set_item(pamh, PAM_TTY, user_tty);

    /* Set credentials (may include resource limits, device ownership, etc). */
    if ((error = pam_setcred(pamh, PAM_ESTABLISH_CRED)) != PAM_SUCCESS) {
	if ((s = pam_strerror(pamh, error)))
	    log_error(NO_EXIT|NO_MAIL, "pam_setcred: %s", s);
    }

    if (pam_end(pamh, error) != PAM_SUCCESS)
	return(AUTH_FAILURE);

    return(error == PAM_SUCCESS ? AUTH_SUCCESS : AUTH_FAILURE);
}

d155 2
a156 2
		    def_ival(I_PASSWD_TIMEOUT) * 60, tgetpass_flags));
		if (pr->resp == NULL || *pr->resp == '\0')
@


1.3
log
@sudo 1.6.2
@
text
@d60 1
a60 1
static const char rcsid[] = "$Sudo: pam.c,v 1.14 2000/01/24 03:23:40 millert Exp $";
a137 1
    int echo = 0;
d147 1
a147 1
		echo = 1;
d155 1
a155 1
		    def_ival(I_PW_TIMEOUT) * 60, !echo));
@


1.2
log
@sudo 1.6.1
@
text
@d60 1
a60 1
static const char rcsid[] = "$Sudo: pam.c,v 1.12 1999/11/23 18:27:00 millert Exp $";
d103 4
a106 3
    /* Any error other than PAM_PERM_DENIED may indicate a config problem. */
    if (error != PAM_PERM_DENIED && (s = pam_strerror(pamh, error))) {
	log_error(NO_EXIT|NO_MAIL, "pam_authenticate: %s\n", s);
d137 1
a137 1
    char *p = def_prompt;
d150 5
a154 3
		/* Override default prompt for unix auth */
		if (strcmp(p, "Password: ") && strcmp(p, "Password:"))
		    p = (char *) pm->msg;
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
static const char rcsid[] = "$Sudo: pam.c,v 1.10 1999/10/07 21:21:07 millert Exp $";
d93 2
d100 1
a100 1
    if (pam_authenticate(pamh, PAM_SILENT) == PAM_SUCCESS)
d102 7
a108 2
    else
	return(AUTH_FAILURE);
d135 1
a135 1
    struct pam_message *pm;
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
