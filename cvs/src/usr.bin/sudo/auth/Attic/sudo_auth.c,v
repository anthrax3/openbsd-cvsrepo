head	1.16;
access;
symbols
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.22
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.20
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.6
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.15;
commitid	8ra5qnWqy2bUhcZn;

1.15
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.21.14.48.42;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.11.11.48.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.22.16.33.42;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.05.00.23.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.05.14.01.16;	author millert;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2000.03.27.03.44.39;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.06.45.12;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches;
next	;

1.4.4.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.4.6.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1999-2005, 2008-2009 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <time.h>
#include <signal.h>

#include "sudo.h"
#include "sudo_auth.h"
#include "insults.h"

sudo_auth auth_switch[] = {
#ifdef AUTH_STANDALONE
    AUTH_STANDALONE
#else
#  ifndef WITHOUT_PASSWD
    AUTH_ENTRY(0, "passwd", passwd_init, NULL, passwd_verify, NULL)
#  endif
#  if defined(HAVE_GETPRPWNAM) && !defined(WITHOUT_PASSWD)
    AUTH_ENTRY(0, "secureware", secureware_init, NULL, secureware_verify, NULL)
#  endif
#  ifdef HAVE_AFS
    AUTH_ENTRY(0, "afs", NULL, NULL, afs_verify, NULL)
#  endif
#  ifdef HAVE_DCE
    AUTH_ENTRY(0, "dce", NULL, NULL, dce_verify, NULL)
#  endif
#  ifdef HAVE_KERB4
    AUTH_ENTRY(0, "kerb4", kerb4_init, NULL, kerb4_verify, NULL)
#  endif
#  ifdef HAVE_KERB5
    AUTH_ENTRY(0, "kerb5", kerb5_init, NULL, kerb5_verify, kerb5_cleanup)
#  endif
#  ifdef HAVE_SKEY
    AUTH_ENTRY(0, "S/Key", NULL, rfc1938_setup, rfc1938_verify, NULL)
#  endif
#  ifdef HAVE_OPIE
    AUTH_ENTRY(0, "OPIE", NULL, rfc1938_setup, rfc1938_verify, NULL)
#  endif
#endif /* AUTH_STANDALONE */
    AUTH_ENTRY(0, NULL, NULL, NULL, NULL, NULL)
};

void
verify_user(pw, prompt)
    struct passwd *pw;
    char *prompt;
{
    int counter = def_passwd_tries + 1;
    int success = AUTH_FAILURE;
    int status;
    int flags;
    char *p;
    sudo_auth *auth;
    sigaction_t sa, osa;
#ifdef HAVE_BSM_AUDIT
    extern char **NewArgv;
#endif

    /* Enable suspend during password entry. */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &osa);

    /* Make sure we have at least one auth method. */
    if (auth_switch[0].name == NULL) {
#ifdef HAVE_BSM_AUDIT
	audit_failure(NewArgv, "no authentication methods");
#endif
    	log_error(0, "%s  %s %s",
	    "There are no authentication methods compiled into sudo!",
	    "If you want to turn off authentication, use the",
	    "--disable-authentication configure option.");
    }

    /* Set FLAG_ONEANDONLY if there is only one auth method. */
    if (auth_switch[1].name == NULL)
	SET(auth_switch[0].flags, FLAG_ONEANDONLY);

    /* Initialize auth methods and unconfigure the method if necessary. */
    for (auth = auth_switch; auth->name; auth++) {
	if (auth->init && IS_CONFIGURED(auth)) {
	    if (NEEDS_USER(auth))
		set_perms(PERM_USER);

	    status = (auth->init)(pw, &prompt, auth);
	    if (status == AUTH_FAILURE)
		CLR(auth->flags, FLAG_CONFIGURED);
	    else if (status == AUTH_FATAL) {	/* XXX log */
#ifdef HAVE_BSM_AUDIT
		audit_failure(NewArgv, "authentication failure");
#endif
		exit(1);		/* assume error msg already printed */
	    }

	    if (NEEDS_USER(auth))
		set_perms(PERM_ROOT);
	}
    }

    while (--counter) {
	/* Do any per-method setup and unconfigure the method if needed */
	for (auth = auth_switch; auth->name; auth++) {
	    if (auth->setup && IS_CONFIGURED(auth)) {
		if (NEEDS_USER(auth))
		    set_perms(PERM_USER);

		status = (auth->setup)(pw, &prompt, auth);
		if (status == AUTH_FAILURE)
		    CLR(auth->flags, FLAG_CONFIGURED);
		else if (status == AUTH_FATAL) {/* XXX log */
#ifdef HAVE_BSM_AUDIT
		    audit_failure(NewArgv, "authentication failure");
#endif
		    exit(1);		/* assume error msg already printed */
		}

		if (NEEDS_USER(auth))
		    set_perms(PERM_ROOT);
	    }
	}

	/* Get the password unless the auth function will do it for us */
#ifdef AUTH_STANDALONE
	p = prompt;
#else
	p = (char *) tgetpass(prompt, def_passwd_timeout * 60,
	    tgetpass_flags);
#endif /* AUTH_STANDALONE */

	/* Call authentication functions. */
	for (auth = auth_switch; p && auth->name; auth++) {
	    if (!IS_CONFIGURED(auth))
		continue;

	    if (NEEDS_USER(auth))
		set_perms(PERM_USER);

	    success = auth->status = (auth->verify)(pw, (char *)p, auth);

	    if (NEEDS_USER(auth))
		set_perms(PERM_ROOT);

	    if (auth->status != AUTH_FAILURE)
		goto cleanup;
	}
#ifndef AUTH_STANDALONE
	if (p)
	    zero_bytes(p, strlen(p));
#endif
	if (!ISSET(tgetpass_flags, TGP_ASKPASS))
	    pass_warn(stderr);
    }

cleanup:
    /* Call cleanup routines. */
    for (auth = auth_switch; auth->name; auth++) {
	if (auth->cleanup && IS_CONFIGURED(auth)) {
	    if (NEEDS_USER(auth))
		set_perms(PERM_USER);

	    status = (auth->cleanup)(pw, auth);
	    if (status == AUTH_FATAL) {	/* XXX log */
#ifdef HAVE_BSM_AUDIT
		audit_failure(NewArgv, "authentication failure");
#endif
		exit(1);		/* assume error msg already printed */
	    }

	    if (NEEDS_USER(auth))
		set_perms(PERM_ROOT);
	}
    }

    switch (success) {
	case AUTH_SUCCESS:
	    (void) sigaction(SIGTSTP, &osa, NULL);
	    return;
	case AUTH_INTR:
	case AUTH_FAILURE:
	    if (counter != def_passwd_tries) {
		if (def_mail_badpass || def_mail_always)
		    flags = 0;
		else
		    flags = NO_MAIL;
#ifdef HAVE_BSM_AUDIT
		audit_failure(NewArgv, "authentication failure");
#endif
		log_error(flags, "%d incorrect password attempt%s",
		    def_passwd_tries - counter,
		    (def_passwd_tries - counter == 1) ? "" : "s");
	    }
	    /* FALLTHROUGH */
	case AUTH_FATAL:
#ifdef HAVE_BSM_AUDIT
	    audit_failure(NewArgv, "authentication failure");
#endif
	    exit(1);
    }
    /* NOTREACHED */
}

void
pass_warn(fp)
    FILE *fp;
{

#ifdef INSULT
    if (def_insults)
	(void) fprintf(fp, "%s\n", INSULT);
    else
#endif
	(void) fprintf(fp, "%s\n", def_badpass_message);
}

void
dump_auth_methods()
{
    sudo_auth *auth;

    (void) fputs("Authentication methods:", stdout);
    for (auth = auth_switch; auth->name; auth++)
        (void) printf(" '%s'", auth->name);
    (void) putchar('\n');
}
@


1.15
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@@


1.14
log
@Upgrade to sudo 1.7.2
@
text
@a54 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.40 2009/05/25 12:02:42 millert Exp $";
#endif /* lint */

@


1.13
log
@Update to sudo 1.7.1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005, 2008 Todd C. Miller <Todd.Miller@@courtesan.com>
d56 1
a56 1
__unused static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.39 2009/02/11 01:18:02 millert Exp $";
@


1.12
log
@sync with sudo repo
@
text
@d56 1
a56 1
__unused static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.38 2008/11/07 17:45:52 millert Exp $";
d103 3
d114 4
a117 1
    if (auth_switch[0].name == NULL)
d122 1
d137 4
a140 1
	    else if (status == AUTH_FATAL)	/* XXX log */
d142 1
d159 4
a162 1
		else if (status == AUTH_FATAL)	/* XXX log */
d164 1
d211 4
a214 1
	    if (status == AUTH_FATAL)	/* XXX log */
d216 1
d234 3
d243 3
@


1.11
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d56 1
a56 1
__unused static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.37 2008/03/02 14:31:57 millert Exp $";
a90 2
int nil_pw;		/* I hate resorting to globals like this... */

a156 1
	nil_pw = 0;
a161 2
	if (!p || *p == '\0')
	    nil_pw = 1;
a183 9

	/* Exit loop on nil password, but give it a chance to match first. */
	if (nil_pw) {
	    if (counter == def_passwd_tries)
		exit(1);
	    else
		break;
	}

d208 1
d210 10
a219 7
	    if (def_mail_badpass || def_mail_always)
		flags = 0;
	    else
		flags = NO_MAIL;
	    log_error(flags, "%d incorrect password attempt%s",
		def_passwd_tries - counter,
		(def_passwd_tries - counter == 1) ? "" : "s");
@


1.10
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
d56 1
a56 1
__unused static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.33.2.2 2007/06/12 01:28:42 millert Exp $";
d198 2
a199 1
	pass_warn(stderr);
@


1.9
log
@Update to sudo 1.6.8p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d21 1
a21 1
#include "config.h"
d56 1
a56 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.33 2004/02/13 21:36:47 millert Exp $";
@


1.8
log
@Get rid of volatile variables that were a vain attempt to prevent the
compiler from optimizing away memset() calls.  Instead, add a new function,
zero_bytes(), to clear buffers with sensitive contents.
Taken from the sudo cvs repo, man.
@
text
@a2 1
 * All rights reserved.
d4 11
a14 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d56 1
a56 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.29 2003/04/16 00:42:10 millert Exp $";
d98 1
a98 1
    int counter = def_ival(I_PASSWD_TRIES) + 1;
d121 1
a121 1
	auth_switch[0].flags |= FLAG_ONEANDONLY;
d131 1
a131 1
		auth->flags &= ~FLAG_CONFIGURED;
d149 1
a149 1
		    auth->flags &= ~FLAG_CONFIGURED;
d163 1
a163 1
	p = (char *) tgetpass(prompt, def_ival(I_PASSWD_TIMEOUT) * 60,
d192 1
a192 1
	    if (counter == def_ival(I_PASSWD_TRIES))
d222 1
a222 1
	    if (def_flag(I_MAIL_BADPASS) || def_flag(I_MAIL_ALWAYS))
d227 2
a228 2
		def_ival(I_PASSWD_TRIES) - counter,
		(def_ival(I_PASSWD_TRIES) - counter == 1) ? "" : "s");
d241 1
a241 1
    if (def_flag(I_INSULTS))
d245 1
a245 1
	(void) fprintf(fp, "%s\n", def_str(I_BADPASS_MESSAGE));
@


1.7
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d120 1
a120 1
    volatile char *p;
d205 1
a205 1
	    (void) memset(p, 0, strlen(p));
@


1.6
log
@update to what will soon be sudo 1.6.7
@
text
@d33 4
d74 1
a74 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.28 2003/03/15 20:37:44 millert Exp $";
@


1.5
log
@Update to sudo 1.6.4
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d70 1
a70 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.25 2001/12/14 19:52:54 millert Exp $";
d116 1
a116 1
    char *p;
d141 1
a141 1
		set_perms(PERM_USER, 0);
d150 1
a150 1
		set_perms(PERM_ROOT, 0);
d159 1
a159 1
		    set_perms(PERM_USER, 0);
d168 1
a168 1
		    set_perms(PERM_ROOT, 0);
d189 1
a189 1
		set_perms(PERM_USER, 0);
d191 1
a191 1
	    success = auth->status = (auth->verify)(pw, p, auth);
d194 1
a194 1
		set_perms(PERM_ROOT, 0);
d220 1
a220 1
		set_perms(PERM_USER, 0);
d227 1
a227 1
		set_perms(PERM_ROOT, 0);
@


1.4
log
@Update to sudo 1.6.3p4
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d37 2
d41 6
a46 1
#include <stdlib.h>
d48 10
d59 1
a59 1
#include <unistd.h>
a60 8
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <sys/param.h>
#include <sys/types.h>
d63 1
d70 1
a70 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.19 2000/03/06 19:42:21 millert Exp $";
d78 1
a78 1
    AUTH_ENTRY(0, "passwd", NULL, NULL, passwd_verify, NULL)
d112 4
a115 3
    short counter = def_ival(I_PW_TRIES) + 1;
    short success = AUTH_FAILURE;
    short status;
d118 7
d177 1
a177 1
	p = (char *) tgetpass(prompt, def_ival(I_PW_TIMEOUT) * 60,
d184 1
a184 1
	for (auth = auth_switch; auth->name; auth++) {
d200 2
a201 1
	(void) memset(p, 0, strlen(p));
d206 1
a206 1
	    if (counter == def_ival(I_PW_TRIES))
d233 1
d236 7
a242 3
	    log_error(NO_MAIL, "%d incorrect password attempt%s",
		def_ival(I_PW_TRIES) - counter,
		(def_ival(I_PW_TRIES) - counter == 1) ? "" : "s");
d246 1
d259 1
a259 1
	(void) fprintf(fp, "%s\n", def_str(I_BADPASS_MSG));
@


1.4.4.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
a53 1
#include <signal.h>
d60 1
a60 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.25 2001/12/14 19:52:54 millert Exp $";
d68 1
a68 1
    AUTH_ENTRY(0, "passwd", passwd_init, NULL, passwd_verify, NULL)
d102 3
a104 4
    int counter = def_ival(I_PASSWD_TRIES) + 1;
    int success = AUTH_FAILURE;
    int status;
    int flags;
a106 7
    sigaction_t sa, osa;

    /* Enable suspend during password entry. */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &osa);
d159 1
a159 1
	p = (char *) tgetpass(prompt, def_ival(I_PASSWD_TIMEOUT) * 60,
d166 1
a166 1
	for (auth = auth_switch; p && auth->name; auth++) {
d182 1
a182 2
	if (p)
	    (void) memset(p, 0, strlen(p));
d187 1
a187 1
	    if (counter == def_ival(I_PASSWD_TRIES))
a213 1
	    (void) sigaction(SIGTSTP, &osa, NULL);
d216 3
a218 7
	    if (def_flag(I_MAIL_BADPASS) || def_flag(I_MAIL_ALWAYS))
		flags = 0;
	    else
		flags = NO_MAIL;
	    log_error(flags, "%d incorrect password attempt%s",
		def_ival(I_PASSWD_TRIES) - counter,
		(def_ival(I_PASSWD_TRIES) - counter == 1) ? "" : "s");
a221 1
    /* NOTREACHED */
d234 1
a234 1
	(void) fprintf(fp, "%s\n", def_str(I_BADPASS_MESSAGE));
@


1.4.6.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a36 2
#include <sys/types.h>
#include <sys/param.h>
d39 1
a39 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d41 3
d45 1
a45 8
# if defined(HAVE_MEMORY_H) && !defined(STDC_HEADERS)
#  include <memory.h>
# endif
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d47 5
a51 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
a53 1
#include <signal.h>
d60 1
a60 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.25 2001/12/14 19:52:54 millert Exp $";
d68 1
a68 1
    AUTH_ENTRY(0, "passwd", passwd_init, NULL, passwd_verify, NULL)
d102 3
a104 4
    int counter = def_ival(I_PASSWD_TRIES) + 1;
    int success = AUTH_FAILURE;
    int status;
    int flags;
a106 7
    sigaction_t sa, osa;

    /* Enable suspend during password entry. */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = SIG_DFL;
    (void) sigaction(SIGTSTP, &sa, &osa);
d159 1
a159 1
	p = (char *) tgetpass(prompt, def_ival(I_PASSWD_TIMEOUT) * 60,
d166 1
a166 1
	for (auth = auth_switch; p && auth->name; auth++) {
d182 1
a182 2
	if (p)
	    (void) memset(p, 0, strlen(p));
d187 1
a187 1
	    if (counter == def_ival(I_PASSWD_TRIES))
a213 1
	    (void) sigaction(SIGTSTP, &osa, NULL);
d216 3
a218 7
	    if (def_flag(I_MAIL_BADPASS) || def_flag(I_MAIL_ALWAYS))
		flags = 0;
	    else
		flags = NO_MAIL;
	    log_error(flags, "%d incorrect password attempt%s",
		def_ival(I_PASSWD_TRIES) - counter,
		(def_ival(I_PASSWD_TRIES) - counter == 1) ? "" : "s");
a221 1
    /* NOTREACHED */
d234 1
a234 1
	(void) fprintf(fp, "%s\n", def_str(I_BADPASS_MESSAGE));
@


1.3
log
@sudo 1.6.3; see http://www.courtesan.com/sudo/current.html for a list
of changes.
@
text
@d98 2
a99 1
verify_user(prompt)
d125 1
a125 1
	    status = (auth->init)(sudo_user.pw, &prompt, auth);
d143 1
a143 1
		status = (auth->setup)(sudo_user.pw, &prompt, auth);
d173 1
a173 1
	    success = auth->status = (auth->verify)(sudo_user.pw, p, auth);
d203 1
a203 1
	    status = (auth->cleanup)(sudo_user.pw, auth);
@


1.2
log
@sudo 1.6.1
@
text
@d60 1
a60 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.17 1999/12/06 06:47:19 millert Exp $";
d70 1
a70 1
#  if defined(HAVE_SECUREWARE) && !defined(WITHOUT_PASSWD)
d158 2
a159 1
	p = (char *) tgetpass(prompt, def_ival(I_PW_TIMEOUT) * 60, 1);
@


1.1
log
@Initial revision
@
text
@d60 1
a60 1
static const char rcsid[] = "$Sudo: sudo_auth.c,v 1.15 1999/10/13 02:34:55 millert Exp $";
d227 6
a232 5
#ifdef USE_INSULTS
    (void) fprintf(fp, "%s\n", INSULT);
#else
    (void) fprintf(fp, "%s\n", def_str(I_BADPASS_MSG));
#endif /* USE_INSULTS */
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@
