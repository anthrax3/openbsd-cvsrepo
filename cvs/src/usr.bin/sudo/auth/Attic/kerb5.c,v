head	1.17;
access;
symbols
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.22
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.20
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.16
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	SUDO_1_6_0:1.1.1.1
	COURTESAN:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.07.03.21.51.54;	author millert;	state dead;
branches;
next	1.16;
commitid	8ra5qnWqy2bUhcZn;

1.16
date	2010.03.04.12.21.36;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.07.18.43.11;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.22.16.33.42;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.14.11.58.08;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.31.16.44.04;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.21.19.44.29;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.26.16.10.16;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.31.21.13.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.09.28.15.10.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.08.20.55.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.19.21.57.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.07.03.31.10;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.03.19.15.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.15.21.23.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.03.03.49.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.18.16.29.01;	author millert;	state Exp;
branches
	1.1.1.1.6.1
	1.1.1.1.8.1;
next	;

1.1.1.1.6.1
date	2002.01.18.17.20.23;	author millert;	state Exp;
branches;
next	;

1.1.1.1.8.1
date	2002.01.18.16.14.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Remove sudo, it is now in ports.
@
text
@/*
 * Copyright (c) 1999-2005, 2007-2008 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

#include <config.h>

#include <sys/types.h>
#include <sys/param.h>
#include <stdio.h>
#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif /* STDC_HEADERS */
#ifdef HAVE_STRING_H
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
#endif /* HAVE_STRING_H */
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
#include <pwd.h>
#include <krb5.h>
#ifdef HAVE_HEIMDAL
#include <com_err.h>
#endif

#include "sudo.h"
#include "sudo_auth.h"

#ifdef HAVE_HEIMDAL
# define extract_name(c, p)		krb5_principal_get_comp_string(c, p, 1)
# define krb5_free_data_contents(c, d)	krb5_data_free(d)
#else
# define extract_name(c, p)		(krb5_princ_component(c, p, 1)->data)
#endif

#ifndef HAVE_KRB5_VERIFY_USER
static int verify_krb_v5_tgt __P((krb5_context, krb5_creds *, char *));
#endif
static struct _sudo_krb5_data {
    krb5_context	sudo_context;
    krb5_principal	princ;
    krb5_ccache		ccache;
} sudo_krb5_data = { NULL, NULL, NULL };
typedef struct _sudo_krb5_data *sudo_krb5_datap;

#ifndef HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
static krb5_error_code
krb5_get_init_creds_opt_alloc(context, opts)
    krb5_context		context;
    krb5_get_init_creds_opt   **opts;
{
    *opts = emalloc(sizeof(krb5_get_init_creds_opt));
    krb5_get_init_creds_opt_init(*opts);
    return 0;
}

static void
krb5_get_init_creds_opt_free(opts)
    krb5_get_init_creds_opt *opts;
{
    free(opts);
}
#endif

int
kerb5_init(pw, promptp, auth)
    struct passwd *pw;
    char **promptp;
    sudo_auth *auth;
{
    krb5_context	sudo_context;
    krb5_ccache		ccache;
    krb5_principal	princ;
    krb5_error_code 	error;
    char		cache_name[64];
    char		*pname;

    auth->data = (void *) &sudo_krb5_data; /* Stash all our data here */

#ifdef HAVE_KRB5_INIT_SECURE_CONTEXT
    error = krb5_init_secure_context(&(sudo_krb5_data.sudo_context));
#else
    error = krb5_init_context(&(sudo_krb5_data.sudo_context));
#endif
    if (error)
	return(AUTH_FAILURE);
    sudo_context = sudo_krb5_data.sudo_context;

    if ((error = krb5_parse_name(sudo_context, pw->pw_name,
	&(sudo_krb5_data.princ)))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to parse '%s': %s", auth->name, pw->pw_name,
		  error_message(error));
	return(AUTH_FAILURE);
    }
    princ = sudo_krb5_data.princ;

    /*
     * Really, we need to tell the caller not to prompt for password.
     * The API does not currently provide this unless the auth is standalone.
     */
#if 1
    if ((error = krb5_unparse_name(sudo_context, princ, &pname))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to unparse princ ('%s'): %s", auth->name,
		  pw->pw_name, error_message(error));
	return(AUTH_FAILURE);
    }

    /* Only rewrite prompt if user didn't specify their own. */
    /*if (!strcmp(prompt, PASSPROMPT)) { */
	easprintf(promptp, "Password for %s: ", pname);
    /*}*/
    free(pname);
#endif

    (void) snprintf(cache_name, sizeof(cache_name), "MEMORY:sudocc_%ld",
		    (long) getpid());
    if ((error = krb5_cc_resolve(sudo_context, cache_name,
	&(sudo_krb5_data.ccache)))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to resolve ccache: %s", auth->name,
		  error_message(error));
	return(AUTH_FAILURE);
    }
    ccache = sudo_krb5_data.ccache;

    return(AUTH_SUCCESS);
}

#ifdef HAVE_KRB5_VERIFY_USER
int
kerb5_verify(pw, pass, auth)
    struct passwd *pw;
    char *pass;
    sudo_auth *auth;
{
    krb5_context	sudo_context;
    krb5_principal	princ;
    krb5_ccache		ccache;
    krb5_error_code	error;

    sudo_context = ((sudo_krb5_datap) auth->data)->sudo_context;
    princ = ((sudo_krb5_datap) auth->data)->princ;
    ccache = ((sudo_krb5_datap) auth->data)->ccache;

    error = krb5_verify_user(sudo_context, princ, ccache, pass, 1, NULL);
    return (error ? AUTH_FAILURE : AUTH_SUCCESS);
}
#else
int
kerb5_verify(pw, pass, auth)
    struct passwd *pw;
    char *pass;
    sudo_auth *auth;
{
    krb5_context	sudo_context;
    krb5_principal	princ;
    krb5_creds		credbuf, *creds = NULL;
    krb5_ccache		ccache;
    krb5_error_code	error;
    krb5_get_init_creds_opt *opts = NULL;

    sudo_context = ((sudo_krb5_datap) auth->data)->sudo_context;
    princ = ((sudo_krb5_datap) auth->data)->princ;
    ccache = ((sudo_krb5_datap) auth->data)->ccache;

    /* Set default flags based on the local config file. */
    error = krb5_get_init_creds_opt_alloc(sudo_context, &opts);
    if (error) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to allocate options: %s", auth->name,
		  error_message(error));
	goto done;
    }
#ifdef HAVE_HEIMDAL
    krb5_get_init_creds_opt_set_default_flags(sudo_context, NULL,
	krb5_principal_get_realm(sudo_context, princ), opts);
#endif

    /* Note that we always obtain a new TGT to verify the user */
    if ((error = krb5_get_init_creds_password(sudo_context, &credbuf, princ,
					     pass, krb5_prompter_posix,
					     NULL, 0, NULL, opts))) {
	/* Don't print error if just a bad password */
	if (error != KRB5KRB_AP_ERR_BAD_INTEGRITY)
	    log_error(NO_EXIT|NO_MAIL,
		      "%s: unable to get credentials: %s", auth->name,
		      error_message(error));
	goto done;
    }
    creds = &credbuf;

    /* Verify the TGT to prevent spoof attacks. */
    if ((error = verify_krb_v5_tgt(sudo_context, creds, auth->name)))
	goto done;

    /* Store cred in cred cache. */
    if ((error = krb5_cc_initialize(sudo_context, ccache, princ))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to initialize ccache: %s", auth->name,
		  error_message(error));
    } else if ((error = krb5_cc_store_cred(sudo_context, ccache, creds))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to store cred in ccache: %s", auth->name,
		  error_message(error));
    }

done:
    if (opts) {
#ifdef HAVE_KRB5_GET_INIT_CREDS_OPT_FREE_TWO_ARGS
	krb5_get_init_creds_opt_free(sudo_context, opts);
#else
	krb5_get_init_creds_opt_free(opts);
#endif
    }
    if (creds)
	krb5_free_cred_contents(sudo_context, creds);
    return (error ? AUTH_FAILURE : AUTH_SUCCESS);
}
#endif

int
kerb5_cleanup(pw, auth)
    struct passwd *pw;
    sudo_auth *auth;
{
    krb5_context	sudo_context;
    krb5_principal	princ;
    krb5_ccache		ccache;

    sudo_context = ((sudo_krb5_datap) auth->data)->sudo_context;
    princ = ((sudo_krb5_datap) auth->data)->princ;
    ccache = ((sudo_krb5_datap) auth->data)->ccache;

    if (sudo_context) {
	if (ccache)
	    krb5_cc_destroy(sudo_context, ccache);
	if (princ)
	    krb5_free_principal(sudo_context, princ);
	krb5_free_context(sudo_context);
    }

    return(AUTH_SUCCESS);
}

#ifndef HAVE_KRB5_VERIFY_USER
/*
 * Verify the Kerberos ticket-granting ticket just retrieved for the
 * user.  If the Kerberos server doesn't respond, assume the user is
 * trying to fake us out (since we DID just get a TGT from what is
 * supposedly our KDC).
 *
 * Returns 0 for successful authentication, non-zero for failure.
 */
static int
verify_krb_v5_tgt(sudo_context, cred, auth_name)
    krb5_context	sudo_context;
    krb5_creds		*cred;
    char		*auth_name; /* For error reporting */
{
    krb5_error_code	error;
    krb5_principal	server;
    krb5_verify_init_creds_opt vopt;

    /*
     * Get the server principal for the local host.
     * (Use defaults of "host" and canonicalized local name.)
     */
    if ((error = krb5_sname_to_principal(sudo_context, NULL, NULL,
					KRB5_NT_SRV_HST, &server))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to get host principal: %s", auth_name,
		  error_message(error));
	return(-1);
    }

    /* Initialize verify opts and set secure mode */
    krb5_verify_init_creds_opt_init(&vopt);
    krb5_verify_init_creds_opt_set_ap_req_nofail(&vopt, 1);

    /* verify the Kerberos ticket-granting ticket we just retrieved */
    error = krb5_verify_init_creds(sudo_context, cred, server, NULL,
				   NULL, &vopt);
    krb5_free_principal(sudo_context, server);
    if (error)
	log_error(NO_EXIT|NO_MAIL,
		  "%s: Cannot verify TGT! Possible attack!: %s", auth_name,
		  error_message(error));
    return(error);
}
#endif
@


1.16
log
@Remove old $Sudo$ tags; the main sudo tree no longer lives in cvs.
@
text
@@


1.15
log
@update to sudo 1.7.2p2
@
text
@a55 4
#ifndef lint
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.37 2009/11/03 14:51:20 millert Exp $";
#endif /* lint */

@


1.14
log
@sync with sudo repo
@
text
@d57 1
a57 1
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.36 2008/11/09 14:13:13 millert Exp $";
d84 1
@


1.13
log
@Upgrade to sudo 1.7.  See the WHATSNEW files for details.
@
text
@d2 1
a2 1
 * Copyright (c) 1999-2005 Todd C. Miller <Todd.Miller@@courtesan.com>
d57 1
a57 1
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.34 2008/02/13 22:17:14 millert Exp $";
d77 18
d241 3
a243 1
#ifdef HAVE_HEIMDAL
a244 2
#else
	krb5_get_init_creds_opt_free(sudo_context, opts);
@


1.12
log
@Update to sudo 1.6.9p17
@
text
@d57 1
a57 1
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.23.2.8 2008/02/13 22:17:41 millert Exp $";
d90 1
a90 1
    auth->data = (VOID *) &sudo_krb5_data; /* Stash all our data here */
@


1.11
log
@update to sudo 1.6.9p12
@
text
@d57 1
a57 1
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.23.2.7 2008/01/13 14:54:40 millert Exp $";
d188 1
d191 1
d222 2
a223 1
    if (opts)
d225 4
@


1.10
log
@Update to sudo 1.6.9p1.  Note that the environment handling in sudo
1.6.9 has changed relative to older versions.  Sudo now starts
commands with a minimal environment containing the variables in the
env_keep and env_check lists.  This behavior is configurable in the
sudoers file.  Please see the "SECURITY NOTES" section in the sudo
manual.
@
text
@d57 1
a57 1
__unused static const char rcsid[] = "$Sudo: kerb5.c,v 1.23.2.4 2007/06/12 01:28:42 millert Exp $";
d68 1
a68 1
static int verify_krb_v5_tgt __P((krb5_context, krb5_ccache, char *));
a76 2
extern const krb5_cc_ops krb5_mcc_ops;

a128 10
    /* For CNS compatibility */
    if ((error = krb5_cc_register(sudo_context, &krb5_mcc_ops, FALSE))) {
	if (error != KRB5_CC_TYPE_EXISTS) {
	    log_error(NO_EXIT|NO_MAIL,
		      "%s: unable to use Memory ccache: %s", auth->name,
		      error_message(error));
	    return(AUTH_FAILURE);
	}
    }

a139 7
    if ((error = krb5_cc_initialize(sudo_context, ccache, princ))) {
	log_error(NO_EXIT|NO_MAIL,
		  "%s: unable to initialize ccache: %s", auth->name,
		  error_message(error));
	return(AUTH_FAILURE);
    }

d171 1
a172 1
    krb5_creds		creds;
d174 1
a174 1
    krb5_get_init_creds_opt opts;
d180 10
a189 2
    /* Initialize options to defaults */
    krb5_get_init_creds_opt_init(&opts);
d192 1
a192 1
    if ((error = krb5_get_init_creds_password(sudo_context, &creds, princ,
d194 16
a209 4
					     NULL, 0, NULL, &opts))) {
	if (error == KRB5KRB_AP_ERR_BAD_INTEGRITY) /* Bad password */
	    return(AUTH_FAILURE);
	/* Some other error */
d211 1
a211 1
		  "%s: unable to get credentials: %s", auth->name,
d213 1
a213 5
	return(AUTH_FAILURE);
    }

    /* Stash the TGT so we can verify it. */
    if ((error = krb5_cc_store_cred(sudo_context, ccache, &creds))) {
d215 1
a215 1
		  "%s: unable to store credentials: %s", auth->name,
a216 2
    } else {
	error = verify_krb_v5_tgt(sudo_context, ccache, auth->name);
d219 5
a223 1
    krb5_free_cred_contents(sudo_context, &creds);
a253 2
 * This routine with some modification is from the MIT V5B6 appl/bsd/login.c
 *
d257 1
a257 4
 * supposedly our KDC). If the host/<host> service is unknown (i.e.,
 * the local keytab doesn't have it), return success but log the error.
 *
 * This needs to run as root (to read the host service ticket).
d262 1
a262 1
verify_krb_v5_tgt(sudo_context, ccache, auth_name)
d264 1
a264 1
    krb5_ccache		ccache;
a266 1
    char		phost[BUFSIZ];
d268 2
a269 6
    krb5_principal	princ;
    krb5_data		packet;
    krb5_keyblock	*keyblock = 0;
    krb5_auth_context	auth_context = NULL;

    packet.data = 0;
d276 1
a276 1
					KRB5_NT_SRV_HST, &princ))) {
d283 8
a290 36
    /* Extract the name directly. Yow. */
    strlcpy(phost, extract_name(sudo_context, princ), sizeof(phost));

    /*
     * Do we have host/<host> keys?
     * (use default keytab, kvno IGNORE_VNO to get the first match,
     * and enctype is currently ignored anyhow.)
     */
    if ((error = krb5_kt_read_service_key(sudo_context, NULL, princ, 0,
					 0, &keyblock))) {
	/* Keytab or service key does not exist. */
	log_error(NO_EXIT,
		  "%s: host service key not found: %s", auth_name,
		  error_message(error));
	goto cleanup;
    }
    if (keyblock)
	krb5_free_keyblock(sudo_context, keyblock);

    /* Talk to the kdc and construct the ticket. */
    error = krb5_mk_req(sudo_context, &auth_context, 0, "host", phost,
			NULL, ccache, &packet);
    if (auth_context) {
	krb5_auth_con_free(sudo_context, auth_context);
	auth_context = NULL;	/* setup for rd_req */
    }

    /* Try to use the ticket. */
    if (!error)
	error = krb5_rd_req(sudo_context, &auth_context, &packet, princ,
			    NULL, NULL, NULL);
cleanup:
    if (packet.data)
	krb5_free_data_contents(sudo_context, &packet);
    krb5_free_principal(sudo_context, princ);

@


1.9
log
@update to sudo 1.6.8p8
@
text
@d2 1
a2 1
 * Copyright (c) 1999,2001,2003-2004 Todd C. Miller <Todd.Miller@@courtesan.com>
d24 1
a24 1
#include "config.h"
d49 3
d57 1
a57 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.23 2004/06/07 00:02:56 millert Exp $";
a62 1
# define ENCTYPE_DES_CBC_MD5		ETYPE_DES_CBC_MD5	/* XXX */
d67 1
d69 1
d94 6
a99 1
    if ((error = krb5_init_context(&(sudo_krb5_data.sudo_context))))
d162 20
d227 1
d253 1
d303 1
a303 1
					 ENCTYPE_DES_CBC_MD5, &keyblock))) {
a307 1
	error = 0;
d336 1
@


1.8
log
@Update to sudo 1.6.8p1
@
text
@d58 1
a58 1
# define extract_name(c, p)		krb5_principal_get_comp_string(c, p, 0)
@


1.7
log
@Update to 1.6.7p5
@
text
@d2 1
a2 2
 * Copyright (c) 1999, 2001, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
d4 11
a14 28
 * This code is derived from software contributed by Frank Cusack
 * <fcusack@@fcusack.com>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * 4. Products derived from this software may not be called "Sudo" nor
 *    may "Sudo" appear in their names without specific prior written
 *    permission from the author.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
d54 1
a54 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.18 2003/04/16 00:42:10 millert Exp $";
d73 1
a73 1
extern krb5_cc_ops krb5_mcc_ops;
d96 1
a96 1
	log_error(NO_EXIT|NO_MAIL, 
d125 1
a125 1
	    log_error(NO_EXIT|NO_MAIL, 
d136 1
a136 1
	log_error(NO_EXIT|NO_MAIL, 
d144 1
a144 1
	log_error(NO_EXIT|NO_MAIL, 
d180 1
a180 1
	log_error(NO_EXIT|NO_MAIL, 
d188 1
a188 1
	log_error(NO_EXIT|NO_MAIL, 
d257 1
a257 1
	log_error(NO_EXIT|NO_MAIL, 
d301 1
a301 1
	log_error(NO_EXIT|NO_MAIL, 
@


1.6
log
@sync w/ the sudo cvs tree and sudo 1.6.7p4
@
text
@d76 1
a76 1
# define extract_name(c, p)		krb5_principal_get_comp_string(c, p, 0);
@


1.5
log
@Sync with sudo 1.6.7p3; fixes kerberos 5 compilation issues w/ MIT kerberos.
@
text
@d36 4
d72 1
a72 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.16 2003/04/04 17:46:57 millert Exp $";
d76 1
d78 1
d80 1
a80 1
# define krb5_principal_get_realm(c, p)	(krb5_princ_realm(c, p)->data)
d281 2
a282 3
    /* Extract the name directly. */
    strlcpy(phost, krb5_principal_get_realm(sudo_context, princ),
	    sizeof(phost));
@


1.4
log
@Sync with my sudo cvs repo:
 o update to sudo 1.6.7p2
 o use warn/err throughout
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.14 2003/04/02 18:57:34 millert Exp $";
d71 6
d285 1
a285 1
					 ETYPE_DES_CBC_MD5, &keyblock))) {
d310 1
a310 1
	krb5_data_free(&packet);
@


1.3
log
@update to what will soon be sudo 1.6.7
@
text
@d68 1
a68 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.13 2003/03/15 20:37:44 millert Exp $";
d269 2
a270 2
    /* Extract the name directly. 
    strlcpy(phost, krb5_principal_get_realm(sudo_context, princ, 1),
@


1.2
log
@Update to sudo 1.6.4
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
d68 1
a68 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.11 2001/12/14 19:52:53 millert Exp $";
d96 1
a96 4
    if (error = krb5_init_context(&(sudo_krb5_data.sudo_context))) {
	log_error(NO_EXIT|NO_MAIL, 
		  "%s: unable to initialize context: %s", auth->name,
		  error_message(error));
a97 1
    }
d100 2
a101 2
    if (error = krb5_parse_name(sudo_context, pw->pw_name,
	&(sudo_krb5_data.princ))) {
d114 1
a114 1
    if (error = krb5_unparse_name(sudo_context, princ, &pname)) {
d129 1
a129 1
    if (error = krb5_cc_register(sudo_context, &krb5_mcc_ops, FALSE)) {
d140 2
a141 2
    if (error = krb5_cc_resolve(sudo_context, cache_name,
	&(sudo_krb5_data.ccache))) {
d149 1
a149 1
    if (error = krb5_cc_initialize(sudo_context, ccache, princ)) {
a170 1
    char		cache_name[64];
d180 1
a180 1
    if (error = krb5_get_init_creds_password(sudo_context, &creds, princ,
d182 1
a182 1
					     NULL, 0, NULL, &opts)) {
d193 1
a193 1
    if (error = krb5_cc_store_cred(sudo_context, ccache, &creds)) {
d261 2
a262 2
    if (error = krb5_sname_to_principal(sudo_context, NULL, NULL,
					KRB5_NT_SRV_HST, &princ)) {
d269 3
a271 4
    /* Extract the name directly. Yow. */
    strncpy(phost, krb5_princ_component(sudo_context, princ, 1)->data,
	    sizeof(phost) - 1);
    phost[sizeof(phost) - 1] = '\0';
d278 2
a279 2
    if (error = krb5_kt_read_service_key(sudo_context, NULL, princ, 0,
					 ENCTYPE_DES_CBC_MD5, &keyblock)) {
d304 1
a304 1
	krb5_free_data_contents(sudo_context, &packet);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d40 2
d44 6
a49 1
#include <stdlib.h>
d51 7
d59 1
a59 1
#include <unistd.h>
a60 8
#ifdef HAVE_STRING_H
#include <string.h>
#endif /* HAVE_STRING_H */
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRINGS_H */
#include <sys/param.h>
#include <sys/types.h>
d68 1
a68 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.10 1999/10/13 02:34:55 millert Exp $";
@


1.1.1.1
log
@sudo 1.6, now with a BSD license
@
text
@@


1.1.1.1.6.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a39 2
#include <sys/types.h>
#include <sys/param.h>
d42 1
a42 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d44 3
d48 1
a48 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d50 5
a54 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d62 1
a62 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.11 2001/12/14 19:52:53 millert Exp $";
@


1.1.1.1.8.1
log
@update to sudo 1.6.5p1
@
text
@d2 1
a2 1
 * Copyright (c) 1999, 2001 Todd C. Miller <Todd.Miller@@courtesan.com>
a39 2
#include <sys/types.h>
#include <sys/param.h>
d42 1
a42 6
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
d44 3
d48 1
a48 5
# include <string.h>
#else
# ifdef HAVE_STRINGS_H
#  include <strings.h>
# endif
d50 5
a54 3
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif /* HAVE_UNISTD_H */
d62 1
a62 1
static const char rcsid[] = "$Sudo: kerb5.c,v 1.11 2001/12/14 19:52:53 millert Exp $";
@

