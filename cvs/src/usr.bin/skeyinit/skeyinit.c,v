head	1.72;
access;
symbols
	OPENBSD_6_1:1.72.0.4
	OPENBSD_6_1_BASE:1.72
	OPENBSD_6_0:1.72.0.2
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.69.0.2
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.51.0.34
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.32
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.30
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.28
	OPENBSD_5_0:1.51.0.26
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.24
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.51.0.22
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.51.0.18
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.51.0.20
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.16
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.14
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.51.0.12
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.51.0.10
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.51.0.8
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.51.0.6
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.51.0.4
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.50.0.2
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.48.0.2
	OPENBSD_3_6_BASE:1.48
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.24.0.6
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.24.0.4
	OPENBSD_2_7_BASE:1.24
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.20.0.4
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.17.0.2
	OPENBSD_2_1_BASE:1.17
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.72
date	2016.05.17.23.36.29;	author tb;	state Exp;
branches;
next	1.71;
commitid	kRtSopf7K2o0Au5d;

1.71
date	2016.05.17.23.07.47;	author tb;	state Exp;
branches;
next	1.70;
commitid	Nhoj2raAimXAuqEU;

1.70
date	2016.05.17.20.54.07;	author millert;	state Exp;
branches;
next	1.69;
commitid	EVQpKfAEVl2lbSSe;

1.69
date	2016.02.21.22.53.40;	author tb;	state Exp;
branches;
next	1.68;
commitid	5eC4vJShc4eZ4Y98;

1.68
date	2015.11.29.19.10.44;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	PNzBdgZSr5uQDGpQ;

1.67
date	2015.11.29.14.51.35;	author millert;	state Exp;
branches;
next	1.66;
commitid	HA5xponMCH7TMn5c;

1.66
date	2015.11.29.14.44.20;	author millert;	state Exp;
branches;
next	1.65;
commitid	aMTPOmzHtn6121TC;

1.65
date	2015.11.29.03.09.31;	author millert;	state Exp;
branches;
next	1.64;
commitid	5t4Vr3b5fXSeuCkZ;

1.64
date	2015.11.29.03.08.43;	author millert;	state Exp;
branches;
next	1.63;
commitid	XDiZRgkwx8mBFw44;

1.63
date	2015.11.29.03.08.10;	author millert;	state Exp;
branches;
next	1.62;
commitid	npFEvIgKiztYkDqc;

1.62
date	2015.11.20.20.57.48;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	1eEFtbDOSOlpKnU4;

1.61
date	2015.10.09.21.59.34;	author tim;	state Exp;
branches;
next	1.60;
commitid	DVoiJg7RFqjToPA4;

1.60
date	2015.10.06.15.09.08;	author tim;	state Exp;
branches;
next	1.59;
commitid	xqQ5XmnbwSsAnf8Q;

1.59
date	2015.10.03.13.10.47;	author tim;	state Exp;
branches;
next	1.58;
commitid	hU0QSunPSl8OrXSF;

1.58
date	2015.08.20.22.32.42;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	0Dp7Dy9FuNZesYo2;

1.57
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	6b2lLILbgCR1fvia;

1.56
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	Uu5nFG3wCl0LACBb;

1.55
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2014.04.23.18.24.23;	author ajacoutot;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.20.20.39.13;	author naddy;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.28.18.24.55;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.07.06.22.15.11;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2004.12.27.23.37.49;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.09.14.22.58.57;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.07.19.28.03;	author otto;	state Exp;
branches;
next	1.47;

1.47
date	2004.06.06.11.24.13;	author otto;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.04.18.18.20;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.26.00.05.27;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.07.20.39.29;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.06.21.07.38;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2002.11.16.23.05.36;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.23.03.07.22;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.07.21.53.43;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.07.21.35.26;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.06.20.56.02;	author aaron;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.19.02.09.28;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.17.15.54.13;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.17.00.55.54;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.16.17.54.34;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.05.16.03.50.42;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.16.21.27.52;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.01.18.26.58;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.23.22.29.14;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.20.22.25.08;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.16.27.04;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.26.16.25.34;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.16.15.15.58;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.09.10.10.09.28;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.03.02.21.55.53;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.08.22.19.29.46;	author dgregor;	state Exp;
branches;
next	1.21;

1.21
date	98.07.09.17.04.00;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.07.27.21.36.05;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	97.07.25.00.27.30;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.07.17.05.48.41;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	96.11.03.18.57.46;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	96.10.23.18.09.27;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	96.10.14.03.10.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	96.10.08.16.31.45;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	96.10.02.18.11.30;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.10.02.03.49.34;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	96.09.30.18.49.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	96.09.30.06.30.43;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.09.29.23.11.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.09.29.21.28.42;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.29.04.34.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.09.28.17.35.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	96.09.28.00.04.44;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.27.15.49.04;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.39.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.20.09.48.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.08;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.72
log
@Refactor the handling of pledge and the optional user string: The three
way pledge introduced by millert@@ in -r1.70 is now a two way pledge, one
for non-root and one for root.  This also ensures that root drops the
id promise in all cases early on.

This disentangling of the bits for root and non-root simplifies the code
paths in all cases.

ok millert@@
@
text
@/*	$OpenBSD: skeyinit.c,v 1.70 2016/05/17 20:54:07 millert Exp $	*/

/* OpenBSD S/Key (skeyinit.c)
 *
 * Authors:
 *          Neil M. Haller <nmh@@thumper.bellcore.com>
 *          Philip R. Karn <karn@@chicago.qualcomm.com>
 *          John S. Walden <jsw@@thumper.bellcore.com>
 *          Scott Chasin <chasin@@crimelab.com>
 *          Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * S/Key initialization and seed update
 */

#include <sys/file.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/time.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include <utmp.h>

#include <skey.h>
#include <bsd_auth.h>

#ifndef SKEY_NAMELEN
#define SKEY_NAMELEN    4
#endif

void	usage(void);
void	secure_mode(int *, char *, char *, size_t, char *, size_t);
void	normal_mode(char *, int, char *, char *);
void	enable_db(int);

int
main(int argc, char **argv)
{
	int     rval, i, l, n, defaultsetup, rmkey, hexmode, enable;
	char	hostname[HOST_NAME_MAX+1];
	char	seed[SKEY_MAX_SEED_LEN + 1];
	char    buf[256], key[SKEY_BINKEY_SIZE], filename[PATH_MAX], *ht;
	char    lastc, *p, *auth_type;
	const char *errstr;
	struct skey skey;
	struct passwd *pp;

	n = rmkey = hexmode = enable = 0;
	defaultsetup = 1;
	ht = auth_type = NULL;

	for (i = 1; i < argc && argv[i][0] == '-' && strcmp(argv[i], "--");) {
		if (argv[i][2] == '\0') {
			/* Single character switch */
			switch (argv[i][1]) {
			case 'a':
				if (argv[++i] == NULL || argv[i][0] == '\0')
					usage();
				auth_type = argv[i];
				break;
			case 's':
				defaultsetup = 0;
				if (auth_type == NULL)
					auth_type = "skey";
				break;
			case 'x':
				hexmode = 1;
				break;
			case 'r':
				rmkey = 1;
				break;
			case 'n':
				if (argv[++i] == NULL || argv[i][0] == '\0')
					usage();
				n = strtonum(argv[i], 1, SKEY_MAX_SEQ - 1, &errstr);
				if (errstr)
					errx(1, "count must be > 0 and < %d",
					     SKEY_MAX_SEQ);
				break;
			case 'D':
				enable = -1;
				break;
			case 'E':
				enable = 1;
				break;
			default:
				usage();
			}
		} else {
			/* Multi character switches are hash types */
			if ((ht = skey_set_algorithm(&argv[i][1])) == NULL) {
				warnx("Unknown hash algorithm %s", &argv[i][1]);
				usage();
			}
		}
		i++;
	}
	argv += i;
	argc -= i;

	if (argc > 1 || (enable && argc))
		usage();

	/* Handle -D and -E */
	if (enable) {
		enable_db(enable);
		exit(0);
	}

	if (getuid() != 0) {
		if (pledge("stdio rpath wpath cpath fattr flock tty proc exec "
		    "getpw", NULL) == -1)
			err(1, "pledge");

		if ((pp = getpwuid(getuid())) == NULL)
			err(1, "no user with uid %u", getuid());

		if (argc == 1) {
			char me[UT_NAMESIZE + 1]; 

			(void)strlcpy(me, pp->pw_name, sizeof me);
			if ((pp = getpwnam(argv[0])) == NULL)
				errx(1, "User unknown: %s", argv[0]);
			if (strcmp(pp->pw_name, me) != 0)
				errx(1, "Permission denied.");
		}
	} else {
		if (pledge("stdio rpath wpath cpath fattr flock tty getpw id",
		    NULL) == -1)
			err(1, "pledge");

		if (argc == 1) {
			if ((pp = getpwnam(argv[0])) == NULL) {
				static struct passwd _pp;

				_pp.pw_name = argv[0];
				pp = &_pp;
				warnx("Warning, user unknown: %s", argv[0]);
			} else {
				/* So the file ends up owned by the proper ID */
				if (setresuid(-1, pp->pw_uid, -1) != 0)
					errx(1, "unable to change uid to %u",
					    pp->pw_uid);
			}
		} else if ((pp = getpwuid(0)) == NULL)
			err(1, "no user with uid 0");

		if (pledge("stdio rpath wpath cpath fattr flock tty", NULL)
		    == -1)
			err(1, "pledge");
	}

	switch (skey_haskey(pp->pw_name)) {
	case -1:
		if (errno == ENOENT || errno == EPERM)
			errx(1, "S/Key disabled");
		else
			err(1, "cannot open database");
		break;
	case 0:
		/* existing user */
		break;
	case 1:
		if (!defaultsetup && strcmp(auth_type, "skey") == 0) {
			fprintf(stderr,
"You must authenticate yourself before using S/Key for the first time.  In\n"
"secure mode this is normally done via an existing S/Key key.  However, since\n"
"you do not have an entry in the S/Key database you will have to specify an\n"
"alternate authentication type via the `-a' flag, e.g.\n"
"    \"skeyinit -s -a passwd\"\n\n"
"Note that entering a plaintext password over a non-secure link defeats the\n"
"purpose of using S/Key in the fist place.\n");
			exit(1);
		}
		break;
	}

	if (getuid() != 0) {
		if ((pp = pw_dup(pp)) == NULL)
			err(1, NULL);
		if (!auth_userokay(pp->pw_name, auth_type, NULL, NULL))
			errx(1, "Password incorrect");
	}

	if (pledge("stdio rpath wpath cpath fattr flock tty", NULL) == -1)
		err(1, "pledge");

	/* Build up a default seed based on the hostname and some randomness */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		err(1, "gethostname");
	for (i = 0, p = seed; hostname[i] && i < SKEY_NAMELEN; i++) {
		if (isalnum((unsigned char)hostname[i]))
			*p++ = tolower((unsigned char)hostname[i]);
	}
	for (i = 0; i < 5; i++)
		*p++ = arc4random_uniform(10) + '0';
	*p = '\0';

	/*
	 * Lookup and lock the record we are about to modify.
	 * If this is a new entry this will prevent other users
	 * from appending new entries (and clobbering ours).
	 */
	rval = skeylookup(&skey, pp->pw_name);
	switch (rval) {
		case -1:
			err(1, "cannot open database");
			break;
		case 0:
			/* remove user if asked to do so */
			if (rmkey) {
				if (snprintf(filename, sizeof(filename),
				    "%s/%s", _PATH_SKEYDIR, pp->pw_name)
				    >= sizeof(filename))
					errc(1, ENAMETOOLONG,
					    "Cannot remove S/Key entry");
				if (unlink(filename) != 0)
					err(1, "Cannot remove S/Key entry");
				printf("S/Key entry for %s removed.\n",
				    pp->pw_name);
				exit(0);
			}

			(void)printf("[Updating %s with %s]\n", pp->pw_name,
			    ht ? ht : skey_get_algorithm());
			(void)printf("Old seed: [%s] %s\n",
				     skey_get_algorithm(), skey.seed);

			/*
			 * Sanity check old seed.
			 */
			l = strlen(skey.seed);
			for (p = skey.seed; *p; p++) {
				if (isalpha((unsigned char)*p)) {
					if (isupper((unsigned char)*p))
						*p = tolower((unsigned char)*p);
				} else if (!isdigit((unsigned char)*p)) {
					memmove(p, p + 1, l - (p - skey.seed));
					l--;
				}
			}

			/* If the seed ends in 0-8 just add one.  */
			if (l > 0) {
				lastc = skey.seed[l - 1];
				if (isdigit((unsigned char)lastc) &&
				    lastc != '9') {
					(void)strlcpy(seed, skey.seed,
					    sizeof seed);
					seed[l - 1] = lastc + 1;
				}
				if (isdigit((unsigned char)lastc) &&
				    lastc == '9' && l < 16) {
					(void)strlcpy(seed, skey.seed,
					    sizeof seed);
					seed[l - 1] = '0';
					seed[l] = '0';
					seed[l + 1] = '\0';
				}
			}
			break;
		case 1:
			if (rmkey)
				errx(1, "You have no entry to remove.");
			(void)printf("[Adding %s with %s]\n", pp->pw_name,
			    ht ? ht : skey_get_algorithm());
			if (snprintf(filename, sizeof(filename), "%s/%s",
			    _PATH_SKEYDIR, pp->pw_name) >= sizeof(filename))
				errc(1, ENAMETOOLONG,
				    "Cannot create S/Key entry");
			if ((l = open(filename,
			    O_RDWR | O_NONBLOCK | O_CREAT | O_TRUNC |O_NOFOLLOW,
			    S_IRUSR | S_IWUSR)) == -1 ||
			    flock(l, LOCK_EX) != 0 ||
			    (skey.keyfile = fdopen(l, "r+")) == NULL)
				err(1, "Cannot create S/Key entry");
			break;
	}
	if (fchown(fileno(skey.keyfile), pp->pw_uid, -1) != 0 ||
	    fchmod(fileno(skey.keyfile), S_IRUSR | S_IWUSR) != 0)
		err(1, "can't set owner/mode for %s", pp->pw_name);
	if (defaultsetup && n == 0)
		n = 100;

	/* Set hash type if asked to */
	if (ht && strcmp(ht, skey_get_algorithm()) != 0)
		skey_set_algorithm(ht);

	alarm(180);
	if (!defaultsetup)
		secure_mode(&n, key, seed, sizeof seed, buf, sizeof(buf));
	else
		normal_mode(pp->pw_name, n, key, seed);
	alarm(0);

	/* XXX - why use malloc here? */
	if ((skey.val = malloc(16 + 1)) == NULL)
		err(1, "Can't allocate memory");
	btoa8(skey.val, key);

	(void)fseek(skey.keyfile, 0L, SEEK_SET);
	(void)fprintf(skey.keyfile, "%s\n%s\n%04d\n%s\n%s\n",
	    pp->pw_name, skey_get_algorithm(), n, seed, skey.val);
	(void)fclose(skey.keyfile);

	(void)printf("\nID %s skey is otp-%s %d %s\n", pp->pw_name,
	    skey_get_algorithm(), n, seed);
	(void)printf("Next login password: %s\n\n",
	    hexmode ? put8(buf, key) : btoe(buf, key));
	exit(0);
}

void
secure_mode(int *count, char *key, char *seed, size_t seedlen,
    char *buf, size_t bufsiz)
{
	char *p, newseed[SKEY_MAX_SEED_LEN + 2];
	const char *errstr;
	int i, n = *count;

	(void)puts("You need the 6 words generated from the \"skey\" command.");
	if (n == 0) {
		for (i = 0; ; i++) {
			if (i >= 2)
				exit(1);

			(void)printf("Enter sequence count from 1 to %d: ",
			    SKEY_MAX_SEQ);
			(void)fgets(buf, bufsiz, stdin);
			clearerr(stdin);
			rip(buf);
			n = strtonum(buf, 1, SKEY_MAX_SEQ-1, &errstr);
			if (!errstr)
				break;	/* Valid range */
			fprintf(stderr,
			    "ERROR: Count must be between 1 and %d\n",
			    SKEY_MAX_SEQ - 1);
		}
		*count= n;
	}

	for (i = 0; ; i++) {
		if (i >= 2)
			exit(1);

		(void)printf("Enter new seed [default %s]: ", seed);
		(void)fgets(newseed, sizeof(newseed), stdin); /* XXX */
		clearerr(stdin);
		rip(newseed);
		if (strlen(newseed) > SKEY_MAX_SEED_LEN) {
			(void)fprintf(stderr, "ERROR: Seed must be between 1 "
			    "and %d characters in length\n", SKEY_MAX_SEED_LEN);
			continue;
		}
		for (p = newseed; *p; p++) {
			if (isspace((unsigned char)*p)) {
				(void)fputs("ERROR: Seed must not contain "
				    "any spaces\n", stderr);
				break;
			} else if (isalpha((unsigned char)*p)) {
				if (isupper((unsigned char)*p))
					*p = tolower((unsigned char)*p);
			} else if (!isdigit((unsigned char)*p)) {
				(void)fputs("ERROR: Seed must be purely "
				    "alphanumeric\n", stderr);
				break;
			}
		}
		if (*p == '\0')
			break;  /* Valid seed */
	}
	if (newseed[0] != '\0')
		(void)strlcpy(seed, newseed, seedlen);

	for (i = 0; ; i++) {
		if (i >= 2)
			exit(1);

		(void)printf("otp-%s %d %s\nS/Key access password: ",
			     skey_get_algorithm(), n, seed);
		(void)fgets(buf, bufsiz, stdin);
		clearerr(stdin);
		rip(buf);
		backspace(buf);

		if (buf[0] == '?') {
			(void)puts("Enter 6 words from secure S/Key calculation.");
			continue;
		} else if (buf[0] == '\0')
			exit(1);

		if (etob(key, buf) == 1 || atob8(key, buf) == 0)
			break;	/* Valid format */
		(void)fputs("ERROR: Invalid format - try again with the 6 words.\n",
		    stderr);
	}
}

void
normal_mode(char *username, int n, char *key, char *seed)
{
	int i, nn;
	char passwd[SKEY_MAX_PW_LEN+2], key2[SKEY_BINKEY_SIZE];

	/* Get user's secret passphrase */
	for (i = 0; ; i++) {
		if (i > 2)
			errx(1, "S/Key entry not updated");

		if (readpassphrase("Enter new secret passphrase: ", passwd,
		    sizeof(passwd), 0) == NULL || passwd[0] == '\0')
			exit(1);

		if (strlen(passwd) < SKEY_MIN_PW_LEN) {
			(void)fprintf(stderr,
			    "ERROR: Your passphrase must be at least %d "
			    "characters long.\n", SKEY_MIN_PW_LEN);
			continue;
		} else if (strcmp(passwd, username) == 0) {
			(void)fputs("ERROR: Your passphrase may not be the "
			    "same as your user name.\n", stderr);
			continue;
		} else if (strspn(passwd, "abcdefghijklmnopqrstuvwxyz") ==
		    strlen(passwd)) {
			(void)fputs("ERROR: Your passphrase must contain more "
			    "than just lower case letters.\nWhitespace, "
			    "numbers, and punctuation are suggested.\n",
			    stderr);
			continue;
		} else if (strlen(passwd) > 63) {
			(void)fprintf(stderr, "WARNING: Your passphrase is "
			    "longer than the recommended maximum length of 63\n");
		}
		/* XXX - should check for passphrase that is really too long */

		/* Crunch seed and passphrase into starting key */
		nn = keycrunch(key, seed, passwd);
		explicit_bzero(passwd, sizeof(passwd));
		if (nn != 0)
			err(2, "key crunch failed");

		if (readpassphrase("Again secret passphrase: ", passwd,
		    sizeof(passwd), 0) == NULL || passwd[0] == '\0')
			exit(1);

		/* Crunch seed and passphrase into starting key */
		nn = keycrunch(key2, seed, passwd);
		explicit_bzero(passwd, sizeof(passwd));
		if (nn != 0)
			err(2, "key crunch failed");

		if (memcmp(key, key2, sizeof(key2)) == 0)
			break;

		(void)fputs("Passphrases do not match.\n", stderr);
	}

	nn = n;
	while (nn-- != 0)
		f(key);
}

void
enable_db(int op)
{
	if (op == 1) {
		/* enable */
		if (mkdir(_PATH_SKEYDIR, 01730) != 0 && errno != EEXIST)
			err(1, "can't mkdir %s", _PATH_SKEYDIR);
		if (chown(_PATH_SKEYDIR, geteuid(), getegid()) != 0)
			err(1, "can't chown %s", _PATH_SKEYDIR);
		if (chmod(_PATH_SKEYDIR, 01730) != 0)
			err(1, "can't chmod %s", _PATH_SKEYDIR);
	} else {
		/* disable */
		if (chmod(_PATH_SKEYDIR, 0) != 0 && errno != ENOENT)
			err(1, "can't chmod %s", _PATH_SKEYDIR);
	}
}

void
usage(void)
{
	extern char *__progname;

	(void)fprintf(stderr, "usage: %s [-DErsx] [-a auth-type] [-n count]"
	    "\n\t[-md5 | -rmd160 | -sha1] [user]\n", __progname);
	exit(1);
}
@


1.71
log
@Move the code block that builds up a default seed further down in order
to reduce the noise in the next commit.  While there, fix the indent
level of a bit introduced in the previous commit.

ok millert@@
@
text
@d53 1
a53 1
	char    lastc, me[UT_NAMESIZE + 1], *p, *auth_type;
d124 14
a137 1
	} else if (argc == 1) {
a140 5
	} else {
		if (pledge("stdio rpath wpath cpath fattr flock tty getpw",
		    NULL) == -1)
			err(1, "pledge");
	}
d142 2
a143 8
	if ((pp = getpwuid(getuid())) == NULL)
		err(1, "no user with uid %u", getuid());
	(void)strlcpy(me, pp->pw_name, sizeof me);

	/* Check for optional user string. */
	if (argc == 1) {
		if ((pp = getpwnam(argv[0])) == NULL) {
			if (getuid() == 0) {
d150 4
a153 1
				errx(1, "User unknown: %s", argv[0]);
d155 6
a160 12
		} else if (getuid() == 0) {
			/* So the file ends up owned by the proper ID. */
			if (setresuid(-1, pp->pw_uid, -1) != 0)
				errx(1, "unable to change user ID to %u",
				    pp->pw_uid);
			if (pledge("stdio rpath wpath cpath fattr flock tty",
			    NULL) == -1)
				err(1, "pledge");
		} else {
			if (strcmp(pp->pw_name, me) != 0)
				errx(1, "Permission denied.");
		}
@


1.70
log
@Fix "skeyinit username" run as root.  Also reduce the pledge
promise when run as root since we don't need proc or exec as
root.  OK tb@@, earlier version OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.69 2016/02/21 22:53:40 tb Exp $	*/
a133 11
	/* Build up a default seed based on the hostname and some randomness */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		err(1, "gethostname");
	for (i = 0, p = seed; hostname[i] && i < SKEY_NAMELEN; i++) {
		if (isalnum((unsigned char)hostname[i]))
			*p++ = tolower((unsigned char)hostname[i]);
	}
	for (i = 0; i < 5; i++)
		*p++ = arc4random_uniform(10) + '0';
	*p = '\0';

d153 2
a154 2
			    errx(1, "unable to change user ID to %u",
				pp->pw_uid);
d198 11
@


1.69
log
@Fix skeyinit -E by hoisting argument parsing and the call to enable_db()
above the calls to pledge(): /etc/skey wants to have its sticky bit.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.68 2015/11/29 19:10:44 deraadt Exp $	*/
d120 13
a132 3
	if (pledge("stdio rpath wpath cpath fattr flock tty proc exec getpw",
	    NULL) == -1)
		err(1, "pledge");
d161 11
a171 3
		} else if (strcmp(pp->pw_name, me) != 0 && getuid() != 0) {
			/* Only root can change other's S/Keys. */
			errx(1, "Permission denied.");
@


1.68
log
@wrap long line
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.67 2015/11/29 14:51:35 millert Exp $	*/
a57 4
	if (pledge("stdio rpath wpath cpath fattr flock tty proc exec getpw",
	    NULL) == -1)
		err(1, "pledge");

a61 15
	/* Build up a default seed based on the hostname and some randomness */
	if (gethostname(hostname, sizeof(hostname)) < 0)
		err(1, "gethostname");
	for (i = 0, p = seed; hostname[i] && i < SKEY_NAMELEN; i++) {
		if (isalnum((unsigned char)hostname[i]))
			*p++ = tolower((unsigned char)hostname[i]);
	}
	for (i = 0; i < 5; i++)
		*p++ = arc4random_uniform(10) + '0';
	*p = '\0';

	if ((pp = getpwuid(getuid())) == NULL)
		err(1, "no user with uid %u", getuid());
	(void)strlcpy(me, pp->pw_name, sizeof me);

d119 19
@


1.67
log
@Drop pledge proc exec getpw after authenticating.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.66 2015/11/29 14:44:20 millert Exp $	*/
d58 2
a59 1
	if (pledge("stdio rpath wpath cpath fattr flock tty proc exec getpw", NULL) == -1)
@


1.66
log
@Remove useless getpwnam() call after getpwuid().  Noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.65 2015/11/29 03:09:31 millert Exp $	*/
d58 1
a58 1
	if (pledge("stdio rpath wpath cpath fattr flock tty proc exec", NULL) == -1)
d187 3
@


1.65
log
@skeyinit needs pledge proc and exec to use BSD auth.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.62 2015/11/20 20:57:48 deraadt Exp $	*/
a78 3

	if ((pp = getpwnam(me)) == NULL)
		err(1, "Who are you?");
@


1.64
log
@Allow the -n flag to work in -s mode.
@
text
@d58 1
a58 1
	if (pledge("stdio rpath wpath cpath fattr flock tty", NULL) == -1)
@


1.63
log
@Add missing rip() before the call to strtonum().  Otherwise, strtonum
errors out due to the newline.
@
text
@d274 1
a274 1
	if (n == 0)
d311 1
a311 1
	int i, n;
d314 18
a331 14
	for (i = 0; ; i++) {
		if (i >= 2)
			exit(1);

		(void)printf("Enter sequence count from 1 to %d: ",
		    SKEY_MAX_SEQ);
		(void)fgets(buf, bufsiz, stdin);
		clearerr(stdin);
		rip(buf);
		n = strtonum(buf, 1, SKEY_MAX_SEQ-1, &errstr);
		if (!errstr)
			break;	/* Valid range */
		fprintf(stderr, "ERROR: Count must be between 1 and %d\n",
		    SKEY_MAX_SEQ - 1);
a388 1
	*count= n;
@


1.62
log
@pledge "stdio rpath wpath cpath fattr flock tty"
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.61 2015/10/09 21:59:34 tim Exp $	*/
d322 1
@


1.61
log
@Remove telnet warnings. Civilization has reached a point where they are no
longer relevant.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.60 2015/10/06 15:09:08 tim Exp $	*/
d57 3
@


1.60
log
@Remove the -C option that converts an S/Key database to the new format. It has
been 13 years since the new format was introduced.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.59 2015/10/03 13:10:47 tim Exp $	*/
a179 6

	if (defaultsetup)
		fputs("Reminder - Only use this method if you are directly "
		    "connected\n           or have an encrypted channel.  If "
		    "you are using telnet,\n           hit return now and use "
		    "skeyinit -s.\n", stderr);
@


1.59
log
@- Simplify use of ctype functions.
- Replace arc4random with arc4random_uniform.
- Replace memset with explicit_bzero.

OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.58 2015/08/20 22:32:42 deraadt Exp $	*/
a43 1
void	convert_db(void);
d49 1
a49 1
	int     rval, i, l, n, defaultsetup, rmkey, hexmode, enable, convert;
d58 1
a58 1
	n = rmkey = hexmode = enable = convert = 0;
a107 3
			case 'C':
				convert = 1;
				break;
d129 1
a129 2
	if (argc > 1 || (enable && convert) || (enable && argc) ||
	    (convert && argc))
d132 3
a134 6
	/* Handle -C, -D, and -E */
	if (convert || enable) {
		if (convert)
			convert_db();
		else
			enable_db(enable);
a471 70
#define _PATH_SKEYKEYS	"/etc/skeykeys"
void
convert_db(void)
{
	struct passwd *pp;
	uid_t uid;
	FILE *keyfile;
	FILE *newfile;
	char buf[256], *logname, *hashtype, *seed, *val, *cp;
	char filename[PATH_MAX];
	const char *errstr;
	int fd, n;

	if ((keyfile = fopen(_PATH_SKEYKEYS, "r")) == NULL)
		err(1, "can't open %s", _PATH_SKEYKEYS);
	if (flock(fileno(keyfile), LOCK_EX) != 0)
		err(1, "can't lock %s", _PATH_SKEYKEYS);
	enable_db(1);

	/*
	 * Loop over each entry in _PATH_SKEYKEYS, creating a file
	 * in _PATH_SKEYDIR for each one.
	 */
	while (fgets(buf, sizeof(buf), keyfile) != NULL) {
		if (buf[0] == '#')
			continue;
		if ((logname = strtok(buf, " \t")) == NULL)
			continue;
		if ((cp = strtok(NULL, " \t")) == NULL)
			continue;
		if (!isalpha((unsigned char)*cp))
			continue;
		hashtype = cp;
		if ((cp = strtok(NULL, " \t")) == NULL)
			continue;
		n = strtonum(cp, 0, SKEY_MAX_SEQ, &errstr);
		if (errstr)
			continue;
		if ((seed = strtok(NULL, " \t")) == NULL)
			continue;
		if ((val = strtok(NULL, " \t")) == NULL)
			continue;

		if ((pp = getpwnam(logname)) != NULL)
			uid = pp->pw_uid;
		else
			uid = 0;

		/* Now write the new-style record. */
		if (snprintf(filename, sizeof(filename), "%s/%s", _PATH_SKEYDIR,
		    logname) >= sizeof(filename)) {
			warnc(ENAMETOOLONG, "%s", logname);
			continue;
		}
		fd = open(filename, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);
		if (fd == -1 || flock(fd, LOCK_EX) != 0 ||
		    (newfile = fdopen(fd, "r+")) == NULL) {
			warn("%s", logname);
			continue;
		}
		(void)fprintf(newfile, "%s\n%s\n%04d\n%s\n%s\n", logname,
			    hashtype, n, seed, val);
		(void)fchown(fileno(newfile), uid, -1);
		(void)fclose(newfile);
	}
	printf("%s has been populated.  NOTE: %s has *not* been removed.\n"
	    "It should be removed once you have verified that the new keys "
	    "work.\n", _PATH_SKEYDIR, _PATH_SKEYKEYS);
}

d477 1
a477 1
	(void)fprintf(stderr, "usage: %s [-CDErsx] [-a auth-type] [-n count]"
@


1.58
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.57 2015/04/18 18:28:38 deraadt Exp $	*/
a55 1
	u_int32_t noise;
d63 1
a63 1
	/* Build up a default seed based on the hostname and some noise */
d67 2
a68 11
		if (isalpha((unsigned char)hostname[i])) {
			if (isupper((unsigned char)hostname[i]))
				hostname[i] = tolower((unsigned char)hostname[i]);
			*p++ = hostname[i];
		} else if (isdigit((unsigned char)hostname[i]))
			*p++ = hostname[i];
	}
	noise = arc4random();
	for (i = 0; i < 5; i++) {
		*p++ = (noise % 10) + '0';
		noise /= 10;
d70 2
d437 1
a437 1
		memset(passwd, 0, sizeof(passwd));
d447 1
a447 1
		memset(passwd, 0, sizeof(passwd));
@


1.57
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.56 2015/01/16 06:40:11 deraadt Exp $	*/
d308 1
a308 1
	if ((skey.val = (char *)malloc(16 + 1)) == NULL)
@


1.56
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.55 2014/05/20 01:25:23 guenther Exp $	*/
d55 1
d112 2
a113 1
				if ((n = atoi(argv[i])) < 1 || n >= SKEY_MAX_SEQ)
d329 1
d341 2
a342 2
		n = atoi(buf);
		if (n > 0 && n < SKEY_MAX_SEQ)
d344 2
a345 2
		(void)fprintf(stderr, "ERROR: Count must be between 1 and %d\n",
			     SKEY_MAX_SEQ);
d498 1
d523 3
a525 1
		n = atoi(cp);
@


1.55
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.54 2014/04/23 18:24:23 ajacoutot Exp $	*/
a14 1
#include <sys/param.h>
d31 1
d51 1
a51 1
	char	hostname[MAXHOSTNAMELEN];
@


1.54
log
@Remove more Kerberos cruft.

ok jca@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.53 2014/03/20 20:39:13 naddy Exp $	*/
d223 3
a225 4
				    >= sizeof(filename)) {
					errno = ENAMETOOLONG;
					err(1, "Cannot remove S/Key entry");
				}
d277 3
a279 4
			    _PATH_SKEYDIR, pp->pw_name) >= sizeof(filename)) {
				errno = ENAMETOOLONG;
				err(1, "Cannot create S/Key entry");
			}
d533 1
a533 2
			errno = ENAMETOOLONG;
			warn("%s", logname);
@


1.53
log
@Remove the (non-default) MD4 hash algorithm from S/Key.
ok millert, man pages ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.52 2013/11/28 18:24:55 deraadt Exp $	*/
d187 1
a187 1
"    \"skeyinit -s -a krb5\" or \"skeyinit -s -a passwd\"\n\n"
@


1.52
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.51 2005/07/06 22:15:11 jmc Exp $	*/
d516 5
a520 6
		if (isalpha((unsigned char)*cp)) {
			hashtype = cp;
			if ((cp = strtok(NULL, " \t")) == NULL)
				continue;
		} else
			hashtype = "md4";
d561 1
a561 1
	    "\n\t[-md4 | -md5 | -rmd160 | -sha1] [user]\n", __progname);
@


1.51
log
@- tidy up SYNOPSIS
- sort options
- sync usage()
- more minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.50 2004/12/27 23:37:49 deraadt Exp $	*/
d67 3
a69 3
		if (isalpha(hostname[i])) {
			if (isupper(hostname[i]))
				hostname[i] = tolower(hostname[i]);
d71 1
a71 1
		} else if (isdigit(hostname[i]))
d244 4
a247 4
				if (isalpha(*p)) {
					if (isupper(*p))
						*p = tolower(*p);
				} else if (!isdigit(*p)) {
d256 2
a257 1
				if (isdigit(lastc) && lastc != '9') {
d262 2
a263 1
				if (isdigit(lastc) && lastc == '9' && l < 16) {
d361 1
a361 1
			if (isspace(*p)) {
d365 4
a368 4
			} else if (isalpha(*p)) {
				if (isupper(*p))
					*p = tolower(*p);
			} else if (!isdigit(*p)) {
d516 1
a516 1
		if (isalpha(*cp)) {
@


1.50
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.49 2004/09/14 22:58:57 deraadt Exp $	*/
d559 2
a560 3
	(void)fprintf(stderr, "usage: %s [-r] [-s] [-x] [-C] [-D] [-E] "
	    "[-a auth_type] [-n count]\n                "
	    "[-md4|-md5|-sha1|-rmd160] [user]\n", __progname);
@


1.49
log
@delete unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.48 2004/06/07 19:28:03 otto Exp $	*/
d427 1
a427 1
		} else if (strspn(passwd, "abcdefghijklmnopqrstuvwxyz") == 
@


1.48
log
@Allow -a to specify an alternative auth method, even if secure mode
is used. Only bail out if the user has no skey entry and requests
secure mode without specifying an alternative auth method.

ok hshoexer@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.47 2004/06/06 11:24:13 otto Exp $	*/
a43 1
void	timedout(int);
a551 9
}

#define TIMEOUT_MSG	"Timed out waiting for input.\n"
void
timedout(int signo)
{

	write(STDERR_FILENO, TIMEOUT_MSG, sizeof(TIMEOUT_MSG) - 1);
	_exit(1);
@


1.47
log
@First sequence number should be 100, as promised by man page.

ok hshoexer@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.46 2004/06/04 18:18:20 otto Exp $	*/
d96 1
a96 2
				if (auth_type == NULL)
					auth_type = argv[i];
d100 2
a101 1
				auth_type = "skey";
d182 1
a182 1
		if (!defaultsetup) {
@


1.46
log
@Consistently use "secret passphrase" for the passphrase made up by the user
and "one-time password" for the generated passwords.
ok jmc@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.45 2003/11/26 00:05:27 espie Exp $	*/
d293 1
a293 1
		n = 99;
@


1.45
log
@multi-line literals are not ANSI C.  And gcc3 complains about them.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.44 2003/05/07 20:39:29 deraadt Exp $	*/
d415 1
a415 1
		if (readpassphrase("Enter secret passphrase: ", passwd,
@


1.44
log
@bounds were sizeof(pointer) rather than size of the object; found with
anil's gcc bounds checker mod
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.43 2003/04/07 21:13:54 deraadt Exp $	*/
d184 7
a190 7
"You must authenticate yourself before using S/Key for the first time.  In
secure mode this is normally done via an existing S/Key key.  However, since
you do not have an entry in the S/Key database you will have to specify an
alternate authentication type via the `-a' flag, e.g.
    \"skeyinit -s -a krb5\" or \"skeyinit -s -a passwd\"\n
Note that entering a plaintext password over a non-secure link defeats the
purpose of using S/Key in the fist place.\n");
@


1.43
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.42 2003/04/06 21:07:38 deraadt Exp $	*/
d42 1
a42 1
void	secure_mode(int *, char *, char *, char *, size_t);
d301 1
a301 1
		secure_mode(&n, key, seed, buf, sizeof(buf));
d324 2
a325 1
secure_mode(int *count, char *key, char *seed, char *buf, size_t bufsiz)
d377 1
a377 1
		(void)strlcpy(seed, newseed, sizeof seed);
@


1.42
log
@strlcpy; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.41 2002/11/16 23:05:36 millert Exp $	*/
d258 2
a259 1
					(void)strcpy(seed, skey.seed);
d263 2
a264 1
					(void)strcpy(seed, skey.seed);
d376 1
a376 1
		(void)strcpy(seed, newseed);
@


1.41
log
@Give a sensible error message when a user who has no entry in /etc/skey
specifies the -s flag.  Also improve the error message when S/Key is disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.40 2002/06/23 03:07:22 deraadt Exp $	*/
d84 1
a84 1
	(void)strcpy(me, pp->pw_name);
@


1.40
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.39 2002/06/07 21:53:43 millert Exp $	*/
d96 2
a97 1
				auth_type = argv[i];
d171 25
d217 1
a217 4
			if (errno == ENOENT)
				errx(1, "S/Key disabled");
			else
				err(1, "cannot open database");
@


1.39
log
@The code to append the last 5 digits of the time in Unix format to
the default seed was lost in the flat file -> directory structure
conversion.  Instead of reinstating that, use arc4random() to get
some noise and append the last 5 digits to the seed.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.38 2002/06/07 21:35:26 millert Exp $	*/
d83 1
a83 1
		err(1, "no user with uid %d", getuid());
@


1.38
log
@Instead of passing seed and defaultseed to normal_mode() and
secure_mode() just pass in a single default seed.  Only secure_mode()
needs to actually change the seed and it can use its own temporary
buffer.

Fix zeroing of the secrete passphrase.  Instead of useing multiple
password buffers, crunch the key each time and compare the crunched
values.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.37 2002/06/06 20:56:02 aaron Exp $	*/
d56 1
d64 1
a64 1
	/* Build up a default seed based on the hostname and time */
d74 5
@


1.37
log
@Zero out memory filled in by readpassphrase(3). Also fix a spelling error;
markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.36 2002/05/19 02:09:28 millert Exp $	*/
d42 2
a43 2
void	secure_mode(int *, char *, char *, char *, char *, size_t);
void	normal_mode(char *, int, char *, char *, char *);
d53 1
a53 1
	char	seed[SKEY_MAX_SEED_LEN + 2], defaultseed[SKEY_MAX_SEED_LEN + 1];
d66 1
a66 1
	for (i = 0, p = defaultseed; hostname[i] && i < SKEY_NAMELEN; i++) {
d229 2
a230 2
					(void)strcpy(defaultseed, skey.seed);
					defaultseed[l - 1] = lastc + 1;
d233 4
a236 4
					(void)strcpy(defaultseed, skey.seed);
					defaultseed[l - 1] = '0';
					defaultseed[l] = '0';
					defaultseed[l + 1] = '\0';
d270 1
a270 1
		secure_mode(&n, key, seed, defaultseed, buf, sizeof(buf));
d272 1
a272 1
		normal_mode(pp->pw_name, n, key, seed, defaultseed);
d286 1
a286 1
		     skey_get_algorithm(), n, seed);
d293 1
a293 2
secure_mode(int *count, char *key, char *seed, char *defaultseed, char *buf,
    size_t bufsiz)
d295 1
a296 1
	char *p;
d318 2
a319 3
		(void)printf("Enter new seed [default %s]: ",
			     defaultseed);
		(void)fgets(seed, SKEY_MAX_SEED_LEN+2, stdin); /* XXX */
d321 2
a322 2
		rip(seed);
		if (strlen(seed) > SKEY_MAX_SEED_LEN) {
d327 1
a327 3
		if (seed[0] == '\0')
			(void)strcpy(seed, defaultseed);
		for (p = seed; *p; p++) {
d344 2
d373 1
a373 1
normal_mode(char *username, int n, char *key, char *seed, char *defaultseed)
d376 1
a376 1
	char passwd[SKEY_MAX_PW_LEN+2], passwd2[SKEY_MAX_PW_LEN+2];
a379 3
		memset(passwd, 0, sizeof(passwd));
		memset(passwd2, 0, sizeof(passwd2));

d381 1
a381 1
			exit(1);
d409 17
a425 2
		if (readpassphrase("Again secret passphrase: ", passwd2,
		    sizeof(passwd2), 0) && strcmp(passwd, passwd2) == 0)
a429 5

	/* Crunch seed and passphrase into starting key */
	(void)strcpy(seed, defaultseed);
	if (keycrunch(key, seed, passwd) != 0)
		err(2, "key crunch failed");
@


1.36
log
@ o Fix some fallout from argv handling changes.
 o Use ANSI function headers
 o When creating a new user record cope with the fact that there may be
   an existing zero-length userrecord.
 o Replace -z with -r in usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.35 2002/05/17 15:54:13 millert Exp $	*/
d382 3
d405 2
a406 1
			    "numbers, and puctuation are suggested.\n", stderr);
@


1.35
log
@Replace -z option (zero) with -r option (remove).
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.34 2002/05/17 00:55:54 millert Exp $	*/
d41 1
a41 1
void	usage(char *);
d49 1
a49 3
main(argc, argv)
	int     argc;
	char   *argv[];
d89 1
a89 1
					usage(argv[0]);
d104 1
a104 1
					usage(argv[0]);
d119 1
a119 1
				usage(argv[0]);
d125 1
a125 1
				usage(argv[0]);
d135 1
a135 1
		usage(argv[0]);
d148 1
a148 1
		if ((pp = getpwnam(argv[i])) == NULL) {
d152 1
a152 1
				_pp.pw_name = argv[i];
d154 1
a154 1
				warnx("Warning, user unknown: %s", argv[i]);
d156 1
a156 1
				errx(1, "User unknown: %s", argv[i]);
d250 2
a251 1
			if ((l = open(filename, O_RDWR | O_CREAT | O_EXCL,
d293 2
a294 7
secure_mode(count, key, seed, defaultseed, buf, bufsiz)
	int *count;
	char *key;
	char *seed;
	char *defaultseed;
	char *buf;
	size_t bufsiz;
d375 1
a375 6
normal_mode(username, n, key, seed, defaultseed)
	char *username;
	int n;
	char *key;
	char *seed;
	char *defaultseed;
d428 1
a428 2
enable_db(op)
	int op;
d516 1
a516 2
timedout(signo)
	int signo;
d524 1
a524 2
usage(s)
	char *s;
d526 3
a528 1
	(void)fprintf(stderr, "usage: %s [-s] [-x] [-z] [-C] [-D] [-E] "
d530 1
a530 1
	    "[-md4|-md5|-sha1|-rmd160] [user]\n", s);
@


1.34
log
@Call enable_db() from convert_db() so the dir creation as well as
mode/user/group setting is done in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.33 2002/05/16 17:54:34 millert Exp $	*/
d53 1
a53 1
	int     rval, i, l, n, defaultsetup, zerokey, hexmode, enable, convert;
d61 1
a61 1
	n = zerokey = hexmode = enable = convert = 0;
d101 2
a102 2
			case 'z':
				zerokey = 1;
d193 14
a206 3
			/* comment out user if asked to */
			if (zerokey)
				exit(skeyzero(&skey));
d243 2
a244 2
			if (zerokey)
				errx(1, "You have no entry to zero.");
@


1.33
log
@Add missing chown(2) call.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.32 2002/05/16 03:50:42 millert Exp $	*/
d140 7
a146 4
	if (enable)
		enable_db(enable);
	if (convert)
		convert_db();
a443 1
	exit(0);
d462 1
a462 4
	if (mkdir(_PATH_SKEYDIR, 01730) != 0 && errno != EEXIST)
		err(1, "can't mkdir %s", _PATH_SKEYDIR);
	if (chmod(_PATH_SKEYDIR, 01730) != 0)
		err(1, "can't chmod %s", _PATH_SKEYDIR);
a512 1
	exit(0);
@


1.32
log
@Change S/Key stuff from using a flat file (/etc/skeykeys) to a directory
where each user gets their own file, which is owned by that user.

An old S/Key database may be converted by running "skeyinit -C" as root.

Programs that need to access the S/Key database no longer need to be
setuid root.  They must now be setgid auth instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.31 2002/02/16 21:27:52 millert Exp $	*/
d432 2
@


1.31
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.30 2001/11/01 18:26:58 miod Exp $	*/
d17 2
a19 1
#include <sys/resource.h>
d21 1
a23 1
#include <ctype.h>
d35 1
a40 1
void	lockeof(struct skey *, char *);
d45 2
d53 1
a53 4
	int     rval, i, l, n=0, defaultsetup=1, zerokey=0, hexmode=0;
	int	oldmd4=0;
	time_t  now;
	size_t	seedlen;
d55 3
a57 4
	char    passwd[SKEY_MAX_PW_LEN+2];
	char	seed[SKEY_MAX_SEED_LEN+2], defaultseed[SKEY_MAX_SEED_LEN+1];
	char    tbuf[27], buf[256], key[SKEY_BINKEY_SIZE];
	char    lastc, me[UT_NAMESIZE+1], *salt, *p, *ht=NULL;
a59 1
	struct tm *tm;
d61 3
a63 2
	if (geteuid() != 0)
		errx(1, "must be setuid root.");
a76 3
	(void)time(&now);
	(void)sprintf(tbuf, "%05ld", (long) (now % 100000));
	(void)strncat(defaultseed, tbuf, sizeof(defaultseed) - 5);
a83 1
	salt = pp->pw_passwd;
d89 5
d96 1
d111 9
d132 2
d135 2
a136 2
	/* check for optional user string */
	if (argc - i  > 1) {
d138 9
a146 1
	} else if (argv[i]) {
d157 3
a159 5
		} else if (strcmp(pp->pw_name, me) != 0) {
			if (getuid() != 0) {
				/* Only root can change other's passwds */
				errx(1, "Permission denied.");
			}
d164 4
a167 1
		fputs("Reminder - Only use this method if you are directly connected\n           or have an encrypted channel.  If you are using telnet\n           or rlogin, hit return now and use skeyinit -s.\n", stderr);
d170 4
a173 24
		/* XXX - use BSD auth */
		passwd[0] = '\0';
		if (!defaultsetup && skeychallenge(&skey, me, buf) == 0) {
			printf("Enter S/Key password below or hit return twice "
			    "to enter standard password.\n%s\n", buf);
			fflush(stdout);
			if (!readpassphrase("S/Key Password: ", passwd,
			    sizeof(passwd), 0) || passwd[0] == '\0') {
				readpassphrase("S/Key Password: [echo on] ",
				    passwd, sizeof(passwd), RPP_ECHO_ON);
			}
		}
		if (passwd[0]) {
			if (skeyverify(&skey, passwd) != 0)
				errx(1, "Password incorrect.");
		} else {
			fflush(stdout);
			readpassphrase("Password: ", passwd, sizeof(passwd), 0);
			if (strcmp(crypt(passwd, salt), pp->pw_passwd)) {
				if (passwd[0])
					warnx("Password incorrect.");
				exit(1);
			}
		}
d233 10
a242 1
			lockeof(&skey, pp->pw_name);
d245 3
a250 5
	/* Do we have an old-style md4 entry? */
	if (rval == 0 && strcmp("md4", skey_get_algorithm()) == 0 &&
	    strcmp("md4", skey.logname + strlen(skey.logname) + 1) != 0)
		oldmd4 = 1;

d262 1
a262 36
	(void)time(&now);
	tm = localtime(&now);
	(void)strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);

	/* If this is an exiting entry, compute the line length and seed pad */
	seedlen = SKEY_MAX_SEED_LEN;
	if (rval == 0) {
		int nlen;

		nlen = strlen(pp->pw_name) + 1 + strlen(skey_get_algorithm()) +
		    1 + 4 + 1 + strlen(seed) + 1 + 16 + 1 + strlen(tbuf) + 1;

		/*
		 * If there was no hash type (md4) add one unless we
		 * are short on space.
		 */ 
		if (oldmd4) {
			if (nlen > skey.len)
				nlen -= 4;
			else
				oldmd4 = 0;
		}

		/* If new entry is longer than the old, comment out the old. */
		if (nlen > skey.len) {
			(void)skeyzero(&skey);
			/* Re-open keys file and seek to the end */
			if (skeylookup(&skey, pp->pw_name) == -1)
				err(1, "cannot reopen database");
			lockeof(&skey, pp->pw_name);
		} else {
			/* Compute how much to space-pad the seed */
			seedlen = strlen(seed) + (skey.len - nlen);
		}
	}

d267 3
a269 9
	/* Don't save algorithm type for md4 (maintain record length) */
	/* XXX - should check return values of fprintf + fclose */
	if (oldmd4)
		(void)fprintf(skey.keyfile, "%s %04d %-*s %s %-21s\n",
		    pp->pw_name, n, seedlen, seed, skey.val, tbuf);
	else
		(void)fprintf(skey.keyfile, "%s %s %04d %-*s %s %-21s\n",
		    pp->pw_name, skey_get_algorithm(), n, seedlen, seed,
		    skey.val, tbuf);
a279 29
lockeof(mp, user)
	struct skey *mp;
	char *user;
{
	struct flock fl;

	fseek(mp->keyfile, 0, SEEK_END);
dolock:
	fl.l_start = ftell(mp->keyfile);
	fl.l_len = mp->len;
	fl.l_pid = getpid();
	fl.l_type = F_WRLCK;
	fl.l_whence = SEEK_SET;

	if (fcntl(fileno(mp->keyfile), F_SETLKW, &fl) == -1)
		err(1, "Can't lock database");

	/* Make sure we are still at the end. */
	fseek(mp->keyfile, 0, SEEK_END);
	if (fl.l_start == ftell(mp->keyfile))
		return;		/* still at EOF */

	fclose(mp->keyfile);
	if (skeylookup(mp, user) != 1)
		errx(1, "user %s already added", user);
	goto dolock;
}

void
d424 91
d529 3
a531 2
	(void)fprintf(stderr,
		"Usage: %s [-s] [-x] [-z] [-n count] [-md4|-md5|-sha1|-rmd160] [user]\n", s);
@


1.30
log
@printf() format string fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.28 2001/06/20 22:25:08 millert Exp $	*/
d39 5
a43 5
void	lockeof __P((struct skey *, char *));
void	usage __P((char *));
void	secure_mode __P((int *, char *, char *, char *, char *, size_t));
void	normal_mode __P((char *, int, char *, char *, char *));
void	timedout __P((int));
@


1.29
log
@skeyzero() now takes 1 arg
@
text
@d297 1
a297 1
		(void)fprintf(skey.keyfile, "%s %04d %-* %s %-21s\n",
@


1.28
log
@o When converting from a different hash type, if there is room on the line
  we don't need to comment out the existing entry since the key almost
  never takes up as much room as is allocated for it.
o Do per-record locking (and timeout) now that libskey does.
o Rearrange the code into functions.
o Use readpassphrase()
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.27 2001/01/26 16:27:04 millert Exp $	*/
d191 1
a191 1
				exit(skeyzero(&skey, pp->pw_name));
d279 1
a279 1
			(void)skeyzero(&skey, pp->pw_name);
@


1.27
log
@It is pronounced S/Key
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.26 2001/01/26 16:25:34 millert Exp $	*/
d3 1
a3 1
/* S/KEY v1.1b (skeyinit.c)
a9 2
 *
 * Modifications:
d12 1
a12 1
 * S/KEY initialization and seed update
d24 1
d39 1
d41 3
d50 2
a51 1
	int     rval, nn, i, l, n=0, defaultsetup=1, zerokey=0, hexmode=0;
d53 1
d55 1
a55 1
	char    passwd[SKEY_MAX_PW_LEN+2], passwd2[SKEY_MAX_PW_LEN+2];
d57 2
a58 2
	char    tbuf[27], buf[80], key[SKEY_BINKEY_SIZE];
	char    lastc, me[UT_NAMESIZE+1], *salt, *p, *pw, *ht=NULL;
d66 1
d145 3
d149 14
a162 5
		pw = getpass("Password (or `s/key'):");
		if (strcasecmp(pw, "s/key") == 0) {
			if (skey_haskey(me))
				exit(1);
			if (skey_authenticate(me))
d165 7
a171 3
			p = crypt(pw, salt);
			if (strcmp(p, pp->pw_passwd))
				errx(1, "Password incorrect.");
d175 5
d193 4
a196 3
			(void)printf("[Updating %s]\n", pp->pw_name);
			(void)printf("Old key: [%s] %s\n", skey_get_algorithm(),
				     skey.seed);
d212 1
a212 4
			/*
			 * Let's be nice if they have an skey.seed that
			 * ends in 0-8 just add one
			 */
d230 3
a232 1
			(void)printf("[Adding %s]\n", pp->pw_name);
d238 5
d244 9
a252 5
	if (ht) {
		/* Need to zero out old key when changing algorithm */
		if (strcmp(ht, skey_get_algorithm()) && skey_set_algorithm(ht))
			zerokey = 1;
	}
d254 3
a256 5
	if (!defaultsetup) {
		(void)printf("You need the 6 english words generated from the \"skey\" command.\n");
		for (i = 0; ; i++) {
			if (i >= 2)
				exit(1);
d258 17
a274 8
			(void)printf("Enter sequence count from 1 to %d: ",
				     SKEY_MAX_SEQ);
			(void)fgets(buf, sizeof(buf), stdin);
			n = atoi(buf);
			if (n > 0 && n < SKEY_MAX_SEQ)
				break;	/* Valid range */
			(void)printf("Error: Count must be > 0 and < %d\n",
				     SKEY_MAX_SEQ);
d277 10
a286 26
		for (i = 0;; i++) {
			if (i >= 2)
				exit(1);

			(void)printf("Enter new key [default %s]: ",
				     defaultseed);
			(void)fgets(seed, sizeof(seed), stdin);
			rip(seed);
			if (seed[0] == '\0')
				(void)strcpy(seed, defaultseed);
			for (p = seed; *p; p++) {
				if (isalpha(*p)) {
					if (isupper(*p))
						*p = tolower(*p);
				} else if (!isdigit(*p)) {
					(void)puts("Error: seed may only contain alpha numeric characters");
					break;
				}
			}
			if (*p == '\0')
				break;  /* Valid seed */
		}
		if (strlen(seed) > SKEY_MAX_SEED_LEN) {
			(void)printf("Notice: Seed truncated to %d characters.\n",
				     SKEY_MAX_SEED_LEN);
			seed[SKEY_MAX_SEED_LEN] = '\0';
d288 1
d290 3
a292 3
		for (i = 0;; i++) {
			if (i >= 2)
				exit(1);
d294 10
a303 18
			(void)printf("otp-%s %d %s\nS/Key access password: ",
				     skey_get_algorithm(), n, seed);
			(void)fgets(buf, sizeof(buf), stdin);
			rip(buf);
			backspace(buf);

			if (buf[0] == '?') {
				(void)puts("Enter 6 English words from secure S/Key calculation.");
				continue;
			} else if (buf[0] == '\0')
				exit(1);
			if (etob(key, buf) == 1 || atob8(key, buf) == 0)
				break;	/* Valid format */
			(void)puts("Invalid format - try again with 6 English words.");
		}
	} else {
		/* Get user's secret password */
		fputs("Reminder - Only use this method if you are directly connected\n           or have an encrypted channel.  If you are using telnet\n           or rlogin, exit with no password and use skeyinit -s.\n", stderr);
d305 6
a310 3
		for (i = 0;; i++) {
			if (i > 2)
				exit(1);
d312 6
a317 4
			(void)fputs("Enter secret password: ", stderr);
			readpass(passwd, sizeof(passwd));
			if (passwd[0] == '\0')
				exit(1);
d319 33
a351 11
			if (strlen(passwd) < SKEY_MIN_PW_LEN) {
				(void)fprintf(stderr,
				    "Your password must be at least %d characters long.\n", SKEY_MIN_PW_LEN);
				continue;
			} else if (strcmp(passwd, pp->pw_name) == 0) {
				(void)fputs("Your password may not be the same as your user name.\n", stderr);
				continue;
			} else if (strspn(passwd, "abcdefghijklmnopqrstuvwxyz") == strlen(passwd)) {
				(void)fputs("Your password must contain more than just lower case letters.\nWhitespace, numbers, and puctuation are suggested.\n", stderr);
				continue;
			}
d353 15
a367 2
			(void)fputs("Again secret password: ", stderr);
			readpass(passwd2, sizeof(passwd));
d369 20
a388 1
			if (strcmp(passwd, passwd2) == 0)
d390 8
a397 2

			(void)fputs("Passwords do not match.\n", stderr);
d399 3
d403 21
a423 8
		/* Crunch seed and password into starting key */
		(void)strcpy(seed, defaultseed);
		if (keycrunch(key, seed, passwd) != 0)
			err(2, "key crunch failed");

		nn = n;
		while (nn-- != 0)
			f(key);
d425 2
a426 3
	(void)time(&now);
	tm = localtime(&now);
	(void)strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);
d428 10
a437 2
	if ((skey.val = (char *)malloc(16 + 1)) == NULL)
		err(1, "Can't allocate memory");
d439 29
a467 7
	/* Zero out old key if necesary (entry would change size) */
	if (zerokey) {
		(void)skeyzero(&skey, pp->pw_name);
		/* Re-open keys file and seek to the end */
		if (skeylookup(&skey, pp->pw_name) == -1)
			err(1, "cannot open database");
	}
d469 3
a471 1
	btoa8(skey.val, key);
d473 1
a473 13
	/*
	 * Obtain an exclusive lock on the key file so we don't
	 * clobber someone authenticating themselves at the same time.
	 */
	for (i = 0; i < 300; i++) {
		if ((rval = flock(fileno(skey.keyfile), LOCK_EX|LOCK_NB)) == 0
		    || errno != EWOULDBLOCK)
			break;
		usleep(100000);			/* Sleep for 0.1 seconds */
	}
	if (rval == -1)	{			/* Can't get exclusive lock */
		errno = EAGAIN;
		err(1, "cannot open database");
d476 15
a490 9
	/* Don't save algorithm type for md4 (keep record length same) */
	if (strcmp(skey_get_algorithm(), "md4") == 0)
		(void)fprintf(skey.keyfile, "%s %04d %-16s %s %-21s\n",
		    pp->pw_name, n, seed, skey.val, tbuf);
	else
		(void)fprintf(skey.keyfile, "%s %s %04d %-16s %s %-21s\n",
		    pp->pw_name, skey_get_algorithm(), n, seed, skey.val, tbuf);

	(void)fclose(skey.keyfile);
d492 2
a493 5
	(void)printf("\nID %s skey is otp-%s %d %s\n", pp->pw_name,
		     skey_get_algorithm(), n, seed);
	(void)printf("Next login password: %s\n\n",
		     hexmode ? put8(buf, key) : btoe(buf, key));
	exit(0);
@


1.26
log
@Fix stupid bug in last commit that caused the hostname not to
be used as part of the seed for first time users.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.25 2000/11/16 15:15:58 millert Exp $	*/
d157 1
a157 1
				errx(1, "s/key disabled");
@


1.25
log
@When building default seed from the hostname, only use alphanumeric
characters and make things lower case.  Also sanity check the
existing seed in skeykeys since we can't be sure it is completely
sane.  Problem noted by wozz@@wookie.net
@
text
@d1 1
a1 2
/*	$OpenBSD: skeyinit.c,v 1.24 1999/09/10 10:09:28 millert Exp $	*/
/*	$NetBSD: skeyinit.c,v 1.6 1995/06/05 19:50:48 pk Exp $	*/
d65 3
a67 2
			if (isupper(*p))
				*p++ = tolower(hostname[i]);
@


1.24
log
@Don't unlock the skeykeys file before the fclose since stdio may still have some data buffered.  Closing the file is enough to unlock it.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.23 1999/03/02 21:55:53 deraadt Exp $	*/
d64 8
a71 2
	(void)strncpy(defaultseed, hostname, sizeof(defaultseed) - 1);
	defaultseed[SKEY_NAMELEN] = '\0';
d171 14
a187 1
			l = strlen(skey.seed);
d242 2
d260 1
a260 2
		} else if (seed[0] == '\0')
			(void)strcpy(seed, defaultseed);
@


1.23
log
@do not crash if -n has no arg; spotted by weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.22 1998/08/22 19:29:46 dgregor Exp $	*/
a343 1
	(void)flock(fileno(skey.keyfile), LOCK_UN);
@


1.22
log
@Changed warning message from "... keyinit -s" to "... skeyinit -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.21 1998/07/09 17:04:00 millert Exp $	*/
d92 1
a92 1
				if (argv[++i][0] == '\0')
@


1.21
log
@say "s/key disabled" if skeykeys file does not exist.  I thought I committed this ages ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.20 1997/07/27 21:36:05 millert Exp $	*/
d263 1
a263 1
		fputs("Reminder - Only use this method if you are directly connected\n           or have an encrypted channel.  If you are using telnet\n           or rlogin, exit with no password and use keyinit -s.\n", stderr);
@


1.20
log
@- Do coarse locking on /etc/skeykeys so we don't clobber
  an entry that is being updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.19 1997/07/25 00:27:30 millert Exp $	*/
d150 5
a154 1
			err(1, "cannot open database");
@


1.19
log
@Protect users from themselves.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.18 1997/07/17 05:48:41 millert Exp $	*/
d12 3
d19 1
d24 1
a146 2
	(void)setpriority(PRIO_PROCESS, 0, -4);

d317 15
d339 2
a341 2

	(void)setpriority(PRIO_PROCESS, 0, 0);
@


1.18
log
@Add RIPEMD-160 (rmd160) support to OTP (s/key).
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.17 1996/11/03 18:57:46 millert Exp $	*/
d19 3
d25 2
a26 2
#include <err.h>
#include <pwd.h>
a27 1
#include <time.h>
d29 1
a29 1
#include <ctype.h>
d268 8
a275 2
				(void)fputs("Your password must be longer.\n",
					    stderr);
@


1.17
log
@Use new length/size macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.16 1996/10/23 18:09:27 millert Exp $	*/
d329 1
a329 1
		"Usage: %s [-s] [-x] [-z] [-n count] [-md4|-md5|-sha1] [user]\n", s);
@


1.16
log
@Allow root to add entry for login that does not exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.15 1996/10/14 03:10:07 millert Exp $	*/
a29 3
#ifndef SKEY_MAXSEQ
#define SKEY_MAXSEQ	10000
#endif
d31 1
a31 4
#define SKEY_NAMELEN	4
#endif
#ifndef SKEY_MIN_PW_LEN
#define SKEY_MIN_PW_LEN	10
d41 1
a41 1
	int     rval, n, nn, i, l, defaultsetup=1, zerokey=0, hexmode=0;
d44 3
a46 2
	char    seed[18], tmp[80], key[8], defaultseed[17];
	char    passwd[256], passwd2[256], tbuf[27], buf[60];
a54 3
	(void)time(&now);
	(void)sprintf(tbuf, "%05ld", (long) (now % 100000));

d59 2
d84 7
d156 1
a156 1
			 * Lets be nice if they have a skey.seed that
d180 2
a181 1
	n = 99;
d192 1
a192 1
		for (i = 0;; i++) {
d197 4
a200 4
				     SKEY_MAXSEQ);
			(void)fgets(tmp, sizeof(tmp), stdin);
			n = atoi(tmp);
			if (n > 0 && n < SKEY_MAXSEQ)
d203 1
a203 1
				     SKEY_MAXSEQ);
d226 5
a230 5
		if (strlen(seed) > 16) {
			(void)puts("Notice: Seed truncated to 16 characters.");
			seed[16] = '\0';
		}
		if (seed[0] == '\0')
d239 3
a241 3
			(void)fgets(tmp, sizeof(tmp), stdin);
			rip(tmp);
			backspace(tmp);
d243 1
a243 1
			if (tmp[0] == '?') {
d246 1
a246 1
			} else if (tmp[0] == '\0')
d248 1
a248 1
			if (etob(key, tmp) == 1 || atob8(key, tmp) == 0)
d329 1
a329 1
		"Usage: %s [-s] [-x] [-z] [-md4|-md5|-sha1] [user]\n", s);
@


1.15
log
@Fixed a bug in skeylookup() so no need for extra skey_set_algorithm.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.14 1996/10/08 16:31:45 millert Exp $	*/
d75 1
d107 11
a117 4
		if ((pp = getpwnam(argv[i])) == NULL)
			err(1, "User unknown");

		if (strcmp(pp->pw_name, me) != 0) {
a123 1
	salt = pp->pw_passwd;
a270 2
			if (passwd2[0] == '\0')
				exit(1);
@


1.14
log
@reset hash type after zeroing when changing hash type, from dm.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.13 1996/10/02 18:11:30 millert Exp $	*/
a294 1
		skey_set_algorithm(ht);
@


1.13
log
@When changing hash algorithms comment out the old entry so we
don't overflow the old fixed length record.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.12 1996/10/02 03:49:34 millert Exp $	*/
d295 1
@


1.12
log
@Fix a bug wrt handling of old md4 entries.  Now don't save a type with md4
so we don't go over the record size and munge other entries.  Don't export
symbols we don't need to in put.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.11 1996/09/30 18:49:55 millert Exp $	*/
d175 5
a179 2
	if (ht)
		skey_set_algorithm(ht);
d289 8
d301 1
a301 1
		(void)fprintf(skey.keyfile, "%s s %04d %-16s %s %-21s\n",
@


1.11
log
@Fixed up docs and improved skeyinit's passwd prompt.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.10 1996/09/30 06:30:43 millert Exp $	*/
d144 2
a145 1
			(void)printf("Old key: %s\n", skey.seed);
d288 7
a294 2
	(void)fprintf(skey.keyfile, "%s %s %04d %-16s %s %-21s\n",
	    pp->pw_name, skey_get_algorithm(), n, seed, skey.val, tbuf);
d299 2
a300 1
	(void)printf("\nID %s skey is %d %s\n", pp->pw_name, n, seed);
@


1.10
log
@In -s mode, now checks that seed is pure alphanum and converts chars
to lowercase.  Also fixed prompt in -s mode to be rfc1938 compliant.
You may now enter "s/key" as the password and get in via an s/key
challenge, the lack of which was pointed out by dm.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.9 1996/09/29 23:11:04 millert Exp $	*/
d119 1
a119 1
		pw = getpass("Password:");
@


1.9
log
@RFC 1938 says min passwd len is 10...
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.8 1996/09/29 21:28:42 millert Exp $	*/
a117 2
	(void)setpriority(PRIO_PROCESS, 0, -4);

a118 2
		(void)setpriority(PRIO_PROCESS, 0, -4);

d120 11
a130 1
		p = crypt(pw, salt);
d132 1
a132 5
		(void)setpriority(PRIO_PROCESS, 0, 0);

		if (pp && strcmp(p, pp->pw_passwd))
			errx(1, "Password incorrect.");
	}
d182 1
d189 1
a189 1
			(void)printf("\n Error: Count must be > 0 and < %d\n",
d193 20
a212 4
		(void)printf("Enter new key [default %s]: ", defaultseed);
		(void)fflush(stdout);
		(void)fgets(seed, sizeof(seed), stdin);
		rip(seed);
d224 2
a225 2
			(void)printf("skey %d %s\nskey access password: ",
			    n, seed);
d290 3
d294 2
a295 2
	(void)printf("Next login password: %s\n", hexmode ? put8(buf, key) : btoe(buf, key));

@


1.8
log
@Works with new libskey and supports SHA.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.7 1996/09/29 04:34:08 millert Exp $	*/
d37 1
a37 1
#define SKEY_MIN_PW_LEN	4
@


1.7
log
@Added support for MD4/MD5 as an argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.6 1996/09/28 17:35:25 millert Exp $	*/
d40 2
d47 1
a47 1
	int     rval, n, nn, i, l, md=0, defaultsetup=1, zerokey=0, hexmode=0;
d52 1
a52 1
	char    lastc, me[UT_NAMESIZE+1], *salt, *p, *pw;
d76 4
a79 2
	while ((i = getopt(argc, argv, "sxz45")) != EOF) {
		switch (i) {
d89 9
a97 17
			case '4':
				md = 4;
				break;
			case '5':
				md = 5;
				break;
		}
	}

	/* check for md4/md5 argument */
	if (argv[optind]) {
		if (strcmp(argv[optind], "MD4") == 0) {
			md = 4;
			optind++;
		} else if (strcmp(argv[optind], "MD5") == 0) {
			md = 5;
			optind++;
d99 1
d103 4
a106 7
	if (argc - optind  > 1) {
		(void)fprintf(stderr,
			"Usage: %s [-s] [-x] [-z] [-4|-5] [MD4|MD5] [user]\n",
			argv[0]);
		exit(1);
	} else if (argv[optind]) {
		if ((pp = getpwnam(argv[optind])) == NULL)
d171 3
a173 3
	/* Set MDX (currently 4 or 5) if given the option */
	if (md)
		skey_set_MDX(md);
d268 2
a269 2
	(void)fprintf(skey.keyfile, "%s MD%d %04d %-16s %s %-21s\n",
	    pp->pw_name, skey_get_MDX(), n, seed, skey.val, tbuf);
d275 9
@


1.6
log
@strings for username are of size UT_NAMESIZE
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.5 1996/09/28 00:04:44 millert Exp $	*/
d50 1
a50 1
	char    lastc, me[UT_NAMESIZE], *salt, *p, *pw;
d93 13
d108 2
a109 1
			"Usage: %s [-s] [-x] [-z] [-4|-5] [user]\n", argv[0]);
d211 1
a211 1
			(void)printf("s/key %d %s\ns/key access password: ",
d277 1
a277 1
	(void)printf("\nID %s s/key is %d %s\n", pp->pw_name, n, seed);
@


1.5
log
@Less easily guessed seed.  From logdaemon package.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.4 1996/09/27 15:49:04 millert Exp $	*/
d26 1
d50 1
a50 1
	char    lastc, me[80], *salt, *p, *pw;
@


1.4
log
@Now can deal with both MD4 and MD5 s/key's.
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.3 1996/06/26 05:39:24 deraadt Exp $	*/
d58 1
a58 2
	tm = localtime(&now);
	(void)strftime(tbuf, sizeof(tbuf), "%M%j", tm);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: skeyinit.c,v 1.6 1995/06/05 19:50:48 pk Exp $	*/
d27 1
d29 9
a37 6
#include "skey.h"

#define NAMELEN 2

int skeylookup __ARGS((struct skey * mp, char *name));
int skeyzero __ARGS((struct skey * mp, char *name));
d44 1
a44 1
	int     rval, n, nn, i, defaultsetup, l, zerokey = 0;
d49 1
a49 1
	char    lastc, me[80], user[8], *salt, *p, *pw;
d54 4
a57 1
	time(&now);
d59 1
a59 1
	strftime(tbuf, sizeof(tbuf), "%M%j", tm);
d63 3
a65 3
	strncpy(defaultseed, hostname, sizeof(defaultseed)- 1);
	defaultseed[4] = '\0';
	strncat(defaultseed, tbuf, sizeof(defaultseed) - 5);
d69 1
a69 1
	strcpy(me, pp->pw_name);
d74 17
a90 9
	defaultsetup = 1;
	for (i=1; i < argc; i++) {
		if (strcmp("-s", argv[i]) == 0)
			defaultsetup = 0;
		else if (strcmp("-z", argv[i]) == 0)
			zerokey = 1;
		else {
			pp = getpwnam(argv[i]);
			break;
d93 13
a105 8
	if (pp == NULL) {
		err(1, "User unknown");
	}
	if (strcmp(pp->pw_name, me) != 0) {
		if (getuid() != 0) {
			/* Only root can change other's passwds */
			printf("Permission denied.\n");
			exit(1);
d110 1
a110 1
	setpriority(PRIO_PROCESS, 0, -4);
d113 1
a113 1
		setpriority(PRIO_PROCESS, 0, -4);
d118 1
a118 1
		setpriority(PRIO_PROCESS, 0, 0);
d120 2
a121 4
		if (pp && strcmp(p, pp->pw_passwd)) {
			printf("Password incorrect.\n");
			exit(1);
		}
d123 1
d126 27
a152 20
	case -1:
		err(1, "cannot open database");
	case 0:
		/* comment out user if asked to */
		if (zerokey)
			exit(skeyzero(&skey, pp->pw_name));

		printf("[Updating %s]\n", pp->pw_name);
		printf("Old key: %s\n", skey.seed);

		/*
		 * lets be nice if they have a skey.seed that
		 * ends in 0-8 just add one
		 */
		l = strlen(skey.seed);
		if (l > 0) {
			lastc = skey.seed[l - 1];
			if (isdigit(lastc) && lastc != '9') {
				strcpy(defaultseed, skey.seed);
				defaultseed[l - 1] = lastc + 1;
d154 6
a159 15
			if (isdigit(lastc) && lastc == '9' && l < 16) {
				strcpy(defaultseed, skey.seed);
				defaultseed[l - 1] = '0';
				defaultseed[l] = '0';
				defaultseed[l + 1] = '\0';
			}
		}
		break;
	case 1:
		if (zerokey) {
			printf("You have no entry to zero.\n");
			exit(1);
		}
		printf("[Adding %s]\n", pp->pw_name);
		break;
d163 4
d168 1
a168 1
		printf("You need the 6 english words generated from the \"key\" command.\n");
d172 3
a174 2
			printf("Enter sequence count from 1 to 10000: ");
			fgets(tmp, sizeof(tmp), stdin);
d176 1
a176 1
			if (n > 0 && n < 10000)
d178 2
a179 1
			printf("\n Error: Count must be > 0 and < 10000\n");
d181 4
a184 5
	}
	if (!defaultsetup) {
		printf("Enter new key [default %s]: ", defaultseed);
		fflush(stdout);
		fgets(seed, sizeof(seed), stdin);
d187 1
a187 1
			printf("Notice: Seed truncated to 16 characters.\n");
d191 1
a191 1
			strcpy(seed, defaultseed);
d197 3
a199 2
			printf("s/key %d %s\ns/key access password: ", n, seed);
			fgets(tmp, sizeof(tmp), stdin);
d204 1
a204 1
				printf("Enter 6 English words from secure S/Key calculation.\n");
d206 1
a206 2
			}
			if (tmp[0] == '\0') {
a207 1
			}
d210 1
a210 1
			printf("Invalid format - try again with 6 English words.\n");
d214 2
d217 1
a217 1
			if (i >= 2)
d220 1
a220 1
			printf("Enter secret password: ");
d225 7
a231 1
			printf("Again secret password: ");
a235 2
			if (strlen(passwd) < 4 && strlen(passwd2) < 4)
				err(1, "Your password must be longer");
d239 1
a239 1
			printf("Passwords do not match.\n");
a240 1
		strcpy(seed, defaultseed);
d243 1
d246 1
d251 1
a251 1
	time(&now);
d253 1
a253 1
	strftime(tbuf, sizeof(tbuf), " %b %d,%Y %T", tm);
d255 2
a256 1
	skey.val = (char *)malloc(16 + 1);
d260 5
a264 8
	fprintf(skey.keyfile, "%s %04d %-16s %s %-21s\n", pp->pw_name, n,
	    seed, skey.val, tbuf);
	fclose(skey.keyfile);
	printf("ID %s s/key is %d %s\n", pp->pw_name, n, seed);
	printf("Next login password: %s\n", btoe(buf, key));
#ifdef HEXIN
	printf("%s\n", put8(buf, key));
#endif
d266 1
a266 1
	exit(1);
@


1.2
log
@add ability to zero out entry; from millert@@cs.colorado.edu; netbsd pr#1851
also add a prototype for skeyzero()
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d32 1
d39 1
a39 1
	int     rval, n, nn, i, defaultsetup, l;
d67 2
a68 2
	if (argc > 1) {
		if (strcmp("-s", argv[1]) == 0)
d70 6
a75 5
		else
			pp = getpwnam(argv[1]);

		if (argc > 2)
			pp = getpwnam(argv[2]);
d109 4
d136 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
