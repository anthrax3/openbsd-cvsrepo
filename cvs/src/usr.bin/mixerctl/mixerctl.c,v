head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.12
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.8
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.4
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.29.0.22
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.20
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.16
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.14
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.12
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.10
	OPENBSD_5_0:1.29.0.8
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.6
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.10
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.8
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	MIXERCTL10:1.1.1.1
	MIXERCTL:1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	yGZX28AeTChVE8eY;

1.29
date	2009.11.12.07.27.31;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.26.05.42.21;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.13.21.26.01;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.26.13.36.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.27.21.55.54;	author sobrado;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.07.17.08.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.01.17.07.26;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.09.13.23.35;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.07.14.29.10;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.02.08.08.33;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.04.18.22.09;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.04.18.20.37;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.02.23.09.27;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.22.17.44.54;	author vincent;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.22.08.06.18;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.21.10.20.06;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.15.09.30.06;	author todd;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.15.04.16.57;	author jsyn;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.15.00.57.50;	author jfb;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.03.22.27.42;	author pvalchev;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.18.33.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.09.18.12.24;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.07.19.20.54.21;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	98.05.02.22.28.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.04.30.13.40.01;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	98.04.26.22.27.30;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	98.04.26.21.45.35;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.26.21.45.35;	author provos;	state Exp;
branches;
next	;


desc
@@


1.30
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@/*	$OpenBSD: mixerctl.c,v 1.29 2009/11/12 07:27:31 ratchov Exp $	*/
/*	$NetBSD: mixerctl.c,v 1.11 1998/04/27 16:55:23 augustss Exp $	*/

/*
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Lennart Augustsson, with some code and ideas from Chuck Cranor.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * mixerctl(1) - a program to control audio mixing.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

struct field *findfield(char *);
void adjlevel(char **, u_char *, int);
void catstr(char *, char *, char *);
void prfield(struct field *, char *, int, mixer_ctrl_t *);
void rdfield(int, struct field *, char *, int, char *);
__dead void usage(void);

#define FIELD_NAME_MAX	64

struct field {
	char name[FIELD_NAME_MAX];
	mixer_ctrl_t *valp;
	mixer_devinfo_t *infp;
} *fields, *rfields;

mixer_ctrl_t *values;
mixer_devinfo_t *infos;

void
catstr(char *p, char *q, char *out)
{
	char tmp[FIELD_NAME_MAX];

	snprintf(tmp, FIELD_NAME_MAX, "%s.%s", p, q);
	strlcpy(out, tmp, FIELD_NAME_MAX);
}

struct field *
findfield(char *name)
{
	int i;
	for (i = 0; fields[i].name[0] != '\0'; i++)
		if (strcmp(fields[i].name, name) == 0)
			return &fields[i];
	return (0);
}

#define e_member_name	un.e.member[i].label.name
#define s_member_name	un.s.member[i].label.name

void
prfield(struct field *p, char *sep, int prvalset, mixer_ctrl_t *m)
{
	int i, n;

	if (sep)
		printf("%s%s", p->name, sep);
	switch (m->type) {
	case AUDIO_MIXER_ENUM:
		for (i = 0; i < p->infp->un.e.num_mem; i++)
			if (p->infp->un.e.member[i].ord == m->un.ord)
				printf("%s",
					p->infp->e_member_name);
		if (prvalset) {
			printf("  [ ");
			for (i = 0; i < p->infp->un.e.num_mem; i++)
				printf("%s ", p->infp->e_member_name);
			printf("]");
		}
		break;
	case AUDIO_MIXER_SET:
		for (n = i = 0; i < p->infp->un.s.num_mem; i++)
			if (m->un.mask & p->infp->un.s.member[i].mask)
				printf("%s%s", n++ ? "," : "",
						p->infp->s_member_name);
		if (prvalset) {
			printf("  { ");
			for (i = 0; i < p->infp->un.s.num_mem; i++)
				printf("%s ", p->infp->s_member_name);
			printf("}");
		}
		break;
	case AUDIO_MIXER_VALUE:
		if (m->un.value.num_channels == 1)
			printf("%d", m->un.value.level[0]);
		else
			printf("%d,%d", m->un.value.level[0],
			    m->un.value.level[1]);
		if (prvalset)
			printf(" %s", p->infp->un.v.units.name);
		break;
	default:
		errx(1, "Invalid format.");
	}
}

void
adjlevel(char **p, u_char *olevel, int more)
{
	char *ep, *cp = *p;
	long inc;
	u_char level;

	if (*cp != '+' && *cp != '-')
		*olevel = 0;		/* absolute setting */

	errno = 0;
	inc = strtol(cp, &ep, 10);
	if (*cp == '\0' || (*ep != '\0' && *ep != ',') ||
	    (errno == ERANGE && (inc == LONG_MAX || inc == LONG_MIN)))
		errx(1, "Bad number %s", cp);
	if (*ep == ',' && !more)
		errx(1, "Too many values");
	*p = ep;

	if (inc < AUDIO_MIN_GAIN - *olevel)
		level = AUDIO_MIN_GAIN;
	else if (inc > AUDIO_MAX_GAIN - *olevel)
		level = AUDIO_MAX_GAIN;
	else
		level = *olevel + inc;
	*olevel = level;
}

void
rdfield(int fd, struct field *p, char *q, int quiet, char *sep)
{
	mixer_ctrl_t *m, oldval;
	int i, mask;
	char *s;

	oldval = *p->valp;
	m = p->valp;

	switch (m->type) {
	case AUDIO_MIXER_ENUM:
		if (strcmp(q, "toggle") == 0) {
			for (i = 0; i < p->infp->un.e.num_mem; i++) {
				if (m->un.ord == p->infp->un.e.member[i].ord)
					break;
			}
			if (i < p->infp->un.e.num_mem)
				i++;
			else
				i = 0;
			m->un.ord = p->infp->un.e.member[i].ord;
			break;
		}
		for (i = 0; i < p->infp->un.e.num_mem; i++)
			if (strcmp(p->infp->e_member_name, q) == 0)
				break;
		if (i < p->infp->un.e.num_mem)
			m->un.ord = p->infp->un.e.member[i].ord;
		else
			errx(1, "Bad enum value %s", q);
		break;
	case AUDIO_MIXER_SET:
		mask = 0;
		for (; q && *q; q = s) {
			if ((s = strchr(q, ',')) != NULL)
				*s++ = 0;
			for (i = 0; i < p->infp->un.s.num_mem; i++)
				if (strcmp(p->infp->s_member_name, q) == 0)
					break;
			if (i < p->infp->un.s.num_mem)
				mask |= p->infp->un.s.member[i].mask;
			else
				errx(1, "Bad set value %s", q);
		}
		m->un.mask = mask;
		break;
	case AUDIO_MIXER_VALUE:
		if (m->un.value.num_channels == 1) {
			adjlevel(&q, &m->un.value.level[0], 0);
		} else {
			adjlevel(&q, &m->un.value.level[0], 1);
			if (*q++ == ',')
				adjlevel(&q, &m->un.value.level[1], 0);
			else
				m->un.value.level[1] = m->un.value.level[0];
		}
		break;
	default:
		errx(1, "Invalid format.");
	}

	if (ioctl(fd, AUDIO_MIXER_WRITE, p->valp) < 0) {
		warn("AUDIO_MIXER_WRITE");
	} else if (!quiet) {
		if (ioctl(fd, AUDIO_MIXER_READ, p->valp) < 0) {
			warn("AUDIO_MIXER_READ");
		} else {
			if (sep) {
				prfield(p, ": ", 0, &oldval);
				printf(" -> ");
			}
			prfield(p, NULL, 0, p->valp);
			printf("\n");
		}
	}
}

int
main(int argc, char **argv)
{
	int fd, i, j, ch, pos;
	int aflag = 0, qflag = 0, vflag = 0, tflag = 0;
	char *file;
	char *sep = "=";
	mixer_devinfo_t dinfo;
	int ndev;

	if ((file = getenv("MIXERDEVICE")) == 0 || *file == '\0')
		file = "/dev/mixer";

	while ((ch = getopt(argc, argv, "af:nqtvw")) != -1) {
		switch (ch) {
		case 'a':
			aflag = 1;
			break;
		case 'w':
			/* compat */
			break;
		case 'v':
			vflag = 1;
			break;
		case 'n':
			sep = 0;
			break;
		case 'f':
			file = optarg;
			break;
		case 'q':
			qflag = 1;
			break;
		case 't':
			tflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc == 0 && tflag == 0)
		aflag = 1;
		
	if ((fd = open(file, O_RDWR)) == -1)
		if ((fd = open(file, O_RDONLY)) == -1)
			err(1, "%s", file);

	for (ndev = 0; ; ndev++) {
		dinfo.index = ndev;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &dinfo) < 0)
			break;
	}

	if (!ndev)
		errx(1, "no mixer devices configured");

	if ((rfields = calloc(ndev, sizeof *rfields)) == NULL ||
	    (fields = calloc(ndev, sizeof *fields)) == NULL ||
	    (infos = calloc(ndev, sizeof *infos)) == NULL ||
	    (values = calloc(ndev, sizeof *values)) == NULL)
		err(1, "calloc()");

	for (i = 0; i < ndev; i++) {
		infos[i].index = i;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &infos[i]) < 0) {
			ndev--;
			i--;
			continue;
		}
	}

	for (i = 0; i < ndev; i++) {
		strlcpy(rfields[i].name, infos[i].label.name, FIELD_NAME_MAX);
		rfields[i].valp = &values[i];
		rfields[i].infp = &infos[i];
	}

	for (i = 0; i < ndev; i++) {
		values[i].dev = i;
		values[i].type = infos[i].type;
		if (infos[i].type != AUDIO_MIXER_CLASS) {
			values[i].un.value.num_channels = 2;
			if (ioctl(fd, AUDIO_MIXER_READ, &values[i]) < 0) {
				values[i].un.value.num_channels = 1;
				if (ioctl(fd, AUDIO_MIXER_READ, &values[i]) < 0)
					err(1, "AUDIO_MIXER_READ");
			}
		}
	}

	for (j = i = 0; i < ndev; i++) {
		if (infos[i].type != AUDIO_MIXER_CLASS &&
		    infos[i].prev == AUDIO_MIXER_LAST) {
			fields[j++] = rfields[i];
			for (pos = infos[i].next; pos != AUDIO_MIXER_LAST;
			    pos = infos[pos].next) {
				fields[j] = rfields[pos];
				catstr(rfields[i].name, infos[pos].label.name,
				    fields[j].name);
				j++;
			}
		}
	}

	for (i = 0; i < j; i++) {
		int cls = fields[i].infp->mixer_class;
		if (cls >= 0 && cls < ndev)
			catstr(infos[cls].label.name, fields[i].name,
			    fields[i].name);
	}

	if (!argc && aflag) {
		for (i = 0; fields[i].name[0] != '\0'; i++) {
			prfield(&fields[i], sep, vflag, fields[i].valp);
			printf("\n");
		}
	} else if (argc > 0 && !aflag) {
		struct field *p;

		while (argc--) {
			char *q;

			ch = 0;
			if ((q = strchr(*argv, '=')) != NULL) {
				*q++ = '\0';
				ch = 1;
			}

			if ((p = findfield(*argv)) == NULL) {
				warnx("field %s does not exist", *argv);
			} else if (ch || tflag) {
				if (tflag && q == NULL)
					q = "toggle";
				rdfield(fd, p, q, qflag, sep);
			} else {
				prfield(p, sep, vflag, p->valp);
				printf("\n");
			}

			argv++;
		}
	} else
		usage();
	exit(0);
}

__dead void
usage(void)
{
	extern char *__progname;	/* from crt0.o */

	fprintf(stderr,
	    "usage: %s [-anv] [-f file]\n"
	    "       %s [-nv] [-f file] name ...\n"
	    "       %s [-qt] [-f file] name ...\n"
	    "       %s [-q] [-f file] name=value ...\n",
	    __progname, __progname, __progname, __progname);

	exit(1);
}
@


1.29
log
@if a value is changed and -n is used, print the new value only.
from Pawlowski Marcin Piotr <pmp.openbsd at gmail.com>
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.28 2008/06/26 05:42:21 ray Exp $	*/
d257 1
a257 1
			aflag++;
d263 1
a263 1
			vflag++;
d285 1
a285 1
		aflag++;
@


1.28
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.27 2008/01/13 21:26:01 ratchov Exp $	*/
d52 2
a53 2
void prfield(struct field *, char *, int);
void rdfield(int, struct field *, char *, int);
d90 1
a90 1
prfield(struct field *p, char *sep, int prvalset)
a91 1
	mixer_ctrl_t *m;
a95 1
	m = p->valp;
d164 1
a164 1
rdfield(int fd, struct field *p, char *q, int quiet)
a227 2
		*p->valp = oldval;
		prfield(p, ": ", 0);
d231 5
a235 2
			printf(" -> ");
			prfield(p, NULL, 0);
d357 1
a357 1
			prfield(&fields[i], sep, vflag);
d377 1
a377 1
				rdfield(fd, p, q, qflag);
d379 1
a379 1
				prfield(p, sep, vflag);
@


1.27
log
@the mixer_devinfo structure contains next and prev pointers; they are used
to create doubly linked "chains" of mixer devices. Currently mixerctl(1)
supposes that the 'next' index is never smaller than the index of the
device; so it fails to handle such mixers. The fix, allows 'next' indexes to
be smaller than the index of the device.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.26 2007/11/26 13:36:34 deraadt Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.26
log
@if no arguments given, assume a nice default; ok miod jakemsr deanna
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.25 2007/09/27 21:55:54 sobrado Exp $	*/
d344 1
a344 1
		    infos[i].type != -1) {
a350 1
				infos[pos].type = -1;
@


1.25
log
@style(9) fixes, optional flags without arguments come first;
while here, some spacing fixes

ok deanna@@, jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.24 2007/08/06 19:16:06 sobrado Exp $	*/
a284 1
		case '?':
d292 3
d405 1
a405 1
	    "usage: %s [-nv] [-f file] -a\n"
@


1.24
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.23 2005/10/07 17:08:36 deraadt Exp $	*/
d263 1
a263 1
		switch(ch) {
d406 1
a406 1
	    "       %s [-q]  [-f file] name=value ...\n",
@


1.23
log
@missing progname, clamat@@telus.net
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.22 2005/10/01 17:07:26 deraadt Exp $	*/
d404 3
a406 3
	    "       %s [-nv] [-f file] name [...]\n"
	    "       %s [-qt] [-f file] name [...]\n"
	    "       %s [-q]  [-f file] name=value [...]\n",
@


1.22
log
@toggle support from janus@@area319.de.  i was unsure, but a few other
people found this very useful
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.21 2005/05/09 13:23:35 millert Exp $	*/
d407 1
a407 1
	    __progname, __progname, __progname);
@


1.21
log
@Fix mixerctl -q
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.20 2005/02/07 14:29:10 millert Exp $	*/
d135 1
a135 1
			       m->un.value.level[1]);
d184 12
d202 1
a202 1
		        errx(1, "Bad enum value %s", q);
d215 1
a215 1
			        errx(1, "Bad set value %s", q);
d253 1
a253 1
	int aflag = 0, qflag = 0, vflag = 0;
d260 1
a260 1
	        file = "/dev/mixer";
d262 1
a262 1
	while ((ch = getopt(argc, argv, "af:nqvw")) != -1) {
d282 3
d381 3
a383 1
			} else if (ch) {
d405 1
@


1.20
log
@Levels should be between AUDIO_MIN_GAIN and AUDIO_MAX_GAIN inclusive
Truncate specified level to be within this range and avoid wrapping.
Idea from espie@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.19 2005/02/02 08:08:33 otto Exp $	*/
d60 1
a60 1
void rdfield(int, struct field *, char *);
d173 1
a173 1
rdfield(int fd, struct field *p, char *q)
d224 1
a224 1
	} else {
d367 1
a367 1
				rdfield(fd, p, q);
@


1.19
log
@Fix a few memory leaks and general cleanup. From Joris Vink. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.18 2005/01/04 18:22:09 millert Exp $	*/
d48 1
d50 1
d56 2
a58 1
struct field *findfield(char *);
d145 28
d176 1
a176 2
	int v, v0, v1, mask;
	int i;
d194 1
a194 1
		for (v = 0; q && *q; q = s) {
d209 1
a209 12
			if (sscanf(q, "%d", &v) == 1) {
				switch (*q) {
				case '+':
				case '-':
					m->un.value.level[0] += v;
					break;
				default:
					m->un.value.level[0] = v;
					break;
				}
			} else
				errx(1, "Bad number %s", q);
d211 5
a215 34
			if (sscanf(q, "%d,%d", &v0, &v1) == 2) {
				switch (*q) {
				case '+':
				case '-':
					m->un.value.level[0] += v0;
					break;
				default:
					m->un.value.level[0] = v0;
					break;
				}
				s = strchr(q, ',') + 1;
				switch (*s) {
				case '+':
				case '-':
					m->un.value.level[1] += v1;
					break;
				default:
					m->un.value.level[1] = v1;
					break;
				}
			} else if (sscanf(q, "%d", &v) == 1) {
				switch (*q) {
				case '+':
				case '-':
					m->un.value.level[0] += v;
					m->un.value.level[1] += v;
					break;
				default:
					m->un.value.level[0] = v;
					m->un.value.level[1] = v;
					break;
				}
			} else
				errx(1, "Bad numbers %s", q);
@


1.18
log
@Minor KNF, s/for(/for (/
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.17 2005/01/04 18:20:37 millert Exp $	*/
d43 6
d51 1
a51 2
#include <fcntl.h>
#include <err.h>
a52 4
#include <string.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/audioio.h>
d54 5
a58 6
char *catstr(char *p, char *q);
struct field *findfield(char *name);
void prfield(struct field *p, char *sep, int prvalset);
int rdfield(struct field *p, char *q);
int main(int argc, char **argv);
void usage(void);
d60 1
a60 1
FILE *out = stdout;
d63 1
a63 1
	char *name;
d71 2
a72 2
char *
catstr(char *p, char *q)
d74 1
a74 2
	int len;
	char *r;
d76 2
a77 7
	len = strlen(p) + 1 + strlen(q) + 1;
	if ((r = malloc(len)) == NULL)
		err(1, "malloc()");
	strlcpy(r, p, len);
	strlcat(r, ".", len);
	strlcat(r, q, len);
	return (r);
d84 1
a84 1
	for (i = 0; fields[i].name; i++)
d90 3
d100 1
a100 1
		fprintf(out, "%s%s", p->name, sep);
d102 1
a102 1
	switch(m->type) {
d106 2
a107 2
				fprintf(out, "%s",
					p->infp->un.e.member[i].label.name);
d109 1
a109 1
			fprintf(out, "  [ ");
d111 2
a112 2
				fprintf(out, "%s ", p->infp->un.e.member[i].label.name);
			fprintf(out, "]");
d118 2
a119 2
				fprintf(out, "%s%s", n++ ? "," : "",
					p->infp->un.s.member[i].label.name);
d121 1
a121 1
			fprintf(out, "  { ");
d123 2
a124 2
				fprintf(out, "%s ", p->infp->un.s.member[i].label.name);
			fprintf(out, "}");
d129 1
a129 1
			fprintf(out, "%d", m->un.value.level[0]);
d131 1
a131 1
			fprintf(out, "%d,%d", m->un.value.level[0],
d134 1
a134 1
			fprintf(out, " %s", p->infp->un.v.units.name);
d141 2
a142 2
int
rdfield(struct field *p, char *q)
d144 1
a144 1
	mixer_ctrl_t *m;
d149 1
d151 2
a152 1
	switch(m->type) {
d155 1
a155 1
			if (strcmp(p->infp->un.e.member[i].label.name, q) == 0)
d165 1
a165 1
			if (s = strchr(q, ','))
d168 1
a168 1
				if (strcmp(p->infp->un.s.member[i].label.name, q) == 0)
d231 14
a244 1
	return (1);
a254 1
	mixer_ctrl_t val;
d310 2
a311 1
			ndev--, i--;
d317 1
a317 1
		rfields[i].name = infos[i].label.name;
d342 2
a343 2
				fields[j].name = catstr(rfields[i].name,
							infos[pos].label.name);
d353 2
a354 2
			fields[i].name = catstr(infos[cls].label.name,
						fields[i].name);
d358 1
a358 1
		for (i = 0; fields[i].name; i++) {
d360 1
a360 1
			fprintf(out, "\n");
d365 1
a365 1
		while(argc--) {
d368 10
a377 20
			if (q = strchr(*argv, '=')) {
				*q++ = 0;
				p = findfield(*argv);
				if (p == NULL)
					warnx("field %s does not exist", *argv);
				else {
					val = *p->valp;
					if (rdfield(p, q)) {
						if (ioctl(fd, AUDIO_MIXER_WRITE, p->valp) < 0)
							warn("AUDIO_MIXER_WRITE");
						else if (sep && !qflag) {
							*p->valp = val;
							prfield(p, ": ", 0);
							ioctl(fd, AUDIO_MIXER_READ, p->valp);
							printf(" -> ");
							prfield(p, 0, 0);
							printf("\n");
						}
					}
				}
d379 2
a380 7
				p = findfield(*argv);
				if (p == NULL)
					warnx("field %s does not exist", *argv);
				else {
					prfield(p, sep, vflag);
					fprintf(out, "\n");
				}
d382 1
d390 1
a390 1
void
@


1.17
log
@Fix some issues noted by Joris Vink; pedro@@ OK
o g/c the changed field in struct field
o increment argv for bad fields too
o deal with AUDIO_MIXER_DEVINFO (unlikely) failures
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.16 2004/03/02 23:09:27 tedu Exp $	*/
d90 1
a90 1
	for(i = 0; fields[i].name; i++)
d107 1
a107 1
		for(i = 0; i < p->infp->un.e.num_mem; i++)
d113 1
a113 1
			for(i = 0; i < p->infp->un.e.num_mem; i++)
d119 1
a119 1
		for(n = i = 0; i < p->infp->un.s.num_mem; i++)
d125 1
a125 1
			for(i = 0; i < p->infp->un.s.num_mem; i++)
d155 1
a155 1
		for(i = 0; i < p->infp->un.e.num_mem; i++)
d165 1
a165 1
		for(v = 0; q && *q; q = s) {
d281 1
a281 1
	for(ndev = 0; ; ndev++) {
d296 1
a296 1
	for(i = 0; i < ndev; i++) {
d304 1
a304 1
	for(i = 0; i < ndev; i++) {
d310 1
a310 1
	for(i = 0; i < ndev; i++) {
d323 1
a323 1
	for(j = i = 0; i < ndev; i++) {
d327 1
a327 1
			for(pos = infos[i].next; pos != AUDIO_MIXER_LAST;
d338 1
a338 1
	for(i = 0; i < j; i++) {
d346 1
a346 1
		for(i = 0; fields[i].name; i++) {
@


1.16
log
@fix ndev counting loop.  report from Stuart Cassoff
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.15 2004/01/22 17:44:54 vincent Exp $	*/
a65 1
	char changed;
a231 1
	p->changed = 1;
d298 4
a301 1
		ioctl(fd, AUDIO_MIXER_DEVINFO, &infos[i]);
a375 1
				argv++;
d385 1
@


1.15
log
@fix segfault when an invalid field was requested

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.14 2004/01/22 08:06:18 tedu Exp $	*/
d246 1
a246 1
	int ndev = 0;
d283 2
a284 2
	for(;;) {
		dinfo.index = ndev++;
@


1.14
log
@remove need for -w. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.13 2003/11/21 10:20:06 jmc Exp $	*/
d375 1
a375 1
			argv++;
d378 6
a383 2
				prfield(p, sep, vflag);
				fprintf(out, "\n");
@


1.13
log
@mixerctl.1:
- put SYNOPSIS in standard form
- -n does not make sense with -q
- adjust -width of option list
- sort options
- a clarity fix from snj att pobox dott com

mixerctl.c:
- fix spacing in usage()
- sync usage() with SYNOPSIS
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.12 2003/05/15 09:30:06 todd Exp $	*/
d241 1
a241 1
	int aflag = 0, qflag = 0, wflag = 0, vflag = 0;
d257 1
a257 1
			wflag++;
d279 3
a281 2
	if ((fd = open(file, wflag ? O_RDWR : O_RDONLY)) < 0)
		err(1, "%s", file);
d284 3
a286 3
	       dinfo.index = ndev++;
	       if (ioctl(fd, AUDIO_MIXER_DEVINFO, &dinfo) < 0)
	 	       break;
d344 1
a344 1
	if (!argc && aflag && !wflag) {
d351 21
a371 22
		if (wflag) {
			while(argc--) {
				char *q;

				if (q = strchr(*argv, '=')) {
					*q++ = 0;
					p = findfield(*argv);
					if (p == 0)
						warnx("field %s does not exist", *argv);
					else {
						val = *p->valp;
						if (rdfield(p, q)) {
							if (ioctl(fd, AUDIO_MIXER_WRITE, p->valp) < 0)
								warn("AUDIO_MIXER_WRITE");
							else if (sep && !qflag) {
								*p->valp = val;
								prfield(p, ": ", 0);
								ioctl(fd, AUDIO_MIXER_READ, p->valp);
								printf(" -> ");
								prfield(p, 0, 0);
								printf("\n");
							}
d374 3
a376 6
				} else
					warnx("No `=' in %s", *argv);
				argv++;
			}
		} else {
			while(argc--) {
d378 2
a379 5
				if (p == 0)
					warnx("field %s does not exist", *argv);
				else
					prfield(p, sep, vflag), fprintf(out, "\n");
				argv++;
d395 1
a395 1
	    "       %s [-q]  [-f file] -w name=value [...]\n",
@


1.12
log
@unbreak tree; ok margarida@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.11 2003/05/15 04:16:57 jsyn Exp $	*/
d399 3
a401 3
	    "usage: %s [-f file] [-n] [-v] -a\n"
	    "	    %s [-f file] [-n] [-v] name ...\n"
	    "       %s [-f file] [-n] [-q] -w name=value ...\n",
@


1.11
log
@make usage printing match what's in the manpage, which is better; ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.10 2003/05/15 00:57:50 jfb Exp $	*/
d401 1
a401 1
	    "       %s [-f file] [-n] [-q] -w name=value ...\n"
@


1.10
log
@Add a -q flag to suppress all output when setting a variable, and
remove the -v flag from the SYNOPSIS for the -w option since it
has no effect

ok jsyn@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.9 2002/12/03 22:27:42 pvalchev Exp $	*/
d399 2
a400 1
	    "usage: %s [-f file] [-n] [-v] name ...\n"
d402 1
a402 2
	    "       %s [-f file] [-n] [-v] -a\n", __progname,
	    __progname, __progname);
@


1.9
log
@ansify, indent, check for malloc/calloc failure, proper usage()
from andrushock@@korovino.net via deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.8 2002/05/29 18:33:39 deraadt Exp $	*/
d241 1
a241 1
	int aflag = 0, wflag = 0, vflag = 0;
d251 1
a251 1
	while ((ch = getopt(argc, argv, "af:nvw")) != -1) {
d268 3
d364 1
a364 1
							else if (sep) {
d400 1
a400 1
	    "       %s [-f file] [-n] [-v] -w name=value ...\n"
d402 1
a402 1
		__progname, __progname);
@


1.8
log
@strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.7 2002/02/16 21:27:49 millert Exp $	*/
d38 5
d58 1
a61 2
char *prog;

d73 1
a73 3
catstr(p, q)
	char *p;
	char *q;
d79 2
a80 1
	r = malloc(len);
d84 1
a84 1
	return r;
d88 1
a88 2
findfield(name)
	char *name;
d94 1
a94 1
	return 0;
d98 1
a98 4
prfield(p, sep, prvalset)
	struct field *p;
	char *sep;
	int prvalset;
a140 1
		printf("\n");
d146 1
a146 3
rdfield(p, q)
	struct field *p;
	char *q;
d161 2
a162 4
		else {
			warnx("Bad enum value %s", q);
			return 0;
		}
d167 1
a167 2
			s = strchr(q, ',');
			if (s)
d172 1
a172 1
			if (i < p->infp->un.s.num_mem) {
d174 2
a175 4
			} else {
				warnx("Bad set value %s", q);
				return 0;
			}
d191 2
a192 4
			} else {
				warnx("Bad number %s", q);
				return 0;
			}
d222 2
a223 2
					m->un.value.level[0] =
					    m->un.value.level[1] = v;
d226 2
a227 4
			} else {
				warnx("Bad numbers %s", q);
				return 0;
			}
d234 1
a234 1
	return 1;
d238 1
a238 3
main(argc, argv)
	int argc;
	char **argv;
d246 1
a246 5
	int ndev;

	file = getenv("MIXERDEVICE");
	if (file == 0)
		file = "/dev/mixer";
d248 2
a249 1
	prog = *argv;
d270 1
a270 5
		usage:
		fprintf(out, "%s [-f file] [-v] [-n] name ...\n", prog);
		fprintf(out, "%s [-f file] [-v] [-n] -w name=value ...\n", prog);
		fprintf(out, "%s [-f file] [-v] [-n] -a\n", prog);
		exit(0);
d276 1
a276 2
	fd = open(file, wflag? O_RDWR : O_RDONLY);
	if (fd < 0)
d279 4
a282 4
	for(ndev = 0; ; ndev++) {
		dinfo.index = ndev;
		if (ioctl(fd, AUDIO_MIXER_DEVINFO, &dinfo) < 0)
			break;
d285 1
a285 1
	if (ndev == 0)
d288 5
a292 4
	rfields = calloc(ndev, sizeof *rfields);
	fields = calloc(ndev, sizeof *fields);
	infos = calloc(ndev, sizeof *infos);
	values = calloc(ndev, sizeof *values);
d340 1
a340 1
	if (argc == 0 && aflag && !wflag) {
d351 1
a351 2
				q = strchr(*argv, '=');
				if (q) {
d371 1
a371 1
				} else {
a372 1
				}
d386 1
a386 1
		goto usage;
d388 14
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.6 2002/01/09 18:12:24 mickey Exp $	*/
d73 8
a80 4
	char *r = malloc(strlen(p) + strlen(q) + 2);
	strcpy(r, p);
	strcat(r, ".");
	strcat(r, q);
@


1.6
log
@open RDWR only for -w, RDONLY otherwise
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.5 1999/07/19 20:54:21 mickey Exp $	*/
d48 4
a51 4
char *catstr __P((char *p, char *q));
struct field *findfield __P((char *name));
void prfield __P((struct field *p, char *sep, int prvalset));
int rdfield __P((struct field *p, char *q));
@


1.5
log
@fix for case no mixer devices are available, got triggered by malloc.conf->J; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.4 1998/05/02 22:28:07 millert Exp $	*/
d71 1
a71 1
        char *q;
d94 2
a95 2
        char *sep;
        int prvalset;
d132 1
a132 1
			fprintf(out, "%d,%d", m->un.value.level[0], 
d146 1
a146 1
        char *q;
d249 1
a249 1
        char **argv;
d293 2
a294 2
    
	fd = open(file, O_RDWR);
d343 1
a343 1
				fields[j].name = catstr(rfields[i].name, 
d354 1
a354 1
			fields[i].name = catstr(infos[cls].label.name, 
@


1.4
log
@allow relative values via +/- prefixes
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.3 1998/04/30 13:40:01 provos Exp $	*/
d303 4
@


1.3
log
@From NetBSD: Lennart Augustsson:
environment variable for default mixer device
@
text
@d1 1
a1 1
/*	$OpenBSD: mixerctl.c,v 1.2 1998/04/26 22:27:30 provos Exp $	*/
d172 1
a172 1
			for(i = 0; i < p->infp->un.s.num_mem; i++)
d187 9
a195 1
				m->un.value.level[0] = v;
d202 19
a220 2
				m->un.value.level[0] = v0;
				m->un.value.level[1] = v1;
d222 11
a232 1
				m->un.value.level[0] = m->un.value.level[1] = v;
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mixerctl.c,v 1.9 1997/10/19 07:46:04 augustss Exp $	*/
d218 1
a218 1
	char *file = "/dev/mixer";
d223 4
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@mixerctl from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@@
