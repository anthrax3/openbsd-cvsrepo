head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.10
date	2017.01.20.08.57.12;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	dLXg6G5zkTXfsv25;

1.9
date	2015.10.17.15.00.11;	author doug;	state Exp;
branches;
next	1.8;
commitid	eAF5hlziO0omr4Cj;

1.8
date	2015.10.17.07.51.10;	author semarie;	state Exp;
branches;
next	1.7;
commitid	sUU1X3HBhu9tnHPd;

1.7
date	2015.10.10.22.28.51;	author doug;	state Exp;
branches;
next	1.6;
commitid	7Pr412xEOoY2KZOT;

1.6
date	2015.09.11.14.30.23;	author bcook;	state Exp;
branches;
next	1.5;
commitid	erFqA80i5nzJClSk;

1.5
date	2015.08.19.18.25.31;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	mhJdagBRVnDGkLkQ;

1.4
date	2015.01.08.11.06.12;	author doug;	state Exp;
branches;
next	1.3;
commitid	VbVaT2wZNrv1p2Gs;

1.3
date	2014.08.28.14.25.48;	author jsing;	state Exp;
branches;
next	1.2;
commitid	NXPv87VQ5deYVqsV;

1.2
date	2014.08.28.14.23.52;	author jsing;	state Exp;
branches;
next	1.1;
commitid	sL7NDHJPBg4hmfYx;

1.1
date	2014.08.26.17.47.25;	author jsing;	state Exp;
branches;
next	;
commitid	7A7DObXgY4Fni8xJ;


desc
@@


1.10
log
@rearrange pledge promises into the canonical order; easier to eyeball
@
text
@/* $OpenBSD: pkcs8.c,v 1.9 2015/10/17 15:00:11 doug Exp $ */
/* Written by Dr Stephen N Henson (steve@@openssl.org) for the OpenSSL
 * project 1999-2004.
 */
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    licensing@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include "apps.h"
#include "progs.h"

#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>

static struct {
	const EVP_CIPHER *cipher;
	char *infile;
	int informat;
	int iter;
	int nocrypt;
	char *outfile;
	int outformat;
	int p8_broken;
	char *passargin;
	char *passargout;
	int pbe_nid;
	int topk8;
} pkcs8_config;

static int
pkcs8_opt_v1(char *arg)
{
	if ((pkcs8_config.pbe_nid = OBJ_txt2nid(arg)) == NID_undef) {
		fprintf(stderr, "Unknown PBE algorithm '%s'\n", arg);
		return (1);
	}

	return (0);
}

static int
pkcs8_opt_v2(char *arg)
{
	if ((pkcs8_config.cipher = EVP_get_cipherbyname(arg)) == NULL) {
		fprintf(stderr, "Unknown cipher '%s'\n", arg);
		return (1);
	}

	return (0);
}

static struct option pkcs8_options[] = {
	{
		.name = "embed",
		.desc = "Generate DSA keys in a broken format",
		.type = OPTION_VALUE,
		.value = PKCS8_EMBEDDED_PARAM,
		.opt.value = &pkcs8_config.p8_broken,
	},
	{
		.name = "in",
		.argname = "file",
		.desc = "Input file (default stdin)",
		.type = OPTION_ARG,
		.opt.arg = &pkcs8_config.infile,
	},
	{
		.name = "inform",
		.argname = "format",
		.desc = "Input format (DER or PEM (default))",
		.type = OPTION_ARG_FORMAT,
		.opt.value = &pkcs8_config.informat,
	},
	{
		.name = "nocrypt",
		.desc = "Use or expect unencrypted private key",
		.type = OPTION_FLAG,
		.opt.flag = &pkcs8_config.nocrypt,
	},
	{
		.name = "noiter",
		.desc = "Use 1 as iteration count",
		.type = OPTION_VALUE,
		.value = 1,
		.opt.value = &pkcs8_config.iter,
	},
	{
		.name = "nooct",
		.desc = "Generate RSA keys in a broken format (no octet)",
		.type = OPTION_VALUE,
		.value = PKCS8_NO_OCTET,
		.opt.value = &pkcs8_config.p8_broken,
	},
	{
		.name = "nsdb",
		.desc = "Generate DSA keys in the broken Netscape DB format",
		.type = OPTION_VALUE,
		.value = PKCS8_NS_DB,
		.opt.value = &pkcs8_config.p8_broken,
	},
	{
		.name = "out",
		.argname = "file",
		.desc = "Output file (default stdout)",
		.type = OPTION_ARG,
		.opt.arg = &pkcs8_config.outfile,
	},
	{
		.name = "outform",
		.argname = "format",
		.desc = "Output format (DER or PEM (default))",
		.type = OPTION_ARG_FORMAT,
		.opt.value = &pkcs8_config.outformat,
	},
	{
		.name = "passin",
		.argname = "source",
		.desc = "Input file passphrase source",
		.type = OPTION_ARG,
		.opt.arg = &pkcs8_config.passargin,
	},
	{
		.name = "passout",
		.argname = "source",
		.desc = "Output file passphrase source",
		.type = OPTION_ARG,
		.opt.arg = &pkcs8_config.passargout,
	},
	{
		.name = "topk8",
		.desc = "Read traditional format key and write PKCS#8 format"
		    " key",
		.type = OPTION_FLAG,
		.opt.flag = &pkcs8_config.topk8,
	},
	{
		.name = "v1",
		.argname = "algorithm",
		.desc = "Use PKCS#5 v1.5 or PKCS#12 with given algorithm",
		.type = OPTION_ARG_FUNC,
		.opt.argfunc = pkcs8_opt_v1,
	},
	{
		.name = "v2",
		.argname = "cipher",
		.desc = "Use PKCS#5 v2.0 with given cipher",
		.type = OPTION_ARG_FUNC,
		.opt.argfunc = pkcs8_opt_v2,
	},
	{ NULL },
};

static void
pkcs8_usage()
{
	fprintf(stderr, "usage: pkcs8 [-embed] [-in file] "
	    "[-inform fmt] [-nocrypt]\n"
	    "    [-noiter] [-nooct] [-nsdb] [-out file] [-outform fmt] "
	    "[-passin src]\n"
	    "    [-passout src] [-topk8] [-v1 alg] [-v2 alg]\n\n");
	options_usage(pkcs8_options);
}

int
pkcs8_main(int argc, char **argv)
{
	BIO *in = NULL, *out = NULL;
	X509_SIG *p8 = NULL;
	PKCS8_PRIV_KEY_INFO *p8inf = NULL;
	EVP_PKEY *pkey = NULL;
	char pass[50], *passin = NULL, *passout = NULL, *p8pass = NULL;
	int ret = 1;

	if (single_execution) {
		if (pledge("stdio cpath wpath rpath tty", NULL) == -1) {
			perror("pledge");
			exit(1);
		}
	}

	memset(&pkcs8_config, 0, sizeof(pkcs8_config));

	pkcs8_config.iter = PKCS12_DEFAULT_ITER;
	pkcs8_config.informat = FORMAT_PEM;
	pkcs8_config.outformat = FORMAT_PEM;
	pkcs8_config.p8_broken = PKCS8_OK;
	pkcs8_config.pbe_nid = -1;

	if (options_parse(argc, argv, pkcs8_options, NULL, NULL) != 0) {
		pkcs8_usage();
		return (1);
	}

	if (!app_passwd(bio_err, pkcs8_config.passargin,
	    pkcs8_config.passargout, &passin, &passout)) {
		BIO_printf(bio_err, "Error getting passwords\n");
		goto end;
	}
	if ((pkcs8_config.pbe_nid == -1) && !pkcs8_config.cipher)
		pkcs8_config.pbe_nid = NID_pbeWithMD5AndDES_CBC;

	if (pkcs8_config.infile) {
		if (!(in = BIO_new_file(pkcs8_config.infile, "rb"))) {
			BIO_printf(bio_err,
			    "Can't open input file '%s'\n",
			    pkcs8_config.infile);
			goto end;
		}
	} else
		in = BIO_new_fp(stdin, BIO_NOCLOSE);

	if (pkcs8_config.outfile) {
		if (!(out = BIO_new_file(pkcs8_config.outfile, "wb"))) {
			BIO_printf(bio_err, "Can't open output file '%s'\n",
			    pkcs8_config.outfile);
			goto end;
		}
	} else {
		out = BIO_new_fp(stdout, BIO_NOCLOSE);
	}
	if (pkcs8_config.topk8) {
		pkey = load_key(bio_err, pkcs8_config.infile,
		    pkcs8_config.informat, 1, passin, "key");
		if (!pkey)
			goto end;
		if (!(p8inf = EVP_PKEY2PKCS8_broken(pkey,
		    pkcs8_config.p8_broken))) {
			BIO_printf(bio_err, "Error converting key\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		if (pkcs8_config.nocrypt) {
			if (pkcs8_config.outformat == FORMAT_PEM)
				PEM_write_bio_PKCS8_PRIV_KEY_INFO(out, p8inf);
			else if (pkcs8_config.outformat == FORMAT_ASN1)
				i2d_PKCS8_PRIV_KEY_INFO_bio(out, p8inf);
			else {
				BIO_printf(bio_err,
				    "Bad format specified for key\n");
				goto end;
			}
		} else {
			if (passout)
				p8pass = passout;
			else {
				p8pass = pass;
				if (EVP_read_pw_string(pass, sizeof pass,
				    "Enter Encryption Password:", 1))
					goto end;
			}
			if (!(p8 = PKCS8_encrypt(pkcs8_config.pbe_nid,
			    pkcs8_config.cipher, p8pass, strlen(p8pass),
			    NULL, 0, pkcs8_config.iter, p8inf))) {
				BIO_printf(bio_err, "Error encrypting key\n");
				ERR_print_errors(bio_err);
				goto end;
			}
			if (pkcs8_config.outformat == FORMAT_PEM)
				PEM_write_bio_PKCS8(out, p8);
			else if (pkcs8_config.outformat == FORMAT_ASN1)
				i2d_PKCS8_bio(out, p8);
			else {
				BIO_printf(bio_err,
				    "Bad format specified for key\n");
				goto end;
			}
		}

		ret = 0;
		goto end;
	}
	if (pkcs8_config.nocrypt) {
		if (pkcs8_config.informat == FORMAT_PEM)
			p8inf = PEM_read_bio_PKCS8_PRIV_KEY_INFO(in, NULL,
			    NULL, NULL);
		else if (pkcs8_config.informat == FORMAT_ASN1)
			p8inf = d2i_PKCS8_PRIV_KEY_INFO_bio(in, NULL);
		else {
			BIO_printf(bio_err, "Bad format specified for key\n");
			goto end;
		}
	} else {
		if (pkcs8_config.informat == FORMAT_PEM)
			p8 = PEM_read_bio_PKCS8(in, NULL, NULL, NULL);
		else if (pkcs8_config.informat == FORMAT_ASN1)
			p8 = d2i_PKCS8_bio(in, NULL);
		else {
			BIO_printf(bio_err, "Bad format specified for key\n");
			goto end;
		}

		if (!p8) {
			BIO_printf(bio_err, "Error reading key\n");
			ERR_print_errors(bio_err);
			goto end;
		}
		if (passin)
			p8pass = passin;
		else {
			p8pass = pass;
			EVP_read_pw_string(pass, sizeof pass,
			    "Enter Password:", 0);
		}
		p8inf = PKCS8_decrypt(p8, p8pass, strlen(p8pass));
	}

	if (!p8inf) {
		BIO_printf(bio_err, "Error decrypting key\n");
		ERR_print_errors(bio_err);
		goto end;
	}
	if (!(pkey = EVP_PKCS82PKEY(p8inf))) {
		BIO_printf(bio_err, "Error converting key\n");
		ERR_print_errors(bio_err);
		goto end;
	}
	if (p8inf->broken) {
		BIO_printf(bio_err, "Warning: broken key encoding: ");
		switch (p8inf->broken) {
		case PKCS8_NO_OCTET:
			BIO_printf(bio_err, "No Octet String in PrivateKey\n");
			break;

		case PKCS8_EMBEDDED_PARAM:
			BIO_printf(bio_err,
			    "DSA parameters included in PrivateKey\n");
			break;

		case PKCS8_NS_DB:
			BIO_printf(bio_err,
			    "DSA public key include in PrivateKey\n");
			break;

		case PKCS8_NEG_PRIVKEY:
			BIO_printf(bio_err, "DSA private key value is negative\n");
			break;

		default:
			BIO_printf(bio_err, "Unknown broken type\n");
			break;
		}
	}
	if (pkcs8_config.outformat == FORMAT_PEM)
		PEM_write_bio_PrivateKey(out, pkey, NULL, NULL, 0, NULL,
		    passout);
	else if (pkcs8_config.outformat == FORMAT_ASN1)
		i2d_PrivateKey_bio(out, pkey);
	else {
		BIO_printf(bio_err, "Bad format specified for key\n");
		goto end;
	}
	ret = 0;

end:
	X509_SIG_free(p8);
	PKCS8_PRIV_KEY_INFO_free(p8inf);
	EVP_PKEY_free(pkey);
	BIO_free_all(out);
	BIO_free(in);
	free(passin);
	free(passout);

	return ret;
}
@


1.9
log
@Exit if a pledge call fails in non-interactive mode.

ok semarie@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.8 2015/10/17 07:51:10 semarie Exp $ */
d230 1
a230 1
		if (pledge("stdio rpath wpath cpath tty", NULL) == -1) {
@


1.8
log
@add "tty" for several subcommands of openssl

it is needed in order to let libssl UI_* function plays with echo on/off when
asking for password on terminal.

passwd subcommand needs additionnal "wpath cpath" in order to let it calls
fopen("/dev/tty", "w") (O_WRONLY with O_CREAT | O_TRUNC).

problem reported by several
with and ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.7 2015/10/10 22:28:51 doug Exp $ */
d230 1
a230 1
		if (pledge("stdio rpath wpath cpath tty", NULL) == -1)
d232 2
@


1.7
log
@Initial support for pledges in openssl(1) commands.

openssl(1) has two mechanisms for operating: either a single execution
of one command (looking at argv[0] or argv[1]) or as an interactive
session than may execute any number of commands.

We already have a top level pledge that should cover all commands
and that's what interactive mode must continue using.  However, we can
tighten up the pledges when only executing one command.

This is an initial stab at support and may contain regressions.  Most
commands only need "stdio rpath wpath cpath".  The pledges could be
further restricted by evaluating the situation after parsing options.

deraadt@@ and beck@@ are roughly fine with this approach.
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.6 2015/09/11 14:30:23 bcook Exp $ */
d230 1
a230 1
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
@


1.6
log
@Remove engine command and parameters from openssl(1).

We do not have any builtin or dynamic engines, meaning openssl(1) has
no way to use the engine command or parameters at all.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.5 2015/08/19 18:25:31 deraadt Exp $ */
d228 5
@


1.5
log
@bring prototypes into scope, requires movement of a large global object
out of .h file
ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.4 2015/01/08 11:06:12 doug Exp $ */
a71 3
#ifndef OPENSSL_NO_ENGINE
	char *engine;
#endif
a114 9
#ifndef OPENSSL_NO_ENGINE
	{
		.name = "engine",
		.argname = "id",
		.desc = "Use the engine specified by the given identifier",
		.type = OPTION_ARG,
		.opt.arg = &pkcs8_config.engine,
	},
#endif
d211 1
a211 1
	fprintf(stderr, "usage: pkcs8 [-embed] [-engine id] [-in file] "
a221 1
	ENGINE *e = NULL;
a241 4
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, pkcs8_config.engine, 0);
#endif

d271 1
a271 1
		    pkcs8_config.informat, 1, passin, e, "key");
@


1.4
log
@Convert pkcs8.c to the new option handling code.

Minor KNF in a few places too.
input + ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.3 2014/08/28 14:25:48 jsing Exp $ */
d63 1
@


1.3
log
@OpenSSL_add_all_algorithms() is called from openssl_startup() - it does not
need to also be called from some of the applications.
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.2 2014/08/28 14:23:52 jsing Exp $ */
d69 160
a228 1
int pkcs8_main(int, char **);
a233 2
	char **args, *infile = NULL, *outfile = NULL;
	char *passargin = NULL, *passargout = NULL;
a234 7
	int topk8 = 0;
	int pbe_nid = -1;
	const EVP_CIPHER *cipher = NULL;
	int iter = PKCS12_DEFAULT_ITER;
	int informat, outformat;
	int p8_broken = PKCS8_OK;
	int nocrypt = 0;
a238 1
	int badarg = 0;
a239 3
#ifndef OPENSSL_NO_ENGINE
	char *engine = NULL;
#endif
d241 1
a241 2
	informat = FORMAT_PEM;
	outformat = FORMAT_PEM;
d243 9
a251 79
	args = argv + 1;
	while (!badarg && *args && *args[0] == '-') {
		if (!strcmp(*args, "-v2")) {
			if (args[1]) {
				args++;
				cipher = EVP_get_cipherbyname(*args);
				if (!cipher) {
					BIO_printf(bio_err,
					    "Unknown cipher %s\n", *args);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-v1")) {
			if (args[1]) {
				args++;
				pbe_nid = OBJ_txt2nid(*args);
				if (pbe_nid == NID_undef) {
					BIO_printf(bio_err,
					    "Unknown PBE algorithm %s\n", *args);
					badarg = 1;
				}
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-inform")) {
			if (args[1]) {
				args++;
				informat = str2fmt(*args);
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-outform")) {
			if (args[1]) {
				args++;
				outformat = str2fmt(*args);
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-topk8"))
			topk8 = 1;
		else if (!strcmp(*args, "-noiter"))
			iter = 1;
		else if (!strcmp(*args, "-nocrypt"))
			nocrypt = 1;
		else if (!strcmp(*args, "-nooct"))
			p8_broken = PKCS8_NO_OCTET;
		else if (!strcmp(*args, "-nsdb"))
			p8_broken = PKCS8_NS_DB;
		else if (!strcmp(*args, "-embed"))
			p8_broken = PKCS8_EMBEDDED_PARAM;
		else if (!strcmp(*args, "-passin")) {
			if (!args[1])
				goto bad;
			passargin = *(++args);
		} else if (!strcmp(*args, "-passout")) {
			if (!args[1])
				goto bad;
			passargout = *(++args);
		}
#ifndef OPENSSL_NO_ENGINE
		else if (strcmp(*args, "-engine") == 0) {
			if (!args[1])
				goto bad;
			engine = *(++args);
		}
#endif
		else if (!strcmp(*args, "-in")) {
			if (args[1]) {
				args++;
				infile = *args;
			} else
				badarg = 1;
		} else if (!strcmp(*args, "-out")) {
			if (args[1]) {
				args++;
				outfile = *args;
			} else
				badarg = 1;
		} else
			badarg = 1;
		args++;
a253 18
	if (badarg) {
bad:
		BIO_printf(bio_err, "Usage pkcs8 [options]\n");
		BIO_printf(bio_err, "where options are\n");
		BIO_printf(bio_err, "-in file        input file\n");
		BIO_printf(bio_err, "-inform X       input format (DER or PEM)\n");
		BIO_printf(bio_err, "-passin arg     input file pass phrase source\n");
		BIO_printf(bio_err, "-outform X      output format (DER or PEM)\n");
		BIO_printf(bio_err, "-out file       output file\n");
		BIO_printf(bio_err, "-passout arg    output file pass phrase source\n");
		BIO_printf(bio_err, "-topk8          output PKCS8 file\n");
		BIO_printf(bio_err, "-nooct          use (nonstandard) no octet format\n");
		BIO_printf(bio_err, "-embed          use (nonstandard) embedded DSA parameters format\n");
		BIO_printf(bio_err, "-nsdb           use (nonstandard) DSA Netscape DB format\n");
		BIO_printf(bio_err, "-noiter         use 1 as iteration count\n");
		BIO_printf(bio_err, "-nocrypt        use or expect unencrypted private key\n");
		BIO_printf(bio_err, "-v2 alg         use PKCS#5 v2.0 and cipher \"alg\"\n");
		BIO_printf(bio_err, "-v1 obj         use PKCS#5 v1.5 and cipher \"alg\"\n");
d255 1
a255 6
		BIO_printf(bio_err, " -engine e       use engine e, possibly a hardware device.\n");
#endif
		goto end;
	}
#ifndef OPENSSL_NO_ENGINE
	e = setup_engine(bio_err, engine, 0);
d258 2
a259 1
	if (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {
d263 2
a264 2
	if ((pbe_nid == -1) && !cipher)
		pbe_nid = NID_pbeWithMD5AndDES_CBC;
d266 2
a267 2
	if (infile) {
		if (!(in = BIO_new_file(infile, "rb"))) {
d269 2
a270 1
			    "Can't open input file %s\n", infile);
d276 4
a279 4
	if (outfile) {
		if (!(out = BIO_new_file(outfile, "wb"))) {
			BIO_printf(bio_err,
			    "Can't open output file %s\n", outfile);
d285 3
a287 3
	if (topk8) {
		pkey = load_key(bio_err, infile, informat, 1,
		    passin, e, "key");
d290 2
a291 1
		if (!(p8inf = EVP_PKEY2PKCS8_broken(pkey, p8_broken))) {
d296 2
a297 2
		if (nocrypt) {
			if (outformat == FORMAT_PEM)
d299 1
a299 1
			else if (outformat == FORMAT_ASN1)
d302 2
a303 1
				BIO_printf(bio_err, "Bad format specified for key\n");
d311 2
a312 1
				if (EVP_read_pw_string(pass, sizeof pass, "Enter Encryption Password:", 1))
d315 3
a317 3
			if (!(p8 = PKCS8_encrypt(pbe_nid, cipher,
				    p8pass, strlen(p8pass),
				    NULL, 0, iter, p8inf))) {
d322 1
a322 1
			if (outformat == FORMAT_PEM)
d324 1
a324 1
			else if (outformat == FORMAT_ASN1)
d327 2
a328 1
				BIO_printf(bio_err, "Bad format specified for key\n");
d336 5
a340 4
	if (nocrypt) {
		if (informat == FORMAT_PEM)
			p8inf = PEM_read_bio_PKCS8_PRIV_KEY_INFO(in, NULL, NULL, NULL);
		else if (informat == FORMAT_ASN1)
d347 1
a347 1
		if (informat == FORMAT_PEM)
d349 1
a349 1
		else if (informat == FORMAT_ASN1)
d365 2
a366 1
			EVP_read_pw_string(pass, sizeof pass, "Enter Password:", 0);
d389 2
a390 1
			BIO_printf(bio_err, "DSA parameters included in PrivateKey\n");
d394 2
a395 1
			BIO_printf(bio_err, "DSA public key include in PrivateKey\n");
d407 4
a410 3
	if (outformat == FORMAT_PEM)
		PEM_write_bio_PrivateKey(out, pkey, NULL, NULL, 0, NULL, passout);
	else if (outformat == FORMAT_ASN1)
@


1.2
log
@openssl_setup() calls SSL_load_error_strings(), which happens to call
ERR_load_crypto_strings() - as such, we do not need to call the same
function from most of the applications.
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.1 2014/08/26 17:47:25 jsing Exp $ */
a97 1
	OpenSSL_add_all_algorithms();
@


1.1
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pkcs8.c,v 1.21 2014/07/14 00:35:10 deraadt Exp $ */
a97 1
	ERR_load_crypto_strings();
@

