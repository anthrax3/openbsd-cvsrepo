head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.10
date	2015.10.17.15.00.11;	author doug;	state Exp;
branches;
next	1.9;
commitid	eAF5hlziO0omr4Cj;

1.9
date	2015.10.10.22.28.51;	author doug;	state Exp;
branches;
next	1.8;
commitid	7Pr412xEOoY2KZOT;

1.8
date	2015.09.12.15.04.06;	author lteo;	state Exp;
branches;
next	1.7;
commitid	2ujX9ZmGF0cHzMqy;

1.7
date	2015.08.22.16.36.05;	author jsing;	state Exp;
branches;
next	1.6;
commitid	FOQ5PgwxGR8cjJ8X;

1.6
date	2015.02.11.03.19.37;	author doug;	state Exp;
branches;
next	1.5;
commitid	5KSZBoxiLebzObKt;

1.5
date	2015.01.13.03.42.36;	author lteo;	state Exp;
branches;
next	1.4;
commitid	GLGrHUBXx08x66lg;

1.4
date	2014.12.28.15.48.52;	author jsing;	state Exp;
branches;
next	1.3;
commitid	bQimQQipD1DRW09U;

1.3
date	2014.10.13.02.46.14;	author bcook;	state Exp;
branches;
next	1.2;
commitid	Z6BCDPzTn5x0AxGt;

1.2
date	2014.08.27.15.55.23;	author jsing;	state Exp;
branches;
next	1.1;
commitid	OJEZYWyeIPfBresb;

1.1
date	2014.08.26.17.47.25;	author jsing;	state Exp;
branches;
next	;
commitid	7A7DObXgY4Fni8xJ;


desc
@@


1.10
log
@Exit if a pledge call fails in non-interactive mode.

ok semarie@@
@
text
@/* $OpenBSD: prime.c,v 1.9 2015/10/10 22:28:51 doug Exp $ */
/* ====================================================================
 * Copyright (c) 2004 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <string.h>
#include <limits.h>

#include "apps.h"

#include <openssl/bn.h>
#include <openssl/err.h>

struct {
	int bits;
	int checks;
	int generate;
	int hex;
	int safe;
} prime_config;

struct option prime_options[] = {
	{
		.name = "bits",
		.argname = "n",
		.desc = "Number of bits in the generated prime number",
		.type = OPTION_ARG_INT,
		.opt.value = &prime_config.bits,
	},
	{
		.name = "checks",
		.argname = "n",
		.desc = "Miller-Rabin probablistic primality test iterations",
		.type = OPTION_ARG_INT,
		.opt.value = &prime_config.checks,
	},
	{
		.name = "generate",
		.desc = "Generate a pseudo-random prime number",
		.type = OPTION_FLAG,
		.opt.flag = &prime_config.generate,
	},
	{
		.name = "hex",
		.desc = "Hexadecimal prime numbers",
		.type = OPTION_FLAG,
		.opt.flag = &prime_config.hex,
	},
	{
		.name = "safe",
		.desc = "Generate only \"safe\" prime numbers",
		.type = OPTION_FLAG,
		.opt.flag = &prime_config.safe,
	},
	{NULL},
};

static void
prime_usage()
{
	fprintf(stderr,
	    "usage: prime [-bits n] [-checks n] [-generate] [-hex] [-safe] "
	    "p\n");
	options_usage(prime_options);
}

int
prime_main(int argc, char **argv)
{
	BIGNUM *bn = NULL;
	char *prime = NULL;
	BIO *bio_out;
	char *s;
	int ret = 1;

	if (single_execution) {
		if (pledge("stdio rpath", NULL) == -1) {
			perror("pledge");
			exit(1);
		}
	}

	memset(&prime_config, 0, sizeof(prime_config));

	/* Default iterations for Miller-Rabin probabilistic primality test. */
	prime_config.checks = 20;

	if (options_parse(argc, argv, prime_options, &prime, NULL) != 0) {
		prime_usage();
		return (1);
	}

	if (prime == NULL && prime_config.generate == 0) {
		BIO_printf(bio_err, "No prime specified.\n");
		prime_usage();
		return (1);
	}

	if ((bio_out = BIO_new(BIO_s_file())) == NULL) {
		ERR_print_errors(bio_err);
		return (1);
	}
	BIO_set_fp(bio_out, stdout, BIO_NOCLOSE);

	if (prime_config.generate != 0) {
		if (prime_config.bits == 0) {
			BIO_printf(bio_err, "Specify the number of bits.\n");
			goto end;
		}
		bn = BN_new();
		if (!bn) {
			BIO_printf(bio_err, "Out of memory.\n");
			goto end;
		}
		if (!BN_generate_prime_ex(bn, prime_config.bits,
		    prime_config.safe, NULL, NULL, NULL)) {
			BIO_printf(bio_err, "Prime generation error.\n");
			goto end;
		}
		s = prime_config.hex ? BN_bn2hex(bn) : BN_bn2dec(bn);
		if (s == NULL) {
			BIO_printf(bio_err, "Out of memory.\n");
			goto end;
		}
		BIO_printf(bio_out, "%s\n", s);
		free(s);
	} else {
		if (prime_config.hex) {
			if (!BN_hex2bn(&bn, prime)) {
				BIO_printf(bio_err, "%s is an invalid hex "
				    "value.\n", prime);
				goto end;
			}
		} else {
			if (!BN_dec2bn(&bn, prime)) {
				BIO_printf(bio_err, "%s is an invalid decimal "
				    "value.\n", prime);
				goto end;
			}
		}

		BIO_printf(bio_out, "%s is %sprime\n", prime,
		    BN_is_prime_ex(bn, prime_config.checks,
			NULL, NULL) ? "" : "not ");
	}

	ret = 0;

end:
	BN_free(bn);
	BIO_free_all(bio_out);

	return (ret);
}
@


1.9
log
@Initial support for pledges in openssl(1) commands.

openssl(1) has two mechanisms for operating: either a single execution
of one command (looking at argv[0] or argv[1]) or as an interactive
session than may execute any number of commands.

We already have a top level pledge that should cover all commands
and that's what interactive mode must continue using.  However, we can
tighten up the pledges when only executing one command.

This is an initial stab at support and may contain regressions.  Most
commands only need "stdio rpath wpath cpath".  The pledges could be
further restricted by evaluating the situation after parsing options.

deraadt@@ and beck@@ are roughly fine with this approach.
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.8 2015/09/12 15:04:06 lteo Exp $ */
d122 1
a122 1
		if (pledge("stdio rpath", NULL) == -1)
d124 2
@


1.8
log
@Fix the openssl(1) prime command: When checking a decimal number for
primality, do not unnecessarily convert the original decimal number to
hex in the output.

Hex numbers explicitly specified with -hex remain unchanged.

ok beck@@ deraadt@@ jsing@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.7 2015/08/22 16:36:05 jsing Exp $ */
d120 5
@


1.7
log
@Remove all duplicate prototypes for *_main functions (these are already
provided by progs.h). Also, move the FUNCTION type (and flags) into
openssl.c since that is the only place of use. Lastly, remove pointless
'extern' from the prototypes and use char **argv instead of char *argv[]
(the former is used elsewhere).

ok deraadt@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.6 2015/02/11 03:19:37 doug Exp $ */
d180 1
a180 2
		BN_print(bio_out, bn);
		BIO_printf(bio_out, " is %sprime\n",
@


1.6
log
@Enable building with -DOPENSSL_NO_DEPRECATED.

If you didn't enable deprecated code, there were missing err.h and
bn.h includes.  This commit allows building with or without deprecated
code.

This was not derived from an OpenSSL commit.  However, they recently
enabled OPENSSL_NO_DEPRECATED in git and fixed these header problems
in a different way.

Verified with clang that this only changes line numbers in the generated
asm.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.5 2015/01/13 03:42:36 lteo Exp $ */
a110 2

int prime_main(int, char **);
@


1.5
log
@Implement more thorough error checks:

- Check the return value of every relevant function call.

- If BIO_new() returns NULL instead of a valid BIO, do not attempt to
  blindly use the NULL value as a BIO throughout the rest of the code.

- Ensure that bio_out is freed by BIO_free_all() at the end of all
  error paths.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.4 2014/12/28 15:48:52 jsing Exp $ */
d57 1
@


1.4
log
@Provide a mechanism for option parsing to return the number of arguments
that it has consumed. This allows for the handling of multiple unnamed
arguments, including lists of filenames.
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.3 2014/10/13 02:46:14 bcook Exp $ */
d120 1
d138 3
a140 2
	if ((bio_out = BIO_new(BIO_s_file())) != NULL) {
		BIO_set_fp(bio_out, stdout, BIO_NOCLOSE);
d142 1
d147 11
a157 1
			return 1;
a158 3
		bn = BN_new();	/* XXX - unchecked malloc. */
		BN_generate_prime_ex(bn, prime_config.bits, prime_config.safe,
		    NULL, NULL, NULL);
d160 4
d167 13
a179 4
		if (prime_config.hex)
			BN_hex2bn(&bn, prime);
		else
			BN_dec2bn(&bn, prime);
d187 3
d193 1
a193 1
	return 0;
@


1.3
log
@prefer C99 array initialization syntax.

use C99 array initialization syntax for strict C compilers.

from kinichiro, found building with HP/UX compiler

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.2 2014/08/27 15:55:23 jsing Exp $ */
d126 1
a126 1
	if (options_parse(argc, argv, prime_options, &prime) != 0) {
@


1.2
log
@Convert openssl(1) prime to the new options/usage handling.
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.1 2014/08/26 17:47:25 jsing Exp $ */
d99 1
a99 1
	{},
@


1.1
log
@Move openssl(1) from /usr/sbin/openssl to /usr/bin/openssl, since it is not
a system/superuser binary. At the same time, move the source code from its
current lib/libssl/src/apps location to a more appropriate home under
usr.bin/openssl.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: prime.c,v 1.12 2014/07/14 00:35:10 deraadt Exp $ */
d58 53
a115 5
	int hex = 0;
	int checks = 20;
	int generate = 0;
	int bits = 0;
	int safe = 0;
d117 1
a117 1
	const char *errstr = NULL;
d119 6
d126 3
a128 29
	--argc;
	++argv;
	while (argc >= 1 && **argv == '-') {
		if (!strcmp(*argv, "-hex"))
			hex = 1;
		else if (!strcmp(*argv, "-generate"))
			generate = 1;
		else if (!strcmp(*argv, "-bits")) {
			if (--argc < 1)
				goto bad;
			else
				bits = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else if (!strcmp(*argv, "-safe"))
			safe = 1;
		else if (!strcmp(*argv, "-checks")) {
			if (--argc < 1)
				goto bad;
			else
				checks = strtonum(*(++argv), 0, INT_MAX, &errstr);
			if (errstr)
				goto bad;
		} else {
			BIO_printf(bio_err, "Unknown option '%s'\n", *argv);
			goto bad;
		}
		--argc;
		++argv;
d131 4
a134 3
	if (argv[0] == NULL && !generate) {
		BIO_printf(bio_err, "No prime specified\n");
		goto bad;
d136 1
a139 2
	if (generate) {
		char *s;
d141 3
a143 2
		if (!bits) {
			BIO_printf(bio_err, "Specifiy the number of bits.\n");
d146 4
a149 3
		bn = BN_new();
		BN_generate_prime_ex(bn, bits, safe, NULL, NULL, NULL);
		s = hex ? BN_bn2hex(bn) : BN_bn2dec(bn);
d153 2
a154 2
		if (hex)
			BN_hex2bn(&bn, argv[0]);
d156 1
a156 1
			BN_dec2bn(&bn, argv[0]);
d160 2
a161 1
		    BN_is_prime_ex(bn, checks, NULL, NULL) ? "" : "not ");
a167 10

bad:
	if (errstr)
		BIO_printf(bio_err, "invalid argument %s: %s\n", *argv, errstr);
	else {
		BIO_printf(bio_err, "options are\n");
		BIO_printf(bio_err, "%-14s hex\n", "-hex");
		BIO_printf(bio_err, "%-14s number of checks\n", "-checks <n>");
	}
	return 1;
@

