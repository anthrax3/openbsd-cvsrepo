head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2016.09.16.09.25.23;	author fcambus;	state Exp;
branches;
next	1.20;
commitid	JtYhsoxHp96U7yzi;

1.20
date	2015.12.08.01.00.45;	author schwarze;	state Exp;
branches;
next	1.19;
commitid	TNV0QbpyDxYYaU84;

1.19
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	sbrB3Q5CNxcwZpfU;

1.18
date	2015.10.03.14.39.25;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	zC0tPWaolEFluUZx;

1.17
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	Uu5nFG3wCl0LACBb;

1.16
date	2013.11.27.13.32.02;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.23.17.37.22;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.12.13.54.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.23.59.49;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.19.18.29.06;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.19.21.49.02;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.11.07.04.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.03.02.56.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.17.19.37.40;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.16.21.27.58;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.12.05.17.31;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.02.02.03.48.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.02.02.03.44.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@- Removed unnecessary string.h include
- Changed 'format_and_print' argument type to int64_t and casting
  inside the function
- Declaring 'print_counts', 'format_and_print', and 'cnt' as static
- Remove unnecessary cast for NULL, and (void) casts from printfs,
  'mbtowc' and 'format_and_print' calls
- In 'cnt', change bufsz type from ssize_t to size_t to avoid
  converting between pointers to integer types with different sign
  when calling getline (catched when compiling with Clang)
- Use return instead of exit in main

OK jung@@
@
text
@/*	$OpenBSD: wc.c,v 1.20 2015/12/08 01:00:45 schwarze Exp $	*/

/*
 * Copyright (c) 1980, 1987, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/stat.h>
#include <sys/file.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <ctype.h>
#include <err.h>
#include <unistd.h>
#include <util.h>
#include <wchar.h>
#include <wctype.h>

int64_t	tlinect, twordct, tcharct;
int	doline, doword, dochar, humanchar, multibyte;
int	rval;
extern char *__progname;

static void print_counts(int64_t, int64_t, int64_t, char *);
static void format_and_print(int64_t);
static void cnt(char *);

int
main(int argc, char *argv[])
{
	int ch;

	setlocale(LC_CTYPE, "");

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	while ((ch = getopt(argc, argv, "lwchm")) != -1)
		switch(ch) {
		case 'l':
			doline = 1;
			break;
		case 'w':
			doword = 1;
			break;
		case 'm':
			if (MB_CUR_MAX > 1)
				multibyte = 1;
			/* FALLTHROUGH */
		case 'c':
			dochar = 1;
			break;
		case 'h':
			humanchar = 1;
			break;
		case '?':
		default:
			fprintf(stderr,
			    "usage: %s [-c | -m] [-hlw] [file ...]\n",
			    __progname);
			return 1;
		}
	argv += optind;
	argc -= optind;

	/*
	 * wc is unusual in that its flags are on by default, so,
	 * if you don't get any arguments, you have to turn them
	 * all on.
	 */
	if (!doline && !doword && !dochar)
		doline = doword = dochar = 1;

	if (!*argv) {
		cnt(NULL);
	} else {
		int dototal = (argc > 1);

		do {
			cnt(*argv);
		} while(*++argv);

		if (dototal)
			print_counts(tlinect, twordct, tcharct, "total");
	}

	return rval;
}

static void
cnt(char *file)
{
	static char *buf;
	static size_t bufsz;

	FILE *stream;
	char *C;
	wchar_t wc;
	short gotsp;
	ssize_t len;
	int64_t linect, wordct, charct;
	struct stat sbuf;
	int fd;

	linect = wordct = charct = 0;
	stream = NULL;
	if (file) {
		if ((fd = open(file, O_RDONLY, 0)) < 0) {
			warn("%s", file);
			rval = 1;
			return;
		}
	} else  {
		fd = STDIN_FILENO;
	}

	if (!doword && !multibyte) {
		if (bufsz < MAXBSIZE &&
		    (buf = realloc(buf, MAXBSIZE)) == NULL)
			err(1, NULL);
		/*
		 * Line counting is split out because it's a lot
		 * faster to get lines than to get words, since
		 * the word count requires some logic.
		 */
		if (doline) {
			while ((len = read(fd, buf, MAXBSIZE)) > 0) {
				charct += len;
				for (C = buf; len--; ++C)
					if (*C == '\n')
						++linect;
			}
			if (len == -1) {
				warn("%s", file);
				rval = 1;
			}
		}
		/*
		 * If all we need is the number of characters and
		 * it's a directory or a regular or linked file, just
		 * stat the puppy.  We avoid testing for it not being
		 * a special device in case someone adds a new type
		 * of inode.
		 */
		else if (dochar) {
			mode_t ifmt;

			if (fstat(fd, &sbuf)) {
				warn("%s", file);
				rval = 1;
			} else {
				ifmt = sbuf.st_mode & S_IFMT;
				if (ifmt == S_IFREG || ifmt == S_IFLNK
				    || ifmt == S_IFDIR) {
					charct = sbuf.st_size;
				} else {
					while ((len = read(fd, buf, MAXBSIZE)) > 0)
						charct += len;
					if (len == -1) {
						warn("%s", file);
						rval = 1;
					}
				}
			}
		}
	} else {
		if (file == NULL)
			stream = stdin;
		else if ((stream = fdopen(fd, "r")) == NULL) {
			warn("%s", file);
			close(fd);
			rval = 1;
			return;
		}

		/*
		 * Do it the hard way.
		 * According to POSIX, a word is a "maximal string of
		 * characters delimited by whitespace."  Nothing is said
		 * about a character being printing or non-printing.
		 */
		gotsp = 1;
		while ((len = getline(&buf, &bufsz, stream)) > 0) {
			if (multibyte) {
				for (C = buf; *C != '\0'; C += len) {
					++charct;
					len = mbtowc(&wc, C, MB_CUR_MAX);
					if (len == -1) {
						mbtowc(NULL, NULL,
						    MB_CUR_MAX);
						len = 1;
						wc = L' ';
					}
					if (iswspace(wc)) {
						gotsp = 1;
						if (wc == L'\n')
							++linect;
					} else if (gotsp) {
						gotsp = 0;
						++wordct;
					}
				}
			} else {
				charct += len;
				for (C = buf; *C != '\0'; ++C) {
					if (isspace((unsigned char)*C)) {
						gotsp = 1;
						if (*C == '\n')
							++linect;
					} else if (gotsp) {
						gotsp = 0;
						++wordct;
					}
				}
			}
		}
		if (ferror(stream)) {
			warn("%s", file);
			rval = 1;
		}
	}

	print_counts(linect, wordct, charct, file);

	/*
	 * Don't bother checking doline, doword, or dochar -- speeds
	 * up the common case
	 */
	tlinect += linect;
	twordct += wordct;
	tcharct += charct;

	if ((stream == NULL ? close(fd) : fclose(stream)) != 0) {
		warn("%s", file);
		rval = 1;
	}
}

static void
format_and_print(int64_t v)
{
	if (humanchar) {
		char result[FMT_SCALED_STRSIZE];

		fmt_scaled((long long)v, result);
		printf("%7s", result);
	} else {
		printf(" %7lld", v);
	}
}

static void
print_counts(int64_t lines, int64_t words, int64_t chars, char *name)
{
	if (doline)
		format_and_print(lines);
	if (doword)
		format_and_print(words);
	if (dochar)
		format_and_print(chars);

	if (name)
		printf(" %s\n", name);
	else
		printf("\n");
}
@


1.20
log
@UTF-8 support: implement -m for character counting
and use iswspace(3) for word counting.
Requires using getline(3) rather than read(2)
to make sure that characters aren't chopped to pieces.

Using feedback from millert@@ on an earlier version.
Feedback and OK tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.19 2015/10/09 01:37:09 deraadt Exp $	*/
a36 1
#include <string.h>
d47 1
a47 1
int 	rval;
d50 3
a52 3
void	print_counts(int64_t, int64_t, int64_t, char *);
void	format_and_print(long long);
void	cnt(char *);
d84 1
a84 1
			(void)fprintf(stderr,
d87 1
a87 1
			exit(1);
d101 1
a101 1
		cnt((char *)NULL);
d113 1
a113 1
	exit(rval);
d116 1
a116 1
void
d120 1
a120 1
	static ssize_t bufsz;
d215 1
a215 1
						(void)mbtowc(NULL, NULL,
d265 2
a266 2
void 
format_and_print(long long v)
d271 2
a272 2
		(void)fmt_scaled(v, result);
		(void)printf("%7s", result);
d274 1
a274 1
		(void)printf(" %7lld", v);
d278 1
a278 1
void
d282 1
a282 1
		format_and_print((long long)lines);
d284 1
a284 1
		format_and_print((long long)words);
d286 1
a286 1
		format_and_print((long long)chars);
d289 1
a289 1
		(void)printf(" %s\n", name);
d291 1
a291 1
		(void)printf("\n");
@


1.19
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.18 2015/10/03 14:39:25 deraadt Exp $	*/
d43 2
d47 1
a47 1
int	doline, doword, dochar, humanchar;
d60 1
a60 1
	setlocale(LC_ALL, "");
d73 4
a77 1
		case 'm':
d120 6
a125 1
	u_char *C;
d127 1
a127 1
	int len;
a130 1
	u_char buf[MAXBSIZE];
d133 1
d144 4
a147 1
	if (!doword) {
d194 15
a208 1
		/* Do it the hard way... */
d210 28
a237 22
		while ((len = read(fd, buf, MAXBSIZE)) > 0) {
			/*
			 * This loses in the presence of multi-byte characters.
			 * To do it right would require a function to return a
			 * character while knowing how many bytes it consumed.
			 */
			charct += len;
			for (C = buf; len--; ++C) {
				if (isspace(*C)) {
					gotsp = 1;
					if (*C == '\n')
						++linect;
				} else {
					/*
					 * This line implements the POSIX
					 * spec, i.e. a word is a "maximal
					 * string of characters delimited by
					 * whitespace."  Notice nothing was
					 * said about a character being
					 * printing or non-printing.
					 */
					if (gotsp) {
d244 1
a244 1
		if (len == -1) {
d260 1
a260 1
	if (close(fd) != 0) {
@


1.18
log
@wc only opens files read-only, proceses them, and spits results to stdout.
tame "stdio rpath" works, right before calling getopt()
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.17 2015/01/16 06:40:14 deraadt Exp $	*/
d60 2
a61 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.17
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.16 2013/11/27 13:32:02 okan Exp $	*/
d59 3
@


1.16
log
@remove erroneous char cast to switch expression processing getopt(3);
not used in any cases.

ok deraadt@@, guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.15 2013/11/23 17:37:22 deraadt Exp $	*/
d32 3
a40 3
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/file.h>
@


1.15
log
@send a extra space to the bit bucket
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.14 2013/11/12 13:54:50 deraadt Exp $	*/
d61 1
a61 1
		switch((char)ch) {
@


1.14
log
@simpler prototype repairs
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.13 2009/10/27 23:59:49 deraadt Exp $	*/
d188 1
a188 1
				if (isspace (*C)) {
@


1.13
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.12 2008/06/19 18:29:06 otto Exp $	*/
d50 1
@


1.12
log
@do not print spurious whitespace when reading from stdin;
from Bernd Ahlers with a twist from me; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.11 2005/10/19 21:49:02 espie Exp $	*/
a30 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1980, 1987, 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)wc.c	8.2 (Berkeley) 5/2/95";
#else
static char rcsid[] = "$OpenBSD: wc.c,v 1.11 2005/10/19 21:49:02 espie Exp $";
#endif
#endif /* not lint */
@


1.11
log
@Add -h option to display human-readable numbers.

okay otto@@, deraadt@@, jmc@@.

(note that is mostly useless from scripts, hence okay as a non-standard
option).
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.10 2005/04/11 07:04:47 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.10 2005/04/11 07:04:47 deraadt Exp $";
d227 1
a227 1
	print_counts(linect, wordct, charct, file ? file : "");
d266 4
a269 1
	(void)printf(" %s\n", name);
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.9 2003/06/03 02:56:22 millert Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.9 2003/06/03 02:56:22 millert Exp $";
d56 1
d59 1
a59 1
int	doline, doword, dochar;
d73 1
a73 1
	while ((ch = getopt(argc, argv, "lwcm")) != -1)
d85 3
d91 1
a91 1
			    "usage: %s [-c | -m] [-lw] [file ...]\n",
d243 13
a258 1

d260 1
a260 1
		(void)printf(" %7lld", (long long)lines);
d262 1
a262 1
		(void)printf(" %7lld", (long long)words);
d264 1
a264 1
		(void)printf(" %7lld", (long long)chars);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.8 2002/09/17 19:37:40 deraadt Exp $	*/
d42 1
a42 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.8 2002/09/17 19:37:40 deraadt Exp $";
d112 1
a112 1
			print_counts(tlinect, twordct, tcharct, "total"); 
d139 1
a139 1
	
d227 1
a227 1
         * up the common case
@


1.8
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.7 2002/02/16 21:27:58 millert Exp $	*/
d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d42 1
a42 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.7 2002/02/16 21:27:58 millert Exp $";
@


1.7
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.6 2001/11/19 19:02:17 mpech Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.6 2001/11/19 19:02:17 mpech Exp $";
d70 1
a70 3
main(argc, argv)
	int argc;
	char *argv[];
d123 1
a123 2
cnt(file)
	char *file;
d244 1
a244 5
print_counts(lines, words, chars, name)
	int64_t lines;
	int64_t words;
	int64_t chars;
	char *name;
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.5 2001/07/12 05:17:31 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.5 2001/07/12 05:17:31 deraadt Exp $";
d66 2
a67 2
void	print_counts __P((int64_t, int64_t, int64_t, char *));
void	cnt __P((char *));
@


1.5
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.4 1999/02/02 03:48:34 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.4 1999/02/02 03:48:34 millert Exp $";
d74 1
a74 1
	register int ch;
d128 4
a131 4
	register u_char *C;
	register short gotsp;
	register int len;
	register int64_t linect, wordct, charct;
@


1.4
log
@Remove useless cast to quad_t.  Gcc thinks "%qd" in printf is the same as "%lld" so we get a warning on alpha with -Wall.  Live with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.3 1999/02/02 03:44:07 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.3 1999/02/02 03:44:07 millert Exp $";
d255 1
a255 1
		(void)printf(" %7qd", lines);
d257 1
a257 1
		(void)printf(" %7qd", words);
d259 1
a259 1
		(void)printf(" %7qd", chars);
@


1.3
log
@ o Some minor updates from lite2 (mostly in the man page)
 o Add support for large files by using quads as counters
@
text
@d1 1
a1 1
/*	$OpenBSD: wc.c,v 1.2 1996/06/26 05:42:50 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: wc.c,v 1.2 1996/06/26 05:42:50 deraadt Exp $";
d255 1
a255 1
		(void)printf(" %7qd", (quad_t) lines);
d257 1
a257 1
		(void)printf(" %7qd", (quad_t) words);
d259 1
a259 1
		(void)printf(" %7qd", (quad_t) chars);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 2
a5 2
 * Copyright (c) 1980, 1987 Regents of the University of California.
 * All rights reserved.
d37 3
a39 3
char copyright[] =
"@@(#) Copyright (c) 1980, 1987 Regents of the University of California.\n\
 All rights reserved.\n";
d43 5
a47 2
/*static char sccsid[] = "from: @@(#)wc.c	5.7 (Berkeley) 3/2/91";*/
static char rcsid[] = "$OpenBSD: wc.c,v 1.1.1.1 1995/10/18 08:46:51 deraadt Exp $";
a49 2
/* wc line, word and char count */

d55 1
a55 1
#include <errno.h>
a59 1
#include <err.h>
d61 7
a67 5
static void	print_counts();
static void	cnt();
static long	tlinect, twordct, tcharct;
static int	doline, doword, dochar;
static int 	rval = 0;
d72 1
a72 1
	char **argv;
a73 1
	extern int optind;
d92 3
a94 1
			fprintf(stderr, "usage: wc [-c | -m] [-lw] [file ...]\n");
d105 1
a105 1
	if (!doline && !doword && !dochar) {
a106 1
	}
d117 2
a118 3
		if (dototal) {
			print_counts (tlinect, twordct, tcharct, "total"); 
		}
d124 1
a124 2

static void
d131 1
a131 1
	register long linect, wordct, charct;
d139 1
a139 1
			warn ("%s", file);
d149 1
a149 1
		 * line counting is split out because it's a lot
d154 1
a154 1
			while((len = read(fd, buf, MAXBSIZE)) > 0) {
d161 1
a161 1
				warn ("%s", file);
a164 1

d166 1
a166 1
		 * if all we need is the number of characters and
d173 1
a173 1
			int ifmt;
d176 1
a176 1
				warn ("%s", file);
d181 1
a181 1
					|| ifmt == S_IFDIR) {
d184 1
a184 1
					while((len = read(fd, buf, MAXBSIZE)) > 0)
d187 1
a187 1
						warn ("%s", file);
d193 2
a194 4
	}
	else
	{
		/* do it the hard way... */
d197 5
d206 1
a206 1
					if (*C == '\n') {
a207 1
					}
d225 1
a225 1
			warn ("%s", file);
d230 1
a230 1
	print_counts (linect, wordct, charct, file ? file : "");
d232 4
a235 2
	/* don't bother checkint doline, doword, or dochar --- speeds
           up the common case */
d240 2
a241 2
	if (close(fd)) {
		warn ("%s", file);
a245 1

d247 4
a250 4
print_counts (lines, words, chars, name)
	long lines;
	long words;
	long chars;
d255 1
a255 1
		printf(" %7ld", lines);
d257 1
a257 1
		printf(" %7ld", words);
d259 1
a259 1
		printf(" %7ld", chars);
d261 1
a261 1
	printf (" %s\n", name);
@


1.1
log
@Initial revision
@
text
@d1 2
d44 1
a44 1
static char rcsid[] = "$Id: wc.c,v 1.9 1994/01/03 03:11:06 andrew Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
