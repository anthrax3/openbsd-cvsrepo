head	1.9;
access;
symbols
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.20
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.16
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.14
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.12
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.10
	OPENBSD_5_0:1.7.0.8
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.6
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.8
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.6
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.8;
commitid	4VUU04TZM8ebPiy4;

1.8
date	2014.05.18.17.50.11;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.09.16.39.48;	author dim;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.11.16.31.35;	author deraadt;	state Exp;
branches
	1.3.6.1
	1.3.8.1;
next	1.2;

1.2
date	2004.05.19.02.36.26;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	;

1.3.6.1
date	2007.07.09.17.32.51;	author ckuethe;	state Exp;
branches;
next	;

1.3.8.1
date	2007.07.09.17.32.48;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.9
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/* $OpenBSD: funcs.c,v 1.8 2014/05/18 17:50:11 espie Exp $ */
/*
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "file.h"
#include "magic.h"
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#if defined(HAVE_WCHAR_H)
#include <wchar.h>
#endif
#if defined(HAVE_WCTYPE_H)
#include <wctype.h>
#endif

/*
 * Like printf, only we append to a buffer.
 */
protected int
file_printf(struct magic_set *ms, const char *fmt, ...)
{
	va_list ap;
	int len;
	char *buf, *newstr;

	va_start(ap, fmt);
	len = vasprintf(&buf, fmt, ap);
	if (len < 0)
		goto out;
	va_end(ap);

	if (ms->o.buf != NULL) {
		len = asprintf(&newstr, "%s%s", ms->o.buf, buf);
		free(buf);
		if (len < 0)
			goto out;
		free(ms->o.buf);
		buf = newstr;
	}
	ms->o.buf = buf;
	return 0;
out:
	file_error(ms, errno, "vasprintf failed");
	return -1;
}

/*
 * error - print best error message possible
 */
/*VARARGS*/
private void
file_error_core(struct magic_set *ms, int error, const char *f, va_list va,
    uint32_t lineno)
{
	/* Only the first error is ok */
	if (ms->haderr)
		return;
	if (lineno != 0) {
		free(ms->o.buf);
		ms->o.buf = NULL;
		file_printf(ms, "line %u: ", lineno);
	}
        file_printf(ms, f, va);
	if (error > 0)
		file_printf(ms, " (%s)", strerror(error));
	ms->haderr++;
	ms->error = error;
}

/*VARARGS*/
protected void
file_error(struct magic_set *ms, int error, const char *f, ...)
{
	va_list va;
	va_start(va, f);
	file_error_core(ms, error, f, va, 0);
	va_end(va);
}

/*
 * Print an error with magic line number.
 */
/*VARARGS*/
protected void
file_magerror(struct magic_set *ms, const char *f, ...)
{
	va_list va;
	va_start(va, f);
	file_error_core(ms, 0, f, va, ms->line);
	va_end(va);
}

protected void
file_oomem(struct magic_set *ms, size_t len)
{
	file_error(ms, errno, "cannot allocate %zu bytes", len);
}

protected void
file_oomem2(struct magic_set *ms, size_t len, size_t l2)
{
	file_error(ms, errno, "cannot allocate %zu * %zu bytes", len, l2);
}
protected void
file_badseek(struct magic_set *ms)
{
	file_error(ms, errno, "error seeking");
}

protected void
file_badread(struct magic_set *ms)
{
	file_error(ms, errno, "error reading");
}

#ifndef COMPILE_ONLY
protected int
file_buffer(struct magic_set *ms, int fd, const char *inname, const void *buf,
    size_t nb)
{
	int m;
	int mime = ms->flags & MAGIC_MIME;

	if (nb == 0) {
		if ((!mime || (mime & MAGIC_MIME_TYPE)) &&
		    file_printf(ms, mime ? "application/x-empty" :
		    "empty") == -1)
			return -1;
		return 1;
	} else if (nb == 1) {
		if ((!mime || (mime & MAGIC_MIME_TYPE)) &&
		    file_printf(ms, mime ? "application/octet-stream" :
		    "very short file (no magic)") == -1)
			return -1;
		return 1;
	}

#ifdef __EMX__
	if ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {
		switch (file_os2_apptype(ms, inname, buf, nb)) {
		case -1:
			return -1;
		case 0:
			break;
		default:
			return 1;
		}
	}
#endif

	/* try compression stuff */
	if ((ms->flags & MAGIC_NO_CHECK_COMPRESS) != 0 ||
	    (m = file_zmagic(ms, fd, inname, buf, nb)) == 0) {
	    /* Check if we have a tar file */
	    if ((ms->flags & MAGIC_NO_CHECK_TAR) != 0 ||
		(m = file_is_tar(ms, buf, nb)) == 0) {
		/* try tests in /etc/magic (or surrogate magic file) */
		if ((ms->flags & MAGIC_NO_CHECK_SOFT) != 0 ||
		    (m = file_softmagic(ms, buf, nb, BINTEST)) == 0) {
		    /* try known keywords, check whether it is ASCII */
		    if ((ms->flags & MAGIC_NO_CHECK_ASCII) != 0 ||
			(m = file_ascmagic(ms, buf, nb)) == 0) {
			/* abandon hope, all ye who remain here */
			if ((!mime || (mime & MAGIC_MIME_TYPE)) &&
			    file_printf(ms, mime ? "application/octet-stream" :
				"data") == -1)
				return -1;
			m = 1;
		    }
		}
	    }
	}
#ifdef BUILTIN_ELF
	if ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && m == 1 &&
	    nb > 5 && fd != -1) {
		/*
		 * We matched something in the file, so this *might*
		 * be an ELF file, and the file is at least 5 bytes
		 * long, so if it's an ELF file it has at least one
		 * byte past the ELF magic number - try extracting
		 * information from the ELF headers that cannot easily
		 * be extracted with rules in the magic file.
		 */
		(void)file_tryelf(ms, fd, buf, nb);
	}
#endif
	return m;
}
#endif

protected int
file_reset(struct magic_set *ms)
{
	if (ms->mlist == NULL) {
		file_error(ms, 0, "no magic files loaded");
		return -1;
	}
	ms->o.buf = NULL;
	ms->haderr = 0;
	ms->error = -1;
	return 0;
}

#define OCTALIFY(n, o)	\
	/*LINTED*/ \
	(void)(*(n)++ = '\\', \
	*(n)++ = (((uint32_t)*(o) >> 6) & 3) + '0', \
	*(n)++ = (((uint32_t)*(o) >> 3) & 7) + '0', \
	*(n)++ = (((uint32_t)*(o) >> 0) & 7) + '0', \
	(o)++)

protected const char *
file_getbuffer(struct magic_set *ms)
{
	char *pbuf, *op, *np;
	size_t psize, len;

	if (ms->haderr)
		return NULL;

	if (ms->flags & MAGIC_RAW)
		return ms->o.buf;

	/* * 4 is for octal representation, + 1 is for NUL */
	len = strlen(ms->o.buf);
	if (len > (SIZE_MAX - 1) / 4) {
		file_oomem(ms, len);
		return NULL;
	}
	psize = len * 4 + 1;
	if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
		file_oomem(ms, psize);
		return NULL;
	}
	ms->o.pbuf = pbuf;

#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)
	{
		mbstate_t state;
		wchar_t nextchar;
		int mb_conv = 1;
		size_t bytesconsumed;
		char *eop;
		(void)memset(&state, 0, sizeof(mbstate_t));

		np = ms->o.pbuf;
		op = ms->o.buf;
		eop = op + len;

		while (op < eop) {
			bytesconsumed = mbrtowc(&nextchar, op,
			    (size_t)(eop - op), &state);
			if (bytesconsumed == (size_t)(-1) ||
			    bytesconsumed == (size_t)(-2)) {
				mb_conv = 0;
				break;
			}

			if (iswprint(nextchar)) {
				(void)memcpy(np, op, bytesconsumed);
				op += bytesconsumed;
				np += bytesconsumed;
			} else {
				while (bytesconsumed-- > 0)
					OCTALIFY(np, op);
			}
		}
		*np = '\0';

		/* Parsing succeeded as a multi-byte sequence */
		if (mb_conv != 0)
			return ms->o.pbuf;
	}
#endif

	for (np = ms->o.pbuf, op = ms->o.buf; *op; op++) {
		if (isprint((unsigned char)*op)) {
			*np++ = *op;	
		} else {
			OCTALIFY(np, op);
		}
	}
	*np = '\0';
	return ms->o.pbuf;
}

protected int
file_check_mem(struct magic_set *ms, unsigned int level)
{
	size_t len;

	if (level >= ms->c.len) {
		len = (ms->c.len += 20) * sizeof(*ms->c.li);
		ms->c.li = (ms->c.li == NULL) ? malloc(len) :
		    realloc(ms->c.li, len);
		if (ms->c.li == NULL) {
			file_oomem(ms, len);
			return -1;
		}
	}
	ms->c.li[level].got_match = 0;
#ifdef ENABLE_CONDITIONALS
	ms->c.li[level].last_match = 0;
	ms->c.li[level].last_cond = COND_NONE;
#endif /* ENABLE_CONDITIONALS */
	return 0;
}
@


1.8
log
@use reallocarray
okay ian@@, chl@@
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.7 2009/10/27 23:59:37 deraadt Exp $ */
@


1.7
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.6 2009/04/24 18:54:34 chl Exp $ */
d124 5
@


1.6
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.5 2008/05/08 01:40:56 chl Exp $ */
a39 4

#ifndef	lint
FILE_RCSID("@@(#)$Id: funcs.c,v 1.5 2008/05/08 01:40:56 chl Exp $")
#endif	/* lint */
@


1.5
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $ */
a39 10
#if defined(HAVE_LIMITS_H)
#include <limits.h>
#endif
#ifndef SIZE_T_MAX
#ifdef __LP64__
#define SIZE_T_MAX (size_t)0xfffffffffffffffffU
#else
#define SIZE_T_MAX (size_t)0xffffffffU
#endif
#endif
d42 1
a42 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $")
a44 4
#ifndef HAVE_VSNPRINTF
int vsnprintf(char *, size_t, const char *, va_list);
#endif

d46 1
a46 1
 * Like printf, only we print to a buffer and advance it.
d52 2
a53 2
	size_t len, size;
	char *buf;
d56 4
d61 7
a67 25
	len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
	if (len == -1) {
		file_error(ms, errno, "vsnprintf failed");
		return -1;
	} else if (len >= ms->o.left) {
		long diff;	/* XXX: really ptrdiff_t */

		va_end(ap);
		size = (ms->o.size - ms->o.left) + len + 1024;
		if ((buf = realloc(ms->o.buf, size)) == NULL) {
			file_oomem(ms, size);
			return -1;
		}
		diff = ms->o.ptr - ms->o.buf;
		ms->o.ptr = buf + diff;
		ms->o.buf = buf;
		ms->o.left = size - diff;
		ms->o.size = size;

		va_start(ap, fmt);
		len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
		if (len == -1) {
			file_error(ms, errno, "vsnprintf failed");
			return -1;
		}
d69 1
a69 3
	va_end(ap);
	ms->o.ptr += len;
	ms->o.left -= len;
d71 3
a83 1
	size_t len;
a86 1
	len = 0;
d88 7
a94 9
		(void)snprintf(ms->o.buf, ms->o.size, "line %u: ", lineno);
		len = strlen(ms->o.buf);
	}
	(void)vsnprintf(ms->o.buf + len, ms->o.size - len, f, va);
	if (error > 0) {
		len = strlen(ms->o.buf);
		(void)snprintf(ms->o.buf + len, ms->o.size - len, " (%s)",
		    strerror(error));
	}
d145 16
a160 1
    int m;
d163 9
a171 8
    if ((ms->flags & MAGIC_NO_CHECK_APPTYPE) == 0 && inname) {
	switch (file_os2_apptype(ms, inname, buf, nb)) {
	case -1:
	    return -1;
	case 0:
	    break;
	default:
	    return 1;
a172 1
    }
d175 19
a193 20
    /* try compression stuff */
    if ((ms->flags & MAGIC_NO_CHECK_COMPRESS) != 0 ||
        (m = file_zmagic(ms, fd, inname, buf, nb)) == 0) {
	/* Check if we have a tar file */
	if ((ms->flags & MAGIC_NO_CHECK_TAR) != 0 ||
	    (m = file_is_tar(ms, buf, nb)) == 0) {
	    /* try tests in /etc/magic (or surrogate magic file) */
	    if ((ms->flags & MAGIC_NO_CHECK_SOFT) != 0 ||
		(m = file_softmagic(ms, buf, nb)) == 0) {
		/* try known keywords, check whether it is ASCII */
		if ((ms->flags & MAGIC_NO_CHECK_ASCII) != 0 ||
		    (m = file_ascmagic(ms, buf, nb)) == 0) {
		    /* abandon hope, all ye who remain here */
		    if (file_printf(ms, ms->flags & MAGIC_MIME ?
			(nb ? "application/octet-stream" :
			    "application/empty") :
			(nb ? "data" :
			    "empty")) == -1)
			    return -1;
		    m = 1;
a196 1
    }
d198 12
a209 11
    if ((ms->flags & MAGIC_NO_CHECK_ELF) == 0 && m == 1 && nb > 5 && fd != -1) {
	/*
	 * We matched something in the file, so this *might*
	 * be an ELF file, and the file is at least 5 bytes
	 * long, so if it's an ELF file it has at least one
	 * byte past the ELF magic number - try extracting
	 * information from the ELF headers that cannot easily
	 * be extracted with rules in the magic file.
	 */
	(void)file_tryelf(ms, fd, buf, nb);
    }
d211 1
a211 1
    return m;
d222 1
a222 2
	ms->o.ptr = ms->o.buf;
	ms->o.left = ms->o.size;
a247 1
	len = ms->o.size - ms->o.left;
d249 2
a250 1
	if (len > (SIZE_T_MAX - 1) / 4) {
d255 3
a257 7
	if (ms->o.psize < psize) {
		if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
			file_oomem(ms, psize);
			return NULL;
		}
		ms->o.psize = psize;
		ms->o.pbuf = pbuf;
d259 1
d272 1
a272 1
		eop = op + strlen(ms->o.buf);
a331 25
/*
 * Yes these wrappers suffer from buffer overflows, but if your OS does not
 * have the real functions, maybe you should consider replacing your OS?
 */
#ifndef HAVE_VSNPRINTF
int
vsnprintf(char *buf, size_t len, const char *fmt, va_list ap)
{
	return vsprintf(buf, fmt, ap);
}
#endif

#ifndef HAVE_SNPRINTF
/*ARGSUSED*/
int
snprintf(char *buf, size_t len, const char *fmt, ...)
{
	int rv;
	va_list ap;
	va_start(ap, fmt);
	rv = vsprintf(buf, fmt, ap);
	va_end(ap);
	return rv;
}
#endif
@


1.4
log
@Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.3 2005/04/11 16:31:35 deraadt Exp $ */
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
a29 1
#include <limits.h>
a30 1
#include <stddef.h>
d34 16
d52 1
a52 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.3 2005/04/11 16:31:35 deraadt Exp $")
d54 5
d66 1
a66 2
	int len;
	size_t size;
a67 1
	ptrdiff_t diff;
d76 2
d81 1
a81 1
			file_oomem(ms);
d97 1
a99 1
	va_end(ap);
d107 3
a109 2
protected void
file_error(struct magic_set *ms, int error, const char *f, ...)
d111 1
a111 1
	va_list va;
d115 6
a120 3
	va_start(va, f);
	(void)vsnprintf(ms->o.buf, ms->o.size, f, va);
	va_end(va);
d122 1
a122 1
		size_t len = strlen(ms->o.buf);
d130 22
d154 1
a154 1
file_oomem(struct magic_set *ms)
d156 1
a156 1
	file_error(ms, errno, "cannot allocate memory");
d171 1
d173 2
a174 1
file_buffer(struct magic_set *ms, const void *buf, size_t nb)
d177 14
d192 2
a193 1
    if ((m = file_zmagic(ms, buf, nb)) == 0) {
d195 2
a196 1
	if ((m = file_is_tar(ms, buf, nb)) == 0) {
d198 2
a199 1
	    if ((m = file_softmagic(ms, buf, nb)) == 0) {
d201 2
a202 1
		if ((m = file_ascmagic(ms, buf, nb)) == 0) {
d205 4
a208 1
			"application/octet-stream" : "data") == -1)
d215 13
d230 1
d240 1
d246 8
d267 1
d269 1
a269 1
		file_oomem(ms);
a271 1
	/* * 4 is for octal representation, + 1 is for NUL */
d275 1
a275 1
			file_oomem(ms);
d282 39
d325 1
a325 4
			*np++ = '\\';
			*np++ = ((*op >> 6) & 3) + '0';
			*np++ = ((*op >> 3) & 7) + '0';
			*np++ = ((*op >> 0) & 7) + '0';
d331 47
@


1.3
log
@handle -1 potential case from snprintf too
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.2 2004/05/19 02:36:26 tedu Exp $ */
d32 1
d34 1
d40 1
a40 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.2 2004/05/19 02:36:26 tedu Exp $")
d49 2
a50 1
	size_t len;
d52 1
d56 5
a60 2
	len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap);
	if (len == -1 || len >= ms->o.len) {
d62 2
a63 1
		if ((buf = realloc(ms->o.buf, len + 1024)) == NULL) {
d67 2
a68 1
		ms->o.ptr = buf + (ms->o.ptr - ms->o.buf);
d70 2
a71 2
		ms->o.len = ms->o.size - (ms->o.ptr - ms->o.buf);
		ms->o.size = len + 1024;
d74 5
a78 1
		len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap);
d81 1
a81 1
	ms->o.len -= len;
d168 2
a169 2
	char *nbuf, *op, *np;
	size_t nsize;
d177 9
a185 3
	nsize = ms->o.len * 4 + 1;
	if (ms->o.psize < nsize) {
		if ((nbuf = realloc(ms->o.pbuf, nsize)) == NULL) {
d189 2
a190 2
		ms->o.psize = nsize;
		ms->o.pbuf = nbuf;
@


1.3.6.1
log
@Backport security fix.
Original commit by: dim@@openbsd.org
Original commit message:
Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $ */
a31 1
#include <limits.h>
a32 1
#include <stddef.h>
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $")
d47 1
a47 2
	int len;
	size_t size;
a48 1
	ptrdiff_t diff;
d52 2
a53 5
	len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
	if (len == -1) {
		file_error(ms, errno, "vsnprintf failed");
		return -1;
	} else if (len >= ms->o.left) {
d55 1
a55 2
		size = (ms->o.size - ms->o.left) + len + 1024;
		if ((buf = realloc(ms->o.buf, size)) == NULL) {
d59 1
a59 2
		diff = ms->o.ptr - ms->o.buf;
		ms->o.ptr = buf + diff;
d61 2
a62 2
		ms->o.left = size - diff;
		ms->o.size = size;
d65 1
a65 5
		len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
		if (len == -1) {
			file_error(ms, errno, "vsnprintf failed");
			return -1;
		}
d68 1
a68 1
	ms->o.left -= len;
d155 2
a156 2
	char *pbuf, *op, *np;
	size_t psize, len;
d164 3
a166 9
	len = ms->o.size - ms->o.left;
	if (len > (SIZE_T_MAX - 1) / 4) {
		file_oomem(ms);
		return NULL;
	}
	/* * 4 is for octal representation, + 1 is for NUL */
	psize = len * 4 + 1;
	if (ms->o.psize < psize) {
		if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
d170 2
a171 2
		ms->o.psize = psize;
		ms->o.pbuf = pbuf;
@


1.3.8.1
log
@Backport security fix.
Original commit by: dim@@openbsd.org
Original commit message:
Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $ */
a31 1
#include <limits.h>
a32 1
#include <stddef.h>
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.4 2007/07/09 16:39:48 dim Exp $")
d47 1
a47 2
	int len;
	size_t size;
a48 1
	ptrdiff_t diff;
d52 2
a53 5
	len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
	if (len == -1) {
		file_error(ms, errno, "vsnprintf failed");
		return -1;
	} else if (len >= ms->o.left) {
d55 1
a55 2
		size = (ms->o.size - ms->o.left) + len + 1024;
		if ((buf = realloc(ms->o.buf, size)) == NULL) {
d59 1
a59 2
		diff = ms->o.ptr - ms->o.buf;
		ms->o.ptr = buf + diff;
d61 2
a62 2
		ms->o.left = size - diff;
		ms->o.size = size;
d65 1
a65 5
		len = vsnprintf(ms->o.ptr, ms->o.left, fmt, ap);
		if (len == -1) {
			file_error(ms, errno, "vsnprintf failed");
			return -1;
		}
d68 1
a68 1
	ms->o.left -= len;
d155 2
a156 2
	char *pbuf, *op, *np;
	size_t psize, len;
d164 3
a166 9
	len = ms->o.size - ms->o.left;
	if (len > (SIZE_T_MAX - 1) / 4) {
		file_oomem(ms);
		return NULL;
	}
	/* * 4 is for octal representation, + 1 is for NUL */
	psize = len * 4 + 1;
	if (ms->o.psize < psize) {
		if ((pbuf = realloc(ms->o.pbuf, psize)) == NULL) {
d170 2
a171 2
		ms->o.psize = psize;
		ms->o.pbuf = pbuf;
@


1.2
log
@remove old file, rcsids
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.1 2004/05/19 02:32:35 tedu Exp $")
d52 2
a53 1
	if ((len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap)) >= ms->o.len) {
@


1.1
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
d38 1
a38 1
FILE_RCSID("@@(#)$Id: funcs.c,v 1.11 2003/11/11 20:01:46 christos Exp $")
@

