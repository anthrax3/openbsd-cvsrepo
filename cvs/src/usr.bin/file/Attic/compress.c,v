head	1.17;
access;
symbols
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.16
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.16;
commitid	4VUU04TZM8ebPiy4;

1.16
date	2013.04.20.19.02.57;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.10.20.59.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.02.00.21.16;	author avsm;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.07.21.13.54;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.22.24.08;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	98.07.10.15.05.19;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.02.09.23.58.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.08;	author deraadt;	state Exp;
branches;
next	;

1.5.4.1
date	2003.03.12.02.14.16;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.17
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/*	$OpenBSD: compress.c,v 1.16 2013/04/20 19:02:57 deraadt Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * compress routines:
 *	zmagic() - returns 0 if not recognized, uncompresses and prints
 *		   information if recognized
 *	uncompress(method, old, n, newch) - uncompress old into new, 
 *					    using method, return sizeof new
 */
#include "file.h"
#include "magic.h"
#include <stdio.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <string.h>
#include <errno.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#if defined(HAVE_SYS_TIME_H)
#include <sys/time.h>
#endif
#if defined(HAVE_ZLIB_H) && defined(HAVE_LIBZ)
#define BUILTIN_DECOMPRESS
#include <zlib.h>
#endif


private const struct {
	const char magic[8];
	size_t maglen;
	const char *argv[3];
	int silent;
} compr[] = {
	{ "\037\235", 2, { "gzip", "-cdq", NULL }, 1 },		/* compressed */
	/* Uncompress can get stuck; so use gzip first if we have it
	 * Idea from Damien Clark, thanks! */
	{ "\037\235", 2, { "uncompress", "-c", NULL }, 1 },	/* compressed */
	{ "\037\213", 2, { "gzip", "-cdq", NULL }, 1 },		/* gzipped */
	{ "\037\236", 2, { "gzip", "-cdq", NULL }, 1 },		/* frozen */
	{ "\037\240", 2, { "gzip", "-cdq", NULL }, 1 },		/* SCO LZH */
	/* the standard pack utilities do not accept standard input */
	{ "\037\036", 2, { "gzip", "-cdq", NULL }, 0 },		/* packed */
	{ "PK\3\4",   4, { "gzip", "-cdq", NULL }, 1 },		/* pkzipped, */
					    /* ...only first file examined */
	{ "BZh",      3, { "bzip2", "-cd", NULL }, 1 },		/* bzip2-ed */
};

private size_t ncompr = sizeof(compr) / sizeof(compr[0]);

#define NODATA ((size_t)~0)


private ssize_t swrite(int, const void *, size_t);
private size_t uncompressbuf(struct magic_set *, int, size_t,
    const unsigned char *, unsigned char **, size_t);
#ifdef BUILTIN_DECOMPRESS
private size_t uncompressgzipped(struct magic_set *, const unsigned char *,
    unsigned char **, size_t);
#endif

protected int
file_zmagic(struct magic_set *ms, int fd, const char *name,
    const unsigned char *buf, size_t nbytes)
{
	unsigned char *newbuf = NULL;
	size_t i, nsz;
	int rv = 0;
	int mime = ms->flags & MAGIC_MIME;

	if ((ms->flags & MAGIC_COMPRESS) == 0)
		return 0;

	for (i = 0; i < ncompr; i++) {
		if (nbytes < compr[i].maglen)
			continue;
		if (memcmp(buf, compr[i].magic, compr[i].maglen) == 0 &&
		    (nsz = uncompressbuf(ms, fd, i, buf, &newbuf,
		    nbytes)) != NODATA) {
			ms->flags &= ~MAGIC_COMPRESS;
			rv = -1;
			if (file_buffer(ms, -1, name, newbuf, nsz) == -1)
				goto error;

			if (mime == MAGIC_MIME || mime == 0) {
				if (file_printf(ms, mime ?
				    " compressed-encoding=" : " (") == -1)
					goto error;
			}

			if ((mime == 0 || mime & MAGIC_MIME_ENCODING) &&
			    file_buffer(ms, -1, NULL, buf, nbytes) == -1)
				goto error;

			if (!mime && file_printf(ms, ")") == -1)
				goto error;
			rv = 1;
			break;
		}
	}
error:
	if (newbuf)
		free(newbuf);
	ms->flags |= MAGIC_COMPRESS;
	return rv;
}

/*
 * `safe' write for sockets and pipes.
 */
private ssize_t
swrite(int fd, const void *buf, size_t n)
{
	int rv;
	size_t rn = n;

	do
		switch (rv = write(fd, buf, n)) {
		case -1:
			if (errno == EINTR)
				continue;
			return -1;
		default:
			n -= rv;
			buf = ((const char *)buf) + rv;
			break;
		}
	while (n > 0);
	return rn;
}


/*
 * `safe' read for sockets and pipes.
 */
protected ssize_t
sread(int fd, void *buf, size_t n, int canbepipe)
{
	int rv, cnt;
#ifdef FIONREAD
	int t = 0;
#endif
	size_t rn = n;

	if (fd == STDIN_FILENO)
		goto nocheck;

#ifdef FIONREAD
	if ((canbepipe && (ioctl(fd, FIONREAD, &t) == -1)) || (t == 0)) {
#ifdef FD_ZERO
		for (cnt = 0;; cnt++) {
			struct pollfd pfd[1];
			int rv;

			pfd[0].fd = fd;
			pfd[0].events = POLLIN;

			/*
			 * Avoid soft deadlock: do not read if there
			 * is nothing to read from sockets and pipes.
			 */
			rv = poll(pfd, 1, 100);
			if (rv == -1) {
				if (errno == EINTR || errno == EAGAIN)
					continue;
			} else if (rv == 0 && cnt >= 5) {
				return 0;
			} else
				break;
		}
#endif
		(void)ioctl(fd, FIONREAD, &t);
	}

	if (t > 0 && (size_t)t < n) {
		n = t;
		rn = n;
	}
#endif

nocheck:
	do
		switch ((rv = read(fd, buf, n))) {
		case -1:
			if (errno == EINTR)
				continue;
			return -1;
		case 0:
			return rn - n;
		default:
			n -= rv;
			buf = ((char *)buf) + rv;
			break;
		}
	while (n > 0);
	return rn;
}

protected int
file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,
    size_t nbytes)
{
	char buf[4096];
	int r, tfd;

	(void)strlcpy(buf, "/tmp/file.XXXXXX", sizeof buf);
	tfd = mkstemp(buf);
	r = errno;
	(void)unlink(buf);
	errno = r;
	if (tfd == -1) {
		file_error(ms, errno,
		    "cannot create temporary file for pipe copy");
		return -1;
	}

	if (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)
		r = 1;
	else {
		while ((r = sread(fd, buf, sizeof(buf), 1)) > 0)
			if (swrite(tfd, buf, (size_t)r) != r)
				break;
	}

	switch (r) {
	case -1:
		file_error(ms, errno, "error copying from pipe to temp file");
		return -1;
	case 0:
		break;
	default:
		file_error(ms, errno, "error while writing to temp file");
		return -1;
	}

	/*
	 * We duplicate the file descriptor, because fclose on a
	 * tmpfile will delete the file, but any open descriptors
	 * can still access the phantom inode.
	 */
	if ((fd = dup2(tfd, fd)) == -1) {
		file_error(ms, errno, "could not dup descriptor for temp file");
		return -1;
	}
	(void)close(tfd);
	if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}
	return fd;
}

#ifdef BUILTIN_DECOMPRESS

#define FHCRC		(1 << 1)
#define FEXTRA		(1 << 2)
#define FNAME		(1 << 3)
#define FCOMMENT	(1 << 4)

private size_t
uncompressgzipped(struct magic_set *ms, const unsigned char *old,
    unsigned char **newch, size_t n)
{
	unsigned char flg = old[3];
	size_t data_start = 10;
	z_stream z;
	int rc;

	if (flg & FEXTRA) {
		if (data_start+1 >= n)
			return 0;
		data_start += 2 + old[data_start] + old[data_start + 1] * 256;
	}
	if (flg & FNAME) {
		while(data_start < n && old[data_start])
			data_start++;
		data_start++;
	}
	if(flg & FCOMMENT) {
		while(data_start < n && old[data_start])
			data_start++;
		data_start++;
	}
	if(flg & FHCRC)
		data_start += 2;

	if (data_start >= n)
		return 0;
	if ((*newch = (unsigned char *)malloc(HOWMANY + 1)) == NULL) {
		return 0;
	}
	
	/* XXX: const castaway, via strchr */
	z.next_in = (Bytef *)strchr((const char *)old + data_start,
	    old[data_start]);
	z.avail_in = n - data_start;
	z.next_out = *newch;
	z.avail_out = HOWMANY;
	z.zalloc = Z_NULL;
	z.zfree = Z_NULL;
	z.opaque = Z_NULL;

	rc = inflateInit2(&z, -15);
	if (rc != Z_OK) {
		file_error(ms, 0, "zlib: %s", z.msg);
		return 0;
	}

	rc = inflate(&z, Z_SYNC_FLUSH);
	if (rc != Z_OK && rc != Z_STREAM_END) {
		file_error(ms, 0, "zlib: %s", z.msg);
		return 0;
	}

	n = (size_t)z.total_out;
	(void)inflateEnd(&z);
	
	/* let's keep the nul-terminate tradition */
	(*newch)[n] = '\0';

	return n;
}
#endif

private size_t
uncompressbuf(struct magic_set *ms, int fd, size_t method,
    const unsigned char *old, unsigned char **newch, size_t n)
{
	int fdin[2], fdout[2];
	int r;

#ifdef BUILTIN_DECOMPRESS
        /* FIXME: This doesn't cope with bzip2 */
	if (method == 2)
		return uncompressgzipped(ms, old, newch, n);
#endif
	(void)fflush(stdout);
	(void)fflush(stderr);

	if ((fd != -1 && pipe(fdin) == -1) || pipe(fdout) == -1) {
		file_error(ms, errno, "cannot create pipe");	
		return NODATA;
	}
	switch (fork()) {
	case 0:	/* child */
		(void) close(0);
		if (fd != -1) {
		    (void) dup(fd);
		    (void) lseek(0, (off_t)0, SEEK_SET);
		} else {
		    (void) dup(fdin[0]);
		    (void) close(fdin[0]);
		    (void) close(fdin[1]);
		}

		(void) close(1);
		(void) dup(fdout[1]);
		(void) close(fdout[0]);
		(void) close(fdout[1]);
#ifndef DEBUG
		if (compr[method].silent)
			(void)close(2);
#endif

		(void)execvp(compr[method].argv[0],
		    (char *const *)(intptr_t)compr[method].argv);
#ifdef DEBUG
		(void)fprintf(stderr, "exec `%s' failed (%s)\n",
		    compr[method].argv[0], strerror(errno));
#endif
		exit(1);
		/*NOTREACHED*/
	case -1:
		file_error(ms, errno, "could not fork");
		return NODATA;

	default: /* parent */
		(void) close(fdout[1]);
		if (fd == -1) {
			(void) close(fdin[0]);
			/* 
			 * fork again, to avoid blocking because both
			 * pipes filled
			 */
			switch (fork()) {
			case 0: /* child */
				(void)close(fdout[0]);
				if (swrite(fdin[1], old, n) != (ssize_t)n) {
#ifdef DEBUG
					(void)fprintf(stderr,
					    "Write failed (%s)\n",
					    strerror(errno));
#endif
					exit(1);
				}
				exit(0);
				/*NOTREACHED*/

			case -1:
#ifdef DEBUG
				(void)fprintf(stderr, "Fork failed (%s)\n",
				    strerror(errno));
#endif
				exit(1);
				/*NOTREACHED*/

			default:  /* parent */
				break;
			}
			(void) close(fdin[1]);
			fdin[1] = -1;
		}

		if ((*newch = (unsigned char *) malloc(HOWMANY + 1)) == NULL) {
#ifdef DEBUG
			(void)fprintf(stderr, "Malloc failed (%s)\n",
			    strerror(errno));
#endif
			n = 0;
			goto err;
		}
		if ((r = sread(fdout[0], *newch, HOWMANY, 0)) <= 0) {
#ifdef DEBUG
			(void)fprintf(stderr, "Read failed (%s)\n",
			    strerror(errno));
#endif
			free(*newch);
			n = 0;
			newch[0] = '\0';
			goto err;
		} else {
			n = r;
		}
 		/* NUL terminate, as every buffer is handled here. */
 		(*newch)[n] = '\0';
err:
		if (fdin[1] != -1)
			(void) close(fdin[1]);
		(void) close(fdout[0]);
#ifdef WNOHANG
		while (waitpid(-1, NULL, WNOHANG) != -1)
			continue;
#else
		(void)wait(NULL);
#endif
		return n;
	}
}
@


1.16
log
@use poll() instead of select() with a limited-size fd_set
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.15 2011/01/10 20:59:42 deraadt Exp $ */
@


1.15
log
@delete embarrasingly horrid use of mktemp() brought in from upstream
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.14 2009/10/27 23:59:37 deraadt Exp $ */
d45 1
d183 2
a184 3
			fd_set check;
			struct timeval tout = {0, 100 * 1000};
			int selrv;
d186 2
a187 2
			FD_ZERO(&check);
			FD_SET(fd, &check);
d193 2
a194 2
			selrv = select(fd + 1, &check, NULL, NULL, &tout);
			if (selrv == -1) {
d197 1
a197 1
			} else if (selrv == 0 && cnt >= 5) {
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.13 2009/04/24 18:54:34 chl Exp $ */
a237 9
#ifndef HAVE_MKSTEMP
	{
		char *ptr = mktemp(buf);
		tfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);
		r = errno;
		(void)unlink(ptr);
		errno = r;
	}
#else
a241 1
#endif
@


1.13
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.12 2008/05/08 01:40:56 chl Exp $ */
a57 4

#ifndef lint
FILE_RCSID("@@(#)$Id: compress.c,v 1.12 2008/05/08 01:40:56 chl Exp $")
#endif
@


1.12
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.11 2004/05/19 02:32:35 tedu Exp $ */
d53 2
a54 1
#ifdef HAVE_LIBZ
d60 1
a60 1
FILE_RCSID("@@(#)$Id: compress.c,v 1.11 2004/05/19 02:32:35 tedu Exp $")
d63 2
a64 2
private struct {
	const char *magic;
d66 1
a66 1
	const char *const argv[3];
d91 1
a91 1
#ifdef HAVE_LIBZ
d103 1
d118 9
a126 1
			if (file_printf(ms, " (") == -1)
d128 2
a129 3
			if (file_buffer(ms, -1, NULL, buf, nbytes) == -1)
				goto error;
			if (file_printf(ms, ")") == -1)
d298 1
a298 1
#ifdef HAVE_LIBZ
d377 2
a378 1
#ifdef HAVE_LIBZ
@


1.11
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d46 1
d50 3
a52 1
#undef HAVE_LIBZ
d57 1
d59 1
a59 1
FILE_RCSID("@@(#)$Id: compress.c,v 1.36 2004/03/22 19:11:54 christos Exp $")
a61 1

d77 2
d82 3
a84 1
private int ncompr = sizeof(compr) / sizeof(compr[0]);
d88 2
a89 3
private ssize_t sread(int, void *, size_t);
private size_t uncompressbuf(struct magic_set *, size_t, const unsigned char *,
    unsigned char **, size_t);
d96 2
a97 1
file_zmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes)
d110 2
a111 1
		    (nsz = uncompressbuf(ms, i, buf, &newbuf, nbytes)) != 0) {
d114 1
a114 1
			if (file_buffer(ms, newbuf, nsz) == -1)
d118 1
a118 1
			if (file_buffer(ms, buf, nbytes) == -1)
d161 2
a162 2
private ssize_t
sread(int fd, void *buf, size_t n)
d164 4
a167 1
	int rv;
d170 38
d209 1
a209 1
		switch (rv = read(fd, buf, n)) {
d256 1
a256 1
		while ((r = sread(fd, buf, sizeof(buf))) > 0)
d352 1
a352 1
	inflateEnd(&z);
d355 1
a355 1
	(*newch)[n++] = '\0';
d362 2
a363 2
uncompressbuf(struct magic_set *ms, size_t method, const unsigned char *old,
    unsigned char **newch, size_t n)
a367 3
	/* The buffer is NUL terminated, and we don't need that. */
	n--;
	 
d372 2
d375 1
a375 1
	if (pipe(fdin) == -1 || pipe(fdout) == -1) {
d377 1
a377 1
		return 0;
d382 8
a389 3
		(void) dup(fdin[0]);
		(void) close(fdin[0]);
		(void) close(fdin[1]);
d395 1
d397 2
a398 1
			(void) close(2);
d400 6
a405 2
		execvp(compr[method].argv[0],
		       (char *const *)compr[method].argv);
d410 1
a410 1
		return 0;
a412 1
		(void) close(fdin[0]);
d414 25
a438 5
		/* fork again, to avoid blocking because both pipes filled */
		switch (fork()) {
		case 0: /* child */
			(void)close(fdout[0]);
			if (swrite(fdin[1], old, n) != n)
d440 1
a440 2
			exit(0);
			/*NOTREACHED*/
d442 6
a447 3
		case -1:
			exit(1);
			/*NOTREACHED*/
a448 5
		default:  /* parent */
			break;
		}
		(void) close(fdin[1]);
		fdin[1] = -1;
d450 4
d457 5
a461 1
		if ((r = sread(fdout[0], *newch, HOWMANY)) <= 0) {
d470 1
a470 1
 		(*newch)[n++] = '\0';
@


1.10
log
@bump randomness of mktemp to from 6 to 10 X's, as recommended by mktemp(3)
@
text
@d1 1
a1 2
/*	$OpenBSD: compress.c,v 1.9 2003/06/13 18:31:14 deraadt Exp $	*/

a2 6
 * compress routines:
 *	zmagic() - returns 0 if not recognized, uncompresses and prints
 *		   information if recognized
 *	uncompress(method, old, n, newch) - uncompress old into new, 
 *					    using method, return sizeof new
 *
d29 7
a35 1

d37 2
d40 1
a40 1
#ifdef	HAVE_UNISTD_H
d44 3
a46 1
#ifdef	HAVE_SYS_WAIT_H
d49 2
a50 4
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#ifdef	HAVE_LIBZ
d54 10
a63 5
static struct {
   const char *magic;
   int   maglen;
   const char *const argv[3];
   int	 silent;
d65 10
a74 6
    { "\037\235", 2, { "uncompress", "-c", NULL }, 0 },	/* compressed */
    { "\037\213", 2, { "gzip", "-cdq", NULL }, 1 },	/* gzipped */
    { "\037\236", 2, { "gzip", "-cdq", NULL }, 1 },	/* frozen */
    { "\037\240", 2, { "gzip", "-cdq", NULL }, 1 },	/* SCO LZH */
    /* the standard pack utilities do not accept standard input */
    { "\037\036", 2, { "gzip", "-cdq", NULL }, 0 },	/* packed */
d77 1
a77 1
static int ncompr = sizeof(compr) / sizeof(compr[0]);
d80 8
a87 3
static int swrite(int, const void *, size_t);
static int sread(int, void *, size_t);
static int uncompress(int, const unsigned char *, unsigned char **, int);
d89 2
a90 4
int
zmagic(buf, nbytes)
unsigned char *buf;
int nbytes;
d92 6
a97 3
	unsigned char *newbuf;
	int newsize;
	int i;
d102 13
a114 1
		if (memcmp(buf, compr[i].magic,  compr[i].maglen) == 0)
d116 1
d118 2
a119 6

	if (i == ncompr)
		return 0;

	if ((newsize = uncompress(i, buf, &newbuf, nbytes)) != 0) {
		tryit(newbuf, newsize, 1);
d121 2
a122 5
		printf(" (");
		tryit(buf, nbytes, 0);
		printf(")");
	}
	return 1;
d128 1
a128 1
static int
d149 1
d153 1
a153 1
static int
d176 3
a178 2
int
pipe2file(int fd, void *startbuf, size_t nbytes)
d183 1
a183 1
	(void)strlcpy(buf, "/tmp/file.XXXXXXXXXX", sizeof buf);
d199 3
a201 3
		error("Can't create temporary file for pipe copy (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
d204 1
a204 1
	if (swrite(tfd, startbuf, nbytes) != nbytes)
d208 1
a208 1
			if (swrite(tfd, buf, r) != r)
d214 2
a215 3
		error("Error copying from pipe to temp file (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
d219 2
a220 3
		error("Error while writing to temp file (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
d229 2
a230 3
		error("Couldn't dup destcriptor for temp file(%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
d234 2
a235 2
		error("Couldn't seek on temp file (%s)\n", strerror(errno));
		/*NOTREACHED*/
d240 75
a314 6
static int
uncompress(method, old, newch, n)
int method;
const unsigned char *old;
unsigned char **newch;
int n;
d317 9
d328 2
a329 2
		err(1, "cannot create pipe");	
		/*NOTREACHED*/
d343 1
a343 1
		    (void) close(2);
d345 3
a347 2
		execvp(compr[method].argv[0], (char *const *)compr[method].argv);
		err(1, "could not execute `%s'", compr[method].argv[0]);
d350 2
a351 2
		err(1, "could not fork");
		/*NOTREACHED*/
d356 7
a362 2
		if (write(fdin[1], old, n) != n) {
			err(1, "write failed");
d364 7
d373 4
a376 3
		if ((*newch = (unsigned char *) malloc(n)) == NULL) {
			err(1, "malloc");
			/*NOTREACHED*/
d378 1
a378 1
		if ((n = read(fdout[0], *newch, n)) <= 0) {
d380 5
a384 2
			err(1, "read failed");
			/*NOTREACHED*/
d386 5
d392 6
a397 1
		(void) wait(NULL);
@


1.9
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.8 2003/04/07 21:13:54 deraadt Exp $	*/
d159 1
a159 1
	(void)strlcpy(buf, "/tmp/file.XXXXXX", sizeof buf);
@


1.8
log
@replace strcpy calls that got inlined by gcc; Hans-Joerg.Hoexer@@yerbouti.franken.de
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.7 2003/03/11 21:26:26 ian Exp $	*/
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.6 2003/03/03 22:24:08 ian Exp $	*/
d164 1
a164 1
	(void)strcpy(buf, "/tmp/file.XXXXXX");
@


1.6
log
@Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.5 2002/02/16 21:27:46 millert Exp $	*/
d9 31
d41 1
@


1.5
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.4 1998/07/10 15:05:19 mickey Exp $	*/
d10 7
d18 1
a20 2
#include <unistd.h>
#include <string.h>
d22 3
a24 2

#include "file.h"
d27 1
a27 1
   char *magic;
d29 1
a29 1
   char *argv[3];
d43 2
d76 115
d219 1
a219 1
		execvp(compr[method].argv[0], compr[method].argv);
@


1.5.4.1
log
@Pull patch from current.
Fix by ian@@
Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.6 2003/03/03 22:24:08 ian Exp $	*/
d10 2
a11 1
#include "file.h"
a12 1
#ifdef	HAVE_UNISTD_H
a13 1
#endif
a14 5
#ifdef	HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#include <stdio.h>
#include <stdlib.h>
d16 2
a17 3
#ifdef	HAVE_LIBZ
#include <zlib.h>
#endif
d20 1
a20 1
   const char *magic;
d22 1
a22 1
   const char *const argv[3];
a35 2
static int swrite(int, const void *, size_t);
static int sread(int, void *, size_t);
a66 115
/*
 * `safe' write for sockets and pipes.
 */
static int
swrite(int fd, const void *buf, size_t n)
{
	int rv;
	size_t rn = n;

	do
		switch (rv = write(fd, buf, n)) {
		case -1:
			if (errno == EINTR)
				continue;
			return -1;
		default:
			n -= rv;
			buf = ((const char *)buf) + rv;
			break;
		}
	while (n > 0);
	return rn;
}

/*
 * `safe' read for sockets and pipes.
 */
static int
sread(int fd, void *buf, size_t n)
{
	int rv;
	size_t rn = n;

	do
		switch (rv = read(fd, buf, n)) {
		case -1:
			if (errno == EINTR)
				continue;
			return -1;
		case 0:
			return rn - n;
		default:
			n -= rv;
			buf = ((char *)buf) + rv;
			break;
		}
	while (n > 0);
	return rn;
}

int
pipe2file(int fd, void *startbuf, size_t nbytes)
{
	char buf[4096];
	int r, tfd;

	(void)strcpy(buf, "/tmp/file.XXXXXX");
#ifndef HAVE_MKSTEMP
	{
		char *ptr = mktemp(buf);
		tfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);
		r = errno;
		(void)unlink(ptr);
		errno = r;
	}
#else
	tfd = mkstemp(buf);
	r = errno;
	(void)unlink(buf);
	errno = r;
#endif
	if (tfd == -1) {
		error("Can't create temporary file for pipe copy (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
	}

	if (swrite(tfd, startbuf, nbytes) != nbytes)
		r = 1;
	else {
		while ((r = sread(fd, buf, sizeof(buf))) > 0)
			if (swrite(tfd, buf, r) != r)
				break;
	}

	switch (r) {
	case -1:
		error("Error copying from pipe to temp file (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
	case 0:
		break;
	default:
		error("Error while writing to temp file (%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
	}

	/*
	 * We duplicate the file descriptor, because fclose on a
	 * tmpfile will delete the file, but any open descriptors
	 * can still access the phantom inode.
	 */
	if ((fd = dup2(tfd, fd)) == -1) {
		error("Couldn't dup destcriptor for temp file(%s)\n",
		    strerror(errno));
		/*NOTREACHED*/
	}
	(void)close(tfd);
	if (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) {
		error("Couldn't seek on temp file (%s)\n", strerror(errno));
		/*NOTREACHED*/
	}
	return fd;
}
d95 1
a95 1
		execvp(compr[method].argv[0], (char *const *)compr[method].argv);
@


1.4
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.3 1997/02/09 23:58:19 millert Exp $	*/
d36 1
a36 1
static int uncompress __P((int, const unsigned char *, unsigned char **, int));
@


1.3
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: compress.c,v 1.2 1996/06/26 05:32:55 deraadt Exp $	*/
d10 1
d15 1
a15 1
#include <sys/wait.h>
d78 1
a78 1
		error("cannot create pipe (%s).\n", strerror(errno));	
d96 1
a96 2
		error("could not execute `%s' (%s).\n", 
		      compr[method].argv[0], strerror(errno));
d99 1
a99 1
		error("could not fork (%s).\n", strerror(errno));
d106 1
a106 1
			error("write failed (%s).\n", strerror(errno));
d111 1
a111 1
			error("out of memory.\n");
d116 1
a116 1
			error("read failed (%s).\n", strerror(errno));
@


1.2
log
@rcsid
@
text
@d1 2
a2 1
/*	$OpenBSD: compress.c,v 1.1.1.1 1995/10/18 08:45:08 deraadt Exp$	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a7 1
 * $Id: compress.c,v 1.4 1995/05/21 00:13:28 christos Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
