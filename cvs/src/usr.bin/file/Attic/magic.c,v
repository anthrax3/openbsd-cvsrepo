head	1.11;
access;
symbols
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.10;
commitid	4VUU04TZM8ebPiy4;

1.10
date	2015.01.16.08.24.04;	author doug;	state Exp;
branches;
next	1.9;
commitid	3kmy59NzQyG8Ee1H;

1.9
date	2014.10.11.03.06.44;	author doug;	state Exp;
branches;
next	1.8;
commitid	gbyKEbyEUtzKnDXs;

1.8
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.08.27.16.26.43;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.02.15.19.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.09.16.39.48;	author dim;	state Exp;
branches;
next	1.2;

1.2
date	2004.05.19.02.36.26;	author tedu;	state Exp;
branches
	1.2.10.1
	1.2.12.1;
next	1.1;

1.1
date	2004.05.19.02.34.27;	author tedu;	state Exp;
branches;
next	;

1.2.10.1
date	2007.07.09.17.32.51;	author ckuethe;	state Exp;
branches;
next	;

1.2.12.1
date	2007.07.09.17.32.48;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.11
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/* $OpenBSD: magic.c,v 1.10 2015/01/16 08:24:04 doug Exp $ */
/*
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include "file.h"
#include "magic.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#ifdef QUICK
#include <sys/mman.h>
#endif
#include <limits.h>	/* for PIPE_BUF */

#if defined(HAVE_UTIMES)
# include <sys/time.h>
#elif defined(HAVE_UTIME)
# if defined(HAVE_SYS_UTIME_H)
#  include <sys/utime.h>
# elif defined(HAVE_UTIME_H)
#  include <utime.h>
# endif
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>	/* for read() */
#endif

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#include <netinet/in.h>		/* for byte swapping */

#include "patchlevel.h"

#ifndef PIPE_BUF 
/* Get the PIPE_BUF from pathconf */
#ifdef _PC_PIPE_BUF
#define PIPE_BUF pathconf(".", _PC_PIPE_BUF)
#else
#define PIPE_BUF 512
#endif
#endif

#ifdef __EMX__
private char *apptypeName = NULL;
protected int file_os2_apptype(struct magic_set *ms, const char *fn,
    const void *buf, size_t nb);
#endif /* __EMX__ */

private void free_mlist(struct mlist *);
private void close_and_restore(const struct magic_set *, const char *, int,
    const struct stat *);
private int info_from_stat(struct magic_set *, mode_t);
#ifndef COMPILE_ONLY
private const char *file_or_fd(struct magic_set *, const char *, int);
#endif

#ifndef	STDIN_FILENO
#define	STDIN_FILENO	0
#endif

public struct magic_set *
magic_open(int flags)
{
	struct magic_set *ms;

	if ((ms = calloc((size_t)1, sizeof(struct magic_set))) == NULL)
		return NULL;

	if (magic_setflags(ms, flags) == -1) {
		errno = EINVAL;
		goto free;
	}

	ms->o.buf = ms->o.pbuf = NULL;

	ms->c.len = 10;
	ms->c.li = reallocarray(NULL, ms->c.len, sizeof(*ms->c.li));
	if (ms->c.li == NULL)
		goto free;
	
	ms->haderr = 0;
	ms->error = -1;
	ms->mlist = NULL;
	ms->file = "unknown";
	ms->line = 0;
	return ms;
free:
	free(ms);
	return NULL;
}

private void
free_mlist(struct mlist *mlist)
{
	struct mlist *ml;

	if (mlist == NULL)
		return;

	for (ml = mlist->next; ml != mlist;) {
		struct mlist *next = ml->next;
		struct magic *mg = ml->magic;
		file_delmagic(mg, ml->mapped, ml->nmagic);
		free(ml);
		ml = next;
	}
	free(ml);
}

private int
info_from_stat(struct magic_set *ms, mode_t md)
{
	/* We cannot open it, but we were able to stat it. */
	if (md & 0222)
		if (file_printf(ms, "writable, ") == -1)
			return -1;
	if (md & 0111)
		if (file_printf(ms, "executable, ") == -1)
			return -1;
	if (S_ISREG(md))
		if (file_printf(ms, "regular file, ") == -1)
			return -1;
	if (file_printf(ms, "no read permission") == -1)
		return -1;
	return 0;
}

public void
magic_close(struct magic_set *ms)
{
	free_mlist(ms->mlist);
	free(ms->o.pbuf);
	free(ms->o.buf);
	free(ms->c.li);
	free(ms);
}

/*
 * load a magic file
 */
public int
magic_load(struct magic_set *ms, const char *magicfile)
{
	struct mlist *ml = file_apprentice(ms, magicfile, FILE_LOAD);
	if (ml) {
		free_mlist(ms->mlist);
		ms->mlist = ml;
		return 0;
	}
	return -1;
}

public int
magic_compile(struct magic_set *ms, const char *magicfile)
{
	struct mlist *ml = file_apprentice(ms, magicfile, FILE_COMPILE);
	free_mlist(ml);
	return ml ? 0 : -1;
}

public int
magic_check(struct magic_set *ms, const char *magicfile)
{
	struct mlist *ml = file_apprentice(ms, magicfile, FILE_CHECK);
	free_mlist(ml);
	return ml ? 0 : -1;
}

private void
close_and_restore(const struct magic_set *ms, const char *name, int fd,
    const struct stat *sb)
{
	if (fd == STDIN_FILENO)
		return;
	(void) close(fd);

	if ((ms->flags & MAGIC_PRESERVE_ATIME) != 0) {
		/*
		 * Try to restore access, modification times if read it.
		 * This is really *bad* because it will modify the status
		 * time of the file... And of course this will affect
		 * backup programs
		 */
#ifdef HAVE_UTIMES
		struct timeval  utsbuf[2];
		(void)memset(utsbuf, 0, sizeof(utsbuf));
		utsbuf[0].tv_sec = sb->st_atime;
		utsbuf[1].tv_sec = sb->st_mtime;

		(void) utimes(name, utsbuf); /* don't care if loses */
#elif defined(HAVE_UTIME_H) || defined(HAVE_SYS_UTIME_H)
		struct utimbuf  utbuf;

		(void)memset(utbuf, 0, sizeof(utbuf));
		utbuf.actime = sb->st_atime;
		utbuf.modtime = sb->st_mtime;
		(void) utime(name, &utbuf); /* don't care if loses */
#endif
	}
}

#ifndef COMPILE_ONLY

/*
 * find type of descriptor
 */
public const char *
magic_descriptor(struct magic_set *ms, int fd)
{
	return file_or_fd(ms, NULL, fd);
}

/*
 * find type of named file
 */
public const char *
magic_file(struct magic_set *ms, const char *inname)
{
	return file_or_fd(ms, inname, STDIN_FILENO);
}

private const char *
file_or_fd(struct magic_set *ms, const char *inname, int fd)
{
	int	rv = -1;
	unsigned char *buf;
	struct stat	sb;
	ssize_t nbytes = 0;	/* number of bytes read from a datafile */
	int	ispipe = 0;

	/*
	 * one extra for terminating '\0', and
	 * some overlapping space for matches near EOF
	 */
#define SLOP (1 + sizeof(union VALUETYPE))
	if ((buf = malloc(HOWMANY + SLOP)) == NULL)
		return NULL;

	if (file_reset(ms) == -1)
		goto done;

	switch (file_fsmagic(ms, inname, &sb)) {
	case -1:		/* error */
		goto done;
	case 0:			/* nothing found */
		break;
	default:		/* matched it and printed type */
		rv = 0;
		goto done;
	}

	if (inname == NULL) {
		if (fstat(fd, &sb) == 0 && S_ISFIFO(sb.st_mode))
			ispipe = 1;
	} else {
		int flags = O_RDONLY|O_BINARY;

		if (stat(inname, &sb) == 0 && S_ISFIFO(sb.st_mode)) {
			flags |= O_NONBLOCK;
			ispipe = 1;
		}

		errno = 0;
		if ((fd = open(inname, flags)) < 0) {
#ifdef __CYGWIN__
			/* FIXME: Do this with EXEEXT from autotools */
			char *tmp = alloca(strlen(inname) + 5);
			(void)strcat(strcpy(tmp, inname), ".exe");
			if ((fd = open(tmp, flags)) < 0) {
#endif
				fprintf(stderr, "couldn't open file\n");
				if (info_from_stat(ms, sb.st_mode) == -1)
					goto done;
				rv = 0;
				goto done;
#ifdef __CYGWIN__
			}
#endif
		}
#ifdef O_NONBLOCK
		if ((flags = fcntl(fd, F_GETFL)) != -1) {
			flags &= ~O_NONBLOCK;
			(void)fcntl(fd, F_SETFL, flags);
		}
#endif
	}

	/*
	 * try looking at the first HOWMANY bytes
	 */
	if (ispipe) {
		ssize_t r = 0;

		while ((r = sread(fd, (void *)&buf[nbytes],
		    (size_t)(HOWMANY - nbytes), 1)) > 0) {
			nbytes += r;
			if (r < PIPE_BUF) break;
		}

		if (nbytes == 0) {
			/* We can not read it, but we were able to stat it. */
			if (info_from_stat(ms, sb.st_mode) == -1)
				goto done;
			rv = 0;
			goto done;
		}

	} else {
		if ((nbytes = read(fd, (char *)buf, HOWMANY)) == -1) {
			file_error(ms, errno, "cannot read `%s'", inname);
			goto done;
		}
	}

	(void)memset(buf + nbytes, 0, SLOP); /* NUL terminate */
	if (file_buffer(ms, fd, inname, buf, (size_t)nbytes) == -1)
		goto done;
	rv = 0;
done:
	free(buf);
	close_and_restore(ms, inname, fd, &sb);
	return rv == 0 ? file_getbuffer(ms) : NULL;
}


public const char *
magic_buffer(struct magic_set *ms, const void *buf, size_t nb)
{
	if (file_reset(ms) == -1)
		return NULL;
	/*
	 * The main work is done here!
	 * We have the file name and/or the data buffer to be identified. 
	 */
	if (file_buffer(ms, -1, NULL, buf, nb) == -1) {
		return NULL;
	}
	return file_getbuffer(ms);
}
#endif

public const char *
magic_error(struct magic_set *ms)
{
	return ms->haderr ? ms->o.buf : NULL;
}

public int
magic_errno(struct magic_set *ms)
{
	return ms->haderr ? ms->error : 0;
}

public int
magic_setflags(struct magic_set *ms, int flags)
{
#if !defined(HAVE_UTIME) && !defined(HAVE_UTIMES)
	if (flags & MAGIC_PRESERVE_ATIME)
		return -1;
#endif
	ms->flags = flags;
	return 0;
}
@


1.10
log
@Replace <sys/param.h> with <limits.h>

This patch is from Theo.  I helped verify that removing <sys/param.h>
doesn't change anything.

This produces the same binaries before and after with clang 3.5 and gcc
4.9.4 on amd64.  There is a slight difference in the way it is generated by
our old gcc 4.2.1 despite the fact that the preprocessed input is almost
identical.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.9 2014/10/11 03:06:44 doug Exp $ */
@


1.9
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.8 2009/10/27 23:59:37 deraadt Exp $ */
a29 1
#include <sys/param.h>	/* for MAXPATHLEN */
@


1.8
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.7 2009/08/27 16:26:43 deraadt Exp $ */
d109 2
a110 1
	ms->c.li = malloc((ms->c.len = 10) * sizeof(*ms->c.li));
@


1.7
log
@Appease gcc2 (I wish people would write in C, rather than "latest crap
gcc added")
ok millert miod
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.6 2009/04/24 18:54:34 chl Exp $ */
a65 4

#ifndef	lint
FILE_RCSID("@@(#)$Id: magic.c,v 1.6 2009/04/24 18:54:34 chl Exp $")
#endif	/* lint */
@


1.6
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.5 2008/05/08 01:40:56 chl Exp $ */
d29 4
a39 3
#include <sys/types.h>
#include <sys/param.h>	/* for MAXPATHLEN */
#include <sys/stat.h>
d68 1
a68 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.5 2008/05/08 01:40:56 chl Exp $")
@


1.5
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.4 2007/09/02 15:19:32 deraadt Exp $ */
d67 1
a67 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.4 2007/09/02 15:19:32 deraadt Exp $")
d70 9
d89 3
d107 1
a107 1
		goto free1;
d110 1
a110 7
	ms->o.ptr = ms->o.buf = malloc(ms->o.left = ms->o.size = 1024);
	if (ms->o.buf == NULL)
		goto free1;

	ms->o.pbuf = malloc(ms->o.psize = 1024);
	if (ms->o.pbuf == NULL)
		goto free2;
d114 1
a114 1
		goto free3;
d122 1
a122 5
free3:
	free(ms->o.pbuf);
free2:
	free(ms->o.buf);
free1:
d221 1
d229 1
d238 10
d254 6
a259 1
	int	fd = 0;
a287 1
		fd = STDIN_FILENO;
d301 4
a304 3
		    char *tmp = alloca(strlen(inname) + 5);
		    (void)strcat(strcpy(tmp, inname), ".exe");
		    if ((fd = open(tmp, flags)) < 0) {
d306 5
a310 4
			if (info_from_stat(ms, sb.st_mode) == -1)
			    goto done;
			rv = 0;
			goto done;
d312 1
a312 1
		    }
d350 3
a352 12
	if (nbytes == 0) {
		if (file_printf(ms, (ms->flags & MAGIC_MIME) ?
		    "application/x-empty" : "empty") == -1)
			goto done;
	} else if (nbytes == 1) {
		if (file_printf(ms, "very short file (no magic)") == -1)
			goto done;
	} else {
		(void)memset(buf + nbytes, 0, SLOP); /* NUL terminate */
		if (file_buffer(ms, fd, inname, buf, (size_t)nbytes) == -1)
			goto done;
	}
@


1.4
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $ */
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
a38 1
#include <fcntl.h>	/* for open() */
d42 1
d44 3
a46 1
#if defined(HAVE_UTIME)
a51 2
#elif defined(HAVE_UTIMES)
# include <sys/time.h>
d67 1
a67 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $")
d79 5
d90 1
a90 1
	if ((ms = malloc(sizeof(struct magic_set))) == NULL)
a93 1
		free(ms);
d95 1
a95 1
		return NULL;
d99 3
a101 4
	if (ms->o.buf == NULL) {
		free(ms);
		return NULL;
	}
d103 7
a109 13
	if (ms->o.pbuf == NULL) {
		free(ms->o.buf);
		free(ms);
		return NULL;
	}
	ms->c.len = 10;
	ms->c.off = calloc(ms->c.len, sizeof(*ms->c.off));
	if (ms->c.off == NULL) {
		free(ms->o.pbuf);
		free(ms->o.buf);
		free(ms);
		return NULL;
	}
d113 2
d116 7
d143 18
d162 1
a162 2
magic_close(ms)
    struct magic_set *ms;
d165 1
d167 1
a167 1
	free(ms->c.off);
d206 2
d209 2
a210 1
	if (fd != STDIN_FILENO && (ms->flags & MAGIC_PRESERVE_ATIME) != 0) {
d233 1
d241 2
a242 1
	unsigned char buf[HOWMANY+1];	/* one extra for terminating '\0' */
d245 9
d256 1
a256 1
		return NULL;
d259 3
a261 3
	case -1:
		return NULL;
	case 0:
d263 3
a265 2
	default:
		return file_getbuffer(ms);
d268 32
a299 2
#ifndef	STDIN_FILENO
#define	STDIN_FILENO	0
a300 16
	if (inname == NULL)
		fd = STDIN_FILENO;
	else if ((fd = open(inname, O_RDONLY)) < 0) {
		/* We cannot open it, but we were able to stat it. */
		if (sb.st_mode & 0222)
			if (file_printf(ms, "writable, ") == -1)
				return NULL;
		if (sb.st_mode & 0111)
			if (file_printf(ms, "executable, ") == -1)
				return NULL;
		if (S_ISREG(sb.st_mode))
			if (file_printf(ms, "regular file, ") == -1)
				return NULL;
		if (file_printf(ms, "no read permission") == -1)
			return NULL;
		return file_getbuffer(ms);
d306 22
a327 3
	if ((nbytes = read(fd, (char *)buf, HOWMANY)) == -1) {
		file_error(ms, errno, "cannot read `%s'", inname);
		goto done;
a333 1
		goto gotit;
a336 1
		goto gotit;
d338 2
a339 12
		buf[nbytes] = '\0';	/* null-terminate it */
#ifdef __EMX__
		switch (file_os2_apptype(ms, inname, buf, nbytes)) {
		case -1:
			goto done;
		case 0:
			break;
		default:
			goto gotit;
		}
#endif
		if (file_buffer(ms, buf, (size_t)nbytes) == -1)
a340 13
#ifdef BUILTIN_ELF
		if (nbytes > 5) {
			/*
			 * We matched something in the file, so this *might*
			 * be an ELF file, and the file is at least 5 bytes
			 * long, so if it's an ELF file it has at least one
			 * byte past the ELF magic number - try extracting
			 * information from the ELF headers that cannot easily
			 * be extracted with rules in the magic file.
			 */
			file_tryelf(ms, fd, buf, (size_t)nbytes);
		}
#endif
d342 1
a342 3
gotit:
	close_and_restore(ms, inname, fd, &sb);
	return file_getbuffer(ms);
d344 1
d346 1
a346 1
	return NULL;
d359 1
a359 1
	if (file_buffer(ms, buf, nb) == -1) {
d364 1
@


1.3
log
@Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.2 2004/05/19 02:36:26 tedu Exp $ */
d69 1
a69 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.2 2004/05/19 02:36:26 tedu Exp $")
d107 2
a108 1
	ms->c.off = malloc((ms->c.len = 10) * sizeof(*ms->c.off));
@


1.2
log
@remove old file, rcsids
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d69 1
a69 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.1 2004/05/19 02:34:27 tedu Exp $")
d96 1
a96 2
	ms->o.ptr = ms->o.buf = malloc(ms->o.size = 1024);
	ms->o.len = 0;
@


1.2.10.1
log
@Backport security fix.
Original commit by: dim@@openbsd.org
Original commit message:
Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $ */
d69 1
a69 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $")
d96 2
a97 1
	ms->o.ptr = ms->o.buf = malloc(ms->o.left = ms->o.size = 1024);
@


1.2.12.1
log
@Backport security fix.
Original commit by: dim@@openbsd.org
Original commit message:
Fix possible heap overflow in file(1), aka CVE-2007-1536.

When writing data into a buffer in the file_printf() function, the
length of the unused portion of the buffer is not correctly tracked,
resulting in a buffer overflow when processing certain files.

Adapted from FreeBSD's SA-07:04.file fix, with ok and some minor
tweaks from canacar@@ and ray@@.
@
text
@d1 1
a1 1
/* $OpenBSD: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $ */
d69 1
a69 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.3 2007/07/09 16:39:48 dim Exp $")
d96 2
a97 1
	ms->o.ptr = ms->o.buf = malloc(ms->o.left = ms->o.size = 1024);
@


1.1
log
@file 4.09
@
text
@d1 1
d69 1
a69 1
FILE_RCSID("@@(#)$Id: magic.c,v 1.20 2004/03/23 15:33:43 christos Exp $")
@

