head	1.18;
access;
symbols
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.17;
commitid	4VUU04TZM8ebPiy4;

1.17
date	2013.04.17.15.01.26;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.17.20.36.21;	author chl;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.19.02.32.36;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.05.13.46.44;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.17.19.42.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	98.07.10.15.05.27;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.02.09.23.58.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/*	$OpenBSD: softmagic.c,v 1.17 2013/04/17 15:01:26 deraadt Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * softmagic - interpret variable magic from MAGIC
 */

#include "file.h"
#include "magic.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>


private int match(struct magic_set *, struct magic *, uint32_t,
    const unsigned char *, size_t, int);
private int mget(struct magic_set *, const unsigned char *,
    struct magic *, size_t, unsigned int);
private int magiccheck(struct magic_set *, struct magic *);
private int32_t mprint(struct magic_set *, struct magic *);
private void mdebug(uint32_t, const char *, size_t);
private int mcopy(struct magic_set *, union VALUETYPE *, int, int,
    const unsigned char *, uint32_t, size_t, size_t);
private int mconvert(struct magic_set *, struct magic *);
private int print_sep(struct magic_set *, int);
private void cvt_8(union VALUETYPE *, const struct magic *);
private void cvt_16(union VALUETYPE *, const struct magic *);
private void cvt_32(union VALUETYPE *, const struct magic *);
private void cvt_64(union VALUETYPE *, const struct magic *);

/*
 * Macro to give description string according to whether we want plain
 * text or MIME type
 */
#define MAGIC_DESC ((ms->flags & MAGIC_MIME) ? m->mimetype : m->desc)

/*
 * softmagic - lookup one file in parsed, in-memory copy of database
 * Passed the name and FILE * of one file to be typed.
 */
/*ARGSUSED1*/		/* nbytes passed for regularity, maybe need later */
protected int
file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes, int mode)
{
	struct mlist *ml;
	int rv;
	for (ml = ms->mlist->next; ml != ms->mlist; ml = ml->next)
		if ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes, mode)) != 0)
			return rv;

	return 0;
}

/*
 * Go through the whole list, stopping if you find a match.  Process all
 * the continuations of that match before returning.
 *
 * We support multi-level continuations:
 *
 *	At any time when processing a successful top-level match, there is a
 *	current continuation level; it represents the level of the last
 *	successfully matched continuation.
 *
 *	Continuations above that level are skipped as, if we see one, it
 *	means that the continuation that controls them - i.e, the
 *	lower-level continuation preceding them - failed to match.
 *
 *	Continuations below that level are processed as, if we see one,
 *	it means we've finished processing or skipping higher-level
 *	continuations under the control of a successful or unsuccessful
 *	lower-level continuation, and are now seeing the next lower-level
 *	continuation and should process it.  The current continuation
 *	level reverts to the level of the one we're seeing.
 *
 *	Continuations at the current level are processed as, if we see
 *	one, there's no lower-level continuation that may have failed.
 *
 *	If a continuation matches, we bump the current continuation level
 *	so that higher-level continuations are processed.
 */
private int
match(struct magic_set *ms, struct magic *magic, uint32_t nmagic,
    const unsigned char *s, size_t nbytes, int mode)
{
	uint32_t magindex = 0;
	unsigned int cont_level = 0;
	int need_separator = 0;
	int returnval = 0; /* if a match is found it is set to 1*/
	int firstline = 1; /* a flag to print X\n  X\n- X */
	int printed_something = 0;

	if (file_check_mem(ms, cont_level) == -1)
		return -1;

	for (magindex = 0; magindex < nmagic; magindex++) {
		int flush;
		struct magic *m = &magic[magindex];

		if ((m->flag & BINTEST) != mode) {
			/* Skip sub-tests */
			while (magic[magindex + 1].cont_level != 0 &&
			       ++magindex < nmagic)
				continue;
			continue; /* Skip to next top-level test*/
		}

		ms->offset = m->offset;
		ms->line = m->lineno;

		/* if main entry matches, print it... */
		flush = !mget(ms, s, m, nbytes, cont_level);
		if (flush) {
			if (m->reln == '!')
				flush = 0;
		} else {	
			switch (magiccheck(ms, m)) {
			case -1:
				return -1;
			case 0:
				flush++;
				break;
			default:
				break;
			}
		}
		if (flush) {
			/* 
			 * main entry didn't match,
			 * flush its continuations
			 */
			while (magindex < nmagic - 1 &&
			    magic[magindex + 1].cont_level != 0)
				magindex++;
			continue;
		}

		/*
		 * If we are going to print something, we'll need to print
		 * a blank before we print something else.
		 */
		if (*MAGIC_DESC) {
			need_separator = 1;
			printed_something = 1;
			if (print_sep(ms, firstline) == -1)
				return -1;
		}

		if ((ms->c.li[cont_level].off = mprint(ms, m)) == -1)
			return -1;

		/* and any continuations that match */
		if (file_check_mem(ms, ++cont_level) == -1)
			return -1;

		while (magic[magindex+1].cont_level != 0 &&
		    ++magindex < nmagic) {
			m = &magic[magindex];
			ms->line = m->lineno; /* for messages */

			if (cont_level < m->cont_level)
				continue;
			if (cont_level > m->cont_level) {
				/*
				 * We're at the end of the level
				 * "cont_level" continuations.
				 */
				cont_level = m->cont_level;
			}
			ms->offset = m->offset;
			if (m->flag & OFFADD) {
				ms->offset +=
				    ms->c.li[cont_level - 1].off;
			}

#ifdef ENABLE_CONDITIONALS
			if (m->cond == COND_ELSE ||
			    m->cond == COND_ELIF) {
				if (ms->c.li[cont_level].last_match == 1)
					continue;
			}
#endif
			flush = !mget(ms, s, m, nbytes, cont_level);
			if (flush && m->reln != '!')
				continue;
				
			switch (flush ? 1 : magiccheck(ms, m)) {
			case -1:
				return -1;
			case 0:
#ifdef ENABLE_CONDITIONALS
				ms->c.li[cont_level].last_match = 0;
#endif
				break;
			default:
#ifdef ENABLE_CONDITIONALS
				ms->c.li[cont_level].last_match = 1;
#endif
				if (m->type != FILE_DEFAULT)
					ms->c.li[cont_level].got_match = 1;
				else if (ms->c.li[cont_level].got_match) {
					ms->c.li[cont_level].got_match = 0;
					break;
				}
				/*
				 * If we are going to print something,
				 * make sure that we have a separator first.
				 */
				if (*MAGIC_DESC) {
					printed_something = 1;
					if (print_sep(ms, firstline) == -1)
						return -1;
				}
				/*
				 * This continuation matched.  Print
				 * its message, with a blank before it
				 * if the previous item printed and
				 * this item isn't empty.
				 */
				/* space if previous printed */
				if (need_separator
				    && ((m->flag & NOSPACE) == 0)
				    && *MAGIC_DESC) {
					if (file_printf(ms, " ") == -1)
						return -1;
					need_separator = 0;
				}
				if ((ms->c.li[cont_level].off = mprint(ms, m)) == -1)
					return -1;
				if (*MAGIC_DESC)
					need_separator = 1;

				/*
				 * If we see any continuations
				 * at a higher level,
				 * process them.
				 */
				if (file_check_mem(ms, ++cont_level) == -1)
					return -1;
				break;
			}
		}
		if (printed_something) {
			firstline = 0;
			returnval = 1;
		}
		if ((ms->flags & MAGIC_CONTINUE) == 0 && printed_something) {
			return 1; /* don't keep searching */
		}			
	}
	return returnval;  /* This is hit if -k is set or there is no match */
}

private int
check_fmt(struct magic_set *ms, struct magic *m)
{
	regex_t rx;
	int rc;

	if (strchr(MAGIC_DESC, '%') == NULL)
		return 0;

	rc = regcomp(&rx, "%[-0-9\\.]*s", REG_EXTENDED|REG_NOSUB);
	if (rc) {
		char errmsg[512];
		(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
		file_magerror(ms, "regex error %d, (%s)", rc, errmsg);
		return -1;
	} else {
		rc = regexec(&rx, MAGIC_DESC, 0, 0, 0);
		regfree(&rx);
		return !rc;
	}
}

#ifndef HAVE_STRNDUP
char * strndup(const char *, size_t);

char *
strndup(const char *str, size_t n)
{
	size_t len;
	char *copy;

	for (len = 0; len < n && str[len]; len++)
		continue;
	if ((copy = malloc(len + 1)) == NULL)
		return NULL;
	(void)memcpy(copy, str, len);
	copy[len] = '\0';
	return copy;
}
#endif /* HAVE_STRNDUP */

private int32_t
mprint(struct magic_set *ms, struct magic *m)
{
	uint64_t v;
	float vf;
	double vd;
	int64_t t = 0;
 	char *buf;
	union VALUETYPE *p = &ms->ms_value;

  	switch (m->type) {
  	case FILE_BYTE:
		v = file_signextend(ms, m, (uint64_t)p->b);
		switch (check_fmt(ms, m)) {
		case -1:
			return -1;
		case 1:
			if (asprintf(&buf, "%c", (unsigned char)v) < 0)
				return -1;
			if (file_printf(ms, MAGIC_DESC, buf) == -1)
				return -1;
			break;
		default:
			if (file_printf(ms, MAGIC_DESC, (unsigned char) v) == -1)
				return -1;
			break;
		}
		t = ms->offset + sizeof(char);
		break;

  	case FILE_SHORT:
  	case FILE_BESHORT:
  	case FILE_LESHORT:
		v = file_signextend(ms, m, (uint64_t)p->h);
		switch (check_fmt(ms, m)) {
		case -1:
			return -1;
		case 1:
			if (asprintf(&buf, "%hu", (unsigned short)v) < 0)
				return -1;
			if (file_printf(ms, MAGIC_DESC, buf) == -1)
				return -1;
			break;
		default:
			if (file_printf(ms, MAGIC_DESC, (unsigned short) v) == -1)
				return -1;
			break;
		}
		t = ms->offset + sizeof(short);
		break;

  	case FILE_LONG:
  	case FILE_BELONG:
  	case FILE_LELONG:
  	case FILE_MELONG:
		v = file_signextend(ms, m, (uint64_t)p->l);
		switch (check_fmt(ms, m)) {
		case -1:
			return -1;
		case 1:
			if (asprintf(&buf, "%u", (uint32_t)v) < 0)
				return -1;
			if (file_printf(ms, MAGIC_DESC, buf) == -1)
				return -1;
			break;
		default:
			if (file_printf(ms, MAGIC_DESC, (uint32_t) v) == -1)
				return -1;
			break;
		}
		t = ms->offset + sizeof(int32_t);
  		break;

  	case FILE_QUAD:
  	case FILE_BEQUAD:
  	case FILE_LEQUAD:
		v = file_signextend(ms, m, p->q);
		if (file_printf(ms, MAGIC_DESC, (uint64_t) v) == -1)
			return -1;
		t = ms->offset + sizeof(int64_t);
  		break;

  	case FILE_STRING:
  	case FILE_PSTRING:
  	case FILE_BESTRING16:
  	case FILE_LESTRING16:
		if (m->reln == '=' || m->reln == '!') {
			if (file_printf(ms, MAGIC_DESC, m->value.s) == -1)
				return -1;
			t = ms->offset + m->vallen;
		}
		else {
			if (*m->value.s == '\0')
				p->s[strcspn(p->s, "\n")] = '\0';
			if (file_printf(ms, MAGIC_DESC, p->s) == -1)
				return -1;
			t = ms->offset + strlen(p->s);
			if (m->type == FILE_PSTRING)
				t++;
		}
		break;

	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_MEDATE:
		if (file_printf(ms, MAGIC_DESC, file_fmttime(p->l, 1)) == -1)
			return -1;
		t = ms->offset + sizeof(int32_t);
		break;

	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
	case FILE_MELDATE:
		if (file_printf(ms, MAGIC_DESC, file_fmttime(p->l, 0)) == -1)
			return -1;
		t = ms->offset + sizeof(int32_t);
		break;

	case FILE_QDATE:
	case FILE_BEQDATE:
	case FILE_LEQDATE:
		if (file_printf(ms, MAGIC_DESC, file_fmttime(p->q, 1))
		    == -1)
			return -1;
		t = ms->offset + sizeof(uint64_t);
		break;

	case FILE_QLDATE:
	case FILE_BEQLDATE:
	case FILE_LEQLDATE:
		if (file_printf(ms, MAGIC_DESC, file_fmttime(p->q, 0))
		    == -1)
			return -1;
		t = ms->offset + sizeof(uint64_t);
		break;

  	case FILE_FLOAT:
  	case FILE_BEFLOAT:
  	case FILE_LEFLOAT:
		vf = p->f;
		switch (check_fmt(ms, m)) {
		case -1:
			return -1;
		case 1:
			if (asprintf(&buf, "%g", vf) < 0)
				return -1;
			if (file_printf(ms, MAGIC_DESC, buf) == -1)
				return -1;
			break;
		default:
			if (file_printf(ms, MAGIC_DESC, vf) == -1)
				return -1;
			break;
		}
		t = ms->offset + sizeof(float);
  		break;

  	case FILE_DOUBLE:
  	case FILE_BEDOUBLE:
  	case FILE_LEDOUBLE:
		vd = p->d;
		switch (check_fmt(ms, m)) {
		case -1:
			return -1;
		case 1:
			if (asprintf(&buf, "%g", vd) < 0)
				return -1;
			if (file_printf(ms, MAGIC_DESC, buf) == -1)
				return -1;
			break;
		default:
			if (file_printf(ms, MAGIC_DESC, vd) == -1)
				return -1;
			break;
		}
		t = ms->offset + sizeof(double);
  		break;

	case FILE_REGEX: {
		char *cp;
		int rval;

		cp = strndup((const char *)ms->search.s, ms->search.rm_len);
		if (cp == NULL) {
			file_oomem(ms, ms->search.rm_len);
			return -1;
		}
		rval = file_printf(ms, MAGIC_DESC, cp);
		free(cp);

		if (rval == -1)
			return -1;

		if ((m->str_flags & REGEX_OFFSET_START))
			t = ms->search.offset;
		else
			t = ms->search.offset + ms->search.rm_len;
		break;
	}

	case FILE_SEARCH:
	  	if (file_printf(ms, MAGIC_DESC, m->value.s) == -1)
			return -1;
		if ((m->str_flags & REGEX_OFFSET_START))
			t = ms->search.offset;
		else
			t = ms->search.offset + m->vallen;
		break;

	case FILE_DEFAULT:
	  	if (file_printf(ms, MAGIC_DESC, m->value.s) == -1)
			return -1;
		t = ms->offset;
		break;

	default:
		file_magerror(ms, "invalid m->type (%d) in mprint()", m->type);
		return -1;
	}
	return(t);
}


#define DO_CVT(fld, cast) \
	if (m->num_mask) \
		switch (m->mask_op & FILE_OPS_MASK) { \
		case FILE_OPAND: \
			p->fld &= cast m->num_mask; \
			break; \
		case FILE_OPOR: \
			p->fld |= cast m->num_mask; \
			break; \
		case FILE_OPXOR: \
			p->fld ^= cast m->num_mask; \
			break; \
		case FILE_OPADD: \
			p->fld += cast m->num_mask; \
			break; \
		case FILE_OPMINUS: \
			p->fld -= cast m->num_mask; \
			break; \
		case FILE_OPMULTIPLY: \
			p->fld *= cast m->num_mask; \
			break; \
		case FILE_OPDIVIDE: \
			p->fld /= cast m->num_mask; \
			break; \
		case FILE_OPMODULO: \
			p->fld %= cast m->num_mask; \
			break; \
		} \
	if (m->mask_op & FILE_OPINVERSE) \
		p->fld = ~p->fld \

private void
cvt_8(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT(b, (uint8_t));
}

private void
cvt_16(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT(h, (uint16_t));
}

private void
cvt_32(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT(l, (uint32_t));
}

private void
cvt_64(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT(q, (uint64_t));
}

#define DO_CVT2(fld, cast) \
	if (m->num_mask) \
		switch (m->mask_op & FILE_OPS_MASK) { \
		case FILE_OPADD: \
			p->fld += cast m->num_mask; \
			break; \
		case FILE_OPMINUS: \
			p->fld -= cast m->num_mask; \
			break; \
		case FILE_OPMULTIPLY: \
			p->fld *= cast m->num_mask; \
			break; \
		case FILE_OPDIVIDE: \
			p->fld /= cast m->num_mask; \
			break; \
		} \

private void
cvt_float(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT2(f, (float));
}

private void
cvt_double(union VALUETYPE *p, const struct magic *m)
{
	DO_CVT2(d, (double));
}

/*
 * Convert the byte order of the data we are looking at
 * While we're here, let's apply the mask operation
 * (unless you have a better idea)
 */
private int
mconvert(struct magic_set *ms, struct magic *m)
{
	union VALUETYPE *p = &ms->ms_value;

	switch (m->type) {
	case FILE_BYTE:
		cvt_8(p, m);
		return 1;
	case FILE_SHORT:
		cvt_16(p, m);
		return 1;
	case FILE_LONG:
	case FILE_DATE:
	case FILE_LDATE:
		cvt_32(p, m);
		return 1;
	case FILE_QUAD:
	case FILE_QDATE:
	case FILE_QLDATE:
		cvt_64(p, m);
		return 1;
	case FILE_STRING:
	case FILE_BESTRING16:
	case FILE_LESTRING16: {
		size_t len;
		
		/* Null terminate and eat *trailing* return */
		p->s[sizeof(p->s) - 1] = '\0';
		len = strlen(p->s);
		if (len-- && p->s[len] == '\n')
			p->s[len] = '\0';
		return 1;
	}
	case FILE_PSTRING: {
		char *ptr1 = p->s, *ptr2 = ptr1 + 1;
		size_t len = *p->s;
		if (len >= sizeof(p->s))
			len = sizeof(p->s) - 1;
		while (len--)
			*ptr1++ = *ptr2++;
		*ptr1 = '\0';
		len = strlen(p->s);
		if (len-- && p->s[len] == '\n')
			p->s[len] = '\0';
		return 1;
	}
	case FILE_BESHORT:
		p->h = (short)((p->hs[0]<<8)|(p->hs[1]));
		cvt_16(p, m);
		return 1;
	case FILE_BELONG:
	case FILE_BEDATE:
	case FILE_BELDATE:
		p->l = (int32_t)
		    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));
		cvt_32(p, m);
		return 1;
	case FILE_BEQUAD:
	case FILE_BEQDATE:
	case FILE_BEQLDATE:
		p->q = (uint64_t)
		    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
		     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
		     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
		     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));
		cvt_64(p, m);
		return 1;
	case FILE_LESHORT:
		p->h = (short)((p->hs[1]<<8)|(p->hs[0]));
		cvt_16(p, m);
		return 1;
	case FILE_LELONG:
	case FILE_LEDATE:
	case FILE_LELDATE:
		p->l = (int32_t)
		    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));
		cvt_32(p, m);
		return 1;
	case FILE_LEQUAD:
	case FILE_LEQDATE:
	case FILE_LEQLDATE:
		p->q = (uint64_t)
		    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
		     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
		     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
		     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));
		cvt_64(p, m);
		return 1;
	case FILE_MELONG:
	case FILE_MEDATE:
	case FILE_MELDATE:
		p->l = (int32_t)
		    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));
		cvt_32(p, m);
		return 1;
	case FILE_FLOAT:
		cvt_float(p, m);
		return 1;
	case FILE_BEFLOAT:
		p->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|
			((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);
		cvt_float(p, m);
		return 1;
	case FILE_LEFLOAT:
		p->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|
			((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);
		cvt_float(p, m);
		return 1;
	case FILE_DOUBLE:
		cvt_double(p, m);
		return 1;
	case FILE_BEDOUBLE:
		p->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
			((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
			((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
			((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);
		cvt_double(p, m);
		return 1;
	case FILE_LEDOUBLE:
		p->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
			((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
			((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
			((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);
		cvt_double(p, m);
		return 1;
	case FILE_REGEX:
	case FILE_SEARCH:
	case FILE_DEFAULT:
		return 1;
	default:
		file_magerror(ms, "invalid type %d in mconvert()", m->type);
		return 0;
	}
}


private void
mdebug(uint32_t offset, const char *str, size_t len)
{
	(void) fprintf(stderr, "mget @@%d: ", offset);
	file_showstr(stderr, str, len);
	(void) fputc('\n', stderr);
	(void) fputc('\n', stderr);
}

private int
mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,
    const unsigned char *s, uint32_t offset, size_t nbytes, size_t linecnt)
{
	/*
	 * Note: FILE_SEARCH and FILE_REGEX do not actually copy
	 * anything, but setup pointers into the source
	 */
	if (indir == 0) {
		switch (type) {
		case FILE_SEARCH:
			ms->search.s = (const char *)s + offset;
			ms->search.s_len = nbytes - offset;
			ms->search.offset = offset;
			return 0;

		case FILE_REGEX: {
			const char *b;
			const char *c;
			const char *last;	/* end of search region */
			const char *buf;	/* start of search region */
			size_t lines;

			if (s == NULL) {
				ms->search.s_len = 0;
				ms->search.s = NULL;
				return 0;
			}
			buf = (const char *)s + offset;
			last = (const char *)s + nbytes;
			/* mget() guarantees buf <= last */
			for (lines = linecnt, b = buf;
			     lines && ((b = strchr(c = b, '\n')) || (b = strchr(c, '\r')));
			     lines--, b++) {
				last = b;
				if (b[0] == '\r' && b[1] == '\n')
					b++;
			}
			if (lines)
				last = (const char *)s + nbytes;
			
			ms->search.s = buf;
			ms->search.s_len = last - buf;
			ms->search.offset = offset;
			ms->search.rm_len = 0;
			return 0;
		}
		case FILE_BESTRING16:
		case FILE_LESTRING16: {
			const unsigned char *src = s + offset;
			const unsigned char *esrc = s + nbytes;
			char *dst = p->s;
			char *edst = &p->s[sizeof(p->s) - 1];
			
			if (type == FILE_BESTRING16)
				src++;
			
			/* check for pointer overflow */
			if (src < s) {
				file_magerror(ms, "invalid offset %zu in mcopy()",
				    offset);
				return -1;
			}
			for (/*EMPTY*/; src < esrc; src += 2, dst++) {
				if (dst < edst)
					*dst = *src;
				else
					break;
				if (*dst == '\0') {
					if (type == FILE_BESTRING16 ?
					    *(src - 1) != '\0' :
					    *(src + 1) != '\0')
						*dst = ' ';
				}
			}
			*edst = '\0';
			return 0;
		}
		case FILE_STRING:	/* XXX - these two should not need */
		case FILE_PSTRING:	/* to copy anything, but do anyway. */
		default:
			break;
		}
	}

	if (offset >= nbytes) {
		(void)memset(p, '\0', sizeof(*p));
		return 0;
	}
	if (nbytes - offset < sizeof(*p))
		nbytes = nbytes - offset;
	else
		nbytes = sizeof(*p);

	(void)memcpy(p, s + offset, nbytes);

	/*
	 * the usefulness of padding with zeroes eludes me, it
	 * might even cause problems
	 */
	if (nbytes < sizeof(*p))
		(void)memset(((char *)(void *)p) + nbytes, '\0',
		    sizeof(*p) - nbytes);
	return 0;
}

private int
mget(struct magic_set *ms, const unsigned char *s,
    struct magic *m, size_t nbytes, unsigned int cont_level)
{
	uint32_t offset = ms->offset;
	uint32_t count = m->str_range;
	union VALUETYPE *p = &ms->ms_value;

	if (mcopy(ms, p, m->type, m->flag & INDIR, s, offset, nbytes, count) == -1)
		return -1;

	if ((ms->flags & MAGIC_DEBUG) != 0) {
		mdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));
		file_mdump(m);
	}

	if (m->flag & INDIR) {
		int off = m->in_offset;
		if (m->in_op & FILE_OPINDIRECT) {
			const union VALUETYPE *q =
			    ((const void *)(s + offset + off));
			switch (m->in_type) {
			case FILE_BYTE:
				off = q->b;
				break;
			case FILE_SHORT:
				off = q->h;
				break;
			case FILE_BESHORT:
				off = (short)((q->hs[0]<<8)|(q->hs[1]));
				break;
			case FILE_LESHORT:
				off = (short)((q->hs[1]<<8)|(q->hs[0]));
				break;
			case FILE_LONG:
				off = q->l;
				break;
			case FILE_BELONG:
				off = (int32_t)((q->hl[0]<<24)|(q->hl[1]<<16)|
						 (q->hl[2]<<8)|(q->hl[3]));
				break;
			case FILE_LELONG:
				off = (int32_t)((q->hl[3]<<24)|(q->hl[2]<<16)|
						 (q->hl[1]<<8)|(q->hl[0]));
				break;
			case FILE_MELONG:
				off = (int32_t)((q->hl[1]<<24)|(q->hl[0]<<16)|
						 (q->hl[3]<<8)|(q->hl[2]));
				break;
			}
		}
		switch (m->in_type) {
		case FILE_BYTE:
			if (nbytes < (offset + 1))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = p->b & off;
					break;
				case FILE_OPOR:
					offset = p->b | off;
					break;
				case FILE_OPXOR:
					offset = p->b ^ off;
					break;
				case FILE_OPADD:
					offset = p->b + off;
					break;
				case FILE_OPMINUS:
					offset = p->b - off;
					break;
				case FILE_OPMULTIPLY:
					offset = p->b * off;
					break;
				case FILE_OPDIVIDE:
					offset = p->b / off;
					break;
				case FILE_OPMODULO:
					offset = p->b % off;
					break;
				}
			} else
				offset = p->b;
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BESHORT:
			if (nbytes < (offset + 2))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) &
						 off;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) |
						 off;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) ^
						 off;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) +
						 off;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) -
						 off;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) *
						 off;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) /
						 off;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[0]<<8)|
							 (p->hs[1])) %
						 off;
					break;
				}
			} else
				offset = (short)((p->hs[0]<<8)|
						 (p->hs[1]));
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LESHORT:
			if (nbytes < (offset + 2))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) &
						 off;
					break;
				case FILE_OPOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) |
						 off;
					break;
				case FILE_OPXOR:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) ^
						 off;
					break;
				case FILE_OPADD:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) +
						 off;
					break;
				case FILE_OPMINUS:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) -
						 off;
					break;
				case FILE_OPMULTIPLY:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) *
						 off;
					break;
				case FILE_OPDIVIDE:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) /
						 off;
					break;
				case FILE_OPMODULO:
					offset = (short)((p->hs[1]<<8)|
							 (p->hs[0])) %
						 off;
					break;
				}
			} else
				offset = (short)((p->hs[1]<<8)|
						 (p->hs[0]));
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_SHORT:
			if (nbytes < (offset + 2))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = p->h & off;
					break;
				case FILE_OPOR:
					offset = p->h | off;
					break;
				case FILE_OPXOR:
					offset = p->h ^ off;
					break;
				case FILE_OPADD:
					offset = p->h + off;
					break;
				case FILE_OPMINUS:
					offset = p->h - off;
					break;
				case FILE_OPMULTIPLY:
					offset = p->h * off;
					break;
				case FILE_OPDIVIDE:
					offset = p->h / off;
					break;
				case FILE_OPMODULO:
					offset = p->h % off;
					break;
				}
			}
			else
				offset = p->h;
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_BELONG:
			if (nbytes < (offset + 4))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) &
						 off;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) |
						 off;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) ^
						 off;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) +
						 off;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) -
						 off;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) *
						 off;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) /
						 off;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[0]<<24)|
							 (p->hl[1]<<16)|
							 (p->hl[2]<<8)|
							 (p->hl[3])) %
						 off;
					break;
				}
			} else
				offset = (int32_t)((p->hl[0]<<24)|
						 (p->hl[1]<<16)|
						 (p->hl[2]<<8)|
						 (p->hl[3]));
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LELONG:
			if (nbytes < (offset + 4))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) &
						 off;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) |
						 off;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) ^
						 off;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) +
						 off;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) -
						 off;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) *
						 off;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) /
						 off;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[3]<<24)|
							 (p->hl[2]<<16)|
							 (p->hl[1]<<8)|
							 (p->hl[0])) %
						 off;
					break;
				}
			} else
				offset = (int32_t)((p->hl[3]<<24)|
						 (p->hl[2]<<16)|
						 (p->hl[1]<<8)|
						 (p->hl[0]));
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_MELONG:
			if (nbytes < (offset + 4))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) &
						 off;
					break;
				case FILE_OPOR:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) |
						 off;
					break;
				case FILE_OPXOR:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) ^
						 off;
					break;
				case FILE_OPADD:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) +
						 off;
					break;
				case FILE_OPMINUS:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) -
						 off;
					break;
				case FILE_OPMULTIPLY:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) *
						 off;
					break;
				case FILE_OPDIVIDE:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) /
						 off;
					break;
				case FILE_OPMODULO:
					offset = (int32_t)((p->hl[1]<<24)|
							 (p->hl[0]<<16)|
							 (p->hl[3]<<8)|
							 (p->hl[2])) %
						 off;
					break;
				}
			} else
				offset = (int32_t)((p->hl[1]<<24)|
						 (p->hl[0]<<16)|
						 (p->hl[3]<<8)|
						 (p->hl[2]));
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		case FILE_LONG:
			if (nbytes < (offset + 4))
				return 0;
			if (off) {
				switch (m->in_op & FILE_OPS_MASK) {
				case FILE_OPAND:
					offset = p->l & off;
					break;
				case FILE_OPOR:
					offset = p->l | off;
					break;
				case FILE_OPXOR:
					offset = p->l ^ off;
					break;
				case FILE_OPADD:
					offset = p->l + off;
					break;
				case FILE_OPMINUS:
					offset = p->l - off;
					break;
				case FILE_OPMULTIPLY:
					offset = p->l * off;
					break;
				case FILE_OPDIVIDE:
					offset = p->l / off;
					break;
				case FILE_OPMODULO:
					offset = p->l % off;
					break;
				}
			} else
				offset = p->l;
			if (m->in_op & FILE_OPINVERSE)
				offset = ~offset;
			break;
		}

		if (m->flag & INDIROFFADD)
			offset += ms->c.li[cont_level-1].off;
		if (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)
			return -1;
		ms->offset = offset;

		if ((ms->flags & MAGIC_DEBUG) != 0) {
			mdebug(offset, (char *)(void *)p,
			    sizeof(union VALUETYPE));
			file_mdump(m);
		}
	}

	/* Verify we have enough data to match magic type */
	switch (m->type) {
	case FILE_BYTE:
		if (nbytes < (offset + 1)) /* should alway be true */
			return 0;
		break;
		
	case FILE_SHORT:
	case FILE_BESHORT:
	case FILE_LESHORT:
		if (nbytes < (offset + 2))
			return 0;
		break;
		
	case FILE_LONG:
	case FILE_BELONG:
	case FILE_LELONG:
	case FILE_MELONG:
	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_MEDATE:
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
	case FILE_MELDATE:
	case FILE_FLOAT:
	case FILE_BEFLOAT:
	case FILE_LEFLOAT:
		if (nbytes < (offset + 4))
			return 0;
		break;
		
	case FILE_DOUBLE:
	case FILE_BEDOUBLE:
	case FILE_LEDOUBLE:
		if (nbytes < (offset + 8))
			return 0;
		break;

	case FILE_STRING:
	case FILE_PSTRING:
	case FILE_SEARCH:
		if (nbytes < (offset + m->vallen))
			return 0;
		break;

	case FILE_REGEX:
		if (nbytes < offset)
			return 0;
		break;

	case FILE_DEFAULT:	/* nothing to check */
	default:
		break;
	}
	if (!mconvert(ms, m))
		return 0;
	return 1;
}

private uint64_t
file_strncmp(const char *s1, const char *s2, size_t len, uint32_t flags)
{
	/*
	 * Convert the source args to unsigned here so that (1) the
	 * compare will be unsigned as it is in strncmp() and (2) so
	 * the ctype functions will work correctly without extra
	 * casting.
	 */
	const unsigned char *a = (const unsigned char *)s1;
	const unsigned char *b = (const unsigned char *)s2;
	uint64_t v;

	/*
	 * What we want here is v = strncmp(s1, s2, len),
	 * but ignoring any nulls.
	 */
	v = 0;
	if (0L == flags) { /* normal string: do it fast */
		while (len-- > 0)
			if ((v = *b++ - *a++) != '\0')
				break; 
	}
	else { /* combine the others */
		while (len-- > 0) {
			if ((flags & STRING_IGNORE_LOWERCASE) &&
			    islower(*a)) {
				if ((v = tolower(*b++) - *a++) != '\0')
					break;
			}
			else if ((flags & STRING_IGNORE_UPPERCASE) &&
			    isupper(*a)) {
				if ((v = toupper(*b++) - *a++) != '\0')
					break;
			}
			else if ((flags & STRING_COMPACT_BLANK) && 
			    isspace(*a)) { 
				a++;
				if (isspace(*b++)) {
					while (isspace(*b))
						b++;
				}
				else {
					v = 1;
					break;
				}
			}
			else if ((flags & STRING_COMPACT_OPTIONAL_BLANK) &&
			    isspace(*a)) {
				a++;
				while (isspace(*b))
					b++;
			}
			else {
				if ((v = *b++ - *a++) != '\0')
					break;
			}
		}
	}
	return v;
}

private uint64_t
file_strncmp16(const char *a, const char *b, size_t len, uint32_t flags)
{
	/*
	 * XXX - The 16-bit string compare probably needs to be done
	 * differently, especially if the flags are to be supported.
	 * At the moment, I am unsure.
	 */
	flags = 0;
	return file_strncmp(a, b, len, flags);
}

private int
magiccheck(struct magic_set *ms, struct magic *m)
{
	uint64_t l = m->value.q;
	uint64_t v;
	float fl, fv;
	double dl, dv;
	int matched;
	union VALUETYPE *p = &ms->ms_value;

	switch (m->type) {
	case FILE_BYTE:
		v = p->b;
		break;

	case FILE_SHORT:
	case FILE_BESHORT:
	case FILE_LESHORT:
		v = p->h;
		break;

	case FILE_LONG:
	case FILE_BELONG:
	case FILE_LELONG:
	case FILE_MELONG:
	case FILE_DATE:
	case FILE_BEDATE:
	case FILE_LEDATE:
	case FILE_MEDATE:
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
	case FILE_MELDATE:
		v = p->l;
		break;

	case FILE_QUAD:
	case FILE_LEQUAD:
	case FILE_BEQUAD:
	case FILE_QDATE:
	case FILE_BEQDATE:
	case FILE_LEQDATE:
	case FILE_QLDATE:
	case FILE_BEQLDATE:
	case FILE_LEQLDATE:
		v = p->q;
		break;

	case FILE_FLOAT:
	case FILE_BEFLOAT:
	case FILE_LEFLOAT:
		fl = m->value.f;
		fv = p->f;
		switch (m->reln) {
		case 'x':
			matched = 1;
			break;
	
		case '!':
			matched = fv != fl;
			break;
	
		case '=':
			matched = fv == fl;
			break;
	
		case '>':
			matched = fv > fl;
			break;
	
		case '<':
			matched = fv < fl;
			break;
	
		default:
			matched = 0;
			file_magerror(ms, "cannot happen with float: invalid relation `%c'", m->reln);
			return -1;
		}
		return matched;

	case FILE_DOUBLE:
	case FILE_BEDOUBLE:
	case FILE_LEDOUBLE:
		dl = m->value.d;
		dv = p->d;
		switch (m->reln) {
		case 'x':
			matched = 1;
			break;
	
		case '!':
			matched = dv != dl;
			break;
	
		case '=':
			matched = dv == dl;
			break;
	
		case '>':
			matched = dv > dl;
			break;
	
		case '<':
			matched = dv < dl;
			break;
	
		default:
			matched = 0;
			file_magerror(ms, "cannot happen with double: invalid relation `%c'", m->reln);
			return -1;
		}
		return matched;

	case FILE_DEFAULT:
		l = 0;
		v = 0;
		break;

	case FILE_STRING:
	case FILE_PSTRING:
		l = 0;
		v = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);
		break;

	case FILE_BESTRING16:
	case FILE_LESTRING16:
		l = 0;
		v = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);
		break;

	case FILE_SEARCH: { /* search ms->search.s for the string m->value.s */
		size_t slen;
		size_t idx;

		if (ms->search.s == NULL)
			return 0;

		slen = MIN(m->vallen, sizeof(m->value.s));
		l = 0;
		v = 0;

		for (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {
			if (slen + idx > ms->search.s_len)
				break;

			v = file_strncmp(m->value.s, ms->search.s + idx, slen, m->str_flags);
			if (v == 0) {	/* found match */
				ms->search.offset += idx;
				break;
			}
		}
		break;
	}
	case FILE_REGEX: {
		int rc;
		regex_t rx;
		char errmsg[512];

		if (ms->search.s == NULL)
			return 0;

		l = 0;
		rc = regcomp(&rx, m->value.s,
		    REG_EXTENDED|REG_NEWLINE|
		    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));
		if (rc) {
			(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
			file_magerror(ms, "regex error %d, (%s)",
			    rc, errmsg);
			v = (uint64_t)-1;
		}
		else {
			regmatch_t pmatch[1];
#ifndef REG_STARTEND
#define	REG_STARTEND	0
			size_t l = ms->search.s_len - 1;
			char c = ms->search.s[l];
			((char *)(intptr_t)ms->search.s)[l] = '\0';
#else
			pmatch[0].rm_so = 0;
			pmatch[0].rm_eo = ms->search.s_len;
#endif
			rc = regexec(&rx, (const char *)ms->search.s,
			    1, pmatch, REG_STARTEND);
#if REG_STARTEND == 0
			((char *)(intptr_t)ms->search.s)[l] = c;
#endif
			switch (rc) {
			case 0:
				ms->search.s += (int)pmatch[0].rm_so;
				ms->search.offset += (size_t)pmatch[0].rm_so;
				ms->search.rm_len =
				    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);
				v = 0;
				break;

			case REG_NOMATCH:
				v = 1;
				break;

			default:
				(void)regerror(rc, &rx, errmsg, sizeof(errmsg));
				file_magerror(ms, "regexec error %d, (%s)",
				    rc, errmsg);
				v = (uint64_t)-1;
				break;
			}
			regfree(&rx);
		}
		if (v == (uint64_t)-1)
			return -1;
		break;
	}
	default:
		file_magerror(ms, "invalid type %d in magiccheck()", m->type);
		return -1;
	}

	v = file_signextend(ms, m, v);

	switch (m->reln) {
	case 'x':
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%llu == *any* = 1\n",
			    (unsigned long long)v);
		matched = 1;
		break;

	case '!':
		matched = v != l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%llu != %llu = %d\n",
			    (unsigned long long)v, (unsigned long long)l,
			    matched);
		break;

	case '=':
		matched = v == l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "%llu == %llu = %d\n",
			    (unsigned long long)v, (unsigned long long)l,
			    matched);
		break;

	case '>':
		if (m->flag & UNSIGNED) {
			matched = v > l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%llu > %llu = %d\n",
				    (unsigned long long)v,
				    (unsigned long long)l, matched);
		}
		else {
			matched = (int64_t) v > (int64_t) l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%lld > %lld = %d\n",
				    (long long)v, (long long)l, matched);
		}
		break;

	case '<':
		if (m->flag & UNSIGNED) {
			matched = v < l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%llu < %llu = %d\n",
				    (unsigned long long)v,
				    (unsigned long long)l, matched);
		}
		else {
			matched = (int64_t) v < (int64_t) l;
			if ((ms->flags & MAGIC_DEBUG) != 0)
				(void) fprintf(stderr, "%lld < %lld = %d\n",
				       (long long)v, (long long)l, matched);
		}
		break;

	case '&':
		matched = (v & l) == l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "((%llx & %llx) == %llx) = %d\n",
			    (unsigned long long)v, (unsigned long long)l,
			    (unsigned long long)l, matched);
		break;

	case '^':
		matched = (v & l) != l;
		if ((ms->flags & MAGIC_DEBUG) != 0)
			(void) fprintf(stderr, "((%llx & %llx) != %llx) = %d\n",
			    (unsigned long long)v, (unsigned long long)l,
			    (unsigned long long)l, matched);
		break;

	default:
		matched = 0;
		file_magerror(ms, "cannot happen: invalid relation `%c'",
		    m->reln);
		return -1;
	}

	return matched;
}

private int
print_sep(struct magic_set *ms, int firstline)
{
	if (firstline)
		return 0;
	/*
	 * we found another match 
	 * put a newline and '-' to do some simple formatting
	 */
	return file_printf(ms, "\n- ");
}
@


1.17
log
@variety of fixes to correct large time_t code.  it is quite broken upstream.
ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.16 2010/01/17 20:36:21 chl Exp $ */
@


1.16
log
@Backport bug fix from upstream.

Bug found by sthen@@

ok sthen@@ ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.15 2009/10/27 23:59:38 deraadt Exp $ */
d428 1
a428 1
		t = ms->offset + sizeof(time_t);
d437 1
a437 1
		t = ms->offset + sizeof(time_t);
d443 1
a443 1
		if (file_printf(ms, MAGIC_DESC, file_fmttime((uint32_t)p->q, 1))
d452 1
a452 1
		if (file_printf(ms, MAGIC_DESC, file_fmttime((uint32_t)p->q, 0))
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.14 2009/04/24 18:54:34 chl Exp $ */
d310 5
a314 6
	len = strlen(str);
	if (len > n)
		len = n;
	if (!(copy = malloc(len + 1)))
		return (NULL);
	(void) memcpy(copy, str, len + 1);
d316 1
a316 1
	return (copy);
@


1.14
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.13 2008/05/08 01:40:56 chl Exp $ */
a39 4

#ifndef	lint
FILE_RCSID("@@(#)$Id: softmagic.c,v 1.13 2008/05/08 01:40:56 chl Exp $")
#endif	/* lint */
@


1.13
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.12 2007/09/11 15:47:17 gilles Exp $ */
d42 1
a42 1
FILE_RCSID("@@(#)$Id: softmagic.c,v 1.12 2007/09/11 15:47:17 gilles Exp $")
d46 1
a46 1
    const unsigned char *, size_t);
d62 6
d73 1
a73 1
file_softmagic(struct magic_set *ms, const unsigned char *buf, size_t nbytes)
d78 1
a78 1
		if ((rv = match(ms, ml->magic, ml->nmagic, buf, nbytes)) != 0)
d113 1
a113 1
    const unsigned char *s, size_t nbytes)
d127 9
d137 2
a138 2
		ms->offset = magic[magindex].offset;
		ms->line = magic[magindex].lineno;
d141 1
a141 1
		flush = !mget(ms, s, &magic[magindex], nbytes, cont_level);
d143 1
a143 1
			if (magic[magindex].reln == '!')
d146 1
a146 1
			switch (magiccheck(ms, &magic[magindex])) {
d171 1
a171 1
		if (magic[magindex].desc[0]) {
d178 1
a178 2
		if ((ms->c.li[cont_level].off = mprint(ms, &magic[magindex]))
		    == -1)
d187 2
a188 1
			ms->line = magic[magindex].lineno; /* for messages */
d190 1
a190 1
			if (cont_level < magic[magindex].cont_level)
d192 1
a192 1
			if (cont_level > magic[magindex].cont_level) {
d197 1
a197 1
				cont_level = magic[magindex].cont_level;
d199 2
a200 2
			ms->offset = magic[magindex].offset;
			if (magic[magindex].flag & OFFADD) {
d206 2
a207 2
			if (magic[magindex].cond == COND_ELSE ||
			    magic[magindex].cond == COND_ELIF) {
d212 2
a213 3
			flush = !mget(ms, s, &magic[magindex], nbytes,
			    cont_level);
			if (flush && magic[magindex].reln != '!')
d216 1
a216 1
			switch (flush ? 1 : magiccheck(ms, &magic[magindex])) {
d228 1
a228 1
				if (magic[magindex].type != FILE_DEFAULT)
d238 1
a238 1
				if (magic[magindex].desc[0]) {
d251 2
a252 2
				    && (magic[magindex].nospflag == 0)
				    && (magic[magindex].desc[0] != '\0')) {
d257 1
a257 1
				if ((ms->c.li[cont_level].off = mprint(ms, &magic[magindex])) == -1)
d259 1
a259 1
				if (magic[magindex].desc[0])
d272 2
a273 2
		firstline = 0;
		if (printed_something)
d275 1
d289 1
a289 1
	if (strchr(m->desc, '%') == NULL)
d299 1
a299 1
		rc = regexec(&rx, m->desc, 0, 0, 0);
d329 2
d332 1
a332 1
 	char buf[512];
d342 1
a342 2
			if (snprintf(buf, sizeof(buf), "%c",
			    (unsigned char)v) < 0)
d344 1
a344 1
			if (file_printf(ms, m->desc, buf) == -1)
d348 1
a348 1
			if (file_printf(ms, m->desc, (unsigned char) v) == -1)
d363 1
a363 2
			if (snprintf(buf, sizeof(buf), "%hu",
			    (unsigned short)v) < 0)
d365 1
a365 1
			if (file_printf(ms, m->desc, buf) == -1)
d369 1
a369 1
			if (file_printf(ms, m->desc, (unsigned short) v) == -1)
d385 1
a385 1
			if (snprintf(buf, sizeof(buf), "%u", (uint32_t)v) < 0)
d387 1
a387 1
			if (file_printf(ms, m->desc, buf) == -1)
d391 1
a391 1
			if (file_printf(ms, m->desc, (uint32_t) v) == -1)
d402 1
a402 1
		if (file_printf(ms, m->desc, (uint64_t) v) == -1)
d412 1
a412 1
			if (file_printf(ms, m->desc, m->value.s) == -1)
d419 1
a419 1
			if (file_printf(ms, m->desc, p->s) == -1)
d422 2
d431 1
a431 1
		if (file_printf(ms, m->desc, file_fmttime(p->l, 1)) == -1)
d440 1
a440 1
		if (file_printf(ms, m->desc, file_fmttime(p->l, 0)) == -1)
d448 1
a448 1
		if (file_printf(ms, m->desc, file_fmttime((uint32_t)p->q, 1))
d457 1
a457 1
		if (file_printf(ms, m->desc, file_fmttime((uint32_t)p->q, 0))
d463 42
d514 1
a514 1
		rval = file_printf(ms, m->desc, cp);
d528 1
a528 1
	  	if (file_printf(ms, m->desc, m->value.s) == -1)
d537 1
a537 1
	  	if (file_printf(ms, m->desc, m->value.s) == -1)
d605 29
d700 5
a704 4
		p->q = (int64_t)
		    (((int64_t)p->hq[0]<<56)|((int64_t)p->hq[1]<<48)|
		     ((int64_t)p->hq[2]<<40)|((int64_t)p->hq[3]<<32)|
		     (p->hq[4]<<24)|(p->hq[5]<<16)|(p->hq[6]<<8)|(p->hq[7]));
d721 5
a725 4
		p->q = (int64_t)
		    (((int64_t)p->hq[7]<<56)|((int64_t)p->hq[6]<<48)|
		     ((int64_t)p->hq[5]<<40)|((int64_t)p->hq[4]<<32)|
		     (p->hq[3]<<24)|(p->hq[2]<<16)|(p->hq[1]<<8)|(p->hq[0]));
d735 30
d798 1
a801 4
			/*
			 * offset is interpreted as last line to search,
			 * (starting at 1), not as bytes-from start-of-file
			 */
d848 1
a848 1
			for (/*EMPTY*/; src < esrc; src++, dst++) {
d850 1
a850 1
					*dst = *src++;
d853 6
a858 2
				if (*dst == '\0')
					*dst = ' ';
d896 1
a896 1
	uint32_t count = m->str_count;
a1356 7
			/*	case TOOMANYSWITCHBLOCKS:
			 *		ugh = p->eye % m->strain;
			 *		rub;
			 *	case BEER:
			 *		off = p->tab & m->in_gest;
			 *		sleep;
			 */
d1404 3
d1411 7
d1453 2
a1454 4
	 * What we want here is:
	 * v = strncmp(m->value.s, p->s, m->vallen);
	 * but ignoring any nulls.  bcmp doesn't give -/+/0
	 * and isn't universally available anyway.
d1518 2
d1561 66
a1653 1
		ms->search.offset = m->offset;
d1655 1
a1655 1
		for (idx = 0; m->str_count == 0 || idx < m->str_count; idx++) {
d1661 1
a1661 1
				ms->search.offset = m->offset + idx;
@


1.12
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.11 2004/05/19 02:32:36 tedu Exp $ */
a38 1
#include <regex.h>
d42 1
a42 1
FILE_RCSID("@@(#)$Id: softmagic.c,v 1.11 2004/05/19 02:32:36 tedu Exp $")
d47 4
a50 4
private int mget(struct magic_set *, union VALUETYPE *, const unsigned char *,
    struct magic *, size_t);
private int mcheck(struct magic_set *, union VALUETYPE *, struct magic *);
private int32_t mprint(struct magic_set *, union VALUETYPE *, struct magic *);
d52 8
a59 2
private int mconvert(struct magic_set *, union VALUETYPE *, struct magic *);
private int check_mem(struct magic_set *, unsigned int);
d62 1
a62 2
 * softmagic - lookup one file in database 
 * (already read from MAGIC by apprentice.c).
d70 1
d72 2
a73 2
		if (match(ms, ml->magic, ml->nmagic, buf, nbytes))
			return 1;
a111 2
	union VALUETYPE p;
	int32_t oldoff = 0;
d114 1
d116 1
a116 1
	if (check_mem(ms, cont_level) == -1)
d120 5
d126 14
a139 9
		int flush = !mget(ms, &p, s, &magic[magindex], nbytes);
		switch (mcheck(ms, &p, &magic[magindex])) {
		case -1:
			return -1;
		case 0:
			flush++;
			break;
		default:
			break;
d147 2
a148 2
			       magic[magindex + 1].cont_level != 0)
			       magindex++;
d152 8
a159 3
		if (!firstline) { /* we found another match */
			/* put a newline and '-' to do some simple formatting*/
			if (file_printf(ms, "\n- ") == -1)
d163 1
a163 1
		if ((ms->c.off[cont_level] = mprint(ms, &p, &magic[magindex]))
d166 1
a166 6
		/*
		 * If we printed something, we'll need to print
		 * a blank before we print something else.
		 */
		if (magic[magindex].desc[0])
			need_separator = 1;
d168 1
a168 1
		if (check_mem(ms, ++cont_level) == -1)
d171 4
a174 2
		while (magic[magindex+1].cont_level != 0 && 
		       ++magindex < nmagic) {
d184 1
d186 2
a187 2
				oldoff=magic[magindex].offset;
				magic[magindex].offset += ms->c.off[cont_level-1];
d189 12
a200 2
			if (!mget(ms, &p, s, &magic[magindex], nbytes))
				goto done;
d202 1
a202 1
			switch (mcheck(ms, &p, &magic[magindex])) {
d206 3
d211 18
d230 4
a233 5
				 * This continuation matched.
				 * Print its message, with
				 * a blank before it if
				 * the previous item printed
				 * and this item isn't empty.
d238 1
a238 1
				   && (magic[magindex].desc[0] != '\0')) {
d243 1
a243 2
				if ((ms->c.off[cont_level] = mprint(ms, &p,
				    &magic[magindex])) == -1)
d253 1
a253 1
				if (check_mem(ms, ++cont_level) == -1)
d255 1
a255 4
			}
done:
			if (magic[magindex].flag & OFFADD) {
				 magic[magindex].offset = oldoff;
d259 3
a261 2
		returnval = 1;
		if ((ms->flags & MAGIC_CONTINUE) == 0) {
d269 1
a269 1
check_mem(struct magic_set *ms, unsigned int level)
d271 2
a272 1
	size_t len;
d274 1
a274 1
	if (level < ms->c.len)
d277 30
a306 6
	len = (ms->c.len += 20) * sizeof(*ms->c.off);
	ms->c.off = (ms->c.off == NULL) ? malloc(len) : realloc(ms->c.off, len);
	if (ms->c.off != NULL)
		return 0;
	file_oomem(ms);
	return -1;
d308 1
d311 1
a311 1
mprint(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d313 4
a316 3
	uint32_t v;
	int32_t t=0 ;

d320 3
a322 2
		v = file_signextend(ms, m, (size_t)p->b);
		if (file_printf(ms, m->desc, (unsigned char) v) == -1)
d324 13
a336 1
		t = m->offset + sizeof(char);
d342 3
a344 2
		v = file_signextend(ms, m, (size_t)p->h);
		if (file_printf(ms, m->desc, (unsigned short) v) == -1)
d346 13
a358 1
		t = m->offset + sizeof(short);
d364 4
a367 2
		v = file_signextend(ms, m, p->l);
		if (file_printf(ms, m->desc, (uint32_t) v) == -1)
d369 21
a389 1
		t = m->offset + sizeof(int32_t);
d394 3
a396 1
		if (m->reln == '=') {
d399 1
a399 1
			t = m->offset + strlen(m->value.s);
d406 1
a406 1
			t = m->offset + strlen(p->s);
d413 1
d416 1
a416 1
		t = m->offset + sizeof(time_t);
d422 1
d425 50
a474 1
		t = m->offset + sizeof(time_t);
d476 3
a478 2
	case FILE_REGEX:
	  	if (file_printf(ms, m->desc, p->s) == -1)
d480 1
a480 1
		t = m->offset + strlen(p->s);
d484 1
a484 1
		file_error(ms, 0, "invalid m->type (%d) in mprint()", m->type);
d490 56
d552 1
a552 1
mconvert(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d554 2
d558 1
a558 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->b &= m->mask;
				break;
			case FILE_OPOR:
				p->b |= m->mask;
				break;
			case FILE_OPXOR:
				p->b ^= m->mask;
				break;
			case FILE_OPADD:
				p->b += m->mask;
				break;
			case FILE_OPMINUS:
				p->b -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->b *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->b /= m->mask;
				break;
			case FILE_OPMODULO:
				p->b %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->b = ~p->b;
d561 1
a561 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
d566 6
a571 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
d574 24
a597 24
		{
			int n;

			/* Null terminate and eat *trailing* return */
			p->s[sizeof(p->s) - 1] = '\0';
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
			return 1;
		}
	case FILE_PSTRING:
		{
			char *ptr1 = p->s, *ptr2 = ptr1 + 1;
			unsigned int n = *p->s;
			if (n >= sizeof(p->s))
				n = sizeof(p->s) - 1;
			while (n--)
				*ptr1++ = *ptr2++;
			*ptr1 = '\0';
			n = strlen(p->s) - 1;
			if (p->s[n] == '\n')
				p->s[n] = '\0';
			return 1;
		}
d600 1
a600 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
d607 10
a616 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
d620 1
a620 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->h &= m->mask;
				break;
			case FILE_OPOR:
				p->h |= m->mask;
				break;
			case FILE_OPXOR:
				p->h ^= m->mask;
				break;
			case FILE_OPADD:
				p->h += m->mask;
				break;
			case FILE_OPMINUS:
				p->h -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->h *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->h /= m->mask;
				break;
			case FILE_OPMODULO:
				p->h %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->h = ~p->h;
d627 17
a643 29
		if (m->mask)
			switch (m->mask_op&0x7F) {
			case FILE_OPAND:
				p->l &= m->mask;
				break;
			case FILE_OPOR:
				p->l |= m->mask;
				break;
			case FILE_OPXOR:
				p->l ^= m->mask;
				break;
			case FILE_OPADD:
				p->l += m->mask;
				break;
			case FILE_OPMINUS:
				p->l -= m->mask;
				break;
			case FILE_OPMULTIPLY:
				p->l *= m->mask;
				break;
			case FILE_OPDIVIDE:
				p->l /= m->mask;
				break;
			case FILE_OPMODULO:
				p->l %= m->mask;
				break;
			}
		if (m->mask_op & FILE_OPINVERSE)
			p->l = ~p->l;
d646 2
d650 1
a650 1
		file_error(ms, 0, "invalid type %d in mconvert()", m->type);
d666 2
a667 2
mget(struct magic_set *ms, union VALUETYPE *p, const unsigned char *s,
    struct magic *m, size_t nbytes)
d669 10
a678 1
	uint32_t offset = m->offset;
d680 66
a745 9
	if (m->type == FILE_REGEX) {
		/*
		 * offset is interpreted as last line to search,
		 * (starting at 1), not as bytes-from start-of-file
		 */
		unsigned char *b, *last = NULL;
		if ((p->buf = strdup((const char *)s)) == NULL) {
			file_oomem(ms);
			return -1;
a746 16
		for (b = (unsigned char *)p->buf; offset &&
		    (b = (unsigned char *)strchr((char *)b, '\n')) != NULL;
		    offset--, s++)
			last = b;
		if (last != NULL)
			*last = '\0';
	} else if (offset + sizeof(union VALUETYPE) <= nbytes)
		memcpy(p, s + offset, sizeof(union VALUETYPE));
	else {
		/*
		 * the usefulness of padding with zeroes eludes me, it
		 * might even cause problems
		 */
		memset(p, 0, sizeof(union VALUETYPE));
		if (offset < nbytes)
			memcpy(p, s + offset, nbytes - offset);
d749 20
a768 6
	/* Verify we have enough data to match magic type */
	switch (m->type) {
		case FILE_BYTE:
			if (nbytes < (offset + 1)) /* should alway be true */
				return 0;
			break;
d770 7
a776 6
		case FILE_SHORT:
		case FILE_BESHORT:
		case FILE_LESHORT:
			if (nbytes < (offset + 2))
				return 0;
			break;
d778 2
a779 19
		case FILE_LONG:
		case FILE_BELONG:
		case FILE_LELONG:
		case FILE_DATE:
		case FILE_BEDATE:
		case FILE_LEDATE:
		case FILE_LDATE:
		case FILE_BELDATE:
		case FILE_LELDATE:
			if (nbytes < (offset + 4))
				return 0;
			break;

		case FILE_STRING:
		case FILE_PSTRING:
			if (nbytes < (offset + m->vallen))
				return 0;
			break;
	}
d787 34
d823 4
a826 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d828 1
a828 1
					offset = p->b & m->in_offset;
d831 1
a831 1
					offset = p->b | m->in_offset;
d834 1
a834 1
					offset = p->b ^ m->in_offset;
d837 1
a837 1
					offset = p->b + m->in_offset;
d840 1
a840 1
					offset = p->b - m->in_offset;
d843 1
a843 1
					offset = p->b * m->in_offset;
d846 1
a846 1
					offset = p->b / m->in_offset;
d849 1
a849 1
					offset = p->b % m->in_offset;
d852 2
d858 4
a861 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d865 1
a865 1
						 m->in_offset;
d870 1
a870 1
						 m->in_offset;
d875 1
a875 1
						 m->in_offset;
d880 1
a880 1
						 m->in_offset;
d885 1
a885 1
						 m->in_offset;
d890 1
a890 1
						 m->in_offset;
d895 1
a895 1
						 m->in_offset;
d900 1
a900 1
						 m->in_offset;
d903 3
d910 4
a913 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d917 1
a917 1
						 m->in_offset;
d922 1
a922 1
						 m->in_offset;
d927 1
a927 1
						 m->in_offset;
d932 1
a932 1
						 m->in_offset;
d937 1
a937 1
						 m->in_offset;
d942 1
a942 1
						 m->in_offset;
d947 1
a947 1
						 m->in_offset;
d952 1
a952 1
						 m->in_offset;
d955 3
d962 4
a965 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d967 1
a967 1
					offset = p->h & m->in_offset;
d970 1
a970 1
					offset = p->h | m->in_offset;
d973 1
a973 1
					offset = p->h ^ m->in_offset;
d976 1
a976 1
					offset = p->h + m->in_offset;
d979 1
a979 1
					offset = p->h - m->in_offset;
d982 1
a982 1
					offset = p->h * m->in_offset;
d985 1
a985 1
					offset = p->h / m->in_offset;
d988 1
a988 1
					offset = p->h % m->in_offset;
d991 3
d998 4
a1001 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d1007 1
a1007 1
						 m->in_offset;
d1014 1
a1014 1
						 m->in_offset;
d1021 1
a1021 1
						 m->in_offset;
d1028 1
a1028 1
						 m->in_offset;
d1035 1
a1035 1
						 m->in_offset;
d1042 1
a1042 1
						 m->in_offset;
d1049 1
a1049 1
						 m->in_offset;
d1056 1
a1056 1
						 m->in_offset;
d1059 5
d1068 4
a1071 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d1077 1
a1077 1
						 m->in_offset;
d1084 1
a1084 1
						 m->in_offset;
d1091 1
a1091 1
						 m->in_offset;
d1098 1
a1098 1
						 m->in_offset;
d1105 1
a1105 1
						 m->in_offset;
d1112 1
a1112 1
						 m->in_offset;
d1119 1
a1119 1
						 m->in_offset;
d1126 1
a1126 1
						 m->in_offset;
d1129 75
d1208 4
a1211 2
			if (m->in_offset)
				switch (m->in_op&0x7F) {
d1213 1
a1213 1
					offset = p->l & m->in_offset;
d1216 1
a1216 1
					offset = p->l | m->in_offset;
d1219 1
a1219 1
					offset = p->l ^ m->in_offset;
d1222 1
a1222 1
					offset = p->l + m->in_offset;
d1225 1
a1225 1
					offset = p->l - m->in_offset;
d1228 1
a1228 1
					offset = p->l * m->in_offset;
d1231 1
a1231 1
					offset = p->l / m->in_offset;
d1234 1
a1234 1
					offset = p->l % m->in_offset;
d1244 2
d1251 5
a1255 5
		if (nbytes < sizeof(union VALUETYPE) ||
		    nbytes - sizeof(union VALUETYPE) < offset)
			return 0;

		memcpy(p, s + offset, sizeof(union VALUETYPE));
d1263 49
a1311 2
	if (!mconvert(ms, p, m))
	  return 0;
d1315 76
d1392 1
a1392 1
mcheck(struct magic_set *ms, union VALUETYPE *p, struct magic *m)
d1394 2
a1395 2
	uint32_t l = m->value.l;
	uint32_t v;
d1397 1
a1397 5

	if ( (m->value.s[0] == 'x') && (m->value.s[1] == '\0') ) {
		return 1;
	}

d1413 1
d1417 1
d1421 1
d1425 17
d1444 18
a1461 10
	{
		/*
		 * What we want here is:
		 * v = strncmp(m->value.s, p->s, m->vallen);
		 * but ignoring any nulls.  bcmp doesn't give -/+/0
		 * and isn't universally available anyway.
		 */
		unsigned char *a = (unsigned char*)m->value.s;
		unsigned char *b = (unsigned char*)p->s;
		int len = m->vallen;
d1464 10
a1473 29
		if (0L == m->mask) { /* normal string: do it fast */
			while (--len >= 0)
				if ((v = *b++ - *a++) != '\0')
					break; 
		} else { /* combine the others */
			while (--len >= 0) {
				if ((m->mask & STRING_IGNORE_LOWERCASE) &&
				    islower(*a)) {
					if ((v = tolower(*b++) - *a++) != '\0')
						break;
				} else if ((m->mask & STRING_COMPACT_BLANK) && 
				    isspace(*a)) { 
					a++;
					if (isspace(*b++)) {
						while (isspace(*b))
							b++;
					} else {
						v = 1;
						break;
					}
				} else if (isspace(*a) &&
				    (m->mask & STRING_COMPACT_OPTIONAL_BLANK)) {
					a++;
					while (isspace(*b))
						b++;
				} else {
					if ((v = *b++ - *a++) != '\0')
						break;
				}
d1478 1
a1478 2
	case FILE_REGEX:
	{
d1483 7
a1489 1
		rc = regcomp(&rx, m->value.s, REG_EXTENDED|REG_NOSUB);
d1491 41
a1531 6
			free(p->buf);
			regerror(rc, &rx, errmsg, sizeof(errmsg));
			file_error(ms, 0, "regex error %d, (%s)", rc, errmsg);
			return -1;
		} else {
			rc = regexec(&rx, p->buf, 0, 0, 0);
a1532 2
			free(p->buf);
			return !rc;
d1534 3
d1539 1
a1539 1
		file_error(ms, 0, "invalid type %d in mcheck()", m->type);
d1543 1
a1543 2
	if (m->type != FILE_STRING && m->type != FILE_PSTRING)
		v = file_signextend(ms, m, v);
d1548 2
a1549 1
			(void) fprintf(stderr, "%u == *any* = 1\n", v);
d1556 3
a1558 2
			(void) fprintf(stderr, "%u != %u = %d\n",
				       v, l, matched);
d1564 3
a1566 2
			(void) fprintf(stderr, "%u == %u = %d\n",
				       v, l, matched);
d1573 3
a1575 2
				(void) fprintf(stderr, "%u > %u = %d\n",
					       v, l, matched);
d1578 1
a1578 1
			matched = (int32_t) v > (int32_t) l;
d1580 2
a1581 2
				(void) fprintf(stderr, "%d > %d = %d\n",
					       v, l, matched);
d1589 3
a1591 2
				(void) fprintf(stderr, "%u < %u = %d\n",
					       v, l, matched);
d1594 1
a1594 1
			matched = (int32_t) v < (int32_t) l;
d1596 2
a1597 2
				(void) fprintf(stderr, "%d < %d = %d\n",
					       v, l, matched);
d1604 3
a1606 2
			(void) fprintf(stderr, "((%x & %x) == %x) = %d\n",
				       v, l, l, matched);
d1612 3
a1614 2
			(void) fprintf(stderr, "((%x & %x) != %x) = %d\n",
				       v, l, l, matched);
d1619 1
a1619 1
		file_error(ms, 0, "cannot happen: invalid relation `%c'",
d1625 12
@


1.11
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d43 1
a43 1
FILE_RCSID("@@(#)$Id: softmagic.c,v 1.65 2004/03/09 18:49:58 christos Exp $")
d281 2
a282 5
			if (*m->value.s == '\0') {
				char *cp = strchr(p->s,'\n');
				if (cp)
					*cp = '\0';
			}
@


1.10
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 2
/*	$OpenBSD: softmagic.c,v 1.9 2003/03/11 21:26:26 ian Exp $	*/

a2 2
 * softmagic - interpret variable magic from /etc/magic
 *
d29 3
d33 2
a34 2
#include <sys/types.h>
#include <stdio.h>
d36 1
d39 1
a39 1
#include <err.h>
a40 1
#include "file.h"
d43 1
a43 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.9 2003/03/11 21:26:26 ian Exp $";
d46 9
a54 6
static int match(unsigned char *, int);
static int mget(union VALUETYPE *, unsigned char *, struct magic *, int);
static int mcheck(union VALUETYPE *, struct magic *);
static int32_t mprint(union VALUETYPE *, struct magic *);
static void mdebug(int32_t, char *, int);
static int mconvert(union VALUETYPE *, struct magic *);
d58 1
a58 1
 * (already read from /etc/magic by apprentice.c).
d62 2
a63 4
int
softmagic(buf, nbytes)
unsigned char *buf;
int nbytes;
d65 4
a68 2
	if (match(buf, nbytes))
		return 1;
d100 3
a102 4
static int
match(s, nbytes)
unsigned char	*s;
int nbytes;
d104 2
a105 2
	int magindex = 0;
	int cont_level = 0;
a107 2
	static int32_t *tmpoff = NULL;
	static size_t tmplen = 0;
d109 2
d112 2
a113 3
	if (tmpoff == NULL)
		if ((tmpoff = (int32_t *) malloc(tmplen = 20)) == NULL)
			err(1, "malloc");
d117 19
a135 10
		if (!mget(&p, s, &magic[magindex], nbytes) ||
		    !mcheck(&p, &magic[magindex])) {
			    /* 
			     * main entry didn't match,
			     * flush its continuations
			     */
			    while (magindex < nmagic &&
			    	   magic[magindex + 1].cont_level != 0)
			    	   magindex++;
			    continue;
d138 9
a146 1
		tmpoff[cont_level] = mprint(&p, &magic[magindex]);
d154 3
a156 4
		if (++cont_level >= tmplen)
			if ((tmpoff = (int32_t *) realloc(tmpoff,
						       tmplen += 20)) == NULL)
				err(1, "malloc");
d159 36
a194 46
			if (cont_level >= magic[magindex].cont_level) {
				if (cont_level > magic[magindex].cont_level) {
					/*
					 * We're at the end of the level
					 * "cont_level" continuations.
					 */
					cont_level = magic[magindex].cont_level;
				}
				if (magic[magindex].flag & ADD) {
					oldoff=magic[magindex].offset;
					magic[magindex].offset += tmpoff[cont_level-1];
				}
				if (mget(&p, s, &magic[magindex], nbytes) &&
				    mcheck(&p, &magic[magindex])) {
					/*
					 * This continuation matched.
					 * Print its message, with
					 * a blank before it if
					 * the previous item printed
					 * and this item isn't empty.
					 */
					/* space if previous printed */
					if (need_separator
					   && (magic[magindex].nospflag == 0)
					   && (magic[magindex].desc[0] != '\0')
					   ) {
						(void) putchar(' ');
						need_separator = 0;
					}
					tmpoff[cont_level] = mprint(&p, &magic[magindex]);
					if (magic[magindex].desc[0])
						need_separator = 1;

					/*
					 * If we see any continuations
					 * at a higher level,
					 * process them.
					 */
					if (++cont_level >= tmplen)
						if ((tmpoff = 
						    (int32_t *) realloc(tmpoff,
						    tmplen += 20)) == NULL)
							err(1, "malloc");
				}
				if (magic[magindex].flag & ADD) {
					 magic[magindex].offset = oldoff;
d196 17
d215 5
a219 1
		return 1;		/* all through */
d221 17
a237 1
	return 0;			/* no match at all */
d240 2
a241 4
static int32_t
mprint(p, m)
union VALUETYPE *p;
struct magic *m;
a242 1
	char *pp, *rt;
d248 4
a251 4
  	case BYTE:
		v = p->b;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (unsigned char) v);
d255 6
a260 6
  	case SHORT:
  	case BESHORT:
  	case LESHORT:
		v = p->h;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (unsigned short) v);
d264 6
a269 6
  	case LONG:
  	case BELONG:
  	case LELONG:
		v = p->l;
		v = signextend(m, v) & m->mask;
		(void) printf(m->desc, (uint32_t) v);
d273 2
a274 1
  	case STRING:
d276 2
a277 1
			(void) printf(m->desc, m->value.s);
d286 2
a287 1
			(void) printf(m->desc, p->s);
d292 5
a296 7
	case DATE:
	case BEDATE:
	case LEDATE:
		pp = ctime((time_t*) &p->l);
		if ((rt = strchr(pp, '\n')) != NULL)
			*rt = '\0';
		(void) printf(m->desc, pp);
d300 13
d314 2
a315 2
		errx(1, "invalid m->type (%d) in mprint().", m->type);
		/*NOTREACHED*/
d322 2
d325 2
a326 4
static int
mconvert(p, m)
union VALUETYPE *p;
struct magic *m;
d329 30
a358 4
	case BYTE:
	case SHORT:
	case LONG:
	case DATE:
d360 65
a424 1
	case STRING:
d426 1
a426 1
			char *ptr;
d428 1
a428 1
			/* Null terminate and eat the return */
d430 3
a432 2
			if ((ptr = strchr(p->s, '\n')) != NULL)
				*ptr = '\0';
d435 15
a449 1
	case BESHORT:
d451 29
d481 3
a483 2
	case BELONG:
	case BEDATE:
d486 29
d516 1
a516 1
	case LESHORT:
d518 29
d548 3
a550 2
	case LELONG:
	case LEDATE:
d553 31
d586 1
a586 1
		errx(1, "invalid type %d in mconvert().", m->type);
d592 2
a593 5
static void
mdebug(offset, str, len)
int32_t offset;
char *str;
int len;
d596 1
a596 1
	showstr(stderr, (char *) str, len);
d601 3
a603 6
static int
mget(p, s, m, nbytes)
union VALUETYPE* p;
unsigned char	*s;
struct magic *m;
int nbytes;
d605 1
a605 1
	int32_t offset = m->offset;
d607 17
a623 1
	if (offset + sizeof(union VALUETYPE) <= nbytes)
a629 1
		int32_t have = nbytes - offset;
d631 2
a632 2
		if (have > 0)
			memcpy(p, s + offset, have);
d635 6
d642 25
a666 3
	if (debug) {
		mdebug(offset, (char *) p, sizeof(union VALUETYPE));
		mdump(m);
d669 4
a672 2
	if (!mconvert(p, m))
		return 0;
d675 219
a893 4

		switch (m->in.type) {
		case BYTE:
			offset = p->b + m->in.offset;
d895 62
a956 2
		case SHORT:
			offset = p->h + m->in.offset;
d958 37
a994 2
		case LONG:
			offset = p->l + m->in.offset;
d998 2
a999 1
		if (offset + sizeof(union VALUETYPE) > nbytes)
d1004 4
a1007 3
		if (debug) {
			mdebug(offset, (char *) p, sizeof(union VALUETYPE));
			mdump(m);
a1008 3

		if (!mconvert(p, m))
			return 0;
d1010 2
d1015 2
a1016 4
static int
mcheck(p, m)
union VALUETYPE* p;
struct magic *m;
a1022 1
		fprintf(stderr, "BOINK");
d1028 1
a1028 1
	case BYTE:
d1032 3
a1034 3
	case SHORT:
	case BESHORT:
	case LESHORT:
d1038 9
a1046 6
	case LONG:
	case BELONG:
	case LELONG:
	case DATE:
	case BEDATE:
	case LEDATE:
d1050 5
a1054 3
	case STRING:
		l = 0;
		/* What we want here is:
d1059 4
d1064 1
a1064 5
		{
			unsigned char *a = (unsigned char*)m->value.s;
			unsigned char *b = (unsigned char*)p->s;
			int len = m->vallen;

d1067 27
a1093 1
					break;
d1096 20
d1117 2
a1118 2
		errx(1, "invalid type %d in mcheck().", m->type);
		return 0;/*NOTREACHED*/
d1121 2
a1122 1
	v = signextend(m, v) & m->mask;
d1126 1
a1126 1
		if (debug)
d1133 1
a1133 1
		if (debug)
d1140 1
a1140 1
		if (debug)
d1148 1
a1148 1
			if (debug)
d1154 1
a1154 1
			if (debug)
d1163 1
a1163 1
			if (debug)
d1169 1
a1169 1
			if (debug)
d1177 1
a1177 1
		if (debug)
d1184 1
a1184 1
		if (debug)
d1191 3
a1193 2
		errx(1, "mcheck: can't happen: invalid relation %d.", m->reln);
		break;/*NOTREACHED*/
@


1.9
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.8 2002/06/05 13:46:44 itojun Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d43 1
a43 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.8 2002/06/05 13:46:44 itojun Exp $";
@


1.8
log
@use types in inttypes.h directly
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.7 2002/02/17 19:42:30 millert Exp $	*/
d6 30
a35 22
 * Copyright (c) Ian F. Darwin, 1987.
 * Written by Ian F. Darwin.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or of the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. The author is not responsible for the consequences of use of this
 *    software, no matter how awful, even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Since few users ever read sources,
 *    credits must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.  Since few users
 *    ever read sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
d48 1
a48 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.7 2002/02/17 19:42:30 millert Exp $";
@


1.7
log
@Manual cleanup of remaining userland __P use (excluding packages maintained outside the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.6 2002/02/16 21:27:46 millert Exp $	*/
d40 1
a40 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.6 2002/02/16 21:27:46 millert Exp $";
d46 2
a47 2
static int32 mprint(union VALUETYPE *, struct magic *);
static void mdebug(int32, char *, int);
d103 1
a103 1
	static int32 *tmpoff = NULL;
d105 1
a105 1
	int32 oldoff = 0;
d108 1
a108 1
		if ((tmpoff = (int32 *) malloc(tmplen = 20)) == NULL)
d134 1
a134 1
			if ((tmpoff = (int32 *) realloc(tmpoff,
d179 1
a179 1
						    (int32 *) realloc(tmpoff,
d193 1
a193 1
static int32
d199 2
a200 2
	uint32 v;
	int32 t=0 ;
d225 2
a226 2
		(void) printf(m->desc, (uint32) v);
		t = m->offset + sizeof(int32);
d291 1
a291 1
		p->l = (int32)
d299 1
a299 1
		p->l = (int32)
d311 1
a311 1
int32 offset;
d328 1
a328 1
	int32 offset = m->offset;
d337 1
a337 1
		int32 have = nbytes - offset;
d387 2
a388 2
	uint32 l = m->value.l;
	uint32 v;
d471 1
a471 1
			matched = (int32) v > (int32) l;
d486 1
a486 1
			matched = (int32) v < (int32) l;
@


1.6
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.5 2001/11/19 19:02:13 mpech Exp $	*/
d40 1
a40 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.5 2001/11/19 19:02:13 mpech Exp $";
d44 1
a44 2
static int mget		__P((union VALUETYPE *,
			     unsigned char *, struct magic *, int));
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.4 1998/07/10 15:05:27 mickey Exp $	*/
d40 1
a40 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.4 1998/07/10 15:05:27 mickey Exp $";
d43 1
a43 1
static int match	__P((unsigned char *, int));
d46 4
a49 4
static int mcheck	__P((union VALUETYPE *, struct magic *));
static int32 mprint	__P((union VALUETYPE *, struct magic *));
static void mdebug	__P((int32, char *, int));
static int mconvert	__P((union VALUETYPE *, struct magic *));
@


1.4
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.3 1997/02/09 23:58:36 millert Exp $	*/
d40 1
a40 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.3 1997/02/09 23:58:36 millert Exp $";
d388 2
a389 2
	register uint32 l = m->value.l;
	register uint32 v;
d427 3
a429 3
			register unsigned char *a = (unsigned char*)m->value.s;
			register unsigned char *b = (unsigned char*)p->s;
			register int len = m->vallen;
@


1.3
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: softmagic.c,v 1.2 1996/06/26 05:33:01 deraadt Exp $	*/
d30 1
d35 1
a35 1
#include <sys/types.h>
d40 1
a40 1
static char *moduleid = "$OpenBSD: softmagic.c,v 1.2 1996/06/26 05:33:01 deraadt Exp $";
d110 1
a110 1
			error("out of memory\n");
d137 1
a137 1
				error("out of memory\n");
d182 1
a182 1
							error("out of memory\n");
d257 1
a257 1
		error("invalid m->type (%d) in mprint().\n", m->type);
d304 1
a304 1
		error("invalid type %d in mconvert().\n", m->type);
d437 1
a437 1
		error("invalid type %d in mcheck().\n", m->type);
d510 1
a510 1
		error("mcheck: can't happen: invalid relation %d.\n", m->reln);
@


1.2
log
@rcsid
@
text
@d1 2
a2 1
/*	$OpenBSD: softmagic.c,v 1.1.1.1 1995/10/18 08:45:09 deraadt Exp $	*/
d32 1
d39 1
a39 1
static char *moduleid = "$OpenBSD$";
d46 2
a47 2
static void mprint	__P((union VALUETYPE *, struct magic *));
static void mdebug	__P((long, char *, int));
d103 7
d125 1
a125 1
		mprint(&p, &magic[magindex]);
d133 4
a136 1
		cont_level++;
d147 4
d168 1
a168 1
					mprint(&p, &magic[magindex]);
d177 8
a184 1
					cont_level++;
d193 1
a193 1
static void
d199 2
a200 1
	unsigned long v;
d208 1
d217 1
d225 2
a226 1
		(void) printf(m->desc, (unsigned long) v);
d232 1
d235 5
d241 1
d243 1
a243 1
		return;
d252 3
a254 1
		return;
d259 1
a269 2
	char *rt;

d277 9
a285 5
		/* Null terminate and eat the return */
		p->s[sizeof(p->s) - 1] = '\0';
		if ((rt = strchr(p->s, '\n')) != NULL)
			*rt = '\0';
		return 1;
d291 1
a291 1
		p->l = (long)
d299 1
a299 1
		p->l = (long)
d311 1
a311 1
long offset;
d315 1
a315 1
	(void) fprintf(stderr, "mget @@%ld: ", offset);
d328 1
a328 1
	long offset = m->offset;
d337 1
a337 1
		long have = nbytes - offset;
d387 2
a388 2
	register unsigned long l = m->value.l;
	register unsigned long v;
d431 1
a431 1
				if ((v = *b++ - *a++) != 0)
d445 1
a445 1
			(void) fprintf(stderr, "%lu == *any* = 1\n", v);
d452 1
a452 1
			(void) fprintf(stderr, "%lu != %lu = %d\n",
d459 1
a459 1
			(void) fprintf(stderr, "%lu == %lu = %d\n",
d467 1
a467 1
				(void) fprintf(stderr, "%lu > %lu = %d\n",
d471 1
a471 1
			matched = (long) v > (long) l;
d473 1
a473 1
				(void) fprintf(stderr, "%ld > %ld = %d\n",
d482 1
a482 1
				(void) fprintf(stderr, "%lu < %lu = %d\n",
d486 1
a486 1
			matched = (long) v < (long) l;
d488 1
a488 1
				(void) fprintf(stderr, "%ld < %ld = %d\n",
d496 1
a496 1
			(void) fprintf(stderr, "((%lx & %lx) == %lx) = %d\n",
d503 1
a503 1
			(void) fprintf(stderr, "((%lx & %lx) != %lx) = %d\n",
@


1.1
log
@Initial revision
@
text
@d1 1
d37 1
a37 2
static char *moduleid = 
	"@@(#)$Id: softmagic.c,v 1.9 1995/05/21 00:13:32 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
