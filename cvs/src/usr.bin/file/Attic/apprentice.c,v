head	1.35;
access;
symbols
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.29.0.16
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.29.0.14
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.12
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.10
	OPENBSD_5_0:1.29.0.8
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.6
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.10.0.6
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.34;
commitid	4VUU04TZM8ebPiy4;

1.34
date	2015.01.16.18.08.15;	author millert;	state Exp;
branches;
next	1.33;
commitid	YSfteyP6tDfW8ZsE;

1.33
date	2015.01.16.08.24.04;	author doug;	state Exp;
branches;
next	1.32;
commitid	3kmy59NzQyG8Ee1H;

1.32
date	2014.10.26.04.10.26;	author brad;	state Exp;
branches;
next	1.31;
commitid	HxaumdTLwmtf8tYZ;

1.31
date	2014.05.18.17.50.11;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2014.01.16.21.45.33;	author tobias;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.11.16.21.51;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.27.16.26.42;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.05.14.29.46;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.31.18.06.27;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.04.14.17.01;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.04.10.53.40;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2004.09.25.09.19.35;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.07.19.03.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.05.13.46.44;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.06.51.41;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.30.16.00.13;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.12.06.00.32.28;	author deraadt;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.09.26.20.47.28;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	98.08.21.04.25.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.08.19.17.20.01;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.07.10.15.05.13;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.09.23.58.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.32.54;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.30.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.08;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.08;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2000.10.06.21.16.12;	author jason;	state Exp;
branches;
next	;


desc
@@


1.35
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/*	$OpenBSD: apprentice.c,v 1.34 2015/01/16 18:08:15 millert Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * apprentice - make one pass through /etc/magic, learning its secrets.
 */


#include <sys/stat.h>
#include <sys/types.h>

#include "file.h"
#include "magic.h"
#include "patchlevel.h"
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <limits.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <fcntl.h>
#ifdef QUICK
#include <sys/mman.h>
#endif
#include <dirent.h>

#define	EATAB {while (isascii((unsigned char) *l) && \
		      isspace((unsigned char) *l))  ++l;}
#define LOWCASE(l) (isupper((unsigned char) (l)) ? \
			tolower((unsigned char) (l)) : (l))
/*
 * Work around a bug in headers on Digital Unix.
 * At least confirmed for: OSF1 V4.0 878
 */
#if defined(__osf__) && defined(__DECC)
#ifdef MAP_FAILED
#undef MAP_FAILED
#endif
#endif

#ifndef MAP_FAILED
#define MAP_FAILED (void *) -1
#endif

#ifndef MAP_FILE
#define MAP_FILE 0
#endif

struct magic_entry {
	struct magic *mp;	
	uint32_t cont_count;
	uint32_t max_count;
};

int file_formats[FILE_NAMES_SIZE];
const size_t file_nformats = FILE_NAMES_SIZE;
const char *file_names[FILE_NAMES_SIZE];
const size_t file_nnames = FILE_NAMES_SIZE;

private int getvalue(struct magic_set *ms, struct magic *, const char **, int);
private int hextoint(int);
private const char *getstr(struct magic_set *, const char *, char *, int,
    int *, int);
private int parse(struct magic_set *, struct magic_entry **, uint32_t *,
    const char *, size_t, int);
private int parse_mime(struct magic_set *, struct magic_entry **, uint32_t *,
    const char *);
private void eatsize(const char **);
private int apprentice_1(struct magic_set *, const char *, int, struct mlist *);
private size_t apprentice_magic_strength(const struct magic *);
private int apprentice_sort(const void *, const void *);
private int apprentice_load(struct magic_set *, struct magic **, uint32_t *,
    const char *, int);
private void byteswap(struct magic *, uint32_t);
private void bs1(struct magic *);
private uint16_t swap2(uint16_t);
private uint32_t swap4(uint32_t);
private uint64_t swap8(uint64_t);
private void mkdbname(const char *, char **, int);
private int apprentice_map(struct magic_set *, struct magic **, uint32_t *,
    const char *);
private int apprentice_compile(struct magic_set *, struct magic **, uint32_t *,
    const char *);
private int check_format_type(const char *, int);
private int check_format(struct magic_set *, struct magic *);
private int get_op(char);

private size_t maxmagic = 0;
private size_t magicsize = sizeof(struct magic);

private const char usg_hdr[] = "cont\toffset\ttype\topcode\tmask\tvalue\tdesc";
private const char mime_marker[] = "!:mime";
private const size_t mime_marker_len = sizeof(mime_marker) - 1;

#ifdef COMPILE_ONLY

int main(int, char *[]);

int
main(int argc, char *argv[])
{
	int ret;
	struct magic_set *ms;
	char *progname;

	if ((progname = strrchr(argv[0], '/')) != NULL)
		progname++;
	else
		progname = argv[0];

	if (argc != 2) {
		(void)fprintf(stderr, "Usage: %s file\n", progname);
		return 1;
	}

	if ((ms = magic_open(MAGIC_CHECK)) == NULL) {
		(void)fprintf(stderr, "%s: %s\n", progname, strerror(errno));
		return 1;
	}
	ret = magic_compile(ms, argv[1]) == -1 ? 1 : 0;
	if (ret == 1)
		(void)fprintf(stderr, "%s: %s\n", progname, magic_error(ms));
	magic_close(ms);
	return ret;
}
#endif /* COMPILE_ONLY */

static const struct type_tbl_s {
	const char name[16];
	const size_t len;
	const int type;
	const int format;
} type_tbl[] = {
# define XX(s)		s, (sizeof(s) - 1)
# define XX_NULL	"", 0
	{ XX("byte"),		FILE_BYTE,		FILE_FMT_NUM },
	{ XX("short"),		FILE_SHORT,		FILE_FMT_NUM },
	{ XX("default"),	FILE_DEFAULT,		FILE_FMT_STR },
	{ XX("long"),		FILE_LONG,		FILE_FMT_NUM },
	{ XX("string"),		FILE_STRING,		FILE_FMT_STR },
	{ XX("date"),		FILE_DATE,		FILE_FMT_STR },
	{ XX("beshort"),	FILE_BESHORT,		FILE_FMT_NUM },
	{ XX("belong"),		FILE_BELONG,		FILE_FMT_NUM },
	{ XX("bedate"),		FILE_BEDATE,		FILE_FMT_STR },
	{ XX("leshort"),	FILE_LESHORT,		FILE_FMT_NUM },
	{ XX("lelong"),		FILE_LELONG,		FILE_FMT_NUM },
	{ XX("ledate"),		FILE_LEDATE,		FILE_FMT_STR },
	{ XX("pstring"),	FILE_PSTRING,		FILE_FMT_STR },
	{ XX("ldate"),		FILE_LDATE,		FILE_FMT_STR },
	{ XX("beldate"),	FILE_BELDATE,		FILE_FMT_STR },
	{ XX("leldate"),	FILE_LELDATE,		FILE_FMT_STR },
	{ XX("regex"),		FILE_REGEX,		FILE_FMT_STR },
	{ XX("bestring16"),	FILE_BESTRING16,	FILE_FMT_STR },
	{ XX("lestring16"),	FILE_LESTRING16,	FILE_FMT_STR },
	{ XX("search"),		FILE_SEARCH,		FILE_FMT_STR },
	{ XX("medate"),		FILE_MEDATE,		FILE_FMT_STR },
	{ XX("meldate"),	FILE_MELDATE,		FILE_FMT_STR },
	{ XX("melong"),		FILE_MELONG,		FILE_FMT_NUM },
	{ XX("quad"),		FILE_QUAD,		FILE_FMT_QUAD },
	{ XX("lequad"),		FILE_LEQUAD,		FILE_FMT_QUAD },
	{ XX("bequad"),		FILE_BEQUAD,		FILE_FMT_QUAD },
	{ XX("qdate"),		FILE_QDATE,		FILE_FMT_STR },
	{ XX("leqdate"),	FILE_LEQDATE,		FILE_FMT_STR },
	{ XX("beqdate"),	FILE_BEQDATE,		FILE_FMT_STR },
	{ XX("qldate"),		FILE_QLDATE,		FILE_FMT_STR },
	{ XX("leqldate"),	FILE_LEQLDATE,		FILE_FMT_STR },
	{ XX("beqldate"),	FILE_BEQLDATE,		FILE_FMT_STR },
	{ XX("float"),		FILE_FLOAT,		FILE_FMT_FLOAT },
	{ XX("befloat"),	FILE_BEFLOAT,		FILE_FMT_FLOAT },
	{ XX("lefloat"),	FILE_LEFLOAT,		FILE_FMT_FLOAT },
	{ XX("double"),		FILE_DOUBLE,		FILE_FMT_DOUBLE },
	{ XX("bedouble"),	FILE_BEDOUBLE,		FILE_FMT_DOUBLE },
	{ XX("ledouble"),	FILE_LEDOUBLE,		FILE_FMT_DOUBLE },
	{ XX_NULL,		FILE_INVALID,		FILE_FMT_NONE },
# undef XX
# undef XX_NULL
};

private int
get_type(const char *l, const char **t)
{
	const struct type_tbl_s *p;

	for (p = type_tbl; p->len; p++) {
		if (strncmp(l, p->name, p->len) == 0) {
			if (t)
				*t = l + p->len;
			break;
		}
	}
	return p->type;
}

private void
init_file_tables(void)
{
	static int done = 0;
	const struct type_tbl_s *p;

	if (done)
		return;
	done++;

	for (p = type_tbl; p->len; p++) {
		assert(p->type < FILE_NAMES_SIZE);
		file_names[p->type] = p->name;
		file_formats[p->type] = p->format;
	}
}

/*
 * Handle one file or directory.
 */
private int
apprentice_1(struct magic_set *ms, const char *fn, int action,
    struct mlist *mlist)
{
	struct magic *magic = NULL;
	uint32_t nmagic = 0;
	struct mlist *ml;
	int rv = -1;
	int mapped;

	if (magicsize != FILE_MAGICSIZE) {
		file_error(ms, 0, "magic element size %lu != %lu",
		    (unsigned long)sizeof(*magic),
		    (unsigned long)FILE_MAGICSIZE);
		return -1;
	}

	if (action == FILE_COMPILE) {
		rv = apprentice_load(ms, &magic, &nmagic, fn, action);
		if (rv != 0)
			return -1;
		rv = apprentice_compile(ms, &magic, &nmagic, fn);
		free(magic);
		return rv;
	}

#ifndef COMPILE_ONLY
	if ((rv = apprentice_map(ms, &magic, &nmagic, fn)) == -1) {
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "using regular magic file `%s'", fn);
		rv = apprentice_load(ms, &magic, &nmagic, fn, action);
		if (rv != 0)
			return -1;
	}

	mapped = rv;
	     
	if (magic == NULL) {
		file_delmagic(magic, mapped, nmagic);
		return -1;
	}

	if ((ml = malloc(sizeof(*ml))) == NULL) {
		file_delmagic(magic, mapped, nmagic);
		file_oomem(ms, sizeof(*ml));
		return -1;
	}

	ml->magic = magic;
	ml->nmagic = nmagic;
	ml->mapped = mapped;

	mlist->prev->next = ml;
	ml->prev = mlist->prev;
	ml->next = mlist;
	mlist->prev = ml;

	return 0;
#endif /* COMPILE_ONLY */
}

protected void
file_delmagic(struct magic *p, int type, size_t entries)
{
	if (p == NULL)
		return;
	switch (type) {
#ifdef QUICK
	case 2:
		p--;
		(void)munmap((void *)p, sizeof(*p) * (entries + 1));
		break;
#endif
	case 1:
		p--;
		/*FALLTHROUGH*/
	case 0:
		free(p);
		break;
	default:
		abort();
	}
}

/* const char *fn: list of magic files and directories */
protected struct mlist *
file_apprentice(struct magic_set *ms, const char *fn, int action)
{
	char *p, *mfn;
	int file_err, errs = -1;
	struct mlist *mlist;

	init_file_tables();

	if (fn == NULL)
		fn = getenv("MAGIC");
	if (fn == NULL)
		fn = MAGIC;

	if ((mfn = strdup(fn)) == NULL) {
		file_oomem(ms, strlen(fn));
		return NULL;
	}
	fn = mfn;

	if ((mlist = malloc(sizeof(*mlist))) == NULL) {
		free(mfn);
		file_oomem(ms, sizeof(*mlist));
		return NULL;
	}
	mlist->next = mlist->prev = mlist;

	while (fn) {
		p = strchr(fn, PATHSEP);
		if (p)
			*p++ = '\0';
		if (*fn == '\0')
			break;
		file_err = apprentice_1(ms, fn, action, mlist);
		errs = MAX(errs, file_err);
		fn = p;
	}
	if (errs == -1) {
		free(mfn);
		free(mlist);
		mlist = NULL;
		file_error(ms, 0, "could not find any magic files!");
		return NULL;
	}
	free(mfn);
	return mlist;
}

/*
 * Get weight of this magic entry, for sorting purposes.
 */
private size_t
apprentice_magic_strength(const struct magic *m)
{
#define MULT 10
	size_t val = 2 * MULT;	/* baseline strength */

	switch (m->type) {
	case FILE_DEFAULT:	/* make sure this sorts last */
		return 0;

	case FILE_BYTE:
		val += 1 * MULT;
		break;

	case FILE_SHORT:
	case FILE_LESHORT:
	case FILE_BESHORT:
		val += 2 * MULT;
		break;

	case FILE_LONG:
	case FILE_LELONG:
	case FILE_BELONG:
	case FILE_MELONG:
		val += 4 * MULT;
		break;

	case FILE_PSTRING:
	case FILE_STRING:
		val += m->vallen * MULT;
		break;

	case FILE_BESTRING16:
	case FILE_LESTRING16:
		val += m->vallen * MULT / 2;
		break;

	case FILE_SEARCH:
	case FILE_REGEX:
		val += m->vallen * MAX(MULT / m->vallen, 1);
		break;

	case FILE_DATE:
	case FILE_LEDATE:
	case FILE_BEDATE:
	case FILE_MEDATE:
	case FILE_LDATE:
	case FILE_LELDATE:
	case FILE_BELDATE:
	case FILE_MELDATE:
	case FILE_FLOAT:
	case FILE_BEFLOAT:
	case FILE_LEFLOAT:
		val += 4 * MULT;
		break;

	case FILE_QUAD:
	case FILE_BEQUAD:
	case FILE_LEQUAD:
	case FILE_QDATE:
	case FILE_LEQDATE:
	case FILE_BEQDATE:
	case FILE_QLDATE:
	case FILE_LEQLDATE:
	case FILE_BEQLDATE:
	case FILE_DOUBLE:
	case FILE_BEDOUBLE:
	case FILE_LEDOUBLE:
		val += 8 * MULT;
		break;

	default:
		val = 0;
		(void)fprintf(stderr, "Bad type %d\n", m->type);
		abort();
	}

	switch (m->reln) {
	case 'x':	/* matches anything penalize */
	case '!':       /* matches almost anything penalize */
		val = 0;
		break;

	case '=':	/* Exact match, prefer */
		val += MULT;
		break;

	case '>':
	case '<':	/* comparison match reduce strength */
		val -= 2 * MULT;
		break;

	case '^':
	case '&':	/* masking bits, we could count them too */
		val -= MULT;
		break;

	default:
		(void)fprintf(stderr, "Bad relation %c\n", m->reln);
		abort();
	}

	if (val == 0)	/* ensure we only return 0 for FILE_DEFAULT */
		val = 1;

	return val;
}

/*  
 * Sort callback for sorting entries by "strength" (basically length)
 */
private int
apprentice_sort(const void *a, const void *b)
{
	const struct magic_entry *ma = a;
	const struct magic_entry *mb = b;
	size_t sa = apprentice_magic_strength(ma->mp);
	size_t sb = apprentice_magic_strength(mb->mp);
	if (sa == sb)
		return 0;
	else if (sa > sb)
		return -1;
	else
		return 1;
}

private void
set_test_type(struct magic *mstart, struct magic *m)
{
	switch (m->type) {
	case FILE_BYTE:
	case FILE_SHORT:
	case FILE_LONG:
	case FILE_DATE:
	case FILE_BESHORT:
	case FILE_BELONG:
	case FILE_BEDATE:
	case FILE_LESHORT:
	case FILE_LELONG:
	case FILE_LEDATE:
	case FILE_LDATE:
	case FILE_BELDATE:
	case FILE_LELDATE:
	case FILE_MEDATE:
	case FILE_MELDATE:
	case FILE_MELONG:
	case FILE_QUAD:
	case FILE_LEQUAD:
	case FILE_BEQUAD:
	case FILE_QDATE:
	case FILE_LEQDATE:
	case FILE_BEQDATE:
	case FILE_QLDATE:
	case FILE_LEQLDATE:
	case FILE_BEQLDATE:
	case FILE_FLOAT:
	case FILE_BEFLOAT:
	case FILE_LEFLOAT:
	case FILE_DOUBLE:
	case FILE_BEDOUBLE:
	case FILE_LEDOUBLE:
	case FILE_STRING:
	case FILE_PSTRING:
	case FILE_BESTRING16:
	case FILE_LESTRING16:
		/* binary test, set flag */
		mstart->flag |= BINTEST;
		break;
	case FILE_REGEX:
	case FILE_SEARCH:
		/* binary test if pattern is not text */
		if (file_looks_utf8(m->value.s, m->vallen, NULL, NULL) == 0)
			mstart->flag |= BINTEST;
		break;
	case FILE_DEFAULT:
		/* can't deduce anything; we shouldn't see this at the
		   top level anyway */
		break;
	case FILE_INVALID:
	default:
		/* invalid search type, but no need to complain here */
		break;
	}
}

/*
 * Load and parse one file.
 */
private void
load_1(struct magic_set *ms, int action, const char *fn, int *errs,
   struct magic_entry **marray, uint32_t *marraycount)
{
	char line[BUFSIZ];
	size_t lineno = 0;
	FILE *f = fopen(ms->file = fn, "r");
	if (f == NULL) {
		if (errno != ENOENT)
			file_error(ms, errno, "cannot read magic file `%s'",
				   fn);
		(*errs)++;
	} else {
		/* read and parse this file */
		for (ms->line = 1; fgets(line, sizeof(line), f) != NULL; ms->line++) {
			size_t len;
			len = strlen(line);
			if (len == 0) /* null line, garbage, etc */
				continue;
			if (line[len - 1] == '\n') {
				lineno++;
				line[len - 1] = '\0'; /* delete newline */
			}
			if (line[0] == '\0')	/* empty, do not parse */
				continue;
			if (line[0] == '#')	/* comment, do not parse */
				continue;
			if (len > mime_marker_len &&
			    memcmp(line, mime_marker, mime_marker_len) == 0) {
				/* MIME type */
				if (parse_mime(ms, marray, marraycount,
					       line + mime_marker_len) != 0)
					(*errs)++;
				continue;
			}
			if (parse(ms, marray, marraycount, line, lineno, action) != 0)
				(*errs)++;
		}

		(void)fclose(f);
	}
}

/*
 * parse a file or directory of files
 * const char *fn: name of magic file or directory
 */
private int
apprentice_load(struct magic_set *ms, struct magic **magicp, uint32_t *nmagicp,
    const char *fn, int action)
{
	int errs = 0;
	struct magic_entry *marray;
	uint32_t marraycount, i, mentrycount = 0, starttest;
	char subfn[PATH_MAX];
	struct stat st;
	DIR *dir;
	struct dirent *d;

	ms->flags |= MAGIC_CHECK;	/* Enable checks for parsed files */

        maxmagic = MAXMAGIS;
	if ((marray = calloc(maxmagic, sizeof(*marray))) == NULL) {
		file_oomem2(ms, maxmagic, sizeof(*marray));
		return -1;
	}
	marraycount = 0;

	/* print silly verbose header for USG compat. */
	if (action == FILE_CHECK)
		(void)fprintf(stderr, "%s\n", usg_hdr);

	/* load directory or file */
	if (stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {
		dir = opendir(fn);
		if (dir) {
			while ((d = readdir(dir)) != NULL) {
				snprintf(subfn, sizeof(subfn), "%s/%s",
				    fn, d->d_name);
				if (stat(subfn, &st) == 0 && S_ISREG(st.st_mode)) {
					load_1(ms, action, subfn, &errs,
					    &marray, &marraycount);
				}
			}
			closedir(dir);
		} else
			errs++;
	} else
		load_1(ms, action, fn, &errs, &marray, &marraycount);
	if (errs)
		goto out;

	/* Set types of tests */
	for (i = 0; i < marraycount; ) {
		if (marray[i].mp->cont_level != 0) {
			i++;
			continue;
		}

		starttest = i;
		do {
			set_test_type(marray[starttest].mp, marray[i].mp);
			if (ms->flags & MAGIC_DEBUG) {
				(void)fprintf(stderr, "%s%s%s: %s\n",
					marray[i].mp->mimetype,
					marray[i].mp->mimetype[0] == '\0' ? "" : "; ",
					marray[i].mp->desc[0] ? marray[i].mp->desc : "(no description)",
					marray[i].mp->flag & BINTEST ? "binary" : "text");
				if (marray[i].mp->flag & BINTEST) {
#define SYMBOL "text"
#define SYMLEN sizeof(SYMBOL)
					char *p = strstr(marray[i].mp->desc, "text");
					if (p && (p == marray[i].mp->desc || isspace(p[-1])) &&
					    (p + SYMLEN - marray[i].mp->desc == MAXstring ||
					     (p[SYMLEN] == '\0' || isspace(p[SYMLEN])))) {
						(void)fprintf(stderr,
							      "*** Possible binary test for text type\n");
					}
#undef SYMBOL
#undef SYMLEN
				}
			}
		} while (++i < marraycount && marray[i].mp->cont_level != 0);
	}

	qsort(marray, marraycount, sizeof(*marray), apprentice_sort);

	/*
	 * Make sure that any level 0 "default" line is last (if one exists).
	 */
	for (i = 0; i < marraycount; i++) {
		if (marray[i].mp->cont_level == 0 &&
		    marray[i].mp->type == FILE_DEFAULT) {
			while (++i < marraycount)
				if (marray[i].mp->cont_level == 0)
					break;
			if (i != marraycount) {
				ms->line = marray[i].mp->lineno; /* XXX - Ugh! */
				file_magwarn(ms,
				    "level 0 \"default\" did not sort last");
			}
			break;					    
		}
	}

	for (i = 0; i < marraycount; i++)
		mentrycount += marray[i].cont_count;

	if ((*magicp = reallocarray(NULL, mentrycount, sizeof(**magicp))) == NULL) {
		file_oomem2(ms, mentrycount, sizeof(**magicp));
		errs++;
		goto out;
	}

	mentrycount = 0;
	for (i = 0; i < marraycount; i++) {
		(void)memcpy(*magicp + mentrycount, marray[i].mp,
		    marray[i].cont_count * sizeof(**magicp));
		mentrycount += marray[i].cont_count;
	}
out:
	for (i = 0; i < marraycount; i++)
		free(marray[i].mp);
	free(marray);
	if (errs) {
		*magicp = NULL;
		*nmagicp = 0;
		return errs;
	} else {
		*nmagicp = mentrycount;
		return 0;
	}

}

/*
 * extend the sign bit if the comparison is to be signed
 */
protected uint64_t
file_signextend(struct magic_set *ms, struct magic *m, uint64_t v)
{
	if (!(m->flag & UNSIGNED)) {
		switch(m->type) {
		/*
		 * Do not remove the casts below.  They are
		 * vital.  When later compared with the data,
		 * the sign extension must have happened.
		 */
		case FILE_BYTE:
			v = (char) v;
			break;
		case FILE_SHORT:
		case FILE_BESHORT:
		case FILE_LESHORT:
			v = (short) v;
			break;
		case FILE_DATE:
		case FILE_BEDATE:
		case FILE_LEDATE:
		case FILE_MEDATE:
		case FILE_LDATE:
		case FILE_BELDATE:
		case FILE_LELDATE:
		case FILE_MELDATE:
		case FILE_LONG:
		case FILE_BELONG:
		case FILE_LELONG:
		case FILE_MELONG:
		case FILE_FLOAT:
		case FILE_BEFLOAT:
		case FILE_LEFLOAT:
			v = (int32_t) v;
			break;
		case FILE_QUAD:
		case FILE_BEQUAD:
		case FILE_LEQUAD:
		case FILE_QDATE:
		case FILE_QLDATE:
		case FILE_BEQDATE:
		case FILE_BEQLDATE:
		case FILE_LEQDATE:
		case FILE_LEQLDATE:
		case FILE_DOUBLE:
		case FILE_BEDOUBLE:
		case FILE_LEDOUBLE:
			v = (int64_t) v;
			break;
		case FILE_STRING:
		case FILE_PSTRING:
		case FILE_BESTRING16:
		case FILE_LESTRING16:
		case FILE_REGEX:
		case FILE_SEARCH:
		case FILE_DEFAULT:
			break;
		default:
			if (ms->flags & MAGIC_CHECK)
			    file_magwarn(ms, "cannot happen: m->type=%d\n",
				    m->type);
			return ~0U;
		}
	}
	return v;
}

private int
string_modifier_check(struct magic_set *ms, struct magic *m)
{
	if ((ms->flags & MAGIC_CHECK) == 0)
		return 0;

	switch (m->type) {
	case FILE_BESTRING16:
	case FILE_LESTRING16:
		if (m->str_flags != 0) {
			file_magwarn(ms,
			    "no modifiers allowed for 16-bit strings\n");
			return -1;
		}
		break;
	case FILE_STRING:
	case FILE_PSTRING:
		if ((m->str_flags & REGEX_OFFSET_START) != 0) {
			file_magwarn(ms,
			    "'/%c' only allowed on regex and search\n",
			    CHAR_REGEX_OFFSET_START);
			return -1;
		}
		break;
	case FILE_SEARCH:
		if (m->str_range == 0) {
			file_magwarn(ms,
			    "missing range; defaulting to %d\n",
                            STRING_DEFAULT_RANGE);
			m->str_range = STRING_DEFAULT_RANGE;
			return -1;
		}
		break;
	case FILE_REGEX:
		if ((m->str_flags & STRING_COMPACT_BLANK) != 0) {
			file_magwarn(ms, "'/%c' not allowed on regex\n",
			    CHAR_COMPACT_BLANK);
			return -1;
		}
		if ((m->str_flags & STRING_COMPACT_OPTIONAL_BLANK) != 0) {
			file_magwarn(ms, "'/%c' not allowed on regex\n",
			    CHAR_COMPACT_OPTIONAL_BLANK);
			return -1;
		}
		break;
	default:
		file_magwarn(ms, "coding error: m->type=%d\n",
		    m->type);
		return -1;
	}
	return 0;
}

private int
get_op(char c)
{
	switch (c) {
	case '&':
		return FILE_OPAND;
	case '|':
		return FILE_OPOR;
	case '^':
		return FILE_OPXOR;
	case '+':
		return FILE_OPADD;
	case '-':
		return FILE_OPMINUS;
	case '*':
		return FILE_OPMULTIPLY;
	case '/':
		return FILE_OPDIVIDE;
	case '%':
		return FILE_OPMODULO;
	default:
		return -1;
	}
}

#ifdef ENABLE_CONDITIONALS
private int
get_cond(const char *l, const char **t)
{
	static const struct cond_tbl_s {
		char name[8];
		size_t len;
		int cond;
	} cond_tbl[] = {
		{ "if",		2,	COND_IF },
		{ "elif",	4,	COND_ELIF },
		{ "else",	4,	COND_ELSE },
		{ "",		0,	COND_NONE },
	};
	const struct cond_tbl_s *p;

	for (p = cond_tbl; p->len; p++) {
		if (strncmp(l, p->name, p->len) == 0 &&
		    isspace((unsigned char)l[p->len])) {
			if (t)
				*t = l + p->len;
			break;
		}
	}
	return p->cond;
}

private int
check_cond(struct magic_set *ms, int cond, uint32_t cont_level)
{
	int last_cond;
	last_cond = ms->c.li[cont_level].last_cond;

	switch (cond) {
	case COND_IF:
		if (last_cond != COND_NONE && last_cond != COND_ELIF) {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "syntax error: `if'");
			return -1;
		}
		last_cond = COND_IF;
		break;

	case COND_ELIF:
		if (last_cond != COND_IF && last_cond != COND_ELIF) {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "syntax error: `elif'");
			return -1;
		}
		last_cond = COND_ELIF;
		break;

	case COND_ELSE:
		if (last_cond != COND_IF && last_cond != COND_ELIF) {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "syntax error: `else'");
			return -1;
		}
		last_cond = COND_NONE;
		break;

	case COND_NONE:
		last_cond = COND_NONE;
		break;
	}

	ms->c.li[cont_level].last_cond = last_cond;
	return 0;
}
#endif /* ENABLE_CONDITIONALS */

/*
 * parse one line from magic file, put into magic[index++] if valid
 */
private int
parse(struct magic_set *ms, struct magic_entry **mentryp, uint32_t *nmentryp, 
    const char *line, size_t lineno, int action)
{
#ifdef ENABLE_CONDITIONALS
	static uint32_t last_cont_level = 0;
#endif
	size_t i;
	struct magic_entry *me;
	struct magic *m;
	const char *l = line;
	char *t;
	int op;
	uint32_t cont_level;

	cont_level = 0;

	while (*l == '>') {
		++l;		/* step over */
		cont_level++; 
	}
#ifdef ENABLE_CONDITIONALS
	if (cont_level == 0 || cont_level > last_cont_level)
		if (file_check_mem(ms, cont_level) == -1)
			return -1;
	last_cont_level = cont_level;
#endif

#define ALLOC_CHUNK	(size_t)10
#define ALLOC_INCR	(size_t)200

	if (cont_level != 0) {
		if (*nmentryp == 0) {
			file_error(ms, 0, "No current entry for continuation");
			return -1;
		}
		me = &(*mentryp)[*nmentryp - 1];
		if (me->cont_count == me->max_count) {
			struct magic *nm;
			size_t cnt = me->max_count + ALLOC_CHUNK;
			if ((nm = reallocarray(me->mp, cnt, sizeof(*nm))) 
			    == NULL) {
				file_oomem2(ms, cnt, sizeof(*nm));
				return -1;
			}
			me->mp = m = nm;
			me->max_count = cnt;
		}
		m = &me->mp[me->cont_count++];
		(void)memset(m, 0, sizeof(*m));
		m->cont_level = cont_level;
	} else {
		if (*nmentryp == maxmagic) {
			struct magic_entry *mp;

			maxmagic += ALLOC_INCR;
			if ((mp = reallocarray(*mentryp, maxmagic, 
			    sizeof(*mp))) == NULL) {
				file_oomem2(ms, maxmagic, sizeof(*mp));
				return -1;
			}
			(void)memset(&mp[*nmentryp], 0, sizeof(*mp) *
			    ALLOC_INCR);
			*mentryp = mp;
		}
		me = &(*mentryp)[*nmentryp];
		if (me->mp == NULL) {
			if ((m = reallocarray(NULL, ALLOC_CHUNK, sizeof(*m))) == NULL) {
				file_oomem2(ms, ALLOC_CHUNK, sizeof(*m));
				return -1;
			}
			me->mp = m;
			me->max_count = ALLOC_CHUNK;
		} else
			m = me->mp;
		(void)memset(m, 0, sizeof(*m));
		m->cont_level = 0;
		me->cont_count = 1;
	}
	m->lineno = lineno;

	if (*l == '&') {  /* m->cont_level == 0 checked below. */
                ++l;            /* step over */
                m->flag |= OFFADD;
        }
	if (*l == '(') {
		++l;		/* step over */
		m->flag |= INDIR;
		if (m->flag & OFFADD)
			m->flag = (m->flag & ~OFFADD) | INDIROFFADD;

		if (*l == '&') {  /* m->cont_level == 0 checked below */
			++l;            /* step over */
			m->flag |= OFFADD;
		}
	}
	/* Indirect offsets are not valid at level 0. */
	if (m->cont_level == 0 && (m->flag & (OFFADD | INDIROFFADD)))
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "relative offset at level 0");

	/* get offset, then skip over it */
	m->offset = (uint32_t)strtoul(l, &t, 0);
        if (l == t)
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "offset `%s' invalid", l);
        l = t;

	if (m->flag & INDIR) {
		m->in_type = FILE_LONG;
		m->in_offset = 0;
		/*
		 * read [.lbs][+-]nnnnn)
		 */
		if (*l == '.') {
			l++;
			switch (*l) {
			case 'l':
				m->in_type = FILE_LELONG;
				break;
			case 'L':
				m->in_type = FILE_BELONG;
				break;
			case 'm':
				m->in_type = FILE_MELONG;
				break;
			case 'h':
			case 's':
				m->in_type = FILE_LESHORT;
				break;
			case 'H':
			case 'S':
				m->in_type = FILE_BESHORT;
				break;
			case 'c':
			case 'b':
			case 'C':
			case 'B':
				m->in_type = FILE_BYTE;
				break;
			case 'e':
			case 'f':
			case 'g':
				m->in_type = FILE_LEDOUBLE;
				break;
			case 'E':
			case 'F':
			case 'G':
				m->in_type = FILE_BEDOUBLE;
				break;
			default:
				if (ms->flags & MAGIC_CHECK)
					file_magwarn(ms,
					    "indirect offset type `%c' invalid",
					    *l);
				break;
			}
			l++;
		}

		m->in_op = 0;
		if (*l == '~') {
			m->in_op |= FILE_OPINVERSE;
			l++;
		}
		if ((op = get_op(*l)) != -1) {
			m->in_op |= op;
			l++;
		}
		if (*l == '(') {
			m->in_op |= FILE_OPINDIRECT;
			l++;
		}
		if (isdigit((unsigned char)*l) || *l == '-') {
			m->in_offset = (int32_t)strtol(l, &t, 0);
			if (l == t)
				if (ms->flags & MAGIC_CHECK)
					file_magwarn(ms,
					    "in_offset `%s' invalid", l);
			l = t;
		}
		if (*l++ != ')' || 
		    ((m->in_op & FILE_OPINDIRECT) && *l++ != ')'))
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms,
				    "missing ')' in indirect offset");
	}
	EATAB;

#ifdef ENABLE_CONDITIONALS
	m->cond = get_cond(l, &l);
	if (check_cond(ms, m->cond, cont_level) == -1)
		return -1;

	EATAB;
#endif

	if (*l == 'u') {
		++l;
		m->flag |= UNSIGNED;
	}

	m->type = get_type(l, &l);
	if (m->type == FILE_INVALID) {
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "type `%s' invalid", l);
		return -1;
	}

	/* New-style anding: "0 byte&0x80 =0x80 dynamically linked" */
	/* New and improved: ~ & | ^ + - * / % -- exciting, isn't it? */

	m->mask_op = 0;
	if (*l == '~') {
		if (!IS_STRING(m->type))
			m->mask_op |= FILE_OPINVERSE;
		else if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "'~' invalid for string types");
		++l;
	}
	m->str_range = 0;
	m->str_flags = 0;
	m->num_mask = 0;
	if ((op = get_op(*l)) != -1) {
		if (!IS_STRING(m->type)) {
			uint64_t val;
			++l;
			m->mask_op |= op;
			val = (uint64_t)strtoull(l, &t, 0);
			l = t;
			m->num_mask = file_signextend(ms, m, val);
			eatsize(&l);
		}
		else if (op == FILE_OPDIVIDE) {
			int have_range = 0;
			while (!isspace((unsigned char)*++l)) {
				switch (*l) {
				case '0':  case '1':  case '2':
				case '3':  case '4':  case '5':
				case '6':  case '7':  case '8':
				case '9':
					if (have_range &&
					    (ms->flags & MAGIC_CHECK))
						file_magwarn(ms,
						    "multiple ranges");
					have_range = 1;
					m->str_range = strtoul(l, &t, 0);
					if (m->str_range == 0)
						file_magwarn(ms,
						    "zero range");
					l = t - 1;
					break;
				case CHAR_COMPACT_BLANK:
					m->str_flags |= STRING_COMPACT_BLANK;
					break;
				case CHAR_COMPACT_OPTIONAL_BLANK:
					m->str_flags |=
					    STRING_COMPACT_OPTIONAL_BLANK;
					break;
				case CHAR_IGNORE_LOWERCASE:
					m->str_flags |= STRING_IGNORE_LOWERCASE;
					break;
				case CHAR_IGNORE_UPPERCASE:
					m->str_flags |= STRING_IGNORE_UPPERCASE;
					break;
				case CHAR_REGEX_OFFSET_START:
					m->str_flags |= REGEX_OFFSET_START;
					break;
				default:
					if (ms->flags & MAGIC_CHECK)
						file_magwarn(ms,
						"string extension `%c' invalid",
						*l);
					return -1;
				}
				/* allow multiple '/' for readability */
				if (l[1] == '/' &&
				    !isspace((unsigned char)l[2]))
					l++;
			}
			if (string_modifier_check(ms, m) == -1)
				return -1;
		}
		else {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "invalid string op: %c", *t);
			return -1;
		}
	}
	/*
	 * We used to set mask to all 1's here, instead let's just not do
	 * anything if mask = 0 (unless you have a better idea)
	 */
	EATAB;
  
	switch (*l) {
	case '>':
	case '<':
	/* Old-style anding: "0 byte &0x80 dynamically linked" */
	case '&':
	case '^':
	case '=':
  		m->reln = *l;
  		++l;
		if (*l == '=') {
		   /* HP compat: ignore &= etc. */
		   ++l;
		}
		break;
	case '!':
		m->reln = *l;
		++l;
		break;
	default:
  		m->reln = '=';	/* the default relation */
		if (*l == 'x' && ((isascii((unsigned char)l[1]) && 
		    isspace((unsigned char)l[1])) || !l[1])) {
			m->reln = *l;
			++l;
		}
		break;
	}
	/*
	 * Grab the value part, except for an 'x' reln.
	 */
	if (m->reln != 'x' && getvalue(ms, m, &l, action))
		return -1;

	/*
	 * TODO finish this macro and start using it!
	 * #define offsetcheck {if (offset > HOWMANY-1) 
	 *	magwarn("offset too big"); }
	 */

	/*
	 * Now get last part - the description
	 */
	EATAB;
	if (l[0] == '\b') {
		++l;
		m->flag |= NOSPACE;
	} else if ((l[0] == '\\') && (l[1] == 'b')) {
		++l;
		++l;
		m->flag |= NOSPACE;
	}
	for (i = 0; (m->desc[i++] = *l++) != '\0' && i < sizeof(m->desc); )
		continue;
	if (i == sizeof(m->desc)) {
		m->desc[sizeof(m->desc) - 1] = '\0';
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "description `%s' truncated", m->desc);
	}

        /*
	 * We only do this check while compiling, or if any of the magic
	 * files were not compiled.
         */
        if (ms->flags & MAGIC_CHECK) {
		if (check_format(ms, m) == -1)
			return -1;
	}
#ifndef COMPILE_ONLY
	if (action == FILE_CHECK) {
		file_mdump(m);
	}
#endif
	m->mimetype[0] = '\0';		/* initialise MIME type to none */
	if (m->cont_level == 0)
		++(*nmentryp);		/* make room for next */
	return 0;
}

/*
 * parse a MIME annotation line from magic file, put into magic[index - 1]
 * if valid
 */
private int
parse_mime(struct magic_set *ms, struct magic_entry **mentryp,
    uint32_t *nmentryp, const char *line)
{
	size_t i;
	const char *l = line;
	struct magic *m;
	struct magic_entry *me;

	if (*nmentryp == 0) {
		file_error(ms, 0, "No current entry for MIME type");
		return -1;
	}

	me = &(*mentryp)[*nmentryp - 1];
	m = &me->mp[me->cont_count == 0 ? 0 : me->cont_count - 1];

	if (m->mimetype[0] != '\0') {
		file_error(ms, 0, "Current entry already has a MIME type: %s\n"
		    "Description: %s\nNew type: %s", m->mimetype, m->desc, l);
		return -1;
	}	

	EATAB;
	for (i = 0;
	     *l && ((isascii((unsigned char)*l) && isalnum((unsigned char)*l))
	     || strchr("-+/.", *l)) && i < sizeof(m->mimetype);
	     m->mimetype[i++] = *l++)
		continue;
	if (i == sizeof(m->mimetype)) {
		m->desc[sizeof(m->mimetype) - 1] = '\0';
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, "MIME type `%s' truncated %zu",
			    m->mimetype, i);
	} else
		m->mimetype[i] = '\0';

	if (i > 0)
		return 0;
	else
		return -1;
}

private int
check_format_type(const char *ptr, int type)
{
	int quad = 0;
	if (*ptr == '\0') {
		/* Missing format string; bad */
		return -1;
	}

	switch (type) {
	case FILE_FMT_QUAD:
		quad = 1;
		/*FALLTHROUGH*/
	case FILE_FMT_NUM:
		if (*ptr == '-')
			ptr++;
		if (*ptr == '.')
			ptr++;
		while (isdigit((unsigned char)*ptr)) ptr++;
		if (*ptr == '.')
			ptr++;
		while (isdigit((unsigned char)*ptr)) ptr++;
		if (quad) {
			if (*ptr++ != 'l')
				return -1;
			if (*ptr++ != 'l')
				return -1;
		}
	
		switch (*ptr++) {
		case 'l':
			switch (*ptr++) {
			case 'i':
			case 'd':
			case 'u':
			case 'x':
			case 'X':
				return 0;
			default:
				return -1;
			}
		
		case 'h':
			switch (*ptr++) {
			case 'h':
				switch (*ptr++) {
				case 'i':
				case 'd':
				case 'u':
				case 'x':
				case 'X':
					return 0;
				default:
					return -1;
				}
			case 'd':
				return 0;
			default:
				return -1;
			}

		case 'i':
		case 'c':
		case 'd':
		case 'u':
		case 'x':
		case 'X':
			return 0;
			
		default:
			return -1;
		}
		
	case FILE_FMT_FLOAT:
	case FILE_FMT_DOUBLE:
		if (*ptr == '-')
			ptr++;
		if (*ptr == '.')
			ptr++;
		while (isdigit((unsigned char)*ptr)) ptr++;
		if (*ptr == '.')
			ptr++;
		while (isdigit((unsigned char)*ptr)) ptr++;
	
		switch (*ptr++) {
		case 'e':
		case 'E':
		case 'f':
		case 'F':
		case 'g':
		case 'G':
			return 0;
			
		default:
			return -1;
		}
		

	case FILE_FMT_STR:
		if (*ptr == '-')
			ptr++;
		while (isdigit((unsigned char )*ptr))
			ptr++;
		if (*ptr == '.') {
			ptr++;
			while (isdigit((unsigned char )*ptr))
				ptr++;
		}
		
		switch (*ptr++) {
		case 's':
			return 0;
		default:
			return -1;
		}
		
	default:
		/* internal error */
		abort();
	}
	/*NOTREACHED*/
	return -1;
}
	
/*
 * Check that the optional printf format in description matches
 * the type of the magic.
 */
private int
check_format(struct magic_set *ms, struct magic *m)
{
	char *ptr;

	for (ptr = m->desc; *ptr; ptr++)
		if (*ptr == '%')
			break;
	if (*ptr == '\0') {
		/* No format string; ok */
		return 1;
	}

	assert(file_nformats == file_nnames);

	if (m->type >= file_nformats) {
		file_magwarn(ms, "Internal error inconsistency between "
		    "m->type and format strings");		
		return -1;
	}
	if (file_formats[m->type] == FILE_FMT_NONE) {
		file_magwarn(ms, "No format string for `%s' with description "
		    "`%s'", m->desc, file_names[m->type]);
		return -1;
	}

	ptr++;
	if (check_format_type(ptr, file_formats[m->type]) == -1) {
		/*
		 * TODO: this error message is unhelpful if the format
		 * string is not one character long
		 */
		file_magwarn(ms, "Printf format `%c' is not valid for type "
		    "`%s' in description `%s'",
		    ptr && *ptr ? *ptr : '?',
		    file_names[m->type], m->desc);
		return -1;
	}
	
	for (; *ptr; ptr++) {
		if (*ptr == '%') {
			file_magwarn(ms,
			    "Too many format strings (should have at most one) "
			    "for `%s' with description `%s'",
			    file_names[m->type], m->desc);
			return -1;
		}
	}
	return 0;
}

/* 
 * Read a numeric value from a pointer, into the value union of a magic 
 * pointer, according to the magic type.  Update the string pointer to point 
 * just after the number read.  Return 0 for success, non-zero for failure.
 */
private int
getvalue(struct magic_set *ms, struct magic *m, const char **p, int action)
{
	int slen;

	switch (m->type) {
	case FILE_BESTRING16:
	case FILE_LESTRING16:
	case FILE_STRING:
	case FILE_PSTRING:
	case FILE_REGEX:
	case FILE_SEARCH:
		*p = getstr(ms, *p, m->value.s, sizeof(m->value.s), &slen, action);
		if (*p == NULL) {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, "cannot get string from `%s'",
				    m->value.s);
			return -1;
		}
		m->vallen = slen;
		if (m->type == FILE_PSTRING)
			m->vallen++;
		return 0;
	case FILE_FLOAT:
	case FILE_BEFLOAT:
	case FILE_LEFLOAT:
		if (m->reln != 'x') {
			char *ep;
#ifdef HAVE_STRTOF
			m->value.f = strtof(*p, &ep);
#else
			m->value.f = (float)strtod(*p, &ep);
#endif
			*p = ep;
		}
		return 0;
	case FILE_DOUBLE:
	case FILE_BEDOUBLE:
	case FILE_LEDOUBLE:
		if (m->reln != 'x') {
			char *ep;
			m->value.d = strtod(*p, &ep);
			*p = ep;
		}
		return 0;
	default:
		if (m->reln != 'x') {
			char *ep;
			m->value.q = file_signextend(ms, m,
			    (uint64_t)strtoull(*p, &ep, 0));
			*p = ep;
			eatsize(p);
		}
		return 0;
	}
}

/*
 * Convert a string containing C character escapes.  Stop at an unescaped
 * space or tab.
 * Copy the converted version to "p", returning its length in *slen.
 * Return updated scan pointer as function result.
 */
private const char *
getstr(struct magic_set *ms, const char *s, char *p, int plen, int *slen, int action)
{
	const char *origs = s;
	char 	*origp = p;
	char	*pmax = p + plen - 1;
	int	c;
	int	val;

	while ((c = *s++) != '\0') {
		if (isspace((unsigned char) c))
			break;
		if (p >= pmax) {
			file_error(ms, 0, "string too long: `%s'", origs);
			return NULL;
		}
		if (c == '\\') {
			switch(c = *s++) {

			case '\0':
				if (action == FILE_COMPILE)
					file_magwarn(ms, "incomplete escape");
				goto out;

			case '\t':
				if (action == FILE_COMPILE) {
					file_magwarn(ms,
					    "escaped tab found, use \\t instead");
					action++;
				}
				/*FALLTHROUGH*/
			default:
				if (action == FILE_COMPILE) {
					if (isprint((unsigned char)c))
					    file_magwarn(ms,
						"no need to escape `%c'", c);
					else
					    file_magwarn(ms,
						"unknown escape sequence: \\%03o", c);
				}
				/*FALLTHROUGH*/
			/* space, perhaps force people to use \040? */
			case ' ':
#if 0
			/*
			 * Other things people escape, but shouldn't need to,
			 * so we disallow them
			 */
			case '\'':
			case '"':
			case '?':
#endif
			/* Relations */
			case '>':
			case '<':
			case '&':
			case '^':
			case '=':
			case '!':
			/* and baskslash itself */
			case '\\':
				*p++ = (char) c;
				break;

			case 'a':
				*p++ = '\a';
				break;

			case 'b':
				*p++ = '\b';
				break;

			case 'f':
				*p++ = '\f';
				break;

			case 'n':
				*p++ = '\n';
				break;

			case 'r':
				*p++ = '\r';
				break;

			case 't':
				*p++ = '\t';
				break;

			case 'v':
				*p++ = '\v';
				break;

			/* \ and up to 3 octal digits */
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
				val = c - '0';
				c = *s++;  /* try for 2 */
				if (c >= '0' && c <= '7') {
					val = (val << 3) | (c - '0');
					c = *s++;  /* try for 3 */
					if (c >= '0' && c <= '7')
						val = (val << 3) | (c-'0');
					else
						--s;
				}
				else
					--s;
				*p++ = (char)val;
				break;

			/* \x and up to 2 hex digits */
			case 'x':
				val = 'x';	/* Default if no digits */
				c = hextoint(*s++);	/* Get next char */
				if (c >= 0) {
					val = c;
					c = hextoint(*s++);
					if (c >= 0)
						val = (val << 4) + c;
					else
						--s;
				} else
					--s;
				*p++ = (char)val;
				break;
			}
		} else
			*p++ = (char)c;
	}
out:
	*p = '\0';
	*slen = p - origp;
	return s;
}


/* Single hex char to int; -1 if not a hex char. */
private int
hextoint(int c)
{
	if (!isascii((unsigned char) c))
		return -1;
	if (isdigit((unsigned char) c))
		return c - '0';
	if ((c >= 'a') && (c <= 'f'))
		return c + 10 - 'a';
	if (( c>= 'A') && (c <= 'F'))
		return c + 10 - 'A';
	return -1;
}


/*
 * Print a string containing C character escapes.
 */
protected void
file_showstr(FILE *fp, const char *s, size_t len)
{
	char	c;

	for (;;) {
		c = *s++;
		if (len == ~0U) {
			if (c == '\0')
				break;
		}
		else  {
			if (len-- == 0)
				break;
		}
		if (c >= 040 && c <= 0176)	/* TODO isprint && !iscntrl */
			(void) fputc(c, fp);
		else {
			(void) fputc('\\', fp);
			switch (c) {
			case '\a':
				(void) fputc('a', fp);
				break;

			case '\b':
				(void) fputc('b', fp);
				break;

			case '\f':
				(void) fputc('f', fp);
				break;

			case '\n':
				(void) fputc('n', fp);
				break;

			case '\r':
				(void) fputc('r', fp);
				break;

			case '\t':
				(void) fputc('t', fp);
				break;

			case '\v':
				(void) fputc('v', fp);
				break;

			default:
				(void) fprintf(fp, "%.3o", c & 0377);
				break;
			}
		}
	}
}

/*
 * eatsize(): Eat the size spec from a number [eg. 10UL]
 */
private void
eatsize(const char **p)
{
	const char *l = *p;

	if (LOWCASE(*l) == 'u') 
		l++;

	switch (LOWCASE(*l)) {
	case 'l':    /* long */
	case 's':    /* short */
	case 'h':    /* short */
	case 'b':    /* char/byte */
	case 'c':    /* char/byte */
		l++;
		/*FALLTHROUGH*/
	default:
		break;
	}

	*p = l;
}

/*
 * handle a compiled file.
 */
private int
apprentice_map(struct magic_set *ms, struct magic **magicp, uint32_t *nmagicp,
    const char *fn)
{
	int fd;
	struct stat st;
	uint32_t *ptr;
	uint32_t version;
	int needsbyteswap;
	char *dbname = NULL;
	void *mm = NULL;

	mkdbname(fn, &dbname, 0);
	if (dbname == NULL)
		goto error2;

	if ((fd = open(dbname, O_RDONLY|O_BINARY)) == -1)
		goto error2;

	if (fstat(fd, &st) == -1) {
		file_error(ms, errno, "cannot stat `%s'", dbname);
		goto error1;
	}
	if (st.st_size < 8 || st.st_size > SIZE_MAX) {
		file_error(ms, 0, "file `%s' is too %s", dbname,
		    st.st_size > SIZE_MAX ? "large" : "small");
		goto error1;
	}

#ifdef QUICK
	if ((mm = mmap(0, (size_t)st.st_size, PROT_READ|PROT_WRITE,
	    MAP_PRIVATE|MAP_FILE, fd, (off_t)0)) == MAP_FAILED) {
		file_error(ms, errno, "cannot map `%s'", dbname);
		goto error1;
	}
#define RET	2
#else
	if ((mm = malloc((size_t)st.st_size)) == NULL) {
		file_oomem(ms, (size_t)st.st_size);
		goto error1;
	}
	if (read(fd, mm, (size_t)st.st_size) != (size_t)st.st_size) {
		file_badread(ms);
		goto error1;
	}
#define RET	1
#endif
	*magicp = mm;
	(void)close(fd);
	fd = -1;
	ptr = (uint32_t *)(void *)*magicp;
	if (*ptr != MAGICNO) {
		if (swap4(*ptr) != MAGICNO) {
			file_error(ms, 0, "bad magic in `%s'");
			goto error1;
		}
		needsbyteswap = 1;
	} else
		needsbyteswap = 0;
	if (needsbyteswap)
		version = swap4(ptr[1]);
	else
		version = ptr[1];
	if (version != VERSIONNO) {
		file_error(ms, 0, "File %d.%d supports only %d version magic "
		    "files. `%s' is version %d", FILE_VERSION_MAJOR, patchlevel,
		    VERSIONNO, dbname, version);
		goto error1;
	}
	*nmagicp = (uint32_t)(st.st_size / sizeof(struct magic));
	if (*nmagicp > 0)
		(*nmagicp)--;
	(*magicp)++;
	if (needsbyteswap)
		byteswap(*magicp, *nmagicp);
	free(dbname);
	return RET;

error1:
	if (fd != -1)
		(void)close(fd);
	if (mm) {
#ifdef QUICK
		(void)munmap((void *)mm, (size_t)st.st_size);
#else
		free(mm);
#endif
	} else {
		*magicp = NULL;
		*nmagicp = 0;
	}
error2:
	free(dbname);
	return -1;
}

private const uint32_t ar[] = {
    MAGICNO, VERSIONNO
};
/*
 * handle an mmaped file.
 */
private int
apprentice_compile(struct magic_set *ms, struct magic **magicp,
    uint32_t *nmagicp, const char *fn)
{
	int fd;
	char *dbname;
	int rv = -1;

	mkdbname(fn, &dbname, 1);

	if (dbname == NULL) 
		goto out;

	if ((fd = open(dbname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0644)) == -1) {
		file_error(ms, errno, "cannot open `%s'", dbname);
		goto out;
	}

	if (write(fd, ar, sizeof(ar)) != (ssize_t)sizeof(ar)) {
		file_error(ms, errno, "error writing `%s'", dbname);
		goto out;
	}

	if (lseek(fd, (off_t)sizeof(struct magic), SEEK_SET)
	    != sizeof(struct magic)) {
		file_error(ms, errno, "error seeking `%s'", dbname);
		goto out;
	}

	if (write(fd, *magicp, (sizeof(struct magic) * *nmagicp)) 
	    != (ssize_t)(sizeof(struct magic) * *nmagicp)) {
		file_error(ms, errno, "error writing `%s'", dbname);
		goto out;
	}

	(void)close(fd);
	rv = 0;
out:
	free(dbname);
	return rv;
}

private const char ext[] = ".mgc";
/*
 * make a dbname
 */
private void
mkdbname(const char *fn, char **buf, int strip)
{
	if (strip) {
		const char *p;
		if ((p = strrchr(fn, '/')) != NULL)
			fn = ++p;
	}

	(void)asprintf(buf, "%s%s", fn, ext);
	if (*buf && strlen(*buf) > PATH_MAX) {
		free(*buf);
		*buf = NULL;
	}
}

/*
 * Byteswap an mmap'ed file if needed
 */
private void
byteswap(struct magic *magic, uint32_t nmagic)
{
	uint32_t i;
	for (i = 0; i < nmagic; i++)
		bs1(&magic[i]);
}

/*
 * swap a short
 */
private uint16_t
swap2(uint16_t sv)
{
	uint16_t rv;
	uint8_t *s = (uint8_t *)(void *)&sv; 
	uint8_t *d = (uint8_t *)(void *)&rv; 
	d[0] = s[1];
	d[1] = s[0];
	return rv;
}

/*
 * swap an int
 */
private uint32_t
swap4(uint32_t sv)
{
	uint32_t rv;
	uint8_t *s = (uint8_t *)(void *)&sv; 
	uint8_t *d = (uint8_t *)(void *)&rv; 
	d[0] = s[3];
	d[1] = s[2];
	d[2] = s[1];
	d[3] = s[0];
	return rv;
}

/*
 * swap a quad
 */
private uint64_t
swap8(uint64_t sv)
{
	uint64_t rv;
	uint8_t *s = (uint8_t *)(void *)&sv; 
	uint8_t *d = (uint8_t *)(void *)&rv; 
#if 0
	d[0] = s[3];
	d[1] = s[2];
	d[2] = s[1];
	d[3] = s[0];
	d[4] = s[7];
	d[5] = s[6];
	d[6] = s[5];
	d[7] = s[4];
#else
	d[0] = s[7];
	d[1] = s[6];
	d[2] = s[5];
	d[3] = s[4];
	d[4] = s[3];
	d[5] = s[2];
	d[6] = s[1];
	d[7] = s[0];
#endif
	return rv;
}

/*
 * byteswap a single magic entry
 */
private void
bs1(struct magic *m)
{
	m->cont_level = swap2(m->cont_level);
	m->offset = swap4((uint32_t)m->offset);
	m->in_offset = swap4((uint32_t)m->in_offset);
	m->lineno = swap4((uint32_t)m->lineno);
	if (IS_STRING(m->type)) {
		m->str_range = swap4(m->str_range);
		m->str_flags = swap4(m->str_flags);
	}
	else {
		m->value.q = swap8(m->value.q);
		m->num_mask = swap8(m->num_mask);
	}
}
@


1.34
log
@Add missing <limits.h> to file.c and remove definition of PATH_MAX
which masked the missing include.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.33 2015/01/16 08:24:04 doug Exp $ */
@


1.33
log
@Replace <sys/param.h> with <limits.h>

This patch is from Theo.  I helped verify that removing <sys/param.h>
doesn't change anything.

This produces the same binaries before and after with clang 3.5 and gcc
4.9.4 on amd64.  There is a slight difference in the way it is generated by
our old gcc 4.2.1 despite the fact that the preprocessed input is almost
identical.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.32 2014/10/26 04:10:26 brad Exp $ */
a73 4
#endif

#ifndef PATH_MAX
#define PATH_MAX	1024
@


1.32
log
@Place additional parantheses around readdir() and check return does not
equal NULL.

apprentice.c:645:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]

With input and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.31 2014/05/18 17:50:11 espie Exp $ */
d33 1
a33 1
#include <sys/param.h>
d76 2
a77 2
#ifndef MAXPATHLEN
#define MAXPATHLEN	1024
d623 1
a623 1
	char subfn[MAXPATHLEN];
d2037 1
a2037 1
	if (*buf && strlen(*buf) > MAXPATHLEN) {
@


1.31
log
@use reallocarray
okay ian@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.30 2014/01/16 21:45:33 tobias Exp $ */
d645 1
a645 1
			while (d = readdir(dir)) {
@


1.30
log
@Avoid size_t overflow in apprentice_map.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.29 2009/11/11 16:21:51 jsg Exp $ */
d632 1
a632 1
		file_oomem(ms, maxmagic * sizeof(*marray));
d717 2
a718 2
	if ((*magicp = malloc(sizeof(**magicp) * mentrycount)) == NULL) {
		file_oomem(ms, sizeof(**magicp) * mentrycount);
d1006 3
a1008 2
			if ((nm = realloc(me->mp, sizeof(*nm) * cnt)) == NULL) {
				file_oomem(ms, sizeof(*nm) * cnt);
d1022 3
a1024 3
			if ((mp = realloc(*mentryp, sizeof(*mp) * maxmagic)) ==
			    NULL) {
				file_oomem(ms, sizeof(*mp) * maxmagic);
d1033 2
a1034 2
			if ((m = malloc(sizeof(*m) * ALLOC_CHUNK)) == NULL) {
				file_oomem(ms, sizeof(*m) * ALLOC_CHUNK);
@


1.29
log
@fix a buffer overflow found by parfait
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.28 2009/10/27 23:59:37 deraadt Exp $ */
d44 1
d1901 3
a1903 2
	if (st.st_size < 8) {
		file_error(ms, 0, "file `%s' is too small", dbname);
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.27 2009/08/27 16:26:42 deraadt Exp $ */
d2087 1
a2087 1
	uint32_t rv;
@


1.27
log
@Appease gcc2 (I wish people would write in C, rather than "latest crap
gcc added")
ok millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.26 2009/04/24 18:54:34 chl Exp $ */
a51 4

#ifndef	lint
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.26 2009/04/24 18:54:34 chl Exp $")
#endif	/* lint */
@


1.26
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.25 2008/05/08 01:40:56 chl Exp $ */
d33 4
a47 2
#include <sys/stat.h>
#include <sys/param.h>
a50 1
#include <sys/types.h>
d54 1
a54 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.25 2008/05/08 01:40:56 chl Exp $")
@


1.25
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.24 2007/10/05 14:29:46 chl Exp $ */
d35 1
d49 2
d53 1
a53 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.24 2007/10/05 14:29:46 chl Exp $")
d99 2
d105 1
a105 1
private int apprentice_file(struct magic_set *, struct magic **, uint32_t *,
d112 1
a112 1
private char *mkdbname(const char *, char *, size_t, int);
d119 1
d124 3
d162 1
a162 1
	const char *name;
d168 1
a168 1
# define XX_NULL	NULL, 0
d201 6
d217 1
a217 1
	for (p = type_tbl; p->name; p++) {
d237 1
a237 1
	for (p = type_tbl; p->name; p++) {
d245 1
a245 1
 * Handle one file.
d265 1
a265 1
		rv = apprentice_file(ms, &magic, &nmagic, fn, action);
d277 1
a277 1
		rv = apprentice_file(ms, &magic, &nmagic, fn, action);
d284 1
a284 1
	if (magic == NULL || nmagic == 0) {
d331 1
a331 1
/* const char *fn: list of magic files */
d335 1
a335 1
	char *p, *mfn, *afn = NULL;
a337 1
	static const char mime[] = ".mime";
a364 12
		if (ms->flags & MAGIC_MIME) {
			size_t len = strlen(fn) + sizeof(mime);
			if ((afn = malloc(len)) == NULL) {
				free(mfn);
				free(mlist);
				file_oomem(ms, len);
				return NULL;
			}
			(void)strlcpy(afn, fn, len);
			(void)strlcat(afn, ".mime", len);
			fn = afn;
		}
d366 1
a366 6
		if (file_err > errs)
			errs = file_err;
		if (afn) {
			free(afn);
			afn = NULL;
		}
d422 1
a422 1
		val += m->vallen;
d433 3
d448 3
d462 1
a465 1
	case '!':
d509 59
d569 48
a616 2
 * parse from a file
 * const char *fn: name of magic file
d619 1
a619 1
apprentice_file(struct magic_set *ms, struct magic **magicp, uint32_t *nmagicp,
a621 4
	private const char hdr[] =
		"cont\toffset\ttype\topcode\tmask\tvalue\tdesc";
	FILE *f;
	char line[BUFSIZ];
d624 5
a628 2
	uint32_t marraycount, i, mentrycount = 0;
	size_t lineno = 0;
a631 8
	f = fopen(ms->file = fn, "r");
	if (f == NULL) {
		if (errno != ENOENT)
			file_error(ms, errno, "cannot read magic file `%s'",
			    fn);
		return -1;
	}

a633 1
		(void)fclose(f);
d641 21
a661 1
		(void)fprintf(stderr, "%s\n", hdr);
d663 4
a666 5
	/* read and parse this file */
	for (ms->line = 1; fgets(line, sizeof(line), f) != NULL; ms->line++) {
		size_t len;
		len = strlen(line);
		if (len == 0) /* null line, garbage, etc */
a667 3
		if (line[len - 1] == '\n') {
			lineno++;
			line[len - 1] = '\0'; /* delete newline */
d669 25
a693 6
		if (line[0] == '\0')	/* empty, do not parse */
			continue;
		if (line[0] == '#')	/* comment, do not parse */
			continue;
		if (parse(ms, &marray, &marraycount, line, lineno, action) != 0)
			errs++;
d696 1
a696 3
	(void)fclose(f);
	if (errs)
		goto out;
a697 2
#ifndef NOORDER
	qsort(marray, marraycount, sizeof(*marray), apprentice_sort);
a714 1
#endif
d779 3
d793 3
d817 1
a817 1
string_modifier_check(struct magic_set *ms, struct magic const *m)
d826 2
a827 1
			file_magwarn(ms, "no modifiers allowed for 16-bit strings\n");
d834 2
a835 1
			file_magwarn(ms, "'/%c' only allowed on regex and search\n",
d841 7
d898 4
a901 4
	static struct cond_tbl_s {
		const char *name;
		const size_t len;
		const int cond;
d906 1
a906 1
		{ NULL, 	0,	COND_NONE },
d908 1
a908 1
	struct cond_tbl_s *p;
d910 1
a910 1
	for (p = cond_tbl; p->name; p++) {
d1107 10
d1187 1
a1187 1
	m->str_count = 0;
d1201 1
a1201 1
			int have_count = 0;
a1203 1
				/* for portability avoid "case '0' ... '9':" */
d1207 3
a1209 2
				case '9': {
					if (have_count && ms->flags & MAGIC_CHECK)
d1211 6
a1216 3
						    "multiple counts");
					have_count = 1;
					m->str_count = strtoul(l, &t, 0);
a1218 1
				}
d1243 2
a1244 1
				if (l[1] == '/' && !isspace((unsigned char)l[2]))
d1307 1
a1307 1
		m->nospflag = 1;
d1311 2
a1312 3
		m->nospflag = 1;
	} else
		m->nospflag = 0;
d1334 1
d1340 47
d1460 25
d1531 1
a1531 1
		file_error(ms, 0, "Internal error inconsistency between "
d1536 1
a1536 1
		file_error(ms, 0, "No format string for `%s' with description "
d1547 2
a1548 2
		file_error(ms, 0, "Printf format `%c' is not valid for type "
		    " `%s' in description `%s'", 
d1556 1
a1556 1
			file_error(ms, 0,
d1591 24
d1889 1
a1889 2
	char buf[MAXPATHLEN];
	char *dbname = mkdbname(fn, buf, sizeof(buf), 0);
d1892 1
d1894 1
a1894 1
		return -1;
d1897 1
a1897 1
		return -1;
d1901 1
a1901 1
		goto error;
d1903 1
a1903 1
	if (st.st_size < 16) {
d1905 1
a1905 1
		goto error;
d1912 1
a1912 1
		goto error;
d1918 1
a1918 1
		goto error;
d1922 1
a1922 1
		goto error;
d1933 1
a1933 1
			goto error;
d1943 8
a1950 5
		file_error(ms, 0, "version mismatch (%d != %d) in `%s'",
		    version, VERSIONNO, dbname);
		goto error;
	}
	*nmagicp = (uint32_t)(st.st_size / sizeof(struct magic)) - 1;
d1954 1
d1957 1
a1957 1
error:
d1970 2
d1986 4
a1989 2
	char buf[MAXPATHLEN];
	char *dbname = mkdbname(fn, buf, sizeof(buf), 1);
d1992 1
a1992 1
		return -1;
d1996 1
a1996 1
		return -1;
d2001 1
a2001 1
		return -1;
d2007 1
a2007 1
		return -1;
d2013 1
a2013 1
		return -1;
d2017 4
a2020 1
	return 0;
d2027 2
a2028 2
private char *
mkdbname(const char *fn, char *buf, size_t bufsiz, int strip)
d2036 5
a2040 2
	(void)snprintf(buf, bufsiz, "%s%s", fn, ext);
	return buf;
d2093 1
d2102 10
d2126 1
a2126 1
		m->str_count = swap4(m->str_count);
@


1.24
log
@use strcspn instead of strchr to properly overwrite '\n' in fgets returned buffer
check if the first byte is NUL instead of invoking strlen()

with help of ray@@ "Looks OK" millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.23 2006/10/31 18:06:27 ray Exp $ */
d40 1
d50 1
a50 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.23 2006/10/31 18:06:27 ray Exp $")
d79 12
a90 1
private int getvalue(struct magic_set *ms, struct magic *, char **);
d92 5
a96 3
private char *getstr(struct magic_set *, char *, char *, int, int *);
private int parse(struct magic_set *, struct magic **, uint32_t *, char *, int);
private void eatsize(char **);
d98 2
d106 2
a107 1
private char *mkdbname(const char *, char *, size_t);
d112 2
d118 1
a119 3
const char *magicfile;
char *progname;
int lineno;
d127 2
d136 2
a137 2
		(void)fprintf(stderr, "usage: %s file\n", progname);
		exit(1);
a138 1
	magicfile = argv[1];
d140 9
a148 1
	exit(file_apprentice(magicfile, COMPILE, MAGIC_CHECK) == -1 ? 1 : 0);
d152 76
d257 1
d261 1
a261 1
			file_magwarn("using regular magic file `%s'", fn);
a264 1
		mapped = 0;
a266 2
	if (rv == -1)
		return rv;
d276 1
a276 1
		file_oomem(ms);
d299 1
d304 1
d307 1
a315 1

d323 3
d332 2
a333 2
	if ((fn = mfn = strdup(fn)) == NULL) {
		file_oomem(ms);
d336 1
d340 1
a340 1
		file_oomem(ms);
d352 1
a352 1
			size_t len = strlen(fn) + 5 + 1;
d356 1
a356 1
				file_oomem(ms);
d384 123
a517 1
	int lineno;
d519 3
d523 3
a525 1
	f = fopen(fn, "r");
d534 1
a534 2
	*magicp = (struct magic *) calloc(maxmagic, sizeof(struct magic));
	if (*magicp == NULL) {
d536 1
a536 1
		file_oomem(ms);
d539 1
d545 11
a555 3
	/* parse it */
	for (lineno = 1; fgets(line, sizeof(line), f) != NULL; lineno++) {
		if (line[0]=='#')	/* comment, do not parse */
d557 1
a557 3
		/* delete newline */
		line[strcspn(line, "\n")] = '\0';
		if (line[0] == '\0')
d559 2
a560 2
		if (parse(ms, magicp, nmagicp, line, action) != 0)
			errs = 1;
d564 43
a607 1
		free(*magicp);
d610 4
d615 1
a615 1
	return errs;
d621 2
a622 2
protected uint32_t
file_signextend(struct magic_set *ms, struct magic *m, uint32_t v)
d624 1
a624 1
	if (!(m->flag & UNSIGNED))
d642 1
d646 1
d650 1
d653 11
d666 2
a667 1
			break;
d669 2
d674 1
a674 1
			    file_magwarn("cannot happen: m->type=%d\n",
d678 1
d682 140
d826 2
a827 2
parse(struct magic_set *ms, struct magic **magicp, uint32_t *nmagicp, char *l,
    int action)
d829 5
d835 1
d837 2
a838 2
	private const char *fops = FILE_OPS;
	uint32_t val;
d840 1
a840 17
#define ALLOC_INCR	200
	if (*nmagicp + 1 >= maxmagic){
		maxmagic += ALLOC_INCR;
		if ((m = (struct magic *) realloc(*magicp,
		    sizeof(struct magic) * maxmagic)) == NULL) {
			file_oomem(ms);
			if (*magicp)
				free(*magicp);
			return -1;
		}
		*magicp = m;
		memset(&(*magicp)[*nmagicp], 0, sizeof(struct magic)
		    * ALLOC_INCR);
	}
	m = &(*magicp)[*nmagicp];
	m->flag = 0;
	m->cont_level = 0;
d844 1
a844 1
		m->cont_level++; 
d846 9
d856 46
a901 3
	if (m->cont_level != 0 && *l == '(') {
		++l;		/* step over */
		m->flag |= INDIR;
d903 3
a905 1
	if (m->cont_level != 0 && *l == '&') {
d909 15
d929 1
a929 1
			file_magwarn("offset %s invalid", l);
d947 3
d966 2
a967 2
					file_magwarn(
					    "indirect offset type %c invalid",
d973 2
d976 1
a976 1
			m->in_op = FILE_OPINVERSE;
d979 2
a980 3
		switch (*l) {
		case '&':
			m->in_op |= FILE_OPAND;
d982 3
a984 3
			break;
		case '|':
			m->in_op |= FILE_OPOR;
a985 25
			break;
		case '^':
			m->in_op |= FILE_OPXOR;
			l++;
			break;
		case '+':
			m->in_op |= FILE_OPADD;
			l++;
			break;
		case '-':
			m->in_op |= FILE_OPMINUS;
			l++;
			break;
		case '*':
			m->in_op |= FILE_OPMULTIPLY;
			l++;
			break;
		case '/':
			m->in_op |= FILE_OPDIVIDE;
			l++;
			break;
		case '%':
			m->in_op |= FILE_OPMODULO;
			l++;
			break;
d987 10
a996 5
		if (isdigit((unsigned char)*l)) 
			m->in_offset = (uint32_t)strtoul(l, &t, 0);
		else
			t = l;
		if (*t++ != ')') 
d998 2
a999 2
				file_magwarn("missing ')' in indirect offset");
		l = t;
d1001 1
d1003 4
a1007 2
	while (isascii((unsigned char)*l) && isdigit((unsigned char)*l))
		++l;
d1009 1
a1009 17

#define NBYTE		4
#define NSHORT		5
#define NLONG		4
#define NSTRING 	6
#define NDATE		4
#define NBESHORT	7
#define NBELONG		6
#define NBEDATE		6
#define NLESHORT	7
#define NLELONG		6
#define NLEDATE		6
#define NPSTRING	7
#define NLDATE		5
#define NBELDATE	7
#define NLELDATE	7
#define NREGEX		5
d1016 2
a1017 53
	/* get type, skip it */
	if (strncmp(l, "char", NBYTE)==0) {	/* HP/UX compat */
		m->type = FILE_BYTE;
		l += NBYTE;
	} else if (strncmp(l, "byte", NBYTE)==0) {
		m->type = FILE_BYTE;
		l += NBYTE;
	} else if (strncmp(l, "short", NSHORT)==0) {
		m->type = FILE_SHORT;
		l += NSHORT;
	} else if (strncmp(l, "long", NLONG)==0) {
		m->type = FILE_LONG;
		l += NLONG;
	} else if (strncmp(l, "string", NSTRING)==0) {
		m->type = FILE_STRING;
		l += NSTRING;
	} else if (strncmp(l, "date", NDATE)==0) {
		m->type = FILE_DATE;
		l += NDATE;
	} else if (strncmp(l, "beshort", NBESHORT)==0) {
		m->type = FILE_BESHORT;
		l += NBESHORT;
	} else if (strncmp(l, "belong", NBELONG)==0) {
		m->type = FILE_BELONG;
		l += NBELONG;
	} else if (strncmp(l, "bedate", NBEDATE)==0) {
		m->type = FILE_BEDATE;
		l += NBEDATE;
	} else if (strncmp(l, "leshort", NLESHORT)==0) {
		m->type = FILE_LESHORT;
		l += NLESHORT;
	} else if (strncmp(l, "lelong", NLELONG)==0) {
		m->type = FILE_LELONG;
		l += NLELONG;
	} else if (strncmp(l, "ledate", NLEDATE)==0) {
		m->type = FILE_LEDATE;
		l += NLEDATE;
	} else if (strncmp(l, "pstring", NPSTRING)==0) {
		m->type = FILE_PSTRING;
		l += NPSTRING;
	} else if (strncmp(l, "ldate", NLDATE)==0) {
		m->type = FILE_LDATE;
		l += NLDATE;
	} else if (strncmp(l, "beldate", NBELDATE)==0) {
		m->type = FILE_BELDATE;
		l += NBELDATE;
	} else if (strncmp(l, "leldate", NLELDATE)==0) {
		m->type = FILE_LELDATE;
		l += NLELDATE;
	} else if (strncmp(l, "regex", NREGEX)==0) {
		m->type = FILE_REGEX;
		l += sizeof("regex");
	} else {
d1019 1
a1019 1
			file_magwarn("type %s invalid", l);
d1022 1
d1025 2
d1028 4
a1031 2
		if (FILE_STRING != m->type && FILE_PSTRING != m->type)
			m->mask_op = FILE_OPINVERSE;
d1034 6
a1039 4
	if ((t = strchr(fops,  *l)) != NULL) {
		uint32_t op = (uint32_t)(t - fops);
		if (op != FILE_OPDIVIDE ||
		    (FILE_STRING != m->type && FILE_PSTRING != m->type)) {
d1042 3
a1044 2
			val = (uint32_t)strtoul(l, &l, 0);
			m->mask = file_signextend(ms, m, val);
d1046 3
a1048 2
		} else {
			m->mask = 0L;
d1051 11
a1061 2
				case CHAR_IGNORE_LOWERCASE:
					m->mask |= STRING_IGNORE_LOWERCASE;
d1063 1
d1065 1
a1065 1
					m->mask |= STRING_COMPACT_BLANK;
d1068 1
a1068 1
					m->mask |=
d1071 9
d1082 2
a1083 2
						file_magwarn(
						"string extension %c invalid",
d1087 3
d1091 7
d1121 3
a1123 6
		if (m->type != FILE_STRING && m->type != FILE_PSTRING) {
			m->reln = *l;
			++l;
			break;
		}
		/*FALLTHROUGH*/
d1125 3
a1127 2
		if (*l == 'x' && isascii((unsigned char)l[1]) && 
		    isspace((unsigned char)l[1])) {
a1129 1
			goto GetDesc;	/* Bill The Cat */
a1130 1
  		m->reln = '=';
d1133 4
a1136 3
  	EATAB;
  
	if (getvalue(ms, m, &l))
d1138 1
d1146 1
a1146 1
	 * now get last part - the description
a1147 1
GetDesc:
d1158 7
d1166 8
a1173 2
	strlcpy(m->desc, l, sizeof(m->desc));

d1179 156
a1334 1
	++(*nmagicp);		/* make room for next */
d1344 1
a1344 1
getvalue(struct magic_set *ms, struct magic *m, char **p)
d1349 2
d1354 2
a1355 1
		*p = getstr(ms, *p, m->value.s, sizeof(m->value.s), &slen);
d1358 1
a1358 1
				file_magwarn("cannot get string from `%s'",
d1366 4
a1369 2
			m->value.l = file_signextend(ms, m,
			    (uint32_t)strtoul(*p, p, 0));
d1382 2
a1383 2
private char *
getstr(struct magic_set *ms, char *s, char *p, int plen, int *slen)
d1385 2
a1386 1
	char	*origs = s, *origp = p;
d1398 1
a1398 1
		if(c == '\\') {
d1402 2
d1406 7
d1414 29
d1446 12
a1465 4
			case 'b':
				*p++ = '\b';
				break;

a1469 4
			case 'f':
				*p++ = '\f';
				break;

d1485 2
a1486 2
				if(c >= '0' && c <= '7') {
					val = (val<<3) | (c - '0');
d1488 2
a1489 2
					if(c >= '0' && c <= '7')
						val = (val<<3) | (c-'0');
d1532 1
a1532 1
	if ((c >= 'a')&&(c <= 'f'))
d1534 1
a1534 1
	if (( c>= 'A')&&(c <= 'F'))
d1558 1
a1558 1
		if(c >= 040 && c <= 0176)	/* TODO isprint && !iscntrl */
d1563 12
a1574 1
			
a1582 4
			case '\b':
				(void) fputc('b', fp);
				break;

a1586 4
			case '\f':
				(void) fputc('f', fp);
				break;

d1603 1
a1603 1
eatsize(char **p)
d1605 1
a1605 1
	char *l = *p;
d1638 1
a1638 1
	char *dbname = mkdbname(fn, buf, sizeof(buf));
d1644 1
a1644 1
	if ((fd = open(dbname, O_RDONLY)) == -1)
d1665 1
a1665 1
		file_oomem(ms);
d1729 1
a1729 1
	char *dbname = mkdbname(fn, buf, sizeof(buf));
d1734 1
a1734 1
	if ((fd = open(dbname, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1) {
d1765 1
a1765 1
mkdbname(const char *fn, char *buf, size_t bufsiz)
d1767 6
a1772 5
#ifdef notdef
	const char *p;
	if ((p = strrchr(fn, '/')) != NULL)
		fn = ++p;
#endif
d1819 20
d1847 9
a1855 3
	if (m->type != FILE_STRING)
		m->value.l = swap4(m->value.l);
	m->mask = swap4(m->mask);
@


1.23
log
@Don't blindly truncate buf[strlen(buf) - 1] without checking for
newline.

Initial patch from Charles Longeau <chl at tuxfamily dot org>, fix
inspired by comment by Anonymous Coward on undeadly.

OK moritz@@, ian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.22 2006/04/04 14:17:01 pedro Exp $ */
d49 1
a49 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.22 2006/04/04 14:17:01 pedro Exp $")
a313 2
		char *p;

d316 3
a318 1
		if (strlen(line) <= (unsigned)1) /* null line, garbage, etc */
a319 3
		/* delete newline */
		if ((p = strchr(line, '\n')) != NULL)
			*p = '\0';
@


1.22
log
@Remove unused variable, spotted by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.21 2006/04/04 10:53:40 pedro Exp $ */
d49 1
a49 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.21 2006/04/04 10:53:40 pedro Exp $")
d314 2
d320 3
a322 1
		line[strlen(line)-1] = '\0'; /* delete newline */
@


1.21
log
@Fix case where a string could not be correctly terminated, okay jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.20 2004/09/25 09:19:35 otto Exp $ */
d49 1
a49 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.20 2004/09/25 09:19:35 otto Exp $")
a384 1
	int i = 0;
@


1.20
log
@tidy buffer sizes, from Alexander Farber, PR 3924. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.19 2004/05/19 02:32:35 tedu Exp $ */
d49 1
a49 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.19 2004/05/19 02:32:35 tedu Exp $")
d701 2
a702 2
	while ((m->desc[i++] = *l++) != '\0' && i < MAXDESC)
		/* NULLBODY */;
@


1.19
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 1
a49 1
FILE_RCSID("@@(#)$Id: apprentice.c,v 1.75 2004/03/22 18:48:56 christos Exp $")
d288 1
a288 1
	char line[BUFSIZ+1];
d313 1
a313 1
	for (lineno = 1; fgets(line, BUFSIZ, f) != NULL; lineno++) {
@


1.18
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 2
/*	$OpenBSD: apprentice.c,v 1.17 2003/04/07 19:03:46 deraadt Exp $	*/

a2 2
 * apprentice - make one pass through /etc/magic, learning its secrets.
 *
d29 3
d33 2
a34 1
#include <stdio.h>
d36 3
d41 6
a46 3
#include <errno.h>
#include <err.h>
#include "file.h"
d49 1
a49 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.17 2003/04/07 19:03:46 deraadt Exp $";
d56 90
d147 17
d165 8
a172 5
static int getvalue(struct magic *, char **);
static int hextoint(int);
static char *getstr(char *, char *, int, int *);
static int parse(char *, int *, int);
static void eatsize(char **);
d174 5
a178 2
static int maxmagic = 0;
static int alloc_incr = 256;
d180 8
a187 1
static int apprentice_1(char *, int);
d189 28
a216 4
int
apprentice(fn, check)
char *fn;			/* list of magic files */
int check;			/* non-zero? checking-only run. */
d218 1
a218 1
	char *p, *mfn;
d220 1
a220 1
	size_t len;
d222 14
a235 10
        maxmagic = MAXMAGIS;
	magic = (struct magic *) calloc(maxmagic, sizeof(struct magic));
	len = strlen(fn)+1;
	mfn = malloc(len);
	if (magic == NULL || mfn == NULL) {
		warn("malloc");
		if (check)
			return -1;
		else
			exit(1);
d237 1
a237 2
	strlcpy(mfn, fn, len);
	fn = mfn;
d240 1
a240 1
		p = strchr(fn, ':');
d243 15
a257 1
		file_err = apprentice_1(fn, check);
d260 4
d266 7
a272 5
	if (errs == -1)
		warnx("couldn't find any magic files!");
	if (!check && errs)
		exit(1);

d274 1
a274 1
	return errs;
d277 7
a283 4
static int
apprentice_1(fn, check)
char *fn;			/* name of magic file */
int check;			/* non-zero? checking-only run. */
d285 1
a285 1
	static const char hdr[] =
d289 1
d293 1
a293 1
	if (f==NULL) {
d295 2
a296 1
			warn("%s", fn);
d300 12
d313 1
a313 4
	if (check)	/* print silly verbose header for USG compat. */
		(void) printf("%s\n", hdr);

	for (lineno = 1;fgets(line, BUFSIZ, f) != NULL; lineno++) {
d319 1
a319 1
		if (parse(line, &nmagic, check) != 0)
d323 6
a328 1
	(void) fclose(f);
d335 2
a336 4
uint32_t
signextend(m, v)
struct magic *m;
uint32_t v;
d345 1
a345 1
		case BYTE:
d348 3
a350 3
		case SHORT:
		case BESHORT:
		case LESHORT:
d353 9
a361 6
		case DATE:
		case BEDATE:
		case LEDATE:
		case LONG:
		case BELONG:
		case LELONG:
d364 4
a367 1
		case STRING:
d370 4
a373 2
			warnx("can't happen: m->type=%d", m->type);
			return -1;
d381 3
a383 4
static int
parse(l, ndx, check)
char *l;
int *ndx, check;
d385 1
a385 1
	int i = 0, nd = *ndx;
d387 12
a398 13
	char *t, *s;

	if (nd+1 >= maxmagic){
	    struct magic *mtmp;

	    maxmagic += alloc_incr;
	    if ((mtmp = (struct magic *) realloc(magic, 
						  sizeof(struct magic) * 
						  maxmagic)) == NULL) {
		warn("malloc");
		if (check) {
			if (magic)
				free(magic);
d400 4
a403 6
		} else
			exit(1);
	    }
	    magic = mtmp;
	    memset(&magic[*ndx], 0, sizeof(struct magic) * alloc_incr);
	    alloc_incr *= 2;
d405 1
a405 1
	m = &magic[*ndx];
d420 1
a420 1
                m->flag |= ADD;
d424 1
a424 1
	m->offset = (int) strtoul(l,&t,0);
d426 2
a427 1
		warnx("offset %s invalid", l);
d431 2
a432 2
		m->in.type = LONG;
		m->in.offset = 0;
d438 1
a438 1
			switch (LOWCASE(*l)) {
d440 4
a443 1
				m->in.type = LONG;
d447 5
a451 1
				m->in.type = SHORT;
d455 3
a457 1
				m->in.type = BYTE;
d460 4
a463 1
				warnx("indirect offset type %c invalid", *l);
d468 37
a504 5
		s = l;
		if (*l == '+' || *l == '-') l++;
		if (isdigit((unsigned char)*l)) {
			m->in.offset = strtoul(l, &t, 0);
			if (*s == '-') m->in.offset = - m->in.offset;
d506 2
d511 2
a512 1
			warnx("missing ')' in indirect offset");
d532 5
d544 5
a548 2
	if (strncmp(l, "byte", NBYTE)==0) {
		m->type = BYTE;
d551 1
a551 1
		m->type = SHORT;
d554 1
a554 1
		m->type = LONG;
d557 1
a557 1
		m->type = STRING;
d560 1
a560 1
		m->type = DATE;
d563 1
a563 1
		m->type = BESHORT;
d566 1
a566 1
		m->type = BELONG;
d569 1
a569 1
		m->type = BEDATE;
d572 1
a572 1
		m->type = LESHORT;
d575 1
a575 1
		m->type = LELONG;
d578 1
a578 1
		m->type = LEDATE;
d580 15
d596 2
a597 1
		warnx("type %s invalid", l);
d601 4
a604 1
	if (*l == '&') {
d606 38
a643 4
		m->mask = signextend(m, strtoul(l, &l, 0));
		eatsize(&l);
	} else
		m->mask = ~0L;
d655 4
d661 1
a661 1
		if (m->type != STRING) {
d666 1
a666 1
		/* FALL THROUGH */
d679 1
a679 1
	if (getvalue(m, &l))
d684 1
a684 1
	 *	warnx("offset too big"); }
d701 1
a701 1
	while ((m->desc[i++] = *l++) != '\0' && i<MAXDESC)
d704 3
a706 2
	if (check) {
		mdump(m);
d708 2
a709 1
	++(*ndx);		/* make room for next */
d718 2
a719 4
static int
getvalue(m, p)
struct magic *m;
char **p;
d723 11
a733 2
	if (m->type == STRING) {
		*p = getstr(*p, m->value.s, sizeof(m->value.s), &slen);
d735 2
a736 1
	} else
d738 2
a739 1
			m->value.l = signextend(m, strtoul(*p, p, 0));
d742 2
a743 1
	return 0;
d752 2
a753 5
static char *
getstr(s, p, plen, slen)
char	*s;
char	*p;
int	plen, *slen;
d764 2
a765 2
			fprintf(stderr, "String too long: %s\n", origs);
			break;
d852 12
a863 9
static int
hextoint(c)
int c;
{
	if (!isascii((unsigned char) c))	return -1;
	if (isdigit((unsigned char) c))		return c - '0';
	if ((c>='a')&&(c<='f'))	return c + 10 - 'a';
	if ((c>='A')&&(c<='F'))	return c + 10 - 'A';
				return -1;
d870 2
a871 5
void
showstr(fp, s, len)
FILE *fp;
const char *s;
int len;
d877 1
a877 1
		if (len == -1) {
d926 2
a927 3
static void
eatsize(p)
char **p;
d947 206
@


1.17
log
@string fixes; ian ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.16 2003/03/11 21:26:26 ian Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d42 1
a42 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.16 2003/03/11 21:26:26 ian Exp $";
@


1.16
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.15 2002/08/12 00:42:56 aaron Exp $	*/
d47 1
a47 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.15 2002/08/12 00:42:56 aaron Exp $";
d74 1
d78 2
a79 1
	mfn = malloc(strlen(fn)+1);
d87 3
a89 2
	fn = strcpy(mfn, fn);	/* ok */
  
@


1.15
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.14 2002/06/05 13:46:44 itojun Exp $	*/
d6 30
a35 22
 * Copyright (c) Ian F. Darwin, 1987.
 * Written by Ian F. Darwin.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or of the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. The author is not responsible for the consequences of use of this
 *    software, no matter how awful, even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Since few users ever read sources,
 *    credits must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.  Since few users
 *    ever read sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
d47 1
a47 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.14 2002/06/05 13:46:44 itojun Exp $";
@


1.14
log
@use types in inttypes.h directly
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.13 2002/03/14 06:51:41 mpech Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.13 2002/03/14 06:51:41 mpech Exp $";
d68 1
a68 1
	magic = (struct magic *) calloc(sizeof(struct magic), maxmagic);
@


1.13
log
@Remove \n from err/errx/warn/warnx().

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.12 2002/02/16 21:27:46 millert Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.12 2002/02/16 21:27:46 millert Exp $";
d136 1
a136 1
uint32
d139 1
a139 1
uint32 v;
d162 1
a162 1
			v = (int32) v;
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.11 2001/11/19 19:02:13 mpech Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.11 2001/11/19 19:02:13 mpech Exp $";
d167 1
a167 1
			warnx("can't happen: m->type=%d\n", m->type);
@


1.11
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.10 2000/06/30 16:00:13 millert Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.10 2000/06/30 16:00:13 millert Exp $";
d48 5
a52 5
static int getvalue	__P((struct magic *, char **));
static int hextoint	__P((int));
static char *getstr	__P((char *, char *, int, int *));
static int parse	__P((char *, int *, int));
static void eatsize	__P((char **));
d57 1
a57 1
static int apprentice_1	__P((char *, int));
@


1.10
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.9 1999/12/06 00:32:28 deraadt Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.9 1999/12/06 00:32:28 deraadt Exp $";
d428 2
a429 2
register char	*s;
register char	*p;
d434 2
a435 2
	register int	c;
	register int	val;
d550 1
a550 1
	register char	c;
@


1.9
log
@oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.8 1999/09/26 20:47:28 ian Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.8 1999/09/26 20:47:28 ian Exp $";
d111 1
a111 1
			warn(fn);
@


1.9.2.1
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.10 2000/06/30 16:00:13 millert Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.10 2000/06/30 16:00:13 millert Exp $";
d111 1
a111 1
			warn("%s", fn);
@


1.8
log
@Increase MAXMAGIS again, and change the reallocation - don't need to
skimp on memory as much as when this code was written! (Thanks Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.7 1998/08/21 04:25:02 deraadt Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.7 1998/08/21 04:25:02 deraadt Exp $";
d77 1
a77 1
	fn = strcpy(mfn, fn);
@


1.7
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.6 1998/08/19 17:20:01 deraadt Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.6 1998/08/19 17:20:01 deraadt Exp $";
d55 1
a184 1
#define ALLOC_INCR	20
d188 1
a188 1
	    maxmagic += ALLOC_INCR;
d201 2
a202 1
	    memset(&magic[*ndx], 0, sizeof(struct magic) * ALLOC_INCR);
@


1.6
log
@realloc fix
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.5 1998/07/10 15:05:13 mickey Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.5 1998/07/10 15:05:13 mickey Exp $";
a195 1
			magic = mtmp;
d200 1
@


1.5
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.4 1997/02/09 23:58:16 millert Exp $	*/
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.4 1997/02/09 23:58:16 millert Exp $";
d186 2
d189 1
a189 1
	    if ((magic = (struct magic *) realloc(magic, 
d193 4
a196 1
		if (check)
d198 1
a198 1
		else
@


1.4
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: apprentice.c,v 1.3 1996/06/26 05:32:54 deraadt Exp $	*/
d35 1
d39 1
a39 1
static char *moduleid = "$OpenBSD: apprentice.c,v 1.3 1996/06/26 05:32:54 deraadt Exp $";
d70 1
a70 1
		(void) fprintf(stderr, "%s: Out of memory.\n", progname);
d88 1
a88 2
		(void) fprintf(stderr, "%s: couldn't find any magic files!\n",
			       progname);
d110 1
a110 3
			(void) fprintf(stderr,
			"%s: can't read magic file %s (%s)\n", 
			progname, fn, strerror(errno));
d166 1
a166 2
			magwarn("can't happen: m->type=%d\n",
				m->type);
d190 1
a190 1
		(void) fprintf(stderr, "%s: Out of memory.\n", progname);
d219 1
a219 1
		magwarn("offset %s invalid", l);
d243 1
a243 1
				magwarn("indirect offset type %c invalid", *l);
d257 1
a257 1
			magwarn("missing ')' in indirect offset");
d318 1
a318 1
		magwarn("type %s invalid", l);
d364 1
a364 1
	 *	magwarn("offset too big"); }
@


1.3
log
@rcsid
@
text
@d1 2
a2 1
/*	$OpenBSD: apprentice.c,v 1.2 1995/12/14 03:30:01 deraadt Exp $	*/
d38 1
a38 1
static char *moduleid = "$OpenBSD$";
d137 1
a137 1
unsigned long
d140 1
a140 1
unsigned long v;
d163 1
a163 1
			v = (long) v;
d214 4
d499 1
a499 1
			/* \x and up to 3 hex digits */
d506 1
a506 1
					if (c >= 0) {
d508 1
a508 6
						c = hextoint(*s++);
						if (c >= 0) {
							val = (val << 4) + c;
						} else
							--s;
					} else
@


1.2
log
@update from netbsd
@
text
@d1 1
d37 1
a37 2
static char *moduleid = 
	"@@(#)$Id: apprentice.c,v 1.10 1995/10/27 23:33:17 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d32 1
d37 1
a37 1
	"@@(#)$Id: apprentice.c,v 1.9 1995/05/21 00:13:24 christos Exp $";
d54 1
d58 39
d100 2
d108 5
a112 6
		(void) fprintf(stderr, "%s: can't read magic file %s\n",
		progname, fn);
		if (check)
			return -1;
		else
			exit(1);
a114 10
        maxmagic = MAXMAGIS;
	if ((magic = (struct magic *) calloc(sizeof(struct magic), maxmagic))
	    == NULL) {
		(void) fprintf(stderr, "%s: Out of memory.\n", progname);
		if (check)
			return -1;
		else
			exit(1);
	}
  
d117 1
a117 1
		(void) printf("cont\toffset\ttype\topcode\tmask\tvalue\tdesc\n");
d126 1
a126 1
			++errs;
d130 1
a130 1
	return errs ? -1 : 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
