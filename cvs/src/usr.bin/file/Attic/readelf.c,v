head	1.13;
access;
symbols
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.2.0.16
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.14
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.12
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.1.0.6
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.12;
commitid	4VUU04TZM8ebPiy4;

1.12
date	2014.11.04.16.18.54;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	ypEEhkQJedg0mY2x;

1.11
date	2009.10.27.23.59.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.03.22.24.08;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.05.13.46.44;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	98.07.10.15.05.26;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.02.09.23.58.33;	author millert;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.12.02.14.16;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.13
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/*	$OpenBSD: readelf.c,v 1.12 2014/11/04 16:18:54 deraadt Exp $ */
/*
 * Copyright (c) Christos Zoulas 2003.
 * All Rights Reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "file.h"

#ifdef BUILTIN_ELF
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "readelf.h"
#include "magic.h"

#ifdef	ELFCORE
private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,
    off_t, int *);
#endif
private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,
    off_t, int *);
private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *);
private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,
    int, size_t, int *);

#define	ELF_ALIGN(a)	((((a) + align - 1) / align) * align)

#define isquote(c) (strchr("'\"`", (c)) != NULL)

private uint16_t getu16(int, uint16_t);
private uint32_t getu32(int, uint32_t);
private uint64_t getu64(int, uint64_t);

private uint16_t
getu16(int swap, uint16_t value)
{
	union {
		uint16_t ui;
		char c[2];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[1];
		retval.c[1] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

private uint32_t
getu32(int swap, uint32_t value)
{
	union {
		uint32_t ui;
		char c[4];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[3];
		retval.c[1] = tmpval.c[2];
		retval.c[2] = tmpval.c[1];
		retval.c[3] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

private uint64_t
getu64(int swap, uint64_t value)
{
	union {
		uint64_t ui;
		char c[8];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[7];
		retval.c[1] = tmpval.c[6];
		retval.c[2] = tmpval.c[5];
		retval.c[3] = tmpval.c[4];
		retval.c[4] = tmpval.c[3];
		retval.c[5] = tmpval.c[2];
		retval.c[6] = tmpval.c[1];
		retval.c[7] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

#define elf_getu16(swap, value) getu16(swap, value)
#define elf_getu32(swap, value) getu32(swap, value)
#ifdef USE_ARRAY_FOR_64BIT_TYPES
# define elf_getu64(swap, array) \
	((swap ? ((uint64_t)elf_getu32(swap, array[0])) << 32 : elf_getu32(swap, array[0])) + \
	 (swap ? elf_getu32(swap, array[1]) : ((uint64_t)elf_getu32(swap, array[1]) << 32)))
#else
# define elf_getu64(swap, value) getu64(swap, value)
#endif

#define xsh_addr	(class == ELFCLASS32			\
			 ? (void *) &sh32			\
			 : (void *) &sh64)
#define xsh_sizeof	(class == ELFCLASS32			\
			 ? sizeof sh32				\
			 : sizeof sh64)
#define xsh_size	(class == ELFCLASS32			\
			 ? elf_getu32(swap, sh32.sh_size)	\
			 : elf_getu64(swap, sh64.sh_size))
#define xsh_offset	(class == ELFCLASS32			\
			 ? elf_getu32(swap, sh32.sh_offset)	\
			 : elf_getu64(swap, sh64.sh_offset))
#define xsh_type	(class == ELFCLASS32			\
			 ? elf_getu32(swap, sh32.sh_type)	\
			 : elf_getu32(swap, sh64.sh_type))
#define xph_addr	(class == ELFCLASS32			\
			 ? (void *) &ph32			\
			 : (void *) &ph64)
#define xph_sizeof	(class == ELFCLASS32			\
			 ? sizeof ph32				\
			 : sizeof ph64)
#define xph_type	(class == ELFCLASS32			\
			 ? elf_getu32(swap, ph32.p_type)	\
			 : elf_getu32(swap, ph64.p_type))
#define xph_offset	(off_t)(class == ELFCLASS32		\
			 ? elf_getu32(swap, ph32.p_offset)	\
			 : elf_getu64(swap, ph64.p_offset))
#define xph_align	(size_t)((class == ELFCLASS32		\
			 ? (off_t) (ph32.p_align ? 		\
			    elf_getu32(swap, ph32.p_align) : 4) \
			 : (off_t) (ph64.p_align ?		\
			    elf_getu64(swap, ph64.p_align) : 4)))
#define xph_filesz	(size_t)((class == ELFCLASS32		\
			 ? elf_getu32(swap, ph32.p_filesz)	\
			 : elf_getu64(swap, ph64.p_filesz)))
#define xnh_addr	(class == ELFCLASS32			\
			 ? (void *) &nh32			\
			 : (void *) &nh64)
#define xph_memsz	(size_t)((class == ELFCLASS32		\
			 ? elf_getu32(swap, ph32.p_memsz)	\
			 : elf_getu64(swap, ph64.p_memsz)))
#define xnh_sizeof	(class == ELFCLASS32			\
			 ? sizeof nh32				\
			 : sizeof nh64)
#define xnh_type	(class == ELFCLASS32			\
			 ? elf_getu32(swap, nh32.n_type)	\
			 : elf_getu32(swap, nh64.n_type))
#define xnh_namesz	(class == ELFCLASS32			\
			 ? elf_getu32(swap, nh32.n_namesz)	\
			 : elf_getu32(swap, nh64.n_namesz))
#define xnh_descsz	(class == ELFCLASS32			\
			 ? elf_getu32(swap, nh32.n_descsz)	\
			 : elf_getu32(swap, nh64.n_descsz))
#define prpsoffsets(i)	(class == ELFCLASS32			\
			 ? prpsoffsets32[i]			\
			 : prpsoffsets64[i])

#ifdef ELFCORE
/*
 * Try larger offsets first to avoid false matches
 * from earlier data that happen to look like strings.
 */
static const size_t	prpsoffsets32[] = {
#ifdef USE_NT_PSINFO
	104,		/* SunOS 5.x (command line) */
	88,		/* SunOS 5.x (short name) */
#endif /* USE_NT_PSINFO */

	100,		/* SunOS 5.x (command line) */
	84,		/* SunOS 5.x (short name) */

	44,		/* Linux (command line) */
	28,		/* Linux 2.0.36 (short name) */

	8,		/* FreeBSD */
};

static const size_t	prpsoffsets64[] = {
#ifdef USE_NT_PSINFO
	152,		/* SunOS 5.x (command line) */
	136,		/* SunOS 5.x (short name) */
#endif /* USE_NT_PSINFO */

	136,		/* SunOS 5.x, 64-bit (command line) */
	120,		/* SunOS 5.x, 64-bit (short name) */

	56,		/* Linux (command line) */
	40,             /* Linux (tested on core from 2.4.x, short name) */

	16,		/* FreeBSD, 64-bit */
};

#define	NOFFSETS32	(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])
#define NOFFSETS64	(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])

#define NOFFSETS	(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)

/*
 * Look through the program headers of an executable image, searching
 * for a PT_NOTE section of type NT_PRPSINFO, with a name "CORE" or
 * "FreeBSD"; if one is found, try looking in various places in its
 * contents for a 16-character string containing only printable
 * characters - if found, that string should be the name of the program
 * that dropped core.  Note: right after that 16-character string is,
 * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and
 * Linux, a longer string (80 characters, in 5.x, probably other
 * SVR4-flavored systems, and Linux) containing the start of the
 * command line for that program.
 *
 * SunOS 5.x core files contain two PT_NOTE sections, with the types
 * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the
 * same info about the command name and command line, so it probably
 * isn't worthwhile to look for NT_PSINFO, but the offsets are provided
 * above (see USE_NT_PSINFO), in case we ever decide to do so.  The
 * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;
 * the SunOS 5.x file command relies on this (and prefers the latter).
 *
 * The signal number probably appears in a section of type NT_PRSTATUS,
 * but that's also rather OS-dependent, in ways that are harder to
 * dissect with heuristics, so I'm not bothering with the signal number.
 * (I suppose the signal number could be of interest in situations where
 * you don't have the binary of the program that dropped core; if you
 * *do* have that binary, the debugger will probably tell you what
 * signal it was.)
 */

#define	OS_STYLE_SVR4		0
#define	OS_STYLE_FREEBSD	1
#define	OS_STYLE_NETBSD		2

private const char os_style_names[][8] = {
	"SVR4",
	"FreeBSD",
	"NetBSD",
};

#define FLAGS_DID_CORE		1
#define FLAGS_DID_NOTE		2
#define FLAGS_DID_CORE_STYLE	4

private int
dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size, off_t fsize, int *flags)
{
	Elf32_Phdr ph32;
	Elf64_Phdr ph64;
	size_t offset;
	unsigned char nbuf[BUFSIZ];
	ssize_t bufsize;
	off_t savedoffset;
 	struct stat st;

	if (fstat(fd, &st) < 0) {
		file_badread(ms);
		return -1;
	}

	if (size != xph_sizeof) {
		if (file_printf(ms, ", corrupted program header size") == -1)
			return -1;
		return 0;
	}

	/*
	 * Loop through all the program headers.
	 */
	for ( ; num; num--) {
		if ((savedoffset = lseek(fd, off, SEEK_SET)) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
		if (read(fd, xph_addr, xph_sizeof) == -1) {
			file_badread(ms);
			return -1;
		}
		if (xph_offset > fsize) {
			if (lseek(fd, savedoffset, SEEK_SET) == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			continue;
		}

		off += size;
		if (xph_type != PT_NOTE)
			continue;

		/*
		 * This is a PT_NOTE section; loop through all the notes
		 * in the section.
		 */
		if (lseek(fd, xph_offset, SEEK_SET) == (off_t)-1) {
			file_badseek(ms);
			return -1;
		}
		bufsize = read(fd, nbuf,
		    ((xph_filesz < sizeof(nbuf)) ? xph_filesz : sizeof(nbuf)));
		if (bufsize == -1) {
			file_badread(ms);
			return -1;
		}
		offset = 0;
		for (;;) {
			if (offset >= (size_t)bufsize)
				break;
			offset = donote(ms, nbuf, offset, (size_t)bufsize,
			    class, swap, 4, flags);
			if (offset == 0)
				break;

		}
	}
	return 0;
}
#endif

private size_t
donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,
    int class, int swap, size_t align, int *flags)
{
	Elf32_Nhdr nh32;
	Elf64_Nhdr nh64;
	size_t noff, doff;
#ifdef ELFCORE
	int os_style = -1;
#endif
	uint32_t namesz, descsz;

	if (xnh_sizeof + offset > size) {
		/*
		 * We're out of note headers.
		 */
		return xnh_sizeof + offset;
	}

	(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);
	offset += xnh_sizeof;

	namesz = xnh_namesz;
	descsz = xnh_descsz;
	if ((namesz == 0) && (descsz == 0)) {
		/*
		 * We're out of note headers.
		 */
		return (offset >= size) ? offset : size;
	}

	if (namesz & 0x80000000) {
	    (void)file_printf(ms, ", bad note name size 0x%lx",
		(unsigned long)namesz);
	    return offset;
	}

	if (descsz & 0x80000000) {
	    (void)file_printf(ms, ", bad note description size 0x%lx",
		(unsigned long)descsz);
	    return offset;
	}


	noff = offset;
	doff = ELF_ALIGN(offset + namesz);

	if (offset + namesz > size) {
		/*
		 * We're past the end of the buffer.
		 */
		return doff;
	}

	offset = ELF_ALIGN(doff + descsz);
	if (doff + descsz > size) {
		/*
		 * We're past the end of the buffer.
		 */
		return (offset >= size) ? offset : size;
	}

	if (*flags & FLAGS_DID_NOTE)
		goto core;

	if (namesz == 4 && strcmp((char *)&nbuf[noff], "GNU") == 0 &&
	    xnh_type == NT_GNU_VERSION && descsz == 16) {
		uint32_t desc[4];
		(void)memcpy(desc, &nbuf[doff], sizeof(desc));

		if (file_printf(ms, ", for GNU/") == -1)
			return size;
		switch (elf_getu32(swap, desc[0])) {
		case GNU_OS_LINUX:
			if (file_printf(ms, "Linux") == -1)
				return size;
			break;
		case GNU_OS_HURD:
			if (file_printf(ms, "Hurd") == -1)
				return size;
			break;
		case GNU_OS_SOLARIS:
			if (file_printf(ms, "Solaris") == -1)
				return size;
			break;
		case GNU_OS_KFREEBSD:
			if (file_printf(ms, "kFreeBSD") == -1)
				return size;
			break;
		case GNU_OS_KNETBSD:
			if (file_printf(ms, "kNetBSD") == -1)
				return size;
			break;
		default:
			if (file_printf(ms, "<unknown>") == -1)
				return size; 
		}
		if (file_printf(ms, " %d.%d.%d", elf_getu32(swap, desc[1]),
		    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)
			return size;
		*flags |= FLAGS_DID_NOTE;
		return size;
	}

	if (namesz == 7 && strcmp((char *)&nbuf[noff], "NetBSD") == 0 &&
	    xnh_type == NT_NETBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = elf_getu32(swap, desc);

		if (file_printf(ms, ", for NetBSD") == -1)
			return size;
		/*
		 * The version number used to be stuck as 199905, and was thus
		 * basically content-free.  Newer versions of NetBSD have fixed
		 * this and now use the encoding of __NetBSD_Version__:
		 *
		 *	MMmmrrpp00
		 *
		 * M = major version
		 * m = minor version
		 * r = release ["",A-Z,Z[A-Z] but numeric]
		 * p = patchlevel
		 */
		if (desc > 100000000U) {
			uint32_t ver_patch = (desc / 100) % 100;
			uint32_t ver_rel = (desc / 10000) % 100;
			uint32_t ver_min = (desc / 1000000) % 100;
			uint32_t ver_maj = desc / 100000000;

			if (file_printf(ms, " %u.%u", ver_maj, ver_min) == -1)
				return size;
			if (ver_rel == 0 && ver_patch != 0) {
				if (file_printf(ms, ".%u", ver_patch) == -1)
					return size;
			} else if (ver_rel != 0) {
				while (ver_rel > 26) {
					if (file_printf(ms, "Z") == -1)
						return size;
					ver_rel -= 26;
				}
				if (file_printf(ms, "%c", 'A' + ver_rel - 1)
				    == -1)
					return size;
			}
		}
		*flags |= FLAGS_DID_NOTE;
		return size;
	}

	if (namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0 &&
	    xnh_type == NT_FREEBSD_VERSION && descsz == 4) {
		uint32_t desc;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = elf_getu32(swap, desc);
		if (file_printf(ms, ", for FreeBSD") == -1)
			return size;

		/*
		 * Contents is __FreeBSD_version, whose relation to OS
		 * versions is defined by a huge table in the Porter's
		 * Handbook.  This is the general scheme:
		 * 
		 * Releases:
		 * 	Mmp000 (before 4.10)
		 * 	Mmi0p0 (before 5.0)
		 * 	Mmm0p0
		 * 
		 * Development branches:
		 * 	Mmpxxx (before 4.6)
		 * 	Mmp1xx (before 4.10)
		 * 	Mmi1xx (before 5.0)
		 * 	M000xx (pre-M.0)
		 * 	Mmm1xx
		 * 
		 * M = major version
		 * m = minor version
		 * i = minor version increment (491000 -> 4.10)
		 * p = patchlevel
		 * x = revision
		 * 
		 * The first release of FreeBSD to use ELF by default
		 * was version 3.0.
		 */
		if (desc == 460002) {
			if (file_printf(ms, " 4.6.2") == -1)
				return size;
		} else if (desc < 460100) {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 10000 % 10) == -1)
				return size;
			if (desc / 1000 % 10 > 0)
				if (file_printf(ms, ".%d", desc / 1000 % 10)
				    == -1)
					return size;
			if ((desc % 1000 > 0) || (desc % 100000 == 0))
				if (file_printf(ms, " (%d)", desc) == -1)
					return size;
		} else if (desc < 500000) {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 10000 % 10 + desc / 1000 % 10) == -1)
				return size;
			if (desc / 100 % 10 > 0) {
				if (file_printf(ms, " (%d)", desc) == -1)
					return size;
			} else if (desc / 10 % 10 > 0) {
				if (file_printf(ms, ".%d", desc / 10 % 10)
				    == -1)
					return size;
			}
		} else {
			if (file_printf(ms, " %d.%d", desc / 100000,
			    desc / 1000 % 100) == -1)
				return size;
			if ((desc / 100 % 10 > 0) ||
			    (desc % 100000 / 100 == 0)) {
				if (file_printf(ms, " (%d)", desc) == -1)
					return size;
			} else if (desc / 10 % 10 > 0) {
				if (file_printf(ms, ".%d", desc / 10 % 10)
				    == -1)
					return size;
			}
		}
		*flags |= FLAGS_DID_NOTE;
		return size;
	}

	if (namesz == 8 && strcmp((char *)&nbuf[noff], "OpenBSD") == 0 &&
	    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {
		if (file_printf(ms, ", for OpenBSD") == -1)
			return size;
		/* Content of note is always 0 */
		*flags |= FLAGS_DID_NOTE;
		return size;
	}

	if (namesz == 10 && strcmp((char *)&nbuf[noff], "DragonFly") == 0 &&
	    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {
		uint32_t desc;
		if (file_printf(ms, ", for DragonFly") == -1)
			return size;
		(void)memcpy(&desc, &nbuf[doff], sizeof(desc));
		desc = elf_getu32(swap, desc);
		if (file_printf(ms, " %d.%d.%d", desc / 100000,
		    desc / 10000 % 10, desc % 10000) == -1)
			return size;
		*flags |= FLAGS_DID_NOTE;
		return size;
	}

core:
	/*
	 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
	 * least, doesn't correctly implement name
	 * sections, in core dumps, as specified by
	 * the "Program Linking" section of "UNIX(R) System
	 * V Release 4 Programmer's Guide: ANSI C and
	 * Programming Support Tools", because my copy
	 * clearly says "The first 'namesz' bytes in 'name'
	 * contain a *null-terminated* [emphasis mine]
	 * character representation of the entry's owner
	 * or originator", but the 2.0.36 kernel code
	 * doesn't include the terminating null in the
	 * name....
	 */
	if ((namesz == 4 && strncmp((char *)&nbuf[noff], "CORE", 4) == 0) ||
	    (namesz == 5 && strcmp((char *)&nbuf[noff], "CORE") == 0)) {
		os_style = OS_STYLE_SVR4;
	} 

	if ((namesz == 8 && strcmp((char *)&nbuf[noff], "FreeBSD") == 0)) {
		os_style = OS_STYLE_FREEBSD;
	}

	if ((namesz >= 11 && strncmp((char *)&nbuf[noff], "NetBSD-CORE", 11)
	    == 0)) {
		os_style = OS_STYLE_NETBSD;
	}

#ifdef ELFCORE
	if ((*flags & FLAGS_DID_CORE) != 0)
		return size;

	if (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {
		if (file_printf(ms, ", %s-style", os_style_names[os_style])
		    == -1)
			return size;
		*flags |= FLAGS_DID_CORE_STYLE;
	}

	switch (os_style) {
	case OS_STYLE_NETBSD:
		if (xnh_type == NT_NETBSD_CORE_PROCINFO) {
			uint32_t signo;
			/*
			 * Extract the program name.  It is at
			 * offset 0x7c, and is up to 32-bytes,
			 * including the terminating NUL.
			 */
			if (file_printf(ms, ", from '%.31s'",
			    &nbuf[doff + 0x7c]) == -1)
				return size;
			
			/*
			 * Extract the signal number.  It is at
			 * offset 0x08.
			 */
			(void)memcpy(&signo, &nbuf[doff + 0x08],
			    sizeof(signo));
			if (file_printf(ms, " (signal %u)",
			    elf_getu32(swap, signo)) == -1)
				return size;
			*flags |= FLAGS_DID_CORE;
			return size;
		}
		break;

	default:
		if (xnh_type == NT_PRPSINFO) {
			size_t i, j;
			unsigned char c;
			/*
			 * Extract the program name.  We assume
			 * it to be 16 characters (that's what it
			 * is in SunOS 5.x and Linux).
			 *
			 * Unfortunately, it's at a different offset
			 * in various OSes, so try multiple offsets.
			 * If the characters aren't all printable,
			 * reject it.
			 */
			for (i = 0; i < NOFFSETS; i++) {
				unsigned char *cname, *cp;
				size_t reloffset = prpsoffsets(i);
				size_t noffset = doff + reloffset;
				for (j = 0; j < 16; j++, noffset++,
				    reloffset++) {
					/*
					 * Make sure we're not past
					 * the end of the buffer; if
					 * we are, just give up.
					 */
					if (noffset >= size)
						goto tryanother;

					/*
					 * Make sure we're not past
					 * the end of the contents;
					 * if we are, this obviously
					 * isn't the right offset.
					 */
					if (reloffset >= descsz)
						goto tryanother;

					c = nbuf[noffset];
					if (c == '\0') {
						/*
						 * A '\0' at the
						 * beginning is
						 * obviously wrong.
						 * Any other '\0'
						 * means we're done.
						 */
						if (j == 0)
							goto tryanother;
						else
							break;
					} else {
						/*
						 * A nonprintable
						 * character is also
						 * wrong.
						 */
						if (!isprint(c) || isquote(c))
							goto tryanother;
					}
				}
				/*
				 * Well, that worked.
				 */
				cname = (unsigned char *)
				    &nbuf[doff + prpsoffsets(i)];
				for (cp = cname; *cp && isprint(*cp); cp++)
					continue;
				/*
				 * Linux apparently appends a space at the end
				 * of the command line: remove it.
				 */
				while (cp > cname && isspace(cp[-1]))
					cp--;
				if (file_printf(ms, ", from '%.*s'",
				    (int)(cp - cname), cname) == -1)
					return size;
				*flags |= FLAGS_DID_CORE;
				return size;

			tryanother:
				;
			}
		}
		break;
	}
#endif
	return offset;
}

private int
doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,
    size_t size, int *flags)
{
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;
	int stripped = 1;
	void *nbuf;
	off_t noff;

	if (size != xsh_sizeof) {
		if (file_printf(ms, ", corrupted section header size") == -1)
			return -1;
		return 0;
	}

	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

	for ( ; num; num--) {
		if (read(fd, xsh_addr, xsh_sizeof) == -1) {
			file_badread(ms);
			return -1;
		}
		switch (xsh_type) {
		case SHT_SYMTAB:
#if 0
		case SHT_DYNSYM:
#endif
			stripped = 0;
			break;
		case SHT_NOTE:
			if ((off = lseek(fd, (off_t)0, SEEK_CUR)) ==
			    (off_t)-1) {
				file_badread(ms);
				return -1;
			}
			if ((nbuf = malloc((size_t)xsh_size)) == NULL) {
				file_error(ms, errno, "Cannot allocate memory"
				    " for note");
				return -1;
			}
			if ((noff = lseek(fd, (off_t)xsh_offset, SEEK_SET)) ==
			    (off_t)-1) {
				file_badread(ms);
				free(nbuf);
				return -1;
			}
			if (read(fd, nbuf, (size_t)xsh_size) !=
			    (ssize_t)xsh_size) {
				free(nbuf);
				file_badread(ms);
				return -1;
			}

			noff = 0;
			for (;;) {
				if (noff >= (size_t)xsh_size)
					break;
				noff = donote(ms, nbuf, (size_t)noff,
				    (size_t)xsh_size, class, swap, 4,
				    flags);
				if (noff == 0)
					break;
			}
			if ((lseek(fd, off, SEEK_SET)) == (off_t)-1) {
				free(nbuf);
				file_badread(ms);
				return -1;
			}
			free(nbuf);
			break;
		}
	}
	if (file_printf(ms, ", %sstripped", stripped ? "" : "not ") == -1)
		return -1;
	return 0;
}

/*
 * Look through the program headers of an executable image, searching
 * for a PT_INTERP section; if one is found, it's dynamically linked,
 * otherwise it's statically linked.
 */
private int
dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,
    int num, size_t size, off_t fsize, int *flags)
{
	Elf32_Phdr ph32;
	Elf64_Phdr ph64;
	const char *linking_style = "statically";
	const char *shared_libraries = "";
	unsigned char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, align;
	off_t savedoffset = (off_t)-1;
	struct stat st;

	if (fstat(fd, &st) < 0) {
		file_badread(ms);
		return -1;
	}
	
	if (size != xph_sizeof) {
		if (file_printf(ms, ", corrupted program header size") == -1)
			return -1;
		return 0;
	}

	if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
		file_badseek(ms);
		return -1;
	}

  	for ( ; num; num--) {
  		if (read(fd, xph_addr, xph_sizeof) == -1) {
  			file_badread(ms);
			return -1;
		}
		if (xph_offset > st.st_size && savedoffset != (off_t)-1) {
			if (lseek(fd, savedoffset, SEEK_SET) == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			continue;
		}

		if ((savedoffset = lseek(fd, (off_t)0, SEEK_CUR)) == (off_t)-1) {
  			file_badseek(ms);
			return -1;
		}

		if (xph_offset > fsize) {
			if (lseek(fd, savedoffset, SEEK_SET) == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			continue;
		}

		switch (xph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
			if ((align = xph_align) & 0x80000000) {
				if (file_printf(ms, 
				    ", invalid note alignment 0x%lx",
				    (unsigned long)align) == -1)
					return -1;
				align = 4;
			}
			/*
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
			 */
			if (lseek(fd, xph_offset, SEEK_SET)
			    == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			bufsize = read(fd, nbuf, ((xph_filesz < sizeof(nbuf)) ?
			    xph_filesz : sizeof(nbuf)));
			if (bufsize == -1) {
				file_badread(ms);
				return -1;
			}
			offset = 0;
			for (;;) {
				if (offset >= (size_t)bufsize)
					break;
				offset = donote(ms, nbuf, offset,
				    (size_t)bufsize, class, swap, align,
				    flags);
				if (offset == 0)
					break;
			}
			if (lseek(fd, savedoffset, SEEK_SET) == (off_t)-1) {
				file_badseek(ms);
				return -1;
			}
			break;
		default:
			break;
		}
	}
	if (file_printf(ms, ", %s linked%s", linking_style, shared_libraries)
	    == -1)
	    return -1;
	return 0;
}


protected int
file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,
    size_t nbytes)
{
	union {
		int32_t l;
		char c[sizeof (int32_t)];
	} u;
	int class;
	int swap;
	struct stat st;
	off_t fsize;
	int flags = 0;
	Elf32_Ehdr elf32hdr;
	Elf64_Ehdr elf64hdr;
	uint16_t type;

	if (ms->flags & MAGIC_MIME)
		return 0;
	/*
	 * ELF executables have multiple section headers in arbitrary
	 * file locations and thus file(1) cannot determine it from easily.
	 * Instead we traverse thru all section headers until a symbol table
	 * one is found or else the binary is stripped.
	 * Return immediately if it's not ELF (so we avoid pipe2file unless needed).
	 */
	if (buf[EI_MAG0] != ELFMAG0
	    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)
	    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)
		return 0;

	/*
	 * If we cannot seek, it must be a pipe, socket or fifo.
	 */
	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))
		fd = file_pipe2file(ms, fd, buf, nbytes);

	if (fstat(fd, &st) == -1) {
  		file_badread(ms);
		return -1;
	}
	fsize = st.st_size;

	class = buf[EI_CLASS];

	switch (class) {
	case ELFCLASS32:
#undef elf_getu
#define elf_getu(a, b)	elf_getu32(a, b)
#undef elfhdr
#define elfhdr elf32hdr
#include "elfclass.h"
	case ELFCLASS64:
#undef elf_getu
#define elf_getu(a, b)	elf_getu64(a, b)
#undef elfhdr
#define elfhdr elf64hdr
#include "elfclass.h"
	default:
	    if (file_printf(ms, ", unknown class %d", class) == -1)
		    return -1;
	    break;
	}
	return 0;
}
#endif
@


1.12
log
@bounds check, apply from upstream devel/libmagic
from Matthias Pitzl @@ genua
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.11 2009/10/27 23:59:38 deraadt Exp $ */
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.10 2009/04/24 18:54:34 chl Exp $ */
d361 7
@


1.10
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.9 2008/05/08 01:40:56 chl Exp $ */
a39 4

#ifndef lint
FILE_RCSID("@@(#)$Id: readelf.c,v 1.9 2008/05/08 01:40:56 chl Exp $")
#endif
@


1.9
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.8 2004/05/19 02:32:35 tedu Exp $ */
d39 1
d42 1
a42 1
FILE_RCSID("@@(#)$Id: readelf.c,v 1.8 2004/05/19 02:32:35 tedu Exp $")
d128 2
d132 2
a133 2
	((swap ? ((uint64_t)getu32(swap, array[0])) << 32 : getu32(swap, array[0])) + \
	 (swap ? getu32(swap, array[1]) : ((uint64_t)getu32(swap, array[1]) << 32)))
d138 2
a139 2
#define xsh_addr	(class == ELFCLASS32		\
			 ? (void *) &sh32		\
d141 2
a142 2
#define xsh_sizeof	(class == ELFCLASS32		\
			 ? sizeof sh32			\
d144 11
a154 11
#define xsh_size	(class == ELFCLASS32		\
			 ? getu32(swap, sh32.sh_size)	\
			 : getu64(swap, sh64.sh_size))
#define xsh_offset	(class == ELFCLASS32		\
			 ? getu32(swap, sh32.sh_offset)	\
			 : getu64(swap, sh64.sh_offset))
#define xsh_type	(class == ELFCLASS32		\
			 ? getu32(swap, sh32.sh_type)	\
			 : getu32(swap, sh64.sh_type))
#define xph_addr	(class == ELFCLASS32		\
			 ? (void *) &ph32		\
d156 2
a157 2
#define xph_sizeof	(class == ELFCLASS32		\
			 ? sizeof ph32			\
d159 16
a174 16
#define xph_type	(class == ELFCLASS32		\
			 ? getu32(swap, ph32.p_type)	\
			 : getu32(swap, ph64.p_type))
#define xph_offset	(off_t)(class == ELFCLASS32	\
			 ? getu32(swap, ph32.p_offset)	\
			 : getu64(swap, ph64.p_offset))
#define xph_align	(size_t)((class == ELFCLASS32	\
			 ? (off_t) (ph32.p_align ? 	\
			    getu32(swap, ph32.p_align) : 4) \
			 : (off_t) (ph64.p_align ?	\
			    getu64(swap, ph64.p_align) : 4)))
#define xph_filesz	(size_t)((class == ELFCLASS32	\
			 ? getu32(swap, ph32.p_filesz)	\
			 : getu64(swap, ph64.p_filesz)))
#define xnh_addr	(class == ELFCLASS32		\
			 ? (void *) &nh32		\
d176 5
a180 5
#define xph_memsz	(size_t)((class == ELFCLASS32	\
			 ? getu32(swap, ph32.p_memsz)	\
			 : getu64(swap, ph64.p_memsz)))
#define xnh_sizeof	(class == ELFCLASS32		\
			 ? sizeof nh32			\
d182 11
a192 11
#define xnh_type	(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_type)	\
			 : getu32(swap, nh64.n_type))
#define xnh_namesz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_namesz)	\
			 : getu32(swap, nh64.n_namesz))
#define xnh_descsz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32.n_descsz)	\
			 : getu32(swap, nh64.n_descsz))
#define prpsoffsets(i)	(class == ELFCLASS32		\
			 ? prpsoffsets32[i]		\
d196 16
a211 1
size_t	prpsoffsets32[] = {
a212 3
	28,		/* Linux 2.0.36 (short name) */
	44,		/* Linux (path name) */
	84,		/* SunOS 5.x */
d215 12
a226 1
size_t	prpsoffsets64[] = {
a227 3
	40,             /* Linux (tested on core from 2.4.x, short name) */
	56,		/* Linux (path name) */
	120,		/* SunOS 5.x, 64-bit */
d247 8
d268 1
a268 1
private const char *os_style_names[] = {
d276 1
d419 1
a419 1
		switch (getu32(swap, desc[0])) {
d432 8
d444 2
a445 2
		if (file_printf(ms, " %d.%d.%d", getu32(swap, desc[1]),
		    getu32(swap, desc[2]), getu32(swap, desc[3])) == -1)
d455 1
a455 1
		desc = getu32(swap, desc);
d501 1
a501 1
		desc = getu32(swap, desc);
d590 1
a590 1
		desc = getu32(swap, desc);
d631 1
a631 1
	if (os_style != -1) {
d635 1
d658 1
a658 1
			    getu32(swap, signo)) == -1)
d660 1
d680 1
d728 12
a739 2
				if (file_printf(ms, ", from '%.16s'",
				    &nbuf[doff + prpsoffsets(i)]) == -1)
d741 1
a750 1
	*flags |= FLAGS_DID_CORE;
d861 1
a861 1
		    return -1;
d941 2
d965 17
a994 12
	/*
	 * ELF executables have multiple section headers in arbitrary
	 * file locations and thus file(1) cannot determine it from easily.
	 * Instead we traverse thru all section headers until a symbol table
	 * one is found or else the binary is stripped.
	 */
	if (buf[EI_MAG0] != ELFMAG0
	    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)
	    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)
	    return 0;


d997 17
a1013 79
	if (class == ELFCLASS32) {
		Elf32_Ehdr elfhdr;
		if (nbytes <= sizeof (Elf32_Ehdr))
			return 0;


		u.l = 1;
		(void) memcpy(&elfhdr, buf, sizeof elfhdr);
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[EI_DATA];

		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
#ifdef ELFCORE
			if (dophn_core(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_phoff),
			    getu16(swap, elfhdr.e_phnum), 
			    (size_t)getu16(swap, elfhdr.e_phentsize),
			    fsize, &flags) == -1)
				return -1;
#else
			;
#endif
		} else {
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				if (dophn_exec(ms, class, swap,
				    fd, (off_t)getu32(swap, elfhdr.e_phoff),
				    getu16(swap, elfhdr.e_phnum), 
				    (size_t)getu16(swap, elfhdr.e_phentsize),
				    fsize, &flags)
				    == -1)
					return -1;
			}
			if (doshn(ms, class, swap, fd,
			    (off_t)getu32(swap, elfhdr.e_shoff),
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize),
			    &flags) == -1)
				return -1;
		}
		return 1;
	}

        if (class == ELFCLASS64) {
		Elf64_Ehdr elfhdr;
		if (nbytes <= sizeof (Elf64_Ehdr))
			return 0;


		u.l = 1;
		(void) memcpy(&elfhdr, buf, sizeof elfhdr);
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[EI_DATA];

		if (getu16(swap, elfhdr.e_type) == ET_CORE) {
#ifdef ELFCORE
			if (dophn_core(ms, class, swap, fd,
			    (off_t)elf_getu64(swap, elfhdr.e_phoff),
			    getu16(swap, elfhdr.e_phnum), 
			    (size_t)getu16(swap, elfhdr.e_phentsize),
			    fsize, &flags) == -1)
				return -1;
#else
			;
#endif
		} else {
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				if (dophn_exec(ms, class, swap, fd,
				    (off_t)elf_getu64(swap, elfhdr.e_phoff),
				    getu16(swap, elfhdr.e_phnum), 
				    (size_t)getu16(swap, elfhdr.e_phentsize),
				    fsize, &flags) == -1)
					return -1;
			}
			if (doshn(ms, class, swap, fd,
			    (off_t)elf_getu64(swap, elfhdr.e_shoff),
			    getu16(swap, elfhdr.e_shnum),
			    (size_t)getu16(swap, elfhdr.e_shentsize), &flags)
			    == -1)
				return -1;
		}
		return 1;
@


1.8
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d41 1
a41 1
FILE_RCSID("@@(#)$Id: readelf.c,v 1.39 2004/03/22 20:28:40 christos Exp $")
d45 2
a46 1
private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t);
d48 3
a50 2
private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t);
private int doshn(struct magic_set *, int, int, int, off_t, int, size_t);
d52 1
a52 1
    int, size_t);
d56 2
d127 9
a135 1
#define sh_addr		(class == ELFCLASS32		\
d138 1
a138 1
#define sh_size		(class == ELFCLASS32		\
d141 7
a147 1
#define shs_type	(class == ELFCLASS32		\
d150 1
a150 1
#define ph_addr		(class == ELFCLASS32		\
d153 1
a153 1
#define ph_size		(class == ELFCLASS32		\
d156 1
a156 1
#define ph_type		(class == ELFCLASS32		\
d159 1
a159 1
#define ph_offset	(class == ELFCLASS32		\
d162 1
a162 1
#define ph_align	(size_t)((class == ELFCLASS32	\
d167 10
a176 1
#define nh_size		(class == ELFCLASS32		\
d179 1
a179 1
#define nh_type		(class == ELFCLASS32		\
d182 1
a182 1
#define nh_namesz	(class == ELFCLASS32		\
d185 1
a185 1
#define nh_descsz	(class == ELFCLASS32		\
d195 2
a196 2
	28,		/* Linux 2.0.36 */
	32,		/* Linux (I forget which kernel version) */
d201 4
a204 1
       120,		/* SunOS 5.x, 64-bit */
d243 3
d248 1
a248 1
    int num, size_t size)
d255 2
d258 6
a263 1
	if (size != ph_size) {
d268 1
d273 1
a273 1
		if (lseek(fd, off, SEEK_SET) == (off_t)-1) {
d277 1
a277 1
		if (read(fd, ph_addr, ph_size) == -1) {
d281 8
d290 1
a290 1
		if (ph_type != PT_NOTE)
d297 1
a297 1
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == (off_t)-1) {
d301 2
a302 1
		bufsize = read(fd, nbuf, BUFSIZ);
d312 1
a312 1
			    class, swap, 4);
d324 1
a324 1
    int class, int swap, size_t align)
d334 2
a335 5
	if (class == ELFCLASS32)
		memcpy(&nh32, &nbuf[offset], sizeof(nh32));
	else
		memcpy(&nh64, &nbuf[offset], sizeof(nh64));
	offset += nh_size;
d337 2
a338 2
	namesz = nh_namesz;
	descsz = nh_descsz;
d343 1
a343 1
		return offset;
d362 1
a362 1
	if (offset + namesz >= size) {
d370 5
a374 2
	if (offset + descsz >= size) {
		return offset;
d377 3
d381 1
a381 1
	    nh_type == NT_GNU_VERSION && descsz == 16) {
d407 1
d412 1
a412 1
	    nh_type == NT_NETBSD_VERSION && descsz == 4) {
d432 4
a435 4
			u_int ver_patch = (desc / 100) % 100;
			u_int ver_rel = (desc / 10000) % 100;
			u_int ver_min = (desc / 1000000) % 100;
			u_int ver_maj = desc / 100000000;
d444 2
a445 1
					file_printf(ms, "Z");
d448 3
a450 1
				file_printf(ms, "%c", 'A' + ver_rel - 1);
d453 1
d458 1
a458 1
	    nh_type == NT_FREEBSD_VERSION && descsz == 4) {
d467 23
a489 5
		 * versions is defined by a huge table in the Porters'
		 * Handbook. For up to 5.x, the first three digits are
		 * the version number.  For 5.x and higher, the scheme
		 * is: <major><two digit minor> <0 if release branch,
		 * otherwise 1>xx
d491 4
a494 1
		if (desc / 100000 < 5) {
d502 15
d521 3
a523 4
			desc %= 1000;
			if (desc > 100) {
				if (file_printf(ms, "-CURRENT (rev %d)",
				    desc % 100) == -1)
d525 3
a527 2
			} else if (desc != 0) {
				if (file_printf(ms, ".%d", desc / 10) == -1)
d531 1
d536 1
a536 1
	    nh_type == NT_OPENBSD_VERSION && descsz == 4) {
d540 1
d544 15
d588 6
a593 2
	if (os_style != -1)
		if (file_printf(ms, ", %s-style", os_style_names[os_style]) == -1)
d595 1
d597 22
a618 8
	if (os_style == OS_STYLE_NETBSD && nh_type == NT_NETBSD_CORE_PROCINFO) {
		uint32_t signo;
		/*
		 * Extract the program name.  It is at
		 * offset 0x7c, and is up to 32-bytes,
		 * including the terminating NUL.
		 */
		if (file_printf(ms, ", from '%.31s'", &nbuf[doff + 0x7c]) == -1)
d620 2
a621 34
		
		/*
		 * Extract the signal number.  It is at
		 * offset 0x08.
		 */
		memcpy(&signo, &nbuf[doff + 0x08],
		    sizeof(signo));
		if (file_printf(ms, " (signal %u)", getu32(swap, signo)) == -1)
			return size;
		return size;
	} else if (os_style != OS_STYLE_NETBSD && nh_type == NT_PRPSINFO) {
		size_t i, j;
		unsigned char c;
		/*
		 * Extract the program name.  We assume
		 * it to be 16 characters (that's what it
		 * is in SunOS 5.x and Linux).
		 *
		 * Unfortunately, it's at a different offset
		 * in varous OSes, so try multiple offsets.
		 * If the characters aren't all printable,
		 * reject it.
		 */
		for (i = 0; i < NOFFSETS; i++) {
			size_t reloffset = prpsoffsets(i);
			size_t noffset = doff + reloffset;
			for (j = 0; j < 16; j++, noffset++, reloffset++) {
				/*
				 * Make sure we're not past
				 * the end of the buffer; if
				 * we are, just give up.
				 */
				if (noffset >= size)
					goto tryanother;
d623 19
a641 11
				/*
				 * Make sure we're not past
				 * the end of the contents;
				 * if we are, this obviously
				 * isn't the right offset.
				 */
				if (reloffset >= descsz)
					goto tryanother;

				c = nbuf[noffset];
				if (c == '\0') {
d643 3
a645 5
					 * A '\0' at the
					 * beginning is
					 * obviously wrong.
					 * Any other '\0'
					 * means we're done.
d647 1
a647 1
					if (j == 0)
d649 1
a649 3
					else
						break;
				} else {
d651 4
a654 3
					 * A nonprintable
					 * character is also
					 * wrong.
d656 1
a656 2
#define isquote(c) (strchr("'\"`", (c)) != NULL)
					if (!isprint(c) || isquote(c))
d658 23
d682 6
a687 7
			}

			/*
			 * Well, that worked.
			 */
			if (file_printf(ms, ", from '%.16s'",
			    &nbuf[doff + prpsoffsets(i)]) == -1)
a688 1
			return size;
d690 3
a692 2
		tryanother:
			;
d694 1
a694 1
		return offset;
d697 1
d703 1
a703 1
    size_t size)
d707 3
d711 1
a711 1
	if (size != sh_size) {
d723 1
a723 1
		if (read(fd, sh_addr, sh_size) == -1) {
d727 44
a770 2
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
			if (file_printf(ms, ", not stripped") == -1)
d772 3
a774 1
			return 0;
d777 1
a777 1
	if (file_printf(ms, ", stripped") == -1)
d789 1
a789 1
    int num, size_t size)
d798 2
a799 1
	off_t savedoffset;
d801 6
a806 1
	if (size != ph_size) {
d811 1
d818 1
a818 1
  		if (read(fd, ph_addr, ph_size) == -1) {
d822 8
d835 9
a843 1
		switch (ph_type) {
d851 1
a851 1
			if ((align = ph_align) & 0x80000000) {
d862 1
a862 1
			if (lseek(fd, (off_t) ph_offset, SEEK_SET)
d867 2
a868 1
			bufsize = read(fd, nbuf, sizeof(nbuf));
d878 2
a879 1
				    (size_t)bufsize, class, swap, align);
d883 1
a883 2
			if (lseek(fd, savedoffset + offset, SEEK_SET)
			    == (off_t)-1) {
d907 3
d917 6
d935 1
a935 1
	class = buf[4];
d945 1
a945 1
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];
d952 2
a953 1
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
d963 2
a964 1
				    (size_t)getu16(swap, elfhdr.e_phentsize))
d971 2
a972 1
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
d986 1
a986 1
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];
d991 1
a991 5
#ifdef USE_ARRAY_FOR_64BIT_TYPES
			    (off_t)getu32(swap, elfhdr.e_phoff[1]),
#else
			    (off_t)getu64(swap, elfhdr.e_phoff),
#endif
d993 2
a994 1
			    (size_t)getu16(swap, elfhdr.e_phentsize)) == -1)
d1002 1
a1002 5
#ifdef USE_ARRAY_FOR_64BIT_TYPES
				    (off_t)getu32(swap, elfhdr.e_phoff[1]),
#else
				    (off_t)getu64(swap, elfhdr.e_phoff),
#endif
d1004 2
a1005 2
				    (size_t)getu16(swap, elfhdr.e_phentsize))
				    == -1)
d1009 1
a1009 5
#ifdef USE_ARRAY_FOR_64BIT_TYPES
			    (off_t)getu32(swap, elfhdr.e_shoff[1]),
#else
			    (off_t)getu64(swap, elfhdr.e_shoff),
#endif
d1011 2
a1012 1
			    (size_t)getu16(swap, elfhdr.e_shentsize)) == -1)
@


1.7
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
d3 2
a4 5
 * ELF routines for the file command.
 *
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
d15 2
a29 1

d43 1
a43 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.6 2003/06/13 18:31:14 deraadt Exp $";
d47 1
a47 1
static void dophn_core(int, int, int, off_t, int, size_t);
d49 10
a58 2
static void dophn_exec(int, int, int, off_t, int, size_t);
static void doshn(int, int, int, off_t, int, size_t);
d60 1
a60 5
static uint16_t getu16(int, uint16_t);
static uint32_t getu32(int, uint32_t);
static uint64_t getu64(int, uint64_t);

static uint16_t
d79 1
a79 1
static uint32_t
d100 1
a100 1
static uint64_t
d146 5
a150 3
#define ph_align	(class == ELFCLASS32		\
			 ? (ph32.p_align ? getu32(swap, ph32.p_align) : 4) \
			 : (ph64.p_align ? getu64(swap, ph64.p_align) : 4))
d152 2
a153 2
			 ? sizeof *nh32			\
			 : sizeof *nh64)
d155 2
a156 2
			 ? getu32(swap, nh32->n_type)	\
			 : getu32(swap, nh64->n_type))
d158 2
a159 2
			 ? getu32(swap, nh32->n_namesz)	\
			 : getu32(swap, nh64->n_namesz))
d161 2
a162 2
			 ? getu32(swap, nh32->n_descsz)	\
			 : getu32(swap, nh64->n_descsz))
a166 180
static void
doshn(int class, int swap, int fd, off_t off, int num, size_t size)
{
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;

	if (size != sh_size)
		error("corrupted section header size.\n");

	if (lseek(fd, off, SEEK_SET) == -1)
		error("lseek failed (%s).\n", strerror(errno));

	for ( ; num; num--) {
		if (read(fd, sh_addr, sh_size) == -1)
			error("read failed (%s).\n", strerror(errno));
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
			(void) printf (", not stripped");
			return;
		}
	}
	(void) printf (", stripped");
}

/*
 * Look through the program headers of an executable image, searching
 * for a PT_INTERP section; if one is found, it's dynamically linked,
 * otherwise it's statically linked.
 */
static void
dophn_exec(int class, int swap, int fd, off_t off, int num, size_t size)
{
	Elf32_Phdr ph32;
	Elf32_Nhdr *nh32 = NULL;
	Elf64_Phdr ph64;
	Elf64_Nhdr *nh64 = NULL;
	char *linking_style = "statically";
	char *shared_libraries = "";
	char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, nameoffset;
	off_t savedoffset;

	if (size != ph_size)
		error("corrupted program header size.\n");
	if (lseek(fd, off, SEEK_SET) == -1)
		error("lseek failed (%s).\n", strerror(errno));

  	for ( ; num; num--) {
  		if (read(fd, ph_addr, ph_size) == -1)
  			error("read failed (%s).\n", strerror(errno));
		if ((savedoffset = lseek(fd, 0, SEEK_CUR)) == -1)
  			error("lseek failed (%s).\n", strerror(errno));

		switch (ph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
			/*
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
			 */
			if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			bufsize = read(fd, nbuf, sizeof(nbuf));
			if (bufsize == -1)
				error(": " "read failed (%s).\n",
				    strerror(errno));
			offset = 0;
			for (;;) {
				if (offset >= bufsize)
					break;
				if (class == ELFCLASS32)
					nh32 = (Elf32_Nhdr *)&nbuf[offset];
				else
					nh64 = (Elf64_Nhdr *)&nbuf[offset];
				offset += nh_size;
	
				if (offset + nh_namesz >= bufsize) {
					/*
					 * We're past the end of the buffer.
					 */
					break;
				}

				nameoffset = offset;
				offset += nh_namesz;
				offset = ((offset+ph_align-1)/ph_align)*ph_align;

				if ((nh_namesz == 0) && (nh_descsz == 0)) {
					/*
					 * We're out of note headers.
					 */
					break;
				}

				if (offset + nh_descsz >= bufsize)
					break;

				if (nh_namesz == 4 &&
				    strcmp(&nbuf[nameoffset], "GNU") == 0 &&
				    nh_type == NT_GNU_VERSION &&
				    nh_descsz == 16) {
					uint32_t *desc =
					    (uint32_t *)&nbuf[offset];

					printf(", for GNU/");
					switch (getu32(swap, desc[0])) {
					case GNU_OS_LINUX:
						printf("Linux");
						break;
					case GNU_OS_HURD:
						printf("Hurd");
						break;
					case GNU_OS_SOLARIS:
						printf("Solaris");
						break;
					default:
						printf("<unknown>");
					}
					printf(" %d.%d.%d",
					    getu32(swap, desc[1]),
					    getu32(swap, desc[2]),
					    getu32(swap, desc[3]));
				}

				if (nh_namesz == 7 &&
				    strcmp(&nbuf[nameoffset], "NetBSD") == 0 &&
				    nh_type == NT_NETBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for NetBSD");
					/*
					 * Version number is stuck at 199905,
					 * and hence is basically content-free.
					 */
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "FreeBSD") == 0 &&
				    nh_type == NT_FREEBSD_VERSION &&
				    nh_descsz == 4) {
					uint32_t desc = getu32(swap,
					    *(uint32_t *)&nbuf[offset]);
					printf(", for FreeBSD");
					/*
					 * Contents is __FreeBSD_version,
					 * whose relation to OS versions is
					 * defined by a huge table in the
					 * Porters' Handbook.  Happily, the
					 * first three digits are the version
					 * number, at least in versions of
					 * FreeBSD that use this note.
					 */

					printf(" %d.%d", desc / 100000,
					    desc / 10000 % 10);
					if (desc / 1000 % 10 > 0)
						printf(".%d",
						    desc / 1000 % 10);
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "OpenBSD") == 0 &&
				    nh_type == NT_OPENBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for OpenBSD");
					/* Content of note is always 0 */
				}
			}
			if ((lseek(fd, savedoffset + offset, SEEK_SET)) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			break;
		}
	}
	printf(", %s linked%s", linking_style, shared_libraries);
}

d209 1
a209 1
static const char *os_style_names[] = {
d215 3
a217 2
static void
dophn_core(int class, int swap, int fd, off_t off, int num, size_t size)
a219 1
	Elf32_Nhdr *nh32 = NULL;
d221 9
a229 10
	Elf64_Nhdr *nh64 = NULL;
	size_t offset, nameoffset, noffset, reloffset;
	unsigned char c;
	int i, j;
	char nbuf[BUFSIZ];
	int bufsize;
	int os_style = -1;

	if (size != ph_size)
		error("corrupted program header size.\n");
d234 8
a241 4
		if (lseek(fd, off, SEEK_SET) == -1)
			error("lseek failed (%s).\n", strerror(errno));
		if (read(fd, ph_addr, ph_size) == -1)
			error("read failed (%s).\n", strerror(errno));
d250 4
a253 2
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
			error("lseek failed (%s).\n", strerror(errno));
d255 4
a258 2
		if (bufsize == -1)
			error(": " "read failed (%s).\n", strerror(errno));
d261 5
a265 1
			if (offset >= bufsize)
a266 5
			if (class == ELFCLASS32)
				nh32 = (Elf32_Nhdr *)&nbuf[offset];
			else
				nh64 = (Elf64_Nhdr *)&nbuf[offset];
			offset += nh_size;
d268 128
a395 9
			/*
			 * Check whether this note has the name "CORE" or
			 * "FreeBSD", or "NetBSD-CORE".
			 */
			if (offset + nh_namesz >= bufsize) {
				/*
				 * We're past the end of the buffer.
				 */
				break;
d397 3
d401 7
a407 3
			nameoffset = offset;
			offset += nh_namesz;
			offset = ((offset + 3)/4)*4;
d409 28
a436 35
			/*
			 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
			 * least, doesn't correctly implement name
			 * sections, in core dumps, as specified by
			 * the "Program Linking" section of "UNIX(R) System
			 * V Release 4 Programmer's Guide: ANSI C and
			 * Programming Support Tools", because my copy
			 * clearly says "The first 'namesz' bytes in 'name'
			 * contain a *null-terminated* [emphasis mine]
			 * character representation of the entry's owner
			 * or originator", but the 2.0.36 kernel code
			 * doesn't include the terminating null in the
			 * name....
			 */
			if (os_style == -1) {
				if ((nh_namesz == 4 &&
				     strncmp(&nbuf[nameoffset],
					    "CORE", 4) == 0) ||
				    (nh_namesz == 5 &&
				     strcmp(&nbuf[nameoffset],
				     	    "CORE") == 0)) {
					os_style = OS_STYLE_SVR4;
				} else
				if ((nh_namesz == 8 &&
				     strcmp(&nbuf[nameoffset],
				     	    "FreeBSD") == 0)) {
					os_style = OS_STYLE_FREEBSD;
				} else
				if ((nh_namesz >= 11 &&
				     strncmp(&nbuf[nameoffset],
				     	     "NetBSD-CORE", 11) == 0)) {
					os_style = OS_STYLE_NETBSD;
				} else
					continue;
				printf(", %s-style", os_style_names[os_style]);
d438 39
d478 4
a481 3
			if (os_style == OS_STYLE_NETBSD &&
			    nh_type == NT_NETBSD_CORE_PROCINFO) {
				uint32_t signo;
d483 36
d520 3
a522 3
				 * Extract the program name.  It is at
				 * offset 0x7c, and is up to 32-bytes,
				 * including the terminating NUL.
d524 3
a526 12
				printf(", from '%.31s'", &nbuf[offset + 0x7c]);
				
				/*
				 * Extract the signal number.  It is at
				 * offset 0x08.
				 */
				memcpy(&signo, &nbuf[offset + 0x08],
				    sizeof(signo));
				printf(" (signal %u)", getu32(swap, signo));
			} else
			if (os_style != OS_STYLE_NETBSD &&
			    nh_type == NT_PRPSINFO) {
d528 4
a531 8
				 * Extract the program name.  We assume
				 * it to be 16 characters (that's what it
				 * is in SunOS 5.x and Linux).
				 *
				 * Unfortunately, it's at a different offset
				 * in various OSes, so try multiple offsets.
				 * If the characters aren't all printable,
				 * reject it.
d533 2
a534 47
				for (i = 0; i < NOFFSETS; i++) {
					reloffset = prpsoffsets(i);
					noffset = offset + reloffset;
					for (j = 0; j < 16;
					    j++, noffset++, reloffset++) {
						/*
						 * Make sure we're not past
						 * the end of the buffer; if
						 * we are, just give up.
						 */
						if (noffset >= bufsize)
							goto tryanother;

						/*
						 * Make sure we're not past
						 * the end of the contents;
						 * if we are, this obviously
						 * isn't the right offset.
						 */
						if (reloffset >= nh_descsz)
							goto tryanother;

						c = nbuf[noffset];
						if (c == '\0') {
							/*
							 * A '\0' at the
							 * beginning is
							 * obviously wrong.
							 * Any other '\0'
							 * means we're done.
							 */
							if (j == 0)
								goto tryanother;
							else
								break;
						} else {
							/*
							 * A nonprintable
							 * character is also
							 * wrong.
							 */
#define isquote(c) (strchr("'\"`", (c)) != NULL)
							if (!isprint(c) ||
							     isquote(c))
								goto tryanother;
						}
					}
d536 14
d551 3
a553 1
					 * Well, that worked.
d555 131
a685 2
					printf(", from '%.16s'",
					    &nbuf[offset + prpsoffsets(i)]);
a686 5

				tryanother:
					;
				}
				break;
d688 6
a693 2
			offset += nh_descsz;
			offset = ((offset + 3)/4)*4;
d696 4
a700 1
#endif
d702 4
a705 2
void
tryelf(int fd, unsigned char *buf, int nbytes)
d715 1
a715 1
	 * If we can't seek, it must be a pipe, socket or fifo.
d718 1
a718 1
		fd = pipe2file(fd, buf, nbytes);
d729 1
a729 1
	    return;
d737 1
a737 1
			return;
d744 1
a744 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
d746 5
a750 5
			dophn_core(class, swap,
				   fd,
				   getu32(swap, elfhdr.e_phoff),
				   getu16(swap, elfhdr.e_phnum), 
				   getu16(swap, elfhdr.e_phentsize));
d754 1
a754 1
		else {
d756 6
a761 5
				dophn_exec(class, swap,
					   fd,
					   getu32(swap, elfhdr.e_phoff),
					   getu16(swap, elfhdr.e_phnum), 
					   getu16(swap, elfhdr.e_phentsize));
d763 5
a767 5
			doshn(class, swap,
			      fd,
			      getu32(swap, elfhdr.e_shoff),
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
d769 1
a769 1
		return;
d775 1
a775 1
			return;
d782 1
a782 1
		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
d784 1
a784 2
			dophn_core(class, swap,
				   fd,
d786 1
a786 1
				   getu32(swap, elfhdr.e_phoff[1]),
d788 1
a788 1
				   getu64(swap, elfhdr.e_phoff),
d790 3
a792 2
				   getu16(swap, elfhdr.e_phnum), 
				   getu16(swap, elfhdr.e_phentsize));
d796 1
a796 2
		else
		{
d798 1
a798 2
				dophn_exec(class, swap,
					   fd,
d800 1
a800 1
					   getu32(swap, elfhdr.e_phoff[1]),
d802 1
a802 1
					   getu64(swap, elfhdr.e_phoff),
d804 4
a807 2
					   getu16(swap, elfhdr.e_phnum), 
					   getu16(swap, elfhdr.e_phentsize));
d809 1
a809 2
			doshn(class, swap,
			      fd,
d811 1
a811 1
			      getu32(swap, elfhdr.e_shoff[1]),
d813 1
a813 1
			      getu64(swap, elfhdr.e_shoff),
d815 3
a817 2
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
d819 1
a819 1
		return;
d821 1
@


1.6
log
@ian gives permission for 3/4 removal
@
text
@d44 1
a44 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.5 2003/03/11 21:26:26 ian Exp $";
d516 1
a516 1
				 * in varous OSes, so try multiple offsets.
@


1.5
log
@Replace TPUM license with standard BSD-style license
@
text
@a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d44 1
a44 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.4 2003/03/03 22:24:08 ian Exp $";
@


1.4
log
@Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.
@
text
@d1 35
d49 1
a49 1
static char *RCSID = "@@(#)$Id: readelf.c,v 1.26 2003/02/25 15:30:00 christos Exp $";
@


1.3
log
@use types in inttypes.h directly
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.2 1998/07/10 15:05:26 mickey Exp $	*/
a3 1
#include <sys/types.h>
a4 1
#include <stdio.h>
d7 1
d9 1
a9 1
#include <errno.h>
d12 119
a130 1
#include "file.h"
d133 1
a133 6
doshn(fd, off, num, size, buf)
	int fd;
	off_t off;
	int num;
	size_t size;
	char *buf;
d135 5
a139 9
	/*
	 * This works for both 32-bit and 64-bit ELF formats,
	 * because it looks only at the "sh_type" field, which is
	 * always 32 bits, and is preceded only by the "sh_name"
	 * field which is also always 32 bits, and because it uses
	 * the shdr size from the ELF header rather than using
	 * the size of an "Elf32_Shdr".
	 */
	Elf32_Shdr *sh = (Elf32_Shdr *) buf;
d142 1
a142 1
		err(1, "lseek failed");
d145 3
a147 3
		if (read(fd, buf, size) == -1)
			err(1, "read failed");
		if (sh->sh_type == SHT_SYMTAB) {
d161 1
a161 6
dophn_exec(fd, off, num, size, buf)
	int fd;
	off_t off;
	int num;
	size_t size;
	char *buf;
d163 10
a172 2
	/* I am not sure if this works for 64 bit elf formats */
	Elf32_Phdr *ph = (Elf32_Phdr *) buf;
d174 2
d177 1
a177 1
		err(1, "lseek failed");
d180 13
a192 3
  		if (read(fd, buf, size) == -1)
  			err(1, "read failed");
		if (ph->p_type == PT_INTERP) {
d194 2
a195 2
			 * Has an interpreter - must be a dynamically-linked
			 * executable.
d197 110
a306 2
			printf(", dynamically linked");
			return;
d309 1
a309 1
	printf(", statically linked");
d312 10
a321 3
size_t	prpsoffsets[] = {
	100,		/* SunOS 5.x */
	32,		/* Linux */
d324 4
a327 1
#define	NOFFSETS	(sizeof prpsoffsets / sizeof prpsoffsets[0])
d331 17
a347 8
 * for a PT_NOTE section of type NT_PRPSINFO, with a name "CORE"; if one
 * is found, try looking in various places in its contents for a 16-character
 * string containing only printable characters - if found, that string
 * should be the name of the program that dropped core.
 * Note: right after that 16-character string is, at least in SunOS 5.x
 * (and possibly other SVR4-flavored systems) and Linux, a longer string
 * (80 characters, in 5.x, probably other SVR4-flavored systems, and Linux)
 * containing the start of the command line for that program.
d349 11
d361 1
a361 6
dophn_core(fd, off, num, size, buf)
	int fd;
	off_t off;
	int num;
	size_t size;
	char *buf;
d363 5
a367 11
	/*
	 * This doesn't work for 64-bit ELF, as the "p_offset" field is
	 * 64 bits in 64-bit ELF.
	 */
	/*
	 * This doesn't work for 64-bit ELF, as the "p_offset" field is
	 * 64 bits in 64-bit ELF.
	 */
	Elf32_Phdr *ph = (Elf32_Phdr *) buf;
	Elf32_Nhdr *nh;
	size_t offset, noffset, reloffset;
d372 1
d374 5
d381 3
a383 3
			err(1, "lseek failed");
		if (read(fd, buf, size) == -1)
			err(1, "read failed");
d385 1
a385 1
		if (ph->p_type != PT_NOTE)
d387 7
a393 2
		if (lseek(fd, ph->p_offset, SEEK_SET) == -1)
			err(1, "lseek failed");
d396 1
a396 1
			err(1, "read failed");
d401 5
a405 2
			nh = (Elf32_Nhdr *)&nbuf[offset];
			offset += sizeof *nh;
d408 2
a409 2
			 * If this note isn't an NT_PRPSINFO note, it's
			 * not what we're looking for.
d411 1
a411 12
			if (nh->n_type != NT_PRPSINFO) {
				offset += nh->n_namesz;
				offset = ((offset + 3)/4)*4;
				offset += nh->n_descsz;
				offset = ((offset + 3)/4)*4;
				continue;
			}

			/*
			 * Make sure this note has the name "CORE".
			 */
			if (offset + nh->n_namesz >= bufsize) {
d417 3
a419 4
			if (nh->n_namesz != 5
			    || strcmp(&nbuf[offset], "CORE") != 0)
				continue;
			offset += nh->n_namesz;
d423 12
a434 8
			 * Extract the program name.  We assume it to be
			 * 16 characters (that's what it is in SunOS 5.x
			 * and Linux).
			 *
			 * Unfortunately, it's at a different offset in
			 * SunOS 5.x and Linux, so try multiple offsets.
			 * If the characters aren't all printable, reject
			 * it.
d436 101
a536 12
			for (i = 0; i < NOFFSETS; i++) {
				reloffset = prpsoffsets[i];
				noffset = offset + reloffset;
				for (j = 0; j < 16;
				    j++, noffset++, reloffset++) {
					/*
					 * Make sure we're not past the end
					 * of the buffer; if we are, just
					 * give up.
					 */
					if (noffset >= bufsize)
						return;
d539 1
a539 4
					 * Make sure we're not past the
					 * end of the contents; if we
					 * are, this obviously isn't
					 * the right offset.
d541 3
a543 2
					if (reloffset >= nh->n_descsz)
						goto tryanother;
d545 2
a546 3
					c = nbuf[noffset];
					if (c != '\0' && !isprint(c))
						goto tryanother;
d548 1
a548 10

				/*
				 * Well, that worked.
				 */
				printf(", from '%.16s'",
				    &nbuf[offset + prpsoffsets[i]]);
				return;

			tryanother:
				;
d550 1
a550 1
			offset += nh->n_descsz;
d555 1
d558 1
a558 4
tryelf(fd, buf, nbytes)
	int fd;
	char *buf;
	int nbytes;
d564 8
d579 2
a580 1
	if (buf[EI_MAG0] != ELFMAG0 || buf[EI_MAG1] != ELFMAG1
d585 3
a587 1
	if (buf[4] == ELFCLASS32) {
d595 19
a613 19
		/*
		 * If the system byteorder does not equal the
		 * object byteorder then don't test.
		 * XXX - we could conceivably fix up the "dophn_XXX()" and
		 * "doshn()" routines to extract stuff in the right
		 * byte order....
		 */
		if ((u.c[sizeof(long) - 1] + 1) == elfhdr.e_ident[5]) {
			if (elfhdr.e_type == ET_CORE) 
				dophn_core(fd, elfhdr.e_phoff, elfhdr.e_phnum, 
				      elfhdr.e_phentsize, buf);
			else {
				if (elfhdr.e_type == ET_EXEC) {
					dophn_exec(fd, elfhdr.e_phoff,
					    elfhdr.e_phnum, 
					      elfhdr.e_phentsize, buf);
				}
				doshn(fd, elfhdr.e_shoff, elfhdr.e_shnum,
				      elfhdr.e_shentsize, buf);
d615 5
d624 1
a624 1
        if (buf[4] == ELFCLASS64) {
d632 1
d634 13
a646 13
		/*
		 * If the system byteorder does not equal the
		 * object byteorder then don't test.
		 * XXX - we could conceivably fix up the "dophn_XXX()" and
		 * "doshn()" routines to extract stuff in the right
		 * byte order....
		 */
		if ((u.c[sizeof(long) - 1] + 1) == elfhdr.e_ident[5]) {
#ifdef notyet
			if (elfhdr.e_type == ET_CORE) 
				dophn_core(fd, elfhdr.e_phoff, elfhdr.e_phnum, 
				      elfhdr.e_phentsize, buf);
			else
d648 9
a656 7
			{
#ifdef notyet
				if (elfhdr.e_type == ET_EXEC) {
					dophn_exec(fd, elfhdr.e_phoff,
					    elfhdr.e_phnum, 
					      elfhdr.e_phentsize, buf);
				}
d658 2
a659 2
				doshn(fd, elfhdr.e_shoff, elfhdr.e_shnum,
				      elfhdr.e_shentsize, buf);
d661 9
@


1.3.2.1
log
@Pull patch from current.
Fix by ian@@
Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.

ok millert@@
@
text
@d1 1
a1 1
#include "file.h"
d4 1
d6 1
a8 1
#ifdef HAVE_UNISTD_H
d10 1
a10 1
#endif
d13 1
a13 119

#ifndef lint
static char *RCSID = "@@(#)$Id: readelf.c,v 1.4 2003/03/03 22:24:08 ian Exp $";
#endif

#ifdef	ELFCORE
static void dophn_core(int, int, int, off_t, int, size_t);
#endif
static void dophn_exec(int, int, int, off_t, int, size_t);
static void doshn(int, int, int, off_t, int, size_t);

static uint16_t getu16(int, uint16_t);
static uint32_t getu32(int, uint32_t);
static uint64_t getu64(int, uint64_t);

static uint16_t
getu16(int swap, uint16_t value)
{
	union {
		uint16_t ui;
		char c[2];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[1];
		retval.c[1] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

static uint32_t
getu32(int swap, uint32_t value)
{
	union {
		uint32_t ui;
		char c[4];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[3];
		retval.c[1] = tmpval.c[2];
		retval.c[2] = tmpval.c[1];
		retval.c[3] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

static uint64_t
getu64(int swap, uint64_t value)
{
	union {
		uint64_t ui;
		char c[8];
	} retval, tmpval;

	if (swap) {
		tmpval.ui = value;

		retval.c[0] = tmpval.c[7];
		retval.c[1] = tmpval.c[6];
		retval.c[2] = tmpval.c[5];
		retval.c[3] = tmpval.c[4];
		retval.c[4] = tmpval.c[3];
		retval.c[5] = tmpval.c[2];
		retval.c[6] = tmpval.c[1];
		retval.c[7] = tmpval.c[0];
		
		return retval.ui;
	} else
		return value;
}

#define sh_addr		(class == ELFCLASS32		\
			 ? (void *) &sh32		\
			 : (void *) &sh64)
#define sh_size		(class == ELFCLASS32		\
			 ? sizeof sh32			\
			 : sizeof sh64)
#define shs_type	(class == ELFCLASS32		\
			 ? getu32(swap, sh32.sh_type)	\
			 : getu32(swap, sh64.sh_type))
#define ph_addr		(class == ELFCLASS32		\
			 ? (void *) &ph32		\
			 : (void *) &ph64)
#define ph_size		(class == ELFCLASS32		\
			 ? sizeof ph32			\
			 : sizeof ph64)
#define ph_type		(class == ELFCLASS32		\
			 ? getu32(swap, ph32.p_type)	\
			 : getu32(swap, ph64.p_type))
#define ph_offset	(class == ELFCLASS32		\
			 ? getu32(swap, ph32.p_offset)	\
			 : getu64(swap, ph64.p_offset))
#define ph_align	(class == ELFCLASS32		\
			 ? (ph32.p_align ? getu32(swap, ph32.p_align) : 4) \
			 : (ph64.p_align ? getu64(swap, ph64.p_align) : 4))
#define nh_size		(class == ELFCLASS32		\
			 ? sizeof *nh32			\
			 : sizeof *nh64)
#define nh_type		(class == ELFCLASS32		\
			 ? getu32(swap, nh32->n_type)	\
			 : getu32(swap, nh64->n_type))
#define nh_namesz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32->n_namesz)	\
			 : getu32(swap, nh64->n_namesz))
#define nh_descsz	(class == ELFCLASS32		\
			 ? getu32(swap, nh32->n_descsz)	\
			 : getu32(swap, nh64->n_descsz))
#define prpsoffsets(i)	(class == ELFCLASS32		\
			 ? prpsoffsets32[i]		\
			 : prpsoffsets64[i])
d16 6
a21 1
doshn(int class, int swap, int fd, off_t off, int num, size_t size)
d23 9
a31 5
	Elf32_Shdr sh32;
	Elf64_Shdr sh64;

	if (size != sh_size)
		error("corrupted section header size.\n");
d34 1
a34 1
		error("lseek failed (%s).\n", strerror(errno));
d37 3
a39 3
		if (read(fd, sh_addr, sh_size) == -1)
			error("read failed (%s).\n", strerror(errno));
		if (shs_type == SHT_SYMTAB /* || shs_type == SHT_DYNSYM */) {
d53 6
a58 1
dophn_exec(int class, int swap, int fd, off_t off, int num, size_t size)
d60 2
a61 10
	Elf32_Phdr ph32;
	Elf32_Nhdr *nh32 = NULL;
	Elf64_Phdr ph64;
	Elf64_Nhdr *nh64 = NULL;
	char *linking_style = "statically";
	char *shared_libraries = "";
	char nbuf[BUFSIZ];
	int bufsize;
	size_t offset, nameoffset;
	off_t savedoffset;
a62 2
	if (size != ph_size)
		error("corrupted program header size.\n");
d64 1
a64 1
		error("lseek failed (%s).\n", strerror(errno));
d67 3
a69 13
  		if (read(fd, ph_addr, ph_size) == -1)
  			error("read failed (%s).\n", strerror(errno));
		if ((savedoffset = lseek(fd, 0, SEEK_CUR)) == -1)
  			error("lseek failed (%s).\n", strerror(errno));

		switch (ph_type) {
		case PT_DYNAMIC:
			linking_style = "dynamically";
			break;
		case PT_INTERP:
			shared_libraries = " (uses shared libs)";
			break;
		case PT_NOTE:
d71 2
a72 2
			 * This is a PT_NOTE section; loop through all the notes
			 * in the section.
d74 2
a75 110
			if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			bufsize = read(fd, nbuf, sizeof(nbuf));
			if (bufsize == -1)
				error(": " "read failed (%s).\n",
				    strerror(errno));
			offset = 0;
			for (;;) {
				if (offset >= bufsize)
					break;
				if (class == ELFCLASS32)
					nh32 = (Elf32_Nhdr *)&nbuf[offset];
				else
					nh64 = (Elf64_Nhdr *)&nbuf[offset];
				offset += nh_size;
	
				if (offset + nh_namesz >= bufsize) {
					/*
					 * We're past the end of the buffer.
					 */
					break;
				}

				nameoffset = offset;
				offset += nh_namesz;
				offset = ((offset+ph_align-1)/ph_align)*ph_align;

				if ((nh_namesz == 0) && (nh_descsz == 0)) {
					/*
					 * We're out of note headers.
					 */
					break;
				}

				if (offset + nh_descsz >= bufsize)
					break;

				if (nh_namesz == 4 &&
				    strcmp(&nbuf[nameoffset], "GNU") == 0 &&
				    nh_type == NT_GNU_VERSION &&
				    nh_descsz == 16) {
					uint32_t *desc =
					    (uint32_t *)&nbuf[offset];

					printf(", for GNU/");
					switch (getu32(swap, desc[0])) {
					case GNU_OS_LINUX:
						printf("Linux");
						break;
					case GNU_OS_HURD:
						printf("Hurd");
						break;
					case GNU_OS_SOLARIS:
						printf("Solaris");
						break;
					default:
						printf("<unknown>");
					}
					printf(" %d.%d.%d",
					    getu32(swap, desc[1]),
					    getu32(swap, desc[2]),
					    getu32(swap, desc[3]));
				}

				if (nh_namesz == 7 &&
				    strcmp(&nbuf[nameoffset], "NetBSD") == 0 &&
				    nh_type == NT_NETBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for NetBSD");
					/*
					 * Version number is stuck at 199905,
					 * and hence is basically content-free.
					 */
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "FreeBSD") == 0 &&
				    nh_type == NT_FREEBSD_VERSION &&
				    nh_descsz == 4) {
					uint32_t desc = getu32(swap,
					    *(uint32_t *)&nbuf[offset]);
					printf(", for FreeBSD");
					/*
					 * Contents is __FreeBSD_version,
					 * whose relation to OS versions is
					 * defined by a huge table in the
					 * Porters' Handbook.  Happily, the
					 * first three digits are the version
					 * number, at least in versions of
					 * FreeBSD that use this note.
					 */

					printf(" %d.%d", desc / 100000,
					    desc / 10000 % 10);
					if (desc / 1000 % 10 > 0)
						printf(".%d",
						    desc / 1000 % 10);
				}

				if (nh_namesz == 8 &&
				    strcmp(&nbuf[nameoffset], "OpenBSD") == 0 &&
				    nh_type == NT_OPENBSD_VERSION &&
				    nh_descsz == 4) {
					printf(", for OpenBSD");
					/* Content of note is always 0 */
				}
			}
			if ((lseek(fd, savedoffset + offset, SEEK_SET)) == -1)
				error("lseek failed (%s).\n", strerror(errno));
			break;
d78 1
a78 1
	printf(", %s linked%s", linking_style, shared_libraries);
d81 3
a83 10
#ifdef ELFCORE
size_t	prpsoffsets32[] = {
	8,		/* FreeBSD */
	28,		/* Linux 2.0.36 */
	32,		/* Linux (I forget which kernel version) */
	84,		/* SunOS 5.x */
};

size_t	prpsoffsets64[] = {
       120,		/* SunOS 5.x, 64-bit */
d86 1
a86 4
#define	NOFFSETS32	(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])
#define NOFFSETS64	(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])

#define NOFFSETS	(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)
d90 8
a97 17
 * for a PT_NOTE section of type NT_PRPSINFO, with a name "CORE" or
 * "FreeBSD"; if one is found, try looking in various places in its
 * contents for a 16-character string containing only printable
 * characters - if found, that string should be the name of the program
 * that dropped core.  Note: right after that 16-character string is,
 * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and
 * Linux, a longer string (80 characters, in 5.x, probably other
 * SVR4-flavored systems, and Linux) containing the start of the
 * command line for that program.
 *
 * The signal number probably appears in a section of type NT_PRSTATUS,
 * but that's also rather OS-dependent, in ways that are harder to
 * dissect with heuristics, so I'm not bothering with the signal number.
 * (I suppose the signal number could be of interest in situations where
 * you don't have the binary of the program that dropped core; if you
 * *do* have that binary, the debugger will probably tell you what
 * signal it was.)
a98 11

#define	OS_STYLE_SVR4		0
#define	OS_STYLE_FREEBSD	1
#define	OS_STYLE_NETBSD		2

static const char *os_style_names[] = {
	"SVR4",
	"FreeBSD",
	"NetBSD",
};

d100 6
a105 1
dophn_core(int class, int swap, int fd, off_t off, int num, size_t size)
d107 11
a117 5
	Elf32_Phdr ph32;
	Elf32_Nhdr *nh32 = NULL;
	Elf64_Phdr ph64;
	Elf64_Nhdr *nh64 = NULL;
	size_t offset, nameoffset, noffset, reloffset;
a121 1
	int os_style = -1;
a122 5
	if (size != ph_size)
		error("corrupted program header size.\n");
	/*
	 * Loop through all the program headers.
	 */
d125 3
a127 3
			error("lseek failed (%s).\n", strerror(errno));
		if (read(fd, ph_addr, ph_size) == -1)
			error("read failed (%s).\n", strerror(errno));
d129 1
a129 1
		if (ph_type != PT_NOTE)
d131 2
a132 7

		/*
		 * This is a PT_NOTE section; loop through all the notes
		 * in the section.
		 */
		if (lseek(fd, (off_t) ph_offset, SEEK_SET) == -1)
			error("lseek failed (%s).\n", strerror(errno));
d135 1
a135 1
			error(": " "read failed (%s).\n", strerror(errno));
d140 14
a153 5
			if (class == ELFCLASS32)
				nh32 = (Elf32_Nhdr *)&nbuf[offset];
			else
				nh64 = (Elf64_Nhdr *)&nbuf[offset];
			offset += nh_size;
d156 1
a156 2
			 * Check whether this note has the name "CORE" or
			 * "FreeBSD", or "NetBSD-CORE".
d158 1
a158 1
			if (offset + nh_namesz >= bufsize) {
d164 4
a167 3

			nameoffset = offset;
			offset += nh_namesz;
d171 8
a178 12
			 * Sigh.  The 2.0.36 kernel in Debian 2.1, at
			 * least, doesn't correctly implement name
			 * sections, in core dumps, as specified by
			 * the "Program Linking" section of "UNIX(R) System
			 * V Release 4 Programmer's Guide: ANSI C and
			 * Programming Support Tools", because my copy
			 * clearly says "The first 'namesz' bytes in 'name'
			 * contain a *null-terminated* [emphasis mine]
			 * character representation of the entry's owner
			 * or originator", but the 2.0.36 kernel code
			 * doesn't include the terminating null in the
			 * name....
d180 21
a200 22
			if (os_style == -1) {
				if ((nh_namesz == 4 &&
				     strncmp(&nbuf[nameoffset],
					    "CORE", 4) == 0) ||
				    (nh_namesz == 5 &&
				     strcmp(&nbuf[nameoffset],
				     	    "CORE") == 0)) {
					os_style = OS_STYLE_SVR4;
				} else
				if ((nh_namesz == 8 &&
				     strcmp(&nbuf[nameoffset],
				     	    "FreeBSD") == 0)) {
					os_style = OS_STYLE_FREEBSD;
				} else
				if ((nh_namesz >= 11 &&
				     strncmp(&nbuf[nameoffset],
				     	     "NetBSD-CORE", 11) == 0)) {
					os_style = OS_STYLE_NETBSD;
				} else
					continue;
				printf(", %s-style", os_style_names[os_style]);
			}
d202 4
a205 3
			if (os_style == OS_STYLE_NETBSD &&
			    nh_type == NT_NETBSD_CORE_PROCINFO) {
				uint32_t signo;
d208 1
a208 3
				 * Extract the program name.  It is at
				 * offset 0x7c, and is up to 32-bytes,
				 * including the terminating NUL.
d210 3
a212 76
				printf(", from '%.31s'", &nbuf[offset + 0x7c]);
				
				/*
				 * Extract the signal number.  It is at
				 * offset 0x08.
				 */
				memcpy(&signo, &nbuf[offset + 0x08],
				    sizeof(signo));
				printf(" (signal %u)", getu32(swap, signo));
			} else
			if (os_style != OS_STYLE_NETBSD &&
			    nh_type == NT_PRPSINFO) {
				/*
				 * Extract the program name.  We assume
				 * it to be 16 characters (that's what it
				 * is in SunOS 5.x and Linux).
				 *
				 * Unfortunately, it's at a different offset
				 * in varous OSes, so try multiple offsets.
				 * If the characters aren't all printable,
				 * reject it.
				 */
				for (i = 0; i < NOFFSETS; i++) {
					reloffset = prpsoffsets(i);
					noffset = offset + reloffset;
					for (j = 0; j < 16;
					    j++, noffset++, reloffset++) {
						/*
						 * Make sure we're not past
						 * the end of the buffer; if
						 * we are, just give up.
						 */
						if (noffset >= bufsize)
							goto tryanother;

						/*
						 * Make sure we're not past
						 * the end of the contents;
						 * if we are, this obviously
						 * isn't the right offset.
						 */
						if (reloffset >= nh_descsz)
							goto tryanother;

						c = nbuf[noffset];
						if (c == '\0') {
							/*
							 * A '\0' at the
							 * beginning is
							 * obviously wrong.
							 * Any other '\0'
							 * means we're done.
							 */
							if (j == 0)
								goto tryanother;
							else
								break;
						} else {
							/*
							 * A nonprintable
							 * character is also
							 * wrong.
							 */
#define isquote(c) (strchr("'\"`", (c)) != NULL)
							if (!isprint(c) ||
							     isquote(c))
								goto tryanother;
						}
					}

					/*
					 * Well, that worked.
					 */
					printf(", from '%.16s'",
					    &nbuf[offset + prpsoffsets(i)]);
					break;
d214 2
a215 4
				tryanother:
					;
				}
				break;
d217 1
a217 1
			offset += nh_descsz;
a221 1
#endif
d224 4
a227 1
tryelf(int fd, unsigned char *buf, int nbytes)
a232 8
	int class;
	int swap;

	/*
	 * If we can't seek, it must be a pipe, socket or fifo.
	 */
	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))
		fd = pipe2file(fd, buf, nbytes);
d240 1
a240 2
	if (buf[EI_MAG0] != ELFMAG0
	    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)
d245 1
a245 3
	class = buf[4];

	if (class == ELFCLASS32) {
d253 19
a271 19
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];

		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
#ifdef ELFCORE
			dophn_core(class, swap,
				   fd,
				   getu32(swap, elfhdr.e_phoff),
				   getu16(swap, elfhdr.e_phnum), 
				   getu16(swap, elfhdr.e_phentsize));
#else
			;
#endif
		else {
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				dophn_exec(class, swap,
					   fd,
					   getu32(swap, elfhdr.e_phoff),
					   getu16(swap, elfhdr.e_phnum), 
					   getu16(swap, elfhdr.e_phentsize));
a272 5
			doshn(class, swap,
			      fd,
			      getu32(swap, elfhdr.e_shoff),
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
d277 1
a277 1
        if (class == ELFCLASS64) {
a284 1
		swap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[5];
d286 13
a298 8
		if (getu16(swap, elfhdr.e_type) == ET_CORE) 
#ifdef ELFCORE
			dophn_core(class, swap,
				   fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
				   getu32(swap, elfhdr.e_phoff[1]),
#else
				   getu64(swap, elfhdr.e_phoff),
d300 7
a306 14
				   getu16(swap, elfhdr.e_phnum), 
				   getu16(swap, elfhdr.e_phentsize));
#else
			;
#endif
		else
		{
			if (getu16(swap, elfhdr.e_type) == ET_EXEC) {
				dophn_exec(class, swap,
					   fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
					   getu32(swap, elfhdr.e_phoff[1]),
#else
					   getu64(swap, elfhdr.e_phoff),
d308 2
a309 2
					   getu16(swap, elfhdr.e_phnum), 
					   getu16(swap, elfhdr.e_phentsize));
a310 9
			doshn(class, swap,
			      fd,
#ifdef USE_ARRAY_FOR_64BIT_TYPES
			      getu32(swap, elfhdr.e_shoff[1]),
#else
			      getu64(swap, elfhdr.e_shoff),
#endif
			      getu16(swap, elfhdr.e_shnum),
			      getu16(swap, elfhdr.e_shentsize));
@


1.2
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: readelf.c,v 1.1 1997/02/09 23:58:33 millert Exp $	*/
d230 2
a231 2
		int32 l;
		char c[sizeof (int32)];
@


1.1
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 1997/01/15 23:42:26 millert Exp $	*/
d34 1
a34 1
		error("lseek failed (%s).\n", strerror(errno));
d38 1
a38 1
			error("read failed (%s).\n", strerror(errno));
d64 1
a64 1
		error("lseek failed (%s).\n", strerror(errno));
d68 1
a68 1
  			error("read failed (%s).\n", strerror(errno));
d125 1
a125 1
			error("lseek failed (%s).\n", strerror(errno));
d127 1
a127 1
			error("read failed (%s).\n", strerror(errno));
d132 1
a132 1
			error("lseek failed (%s).\n", strerror(errno));
d135 1
a135 1
			error("read failed (%s).\n", strerror(errno));
@

