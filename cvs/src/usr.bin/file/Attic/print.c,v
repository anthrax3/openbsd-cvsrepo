head	1.18;
access;
symbols
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.14
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.12
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.10
	OPENBSD_5_0:1.16.0.8
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.14
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.12
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.10
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.8
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.6
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.4
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.6.0.14
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.12
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.6
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.04.24.16.24.11;	author nicm;	state dead;
branches;
next	1.17;
commitid	4VUU04TZM8ebPiy4;

1.17
date	2013.04.17.15.01.26;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.14.14.29.20;	author chl;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.11.15.47.17;	author gilles;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.22.24.08;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.19.19.39.38;	author millert;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	98.07.10.15.05.25;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.08.24.18.33.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.21.05.26;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.02.09.23.58.32;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.33.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2003.03.12.02.14.16;	author margarida;	state Exp;
branches;
next	;


desc
@@


1.18
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@/*	$OpenBSD: print.c,v 1.17 2013/04/17 15:01:26 deraadt Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * print.c - debugging printout routines
 */

#include "file.h"
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <time.h>

#define SZOF(a)	(sizeof(a) / sizeof(a[0]))

#ifndef COMPILE_ONLY
protected void
file_mdump(struct magic *m)
{
	private const char optyp[] = { FILE_OPS };

	(void) fprintf(stderr, "[%u", m->lineno);
	(void) fprintf(stderr, ">>>>>>>> %u" + 8 - (m->cont_level & 7),
		       m->offset);

	if (m->flag & INDIR) {
		(void) fprintf(stderr, "(%s,",
			       /* Note: type is unsigned */
			       (m->in_type < file_nnames) ? 
					file_names[m->in_type] : "*bad*");
		if (m->in_op & FILE_OPINVERSE)
			(void) fputc('~', stderr);
		(void) fprintf(stderr, "%c%u),",
			       ((m->in_op & FILE_OPS_MASK) < SZOF(optyp)) ? 
					optyp[m->in_op & FILE_OPS_MASK] : '?',
				m->in_offset);
	}
	(void) fprintf(stderr, " %s%s", (m->flag & UNSIGNED) ? "u" : "",
		       /* Note: type is unsigned */
		       (m->type < file_nnames) ? file_names[m->type] : "*bad*");
	if (m->mask_op & FILE_OPINVERSE)
		(void) fputc('~', stderr);

	if (IS_STRING(m->type)) {
		if (m->str_flags) {
			(void) fputc('/', stderr);
			if (m->str_flags & STRING_COMPACT_BLANK) 
				(void) fputc(CHAR_COMPACT_BLANK, stderr);
			if (m->str_flags & STRING_COMPACT_OPTIONAL_BLANK) 
				(void) fputc(CHAR_COMPACT_OPTIONAL_BLANK,
				    stderr);
			if (m->str_flags & STRING_IGNORE_LOWERCASE) 
				(void) fputc(CHAR_IGNORE_LOWERCASE, stderr);
			if (m->str_flags & STRING_IGNORE_UPPERCASE) 
				(void) fputc(CHAR_IGNORE_UPPERCASE, stderr);
			if (m->str_flags & REGEX_OFFSET_START) 
				(void) fputc(CHAR_REGEX_OFFSET_START, stderr);
		}
		if (m->str_range)
			(void) fprintf(stderr, "/%u", m->str_range);
	}
	else {
		if ((m->mask_op & FILE_OPS_MASK) < SZOF(optyp))
			(void) fputc(optyp[m->mask_op & FILE_OPS_MASK], stderr);
		else
			(void) fputc('?', stderr);
			
		if (m->num_mask) {
			(void) fprintf(stderr, "%.8llx",
			    (unsigned long long)m->num_mask);
		}
	}
	(void) fprintf(stderr, ",%c", m->reln);

	if (m->reln != 'x') {
		switch (m->type) {
		case FILE_BYTE:
		case FILE_SHORT:
		case FILE_LONG:
		case FILE_LESHORT:
		case FILE_LELONG:
		case FILE_MELONG:
		case FILE_BESHORT:
		case FILE_BELONG:
			(void) fprintf(stderr, "%d", m->value.l);
			break;
		case FILE_BEQUAD:
		case FILE_LEQUAD:
		case FILE_QUAD:
			(void) fprintf(stderr, "%lld",
			    (unsigned long long)m->value.q);
			break;
		case FILE_PSTRING:
		case FILE_STRING:
		case FILE_REGEX:
		case FILE_BESTRING16:
		case FILE_LESTRING16:
		case FILE_SEARCH:
			file_showstr(stderr, m->value.s, (size_t)m->vallen);
			break;
		case FILE_DATE:
		case FILE_LEDATE:
		case FILE_BEDATE:
		case FILE_MEDATE:
			(void)fprintf(stderr, "%s,",
			    file_fmttime(m->value.l, 1));
			break;
		case FILE_LDATE:
		case FILE_LELDATE:
		case FILE_BELDATE:
		case FILE_MELDATE:
			(void)fprintf(stderr, "%s,",
			    file_fmttime(m->value.l, 0));
			break;
		case FILE_QDATE:
		case FILE_LEQDATE:
		case FILE_BEQDATE:
			(void)fprintf(stderr, "%s,",
			    file_fmttime(m->value.q, 1));
			break;
		case FILE_QLDATE:
		case FILE_LEQLDATE:
		case FILE_BEQLDATE:
			(void)fprintf(stderr, "%s,",
			    file_fmttime(m->value.q, 0));
			break;
		case FILE_FLOAT:
		case FILE_BEFLOAT:
		case FILE_LEFLOAT:
			(void) fprintf(stderr, "%G", m->value.f);
			break;
		case FILE_DOUBLE:
		case FILE_BEDOUBLE:
		case FILE_LEDOUBLE:
			(void) fprintf(stderr, "%G", m->value.d);
			break;
		case FILE_DEFAULT:
			/* XXX - do anything here? */
			break;
		default:
			(void) fputs("*bad*", stderr);
			break;
		}
	}
	(void) fprintf(stderr, ",\"%s\"]\n", m->desc);
}
#endif

/*VARARGS*/
protected void
file_magwarn(struct magic_set *ms, const char *f, ...)
{
	va_list va;

	/* cuz we use stdout for most, stderr here */
	(void) fflush(stdout); 

	if (ms->file)
		(void) fprintf(stderr, "%s, %lu: ", ms->file,
		    (unsigned long)ms->line);
	(void) fprintf(stderr, "Warning: ");
	va_start(va, f);
	(void) vfprintf(stderr, f, va);
	va_end(va);
	(void) fputc('\n', stderr);
}

protected const char *
file_fmttime(uint64_t v, int local)
{
	char *pp;
	time_t t = (time_t)v;
	struct tm *tm;

	if (local) {
		pp = ctime(&t);
	} else {
#ifndef HAVE_DAYLIGHT
		private int daylight = 0;
#ifdef HAVE_TM_ISDST
		private time_t now = (time_t)0;

		if (now == (time_t)0) {
			struct tm *tm1;
			(void)time(&now);
			tm1 = localtime(&now);
			if (tm1 == NULL)
				return "*Invalid time*";
			daylight = tm1->tm_isdst;
		}
#endif /* HAVE_TM_ISDST */
#endif /* HAVE_DAYLIGHT */
		if (daylight)
			t += 3600;
		tm = gmtime(&t);
		if (tm == NULL)
			return "*Invalid time*";
		pp = asctime(tm);
	}

	pp[strcspn(pp, "\n")] = '\0';
	return pp;
}
@


1.17
log
@variety of fixes to correct large time_t code.  it is quite broken upstream.
ok chl
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.16 2009/10/27 23:59:37 deraadt Exp $ */
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.15 2009/04/24 18:54:34 chl Exp $ */
d149 1
a149 1
			    file_fmttime((uint32_t)m->value.q, 1));
d155 1
a155 1
			    file_fmttime((uint32_t)m->value.q, 0));
d199 1
a199 1
file_fmttime(uint32_t v, int local)
@


1.15
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.14 2008/05/08 01:40:56 chl Exp $ */
a42 4

#ifndef lint
FILE_RCSID("@@(#)$Id: print.c,v 1.14 2008/05/08 01:40:56 chl Exp $")
#endif  /* lint */
@


1.14
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.13 2007/09/14 14:29:20 chl Exp $ */
d45 1
a45 1
FILE_RCSID("@@(#)$Id: print.c,v 1.13 2007/09/14 14:29:20 chl Exp $")
d93 2
a94 2
		if (m->str_count)
			(void) fprintf(stderr, "/%u", m->str_count);
d161 10
a187 1
	va_start(va, f);
d192 5
a196 2
	(void) fprintf(stderr, "%s, %lu: Warning ", ms->file,
	    (unsigned long)ms->line);
@


1.13
log
@remove some warnings:
unused variable `variable'
`variable' might be used uninitialized in this function

ok gilles@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.12 2007/09/11 15:47:17 gilles Exp $ */
d45 1
a45 1
FILE_RCSID("@@(#)$Id: print.c,v 1.12 2007/09/11 15:47:17 gilles Exp $")
d54 4
a57 9
	private const char *typ[] = { "invalid", "byte", "short", "invalid",
				     "long", "string", "date", "beshort",
				     "belong", "bedate", "leshort", "lelong",
				     "ledate", "pstring", "ldate", "beldate",
				     "leldate", "regex" };
	private const char optyp[] = { '@@', '&', '|', '^', '+', '-', 
				      '*', '/', '%' };
	(void) fputc('[', stderr);
	(void) fprintf(stderr, ">>>>>>>> %d" + 8 - (m->cont_level & 7),
d63 2
a64 2
			       (m->in_type < SZOF(typ)) ? 
					typ[m->in_type] : "*bad*");
d67 3
a69 3
		(void) fprintf(stderr, "%c%d),",
			       ((m->in_op&0x7F) < SZOF(optyp)) ? 
					optyp[m->in_op&0x7F] : '?',
d74 1
a74 1
		       (m->type < SZOF(typ)) ? typ[m->type] : "*bad*");
d77 5
a81 11
	if (m->mask) {
		if ((m->mask_op & 0x7F) < SZOF(optyp)) 
			fputc(optyp[m->mask_op&0x7F], stderr);
		else
			fputc('?', stderr);
		if(FILE_STRING != m->type || FILE_PSTRING != m->type)
			(void) fprintf(stderr, "%.8x", m->mask);
		else {
			if (m->mask & STRING_IGNORE_LOWERCASE) 
				(void) fputc(CHAR_IGNORE_LOWERCASE, stderr);
			if (m->mask & STRING_COMPACT_BLANK) 
d83 1
a83 1
			if (m->mask & STRING_COMPACT_OPTIONAL_BLANK) 
d85 20
a104 1
				stderr);
a106 1

d116 1
d121 7
a128 1
		case FILE_PSTRING:
d130 4
a133 1
			file_showstr(stderr, m->value.s, ~0U);
d138 1
d145 1
d149 15
d175 1
a175 1
file_magwarn(const char *f, ...)
d183 2
a184 1
	(void) fprintf(stderr, "WARNING: ");
d187 1
a187 1
	fputc('\n', stderr);
d190 1
a190 1
protected char *
d209 2
d218 2
@


1.12
log
@use strcspn to properly overwrite '\n' in fgets returned buffer

ok pyr@@, ray@@, millert@@, moritz@@, chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.11 2004/05/19 02:32:35 tedu Exp $ */
d45 1
a45 1
FILE_RCSID("@@(#)$Id: print.c,v 1.11 2004/05/19 02:32:35 tedu Exp $")
d158 1
a158 1
	char *pp, *rt;
@


1.11
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 1
a45 1
FILE_RCSID("@@(#)$Id: print.c,v 1.44 2003/09/12 19:39:44 christos Exp $")
d184 1
a184 2
	if ((rt = strchr(pp, '\n')) != NULL)
		*rt = '\0';
@


1.10
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 2
/*	$OpenBSD: print.c,v 1.9 2003/03/11 21:26:26 ian Exp $	*/

a2 2
 * print.c - debugging printout routines
 *
d29 3
d33 1
d39 1
d41 1
a42 2
#include <err.h>
#include "file.h"
d45 1
a45 1
static char *moduleid = "$OpenBSD: print.c,v 1.9 2003/03/11 21:26:26 ian Exp $";
d50 3
a52 3
void
mdump(m)
struct magic *m;
d54 7
a60 4
	static char *typ[] = {   "invalid", "byte", "short", "invalid",
				 "long", "string", "date", "beshort",
				 "belong", "bedate", "leshort", "lelong",
				 "ledate" };
d65 12
a76 7
	if (m->flag & INDIR)
		(void) fprintf(stderr, "(%s,%d),",
			       (m->in.type >= 0 && m->in.type < SZOF(typ)) ? 
					typ[(unsigned char) m->in.type] :
					"*bad*",
			       m->in.offset);

d78 21
a98 5
		       (m->type >= 0 && m->type < SZOF(typ)) ? 
				typ[(unsigned char) m->type] : 
				"*bad*");
	if (m->mask != ~0)
		(void) fprintf(stderr, " & %.8x", m->mask);
d103 31
a133 29
	    switch (m->type) {
	    case BYTE:
	    case SHORT:
	    case LONG:
	    case LESHORT:
	    case LELONG:
	    case BESHORT:
	    case BELONG:
		    (void) fprintf(stderr, "%d", m->value.l);
		    break;
	    case STRING:
		    showstr(stderr, m->value.s, -1);
		    break;
	    case DATE:
	    case LEDATE:
	    case BEDATE:
		    {
			    char *rt, *pp = ctime((time_t*) &m->value.l);
			    if ((rt = strchr(pp, '\n')) != NULL)
				    *rt = '\0';
			    (void) fprintf(stderr, "%s,", pp);
			    if (rt)
				    *rt = '\n';
		    }
		    break;
	    default:
		    (void) fputs("*bad*", stderr);
		    break;
	    }
d137 1
d139 3
a141 5
/*
 * This "error" is here so we don't have to change all occurrences of
 * error() to err(1,...) when importing new versions from Christos.
 */
void error(const char *fmt, ...)
d144 4
a147 3
	va_start(va, fmt);
	verr(1, fmt, va);
}
d149 4
a152 11
/*
 * ckfputs - futs, but with error checking
 * ckfprintf - fprintf, but with error checking
 */
void
ckfputs(str, fil) 	
    const char *str;
    FILE *fil;
{
	if (fputs(str,fil) == EOF)
		err(1, "write failed");
d155 2
a156 3
/*VARARGS*/
void
ckfprintf(FILE *f, const char *fmt, ...)
d158 25
a182 1
	va_list va;
d184 3
a186 5
	va_start(va, fmt);
	(void) vfprintf(f, fmt, va);
	if (ferror(f))
		err(1, "write failed");
	va_end(va);
@


1.9
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.8 2003/03/03 22:24:08 ian Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d44 1
a44 1
static char *moduleid = "$OpenBSD: print.c,v 1.8 2003/03/03 22:24:08 ian Exp $";
@


1.8
log
@Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.7 2002/02/19 19:39:38 millert Exp $	*/
d6 30
a35 22
 * Copyright (c) Ian F. Darwin, 1987.
 * Written by Ian F. Darwin.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or of the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. The author is not responsible for the consequences of use of this
 *    software, no matter how awful, even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Since few users ever read sources,
 *    credits must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.  Since few users
 *    ever read sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
d49 1
a49 1
static char *moduleid = "$OpenBSD: print.c,v 1.7 2002/02/19 19:39:38 millert Exp $";
@


1.7
log
@We live in an ANSI C world.  Remove lots of gratuitous #ifdef __STDC__ cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.6 1998/07/10 15:05:25 mickey Exp $	*/
d41 1
a41 1
static char *moduleid = "$OpenBSD: print.c,v 1.6 1998/07/10 15:05:25 mickey Exp $";
d106 11
@


1.7.4.1
log
@Pull patch from current.
Fix by ian@@
Bring in readelf.c from Christos' version 3.41 to head off a local
stack attack noted by iDefense, and for more complete 64-bit ELF support.
Add hand-made config.h to avoid running configure but still be able
to use Christos' code.  In print.c add error(...)-->err(1,...) wrapper.
Tested on i386, sparc64, macppc.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.8 2003/03/03 22:24:08 ian Exp $	*/
d41 1
a41 1
static char *moduleid = "$OpenBSD: print.c,v 1.8 2003/03/03 22:24:08 ian Exp $";
a105 11
}

/*
 * This "error" is here so we don't have to change all occurrences of
 * error() to err(1,...) when importing new versions from Christos.
 */
void error(const char *fmt, ...)
{
	va_list va;
	va_start(va, fmt);
	verr(1, fmt, va);
@


1.6
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.5 1997/08/24 18:33:12 millert Exp $	*/
d33 1
a33 5
#ifdef __STDC__
# include <stdarg.h>
#else
# include <varargs.h>
#endif
d41 1
a41 1
static char *moduleid = "$OpenBSD: print.c,v 1.5 1997/08/24 18:33:12 millert Exp $";
a122 1
#ifdef __STDC__
a123 4
#else
ckfprintf(va_alist)
	va_dcl
#endif
d126 1
a126 1
#ifdef __STDC__
a127 7
#else
	FILE *f;
	const char *fmt;
	va_start(va);
	f = va_arg(va, FILE *);
	fmt = va_arg(va, const char *);
#endif
@


1.5
log
@64bit fix: don't mix long & int.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.4 1997/07/25 21:05:26 mickey Exp $	*/
d41 1
d45 1
a45 1
static char *moduleid = "$OpenBSD: print.c,v 1.4 1997/07/25 21:05:26 mickey Exp $";
d122 1
a122 1
		error("write failed.\n");
d146 1
a146 1
		error("write failed.\n");
a147 58
}

/*
 * error - print best error message possible and exit
 */
/*VARARGS*/
void
#ifdef __STDC__
error(const char *f, ...)
#else
error(va_alist)
	va_dcl
#endif
{
	va_list va;
#ifdef __STDC__
	va_start(va, f);
#else
	const char *f;
	va_start(va);
	f = va_arg(va, const char *);
#endif
	/* cuz we use stdout for most, stderr here */
	(void) fflush(stdout); 

	if (progname != NULL) 
		(void) fprintf(stderr, "%s: ", progname);
	(void) vfprintf(stderr, f, va);
	va_end(va);
	exit(1);
}

/*VARARGS*/
void
#ifdef __STDC__
magwarn(const char *f, ...)
#else
magwarn(va_alist)
	va_dcl
#endif
{
	va_list va;
#ifdef __STDC__
	va_start(va, f);
#else
	const char *f;
	va_start(va);
	f = va_arg(va, const char *);
#endif
	/* cuz we use stdout for most, stderr here */
	(void) fflush(stdout); 

	if (progname != NULL) 
		(void) fprintf(stderr, "%s: %s, %d: ", 
			       progname, magicfile, lineno);
	(void) vfprintf(stderr, f, va);
	va_end(va);
	fputc('\n', stderr);
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.3 1997/02/09 23:58:32 millert Exp $	*/
d44 1
a44 1
static char *moduleid = "$OpenBSD: print.c,v 1.3 1997/02/09 23:58:32 millert Exp $";
d72 1
a72 1
	if (m->mask != ~0L)
@


1.3
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: print.c,v 1.2 1996/06/26 05:33:00 deraadt Exp $	*/
d33 1
a33 1
#if __STDC__
d44 1
a44 1
static char *moduleid = "$OpenBSD: print.c,v 1.2 1996/06/26 05:33:00 deraadt Exp $";
d126 1
a126 1
#if __STDC__
d134 1
a134 1
#if __STDC__
d154 1
a154 1
#if __STDC__
d162 1
a162 1
#if __STDC__
d181 1
a181 1
#if __STDC__
d189 1
a189 1
#if __STDC__
@


1.2
log
@rcsid
@
text
@d1 2
a2 1
/*	$OpenBSD: print.c,v 1.1.1.1 1995/10/18 08:45:09 deraadt Exp $	*/
d44 1
a44 1
static char *moduleid = "$OpenBSD$";
d62 1
a62 1
		(void) fprintf(stderr, "(%s,%ld),",
d73 1
a73 1
		(void) fprintf(stderr, " & %.8lx", m->mask);
d86 1
a86 1
		    (void) fprintf(stderr, "%ld", m->value.l);
@


1.1
log
@Initial revision
@
text
@d1 1
d43 1
a43 2
static char *moduleid =
	"@@(#)$Id: print.c,v 1.8 1995/04/30 19:39:40 christos Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
