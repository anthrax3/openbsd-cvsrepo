head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.32
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.30
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.26
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.28
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.20
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.24
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.22
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.18
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.16
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.14
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.12
	OPENBSD_5_0:1.4.0.10
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.8
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.16
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.14
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.12
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.10
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.0.6
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.4
	OPENBSD_3_4_BASE:1.1
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@# @;


1.4
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.08.01.40.57;	author chl;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.03.03.14.20;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.04.03.19.26;	author ian;	state Exp;
branches;
next	;


desc
@@


1.4
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@#	$OpenBSD: jpeg,v 1.3 2008/05/08 01:40:57 chl Exp $

#------------------------------------------------------------------------------
# JPEG images
# SunOS 5.5.1 had
#
#	0	string		\377\330\377\340	JPEG file
#	0	string		\377\330\377\356	JPG file
#
# both of which turn into "JPEG image data" here.
#
0	beshort		0xffd8		JPEG image data
!:mime	image/jpeg
>6	string		JFIF		\b, JFIF standard
# The following added by Erik Rossen <rossen@@freesurf.ch> 1999-09-06
# in a vain attempt to add image size reporting for JFIF.  Note that these
# tests are not fool-proof since some perfectly valid JPEGs are currently
# impossible to specify in magic(4) format.
# First, a little JFIF version info:
>>11	byte		x		\b %d.
>>12	byte		x		\b%02d
# Next, the resolution or aspect ratio of the image:
#>>13	byte		0		\b, aspect ratio
#>>13	byte		1		\b, resolution (DPI)
#>>13	byte		2		\b, resolution (DPCM)
#>>4	beshort		x		\b, segment length %d
# Next, show thumbnail info, if it exists:
>>18	byte		!0		\b, thumbnail %dx
>>>19	byte		x		\b%d

# EXIF moved down here to avoid reporting a bogus version number,
# and EXIF version number printing added.
#   - Patrik R=E5dman <patrik+file-magic@@iki.fi>
>6	string		Exif		\b, EXIF standard
# Look for EXIF IFD offset in IFD 0, and then look for EXIF version tag in EXIF IFD.
# All possible combinations of entries have to be enumerated, since no looping
# is possible. And both endians are possible...
# The combinations included below are from real-world JPEGs.
# Little-endian
>>12	string		II		
# IFD 0 Entry #5:
>>>70	leshort		0x8769          
# EXIF IFD Entry #1:
>>>>(78.l+14)	leshort	0x9000		
>>>>>(78.l+23)	byte	x		%c
>>>>>(78.l+24)	byte	x		\b.%c
>>>>>(78.l+25)	byte	!0x30		\b%c
# IFD 0 Entry #9:
>>>118	leshort		0x8769          
# EXIF IFD Entry #3:
>>>>(126.l+38)	leshort	0x9000		
>>>>>(126.l+47)	byte	x		%c
>>>>>(126.l+48)	byte	x		\b.%c
>>>>>(126.l+49)	byte	!0x30		\b%c
# IFD 0 Entry #10
>>>130	leshort		0x8769          
# EXIF IFD Entry #3:
>>>>(138.l+38)	leshort	0x9000		
>>>>>(138.l+47)	byte	x		%c
>>>>>(138.l+48)	byte	x		\b.%c
>>>>>(138.l+49)	byte	!0x30		\b%c
# EXIF IFD Entry #4:
>>>>(138.l+50)	leshort	0x9000		
>>>>>(138.l+59)	byte	x		%c
>>>>>(138.l+60)	byte	x		\b.%c
>>>>>(138.l+61)	byte	!0x30		\b%c
# EXIF IFD Entry #5:
>>>>(138.l+62)	leshort	0x9000		
>>>>>(138.l+71)	byte	x		%c
>>>>>(138.l+72)	byte	x		\b.%c
>>>>>(138.l+73)	byte	!0x30		\b%c
# IFD 0 Entry #11
>>>142	leshort		0x8769          
# EXIF IFD Entry #3:
>>>>(150.l+38)	leshort	0x9000		
>>>>>(150.l+47)	byte	x		%c
>>>>>(150.l+48)	byte	x		\b.%c
>>>>>(150.l+49)	byte	!0x30		\b%c
# EXIF IFD Entry #4:
>>>>(150.l+50)	leshort	0x9000		
>>>>>(150.l+59)	byte	x		%c
>>>>>(150.l+60)	byte	x		\b.%c
>>>>>(150.l+61)	byte	!0x30		\b%c
# EXIF IFD Entry #5:
>>>>(150.l+62)	leshort	0x9000		
>>>>>(150.l+71)	byte	x		%c
>>>>>(150.l+72)	byte	x		\b.%c
>>>>>(150.l+73)	byte	!0x30		\b%c
# Big-endian
>>12	string		MM		
# IFD 0 Entry #9:
>>>118	beshort		0x8769          
# EXIF IFD Entry #1:
>>>>(126.L+14)	beshort	0x9000		
>>>>>(126.L+23)	byte	x		%c
>>>>>(126.L+24)	byte	x		\b.%c
>>>>>(126.L+25)	byte	!0x30		\b%c
# EXIF IFD Entry #3:
>>>>(126.L+38)	beshort	0x9000		
>>>>>(126.L+47)	byte	x		%c
>>>>>(126.L+48)	byte	x		\b.%c
>>>>>(126.L+49)	byte	!0x30		\b%c
# IFD 0 Entry #10
>>>130	beshort		0x8769          
# EXIF IFD Entry #3:
>>>>(138.L+38)	beshort	0x9000		
>>>>>(138.L+47)	byte	x		%c
>>>>>(138.L+48)	byte	x		\b.%c
>>>>>(138.L+49)	byte	!0x30		\b%c
# EXIF IFD Entry #5:
>>>>(138.L+62)	beshort	0x9000		
>>>>>(138.L+71)	byte	x		%c
>>>>>(138.L+72)	byte	x		\b.%c
>>>>>(138.L+73)	byte	!0x30		\b%c
# IFD 0 Entry #11
>>>142	beshort		0x8769          
# EXIF IFD Entry #4:
>>>>(150.L+50)	beshort	0x9000		
>>>>>(150.L+59)	byte	x		%c
>>>>>(150.L+60)	byte	x		\b.%c
>>>>>(150.L+61)	byte	!0x30		\b%c
# Here things get sticky.  We can do ONE MORE marker segment with
# indirect addressing, and that's all.  It would be great if we could
# do pointer arithemetic like in an assembler language.  Christos?
# And if there was some sort of looping construct to do searches, plus a few
# named accumulators, it would be even more effective...
# At least we can show a comment if no other segments got inserted before:
>(4.S+5)	byte		0xFE
>>(4.S+8)	string		>\0		\b, comment: "%s"
#>(4.S+5)	byte		0xFE		\b, comment
#>>(4.S+6)	beshort		x		\b length=%d
#>>(4.S+8)	string		>\0		\b, "%s"
# Or, we can show the encoding type (I've included only the three most common)
# and image dimensions if we are lucky and the SOFn (image segment) is here:
>(4.S+5)	byte		0xC0		\b, baseline
>>(4.S+6)	byte		x		\b, precision %d
>>(4.S+7)	beshort		x		\b, %dx
>>(4.S+9)	beshort		x		\b%d
>(4.S+5)	byte		0xC1		\b, extended sequential
>>(4.S+6)	byte		x		\b, precision %d
>>(4.S+7)	beshort		x		\b, %dx
>>(4.S+9)	beshort		x		\b%d
>(4.S+5)	byte		0xC2		\b, progressive
>>(4.S+6)	byte		x		\b, precision %d
>>(4.S+7)	beshort		x		\b, %dx
>>(4.S+9)	beshort		x		\b%d
# I've commented-out quantisation table reporting.  I doubt anyone cares yet.
#>(4.S+5)	byte		0xDB		\b, quantisation table
#>>(4.S+6)	beshort		x		\b length=%d
#>14	beshort		x		\b, %d x
#>16	beshort		x		\b %d

# HSI is Handmade Software's proprietary JPEG encoding scheme
0	string		hsi1		JPEG image data, HSI proprietary

# From: David Santinoli <david@@santinoli.com>
0	string		\x00\x00\x00\x0C\x6A\x50\x20\x20\x0D\x0A\x87\x0A	JPEG 2000 image data

# Type: JPEG 2000 codesream
# From: Mathieu Malaterre <mathieu.malaterre@@gmail.com>
0	belong		0xff4fff51						JPEG 2000 codestream
45	beshort		0xff52
@


1.3
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: jpeg,v 1.2 2004/06/03 03:14:20 tedu Exp $
d13 1
d158 5
@


1.2
log
@merge in new magic from file 4.09.  Mostly from Bruno Rohee
@
text
@d1 1
a1 1
#	$OpenBSD$
a13 1
>6	string		Exif		\b, EXIF standard
d19 2
a20 2
>11	byte		x		\b %d.
>12	byte		x		\b%02d
d22 4
a25 4
#>13	byte		0		\b, aspect ratio
#>13	byte		1		\b, resolution (DPI)
#>13	byte		2		\b, resolution (DPCM)
#>4	beshort		x		\b, segment length %d
d27 94
a120 2
>18	byte		!0		\b, thumbnail %dx
>>19	byte		x		\b%d
d128 1
a128 1
>>(4.S+8)	string		>\0		\b, "%s"
@


1.1
log
@Interim JPEG size support; PNG and other lesser image formats added.
@
text
@d1 1
d23 3
a25 3
>13	byte		0		\b, aspect ratio
>13	byte		1		\b, resolution (DPI)
>13	byte		2		\b, resolution (DPCM)
d58 2
a59 2
>14	beshort		x		\b, %d x
>16	beshort		x		\b %d
@

