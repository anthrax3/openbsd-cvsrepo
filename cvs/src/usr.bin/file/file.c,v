head	1.63;
access;
symbols
	OPENBSD_6_1:1.58.0.6
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.23.0.16
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.14
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.6
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.4
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.8
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.7.0.12
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.63
date	2017.06.28.17.14.15;	author brynet;	state Exp;
branches;
next	1.62;
commitid	oDFQfQXYu114XZKS;

1.62
date	2017.06.28.15.42.49;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	17gWQmc6WVMESglM;

1.61
date	2017.06.28.15.40.54;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	HMhkDMDg01xD3rZt;

1.60
date	2017.06.28.13.37.56;	author brynet;	state Exp;
branches;
next	1.59;
commitid	4DDAMOSxi4KVPPvg;

1.59
date	2017.04.18.14.16.48;	author nicm;	state Exp;
branches;
next	1.58;
commitid	JObUpQGTRStjKJXF;

1.58
date	2016.05.01.20.34.26;	author nicm;	state Exp;
branches;
next	1.57;
commitid	9Fc5iJrGyxGRfZc0;

1.57
date	2015.12.24.11.45.34;	author jca;	state Exp;
branches;
next	1.56;
commitid	RIVtYu1RhflEh8Tu;

1.56
date	2015.12.05.13.18.09;	author claudio;	state Exp;
branches;
next	1.55;
commitid	GLrs4jmW5LoUsYf6;

1.55
date	2015.11.13.08.32.10;	author nicm;	state Exp;
branches;
next	1.54;
commitid	vS0XYm4S9l0ZnCrU;

1.54
date	2015.11.13.08.30.18;	author nicm;	state Exp;
branches;
next	1.53;
commitid	y1o9SgaVwEMRsFBr;

1.53
date	2015.10.17.04.41.37;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	CCb80IKaYZam04Cg;

1.52
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	sbrB3Q5CNxcwZpfU;

1.51
date	2015.10.06.15.39.44;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	Ytytyuwcp2O4NL3A;

1.50
date	2015.10.05.06.23.34;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	LDLOLNYY4TJhMyO7;

1.49
date	2015.10.04.07.25.59;	author nicm;	state Exp;
branches;
next	1.48;
commitid	dqw6dqZelGQB4GLZ;

1.48
date	2015.10.02.18.06.27;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	wAPE3Qpi3cDOGWss;

1.47
date	2015.07.12.09.51.25;	author tobias;	state Exp;
branches;
next	1.46;
commitid	dvMf50IRGXbCQLBt;

1.46
date	2015.07.08.17.49.45;	author tobias;	state Exp;
branches;
next	1.45;
commitid	4IXeVwQOHJDUicBB;

1.45
date	2015.05.30.06.25.35;	author nicm;	state Exp;
branches;
next	1.44;
commitid	03wotVZX3iCHcRkm;

1.44
date	2015.05.29.15.58.34;	author nicm;	state Exp;
branches;
next	1.43;
commitid	147ZWb5defUBrhjw;

1.43
date	2015.05.29.12.33.41;	author nicm;	state Exp;
branches;
next	1.42;
commitid	jIIBGuuv2HYLnpd2;

1.42
date	2015.05.29.11.59.01;	author nicm;	state Exp;
branches;
next	1.41;
commitid	eBc4akMxwYzTX4sw;

1.41
date	2015.05.29.11.03.37;	author nicm;	state Exp;
branches;
next	1.40;
commitid	3zyFm4603T81ccyh;

1.40
date	2015.05.29.07.30.28;	author nicm;	state Exp;
branches;
next	1.39;
commitid	q1Ya8O0dFYCeEq85;

1.39
date	2015.05.28.19.26.37;	author jmc;	state Exp;
branches;
next	1.38;
commitid	0DsSafF3fZLR7iuu;

1.38
date	2015.05.18.11.57.52;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	wlfdU7BegzaUAZIo;

1.37
date	2015.04.28.02.26.43;	author lteo;	state Exp;
branches;
next	1.36;
commitid	QxS0RF8Sg4kSbNPu;

1.36
date	2015.04.27.13.52.17;	author nicm;	state Exp;
branches;
next	1.35;
commitid	hZDBTMiQdWyr3asB;

1.35
date	2015.04.27.13.41.45;	author nicm;	state Exp;
branches;
next	1.34;
commitid	2EKcnUf9L3xLVo15;

1.34
date	2015.04.26.22.51.32;	author nicm;	state Exp;
branches;
next	1.33;
commitid	mtXIburVXEyiHueG;

1.33
date	2015.04.26.19.53.50;	author nicm;	state Exp;
branches;
next	1.32;
commitid	tJD5ToJDtdoTDR2o;

1.32
date	2015.04.24.17.34.57;	author nicm;	state Exp;
branches;
next	1.31;
commitid	CaRea3jzwV1rFe2T;

1.31
date	2015.04.24.17.10.50;	author nicm;	state Exp;
branches;
next	1.30;
commitid	KjoFI6FTMRImSzk1;

1.30
date	2015.04.24.16.47.32;	author nicm;	state Exp;
branches;
next	1.29;
commitid	AfcBhllyOgpBXu9w;

1.29
date	2015.04.24.16.30.06;	author nicm;	state Exp;
branches;
next	1.28;
commitid	Tj9XRz5lUvG931j7;

1.28
date	2015.04.24.16.28.00;	author nicm;	state Exp;
branches;
next	1.27;
commitid	lho9I6GYxAMPGaxl;

1.27
date	2015.04.24.16.24.11;	author nicm;	state Exp;
branches;
next	1.26;
commitid	4VUU04TZM8ebPiy4;

1.26
date	2015.01.16.18.08.15;	author millert;	state Exp;
branches;
next	1.25;
commitid	YSfteyP6tDfW8ZsE;

1.25
date	2015.01.16.08.24.04;	author doug;	state Exp;
branches;
next	1.24;
commitid	3kmy59NzQyG8Ee1H;

1.24
date	2015.01.16.05.46.44;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	xaoJpzDupP01XiYp;

1.23
date	2011.04.15.16.05.34;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.26.21.03.55;	author ajacoutot;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.27.16.26.43;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.24.18.54.34;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.08.01.40.56;	author chl;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.19.13.02.08;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.04.19.55.12;	author jaredy;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.25.09.19.35;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.19.02.32.35;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.15.13.30.17;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.29.00.27.03;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.46;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.02.19.00.28.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.07.10.15.05.20;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	97.02.09.23.58.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.42.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.32.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.03.30.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Fix stdin file read support, accidentally broken in my last commit.
@
text
@/* $OpenBSD: file.c,v 1.62 2017/06/28 15:42:49 deraadt Exp $ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <libgen.h>
#include <limits.h>
#include <pwd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "file.h"
#include "magic.h"
#include "xmalloc.h"

struct input_file {
	struct magic	*m;

	const char	*path;
	struct stat	 sb;
	int		 fd;
	int		 error;

	char		 link_path[PATH_MAX];
	int		 link_error;
	int		 link_target;

	void		*base;
	size_t		 size;
	int		 mapped;
	char		*result;
};

extern char	*__progname;

__dead void	 usage(void);

static void	 prepare_input(struct input_file *, const char *);

static void	 read_link(struct input_file *, const char *);

static void	 test_file(struct input_file *, size_t);

static int	 try_stat(struct input_file *);
static int	 try_empty(struct input_file *);
static int	 try_access(struct input_file *);
static int	 try_text(struct input_file *);
static int	 try_magic(struct input_file *);
static int	 try_unknown(struct input_file *);

static int	 bflag;
static int	 cflag;
static int	 iflag;
static int	 Lflag;
static int	 sflag;
static int	 Wflag;

static struct option longopts[] = {
	{ "brief",       no_argument, NULL, 'b' },
	{ "dereference", no_argument, NULL, 'L' },
	{ "mime",        no_argument, NULL, 'i' },
	{ "mime-type",   no_argument, NULL, 'i' },
	{ NULL,          0,           NULL, 0   }
};

__dead void
usage(void)
{
	fprintf(stderr, "usage: %s [-bchiLsW] file ...\n", __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	int			 opt, idx;
	char			*home, *magicpath;
	struct passwd		*pw;
	FILE			*magicfp = NULL;
	struct magic		*m;
	struct input_file	*inf = NULL;
	size_t			 len, width = 0;

	if (pledge("stdio rpath getpw id", NULL) == -1)
		err(1, "pledge");

	for (;;) {
		opt = getopt_long(argc, argv, "bchiLsW", longopts, NULL);
		if (opt == -1)
			break;
		switch (opt) {
		case 'b':
			bflag = 1;
			break;
		case 'c':
			cflag = 1;
			break;
		case 'h':
			Lflag = 0;
			break;
		case 'i':
			iflag = 1;
			break;
		case 'L':
			Lflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case 'W':
			Wflag = 1;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;
	if (cflag) {
		if (argc != 0)
			usage();
	} else if (argc == 0)
		usage();

	if (geteuid() != 0 && !issetugid()) {
		home = getenv("HOME");
		if (home == NULL || *home == '\0') {
			pw = getpwuid(getuid());
			if (pw != NULL)
				home = pw->pw_dir;
			else
				home = NULL;
		}
		if (home != NULL) {
			xasprintf(&magicpath, "%s/.magic", home);
			magicfp = fopen(magicpath, "r");
			if (magicfp == NULL)
				free(magicpath);
		}
	}
	if (magicfp == NULL) {
		magicpath = xstrdup("/etc/magic");
		magicfp = fopen(magicpath, "r");
	}
	if (magicfp == NULL)
		err(1, "%s", magicpath);

	if (!cflag) {
		inf = xcalloc(argc, sizeof *inf);
		for (idx = 0; idx < argc; idx++) {
			len = strlen(argv[idx]) + 1;
			if (len > width)
				width = len;
			prepare_input(&inf[idx], argv[idx]);
		}
	}

	tzset();

	if (pledge("stdio getpw id", NULL) == -1)
		err(1, "pledge");

	if (geteuid() == 0) {
		pw = getpwnam(FILE_USER);
		if (pw == NULL)
			errx(1, "unknown user %s", FILE_USER);
		if (setgroups(1, &pw->pw_gid) != 0)
			err(1, "setgroups");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
			err(1, "setresgid");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
			err(1, "setresuid");
	}

	if (pledge("stdio", NULL) == -1)
		err(1, "pledge");

	m = magic_load(magicfp, magicpath, cflag || Wflag);
	if (cflag) {
		magic_dump(m);
		exit(0);
	}
	fclose(magicfp);

	for (idx = 0; idx < argc; idx++) {
		inf[idx].m = m;
		test_file(&inf[idx], width);
	}
	exit(0);
}

static void
prepare_input(struct input_file *inf, const char *path)
{
	int	fd, mode, error;

	inf->path = path;

	if (strcmp(path, "-") == 0) {
		if (fstat(STDIN_FILENO, &inf->sb) == -1) {
			inf->error = errno;
			inf->fd = -1;
			return;
		}
		inf->fd = STDIN_FILENO;
		return;
	}

	if (Lflag)
		error = stat(path, &inf->sb);
	else
		error = lstat(path, &inf->sb);
	if (error == -1) {
		inf->error = errno;
		inf->fd = -1;
		return;
	}

	/* We don't need them, so don't open directories or symlinks. */
	mode = inf->sb.st_mode;
	if (!S_ISDIR(mode) && !S_ISLNK(mode)) {
		fd = open(path, O_RDONLY|O_NONBLOCK);
		if (fd == -1 && (errno == ENFILE || errno == EMFILE))
			err(1, "open");
	} else
		fd = -1;
	if (S_ISLNK(mode))
		read_link(inf, path);
	inf->fd = fd;
}

static void
read_link(struct input_file *inf, const char *path)
{
	struct stat	 sb;
	char		 lpath[PATH_MAX];
	char		*copy, *root;
	int		 used;
	ssize_t		 size;

	size = readlink(path, lpath, sizeof lpath - 1);
	if (size == -1) {
		inf->link_error = errno;
		return;
	}
	lpath[size] = '\0';

	if (*lpath == '/')
		strlcpy(inf->link_path, lpath, sizeof inf->link_path);
	else {
		copy = xstrdup(path);

		root = dirname(copy);
		if (*root == '\0' || strcmp(root, ".") == 0 ||
		    strcmp (root, "/") == 0)
			strlcpy(inf->link_path, lpath, sizeof inf->link_path);
		else {
			used = snprintf(inf->link_path, sizeof inf->link_path,
			    "%s/%s", root, lpath);
			if (used < 0 || (size_t)used >= sizeof inf->link_path) {
				inf->link_error = ENAMETOOLONG;
				free(copy);
				return;
			}
		}

		free(copy);
	}

	if (!Lflag && stat(path, &sb) == -1)
		inf->link_target = errno;
}

static void *
fill_buffer(int fd, size_t size, size_t *used)
{
	static void	*buffer;
	ssize_t		 got;
	size_t		 left;
	void		*next;

	if (buffer == NULL)
		buffer = xmalloc(FILE_READ_SIZE);

	next = buffer;
	left = size;
	while (left != 0) {
		got = read(fd, next, left);
		if (got == -1) {
			if (errno == EINTR)
				continue;
			return (NULL);
		}
		if (got == 0)
			break;
		next = (char *)next + got;
		left -= got;
	}
	*used = size - left;
	return (buffer);
}

static int
load_file(struct input_file *inf)
{
	size_t	used;

	if (inf->sb.st_size == 0 && S_ISREG(inf->sb.st_mode))
		return (0); /* empty file */
	if (inf->sb.st_size == 0 || inf->sb.st_size > FILE_READ_SIZE)
		inf->size = FILE_READ_SIZE;
	else
		inf->size = inf->sb.st_size;

	if (!S_ISREG(inf->sb.st_mode))
		goto try_read;

	inf->base = mmap(NULL, inf->size, PROT_READ, MAP_PRIVATE, inf->fd, 0);
	if (inf->base == MAP_FAILED)
		goto try_read;
	inf->mapped = 1;
	return (0);

try_read:
	inf->base = fill_buffer(inf->fd, inf->size, &used);
	if (inf->base == NULL) {
		xasprintf(&inf->result, "cannot read '%s' (%s)", inf->path,
		    strerror(errno));
		return (1);
	}
	inf->size = used;
	return (0);
}

static int
try_stat(struct input_file *inf)
{
	if (inf->error != 0) {
		xasprintf(&inf->result, "cannot stat '%s' (%s)", inf->path,
		    strerror(inf->error));
		return (1);
	}
	if (sflag || strcmp(inf->path, "-") == 0) {
		switch (inf->sb.st_mode & S_IFMT) {
		case S_IFIFO:
			if (strcmp(inf->path, "-") != 0)
				break;
		case S_IFBLK:
		case S_IFCHR:
		case S_IFREG:
			return (0);
		}
	}

	if (iflag && (inf->sb.st_mode & S_IFMT) != S_IFREG) {
		xasprintf(&inf->result, "application/x-not-regular-file");
		return (1);
	}

	switch (inf->sb.st_mode & S_IFMT) {
	case S_IFDIR:
		xasprintf(&inf->result, "directory");
		return (1);
	case S_IFLNK:
		if (inf->link_error != 0) {
			xasprintf(&inf->result, "unreadable symlink '%s' (%s)",
			    inf->path, strerror(inf->link_error));
			return (1);
		}
		if (inf->link_target == ELOOP)
			xasprintf(&inf->result, "symbolic link in a loop");
		else if (inf->link_target != 0) {
			xasprintf(&inf->result, "broken symbolic link to '%s'",
			    inf->link_path);
		} else {
			xasprintf(&inf->result, "symbolic link to '%s'",
			    inf->link_path);
		}
		return (1);
	case S_IFSOCK:
		xasprintf(&inf->result, "socket");
		return (1);
	case S_IFBLK:
		xasprintf(&inf->result, "block special (%ld/%ld)",
		    (long)major(inf->sb.st_rdev),
		    (long)minor(inf->sb.st_rdev));
		return (1);
	case S_IFCHR:
		xasprintf(&inf->result, "character special (%ld/%ld)",
		    (long)major(inf->sb.st_rdev),
		    (long)minor(inf->sb.st_rdev));
		return (1);
	case S_IFIFO:
		xasprintf(&inf->result, "fifo (named pipe)");
		return (1);
	}
	return (0);
}

static int
try_empty(struct input_file *inf)
{
	if (inf->size != 0)
		return (0);

	if (iflag)
		xasprintf(&inf->result, "application/x-empty");
	else
		xasprintf(&inf->result, "empty");
	return (1);
}

static int
try_access(struct input_file *inf)
{
	char tmp[256] = "";

	if (inf->sb.st_size == 0 && S_ISREG(inf->sb.st_mode))
		return (0); /* empty file */
	if (inf->fd != -1)
		return (0);

	if (inf->sb.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH))
		strlcat(tmp, "writable, ", sizeof tmp);
	if (inf->sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))
		strlcat(tmp, "executable, ", sizeof tmp);
	if (S_ISREG(inf->sb.st_mode))
		strlcat(tmp, "regular file, ", sizeof tmp);
	strlcat(tmp, "no read permission", sizeof tmp);

	inf->result = xstrdup(tmp);
	return (1);
}

static int
try_text(struct input_file *inf)
{
	const char	*type, *s;
	int		 flags;

	flags = MAGIC_TEST_TEXT;
	if (iflag)
		flags |= MAGIC_TEST_MIME;

	type = text_get_type(inf->base, inf->size);
	if (type == NULL)
		return (0);

	s = magic_test(inf->m, inf->base, inf->size, flags);
	if (s != NULL) {
		inf->result = xstrdup(s);
		return (1);
	}

	s = text_try_words(inf->base, inf->size, flags);
	if (s != NULL) {
		if (iflag)
			inf->result = xstrdup(s);
		else
			xasprintf(&inf->result, "%s %s text", type, s);
		return (1);
	}

	if (iflag)
		inf->result = xstrdup("text/plain");
	else
		xasprintf(&inf->result, "%s text", type);
	return (1);
}

static int
try_magic(struct input_file *inf)
{
	const char	*s;
	int		 flags;

	flags = 0;
	if (iflag)
		flags |= MAGIC_TEST_MIME;

	s = magic_test(inf->m, inf->base, inf->size, flags);
	if (s != NULL) {
		inf->result = xstrdup(s);
		return (1);
	}
	return (0);
}

static int
try_unknown(struct input_file *inf)
{
	if (iflag)
		xasprintf(&inf->result, "application/x-not-regular-file");
	else
		xasprintf(&inf->result, "data");
	return (1);
}

static void
test_file(struct input_file *inf, size_t width)
{
	char	*label;
	int	 stop;

	stop = 0;
	if (!stop)
		stop = try_stat(inf);
	if (!stop)
		stop = try_access(inf);
	if (!stop)
		stop = load_file(inf);
	if (!stop)
		stop = try_empty(inf);
	if (!stop)
		stop = try_magic(inf);
	if (!stop)
		stop = try_text(inf);
	if (!stop)
		stop = try_unknown(inf);

	if (bflag)
		printf("%s\n", inf->result);
	else {
		if (strcmp(inf->path, "-") == 0)
			xasprintf(&label, "/dev/stdin:");
		else
			xasprintf(&label, "%s:", inf->path);
		printf("%-*s %s\n", (int)width, label, inf->result);
		free(label);
	}
	free(inf->result);

	if (inf->mapped && inf->base != NULL)
		munmap(inf->base, inf->size);
}
@


1.62
log
@remove excess #include
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.61 2017/06/28 15:40:54 deraadt Exp $ */
d220 2
d226 1
d229 1
d239 1
a252 1
	inf->path = path;
@


1.61
log
@perform an initial pledge very early on, and drop tzset to later.
ok nicm brynet
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.60 2017/06/28 13:37:56 brynet Exp $ */
a19 1
#include <sys/ioctl.h>
a20 2
#include <sys/queue.h>
#include <sys/socket.h>
a21 2
#include <sys/uio.h>
#include <sys/wait.h>
@


1.60
log
@Simplify file(1) by removing the no longer necessary parent/child separation
and just drop privileges in the main process.

Also allows for a tighter "stdio" pledge.

passing regress tests still pass

ok nicm@@ with helpful feedback
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.59 2017/04/18 14:16:48 nicm Exp $ */
d107 1
a107 1
	FILE			*magicfp;
d112 2
a113 1
	tzset();
a152 1
	magicfp = NULL;
d185 2
@


1.59
log
@Style nits; no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.58 2016/05/01 20:34:26 nicm Exp $ */
a31 1
#include <imsg.h>
a35 1
#include <stdlib.h>
a43 15
struct input_msg {
	int		idx;

	struct stat	sb;
	int		error;

	char		link_path[PATH_MAX];
	int		link_error;
	int		link_target;
};

struct input_ack {
	int		idx;
};

d45 1
a45 2
	struct magic		*m;
	struct input_msg	*msg;
d47 4
a50 2
	const char		*path;
	int			 fd;
d52 8
a59 4
	void			*base;
	size_t			 size;
	int			 mapped;
	char			*result;
d66 1
a66 5
static int	 prepare_message(struct input_msg *, int, const char *);
static void	 send_message(struct imsgbuf *, void *, size_t, int);
static int	 read_message(struct imsgbuf *, struct imsg *, pid_t);

static void	 read_link(struct input_msg *, const char *);
d68 1
a68 1
static __dead void child(int, pid_t, int, char **);
a85 3
static char	*magicpath;
static FILE	*magicfp;

d104 2
a105 2
	int			 opt, pair[2], fd, idx;
	char			*home;
d107 4
a110 5
	struct imsgbuf		 ibuf;
	struct imsg		 imsg;
	struct input_msg	 msg;
	struct input_ack	*ack;
	pid_t			 pid, parent;
d176 8
a183 9
	parent = getpid();
	if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, pair) != 0)
		err(1, "socketpair");
	switch (pid = fork()) {
	case -1:
		err(1, "fork");
	case 0:
		close(pair[0]);
		child(pair[1], parent, argc, argv);
a184 1
	close(pair[1]);
d186 2
a187 2
	fclose(magicfp);
	magicfp = NULL;
d189 11
a199 2
	if (cflag)
		goto wait_for_child;
d201 2
a202 4
	imsg_init(&ibuf, pair[0]);
	for (idx = 0; idx < argc; idx++) {
		fd = prepare_message(&msg, idx, argv[idx]);
		send_message(&ibuf, &msg, sizeof msg, fd);
d204 4
a207 8
		if (read_message(&ibuf, &imsg, pid) == 0)
			break;
		if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof *ack)
			errx(1, "message too small");
		ack = imsg.data;
		if (ack->idx != idx)
			errx(1, "index not expected");
		imsg_free(&imsg);
d209 1
d211 3
a213 5
wait_for_child:
	close(pair[0]);
	while (wait(NULL) == -1 && errno != ECHILD) {
		if (errno != EINTR)
			err(1, "wait");
d215 1
a215 1
	_exit(0); /* let the child flush */
d218 2
a219 2
static int
prepare_message(struct input_msg *msg, int idx, const char *path)
a222 3
	memset(msg, 0, sizeof *msg);
	msg->idx = idx;

d224 3
a226 3
		if (fstat(STDIN_FILENO, &msg->sb) == -1) {
			msg->error = errno;
			return (-1);
d228 1
a228 1
		return (STDIN_FILENO);
d232 1
a232 1
		error = stat(path, &msg->sb);
d234 1
a234 1
		error = lstat(path, &msg->sb);
d236 2
a237 2
		msg->error = errno;
		return (-1);
d240 2
a241 6
	/*
	 * pledge(2) doesn't let us pass directory file descriptors around -
	 * but in fact we don't need them, so just don't open directories or
	 * symlinks (which could be to directories).
	 */
	mode = msg->sb.st_mode;
d249 3
a251 36
		read_link(msg, path);
	return (fd);

}

static void
send_message(struct imsgbuf *ibuf, void *msg, size_t msglen, int fd)
{
	if (imsg_compose(ibuf, -1, -1, 0, fd, msg, msglen) != 1)
		err(1, "imsg_compose");
	if (imsg_flush(ibuf) != 0)
		err(1, "imsg_flush");
}

static int
read_message(struct imsgbuf *ibuf, struct imsg *imsg, pid_t from)
{
	int	n;

	while ((n = imsg_read(ibuf)) == -1 && errno == EAGAIN)
		/* nothing */ ;
	if (n == -1)
		err(1, "imsg_read");
	if (n == 0)
		return (0);

	if ((n = imsg_get(ibuf, imsg)) == -1)
		err(1, "imsg_get");
	if (n == 0)
		return (0);

	if ((pid_t)imsg->hdr.pid != from)
		errx(1, "PIDs don't match");

	return (n);

d255 1
a255 1
read_link(struct input_msg *msg, const char *path)
d265 1
a265 1
		msg->link_error = errno;
d271 1
a271 1
		strlcpy(msg->link_path, lpath, sizeof msg->link_path);
d278 1
a278 1
			strlcpy(msg->link_path, lpath, sizeof msg->link_path);
d280 1
a280 1
			used = snprintf(msg->link_path, sizeof msg->link_path,
d282 2
a283 2
			if (used < 0 || (size_t)used >= sizeof msg->link_path) {
				msg->link_error = ENAMETOOLONG;
d293 1
a293 75
		msg->link_target = errno;
}

static __dead void
child(int fd, pid_t parent, int argc, char **argv)
{
	struct passwd		*pw;
	struct magic		*m;
	struct imsgbuf		 ibuf;
	struct imsg		 imsg;
	struct input_msg	*msg;
	struct input_ack	 ack;
	struct input_file	 inf;
	int			 i, idx;
	size_t			 len, width = 0;

	if (pledge("stdio getpw recvfd id", NULL) == -1)
		err(1, "pledge");

	if (geteuid() == 0) {
		pw = getpwnam(FILE_USER);
		if (pw == NULL)
			errx(1, "unknown user %s", FILE_USER);
		if (setgroups(1, &pw->pw_gid) != 0)
			err(1, "setgroups");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
			err(1, "setresgid");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
			err(1, "setresuid");
	}

	if (pledge("stdio recvfd", NULL) == -1)
		err(1, "pledge");

	m = magic_load(magicfp, magicpath, cflag || Wflag);
	if (cflag) {
		magic_dump(m);
		exit(0);
	}

	for (i = 0; i < argc; i++) {
		len = strlen(argv[i]) + 1;
		if (len > width)
			width = len;
	}

	imsg_init(&ibuf, fd);
	for (;;) {
		if (read_message(&ibuf, &imsg, parent) == 0)
			break;
		if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof *msg)
			errx(1, "message too small");
		msg = imsg.data;

		idx = msg->idx;
		if (idx < 0 || idx >= argc)
			errx(1, "index out of range");

		memset(&inf, 0, sizeof inf);
		inf.m = m;
		inf.msg = msg;

		inf.path = argv[idx];
		inf.fd = imsg.fd;

		test_file(&inf, width);

		if (imsg.fd != -1)
			close(imsg.fd);
		imsg_free(&imsg);

		ack.idx = idx;
		send_message(&ibuf, &ack, sizeof ack, -1);
	}
	exit(0);
d330 1
a330 1
	if (inf->msg->sb.st_size == 0 && S_ISREG(inf->msg->sb.st_mode))
d332 1
a332 1
	if (inf->msg->sb.st_size == 0 || inf->msg->sb.st_size > FILE_READ_SIZE)
d335 1
a335 1
		inf->size = inf->msg->sb.st_size;
d337 1
a337 1
	if (!S_ISREG(inf->msg->sb.st_mode))
d360 1
a360 1
	if (inf->msg->error != 0) {
d362 1
a362 1
		    strerror(inf->msg->error));
d366 1
a366 1
		switch (inf->msg->sb.st_mode & S_IFMT) {
d377 1
a377 1
	if (iflag && (inf->msg->sb.st_mode & S_IFMT) != S_IFREG) {
d382 1
a382 1
	switch (inf->msg->sb.st_mode & S_IFMT) {
d387 1
a387 1
		if (inf->msg->link_error != 0) {
d389 1
a389 1
			    inf->path, strerror(inf->msg->link_error));
d392 1
a392 1
		if (inf->msg->link_target == ELOOP)
d394 1
a394 1
		else if (inf->msg->link_target != 0) {
d396 1
a396 1
			    inf->msg->link_path);
d399 1
a399 1
			    inf->msg->link_path);
d407 2
a408 2
		    (long)major(inf->msg->sb.st_rdev),
		    (long)minor(inf->msg->sb.st_rdev));
d412 2
a413 2
		    (long)major(inf->msg->sb.st_rdev),
		    (long)minor(inf->msg->sb.st_rdev));
d440 1
a440 1
	if (inf->msg->sb.st_size == 0 && S_ISREG(inf->msg->sb.st_mode))
d445 1
a445 1
	if (inf->msg->sb.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH))
d447 1
a447 1
	if (inf->msg->sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))
d449 1
a449 1
	if (S_ISREG(inf->msg->sb.st_mode))
@


1.58
log
@Tidy up some #include lines.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.57 2015/12/24 11:45:34 jca Exp $ */
d46 1
a46 2
struct input_msg
{
d57 1
a57 2
struct input_ack
{
d61 1
a61 2
struct input_file
{
d448 1
a448 1
			return NULL;
d456 1
a456 1
	return buffer;
@


1.57
log
@Add --brief and --dereference, used by xdg-open/xdg-mime.

From Ralf Horstmann, ok tb@@ deraadt@@ nicm@@ sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.56 2015/12/05 13:18:09 claudio Exp $ */
d22 1
d24 1
a24 1
#include <sys/queue.h>
d28 1
d30 2
d34 1
a34 2
#include <getopt.h>
#include <fcntl.h>
d37 2
a40 1
#include <limits.h>
@


1.56
log
@EAGAIN handling for imsg_read. OK henning@@ benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.55 2015/11/13 08:32:10 nicm Exp $ */
d105 5
a109 3
	{ "mime",      no_argument, NULL, 'i' },
	{ "mime-type", no_argument, NULL, 'i' },
	{ NULL,        0,           NULL, 0   }
@


1.55
log
@Break the message preparation bit of the main loop into its own function
for less excessive level of indentation.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.54 2015/11/13 08:30:18 nicm Exp $ */
d292 3
a294 1
	if ((n = imsg_read(ibuf)) == -1)
@


1.54
log
@Call stat not lstat with -L, makes links actually be followed. Reported
by and ok semarie@@.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.53 2015/10/17 04:41:37 deraadt Exp $ */
d77 1
d120 1
a120 1
	int			 opt, pair[2], fd, idx, mode, error;
d213 1
a213 37
		memset(&msg, 0, sizeof msg);
		msg.idx = idx;

		if (strcmp(argv[idx], "-") == 0) {
			if (fstat(STDIN_FILENO, &msg.sb) == -1) {
				fd = -1;
				msg.error = errno;
			} else
				fd = STDIN_FILENO;
		} else {
			if (Lflag)
				error = stat(argv[idx], &msg.sb);
			else
				error = lstat(argv[idx], &msg.sb);
			if (error == -1) {
				fd = -1;
				msg.error = errno;
			} else {
				/*
				 * pledge(2) doesn't let us pass directory file
				 * descriptors around - but in fact we don't
				 * need them, so just don't open directories or
				 * symlinks (which could be to directories).
				 */
				mode = msg.sb.st_mode;
				if (!S_ISDIR(mode) && !S_ISLNK(mode)) {
					fd = open(argv[idx],
					    O_RDONLY|O_NONBLOCK);
					if (fd == -1 && (errno == ENFILE ||
					    errno == EMFILE))
						err(1, "open");
				} else
					fd = -1;
				if (S_ISLNK(mode))
					read_link(&msg, argv[idx]);
			}
		}
d233 43
@


1.53
log
@The file(1) magic-parsing process was using pledge "stdio getpw proc recvfd"
early on, then a set of getpwnam/setresuid/... before quickly dropping to
"stdio recvfd".  It receives fd's and runs the magic code on them in a
chroot'd "stdio" jail.  We can do better than that.

Before the recent change, "proc" contained both the concepts of "forking"
and "setuid".  "id" is now split out as a seperate request, and it is
exactly what this process needs momentarily.  So this loses another window
of opportunity, in case we have a major bug in .... hmm, it'd have to be
in getpwnam....

ok tedu doug semarie gilles
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.52 2015/10/09 01:37:07 deraadt Exp $ */
d119 1
a119 1
	int			 opt, pair[2], fd, idx, mode;
a220 3
		} else if (lstat(argv[idx], &msg.sb) == -1) {
			fd = -1;
			msg.error = errno;
d222 5
a226 13
			/*
			 * pledge(2) doesn't let us pass directory file
			 * descriptors around - but in fact we don't need them,
			 * so just don't open directories or symlinks (which
			 * could be to directories).
			 */
			mode = msg.sb.st_mode;
			if (!S_ISDIR(mode) && !S_ISLNK(mode)) {
				fd = open(argv[idx], O_RDONLY|O_NONBLOCK);
				if (fd == -1 &&
				    (errno == ENFILE || errno == EMFILE))
					err(1, "open");
			} else
d228 20
a247 2
			if (S_ISLNK(mode))
				read_link(&msg, argv[idx]);
d339 2
a340 7
	if (Lflag) {
		if (stat(path, &msg->sb) == -1)
			msg->error = errno;
	} else {
		if (stat(path, &sb) == -1)
			msg->link_target = errno;
	}
@


1.52
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.51 2015/10/06 15:39:44 deraadt Exp $ */
d354 1
a354 1
	if (pledge("stdio getpw proc recvfd", NULL) == -1)
@


1.51
log
@Move from tame "cmsg" to tame "sendfd" or "recvfd", depending on which
way the process moves fd's.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.51 2015/10/06 15:36:23 deraadt Exp $ */
d226 1
a226 1
			 * tame(2) doesn't let us pass directory file
d354 2
a355 2
	if (tame("stdio getpw proc recvfd", NULL) == -1)
		err(1, "tame");
d369 2
a370 2
	if (tame("stdio recvfd", NULL) == -1)
		err(1, "tame");
@


1.50
log
@use the normal -1 check for tame failure
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.49 2015/10/04 07:25:59 nicm Exp $ */
d354 1
a354 1
	if (tame("stdio cmsg getpw proc", NULL) == -1)
d369 1
a369 1
	if (tame("stdio cmsg", NULL) == -1)
@


1.49
log
@Add tame(2) to file(1) and drop the old systrace(4) sandbox. tame(2) is
only applied to the child process, which requires the parent to not pass
directory file descriptors (tame("cmsg") does not allow it). Because
file(1) is already privsep, the permissions in the child can be quickly
restricted: first to "stdio cmsg getpw proc" then after the privdrop to
"stdio cmsg".
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.48 2015/10/02 18:06:27 deraadt Exp $ */
d354 1
a354 1
	if (tame("stdio cmsg getpw proc", NULL) != 0)
d369 1
a369 1
	if (tame("stdio cmsg", NULL) != 0)
@


1.48
log
@use limits.h instead of sys/param.h to get PATH_MAX
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.47 2015/07/12 09:51:25 tobias Exp $ */
d119 1
a119 1
	int			 opt, pair[2], fd, idx;
d195 4
a198 2
	pid = sandbox_fork(FILE_USER);
	if (pid == 0) {
d225 15
a239 4
			fd = open(argv[idx], O_RDONLY|O_NONBLOCK);
			if (fd == -1 && (errno == ENFILE || errno == EMFILE))
				err(1, "open");
			if (S_ISLNK(msg.sb.st_mode))
d344 1
d354 18
d559 2
@


1.47
log
@Keep one byte for terminating '\0'.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.46 2015/07/08 17:49:45 tobias Exp $ */
d36 1
@


1.46
log
@Properly handle files >= 4 GB on 32 bit architectures.

with input by and ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.45 2015/05/30 06:25:35 nicm Exp $ */
d289 1
a289 1
	size = readlink(path, lpath, sizeof lpath);
@


1.45
log
@Support - to read from stdin, from Sebastien Marie.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.44 2015/05/29 15:58:34 nicm Exp $ */
d416 1
a416 2
	inf->size = inf->msg->sb.st_size;
	if (inf->size == 0 && S_ISREG(inf->msg->sb.st_mode))
d418 1
a418 1
	if (inf->size == 0 || inf->size > FILE_READ_SIZE)
d420 2
@


1.44
log
@millert points out I can just call tzset() early to avoid having to
permit access() in the child.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.43 2015/05/29 12:33:41 nicm Exp $ */
d212 7
a218 1
		if (lstat(argv[idx], &msg.sb) == -1) {
d450 1
a450 1
	if (sflag) {
d452 3
d629 4
a632 1
		xasprintf(&label, "%s:", inf->path);
@


1.43
log
@Only mmap() on regular files; mmap() on /dev/stdin will happily map as
much as we ask for but only the first page will be usable. (We could get
the actual size with ioctl(FIONREAD) and mmap() that but it would need
to be done in the parent - I think just using read() is simpler.)
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.42 2015/05/29 11:59:01 nicm Exp $ */
d34 1
d126 2
@


1.42
log
@Make things a little less confusing by making fill_buffer self-contained
and return both the buffer and amount filled rather than having it
modify the input struct and return a value.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.41 2015/05/29 11:03:37 nicm Exp $ */
d408 3
a410 1
	if (inf->size > FILE_READ_SIZE)
d412 3
a414 6
	if (inf->size == 0) {
		if (!S_ISREG(inf->msg->sb.st_mode))
			inf->size = FILE_READ_SIZE;
		else
			return (0);
	}
d417 13
a429 10
	if (inf->base == MAP_FAILED) {
		inf->base = fill_buffer(inf->fd, inf->size, &used);
		if (inf->base == NULL) {
			xasprintf(&inf->result, "cannot read '%s' (%s)",
			    inf->path, strerror(errno));
			return (1);
		}
		inf->size = used;
	} else
		inf->mapped = 1;
@


1.41
log
@If reading into buffer, correct the stored file size at EOF, we don't
want to look at any garbage that might already be in the buffer after
that. From Sebastien Marie.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.40 2015/05/29 07:30:28 nicm Exp $ */
d374 1
a374 1
fill_buffer(struct input_file *inf)
d385 1
a385 1
	left = inf->size;
d387 1
a387 1
		got = read(inf->fd, next, left);
d398 1
a398 1
	inf->size -= left;
d405 2
d419 1
a419 1
		inf->base = fill_buffer(inf);
d425 1
@


1.40
log
@Silently fall back to /etc/magic if ~/.magic can't be opened, ok deraadt stsp
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.39 2015/05/28 19:26:37 jmc Exp $ */
d398 1
a398 1

@


1.39
log
@probably makes more sense to show "file" as being mandatory;
from sebastien marie
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.38 2015/05/18 11:57:52 deraadt Exp $ */
a176 2
			if (magicfp == NULL && errno != ENOENT)
				err(1, "%s", magicpath);
@


1.38
log
@No longer need tricks with setvbuf().  Instead, we just give permission
to call fstat() and fcntl().
ok nicm
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.37 2015/04/28 02:26:43 lteo Exp $ */
d110 1
a110 1
	fprintf(stderr, "usage: %s [-bchiLsW] [file ...]\n", __progname);
@


1.37
log
@Add a missing free in the error path.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.36 2015/04/27 13:52:17 nicm Exp $ */
a188 1
	setvbuf(magicfp, NULL, _IOLBF, 0); /* stops stdio calling fstat */
@


1.36
log
@Use a systrace(4) sandbox with a short whitelist of allowed syscalls for
the file(1) child process. Based on similar code in ssh sandbox-systrace.c.
Idea and help from deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.35 2015/04/27 13:41:45 nicm Exp $ */
d304 1
@


1.35
log
@Add simple privilege separation to file(1). Two processes, file
descriptors and a few other bits are opened in parent and passed to
child using imsg. Child currently drops to "nobody" but this will change.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.34 2015/04/26 22:51:32 nicm Exp $ */
d189 1
d194 2
a195 2
	switch (pid = fork()) {
	case 0:
a197 2
	case -1:
		err(1, "fork");
a330 13
	struct passwd		*pw;

	if (geteuid() == 0) {
		pw = getpwnam(FILE_USER);
		if (pw == NULL)
			errx(1, "unknown user %s", FILE_USER);
		if (setgroups(1, &pw->pw_gid) != 0)
			err(1, "setgroups");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
			err(1, "setresgid");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
			err(1, "setresuid");
	}
@


1.34
log
@Don't support -s on FIFOs, it doesn't work well and the workarounds are
a bit horrible.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.33 2015/04/26 19:53:50 nicm Exp $ */
d22 4
d28 1
d40 17
d59 2
a60 1
	struct magic	*m;
d62 2
a63 2
	const char	*path;
	const char	*label;
d65 4
a68 12
	int		 fd;
	struct stat	 sb;
	const char	*error;

	void		*base;
	size_t           size;
	int		 mapped;
	char		*result;

	char		 link_path[PATH_MAX];
	const char	*link_error;
	int		 link_target;
d75 8
a82 4
static void	 prepare_file(struct input_file *, const char *, int *);
static void	 open_file(struct input_file *);
static void	 read_link(struct input_file *);
static void	 test_file(struct magic *, struct input_file *, int);
d98 3
d117 2
a118 5
	struct input_file	*files = NULL;
	int			 opt, i, width = 0;
	FILE			*f;
	struct magic		*m;
	char			*home, *path;
d120 5
d164 1
a164 1
	f = NULL;
d175 6
a180 6
			xasprintf(&path, "%s/.magic", home);
			f = fopen(path, "r");
			if (f == NULL && errno != ENOENT)
				err(1, "%s", path);
			if (f == NULL)
				free(path);
d183 41
a223 6
	if (f == NULL) {
		path = xstrdup("/etc/magic");
		f = fopen(path, "r");
	}
	if (f == NULL)
		err(1, "%s", path);
d225 8
a232 4
	m = magic_load(f, path, cflag || Wflag);
	if (cflag) {
		magic_dump(m);
		exit(0);
d235 5
a239 6
	files = xcalloc(argc, sizeof *files);
	for (i = 0; i < argc; i++)
		prepare_file(&files[i], argv[i], &width);
	for (i = 0; i < argc; i++) {
		open_file(&files[i]);
		test_file(m, &files[i], width);
d241 1
a241 1
	exit(0);
d245 10
a254 1
prepare_file(struct input_file *inf, const char *path, int *width)
d256 1
a256 2
	char	*label;
	int	 n;
d258 4
a261 1
	inf->path = xstrdup(path);
d263 4
a266 5
	n = xasprintf(&label, "%s:", inf->path);
	if (n > *width)
		*width = n;
	inf->label = label;
}
d268 2
a269 4
static void
open_file(struct input_file *inf)
{
	int	 retval;
d271 1
a271 5
	retval = lstat(inf->path, &inf->sb);
	if (retval == -1) {
		inf->error = strerror(errno);
		return;
	}
a272 3
	if (S_ISLNK(inf->sb.st_mode))
		read_link(inf);
	inf->fd = open(inf->path, O_RDONLY|O_NONBLOCK);
d276 1
a276 1
read_link(struct input_file *inf)
d279 1
a279 1
	char		 path[PATH_MAX];
d284 1
a284 1
	size = readlink(inf->path, path, sizeof path);
d286 1
a286 1
		inf->link_error = strerror(errno);
d289 1
a289 1
	path[size] = '\0';
d291 2
a292 2
	if (*path == '/')
		strlcpy(inf->link_path, path, sizeof inf->link_path);
d294 1
a294 1
		copy = xstrdup(inf->path);
d299 1
a299 1
			strlcpy(inf->link_path, path, sizeof inf->link_path);
d301 4
a304 4
			used = snprintf(inf->link_path, sizeof inf->link_path,
			    "%s/%s", root, path);
			if (used < 0 || (size_t)used >= sizeof inf->link_path) {
				inf->link_error = strerror(ENAMETOOLONG);
d313 2
a314 2
		if (stat(inf->path, &inf->sb) == -1)
			inf->error = strerror(errno);
d316 2
a317 2
		if (stat(inf->path, &sb) == -1)
			inf->link_target = errno;
d321 68
d421 1
a421 1
	inf->size = inf->sb.st_size;
d425 1
a425 1
		if (!S_ISREG(inf->sb.st_mode))
d447 1
a447 1
	if (inf->error != NULL) {
d449 1
a449 1
		    inf->error);
d453 1
a453 1
		switch (inf->sb.st_mode & S_IFMT) {
d461 1
a461 1
	if (iflag && (inf->sb.st_mode & S_IFMT) != S_IFREG) {
d466 1
a466 2

	switch (inf->sb.st_mode & S_IFMT) {
d471 1
a471 1
		if (inf->link_error != NULL) {
d473 1
a473 1
			    inf->path, inf->link_error);
d476 1
a476 1
		if (inf->link_target == ELOOP)
d478 1
a478 1
		else if (inf->link_target != 0) {
d480 1
a480 1
			    inf->link_path);
d483 1
a483 1
			    inf->link_path);
d491 2
a492 1
		    (long)major(inf->sb.st_rdev), (long)minor(inf->sb.st_rdev));
d496 2
a497 1
		    (long)major(inf->sb.st_rdev), (long)minor(inf->sb.st_rdev));
d527 1
a527 1
	if (inf->sb.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH))
d529 1
a529 1
	if (inf->sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH))
d531 1
a531 1
	if (S_ISREG(inf->sb.st_mode))
d604 1
a604 1
test_file(struct magic *m, struct input_file *inf, int width)
d606 2
a607 3
	int	stop;

	inf->m = m;
d627 5
a631 2
	else
		printf("%-*s %s\n", width, inf->label, inf->result);
a635 6
	inf->base = NULL;

	if (inf->fd != -1)
		close(inf->fd);
	free((void *)inf->label);
	free((void *)inf->path);
@


1.33
log
@stat() the original link path not the resolved one which may be relative.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.32 2015/04/24 17:34:57 nicm Exp $ */
a289 2
	int	available;

d293 6
a298 11
	if (S_ISFIFO(inf->sb.st_mode)) {
		if (ioctl(inf->fd, FIONREAD, &available) == -1) {
			xasprintf(&inf->result,  "cannot read '%s' (%s)",
			    inf->path, strerror(errno));
			return (1);
		}
		inf->size = available;
	} else if (!S_ISREG(inf->sb.st_mode) && inf->size == 0)
		inf->size = FILE_READ_SIZE;
	if (inf->size == 0)
		return (0);
a324 1
		case S_IFIFO:
@


1.32
log
@Do not attempt to use ~/.magic if running as root (or issetugid()).
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.31 2015/04/24 17:10:50 nicm Exp $ */
d253 1
a253 1
		if (stat(inf->link_path, &sb) == -1)
@


1.31
log
@We need to loop over the files once to work out the width of the labels
before testing them.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.30 2015/04/24 16:47:32 nicm Exp $ */
d140 18
a157 7
	home = getenv("HOME");
	if (home == NULL || *home == '\0') {
		pw = getpwuid(getuid());
		if (pw != NULL)
			home = pw->pw_dir;
		else
			home = NULL;
a158 9
	if (home != NULL) {
		xasprintf(&path, "%s/.magic", home);
		f = fopen(path, "r");
		if (f == NULL && errno != ENOENT)
			err(1, "%s", path);
		if (f == NULL)
			free(path);
	} else
		f = NULL;
@


1.30
log
@Trying to drop privileges means we can't handle ARG_MAX arguments, so
remove it for now.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.29 2015/04/24 16:30:06 nicm Exp $ */
d60 2
a61 1
static void	 open_file(struct input_file *, const char *, int *);
d95 1
a95 1
	struct input_file	 inf;
d170 3
d174 2
a175 3
		memset(&inf, 0, sizeof inf);
		open_file(&inf, argv[i], &width);
		test_file(m, &inf, width);
d181 1
a181 1
open_file(struct input_file *inf, const char *path, int *width)
d184 1
a184 1
	int	 n, retval;
d192 6
@


1.29
log
@Use symbolic constants for st_mode flags, no binary change.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.28 2015/04/24 16:28:00 nicm Exp $ */
d94 2
a95 2
	struct input_file	*files = NULL;
	int			 nfiles, opt, i, width = 0;
a138 7
	nfiles = argc;
	if (nfiles != 0) {
		files = xcalloc(nfiles, sizeof *files);
		for (i = 0; i < argc; i++)
			open_file(&files[i], argv[i], &width);
	}

a162 12
	if (geteuid() == 0) {
		pw = getpwnam(FILE_USER);
		if (pw == NULL)
			errx(1, "unknown user %s", FILE_USER);
		if (setgroups(1, &pw->pw_gid) != 0)
			err(1, "setgroups");
		if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0)
			err(1, "setresgid");
		if (setresuid(pw->pw_uid, pw->pw_uid, pw->pw_uid) != 0)
			err(1, "setresuid");
	}

d169 5
a173 2
	for (i = 0; i < nfiles; i++)
		test_file(m, &files[i], width);
d269 1
a269 1
		next = (char*)next + got;
d495 1
d501 4
a504 1
	free(inf->result);
@


1.28
log
@If ~/.magic exists but can't be used, fail rather than silently falling
back to /etc/magic.
@
text
@d1 1
a1 1
/* $OpenBSD: file.c,v 1.27 2015/04/24 16:24:11 nicm Exp $ */
d408 1
a408 1
	if (inf->sb.st_mode & 0222)
d410 1
a410 1
	if (inf->sb.st_mode & 0111)
@


1.27
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d157 4
@


1.26
log
@Add missing <limits.h> to file.c and remove definition of PATH_MAX
which masked the missing include.  OK deraadt@@
@
text
@d1 2
a2 28
/*	$OpenBSD: file.c,v 1.25 2015/01/16 08:24:04 doug Exp $ */
/*
 * Copyright (c) Ian F. Darwin 1986-1995.
 * Software written by Ian F. Darwin and others;
 * maintained 1995-present by Christos Zoulas and others.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d4 13
a16 1
 * file - find type of a file or files - main program.
d20 2
a21 1
#include <sys/stat.h>
d23 5
a27 4
#include "file.h"
#include "magic.h"

#include <stdio.h>
a29 22
#include <limits.h>
#include <string.h>
#ifdef RESTORE_TIME
# if (__COHERENT__ >= 0x420)
#  include <sys/utime.h>
# else
#  ifdef USE_UTIMES
#   include <sys/time.h>
#  else
#   include <utime.h>
#  endif
# endif
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>	/* for read() */
#endif
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif
#ifdef HAVE_WCHAR_H
#include <wchar.h>
#endif
d31 3
a33 4
#include <getopt.h>
#ifndef HAVE_GETOPT_LONG
int getopt_long(int argc, char * const *argv, const char *optstring, const struct option *longopts, int *longindex);
#endif
d35 3
a37 1
#include <netinet/in.h>		/* for byte swapping */
d39 2
a40 1
#include "patchlevel.h"
d42 13
d56 1
a56 5
#ifdef S_IFLNK
#define SYMLINKFLAG "Lh"
#else
#define SYMLINKFLAG ""
#endif
d58 1
a58 2
# define USAGE  "Usage: %s [-bcik" SYMLINKFLAG "nNprsvz0] [-e test] [-f namefile] [-F separator] [-m magicfiles] file...\n" \
		"       %s -C -m magicfiles\n"
d60 23
a82 5
private int 		/* Global command-line options 		*/
	bflag = 0,	/* brief output format	 		*/
	nopad = 0,	/* Don't pad output			*/
	nobuffer = 0,   /* Do not buffer stdout 		*/
	nulsep = 0;	/* Append '\0' to the separator		*/
d84 6
a89 3
private const char *magicfile = 0;	/* where the magic is	*/
private const char *default_magicfile = MAGIC;
private const char *separator = ":";	/* Default field separator	*/
a90 16
extern char *__progname;		/* used throughout 		*/

private struct magic_set *magic;

private void unwrap(char *);
private void usage(void);
private void help(void);

int main(int, char *[]);
private void process(const char *, int);
private void load(const char *, int);


/*
 * main - parse arguments and handle options
 */
d92 1
a92 1
main(int argc, char *argv[])
d94 10
a103 79
	int c;
	size_t i;
	int action = 0, didsomefiles = 0, errflg = 0;
	int flags = 0;
	char *home, *usermagic;
	struct stat sb;
	static const char hmagic[] = "/.magic";
#define OPTSTRING	"bcCde:f:F:hikLm:nNprsvz0"
	int longindex;
	static const struct option long_options[] =
	{
#define OPT(shortname, longname, opt, doc)      \
    {longname, opt, NULL, shortname},
#define OPT_LONGONLY(longname, opt, doc)        \
    {longname, opt, NULL, 0},
#include "file_opts.h"
#undef OPT
#undef OPT_LONGONLY
    {0, 0, NULL, 0}
};

	static const struct {
		const char *name;
		int value;
	} nv[] = {
		{ "apptype",	MAGIC_NO_CHECK_APPTYPE },
		{ "ascii",	MAGIC_NO_CHECK_ASCII },
		{ "compress",	MAGIC_NO_CHECK_COMPRESS },
		{ "elf",	MAGIC_NO_CHECK_ELF },
		{ "soft",	MAGIC_NO_CHECK_SOFT },
		{ "tar",	MAGIC_NO_CHECK_TAR },
		{ "tokens",	MAGIC_NO_CHECK_TOKENS },
	};

	/* makes islower etc work for other langs */
	(void)setlocale(LC_CTYPE, "");

#ifdef __EMX__
	/* sh-like wildcard expansion! Shouldn't hurt at least ... */
	_wildcard(&argc, &argv);
#endif

	magicfile = default_magicfile;
	if ((usermagic = getenv("MAGIC")) != NULL)
		magicfile = usermagic;
	else
		if ((home = getenv("HOME")) != NULL) {
			size_t len = strlen(home) + sizeof(hmagic);
			if ((usermagic = malloc(len)) != NULL) {
				(void)strlcpy(usermagic, home, len);
				(void)strlcat(usermagic, hmagic, len);
				if (stat(usermagic, &sb)<0) 
					free(usermagic);
				else
					magicfile = usermagic;
			}
		}

#ifdef S_IFLNK
	flags |= getenv("POSIXLY_CORRECT") ? MAGIC_SYMLINK : 0;
#endif
	while ((c = getopt_long(argc, argv, OPTSTRING, long_options,
	    &longindex)) != -1)
		switch (c) {
		case 0 :
			switch (longindex) {
			case 0:
				help();
				break;
			case 10:
				flags |= MAGIC_MIME_TYPE;
				break;
			case 11:
				flags |= MAGIC_MIME_ENCODING;
				break;
			}
			break;
		case '0':
			nulsep = 1;
d105 1
d107 1
a107 1
			bflag++;
d110 1
a110 1
			action = FILE_CHECK;
d112 2
a113 26
		case 'C':
			action = FILE_COMPILE;
			break;
		case 'd':
			flags |= MAGIC_DEBUG|MAGIC_CHECK;
			break;
		case 'e':
			for (i = 0; i < sizeof(nv) / sizeof(nv[0]); i++)
				if (strcmp(nv[i].name, optarg) == 0)
					break;

			if (i == sizeof(nv) / sizeof(nv[0]))
				errflg++;
			else
				flags |= nv[i].value;
			break;
			
		case 'f':
			if(action)
				usage();
			load(magicfile, flags);
			unwrap(optarg);
			++didsomefiles;
			break;
		case 'F':
			separator = optarg;
d116 1
a116 1
			flags |= MAGIC_MIME;
d118 2
a119 19
		case 'k':
			flags |= MAGIC_CONTINUE;
			break;
		case 'm':
			magicfile = optarg;
			break;
		case 'n':
			++nobuffer;
			break;
		case 'N':
			++nopad;
			break;
#if defined(HAVE_UTIME) || defined(HAVE_UTIMES)
		case 'p':
			flags |= MAGIC_PRESERVE_ATIME;
			break;
#endif
		case 'r':
			flags |= MAGIC_RAW;
d122 1
a122 14
			flags |= MAGIC_DEVICES;
			break;
		case 'v':
			(void)fprintf(stderr, "%s-%d.%.2d\n", __progname,
				       FILE_VERSION_MAJOR, patchlevel);
			(void)fprintf(stderr, "magic file from %s\n",
				       magicfile);
			return 1;
		case 'z':
			flags |= MAGIC_COMPRESS;
			break;
#ifdef S_IFLNK
		case 'L':
			flags |= MAGIC_SYMLINK;
d124 2
a125 2
		case 'h':
			flags &= ~MAGIC_SYMLINK;
a126 2
#endif
		case '?':
d128 1
a128 2
			errflg++;
			break;
d130 8
d139 5
a143 2
	if (errflg) {
		usage();
d146 16
a161 20
	switch(action) {
	case FILE_CHECK:
	case FILE_COMPILE:
		magic = magic_open(flags|MAGIC_CHECK);
		if (magic == NULL) {
			(void)fprintf(stderr, "%s: %s\n", __progname,
			    strerror(errno));
			return 1;
		}
		c = action == FILE_CHECK ? magic_check(magic, magicfile) :
		    magic_compile(magic, magicfile);
		if (c == -1) {
			(void)fprintf(stderr, "%s: %s\n", __progname,
			    magic_error(magic));
			return -1;
		}
		return 0;
	default:
		load(magicfile, flags);
		break;
d163 2
d166 10
a175 4
	if (optind == argc) {
		if (!didsomefiles) {
			usage();
		}
d177 5
a181 16
	else {
		size_t j, wid, nw;
		for (wid = 0, j = (size_t)optind; j < (size_t)argc; j++) {
			nw = file_mbswidth(argv[j]);
			if (nw > wid)
				wid = nw;
		}
		/*
		 * If bflag is only set twice, set it depending on
		 * number of files [this is undocumented, and subject to change]
		 */
		if (bflag == 2) {
			bflag = optind >= argc - 1;
		}
		for (; optind < argc; optind++)
			process(argv[optind], wid);
d184 3
a186 3
	c = magic->haderr ? 1 : 0;
	magic_close(magic);
	return c;
d189 5
d195 20
a214 3
private void
/*ARGSUSED*/
load(const char *m, int flags)
d216 9
a224 1
	if (magic || m == NULL)
d226 30
a255 9
	magic = magic_open(flags);
	if (magic == NULL) {
		(void)fprintf(stderr, "%s: %s\n", __progname, strerror(errno));
		exit(1);
	}
	if (magic_load(magic, magicfile) == -1) {
		(void)fprintf(stderr, "%s: %s\n",
		    __progname, magic_error(magic));
		exit(1);
d259 2
a260 5
/*
 * unwrap -- read a file of filenames, do each one.
 */
private void
unwrap(char *fn)
d262 16
a277 12
	char buf[PATH_MAX];
	FILE *f;
	int wid = 0, cwid;

	if (strcmp("-", fn) == 0) {
		f = stdin;
		wid = 1;
	} else {
		if ((f = fopen(fn, "r")) == NULL) {
			(void)fprintf(stderr, "%s: Cannot open `%s' (%s).\n",
			    __progname, fn, strerror(errno));
			exit(1);
d279 41
d321 15
a335 5
		while (fgets(buf, sizeof(buf), f) != NULL) {
			buf[strcspn(buf, "\n")] = '\0';
			cwid = file_mbswidth(buf);
			if (cwid > wid)
				wid = cwid;
d337 1
d339 3
a341 1
		rewind(f);
d344 35
a378 5
	while (fgets(buf, sizeof(buf), f) != NULL) {
		buf[strcspn(buf, "\n")] = '\0';
		process(buf, wid);
		if(nobuffer)
			(void)fflush(stdout);
d380 23
d404 10
a413 1
	(void)fclose(f);
d416 2
a417 5
/*
 * Called for each input file on the command line (or in a list of files)
 */
private void
process(const char *inname, int wid)
d419 10
a428 2
	const char *type;
	int std_in = strcmp(inname, "-") == 0;
d430 10
a439 4
	if (wid > 0 && !bflag) {
		(void)printf("%s", std_in ? "/dev/stdin" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
d441 2
a442 3
			(void)printf("%s", separator);
		(void)printf("%*s ",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), "");
d445 2
a446 3
	type = magic_file(magic, std_in ? NULL : inname);
	if (type == NULL)
		(void)printf("ERROR: %s\n", magic_error(magic));
d448 2
a449 1
		(void)printf("%s\n", type);
d452 2
a453 2
size_t
file_mbswidth(const char *s)
d455 2
a456 26
#if defined(HAVE_WCHAR_H) && defined(HAVE_MBRTOWC) && defined(HAVE_WCWIDTH)
	size_t bytesconsumed, old_n, n, width = 0;
	mbstate_t state;
	wchar_t nextchar;
	(void)memset(&state, 0, sizeof(mbstate_t));
	old_n = n = strlen(s);
	int w;

	while (n > 0) {
		bytesconsumed = mbrtowc(&nextchar, s, n, &state);
		if (bytesconsumed == (size_t)(-1) ||
		    bytesconsumed == (size_t)(-2)) {
			/* Something went wrong, return something reasonable */
			return old_n;
		}
		if (s[0] == '\n') {
			/*
			 * do what strlen() would do, so that caller
			 * is always right
			 */
			width++;
		} else {
			w = wcwidth(nextchar);
			if (w > 0)
				width += w;
		}
d458 8
a465 1
		s += bytesconsumed, n -= bytesconsumed;
d467 1
a467 4
	return width;
#else
	return strlen(s);
#endif
d470 2
a471 2
private void
usage(void)
d473 5
a477 3
	(void)fprintf(stderr, USAGE, __progname, __progname);
	(void)fputs("Try `file --help' for more information.\n", stderr);
	exit(1);
d480 2
a481 2
private void
help(void)
d483 30
a512 12
	(void)fputs(
"Usage: file [OPTION...] [FILE...]\n"
"Determine type of FILEs.\n"
"\n", stderr);
#define OPT(shortname, longname, opt, doc)      \
        fprintf(stderr, "  -%c, --" longname doc, shortname);
#define OPT_LONGONLY(longname, opt, doc)        \
        fprintf(stderr, "      --" longname doc);
#include "file_opts.h"
#undef OPT
#undef OPT_LONGONLY
	exit(0);
@


1.25
log
@Replace <sys/param.h> with <limits.h>

This patch is from Theo.  I helped verify that removing <sys/param.h>
doesn't change anything.

This produces the same binaries before and after with clang 3.5 and gcc
4.9.4 on amd64.  There is a slight difference in the way it is generated by
our old gcc 4.2.1 despite the fact that the preprocessed input is almost
identical.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.24 2015/01/16 05:46:44 deraadt Exp $ */
d42 1
a82 4

#ifndef PATH_MAX
#define	PATH_MAX	1024
#endif
@


1.24
log
@If MAXPATHLEN is undefined, do not set it to 512. Dangerous.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.23 2011/04/15 16:05:34 stsp Exp $ */
a33 1
#include <sys/param.h>	/* for MAXPATHLEN */
d83 2
a84 2
#ifndef MAXPATHLEN
#define	MAXPATHLEN	1024
d357 1
a357 1
	char buf[MAXPATHLEN];
@


1.23
log
@Make the file_mbswidth() function cope if wcwidth() returns -1.
ok mikeb millert
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.22 2009/10/27 23:59:37 deraadt Exp $ */
d85 1
a85 1
#define	MAXPATHLEN	512
@


1.22
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.21 2009/10/26 21:03:55 ajacoutot Exp $ */
d427 1
d442 5
a446 2
		} else
			width += wcwidth(nextchar);
@


1.21
log
@Fix usage;  requested by jmc@@

ok jmc@@ ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.20 2009/08/27 16:26:43 deraadt Exp $ */
a72 4

#ifndef	lint
FILE_RCSID("@@(#)$Id: file.c,v 1.20 2009/08/27 16:26:43 deraadt Exp $")
#endif	/* lint */
@


1.20
log
@Appease gcc2 (I wish people would write in C, rather than "latest crap
gcc added")
ok millert miod
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.19 2009/04/24 18:54:34 chl Exp $ */
d75 1
a75 1
FILE_RCSID("@@(#)$Id: file.c,v 1.19 2009/04/24 18:54:34 chl Exp $")
d85 2
a86 2
# define USAGE  "Usage: %s [-bcik" SYMLINKFLAG "nNrsvz0] [-e test] [-f namefile] [-F separator] [-m magicfiles] file...\n" \
		" 	%s [-m magicfiles] -C\n"
@


1.19
log
@file update to 4.24

The '-i' switch is now enabled so file(1) can output mime type strings.

ok ian@@
builk ports build test on amd64 by jasper@@

ok ray@@ gilles@@ on a almost identical diff
builk ports build test on sparc64 on this almost identical diff by ajacoutot@@
also tested by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.18 2008/05/08 01:40:56 chl Exp $ */
d33 4
a43 3
#include <sys/types.h>
#include <sys/param.h>	/* for MAXPATHLEN */
#include <sys/stat.h>
d75 1
a75 1
FILE_RCSID("@@(#)$Id: file.c,v 1.18 2008/05/08 01:40:56 chl Exp $")
@


1.18
log
@Update file to 4.21.

tested by ian@@ sthen@@

OK ian@@, "move ahead with it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.17 2007/02/19 13:02:08 tom Exp $ */
d64 3
a66 4
#ifdef HAVE_GETOPT_H
#include <getopt.h>	/* for long options (is this portable?)*/
#else
#undef HAVE_GETOPT_LONG
d74 1
a74 1
FILE_RCSID("@@(#)$Id: file.c,v 1.17 2007/02/19 13:02:08 tom Exp $")
d84 1
a84 1
# define USAGE  "Usage: %s [-bck" SYMLINKFLAG "nNrsvz0] [-e test] [-f namefile] [-F separator] [-m magicfiles] file...\n" \
d101 2
a103 1
extern char *__progname;
a106 1
#ifdef HAVE_GETOPT_LONG
a107 5
#endif
#if 0
private int byteconv4(int, int, int);
private short byteconv2(int, int, int);
#endif
d120 2
a121 1
	int c, i;
d127 1
a127 2
#define OPTSTRING	"bcCde:f:F:hkLm:nNprsvz0"
#ifdef HAVE_GETOPT_LONG
d131 9
a139 27
		{"version", 0, 0, 'v'},
		{"help", 0, 0, 0},
		{"brief", 0, 0, 'b'},
		{"checking-printout", 0, 0, 'c'},
		{"debug", 0, 0, 'd'},
		{"exclude", 1, 0, 'e' },
		{"files-from", 1, 0, 'f'},
		{"separator", 1, 0, 'F'},
		{"keep-going", 0, 0, 'k'},
#ifdef S_IFLNK
		{"dereference", 0, 0, 'L'},
		{"no-dereference", 0, 0, 'h'},
#endif
		{"magic-file", 1, 0, 'm'},
#if defined(HAVE_UTIME) || defined(HAVE_UTIMES)
		{"preserve-date", 0, 0, 'p'},
#endif
		{"uncompress", 0, 0, 'z'},
		{"raw", 0, 0, 'r'},
		{"no-buffer", 0, 0, 'n'},
		{"no-pad", 0, 0, 'N'},
		{"special-files", 0, 0, 's'},
		{"compile", 0, 0, 'C'},
		{"print0", 0, 0, '0'},
		{0, 0, 0, 0},
	};
#endif
a148 1
		{ "fortran",	MAGIC_NO_CHECK_FORTRAN },
a151 1
		{ "troff",	MAGIC_NO_CHECK_TROFF },
a153 1
#ifdef LC_CTYPE
a155 1
#endif
a180 3
#ifndef HAVE_GETOPT_LONG
	while ((c = getopt(argc, argv, OPTSTRING)) != -1)
#else
a182 1
#endif
a183 1
#ifdef HAVE_GETOPT_LONG
d185 2
a186 1
			if (longindex == 1)
d188 8
a196 1
#endif
d201 1
a201 1
			++bflag;
d233 3
d260 1
a260 1
			(void)fprintf(stdout, "%s-%d.%.2d\n", __progname,
d262 1
a262 1
			(void)fprintf(stdout, "magic file from %s\n",
d314 3
a316 3
		int i, wid, nw;
		for (wid = 0, i = optind; i < argc; i++) {
			nw = file_mbswidth(argv[i]);
d320 7
d331 1
d333 1
a333 1
	return 0;
a420 58

#if 0
/*
 * byteconv4
 * Input:
 *	from		4 byte quantity to convert
 *	same		whether to perform byte swapping
 *	big_endian	whether we are a big endian host
 */
private int
byteconv4(int from, int same, int big_endian)
{
	if (same)
		return from;
	else if (big_endian) {		/* lsb -> msb conversion on msb */
		union {
			int i;
			char c[4];
		} retval, tmpval;

		tmpval.i = from;
		retval.c[0] = tmpval.c[3];
		retval.c[1] = tmpval.c[2];
		retval.c[2] = tmpval.c[1];
		retval.c[3] = tmpval.c[0];

		return retval.i;
	}
	else
		return ntohl(from);	/* msb -> lsb conversion on lsb */
}

/*
 * byteconv2
 * Same as byteconv4, but for shorts
 */
private short
byteconv2(int from, int same, int big_endian)
{
	if (same)
		return from;
	else if (big_endian) {		/* lsb -> msb conversion on msb */
		union {
			short s;
			char c[2];
		} retval, tmpval;

		tmpval.s = (short) from;
		retval.c[0] = tmpval.c[1];
		retval.c[1] = tmpval.c[0];

		return retval.s;
	}
	else
		return ntohs(from);	/* msb -> lsb conversion on lsb */
}
#endif

a458 1
#ifdef HAVE_GETOPT_LONG
a459 1
#endif
a462 1
#ifdef HAVE_GETOPT_LONG
d466 11
a476 31
	(void)puts(
"Usage: file [OPTION]... [FILE]...\n"
"Determine file type of FILEs.\n"
"\n"
"  -m, --magic-file LIST      use LIST as a colon-separated list of magic\n"
"                               number files\n"
"  -z, --uncompress           try to look inside compressed files\n"
"  -b, --brief                do not prepend filenames to output lines\n"
"  -c, --checking-printout    print the parsed form of the magic file, use in\n"
"                               conjunction with -m to debug a new magic file\n"
"                               before installing it\n"
"  -e, --exclude              exclude test from the list of test to be\n"
"                               performed for file. Valid tests are:\n"
"                               ascii, apptype, elf, compress, soft, tar\n"
"  -f, --files-from FILE      read the filenames to be examined from FILE\n"
"  -F, --separator string     use string as separator instead of `:'\n"
"  -k, --keep-going           don't stop at the first match\n"
"  -L, --dereference          causes symlinks to be followed\n"
"  -n, --no-buffer            do not buffer output\n"
"  -N, --no-pad               do not pad output\n"
"  -p, --preserve-date        preserve access times on files\n"
"  -r, --raw                  don't translate unprintable chars to \\ooo\n"
"  -s, --special-files        treat special (block/char devices) files as\n"
"                             ordinary ones\n"
"or\n"
"      --help                 display this help and exit\n"
"or\n"
"      --version              output version information and exit\n"
"or\n"
"  -C, --compile              compile file specified by -m\n"
);
a478 1
#endif
@


1.17
log
@Our version of file(1) doesn't have the MIME magic file, so remove
references to -i/--mime and no longer accept them on the command line.
Update the HISTORY section to be less confusing.

Based on a diff to tech@@ by Mikolaj Kucharski, mikolaj (dot) kucharski
(at) gmail (dot) com.

Prompted by jmc@@; input from and ok jmc@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.16 2004/12/04 19:55:12 jaredy Exp $ */
a42 1
#include <fcntl.h>	/* for open() */
d75 1
a75 1
FILE_RCSID("@@(#)$Id: file.c,v 1.16 2004/12/04 19:55:12 jaredy Exp $")
d80 1
a80 1
#define SYMLINKFLAG "L"
d85 2
a86 2
#define USAGE	"Usage: %s [-bck" SYMLINKFLAG "Nnrsvz] [-F separator] [-f namefile] [-m magicfiles] file ...\n" \
		"       %s [-m magicfiles] -C\n"
d95 2
a96 1
	nobuffer = 0;   /* Do not buffer stdout 		*/
d100 1
a100 3
private char *separator = ":";	/* Default field separator	*/

private char *progname;		/* used throughout 		*/
d103 1
d126 1
a126 1
	int c;
d131 2
a132 1
#define OPTSTRING	"bcCdf:F:kLm:nNprsvz"
d135 1
a135 1
	private struct option long_options[] =
d142 1
d148 1
d160 1
d165 15
d181 2
a182 1
	setlocale(LC_CTYPE, ""); /* makes islower etc work for other langs */
a189 5
	if ((progname = strrchr(argv[0], '/')) != NULL)
		progname++;
	else
		progname = argv[0];

d195 1
a195 1
			size_t len = strlen(home) + 8;
d198 1
a198 1
				(void)strlcat(usermagic, "/.magic", len);
d206 3
d222 3
d237 11
d282 1
a282 1
			(void) fprintf(stdout, "%s-%d.%.2d\n", progname,
d284 1
a284 1
			(void) fprintf(stdout, "magic file from %s\n",
d294 3
d313 1
a313 1
			(void)fprintf(stderr, "%s: %s\n", progname,
d320 1
a320 1
			(void)fprintf(stderr, "%s: %s\n", progname,
d346 1
d352 1
d355 1
a355 1
	if (magic)
d359 1
a359 1
		(void)fprintf(stderr, "%s: %s\n", progname, strerror(errno));
d364 1
a364 1
		    progname, magic_error(magic));
d385 1
a385 1
			    progname, fn, strerror(errno));
d390 2
a391 1
			cwid = file_mbswidth(buf) - 1;
d400 1
a400 1
		buf[file_mbswidth(buf)-1] = '\0';
d403 1
a403 1
			(void) fflush(stdout);
d406 1
a406 1
	(void) fclose(f);
d409 3
d418 9
a426 3
	if (wid > 0 && !bflag)
		(void) printf("%s%s%*s ", std_in ? "/dev/stdin" : inname,
		    separator, (int) (nopad ? 0 : (wid - file_mbswidth(inname))), "");
d430 1
a430 1
		printf("ERROR: %s\n", magic_error(magic));
d432 1
a432 1
		printf("%s\n", type);
d496 1
a496 1
#ifdef HAVE_WCHAR_H
d530 1
a530 1
	(void)fprintf(stderr, USAGE, progname, progname);
d541 1
a541 1
	puts(
d552 3
d565 1
d567 1
d569 2
@


1.16
log
@sync manual and usage to file-4.09; bits from and ok ian and jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.15 2004/09/25 09:19:35 otto Exp $ */
d76 1
a76 1
FILE_RCSID("@@(#)$Id: file.c,v 1.15 2004/09/25 09:19:35 otto Exp $")
d132 1
a132 1
#define OPTSTRING	"bcCdf:F:ikLm:nNprsvz"
a143 1
		{"mime", 0, 0, 'i'},
a226 3
		case 'i':
			flags |= MAGIC_MIME;
			break;
a507 1
"  -i, --mime                 output mime type strings\n"
@


1.15
log
@tidy buffer sizes, from Alexander Farber, PR 3924. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.14 2004/05/19 02:32:35 tedu Exp $ */
d76 1
a76 1
FILE_RCSID("@@(#)$Id: file.c,v 1.14 2004/05/19 02:32:35 tedu Exp $")
d86 2
a87 1
# define USAGE  "Usage: %s [-bcik" SYMLINKFLAG "nNsvz] [-f namefile] [-F separator] [-m magicfiles] file...\n       %s -C -m magicfiles\n"
@


1.14
log
@big update to file 4.09.  ok ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d76 1
a76 1
FILE_RCSID("@@(#)$Id: file.c,v 1.92 2004/03/22 21:34:39 christos Exp $")
d356 1
a356 1
		while (fgets(buf, MAXPATHLEN, f) != NULL) {
d365 1
a365 1
	while (fgets(buf, MAXPATHLEN, f) != NULL) {
@


1.13
log
@protos
@
text
@d1 1
a1 2
/*	$OpenBSD: file.c,v 1.12 2003/06/13 18:31:14 deraadt Exp $	*/

a2 2
 * file - find type of a file or files - main program.
 *
d29 3
d33 2
a34 3
#ifndef	lint
static char *moduleid = "$OpenBSD: file.c,v 1.12 2003/06/13 18:31:14 deraadt Exp $";
#endif	/* lint */
d38 1
d44 3
a46 5
#if (__COHERENT__ >= 0x420)
# include <sys/utime.h>
#else
# ifdef USE_UTIMES
#  include <sys/time.h>
d48 5
a52 1
#  include <utime.h>
d55 1
d57 13
a69 1
#include <err.h>
d74 5
a78 1
#include "file.h"
d81 1
a81 1
# define USAGE  "Usage: %s [-vbczL] [-f namefile] [-m magicfiles] file...\n"
d83 1
a83 1
# define USAGE  "Usage: %s [-vbcz] [-f namefile] [-m magicfiles] file...\n"
d86 4
a89 2
#ifndef MAGIC
# define MAGIC "/etc/magic"
d92 22
a113 8
int 			/* Global command-line options 		*/
	debug = 0, 	/* debugging 				*/
	bflag = 0,	/* Don't print filename			*/
	lflag = 0,	/* follow Symlinks (BSD only) 		*/
	zflag = 0;	/* follow (uncompress) compressed files */

int			/* Misc globals				*/
	nmagic = 0;	/* number of valid magic[]s 		*/
d115 3
a117 1
struct  magic *magic;	/* array of magic entries		*/
a118 10
char *magicfile;	/* where magic be found 		*/

int lineno;		/* line number in the magic file	*/


static void	unwrap(char *fn);
#if 0
static int	byteconv4(int, int, int);
static short	byteconv2(int, int, int);
#endif
d127 38
a164 2
	int check = 0, didsomefiles = 0, errflg = 0, ret = 0, app = 0;
	extern char *__progname;
d166 4
a169 2
	if (!(magicfile = getenv("MAGIC")))
		magicfile = MAGIC;
d171 27
a197 1
	while ((c = getopt(argc, argv, "bvcdf:Lm:z")) != -1)
d199 6
a204 4
		case 'v':
			(void) printf("%s-%d.%d\n", __progname,
				       FILE_VERSION_MAJOR, patchlevel);
			return 1;
d209 4
a212 1
			++check;
d215 1
a215 1
			++debug;
d218 3
a220 6
			if (!app) {
				ret = apprentice(magicfile, check);
				if (check)
					exit(ret);
				app = 1;
			}
d224 8
a231 3
#ifdef S_IFLNK
		case 'L':
			++lflag;
a232 1
#endif
d236 23
d260 1
a260 1
			zflag++;
d262 5
d274 1
a274 2
		(void) fprintf(stderr, USAGE, __progname);
		exit(2);
d277 20
a296 5
	if (!app) {
		ret = apprentice(magicfile, check);
		if (check)
			exit(ret);
		app = 1;
d301 1
a301 2
			fprintf(stderr, USAGE, __progname);
			exit(2);
d303 2
a304 1
	} else {
d307 1
a307 1
			nw = strlen(argv[i]);
d319 17
d339 2
a340 3
static void
unwrap(fn)
char *fn;
d351 3
a353 2
			err(1, "Cannot open `%s'", fn);
			/*NOTREACHED*/
d356 2
a357 2
		while (fgets(buf, sizeof(buf), f) != NULL) {
			cwid = strlen(buf) - 1;
d365 2
a366 2
	while (fgets(buf, sizeof(buf), f) != NULL) {
		buf[strlen(buf)-1] = '\0';
d368 2
d375 17
d401 2
a402 5
static int
byteconv4(from, same, big_endian)
    int from;
    int same;
    int big_endian;
d404 18
a421 19
  if (same)
    return from;
  else if (big_endian)		/* lsb -> msb conversion on msb */
  {
    union {
      int i;
      char c[4];
    } retval, tmpval;

    tmpval.i = from;
    retval.c[0] = tmpval.c[3];
    retval.c[1] = tmpval.c[2];
    retval.c[2] = tmpval.c[1];
    retval.c[3] = tmpval.c[0];

    return retval.i;
  }
  else
    return ntohl(from);		/* msb -> lsb conversion on lsb */
d428 2
a429 5
static short
byteconv2(from, same, big_endian)
	int from;
	int same;
	int big_endian;
d431 16
a446 17
  if (same)
    return from;
  else if (big_endian)		/* lsb -> msb conversion on msb */
  {
    union {
      short s;
      char c[2];
    } retval, tmpval;

    tmpval.s = (short) from;
    retval.c[0] = tmpval.c[1];
    retval.c[1] = tmpval.c[0];

    return retval.s;
  }
  else
    return ntohs(from);		/* msb -> lsb conversion on lsb */
d450 2
a451 7
/*
 * process - process input file
 */
void
process(inname, wid)
const char	*inname;
int wid;
d453 13
a465 11
	int	fd = 0;
	static  const char stdname[] = "standard input";
	unsigned char	buf[HOWMANY+1];	/* one extra for terminating '\0' */
	struct stat	sb;
	int nbytes = 0;	/* number of bytes read from a datafile */
	char match = '\0';

	if (strcmp("-", inname) == 0) {
		if (fstat(0, &sb)<0) {
			err(1, "cannot fstat `%s'", stdname);
			/*NOTREACHED*/
d467 8
a474 2
		inname = stdname;
	}
d476 1
a476 21
	if (wid > 0 && !bflag)
	     (void) printf("%s:%*s ", inname, 
			   (int) (wid - strlen(inname)), "");

	if (inname != stdname) {
	    /*
	     * first try judging the file based on its filesystem status
	     */
	    if (fsmagic(inname, &sb) != 0) {
		    putchar('\n');
		    return;
	    }

	    if ((fd = open(inname, O_RDONLY)) < 0) {
		    /* We can't open it, but we were able to stat it. */
		    if (sb.st_mode & 0002) ckfputs("writable, ", stdout);
		    if (sb.st_mode & 0111) ckfputs("executable, ", stdout);
		    ckfprintf(stdout, "can't read `%s' (%s).\n",
			inname, strerror(errno));
		    return;
	    }
d478 3
a480 20


	/*
	 * try looking at the first HOWMANY bytes
	 */
	if ((nbytes = read(fd, (char *)buf, HOWMANY)) == -1) {
		err(1, "read failed");
		/*NOTREACHED*/
	}

	if (nbytes == 0)
		ckfputs("empty", stdout);
	else {
		buf[nbytes++] = '\0';	/* null-terminate it */
		match = tryit(buf, nbytes, zflag);
	}

#ifdef BUILTIN_ELF
	if (match == 's' && nbytes > 5)
		tryelf(fd, buf, nbytes);
d482 1
d484 6
a489 18
	if (inname != stdname) {
#ifdef RESTORE_TIME
		/*
		 * Try to restore access, modification times if read it.
		 */
# ifdef USE_UTIMES
		struct timeval  utsbuf[2];
		utsbuf[0].tv_sec = sb.st_atime;
		utsbuf[1].tv_sec = sb.st_mtime;

		(void) utimes(inname, utsbuf); /* don't care if loses */
# else
		struct utimbuf  utbuf;

		utbuf.actime = sb.st_atime;
		utbuf.modtime = sb.st_mtime;
		(void) utime(inname, &utbuf); /* don't care if loses */
# endif
d491 1
a491 3
		(void) close(fd);
	}
	(void) putchar('\n');
d494 3
a496 5

int
tryit(buf, nb, zflag)
unsigned char *buf;
int nb, zflag;
d498 26
a523 19
	/* try compression stuff */
	if (zflag && zmagic(buf, nb))
		return 'z';

	/* try tests in /etc/magic (or surrogate magic file) */
	if (softmagic(buf, nb))
		return 's';

	/* try known keywords, check whether it is ASCII */
	if (ascmagic(buf, nb))
		return 'a';

	/* see if it's international language text */
	if (internatmagic(buf, nb))
		return 'i';

	/* abandon hope, all ye who remain here */
	ckfputs("data", stdout);
		return '\0';
d525 1
@


1.12
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.11 2003/03/11 21:26:26 ian Exp $	*/
d34 1
a34 1
static char *moduleid = "$OpenBSD: file.c,v 1.11 2003/03/11 21:26:26 ian Exp $";
d97 1
a97 3
main(argc, argv)
int argc;
char *argv[];
@


1.11
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.10 2002/12/15 13:30:17 henning Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Ian F. Darwin and others.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d34 1
a34 1
static char *moduleid = "$OpenBSD: file.c,v 1.10 2002/12/15 13:30:17 henning Exp $";
@


1.10
log
@more writable spelling; torh
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.9 2002/11/29 00:27:03 millert Exp $	*/
d6 30
a35 22
 * Copyright (c) Ian F. Darwin, 1987.
 * Written by Ian F. Darwin.
 *
 * This software is not subject to any license of the American Telephone
 * and Telegraph Company or of the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on
 * any computer system, and to alter it and redistribute it freely, subject
 * to the following restrictions:
 *
 * 1. The author is not responsible for the consequences of use of this
 *    software, no matter how awful, even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 *    explicit claim or by omission.  Since few users ever read sources,
 *    credits must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.  Since few users
 *    ever read sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
d37 1
d39 1
a39 1
static char *moduleid = "$OpenBSD: file.c,v 1.9 2002/11/29 00:27:03 millert Exp $";
@


1.9
log
@Add -b flag (brief mode) like NetBSD and FreeBSD; Ibrahim Khalifa
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.8 2002/02/16 21:27:46 millert Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.8 2002/02/16 21:27:46 millert Exp $";
d319 1
a319 1
		    if (sb.st_mode & 0002) ckfputs("writeable, ", stdout);
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.7 1999/02/19 00:28:37 deraadt Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.7 1999/02/19 00:28:37 deraadt Exp $";
d58 1
a58 1
# define USAGE  "Usage: %s [-vczL] [-f namefile] [-m magicfiles] file...\n"
d60 1
a60 1
# define USAGE  "Usage: %s [-vcz] [-f namefile] [-m magicfiles] file...\n"
d69 1
d104 1
a104 1
	while ((c = getopt(argc, argv, "vcdf:Lm:z")) != -1)
d110 3
d304 1
a304 1
	if (wid > 0)
@


1.7
log
@broken usage line
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.6 1998/07/10 15:05:20 mickey Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.6 1998/07/10 15:05:20 mickey Exp $";
d82 1
a82 1
static void	unwrap		__P((char *fn));
d84 2
a85 2
static int	byteconv4	__P((int, int, int));
static short	byteconv2	__P((int, int, int));
@


1.6
log
@err/warn
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.5 1997/02/09 23:58:22 millert Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.5 1997/02/09 23:58:22 millert Exp $";
d155 4
a158 2
		if (!didsomefiles)
			err(2, USAGE, __progname);
@


1.5
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.4 1997/01/15 23:42:26 millert Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.11 1997/01/28 00:49:40 christos Exp $";
d50 1
a78 1
char *progname;		/* used throughout 			*/
d98 1
a98 5

	if ((progname = strrchr(argv[0], '/')) != NULL)
		progname++;
	else
		progname = argv[0];
d106 1
a106 1
			(void) fprintf(stdout, "%s-%d.%d\n", progname,
d143 1
a143 1
		(void) fprintf(stderr, USAGE, progname);
d155 3
a157 6
		if (!didsomefiles) {
			(void)fprintf(stderr, USAGE, progname);
			exit(2);
		}
	}
	else {
d188 1
a188 1
			error("Cannot open `%s' (%s).\n", fn, strerror(errno));
d292 1
a292 2
			error("cannot fstat `%s' (%s).\n", stdname,
			      strerror(errno));
d326 1
a326 1
		error("read failed (%s).\n", strerror(errno));
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 2
a2 1
/*	$OpenBSD: file.c,v 1.3 1996/06/26 05:32:56 deraadt Exp $	*/
d30 1
a30 1
static char *moduleid = "$OpenBSD: file.c,v 1.3 1996/06/26 05:32:56 deraadt Exp $";
d41 1
a41 1
#include <sys/utime.h>
d43 5
a47 1
#include <utime.h>
d51 1
a51 3
#ifdef __ELF__
#include <elf.h>
#endif
d82 5
a86 1
static void unwrap	__P((char *fn));
d190 14
a203 4
	if ((f = fopen(fn, "r")) == NULL) {
		error("Cannot open `%s' (%s).\n", fn, strerror(errno));
		/*NOTREACHED*/
	}
d205 1
a205 4
	while (fgets(buf, MAXPATHLEN, f) != NULL) {
		cwid = strlen(buf) - 1;
		if (cwid > wid)
			wid = cwid;
d208 1
a208 3
	rewind(f);

	while (fgets(buf, MAXPATHLEN, f) != NULL) {
d217 65
a292 1
	struct utimbuf  utbuf;
a343 9
#ifdef __ELF__
	/*
	 * ELF executables have multiple section headers in arbitrary
	 * file locations and thus file(1) cannot determine it from easily.
	 * Instead we traverse thru all section headers until a symbol table
	 * one is found or else the binary is stripped.
	 * XXX: This will not work for binaries of a different byteorder.
	 *	Should come up with a better fix.
	 */
d345 4
a348 15
	if (match == 's' && nbytes > sizeof (Elf32_Ehdr) &&
	    buf[EI_MAG0] == ELFMAG0 &&
	    buf[EI_MAG1] == ELFMAG1 &&
	    buf[EI_MAG2] == ELFMAG2 &&
	    buf[EI_MAG3] == ELFMAG3) {

		union {
			long l;
			char c[sizeof (long)];
		} u;
		Elf32_Ehdr elfhdr;
		int stripped = 1;

		u.l = 1;
		(void) memcpy(&elfhdr, buf, sizeof elfhdr);
d350 2
d353 1
a353 2
		 * If the system byteorder does not equal the object byteorder
		 * then don't test.
d355 13
a367 16
		if ((u.c[sizeof(long) - 1] + 1) == elfhdr.e_ident[5]) {
		    if (lseek(fd, elfhdr.e_shoff, SEEK_SET)<0)
			error("lseek failed (%s).\n", strerror(errno));

		    for ( ; elfhdr.e_shnum ; elfhdr.e_shnum--) {
			if (read(fd, buf, elfhdr.e_shentsize)<0)
			    error("read failed (%s).\n", strerror(errno));
			if (((Elf32_Shdr *)&buf)->sh_type == SHT_SYMTAB) {
			    stripped = 0;
			    break;
			}
		    }
		    if (stripped)
			(void) printf (", stripped");
		}
	}
a368 2

	if (inname != stdname)
d370 1
d391 4
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: file.c,v 1.2 1995/12/14 03:30:03 deraadt Exp $	*/
d29 1
a29 1
static char *moduleid = "$OpenBSD$";
d100 1
a100 1
	while ((c = getopt(argc, argv, "vcdf:Lm:z")) != EOF)
@


1.2
log
@update from netbsd
@
text
@d1 1
d29 1
a29 2
static char *moduleid = 
	"@@(#)$Id: file.c,v 1.8 1995/10/27 23:33:20 christos Exp $";
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
	"@@(#)$Id: file.c,v 1.7 1995/07/13 13:22:58 mycroft Exp $";
d54 1
a54 1
# define USAGE  "Usage: %s [-vczL] [-f namefile] [-m magicfile] file...\n"
d56 1
a56 1
# define USAGE  "Usage: %s [-vcz] [-f namefile] [-m magicfile] file...\n"
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
