head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.14.0.22
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.24
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.16
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.20
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.18
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.14
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.12
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.10
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.6.0.12
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@.\" @;


1.17
date	2016.04.24.07.02.07;	author jmc;	state Exp;
branches;
next	1.16;
commitid	WGXlDHs3buntbQ2o;

1.16
date	2016.03.04.16.25.31;	author czarkoff;	state Exp;
branches;
next	1.15;
commitid	d5dh0FiMnLXTze7H;

1.15
date	2016.03.04.15.25.35;	author czarkoff;	state Exp;
branches;
next	1.14;
commitid	poWIPlsEjiD2sBCZ;

1.14
date	2010.07.15.21.54.20;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.26.20.22.50;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.26.21.03.03;	author ajacoutot;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.31.19.20.10;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.13.18.31.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.10.09.12.10;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.11.21.26.26;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.15.09.44.42;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.12.21.47.48;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.23.21.39.53;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.06.02.38.19;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	97.02.09.23.58.28;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.09;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.17
log
@typos;
@
text
@.\" $OpenBSD: magic.5,v 1.16 2016/03/04 16:25:31 czarkoff Exp $
.\"
.\" @@(#)$FreeBSD: src/usr.bin/file/magic.5,v 1.11 2000/03/01 12:19:39 sheldonh Exp $
.\"
.\" install as magic.4 on USG, magic.5 on V7 or Berkeley systems.
.\"
.\" Copyright (c) Ian F. Darwin 1986-1995.
.\" Software written by Ian F. Darwin and others;
.\" maintained 1995-present by Christos Zoulas and others.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice immediately at the beginning of the file, without modification,
.\"    this list of conditions, and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
.\" ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.Dd $Mdocdate: March 4 2016 $
.Dt MAGIC 5
.Os
.\" install as magic.4 on USG, magic.5 on V7, Berkeley and Linux systems.
.Sh NAME
.Nm magic
.Nd file command's magic pattern file
.Sh DESCRIPTION
This manual page documents the format of the magic file as
used by the
.Xr file 1
command, version 4.24.
The
.Xr file 1
command identifies the type of a file using,
among other tests,
a test for whether the file contains certain
.Dq "magic patterns" .
The file
.Pa /etc/magic
specifies what magic numbers are to be tested for,
what message to print if a particular magic number is found,
and additional information to extract from the file.
.Pp
Each line of the file specifies a test to be performed.
A test compares the data starting at a particular offset
in the file with a byte value, a string or a numeric value.
If the test succeeds, a message is printed.
The line consists of the following fields:
.Bl -tag -width ".Dv message"
.It Dv offset
A number specifying the offset, in bytes, into the file of the data
which is to be tested.
.It Dv type
The type of the data to be tested.
The possible values are:
.Bl -tag -width ".Dv lestring16"
.It Dv byte
A one-byte value.
.It Dv short
A two-byte value in this machine's native byte order.
.It Dv long
A four-byte value in this machine's native byte order.
.It Dv quad
An eight-byte value in this machine's native byte order.
.It Dv float
A 32-bit single precision IEEE floating point number in this machine's native byte order.
.It Dv double
A 64-bit double precision IEEE floating point number in this machine's native byte order.
.It Dv string
A string of bytes.
The string type specification can be optionally followed
by /[Bbc]*.
The
.Dq B
flag compacts whitespace in the target, which must
contain at least one whitespace character.
If the magic has
.Dv n
consecutive blanks, the target needs at least
.Dv n
consecutive blanks to match.
The
.Dq b
flag treats every blank in the target as an optional blank.
Finally the
.Dq c
flag, specifies case insensitive matching: lowercase
characters in the magic match both lower and upper case characters in the
target, whereas upper case characters in the magic only match uppercase
characters in the target.
.It Dv pstring
A Pascal-style string where the first byte is interpreted as the an
unsigned length.
The string is not NUL terminated.
.It Dv date
A four-byte value interpreted as a UNIX date.
.It Dv qdate
An eight-byte value interpreted as a UNIX date.
.It Dv ldate
A four-byte value interpreted as a UNIX-style date, but interpreted as
local time rather than UTC.
.It Dv qldate
An eight-byte value interpreted as a UNIX-style date, but interpreted as
local time rather than UTC.
.It Dv beshort
A two-byte value in big-endian byte order.
.It Dv belong
A four-byte value in big-endian byte order.
.It Dv bequad
An eight-byte value in big-endian byte order.
.It Dv befloat
A 32-bit single precision IEEE floating point number in big-endian byte order.
.It Dv bedouble
A 64-bit double precision IEEE floating point number in big-endian byte order.
.It Dv bedate
A four-byte value in big-endian byte order,
interpreted as a Unix date.
.It Dv beqdate
An eight-byte value in big-endian byte order,
interpreted as a Unix date.
.It Dv beldate
A four-byte value in big-endian byte order,
interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.
.It Dv beqldate
An eight-byte value in big-endian byte order,
interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.
.It Dv bestring16
A two-byte unicode (UCS16) string in big-endian byte order.
.It Dv leshort
A two-byte value in little-endian byte order.
.It Dv lelong
A four-byte value in little-endian byte order.
.It Dv lequad
An eight-byte value in little-endian byte order.
.It Dv lefloat
A 32-bit single precision IEEE floating point number in little-endian byte order.
.It Dv ledouble
A 64-bit double precision IEEE floating point number in little-endian byte order.
.It Dv ledate
A four-byte value in little-endian byte order,
interpreted as a UNIX date.
.It Dv leqdate
An eight-byte value in little-endian byte order,
interpreted as a UNIX date.
.It Dv leldate
A four-byte value in little-endian byte order,
interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.
.It Dv leqldate
An eight-byte value in little-endian byte order,
interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.
.It Dv lestring16
A two-byte unicode (UCS16) string in little-endian byte order.
.It Dv melong
A four-byte value in middle-endian (PDP-11) byte order.
.It Dv medate
A four-byte value in middle-endian (PDP-11) byte order,
interpreted as a UNIX date.
.It Dv meldate
A four-byte value in middle-endian (PDP-11) byte order,
interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.
.It Dv regex
A regular expression match in extended POSIX regular expression syntax
(like egrep).
Regular expressions can take exponential time to process,
and their performance is hard to predict, so their use is discouraged.
When used in production environments,
their performance should be carefully checked.
The type specification can be optionally followed by
.Dv /[c][s] .
The
.Dq c
flag makes the match case insensitive, while the
.Dq s
flag update the offset to the start offset of the match, rather than the end.
The regular expression is tested against line
.Dv N + 1
onwards, where
.Dv N
is the given offset.
Line endings are assumed to be in the machine's native format.
.Dv ^
and
.Dv $
match the beginning and end of individual lines, respectively,
not beginning and end of file.
.It Dv search
A literal string search starting at the given offset.
The same modifier flags can be used as for string patterns.
The modifier flags (if any) must be followed by
.Dv /number
the range, that is, the number of positions at which the match will be
attempted, starting from the start offset.
This is suitable for searching larger binary expressions
with variable offsets, using
.Dv \e
escapes for special characters.
The offset works as for regex.
.It Dv default
This is intended to be used with the test
.Em x
(which is always true) and a message that is to be used if there are
no other matches.
.El
.Pp
Each top-level magic pattern (see below for an explanation of levels)
is classified as text or binary according to the types used.
Types
.Dq regex
and
.Dq search
are classified as text tests, unless non-printable characters are used
in the pattern.
All other tests are classified as binary.
A top-level pattern is considered to be a test text
when all its patterns are text
patterns; otherwise, it is considered to be a binary pattern.
When matching a file, binary patterns are tried first; if no match is
found, and the file looks like text, then its encoding is determined
and the text patterns are tried.
.Pp
The numeric types may optionally be followed by
.Dv &
and a numeric value,
to specify that the value is to be AND'ed with the
numeric value before any comparisons are done.
Prepending a
.Dv u
to the type indicates that ordered comparisons should be unsigned.
.It Dv test
The value to be compared with the value from the file.
If the type is
numeric, this value
is specified in C form; if it is a string, it is specified as a C string
with the usual escapes permitted (e.g. \en for new-line).
.Pp
Numeric values
may be preceded by a character indicating the operation to be performed.
It may be
.Dv = ,
to specify that the value from the file must equal the specified value,
.Dv \*(Lt ,
to specify that the value from the file must be less than the specified
value,
.Dv \*(Gt ,
to specify that the value from the file must be greater than the specified
value,
.Dv & ,
to specify that the value from the file must have set all of the bits
that are set in the specified value,
.Dv ^ ,
to specify that the value from the file must have clear any of the bits
that are set in the specified value, or
.Dv ~ ,
the value specified after is negated before tested.
.Dv x ,
to specify that any value will match.
If the character is omitted, it is assumed to be
.Dv = .
Operators
.Dv & ,
.Dv ^ ,
and
.Dv ~
don't work with floats and doubles.
The operator
.Dv !\&
specifies that the line matches if the test does
.Em not
succeed.
.Pp
Numeric values are specified in C form; e.g.
.Dv 13
is decimal,
.Dv 013
is octal, and
.Dv 0x13
is hexadecimal.
.Pp
For string values, the string from the
file must match the specified string.
The operators
.Dv = ,
.Dv \*(Lt
and
.Dv \*(Gt
(but not
.Dv & )
can be applied to strings.
The length used for matching is that of the string argument
in the magic file.
This means that a line can match any non-empty string (usually used to
then print the string), with
.Em \*(Gt\e0
(because all non-empty strings are greater than the empty string).
.Pp
The special test
.Em x
always evaluates to true.
.It Dv message
The message to be printed if the comparison succeeds.
If the string contains a
.Xr printf 3
format specification, the value from the file (with any specified masking
performed) is printed using the message as the format string.
If the string begins with
.Dq \eb ,
the message printed is the remainder of the string with no whitespace
added before it: multiple matches are normally separated by a single
space.
.El
.Pp
A MIME type is given on a separate line, which must be the next
non-blank or comment line after the magic line that identifies the
file type, and has the following format:
.Bd -literal -offset indent
!:mime	MIMETYPE
.Ed
.Pp
i.e. the literal string
.Dq !:mime
followed by the MIME type.
.Pp
Some file formats contain additional information which is to be printed
along with the file type or need additional tests to determine the true
file type.
These additional tests are introduced by one or more
.Em \*(Gt
characters preceding the offset.
The number of
.Em \*(Gt
on the line indicates the level of the test; a line with no
.Em \*(Gt
at the beginning is considered to be at level 0.
Tests are arranged in a tree-like hierarchy:
If a test on a line at level
.Em n
succeeds, all following tests at level
.Em n+1
are performed, and the messages printed if the tests succeed, until a line
with level
.Em n
(or less) appears.
For more complex files, one can use empty messages to get just the
"if/then" effect, in the following way:
.Bd -literal -offset indent
0      string   MZ
\*(Gt0x18  leshort  \*(Lt0x40   MS-DOS executable
\*(Gt0x18  leshort  \*(Gt0x3f   extended PC executable (e.g., MS Windows)
.Ed
.Pp
Offsets do not need to be constant, but can also be read from the file
being examined.
If the first character following the last
.Em \*(Gt
is a
.Em \&(
then the string after the parenthesis is interpreted as an indirect offset.
That means that the number after the parenthesis is used as an offset in
the file.
The value at that offset is read, and is used again as an offset
in the file.
Indirect offsets are of the form:
.Em (( x [.[bslBSL]][+\-][ y ]) .
The value of
.Em x
is used as an offset in the file.
A byte, short or long is read at that offset depending on the
.Op bslBSLm
type specifier.
The capitalized types interpret the number as a big endian
value, whereas the small letter versions interpret the number as a little
endian value;
the
.Em m
type interprets the number as a middle endian (PDP-11) value.
To that number the value of
.Em y
is added and the result is used as an offset in the file.
The default type if one is not specified is long.
.Pp
That way variable length structures can be examined:
.Bd -literal -offset indent
# MS Windows executables are also valid MS-DOS executables
0           string  MZ
\*(Gt0x18       leshort \*(Lt0x40   MZ executable (MS-DOS)
# skip the whole block below if it is not an extended executable
\*(Gt0x18       leshort \*(Gt0x3f
\*(Gt\*(Gt(0x3c.l)  string  PE\e0\e0  PE executable (MS-Windows)
\*(Gt\*(Gt(0x3c.l)  string  LX\e0\e0  LX executable (OS/2)
.Ed
.Pp
This strategy of examining has a drawback: You must make sure that
you eventually print something, or users may get empty output (like, when
there is neither PE\e0\e0 nor LE\e0\e0 in the above example)
.Pp
If this indirect offset cannot be used directly, simple calculations are
possible: appending
.Em [+-*/%&|^]number
inside parentheses allows one to modify
the value read from the file before it is used as an offset:
.Bd -literal -offset indent
# MS Windows executables are also valid MS-DOS executables
0           string  MZ
# sometimes, the value at 0x18 is less that 0x40 but there's still an
# extended executable, simply appended to the file
\*(Gt0x18       leshort \*(Lt0x40
\*(Gt\*(Gt(4.s*512) leshort 0x014c  COFF executable (MS-DOS, DJGPP)
\*(Gt\*(Gt(4.s*512) leshort !0x014c MZ executable (MS-DOS)
.Ed
.Pp
Sometimes you do not know the exact offset as this depends on the length or
position (when indirection was used before) of preceding fields.
You can specify an offset relative to the end of the last up-level
field using
.Sq &
as a prefix to the offset:
.Bd -literal -offset indent
0           string  MZ
\*(Gt0x18       leshort \*(Gt0x3f
\*(Gt\*(Gt(0x3c.l)  string  PE\e0\e0    PE executable (MS-Windows)
# immediately following the PE signature is the CPU type
\*(Gt\*(Gt\*(Gt&0       leshort 0x14c     for Intel 80386
\*(Gt\*(Gt\*(Gt&0       leshort 0x184     for DEC Alpha
.Ed
.Pp
Indirect and relative offsets can be combined:
.Bd -literal -offset indent
0             string  MZ
\*(Gt0x18         leshort \*(Lt0x40
\*(Gt\*(Gt(4.s*512)   leshort !0x014c MZ executable (MS-DOS)
# if it's not COFF, go back 512 bytes and add the offset taken
# from byte 2/3, which is yet another way of finding the start
# of the extended executable
\*(Gt\*(Gt\*(Gt&(2.s-514) string  LE      LE executable (MS Windows VxD driver)
.Ed
.Pp
Or the other way around:
.Bd -literal -offset indent
0                 string  MZ
\*(Gt0x18             leshort \*(Gt0x3f
\*(Gt\*(Gt(0x3c.l)        string  LE\e0\e0  LE executable (MS-Windows)
# at offset 0x80 (-4, since relative offsets start at the end
# of the up-level match) inside the LE header, we find the absolute
# offset to the code area, where we look for a specific signature
\*(Gt\*(Gt\*(Gt(&0x7c.l+0x26) string  UPX     \eb, UPX compressed
.Ed
.Pp
Or even both!
.Bd -literal -offset indent
0                string  MZ
\*(Gt0x18            leshort \*(Gt0x3f
\*(Gt\*(Gt(0x3c.l)       string  LE\e0\e0 LE executable (MS-Windows)
# at offset 0x58 inside the LE header, we find the relative offset
# to a data area where we look for a specific signature
\*(Gt\*(Gt\*(Gt&(&0x54.l-3)  string  UNACE  \eb, ACE self-extracting archive
.Ed
.Pp
Finally, if you have to deal with offset/length pairs in your file, even the
second value in a parenthesized expression can be taken from the file itself,
using another set of parentheses.
Note that this additional indirect offset is always relative to the
start of the main indirect offset.
.Bd -literal -offset indent
0                 string       MZ
\*(Gt0x18             leshort      \*(Gt0x3f
\*(Gt\*(Gt(0x3c.l)        string       PE\e0\e0 PE executable (MS-Windows)
# search for the PE section called ".idata"...
\*(Gt\*(Gt\*(Gt&0xf4          search/0x140 .idata
# ...and go to the end of it, calculated from start+length;
# these are located 14 and 10 bytes after the section name
\*(Gt\*(Gt\*(Gt\*(Gt(&0xe.l+(-4)) string       PK\e3\e4 \eb, ZIP self-extracting archive
.Ed
.Sh SEE ALSO
.Xr file 1
\- the command that reads this file.
.Sh BUGS
The formats
.Dv long ,
.Dv belong ,
.Dv lelong ,
.Dv melong ,
.Dv short ,
.Dv beshort ,
.Dv leshort ,
.Dv date ,
.Dv bedate ,
.Dv medate ,
.Dv ledate ,
.Dv beldate ,
.Dv leldate ,
and
.Dv meldate
are system-dependent; perhaps they should be specified as a number
of bytes (2B, 4B, etc),
since the files being recognized typically come from
a system on which the lengths are invariant.
.\"
.\" From: guy@@sun.uucp (Guy Harris)
.\" Newsgroups: net.bugs.usg
.\" Subject: /etc/magic's format isn't well documented
.\" Message-ID: <2752@@sun.uucp>
.\" Date: 3 Sep 85 08:19:07 GMT
.\" Organization: Sun Microsystems, Inc.
.\" Lines: 136
.\"
.\" Here's a manual page for the format accepted by the "file" made by adding
.\" the changes I posted to the S5R2 version.
.\"
.\" Modified for Ian Darwin's version of the file command.
@


1.16
log
@fix broken list
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.15 2016/03/04 15:25:35 czarkoff Exp $
d353 1
a353 1
If a the test on a line at level
@


1.15
log
@fix typo
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.14 2010/07/15 21:54:20 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: July 15 2010 $
d317 1
a317 1
.Dv message
@


1.14
log
@some escapes i missed;
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.13 2009/11/26 20:22:50 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: November 26 2009 $
d357 1
a357 1
are performed, and the messages printed if the tests succeed, untile a line
@


1.13
log
@grammar;
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.12 2009/10/26 21:03:03 ajacoutot Exp $
d33 1
a33 1
.Dd $Mdocdate: October 26 2009 $
d374 1
a374 1
.Em (
@


1.12
log
@Bring man pages on par with our file(1) version (merge from upstream with
several tweaks).

As usual, several enhancements and inputs from jmc@@
Input from ian@@

ok jmc@@ ian@@
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.11 2007/05/31 19:20:10 jmc Exp $
d33 1
a33 1
.Dd $Mdocdate: May 31 2007 $
d111 1
a111 1
A eight-byte value interpreted as a UNIX date.
@


1.11
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.10 2003/06/13 18:31:14 deraadt Exp $
d33 1
a33 1
.Dd $Mdocdate$
d36 1
d39 1
a39 1
.Nd file command's magic number file
d44 1
a44 1
command, version 3.22.
d46 1
a46 1
.Nm file
d49 2
a50 3
a test for whether the file begins with a certain
.Dq magic number .
.Pp
d59 1
a59 2
in the file with a 1-byte, 2-byte, or 4-byte numeric value or
a string.
d62 2
a63 2
.Bl -tag -width indent
.It Sy offset
d66 1
a66 1
.It Sy type
d69 2
a70 2
.Bl -tag -width beshort
.It Sy byte
d72 11
a82 5
.It Sy short
A two-byte value (on most systems) in this machine's native byte order.
.It Sy long
A four-byte value (on most systems) in this machine's native byte order.
.It Sy string
d84 137
a220 23
.It Sy date
A four-byte value interpreted as a
.Ux
date.
.It Sy beshort
A two-byte value (on most systems) in big-endian byte order.
.It Sy belong
A four-byte value (on most systems) in big-endian byte order.
.It Sy bedate
A four-byte value (on most systems) in big-endian byte order,
interpreted as a
.Ux
date.
.It Sy leshort
A two-byte value (on most systems) in little-endian byte order.
.It Sy lelong
A four-byte value (on most systems) in little-endian byte order.
.It Sy ledate
A four-byte value (on most systems) in little-endian byte order,
interpreted as a
.Ux
date.
.El
d222 16
d240 1
a240 1
.Ql &
d245 1
a245 1
.Sq u
d247 1
a247 2
.Bl -tag -width indent
.It Sy test
d252 2
a253 4
with the usual escapes permitted (e.g.,
.Ql \en
for newline).
.It Sy ""
d257 1
a257 1
.Ql =
d259 1
a259 1
.Ql <
d262 1
a262 1
.Ql >
d265 1
a265 1
.Ql &
d268 1
a268 1
.Ql ^
d271 3
a273 1
.Sq x
d275 16
a290 6
If the character is omitted,
it is assumed to be
.Ql = .
.It Sy ""
Numeric values are specified in C form; e.g.,
.Dq 13
d292 1
a292 1
.Dq 013
d294 1
a294 1
.Dq 0x13
d296 3
a298 3
.It Sy ""
For string values, the byte string from the
file must match the specified byte string.
d300 2
a301 2
.Ql = ,
.Ql < ,
d303 1
a303 1
.Ql >
d305 1
a305 1
.Ql & )
d309 9
a317 5
This means that a line can match any string, and
then presumably print that string, by doing
.Ql >\e0
(because all strings are greater than the null string).
.It Sy message
d319 1
a319 2
If the string
contains a
d323 5
d330 11
d342 5
a346 4
along with the file type.
A line which begins with the character
.Ql >
indicates additional tests and messages to be printed.
d348 1
a348 1
.Ql >
d350 1
a350 1
.Ql >
d352 2
a353 7
.Pp
Each line at level
.Em n+1
is under the control of the line at level
.Em n
most closely preceding it in the magic file.
If the test on a line at level
d355 1
a355 1
succeeds, the tests specified in all the subsequent lines at level
d357 2
a358 3
are performed, and the messages printed if the tests succeed.
The next
line at level
d360 8
a367 1
terminates this.
d369 2
d372 1
a372 1
.Ql >
d374 1
a374 1
.Ql (
a379 1
.Pp
d381 1
a381 1
.Dq (x[.[bsl]][+-][y]) .
d383 1
a383 1
.Sq x
d385 2
a386 3
A byte, short or long is read at that offset
depending on the
.Dq [bsl]
d388 6
d395 1
a395 1
.Sq y
d397 16
a412 2
The default type
if one is not specified is long.
d414 77
a490 13
Sometimes you do not know the exact offset as this depends on the length of
preceding fields.
You can specify an offset relative to the end of the
last uplevel field (of course this may only be done for sublevel tests, i.e.,
test beginning with
.Ql > ) .
Such a relative offset is specified using
.Ql &
as a prefix to the offset.
.Sh FILES
.Bl -tag -width /etc/magic
.It Pa /etc/magic
.El
d493 1
d496 13
a508 8
.Li long ,
.Li belong ,
.Li lelong ,
.Li short ,
.Li beshort ,
.Li leshort ,
.Li date ,
.Li bedate ,
d510 1
a510 1
.Li ledate
a514 3
.Pp
There is (currently) no support for specified-endian data to be used in
indirect offsets.
@


1.10
log
@ian gives permission for 3/4 removal
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.9 2003/06/10 09:12:10 jmc Exp $
d33 1
a33 1
.Dd September 3, 1994
@


1.9
log
@- section reorder
- COMPATIBILITY merge
- macro cleanup
- kill whitespace at EOL
- new sentence, new line

ssh pages ok markus@@
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.8 2003/03/11 21:26:26 ian Exp $
a19 5
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"    This product includes software developed by Ian F. Darwin and others.
.\" 4. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
@


1.8
log
@Replace TPUM license with standard BSD-style license
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.7 2003/02/15 09:44:42 jmc Exp $
d10 1
a10 1
.\" 
d25 1
a25 1
.\"  
d243 6
a267 6
.Sh FILES
.Bl -tag -width /etc/magic
.It Pa /etc/magic
.El
.Sh SEE ALSO
.Xr file 1
@


1.7
log
@copyrights added;

file(1), magic(5): Ian F. Darwin
afterboot(8): Marshall M. Midden
x99token(1): Paul Borman
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.6 2000/04/12 21:47:48 aaron Exp $
d7 30
a36 22
.\" Copyright (c) Ian F. Darwin, 1987.
.\" Written by Ian F. Darwin.
.\"
.\" This software is not subject to any license of the American Telephone
.\" and Telegraph Company or of the Regents of the University of California.
.\"
.\" Permission is granted to anyone to use this software for any purpose on
.\" any computer system, and to alter it and redistribute it freely, subject
.\" to the following restrictions:
.\"
.\" 1. The author is not responsible for the consequences of use of this
.\"    software, no matter how awful, even if they arise from flaws in it.
.\"
.\" 2. The origin of this software must not be misrepresented, either by
.\"    explicit claim or by omission.  Since few users ever read sources,
.\"    credits must appear in the documentation.
.\"
.\" 3. Altered versions must be plainly marked as such, and must not be
.\"    misrepresented as being the original software.  Since few users
.\"    ever read sources, credits must appear in the documentation.
.\"
.\" 4. This notice may not be removed or altered.
@


1.6
log
@Trailing whitespace begone!
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.5 2000/03/23 21:39:53 aaron Exp $
d6 23
@


1.5
log
@More pedantic man page formatting insanity, lalala
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.4 2000/03/06 02:38:19 aaron Exp $
d108 1
a108 1
to specify that the value from the file must have set all of the bits 
d111 1
a111 1
to specify that the value from the file must have clear any of the bits 
d128 1
a128 1
file must match the specified byte string. 
d190 1
a190 1
The value of 
d194 1
a194 1
depending on the 
d207 1
a207 1
test beginning with 
d213 1
a213 1
The formats 
d225 1
a225 1
of bytes (2B, 4B, etc), 
d245 1
a245 1
.\" 
@


1.4
log
@mdoc'ify; from FreeBSD, with many modifications by me.
@
text
@d1 1
a1 1
.\" $OpenBSD: magic.5,v 1.3 1997/02/09 23:58:28 millert Exp $
d17 2
a18 1
command, version 3.22. The
@


1.3
log
@Updates file(1) to version 3.22 by way to NetBSD.
@
text
@d1 4
a4 1
.\" $OpenBSD: magic.5,v 1.2 1996/06/26 05:32:59 deraadt Exp $
d6 8
a13 4
.TH MAGIC 5 "Public Domain"
.SH NAME
magic \- file command's magic number file
.SH DESCRIPTION
d16 1
a16 1
.BR file (1)
d18 1
a18 1
.B file
d22 2
a23 1
.IR "magic number" .
d25 1
a25 1
.I /etc/magic
d29 1
a29 1
.PP
d33 2
a34 1
a string.  If the test succeeds, a message is printed.
d36 2
a37 1
.IP offset \w'message'u+2n
d40 5
a44 4
.IP type
The type of the data to be tested.  The possible values are:
.RS
.IP byte \w'message'u+2n
d46 1
a46 1
.IP short
d48 1
a48 1
.IP long
d50 1
a50 1
.IP string
d52 5
a56 3
.IP date
A four-byte value interpreted as a unix date.
.IP beshort
d58 1
a58 1
.IP belong
d60 1
a60 1
.IP bedate
d62 4
a65 2
interpreted as a unix date.
.IP leshort
d67 1
a67 1
.IP lelong
d69 1
a69 1
.IP ledate
d71 6
a76 3
interpreted as a unix date.
.RE
.PP
d78 1
a78 1
.B &
d81 3
a83 2
numeric value before any comparisons are done.  Prepending a
.B u
d85 4
a88 2
.IP test
The value to be compared with the value from the file.  If the type is
d91 4
a94 2
with the usual escapes permitted (e.g. \en for new-line).
.IP
d98 1
a98 1
.BR = ,
d100 1
a100 1
.BR < ,
d103 1
a103 1
.BR > ,
d106 1
a106 1
.BR & ,
d109 1
a109 1
.BR ^ ,
d112 3
a114 2
.BR x ,
to specify that any value will match. If the character is omitted,
d116 4
a119 4
.BR = .
.IP
Numeric values are specified in C form; e.g.
.B 13
d121 1
a121 1
.B 013
d123 1
a123 1
.B 0x13
d125 1
a125 1
.IP
d129 2
a130 2
.BR = ,
.B <
d132 1
a132 1
.B >
d134 1
a134 1
.BR & )
d137 2
a138 1
in the magic file.  This means that a line can match any string, and
d140 1
a140 1
.B >\e0
d142 3
a144 2
.IP message
The message to be printed if the comparison succeeds.  If the string
d146 1
a146 1
.BR printf (3S)
d149 2
a150 1
.PP
d152 6
a157 4
along with the file type.  A line which begins with the character
.B >
indicates additional tests and messages to be printed.  The number of
.B >
d159 1
a159 1
.B >
d161 1
d163 1
a163 1
.IB n \(pl1
d165 1
a165 1
.IB n
d168 1
a168 1
.I n
d170 3
a172 2
.IB n \(pl1
are performed, and the messages printed if the tests succeed.  The next
d174 1
a174 1
.I n
d176 1
d178 1
a178 1
.B >
d180 1
a180 1
.B (
d183 6
a188 3
the file. The value at that offset is read, and is used again as an offset
in the file. Indirect offsets are of the form:
.BI (( x [.[bsl]][+-][ y ]).
d190 3
a192 2
.I x
is used as an offset in the file. A byte, short or long is read at that offset
d194 6
a199 4
.B [bsl] 
type specifier. To that number the value of
.I y
is added and the result is used as an offset in the file. The default type
d201 1
a201 1
.PP
d203 3
a205 2
preceding fields. You can specify an offset relative to the end of the
last uplevel field (of course this may only be done for sublevel tests, i.e.
d207 3
a209 3
.B >
). Such a relative offset is specified using
.B &
d211 1
a211 1
.SH BUGS
d213 8
a220 8
.IR long ,
.IR belong ,
.IR lelong ,
.IR short ,
.IR beshort ,
.IR leshort ,
.IR date ,
.IR bedate ,
d222 1
a222 1
.I ledate
d227 1
a227 1
.PP
d230 6
a235 3
.SH SEE ALSO
.BR file (1)
\- the command that reads this file.
@


1.2
log
@rcsid
@
text
@d1 2
a2 1
.\" @@(#)$OpenBSD: magic.5,v 1.1.1.1 1995/10/18 08:45:09 deraadt Exp $
a3 1
.\" install as magic.5 on USG, magic.5 on V7 or Berkeley systems.
d7 5
a11 2
The
.IR file (1)
d17 1
a17 1
.B /etc/magic
d120 1
a120 1
.IR printf (3S)
d163 9
d192 1
a192 1
.IR file (1)
@


1.1
log
@Initial revision
@
text
@d1 1
a194 1
.\" @@(#)$Id: magic.5,v 1.8 1995/03/27 16:16:28 christos Exp $
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
