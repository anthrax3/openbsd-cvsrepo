head	1.24;
access;
symbols
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.24
date	2016.08.26.08.50.31;	author guenther;	state Exp;
branches;
next	1.23;
commitid	K6j5dsKRXHFwdv82;

1.23
date	2016.05.01.11.26.19;	author nicm;	state Exp;
branches;
next	1.22;
commitid	D6qi74ABDUDsVHHV;

1.22
date	2016.05.01.10.56.03;	author nicm;	state Exp;
branches;
next	1.21;
commitid	4wKczbrqqtYj8YHM;

1.21
date	2016.05.01.08.53.26;	author nicm;	state Exp;
branches;
next	1.20;
commitid	IaYroIhcp05zZpBH;

1.20
date	2016.05.01.08.48.39;	author nicm;	state Exp;
branches;
next	1.19;
commitid	pIoqErW4Gu1kXma4;

1.19
date	2016.04.30.22.03.30;	author nicm;	state Exp;
branches;
next	1.18;
commitid	qhNnyMWP2efg1xER;

1.18
date	2016.04.30.21.42.11;	author nicm;	state Exp;
branches;
next	1.17;
commitid	VzzcvK224IrqJfVf;

1.17
date	2016.04.30.21.10.28;	author nicm;	state Exp;
branches;
next	1.16;
commitid	wjrNOGpsANfzAWXU;

1.16
date	2016.02.20.15.29.37;	author nicm;	state Exp;
branches;
next	1.15;
commitid	IF76bSyG0gqgLCf4;

1.15
date	2015.10.06.08.20.10;	author nicm;	state Exp;
branches;
next	1.14;
commitid	ePJgE2oCLn8xG7Xd;

1.14
date	2015.10.05.19.50.38;	author nicm;	state Exp;
branches;
next	1.13;
commitid	UEKcLh5DlhDlA9sA;

1.13
date	2015.08.12.09.39.43;	author nicm;	state Exp;
branches;
next	1.12;
commitid	ZZu8lZJzrYxH6wRJ;

1.12
date	2015.08.12.09.29.49;	author nicm;	state Exp;
branches;
next	1.11;
commitid	k7ulsQmwqflsBCkU;

1.11
date	2015.08.12.07.43.27;	author nicm;	state Exp;
branches;
next	1.10;
commitid	74MzzIBh2PL4uXWG;

1.10
date	2015.08.11.23.03.26;	author nicm;	state Exp;
branches;
next	1.9;
commitid	zErvsEYpX0YE2cAZ;

1.9
date	2015.08.11.22.48.09;	author nicm;	state Exp;
branches;
next	1.8;
commitid	t57yDj9HYqfCrtyZ;

1.8
date	2015.08.11.22.18.43;	author nicm;	state Exp;
branches;
next	1.7;
commitid	t7mTpLYD1wpKhix5;

1.7
date	2015.08.11.22.12.48;	author nicm;	state Exp;
branches;
next	1.6;
commitid	W04QZVVfrRYK2LJv;

1.6
date	2015.05.29.15.58.01;	author nicm;	state Exp;
branches;
next	1.5;
commitid	8ROk53IECMBvOidn;

1.5
date	2015.05.29.15.11.08;	author nicm;	state Exp;
branches;
next	1.4;
commitid	AQilYnaKmfj8y4T5;

1.4
date	2015.05.29.14.52.10;	author nicm;	state Exp;
branches;
next	1.3;
commitid	RLophMfMfmMskw2Z;

1.3
date	2015.04.25.16.35.47;	author brynet;	state Exp;
branches;
next	1.2;
commitid	MzurxIxZvRrMQ9qG;

1.2
date	2015.04.24.17.19.06;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	rfhGFT81OGyIsy3C;

1.1
date	2015.04.24.16.24.11;	author nicm;	state Exp;
branches;
next	;
commitid	4VUU04TZM8ebPiy4;


desc
@@


1.24
log
@Pull in <time.h> for ctime_r, gmtime, etc

ok deraadt@@
@
text
@/* $OpenBSD: magic-test.c,v 1.23 2016/05/01 11:26:19 nicm Exp $ */

/*
 * Copyright (c) 2015 Nicholas Marriott <nicm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <vis.h>

#include "magic.h"
#include "xmalloc.h"

static int magic_test_line(struct magic_line *, struct magic_state *);

static struct magic_line *
magic_get_named(struct magic *m, const char *name)
{
	struct magic_line	ml;

	ml.name = name;
	return (RB_FIND(magic_named_tree, &m->named, &ml));
}

static enum magic_type
magic_reverse_type(struct magic_state *ms, enum magic_type type)
{
	if (!ms->reverse)
		return (type);
	switch (type) {
	case MAGIC_TYPE_BESHORT:
		return (MAGIC_TYPE_LESHORT);
	case MAGIC_TYPE_BELONG:
		return (MAGIC_TYPE_LELONG);
	case MAGIC_TYPE_BEQUAD:
		return (MAGIC_TYPE_LEQUAD);
	case MAGIC_TYPE_UBESHORT:
		return (MAGIC_TYPE_ULESHORT);
	case MAGIC_TYPE_UBELONG:
		return (MAGIC_TYPE_ULELONG);
	case MAGIC_TYPE_UBEQUAD:
		return (MAGIC_TYPE_ULEQUAD);
	case MAGIC_TYPE_BEFLOAT:
		return (MAGIC_TYPE_LEFLOAT);
	case MAGIC_TYPE_BEDOUBLE:
		return (MAGIC_TYPE_LEDOUBLE);
	case MAGIC_TYPE_BEDATE:
		return (MAGIC_TYPE_LEDATE);
	case MAGIC_TYPE_BEQDATE:
		return (MAGIC_TYPE_LEQDATE);
	case MAGIC_TYPE_BELDATE:
		return (MAGIC_TYPE_LELDATE);
	case MAGIC_TYPE_BEQLDATE:
		return (MAGIC_TYPE_LEQLDATE);
	case MAGIC_TYPE_UBEDATE:
		return (MAGIC_TYPE_ULEDATE);
	case MAGIC_TYPE_UBEQDATE:
		return (MAGIC_TYPE_ULEQDATE);
	case MAGIC_TYPE_UBELDATE:
		return (MAGIC_TYPE_ULELDATE);
	case MAGIC_TYPE_UBEQLDATE:
		return (MAGIC_TYPE_ULEQLDATE);
	case MAGIC_TYPE_LESHORT:
		return (MAGIC_TYPE_BESHORT);
	case MAGIC_TYPE_LELONG:
		return (MAGIC_TYPE_LELONG);
	case MAGIC_TYPE_LEQUAD:
		return (MAGIC_TYPE_LEQUAD);
	case MAGIC_TYPE_ULESHORT:
		return (MAGIC_TYPE_UBESHORT);
	case MAGIC_TYPE_ULELONG:
		return (MAGIC_TYPE_UBELONG);
	case MAGIC_TYPE_ULEQUAD:
		return (MAGIC_TYPE_UBEQUAD);
	case MAGIC_TYPE_LEFLOAT:
		return (MAGIC_TYPE_BEFLOAT);
	case MAGIC_TYPE_LEDOUBLE:
		return (MAGIC_TYPE_BEDOUBLE);
	case MAGIC_TYPE_LEDATE:
		return (MAGIC_TYPE_BEDATE);
	case MAGIC_TYPE_LEQDATE:
		return (MAGIC_TYPE_BEQDATE);
	case MAGIC_TYPE_LELDATE:
		return (MAGIC_TYPE_BELDATE);
	case MAGIC_TYPE_LEQLDATE:
		return (MAGIC_TYPE_BEQLDATE);
	case MAGIC_TYPE_ULEDATE:
		return (MAGIC_TYPE_UBEDATE);
	case MAGIC_TYPE_ULEQDATE:
		return (MAGIC_TYPE_UBEQDATE);
	case MAGIC_TYPE_ULELDATE:
		return (MAGIC_TYPE_UBELDATE);
	case MAGIC_TYPE_ULEQLDATE:
		return (MAGIC_TYPE_UBEQLDATE);
	default:
		return (type);
	}
}

static int
magic_one_eq(char a, char b, int cflag)
{
	if (a == b)
		return (1);
	if (cflag && islower((u_char)b) && tolower((u_char)a) == (u_char)b)
		return (1);
	return (0);
}

static int
magic_test_eq(const char *ap, size_t asize, const char *bp, size_t bsize,
    int cflag, int bflag, int Bflag)
{
	size_t	aoff, boff, aspaces, bspaces;

	aoff = boff = 0;
	while (aoff != asize && boff != bsize) {
		if (Bflag && isspace((u_char)ap[aoff])) {
			aspaces = 0;
			while (aoff != asize && isspace((u_char)ap[aoff])) {
				aspaces++;
				aoff++;
			}
			bspaces = 0;
			while (boff != bsize && isspace((u_char)bp[boff])) {
				bspaces++;
				boff++;
			}
			if (bspaces >= aspaces)
				continue;
			return (1);
		}
		if (magic_one_eq(ap[aoff], bp[boff], cflag)) {
			aoff++;
			boff++;
			continue;
		}
		if (bflag && isspace((u_char)bp[boff])) {
			boff++;
			continue;
		}
		if (ap[aoff] < bp[boff])
			return (-1);
		return (1);
	}
	return (0);
}

static int
magic_copy_from(struct magic_state *ms, ssize_t offset, void *dst, size_t size)
{
	if (offset < 0)
		offset = ms->offset;
	if (offset + size > ms->size)
		return (-1);
	memcpy(dst, ms->base + offset, size);
	return (0);
}

static void
magic_add_result(struct magic_state *ms, struct magic_line *ml,
    const char *fmt, ...)
{
	va_list	 ap;
	int	 separate;
	char	*s, *tmp, *add;

	va_start(ap, fmt);
	if (ml->stringify) {
		if (vasprintf(&s, fmt, ap) == -1) {
			va_end(ap);
			return;
		}
		va_end(ap);
		if (asprintf(&tmp, ml->result, s) == -1) {
			free(s);
			return;
		}
		free(s);
	} else {
		if (vasprintf(&tmp, ml->result, ap) == -1) {
			va_end(ap);
			return;
		}
		va_end(ap);
	}

	separate = 1;
	if (tmp[0] == '\\' && tmp[1] == 'b') {
		separate = 0;
		add = tmp + 2;
	} else
		add = tmp;

	if (separate && *ms->out != '\0')
		strlcat(ms->out, " ", sizeof ms->out);
	strlcat(ms->out, add, sizeof ms->out);

	free(tmp);
}

static void
magic_add_string(struct magic_state *ms, struct magic_line *ml,
    const char *s, size_t slen)
{
	char	*out;
	size_t	 outlen, offset;

	outlen = MAGIC_STRING_SIZE;
	if (outlen > slen)
		outlen = slen;
	for (offset = 0; offset < outlen; offset++) {
		if (s[offset] == '\0' || !isprint((u_char)s[offset])) {
			outlen = offset;
			break;
		}
	}
	out = xreallocarray(NULL, 4, outlen + 1);
	strvisx(out, s, outlen, VIS_TAB|VIS_NL|VIS_CSTYLE|VIS_OCTAL);
	magic_add_result(ms, ml, "%s", out);
	free(out);
}

static int
magic_test_signed(struct magic_line *ml, int64_t value, int64_t wanted)
{
	switch (ml->test_operator) {
	case 'x':
		return (1);
	case '<':
		return (value < wanted);
	case '[':
		return (value <= wanted);
	case '>':
		return (value > wanted);
	case ']':
		return (value >= wanted);
	case '=':
		return (value == wanted);
	case '&':
		return ((value & wanted) == wanted);
	case '^':
		return ((~value & wanted) == wanted);
	}
	return (-1);
}

static int
magic_test_unsigned(struct magic_line *ml, uint64_t value, uint64_t wanted)
{
	switch (ml->test_operator) {
	case 'x':
		return (1);
	case '<':
		return (value < wanted);
	case '[':
		return (value <= wanted);
	case '>':
		return (value > wanted);
	case ']':
		return (value >= wanted);
	case '=':
		return (value == wanted);
	case '&':
		return ((value & wanted) == wanted);
	case '^':
		return ((~value & wanted) == wanted);
	}
	return (-1);
}

static int
magic_test_double(struct magic_line *ml, double value, double wanted)
{
	switch (ml->test_operator) {
	case 'x':
		return (1);
	case '=':
		return (value == wanted);
	}
	return (-1);
}

static int
magic_test_type_none(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (0);
}

static int
magic_test_type_byte(struct magic_line *ml, struct magic_state *ms)
{
	int8_t	value;
	int	result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);

	if (ml->type_operator == '&')
		value &= (int8_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int8_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int8_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (int8_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (int8_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (int8_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int8_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%c", (int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_short(struct magic_line *ml, struct magic_state *ms)
{
	int16_t value;
	int	result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BESHORT))
		value = be16toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LESHORT))
		value = le16toh(value);

	if (ml->type_operator == '&')
		value &= (int16_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int16_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int16_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (int16_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (int16_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (int16_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int16_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%hd", (int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_long(struct magic_line *ml, struct magic_state *ms)
{
	int32_t value;
	int	result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BELONG))
		value = be32toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LELONG))
		value = le32toh(value);

	if (ml->type_operator == '&')
		value &= (int32_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int32_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int32_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (int32_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (int32_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (int32_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int32_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%d", (int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_quad(struct magic_line *ml, struct magic_state *ms)
{
	int64_t value;
	int	result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEQUAD))
		value = be64toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEQUAD))
		value = le64toh(value);

	if (ml->type_operator == '&')
		value &= (int64_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int64_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int64_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (int64_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (int64_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (int64_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int64_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%lld", (long long)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_ubyte(struct magic_line *ml, struct magic_state *ms)
{
	uint8_t value;
	int	result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);

	if (ml->type_operator == '&')
		value &= (uint8_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint8_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint8_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (uint8_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (uint8_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (uint8_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint8_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%c", (unsigned int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_ushort(struct magic_line *ml, struct magic_state *ms)
{
	uint16_t	value;
	int		result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == MAGIC_TYPE_UBESHORT)
		value = be16toh(value);
	if (ml->type == MAGIC_TYPE_ULESHORT)
		value = le16toh(value);

	if (ml->type_operator == '&')
		value &= (uint16_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint16_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint16_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (uint16_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (uint16_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (uint16_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint16_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%hu", (unsigned int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_ulong(struct magic_line *ml, struct magic_state *ms)
{
	uint32_t	value;
	int		result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == MAGIC_TYPE_UBELONG)
		value = be32toh(value);
	if (ml->type == MAGIC_TYPE_ULELONG)
		value = le32toh(value);

	if (ml->type_operator == '&')
		value &= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint32_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (uint32_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint32_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%u", (unsigned int)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_uquad(struct magic_line *ml, struct magic_state *ms)
{
	uint64_t	value;
	int		result;

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == MAGIC_TYPE_UBEQUAD)
		value = be64toh(value);
	if (ml->type == MAGIC_TYPE_ULEQUAD)
		value = le64toh(value);

	if (ml->type_operator == '&')
		value &= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint64_t)ml->type_operand;
	else if (ml->type_operator == '/')
		value /= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '%')
		value %= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '*')
		value *= (uint64_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint64_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%llu", (unsigned long long)value);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_float(struct magic_line *ml, struct magic_state *ms)
{
	uint32_t	value0;
	float		value;
	int		result;

	if (magic_copy_from(ms, -1, &value0, sizeof value0) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEFLOAT))
		value0 = be32toh(value0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEFLOAT))
		value0 = le32toh(value0);
	memcpy(&value, &value0, sizeof value);

	if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_double(ml, value, (float)ml->test_double);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%g", value);
		ms->offset += sizeof value0;
	}
	return (1);
}

static int
magic_test_type_double(struct magic_line *ml, struct magic_state *ms)
{
	uint64_t	value0;
	double		value;
	int		result;

	if (magic_copy_from(ms, -1, &value0, sizeof value0) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEDOUBLE))
		value0 = be64toh(value0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEDOUBLE))
		value0 = le64toh(value0);
	memcpy(&value, &value0, sizeof value);

	if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_double(ml, value, (double)ml->test_double);
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%g", value);
		ms->offset += sizeof value0;
	}
	return (1);
}

static int
magic_test_type_string(struct magic_line *ml, struct magic_state *ms)
{
	const char	*s, *cp;
	size_t		 slen;
	int		 result, cflag = 0, bflag = 0, Bflag = 0;

	cp = &ml->type_string[(sizeof "string") - 1];
	if (*cp != '\0') {
		if (*cp != '/')
			return (-1);
		cp++;
		for (; *cp != '\0'; cp++) {
			switch (*cp) {
			case 'B':
			case 'W':
				Bflag = 1;
				break;
			case 'b':
			case 'w':
				bflag = 1;
				break;
			case 'c':
				cflag = 1;
				break;
			case 't':
				break;
			default:
				return (-1);
			}
		}
	}

	s = ms->base + ms->offset;
	slen = ms->size - ms->offset;
	if (slen < ml->test_string_size)
		return (0);

	result = magic_test_eq(s, slen, ml->test_string, ml->test_string_size,
	    cflag, bflag, Bflag);
	switch (ml->test_operator) {
	case 'x':
		result = 1;
		break;
	case '<':
		result = result < 0;
		break;
	case '>':
		result = result > 0;
		break;
	case '=':
		slen = ml->test_string_size; /* only print what was found */
		result = result == 0;
		break;
	default:
		result = -1;
		break;
	}
	if (result == !ml->test_not) {
		if (ml->result != NULL)
			magic_add_string(ms, ml, s, slen);
		if (result && ml->test_operator == '=')
			ms->offset = s - ms->base + ml->test_string_size;
	}
	return (result);
}

static int
magic_test_type_pstring(struct magic_line *ml, struct magic_state *ms)
{
	const char	*s, *cp;
	size_t		 slen;
	int		 result;

	cp = &ml->type_string[(sizeof "pstring") - 1];
	if (*cp != '\0') {
		if (*cp != '/')
			return (-1);
		cp++;
		for (; *cp != '\0'; cp++) {
			switch (*cp) {
			default:
				return (-1);
			}
		}
	}

	s = ms->base + ms->offset;
	if (ms->size - ms->offset < 1)
		return (-1);
	slen = *(u_char *)s;
	if (slen + 1 > ms->size - ms->offset)
		return (-1);
	s++;

	if (slen < ml->test_string_size)
		result = -1;
	else if (slen > ml->test_string_size)
		result = 1;
	else
		result = memcmp(s, ml->test_string, ml->test_string_size);
	switch (ml->test_operator) {
	case 'x':
		result = 1;
		break;
	case '<':
		result = result < 0;
		break;
	case '>':
		result = result > 0;
		break;
	case '=':
		result = result == 0;
		break;
	default:
		result = -1;
		break;
	}
	if (result == !ml->test_not) {
		if (ml->result != NULL)
			magic_add_string(ms, ml, s, slen);
		if (result && ml->test_operator == '=')
			ms->offset += slen + 1;
	}
	return (result);
}

static int
magic_test_type_date(struct magic_line *ml, struct magic_state *ms)
{
	int32_t	value;
	int	result;
	time_t	t;
	char	s[64];

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_BELDATE))
		value = be32toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_LELDATE))
		value = le32toh(value);

	if (ml->type_operator == '&')
		value &= (int32_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int32_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int32_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int32_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		t = value;
		switch (ml->type) {
		case MAGIC_TYPE_LDATE:
		case MAGIC_TYPE_LELDATE:
		case MAGIC_TYPE_BELDATE:
			ctime_r(&t, s);
			break;
		default:
			asctime_r(gmtime(&t), s);
			break;
		}
		s[strcspn(s, "\n")] = '\0';
		magic_add_result(ms, ml, "%s", s);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_qdate(struct magic_line *ml, struct magic_state *ms)
{
	int64_t value;
	int	result;
	time_t	t;
	char	s[64];

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEQDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEQLDATE))
		value = be64toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEQDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEQLDATE))
		value = le64toh(value);

	if (ml->type_operator == '&')
		value &= (int64_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (int64_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (int64_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_signed(ml, value, (int64_t)ml->test_signed);
	if (result == !ml->test_not && ml->result != NULL) {
		t = value;
		switch (ml->type) {
		case MAGIC_TYPE_QLDATE:
		case MAGIC_TYPE_LEQLDATE:
		case MAGIC_TYPE_BEQLDATE:
			ctime_r(&t, s);
			break;
		default:
			asctime_r(gmtime(&t), s);
			break;
		}
		s[strcspn(s, "\n")] = '\0';
		magic_add_result(ms, ml, "%s", s);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_udate(struct magic_line *ml, struct magic_state *ms)
{
	uint32_t	value;
	int		result;
	time_t		t;
	char		s[64];

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_BEDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_BELDATE))
		value = be32toh(value);
	if (ml->type == magic_reverse_type(ms, MAGIC_TYPE_LEDATE) ||
	    ml->type == magic_reverse_type(ms, MAGIC_TYPE_LELDATE))
		value = le32toh(value);

	if (ml->type_operator == '&')
		value &= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint32_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint32_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint32_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		t = value;
		switch (ml->type) {
		case MAGIC_TYPE_LDATE:
		case MAGIC_TYPE_LELDATE:
		case MAGIC_TYPE_BELDATE:
			ctime_r(&t, s);
			break;
		default:
			asctime_r(gmtime(&t), s);
			break;
		}
		s[strcspn(s, "\n")] = '\0';
		magic_add_result(ms, ml, "%s", s);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_uqdate(struct magic_line *ml, struct magic_state *ms)
{
	uint64_t	value;
	int		result;
	time_t		t;
	char		s[64];

	if (magic_copy_from(ms, -1, &value, sizeof value) != 0)
		return (0);
	if (ml->type == MAGIC_TYPE_UBEQDATE ||
	    ml->type == MAGIC_TYPE_UBEQLDATE)
		value = be64toh(value);
	if (ml->type == MAGIC_TYPE_ULEQDATE ||
	    ml->type == MAGIC_TYPE_ULEQLDATE)
		value = le64toh(value);

	if (ml->type_operator == '&')
		value &= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '-')
		value -= (uint64_t)ml->type_operand;
	else if (ml->type_operator == '+')
		value += (uint64_t)ml->type_operand;
	else if (ml->type_operator != ' ')
		return (-1);

	result = magic_test_unsigned(ml, value, (uint64_t)ml->test_unsigned);
	if (result == !ml->test_not && ml->result != NULL) {
		t = value;
		switch (ml->type) {
		case MAGIC_TYPE_UQLDATE:
		case MAGIC_TYPE_ULEQLDATE:
		case MAGIC_TYPE_UBEQLDATE:
			ctime_r(&t, s);
			break;
		default:
			asctime_r(gmtime(&t), s);
			break;
		}
		s[strcspn(s, "\n")] = '\0';
		magic_add_result(ms, ml, "%s", s);
		ms->offset += sizeof value;
	}
	return (result);
}

static int
magic_test_type_bestring16(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-2);
}

static int
magic_test_type_lestring16(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-2);
}

static int
magic_test_type_melong(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-2);
}

static int
magic_test_type_medate(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-2);
}

static int
magic_test_type_meldate(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-2);
}

static int
magic_test_type_regex(struct magic_line *ml, struct magic_state *ms)
{
	const char	*cp;
	regex_t		 re;
	regmatch_t	 m;
	int		 result, flags = 0, sflag = 0;

	cp = &ml->type_string[(sizeof "regex") - 1];
	if (*cp != '\0') {
		if (*cp != '/')
			return (-1);
		cp++;
		for (; *cp != '\0'; cp++) {
			switch (*cp) {
			case 's':
				sflag = 1;
				break;
			case 'c':
				flags |= REG_ICASE;
				break;
			default:
				return (-1);
			}
		}
	}

	if (regcomp(&re, ml->test_string, REG_EXTENDED) != 0)
		return (-1);
	m.rm_so = ms->offset;
	m.rm_eo = ms->size;

	result = (regexec(&re, ms->base, 1, &m, REG_STARTEND) == 0);
	if (result == !ml->test_not) {
		if (ml->result != NULL) {
			magic_add_string(ms, ml, ms->base + m.rm_so,
			    m.rm_eo - m.rm_so);
		}
		if (result) {
			if (sflag)
				ms->offset = m.rm_so;
			else
				ms->offset = m.rm_eo;
		}
	}
	regfree(&re);
	return (result);
}

static int
magic_test_type_search(struct magic_line *ml, struct magic_state *ms)
{
	const char	*cp, *endptr, *start, *found;
	size_t		 size, end, i;
	uint64_t	 range;
	int		 result, n, cflag = 0, bflag = 0, Bflag = 0;

	cp = &ml->type_string[(sizeof "search") - 1];
	if (*cp != '\0') {
		if (*cp != '/')
			return (-1);
		cp++;

		endptr = magic_strtoull(cp, &range);
		if (endptr == NULL || (*endptr != '/' && *endptr != '\0'))
			return (-1);

		if (*endptr == '/') {
			for (cp = endptr + 1; *cp != '\0'; cp++) {
				switch (*cp) {
				case 'B':
				case 'W':
					Bflag = 1;
					break;
				case 'b':
				case 'w':
					bflag = 1;
					break;
				case 'c':
					cflag = 1;
					break;
				case 't':
					break;
				default:
					return (-1);
				}
			}
		}
	} else
		range = UINT64_MAX;
	if (range > (uint64_t)ms->size - ms->offset)
		range = ms->size - ms->offset;
	size = ml->test_string_size;

	/* Want to search every starting position from up to range + size. */
	end = range + size;
	if (end > ms->size - ms->offset) {
		if (size > ms->size - ms->offset)
			end = 0;
		else
			end = ms->size - ms->offset - size;
	}

	/*
	 * < and > and the flags are only in /etc/magic with search/1 so don't
	 * support them with anything else.
	 */
	start = ms->base + ms->offset;
	if (end == 0)
		found = NULL;
	else if (ml->test_operator == 'x')
		found = start;
	else if (range == 1) {
		n = magic_test_eq(start, ms->size - ms->offset, ml->test_string,
		    size, cflag, bflag, Bflag);
		if (n == -1 && ml->test_operator == '<')
			found = start;
		else if (n == 1 && ml->test_operator == '>')
			found = start;
		else if (n == 0 && ml->test_operator == '=')
			found = start;
		else
			found = NULL;
	} else {
		if (ml->test_operator != '=')
			return (-2);
		for (i = 0; i < end; i++) {
			n = magic_test_eq(start + i, ms->size - ms->offset - i,
			    ml->test_string, size, cflag, bflag, Bflag);
			if (n == 0) {
				found = start + i;
				break;
			}
		}
		if (i == end)
			found = NULL;
	}
	result = (found != NULL);

	if (result == !ml->test_not) {
		if (ml->result != NULL)
			magic_add_string(ms, ml, found, ms->size - ms->offset);
		if (result && found != NULL && ml->test_operator == '=')
			ms->offset = (found + size) - ms->base;
	}
	return (result);
}

static int
magic_test_type_default(struct magic_line *ml, struct magic_state *ms)
{
	if (!ms->matched && ml->result != NULL)
		magic_add_result(ms, ml, "%s", "");
	return (!ms->matched);
}

static int
magic_test_type_clear(struct magic_line *ml, struct magic_state *ms)
{
	if (ml->result != NULL)
		magic_add_result(ms, ml, "%s", "");
	return (1);
}

static int
magic_test_type_name(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (-1);
}

static int
magic_test_type_use(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
{
	return (1);
}

static int (*magic_test_functions[])(struct magic_line *,
    struct magic_state *) = {
	magic_test_type_none,
	magic_test_type_byte,
	magic_test_type_short,
	magic_test_type_long,
	magic_test_type_quad,
	magic_test_type_ubyte,
	magic_test_type_ushort,
	magic_test_type_ulong,
	magic_test_type_uquad,
	magic_test_type_float,
	magic_test_type_double,
	magic_test_type_string,
	magic_test_type_pstring,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_udate,
	magic_test_type_uqdate,
	magic_test_type_udate,
	magic_test_type_qdate,
	magic_test_type_short,
	magic_test_type_long,
	magic_test_type_quad,
	magic_test_type_ushort,
	magic_test_type_ulong,
	magic_test_type_uquad,
	magic_test_type_float,
	magic_test_type_double,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_udate,
	magic_test_type_uqdate,
	magic_test_type_udate,
	magic_test_type_uqdate,
	magic_test_type_bestring16,
	magic_test_type_short,
	magic_test_type_long,
	magic_test_type_quad,
	magic_test_type_ushort,
	magic_test_type_ulong,
	magic_test_type_uquad,
	magic_test_type_float,
	magic_test_type_double,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_date,
	magic_test_type_qdate,
	magic_test_type_udate,
	magic_test_type_uqdate,
	magic_test_type_udate,
	magic_test_type_uqdate,
	magic_test_type_lestring16,
	magic_test_type_melong,
	magic_test_type_medate,
	magic_test_type_meldate,
	magic_test_type_regex,
	magic_test_type_search,
	magic_test_type_default,
	magic_test_type_clear,
	magic_test_type_name,
	magic_test_type_use,
};

static void
magic_test_children(struct magic_line *ml, struct magic_state *ms, size_t start,
    int reverse)
{
	struct magic_line	*child;
	size_t			 saved_start, saved_offset;
	int			 saved_reverse;

	saved_start = ms->start;
	saved_reverse = ms->reverse;
	saved_offset = ms->offset;

	ms->matched = 0; /* no need to save, caller will set too */

	TAILQ_FOREACH(child, &ml->children, entry) {
		ms->start = start;
		ms->reverse = reverse;
		ms->offset = saved_offset;

		magic_test_line(child, ms);
	}

	ms->start = saved_start;
	ms->reverse = saved_reverse;
	ms->offset = saved_offset;
}

static int
magic_test_line(struct magic_line *ml, struct magic_state *ms)
{
	struct magic		*m = ml->root;
	struct magic_line	*named;
	int64_t			 offset, wanted, next;
	int			 result;
	uint8_t			 b;
	uint16_t		 s;
	uint32_t		 l;

	if (ml->indirect_type == ' ')
		wanted = ms->start + ml->offset;
	else {
		wanted = ml->indirect_offset;
		if (ml->indirect_relative) {
			if (wanted < 0 && (size_t)-wanted > ms->offset)
				return (0);
			if (wanted > 0 && ms->offset + wanted > ms->size)
				return (0);
			next = ms->offset + ml->indirect_offset;
		} else
			next = wanted;

		switch (ml->indirect_type) {
		case 'b':
		case 'B':
			if (magic_copy_from(ms, next, &b, sizeof b) != 0)
				return (0);
			wanted = b;
			break;
		case 's':
			if (magic_copy_from(ms, next, &s, sizeof s) != 0)
				return (0);
			wanted = le16toh(s);
			break;
		case 'S':
			if (magic_copy_from(ms, next, &s, sizeof s) != 0)
				return (0);
			wanted = be16toh(s);
			break;
		case 'l':
			if (magic_copy_from(ms, next, &l, sizeof l) != 0)
				return (0);
			wanted = le16toh(l);
			break;
		case 'L':
			if (magic_copy_from(ms, next, &l, sizeof l) != 0)
				return (0);
			wanted = be16toh(l);
			break;
		}

		switch (ml->indirect_operator) {
		case '+':
			wanted += ml->indirect_operand;
			break;
		case '-':
			wanted -= ml->indirect_operand;
			break;
		case '*':
			wanted *= ml->indirect_operand;
			break;
		}
	}

	if (ml->offset_relative) {
		if (wanted < 0 && (size_t)-wanted > ms->offset)
			return (0);
		if (wanted > 0 && ms->offset + wanted > ms->size)
			return (0);
		offset = ms->offset + wanted;
	} else
		offset = wanted;
	if (offset < 0 || (size_t)offset > ms->size)
		return (0);
	ms->offset = offset; /* test function may update */

	result = magic_test_functions[ml->type](ml, ms);
	if (result == -1) {
		magic_warn(ml, "test %s/%c failed", ml->type_string,
		    ml->test_operator);
		return (0);
	}
	if (result == -2) {
		magic_warn(ml, "test %s/%c not implemented", ml->type_string,
		    ml->test_operator);
		return (0);
	}
	if (result == ml->test_not)
		return (0);
	if (ml->mimetype != NULL)
		ms->mimetype = ml->mimetype;

	magic_warn(ml, "test %s/%c matched at offset %lld (now %zu): "
	    "'%s'", ml->type_string, ml->test_operator, offset,
	    ms->offset, ml->result == NULL ? "" : ml->result);

	if (ml->type == MAGIC_TYPE_USE) {
		if (*ml->name == '^')
			named = magic_get_named(m, ml->name + 1);
		else
			named = magic_get_named(m, ml->name);
		if (named == NULL) {
			magic_warn(ml, "no name found for use %s", ml->name);
			return (0);
		}
		magic_warn(ml, "use %s at offset %lld", ml->name, offset);
		magic_test_children(named, ms, offset, *ml->name == '^');
	}

	magic_test_children(ml, ms, ms->start, ms->reverse);

	if (ml->type == MAGIC_TYPE_CLEAR)
		ms->matched = 0;
	else
		ms->matched = 1;
	return (ml->result != NULL);
}

const char *
magic_test(struct magic *m, const void *base, size_t size, int flags)
{
	struct magic_line		*ml;
	static struct magic_state	 ms;

	memset(&ms, 0, sizeof ms);

	ms.base = base;
	ms.size = size;

	ms.text = !!(flags & MAGIC_TEST_TEXT);

	RB_FOREACH(ml, magic_tree, &m->tree) {
		ms.offset = 0;
		if (ml->text == ms.text && magic_test_line(ml, &ms))
			break;
	}

	if (*ms.out != '\0') {
		if (flags & MAGIC_TEST_MIME) {
			if (ms.mimetype)
				return (xstrdup(ms.mimetype));
			return (NULL);
		}
		return (xstrdup(ms.out));
	}
	return (NULL);
}
@


1.23
log
@Use the right size (include the length byte) when working out if a
pstring is too big.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.22 2016/05/01 10:56:03 nicm Exp $ */
d30 1
@


1.22
log
@Add support for 'name' and 'use' which allows more of the latest magic
files to work unchanged. (We are still missing 'indirect' and a few
other bits.)
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.21 2016/05/01 08:53:26 nicm Exp $ */
d736 1
a736 1
	if (slen > ms->size - ms->offset)
@


1.21
log
@Remove __unused that are now lies.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.20 2016/05/01 08:48:39 nicm Exp $ */
d36 86
d353 1
a353 1
	if (ml->type == MAGIC_TYPE_BESHORT)
d355 1
a355 1
	if (ml->type == MAGIC_TYPE_LESHORT)
d389 1
a389 1
	if (ml->type == MAGIC_TYPE_BELONG)
d391 1
a391 1
	if (ml->type == MAGIC_TYPE_LELONG)
d425 1
a425 1
	if (ml->type == MAGIC_TYPE_BEQUAD)
d427 1
a427 1
	if (ml->type == MAGIC_TYPE_LEQUAD)
d602 1
a602 1
	if (ml->type == MAGIC_TYPE_BEFLOAT)
d604 1
a604 1
	if (ml->type == MAGIC_TYPE_LEFLOAT)
d628 1
a628 1
	if (ml->type == MAGIC_TYPE_BEDOUBLE)
d630 1
a630 1
	if (ml->type == MAGIC_TYPE_LEDOUBLE)
d782 2
a783 2
	if (ml->type == MAGIC_TYPE_BEDATE ||
	    ml->type == MAGIC_TYPE_BELDATE)
d785 2
a786 2
	if (ml->type == MAGIC_TYPE_LEDATE ||
	    ml->type == MAGIC_TYPE_LELDATE)
d828 2
a829 2
	if (ml->type == MAGIC_TYPE_BEQDATE ||
	    ml->type == MAGIC_TYPE_BEQLDATE)
d831 2
a832 2
	if (ml->type == MAGIC_TYPE_LEQDATE ||
	    ml->type == MAGIC_TYPE_LEQLDATE)
d874 2
a875 2
	if (ml->type == MAGIC_TYPE_BEDATE ||
	    ml->type == MAGIC_TYPE_BELDATE)
d877 2
a878 2
	if (ml->type == MAGIC_TYPE_LEDATE ||
	    ml->type == MAGIC_TYPE_LELDATE)
d1155 14
d1233 2
d1237 27
d1267 2
a1268 1
	struct magic_line	*child;
d1276 1
a1276 1
		wanted = ml->offset;
d1340 1
a1340 1
	ms->offset = offset;
d1358 16
a1373 3
	magic_warn(ml, "test %s/%c matched at offset %lld (now %zu): '%s'",
	    ml->type_string, ml->test_operator, offset, ms->offset,
	    ml->result == NULL ? "" : ml->result);
d1375 1
a1375 6
	ms->matched = 0;
	offset = ms->offset;
	TAILQ_FOREACH(child, &ml->children, entry) {
		ms->offset = offset;
		magic_test_line(child, ms);
	}
@


1.20
log
@Add support for 'clear' test, and fix 'default' to expand the result
string if any (used by, for example, rtf).
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.19 2016/04/30 22:03:30 nicm Exp $ */
d1054 1
a1054 1
magic_test_type_default(__unused struct magic_line *ml, struct magic_state *ms)
d1062 1
a1062 2
magic_test_type_clear(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
@


1.19
log
@magic_test_type_default parameter is no longer __unused.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.18 2016/04/30 21:42:11 nicm Exp $ */
d1056 2
d1061 9
d1133 1
d1240 4
a1243 1
	ms->matched = 1;
@


1.18
log
@Fix the default type to work properly, that is to only match if no
previous test at the same level has matched.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.17 2016/04/30 21:10:28 nicm Exp $ */
d1054 1
a1054 2
magic_test_type_default(__unused struct magic_line *ml,
    __unused struct magic_state *ms)
@


1.17
log
@Replace regex match string in results (some new magic entries use this).
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.16 2016/02/20 15:29:37 nicm Exp $ */
d1057 1
a1057 1
	return (1);
d1222 1
d1228 2
@


1.16
log
@Fix the C type used for 32-bit float/lefloat/befloat, it should be float
not double (they are not used in any magic files anyway at the moment
though). Spotted by and ok jsg.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.15 2015/10/06 08:20:10 nicm Exp $ */
d939 4
a942 2
		if (ml->result != NULL)
			magic_add_result(ms, ml, "%s", "");
@


1.15
log
@Log the matched offset (and the new offset) instead of just of the new
offset (as if it was where the match was found).
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.14 2015/10/05 19:50:38 nicm Exp $ */
d511 1
a511 1
	double		value;
@


1.14
log
@Offset into the file can be size_t and add some casts to remove warnings.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.13 2015/08/12 09:39:43 nicm Exp $ */
d1216 2
a1217 2
	magic_warn(ml, "test %s/%c matched at offset %zu: '%s'",
	    ml->type_string, ml->test_operator, ms->offset,
@


1.13
log
@Support + and - for dates.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.12 2015/08/12 09:29:49 nicm Exp $ */
d1138 1
a1138 1
			if (wanted < 0 && -wanted > ms->offset)
d1189 1
a1189 1
		if (wanted < 0 && -wanted > ms->offset)
d1196 1
a1196 1
	if (offset < 0 || offset > ms->size)
d1216 1
a1216 1
	magic_warn(ml, "test %s/%c matched at offset %llu: '%s'",
@


1.12
log
@Fix adjustment of the offset when string, pstring or search match.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.11 2015/08/12 07:43:27 nicm Exp $ */
d705 4
d751 4
d797 4
d843 4
@


1.11
log
@Add string/Ww as aliases for string/Bb, and ignore t. (The latest
version of the original file replaced Bb with Ww and then reused b for
something else (!), but alias them instead.)
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.10 2015/08/11 23:03:26 nicm Exp $ */
d680 1
a680 1
		if (result)
d922 3
a924 2
	if (result == !ml->test_not && ml->result != NULL) {
		magic_add_result(ms, ml, "%s", "");
d1026 5
a1030 3
	if (result == !ml->test_not && ml->result != NULL && found != NULL) {
		magic_add_string(ms, ml, found, ms->size - ms->offset);
		ms->offset = found - start + size;
@


1.10
log
@When an exact string match is found, only print the test string, not up
to \0. Noticed by Theo with some GIF files.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.9 2015/08/11 22:48:09 nicm Exp $ */
d574 1
d578 1
d584 2
d957 1
d961 1
d966 2
@


1.9
log
@Any type can be prefixed with "u", even where it makes no sense. Also
make pstring/upstring a text type.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.8 2015/08/11 22:18:43 nicm Exp $ */
d606 1
@


1.8
log
@Extend accepted operators to +-&/%* for integer tests.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.7 2015/08/11 22:12:48 nicm Exp $ */
d624 1
a624 1
	const char	*s;
d627 13
@


1.7
log
@Support = test for floats and doubles.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.6 2015/05/29 15:58:01 nicm Exp $ */
d238 10
d274 10
d310 10
d346 10
d378 10
d414 10
d450 10
d486 10
@


1.6
log
@Use gmtime not localtime when we want UTC, I got it right in one place
but not in another two. I expect I was confused by the fact that the
original file(1) had them the wrong way round (so, for example, leqldate
was actually UTC).
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.5 2015/05/29 15:11:08 nicm Exp $ */
d209 12
d432 1
d445 5
a449 5
	if (ml->test_operator != 'x')
		return (-1);

	magic_add_result(ms, ml, "%g", value);
	ms->offset += sizeof value0;
d458 1
d471 5
a475 5
	if (ml->test_operator != 'x')
		return (-1);

	magic_add_result(ms, ml, "%g", value);
	ms->offset += sizeof value0;
@


1.5
log
@Don't stop at the first successful test unless it has generated some
output.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.4 2015/05/29 14:52:10 nicm Exp $ */
d606 1
a606 1
			asctime_r(localtime(&t), s);
d648 1
a648 1
			asctime_r(localtime(&t), s);
@


1.4
log
@The case-insensitive flag (c) for string and search tests doesn't make
the entire match case sensitive, only lower case characters.
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.3 2015/04/25 16:35:47 brynet Exp $ */
d1090 1
a1090 1
	return (1);
@


1.3
log
@Switch to using the POSIX endian macros, i.e: be64toh vs. betoh64.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.2 2015/04/24 17:19:06 deraadt Exp $ */
d41 1
a41 1
	if (cflag && tolower((u_char)a) == tolower((u_char)b))
@


1.2
log
@move an ugly space
@
text
@d1 1
a1 1
/* $OpenBSD: magic-test.c,v 1.1 2015/04/24 16:24:11 nicm Exp $ */
d246 1
a246 1
		value = betoh16(value);
d248 1
a248 1
		value = letoh16(value);
d272 1
a272 1
		value = betoh32(value);
d274 1
a274 1
		value = letoh32(value);
d298 1
a298 1
		value = betoh64(value);
d300 1
a300 1
		value = letoh64(value);
d346 1
a346 1
		value = betoh16(value);
d348 1
a348 1
		value = letoh16(value);
d372 1
a372 1
		value = betoh32(value);
d374 1
a374 1
		value = letoh32(value);
d398 1
a398 1
		value = betoh64(value);
d400 1
a400 1
		value = letoh64(value);
d424 1
a424 1
		value0 = betoh32(value0);
d426 1
a426 1
		value0 = letoh32(value0);
d449 1
a449 1
		value0 = betoh64(value0);
d451 1
a451 1
		value0 = letoh64(value0);
d586 1
a586 1
		value = betoh32(value);
d589 1
a589 1
		value = letoh32(value);
d628 1
a628 1
		value = betoh64(value);
d631 1
a631 1
		value = letoh64(value);
d670 1
a670 1
		value = betoh32(value);
d673 1
a673 1
		value = letoh32(value);
d712 1
a712 1
		value = betoh64(value);
d715 1
a715 1
		value = letoh64(value);
d1021 1
a1021 1
			wanted = letoh16(s);
d1026 1
a1026 1
			wanted = betoh16(s);
d1031 1
a1031 1
			wanted = letoh16(l);
d1036 1
a1036 1
			wanted = betoh16(l);
@


1.1
log
@New implementation of the file(1) utility. This is a simplified,
modernised version with a nearly complete magic(5) parser but omits some
of the complex builtin tests (notably ELF) and has a reduced set of
options.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d140 1
a140 1
    const char* s, size_t slen)
@

