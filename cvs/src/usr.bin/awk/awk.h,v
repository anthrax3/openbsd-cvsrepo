head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.32
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.28
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.30
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.22
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.26
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.14
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.12
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.10
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.8
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.8
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.6
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.4
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2008.10.06.20.38.33;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.04.14.04.42;	author pyr;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.12.08.23.09.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.12.04.00.12.25;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.04.20.17.31.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.25.16.17.09;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.15.59.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.04.06.06.31.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.20.19.43.19;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update awk to version 20071023; OK deraadt@@
@
text
@/*	$OpenBSD: awk.h,v 1.12 2008/06/04 14:04:42 pyr Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#include <assert.h>

typedef double	Awkfloat;

/* unsigned char is more trouble than it's worth */

typedef	unsigned char uschar;

#define	xfree(a)	{ if ((a) != NULL) { free((void *) (a)); (a) = NULL; } }

#define	NN(p)	((p) ? (p) : "(null)")	/* guaranteed non-null for dprintf 
*/
#define	DEBUG
#ifdef	DEBUG
			/* uses have to be doubly parenthesized */
#	define	dprintf(x)	if (dbg) printf x
#else
#	define	dprintf(x)
#endif

extern int	compile_time;	/* 1 if compiling, 0 if running */
extern int	safe;		/* 0 => unsafe, 1 => safe */

#define	RECSIZE	(8 * 1024)	/* sets limit on records, fields, etc., etc. */
extern int	recsize;	/* size of current record, orig RECSIZE */

extern char	**FS;
extern char	**RS;
extern char	**ORS;
extern char	**OFS;
extern char	**OFMT;
extern Awkfloat *NR;
extern Awkfloat *FNR;
extern Awkfloat *NF;
extern char	**FILENAME;
extern char	**SUBSEP;
extern Awkfloat *RSTART;
extern Awkfloat *RLENGTH;

extern char	*record;	/* points to $0 */
extern int	lineno;		/* line number in awk program */
extern int	errorflag;	/* 1 if error has occurred */
extern int	donefld;	/* 1 if record broken into fields */
extern int	donerec;	/* 1 if record is valid (no fld has changed */
extern char	inputFS[];	/* FS at time of input, for field splitting */

extern int	dbg;

extern	char	*patbeg;	/* beginning of pattern matched */
extern	int	patlen;		/* length of pattern matched.  set in b.c */

/* Cell:  all information about a variable or constant */

typedef struct Cell {
	uschar	ctype;		/* OCELL, OBOOL, OJUMP, etc. */
	uschar	csub;		/* CCON, CTEMP, CFLD, etc. */
	char	*nval;		/* name, for variables only */
	char	*sval;		/* string value */
	Awkfloat fval;		/* value as number */
	int	 tval;		/* type info: STR|NUM|ARR|FCN|FLD|CON|DONTFREE */
	struct Cell *cnext;	/* ptr to next if chained */
} Cell;

typedef struct Array {		/* symbol table array */
	int	nelem;		/* elements in table right now */
	int	size;		/* size of tab */
	Cell	**tab;		/* hash table pointers */
} Array;

#define	NSYMTAB	50	/* initial size of a symbol table */
extern Array	*symtab;

extern Cell	*nrloc;		/* NR */
extern Cell	*fnrloc;	/* FNR */
extern Cell	*nfloc;		/* NF */
extern Cell	*rstartloc;	/* RSTART */
extern Cell	*rlengthloc;	/* RLENGTH */

/* Cell.tval values: */
#define	NUM	01	/* number value is valid */
#define	STR	02	/* string value is valid */
#define DONTFREE 04	/* string space is not freeable */
#define	CON	010	/* this is a constant */
#define	ARR	020	/* this is an array */
#define	FCN	040	/* this is a function name */
#define FLD	0100	/* this is a field $1, $2, ... */
#define	REC	0200	/* this is $0 */


/* function types */
#define	FLENGTH	1
#define	FSQRT	2
#define	FEXP	3
#define	FLOG	4
#define	FINT	5
#define	FSYSTEM	6
#define	FRAND	7
#define	FSRAND	8
#define	FSIN	9
#define	FCOS	10
#define	FATAN	11
#define	FTOUPPER 12
#define	FTOLOWER 13
#define	FFLUSH	14
#define FAND	15
#define FFOR	16
#define FXOR	17
#define FCOMPL	18
#define FLSHIFT	19
#define FRSHIFT	20

/* Node:  parse tree is made of nodes, with Cell's at bottom */

typedef struct Node {
	int	ntype;
	struct	Node *nnext;
	int	lineno;
	int	nobj;
	struct	Node *narg[1];	/* variable: actual size set by calling malloc */
} Node;

#define	NIL	((Node *) 0)

extern Node	*winner;
extern Node	*nullstat;
extern Node	*nullnode;

/* ctypes */
#define OCELL	1
#define OBOOL	2
#define OJUMP	3

/* Cell subtypes: csub */
#define	CFREE	7
#define CCOPY	6
#define CCON	5
#define CTEMP	4
#define CNAME	3 
#define CVAR	2
#define CFLD	1
#define	CUNK	0

/* bool subtypes */
#define BTRUE	11
#define BFALSE	12

/* jump subtypes */
#define JEXIT	21
#define JNEXT	22
#define	JBREAK	23
#define	JCONT	24
#define	JRET	25
#define	JNEXTFILE	26

/* node types */
#define NVALUE	1
#define NSTAT	2
#define NEXPR	3


extern	int	pairstack[], paircnt;

#define notlegal(n)	(n <= FIRSTTOKEN || n >= LASTTOKEN || proctab[n-FIRSTTOKEN] == nullproc)
#define isvalue(n)	((n)->ntype == NVALUE)
#define isexpr(n)	((n)->ntype == NEXPR)
#define isjump(n)	((n)->ctype == OJUMP)
#define isexit(n)	((n)->csub == JEXIT)
#define	isbreak(n)	((n)->csub == JBREAK)
#define	iscont(n)	((n)->csub == JCONT)
#define	isnext(n)	((n)->csub == JNEXT || (n)->csub == JNEXTFILE)
#define	isret(n)	((n)->csub == JRET)
#define isrec(n)	((n)->tval & REC)
#define isfld(n)	((n)->tval & FLD)
#define isstr(n)	((n)->tval & STR)
#define isnum(n)	((n)->tval & NUM)
#define isarr(n)	((n)->tval & ARR)
#define isfcn(n)	((n)->tval & FCN)
#define istrue(n)	((n)->csub == BTRUE)
#define istemp(n)	((n)->csub == CTEMP)
#define	isargument(n)	((n)->nobj == ARG)
/* #define freeable(p)	(!((p)->tval & DONTFREE)) */
#define freeable(p)	( ((p)->tval & (STR|DONTFREE)) == STR )

/* structures used by regular expression matching machinery, mostly b.c: */

#define NCHARS	(256+3)		/* 256 handles 8-bit chars; 128 does 7-bit */
				/* watch out in match(), etc. */
#define NSTATES	32

typedef struct rrow {
	long	ltype;	/* long avoids pointer warnings on 64-bit */
	union {
		int i;
		Node *np;
		uschar *up;
	} lval;		/* because Al stores a pointer in it! */
	int	*lfollow;
} rrow;

typedef struct fa {
	uschar	gototab[NSTATES][NCHARS];
	uschar	out[NSTATES];
	uschar	*restr;
	int	*posns[NSTATES];
	int	anchor;
	int	use;
	int	initstat;
	int	curstat;
	int	accept;
	int	reset;
	struct	rrow re[1];	/* variable: actual size set by calling malloc */
} fa;


#include "proto.h"
@


1.12
log
@Extend awk with bitwise operations. This is an extension to the awk
spec and documented as such, but comes in handy from time to time.
The prototypes make it compatible with a similar GNU awk extension.

ok millert@@, enthusiasm from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.11 2004/12/30 01:52:48 millert Exp $	*/
d34 1
a34 1
#define	xfree(a)	{ if ((a) != NULL) { free((char *) a); a = NULL; } }
@


1.11
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.10 2002/12/19 21:24:28 millert Exp $	*/
d130 6
@


1.10
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.9 2001/09/08 00:12:40 millert Exp $	*/
d26 2
d205 1
a205 1
#define NCHARS	(256+1)		/* 256 handles 8-bit chars; 128 does 7-bit */
@


1.9
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.8 1999/12/08 23:09:45 millert Exp $	*/
d34 2
@


1.8
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.7 1999/12/04 00:12:25 millert Exp $	*/
d185 1
a185 2
#define	isnext(n)	((n)->csub == JNEXT)
#define	isnextfile(n)	((n)->csub == JNEXTFILE)
d210 1
a210 1
		char *up;
d218 1
a218 1
	char	*restr;
@


1.7
log
@Fix 2 core dumps:
1) give an error if the user specifies > 20 -f options instead of oflowing
2) use snprintf in the ERROR macro to avoid an oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.6 1999/04/20 17:31:28 millert Exp $	*/
a40 6

extern	char	errbuf[300];
#define	ERROR	snprintf(errbuf, sizeof(errbuf),
#define	FATAL	), error(1, errbuf)
#define	WARNING	), error(0, errbuf)
#define	SYNTAX	), yyerror(errbuf)
@


1.6
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: awk.h,v 1.5 1997/08/25 16:17:09 kstailey Exp $	*/
d42 2
a43 2
extern	char	errbuf[];
#define	ERROR	sprintf(errbuf,
@


1.5
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 1
	unsigned tval;		/* type info: STR|NUM|ARR|FCN|FLD|CON|DONTFREE */
d140 1
a140 1
	struct Node *narg[1];	/* variable: actual size set by calling malloc */
d213 1
a213 1
	int	ltype;
d223 2
d226 1
a228 3
	uschar	gototab[NSTATES][NCHARS];
	int	*posns[NSTATES];
	uschar	out[NSTATES];
d233 1
a233 1
	struct	rrow re[1];
@


1.4
log
@Back out last changes for now.  They cause problems.
@
text
@d1 1
d3 1
a3 1
Copyright (C) AT&T and Lucent Technologies 1996
d11 13
a23 13
documentation, and that the names of AT&T or Lucent Technologies
or any of their entities not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

AT&T AND LUCENT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL AT&T OR LUCENT OR ANY OF THEIR
ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
d42 1
a42 1
extern	char	errbuf[200];
d49 1
d51 2
a52 2
#define	RECSIZE	(3 * 1024)	/* sets limit on records, fields, etc., etc. */
extern int	recsize;	/* variable version */
a75 14
typedef struct {
	char	*cbuf;
	int	clen;
	int	cmax;
} Gstring;		/* a string that grows */

extern Gstring	*newGstring(void);		/* constructor */
extern void	delGstring(Gstring *);		/* destructor */
extern char	*cadd(Gstring *gs, int c);	/* function to grow with */
extern void	caddreset(Gstring *gs);		/* set cbuf empty */
extern void	cunadd(Gstring *gs);		/* back up one char in cbuf */

extern Gstring	*gs;	/* used by lex */

d91 1
a91 1
typedef struct {		/* symbol table array */
a99 1
extern Cell	*recloc;	/* location of input record */
a179 1
#define	NFIELD	4
d194 2
d199 1
a199 1
#define isfunc(n)	((n)->tval & FCN)
d203 2
a204 1
#define freeable(p)	(!((p)->tval & DONTFREE))
@


1.3
log
@Use long, not int when casting pointers and storing as integers.
Now compiles on alpha w/o warnings.
@
text
@d196 1
a196 1
extern	long	pairstack[], paircnt;
d224 1
a224 1
	long	ltype;
d230 1
a230 1
	long	*lfollow;
d238 1
a238 1
	long	*posns[NSTATES];
@


1.2
log
@Latest research awk from June 29, 1996
@
text
@d196 1
a196 1
extern	int	pairstack[], paircnt;
d224 1
a224 1
	int	ltype;
d230 1
a230 1
	int	*lfollow;
d238 1
a238 1
	int	*posns[NSTATES];
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d70 1
@
