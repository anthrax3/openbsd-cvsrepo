head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.24
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.20
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.16
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.18
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.10
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.14
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.12
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.20
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.18
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.16
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.12
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.14
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.10
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.8
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.6
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.4
	OPENBSD_3_1_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2011.09.28.19.27.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.04.19.10.15;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.15.15.54.26;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.30.02.06.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.06.06.12.01;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.12.08.23.09.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.04.20.17.31.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.18.17.06.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.08.25.16.17.14;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.20.19.43.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.49;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update awk to Aug 10, 2011 version; naddy@@ reports no ports problems
from the update.
@
text
@/*	$OpenBSD: tran.c,v 1.14 2006/11/04 19:10:15 jmc Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define	DEBUG
#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "awk.h"
#include "ytab.h"

#define	FULLTAB	2	/* rehash when table gets this x full */
#define	GROWTAB 4	/* grow table by this factor */

Array	*symtab;	/* main symbol table */

char	**FS;		/* initial field sep */
char	**RS;		/* initial record sep */
char	**OFS;		/* output field sep */
char	**ORS;		/* output record sep */
char	**OFMT;		/* output format for numbers */
char	**CONVFMT;	/* format for conversions in getsval */
Awkfloat *NF;		/* number of fields in current record */
Awkfloat *NR;		/* number of current record */
Awkfloat *FNR;		/* number of current record in current file */
char	**FILENAME;	/* current filename argument */
Awkfloat *ARGC;		/* number of arguments from command line */
char	**SUBSEP;	/* subscript separator for a[i,j,k]; default \034 */
Awkfloat *RSTART;	/* start of re matched with ~; origin 1 (!) */
Awkfloat *RLENGTH;	/* length of same */

Cell	*fsloc;		/* FS */
Cell	*nrloc;		/* NR */
Cell	*nfloc;		/* NF */
Cell	*fnrloc;	/* FNR */
Array	*ARGVtab;	/* symbol table containing ARGV[...] */
Array	*ENVtab;	/* symbol table containing ENVIRON[...] */
Cell	*rstartloc;	/* RSTART */
Cell	*rlengthloc;	/* RLENGTH */
Cell	*symtabloc;	/* SYMTAB */

Cell	*nullloc;	/* a guaranteed empty cell */
Node	*nullnode;	/* zero&null, converted into a node for comparisons */
Cell	*literal0;

extern Cell **fldtab;

void syminit(void)	/* initialize symbol table with builtin vars */
{
	literal0 = setsymtab("0", "0", 0.0, NUM|STR|CON|DONTFREE, symtab);
	/* this is used for if(x)... tests: */
	nullloc = setsymtab("$zero&null", "", 0.0, NUM|STR|CON|DONTFREE, symtab);
	nullnode = celltonode(nullloc, CCON);

	fsloc = setsymtab("FS", " ", 0.0, STR|DONTFREE, symtab);
	FS = &fsloc->sval;
	RS = &setsymtab("RS", "\n", 0.0, STR|DONTFREE, symtab)->sval;
	OFS = &setsymtab("OFS", " ", 0.0, STR|DONTFREE, symtab)->sval;
	ORS = &setsymtab("ORS", "\n", 0.0, STR|DONTFREE, symtab)->sval;
	OFMT = &setsymtab("OFMT", "%.6g", 0.0, STR|DONTFREE, symtab)->sval;
	CONVFMT = &setsymtab("CONVFMT", "%.6g", 0.0, STR|DONTFREE, symtab)->sval;
	FILENAME = &setsymtab("FILENAME", "", 0.0, STR|DONTFREE, symtab)->sval;
	nfloc = setsymtab("NF", "", 0.0, NUM, symtab);
	NF = &nfloc->fval;
	nrloc = setsymtab("NR", "", 0.0, NUM, symtab);
	NR = &nrloc->fval;
	fnrloc = setsymtab("FNR", "", 0.0, NUM, symtab);
	FNR = &fnrloc->fval;
	SUBSEP = &setsymtab("SUBSEP", "\034", 0.0, STR|DONTFREE, symtab)->sval;
	rstartloc = setsymtab("RSTART", "", 0.0, NUM, symtab);
	RSTART = &rstartloc->fval;
	rlengthloc = setsymtab("RLENGTH", "", 0.0, NUM, symtab);
	RLENGTH = &rlengthloc->fval;
	symtabloc = setsymtab("SYMTAB", "", 0.0, ARR, symtab);
	symtabloc->sval = (char *) symtab;
}

void arginit(int ac, char **av)	/* set up ARGV and ARGC */
{
	Cell *cp;
	int i;
	char temp[50];

	ARGC = &setsymtab("ARGC", "", (Awkfloat) ac, NUM, symtab)->fval;
	cp = setsymtab("ARGV", "", 0.0, ARR, symtab);
	ARGVtab = makesymtab(NSYMTAB);	/* could be (int) ARGC as well */
	cp->sval = (char *) ARGVtab;
	for (i = 0; i < ac; i++) {
		snprintf(temp, sizeof temp, "%d", i);
		if (is_number(*av))
			setsymtab(temp, *av, atof(*av), STR|NUM, ARGVtab);
		else
			setsymtab(temp, *av, 0.0, STR, ARGVtab);
		av++;
	}
}

void envinit(char **envp)	/* set up ENVIRON variable */
{
	Cell *cp;
	char *p;

	cp = setsymtab("ENVIRON", "", 0.0, ARR, symtab);
	ENVtab = makesymtab(NSYMTAB);
	cp->sval = (char *) ENVtab;
	for ( ; *envp; envp++) {
		if ((p = strchr(*envp, '=')) == NULL)
			continue;
		if( p == *envp ) /* no left hand side name in env string */
			continue;
		*p++ = 0;	/* split into two strings at = */
		if (is_number(p))
			setsymtab(*envp, p, atof(p), STR|NUM, ENVtab);
		else
			setsymtab(*envp, p, 0.0, STR, ENVtab);
		p[-1] = '=';	/* restore in case env is passed down to a shell */
	}
}

Array *makesymtab(int n)	/* make a new symbol table */
{
	Array *ap;
	Cell **tp;

	ap = (Array *) malloc(sizeof(Array));
	tp = (Cell **) calloc(n, sizeof(Cell *));
	if (ap == NULL || tp == NULL)
		FATAL("out of space in makesymtab");
	ap->nelem = 0;
	ap->size = n;
	ap->tab = tp;
	return(ap);
}

void freesymtab(Cell *ap)	/* free a symbol table */
{
	Cell *cp, *temp;
	Array *tp;
	int i;

	if (!isarr(ap))
		return;
	tp = (Array *) ap->sval;
	if (tp == NULL)
		return;
	for (i = 0; i < tp->size; i++) {
		for (cp = tp->tab[i]; cp != NULL; cp = temp) {
			xfree(cp->nval);
			if (freeable(cp))
				xfree(cp->sval);
			temp = cp->cnext;	/* avoids freeing then using */
			free(cp); 
			tp->nelem--;
		}
		tp->tab[i] = 0;
	}
	if (tp->nelem != 0)
		WARNING("can't happen: inconsistent element count freeing %s", ap->nval);
	free(tp->tab);
	free(tp);
}

void freeelem(Cell *ap, const char *s)	/* free elem s from ap (i.e., ap["s"] */
{
	Array *tp;
	Cell *p, *prev = NULL;
	int h;
	
	tp = (Array *) ap->sval;
	h = hash(s, tp->size);
	for (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)
		if (strcmp(s, p->nval) == 0) {
			if (prev == NULL)	/* 1st one */
				tp->tab[h] = p->cnext;
			else			/* middle somewhere */
				prev->cnext = p->cnext;
			if (freeable(p))
				xfree(p->sval);
			free(p->nval);
			free(p);
			tp->nelem--;
			return;
		}
}

Cell *setsymtab(const char *n, const char *s, Awkfloat f, unsigned t, Array *tp)
{
	int h;
	Cell *p;

	if (n != NULL && (p = lookup(n, tp)) != NULL) {
		   dprintf( ("setsymtab found %p: n=%s s=\"%s\" f=%g t=%o\n",
			(void*)p, NN(p->nval), NN(p->sval), p->fval, p->tval) );
		return(p);
	}
	p = (Cell *) malloc(sizeof(Cell));
	if (p == NULL)
		FATAL("out of space for symbol table at %s", n);
	p->nval = tostring(n);
	p->sval = s ? tostring(s) : tostring("");
	p->fval = f;
	p->tval = t;
	p->csub = CUNK;
	p->ctype = OCELL;
	tp->nelem++;
	if (tp->nelem > FULLTAB * tp->size)
		rehash(tp);
	h = hash(n, tp->size);
	p->cnext = tp->tab[h];
	tp->tab[h] = p;
	   dprintf( ("setsymtab set %p: n=%s s=\"%s\" f=%g t=%o\n",
		(void*)p, p->nval, p->sval, p->fval, p->tval) );
	return(p);
}

int hash(const char *s, int n)	/* form hash value for string s */
{
	unsigned hashval;

	for (hashval = 0; *s != '\0'; s++)
		hashval = (*s + 31 * hashval);
	return hashval % n;
}

void rehash(Array *tp)	/* rehash items in small table into big one */
{
	int i, nh, nsz;
	Cell *cp, *op, **np;

	nsz = GROWTAB * tp->size;
	np = (Cell **) calloc(nsz, sizeof(Cell *));
	if (np == NULL)		/* can't do it, but can keep running. */
		return;		/* someone else will run out later. */
	for (i = 0; i < tp->size; i++) {
		for (cp = tp->tab[i]; cp; cp = op) {
			op = cp->cnext;
			nh = hash(cp->nval, nsz);
			cp->cnext = np[nh];
			np[nh] = cp;
		}
	}
	free(tp->tab);
	tp->tab = np;
	tp->size = nsz;
}

Cell *lookup(const char *s, Array *tp)	/* look for s in tp */
{
	Cell *p;
	int h;

	h = hash(s, tp->size);
	for (p = tp->tab[h]; p != NULL; p = p->cnext)
		if (strcmp(s, p->nval) == 0)
			return(p);	/* found it */
	return(NULL);			/* not found */
}

Awkfloat setfval(Cell *vp, Awkfloat f)	/* set float val of a Cell */
{
	int fldno;

	if ((vp->tval & (NUM | STR)) == 0) 
		funnyvar(vp, "assign to");
	if (isfld(vp)) {
		donerec = 0;	/* mark $0 invalid */
		fldno = atoi(vp->nval);
		if (fldno > *NF)
			newfld(fldno);
		   dprintf( ("setting field %d to %g\n", fldno, f) );
	} else if (isrec(vp)) {
		donefld = 0;	/* mark $1... invalid */
		donerec = 1;
	}
	if (freeable(vp))
		xfree(vp->sval); /* free any previous string */
	vp->tval &= ~STR;	/* mark string invalid */
	vp->tval |= NUM;	/* mark number ok */
	   dprintf( ("setfval %p: %s = %g, t=%o\n", (void*)vp, NN(vp->nval), f, vp->tval) );
	return vp->fval = f;
}

void funnyvar(Cell *vp, const char *rw)
{
	if (isarr(vp))
		FATAL("can't %s %s; it's an array name.", rw, vp->nval);
	if (vp->tval & FCN)
		FATAL("can't %s %s; it's a function.", rw, vp->nval);
	WARNING("funny variable %p: n=%s s=\"%s\" f=%g t=%o",
		vp, vp->nval, vp->sval, vp->fval, vp->tval);
}

char *setsval(Cell *vp, const char *s)	/* set string val of a Cell */
{
	char *t;
	int fldno;

	   dprintf( ("starting setsval %p: %s = \"%s\", t=%o, r,f=%d,%d\n", 
		(void*)vp, NN(vp->nval), s, vp->tval, donerec, donefld) );
	if ((vp->tval & (NUM | STR)) == 0)
		funnyvar(vp, "assign to");
	if (isfld(vp)) {
		donerec = 0;	/* mark $0 invalid */
		fldno = atoi(vp->nval);
		if (fldno > *NF)
			newfld(fldno);
		   dprintf( ("setting field %d to %s (%p)\n", fldno, s, s) );
	} else if (isrec(vp)) {
		donefld = 0;	/* mark $1... invalid */
		donerec = 1;
	}
	t = tostring(s);	/* in case it's self-assign */
	if (freeable(vp))
		xfree(vp->sval);
	vp->tval &= ~NUM;
	vp->tval |= STR;
	vp->tval &= ~DONTFREE;
	   dprintf( ("setsval %p: %s = \"%s (%p) \", t=%o r,f=%d,%d\n", 
		(void*)vp, NN(vp->nval), t,t, vp->tval, donerec, donefld) );
	return(vp->sval = t);
}

Awkfloat getfval(Cell *vp)	/* get float val of a Cell */
{
	if ((vp->tval & (NUM | STR)) == 0)
		funnyvar(vp, "read value of");
	if (isfld(vp) && donefld == 0)
		fldbld();
	else if (isrec(vp) && donerec == 0)
		recbld();
	if (!isnum(vp)) {	/* not a number */
		vp->fval = atof(vp->sval);	/* best guess */
		if (is_number(vp->sval) && !(vp->tval&CON))
			vp->tval |= NUM;	/* make NUM only sparingly */
	}
	   dprintf( ("getfval %p: %s = %g, t=%o\n",
		(void*)vp, NN(vp->nval), vp->fval, vp->tval) );
	return(vp->fval);
}

static char *get_str_val(Cell *vp, char **fmt)        /* get string val of a Cell */
{
	int n;
	double dtemp;

	if ((vp->tval & (NUM | STR)) == 0)
		funnyvar(vp, "read value of");
	if (isfld(vp) && donefld == 0)
		fldbld();
	else if (isrec(vp) && donerec == 0)
		recbld();
	if (isstr(vp) == 0) {
		if (freeable(vp))
			xfree(vp->sval);
		if (modf(vp->fval, &dtemp) == 0)	/* it's integral */
			n = asprintf(&vp->sval, "%.30g", vp->fval);
		else
			n = asprintf(&vp->sval, *fmt, vp->fval);
		if (n == -1)
			FATAL("out of space in get_str_val");
		vp->tval &= ~DONTFREE;
		vp->tval |= STR;
	}
	   dprintf( ("getsval %p: %s = \"%s (%p)\", t=%o\n",
		(void*)vp, NN(vp->nval), vp->sval, vp->sval, vp->tval) );
	return(vp->sval);
}

char *getsval(Cell *vp)       /* get string val of a Cell */
{
      return get_str_val(vp, CONVFMT);
}

char *getpssval(Cell *vp)     /* get string val of a Cell for print */
{
      return get_str_val(vp, OFMT);
}


char *tostring(const char *s)	/* make a copy of string s */
{
	char *p;

	p = strdup(s);
	if (p == NULL)
		FATAL("out of space in tostring on %s", s);
	return p;
}

char *qstring(const char *is, int delim)	/* collect string up to next delim */
{
	const char *os = is;
	int c, n;
	uschar *s = (uschar *) is;
	uschar *buf, *bp;

	if ((buf = (uschar *) malloc(strlen(is)+3)) == NULL)
		FATAL( "out of space in qstring(%s)", s);
	for (bp = buf; (c = *s) != delim; s++) {
		if (c == '\n')
			SYNTAX( "newline in string %.20s...", os );
		else if (c != '\\')
			*bp++ = c;
		else {	/* \something */
			c = *++s;
			if (c == 0) {	/* \ at end */
				*bp++ = '\\';
				break;	/* for loop */
			}	
			switch (c) {
			case '\\':	*bp++ = '\\'; break;
			case 'n':	*bp++ = '\n'; break;
			case 't':	*bp++ = '\t'; break;
			case 'b':	*bp++ = '\b'; break;
			case 'f':	*bp++ = '\f'; break;
			case 'r':	*bp++ = '\r'; break;
			default:
				if (!isdigit(c)) {
					*bp++ = c;
					break;
				}
				n = c - '0';
				if (isdigit(s[1])) {
					n = 8 * n + *++s - '0';
					if (isdigit(s[1]))
						n = 8 * n + *++s - '0';
				}
				*bp++ = n;
				break;
			}
		}
	}
	*bp++ = 0;
	return (char *) buf;
}
@


1.14
log
@from ru@@freebsd:
Fix a bug converting a variable from the numeric type to a string.

ok otto deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.13 2005/04/15 15:54:26 millert Exp $	*/
d216 1
a216 1
			p, NN(p->nval), NN(p->sval), p->fval, p->tval) );
d235 1
a235 1
		p, p->nval, p->sval, p->fval, p->tval) );
d302 1
a302 1
	   dprintf( ("setfval %p: %s = %g, t=%o\n", vp, NN(vp->nval), f, vp->tval) );
d322 1
a322 1
		vp, NN(vp->nval), s, vp->tval, donerec, donefld) );
d342 1
a342 1
		vp, NN(vp->nval), t,t, vp->tval, donerec, donefld) );
d359 2
a360 1
	   dprintf( ("getfval %p: %s = %g, t=%o\n", vp, NN(vp->nval), vp->fval, vp->tval) );
d387 2
a388 1
	   dprintf( ("getsval %p: %s = \"%s (%p)\", t=%o\n", vp, NN(vp->nval), vp->sval, vp->sval, vp->tval) );
@


1.13
log
@Use asprint(), not snprintf() when converting strings to numbers
since CONVFMT is user-settable (hence we can't know the actual
buffer size requirements) and we need to store a dynamic copy of
the result anyway.  Fixes a truncation issue with weird CONVFMT
values and closes PR 4172 (Matthias Kilian).
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.12 2004/12/30 02:06:00 millert Exp $	*/
d336 2
a339 2
	if (freeable(vp))
		xfree(vp->sval);
@


1.12
log
@Restore error checking in tostring().
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.11 2004/12/30 01:52:48 millert Exp $	*/
d365 1
a365 1
	char s[100];	/* BUG: unchecked */
d378 1
a378 1
			snprintf(s, sizeof(s), "%.30g", vp->fval);
d380 3
a382 2
			snprintf(s, sizeof(s), *fmt, vp->fval);
		vp->sval = tostring(s);
@


1.11
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.10 2003/04/06 06:12:01 pvalchev Exp $	*/
d402 6
a407 1
	return (strdup(s));
@


1.10
log
@more string business; millert ok and suggestion for strdup
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.9 2003/04/04 00:42:34 deraadt Exp $	*/
d55 1
d78 2
a79 1
	FS = &setsymtab("FS", " ", 0.0, STR|DONTFREE, symtab)->sval;
d321 2
a322 1
	   dprintf( ("starting setsval %p: %s = \"%s\", t=%o\n", vp, NN(vp->nval), s, vp->tval) );
d341 2
a342 1
	   dprintf( ("setsval %p: %s = \"%s (%p)\", t=%o\n", vp, NN(vp->nval), t,t, vp->tval) );
d363 1
a363 2
 static char *get_str_val(Cell *vp, char **fmt)        /* get string val of a Cell */

@


1.9
log
@snprintf & strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.8 2002/12/19 21:24:28 millert Exp $	*/
d375 1
a375 1
			sprintf(s, "%.30g", vp->fval);
d377 1
a377 1
			sprintf(s, *fmt, vp->fval);
d399 1
a399 7
	char *p;

	p = (char *) malloc(strlen(s)+1);
	if (p == NULL)
		FATAL("out of space in tostring on %s", s);
	strcpy(p, s);
	return(p);
@


1.8
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.7 2001/09/08 00:12:40 millert Exp $	*/
d110 1
a110 1
		sprintf(temp, "%d", i);
@


1.7
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.6 1999/12/08 23:09:46 millert Exp $	*/
d174 1
d178 2
d184 1
a184 1
void freeelem(Cell *ap, char *s)	/* free elem s from ap (i.e., ap["s"] */
d207 1
a207 1
Cell *setsymtab(char *n, char *s, Awkfloat f, unsigned t, Array *tp)
d214 1
a214 1
			p, p->nval, p->sval, p->fval, p->tval) );
d237 1
a237 1
int hash(char *s, int n)	/* form hash value for string s */
d268 1
a268 1
Cell *lookup(char *s, Array *tp)	/* look for s in tp */
d300 1
a300 1
	   dprintf( ("setfval %p: %s = %g, t=%o\n", vp, vp->nval, f, vp->tval) );
d304 1
a304 1
void funnyvar(Cell *vp, char *rw)
d314 1
a314 1
char *setsval(Cell *vp, char *s)	/* set string val of a Cell */
d319 1
a319 1
	   dprintf( ("starting setsval %p: %s = \"%s\", t=%o\n", vp, vp->nval, s, vp->tval) );
d338 1
a338 1
	   dprintf( ("setsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, t,t, vp->tval) );
d355 1
a355 1
	   dprintf( ("getfval %p: %s = %g, t=%o\n", vp, vp->nval, vp->fval, vp->tval) );
d359 2
a360 1
char *getsval(Cell *vp)	/* get string val of a Cell */
d377 1
a377 1
			sprintf(s, *CONVFMT, vp->fval);
d382 1
a382 1
	   dprintf( ("getsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, vp->sval, vp->sval, vp->tval) );
d386 12
a397 1
char *tostring(char *s)	/* make a copy of string s */
d408 1
a408 1
char *qstring(char *is, int delim)	/* collect string up to next delim */
d410 1
a410 1
	char *os = is;
d415 1
a415 1
	if ((buf = (uschar *) malloc(strlen(s)+3)) == NULL)
@


1.6
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.5 1999/04/20 17:31:31 millert Exp $	*/
d130 2
d393 1
a393 1
char *qstring(char *s, int delim)	/* collect string up to next delim */
d395 1
a395 1
	char *os = s;
d397 2
a398 1
	char *buf, *bp;
d400 1
a400 1
	if ((buf = (char *) malloc(strlen(s)+3)) == NULL)
d437 1
a437 1
	return buf;
@


1.5
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.4 1999/04/18 17:06:31 millert Exp $	*/
d147 1
a147 1
		ERROR "out of space in makesymtab" FATAL;
d214 1
a214 1
		ERROR "out of space for symbol table at %s", n FATAL;
d302 1
a302 1
		ERROR "can't %s %s; it's an array name.", rw, vp->nval FATAL;
d304 3
a306 3
		ERROR "can't %s %s; it's a function.", rw, vp->nval FATAL;
	ERROR "funny variable %p: n=%s s=\"%s\" f=%g t=%o",
		vp, vp->nval, vp->sval, vp->fval, vp->tval WARNING;
d386 1
a386 1
		ERROR "out of space in tostring on %s", s FATAL;
d393 1
d395 1
a395 1
	char *buf = 0, *bp;
d398 1
a398 1
		ERROR "out of space in qstring(%s)", s);
d401 1
a401 1
			ERROR "newline in string %.10s...", buf SYNTAX;
d404 7
a410 2
		else {	/* \something */	
			switch (c = *++s) {
@


1.4
log
@March 5, 1999 version of the "one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD: tran.c,v 1.3 1997/08/25 16:17:14 kstailey Exp $	*/
d265 1
a265 1
	Cell *p, *prev = NULL;
d269 1
a269 1
	for (p = tp->tab[h]; p != NULL; prev = p, p = p->cnext)
@


1.3
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 1
a111 1
		if (isnumber(*av))
d131 1
a131 1
		if (isnumber(p))
d291 2
d347 1
a347 1
		if (isnumber(vp->sval) && !(vp->tval&CON))
@


1.2
log
@Latest research awk from June 29, 1996
@
text
@d1 1
d3 1
a3 1
Copyright (C) AT&T and Lucent Technologies 1996
d11 13
a23 13
documentation, and that the names of AT&T or Lucent Technologies
or any of their entities not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

AT&T AND LUCENT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL AT&T OR LUCENT OR ANY OF THEIR
ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
d33 1
a33 1
#include "awkgram.h"
a54 1
Cell	*recloc;	/* location of record */
d66 1
d68 1
a68 1
extern Cell *fldtab;
d72 1
a72 1
	setsymtab("0", "0", 0.0, NUM|STR|CON|DONTFREE, symtab);
d75 1
a75 1
	nullnode = valtonode(nullloc, CCON);
a76 3
	/* recloc = setsymtab("$0", record, 0.0, REC|STR|DONTFREE, symtab); */
	/* has been done elsewhere */
	recloc = &fldtab[0];
d99 1
a99 1
void arginit(int ac, char *av[])	/* set up ARGV and ARGC */
d103 1
a103 1
	char temp[5];
d110 1
a110 1
		sprintf((char *)temp, "%d", i);
d128 1
a128 1
		if ((p = (char *) strchr((char *) *envp, '=')) == NULL)
d171 1
a171 1
			free((char *) cp); 
d175 2
a176 2
	free((char *) (tp->tab));
	free((char *) tp);
d188 1
a188 1
		if (strcmp((char *) s, (char *) p->nval) == 0) {
d196 1
a196 1
			free((char *) p);
d208 1
a208 1
		dprintf( ("setsymtab found %p: n=%s s=\"%s\" f=%g t=%o\n",
d227 1
a227 1
	dprintf( ("setsymtab set %p: n=%s s=\"%s\" f=%g t=%o\n",
d258 1
a258 1
	free((char *) (tp->tab));
d270 1
a270 1
		if (strcmp((char *) s, (char *) p->nval) == 0)
d277 2
d281 1
a281 1
	if (vp->tval & FLD) {
d283 5
a287 4
		if (vp-fldtab > *NF)
			newfld(vp-fldtab);
		dprintf( ("setting field %d to %g\n", vp-fldtab, f) );
	} else if (vp->tval & REC) {
d293 1
a293 1
	dprintf( ("setfval %p: %s = %g, t=%o\n", vp, vp->nval, f, vp->tval) );
d299 1
a299 1
	if (vp->tval & ARR)
d310 1
d312 1
d315 1
a315 1
	if (vp->tval & FLD) {
d317 5
a321 4
		if (vp-fldtab > *NF)
			newfld(vp-fldtab);
		dprintf( ("setting field %d to %s (%p)\n", vp-fldtab, s, s) );
	} else if (vp->tval & REC) {
d331 1
a331 1
	dprintf( ("setsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, t,t, vp->tval) );
d339 1
a339 1
	if ((vp->tval & FLD) && donefld == 0)
d341 1
a341 1
	else if ((vp->tval & REC) && donerec == 0)
d348 1
a348 1
	dprintf( ("getfval %p: %s = %g, t=%o\n", vp, vp->nval, vp->fval, vp->tval) );
d354 1
a354 1
	char s[100];
d359 1
a359 1
	if ((vp->tval & FLD) && donefld == 0)
d361 1
a361 1
	else if ((vp->tval & REC) && donerec == 0)
d363 2
a364 2
	if ((vp->tval & STR) == 0) {
		if (!(vp->tval&DONTFREE))
d367 1
a367 1
			sprintf((char *)s, "%.20g", vp->fval);
d369 1
a369 1
			sprintf((char *)s, (char *)*CONVFMT, vp->fval);
d374 1
a374 1
	dprintf( ("getsval %p: %s = \"%s (%p)\", t=%o\n", vp, vp->nval, vp->sval, vp->sval, vp->tval) );
d382 1
a382 1
	p = (char *) malloc(strlen((char *) s)+1);
d385 1
a385 1
	strcpy((char *) p, (char *) s);
d392 1
d394 3
a396 1
	for (caddreset(gs); (c = *s) != delim; s++) {
d398 1
a398 1
			ERROR "newline in string %.10s...", gs->cbuf SYNTAX;
d400 2
a401 2
			cadd(gs, c);
		else	/* \something */	
d403 6
a408 6
			case '\\':	cadd(gs, '\\'); break;
			case 'n':	cadd(gs, '\n'); break;
			case 't':	cadd(gs, '\t'); break;
			case 'b':	cadd(gs, '\b'); break;
			case 'f':	cadd(gs, '\f'); break;
			case 'r':	cadd(gs, '\r'); break;
d411 1
a411 1
					cadd(gs, c);
d420 1
a420 1
				cadd(gs, n);
d423 1
d425 2
a426 2
	cadd(gs, 0);
	return gs->cbuf;
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d85 1
a85 1
	FILENAME = &setsymtab("FILENAME", "-", 0.0, STR|DONTFREE, symtab)->sval;
@
