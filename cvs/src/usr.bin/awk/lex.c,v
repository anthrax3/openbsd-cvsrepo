head	1.12;
access;
symbols
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.24
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.20
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.16
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.18
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.10
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.14
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.12
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.8
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.6
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.4
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.12
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.1.0.8
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.6
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.4
	OPENBSD_2_3_BASE:1.1
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2011.09.28.19.27.18;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.06.20.38.33;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.04.14.04.42;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.16.02.10.18;	author hugh;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.23.09.45;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.17.31.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.18.17.06.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.08.25.16.17.11;	author kstailey;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update awk to Aug 10, 2011 version; naddy@@ reports no ports problems
from the update.
@
text
@/*	$OpenBSD: lex.c,v 1.11 2008/10/06 20:38:33 millert Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "awk.h"
#include "ytab.h"

extern YYSTYPE	yylval;
extern int	infunc;

int	lineno	= 1;
int	bracecnt = 0;
int	brackcnt  = 0;
int	parencnt = 0;

typedef struct Keyword {
	const char *word;
	int	sub;
	int	type;
} Keyword;

Keyword keywords[] ={	/* keep sorted: binary searched */
	{ "BEGIN",	XBEGIN,		XBEGIN },
	{ "END",	XEND,		XEND },
	{ "NF",		VARNF,		VARNF },
	{ "and",	FAND,		BLTIN },
	{ "atan2",	FATAN,		BLTIN },
	{ "break",	BREAK,		BREAK },
	{ "close",	CLOSE,		CLOSE },
	{ "compl",	FCOMPL,		BLTIN },
	{ "continue",	CONTINUE,	CONTINUE },
	{ "cos",	FCOS,		BLTIN },
	{ "delete",	DELETE,		DELETE },
	{ "do",		DO,		DO },
	{ "else",	ELSE,		ELSE },
	{ "exit",	EXIT,		EXIT },
	{ "exp",	FEXP,		BLTIN },
	{ "fflush",	FFLUSH,		BLTIN },
	{ "for",	FOR,		FOR },
	{ "func",	FUNC,		FUNC },
	{ "function",	FUNC,		FUNC },
	{ "getline",	GETLINE,	GETLINE },
	{ "gsub",	GSUB,		GSUB },
	{ "if",		IF,		IF },
	{ "in",		IN,		IN },
	{ "index",	INDEX,		INDEX },
	{ "int",	FINT,		BLTIN },
	{ "length",	FLENGTH,	BLTIN },
	{ "log",	FLOG,		BLTIN },
	{ "lshift",	FLSHIFT,	BLTIN },
	{ "match",	MATCHFCN,	MATCHFCN },
	{ "next",	NEXT,		NEXT },
	{ "nextfile",	NEXTFILE,	NEXTFILE },
	{ "or",		FFOR,		BLTIN },
	{ "print",	PRINT,		PRINT },
	{ "printf",	PRINTF,		PRINTF },
	{ "rand",	FRAND,		BLTIN },
	{ "return",	RETURN,		RETURN },
	{ "rshift",	FRSHIFT,	BLTIN },
	{ "sin",	FSIN,		BLTIN },
	{ "split",	SPLIT,		SPLIT },
	{ "sprintf",	SPRINTF,	SPRINTF },
	{ "sqrt",	FSQRT,		BLTIN },
	{ "srand",	FSRAND,		BLTIN },
	{ "sub",	SUB,		SUB },
	{ "substr",	SUBSTR,		SUBSTR },
	{ "system",	FSYSTEM,	BLTIN },
	{ "tolower",	FTOLOWER,	BLTIN },
	{ "toupper",	FTOUPPER,	BLTIN },
	{ "while",	WHILE,		WHILE },
	{ "xor",	FXOR,		BLTIN },
};

#define	RET(x)	{ if(dbg)printf("lex %s\n", tokname(x)); return(x); }

int peek(void);
int gettok(char **, int *);
int binsearch(char *, Keyword *, int);

int peek(void)
{
	int c = input();
	unput(c);
	return c;
}

int gettok(char **pbuf, int *psz)	/* get next input token */
{
	int c, retc;
	char *buf = *pbuf;
	int sz = *psz;
	char *bp = buf;

	c = input();
	if (c == 0)
		return 0;
	buf[0] = c;
	buf[1] = 0;
	if (!isalnum(c) && c != '.' && c != '_')
		return c;

	*bp++ = c;
	if (isalpha(c) || c == '_') {	/* it's a varname */
		for ( ; (c = input()) != 0; ) {
			if (bp-buf >= sz)
				if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, "gettok"))
					FATAL( "out of space for name %.10s...", buf );
			if (isalnum(c) || c == '_')
				*bp++ = c;
			else {
				*bp = 0;
				unput(c);
				break;
			}
		}
		*bp = 0;
		retc = 'a';	/* alphanumeric */
	} else {	/* maybe it's a number, but could be . */
		char *rem;
		/* read input until can't be a number */
		for ( ; (c = input()) != 0; ) {
			if (bp-buf >= sz)
				if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, "gettok"))
					FATAL( "out of space for number %.10s...", buf );
			if (isdigit(c) || c == 'e' || c == 'E' 
			  || c == '.' || c == '+' || c == '-')
				*bp++ = c;
			else {
				unput(c);
				break;
			}
		}
		*bp = 0;
		strtod(buf, &rem);	/* parse the number */
		if (rem == buf) {	/* it wasn't a valid number at all */
			buf[1] = 0;	/* return one character as token */
			retc = buf[0];	/* character is its own type */
			unputstr(rem+1); /* put rest back for later */
		} else {	/* some prefix was a number */
			unputstr(rem);	/* put rest back for later */
			rem[0] = 0;	/* truncate buf after number part */
			retc = '0';	/* type is number */
		}
	}
	*pbuf = buf;
	*psz = sz;
	return retc;
}

int	word(char *);
int	string(void);
int	regexpr(void);
int	sc	= 0;	/* 1 => return a } right now */
int	reg	= 0;	/* 1 => return a REGEXPR now */

int yylex(void)
{
	int c;
	static char *buf = 0;
	static int bufsize = 5; /* BUG: setting this small causes core dump! */

	if (buf == 0 && (buf = (char *) malloc(bufsize)) == NULL)
		FATAL( "out of space in yylex" );
	if (sc) {
		sc = 0;
		RET('}');
	}
	if (reg) {
		reg = 0;
		return regexpr();
	}
	for (;;) {
		c = gettok(&buf, &bufsize);
		if (c == 0)
			return 0;
		if (isalpha(c) || c == '_')
			return word(buf);
		if (isdigit(c)) {
			yylval.cp = setsymtab(buf, tostring(buf), atof(buf), CON|NUM, symtab);
			/* should this also have STR set? */
			RET(NUMBER);
		}
	
		yylval.i = c;
		switch (c) {
		case '\n':	/* {EOL} */
			RET(NL);
		case '\r':	/* assume \n is coming */
		case ' ':	/* {WS}+ */
		case '\t':
			break;
		case '#':	/* #.* strip comments */
			while ((c = input()) != '\n' && c != 0)
				;
			unput(c);
			break;
		case ';':
			RET(';');
		case '\\':
			if (peek() == '\n') {
				input();
			} else if (peek() == '\r') {
				input(); input();	/* \n */
				lineno++;
			} else {
				RET(c);
			}
			break;
		case '&':
			if (peek() == '&') {
				input(); RET(AND);
			} else 
				RET('&');
		case '|':
			if (peek() == '|') {
				input(); RET(BOR);
			} else
				RET('|');
		case '!':
			if (peek() == '=') {
				input(); yylval.i = NE; RET(NE);
			} else if (peek() == '~') {
				input(); yylval.i = NOTMATCH; RET(MATCHOP);
			} else
				RET(NOT);
		case '~':
			yylval.i = MATCH;
			RET(MATCHOP);
		case '<':
			if (peek() == '=') {
				input(); yylval.i = LE; RET(LE);
			} else {
				yylval.i = LT; RET(LT);
			}
		case '=':
			if (peek() == '=') {
				input(); yylval.i = EQ; RET(EQ);
			} else {
				yylval.i = ASSIGN; RET(ASGNOP);
			}
		case '>':
			if (peek() == '=') {
				input(); yylval.i = GE; RET(GE);
			} else if (peek() == '>') {
				input(); yylval.i = APPEND; RET(APPEND);
			} else {
				yylval.i = GT; RET(GT);
			}
		case '+':
			if (peek() == '+') {
				input(); yylval.i = INCR; RET(INCR);
			} else if (peek() == '=') {
				input(); yylval.i = ADDEQ; RET(ASGNOP);
			} else
				RET('+');
		case '-':
			if (peek() == '-') {
				input(); yylval.i = DECR; RET(DECR);
			} else if (peek() == '=') {
				input(); yylval.i = SUBEQ; RET(ASGNOP);
			} else
				RET('-');
		case '*':
			if (peek() == '=') {	/* *= */
				input(); yylval.i = MULTEQ; RET(ASGNOP);
			} else if (peek() == '*') {	/* ** or **= */
				input();	/* eat 2nd * */
				if (peek() == '=') {
					input(); yylval.i = POWEQ; RET(ASGNOP);
				} else {
					RET(POWER);
				}
			} else
				RET('*');
		case '/':
			RET('/');
		case '%':
			if (peek() == '=') {
				input(); yylval.i = MODEQ; RET(ASGNOP);
			} else
				RET('%');
		case '^':
			if (peek() == '=') {
				input(); yylval.i = POWEQ; RET(ASGNOP);
			} else
				RET(POWER);

		case '$':
			/* BUG: awkward, if not wrong */
			c = gettok(&buf, &bufsize);
			if (isalpha(c)) {
				if (strcmp(buf, "NF") == 0) {	/* very special */
					unputstr("(NF)");
					RET(INDIRECT);
				}
				c = peek();
				if (c == '(' || c == '[' || (infunc && isarg(buf) >= 0)) {
					unputstr(buf);
					RET(INDIRECT);
				}
				yylval.cp = setsymtab(buf, "", 0.0, STR|NUM, symtab);
				RET(IVAR);
			} else if (c == 0) {	/*  */
				SYNTAX( "unexpected end of input after $" );
				RET(';');
			} else {
				unputstr(buf);
				RET(INDIRECT);
			}
	
		case '}':
			if (--bracecnt < 0)
				SYNTAX( "extra }" );
			sc = 1;
			RET(';');
		case ']':
			if (--brackcnt < 0)
				SYNTAX( "extra ]" );
			RET(']');
		case ')':
			if (--parencnt < 0)
				SYNTAX( "extra )" );
			RET(')');
		case '{':
			bracecnt++;
			RET('{');
		case '[':
			brackcnt++;
			RET('[');
		case '(':
			parencnt++;
			RET('(');
	
		case '"':
			return string();	/* BUG: should be like tran.c ? */
	
		default:
			RET(c);
		}
	}
}

int string(void)
{
	int c, n;
	char *s, *bp;
	static char *buf = 0;
	static int bufsz = 500;

	if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of space for strings");
	for (bp = buf; (c = input()) != '"'; ) {
		if (!adjbuf(&buf, &bufsz, bp-buf+2, 500, &bp, "string"))
			FATAL("out of space for string %.10s...", buf);
		switch (c) {
		case '\n':
		case '\r':
		case 0:
			SYNTAX( "non-terminated string %.10s...", buf );
			lineno++;
			if (c == 0)	/* hopeless */
				FATAL( "giving up" );
			break;
		case '\\':
			c = input();
			switch (c) {
			case '"': *bp++ = '"'; break;
			case 'n': *bp++ = '\n'; break;	
			case 't': *bp++ = '\t'; break;
			case 'f': *bp++ = '\f'; break;
			case 'r': *bp++ = '\r'; break;
			case 'b': *bp++ = '\b'; break;
			case 'v': *bp++ = '\v'; break;
			case 'a': *bp++ = '\007'; break;
			case '\\': *bp++ = '\\'; break;

			case '0': case '1': case '2': /* octal: \d \dd \ddd */
			case '3': case '4': case '5': case '6': case '7':
				n = c - '0';
				if ((c = peek()) >= '0' && c < '8') {
					n = 8 * n + input() - '0';
					if ((c = peek()) >= '0' && c < '8')
						n = 8 * n + input() - '0';
				}
				*bp++ = n;
				break;

			case 'x':	/* hex  \x0-9a-fA-F + */
			    {	char xbuf[100], *px;
				for (px = xbuf; (c = input()) != 0 && px-xbuf < 100-2; ) {
					if (isdigit(c)
					 || (c >= 'a' && c <= 'f')
					 || (c >= 'A' && c <= 'F'))
						*px++ = c;
					else
						break;
				}
				*px = 0;
				unput(c);
	  			sscanf(xbuf, "%x", (unsigned int *) &n);
				*bp++ = n;
				break;
			    }

			default: 
				*bp++ = c;
				break;
			}
			break;
		default:
			*bp++ = c;
			break;
		}
	}
	*bp = 0; 
	s = tostring(buf);
	*bp++ = ' '; *bp++ = 0;
	yylval.cp = setsymtab(buf, s, 0.0, CON|STR|DONTFREE, symtab);
	RET(STRING);
}


int binsearch(char *w, Keyword *kp, int n)
{
	int cond, low, mid, high;

	low = 0;
	high = n - 1;
	while (low <= high) {
		mid = (low + high) / 2;
		if ((cond = strcmp(w, kp[mid].word)) < 0)
			high = mid - 1;
		else if (cond > 0)
			low = mid + 1;
		else
			return mid;
	}
	return -1;
}

int word(char *w) 
{
	Keyword *kp;
	int c, n;

	n = binsearch(w, keywords, sizeof(keywords)/sizeof(keywords[0]));
/* BUG: this ought to be inside the if; in theory could fault (daniel barrett) */
	kp = keywords + n;
	if (n != -1) {	/* found in table */
		yylval.i = kp->sub;
		switch (kp->type) {	/* special handling */
		case BLTIN:
			if (kp->sub == FSYSTEM && safe)
				SYNTAX( "system is unsafe" );
			RET(kp->type);
		case FUNC:
			if (infunc)
				SYNTAX( "illegal nested function" );
			RET(kp->type);
		case RETURN:
			if (!infunc)
				SYNTAX( "return not in function" );
			RET(kp->type);
		case VARNF:
			yylval.cp = setsymtab("NF", "", 0.0, NUM, symtab);
			RET(VARNF);
		default:
			RET(kp->type);
		}
	}
	c = peek();	/* look for '(' */
	if (c != '(' && infunc && (n=isarg(w)) >= 0) {
		yylval.i = n;
		RET(ARG);
	} else {
		yylval.cp = setsymtab(w, "", 0.0, STR|NUM|DONTFREE, symtab);
		if (c == '(') {
			RET(CALL);
		} else {
			RET(VAR);
		}
	}
}

void startreg(void)	/* next call to yylex will return a regular expression */
{
	reg = 1;
}

int regexpr(void)
{
	int c, openclass = 0;
	static char *buf = 0;
	static int bufsz = 500;
	char *bp;

	if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of space for rex expr");
	bp = buf;
	for ( ; ((c = input()) != '/' || openclass == 1) && c != 0; ) {
		if (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, "regexpr"))
			FATAL("out of space for reg expr %.10s...", buf);
		if (c == '\n') {
			SYNTAX( "newline in regular expression %.10s...", buf ); 
			unput('\n');
			break;
		} else if (c == '\\') {
			*bp++ = '\\'; 
			*bp++ = input();
		} else {
			if (c == '[')
				openclass = 1;
			else if (c == ']')
				openclass = 0;
			*bp++ = c;
		}
	}
	*bp = 0;
	if (c == 0)
		SYNTAX("non-terminated regular expression %.10s...", buf);
	yylval.s = tostring(buf);
	unput('/');
	RET(REGEXPR);
}

/* low-level lexical stuff, sort of inherited from lex */

char	ebuf[300];
char	*ep = ebuf;
char	yysbuf[100];	/* pushback buffer */
char	*yysptr = yysbuf;
FILE	*yyin = 0;

int input(void)	/* get next lexical input character */
{
	int c;
	extern char *lexprog;

	if (yysptr > yysbuf)
		c = (uschar)*--yysptr;
	else if (lexprog != NULL) {	/* awk '...' */
		if ((c = (uschar)*lexprog) != 0)
			lexprog++;
	} else				/* awk -f ... */
		c = pgetc();
	if (c == '\n')
		lineno++;
	else if (c == EOF)
		c = 0;
	if (ep >= ebuf + sizeof ebuf)
		ep = ebuf;
	return *ep++ = c;
}

void unput(int c)	/* put lexical character back on input */
{
	if (c == '\n')
		lineno--;
	if (yysptr >= yysbuf + sizeof(yysbuf))
		FATAL("pushed back too much: %.20s...", yysbuf);
	*yysptr++ = c;
	if (--ep < ebuf)
		ep = ebuf + sizeof(ebuf) - 1;
}

void unputstr(const char *s)	/* put a string back on input */
{
	int i;

	for (i = strlen(s)-1; i >= 0; i--)
		unput(s[i]);
}
@


1.11
log
@Update awk to version 20071023; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.10 2008/06/04 14:04:42 pyr Exp $	*/
d425 1
a425 1
	  			sscanf(xbuf, "%x", &n);
@


1.10
log
@Extend awk with bitwise operations. This is an extension to the awk
spec and documented as such, but comes in handy from time to time.
The prototypes make it compatible with a similar GNU awk extension.

ok millert@@, enthusiasm from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.9 2006/04/16 02:10:18 hugh Exp $	*/
a98 2
#define DEBUG
#ifdef	DEBUG
a99 3
#else
#define	RET(x)	return(x)
#endif
d131 1
a131 1
				if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, 0))
d143 1
a143 1
	} else {	/* it's a number */
d148 1
a148 1
				if (!adjbuf(&buf, &sz, bp-buf+2, 100, &bp, 0))
a159 2
		unputstr(rem);		/* put rest back for later */
/* printf("unputstr [%s], buf [%s]\n", rem, buf); */
d161 1
a161 1
			buf[1] = 0;	/* so return one character as token */
d163 1
d165 3
a167 2
			rem[0] = 0;	/* so truncate where failure started */
			retc = '0';	/* number */
d185 1
a185 1
	static int bufsize = 500;
a196 1
/* printf("top\n"); */
a198 1
/* printf("gettok [%s]\n", buf); */
d378 1
a378 1
		if (!adjbuf(&buf, &bufsz, bp-buf+2, 500, &bp, 0))
d472 1
d477 2
a478 2
		case FSYSTEM:
			if (safe)
d526 1
a526 1
		if (!adjbuf(&buf, &bufsz, bp-buf+3, 500, &bp, 0))
@


1.9
log
@Handle / inside []s properly.
OK by otto and millert.
Offered back to bell-labs.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.8 2004/12/30 01:52:48 millert Exp $	*/
d51 1
d55 1
d75 1
d79 1
d84 1
d96 1
@


1.8
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.7 2003/07/02 21:04:09 deraadt Exp $	*/
d517 1
a517 1
	int c;
d525 1
a525 1
	for ( ; (c = input()) != '/' && c != 0; ) {
d536 4
@


1.7
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.6 2002/12/19 21:24:28 millert Exp $	*/
d160 1
d196 1
d199 1
d540 2
d561 1
a561 1
		c = *--yysptr;
d563 1
a563 1
		if ((c = *lexprog) != 0)
@


1.6
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.5 2001/09/08 00:12:40 millert Exp $	*/
d99 4
@


1.5
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.4 1999/12/08 23:09:45 millert Exp $	*/
d42 1
a42 1
	char	*word;
d109 1
a109 1
	int c;
d137 1
d156 7
a162 1
		rem[0] = 0;
d166 1
a166 1
	return buf[0];
d197 1
a197 1
		if (isdigit(c) || c == '.') {
d322 3
d380 2
d503 1
a503 1
void startreg(void)	/* next call to yyles will return a regular expression */
d578 1
a578 1
void unputstr(char *s)	/* put a string back on input */
@


1.4
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.3 1999/04/20 17:31:29 millert Exp $	*/
d299 1
a299 1
	
d303 1
a303 4
			if (c == '(' || c == '[' || (infunc && isarg(buf) >= 0)) {
				unputstr(buf);
				RET(INDIRECT);
			} else if (isalpha(c)) {
d306 5
@


1.3
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.2 1999/04/18 17:06:30 millert Exp $	*/
d127 1
a127 1
					ERROR "out of space for name %.10s...", buf FATAL;
d136 1
d143 1
a143 1
					ERROR "out of space for number %.10s...", buf FATAL;
d175 1
a175 1
		ERROR "out of space in yylex" FATAL;
d320 1
a320 1
				ERROR "extra }" SYNTAX;
d325 1
a325 1
				ERROR "extra ]" SYNTAX;
d329 1
a329 1
				ERROR "extra )" SYNTAX;
d358 1
a358 1
		ERROR "out of space for strings" FATAL;
d361 1
a361 1
			ERROR "out of space for string %.10s...", buf FATAL;
d366 1
a366 1
			ERROR "non-terminated string %.10s...", buf SYNTAX;
d458 1
a458 1
				ERROR "system is unsafe" SYNTAX;
d462 1
a462 1
				ERROR "illegal nested function" SYNTAX;
d466 1
a466 1
				ERROR "return not in function" SYNTAX;
d502 1
a502 1
		ERROR "out of space for rex expr" FATAL;
d506 1
a506 1
			ERROR "out of space for reg expr %.10s...", buf FATAL;
d508 1
a508 1
			ERROR "newline in regular expression %.10s...", buf SYNTAX; 
d558 1
a558 1
		ERROR "pushed back too much: %.20s...", yysbuf FATAL;
@


1.2
log
@March 5, 1999 version of the "one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD: lex.c,v 1.1 1997/08/25 16:17:11 kstailey Exp $	*/
d167 1
a167 1
int yylex()
d169 1
a169 1
	int c, n;
d212 1
a212 1
				input(); lineno++;
d287 1
a287 4
			if (peek() == '=') {
				input(); yylval.i = DIVEQ; RET(ASGNOP);
			} else
				RET('/');
d302 1
a302 1
			if (c == '(' || c == '[' || (infunc && (n=isarg(buf)) >= 0)) {
d349 1
a349 1
int string()
d378 1
a378 1
			case 'a': *bp++ = '\a'; break;
d493 1
a493 1
int regexpr()
@


1.1
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
int peek()
a146 1
				*bp = 0;
d151 1
@

