head	1.41;
access;
symbols
	OPENBSD_6_1:1.40.0.8
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.40.0.4
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.38.0.6
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.8
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.6
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.30.0.4
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.12
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.10
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.26.0.8
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.6
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.6
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.4
	OPENBSD_3_1_BASE:1.17
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.6
	OPENBSD_2_8:1.16.0.4
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.13.0.8
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.6
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.41
date	2017.09.15.14.19.56;	author ajacoutot;	state Exp;
branches;
next	1.40;
commitid	T3MGFxy9QxLdq4UU;

1.40
date	2015.12.16.19.44.42;	author tb;	state Exp;
branches;
next	1.39;
commitid	FRuir3B7kaQaBLbV;

1.39
date	2015.09.05.22.07.10;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	A9fb7VgTE9Nqw7sI;

1.38
date	2014.12.19.19.28.55;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	F6KsUHbBzg2Ekpcd;

1.37
date	2014.12.08.21.50.09;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	SXBTfmxVIS9mOzSl;

1.36
date	2014.12.01.03.18.50;	author millert;	state Exp;
branches;
next	1.35;
commitid	NIGIPT1ihtjwJ25U;

1.35
date	2014.10.11.03.07.29;	author doug;	state Exp;
branches;
next	1.34;
commitid	m8JXPdZw3A2lFspQ;

1.34
date	2013.09.29.15.42.25;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.28.19.27.18;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.20.22.28.39;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.13.17.58.19;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.06.20.38.33;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.04.14.04.42;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.13.00.22.17;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.27.17.19.34;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.30.02.08.35;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.08.22.08.51;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.02.21.04.09;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.28.03.07.40;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.04.06.06.12.01;	author pvalchev;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.12.08.23.09.46;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.04.20.17.31.30;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.04.18.17.06.31;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.08.25.16.17.14;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.04.07.15.59.56;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.04.06.06.31.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.01.29.18.33.56;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.01.25.03.24.52;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.01.25.00.24.31;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.01.24.23.43.10;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.24.23.11.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.01.21.23.57.37;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.21.23.47.55;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.21.21.14.06;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.01.20.19.43.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.48;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Fix bitwise operations error messages; from FreeBSD

ok deraadt@@
@
text
@/*	$OpenBSD: run.c,v 1.40 2015/12/16 19:44:42 tb Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <ctype.h>
#include <setjmp.h>
#include <limits.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "awk.h"
#include "ytab.h"

#define tempfree(x)	if (istemp(x)) tfree(x); else

/*
#undef tempfree

void tempfree(Cell *p) {
	if (p->ctype == OCELL && (p->csub < CUNK || p->csub > CFREE)) {
		WARNING("bad csub %d in Cell %d %s",
			p->csub, p->ctype, p->sval);
	}
	if (istemp(p))
		tfree(p);
}
*/

/* do we really need these? */
/* #ifdef _NFILE */
/* #ifndef FOPEN_MAX */
/* #define FOPEN_MAX _NFILE */
/* #endif */
/* #endif */
/*  */
/* #ifndef	FOPEN_MAX */
/* #define	FOPEN_MAX	40 */	/* max number of open files */
/* #endif */
/*  */
/* #ifndef RAND_MAX */
/* #define RAND_MAX	32767 */	/* all that ansi guarantees */
/* #endif */

jmp_buf env;
extern	int	pairstack[];
extern	Awkfloat	srand_seed;

Node	*winner = NULL;	/* root of parse tree */
Cell	*tmps;		/* free temporary cells for execution */

static Cell	truecell	={ OBOOL, BTRUE, 0, 0, 1.0, NUM };
Cell	*True	= &truecell;
static Cell	falsecell	={ OBOOL, BFALSE, 0, 0, 0.0, NUM };
Cell	*False	= &falsecell;
static Cell	breakcell	={ OJUMP, JBREAK, 0, 0, 0.0, NUM };
Cell	*jbreak	= &breakcell;
static Cell	contcell	={ OJUMP, JCONT, 0, 0, 0.0, NUM };
Cell	*jcont	= &contcell;
static Cell	nextcell	={ OJUMP, JNEXT, 0, 0, 0.0, NUM };
Cell	*jnext	= &nextcell;
static Cell	nextfilecell	={ OJUMP, JNEXTFILE, 0, 0, 0.0, NUM };
Cell	*jnextfile	= &nextfilecell;
static Cell	exitcell	={ OJUMP, JEXIT, 0, 0, 0.0, NUM };
Cell	*jexit	= &exitcell;
static Cell	retcell		={ OJUMP, JRET, 0, 0, 0.0, NUM };
Cell	*jret	= &retcell;
static Cell	tempcell	={ OCELL, CTEMP, 0, "", 0.0, NUM|STR|DONTFREE };

Node	*curnode = NULL;	/* the node being executed, for debugging */

void	stdinit(void);
void	flush_all(void);

/* buffer memory management */
int adjbuf(char **pbuf, int *psiz, int minlen, int quantum, char **pbptr,
	const char *whatrtn)
/* pbuf:    address of pointer to buffer being managed
 * psiz:    address of buffer size variable
 * minlen:  minimum length of buffer needed
 * quantum: buffer size quantum
 * pbptr:   address of movable pointer into buffer, or 0 if none
 * whatrtn: name of the calling routine if failure should cause fatal error
 *
 * return   0 for realloc failure, !=0 for success
 */
{
	if (minlen > *psiz) {
		char *tbuf;
		int rminlen = quantum ? minlen % quantum : 0;
		int boff = pbptr ? *pbptr - *pbuf : 0;
		/* round up to next multiple of quantum */
		if (rminlen)
			minlen += quantum - rminlen;
		tbuf = (char *) realloc(*pbuf, minlen);
		dprintf( ("adjbuf %s: %d %d (pbuf=%p, tbuf=%p)\n", whatrtn, *psiz, minlen, *pbuf, tbuf) );
		if (tbuf == NULL) {
			if (whatrtn)
				FATAL("out of memory in %s", whatrtn);
			return 0;
		}
		*pbuf = tbuf;
		*psiz = minlen;
		if (pbptr)
			*pbptr = tbuf + boff;
	}
	return 1;
}

void run(Node *a)	/* execution of parse tree starts here */
{
	stdinit();
	execute(a);
	closeall();
}

Cell *execute(Node *u)	/* execute a node of the parse tree */
{
	Cell *(*proc)(Node **, int);
	Cell *x;
	Node *a;

	if (u == NULL)
		return(True);
	for (a = u; ; a = a->nnext) {
		curnode = a;
		if (isvalue(a)) {
			x = (Cell *) (a->narg[0]);
			if (isfld(x) && !donefld)
				fldbld();
			else if (isrec(x) && !donerec)
				recbld();
			return(x);
		}
		if (notlegal(a->nobj))	/* probably a Cell* but too risky to print */
			FATAL("illegal statement");
		proc = proctab[a->nobj-FIRSTTOKEN];
		x = (*proc)(a->narg, a->nobj);
		if (isfld(x) && !donefld)
			fldbld();
		else if (isrec(x) && !donerec)
			recbld();
		if (isexpr(a))
			return(x);
		if (isjump(x))
			return(x);
		if (a->nnext == NULL)
			return(x);
		tempfree(x);
	}
}


Cell *program(Node **a, int n)	/* execute an awk program */
{				/* a[0] = BEGIN, a[1] = body, a[2] = END */
	Cell *x;

	if (setjmp(env) != 0)
		goto ex;
	if (a[0]) {		/* BEGIN */
		x = execute(a[0]);
		if (isexit(x))
			return(True);
		if (isjump(x))
			FATAL("illegal break, continue, next or nextfile from BEGIN");
		tempfree(x);
	}
	if (a[1] || a[2])
		while (getrec(&record, &recsize, 1) > 0) {
			x = execute(a[1]);
			if (isexit(x))
				break;
			tempfree(x);
		}
  ex:
	if (setjmp(env) != 0)	/* handles exit within END */
		goto ex1;
	if (a[2]) {		/* END */
		x = execute(a[2]);
		if (isbreak(x) || isnext(x) || iscont(x))
			FATAL("illegal break, continue, next or nextfile from END");
		tempfree(x);
	}
  ex1:
	return(True);
}

struct Frame {	/* stack frame for awk function calls */
	int nargs;	/* number of arguments in this call */
	Cell *fcncell;	/* pointer to Cell for function */
	Cell **args;	/* pointer to array of arguments after execute */
	Cell *retval;	/* return value */
};

#define	NARGS	50	/* max args in a call */

struct Frame *frame = NULL;	/* base of stack frames; dynamically allocated */
int	nframe = 0;		/* number of frames allocated */
struct Frame *fp = NULL;	/* frame pointer. bottom level unused */

Cell *call(Node **a, int n)	/* function call.  very kludgy and fragile */
{
	static Cell newcopycell = { OCELL, CCOPY, 0, "", 0.0, NUM|STR|DONTFREE };
	int i, ncall, ndef;
	int freed = 0; /* handles potential double freeing when fcn & param share a tempcell */
	Node *x;
	Cell *args[NARGS], *oargs[NARGS];	/* BUG: fixed size arrays */
	Cell *y, *z, *fcn;
	char *s;

	fcn = execute(a[0]);	/* the function itself */
	s = fcn->nval;
	if (!isfcn(fcn))
		FATAL("calling undefined function %s", s);
	if (frame == NULL) {
		fp = frame = (struct Frame *) calloc(nframe += 100, sizeof(struct Frame));
		if (frame == NULL)
			FATAL("out of space for stack frames calling %s", s);
	}
	for (ncall = 0, x = a[1]; x != NULL; x = x->nnext)	/* args in call */
		ncall++;
	ndef = (int) fcn->fval;			/* args in defn */
	   dprintf( ("calling %s, %d args (%d in defn), fp=%d\n", s, ncall, ndef, (int) (fp-frame)) );
	if (ncall > ndef)
		WARNING("function %s called with %d args, uses only %d",
			s, ncall, ndef);
	if (ncall + ndef > NARGS)
		FATAL("function %s has %d arguments, limit %d", s, ncall+ndef, NARGS);
	for (i = 0, x = a[1]; x != NULL; i++, x = x->nnext) {	/* get call args */
		   dprintf( ("evaluate args[%d], fp=%d:\n", i, (int) (fp-frame)) );
		y = execute(x);
		oargs[i] = y;
		   dprintf( ("args[%d]: %s %f <%s>, t=%o\n",
			   i, NN(y->nval), y->fval, isarr(y) ? "(array)" : NN(y->sval), y->tval) );
		if (isfcn(y))
			FATAL("can't use function %s as argument in %s", y->nval, s);
		if (isarr(y))
			args[i] = y;	/* arrays by ref */
		else
			args[i] = copycell(y);
		tempfree(y);
	}
	for ( ; i < ndef; i++) {	/* add null args for ones not provided */
		args[i] = gettemp();
		*args[i] = newcopycell;
	}
	fp++;	/* now ok to up frame */
	if (fp >= frame + nframe) {
		int dfp = fp - frame;	/* old index */
		frame = reallocarray(frame, (nframe += 100),
		    sizeof(struct Frame));
		if (frame == NULL)
			FATAL("out of space for stack frames in %s", s);
		fp = frame + dfp;
	}
	fp->fcncell = fcn;
	fp->args = args;
	fp->nargs = ndef;	/* number defined with (excess are locals) */
	fp->retval = gettemp();

	   dprintf( ("start exec of %s, fp=%d\n", s, (int) (fp-frame)) );
	y = execute((Node *)(fcn->sval));	/* execute body */
	   dprintf( ("finished exec of %s, fp=%d\n", s, (int) (fp-frame)) );

	for (i = 0; i < ndef; i++) {
		Cell *t = fp->args[i];
		if (isarr(t)) {
			if (t->csub == CCOPY) {
				if (i >= ncall) {
					freesymtab(t);
					t->csub = CTEMP;
					tempfree(t);
				} else {
					oargs[i]->tval = t->tval;
					oargs[i]->tval &= ~(STR|NUM|DONTFREE);
					oargs[i]->sval = t->sval;
					tempfree(t);
				}
			}
		} else if (t != y) {	/* kludge to prevent freeing twice */
			t->csub = CTEMP;
			tempfree(t);
		} else if (t == y && t->csub == CCOPY) {
			t->csub = CTEMP;
			tempfree(t);
			freed = 1;
		}
	}
	tempfree(fcn);
	if (isexit(y) || isnext(y))
		return y;
	if (freed == 0) {
		tempfree(y);	/* don't free twice! */
	}
	z = fp->retval;			/* return value */
	   dprintf( ("%s returns %g |%s| %o\n", s, getfval(z), getsval(z), z->tval) );
	fp--;
	return(z);
}

Cell *copycell(Cell *x)	/* make a copy of a cell in a temp */
{
	Cell *y;

	y = gettemp();
	y->csub = CCOPY;	/* prevents freeing until call is over */
	y->nval = x->nval;	/* BUG? */
	if (isstr(x))
		y->sval = tostring(x->sval);
	y->fval = x->fval;
	y->tval = x->tval & ~(CON|FLD|REC|DONTFREE);	/* copy is not constant or field */
							/* is DONTFREE right? */
	return y;
}

Cell *arg(Node **a, int n)	/* nth argument of a function */
{

	n = ptoi(a[0]);	/* argument number, counting from 0 */
	   dprintf( ("arg(%d), fp->nargs=%d\n", n, fp->nargs) );
	if (n+1 > fp->nargs)
		FATAL("argument #%d of function %s was not supplied",
			n+1, fp->fcncell->nval);
	return fp->args[n];
}

Cell *jump(Node **a, int n)	/* break, continue, next, nextfile, return */
{
	Cell *y;

	switch (n) {
	case EXIT:
		if (a[0] != NULL) {
			y = execute(a[0]);
			errorflag = (int) getfval(y);
			tempfree(y);
		}
		longjmp(env, 1);
	case RETURN:
		if (a[0] != NULL) {
			y = execute(a[0]);
			if ((y->tval & (STR|NUM)) == (STR|NUM)) {
				setsval(fp->retval, getsval(y));
				fp->retval->fval = getfval(y);
				fp->retval->tval |= NUM;
			}
			else if (y->tval & STR)
				setsval(fp->retval, getsval(y));
			else if (y->tval & NUM)
				setfval(fp->retval, getfval(y));
			else		/* can't happen */
				FATAL("bad type variable %d", y->tval);
			tempfree(y);
		}
		return(jret);
	case NEXT:
		return(jnext);
	case NEXTFILE:
		nextfile();
		return(jnextfile);
	case BREAK:
		return(jbreak);
	case CONTINUE:
		return(jcont);
	default:	/* can't happen */
		FATAL("illegal jump type %d", n);
	}
	return 0;	/* not reached */
}

Cell *awkgetline(Node **a, int n)	/* get next line from specific input */
{		/* a[0] is variable, a[1] is operator, a[2] is filename */
	Cell *r, *x;
	extern Cell **fldtab;
	FILE *fp;
	char *buf;
	int bufsize = recsize;
	int mode;

	if ((buf = (char *) malloc(bufsize)) == NULL)
		FATAL("out of memory in getline");

	fflush(stdout);	/* in case someone is waiting for a prompt */
	r = gettemp();
	if (a[1] != NULL) {		/* getline < file */
		x = execute(a[2]);		/* filename */
		mode = ptoi(a[1]);
		if (mode == '|')		/* input pipe */
			mode = LE;	/* arbitrary flag */
		fp = openfile(mode, getsval(x));
		tempfree(x);
		if (fp == NULL)
			n = -1;
		else
			n = readrec(&buf, &bufsize, fp);
		if (n <= 0) {
			;
		} else if (a[0] != NULL) {	/* getline var <file */
			x = execute(a[0]);
			setsval(x, buf);
			tempfree(x);
		} else {			/* getline <file */
			setsval(fldtab[0], buf);
			if (is_number(fldtab[0]->sval)) {
				fldtab[0]->fval = atof(fldtab[0]->sval);
				fldtab[0]->tval |= NUM;
			}
		}
	} else {			/* bare getline; use current input */
		if (a[0] == NULL)	/* getline */
			n = getrec(&record, &recsize, 1);
		else {			/* getline var */
			n = getrec(&buf, &bufsize, 0);
			x = execute(a[0]);
			setsval(x, buf);
			tempfree(x);
		}
	}
	setfval(r, (Awkfloat) n);
	free(buf);
	return r;
}

Cell *getnf(Node **a, int n)	/* get NF */
{
	if (donefld == 0)
		fldbld();
	return (Cell *) a[0];
}

Cell *array(Node **a, int n)	/* a[0] is symtab, a[1] is list of subscripts */
{
	Cell *x, *y, *z;
	char *s;
	Node *np;
	char *buf;
	int bufsz = recsize;
	int nsub = strlen(*SUBSEP);

	if ((buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of memory in array");

	x = execute(a[0]);	/* Cell* for symbol table */
	buf[0] = 0;
	for (np = a[1]; np; np = np->nnext) {
		y = execute(np);	/* subscript */
		s = getsval(y);
		if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, "array"))
			FATAL("out of memory for %s[%s...]", x->nval, buf);
		strlcat(buf, s, bufsz);
		if (np->nnext)
			strlcat(buf, *SUBSEP, bufsz);
		tempfree(y);
	}
	if (!isarr(x)) {
		   dprintf( ("making %s into an array\n", NN(x->nval)) );
		if (freeable(x))
			xfree(x->sval);
		x->tval &= ~(STR|NUM|DONTFREE);
		x->tval |= ARR;
		x->sval = (char *) makesymtab(NSYMTAB);
	}
	z = setsymtab(buf, "", 0.0, STR|NUM, (Array *) x->sval);
	z->ctype = OCELL;
	z->csub = CVAR;
	tempfree(x);
	free(buf);
	return(z);
}

Cell *awkdelete(Node **a, int n)	/* a[0] is symtab, a[1] is list of subscripts */
{
	Cell *x, *y;
	Node *np;
	char *s;
	int nsub = strlen(*SUBSEP);

	x = execute(a[0]);	/* Cell* for symbol table */
	if (!isarr(x))
		return True;
	if (a[1] == 0) {	/* delete the elements, not the table */
		freesymtab(x);
		x->tval &= ~STR;
		x->tval |= ARR;
		x->sval = (char *) makesymtab(NSYMTAB);
	} else {
		int bufsz = recsize;
		char *buf;
		if ((buf = (char *) malloc(bufsz)) == NULL)
			FATAL("out of memory in adelete");
		buf[0] = 0;
		for (np = a[1]; np; np = np->nnext) {
			y = execute(np);	/* subscript */
			s = getsval(y);
			if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, "awkdelete"))
				FATAL("out of memory deleting %s[%s...]", x->nval, buf);
			strlcat(buf, s, bufsz);	
			if (np->nnext)
				strlcat(buf, *SUBSEP, bufsz);
			tempfree(y);
		}
		freeelem(x, buf);
		free(buf);
	}
	tempfree(x);
	return True;
}

Cell *intest(Node **a, int n)	/* a[0] is index (list), a[1] is symtab */
{
	Cell *x, *ap, *k;
	Node *p;
	char *buf;
	char *s;
	int bufsz = recsize;
	int nsub = strlen(*SUBSEP);

	ap = execute(a[1]);	/* array name */
	if (!isarr(ap)) {
		   dprintf( ("making %s into an array\n", ap->nval) );
		if (freeable(ap))
			xfree(ap->sval);
		ap->tval &= ~(STR|NUM|DONTFREE);
		ap->tval |= ARR;
		ap->sval = (char *) makesymtab(NSYMTAB);
	}
	if ((buf = (char *) malloc(bufsz)) == NULL) {
		FATAL("out of memory in intest");
	}
	buf[0] = 0;
	for (p = a[0]; p; p = p->nnext) {
		x = execute(p);	/* expr */
		s = getsval(x);
		if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, "intest"))
			FATAL("out of memory deleting %s[%s...]", x->nval, buf);
		strlcat(buf, s, bufsz);
		tempfree(x);
		if (p->nnext)
			strlcat(buf, *SUBSEP, bufsz);
	}
	k = lookup(buf, (Array *) ap->sval);
	tempfree(ap);
	free(buf);
	if (k == NULL)
		return(False);
	else
		return(True);
}


Cell *matchop(Node **a, int n)	/* ~ and match() */
{
	Cell *x, *y;
	char *s, *t;
	int i;
	fa *pfa;
	int (*mf)(fa *, const char *) = match, mode = 0;

	if (n == MATCHFCN) {
		mf = pmatch;
		mode = 1;
	}
	x = execute(a[1]);	/* a[1] = target text */
	s = getsval(x);
	if (a[0] == 0)		/* a[1] == 0: already-compiled reg expr */
		i = (*mf)((fa *) a[2], s);
	else {
		y = execute(a[2]);	/* a[2] = regular expr */
		t = getsval(y);
		pfa = makedfa(t, mode);
		i = (*mf)(pfa, s);
		tempfree(y);
	}
	tempfree(x);
	if (n == MATCHFCN) {
		int start = patbeg - s + 1;
		if (patlen < 0)
			start = 0;
		setfval(rstartloc, (Awkfloat) start);
		setfval(rlengthloc, (Awkfloat) patlen);
		x = gettemp();
		x->tval = NUM;
		x->fval = start;
		return x;
	} else if ((n == MATCH && i == 1) || (n == NOTMATCH && i == 0))
		return(True);
	else
		return(False);
}


Cell *boolop(Node **a, int n)	/* a[0] || a[1], a[0] && a[1], !a[0] */
{
	Cell *x, *y;
	int i;

	x = execute(a[0]);
	i = istrue(x);
	tempfree(x);
	switch (n) {
	case BOR:
		if (i) return(True);
		y = execute(a[1]);
		i = istrue(y);
		tempfree(y);
		if (i) return(True);
		else return(False);
	case AND:
		if ( !i ) return(False);
		y = execute(a[1]);
		i = istrue(y);
		tempfree(y);
		if (i) return(True);
		else return(False);
	case NOT:
		if (i) return(False);
		else return(True);
	default:	/* can't happen */
		FATAL("unknown boolean operator %d", n);
	}
	return 0;	/*NOTREACHED*/
}

Cell *relop(Node **a, int n)	/* a[0 < a[1], etc. */
{
	int i;
	Cell *x, *y;
	Awkfloat j;

	x = execute(a[0]);
	y = execute(a[1]);
	if (x->tval&NUM && y->tval&NUM) {
		j = x->fval - y->fval;
		i = j<0? -1: (j>0? 1: 0);
	} else {
		i = strcmp(getsval(x), getsval(y));
	}
	tempfree(x);
	tempfree(y);
	switch (n) {
	case LT:	if (i<0) return(True);
			else return(False);
	case LE:	if (i<=0) return(True);
			else return(False);
	case NE:	if (i!=0) return(True);
			else return(False);
	case EQ:	if (i == 0) return(True);
			else return(False);
	case GE:	if (i>=0) return(True);
			else return(False);
	case GT:	if (i>0) return(True);
			else return(False);
	default:	/* can't happen */
		FATAL("unknown relational operator %d", n);
	}
	return 0;	/*NOTREACHED*/
}

void tfree(Cell *a)	/* free a tempcell */
{
	if (freeable(a)) {
		   dprintf( ("freeing %s %s %o\n", NN(a->nval), NN(a->sval), a->tval) );
		xfree(a->sval);
	}
	if (a == tmps)
		FATAL("tempcell list is curdled");
	a->cnext = tmps;
	tmps = a;
}

Cell *gettemp(void)	/* get a tempcell */
{	int i;
	Cell *x;

	if (!tmps) {
		tmps = (Cell *) calloc(100, sizeof(Cell));
		if (!tmps)
			FATAL("out of space for temporaries");
		for(i = 1; i < 100; i++)
			tmps[i-1].cnext = &tmps[i];
		tmps[i-1].cnext = 0;
	}
	x = tmps;
	tmps = x->cnext;
	*x = tempcell;
	return(x);
}

Cell *indirect(Node **a, int n)	/* $( a[0] ) */
{
	Awkfloat val;
	Cell *x;
	int m;
	char *s;

	x = execute(a[0]);
	val = getfval(x);	/* freebsd: defend against super large field numbers */
	if ((Awkfloat)INT_MAX < val)
		FATAL("trying to access out of range field %s", x->nval);
	m = (int) val;
	if (m == 0 && !is_number(s = getsval(x)))	/* suspicion! */
		FATAL("illegal field $(%s), name \"%s\"", s, x->nval);
		/* BUG: can x->nval ever be null??? */
	tempfree(x);
	x = fieldadr(m);
	x->ctype = OCELL;	/* BUG?  why are these needed? */
	x->csub = CFLD;
	return(x);
}

Cell *substr(Node **a, int nnn)		/* substr(a[0], a[1], a[2]) */
{
	int k, m, n;
	char *s;
	int temp;
	Cell *x, *y, *z = 0;

	x = execute(a[0]);
	y = execute(a[1]);
	if (a[2] != 0)
		z = execute(a[2]);
	s = getsval(x);
	k = strlen(s) + 1;
	if (k <= 1) {
		tempfree(x);
		tempfree(y);
		if (a[2] != 0) {
			tempfree(z);
		}
		x = gettemp();
		setsval(x, "");
		return(x);
	}
	m = (int) getfval(y);
	if (m <= 0)
		m = 1;
	else if (m > k)
		m = k;
	tempfree(y);
	if (a[2] != 0) {
		n = (int) getfval(z);
		tempfree(z);
	} else
		n = k - 1;
	if (n < 0)
		n = 0;
	else if (n > k - m)
		n = k - m;
	   dprintf( ("substr: m=%d, n=%d, s=%s\n", m, n, s) );
	y = gettemp();
	temp = s[n+m-1];	/* with thanks to John Linderman */
	s[n+m-1] = '\0';
	setsval(y, s + m - 1);
	s[n+m-1] = temp;
	tempfree(x);
	return(y);
}

Cell *sindex(Node **a, int nnn)		/* index(a[0], a[1]) */
{
	Cell *x, *y, *z;
	char *s1, *s2, *p1, *p2, *q;
	Awkfloat v = 0.0;

	x = execute(a[0]);
	s1 = getsval(x);
	y = execute(a[1]);
	s2 = getsval(y);

	z = gettemp();
	for (p1 = s1; *p1 != '\0'; p1++) {
		for (q=p1, p2=s2; *p2 != '\0' && *q == *p2; q++, p2++)
			;
		if (*p2 == '\0') {
			v = (Awkfloat) (p1 - s1 + 1);	/* origin 1 */
			break;
		}
	}
	tempfree(x);
	tempfree(y);
	setfval(z, v);
	return(z);
}

#define	MAXNUMSIZE	50

int format(char **pbuf, int *pbufsize, const char *s, Node *a)	/* printf-like conversions */
{
	char *fmt;
	char *p, *t;
	const char *os;
	Cell *x;
	int flag = 0, n;
	int fmtwd; /* format width */
	int fmtsz = recsize;
	char *buf = *pbuf;
	int bufsize = *pbufsize;

	os = s;
	p = buf;
	if ((fmt = (char *) malloc(fmtsz)) == NULL)
		FATAL("out of memory in format()");
	while (*s) {
		adjbuf(&buf, &bufsize, MAXNUMSIZE+1+p-buf, recsize, &p, "format1");
		if (*s != '%') {
			*p++ = *s++;
			continue;
		}
		if (*(s+1) == '%') {
			*p++ = '%';
			s += 2;
			continue;
		}
		/* have to be real careful in case this is a huge number, eg, %100000d */
		fmtwd = atoi(s+1);
		if (fmtwd < 0)
			fmtwd = -fmtwd;
		adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format2");
		for (t = fmt; (*t++ = *s) != '\0'; s++) {
			if (!adjbuf(&fmt, &fmtsz, MAXNUMSIZE+1+t-fmt, recsize, &t, "format3"))
				FATAL("format item %.30s... ran format() out of memory", os);
			if (isalpha((uschar)*s) && *s != 'l' && *s != 'h' && *s != 'L')
				break;	/* the ansi panoply */
			if (*s == '*') {
				if (a == NULL)
					FATAL("not enough args in printf(%s)", os);
				x = execute(a);
				a = a->nnext;
				snprintf(t-1, fmt + fmtsz - (t-1), "%d", fmtwd=(int) getfval(x));
				if (fmtwd < 0)
					fmtwd = -fmtwd;
				adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");
				t = fmt + strlen(fmt);
				tempfree(x);
			}
		}
		*t = '\0';
		if (fmtwd < 0)
			fmtwd = -fmtwd;
		adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format4");

		switch (*s) {
		case 'f': case 'e': case 'g': case 'E': case 'G':
			flag = 'f';
			break;
		case 'd': case 'i':
			flag = 'd';
			if(*(s-1) == 'l') break;
			*(t-1) = 'l';
			*t = 'd';
			*++t = '\0';
			break;
		case 'o': case 'x': case 'X': case 'u':
			flag = *(s-1) == 'l' ? 'd' : 'u';
			break;
		case 's':
			flag = 's';
			break;
		case 'c':
			flag = 'c';
			break;
		default:
			WARNING("weird printf conversion %s", fmt);
			flag = '?';
			break;
		}
		if (a == NULL)
			FATAL("not enough args in printf(%s)", os);
		x = execute(a);
		a = a->nnext;
		n = MAXNUMSIZE;
		if (fmtwd > n)
			n = fmtwd;
		adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, "format5");
		switch (flag) {
		case '?':	/* unknown, so dump it too */
			snprintf(p, buf + bufsize - p, "%s", fmt);
			t = getsval(x);
			n = strlen(t);
			if (fmtwd > n)
				n = fmtwd;
			adjbuf(&buf, &bufsize, 1+strlen(p)+n+p-buf, recsize, &p, "format6");
			p += strlen(p);
			snprintf(p, buf + bufsize - p, "%s", t);
			break;
		case 'f':	snprintf(p, buf + bufsize - p, fmt, getfval(x)); break;
		case 'd':	snprintf(p, buf + bufsize - p, fmt, (long) getfval(x)); break;
		case 'u':	snprintf(p, buf + bufsize - p, fmt, (int) getfval(x)); break;
		case 's':
			t = getsval(x);
			n = strlen(t);
			if (fmtwd > n)
				n = fmtwd;
			if (!adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, "format7"))
				FATAL("huge string/format (%d chars) in printf %.30s... ran format() out of memory", n, t);
			snprintf(p, buf + bufsize - p, fmt, t);
			break;
		case 'c':
			if (isnum(x)) {
				if ((int)getfval(x))
					snprintf(p, buf + bufsize - p, fmt, (int) getfval(x));
				else {
					*p++ = '\0'; /* explicit null byte */
					*p = '\0';   /* next output will start here */
				}
			} else
				snprintf(p, buf + bufsize - p, fmt, getsval(x)[0]);
			break;
		default:
			FATAL("can't happen: bad conversion %c in format()", flag);
		}
		tempfree(x);
		p += strlen(p);
		s++;
	}
	*p = '\0';
	free(fmt);
	for ( ; a; a = a->nnext)		/* evaluate any remaining args */
		execute(a);
	*pbuf = buf;
	*pbufsize = bufsize;
	return p - buf;
}

Cell *awksprintf(Node **a, int n)		/* sprintf(a[0]) */
{
	Cell *x;
	Node *y;
	char *buf;
	int bufsz=3*recsize;

	if ((buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of memory in awksprintf");
	y = a[0]->nnext;
	x = execute(a[0]);
	if (format(&buf, &bufsz, getsval(x), y) == -1)
		FATAL("sprintf string %.30s... too long.  can't happen.", buf);
	tempfree(x);
	x = gettemp();
	x->sval = buf;
	x->tval = STR;
	return(x);
}

Cell *awkprintf(Node **a, int n)		/* printf */
{	/* a[0] is list of args, starting with format string */
	/* a[1] is redirection operator, a[2] is redirection file */
	FILE *fp;
	Cell *x;
	Node *y;
	char *buf;
	int len;
	int bufsz=3*recsize;

	if ((buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of memory in awkprintf");
	y = a[0]->nnext;
	x = execute(a[0]);
	if ((len = format(&buf, &bufsz, getsval(x), y)) == -1)
		FATAL("printf string %.30s... too long.  can't happen.", buf);
	tempfree(x);
	if (a[1] == NULL) {
		/* fputs(buf, stdout); */
		fwrite(buf, len, 1, stdout);
		if (ferror(stdout))
			FATAL("write error on stdout");
	} else {
		fp = redirect(ptoi(a[1]), a[2]);
		/* fputs(buf, fp); */
		fwrite(buf, len, 1, fp);
		fflush(fp);
		if (ferror(fp))
			FATAL("write error on %s", filename(fp));
	}
	free(buf);
	return(True);
}

Cell *arith(Node **a, int n)	/* a[0] + a[1], etc.  also -a[0] */
{
	Awkfloat i, j = 0;
	double v;
	Cell *x, *y, *z;

	x = execute(a[0]);
	i = getfval(x);
	tempfree(x);
	if (n != UMINUS) {
		y = execute(a[1]);
		j = getfval(y);
		tempfree(y);
	}
	z = gettemp();
	switch (n) {
	case ADD:
		i += j;
		break;
	case MINUS:
		i -= j;
		break;
	case MULT:
		i *= j;
		break;
	case DIVIDE:
		if (j == 0)
			FATAL("division by zero");
		i /= j;
		break;
	case MOD:
		if (j == 0)
			FATAL("division by zero in mod");
		modf(i/j, &v);
		i = i - j * v;
		break;
	case UMINUS:
		i = -i;
		break;
	case POWER:
		if (j >= 0 && modf(j, &v) == 0.0)	/* pos integer exponent */
			i = ipow(i, (int) j);
		else
			i = errcheck(pow(i, j), "pow");
		break;
	default:	/* can't happen */
		FATAL("illegal arithmetic operator %d", n);
	}
	setfval(z, i);
	return(z);
}

double ipow(double x, int n)	/* x**n.  ought to be done by pow, but isn't always */
{
	double v;

	if (n <= 0)
		return 1;
	v = ipow(x, n/2);
	if (n % 2 == 0)
		return v * v;
	else
		return x * v * v;
}

Cell *incrdecr(Node **a, int n)		/* a[0]++, etc. */
{
	Cell *x, *z;
	int k;
	Awkfloat xf;

	x = execute(a[0]);
	xf = getfval(x);
	k = (n == PREINCR || n == POSTINCR) ? 1 : -1;
	if (n == PREINCR || n == PREDECR) {
		setfval(x, xf + k);
		return(x);
	}
	z = gettemp();
	setfval(z, xf);
	setfval(x, xf + k);
	tempfree(x);
	return(z);
}

Cell *assign(Node **a, int n)	/* a[0] = a[1], a[0] += a[1], etc. */
{		/* this is subtle; don't muck with it. */
	Cell *x, *y;
	Awkfloat xf, yf;
	double v;

	y = execute(a[1]);
	x = execute(a[0]);
	if (n == ASSIGN) {	/* ordinary assignment */
		if (x == y && !(x->tval & (FLD|REC)))	/* self-assignment: */
			;		/* leave alone unless it's a field */
		else if ((y->tval & (STR|NUM)) == (STR|NUM)) {
			setsval(x, getsval(y));
			x->fval = getfval(y);
			x->tval |= NUM;
		}
		else if (isstr(y))
			setsval(x, getsval(y));
		else if (isnum(y))
			setfval(x, getfval(y));
		else
			funnyvar(y, "read value of");
		tempfree(y);
		return(x);
	}
	xf = getfval(x);
	yf = getfval(y);
	switch (n) {
	case ADDEQ:
		xf += yf;
		break;
	case SUBEQ:
		xf -= yf;
		break;
	case MULTEQ:
		xf *= yf;
		break;
	case DIVEQ:
		if (yf == 0)
			FATAL("division by zero in /=");
		xf /= yf;
		break;
	case MODEQ:
		if (yf == 0)
			FATAL("division by zero in %%=");
		modf(xf/yf, &v);
		xf = xf - yf * v;
		break;
	case POWEQ:
		if (yf >= 0 && modf(yf, &v) == 0.0)	/* pos integer exponent */
			xf = ipow(xf, (int) yf);
		else
			xf = errcheck(pow(xf, yf), "pow");
		break;
	default:
		FATAL("illegal assignment operator %d", n);
		break;
	}
	tempfree(y);
	setfval(x, xf);
	return(x);
}

Cell *cat(Node **a, int q)	/* a[0] cat a[1] */
{
	Cell *x, *y, *z;
	int n1, n2;
	char *s;
	size_t len;

	x = execute(a[0]);
	y = execute(a[1]);
	getsval(x);
	getsval(y);
	n1 = strlen(x->sval);
	n2 = strlen(y->sval);
	len = n1 + n2 + 1;
	s = (char *) malloc(len);
	if (s == NULL)
		FATAL("out of space concatenating %.15s... and %.15s...",
			x->sval, y->sval);
	strlcpy(s, x->sval, len);
	strlcpy(s+n1, y->sval, len - n1);
	tempfree(x);
	tempfree(y);
	z = gettemp();
	z->sval = s;
	z->tval = STR;
	return(z);
}

Cell *pastat(Node **a, int n)	/* a[0] { a[1] } */
{
	Cell *x;

	if (a[0] == 0)
		x = execute(a[1]);
	else {
		x = execute(a[0]);
		if (istrue(x)) {
			tempfree(x);
			x = execute(a[1]);
		}
	}
	return x;
}

Cell *dopa2(Node **a, int n)	/* a[0], a[1] { a[2] } */
{
	Cell *x;
	int pair;

	pair = ptoi(a[3]);
	if (pairstack[pair] == 0) {
		x = execute(a[0]);
		if (istrue(x))
			pairstack[pair] = 1;
		tempfree(x);
	}
	if (pairstack[pair] == 1) {
		x = execute(a[1]);
		if (istrue(x))
			pairstack[pair] = 0;
		tempfree(x);
		x = execute(a[2]);
		return(x);
	}
	return(False);
}

Cell *split(Node **a, int nnn)	/* split(a[0], a[1], a[2]); a[3] is type */
{
	Cell *x = 0, *y, *ap;
	char *s;
	int sep;
	char *t, temp, num[50], *fs = 0;
	int n, tempstat, arg3type;

	y = execute(a[0]);	/* source string */
	s = getsval(y);
	arg3type = ptoi(a[3]);
	if (a[2] == 0)		/* fs string */
		fs = *FS;
	else if (arg3type == STRING) {	/* split(str,arr,"string") */
		x = execute(a[2]);
		fs = getsval(x);
	} else if (arg3type == REGEXPR)
		fs = "(regexpr)";	/* split(str,arr,/regexpr/) */
	else
		FATAL("illegal type of split");
	sep = *fs;
	ap = execute(a[1]);	/* array name */
	freesymtab(ap);
	   dprintf( ("split: s=|%s|, a=%s, sep=|%s|\n", s, NN(ap->nval), fs) );
	ap->tval &= ~STR;
	ap->tval |= ARR;
	ap->sval = (char *) makesymtab(NSYMTAB);

	n = 0;
        if (arg3type == REGEXPR && strlen((char*)((fa*)a[2])->restr) == 0) {
		/* split(s, a, //); have to arrange that it looks like empty sep */
		arg3type = 0;
		fs = "";
		sep = 0;
	}
	if (*s != '\0' && (strlen(fs) > 1 || arg3type == REGEXPR)) {	/* reg expr */
		fa *pfa;
		if (arg3type == REGEXPR) {	/* it's ready already */
			pfa = (fa *) a[2];
		} else {
			pfa = makedfa(fs, 1);
		}
		if (nematch(pfa,s)) {
			tempstat = pfa->initstat;
			pfa->initstat = 2;
			do {
				n++;
				snprintf(num, sizeof num, "%d", n);
				temp = *patbeg;
				*patbeg = '\0';
				if (is_number(s))
					setsymtab(num, s, atof(s), STR|NUM, (Array *) ap->sval);
				else
					setsymtab(num, s, 0.0, STR, (Array *) ap->sval);
				*patbeg = temp;
				s = patbeg + patlen;
				if (*(patbeg+patlen-1) == 0 || *s == 0) {
					n++;
					snprintf(num, sizeof num, "%d", n);
					setsymtab(num, "", 0.0, STR, (Array *) ap->sval);
					pfa->initstat = tempstat;
					goto spdone;
				}
			} while (nematch(pfa,s));
			pfa->initstat = tempstat; 	/* bwk: has to be here to reset */
							/* cf gsub and refldbld */
		}
		n++;
		snprintf(num, sizeof num, "%d", n);
		if (is_number(s))
			setsymtab(num, s, atof(s), STR|NUM, (Array *) ap->sval);
		else
			setsymtab(num, s, 0.0, STR, (Array *) ap->sval);
  spdone:
		pfa = NULL;
	} else if (sep == ' ') {
		for (n = 0; ; ) {
			while (*s == ' ' || *s == '\t' || *s == '\n')
				s++;
			if (*s == 0)
				break;
			n++;
			t = s;
			do
				s++;
			while (*s!=' ' && *s!='\t' && *s!='\n' && *s!='\0');
			temp = *s;
			*s = '\0';
			snprintf(num, sizeof num, "%d", n);
			if (is_number(t))
				setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
			else
				setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
			*s = temp;
			if (*s != 0)
				s++;
		}
	} else if (sep == 0) {	/* new: split(s, a, "") => 1 char/elem */
		for (n = 0; *s != 0; s++) {
			char buf[2];
			n++;
			snprintf(num, sizeof num, "%d", n);
			buf[0] = *s;
			buf[1] = 0;
			if (isdigit((uschar)buf[0]))
				setsymtab(num, buf, atof(buf), STR|NUM, (Array *) ap->sval);
			else
				setsymtab(num, buf, 0.0, STR, (Array *) ap->sval);
		}
	} else if (*s != 0) {
		for (;;) {
			n++;
			t = s;
			while (*s != sep && *s != '\n' && *s != '\0')
				s++;
			temp = *s;
			*s = '\0';
			snprintf(num, sizeof num, "%d", n);
			if (is_number(t))
				setsymtab(num, t, atof(t), STR|NUM, (Array *) ap->sval);
			else
				setsymtab(num, t, 0.0, STR, (Array *) ap->sval);
			*s = temp;
			if (*s++ == 0)
				break;
		}
	}
	tempfree(ap);
	tempfree(y);
	if (a[2] != 0 && arg3type == STRING) {
		tempfree(x);
	}
	x = gettemp();
	x->tval = NUM;
	x->fval = n;
	return(x);
}

Cell *condexpr(Node **a, int n)	/* a[0] ? a[1] : a[2] */
{
	Cell *x;

	x = execute(a[0]);
	if (istrue(x)) {
		tempfree(x);
		x = execute(a[1]);
	} else {
		tempfree(x);
		x = execute(a[2]);
	}
	return(x);
}

Cell *ifstat(Node **a, int n)	/* if (a[0]) a[1]; else a[2] */
{
	Cell *x;

	x = execute(a[0]);
	if (istrue(x)) {
		tempfree(x);
		x = execute(a[1]);
	} else if (a[2] != 0) {
		tempfree(x);
		x = execute(a[2]);
	}
	return(x);
}

Cell *whilestat(Node **a, int n)	/* while (a[0]) a[1] */
{
	Cell *x;

	for (;;) {
		x = execute(a[0]);
		if (!istrue(x))
			return(x);
		tempfree(x);
		x = execute(a[1]);
		if (isbreak(x)) {
			x = True;
			return(x);
		}
		if (isnext(x) || isexit(x) || isret(x))
			return(x);
		tempfree(x);
	}
}

Cell *dostat(Node **a, int n)	/* do a[0]; while(a[1]) */
{
	Cell *x;

	for (;;) {
		x = execute(a[0]);
		if (isbreak(x))
			return True;
		if (isnext(x) || isexit(x) || isret(x))
			return(x);
		tempfree(x);
		x = execute(a[1]);
		if (!istrue(x))
			return(x);
		tempfree(x);
	}
}

Cell *forstat(Node **a, int n)	/* for (a[0]; a[1]; a[2]) a[3] */
{
	Cell *x;

	x = execute(a[0]);
	tempfree(x);
	for (;;) {
		if (a[1]!=0) {
			x = execute(a[1]);
			if (!istrue(x)) return(x);
			else tempfree(x);
		}
		x = execute(a[3]);
		if (isbreak(x))		/* turn off break */
			return True;
		if (isnext(x) || isexit(x) || isret(x))
			return(x);
		tempfree(x);
		x = execute(a[2]);
		tempfree(x);
	}
}

Cell *instat(Node **a, int n)	/* for (a[0] in a[1]) a[2] */
{
	Cell *x, *vp, *arrayp, *cp, *ncp;
	Array *tp;
	int i;

	vp = execute(a[0]);
	arrayp = execute(a[1]);
	if (!isarr(arrayp)) {
		return True;
	}
	tp = (Array *) arrayp->sval;
	tempfree(arrayp);
	for (i = 0; i < tp->size; i++) {	/* this routine knows too much */
		for (cp = tp->tab[i]; cp != NULL; cp = ncp) {
			setsval(vp, cp->nval);
			ncp = cp->cnext;
			x = execute(a[2]);
			if (isbreak(x)) {
				tempfree(vp);
				return True;
			}
			if (isnext(x) || isexit(x) || isret(x)) {
				tempfree(vp);
				return(x);
			}
			tempfree(x);
		}
	}
	return True;
}

Cell *bltin(Node **a, int n)	/* builtin functions. a[0] is type, a[1] is arg list */
{
	Cell *x, *y;
	Awkfloat u;
	int t;
	Awkfloat tmp;
	char *p, *buf;
	Node *nextarg;
	FILE *fp;

	t = ptoi(a[0]);
	x = execute(a[1]);
	nextarg = a[1]->nnext;
	switch (t) {
	case FLENGTH:
		if (isarr(x))
			u = ((Array *) x->sval)->nelem;	/* GROT.  should be function*/
		else
			u = strlen(getsval(x));
		break;
	case FLOG:
		u = errcheck(log(getfval(x)), "log"); break;
	case FINT:
		modf(getfval(x), &u); break;
	case FEXP:
		u = errcheck(exp(getfval(x)), "exp"); break;
	case FSQRT:
		u = errcheck(sqrt(getfval(x)), "sqrt"); break;
	case FSIN:
		u = sin(getfval(x)); break;
	case FCOS:
		u = cos(getfval(x)); break;
	case FATAN:
		if (nextarg == 0) {
			WARNING("atan2 requires two arguments; returning 1.0");
			u = 1.0;
		} else {
			y = execute(a[1]->nnext);
			u = atan2(getfval(x), getfval(y));
			tempfree(y);
			nextarg = nextarg->nnext;
		}
		break;
	case FCOMPL:
		u = ~((int)getfval(x));
		break;
	case FAND:
		if (nextarg == 0) {
			WARNING("and requires two arguments; returning 0");
			u = 0;
			break;
		}
		y = execute(a[1]->nnext);
		u = ((int)getfval(x)) & ((int)getfval(y));
		tempfree(y);
		nextarg = nextarg->nnext;
		break;
	case FFOR:
		if (nextarg == 0) {
			WARNING("or requires two arguments; returning 0");
			u = 0;
			break;
		}
		y = execute(a[1]->nnext);
		u = ((int)getfval(x)) | ((int)getfval(y));
		tempfree(y);
		nextarg = nextarg->nnext;
		break;
	case FXOR:
		if (nextarg == 0) {
			WARNING("xor requires two arguments; returning 0");
			u = 0;
			break;
		}
		y = execute(a[1]->nnext);
		u = ((int)getfval(x)) ^ ((int)getfval(y));
		tempfree(y);
		nextarg = nextarg->nnext;
		break;
	case FLSHIFT:
		if (nextarg == 0) {
			WARNING("lshift requires two arguments; returning 0");
			u = 0;
			break;
		}
		y = execute(a[1]->nnext);
		u = ((int)getfval(x)) << ((int)getfval(y));
		tempfree(y);
		nextarg = nextarg->nnext;
		break;
	case FRSHIFT:
		if (nextarg == 0) {
			WARNING("rshift requires two arguments; returning 0");
			u = 0;
			break;
		}
		y = execute(a[1]->nnext);
		u = ((int)getfval(x)) >> ((int)getfval(y));
		tempfree(y);
		nextarg = nextarg->nnext;
		break;
	case FSYSTEM:
		fflush(stdout);		/* in case something is buffered already */
		u = (Awkfloat) system(getsval(x)) / 256;   /* 256 is unix-dep */
		break;
	case FRAND:
		u = (Awkfloat) (random() & RAND_MAX) / ((u_int)RAND_MAX + 1);
		break;
	case FSRAND:
		if (isrec(x)) {		/* no argument provided */
			u = time(NULL);
			tmp = u;
			srandom((unsigned int) u);
		} else {
			u = getfval(x);
			tmp = u;
			srandom_deterministic((unsigned int) u);
		}
		u = srand_seed;
		srand_seed = tmp;
		break;
	case FTOUPPER:
	case FTOLOWER:
		buf = tostring(getsval(x));
		if (t == FTOUPPER) {
			for (p = buf; *p; p++)
				if (islower((uschar) *p))
					*p = toupper((uschar)*p);
		} else {
			for (p = buf; *p; p++)
				if (isupper((uschar) *p))
					*p = tolower((uschar)*p);
		}
		tempfree(x);
		x = gettemp();
		setsval(x, buf);
		free(buf);
		return x;
	case FFLUSH:
		if (isrec(x) || strlen(getsval(x)) == 0) {
			flush_all();	/* fflush() or fflush("") -> all */
			u = 0;
		} else if ((fp = openfile(FFLUSH, getsval(x))) == NULL)
			u = EOF;
		else
			u = fflush(fp);
		break;
	default:	/* can't happen */
		FATAL("illegal function type %d", t);
		break;
	}
	tempfree(x);
	x = gettemp();
	setfval(x, u);
	if (nextarg != 0) {
		WARNING("warning: function has too many arguments");
		for ( ; nextarg; nextarg = nextarg->nnext)
			execute(nextarg);
	}
	return(x);
}

Cell *printstat(Node **a, int n)	/* print a[0] */
{
	Node *x;
	Cell *y;
	FILE *fp;

	if (a[1] == 0)	/* a[1] is redirection operator, a[2] is file */
		fp = stdout;
	else
		fp = redirect(ptoi(a[1]), a[2]);
	for (x = a[0]; x != NULL; x = x->nnext) {
		y = execute(x);
		fputs(getpssval(y), fp);
		tempfree(y);
		if (x->nnext == NULL)
			fputs(*ORS, fp);
		else
			fputs(*OFS, fp);
	}
	if (a[1] != 0)
		fflush(fp);
	if (ferror(fp))
		FATAL("write error on %s", filename(fp));
	return(True);
}

Cell *nullproc(Node **a, int n)
{
	n = n;
	a = a;
	return 0;
}


FILE *redirect(int a, Node *b)	/* set up all i/o redirections */
{
	FILE *fp;
	Cell *x;
	char *fname;

	x = execute(b);
	fname = getsval(x);
	fp = openfile(a, fname);
	if (fp == NULL)
		FATAL("can't open file %s", fname);
	tempfree(x);
	return fp;
}

struct files {
	FILE	*fp;
	const char	*fname;
	int	mode;	/* '|', 'a', 'w' => LE/LT, GT */
} *files;

int nfiles;

void stdinit(void)	/* in case stdin, etc., are not constants */
{
	nfiles = FOPEN_MAX;
	files = calloc(nfiles, sizeof(*files));
	if (files == NULL)
		FATAL("can't allocate file memory for %u files", nfiles);
        files[0].fp = stdin;
	files[0].fname = "/dev/stdin";
	files[0].mode = LT;
        files[1].fp = stdout;
	files[1].fname = "/dev/stdout";
	files[1].mode = GT;
        files[2].fp = stderr;
	files[2].fname = "/dev/stderr";
	files[2].mode = GT;
}

FILE *openfile(int a, const char *us)
{
	const char *s = us;
	int i, m;
	FILE *fp = 0;

	if (*s == '\0')
		FATAL("null file name in print or getline");
	for (i=0; i < nfiles; i++)
		if (files[i].fname && strcmp(s, files[i].fname) == 0) {
			if (a == files[i].mode || (a==APPEND && files[i].mode==GT))
				return files[i].fp;
			if (a == FFLUSH)
				return files[i].fp;
		}
	if (a == FFLUSH)	/* didn't find it, so don't create it! */
		return NULL;

	for (i=0; i < nfiles; i++)
		if (files[i].fp == 0)
			break;
	if (i >= nfiles) {
		struct files *nf;
		int nnf = nfiles + FOPEN_MAX;
		nf = reallocarray(files, nnf, sizeof(*nf));
		if (nf == NULL)
			FATAL("cannot grow files for %s and %d files", s, nnf);
		memset(&nf[nfiles], 0, FOPEN_MAX * sizeof(*nf));
		nfiles = nnf;
		files = nf;
	}
	fflush(stdout);	/* force a semblance of order */
	m = a;
	if (a == GT) {
		fp = fopen(s, "w");
	} else if (a == APPEND) {
		fp = fopen(s, "a");
		m = GT;	/* so can mix > and >> */
	} else if (a == '|') {	/* output pipe */
		fp = popen(s, "w");
	} else if (a == LE) {	/* input pipe */
		fp = popen(s, "r");
	} else if (a == LT) {	/* getline <file */
		fp = strcmp(s, "-") == 0 ? stdin : fopen(s, "r");	/* "-" is stdin */
	} else	/* can't happen */
		FATAL("illegal redirection %d", a);
	if (fp != NULL) {
		files[i].fname = tostring(s);
		files[i].fp = fp;
		files[i].mode = m;
	}
	return fp;
}

const char *filename(FILE *fp)
{
	int i;

	for (i = 0; i < nfiles; i++)
		if (fp == files[i].fp)
			return files[i].fname;
	return "???";
}

Cell *closefile(Node **a, int n)
{
	Cell *x;
	int i, stat;

	n = n;
	x = execute(a[0]);
	getsval(x);
	stat = -1;
	for (i = 0; i < nfiles; i++) {
		if (files[i].fname && strcmp(x->sval, files[i].fname) == 0) {
			if (ferror(files[i].fp))
				WARNING( "i/o error occurred on %s", files[i].fname );
			if (files[i].mode == '|' || files[i].mode == LE)
				stat = pclose(files[i].fp);
			else
				stat = fclose(files[i].fp);
			if (stat == EOF)
				WARNING( "i/o error occurred closing %s", files[i].fname );
			if (i > 2)	/* don't do /dev/std... */
				xfree(files[i].fname);
			files[i].fname = NULL;	/* watch out for ref thru this */
			files[i].fp = NULL;
		}
	}
	tempfree(x);
	x = gettemp();
	setfval(x, (Awkfloat) stat);
	return(x);
}

void closeall(void)
{
	int i, stat;

	for (i = 0; i < FOPEN_MAX; i++) {
		if (files[i].fp) {
			if (ferror(files[i].fp))
				WARNING( "i/o error occurred on %s", files[i].fname );
			if (files[i].mode == '|' || files[i].mode == LE)
				stat = pclose(files[i].fp);
			else
				stat = fclose(files[i].fp);
			if (stat == EOF)
				WARNING( "i/o error occurred while closing %s", files[i].fname );
		}
	}
}

void flush_all(void)
{
	int i;

	for (i = 0; i < nfiles; i++)
		if (files[i].fp)
			fflush(files[i].fp);
}

void backsub(char **pb_ptr, char **sptr_ptr);

Cell *sub(Node **a, int nnn)	/* substitute command */
{
	char *sptr, *pb, *q;
	Cell *x, *y, *result;
	char *t, *buf;
	fa *pfa;
	int bufsz = recsize;

	if ((buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of memory in sub");
	x = execute(a[3]);	/* target string */
	t = getsval(x);
	if (a[0] == 0)		/* 0 => a[1] is already-compiled regexpr */
		pfa = (fa *) a[1];	/* regular expression */
	else {
		y = execute(a[1]);
		pfa = makedfa(getsval(y), 1);
		tempfree(y);
	}
	y = execute(a[2]);	/* replacement string */
	result = False;
	if (pmatch(pfa, t)) {
		sptr = t;
		adjbuf(&buf, &bufsz, 1+patbeg-sptr, recsize, 0, "sub");
		pb = buf;
		while (sptr < patbeg)
			*pb++ = *sptr++;
		sptr = getsval(y);
		while (*sptr != 0) {
			adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "sub");
			if (*sptr == '\\') {
				backsub(&pb, &sptr);
			} else if (*sptr == '&') {
				sptr++;
				adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "sub");
				for (q = patbeg; q < patbeg+patlen; )
					*pb++ = *q++;
			} else
				*pb++ = *sptr++;
		}
		*pb = '\0';
		if (pb > buf + bufsz)
			FATAL("sub result1 %.30s too big; can't happen", buf);
		sptr = patbeg + patlen;
		if ((patlen == 0 && *patbeg) || (patlen && *(sptr-1))) {
			adjbuf(&buf, &bufsz, 1+strlen(sptr)+pb-buf, 0, &pb, "sub");
			while ((*pb++ = *sptr++) != 0)
				;
		}
		if (pb > buf + bufsz)
			FATAL("sub result2 %.30s too big; can't happen", buf);
		setsval(x, buf);	/* BUG: should be able to avoid copy */
		result = True;
	}
	tempfree(x);
	tempfree(y);
	free(buf);
	return result;
}

Cell *gsub(Node **a, int nnn)	/* global substitute */
{
	Cell *x, *y;
	char *rptr, *sptr, *t, *pb, *q;
	char *buf;
	fa *pfa;
	int mflag, tempstat, num;
	int bufsz = recsize;

	if ((buf = (char *) malloc(bufsz)) == NULL)
		FATAL("out of memory in gsub");
	mflag = 0;	/* if mflag == 0, can replace empty string */
	num = 0;
	x = execute(a[3]);	/* target string */
	t = getsval(x);
	if (a[0] == 0)		/* 0 => a[1] is already-compiled regexpr */
		pfa = (fa *) a[1];	/* regular expression */
	else {
		y = execute(a[1]);
		pfa = makedfa(getsval(y), 1);
		tempfree(y);
	}
	y = execute(a[2]);	/* replacement string */
	if (pmatch(pfa, t)) {
		tempstat = pfa->initstat;
		pfa->initstat = 2;
		pb = buf;
		rptr = getsval(y);
		do {
			if (patlen == 0 && *patbeg != 0) {	/* matched empty string */
				if (mflag == 0) {	/* can replace empty */
					num++;
					sptr = rptr;
					while (*sptr != 0) {
						adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "gsub");
						if (*sptr == '\\') {
							backsub(&pb, &sptr);
						} else if (*sptr == '&') {
							sptr++;
							adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "gsub");
							for (q = patbeg; q < patbeg+patlen; )
								*pb++ = *q++;
						} else
							*pb++ = *sptr++;
					}
				}
				if (*t == 0)	/* at end */
					goto done;
				adjbuf(&buf, &bufsz, 2+pb-buf, recsize, &pb, "gsub");
				*pb++ = *t++;
				if (pb > buf + bufsz)	/* BUG: not sure of this test */
					FATAL("gsub result0 %.30s too big; can't happen", buf);
				mflag = 0;
			}
			else {	/* matched nonempty string */
				num++;
				sptr = t;
				adjbuf(&buf, &bufsz, 1+(patbeg-sptr)+pb-buf, recsize, &pb, "gsub");
				while (sptr < patbeg)
					*pb++ = *sptr++;
				sptr = rptr;
				while (*sptr != 0) {
					adjbuf(&buf, &bufsz, 5+pb-buf, recsize, &pb, "gsub");
					if (*sptr == '\\') {
						backsub(&pb, &sptr);
					} else if (*sptr == '&') {
						sptr++;
						adjbuf(&buf, &bufsz, 1+patlen+pb-buf, recsize, &pb, "gsub");
						for (q = patbeg; q < patbeg+patlen; )
							*pb++ = *q++;
					} else
						*pb++ = *sptr++;
				}
				t = patbeg + patlen;
				if (patlen == 0 || *t == 0 || *(t-1) == 0)
					goto done;
				if (pb > buf + bufsz)
					FATAL("gsub result1 %.30s too big; can't happen", buf);
				mflag = 1;
			}
		} while (pmatch(pfa,t));
		sptr = t;
		adjbuf(&buf, &bufsz, 1+strlen(sptr)+pb-buf, 0, &pb, "gsub");
		while ((*pb++ = *sptr++) != 0)
			;
	done:	if (pb < buf + bufsz)
			*pb = '\0';
		else if (*(pb-1) != '\0')
			FATAL("gsub result2 %.30s truncated; can't happen", buf);
		setsval(x, buf);	/* BUG: should be able to avoid copy + free */
		pfa->initstat = tempstat;
	}
	tempfree(x);
	tempfree(y);
	x = gettemp();
	x->tval = NUM;
	x->fval = num;
	free(buf);
	return(x);
}

void backsub(char **pb_ptr, char **sptr_ptr)	/* handle \\& variations */
{						/* sptr[0] == '\\' */
	char *pb = *pb_ptr, *sptr = *sptr_ptr;

	if (sptr[1] == '\\') {
		if (sptr[2] == '\\' && sptr[3] == '&') { /* \\\& -> \& */
			*pb++ = '\\';
			*pb++ = '&';
			sptr += 4;
		} else if (sptr[2] == '&') {	/* \\& -> \ + matched */
			*pb++ = '\\';
			sptr += 2;
		} else {			/* \\x -> \\x */
			*pb++ = *sptr++;
			*pb++ = *sptr++;
		}
	} else if (sptr[1] == '&') {	/* literal & */
		sptr++;
		*pb++ = *sptr++;
	} else				/* literal \ */
		*pb++ = *sptr++;

	*pb_ptr = pb;
	*sptr_ptr = sptr;
}
@


1.40
log
@Remove modulo bias in random number generator.

Diff from Matthew Martin, rewieved by deraadt@@ and me.

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.39 2015/09/05 22:07:10 deraadt Exp $	*/
d1548 1
a1548 1
			WARNING("or requires two arguments; returning 0");
d1559 1
a1559 1
			WARNING("or requires two arguments; returning 0");
d1570 1
a1570 1
			WARNING("or requires two arguments; returning 0");
@


1.39
log
@When rand() was made fully random, the return value of srand() was
also affected incorrectly.  Noticed by Stephane Chazelas.  This reverts
the return value of srand() to the old (not very useful) behaviour.
This also allows toggling rand() to strong/weak based upon whether
srand() is called without/with an argument.
Long discussion and work with millert
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.38 2014/12/19 19:28:55 deraadt Exp $	*/
d1584 1
a1584 1
		u = (Awkfloat) (random() % RAND_MAX) / RAND_MAX;
@


1.38
log
@Use reallocarray() where suitable
ok millert doug
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.38 2014/12/19 19:25:51 deraadt Exp $	*/
d1587 5
a1591 1
		if (!isrec(x)) {
a1594 2
			u = srand_seed;
			srand_seed = tmp;
d1596 2
@


1.37
log
@Use srandom_deterministic() if a seed is supplied, thereby switching the
subsystem out of strong random mode.  No effective change from what we've
been doing for a while.  Result is it becomes 1 line of code.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.36 2014/12/01 03:18:50 millert Exp $	*/
d273 2
a274 2
		frame = (struct Frame *)
			realloc((char *) frame, (nframe += 100) * sizeof(struct Frame));
@


1.36
log
@Fix %c for floating values that become 0 when coerced to int.
From Jeremy Devenport
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.35 2014/10/11 03:07:29 doug Exp $	*/
a68 1
int use_srandom;
d1584 1
a1584 4
		if (use_srandom)
			u = (Awkfloat) (random() % RAND_MAX) / RAND_MAX;
		else
			u = (Awkfloat)arc4random() / 0xffffffff;
d1587 1
a1587 4
		if (isrec(x))	/* no argument provided, want arc4random() */
			use_srandom = 0;
		else {
			use_srandom = 1;
d1590 1
a1590 1
			srandom((unsigned int) u);
@


1.35
log
@Userland reallocarray() audit.

Avoid potential integer overflow in the size argument of malloc() and
realloc() by using reallocarray() to avoid unchecked multiplication.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.34 2013/09/29 15:42:25 deraadt Exp $	*/
d924 1
a924 1
				if (getfval(x))
@


1.34
log
@use a more clearly named variable for the srandom case in the code
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.33 2011/09/28 19:27:18 millert Exp $	*/
d1741 1
a1741 1
		nf = realloc(files, nnf * sizeof(*nf));
@


1.33
log
@Update awk to Aug 10, 2011 version; naddy@@ reports no ports problems
from the update.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.32 2011/04/20 22:28:39 millert Exp $	*/
d69 1
a69 1
int use_arc4 = 1;
d1585 3
a1587 1
		if (use_arc4)
a1588 2
		else
			u = (Awkfloat) (random() % RAND_MAX) / RAND_MAX;
d1592 1
a1592 1
			use_arc4 = 1;
d1594 1
a1594 1
			use_arc4 = 0;
@


1.32
log
@Stash the old seed when srand() is called and use it as the return
value as per POSIX and the fine manual.  Fix sent upstream to bwk.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.31 2010/06/13 17:58:19 millert Exp $	*/
d71 1
d1247 6
d1484 1
a1487 1
	static Awkfloat old_seed = 1;
a1590 1
		u = old_seed;
a1593 2
			old_seed = getfval(x);
			srandom((unsigned int) old_seed);
d1595 5
d1696 3
a1698 5
} files[FOPEN_MAX] ={
	{ NULL,  "/dev/stdin",  LT },	/* watch out: don't free this! */
	{ NULL, "/dev/stdout", GT },
	{ NULL, "/dev/stderr", GT }
};
d1702 13
a1714 3
	files[0].fp = stdin;
	files[1].fp = stdout;
	files[2].fp = stderr;
d1725 1
a1725 1
	for (i=0; i < FOPEN_MAX; i++)
d1735 1
a1735 1
	for (i=0; i < FOPEN_MAX; i++)
d1738 10
a1747 2
	if (i >= FOPEN_MAX)
		FATAL("%s makes too many open files", s);
d1775 1
a1775 1
	for (i = 0; i < FOPEN_MAX; i++)
d1790 1
a1790 1
	for (i = 0; i < FOPEN_MAX; i++) {
d1834 1
a1834 1
	for (i = 0; i < FOPEN_MAX; i++)
@


1.31
log
@Update awk to May 23, 2010 version.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.30 2008/10/06 20:38:33 millert Exp $	*/
d1480 1
d1584 1
d1588 2
a1589 2
			u = getfval(x);
			srandom((unsigned int) u);
@


1.30
log
@Update awk to version 20071023; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.29 2008/06/04 14:04:42 pyr Exp $	*/
d394 1
a394 1
Cell *getline(Node **a, int n)	/* get next line from specific input */
d1170 1
a1174 1
	tempfree(x);
d1959 4
a1962 3
	done:	if (pb > buf + bufsz)
			FATAL("gsub result2 %.30s too big; can't happen", buf);
		*pb = '\0';
@


1.29
log
@Extend awk with bitwise operations. This is an extension to the awk
spec and documented as such, but comes in handy from time to time.
The prototypes make it compatible with a similar GNU awk extension.

ok millert@@, enthusiasm from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.28 2008/04/13 00:22:17 djm Exp $	*/
d53 14
a66 13
#ifdef _NFILE
#ifndef FOPEN_MAX
#define FOPEN_MAX _NFILE
#endif
#endif

#ifndef	FOPEN_MAX
#define	FOPEN_MAX	40	/* max number of open files */
#endif

#ifndef RAND_MAX
#define RAND_MAX	32767	/* all that ansi guarantees */
#endif
d119 1
d471 1
a471 1
		if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
d518 1
a518 1
			if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
d557 1
a557 1
		if (!adjbuf(&buf, &bufsz, strlen(buf)+strlen(s)+nsub+1, recsize, 0, 0))
d827 1
a827 1
		adjbuf(&buf, &bufsize, MAXNUMSIZE+1+p-buf, recsize, &p, "format");
d841 1
a841 1
		adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");
d843 1
a843 1
			if (!adjbuf(&fmt, &fmtsz, MAXNUMSIZE+1+t-fmt, recsize, &t, 0))
d863 1
a863 1
		adjbuf(&buf, &bufsize, fmtwd+1+p-buf, recsize, &p, "format");
d897 1
a897 1
		adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, "format");
d905 1
a905 1
			adjbuf(&buf, &bufsize, 1+strlen(p)+n+p-buf, recsize, &p, "format");
d917 1
a917 1
			if (!adjbuf(&buf, &bufsize, 1+n+p-buf, recsize, &p, 0))
@


1.28
log
@Use arc4random_buf() when requesting more than a single word of output

Use arc4random_uniform() when the desired random number upper bound
is not a power of two

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.27 2008/02/27 17:19:34 deraadt Exp $	*/
d1511 58
@


1.27
log
@fail nicely instead of crashing for format strings containing '*',
without a matching argument following
from Jukka Salmi
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.26 2004/12/30 02:08:35 millert Exp $	*/
d1518 1
a1518 1
			u = (Awkfloat) (arc4random() % RAND_MAX) / RAND_MAX;
@


1.26
log
@stdinit() and flush_all() are prototyped globally, no need to do it
inside functions that use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.25 2004/12/30 01:52:48 millert Exp $	*/
d846 2
@


1.25
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.24 2004/05/08 22:08:51 millert Exp $	*/
a96 1

a132 2
	extern void stdinit(void);

a1475 1
	void flush_all(void);
@


1.24
log
@Use arc4random() unless the user specifies a specific seed, in which
case, call srandom() and use random().  Avoid using rand() because
it does not produce good random numbers.  Based on a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.23 2003/08/06 21:08:07 millert Exp $	*/
d30 1
d229 1
d307 4
d316 3
a318 1
	tempfree(y);		/* this can free twice! */
d715 1
d721 4
a724 1
	m = (int) getfval(x);
d1245 1
a1245 1
	if ((*s != '\0' && strlen(fs) > 1) || arg3type == REGEXPR) {	/* reg expr */
d1274 2
d1539 1
a1539 1
					*p = toupper(*p);
d1543 1
a1543 1
					*p = tolower(*p);
@


1.23
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.22 2003/07/02 21:04:09 deraadt Exp $	*/
d67 1
d1505 4
a1508 2
		/* in principle, rand() returns something in 0..RAND_MAX */
		u = (Awkfloat) (rand() % RAND_MAX) / RAND_MAX;
d1511 3
a1513 3
		if (isrec(x))	/* no argument provided */
			u = time((time_t *)0);
		else
d1515 3
a1517 1
		srand((unsigned int) u);
@


1.22
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.21 2003/04/28 03:07:40 tedu Exp $	*/
d1789 1
a1789 1
		result = True;;
@


1.21
log
@string cleaning.  ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.20 2003/04/06 06:12:01 pvalchev Exp $	*/
d91 4
@


1.20
log
@more string business; millert ok and suggestion for strdup
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.19 2003/04/04 00:42:34 deraadt Exp $	*/
d834 1
a834 1
				sprintf(t-1, "%d", fmtwd=(int) getfval(x));
d881 2
a882 1
		case '?':	sprintf(p, "%s", fmt);	/* unknown, so dump it too */
d889 1
a889 1
			sprintf(p, "%s", t);
d891 3
a893 3
		case 'f':	sprintf(p, fmt, getfval(x)); break;
		case 'd':	sprintf(p, fmt, (long) getfval(x)); break;
		case 'u':	sprintf(p, fmt, (int) getfval(x)); break;
d901 1
a901 1
			sprintf(p, fmt, t);
d906 1
a906 1
					sprintf(p, fmt, (int) getfval(x));
d912 1
a912 1
				sprintf(p, fmt, getsval(x)[0]);
d1137 1
d1145 2
a1146 1
	s = (char *) malloc(n1 + n2 + 1);
d1150 2
a1151 2
	strcpy(s, x->sval);
	strcpy(s+n1, y->sval);
@


1.19
log
@snprintf & strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.18 2002/12/19 21:24:28 millert Exp $	*/
d461 1
a461 1
		strcat(buf, s);
d463 1
a463 1
			strcat(buf, *SUBSEP);
d508 1
a508 1
			strcat(buf, s);	
d510 1
a510 1
				strcat(buf, *SUBSEP);
d547 1
a547 1
		strcat(buf, s);
d550 1
a550 1
			strcat(buf, *SUBSEP);
@


1.18
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.17 2001/09/08 00:12:40 millert Exp $	*/
d1237 1
a1237 1
				sprintf(num, "%d", n);
d1248 1
a1248 1
					sprintf(num, "%d", n);
d1256 1
a1256 1
		sprintf(num, "%d", n);
d1276 1
a1276 1
			sprintf(num, "%d", n);
d1289 1
a1289 1
			sprintf(num, "%d", n);
d1305 1
a1305 1
			sprintf(num, "%d", n);
@


1.17
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.16 1999/12/08 23:09:46 millert Exp $	*/
d94 1
a94 1
	char *whatrtn)
d251 1
a251 1
			   i, y->nval, y->fval, isarr(y) ? "(array)" : y->sval, y->tval) );
d467 1
a467 1
		   dprintf( ("making %s into an array\n", x->nval) );
d568 1
a568 1
	int (*mf)(fa *, char *) = match, mode = 0;
d673 1
a673 1
		   dprintf( ("freeing %s %s %o\n", a->nval, a->sval, a->tval) );
d794 1
a794 1
int format(char **pbuf, int *pbufsize, char *s, Node *a)	/* printf-like conversions */
d797 2
a798 1
	char *p, *t, *os;
d849 1
a849 1
			flag = 1;
d852 1
a852 1
			flag = 2;
d859 1
a859 1
			flag = *(s-1) == 'l' ? 2 : 3;
d862 1
a862 1
			flag = 4;
d865 1
a865 1
			flag = 5;
d869 1
a869 1
			flag = 0;
d881 1
a881 1
		case 0:	sprintf(p, "%s", fmt);	/* unknown, so dump it too */
d890 4
a893 4
		case 1:	sprintf(p, fmt, getfval(x)); break;
		case 2:	sprintf(p, fmt, (long) getfval(x)); break;
		case 3:	sprintf(p, fmt, (int) getfval(x)); break;
		case 4:
d902 1
a902 1
		case 5:
d906 4
a909 2
				else
					*p++ = '\0';
d913 2
d1219 1
a1219 1
	   dprintf( ("split: s=|%s|, a=%s, sep=|%s|\n", s, ap->nval, fs) );
d1457 1
d1464 5
a1468 1
		u = strlen(getsval(x)); break;
d1525 4
a1528 1
		if ((fp = openfile(FFLUSH, getsval(x))) == NULL)
d1560 1
a1560 1
		fputs(getsval(y), fp);
d1599 1
a1599 1
	char	*fname;
d1614 1
a1614 1
FILE *openfile(int a, char *us)
d1616 1
a1616 1
	char *s = us;
d1660 1
a1660 1
char *filename(FILE *fp)
d1717 9
@


1.16
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.15 1999/04/20 17:31:30 millert Exp $	*/
d303 1
a303 1
	if (isexit(y) || isnext(y) || isnextfile(y))
d319 2
a320 1
	y->sval = x->sval ? tostring(x->sval) : NULL;
d734 1
a734 1
		if (a[2] != 0)
d736 1
d828 1
a828 1
			if (isalpha(*s) && *s != 'l' && *s != 'h' && *s != 'L')
d1287 1
a1287 1
			if (isdigit(buf[0]))
d1312 1
a1312 1
	if (a[2] != 0 && arg3type == STRING)
d1314 1
d1379 1
a1379 1
		if (isnext(x) || isnextfile(x) || isexit(x) || isret(x))
d1502 1
a1502 1
				if (islower(*p))
d1506 1
a1506 1
				if (isupper(*p))
d1665 2
a1666 1
	for (i = 0; i < FOPEN_MAX; i++)
d1681 1
d1683 3
a1685 1
	return(True);
d1692 1
a1692 1
	for (i = 0; i < FOPEN_MAX; i++)
d1703 1
@


1.15
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.14 1999/04/18 17:06:31 millert Exp $	*/
d44 2
a45 2
		ERROR "bad csub %d in Cell %d %s",
			p->csub, p->ctype, p->sval WARNING;
d115 1
a115 1
				ERROR "out of memory in %s", whatrtn FATAL;
d128 3
d154 1
a154 1
			ERROR "illegal statement" FATAL;
d183 1
a183 1
			ERROR "illegal break, continue, next or nextfile from BEGIN" FATAL;
d199 1
a199 1
			ERROR "illegal break, continue, next or nextfile from END" FATAL;
d231 1
a231 1
		ERROR "calling undefined function %s", s FATAL;
d235 1
a235 1
			ERROR "out of space for stack frames calling %s", s FATAL;
d242 2
a243 2
		ERROR "function %s called with %d args, uses only %d",
			s, ncall, ndef WARNING;
d245 1
a245 1
		ERROR "function %s has %d arguments, limit %d", s, ncall+ndef, NARGS FATAL;
d253 1
a253 1
			ERROR "can't use function %s as argument in %s", y->nval, s FATAL;
d270 1
a270 1
			ERROR "out of space for stack frames in %s", s FATAL;
d332 2
a333 2
		ERROR "argument #%d of function %s was not supplied",
			n+1, fp->fcncell->nval FATAL;
d362 1
a362 1
				ERROR "bad type variable %d", y->tval FATAL;
d376 1
a376 1
		ERROR "illegal jump type %d", n FATAL;
d391 1
a391 1
		ERROR "out of memory in getline" FATAL;
d451 1
a451 1
		ERROR "out of memory in array" FATAL;
d459 1
a459 1
			ERROR "out of memory for %s[%s...]", x->nval, buf FATAL;
d500 1
a500 1
			ERROR "out of memory in adelete" FATAL;
d506 1
a506 1
				ERROR "out of memory deleting %s[%s...]", x->nval, buf FATAL;
d538 1
a538 1
		ERROR "out of memory in intest" FATAL;
d545 1
a545 1
			ERROR "out of memory deleting %s[%s...]", x->nval, buf FATAL;
d629 1
a629 1
		ERROR "unknown boolean operator %d", n FATAL;
d664 1
a664 1
		ERROR "unknown relational operator %d", n FATAL;
d676 1
a676 1
		ERROR "tempcell list is curdled" FATAL;
d688 1
a688 1
			ERROR "out of space for temporaries" FATAL;
d708 1
a708 1
		ERROR "illegal field $(%s), name \"%s\"", s, x->nval FATAL;
d806 1
a806 1
		ERROR "out of memory in format()" FATAL;
d825 1
a825 1
				ERROR "format item %.30s... ran format() out of memory", os FATAL;
d865 1
a865 1
			ERROR "weird printf conversion %s", fmt WARNING;
d870 1
a870 1
			ERROR "not enough args in printf(%s)", os FATAL;
d896 1
a896 1
				ERROR "huge string/format (%d chars) in printf %.30s... ran format() out of memory", n, t FATAL;
d930 1
a930 1
		ERROR "out of memory in awksprintf" FATAL;
d934 1
a934 1
		ERROR "sprintf string %.30s... too long.  can't happen.", buf FATAL;
d953 1
a953 1
		ERROR "out of memory in awkprintf" FATAL;
d957 1
a957 1
		ERROR "printf string %.30s... too long.  can't happen.", buf FATAL;
d963 1
a963 1
			ERROR "write error on stdout" FATAL;
d970 1
a970 1
			ERROR "write error on %s", filename(fp) FATAL;
d1003 1
a1003 1
			ERROR "division by zero" FATAL;
d1008 1
a1008 1
			ERROR "division by zero in mod" FATAL;
d1022 1
a1022 1
		ERROR "illegal arithmetic operator %d", n FATAL;
d1100 1
a1100 1
			ERROR "division by zero in /=" FATAL;
d1105 1
a1105 1
			ERROR "division by zero in %%=" FATAL;
d1116 1
a1116 1
		ERROR "illegal assignment operator %d", n FATAL;
d1138 2
a1139 2
		ERROR "out of space concatenating %.15s... and %.15s...",
			x->sval, y->sval FATAL;
d1208 1
a1208 1
		ERROR "illegal type of split" FATAL;
d1470 1
a1470 1
			ERROR "atan2 requires two arguments; returning 1.0" WARNING;
d1518 1
a1518 1
		ERROR "illegal function type %d", t FATAL;
d1525 1
a1525 1
		ERROR "warning: function has too many arguments" WARNING;
d1554 1
a1554 1
		ERROR "write error on %s", filename(fp) FATAL;
d1576 1
a1576 1
		ERROR "can't open file %s", fname FATAL;
d1586 3
a1588 3
	{ stdin,  "/dev/stdin",  LT },	/* watch out: don't free this! */
	{ stdout, "/dev/stdout", GT },
	{ stderr, "/dev/stderr", GT }
d1591 7
d1605 1
a1605 1
		ERROR "null file name in print or getline" FATAL;
d1620 1
a1620 1
		ERROR "%s makes too many open files", s FATAL;
d1635 1
a1635 1
		ERROR "illegal redirection %d", a FATAL;
d1665 1
a1665 1
				ERROR "i/o error occurred on %s", files[i].fname WARNING;
d1671 1
a1671 1
				ERROR "i/o error occurred closing %s", files[i].fname WARNING;
d1688 1
a1688 1
				ERROR "i/o error occurred on %s", files[i].fname WARNING;
d1694 1
a1694 1
				ERROR "i/o error occurred while closing %s", files[i].fname WARNING;
d1709 1
a1709 1
		ERROR "out of memory in sub" FATAL;
d1742 1
a1742 1
			ERROR "sub result1 %.30s too big; can't happen", buf FATAL;
d1750 1
a1750 1
			ERROR "sub result2 %.30s too big; can't happen", buf FATAL;
d1770 1
a1770 1
		ERROR "out of memory in gsub" FATAL;
d1811 1
a1811 1
					ERROR "gsub result0 %.30s too big; can't happen", buf FATAL;
d1837 1
a1837 1
					ERROR "gsub result1 %.30s too big; can't happen", buf FATAL;
d1846 1
a1846 1
			ERROR "gsub result2 %.30s too big; can't happen", buf FATAL;
@


1.14
log
@March 5, 1999 version of the "one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.13 1997/08/25 16:17:14 kstailey Exp $	*/
d73 1
a73 1
Cell	*true	= &truecell;
d75 1
a75 1
Cell	*false	= &falsecell;
d112 1
a112 1
		tbuf = realloc(*pbuf, minlen);
d139 1
a139 1
		return(true);
d178 1
a178 1
			return(true);
d200 1
a200 1
	return(true);
d237 1
a237 1
	   dprintf( ("calling %s, %d args (%d in defn), fp=%d\n", s, ncall, ndef, fp-frame) );
d244 1
a244 1
		   dprintf( ("evaluate args[%d], fp=%d:\n", i, fp-frame) );
d275 1
a275 1
	   dprintf( ("start exec of %s, fp=%d\n", s, fp-frame) );
d277 1
a277 1
	   dprintf( ("finished exec of %s, fp=%d\n", s, fp-frame) );
d326 1
a326 1
	n = (int) a[0];	/* argument number, counting from 0 */
d385 1
d394 4
a397 3
		if ((int) a[1] == '|')		/* input pipe */
			a[1] = (Node *) LE;	/* arbitrary flag */
		fp = openfile((int) a[1], getsval(x));
d447 1
a447 1
	if ((buf = malloc(bufsz)) == NULL)
d487 1
a487 1
		return true;
d496 1
a496 1
		if ((buf = malloc(bufsz)) == NULL)
d513 1
a513 1
	return true;
d534 1
a534 1
	if ((buf = malloc(bufsz)) == NULL) {
d552 1
a552 1
		return(false);
d554 1
a554 1
		return(true);
d593 1
a593 1
		return(true);
d595 1
a595 1
		return(false);
d609 1
a609 1
		if (i) return(true);
d613 2
a614 2
		if (i) return(true);
		else return(false);
d616 1
a616 1
		if ( !i ) return(false);
d620 2
a621 2
		if (i) return(true);
		else return(false);
d623 2
a624 2
		if (i) return(false);
		else return(true);
d648 12
a659 12
	case LT:	if (i<0) return(true);
			else return(false);
	case LE:	if (i<=0) return(true);
			else return(false);
	case NE:	if (i!=0) return(true);
			else return(false);
	case EQ:	if (i == 0) return(true);
			else return(false);
	case GE:	if (i>=0) return(true);
			else return(false);
	case GT:	if (i>0) return(true);
			else return(false);
d802 1
a802 1
	if ((fmt = malloc(fmtsz)) == NULL)
d926 1
a926 1
	if ((buf=malloc(bufsz)) == NULL)
d949 1
a949 1
	if ((buf=malloc(bufsz)) == NULL)
d962 1
a962 1
		fp = redirect((int)a[1], a[2]);
d970 1
a970 1
	return(true);
d1168 1
a1168 1
	pair = (int) a[3];
d1183 1
a1183 1
	return(false);
d1192 1
a1192 1
	int n, tempstat;
d1196 1
d1199 1
a1199 1
	else if ((int) a[3] == STRING) {	/* split(str,arr,"string") */
d1202 1
a1202 1
	} else if ((int) a[3] == REGEXPR)
d1215 1
a1215 1
	if ((*s != '\0' && strlen(fs) > 1) || (int) a[3] == REGEXPR) {	/* reg expr */
d1217 1
a1217 1
		if ((int) a[3] == REGEXPR) {	/* it's ready already */
d1307 1
a1307 1
	if (a[2] != 0 && (int) a[3] == STRING)
d1356 1
a1356 1
			x = true;
d1372 1
a1372 1
			return true;
d1397 1
a1397 1
			return true;
d1415 1
a1415 1
		return true;
d1426 1
a1426 1
				return true;
d1435 1
a1435 1
	return true;
d1447 1
a1447 1
	t = (int) a[0];
d1538 1
a1538 1
		fp = redirect((int)a[1], a[2]);
d1552 1
a1552 1
	return(true);
d1557 2
a1558 2
	n = 0;
	a = 0;
d1649 1
a1649 1
	n = 0;
d1668 1
a1668 1
	return(true);
d1698 1
a1698 1
	if ((buf=malloc(bufsz)) == NULL)
d1710 1
a1710 1
	result = false;
d1742 1
a1742 1
		result = true;;
d1759 1
a1759 1
	if ((buf=malloc(bufsz)) == NULL)
@


1.13
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d286 1
d342 1
a342 1
			errorflag = getfval(y);
d409 1
a409 1
			if (isnumber(fldtab[0]->sval)) {
d476 1
a476 1
Cell *adelete(Node **a, int n)	/* a[0] is symtab, a[1] is list of subscripts */
d701 2
a702 2
	m = getfval(x);
	if (m == 0 && !isnumber(s = getsval(x)))	/* suspicion! */
d734 1
a734 1
	m = getfval(y);
d741 1
a741 1
		n = getfval(z);
d1227 1
a1227 1
				if (isnumber(s))
d1244 1
a1244 1
		if (isnumber(s))
d1264 1
a1264 1
			if (isnumber(t))
d1293 1
a1293 1
			if (isnumber(t))
d1486 1
a1486 1
		srand((int) u); u = (int) u;
@


1.12
log
@Back out last changes for now.  They cause problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.11 1997/04/06 06:31:51 millert Exp $	*/
d3 1
a3 1
Copyright (C) AT&T and Lucent Technologies 1996
d11 13
a23 13
documentation, and that the names of AT&T or Lucent Technologies
or any of their entities not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

AT&T AND LUCENT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL AT&T OR LUCENT OR ANY OF THEIR
ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
d35 1
a35 1
#include "awkgram.h"
d67 1
a67 4

#define PA2NUM	29	/* max number of pat,pat patterns allowed */
int	paircnt;		/* number of them in use */
int	pairstack[PA2NUM];	/* state of each pat,pat */
d88 1
a88 1
static Cell	tempcell	={ OCELL, CTEMP, 0, 0, 0.0, NUM };
d92 34
d144 1
a144 1
			if ((x->tval & FLD) && !donefld)
d146 1
a146 1
			else if ((x->tval & REC) && !donerec)
d154 1
a154 1
		if ((x->tval & FLD) && !donefld)
d156 1
a156 1
		else if ((x->tval & REC) && !donerec)
d184 1
a184 1
		while (getrec(record) > 0) {
d218 1
a218 1
	static Cell newcopycell = { OCELL, CCOPY, 0, (char *) "", 0.0, NUM|STR|DONTFREE };
d221 2
a222 1
	Cell *args[NARGS], *oargs[NARGS], *y, *z, *fcn;
d227 1
a227 1
	if (!isfunc(fcn))
d237 1
a237 1
	dprintf( ("calling %s, %d args (%d in defn), fp=%d\n", s, ncall, ndef, fp-frame) );
d244 1
a244 1
		dprintf( ("evaluate args[%d], fp=%d:\n", i, fp-frame) );
d247 3
a249 3
		dprintf( ("args[%d]: %s %f <%s>, t=%o\n",
			   i, y->nval, y->fval, isarr(y) ? "(array)" : (char*) y->sval, y->tval) );
		if (isfunc(y))
d275 1
a275 1
	dprintf( ("start exec of %s, fp=%d\n", s, fp-frame) );
d277 1
a277 1
	dprintf( ("finished exec of %s, fp=%d\n", s, fp-frame) );
d303 1
a303 1
	dprintf( ("%s returns %g |%s| %o\n", s, getfval(z), getsval(z), z->tval) );
d314 1
a314 1
	y->nval = x->nval;
d326 1
a326 1
	dprintf( ("arg(%d), fp->nargs=%d\n", n, fp->nargs) );
d380 1
a380 1
	char buf[RECSIZE];
d382 5
d392 1
a392 1
		if ((int) a[1] == '|')	/* input pipe */
d399 1
a399 1
			n = readrec(buf, sizeof(buf), fp);
d403 3
a405 1
			setsval(execute(a[0]), buf);
d407 4
a410 8
			if (!(recloc->tval & DONTFREE))
				xfree(recloc->sval);
			strcpy(record, buf);
			recloc->sval = record;
			recloc->tval = REC | STR | DONTFREE;
			if (isnumber(recloc->sval)) {
				recloc->fval = atof(recloc->sval);
				recloc->tval |= NUM;
a411 1
			donerec = 1; donefld = 0;
d415 1
a415 1
			n = getrec(record);
d417 4
a420 2
			n = getrec(buf);
			setsval(execute(a[0]), buf);
d424 1
d440 6
a445 1
	char buf[RECSIZE];
d452 3
a454 1
		strcat(buf, s);		/* BUG: unchecked! */
d460 1
a460 1
		dprintf( ("making %s into an array\n", x->nval) );
d471 1
d479 2
a480 1
	char buf[RECSIZE], *s;
d491 4
d499 3
a501 1
			strcat(buf, s);
d507 1
d517 1
a517 1
	char buf[RECSIZE];
d519 2
d524 1
a524 1
		dprintf( ("making %s into an array\n", ap->nval) );
d531 3
d538 2
d547 1
d665 2
a666 1
	if (freeable(a))
d668 1
d703 1
a703 2
  /* can x->nval ever be null??? */
		/* ERROR "illegal field $(%s)", s FATAL; */
d706 1
a706 1
	x->ctype = OCELL;
d748 1
a748 1
	dprintf( ("substr: m=%d, n=%d, s=%s\n", m, n, s) );
d784 3
a786 5
/*
 * printf-like conversions
 *   returns len of buf or -1 on error
 */
int format(char *buf, int bufsize, char *s, Node *a)
d788 1
a788 1
	char fmt[RECSIZE];
d792 4
d799 2
d802 1
a802 2
		if (p - buf >= bufsize)
			return -1;
d812 8
a819 1
		for (t=fmt; (*t++ = *s) != '\0'; s++) {
d825 4
a828 1
				sprintf((char *)t-1, "%d", (int) getfval(x));
d834 4
a837 2
		if (t >= fmt + sizeof(fmt))
			ERROR "format item %.30s... too long", os FATAL;
d867 4
d872 6
a877 1
		case 0:	sprintf((char *)p, "%s", fmt);	/* unknown, so dump it too */
d879 1
a879 1
			sprintf((char *)p, "%s", getsval(x));
d881 3
a883 3
		case 1:	sprintf((char *)p, (char *)fmt, getfval(x)); break;
		case 2:	sprintf((char *)p, (char *)fmt, (long) getfval(x)); break;
		case 3:	sprintf((char *)p, (char *)fmt, (int) getfval(x)); break;
d887 5
a891 4
			if (n >= bufsize)
				ERROR "huge string (%d chars) in printf %.30s...",
					n, t FATAL;
			sprintf((char *)p, (char *)fmt, t);
d894 7
a900 5
			isnum(x) ?
			  (getfval(x) ?
			    sprintf((char *)p, (char *)fmt, (int) getfval(x))
                                      : (*p++ = '\0'))
				 : sprintf((char *)p, (char *)fmt, getsval(x)[0]);
d908 1
d911 3
a913 1
	return ((int)(p - buf));
d920 2
a921 1
	char buf[3*RECSIZE];
d923 2
d927 2
a928 2
	if (format(buf, sizeof buf, getsval(x), y) == -1)
		ERROR "sprintf string %.30s... too long", buf FATAL;
d931 1
a931 1
	x->sval = tostring(buf);
d942 1
a942 1
	char buf[3*RECSIZE];
d944 1
d946 2
d950 2
a951 2
	if ((len = format(buf, sizeof buf, getsval(x), y)) == -1)
		ERROR "printf string %.30s... too long", buf FATAL;
d954 1
d960 1
d966 1
d1071 1
a1071 1
		else if (y->tval & STR)
d1073 1
a1073 1
		else if (y->tval & NUM)
d1188 1
a1188 1
	char *t, temp, num[10], *fs = 0;
d1199 1
a1199 1
		fs = (char*) "(regexpr)";	/* split(str,arr,/regexpr/) */
d1201 1
a1201 1
		ERROR "illegal type of split()" FATAL;
d1205 1
a1205 1
	dprintf( ("split: s=|%s|, a=%s, sep=|%s|\n", s, ap->nval, fs) );
d1223 1
a1223 1
				sprintf((char *)num, "%d", n);
d1227 1
a1227 1
					setsymtab(num, s, atof((char *)s), STR|NUM, (Array *) ap->sval);
d1234 1
a1234 1
					sprintf((char *)num, "%d", n);
d1242 1
a1242 1
		sprintf((char *)num, "%d", n);
d1244 1
a1244 1
			setsymtab(num, s, atof((char *)s), STR|NUM, (Array *) ap->sval);
d1262 1
a1262 1
			sprintf((char *)num, "%d", n);
d1264 1
a1264 1
				setsymtab(num, t, atof((char *)t), STR|NUM, (Array *) ap->sval);
d1275 1
a1275 1
			sprintf((char *)num, "%d", n);
d1291 1
a1291 1
			sprintf((char *)num, "%d", n);
d1293 1
a1293 1
				setsymtab(num, t, atof((char *)t), STR|NUM, (Array *) ap->sval);
a1433 56
#if 0
	/* if someone ever wants to run over the arrays in sorted order, */
	/* here it is.  but it will likely run slower, not faster. */
	
	int qstrcmp(p, q)
		char **p, **q;
	{
		return strcmp(*p, *q);
	}
	
	Cell *instat(Node **a, int n)	/* for (a[0] in a[1]) a[2] */
	{
		Cell *x, *vp, *arrayp, *cp, *ncp, *ret;
		Array *tp;
		int i, ne;
	#define BIGENOUGH 1000
		char *elems[BIGENOUGH], **ep;
	
		vp = execute(a[0]);
		arrayp = execute(a[1]);
		if (!isarr(arrayp))
			ERROR "%s is not an array", arrayp->nval FATAL;
		tp = (Array *) arrayp->sval;
		tempfree(arrayp);
		ep = elems;
		ret = true;
		if (tp->nelem >= BIGENOUGH)
			ep = (char **) malloc(tp->nelem * sizeof(char *));
	
		for (i = ne = 0; i < tp->size; i++)
			for (cp = tp->tab[i]; cp != NULL; cp = cp->cnext)
				ep[ne++] = cp->nval;
		if (ne != tp->nelem)
			ERROR "can't happen: lost elems %d vs. %d", ne, tp->nelem FATAL;
		qsort(ep, ne, sizeof(char *), qstrcmp);
		for (i = 0; i < ne; i++) {
			setsval(vp, ep[i]);
			x = execute(a[2]);
			if (isbreak(x)) {
				tempfree(vp);
				break;
			}
			if (isnext(x) || isnextfile(x) || isexit(x) || isret(x)) {
				tempfree(vp);
				ret = x;
				break;
			}
			tempfree(x);
		}
		if (ep != elems)
			free(ep);
		return ret;
	}
#endif


d1439 1
a1439 1
	char *p, buf[RECSIZE];
d1474 1
a1474 1
		u = (Awkfloat) system((char *)getsval(x)) / 256;   /* 256 is unix-dep */
d1481 1
a1481 1
		if (x->tval & REC)	/* no argument provided */
d1489 1
a1489 1
		strcpy(buf, getsval(x));
d1502 1
d1505 1
a1505 1
		if ((fp = openfile(GT, getsval(x))) == NULL)
d1537 1
a1537 1
		fputs((char *)getsval(y), fp);
d1540 1
a1540 1
			fputs((char *)*ORS, fp);
d1542 1
a1542 1
			fputs((char *)*OFS, fp);
d1593 1
a1593 1
		if (files[i].fname && strcmp(s, files[i].fname) == 0)
d1596 6
d1684 1
a1684 1
#define	SUBSIZE	(20 * RECSIZE)
d1690 1
a1690 1
	char buf[SUBSIZE], *t;
d1692 1
d1694 2
d1708 2
a1710 1
		sptr = t;
d1714 4
a1717 4
		while (*sptr != 0 && pb < buf + SUBSIZE - 1)
			if (*sptr == '\\' && *(sptr+1) == '&') {
				sptr++;		/* skip \, */
				*pb++ = *sptr++; /* add & */
d1720 1
d1725 1
d1727 2
a1728 2
		if (pb >= buf + SUBSIZE)
			ERROR "sub() result %.30s too big", buf FATAL;
d1730 2
a1731 1
		if ((patlen == 0 && *patbeg) || (patlen && *(sptr-1)))
d1734 4
a1737 3
		if (pb >= buf + SUBSIZE)
			ERROR "sub() result %.30s too big", buf FATAL;
		setsval(x, buf);
d1742 1
d1749 2
a1750 2
	char *rptr, *sptr, *t, *pb;
	char buf[SUBSIZE];
d1753 1
d1755 2
a1774 11
			/*
			char *p;
			int i;
			printf("target string: %s, *patbeg = %o, patlen = %d\n",
				t, *patbeg, patlen);
			printf("	match found: ");
			p=patbeg;
			for (i=0; i<patlen; i++)
				printf("%c", *p++);
			printf("\n");
			*/
d1779 4
a1782 4
					while (*sptr != 0 && pb < buf + SUBSIZE-1)
						if (*sptr == '\\' && *(sptr+1) == '&') {
							sptr++;
							*pb++ = *sptr++;
a1783 1
							char *q;
d1785 1
d1790 1
d1794 1
d1796 2
a1797 2
				if (pb >= buf + SUBSIZE-1)
					ERROR "gsub() result %.30s too big", buf FATAL;
a1801 2
				/* if (patlen <= 0)
					ERROR "4: buf=%s, patlen %d, t=%s, patbeg=%s", buf, patlen, t, patbeg WARNING; */
d1803 2
a1804 1
				while (sptr < patbeg && pb < buf + SUBSIZE-1)
d1807 4
a1810 4
				while (*sptr != 0 && pb < buf + SUBSIZE-1)
					if (*sptr == '\\' && *(sptr+1) == '&') {
						sptr++;
						*pb++ = *sptr++;
a1811 1
						char *q;
d1813 1
d1818 1
d1822 2
a1823 2
				if (pb >= buf + SUBSIZE-1)
					ERROR "gsub() result %.30s too big", buf FATAL;
d1828 1
d1831 2
a1832 2
	done:	if (pb >= buf + SUBSIZE-1)
			ERROR "gsub() result %.30s too big", buf FATAL;
d1834 1
a1834 1
		setsval(x, buf);
d1842 1
d1844 26
@


1.11
log
@Use long, not int when casting pointers and storing as integers.
Now compiles on alpha w/o warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.10 1997/01/29 18:33:56 kstailey Exp $	*/
d69 2
a70 2
long	paircnt;		/* number of them in use */
long	pairstack[PA2NUM];	/* state of each pat,pat */
d204 1
a204 1
	ndef = (long) fcn->fval;		/* args in defn */
d293 1
a293 1
	n = (long) a[0];	/* argument number, counting from 0 */
d355 1
a355 1
		if ((long) a[1] == '|')	/* input pipe */
d357 1
a357 1
		fp = openfile((long) a[1], getsval(x));
d753 1
a753 1
				sprintf((char *)t-1, "%ld", (long) getfval(x));
d797 1
a797 1
		case 3:	sprintf((char *)p, (char *)fmt, (long) getfval(x)); break;
d809 1
a809 1
			    sprintf((char *)p, (char *)fmt, (long) getfval(x))
d821 1
a821 1
	return ((long)(p - buf));
d860 1
a860 1
		fp = redirect((long)a[1], a[2]);
d910 1
a910 1
			i = ipow(i, (long) j);
d1004 1
a1004 1
			xf = ipow(xf, (long) yf);
d1064 1
a1064 1
	pair = (long) a[3];
d1094 1
a1094 1
	else if ((long) a[3] == STRING) {	/* split(str,arr,"string") */
d1097 1
a1097 1
	} else if ((long) a[3] == REGEXPR)
d1110 1
a1110 1
	if ((*s != '\0' && strlen(fs) > 1) || (long) a[3] == REGEXPR) {	/* reg expr */
d1112 1
a1112 1
		if ((long) a[3] == REGEXPR) {	/* it's ready already */
d1202 1
a1202 1
	if (a[2] != 0 && (long) a[3] == STRING)
d1398 1
a1398 1
	t = (long) a[0];
d1440 1
a1440 1
		srand((long) u); u = (long) u;
d1488 1
a1488 1
		fp = redirect((long)a[1], a[2]);
@


1.10
log
@calculate string length in format() more efficiently
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.9 1997/01/25 03:24:52 kstailey Exp $	*/
d69 2
a70 2
int	paircnt;		/* number of them in use */
int	pairstack[PA2NUM];	/* state of each pat,pat */
d204 1
a204 1
	ndef = (int) fcn->fval;			/* args in defn */
d293 1
a293 1
	n = (int) a[0];	/* argument number, counting from 0 */
d355 1
a355 1
		if ((int) a[1] == '|')	/* input pipe */
d357 1
a357 1
		fp = openfile((int) a[1], getsval(x));
d753 1
a753 1
				sprintf((char *)t-1, "%d", (int) getfval(x));
d797 1
a797 1
		case 3:	sprintf((char *)p, (char *)fmt, (int) getfval(x)); break;
d809 1
a809 1
			    sprintf((char *)p, (char *)fmt, (int) getfval(x))
d821 1
a821 1
	return ((int)(p - buf));
d860 1
a860 1
		fp = redirect((int)a[1], a[2]);
d910 1
a910 1
			i = ipow(i, (int) j);
d1004 1
a1004 1
			xf = ipow(xf, (int) yf);
d1064 1
a1064 1
	pair = (int) a[3];
d1094 1
a1094 1
	else if ((int) a[3] == STRING) {	/* split(str,arr,"string") */
d1097 1
a1097 1
	} else if ((int) a[3] == REGEXPR)
d1110 1
a1110 1
	if ((*s != '\0' && strlen(fs) > 1) || (int) a[3] == REGEXPR) {	/* reg expr */
d1112 1
a1112 1
		if ((int) a[3] == REGEXPR) {	/* it's ready already */
d1202 1
a1202 1
	if (a[2] != 0 && (int) a[3] == STRING)
d1398 1
a1398 1
	t = (int) a[0];
d1440 1
a1440 1
		srand((int) u); u = (int) u;
d1488 1
a1488 1
		fp = redirect((int)a[1], a[2]);
@


1.9
log
@reapplied 1.2 -> 1.3 changes to run.c plus many fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.7 1997/01/24 23:43:10 kstailey Exp $	*/
d731 1
a731 1
	int flag = 0, len = 0, n;
a738 1
		        len++;
a742 1
			len++;
a791 1
			len += strlen(p);
d810 1
a810 1
                                      : (*p++ = '\0', len++))
a814 1
		len += strlen(p);
d821 1
a821 1
	return (len);
@


1.8
log
@back out 1.2 again for testing
@
text
@d1 1
d722 5
a726 1
int format(char *buf, int bufsize, char *s, Node *a)	/* printf-like conversions */
d731 1
a731 1
	int flag = 0, n;
d739 1
d744 1
d794 1
d810 4
a813 1
			isnum(x) ? sprintf((char *)p, (char *)fmt, (int) getfval(x))
d818 1
d825 1
a825 1
	return 0;
d852 1
d856 1
a856 1
	if (format(buf, sizeof buf, getsval(x), y) == -1)
d860 1
a860 1
		fputs((char *)buf, stdout);
d865 1
a865 1
		fputs((char *)buf, fp);
@


1.7
log
@reapplied 1.2 -> 1.3 changes to run.c that got squashed
@
text
@a0 1
/*	$OpenBSD$	*/
d721 1
a721 5
/*
 * printf-like conversions
 *   returns len of buf or -1 on error
 */
int format(char *buf, int bufsize, char *s, Node *a)
d726 1
a726 1
	int flag = 0, len = 0, n;
a733 1
		        len++;
a737 1
			len++;
a786 1
			len += strlen(p);
d802 1
a802 4
			isnum(x) ?
			  (getfval(x) ?
			    sprintf((char *)p, (char *)fmt, (int) getfval(x))
                                      : len++)
a806 1
		len += strlen(p);
d813 1
a813 1
	return (len);
a839 1
	int len;
d843 1
a843 1
	if ((len = format(buf, sizeof buf, getsval(x), y)) == -1)
d847 2
a848 1
		if (write(1, buf, len) != len)
d852 3
a854 2
		ferror(fp);	/* XXX paranoia */
		if (write(fileno(fp), buf, len) != len)
@


1.6
log
@Basically stock AT&T resarch awk until the awk vs. flex problems
have a better resolution.
@
text
@d1 1
d722 5
a726 1
int format(char *buf, int bufsize, char *s, Node *a)	/* printf-like conversions */
d731 1
a731 1
	int flag = 0, n;
d739 1
d744 1
d794 1
d810 4
a813 1
			isnum(x) ? sprintf((char *)p, (char *)fmt, (int) getfval(x))
d818 1
d825 1
a825 1
	return 0;
d852 1
d856 1
a856 1
	if (format(buf, sizeof buf, getsval(x), y) == -1)
d860 1
a860 2
		fputs((char *)buf, stdout);
		if (ferror(stdout))
d864 2
a865 3
		fputs((char *)buf, fp);
		fflush(fp);
		if (ferror(fp))
@


1.5
log
@back out 1.4; I should know better than to do this after a big meal
@
text
@a0 1
/*	$OpenBSD: run.c,v 1.4 1997/01/21 23:47:55 kstailey Exp $	*/
d721 1
a721 5
/*
 * printf-like conversions
 *   returns len of buf or -1 on error
 */
int format(char *buf, int bufsize, char *s, Node *a)
d726 1
a726 1
	int flag = 0, len = 0, n;
a733 1
		        len++;
a737 1
			len++;
a786 1
			len += strlen(p);
d802 1
a802 4
			isnum(x) ?
			  (getfval(x) ?
			    sprintf((char *)p, (char *)fmt, (int) getfval(x))
                                      : len++)
a806 1
		len += strlen(p);
d813 1
a813 1
	return (len);
a839 1
	int len;
d843 1
a843 1
	if ((len = format(buf, sizeof buf, getsval(x), y)) == -1)
d847 2
a848 1
		if (write(1, buf, len) != len)
d852 3
a854 2
		ferror(fp);	/* XXX paranoia */
		if (write(fileno(fp), buf, len) != len)
@


1.4
log
@optimization: kill two calls to strlen() in format()
@
text
@d1 1
a1 1
/*	$OpenBSD: run.c,v 1.3 1997/01/21 21:14:06 kstailey Exp $	*/
d794 2
a795 1
			p += len += strlen(p);
d818 2
a819 1
		p += len += strlen(p);
@


1.3
log
@from the FIXES file:

Oct 20, 1988:
        Fixed %c:  if expr is numeric, use numeric value;
        otherwise print 1st char of string value.  still
        doesn't work if the value is 0 -- won't print \0.

This bugged me because it prevents awk from being a general-purpose
decimal to bytestream converter (also GNU awk gets this right.)

Look in /usr/share/man/cat4/sun3/leds.0 and you see:

           # echo 0 0 0 5 0 0 0 8 254 253 250 247 239 223 175 127 |
             awk '{ for (i=1;i<=NF;i++) printf("%c",$i+0); }' > /dev/leds

This used to fail since "0" did not produce a \0 on stdout.

It doesn't make any sense to me to fix awksprintf() the same way I did
awkprintf() since sticking a \0 in a string ends it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d794 1
a794 2
			len += strlen(p);
			p += strlen(p);
d817 1
a817 2
		len += strlen(p);
		p += strlen(p);
@


1.2
log
@Latest research awk from June 29, 1996
@
text
@d1 1
d722 5
a726 1
int format(char *buf, int bufsize, char *s, Node *a)	/* printf-like conversions */
d731 1
a731 1
	int flag = 0, n;
d739 1
d744 1
d794 1
d810 4
a813 1
			isnum(x) ? sprintf((char *)p, (char *)fmt, (int) getfval(x))
d818 1
d825 1
a825 1
	return 0;
d852 1
d856 1
a856 1
	if (format(buf, sizeof buf, getsval(x), y) == -1)
d860 1
a860 2
		fputs((char *)buf, stdout);
		if (ferror(stdout))
d864 2
a865 3
		fputs((char *)buf, fp);
		fflush(fp);
		if (ferror(fp))
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d111 1
a111 1
			x = (Cell *)(a->narg[0]);
a355 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a407 2
		if ((y->tval & STR) == 0)
			y = copycell(y);
a446 2
			if ((y->tval & STR) == 0)
				y = copycell(y);
a477 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a505 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a510 2
		if ((y->tval & STR) == 0)
			y = copycell(y);
a577 4
		if ((x->tval & STR) == 0)
			x = copycell(x);
		if ((y->tval & STR) == 0)
			y = copycell(y);
a635 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a658 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a701 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a703 2
	if ((y->tval & STR) == 0)
		y = copycell(y);
a783 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a823 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a842 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a866 2
	if ((x->tval & NUM) == 0)
		x = copycell(x);
a870 2
		if ((y->tval & NUM) == 0)
			y = copycell(y);
a1015 4
	if ((x->tval & STR) == 0)
		x = copycell(x);
	if ((y->tval & STR) == 0)
		y = copycell(y);
a1081 2
	if ((y->tval & STR) == 0)
		y = copycell(y);
a1086 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a1393 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a1419 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a1434 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a1449 2
		if ((x->tval & STR) == 0)
			x = copycell(x);
a1471 2
	extern char **OFMT, **CONVFMT;
	char **save;
a1481 4
		if ((y->tval & STR) == 0)
			y = copycell(y);
		save = CONVFMT;
		CONVFMT = OFMT;
a1482 1
		CONVFMT = save;
a1510 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a1585 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a1632 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a1641 2
	if ((y->tval & STR) == 0)
		y = copycell(y);
a1686 2
	if ((x->tval & STR) == 0)
		x = copycell(x);
a1691 2
		if ((y->tval & STR) == 0)
			y = copycell(y);
a1695 2
	if ((y->tval & STR) == 0)
		y = copycell(y);
@
