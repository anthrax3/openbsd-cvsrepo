head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.8
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.14
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.10
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.6
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.6
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2;
locks; strict;
comment	@# @;


1.44
date	2015.09.14.20.06.58;	author schwarze;	state Exp;
branches;
next	1.43;
commitid	r87YNrjEWwl7OkJ0;

1.43
date	2015.01.16.15.53.24;	author schwarze;	state Exp;
branches;
next	1.42;
commitid	5xwj61wmOCXaN2wW;

1.42
date	2014.12.15.20.31.40;	author tedu;	state Exp;
branches;
next	1.41;
commitid	nYzwHustSVvMRt3B;

1.41
date	2014.03.17.21.48.51;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.02.11.14.11;	author jmc;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.22.15.55.43;	author jmc;	state Exp;
branches;
next	1.38;

1.38
date	2011.02.07.00.02.50;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.01.07.06.16;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2010.08.25.19.21.04;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.08.13.26.48;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.10.10.53.33;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2009.02.08.17.15.09;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.04.15.51.28;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.25.05.09.55;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.04.17.14.07;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.04.14.04.42;	author pyr;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.27.21.10.39;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.31.19.20.07;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.30.04.41.33;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.29.19.41.10;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.29.15.29.55;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.12.09.18.24;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.04.21.40.53;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.19.18.29.17;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.19.12.48.02;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.19.09.27.36;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.18.20.22.51;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.16.11.18.37;	author jmc;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.12.19.50.55;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.24.10.58.08;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.02.18.50.06;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.30.23.59.00;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.10.09.12.09;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.18.07.51.08;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.05.09.37.36;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.17.21.48.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.10.05.10.21;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.30.13.37.51;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.06.05.01.21.18;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	98.03.03.01.56.00;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	98.02.03.00.24.01;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.20.19.43.18;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.07.06.05.40.03;	author etheisen;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Avoid .Ns right after .Pf, it's pointless.
In some cases, do additional cleanup in the immediate vicinity.
@
text
@.\"	$OpenBSD: awk.1,v 1.43 2015/01/16 15:53:24 schwarze Exp $
.\"
.\" Copyright (C) Lucent Technologies 1997
.\" All Rights Reserved
.\"
.\" Permission to use, copy, modify, and distribute this software and
.\" its documentation for any purpose and without fee is hereby
.\" granted, provided that the above copyright notice appear in all
.\" copies and that both that the copyright notice and this
.\" permission notice and warranty disclaimer appear in supporting
.\" documentation, and that the name Lucent Technologies or any of
.\" its entities not be used in advertising or publicity pertaining
.\" to distribution of the software without specific, written prior
.\" permission.
.\"
.\" LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
.\" INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
.\" IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
.\" SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
.\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
.\" THIS SOFTWARE.
.\"
.Dd $Mdocdate: January 16 2015 $
.Dt AWK 1
.Os
.Sh NAME
.Nm awk
.Nd pattern-directed scanning and processing language
.Sh SYNOPSIS
.Nm awk
.Op Fl safe
.Op Fl V
.Op Fl d Ns Op Ar n
.Op Fl F Ar fs
.Op Fl v Ar var Ns = Ns Ar value
.Op Ar prog | Fl f Ar progfile
.Ar
.Sh DESCRIPTION
.Nm
scans each input
.Ar file
for lines that match any of a set of patterns specified literally in
.Ar prog
or in one or more files specified as
.Fl f Ar progfile .
With each pattern there can be an associated action that will be performed
when a line of a
.Ar file
matches the pattern.
Each line is matched against the
pattern portion of every pattern-action statement;
the associated action is performed for each matched pattern.
The file name
.Sq -
means the standard input.
Any
.Ar file
of the form
.Ar var Ns = Ns Ar value
is treated as an assignment, not a filename,
and is executed at the time it would have been opened if it were a filename.
.Pp
The options are as follows:
.Bl -tag -width "-safe "
.It Fl d Ns Op Ar n
Debug mode.
Set debug level to
.Ar n ,
or 1 if
.Ar n
is not specified.
A value greater than 1 causes
.Nm
to dump core on fatal errors.
.It Fl F Ar fs
Define the input field separator to be the regular expression
.Ar fs .
.It Fl f Ar progfile
Read program code from the specified file
.Ar progfile
instead of from the command line.
.It Fl safe
Disable file output
.Pf ( Ic print No > ,
.Ic print No >> ) ,
process creation
.Po
.Ar cmd | Ic getline ,
.Ic print | ,
.Ic system
.Pc
and access to the environment
.Pf ( Va ENVIRON ;
see the section on variables below).
This is a first
.Pq and not very reliable
approximation to a
.Dq safe
version of
.Nm .
.It Fl V
Print the version number of
.Nm
to standard output and exit.
.It Fl v Ar var Ns = Ns Ar value
Assign
.Ar value
to variable
.Ar var
before
.Ar prog
is executed;
any number of
.Fl v
options may be present.
.El
.Pp
The input is normally made up of input lines
.Pq records
separated by newlines, or by the value of
.Va RS .
If
.Va RS
is null, then any number of blank lines are used as the record separator,
and newlines are used as field separators
(in addition to the value of
.Va FS ) .
This is convenient when working with multi-line records.
.Pp
An input line is normally made up of fields separated by whitespace,
or by the regular expression
.Va FS .
The fields are denoted
.Va $1 , $2 , ... ,
while
.Va $0
refers to the entire line.
If
.Va FS
is null, the input line is split into one field per character.
.Pp
Normally, any number of blanks separate fields.
In order to set the field separator to a single blank, use the
.Fl F
option with a value of
.Sq [\ \&] .
If a field separator of
.Sq t
is specified,
.Nm
treats it as if
.Sq \et
had been specified and uses
.Aq TAB
as the field separator.
In order to use a literal
.Sq t
as the field separator, use the
.Fl F
option with a value of
.Sq [t] .
.Pp
A pattern-action statement has the form
.Pp
.D1 Ar pattern Ic \&{ Ar action Ic \&}
.Pp
A missing
.Ic \&{ Ar action Ic \&}
means print the line;
a missing pattern always matches.
Pattern-action statements are separated by newlines or semicolons.
.Pp
Newlines are permitted after a terminating statement or following a comma
.Pq Sq ,\& ,
an open brace
.Pq Sq { ,
a logical AND
.Pq Sq && ,
a logical OR
.Pq Sq || ,
after the
.Sq do
or
.Sq else
keywords,
or after the closing parenthesis of an
.Sq if ,
.Sq for ,
or
.Sq while
statement.
Additionally, a backslash
.Pq Sq \e
can be used to escape a newline between tokens.
.Pp
An action is a sequence of statements.
A statement can be one of the following:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It Ic if Ar ( expression ) Ar statement Op Ic else Ar statement
.It Ic while Ar ( expression ) Ar statement
.It Ic for Ar ( expression ; expression ; expression ) statement
.It Ic for Ar ( var Ic in Ar array ) statement
.It Ic do Ar statement Ic while Ar ( expression )
.It Ic break
.It Ic continue
.It Xo Ic {
.Op Ar statement ...
.Ic }
.Xc
.It Xo Ar expression
.No # commonly
.Ar var No = Ar expression
.Xc
.It Xo Ic print
.Op Ar expression-list
.Op > Ns Ar expression
.Xc
.It Xo Ic printf Ar format
.Op Ar ... , expression-list
.Op > Ns Ar expression
.Xc
.It Ic return Op Ar expression
.It Xo Ic next
.No # skip remaining patterns on this input line
.Xc
.It Xo Ic nextfile
.No # skip rest of this file, open next, start at top
.Xc
.It Xo Ic delete
.Sm off
.Ar array Ic \&[ Ar expression Ic \&]
.Sm on
.No # delete an array element
.Xc
.It Xo Ic delete Ar array
.No # delete all elements of array
.Xc
.It Xo Ic exit
.Op Ar expression
.No # exit immediately; status is Ar expression
.Xc
.El
.Pp
Statements are terminated by
semicolons, newlines or right braces.
An empty
.Ar expression-list
stands for
.Ar $0 .
String constants are quoted
.Li \&"" ,
with the usual C escapes recognized within
(see
.Xr printf 1
for a complete list of these).
Expressions take on string or numeric values as appropriate,
and are built using the operators
.Ic + \- * / % ^
.Pq exponentiation ,
and concatenation
.Pq indicated by whitespace .
The operators
.Ic \&! ++ \-\- += \-= *= /= %= ^=
.Ic > >= < <= == != ?:
are also available in expressions.
Variables may be scalars, array elements
(denoted
.Li x[i] )
or fields.
Variables are initialized to the null string.
Array subscripts may be any string,
not necessarily numeric;
this allows for a form of associative memory.
Multiple subscripts such as
.Li [i,j,k]
are permitted; the constituents are concatenated,
separated by the value of
.Va SUBSEP
.Pq see the section on variables below .
.Pp
The
.Ic print
statement prints its arguments on the standard output
(or on a file if
.Pf > Ar file
or
.Pf >> Ar file
is present or on a pipe if
.Pf |\ \& Ar cmd
is present), separated by the current output field separator,
and terminated by the output record separator.
.Ar file
and
.Ar cmd
may be literal names or parenthesized expressions;
identical string values in different statements denote
the same open file.
The
.Ic printf
statement formats its expression list according to the format
(see
.Xr printf 1 ) .
.Pp
Patterns are arbitrary Boolean combinations
(with
.Ic "\&! || &&" )
of regular expressions and
relational expressions.
.Nm
supports extended regular expressions
.Pq EREs .
See
.Xr re_format 7
for more information on regular expressions.
Isolated regular expressions
in a pattern apply to the entire line.
Regular expressions may also occur in
relational expressions, using the operators
.Ic ~
and
.Ic !~ .
.Pf / Ar re Ns /
is a constant regular expression;
any string (constant or variable) may be used
as a regular expression, except in the position of an isolated regular expression
in a pattern.
.Pp
A pattern may consist of two patterns separated by a comma;
in this case, the action is performed for all lines
from an occurrence of the first pattern
through an occurrence of the second.
.Pp
A relational expression is one of the following:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It Ar expression matchop regular-expression
.It Ar expression relop expression
.It Ar expression Ic in Ar array-name
.It Xo Ic \&( Ns
.Ar expr , expr , \&... Ns Ic \&) in
.Ar array-name
.Xc
.El
.Pp
where a
.Ar relop
is any of the six relational operators in C, and a
.Ar matchop
is either
.Ic ~
(matches)
or
.Ic !~
(does not match).
A conditional is an arithmetic expression,
a relational expression,
or a Boolean combination
of these.
.Pp
The special patterns
.Ic BEGIN
and
.Ic END
may be used to capture control before the first input line is read
and after the last.
.Ic BEGIN
and
.Ic END
do not combine with other patterns.
.Pp
Variable names with special meanings:
.Pp
.Bl -tag -width "FILENAME " -compact
.It Va ARGC
Argument count, assignable.
.It Va ARGV
Argument array, assignable;
non-null members are taken as filenames.
.It Va CONVFMT
Conversion format when converting numbers
(default
.Qq Li %.6g ) .
.It Va ENVIRON
Array of environment variables; subscripts are names.
.It Va FILENAME
The name of the current input file.
.It Va FNR
Ordinal number of the current record in the current file.
.It Va FS
Regular expression used to separate fields; also settable
by option
.Fl F Ar fs .
.It Va NF
Number of fields in the current record.
.Va $NF
can be used to obtain the value of the last field in the current record.
.It Va NR
Ordinal number of the current record.
.It Va OFMT
Output format for numbers (default
.Qq Li %.6g ) .
.It Va OFS
Output field separator (default blank).
.It Va ORS
Output record separator (default newline).
.It Va RLENGTH
The length of the string matched by the
.Fn match
function.
.It Va RS
Input record separator (default newline).
.It Va RSTART
The starting position of the string matched by the
.Fn match
function.
.It Va SUBSEP
Separates multiple subscripts (default 034).
.El
.Sh FUNCTIONS
The awk language has a variety of built-in functions:
arithmetic, string, input/output, general, and bit-operation.
.Pp
Functions may be defined (at the position of a pattern-action statement)
thusly:
.Pp
.Dl function foo(a, b, c) { ...; return x }
.Pp
Parameters are passed by value if scalar, and by reference if array name;
functions may be called recursively.
Parameters are local to the function; all other variables are global.
Thus local variables may be created by providing excess parameters in
the function definition.
.Ss Arithmetic Functions
.Bl -tag -width "atan2(y, x)"
.It Fn atan2 y x
Return the arctangent of
.Fa y Ns / Ns Fa x
in radians.
.It Fn cos x
Return the cosine of
.Fa x ,
where
.Fa x
is in radians.
.It Fn exp x
Return the exponential of
.Fa x .
.It Fn int x
Return
.Fa x
truncated to an integer value.
.It Fn log x
Return the natural logarithm of
.Fa x .
.It Fn rand
Return a random number,
.Fa n ,
such that
.Sm off
.Pf 0 \*(Le Fa n No \*(Lt 1 .
.Sm on
.It Fn sin x
Return the sine of
.Fa x ,
where
.Fa x
is in radians.
.It Fn sqrt x
Return the square root of
.Fa x .
.It Fn srand expr
Sets seed for
.Fn rand
to
.Fa expr
and returns the previous seed.
If
.Fa expr
is omitted, the time of day is used instead.
.El
.Ss String Functions
.Bl -tag -width "split(s, a, fs)"
.It Fn gsub r t s
The same as
.Fn sub
except that all occurrences of the regular expression are replaced.
.Fn gsub
returns the number of replacements.
.It Fn index s t
The position in
.Fa s
where the string
.Fa t
occurs, or 0 if it does not.
.It Fn length s
The length of
.Fa s
taken as a string,
or of
.Va $0
if no argument is given.
.It Fn match s r
The position in
.Fa s
where the regular expression
.Fa r
occurs, or 0 if it does not.
The variable
.Va RSTART
is set to the starting position of the matched string
.Pq which is the same as the returned value
or zero if no match is found.
The variable
.Va RLENGTH
is set to the length of the matched string,
or \-1 if no match is found.
.It Fn split s a fs
Splits the string
.Fa s
into array elements
.Va a[1] , a[2] , ... , a[n]
and returns
.Va n .
The separation is done with the regular expression
.Ar fs
or with the field separator
.Va FS
if
.Ar fs
is not given.
An empty string as field separator splits the string
into one array element per character.
.It Fn sprintf fmt expr ...
The string resulting from formatting
.Fa expr , ...
according to the
.Xr printf 1
format
.Fa fmt .
.It Fn sub r t s
Substitutes
.Fa t
for the first occurrence of the regular expression
.Fa r
in the string
.Fa s .
If
.Fa s
is not given,
.Va $0
is used.
An ampersand
.Pq Sq &
in
.Fa t
is replaced in string
.Fa s
with regular expression
.Fa r .
A literal ampersand can be specified by preceding it with two backslashes
.Pq Sq \e\e .
A literal backslash can be specified by preceding it with another backslash
.Pq Sq \e\e .
.Fn sub
returns the number of replacements.
.It Fn substr s m n
Return at most the
.Fa n Ns -character
substring of
.Fa s
that begins at position
.Fa m
counted from 1.
If
.Fa n
is omitted, or if
.Fa n
specifies more characters than are left in the string,
the length of the substring is limited by the length of
.Fa s .
.It Fn tolower str
Returns a copy of
.Fa str
with all upper-case characters translated to their
corresponding lower-case equivalents.
.It Fn toupper str
Returns a copy of
.Fa str
with all lower-case characters translated to their
corresponding upper-case equivalents.
.El
.Ss Input/Output and General Functions
.Bl -tag -width "getline [var] < file"
.It Fn close expr
Closes the file or pipe
.Fa expr .
.Fa expr
should match the string that was used to open the file or pipe.
.It Ar cmd | Ic getline Op Va var
Read a record of input from a stream piped from the output of
.Ar cmd .
If
.Va var
is omitted, the variables
.Va $0
and
.Va NF
are set.
Otherwise
.Va var
is set.
If the stream is not open, it is opened.
As long as the stream remains open, subsequent calls
will read subsequent records from the stream.
The stream remains open until explicitly closed with a call to
.Fn close .
.Ic getline
returns 1 for a successful input, 0 for end of file, and \-1 for an error.
.It Fn fflush [expr]
Flushes any buffered output for the file or pipe
.Fa expr ,
or all open files or pipes if
.Fa expr
is omitted.
.Fa expr
should match the string that was used to open the file or pipe.
.It Ic getline
Sets
.Va $0
to the next input record from the current input file.
This form of
.Ic getline
sets the variables
.Va NF ,
.Va NR ,
and
.Va FNR .
.Ic getline
returns 1 for a successful input, 0 for end of file, and \-1 for an error.
.It Ic getline Va var
Sets
.Va $0
to variable
.Va var .
This form of
.Ic getline
sets the variables
.Va NR
and
.Va FNR .
.Ic getline
returns 1 for a successful input, 0 for end of file, and \-1 for an error.
.It Xo
.Ic getline Op Va var
.Pf \ \&< Ar file
.Xc
Sets
.Va $0
to the next record from
.Ar file .
If
.Va var
is omitted, the variables
.Va $0
and
.Va NF
are set.
Otherwise
.Va var
is set.
If
.Ar file
is not open, it is opened.
As long as the stream remains open, subsequent calls will read subsequent
records from
.Ar file .
.Ar file
remains open until explicitly closed with a call to
.Fn close .
.It Fn system cmd
Executes
.Fa cmd
and returns its exit status.
.El
.Ss Bit-Operation Functions
.Bl -tag -width "lshift(a, b)"
.It Fn compl x
Returns the bitwise complement of integer argument x.
.It Fn and x y
Performs a bitwise AND on integer arguments x and y.
.It Fn or x y
Performs a bitwise OR on integer arguments x and y.
.It Fn xor x y
Performs a bitwise Exclusive-OR on integer arguments x and y.
.It Fn lshift x n
Returns integer argument x shifted by n bits to the left.
.It Fn rshift x n
Returns integer argument x shifted by n bits to the right.
.El
.Sh EXIT STATUS
.Ex -std awk
.Pp
But note that the
.Ic exit
expression can modify the exit status.
.Sh EXAMPLES
Print lines longer than 72 characters:
.Pp
.Dl length($0) > 72
.Pp
Print first two fields in opposite order:
.Pp
.Dl { print $2, $1 }
.Pp
Same, with input fields separated by comma and/or blanks and tabs:
.Bd -literal -offset indent
BEGIN { FS = ",[ \et]*|[ \et]+" }
      { print $2, $1 }
.Ed
.Pp
Add up first column, print sum and average:
.Bd -literal -offset indent
{ s += $1 }
END { print "sum is", s, " average is", s/NR }
.Ed
.Pp
Print all lines between start/stop pairs:
.Pp
.Dl /start/, /stop/
.Pp
Simulate echo(1):
.Bd -literal -offset indent
BEGIN { # Simulate echo(1)
        for (i = 1; i < ARGC; i++) printf "%s ", ARGV[i]
        printf "\en"
        exit }
.Ed
.Pp
Print an error message to standard error:
.Bd -literal -offset indent
{ print "error!" > "/dev/stderr" }
.Ed
.Sh SEE ALSO
.Xr cut 1 ,
.Xr lex 1 ,
.Xr printf 1 ,
.Xr sed 1 ,
.Xr re_format 7 ,
.Xr script 7
.Rs
.%A A. V. Aho
.%A B. W. Kernighan
.%A P. J. Weinberger
.%T The AWK Programming Language
.%I Addison-Wesley
.%D 1988
.%O ISBN 0-201-07981-X
.Re
.Sh STANDARDS
The
.Nm
utility is compliant with the
.St -p1003.1-2008
specification,
except
.Nm
does not support {n,m} pattern matching.
.Pp
The flags
.Op Fl \&dV
and
.Op Fl safe ,
as well as the commands
.Cm fflush , compl , and , or ,
.Cm xor , lshift , rshift ,
are extensions to that specification.
.Sh HISTORY
An
.Nm
utility appeared in
.At v7 .
.Sh BUGS
There are no explicit conversions between numbers and strings.
To force an expression to be treated as a number add 0 to it;
to force it to be treated as a string concatenate
.Li \&""
to it.
.Pp
The scope rules for variables in functions are a botch;
the syntax is worse.
@


1.43
log
@fix placement of opening parentheses, and drop some .Xo while here
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.42 2014/12/15 20:31:40 tedu Exp $
d25 1
a25 1
.Dd $Mdocdate: December 15 2014 $
d288 1
a288 1
.Pf > Ns Ar file
d290 1
a290 1
.Pf >> Ns Ar file
d325 1
a325 1
.Pf / Ns Ar re Ns /
@


1.42
log
@.Xr cut which may be what you're really looking for.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.41 2014/03/17 21:48:51 jmc Exp $
d25 1
a25 1
.Dd $Mdocdate: March 17 2014 $
d202 5
a206 13
.It Xo Ic if ( Ar expression ) Ar statement
.Op Ic else Ar statement
.Xc
.It Ic while ( Ar expression ) Ar statement
.It Xo Ic for
.No ( Ar expression ; expression ; expression ) statement
.Xc
.It Xo Ic for
.No ( Ar var Ic in Ar array ) statement
.Xc
.It Xo Ic do
.Ar statement Ic while ( Ar expression )
.Xc
@


1.41
log
@as suggested by schwarze, reshuffle STANDARDS text detailing posix features
we don;t support next to the posix compat blurb, in order to make things a bit
clearer; this also makes the text more concise;

ok millert schwarze sobrado
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.40 2011/05/02 11:14:11 jmc Exp $
d25 1
a25 1
.Dd $Mdocdate: May 2 2011 $
d755 1
@


1.40
log
@no need to escape `|'; as discussed with schwartze
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.39 2011/03/22 15:55:43 jmc Exp $
d25 1
a25 1
.Dd $Mdocdate: March 22 2011 $
d774 4
a777 1
specification.
a786 3
.Pp
.Nm
does not support {n,m} pattern matching.
@


1.39
log
@some small tweaks from Michael W. Bombardieri;
ok sobrado
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.38 2011/02/07 00:02:50 schwarze Exp $
d25 1
a25 1
.Dd $Mdocdate: February 7 2011 $
d91 1
a91 1
.Ic print No \&| ,
@


1.38
log
@Between groff-1.15 and groff-1.20.1, the .Ns macro was changed to no
longer suppress spacing when used at the beginning of an input line,
and mandoc now follows the same behaviour as new groff.
Thus, sweep the tree and remove useless .Ns.
Most places found by jmc@@; ok jmc@@ kristaps@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.37 2010/10/01 07:06:16 jmc Exp $
d25 1
a25 1
.Dd $Mdocdate: October 1 2010 $
d631 1
a631 1
Flushes any buffered output for the file, pipe
d707 1
a707 1
Returns x shifted by n bits to the left.
d709 1
a709 1
Returns y shifted by n bits to the right.
@


1.37
log
@more EXIT STATUS tweaks; from Daniel Dickman
@
text
@d1 1
a1 2
.\"	$OpenBSD: awk.1,v 1.36 2010/08/25 19:21:04 deraadt Exp $
.\" EX/EE is a Bd
d25 1
a25 1
.Dd $Mdocdate: August 25 2010 $
d37 1
a37 2
.Oo Fl v Ar var Ns =
.Ns Ar value Oc
@


1.36
log
@get rid of the nawk hard link
ok millert guenther
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.35 2010/08/08 13:26:48 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: August 8 2010 $
d713 6
@


1.35
log
@convert some of the weirder displays into lists, to avoid mangling;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.34 2010/01/10 10:53:33 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: January 10 2010 $
a41 2
.Nm nawk
.Ar ...
@


1.34
log
@remove references to docs we no longer install;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.33 2009/02/08 17:15:09 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: February 8 2009 $
d204 3
a206 3
.Bd -unfilled -offset indent
.Ic if ( Xo
.Ar expression ) statement \&
d209 19
a227 14
.Ic while ( Ar expression ) statement
.Ic for ( Xo
.Ar expression ; expression ; expression ) statement
.Xc
.Ic for ( Xo
.Ar var Ic in Ar array ) statement
.Xc
.Ic do Ar statement Ic while ( Ar expression )
.Ic break
.Ic continue
.Ic { Oo Ar statement ... Oc Ic \& }
.Ar expression Xo
.No "# commonly" \&
.Ar var Ic = Ar expression
d229 1
a229 1
.Ic print Xo
d233 1
a233 1
.Ic printf Ar format Xo
d237 12
a248 10
.Ic return Op Ar expression
.Ic next Xo
.No "# skip remaining patterns on this input line"
.Xc
.Ic nextfile Xo
.No "# skip rest of this file, open next, start at top"
.Xc
.Ic delete Ar array Ns Xo
.Ic \&[ Ns Ar expression Ns Ic \&]
.No \& "# delete an array element"
d250 2
a251 2
.Ic delete Ar array Xo
.No "# delete all elements of array"
d253 1
a253 1
.Ic exit Xo
d255 1
a255 1
.No \& "# exit immediately; status is" Ar expression
d257 1
a257 1
.Ed
d349 6
a354 5
.Bd -unfilled -offset indent
.Ar expression matchop regular-expression
.Ar expression relop expression
.Ar expression Ic in Ar array-name
.Ic \&( Ns Xo
d356 1
a356 1
.Ar \& array-name
d358 1
a358 1
.Ed
@


1.33
log
@bump the posix reference in STANDARDS to IEEE Std 1003.1-2008, with a few
updates to follow;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.32 2008/09/04 15:51:28 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: September 4 2008 $
a749 3
.Pp
"Awk \(em A Pattern Scanning and Processing Language",
.Pa /usr/share/doc/usd/16.awk/ .
@


1.32
log
@+awk does not support {n,m} pattern matching
noted by Vadim Zhukov, though slightly different (doc) fix committed;

ok millert
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.31 2008/07/25 05:09:55 deraadt Exp $
d26 1
a26 1
.Dd $Mdocdate: July 25 2008 $
d766 1
a766 1
.St -p1003.1-2004
@


1.31
log
@repair .Pq use; Alan R. S. Bueno
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.30 2008/06/04 17:14:07 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate: June 4 2008 $
d777 3
@


1.30
log
@tweak previous, and arrange the text to read a little better;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.29 2008/06/04 14:04:42 pyr Exp $
d287 1
a287 1
.Pq see the section on variables below ) .
@


1.29
log
@Extend awk with bitwise operations. This is an extension to the awk
spec and documented as such, but comes in handy from time to time.
The prototypes make it compatible with a similar GNU awk extension.

ok millert@@, enthusiasm from deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.28 2007/06/27 21:10:39 jmc Exp $
d26 1
a26 1
.Dd $Mdocdate$
d428 12
a439 1
arithmetic, string, input/output and general.
d692 1
a692 1
.Ss Bit-Operation functions
d697 1
a697 1
Performs a bitwise AND on integer arguments x and y
d699 1
a699 1
Performs a bitwise OR on integer arguments x and y
d701 1
a701 1
Performs a bitwise Exclusive-OR on integer arguments x and y
a706 11
.Pp
Functions may be defined (at the position of a pattern-action statement)
thusly:
.Pp
.Dl function foo(a, b, c) { ...; return x }
.Pp
Parameters are passed by value if scalar, and by reference if array name;
functions may be called recursively.
Parameters are local to the function; all other variables are global.
Thus local variables may be created by providing excess parameters in
the function definition.
d773 3
a775 2
as well as the command
.Cm fflush , compl , and , or , xor , lshift , rshift
@


1.28
log
@printf(1) is the correct reference here, not printf(3);
from otto; ok millert
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.27 2007/05/31 19:20:07 jmc Exp $
d681 15
d774 1
a774 1
.Cm fflush ,
@


1.27
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.26 2007/05/30 04:41:33 jmc Exp $
d310 1
a310 1
.Xr printf 3 ) .
d533 1
a533 1
.Xr printf 3
a732 1
.Xr printf 3 ,
@


1.26
log
@- use a consistent text for STANDARDS
- note which options are extensions to POSIX
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.25 2007/01/29 19:41:10 jmc Exp $
d26 1
a26 1
.Dd June 29, 1996
@


1.25
log
@sync the -f description w/ its synopsis;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.24 2006/03/29 15:29:55 jmc Exp $
d748 14
@


1.24
log
@- document return value of cmd | getline [var]
- document fflush w/o arg

from matthias kilian;
ok otto
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.23 2005/05/12 09:18:24 jmc Exp $
d84 1
a84 1
.It Fl f Ar filename
d86 1
a86 1
.Ar filename
@


1.23
log
@.Xr script 7
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.22 2004/10/04 21:40:53 jmc Exp $
d613 8
a620 3
.It Fn fflush expr
Flushes any buffered output for the file or pipe
.Fa expr .
@


1.22
log
@refer to re_format.7 rather than egrep.1 for a description of EREs;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.21 2004/04/19 18:29:17 jmc Exp $
d729 2
a730 1
.Xr re_format 7
@


1.21
log
@point people to usd/psd docs;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.20 2003/12/19 12:48:02 jmc Exp $
d317 6
a322 2
Regular expressions are as in
.Xr egrep 1 .
a724 1
.Xr egrep 1 ,
d728 2
a729 1
.Xr printf 3
@


1.20
log
@- adjust some list widths for better postscript output
- reference printf(1) for a list of C escapes
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.19 2003/12/19 09:27:36 jmc Exp $
d726 3
@


1.19
log
@add an example showing how to print to standard error;
suggested by otto@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.18 2003/12/18 20:22:51 jmc Exp $
d70 1
a70 1
.Bl -tag -width Ds
d260 4
a263 1
with the usual C escapes recognized within.
d267 3
a269 1
(exponentiation), and concatenation (indicated by whitespace).
d376 1
a376 1
.Bl -tag -width "FILENAME" -compact
d723 1
@


1.18
log
@document various aspects of awk behaviour:

- when newlines are permissible
- effects of null RS
- $NF can be used to find value of last field
- -F [ ] can be used to set FS to a single space
- t and \t are synonyms when used with FS. use [t] for a literal `t'.
- make [prog | -f profile] optional again in SYNOPSIS

Also move the functions to the end of the page for a more logical layout.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.17 2003/12/16 11:18:37 jmc Exp $
d709 5
@


1.17
log
@expand documentation of built-ins:
group them according to POSIX - arithmetic, string, I/O, general
and better document how they work.

use section headers for more logical navigation.

ok jose@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.16 2003/12/12 19:50:55 jmc Exp $
d40 1
a40 1
.Ar prog | Fl f Ar progfile
d100 1
a100 3
see
.Sx VARIABLES
below).
d124 12
d137 1
a137 1
or by regular expression
d148 21
d179 23
d282 1
a282 3
(see
.Sx VARIABLES
below).
d306 111
a677 109
.Sh PATTERNS
Patterns are arbitrary Boolean combinations
(with
.Ic "\&! || &&" )
of regular expressions and
relational expressions.
Regular expressions are as in
.Xr egrep 1 .
Isolated regular expressions
in a pattern apply to the entire line.
Regular expressions may also occur in
relational expressions, using the operators
.Ic ~
and
.Ic !~ .
.Pf / Ns Ar re Ns /
is a constant regular expression;
any string (constant or variable) may be used
as a regular expression, except in the position of an isolated regular expression
in a pattern.
.Pp
A pattern may consist of two patterns separated by a comma;
in this case, the action is performed for all lines
from an occurrence of the first pattern
through an occurrence of the second.
.Pp
A relational expression is one of the following:
.Bd -unfilled -offset indent
.Ar expression matchop regular-expression
.Ar expression relop expression
.Ar expression Ic in Ar array-name
.Ic \&( Ns Xo
.Ar expr , expr , \&... Ns Ic \&) in
.Ar \& array-name
.Xc
.Ed
.Pp
where a
.Ar relop
is any of the six relational operators in C, and a
.Ar matchop
is either
.Ic ~
(matches)
or
.Ic !~
(does not match).
A conditional is an arithmetic expression,
a relational expression,
or a Boolean combination
of these.
.Pp
The special patterns
.Ic BEGIN
and
.Ic END
may be used to capture control before the first input line is read
and after the last.
.Ic BEGIN
and
.Ic END
do not combine with other patterns.
.Sh VARIABLES
Variable names with special meanings:
.Pp
.Bl -tag -width "FILENAME" -compact
.It Va ARGC
Argument count, assignable.
.It Va ARGV
Argument array, assignable;
non-null members are taken as filenames.
.It Va CONVFMT
Conversion format used when converting numbers
(default
.Qq Li %.6g ) .
.It Va ENVIRON
Array of environment variables; subscripts are names.
.It Va FILENAME
The name of the current input file.
.It Va FNR
Ordinal number of the current record in the current file.
.It Va FS
Regular expression used to separate fields; also settable
by option
.Fl F Ar fs .
.It Va NF
Number of fields in the current record.
.It Va NR
Ordinal number of the current record.
.It Va OFMT
Output format for numbers (default
.Qq Li %.6g ) .
.It Va OFS
Output field separator (default blank).
.It Va ORS
Output record separator (default newline).
.It Va RLENGTH
The length of the string matched by the
.Fn match
function.
.It Va RS
Input record separator (default newline).
.It Va RSTART
The starting position of the string matched by the
.Fn match
function.
.It Va SUBSEP
Separates multiple subscripts (default 034).
.El
@


1.16
log
@- update SYNOPSIS
- standard options list
- document -V and -d[n]
- -mr and -mf no longer supported
- some formatting issues
- descriptions of examples before examples and indent examples
- update SEE ALSO

ok millert@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.15 2003/11/24 10:58:08 jmc Exp $
d90 2
a91 2
.Pf ( Ic print > ,
.Ic print >> ) ,
d94 3
a96 2
.Ar cmd Ic \&| getline ,
.Ic print \&| , system
d99 5
a103 3
.Pq Va ENVIRON .
This
is a first
d172 1
a172 1
.Op Ic > Ns Ar expression
d176 1
a176 1
.Op Ic > Ns Ar expression
d227 4
a230 1
.Va SUBSEP .
d236 1
a236 1
.Ic > Ns Ar file
d238 1
a238 1
.Ic >> Ns Ar file
d240 1
a240 1
.Ic \&| Ar cmd
d254 25
a278 26
The built-in function
.Fn close expr
closes the file or pipe
.Fa expr .
The built-in function
.Fn fflush expr
flushes any buffered output for the file or pipe
.Fa expr .
.Pp
The mathematical functions
.Fn exp ,
.Fn log ,
.Fn sqrt ,
.Fn sin ,
.Fn cos ,
and
.Fn atan2
are built in.
Other built-in functions:
.Bl -tag -width Fn
.It Fn length
The length of its argument
taken as a string,
or of
.Va $0
if no argument.
d280 16
a295 2
Random number on (0,1).
.It Fn srand
d298 2
d301 12
a312 10
.It Fn int
Truncates to an integer value.
.It Fn substr s m n
The
.Fa n Ns No -character
substring of
.Fa s
that begins at position
.Fa m
counted from 1.
d319 7
d332 1
a332 1
The variables
d334 4
a337 1
and
d339 2
a340 1
are set to the position and length of the matched string.
d357 7
d376 12
a387 2
.It Fn gsub r t s
Same as
d389 16
a404 17
except that all occurrences of the regular expression
are replaced;
.Fn sub
and
.Fn gsub
return the number of replacements.
.It Fn sprintf fmt expr ...
The string resulting from formatting
.Fa expr , ...
according to the
.Xr printf 3
format
.Fa fmt .
.It Fn system cmd
Executes
.Fa cmd
and returns its exit status.
d416 41
a456 3
.Pp
The
.Sq function
d458 3
a460 1
sets
d462 15
a476 3
to the next input record from the current input file;
.Ic getline < Ar file
sets
d480 29
a508 18
.Ic getline Va x
sets variable
.Va x
instead.
Finally,
.Ar cmd Ic \&| getline
pipes the output of
.Ar cmd
into
.Ic getline ;
each call of
.Ic getline
returns the next line of output from
.Ar cmd .
In all cases,
.Ic getline
returns 1 for a successful input,
0 for end of file, and \-1 for an error.
d510 6
d530 1
a530 1
.Ic / Ns Ar re Ns Ic /
d577 1
a577 1
.Pp
d611 4
d617 4
a623 11
.Pp
Functions may be defined (at the position of a pattern-action statement)
thusly:
.Pp
.Dl function foo(a, b, c) { ...; return x }
.Pp
Parameters are passed by value if scalar, and by reference if array name;
functions may be called recursively.
Parameters are local to the function; all other variables are global.
Thus local variables may be created by providing excess parameters in
the function definition.
@


1.15
log
@typo from Michael Knudsen;
also, kill some .Pp's before displays, and add one after;
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.14 2003/09/02 18:50:06 jmc Exp $
d34 3
d38 3
a40 5
.Op Fl v Ar var=value
.Op Fl safe
.Op Fl mr Ar n
.Op Fl mf Ar n
.Op Ar prog | Fl f Ar progfile
d50 1
a50 2
or in one or more files
specified as
d52 1
a52 2
With each pattern
there can be an associated action that will be performed
d60 1
a60 1
.Sq Pa \-
d65 1
a65 1
.Ar var=value
d68 15
a82 13
The option
.Fl v
followed by
.Ar var=value
is an assignment to be done before
.Ar prog
is executed;
any number of
.Fl v
options may be present.
The
.Fl F Ar fs
option defines the input field separator to be the regular expression
d84 8
a91 7
The
.Fl safe
option disables file output
.Po
.Ic print Ic > ,
.Ic print Ic >> ,
.Pc
d100 3
a102 1
is a first (and not very reliable) approximation to a
d105 17
a121 1
.Nm awk .
a134 8
To compensate for inadequate implementation of storage management,
the
.Fl mr
option can be used to set the maximum size of the input record,
and the
.Fl mf
option to set the maximum number of fields.
.Pp
d209 2
a210 1
.Ic \&! ++ \-\- += \-= *= /= %= ^= > >= < <= == != ?:
d269 1
a269 1
the length of its argument
d275 1
a275 1
random number on (0,1)
d277 1
a277 1
sets seed for
d281 1
a281 1
truncates to an integer value.
d283 1
a283 1
the
d291 1
a291 1
the position in
d297 1
a297 1
the position in
d308 1
a308 1
splits the string
d324 1
a324 1
substitutes
d336 1
a336 1
same as
d345 1
a345 1
the string resulting from formatting
d352 1
a352 1
executes
d356 1
a356 1
returns a copy of
d361 1
a361 1
returns a copy of
d461 6
a466 1
.Bl -tag -width Va -compact
d468 1
a468 1
conversion format used when converting numbers
d470 7
a476 1
.Qq Li %.6g )
d478 1
a478 1
regular expression used to separate fields; also settable
d482 1
a482 1
number of fields in the current record
d484 4
a487 7
ordinal number of the current record
.It Va FNR
ordinal number of the current record in the current file
.It Va FILENAME
the name of the current input file
.It Va RS
input record separator (default newline)
d489 1
a489 1
output field separator (default blank)
d491 3
a493 4
output record separator (default newline)
.It Va OFMT
output format for numbers (default
.Qq Li %.6g )
d495 1
a495 8
separates multiple subscripts (default 034)
.It Va ARGC
argument count, assignable
.It Va ARGV
argument array, assignable;
non-null members are taken as filenames
.It Va ENVIRON
array of environment variables; subscripts are names.
d503 1
a503 1
Parameters are passed by value if scalar and by reference if array name;
d509 2
d512 2
a513 1
Print lines longer than 72 characters.
d516 2
a517 1
Print first two fields in opposite order.
d522 2
a523 1
Same, with input fields separated by comma and/or blanks and tabs.
d528 2
a529 1
Add up first column, print sum and average.
d532 2
a533 1
Print all lines between start/stop pairs.
d541 1
d543 2
a544 1
.Xr sed 1
@


1.14
log
@escape punctuation;
ok deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.13 2003/06/30 23:59:00 millert Exp $
a134 1
.Pp
a253 1
.Pp
d407 1
a407 1
though an occurrence of the second.
d419 1
a500 1
.Pp
a505 1
.Pp
a513 1
.Pp
@


1.13
log
@Awk first appeared in appeared in Version 7 AT&T UNIX.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.12 2003/06/10 09:12:09 jmc Exp $
d198 1
a198 1
.Ic ! ++ \-\- += \-= *= /= %= ^= > >= < <= == != ?:
d388 1
a388 1
.Ic "! || &&" )
@


1.12
log
@- section reorder
- COMPATIBILITY merge
- macro cleanup
- kill whitespace at EOL
- new sentence, new line

ssh pages ok markus@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.11 2003/02/18 07:51:08 jmc Exp $
d537 1
a537 1
AT&T
d539 2
a540 3
by B. W. Kernighan was updated for
.Bx 4.4
and again in 1996.
@


1.11
log
@copyrights added;

bootpef(8), pppd(8): Carnegie Mellon
map-mbone(8), mrinfo(8): Xerox
pdisk(8): Apple
awk(1): Lucent
sectok(3): University of Michigan
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.10 2003/01/05 09:37:36 pvalchev Exp $
d6 1
a6 1
.\" 
d16 1
a16 1
.\" 
d392 1
a392 1
.Xr egrep  1 .
@


1.10
log
@add missing bracket; jmc@@prioris.mini.pw.edu.pl
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.9 2002/07/17 21:48:56 millert Exp $
d3 23
@


1.9
log
@Fix omission in description of FS variable; from tedu
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.8 2000/11/10 05:10:21 aaron Exp $
d212 1
a212 1
.Xr printf 3 .
@


1.8
log
@- Section shuffling: comply to the section ordering outlined in mdoc(7).
- Some .Nm trimming.
- .Sh AUTHOR -> .Sh AUTHORS
- Other miscellaneous fixes here and there.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.7 2000/08/30 13:37:51 aaron Exp $
d434 1
a434 1
.Fl fs .
@


1.7
log
@mdoc'd awk(1) man page; thanks d@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.6 1999/06/05 01:21:18 aaron Exp $
d513 6
a527 6
.Sh HISTORY
AT&T
.Nm
by B. W. Kernighan was updated for
.Bx 4.4
and again in 1996.
@


1.6
log
@- remove trailing white space
- remove arguments from .Os macros
- remove arguments from .Nm macros, where appropriate
- some more Dq/Sq/Ql insanity
- still lots to do in the usr.bin tree... :/
@
text
@d1 21
a21 44
.\"	$OpenBSD: awk.1,v 1.5 1998/03/03 01:56:00 angelos Exp $
.de EX
.nf
.ft CW
..
.de EE
.br
.fi
.ft 1
..
.TH AWK 1
.CT 1 files prog_other
.SH NAME
awk \- pattern-directed scanning and processing language
.SH SYNOPSIS
.B awk|nawk
[
.BI \-F
.I fs
]
[
.BI \-v
.I var=value
]
[
.BI \-safe
]
[
.BI \-mr n
]
[
.BI \-mf n
]
[
.I 'prog'
|
.BI \-f
.I progfile
]
[
.I file ...
]
.SH DESCRIPTION
.I Awk
d23 1
a23 1
.I file
d25 1
a25 1
.IR prog
d28 1
a28 2
.B \-f
.IR progfile .
d32 1
a32 1
.I file
d38 1
a38 1
.B \-
d41 1
a41 1
.IR file
d43 1
a43 1
.I var=value
d47 1
a47 1
.B \-v
d49 1
a49 1
.I var=value
d51 1
a51 1
.I prog
d54 1
a54 1
.B \-v
d57 1
a57 2
.B \-F
.IR fs
d59 1
a59 1
.IR fs.
d61 20
a80 6
.B \-safe
option disables file output (print >, print >>), process creation
(cmd|getline, print |, system), and access to the environment (ENVIRON). This
is a first (and not very reliable) approximation to a "safe" version of awk.
.PP
An input line is normally made up of fields separated by white space,
d82 1
a82 1
.BR FS .
d84 3
a86 4
.BR $1 ,
.BR $2 ,
\&..., while
.B $0
d89 1
a89 1
.BR FS
d91 1
a91 1
.PP
d94 1
a94 1
.B \-mr
d97 1
a97 1
.B \-mf
d99 1
a99 1
.PP
d101 3
a103 3
.IP
.IB pattern " { " action " }
.PP
d105 1
a105 1
.BI { " action " }
d109 1
a109 1
.PP
d112 49
a160 28
.PP
.EX
.ta \w'\f(CWdelete array[expression]'u
.RS
.nf
.ft CW
if(\fI expression \fP)\fI statement \fP\fR[ \fPelse\fI statement \fP\fR]\fP
while(\fI expression \fP)\fI statement\fP
for(\fI expression \fP;\fI expression \fP;\fI expression \fP)\fI statement\fP
for(\fI var \fPin\fI array \fP)\fI statement\fP
do\fI statement \fPwhile(\fI expression \fP)
break
continue
{\fR [\fP\fI statement ... \fP\fR] \fP}
\fIexpression\fP	#\fR commonly\fP\fI var = expression\fP
print\fR [ \fP\fIexpression-list \fP\fR] \fP\fR[ \fP>\fI expression \fP\fR]\fP
printf\fI format \fP\fR[ \fP,\fI expression-list \fP\fR] \fP\fR[ \fP>\fI expression \fP\fR]\fP
return\fR [ \fP\fIexpression \fP\fR]\fP
next	#\fR skip remaining patterns on this input line\fP
nextfile	#\fR skip rest of this file, open next, start at top\fP
delete\fI array\fP[\fI expression \fP]	#\fR delete an array element\fP
delete\fI array\fP	#\fR delete all elements of array\fP
exit\fR [ \fP\fIexpression \fP\fR]\fP	#\fR exit immediately; status is \fP\fIexpression\fP
.fi
.RE
.EE
.DT
.PP
d164 1
a164 1
.I expression-list
d166 3
a168 2
.BR $0 .
String constants are quoted \&\f(CW"\ "\fR,
d172 2
a173 2
.B + \- * / % ^
(exponentiation), and concatenation (indicated by white space).
d175 1
a175 2
.B
! ++ \-\- += \-= *= /= %= ^= > >= < <= == != ?:
d179 1
a179 1
.IB x  [ i ] )
d186 1
a186 1
.B [i,j,k]
d189 2
a190 2
.BR SUBSEP .
.PP
d192 1
a192 1
.B print
d195 1
a195 1
.BI > file
d197 1
a197 1
.BI >> file
d199 1
a199 1
.BI | cmd
d202 1
a202 1
.I file
d204 1
a204 1
.I cmd
d209 1
a209 1
.B printf
d212 1
a212 1
.IR printf (3)) .
d214 1
a214 1
.BI close( expr )
d216 1
a216 1
.IR expr .
d218 1
a218 1
.BI fflush( expr )
d220 2
a221 2
.IR expr .
.PP
d223 5
a227 5
.BR exp ,
.BR log ,
.BR sqrt ,
.BR sin ,
.BR cos ,
d229 1
a229 1
.BR atan2
d232 3
a234 3
.TF length
.TP
.B length
d238 1
a238 1
.B $0
d240 1
a240 2
.TP
.B rand
d242 1
a242 2
.TP
.B srand
d244 1
a244 1
.B rand
d246 3
a248 5
.TP
.B int
truncates to an integer value
.TP
.BI substr( s , " m" , " n\fB)
d250 1
a250 1
.IR n -character
d252 1
a252 1
.I s
d254 1
a254 1
.IR m
d256 1
a256 2
.TP
.BI index( s , " t" )
d258 1
a258 1
.I s
d260 1
a260 1
.I t
d262 1
a262 2
.TP
.BI match( s , " r" )
d264 1
a264 1
.I s
d266 1
a266 1
.I r
d269 1
a269 1
.B RSTART
d271 1
a271 1
.B RLENGTH
d273 1
a273 2
.TP
.BI split( s , " a" , " fs\fB)
d275 1
a275 1
.I s
d277 1
a277 4
.IB a [1] ,
.IB a [2] ,
\&...,
.IB a [ n ] ,
d279 1
a279 1
.IR n .
d281 1
a281 1
.I fs
d283 1
a283 1
.B FS
d285 1
a285 1
.I fs
d289 1
a289 2
.TP
.BI sub( r , " t" , " s\fB)
d291 1
a291 1
.I t
d293 1
a293 1
.I r
d295 1
a295 1
.IR s .
d297 1
a297 1
.I s
d299 1
a299 1
.B $0
d301 1
a301 2
.TP
.B gsub
d303 1
a303 1
.B sub
d306 1
a306 1
.B sub
d308 1
a308 1
.B gsub
d310 1
a310 2
.TP
.BI sprintf( fmt , " expr" , " ...\fB )
d312 1
a312 1
.I expr ...
d314 1
a314 1
.IR printf (3)
d316 2
a317 3
.I fmt
.TP
.BI system( cmd )
d319 3
a321 4
.I cmd
and returns its exit status
.TP
.BI tolower( str )
d323 1
a323 1
.I str
d326 1
a326 2
.TP
.BI toupper( str )
d328 1
a328 1
.I str
d331 5
a335 4
.PD
.PP
The ``function''
.B getline
d337 1
a337 1
.B $0
d339 1
a339 2
.B getline
.BI < file
d341 1
a341 1
.B $0
d343 2
a344 3
.IR file .
.B getline
.I x
d346 1
a346 1
.I x
d349 1
a349 1
.IB cmd " | getline
d351 1
a351 1
.I cmd
d353 1
a353 1
.BR getline ;
d355 1
a355 1
.B getline
d357 1
a357 1
.IR cmd .
d359 1
a359 1
.B getline
d362 1
a362 1
.PP
d365 1
a365 1
.BR "! || &&" )
d369 1
a369 3
.IR egrep ;
see
.IR grep (1).
d374 1
a374 1
.BR ~
d376 2
a377 2
.BR !~ .
.BI / re /
d382 1
a382 1
.PP
d387 1
a387 1
.PP
d389 15
a403 12
.IP
.I expression matchop regular-expression
.br
.I expression relop expression
.br
.IB expression " in " array-name
.br
.BI ( expr , expr,... ") in " array-name
.PP
where a relop is any of the six relational operators in C,
and a matchop is either
.B ~
d406 1
a406 1
.B !~
d412 1
a412 1
.PP
d414 1
a414 1
.B BEGIN
d416 1
a416 1
.B END
d419 1
a419 1
.B BEGIN
d421 1
a421 1
.B END
d423 1
a423 1
.PP
d425 3
a427 3
.TF FILENAME
.TP
.B CONVFMT
d430 2
a431 3
.BR "%.6g" )
.TP
.B FS
d434 2
a435 3
.BI \-F fs.
.TP
.BR NF
d437 1
a437 2
.TP
.B NR
d439 1
a439 2
.TP
.B FNR
d441 1
a441 2
.TP
.B FILENAME
d443 1
a443 2
.TP
.B RS
d445 1
a445 2
.TP
.B OFS
d447 1
a447 2
.TP
.B ORS
d449 1
a449 2
.TP
.B OFMT
d451 2
a452 3
.BR "%.6g" )
.TP
.B SUBSEP
d454 1
a454 2
.TP
.B ARGC
d456 1
a456 2
.TP
.B ARGV
d459 1
a459 2
.TP
.B ENVIRON
d461 7
a467 7
.PD
.PP
Functions may be defined (at the position of a pattern-action statement) thus:
.IP
.B
function foo(a, b, c) { ...; return x }
.PP
d473 2
a474 5
.SH EXAMPLES
.TP
.EX
length($0) > 72
.EE
d476 2
a477 4
.TP
.EX
{ print $2, $1 }
.EE
d479 2
a480 2
.PP
.EX
d483 1
a483 3
.EE
.ns
.IP
d485 5
a489 9
.PP
.EX
.nf
	{ s += $1 }
END	{ print "sum is", s, " average is", s/NR }
.fi
.EE
.ns
.IP
d491 2
a492 4
.TP
.EX
/start/, /stop/
.EE
d494 20
a513 18
.PP
.EX
.nf
BEGIN	{	# Simulate echo(1)
	for (i = 1; i < ARGC; i++) printf "%s ", ARGV[i]
	printf "\en"
	exit }
.fi
.EE
.SH SEE ALSO
.IR lex (1),
.IR sed (1)
.br
A. V. Aho, B. W. Kernighan, P. J. Weinberger,
.I
The AWK Programming Language,
Addison-Wesley, 1988.  ISBN 0-201-07981-X
.SH BUGS
d517 3
a519 2
\&\f(CW""\fP to it.
.br
d522 6
@


1.5
log
@Document -safe option and update usage message.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.4 1998/02/03 00:24:01 millert Exp $
d61 1
a61 1
The file name 
d105 1
a105 1
the 
d116 1
a116 1
A missing 
d220 1
a220 1
.BR atan2 
d249 1
a249 1
.IR m 
d377 1
a377 1
.IR egrep ; 
d537 1
a537 1
.IR lex (1), 
@


1.4
log
@Remove stray "awk" at the beginning of the mam page.
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.3 1997/01/20 19:43:18 millert Exp $
d26 3
d85 5
@


1.3
log
@Latest research awk from June 29, 1996
@
text
@d1 1
a1 1
.\"	$OpenBSD: awk.1,v 1.2 1996/07/06 05:40:03 etheisen Exp $
a10 1
awk
@


1.2
log
@Should get installed as nawk as well.
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d429 1
d488 1
a488 1
.B
d490 1
d493 1
a493 1
.B
d495 1
d516 1
a516 1
.B
d518 1
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d1 1
d17 1
a17 1
.B awk
@

