head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.6
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.10
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.14
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.12
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.8
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.09.25.17.36.35;	author krw;	state Exp;
branches;
next	1.22;
commitid	HMK1W3pnlhTFy5WZ;

1.22
date	2016.04.12.19.43.38;	author millert;	state Exp;
branches;
next	1.21;
commitid	N4hljChJoPrXp8K6;

1.21
date	2015.03.27.10.09.30;	author tobiasu;	state Exp;
branches;
next	1.20;
commitid	CHng8oIIzCb5D0YV;

1.20
date	2011.09.28.19.27.18;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.13.17.58.19;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.06.20.38.33;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.02.15.19.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.23.02.43.45;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.01.15.34.26;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.28.03.07.40;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.04.00.42.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.04.02.38.58;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.09.58.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.12.08.23.09.45;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.04.20.17.31.29;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.04.18.17.06.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.08.25.16.17.11;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.01.24.23.11.31;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.20.19.43.22;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.42;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Mark FATAL() as __dead so clang doesn't report
use of uninitialized variables after calls to
FATAL().

ok millert@@ guenther@@
@
text
@/*	$OpenBSD: lib.c,v 1.22 2016/04/12 19:43:38 millert Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

#define DEBUG
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include "awk.h"
#include "ytab.h"

FILE	*infile	= NULL;
char	*file	= "";
char	*record;
int	recsize	= RECSIZE;
char	*fields;
int	fieldssize = RECSIZE;

Cell	**fldtab;	/* pointers to Cells */
char	inputFS[100] = " ";

#define	MAXFLD	2
int	nfields	= MAXFLD;	/* last allocated slot for $i */

int	donefld;	/* 1 = implies rec broken into fields */
int	donerec;	/* 1 = record is valid (no flds have changed) */

int	lastfld	= 0;	/* last used field */
int	argno	= 1;	/* current input argument number */
extern	Awkfloat *ARGC;

static Cell dollar0 = { OCELL, CFLD, NULL, "", 0.0, REC|STR|DONTFREE };
static Cell dollar1 = { OCELL, CFLD, NULL, "", 0.0, FLD|STR|DONTFREE };

void recinit(unsigned int n)
{
	if ( (record = (char *) malloc(n)) == NULL
	  || (fields = (char *) malloc(n+1)) == NULL
	  || (fldtab = (Cell **) calloc(nfields+1, sizeof(Cell *))) == NULL
	  || (fldtab[0] = (Cell *) malloc(sizeof(Cell))) == NULL )
		FATAL("out of space for $0 and fields");
	*record = '\0';
	*fldtab[0] = dollar0;
	fldtab[0]->sval = record;
	fldtab[0]->nval = tostring("0");
	makefields(1, nfields);
}

void makefields(int n1, int n2)		/* create $n1..$n2 inclusive */
{
	char temp[50];
	int i;

	for (i = n1; i <= n2; i++) {
		fldtab[i] = (Cell *) malloc(sizeof (struct Cell));
		if (fldtab[i] == NULL)
			FATAL("out of space in makefields %d", i);
		*fldtab[i] = dollar1;
		snprintf(temp, sizeof temp, "%d", i);
		fldtab[i]->nval = tostring(temp);
	}
}

void initgetrec(void)
{
	int i;
	char *p;

	for (i = 1; i < *ARGC; i++) {
		p = getargv(i); /* find 1st real filename */
		if (p == NULL || *p == '\0') {  /* deleted or zapped */
			argno++;
			continue;
		}
		if (!isclvar(p)) {
			setsval(lookup("FILENAME", symtab), p);
			return;
		}
		setclvar(p);	/* a commandline assignment before filename */
		argno++;
	}
	infile = stdin;		/* no filenames, so use stdin */
}

static int firsttime = 1;

int getrec(char **pbuf, int *pbufsize, int isrecord)	/* get next input record */
{			/* note: cares whether buf == record */
	int c;
	char *buf = *pbuf;
	uschar saveb0;
	int bufsize = *pbufsize, savebufsize = bufsize;

	if (firsttime) {
		firsttime = 0;
		initgetrec();
	}
	   dprintf( ("RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\n",
		*RS, *FS, *ARGC, *FILENAME) );
	if (isrecord) {
		donefld = 0;
		donerec = 1;
	}
	saveb0 = buf[0];
	buf[0] = 0;
	while (argno < *ARGC || infile == stdin) {
		   dprintf( ("argno=%d, file=|%s|\n", argno, file) );
		if (infile == NULL) {	/* have to open a new file */
			file = getargv(argno);
			if (file == NULL || *file == '\0') {	/* deleted or zapped */
				argno++;
				continue;
			}
			if (isclvar(file)) {	/* a var=value arg */
				setclvar(file);
				argno++;
				continue;
			}
			*FILENAME = file;
			   dprintf( ("opening file %s\n", file) );
			if (*file == '-' && *(file+1) == '\0')
				infile = stdin;
			else if ((infile = fopen(file, "r")) == NULL)
				FATAL("can't open file %s", file);
			setfval(fnrloc, 0.0);
		}
		c = readrec(&buf, &bufsize, infile);
		if (c != 0 || buf[0] != '\0') {	/* normal record */
			if (isrecord) {
				if (freeable(fldtab[0]))
					xfree(fldtab[0]->sval);
				fldtab[0]->sval = buf;	/* buf == record */
				fldtab[0]->tval = REC | STR | DONTFREE;
				if (is_number(fldtab[0]->sval)) {
					fldtab[0]->fval = atof(fldtab[0]->sval);
					fldtab[0]->tval |= NUM;
				}
			}
			setfval(nrloc, nrloc->fval+1);
			setfval(fnrloc, fnrloc->fval+1);
			*pbuf = buf;
			*pbufsize = bufsize;
			return 1;
		}
		/* EOF arrived on this file; set up next */
		if (infile != stdin)
			fclose(infile);
		infile = NULL;
		argno++;
	}
	buf[0] = saveb0;
	*pbuf = buf;
	*pbufsize = savebufsize;
	return 0;	/* true end of file */
}

void nextfile(void)
{
	if (infile != NULL && infile != stdin)
		fclose(infile);
	infile = NULL;
	argno++;
}

int readrec(char **pbuf, int *pbufsize, FILE *inf)	/* read one record into buf */
{
	int sep, c;
	char *rr, *buf = *pbuf;
	int bufsize = *pbufsize;

	if (strlen(*FS) >= sizeof(inputFS))
		FATAL("field separator %.10s... is too long", *FS);
	/*fflush(stdout); avoids some buffering problem but makes it 25% slower*/
	strlcpy(inputFS, *FS, sizeof inputFS);	/* for subsequent field splitting */
	if ((sep = **RS) == 0) {
		sep = '\n';
		while ((c=getc(inf)) == '\n' && c != EOF)	/* skip leading \n's */
			;
		if (c != EOF)
			ungetc(c, inf);
	}
	for (rr = buf; ; ) {
		for (; (c=getc(inf)) != sep && c != EOF; ) {
			if (rr-buf+1 > bufsize)
				if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 1"))
					FATAL("input record `%.30s...' too long", buf);
			*rr++ = c;
		}
		if (**RS == sep || c == EOF)
			break;
		if ((c = getc(inf)) == '\n' || c == EOF) /* 2 in a row */
			break;
		if (!adjbuf(&buf, &bufsize, 2+rr-buf, recsize, &rr, "readrec 2"))
			FATAL("input record `%.30s...' too long", buf);
		*rr++ = '\n';
		*rr++ = c;
	}
	if (!adjbuf(&buf, &bufsize, 1+rr-buf, recsize, &rr, "readrec 3"))
		FATAL("input record `%.30s...' too long", buf);
	*rr = 0;
	   dprintf( ("readrec saw <%s>, returns %d\n", buf, c == EOF && rr == buf ? 0 : 1) );
	*pbuf = buf;
	*pbufsize = bufsize;
	return c == EOF && rr == buf ? 0 : 1;
}

char *getargv(int n)	/* get ARGV[n] */
{
	Cell *x;
	char *s, temp[50];
	extern Array *ARGVtab;

	snprintf(temp, sizeof temp, "%d", n);
	if (lookup(temp, ARGVtab) == NULL)
		return NULL;
	x = setsymtab(temp, "", 0.0, STR, ARGVtab);
	s = getsval(x);
	   dprintf( ("getargv(%d) returns |%s|\n", n, s) );
	return s;
}

void setclvar(char *s)	/* set var=value from s */
{
	char *p;
	Cell *q;

	for (p=s; *p != '='; p++)
		;
	*p++ = 0;
	p = qstring(p, '\0');
	q = setsymtab(s, p, 0.0, STR, symtab);
	setsval(q, p);
	if (is_number(q->sval)) {
		q->fval = atof(q->sval);
		q->tval |= NUM;
	}
	   dprintf( ("command line set %s to |%s|\n", s, p) );
}


void fldbld(void)	/* create fields from current record */
{
	/* this relies on having fields[] the same length as $0 */
	/* the fields are all stored in this one array with \0's */
	/* possibly with a final trailing \0 not associated with any field */
	char *r, *fr, sep;
	Cell *p;
	int i, j, n;

	if (donefld)
		return;
	if (!isstr(fldtab[0]))
		getsval(fldtab[0]);
	r = fldtab[0]->sval;
	n = strlen(r);
	if (n > fieldssize) {
		xfree(fields);
		if ((fields = (char *) malloc(n+2)) == NULL) /* possibly 2 final \0s */
			FATAL("out of space for fields in fldbld %d", n);
		fieldssize = n;
	}
	fr = fields;
	i = 0;	/* number of fields accumulated here */
	strlcpy(inputFS, *FS, sizeof(inputFS));
	if (strlen(inputFS) > 1) {	/* it's a regular expression */
		i = refldbld(r, inputFS);
	} else if ((sep = *inputFS) == ' ') {	/* default whitespace */
		for (i = 0; ; ) {
			while (*r == ' ' || *r == '\t' || *r == '\n')
				r++;
			if (*r == 0)
				break;
			i++;
			if (i > nfields)
				growfldtab(i);
			if (freeable(fldtab[i]))
				xfree(fldtab[i]->sval);
			fldtab[i]->sval = fr;
			fldtab[i]->tval = FLD | STR | DONTFREE;
			do
				*fr++ = *r++;
			while (*r != ' ' && *r != '\t' && *r != '\n' && *r != '\0');
			*fr++ = 0;
		}
		*fr = 0;
	} else if ((sep = *inputFS) == 0) {		/* new: FS="" => 1 char/field */
		for (i = 0; *r != 0; r++) {
			char buf[2];
			i++;
			if (i > nfields)
				growfldtab(i);
			if (freeable(fldtab[i]))
				xfree(fldtab[i]->sval);
			buf[0] = *r;
			buf[1] = 0;
			fldtab[i]->sval = tostring(buf);
			fldtab[i]->tval = FLD | STR;
		}
		*fr = 0;
	} else if (*r != 0) {	/* if 0, it's a null field */
		/* subtlecase : if length(FS) == 1 && length(RS > 0)
		 * \n is NOT a field separator (cf awk book 61,84).
		 * this variable is tested in the inner while loop.
		 */
		int rtest = '\n';  /* normal case */
		if (strlen(*RS) > 0)
			rtest = '\0';
		for (;;) {
			i++;
			if (i > nfields)
				growfldtab(i);
			if (freeable(fldtab[i]))
				xfree(fldtab[i]->sval);
			fldtab[i]->sval = fr;
			fldtab[i]->tval = FLD | STR | DONTFREE;
			while (*r != sep && *r != rtest && *r != '\0')	/* \n is always a separator */
				*fr++ = *r++;
			*fr++ = 0;
			if (*r++ == 0)
				break;
		}
		*fr = 0;
	}
	if (i > nfields)
		FATAL("record `%.30s...' has too many fields; can't happen", r);
	cleanfld(i+1, lastfld);	/* clean out junk from previous record */
	lastfld = i;
	donefld = 1;
	for (j = 1; j <= lastfld; j++) {
		p = fldtab[j];
		if(is_number(p->sval)) {
			p->fval = atof(p->sval);
			p->tval |= NUM;
		}
	}
	setfval(nfloc, (Awkfloat) lastfld);
	if (dbg) {
		for (j = 0; j <= lastfld; j++) {
			p = fldtab[j];
			printf("field %d (%s): |%s|\n", j, p->nval, p->sval);
		}
	}
}

void cleanfld(int n1, int n2)	/* clean out fields n1 .. n2 inclusive */
{				/* nvals remain intact */
	Cell *p;
	int i;

	for (i = n1; i <= n2; i++) {
		p = fldtab[i];
		if (freeable(p))
			xfree(p->sval);
		p->sval = "";
		p->tval = FLD | STR | DONTFREE;
	}
}

void newfld(int n)	/* add field n after end of existing lastfld */
{
	if (n > nfields)
		growfldtab(n);
	cleanfld(lastfld+1, n);
	lastfld = n;
	setfval(nfloc, (Awkfloat) n);
}

Cell *fieldadr(int n)	/* get nth field */
{
	if (n < 0)
		FATAL("trying to access out of range field %d", n);
	if (n > nfields)	/* fields after NF are empty */
		growfldtab(n);	/* but does not increase NF */
	return(fldtab[n]);
}

void growfldtab(int n)	/* make new fields up to at least $n */
{
	int nf = 2 * nfields;
	size_t s;

	if (n > nf)
		nf = n;
	s = (nf+1) * (sizeof (struct Cell *));  /* freebsd: how much do we need? */
	if (s / sizeof(struct Cell *) - 1 == nf) /* didn't overflow */
		fldtab = (Cell **) realloc(fldtab, s);
	else					/* overflow sizeof int */
		xfree(fldtab);	/* make it null */
	if (fldtab == NULL)
		FATAL("out of space creating %d fields", nf);
	makefields(nfields+1, nf);
	nfields = nf;
}

int refldbld(const char *rec, const char *fs)	/* build fields from reg expr in FS */
{
	/* this relies on having fields[] the same length as $0 */
	/* the fields are all stored in this one array with \0's */
	char *fr;
	int i, tempstat, n;
	fa *pfa;

	n = strlen(rec);
	if (n > fieldssize) {
		xfree(fields);
		if ((fields = (char *) malloc(n+1)) == NULL)
			FATAL("out of space for fields in refldbld %d", n);
		fieldssize = n;
	}
	fr = fields;
	*fr = '\0';
	if (*rec == '\0')
		return 0;
	pfa = makedfa(fs, 1);
	   dprintf( ("into refldbld, rec = <%s>, pat = <%s>\n", rec, fs) );
	tempstat = pfa->initstat;
	for (i = 1; ; i++) {
		if (i > nfields)
			growfldtab(i);
		if (freeable(fldtab[i]))
			xfree(fldtab[i]->sval);
		fldtab[i]->tval = FLD | STR | DONTFREE;
		fldtab[i]->sval = fr;
		   dprintf( ("refldbld: i=%d\n", i) );
		if (nematch(pfa, rec)) {
			pfa->initstat = 2;	/* horrible coupling to b.c */
			   dprintf( ("match %s (%d chars)\n", patbeg, patlen) );
			strncpy(fr, rec, patbeg-rec);
			fr += patbeg - rec + 1;
			*(fr-1) = '\0';
			rec = patbeg + patlen;
		} else {
			   dprintf( ("no match %s\n", rec) );
			strlcpy(fr, rec, fields + fieldssize - fr);
			pfa->initstat = tempstat;
			break;
		}
	}
	return i;		
}

void recbld(void)	/* create $0 from $1..$NF if necessary */
{
	int i;
	char *r, *p;

	if (donerec == 1)
		return;
	r = record;
	for (i = 1; i <= *NF; i++) {
		p = getsval(fldtab[i]);
		if (!adjbuf(&record, &recsize, 1+strlen(p)+r-record, recsize, &r, "recbld 1"))
			FATAL("created $0 `%.30s...' too long", record);
		while ((*r = *p++) != 0)
			r++;
		if (i < *NF) {
			if (!adjbuf(&record, &recsize, 2+strlen(*OFS)+r-record, recsize, &r, "recbld 2"))
				FATAL("created $0 `%.30s...' too long", record);
			for (p = *OFS; (*r = *p++) != 0; )
				r++;
		}
	}
	if (!adjbuf(&record, &recsize, 2+r-record, recsize, &r, "recbld 3"))
		FATAL("built giant record `%.30s...'", record);
	*r = '\0';
	   dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, (void*)fldtab[0]) );

	if (freeable(fldtab[0]))
		xfree(fldtab[0]->sval);
	fldtab[0]->tval = REC | STR | DONTFREE;
	fldtab[0]->sval = record;

	   dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, (void*)fldtab[0]) );
	   dprintf( ("recbld = |%s|\n", record) );
	donerec = 1;
}

int	errorflag	= 0;

void yyerror(const char *s)
{
	SYNTAX("%s", s);
}

void SYNTAX(const char *fmt, ...)
{
	extern char *cmdname, *curfname;
	static int been_here = 0;
	va_list varg;

	if (been_here++ > 2)
		return;
	fprintf(stderr, "%s: ", cmdname);
	va_start(varg, fmt);
	vfprintf(stderr, fmt, varg);
	va_end(varg);
	fprintf(stderr, " at source line %d", lineno);
	if (curfname != NULL)
		fprintf(stderr, " in function %s", curfname);
	if (compile_time == 1 && cursource() != NULL)
		fprintf(stderr, " source file %s", cursource());
	fprintf(stderr, "\n");
	errorflag = 2;
	eprint();
}

void fpecatch(int sig)
{
	extern Node *curnode;
	char buf[1024];

	snprintf(buf, sizeof buf, "floating point exception\n");
	write(STDERR_FILENO, buf, strlen(buf));

	if (compile_time != 2 && NR && *NR > 0) {
		snprintf(buf, sizeof buf, " input record number %d", (int) (*FNR));
		write(STDERR_FILENO, buf, strlen(buf));

		if (strcmp(*FILENAME, "-") != 0) {
			snprintf(buf, sizeof buf, ", file %s", *FILENAME);
			write(STDERR_FILENO, buf, strlen(buf));
		}
		write(STDERR_FILENO, "\n", 1);
	}
	if (compile_time != 2 && curnode) {
		snprintf(buf, sizeof buf, " source line number %d", curnode->lineno);
		write(STDERR_FILENO, buf, strlen(buf));
	} else if (compile_time != 2 && lineno) {
		snprintf(buf, sizeof buf, " source line number %d", lineno);
		write(STDERR_FILENO, buf, strlen(buf));
	}
	if (compile_time == 1 && cursource() != NULL) {
		snprintf(buf, sizeof buf, " source file %s", cursource());
		write(STDERR_FILENO, buf, strlen(buf));
	}
	write(STDERR_FILENO, "\n", 1);
	if (dbg > 1)		/* core dump if serious debugging on */
		abort();
	_exit(1);
}

extern int bracecnt, brackcnt, parencnt;

void bracecheck(void)
{
	int c;
	static int beenhere = 0;

	if (beenhere++)
		return;
	while ((c = input()) != EOF && c != '\0')
		bclass(c);
	bcheck2(bracecnt, '{', '}');
	bcheck2(brackcnt, '[', ']');
	bcheck2(parencnt, '(', ')');
}

void bcheck2(int n, int c1, int c2)
{
	if (n == 1)
		fprintf(stderr, "\tmissing %c\n", c2);
	else if (n > 1)
		fprintf(stderr, "\t%d missing %c's\n", n, c2);
	else if (n == -1)
		fprintf(stderr, "\textra %c\n", c2);
	else if (n < -1)
		fprintf(stderr, "\t%d extra %c's\n", -n, c2);
}

__dead void FATAL(const char *fmt, ...)
{
	extern char *cmdname;
	va_list varg;

	fflush(stdout);
	fprintf(stderr, "%s: ", cmdname);
	va_start(varg, fmt);
	vfprintf(stderr, fmt, varg);
	va_end(varg);
	error();
	if (dbg > 1)		/* core dump if serious debugging on */
		abort();
	exit(2);
}

void WARNING(const char *fmt, ...)
{
	extern char *cmdname;
	va_list varg;

	fflush(stdout);
	fprintf(stderr, "%s: ", cmdname);
	va_start(varg, fmt);
	vfprintf(stderr, fmt, varg);
	va_end(varg);
	error();
}

void error()
{
	extern Node *curnode;

	fprintf(stderr, "\n");
	if (compile_time != 2 && NR && *NR > 0) {
		fprintf(stderr, " input record number %d", (int) (*FNR));
		if (strcmp(*FILENAME, "-") != 0)
			fprintf(stderr, ", file %s", *FILENAME);
		fprintf(stderr, "\n");
	}
	if (compile_time != 2 && curnode)
		fprintf(stderr, " source line number %d", curnode->lineno);
	else if (compile_time != 2 && lineno)
		fprintf(stderr, " source line number %d", lineno);
	if (compile_time == 1 && cursource() != NULL)
		fprintf(stderr, " source file %s", cursource());
	fprintf(stderr, "\n");
	eprint();
}

void eprint(void)	/* try to print context around error */
{
	char *p, *q;
	int c;
	static int been_here = 0;
	extern char ebuf[], *ep;

	if (compile_time == 2 || compile_time == 0 || been_here++ > 0 ||
	    ebuf == ep)
		return;
	p = ep - 1;
	if (p > ebuf && *p == '\n')
		p--;
	for ( ; p > ebuf && *p != '\n' && *p != '\0'; p--)
		;
	while (*p == '\n')
		p++;
	fprintf(stderr, " context is\n\t");
	for (q=ep-1; q>=p && *q!=' ' && *q!='\t' && *q!='\n'; q--)
		;
	for ( ; p < q; p++)
		if (*p)
			putc(*p, stderr);
	fprintf(stderr, " >>> ");
	for ( ; p < ep; p++)
		if (*p)
			putc(*p, stderr);
	fprintf(stderr, " <<< ");
	if (*ep)
		while ((c = input()) != '\n' && c != '\0' && c != EOF) {
			putc(c, stderr);
			bclass(c);
		}
	putc('\n', stderr);
	ep = ebuf;
}

void bclass(int c)
{
	switch (c) {
	case '{': bracecnt++; break;
	case '}': bracecnt--; break;
	case '[': brackcnt++; break;
	case ']': brackcnt--; break;
	case '(': parencnt++; break;
	case ')': parencnt--; break;
	}
}

double errcheck(double x, const char *s)
{

	if (errno == EDOM) {
		errno = 0;
		WARNING("%s argument out of domain", s);
		x = 1;
	} else if (errno == ERANGE) {
		errno = 0;
		WARNING("%s result out of range", s);
		x = 1;
	}
	return x;
}

int isclvar(const char *s)	/* is s of form var=something ? */
{
	const char *os = s;

	if (!isalpha((uschar) *s) && *s != '_')
		return 0;
	for ( ; *s; s++)
		if (!(isalnum((uschar) *s) || *s == '_'))
			break;
	return *s == '=' && s > os && *(s+1) != '=';
}

/* strtod is supposed to be a proper test of what's a valid number */
/* appears to be broken in gcc on linux: thinks 0x123 is a valid FP number */
/* wrong: violates 4.10.1.4 of ansi C standard */

#include <math.h>
int is_number(const char *s)
{
	double r;
	char *ep;
	errno = 0;
	r = strtod(s, &ep);
	if (ep == s || r == HUGE_VAL || errno == ERANGE)
		return 0;
	while (*ep == ' ' || *ep == '\t' || *ep == '\n')
		ep++;
	if (*ep == '\0')
		return 1;
	else
		return 0;
}
@


1.22
log
@Fix awk crash with empty assignment, e.g. 'BEGIN {i=$1}', when
malloc does not return zero-filled data.  OK tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.21 2015/03/27 10:09:30 tobiasu Exp $	*/
d595 1
a595 1
void FATAL(const char *fmt, ...)
@


1.21
log
@Don't display empty error context.

Context extraction didn't handle this case and showed uninitialized memory.

ok tobias, miod
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.20 2011/09/28 19:27:18 millert Exp $	*/
d67 1
@


1.20
log
@Update awk to Aug 10, 2011 version; naddy@@ reports no ports problems
from the update.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.19 2010/06/13 17:58:19 millert Exp $	*/
d651 2
a652 1
	if (compile_time == 2 || compile_time == 0 || been_here++ > 0)
@


1.19
log
@Update awk to May 23, 2010 version.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.18 2008/10/06 20:38:33 millert Exp $	*/
d94 7
a100 2
		if (!isclvar(p = getargv(i))) {	/* find 1st real filename */
			setsval(lookup("FILENAME", symtab), getargv(i));
d134 1
a134 1
			if (*file == '\0') {	/* it's been zapped */
d197 1
d238 2
d269 1
d282 1
a282 1
		if ((fields = (char *) malloc(n+1)) == NULL)
d490 1
a490 1
	   dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, fldtab[0]) );
d497 1
a497 1
	   dprintf( ("in recbld inputFS=%s, fldtab[0]=%p\n", inputFS, fldtab[0]) );
@


1.18
log
@Update awk to version 20071023; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.17 2007/09/02 15:19:31 deraadt Exp $	*/
d279 1
@


1.17
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.16 2005/11/23 02:43:45 millert Exp $	*/
d47 1
a47 1
#define	MAXFLD	200
d62 4
a65 4
	record = (char *) malloc(n);
	fields = (char *) malloc(n);
	fldtab = (Cell **) calloc((nfields+1), sizeof(Cell *));
	if (record == NULL || fields == NULL || fldtab == NULL)
a66 4

	fldtab[0] = (Cell *) malloc(sizeof (Cell));
	if (fldtab[0] == NULL)
		FATAL("out of space for fields");
d110 2
a111 1
	int bufsize = *pbufsize;
d123 1
d170 1
d172 1
a172 1
	*pbufsize = bufsize;
d178 1
a178 1
	if (infile != stdin && infile != NULL)
@


1.16
log
@Don't try to fclose(infile) when infile == NULL.  This can happen
when using nextfile in the BEGIN block.  From Matthias Kilian.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.15 2004/12/30 01:52:48 millert Exp $	*/
d64 1
a64 1
	fldtab = (Cell **) malloc((nfields+1) * sizeof(Cell *));
@


1.15
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.14 2003/12/01 15:34:26 grange Exp $	*/
d179 1
a179 1
	if (infile != stdin)
@


1.14
log
@Format string fixes from art's amd64 tree.
ok rohee@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.13 2003/04/28 03:07:40 tedu Exp $	*/
d108 2
a112 1
	static int firsttime = 1;
d316 7
d331 1
a331 1
			while (*r != sep && *r != '\n' && *r != '\0')	/* \n is always a separator */
d386 1
a386 1
		FATAL("trying to access field %d", n);
d395 1
d399 5
a403 1
	fldtab = (Cell **) realloc(fldtab, (nf+1) * (sizeof (struct Cell *)));
@


1.13
log
@string cleaning.  ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.12 2003/04/04 00:42:34 deraadt Exp $	*/
d484 1
a484 1
	SYNTAX(s);
@


1.12
log
@snprintf & strlcpy; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.11 2002/12/19 21:24:28 millert Exp $	*/
d436 1
a436 1
			strcpy(fr, rec);
@


1.11
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.10 2002/07/04 02:38:58 deraadt Exp $	*/
d87 1
a87 1
		sprintf(temp, "%d", i);
d192 1
a192 1
	strcpy(inputFS, *FS);	/* for subsequent field splitting */
d231 1
a231 1
	sprintf(temp, "%d", n);
@


1.10
log
@catch malloc failures, my changes; found by cloder@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.9 2001/11/05 09:58:13 deraadt Exp $	*/
d397 1
a397 1
int refldbld(char *rec, char *fs)	/* build fields from reg expr in FS */
d482 1
a482 1
void yyerror(char *s)
d487 1
a487 1
void SYNTAX(char *fmt, ...)
d572 1
a572 1
void FATAL(char *fmt, ...)
d588 1
a588 1
void WARNING(char *fmt, ...)
d670 1
a670 1
double errcheck(double x, char *s)
d685 1
a685 1
int isclvar(char *s)	/* is s of form var=something ? */
d687 1
a687 1
	char *os = s;
d702 1
a702 1
int is_number(char *s)
@


1.9
log
@some syslog_r uses in signal handlers
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.8 2001/09/08 00:12:40 millert Exp $	*/
d69 2
@


1.8
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.7 1999/12/08 23:09:45 millert Exp $	*/
d32 1
d507 1
a507 1
void fpecatch(int n)
d509 31
a539 1
	FATAL("floating point exception %d", n);
@


1.7
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.6 1999/04/20 17:31:29 millert Exp $	*/
d656 1
a656 1
	if (!isalpha(*s) && *s != '_')
d659 1
a659 1
		if (!(isalnum(*s) || *s == '_'))
d665 2
@


1.6
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.5 1999/04/18 17:06:30 millert Exp $	*/
d32 1
d65 1
a65 1
		ERROR "out of space for $0 and fields" FATAL;
d82 1
a82 1
			ERROR "out of space in makefields %d", i FATAL;
d141 1
a141 1
				ERROR "can't open file %s", file FATAL;
d188 1
a188 1
		ERROR "field separator %.10s... is too long", *FS FATAL;
d201 1
a201 1
					ERROR "input record `%.30s...' too long", buf FATAL;
d209 1
a209 1
			ERROR "input record `%.30s...' too long", buf FATAL;
d214 1
a214 1
		ERROR "input record `%.30s...' too long", buf FATAL;
d271 1
a271 1
			ERROR "out of space for fields in fldbld %d", n FATAL;
d329 1
a329 1
		ERROR "record `%.30s...' has too many fields; can't happen", r FATAL;
d375 1
a375 1
		ERROR "trying to access field %d", n FATAL;
d389 1
a389 1
		ERROR "out of space creating %d fields", nf FATAL;
d406 1
a406 1
			ERROR "out of space for fields in refldbld %d", n FATAL;
d452 1
a452 1
			ERROR "created $0 `%.30s...' too long", record FATAL;
d457 1
a457 1
				ERROR "created $0 `%.30s...' too long", record FATAL;
d463 1
a463 1
		ERROR "built giant record `%.30s...'", record FATAL;
a477 1
char	errbuf[300];	/* used by ERROR macro */
d481 5
d488 1
d492 4
a495 1
	fprintf(stderr, "%s: %s", cmdname, s);
d508 1
a508 1
	ERROR "floating point exception %d", n FATAL;
d539 17
a555 1
void error(int f, char *s)
a556 1
	extern Node *curnode;
d558 1
d562 10
a571 1
	fprintf(stderr, "%s", s);
a586 5
	if (f) {
		if (dbg > 1)		/* core dump if serious debugging on */
			abort();
		exit(2);
	}
d642 1
a642 1
		ERROR "%s argument out of domain", s WARNING;
d646 1
a646 1
		ERROR "%s result out of range", s WARNING;
@


1.5
log
@March 5, 1999 version of the "one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD: lib.c,v 1.4 1997/08/25 16:17:11 kstailey Exp $	*/
d490 2
d546 1
a546 1
		fprintf(stderr, " source line number %d\n", curnode->lineno);
d548 4
a551 1
		fprintf(stderr, " source line number %d\n", lineno);
a609 1
	extern int errno;
@


1.4
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
char	inputFS[100];
d117 4
a120 2
	donefld = 0;
	donerec = 1;
d150 1
a150 1
				if (isnumber(fldtab[0]->sval)) {
d245 1
a245 1
	if (isnumber(q->sval)) {
d334 1
a334 1
		if(isnumber(p->sval)) {
a443 2
	char *buf = record;
	int bufsize = recsize;
d447 1
a447 1
	r = buf;
d450 2
a451 2
		if (!adjbuf(&buf, &bufsize, 1+strlen(p)+r-buf, recsize, &r, "recbld 1"))
			ERROR "created $0 `%.30s...' too long", buf FATAL;
d455 2
a456 2
			if (!adjbuf(&buf, &bufsize, 2+strlen(*OFS)+r-buf, recsize, &r, "recbld 2"))
				ERROR "created $0 `%.30s...' too long", buf FATAL;
d461 2
a462 2
	if (!adjbuf(&buf, &bufsize, 2+r-buf, recsize, &r, "recbld 3"))
		ERROR "built giant record `%.30s...'", buf FATAL;
a465 4
	if (buf != record) {	/* increased size of record */
		record = buf;	/* BUG?  memory leak? */
		recsize = bufsize;
	}
d634 1
a634 1
int isnumber(char *s)
@


1.3
log
@Basically stock AT&T resarch awk until the awk vs. flex problems
have a better resolution.
@
text
@d1 1
d3 1
a3 1
Copyright (C) AT&T and Lucent Technologies 1996
d11 13
a23 13
documentation, and that the names of AT&T or Lucent Technologies
or any of their entities not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

AT&T AND LUCENT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL AT&T OR LUCENT OR ANY OF THEIR
ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
d33 1
a33 1
#include "awkgram.h"
d37 1
a38 2
char	*recdata;
char	*record;
d40 4
a43 2
Cell	*fldtab;
char	inputFS[100];	/* BUG: unchecked */
d46 1
a46 1
int	nfields	= MAXFLD;	/* can be set from commandline in main */
d51 1
a51 1
int	maxfld	= 0;	/* last used field */
d55 3
d60 16
a75 4
	static Cell dollar0 = {
	    OCELL, CFLD, "$0", /*recdata*/0, 0.0, REC|STR|DONTFREE };
	static Cell dollar1 = {
	    OCELL, CFLD, NULL, "", 0.0, FLD|STR|DONTFREE };
d78 8
a85 9
	record = recdata = (char *) malloc(n);
	fields = (char *) malloc(n);
	fldtab = (Cell *) malloc(nfields * sizeof(Cell));
	if (recdata == NULL || fields == NULL || fldtab == NULL)
		ERROR "out of space for $0 and fields" FATAL;
	fldtab[0] = dollar0;
	fldtab[0].sval = recdata;
	for (i = 1; i < nfields; i++)
		fldtab[i] = dollar1;
d104 2
a105 2
int getrec(char *buf)	/* get next input record from whatever source */
{			/* note: tests whether buf == record */
d108 2
d115 1
a115 1
	dprintf( ("RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\n",
d121 1
a121 1
		dprintf( ("argno=%d, file=|%s|\n", argno, file) );
d134 1
a134 1
			dprintf( ("opening file %s\n", file) );
d137 1
a137 1
			else if ((infile = fopen((char *)file, "r")) == NULL)
d141 1
a141 1
		c = readrec(buf, recsize, infile);
d143 8
a150 8
			if (buf == record) {
				if (!(recloc->tval & DONTFREE))
					xfree(recloc->sval);
				recloc->sval = record;
				recloc->tval = REC | STR | DONTFREE;
				if (isnumber(recloc->sval)) {
					recloc->fval = atof(recloc->sval);
					recloc->tval |= NUM;
d155 2
d165 2
d178 1
a178 1
int readrec(char *buf, int bufsize, FILE *inf)	/* read one record into buf */
d181 2
a182 2
	char *rr;
	int nrr;
d184 2
d194 7
a200 4
	for (rr = buf, nrr = bufsize; ; ) {
		for (; (c=getc(inf)) != sep && c != EOF; *rr++ = c)
			if (--nrr < 0)
				ERROR "input record `%.30s...' too long; try -mr n", buf FATAL;
d205 2
d210 2
a211 2
	if (rr > buf + bufsize)
		ERROR "input record `%.30s...' too long; try -mr n", buf FATAL;
d213 3
a215 1
	dprintf( ("readrec saw <%s>, returns %d\n", buf, c == EOF && rr == buf ? 0 : 1) );
d222 1
a222 1
	char *s, temp[10];
d228 1
a228 1
	dprintf( ("getargv(%d) returns |%s|\n", n, s) );
d247 1
a247 1
	dprintf( ("command line set %s to |%s|\n", s, p) );
d253 2
d257 1
a257 1
	int i;
d261 10
a270 3
	if (!(recloc->tval & STR))
		getsval(recloc);
	r = recloc->sval;
d282 6
a287 6
			if (i >= nfields)
				break;
			if (!(fldtab[i].tval & DONTFREE))
				xfree(fldtab[i].sval);
			fldtab[i].sval = fr;
			fldtab[i].tval = FLD | STR | DONTFREE;
d298 4
a301 4
			if (i >= nfields)
				break;
			if (!(fldtab[i].tval & DONTFREE))
				xfree(fldtab[i].sval);
d304 2
a305 2
			fldtab[i].sval = tostring(buf);
			fldtab[i].tval = FLD | STR;
d311 6
a316 6
			if (i >= nfields)
				break;
			if (!(fldtab[i].tval & DONTFREE))
				xfree(fldtab[i].sval);
			fldtab[i].sval = fr;
			fldtab[i].tval = FLD | STR | DONTFREE;
d325 4
a328 5
	if (i >= nfields)
		ERROR "record `%.30s...' has too many fields; try -mf n", record FATAL;
	/* clean out junk from previous record */
	cleanfld(i, maxfld);
	maxfld = i;
d330 2
a331 1
	for (p = fldtab+1; p <= fldtab+maxfld; p++) {
d337 7
a343 4
	setfval(nfloc, (Awkfloat) maxfld);
	if (dbg)
		for (p = fldtab; p <= fldtab+maxfld; p++)
			printf("field %d: |%s|\n", p-fldtab, p->sval);
d346 4
a349 4
void cleanfld(int n1, int n2)	/* clean out fields n1..n2 inclusive */
{
	static char *nullstat = "";
	Cell *p, *q;
d351 3
a353 2
	for (p = &fldtab[n2], q = &fldtab[n1]; p > q; p--) {
		if (!(p->tval & DONTFREE))
d355 1
a356 1
		p->sval = nullstat;
d360 1
a360 1
void newfld(int n)	/* add field n (after end) */
d362 4
a365 4
	if (n >= nfields)
		ERROR "creating too many fields (%d); try -mf n", n FATAL;
	cleanfld(maxfld, n);
	maxfld = n;
d369 22
d393 2
d396 1
a396 1
	int i, tempstat;
d399 7
d411 1
a411 1
	dprintf( ("into refldbld, rec = <%s>, pat = <%s>\n", rec, fs) );
d413 8
a420 6
	for (i = 1; i < nfields; i++) {
		if (!(fldtab[i].tval & DONTFREE))
			xfree(fldtab[i].sval);
		fldtab[i].tval = FLD | STR | DONTFREE;
		fldtab[i].sval = fr;
		dprintf( ("refldbld: i=%d\n", i) );
d422 2
a423 2
			pfa->initstat = 2;	/* horrible coupling */
			dprintf( ("match %s (%d chars)\n", patbeg, patlen) );
d429 1
a429 1
			dprintf( ("no match %s\n", rec) );
d442 2
a443 1
	static char *rec = 0;
d447 1
a447 6
	if (rec == 0) {
		rec = (char *) malloc(recsize);
		if (rec == 0)
			ERROR "out of space building $0, record size %d", recsize FATAL;
	}
	r = rec;
d449 4
a452 2
		p = getsval(&fldtab[i]);
		while (r < rec+recsize-1 && (*r = *p++))
d454 4
a457 2
		if (i < *NF)
			for (p = *OFS; r < rec+recsize-1 && (*r = *p++); )
d459 1
d461 2
a462 2
	if (r > rec + recsize - 1)
		ERROR "built giant record `%.30s...'; try -mr n", record FATAL;
d464 13
a476 5
	dprintf( ("in recbld inputFS=%s, recloc=%p\n", inputFS, recloc) );
	recloc->tval = REC | STR | DONTFREE;
	recloc->sval = record = rec;
	dprintf( ("in recbld inputFS=%s, recloc=%p\n", inputFS, recloc) );
	dprintf( ("recbld = |%s|\n", record) );
a479 7
Cell *fieldadr(int n)
{
	if (n < 0 || n >= nfields)
		ERROR "trying to access field %d; try -mf n", n FATAL;
	return(&fldtab[n]);
}

d481 1
a481 1
char	errbuf[200];
d635 1
a635 1
#define	MAXEXPON	38	/* maximum exponent for fp number. should be IEEE */
d637 2
a638 1
int isnumber(char *s)	/* should be done by a library function */
d640 10
a649 50
	int d1, d2;
	int point;
	char *es;

	d1 = d2 = point = 0;
	while (*s == ' ' || *s == '\t' || *s == '\n')
		s++;
	if (*s == '\0')
		return(0);	/* empty stuff isn't a number */
	if (*s == '+' || *s == '-')
		s++;
	if (!isdigit(*s) && *s != '.')
		return(0);
	if (isdigit(*s)) {
		do {
			d1++;
			s++;
		} while (isdigit(*s));
	}
	if (*s == '.') {
		point++;
		s++;
	}
	if (isdigit(*s)) {
		d2++;
		do {
			s++;
		} while (isdigit(*s));
	}
	if (!(d1 || (point && d2)))
		return(0);
	if (*s == 'e' || *s == 'E') {
		s++;
		if (*s == '+' || *s == '-')
			s++;
		if (!isdigit(*s))
			return(0);
		es = s;
		do {
			s++;
		} while (isdigit(*s));
		if (s - es > 2)
			return(0);
		else if (s - es == 2 && (int)(10 * (*es-'0') + *(es+1)-'0') >= MAXEXPON)
			return(0);
	}
	while (*s == ' ' || *s == '\t' || *s == '\n')
		s++;
	if (*s == '\0')
		return(1);
d651 1
a651 1
		return(0);
a652 24

#if 0
	/* THIS IS AN EXPERIMENT THAT'S NOT DONE. */
	/* strtod ought to provide a better test of what's */
	/* a valid number, but it doesn't work according to */
	/* the standard on any machine near me! */
	
	#include <math.h>
	isnumber(char *s)
	{
		double r;
		char *ep;
		errno = 0;
		r = strtod(s, &ep);
		if (r == HUGE_VAL || errno == ERANGE)
			return 0;
		while (*ep == ' ' || *ep == '\t' || *ep == '\n')
			ep++;
		if (*ep == '\0')
			return 1;
		else
			return 0;
	}
#endif	
@


1.2
log
@Latest research awk from June 29, 1996
@
text
@d434 1
a434 1
	while ((c = lex_input()) != EOF && c != '\0')
a481 1
#if 0
a513 1
#endif
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d41 1
d162 1
d233 3
a235 3
	if (strlen(*FS) > 1) {	/* it's a regular expression */
		i = refldbld(r, *FS);
	} else if ((sep = **FS) == ' ') {	/* default whitespace */
d254 1
a254 1
	} else if ((sep = **FS) == 0) {		/* new: FS="" => 1 char/field */
d386 1
a386 1
	dprintf( ("in recbld FS=%o, recloc=%p\n", **FS, recloc) );
d389 1
a389 1
	dprintf( ("in recbld FS=%o, recloc=%p\n", **FS, recloc) );
@
