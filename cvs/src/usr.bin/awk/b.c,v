head	1.18;
access;
symbols
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.12
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.14
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.4
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.8
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.6
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.4
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.12.19.19.28.55;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	F6KsUHbBzg2Ekpcd;

1.17
date	2011.09.28.19.27.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.13.17.58.19;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2008.10.06.20.38.33;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.02.15.19.31;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.19.18.17.11;	author pvalchev;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.30.01.52.48;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.19.21.24.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.08.00.12.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.12.05.16.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.12.08.23.09.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	99.04.20.17.31.29;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.04.18.17.06.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.08.25.16.17.10;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.15.59.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.04.06.06.31.48;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.01.20.19.43.20;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.07.04.20.34.41;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Use reallocarray() where suitable
ok millert doug
@
text
@/*	$OpenBSD: b.c,v 1.18 2014/12/19 19:25:51 deraadt Exp $	*/
/****************************************************************
Copyright (C) Lucent Technologies 1997
All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appear in all
copies and that both that the copyright notice and this
permission notice and warranty disclaimer appear in supporting
documentation, and that the name Lucent Technologies or any of
its entities not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
THIS SOFTWARE.
****************************************************************/

/* lasciate ogne speranza, voi ch'intrate. */

#define	DEBUG

#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "awk.h"
#include "ytab.h"

#define	HAT	(NCHARS+2)	/* matches ^ in regular expr */
				/* NCHARS is 2**n */
#define MAXLIN 22

#define type(v)		(v)->nobj	/* badly overloaded here */
#define info(v)		(v)->ntype	/* badly overloaded here */
#define left(v)		(v)->narg[0]
#define right(v)	(v)->narg[1]
#define parent(v)	(v)->nnext

#define LEAF	case CCL: case NCCL: case CHAR: case DOT: case FINAL: case ALL:
#define ELEAF	case EMPTYRE:		/* empty string in regexp */
#define UNARY	case STAR: case PLUS: case QUEST:

/* encoding in tree Nodes:
	leaf (CCL, NCCL, CHAR, DOT, FINAL, ALL, EMPTYRE):
		left is index, right contains value or pointer to value
	unary (STAR, PLUS, QUEST): left is child, right is null
	binary (CAT, OR): left and right are children
	parent contains pointer to parent
*/


int	*setvec;
int	*tmpset;
int	maxsetvec = 0;

int	rtok;		/* next token in current re */
int	rlxval;
static uschar	*rlxstr;
static uschar	*prestr;	/* current position in current re */
static uschar	*lastre;	/* origin of last re */

static	int setcnt;
static	int poscnt;

char	*patbeg;
int	patlen;

#define	NFA	20	/* cache this many dynamic fa's */
fa	*fatab[NFA];
int	nfatab	= 0;	/* entries in fatab */

fa *makedfa(const char *s, int anchor)	/* returns dfa for reg expr s */
{
	int i, use, nuse;
	fa *pfa;
	static int now = 1;

	if (setvec == 0) {	/* first time through any RE */
		maxsetvec = MAXLIN;
		setvec = (int *) calloc(maxsetvec, sizeof(int));
		tmpset = (int *) calloc(maxsetvec, sizeof(int));
		if (setvec == 0 || tmpset == 0)
			overflo("out of space initializing makedfa");
	}

	if (compile_time)	/* a constant for sure */
		return mkdfa(s, anchor);
	for (i = 0; i < nfatab; i++)	/* is it there already? */
		if (fatab[i]->anchor == anchor
		  && strcmp((const char *) fatab[i]->restr, s) == 0) {
			fatab[i]->use = now++;
			return fatab[i];
		}
	pfa = mkdfa(s, anchor);
	if (nfatab < NFA) {	/* room for another */
		fatab[nfatab] = pfa;
		fatab[nfatab]->use = now++;
		nfatab++;
		return pfa;
	}
	use = fatab[0]->use;	/* replace least-recently used */
	nuse = 0;
	for (i = 1; i < nfatab; i++)
		if (fatab[i]->use < use) {
			use = fatab[i]->use;
			nuse = i;
		}
	freefa(fatab[nuse]);
	fatab[nuse] = pfa;
	pfa->use = now++;
	return pfa;
}

fa *mkdfa(const char *s, int anchor)	/* does the real work of making a dfa */
				/* anchor = 1 for anchored matches, else 0 */
{
	Node *p, *p1;
	fa *f;

	p = reparse(s);
	p1 = op2(CAT, op2(STAR, op2(ALL, NIL, NIL), NIL), p);
		/* put ALL STAR in front of reg.  exp. */
	p1 = op2(CAT, p1, op2(FINAL, NIL, NIL));
		/* put FINAL after reg.  exp. */

	poscnt = 0;
	penter(p1);	/* enter parent pointers and leaf indices */
	if ((f = (fa *) calloc(1, sizeof(fa) + poscnt*sizeof(rrow))) == NULL)
		overflo("out of space for fa");
	f->accept = poscnt-1;	/* penter has computed number of positions in re */
	cfoll(f, p1);	/* set up follow sets */
	freetr(p1);
	if ((f->posns[0] = (int *) calloc(*(f->re[0].lfollow), sizeof(int))) == NULL)
			overflo("out of space in makedfa");
	if ((f->posns[1] = (int *) calloc(1, sizeof(int))) == NULL)
		overflo("out of space in makedfa");
	*f->posns[1] = 0;
	f->initstat = makeinit(f, anchor);
	f->anchor = anchor;
	f->restr = (uschar *) tostring(s);
	return f;
}

int makeinit(fa *f, int anchor)
{
	int i, k;

	f->curstat = 2;
	f->out[2] = 0;
	f->reset = 0;
	k = *(f->re[0].lfollow);
	xfree(f->posns[2]);			
	if ((f->posns[2] = (int *) calloc(k+1, sizeof(int))) == NULL)
		overflo("out of space in makeinit");
	for (i=0; i <= k; i++) {
		(f->posns[2])[i] = (f->re[0].lfollow)[i];
	}
	if ((f->posns[2])[1] == f->accept)
		f->out[2] = 1;
	for (i=0; i < NCHARS; i++)
		f->gototab[2][i] = 0;
	f->curstat = cgoto(f, 2, HAT);
	if (anchor) {
		*f->posns[2] = k-1;	/* leave out position 0 */
		for (i=0; i < k; i++) {
			(f->posns[0])[i] = (f->posns[2])[i];
		}

		f->out[0] = f->out[2];
		if (f->curstat != 2)
			--(*f->posns[f->curstat]);
	}
	return f->curstat;
}

void penter(Node *p)	/* set up parent pointers and leaf indices */
{
	switch (type(p)) {
	ELEAF
	LEAF
		info(p) = poscnt;
		poscnt++;
		break;
	UNARY
		penter(left(p));
		parent(left(p)) = p;
		break;
	case CAT:
	case OR:
		penter(left(p));
		penter(right(p));
		parent(left(p)) = p;
		parent(right(p)) = p;
		break;
	default:	/* can't happen */
		FATAL("can't happen: unknown type %d in penter", type(p));
		break;
	}
}

void freetr(Node *p)	/* free parse tree */
{
	switch (type(p)) {
	ELEAF
	LEAF
		xfree(p);
		break;
	UNARY
		freetr(left(p));
		xfree(p);
		break;
	case CAT:
	case OR:
		freetr(left(p));
		freetr(right(p));
		xfree(p);
		break;
	default:	/* can't happen */
		FATAL("can't happen: unknown type %d in freetr", type(p));
		break;
	}
}

/* in the parsing of regular expressions, metacharacters like . have */
/* to be seen literally;  \056 is not a metacharacter. */

int hexstr(uschar **pp)	/* find and eval hex string at pp, return new p */
{			/* only pick up one 8-bit byte (2 chars) */
	uschar *p;
	int n = 0;
	int i;

	for (i = 0, p = (uschar *) *pp; i < 2 && isxdigit(*p); i++, p++) {
		if (isdigit(*p))
			n = 16 * n + *p - '0';
		else if (*p >= 'a' && *p <= 'f')
			n = 16 * n + *p - 'a' + 10;
		else if (*p >= 'A' && *p <= 'F')
			n = 16 * n + *p - 'A' + 10;
	}
	*pp = (uschar *) p;
	return n;
}

#define isoctdigit(c) ((c) >= '0' && (c) <= '7')	/* multiple use of arg */

int quoted(uschar **pp)	/* pick up next thing after a \\ */
			/* and increment *pp */
{
	uschar *p = *pp;
	int c;

	if ((c = *p++) == 't')
		c = '\t';
	else if (c == 'n')
		c = '\n';
	else if (c == 'f')
		c = '\f';
	else if (c == 'r')
		c = '\r';
	else if (c == 'b')
		c = '\b';
	else if (c == '\\')
		c = '\\';
	else if (c == 'x') {	/* hexadecimal goo follows */
		c = hexstr(&p);	/* this adds a null if number is invalid */
	} else if (isoctdigit(c)) {	/* \d \dd \ddd */
		int n = c - '0';
		if (isoctdigit(*p)) {
			n = 8 * n + *p++ - '0';
			if (isoctdigit(*p))
				n = 8 * n + *p++ - '0';
		}
		c = n;
	} /* else */
		/* c = c; */
	*pp = p;
	return c;
}

char *cclenter(const char *argp)	/* add a character class */
{
	int i, c, c2;
	uschar *p = (uschar *) argp;
	uschar *op, *bp;
	static uschar *buf = 0;
	static int bufsz = 100;

	op = p;
	if (buf == 0 && (buf = (uschar *) malloc(bufsz)) == NULL)
		FATAL("out of space for character class [%.10s...] 1", p);
	bp = buf;
	for (i = 0; (c = *p++) != 0; ) {
		if (c == '\\') {
			c = quoted(&p);
		} else if (c == '-' && i > 0 && bp[-1] != 0) {
			if (*p != 0) {
				c = bp[-1];
				c2 = *p++;
				if (c2 == '\\')
					c2 = quoted(&p);
				if (c > c2) {	/* empty; ignore */
					bp--;
					i--;
					continue;
				}
				while (c < c2) {
					if (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, "cclenter1"))
						FATAL("out of space for character class [%.10s...] 2", p);
					*bp++ = ++c;
					i++;
				}
				continue;
			}
		}
		if (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, "cclenter2"))
			FATAL("out of space for character class [%.10s...] 3", p);
		*bp++ = c;
		i++;
	}
	*bp = 0;
	dprintf( ("cclenter: in = |%s|, out = |%s|\n", op, buf) );
	xfree(op);
	return (char *) tostring((char *) buf);
}

void overflo(const char *s)
{
	FATAL("regular expression too big: %.30s...", s);
}

void cfoll(fa *f, Node *v)	/* enter follow set of each leaf of vertex v into lfollow[leaf] */
{
	int i;
	int *p;

	switch (type(v)) {
	ELEAF
	LEAF
		f->re[info(v)].ltype = type(v);
		f->re[info(v)].lval.np = right(v);
		while (f->accept >= maxsetvec) {	/* guessing here! */
			setvec = reallocarray(setvec, maxsetvec,
			    4 * sizeof(int));
			tmpset = reallocarray(tmpset, maxsetvec,
			    4 * sizeof(int));
			if (setvec == 0 || tmpset == 0)
				overflo("out of space in cfoll()");
			maxsetvec *= 4;
		}
		for (i = 0; i <= f->accept; i++)
			setvec[i] = 0;
		setcnt = 0;
		follow(v);	/* computes setvec and setcnt */
		if ((p = (int *) calloc(setcnt+1, sizeof(int))) == NULL)
			overflo("out of space building follow set");
		f->re[info(v)].lfollow = p;
		*p = setcnt;
		for (i = f->accept; i >= 0; i--)
			if (setvec[i] == 1)
				*++p = i;
		break;
	UNARY
		cfoll(f,left(v));
		break;
	case CAT:
	case OR:
		cfoll(f,left(v));
		cfoll(f,right(v));
		break;
	default:	/* can't happen */
		FATAL("can't happen: unknown type %d in cfoll", type(v));
	}
}

int first(Node *p)	/* collects initially active leaves of p into setvec */
			/* returns 0 if p matches empty string */
{
	int b, lp;

	switch (type(p)) {
	ELEAF
	LEAF
		lp = info(p);	/* look for high-water mark of subscripts */
		while (setcnt >= maxsetvec || lp >= maxsetvec) {	/* guessing here! */
			setvec = reallocarray(setvec, maxsetvec,
			    4 * sizeof(int));
			tmpset = reallocarray(tmpset, maxsetvec,
			    4 * sizeof(int));
			if (setvec == 0 || tmpset == 0)
				overflo("out of space in first()");
			maxsetvec *= 4;
		}
		if (type(p) == EMPTYRE) {
			setvec[lp] = 0;
			return(0);
		}
		if (setvec[lp] != 1) {
			setvec[lp] = 1;
			setcnt++;
		}
		if (type(p) == CCL && (*(char *) right(p)) == '\0')
			return(0);		/* empty CCL */
		else return(1);
	case PLUS:
		if (first(left(p)) == 0) return(0);
		return(1);
	case STAR:
	case QUEST:
		first(left(p));
		return(0);
	case CAT:
		if (first(left(p)) == 0 && first(right(p)) == 0) return(0);
		return(1);
	case OR:
		b = first(right(p));
		if (first(left(p)) == 0 || b == 0) return(0);
		return(1);
	}
	FATAL("can't happen: unknown type %d in first", type(p));	/* can't happen */
	return(-1);
}

void follow(Node *v)	/* collects leaves that can follow v into setvec */
{
	Node *p;

	if (type(v) == FINAL)
		return;
	p = parent(v);
	switch (type(p)) {
	case STAR:
	case PLUS:
		first(v);
		follow(p);
		return;

	case OR:
	case QUEST:
		follow(p);
		return;

	case CAT:
		if (v == left(p)) {	/* v is left child of p */
			if (first(right(p)) == 0) {
				follow(p);
				return;
			}
		} else		/* v is right child */
			follow(p);
		return;
	}
}

int member(int c, const char *sarg)	/* is c in s? */
{
	uschar *s = (uschar *) sarg;

	while (*s)
		if (c == *s++)
			return(1);
	return(0);
}

int match(fa *f, const char *p0)	/* shortest match ? */
{
	int s, ns;
	uschar *p = (uschar *) p0;

	s = f->reset ? makeinit(f,0) : f->initstat;
	if (f->out[s])
		return(1);
	do {
		/* assert(*p < NCHARS); */
		if ((ns = f->gototab[s][*p]) != 0)
			s = ns;
		else
			s = cgoto(f, s, *p);
		if (f->out[s])
			return(1);
	} while (*p++ != 0);
	return(0);
}

int pmatch(fa *f, const char *p0)	/* longest match, for sub */
{
	int s, ns;
	uschar *p = (uschar *) p0;
	uschar *q;
	int i, k;

	/* s = f->reset ? makeinit(f,1) : f->initstat; */
	if (f->reset) {
		f->initstat = s = makeinit(f,1);
	} else {
		s = f->initstat;
	}
	patbeg = (char *) p;
	patlen = -1;
	do {
		q = p;
		do {
			if (f->out[s])		/* final state */
				patlen = q-p;
			/* assert(*q < NCHARS); */
			if ((ns = f->gototab[s][*q]) != 0)
				s = ns;
			else
				s = cgoto(f, s, *q);
			if (s == 1) {	/* no transition */
				if (patlen >= 0) {
					patbeg = (char *) p;
					return(1);
				}
				else
					goto nextin;	/* no match */
			}
		} while (*q++ != 0);
		if (f->out[s])
			patlen = q-p-1;	/* don't count $ */
		if (patlen >= 0) {
			patbeg = (char *) p;
			return(1);
		}
	nextin:
		s = 2;
		if (f->reset) {
			for (i = 2; i <= f->curstat; i++)
				xfree(f->posns[i]);
			k = *f->posns[0];			
			if ((f->posns[2] = (int *) calloc(k+1, sizeof(int))) == NULL)
				overflo("out of space in pmatch");
			for (i = 0; i <= k; i++)
				(f->posns[2])[i] = (f->posns[0])[i];
			f->initstat = f->curstat = 2;
			f->out[2] = f->out[0];
			for (i = 0; i < NCHARS; i++)
				f->gototab[2][i] = 0;
		}
	} while (*p++ != 0);
	return (0);
}

int nematch(fa *f, const char *p0)	/* non-empty match, for sub */
{
	int s, ns;
	uschar *p = (uschar *) p0;
	uschar *q;
	int i, k;

	/* s = f->reset ? makeinit(f,1) : f->initstat; */
	if (f->reset) {
		f->initstat = s = makeinit(f,1);
	} else {
		s = f->initstat;
	}
	patlen = -1;
	while (*p) {
		q = p;
		do {
			if (f->out[s])		/* final state */
				patlen = q-p;
			/* assert(*q < NCHARS); */
			if ((ns = f->gototab[s][*q]) != 0)
				s = ns;
			else
				s = cgoto(f, s, *q);
			if (s == 1) {	/* no transition */
				if (patlen > 0) {
					patbeg = (char *) p;
					return(1);
				} else
					goto nnextin;	/* no nonempty match */
			}
		} while (*q++ != 0);
		if (f->out[s])
			patlen = q-p-1;	/* don't count $ */
		if (patlen > 0 ) {
			patbeg = (char *) p;
			return(1);
		}
	nnextin:
		s = 2;
		if (f->reset) {
			for (i = 2; i <= f->curstat; i++)
				xfree(f->posns[i]);
			k = *f->posns[0];			
			if ((f->posns[2] = (int *) calloc(k+1, sizeof(int))) == NULL)
				overflo("out of state space");
			for (i = 0; i <= k; i++)
				(f->posns[2])[i] = (f->posns[0])[i];
			f->initstat = f->curstat = 2;
			f->out[2] = f->out[0];
			for (i = 0; i < NCHARS; i++)
				f->gototab[2][i] = 0;
		}
		p++;
	}
	return (0);
}

Node *reparse(const char *p)	/* parses regular expression pointed to by p */
{			/* uses relex() to scan regular expression */
	Node *np;

	dprintf( ("reparse <%s>\n", p) );
	lastre = prestr = (uschar *) p;	/* prestr points to string to be parsed */
	rtok = relex();
	/* GNU compatibility: an empty regexp matches anything */
	if (rtok == '\0') {
		/* FATAL("empty regular expression"); previous */
		return(op2(EMPTYRE, NIL, NIL));
	}
	np = regexp();
	if (rtok != '\0')
		FATAL("syntax error in regular expression %s at %s", lastre, prestr);
	return(np);
}

Node *regexp(void)	/* top-level parse of reg expr */
{
	return (alt(concat(primary())));
}

Node *primary(void)
{
	Node *np;

	switch (rtok) {
	case CHAR:
		np = op2(CHAR, NIL, itonp(rlxval));
		rtok = relex();
		return (unary(np));
	case ALL:
		rtok = relex();
		return (unary(op2(ALL, NIL, NIL)));
	case EMPTYRE:
		rtok = relex();
		return (unary(op2(ALL, NIL, NIL)));
	case DOT:
		rtok = relex();
		return (unary(op2(DOT, NIL, NIL)));
	case CCL:
		np = op2(CCL, NIL, (Node*) cclenter((char *) rlxstr));
		rtok = relex();
		return (unary(np));
	case NCCL:
		np = op2(NCCL, NIL, (Node *) cclenter((char *) rlxstr));
		rtok = relex();
		return (unary(np));
	case '^':
		rtok = relex();
		return (unary(op2(CHAR, NIL, itonp(HAT))));
	case '$':
		rtok = relex();
		return (unary(op2(CHAR, NIL, NIL)));
	case '(':
		rtok = relex();
		if (rtok == ')') {	/* special pleading for () */
			rtok = relex();
			return unary(op2(CCL, NIL, (Node *) tostring("")));
		}
		np = regexp();
		if (rtok == ')') {
			rtok = relex();
			return (unary(np));
		}
		else
			FATAL("syntax error in regular expression %s at %s", lastre, prestr);
	default:
		FATAL("illegal primary in regular expression %s at %s", lastre, prestr);
	}
	return 0;	/*NOTREACHED*/
}

Node *concat(Node *np)
{
	switch (rtok) {
	case CHAR: case DOT: case ALL: case EMPTYRE: case CCL: case NCCL: case '$': case '(':
		return (concat(op2(CAT, np, primary())));
	}
	return (np);
}

Node *alt(Node *np)
{
	if (rtok == OR) {
		rtok = relex();
		return (alt(op2(OR, np, concat(primary()))));
	}
	return (np);
}

Node *unary(Node *np)
{
	switch (rtok) {
	case STAR:
		rtok = relex();
		return (unary(op2(STAR, np, NIL)));
	case PLUS:
		rtok = relex();
		return (unary(op2(PLUS, np, NIL)));
	case QUEST:
		rtok = relex();
		return (unary(op2(QUEST, np, NIL)));
	default:
		return (np);
	}
}

/*
 * Character class definitions conformant to the POSIX locale as
 * defined in IEEE P1003.1 draft 7 of June 2001, assuming the source
 * and operating character sets are both ASCII (ISO646) or supersets
 * thereof.
 *
 * Note that to avoid overflowing the temporary buffer used in
 * relex(), the expanded character class (prior to range expansion)
 * must be less than twice the size of their full name.
 */

/* Because isblank doesn't show up in any of the header files on any
 * system i use, it's defined here.  if some other locale has a richer
 * definition of "blank", define HAS_ISBLANK and provide your own
 * version.
 * the parentheses here are an attempt to find a path through the maze
 * of macro definition and/or function and/or version provided.  thanks
 * to nelson beebe for the suggestion; let's see if it works everywhere.
 */

#ifndef HAS_ISBLANK

int (xisblank)(int c)
{
	return c==' ' || c=='\t';
}

#endif

struct charclass {
	const char *cc_name;
	int cc_namelen;
	int (*cc_func)(int);
} charclasses[] = {
	{ "alnum",	5,	isalnum },
	{ "alpha",	5,	isalpha },
#ifndef HAS_ISBLANK
	{ "blank",	5,	isspace }, /* was isblank */
#else
	{ "blank",	5,	isblank },
#endif
	{ "cntrl",	5,	iscntrl },
	{ "digit",	5,	isdigit },
	{ "graph",	5,	isgraph },
	{ "lower",	5,	islower },
	{ "print",	5,	isprint },
	{ "punct",	5,	ispunct },
	{ "space",	5,	isspace },
	{ "upper",	5,	isupper },
	{ "xdigit",	6,	isxdigit },
	{ NULL,		0,	NULL },
};


int relex(void)		/* lexical analyzer for reparse */
{
	int c, n;
	int cflag;
	static uschar *buf = 0;
	static int bufsz = 100;
	uschar *bp;
	struct charclass *cc;
	int i;

	switch (c = *prestr++) {
	case '|': return OR;
	case '*': return STAR;
	case '+': return PLUS;
	case '?': return QUEST;
	case '.': return DOT;
	case '\0': prestr--; return '\0';
	case '^':
	case '$':
	case '(':
	case ')':
		return c;
	case '\\':
		rlxval = quoted(&prestr);
		return CHAR;
	default:
		rlxval = c;
		return CHAR;
	case '[': 
		if (buf == 0 && (buf = (uschar *) malloc(bufsz)) == NULL)
			FATAL("out of space in reg expr %.10s..", lastre);
		bp = buf;
		if (*prestr == '^') {
			cflag = 1;
			prestr++;
		}
		else
			cflag = 0;
		n = 2 * strlen((const char *) prestr)+1;
		if (!adjbuf((char **) &buf, &bufsz, n, n, (char **) &bp, "relex1"))
			FATAL("out of space for reg expr %.10s...", lastre);
		for (; ; ) {
			if ((c = *prestr++) == '\\') {
				*bp++ = '\\';
				if ((c = *prestr++) == '\0')
					FATAL("nonterminated character class %.20s...", lastre);
				*bp++ = c;
			/* } else if (c == '\n') { */
			/* 	FATAL("newline in character class %.20s...", lastre); */
			} else if (c == '[' && *prestr == ':') {
				/* POSIX char class names, Dag-Erling Smorgrav, des@@ofug.org */
				for (cc = charclasses; cc->cc_name; cc++)
					if (strncmp((const char *) prestr + 1, (const char *) cc->cc_name, cc->cc_namelen) == 0)
						break;
				if (cc->cc_name != NULL && prestr[1 + cc->cc_namelen] == ':' &&
				    prestr[2 + cc->cc_namelen] == ']') {
					prestr += cc->cc_namelen + 3;
					for (i = 0; i < NCHARS; i++) {
						if (!adjbuf((char **) &buf, &bufsz, bp-buf+1, 100, (char **) &bp, "relex2"))
						    FATAL("out of space for reg expr %.10s...", lastre);
						if (cc->cc_func(i)) {
							*bp++ = i;
							n++;
						}
					}
				} else
					*bp++ = c;
			} else if (c == '\0') {
				FATAL("nonterminated character class %.20s", lastre);
			} else if (bp == buf) {	/* 1st char is special */
				*bp++ = c;
			} else if (c == ']') {
				*bp++ = 0;
				rlxstr = (uschar *) tostring((char *) buf);
				if (cflag == 0)
					return CCL;
				else
					return NCCL;
			} else
				*bp++ = c;
		}
	}
}

int cgoto(fa *f, int s, int c)
{
	int i, j, k;
	int *p, *q;

	assert(c == HAT || c < NCHARS);
	while (f->accept >= maxsetvec) {	/* guessing here! */
		setvec = reallocarray(setvec, maxsetvec, 4 * sizeof(int));
		tmpset = reallocarray(tmpset, maxsetvec, 4 * sizeof(int));
		if (setvec == 0 || tmpset == 0)
			overflo("out of space in cgoto()");
		maxsetvec *= 4;
	}
	for (i = 0; i <= f->accept; i++)
		setvec[i] = 0;
	setcnt = 0;
	/* compute positions of gototab[s,c] into setvec */
	p = f->posns[s];
	for (i = 1; i <= *p; i++) {
		if ((k = f->re[p[i]].ltype) != FINAL) {
			if ((k == CHAR && c == ptoi(f->re[p[i]].lval.np))
			 || (k == DOT && c != 0 && c != HAT)
			 || (k == ALL && c != 0)
			 || (k == EMPTYRE && c != 0)
			 || (k == CCL && member(c, (char *) f->re[p[i]].lval.up))
			 || (k == NCCL && !member(c, (char *) f->re[p[i]].lval.up) && c != 0 && c != HAT)) {
				q = f->re[p[i]].lfollow;
				for (j = 1; j <= *q; j++) {
					if (q[j] >= maxsetvec) {
						setvec = reallocarray(setvec,
						    maxsetvec, 4 * sizeof(int));
						tmpset = reallocarray(tmpset,
						    maxsetvec, 4 * sizeof(int));
						if (setvec == 0 || tmpset == 0)
							overflo("cgoto overflow");
						maxsetvec *= 4;
					}
					if (setvec[q[j]] == 0) {
						setcnt++;
						setvec[q[j]] = 1;
					}
				}
			}
		}
	}
	/* determine if setvec is a previous state */
	tmpset[0] = setcnt;
	j = 1;
	for (i = f->accept; i >= 0; i--)
		if (setvec[i]) {
			tmpset[j++] = i;
		}
	/* tmpset == previous state? */
	for (i = 1; i <= f->curstat; i++) {
		p = f->posns[i];
		if ((k = tmpset[0]) != p[0])
			goto different;
		for (j = 1; j <= k; j++)
			if (tmpset[j] != p[j])
				goto different;
		/* setvec is state i */
		f->gototab[s][c] = i;
		return i;
	  different:;
	}

	/* add tmpset to current set of states */
	if (f->curstat >= NSTATES-1) {
		f->curstat = 2;
		f->reset = 1;
		for (i = 2; i < NSTATES; i++)
			xfree(f->posns[i]);
	} else
		++(f->curstat);
	for (i = 0; i < NCHARS; i++)
		f->gototab[f->curstat][i] = 0;
	xfree(f->posns[f->curstat]);
	if ((p = (int *) calloc(setcnt+1, sizeof(int))) == NULL)
		overflo("out of space in cgoto");

	f->posns[f->curstat] = p;
	f->gototab[s][c] = f->curstat;
	for (i = 0; i <= setcnt; i++)
		p[i] = tmpset[i];
	if (setvec[f->accept])
		f->out[f->curstat] = 1;
	else
		f->out[f->curstat] = 0;
	return f->curstat;
}


void freefa(fa *f)	/* free a finite automaton */
{
	int i;

	if (f == NULL)
		return;
	for (i = 0; i <= f->curstat; i++)
		xfree(f->posns[i]);
	for (i = 0; i <= f->accept; i++) {
		xfree(f->re[i].lfollow);
		if (f->re[i].ltype == CCL || f->re[i].ltype == NCCL)
			xfree((f->re[i].lval.np));
	}
	xfree(f->restr);
	xfree(f);
}
@


1.17
log
@Update awk to Aug 10, 2011 version; naddy@@ reports no ports problems
from the update.
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.16 2010/06/13 17:58:19 millert Exp $	*/
d351 4
a354 3
			maxsetvec *= 4;
			setvec = (int *) realloc(setvec, maxsetvec * sizeof(int));
			tmpset = (int *) realloc(tmpset, maxsetvec * sizeof(int));
d357 1
d394 4
a397 3
			maxsetvec *= 4;
			setvec = (int *) realloc(setvec, maxsetvec * sizeof(int));
			tmpset = (int *) realloc(tmpset, maxsetvec * sizeof(int));
d400 1
d864 2
a865 3
		maxsetvec *= 4;
		setvec = (int *) realloc(setvec, maxsetvec * sizeof(int));
		tmpset = (int *) realloc(tmpset, maxsetvec * sizeof(int));
d868 1
d886 4
a889 3
						maxsetvec *= 4;
						setvec = (int *) realloc(setvec, maxsetvec * sizeof(int));
						tmpset = (int *) realloc(tmpset, maxsetvec * sizeof(int));
d892 1
@


1.16
log
@Update awk to May 23, 2010 version.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.15 2008/10/06 20:38:33 millert Exp $	*/
d235 1
a235 1
int hexstr(char **pp)	/* find and eval hex string at pp, return new p */
d249 1
a249 1
	*pp = (char *) p;
d255 1
a255 1
int quoted(char **pp)	/* pick up next thing after a \\ */
d258 1
a258 1
	char *p = *pp;
d303 1
a303 1
			c = quoted((char **) &p);
d309 1
a309 1
					c2 = quoted((char **) &p);
d737 1
a737 1
int (isblank)(int c)
d751 3
d755 1
d792 1
a792 1
		rlxval = quoted((char **) &prestr);
@


1.15
log
@Update awk to version 20071023; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.14 2007/09/02 15:19:31 deraadt Exp $	*/
d880 1
a880 1
						tmpset = (int *) realloc(setvec, maxsetvec * sizeof(int));
@


1.14
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.13 2006/03/19 18:17:11 pvalchev Exp $	*/
d26 1
a26 1
/* lasciate ogne speranza, voi ch'entrate. */
d48 1
d52 1
a52 1
	leaf (CCL, NCCL, CHAR, DOT, FINAL, ALL):
d187 1
d212 1
d316 1
a316 1
					if (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, 0))
d324 1
a324 1
		if (!adjbuf((char **) &buf, &bufsz, bp-buf+2, 100, (char **) &bp, 0))
d346 1
d383 1
a383 1
			/* returns 1 if p matches empty string */
d388 1
d398 4
d478 1
a478 1
		assert(*p < NCHARS);
d509 1
a509 1
			assert(*q < NCHARS);
d567 1
a567 1
			assert(*q < NCHARS);
d614 1
a614 1
	if (rtok == '\0')
d616 2
a617 1
		return(op2(ALL, NIL, NIL));
d641 3
d683 1
a683 1
	case CHAR: case DOT: case ALL: case CCL: case NCCL: case '$': case '(':
d804 1
a804 1
		if (!adjbuf((char **) &buf, &bufsz, n, n, (char **) &bp, 0))
d823 1
a823 1
						if (!adjbuf((char **) &buf, &bufsz, bp-buf+1, 100, (char **) &bp, 0))
d872 1
@


1.13
log
@more sane calloc(3) usage; from adobriyan@@gmail.com, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.12 2004/12/30 01:52:48 millert Exp $	*/
d87 2
a88 2
		setvec = (int *) malloc(maxsetvec * sizeof(int));
		tmpset = (int *) malloc(maxsetvec * sizeof(int));
@


1.12
log
@Update to version 20041222; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.11 2002/12/19 21:24:28 millert Exp $	*/
d140 1
a140 1
	if ((f->posns[0] = (int *) calloc(1, *(f->re[0].lfollow)*sizeof(int))) == NULL)
d160 1
a160 1
	if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d357 1
a357 1
		if ((p = (int *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
d526 1
a526 1
			if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d583 1
a583 1
			if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d910 1
a910 1
	if ((p = (int *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
@


1.11
log
@Update to the One True Awk version 20021213
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.10 2001/09/08 00:12:40 millert Exp $	*/
d37 1
a37 1
#define	HAT	(NCHARS-2)	/* matches ^ in regular expr */
d469 1
d487 6
a492 1
	s = f->reset ? makeinit(f,1) : f->initstat;
d500 1
d546 6
a551 1
	s = f->reset ? makeinit(f,1) : f->initstat;
d558 1
d712 19
d734 1
a734 1
	const char *cc_expand;
d736 12
a747 12
	{ "alnum",	5,	"0-9A-Za-z" },
	{ "alpha",	5,	"A-Za-z" },
	{ "blank",	5,	" \t" },
	{ "cntrl",	5,	"\000-\037\177" },
	{ "digit",	5,	"0-9" },
	{ "graph",	5,	"\041-\176" },
	{ "lower",	5,	"a-z" },
	{ "print",	5,	" \041-\176" },
	{ "punct",	5,	"\041-\057\072-\100\133-\140\173-\176" },
	{ "space",	5,	" \f\n\r\t\v" },
	{ "upper",	5,	"A-Z" },
	{ "xdigit",	6,	"0-9A-Fa-f" },
d760 1
a760 1
	const uschar *p;
d809 8
a816 2
					for (p = (const uschar *) cc->cc_expand; *p; p++)
						*bp++ = *p;
d841 1
a841 2
	if (c < 0 || c > 255)
		FATAL("can't happen: neg char %d in cgoto", c);
@


1.10
log
@Update to latest version of the One True Awk.  See the FIXES file
for details.
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.9 2001/07/12 05:16:53 deraadt Exp $	*/
d79 1
a79 1
fa *makedfa(char *s, int anchor)	/* returns dfa for reg expr s */
d97 1
a97 1
		  && strcmp(fatab[i]->restr, s) == 0) {
d121 1
a121 1
fa *mkdfa(char *s, int anchor)	/* does the real work of making a dfa */
d286 1
a286 1
char *cclenter(char *argp)	/* add a character class */
d332 1
a332 1
void overflo(char *s)
d450 1
a450 1
int member(int c, char *sarg)	/* is c in s? */
d460 1
a460 1
int match(fa *f, char *p0)	/* shortest match ? */
d479 1
a479 1
int pmatch(fa *f, char *p0)	/* longest match, for sub */
d532 1
a532 1
int nematch(fa *f, char *p0)	/* non-empty match, for sub */
d584 1
a584 1
Node *reparse(char *p)	/* parses regular expression pointed to by p */
d591 1
d593 2
a594 1
		FATAL("empty regular expression");
d689 31
d727 2
d758 1
a758 1
		n = 2 * strlen(prestr)+1;
d769 12
@


1.9
log
@first pass at a -Wall cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.8 1999/12/08 23:09:45 millert Exp $	*/
d37 1
a37 1
#define	HAT	(NCHARS-1)	/* matches ^ in regular expr */
d65 3
a67 3
char	*rlxstr;
char	*prestr;	/* current position in current re */
char	*lastre;	/* origin of last re */
d100 1
a100 1
	}
d147 1
a147 1
	f->restr = tostring(s);
d234 1
a234 1
	char *p;
d238 1
a238 1
	for (i = 0, p = *pp; i < 2 && isxdigit(*p); i++, p++) {
d246 1
a246 1
	*pp = p;
d286 1
a286 1
char *cclenter(char *p)	/* add a character class */
d289 3
a291 2
	char *op, *bp;
	static char *buf = 0;
d295 1
a295 1
	if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
d300 1
a300 1
			c = quoted(&p);
d306 1
a306 1
					c2 = quoted(&p);
d313 1
a313 1
					if (!adjbuf(&buf, &bufsz, bp-buf+2, 100, &bp, 0))
d321 1
a321 1
		if (!adjbuf(&buf, &bufsz, bp-buf+2, 100, &bp, 0))
d329 1
a329 1
	return(tostring(buf));
d450 1
a450 1
int member(int c, char *s)	/* is c in s? */
d452 2
d589 1
a589 1
	lastre = prestr = p;	/* prestr points to string to be parsed */
d620 1
a620 1
		np = op2(CCL, NIL, (Node*) cclenter(rlxstr));
d624 1
a624 1
		np = op2(NCCL, NIL, (Node *) cclenter(rlxstr));
d691 1
a691 1
	static char *buf = 0;
d693 1
a693 1
	char *bp;
d708 1
a708 1
		rlxval = quoted(&prestr);
d714 1
a714 1
		if (buf == 0 && (buf = (char *) malloc(bufsz)) == NULL)
d724 1
a724 1
		if (!adjbuf(&buf, &bufsz, n, n, &bp, 0))
d732 2
a733 2
			} else if (c == '\n') {
				FATAL("newline in character class %.20s...", lastre);
d740 1
a740 1
				rlxstr = tostring(buf);
d756 1
a756 1
	if (c < 0)
d775 2
a776 2
			 || (k == CCL && member(c, f->re[p[i]].lval.up))
			 || (k == NCCL && !member(c, f->re[p[i]].lval.up) && c != 0 && c != HAT)) {
@


1.8
log
@June 6, 1999 version of the "one true awk"
Most of the changes are to avoid using a static buffer for error messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.7 1999/04/20 17:31:29 millert Exp $	*/
d495 1
a495 1
			if (s == 1)	/* no transition */
d502 1
d547 1
a547 1
			if (s == 1)	/* no transition */
d553 1
@


1.7
log
@April 16, 1999 version of the "one true awk"--64-bit fixes and more.
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.6 1999/04/18 17:06:30 millert Exp $	*/
d202 1
a202 1
		ERROR "can't happen: unknown type %d in penter", type(p) FATAL;
d224 1
a224 1
		ERROR "can't happen: unknown type %d in freetr", type(p) FATAL;
d295 1
a295 1
		ERROR "out of space for character class [%.10s...] 1", p FATAL;
d313 1
a313 1
						ERROR "out of space for character class [%.10s...] 2", p FATAL;
d321 1
a321 1
			ERROR "out of space for character class [%.10s...] 3", p FATAL;
d333 1
a333 1
	ERROR "regular expression too big: %.30s...", s FATAL;
d373 1
a373 1
		ERROR "can't happen: unknown type %d in cfoll", type(v) FATAL;
d414 1
a414 1
	ERROR "can't happen: unknown type %d in first", type(p) FATAL;	/* can't happen */
d587 1
a587 1
		ERROR "empty regular expression" FATAL;
d590 1
a590 1
		ERROR "syntax error in regular expression %s at %s", lastre, prestr FATAL;
d640 1
a640 1
			ERROR "syntax error in regular expression %s at %s", lastre, prestr FATAL;
d642 1
a642 1
		ERROR "illegal primary in regular expression %s at %s", lastre, prestr FATAL;
d710 1
a710 1
			ERROR "out of space in reg expr %.10s..", lastre FATAL;
d720 1
a720 1
			ERROR "out of space for reg expr %.10s...", lastre FATAL;
d725 1
a725 1
					ERROR "nonterminated character class %.20s...", lastre FATAL;
d728 1
a728 1
				ERROR "newline in character class %.20s...", lastre FATAL;
d730 1
a730 1
				ERROR "nonterminated character class %.20s", lastre FATAL;
d752 1
a752 1
		ERROR "can't happen: neg char %d in cgoto", c FATAL;
@


1.6
log
@March 5, 1999 version of the "one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD: b.c,v 1.5 1997/08/25 16:17:10 kstailey Exp $	*/
d41 2
a42 1
#define type(v)		(v)->nobj
d187 1
a187 1
		left(p) = (Node *) poscnt;
d343 2
a344 2
		f->re[(int) left(v)].ltype = type(v);
		f->re[(int) left(v)].lval.np = right(v);
d358 1
a358 1
		f->re[(int) left(v)].lfollow = p;
d384 1
a384 1
		lp = (int) left(p);	/* look for high-water mark of subscripts */
d389 1
a389 1
			if (setvec == 0 || tmpset == 0) { abort();
a390 1
}
d605 1
a605 1
		np = op2(CHAR, NIL, (Node *) rlxval);
d624 1
a624 1
		return (unary(op2(CHAR, NIL, (Node *) HAT)));
d757 1
a757 1
		if (setvec == 0 || tmpset == 0) { abort();
a758 1
}
d767 1
a767 1
			if ((k == CHAR && c == f->re[p[i]].lval.i)
@


1.5
log
@August 1997 version of "the one true awk"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 1
d97 1
a97 1
			fatab[i]->use++;
d103 1
a103 1
		fatab[nfatab]->use = 1;
d116 1
a116 1
	pfa->use = 1;
@


1.4
log
@Back out last changes for now.  They cause problems.
@
text
@d1 1
d3 1
a3 1
Copyright (C) AT&T and Lucent Technologies 1996
d11 13
a23 13
documentation, and that the names of AT&T or Lucent Technologies
or any of their entities not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

AT&T AND LUCENT DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL AT&T OR LUCENT OR ANY OF THEIR
ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
d35 1
a35 1
#include "awkgram.h"
d287 3
a289 2
	char *op;
	static Gstring *cgp = 0;
d292 4
a295 5
	if (cgp == 0)
		cgp = newGstring();
	caddreset(cgp);
	i = 0;
	while ((c = *p++) != 0) {
d298 1
a298 1
		} else if (c == '-' && i > 0 && cgp->cbuf[i-1] != 0) {
d300 1
a300 1
				c = cgp->cbuf[i-1];
d305 1
a305 1
					cunadd(cgp);
d310 3
a312 1
					cadd(cgp, ++c);
d318 3
a320 1
		cadd(cgp, c);
d323 2
a324 2
	cadd(cgp, 0);
	dprintf( ("cclenter: in = |%s|, out = |%s|\n", op, cgp->cbuf) );
d326 1
a326 1
	return(tostring(cgp->cbuf));
d347 1
a347 1
			if (setvec == 0 || tmpset == 0) { abort();
a348 1
}
d683 1
a683 1
	int c;
d685 3
a687 1
	static Gstring *gp = 0;
d708 3
a710 3
		if (gp == 0)
			gp = newGstring();
		caddreset(gp);
d717 3
d722 1
a722 1
				cadd(gp, '\\');
d725 1
a725 1
				cadd(gp, c);
d730 2
a731 2
			} else if (gp->clen == 0) {	/* 1st char is special */
				cadd(gp, c);
d733 2
a734 2
				cadd(gp, 0);
				rlxstr = tostring(gp->cbuf);
d740 1
a740 1
				cadd(gp, c);
@


1.3
log
@Use long, not int when casting pointers and storing as integers.
Now compiles on alpha w/o warnings.
@
text
@d62 1
a62 1
long	rlxval;
d67 2
a68 2
static	long setcnt;
static	long poscnt;
d137 1
a137 1
	if ((f->posns[0] = (long *) calloc(1, *(f->re[0].lfollow)*sizeof(int))) == NULL)
d139 1
a139 1
	if ((f->posns[1] = (long *) calloc(1, sizeof(int))) == NULL)
d157 1
a157 1
	if ((f->posns[2] = (long *) calloc(1, (k+1)*sizeof(int))) == NULL)
d332 1
a332 1
	long *p;
d336 2
a337 2
		f->re[(long) left(v)].ltype = type(v);
		f->re[(long) left(v)].lval.np = right(v);
d350 1
a350 1
		if ((p = (long *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
d352 1
a352 1
		f->re[(long) left(v)].lfollow = p;
d374 1
a374 2
	int b;
	long lp;
d378 1
a378 1
		lp = (long) left(p);	/* look for high-water mark of subscripts */
d510 1
a510 1
			if ((f->posns[2] = (long *) calloc(1, (k+1)*sizeof(int))) == NULL)
d560 1
a560 1
			if ((f->posns[2] = (long *) calloc(1, (k+1)*sizeof(int))) == NULL)
d739 1
a739 1
	long *p, *q;
d812 1
a812 1
	if ((p = (long *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
@


1.2
log
@Latest research awk from June 29, 1996
@
text
@d62 1
a62 1
int	rlxval;
d67 2
a68 2
static	int setcnt;
static	int poscnt;
d137 1
a137 1
	if ((f->posns[0] = (int *) calloc(1, *(f->re[0].lfollow)*sizeof(int))) == NULL)
d139 1
a139 1
	if ((f->posns[1] = (int *) calloc(1, sizeof(int))) == NULL)
d157 1
a157 1
	if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d332 1
a332 1
	int *p;
d336 2
a337 2
		f->re[(int) left(v)].ltype = type(v);
		f->re[(int) left(v)].lval.np = right(v);
d350 1
a350 1
		if ((p = (int *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
d352 1
a352 1
		f->re[(int) left(v)].lfollow = p;
d374 2
a375 1
	int b, lp;
d379 1
a379 1
		lp = (int) left(p);	/* look for high-water mark of subscripts */
d511 1
a511 1
			if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d561 1
a561 1
			if ((f->posns[2] = (int *) calloc(1, (k+1)*sizeof(int))) == NULL)
d740 1
a740 1
	int *p, *q;
d813 1
a813 1
	if ((p = (int *) calloc(1, (setcnt+1)*sizeof(int))) == NULL)
@


1.1
log
@AT&T awk, by B. W. Kernighan, with fixes from 4.4BSD and by me
@
text
@d230 1
a230 1
{
d233 1
d235 1
a235 1
	for (p = *pp; isxdigit(*p); p++) {
d247 1
a247 1
#define isoctdigit(c) ((c) >= '0' && (c) <= '8')	/* multiple use of arg */
@
