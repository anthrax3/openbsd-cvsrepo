head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.10
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.7
date	2015.11.20.18.54.49;	author tedu;	state Exp;
branches;
next	1.6;
commitid	1DCLbr246dYBrwsL;

1.6
date	2015.11.19.23.36.46;	author tedu;	state Exp;
branches;
next	1.5;
commitid	26jQqp7hYs0AO9cj;

1.5
date	2015.11.19.23.28.03;	author tedu;	state Exp;
branches;
next	1.4;
commitid	CMGrkCVc2tUoCr3Z;

1.4
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.3;
commitid	BIjrMDODd4w0xnpk;

1.3
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.2;
commitid	cuVuNj9APX2eFzx2;

1.2
date	2015.11.19.22.16.43;	author tedu;	state Exp;
branches;
next	1.1;
commitid	cXEbYUQ1o6xIQH4J;

1.1
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	;
commitid	TCPdLh99ETkn9X6R;


desc
@@


1.7
log
@ansi
@
text
@/* $OpenBSD: buf.c,v 1.6 2015/11/19 23:36:46 tedu Exp $ */

/* flex - tool to generate fast lexical analyzers */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */


#include "flexdef.h"

/* Take note: The buffer object is sometimes used as a String buffer (one
 * continuous string), and sometimes used as a list of strings, usually line by
 * line.
 *
 * The type is specified in buf_init by the elt_size. If the elt_size is
 * sizeof(char), then the buffer should be treated as string buffer. If the
 * elt_size is sizeof(char*), then the buffer should be treated as a list of
 * strings.
 *
 * Certain functions are only appropriate for one type or the other.
 */

/* global buffers. */
struct Buf userdef_buf;		/**< for user #definitions triggered by cmd-line. */
struct Buf defs_buf;		/**< for #define's autogenerated. List of strings. */
struct Buf yydmap_buf;		/**< string buffer to hold yydmap elements */
struct Buf m4defs_buf;		/**< m4 definitions. List of strings. */
struct Buf top_buf;		/**< contains %top code. String buffer. */

struct Buf *
buf_print_strings(struct Buf * buf, FILE * out)
{
	int i;

	if (!buf || !out)
		return buf;

	for (i = 0; i < buf->nelts; i++) {
		const char *s = ((char **) buf->elts)[i];
		if (s)
			fprintf(out, "%s", s);
	}
	return buf;
}

/* Append a "%s" formatted string to a string buffer */
struct Buf *
buf_prints(struct Buf * buf, const char *fmt, const char *s)
{
	char *t;
	size_t tsz;

	tsz = strlen(fmt) + strlen(s) + 1;
	t = malloc(tsz);
	if (!t)
		flexfatal(_("Allocation of buffer to print string failed"));
	snprintf(t, tsz, fmt, s);
	buf = buf_strappend(buf, t);
	free(t);
	return buf;
}

/** Append a line directive to the string buffer.
 * @@param buf A string buffer.
 * @@param filename file name
 * @@param lineno line number
 * @@return buf
 */
struct Buf *
buf_linedir(struct Buf * buf, const char *filename, int lineno)
{
	const char *src;
	char *dst, *t;
	size_t tsz;

	tsz = strlen("#line \"\"\n") +	/* constant parts */
	    2 * strlen(filename) +	/* filename with possibly all backslashes escaped */
	    (int) (1 + log10(abs(lineno))) +	/* line number */
	    1;			/* NUL */
	t = malloc(tsz);
	if (!t)
		flexfatal(_("Allocation of buffer for line directive failed"));
	dst = t + snprintf(t, tsz, "#line %d \"", lineno);
	for (src = filename; *src; *dst++ = *src++)
		if (*src == '\\')	/* escape backslashes */
			*dst++ = '\\';
	*dst++ = '"';
	*dst++ = '\n';
	*dst = '\0';
	buf = buf_strappend(buf, t);
	free(t);
	return buf;
}


/** Append the contents of @@a src to @@a dest.
 * @@param @@a dest the destination buffer
 * @@param @@a dest the source buffer
 * @@return @@a dest
 */
struct Buf *
buf_concat(struct Buf * dest, const struct Buf * src)
{
	buf_append(dest, src->elts, src->nelts);
	return dest;
}


/* Appends n characters in str to buf. */
struct Buf *
buf_strnappend(struct Buf *buf, const char *str, int n)
{
	buf_append(buf, str, n + 1);

	/* "undo" the '\0' character that buf_append() already copied. */
	buf->nelts--;

	return buf;
}

/* Appends characters in str to buf. */
struct Buf *
buf_strappend(struct Buf *buf, const char *str)
{
	return buf_strnappend(buf, str, strlen(str));
}

/* appends "#define str def\n" */
struct Buf *
buf_strdefine(struct Buf *buf, const char *str, const char *def)
{
	buf_strappend(buf, "#define ");
	buf_strappend(buf, " ");
	buf_strappend(buf, str);
	buf_strappend(buf, " ");
	buf_strappend(buf, def);
	buf_strappend(buf, "\n");
	return buf;
}

/** Pushes "m4_define( [[def]], [[val]])m4_dnl" to end of buffer.
 * @@param buf A buffer as a list of strings.
 * @@param def The m4 symbol to define.
 * @@param val The definition; may be NULL.
 * @@return buf
 */
struct Buf *
buf_m4_define(struct Buf * buf, const char *def, const char *val)
{
	const char *fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
	char *str;
	size_t strsz;

	val = val ? val : "";
	strsz = strlen(fmt) + strlen(def) + strlen(val) + 2;
	str = malloc(strsz);
	if (!str)
		flexfatal(_("Allocation of buffer for m4 def failed"));

	snprintf(str, strsz, fmt, def, val);
	buf_append(buf, &str, 1);
	return buf;
}

/** Pushes "m4_undefine([[def]])m4_dnl" to end of buffer.
 * @@param buf A buffer as a list of strings.
 * @@param def The m4 symbol to undefine.
 * @@return buf
 */
struct Buf *
buf_m4_undefine(struct Buf * buf, const char *def)
{
	const char *fmt = "m4_undefine( [[%s]])m4_dnl\n";
	char *str;
	size_t strsz;

	strsz = strlen(fmt) + strlen(def) + 2;
	str = malloc(strsz);
	if (!str)
		flexfatal(_("Allocation of buffer for m4 undef failed"));

	snprintf(str, strsz, fmt, def);
	buf_append(buf, &str, 1);
	return buf;
}

/* create buf with 0 elements, each of size elem_size. */
void
buf_init(struct Buf *buf, size_t elem_size)
{
	buf->elts = NULL;
	buf->nelts = 0;
	buf->elt_size = elem_size;
	buf->nmax = 0;
}

/* frees memory */
void
buf_destroy(struct Buf *buf)
{
	free(buf->elts);
	buf->elts = NULL;
}


/* appends ptr[] to buf, grow if necessary.
 * n_elem is number of elements in ptr[], NOT bytes.
 * returns buf.
 * We grow by mod(512) boundaries.
 */

struct Buf *
buf_append(struct Buf *buf, const void *ptr, int n_elem)
{
	int n_alloc = 0;

	if (!ptr || n_elem == 0)
		return buf;

	/* May need to alloc more. */
	if (n_elem + buf->nelts > buf->nmax) {

		/* exact amount needed... */
		n_alloc = (n_elem + buf->nelts) * buf->elt_size;

		/* ...plus some extra */
		if (((n_alloc * buf->elt_size) % 512) != 0
		    && buf->elt_size < 512)
			n_alloc +=
			    (512 -
			    ((n_alloc * buf->elt_size) % 512)) /
			    buf->elt_size;

		if (!buf->elts)
			buf->elts =
			    allocate_array(n_alloc, buf->elt_size);
		else
			buf->elts =
			    reallocate_array(buf->elts, n_alloc,
			    buf->elt_size);

		buf->nmax = n_alloc;
	}
	memcpy((char *) buf->elts + buf->nelts * buf->elt_size, ptr,
	    n_elem * buf->elt_size);
	buf->nelts += n_elem;

	return buf;
}
@


1.6
log
@split out some variable initialization to be easier
@
text
@d1 1
a1 1
/* $OpenBSD: buf.c,v 1.5 2015/11/19 23:28:03 tedu Exp $ */
d139 1
a139 4
buf_strnappend(buf, str, n)
	struct Buf *buf;
	const char *str;
	int n;
d151 1
a151 3
buf_strappend(buf, str)
	struct Buf *buf;
	const char *str;
d158 1
a158 4
buf_strdefine(buf, str, def)
	struct Buf *buf;
	const char *str;
	const char *def;
d217 1
a217 3
buf_init(buf, elem_size)
	struct Buf *buf;
	size_t elem_size;
d227 1
a227 2
buf_destroy(buf)
	struct Buf *buf;
d241 1
a241 4
buf_append(buf, ptr, n_elem)
	struct Buf *buf;
	const void *ptr;
	int n_elem;
@


1.5
log
@it is not necessary to cast the result of malloc/calloc.
also replace some 0s with the modern concept of NULL
@
text
@d1 1
a1 1
/* $OpenBSD: buf.c,v 1.4 2015/11/19 23:20:34 tedu Exp $ */
d81 2
a82 1
	t = malloc(tsz = strlen(fmt) + strlen(s) + 1);
d104 2
a105 3
	t = malloc(tsz = strlen("#line \"\"\n") +	/* constant parts */
	    2 * strlen(filename) +	/* filename with possibly all
					 * backslashes escaped */
d107 2
a108 1
	    1);			/* NUL */
d111 2
a112 1
	for (dst = t + snprintf(t, tsz, "#line %d \"", lineno), src = filename; *src; *dst++ = *src++)
d191 2
a192 1
	str = (char *) malloc(strsz = strlen(fmt) + strlen(def) + strlen(val) + 2);
d213 2
a214 1
	str = malloc(strsz = strlen(fmt) + strlen(def) + 2);
@


1.4
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/* $OpenBSD: buf.c,v 1.3 2015/11/19 22:52:40 tedu Exp $ */
d210 1
a210 1
	str = (char *) malloc(strsz = strlen(fmt) + strlen(def) + 2);
d220 1
a220 1
void 
d225 1
a225 1
	buf->elts = (void *) 0;
d232 1
a232 1
void 
d236 2
a237 3
	if (buf && buf->elts)
		free(buf->elts);
	buf->elts = (void *) 0;
@


1.3
log
@orbital strike from moonbase knf
@
text
@d1 1
a1 1
/* $OpenBSD: buf.c,v 1.2 2015/11/19 22:16:43 tedu Exp $ */
d81 1
a81 1
	t = flex_alloc(tsz = strlen(fmt) + strlen(s) + 1);
d86 1
a86 1
	flex_free(t);
d103 1
a103 1
	t = flex_alloc(tsz = strlen("#line \"\"\n") +	/* constant parts */
d117 1
a117 1
	flex_free(t);
d189 1
a189 1
	str = (char *) flex_alloc(strsz = strlen(fmt) + strlen(def) + strlen(val) + 2);
d210 1
a210 1
	str = (char *) flex_alloc(strsz = strlen(fmt) + strlen(def) + 2);
d237 1
a237 1
		flex_free(buf->elts);
@


1.2
log
@we don't keep vim modelines in files
@
text
@d1 1
a1 1
/* $OpenBSD: buf.c,v 1.1 2015/11/19 19:43:40 tedu Exp $ */
d35 2
a36 1

d42 1
a42 1
 * 
d48 1
a48 1
 * Certain functions are only appropriate for one type or the other. 
d55 2
a56 2
struct Buf m4defs_buf;          /**< m4 definitions. List of strings. */
struct Buf top_buf;             /**< contains %top code. String buffer. */
d58 2
a59 1
struct Buf *buf_print_strings(struct Buf * buf, FILE* out)
d61 1
a61 1
    int i;
d63 9
a71 9
    if(!buf || !out)
        return buf;

    for (i=0; i < buf->nelts; i++){
        const char * s = ((char**)buf->elts)[i];
        if(s)
            fprintf(out, "%s", s);
    }
    return buf;
d75 2
a76 1
struct Buf *buf_prints (struct Buf *buf, const char *fmt, const char *s)
d78 2
a79 2
	char   *t;
        size_t tsz;
d81 1
a81 1
	t = flex_alloc (tsz = strlen (fmt) + strlen (s) + 1);
d83 4
a86 4
	    flexfatal (_("Allocation of buffer to print string failed"));
	snprintf (t, tsz, fmt, s);
	buf = buf_strappend (buf, t);
	flex_free (t);
d96 2
a97 1
struct Buf *buf_linedir (struct Buf *buf, const char* filename, int lineno)
d99 20
a118 19
    const char *src;
    char *dst, *t;
    size_t tsz;

    t = flex_alloc (tsz = strlen ("#line \"\"\n")    +   /* constant parts */
                    2 * strlen (filename)            +   /* filename with possibly all backslashes escaped */
                    (int) (1 + log10 (abs (lineno))) +   /* line number */
                    1);                                  /* NUL */
    if (!t)
      flexfatal (_("Allocation of buffer for line directive failed"));
    for (dst = t + snprintf (t, tsz, "#line %d \"", lineno), src = filename; *src; *dst++ = *src++)
      if (*src == '\\')   /* escape backslashes */
        *dst++ = '\\';
    *dst++ = '"';
    *dst++ = '\n';
    *dst   = '\0';
    buf = buf_strappend (buf, t);
    flex_free (t);
    return buf;
d127 2
a128 1
struct Buf *buf_concat(struct Buf* dest, const struct Buf* src)
d130 2
a131 2
    buf_append(dest, src->elts, src->nelts);
    return dest;
d136 5
a140 4
struct Buf *buf_strnappend (buf, str, n)
     struct Buf *buf;
     const char *str;
     int n;
d142 1
a142 1
	buf_append (buf, str, n + 1);
d151 4
a154 3
struct Buf *buf_strappend (buf, str)
     struct Buf *buf;
     const char *str;
d156 1
a156 1
	return buf_strnappend (buf, str, strlen (str));
d160 12
a171 11
struct Buf *buf_strdefine (buf, str, def)
     struct Buf *buf;
     const char *str;
     const char *def;
{
	buf_strappend (buf, "#define ");
	buf_strappend (buf, " ");
	buf_strappend (buf, str);
	buf_strappend (buf, " ");
	buf_strappend (buf, def);
	buf_strappend (buf, "\n");
d181 2
a182 1
struct Buf *buf_m4_define (struct Buf *buf, const char* def, const char* val)
d184 12
a195 12
    const char * fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
    char * str;
    size_t strsz;

    val = val?val:"";
    str = (char*)flex_alloc(strsz = strlen(fmt) + strlen(def) + strlen(val) + 2);
    if (!str)
        flexfatal (_("Allocation of buffer for m4 def failed"));

    snprintf(str, strsz, fmt, def, val);
    buf_append(buf, &str, 1);
    return buf;
d203 2
a204 1
struct Buf *buf_m4_undefine (struct Buf *buf, const char* def)
d206 11
a216 11
    const char * fmt = "m4_undefine( [[%s]])m4_dnl\n";
    char * str;
    size_t strsz;

    str = (char*)flex_alloc(strsz = strlen(fmt) + strlen(def) + 2);
    if (!str)
        flexfatal (_("Allocation of buffer for m4 undef failed"));

    snprintf(str, strsz, fmt, def);
    buf_append(buf, &str, 1);
    return buf;
d220 4
a223 3
void buf_init (buf, elem_size)
     struct Buf *buf;
     size_t elem_size;
d232 3
a234 2
void buf_destroy (buf)
     struct Buf *buf;
d237 1
a237 1
		flex_free (buf->elts);
d248 5
a252 4
struct Buf *buf_append (buf, ptr, n_elem)
     struct Buf *buf;
     const void *ptr;
     int n_elem;
d254 1
a254 1
	int     n_alloc = 0;
d269 3
a271 3
				(512 -
				 ((n_alloc * buf->elt_size) % 512)) /
				buf->elt_size;
d275 1
a275 1
				allocate_array (n_alloc, buf->elt_size);
d278 2
a279 2
				reallocate_array (buf->elts, n_alloc,
						  buf->elt_size);
d283 2
a284 3

	memcpy ((char *) buf->elts + buf->nelts * buf->elt_size, ptr,
		n_elem * buf->elt_size);
@


1.1
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a275 2

/* vim:set tabstop=8 softtabstop=4 shiftwidth=4: */
@

