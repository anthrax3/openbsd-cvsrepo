head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.30
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.28
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.26
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.24
	OPENBSD_5_0:1.12.0.22
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.20
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.18
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.14
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.11.19.23.34.56;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	sr9v9L5qZs3TeEb4;

1.18
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.17;
commitid	BIjrMDODd4w0xnpk;

1.17
date	2015.11.19.23.04.51;	author tedu;	state Exp;
branches;
next	1.16;
commitid	S1mOxGQqBoiBveCO;

1.16
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.15;
commitid	cuVuNj9APX2eFzx2;

1.15
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.14;
commitid	TCPdLh99ETkn9X6R;

1.14
date	2015.10.15.05.57.09;	author mmcc;	state Exp;
branches;
next	1.13;
commitid	hVghKwalTGZmvBwG;

1.13
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.04.16.18.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.08.00.18.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.31.22.49.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.00.56.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.30.10.53.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.21.05.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Replace Char (defined as unsigned char) with u_char.

ok tedu@@
@
text
@/*	$OpenBSD: misc.c,v 1.18 2015/11/19 23:20:34 tedu Exp $	*/

/* misc - miscellaneous flex routines */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"
#include "tables.h"

#define CMD_IF_TABLES_SER    "%if-tables-serialization"
#define CMD_TABLES_YYDMAP    "%tables-yydmap"
#define CMD_DEFINE_YYTABLES  "%define-yytables"
#define CMD_IF_CPP_ONLY      "%if-c++-only"
#define CMD_IF_C_ONLY        "%if-c-only"
#define CMD_IF_C_OR_CPP      "%if-c-or-c++"
#define CMD_NOT_FOR_HEADER   "%not-for-header"
#define CMD_OK_FOR_HEADER    "%ok-for-header"
#define CMD_PUSH             "%push"
#define CMD_POP              "%pop"
#define CMD_IF_REENTRANT     "%if-reentrant"
#define CMD_IF_NOT_REENTRANT "%if-not-reentrant"
#define CMD_IF_BISON_BRIDGE  "%if-bison-bridge"
#define CMD_IF_NOT_BISON_BRIDGE  "%if-not-bison-bridge"
#define CMD_ENDIF            "%endif"

/* we allow the skeleton to push and pop. */
struct sko_state {
	bool dc;		/**< do_copy */
};
static struct sko_state *sko_stack = 0;
static int sko_len = 0, sko_sz = 0;
static void 
sko_push(bool dc)
{
	if (!sko_stack) {
		sko_sz = 1;
		sko_stack = malloc(sizeof(struct sko_state) * sko_sz);
		if (!sko_stack)
			flexfatal(_("allocation of sko_stack failed"));
		sko_len = 0;
	}
	if (sko_len >= sko_sz) {
		sko_sz *= 2;
		sko_stack = realloc(sko_stack, sizeof(struct sko_state) * sko_sz);
	}
	/* initialize to zero and push */
	sko_stack[sko_len].dc = dc;
	sko_len++;
}
static void 
sko_peek(bool * dc)
{
	if (sko_len <= 0)
		flex_die("peek attempt when sko stack is empty");
	if (dc)
		*dc = sko_stack[sko_len - 1].dc;
}
static void 
sko_pop(bool * dc)
{
	sko_peek(dc);
	sko_len--;
	if (sko_len < 0)
		flex_die("popped too many times in skeleton.");
}

/* Append "#define defname value\n" to the running buffer. */
void 
action_define(defname, value)
	const char *defname;
	int value;
{
	char buf[MAXLINE];
	char *cpy;

	if ((int) strlen(defname) > MAXLINE / 2) {
		format_pinpoint_message(_
		    ("name \"%s\" ridiculously long"),
		    defname);
		return;
	}
	snprintf(buf, sizeof(buf), "#define %s %d\n", defname, value);
	add_action(buf);

	/* track #defines so we can undef them when we're done. */
	cpy = copy_string(defname);
	buf_append(&defs_buf, &cpy, 1);
}


/** Append "m4_define([[defname]],[[value]])m4_dnl\n" to the running buffer.
 *  @@param defname The macro name.
 *  @@param value The macro value, can be NULL, which is the same as the empty string.
 */
void 
action_m4_define(const char *defname, const char *value)
{
	char buf[MAXLINE];

	flexfatal("DO NOT USE THIS FUNCTION!");

	if ((int) strlen(defname) > MAXLINE / 2) {
		format_pinpoint_message(_
		    ("name \"%s\" ridiculously long"),
		    defname);
		return;
	}
	snprintf(buf, sizeof(buf), "m4_define([[%s]],[[%s]])m4_dnl\n", defname, value ? value : "");
	add_action(buf);
}

/* Append "new_text" to the running buffer. */
void 
add_action(new_text)
	const char *new_text;
{
	int len = strlen(new_text);

	while (len + action_index >= action_size - 10 /* slop */ ) {
		int new_size = action_size * 2;

		if (new_size <= 0)
			/*
			 * Increase just a little, to try to avoid overflow
			 * on 16-bit machines.
			 */
			action_size += action_size / 8;
		else
			action_size = new_size;

		action_array =
		    reallocate_character_array(action_array,
		    action_size);
	}

	strlcpy(&action_array[action_index], new_text,
	    action_size - action_index);

	action_index += len;
}


/* allocate_array - allocate memory for an integer array of the given size */

void *
allocate_array(size, element_size)
	int size;
	size_t element_size;
{
	void *mem;
	size_t num_bytes = element_size * size;

	mem = malloc(num_bytes);
	if (!mem)
		flexfatal(_
		    ("memory allocation failed in allocate_array()"));

	return mem;
}


/* all_lower - true if a string is all lower-case */

int 
all_lower(str)
	char *str;
{
	while (*str) {
		if (!isascii((u_char) * str) || !islower((u_char) * str))
			return 0;
		++str;
	}

	return 1;
}


/* all_upper - true if a string is all upper-case */

int 
all_upper(str)
	char *str;
{
	while (*str) {
		if (!isascii((u_char) * str) || !isupper((u_char) * str))
			return 0;
		++str;
	}

	return 1;
}


/* intcmp - compares two integers for use by qsort. */

int 
intcmp(const void *a, const void *b)
{
	return *(const int *) a - *(const int *) b;
}


/* check_char - checks a character to make sure it's within the range
 *		we're expecting.  If not, generates fatal error message
 *		and exits.
 */

void 
check_char(c)
	int c;
{
	if (c >= CSIZE)
		lerrsf(_("bad character '%s' detected in check_char()"),
		    readable_form(c));

	if (c >= csize)
		lerrsf(_
		    ("scanner requires -8 flag to use the character %s"),
		    readable_form(c));
}



/* clower - replace upper-case letter to lower-case */

u_char 
clower(c)
	int c;
{
	return (u_char) ((isascii(c) && isupper(c)) ? tolower(c) : c);
}


/* copy_string - returns a dynamically allocated copy of a string */

char *
copy_string(str)
	const char *str;
{
	const char *c1;
	char *c2;
	char *copy;
	unsigned int size;

	/* find length */
	for (c1 = str; *c1; ++c1);

	size = (c1 - str + 1) * sizeof(char);

	copy = (char *) malloc(size);

	if (copy == NULL)
		flexfatal(_("dynamic memory failure in copy_string()"));

	for (c2 = copy; (*c2++ = *str++) != 0;);

	return copy;
}


/* copy_unsigned_string -
 *    returns a dynamically allocated copy of a (potentially) unsigned string
 */

u_char *
copy_unsigned_string(str)
	u_char *str;
{
	u_char *c;
	u_char *copy;

	/* find length */
	for (c = str; *c; ++c);

	copy = allocate_Character_array(c - str + 1);

	for (c = copy; (*c++ = *str++) != 0;);

	return copy;
}


/* cclcmp - compares two characters for use by qsort with '\0' sorting last. */

int 
cclcmp(const void *a, const void *b)
{
	if (!*(const u_char *) a)
		return 1;
	else if (!*(const u_char *) b)
		return -1;
	else
		return *(const u_char *) a - *(const u_char *) b;
}


/* dataend - finish up a block of data declarations */

void 
dataend()
{
	/* short circuit any output */
	if (gentables) {

		if (datapos > 0)
			dataflush();

		/* add terminator for initialization; { for vi */
		outn("    } ;\n");
	}
	dataline = 0;
	datapos = 0;
}


/* dataflush - flush generated data statements */

void 
dataflush()
{
	/* short circuit any output */
	if (!gentables)
		return;

	outc('\n');

	if (++dataline >= NUMDATALINES) {
		/*
		 * Put out a blank line so that the table is grouped into
		 * large blocks that enable the user to find elements easily.
		 */
		outc('\n');
		dataline = 0;
	}
	/* Reset the number of characters written on the current line. */
	datapos = 0;
}


/* flexerror - report an error message and terminate */

void 
flexerror(msg)
	const char *msg;
{
	fprintf(stderr, "%s: %s\n", program_name, msg);
	flexend(1);
}


/* flexfatal - report a fatal error message and terminate */

void 
flexfatal(msg)
	const char *msg;
{
	fprintf(stderr, _("%s: fatal internal error, %s\n"),
	    program_name, msg);
	FLEX_EXIT(1);
}


/* htoi - convert a hexadecimal digit string to an integer value */

int 
htoi(str)
	u_char str[];
{
	unsigned int result;

	(void) sscanf((char *) str, "%x", &result);

	return result;
}


/* lerrif - report an error message formatted with one integer argument */

void 
lerrif(msg, arg)
	const char *msg;
	int arg;
{
	char errmsg[MAXLINE];

	snprintf(errmsg, sizeof(errmsg), msg, arg);
	flexerror(errmsg);
}


/* lerrsf - report an error message formatted with one string argument */

void 
lerrsf(msg, arg)
	const char *msg, arg[];
{
	char errmsg[MAXLINE];

	snprintf(errmsg, sizeof(errmsg) - 1, msg, arg);
	errmsg[sizeof(errmsg) - 1] = 0;	/* ensure NULL termination */
	flexerror(errmsg);
}


/* lerrsf_fatal - as lerrsf, but call flexfatal */

void 
lerrsf_fatal(msg, arg)
	const char *msg, arg[];
{
	char errmsg[MAXLINE];

	snprintf(errmsg, sizeof(errmsg) - 1, msg, arg);
	errmsg[sizeof(errmsg) - 1] = 0;	/* ensure NULL termination */
	flexfatal(errmsg);
}


/* line_directive_out - spit out a "#line" statement */

void 
line_directive_out(output_file, do_infile)
	FILE *output_file;
	int do_infile;
{
	char directive[MAXLINE], filename[MAXLINE];
	char *s1, *s2, *s3;
	static const char *line_fmt = "#line %d \"%s\"\n";

	if (!gen_line_dirs)
		return;

	s1 = do_infile ? infilename : "M4_YY_OUTFILE_NAME";

	if (do_infile && !s1)
		s1 = "<stdin>";

	s2 = filename;
	s3 = &filename[sizeof(filename) - 2];

	while (s2 < s3 && *s1) {
		if (*s1 == '\\')
			/* Escape the '\' */
			*s2++ = '\\';

		*s2++ = *s1++;
	}

	*s2 = '\0';

	if (do_infile)
		snprintf(directive, sizeof(directive), line_fmt, linenum, filename);
	else {
		snprintf(directive, sizeof(directive), line_fmt, 0, filename);
	}

	/*
	 * If output_file is nil then we should put the directive in the
	 * accumulated actions.
	 */
	if (output_file) {
		fputs(directive, output_file);
	} else
		add_action(directive);
}


/* mark_defs1 - mark the current position in the action array as
 *               representing where the user's section 1 definitions end
 *		 and the prolog begins
 */
void 
mark_defs1()
{
	defs1_offset = 0;
	action_array[action_index++] = '\0';
	action_offset = prolog_offset = action_index;
	action_array[action_index] = '\0';
}


/* mark_prolog - mark the current position in the action array as
 *               representing the end of the action prolog
 */
void 
mark_prolog()
{
	action_array[action_index++] = '\0';
	action_offset = action_index;
	action_array[action_index] = '\0';
}


/* mk2data - generate a data statement for a two-dimensional array
 *
 * Generates a data statement initializing the current 2-D array to "value".
 */
void 
mk2data(value)
	int value;
{
	/* short circuit any output */
	if (!gentables)
		return;

	if (datapos >= NUMDATAITEMS) {
		outc(',');
		dataflush();
	}
	if (datapos == 0)
		/* Indent. */
		out("    ");

	else
		outc(',');

	++datapos;

	out_dec("%5d", value);
}


/* mkdata - generate a data statement
 *
 * Generates a data statement initializing the current array element to
 * "value".
 */
void 
mkdata(value)
	int value;
{
	/* short circuit any output */
	if (!gentables)
		return;

	if (datapos >= NUMDATAITEMS) {
		outc(',');
		dataflush();
	}
	if (datapos == 0)
		/* Indent. */
		out("    ");
	else
		outc(',');

	++datapos;

	out_dec("%5d", value);
}


/* myctoi - return the integer represented by a string of digits */

int 
myctoi(array)
	const char *array;
{
	int val = 0;

	(void) sscanf(array, "%d", &val);

	return val;
}


/* myesc - return character corresponding to escape sequence */

u_char 
myesc(array)
	u_char array[];
{
	u_char c, esc_char;

	switch (array[1]) {
	case 'b':
		return '\b';
	case 'f':
		return '\f';
	case 'n':
		return '\n';
	case 'r':
		return '\r';
	case 't':
		return '\t';

#if defined (__STDC__)
	case 'a':
		return '\a';
	case 'v':
		return '\v';
#else
	case 'a':
		return '\007';
	case 'v':
		return '\013';
#endif

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
		{		/* \<octal> */
			int sptr = 1;

			while (isascii(array[sptr]) &&
			    isdigit(array[sptr]))
				/*
				 * Don't increment inside loop control
				 * because if isdigit() is a macro it might
				 * expand into multiple increments ...
				 */
				++sptr;

			c = array[sptr];
			array[sptr] = '\0';

			esc_char = otoi(array + 1);

			array[sptr] = c;

			return esc_char;
		}

	case 'x':
		{		/* \x<hex> */
			int sptr = 2;

			while (isascii(array[sptr]) &&
			    isxdigit(array[sptr]))
				/*
				 * Don't increment inside loop control
				 * because if isdigit() is a macro it might
				 * expand into multiple increments ...
				 */
				++sptr;

			c = array[sptr];
			array[sptr] = '\0';

			esc_char = htoi(array + 2);

			array[sptr] = c;

			return esc_char;
		}

	default:
		return array[1];
	}
}


/* otoi - convert an octal digit string to an integer value */

int 
otoi(str)
	u_char str[];
{
	unsigned int result;

	(void) sscanf((char *) str, "%o", &result);
	return result;
}


/* out - various flavors of outputing a (possibly formatted) string for the
 *	 generated scanner, keeping track of the line count.
 */

void 
out(str)
	const char *str;
{
	fputs(str, stdout);
}

void 
out_dec(fmt, n)
	const char *fmt;
	int n;
{
	fprintf(stdout, fmt, n);
}

void 
out_dec2(fmt, n1, n2)
	const char *fmt;
	int n1, n2;
{
	fprintf(stdout, fmt, n1, n2);
}

void 
out_hex(fmt, x)
	const char *fmt;
	unsigned int x;
{
	fprintf(stdout, fmt, x);
}

void 
out_str(fmt, str)
	const char *fmt, str[];
{
	fprintf(stdout, fmt, str);
}

void 
out_str3(fmt, s1, s2, s3)
	const char *fmt, s1[], s2[], s3[];
{
	fprintf(stdout, fmt, s1, s2, s3);
}

void 
out_str_dec(fmt, str, n)
	const char *fmt, str[];
	int n;
{
	fprintf(stdout, fmt, str, n);
}

void 
outc(c)
	int c;
{
	fputc(c, stdout);
}

void 
outn(str)
	const char *str;
{
	fputs(str, stdout);
	fputc('\n', stdout);
}

/** Print "m4_define( [[def]], [[val]])m4_dnl\n".
 * @@param def The m4 symbol to define.
 * @@param val The definition; may be NULL.
 * @@return buf
 */
void 
out_m4_define(const char *def, const char *val)
{
	const char *fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
	fprintf(stdout, fmt, def, val ? val : "");
}


/* readable_form - return the human-readable form of a character
 *
 * The returned string is in static storage.
 */

char *
readable_form(c)
	int c;
{
	static char rform[10];

	if ((c >= 0 && c < 32) || c >= 127) {
		switch (c) {
		case '\b':
			return "\\b";
		case '\f':
			return "\\f";
		case '\n':
			return "\\n";
		case '\r':
			return "\\r";
		case '\t':
			return "\\t";

#if defined (__STDC__)
		case '\a':
			return "\\a";
		case '\v':
			return "\\v";
#endif

		default:
			snprintf(rform, sizeof(rform), "\\%.3o", (unsigned int) c);
			return rform;
		}
	} else if (c == ' ')
		return "' '";

	else {
		rform[0] = c;
		rform[1] = '\0';

		return rform;
	}
}


/* reallocate_array - increase the size of a dynamic array */

void *
reallocate_array(array, size, element_size)
	void *array;
	int size;
	size_t element_size;
{
	void *new_array;
	size_t num_bytes = element_size * size;

	new_array = realloc(array, num_bytes);
	if (!new_array)
		flexfatal(_("attempt to increase array size failed"));

	return new_array;
}


/* skelout - write out one section of the skeleton file
 *
 * Description
 *    Copies skelfile or skel array to stdout until a line beginning with
 *    "%%" or EOF is found.
 */
void 
skelout()
{
	char buf_storage[MAXLINE];
	char *buf = buf_storage;
	bool do_copy = true;

	/* "reset" the state by clearing the buffer and pushing a '1' */
	if (sko_len > 0)
		sko_peek(&do_copy);
	sko_len = 0;
	sko_push(do_copy = true);


	/*
	 * Loop pulling lines either from the skelfile, if we're using one,
	 * or from the skel[] array.
	 */
	while (skelfile ?
	    (fgets(buf, MAXLINE, skelfile) != NULL) :
	    ((buf = (char *) skel[skel_ind++]) != 0)) {

		if (skelfile)
			chomp(buf);

		/* copy from skel array */
		if (buf[0] == '%') {	/* control line */
			/* print the control line as a comment. */
			if (ddebug && buf[1] != '#') {
				if (buf[strlen(buf) - 1] == '\\')
					out_str("/* %s */\\\n", buf);
				else
					out_str("/* %s */\n", buf);
			}
			/*
			 * We've been accused of using cryptic markers in the
			 * skel. So we'll use
			 * emacs-style-hyphenated-commands. We might consider
			 * a hash if this if-else-if-else chain gets too
			 * large.
			 */
#define cmd_match(s) (strncmp(buf,(s),strlen(s))==0)

			if (buf[1] == '%') {
				/* %% is a break point for skelout() */
				return;
			} else if (cmd_match(CMD_PUSH)) {
				sko_push(do_copy);
				if (ddebug) {
					out_str("/*(state = (%s) */", do_copy ? "true" : "false");
				}
				out_str("%s\n", buf[strlen(buf) - 1] == '\\' ? "\\" : "");
			} else if (cmd_match(CMD_POP)) {
				sko_pop(&do_copy);
				if (ddebug) {
					out_str("/*(state = (%s) */", do_copy ? "true" : "false");
				}
				out_str("%s\n", buf[strlen(buf) - 1] == '\\' ? "\\" : "");
			} else if (cmd_match(CMD_IF_REENTRANT)) {
				sko_push(do_copy);
				do_copy = reentrant && do_copy;
			} else if (cmd_match(CMD_IF_NOT_REENTRANT)) {
				sko_push(do_copy);
				do_copy = !reentrant && do_copy;
			} else if (cmd_match(CMD_IF_BISON_BRIDGE)) {
				sko_push(do_copy);
				do_copy = bison_bridge_lval && do_copy;
			} else if (cmd_match(CMD_IF_NOT_BISON_BRIDGE)) {
				sko_push(do_copy);
				do_copy = !bison_bridge_lval && do_copy;
			} else if (cmd_match(CMD_ENDIF)) {
				sko_pop(&do_copy);
			} else if (cmd_match(CMD_IF_TABLES_SER)) {
				do_copy = do_copy && tablesext;
			} else if (cmd_match(CMD_TABLES_YYDMAP)) {
				if (tablesext && yydmap_buf.elts)
					outn((char *) (yydmap_buf.elts));
			} else if (cmd_match(CMD_DEFINE_YYTABLES)) {
				out_str("#define YYTABLES_NAME \"%s\"\n",
				    tablesname ? tablesname : "yytables");
			} else if (cmd_match(CMD_IF_CPP_ONLY)) {
				/* only for C++ */
				sko_push(do_copy);
				do_copy = C_plus_plus;
			} else if (cmd_match(CMD_IF_C_ONLY)) {
				/* %- only for C */
				sko_push(do_copy);
				do_copy = !C_plus_plus;
			} else if (cmd_match(CMD_IF_C_OR_CPP)) {
				/* %* for C and C++ */
				sko_push(do_copy);
				do_copy = true;
			} else if (cmd_match(CMD_NOT_FOR_HEADER)) {
				/* %c begin linkage-only (non-header) code. */
				OUT_BEGIN_CODE();
			} else if (cmd_match(CMD_OK_FOR_HEADER)) {
				/* %e end linkage-only code. */
				OUT_END_CODE();
			} else if (buf[1] == '#') {
				/* %# a comment in the skel. ignore. */
			} else {
				flexfatal(_("bad line in skeleton file"));
			}
		} else if (do_copy)
			outn(buf);
	}			/* end while */
}


/* transition_struct_out - output a yy_trans_info structure
 *
 * outputs the yy_trans_info structure with the two elements, element_v and
 * element_n.  Formats the output with spaces and carriage returns.
 */

void 
transition_struct_out(element_v, element_n)
	int element_v, element_n;
{

	/* short circuit any output */
	if (!gentables)
		return;

	out_dec2(" {%4d,%4d },", element_v, element_n);

	datapos += TRANS_STRUCT_PRINT_LENGTH;

	if (datapos >= 79 - TRANS_STRUCT_PRINT_LENGTH) {
		outc('\n');

		if (++dataline % 10 == 0)
			outc('\n');

		datapos = 0;
	}
}


/* The following is only needed when building flex's parser using certain
 * broken versions of bison.
 */
void *
yy_flex_xmalloc(size)
	int size;
{
	void *result = malloc((size_t) size);

	if (!result)
		flexfatal(_
		    ("memory allocation failed in yy_flex_xmalloc()"));

	return result;
}


/* Remove all '\n' and '\r' characters, if any, from the end of str.
 * str can be any null-terminated string, or NULL.
 * returns str. */
char *
chomp(str)
	char *str;
{
	char *p = str;

	if (!str || !*str)	/* s is null or empty string */
		return str;

	/* find end of string minus one */
	while (*p)
		++p;
	--p;

	/* eat newlines */
	while (p >= str && (*p == '\r' || *p == '\n'))
		*p-- = 0;
	return str;
}
@


1.18
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.17 2015/11/19 23:04:51 tedu Exp $	*/
d198 1
a198 1
		if (!isascii((Char) * str) || !islower((Char) * str))
d214 1
a214 1
		if (!isascii((Char) * str) || !isupper((Char) * str))
d255 1
a255 1
Char 
d259 1
a259 1
	return (Char) ((isascii(c) && isupper(c)) ? tolower(c) : c);
d294 1
a294 1
Char *
d296 1
a296 1
	Char *str;
d298 2
a299 2
	Char *c;
	Char *copy;
d317 1
a317 1
	if (!*(const Char *) a)
d319 1
a319 1
	else if (!*(const Char *) b)
d322 1
a322 1
		return *(const Char *) a - *(const Char *) b;
d396 1
a396 1
	Char str[];
d597 1
a597 1
Char 
d599 1
a599 1
	Char array[];
d601 1
a601 1
	Char c, esc_char;
d690 1
a690 1
	Char str[];
@


1.17
log
@it should be safe to assume the presence of memset these days instead of
implementing a local version.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.16 2015/11/19 22:52:40 tedu Exp $	*/
d66 1
a66 1
		sko_stack = (struct sko_state *) flex_alloc(sizeof(struct sko_state) * sko_sz);
d73 1
a73 1
		sko_stack = (struct sko_state *) flex_realloc(sko_stack, sizeof(struct sko_state) * sko_sz);
d182 1
a182 1
	mem = flex_alloc(num_bytes);
d279 1
a279 1
	copy = (char *) flex_alloc(size);
d842 1
a842 1
	new_array = flex_realloc(array, num_bytes);
d1002 1
a1002 1
	void *result = flex_alloc((size_t) size);
@


1.16
log
@orbital strike from moonbase knf
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.15 2015/11/19 19:43:40 tedu Exp $	*/
a1010 19

/* zero_out - set a region of memory to 0
 *
 * Sets region_ptr[0] through region_ptr[size_in_bytes - 1] to zero.
 */

void 
zero_out(region_ptr, size_in_bytes)
	char *region_ptr;
	size_t size_in_bytes;
{
	char *rp, *rp_end;

	rp = region_ptr;
	rp_end = region_ptr + size_in_bytes;

	while (rp < rp_end)
		*rp++ = 0;
}
@


1.15
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.14 2015/10/15 05:57:09 mmcc Exp $	*/
d57 1
a57 1
    bool dc; /**< do_copy */
d59 35
a93 33
static struct sko_state *sko_stack=0;
static int sko_len=0,sko_sz=0;
static void sko_push(bool dc)
{
    if(!sko_stack){
        sko_sz = 1;
        sko_stack = (struct sko_state*)flex_alloc(sizeof(struct sko_state)*sko_sz);
        if (!sko_stack)
            flexfatal(_("allocation of sko_stack failed"));
        sko_len = 0;
    }
    if(sko_len >= sko_sz){
        sko_sz *= 2;
        sko_stack = (struct sko_state*)flex_realloc(sko_stack,sizeof(struct sko_state)*sko_sz);
    }
    
    /* initialize to zero and push */
    sko_stack[sko_len].dc = dc;
    sko_len++;
}
static void sko_peek(bool *dc)
{
    if(sko_len <= 0)
        flex_die("peek attempt when sko stack is empty");
    if(dc)
        *dc = sko_stack[sko_len-1].dc;
}
static void sko_pop(bool* dc)
{
    sko_peek(dc);
    sko_len--;
    if(sko_len < 0)
        flex_die("popped too many times in skeleton.");
d97 12
a108 11
void action_define (defname, value)
     const char *defname;
     int value;
{
	char    buf[MAXLINE];
	char   *cpy;

	if ((int) strlen (defname) > MAXLINE / 2) {
		format_pinpoint_message (_
					 ("name \"%s\" ridiculously long"),
					 defname);
d111 2
a112 3

	snprintf (buf, sizeof(buf), "#define %s %d\n", defname, value);
	add_action (buf);
d115 2
a116 2
	cpy = copy_string (defname);
	buf_append (&defs_buf, &cpy, 1);
d124 2
a125 1
void action_m4_define (const char *defname, const char * value)
d127 1
a127 1
	char    buf[MAXLINE];
d129 1
a129 1
    flexfatal ("DO NOT USE THIS FUNCTION!");
d131 4
a134 4
	if ((int) strlen (defname) > MAXLINE / 2) {
		format_pinpoint_message (_
					 ("name \"%s\" ridiculously long"),
					 defname);
d137 2
a138 3

	snprintf (buf, sizeof(buf), "m4_define([[%s]],[[%s]])m4_dnl\n", defname, value?value:"");
	add_action (buf);
d142 3
a144 2
void add_action (new_text)
     const char   *new_text;
d146 1
a146 1
	int     len = strlen (new_text);
d149 1
a149 1
		int     new_size = action_size * 2;
d152 2
a153 1
			/* Increase just a little, to try to avoid overflow
d161 2
a162 2
			reallocate_character_array (action_array,
						    action_size);
d165 2
a166 2
	strlcpy ( &action_array[action_index], new_text,
		action_size - action_index );
d174 4
a177 3
void   *allocate_array (size, element_size)
     int size;
     size_t element_size;
d180 1
a180 1
	size_t  num_bytes = element_size * size;
d182 1
a182 1
	mem = flex_alloc (num_bytes);
d184 2
a185 2
		flexfatal (_
			   ("memory allocation failed in allocate_array()"));
d193 3
a195 2
int all_lower (str)
     char *str;
d198 1
a198 1
		if (!isascii ((Char) * str) || !islower ((Char) * str))
d209 3
a211 2
int all_upper (str)
     char *str;
d214 1
a214 1
		if (!isascii ((Char) * str) || !isupper ((Char) * str))
d225 2
a226 1
int intcmp (const void *a, const void *b)
d228 1
a228 1
  return *(const int *) a - *(const int *) b;
d237 3
a239 2
void check_char (c)
     int c;
d242 2
a243 2
		lerrsf (_("bad character '%s' detected in check_char()"),
			readable_form (c));
d246 3
a248 3
		lerrsf (_
			("scanner requires -8 flag to use the character %s"),
			readable_form (c));
d255 3
a257 2
Char clower (c)
     int c;
d259 1
a259 1
	return (Char) ((isascii (c) && isupper (c)) ? tolower (c) : c);
d265 3
a267 2
char   *copy_string (str)
     const char *str;
d271 1
a271 1
	char   *copy;
d275 1
a275 1
	for (c1 = str; *c1; ++c1) ;
d277 1
a277 1
	size = (c1 - str + 1) * sizeof (char);
d279 1
a279 1
	copy = (char *) flex_alloc (size);
d282 1
a282 1
		flexfatal (_("dynamic memory failure in copy_string()"));
d284 1
a284 1
	for (c2 = copy; (*c2++ = *str++) != 0;) ;
d294 3
a296 2
Char   *copy_unsigned_string (str)
     Char *str;
d299 1
a299 1
	Char   *copy;
d302 1
a302 1
	for (c = str; *c; ++c) ;
d304 1
a304 1
	copy = allocate_Character_array (c - str + 1);
d306 1
a306 1
	for (c = copy; (*c++ = *str++) != 0;) ;
d314 2
a315 1
int cclcmp (const void *a, const void *b)
d317 4
a320 5
  if (!*(const Char *) a)
	return 1;
  else
	if (!*(const Char *) b)
	  return - 1;
d322 1
a322 1
	  return *(const Char *) a - *(const Char *) b;
d328 2
a329 1
void dataend ()
d335 1
a335 1
			dataflush ();
d338 1
a338 1
		outn ("    } ;\n");
d347 2
a348 1
void dataflush ()
d354 1
a354 1
	outc ('\n');
d357 2
a358 1
		/* Put out a blank line so that the table is grouped into
d361 1
a361 1
		outc ('\n');
a363 1

d371 3
a373 2
void flexerror (msg)
     const char *msg;
d375 2
a376 2
	fprintf (stderr, "%s: %s\n", program_name, msg);
	flexend (1);
d382 7
a388 6
void flexfatal (msg)
     const char *msg;
{
	fprintf (stderr, _("%s: fatal internal error, %s\n"),
		 program_name, msg);
	FLEX_EXIT (1);
d394 3
a396 2
int htoi (str)
     Char str[];
d400 1
a400 1
	(void) sscanf ((char *) str, "%x", &result);
d408 4
a411 3
void lerrif (msg, arg)
     const char *msg;
     int arg;
d413 1
a413 1
	char    errmsg[MAXLINE];
d415 2
a416 2
	snprintf (errmsg, sizeof(errmsg), msg, arg);
	flexerror (errmsg);
d422 2
a423 1
void lerrsf (msg, arg)
d426 1
a426 1
	char    errmsg[MAXLINE];
d428 3
a430 3
	snprintf (errmsg, sizeof(errmsg)-1, msg, arg);
	errmsg[sizeof(errmsg)-1] = 0; /* ensure NULL termination */
	flexerror (errmsg);
d436 2
a437 1
void lerrsf_fatal (msg, arg)
d440 1
a440 1
	char    errmsg[MAXLINE];
d442 3
a444 3
	snprintf (errmsg, sizeof(errmsg)-1, msg, arg);
	errmsg[sizeof(errmsg)-1] = 0; /* ensure NULL termination */
	flexfatal (errmsg);
d450 4
a453 3
void line_directive_out (output_file, do_infile)
     FILE   *output_file;
     int do_infile;
d455 2
a456 2
	char    directive[MAXLINE], filename[MAXLINE];
	char   *s1, *s2, *s3;
d465 2
a466 2
        s1 = "<stdin>";
    
d468 1
a468 1
	s3 = &filename[sizeof (filename) - 2];
d481 1
a481 1
		snprintf (directive, sizeof(directive), line_fmt, linenum, filename);
d483 1
a483 1
		snprintf (directive, sizeof(directive), line_fmt, 0, filename);
d486 3
a488 2
	/* If output_file is nil then we should put the directive in
	 * the accumulated actions.
d491 3
a493 4
		fputs (directive, output_file);
	}
	else
		add_action (directive);
d501 2
a502 1
void mark_defs1 ()
d514 2
a515 1
void mark_prolog ()
d527 3
a529 2
void mk2data (value)
     int value;
d536 2
a537 2
		outc (',');
		dataflush ();
a538 1

d541 1
a541 1
		out ("    ");
d544 1
a544 1
		outc (',');
d548 1
a548 1
	out_dec ("%5d", value);
d557 3
a559 2
void mkdata (value)
     int value;
d566 2
a567 2
		outc (',');
		dataflush ();
a568 1

d571 1
a571 1
		out ("    ");
d573 1
a573 1
		outc (',');
d577 1
a577 1
	out_dec ("%5d", value);
d583 3
a585 2
int myctoi (array)
     const char *array;
d587 1
a587 1
	int     val = 0;
d589 1
a589 1
	(void) sscanf (array, "%d", &val);
d597 3
a599 2
Char myesc (array)
     Char array[];
d601 1
a601 1
	Char    c, esc_char;
d636 1
a636 1
			int     sptr = 1;
d638 4
a641 3
			while (isascii (array[sptr]) &&
			       isdigit (array[sptr]))
				/* Don't increment inside loop control
d650 1
a650 1
			esc_char = otoi (array + 1);
d659 1
a659 1
			int     sptr = 2;
d661 4
a664 3
			while (isascii (array[sptr]) &&
			       isxdigit (array[sptr]))
				/* Don't increment inside loop control
d673 1
a673 1
			esc_char = htoi (array + 2);
d688 3
a690 2
int otoi (str)
     Char str[];
d694 1
a694 1
	(void) sscanf ((char *) str, "%o", &result);
d703 3
a705 2
void out (str)
     const char *str;
d707 1
a707 1
	fputs (str, stdout);
d710 4
a713 3
void out_dec (fmt, n)
     const char *fmt;
     int n;
d715 1
a715 1
	fprintf (stdout, fmt, n);
d718 4
a721 3
void out_dec2 (fmt, n1, n2)
     const char *fmt;
     int n1, n2;
d723 1
a723 1
	fprintf (stdout, fmt, n1, n2);
d726 4
a729 3
void out_hex (fmt, x)
     const char *fmt;
     unsigned int x;
d731 1
a731 1
	fprintf (stdout, fmt, x);
d734 3
a736 2
void out_str (fmt, str)
     const char *fmt, str[];
d738 1
a738 1
	fprintf (stdout,fmt, str);
d741 3
a743 2
void out_str3 (fmt, s1, s2, s3)
     const char *fmt, s1[], s2[], s3[];
d745 1
a745 1
	fprintf (stdout,fmt, s1, s2, s3);
d748 4
a751 3
void out_str_dec (fmt, str, n)
     const char *fmt, str[];
     int n;
d753 1
a753 1
	fprintf (stdout,fmt, str, n);
d756 3
a758 2
void outc (c)
     int c;
d760 1
a760 1
	fputc (c, stdout);
d763 3
a765 2
void outn (str)
     const char *str;
d767 2
a768 2
	fputs (str,stdout);
    fputc('\n',stdout);
d776 2
a777 1
void out_m4_define (const char* def, const char* val)
d779 2
a780 2
    const char * fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
    fprintf(stdout, fmt, def, val?val:"");
d789 3
a791 2
char   *readable_form (c)
     int c;
d816 1
a816 1
			snprintf (rform, sizeof(rform), "\\%.3o", (unsigned int) c);
d819 1
a819 3
	}

	else if (c == ' ')
d833 5
a837 4
void   *reallocate_array (array, size, element_size)
     void   *array;
     int size;
     size_t element_size;
d840 1
a840 1
	size_t  num_bytes = element_size * size;
d842 1
a842 1
	new_array = flex_realloc (array, num_bytes);
d844 1
a844 1
		flexfatal (_("attempt to increase array size failed"));
d856 2
a857 1
void skelout ()
d859 14
a872 13
	char    buf_storage[MAXLINE];
	char   *buf = buf_storage;
	bool   do_copy = true;

    /* "reset" the state by clearing the buffer and pushing a '1' */
    if(sko_len > 0)
        sko_peek(&do_copy);
    sko_len = 0;
    sko_push(do_copy=true);


	/* Loop pulling lines either from the skelfile, if we're using
	 * one, or from the skel[] array.
d875 2
a876 2
	       (fgets (buf, MAXLINE, skelfile) != NULL) :
	       ((buf = (char *) skel[skel_ind++]) != 0)) {
d879 1
a879 1
			chomp (buf);
d885 2
a886 2
				if (buf[strlen (buf) - 1] == '\\')
					out_str ("/* %s */\\\n", buf);
d888 1
a888 1
					out_str ("/* %s */\n", buf);
d890 6
a895 5

			/* We've been accused of using cryptic markers in the skel.
			 * So we'll use emacs-style-hyphenated-commands.
             * We might consider a hash if this if-else-if-else
             * chain gets too large.
d902 29
a930 38
			}
            else if (cmd_match (CMD_PUSH)){
                sko_push(do_copy);
                if(ddebug){
                    out_str("/*(state = (%s) */",do_copy?"true":"false");
                }
                out_str("%s\n", buf[strlen (buf) - 1] =='\\' ? "\\" : "");
            }
            else if (cmd_match (CMD_POP)){
                sko_pop(&do_copy);
                if(ddebug){
                    out_str("/*(state = (%s) */",do_copy?"true":"false");
                }
                out_str("%s\n", buf[strlen (buf) - 1] =='\\' ? "\\" : "");
            }
            else if (cmd_match (CMD_IF_REENTRANT)){
                sko_push(do_copy);
                do_copy = reentrant && do_copy;
            }
            else if (cmd_match (CMD_IF_NOT_REENTRANT)){
                sko_push(do_copy);
                do_copy = !reentrant && do_copy;
            }
            else if (cmd_match(CMD_IF_BISON_BRIDGE)){
                sko_push(do_copy);
                do_copy = bison_bridge_lval && do_copy;
            }
            else if (cmd_match(CMD_IF_NOT_BISON_BRIDGE)){
                sko_push(do_copy);
                do_copy = !bison_bridge_lval && do_copy;
            }
            else if (cmd_match (CMD_ENDIF)){
                sko_pop(&do_copy);
            }
			else if (cmd_match (CMD_IF_TABLES_SER)) {
                do_copy = do_copy && tablesext;
			}
			else if (cmd_match (CMD_TABLES_YYDMAP)) {
d932 5
a936 7
					outn ((char *) (yydmap_buf.elts));
			}
            else if (cmd_match (CMD_DEFINE_YYTABLES)) {
                out_str("#define YYTABLES_NAME \"%s\"\n",
                        tablesname?tablesname:"yytables");
            }
			else if (cmd_match (CMD_IF_CPP_ONLY)) {
d938 1
a938 1
                sko_push(do_copy);
d940 1
a940 2
			}
			else if (cmd_match (CMD_IF_C_ONLY)) {
d942 1
a942 1
                sko_push(do_copy);
d944 1
a944 2
			}
			else if (cmd_match (CMD_IF_C_OR_CPP)) {
d946 1
a946 1
                sko_push(do_copy);
d948 1
a948 2
			}
			else if (cmd_match (CMD_NOT_FOR_HEADER)) {
d950 2
a951 3
				OUT_BEGIN_CODE ();
			}
			else if (cmd_match (CMD_OK_FOR_HEADER)) {
d953 2
a954 3
				OUT_END_CODE ();
			}
			else if (buf[1] == '#') {
d956 2
d959 2
a960 7
			else {
				flexfatal (_("bad line in skeleton file"));
			}
		}

		else if (do_copy) 
            outn (buf);
d971 3
a973 2
void transition_struct_out (element_v, element_n)
     int element_v, element_n;
d980 1
a980 1
	out_dec2 (" {%4d,%4d },", element_v, element_n);
d985 1
a985 1
		outc ('\n');
d988 1
a988 1
			outc ('\n');
d998 3
a1000 2
void   *yy_flex_xmalloc (size)
     int size;
d1002 1
a1002 1
	void   *result = flex_alloc ((size_t) size);
d1005 2
a1006 2
		flexfatal (_
			   ("memory allocation failed in yy_flex_xmalloc()"));
d1017 4
a1020 3
void zero_out (region_ptr, size_in_bytes)
     char   *region_ptr;
     size_t size_in_bytes;
d1034 3
a1036 2
char   *chomp (str)
     char   *str;
d1038 1
a1038 1
	char   *p = str;
@


1.14
log
@Cast arguments of ctype functions to Char, a lexism defined as unsigned
char.

Part of a larger attempt to audit ctype function argument types with
Coccinelle.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.13 2013/10/27 18:31:24 guenther Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.13 2013/10/27 18:31:24 guenther Exp $ */
d37 79
d118 14
a131 10
void action_define( defname, value )
char *defname;
int value;
	{
	char buf[MAXLINE];

	if ( (int) strlen( defname ) > MAXLINE / 2 )
		{
		format_pinpoint_message( _( "name \"%s\" ridiculously long" ), 
			defname );
a132 4
		}

	snprintf( buf, sizeof buf, "#define %s %d\n", defname, value );
	add_action( buf );
d135 9
d145 2
a146 4
void add_action( new_text )
char *new_text;
	{
	int len = strlen( new_text );
d148 1
a148 5
	while ( len + action_index >= action_size - 10 /* slop */ )
		{
		int new_size = action_size * 2;

		if ( new_size <= 0 )
d157 3
a159 2
			reallocate_character_array( action_array, action_size );
		}
d161 1
a161 1
	strlcpy( &action_array[action_index], new_text,
d165 1
a165 1
	}
d170 4
a173 4
void *allocate_array( size, element_size )
int size;
size_t element_size;
	{
d175 1
a175 1
	size_t num_bytes = element_size * size;
d177 4
a180 4
	mem = flex_alloc( num_bytes );
	if ( ! mem )
		flexfatal(
			_( "memory allocation failed in allocate_array()" ) );
d183 1
a183 1
	}
d188 5
a192 6
int all_lower( str )
char *str;
	{
	while ( *str )
		{
		if ( ! isascii( (Char) *str ) || ! islower( (Char) *str ) )
d195 1
a195 1
		}
d198 1
a198 1
	}
d203 5
a207 6
int all_upper( str )
char *str;
	{
	while ( *str )
		{
		if ( ! isascii( (Char) *str ) || ! isupper( (Char) *str ) )
d210 1
a210 1
		}
d213 2
a214 1
	}
d216 1
d218 4
a221 29
/* bubble - bubble sort an integer array in increasing order
 *
 * synopsis
 *   int v[n], n;
 *   void bubble( v, n );
 *
 * description
 *   sorts the first n elements of array v and replaces them in
 *   increasing order.
 *
 * passed
 *   v - the array to be sorted
 *   n - the number of elements of 'v' to be sorted
 */

void bubble( v, n )
int v[], n;
	{
	int i, j, k;

	for ( i = n; i > 1; --i )
		for ( j = 1; j < i; ++j )
			if ( v[j] > v[j + 1] )	/* compare */
				{
				k = v[j];	/* exchange */
				v[j] = v[j + 1];
				v[j + 1] = k;
				}
	}
d229 12
a240 12
void check_char( c )
int c;
	{
	if ( c >= CSIZE )
		lerrsf( _( "bad character '%s' detected in check_char()" ),
			readable_form( c ) );

	if ( c >= csize )
		lerrsf(
		_( "scanner requires -8 flag to use the character %s" ),
			readable_form( c ) );
	}
d246 5
a250 5
Char clower( c )
int c;
	{
	return (Char) ((isascii( c ) && isupper( c )) ? tolower( c ) : c);
	}
d255 3
a257 3
char *copy_string( str )
const char *str;
	{
d260 1
a260 1
	char *copy;
d264 3
a266 2
	for ( c1 = str; *c1; ++c1 )
		;
d268 1
a268 2
	size = (c1 - str + 1) * sizeof( char );
	copy = (char *) flex_alloc( size );
d270 2
a271 2
	if ( copy == NULL )
		flexfatal( _( "dynamic memory failure in copy_string()" ) );
d273 1
a273 2
	for ( c2 = copy; (*c2++ = *str++) != 0; )
		;
d276 1
a276 1
	}
d283 3
a285 3
Char *copy_unsigned_string( str )
Char *str;
	{
d287 1
a287 1
	Char *copy;
d290 1
a290 2
	for ( c = str; *c; ++c )
		;
d292 1
a292 1
	copy = allocate_Character_array( c - str + 1 );
d294 1
a294 2
	for ( c = copy; (*c++ = *str++) != 0; )
		;
d297 2
a298 1
	}
d300 1
d302 10
a311 48
/* cshell - shell sort a character array in increasing order
 *
 * synopsis
 *
 *   Char v[n];
 *   int n, special_case_0;
 *   cshell( v, n, special_case_0 );
 *
 * description
 *   Does a shell sort of the first n elements of array v.
 *   If special_case_0 is true, then any element equal to 0
 *   is instead assumed to have infinite weight.
 *
 * passed
 *   v - array to be sorted
 *   n - number of elements of v to be sorted
 */

void cshell( v, n, special_case_0 )
Char v[];
int n, special_case_0;
	{
	int gap, i, j, jg;
	Char k;

	for ( gap = n / 2; gap > 0; gap = gap / 2 )
		for ( i = gap; i < n; ++i )
			for ( j = i - gap; j >= 0; j = j - gap )
				{
				jg = j + gap;

				if ( special_case_0 )
					{
					if ( v[jg] == 0 )
						break;

					else if ( v[j] != 0 && v[j] <= v[jg] )
						break;
					}

				else if ( v[j] <= v[jg] )
					break;

				k = v[j];
				v[j] = v[jg];
				v[jg] = k;
				}
	}
d316 4
a319 4
void dataend()
	{
	if ( datapos > 0 )
		dataflush();
d321 2
a322 2
	/* add terminator for initialization; { for vi */
	outn( "    } ;\n" );
d324 3
d329 1
a329 1
	}
d334 7
a340 3
void dataflush()
	{
	outc( '\n' );
d342 1
a342 2
	if ( ++dataline >= NUMDATALINES )
		{
d346 1
a346 1
		outc( '\n' );
d348 1
a348 1
		}
d352 1
a352 1
	}
d357 6
a362 6
void flexerror( msg )
const char msg[];
	{
	fprintf( stderr, "%s: %s\n", program_name, msg );
	flexend( 1 );
	}
d367 7
a373 7
void flexfatal( msg )
const char msg[];
	{
	fprintf( stderr, _( "%s: fatal internal error, %s\n" ),
		program_name, msg );
	exit( 1 );
	}
d378 3
a380 3
int htoi( str )
Char str[];
	{
d383 1
a383 1
	(void) sscanf( (char *) str, "%x", &result );
d386 1
a386 1
	}
d391 9
a399 8
void lerrif( msg, arg )
const char msg[];
int arg;
	{
	char errmsg[MAXLINE];
	(void) snprintf( errmsg, sizeof errmsg, msg, arg );
	flexerror( errmsg );
	}
d404 22
a425 8
void lerrsf( msg, arg )
const char msg[], arg[];
	{
	char errmsg[MAXLINE];

	(void) snprintf( errmsg, sizeof errmsg, msg, arg );
	flexerror( errmsg );
	}
d430 7
a436 7
void line_directive_out( output_file, do_infile )
FILE *output_file;
int do_infile;
	{
	char directive[MAXLINE], filename[MAXLINE];
	char *s1, *s2, *s3;
	static const char line_fmt[] = "#line %d \"%s\"\n";
d438 1
a438 1
	if ( ! gen_line_dirs )
d441 1
a441 3
	if ( (do_infile && ! infilename) || (! do_infile && ! outfilename) )
		/* don't know the filename to use, skip */
		return;
d443 3
a445 1
	s1 = do_infile ? infilename : outfilename;
d447 1
a447 1
	s3 = &filename[sizeof( filename ) - 2];
d449 2
a450 3
	while ( s2 < s3 && *s1 )
		{
		if ( *s1 == '\\' )
d455 1
a455 1
		}
d459 5
a463 12
	if ( do_infile )
		snprintf( directive, sizeof directive, line_fmt,
			linenum, filename );
	else
		{
		if ( output_file == stdout )
			/* Account for the line directive itself. */
			++out_linenum;

		snprintf( directive, sizeof directive, line_fmt,
			out_linenum, filename );
		}
d468 3
a470 4
	if ( output_file )
		{
		fputs( directive, output_file );
		}
d472 2
a473 2
		add_action( directive );
	}
d480 2
a481 2
void mark_defs1()
	{
d486 1
a486 1
	}
d492 2
a493 2
void mark_prolog()
	{
d497 1
a497 1
	}
d504 11
a514 8
void mk2data( value )
int value;
	{
	if ( datapos >= NUMDATAITEMS )
		{
		outc( ',' );
		dataflush();
		}
d516 1
a516 1
	if ( datapos == 0 )
d518 1
a518 1
		out( "    " );
d521 1
a521 1
		outc( ',' );
d525 2
a526 2
	out_dec( "%5d", value );
	}
d534 11
a544 8
void mkdata( value )
int value;
	{
	if ( datapos >= NUMDATAITEMS )
		{
		outc( ',' );
		dataflush();
		}
d546 1
a546 1
	if ( datapos == 0 )
d548 1
a548 1
		out( "    " );
d550 1
a550 1
		outc( ',' );
d554 2
a555 2
	out_dec( "%5d", value );
	}
d560 4
a563 4
int myctoi( array )
char array[];
	{
	int val = 0;
d565 1
a565 1
	(void) sscanf( array, "%d", &val );
d568 1
a568 1
	}
d573 22
a594 16
Char myesc( array )
Char array[];
	{
	Char c, esc_char;

	switch ( array[1] )
		{
		case 'b': return '\b';
		case 'f': return '\f';
		case 'n': return '\n';
		case 'r': return '\r';
		case 't': return '\t';

#ifdef __STDC__
		case 'a': return '\a';
		case 'v': return '\v';
d596 4
a599 2
		case 'a': return '\007';
		case 'v': return '\013';
d602 10
a611 10
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
			{ /* \<octal> */
			int sptr = 1;
d613 2
a614 2
			while ( isascii( array[sptr] ) &&
				isdigit( array[sptr] ) )
d624 1
a624 1
			esc_char = otoi( array + 1 );
d629 1
a629 1
			}
d631 3
a633 3
		case 'x':
			{ /* \x<hex> */
			int sptr = 2;
d635 2
a636 2
			while ( isascii( array[sptr] ) &&
				isxdigit( array[sptr] ) )
d646 1
a646 1
			esc_char = htoi( array + 2 );
d651 1
a651 1
			}
d653 2
a654 3
		default:
			return array[1];
		}
d656 1
d661 3
a663 3
int otoi( str )
Char str[];
	{
d666 1
a666 1
	(void) sscanf( (char *) str, "%o", &result );
d668 1
a668 1
	}
d675 69
a743 84
void out( str )
const char str[];
	{
	fputs( str, stdout );
	out_line_count( str );
	}

void out_dec( fmt, n )
const char fmt[];
int n;
	{
	printf( fmt, n );
	out_line_count( fmt );
	}

void out_dec2( fmt, n1, n2 )
const char fmt[];
int n1, n2;
	{
	printf( fmt, n1, n2 );
	out_line_count( fmt );
	}

void out_hex( fmt, x )
const char fmt[];
unsigned int x;
	{
	printf( fmt, x );
	out_line_count( fmt );
	}

void out_line_count( str )
const char str[];
	{
	int i;

	for ( i = 0; str[i]; ++i )
		if ( str[i] == '\n' )
			++out_linenum;
	}

void out_str( fmt, str )
const char fmt[], str[];
	{
	printf( fmt, str );
	out_line_count( fmt );
	out_line_count( str );
	}

void out_str3( fmt, s1, s2, s3 )
const char fmt[], s1[], s2[], s3[];
	{
	printf( fmt, s1, s2, s3 );
	out_line_count( fmt );
	out_line_count( s1 );
	out_line_count( s2 );
	out_line_count( s3 );
	}

void out_str_dec( fmt, str, n )
const char fmt[], str[];
int n;
	{
	printf( fmt, str, n );
	out_line_count( fmt );
	out_line_count( str );
	}

void outc( c )
int c;
	{
	putc( c, stdout );

	if ( c == '\n' )
		++out_linenum;
	}

void outn( str )
const char str[];
	{
	puts( str );
	out_line_count( str );
	++out_linenum;
	}
d751 3
a753 3
char *readable_form( c )
int c;
	{
d756 18
a773 13
	if ( (c >= 0 && c < 32) || c >= 127 )
		{
		switch ( c )
			{
			case '\b': return "\\b";
			case '\f': return "\\f";
			case '\n': return "\\n";
			case '\r': return "\\r";
			case '\t': return "\\t";

#ifdef __STDC__
			case '\a': return "\\a";
			case '\v': return "\\v";
d776 3
a778 5
			default:
				(void) snprintf( rform, sizeof rform,
					"\\%.3o", (unsigned int) c );
				return rform;
			}
d780 1
d782 1
a782 1
	else if ( c == ' ' )
d785 1
a785 2
	else
		{
a789 1
		}
d791 1
d796 5
a800 5
void *reallocate_array( array, size, element_size )
void *array;
int size;
size_t element_size;
	{
d802 1
a802 1
	size_t num_bytes = element_size * size;
d804 3
a806 3
	new_array = flex_realloc( array, num_bytes );
	if ( ! new_array )
		flexfatal( _( "attempt to increase array size failed" ) );
d809 1
a809 1
	}
d818 12
a829 5
void skelout()
	{
	char buf_storage[MAXLINE];
	char *buf = buf_storage;
	int do_copy = 1;
d834 100
a933 38
	while ( skelfile ?
		(fgets( buf, MAXLINE, skelfile ) != NULL) :
		((buf = (char *) skel[skel_ind++]) != 0) )
		{ /* copy from skel array */
		if ( buf[0] == '%' )
			{ /* control line */
			switch ( buf[1] )
				{
				case '%':
					return;

				case '+':
					do_copy = C_plus_plus;
					break;

				case '-':
					do_copy = ! C_plus_plus;
					break;

				case '*':
					do_copy = 1;
					break;

				default:
					flexfatal(
					_( "bad line in skeleton file" ) );
				}
			}

		else if ( do_copy )
			{
			if ( skelfile )
				/* Skeleton file reads include final
				 * newline, skel[] array does not.
				 */
				out( buf );
			else
				outn( buf );
d936 5
a940 1
	}
d949 9
a957 4
void transition_struct_out( element_v, element_n )
int element_v, element_n;
	{
	out_dec2( " {%4d,%4d },", element_v, element_n );
d961 2
a962 3
	if ( datapos >= 79 - TRANS_STRUCT_PRINT_LENGTH )
		{
		outc( '\n' );
d964 2
a965 2
		if ( ++dataline % 10 == 0 )
			outc( '\n' );
a967 1
		}
d969 1
d975 8
a982 8
void *yy_flex_xmalloc( size )
int size;
	{
	void *result = flex_alloc( (size_t) size );

	if ( ! result  )
		flexfatal(
			_( "memory allocation failed in yy_flex_xmalloc()" ) );
d985 1
a985 1
	}
d993 4
a996 4
void zero_out( region_ptr, size_in_bytes )
char *region_ptr;
size_t size_in_bytes;
	{
d1002 1
a1002 1
	while ( rp < rp_end )
d1004 23
a1026 1
	}
@


1.13
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.12 2006/03/04 16:18:06 miod Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.12 2006/03/04 16:18:06 miod Exp $ */
d112 1
a112 1
		if ( ! isascii( (Char) *str ) || ! islower( *str ) )
d128 1
a128 1
		if ( ! isascii( (Char) *str ) || ! isupper( *str ) )
d593 1
a593 1
				isxdigit( (char) array[sptr] ) )
@


1.12
log
@the the
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.11 2003/06/04 17:34:44 millert Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.11 2003/06/04 17:34:44 millert Exp $ */
d398 1
a398 1
	static char line_fmt[] = "#line %d \"%s\"\n";
@


1.11
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.10 2003/04/08 00:18:13 deraadt Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.10 2003/04/08 00:18:13 deraadt Exp $ */
d718 1
a718 1
/* readable_form - return the the human-readable form of a character
@


1.10
log
@string cleaning; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.9 2002/05/31 22:49:29 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.9 2002/05/31 22:49:29 deraadt Exp $ */
@


1.9
log
@recommit strlcpy/snprintf diff after i found my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.7 2002/05/30 10:53:44 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.7 2002/05/30 10:53:44 deraadt Exp $ */
d75 2
a76 1
	strcpy( &action_array[action_index], new_text );
@


1.8
log
@undo until i find my #line bug
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.6 2001/11/19 19:02:14 mpech Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.6 2001/11/19 19:02:14 mpech Exp $ */
d49 1
a49 1
	sprintf( buf, "#define %s %d\n", defname, value );
d367 1
a367 1
	(void) sprintf( errmsg, msg, arg );
d379 1
a379 1
	(void) sprintf( errmsg, msg, arg );
d417 2
a418 1
		sprintf( directive, line_fmt, linenum, filename );
d425 2
a426 1
		sprintf( directive, line_fmt, out_linenum, filename );
d738 2
a739 2
				(void) sprintf( rform, "\\%.3o",
						(unsigned int) c );
@


1.7
log
@use strlcpy and snprintf
@
text
@d49 1
a49 1
	snprintf( buf, sizeof buf, "#define %s %d\n", defname, value );
d367 1
a367 1
	(void) snprintf( errmsg, sizeof errmsg, msg, arg );
d379 1
a379 1
	(void) snprintf( errmsg, sizeof errmsg, msg, arg );
d417 1
a417 2
		snprintf( directive, sizeof directive, line_fmt,
			linenum, filename );
d424 1
a424 2
		snprintf( directive, sizeof directive, line_fmt,
			out_linenum, filename );
d736 2
a737 2
				(void) snprintf( rform, sizeof rform,
					"\\%.3o", (unsigned int) c );
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $ */
d49 1
a49 1
	sprintf( buf, "#define %s %d\n", defname, value );
d367 1
a367 1
	(void) sprintf( errmsg, msg, arg );
d379 1
a379 1
	(void) sprintf( errmsg, msg, arg );
d417 2
a418 1
		sprintf( directive, line_fmt, linenum, filename );
d425 2
a426 1
		sprintf( directive, line_fmt, out_linenum, filename );
d738 2
a739 2
				(void) sprintf( rform, "\\%.3o",
						(unsigned int) c );
@


1.5
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.4 1997/07/25 21:05:30 mickey Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.4 1997/07/25 21:05:30 mickey Exp $ */
d87 1
a87 1
	register void *mem;
d102 1
a102 1
register char *str;
d118 1
a118 1
register char *str;
d149 1
a149 1
	register int i, j, k;
d185 1
a185 1
register int c;
d194 1
a194 1
register const char *str;
d196 2
a197 2
	register const char *c1;
	register char *c2;
d223 1
a223 1
register Char *str;
d225 1
a225 1
	register Char *c;
d658 1
a658 1
	register int i;
d716 1
a716 1
register int c;
d762 1
a762 1
	register void *new_array;
d881 1
a881 1
	register char *rp, *rp_end;
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.3 1996/07/13 22:22:09 millert Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.3 1996/07/13 22:22:09 millert Exp $ */
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: misc.c,v 1.2 1996/06/26 05:35:38 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/misc.c,v 2.47 95/04/28 11:39:39 vern Exp $ */
d543 1
a543 1
#if __STDC__
d730 1
a730 1
#if __STDC__
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/misc.c,v 1.1.1.1 1995/10/18 08:45:31 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/misc.c,v 1.7 1995/05/05 05:35:35 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
