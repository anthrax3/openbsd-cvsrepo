head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.6.0.52
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.44
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.48
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.46
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.42
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.40
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.38
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.36
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.19.23.34.56;	author mmcc;	state Exp;
branches;
next	1.9;
commitid	sr9v9L5qZs3TeEb4;

1.9
date	2015.11.19.23.04.51;	author tedu;	state Exp;
branches;
next	1.8;
commitid	S1mOxGQqBoiBveCO;

1.8
date	2015.11.19.22.55.13;	author tedu;	state Exp;
branches;
next	1.7;
commitid	kuemS673xiRF5kXq;

1.7
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.6;
commitid	TCPdLh99ETkn9X6R;

1.6
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Replace Char (defined as unsigned char) with u_char.

ok tedu@@
@
text
@/*	$OpenBSD: tblcmp.c,v 1.9 2015/11/19 23:04:51 tedu Exp $	*/

/* tblcmp - table compression routines */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"


/* declarations for functions that have forward references */

void mkentry PROTO((int *, int, int, int, int));
void mkprot PROTO((int[], int, int));
void mktemplate PROTO((int[], int, int));
void mv2front PROTO((int));
int tbldiff PROTO((int[], int, int[]));


/* bldtbl - build table entries for dfa state
 *
 * synopsis
 *   int state[numecs], statenum, totaltrans, comstate, comfreq;
 *   bldtbl( state, statenum, totaltrans, comstate, comfreq );
 *
 * State is the statenum'th dfa state.  It is indexed by equivalence class and
 * gives the number of the state to enter for a given equivalence class.
 * totaltrans is the total number of transitions out of the state.  Comstate
 * is that state which is the destination of the most transitions out of State.
 * Comfreq is how many transitions there are out of State to Comstate.
 *
 * A note on terminology:
 *    "protos" are transition tables which have a high probability of
 * either being redundant (a state processed later will have an identical
 * transition table) or nearly redundant (a state processed later will have
 * many of the same out-transitions).  A "most recently used" queue of
 * protos is kept around with the hope that most states will find a proto
 * which is similar enough to be usable, and therefore compacting the
 * output tables.
 *    "templates" are a special type of proto.  If a transition table is
 * homogeneous or nearly homogeneous (all transitions go to the same
 * destination) then the odds are good that future states will also go
 * to the same destination state on basically the same character set.
 * These homogeneous states are so common when dealing with large rule
 * sets that they merit special attention.  If the transition table were
 * simply made into a proto, then (typically) each subsequent, similar
 * state will differ from the proto for two out-transitions.  One of these
 * out-transitions will be that character on which the proto does not go
 * to the common destination, and one will be that character on which the
 * state does not go to the common destination.  Templates, on the other
 * hand, go to the common state on EVERY transition character, and therefore
 * cost only one difference.
 */

void 
bldtbl(state, statenum, totaltrans, comstate, comfreq)
	int state[], statenum, totaltrans, comstate, comfreq;
{
	int extptr, extrct[2][CSIZE + 1];
	int mindiff, minprot, i, d;

	/*
	 * If extptr is 0 then the first array of extrct holds the result of
	 * the "best difference" to date, which is those transitions which
	 * occur in "state" but not in the proto which, to date, has the
	 * fewest differences between itself and "state".  If extptr is 1
	 * then the second array of extrct hold the best difference.  The two
	 * arrays are toggled between so that the best difference to date can
	 * be kept around and also a difference just created by checking
	 * against a candidate "best" proto.
	 */

	extptr = 0;

	/*
	 * If the state has too few out-transitions, don't bother trying to
	 * compact its tables.
	 */

	if ((totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE))
		mkentry(state, numecs, statenum, JAMSTATE, totaltrans);

	else {
		/*
		 * "checkcom" is true if we should only check "state" against
		 * protos which have the same "comstate" value.
		 */
		int checkcom =

		comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;

		minprot = firstprot;
		mindiff = totaltrans;

		if (checkcom) {
			/* Find first proto which has the same "comstate". */
			for (i = firstprot; i != NIL; i = protnext[i])
				if (protcomst[i] == comstate) {
					minprot = i;
					mindiff = tbldiff(state, minprot,
					    extrct[extptr]);
					break;
				}
		} else {
			/*
			 * Since we've decided that the most common
			 * destination out of "state" does not occur with a
			 * high enough frequency, we set the "comstate" to
			 * zero, assuring that if this state is entered into
			 * the proto list, it will not be considered a
			 * template.
			 */
			comstate = 0;

			if (firstprot != NIL) {
				minprot = firstprot;
				mindiff = tbldiff(state, minprot,
				    extrct[extptr]);
			}
		}

		/*
		 * We now have the first interesting proto in "minprot".  If
		 * it matches within the tolerances set for the first proto,
		 * we don't want to bother scanning the rest of the proto
		 * list to see if we have any other reasonable matches.
		 */

		if (mindiff * 100 >
		    totaltrans * FIRST_MATCH_DIFF_PERCENTAGE) {
			/*
			 * Not a good enough match.  Scan the rest of the
			 * protos.
			 */
			for (i = minprot; i != NIL; i = protnext[i]) {
				d = tbldiff(state, i, extrct[1 - extptr]);
				if (d < mindiff) {
					extptr = 1 - extptr;
					mindiff = d;
					minprot = i;
				}
			}
		}
		/*
		 * Check if the proto we've decided on as our best bet is
		 * close enough to the state we want to match to be usable.
		 */

		if (mindiff * 100 >
		    totaltrans * ACCEPTABLE_DIFF_PERCENTAGE) {
			/*
			 * No good.  If the state is homogeneous enough, we
			 * make a template out of it.  Otherwise, we make a
			 * proto.
			 */

			if (comfreq * 100 >=
			    totaltrans * TEMPLATE_SAME_PERCENTAGE)
				mktemplate(state, statenum,
				    comstate);

			else {
				mkprot(state, statenum, comstate);
				mkentry(state, numecs, statenum,
				    JAMSTATE, totaltrans);
			}
		} else {	/* use the proto */
			mkentry(extrct[extptr], numecs, statenum,
			    prottbl[minprot], mindiff);

			/*
			 * If this state was sufficiently different from the
			 * proto we built it from, make it, too, a proto.
			 */

			if (mindiff * 100 >=
			    totaltrans * NEW_PROTO_DIFF_PERCENTAGE)
				mkprot(state, statenum, comstate);

			/*
			 * Since mkprot added a new proto to the proto queue,
			 * it's possible that "minprot" is no longer on the
			 * proto queue (if it happened to have been the last
			 * entry, it would have been bumped off).  If it's
			 * not there, then the new proto took its physical
			 * place (though logically the new proto is at the
			 * beginning of the queue), so in that case the
			 * following call will do nothing.
			 */

			mv2front(minprot);
		}
	}
}


/* cmptmps - compress template table entries
 *
 * Template tables are compressed by using the 'template equivalence
 * classes', which are collections of transition character equivalence
 * classes which always appear together in templates - really meta-equivalence
 * classes.
 */

void 
cmptmps()
{
	int tmpstorage[CSIZE + 1];
	int *tmp = tmpstorage, i, j;
	int totaltrans, trans;

	peakpairs = numtemps * numecs + tblend;

	if (usemecs) {
		/*
		 * Create equivalence classes based on data gathered on
		 * template transitions.
		 */
		nummecs = cre8ecs(tecfwd, tecbck, numecs);
	} else
		nummecs = numecs;

	while (lastdfa + numtemps + 1 >= current_max_dfas)
		increase_max_dfas();

	/* Loop through each template. */

	for (i = 1; i <= numtemps; ++i) {
		/* Number of non-jam transitions out of this template. */
		totaltrans = 0;

		for (j = 1; j <= numecs; ++j) {
			trans = tnxt[numecs * i + j];

			if (usemecs) {
				/*
				 * The absolute value of tecbck is the
				 * meta-equivalence class of a given
				 * equivalence class, as set up by cre8ecs().
				 */
				if (tecbck[j] > 0) {
					tmp[tecbck[j]] = trans;

					if (trans > 0)
						++totaltrans;
				}
			} else {
				tmp[j] = trans;

				if (trans > 0)
					++totaltrans;
			}
		}

		/*
		 * It is assumed (in a rather subtle way) in the skeleton
		 * that if we're using meta-equivalence classes, the def[]
		 * entry for all templates is the jam template, i.e.,
		 * templates never default to other non-jam table entries
		 * (e.g., another template)
		 */

		/* Leave room for the jam-state after the last real state. */
		mkentry(tmp, nummecs, lastdfa + i + 1, JAMSTATE,
		    totaltrans);
	}
}



/* expand_nxt_chk - expand the next check arrays */

void 
expand_nxt_chk()
{
	int old_max = current_max_xpairs;

	current_max_xpairs += MAX_XPAIRS_INCREMENT;

	++num_reallocs;

	nxt = reallocate_integer_array(nxt, current_max_xpairs);
	chk = reallocate_integer_array(chk, current_max_xpairs);

	memset((chk + old_max), 0, MAX_XPAIRS_INCREMENT * sizeof(int));
}


/* find_table_space - finds a space in the table for a state to be placed
 *
 * synopsis
 *     int *state, numtrans, block_start;
 *     int find_table_space();
 *
 *     block_start = find_table_space( state, numtrans );
 *
 * State is the state to be added to the full speed transition table.
 * Numtrans is the number of out-transitions for the state.
 *
 * find_table_space() returns the position of the start of the first block (in
 * chk) able to accommodate the state
 *
 * In determining if a state will or will not fit, find_table_space() must take
 * into account the fact that an end-of-buffer state will be added at [0],
 * and an action number will be added in [-1].
 */

int 
find_table_space(state, numtrans)
	int *state, numtrans;
{
	/*
	 * Firstfree is the position of the first possible occurrence of two
	 * consecutive unused records in the chk and nxt arrays.
	 */
	int i;
	int *state_ptr, *chk_ptr;
	int *ptr_to_last_entry_in_state;

	/*
	 * If there are too many out-transitions, put the state at the end of
	 * nxt and chk.
	 */
	if (numtrans > MAX_XTIONS_FULL_INTERIOR_FIT) {
		/*
		 * If table is empty, return the first available spot in
		 * chk/nxt, which should be 1.
		 */
		if (tblend < 2)
			return 1;

		/*
		 * Start searching for table space near the end of chk/nxt
		 * arrays.
		 */
		i = tblend - numecs;
	} else
		/*
		 * Start searching for table space from the beginning
		 * (skipping only the elements which will definitely not hold
		 * the new state).
		 */
		i = firstfree;

	while (1) {		/* loops until a space is found */
		while (i + numecs >= current_max_xpairs)
			expand_nxt_chk();

		/*
		 * Loops until space for end-of-buffer and action number are
		 * found.
		 */
		while (1) {
			/* Check for action number space. */
			if (chk[i - 1] == 0) {
				/* Check for end-of-buffer space. */
				if (chk[i] == 0)
					break;

				else
					/*
					 * Since i != 0, there is no use
					 * checking to see if (++i) - 1 == 0,
					 * because that's the same as i == 0,
					 * so we skip a space.
					 */
					i += 2;
			} else
				++i;

			while (i + numecs >= current_max_xpairs)
				expand_nxt_chk();
		}

		/*
		 * If we started search from the beginning, store the new
		 * firstfree for the next call of find_table_space().
		 */
		if (numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT)
			firstfree = i + 1;

		/*
		 * Check to see if all elements in chk (and therefore nxt)
		 * that are needed for the new state have not yet been taken.
		 */

		state_ptr = &state[1];
		ptr_to_last_entry_in_state = &chk[i + numecs + 1];

		for (chk_ptr = &chk[i + 1];
		    chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr)
			if (*(state_ptr++) != 0 && *chk_ptr != 0)
				break;

		if (chk_ptr == ptr_to_last_entry_in_state)
			return i;

		else
			++i;
	}
}


/* inittbl - initialize transition tables
 *
 * Initializes "firstfree" to be one beyond the end of the table.  Initializes
 * all "chk" entries to be zero.
 */
void 
inittbl()
{
	int i;

	memset(chk, 0, current_max_xpairs * sizeof(int));

	tblend = 0;
	firstfree = tblend + 1;
	numtemps = 0;

	if (usemecs) {
		/*
		 * Set up doubly-linked meta-equivalence classes; these are
		 * sets of equivalence classes which all have identical
		 * transitions out of TEMPLATES.
		 */

		tecbck[1] = NIL;

		for (i = 2; i <= numecs; ++i) {
			tecbck[i] = i - 1;
			tecfwd[i - 1] = i;
		}

		tecfwd[numecs] = NIL;
	}
}


/* mkdeftbl - make the default, "jam" table entries */

void 
mkdeftbl()
{
	int i;

	jamstate = lastdfa + 1;

	++tblend;		/* room for transition on end-of-buffer
				 * character */

	while (tblend + numecs >= current_max_xpairs)
		expand_nxt_chk();

	/* Add in default end-of-buffer transition. */
	nxt[tblend] = end_of_buffer_state;
	chk[tblend] = jamstate;

	for (i = 1; i <= numecs; ++i) {
		nxt[tblend + i] = 0;
		chk[tblend + i] = jamstate;
	}

	jambase = tblend;

	base[jamstate] = jambase;
	def[jamstate] = 0;

	tblend += numecs;
	++numtemps;
}


/* mkentry - create base/def and nxt/chk entries for transition array
 *
 * synopsis
 *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;
 *   mkentry( state, numchars, statenum, deflink, totaltrans );
 *
 * "state" is a transition array "numchars" characters in size, "statenum"
 * is the offset to be used into the base/def tables, and "deflink" is the
 * entry to put in the "def" table entry.  If "deflink" is equal to
 * "JAMSTATE", then no attempt will be made to fit zero entries of "state"
 * (i.e., jam entries) into the table.  It is assumed that by linking to
 * "JAMSTATE" they will be taken care of.  In any case, entries in "state"
 * marking transitions to "SAME_TRANS" are treated as though they will be
 * taken care of by whereever "deflink" points.  "totaltrans" is the total
 * number of transitions out of the state.  If it is below a certain threshold,
 * the tables are searched for an interior spot that will accommodate the
 * state array.
 */

void 
mkentry(state, numchars, statenum, deflink, totaltrans)
	int *state;
	int numchars, statenum, deflink, totaltrans;
{
	int minec, maxec, i, baseaddr;
	int tblbase, tbllast;

	if (totaltrans == 0) {	/* there are no out-transitions */
		if (deflink == JAMSTATE)
			base[statenum] = JAMSTATE;
		else
			base[statenum] = 0;

		def[statenum] = deflink;
		return;
	}
	for (minec = 1; minec <= numchars; ++minec) {
		if (state[minec] != SAME_TRANS)
			if (state[minec] != 0 || deflink != JAMSTATE)
				break;
	}

	if (totaltrans == 1) {
		/*
		 * There's only one out-transition.  Save it for later to
		 * fill in holes in the tables.
		 */
		stack1(statenum, minec, state[minec], deflink);
		return;
	}
	for (maxec = numchars; maxec > 0; --maxec) {
		if (state[maxec] != SAME_TRANS)
			if (state[maxec] != 0 || deflink != JAMSTATE)
				break;
	}

	/*
	 * Whether we try to fit the state table in the middle of the table
	 * entries we have already generated, or if we just take the state
	 * table at the end of the nxt/chk tables, we must make sure that we
	 * have a valid base address (i.e., non-negative).  Note that
	 * negative base addresses dangerous at run-time (because indexing
	 * the nxt array with one and a low-valued character will access
	 * memory before the start of the array.
	 */

	/* Find the first transition of state that we need to worry about. */
	if (totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE) {
		/* Attempt to squeeze it into the middle of the tables. */
		baseaddr = firstfree;

		while (baseaddr < minec) {
			/*
			 * Using baseaddr would result in a negative base
			 * address below; find the next free slot.
			 */
			for (++baseaddr; chk[baseaddr] != 0; ++baseaddr);
		}

		while (baseaddr + maxec - minec + 1 >= current_max_xpairs)
			expand_nxt_chk();

		for (i = minec; i <= maxec; ++i)
			if (state[i] != SAME_TRANS &&
			    (state[i] != 0 || deflink != JAMSTATE) &&
			    chk[baseaddr + i - minec] != 0) {	/* baseaddr unsuitable -
								 * find another */
				for (++baseaddr;
				    baseaddr < current_max_xpairs &&
				    chk[baseaddr] != 0; ++baseaddr);

				while (baseaddr + maxec - minec + 1 >=
				    current_max_xpairs)
					expand_nxt_chk();

				/*
				 * Reset the loop counter so we'll start all
				 * over again next time it's incremented.
				 */

				i = minec - 1;
			}
	} else {
		/*
		 * Ensure that the base address we eventually generate is
		 * non-negative.
		 */
		baseaddr = MAX(tblend + 1, minec);
	}

	tblbase = baseaddr - minec;
	tbllast = tblbase + maxec;

	while (tbllast + 1 >= current_max_xpairs)
		expand_nxt_chk();

	base[statenum] = tblbase;
	def[statenum] = deflink;

	for (i = minec; i <= maxec; ++i)
		if (state[i] != SAME_TRANS)
			if (state[i] != 0 || deflink != JAMSTATE) {
				nxt[tblbase + i] = state[i];
				chk[tblbase + i] = statenum;
			}
	if (baseaddr == firstfree)
		/* Find next free slot in tables. */
		for (++firstfree; chk[firstfree] != 0; ++firstfree);

	tblend = MAX(tblend, tbllast);
}


/* mk1tbl - create table entries for a state (or state fragment) which
 *            has only one out-transition
 */

void 
mk1tbl(state, sym, onenxt, onedef)
	int state, sym, onenxt, onedef;
{
	if (firstfree < sym)
		firstfree = sym;

	while (chk[firstfree] != 0)
		if (++firstfree >= current_max_xpairs)
			expand_nxt_chk();

	base[state] = firstfree - sym;
	def[state] = onedef;
	chk[firstfree] = state;
	nxt[firstfree] = onenxt;

	if (firstfree > tblend) {
		tblend = firstfree++;

		if (firstfree >= current_max_xpairs)
			expand_nxt_chk();
	}
}


/* mkprot - create new proto entry */

void 
mkprot(state, statenum, comstate)
	int state[], statenum, comstate;
{
	int i, slot, tblbase;

	if (++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE) {
		/*
		 * Gotta make room for the new proto by dropping last entry
		 * in the queue.
		 */
		slot = lastprot;
		lastprot = protprev[lastprot];
		protnext[lastprot] = NIL;
	} else
		slot = numprots;

	protnext[slot] = firstprot;

	if (firstprot != NIL)
		protprev[firstprot] = slot;

	firstprot = slot;
	prottbl[slot] = statenum;
	protcomst[slot] = comstate;

	/* Copy state into save area so it can be compared with rapidly. */
	tblbase = numecs * (slot - 1);

	for (i = 1; i <= numecs; ++i)
		protsave[tblbase + i] = state[i];
}


/* mktemplate - create a template entry based on a state, and connect the state
 *              to it
 */

void 
mktemplate(state, statenum, comstate)
	int state[], statenum, comstate;
{
	int i, numdiff, tmpbase, tmp[CSIZE + 1];
	u_char transset[CSIZE + 1];
	int tsptr;

	++numtemps;

	tsptr = 0;

	/*
	 * Calculate where we will temporarily store the transition table of
	 * the template in the tnxt[] array.  The final transition table gets
	 * created by cmptmps().
	 */

	tmpbase = numtemps * numecs;

	if (tmpbase + numecs >= current_max_template_xpairs) {
		current_max_template_xpairs +=
		    MAX_TEMPLATE_XPAIRS_INCREMENT;

		++num_reallocs;

		tnxt = reallocate_integer_array(tnxt,
		    current_max_template_xpairs);
	}
	for (i = 1; i <= numecs; ++i)
		if (state[i] == 0)
			tnxt[tmpbase + i] = 0;
		else {
			transset[tsptr++] = i;
			tnxt[tmpbase + i] = comstate;
		}

	if (usemecs)
		mkeccl(transset, tsptr, tecfwd, tecbck, numecs, 0);

	mkprot(tnxt + tmpbase, -numtemps, comstate);

	/*
	 * We rely on the fact that mkprot adds things to the beginning of
	 * the proto queue.
	 */

	numdiff = tbldiff(state, firstprot, tmp);
	mkentry(tmp, numecs, statenum, -numtemps, numdiff);
}


/* mv2front - move proto queue element to front of queue */

void 
mv2front(qelm)
	int qelm;
{
	if (firstprot != qelm) {
		if (qelm == lastprot)
			lastprot = protprev[lastprot];

		protnext[protprev[qelm]] = protnext[qelm];

		if (protnext[qelm] != NIL)
			protprev[protnext[qelm]] = protprev[qelm];

		protprev[qelm] = NIL;
		protnext[qelm] = firstprot;
		protprev[firstprot] = qelm;
		firstprot = qelm;
	}
}


/* place_state - place a state into full speed transition table
 *
 * State is the statenum'th state.  It is indexed by equivalence class and
 * gives the number of the state to enter for a given equivalence class.
 * Transnum is the number of out-transitions for the state.
 */

void 
place_state(state, statenum, transnum)
	int *state, statenum, transnum;
{
	int i;
	int *state_ptr;
	int position = find_table_space(state, transnum);

	/* "base" is the table of start positions. */
	base[statenum] = position;

	/*
	 * Put in action number marker; this non-zero number makes sure that
	 * find_table_space() knows that this position in chk/nxt is taken
	 * and should not be used for another accepting number in another
	 * state.
	 */
	chk[position - 1] = 1;

	/*
	 * Put in end-of-buffer marker; this is for the same purposes as
	 * above.
	 */
	chk[position] = 1;

	/* Place the state into chk and nxt. */
	state_ptr = &state[1];

	for (i = 1; i <= numecs; ++i, ++state_ptr)
		if (*state_ptr != 0) {
			chk[position + i] = i;
			nxt[position + i] = *state_ptr;
		}
	if (position + numecs > tblend)
		tblend = position + numecs;
}


/* stack1 - save states with only one out-transition to be processed later
 *
 * If there's room for another state on the "one-transition" stack, the
 * state is pushed onto it, to be processed later by mk1tbl.  If there's
 * no room, we process the sucker right now.
 */

void 
stack1(statenum, sym, nextstate, deflink)
	int statenum, sym, nextstate, deflink;
{
	if (onesp >= ONE_STACK_SIZE - 1)
		mk1tbl(statenum, sym, nextstate, deflink);

	else {
		++onesp;
		onestate[onesp] = statenum;
		onesym[onesp] = sym;
		onenext[onesp] = nextstate;
		onedef[onesp] = deflink;
	}
}


/* tbldiff - compute differences between two state tables
 *
 * "state" is the state array which is to be extracted from the pr'th
 * proto.  "pr" is both the number of the proto we are extracting from
 * and an index into the save area where we can find the proto's complete
 * state table.  Each entry in "state" which differs from the corresponding
 * entry of "pr" will appear in "ext".
 *
 * Entries which are the same in both "state" and "pr" will be marked
 * as transitions to "SAME_TRANS" in "ext".  The total number of differences
 * between "state" and "pr" is returned as function value.  Note that this
 * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".
 */

int 
tbldiff(state, pr, ext)
	int state[], pr, ext[];
{
	int i, *sp = state, *ep = ext, *protp;
	int numdiff = 0;

	protp = &protsave[numecs * (pr - 1)];

	for (i = numecs; i > 0; --i) {
		if (*++protp == *++sp)
			*++ep = SAME_TRANS;
		else {
			*++ep = *sp;
			++numdiff;
		}
	}

	return numdiff;
}
@


1.9
log
@it should be safe to assume the presence of memset these days instead of
implementing a local version.
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.8 2015/11/19 22:55:13 tedu Exp $	*/
d708 1
a708 1
	Char transset[CSIZE + 1];
@


1.8
log
@mechanical knf
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.7 2015/11/19 19:43:40 tedu Exp $	*/
d313 1
a313 2
	zero_out((char *) (chk + old_max),
	    (size_t) (MAX_XPAIRS_INCREMENT * sizeof(int)));
d442 1
a442 3
	zero_out((char *) chk,

	    (size_t) (current_max_xpairs * sizeof(int)));
@


1.7
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.6 2003/06/04 17:34:44 millert Exp $	*/
d41 5
a45 5
void mkentry PROTO ((int *, int, int, int, int));
void mkprot PROTO ((int[], int, int));
void mktemplate PROTO ((int[], int, int));
void mv2front PROTO ((int));
int tbldiff PROTO ((int[], int, int[]));
d83 16
a98 14
void    bldtbl (state, statenum, totaltrans, comstate, comfreq)
     int     state[], statenum, totaltrans, comstate, comfreq;
{
	int     extptr, extrct[2][CSIZE + 1];
	int     mindiff, minprot, i, d;

	/* If extptr is 0 then the first array of extrct holds the result
	 * of the "best difference" to date, which is those transitions
	 * which occur in "state" but not in the proto which, to date,
	 * has the fewest differences between itself and "state".  If
	 * extptr is 1 then the second array of extrct hold the best
	 * difference.  The two arrays are toggled between so that the
	 * best difference to date can be kept around and also a difference
	 * just created by checking against a candidate "best" proto.
d103 2
a104 1
	/* If the state has too few out-transitions, don't bother trying to
d109 1
a109 1
		mkentry (state, numecs, statenum, JAMSTATE, totaltrans);
d112 2
a113 1
		/* "checkcom" is true if we should only check "state" against
d116 1
a116 1
		int     checkcom =
d118 1
a118 1
			comfreq * 100 > totaltrans * CHECK_COM_PERCENTAGE;
d128 2
a129 2
					mindiff = tbldiff (state, minprot,
							   extrct[extptr]);
d132 8
a139 8
		}

		else {
			/* Since we've decided that the most common destination
			 * out of "state" does not occur with a high enough
			 * frequency, we set the "comstate" to zero, assuring
			 * that if this state is entered into the proto list,
			 * it will not be considered a template.
d145 2
a146 2
				mindiff = tbldiff (state, minprot,
						   extrct[extptr]);
d150 2
a151 1
		/* We now have the first interesting proto in "minprot".  If
d153 2
a154 2
		 * we don't want to bother scanning the rest of the proto list
		 * to see if we have any other reasonable matches.
d159 2
a160 1
			/* Not a good enough match.  Scan the rest of the
d164 1
a164 1
				d = tbldiff (state, i, extrct[1 - extptr]);
d172 3
a174 3

		/* Check if the proto we've decided on as our best bet is close
		 * enough to the state we want to match to be usable.
d179 4
a182 3
			/* No good.  If the state is homogeneous enough,
			 * we make a template out of it.  Otherwise, we
			 * make a proto.
d187 2
a188 2
					mktemplate (state, statenum,
						    comstate);
d191 3
a193 3
				mkprot (state, statenum, comstate);
				mkentry (state, numecs, statenum,
					 JAMSTATE, totaltrans);
d195 3
a197 5
		}

		else {		/* use the proto */
			mkentry (extrct[extptr], numecs, statenum,
				 prottbl[minprot], mindiff);
d199 2
a200 1
			/* If this state was sufficiently different from the
d206 1
a206 1
					mkprot (state, statenum, comstate);
d208 2
a209 1
			/* Since mkprot added a new proto to the proto queue,
d219 1
a219 1
			mv2front (minprot);
d233 2
a234 1
void    cmptmps ()
d236 1
a236 1
	int     tmpstorage[CSIZE + 1];
d238 1
a238 1
	int     totaltrans, trans;
d243 2
a244 1
		/* Create equivalence classes based on data gathered on
d247 2
a248 4
		nummecs = cre8ecs (tecfwd, tecbck, numecs);
	}

	else
d252 1
a252 1
		increase_max_dfas ();
d264 2
a265 1
				/* The absolute value of tecbck is the
d275 1
a275 3
			}

			else {
d283 2
a284 1
		/* It is assumed (in a rather subtle way) in the skeleton
d292 2
a293 2
		mkentry (tmp, nummecs, lastdfa + i + 1, JAMSTATE,
			 totaltrans);
d301 2
a302 1
void    expand_nxt_chk ()
d310 2
a311 2
	nxt = reallocate_integer_array (nxt, current_max_xpairs);
	chk = reallocate_integer_array (chk, current_max_xpairs);
d313 2
a314 2
	zero_out ((char *) (chk + old_max),
		  (size_t) (MAX_XPAIRS_INCREMENT * sizeof (int)));
d337 3
a339 2
int     find_table_space (state, numtrans)
     int    *state, numtrans;
d341 2
a342 1
	/* Firstfree is the position of the first possible occurrence of two
d349 2
a350 1
	/* If there are too many out-transitions, put the state at the end of
d354 2
a355 1
		/* If table is empty, return the first available spot in
d361 3
a363 2
		/* Start searching for table space near the end of
		 * chk/nxt arrays.
d366 5
a370 6
	}

	else
		/* Start searching for table space from the beginning
		 * (skipping only the elements which will definitely not
		 * hold the new state).
d376 1
a376 1
			expand_nxt_chk ();
d378 3
a380 2
		/* Loops until space for end-of-buffer and action number
		 * are found.
d390 2
a391 1
					/* Since i != 0, there is no use
d397 1
a397 3
			}

			else
d401 1
a401 1
				expand_nxt_chk ();
d404 2
a405 1
		/* If we started search from the beginning, store the new
d411 2
a412 1
		/* Check to see if all elements in chk (and therefore nxt)
d420 1
a420 1
		     chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr)
d438 2
a439 1
void    inittbl ()
d443 1
a443 1
	zero_out ((char *) chk,
d445 1
a445 1
		  (size_t) (current_max_xpairs * sizeof (int)));
d452 3
a454 2
		/* Set up doubly-linked meta-equivalence classes; these
		 * are sets of equivalence classes which all have identical
d472 2
a473 1
void    mkdeftbl ()
d475 1
a475 1
	int     i;
d479 2
a480 1
	++tblend;		/* room for transition on end-of-buffer character */
d483 1
a483 1
		expand_nxt_chk ();
d523 4
a526 3
void    mkentry (state, numchars, statenum, deflink, totaltrans)
     int *state;
     int     numchars, statenum, deflink, totaltrans;
d529 1
a529 1
	int     tblbase, tbllast;
a539 1

d547 3
a549 2
		/* There's only one out-transition.  Save it for later to fill
		 * in holes in the tables.
d551 1
a551 1
		stack1 (statenum, minec, state[minec], deflink);
a553 1

d560 2
a561 1
	/* Whether we try to fit the state table in the middle of the table
d576 2
a577 1
			/* Using baseaddr would result in a negative base
d580 1
a580 1
			for (++baseaddr; chk[baseaddr] != 0; ++baseaddr) ;
d584 1
a584 1
			expand_nxt_chk ();
d589 2
a590 1
			    chk[baseaddr + i - minec] != 0) {	/* baseaddr unsuitable - find another */
d592 2
a593 2
				     baseaddr < current_max_xpairs &&
				     chk[baseaddr] != 0; ++baseaddr) ;
d596 2
a597 2
				       current_max_xpairs)
						expand_nxt_chk ();
d599 2
a600 1
				/* Reset the loop counter so we'll start all
d606 3
a608 4
	}

	else {
		/* Ensure that the base address we eventually generate is
d611 1
a611 1
		baseaddr = MAX (tblend + 1, minec);
d618 1
a618 1
		expand_nxt_chk ();
a628 1

d631 1
a631 1
		for (++firstfree; chk[firstfree] != 0; ++firstfree) ;
d633 1
a633 1
	tblend = MAX (tblend, tbllast);
d641 3
a643 2
void    mk1tbl (state, sym, onenxt, onedef)
     int     state, sym, onenxt, onedef;
d650 1
a650 1
			expand_nxt_chk ();
d661 1
a661 1
			expand_nxt_chk ();
d668 3
a670 2
void    mkprot (state, statenum, comstate)
     int     state[], statenum, comstate;
d672 1
a672 1
	int     i, slot, tblbase;
d675 3
a677 2
		/* Gotta make room for the new proto by dropping last entry in
		 * the queue.
d682 1
a682 3
	}

	else
d706 7
a712 6
void    mktemplate (state, statenum, comstate)
     int     state[], statenum, comstate;
{
	int     i, numdiff, tmpbase, tmp[CSIZE + 1];
	Char    transset[CSIZE + 1];
	int     tsptr;
d718 4
a721 3
	/* Calculate where we will temporarily store the transition table
	 * of the template in the tnxt[] array.  The final transition table
	 * gets created by cmptmps().
d728 1
a728 1
			MAX_TEMPLATE_XPAIRS_INCREMENT;
d732 2
a733 2
		tnxt = reallocate_integer_array (tnxt,
						 current_max_template_xpairs);
a734 1

d744 1
a744 1
		mkeccl (transset, tsptr, tecfwd, tecbck, numecs, 0);
d746 1
a746 1
	mkprot (tnxt + tmpbase, -numtemps, comstate);
d748 3
a750 2
	/* We rely on the fact that mkprot adds things to the beginning
	 * of the proto queue.
d753 2
a754 2
	numdiff = tbldiff (state, firstprot, tmp);
	mkentry (tmp, numecs, statenum, -numtemps, numdiff);
d760 3
a762 2
void    mv2front (qelm)
     int     qelm;
d788 3
a790 2
void    place_state (state, statenum, transnum)
     int    *state, statenum, transnum;
d794 1
a794 1
	int     position = find_table_space (state, transnum);
d799 2
a800 1
	/* Put in action number marker; this non-zero number makes sure that
d807 2
a808 1
	/* Put in end-of-buffer marker; this is for the same purposes as
a820 1

d833 3
a835 2
void    stack1 (statenum, sym, nextstate, deflink)
     int     statenum, sym, nextstate, deflink;
d838 1
a838 1
		mk1tbl (statenum, sym, nextstate, deflink);
d864 3
a866 2
int     tbldiff (state, pr, ext)
     int     state[], pr, ext[];
@


1.6
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /cvs/src/usr.bin/lex/tblcmp.c,v 1.5 2001/11/19 19:02:14 mpech Exp $ */
d41 5
a45 5
void mkentry PROTO((int*, int, int, int, int));
void mkprot PROTO((int[], int, int));
void mktemplate PROTO((int[], int, int));
void mv2front PROTO((int));
int tbldiff PROTO((int[], int, int[]));
d83 5
a87 5
void bldtbl( state, statenum, totaltrans, comstate, comfreq )
int state[], statenum, totaltrans, comstate, comfreq;
	{
	int extptr, extrct[2][CSIZE + 1];
	int mindiff, minprot, i, d;
d105 2
a106 2
	if ( (totaltrans * 100) < (numecs * PROTO_SIZE_PERCENTAGE) )
		mkentry( state, numecs, statenum, JAMSTATE, totaltrans );
d108 1
a108 2
	else
		{
d112 2
a113 1
		int checkcom =
d119 1
a119 2
		if ( checkcom )
			{
d121 2
a122 3
			for ( i = firstprot; i != NIL; i = protnext[i] )
				if ( protcomst[i] == comstate )
					{
d124 2
a125 2
					mindiff = tbldiff( state, minprot,
							extrct[extptr] );
d127 2
a128 2
					}
			}
d130 1
a130 2
		else
			{
d139 1
a139 2
			if ( firstprot != NIL )
				{
d141 2
a142 3
				mindiff = tbldiff( state, minprot,
						extrct[extptr] );
				}
d144 1
d152 2
a153 2
		if ( mindiff * 100 > totaltrans * FIRST_MATCH_DIFF_PERCENTAGE )
			{
d157 3
a159 5
			for ( i = minprot; i != NIL; i = protnext[i] )
				{
				d = tbldiff( state, i, extrct[1 - extptr] );
				if ( d < mindiff )
					{
a162 1
					}
d165 1
d171 2
a172 2
		if ( mindiff * 100 > totaltrans * ACCEPTABLE_DIFF_PERCENTAGE )
			{
d178 4
a181 3
			if ( comfreq * 100 >=
			     totaltrans * TEMPLATE_SAME_PERCENTAGE )
				mktemplate( state, statenum, comstate );
d183 4
a186 6
			else
				{
				mkprot( state, statenum, comstate );
				mkentry( state, numecs, statenum,
					JAMSTATE, totaltrans );
				}
d188 1
d190 3
a192 4
		else
			{ /* use the proto */
			mkentry( extrct[extptr], numecs, statenum,
				prottbl[minprot], mindiff );
d198 3
a200 3
			if ( mindiff * 100 >=
			     totaltrans * NEW_PROTO_DIFF_PERCENTAGE )
				mkprot( state, statenum, comstate );
d212 1
a212 2
			mv2front( minprot );
			}
d215 1
d226 3
a228 3
void cmptmps()
	{
	int tmpstorage[CSIZE + 1];
d230 1
a230 1
	int totaltrans, trans;
d234 1
a234 2
	if ( usemecs )
		{
d238 2
a239 2
		nummecs = cre8ecs( tecfwd, tecbck, numecs );
		}
d244 2
a245 2
	while ( lastdfa + numtemps + 1 >= current_max_dfas )
		increase_max_dfas();
d249 1
a249 2
	for ( i = 1; i <= numtemps; ++i )
		{
d253 1
a253 2
		for ( j = 1; j <= numecs; ++j )
			{
d256 1
a256 2
			if ( usemecs )
				{
d261 1
a261 2
				if ( tecbck[j] > 0 )
					{
d264 1
a264 1
					if ( trans > 0 )
a265 1
					}
d267 1
d269 1
a269 2
			else
				{
d272 1
a272 1
				if ( trans > 0 )
a273 1
				}
d275 1
d285 2
a286 2
		mkentry( tmp, nummecs, lastdfa + i + 1, JAMSTATE, totaltrans );
		}
d288 1
d294 2
a295 2
void expand_nxt_chk()
	{
d302 2
a303 2
	nxt = reallocate_integer_array( nxt, current_max_xpairs );
	chk = reallocate_integer_array( chk, current_max_xpairs );
d305 3
a307 3
	zero_out( (char *) (chk + old_max),
		(size_t) (MAX_XPAIRS_INCREMENT * sizeof( int )) );
	}
d329 3
a331 3
int find_table_space( state, numtrans )
int *state, numtrans;
	{
d342 1
a342 2
	if ( numtrans > MAX_XTIONS_FULL_INTERIOR_FIT )
		{
d346 1
a346 1
		if ( tblend < 2 )
d353 1
a353 1
		}
d362 3
a364 4
	while ( 1 )	/* loops until a space is found */
		{
		while ( i + numecs >= current_max_xpairs )
			expand_nxt_chk();
d369 1
a369 2
		while ( 1 )
			{
d371 1
a371 2
			if ( chk[i - 1] == 0 )
				{
d373 1
a373 1
				if ( chk[i] == 0 )
d383 1
a383 1
				}
d388 3
a390 3
			while ( i + numecs >= current_max_xpairs )
				expand_nxt_chk();
			}
d395 1
a395 1
		if ( numtrans <= MAX_XTIONS_FULL_INTERIOR_FIT )
d405 3
a407 3
		for ( chk_ptr = &chk[i + 1];
		      chk_ptr != ptr_to_last_entry_in_state; ++chk_ptr )
			if ( *(state_ptr++) != 0 && *chk_ptr != 0 )
d410 1
a410 1
		if ( chk_ptr == ptr_to_last_entry_in_state )
d414 1
a414 2
		++i;
		}
d416 1
d424 2
a425 2
void inittbl()
	{
d428 3
a430 1
	zero_out( (char *) chk, (size_t) (current_max_xpairs * sizeof( int )) );
d436 1
a436 2
	if ( usemecs )
		{
d444 1
a444 2
		for ( i = 2; i <= numecs; ++i )
			{
d447 1
a447 1
			}
a449 1
		}
d451 1
d456 3
a458 3
void mkdeftbl()
	{
	int i;
d462 1
a462 1
	++tblend; /* room for transition on end-of-buffer character */
d464 2
a465 2
	while ( tblend + numecs >= current_max_xpairs )
		expand_nxt_chk();
d471 1
a471 2
	for ( i = 1; i <= numecs; ++i )
		{
d474 1
a474 1
		}
d483 1
a483 1
	}
d505 4
a508 4
void mkentry( state, numchars, statenum, deflink, totaltrans )
int *state;
int numchars, statenum, deflink, totaltrans;
	{
d510 1
a510 1
	int tblbase, tbllast;
d512 2
a513 3
	if ( totaltrans == 0 )
		{ /* there are no out-transitions */
		if ( deflink == JAMSTATE )
d520 1
a520 1
		}
d522 3
a524 4
	for ( minec = 1; minec <= numchars; ++minec )
		{
		if ( state[minec] != SAME_TRANS )
			if ( state[minec] != 0 || deflink != JAMSTATE )
d526 1
a526 1
		}
d528 1
a528 2
	if ( totaltrans == 1 )
		{
d532 1
a532 1
		stack1( statenum, minec, state[minec], deflink );
d534 1
a534 1
		}
d536 3
a538 4
	for ( maxec = numchars; maxec > 0; --maxec )
		{
		if ( state[maxec] != SAME_TRANS )
			if ( state[maxec] != 0 || deflink != JAMSTATE )
d540 1
a540 1
		}
d552 1
a552 2
	if ( totaltrans * 100 <= numchars * INTERIOR_FIT_PERCENTAGE )
		{
d556 1
a556 2
		while ( baseaddr < minec )
			{
d560 2
a561 3
			for ( ++baseaddr; chk[baseaddr] != 0; ++baseaddr )
				;
			}
d563 2
a564 2
		while ( baseaddr + maxec - minec + 1 >= current_max_xpairs )
			expand_nxt_chk();
d566 11
a576 13
		for ( i = minec; i <= maxec; ++i )
			if ( state[i] != SAME_TRANS &&
			     (state[i] != 0 || deflink != JAMSTATE) &&
			     chk[baseaddr + i - minec] != 0 )
				{ /* baseaddr unsuitable - find another */
				for ( ++baseaddr;
				      baseaddr < current_max_xpairs &&
				      chk[baseaddr] != 0; ++baseaddr )
					;

				while ( baseaddr + maxec - minec + 1 >=
					current_max_xpairs )
					expand_nxt_chk();
d583 2
a584 2
				}
		}
d586 1
a586 2
	else
		{
d590 2
a591 2
		baseaddr = MAX( tblend + 1, minec );
		}
d596 2
a597 2
	while ( tbllast + 1 >= current_max_xpairs )
		expand_nxt_chk();
d602 3
a604 4
	for ( i = minec; i <= maxec; ++i )
		if ( state[i] != SAME_TRANS )
			if ( state[i] != 0 || deflink != JAMSTATE )
				{
d607 1
a607 1
				}
d609 1
a609 1
	if ( baseaddr == firstfree )
d611 1
a611 2
		for ( ++firstfree; chk[firstfree] != 0; ++firstfree )
			;
d613 2
a614 2
	tblend = MAX( tblend, tbllast );
	}
d621 4
a624 4
void mk1tbl( state, sym, onenxt, onedef )
int state, sym, onenxt, onedef;
	{
	if ( firstfree < sym )
d627 3
a629 3
	while ( chk[firstfree] != 0 )
		if ( ++firstfree >= current_max_xpairs )
			expand_nxt_chk();
d636 1
a636 2
	if ( firstfree > tblend )
		{
d639 2
a640 3
		if ( firstfree >= current_max_xpairs )
			expand_nxt_chk();
		}
d642 1
d647 4
a650 4
void mkprot( state, statenum, comstate )
int state[], statenum, comstate;
	{
	int i, slot, tblbase;
d652 1
a652 2
	if ( ++numprots >= MSP || numecs * numprots >= PROT_SAVE_SIZE )
		{
d659 1
a659 1
		}
d666 1
a666 1
	if ( firstprot != NIL )
d676 1
a676 1
	for ( i = 1; i <= numecs; ++i )
d678 1
a678 1
	}
d685 6
a690 6
void mktemplate( state, statenum, comstate )
int state[], statenum, comstate;
	{
	int i, numdiff, tmpbase, tmp[CSIZE + 1];
	Char transset[CSIZE + 1];
	int tsptr;
d703 3
a705 3
	if ( tmpbase + numecs >= current_max_template_xpairs )
		{
		current_max_template_xpairs += MAX_TEMPLATE_XPAIRS_INCREMENT;
d709 3
a711 3
		tnxt = reallocate_integer_array( tnxt,
			current_max_template_xpairs );
		}
d713 2
a714 2
	for ( i = 1; i <= numecs; ++i )
		if ( state[i] == 0 )
d716 1
a716 2
		else
			{
d719 1
a719 1
			}
d721 2
a722 2
	if ( usemecs )
		mkeccl( transset, tsptr, tecfwd, tecbck, numecs, 0 );
d724 1
a724 1
	mkprot( tnxt + tmpbase, -numtemps, comstate );
d730 3
a732 3
	numdiff = tbldiff( state, firstprot, tmp );
	mkentry( tmp, numecs, statenum, -numtemps, numdiff );
	}
d737 5
a741 6
void mv2front( qelm )
int qelm;
	{
	if ( firstprot != qelm )
		{
		if ( qelm == lastprot )
d746 1
a746 1
		if ( protnext[qelm] != NIL )
a752 1
		}
d754 1
d764 3
a766 3
void place_state( state, statenum, transnum )
int *state, statenum, transnum;
	{
d769 1
a769 1
	int position = find_table_space( state, transnum );
d789 2
a790 3
	for ( i = 1; i <= numecs; ++i, ++state_ptr )
		if ( *state_ptr != 0 )
			{
d793 1
a793 1
			}
d795 1
a795 1
	if ( position + numecs > tblend )
d797 1
a797 1
	}
d807 5
a811 5
void stack1( statenum, sym, nextstate, deflink )
int statenum, sym, nextstate, deflink;
	{
	if ( onesp >= ONE_STACK_SIZE - 1 )
		mk1tbl( statenum, sym, nextstate, deflink );
d813 1
a813 2
	else
		{
a818 1
		}
d820 1
d837 3
a839 3
int tbldiff( state, pr, ext )
int state[], pr, ext[];
	{
d845 2
a846 3
	for ( i = numecs; i > 0; --i )
		{
		if ( *++protp == *++sp )
d848 1
a848 2
		else
			{
a850 1
			}
d852 1
d855 1
a855 1
	}
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/tblcmp.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $ */
@


1.4
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.3 1996/07/13 22:22:14 millert Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/tblcmp.c,v 1.3 1996/07/13 22:22:14 millert Exp $ */
d38 1
a38 1
void mkentry PROTO((register int*, int, int, int, int));
d233 1
a233 1
	register int *tmp = tmpstorage, i, j;
d305 1
a305 1
	register int old_max = current_max_xpairs;
d344 3
a346 3
	register int i;
	register int *state_ptr, *chk_ptr;
	register int *ptr_to_last_entry_in_state;
d439 1
a439 1
	register int i;
d520 1
a520 1
register int *state;
d523 1
a523 1
	register int minec, maxec, i, baseaddr;
d797 2
a798 2
	register int i;
	register int *state_ptr;
d872 2
a873 2
	register int i, *sp = state, *ep = ext, *protp;
	register int numdiff = 0;
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: tblcmp.c,v 1.2 1996/06/26 05:35:43 deraadt Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/tblcmp.c,v 2.11 94/11/05 17:08:28 vern Exp $ */
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/tblcmp.c,v 1.1.1.1 1995/10/18 08:45:32 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/tblcmp.c,v 1.7 1995/05/05 05:35:43 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
