head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.11.0.50
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.42
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.46
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.44
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.40
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.38
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.36
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.34
	OPENBSD_5_0:1.11.0.32
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.30
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.28
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.24
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.26
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.22
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.20
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.18
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.16
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.14
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.12
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.10
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.11.19.23.28.03;	author tedu;	state Exp;
branches;
next	1.14;
commitid	CMGrkCVc2tUoCr3Z;

1.14
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.13;
commitid	BIjrMDODd4w0xnpk;

1.13
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.12;
commitid	cuVuNj9APX2eFzx2;

1.12
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.11;
commitid	TCPdLh99ETkn9X6R;

1.11
date	2004.02.03.21.20.17;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.31.22.49.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.00.56.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.30.10.53.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.11.24.01.21.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.30;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@it is not necessary to cast the result of malloc/calloc.
also replace some 0s with the modern concept of NULL
@
text
@/*	$OpenBSD: gen.c,v 1.14 2015/11/19 23:20:34 tedu Exp $	*/

/* gen - actual generation (writing) of flex scanners */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"
#include "tables.h"


/* declare functions that have forward references */

void gen_next_state PROTO((int));
void genecs PROTO((void));
void indent_put2s PROTO((const char *, const char *));
void indent_puts PROTO((const char *));


static int indent_level = 0;	/* each level is 8 spaces */

#define indent_up() (++indent_level)
#define indent_down() (--indent_level)
#define set_indent(indent_val) indent_level = indent_val

/* Almost everything is done in terms of arrays starting at 1, so provide
 * a null entry for the zero element of all C arrays.  (The exception
 * to this is that the fast table representation generally uses the
 * 0 elements of its arrays, too.)
 */

static const char *
get_int16_decl(void)
{
	return (gentables)
	? "static yyconst flex_int16_t %s[%d] =\n    {   0,\n"
	: "static yyconst flex_int16_t * %s = 0;\n";
}


static const char *
get_int32_decl(void)
{
	return (gentables)
	? "static yyconst flex_int32_t %s[%d] =\n    {   0,\n"
	: "static yyconst flex_int32_t * %s = 0;\n";
}

static const char *
get_state_decl(void)
{
	return (gentables)
	? "static yyconst yy_state_type %s[%d] =\n    {   0,\n"
	: "static yyconst yy_state_type * %s = 0;\n";
}

/* Indent to the current level. */

void 
do_indent()
{
	int i = indent_level * 8;

	while (i >= 8) {
		outc('\t');
		i -= 8;
	}

	while (i > 0) {
		outc(' ');
		--i;
	}
}


/** Make the table for possible eol matches.
 *  @@return the newly allocated rule_can_match_eol table
 */
static struct yytbl_data *
mkeoltbl(void)
{
	int i;
	flex_int8_t *tdata = NULL;
	struct yytbl_data *tbl;

	tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(tbl, YYTD_ID_RULE_CAN_MATCH_EOL);
	tbl->td_flags = YYTD_DATA8;
	tbl->td_lolen = num_rules + 1;
	tbl->td_data = tdata =
	    calloc(tbl->td_lolen, sizeof(flex_int8_t));

	for (i = 1; i <= num_rules; i++)
		tdata[i] = rule_has_nl[i] ? 1 : 0;

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_RULE_CAN_MATCH_EOL, (void**)&yy_rule_can_match_eol, sizeof(%s)},\n",
	    "flex_int32_t");
	return tbl;
}

/* Generate the table for possible eol matches. */
static void 
geneoltbl()
{
	int i;

	outn("m4_ifdef( [[M4_YY_USE_LINENO]],[[");
	outn("/* Table of booleans, true if rule could match eol. */");
	out_str_dec(get_int32_decl(), "yy_rule_can_match_eol",
	    num_rules + 1);

	if (gentables) {
		for (i = 1; i <= num_rules; i++) {
			out_dec("%d, ", rule_has_nl[i] ? 1 : 0);
			/* format nicely, 20 numbers per line. */
			if ((i % 20) == 19)
				out("\n    ");
		}
		out("    };\n");
	}
	outn("]])");
}


/* Generate the code to keep backing-up information. */

void 
gen_backing_up()
{
	if (reject || num_backing_up == 0)
		return;

	if (fullspd)
		indent_puts("if ( yy_current_state[-1].yy_nxt )");
	else
		indent_puts("if ( yy_accept[yy_current_state] )");

	indent_up();
	indent_puts("{");
	indent_puts("YY_G(yy_last_accepting_state) = yy_current_state;");
	indent_puts("YY_G(yy_last_accepting_cpos) = yy_cp;");
	indent_puts("}");
	indent_down();
}


/* Generate the code to perform the backing up. */

void 
gen_bu_action()
{
	if (reject || num_backing_up == 0)
		return;

	set_indent(3);

	indent_puts("case 0: /* must back up */");
	indent_puts("/* undo the effects of YY_DO_BEFORE_ACTION */");
	indent_puts("*yy_cp = YY_G(yy_hold_char);");

	if (fullspd || fulltbl)
		indent_puts("yy_cp = YY_G(yy_last_accepting_cpos) + 1;");
	else
		/*
		 * Backing-up info for compressed tables is taken \after/
		 * yy_cp has been incremented for the next state.
		 */
		indent_puts("yy_cp = YY_G(yy_last_accepting_cpos);");

	indent_puts("yy_current_state = YY_G(yy_last_accepting_state);");
	indent_puts("goto yy_find_action;");
	outc('\n');

	set_indent(0);
}

/** mkctbl - make full speed compressed transition table
 * This is an array of structs; each struct a pair of integers.
 * You should call mkssltbl() immediately after this.
 * Then, I think, mkecstbl(). Arrrg.
 * @@return the newly allocated trans table
 */

static struct yytbl_data *
mkctbl(void)
{
	int i;
	struct yytbl_data *tbl = NULL;
	flex_int32_t *tdata = NULL, curr = 0;
	int end_of_buffer_action = num_rules + 1;

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_TRANSITION, (void**)&yy_transition, sizeof(%s)},\n",
	    ((tblend + numecs + 1) >= INT16_MAX
		|| long_align) ? "flex_int32_t" : "flex_int16_t");

	tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(tbl, YYTD_ID_TRANSITION);
	tbl->td_flags = YYTD_DATA32 | YYTD_STRUCT;
	tbl->td_hilen = 0;
	tbl->td_lolen = tblend + numecs + 1;	/* number of structs */

	tbl->td_data = tdata =
	    calloc(tbl->td_lolen * 2, sizeof(flex_int32_t));

	/*
	 * We want the transition to be represented as the offset to the next
	 * state, not the actual state number, which is what it currently is.
	 * The offset is base[nxt[i]] - (base of current state)].  That's
	 * just the difference between the starting points of the two
	 * involved states (to - from).
	 * 
	 * First, though, we need to find some way to put in our end-of-buffer
	 * flags and states.  We do this by making a state with absolutely no
	 * transitions.  We put it at the end of the table.
	 */

	/*
	 * We need to have room in nxt/chk for two more slots: One for the
	 * action and one for the end-of-buffer transition.  We now *assume*
	 * that we're guaranteed the only character we'll try to index this
	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
	 * there's room for jam entries for other characters.
	 */

	while (tblend + 2 >= current_max_xpairs)
		expand_nxt_chk();

	while (lastdfa + 1 >= current_max_dfas)
		increase_max_dfas();

	base[lastdfa + 1] = tblend + 2;
	nxt[tblend + 1] = end_of_buffer_action;
	chk[tblend + 1] = numecs + 1;
	chk[tblend + 2] = 1;	/* anything but EOB */

	/* So that "make test" won't show arb. differences. */
	nxt[tblend + 2] = 0;

	/*
	 * Make sure every state has an end-of-buffer transition and an
	 * action #.
	 */
	for (i = 0; i <= lastdfa; ++i) {
		int anum = dfaacc[i].dfaacc_state;
		int offset = base[i];

		chk[offset] = EOB_POSITION;
		chk[offset - 1] = ACTION_POSITION;
		nxt[offset - 1] = anum;	/* action number */
	}

	for (i = 0; i <= tblend; ++i) {
		if (chk[i] == EOB_POSITION) {
			tdata[curr++] = 0;
			tdata[curr++] = base[lastdfa + 1] - i;
		} else if (chk[i] == ACTION_POSITION) {
			tdata[curr++] = 0;
			tdata[curr++] = nxt[i];
		} else if (chk[i] > numecs || chk[i] == 0) {
			tdata[curr++] = 0;
			tdata[curr++] = 0;
		} else {	/* verify, transition */

			tdata[curr++] = chk[i];
			tdata[curr++] = base[nxt[i]] - (i - chk[i]);
		}
	}


	/* Here's the final, end-of-buffer state. */
	tdata[curr++] = chk[tblend + 1];
	tdata[curr++] = nxt[tblend + 1];

	tdata[curr++] = chk[tblend + 2];
	tdata[curr++] = nxt[tblend + 2];

	return tbl;
}


/** Make start_state_list table.
 *  @@return the newly allocated start_state_list table
 */
static struct yytbl_data *
mkssltbl(void)
{
	struct yytbl_data *tbl = NULL;
	flex_int32_t *tdata = NULL;
	flex_int32_t i;

	tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(tbl, YYTD_ID_START_STATE_LIST);
	tbl->td_flags = YYTD_DATA32 | YYTD_PTRANS;
	tbl->td_hilen = 0;
	tbl->td_lolen = lastsc * 2 + 1;

	tbl->td_data = tdata =
	    calloc(tbl->td_lolen, sizeof(flex_int32_t));

	for (i = 0; i <= lastsc * 2; ++i)
		tdata[i] = base[i];

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_START_STATE_LIST, (void**)&yy_start_state_list, sizeof(%s)},\n",
	    "struct yy_trans_info*");

	return tbl;
}



/* genctbl - generates full speed compressed transition table */

void 
genctbl()
{
	int i;
	int end_of_buffer_action = num_rules + 1;

	/* Table of verify for transition and offset to next state. */
	if (gentables)
		out_dec("static yyconst struct yy_trans_info yy_transition[%d] =\n    {\n", tblend + numecs + 1);
	else
		outn("static yyconst struct yy_trans_info *yy_transition = 0;");

	/*
	 * We want the transition to be represented as the offset to the next
	 * state, not the actual state number, which is what it currently is.
	 * The offset is base[nxt[i]] - (base of current state)].  That's
	 * just the difference between the starting points of the two
	 * involved states (to - from).
	 * 
	 * First, though, we need to find some way to put in our end-of-buffer
	 * flags and states.  We do this by making a state with absolutely no
	 * transitions.  We put it at the end of the table.
	 */

	/*
	 * We need to have room in nxt/chk for two more slots: One for the
	 * action and one for the end-of-buffer transition.  We now *assume*
	 * that we're guaranteed the only character we'll try to index this
	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure
	 * there's room for jam entries for other characters.
	 */

	while (tblend + 2 >= current_max_xpairs)
		expand_nxt_chk();

	while (lastdfa + 1 >= current_max_dfas)
		increase_max_dfas();

	base[lastdfa + 1] = tblend + 2;
	nxt[tblend + 1] = end_of_buffer_action;
	chk[tblend + 1] = numecs + 1;
	chk[tblend + 2] = 1;	/* anything but EOB */

	/* So that "make test" won't show arb. differences. */
	nxt[tblend + 2] = 0;

	/*
	 * Make sure every state has an end-of-buffer transition and an
	 * action #.
	 */
	for (i = 0; i <= lastdfa; ++i) {
		int anum = dfaacc[i].dfaacc_state;
		int offset = base[i];

		chk[offset] = EOB_POSITION;
		chk[offset - 1] = ACTION_POSITION;
		nxt[offset - 1] = anum;	/* action number */
	}

	for (i = 0; i <= tblend; ++i) {
		if (chk[i] == EOB_POSITION)
			transition_struct_out(0, base[lastdfa + 1] - i);

		else if (chk[i] == ACTION_POSITION)
			transition_struct_out(0, nxt[i]);

		else if (chk[i] > numecs || chk[i] == 0)
			transition_struct_out(0, 0);	/* unused slot */

		else		/* verify, transition */
			transition_struct_out(chk[i],
			    base[nxt[i]] - (i -
				chk[i]));
	}


	/* Here's the final, end-of-buffer state. */
	transition_struct_out(chk[tblend + 1], nxt[tblend + 1]);
	transition_struct_out(chk[tblend + 2], nxt[tblend + 2]);

	if (gentables)
		outn("    };\n");

	/* Table of pointers to start states. */
	if (gentables)
		out_dec("static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n", lastsc * 2 + 1);
	else
		outn("static yyconst struct yy_trans_info **yy_start_state_list =0;");

	if (gentables) {
		outn("    {");

		for (i = 0; i <= lastsc * 2; ++i)
			out_dec("    &yy_transition[%d],\n", base[i]);

		dataend();
	}
	if (useecs)
		genecs();
}


/* mkecstbl - Make equivalence-class tables.  */

struct yytbl_data *
mkecstbl(void)
{
	int i;
	struct yytbl_data *tbl = NULL;
	flex_int32_t *tdata = NULL;

	tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(tbl, YYTD_ID_EC);
	tbl->td_flags |= YYTD_DATA32;
	tbl->td_hilen = 0;
	tbl->td_lolen = csize;

	tbl->td_data = tdata =
	    calloc(tbl->td_lolen, sizeof(flex_int32_t));

	for (i = 1; i < csize; ++i) {
		ecgroup[i] = ABS(ecgroup[i]);
		tdata[i] = ecgroup[i];
	}

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_EC, (void**)&yy_ec, sizeof(%s)},\n",
	    "flex_int32_t");

	return tbl;
}

/* Generate equivalence-class tables. */

void 
genecs()
{
	int i, j;
	int numrows;

	out_str_dec(get_int32_decl(), "yy_ec", csize);

	for (i = 1; i < csize; ++i) {
		ecgroup[i] = ABS(ecgroup[i]);
		mkdata(ecgroup[i]);
	}

	dataend();

	if (trace) {
		fputs(_("\n\nEquivalence Classes:\n\n"), stderr);

		numrows = csize / 8;

		for (j = 0; j < numrows; ++j) {
			for (i = j; i < csize; i = i + numrows) {
				fprintf(stderr, "%4s = %-2d",
				    readable_form(i), ecgroup[i]);

				putc(' ', stderr);
			}

			putc('\n', stderr);
		}
	}
}


/* Generate the code to find the action number. */

void 
gen_find_action()
{
	if (fullspd)
		indent_puts("yy_act = yy_current_state[-1].yy_nxt;");

	else if (fulltbl)
		indent_puts("yy_act = yy_accept[yy_current_state];");

	else if (reject) {
		indent_puts("yy_current_state = *--YY_G(yy_state_ptr);");
		indent_puts("YY_G(yy_lp) = yy_accept[yy_current_state];");

		outn("find_rule: /* we branch to this label when backing up */");

		indent_puts
		    ("for ( ; ; ) /* until we find what rule we matched */");

		indent_up();

		indent_puts("{");

		indent_puts
		    ("if ( YY_G(yy_lp) && YY_G(yy_lp) < yy_accept[yy_current_state + 1] )");
		indent_up();
		indent_puts("{");
		indent_puts("yy_act = yy_acclist[YY_G(yy_lp)];");

		if (variable_trailing_context_rules) {
			indent_puts
			    ("if ( yy_act & YY_TRAILING_HEAD_MASK ||");
			indent_puts("     YY_G(yy_looking_for_trail_begin) )");
			indent_up();
			indent_puts("{");

			indent_puts
			    ("if ( yy_act == YY_G(yy_looking_for_trail_begin) )");
			indent_up();
			indent_puts("{");
			indent_puts("YY_G(yy_looking_for_trail_begin) = 0;");
			indent_puts("yy_act &= ~YY_TRAILING_HEAD_MASK;");
			indent_puts("break;");
			indent_puts("}");
			indent_down();

			indent_puts("}");
			indent_down();

			indent_puts
			    ("else if ( yy_act & YY_TRAILING_MASK )");
			indent_up();
			indent_puts("{");
			indent_puts
			    ("YY_G(yy_looking_for_trail_begin) = yy_act & ~YY_TRAILING_MASK;");
			indent_puts
			    ("YY_G(yy_looking_for_trail_begin) |= YY_TRAILING_HEAD_MASK;");

			if (real_reject) {
				/*
				 * Remember matched text in case we back up
				 * due to REJECT.
				 */
				indent_puts
				    ("YY_G(yy_full_match) = yy_cp;");
				indent_puts
				    ("YY_G(yy_full_state) = YY_G(yy_state_ptr);");
				indent_puts("YY_G(yy_full_lp) = YY_G(yy_lp);");
			}
			indent_puts("}");
			indent_down();

			indent_puts("else");
			indent_up();
			indent_puts("{");
			indent_puts("YY_G(yy_full_match) = yy_cp;");
			indent_puts
			    ("YY_G(yy_full_state) = YY_G(yy_state_ptr);");
			indent_puts("YY_G(yy_full_lp) = YY_G(yy_lp);");
			indent_puts("break;");
			indent_puts("}");
			indent_down();

			indent_puts("++YY_G(yy_lp);");
			indent_puts("goto find_rule;");
		} else {
			/*
			 * Remember matched text in case we back up due to
			 * trailing context plus REJECT.
			 */
			indent_up();
			indent_puts("{");
			indent_puts("YY_G(yy_full_match) = yy_cp;");
			indent_puts("break;");
			indent_puts("}");
			indent_down();
		}

		indent_puts("}");
		indent_down();

		indent_puts("--yy_cp;");

		/*
		 * We could consolidate the following two lines with those at
		 * the beginning, but at the cost of complaints that we're
		 * branching inside a loop.
		 */
		indent_puts("yy_current_state = *--YY_G(yy_state_ptr);");
		indent_puts("YY_G(yy_lp) = yy_accept[yy_current_state];");

		indent_puts("}");

		indent_down();
	} else {		/* compressed */
		indent_puts("yy_act = yy_accept[yy_current_state];");

		if (interactive && !reject) {
			/*
			 * Do the guaranteed-needed backing up to figure out
			 * the match.
			 */
			indent_puts("if ( yy_act == 0 )");
			indent_up();
			indent_puts("{ /* have to back up */");
			indent_puts
			    ("yy_cp = YY_G(yy_last_accepting_cpos);");
			indent_puts
			    ("yy_current_state = YY_G(yy_last_accepting_state);");
			indent_puts
			    ("yy_act = yy_accept[yy_current_state];");
			indent_puts("}");
			indent_down();
		}
	}
}

/* mkftbl - make the full table and return the struct .
 * you should call mkecstbl() after this.
 */

struct yytbl_data *
mkftbl(void)
{
	int i;
	int end_of_buffer_action = num_rules + 1;
	struct yytbl_data *tbl;
	flex_int32_t *tdata = NULL;

	tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(tbl, YYTD_ID_ACCEPT);
	tbl->td_flags |= YYTD_DATA32;
	tbl->td_hilen = 0;	/* it's a one-dimensional array */
	tbl->td_lolen = lastdfa + 1;

	tbl->td_data = tdata =
	    calloc(tbl->td_lolen, sizeof(flex_int32_t));

	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;

	for (i = 1; i <= lastdfa; ++i) {
		int anum = dfaacc[i].dfaacc_state;

		tdata[i] = anum;

		if (trace && anum)
			fprintf(stderr, _("state # %d accepts: [%d]\n"),
			    i, anum);
	}

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n",
	    long_align ? "flex_int32_t" : "flex_int16_t");
	return tbl;
}


/* genftbl - generate full transition table */

void 
genftbl()
{
	int i;
	int end_of_buffer_action = num_rules + 1;

	out_str_dec(long_align ? get_int32_decl() : get_int16_decl(),
	    "yy_accept", lastdfa + 1);

	dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;

	for (i = 1; i <= lastdfa; ++i) {
		int anum = dfaacc[i].dfaacc_state;

		mkdata(anum);

		if (trace && anum)
			fprintf(stderr, _("state # %d accepts: [%d]\n"),
			    i, anum);
	}

	dataend();

	if (useecs)
		genecs();

	/*
	 * Don't have to dump the actual full table entries - they were
	 * created on-the-fly.
	 */
}


/* Generate the code to find the next compressed-table state. */

void 
gen_next_compressed_state(char_map)
	char *char_map;
{
	indent_put2s("YY_CHAR yy_c = %s;", char_map);

	/*
	 * Save the backing-up info \before/ computing the next state because
	 * we always compute one more state than needed - we always proceed
	 * until we reach a jam state
	 */
	gen_backing_up();

	indent_puts
	    ("while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )");
	indent_up();
	indent_puts("{");
	indent_puts("yy_current_state = (int) yy_def[yy_current_state];");

	if (usemecs) {
		/*
		 * We've arrange it so that templates are never chained to
		 * one another.  This means we can afford to make a very
		 * simple test to see if we need to convert to yy_c's
		 * meta-equivalence class without worrying about erroneously
		 * looking up the meta-equivalence class twice
		 */
		do_indent();

		/* lastdfa + 2 is the beginning of the templates */
		out_dec("if ( yy_current_state >= %d )\n", lastdfa + 2);

		indent_up();
		indent_puts("yy_c = yy_meta[(unsigned int) yy_c];");
		indent_down();
	}
	indent_puts("}");
	indent_down();

	indent_puts
	    ("yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];");
}


/* Generate the code to find the next match. */

void 
gen_next_match()
{
	/*
	 * NOTE - changes in here should be reflected in gen_next_state() and
	 * gen_NUL_trans().
	 */
	char *char_map = useecs ?
	"yy_ec[YY_SC_TO_UI(*yy_cp)] " : "YY_SC_TO_UI(*yy_cp)";

	char *char_map_2 = useecs ?
	"yy_ec[YY_SC_TO_UI(*++yy_cp)] " : "YY_SC_TO_UI(*++yy_cp)";

	if (fulltbl) {
		if (gentables)
			indent_put2s
			    ("while ( (yy_current_state = yy_nxt[yy_current_state][ %s ]) > 0 )",
			    char_map);
		else
			indent_put2s
			    ("while ( (yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN +  %s ]) > 0 )",
			    char_map);

		indent_up();

		if (num_backing_up > 0) {
			indent_puts("{");
			gen_backing_up();
			outc('\n');
		}
		indent_puts("++yy_cp;");

		if (num_backing_up > 0)
			indent_puts("}");

		indent_down();

		outc('\n');
		indent_puts("yy_current_state = -yy_current_state;");
	} else if (fullspd) {
		indent_puts("{");
		indent_puts
		    ("yyconst struct yy_trans_info *yy_trans_info;\n");
		indent_puts("YY_CHAR yy_c;\n");
		indent_put2s("for ( yy_c = %s;", char_map);
		indent_puts
		    ("      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->");
		indent_puts("yy_verify == yy_c;");
		indent_put2s("      yy_c = %s )", char_map_2);

		indent_up();

		if (num_backing_up > 0)
			indent_puts("{");

		indent_puts("yy_current_state += yy_trans_info->yy_nxt;");

		if (num_backing_up > 0) {
			outc('\n');
			gen_backing_up();
			indent_puts("}");
		}
		indent_down();
		indent_puts("}");
	} else {		/* compressed */
		indent_puts("do");

		indent_up();
		indent_puts("{");

		gen_next_state(false);

		indent_puts("++yy_cp;");


		indent_puts("}");
		indent_down();

		do_indent();

		if (interactive)
			out_dec("while ( yy_base[yy_current_state] != %d );\n", jambase);
		else
			out_dec("while ( yy_current_state != %d );\n",
			    jamstate);

		if (!reject && !interactive) {
			/*
			 * Do the guaranteed-needed backing up to figure out
			 * the match.
			 */
			indent_puts
			    ("yy_cp = YY_G(yy_last_accepting_cpos);");
			indent_puts
			    ("yy_current_state = YY_G(yy_last_accepting_state);");
		}
	}
}


/* Generate the code to find the next state. */

void 
gen_next_state(worry_about_NULs)
	int worry_about_NULs;
{				/* NOTE - changes in here should be reflected
				 * in gen_next_match() */
	char char_map[256];

	if (worry_about_NULs && !nultrans) {
		if (useecs)
			snprintf(char_map, sizeof(char_map),
			    "(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
			    NUL_ec);
		else
			snprintf(char_map, sizeof(char_map),
			    "(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)",
			    NUL_ec);
	} else
		strlcpy(char_map, useecs ?
		    "yy_ec[YY_SC_TO_UI(*yy_cp)] " : "YY_SC_TO_UI(*yy_cp)",
		    sizeof char_map);

	if (worry_about_NULs && nultrans) {
		if (!fulltbl && !fullspd)
			/* Compressed tables back up *before* they match. */
			gen_backing_up();

		indent_puts("if ( *yy_cp )");
		indent_up();
		indent_puts("{");
	}
	if (fulltbl) {
		if (gentables)
			indent_put2s
			    ("yy_current_state = yy_nxt[yy_current_state][%s];",
			    char_map);
		else
			indent_put2s
			    ("yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %s];",
			    char_map);
	} else if (fullspd)
		indent_put2s
		    ("yy_current_state += yy_current_state[%s].yy_nxt;",
		    char_map);

	else
		gen_next_compressed_state(char_map);

	if (worry_about_NULs && nultrans) {

		indent_puts("}");
		indent_down();
		indent_puts("else");
		indent_up();
		indent_puts
		    ("yy_current_state = yy_NUL_trans[yy_current_state];");
		indent_down();
	}
	if (fullspd || fulltbl)
		gen_backing_up();

	if (reject)
		indent_puts("*YY_G(yy_state_ptr)++ = yy_current_state;");
}


/* Generate the code to make a NUL transition. */

void 
gen_NUL_trans()
{				/* NOTE - changes in here should be reflected
				 * in gen_next_match() */
	/*
	 * Only generate a definition for "yy_cp" if we'll generate code that
	 * uses it.  Otherwise lint and the like complain.
	 */
	int need_backing_up = (num_backing_up > 0 && !reject);

	if (need_backing_up && (!nultrans || fullspd || fulltbl))
		/*
		 * We're going to need yy_cp lying around for the call below
		 * to gen_backing_up().
		 */
		indent_puts("char *yy_cp = YY_G(yy_c_buf_p);");

	outc('\n');

	if (nultrans) {
		indent_puts
		    ("yy_current_state = yy_NUL_trans[yy_current_state];");
		indent_puts("yy_is_jam = (yy_current_state == 0);");
	} else if (fulltbl) {
		do_indent();
		if (gentables)
			out_dec("yy_current_state = yy_nxt[yy_current_state][%d];\n", NUL_ec);
		else
			out_dec("yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %d];\n", NUL_ec);
		indent_puts("yy_is_jam = (yy_current_state <= 0);");
	} else if (fullspd) {
		do_indent();
		out_dec("int yy_c = %d;\n", NUL_ec);

		indent_puts
		    ("yyconst struct yy_trans_info *yy_trans_info;\n");
		indent_puts
		    ("yy_trans_info = &yy_current_state[(unsigned int) yy_c];");
		indent_puts("yy_current_state += yy_trans_info->yy_nxt;");

		indent_puts
		    ("yy_is_jam = (yy_trans_info->yy_verify != yy_c);");
	} else {
		char NUL_ec_str[20];

		snprintf(NUL_ec_str, sizeof(NUL_ec_str), "%d", NUL_ec);
		gen_next_compressed_state(NUL_ec_str);

		do_indent();
		out_dec("yy_is_jam = (yy_current_state == %d);\n",
		    jamstate);

		if (reject) {
			/*
			 * Only stack this state if it's a transition we
			 * actually make.  If we stack it on a jam, then the
			 * state stack and yy_c_buf_p get out of sync.
			 */
			indent_puts("if ( ! yy_is_jam )");
			indent_up();
			indent_puts
			    ("*YY_G(yy_state_ptr)++ = yy_current_state;");
			indent_down();
		}
	}

	/*
	 * If we've entered an accepting state, back up; note that compressed
	 * tables have *already* done such backing up, so we needn't bother
	 * with it again.
	 */
	if (need_backing_up && (fullspd || fulltbl)) {
		outc('\n');
		indent_puts("if ( ! yy_is_jam )");
		indent_up();
		indent_puts("{");
		gen_backing_up();
		indent_puts("}");
		indent_down();
	}
}


/* Generate the code to find the start state. */

void 
gen_start_state()
{
	if (fullspd) {
		if (bol_needed) {
			indent_puts
			("yy_current_state = yy_start_state_list[YY_G(yy_start) + YY_AT_BOL()];");
		} else
			indent_puts
			    ("yy_current_state = yy_start_state_list[YY_G(yy_start)];");
	} else {
		indent_puts("yy_current_state = YY_G(yy_start);");

		if (bol_needed)
			indent_puts("yy_current_state += YY_AT_BOL();");

		if (reject) {
			/* Set up for storing up states. */
			outn("m4_ifdef( [[M4_YY_USES_REJECT]],\n[[");
			indent_puts
			    ("YY_G(yy_state_ptr) = YY_G(yy_state_buf);");
			indent_puts
			    ("*YY_G(yy_state_ptr)++ = yy_current_state;");
			outn("]])");
		}
	}
}


/* gentabs - generate data statements for the transition tables */

void 
gentabs()
{
	int i, j, k, *accset, nacc, *acc_array, total_states;
	int end_of_buffer_action = num_rules + 1;
	struct yytbl_data *yyacc_tbl = 0, *yymeta_tbl = 0, *yybase_tbl = 0, *yydef_tbl = 0,
	*yynxt_tbl = 0, *yychk_tbl = 0, *yyacclist_tbl = 0;
	flex_int32_t *yyacc_data = 0, *yybase_data = 0, *yydef_data = 0, *yynxt_data = 0,
	*yychk_data = 0, *yyacclist_data = 0;
	flex_int32_t yybase_curr = 0, yyacclist_curr = 0, yyacc_curr = 0;

	acc_array = allocate_integer_array(current_max_dfas);
	nummt = 0;

	/*
	 * The compressed table format jams by entering the "jam state",
	 * losing information about the previous state in the process. In
	 * order to recover the previous state, we effectively need to keep
	 * backing-up information.
	 */
	++num_backing_up;

	if (reject) {
		/*
		 * Write out accepting list and pointer list.
		 * 
		 * First we generate the "yy_acclist" array.  In the process, we
		 * compute the indices that will go into the "yy_accept"
		 * array, and save the indices in the dfaacc array.
		 */
		int EOB_accepting_list[2];

		/* Set up accepting structures for the End Of Buffer state. */
		EOB_accepting_list[0] = 0;
		EOB_accepting_list[1] = end_of_buffer_action;
		accsiz[end_of_buffer_state] = 1;
		dfaacc[end_of_buffer_state].dfaacc_set =
		    EOB_accepting_list;

		out_str_dec(long_align ? get_int32_decl() :
		    get_int16_decl(), "yy_acclist", MAX(numas,
			1) + 1);

		buf_prints(&yydmap_buf,
		    "\t{YYTD_ID_ACCLIST, (void**)&yy_acclist, sizeof(%s)},\n",
		    long_align ? "flex_int32_t" : "flex_int16_t");

		yyacclist_tbl = calloc(1, sizeof(struct yytbl_data));
		yytbl_data_init(yyacclist_tbl, YYTD_ID_ACCLIST);
		yyacclist_tbl->td_lolen = MAX(numas, 1) + 1;
		yyacclist_tbl->td_data = yyacclist_data =
		    calloc(yyacclist_tbl->td_lolen, sizeof(flex_int32_t));
		yyacclist_curr = 1;

		j = 1;		/* index into "yy_acclist" array */

		for (i = 1; i <= lastdfa; ++i) {
			acc_array[i] = j;

			if (accsiz[i] != 0) {
				accset = dfaacc[i].dfaacc_set;
				nacc = accsiz[i];

				if (trace)
					fprintf(stderr,
					    _("state # %d accepts: "),
					    i);

				for (k = 1; k <= nacc; ++k) {
					int accnum = accset[k];

					++j;

					if (variable_trailing_context_rules
					    && !(accnum &
						YY_TRAILING_HEAD_MASK)
					    && accnum > 0
					    && accnum <= num_rules
					    && rule_type[accnum] ==
					    RULE_VARIABLE) {
						/*
						 * Special hack to flag
						 * accepting number as part
						 * of trailing context rule.
						 */
						accnum |= YY_TRAILING_MASK;
					}
					mkdata(accnum);
					yyacclist_data[yyacclist_curr++] = accnum;

					if (trace) {
						fprintf(stderr, "[%d]",
						    accset[k]);

						if (k < nacc)
							fputs(", ",
							    stderr);
						else
							putc('\n',
							    stderr);
					}
				}
			}
		}

		/* add accepting number for the "jam" state */
		acc_array[i] = j;

		dataend();
		if (tablesext) {
			yytbl_data_compress(yyacclist_tbl);
			if (yytbl_data_fwrite(&tableswr, yyacclist_tbl) < 0)
				flexerror(_("Could not write yyacclist_tbl"));
			yytbl_data_destroy(yyacclist_tbl);
			yyacclist_tbl = NULL;
		}
	} else {
		dfaacc[end_of_buffer_state].dfaacc_state =
		    end_of_buffer_action;

		for (i = 1; i <= lastdfa; ++i)
			acc_array[i] = dfaacc[i].dfaacc_state;

		/* add accepting number for jam state */
		acc_array[i] = 0;
	}

	/* Begin generating yy_accept */

	/*
	 * Spit out "yy_accept" array.  If we're doing "reject", it'll be
	 * pointers into the "yy_acclist" array.  Otherwise it's actual
	 * accepting numbers.  In either case, we just dump the numbers.
	 */

	/*
	 * "lastdfa + 2" is the size of "yy_accept"; includes room for C
	 * arrays beginning at 0 and for "jam" state.
	 */
	k = lastdfa + 2;

	if (reject)
		/*
		 * We put a "cap" on the table associating lists of accepting
		 * numbers with state numbers.  This is needed because we
		 * tell where the end of an accepting list is by looking at
		 * where the list for the next state starts.
		 */
		++k;

	out_str_dec(long_align ? get_int32_decl() : get_int16_decl(),
	    "yy_accept", k);

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n",
	    long_align ? "flex_int32_t" : "flex_int16_t");

	yyacc_tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(yyacc_tbl, YYTD_ID_ACCEPT);
	yyacc_tbl->td_lolen = k;
	yyacc_tbl->td_data = yyacc_data =
	    calloc(yyacc_tbl->td_lolen, sizeof(flex_int32_t));
	yyacc_curr = 1;

	for (i = 1; i <= lastdfa; ++i) {
		mkdata(acc_array[i]);
		yyacc_data[yyacc_curr++] = acc_array[i];

		if (!reject && trace && acc_array[i])
			fprintf(stderr, _("state # %d accepts: [%d]\n"),
			    i, acc_array[i]);
	}

	/* Add entry for "jam" state. */
	mkdata(acc_array[i]);
	yyacc_data[yyacc_curr++] = acc_array[i];

	if (reject) {
		/* Add "cap" for the list. */
		mkdata(acc_array[i]);
		yyacc_data[yyacc_curr++] = acc_array[i];
	}
	dataend();
	if (tablesext) {
		yytbl_data_compress(yyacc_tbl);
		if (yytbl_data_fwrite(&tableswr, yyacc_tbl) < 0)
			flexerror(_("Could not write yyacc_tbl"));
		yytbl_data_destroy(yyacc_tbl);
		yyacc_tbl = NULL;
	}
	/* End generating yy_accept */

	if (useecs) {

		genecs();
		if (tablesext) {
			struct yytbl_data *tbl;

			tbl = mkecstbl();
			yytbl_data_compress(tbl);
			if (yytbl_data_fwrite(&tableswr, tbl) < 0)
				flexerror(_("Could not write ecstbl"));
			yytbl_data_destroy(tbl);
			tbl = 0;
		}
	}
	if (usemecs) {
		/* Begin generating yy_meta */
		/*
		 * Write out meta-equivalence classes (used to index
		 * templates with).
		 */
		flex_int32_t *yymecs_data = NULL;
		yymeta_tbl = calloc(1, sizeof(struct yytbl_data));
		yytbl_data_init(yymeta_tbl, YYTD_ID_META);
		yymeta_tbl->td_lolen = numecs + 1;
		yymeta_tbl->td_data = yymecs_data =
		    calloc(yymeta_tbl->td_lolen,
		    sizeof(flex_int32_t));

		if (trace)
			fputs(_("\n\nMeta-Equivalence Classes:\n"),
			    stderr);

		out_str_dec(get_int32_decl(), "yy_meta", numecs + 1);
		buf_prints(&yydmap_buf,
		    "\t{YYTD_ID_META, (void**)&yy_meta, sizeof(%s)},\n",
		    "flex_int32_t");

		for (i = 1; i <= numecs; ++i) {
			if (trace)
				fprintf(stderr, "%d = %d\n",
				    i, ABS(tecbck[i]));

			mkdata(ABS(tecbck[i]));
			yymecs_data[i] = ABS(tecbck[i]);
		}

		dataend();
		if (tablesext) {
			yytbl_data_compress(yymeta_tbl);
			if (yytbl_data_fwrite(&tableswr, yymeta_tbl) < 0)
				flexerror(_
				    ("Could not write yymeta_tbl"));
			yytbl_data_destroy(yymeta_tbl);
			yymeta_tbl = NULL;
		}
		/* End generating yy_meta */
	}
	total_states = lastdfa + numtemps;

	/* Begin generating yy_base */
	out_str_dec((tblend >= INT16_MAX || long_align) ?
	    get_int32_decl() : get_int16_decl(),
	    "yy_base", total_states + 1);

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_BASE, (void**)&yy_base, sizeof(%s)},\n",
	    (tblend >= INT16_MAX
		|| long_align) ? "flex_int32_t" : "flex_int16_t");
	yybase_tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(yybase_tbl, YYTD_ID_BASE);
	yybase_tbl->td_lolen = total_states + 1;
	yybase_tbl->td_data = yybase_data =
	    calloc(yybase_tbl->td_lolen,
	    sizeof(flex_int32_t));
	yybase_curr = 1;

	for (i = 1; i <= lastdfa; ++i) {
		int d = def[i];

		if (base[i] == JAMSTATE)
			base[i] = jambase;

		if (d == JAMSTATE)
			def[i] = jamstate;

		else if (d < 0) {
			/* Template reference. */
			++tmpuses;
			def[i] = lastdfa - d + 1;
		}
		mkdata(base[i]);
		yybase_data[yybase_curr++] = base[i];
	}

	/* Generate jam state's base index. */
	mkdata(base[i]);
	yybase_data[yybase_curr++] = base[i];

	for (++i /* skip jam state */ ; i <= total_states; ++i) {
		mkdata(base[i]);
		yybase_data[yybase_curr++] = base[i];
		def[i] = jamstate;
	}

	dataend();
	if (tablesext) {
		yytbl_data_compress(yybase_tbl);
		if (yytbl_data_fwrite(&tableswr, yybase_tbl) < 0)
			flexerror(_("Could not write yybase_tbl"));
		yytbl_data_destroy(yybase_tbl);
		yybase_tbl = NULL;
	}
	/* End generating yy_base */


	/* Begin generating yy_def */
	out_str_dec((total_states >= INT16_MAX || long_align) ?
	    get_int32_decl() : get_int16_decl(),
	    "yy_def", total_states + 1);

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_DEF, (void**)&yy_def, sizeof(%s)},\n",
	    (total_states >= INT16_MAX
		|| long_align) ? "flex_int32_t" : "flex_int16_t");

	yydef_tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(yydef_tbl, YYTD_ID_DEF);
	yydef_tbl->td_lolen = total_states + 1;
	yydef_tbl->td_data = yydef_data =
	    calloc(yydef_tbl->td_lolen, sizeof(flex_int32_t));

	for (i = 1; i <= total_states; ++i) {
		mkdata(def[i]);
		yydef_data[i] = def[i];
	}

	dataend();
	if (tablesext) {
		yytbl_data_compress(yydef_tbl);
		if (yytbl_data_fwrite(&tableswr, yydef_tbl) < 0)
			flexerror(_("Could not write yydef_tbl"));
		yytbl_data_destroy(yydef_tbl);
		yydef_tbl = NULL;
	}
	/* End generating yy_def */


	/* Begin generating yy_nxt */
	out_str_dec((total_states >= INT16_MAX || long_align) ?
	    get_int32_decl() : get_int16_decl(), "yy_nxt",
	    tblend + 1);

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_NXT, (void**)&yy_nxt, sizeof(%s)},\n",
	    (total_states >= INT16_MAX
		|| long_align) ? "flex_int32_t" : "flex_int16_t");

	yynxt_tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(yynxt_tbl, YYTD_ID_NXT);
	yynxt_tbl->td_lolen = tblend + 1;
	yynxt_tbl->td_data = yynxt_data =
	    calloc(yynxt_tbl->td_lolen, sizeof(flex_int32_t));

	for (i = 1; i <= tblend; ++i) {
		/*
		 * Note, the order of the following test is important. If
		 * chk[i] is 0, then nxt[i] is undefined.
		 */
		if (chk[i] == 0 || nxt[i] == 0)
			nxt[i] = jamstate;	/* new state is the JAM state */

		mkdata(nxt[i]);
		yynxt_data[i] = nxt[i];
	}

	dataend();
	if (tablesext) {
		yytbl_data_compress(yynxt_tbl);
		if (yytbl_data_fwrite(&tableswr, yynxt_tbl) < 0)
			flexerror(_("Could not write yynxt_tbl"));
		yytbl_data_destroy(yynxt_tbl);
		yynxt_tbl = NULL;
	}
	/* End generating yy_nxt */

	/* Begin generating yy_chk */
	out_str_dec((total_states >= INT16_MAX || long_align) ?
	    get_int32_decl() : get_int16_decl(), "yy_chk",
	    tblend + 1);

	buf_prints(&yydmap_buf,
	    "\t{YYTD_ID_CHK, (void**)&yy_chk, sizeof(%s)},\n",
	    (total_states >= INT16_MAX
		|| long_align) ? "flex_int32_t" : "flex_int16_t");

	yychk_tbl = calloc(1, sizeof(struct yytbl_data));
	yytbl_data_init(yychk_tbl, YYTD_ID_CHK);
	yychk_tbl->td_lolen = tblend + 1;
	yychk_tbl->td_data = yychk_data =
	    calloc(yychk_tbl->td_lolen, sizeof(flex_int32_t));

	for (i = 1; i <= tblend; ++i) {
		if (chk[i] == 0)
			++nummt;

		mkdata(chk[i]);
		yychk_data[i] = chk[i];
	}

	dataend();
	if (tablesext) {
		yytbl_data_compress(yychk_tbl);
		if (yytbl_data_fwrite(&tableswr, yychk_tbl) < 0)
			flexerror(_("Could not write yychk_tbl"));
		yytbl_data_destroy(yychk_tbl);
		yychk_tbl = NULL;
	}
	/* End generating yy_chk */

	free(acc_array);
}


/* Write out a formatted string (with a secondary string argument) at the
 * current indentation level, adding a final newline.
 */

void 
indent_put2s(fmt, arg)
	const char *fmt, *arg;
{
	do_indent();
	out_str(fmt, arg);
	outn("");
}


/* Write out a string at the current indentation level, adding a final
 * newline.
 */

void 
indent_puts(str)
	const char *str;
{
	do_indent();
	outn(str);
}


/* make_tables - generate transition tables and finishes generating output file
 */

void 
make_tables()
{
	int i;
	int did_eof_rule = false;
	struct yytbl_data *yynultrans_tbl;


	skelout();		/* %% [2.0] - break point in skel */

	/*
	 * First, take care of YY_DO_BEFORE_ACTION depending on yymore being
	 * used.
	 */
	set_indent(1);

	if (yymore_used && !yytext_is_array) {
		indent_puts("YY_G(yytext_ptr) -= YY_G(yy_more_len); \\");
		indent_puts
		    ("yyleng = (size_t) (yy_cp - YY_G(yytext_ptr)); \\");
	} else
		indent_puts("yyleng = (size_t) (yy_cp - yy_bp); \\");

	/* Now also deal with copying yytext_ptr to yytext if needed. */
	skelout();		/* %% [3.0] - break point in skel */
	if (yytext_is_array) {
		if (yymore_used)
			indent_puts
			    ("if ( yyleng + YY_G(yy_more_offset) >= YYLMAX ) \\");
		else
			indent_puts("if ( yyleng >= YYLMAX ) \\");

		indent_up();
		indent_puts
		    ("YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\");
		indent_down();

		if (yymore_used) {
			indent_puts
			    ("yy_flex_strncpy( &yytext[YY_G(yy_more_offset)], YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\");
			indent_puts("yyleng += YY_G(yy_more_offset); \\");
			indent_puts
			    ("YY_G(yy_prev_more_offset) = YY_G(yy_more_offset); \\");
			indent_puts("YY_G(yy_more_offset) = 0; \\");
		} else {
			indent_puts
			    ("yy_flex_strncpy( yytext, YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\");
		}
	}
	set_indent(0);

	skelout();		/* %% [4.0] - break point in skel */


	/* This is where we REALLY begin generating the tables. */

	out_dec("#define YY_NUM_RULES %d\n", num_rules);
	out_dec("#define YY_END_OF_BUFFER %d\n", num_rules + 1);

	if (fullspd) {
		/*
		 * Need to define the transet type as a size large enough to
		 * hold the biggest offset.
		 */
		int total_table_size = tblend + numecs + 1;
		char *trans_offset_type =
		(total_table_size >= INT16_MAX || long_align) ?
		"flex_int32_t" : "flex_int16_t";

		set_indent(0);
		indent_puts("struct yy_trans_info");
		indent_up();
		indent_puts("{");

		/*
		 * We require that yy_verify and yy_nxt must be of the same
		 * size int.
		 */
		indent_put2s("%s yy_verify;", trans_offset_type);

		/*
		 * In cases where its sister yy_verify *is* a "yes, there is
		 * a transition", yy_nxt is the offset (in records) to the
		 * next state.  In most cases where there is no transition,
		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th
		 * record of a state, though, then yy_nxt is the action
		 * number for that state.
		 */

		indent_put2s("%s yy_nxt;", trans_offset_type);
		indent_puts("};");
		indent_down();
	} else {
		/*
		 * We generate a bogus 'struct yy_trans_info' data type so we
		 * can guarantee that it is always declared in the skel. This
		 * is so we can compile "sizeof(struct yy_trans_info)" in any
		 * scanner.
		 */
		indent_puts
		    ("/* This struct is not used in this scanner,");
		indent_puts("   but its presence is necessary. */");
		indent_puts("struct yy_trans_info");
		indent_up();
		indent_puts("{");
		indent_puts("flex_int32_t yy_verify;");
		indent_puts("flex_int32_t yy_nxt;");
		indent_puts("};");
		indent_down();
	}

	if (fullspd) {
		genctbl();
		if (tablesext) {
			struct yytbl_data *tbl;

			tbl = mkctbl();
			yytbl_data_compress(tbl);
			if (yytbl_data_fwrite(&tableswr, tbl) < 0)
				flexerror(_("Could not write ftbl"));
			yytbl_data_destroy(tbl);

			tbl = mkssltbl();
			yytbl_data_compress(tbl);
			if (yytbl_data_fwrite(&tableswr, tbl) < 0)
				flexerror(_("Could not write ssltbl"));
			yytbl_data_destroy(tbl);
			tbl = 0;

			if (useecs) {
				tbl = mkecstbl();
				yytbl_data_compress(tbl);
				if (yytbl_data_fwrite(&tableswr, tbl) < 0)
					flexerror(_
					    ("Could not write ecstbl"));
				yytbl_data_destroy(tbl);
				tbl = 0;
			}
		}
	} else if (fulltbl) {
		genftbl();
		if (tablesext) {
			struct yytbl_data *tbl;

			tbl = mkftbl();
			yytbl_data_compress(tbl);
			if (yytbl_data_fwrite(&tableswr, tbl) < 0)
				flexerror(_("Could not write ftbl"));
			yytbl_data_destroy(tbl);
			tbl = 0;

			if (useecs) {
				tbl = mkecstbl();
				yytbl_data_compress(tbl);
				if (yytbl_data_fwrite(&tableswr, tbl) < 0)
					flexerror(_
					    ("Could not write ecstbl"));
				yytbl_data_destroy(tbl);
				tbl = 0;
			}
		}
	} else
		gentabs();

	if (do_yylineno) {

		geneoltbl();

		if (tablesext) {
			struct yytbl_data *tbl;

			tbl = mkeoltbl();
			yytbl_data_compress(tbl);
			if (yytbl_data_fwrite(&tableswr, tbl) < 0)
				flexerror(_("Could not write eoltbl"));
			yytbl_data_destroy(tbl);
			tbl = 0;
		}
	}
	/*
	 * Definitions for backing up.  We don't need them if REJECT is being
	 * used because then we use an alternative backin-up technique
	 * instead.
	 */
	if (num_backing_up > 0 && !reject) {
		if (!C_plus_plus && !reentrant) {
			indent_puts
			    ("static yy_state_type yy_last_accepting_state;");
			indent_puts
			    ("static char *yy_last_accepting_cpos;\n");
		}
	}
	if (nultrans) {
		flex_int32_t *yynultrans_data = NULL;

		/* Begin generating yy_NUL_trans */
		out_str_dec(get_state_decl(), "yy_NUL_trans",
		    lastdfa + 1);
		buf_prints(&yydmap_buf,
		    "\t{YYTD_ID_NUL_TRANS, (void**)&yy_NUL_trans, sizeof(%s)},\n",
		    (fullspd) ? "struct yy_trans_info*" :
		    "flex_int32_t");

		yynultrans_tbl = calloc(1, sizeof(struct yytbl_data));
		yytbl_data_init(yynultrans_tbl, YYTD_ID_NUL_TRANS);
		if (fullspd)
			yynultrans_tbl->td_flags |= YYTD_PTRANS;
		yynultrans_tbl->td_lolen = lastdfa + 1;
		yynultrans_tbl->td_data = yynultrans_data =
		    calloc(yynultrans_tbl->td_lolen,
		    sizeof(flex_int32_t));

		for (i = 1; i <= lastdfa; ++i) {
			if (fullspd) {
				out_dec("    &yy_transition[%d],\n",
				    base[i]);
				yynultrans_data[i] = base[i];
			} else {
				mkdata(nultrans[i]);
				yynultrans_data[i] = nultrans[i];
			}
		}

		dataend();
		if (tablesext) {
			yytbl_data_compress(yynultrans_tbl);
			if (yytbl_data_fwrite(&tableswr, yynultrans_tbl) < 0)
				flexerror(_
				    ("Could not write yynultrans_tbl"));
			yytbl_data_destroy(yynultrans_tbl);
			yynultrans_tbl = NULL;
		}
		/* End generating yy_NUL_trans */
	}
	if (!C_plus_plus && !reentrant) {
		indent_puts("extern int yy_flex_debug;");
		indent_put2s("int yy_flex_debug = %s;\n",
		    ddebug ? "1" : "0");
	}
	if (ddebug) {		/* Spit out table mapping rules to line
				 * numbers. */
		out_str_dec(long_align ? get_int32_decl() :
		    get_int16_decl(), "yy_rule_linenum",
		    num_rules);
		for (i = 1; i < num_rules; ++i)
			mkdata(rule_linenum[i]);
		dataend();
	}
	if (reject) {
		outn("m4_ifdef( [[M4_YY_USES_REJECT]],\n[[");
		/* Declare state buffer variables. */
		if (!C_plus_plus && !reentrant) {
			outn("static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;");
			outn("static char *yy_full_match;");
			outn("static int yy_lp;");
		}
		if (variable_trailing_context_rules) {
			if (!C_plus_plus && !reentrant) {
				outn("static int yy_looking_for_trail_begin = 0;");
				outn("static int yy_full_lp;");
				outn("static int *yy_full_state;");
			}
			out_hex("#define YY_TRAILING_MASK 0x%x\n",
			    (unsigned int) YY_TRAILING_MASK);
			out_hex("#define YY_TRAILING_HEAD_MASK 0x%x\n",
			    (unsigned int) YY_TRAILING_HEAD_MASK);
		}
		outn("#define REJECT \\");
		outn("{ \\");
		outn("*yy_cp = YY_G(yy_hold_char); /* undo effects of setting up yytext */ \\");
		outn("yy_cp = YY_G(yy_full_match); /* restore poss. backed-over text */ \\");

		if (variable_trailing_context_rules) {
			outn("YY_G(yy_lp) = YY_G(yy_full_lp); /* restore orig. accepting pos. */ \\");
			outn("YY_G(yy_state_ptr) = YY_G(yy_full_state); /* restore orig. state */ \\");
			outn("yy_current_state = *YY_G(yy_state_ptr); /* restore curr. state */ \\");
		}
		outn("++YY_G(yy_lp); \\");
		outn("goto find_rule; \\");

		outn("}");
		outn("]])\n");
	} else {
		outn("/* The intent behind this definition is that it'll catch");
		outn(" * any uses of REJECT which flex missed.");
		outn(" */");
		outn("#define REJECT reject_used_but_not_detected");
	}

	if (yymore_used) {
		if (!C_plus_plus) {
			if (yytext_is_array) {
				if (!reentrant) {
					indent_puts("static int yy_more_offset = 0;");
					indent_puts("static int yy_prev_more_offset = 0;");
				}
			} else if (!reentrant) {
				indent_puts
				    ("static int yy_more_flag = 0;");
				indent_puts
				    ("static int yy_more_len = 0;");
			}
		}
		if (yytext_is_array) {
			indent_puts
			    ("#define yymore() (YY_G(yy_more_offset) = yy_flex_strlen( yytext M4_YY_CALL_LAST_ARG))");
			indent_puts("#define YY_NEED_STRLEN");
			indent_puts("#define YY_MORE_ADJ 0");
			indent_puts
			    ("#define YY_RESTORE_YY_MORE_OFFSET \\");
			indent_up();
			indent_puts("{ \\");
			indent_puts
			    ("YY_G(yy_more_offset) = YY_G(yy_prev_more_offset); \\");
			indent_puts("yyleng -= YY_G(yy_more_offset); \\");
			indent_puts("}");
			indent_down();
		} else {
			indent_puts
			    ("#define yymore() (YY_G(yy_more_flag) = 1)");
			indent_puts
			    ("#define YY_MORE_ADJ YY_G(yy_more_len)");
			indent_puts("#define YY_RESTORE_YY_MORE_OFFSET");
		}
	} else {
		indent_puts
		    ("#define yymore() yymore_used_but_not_detected");
		indent_puts("#define YY_MORE_ADJ 0");
		indent_puts("#define YY_RESTORE_YY_MORE_OFFSET");
	}

	if (!C_plus_plus) {
		if (yytext_is_array) {
			outn("#ifndef YYLMAX");
			outn("#define YYLMAX 8192");
			outn("#endif\n");
			if (!reentrant) {
				outn("char yytext[YYLMAX];");
				outn("char *yytext_ptr;");
			}
		} else {
			if (!reentrant)
				outn("char *yytext;");
		}
	}
	out(&action_array[defs1_offset]);

	line_directive_out(stdout, 0);

	skelout();		/* %% [5.0] - break point in skel */

	if (!C_plus_plus) {
		if (use_read) {
			outn("\terrno=0; \\");
			outn("\twhile ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\");
			outn("\t{ \\");
			outn("\t\tif( errno != EINTR) \\");
			outn("\t\t{ \\");
			outn("\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn("\t\t\tbreak; \\");
			outn("\t\t} \\");
			outn("\t\terrno=0; \\");
			outn("\t\tclearerr(yyin); \\");
			outn("\t}\\");
		} else {
			outn("\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\");
			outn("\t\t{ \\");
			outn("\t\tint c = '*'; \\");
			outn("\t\tsize_t n; \\");
			outn("\t\tfor ( n = 0; n < max_size && \\");
			outn("\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\");
			outn("\t\t\tbuf[n] = (char) c; \\");
			outn("\t\tif ( c == '\\n' ) \\");
			outn("\t\t\tbuf[n++] = (char) c; \\");
			outn("\t\tif ( c == EOF && ferror( yyin ) ) \\");
			outn("\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn("\t\tresult = n; \\");
			outn("\t\t} \\");
			outn("\telse \\");
			outn("\t\t{ \\");
			outn("\t\terrno=0; \\");
			outn("\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\");
			outn("\t\t\t{ \\");
			outn("\t\t\tif( errno != EINTR) \\");
			outn("\t\t\t\t{ \\");
			outn("\t\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn("\t\t\t\tbreak; \\");
			outn("\t\t\t\t} \\");
			outn("\t\t\terrno=0; \\");
			outn("\t\t\tclearerr(yyin); \\");
			outn("\t\t\t} \\");
			outn("\t\t}\\");
		}
	}
	skelout();		/* %% [6.0] - break point in skel */

	indent_puts("#define YY_RULE_SETUP \\");
	indent_up();
	if (bol_needed) {
		indent_puts("if ( yyleng > 0 ) \\");
		indent_up();
		indent_puts("YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \\");
		indent_puts("\t\t(yytext[yyleng - 1] == '\\n'); \\");
		indent_down();
	}
	indent_puts("YY_USER_ACTION");
	indent_down();

	skelout();		/* %% [7.0] - break point in skel */

	/* Copy prolog to output file. */
	out(&action_array[prolog_offset]);

	line_directive_out(stdout, 0);

	skelout();		/* %% [8.0] - break point in skel */

	set_indent(2);

	if (yymore_used && !yytext_is_array) {
		indent_puts("YY_G(yy_more_len) = 0;");
		indent_puts("if ( YY_G(yy_more_flag) )");
		indent_up();
		indent_puts("{");
		indent_puts
		    ("YY_G(yy_more_len) = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);");
		indent_puts("YY_G(yy_more_flag) = 0;");
		indent_puts("}");
		indent_down();
	}
	skelout();		/* %% [9.0] - break point in skel */

	gen_start_state();

	/* Note, don't use any indentation. */
	outn("yy_match:");
	gen_next_match();

	skelout();		/* %% [10.0] - break point in skel */
	set_indent(2);
	gen_find_action();

	skelout();		/* %% [11.0] - break point in skel */
	outn("m4_ifdef( [[M4_YY_USE_LINENO]],[[");
	indent_puts
	    ("if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )");
	indent_up();
	indent_puts("{");
	indent_puts("yy_size_t yyl;");
	do_indent();
	out_str("for ( yyl = %s; yyl < yyleng; ++yyl )\n",
	    yymore_used ? (yytext_is_array ? "YY_G(yy_prev_more_offset)" :
		"YY_G(yy_more_len)") : "0");
	indent_up();
	indent_puts("if ( yytext[yyl] == '\\n' )");
	indent_up();
	indent_puts("M4_YY_INCR_LINENO();");
	indent_down();
	indent_down();
	indent_puts("}");
	indent_down();
	outn("]])");

	skelout();		/* %% [12.0] - break point in skel */
	if (ddebug) {
		indent_puts("if ( yy_flex_debug )");
		indent_up();

		indent_puts("{");
		indent_puts("if ( yy_act == 0 )");
		indent_up();
		indent_puts(C_plus_plus ?
		    "std::cerr << \"--scanner backing up\\n\";" :
		    "fprintf( stderr, \"--scanner backing up\\n\" );");
		indent_down();

		do_indent();
		out_dec("else if ( yy_act < %d )\n", num_rules);
		indent_up();

		if (C_plus_plus) {
			indent_puts
			    ("std::cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<");
			indent_puts
			    ("         \"(\\\"\" << yytext << \"\\\")\\n\";");
		} else {
			indent_puts
			    ("fprintf( stderr, \"--accepting rule at line %ld (\\\"%s\\\")\\n\",");

			indent_puts
			    ("         (long)yy_rule_linenum[yy_act], yytext );");
		}

		indent_down();

		do_indent();
		out_dec("else if ( yy_act == %d )\n", num_rules);
		indent_up();

		if (C_plus_plus) {
			indent_puts
			    ("std::cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";");
		} else {
			indent_puts
			    ("fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\",");
			indent_puts("         yytext );");
		}

		indent_down();

		do_indent();
		out_dec("else if ( yy_act == %d )\n", num_rules + 1);
		indent_up();

		indent_puts(C_plus_plus ?
		    "std::cerr << \"--(end of buffer or a NUL)\\n\";" :
		    "fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );");

		indent_down();

		do_indent();
		outn("else");
		indent_up();

		if (C_plus_plus) {
			indent_puts
			    ("std::cerr << \"--EOF (start condition \" << YY_START << \")\\n\";");
		} else {
			indent_puts
			    ("fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );");
		}

		indent_down();

		indent_puts("}");
		indent_down();
	}
	/* Copy actions to output file. */
	skelout();		/* %% [13.0] - break point in skel */
	indent_up();
	gen_bu_action();
	out(&action_array[action_offset]);

	line_directive_out(stdout, 0);

	/* generate cases for any missing EOF rules */
	for (i = 1; i <= lastsc; ++i)
		if (!sceof[i]) {
			do_indent();
			out_str("case YY_STATE_EOF(%s):\n", scname[i]);
			did_eof_rule = true;
		}
	if (did_eof_rule) {
		indent_up();
		indent_puts("yyterminate();");
		indent_down();
	}
	/* Generate code for handling NUL's, if needed. */

	/*
	 * First, deal with backing up and setting up yy_cp if the scanner
	 * finds that it should JAM on the NUL.
	 */
	skelout();		/* %% [14.0] - break point in skel */
	set_indent(4);

	if (fullspd || fulltbl)
		indent_puts("yy_cp = YY_G(yy_c_buf_p);");

	else {			/* compressed table */
		if (!reject && !interactive) {
			/*
			 * Do the guaranteed-needed backing up to figure out
			 * the match.
			 */
			indent_puts
			    ("yy_cp = YY_G(yy_last_accepting_cpos);");
			indent_puts
			    ("yy_current_state = YY_G(yy_last_accepting_state);");
		} else
			/*
			 * Still need to initialize yy_cp, though
			 * yy_current_state was set up by
			 * yy_get_previous_state().
			 */
			indent_puts("yy_cp = YY_G(yy_c_buf_p);");
	}


	/* Generate code for yy_get_previous_state(). */
	set_indent(1);
	skelout();		/* %% [15.0] - break point in skel */

	gen_start_state();

	set_indent(2);
	skelout();		/* %% [16.0] - break point in skel */
	gen_next_state(true);

	set_indent(1);
	skelout();		/* %% [17.0] - break point in skel */
	gen_NUL_trans();

	skelout();		/* %% [18.0] - break point in skel */
	skelout();		/* %% [19.0] - break point in skel */
	/* Update BOL and yylineno inside of input(). */
	if (bol_needed) {
		indent_puts
		    ("YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');");
		if (do_yylineno) {
			indent_puts
			    ("if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )");
			indent_up();
			indent_puts("M4_YY_INCR_LINENO();");
			indent_down();
		}
	} else if (do_yylineno) {
		indent_puts("if ( c == '\\n' )");
		indent_up();
		indent_puts("M4_YY_INCR_LINENO();");
		indent_down();
	}
	skelout();

	/* Copy remainder of input to output. */

	line_directive_out(stdout, 1);

	if (sectnum == 3) {
		OUT_BEGIN_CODE();
		(void) flexscan();	/* copy remainder of input to output */
		OUT_END_CODE();
	}
}
@


1.14
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.13 2015/11/19 22:52:40 tedu Exp $	*/
d111 1
a111 1
	flex_int8_t *tdata = 0;
d114 1
a114 1
	tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d119 1
a119 1
	    (flex_int8_t *) calloc(tbl->td_lolen, sizeof(flex_int8_t));
d217 2
a218 2
	struct yytbl_data *tbl = 0;
	flex_int32_t *tdata = 0, curr = 0;
d226 1
a226 1
	tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d233 1
a233 1
	    (flex_int32_t *) calloc(tbl->td_lolen * 2, sizeof(flex_int32_t));
d317 2
a318 2
	struct yytbl_data *tbl = 0;
	flex_int32_t *tdata = 0;
d321 1
a321 1
	tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d328 1
a328 1
	    (flex_int32_t *) calloc(tbl->td_lolen, sizeof(flex_int32_t));
d452 2
a453 2
	struct yytbl_data *tbl = 0;
	flex_int32_t *tdata = 0;
d455 1
a455 1
	tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d462 1
a462 1
	    (flex_int32_t *) calloc(tbl->td_lolen, sizeof(flex_int32_t));
d660 1
a660 1
	flex_int32_t *tdata = 0;
d662 1
a662 1
	tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d669 1
a669 1
	    (flex_int32_t *) calloc(tbl->td_lolen, sizeof(flex_int32_t));
d1105 1
a1105 1
		yyacclist_tbl = (struct yytbl_data *) calloc(1, sizeof(struct yytbl_data));
d1109 1
a1109 1
		    (flex_int32_t *) calloc(yyacclist_tbl->td_lolen, sizeof(flex_int32_t));
d1215 1
a1215 3
	yyacc_tbl =
	    (struct yytbl_data *) calloc(1,
	    sizeof(struct yytbl_data));
d1219 1
a1219 1
	    (flex_int32_t *) calloc(yyacc_tbl->td_lolen, sizeof(flex_int32_t));
d1270 2
a1271 5
		flex_int32_t *yymecs_data = 0;
		yymeta_tbl =
		    (struct yytbl_data *) calloc(1,
		    sizeof(struct
			yytbl_data));
d1275 1
a1275 1
		    (flex_int32_t *) calloc(yymeta_tbl->td_lolen,
d1318 1
a1318 3
	yybase_tbl =
	    (struct yytbl_data *) calloc(1,
	    sizeof(struct yytbl_data));
d1322 1
a1322 1
	    (flex_int32_t *) calloc(yybase_tbl->td_lolen,
d1375 1
a1375 3
	yydef_tbl =
	    (struct yytbl_data *) calloc(1,
	    sizeof(struct yytbl_data));
d1379 1
a1379 1
	    (flex_int32_t *) calloc(yydef_tbl->td_lolen, sizeof(flex_int32_t));
d1407 1
a1407 3
	yynxt_tbl =
	    (struct yytbl_data *) calloc(1,
	    sizeof(struct yytbl_data));
d1411 1
a1411 1
	    (flex_int32_t *) calloc(yynxt_tbl->td_lolen, sizeof(flex_int32_t));
d1445 1
a1445 3
	yychk_tbl =
	    (struct yytbl_data *) calloc(1,
	    sizeof(struct yytbl_data));
d1449 1
a1449 1
	    (flex_int32_t *) calloc(yychk_tbl->td_lolen, sizeof(flex_int32_t));
d1469 1
a1469 1
	free((void *) acc_array);
d1696 1
a1696 1
		flex_int32_t *yynultrans_data = 0;
d1706 1
a1706 4
		yynultrans_tbl =
		    (struct yytbl_data *) calloc(1,
		    sizeof(struct
			yytbl_data));
d1712 1
a1712 1
		    (flex_int32_t *) calloc(yynultrans_tbl->td_lolen,
d1729 1
a1729 2
			if (yytbl_data_fwrite(&tableswr, yynultrans_tbl) <
			    0)
@


1.13
log
@orbital strike from moonbase knf
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.12 2015/11/19 19:43:40 tedu Exp $	*/
d1482 1
a1482 1
	flex_free((void *) acc_array);
@


1.12
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.11 2004/02/03 21:20:17 espie Exp $	*/
d42 4
a45 4
void gen_next_state PROTO ((int));
void genecs PROTO ((void));
void indent_put2s PROTO ((const char *, const char *));
void indent_puts PROTO ((const char *));
d60 2
a61 1
static const char *get_int16_decl (void)
d64 2
a65 2
		? "static yyconst flex_int16_t %s[%d] =\n    {   0,\n"
		: "static yyconst flex_int16_t * %s = 0;\n";
d69 2
a70 1
static const char *get_int32_decl (void)
d73 2
a74 2
		? "static yyconst flex_int32_t %s[%d] =\n    {   0,\n"
		: "static yyconst flex_int32_t * %s = 0;\n";
d77 2
a78 1
static const char *get_state_decl (void)
d81 2
a82 2
		? "static yyconst yy_state_type %s[%d] =\n    {   0,\n"
		: "static yyconst yy_state_type * %s = 0;\n";
d87 2
a88 1
void do_indent ()
d93 1
a93 1
		outc ('\t');
d98 1
a98 1
		outc (' ');
d107 2
a108 1
static struct yytbl_data *mkeoltbl (void)
d110 1
a110 1
	int     i;
d114 2
a115 2
	tbl = (struct yytbl_data *) calloc (1, sizeof (struct yytbl_data));
	yytbl_data_init (tbl, YYTD_ID_RULE_CAN_MATCH_EOL);
d119 1
a119 1
		(flex_int8_t *) calloc (tbl->td_lolen, sizeof (flex_int8_t));
d124 3
a126 3
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_RULE_CAN_MATCH_EOL, (void**)&yy_rule_can_match_eol, sizeof(%s)},\n",
		    "flex_int32_t");
d131 2
a132 1
static void geneoltbl ()
d134 1
a134 1
	int     i;
d136 4
a139 4
	outn ("m4_ifdef( [[M4_YY_USE_LINENO]],[[");
	outn ("/* Table of booleans, true if rule could match eol. */");
	out_str_dec (get_int32_decl (), "yy_rule_can_match_eol",
		     num_rules + 1);
d143 1
a143 1
			out_dec ("%d, ", rule_has_nl[i] ? 1 : 0);
d146 1
a146 1
				out ("\n    ");
d148 1
a148 1
		out ("    };\n");
d150 1
a150 1
	outn ("]])");
d156 2
a157 1
void gen_backing_up ()
d163 1
a163 1
		indent_puts ("if ( yy_current_state[-1].yy_nxt )");
d165 1
a165 1
		indent_puts ("if ( yy_accept[yy_current_state] )");
d167 6
a172 6
	indent_up ();
	indent_puts ("{");
	indent_puts ("YY_G(yy_last_accepting_state) = yy_current_state;");
	indent_puts ("YY_G(yy_last_accepting_cpos) = yy_cp;");
	indent_puts ("}");
	indent_down ();
d178 2
a179 1
void gen_bu_action ()
d184 1
a184 1
	set_indent (3);
d186 3
a188 3
	indent_puts ("case 0: /* must back up */");
	indent_puts ("/* undo the effects of YY_DO_BEFORE_ACTION */");
	indent_puts ("*yy_cp = YY_G(yy_hold_char);");
d191 1
a191 1
		indent_puts ("yy_cp = YY_G(yy_last_accepting_cpos) + 1;");
d193 2
a194 1
		/* Backing-up info for compressed tables is taken \after/
d197 1
a197 1
		indent_puts ("yy_cp = YY_G(yy_last_accepting_cpos);");
d199 3
a201 3
	indent_puts ("yy_current_state = YY_G(yy_last_accepting_state);");
	indent_puts ("goto yy_find_action;");
	outc ('\n');
d203 1
a203 1
	set_indent (0);
d213 2
a214 1
static struct yytbl_data *mkctbl (void)
d219 1
a219 1
	int     end_of_buffer_action = num_rules + 1;
d221 4
a224 4
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_TRANSITION, (void**)&yy_transition, sizeof(%s)},\n",
		    ((tblend + numecs + 1) >= INT16_MAX
		     || long_align) ? "flex_int32_t" : "flex_int16_t");
d226 2
a227 2
	tbl = (struct yytbl_data *) calloc (1, sizeof (struct yytbl_data));
	yytbl_data_init (tbl, YYTD_ID_TRANSITION);
d233 1
a233 1
		(flex_int32_t *) calloc (tbl->td_lolen * 2, sizeof (flex_int32_t));
d235 7
a241 6
	/* We want the transition to be represented as the offset to the
	 * next state, not the actual state number, which is what it currently
	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
	 * just the difference between the starting points of the two involved
	 * states (to - from).
	 *
d247 2
a248 1
	/* We need to have room in nxt/chk for two more slots: One for the
d256 1
a256 1
		expand_nxt_chk ();
d259 1
a259 1
		increase_max_dfas ();
d269 2
a270 1
	/* Make sure every state has an end-of-buffer transition and an
d274 2
a275 2
		int     anum = dfaacc[i].dfaacc_state;
		int     offset = base[i];
d286 1
a286 3
		}

		else if (chk[i] == ACTION_POSITION) {
d289 1
a289 3
		}

		else if (chk[i] > numecs || chk[i] == 0) {
d292 1
a292 2
		}
		else {		/* verify, transition */
d314 2
a315 1
static struct yytbl_data *mkssltbl (void)
d321 2
a322 2
	tbl = (struct yytbl_data *) calloc (1, sizeof (struct yytbl_data));
	yytbl_data_init (tbl, YYTD_ID_START_STATE_LIST);
d328 1
a328 1
		(flex_int32_t *) calloc (tbl->td_lolen, sizeof (flex_int32_t));
d333 3
a335 3
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_START_STATE_LIST, (void**)&yy_start_state_list, sizeof(%s)},\n",
		    "struct yy_trans_info*");
d344 2
a345 1
void genctbl ()
d348 1
a348 1
	int     end_of_buffer_action = num_rules + 1;
d352 1
a352 1
		out_dec ("static yyconst struct yy_trans_info yy_transition[%d] =\n    {\n", tblend + numecs + 1);
d354 1
a354 1
		outn ("static yyconst struct yy_trans_info *yy_transition = 0;");
d356 7
a362 6
	/* We want the transition to be represented as the offset to the
	 * next state, not the actual state number, which is what it currently
	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's
	 * just the difference between the starting points of the two involved
	 * states (to - from).
	 *
d368 2
a369 1
	/* We need to have room in nxt/chk for two more slots: One for the
d377 1
a377 1
		expand_nxt_chk ();
d380 1
a380 1
		increase_max_dfas ();
d390 2
a391 1
	/* Make sure every state has an end-of-buffer transition and an
d395 2
a396 2
		int     anum = dfaacc[i].dfaacc_state;
		int     offset = base[i];
d405 1
a405 1
			transition_struct_out (0, base[lastdfa + 1] - i);
d408 1
a408 1
			transition_struct_out (0, nxt[i]);
d411 1
a411 1
			transition_struct_out (0, 0);	/* unused slot */
d414 3
a416 3
			transition_struct_out (chk[i],
					       base[nxt[i]] - (i -
							       chk[i]));
d421 2
a422 2
	transition_struct_out (chk[tblend + 1], nxt[tblend + 1]);
	transition_struct_out (chk[tblend + 2], nxt[tblend + 2]);
d425 1
a425 1
		outn ("    };\n");
d429 1
a429 1
		out_dec ("static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n", lastsc * 2 + 1);
d431 1
a431 1
		outn ("static yyconst struct yy_trans_info **yy_start_state_list =0;");
d434 1
a434 1
		outn ("    {");
d437 1
a437 1
			out_dec ("    &yy_transition[%d],\n", base[i]);
d439 1
a439 1
		dataend ();
a440 1

d442 1
a442 1
		genecs ();
d448 2
a449 1
struct yytbl_data *mkecstbl (void)
d455 2
a456 2
	tbl = (struct yytbl_data *) calloc (1, sizeof (struct yytbl_data));
	yytbl_data_init (tbl, YYTD_ID_EC);
d462 1
a462 1
		(flex_int32_t *) calloc (tbl->td_lolen, sizeof (flex_int32_t));
d465 1
a465 1
		ecgroup[i] = ABS (ecgroup[i]);
d469 3
a471 3
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_EC, (void**)&yy_ec, sizeof(%s)},\n",
		    "flex_int32_t");
d478 2
a479 1
void genecs ()
d482 1
a482 1
	int     numrows;
d484 1
a484 1
	out_str_dec (get_int32_decl (), "yy_ec", csize);
d487 2
a488 2
		ecgroup[i] = ABS (ecgroup[i]);
		mkdata (ecgroup[i]);
d491 1
a491 1
	dataend ();
d494 1
a494 1
		fputs (_("\n\nEquivalence Classes:\n\n"), stderr);
d500 2
a501 2
				fprintf (stderr, "%4s = %-2d",
					 readable_form (i), ecgroup[i]);
d503 1
a503 1
				putc (' ', stderr);
d506 1
a506 1
			putc ('\n', stderr);
d514 2
a515 1
void gen_find_action ()
d518 1
a518 1
		indent_puts ("yy_act = yy_current_state[-1].yy_nxt;");
d521 1
a521 1
		indent_puts ("yy_act = yy_accept[yy_current_state];");
d524 2
a525 2
		indent_puts ("yy_current_state = *--YY_G(yy_state_ptr);");
		indent_puts ("YY_G(yy_lp) = yy_accept[yy_current_state];");
d527 1
a527 1
		outn ("find_rule: /* we branch to this label when backing up */");
d530 1
a530 1
			("for ( ; ; ) /* until we find what rule we matched */");
d532 1
a532 1
		indent_up ();
d534 1
a534 1
		indent_puts ("{");
d537 4
a540 4
			("if ( YY_G(yy_lp) && YY_G(yy_lp) < yy_accept[yy_current_state + 1] )");
		indent_up ();
		indent_puts ("{");
		indent_puts ("yy_act = yy_acclist[YY_G(yy_lp)];");
d544 4
a547 4
				("if ( yy_act & YY_TRAILING_HEAD_MASK ||");
			indent_puts ("     YY_G(yy_looking_for_trail_begin) )");
			indent_up ();
			indent_puts ("{");
d550 8
a557 8
				("if ( yy_act == YY_G(yy_looking_for_trail_begin) )");
			indent_up ();
			indent_puts ("{");
			indent_puts ("YY_G(yy_looking_for_trail_begin) = 0;");
			indent_puts ("yy_act &= ~YY_TRAILING_HEAD_MASK;");
			indent_puts ("break;");
			indent_puts ("}");
			indent_down ();
d559 2
a560 2
			indent_puts ("}");
			indent_down ();
d563 3
a565 3
				("else if ( yy_act & YY_TRAILING_MASK )");
			indent_up ();
			indent_puts ("{");
d567 1
a567 1
				("YY_G(yy_looking_for_trail_begin) = yy_act & ~YY_TRAILING_MASK;");
d569 1
a569 1
				("YY_G(yy_looking_for_trail_begin) |= YY_TRAILING_HEAD_MASK;");
d572 2
a573 1
				/* Remember matched text in case we back up
d577 1
a577 1
					("YY_G(yy_full_match) = yy_cp;");
d579 2
a580 2
					("YY_G(yy_full_state) = YY_G(yy_state_ptr);");
				indent_puts ("YY_G(yy_full_lp) = YY_G(yy_lp);");
d582 2
d585 16
a600 20
			indent_puts ("}");
			indent_down ();

			indent_puts ("else");
			indent_up ();
			indent_puts ("{");
			indent_puts ("YY_G(yy_full_match) = yy_cp;");
			indent_puts
				("YY_G(yy_full_state) = YY_G(yy_state_ptr);");
			indent_puts ("YY_G(yy_full_lp) = YY_G(yy_lp);");
			indent_puts ("break;");
			indent_puts ("}");
			indent_down ();

			indent_puts ("++YY_G(yy_lp);");
			indent_puts ("goto find_rule;");
		}

		else {
			/* Remember matched text in case we back up due to
d603 6
a608 6
			indent_up ();
			indent_puts ("{");
			indent_puts ("YY_G(yy_full_match) = yy_cp;");
			indent_puts ("break;");
			indent_puts ("}");
			indent_down ();
d611 2
a612 2
		indent_puts ("}");
		indent_down ();
d614 1
a614 1
		indent_puts ("--yy_cp;");
d616 2
a617 1
		/* We could consolidate the following two lines with those at
d621 2
a622 4
		indent_puts ("yy_current_state = *--YY_G(yy_state_ptr);");
		indent_puts ("YY_G(yy_lp) = yy_accept[yy_current_state];");

		indent_puts ("}");
d624 1
a624 2
		indent_down ();
	}
d626 3
a628 2
	else {			/* compressed */
		indent_puts ("yy_act = yy_accept[yy_current_state];");
d631 2
a632 1
			/* Do the guaranteed-needed backing up to figure out
d635 3
a637 3
			indent_puts ("if ( yy_act == 0 )");
			indent_up ();
			indent_puts ("{ /* have to back up */");
d639 1
a639 1
				("yy_cp = YY_G(yy_last_accepting_cpos);");
d641 1
a641 1
				("yy_current_state = YY_G(yy_last_accepting_state);");
d643 3
a645 3
				("yy_act = yy_accept[yy_current_state];");
			indent_puts ("}");
			indent_down ();
d654 2
a655 1
struct yytbl_data *mkftbl (void)
d658 1
a658 1
	int     end_of_buffer_action = num_rules + 1;
d662 2
a663 2
	tbl = (struct yytbl_data *) calloc (1, sizeof (struct yytbl_data));
	yytbl_data_init (tbl, YYTD_ID_ACCEPT);
d669 1
a669 1
		(flex_int32_t *) calloc (tbl->td_lolen, sizeof (flex_int32_t));
d679 2
a680 2
			fprintf (stderr, _("state # %d accepts: [%d]\n"),
				 i, anum);
d683 3
a685 3
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n",
		    long_align ? "flex_int32_t" : "flex_int16_t");
d692 2
a693 1
void genftbl ()
d696 1
a696 1
	int     end_of_buffer_action = num_rules + 1;
d698 2
a699 2
	out_str_dec (long_align ? get_int32_decl () : get_int16_decl (),
		     "yy_accept", lastdfa + 1);
d706 1
a706 1
		mkdata (anum);
d709 2
a710 2
			fprintf (stderr, _("state # %d accepts: [%d]\n"),
				 i, anum);
d713 1
a713 1
	dataend ();
d716 1
a716 1
		genecs ();
d718 2
a719 1
	/* Don't have to dump the actual full table entries - they were
d727 10
a736 8
void gen_next_compressed_state (char_map)
     char   *char_map;
{
	indent_put2s ("YY_CHAR yy_c = %s;", char_map);

	/* Save the backing-up info \before/ computing the next state
	 * because we always compute one more state than needed - we
	 * always proceed until we reach a jam state
d738 1
a738 1
	gen_backing_up ();
d741 4
a744 4
		("while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )");
	indent_up ();
	indent_puts ("{");
	indent_puts ("yy_current_state = (int) yy_def[yy_current_state];");
d747 6
a752 6
		/* We've arrange it so that templates are never chained
		 * to one another.  This means we can afford to make a
		 * very simple test to see if we need to convert to
		 * yy_c's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
d754 1
a754 1
		do_indent ();
d757 1
a757 1
		out_dec ("if ( yy_current_state >= %d )\n", lastdfa + 2);
d759 3
a761 3
		indent_up ();
		indent_puts ("yy_c = yy_meta[(unsigned int) yy_c];");
		indent_down ();
d763 2
a764 3

	indent_puts ("}");
	indent_down ();
d767 1
a767 1
		("yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];");
d773 2
a774 1
void gen_next_match ()
d776 2
a777 1
	/* NOTE - changes in here should be reflected in gen_next_state() and
d780 2
a781 2
	char   *char_map = useecs ?
		"yy_ec[YY_SC_TO_UI(*yy_cp)] " : "YY_SC_TO_UI(*yy_cp)";
d783 2
a784 2
	char   *char_map_2 = useecs ?
		"yy_ec[YY_SC_TO_UI(*++yy_cp)] " : "YY_SC_TO_UI(*++yy_cp)";
d789 2
a790 2
				("while ( (yy_current_state = yy_nxt[yy_current_state][ %s ]) > 0 )",
				 char_map);
d793 2
a794 2
				("while ( (yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN +  %s ]) > 0 )",
				 char_map);
d796 1
a796 1
		indent_up ();
d799 3
a801 3
			indent_puts ("{");
			gen_backing_up ();
			outc ('\n');
d803 1
a803 2

		indent_puts ("++yy_cp;");
d806 1
d808 1
a808 1
			indent_puts ("}");
d810 4
a813 8
		indent_down ();

		outc ('\n');
		indent_puts ("yy_current_state = -yy_current_state;");
	}

	else if (fullspd) {
		indent_puts ("{");
d815 3
a817 3
			("yyconst struct yy_trans_info *yy_trans_info;\n");
		indent_puts ("YY_CHAR yy_c;\n");
		indent_put2s ("for ( yy_c = %s;", char_map);
d819 3
a821 3
			("      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->");
		indent_puts ("yy_verify == yy_c;");
		indent_put2s ("      yy_c = %s )", char_map_2);
d823 1
a823 1
		indent_up ();
d826 1
a826 1
			indent_puts ("{");
d828 1
a828 1
		indent_puts ("yy_current_state += yy_trans_info->yy_nxt;");
d831 3
a833 3
			outc ('\n');
			gen_backing_up ();
			indent_puts ("}");
d835 4
d840 2
a841 3
		indent_down ();
		indent_puts ("}");
	}
d843 1
a843 2
	else {			/* compressed */
		indent_puts ("do");
d845 1
a845 2
		indent_up ();
		indent_puts ("{");
a846 1
		gen_next_state (false);
d848 2
a849 1
		indent_puts ("++yy_cp;");
d851 1
a851 5

		indent_puts ("}");
		indent_down ();

		do_indent ();
d854 1
a854 1
			out_dec ("while ( yy_base[yy_current_state] != %d );\n", jambase);
d856 2
a857 2
			out_dec ("while ( yy_current_state != %d );\n",
				 jamstate);
d860 2
a861 1
			/* Do the guaranteed-needed backing up to figure out
d865 1
a865 1
				("yy_cp = YY_G(yy_last_accepting_cpos);");
d867 1
a867 1
				("yy_current_state = YY_G(yy_last_accepting_state);");
d875 6
a880 4
void gen_next_state (worry_about_NULs)
     int worry_about_NULs;
{				/* NOTE - changes in here should be reflected in gen_next_match() */
	char    char_map[256];
d884 3
a886 3
			snprintf (char_map, sizeof(char_map),
					"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
					NUL_ec);
d888 7
a894 9
            snprintf (char_map, sizeof(char_map),
					"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)",
					NUL_ec);
	}

	else
		strlcpy (char_map, useecs ?
				"yy_ec[YY_SC_TO_UI(*yy_cp)] " : "YY_SC_TO_UI(*yy_cp)",
				sizeof char_map );
d899 1
a899 1
			gen_backing_up ();
d901 3
a903 3
		indent_puts ("if ( *yy_cp )");
		indent_up ();
		indent_puts ("{");
a904 1

d908 2
a909 2
				("yy_current_state = yy_nxt[yy_current_state][%s];",
				 char_map);
d912 3
a914 5
				("yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %s];",
				 char_map);
	}

	else if (fullspd)
d916 2
a917 2
			("yy_current_state += yy_current_state[%s].yy_nxt;",
			 char_map);
d920 1
a920 1
		gen_next_compressed_state (char_map);
d924 4
a927 4
		indent_puts ("}");
		indent_down ();
		indent_puts ("else");
		indent_up ();
d929 2
a930 2
			("yy_current_state = yy_NUL_trans[yy_current_state];");
		indent_down ();
a931 1

d933 1
a933 1
		gen_backing_up ();
d936 1
a936 1
		indent_puts ("*YY_G(yy_state_ptr)++ = yy_current_state;");
d942 7
a948 4
void gen_NUL_trans ()
{				/* NOTE - changes in here should be reflected in gen_next_match() */
	/* Only generate a definition for "yy_cp" if we'll generate code
	 * that uses it.  Otherwise lint and the like complain.
d950 1
a950 1
	int     need_backing_up = (num_backing_up > 0 && !reject);
d953 3
a955 2
		/* We're going to need yy_cp lying around for the call
		 * below to gen_backing_up().
d957 1
a957 1
		indent_puts ("char *yy_cp = YY_G(yy_c_buf_p);");
d959 1
a959 1
	outc ('\n');
d963 4
a966 6
			("yy_current_state = yy_NUL_trans[yy_current_state];");
		indent_puts ("yy_is_jam = (yy_current_state == 0);");
	}

	else if (fulltbl) {
		do_indent ();
d968 1
a968 1
			out_dec ("yy_current_state = yy_nxt[yy_current_state][%d];\n", NUL_ec);
d970 5
a974 7
			out_dec ("yy_current_state = yy_nxt[yy_current_state*YY_NXT_LOLEN + %d];\n", NUL_ec);
		indent_puts ("yy_is_jam = (yy_current_state <= 0);");
	}

	else if (fullspd) {
		do_indent ();
		out_dec ("int yy_c = %d;\n", NUL_ec);
d977 1
a977 1
			("yyconst struct yy_trans_info *yy_trans_info;\n");
d979 2
a980 2
			("yy_trans_info = &yy_current_state[(unsigned int) yy_c];");
		indent_puts ("yy_current_state += yy_trans_info->yy_nxt;");
d983 10
a992 12
			("yy_is_jam = (yy_trans_info->yy_verify != yy_c);");
	}

	else {
		char    NUL_ec_str[20];

		snprintf (NUL_ec_str, sizeof(NUL_ec_str), "%d", NUL_ec);
		gen_next_compressed_state (NUL_ec_str);

		do_indent ();
		out_dec ("yy_is_jam = (yy_current_state == %d);\n",
			 jamstate);
d995 4
a998 3
			/* Only stack this state if it's a transition we
			 * actually make.  If we stack it on a jam, then
			 * the state stack and yy_c_buf_p get out of sync.
d1000 2
a1001 2
			indent_puts ("if ( ! yy_is_jam )");
			indent_up ();
d1003 2
a1004 2
				("*YY_G(yy_state_ptr)++ = yy_current_state;");
			indent_down ();
d1008 4
a1011 3
	/* If we've entered an accepting state, back up; note that
	 * compressed tables have *already* done such backing up, so
	 * we needn't bother with it again.
d1014 7
a1020 7
		outc ('\n');
		indent_puts ("if ( ! yy_is_jam )");
		indent_up ();
		indent_puts ("{");
		gen_backing_up ();
		indent_puts ("}");
		indent_down ();
d1027 2
a1028 1
void gen_start_state ()
d1033 2
a1034 3
				("yy_current_state = yy_start_state_list[YY_G(yy_start) + YY_AT_BOL()];");
		}
		else
d1036 3
a1038 5
				("yy_current_state = yy_start_state_list[YY_G(yy_start)];");
	}

	else {
		indent_puts ("yy_current_state = YY_G(yy_start);");
d1041 1
a1041 1
			indent_puts ("yy_current_state += YY_AT_BOL();");
d1045 1
a1045 1
			outn ("m4_ifdef( [[M4_YY_USES_REJECT]],\n[[");
d1047 1
a1047 1
				("YY_G(yy_state_ptr) = YY_G(yy_state_buf);");
d1049 2
a1050 2
				("*YY_G(yy_state_ptr)++ = yy_current_state;");
			outn ("]])");
d1058 2
a1059 1
void gentabs ()
d1061 7
a1067 7
	int     i, j, k, *accset, nacc, *acc_array, total_states;
	int     end_of_buffer_action = num_rules + 1;
	struct yytbl_data *yyacc_tbl = 0, *yymeta_tbl = 0, *yybase_tbl = 0,
		*yydef_tbl = 0, *yynxt_tbl = 0, *yychk_tbl = 0, *yyacclist_tbl=0;
	flex_int32_t *yyacc_data = 0, *yybase_data = 0, *yydef_data = 0,
		*yynxt_data = 0, *yychk_data = 0, *yyacclist_data=0;
	flex_int32_t yybase_curr = 0, yyacclist_curr=0,yyacc_curr=0;
d1069 1
a1069 1
	acc_array = allocate_integer_array (current_max_dfas);
d1072 5
a1076 4
	/* The compressed table format jams by entering the "jam state",
	 * losing information about the previous state in the process.
	 * In order to recover the previous state, we effectively need
	 * to keep backing-up information.
d1081 5
a1085 4
		/* Write out accepting list and pointer list.

		 * First we generate the "yy_acclist" array.  In the process,
		 * we compute the indices that will go into the "yy_accept"
d1088 1
a1088 1
		int     EOB_accepting_list[2];
d1095 1
a1095 1
			EOB_accepting_list;
d1097 14
a1110 14
		out_str_dec (long_align ? get_int32_decl () :
			     get_int16_decl (), "yy_acclist", MAX (numas,
								   1) + 1);
        
        buf_prints (&yydmap_buf,
                "\t{YYTD_ID_ACCLIST, (void**)&yy_acclist, sizeof(%s)},\n",
                long_align ? "flex_int32_t" : "flex_int16_t");

        yyacclist_tbl = (struct yytbl_data*)calloc(1,sizeof(struct yytbl_data));
        yytbl_data_init (yyacclist_tbl, YYTD_ID_ACCLIST);
        yyacclist_tbl->td_lolen  = MAX(numas,1) + 1;
        yyacclist_tbl->td_data = yyacclist_data = 
            (flex_int32_t *) calloc (yyacclist_tbl->td_lolen, sizeof (flex_int32_t));
        yyacclist_curr = 1;
d1122 3
a1124 3
					fprintf (stderr,
						 _("state # %d accepts: "),
						 i);
d1127 1
a1127 1
					int     accnum = accset[k];
d1133 1
a1133 1
						 YY_TRAILING_HEAD_MASK)
d1138 2
a1139 1
						/* Special hack to flag
d1145 2
a1146 3

					mkdata (accnum);
                    yyacclist_data[yyacclist_curr++] = accnum;
d1149 2
a1150 2
						fprintf (stderr, "[%d]",
							 accset[k]);
d1153 2
a1154 2
							fputs (", ",
							       stderr);
d1156 2
a1157 2
							putc ('\n',
							      stderr);
d1166 9
a1174 11
		dataend ();
        if (tablesext) {
            yytbl_data_compress (yyacclist_tbl);
            if (yytbl_data_fwrite (&tableswr, yyacclist_tbl) < 0)
                flexerror (_("Could not write yyacclist_tbl"));
            yytbl_data_destroy (yyacclist_tbl);
            yyacclist_tbl = NULL;
        }
	}

	else {
d1176 1
a1176 1
			end_of_buffer_action;
d1187 2
a1188 1
	/* Spit out "yy_accept" array.  If we're doing "reject", it'll be
d1193 3
a1195 2
	/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays
	 * beginning at 0 and for "jam" state.
d1200 5
a1204 4
		/* We put a "cap" on the table associating lists of accepting
		 * numbers with state numbers.  This is needed because we tell
		 * where the end of an accepting list is by looking at where
		 * the list for the next state starts.
d1208 2
a1209 2
	out_str_dec (long_align ? get_int32_decl () : get_int16_decl (),
		     "yy_accept", k);
d1211 3
a1213 3
	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_ACCEPT, (void**)&yy_accept, sizeof(%s)},\n",
		    long_align ? "flex_int32_t" : "flex_int16_t");
d1216 3
a1218 3
		(struct yytbl_data *) calloc (1,
					      sizeof (struct yytbl_data));
	yytbl_data_init (yyacc_tbl, YYTD_ID_ACCEPT);
d1221 2
a1222 2
		(flex_int32_t *) calloc (yyacc_tbl->td_lolen, sizeof (flex_int32_t));
    yyacc_curr=1;
d1225 1
a1225 1
		mkdata (acc_array[i]);
d1229 2
a1230 2
			fprintf (stderr, _("state # %d accepts: [%d]\n"),
				 i, acc_array[i]);
d1234 1
a1234 1
	mkdata (acc_array[i]);
d1239 1
a1239 1
		mkdata (acc_array[i]);
d1242 1
a1242 2

	dataend ();
d1244 4
a1247 4
		yytbl_data_compress (yyacc_tbl);
		if (yytbl_data_fwrite (&tableswr, yyacc_tbl) < 0)
			flexerror (_("Could not write yyacc_tbl"));
		yytbl_data_destroy (yyacc_tbl);
d1254 1
a1254 1
		genecs ();
d1258 5
a1262 5
			tbl = mkecstbl ();
			yytbl_data_compress (tbl);
			if (yytbl_data_fwrite (&tableswr, tbl) < 0)
				flexerror (_("Could not write ecstbl"));
			yytbl_data_destroy (tbl);
a1265 1

d1268 2
a1269 1
		/* Write out meta-equivalence classes (used to index
d1274 4
a1277 4
			(struct yytbl_data *) calloc (1,
						      sizeof (struct
							      yytbl_data));
		yytbl_data_init (yymeta_tbl, YYTD_ID_META);
d1280 2
a1281 2
			(flex_int32_t *) calloc (yymeta_tbl->td_lolen,
					    sizeof (flex_int32_t));
d1284 2
a1285 2
			fputs (_("\n\nMeta-Equivalence Classes:\n"),
			       stderr);
d1287 4
a1290 4
		out_str_dec (get_int32_decl (), "yy_meta", numecs + 1);
		buf_prints (&yydmap_buf,
			    "\t{YYTD_ID_META, (void**)&yy_meta, sizeof(%s)},\n",
			    "flex_int32_t");
d1294 2
a1295 2
				fprintf (stderr, "%d = %d\n",
					 i, ABS (tecbck[i]));
d1297 2
a1298 2
			mkdata (ABS (tecbck[i]));
			yymecs_data[i] = ABS (tecbck[i]);
d1301 1
a1301 1
		dataend ();
d1303 5
a1307 5
			yytbl_data_compress (yymeta_tbl);
			if (yytbl_data_fwrite (&tableswr, yymeta_tbl) < 0)
				flexerror (_
					   ("Could not write yymeta_tbl"));
			yytbl_data_destroy (yymeta_tbl);
a1311 1

d1315 8
a1322 8
	out_str_dec ((tblend >= INT16_MAX || long_align) ?
		     get_int32_decl () : get_int16_decl (),
		     "yy_base", total_states + 1);

	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_BASE, (void**)&yy_base, sizeof(%s)},\n",
		    (tblend >= INT16_MAX
		     || long_align) ? "flex_int32_t" : "flex_int16_t");
d1324 3
a1326 3
		(struct yytbl_data *) calloc (1,
					      sizeof (struct yytbl_data));
	yytbl_data_init (yybase_tbl, YYTD_ID_BASE);
d1329 2
a1330 2
		(flex_int32_t *) calloc (yybase_tbl->td_lolen,
				    sizeof (flex_int32_t));
d1347 1
a1347 2

		mkdata (base[i]);
d1352 1
a1352 1
	mkdata (base[i]);
d1356 1
a1356 1
		mkdata (base[i]);
d1361 1
a1361 1
	dataend ();
d1363 4
a1366 4
		yytbl_data_compress (yybase_tbl);
		if (yytbl_data_fwrite (&tableswr, yybase_tbl) < 0)
			flexerror (_("Could not write yybase_tbl"));
		yytbl_data_destroy (yybase_tbl);
d1373 8
a1380 8
	out_str_dec ((total_states >= INT16_MAX || long_align) ?
		     get_int32_decl () : get_int16_decl (),
		     "yy_def", total_states + 1);

	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_DEF, (void**)&yy_def, sizeof(%s)},\n",
		    (total_states >= INT16_MAX
		     || long_align) ? "flex_int32_t" : "flex_int16_t");
d1383 3
a1385 3
		(struct yytbl_data *) calloc (1,
					      sizeof (struct yytbl_data));
	yytbl_data_init (yydef_tbl, YYTD_ID_DEF);
d1388 1
a1388 1
		(flex_int32_t *) calloc (yydef_tbl->td_lolen, sizeof (flex_int32_t));
d1391 1
a1391 1
		mkdata (def[i]);
d1395 1
a1395 1
	dataend ();
d1397 4
a1400 4
		yytbl_data_compress (yydef_tbl);
		if (yytbl_data_fwrite (&tableswr, yydef_tbl) < 0)
			flexerror (_("Could not write yydef_tbl"));
		yytbl_data_destroy (yydef_tbl);
d1407 8
a1414 8
	out_str_dec ((total_states >= INT16_MAX || long_align) ?
		     get_int32_decl () : get_int16_decl (), "yy_nxt",
		     tblend + 1);

	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_NXT, (void**)&yy_nxt, sizeof(%s)},\n",
		    (total_states >= INT16_MAX
		     || long_align) ? "flex_int32_t" : "flex_int16_t");
d1417 3
a1419 3
		(struct yytbl_data *) calloc (1,
					      sizeof (struct yytbl_data));
	yytbl_data_init (yynxt_tbl, YYTD_ID_NXT);
d1422 1
a1422 1
		(flex_int32_t *) calloc (yynxt_tbl->td_lolen, sizeof (flex_int32_t));
d1425 3
a1427 2
		/* Note, the order of the following test is important.
		 * If chk[i] is 0, then nxt[i] is undefined.
d1432 1
a1432 1
		mkdata (nxt[i]);
d1436 1
a1436 1
	dataend ();
d1438 4
a1441 4
		yytbl_data_compress (yynxt_tbl);
		if (yytbl_data_fwrite (&tableswr, yynxt_tbl) < 0)
			flexerror (_("Could not write yynxt_tbl"));
		yytbl_data_destroy (yynxt_tbl);
d1447 8
a1454 8
	out_str_dec ((total_states >= INT16_MAX || long_align) ?
		     get_int32_decl () : get_int16_decl (), "yy_chk",
		     tblend + 1);

	buf_prints (&yydmap_buf,
		    "\t{YYTD_ID_CHK, (void**)&yy_chk, sizeof(%s)},\n",
		    (total_states >= INT16_MAX
		     || long_align) ? "flex_int32_t" : "flex_int16_t");
d1457 3
a1459 3
		(struct yytbl_data *) calloc (1,
					      sizeof (struct yytbl_data));
	yytbl_data_init (yychk_tbl, YYTD_ID_CHK);
d1462 1
a1462 1
		(flex_int32_t *) calloc (yychk_tbl->td_lolen, sizeof (flex_int32_t));
d1468 1
a1468 1
		mkdata (chk[i]);
d1472 1
a1472 1
	dataend ();
d1474 4
a1477 4
		yytbl_data_compress (yychk_tbl);
		if (yytbl_data_fwrite (&tableswr, yychk_tbl) < 0)
			flexerror (_("Could not write yychk_tbl"));
		yytbl_data_destroy (yychk_tbl);
d1482 1
a1482 1
	flex_free ((void *) acc_array);
d1490 7
a1496 6
void indent_put2s (fmt, arg)
     const char *fmt, *arg;
{
	do_indent ();
	out_str (fmt, arg);
	outn ("");
d1504 3
a1506 2
void indent_puts (str)
     const char *str;
d1508 2
a1509 2
	do_indent ();
	outn (str);
d1516 2
a1517 1
void make_tables ()
d1520 1
a1520 1
	int     did_eof_rule = false;
d1524 1
a1524 1
	skelout ();		/* %% [2.0] - break point in skel */
d1526 3
a1528 2
	/* First, take care of YY_DO_BEFORE_ACTION depending on yymore
	 * being used.
d1530 1
a1530 1
	set_indent (1);
d1533 1
a1533 1
		indent_puts ("YY_G(yytext_ptr) -= YY_G(yy_more_len); \\");
d1535 3
a1537 5
			("yyleng = (size_t) (yy_cp - YY_G(yytext_ptr)); \\");
	}

	else
		indent_puts ("yyleng = (size_t) (yy_cp - yy_bp); \\");
d1540 1
a1540 1
	skelout ();		/* %% [3.0] - break point in skel */
d1544 1
a1544 1
				("if ( yyleng + YY_G(yy_more_offset) >= YYLMAX ) \\");
d1546 1
a1546 1
			indent_puts ("if ( yyleng >= YYLMAX ) \\");
d1548 1
a1548 1
		indent_up ();
d1550 2
a1551 2
			("YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\");
		indent_down ();
d1555 2
a1556 2
				("yy_flex_strncpy( &yytext[YY_G(yy_more_offset)], YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\");
			indent_puts ("yyleng += YY_G(yy_more_offset); \\");
d1558 3
a1560 4
				("YY_G(yy_prev_more_offset) = YY_G(yy_more_offset); \\");
			indent_puts ("YY_G(yy_more_offset) = 0; \\");
		}
		else {
d1562 1
a1562 1
				("yy_flex_strncpy( yytext, YY_G(yytext_ptr), yyleng + 1 M4_YY_CALL_LAST_ARG); \\");
d1565 1
d1567 1
a1567 3
	set_indent (0);

	skelout ();		/* %% [4.0] - break point in skel */
d1572 2
a1573 2
	out_dec ("#define YY_NUM_RULES %d\n", num_rules);
	out_dec ("#define YY_END_OF_BUFFER %d\n", num_rules + 1);
d1576 17
a1592 2
		/* Need to define the transet type as a size large
		 * enough to hold the biggest offset.
d1594 1
a1594 9
		int     total_table_size = tblend + numecs + 1;
		char   *trans_offset_type =
			(total_table_size >= INT16_MAX || long_align) ?
			"flex_int32_t" : "flex_int16_t";

		set_indent (0);
		indent_puts ("struct yy_trans_info");
		indent_up ();
		indent_puts ("{");
d1596 2
a1597 4
		/* We require that yy_verify and yy_nxt must be of the same size int. */
		indent_put2s ("%s yy_verify;", trans_offset_type);

		/* In cases where its sister yy_verify *is* a "yes, there is
d1601 2
a1602 2
		 * record of a state, though, then yy_nxt is the action number
		 * for that state.
d1605 9
a1613 9
		indent_put2s ("%s yy_nxt;", trans_offset_type);
		indent_puts ("};");
		indent_down ();
	}
	else {
		/* We generate a bogus 'struct yy_trans_info' data type
		 * so we can guarantee that it is always declared in the skel.
		 * This is so we can compile "sizeof(struct yy_trans_info)"
		 * in any scanner.
d1616 9
a1624 9
			("/* This struct is not used in this scanner,");
		indent_puts ("   but its presence is necessary. */");
		indent_puts ("struct yy_trans_info");
		indent_up ();
		indent_puts ("{");
		indent_puts ("flex_int32_t yy_verify;");
		indent_puts ("flex_int32_t yy_nxt;");
		indent_puts ("};");
		indent_down ();
d1628 1
a1628 1
		genctbl ();
d1632 11
a1642 11
			tbl = mkctbl ();
			yytbl_data_compress (tbl);
			if (yytbl_data_fwrite (&tableswr, tbl) < 0)
				flexerror (_("Could not write ftbl"));
			yytbl_data_destroy (tbl);

			tbl = mkssltbl ();
			yytbl_data_compress (tbl);
			if (yytbl_data_fwrite (&tableswr, tbl) < 0)
				flexerror (_("Could not write ssltbl"));
			yytbl_data_destroy (tbl);
d1646 6
a1651 6
				tbl = mkecstbl ();
				yytbl_data_compress (tbl);
				if (yytbl_data_fwrite (&tableswr, tbl) < 0)
					flexerror (_
						   ("Could not write ecstbl"));
				yytbl_data_destroy (tbl);
d1655 2
a1656 3
	}
	else if (fulltbl) {
		genftbl ();
d1660 5
a1664 5
			tbl = mkftbl ();
			yytbl_data_compress (tbl);
			if (yytbl_data_fwrite (&tableswr, tbl) < 0)
				flexerror (_("Could not write ftbl"));
			yytbl_data_destroy (tbl);
d1668 6
a1673 6
				tbl = mkecstbl ();
				yytbl_data_compress (tbl);
				if (yytbl_data_fwrite (&tableswr, tbl) < 0)
					flexerror (_
						   ("Could not write ecstbl"));
				yytbl_data_destroy (tbl);
d1677 2
a1678 3
	}
	else
		gentabs ();
d1682 1
a1682 1
		geneoltbl ();
d1687 5
a1691 5
			tbl = mkeoltbl ();
			yytbl_data_compress (tbl);
			if (yytbl_data_fwrite (&tableswr, tbl) < 0)
				flexerror (_("Could not write eoltbl"));
			yytbl_data_destroy (tbl);
d1695 4
a1698 4

	/* Definitions for backing up.  We don't need them if REJECT
	 * is being used because then we use an alternative backin-up
	 * technique instead.
d1703 1
a1703 1
				("static yy_state_type yy_last_accepting_state;");
d1705 1
a1705 1
				("static char *yy_last_accepting_cpos;\n");
a1707 1

d1712 6
a1717 6
		out_str_dec (get_state_decl (), "yy_NUL_trans",
			     lastdfa + 1);
		buf_prints (&yydmap_buf,
			    "\t{YYTD_ID_NUL_TRANS, (void**)&yy_NUL_trans, sizeof(%s)},\n",
			    (fullspd) ? "struct yy_trans_info*" :
			    "flex_int32_t");
d1720 4
a1723 4
			(struct yytbl_data *) calloc (1,
						      sizeof (struct
							      yytbl_data));
		yytbl_data_init (yynultrans_tbl, YYTD_ID_NUL_TRANS);
d1728 2
a1729 2
			(flex_int32_t *) calloc (yynultrans_tbl->td_lolen,
					    sizeof (flex_int32_t));
d1733 2
a1734 2
				out_dec ("    &yy_transition[%d],\n",
					 base[i]);
d1736 2
a1737 3
			}
			else {
				mkdata (nultrans[i]);
d1742 1
a1742 1
		dataend ();
d1744 2
a1745 2
			yytbl_data_compress (yynultrans_tbl);
			if (yytbl_data_fwrite (&tableswr, yynultrans_tbl) <
d1747 3
a1749 3
				flexerror (_
					   ("Could not write yynultrans_tbl"));
			yytbl_data_destroy (yynultrans_tbl);
a1753 1

d1755 9
a1763 9
		indent_puts ("extern int yy_flex_debug;");
		indent_put2s ("int yy_flex_debug = %s;\n",
			      ddebug ? "1" : "0");
	}

	if (ddebug) {		/* Spit out table mapping rules to line numbers. */
		out_str_dec (long_align ? get_int32_decl () :
			     get_int16_decl (), "yy_rule_linenum",
			     num_rules);
d1765 2
a1766 2
			mkdata (rule_linenum[i]);
		dataend ();
a1767 1

d1769 1
a1769 1
		outn ("m4_ifdef( [[M4_YY_USES_REJECT]],\n[[");
d1772 3
a1774 3
			outn ("static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;");
			outn ("static char *yy_full_match;");
			outn ("static int yy_lp;");
a1775 1

d1778 3
a1780 3
				outn ("static int yy_looking_for_trail_begin = 0;");
				outn ("static int yy_full_lp;");
				outn ("static int *yy_full_state;");
d1782 9
a1790 11

			out_hex ("#define YY_TRAILING_MASK 0x%x\n",
				 (unsigned int) YY_TRAILING_MASK);
			out_hex ("#define YY_TRAILING_HEAD_MASK 0x%x\n",
				 (unsigned int) YY_TRAILING_HEAD_MASK);
		}

		outn ("#define REJECT \\");
		outn ("{ \\");
		outn ("*yy_cp = YY_G(yy_hold_char); /* undo effects of setting up yytext */ \\");
		outn ("yy_cp = YY_G(yy_full_match); /* restore poss. backed-over text */ \\");
d1793 14
a1806 17
			outn ("YY_G(yy_lp) = YY_G(yy_full_lp); /* restore orig. accepting pos. */ \\");
			outn ("YY_G(yy_state_ptr) = YY_G(yy_full_state); /* restore orig. state */ \\");
			outn ("yy_current_state = *YY_G(yy_state_ptr); /* restore curr. state */ \\");
		}

		outn ("++YY_G(yy_lp); \\");
		outn ("goto find_rule; \\");

		outn ("}");
		outn ("]])\n");
	}

	else {
		outn ("/* The intent behind this definition is that it'll catch");
		outn (" * any uses of REJECT which flex missed.");
		outn (" */");
		outn ("#define REJECT reject_used_but_not_detected");
d1812 5
a1816 6
				if (!reentrant){
    				indent_puts ("static int yy_more_offset = 0;");
                    indent_puts ("static int yy_prev_more_offset = 0;");
                }
			}
			else if (!reentrant) {
d1818 1
a1818 1
					("static int yy_more_flag = 0;");
d1820 1
a1820 1
					("static int yy_more_len = 0;");
a1822 1

d1825 13
a1837 3
				("#define yymore() (YY_G(yy_more_offset) = yy_flex_strlen( yytext M4_YY_CALL_LAST_ARG))");
			indent_puts ("#define YY_NEED_STRLEN");
			indent_puts ("#define YY_MORE_ADJ 0");
d1839 1
a1839 3
				("#define YY_RESTORE_YY_MORE_OFFSET \\");
			indent_up ();
			indent_puts ("{ \\");
d1841 2
a1842 4
				("YY_G(yy_more_offset) = YY_G(yy_prev_more_offset); \\");
			indent_puts ("yyleng -= YY_G(yy_more_offset); \\");
			indent_puts ("}");
			indent_down ();
d1844 1
a1844 10
		else {
			indent_puts
				("#define yymore() (YY_G(yy_more_flag) = 1)");
			indent_puts
				("#define YY_MORE_ADJ YY_G(yy_more_len)");
			indent_puts ("#define YY_RESTORE_YY_MORE_OFFSET");
		}
	}

	else {
d1846 3
a1848 3
			("#define yymore() yymore_used_but_not_detected");
		indent_puts ("#define YY_MORE_ADJ 0");
		indent_puts ("#define YY_RESTORE_YY_MORE_OFFSET");
d1853 10
a1862 12
			outn ("#ifndef YYLMAX");
			outn ("#define YYLMAX 8192");
			outn ("#endif\n");
			if (!reentrant){
                outn ("char yytext[YYLMAX];");
                outn ("char *yytext_ptr;");
            }
		}

		else {
			if(! reentrant)
                outn ("char *yytext;");
d1865 1
d1867 1
a1867 1
	out (&action_array[defs1_offset]);
d1869 1
a1869 3
	line_directive_out (stdout, 0);

	skelout ();		/* %% [5.0] - break point in skel */
d1873 39
a1911 41
			outn ("\terrno=0; \\");
			outn ("\twhile ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\");
			outn ("\t{ \\");
			outn ("\t\tif( errno != EINTR) \\");
			outn ("\t\t{ \\");
			outn ("\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn ("\t\t\tbreak; \\");
			outn ("\t\t} \\");
			outn ("\t\terrno=0; \\");
			outn ("\t\tclearerr(yyin); \\");
			outn ("\t}\\");
		}

		else {
			outn ("\tif ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \\");
			outn ("\t\t{ \\");
			outn ("\t\tint c = '*'; \\");
			outn ("\t\tsize_t n; \\");
			outn ("\t\tfor ( n = 0; n < max_size && \\");
			outn ("\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\");
			outn ("\t\t\tbuf[n] = (char) c; \\");
			outn ("\t\tif ( c == '\\n' ) \\");
			outn ("\t\t\tbuf[n++] = (char) c; \\");
			outn ("\t\tif ( c == EOF && ferror( yyin ) ) \\");
			outn ("\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn ("\t\tresult = n; \\");
			outn ("\t\t} \\");
			outn ("\telse \\");
			outn ("\t\t{ \\");
			outn ("\t\terrno=0; \\");
			outn ("\t\twhile ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \\");
			outn ("\t\t\t{ \\");
			outn ("\t\t\tif( errno != EINTR) \\");
			outn ("\t\t\t\t{ \\");
			outn ("\t\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\");
			outn ("\t\t\t\tbreak; \\");
			outn ("\t\t\t\t} \\");
			outn ("\t\t\terrno=0; \\");
			outn ("\t\t\tclearerr(yyin); \\");
			outn ("\t\t\t} \\");
			outn ("\t\t}\\");
d1914 1
d1916 2
a1917 4
	skelout ();		/* %% [6.0] - break point in skel */

	indent_puts ("#define YY_RULE_SETUP \\");
	indent_up ();
d1919 5
a1923 5
		indent_puts ("if ( yyleng > 0 ) \\");
		indent_up ();
		indent_puts ("YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \\");
		indent_puts ("\t\t(yytext[yyleng - 1] == '\\n'); \\");
		indent_down ();
d1925 2
a1926 2
	indent_puts ("YY_USER_ACTION");
	indent_down ();
d1928 1
a1928 1
	skelout ();		/* %% [7.0] - break point in skel */
d1931 1
a1931 1
	out (&action_array[prolog_offset]);
d1933 1
a1933 1
	line_directive_out (stdout, 0);
d1935 1
a1935 1
	skelout ();		/* %% [8.0] - break point in skel */
d1937 1
a1937 1
	set_indent (2);
d1940 4
a1943 4
		indent_puts ("YY_G(yy_more_len) = 0;");
		indent_puts ("if ( YY_G(yy_more_flag) )");
		indent_up ();
		indent_puts ("{");
d1945 4
a1948 4
			("YY_G(yy_more_len) = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);");
		indent_puts ("YY_G(yy_more_flag) = 0;");
		indent_puts ("}");
		indent_down ();
d1950 1
d1952 1
a1952 3
	skelout ();		/* %% [9.0] - break point in skel */

	gen_start_state ();
d1955 2
a1956 2
	outn ("yy_match:");
	gen_next_match ();
d1958 3
a1960 3
	skelout ();		/* %% [10.0] - break point in skel */
	set_indent (2);
	gen_find_action ();
d1962 2
a1963 2
	skelout ();		/* %% [11.0] - break point in skel */
	outn ("m4_ifdef( [[M4_YY_USE_LINENO]],[[");
d1965 17
a1981 17
		("if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )");
	indent_up ();
	indent_puts ("{");
	indent_puts ("yy_size_t yyl;");
	do_indent ();
	out_str ("for ( yyl = %s; yyl < yyleng; ++yyl )\n",
		 yymore_used ? (yytext_is_array ? "YY_G(yy_prev_more_offset)" :
				"YY_G(yy_more_len)") : "0");
	indent_up ();
	indent_puts ("if ( yytext[yyl] == '\\n' )");
	indent_up ();
	indent_puts ("M4_YY_INCR_LINENO();");
	indent_down ();
	indent_down ();
	indent_puts ("}");
	indent_down ();
	outn ("]])");
d1983 1
a1983 1
	skelout ();		/* %% [12.0] - break point in skel */
d1985 2
a1986 2
		indent_puts ("if ( yy_flex_debug )");
		indent_up ();
d1988 11
a1998 11
		indent_puts ("{");
		indent_puts ("if ( yy_act == 0 )");
		indent_up ();
		indent_puts (C_plus_plus ?
			     "std::cerr << \"--scanner backing up\\n\";" :
			     "fprintf( stderr, \"--scanner backing up\\n\" );");
		indent_down ();

		do_indent ();
		out_dec ("else if ( yy_act < %d )\n", num_rules);
		indent_up ();
d2002 1
a2002 1
				("std::cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<");
d2004 2
a2005 3
				("         \"(\\\"\" << yytext << \"\\\")\\n\";");
		}
		else {
d2007 1
a2007 1
				("fprintf( stderr, \"--accepting rule at line %ld (\\\"%s\\\")\\n\",");
d2010 1
a2010 1
				("         (long)yy_rule_linenum[yy_act], yytext );");
d2013 1
a2013 1
		indent_down ();
d2015 3
a2017 3
		do_indent ();
		out_dec ("else if ( yy_act == %d )\n", num_rules);
		indent_up ();
d2021 2
a2022 3
				("std::cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";");
		}
		else {
d2024 2
a2025 2
				("fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\",");
			indent_puts ("         yytext );");
d2028 1
a2028 1
		indent_down ();
d2030 3
a2032 3
		do_indent ();
		out_dec ("else if ( yy_act == %d )\n", num_rules + 1);
		indent_up ();
d2034 3
a2036 3
		indent_puts (C_plus_plus ?
			     "std::cerr << \"--(end of buffer or a NUL)\\n\";" :
			     "fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );");
d2038 1
a2038 1
		indent_down ();
d2040 3
a2042 3
		do_indent ();
		outn ("else");
		indent_up ();
d2046 2
a2047 3
				("std::cerr << \"--EOF (start condition \" << YY_START << \")\\n\";");
		}
		else {
d2049 1
a2049 1
				("fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );");
d2052 1
a2052 1
		indent_down ();
d2054 2
a2055 2
		indent_puts ("}");
		indent_down ();
a2056 1

d2058 4
a2061 4
	skelout ();		/* %% [13.0] - break point in skel */
	indent_up ();
	gen_bu_action ();
	out (&action_array[action_offset]);
d2063 1
a2063 1
	line_directive_out (stdout, 0);
d2068 2
a2069 2
			do_indent ();
			out_str ("case YY_STATE_EOF(%s):\n", scname[i]);
a2071 1

d2073 3
a2075 3
		indent_up ();
		indent_puts ("yyterminate();");
		indent_down ();
a2076 2


d2079 2
a2080 1
	/* First, deal with backing up and setting up yy_cp if the scanner
d2083 2
a2084 2
	skelout ();		/* %% [14.0] - break point in skel */
	set_indent (4);
d2087 1
a2087 1
		indent_puts ("yy_cp = YY_G(yy_c_buf_p);");
d2091 3
a2093 2
			/* Do the guaranteed-needed backing up to figure
			 * out the match.
d2096 1
a2096 1
				("yy_cp = YY_G(yy_last_accepting_cpos);");
d2098 4
a2101 5
				("yy_current_state = YY_G(yy_last_accepting_state);");
		}

		else
			/* Still need to initialize yy_cp, though
d2105 1
a2105 1
			indent_puts ("yy_cp = YY_G(yy_c_buf_p);");
d2110 2
a2111 2
	set_indent (1);
	skelout ();		/* %% [15.0] - break point in skel */
d2113 1
a2113 1
	gen_start_state ();
d2115 3
a2117 3
	set_indent (2);
	skelout ();		/* %% [16.0] - break point in skel */
	gen_next_state (true);
d2119 3
a2121 3
	set_indent (1);
	skelout ();		/* %% [17.0] - break point in skel */
	gen_NUL_trans ();
d2123 2
a2124 2
	skelout ();		/* %% [18.0] - break point in skel */
	skelout ();		/* %% [19.0] - break point in skel */
d2128 1
a2128 1
			("YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\\n');");
d2131 10
a2140 5
				("if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )");
			indent_up ();
			indent_puts ("M4_YY_INCR_LINENO();");
			indent_down ();
		}
d2142 1
a2142 9

	else if (do_yylineno) {
		indent_puts ("if ( c == '\\n' )");
		indent_up ();
		indent_puts ("M4_YY_INCR_LINENO();");
		indent_down ();
	}

	skelout ();
d2146 1
a2146 1
	line_directive_out (stdout, 1);
d2149 3
a2151 3
		OUT_BEGIN_CODE ();
		(void) flexscan ();	/* copy remainder of input to output */
		OUT_END_CODE ();
@


1.11
log
@bring some standard C++ fixes, mostly from NetBSD.
get isatty proto from the right place.
avoid malloc.h

okay otto@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.10 2003/06/04 17:34:44 millert Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /spare/open/cvs/src/usr.bin/lex/gen.c,v 1.10 2003/06/04 17:34:44 millert Exp $ */
d37 1
d42 4
a45 4
void gen_next_state PROTO((int));
void genecs PROTO((void));
void indent_put2s PROTO((char [], char []));
void indent_puts PROTO((char []));
d48 1
a48 1
static int indent_level = 0; /* each level is 8 spaces */
a58 5
static char C_int_decl[] = "static yyconst int %s[%d] =\n    {   0,\n";
static char C_short_decl[] = "static yyconst short int %s[%d] =\n    {   0,\n";
static char C_long_decl[] = "static yyconst long int %s[%d] =\n    {   0,\n";
static char C_state_decl[] =
	"static yyconst yy_state_type %s[%d] =\n    {   0,\n";
d60 21
d84 2
a85 2
void do_indent()
	{
d88 2
a89 3
	while ( i >= 8 )
		{
		outc( '\t' );
d91 1
a91 1
		}
d93 2
a94 3
	while ( i > 0 )
		{
		outc( ' ' );
d96 45
d142 1
d144 2
d150 3
a152 3
void gen_backing_up()
	{
	if ( reject || num_backing_up == 0 )
d155 2
a156 2
	if ( fullspd )
		indent_puts( "if ( yy_current_state[-1].yy_nxt )" );
d158 1
a158 1
		indent_puts( "if ( yy_accept[yy_current_state] )" );
d160 7
a166 7
	indent_up();
	indent_puts( "{" );
	indent_puts( "yy_last_accepting_state = yy_current_state;" );
	indent_puts( "yy_last_accepting_cpos = yy_cp;" );
	indent_puts( "}" );
	indent_down();
	}
d171 3
a173 3
void gen_bu_action()
	{
	if ( reject || num_backing_up == 0 )
d176 1
a176 1
	set_indent( 3 );
d178 3
a180 3
	indent_puts( "case 0: /* must back up */" );
	indent_puts( "/* undo the effects of YY_DO_BEFORE_ACTION */" );
	indent_puts( "*yy_cp = yy_hold_char;" );
d182 2
a183 2
	if ( fullspd || fulltbl )
		indent_puts( "yy_cp = yy_last_accepting_cpos + 1;" );
d188 65
a252 1
		indent_puts( "yy_cp = yy_last_accepting_cpos;" );
d254 9
a262 3
	indent_puts( "yy_current_state = yy_last_accepting_state;" );
	indent_puts( "goto yy_find_action;" );
	outc( '\n' );
d264 3
a266 1
	set_indent( 0 );
d269 63
d335 2
a336 2
void genctbl()
	{
d338 1
a338 1
	int end_of_buffer_action = num_rules + 1;
d341 4
a344 3
	out_dec( "static yyconst struct yy_trans_info yy_transition[%d] =\n",
		tblend + numecs + 1 );
	outn( "    {" );
d364 2
a365 2
	while ( tblend + 2 >= current_max_xpairs )
		expand_nxt_chk();
d367 2
a368 2
	while ( lastdfa + 1 >= current_max_dfas )
		increase_max_dfas();
d373 1
a373 1
	chk[tblend + 2] = 1; /* anything but EOB */
d381 3
a383 4
	for ( i = 0; i <= lastdfa; ++i )
		{
		int anum = dfaacc[i].dfaacc_state;
		int offset = base[i];
d388 1
a388 1
		}
d390 15
a404 15
	for ( i = 0; i <= tblend; ++i )
		{
		if ( chk[i] == EOB_POSITION )
			transition_struct_out( 0, base[lastdfa + 1] - i );

		else if ( chk[i] == ACTION_POSITION )
			transition_struct_out( 0, nxt[i] );

		else if ( chk[i] > numecs || chk[i] == 0 )
			transition_struct_out( 0, 0 );	/* unused slot */

		else	/* verify, transition */
			transition_struct_out( chk[i],
						base[nxt[i]] - (i - chk[i]) );
		}
d408 2
a409 2
	transition_struct_out( chk[tblend + 1], nxt[tblend + 1] );
	transition_struct_out( chk[tblend + 2], nxt[tblend + 2] );
d411 2
a412 1
	outn( "    };\n" );
d415 17
a431 4
	out_dec(
	"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n",
		lastsc * 2 + 1 );
	outn( "    {" );	/* } so vi doesn't get confused */
a432 2
	for ( i = 0; i <= lastsc * 2; ++i )
		out_dec( "    &yy_transition[%d],\n", base[i] );
d434 1
a434 1
	dataend();
d436 18
a453 2
	if ( useecs )
		genecs();
d456 6
d465 2
a466 2
void genecs()
	{
d468 1
a468 1
	int numrows;
d470 1
a470 1
	out_str_dec( C_int_decl, "yy_ec", csize );
d472 4
a475 8
	for ( i = 1; i < csize; ++i )
		{
		if ( caseins && (i >= 'A') && (i <= 'Z') )
			ecgroup[i] = ecgroup[clower( i )];

		ecgroup[i] = ABS( ecgroup[i] );
		mkdata( ecgroup[i] );
		}
d477 1
a477 1
	dataend();
d479 2
a480 3
	if ( trace )
		{
		fputs( _( "\n\nEquivalence Classes:\n\n" ), stderr );
d484 4
a487 6
		for ( j = 0; j < numrows; ++j )
			{
			for ( i = j; i < csize; i = i + numrows )
				{
				fprintf( stderr, "%4s = %-2d",
					readable_form( i ), ecgroup[i] );
d489 2
a490 2
				putc( ' ', stderr );
				}
d492 1
a492 2
			putc( '\n', stderr );
			}
d495 1
d500 55
a554 56
void gen_find_action()
	{
	if ( fullspd )
		indent_puts( "yy_act = yy_current_state[-1].yy_nxt;" );

	else if ( fulltbl )
		indent_puts( "yy_act = yy_accept[yy_current_state];" );

	else if ( reject )
		{
		indent_puts( "yy_current_state = *--yy_state_ptr;" );
		indent_puts( "yy_lp = yy_accept[yy_current_state];" );

		outn(
		"find_rule: /* we branch to this label when backing up */" );

		indent_puts(
		"for ( ; ; ) /* until we find what rule we matched */" );

		indent_up();

		indent_puts( "{" );

		indent_puts(
		"if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )" );
		indent_up();
		indent_puts( "{" );
		indent_puts( "yy_act = yy_acclist[yy_lp];" );

		if ( variable_trailing_context_rules )
			{
			indent_puts( "if ( yy_act & YY_TRAILING_HEAD_MASK ||" );
			indent_puts( "     yy_looking_for_trail_begin )" );
			indent_up();
			indent_puts( "{" );

			indent_puts(
				"if ( yy_act == yy_looking_for_trail_begin )" );
			indent_up();
			indent_puts( "{" );
			indent_puts( "yy_looking_for_trail_begin = 0;" );
			indent_puts( "yy_act &= ~YY_TRAILING_HEAD_MASK;" );
			indent_puts( "break;" );
			indent_puts( "}" );
			indent_down();

			indent_puts( "}" );
			indent_down();

			indent_puts( "else if ( yy_act & YY_TRAILING_MASK )" );
			indent_up();
			indent_puts( "{" );
			indent_puts(
		"yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;" );
			indent_puts(
		"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;" );
d556 1
a556 2
			if ( real_reject )
				{
d560 20
a579 4
				indent_puts( "yy_full_match = yy_cp;" );
				indent_puts( "yy_full_state = yy_state_ptr;" );
				indent_puts( "yy_full_lp = yy_lp;" );
				}
d581 3
a583 2
			indent_puts( "}" );
			indent_down();
d585 1
a585 16
			indent_puts( "else" );
			indent_up();
			indent_puts( "{" );
			indent_puts( "yy_full_match = yy_cp;" );
			indent_puts( "yy_full_state = yy_state_ptr;" );
			indent_puts( "yy_full_lp = yy_lp;" );
			indent_puts( "break;" );
			indent_puts( "}" );
			indent_down();

			indent_puts( "++yy_lp;" );
			indent_puts( "goto find_rule;" );
			}

		else
			{
d589 7
a595 7
			indent_up();
			indent_puts( "{" );
			indent_puts( "yy_full_match = yy_cp;" );
			indent_puts( "break;" );
			indent_puts( "}" );
			indent_down();
			}
d597 2
a598 2
		indent_puts( "}" );
		indent_down();
d600 1
a600 1
		indent_puts( "--yy_cp;" );
d606 2
a607 2
		indent_puts( "yy_current_state = *--yy_state_ptr;" );
		indent_puts( "yy_lp = yy_accept[yy_current_state];" );
d609 1
a609 1
		indent_puts( "}" );
d611 2
a612 2
		indent_down();
		}
d614 2
a615 3
	else
		{ /* compressed */
		indent_puts( "yy_act = yy_accept[yy_current_state];" );
d617 1
a617 2
		if ( interactive && ! reject )
			{
d621 11
a631 10
			indent_puts( "if ( yy_act == 0 )" );
			indent_up();
			indent_puts( "{ /* have to back up */" );
			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
			indent_puts(
				"yy_current_state = yy_last_accepting_state;" );
			indent_puts( "yy_act = yy_accept[yy_current_state];" );
			indent_puts( "}" );
			indent_down();
			}
d634 39
d677 2
a678 2
void genftbl()
	{
d680 1
a680 1
	int end_of_buffer_action = num_rules + 1;
d682 2
a683 2
	out_str_dec( long_align ? C_long_decl : C_short_decl,
		"yy_accept", lastdfa + 1 );
d687 1
a687 2
	for ( i = 1; i <= lastdfa; ++i )
		{
d690 1
a690 1
		mkdata( anum );
d692 4
a695 4
		if ( trace && anum )
			fprintf( stderr, _( "state # %d accepts: [%d]\n" ),
				i, anum );
		}
d697 1
a697 1
	dataend();
d699 2
a700 2
	if ( useecs )
		genecs();
d705 1
a705 1
	}
d710 4
a713 4
void gen_next_compressed_state( char_map )
char *char_map;
	{
	indent_put2s( "register YY_CHAR yy_c = %s;", char_map );
d719 1
a719 1
	gen_backing_up();
d721 5
a725 5
	indent_puts(
"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )" );
	indent_up();
	indent_puts( "{" );
	indent_puts( "yy_current_state = (int) yy_def[yy_current_state];" );
d727 1
a727 2
	if ( usemecs )
		{
d735 1
a735 1
		do_indent();
d738 1
a738 1
		out_dec( "if ( yy_current_state >= %d )\n", lastdfa + 2 );
d740 4
a743 4
		indent_up();
		indent_puts( "yy_c = yy_meta[(unsigned int) yy_c];" );
		indent_down();
		}
d745 2
a746 2
	indent_puts( "}" );
	indent_down();
d748 3
a750 3
	indent_puts(
"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];" );
	}
d755 2
a756 2
void gen_next_match()
	{
d760 29
a788 22
	char *char_map = useecs ?
				"yy_ec[YY_SC_TO_UI(*yy_cp)]" :
				"YY_SC_TO_UI(*yy_cp)";

	char *char_map_2 = useecs ?
				"yy_ec[YY_SC_TO_UI(*++yy_cp)]" :
				"YY_SC_TO_UI(*++yy_cp)";

	if ( fulltbl )
		{
		indent_put2s(
	"while ( (yy_current_state = yy_nxt[yy_current_state][%s]) > 0 )",
				char_map );

		indent_up();

		if ( num_backing_up > 0 )
			{
			indent_puts( "{" );	/* } for vi */
			gen_backing_up();
			outc( '\n' );
			}
d790 1
a790 1
		indent_puts( "++yy_cp;" );
d792 3
a794 35
		if ( num_backing_up > 0 )
			/* { for vi */
			indent_puts( "}" );

		indent_down();

		outc( '\n' );
		indent_puts( "yy_current_state = -yy_current_state;" );
		}

	else if ( fullspd )
		{
		indent_puts( "{" );	/* } for vi */
		indent_puts(
		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
		indent_puts( "register YY_CHAR yy_c;\n" );
		indent_put2s( "for ( yy_c = %s;", char_map );
		indent_puts(
	"      (yy_trans_info = &yy_current_state[(unsigned int) yy_c])->" );
		indent_puts( "yy_verify == yy_c;" );
		indent_put2s( "      yy_c = %s )", char_map_2 );

		indent_up();

		if ( num_backing_up > 0 )
			indent_puts( "{" );	/* } for vi */

		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );

		if ( num_backing_up > 0 )
			{
			outc( '\n' );
			gen_backing_up();	/* { for vi */
			indent_puts( "}" );
			}
d796 22
a817 2
		indent_down();	/* { for vi */
		indent_puts( "}" );
d820 9
a828 3
	else
		{ /* compressed */
		indent_puts( "do" );
d830 1
a830 2
		indent_up();
		indent_puts( "{" );	/* } for vi */
d832 1
a832 1
		gen_next_state( false );
a833 1
		indent_puts( "++yy_cp;" );
d835 2
a836 3
		/* { for vi */
		indent_puts( "}" );
		indent_down();
d838 1
a838 1
		do_indent();
d840 2
a841 3
		if ( interactive )
			out_dec( "while ( yy_base[yy_current_state] != %d );\n",
				jambase );
d843 2
a844 2
			out_dec( "while ( yy_current_state != %d );\n",
				jamstate );
d846 1
a846 2
		if ( ! reject && ! interactive )
			{
d850 4
a853 4
			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
			indent_puts(
				"yy_current_state = yy_last_accepting_state;" );
			}
d856 1
d861 10
a870 11
void gen_next_state( worry_about_NULs )
int worry_about_NULs;
	{ /* NOTE - changes in here should be reflected in gen_next_match() */
	char char_map[256];

	if ( worry_about_NULs && ! nultrans )
		{
		if ( useecs )
			(void) snprintf( char_map, sizeof char_map,
				"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)",
					NUL_ec );
d872 4
a875 3
			(void) snprintf( char_map, sizeof char_map,
				"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)", NUL_ec );
		}
d878 6
a883 7
		strlcpy( char_map, useecs ?
			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)",
			sizeof char_map );

	if ( worry_about_NULs && nultrans )
		{
		if ( ! fulltbl && ! fullspd )
d885 17
a901 1
			gen_backing_up();
d903 4
a906 14
		indent_puts( "if ( *yy_cp )" );
		indent_up();
		indent_puts( "{" );	/* } for vi */
		}

	if ( fulltbl )
		indent_put2s(
			"yy_current_state = yy_nxt[yy_current_state][%s];", 
				char_map );

	else if ( fullspd )
		indent_put2s(
			"yy_current_state += yy_current_state[%s].yy_nxt;",
				char_map );
d909 1
a909 1
		gen_next_compressed_state( char_map );
d911 10
a920 11
	if ( worry_about_NULs && nultrans )
		{
		/* { for vi */
		indent_puts( "}" );
		indent_down();
		indent_puts( "else" );
		indent_up();
		indent_puts(
			"yy_current_state = yy_NUL_trans[yy_current_state];" );
		indent_down();
		}
d922 2
a923 2
	if ( fullspd || fulltbl )
		gen_backing_up();
d925 3
a927 3
	if ( reject )
		indent_puts( "*yy_state_ptr++ = yy_current_state;" );
	}
d932 2
a933 2
void gen_NUL_trans()
	{ /* NOTE - changes in here should be reflected in gen_next_match() */
d937 1
a937 1
	int need_backing_up = (num_backing_up > 0 && ! reject);
d939 1
a939 1
	if ( need_backing_up && (! nultrans || fullspd || fulltbl) )
d943 3
a945 1
		indent_puts( "register char *yy_cp = yy_c_buf_p;" );
d947 14
a960 1
	outc( '\n' );
d962 9
a970 25
	if ( nultrans )
		{
		indent_puts(
			"yy_current_state = yy_NUL_trans[yy_current_state];" );
		indent_puts( "yy_is_jam = (yy_current_state == 0);" );
		}

	else if ( fulltbl )
		{
		do_indent();
		out_dec( "yy_current_state = yy_nxt[yy_current_state][%d];\n",
			NUL_ec );
		indent_puts( "yy_is_jam = (yy_current_state <= 0);" );
		}

	else if ( fullspd )
		{
		do_indent();
		out_dec( "register int yy_c = %d;\n", NUL_ec );

		indent_puts(
		"register yyconst struct yy_trans_info *yy_trans_info;\n" );
		indent_puts(
		"yy_trans_info = &yy_current_state[(unsigned int) yy_c];" );
		indent_puts( "yy_current_state += yy_trans_info->yy_nxt;" );
d972 3
a974 3
		indent_puts(
			"yy_is_jam = (yy_trans_info->yy_verify != yy_c);" );
		}
d976 2
a977 3
	else
		{
		char NUL_ec_str[20];
d979 2
a980 2
		(void) snprintf( NUL_ec_str, sizeof NUL_ec_str, "%d", NUL_ec );
		gen_next_compressed_state( NUL_ec_str );
d982 3
a984 2
		do_indent();
		out_dec( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
d986 1
a986 2
		if ( reject )
			{
d991 5
a995 5
			indent_puts( "if ( ! yy_is_jam )" );
			indent_up();
			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
			indent_down();
			}
d997 1
d1003 8
a1010 10
	if ( need_backing_up && (fullspd || fulltbl) )
		{
		outc( '\n' );
		indent_puts( "if ( ! yy_is_jam )" );
		indent_up();
		indent_puts( "{" );
		gen_backing_up();
		indent_puts( "}" );
		indent_down();
		}
d1012 1
d1017 7
a1023 9
void gen_start_state()
	{
	if ( fullspd )
		{
		if ( bol_needed )
			{
			indent_puts(
	"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];" );
			}
d1025 3
a1027 3
			indent_puts(
			"yy_current_state = yy_start_state_list[yy_start];" );
		}
d1029 2
a1030 3
	else
		{
		indent_puts( "yy_current_state = yy_start;" );
d1032 2
a1033 2
		if ( bol_needed )
			indent_puts( "yy_current_state += YY_AT_BOL();" );
d1035 1
a1035 2
		if ( reject )
			{
d1037 6
a1042 3
			indent_puts( "yy_state_ptr = yy_state_buf;" );
			indent_puts( "*yy_state_ptr++ = yy_current_state;" );
			}
d1045 1
d1050 9
a1058 4
void gentabs()
	{
	int i, j, k, *accset, nacc, *acc_array, total_states;
	int end_of_buffer_action = num_rules + 1;
d1060 1
a1060 1
	acc_array = allocate_integer_array( current_max_dfas );
d1070 1
a1070 2
	if ( reject )
		{
d1072 1
a1072 1
		 *
d1077 1
a1077 1
		int EOB_accepting_list[2];
d1083 2
a1084 1
		dfaacc[end_of_buffer_state].dfaacc_set = EOB_accepting_list;
d1086 14
a1099 2
		out_str_dec( long_align ? C_long_decl : C_short_decl,
			"yy_acclist", MAX( numas, 1 ) + 1 );
d1101 1
a1101 1
		j = 1;	/* index into "yy_acclist" array */
d1103 1
a1103 2
		for ( i = 1; i <= lastdfa; ++i )
			{
d1106 1
a1106 2
			if ( accsiz[i] != 0 )
				{
d1110 7
a1116 8
				if ( trace )
					fprintf( stderr,
						_( "state # %d accepts: " ),
						i );

				for ( k = 1; k <= nacc; ++k )
					{
					int accnum = accset[k];
d1120 7
a1126 5
					if ( variable_trailing_context_rules &&
					  ! (accnum & YY_TRAILING_HEAD_MASK) &&
					   accnum > 0 && accnum <= num_rules &&
					  rule_type[accnum] == RULE_VARIABLE )
						{
d1132 1
a1132 1
						}
d1134 2
a1135 1
					mkdata( accnum );
d1137 7
a1143 7
					if ( trace )
						{
						fprintf( stderr, "[%d]",
							accset[k] );

						if ( k < nacc )
							fputs( ", ", stderr );
d1145 2
a1146 2
							putc( '\n', stderr );
						}
d1150 1
d1155 9
a1163 2
		dataend();
		}
d1165 3
a1167 3
	else
		{
		dfaacc[end_of_buffer_state].dfaacc_state = end_of_buffer_action;
d1169 1
a1169 1
		for ( i = 1; i <= lastdfa; ++i )
d1174 3
a1176 1
		}
d1188 1
a1188 1
	if ( reject )
d1196 2
a1197 1
	out_str_dec( long_align ? C_long_decl : C_short_decl, "yy_accept", k );
d1199 21
a1219 8
	for ( i = 1; i <= lastdfa; ++i )
		{
		mkdata( acc_array[i] );

		if ( ! reject && trace && acc_array[i] )
			fprintf( stderr, _( "state # %d accepts: [%d]\n" ),
				i, acc_array[i] );
		}
d1222 2
a1223 1
	mkdata( acc_array[i] );
d1225 1
a1225 1
	if ( reject )
d1227 3
a1229 1
		mkdata( acc_array[i] );
d1231 9
a1239 1
	dataend();
d1241 1
a1241 2
	if ( useecs )
		genecs();
d1243 15
a1257 2
	if ( usemecs )
		{
d1261 37
a1297 17

		if ( trace )
			fputs( _( "\n\nMeta-Equivalence Classes:\n" ),
			      stderr );

		out_str_dec( C_int_decl, "yy_meta", numecs + 1 );

		for ( i = 1; i <= numecs; ++i )
			{
			if ( trace )
				fprintf( stderr, "%d = %d\n",
					i, ABS( tecbck[i] ) );

			mkdata( ABS( tecbck[i] ) );
			}

		dataend();
d1299 2
d1304 18
a1321 3
	out_str_dec( (tblend >= MAX_SHORT || long_align) ?
			C_long_decl : C_short_decl,
		"yy_base", total_states + 1 );
d1323 1
a1323 2
	for ( i = 1; i <= lastdfa; ++i )
		{
d1326 1
a1326 1
		if ( base[i] == JAMSTATE )
d1329 1
a1329 1
		if ( d == JAMSTATE )
d1332 1
a1332 2
		else if ( d < 0 )
			{
d1336 1
a1336 1
			}
d1338 3
a1340 2
		mkdata( base[i] );
		}
d1343 2
a1344 1
	mkdata( base[i] );
d1346 3
a1348 3
	for ( ++i /* skip jam state */; i <= total_states; ++i )
		{
		mkdata( base[i] );
d1350 11
a1360 1
		}
a1361 1
	dataend();
d1363 22
a1384 3
	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
			C_long_decl : C_short_decl,
		"yy_def", total_states + 1 );
d1386 9
a1394 2
	for ( i = 1; i <= total_states; ++i )
		mkdata( def[i] );
a1395 1
	dataend();
d1397 17
a1413 3
	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
			C_long_decl : C_short_decl,
		"yy_nxt", tblend + 1 );
d1415 1
a1415 2
	for ( i = 1; i <= tblend; ++i )
		{
d1419 1
a1419 1
		if ( chk[i] == 0 || nxt[i] == 0 )
d1422 3
a1424 2
		mkdata( nxt[i] );
		}
d1426 9
a1434 1
	dataend();
d1436 17
a1452 3
	out_str_dec( (total_states >= MAX_SHORT || long_align) ?
			C_long_decl : C_short_decl,
		"yy_chk", tblend + 1 );
d1454 2
a1455 3
	for ( i = 1; i <= tblend; ++i )
		{
		if ( chk[i] == 0 )
d1458 3
a1460 2
		mkdata( chk[i] );
		}
d1462 7
a1468 2
	dataend();
	free(acc_array);
d1470 4
d1480 7
a1486 7
void indent_put2s( fmt, arg )
char fmt[], arg[];
	{
	do_indent();
	out_str( fmt, arg );
	outn( "" );
	}
d1493 6
a1498 6
void indent_puts( str )
char str[];
	{
	do_indent();
	outn( str );
	}
d1504 2
a1505 2
void make_tables()
	{
d1507 2
a1508 1
	int did_eof_rule = false;
d1510 2
a1511 1
	skelout();
d1516 1
a1516 1
	set_indent( 1 );
d1518 5
a1522 5
	if ( yymore_used && ! yytext_is_array )
		{
		indent_puts( "yytext_ptr -= yy_more_len; \\" );
		indent_puts( "yyleng = (int) (yy_cp - yytext_ptr); \\" );
		}
d1525 1
a1525 1
		indent_puts( "yyleng = (int) (yy_cp - yy_bp); \\" );
d1528 5
a1532 6
	skelout();
	if ( yytext_is_array )
		{
		if ( yymore_used )
			indent_puts(
				"if ( yyleng + yy_more_offset >= YYLMAX ) \\" );
d1534 1
a1534 1
			indent_puts( "if ( yyleng >= YYLMAX ) \\" );
d1536 16
a1551 19
		indent_up();
		indent_puts(
		"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\" );
		indent_down();

		if ( yymore_used )
			{
			indent_puts(
"yy_flex_strncpy( &yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\" );
			indent_puts( "yyleng += yy_more_offset; \\" );
			indent_puts(
				"yy_prev_more_offset = yy_more_offset; \\" );
			indent_puts( "yy_more_offset = 0; \\" );
			}
		else
			{
			indent_puts(
		"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\" );
			}
d1553 1
d1555 1
a1555 1
	set_indent( 0 );
d1557 1
a1557 1
	skelout();
d1560 1
a1560 2
	out_dec( "#define YY_NUM_RULES %d\n", num_rules );
	out_dec( "#define YY_END_OF_BUFFER %d\n", num_rules + 1 );
d1562 4
a1565 2
	if ( fullspd )
		{
d1569 9
a1577 9
		int total_table_size = tblend + numecs + 1;
		char *trans_offset_type =
			(total_table_size >= MAX_SHORT || long_align) ?
				"long" : "short";

		set_indent( 0 );
		indent_puts( "struct yy_trans_info" );
		indent_up();
		indent_puts( "{" ); 	/* } for vi */
d1579 2
a1580 4
		if ( long_align )
			indent_puts( "long yy_verify;" );
		else
			indent_puts( "short yy_verify;" );
d1590 49
a1638 3
		indent_put2s( "%s yy_nxt;", trans_offset_type );
		indent_puts( "};" );
		indent_down();
d1640 26
d1667 15
a1681 6
	if ( fullspd )
		genctbl();
	else if ( fulltbl )
		genftbl();
	else
		gentabs();
d1687 6
a1692 9
	if ( num_backing_up > 0 && ! reject )
		{
		if ( ! C_plus_plus )
			{
			indent_puts(
			"static yy_state_type yy_last_accepting_state;" );
			indent_puts(
				"static char *yy_last_accepting_cpos;\n" );
			}
d1694 4
d1699 29
a1727 10
	if ( nultrans )
		{
		out_str_dec( C_state_decl, "yy_NUL_trans", lastdfa + 1 );

		for ( i = 1; i <= lastdfa; ++i )
			{
			if ( fullspd )
				out_dec( "    &yy_transition[%d],\n", base[i] );
			else
				mkdata( nultrans[i] );
d1729 1
d1731 9
a1739 1
		dataend();
d1741 2
d1744 14
a1757 7
	if ( ddebug )
		{ /* Spit out table mapping rules to line numbers. */
		if ( ! C_plus_plus )
			{
			indent_puts( "extern int yy_flex_debug;" );
			indent_puts( "int yy_flex_debug = 1;\n" );
			}
d1759 7
a1765 5
		out_str_dec( long_align ? C_long_decl : C_short_decl,
			"yy_rule_linenum", num_rules );
		for ( i = 1; i < num_rules; ++i )
			mkdata( rule_linenum[i] );
		dataend();
d1768 5
a1772 9
	if ( reject )
		{
		/* Declare state buffer variables. */
		if ( ! C_plus_plus )
			{
			outn(
	"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;" );
			outn( "static char *yy_full_match;" );
			outn( "static int yy_lp;" );
d1775 10
a1784 9
		if ( variable_trailing_context_rules )
			{
			if ( ! C_plus_plus )
				{
				outn(
				"static int yy_looking_for_trail_begin = 0;" );
				outn( "static int yy_full_lp;" );
				outn( "static int *yy_full_state;" );
				}
d1786 5
a1790 5
			out_hex( "#define YY_TRAILING_MASK 0x%x\n",
				(unsigned int) YY_TRAILING_MASK );
			out_hex( "#define YY_TRAILING_HEAD_MASK 0x%x\n",
				(unsigned int) YY_TRAILING_HEAD_MASK );
			}
d1792 2
a1793 16
		outn( "#define REJECT \\" );
		outn( "{ \\" );		/* } for vi */
		outn(
	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\" );
		outn(
	"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\" );

		if ( variable_trailing_context_rules )
			{
			outn(
		"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\" );
			outn(
		"yy_state_ptr = yy_full_state; /* restore orig. state */ \\" );
			outn(
	"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\" );
			}
d1795 3
a1797 5
		outn( "++yy_lp; \\" );
		outn( "goto find_rule; \\" );
		/* { for vi */
		outn( "}" );
		}
d1799 6
a1804 25
	else
		{
		outn(
		"/* The intent behind this definition is that it'll catch" );
		outn( " * any uses of REJECT which flex missed." );
		outn( " */" );
		outn( "#define REJECT reject_used_but_not_detected" );
		}

	if ( yymore_used )
		{
		if ( ! C_plus_plus )
			{
			if ( yytext_is_array )
				{
				indent_puts( "static int yy_more_offset = 0;" );
				indent_puts(
					"static int yy_prev_more_offset = 0;" );
				}
			else
				{
				indent_puts( "static int yy_more_flag = 0;" );
				indent_puts( "static int yy_more_len = 0;" );
				}
			}
d1806 13
a1818 19
		if ( yytext_is_array )
			{
			indent_puts(
	"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))" );
			indent_puts( "#define YY_NEED_STRLEN" );
			indent_puts( "#define YY_MORE_ADJ 0" );
			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET \\" );
			indent_up();
			indent_puts( "{ \\" );
			indent_puts( "yy_more_offset = yy_prev_more_offset; \\" );
			indent_puts( "yyleng -= yy_more_offset; \\" );
			indent_puts( "}" );
			indent_down();
			}
		else
			{
			indent_puts( "#define yymore() (yy_more_flag = 1)" );
			indent_puts( "#define YY_MORE_ADJ yy_more_len" );
			indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
d1822 21
a1842 5
	else
		{
		indent_puts( "#define yymore() yymore_used_but_not_detected" );
		indent_puts( "#define YY_MORE_ADJ 0" );
		indent_puts( "#define YY_RESTORE_YY_MORE_OFFSET" );
d1844 1
d1846 6
a1851 10
	if ( ! C_plus_plus )
		{
		if ( yytext_is_array )
			{
			outn( "#ifndef YYLMAX" );
			outn( "#define YYLMAX 8192" );
			outn( "#endif\n" );
			outn( "char yytext[YYLMAX];" );
			outn( "char *yytext_ptr;" );
			}
d1853 9
a1861 2
		else
			outn( "char *yytext;" );
d1864 5
a1868 1
	out( &action_array[defs1_offset] );
d1870 1
a1870 1
	line_directive_out( stdout, 0 );
d1872 1
a1872 1
	skelout();
d1874 1
a1874 9
	if ( ! C_plus_plus )
		{
		if ( use_read )
			{
			outn(
"\tif ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \\" );
			outn(
		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
			}
d1876 43
a1918 22
		else
			{
			outn(
			"\tif ( yy_current_buffer->yy_is_interactive ) \\" );
			outn( "\t\t{ \\" );
			outn( "\t\tint c = '*', n; \\" );
			outn( "\t\tfor ( n = 0; n < max_size && \\" );
	outn( "\t\t\t     (c = getc( yyin )) != EOF && c != '\\n'; ++n ) \\" );
			outn( "\t\t\tbuf[n] = (char) c; \\" );
			outn( "\t\tif ( c == '\\n' ) \\" );
			outn( "\t\t\tbuf[n++] = (char) c; \\" );
			outn( "\t\tif ( c == EOF && ferror( yyin ) ) \\" );
			outn(
	"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\" );
			outn( "\t\tresult = n; \\" );
			outn( "\t\t} \\" );
			outn(
	"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\" );
			outn( "\t\t  && ferror( yyin ) ) \\" );
			outn(
		"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );" );
			}
d1920 1
d1922 1
a1922 1
	skelout();
d1924 11
a1934 12
	indent_puts( "#define YY_RULE_SETUP \\" );
	indent_up();
	if ( bol_needed )
		{
		indent_puts( "if ( yyleng > 0 ) \\" );
		indent_up();
		indent_puts( "yy_current_buffer->yy_at_bol = \\" );
		indent_puts( "\t\t(yytext[yyleng - 1] == '\\n'); \\" );
		indent_down();
		}
	indent_puts( "YY_USER_ACTION" );
	indent_down();
d1936 1
a1936 1
	skelout();
d1939 1
a1939 1
	out( &action_array[prolog_offset] );
d1941 1
a1941 1
	line_directive_out( stdout, 0 );
d1943 1
a1943 1
	skelout();
d1945 1
a1945 1
	set_indent( 2 );
d1947 11
a1957 11
	if ( yymore_used && ! yytext_is_array )
		{
		indent_puts( "yy_more_len = 0;" );
		indent_puts( "if ( yy_more_flag )" );
		indent_up();
		indent_puts( "{" );
		indent_puts( "yy_more_len = yy_c_buf_p - yytext_ptr;" );
		indent_puts( "yy_more_flag = 0;" );
		indent_puts( "}" );
		indent_down();
		}
d1959 1
a1959 1
	skelout();
d1961 1
a1961 1
	gen_start_state();
d1964 2
a1965 2
	outn( "yy_match:" );
	gen_next_match();
d1967 96
a2062 51
	skelout();
	set_indent( 2 );
	gen_find_action();

	skelout();
	if ( do_yylineno )
		{
		indent_puts( "if ( yy_act != YY_END_OF_BUFFER )" );
		indent_up();
		indent_puts( "{" );
		indent_puts( "int yyl;" );
		indent_puts( "for ( yyl = 0; yyl < yyleng; ++yyl )" );
		indent_up();
		indent_puts( "if ( yytext[yyl] == '\\n' )" );
		indent_up();
		indent_puts( "++yylineno;" );
		indent_down();
		indent_down();
		indent_puts( "}" );
		indent_down();
		}

	skelout();
	if ( ddebug )
		{
		indent_puts( "if ( yy_flex_debug )" );
		indent_up();

		indent_puts( "{" );
		indent_puts( "if ( yy_act == 0 )" );
		indent_up();
		indent_puts( C_plus_plus ?
			"std::cerr << \"--scanner backing up\\n\";" :
			"fprintf( stderr, \"--scanner backing up\\n\" );" );
		indent_down();

		do_indent();
		out_dec( "else if ( yy_act < %d )\n", num_rules );
		indent_up();

		if ( C_plus_plus )
			{
			indent_puts(
	"std::cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<" );
			indent_puts(
			"         \"(\\\"\" << yytext << \"\\\")\\n\";" );
			}
		else
			{
			indent_puts(
	"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\"," );
d2064 1
a2064 3
			indent_puts(
				"         yy_rule_linenum[yy_act], yytext );" );
			}
d2066 3
a2068 50
		indent_down();

		do_indent();
		out_dec( "else if ( yy_act == %d )\n", num_rules );
		indent_up();

		if ( C_plus_plus )
			{
			indent_puts(
"std::cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";" );
			}
		else
			{
			indent_puts(
	"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\"," );
			indent_puts( "         yytext );" );
			}

		indent_down();

		do_indent();
		out_dec( "else if ( yy_act == %d )\n", num_rules + 1 );
		indent_up();

		indent_puts( C_plus_plus ?
			"std::cerr << \"--(end of buffer or a NUL)\\n\";" :
		"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );" );

		indent_down();

		do_indent();
		outn( "else" );
		indent_up();

		if ( C_plus_plus )
			{
			indent_puts(
	"std::cerr << \"--EOF (start condition \" << YY_START << \")\\n\";" );
			}
		else
			{
			indent_puts(
	"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );" );
			}

		indent_down();

		indent_puts( "}" );
		indent_down();
		}
d2071 4
a2074 4
	skelout();
	indent_up();
	gen_bu_action();
	out( &action_array[action_offset] );
d2076 1
a2076 1
	line_directive_out( stdout, 0 );
d2079 4
a2082 5
	for ( i = 1; i <= lastsc; ++i )
		if ( ! sceof[i] )
			{
			do_indent();
			out_str( "case YY_STATE_EOF(%s):\n", scname[i] );
d2084 1
a2084 1
			}
d2086 5
a2090 6
	if ( did_eof_rule )
		{
		indent_up();
		indent_puts( "yyterminate();" );
		indent_down();
		}
d2098 2
a2099 2
	skelout();
	set_indent( 4 );
d2101 2
a2102 2
	if ( fullspd || fulltbl )
		indent_puts( "yy_cp = yy_c_buf_p;" );
d2104 2
a2105 4
	else
		{ /* compressed table */
		if ( ! reject && ! interactive )
			{
d2109 5
a2113 4
			indent_puts( "yy_cp = yy_last_accepting_cpos;" );
			indent_puts(
				"yy_current_state = yy_last_accepting_state;" );
			}
d2120 2
a2121 2
			indent_puts( "yy_cp = yy_c_buf_p;" );
		}
d2125 2
a2126 2
	set_indent( 1 );
	skelout();
d2128 1
a2128 1
	gen_start_state();
d2130 3
a2132 3
	set_indent( 2 );
	skelout();
	gen_next_state( true );
d2134 3
a2136 12
	set_indent( 1 );
	skelout();
	gen_NUL_trans();

	skelout();
	if ( do_yylineno )
		{ /* update yylineno inside of unput() */
		indent_puts( "if ( c == '\\n' )" );
		indent_up();
		indent_puts( "--yylineno;" );
		indent_down();
		}
d2138 2
a2139 1
	skelout();
d2141 9
a2149 10
	if ( bol_needed )
		{
		indent_puts( "yy_current_buffer->yy_at_bol = (c == '\\n');" );
		if ( do_yylineno )
			{
			indent_puts( "if ( yy_current_buffer->yy_at_bol )" );
			indent_up();
			indent_puts( "++yylineno;" );
			indent_down();
			}
d2151 1
d2153 6
a2158 7
	else if ( do_yylineno )
		{
		indent_puts( "if ( c == '\\n' )" );
		indent_up();
		indent_puts( "++yylineno;" );
		indent_down();
		}
d2160 1
a2160 1
	skelout();
d2164 1
a2164 1
	line_directive_out( stdout, 1 );
d2166 4
a2169 2
	if ( sectnum == 3 )
		(void) flexscan(); /* copy remainder of input to output */
d2171 1
@


1.10
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.9 2002/05/31 22:49:29 deraadt Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.9 2002/05/31 22:49:29 deraadt Exp $ */
d1449 1
a1449 1
			"cerr << \"--scanner backing up\\n\";" :
d1460 1
a1460 1
	"cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<" );
d1482 1
a1482 1
"cerr << \"--accepting default rule (\\\"\" << yytext << \"\\\")\\n\";" );
d1498 1
a1498 1
			"cerr << \"--(end of buffer or a NUL)\\n\";" :
d1510 1
a1510 1
	"cerr << \"--EOF (start condition \" << YY_START << \")\\n\";" );
@


1.9
log
@recommit strlcpy/snprintf diff after i found my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.7 2002/05/30 10:53:44 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.7 2002/05/30 10:53:44 deraadt Exp $ */
@


1.8
log
@undo until i find my #line bug
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.6 2001/11/19 19:02:14 mpech Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.6 2001/11/19 19:02:14 mpech Exp $ */
d608 1
a608 1
			(void) sprintf( char_map,
d612 1
a612 1
			(void) sprintf( char_map,
d617 3
a619 2
		strcpy( char_map, useecs ?
			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)" );
d716 1
a716 1
		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
@


1.7
log
@use strlcpy and snprintf
@
text
@d608 1
a608 1
			(void) snprintf( char_map, sizeof char_map,
d612 1
a612 1
			(void) snprintf( char_map, sizeof char_map,
d617 2
a618 3
		strlcpy( char_map, useecs ?
			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)",
			sizeof char_map );
d715 1
a715 1
		(void) snprintf( NUL_ec_str, sizeof NUL_ec_str, "%d", NUL_ec );
@


1.6
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $ */
d608 1
a608 1
			(void) sprintf( char_map,
d612 1
a612 1
			(void) sprintf( char_map,
d617 3
a619 2
		strcpy( char_map, useecs ?
			"yy_ec[YY_SC_TO_UI(*yy_cp)]" : "YY_SC_TO_UI(*yy_cp)" );
d716 1
a716 1
		(void) sprintf( NUL_ec_str, "%d", NUL_ec );
@


1.5
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.4 1998/11/24 01:21:36 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.4 1998/11/24 01:21:36 deraadt Exp $ */
d66 1
a66 1
	register int i = indent_level * 8;
d136 1
a136 1
	register int i;
d232 1
a232 1
	register int i, j;
d413 1
a413 1
	register int i;
d423 1
a423 1
		register int anum = dfaacc[i].dfaacc_state;
d960 1
a960 1
		register int d = def[i];
d1062 1
a1062 1
	register int i;
@


1.4
log
@fix memory leaks; itohy@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.3 1996/07/13 22:22:01 millert Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.3 1996/07/13 22:22:01 millert Exp $ */
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: gen.c,v 1.2 1996/06/26 05:35:34 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/gen.c,v 2.56 96/05/25 20:43:38 vern Exp $ */
d1028 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/gen.c,v 1.1.1.1 1995/10/18 08:45:30 deraadt Exp $ */
d718 3
d722 7
d730 2
a731 4

		do_indent();

		out_dec( "yy_is_jam = (yy_current_state == %d);\n", jamstate );
d1071 1
a1071 1
	if ( yymore_used )
d1084 6
a1089 1
		indent_puts( "if ( yyleng >= YYLMAX ) \\" );
d1094 13
a1106 1
		indent_puts(
d1108 1
d1267 11
a1277 2
			indent_puts( "static int yy_more_flag = 0;" );
			indent_puts( "static int yy_more_len = 0;" );
d1280 20
a1299 2
		indent_puts( "#define yymore() (yy_more_flag = 1)" );
		indent_puts( "#define YY_MORE_ADJ yy_more_len" );
d1306 1
d1390 1
a1390 1
	if ( yymore_used )
d1396 1
a1396 1
		indent_puts( "yy_more_len = yyleng;" );
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/gen.c,v 1.10 1995/05/05 05:35:25 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
