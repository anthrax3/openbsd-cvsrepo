head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.4
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6;
locks; strict;
comment	@ * @;


1.9
date	2017.08.30.02.54.07;	author lteo;	state Exp;
branches;
next	1.8;
commitid	gNPXU4lsyS6NI7bk;

1.8
date	2017.08.17.19.27.48;	author tedu;	state Exp;
branches;
next	1.7;
commitid	EAZMSMDsKRmDOUDj;

1.7
date	2016.12.18.06.11.23;	author krw;	state Exp;
branches;
next	1.6;
commitid	fCnIjtvaaZwmYSr8;

1.6
date	2015.11.19.23.28.03;	author tedu;	state Exp;
branches;
next	1.5;
commitid	CMGrkCVc2tUoCr3Z;

1.5
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.4;
commitid	BIjrMDODd4w0xnpk;

1.4
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.3;
commitid	cuVuNj9APX2eFzx2;

1.3
date	2015.11.19.22.25.53;	author tedu;	state Exp;
branches;
next	1.2;
commitid	f9dcdKPyIqXwzR91;

1.2
date	2015.11.19.22.16.43;	author tedu;	state Exp;
branches;
next	1.1;
commitid	cXEbYUQ1o6xIQH4J;

1.1
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	;
commitid	TCPdLh99ETkn9X6R;


desc
@@


1.9
log
@Remove unused variable; no binary change.

From Michael W. Bombardieri, thanks!
@
text
@/* $OpenBSD: filter.c,v 1.8 2017/08/17 19:27:48 tedu Exp $ */

/* filter - postprocessing of flex output through filters */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"
static const char *check_4_gnu_m4 =
"m4_dnl ifdef(`__gnu__', ,"
"`errprint(Flex requires GNU M4. Set the PATH or set the M4 environment variable to its path name.)"
" m4exit(2)')\n";


/** global chain. */
struct filter *output_chain = NULL;

/* Allocate and initialize an external filter.
 * @@param chain the current chain or NULL for new chain
 * @@param cmd the command to execute.
 * @@param ... a NULL terminated list of (const char*) arguments to command,
 *            not including argv[0].
 * @@return newest filter in chain
 */
struct filter *
filter_create_ext(struct filter * chain, const char *cmd,
    ...)
{
	struct filter *f;
	int max_args;
	const char *s;
	va_list ap;

	/* allocate and initialize new filter */
	f = calloc(sizeof(struct filter), 1);
	if (!f)
		flexerror(_("calloc failed (f) in filter_create_ext"));
	f->filter_func = NULL;
	f->extra = NULL;
	f->next = NULL;
	f->argc = 0;

	if (chain != NULL) {
		/* append f to end of chain */
		while (chain->next)
			chain = chain->next;
		chain->next = f;
	}
	/* allocate argv, and populate it with the argument list. */
	max_args = 8;
	f->argv = malloc(sizeof(char *) * (max_args + 1));
	if (!f->argv)
		flexerror(_("malloc failed (f->argv) in filter_create_ext"));
	f->argv[f->argc++] = cmd;

	va_start(ap, cmd);
	while ((s = va_arg(ap, const char *)) != NULL) {
		if (f->argc >= max_args) {
			max_args += 8;
			f->argv = realloc(f->argv,
			    sizeof(char *) * (max_args + 1));
		}
		f->argv[f->argc++] = s;
	}
	f->argv[f->argc] = NULL;

	va_end(ap);
	return f;
}

/* Allocate and initialize an internal filter.
 * @@param chain the current chain or NULL for new chain
 * @@param filter_func The function that will perform the filtering.
 *        filter_func should return 0 if successful, and -1
 *        if an error occurs -- or it can simply exit().
 * @@param extra optional user-defined data to pass to the filter.
 * @@return newest filter in chain
 */
struct filter *
filter_create_int(struct filter * chain,
    int (*filter_func) (struct filter *),
    void *extra)
{
	struct filter *f;

	/* allocate and initialize new filter */
	f = calloc(sizeof(struct filter), 1);
	if (!f)
		flexerror(_("calloc failed in filter_create_int"));
	f->next = NULL;
	f->argc = 0;
	f->argv = NULL;

	f->filter_func = filter_func;
	f->extra = extra;

	if (chain != NULL) {
		/* append f to end of chain */
		while (chain->next)
			chain = chain->next;
		chain->next = f;
	}
	return f;
}

/** Fork and exec entire filter chain.
 *  @@param chain The head of the chain.
 *  @@return true on success.
 */
bool 
filter_apply_chain(struct filter * chain)
{
	int pid, pipes[2];

	/*
	 * Tricky recursion, since we want to begin the chain at the END.
	 * Why? Because we need all the forked processes to be children of
	 * the main flex process.
	 */
	if (chain)
		filter_apply_chain(chain->next);
	else
		return true;

	/*
	 * Now we are the right-most unprocessed link in the chain.
	 */

	fflush(stdout);
	fflush(stderr);


	if (pipe(pipes) == -1)
		flexerror(_("pipe failed"));

	if ((pid = fork()) == -1)
		flexerror(_("fork failed"));

	if (pid == 0) {
		/* child */

		/*
		 * We need stdin (the FILE* stdin) to connect to this new
		 * pipe. There is no portable way to set stdin to a new file
		 * descriptor, as stdin is not an lvalue on some systems
		 * (BSD). So we dup the new pipe onto the stdin descriptor
		 * and use a no-op fseek to sync the stream. This is a Hail
		 * Mary situation. It seems to work.
		 */
		close(pipes[1]);
		clearerr(stdin);
		if (dup2(pipes[0], fileno(stdin)) == -1)
			flexfatal(_("dup2(pipes[0],0)"));
		close(pipes[0]);
		fseek(stdin, 0, SEEK_CUR);

		/* run as a filter, either internally or by exec */
		if (chain->filter_func) {
			if (chain->filter_func(chain) == -1)
				flexfatal(_("filter_func failed"));
			exit(0);
		} else {
			execvp(chain->argv[0],
			    (char **const) (chain->argv));
			lerrsf_fatal(_("exec of %s failed"),
			    chain->argv[0]);
		}

		exit(1);
	}
	/* Parent */
	close(pipes[0]);
	if (dup2(pipes[1], fileno(stdout)) == -1)
		flexfatal(_("dup2(pipes[1],1)"));
	close(pipes[1]);
	fseek(stdout, 0, SEEK_CUR);

	return true;
}

/** Truncate the chain to max_len number of filters.
 * @@param chain the current chain.
 * @@param max_len the maximum length of the chain.
 * @@return the resulting length of the chain.
 */
int 
filter_truncate(struct filter * chain, int max_len)
{
	int len = 1;

	if (!chain)
		return 0;

	while (chain->next && len < max_len) {
		chain = chain->next;
		++len;
	}

	chain->next = NULL;
	return len;
}

/** Splits the chain in order to write to a header file.
 *  Similar in spirit to the 'tee' program.
 *  The header file name is in extra.
 *  @@return 0 (zero) on success, and -1 on failure.
 */
int 
filter_tee_header(struct filter * chain)
{
	/*
	 * This function reads from stdin and writes to both the C file and
	 * the header file at the same time.
	 */

	const int readsz = 512;
	char *buf;
	int to_cfd = -1;
	FILE *to_c = NULL, *to_h = NULL;
	bool write_header;

	write_header = (chain->extra != NULL);

	/*
	 * Store a copy of the stdout pipe, which is already piped to C file
	 * through the running chain. Then create a new pipe to the H file as
	 * stdout, and fork the rest of the chain again.
	 */

	if ((to_cfd = dup(1)) == -1)
		flexfatal(_("dup(1) failed"));
	to_c = fdopen(to_cfd, "w");

	if (write_header) {
		if (freopen((char *) chain->extra, "w", stdout) == NULL)
			flexfatal(_("freopen(headerfilename) failed"));

		filter_apply_chain(chain->next);
		to_h = stdout;
	}
	/*
	 * Now to_c is a pipe to the C branch, and to_h is a pipe to the H
	 * branch.
	 */

	if (write_header) {
		fputs(check_4_gnu_m4, to_h);
		fputs("m4_changecom`'m4_dnl\n", to_h);
		fputs("m4_changequote`'m4_dnl\n", to_h);
		fputs("m4_changequote([[,]])[[]]m4_dnl\n", to_h);
		fputs("m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n", to_h);
		fputs("m4_define( [[M4_YY_IN_HEADER]],[[]])m4_dnl\n",
		    to_h);
		fprintf(to_h, "#ifndef %sHEADER_H\n", prefix);
		fprintf(to_h, "#define %sHEADER_H 1\n", prefix);
		fprintf(to_h, "#define %sIN_HEADER 1\n\n", prefix);
		fprintf(to_h,
		    "m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n",
		    headerfilename ? headerfilename : "<stdout>");

	}
	fputs(check_4_gnu_m4, to_c);
	fputs("m4_changecom`'m4_dnl\n", to_c);
	fputs("m4_changequote`'m4_dnl\n", to_c);
	fputs("m4_changequote([[,]])[[]]m4_dnl\n", to_c);
	fputs("m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n", to_c);
	fprintf(to_c, "m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n",
	    outfilename ? outfilename : "<stdout>");

	buf = malloc(readsz);
	if (!buf)
		flexerror(_("malloc failed in filter_tee_header"));
	while (fgets(buf, readsz, stdin)) {
		fputs(buf, to_c);
		if (write_header)
			fputs(buf, to_h);
	}

	if (write_header) {
		fprintf(to_h, "\n");

		/*
		 * write a fake line number. It will get fixed by the linedir
		 * filter.
		 */
		fprintf(to_h, "#line 4000 \"M4_YY_OUTFILE_NAME\"\n");

		fprintf(to_h, "#undef %sIN_HEADER\n", prefix);
		fprintf(to_h, "#endif /* %sHEADER_H */\n", prefix);
		fputs("m4_undefine( [[M4_YY_IN_HEADER]])m4_dnl\n", to_h);

		fflush(to_h);
		if (ferror(to_h))
			lerrsf(_("error writing output file %s"),
			    (char *) chain->extra);

		else if (fclose(to_h))
			lerrsf(_("error closing output file %s"),
			    (char *) chain->extra);
	}
	fflush(to_c);
	if (ferror(to_c))
		lerrsf(_("error writing output file %s"),
		    outfilename ? outfilename : "<stdout>");

	else if (fclose(to_c))
		lerrsf(_("error closing output file %s"),
		    outfilename ? outfilename : "<stdout>");

	while (wait(0) > 0);

	exit(0);
	return 0;
}

/** Adjust the line numbers in the #line directives of the generated scanner.
 * After the m4 expansion, the line numbers are incorrect since the m4 macros
 * can add or remove lines.  This only adjusts line numbers for generated code,
 * not user code. This also happens to be a good place to squeeze multiple
 * blank lines into a single blank line.
 */
int 
filter_fix_linedirs(struct filter * chain)
{
	char *buf;
	const int readsz = 512;
	int lineno = 1;
	bool in_gen = true;	/* in generated code */
	bool last_was_blank = false;

	if (!chain)
		return 0;

	buf = malloc(readsz);
	if (!buf)
		flexerror(_("malloc failed in filter_fix_linedirs"));

	while (fgets(buf, readsz, stdin)) {

		regmatch_t m[10];

		/* Check for #line directive. */
		if (buf[0] == '#'
		    && regexec(&regex_linedir, buf, 3, m, 0) == 0) {

			int num;
			char *fname;

			/* extract the line number and filename */
			num = regmatch_strtol(&m[1], buf, NULL, 0);
			fname = regmatch_dup(&m[2], buf);

			if (strcmp(fname,
				outfilename ? outfilename : "<stdout>") == 0 ||
			    strcmp(fname, headerfilename ? headerfilename :
				"<stdout>") == 0) {

				char *s1, *s2;
				char filename[MAXLINE];

				s1 = fname;
				s2 = filename;

				while ((s2 - filename) < (MAXLINE - 1) && *s1) {
					/* Escape the backslash */
					if (*s1 == '\\')
						*s2++ = '\\';
					/* Escape the double quote */
					if (*s1 == '\"')
						*s2++ = '\\';
					/* Copy the character as usual */
					*s2++ = *s1++;
				}

				*s2 = '\0';

				/* Adjust the line directives. */
				in_gen = true;
				snprintf(buf, readsz, "#line %d \"%s\"\n",
				    lineno + 1, filename);
			} else {
				/*
				 * it's a #line directive for code we didn't
				 * write
				 */
				in_gen = false;
			}

			free(fname);
			last_was_blank = false;
		}
		/* squeeze blank lines from generated code */
		else if (in_gen &&
		    regexec(&regex_blank_line, buf, 0, NULL, 0) == 0) {
			if (last_was_blank)
				continue;
			else
				last_was_blank = true;
		} else {
			/* it's a line of normal, non-empty code. */
			last_was_blank = false;
		}

		fputs(buf, stdout);
		lineno++;
	}
	fflush(stdout);
	if (ferror(stdout))
		lerrsf(_("error writing output file %s"),
		    outfilename ? outfilename : "<stdout>");

	else if (fclose(stdout))
		lerrsf(_("error closing output file %s"),
		    outfilename ? outfilename : "<stdout>");

	return 0;
}
@


1.8
log
@combine malloc/memset into calloc. from Michael W. Bombardieri
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.7 2016/12/18 06:11:23 krw Exp $ */
d177 1
a177 3
			int r;

			if ((r = chain->filter_func(chain)) == -1)
@


1.7
log
@Nuke more unused variables.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.6 2015/11/19 23:28:03 tedu Exp $ */
d53 1
a53 1
	f = malloc(sizeof(struct filter));
d55 1
a55 2
		flexerror(_("malloc failed (f) in filter_create_ext"));
	memset(f, 0, sizeof(*f));
d105 1
a105 1
	f = malloc(sizeof(struct filter));
d107 1
a107 2
		flexerror(_("malloc failed in filter_create_int"));
	memset(f, 0, sizeof(*f));
@


1.6
log
@it is not necessary to cast the result of malloc/calloc.
also replace some 0s with the modern concept of NULL
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.5 2015/11/19 23:20:34 tedu Exp $ */
a133 4
	int r;
	const int readsz = 512;
	char *buf;

@


1.5
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.4 2015/11/19 22:52:40 tedu Exp $ */
d53 1
a53 1
	f = (struct filter *) malloc(sizeof(struct filter));
d106 1
a106 1
	f = (struct filter *) malloc(sizeof(struct filter));
d296 1
a296 1
	buf = (char *) malloc(readsz);
d360 1
a360 1
	buf = (char *) malloc(readsz);
@


1.4
log
@orbital strike from moonbase knf
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.3 2015/11/19 22:25:53 tedu Exp $ */
d53 1
a53 1
	f = (struct filter *) flex_alloc(sizeof(struct filter));
d55 1
a55 1
		flexerror(_("flex_alloc failed (f) in filter_create_ext"));
d70 1
a70 1
	f->argv = flex_alloc(sizeof(char *) * (max_args + 1));
d72 1
a72 1
		flexerror(_("flex_alloc failed (f->argv) in filter_create_ext"));
d79 1
a79 1
			f->argv = flex_realloc(f->argv,
d106 1
a106 1
	f = (struct filter *) flex_alloc(sizeof(struct filter));
d108 1
a108 1
		flexerror(_("flex_alloc failed in filter_create_int"));
d296 1
a296 1
	buf = (char *) flex_alloc(readsz);
d298 1
a298 1
		flexerror(_("flex_alloc failed in filter_tee_header"));
d360 1
a360 1
	buf = (char *) flex_alloc(readsz);
d362 1
a362 1
		flexerror(_("flex_alloc failed in filter_fix_linedirs"));
@


1.3
log
@repair some of the preposterously damaged indentation
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.2 2015/11/19 22:16:43 tedu Exp $ */
d27 4
a30 4
static const char * check_4_gnu_m4 =
    "m4_dnl ifdef(`__gnu__', ,"
    "`errprint(Flex requires GNU M4. Set the PATH or set the M4 environment variable to its path name.)"
    " m4exit(2)')\n";
d43 3
a45 2
struct filter *filter_create_ext (struct filter *chain, const char *cmd,
				  ...)
d48 1
a48 1
	int     max_args;
d53 1
a53 1
	f = (struct filter *) flex_alloc (sizeof (struct filter));
d55 2
a56 2
		flexerror (_("flex_alloc failed (f) in filter_create_ext"));
	memset (f, 0, sizeof (*f));
a67 2


d70 1
a70 1
	f->argv = flex_alloc (sizeof (char *) * (max_args + 1));
d72 1
a72 1
		flexerror (_("flex_alloc failed (f->argv) in filter_create_ext"));
d75 2
a76 2
	va_start (ap, cmd);
	while ((s = va_arg (ap, const char *)) != NULL) {
d79 2
a80 2
			f->argv = flex_realloc (f->argv,
			      sizeof (char *) * (max_args + 1));
d86 1
a86 1
	va_end (ap);
d98 4
a101 3
struct filter *filter_create_int (struct filter *chain,
				  int (*filter_func) (struct filter *),
				  void *extra)
d106 1
a106 1
	f = (struct filter *) flex_alloc (sizeof (struct filter));
d108 2
a109 2
		flexerror (_("flex_alloc failed in filter_create_int"));
	memset (f, 0, sizeof (*f));
a122 1

d130 2
a131 1
bool filter_apply_chain (struct filter * chain)
d133 2
a134 2
	int     pid, pipes[2];
	int     r;
d136 1
a136 1
	char   *buf;
d139 4
a142 3
	/* Tricky recursion, since we want to begin the chain
	 * at the END. Why? Because we need all the forked processes
	 * to be children of the main flex process.
d145 1
a145 1
		filter_apply_chain (chain->next);
d149 2
a150 1
	/* Now we are the right-most unprocessed link in the chain.
d153 2
a154 2
	fflush (stdout);
	fflush (stderr);
d157 2
a158 2
	if (pipe (pipes) == -1)
		flexerror (_("pipe failed"));
d160 2
a161 2
	if ((pid = fork ()) == -1)
		flexerror (_("fork failed"));
d166 9
a174 7
        /* We need stdin (the FILE* stdin) to connect to this new pipe.
         * There is no portable way to set stdin to a new file descriptor,
         * as stdin is not an lvalue on some systems (BSD).
         * So we dup the new pipe onto the stdin descriptor and use a no-op fseek
         * to sync the stream. This is a Hail Mary situation. It seems to work.
         */
		close (pipes[1]);
d176 4
a179 4
		if (dup2 (pipes[0], fileno (stdin)) == -1)
			flexfatal (_("dup2(pipes[0],0)"));
		close (pipes[0]);
        	fseek (stdin, 0, SEEK_CUR);
d183 1
a183 1
			int     r;
d185 7
a191 8
			if ((r = chain->filter_func (chain)) == -1)
				flexfatal (_("filter_func failed"));
			exit (0);
		}
		else {
			execvp (chain->argv[0],
				(char **const) (chain->argv));
            		lerrsf_fatal ( _("exec of %s failed"),
d195 1
a195 1
		exit (1);
a196 1

d198 5
a202 5
	close (pipes[0]);
	if (dup2 (pipes[1], fileno (stdout)) == -1)
		flexfatal (_("dup2(pipes[1],1)"));
	close (pipes[1]);
	fseek (stdout, 0, SEEK_CUR);
d212 2
a213 1
int filter_truncate (struct filter *chain, int max_len)
d215 1
a215 1
	int     len = 1;
d234 2
a235 1
int filter_tee_header (struct filter *chain)
d237 3
a239 2
	/* This function reads from stdin and writes to both the C file and the
	 * header file at the same time.
d243 4
a246 4
	char   *buf;
	int     to_cfd = -1;
	FILE   *to_c = NULL, *to_h = NULL;
	bool    write_header;
d250 2
a251 1
	/* Store a copy of the stdout pipe, which is already piped to C file
d256 3
a258 3
	if ((to_cfd = dup (1)) == -1)
		flexfatal (_("dup(1) failed"));
	to_c = fdopen (to_cfd, "w");
d261 2
a262 2
		if (freopen ((char *) chain->extra, "w", stdout) == NULL)
			flexfatal (_("freopen(headerfilename) failed"));
d264 1
a264 1
		filter_apply_chain (chain->next);
d267 3
a269 2

	/* Now to_c is a pipe to the C branch, and to_h is a pipe to the H branch.
d273 13
a285 13
		fputs (check_4_gnu_m4, to_h);
		fputs ("m4_changecom`'m4_dnl\n", to_h);
		fputs ("m4_changequote`'m4_dnl\n", to_h);
		fputs ("m4_changequote([[,]])[[]]m4_dnl\n", to_h);
		fputs ("m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n", to_h);
		fputs ("m4_define( [[M4_YY_IN_HEADER]],[[]])m4_dnl\n",
		       to_h);
		fprintf (to_h, "#ifndef %sHEADER_H\n", prefix);
		fprintf (to_h, "#define %sHEADER_H 1\n", prefix);
		fprintf (to_h, "#define %sIN_HEADER 1\n\n", prefix);
		fprintf (to_h,
			 "m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n",
			 headerfilename ? headerfilename : "<stdout>");
d288 7
d296 1
a296 9
	fputs (check_4_gnu_m4, to_c);
	fputs ("m4_changecom`'m4_dnl\n", to_c);
	fputs ("m4_changequote`'m4_dnl\n", to_c);
	fputs ("m4_changequote([[,]])[[]]m4_dnl\n", to_c);
	fputs ("m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n", to_c);
	fprintf (to_c, "m4_define( [[M4_YY_OUTFILE_NAME]],[[%s]])m4_dnl\n",
		 outfilename ? outfilename : "<stdout>");

	buf = (char *) flex_alloc (readsz);
d298 3
a300 3
		flexerror (_("flex_alloc failed in filter_tee_header"));
	while (fgets (buf, readsz, stdin)) {
		fputs (buf, to_c);
d302 1
a302 1
			fputs (buf, to_h);
d306 1
a306 1
		fprintf (to_h, "\n");
d308 18
a325 15
		/* write a fake line number. It will get fixed by the linedir filter. */
		fprintf (to_h, "#line 4000 \"M4_YY_OUTFILE_NAME\"\n");

		fprintf (to_h, "#undef %sIN_HEADER\n", prefix);
		fprintf (to_h, "#endif /* %sHEADER_H */\n", prefix);
		fputs ("m4_undefine( [[M4_YY_IN_HEADER]])m4_dnl\n", to_h);

		fflush (to_h);
		if (ferror (to_h))
			lerrsf (_("error writing output file %s"),
				(char *) chain->extra);

		else if (fclose (to_h))
			lerrsf (_("error closing output file %s"),
				(char *) chain->extra);
d327 8
d336 1
a336 10
	fflush (to_c);
	if (ferror (to_c))
		lerrsf (_("error writing output file %s"),
			outfilename ? outfilename : "<stdout>");

	else if (fclose (to_c))
		lerrsf (_("error closing output file %s"),
			outfilename ? outfilename : "<stdout>");

	while (wait (0) > 0) ;
d338 1
a338 1
	exit (0);
d348 2
a349 1
int filter_fix_linedirs (struct filter *chain)
d351 1
a351 1
	char   *buf;
d353 3
a355 3
	int     lineno = 1;
	bool    in_gen = true;	/* in generated code */
	bool    last_was_blank = false;
d360 1
a360 1
	buf = (char *) flex_alloc (readsz);
d362 1
a362 1
		flexerror (_("flex_alloc failed in filter_fix_linedirs"));
d364 1
a364 1
	while (fgets (buf, readsz, stdin)) {
d370 1
a370 1
			&& regexec (&regex_linedir, buf, 3, m, 0) == 0) {
d372 2
a373 2
			int     num;
			char   *fname;
d376 2
a377 2
			num = regmatch_strtol (&m[1], buf, NULL, 0);
			fname = regmatch_dup (&m[2], buf);
d379 4
a382 4
			if (strcmp (fname,
			    outfilename ? outfilename : "<stdout>") == 0 ||
			    strcmp (fname, headerfilename ? headerfilename :
			    "<stdout>") == 0) {
d384 2
a385 2
				char    *s1, *s2;
				char	filename[MAXLINE];
d405 7
a411 5
				snprintf (buf, readsz, "#line %d \"%s\"\n",
					  lineno + 1, filename);
			}
			else {
				/* it's a #line directive for code we didn't write */
d415 1
a415 1
			free (fname);
a417 1

d420 1
a420 1
		    regexec (&regex_blank_line, buf, 0, NULL, 0) == 0) {
d425 1
a425 3
		}

		else {
d430 1
a430 1
		fputs (buf, stdout);
d433 8
a440 8
	fflush (stdout);
	if (ferror (stdout))
		lerrsf (_("error writing output file %s"),
			outfilename ? outfilename : "<stdout>");

	else if (fclose (stdout))
		lerrsf (_("error closing output file %s"),
			outfilename ? outfilename : "<stdout>");
@


1.2
log
@we don't keep vim modelines in files
@
text
@d1 1
a1 1
/* $OpenBSD: filter.c,v 1.1 2015/11/19 19:43:40 tedu Exp $ */
d71 1
a71 3
	f->argv =
		(const char **) flex_alloc (sizeof (char *) *
					    (max_args + 1));
d80 2
a81 6
			f->argv =
				(const char **) flex_realloc (f->argv,
							      sizeof (char
								      *) *
							      (max_args +
							       1));
d171 1
a171 1
clearerr(stdin);
d175 1
a175 1
        fseek (stdin, 0, SEEK_CUR);
d188 2
a189 2
            lerrsf_fatal ( _("exec of %s failed"),
                    chain->argv[0]);
d200 1
a200 1
    fseek (stdout, 0, SEEK_CUR);
d266 1
a266 1
        fputs (check_4_gnu_m4, to_h);
d270 1
a270 1
	    fputs ("m4_define([[M4_YY_NOOP]])[[]]m4_dnl\n", to_h);
d282 1
a282 1
    fputs (check_4_gnu_m4, to_c);
d371 3
a373 5
				outfilename ? outfilename : "<stdout>")
					== 0
			 || strcmp (fname,
			 	headerfilename ? headerfilename : "<stdout>")
					== 0) {
d409 2
a410 3
		else if (in_gen
			 && regexec (&regex_blank_line, buf, 0, NULL,
				     0) == 0) {
@


1.1
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a444 2

/* vim:set expandtab cindent tabstop=4 softtabstop=4 shiftwidth=4 textwidth=0: */
@

