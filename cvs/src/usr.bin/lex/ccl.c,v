head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.52
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.44
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.48
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.46
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.42
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.40
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.38
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.36
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.11.19.22.55.13;	author tedu;	state Exp;
branches;
next	1.7;
commitid	kuemS673xiRF5kXq;

1.7
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.6;
commitid	TCPdLh99ETkn9X6R;

1.6
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.21.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.29;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@mechanical knf
@
text
@/*	$OpenBSD: ccl.c,v 1.7 2015/11/19 19:43:40 tedu Exp $	*/

/* ccl - routines for character classes */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
 /* Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"

/* return true if the chr is in the ccl. Takes negation into account. */
static bool
ccl_contains(const int cclp, const int ch)
{
	int ind, len, i;

	len = ccllen[cclp];
	ind = cclmap[cclp];

	for (i = 0; i < len; ++i)
		if (ccltbl[ind + i] == ch)
			return !cclng[cclp];

	return cclng[cclp];
}


/* ccladd - add a single character to a ccl */

void 
ccladd(cclp, ch)
	int cclp;
	int ch;
{
	int ind, len, newpos, i;

	check_char(ch);

	len = ccllen[cclp];
	ind = cclmap[cclp];

	/* check to see if the character is already in the ccl */

	for (i = 0; i < len; ++i)
		if (ccltbl[ind + i] == ch)
			return;

	/* mark newlines */
	if (ch == nlch)
		ccl_has_nl[cclp] = true;

	newpos = ind + len;

	if (newpos >= current_max_ccl_tbl_size) {
		current_max_ccl_tbl_size += MAX_CCL_TBL_SIZE_INCREMENT;

		++num_reallocs;

		ccltbl = reallocate_Character_array(ccltbl,
		    current_max_ccl_tbl_size);
	}
	ccllen[cclp] = len + 1;
	ccltbl[newpos] = ch;
}

/* dump_cclp - same thing as list_character_set, but for cclps.  */

static void 
dump_cclp(FILE * file, int cclp)
{
	int i;

	putc('[', file);

	for (i = 0; i < csize; ++i) {
		if (ccl_contains(cclp, i)) {
			int start_char = i;

			putc(' ', file);

			fputs(readable_form(i), file);

			while (++i < csize && ccl_contains(cclp, i));

			if (i - 1 > start_char)
				/* this was a run */
				fprintf(file, "-%s",
				    readable_form(i - 1));

			putc(' ', file);
		}
	}

	putc(']', file);
}



/* ccl_set_diff - create a new ccl as the set difference of the two given ccls. */
int
ccl_set_diff(int a, int b)
{
	int d, ch;

	/* create new class  */
	d = cclinit();

	/*
	 * In order to handle negation, we spin through all possible chars,
	 * addding each char in a that is not in b. (This could be O(n^2),
	 * but n is small and bounded.)
	 */
	for (ch = 0; ch < csize; ++ch)
		if (ccl_contains(a, ch) && !ccl_contains(b, ch))
			ccladd(d, ch);

	/* debug */
	if (0) {
		fprintf(stderr, "ccl_set_diff (");
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, a);
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, b);
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, d);
		fprintf(stderr, "\n)\n");
	}
	return d;
}

/* ccl_set_union - create a new ccl as the set union of the two given ccls. */
int
ccl_set_union(int a, int b)
{
	int d, i;

	/* create new class  */
	d = cclinit();

	/* Add all of a */
	for (i = 0; i < ccllen[a]; ++i)
		ccladd(d, ccltbl[cclmap[a] + i]);

	/* Add all of b */
	for (i = 0; i < ccllen[b]; ++i)
		ccladd(d, ccltbl[cclmap[b] + i]);

	/* debug */
	if (0) {
		fprintf(stderr, "ccl_set_union (%d + %d = %d", a, b, d);
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, a);
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, b);
		fprintf(stderr, "\n    ");
		dump_cclp(stderr, d);
		fprintf(stderr, "\n)\n");
	}
	return d;
}


/* cclinit - return an empty ccl */

int 
cclinit()
{
	if (++lastccl >= current_maxccls) {
		current_maxccls += MAX_CCLS_INCREMENT;

		++num_reallocs;

		cclmap =
		    reallocate_integer_array(cclmap, current_maxccls);
		ccllen =
		    reallocate_integer_array(ccllen, current_maxccls);
		cclng = reallocate_integer_array(cclng, current_maxccls);
		ccl_has_nl =
		    reallocate_bool_array(ccl_has_nl,
		    current_maxccls);
	}
	if (lastccl == 1)
		/* we're making the first ccl */
		cclmap[lastccl] = 0;

	else
		/*
		 * The new pointer is just past the end of the last ccl.
		 * Since the cclmap points to the \first/ character of a ccl,
		 * adding the length of the ccl to the cclmap pointer will
		 * produce a cursor to the first free space.
		 */
		cclmap[lastccl] =
		    cclmap[lastccl - 1] + ccllen[lastccl - 1];

	ccllen[lastccl] = 0;
	cclng[lastccl] = 0;	/* ccl's start out life un-negated */
	ccl_has_nl[lastccl] = false;

	return lastccl;
}


/* cclnegate - negate the given ccl */

void 
cclnegate(cclp)
	int cclp;
{
	cclng[cclp] = 1;
	ccl_has_nl[cclp] = !ccl_has_nl[cclp];
}


/* list_character_set - list the members of a set of characters in CCL form
 *
 * Writes to the given file a character-class representation of those
 * characters present in the given CCL.  A character is present if it
 * has a non-zero value in the cset array.
 */

void 
list_character_set(file, cset)
	FILE *file;
	int cset[];
{
	int i;

	putc('[', file);

	for (i = 0; i < csize; ++i) {
		if (cset[i]) {
			int start_char = i;

			putc(' ', file);

			fputs(readable_form(i), file);

			while (++i < csize && cset[i]);

			if (i - 1 > start_char)
				/* this was a run */
				fprintf(file, "-%s",
				    readable_form(i - 1));

			putc(' ', file);
		}
	}

	putc(']', file);
}

/** Determines if the range [c1-c2] is unambiguous in a case-insensitive
 * scanner.  Specifically, if a lowercase or uppercase character, x, is in the
 * range [c1-c2], then we require that UPPERCASE(x) and LOWERCASE(x) must also
 * be in the range. If not, then this range is ambiguous, and the function
 * returns false.  For example, [@@-_] spans [a-z] but not [A-Z].  Beware that
 * [a-z] will be labeled ambiguous because it does not include [A-Z].
 *
 * @@param c1 the lower end of the range
 * @@param c2 the upper end of the range
 * @@return true if [c1-c2] is not ambiguous for a caseless scanner.
 */
bool 
range_covers_case(int c1, int c2)
{
	int i, o;

	for (i = c1; i <= c2; i++) {
		if (has_case(i)) {
			o = reverse_case(i);
			if (o < c1 || c2 < o)
				return false;
		}
	}
	return true;
}

/** Reverse the case of a character, if possible.
 * @@return c if case-reversal does not apply.
 */
int 
reverse_case(int c)
{
	return isupper(c) ? tolower(c) : (islower(c) ? toupper(c) : c);
}

/** Return true if c is uppercase or lowercase. */
bool 
has_case(int c)
{
	return (isupper(c) || islower(c)) ? true : false;
}
@


1.7
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccl.c,v 1.6 2003/06/04 17:34:44 millert Exp $	*/
d13 1
a13 1
 /*  Department of Energy and the University of California. */
d40 1
a40 1
ccl_contains (const int cclp, const int ch)
d42 1
a42 1
	int     ind, len, i;
d51 1
a51 1
    return cclng[cclp];
d57 4
a60 3
void    ccladd (cclp, ch)
     int     cclp;
     int     ch;
d62 1
a62 1
	int     ind, len, newpos, i;
d64 1
a64 1
	check_char (ch);
d86 2
a87 2
		ccltbl = reallocate_Character_array (ccltbl,
						     current_max_ccl_tbl_size);
a88 1

d95 2
a96 1
static void    dump_cclp (FILE* file, int cclp)
d100 1
a100 1
	putc ('[', file);
d103 1
a103 1
		if (ccl_contains(cclp, i)){
d106 1
a106 1
			putc (' ', file);
d108 1
a108 1
			fputs (readable_form (i), file);
d110 1
a110 1
			while (++i < csize && ccl_contains(cclp,i)) ;
d114 2
a115 2
				fprintf (file, "-%s",
					 readable_form (i - 1));
d117 1
a117 1
			putc (' ', file);
d121 1
a121 1
	putc (']', file);
d128 1
a128 1
ccl_set_diff (int a, int b)
d130 1
a130 1
    int  d, ch;
d132 2
a133 2
    /* create new class  */
    d = cclinit();
d135 21
a155 20
    /* In order to handle negation, we spin through all possible chars,
     * addding each char in a that is not in b.
     * (This could be O(n^2), but n is small and bounded.)
     */
	for ( ch = 0; ch < csize; ++ch )
        if (ccl_contains (a, ch) && !ccl_contains(b, ch))
            ccladd (d, ch);

    /* debug */
    if (0){
        fprintf(stderr, "ccl_set_diff (");
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, a);
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, b);
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, d);
        fprintf(stderr, "\n)\n");
    }
    return d;
d160 1
a160 1
ccl_set_union (int a, int b)
d162 1
a162 1
    int  d, i;
d164 2
a165 2
    /* create new class  */
    d = cclinit();
d167 20
a186 20
    /* Add all of a */
    for (i = 0; i < ccllen[a]; ++i)
		ccladd (d, ccltbl[cclmap[a] + i]);

    /* Add all of b */
    for (i = 0; i < ccllen[b]; ++i)
		ccladd (d, ccltbl[cclmap[b] + i]);

    /* debug */
    if (0){
        fprintf(stderr, "ccl_set_union (%d + %d = %d", a, b, d);
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, a);
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, b);
            fprintf(stderr, "\n    ");
            dump_cclp (stderr, d);
        fprintf(stderr, "\n)\n");
    }
    return d;
d192 2
a193 1
int     cclinit ()
d201 1
a201 1
			reallocate_integer_array (cclmap, current_maxccls);
d203 2
a204 2
			reallocate_integer_array (ccllen, current_maxccls);
		cclng = reallocate_integer_array (cclng, current_maxccls);
d206 2
a207 2
			reallocate_bool_array (ccl_has_nl,
					       current_maxccls);
a208 1

d214 5
a218 4
		/* The new pointer is just past the end of the last ccl.
		 * Since the cclmap points to the \first/ character of a
		 * ccl, adding the length of the ccl to the cclmap pointer
		 * will produce a cursor to the first free space.
d221 1
a221 1
			cclmap[lastccl - 1] + ccllen[lastccl - 1];
d233 3
a235 2
void    cclnegate (cclp)
     int     cclp;
d249 4
a252 3
void    list_character_set (file, cset)
     FILE   *file;
     int     cset[];
d256 1
a256 1
	putc ('[', file);
d262 1
a262 1
			putc (' ', file);
d264 1
a264 1
			fputs (readable_form (i), file);
d266 1
a266 1
			while (++i < csize && cset[i]) ;
d270 2
a271 2
				fprintf (file, "-%s",
					 readable_form (i - 1));
d273 1
a273 1
			putc (' ', file);
d277 1
a277 1
	putc (']', file);
d291 2
a292 1
bool range_covers_case (int c1, int c2)
d294 1
a294 1
	int     i, o;
d297 2
a298 2
		if (has_case (i)) {
			o = reverse_case (i);
d309 2
a310 1
int reverse_case (int c)
d312 1
a312 1
	return isupper (c) ? tolower (c) : (islower (c) ? toupper (c) : c);
d316 2
a317 1
bool has_case (int c)
d319 1
a319 1
	return (isupper (c) || islower (c)) ? true : false;
@


1.6
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: ccl.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /cvs/src/usr.bin/lex/ccl.c,v 1.5 2001/11/19 19:02:14 mpech Exp $ */
d38 17
d57 5
a61 5
void ccladd( cclp, ch )
int cclp;
int ch;
	{
	int ind, len, newpos, i;
d63 1
a63 1
	check_char( ch );
d70 2
a71 2
	for ( i = 0; i < len; ++i )
		if ( ccltbl[ind + i] == ch )
d74 4
d80 1
a80 2
	if ( newpos >= current_max_ccl_tbl_size )
		{
d85 3
a87 3
		ccltbl = reallocate_Character_array( ccltbl,
						current_max_ccl_tbl_size );
		}
d91 27
d120 67
d190 3
a192 4
int cclinit()
	{
	if ( ++lastccl >= current_maxccls )
		{
d197 9
a205 4
		cclmap = reallocate_integer_array( cclmap, current_maxccls );
		ccllen = reallocate_integer_array( ccllen, current_maxccls );
		cclng = reallocate_integer_array( cclng, current_maxccls );
		}
d207 1
a207 1
	if ( lastccl == 1 )
d217 2
a218 1
		cclmap[lastccl] = cclmap[lastccl - 1] + ccllen[lastccl - 1];
d222 1
d225 1
a225 1
	}
d230 3
a232 3
void cclnegate( cclp )
int cclp;
	{
d234 2
a235 1
	}
d245 4
a248 4
void list_character_set( file, cset )
FILE *file;
int cset[];
	{
d251 1
a251 1
	putc( '[', file );
d253 2
a254 4
	for ( i = 0; i < csize; ++i )
		{
		if ( cset[i] )
			{
d257 1
a257 1
			putc( ' ', file );
d259 1
a259 1
			fputs( readable_form( i ), file );
d261 1
a261 2
			while ( ++i < csize && cset[i] )
				;
d263 1
a263 1
			if ( i - 1 > start_char )
d265 2
a266 1
				fprintf( file, "-%s", readable_form( i - 1 ) );
d268 1
a268 2
			putc( ' ', file );
			}
d270 4
d275 21
a295 1
	putc( ']', file );
d297 16
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ccl.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/ccl.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $ */
@


1.4
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: ccl.c,v 1.3 1996/07/13 22:21:56 millert Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/ccl.c,v 1.3 1996/07/13 22:21:56 millert Exp $ */
d125 1
a125 1
	register int i;
d133 1
a133 1
			register int start_char = i;
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: ccl.c,v 1.2 1996/06/26 05:35:28 deraadt Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/ccl.c,v 2.9 93/09/16 20:32:14 vern Exp $ */
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/ccl.c,v 1.1.1.1 1995/10/18 08:45:29 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/ccl.c,v 1.6 1995/05/05 05:35:12 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
