head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.26
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.22
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.26;
commitid	l2fu419jw6ah0BY2;

1.26
date	2016.12.25.16.40.06;	author krw;	state Exp;
branches;
next	1.25;
commitid	qVghsbRQPfYVwJZ6;

1.25
date	2015.12.11.00.08.43;	author mmcc;	state Exp;
branches;
next	1.24;
commitid	wImmn3Rgz2JgBzph;

1.24
date	2015.11.20.04.07.43;	author millert;	state Exp;
branches;
next	1.23;
commitid	BE1bBtn1oDgRZH7X;

1.23
date	2015.11.20.04.06.48;	author millert;	state Exp;
branches;
next	1.22;
commitid	ZKDmPkkjxsEOKEVn;

1.22
date	2015.11.20.04.04.40;	author millert;	state Exp;
branches;
next	1.21;
commitid	kXG2rHLDnl1QwmSa;

1.21
date	2015.11.19.23.34.56;	author mmcc;	state Exp;
branches;
next	1.20;
commitid	sr9v9L5qZs3TeEb4;

1.20
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.19;
commitid	BIjrMDODd4w0xnpk;

1.19
date	2015.11.19.22.58.59;	author tedu;	state Exp;
branches;
next	1.18;
commitid	O7uCMJk7zcyL3Jk1;

1.18
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.17;
commitid	cuVuNj9APX2eFzx2;

1.17
date	2015.11.19.22.35.19;	author tedu;	state Exp;
branches;
next	1.16;
commitid	wto5sOnPH8auAqBu;

1.16
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.15;
commitid	TCPdLh99ETkn9X6R;

1.15
date	2015.10.10.05.47.54;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	QjUE7FHXLV3OMkyv;

1.14
date	2014.03.16.18.38.30;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2011.06.08.20.22.02;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.03.21.20.17;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.22.49.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.00.56.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.30.10.53.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.08.17.03.20.25;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/*	$OpenBSD: main.c,v 1.26 2016/12/25 16:40:06 krw Exp $	*/

/* flex - tool to generate fast lexical analyzers */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */



#include "flexdef.h"
#include "version.h"
#include "options.h"
#include "tables.h"

static char flex_version[] = FLEX_VERSION;

/* declare functions that have forward references */

void flexinit PROTO((int, char **));
void readin PROTO((void));
void set_up_initial_allocations PROTO((void));
static char *basename2 PROTO((char *path, int should_strip_ext));


/* these globals are all defined and commented in flexdef.h */
int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
int interactive, lex_compat, posix_compat, do_yylineno, useecs, fulltbl,
 usemecs;
int fullspd, gen_line_dirs, performance_report, backing_up_report;
int C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap, csize;
int reentrant, bison_bridge_lval, bison_bridge_lloc;
int yymore_used, reject, real_reject, continued_action, in_rule;
int yymore_really_used, reject_really_used;
int datapos, dataline, linenum;
FILE *skelfile = NULL;
int skel_ind = 0;
char *action_array;
int action_size, defs1_offset, prolog_offset, action_offset, action_index;
char *infilename = NULL, *outfilename = NULL, *headerfilename = NULL;
int did_outfilename;
char *prefix, *yyclass, *extra_type = NULL;
int do_stdinit, use_stdout;
int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
int maximum_mns, current_mns, current_max_rules;
int num_rules, num_eof_rules, default_rule, lastnfa;
int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
int *accptnum, *assoc_rule, *state_type;
int *rule_type, *rule_linenum, *rule_useful;
int current_state_type;
int variable_trailing_context_rules;
int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
int tecbck[CSIZE + 1];
int lastsc, *scset, *scbol, *scxclu, *sceof;
int current_max_scs;
char **scname;
int current_max_dfa_size, current_max_xpairs;
int current_max_template_xpairs, current_max_dfas;
int lastdfa, *nxt, *chk, *tnxt;
int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
union dfaacc_union *dfaacc;
int *accsiz, *dhash, numas;
int numsnpairs, jambase, jamstate;
int lastccl, *cclmap, *ccllen, *cclng, cclreuse;
int current_maxccls, current_max_ccl_tbl_size;
u_char *ccltbl;
char nmstr[MAXLINE];
int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
int num_backing_up, bol_needed;
FILE *backing_up_file;
int end_of_buffer_state;
char **input_files;
int num_input_files;
jmp_buf flex_main_jmp_buf;
bool *rule_has_nl, *ccl_has_nl;
int nlch = '\n';
bool ansi_func_defs, ansi_func_protos;

bool tablesext, tablesverify, gentables;
char *tablesfilename = 0, *tablesname = 0;
struct yytbl_writer tableswr;

/* Make sure program_name is initialized so we don't crash if writing
 * out an error message before getting the program name from argv[0].
 */
char *program_name = "flex";

static const char *outfile_template = "lex.%s.%s";
static const char *backing_name = "lex.backup";
static const char *tablesfile_template = "lex.%s.tables";

/* From scan.l */
extern FILE *yyout;

static char outfile_path[MAXLINE];
static int outfile_created = 0;
static char *skelname = NULL;
static int _stdout_closed = 0;	/* flag to prevent double-fclose() on stdout. */
const char *escaped_qstart = "[[]]M4_YY_NOOP[M4_YY_NOOP[M4_YY_NOOP[[]]";
const char *escaped_qend = "[[]]M4_YY_NOOP]M4_YY_NOOP]M4_YY_NOOP[[]]";

/* For debugging. The max number of filters to apply to skeleton. */
static int preproc_level = 1000;

int flex_main PROTO((int argc, char *argv[]));
int main PROTO((int argc, char *argv[]));

int
flex_main(argc, argv)
	int argc;
	char *argv[];
{
	int i, exit_status, child_status;

	/*
	 * Set a longjmp target. Yes, I know it's a hack, but it gets worse:
	 * The return value of setjmp, if non-zero, is the desired exit code
	 * PLUS ONE. For example, if you want 'main' to return with code '2',
	 * then call longjmp() with an argument of 3. This is because it is
	 * invalid to specify a value of 0 to longjmp. FLEX_EXIT(n) should be
	 * used instead of exit(n);
	 */
	exit_status = setjmp(flex_main_jmp_buf);
	if (exit_status) {
		if (stdout && !_stdout_closed && !ferror(stdout)) {
			fflush(stdout);
			fclose(stdout);
		}
		while (wait(&child_status) > 0) {
			if (!WIFEXITED(child_status)
			    || WEXITSTATUS(child_status) != 0) {
				/*
				 * report an error of a child
				 */
				if (exit_status <= 1)
					exit_status = 2;

			}
		}
		return exit_status - 1;
	}
	flexinit(argc, argv);

	readin();

	skelout();
	/* %% [1.5] DFA */
	ntod();

	for (i = 1; i <= num_rules; ++i)
		if (!rule_useful[i] && i != default_rule)
			line_warning(_("rule cannot be matched"),
			    rule_linenum[i]);

	if (spprdflt && !reject && rule_useful[default_rule])
		line_warning(_
		    ("-s option given but default rule can be matched"),
		    rule_linenum[default_rule]);

	/* Generate the C state transition tables from the DFA. */
	make_tables();

	/*
	 * Note, flexend does not return.  It exits with its argument as
	 * status.
	 */
	flexend(0);

	return 0;		/* keep compilers/lint happy */
}

/* Wrapper around flex_main, so flex_main can be built as a library. */
int
main(argc, argv)
	int argc;
	char *argv[];
{
#if ENABLE_NLS
#if HAVE_LOCALE_H
	setlocale(LC_MESSAGES, "");
	setlocale(LC_CTYPE, "");
	textdomain(PACKAGE);
	bindtextdomain(PACKAGE, LOCALEDIR);
#endif
#endif

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1) {
		fprintf(stderr, _("%s: pledge\n"),
		    program_name);
		exit(1);
	}
	return flex_main(argc, argv);
}

/* check_options - check user-specified options */

void
check_options()
{
	int i;

	if (lex_compat) {
		if (C_plus_plus)
			flexerror(_("Can't use -+ with -l option"));

		if (fulltbl || fullspd)
			flexerror(_("Can't use -f or -F with -l option"));

		if (reentrant || bison_bridge_lval)
			flexerror(_
			    ("Can't use --reentrant or --bison-bridge with -l option"));

		yytext_is_array = true;
		do_yylineno = true;
		use_read = false;
	}
#if 0
	/* This makes no sense whatsoever. I'm removing it. */
	if (do_yylineno)
		/* This should really be "maintain_backup_tables = true" */
		reject_really_used = true;
#endif

	if (csize == unspecified) {
		if ((fulltbl || fullspd) && !useecs)
			csize = DEFAULT_CSIZE;
		else
			csize = CSIZE;
	}
	if (interactive == unspecified) {
		if (fulltbl || fullspd)
			interactive = false;
		else
			interactive = true;
	}
	if (fulltbl || fullspd) {
		if (usemecs)
			flexerror(_
			    ("-Cf/-CF and -Cm don't make sense together"));

		if (interactive)
			flexerror(_("-Cf/-CF and -I are incompatible"));

		if (lex_compat)
			flexerror(_
			    ("-Cf/-CF are incompatible with lex-compatibility mode"));


		if (fulltbl && fullspd)
			flexerror(_
			    ("-Cf and -CF are mutually exclusive"));
	}
	if (C_plus_plus && fullspd)
		flexerror(_("Can't use -+ with -CF option"));

	if (C_plus_plus && yytext_is_array) {
		warn(_("%array incompatible with -+ option"));
		yytext_is_array = false;
	}
	if (C_plus_plus && (reentrant))
		flexerror(_("Options -+ and --reentrant are mutually exclusive."));

	if (C_plus_plus && bison_bridge_lval)
		flexerror(_("bison bridge not supported for the C++ scanner."));


	if (useecs) {		/* Set up doubly-linked equivalence classes. */

		/*
		 * We loop all the way up to csize, since ecgroup[csize] is
		 * the position used for NUL characters.
		 */
		ecgroup[1] = NIL;

		for (i = 2; i <= csize; ++i) {
			ecgroup[i] = i - 1;
			nextecm[i - 1] = i;
		}

		nextecm[csize] = NIL;
	} else {
		/* Put everything in its own equivalence class. */
		for (i = 1; i <= csize; ++i) {
			ecgroup[i] = i;
			nextecm[i] = BAD_SUBSCRIPT;	/* to catch errors */
		}
	}

	if (!ansi_func_defs)
		buf_m4_define(&m4defs_buf, "M4_YY_NO_ANSI_FUNC_DEFS", NULL);

	if (!ansi_func_protos)
		buf_m4_define(&m4defs_buf, "M4_YY_NO_ANSI_FUNC_PROTOS", NULL);

	if (extra_type)
		buf_m4_define(&m4defs_buf, "M4_EXTRA_TYPE_DEFS", extra_type);

	if (!use_stdout) {
		FILE *prev_stdout;

		if (!did_outfilename) {
			char *suffix;

			if (C_plus_plus)
				suffix = "cc";
			else
				suffix = "c";

			snprintf(outfile_path, sizeof(outfile_path), outfile_template,
			    prefix, suffix);

			outfilename = outfile_path;
		}
		prev_stdout = freopen(outfilename, "w+", stdout);

		if (prev_stdout == NULL)
			lerrsf(_("could not create %s"), outfilename);

		outfile_created = 1;
	}
	/* Setup the filter chain. */
	output_chain = filter_create_int(NULL, filter_tee_header, headerfilename);
	filter_create_ext(output_chain, M4, "-P", 0);
	filter_create_int(output_chain, filter_fix_linedirs, NULL);

	/* For debugging, only run the requested number of filters. */
	if (preproc_level > 0) {
		filter_truncate(output_chain, preproc_level);
		filter_apply_chain(output_chain);
	}
	yyout = stdout;


	/* always generate the tablesverify flag. */
	buf_m4_define(&m4defs_buf, "M4_YY_TABLES_VERIFY", tablesverify ? "1" : "0");
	if (tablesext)
		gentables = false;

	if (tablesverify)
		/* force generation of C tables. */
		gentables = true;


	if (tablesext) {
		FILE *tablesout;
		struct yytbl_hdr hdr;
		char *pname = 0;
		int nbytes = 0;

		buf_m4_define(&m4defs_buf, "M4_YY_TABLES_EXTERNAL", NULL);

		if (!tablesfilename) {
			nbytes = strlen(prefix) + strlen(tablesfile_template) + 2;
			tablesfilename = pname = (char *) calloc(nbytes, 1);
			snprintf(pname, nbytes, tablesfile_template, prefix);
		}
		if ((tablesout = fopen(tablesfilename, "w")) == NULL)
			lerrsf(_("could not create %s"), tablesfilename);
		free(pname);
		tablesfilename = 0;

		yytbl_writer_init(&tableswr, tablesout);

		nbytes = strlen(prefix) + strlen("tables") + 2;
		tablesname = (char *) calloc(nbytes, 1);
		snprintf(tablesname, nbytes, "%stables", prefix);
		yytbl_hdr_init(&hdr, flex_version, tablesname);

		if (yytbl_hdr_fwrite(&tableswr, &hdr) <= 0)
			flexerror(_("could not write tables header"));
	}
	if (skelname && (skelfile = fopen(skelname, "r")) == NULL)
		lerrsf(_("can't open skeleton file %s"), skelname);

	if (reentrant) {
		buf_m4_define(&m4defs_buf, "M4_YY_REENTRANT", NULL);
		if (yytext_is_array)
			buf_m4_define(&m4defs_buf, "M4_YY_TEXT_IS_ARRAY", NULL);
	}
	if (bison_bridge_lval)
		buf_m4_define(&m4defs_buf, "M4_YY_BISON_LVAL", NULL);

	if (bison_bridge_lloc)
		buf_m4_define(&m4defs_buf, "<M4_YY_BISON_LLOC>", NULL);

	buf_m4_define(&m4defs_buf, "M4_YY_PREFIX", prefix);

	if (did_outfilename)
		line_directive_out(stdout, 0);

	if (do_yylineno)
		buf_m4_define(&m4defs_buf, "M4_YY_USE_LINENO", NULL);

	/* Create the alignment type. */
	buf_strdefine(&userdef_buf, "YY_INT_ALIGNED",
	    long_align ? "long int" : "short int");

	/* Define the start condition macros. */
	{
		struct Buf tmpbuf;
		buf_init(&tmpbuf, sizeof(char));
		for (i = 1; i <= lastsc; i++) {
			char *str, *fmt = "#define %s %d\n";
			size_t strsz;

			str = (char *) malloc(strsz = strlen(fmt) + strlen(scname[i]) + (int) (1 + log10(i)) + 2);
			if (!str)
				flexfatal(_("allocation of macro definition failed"));
			snprintf(str, strsz, fmt, scname[i], i - 1);
			buf_strappend(&tmpbuf, str);
			free(str);
		}
		buf_m4_define(&m4defs_buf, "M4_YY_SC_DEFS", tmpbuf.elts);
		buf_destroy(&tmpbuf);
	}

	/* This is where we begin writing to the file. */

	/* Dump the %top code. */
	if (top_buf.elts)
		outn((char *) top_buf.elts);

	/* Dump the m4 definitions. */
	buf_print_strings(&m4defs_buf, stdout);
	m4defs_buf.nelts = 0;	/* memory leak here. */

	/* Place a bogus line directive, it will be fixed in the filter. */
	outn("#line 0 \"M4_YY_OUTFILE_NAME\"\n");

	/* Dump the user defined preproc directives. */
	if (userdef_buf.elts)
		outn((char *) (userdef_buf.elts));

	skelout();
	/* %% [1.0] */
}

/* flexend - terminate flex
 *
 * note
 *    This routine does not return.
 */

void
flexend(exit_status)
	int exit_status;

{
	static int called_before = -1;	/* prevent infinite recursion. */
	int tblsiz;

	if (++called_before)
		FLEX_EXIT(exit_status);

	if (skelfile != NULL) {
		if (ferror(skelfile))
			lerrsf(_("input error reading skeleton file %s"),
			    skelname);

		else if (fclose(skelfile))
			lerrsf(_("error closing skeleton file %s"),
			    skelname);
	}
#if 0
	fprintf(header_out,
	    "#ifdef YY_HEADER_EXPORT_START_CONDITIONS\n");
	fprintf(header_out,
	    "/* Beware! Start conditions are not prefixed. */\n");

	/* Special case for "INITIAL" */
	fprintf(header_out,
	    "#undef INITIAL\n#define INITIAL 0\n");
	for (i = 2; i <= lastsc; i++)
		fprintf(header_out, "#define %s %d\n", scname[i], i - 1);
	fprintf(header_out,
	    "#endif /* YY_HEADER_EXPORT_START_CONDITIONS */\n\n");

	/*
	 * Kill ALL flex-related macros. This is so the user can #include
	 * more than one generated header file.
	 */
	fprintf(header_out, "#ifndef YY_HEADER_NO_UNDEFS\n");
	fprintf(header_out,
	    "/* Undefine all internal macros, etc., that do no belong in the header. */\n\n");

	{
		const char *undef_list[] = {

			"BEGIN",
			"ECHO",
			"EOB_ACT_CONTINUE_SCAN",
			"EOB_ACT_END_OF_FILE",
			"EOB_ACT_LAST_MATCH",
			"FLEX_SCANNER",
			"FLEX_STD",
			"REJECT",
			"YYFARGS0",
			"YYFARGS1",
			"YYFARGS2",
			"YYFARGS3",
			"YYLMAX",
			"YYSTATE",
			"YY_AT_BOL",
			"YY_BREAK",
			"YY_BUFFER_EOF_PENDING",
			"YY_BUFFER_NEW",
			"YY_BUFFER_NORMAL",
			"YY_BUF_SIZE",
			"M4_YY_CALL_LAST_ARG",
			"M4_YY_CALL_ONLY_ARG",
			"YY_CURRENT_BUFFER",
			"YY_DECL",
			"M4_YY_DECL_LAST_ARG",
			"M4_YY_DEF_LAST_ARG",
			"M4_YY_DEF_ONLY_ARG",
			"YY_DO_BEFORE_ACTION",
			"YY_END_OF_BUFFER",
			"YY_END_OF_BUFFER_CHAR",
			"YY_EXIT_FAILURE",
			"YY_EXTRA_TYPE",
			"YY_FATAL_ERROR",
			"YY_FLEX_DEFINED_ECHO",
			"YY_FLEX_LEX_COMPAT",
			"YY_FLEX_MAJOR_VERSION",
			"YY_FLEX_MINOR_VERSION",
			"YY_FLEX_SUBMINOR_VERSION",
			"YY_FLUSH_BUFFER",
			"YY_G",
			"YY_INPUT",
			"YY_INTERACTIVE",
			"YY_INT_ALIGNED",
			"YY_LAST_ARG",
			"YY_LESS_LINENO",
			"YY_LEX_ARGS",
			"YY_LEX_DECLARATION",
			"YY_LEX_PROTO",
			"YY_MAIN",
			"YY_MORE_ADJ",
			"YY_NEED_STRLEN",
			"YY_NEW_FILE",
			"YY_NULL",
			"YY_NUM_RULES",
			"YY_ONLY_ARG",
			"YY_PARAMS",
			"YY_PROTO",
			"M4_YY_PROTO_LAST_ARG",
			"M4_YY_PROTO_ONLY_ARG void",
			"YY_READ_BUF_SIZE",
			"YY_REENTRANT",
			"YY_RESTORE_YY_MORE_OFFSET",
			"YY_RULE_SETUP",
			"YY_SC_TO_UI",
			"YY_SKIP_YYWRAP",
			"YY_START",
			"YY_START_STACK_INCR",
			"YY_STATE_EOF",
			"YY_STDINIT",
			"YY_TRAILING_HEAD_MASK",
			"YY_TRAILING_MASK",
			"YY_USER_ACTION",
			"YY_USE_CONST",
			"YY_USE_PROTOS",
			"unput",
			"yyTABLES_NAME",
			"yy_create_buffer",
			"yy_delete_buffer",
			"yy_flex_debug",
			"yy_flush_buffer",
			"yy_init_buffer",
			"yy_load_buffer_state",
			"yy_new_buffer",
			"yy_scan_buffer",
			"yy_scan_bytes",
			"yy_scan_string",
			"yy_set_bol",
			"yy_set_interactive",
			"yy_switch_to_buffer",
			"yypush_buffer_state",
			"yypop_buffer_state",
			"yyensure_buffer_stack",
			"yyalloc",
			"yyconst",
			"yyextra",
			"yyfree",
			"yyget_debug",
			"yyget_extra",
			"yyget_in",
			"yyget_leng",
			"yyget_lineno",
			"yyget_lloc",
			"yyget_lval",
			"yyget_out",
			"yyget_text",
			"yyin",
			"yyleng",
			"yyless",
			"yylex",
			"yylex_destroy",
			"yylex_init",
			"yylex_init_extra",
			"yylineno",
			"yylloc",
			"yylval",
			"yymore",
			"yyout",
			"yyrealloc",
			"yyrestart",
			"yyset_debug",
			"yyset_extra",
			"yyset_in",
			"yyset_lineno",
			"yyset_lloc",
			"yyset_lval",
			"yyset_out",
			"yytables_destroy",
			"yytables_fload",
			"yyterminate",
			"yytext",
			"yytext_ptr",
			"yywrap",

			/* must be null-terminated */
		NULL};


		for (i = 0; undef_list[i] != NULL; i++)
			fprintf(header_out, "#undef %s\n", undef_list[i]);
	}

	/* undef any of the auto-generated symbols. */
	for (i = 0; i < defs_buf.nelts; i++) {

		/* don't undef start conditions */
		if (sclookup(((char **) defs_buf.elts)[i]) > 0)
			continue;
		fprintf(header_out, "#undef %s\n",
		    ((char **) defs_buf.elts)[i]);
	}

	fprintf(header_out,
	    "#endif /* !YY_HEADER_NO_UNDEFS */\n");
	fprintf(header_out, "\n");
	fprintf(header_out, "#undef %sIN_HEADER\n", prefix);
	fprintf(header_out, "#endif /* %sHEADER_H */\n", prefix);

	if (ferror(header_out))
		lerrsf(_("error creating header file %s"),
		    headerfilename);
	fflush(header_out);
	fclose(header_out);
#endif

	if (exit_status != 0 && outfile_created) {
		if (ferror(stdout))
			lerrsf(_("error writing output file %s"),
			    outfilename);

		else if ((_stdout_closed = 1) && fclose(stdout))
			lerrsf(_("error closing output file %s"),
			    outfilename);

		else if (unlink(outfilename))
			lerrsf(_("error deleting output file %s"),
			    outfilename);
	}
	if (backing_up_report && backing_up_file) {
		if (num_backing_up == 0)
			fprintf(backing_up_file, _("No backing up.\n"));
		else if (fullspd || fulltbl)
			fprintf(backing_up_file,
			    _
			    ("%d backing up (non-accepting) states.\n"),
			    num_backing_up);
		else
			fprintf(backing_up_file,
			    _("Compressed tables always back up.\n"));

		if (ferror(backing_up_file))
			lerrsf(_("error writing backup file %s"),
			    backing_name);

		else if (fclose(backing_up_file))
			lerrsf(_("error closing backup file %s"),
			    backing_name);
	}
	if (printstats) {
		fprintf(stderr, _("%s version %s usage statistics:\n"),
		    program_name, flex_version);

		fprintf(stderr, _("  scanner options: -"));

		if (C_plus_plus)
			putc('+', stderr);
		if (backing_up_report)
			putc('b', stderr);
		if (ddebug)
			putc('d', stderr);
		if (sf_case_ins())
			putc('i', stderr);
		if (lex_compat)
			putc('l', stderr);
		if (posix_compat)
			putc('X', stderr);
		if (performance_report > 0)
			putc('p', stderr);
		if (performance_report > 1)
			putc('p', stderr);
		if (spprdflt)
			putc('s', stderr);
		if (reentrant)
			fputs("--reentrant", stderr);
		if (bison_bridge_lval)
			fputs("--bison-bridge", stderr);
		if (bison_bridge_lloc)
			fputs("--bison-locations", stderr);
		if (use_stdout)
			putc('t', stderr);
		if (printstats)
			putc('v', stderr);	/* always true! */
		if (nowarn)
			putc('w', stderr);
		if (interactive == false)
			putc('B', stderr);
		if (interactive == true)
			putc('I', stderr);
		if (!gen_line_dirs)
			putc('L', stderr);
		if (trace)
			putc('T', stderr);

		if (csize == unspecified)
			/*
			 * We encountered an error fairly early on, so csize
			 * never got specified.  Define it now, to prevent
			 * bogus table sizes being written out below.
			 */
			csize = 256;

		if (csize == 128)
			putc('7', stderr);
		else
			putc('8', stderr);

		fprintf(stderr, " -C");

		if (long_align)
			putc('a', stderr);
		if (fulltbl)
			putc('f', stderr);
		if (fullspd)
			putc('F', stderr);
		if (useecs)
			putc('e', stderr);
		if (usemecs)
			putc('m', stderr);
		if (use_read)
			putc('r', stderr);

		if (did_outfilename)
			fprintf(stderr, " -o%s", outfilename);

		if (skelname)
			fprintf(stderr, " -S%s", skelname);

		if (strcmp(prefix, "yy"))
			fprintf(stderr, " -P%s", prefix);

		putc('\n', stderr);

		fprintf(stderr, _("  %d/%d NFA states\n"),
		    lastnfa, current_mns);
		fprintf(stderr, _("  %d/%d DFA states (%d words)\n"),
		    lastdfa, current_max_dfas, totnst);
		fprintf(stderr, _("  %d rules\n"),
		    num_rules + num_eof_rules -
		    1 /* - 1 for def. rule */ );

		if (num_backing_up == 0)
			fprintf(stderr, _("  No backing up\n"));
		else if (fullspd || fulltbl)
			fprintf(stderr,
			    _
			    ("  %d backing-up (non-accepting) states\n"),
			    num_backing_up);
		else
			fprintf(stderr,
			    _
			    ("  Compressed tables always back-up\n"));

		if (bol_needed)
			fprintf(stderr,
			    _("  Beginning-of-line patterns used\n"));

		fprintf(stderr, _("  %d/%d start conditions\n"), lastsc,
		    current_max_scs);
		fprintf(stderr,
		    _
		    ("  %d epsilon states, %d double epsilon states\n"),
		    numeps, eps2);

		if (lastccl == 0)
			fprintf(stderr, _("  no character classes\n"));
		else
			fprintf(stderr,
			    _
			    ("  %d/%d character classes needed %d/%d words of storage, %d reused\n"),
			    lastccl, current_maxccls,
			    cclmap[lastccl] + ccllen[lastccl],
			    current_max_ccl_tbl_size, cclreuse);

		fprintf(stderr, _("  %d state/nextstate pairs created\n"),
		    numsnpairs);
		fprintf(stderr,
		    _("  %d/%d unique/duplicate transitions\n"),
		    numuniq, numdup);

		if (fulltbl) {
			tblsiz = lastdfa * numecs;
			fprintf(stderr, _("  %d table entries\n"),
			    tblsiz);
		} else {
			tblsiz = 2 * (lastdfa + numtemps) + 2 * tblend;

			fprintf(stderr,
			    _("  %d/%d base-def entries created\n"),
			    lastdfa + numtemps, current_max_dfas);
			fprintf(stderr,
			    _
			    ("  %d/%d (peak %d) nxt-chk entries created\n"),
			    tblend, current_max_xpairs, peakpairs);
			fprintf(stderr,
			    _
			    ("  %d/%d (peak %d) template nxt-chk entries created\n"),
			    numtemps * nummecs,
			    current_max_template_xpairs,
			    numtemps * numecs);
			fprintf(stderr, _("  %d empty table entries\n"),
			    nummt);
			fprintf(stderr, _("  %d protos created\n"),
			    numprots);
			fprintf(stderr,
			    _("  %d templates created, %d uses\n"),
			    numtemps, tmpuses);
		}

		if (useecs) {
			tblsiz = tblsiz + csize;
			fprintf(stderr,
			    _
			    ("  %d/%d equivalence classes created\n"),
			    numecs, csize);
		}
		if (usemecs) {
			tblsiz = tblsiz + numecs;
			fprintf(stderr,
			    _
			    ("  %d/%d meta-equivalence classes created\n"),
			    nummecs, csize);
		}
		fprintf(stderr,
		    _
		    ("  %d (%d saved) hash collisions, %d DFAs equal\n"),
		    hshcol, hshsave, dfaeql);
		fprintf(stderr, _("  %d sets of reallocations needed\n"),
		    num_reallocs);
		fprintf(stderr, _("  %d total table entries needed\n"),
		    tblsiz);
	}
	FLEX_EXIT(exit_status);
}


/* flexinit - initialize flex */

void
flexinit(argc, argv)
	int argc;
	char **argv;
{
	int i, sawcmpflag, rv, optind;
	char *arg;
	scanopt_t sopt;

	printstats = syntaxerror = trace = spprdflt = false;
	lex_compat = posix_compat = C_plus_plus = backing_up_report =
	    ddebug = fulltbl = false;
	fullspd = long_align = nowarn = yymore_used = continued_action =
	    false;
	do_yylineno = yytext_is_array = in_rule = reject = do_stdinit =
	    false;
	yymore_really_used = reject_really_used = unspecified;
	interactive = csize = unspecified;
	do_yywrap = gen_line_dirs = usemecs = useecs = true;
	reentrant = bison_bridge_lval = bison_bridge_lloc = false;
	performance_report = 0;
	did_outfilename = 0;
	prefix = "yy";
	yyclass = 0;
	use_read = use_stdout = false;
	tablesext = tablesverify = false;
	gentables = true;
	tablesfilename = tablesname = NULL;
	ansi_func_defs = ansi_func_protos = true;

	sawcmpflag = false;

	/* Initialize dynamic array for holding the rule actions. */
	action_size = 2048;	/* default size of action array in bytes */
	action_array = allocate_character_array(action_size);
	defs1_offset = prolog_offset = action_offset = action_index = 0;
	action_array[0] = '\0';

	/* Initialize any buffers. */
	buf_init(&userdef_buf, sizeof(char));	/* one long string */
	buf_init(&defs_buf, sizeof(char *));	/* list of strings */
	buf_init(&yydmap_buf, sizeof(char));	/* one long string */
	buf_init(&top_buf, sizeof(char));	/* one long string */

	{
		const char *m4defs_init_str[] = {"m4_changequote\n",
		"m4_changequote([[, ]])\n"};
		buf_init(&m4defs_buf, sizeof(char *));
		buf_append(&m4defs_buf, &m4defs_init_str, 2);
	}

	sf_init();

	/* initialize regex lib */
	flex_init_regex();

	/* Enable C++ if program name ends with '+'. */
	program_name = basename2(argv[0], 0);

	if (program_name[0] != '\0' &&
	    program_name[strlen(program_name) - 1] == '+')
		C_plus_plus = true;

	/* read flags */
	sopt = scanopt_init(flexopts, argc, argv, 0);
	if (!sopt) {
		/* This will only happen when flexopts array is altered. */
		fprintf(stderr,
		    _("Internal error. flexopts are malformed.\n"));
		FLEX_EXIT(1);
	}
	while ((rv = scanopt(sopt, &arg, &optind)) != 0) {

		if (rv < 0) {
			/*
			 * Scanopt has already printed an option-specific
			 * error message.
			 */
			fprintf(stderr,
			    _
			    ("Try `%s --help' for more information.\n"),
			    program_name);
			FLEX_EXIT(1);
		}
		switch ((enum flexopt_flag_t) rv) {
		case OPT_CPLUSPLUS:
			C_plus_plus = true;
			break;

		case OPT_BATCH:
			interactive = false;
			break;

		case OPT_BACKUP:
			backing_up_report = true;
			break;

		case OPT_DONOTHING:
			break;

		case OPT_COMPRESSION:
			if (!sawcmpflag) {
				useecs = false;
				usemecs = false;
				fulltbl = false;
				sawcmpflag = true;
			}
			for (i = 0; arg && arg[i] != '\0'; i++)
				switch (arg[i]) {
				case 'a':
					long_align = true;
					break;

				case 'e':
					useecs = true;
					break;

				case 'F':
					fullspd = true;
					break;

				case 'f':
					fulltbl = true;
					break;

				case 'm':
					usemecs = true;
					break;

				case 'r':
					use_read = true;
					break;

				default:
					lerrif(_
					    ("unknown -C option '%c'"),
					    (int) arg[i]);
					break;
				}
			break;

		case OPT_DEBUG:
			ddebug = true;
			break;

		case OPT_NO_DEBUG:
			ddebug = false;
			break;

		case OPT_FULL:
			useecs = usemecs = false;
			use_read = fulltbl = true;
			break;

		case OPT_FAST:
			useecs = usemecs = false;
			use_read = fullspd = true;
			break;

		case OPT_HELP:
			usage();
			FLEX_EXIT(0);

		case OPT_INTERACTIVE:
			interactive = true;
			break;

		case OPT_CASE_INSENSITIVE:
			sf_set_case_ins(true);
			break;

		case OPT_LEX_COMPAT:
			lex_compat = true;
			break;

		case OPT_POSIX_COMPAT:
			posix_compat = true;
			break;

		case OPT_PREPROC_LEVEL:
			preproc_level = strtol(arg, NULL, 0);
			break;

		case OPT_MAIN:
			buf_strdefine(&userdef_buf, "YY_MAIN", "1");
			do_yywrap = false;
			break;

		case OPT_NO_MAIN:
			buf_strdefine(&userdef_buf, "YY_MAIN", "0");
			break;

		case OPT_NO_LINE:
			gen_line_dirs = false;
			break;

		case OPT_OUTFILE:
			outfilename = arg;
			did_outfilename = 1;
			break;

		case OPT_PREFIX:
			prefix = arg;
			break;

		case OPT_PERF_REPORT:
			++performance_report;
			break;

		case OPT_BISON_BRIDGE:
			bison_bridge_lval = true;
			break;

		case OPT_BISON_BRIDGE_LOCATIONS:
			bison_bridge_lval = bison_bridge_lloc = true;
			break;

		case OPT_REENTRANT:
			reentrant = true;
			break;

		case OPT_NO_REENTRANT:
			reentrant = false;
			break;

		case OPT_SKEL:
			skelname = arg;
			break;

		case OPT_DEFAULT:
			spprdflt = false;
			break;

		case OPT_NO_DEFAULT:
			spprdflt = true;
			break;

		case OPT_STDOUT:
			use_stdout = true;
			break;

		case OPT_NO_UNISTD_H:
			//buf_strdefine(&userdef_buf, "YY_NO_UNISTD_H", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_UNISTD_H", 0);
			break;

		case OPT_TABLES_FILE:
			tablesext = true;
			tablesfilename = arg;
			break;

		case OPT_TABLES_VERIFY:
			tablesverify = true;
			break;

		case OPT_TRACE:
			trace = true;
			break;

		case OPT_VERBOSE:
			printstats = true;
			break;

		case OPT_VERSION:
			printf(_("%s %s\n"), program_name, flex_version);
			FLEX_EXIT(0);

		case OPT_WARN:
			nowarn = false;
			break;

		case OPT_NO_WARN:
			nowarn = true;
			break;

		case OPT_7BIT:
			csize = 128;
			break;

		case OPT_8BIT:
			csize = CSIZE;
			break;

		case OPT_ALIGN:
			long_align = true;
			break;

		case OPT_NO_ALIGN:
			long_align = false;
			break;

		case OPT_ALWAYS_INTERACTIVE:
			buf_m4_define(&m4defs_buf, "M4_YY_ALWAYS_INTERACTIVE", 0);
			break;

		case OPT_NEVER_INTERACTIVE:
			buf_m4_define(&m4defs_buf, "M4_YY_NEVER_INTERACTIVE", 0);
			break;

		case OPT_ARRAY:
			yytext_is_array = true;
			break;

		case OPT_POINTER:
			yytext_is_array = false;
			break;

		case OPT_ECS:
			useecs = true;
			break;

		case OPT_NO_ECS:
			useecs = false;
			break;

		case OPT_HEADER_FILE:
			headerfilename = arg;
			break;

		case OPT_META_ECS:
			usemecs = true;
			break;

		case OPT_NO_META_ECS:
			usemecs = false;
			break;

		case OPT_PREPROCDEFINE:
			{
				/* arg is "symbol" or "symbol=definition". */
				char *def;

				for (def = arg;
				    *def != '\0' && *def != '='; ++def);

				buf_strappend(&userdef_buf, "#define ");
				if (*def == '\0') {
					buf_strappend(&userdef_buf, arg);
					buf_strappend(&userdef_buf,
					    " 1\n");
				} else {
					buf_strnappend(&userdef_buf, arg,
					    def - arg);
					buf_strappend(&userdef_buf, " ");
					buf_strappend(&userdef_buf,
					    def + 1);
					buf_strappend(&userdef_buf, "\n");
				}
			}
			break;

		case OPT_READ:
			use_read = true;
			break;

		case OPT_STACK:
			//buf_strdefine(&userdef_buf, "YY_STACK_USED", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_STACK_USED", 0);
			break;

		case OPT_STDINIT:
			do_stdinit = true;
			break;

		case OPT_NO_STDINIT:
			do_stdinit = false;
			break;

		case OPT_YYCLASS:
			yyclass = arg;
			break;

		case OPT_YYLINENO:
			do_yylineno = true;
			break;

		case OPT_NO_YYLINENO:
			do_yylineno = false;
			break;

		case OPT_YYWRAP:
			do_yywrap = true;
			break;

		case OPT_NO_YYWRAP:
			do_yywrap = false;
			break;

		case OPT_YYMORE:
			yymore_really_used = true;
			break;

		case OPT_NO_YYMORE:
			yymore_really_used = false;
			break;

		case OPT_REJECT:
			reject_really_used = true;
			break;

		case OPT_NO_REJECT:
			reject_really_used = false;
			break;

		case OPT_NO_ANSI_FUNC_DEFS:
			ansi_func_defs = false;
			break;

		case OPT_NO_ANSI_FUNC_PROTOS:
			ansi_func_protos = false;
			break;

		case OPT_NO_YY_PUSH_STATE:
			//buf_strdefine(&userdef_buf, "YY_NO_PUSH_STATE", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_PUSH_STATE", 0);
			break;
		case OPT_NO_YY_POP_STATE:
			//buf_strdefine(&userdef_buf, "YY_NO_POP_STATE", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_POP_STATE", 0);
			break;
		case OPT_NO_YY_TOP_STATE:
			//buf_strdefine(&userdef_buf, "YY_NO_TOP_STATE", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_TOP_STATE", 0);
			break;
		case OPT_NO_UNPUT:
			//buf_strdefine(&userdef_buf, "YY_NO_UNPUT", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_UNPUT", 0);
			break;
		case OPT_NO_YY_SCAN_BUFFER:
			//buf_strdefine(&userdef_buf, "YY_NO_SCAN_BUFFER", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SCAN_BUFFER", 0);
			break;
		case OPT_NO_YY_SCAN_BYTES:
			//buf_strdefine(&userdef_buf, "YY_NO_SCAN_BYTES", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SCAN_BYTES", 0);
			break;
		case OPT_NO_YY_SCAN_STRING:
			//buf_strdefine(&userdef_buf, "YY_NO_SCAN_STRING", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SCAN_STRING", 0);
			break;
		case OPT_NO_YYGET_EXTRA:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_EXTRA", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_EXTRA", 0);
			break;
		case OPT_NO_YYSET_EXTRA:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_EXTRA", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_EXTRA", 0);
			break;
		case OPT_NO_YYGET_LENG:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_LENG", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_LENG", 0);
			break;
		case OPT_NO_YYGET_TEXT:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_TEXT", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_TEXT", 0);
			break;
		case OPT_NO_YYGET_LINENO:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_LINENO", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_LINENO", 0);
			break;
		case OPT_NO_YYSET_LINENO:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_LINENO", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_LINENO", 0);
			break;
		case OPT_NO_YYGET_IN:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_IN", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_IN", 0);
			break;
		case OPT_NO_YYSET_IN:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_IN", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_IN", 0);
			break;
		case OPT_NO_YYGET_OUT:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_OUT", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_OUT", 0);
			break;
		case OPT_NO_YYSET_OUT:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_OUT", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_OUT", 0);
			break;
		case OPT_NO_YYGET_LVAL:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_LVAL", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_LVAL", 0);
			break;
		case OPT_NO_YYSET_LVAL:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_LVAL", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_LVAL", 0);
			break;
		case OPT_NO_YYGET_LLOC:
			//buf_strdefine(&userdef_buf, "YY_NO_GET_LLOC", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_GET_LLOC", 0);
			break;
		case OPT_NO_YYSET_LLOC:
			//buf_strdefine(&userdef_buf, "YY_NO_SET_LLOC", "1");
			buf_m4_define(&m4defs_buf, "M4_YY_NO_SET_LLOC", 0);
			break;

		}		/* switch */
	}			/* while scanopt() */

	scanopt_destroy(sopt);

	num_input_files = argc - optind;
	input_files = argv + optind;
	set_input_file(num_input_files > 0 ? input_files[0] : NULL);

	lastccl = lastsc = lastdfa = lastnfa = 0;
	num_rules = num_eof_rules = default_rule = 0;
	numas = numsnpairs = tmpuses = 0;
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst =
	    0;
	numuniq = numdup = hshsave = eofseen = datapos = dataline = 0;
	num_backing_up = onesp = numprots = 0;
	variable_trailing_context_rules = bol_needed = false;

	linenum = sectnum = 1;
	firstprot = NIL;

	/*
	 * Used in mkprot() so that the first proto goes in slot 1 of the
	 * proto queue.
	 */
	lastprot = 1;

	set_up_initial_allocations();
}


/* readin - read in the rules section of the input file(s) */

void
readin()
{
	static char yy_stdinit[] = "FILE *yyin = stdin, *yyout = stdout;";
	static char yy_nostdinit[] =
	"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;";

	line_directive_out((FILE *) 0, 1);

	if (yyparse()) {
		pinpoint_message(_("fatal parse error"));
		flexend(1);
	}
	if (syntaxerror)
		flexend(1);

	/*
	 * If the user explicitly requested posix compatibility by specifing
	 * the posix-compat option, then we check for conflicting options.
	 * However, if the POSIXLY_CORRECT variable is set, then we quietly
	 * make flex as posix-compatible as possible.  This is the
	 * recommended behavior according to the GNU Coding Standards.
	 *
	 * Note: The posix option was added to flex to provide the posix
	 * behavior of the repeat operator in regular expressions, e.g.,
	 * `ab{3}'
	 */
	if (posix_compat) {
		/*
		 * TODO: This is where we try to make flex behave according
		 * to posiz, AND check for conflicting options. How far
		 * should we go with this? Should we disable all the neat-o
		 * flex features?
		 */
		/*
		 * Update: Estes says no, since other flex features don't
		 * violate posix.
		 */
	}
	if (getenv("POSIXLY_CORRECT")) {
		posix_compat = true;
	}
	if (backing_up_report) {
		backing_up_file = fopen(backing_name, "w");
		if (backing_up_file == NULL)
			lerrsf(_
			    ("could not create backing-up info file %s"),
			    backing_name);
	} else
		backing_up_file = NULL;

	if (yymore_really_used == true)
		yymore_used = true;
	else if (yymore_really_used == false)
		yymore_used = false;

	if (reject_really_used == true)
		reject = true;
	else if (reject_really_used == false)
		reject = false;

	if (performance_report > 0) {
		if (lex_compat) {
			fprintf(stderr,
			    _
			    ("-l AT&T lex compatibility option entails a large performance penalty\n"));
			fprintf(stderr,
			    _
			    (" and may be the actual source of other reported performance penalties\n"));
		} else if (do_yylineno) {
			fprintf(stderr,
			    _
			    ("%%option yylineno entails a performance penalty ONLY on rules that can match newline characters\n"));
		}
		if (performance_report > 1) {
			if (interactive)
				fprintf(stderr,
				    _
				    ("-I (interactive) entails a minor performance penalty\n"));

			if (yymore_used)
				fprintf(stderr,
				    _
				    ("yymore() entails a minor performance penalty\n"));
		}
		if (reject)
			fprintf(stderr,
			    _
			    ("REJECT entails a large performance penalty\n"));

		if (variable_trailing_context_rules)
			fprintf(stderr,
			    _
			    ("Variable trailing context rules entail a large performance penalty\n"));
	}
	if (reject)
		real_reject = true;

	if (variable_trailing_context_rules)
		reject = true;

	if ((fulltbl || fullspd) && reject) {
		if (real_reject)
			flexerror(_
			    ("REJECT cannot be used with -f or -F"));
		else if (do_yylineno)
			flexerror(_
			    ("%option yylineno cannot be used with REJECT"));
		else
			flexerror(_
			    ("variable trailing context rules cannot be used with -f or -F"));
	}
	if (reject) {
		out_m4_define("M4_YY_USES_REJECT", NULL);
		//outn("\n#define YY_USES_REJECT");
	}
	if (!do_yywrap) {
		if (!C_plus_plus) {
			if (reentrant)
				outn("\n#define yywrap(yyscanner) 1");
			else
				outn("\n#define yywrap() 1");
		}
		outn("#define YY_SKIP_YYWRAP");
	}
	if (ddebug)
		outn("\n#define FLEX_DEBUG");

	OUT_BEGIN_CODE();
	if (csize == 256)
		outn("typedef unsigned char YY_CHAR;");
	else
		outn("typedef char YY_CHAR;");
	OUT_END_CODE();

	if (C_plus_plus) {
		outn("#define yytext_ptr yytext");

		if (interactive)
			outn("#define YY_INTERACTIVE");
	} else {
		OUT_BEGIN_CODE();
		/* In reentrant scanner, stdinit is handled in flex.skl. */
		if (do_stdinit) {
			if (reentrant) {
				outn("#define YY_STDINIT");
			}
			outn(yy_stdinit);
		} else {
			if (!reentrant)
				outn(yy_nostdinit);
		}
		OUT_END_CODE();
	}

	OUT_BEGIN_CODE();
	if (fullspd)
		outn("typedef yyconst struct yy_trans_info *yy_state_type;");
	else if (!C_plus_plus)
		outn("typedef int yy_state_type;");
	OUT_END_CODE();

	if (lex_compat)
		outn("#define YY_FLEX_LEX_COMPAT");

	if (!C_plus_plus && !reentrant) {
		outn("extern int yylineno;");
		OUT_BEGIN_CODE();
		outn("int yylineno = 1;");
		OUT_END_CODE();
	}
	if (C_plus_plus) {
		outn("\n#include <FlexLexer.h>");

		if (!do_yywrap) {
			outn("\nint yyFlexLexer::yywrap() { return 1; }");
		}
		if (yyclass) {
			outn("int yyFlexLexer::yylex()");
			outn("\t{");
			outn("\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );");
			outn("\treturn 0;");
			outn("\t}");

			out_str("\n#define YY_DECL int %s::yylex()\n",
			    yyclass);
		}
	} else {

		/*
		 * Watch out: yytext_ptr is a variable when yytext is an
		 * array, but it's a macro when yytext is a pointer.
		 */
		if (yytext_is_array) {
			if (!reentrant)
				outn("extern char yytext[];\n");
		} else {
			if (reentrant) {
				outn("#define yytext_ptr yytext_r");
			} else {
				outn("extern char *yytext;");
				outn("#define yytext_ptr yytext");
			}
		}

		if (yyclass)
			flexerror(_
			    ("%option yyclass only meaningful for C++ scanners"));
	}

	if (useecs)
		numecs = cre8ecs(nextecm, ecgroup, csize);
	else
		numecs = csize;

	/* Now map the equivalence class for NUL to its expected place. */
	ecgroup[0] = ecgroup[csize];
	NUL_ec = ABS(ecgroup[0]);

	if (useecs)
		ccl2ecl();
}


/* set_up_initial_allocations - allocate memory for internal tables */

void
set_up_initial_allocations()
{
	maximum_mns = (long_align ? MAXIMUM_MNS_LONG : MAXIMUM_MNS);
	current_mns = INITIAL_MNS;
	firstst = allocate_integer_array(current_mns);
	lastst = allocate_integer_array(current_mns);
	finalst = allocate_integer_array(current_mns);
	transchar = allocate_integer_array(current_mns);
	trans1 = allocate_integer_array(current_mns);
	trans2 = allocate_integer_array(current_mns);
	accptnum = allocate_integer_array(current_mns);
	assoc_rule = allocate_integer_array(current_mns);
	state_type = allocate_integer_array(current_mns);

	current_max_rules = INITIAL_MAX_RULES;
	rule_type = allocate_integer_array(current_max_rules);
	rule_linenum = allocate_integer_array(current_max_rules);
	rule_useful = allocate_integer_array(current_max_rules);
	rule_has_nl = allocate_bool_array(current_max_rules);

	current_max_scs = INITIAL_MAX_SCS;
	scset = allocate_integer_array(current_max_scs);
	scbol = allocate_integer_array(current_max_scs);
	scxclu = allocate_integer_array(current_max_scs);
	sceof = allocate_integer_array(current_max_scs);
	scname = allocate_char_ptr_array(current_max_scs);

	current_maxccls = INITIAL_MAX_CCLS;
	cclmap = allocate_integer_array(current_maxccls);
	ccllen = allocate_integer_array(current_maxccls);
	cclng = allocate_integer_array(current_maxccls);
	ccl_has_nl = allocate_bool_array(current_maxccls);

	current_max_ccl_tbl_size = INITIAL_MAX_CCL_TBL_SIZE;
	ccltbl = allocate_Character_array(current_max_ccl_tbl_size);

	current_max_dfa_size = INITIAL_MAX_DFA_SIZE;

	current_max_xpairs = INITIAL_MAX_XPAIRS;
	nxt = allocate_integer_array(current_max_xpairs);
	chk = allocate_integer_array(current_max_xpairs);

	current_max_template_xpairs = INITIAL_MAX_TEMPLATE_XPAIRS;
	tnxt = allocate_integer_array(current_max_template_xpairs);

	current_max_dfas = INITIAL_MAX_DFAS;
	base = allocate_integer_array(current_max_dfas);
	def = allocate_integer_array(current_max_dfas);
	dfasiz = allocate_integer_array(current_max_dfas);
	accsiz = allocate_integer_array(current_max_dfas);
	dhash = allocate_integer_array(current_max_dfas);
	dss = allocate_int_ptr_array(current_max_dfas);
	dfaacc = allocate_dfaacc_union(current_max_dfas);

	nultrans = (int *) 0;
}


/* extracts basename from path, optionally stripping the extension "\.*"
 * (same concept as /bin/sh `basename`, but different handling of extension). */
static char *
basename2(path, strip_ext)
	char *path;
	int strip_ext;		/* boolean */
{
	char *b, *e = 0;

	b = path;
	for (b = path; *path; path++)
		if (*path == '/')
			b = path + 1;
		else if (*path == '.')
			e = path;

	if (strip_ext && e && e > b)
		*e = '\0';
	return b;
}

void
usage()
{
	FILE *f = stdout;

	if (!did_outfilename) {
		snprintf(outfile_path, sizeof(outfile_path), outfile_template,
		    prefix, C_plus_plus ? "cc" : "c");
		outfilename = outfile_path;
	}
	fprintf(f, _("Usage: %s [OPTIONS] [FILE]...\n"), program_name);
	fprintf(f,
	    _
	    ("Generates programs that perform pattern-matching on text.\n"
		"\n" "Table Compression:\n"
		"  -Ca, --align      trade off larger tables for better memory alignment\n"
		"  -Ce, --ecs        construct equivalence classes\n"
		"  -Cf               do not compress tables; use -f representation\n"
		"  -CF               do not compress tables; use -F representation\n"
		"  -Cm, --meta-ecs   construct meta-equivalence classes\n"
		"  -Cr, --read       use read() instead of stdio for scanner input\n"
		"  -f, --full        generate fast, large scanner. Same as -Cfr\n"
		"  -F, --fast        use alternate table representation. Same as -CFr\n"
		"  -Cem              default compression (same as --ecs --meta-ecs)\n"
		"\n" "Debugging:\n"
		"  -d, --debug             enable debug mode in scanner\n"
		"  -b, --backup            write backing-up information to %s\n"
		"  -p, --perf-report       write performance report to stderr\n"
		"  -s, --nodefault         suppress default rule to ECHO unmatched text\n"
		"  -T, --trace             %s should run in trace mode\n"
		"  -w, --nowarn            do not generate warnings\n"
		"  -v, --verbose           write summary of scanner statistics to stdout\n"
		"\n" "Files:\n"
		"  -o, --outfile=FILE      specify output filename\n"
		"  -S, --skel=FILE         specify skeleton file\n"
		"  -t, --stdout            write scanner on stdout instead of %s\n"
		"      --yyclass=NAME      name of C++ class\n"
		"      --header-file=FILE   create a C header file in addition to the scanner\n"
		"      --tables-file[=FILE] write tables to FILE\n" "\n"
		"Scanner behavior:\n"
		"  -7, --7bit              generate 7-bit scanner\n"
		"  -8, --8bit              generate 8-bit scanner\n"
		"  -B, --batch             generate batch scanner (opposite of -I)\n"
		"  -i, --case-insensitive  ignore case in patterns\n"
		"  -l, --lex-compat        maximal compatibility with original lex\n"
		"  -X, --posix-compat      maximal compatibility with POSIX lex\n"
		"  -I, --interactive       generate interactive scanner (opposite of -B)\n"
		"      --yylineno          track line count in yylineno\n"
		"\n" "Generated code:\n"
		"  -+,  --c++               generate C++ scanner class\n"
		"  -Dmacro[=defn]           #define macro defn  (default defn is '1')\n"
		"  -L,  --noline            suppress #line directives in scanner\n"
		"  -P,  --prefix=STRING     use STRING as prefix instead of \"yy\"\n"
		"  -R,  --reentrant         generate a reentrant C scanner\n"
		"       --bison-bridge      scanner for bison pure parser.\n"
		"       --bison-locations   include yylloc support.\n"
		"       --stdinit           initialize yyin/yyout to stdin/stdout\n"
		"       --noansi-definitions old-style function definitions\n"
		"       --noansi-prototypes  empty parameter list in prototypes\n"
		"       --nounistd          do not include <unistd.h>\n"
		"       --noFUNCTION        do not generate a particular FUNCTION\n"
		"\n" "Miscellaneous:\n"
		"  -n                      do-nothing POSIX option\n"
		"  -?\n"
		"  -h, --help              produce this help message\n"
		"  -V, --version           report %s version\n"),
	    backing_name, program_name, outfile_path, program_name);

}
@


1.26
log
@Add some {}'s to eliminate "ambiguous else" warnings from gcc.

ok tb@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.25 2015/12/11 00:08:43 mmcc Exp $	*/
d139 1
a139 1
int 
d204 1
a204 1
int 
d228 1
a228 1
void 
d475 1
a475 1
void 
d906 1
a906 1
void 
d1436 1
a1436 1
void 
d1458 1
a1458 1
	 * 
d1662 1
a1662 1
void 
d1742 1
a1742 1
void 
@


1.25
log
@Remove a few NULL-checks before free(). I've already removed these
upstream.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.24 2015/11/20 04:07:43 millert Exp $	*/
d1553 1
a1553 1
		if (!C_plus_plus)
d1558 1
@


1.24
log
@Always use the system m4; OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.23 2015/11/20 04:06:48 millert Exp $	*/
d390 1
a390 2
		if (pname)
			free(pname);
@


1.23
log
@Back out rev 1.22 which somehow had unreported merge conflicts.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.21 2015/11/19 23:34:56 mmcc Exp $	*/
a231 1
	const char *m4 = NULL;
d354 1
a354 3
	if (!(m4 = getenv("M4")))
		m4 = M4;
	filter_create_ext(output_chain, m4, "-P", 0);
@


1.22
log
@Always use the system m4.
@
text
@a230 3
<<<<<<< main.c
	int     i;
=======
a232 1
>>>>>>> 1.20
a352 15
<<<<<<< main.c


    /* Setup the filter chain. */
    output_chain = filter_create_int(NULL, filter_tee_header, headerfilename);
    filter_create_ext(output_chain, M4, "-P", 0);
    filter_create_int(output_chain, filter_fix_linedirs, NULL);

    /* For debugging, only run the requested number of filters. */
    if (preproc_level > 0) {
        filter_truncate(output_chain, preproc_level);
        filter_apply_chain(output_chain);
    }
    yyout = stdout;
=======
a365 1
>>>>>>> 1.20
@


1.21
log
@Replace Char (defined as unsigned char) with u_char.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.20 2015/11/19 23:20:34 tedu Exp $	*/
d231 3
d236 1
d357 15
d385 1
@


1.20
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.19 2015/11/19 22:58:59 tedu Exp $	*/
d96 1
a96 1
Char *ccltbl;
@


1.19
log
@remove VMS and MSDOS support
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.18 2015/11/19 22:52:40 tedu Exp $	*/
d441 1
a441 1
			str = (char *) flex_alloc(strsz = strlen(fmt) + strlen(scname[i]) + (int) (1 + log10(i)) + 2);
@


1.18
log
@orbital strike from moonbase knf
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.17 2015/11/19 22:35:19 tedu Exp $	*/
a118 1
#ifndef SHORT_FILE_NAMES
a121 9
#else
static const char *outfile_template = "lex%s.%s";
static const char *backing_name = "lex.bck";
static const char *tablesfile_template = "lex%s.tbl";
#endif

#ifdef MS_DOS
extern unsigned _stklen = 16384;
#endif
a1583 2
				outn("#ifdef VMS");
				outn("#ifdef __VMS_POSIX");
a1584 4
				outn("#endif");
				outn("#else");
				outn("#define YY_STDINIT");
				outn("#endif");
a1585 7
			outn("#ifdef VMS");
			outn("#ifndef __VMS_POSIX");
			outn(yy_nostdinit);
			outn("#else");
			outn(yy_stdinit);
			outn("#endif");
			outn("#else");
a1586 1
			outn("#endif");
@


1.17
log
@typically indentation decreases after a block is closed
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.16 2015/11/19 19:43:40 tedu Exp $	*/
d35 2
a36 1

d47 4
a50 4
void flexinit PROTO ((int, char **));
void readin PROTO ((void));
void set_up_initial_allocations PROTO ((void));
static char *basename2 PROTO ((char *path, int should_strip_ext));
d54 37
a90 40
int     printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
int     interactive, lex_compat, posix_compat, do_yylineno,
	useecs, fulltbl, usemecs;
int     fullspd, gen_line_dirs, performance_report, backing_up_report;
int     C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap,
	csize;
int     reentrant, bison_bridge_lval, bison_bridge_lloc;
int     yymore_used, reject, real_reject, continued_action, in_rule;
int     yymore_really_used, reject_really_used;
int     datapos, dataline, linenum;
FILE   *skelfile = NULL;
int     skel_ind = 0;
char   *action_array;
int     action_size, defs1_offset, prolog_offset, action_offset,
	action_index;
char   *infilename = NULL, *outfilename = NULL, *headerfilename = NULL;
int     did_outfilename;
char   *prefix, *yyclass, *extra_type = NULL;
int     do_stdinit, use_stdout;
int     onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
int     onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
int     maximum_mns, current_mns, current_max_rules;
int     num_rules, num_eof_rules, default_rule, lastnfa;
int    *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
int    *accptnum, *assoc_rule, *state_type;
int    *rule_type, *rule_linenum, *rule_useful;
int     current_state_type;
int     variable_trailing_context_rules;
int     numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
int     protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
int     numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs,
	tecfwd[CSIZE + 1];
int     tecbck[CSIZE + 1];
int     lastsc, *scset, *scbol, *scxclu, *sceof;
int     current_max_scs;
char  **scname;
int     current_max_dfa_size, current_max_xpairs;
int     current_max_template_xpairs, current_max_dfas;
int     lastdfa, *nxt, *chk, *tnxt;
int    *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
d92 13
a104 13
int    *accsiz, *dhash, numas;
int     numsnpairs, jambase, jamstate;
int     lastccl, *cclmap, *ccllen, *cclng, cclreuse;
int     current_maxccls, current_max_ccl_tbl_size;
Char   *ccltbl;
char    nmstr[MAXLINE];
int     sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
int     tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
int     num_backing_up, bol_needed;
FILE   *backing_up_file;
int     end_of_buffer_state;
char  **input_files;
int     num_input_files;
d106 3
a108 3
bool   *rule_has_nl, *ccl_has_nl;
int     nlch = '\n';
bool    ansi_func_defs, ansi_func_protos;
d110 2
a111 2
bool    tablesext, tablesverify, gentables;
char   *tablesfilename=0,*tablesname=0;
d117 1
a117 1
char   *program_name = "flex";
d134 1
a134 1
extern FILE* yyout;
d139 1
a139 1
static int _stdout_closed = 0; /* flag to prevent double-fclose() on stdout. */
d141 1
a141 1
const char *escaped_qend   = "[[]]M4_YY_NOOP]M4_YY_NOOP]M4_YY_NOOP[[]]";
d146 2
a147 2
int flex_main PROTO ((int argc, char *argv[]));
int main PROTO ((int argc, char *argv[]));
d149 4
a152 3
int flex_main (argc, argv)
     int argc;
     char   *argv[];
d154 1
a154 1
	int     i, exit_status, child_status;
d156 7
a162 6
	/* Set a longjmp target. Yes, I know it's a hack, but it gets worse: The
	 * return value of setjmp, if non-zero, is the desired exit code PLUS ONE.
	 * For example, if you want 'main' to return with code '2', then call
	 * longjmp() with an argument of 3. This is because it is invalid to
	 * specify a value of 0 to longjmp. FLEX_EXIT(n) should be used instead of
	 * exit(n);
d164 14
a177 18
	exit_status = setjmp (flex_main_jmp_buf);
	if (exit_status){
        if (stdout && !_stdout_closed && !ferror(stdout)){
            fflush(stdout);
            fclose(stdout);
        }
        while (wait(&child_status) > 0){
            if (!WIFEXITED (child_status)
                || WEXITSTATUS (child_status) != 0){
                /* report an error of a child
                 */
                if( exit_status <= 1 )
                    exit_status = 2;

            }
        }
        return exit_status - 1;
    }
d179 5
a183 1
	flexinit (argc, argv);
d185 1
a185 1
	readin ();
d187 1
a187 1
	skelout ();
d189 1
a189 1
	ntod ();
d193 2
a194 2
			line_warning (_("rule cannot be matched"),
				      rule_linenum[i]);
d197 3
a199 3
		line_warning (_
			      ("-s option given but default rule can be matched"),
			      rule_linenum[default_rule]);
d202 1
a202 1
	make_tables ();
d204 3
a206 2
	/* Note, flexend does not return.  It exits with its argument
	 * as status.
d208 1
a208 1
	flexend (0);
d214 4
a217 3
int main (argc, argv)
     int argc;
     char   *argv[];
d221 4
a224 4
	setlocale (LC_MESSAGES, "");
        setlocale (LC_CTYPE, "");
	textdomain (PACKAGE);
	bindtextdomain (PACKAGE, LOCALEDIR);
d228 3
a230 4
	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
	{
		fprintf( stderr, _( "%s: pledge\n"),
			program_name);
d233 1
a233 2

	return flex_main (argc, argv);
d238 2
a239 1
void check_options ()
d241 2
a242 2
	int     i;
    const char * m4 = NULL;
d246 1
a246 1
			flexerror (_("Can't use -+ with -l option"));
d249 1
a249 1
			flexerror (_("Can't use -f or -F with -l option"));
d252 2
a253 2
			flexerror (_
				   ("Can't use --reentrant or --bison-bridge with -l option"));
a258 2


a271 1

a277 1

d280 2
a281 2
			flexerror (_
				   ("-Cf/-CF and -Cm don't make sense together"));
d284 1
a284 1
			flexerror (_("-Cf/-CF and -I are incompatible"));
d287 2
a288 2
			flexerror (_
				   ("-Cf/-CF are incompatible with lex-compatibility mode"));
d292 2
a293 2
			flexerror (_
				   ("-Cf and -CF are mutually exclusive"));
a294 1

d296 1
a296 1
		flexerror (_("Can't use -+ with -CF option"));
d299 1
a299 1
		warn (_("%array incompatible with -+ option"));
a301 1

d303 1
a303 1
		flexerror (_("Options -+ and --reentrant are mutually exclusive."));
d306 1
a306 1
		flexerror (_("bison bridge not supported for the C++ scanner."));
d311 2
a312 1
		/* We loop all the way up to csize, since ecgroup[csize] is
d323 1
a323 3
	}

	else {
d331 2
a332 2
    if (!ansi_func_defs)
        buf_m4_define( &m4defs_buf, "M4_YY_NO_ANSI_FUNC_DEFS", NULL);
d334 2
a335 2
    if (!ansi_func_protos)
        buf_m4_define( &m4defs_buf, "M4_YY_NO_ANSI_FUNC_PROTOS", NULL);
d337 2
a338 2
    if (extra_type)
        buf_m4_define( &m4defs_buf, "M4_EXTRA_TYPE_DEFS", extra_type);
d341 1
a341 1
		FILE   *prev_stdout;
d344 1
a344 1
			char   *suffix;
d351 2
a352 2
			snprintf (outfile_path, sizeof(outfile_path), outfile_template,
				 prefix, suffix);
d356 1
a356 2

		prev_stdout = freopen (outfilename, "w+", stdout);
d359 1
a359 1
			lerrsf (_("could not create %s"), outfilename);
d363 13
a375 15


    /* Setup the filter chain. */
    output_chain = filter_create_int(NULL, filter_tee_header, headerfilename);
    if ( !(m4 = getenv("M4")))
        m4 = M4;
    filter_create_ext(output_chain, m4, "-P", 0);
    filter_create_int(output_chain, filter_fix_linedirs, NULL);

    /* For debugging, only run the requested number of filters. */
    if (preproc_level > 0) {
        filter_truncate(output_chain, preproc_level);
        filter_apply_chain(output_chain);
    }
    yyout = stdout;
d379 1
a379 1
	buf_m4_define (&m4defs_buf, "M4_YY_TABLES_VERIFY", tablesverify ? "1" : "0");
d389 1
a389 1
		FILE   *tablesout;
d391 2
a392 2
		char   *pname = 0;
		int     nbytes = 0;
d394 1
a394 1
		buf_m4_define (&m4defs_buf, "M4_YY_TABLES_EXTERNAL", NULL);
d397 3
a399 3
			nbytes = strlen (prefix) + strlen (tablesfile_template) + 2;
			tablesfilename = pname = (char *) calloc (nbytes, 1);
			snprintf (pname, nbytes, tablesfile_template, prefix);
d401 2
a402 3

		if ((tablesout = fopen (tablesfilename, "w")) == NULL)
			lerrsf (_("could not create %s"), tablesfilename);
d404 1
a404 1
			free (pname);
d407 1
a407 1
		yytbl_writer_init (&tableswr, tablesout);
d409 4
a412 4
		nbytes = strlen (prefix) + strlen ("tables") + 2;
		tablesname = (char *) calloc (nbytes, 1);
		snprintf (tablesname, nbytes, "%stables", prefix);
		yytbl_hdr_init (&hdr, flex_version, tablesname);
d414 2
a415 2
		if (yytbl_hdr_fwrite (&tableswr, &hdr) <= 0)
			flexerror (_("could not write tables header"));
d417 2
a418 3

	if (skelname && (skelfile = fopen (skelname, "r")) == NULL)
		lerrsf (_("can't open skeleton file %s"), skelname);
d421 1
a421 1
		buf_m4_define (&m4defs_buf, "M4_YY_REENTRANT", NULL);
d423 1
a423 1
			buf_m4_define (&m4defs_buf, "M4_YY_TEXT_IS_ARRAY", NULL);
d425 2
d428 2
a429 5
	if ( bison_bridge_lval)
		buf_m4_define (&m4defs_buf, "M4_YY_BISON_LVAL", NULL);

	if ( bison_bridge_lloc)
		buf_m4_define (&m4defs_buf, "<M4_YY_BISON_LLOC>", NULL);
d434 1
a434 1
		line_directive_out (stdout, 0);
d437 1
a437 1
		buf_m4_define (&m4defs_buf, "M4_YY_USE_LINENO", NULL);
d440 23
a462 2
	buf_strdefine (&userdef_buf, "YY_INT_ALIGNED",
		       long_align ? "long int" : "short int");
d464 3
a466 28
    /* Define the start condition macros. */
    {
        struct Buf tmpbuf;
        buf_init(&tmpbuf, sizeof(char));
        for (i = 1; i <= lastsc; i++) {
             char *str, *fmt = "#define %s %d\n";
             size_t strsz;

             str = (char*)flex_alloc(strsz = strlen(fmt) + strlen(scname[i]) + (int)(1 + log10(i)) + 2);
             if (!str)
               flexfatal(_("allocation of macro definition failed"));
             snprintf(str, strsz, fmt,      scname[i], i - 1);
             buf_strappend(&tmpbuf, str);
             free(str);
        }
        buf_m4_define(&m4defs_buf, "M4_YY_SC_DEFS", tmpbuf.elts);
        buf_destroy(&tmpbuf);
    }

    /* This is where we begin writing to the file. */

    /* Dump the %top code. */
    if( top_buf.elts)
        outn((char*) top_buf.elts);

    /* Dump the m4 definitions. */
    buf_print_strings(&m4defs_buf, stdout);
    m4defs_buf.nelts = 0; /* memory leak here. */
d468 6
a473 2
    /* Place a bogus line directive, it will be fixed in the filter. */
    outn("#line 0 \"M4_YY_OUTFILE_NAME\"\n");
d477 1
a477 1
		outn ((char *) (userdef_buf.elts));
d479 1
a479 1
	skelout ();
d489 3
a491 2
void flexend (exit_status)
     int exit_status;
d495 1
a495 1
	int     tblsiz;
d498 1
a498 1
		FLEX_EXIT (exit_status);
d501 7
a507 7
		if (ferror (skelfile))
			lerrsf (_("input error reading skeleton file %s"),
				skelname);

		else if (fclose (skelfile))
			lerrsf (_("error closing skeleton file %s"),
				skelname);
d509 21
d531 2
a532 173
#if 0
		fprintf (header_out,
			 "#ifdef YY_HEADER_EXPORT_START_CONDITIONS\n");
		fprintf (header_out,
			 "/* Beware! Start conditions are not prefixed. */\n");

		/* Special case for "INITIAL" */
		fprintf (header_out,
			 "#undef INITIAL\n#define INITIAL 0\n");
		for (i = 2; i <= lastsc; i++)
			fprintf (header_out, "#define %s %d\n", scname[i], i - 1);
		fprintf (header_out,
			 "#endif /* YY_HEADER_EXPORT_START_CONDITIONS */\n\n");

		/* Kill ALL flex-related macros. This is so the user
		 * can #include more than one generated header file. */
		fprintf (header_out, "#ifndef YY_HEADER_NO_UNDEFS\n");
		fprintf (header_out,
			 "/* Undefine all internal macros, etc., that do no belong in the header. */\n\n");

        {
            const char * undef_list[] = {

                "BEGIN",
                "ECHO",
                "EOB_ACT_CONTINUE_SCAN",
                "EOB_ACT_END_OF_FILE",
                "EOB_ACT_LAST_MATCH",
                "FLEX_SCANNER",
                "FLEX_STD",
                "REJECT",
                "YYFARGS0",
                "YYFARGS1",
                "YYFARGS2",
                "YYFARGS3",
                "YYLMAX",
                "YYSTATE",
                "YY_AT_BOL",
                "YY_BREAK",
                "YY_BUFFER_EOF_PENDING",
                "YY_BUFFER_NEW",
                "YY_BUFFER_NORMAL",
                "YY_BUF_SIZE",
                "M4_YY_CALL_LAST_ARG",
                "M4_YY_CALL_ONLY_ARG",
                "YY_CURRENT_BUFFER",
                "YY_DECL",
                "M4_YY_DECL_LAST_ARG",
                "M4_YY_DEF_LAST_ARG",
                "M4_YY_DEF_ONLY_ARG",
                "YY_DO_BEFORE_ACTION",
                "YY_END_OF_BUFFER",
                "YY_END_OF_BUFFER_CHAR",
                "YY_EXIT_FAILURE",
                "YY_EXTRA_TYPE",
                "YY_FATAL_ERROR",
                "YY_FLEX_DEFINED_ECHO",
                "YY_FLEX_LEX_COMPAT",
                "YY_FLEX_MAJOR_VERSION",
                "YY_FLEX_MINOR_VERSION",
                "YY_FLEX_SUBMINOR_VERSION",
                "YY_FLUSH_BUFFER",
                "YY_G",
                "YY_INPUT",
                "YY_INTERACTIVE",
                "YY_INT_ALIGNED",
                "YY_LAST_ARG",
                "YY_LESS_LINENO",
                "YY_LEX_ARGS",
                "YY_LEX_DECLARATION",
                "YY_LEX_PROTO",
                "YY_MAIN",
                "YY_MORE_ADJ",
                "YY_NEED_STRLEN",
                "YY_NEW_FILE",
                "YY_NULL",
                "YY_NUM_RULES",
                "YY_ONLY_ARG",
                "YY_PARAMS",
                "YY_PROTO",
                "M4_YY_PROTO_LAST_ARG",
                "M4_YY_PROTO_ONLY_ARG void",
                "YY_READ_BUF_SIZE",
                "YY_REENTRANT",
                "YY_RESTORE_YY_MORE_OFFSET",
                "YY_RULE_SETUP",
                "YY_SC_TO_UI",
                "YY_SKIP_YYWRAP",
                "YY_START",
                "YY_START_STACK_INCR",
                "YY_STATE_EOF",
                "YY_STDINIT",
                "YY_TRAILING_HEAD_MASK",
                "YY_TRAILING_MASK",
                "YY_USER_ACTION",
                "YY_USE_CONST",
                "YY_USE_PROTOS",
                "unput",
                "yyTABLES_NAME",
                "yy_create_buffer",
                "yy_delete_buffer",
                "yy_flex_debug",
                "yy_flush_buffer",
                "yy_init_buffer",
                "yy_load_buffer_state",
                "yy_new_buffer",
                "yy_scan_buffer",
                "yy_scan_bytes",
                "yy_scan_string",
                "yy_set_bol",
                "yy_set_interactive",
                "yy_switch_to_buffer",
				"yypush_buffer_state",
				"yypop_buffer_state",
				"yyensure_buffer_stack",
                "yyalloc",
                "yyconst",
                "yyextra",
                "yyfree",
                "yyget_debug",
                "yyget_extra",
                "yyget_in",
                "yyget_leng",
                "yyget_lineno",
                "yyget_lloc",
                "yyget_lval",
                "yyget_out",
                "yyget_text",
                "yyin",
                "yyleng",
                "yyless",
                "yylex",
                "yylex_destroy",
                "yylex_init",
                "yylex_init_extra",
                "yylineno",
                "yylloc",
                "yylval",
                "yymore",
                "yyout",
                "yyrealloc",
                "yyrestart",
                "yyset_debug",
                "yyset_extra",
                "yyset_in",
                "yyset_lineno",
                "yyset_lloc",
                "yyset_lval",
                "yyset_out",
                "yytables_destroy",
                "yytables_fload",
                "yyterminate",
                "yytext",
                "yytext_ptr",
                "yywrap",

                /* must be null-terminated */
                NULL};


                for (i=0; undef_list[i] != NULL; i++)
                    fprintf (header_out, "#undef %s\n", undef_list[i]);
        }

		/* undef any of the auto-generated symbols. */
		for (i = 0; i < defs_buf.nelts; i++) {

			/* don't undef start conditions */
			if (sclookup (((char **) defs_buf.elts)[i]) > 0)
				continue;
			fprintf (header_out, "#undef %s\n",
				 ((char **) defs_buf.elts)[i]);
		}
d534 162
a695 11
		fprintf (header_out,
			 "#endif /* !YY_HEADER_NO_UNDEFS */\n");
		fprintf (header_out, "\n");
		fprintf (header_out, "#undef %sIN_HEADER\n", prefix);
		fprintf (header_out, "#endif /* %sHEADER_H */\n", prefix);

		if (ferror (header_out))
			lerrsf (_("error creating header file %s"),
				headerfilename);
		fflush (header_out);
		fclose (header_out);
d699 11
a709 11
		if (ferror (stdout))
			lerrsf (_("error writing output file %s"),
				outfilename);

		else if ((_stdout_closed = 1) && fclose (stdout))
			lerrsf (_("error closing output file %s"),
				outfilename);

		else if (unlink (outfilename))
			lerrsf (_("error deleting output file %s"),
				outfilename);
a710 2


d713 1
a713 1
			fprintf (backing_up_file, _("No backing up.\n"));
d715 4
a718 4
			fprintf (backing_up_file,
				 _
				 ("%d backing up (non-accepting) states.\n"),
				 num_backing_up);
d720 2
a721 2
			fprintf (backing_up_file,
				 _("Compressed tables always back up.\n"));
d723 7
a729 7
		if (ferror (backing_up_file))
			lerrsf (_("error writing backup file %s"),
				backing_name);

		else if (fclose (backing_up_file))
			lerrsf (_("error closing backup file %s"),
				backing_name);
a730 1

d732 2
a733 2
		fprintf (stderr, _("%s version %s usage statistics:\n"),
			 program_name, flex_version);
d735 1
a735 1
		fprintf (stderr, _("  scanner options: -"));
d738 1
a738 1
			putc ('+', stderr);
d740 1
a740 1
			putc ('b', stderr);
d742 1
a742 1
			putc ('d', stderr);
d744 1
a744 1
			putc ('i', stderr);
d746 1
a746 1
			putc ('l', stderr);
d748 1
a748 1
			putc ('X', stderr);
d750 1
a750 1
			putc ('p', stderr);
d752 1
a752 1
			putc ('p', stderr);
d754 1
a754 1
			putc ('s', stderr);
d756 1
a756 1
			fputs ("--reentrant", stderr);
d758 1
a758 1
			fputs ("--bison-bridge", stderr);
d760 1
a760 1
			fputs ("--bison-locations", stderr);
d762 1
a762 1
			putc ('t', stderr);
d764 1
a764 1
			putc ('v', stderr);	/* always true! */
d766 1
a766 1
			putc ('w', stderr);
d768 1
a768 1
			putc ('B', stderr);
d770 1
a770 1
			putc ('I', stderr);
d772 1
a772 1
			putc ('L', stderr);
d774 1
a774 1
			putc ('T', stderr);
d777 2
a778 1
			/* We encountered an error fairly early on, so csize
d785 1
a785 1
			putc ('7', stderr);
d787 1
a787 1
			putc ('8', stderr);
d789 1
a789 1
		fprintf (stderr, " -C");
d792 1
a792 1
			putc ('a', stderr);
d794 1
a794 1
			putc ('f', stderr);
d796 1
a796 1
			putc ('F', stderr);
d798 1
a798 1
			putc ('e', stderr);
d800 1
a800 1
			putc ('m', stderr);
d802 1
a802 1
			putc ('r', stderr);
d805 1
a805 1
			fprintf (stderr, " -o%s", outfilename);
d808 1
a808 1
			fprintf (stderr, " -S%s", skelname);
d810 2
a811 2
		if (strcmp (prefix, "yy"))
			fprintf (stderr, " -P%s", prefix);
d813 1
a813 1
		putc ('\n', stderr);
d815 7
a821 7
		fprintf (stderr, _("  %d/%d NFA states\n"),
			 lastnfa, current_mns);
		fprintf (stderr, _("  %d/%d DFA states (%d words)\n"),
			 lastdfa, current_max_dfas, totnst);
		fprintf (stderr, _("  %d rules\n"),
			 num_rules + num_eof_rules -
			 1 /* - 1 for def. rule */ );
d824 1
a824 1
			fprintf (stderr, _("  No backing up\n"));
d826 4
a829 4
			fprintf (stderr,
				 _
				 ("  %d backing-up (non-accepting) states\n"),
				 num_backing_up);
d831 3
a833 3
			fprintf (stderr,
				 _
				 ("  Compressed tables always back-up\n"));
d836 2
a837 2
			fprintf (stderr,
				 _("  Beginning-of-line patterns used\n"));
d839 6
a844 6
		fprintf (stderr, _("  %d/%d start conditions\n"), lastsc,
			 current_max_scs);
		fprintf (stderr,
			 _
			 ("  %d epsilon states, %d double epsilon states\n"),
			 numeps, eps2);
d847 1
a847 1
			fprintf (stderr, _("  no character classes\n"));
d849 12
a860 12
			fprintf (stderr,
				 _
				 ("  %d/%d character classes needed %d/%d words of storage, %d reused\n"),
				 lastccl, current_maxccls,
				 cclmap[lastccl] + ccllen[lastccl],
				 current_max_ccl_tbl_size, cclreuse);

		fprintf (stderr, _("  %d state/nextstate pairs created\n"),
			 numsnpairs);
		fprintf (stderr,
			 _("  %d/%d unique/duplicate transitions\n"),
			 numuniq, numdup);
d864 3
a866 5
			fprintf (stderr, _("  %d table entries\n"),
				 tblsiz);
		}

		else {
d869 20
a888 20
			fprintf (stderr,
				 _("  %d/%d base-def entries created\n"),
				 lastdfa + numtemps, current_max_dfas);
			fprintf (stderr,
				 _
				 ("  %d/%d (peak %d) nxt-chk entries created\n"),
				 tblend, current_max_xpairs, peakpairs);
			fprintf (stderr,
				 _
				 ("  %d/%d (peak %d) template nxt-chk entries created\n"),
				 numtemps * nummecs,
				 current_max_template_xpairs,
				 numtemps * numecs);
			fprintf (stderr, _("  %d empty table entries\n"),
				 nummt);
			fprintf (stderr, _("  %d protos created\n"),
				 numprots);
			fprintf (stderr,
				 _("  %d templates created, %d uses\n"),
				 numtemps, tmpuses);
d893 4
a896 4
			fprintf (stderr,
				 _
				 ("  %d/%d equivalence classes created\n"),
				 numecs, csize);
a897 1

d900 4
a903 4
			fprintf (stderr,
				 _
				 ("  %d/%d meta-equivalence classes created\n"),
				 nummecs, csize);
d905 8
a912 9

		fprintf (stderr,
			 _
			 ("  %d (%d saved) hash collisions, %d DFAs equal\n"),
			 hshcol, hshsave, dfaeql);
		fprintf (stderr, _("  %d sets of reallocations needed\n"),
			 num_reallocs);
		fprintf (stderr, _("  %d total table entries needed\n"),
			 tblsiz);
d914 1
a914 2

	FLEX_EXIT (exit_status);
d920 4
a923 3
void flexinit (argc, argv)
     int argc;
     char  **argv;
d925 2
a926 2
	int     i, sawcmpflag, rv, optind;
	char   *arg;
d931 1
a931 1
		ddebug = fulltbl = false;
d933 1
a933 1
		false;
d935 1
a935 1
		false;
d948 1
a948 1
    ansi_func_defs = ansi_func_protos = true;
d954 1
a954 1
	action_array = allocate_character_array (action_size);
d959 4
a962 11
	buf_init (&userdef_buf, sizeof (char));	/* one long string */
	buf_init (&defs_buf, sizeof (char *));	/* list of strings */
	buf_init (&yydmap_buf, sizeof (char));	/* one long string */
	buf_init (&top_buf, sizeof (char));	    /* one long string */

    {
        const char * m4defs_init_str[] = {"m4_changequote\n",
                                          "m4_changequote([[, ]])\n"};
        buf_init (&m4defs_buf, sizeof (char *));
        buf_append (&m4defs_buf, &m4defs_init_str, 2);
    }
d964 8
a971 1
    sf_init ();
d973 2
a974 2
    /* initialize regex lib */
    flex_init_regex();
d977 1
a977 1
	program_name = basename2 (argv[0], 0);
d980 1
a980 1
	    program_name[strlen (program_name) - 1] == '+')
d984 1
a984 1
	sopt = scanopt_init (flexopts, argc, argv, 0);
d987 3
a989 3
		fprintf (stderr,
			 _("Internal error. flexopts are malformed.\n"));
		FLEX_EXIT (1);
d991 1
a991 2

	while ((rv = scanopt (sopt, &arg, &optind)) != 0) {
d994 9
a1002 6
			/* Scanopt has already printed an option-specific error message. */
			fprintf (stderr,
				 _
				 ("Try `%s --help' for more information.\n"),
				 program_name);
			FLEX_EXIT (1);
a1003 1

a1026 1

d1054 3
a1056 3
					lerrif (_
						("unknown -C option '%c'"),
						(int) arg[i]);
d1080 2
a1081 2
			usage ();
			FLEX_EXIT (0);
d1099 3
a1101 3
        case OPT_PREPROC_LEVEL:
            preproc_level = strtol(arg,NULL,0);
            break;
d1104 1
a1104 1
			buf_strdefine (&userdef_buf, "YY_MAIN", "1");
d1109 1
a1109 1
			buf_strdefine (&userdef_buf, "YY_MAIN", "0");
d1162 2
a1163 2
			//buf_strdefine (&userdef_buf, "YY_NO_UNISTD_H", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_UNISTD_H",0);
d1184 2
a1185 2
			printf (_("%s %s\n"), program_name, flex_version);
			FLEX_EXIT (0);
d1212 1
a1212 1
			buf_m4_define (&m4defs_buf, "M4_YY_ALWAYS_INTERACTIVE", 0);
d1216 1
a1216 1
            buf_m4_define( &m4defs_buf, "M4_YY_NEVER_INTERACTIVE", 0);
d1250 1
a1250 1
				char   *def;
d1253 1
a1253 1
				     *def != '\0' && *def != '='; ++def) ;
d1255 1
a1255 1
				buf_strappend (&userdef_buf, "#define ");
d1257 10
a1266 11
					buf_strappend (&userdef_buf, arg);
					buf_strappend (&userdef_buf,
						       " 1\n");
				}
				else {
					buf_strnappend (&userdef_buf, arg,
							def - arg);
					buf_strappend (&userdef_buf, " ");
					buf_strappend (&userdef_buf,
						       def + 1);
					buf_strappend (&userdef_buf, "\n");
d1276 2
a1277 2
			//buf_strdefine (&userdef_buf, "YY_STACK_USED", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_STACK_USED",0);
d1324 7
a1330 7
        case OPT_NO_ANSI_FUNC_DEFS:
            ansi_func_defs = false;
            break;

        case OPT_NO_ANSI_FUNC_PROTOS:
            ansi_func_protos = false;
            break;
d1333 2
a1334 2
			//buf_strdefine (&userdef_buf, "YY_NO_PUSH_STATE", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_PUSH_STATE",0);
d1337 2
a1338 2
			//buf_strdefine (&userdef_buf, "YY_NO_POP_STATE", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_POP_STATE",0);
d1341 2
a1342 2
			//buf_strdefine (&userdef_buf, "YY_NO_TOP_STATE", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_TOP_STATE",0);
d1345 2
a1346 2
			//buf_strdefine (&userdef_buf, "YY_NO_UNPUT", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_UNPUT",0);
d1349 2
a1350 2
			//buf_strdefine (&userdef_buf, "YY_NO_SCAN_BUFFER", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SCAN_BUFFER",0);
d1353 2
a1354 2
			//buf_strdefine (&userdef_buf, "YY_NO_SCAN_BYTES", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SCAN_BYTES",0);
d1357 2
a1358 2
			//buf_strdefine (&userdef_buf, "YY_NO_SCAN_STRING", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SCAN_STRING",0);
d1361 2
a1362 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_EXTRA", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_EXTRA",0);
d1365 2
a1366 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_EXTRA", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_EXTRA",0);
d1369 2
a1370 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_LENG", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_LENG",0);
d1373 2
a1374 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_TEXT", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_TEXT",0);
d1377 2
a1378 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_LINENO", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_LINENO",0);
d1381 2
a1382 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_LINENO", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_LINENO",0);
d1385 2
a1386 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_IN", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_IN",0);
d1389 2
a1390 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_IN", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_IN",0);
d1393 2
a1394 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_OUT", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_OUT",0);
d1397 2
a1398 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_OUT", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_OUT",0);
d1401 2
a1402 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_LVAL", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_LVAL",0);
d1405 2
a1406 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_LVAL", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_LVAL",0);
d1409 2
a1410 2
			//buf_strdefine (&userdef_buf, "YY_NO_GET_LLOC", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_GET_LLOC",0);
d1413 2
a1414 2
			//buf_strdefine (&userdef_buf, "YY_NO_SET_LLOC", "1");
            buf_m4_define( &m4defs_buf, "M4_YY_NO_SET_LLOC",0);
d1420 1
a1420 1
	scanopt_destroy (sopt);
d1424 1
a1424 1
	set_input_file (num_input_files > 0 ? input_files[0] : NULL);
d1430 1
a1430 1
		0;
d1438 3
a1440 2
	/* Used in mkprot() so that the first proto goes in slot 1
	 * of the proto queue.
d1444 1
a1444 1
	set_up_initial_allocations ();
d1450 2
a1451 1
void readin ()
d1455 1
a1455 1
		"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;";
d1457 1
a1457 1
	line_directive_out ((FILE *) 0, 1);
d1459 3
a1461 3
	if (yyparse ()) {
		pinpoint_message (_("fatal parse error"));
		flexend (1);
a1462 1

d1464 1
a1464 1
		flexend (1);
d1466 10
a1475 8
	/* If the user explicitly requested posix compatibility by specifing the
	 * posix-compat option, then we check for conflicting options. However, if
	 * the POSIXLY_CORRECT variable is set, then we quietly make flex as
	 * posix-compatible as possible.  This is the recommended behavior
	 * according to the GNU Coding Standards.
	 *
	 * Note: The posix option was added to flex to provide the posix behavior
	 * of the repeat operator in regular expressions, e.g., `ab{3}'
d1478 9
a1486 3
		/* TODO: This is where we try to make flex behave according to
		 * posiz, AND check for conflicting options. How far should we go
		 * with this? Should we disable all the neat-o flex features?
a1487 1
		/* Update: Estes says no, since other flex features don't violate posix. */
d1489 1
a1489 2

	if (getenv ("POSIXLY_CORRECT")) {
a1491 1

d1493 1
a1493 1
		backing_up_file = fopen (backing_name, "w");
d1495 4
a1498 6
			lerrsf (_
				("could not create backing-up info file %s"),
				backing_name);
	}

	else
d1513 10
a1522 12
			fprintf (stderr,
				 _
				 ("-l AT&T lex compatibility option entails a large performance penalty\n"));
			fprintf (stderr,
				 _
				 (" and may be the actual source of other reported performance penalties\n"));
		}

		else if (do_yylineno) {
			fprintf (stderr,
				 _
				 ("%%option yylineno entails a performance penalty ONLY on rules that can match newline characters\n"));
a1523 1

d1526 3
a1528 3
				fprintf (stderr,
					 _
					 ("-I (interactive) entails a minor performance penalty\n"));
d1531 3
a1533 3
				fprintf (stderr,
					 _
					 ("yymore() entails a minor performance penalty\n"));
a1534 1

d1536 3
a1538 3
			fprintf (stderr,
				 _
				 ("REJECT entails a large performance penalty\n"));
d1541 3
a1543 3
			fprintf (stderr,
				 _
				 ("Variable trailing context rules entail a large performance penalty\n"));
a1544 1

d1553 2
a1554 2
			flexerror (_
				   ("REJECT cannot be used with -f or -F"));
d1556 2
a1557 2
			flexerror (_
				   ("%option yylineno cannot be used with REJECT"));
d1559 6
a1564 2
			flexerror (_
				   ("variable trailing context rules cannot be used with -f or -F"));
a1565 6

	if (reject){
        out_m4_define( "M4_YY_USES_REJECT", NULL);
		//outn ("\n#define YY_USES_REJECT");
    }

d1568 5
a1572 5
			 if (reentrant)
				outn ("\n#define yywrap(yyscanner) 1");
			 else
				outn ("\n#define yywrap() 1");
		outn ("#define YY_SKIP_YYWRAP");
a1573 1

d1575 1
a1575 1
		outn ("\n#define FLEX_DEBUG");
d1577 1
a1577 1
	OUT_BEGIN_CODE ();
d1579 1
a1579 1
		outn ("typedef unsigned char YY_CHAR;");
d1581 2
a1582 2
		outn ("typedef char YY_CHAR;");
	OUT_END_CODE ();
d1585 1
a1585 1
		outn ("#define yytext_ptr yytext");
d1588 3
a1590 5
			outn ("#define YY_INTERACTIVE");
	}

	else {
		OUT_BEGIN_CODE ();
d1593 8
a1600 8
			if (reentrant){
				outn ("#ifdef VMS");
				outn ("#ifdef __VMS_POSIX");
				outn ("#define YY_STDINIT");
				outn ("#endif");
				outn ("#else");
				outn ("#define YY_STDINIT");
				outn ("#endif");
d1602 9
a1610 10

			outn ("#ifdef VMS");
			outn ("#ifndef __VMS_POSIX");
			outn (yy_nostdinit);
			outn ("#else");
			outn (yy_stdinit);
			outn ("#endif");
			outn ("#else");
			outn (yy_stdinit);
			outn ("#endif");
d1612 2
a1613 2
			if(!reentrant)
                		outn (yy_nostdinit);
d1615 1
a1615 1
		OUT_END_CODE ();
d1618 1
a1618 1
	OUT_BEGIN_CODE ();
d1620 1
a1620 1
		outn ("typedef yyconst struct yy_trans_info *yy_state_type;");
d1622 2
a1623 2
		outn ("typedef int yy_state_type;");
	OUT_END_CODE ();
d1626 1
a1626 1
		outn ("#define YY_FLEX_LEX_COMPAT");
d1629 4
a1632 4
		outn ("extern int yylineno;");
		OUT_BEGIN_CODE ();
		outn ("int yylineno = 1;");
		OUT_END_CODE ();
a1633 1

d1635 1
a1635 1
		outn ("\n#include <FlexLexer.h>");
d1637 1
a1637 1
 		if (!do_yywrap) {
a1639 1

d1641 5
a1645 5
			outn ("int yyFlexLexer::yylex()");
			outn ("\t{");
			outn ("\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );");
			outn ("\treturn 0;");
			outn ("\t}");
d1647 2
a1648 2
			out_str ("\n#define YY_DECL int %s::yylex()\n",
				 yyclass);
d1650 1
a1650 1
	}
d1652 3
a1654 4
	else {

		/* Watch out: yytext_ptr is a variable when yytext is an array,
		 * but it's a macro when yytext is a pointer.
d1658 2
a1659 3
				outn ("extern char yytext[];\n");
		}
		else {
d1661 4
a1664 5
				outn ("#define yytext_ptr yytext_r");
			}
			else {
				outn ("extern char *yytext;");
				outn ("#define yytext_ptr yytext");
d1669 2
a1670 2
			flexerror (_
				   ("%option yyclass only meaningful for C++ scanners"));
d1674 1
a1674 1
		numecs = cre8ecs (nextecm, ecgroup, csize);
d1680 1
a1680 1
	NUL_ec = ABS (ecgroup[0]);
d1683 1
a1683 1
		ccl2ecl ();
d1689 2
a1690 1
void set_up_initial_allocations ()
d1694 9
a1702 9
	firstst = allocate_integer_array (current_mns);
	lastst = allocate_integer_array (current_mns);
	finalst = allocate_integer_array (current_mns);
	transchar = allocate_integer_array (current_mns);
	trans1 = allocate_integer_array (current_mns);
	trans2 = allocate_integer_array (current_mns);
	accptnum = allocate_integer_array (current_mns);
	assoc_rule = allocate_integer_array (current_mns);
	state_type = allocate_integer_array (current_mns);
d1705 4
a1708 4
	rule_type = allocate_integer_array (current_max_rules);
	rule_linenum = allocate_integer_array (current_max_rules);
	rule_useful = allocate_integer_array (current_max_rules);
	rule_has_nl = allocate_bool_array (current_max_rules);
d1711 5
a1715 5
	scset = allocate_integer_array (current_max_scs);
	scbol = allocate_integer_array (current_max_scs);
	scxclu = allocate_integer_array (current_max_scs);
	sceof = allocate_integer_array (current_max_scs);
	scname = allocate_char_ptr_array (current_max_scs);
d1718 4
a1721 4
	cclmap = allocate_integer_array (current_maxccls);
	ccllen = allocate_integer_array (current_maxccls);
	cclng = allocate_integer_array (current_maxccls);
	ccl_has_nl = allocate_bool_array (current_maxccls);
d1724 1
a1724 1
	ccltbl = allocate_Character_array (current_max_ccl_tbl_size);
d1729 2
a1730 2
	nxt = allocate_integer_array (current_max_xpairs);
	chk = allocate_integer_array (current_max_xpairs);
d1733 1
a1733 1
	tnxt = allocate_integer_array (current_max_template_xpairs);
d1736 7
a1742 7
	base = allocate_integer_array (current_max_dfas);
	def = allocate_integer_array (current_max_dfas);
	dfasiz = allocate_integer_array (current_max_dfas);
	accsiz = allocate_integer_array (current_max_dfas);
	dhash = allocate_integer_array (current_max_dfas);
	dss = allocate_int_ptr_array (current_max_dfas);
	dfaacc = allocate_dfaacc_union (current_max_dfas);
d1750 4
a1753 3
static char *basename2 (path, strip_ext)
     char   *path;
     int strip_ext;		/* boolean */
d1755 1
a1755 1
	char   *b, *e = 0;
d1769 2
a1770 1
void usage ()
d1772 1
a1772 1
	FILE   *f = stdout;
d1775 2
a1776 2
		snprintf (outfile_path, sizeof(outfile_path), outfile_template,
			 prefix, C_plus_plus ? "cc" : "c");
d1779 57
a1835 58

	fprintf (f, _("Usage: %s [OPTIONS] [FILE]...\n"), program_name);
	fprintf (f,
		 _
		 ("Generates programs that perform pattern-matching on text.\n"
		  "\n" "Table Compression:\n"
		  "  -Ca, --align      trade off larger tables for better memory alignment\n"
		  "  -Ce, --ecs        construct equivalence classes\n"
		  "  -Cf               do not compress tables; use -f representation\n"
		  "  -CF               do not compress tables; use -F representation\n"
		  "  -Cm, --meta-ecs   construct meta-equivalence classes\n"
		  "  -Cr, --read       use read() instead of stdio for scanner input\n"
		  "  -f, --full        generate fast, large scanner. Same as -Cfr\n"
		  "  -F, --fast        use alternate table representation. Same as -CFr\n"
		  "  -Cem              default compression (same as --ecs --meta-ecs)\n"
		  "\n" "Debugging:\n"
		  "  -d, --debug             enable debug mode in scanner\n"
		  "  -b, --backup            write backing-up information to %s\n"
		  "  -p, --perf-report       write performance report to stderr\n"
		  "  -s, --nodefault         suppress default rule to ECHO unmatched text\n"
		  "  -T, --trace             %s should run in trace mode\n"
		  "  -w, --nowarn            do not generate warnings\n"
		  "  -v, --verbose           write summary of scanner statistics to stdout\n"
		  "\n" "Files:\n"
		  "  -o, --outfile=FILE      specify output filename\n"
		  "  -S, --skel=FILE         specify skeleton file\n"
		  "  -t, --stdout            write scanner on stdout instead of %s\n"
		  "      --yyclass=NAME      name of C++ class\n"
		  "      --header-file=FILE   create a C header file in addition to the scanner\n"
		  "      --tables-file[=FILE] write tables to FILE\n" "\n"
		  "Scanner behavior:\n"
		  "  -7, --7bit              generate 7-bit scanner\n"
		  "  -8, --8bit              generate 8-bit scanner\n"
		  "  -B, --batch             generate batch scanner (opposite of -I)\n"
		  "  -i, --case-insensitive  ignore case in patterns\n"
		  "  -l, --lex-compat        maximal compatibility with original lex\n"
		  "  -X, --posix-compat      maximal compatibility with POSIX lex\n"
		  "  -I, --interactive       generate interactive scanner (opposite of -B)\n"
		  "      --yylineno          track line count in yylineno\n"
		  "\n" "Generated code:\n"
		  "  -+,  --c++               generate C++ scanner class\n"
		  "  -Dmacro[=defn]           #define macro defn  (default defn is '1')\n"
		  "  -L,  --noline            suppress #line directives in scanner\n"
		  "  -P,  --prefix=STRING     use STRING as prefix instead of \"yy\"\n"
		  "  -R,  --reentrant         generate a reentrant C scanner\n"
		  "       --bison-bridge      scanner for bison pure parser.\n"
		  "       --bison-locations   include yylloc support.\n"
		  "       --stdinit           initialize yyin/yyout to stdin/stdout\n"
          "       --noansi-definitions old-style function definitions\n"
          "       --noansi-prototypes  empty parameter list in prototypes\n"
		  "       --nounistd          do not include <unistd.h>\n"
		  "       --noFUNCTION        do not generate a particular FUNCTION\n"
		  "\n" "Miscellaneous:\n"
		  "  -n                      do-nothing POSIX option\n"
		  "  -?\n"
		  "  -h, --help              produce this help message\n"
		  "  -V, --version           report %s version\n"),
		 backing_name, program_name, outfile_path, program_name);
@


1.16
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.15 2015/10/10 05:47:54 deraadt Exp $	*/
d432 1
a432 1
        buf_m4_define (&m4defs_buf, "M4_YY_REENTRANT", NULL);
d441 1
a441 1
        buf_m4_define (&m4defs_buf, "<M4_YY_BISON_LLOC>", NULL);
d443 1
a443 1
    buf_m4_define(&m4defs_buf, "M4_YY_PREFIX", prefix);
d770 4
a773 4
        if (bison_bridge_lval)
            fputs ("--bison-bridge", stderr);
        if (bison_bridge_lloc)
            fputs ("--bison-locations", stderr);
d1617 8
a1624 8
                outn ("#ifdef VMS");
                outn ("#ifdef __VMS_POSIX");
                outn ("#define YY_STDINIT");
                outn ("#endif");
                outn ("#else");
                outn ("#define YY_STDINIT");
                outn ("#endif");
            }
d1635 1
a1635 3
		}

		else {
d1637 1
a1637 1
                outn (yy_nostdinit);
@


1.15
log
@Some of these large so easy to contain, with "stdio rpath".
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.14 2014/03/16 18:38:30 guenther Exp $	*/
d5 2
a6 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 *
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d8 2
a9 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.14 2014/03/16 18:38:30 guenther Exp $ */
d11 25
d39 2
a43 1

d46 4
a49 7
void flexinit PROTO((int, char**));
void readin PROTO((void));
void set_up_initial_allocations PROTO((void));

#ifdef NEED_ARGV_FIXUP
extern void argv_fixup PROTO((int *, char ***));
#endif
d53 40
a92 35
int printstats, syntaxerror, eofseen, ddebug, trace, nowarn, spprdflt;
int interactive, caseins, lex_compat, do_yylineno, useecs, fulltbl, usemecs;
int fullspd, gen_line_dirs, performance_report, backing_up_report;
int C_plus_plus, long_align, use_read, yytext_is_array, do_yywrap, csize;
int yymore_used, reject, real_reject, continued_action, in_rule;
int yymore_really_used, reject_really_used;
int datapos, dataline, linenum, out_linenum;
FILE *skelfile = NULL;
int skel_ind = 0;
char *action_array;
int action_size, defs1_offset, prolog_offset, action_offset, action_index;
char *infilename = NULL, *outfilename = NULL;
int did_outfilename;
char *prefix, *yyclass;
int do_stdinit, use_stdout;
int onestate[ONE_STACK_SIZE], onesym[ONE_STACK_SIZE];
int onenext[ONE_STACK_SIZE], onedef[ONE_STACK_SIZE], onesp;
int current_mns, current_max_rules;
int num_rules, num_eof_rules, default_rule, lastnfa;
int *firstst, *lastst, *finalst, *transchar, *trans1, *trans2;
int *accptnum, *assoc_rule, *state_type;
int *rule_type, *rule_linenum, *rule_useful;
int current_state_type;
int variable_trailing_context_rules;
int numtemps, numprots, protprev[MSP], protnext[MSP], prottbl[MSP];
int protcomst[MSP], firstprot, lastprot, protsave[PROT_SAVE_SIZE];
int numecs, nextecm[CSIZE + 1], ecgroup[CSIZE + 1], nummecs, tecfwd[CSIZE + 1];
int tecbck[CSIZE + 1];
int lastsc, *scset, *scbol, *scxclu, *sceof;
int current_max_scs;
char **scname;
int current_max_dfa_size, current_max_xpairs;
int current_max_template_xpairs, current_max_dfas;
int lastdfa, *nxt, *chk, *tnxt;
int *base, *def, *nultrans, NUL_ec, tblend, firstfree, **dss, *dfasiz;
d94 21
a114 13
int *accsiz, *dhash, numas;
int numsnpairs, jambase, jamstate;
int lastccl, *cclmap, *ccllen, *cclng, cclreuse;
int current_maxccls, current_max_ccl_tbl_size;
Char *ccltbl;
char nmstr[MAXLINE];
int sectnum, nummt, hshcol, dfaeql, numeps, eps2, num_reallocs;
int tmpuses, totnst, peakpairs, numuniq, numdup, hshsave;
int num_backing_up, bol_needed;
FILE *backing_up_file;
int end_of_buffer_state;
char **input_files;
int num_input_files;
d119 1
a119 1
char *program_name = "flex";
d122 3
a124 2
static const char outfile_template[] = "lex.%s.%s";
static const char backing_name[] = "lex.backup";
d126 3
a128 6
static const char outfile_template[] = "lex%s.%s";
static const char backing_name[] = "lex.bck";
#endif

#ifdef THINK_C
#include <console.h>
d135 3
d141 59
a199 37


int main( argc, argv )
int argc;
char **argv;
	{
	int i;

	if (pledge("stdio rpath wpath cpath", NULL) == -1)
		{
		fprintf( stderr, _( "%s: pledge\n" ),
			program_name);
		exit(1);
		}

#ifdef THINK_C
	argc = ccommand( &argv );
#endif
#ifdef NEED_ARGV_FIXUP
	argv_fixup( &argc, &argv );
#endif

	flexinit( argc, argv );

	readin();

	ntod();

	for ( i = 1; i <= num_rules; ++i )
		if ( ! rule_useful[i] && i != default_rule )
			line_warning( _( "rule cannot be matched" ),
					rule_linenum[i] );

	if ( spprdflt && ! reject && rule_useful[default_rule] )
		line_warning(
			_( "-s option given but default rule can be matched" ),
			rule_linenum[default_rule] );
d202 1
a202 1
	make_tables();
d207 1
a207 1
	flexend( 0 );
d209 2
a210 2
	return 0;
	}
d212 13
d226 1
a226 3
/* check_options - check user-specified options */

void check_options()
d228 4
a231 1
	int i;
d233 2
a234 4
	if ( lex_compat )
		{
		if ( C_plus_plus )
			flexerror( _( "Can't use -+ with -l option" ) );
d236 1
a236 2
		if ( fulltbl || fullspd )
			flexerror( _( "Can't use -f or -F with -l option" ) );
d238 15
a252 4
		/* Don't rely on detecting use of yymore() and REJECT,
		 * just assume they'll be used.
		 */
		yymore_really_used = reject_really_used = true;
d257 2
a258 1
		}
d260 3
a262 1
	if ( do_yylineno )
d265 1
d267 2
a268 3
	if ( csize == unspecified )
		{
		if ( (fulltbl || fullspd) && ! useecs )
d272 1
a272 1
		}
d274 2
a275 3
	if ( interactive == unspecified )
		{
		if ( fulltbl || fullspd )
d279 22
a300 1
		}
d302 4
a305 16
	if ( fulltbl || fullspd )
		{
		if ( usemecs )
			flexerror(
			_( "-Cf/-CF and -Cm don't make sense together" ) );

		if ( interactive )
			flexerror( _( "-Cf/-CF and -I are incompatible" ) );

		if ( lex_compat )
			flexerror(
		_( "-Cf/-CF are incompatible with lex-compatibility mode" ) );

		if ( do_yylineno )
			flexerror(
			_( "-Cf/-CF and %option yylineno are incompatible" ) );
d307 2
a308 3
		if ( fulltbl && fullspd )
			flexerror( _( "-Cf and -CF are mutually exclusive" ) );
		}
d310 2
a311 2
	if ( C_plus_plus && fullspd )
		flexerror( _( "Can't use -+ with -CF option" ) );
a312 5
	if ( C_plus_plus && yytext_is_array )
		{
		warn( _( "%array incompatible with -+ option" ) );
		yytext_is_array = false;
		}
d314 1
a314 2
	if ( useecs )
		{ /* Set up doubly-linked equivalence classes. */
d321 1
a321 2
		for ( i = 2; i <= csize; ++i )
			{
d324 1
a324 1
			}
d327 1
a327 1
		}
d329 1
a329 2
	else
		{
d331 1
a331 2
		for ( i = 1; i <= csize; ++i )
			{
a333 1
			}
d335 10
d346 2
a347 3
	if ( ! use_stdout )
		{
		FILE *prev_stdout;
d349 2
a350 3
		if ( ! did_outfilename )
			{
			char *suffix;
d352 1
a352 1
			if ( C_plus_plus )
d357 2
a358 2
			snprintf( outfile_path, sizeof outfile_path,
				outfile_template, prefix, suffix );
d361 1
a361 1
			}
d363 1
a363 1
		prev_stdout = freopen( outfilename, "w", stdout );
d365 2
a366 2
		if ( prev_stdout == NULL )
			lerrsf( _( "could not create %s" ), outfilename );
d369 2
a370 1
		}
d372 51
a422 2
	if ( skelname && (skelfile = fopen( skelname, "r" )) == NULL )
		lerrsf( _( "can't open skeleton file %s" ), skelname );
d424 3
a426 23
	if ( strcmp( prefix, "yy" ) )
		{
#define GEN_PREFIX(name) out_str3( "#define yy%s %s%s\n", name, prefix, name )
		if ( C_plus_plus )
			GEN_PREFIX( "FlexLexer" );
		else
			{
			GEN_PREFIX( "_create_buffer" );
			GEN_PREFIX( "_delete_buffer" );
			GEN_PREFIX( "_scan_buffer" );
			GEN_PREFIX( "_scan_string" );
			GEN_PREFIX( "_scan_bytes" );
			GEN_PREFIX( "_flex_debug" );
			GEN_PREFIX( "_init_buffer" );
			GEN_PREFIX( "_flush_buffer" );
			GEN_PREFIX( "_load_buffer_state" );
			GEN_PREFIX( "_switch_to_buffer" );
			GEN_PREFIX( "in" );
			GEN_PREFIX( "leng" );
			GEN_PREFIX( "lex" );
			GEN_PREFIX( "out" );
			GEN_PREFIX( "restart" );
			GEN_PREFIX( "text" );
d428 2
a429 3
			if ( do_yylineno )
				GEN_PREFIX( "lineno" );
			}
d431 5
a435 2
		if ( do_yywrap )
			GEN_PREFIX( "wrap" );
d437 2
a438 2
		outn( "" );
		}
d440 2
a441 2
	if ( did_outfilename )
		line_directive_out( stdout, 0 );
d443 1
a443 2
	skelout();
	}
d445 49
d501 19
a519 2
void flexend( exit_status )
int exit_status;
d521 186
a706 3
	{
	int tblsiz;
	int unlink();
d708 13
a720 10
	if ( skelfile != NULL )
		{
		if ( ferror( skelfile ) )
			lerrsf( _( "input error reading skeleton file %s" ),
				skelname );

		else if ( fclose( skelfile ) )
			lerrsf( _( "error closing skeleton file %s" ),
				skelname );
		}
a721 14
	if ( exit_status != 0 && outfile_created )
		{
		if ( ferror( stdout ) )
			lerrsf( _( "error writing output file %s" ),
				outfilename );

		else if ( fclose( stdout ) )
			lerrsf( _( "error closing output file %s" ),
				outfilename );

		else if ( unlink( outfilename ) )
			lerrsf( _( "error deleting output file %s" ),
				outfilename );
		}
d723 8
a730 8
	if ( backing_up_report && backing_up_file )
		{
		if ( num_backing_up == 0 )
			fprintf( backing_up_file, _( "No backing up.\n" ) );
		else if ( fullspd || fulltbl )
			fprintf( backing_up_file,
				_( "%d backing up (non-accepting) states.\n" ),
				num_backing_up );
d732 2
a733 2
			fprintf( backing_up_file,
				_( "Compressed tables always back up.\n" ) );
d735 8
a742 8
		if ( ferror( backing_up_file ) )
			lerrsf( _( "error writing backup file %s" ),
				backing_name );

		else if ( fclose( backing_up_file ) )
			lerrsf( _( "error closing backup file %s" ),
				backing_name );
		}
d744 44
a787 37
	if ( printstats )
		{
		fprintf( stderr, _( "%s version %s usage statistics:\n" ),
			program_name, flex_version );

		fprintf( stderr, _( "  scanner options: -" ) );

		if ( C_plus_plus )
			putc( '+', stderr );
		if ( backing_up_report )
			putc( 'b', stderr );
		if ( ddebug )
			putc( 'd', stderr );
		if ( caseins )
			putc( 'i', stderr );
		if ( lex_compat )
			putc( 'l', stderr );
		if ( performance_report > 0 )
			putc( 'p', stderr );
		if ( performance_report > 1 )
			putc( 'p', stderr );
		if ( spprdflt )
			putc( 's', stderr );
		if ( use_stdout )
			putc( 't', stderr );
		if ( printstats )
			putc( 'v', stderr );	/* always true! */
		if ( nowarn )
			putc( 'w', stderr );
		if ( interactive == false )
			putc( 'B', stderr );
		if ( interactive == true )
			putc( 'I', stderr );
		if ( ! gen_line_dirs )
			putc( 'L', stderr );
		if ( trace )
			putc( 'T', stderr );
d789 1
a789 1
		if ( csize == unspecified )
d796 2
a797 2
		if ( csize == 128 )
			putc( '7', stderr );
d799 1
a799 1
			putc( '8', stderr );
d801 1
a801 1
		fprintf( stderr, " -C" );
d803 39
a841 37
		if ( long_align )
			putc( 'a', stderr );
		if ( fulltbl )
			putc( 'f', stderr );
		if ( fullspd )
			putc( 'F', stderr );
		if ( useecs )
			putc( 'e', stderr );
		if ( usemecs )
			putc( 'm', stderr );
		if ( use_read )
			putc( 'r', stderr );

		if ( did_outfilename )
			fprintf( stderr, " -o%s", outfilename );

		if ( skelname )
			fprintf( stderr, " -S%s", skelname );

		if ( strcmp( prefix, "yy" ) )
			fprintf( stderr, " -P%s", prefix );

		putc( '\n', stderr );

		fprintf( stderr, _( "  %d/%d NFA states\n" ),
			lastnfa, current_mns );
		fprintf( stderr, _( "  %d/%d DFA states (%d words)\n" ),
			lastdfa, current_max_dfas, totnst );
		fprintf( stderr, _( "  %d rules\n" ),
		num_rules + num_eof_rules - 1 /* - 1 for def. rule */ );

		if ( num_backing_up == 0 )
			fprintf( stderr, _( "  No backing up\n" ) );
		else if ( fullspd || fulltbl )
			fprintf( stderr,
			_( "  %d backing-up (non-accepting) states\n" ),
				num_backing_up );
d843 14
a856 12
			fprintf( stderr,
				_( "  Compressed tables always back-up\n" ) );

		if ( bol_needed )
			fprintf( stderr,
				_( "  Beginning-of-line patterns used\n" ) );

		fprintf( stderr, _( "  %d/%d start conditions\n" ), lastsc,
			current_max_scs );
		fprintf( stderr,
			_( "  %d epsilon states, %d double epsilon states\n" ),
			numeps, eps2 );
d858 2
a859 2
		if ( lastccl == 0 )
			fprintf( stderr, _( "  no character classes\n" ) );
d861 12
a872 10
			fprintf( stderr,
_( "  %d/%d character classes needed %d/%d words of storage, %d reused\n" ),
				lastccl, current_maxccls,
				cclmap[lastccl] + ccllen[lastccl],
				current_max_ccl_tbl_size, cclreuse );

		fprintf( stderr, _( "  %d state/nextstate pairs created\n" ),
			numsnpairs );
		fprintf( stderr, _( "  %d/%d unique/duplicate transitions\n" ),
			numuniq, numdup );
d874 1
a874 2
		if ( fulltbl )
			{
d876 3
a878 2
			fprintf( stderr, _( "  %d table entries\n" ), tblsiz );
			}
d880 1
a880 2
		else
			{
d883 21
a903 19
			fprintf( stderr,
				_( "  %d/%d base-def entries created\n" ),
				lastdfa + numtemps, current_max_dfas );
			fprintf( stderr,
			_( "  %d/%d (peak %d) nxt-chk entries created\n" ),
				tblend, current_max_xpairs, peakpairs );
			fprintf( stderr,
		_( "  %d/%d (peak %d) template nxt-chk entries created\n" ),
				numtemps * nummecs,
				current_max_template_xpairs,
				numtemps * numecs );
			fprintf( stderr, _( "  %d empty table entries\n" ),
				nummt );
			fprintf( stderr, _( "  %d protos created\n" ),
				numprots );
			fprintf( stderr,
				_( "  %d templates created, %d uses\n" ),
				numtemps, tmpuses );
			}
d905 1
a905 2
		if ( useecs )
			{
d907 5
a911 4
			fprintf( stderr,
				_( "  %d/%d equivalence classes created\n" ),
				numecs, csize );
			}
d913 1
a913 2
		if ( usemecs )
			{
d915 4
a918 12
			fprintf( stderr,
			_( "  %d/%d meta-equivalence classes created\n" ),
				nummecs, csize );
			}

		fprintf( stderr,
		_( "  %d (%d saved) hash collisions, %d DFAs equal\n" ),
			hshcol, hshsave, dfaeql );
		fprintf( stderr, _( "  %d sets of reallocations needed\n" ),
			num_reallocs );
		fprintf( stderr, _( "  %d total table entries needed\n" ),
			tblsiz );
d921 8
a928 1
	exit( exit_status );
d931 3
d937 15
a951 11
void flexinit( argc, argv )
int argc;
char **argv;
	{
	int i, sawcmpflag;
	char *arg;

	printstats = syntaxerror = trace = spprdflt = caseins = false;
	lex_compat = C_plus_plus = backing_up_report = ddebug = fulltbl = false;
	fullspd = long_align = nowarn = yymore_used = continued_action = false;
	do_yylineno = yytext_is_array = in_rule = reject = do_stdinit = false;
d955 1
d961 4
d970 1
a970 1
	action_array = allocate_character_array( action_size );
d974 20
a993 1
	program_name = argv[0];
d995 2
a996 2
	if ( program_name[0] != '\0' &&
	     program_name[strlen( program_name ) - 1] == '+' )
d1000 9
a1008 22
	for ( --argc, ++argv; argc ; --argc, ++argv )
		{
		arg = argv[0];

		if ( arg[0] != '-' || arg[1] == '\0' )
			break;

		if ( arg[1] == '-' )
			{ /* --option */
			if ( ! strcmp( arg, "--help" ) )
				arg = "-h";

			else if ( ! strcmp( arg, "--version" ) )
				arg = "-V";

			else if ( ! strcmp( arg, "--" ) )
				{ /* end of options */
				--argc;
				++argv;
				break;
				}
			}
d1010 8
a1017 6
		for ( i = 1; arg[i] != '\0'; ++i )
			switch ( arg[i] )
				{
				case '+':
					C_plus_plus = true;
					break;
d1019 4
a1022 3
				case 'B':
					interactive = false;
					break;
d1024 3
a1026 3
				case 'b':
					backing_up_report = true;
					break;
d1028 3
a1030 2
				case 'c':
					break;
d1032 2
a1033 47
				case 'C':
					if ( i != 1 )
						flexerror(
				_( "-C flag must be given separately" ) );

					if ( ! sawcmpflag )
						{
						useecs = false;
						usemecs = false;
						fulltbl = false;
						sawcmpflag = true;
						}

					for ( ++i; arg[i] != '\0'; ++i )
						switch ( arg[i] )
							{
							case 'a':
								long_align =
									true;
								break;

							case 'e':
								useecs = true;
								break;

							case 'F':
								fullspd = true;
								break;

							case 'f':
								fulltbl = true;
								break;

							case 'm':
								usemecs = true;
								break;

							case 'r':
								use_read = true;
								break;

							default:
								lerrif(
						_( "unknown -C option '%c'" ),
								(int) arg[i] );
								break;
							}
d1035 7
a1041 1
					goto get_next_arg;
d1043 4
a1046 2
				case 'd':
					ddebug = true;
d1049 2
a1050 3
				case 'f':
					useecs = usemecs = false;
					use_read = fulltbl = true;
d1054 1
a1054 2
					useecs = usemecs = false;
					use_read = fullspd = true;
d1057 3
a1059 4
				case '?':
				case 'h':
					usage();
					exit( 0 );
d1061 2
a1062 2
				case 'I':
					interactive = true;
d1065 2
a1066 2
				case 'i':
					caseins = true;
d1069 4
a1072 2
				case 'l':
					lex_compat = true;
d1074 2
d1077 137
a1213 3
				case 'L':
					gen_line_dirs = false;
					break;
d1215 3
a1217 5
				case 'n':
					/* Stupid do-nothing deprecated
					 * option.
					 */
					break;
d1219 3
a1221 13
				case 'o':
					if ( i != 1 )
						flexerror(
				_( "-o flag must be given separately" ) );

					outfilename = arg + i + 1;
					did_outfilename = 1;
					goto get_next_arg;

				case 'P':
					if ( i != 1 )
						flexerror(
				_( "-P flag must be given separately" ) );
d1223 3
a1225 2
					prefix = arg + i + 1;
					goto get_next_arg;
d1227 3
a1229 3
				case 'p':
					++performance_report;
					break;
d1231 3
a1233 4
				case 'S':
					if ( i != 1 )
						flexerror(
				_( "-S flag must be given separately" ) );
d1235 3
a1237 2
					skelname = arg + i + 1;
					goto get_next_arg;
d1239 3
a1241 3
				case 's':
					spprdflt = true;
					break;
d1243 3
a1245 3
				case 't':
					use_stdout = true;
					break;
d1247 3
a1249 3
				case 'T':
					trace = true;
					break;
d1251 3
a1253 3
				case 'v':
					printstats = true;
					break;
d1255 3
a1257 4
				case 'V':
					printf( _( "%s version %s\n" ),
						program_name, flex_version );
					exit( 0 );
d1259 3
a1261 3
				case 'w':
					nowarn = true;
					break;
d1263 4
a1266 3
				case '7':
					csize = 128;
					break;
d1268 2
a1269 3
				case '8':
					csize = CSIZE;
					break;
d1271 13
a1283 6
				default:
					fprintf( stderr,
		_( "%s: unknown flag '%c'.  For usage, try\n\t%s --help\n" ),
						program_name, (int) arg[i],
						program_name );
					exit( 1 );
d1285 6
d1292 146
a1437 5
		/* Used by -C, -S, -o, and -P flags in lieu of a "continue 2"
		 * control.
		 */
		get_next_arg: ;
		}
d1439 3
a1441 3
	num_input_files = argc;
	input_files = argv;
	set_input_file( num_input_files > 0 ? input_files[0] : NULL );
d1446 2
a1447 1
	numecs = numeps = eps2 = num_reallocs = hshcol = dfaeql = totnst = 0;
d1452 1
a1452 1
	out_linenum = linenum = sectnum = 1;
d1460 2
a1461 2
	set_up_initial_allocations();
	}
d1466 2
a1467 2
void readin()
	{
d1472 1
a1472 1
	line_directive_out( (FILE *) 0, 1 );
d1474 24
a1497 5
	if ( yyparse() )
		{
		pinpoint_message( _( "fatal parse error" ) );
		flexend( 1 );
		}
d1499 3
a1501 2
	if ( syntaxerror )
		flexend( 1 );
d1503 7
a1509 8
	if ( backing_up_report )
		{
		backing_up_file = fopen( backing_name, "w" );
		if ( backing_up_file == NULL )
			lerrsf(
			_( "could not create backing-up info file %s" ),
				backing_name );
		}
d1514 1
a1514 1
	if ( yymore_really_used == true )
d1516 1
a1516 1
	else if ( yymore_really_used == false )
d1519 1
a1519 1
	if ( reject_really_used == true )
d1521 1
a1521 1
	else if ( reject_really_used == false )
d1524 38
a1561 9
	if ( performance_report > 0 )
		{
		if ( lex_compat )
			{
			fprintf( stderr,
_( "-l AT&T lex compatibility option entails a large performance penalty\n" ) );
			fprintf( stderr,
_( " and may be the actual source of other reported performance penalties\n" ) );
			}
d1563 1
a1563 27
		else if ( do_yylineno )
			{
			fprintf( stderr,
	_( "%%option yylineno entails a large performance penalty\n" ) );
			}

		if ( performance_report > 1 )
			{
			if ( interactive )
				fprintf( stderr,
	_( "-I (interactive) entails a minor performance penalty\n" ) );

			if ( yymore_used )
				fprintf( stderr,
		_( "yymore() entails a minor performance penalty\n" ) );
			}

		if ( reject )
			fprintf( stderr,
			_( "REJECT entails a large performance penalty\n" ) );

		if ( variable_trailing_context_rules )
			fprintf( stderr,
_( "Variable trailing context rules entail a large performance penalty\n" ) );
		}

	if ( reject )
d1566 1
a1566 1
	if ( variable_trailing_context_rules )
d1569 7
a1575 8
	if ( (fulltbl || fullspd) && reject )
		{
		if ( real_reject )
			flexerror(
				_( "REJECT cannot be used with -f or -F" ) );
		else if ( do_yylineno )
			flexerror(
			_( "%option yylineno cannot be used with -f or -F" ) );
d1577 3
a1579 3
			flexerror(
	_( "variable trailing context rules cannot be used with -f or -F" ) );
		}
d1581 13
a1593 8
	if ( reject )
		outn( "\n#define YY_USES_REJECT" );

	if ( ! do_yywrap )
		{
		outn( "\n#define yywrap() 1" );
		outn( "#define YY_SKIP_YYWRAP" );
		}
d1595 2
a1596 2
	if ( ddebug )
		outn( "\n#define FLEX_DEBUG" );
d1598 3
a1600 2
	if ( csize == 256 )
		outn( "typedef unsigned char YY_CHAR;" );
d1602 5
a1606 1
		outn( "typedef char YY_CHAR;" );
d1608 3
a1610 3
	if ( C_plus_plus )
		{
		outn( "#define yytext_ptr yytext" );
d1612 28
a1639 2
		if ( interactive )
			outn( "#define YY_INTERACTIVE" );
d1641 2
d1644 16
a1659 14
	else
		{
		if ( do_stdinit )
			{
			outn( "#ifdef VMS" );
			outn( "#ifndef __VMS_POSIX" );
			outn( yy_nostdinit );
			outn( "#else" );
			outn( yy_stdinit );
			outn( "#endif" );
			outn( "#else" );
			outn( yy_stdinit );
			outn( "#endif" );
			}
d1661 2
a1662 3
		else
			outn( yy_nostdinit );
		}
d1664 2
a1665 15
	if ( fullspd )
		outn( "typedef yyconst struct yy_trans_info *yy_state_type;" );
	else if ( ! C_plus_plus )
		outn( "typedef int yy_state_type;" );

	if ( ddebug )
		outn( "\n#define FLEX_DEBUG" );

	if ( lex_compat )
		outn( "#define YY_FLEX_LEX_COMPAT" );

	if ( do_yylineno && ! C_plus_plus )
		{
		outn( "extern int yylineno;" );
		outn( "int yylineno = 1;" );
d1668 6
a1673 3
	if ( C_plus_plus )
		{
		outn( "\n#include <FlexLexer.h>" );
d1675 2
a1676 12
		if ( yyclass )
			{
			outn( "int yyFlexLexer::yylex()" );
			outn( "\t{" );
			outn(
"\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );" );
			outn( "\treturn 0;" );
			outn( "\t}" );
	
			out_str( "\n#define YY_DECL int %s::yylex()\n",
				yyclass );
			}
d1678 1
d1680 1
a1680 4
	else
		{
		if ( yytext_is_array )
			outn( "extern char yytext[];\n" );
d1682 14
a1695 4
		else
			{
			outn( "extern char *yytext;" );
			outn( "#define yytext_ptr yytext" );
d1697 1
d1699 4
a1702 4
		if ( yyclass )
			flexerror(
		_( "%option yyclass only meaningful for C++ scanners" ) );
		}
d1704 2
a1705 2
	if ( useecs )
		numecs = cre8ecs( nextecm, ecgroup, csize );
d1711 1
a1711 1
	NUL_ec = ABS( ecgroup[0] );
d1713 3
a1715 3
	if ( useecs )
		ccl2ecl();
	}
d1720 3
a1722 2
void set_up_initial_allocations()
	{
d1724 9
a1732 9
	firstst = allocate_integer_array( current_mns );
	lastst = allocate_integer_array( current_mns );
	finalst = allocate_integer_array( current_mns );
	transchar = allocate_integer_array( current_mns );
	trans1 = allocate_integer_array( current_mns );
	trans2 = allocate_integer_array( current_mns );
	accptnum = allocate_integer_array( current_mns );
	assoc_rule = allocate_integer_array( current_mns );
	state_type = allocate_integer_array( current_mns );
d1735 4
a1738 3
	rule_type = allocate_integer_array( current_max_rules );
	rule_linenum = allocate_integer_array( current_max_rules );
	rule_useful = allocate_integer_array( current_max_rules );
d1741 5
a1745 5
	scset = allocate_integer_array( current_max_scs );
	scbol = allocate_integer_array( current_max_scs );
	scxclu = allocate_integer_array( current_max_scs );
	sceof = allocate_integer_array( current_max_scs );
	scname = allocate_char_ptr_array( current_max_scs );
d1748 4
a1751 3
	cclmap = allocate_integer_array( current_maxccls );
	ccllen = allocate_integer_array( current_maxccls );
	cclng = allocate_integer_array( current_maxccls );
d1754 1
a1754 1
	ccltbl = allocate_Character_array( current_max_ccl_tbl_size );
d1759 2
a1760 2
	nxt = allocate_integer_array( current_max_xpairs );
	chk = allocate_integer_array( current_max_xpairs );
d1763 1
a1763 1
	tnxt = allocate_integer_array( current_max_template_xpairs );
d1766 7
a1772 7
	base = allocate_integer_array( current_max_dfas );
	def = allocate_integer_array( current_max_dfas );
	dfasiz = allocate_integer_array( current_max_dfas );
	accsiz = allocate_integer_array( current_max_dfas );
	dhash = allocate_integer_array( current_max_dfas );
	dss = allocate_int_ptr_array( current_max_dfas );
	dfaacc = allocate_dfaacc_union( current_max_dfas );
d1775 1
a1775 1
	}
d1778 29
a1806 3
void usage()
	{
	FILE *f = stdout;
d1808 57
a1864 23
	fprintf( f,
_( "%s [-bdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n" ),
		program_name );
	fprintf( f, _( "\t[--help --version] [file ...]\n" ) );

	fprintf( f, _( "\t-b  generate backing-up information to %s\n" ),
		backing_name );
	fprintf( f, _( "\t-d  turn on debug mode in generated scanner\n" ) );
	fprintf( f, _( "\t-f  generate fast, large scanner\n" ) );
	fprintf( f, _( "\t-h  produce this help message\n" ) );
	fprintf( f, _( "\t-i  generate case-insensitive scanner\n" ) );
	fprintf( f, _( "\t-l  maximal compatibility with original lex\n" ) );
	fprintf( f, _( "\t-n  do-nothing POSIX option\n" ) );
	fprintf( f, _( "\t-p  generate performance report to stderr\n" ) );
	fprintf( f,
		_( "\t-s  suppress default rule to ECHO unmatched text\n" ) );

	if ( ! did_outfilename )
		{
		snprintf( outfile_path, sizeof outfile_path, outfile_template,
			prefix, C_plus_plus ? "cc" : "c" );
		outfilename = outfile_path;
		}
d1866 1
a1866 37
	fprintf( f,
		_( "\t-t  write generated scanner on stdout instead of %s\n" ),
		outfilename );

	fprintf( f,
		_( "\t-v  write summary of scanner statistics to f\n" ) );
	fprintf( f, _( "\t-w  do not generate warnings\n" ) );
	fprintf( f, _( "\t-B  generate batch scanner (opposite of -I)\n" ) );
	fprintf( f,
		_( "\t-F  use alternative fast scanner representation\n" ) );
	fprintf( f,
		_( "\t-I  generate interactive scanner (opposite of -B)\n" ) );
	fprintf( f, _( "\t-L  suppress #line directives in scanner\n" ) );
	fprintf( f, _( "\t-T  %s should run in trace mode\n" ), program_name );
	fprintf( f, _( "\t-V  report %s version\n" ), program_name );
	fprintf( f, _( "\t-7  generate 7-bit scanner\n" ) );
	fprintf( f, _( "\t-8  generate 8-bit scanner\n" ) );
	fprintf( f, _( "\t-+  generate C++ scanner class\n" ) );
	fprintf( f, _( "\t-?  produce this help message\n" ) );
	fprintf( f,
_( "\t-C  specify degree of table compression (default is -Cem):\n" ) );
	fprintf( f,
_( "\t\t-Ca  trade off larger tables for better memory alignment\n" ) );
	fprintf( f, _( "\t\t-Ce  construct equivalence classes\n" ) );
	fprintf( f,
_( "\t\t-Cf  do not compress scanner tables; use -f representation\n" ) );
	fprintf( f,
_( "\t\t-CF  do not compress scanner tables; use -F representation\n" ) );
	fprintf( f, _( "\t\t-Cm  construct meta-equivalence classes\n" ) );
	fprintf( f,
	_( "\t\t-Cr  use read() instead of stdio for scanner input\n" ) );
	fprintf( f, _( "\t-o  specify output filename\n" ) );
	fprintf( f, _( "\t-P  specify scanner prefix other than \"yy\"\n" ) );
	fprintf( f, _( "\t-S  specify skeleton file\n" ) );
	fprintf( f, _( "\t--help     produce this help message\n" ) );
	fprintf( f, _( "\t--version  report %s version\n" ), program_name );
	}
@


1.14
log
@lint is dead (long live the lint!), so stop using it as a cpp conditional
(namespace pollution!) or talking about its opinion on code.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.13 2013/10/27 18:31:24 guenther Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.13 2013/10/27 18:31:24 guenther Exp $ */
d138 7
@


1.13
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.12 2011/06/08 20:22:02 jmc Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.12 2011/06/08 20:22:02 jmc Exp $ */
d170 1
a170 1
	return 0;	/* keep compilers/lint happy */
@


1.12
log
@do not document the -c flag: it was added for posix compliance,
but posix deprecated this option in issue 6 (code remains though);

from Daniel Dickman
ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.11 2009/10/27 23:59:39 deraadt Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.11 2009/10/27 23:59:39 deraadt Exp $ */
d113 2
a114 2
static char *outfile_template = "lex.%s.%s";
static char *backing_name = "lex.backup";
d116 2
a117 2
static char *outfile_template = "lex%s.%s";
static char *backing_name = "lex.bck";
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.10 2004/02/03 21:20:17 espie Exp $	*/
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.10 2004/02/03 21:20:17 espie Exp $ */
d1118 1
a1118 1
_( "%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n" ),
a1123 1
	fprintf( f, _( "\t-c  do-nothing POSIX option\n" ) );
@


1.10
log
@bring some standard C++ fixes, mostly from NetBSD.
get isatty proto from the right place.
avoid malloc.h

okay otto@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.9 2003/06/04 17:34:44 millert Exp $	*/
d36 1
a36 7
#ifndef lint
char copyright[] =
"@@(#) Copyright (c) 1990 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

/* $Header: /spare/open/cvs/src/usr.bin/lex/main.c,v 1.9 2003/06/04 17:34:44 millert Exp $ */
@


1.9
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.8 2002/05/31 22:49:29 deraadt Exp $	*/
d42 1
a42 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.8 2002/05/31 22:49:29 deraadt Exp $ */
d1016 1
a1016 1
		outn( "\n#include <g++/FlexLexer.h>" );
@


1.8
log
@recommit strlcpy/snprintf diff after i found my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.6 2002/05/30 10:53:44 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d42 1
a42 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.6 2002/05/30 10:53:44 deraadt Exp $ */
@


1.7
log
@undo until i find my #line bug
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $	*/
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.5 2001/06/17 07:30:42 deraadt Exp $ */
d289 2
a290 2
			sprintf( outfile_path, outfile_template,
				prefix, suffix );
d1138 1
a1138 1
		sprintf( outfile_path, outfile_template,
@


1.6
log
@use strlcpy and snprintf
@
text
@d289 2
a290 2
			snprintf( outfile_path, sizeof outfile_path,
				outfile_template, prefix, suffix );
d1138 1
a1138 1
		snprintf( outfile_path, sizeof outfile_path, outfile_template,
@


1.5
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.4 1998/08/17 03:20:25 deraadt Exp $	*/
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.4 1998/08/17 03:20:25 deraadt Exp $ */
d289 2
a290 2
			sprintf( outfile_path, outfile_template,
				prefix, suffix );
d1138 1
a1138 1
		sprintf( outfile_path, outfile_template,
@


1.4
log
@fix g++/FlexLexer.h support
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.3 1996/07/13 22:22:08 millert Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.3 1996/07/13 22:22:08 millert Exp $ */
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: main.c,v 1.2 1996/06/26 05:35:38 deraadt Exp $	*/
d37 1
a37 1
/* $Header: /home/daffy/u0/vern/flex/RCS/main.c,v 2.64 96/05/25 20:42:42 vern Exp $ */
d1011 1
a1011 1
		outn( "\n#include <FlexLexer.h>" );
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/main.c,v 1.1.1.1 1995/10/18 08:45:31 deraadt Exp $ */
d590 1
a590 1
	char *arg, *mktemp();
@


1.1
log
@Initial revision
@
text
@d1 2
d37 1
a37 1
/* $Header: /a/cvsroot/src/usr.bin/lex/main.c,v 1.9 1995/05/05 05:35:34 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
