head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.52
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.44
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.48
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.46
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.42
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.40
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.38
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.36
	OPENBSD_5_0:1.9.0.34
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.32
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.30
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.26
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.28
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.24
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.22
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.20
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.11.19.22.52.40;	author tedu;	state Exp;
branches;
next	1.10;
commitid	cuVuNj9APX2eFzx2;

1.10
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.9;
commitid	TCPdLh99ETkn9X6R;

1.9
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.31.22.49.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.00.56.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.30.10.53.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.11
log
@orbital strike from moonbase knf
@
text
@/*	$OpenBSD: nfa.c,v 1.10 2015/11/19 19:43:40 tedu Exp $	*/

/* nfa - NFA construction routines */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"


/* declare functions that have forward references */

int dupmachine PROTO((int));
void mkxtion PROTO((int, int));


/* add_accept - add an accepting state to a machine
 *
 * accepting_number becomes mach's accepting number.
 */

void 
add_accept(mach, accepting_number)
	int mach, accepting_number;
{
	/*
	 * Hang the accepting number off an epsilon state.  if it is
	 * associated with a state that has a non-epsilon out-transition,
	 * then the state will accept BEFORE it makes that transition, i.e.,
	 * one character too soon.
	 */

	if (transchar[finalst[mach]] == SYM_EPSILON)
		accptnum[finalst[mach]] = accepting_number;

	else {
		int astate = mkstate(SYM_EPSILON);

		accptnum[astate] = accepting_number;
		(void) link_machines(mach, astate);
	}
}


/* copysingl - make a given number of copies of a singleton machine
 *
 * synopsis
 *
 *   newsng = copysingl( singl, num );
 *
 *     newsng - a new singleton composed of num copies of singl
 *     singl  - a singleton machine
 *     num    - the number of copies of singl to be present in newsng
 */

int 
copysingl(singl, num)
	int singl, num;
{
	int copy, i;

	copy = mkstate(SYM_EPSILON);

	for (i = 1; i <= num; ++i)
		copy = link_machines(copy, dupmachine(singl));

	return copy;
}


/* dumpnfa - debugging routine to write out an nfa */

void 
dumpnfa(state1)
	int state1;

{
	int sym, tsp1, tsp2, anum, ns;

	fprintf(stderr,
	    _
	    ("\n\n********** beginning dump of nfa with start state %d\n"),
	    state1);

	/*
	 * We probably should loop starting at firstst[state1] and going to
	 * lastst[state1], but they're not maintained properly when we "or"
	 * all of the rules together.  So we use our knowledge that the
	 * machine starts at state 1 and ends at lastnfa.
	 */

	/* for ( ns = firstst[state1]; ns <= lastst[state1]; ++ns ) */
	for (ns = 1; ns <= lastnfa; ++ns) {
		fprintf(stderr, _("state # %4d\t"), ns);

		sym = transchar[ns];
		tsp1 = trans1[ns];
		tsp2 = trans2[ns];
		anum = accptnum[ns];

		fprintf(stderr, "%3d:  %4d, %4d", sym, tsp1, tsp2);

		if (anum != NIL)
			fprintf(stderr, "  [%d]", anum);

		fprintf(stderr, "\n");
	}

	fprintf(stderr, _("********** end of dump\n"));
}


/* dupmachine - make a duplicate of a given machine
 *
 * synopsis
 *
 *   copy = dupmachine( mach );
 *
 *     copy - holds duplicate of mach
 *     mach - machine to be duplicated
 *
 * note that the copy of mach is NOT an exact duplicate; rather, all the
 * transition states values are adjusted so that the copy is self-contained,
 * as the original should have been.
 *
 * also note that the original MUST be contiguous, with its low and high
 * states accessible by the arrays firstst and lastst
 */

int 
dupmachine(mach)
	int mach;
{
	int i, init, state_offset;
	int state = 0;
	int last = lastst[mach];

	for (i = firstst[mach]; i <= last; ++i) {
		state = mkstate(transchar[i]);

		if (trans1[i] != NO_TRANSITION) {
			mkxtion(finalst[state], trans1[i] + state - i);

			if (transchar[i] == SYM_EPSILON &&
			    trans2[i] != NO_TRANSITION)
				mkxtion(finalst[state],
				    trans2[i] + state - i);
		}
		accptnum[state] = accptnum[i];
	}

	if (state == 0)
		flexfatal(_("empty machine in dupmachine()"));

	state_offset = state - i + 1;

	init = mach + state_offset;
	firstst[init] = firstst[mach] + state_offset;
	finalst[init] = finalst[mach] + state_offset;
	lastst[init] = lastst[mach] + state_offset;

	return init;
}


/* finish_rule - finish up the processing for a rule
 *
 * An accepting number is added to the given machine.  If variable_trail_rule
 * is true then the rule has trailing context and both the head and trail
 * are variable size.  Otherwise if headcnt or trailcnt is non-zero then
 * the machine recognizes a pattern with trailing context and headcnt is
 * the number of characters in the matched part of the pattern, or zero
 * if the matched part has variable length.  trailcnt is the number of
 * trailing context characters in the pattern, or zero if the trailing
 * context has variable length.
 */

void 
finish_rule(mach, variable_trail_rule, headcnt, trailcnt,
    pcont_act)
	int mach, variable_trail_rule, headcnt, trailcnt, pcont_act;
{
	char action_text[MAXLINE];

	add_accept(mach, num_rules);

	/*
	 * We did this in new_rule(), but it often gets the wrong number
	 * because we do it before we start parsing the current rule.
	 */
	rule_linenum[num_rules] = linenum;

	/*
	 * If this is a continued action, then the line-number has already
	 * been updated, giving us the wrong number.
	 */
	if (continued_action)
		--rule_linenum[num_rules];


	/*
	 * If the previous rule was continued action, then we inherit the
	 * previous newline flag, possibly overriding the current one.
	 */
	if (pcont_act && rule_has_nl[num_rules - 1])
		rule_has_nl[num_rules] = true;

	snprintf(action_text, sizeof(action_text), "case %d:\n", num_rules);
	add_action(action_text);
	if (rule_has_nl[num_rules]) {
		snprintf(action_text, sizeof(action_text), "/* rule %d can match eol */\n",
		    num_rules);
		add_action(action_text);
	}
	if (variable_trail_rule) {
		rule_type[num_rules] = RULE_VARIABLE;

		if (performance_report > 0)
			fprintf(stderr,
			    _
			    ("Variable trailing context rule at line %d\n"),
			    rule_linenum[num_rules]);

		variable_trailing_context_rules = true;
	} else {
		rule_type[num_rules] = RULE_NORMAL;

		if (headcnt > 0 || trailcnt > 0) {
			/*
			 * Do trailing context magic to not match the
			 * trailing characters.
			 */
			char *scanner_cp = "YY_G(yy_c_buf_p) = yy_cp";
			char *scanner_bp = "yy_bp";

			add_action
			    ("*yy_cp = YY_G(yy_hold_char); /* undo effects of setting up yytext */\n");

			if (headcnt > 0) {
				if (rule_has_nl[num_rules]) {
					snprintf(action_text, sizeof(action_text),
					    "YY_LINENO_REWIND_TO(%s + %d);\n", scanner_bp, headcnt);
					add_action(action_text);
				}
				snprintf(action_text, sizeof(action_text), "%s = %s + %d;\n",
				    scanner_cp, scanner_bp, headcnt);
				add_action(action_text);
			} else {
				if (rule_has_nl[num_rules]) {
					snprintf(action_text, sizeof(action_text),
					    "YY_LINENO_REWIND_TO(yy_cp - %d);\n", trailcnt);
					add_action(action_text);
				}
				snprintf(action_text, sizeof(action_text), "%s -= %d;\n",
				    scanner_cp, trailcnt);
				add_action(action_text);
			}

			add_action
			    ("YY_DO_BEFORE_ACTION; /* set up yytext again */\n");
		}
	}

	/*
	 * Okay, in the action code at this point yytext and yyleng have
	 * their proper final values for this rule, so here's the point to do
	 * any user action.  But don't do it for continued actions, as
	 * that'll result in multiple YY_RULE_SETUP's.
	 */
	if (!continued_action)
		add_action("YY_RULE_SETUP\n");

	line_directive_out((FILE *) 0, 1);
}


/* link_machines - connect two machines together
 *
 * synopsis
 *
 *   new = link_machines( first, last );
 *
 *     new    - a machine constructed by connecting first to last
 *     first  - the machine whose successor is to be last
 *     last   - the machine whose predecessor is to be first
 *
 * note: this routine concatenates the machine first with the machine
 *  last to produce a machine new which will pattern-match first first
 *  and then last, and will fail if either of the sub-patterns fails.
 *  FIRST is set to new by the operation.  last is unmolested.
 */

int 
link_machines(first, last)
	int first, last;
{
	if (first == NIL)
		return last;

	else if (last == NIL)
		return first;

	else {
		mkxtion(finalst[first], last);
		finalst[first] = finalst[last];
		lastst[first] = MAX(lastst[first], lastst[last]);
		firstst[first] = MIN(firstst[first], firstst[last]);

		return first;
	}
}


/* mark_beginning_as_normal - mark each "beginning" state in a machine
 *                            as being a "normal" (i.e., not trailing context-
 *                            associated) states
 *
 * The "beginning" states are the epsilon closure of the first state
 */

void 
mark_beginning_as_normal(mach)
	int mach;
{
	switch (state_type[mach]) {
	case STATE_NORMAL:
		/* Oh, we've already visited here. */
		return;

	case STATE_TRAILING_CONTEXT:
		state_type[mach] = STATE_NORMAL;

		if (transchar[mach] == SYM_EPSILON) {
			if (trans1[mach] != NO_TRANSITION)
				mark_beginning_as_normal(trans1[mach]);

			if (trans2[mach] != NO_TRANSITION)
				mark_beginning_as_normal(trans2[mach]);
		}
		break;

	default:
		flexerror(_
		    ("bad state type in mark_beginning_as_normal()"));
		break;
	}
}


/* mkbranch - make a machine that branches to two machines
 *
 * synopsis
 *
 *   branch = mkbranch( first, second );
 *
 *     branch - a machine which matches either first's pattern or second's
 *     first, second - machines whose patterns are to be or'ed (the | operator)
 *
 * Note that first and second are NEITHER destroyed by the operation.  Also,
 * the resulting machine CANNOT be used with any other "mk" operation except
 * more mkbranch's.  Compare with mkor()
 */

int 
mkbranch(first, second)
	int first, second;
{
	int eps;

	if (first == NO_TRANSITION)
		return second;

	else if (second == NO_TRANSITION)
		return first;

	eps = mkstate(SYM_EPSILON);

	mkxtion(eps, first);
	mkxtion(eps, second);

	return eps;
}


/* mkclos - convert a machine into a closure
 *
 * synopsis
 *   new = mkclos( state );
 *
 * new - a new state which matches the closure of "state"
 */

int 
mkclos(state)
	int state;
{
	return mkopt(mkposcl(state));
}


/* mkopt - make a machine optional
 *
 * synopsis
 *
 *   new = mkopt( mach );
 *
 *     new  - a machine which optionally matches whatever mach matched
 *     mach - the machine to make optional
 *
 * notes:
 *     1. mach must be the last machine created
 *     2. mach is destroyed by the call
 */

int 
mkopt(mach)
	int mach;
{
	int eps;

	if (!SUPER_FREE_EPSILON(finalst[mach])) {
		eps = mkstate(SYM_EPSILON);
		mach = link_machines(mach, eps);
	}
	/*
	 * Can't skimp on the following if FREE_EPSILON(mach) is true because
	 * some state interior to "mach" might point back to the beginning
	 * for a closure.
	 */
	eps = mkstate(SYM_EPSILON);
	mach = link_machines(eps, mach);

	mkxtion(mach, finalst[mach]);

	return mach;
}


/* mkor - make a machine that matches either one of two machines
 *
 * synopsis
 *
 *   new = mkor( first, second );
 *
 *     new - a machine which matches either first's pattern or second's
 *     first, second - machines whose patterns are to be or'ed (the | operator)
 *
 * note that first and second are both destroyed by the operation
 * the code is rather convoluted because an attempt is made to minimize
 * the number of epsilon states needed
 */

int 
mkor(first, second)
	int first, second;
{
	int eps, orend;

	if (first == NIL)
		return second;

	else if (second == NIL)
		return first;

	else {
		/*
		 * See comment in mkopt() about why we can't use the first
		 * state of "first" or "second" if they satisfy
		 * "FREE_EPSILON".
		 */
		eps = mkstate(SYM_EPSILON);

		first = link_machines(eps, first);

		mkxtion(first, second);

		if (SUPER_FREE_EPSILON(finalst[first]) &&
		    accptnum[finalst[first]] == NIL) {
			orend = finalst[first];
			mkxtion(finalst[second], orend);
		} else if (SUPER_FREE_EPSILON(finalst[second]) &&
		    accptnum[finalst[second]] == NIL) {
			orend = finalst[second];
			mkxtion(finalst[first], orend);
		} else {
			eps = mkstate(SYM_EPSILON);

			first = link_machines(first, eps);
			orend = finalst[first];

			mkxtion(finalst[second], orend);
		}
	}

	finalst[first] = orend;
	return first;
}


/* mkposcl - convert a machine into a positive closure
 *
 * synopsis
 *   new = mkposcl( state );
 *
 *    new - a machine matching the positive closure of "state"
 */

int 
mkposcl(state)
	int state;
{
	int eps;

	if (SUPER_FREE_EPSILON(finalst[state])) {
		mkxtion(finalst[state], state);
		return state;
	} else {
		eps = mkstate(SYM_EPSILON);
		mkxtion(eps, state);
		return link_machines(state, eps);
	}
}


/* mkrep - make a replicated machine
 *
 * synopsis
 *   new = mkrep( mach, lb, ub );
 *
 *    new - a machine that matches whatever "mach" matched from "lb"
 *          number of times to "ub" number of times
 *
 * note
 *   if "ub" is INFINITE_REPEAT then "new" matches "lb" or more occurrences of "mach"
 */

int 
mkrep(mach, lb, ub)
	int mach, lb, ub;
{
	int base_mach, tail, copy, i;

	base_mach = copysingl(mach, lb - 1);

	if (ub == INFINITE_REPEAT) {
		copy = dupmachine(mach);
		mach = link_machines(mach,
		    link_machines(base_mach,
			mkclos(copy)));
	} else {
		tail = mkstate(SYM_EPSILON);

		for (i = lb; i < ub; ++i) {
			copy = dupmachine(mach);
			tail = mkopt(link_machines(copy, tail));
		}

		mach =
		    link_machines(mach,
		    link_machines(base_mach, tail));
	}

	return mach;
}


/* mkstate - create a state with a transition on a given symbol
 *
 * synopsis
 *
 *   state = mkstate( sym );
 *
 *     state - a new state matching sym
 *     sym   - the symbol the new state is to have an out-transition on
 *
 * note that this routine makes new states in ascending order through the
 * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE
 * relies on machines being made in ascending order and that they are
 * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge
 * that it admittedly is)
 */

int 
mkstate(sym)
	int sym;
{
	if (++lastnfa >= current_mns) {
		if ((current_mns += MNS_INCREMENT) >= maximum_mns)
			lerrif(_
			    ("input rules are too complicated (>= %d NFA states)"),
			    current_mns);

		++num_reallocs;

		firstst = reallocate_integer_array(firstst, current_mns);
		lastst = reallocate_integer_array(lastst, current_mns);
		finalst = reallocate_integer_array(finalst, current_mns);
		transchar =
		    reallocate_integer_array(transchar, current_mns);
		trans1 = reallocate_integer_array(trans1, current_mns);
		trans2 = reallocate_integer_array(trans2, current_mns);
		accptnum =
		    reallocate_integer_array(accptnum, current_mns);
		assoc_rule =
		    reallocate_integer_array(assoc_rule, current_mns);
		state_type =
		    reallocate_integer_array(state_type, current_mns);
	}
	firstst[lastnfa] = lastnfa;
	finalst[lastnfa] = lastnfa;
	lastst[lastnfa] = lastnfa;
	transchar[lastnfa] = sym;
	trans1[lastnfa] = NO_TRANSITION;
	trans2[lastnfa] = NO_TRANSITION;
	accptnum[lastnfa] = NIL;
	assoc_rule[lastnfa] = num_rules;
	state_type[lastnfa] = current_state_type;

	/*
	 * Fix up equivalence classes base on this transition.  Note that any
	 * character which has its own transition gets its own equivalence
	 * class.  Thus only characters which are only in character classes
	 * have a chance at being in the same equivalence class.  E.g. "a|b"
	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]"
	 * puts them in the same equivalence class (barring other differences
	 * elsewhere in the input).
	 */

	if (sym < 0) {
		/*
		 * We don't have to update the equivalence classes since that
		 * was already done when the ccl was created for the first
		 * time.
		 */
	} else if (sym == SYM_EPSILON)
		++numeps;

	else {
		check_char(sym);

		if (useecs)
			/* Map NUL's to csize. */
			mkechar(sym ? sym : csize, nextecm, ecgroup);
	}

	return lastnfa;
}


/* mkxtion - make a transition from one state to another
 *
 * synopsis
 *
 *   mkxtion( statefrom, stateto );
 *
 *     statefrom - the state from which the transition is to be made
 *     stateto   - the state to which the transition is to be made
 */

void 
mkxtion(statefrom, stateto)
	int statefrom, stateto;
{
	if (trans1[statefrom] == NO_TRANSITION)
		trans1[statefrom] = stateto;

	else if ((transchar[statefrom] != SYM_EPSILON) ||
	    (trans2[statefrom] != NO_TRANSITION))
		flexfatal(_("found too many transitions in mkxtion()"));

	else {			/* second out-transition for an epsilon state */
		++eps2;
		trans2[statefrom] = stateto;
	}
}

/* new_rule - initialize for a new rule */

void 
new_rule()
{
	if (++num_rules >= current_max_rules) {
		++num_reallocs;
		current_max_rules += MAX_RULES_INCREMENT;
		rule_type = reallocate_integer_array(rule_type,
		    current_max_rules);
		rule_linenum = reallocate_integer_array(rule_linenum,
		    current_max_rules);
		rule_useful = reallocate_integer_array(rule_useful,
		    current_max_rules);
		rule_has_nl = reallocate_bool_array(rule_has_nl,
		    current_max_rules);
	}
	if (num_rules > MAX_RULE)
		lerrif(_("too many rules (> %d)!"), MAX_RULE);

	rule_linenum[num_rules] = linenum;
	rule_useful[num_rules] = false;
	rule_has_nl[num_rules] = false;
}
@


1.10
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.9 2003/06/04 17:34:44 millert Exp $	*/
d41 2
a42 2
int dupmachine PROTO ((int));
void mkxtion PROTO ((int, int));
d50 9
a58 7
void    add_accept (mach, accepting_number)
     int     mach, accepting_number;
{
	/* Hang the accepting number off an epsilon state.  if it is associated
	 * with a state that has a non-epsilon out-transition, then the state
	 * will accept BEFORE it makes that transition, i.e., one character
	 * too soon.
d65 1
a65 1
		int     astate = mkstate (SYM_EPSILON);
d68 1
a68 1
		(void) link_machines (mach, astate);
d84 3
a86 2
int     copysingl (singl, num)
     int     singl, num;
d88 1
a88 1
	int     copy, i;
d90 1
a90 1
	copy = mkstate (SYM_EPSILON);
d93 1
a93 1
		copy = link_machines (copy, dupmachine (singl));
d101 3
a103 2
void    dumpnfa (state1)
     int     state1;
d106 1
a106 1
	int     sym, tsp1, tsp2, anum, ns;
d108 4
a111 4
	fprintf (stderr,
		 _
		 ("\n\n********** beginning dump of nfa with start state %d\n"),
		 state1);
d113 2
a114 1
	/* We probably should loop starting at firstst[state1] and going to
d116 2
a117 2
	 * all of the rules together.  So we use our knowledge that the machine
	 * starts at state 1 and ends at lastnfa.
d122 1
a122 1
		fprintf (stderr, _("state # %4d\t"), ns);
d129 1
a129 1
		fprintf (stderr, "%3d:  %4d, %4d", sym, tsp1, tsp2);
d132 1
a132 1
			fprintf (stderr, "  [%d]", anum);
d134 1
a134 1
		fprintf (stderr, "\n");
d137 1
a137 1
	fprintf (stderr, _("********** end of dump\n"));
d158 7
a164 6
int     dupmachine (mach)
     int     mach;
{
	int     i, init, state_offset;
	int     state = 0;
	int     last = lastst[mach];
d167 1
a167 1
		state = mkstate (transchar[i]);
d170 1
a170 1
			mkxtion (finalst[state], trans1[i] + state - i);
d174 2
a175 2
					mkxtion (finalst[state],
						 trans2[i] + state - i);
a176 1

d181 1
a181 1
		flexfatal (_("empty machine in dupmachine()"));
d206 12
a217 10
void    finish_rule (mach, variable_trail_rule, headcnt, trailcnt,
		     pcont_act)
     int     mach, variable_trail_rule, headcnt, trailcnt, pcont_act;
{
	char    action_text[MAXLINE];

	add_accept (mach, num_rules);

	/* We did this in new_rule(), but it often gets the wrong
	 * number because we do it before we start parsing the current rule.
d221 2
a222 1
	/* If this is a continued action, then the line-number has already
d229 2
a230 1
	/* If the previous rule was continued action, then we inherit the
d236 2
a237 2
	snprintf (action_text, sizeof(action_text), "case %d:\n", num_rules);
	add_action (action_text);
d239 3
a241 3
		snprintf (action_text, sizeof(action_text), "/* rule %d can match eol */\n",
			 num_rules);
		add_action (action_text);
a242 2


d247 4
a250 4
			fprintf (stderr,
				 _
				 ("Variable trailing context rule at line %d\n"),
				 rule_linenum[num_rules]);
d253 1
a253 3
	}

	else {
d257 3
a259 2
			/* Do trailing context magic to not match the trailing
			 * characters.
d261 2
a262 2
			char   *scanner_cp = "YY_G(yy_c_buf_p) = yy_cp";
			char   *scanner_bp = "yy_bp";
d265 1
a265 1
				("*yy_cp = YY_G(yy_hold_char); /* undo effects of setting up yytext */\n");
d269 3
a271 3
					snprintf (action_text, sizeof(action_text),
						"YY_LINENO_REWIND_TO(%s + %d);\n", scanner_bp, headcnt);
					add_action (action_text);
d273 4
a276 6
				snprintf (action_text, sizeof(action_text), "%s = %s + %d;\n",
					 scanner_cp, scanner_bp, headcnt);
				add_action (action_text);
			}

			else {
d278 3
a280 3
					snprintf (action_text, sizeof(action_text),
						 "YY_LINENO_REWIND_TO(yy_cp - %d);\n", trailcnt);
					add_action (action_text);
d282 3
a284 4

				snprintf (action_text, sizeof(action_text), "%s -= %d;\n",
					 scanner_cp, trailcnt);
				add_action (action_text);
d288 1
a288 1
				("YY_DO_BEFORE_ACTION; /* set up yytext again */\n");
d292 5
a296 4
	/* Okay, in the action code at this point yytext and yyleng have
	 * their proper final values for this rule, so here's the point
	 * to do any user action.  But don't do it for continued actions,
	 * as that'll result in multiple YY_RULE_SETUP's.
d299 1
a299 1
		add_action ("YY_RULE_SETUP\n");
d301 1
a301 1
	line_directive_out ((FILE *) 0, 1);
d321 3
a323 2
int     link_machines (first, last)
     int     first, last;
d332 1
a332 1
		mkxtion (finalst[first], last);
d334 2
a335 2
		lastst[first] = MAX (lastst[first], lastst[last]);
		firstst[first] = MIN (firstst[first], firstst[last]);
d349 3
a351 2
void    mark_beginning_as_normal (mach)
     int mach;
d363 1
a363 1
				mark_beginning_as_normal (trans1[mach]);
d366 1
a366 1
				mark_beginning_as_normal (trans2[mach]);
d371 2
a372 2
		flexerror (_
			   ("bad state type in mark_beginning_as_normal()"));
d392 3
a394 2
int     mkbranch (first, second)
     int     first, second;
d396 1
a396 1
	int     eps;
d404 1
a404 1
	eps = mkstate (SYM_EPSILON);
d406 2
a407 2
	mkxtion (eps, first);
	mkxtion (eps, second);
d421 3
a423 2
int     mkclos (state)
     int     state;
d425 1
a425 1
	return mkopt (mkposcl (state));
d443 9
a451 8
int     mkopt (mach)
     int     mach;
{
	int     eps;

	if (!SUPER_FREE_EPSILON (finalst[mach])) {
		eps = mkstate (SYM_EPSILON);
		mach = link_machines (mach, eps);
d453 2
a454 2

	/* Can't skimp on the following if FREE_EPSILON(mach) is true because
d458 2
a459 2
	eps = mkstate (SYM_EPSILON);
	mach = link_machines (eps, mach);
d461 1
a461 1
	mkxtion (mach, finalst[mach]);
d481 3
a483 2
int     mkor (first, second)
     int     first, second;
d485 1
a485 1
	int     eps, orend;
d494 4
a497 2
		/* See comment in mkopt() about why we can't use the first
		 * state of "first" or "second" if they satisfy "FREE_EPSILON".
d499 1
a499 1
		eps = mkstate (SYM_EPSILON);
d501 1
a501 1
		first = link_machines (eps, first);
d503 1
a503 1
		mkxtion (first, second);
d505 1
a505 1
		if (SUPER_FREE_EPSILON (finalst[first]) &&
d508 3
a510 5
			mkxtion (finalst[second], orend);
		}

		else if (SUPER_FREE_EPSILON (finalst[second]) &&
			 accptnum[finalst[second]] == NIL) {
d512 3
a514 2
			mkxtion (finalst[first], orend);
		}
d516 1
a516 4
		else {
			eps = mkstate (SYM_EPSILON);

			first = link_machines (first, eps);
d519 1
a519 1
			mkxtion (finalst[second], orend);
d536 3
a538 2
int     mkposcl (state)
     int     state;
d540 1
a540 1
	int     eps;
d542 2
a543 2
	if (SUPER_FREE_EPSILON (finalst[state])) {
		mkxtion (finalst[state], state);
d545 4
a548 6
	}

	else {
		eps = mkstate (SYM_EPSILON);
		mkxtion (eps, state);
		return link_machines (state, eps);
d565 3
a567 2
int     mkrep (mach, lb, ub)
     int     mach, lb, ub;
d569 1
a569 1
	int     base_mach, tail, copy, i;
d571 1
a571 1
	base_mach = copysingl (mach, lb - 1);
d574 6
a579 8
		copy = dupmachine (mach);
		mach = link_machines (mach,
				      link_machines (base_mach,
						     mkclos (copy)));
	}

	else {
		tail = mkstate (SYM_EPSILON);
d582 2
a583 2
			copy = dupmachine (mach);
			tail = mkopt (link_machines (copy, tail));
d587 2
a588 2
			link_machines (mach,
				       link_machines (base_mach, tail));
d611 3
a613 2
int     mkstate (sym)
     int     sym;
d617 3
a619 3
			lerrif (_
				("input rules are too complicated (>= %d NFA states)"),
current_mns);
d623 3
a625 3
		firstst = reallocate_integer_array (firstst, current_mns);
		lastst = reallocate_integer_array (lastst, current_mns);
		finalst = reallocate_integer_array (finalst, current_mns);
d627 3
a629 3
			reallocate_integer_array (transchar, current_mns);
		trans1 = reallocate_integer_array (trans1, current_mns);
		trans2 = reallocate_integer_array (trans2, current_mns);
d631 1
a631 1
			reallocate_integer_array (accptnum, current_mns);
d633 1
a633 1
			reallocate_integer_array (assoc_rule, current_mns);
d635 1
a635 1
			reallocate_integer_array (state_type, current_mns);
a636 1

d647 2
a648 1
	/* Fix up equivalence classes base on this transition.  Note that any
d658 4
a661 3
		/* We don't have to update the equivalence classes since
		 * that was already done when the ccl was created for the
		 * first time.
d663 1
a663 3
	}

	else if (sym == SYM_EPSILON)
d667 1
a667 1
		check_char (sym);
d671 1
a671 1
			mkechar (sym ? sym : csize, nextecm, ecgroup);
d688 3
a690 2
void    mkxtion (statefrom, stateto)
     int     statefrom, stateto;
d696 2
a697 2
		 (trans2[statefrom] != NO_TRANSITION))
		flexfatal (_("found too many transitions in mkxtion()"));
d707 2
a708 1
void    new_rule ()
d713 8
a720 8
		rule_type = reallocate_integer_array (rule_type,
						      current_max_rules);
		rule_linenum = reallocate_integer_array (rule_linenum,
							 current_max_rules);
		rule_useful = reallocate_integer_array (rule_useful,
							current_max_rules);
		rule_has_nl = reallocate_bool_array (rule_has_nl,
						     current_max_rules);
a721 1

d723 1
a723 1
		lerrif (_("too many rules (> %d)!"), MAX_RULE);
@


1.9
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.8 2002/05/31 22:49:29 deraadt Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.8 2002/05/31 22:49:29 deraadt Exp $ */
d41 2
a42 2
int dupmachine PROTO((int));
void mkxtion PROTO((int, int));
d50 3
a52 3
void add_accept( mach, accepting_number )
int mach, accepting_number;
	{
d59 1
a59 1
	if ( transchar[finalst[mach]] == SYM_EPSILON )
d62 3
a64 3
	else
		{
		int astate = mkstate( SYM_EPSILON );
d66 1
a66 2
		(void) link_machines( mach, astate );
		}
d68 1
d82 4
a85 4
int copysingl( singl, num )
int singl, num;
	{
	int copy, i;
d87 1
a87 1
	copy = mkstate( SYM_EPSILON );
d89 2
a90 2
	for ( i = 1; i <= num; ++i )
		copy = link_machines( copy, dupmachine( singl ) );
d93 1
a93 1
	}
d98 2
a99 2
void dumpnfa( state1 )
int state1;
d101 2
a102 2
	{
	int sym, tsp1, tsp2, anum, ns;
d104 4
a107 3
	fprintf( stderr,
	_( "\n\n********** beginning dump of nfa with start state %d\n" ),
		state1 );
d116 2
a117 3
	for ( ns = 1; ns <= lastnfa; ++ns )
		{
		fprintf( stderr, _( "state # %4d\t" ), ns );
d124 1
a124 1
		fprintf( stderr, "%3d:  %4d, %4d", sym, tsp1, tsp2 );
d126 2
a127 2
		if ( anum != NIL )
			fprintf( stderr, "  [%d]", anum );
d129 2
a130 2
		fprintf( stderr, "\n" );
		}
d132 2
a133 2
	fprintf( stderr, _( "********** end of dump\n" ) );
	}
d153 18
a170 20
int dupmachine( mach )
int mach;
	{
	int i, init, state_offset;
	int state = 0;
	int last = lastst[mach];

	for ( i = firstst[mach]; i <= last; ++i )
		{
		state = mkstate( transchar[i] );

		if ( trans1[i] != NO_TRANSITION )
			{
			mkxtion( finalst[state], trans1[i] + state - i );

			if ( transchar[i] == SYM_EPSILON &&
			     trans2[i] != NO_TRANSITION )
				mkxtion( finalst[state],
					trans2[i] + state - i );
			}
d173 1
a173 1
		}
d175 2
a176 2
	if ( state == 0 )
		flexfatal( _( "empty machine in dupmachine()" ) );
d186 1
a186 1
	}
d201 5
a205 4
void finish_rule( mach, variable_trail_rule, headcnt, trailcnt )
int mach, variable_trail_rule, headcnt, trailcnt;
	{
	char action_text[MAXLINE];
d207 1
a207 1
	add_accept( mach, num_rules );
d217 1
a217 1
	if ( continued_action )
a219 2
	snprintf( action_text, sizeof action_text, "case %d:\n", num_rules );
	add_action( action_text );
d221 16
a236 2
	if ( variable_trail_rule )
		{
d239 5
a243 4
		if ( performance_report > 0 )
			fprintf( stderr,
			_( "Variable trailing context rule at line %d\n" ),
				rule_linenum[num_rules] );
d246 1
a246 1
		}
d248 1
a248 2
	else
		{
d251 1
a251 2
		if ( headcnt > 0 || trailcnt > 0 )
			{
d255 2
a256 2
			char *scanner_cp = "yy_c_buf_p = yy_cp";
			char *scanner_bp = "yy_bp";
d258 2
a259 2
			add_action(
	"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n" );
d261 5
a265 6
			if ( headcnt > 0 )
				{
				snprintf( action_text, sizeof action_text,
					"%s = %s + %d;\n",
					scanner_cp, scanner_bp, headcnt );
				add_action( action_text );
d267 4
d272 5
a276 6
			else
				{
				snprintf( action_text, sizeof action_text,
					"%s -= %d;\n",
					scanner_cp, trailcnt );
				add_action( action_text );
d279 3
a281 2
			add_action(
			"YY_DO_BEFORE_ACTION; /* set up yytext again */\n" );
d283 3
d287 1
d294 2
a295 2
	if ( ! continued_action )
		add_action( "YY_RULE_SETUP\n" );
d297 2
a298 2
	line_directive_out( (FILE *) 0, 1 );
	}
d317 4
a320 4
int link_machines( first, last )
int first, last;
	{
	if ( first == NIL )
d323 1
a323 1
	else if ( last == NIL )
d326 2
a327 3
	else
		{
		mkxtion( finalst[first], last );
d329 2
a330 2
		lastst[first] = MAX( lastst[first], lastst[last] );
		firstst[first] = MIN( firstst[first], firstst[last] );
a332 1
		}
d334 1
d344 24
a367 29
void mark_beginning_as_normal( mach )
int mach;
	{
	switch ( state_type[mach] )
		{
		case STATE_NORMAL:
			/* Oh, we've already visited here. */
			return;

		case STATE_TRAILING_CONTEXT:
			state_type[mach] = STATE_NORMAL;

			if ( transchar[mach] == SYM_EPSILON )
				{
				if ( trans1[mach] != NO_TRANSITION )
					mark_beginning_as_normal(
						trans1[mach] );

				if ( trans2[mach] != NO_TRANSITION )
					mark_beginning_as_normal(
						trans2[mach] );
				}
			break;

		default:
			flexerror(
			_( "bad state type in mark_beginning_as_normal()" ) );
			break;
		}
d369 1
d386 4
a389 4
int mkbranch( first, second )
int first, second;
	{
	int eps;
d391 1
a391 1
	if ( first == NO_TRANSITION )
d394 1
a394 1
	else if ( second == NO_TRANSITION )
d397 1
a397 1
	eps = mkstate( SYM_EPSILON );
d399 2
a400 2
	mkxtion( eps, first );
	mkxtion( eps, second );
d403 1
a403 1
	}
d414 5
a418 5
int mkclos( state )
int state;
	{
	return mkopt( mkposcl( state ) );
	}
d435 9
a443 10
int mkopt( mach )
int mach;
	{
	int eps;

	if ( ! SUPER_FREE_EPSILON(finalst[mach]) )
		{
		eps = mkstate( SYM_EPSILON );
		mach = link_machines( mach, eps );
		}
d449 2
a450 2
	eps = mkstate( SYM_EPSILON );
	mach = link_machines( eps, mach );
d452 1
a452 1
	mkxtion( mach, finalst[mach] );
d455 1
a455 1
	}
d472 4
a475 4
int mkor( first, second )
int first, second;
	{
	int eps, orend;
d477 1
a477 1
	if ( first == NIL )
d480 1
a480 1
	else if ( second == NIL )
d483 1
a483 2
	else
		{
d487 1
a487 1
		eps = mkstate( SYM_EPSILON );
d489 1
a489 1
		first = link_machines( eps, first );
d491 1
a491 1
		mkxtion( first, second );
d493 2
a494 3
		if ( SUPER_FREE_EPSILON(finalst[first]) &&
		     accptnum[finalst[first]] == NIL )
			{
d496 2
a497 2
			mkxtion( finalst[second], orend );
			}
d499 2
a500 3
		else if ( SUPER_FREE_EPSILON(finalst[second]) &&
			  accptnum[finalst[second]] == NIL )
			{
d502 2
a503 2
			mkxtion( finalst[first], orend );
			}
d505 2
a506 3
		else
			{
			eps = mkstate( SYM_EPSILON );
d508 1
a508 1
			first = link_machines( first, eps );
d511 1
a511 2
			mkxtion( finalst[second], orend );
			}
d513 1
d517 1
a517 1
	}
d528 7
a534 8
int mkposcl( state )
int state;
	{
	int eps;

	if ( SUPER_FREE_EPSILON(finalst[state]) )
		{
		mkxtion( finalst[state], state );
d536 1
a536 1
		}
d538 4
a541 6
	else
		{
		eps = mkstate( SYM_EPSILON );
		mkxtion( eps, state );
		return link_machines( state, eps );
		}
d543 1
d555 1
a555 1
 *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"
d558 4
a561 4
int mkrep( mach, lb, ub )
int mach, lb, ub;
	{
	int base_mach, tail, copy, i;
d563 1
a563 1
	base_mach = copysingl( mach, lb - 1 );
d565 6
a570 6
	if ( ub == INFINITY )
		{
		copy = dupmachine( mach );
		mach = link_machines( mach,
		link_machines( base_mach, mkclos( copy ) ) );
		}
d572 2
a573 9
	else
		{
		tail = mkstate( SYM_EPSILON );

		for ( i = lb; i < ub; ++i )
			{
			copy = dupmachine( mach );
			tail = mkopt( link_machines( copy, tail ) );
			}
d575 3
a577 1
		mach = link_machines( mach, link_machines( base_mach, tail ) );
d580 5
d586 1
a586 1
	}
d605 8
a612 9
int mkstate( sym )
int sym;
	{
	if ( ++lastnfa >= current_mns )
		{
		if ( (current_mns += MNS_INCREMENT) >= MAXIMUM_MNS )
			lerrif(
		_( "input rules are too complicated (>= %d NFA states)" ),
				current_mns );
d616 9
a624 7
		firstst = reallocate_integer_array( firstst, current_mns );
		lastst = reallocate_integer_array( lastst, current_mns );
		finalst = reallocate_integer_array( finalst, current_mns );
		transchar = reallocate_integer_array( transchar, current_mns );
		trans1 = reallocate_integer_array( trans1, current_mns );
		trans2 = reallocate_integer_array( trans2, current_mns );
		accptnum = reallocate_integer_array( accptnum, current_mns );
d626 1
a626 1
			reallocate_integer_array( assoc_rule, current_mns );
d628 2
a629 2
			reallocate_integer_array( state_type, current_mns );
		}
d650 1
a650 2
	if ( sym < 0 )
		{
d655 1
a655 1
		}
d657 1
a657 1
	else if ( sym == SYM_EPSILON )
d660 2
a661 3
	else
		{
		check_char( sym );
d663 1
a663 1
		if ( useecs )
d665 2
a666 2
			mkechar( sym ? sym : csize, nextecm, ecgroup );
		}
d669 1
a669 1
	}
d682 4
a685 4
void mkxtion( statefrom, stateto )
int statefrom, stateto;
	{
	if ( trans1[statefrom] == NO_TRANSITION )
d688 3
a690 3
	else if ( (transchar[statefrom] != SYM_EPSILON) ||
		  (trans2[statefrom] != NO_TRANSITION) )
		flexfatal( _( "found too many transitions in mkxtion()" ) );
d692 1
a692 2
	else
		{ /* second out-transition for an epsilon state */
a694 1
		}
d696 1
d700 3
a702 4
void new_rule()
	{
	if ( ++num_rules >= current_max_rules )
		{
d705 9
a713 7
		rule_type = reallocate_integer_array( rule_type,
							current_max_rules );
		rule_linenum = reallocate_integer_array( rule_linenum,
							current_max_rules );
		rule_useful = reallocate_integer_array( rule_useful,
							current_max_rules );
		}
d715 2
a716 2
	if ( num_rules > MAX_RULE )
		lerrif( _( "too many rules (> %d)!" ), MAX_RULE );
d720 2
a721 1
	}
@


1.8
log
@recommit strlcpy/snprintf diff after i found my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.6 2002/05/30 10:53:44 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.6 2002/05/30 10:53:44 deraadt Exp $ */
@


1.7
log
@undo until i find my #line bug
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.5 2001/11/19 19:02:14 mpech Exp $ */
d218 1
a218 1
	sprintf( action_text, "case %d:\n", num_rules );
d250 3
a252 2
				sprintf( action_text, "%s = %s + %d;\n",
				scanner_cp, scanner_bp, headcnt );
d258 2
a259 1
				sprintf( action_text, "%s -= %d;\n",
@


1.6
log
@use strlcpy and snprintf
@
text
@d218 1
a218 1
	snprintf( action_text, sizeof action_text, "case %d:\n", num_rules );
d250 2
a251 3
				snprintf( action_text, sizeof action_text,
					"%s = %s + %d;\n",
					scanner_cp, scanner_bp, headcnt );
d257 1
a257 2
				snprintf( action_text, sizeof action_text,
					"%s -= %d;\n",
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $ */
d218 1
a218 1
	sprintf( action_text, "case %d:\n", num_rules );
d250 3
a252 2
				sprintf( action_text, "%s = %s + %d;\n",
				scanner_cp, scanner_bp, headcnt );
d258 2
a259 1
				sprintf( action_text, "%s -= %d;\n",
@


1.4
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.3 1996/07/13 22:22:10 millert Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.3 1996/07/13 22:22:10 millert Exp $ */
d324 1
a324 1
register int mach;
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: nfa.c,v 1.2 1996/06/26 05:35:40 deraadt Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/nfa.c,v 2.17 95/03/04 16:11:42 vern Exp $ */
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/nfa.c,v 1.1.1.1 1995/10/18 08:45:31 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/nfa.c,v 1.8 1995/05/05 05:35:38 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
