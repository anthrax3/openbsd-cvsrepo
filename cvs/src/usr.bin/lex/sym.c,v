head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.6.0.52
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.44
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.48
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.46
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.42
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.40
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.38
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.36
	OPENBSD_5_0:1.6.0.34
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.32
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.30
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.26
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.28
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.24
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.22
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.20
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.18
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.11.19.23.34.56;	author mmcc;	state Exp;
branches;
next	1.8;
commitid	sr9v9L5qZs3TeEb4;

1.8
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.7;
commitid	BIjrMDODd4w0xnpk;

1.7
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.6;
commitid	TCPdLh99ETkn9X6R;

1.6
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.19.19.02.14;	author mpech;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Replace Char (defined as unsigned char) with u_char.

ok tedu@@
@
text
@/*	$OpenBSD: sym.c,v 1.8 2015/11/19 23:20:34 tedu Exp $	*/

/* sym - symbol table routines */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"

/* Variables for symbol tables:
 * sctbl - start-condition symbol table
 * ndtbl - name-definition symbol table
 * ccltab - character class text symbol table
 */

struct hash_entry {
	struct hash_entry *prev, *next;
	char   *name;
	char   *str_val;
	int     int_val;
};

typedef struct hash_entry **hash_table;

#define NAME_TABLE_HASH_SIZE 101
#define START_COND_HASH_SIZE 101
#define CCL_HASH_SIZE 101

static struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
static struct hash_entry *sctbl[START_COND_HASH_SIZE];
static struct hash_entry *ccltab[CCL_HASH_SIZE];


/* declare functions that have forward references */

static int addsym PROTO ((char[], char *, int, hash_table, int));
static struct hash_entry *findsym PROTO ((const char *sym,
					  hash_table table,

					  int table_size));
static int hashfunct PROTO ((const char *, int));


/* addsym - add symbol and definitions to symbol table
 *
 * -1 is returned if the symbol already exists, and the change not made.
 */

static int addsym (sym, str_def, int_def, table, table_size)
     char sym[];
     char   *str_def;
     int     int_def;
     hash_table table;
     int     table_size;
{
	int     hash_val = hashfunct (sym, table_size);
	struct hash_entry *sym_entry = table[hash_val];
	struct hash_entry *new_entry;
	struct hash_entry *successor;

	while (sym_entry) {
		if (!strcmp (sym, sym_entry->name)) {	/* entry already exists */
			return -1;
		}

		sym_entry = sym_entry->next;
	}

	/* create new entry */
	new_entry = (struct hash_entry *)
		malloc (sizeof (struct hash_entry));

	if (new_entry == NULL)
		flexfatal (_("symbol table memory allocation failed"));

	if ((successor = table[hash_val]) != 0) {
		new_entry->next = successor;
		successor->prev = new_entry;
	}
	else
		new_entry->next = NULL;

	new_entry->prev = NULL;
	new_entry->name = sym;
	new_entry->str_val = str_def;
	new_entry->int_val = int_def;

	table[hash_val] = new_entry;

	return 0;
}


/* cclinstal - save the text of a character class */

void    cclinstal (ccltxt, cclnum)
     u_char    ccltxt[];
     int     cclnum;
{
	/* We don't bother checking the return status because we are not
	 * called unless the symbol is new.
	 */

	(void) addsym ((char *) copy_unsigned_string (ccltxt),
		       (char *) 0, cclnum, ccltab, CCL_HASH_SIZE);
}


/* ccllookup - lookup the number associated with character class text
 *
 * Returns 0 if there's no CCL associated with the text.
 */

int     ccllookup (ccltxt)
     u_char    ccltxt[];
{
	return findsym ((char *) ccltxt, ccltab, CCL_HASH_SIZE)->int_val;
}


/* findsym - find symbol in symbol table */

static struct hash_entry *findsym (sym, table, table_size)
     const char *sym;
     hash_table table;
     int     table_size;
{
	static struct hash_entry empty_entry = {
		(struct hash_entry *) 0, (struct hash_entry *) 0,
		(char *) 0, (char *) 0, 0,
	};
	struct hash_entry *sym_entry =

		table[hashfunct (sym, table_size)];

	while (sym_entry) {
		if (!strcmp (sym, sym_entry->name))
			return sym_entry;
		sym_entry = sym_entry->next;
	}

	return &empty_entry;
}

/* hashfunct - compute the hash value for "str" and hash size "hash_size" */

static int hashfunct (str, hash_size)
     const char *str;
     int     hash_size;
{
	int hashval;
	int locstr;

	hashval = 0;
	locstr = 0;

	while (str[locstr]) {
		hashval = (hashval << 1) + (unsigned char) str[locstr++];
		hashval %= hash_size;
	}

	return hashval;
}


/* ndinstal - install a name definition */

void    ndinstal (name, definition)
     const char *name;
     u_char    definition[];
{

	if (addsym (copy_string (name),
		    (char *) copy_unsigned_string (definition), 0,
		    ndtbl, NAME_TABLE_HASH_SIZE))
			synerr (_("name defined twice"));
}


/* ndlookup - lookup a name definition
 *
 * Returns a nil pointer if the name definition does not exist.
 */

u_char   *ndlookup (nd)
     const char *nd;
{
	return (u_char *) findsym (nd, ndtbl, NAME_TABLE_HASH_SIZE)->str_val;
}


/* scextend - increase the maximum number of start conditions */

void    scextend ()
{
	current_max_scs += MAX_SCS_INCREMENT;

	++num_reallocs;

	scset = reallocate_integer_array (scset, current_max_scs);
	scbol = reallocate_integer_array (scbol, current_max_scs);
	scxclu = reallocate_integer_array (scxclu, current_max_scs);
	sceof = reallocate_integer_array (sceof, current_max_scs);
	scname = reallocate_char_ptr_array (scname, current_max_scs);
}


/* scinstal - make a start condition
 *
 * NOTE
 *    The start condition is "exclusive" if xcluflg is true.
 */

void    scinstal (str, xcluflg)
     const char *str;
     int     xcluflg;
{

	if (++lastsc >= current_max_scs)
		scextend ();

	scname[lastsc] = copy_string (str);

	if (addsym (scname[lastsc], (char *) 0, lastsc,
		    sctbl, START_COND_HASH_SIZE))
			format_pinpoint_message (_
						 ("start condition %s declared twice"),
str);

	scset[lastsc] = mkstate (SYM_EPSILON);
	scbol[lastsc] = mkstate (SYM_EPSILON);
	scxclu[lastsc] = xcluflg;
	sceof[lastsc] = false;
}


/* sclookup - lookup the number associated with a start condition
 *
 * Returns 0 if no such start condition.
 */

int     sclookup (str)
     const char *str;
{
	return findsym (str, sctbl, START_COND_HASH_SIZE)->int_val;
}
@


1.8
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.7 2015/11/19 19:43:40 tedu Exp $	*/
d125 1
a125 1
     Char    ccltxt[];
d143 1
a143 1
     Char    ccltxt[];
d198 1
a198 1
     Char    definition[];
d213 1
a213 1
Char   *ndlookup (nd)
d216 1
a216 1
	return (Char *) findsym (nd, ndtbl, NAME_TABLE_HASH_SIZE)->str_val;
@


1.7
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.6 2003/06/04 17:34:44 millert Exp $	*/
d99 1
a99 1
		flex_alloc (sizeof (struct hash_entry));
@


1.6
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.5 2001/11/19 19:02:14 mpech Exp $	*/
d5 5
a9 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d11 24
a34 1
/* $Header: /cvs/src/usr.bin/lex/sym.c,v 1.5 2001/11/19 19:02:14 mpech Exp $ */
d38 5
d44 16
a59 1
/* declare functions that have forward references */
a60 1
int hashfunct PROTO((char[], int));
d62 1
d64 3
a66 3
struct hash_entry *ndtbl[NAME_TABLE_HASH_SIZE];
struct hash_entry *sctbl[START_COND_HASH_SIZE];
struct hash_entry *ccltab[CCL_HASH_SIZE];
d68 2
a69 1
struct hash_entry *findsym();
d77 8
a84 8
int addsym( sym, str_def, int_def, table, table_size )
char sym[];
char *str_def;
int int_def;
hash_table table;
int table_size;
	{
	int hash_val = hashfunct( sym, table_size );
d89 2
a90 4
	while ( sym_entry )
		{
		if ( ! strcmp( sym, sym_entry->name ) )
			{ /* entry already exists */
d92 1
a92 1
			}
d95 1
a95 1
		}
d99 1
a99 1
		flex_alloc( sizeof( struct hash_entry ) );
d101 2
a102 2
	if ( new_entry == NULL )
		flexfatal( _( "symbol table memory allocation failed" ) );
d104 1
a104 2
	if ( (successor = table[hash_val]) != 0 )
		{
d107 1
a107 1
		}
d119 1
a119 1
	}
d124 4
a127 4
void cclinstal( ccltxt, cclnum )
Char ccltxt[];
int cclnum;
	{
a130 1
	Char *copy_unsigned_string();
d132 3
a134 4
	(void) addsym( (char *) copy_unsigned_string( ccltxt ),
			(char *) 0, cclnum,
			ccltab, CCL_HASH_SIZE );
	}
d142 5
a146 5
int ccllookup( ccltxt )
Char ccltxt[];
	{
	return findsym( (char *) ccltxt, ccltab, CCL_HASH_SIZE )->int_val;
	}
d151 6
a156 7
struct hash_entry *findsym( sym, table, table_size )
char sym[];
hash_table table;
int table_size;
	{
	static struct hash_entry empty_entry =
		{
d159 1
a159 1
		} ;
a160 1
		table[hashfunct( sym, table_size )];
d162 4
a165 3
	while ( sym_entry )
		{
		if ( ! strcmp( sym, sym_entry->name ) )
d168 1
a168 1
		}
d171 1
a171 2
	}

d175 4
a178 4
int hashfunct( str, hash_size )
char str[];
int hash_size;
	{
d185 1
a185 2
	while ( str[locstr] )
		{
d188 1
a188 1
		}
d191 1
a191 1
	}
d196 10
a205 12
void ndinstal( name, definition )
char name[];
Char definition[];
	{
	char *copy_string();
	Char *copy_unsigned_string();

	if ( addsym( copy_string( name ),
			(char *) copy_unsigned_string( definition ), 0,
			ndtbl, NAME_TABLE_HASH_SIZE ) )
		synerr( _( "name defined twice" ) );
	}
d213 5
a217 5
Char *ndlookup( nd )
char nd[];
	{
	return (Char *) findsym( nd, ndtbl, NAME_TABLE_HASH_SIZE )->str_val;
	}
d222 2
a223 2
void scextend()
	{
d228 6
a233 6
	scset = reallocate_integer_array( scset, current_max_scs );
	scbol = reallocate_integer_array( scbol, current_max_scs );
	scxclu = reallocate_integer_array( scxclu, current_max_scs );
	sceof = reallocate_integer_array( sceof, current_max_scs );
	scname = reallocate_char_ptr_array( scname, current_max_scs );
	}
d242 15
a256 19
void scinstal( str, xcluflg )
char str[];
int xcluflg;
	{
	char *copy_string();

	/* Generate start condition definition, for use in BEGIN et al. */
	action_define( str, lastsc );

	if ( ++lastsc >= current_max_scs )
		scextend();

	scname[lastsc] = copy_string( str );

	if ( addsym( scname[lastsc], (char *) 0, lastsc,
			sctbl, START_COND_HASH_SIZE ) )
		format_pinpoint_message(
				_( "start condition %s declared twice" ),
					str );
d258 2
a259 2
	scset[lastsc] = mkstate( SYM_EPSILON );
	scbol[lastsc] = mkstate( SYM_EPSILON );
d262 1
a262 1
	}
d270 5
a274 5
int sclookup( str )
char str[];
	{
	return findsym( str, sctbl, START_COND_HASH_SIZE )->int_val;
	}
@


1.5
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $	*/
d17 17
a33 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d36 1
a36 1
/* $Header: /cvs/src/usr.bin/lex/sym.c,v 1.4 2001/06/17 07:30:42 deraadt Exp $ */
@


1.4
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.3 1996/07/13 22:22:13 millert Exp $	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/sym.c,v 1.3 1996/07/13 22:22:13 millert Exp $ */
d38 1
a38 1
int hashfunct PROTO((register char[], int));
d54 1
a54 1
register char sym[];
d61 3
a63 3
	register struct hash_entry *sym_entry = table[hash_val];
	register struct hash_entry *new_entry;
	register struct hash_entry *successor;
d133 1
a133 1
register char sym[];
d142 1
a142 1
	register struct hash_entry *sym_entry =
d159 1
a159 1
register char str[];
d162 2
a163 2
	register int hashval;
	register int locstr;
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: sym.c,v 1.2 1996/06/26 05:35:42 deraadt Exp $	*/
d16 10
a25 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d31 1
a31 1
/* $Header: /home/daffy/u0/vern/flex/RCS/sym.c,v 2.19 95/03/04 16:11:04 vern Exp $ */
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
/* $Header: /cvs/src/usr.bin/lex/sym.c,v 1.1.1.1 1995/10/18 08:45:32 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d31 1
a31 1
/* $Header: /a/cvsroot/src/usr.bin/lex/sym.c,v 1.7 1995/05/05 05:35:42 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
