head	1.12;
access;
symbols
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.9.0.38
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.30
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.34
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.32
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.28
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.26
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.24
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.22
	OPENBSD_5_0:1.9.0.20
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.11.19.23.34.56;	author mmcc;	state Exp;
branches;
next	1.11;
commitid	sr9v9L5qZs3TeEb4;

1.11
date	2015.11.19.23.20.34;	author tedu;	state Exp;
branches;
next	1.10;
commitid	BIjrMDODd4w0xnpk;

1.10
date	2015.11.19.19.43.40;	author tedu;	state Exp;
branches;
next	1.9;
commitid	TCPdLh99ETkn9X6R;

1.9
date	2006.12.06.05.03.29;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.04.17.34.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.31.22.49.29;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.31.00.56.21;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.30.10.53.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.17.07.30.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.13.22.22.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.35.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.32;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Replace Char (defined as unsigned char) with u_char.

ok tedu@@
@
text
@/*	$OpenBSD: scan.l,v 1.11 2015/11/19 23:20:34 tedu Exp $	*/

/* scan.l - scanner for flex input -*-C-*- */

%{
/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"
#include "parse.h"
extern bool tablesverify, tablesext;
extern int trlcontxt; /* Set in  parse.y for each rule. */
extern const char *escaped_qstart, *escaped_qend;

#define ACTION_ECHO add_action( yytext )
#define ACTION_IFDEF(def, should_define) \
	{ \
	if ( should_define ) \
		action_define( def, 1 ); \
	}

#define ACTION_ECHO_QSTART add_action (escaped_qstart)
#define ACTION_ECHO_QEND   add_action (escaped_qend)

#define ACTION_M4_IFDEF(def, should_define) \
    do{ \
        if ( should_define ) \
            buf_m4_define( &m4defs_buf, def, NULL);\
        else \
            buf_m4_undefine( &m4defs_buf, def);\
    } while(0)

#define MARK_END_OF_PROLOG mark_prolog();

#define YY_DECL \
	int flexscan()

#define RETURNCHAR \
	yylval = (unsigned char) yytext[0]; \
	return CHAR;

#define RETURNNAME \
	if(yyleng < MAXLINE) \
         { \
	strlcpy( nmstr, yytext, sizeof nmstr ); \
	 } \
	else \
	 { \
	   synerr(_("Input line too long\n")); \
	   FLEX_EXIT(EXIT_FAILURE);  \
	 }  \
	return NAME;

#define PUT_BACK_STRING(str, start) \
	for ( i = strlen( str ) - 1; i >= start; --i ) \
		unput((str)[i])

#define CHECK_REJECT(str) \
	if ( all_upper( str ) ) \
		reject = true;

#define CHECK_YYMORE(str) \
	if ( all_lower( str ) ) \
		yymore_used = true;

#define YY_USER_INIT \
	if ( getenv("POSIXLY_CORRECT") ) \
		posix_compat = true;

%}

%option caseless nodefault stack noyy_top_state
%option nostdinit

%x SECT2 SECT2PROLOG SECT3 CODEBLOCK PICKUPDEF SC CARETISBOL NUM QUOTE
%x FIRSTCCL CCL ACTION RECOVER COMMENT ACTION_STRING PERCENT_BRACE_ACTION
%x OPTION LINEDIR CODEBLOCK_MATCH_BRACE
%x GROUP_WITH_PARAMS
%x GROUP_MINUS_PARAMS
%x EXTENDED_COMMENT
%x COMMENT_DISCARD

WS		[[:blank:]]+
OPTWS		[[:blank:]]*
NOT_WS		[^[:blank:]\r\n]

NL		\r?\n

NAME		([[:alpha:]_][[:alnum:]_-]*)
NOT_NAME	[^[:alpha:]_*\n]+

SCNAME		{NAME}

ESCSEQ		(\\([^\n]|[0-7]{1,3}|x[[:xdigit:]]{1,2}))

FIRST_CCL_CHAR	([^\\\n]|{ESCSEQ})
CCL_CHAR	([^\\\n\]]|{ESCSEQ})
CCL_EXPR	("[:"^?[[:alpha:]]+":]")

LEXOPT		[aceknopr]

M4QSTART    "[["
M4QEND      "]]"

%%
	static int bracelevel, didadef, indented_code;
	static int doing_rule_action = false;
	static int option_sense;

	int doing_codeblock = false;
	int i, brace_depth=0, brace_start_line=0;
	u_char nmdef[MAXLINE];


<INITIAL>{
	^{WS}		indented_code = true; BEGIN(CODEBLOCK);
	^"/*"		ACTION_ECHO; yy_push_state( COMMENT );
	^#{OPTWS}line{WS}	yy_push_state( LINEDIR );
	^"%s"{NAME}?	return SCDECL;
	^"%x"{NAME}?	return XSCDECL;
	^"%{".*{NL}	{
			++linenum;
			line_directive_out( (FILE *) 0, 1 );
			indented_code = false;
			BEGIN(CODEBLOCK);
			}
    ^"%top"[[:blank:]]*"{"[[:blank:]]*{NL}    {
                brace_start_line = linenum;
                ++linenum;
                buf_linedir( &top_buf, infilename?infilename:"<stdin>", linenum);
                brace_depth = 1;
                yy_push_state(CODEBLOCK_MATCH_BRACE);
            }

    ^"%top".*   synerr( _("malformed '%top' directive") );

	{WS}		/* discard */

	^"%%".*		{
			sectnum = 2;
			bracelevel = 0;
			mark_defs1();
			line_directive_out( (FILE *) 0, 1 );
			BEGIN(SECT2PROLOG);
			return SECTEND;
			}

	^"%pointer".*{NL}	yytext_is_array = false; ++linenum;
	^"%array".*{NL}		yytext_is_array = true; ++linenum;

	^"%option"	BEGIN(OPTION); return OPTION_OP;

	^"%"{LEXOPT}{OPTWS}[[:digit:]]*{OPTWS}{NL}	++linenum; /* ignore */
	^"%"{LEXOPT}{WS}.*{NL}	++linenum;	/* ignore */

	/* xgettext: no-c-format */
	^"%"[^sxaceknopr{}].*	synerr( _( "unrecognized '%' directive" ) );

	^{NAME}		{
			if(yyleng < MAXLINE)
        		 {
			strlcpy( nmstr, yytext, sizeof nmstr );
			 }
			else
			 {
			   synerr( _("Definition name too long\n"));
			   FLEX_EXIT(EXIT_FAILURE);
			 }

			didadef = false;
			BEGIN(PICKUPDEF);
			}

	{SCNAME}	RETURNNAME;
	^{OPTWS}{NL}	++linenum; /* allows blank lines in section 1 */
	{OPTWS}{NL}	ACTION_ECHO; ++linenum; /* maybe end of comment line */
}


<COMMENT>{
	"*/"		ACTION_ECHO; yy_pop_state();
	"*"		ACTION_ECHO;
    {M4QSTART}  ACTION_ECHO_QSTART;
    {M4QEND}    ACTION_ECHO_QEND;
	[^*\n]      ACTION_ECHO;
	{NL}	    ++linenum; ACTION_ECHO;
}

<COMMENT_DISCARD>{
        /* This is the same as COMMENT, but is discarded rather than output. */
	"*/"		yy_pop_state();
    "*"         ;
	[^*\n]      ;
	{NL}	    ++linenum;
}

<EXTENDED_COMMENT>{
    ")"         yy_pop_state();
    [^\n\)]+      ;
    {NL}        ++linenum;        
}

<LINEDIR>{
	\n		yy_pop_state();
	[[:digit:]]+	linenum = myctoi( yytext );

	\"[^"\n]*\"	{
			free( (void *) infilename );
			infilename = copy_string( yytext + 1 );
			infilename[strlen( infilename ) - 1] = '\0';
			}
	.		/* ignore spurious characters */
}

<CODEBLOCK>{
	^"%}".*{NL}	++linenum; BEGIN(INITIAL);

    {M4QSTART}  ACTION_ECHO_QSTART;
    {M4QEND}    ACTION_ECHO_QEND;
	.	        ACTION_ECHO;

	{NL}		{
			++linenum;
			ACTION_ECHO;
			if ( indented_code )
				BEGIN(INITIAL);
			}
}

<CODEBLOCK_MATCH_BRACE>{
    "}"     {
                if( --brace_depth == 0){
                    /* TODO: Matched. */
                    yy_pop_state();
                }else
                    buf_strnappend(&top_buf, yytext, yyleng);
            }

    "{"     {
                brace_depth++;
                buf_strnappend(&top_buf, yytext, yyleng);
            }

    {NL}    {
                ++linenum;
                buf_strnappend(&top_buf, yytext, yyleng);
            }

    {M4QSTART}  buf_strnappend(&top_buf, escaped_qstart, strlen(escaped_qstart));
    {M4QEND}    buf_strnappend(&top_buf, escaped_qend, strlen(escaped_qend));

    [^{}\r\n]  {
                buf_strnappend(&top_buf, yytext, yyleng);
               }

    <<EOF>>     {
                linenum = brace_start_line;
                synerr(_("Unmatched '{'"));
                yyterminate();
                }
}


<PICKUPDEF>{
	{WS}		/* separates name and definition */

	{NOT_WS}[^\r\n]*	{
 		        if(yyleng < MAXLINE)
 		         {
			strlcpy( (char *) nmdef, yytext, sizeof nmdef );
 		         }
 		        else
 		         {
 		           format_synerr( _("Definition value for {%s} too long\n"), nmstr);
 		           FLEX_EXIT(EXIT_FAILURE);
			 }
			/* Skip trailing whitespace. */
			for ( i = strlen( (char *) nmdef ) - 1;
			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');
			      --i )
				;

			nmdef[i + 1] = '\0';

			ndinstal( nmstr, nmdef );
			didadef = true;
			}

	{NL}		{
			if ( ! didadef )
				synerr( _( "incomplete name definition" ) );
			BEGIN(INITIAL);
			++linenum;
			}
}


<OPTION>{
	{NL}		++linenum; BEGIN(INITIAL);
	{WS}		option_sense = true;

	"="		return '=';

	no		option_sense = ! option_sense;

	7bit		csize = option_sense ? 128 : 256;
	8bit		csize = option_sense ? 256 : 128;

	align		long_align = option_sense;
	always-interactive	{
			ACTION_M4_IFDEF( "M4""_YY_ALWAYS_INTERACTIVE", option_sense );
            interactive = option_sense;
			}
	array		yytext_is_array = option_sense;
    ansi-definitions ansi_func_defs = option_sense;
    ansi-prototypes  ansi_func_protos = option_sense;
	backup		backing_up_report = option_sense;
	batch		interactive = ! option_sense;
    bison-bridge     bison_bridge_lval = option_sense;
    bison-locations  { if((bison_bridge_lloc = option_sense))
                            bison_bridge_lval = true;
                     }
	"c++"		C_plus_plus = option_sense;
	caseful|case-sensitive		sf_set_case_ins(!option_sense);
	caseless|case-insensitive	sf_set_case_ins(option_sense);
	debug		ddebug = option_sense;
	default		spprdflt = ! option_sense;
	ecs		useecs = option_sense;
	fast		{
			useecs = usemecs = false;
			use_read = fullspd = true;
			}
	full		{
			useecs = usemecs = false;
			use_read = fulltbl = true;
			}
	input		ACTION_IFDEF("YY_NO_INPUT", ! option_sense);
	interactive	interactive = option_sense;
	lex-compat	lex_compat = option_sense;
	posix-compat	posix_compat = option_sense;
	main		{
			ACTION_M4_IFDEF( "M4""_YY_MAIN", option_sense);
            /* Override yywrap */
            if( option_sense == true )
                do_yywrap = false;
			}
	meta-ecs	usemecs = option_sense;
	never-interactive	{
			ACTION_M4_IFDEF( "M4""_YY_NEVER_INTERACTIVE", option_sense );
            interactive = !option_sense;
			}
	perf-report	performance_report += option_sense ? 1 : -1;
	pointer		yytext_is_array = ! option_sense;
	read		use_read = option_sense;
    reentrant   reentrant = option_sense;
	reject		reject_really_used = option_sense;
	stack		ACTION_M4_IFDEF( "M4""_YY_STACK_USED", option_sense );
	stdinit		do_stdinit = option_sense;
	stdout		use_stdout = option_sense;
    unistd      ACTION_IFDEF("YY_NO_UNISTD_H", ! option_sense);
	unput		ACTION_M4_IFDEF("M4""_YY_NO_UNPUT", ! option_sense);
	verbose		printstats = option_sense;
	warn		nowarn = ! option_sense;
	yylineno	do_yylineno = option_sense; ACTION_M4_IFDEF("M4""_YY_USE_LINENO", option_sense);
	yymore		yymore_really_used = option_sense;
	yywrap      do_yywrap = option_sense;

	yy_push_state	ACTION_M4_IFDEF("M4""_YY_NO_PUSH_STATE", ! option_sense);
	yy_pop_state	ACTION_M4_IFDEF("M4""_YY_NO_POP_STATE", ! option_sense);
	yy_top_state	ACTION_M4_IFDEF("M4""_YY_NO_TOP_STATE", ! option_sense);

	yy_scan_buffer	ACTION_M4_IFDEF("M4""_YY_NO_SCAN_BUFFER", ! option_sense);
	yy_scan_bytes	ACTION_M4_IFDEF("M4""_YY_NO_SCAN_BYTES", ! option_sense);
	yy_scan_string	ACTION_M4_IFDEF("M4""_YY_NO_SCAN_STRING", ! option_sense);

    yyalloc         ACTION_M4_IFDEF("M4""_YY_NO_FLEX_ALLOC", ! option_sense);
    yyrealloc       ACTION_M4_IFDEF("M4""_YY_NO_FLEX_REALLOC", ! option_sense);
    yyfree          ACTION_M4_IFDEF("M4""_YY_NO_FLEX_FREE", ! option_sense);

    yyget_debug     ACTION_M4_IFDEF("M4""_YY_NO_GET_DEBUG", ! option_sense);
    yyset_debug     ACTION_M4_IFDEF("M4""_YY_NO_SET_DEBUG", ! option_sense);
    yyget_extra     ACTION_M4_IFDEF("M4""_YY_NO_GET_EXTRA", ! option_sense);
    yyset_extra     ACTION_M4_IFDEF("M4""_YY_NO_SET_EXTRA", ! option_sense);
    yyget_leng      ACTION_M4_IFDEF("M4""_YY_NO_GET_LENG", ! option_sense);
    yyget_text      ACTION_M4_IFDEF("M4""_YY_NO_GET_TEXT", ! option_sense);
    yyget_lineno    ACTION_M4_IFDEF("M4""_YY_NO_GET_LINENO", ! option_sense);
    yyset_lineno    ACTION_M4_IFDEF("M4""_YY_NO_SET_LINENO", ! option_sense);
    yyget_in        ACTION_M4_IFDEF("M4""_YY_NO_GET_IN", ! option_sense);
    yyset_in        ACTION_M4_IFDEF("M4""_YY_NO_SET_IN", ! option_sense);
    yyget_out       ACTION_M4_IFDEF("M4""_YY_NO_GET_OUT", ! option_sense);
    yyset_out       ACTION_M4_IFDEF("M4""_YY_NO_SET_OUT", ! option_sense);
    yyget_lval      ACTION_M4_IFDEF("M4""_YY_NO_GET_LVAL", ! option_sense);
    yyset_lval      ACTION_M4_IFDEF("M4""_YY_NO_SET_LVAL", ! option_sense);
    yyget_lloc      ACTION_M4_IFDEF("M4""_YY_NO_GET_LLOC", ! option_sense);
    yyset_lloc      ACTION_M4_IFDEF("M4""_YY_NO_SET_LLOC", ! option_sense);

	extra-type	return OPT_EXTRA_TYPE;
	outfile		return OPT_OUTFILE;
	prefix		return OPT_PREFIX;
	yyclass		return OPT_YYCLASS;
	header(-file)?      return OPT_HEADER;
	tables-file         return OPT_TABLES;
	tables-verify   {
                    tablesverify = option_sense;
                    if(!tablesext && option_sense)
                        tablesext = true;
                    }


	\"[^"\n]*\"	{
			if(yyleng-1 < MAXLINE)
        		 {
			strlcpy( nmstr, yytext + 1, sizeof nmstr );
			 }
			else
			 {
			   synerr( _("Option line too long\n"));
			   FLEX_EXIT(EXIT_FAILURE);
			 }
			if (nmstr[strlen( nmstr ) - 1] == '"')
				nmstr[strlen( nmstr ) - 1] = '\0';
			return NAME;
			}

	(([a-mo-z]|n[a-np-z])[[:alpha:]\-+]*)|.	{
			format_synerr( _( "unrecognized %%option: %s" ),
				yytext );
			BEGIN(RECOVER);
			}
}

<RECOVER>.*{NL}		++linenum; BEGIN(INITIAL);


<SECT2PROLOG>{
	^"%{".*	++bracelevel; yyless( 2 );	/* eat only %{ */
	^"%}".*	--bracelevel; yyless( 2 );	/* eat only %} */

	^{WS}.*	ACTION_ECHO;	/* indented code in prolog */

	^{NOT_WS}.*	{	/* non-indented code */
			if ( bracelevel <= 0 )
				{ /* not in %{ ... %} */
				yyless( 0 );	/* put it all back */
				yy_set_bol( 1 );
				mark_prolog();
				BEGIN(SECT2);
				}
			else
				ACTION_ECHO;
			}

	.		ACTION_ECHO;
	{NL}	++linenum; ACTION_ECHO;

	<<EOF>>		{
			mark_prolog();
			sectnum = 0;
			yyterminate(); /* to stop the parser */
			}
}

<SECT2>{
	^{OPTWS}{NL}	++linenum; /* allow blank lines in section 2 */

	^{OPTWS}"%{"	{
			indented_code = false;
			doing_codeblock = true;
			bracelevel = 1;
			BEGIN(PERCENT_BRACE_ACTION);
			}

	^{OPTWS}"<"	    {
                        /* Allow "<" to appear in (?x) patterns. */
                        if (!sf_skip_ws())
                            BEGIN(SC);
                        return '<';
                    }
	^{OPTWS}"^"	return '^';
	\"		BEGIN(QUOTE); return '"';
	"{"/[[:digit:]]	{
			BEGIN(NUM);
			if ( lex_compat || posix_compat )
				return BEGIN_REPEAT_POSIX;
			else
				return BEGIN_REPEAT_FLEX;
			}
	"$"/([[:blank:]]|{NL})	return '$';

	{WS}"%{"		{
			bracelevel = 1;
			BEGIN(PERCENT_BRACE_ACTION);

			if ( in_rule )
				{
				doing_rule_action = true;
				in_rule = false;
				return '\n';
				}
			}
	{WS}"|".*{NL}	{
                        if (sf_skip_ws()){
                            /* We're in the middle of a (?x: ) pattern. */
                            /* Push back everything starting at the "|" */
                            size_t amt;
                            amt = strchr (yytext, '|') - yytext;
                            yyless(amt);
                        }
                        else {
                            continued_action = true;
                            ++linenum;
                            return '\n';
                        }
                    }

	^{WS}"/*"	{

                if (sf_skip_ws()){
                    /* We're in the middle of a (?x: ) pattern. */
                    yy_push_state(COMMENT_DISCARD);
                }
                else{
                    yyless( yyleng - 2 );	/* put back '/', '*' */
                    bracelevel = 0;
                    continued_action = false;
                    BEGIN(ACTION);
                }
			}

	^{WS}		/* allow indented rules */ ;

	{WS}		{
            if (sf_skip_ws()){
                /* We're in the middle of a (?x: ) pattern. */
            }
            else{
                /* This rule is separate from the one below because
                 * otherwise we get variable trailing context, so
                 * we can't build the scanner using -{f,F}.
                 */
                bracelevel = 0;
                continued_action = false;
                BEGIN(ACTION);

                if ( in_rule )
                    {
                    doing_rule_action = true;
                    in_rule = false;
                    return '\n';
                    }
            }
			}

	{OPTWS}{NL}	{
            if (sf_skip_ws()){
                /* We're in the middle of a (?x: ) pattern. */
                ++linenum;
            }
            else{
                bracelevel = 0;
                continued_action = false;
                BEGIN(ACTION);
                unput( '\n' );	/* so <ACTION> sees it */

                if ( in_rule )
                    {
                    doing_rule_action = true;
                    in_rule = false;
                    return '\n';
                    }
            }
			}

	^{OPTWS}"<<EOF>>"	|
	"<<EOF>>"	return EOF_OP;

	^"%%".*		{
			sectnum = 3;
			BEGIN(SECT3);
			outn("/* Begin user sect3 */");
			yyterminate(); /* to stop the parser */
			}

	"["({FIRST_CCL_CHAR}|{CCL_EXPR})({CCL_CHAR}|{CCL_EXPR})*	{
			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strlcpy( nmstr, yytext, sizeof nmstr );
			 }
			else
			 {
			   synerr( _("Input line too long\n"));
			   FLEX_EXIT(EXIT_FAILURE);
			 }

			/* Check to see if we've already encountered this
			 * ccl.
			 */
			if (0 /* <--- This "0" effectively disables the reuse of a
                   * character class (purely based on its source text).
                   * The reason it was disabled is so yacc/bison can parse
                   * ccl operations, such as ccl difference and union.
                   */
                &&  (cclval = ccllookup( (u_char *) nmstr )) != 0 )
				{
				if ( input() != ']' )
					synerr( _( "bad character class" ) );

				yylval = cclval;
				++cclreuse;
				return PREVCCL;
				}
			else
				{
				/* We fudge a bit.  We know that this ccl will
				 * soon be numbered as lastccl + 1 by cclinit.
				 */
				cclinstal( (u_char *) nmstr, lastccl + 1 );

				/* Push back everything but the leading bracket
				 * so the ccl can be rescanned.
				 */
				yyless( 1 );

				BEGIN(FIRSTCCL);
				return '[';
				}
			}
    "{-}"       return CCL_OP_DIFF;
    "{+}"       return CCL_OP_UNION;


    /* Check for :space: at the end of the rule so we don't
     * wrap the expanded regex in '(' ')' -- breaking trailing
     * context.
     */
	"{"{NAME}"}"[[:space:]]?	 {
			u_char *nmdefptr;
            int end_is_ws, end_ch;

            end_ch = yytext[yyleng-1];
            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strlcpy( nmstr, yytext + 1, sizeof nmstr );
 			 }
 			else
 			 {
 			   synerr( _("Input line too long\n"));
 			   FLEX_EXIT(EXIT_FAILURE);
 			 }
nmstr[yyleng - 2 - end_is_ws] = '\0';  /* chop trailing brace */

			if ( (nmdefptr = ndlookup( nmstr )) == 0 )
				format_synerr(
					_( "undefined definition {%s}" ),
						nmstr );

			else
				{ /* push back name surrounded by ()'s */
				int len = strlen( (char *) nmdefptr );
                if (end_is_ws)
                    unput(end_ch);

				if ( lex_compat || nmdefptr[0] == '^' ||
				     (len > 0 && nmdefptr[len - 1] == '$')
                     || (end_is_ws && trlcontxt && !sf_skip_ws()))
					{ /* don't use ()'s after all */
					PUT_BACK_STRING((char *) nmdefptr, 0);

					if ( nmdefptr[0] == '^' )
						BEGIN(CARETISBOL);
					}

				else
					{
					unput(')');
					PUT_BACK_STRING((char *) nmdefptr, 0);
					unput('(');
					}
				}
			}

    "/*"        {
                    if (sf_skip_ws())
                        yy_push_state(COMMENT_DISCARD);
                    else{
                        /* Push back the "*" and return "/" as usual. */
                        yyless(1);
                        return '/';
                    }
                }

    "(?#"       {
                    if (lex_compat || posix_compat){
                        /* Push back the "?#" and treat it like a normal parens. */
                        yyless(1);
                        sf_push(); 
                        return '(';
                    }
                    else
                        yy_push_state(EXTENDED_COMMENT);
                }
    "(?"        {
                    sf_push();
                    if (lex_compat || posix_compat)
                        /* Push back the "?" and treat it like a normal parens. */
                        yyless(1);
                    else
                        BEGIN(GROUP_WITH_PARAMS);
                    return '(';
                }
    "("         sf_push(); return '(';
    ")"         sf_pop(); return ')';

	[/|*+?.(){}]	return (unsigned char) yytext[0];
	.		RETURNCHAR;
}


<SC>{
	{OPTWS}{NL}{OPTWS}	++linenum;	/* Allow blank lines & continuations */
	[,*]		return (unsigned char) yytext[0];
	">"		BEGIN(SECT2); return '>';
	">"/^		BEGIN(CARETISBOL); return '>';
	{SCNAME}	RETURNNAME;
	.		{
			format_synerr( _( "bad <start condition>: %s" ),
				yytext );
			}
}

<CARETISBOL>"^"		BEGIN(SECT2); return '^';


<QUOTE>{
	[^"\n]		RETURNCHAR;
	\"		BEGIN(SECT2); return '"';

	{NL}		{
			synerr( _( "missing quote" ) );
			BEGIN(SECT2);
			++linenum;
			return '"';
			}
}

<GROUP_WITH_PARAMS>{
    ":"     BEGIN(SECT2);
    "-"     BEGIN(GROUP_MINUS_PARAMS);
    i       sf_set_case_ins(1);
    s       sf_set_dot_all(1);
    x       sf_set_skip_ws(1);
}
<GROUP_MINUS_PARAMS>{
    ":"     BEGIN(SECT2);
    i       sf_set_case_ins(0);
    s       sf_set_dot_all(0);
    x       sf_set_skip_ws(0);
}

<FIRSTCCL>{
	"^"/[^-\]\n]	BEGIN(CCL); return '^';
	"^"/("-"|"]")	return '^';
	.		BEGIN(CCL); RETURNCHAR;
}

<CCL>{
	-/[^\]\n]	return '-';
	[^\]\n]		RETURNCHAR;
	"]"		BEGIN(SECT2); return ']';
	.|{NL}		{
			synerr( _( "bad character class" ) );
			BEGIN(SECT2);
			return ']';
			}
}

<FIRSTCCL,CCL>{
	"[:alnum:]"	BEGIN(CCL); return CCE_ALNUM;
	"[:alpha:]"	BEGIN(CCL); return CCE_ALPHA;
	"[:blank:]"	BEGIN(CCL); return CCE_BLANK;
	"[:cntrl:]"	BEGIN(CCL); return CCE_CNTRL;
	"[:digit:]"	BEGIN(CCL); return CCE_DIGIT;
	"[:graph:]"	BEGIN(CCL); return CCE_GRAPH;
	"[:lower:]"	BEGIN(CCL); return CCE_LOWER;
	"[:print:]"	BEGIN(CCL); return CCE_PRINT;
	"[:punct:]"	BEGIN(CCL); return CCE_PUNCT;
	"[:space:]"	BEGIN(CCL); return CCE_SPACE;
	"[:upper:]"	BEGIN(CCL); return CCE_UPPER;
	"[:xdigit:]"	BEGIN(CCL); return CCE_XDIGIT;

	"[:^alnum:]"	BEGIN(CCL); return CCE_NEG_ALNUM;
	"[:^alpha:]"	BEGIN(CCL); return CCE_NEG_ALPHA;
	"[:^blank:]"	BEGIN(CCL); return CCE_NEG_BLANK;
	"[:^cntrl:]"	BEGIN(CCL); return CCE_NEG_CNTRL;
	"[:^digit:]"	BEGIN(CCL); return CCE_NEG_DIGIT;
	"[:^graph:]"	BEGIN(CCL); return CCE_NEG_GRAPH;
	"[:^lower:]"	BEGIN(CCL); return CCE_NEG_LOWER;
	"[:^print:]"	BEGIN(CCL); return CCE_NEG_PRINT;
	"[:^punct:]"	BEGIN(CCL); return CCE_NEG_PUNCT;
	"[:^space:]"	BEGIN(CCL); return CCE_NEG_SPACE;
	"[:^upper:]"	BEGIN(CCL); return CCE_NEG_UPPER;
	"[:^xdigit:]"	BEGIN(CCL); return CCE_NEG_XDIGIT;
	{CCL_EXPR}	{
			format_synerr(
				_( "bad character class expression: %s" ),
					yytext );
			BEGIN(CCL); return CCE_ALNUM;
			}
}

<NUM>{
	[[:digit:]]+	{
			yylval = myctoi( yytext );
			return NUMBER;
			}

	","		return ',';
	"}"		{
			BEGIN(SECT2);
			if ( lex_compat || posix_compat )
				return END_REPEAT_POSIX;
			else
				return END_REPEAT_FLEX;
			}

	.		{
			synerr( _( "bad character inside {}'s" ) );
			BEGIN(SECT2);
			return '}';
			}

	{NL}		{
			synerr( _( "missing }" ) );
			BEGIN(SECT2);
			++linenum;
			return '}';
			}
}


<PERCENT_BRACE_ACTION>{
	{OPTWS}"%}".*		bracelevel = 0;

	<ACTION>"/*"		ACTION_ECHO; yy_push_state( COMMENT );

	<CODEBLOCK,ACTION>{
		"reject"	{
			ACTION_ECHO;
			CHECK_REJECT(yytext);
			}
		"yymore"	{
			ACTION_ECHO;
			CHECK_YYMORE(yytext);
			}
	}

    {M4QSTART}  ACTION_ECHO_QSTART;
    {M4QEND}    ACTION_ECHO_QEND;
    .           ACTION_ECHO;
	{NL}		{
			++linenum;
			ACTION_ECHO;
			if ( bracelevel == 0 ||
			     (doing_codeblock && indented_code) )
				{
				if ( doing_rule_action )
					add_action( "\tYY_BREAK\n" );

				doing_rule_action = doing_codeblock = false;
				BEGIN(SECT2);
				}
			}
}


	/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */
<ACTION>{
	"{"		ACTION_ECHO; ++bracelevel;
	"}"		ACTION_ECHO; --bracelevel;
    {M4QSTART}  ACTION_ECHO_QSTART;
    {M4QEND}    ACTION_ECHO_QEND;
	[^[:alpha:]_{}"'/\n\[\]]+	ACTION_ECHO;
    [\[\]]      ACTION_ECHO;
	{NAME}		ACTION_ECHO;
	"'"([^'\\\n]|\\.)*"'"	ACTION_ECHO; /* character constant */
	\"		ACTION_ECHO; BEGIN(ACTION_STRING);
	{NL}		{
			++linenum;
			ACTION_ECHO;
			if ( bracelevel == 0 )
				{
				if ( doing_rule_action )
					add_action( "\tYY_BREAK\n" );

				doing_rule_action = false;
				BEGIN(SECT2);
				}
			}
	.		ACTION_ECHO;
}

<ACTION_STRING>{
	[^"\\\n]+	ACTION_ECHO;
	\\.		ACTION_ECHO;
	{NL}		++linenum; ACTION_ECHO; BEGIN(ACTION);
	\"		ACTION_ECHO; BEGIN(ACTION);
	.		ACTION_ECHO;
}

<COMMENT,COMMENT_DISCARD,ACTION,ACTION_STRING><<EOF>>	{
			synerr( _( "EOF encountered inside an action" ) );
			yyterminate();
			}

<EXTENDED_COMMENT,GROUP_WITH_PARAMS,GROUP_MINUS_PARAMS><<EOF>>	{
			synerr( _( "EOF encountered inside pattern" ) );
			yyterminate();
			}

<SECT2,QUOTE,FIRSTCCL,CCL>{ESCSEQ}	{
			yylval = myesc( (u_char *) yytext );

			if ( YY_START == FIRSTCCL )
				BEGIN(CCL);

			return CHAR;
			}


<SECT3>{
    {M4QSTART}  fwrite (escaped_qstart, 1, strlen(escaped_qstart), yyout);
    {M4QEND}    fwrite (escaped_qend, 1, strlen(escaped_qend), yyout);
	[^\[\]\n]*(\n?) ECHO;
	(.|\n)      ECHO;
	<<EOF>>		sectnum = 0; yyterminate();
}

<*>.|\n			format_synerr( _( "bad character: %s" ), yytext );

%%


int yywrap()
	{
	if ( --num_input_files > 0 )
		{
		set_input_file( *++input_files );
		return 0;
		}

	else
		return 1;
	}


/* set_input_file - open the given file (if NULL, stdin) for scanning */

void set_input_file( file )
char *file;
	{
	if ( file && strcmp( file, "-" ) )
		{
		infilename = copy_string( file );
		yyin = fopen( infilename, "r" );

		if ( yyin == NULL )
			lerrsf( _( "can't open %s" ), file );
		}

	else
		{
		yyin = stdin;
		infilename = copy_string( "<stdin>" );
		}

	linenum = 1;
	}

@


1.11
log
@flex_alloc and flex_free are nothing more than malloc and free, so replace
them with the real functions so as to not trick people into thinking they
are special
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.10 2015/11/19 19:43:40 tedu Exp $	*/
d140 1
a140 1
	Char nmdef[MAXLINE];
d633 1
a633 1
                &&  (cclval = ccllookup( (Char *) nmstr )) != 0 )
d647 1
a647 1
				cclinstal( (Char *) nmstr, lastccl + 1 );
d667 1
a667 1
			Char *nmdefptr;
d953 1
a953 1
			yylval = myesc( (Char *) yytext );
@


1.10
log
@Update flex from ancient 2.5.4 to the recent 2.5.39.
This work was all done by Serguey Parkhomovsky. Thanks.
Some changes from upstream:
* Removed autotools cruft/localization/texinfo manual/etc
* Kept the old manpage, as the new manpage is content-free
* Used safe string handling functions and fixed several compiler warnings
* pledge(2). Flex 2.5.39 now forks/execs its filter chains and needs proc
  exec in addition to what was previously pledged
* Removed register keyword from all variable declarations
* renamed parse.c, parse.h, scan.c, skel.c with init prefix so compiling
  flex outside of obj by accident wouldn't clobber the bootstrap files
* Minor fixes (spelling, accessing buf[strlen(buf) - 1] for zero-length
  strings in initscan.c/scan.l, etc) that were already in our tree

This is a huge change, so it's going in the tree code bomb style.
I'm not excited about the growth in complexity (like now running m4
to _post_ process lexers) but hopefully this will be a one time update
and we will now take "ownership" of the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.9 2006/12/06 05:03:29 ray Exp $	*/
d236 1
a236 1
			flex_free( (void *) infilename );
a1010 22

/* Wrapper routines for accessing the scanner's malloc routines. */

void *flex_alloc( size )
size_t size;
	{
	return (void *) malloc( size );
	}

void *flex_realloc( ptr, size )
void *ptr;
size_t size;
	{
	return (void *) realloc( ptr, size );
	}

void flex_free( ptr )
void *ptr;
	{
	if ( ptr )
		free( ptr );
	}
@


1.9
log
@Don't access buf[strlen(buf) - 1] for zero-length strings.

OK jaredy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.8 2003/06/04 17:34:44 millert Exp $	*/
d3 1
a3 1
/* scan.l - scanner for flex input */
d6 2
a7 30
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 * 
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE.
 */
d9 27
a35 1
/* $Header: /home/ray/openbsd/src/usr.bin/lex/scan.l,v 1.8 2003/06/04 17:34:44 millert Exp $ */
d39 3
d50 11
d71 9
a79 1
	strlcpy( nmstr, yytext, sizeof nmstr); \
d93 5
d100 1
a100 1
%option caseless nodefault outfile="scan.c" stack noyy_top_state
d105 5
a109 1
%x OPTION LINEDIR
d113 1
a113 1
NOT_WS		[^[:blank:]\n]
d126 1
a126 1
CCL_EXPR	("[:"[[:alpha:]]+":]")
d130 3
d139 2
a140 2
	int i;
	Char nmdef[MAXLINE], myesc();
d155 9
d184 1
d188 2
d191 7
d211 18
a228 2
	[^*\n]+		ACTION_ECHO;
	[^*\n]*{NL}	++linenum; ACTION_ECHO;
d246 3
a248 1
	{NAME}|{NOT_NAME}|.	ACTION_ECHO;
d258 33
d295 10
a304 3
	{NOT_WS}.*	{
			strlcpy( (char *) nmdef, yytext, sizeof nmdef);

d339 2
a340 1
			action_define( "YY_ALWAYS_INTERACTIVE", option_sense );
d343 2
d347 4
d352 2
a353 2
	caseful|case-sensitive		caseins = ! option_sense;
	caseless|case-insensitive	caseins = option_sense;
d368 1
d370 4
a373 2
			action_define( "YY_MAIN", option_sense );
			do_yywrap = ! option_sense;
d377 2
a378 1
			action_define( "YY_NEVER_INTERACTIVE", option_sense );
d383 1
d385 1
a385 1
	stack		action_define( "YY_STACK_USED", option_sense );
d388 2
a389 1
	unput		ACTION_IFDEF("YY_NO_UNPUT", ! option_sense);
d392 1
a392 1
	yylineno	do_yylineno = option_sense;
d394 1
a394 1
	yywrap		do_yywrap = option_sense;
d396 28
a423 7
	yy_push_state	ACTION_IFDEF("YY_NO_PUSH_STATE", ! option_sense);
	yy_pop_state	ACTION_IFDEF("YY_NO_POP_STATE", ! option_sense);
	yy_top_state	ACTION_IFDEF("YY_NO_TOP_STATE", ! option_sense);

	yy_scan_buffer	ACTION_IFDEF("YY_NO_SCAN_BUFFER", ! option_sense);
	yy_scan_bytes	ACTION_IFDEF("YY_NO_SCAN_BYTES", ! option_sense);
	yy_scan_string	ACTION_IFDEF("YY_NO_SCAN_STRING", ! option_sense);
d425 1
d429 8
d439 11
a449 3
			strlcpy( nmstr, yytext + 1, sizeof nmstr);
			if (nmstr[strlen(nmstr) - 1] == '"')
				nmstr[strlen(nmstr) - 1] = '\0';
d481 1
a481 1
	.*		ACTION_ECHO;
d501 6
a506 1
	^{OPTWS}"<"	BEGIN(SC); return '<';
d509 7
a515 1
	"{"/[[:digit:]]	BEGIN(NUM); return '{';
d529 14
a542 1
	{WS}"|".*{NL}	continued_action = true; ++linenum; return '\n';
d545 11
a555 4
			yyless( yyleng - 2 );	/* put back '/', '*' */
			bracelevel = 0;
			continued_action = false;
			BEGIN(ACTION);
d558 1
a558 1
	^{WS}		/* allow indented rules */
d561 19
a579 14
			/* This rule is separate from the one below because
			 * otherwise we get variable trailing context, so
			 * we can't build the scanner using -{f,F}.
			 */
			bracelevel = 0;
			continued_action = false;
			BEGIN(ACTION);

			if ( in_rule )
				{
				doing_rule_action = true;
				in_rule = false;
				return '\n';
				}
d583 17
a599 11
			bracelevel = 0;
			continued_action = false;
			BEGIN(ACTION);
			unput( '\n' );	/* so <ACTION> sees it */

			if ( in_rule )
				{
				doing_rule_action = true;
				in_rule = false;
				return '\n';
				}
d608 1
d615 9
a623 1
			strlcpy( nmstr, yytext, sizeof nmstr);
d628 6
a633 1
			if ( (cclval = ccllookup( (Char *) nmstr )) != 0 )
d658 3
d662 7
a668 3
	"{"{NAME}"}"	{
			register Char *nmdefptr;
			Char *ndlookup();
d670 5
d676 7
a682 1
			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */
d692 2
d696 2
a697 1
				     (len > 0 && nmdefptr[len - 1] == '$') )
d714 32
d752 1
d778 13
d822 13
d850 7
a856 1
	"}"		BEGIN(SECT2); return '}';
d889 3
a891 1
	{NAME}|{NOT_NAME}|.	ACTION_ECHO;
d912 4
a915 1
	[^[:alpha:]_{}"'/\n]+	ACTION_ECHO;
d937 1
a937 1
	{NL}		++linenum; ACTION_ECHO;
d942 1
a942 1
<COMMENT,ACTION,ACTION_STRING><<EOF>>	{
d947 4
d963 4
a966 1
	.*(\n?)		ECHO;
@


1.8
log
@Update flex license from sourceforge version (is now 2-term BSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.7 2002/05/31 22:49:29 deraadt Exp $	*/
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/scan.l,v 1.7 2002/05/31 22:49:29 deraadt Exp $ */
d288 2
a289 1
			nmstr[strlen( nmstr ) - 1] = '\0';
@


1.7
log
@recommit strlcpy/snprintf diff after i found my bug
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.5 2002/05/30 10:53:45 deraadt Exp $	*/
d18 17
a34 12
 * modification, are permitted provided that: (1) source distributions
 * retain this entire copyright notice and comment, and (2) distributions
 * including binaries display the following acknowledgement:  ``This product
 * includes software developed by the University of California, Berkeley
 * and its contributors'' in the documentation or other materials provided
 * with the distribution and in all advertising materials mentioning
 * features or use of this software. Neither the name of the University nor
 * the names of its contributors may be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
d37 1
a37 1
/* $Header: /cvs/src/usr.bin/lex/scan.l,v 1.5 2002/05/30 10:53:45 deraadt Exp $ */
@


1.6
log
@undo until i find my #line bug
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.4 2001/06/17 07:30:42 deraadt Exp $	*/
d32 1
a32 1
/* $Header: /cvs/src/usr.bin/lex/scan.l,v 1.4 2001/06/17 07:30:42 deraadt Exp $ */
d54 1
a54 1
	strcpy( nmstr, yytext ); \
d141 1
a141 1
			strcpy( nmstr, yytext );
d189 1
a189 1
			strcpy( (char *) nmdef, yytext );
d282 1
a282 1
			strcpy( nmstr, yytext + 1 );
d406 1
a406 1
			strcpy( nmstr, yytext );
d441 1
a441 1
			strcpy( nmstr, yytext + 1 );
@


1.5
log
@use strlcpy and snprintf
@
text
@d54 1
a54 1
	strlcpy( nmstr, yytext, sizeof nmstr); \
d141 1
a141 1
			strlcpy( nmstr, yytext, sizeof nmstr );
d189 1
a189 1
			strlcpy( (char *) nmdef, yytext, sizeof nmdef);
d282 2
a283 1
			strlcpy( nmstr, yytext + 1, sizeof nmstr);
d406 1
a406 1
			strlcpy( nmstr, yytext, sizeof nmstr);
d441 1
a441 1
			strlcpy( nmstr, yytext + 1, sizeof nmstr );
@


1.4
log
@Vern says:
Yes, this came up a while ago, and I put together a flex release with
a modified copyright that begins:
     Redistribution and use in source and binary forms, with or
     without modification, are permitted provided that:
[...] feel free to update the copyrights in each of the files with the
one in COPYING.
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.3 1996/07/13 22:22:13 millert Exp $	*/
d32 1
a32 1
/* $Header: /cvs/src/usr.bin/lex/scan.l,v 1.3 1996/07/13 22:22:13 millert Exp $ */
d54 1
a54 1
	strcpy( nmstr, yytext ); \
d141 1
a141 1
			strcpy( nmstr, yytext );
d189 1
a189 1
			strcpy( (char *) nmdef, yytext );
d282 1
a282 2
			strcpy( nmstr, yytext + 1 );
			nmstr[strlen( nmstr ) - 1] = '\0';
d405 1
a405 1
			strcpy( nmstr, yytext );
d440 1
a440 1
			strcpy( nmstr, yytext + 1 );
@


1.3
log
@updated to flex 2.5.3
@
text
@d1 1
a1 1
/*	$OpenBSD: scan.l,v 1.2 1996/06/26 05:35:42 deraadt Exp $	*/
d17 10
a26 10
 * Redistribution and use in source and binary forms are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
d32 1
a32 1
/* $Header: /home/daffy/u0/vern/flex/RCS/scan.l,v 2.56 95/04/24 12:17:19 vern Exp $ */
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 1
a32 1
/* $Header: /cvs/src/usr.bin/lex/scan.l,v 1.1.1.1 1995/10/18 08:45:32 deraadt Exp $ */
@


1.1
log
@Initial revision
@
text
@d1 2
d32 1
a32 1
/* $Header: /a/cvsroot/src/usr.bin/lex/scan.l,v 1.8 1995/05/05 05:35:41 jtc Exp $ */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
