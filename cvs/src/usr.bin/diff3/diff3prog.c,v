head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.2
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.6
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.19
date	2016.10.18.21.06.52;	author millert;	state Exp;
branches;
next	1.18;
commitid	foVrnyJsePU0nPEu;

1.18
date	2016.10.16.13.03.40;	author millert;	state Exp;
branches;
next	1.17;
commitid	Yi19rRHCwGVoImk1;

1.17
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	sbrB3Q5CNxcwZpfU;

1.16
date	2015.10.05.13.30.30;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	rSXobTeKTvip1j7I;

1.15
date	2015.09.05.09.47.08;	author jsg;	state Exp;
branches;
next	1.14;
commitid	AWjHn4VUyqwdq4dE;

1.14
date	2014.12.01.06.36.32;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	EsybWdysQwwTyqWb;

1.13
date	2013.11.15.22.20.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.27.18.10.05;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.22.16.00.49;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.01.08.17.57;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.30.04.44.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.07.18.16.42;	author canacar;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.09.20.13.57;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.24.20.32.06;	author avsm;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.14.17.43.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.10.16.06.07;	author millert;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Using bitwise OR along with two assignments in the conditional of
a while() loop is a trap for the unwary programmer (albeit a clever
trap).  Break this up into two separate assignments and using boolean
OR for clarity.  OK otto@@
@
text
@/*	$OpenBSD: diff3prog.c,v 1.18 2016/10/16 13:03:40 millert Exp $	*/

/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diff3.c	8.1 (Berkeley) 6/6/93
 */

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* diff3 - 3-way differential file comparison */

/* diff3 [-ex3EX] d13 d23 f1 f2 f3 [m1 m3]
 *
 * d13 = diff report on f1 vs f3
 * d23 = diff report on f2 vs f3
 * f1, f2, f3 the 3 files
 * if changes in f1 overlap with changes in f3, m1 and m3 are used
 * to mark the overlaps; otherwise, the file names f1 and f3 are used
 * (only for options E and X).
 */

/*
 * "from" is first in range of changed lines; "to" is last+1
 * from=to=line after point of insertion for added lines.
 */
struct  range {
	int from;
	int to;
};
struct diff {
	struct range old;
	struct range new;
};

size_t szchanges;

struct diff *d13;
struct diff *d23;
/*
 * "de" is used to gather editing scripts.  These are later spewed out in
 * reverse order.  Its first element must be all zero, the "new" component
 * of "de" contains line positions or byte positions depending on when you
 * look (!?).  Array overlap indicates which sections in "de" correspond to
 * lines that are different in all three files.
 */
struct diff *de;
char *overlap;
int  overlapcnt;
FILE *fp[3];
int cline[3];		/* # of the last-read line in each file (0-2) */
/*
 * the latest known correspondence between line numbers of the 3 files
 * is stored in last[1-3];
 */
int last[4];
int eflag;
int oflag;		/* indicates whether to mark overlaps (-E or -X)*/
int debug  = 0;
char f1mark[40], f3mark[40];	/* markers for -E and -X */

int duplicate(struct range *, struct range *);
int edit(struct diff *, int, int);
char *getchange(FILE *);
char *get_line(FILE *, size_t *);
int number(char **);
int readin(char *, struct diff **);
int skip(int, int, char *);
void change(int, struct range *, int);
void keep(int, struct range *);
void merge(int, int);
void prange(struct range *);
void repos(int);
void separate(const char *);
__dead void edscript(int);
__dead void trouble(void);
void increase(void);
__dead void usage(void);

int
main(int argc, char **argv)
{
	int ch, i, m, n;

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	eflag = 0;
	oflag = 0;
	while ((ch = getopt(argc, argv, "EeXx3")) != -1) {
		switch (ch) {
		case 'E':
			eflag = 3;
			oflag = 1;
			break;
		case 'e':
			eflag = 3;
			break;
		case 'X':
			oflag = eflag = 1;
			break;
		case 'x':
			eflag = 1;
			break;
		case '3':
			eflag = 2;
			break;
		}
	}
	argc -= optind;
	argv += optind;
	/* XXX - argc usage seems wrong here */
	if (argc < 5)
		usage();

	if (oflag) {
		(void)snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s",
		    argc >= 6 ? argv[5] : argv[2]);
		(void)snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s",
		    argc >= 7 ? argv[6] : argv[4]);
	}

	increase();
	m = readin(argv[0], &d13);
	n = readin(argv[1], &d23);
	for (i = 0; i <= 2; i++) {
		if ((fp[i] = fopen(argv[i + 2], "r")) == NULL)
			err(EXIT_FAILURE, "can't open %s", argv[i + 2]);
	}
	merge(m, n);
	exit(EXIT_SUCCESS);
}

/*
 * Pick up the line numbers of all changes from one change file.
 * (This puts the numbers in a vector, which is not strictly necessary,
 * since the vector is processed in one sequential pass.
 * The vector could be optimized out of existence)
 */
int
readin(char *name, struct diff **dd)
{
	int a, b, c, d, i;
	char kind, *p;

	fp[0] = fopen(name, "r");
	if (fp[0] == NULL)
		err(EXIT_FAILURE, "can't open %s", name);
	for (i=0; (p = getchange(fp[0])); i++) {
		if (i >= szchanges - 1)
			increase();
		a = b = number(&p);
		if (*p == ',') {
			p++;
			b = number(&p);
		}
		kind = *p++;
		c = d = number(&p);
		if (*p==',') {
			p++;
			d = number(&p);
		}
		if (kind == 'a')
			a++;
		if (kind == 'd')
			c++;
		b++;
		d++;
		(*dd)[i].old.from = a;
		(*dd)[i].old.to = b;
		(*dd)[i].new.from = c;
		(*dd)[i].new.to = d;
	}
	if (i) {
		(*dd)[i].old.from = (*dd)[i-1].old.to;
		(*dd)[i].new.from = (*dd)[i-1].new.to;
	}
	(void)fclose(fp[0]);
	return (i);
}

int
number(char **lc)
{
	int nn;
	nn = 0;
	while (isdigit((unsigned char)(**lc)))
		nn = nn*10 + *(*lc)++ - '0';
	return (nn);
}

char *
getchange(FILE *b)
{
	char *line;

	while ((line = get_line(b, NULL))) {
		if (isdigit((unsigned char)line[0]))
			return (line);
	}
	return (NULL);
}

char *
get_line(FILE *b, size_t *n)
{
	char *cp;
	size_t len;
	static char *buf;
	static size_t bufsize;

	if ((cp = fgetln(b, &len)) == NULL)
		return (NULL);

	if (cp[len - 1] != '\n')
		len++;
	if (len + 1 > bufsize) {
		do {
			bufsize += 1024;
		} while (len + 1 > bufsize);
		if ((buf = realloc(buf, bufsize)) == NULL)
			err(EXIT_FAILURE, NULL);
	}
	memcpy(buf, cp, len - 1);
	buf[len - 1] = '\n';
	buf[len] = '\0';
	if (n != NULL)
		*n = len;
	return (buf);
}

void
merge(int m1, int m2)
{
	struct diff *d1, *d2, *d3;
	int dup, j, t1, t2;

	d1 = d13;
	d2 = d23;
	j = 0;
	for (;;) {
		t1 = (d1 < d13 + m1);
		t2 = (d2 < d23 + m2);
		if (!t1 && !t2)
			break;

		if (debug) {
			printf("%d,%d=%d,%d %d,%d=%d,%d\n",
			d1->old.from,d1->old.to,
			d1->new.from,d1->new.to,
			d2->old.from,d2->old.to,
			d2->new.from,d2->new.to);
		}
		/* first file is different from others */
		if (!t2 || (t1 && d1->new.to < d2->new.from)) {
			/* stuff peculiar to 1st file */
			if (eflag==0) {
				separate("1");
				change(1, &d1->old, 0);
				keep(2, &d1->new);
				change(3, &d1->new, 0);
			}
			d1++;
			continue;
		}
		/* second file is different from others */
		if (!t1 || (t2 && d2->new.to < d1->new.from)) {
			if (eflag==0) {
				separate("2");
				keep(1, &d2->new);
				change(2, &d2->old, 0);
				change(3, &d2->new, 0);
			}
			d2++;
			continue;
		}
		/*
		 * Merge overlapping changes in first file
		 * this happens after extension (see below).
		 */
		if (d1 + 1 < d13 + m1 && d1->new.to >= d1[1].new.from) {
			d1[1].old.from = d1->old.from;
			d1[1].new.from = d1->new.from;
			d1++;
			continue;
		}

		/* merge overlapping changes in second */
		if (d2 + 1 < d23 + m2 && d2->new.to >= d2[1].new.from) {
			d2[1].old.from = d2->old.from;
			d2[1].new.from = d2->new.from;
			d2++;
			continue;
		}
		/* stuff peculiar to third file or different in all */
		if (d1->new.from == d2->new.from && d1->new.to == d2->new.to) {
			dup = duplicate(&d1->old,&d2->old);
			/*
			 * dup = 0 means all files differ
			 * dup = 1 means files 1 and 2 identical
			 */
			if (eflag==0) {
				separate(dup ? "3" : "");
				change(1, &d1->old, dup);
				change(2, &d2->old, 0);
				d3 = d1->old.to > d1->old.from ? d1 : d2;
				change(3, &d3->new, 0);
			} else
				j = edit(d1, dup, j);
			d1++;
			d2++;
			continue;
		}
		/*
		 * Overlapping changes from file 1 and 2; extend changes
		 * appropriately to make them coincide.
		 */
		if (d1->new.from < d2->new.from) {
			d2->old.from -= d2->new.from-d1->new.from;
			d2->new.from = d1->new.from;
		} else if (d2->new.from < d1->new.from) {
			d1->old.from -= d1->new.from-d2->new.from;
			d1->new.from = d2->new.from;
		}
		if (d1->new.to > d2->new.to) {
			d2->old.to += d1->new.to - d2->new.to;
			d2->new.to = d1->new.to;
		} else if (d2->new.to > d1->new.to) {
			d1->old.to += d2->new.to - d1->new.to;
			d1->new.to = d2->new.to;
		}
	}
	if (eflag)
		edscript(j);
}

void
separate(const char *s)
{
	printf("====%s\n", s);
}

/*
 * The range of lines rold.from thru rold.to in file i is to be changed.
 * It is to be printed only if it does not duplicate something to be
 * printed later.
 */
void
change(int i, struct range *rold, int dup)
{
	printf("%d:", i);
	last[i] = rold->to;
	prange(rold);
	if (dup || debug)
		return;
	i--;
	(void)skip(i, rold->from, NULL);
	(void)skip(i, rold->to, "  ");
}

/*
 * print the range of line numbers, rold.from thru rold.to, as n1,n2 or n1
 */
void
prange(struct range *rold)
{
	if (rold->to <= rold->from)
		printf("%da\n", rold->from - 1);
	else {
		printf("%d", rold->from);
		if (rold->to > rold->from+1)
			printf(",%d", rold->to - 1);
		printf("c\n");
	}
}

/*
 * No difference was reported by diff between file 1 (or 2) and file 3,
 * and an artificial dummy difference (trange) must be ginned up to
 * correspond to the change reported in the other file.
 */
void
keep(int i, struct range *rnew)
{
	int delta;
	struct range trange;

	delta = last[3] - last[i];
	trange.from = rnew->from - delta;
	trange.to = rnew->to - delta;
	change(i, &trange, 1);
}

/*
 * skip to just before line number from in file "i".  If "pr" is non-NULL,
 * print all skipped stuff with string pr as a prefix.
 */
int
skip(int i, int from, char *pr)
{
	size_t j, n;
	char *line;

	for (n = 0; cline[i] < from - 1; n += j) {
		if ((line = get_line(fp[i], &j)) == NULL)
			trouble();
		if (pr != NULL)
			printf("%s%s", pr, line);
		cline[i]++;
	}
	return ((int) n);
}

/*
 * Return 1 or 0 according as the old range (in file 1) contains exactly
 * the same data as the new range (in file 2).
 */
int
duplicate(struct range *r1, struct range *r2)
{
	int c,d;
	int nchar;
	int nline;

	if (r1->to-r1->from != r2->to-r2->from)
		return (0);
	(void)skip(0, r1->from, NULL);
	(void)skip(1, r2->from, NULL);
	nchar = 0;
	for (nline=0; nline < r1->to - r1->from; nline++) {
		do {
			c = getc(fp[0]);
			d = getc(fp[1]);
			if (c == -1 || d== -1)
				trouble();
			nchar++;
			if (c != d) {
				repos(nchar);
				return (0);
			}
		} while (c != '\n');
	}
	repos(nchar);
	return (1);
}

void
repos(int nchar)
{
	int i;

	for (i = 0; i < 2; i++)
		(void)fseek(fp[i], (long)-nchar, SEEK_CUR);
}

__dead void
trouble(void)
{
	errx(EXIT_FAILURE, "logic error");
}

/*
 * collect an editing script for later regurgitation
 */
int
edit(struct diff *diff, int dup, int j)
{
	if (((dup + 1) & eflag) == 0)
		return (j);
	j++;
	overlap[j] = !dup;
	if (!dup)
		overlapcnt++;
	de[j].old.from = diff->old.from;
	de[j].old.to = diff->old.to;
	de[j].new.from = de[j-1].new.to + skip(2, diff->new.from, NULL);
	de[j].new.to = de[j].new.from + skip(2, diff->new.to, NULL);
	return (j);
}

/* regurgitate */
__dead void
edscript(int n)
{
	int j,k;
	char block[BUFSIZ];

	for (; n > 0; n--) {
		if (!oflag || !overlap[n])
			prange(&de[n].old);
		else
			printf("%da\n=======\n", de[n].old.to -1);
		(void)fseek(fp[2], (long)de[n].new.from, SEEK_SET);
		for (k = de[n].new.to-de[n].new.from; k > 0; k-= j) {
			j = k > BUFSIZ ? BUFSIZ : k;
			if (fread(block, 1, j, fp[2]) != j)
				trouble();
			(void)fwrite(block, 1, j, stdout);
		}
		if (!oflag || !overlap[n])
			printf(".\n");
		else {
			printf("%s\n.\n", f3mark);
			printf("%da\n%s\n.\n", de[n].old.from - 1, f1mark);
		}
	}
	exit(overlapcnt);
}

void
increase(void)
{
	struct diff *p;
	char *q;
	size_t newsz, incr;

	/* are the memset(3) calls needed? */
	newsz = szchanges == 0 ? 64 : 2 * szchanges;
	incr = newsz - szchanges;

	p = reallocarray(d13, newsz, sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
	memset(p + szchanges, 0, incr * sizeof(struct diff));
	d13 = p;
	p = reallocarray(d23, newsz, sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
	memset(p + szchanges, 0, incr * sizeof(struct diff));
	d23 = p;
	p = reallocarray(de, newsz, sizeof(struct diff));
	if (p == NULL)
		err(1, NULL);
	memset(p + szchanges, 0, incr * sizeof(struct diff));
	de = p;
	q = reallocarray(overlap, newsz, sizeof(char));
	if (q == NULL)
		err(1, NULL);
	memset(q + szchanges, 0, incr * sizeof(char));
	overlap = q;
	szchanges = newsz;
}


__dead void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s [-exEX3] /tmp/d3a.?????????? "
	    "/tmp/d3b.?????????? file1 file2 file3\n", __progname);
	exit(EXIT_FAILURE);
}
@


1.18
log
@Remove useless n=n assignment in the first parse of a for().
It was already removed from the rcs version by nicm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.17 2015/10/09 01:37:07 deraadt Exp $	*/
d304 6
a309 1
	while ((t1 = (d1 < d13 + m1)) | (t2 = (d2 < d23 + m2))) {
@


1.17
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.16 2015/10/05 13:30:30 deraadt Exp $	*/
d546 1
a546 1
	for (n = n; n > 0; n--) {
@


1.16
log
@tame "stdio rpath" or tame "stdio" suffices for all of these programs.
fairly easy to audit by running nm and noticing nothing beyond base
stdio except for fopen/freopen.  Then review all callpaths to those
functions, and place the tame() calls.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.15 2015/09/05 09:47:08 jsg Exp $	*/
d148 2
a149 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.15
log
@Add brackets to clarify assignments that are the result of a test operator.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.14 2014/12/01 06:36:32 deraadt Exp $	*/
d147 3
@


1.14
log
@trivial reallocarray() use
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.13 2013/11/15 22:20:04 millert Exp $	*/
d301 1
a301 1
	while ((t1 = d1 < d13 + m1) | (t2 = d2 < d23 + m2)) {
@


1.13
log
@Include unistd.h as it is the standard location for getopt().
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.12 2012/03/04 04:05:15 fgsch Exp $	*/
d576 1
a576 1
	p = realloc(d13, newsz * sizeof(struct diff));
d581 1
a581 1
	p = realloc(d23, newsz * sizeof(struct diff));
d586 1
a586 1
	p = realloc(de, newsz * sizeof(struct diff));
d591 1
a591 1
	q = realloc(overlap, newsz * sizeof(char));
@


1.12
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.11 2009/10/27 23:59:37 deraadt Exp $	*/
d67 2
d72 1
a72 2
#include <ctype.h>
#include <err.h>
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.10 2008/02/27 18:10:05 tobias Exp $	*/
d127 1
a127 1
char *getline(FILE *, size_t *);
d256 1
a256 1
	while ((line = getline(b, NULL))) {
d264 1
a264 1
getline(FILE *b, size_t *n)
d459 1
a459 1
		if ((line = getline(fp[i], &j)) == NULL)
@


1.10
log
@Properly check if temporary files have been successfully opened.  If not,
print error message on stderr (instead of stdout).

ok millert, ray, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.9 2007/09/10 14:29:53 tobias Exp $	*/
a65 10

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.9 2007/09/10 14:29:53 tobias Exp $";
#endif /* not lint */
@


1.9
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.8 2005/11/22 16:00:49 markus Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.8 2005/11/22 16:00:49 markus Exp $";
d196 2
a197 4
		if ((fp[i] = fopen(argv[i + 2], "r")) == NULL) {
			printf("diff3: can't open %s\n", argv[i + 2]);
			exit(EXIT_FAILURE);
		}
d216 2
@


1.8
log
@out-of-bounds access; ok otto@@, millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.7 2005/08/01 08:17:57 otto Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.7 2005/08/01 08:17:57 otto Exp $";
d517 1
a517 1
		(void)fseek(fp[i], (long)-nchar, 1);
d557 1
a557 1
		(void)fseek(fp[2], (long)de[n].new.from, 0);
@


1.7
log
@Use dynamic memory instead of a fixed table. Makes merges files with
lots of changes possible. While there, kill an off-by-one.
Report and testing by Alexander Bluhm. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.6 2005/03/30 04:44:52 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.6 2005/03/30 04:44:52 millert Exp $";
d243 4
a246 2
	(*dd)[i].old.from = (*dd)[i-1].old.to;
	(*dd)[i].new.from = (*dd)[i-1].new.to;
@


1.6
log
@Use fgetln() to read lines so we are not limited to an arbitrarily small
line length.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.5 2004/01/07 18:16:42 canacar Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.5 2004/01/07 18:16:42 canacar Exp $";
d108 4
a111 3
#define NC 200
struct diff d13[NC];
struct diff d23[NC];
d119 2
a120 2
struct diff de[NC];
char overlap[NC];
d139 1
a139 1
int readin(char *, struct diff *);
d149 1
d192 3
a194 2
	m = readin(argv[0], d13);
	n = readin(argv[1], d23);
d212 1
a212 1
readin(char *name, struct diff *dd)
d219 2
a220 2
		if (i >= NC)
			err(EXIT_FAILURE, "too many changes");
d238 4
a241 4
		dd[i].old.from = a;
		dd[i].old.to = b;
		dd[i].new.from = c;
		dd[i].new.to = d;
d243 2
a244 2
	dd[i].old.from = dd[i-1].old.to;
	dd[i].new.from = dd[i-1].new.to;
d571 35
@


1.5
log
@Correctly test for cases where one file is different, and the other has
no more changes.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.4 2003/11/09 20:13:57 otto Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.4 2003/11/09 20:13:57 otto Exp $";
d79 1
a120 1
char line[256];
d135 2
a136 2
int getchange(FILE *);
int getline(FILE *);
d211 3
a213 4
	int i;
	int a,b,c,d;
	char kind;
	char *p;
d215 1
a215 1
	for (i=0; getchange(fp[0]); i++) {
a217 1
		p = line;
d256 1
a256 1
int
d259 3
a261 1
	while (getline(b)) {
d263 1
a263 1
			return (1);
d265 1
a265 1
	return (0);
d268 2
a269 2
int
getline(FILE *b)
d271 16
a286 11
	int i, c;

	for (i = 0; i < sizeof(line) - 1; i++) {
		c = getc(b);
		if (c == EOF)
			break;
		line[i] = c;
		if (c == '\n') {
			line[++i] = 0;
			return (i);
		}
d288 6
a293 1
	return (0);
d460 2
a461 1
	int j, n;
d464 1
a464 1
		if ((j = getline(fp[i])) == 0)
d470 1
a470 1
	return (n);
@


1.4
log
@Typos in comments from Jared Yanovich <jjy2+ at pitt dot edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.3 2003/10/24 20:32:06 avsm Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.3 2003/10/24 20:32:06 avsm Exp $";
d304 1
a304 1
		if ((!t2 || t1) && d1->new.to < d2->new.from) {
d316 1
a316 1
		if ((!t1 || t2) && d2->new.to < d1->new.from) {
@


1.3
log
@dont compare int to NULL, millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.2 2003/07/14 17:43:52 deraadt Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.2 2003/07/14 17:43:52 deraadt Exp $";
d203 1
a203 1
 * Pick up the line numbers of allcahnges from one change file.
d349 1
a349 1
			 * dup = 1 meands files 1 and 2 identical
d444 1
a444 1
 * skip to just befor line number from in file "i".  If "pr" is non-NULL,
@


1.2
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3prog.c,v 1.1 2003/07/10 16:06:07 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: diff3prog.c,v 1.1 2003/07/10 16:06:07 millert Exp $";
d453 1
a453 1
		if ((j = getline(fp[i])) == NULL)
@


1.1
log
@A matching diff3 from 32V w/ some UCB changes.  I cleaned this up a bit
(KNF and -Wall) and rewrote the shell front-end.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD$";
d129 1
a129 1
int oflag;      /* indicates whether to mark overlaps (-E or -X)*/
d155 1
a155 1
        eflag = 0;
d159 4
a162 4
                case 'E':
                        eflag = 3;
                        oflag = 1;
                        break;
d166 3
a168 3
                case 'X':
                        oflag = eflag = 1;
                        break;
d171 1
a171 1
                        break;
d183 2
a184 2
        if (oflag) { 
                (void)snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s",
d186 1
a186 1
                (void)snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s",
d188 1
a188 1
        }
d367 1
a367 1
		 if (d1->new.from < d2->new.from) {
d500 1
a500 1
	for (i = 0; i < 2; i++) 
d519 2
a520 2
        overlap[j] = !dup;
        if (!dup)
d537 4
a540 4
                if (!oflag || !overlap[n]) 
                        prange(&de[n].old);
                else
                        printf("%da\n=======\n", de[n].old.to -1);
d548 6
a553 6
                if (!oflag || !overlap[n]) 
                        printf(".\n");
                else {
                        printf("%s\n.\n", f3mark);
                        printf("%da\n%s\n.\n", de[n].old.from - 1, f1mark);
                }
d555 1
a555 1
        exit(overlapcnt);
@

