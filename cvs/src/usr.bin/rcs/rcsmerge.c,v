head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.56.0.4
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.55.0.6
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.52.0.20
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.18
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.52.0.14
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.12
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.51.0.10
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.51.0.12
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.8
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.6
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.51.0.4
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.51.0.2
	OPENBSD_4_2_BASE:1.51
	OPENBSD_4_1:1.50.0.2
	OPENBSD_4_1_BASE:1.50
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13;
locks; strict;
comment	@ * @;


1.57
date	2016.08.26.09.02.54;	author guenther;	state Exp;
branches;
next	1.56;
commitid	07zudOJ8CxdoPUjD;

1.56
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.55;
commitid	aZp5pu4rATnp3dyP;

1.55
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	Uu5nFG3wCl0LACBb;

1.54
date	2014.10.10.08.15.25;	author otto;	state Exp;
branches;
next	1.53;
commitid	nj4mpSZoLV0jWhzi;

1.53
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.52;
commitid	yRuTsAu91VfT3St0;

1.52
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.11.08.18.19;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.01.05.14.17;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.14.15.23.10;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.10.12.05.33;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.09.14.03.55;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.08.18.36.04;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.08.11.56.16;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.05.08.09.59.09;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.08.09.48.12;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.25.03.25.42;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.24.13.32.10;	author jmc;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.24.08.18.06;	author jmc;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.24.08.10.41;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.04.21.07.06.25;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.14.16.28.24;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.23.08.50.41;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.14.15.59.06;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.08.12.34.53;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.08.08.44.29;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.06.14.44.51;	author jmc;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.06.13.22.59;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.06.08.46.55;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.10.20.27.46;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.02.13.21.37;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.02.11.26.19;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.26.18.13.58;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.23.11.42.43;	author niallo;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.23.11.04.26;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.23.04.25.34;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.23.04.07.06;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.18.16.16.39;	author xsa;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Pull in <time.h> for struct tm, used in rcs.h

ok deraadt@@
@
text
@/*	$OpenBSD: rcsmerge.c,v 1.56 2015/11/02 16:45:21 nicm Exp $	*/
/*
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

int
rcsmerge_main(int argc, char **argv)
{
	int fd, ch, flags, kflag, status;
	char fpath[PATH_MAX], r1[RCS_REV_BUFSZ], r2[RCS_REV_BUFSZ];
	char *rev_str1, *rev_str2;
	RCSFILE *file;
	RCSNUM *rev1, *rev2;
	BUF *bp;

	flags = 0;
	status = D_ERROR;
	rev1 = rev2 = NULL;
	rev_str1 = rev_str2 = NULL;

	while ((ch = rcs_getopt(argc, argv, "AEek:p::q::r::TVx::z:")) != -1) {
		switch (ch) {
		case 'A':
			/*
			 * kept for compatibility
			 */
			break;
		case 'E':
			flags |= MERGE_EFLAG;
			flags |= MERGE_OFLAG;
			break;
		case 'e':
			flags |= MERGE_EFLAG;
			break;
		case 'k':
			kflag = rcs_kflag_get(rcs_optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				warnx("invalid RCS keyword substitution mode");
				(usage)();
			}
			break;
		case 'p':
			rcs_setrevstr2(&rev_str1, &rev_str2, rcs_optarg);
			flags |= PIPEOUT;
			break;
		case 'q':
			rcs_setrevstr2(&rev_str1, &rev_str2, rcs_optarg);
			flags |= QUIET;
			break;
		case 'r':
			rcs_setrevstr2(&rev_str1, &rev_str2,
			    rcs_optarg ? rcs_optarg : "");
			break;
		case 'T':
			/*
			 * kept for compatibility
			 */
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			timezone_flag = rcs_optarg;
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (rev_str1 == NULL) {
		warnx("no base revision number given");
		(usage)();
	}

	if (argc < 1) {
		warnx("no input file");
		(usage)();
	}

	if (argc > 2 || (argc == 2 && argv[1] != NULL))
		warnx("warning: excess arguments ignored");

	if ((fd = rcs_choosefile(argv[0], fpath, sizeof(fpath))) < 0)
		err(status, "%s", fpath);

	if (!(flags & QUIET))
		(void)fprintf(stderr, "RCS file: %s\n", fpath);

	if ((file = rcs_open(fpath, fd, RCS_READ)) == NULL)
		return (status);

	if (strcmp(rev_str1, "") == 0) {
		rev1 = rcsnum_alloc();
		rcsnum_cpy(file->rf_head, rev1, 0);
	} else if ((rev1 = rcs_getrevnum(rev_str1, file)) == NULL)
		errx(D_ERROR, "invalid revision: %s", rev_str1);

	if (rev_str2 != NULL && strcmp(rev_str2, "") != 0) {
		if ((rev2 = rcs_getrevnum(rev_str2, file)) == NULL)
			errx(D_ERROR, "invalid revision: %s", rev_str2);
	} else {
		rev2 = rcsnum_alloc();
		rcsnum_cpy(file->rf_head, rev2, 0);
	}

	if (rcsnum_cmp(rev1, rev2, 0) == 0)
		goto out;

	if ((bp = rcs_diff3(file, argv[0], rev1, rev2, flags)) == NULL)
		errx(D_ERROR, "failed to merge");

	if (!(flags & QUIET)) {
		(void)rcsnum_tostr(rev1, r1, sizeof(r1));
		(void)rcsnum_tostr(rev2, r2, sizeof(r2));

		(void)fprintf(stderr, "Merging differences between %s and "
		    "%s into %s%s\n", r1, r2, argv[0],
		    (flags & PIPEOUT) ? "; result to stdout":"");
	}

	if (diff3_conflicts != 0)
		status = D_OVERLAPS;
	else
		status = 0;

	if (flags & PIPEOUT)
		buf_write_fd(bp, STDOUT_FILENO);
	else {
		/* XXX mode */
		if (buf_write(bp, argv[0], 0644) < 0)
			warnx("buf_write failed");

	}

	buf_free(bp);

out:
	rcs_close(file);
	rcsnum_free(rev1);
	rcsnum_free(rev2);
	return (status);
}

__dead void
rcsmerge_usage(void)
{
	fprintf(stderr,
	    "usage: rcsmerge [-EV] [-kmode] [-p[rev]] [-q[rev]]\n"
	    "                [-xsuffixes] [-ztz] -rrev file ...\n");

	exit(D_ERROR);
}
@


1.56
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.55 2015/01/16 06:40:11 deraadt Exp $	*/
d31 1
@


1.55
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.54 2014/10/10 08:15:25 otto Exp $	*/
d176 2
a177 6

	if (rev1 != NULL)
		rcsnum_free(rev1);
	if (rev2 != NULL)
		rcsnum_free(rev2);

@


1.54
log
@Zap some stored values never read; From Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.53 2014/10/02 06:23:15 otto Exp $	*/
d40 1
a40 1
	char fpath[MAXPATHLEN], r1[RCS_REV_BUFSZ], r2[RCS_REV_BUFSZ];
@


1.53
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.52 2010/07/23 21:46:05 ray Exp $	*/
a46 1
	kflag = RCS_KWEXP_ERR;
@


1.52
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.51 2007/06/30 08:23:49 xsa Exp $	*/
a70 1
				exit(D_ERROR);
a101 1
			exit(D_ERROR);
a110 1
		exit(D_ERROR);
a115 1
		exit(D_ERROR);
d186 1
a186 1
void
d192 2
@


1.51
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.50 2007/02/27 07:59:13 xsa Exp $	*/
d169 1
a169 1
		rcs_buf_write_fd(bp, STDOUT_FILENO);
d172 2
a173 2
		if (rcs_buf_write(bp, argv[0], 0644) < 0)
			warnx("rcs_buf_write failed");
d177 1
a177 1
	rcs_buf_free(bp);
@


1.50
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.49 2006/10/12 17:20:12 niallo Exp $	*/
d40 2
a41 1
	char fpath[MAXPATHLEN], r1[16], r2[16], *rev_str1, *rev_str2;
@


1.49
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.48 2006/08/11 08:18:19 xsa Exp $	*/
d27 5
a31 1
#include "includes.h"
@


1.48
log
@correctly handle merge(1) and rcsmerge(1) -e and -E flags; tests and OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.47 2006/08/01 05:14:17 ray Exp $	*/
d121 1
a121 1
		errx(status, "%s", fpath);
@


1.47
log
@Reduce rcs_buf_release() usage, improving binary support.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.46 2006/05/27 05:49:14 ray Exp $	*/
d49 11
a59 1
		case 'A': case 'E': case 'e':
d146 1
a146 2
	if ((bp = rcs_diff3(file, argv[0], rev1, rev2,
	    !(flags & QUIET))) == NULL)
@


1.46
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.45 2006/05/14 15:23:10 xsa Exp $	*/
d36 1
a36 1
	char *fcont, fpath[MAXPATHLEN], r1[16], r2[16], *rev_str1, *rev_str2;
d154 3
a156 6
	if (flags & PIPEOUT) {
		rcs_buf_putc(bp, '\0');
		fcont = rcs_buf_release(bp);
		printf("%s", fcont);
		xfree(fcont);
	} else {
a160 1
		rcs_buf_free(bp);
d162 2
@


1.45
log
@warnx(); return(); --> errx();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.44 2006/05/10 12:05:33 xsa Exp $	*/
d110 2
a111 2
	if ((fd = rcs_statfile(argv[0], fpath, sizeof(fpath), flags)) < 0)
		return (status);
@


1.44
log
@treat first file passed as argument only; issue a warning for others.
matches gnu/usr.bin/rcs. OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.43 2006/05/09 14:03:55 jmc Exp $	*/
d137 2
a138 4
	    !(flags & QUIET))) == NULL) {
		warnx("failed to merge");
		goto out;
	}
@


1.43
log
@move -e to compat land; pointed out by ray
ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.42 2006/05/09 12:33:42 ray Exp $	*/
d35 1
a35 1
	int fd, i, ch, flags, kflag, status;
d43 1
a43 1
	status = 0;
d95 2
a96 2
	if (argc < 1) {
		warnx("no input file");
d101 2
a102 2
	if (rev_str1 == NULL) {
		warnx("no base revision number given");
d107 5
a111 19
	for (i = 0; i < argc; i++) {
		fd = rcs_statfile(argv[i], fpath, sizeof(fpath), flags);
		if (fd < 0)
			continue;

		if ((file = rcs_open(fpath, fd, RCS_READ)) == NULL)
			continue;

		if (!(flags & QUIET))
			fprintf(stderr, "RCS file: %s\n", fpath);

		if (rev1 != NULL) {
			rcsnum_free(rev1);
			rev1 = NULL;
		}
		if (rev2 != NULL) {
			rcsnum_free(rev2);
			rev2 = NULL;
		}
d113 2
a114 13
		if (strcmp(rev_str1, "") == 0) {
			rev1 = rcsnum_alloc();
			rcsnum_cpy(file->rf_head, rev1, 0);
		} else if ((rev1 = rcs_getrevnum(rev_str1, file)) == NULL)
			errx(D_ERROR, "invalid revision: %s", rev_str1);

		if (rev_str2 != NULL && strcmp(rev_str2, "") != 0) {
			if ((rev2 = rcs_getrevnum(rev_str2, file)) == NULL)
				errx(D_ERROR, "invalid revision: %s", rev_str2);
		} else {
			rev2 = rcsnum_alloc();
			rcsnum_cpy(file->rf_head, rev2, 0);
		}
d116 16
a131 4
		if (rcsnum_cmp(rev1, rev2, 0) == 0) {
			rcs_close(file);
			continue;
		}
d133 2
a134 8
		if (!(flags & QUIET)) {
			(void)rcsnum_tostr(rev1, r1, sizeof(r1));
			(void)rcsnum_tostr(rev2, r2, sizeof(r2));

			fprintf(stderr, "Merging differences between %s and "
			    "%s into %s%s\n", r1, r2, argv[i],
			    (flags & PIPEOUT) ? "; result to stdout":"");
		}
d136 5
a140 6
		if ((bp = rcs_diff3(file, argv[i], rev1, rev2,
		    !(flags & QUIET))) == NULL) {
			warnx("failed to merge");
			rcs_close(file);
			continue;
		}
d142 8
a149 2
		if (diff3_conflicts != 0)
			status = D_OVERLAPS;
d151 14
a164 9
		if (flags & PIPEOUT) {
			rcs_buf_putc(bp, '\0');
			fcont = rcs_buf_release(bp);
			printf("%s", fcont);
			xfree(fcont);
		} else {
			/* XXX mode */
			if (rcs_buf_write(bp, argv[i], 0644) < 0)
				warnx("rcs_buf_write failed");
d166 1
a166 3
			rcs_buf_free(bp);
		}
		rcs_close(file);
d168 8
@


1.42
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.41 2006/05/08 18:36:04 xsa Exp $	*/
d187 1
a187 1
	    "usage: rcsmerge [-EeV] [-kmode] [-p[rev]] [-q[rev]]\n"
@


1.41
log
@properly handle exit code 1; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.40 2006/05/08 11:56:16 xsa Exp $	*/
a78 1
			/* NOTREACHED */
@


1.40
log
@correctly handle the `no input file' case.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.39 2006/05/08 09:59:09 xsa Exp $	*/
d35 1
a35 1
	int fd, i, ch, flags, kflag;
d43 1
d163 3
d181 1
a181 1
	return (0);
@


1.39
log
@err() and errx() should also exit with status 2;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.38 2006/05/08 09:48:12 xsa Exp $	*/
d95 1
a95 1
	if (argc < 0) {
@


1.38
log
@exit with status 2 after usage() too; pointed out by uwe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.37 2006/04/26 21:55:22 joris Exp $	*/
d131 1
a131 1
			errx(1, "invalid revision: %s", rev_str1);
d135 1
a135 1
				errx(1, "invalid revision: %s", rev_str2);
@


1.37
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.36 2006/04/26 02:55:13 joris Exp $	*/
d55 1
a55 1
				exit(1);
d88 1
a88 1
			exit(1);
d98 1
a98 1
		exit(1);
d104 1
a104 1
		exit(1);
@


1.36
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.35 2006/04/25 13:36:35 xsa Exp $	*/
d35 1
a35 1
	int i, ch, flags, kflag;
d108 2
a109 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath), flags) < 0)
d112 1
a112 1
		if ((file = rcs_open(fpath, RCS_READ)) == NULL)
@


1.35
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.34 2006/04/25 03:25:42 ray Exp $	*/
d154 1
a154 1
		if ((bp = cvs_diff3(file, argv[i], rev1, rev2,
d162 2
a163 2
			cvs_buf_putc(bp, '\0');
			fcont = cvs_buf_release(bp);
d168 2
a169 2
			if (cvs_buf_write(bp, argv[i], 0644) < 0)
				warnx("cvs_buf_write failed");
d171 1
a171 1
			cvs_buf_free(bp);
@


1.34
log
@The -r flag without an argument signifies HEAD for rcsmerge as well.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.33 2006/04/24 13:32:10 jmc Exp $	*/
d130 1
a130 1
			fatal("invalid revision: %s", rev_str1);
d134 1
a134 1
				fatal("invalid revision: %s", rev_str2);
@


1.33
log
@- move -A into compat land
- tweak -E description accordingly

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.32 2006/04/24 08:18:06 jmc Exp $	*/
d46 1
a46 1
	while ((ch = rcs_getopt(argc, argv, "AEek:p::q::r:TVx::z:")) != -1) {
d67 2
a68 1
			rcs_setrevstr2(&rev_str1, &rev_str2, rcs_optarg);
d126 4
a129 1
		if ((rev1 = rcs_getrevnum(rev_str1, file)) == NULL)
d131 2
a132 1
		if (rev_str2 != NULL) {
@


1.32
log
@-r is not optional: simplify its synopsis, but improve its description;
ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.31 2006/04/24 08:10:41 xsa Exp $	*/
d178 1
a178 1
	    "usage: rcsmerge [-AEeV] [-kmode] [-p[rev]] [-q[rev]]\n"
@


1.31
log
@be consistent in error messages for wrongly specified keyword substitution
mode for `-k'.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.30 2006/04/21 17:17:29 xsa Exp $	*/
d179 1
a179 1
	    "                [-rrev] [-xsuffixes] [-ztz] file ...\n");
@


1.30
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.29 2006/04/21 14:18:26 xsa Exp $	*/
d53 1
a53 1
				warnx("invalid RCS keyword expansion mode");
@


1.29
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.28 2006/04/21 07:06:25 xsa Exp $	*/
d107 1
a107 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
@


1.28
log
@switch -p handling to bitwise flags; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.27 2006/04/19 06:53:41 xsa Exp $	*/
d53 1
a53 2
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
d95 1
a95 1
		cvs_log(LP_ERR, "no input file");
d101 1
a101 1
		cvs_log(LP_ERR, "no base revision number given");
d151 1
a151 1
			cvs_log(LP_ERR, "failed to merge");
d164 1
a164 1
				cvs_log(LP_ERR, "failed to write new file");
@


1.27
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.26 2006/04/14 16:28:24 ray Exp $	*/
d61 1
a61 1
			pipeout = 1;
d147 1
a147 1
			    (pipeout == 1) ? "; result to stdout":"");
d157 1
a157 1
		if (pipeout == 1) {
@


1.26
log
@Add missing usage() calls.

``crazy'' joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.25 2006/04/13 00:58:25 ray Exp $	*/
a31 2
static int kflag = RCS_KWEXP_ERR;

d35 1
a35 1
	int i, ch;
d41 2
d65 1
a65 1
			verbose = 0;
d114 1
a114 1
		if (verbose == 1)
d141 1
a141 1
		if (verbose == 1) {
d151 1
a151 1
		    verbose)) == NULL) {
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.24 2006/04/12 08:23:30 ray Exp $	*/
d87 2
a88 1
			break;
@


1.24
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.23 2006/03/24 05:14:48 ray Exp $	*/
d125 6
a130 4
		rcs_set_rev(rev_str1, &rev1);
		if (rev_str2 != NULL)
			rcs_set_rev(rev_str2, &rev2);
		else {
@


1.23
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.22 2006/03/23 08:50:41 xsa Exp $	*/
d38 1
a38 1
	char *fcont, fpath[MAXPATHLEN], r1[16], r2[16];
d40 1
a40 1
	RCSNUM *baserev, *rev2, *frev;
d43 2
a44 1
	baserev = rev2 = RCS_HEAD_REV;
d60 1
a60 1
			rcs_set_rev(rcs_optarg, &baserev);
d64 1
a64 1
			rcs_set_rev(rcs_optarg, &baserev);
d68 1
a68 6
			if (baserev == RCS_HEAD_REV)
				rcs_set_rev(rcs_optarg, &baserev);
			else if (rev2 == RCS_HEAD_REV)
				rcs_set_rev(rcs_optarg, &rev2);
			else
				fatal("too many revision numbers");
d100 1
a100 1
	if (baserev == RCS_HEAD_REV) {
d116 16
a131 4
		if (rev2 == RCS_HEAD_REV)
			frev = file->rf_head;
		else
			frev = rev2;
d133 1
a133 1
		if (rcsnum_cmp(baserev, frev, 0) == 0) {
d138 3
a140 2
		rcsnum_tostr(baserev, r1, sizeof(r1));
		rcsnum_tostr(frev, r2, sizeof(r2));
a141 1
		if (verbose == 1)
d145 1
d147 2
a148 2
		if ((bp = cvs_diff3(file, argv[i], baserev,
		    frev, verbose)) == NULL) {
@


1.22
log
@- cvs_buf_putc() will never return non-zero
- change cvs_buf_putc() return type to void
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.21 2006/03/16 04:04:57 ray Exp $	*/
d45 1
a45 1
	while ((ch = rcs_getopt(argc, argv, "AEek:p::q::r:TVx:z:")) != -1) {
d84 2
a85 1
			rcs_suffixes = rcs_optarg;
@


1.21
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.20 2006/03/14 15:59:06 xsa Exp $	*/
d145 1
a145 5
			if (cvs_buf_putc(bp, '\0') < 0) {
				rcs_close(file);
				continue;
			}

@


1.20
log
@add an argument to cvs_diff3() to be able to handle verbosity of
commands; fixes rcsmerge -q  behaviour. OK niallo@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.19 2006/03/08 12:34:53 xsa Exp $	*/
d82 1
@


1.19
log
@fix usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.18 2006/03/08 08:44:29 xsa Exp $	*/
d136 2
a137 1
		if ((bp = cvs_diff3(file, argv[i], baserev, frev)) == NULL) {
@


1.18
log
@respect -q; pointed out by Ray Lai.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.17 2006/03/07 01:40:52 joris Exp $	*/
d168 2
a169 2
	    "usage: rcsmerge [-AEeV] [-kmode] [-p[rev]] [-q[rev]] "
	    "[-rrev] [-xsuffixes] [-ztz] file ...\n");
@


1.17
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.16 2006/03/06 14:44:51 jmc Exp $	*/
d115 2
a116 1
		printf("RCS file: %s\n", fpath);
d131 4
a134 2
		printf("Merging differences between %s and %s into %s%s\n",
		    r1, r2, argv[i], (pipeout == 1) ? "; result to stdout":"");
@


1.16
log
@move compat flags into a STANDARDS section;
update usage() whilst here...
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.15 2006/03/06 13:22:59 xsa Exp $	*/
d45 1
a45 1
	while ((ch = rcs_getopt(argc, argv, "AEek:p::q::r:TVx:")) != -1) {
d84 3
@


1.15
log
@adapt informative message if we are sending output to stdout.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.14 2006/03/06 08:46:55 xsa Exp $	*/
d162 2
a163 2
	    "usage: rcsmerge [-TV] [-kmode] [-p[rev]] [-q[rev]] "
	    "[-rrev] [-xsuffixes] file ...\n");
@


1.14
log
@if the submitted rev(s) is/are the same as the head rev, skip the process
for the specified file. Fix some error messages while there. OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.13 2006/01/05 10:28:24 xsa Exp $	*/
d38 1
a38 1
	char *fcont, fpath[MAXPATHLEN];
d123 6
@


1.13
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.12 2006/01/02 08:13:28 xsa Exp $	*/
d3 1
a3 1
 * Copyright (c) 2005 Xavier Santolaria <xsa@@openbsd.org>
d45 1
a45 1
	while ((ch = rcs_getopt(argc, argv, "k:p::q::r:TVx:")) != -1) {
d47 2
d72 1
a72 1
				cvs_log(LP_WARN, "ignored excessive -r option");
d112 2
d119 4
a122 1
		printf("RCS file: %s\n", fpath);
a145 6

		if (diff3_conflicts > 0) {
			cvs_log(LP_WARN, "%d conflict%s found during merge",
			    diff3_conflicts, (diff3_conflicts > 1) ? "s": "");
		}

@


1.12
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.11 2005/12/10 20:27:46 joris Exp $	*/
d29 1
a29 2
#include "log.h"
#include "rcs.h"
a30 1
#include "rcsprog.h"
@


1.11
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.10 2005/11/28 14:43:59 xsa Exp $	*/
d27 1
a27 7
#include <sys/param.h>
#include <sys/stat.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.10
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.9 2005/11/21 16:20:29 xsa Exp $	*/
d139 1
a139 1
			free(fcont);
@


1.9
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.8 2005/11/02 13:21:37 xsa Exp $	*/
d164 1
a164 1
	    "[-rrev] file ...\n");
@


1.8
log
@print RCS file path;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.7 2005/11/02 11:26:19 xsa Exp $	*/
d53 1
a53 1
	while ((ch = rcs_getopt(argc, argv, "k:p::q::r:TV")) != -1) {
d88 3
@


1.7
log
@sync with Reality;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.6 2005/10/26 18:13:58 xsa Exp $	*/
d119 2
@


1.6
log
@diff3_conflicts cleanup; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.5 2005/10/23 11:42:43 niallo Exp $	*/
d53 1
a53 1
	while ((ch = rcs_getopt(argc, argv, "k:p::qr:TV")) != -1) {
d69 1
d158 2
a159 1
	    "usage: rcsmerge [-qTV] [-kmode] [-rrev] file ...\n");
@


1.5
log
@add extern int diff3_conflicts to unbreak. bad joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.4 2005/10/23 11:04:26 xsa Exp $	*/
a38 2

extern diff3_conflicts;
@


1.4
log
@correct error message;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.3 2005/10/23 04:25:34 joris Exp $	*/
d40 1
@


1.3
log
@warn if conflicts were found during the merge;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.2 2005/10/23 04:07:06 joris Exp $	*/
d103 1
a103 1
		cvs_log(LP_ERR, "missing base revision");
@


1.2
log
@with recent diff3 support, rcsmerge now works;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsmerge.c,v 1.1 2005/10/18 16:16:39 xsa Exp $	*/
d141 5
@


1.1
log
@skeletons for rcsmerge(1);
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
	char fpath[MAXPATHLEN];
d49 2
a50 1
	RCSNUM *rev;
d52 1
a52 1
	rev = RCS_HEAD_REV;
d54 1
a54 1
	while ((ch = rcs_getopt(argc, argv, "k:qr:TV")) != -1) {
d65 4
d73 6
a78 1
			rcs_set_rev(rcs_optarg, &rev);
d102 6
d114 28
@

