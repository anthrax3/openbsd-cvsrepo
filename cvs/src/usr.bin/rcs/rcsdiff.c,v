head	1.84;
access;
symbols
	OPENBSD_6_2:1.84.0.6
	OPENBSD_6_2_BASE:1.84
	OPENBSD_6_1:1.84.0.8
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.84.0.4
	OPENBSD_6_0_BASE:1.84
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.79.0.8
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.79.0.6
	OPENBSD_5_5_BASE:1.79
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.78.0.10
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.78.0.8
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.6
	OPENBSD_5_0:1.78.0.4
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.78.0.2
	OPENBSD_4_9_BASE:1.78
	OPENBSD_4_8:1.77.0.2
	OPENBSD_4_8_BASE:1.77
	OPENBSD_4_7:1.75.0.10
	OPENBSD_4_7_BASE:1.75
	OPENBSD_4_6:1.75.0.12
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.75.0.8
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.75.0.6
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.75.0.4
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.75.0.2
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30;
locks; strict;
comment	@ * @;


1.84
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.83;
commitid	aZp5pu4rATnp3dyP;

1.83
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.82;
commitid	FFUg8uzT5GNAfRXp;

1.82
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	Uu5nFG3wCl0LACBb;

1.81
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	Z3HC5pAWzpo5jsTe;

1.80
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.79;
commitid	yRuTsAu91VfT3St0;

1.79
date	2013.04.16.20.24.45;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.06.22.50.34;	author chl;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.03.00.56.23;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.26.21.50.17;	author sobrado;	state Exp;
branches;
next	1.72;

1.72
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.70;

1.70
date	2006.09.22.13.42.43;	author jmc;	state Exp;
branches;
next	1.69;

1.69
date	2006.09.21.15.30.07;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.31.06.51.55;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.04.20.32.56;	author niallo;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.08.09.59.09;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2006.05.08.09.48.12;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.05.15.47.36;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.04.07.06.58;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.57;

1.57
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.56;

1.56
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.04.24.08.40.01;	author jmc;	state Exp;
branches;
next	1.54;

1.54
date	2006.04.24.08.10.41;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.14.23.32.01;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.14.23.29.01;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.13.16.10.29;	author joris;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.10.19.49.45;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.06.10.13.00;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.30.23.19.20;	author joris;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.20.16.18.13;	author niallo;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.15.21.20.57;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.08.20.19.39;	author joris;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.06.15.00.21;	author jmc;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.06.14.41.04;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.06.09.59.22;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.06.09.41.53;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.05.14.23.07;	author niallo;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.27.16.05.21;	author niallo;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.20.09.04.17;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.10.19.44.36;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.05.14.47.24;	author xsa;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.01.23.02.27;	author niallo;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.29.11.11.39;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.28.10.17.20;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.25.15.56.10;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.23.09.39.20;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.22.15.00.06;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.21.15.01.10;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.16.09.57.04;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.14.11.01.04;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.27.07.43.56;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.16.12.03.09;	author niallo;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.12.17.43.18;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.11.14.27.59;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.09.20.55.27;	author niallo;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.08.20.30.39;	author niallo;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.08.20.03.36;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.08.19.58.04;	author niallo;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.08.19.20.49;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.06.01.24.25;	author joris;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@/*	$OpenBSD: rcsdiff.c,v 1.83 2015/06/13 20:15:21 nicm Exp $	*/
/*
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

static int rcsdiff_file(RCSFILE *, RCSNUM *, const char *, int);
static int rcsdiff_rev(RCSFILE *, RCSNUM *, RCSNUM *, int);
static void push_ignore_pats(char *);

static int quiet;
static int kflag = RCS_KWEXP_ERR;
static char *diff_ignore_pats;

int
rcsdiff_main(int argc, char **argv)
{
	int fd, i, ch, dflags, status;
	RCSNUM *rev1, *rev2;
	RCSFILE *file;
	char fpath[PATH_MAX], *rev_str1, *rev_str2;
	const char *errstr;

	rev1 = rev2 = NULL;
	rev_str1 = rev_str2 = NULL;
	status = D_SAME;
	dflags = 0;

	if (strlcpy(diffargs, "diff", sizeof(diffargs)) >= sizeof(diffargs))
		errx(D_ERROR, "diffargs too long");

	while ((ch = rcs_getopt(argc, argv, "abC:cdI:ik:npqr:TtU:uVwx::z::")) != -1) {
		switch (ch) {
		case 'a':
			if (strlcat(diffargs, " -a", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_FORCEASCII;
			break;
		case 'b':
			if (strlcat(diffargs, " -b", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_FOLDBLANKS;
			break;
		case 'C':
			(void)strlcat(diffargs, " -C", sizeof(diffargs));
			if (strlcat(diffargs, rcs_optarg, sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			diff_context = strtonum(rcs_optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(D_ERROR, "context is %s: %s",
				    errstr, rcs_optarg);
			diff_format = D_CONTEXT;
			break;
		case 'c':
			if (strlcat(diffargs, " -c", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			diff_format = D_CONTEXT;
			break;
		case 'd':
			if (strlcat(diffargs, " -d", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_MINIMAL;
			break;
		case 'i':
			if (strlcat(diffargs, " -i", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_IGNORECASE;
			break;
		case 'I':
			(void)strlcat(diffargs, " -I", sizeof(diffargs));
			if (strlcat(diffargs, rcs_optarg, sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			push_ignore_pats(rcs_optarg);
			break;
		case 'k':
			kflag = rcs_kflag_get(rcs_optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				warnx("invalid RCS keyword substitution mode");
				(usage)();
			}
			break;
		case 'n':
			if (strlcat(diffargs, " -n", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			diff_format = D_RCSDIFF;
			break;
		case 'p':
			if (strlcat(diffargs, " -p", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_PROTOTYPE;
			break;
		case 'q':
			quiet = 1;
			break;
		case 'r':
			rcs_setrevstr2(&rev_str1, &rev_str2, rcs_optarg);
			break;
		case 'T':
			/*
			 * kept for compatibility
			 */
			break;
		case 't':
			if (strlcat(diffargs, " -t", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_EXPANDTABS;
			break;
		case 'U':
			(void)strlcat(diffargs, " -U", sizeof(diffargs));
			if (strlcat(diffargs, rcs_optarg, sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			diff_context = strtonum(rcs_optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(D_ERROR, "context is %s: %s",
				    errstr, rcs_optarg);
			diff_format = D_UNIFIED;
			break;
		case 'u':
			if (strlcat(diffargs, " -u", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			diff_format = D_UNIFIED;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'w':
			if (strlcat(diffargs, " -w", sizeof(diffargs)) >=
			    sizeof(diffargs))
				errx(D_ERROR, "diffargs too long");
			dflags |= D_IGNOREBLANKS;
			break;
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			timezone_flag = rcs_optarg;
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (argc == 0) {
		warnx("no input file");
		(usage)();
	}

	if (diff_ignore_pats != NULL) {
		char buf[BUFSIZ];
		int error;

		diff_ignore_re = xmalloc(sizeof(*diff_ignore_re));
		if ((error = regcomp(diff_ignore_re, diff_ignore_pats,
		    REG_NEWLINE | REG_EXTENDED)) != 0) {
			regerror(error, diff_ignore_re, buf, sizeof(buf));
			if (*diff_ignore_pats != '\0')
				errx(D_ERROR, "%s: %s", diff_ignore_pats, buf);
			else
				errx(D_ERROR, "%s", buf);
		}
	}

	for (i = 0; i < argc; i++) {
		fd = rcs_choosefile(argv[i], fpath, sizeof(fpath));
		if (fd < 0) {
			warn("%s", fpath);
			continue;
		}

		if ((file = rcs_open(fpath, fd,
		    RCS_READ|RCS_PARSE_FULLY)) == NULL)
			continue;

		rcs_kwexp_set(file, kflag);

		if (rev_str1 != NULL) {
			if ((rev1 = rcs_getrevnum(rev_str1, file)) == NULL)
				errx(D_ERROR, "bad revision number");
		}
		if (rev_str2 != NULL) {
			if ((rev2 = rcs_getrevnum(rev_str2, file)) == NULL)
				errx(D_ERROR, "bad revision number");
		}

		if (!quiet) {
			fprintf(stderr, "%s\n", RCS_DIFF_DIV);
			fprintf(stderr, "RCS file: %s\n", fpath);
		}

		diff_file = argv[i];

		/* No revisions given. */
		if (rev_str1 == NULL)
			status = rcsdiff_file(file, file->rf_head, argv[i],
			    dflags);
		/* One revision given. */
		else if (rev_str2 == NULL)
			status = rcsdiff_file(file, rev1, argv[i], dflags);
		/* Two revisions given. */
		else
			status = rcsdiff_rev(file, rev1, rev2, dflags);

		rcs_close(file);
		rcsnum_free(rev1);
		rcsnum_free(rev2);
		rev1 = rev2 = NULL;
	}

	return (status);
}

__dead void
rcsdiff_usage(void)
{
	fprintf(stderr,
	    "usage: rcsdiff [-cnquV] [-kmode] [-rrev] [-xsuffixes] [-ztz]\n"
	    "               [diff_options] file ...\n");

	exit(D_ERROR);
}

static int
rcsdiff_file(RCSFILE *file, RCSNUM *rev, const char *filename, int dflags)
{
	int ret, fd;
	time_t t;
	struct stat st;
	char *path1, *path2;
	BUF *b1, *b2;
	char rbuf[RCS_REV_BUFSZ];
	struct tm *tb;
	struct timeval tv[2], tv2[2];

	memset(&tv, 0, sizeof(tv));
	memset(&tv2, 0, sizeof(tv2));

	ret = D_ERROR;
	b1 = b2 = NULL;

	diff_rev1 = rev;
	diff_rev2 = NULL;
	path1 = path2 = NULL;

	if ((fd = open(filename, O_RDONLY)) == -1) {
		warn("%s", filename);
		goto out;
	}

	rcsnum_tostr(rev, rbuf, sizeof(rbuf));
	if (!quiet) {
		fprintf(stderr, "retrieving revision %s\n", rbuf);
		fprintf(stderr, "%s -r%s %s\n", diffargs, rbuf, filename);
	}

	if ((b1 = rcs_getrev(file, rev)) == NULL) {
		warnx("failed to retrieve revision %s", rbuf);
		goto out;
	}

	b1 = rcs_kwexp_buf(b1, file, rev);
	tv[0].tv_sec = rcs_rev_getdate(file, rev);
	tv[1].tv_sec = tv[0].tv_sec;

	if ((b2 = buf_load(filename)) == NULL) {
		warnx("failed to load file: `%s'", filename);
		goto out;
	}

	/* XXX - GNU uses GMT */
	if (fstat(fd, &st) == -1)
		err(D_ERROR, "%s", filename);

	tb = gmtime(&st.st_mtime);
	t = mktime(tb);

	tv2[0].tv_sec = t;
	tv2[1].tv_sec = t;

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b1, path1);

	buf_free(b1);
	b1 = NULL;

	if (utimes(path1, (const struct timeval *)&tv) < 0)
		warn("utimes");

	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b2, path2);

	buf_free(b2);
	b2 = NULL;

	if (utimes(path2, (const struct timeval *)&tv2) < 0)
		warn("utimes");

	ret = diffreg(path1, path2, NULL, dflags);

out:
	if (fd != -1)
		(void)close(fd);
	buf_free(b1);
	buf_free(b2);
	free(path1);
	free(path2);

	return (ret);
}

static int
rcsdiff_rev(RCSFILE *file, RCSNUM *rev1, RCSNUM *rev2, int dflags)
{
	struct timeval tv[2], tv2[2];
	BUF *b1, *b2;
	int ret;
	char *path1, *path2, rbuf1[RCS_REV_BUFSZ], rbuf2[RCS_REV_BUFSZ];

	ret = D_ERROR;
	b1 = b2 = NULL;
	memset(&tv, 0, sizeof(tv));
	memset(&tv2, 0, sizeof(tv2));

	diff_rev1 = rev1;
	diff_rev2 = rev2;
	path1 = path2 = NULL;

	rcsnum_tostr(rev1, rbuf1, sizeof(rbuf1));
	if (!quiet)
		fprintf(stderr, "retrieving revision %s\n", rbuf1);

	if ((b1 = rcs_getrev(file, rev1)) == NULL) {
		warnx("failed to retrieve revision %s", rbuf1);
		goto out;
	}

	b1 = rcs_kwexp_buf(b1, file, rev1);
	tv[0].tv_sec = rcs_rev_getdate(file, rev1);
	tv[1].tv_sec = tv[0].tv_sec;

	rcsnum_tostr(rev2, rbuf2, sizeof(rbuf2));
	if (!quiet)
		fprintf(stderr, "retrieving revision %s\n", rbuf2);

	if ((b2 = rcs_getrev(file, rev2)) == NULL) {
		warnx("failed to retrieve revision %s", rbuf2);
		goto out;
	}

	b2 = rcs_kwexp_buf(b2, file, rev2);
	tv2[0].tv_sec = rcs_rev_getdate(file, rev2);
	tv2[1].tv_sec = tv2[0].tv_sec;

	if (!quiet)
		fprintf(stderr, "%s -r%s -r%s\n", diffargs, rbuf1, rbuf2);

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b1, path1);

	buf_free(b1);
	b1 = NULL;

	if (utimes(path1, (const struct timeval *)&tv) < 0)
		warn("utimes");

	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b2, path2);

	buf_free(b2);
	b2 = NULL;

	if (utimes(path2, (const struct timeval *)&tv2) < 0)
		warn("utimes");

	ret = diffreg(path1, path2, NULL, dflags);

out:
	buf_free(b1);
	buf_free(b2);
	free(path1);
	free(path2);

	return (ret);
}

static void
push_ignore_pats(char *pattern)
{
	size_t len;

	if (diff_ignore_pats == NULL) {
		len = strlen(pattern) + 1;
		diff_ignore_pats = xmalloc(len);
		strlcpy(diff_ignore_pats, pattern, len);
	} else {
		/* old + "|" + new + NUL */
		len = strlen(diff_ignore_pats) + strlen(pattern) + 2;
		diff_ignore_pats = xreallocarray(diff_ignore_pats, len, 1);
		strlcat(diff_ignore_pats, "|", len);
		strlcat(diff_ignore_pats, pattern, len);
	}
}
@


1.83
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.82 2015/01/16 06:40:11 deraadt Exp $	*/
d253 3
a255 9

		if (rev1 != NULL) {
			rcsnum_free(rev1);
			rev1 = NULL;
		}
		if (rev2 != NULL) {
			rcsnum_free(rev2);
			rev2 = NULL;
		}
d351 2
a352 4
	if (b1 != NULL)
		buf_free(b1);
	if (b2 != NULL)
		buf_free(b2);
d426 2
a427 4
	if (b1 != NULL)
		buf_free(b1);
	if (b2 != NULL)
		buf_free(b2);
@


1.82
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.81 2014/12/01 21:58:46 deraadt Exp $	*/
d361 2
a362 4
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
d438 2
a439 4
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
@


1.81
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.80 2014/10/02 06:23:15 otto Exp $	*/
d54 1
a54 1
	char fpath[MAXPATHLEN], *rev_str1, *rev_str2;
@


1.80
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.79 2013/04/16 20:24:45 deraadt Exp $	*/
d460 1
a460 1
		diff_ignore_pats = xrealloc(diff_ignore_pats, len, 1);
@


1.79
log
@remove wrong casts; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.78 2010/12/06 22:50:34 chl Exp $	*/
a119 1
				exit(D_ERROR);
a185 1
			exit(D_ERROR);
a194 1
		exit(D_ERROR);
d267 1
a267 1
void
d273 2
@


1.78
log
@add missing header needed by futimes()

ok tobias@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.77 2010/07/28 09:07:11 ray Exp $	*/
d317 1
a317 1
	tv[0].tv_sec = (long)rcs_rev_getdate(file, rev);
d397 1
a397 1
	tv[0].tv_sec = (long)rcs_rev_getdate(file, rev1);
d410 1
a410 1
	tv2[0].tv_sec = (long)rcs_rev_getdate(file, rev2);
@


1.77
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.76 2010/07/23 21:46:05 ray Exp $	*/
d28 1
@


1.76
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.75 2007/07/03 00:56:23 ray Exp $	*/
d319 1
a319 1
	if ((b2 = buf_load(filename, BUF_AUTOEXT)) == NULL) {
@


1.75
log
@Rename rcs_diffreg() to diffreg().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.74 2007/06/30 08:23:49 xsa Exp $	*/
d319 1
a319 1
	if ((b2 = rcs_buf_load(filename, BUF_AUTOEXT)) == NULL) {
d335 1
a335 1
	rcs_buf_write_stmp(b1, path1);
d337 1
a337 1
	rcs_buf_free(b1);
d344 1
a344 1
	rcs_buf_write_stmp(b2, path2);
d346 1
a346 1
	rcs_buf_free(b2);
d358 1
a358 1
		rcs_buf_free(b1);
d360 1
a360 1
		rcs_buf_free(b2);
d416 1
a416 1
	rcs_buf_write_stmp(b1, path1);
d418 1
a418 1
	rcs_buf_free(b1);
d425 1
a425 1
	rcs_buf_write_stmp(b2, path2);
d427 1
a427 1
	rcs_buf_free(b2);
d437 1
a437 1
		rcs_buf_free(b1);
d439 1
a439 1
		rcs_buf_free(b2);
@


1.74
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.73 2007/04/26 21:50:17 sobrado Exp $	*/
d352 1
a352 1
	ret = rcs_diffreg(path1, path2, NULL, dflags);
d433 1
a433 1
	ret = rcs_diffreg(path1, path2, NULL, dflags);
@


1.73
log
@the message returned by usage() must fit on a 80-column display

ok by jmc@@, niallo@@, and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.72 2007/02/27 07:59:13 xsa Exp $	*/
d285 1
a285 1
	char rbuf[64];
d375 1
a375 1
	char *path1, *path2, rbuf1[64], rbuf2[64];
@


1.72
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.71 2006/10/12 17:20:12 niallo Exp $	*/
d273 2
a274 2
	    "usage: rcsdiff [-cnquV] [-kmode] [-rrev] "
	    "[-xsuffixes] [-ztz] [diff_options] file ...\n");
@


1.71
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.70 2006/09/22 13:42:43 jmc Exp $	*/
d27 8
a34 1
#include "includes.h"
@


1.70
log
@- explain diff_options (which i renamed from "diff options")
- sync usage()

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.69 2006/09/21 15:30:07 millert Exp $	*/
d210 1
a210 1
			warnx("%s", fpath);
@


1.69
log
@Add support to rcsdiff for all the other diff flags that
are pertinent to files (not directories) and that do not
conflict with rcsdiff-specific flags.  OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.68 2006/07/31 06:51:55 ray Exp $	*/
d267 1
a267 1
	    "[-xsuffixes] [-ztz] file ...\n");
@


1.68
log
@Minor KNF.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.67 2006/07/08 09:25:44 ray Exp $	*/
d32 3
a34 2
static int rcsdiff_file(RCSFILE *, RCSNUM *, const char *);
static int rcsdiff_rev(RCSFILE *, RCSNUM *, RCSNUM *);
d36 1
a36 1
static int flags = 0;
d38 1
d43 1
a43 1
	int fd, i, ch, status;
d47 1
d52 1
d57 1
a57 1
	while ((ch = rcs_getopt(argc, argv, "ck:nqr:TuVx::z::")) != -1) {
d59 23
d88 19
d121 6
d128 1
a128 1
			flags |= QUIET;
d138 17
d164 6
d192 15
d229 1
a229 1
		if (!(flags & QUIET)) {
d238 2
a239 1
			status = rcsdiff_file(file, file->rf_head, argv[i]);
d242 1
a242 1
			status = rcsdiff_file(file, rev1, argv[i]);
d245 1
a245 1
			status = rcsdiff_rev(file, rev1, rev2);
d271 1
a271 1
rcsdiff_file(RCSFILE *file, RCSNUM *rev, const char *filename)
d298 1
a298 1
	if (!(flags & QUIET)) {
d345 1
a345 1
	ret = rcs_diffreg(path1, path2, NULL);
d363 1
a363 1
rcsdiff_rev(RCSFILE *file, RCSNUM *rev1, RCSNUM *rev2)
d380 1
a380 1
	if (!(flags & QUIET))
d393 1
a393 1
	if (!(flags & QUIET))
d405 1
a405 1
	if (!(flags & QUIET))
d426 1
a426 1
	ret = rcs_diffreg(path1, path2, NULL);
d439 18
@


1.67
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.66 2006/06/04 20:32:56 niallo Exp $	*/
d104 1
a104 1
			exit (D_ERROR);
d274 2
d277 1
a277 4
	char *path1, *path2;
	BUF *b1, *b2;
	char rbuf1[64], rbuf2[64];
	struct timeval tv[2], tv2[2];
@


1.66
log
@- initialise path pointers to NULL since error code checks for that.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.65 2006/05/27 05:49:14 ray Exp $	*/
d237 1
a237 1
	rcs_buf_write_stmp(b1, path1, 0600);
d246 1
a246 1
	rcs_buf_write_stmp(b2, path2, 0600);
d319 1
a319 1
	rcs_buf_write_stmp(b1, path1, 0600);
d328 1
a328 1
	rcs_buf_write_stmp(b2, path2, 0600);
@


1.65
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.64 2006/05/09 12:33:42 ray Exp $	*/
d199 1
d287 1
@


1.64
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.63 2006/05/08 09:59:09 xsa Exp $	*/
d118 3
a120 2
		fd = rcs_statfile(argv[i], fpath, sizeof(fpath), flags);
		if (fd < 0)
d122 1
@


1.63
log
@err() and errx() should also exit with status 2;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.62 2006/05/08 09:48:12 xsa Exp $	*/
a94 1
			/* NOTREACHED */
@


1.62
log
@exit with status 2 after usage() too; pointed out by uwe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.61 2006/05/05 15:47:36 xsa Exp $	*/
d51 1
a51 1
		errx(1, "diffargs too long");
d58 1
a58 1
				errx(1, "diffargs too long");
d72 1
a72 1
				errx(1, "diffargs too long");
d89 1
a89 1
				errx(1, "diffargs too long");
d131 1
a131 1
				errx(1, "bad revision number");
d135 1
a135 1
				errx(1, "bad revision number");
d226 1
a226 1
		err(1, "%s", filename);
@


1.61
log
@- fix rcsdiff exit status on success/errors; now matches gnu/usr.bin/rcs.
- add DIAGNOSTICS section to rcsdiff.1 wrt exit codes.
ok ray@@ and jmc@@ for man page bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.60 2006/05/04 07:06:58 xsa Exp $	*/
d66 1
a66 1
				exit(1);
d105 1
a105 1
			exit (1);
d115 1
a115 1
		exit(1);
@


1.60
log
@finish work wrt TMPDIR; use xasprintf() to simplify code while in there;
"looks fine" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.59 2006/04/29 05:31:28 ray Exp $	*/
d48 1
a48 1
	status = 0;
d146 2
a147 3
		if (rev_str1 == NULL) {
			if (rcsdiff_file(file, file->rf_head, argv[i]) < 0)
				status = 2;
d149 2
a150 3
		} else if (rev_str2 == NULL) {
			if (rcsdiff_file(file, rev1, argv[i]) < 0)
				status = 2;
d152 2
a153 4
		} else {
			if (rcsdiff_rev(file, rev1, rev2) < 0)
				status = 2;
		}
d193 1
a193 1
	ret = -1;
d252 1
a252 2
	rcs_diffreg(path1, path2, NULL);
	ret = 0;
d278 1
a278 1
	ret = -1;
d333 1
a333 2
	rcs_diffreg(path1, path2, NULL);
	ret = 0;
@


1.59
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.58 2006/04/26 21:55:22 joris Exp $	*/
d188 1
a188 1
	char path1[MAXPATHLEN], path2[MAXPATHLEN];
d238 1
a238 3
	if (strlcpy(path1, rcs_tmpdir, sizeof(path1)) >= sizeof(path1) ||
	    strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1)) >= sizeof(path1))
		errx(1, "path too long");
d247 1
a247 3
	if (strlcpy(path2, rcs_tmpdir, sizeof(path2)) >= sizeof(path2) ||
	    strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2)) >= sizeof(path2))
		errx(1, "path too long");
d266 4
d278 1
a278 1
	char path1[MAXPATHLEN], path2[MAXPATHLEN];
d320 1
a320 3
	if (strlcpy(path1, rcs_tmpdir, sizeof(path1)) >= sizeof(path1) ||
	    strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1)) >= sizeof(path1))
		errx(1, "path too long");
d329 1
a329 3
	if (strlcpy(path2, rcs_tmpdir, sizeof(path2)) >= sizeof(path2) ||
	    strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2)) >= sizeof(path2))
		errx(1, "path too long");
d346 4
@


1.58
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.57 2006/04/26 02:55:13 joris Exp $	*/
d50 2
a51 1
	strlcpy(diffargs, "diff", sizeof(diffargs));
d56 3
a58 1
			strlcat(diffargs, " -c", sizeof(diffargs));
d70 3
a72 1
			strlcat(diffargs, " -n", sizeof(diffargs));
a77 4
		case 'u':
			strlcat(diffargs, " -u", sizeof(diffargs));
			diff_format = D_UNIFIED;
			break;
d86 6
d238 3
a240 2
	strlcpy(path1, rcs_tmpdir, sizeof(path1));
	strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1));
d249 3
a251 2
	strlcpy(path2, rcs_tmpdir, sizeof(path2));
	strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2));
d320 3
a322 2
	strlcpy(path1, rcs_tmpdir, sizeof(path1));
	strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1));
d331 3
a333 2
	strlcpy(path2, rcs_tmpdir, sizeof(path2));
	strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2));
@


1.57
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.56 2006/04/25 13:36:35 xsa Exp $	*/
d41 1
a41 1
	int i, ch, status;
d112 2
a113 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath), flags) < 0)
d116 2
a117 1
		if ((file = rcs_open(fpath, RCS_READ|RCS_PARSE_FULLY)) == NULL)
d178 1
a178 1
	int ret;
d180 1
a184 1
	struct stat st;
d196 1
a196 1
	if (stat(filename, &st) == -1) {
d222 3
d255 2
@


1.56
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.55 2006/04/24 08:40:01 jmc Exp $	*/
d214 1
a214 1
	if ((b2 = cvs_buf_load(filename, BUF_AUTOEXT)) == NULL) {
d228 1
a228 1
	cvs_buf_write_stmp(b1, path1, 0600);
d230 1
a230 1
	cvs_buf_free(b1);
d238 1
a238 1
	cvs_buf_write_stmp(b2, path2, 0600);
d240 1
a240 1
	cvs_buf_free(b2);
d246 1
a246 1
	cvs_diffreg(path1, path2, NULL);
d251 1
a251 1
		cvs_buf_free(b1);
d253 1
a253 1
		cvs_buf_free(b2);
d306 1
a306 1
	cvs_buf_write_stmp(b1, path1, 0600);
d308 1
a308 1
	cvs_buf_free(b1);
d316 1
a316 1
	cvs_buf_write_stmp(b2, path2, 0600);
d318 1
a318 1
	cvs_buf_free(b2);
d324 1
a324 1
	cvs_diffreg(path1, path2, NULL);
d329 1
a329 1
		cvs_buf_free(b1);
d331 1
a331 1
		cvs_buf_free(b2);
@


1.55
log
@make the -r description match that in rcsmerge(1), as far as is possible;
ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.54 2006/04/24 08:10:41 xsa Exp $	*/
d122 1
a122 1
				fatal("bad revision number");
d126 1
a126 1
				fatal("bad revision number");
@


1.54
log
@be consistent in error messages for wrongly specified keyword substitution
mode for `-k'.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.53 2006/04/21 17:17:29 xsa Exp $	*/
d169 1
a169 1
	    "usage: rcsdiff [-cnquV] [-kmode] [-rrev1 [-rrev2]] "
@


1.53
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.52 2006/04/21 14:18:26 xsa Exp $	*/
d61 1
a61 1
				warnx("invalid RCS keyword expansion mode");
@


1.52
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.51 2006/04/19 06:53:41 xsa Exp $	*/
d112 1
a112 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
@


1.51
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.50 2006/04/14 23:32:01 deraadt Exp $	*/
d61 1
a61 2
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
d106 1
a106 1
		cvs_log(LP_ERR, "no input file");
d195 1
a195 1
		cvs_log(LP_ERRNO, "%s", filename);
d206 1
a206 1
		cvs_log(LP_ERR, "failed to retrieve revision %s", rbuf);
d215 1
a215 1
		cvs_log(LP_ERR, "failed to load file: '%s'", filename);
d234 1
a234 1
		cvs_log(LP_ERRNO, "error setting utimes");
d244 1
a244 1
		cvs_log(LP_ERRNO, "error setting utimes");
d280 1
a280 1
		cvs_log(LP_ERR, "failed to retrieve revision %s", rbuf1);
d293 1
a293 1
		cvs_log(LP_ERR, "failed to retrieve revision %s", rbuf2);
d312 1
a312 1
		cvs_log(LP_ERRNO, "error setting utimes");
d322 1
a322 1
		cvs_log(LP_ERRNO, "error setting utimes");
@


1.50
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.49 2006/04/14 23:29:01 joris Exp $	*/
d35 1
d72 1
a72 1
			verbose = 0;
d130 1
a130 1
		if (verbose == 1) {
d201 1
a201 1
	if (verbose == 1) {
d277 1
a277 1
	if (verbose == 1)
d290 1
a290 1
	if (verbose == 1)
d302 1
a302 1
	if (verbose == 1)
@


1.49
log
@- don't append the extension if it's already there (PR 5076).
- show magic branches in rlog (thanks for that nicer hack niall).
- correct output in rcsdiff, so we perfectly match gnu's

all these bugs were found by sturm@@ while he was using cvsweb
(which uses the RCS tools).

"it is in my view that you should put it in" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.48 2006/04/13 16:10:29 joris Exp $	*/
d224 1
a224 1
	tv2[1].tv_sec = t; 
@


1.48
log
@clean up temporary files when we finish running.
"cool" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.47 2006/04/13 00:58:25 ray Exp $	*/
d177 1
d181 1
d184 1
d191 3
d219 6
a224 2
	tv2[0].tv_sec = st.st_mtime;
	tv2[1].tv_sec = st.st_mtime;
d272 3
d277 1
a277 1
		printf("retrieving revision %s\n", rbuf1);
@


1.47
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.46 2006/04/12 08:23:30 ray Exp $	*/
a239 2
	cvs_worklist_run(&rcs_temp_files, cvs_worklist_unlink);

a314 2
	cvs_worklist_run(&rcs_temp_files, cvs_worklist_unlink);

@


1.46
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.45 2006/04/10 19:49:45 joris Exp $	*/
d121 1
a121 1
			if ((rev1 = rcsnum_parse(rev_str1)) == NULL)
d125 1
a125 1
			if ((rev2 = rcsnum_parse(rev_str2)) == NULL)
@


1.45
log
@make sure we add the correct name mkstemp(3) creates for us
to the worklist of temporary files.

this way we definatly don't leave any files behind in /tmp.

tested & okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.44 2006/04/10 08:08:00 xsa Exp $	*/
d41 1
a41 1
	RCSNUM *rev, *rev2, *frev;
d43 1
a43 1
	char fpath[MAXPATHLEN];
d45 2
a46 2
	rev = RCS_HEAD_REV;
	rev2 = NULL;
d78 1
a78 7
			if (rev == RCS_HEAD_REV) {
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL)
					fatal("bad revision number");
			} else {
				if ((rev2 = rcsnum_parse(rcs_optarg)) == NULL)
					fatal("bad revision number");
			}
d120 8
a127 4
		if (rev == RCS_HEAD_REV)
			frev = file->rf_head;
		else
			frev = rev;
d136 3
a138 3
		if (rev2 == NULL) {
			if (rcsdiff_file(file, frev, argv[i]) < 0) {
				rcs_close(file);
d140 5
a144 2
				continue;
			}
d146 1
a146 2
			if (rcsdiff_rev(file, rev, rev2) < 0) {
				rcs_close(file);
a147 2
				continue;
			}
d151 9
@


1.44
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.43 2006/04/06 10:13:00 xsa Exp $	*/
a210 2

	cvs_worklist_add(path1, &rcs_temp_files);
a220 2

	cvs_worklist_add(path2, &rcs_temp_files);
a287 2

	cvs_worklist_add(path1, &rcs_temp_files);
a297 2

	cvs_worklist_add(path2, &rcs_temp_files);
@


1.43
log
@-z can take no argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.42 2006/03/30 23:19:20 joris Exp $	*/
d124 1
a124 2
		if (kflag != RCS_KWEXP_ERR)
			rcs_kwexp_set(file, kflag);
@


1.42
log
@add temporary files to the worklist before creating them, this prevents
a race when the user would interrupt the program when it was returning
from cvs_buf_write_stmp() and leave the temporary files behind.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.41 2006/03/24 05:14:48 ray Exp $	*/
d51 1
a51 1
	while ((ch = rcs_getopt(argc, argv, "ck:nqr:TuVx::z:")) != -1) {
@


1.41
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.40 2006/03/20 16:18:13 niallo Exp $	*/
d212 2
a215 1
	cvs_worklist_add(path1, &rcs_temp_files);
d224 2
a227 1
	cvs_worklist_add(path2, &rcs_temp_files);
d293 2
a296 1
	cvs_worklist_add(path1, &rcs_temp_files);
d305 2
a308 1
	cvs_worklist_add(path2, &rcs_temp_files);
@


1.40
log
@delint; cvs_buf_write_stmp() will never return non-zero:

- remove superfluous error handling for cvs_buf_write_stmp()
- change cvs_buf_write_stmp() return type to void

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.39 2006/03/16 04:04:57 ray Exp $	*/
d51 1
a51 1
	while ((ch = rcs_getopt(argc, argv, "ck:nqr:TuVx:z:")) != -1) {
d96 2
a97 1
			rcs_suffixes = rcs_optarg;
@


1.39
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.38 2006/03/15 21:20:57 niallo Exp $	*/
d211 1
a211 2
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1)
		goto out;
d222 1
a222 2
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1)
		goto out;
d290 1
a290 2
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1)
		goto out;
d301 1
a301 2
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1)
		goto out;
@


1.38
log
@- zap filename arg in rcsdiff_rev() since its not used.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.37 2006/03/08 20:19:39 joris Exp $	*/
d94 1
@


1.37
log
@make openrcs use the worklist framework to keep track of temporary files
and remove them in case it gets interrupted.

suggested by deraadt@@, ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.36 2006/03/07 01:40:52 joris Exp $	*/
d33 1
a33 1
static int rcsdiff_rev(RCSFILE *, RCSNUM *, RCSNUM *, const char *);
d144 1
a144 1
			if (rcsdiff_rev(file, rev, rev2, argv[i]) < 0) {
d247 1
a247 1
rcsdiff_rev(RCSFILE *file, RCSNUM *rev1, RCSNUM *rev2, const char *filename)
@


1.36
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.35 2006/03/06 15:00:21 jmc Exp $	*/
d168 1
d177 3
d182 1
a182 1
		return (-1);
d193 1
a193 1
		return (-1);
d195 1
d202 1
a202 2
		cvs_buf_free(b1);
		return (-1);
d204 1
d210 4
a213 6
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1) {
		cvs_log(LP_ERRNO, "could not write temporary file");
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		return (-1);
	}
d215 2
d222 4
a225 5
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1) {
		cvs_buf_free(b2);
		(void)unlink(path1);
		return (-1);
	}
d227 2
d233 4
a236 2
	(void)unlink(path1);
	(void)unlink(path2);
d238 6
a243 1
	return (0);
d249 1
d255 2
d266 1
a266 1
		return (-1);
d268 1
d279 1
a279 1
		return (-1);
d281 1
d291 4
a294 6
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1) {
		cvs_log(LP_ERRNO, "could not write temporary file");
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		return (-1);
	}
d296 2
d303 4
a306 5
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1) {
		cvs_buf_free(b2);
		(void)unlink(path1);
		return (-1);
	}
d308 1
d314 9
a322 2
	(void)unlink(path1);
	(void)unlink(path2);
d324 1
a324 1
	return (0);
@


1.35
log
@update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.34 2006/03/06 14:41:04 jmc Exp $	*/
d51 1
a51 1
	while ((ch = rcs_getopt(argc, argv, "ck:nqr:TuVx:")) != -1) {
d96 3
@


1.34
log
@move compat flags into a STANDARDS section;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.33 2006/03/06 09:59:22 xsa Exp $	*/
d159 1
a159 1
	    "[-xsuffixes] file ...\n");
@


1.33
log
@fix output to mimic gnu/usr.bin/rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.32 2006/03/06 09:41:53 deraadt Exp $	*/
d158 1
a158 1
	    "usage: rcsdiff [-cnqTuV] [-kmode] [-rrev1 [-rrev2]] "
@


1.32
log
@many spacing cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.31 2006/03/05 14:23:07 niallo Exp $	*/
d266 1
a266 2
		fprintf(stderr,
		    "%s -r%s -r%s %s\n", diffargs, rbuf1, rbuf2, filename);
@


1.31
log
@now that rcs_getrev() isn't doing keyword expansion anymore and rcsdiff(1)
expects to be comparing files with expanded keywords, we need to add
a couple of calls to rcs_kwexp_buf() to rcsdiff.c.  two minor output
fixes in this diff also.

ok xsa@@ eyeballed by Rai Lai
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.30 2006/01/05 10:28:24 xsa Exp $	*/
d292 1
a292 1
	
@


1.30
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.29 2006/01/02 08:13:28 xsa Exp $	*/
d185 1
a185 1
		cvs_log(LP_ERR, "failed to retrieve revision");
d188 1
d246 1
a246 1
		cvs_log(LP_ERR, "failed to retrieve revision");
d249 1
d258 1
a258 1
		cvs_log(LP_ERR, "failed to retrieve revision");
d261 1
@


1.29
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.28 2005/12/27 16:05:21 niallo Exp $	*/
d29 1
a29 2
#include "log.h"
#include "rcs.h"
a30 1
#include "rcsprog.h"
@


1.28
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.27 2005/12/20 09:04:17 xsa Exp $	*/
d27 1
a27 7
#include <sys/param.h>
#include <sys/stat.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.27
log
@spread the use of fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.26 2005/12/10 19:44:36 niallo Exp $	*/
d124 1
a124 1
		if ((file = rcs_open(fpath, RCS_READ)) == NULL)
@


1.26
log
@- its wrong to use exit() here; return instead.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.25 2005/12/05 14:47:24 xsa Exp $	*/
d87 2
a88 4
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
d90 2
a91 4
				if ((rev2 = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
@


1.25
log
@kill unused var;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.24 2005/12/01 23:02:27 niallo Exp $	*/
d163 1
a163 1
	exit(status);
@


1.24
log
@- fix up context and unified diff output in both open rcs and open cvs so
that the date is set correctly.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.23 2005/11/29 11:11:39 xsa Exp $	*/
d48 1
a48 1
	int i, ch, flags, status;
a52 1
	flags = 0;
@


1.23
log
@consistency in variables naming;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.22 2005/11/28 14:43:59 xsa Exp $	*/
d182 3
d201 2
d209 2
d221 2
d232 2
d248 4
d261 2
d272 2
d288 2
d300 3
@


1.22
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.21 2005/11/28 10:17:20 xsa Exp $	*/
d176 1
a176 1
rcsdiff_file(RCSFILE *rfp, RCSNUM *rev, const char *filename)
d194 1
a194 1
	if ((b1 = rcs_getrev(rfp, rev)) == NULL) {
d232 1
a232 1
rcsdiff_rev(RCSFILE *rfp, RCSNUM *rev1, RCSNUM *rev2, const char *filename)
d242 1
a242 1
	if ((b1 = rcs_getrev(rfp, rev1)) == NULL) {
d251 1
a251 1
	if ((b2 = rcs_getrev(rfp, rev2)) == NULL) {
@


1.21
log
@-T is here for compatibility;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.20 2005/11/25 15:56:10 xsa Exp $	*/
d171 2
a172 1
	    "usage: rcsdiff [-cnquV] [-kmode] [-rrev1 [-rrev2]] file ...\n");
@


1.20
log
@add support for `-kmode';
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.19 2005/11/23 09:39:20 xsa Exp $	*/
d100 3
a102 1
			flags |= PRESERVETIME;
@


1.19
log
@initial bits for -T support;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.18 2005/11/22 15:00:06 xsa Exp $	*/
d129 3
@


1.18
log
@- print to stderr in some cases
- few bits for `-kmode'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.17 2005/11/21 16:20:29 xsa Exp $	*/
d48 1
a48 1
	int i, ch, status;
d53 1
d60 1
a60 1
	while ((ch = rcs_getopt(argc, argv, "ck:nqr:uVx:")) != -1) {
d98 3
@


1.17
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.16 2005/11/21 15:01:10 xsa Exp $	*/
d43 2
d59 1
a59 1
	while ((ch = rcs_getopt(argc, argv, "cnqr:uVx:")) != -1) {
d65 9
d132 2
a133 2
			printf("%s\n", RCS_DIFF_DIV);
			printf("RCS file: %s\n", fpath);
d162 1
a162 1
	    "usage: rcsdiff [-cnquV] [-rrev1 [-rrev2]] file ...\n");
d180 2
a181 2
		printf("retrieving revision %s\n", rbuf);
		printf("%s -r%s %s\n", diffargs, rbuf, filename);
d239 1
a239 1
		printf("retrieving revision %s\n", rbuf2);
d247 2
a248 1
		printf("%s -r%s -r%s %s\n", diffargs, rbuf1, rbuf2, filename);
@


1.16
log
@- print some more informative messages
- minor knf
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.15 2005/11/16 09:57:04 xsa Exp $	*/
d57 1
a57 1
	while ((ch = rcs_getopt(argc, argv, "cnqr:uV")) != -1) {
a73 3
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
d86 6
@


1.15
log
@- add file existence check
- do not pollute with uneeded error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.14 2005/11/14 11:01:04 xsa Exp $	*/
d41 1
a41 1
static int rcsdiff_rev(RCSFILE *rfp, RCSNUM *rev, RCSNUM *rev2);
d55 2
d60 1
d64 1
d71 1
d118 2
a119 2
			cvs_printf("%s\n", RCS_DIFF_DIV);
			cvs_printf("RCS file: %s\n", fpath);
d131 1
a131 1
			if (rcsdiff_rev(file, rev, rev2) < 0) {
d165 1
a165 1
	if (verbose == 1)
d167 2
d208 1
a208 1
rcsdiff_rev(RCSFILE *rfp, RCSNUM *rev1, RCSNUM *rev2)
d212 1
a212 1
	char rbuf[64];
d214 1
a214 1
	rcsnum_tostr(rev1, rbuf, sizeof(rbuf));
d216 1
a216 1
		printf("retrieving revision %s\n", rbuf);
d223 1
a223 1
	rcsnum_tostr(rev2, rbuf, sizeof(rbuf));
d225 1
a225 1
		printf("retrieving revision %s\n", rbuf);
d231 3
@


1.14
log
@print RCS file path;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.13 2005/10/27 07:43:56 xsa Exp $	*/
a120 1
				cvs_log(LP_ERR, "failed to rcsdiff");
a126 1
				cvs_log(LP_ERR, "failed to rcsdiff");
d152 6
@


1.13
log
@TMPDIR support; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.12 2005/10/16 12:03:09 niallo Exp $	*/
a100 3
		if (verbose == 1)
			cvs_printf("%s\n", RCS_DIFF_DIV);

d111 5
@


1.12
log
@- sync rcsdiff_usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.11 2005/10/13 12:35:30 joris Exp $	*/
d168 2
a169 1
	strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1));
d178 2
a179 1
	strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2));
d219 2
a220 1
	strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1));
d229 2
a230 1
	strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2));
@


1.11
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.10 2005/10/12 17:43:18 xsa Exp $	*/
d143 1
a143 1
	    "usage: rcsdiff [-cnquV] [-r rev1 [-r rev2]] file ...\n");
@


1.10
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.9 2005/10/12 17:13:30 deraadt Exp $	*/
d55 1
a55 1
	while ((ch = getopt(argc, argv, "cnqr:uV")) != -1) {
d74 1
a74 1
				if ((rev = rcsnum_parse(optarg)) == NULL) {
d79 1
a79 1
				if ((rev2 = rcsnum_parse(optarg)) == NULL) {
d86 2
a87 1
			break;
d91 2
a92 2
	argc -= optind;
	argv += optind;
@


1.9
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.8 2005/10/11 14:27:59 joris Exp $	*/
d100 1
a100 1
		if (verbose)
d153 1
a153 1
	if (verbose)
d199 1
a199 1
	if (verbose)
d208 1
a208 1
	if (verbose)
@


1.8
log
@correctly set the filename by setting the diff_file variable;
fixes the (null) stuff seen when using rcsdiff;

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.7 2005/10/09 20:55:27 niallo Exp $	*/
a39 2
extern char *__progname;

d141 2
a142 2
	fprintf(stderr, "usage %s [-cnquV] [-r rev1 [-r rev2]] file ...\n",
	    __progname);
@


1.7
log
@if there is a problem generating the diff for one of the files, continue
to process other files but eventually exit with status 2. this mimics
GNU rcs behaviour.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.6 2005/10/08 20:30:39 niallo Exp $	*/
d115 2
@


1.6
log
@sync rcsdiff_usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.5 2005/10/08 20:03:36 joris Exp $	*/
d48 1
a48 1
	int i, ch;
d55 1
d120 1
d127 1
d135 1
a135 1
	return (0);
@


1.5
log
@kill extra ']'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.4 2005/10/08 19:58:04 niallo Exp $	*/
d138 1
a138 1
	fprintf(stderr, "usage %s [-qV] [-r rev1 [-r rev2] file ...\n",
@


1.4
log
@- add support for diffing working file against arbitrary revision, eg
  rcsdiff -r1.1 <file>

- add support for diffing arbitrary revision against arbitrary revision, eg
  rcsdiff -r1.1 -r1.3 <file>

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.3 2005/10/08 19:20:49 joris Exp $	*/
d138 1
a138 1
	fprintf(stderr, "usage %s [-qV] [-r rev1 [-r rev2]] file ...\n",
@


1.3
log
@support unified, context and rcsdiff output
(-u -c -n flags)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.2 2005/10/07 23:59:56 niallo Exp $	*/
d41 1
d43 1
d49 1
a49 1
	RCSNUM *rev, *frev;
d54 1
d56 1
a56 1
	while ((ch = getopt(argc, argv, "cnquV")) != -1) {
d73 13
d115 12
a126 4
		if (rcsdiff_file(file, frev, argv[i]) < 0) {
			cvs_log(LP_ERR, "failed to rcsdiff");
			rcs_close(file);
			continue;
d138 2
a139 1
	fprintf(stderr, "usage %s [-qV] file ...\n", __progname);
d161 49
@


1.2
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.1 2005/10/06 01:24:25 joris Exp $	*/
d53 1
a53 1
	while ((ch = getopt(argc, argv, "qV")) != -1) {
d55 6
d63 3
@


1.1
log
@thanks to niallo's diff changes, we now can support rcsdiff;
only basic stuff works, more coming;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.7 2005/10/05 12:06:23 joris Exp $	*/
a34 1
#include "diff.h"
d37 1
d147 1
a147 1
	cvs_diffreg(path1, path2);
@

