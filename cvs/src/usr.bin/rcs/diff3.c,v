head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.2
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.4
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.12
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.10
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.6
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14;
locks; strict;
comment	@ * @;


1.41
date	2016.10.18.21.06.52;	author millert;	state Exp;
branches;
next	1.40;
commitid	foVrnyJsePU0nPEu;

1.40
date	2016.10.16.13.35.51;	author okan;	state Exp;
branches;
next	1.39;
commitid	RkkF6LzZj7gdsaWi;

1.39
date	2016.08.26.09.02.54;	author guenther;	state Exp;
branches;
next	1.38;
commitid	07zudOJ8CxdoPUjD;

1.38
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.37;
commitid	aZp5pu4rATnp3dyP;

1.37
date	2015.09.05.09.47.08;	author jsg;	state Exp;
branches;
next	1.36;
commitid	AWjHn4VUyqwdq4dE;

1.36
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.35;
commitid	FFUg8uzT5GNAfRXp;

1.35
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	Uu5nFG3wCl0LACBb;

1.34
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	Z3HC5pAWzpo5jsTe;

1.33
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.20.19.34.16;	author nicm;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.25.23.16.20;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.02.19.40.58;	author tobias;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.23.01.15.12;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.10.14.29.53;	author tobias;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.03.00.56.23;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.22.08.30.45;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.11.18.13.33;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.02.16.43.45;	author niallo;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.24.06.22.53;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.21.15.30.07;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.11.08.18.19;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.08.10.22.01;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.07.20.55.28;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.15.06.58.03;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.10.01.10.23;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.08.16.56.40;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.08.10.19.34;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.04.07.06.58;	author xsa;	state Exp;
branches;
next	1.4;

1.4
date	2006.05.03.07.10.39;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.27.07.59.33;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Using bitwise OR along with two assignments in the conditional of
a while() loop is a trap for the unwary programmer (albeit a clever
trap).  Break this up into two separate assignments and using boolean
OR for clarity.  OK otto@@
@
text
@/*	$OpenBSD: diff3.c,v 1.40 2016/10/16 13:35:51 okan Exp $	*/

/*
 * Copyright (C) Caldera International Inc.  2001-2002.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code and documentation must retain the above
 *    copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed or owned by Caldera
 *	International, Inc.
 * 4. Neither the name of Caldera International, Inc. nor the names of other
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
 * INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
 * INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)diff3.c	8.1 (Berkeley) 6/6/93
 */

#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "diff.h"
#include "rcsprog.h"

/* diff3 - 3-way differential file comparison */

/* diff3 [-ex3EX] d13 d23 f1 f2 f3 [m1 m3]
 *
 * d13 = diff report on f1 vs f3
 * d23 = diff report on f2 vs f3
 * f1, f2, f3 the 3 files
 * if changes in f1 overlap with changes in f3, m1 and m3 are used
 * to mark the overlaps; otherwise, the file names f1 and f3 are used
 * (only for options E and X).
 */

/*
 * "from" is first in range of changed lines; "to" is last+1
 * from=to=line after point of insertion for added lines.
 */
struct range {
	int from;
	int to;
};

struct diff {
	struct range old;
	struct range new;
};

static size_t szchanges;

static struct diff *d13;
static struct diff *d23;

/*
 * "de" is used to gather editing scripts.  These are later spewed out in
 * reverse order.  Its first element must be all zero, the "new" component
 * of "de" contains line positions or byte positions depending on when you
 * look (!?).  Array overlap indicates which sections in "de" correspond to
 * lines that are different in all three files.
 */
static struct diff *de;
static char *overlap;
static int overlapcnt = 0;
static FILE *fp[3];
static int cline[3];		/* # of the last-read line in each file (0-2) */

/*
 * the latest known correspondence between line numbers of the 3 files
 * is stored in last[1-3];
 */
static int last[4];
static int eflag = 3;	/* default -E for compatibility with former RCS */
static int oflag = 1;	/* default -E for compatibility with former RCS */
static int debug  = 0;
static char f1mark[PATH_MAX], f3mark[PATH_MAX];	/* markers for -E and -X */

static int duplicate(struct range *, struct range *);
static int edit(struct diff *, int, int);
static char *getchange(FILE *);
static char *get_line(FILE *, size_t *);
static int number(char **);
static ssize_t readin(char *, struct diff **);
static int skip(int, int, char *);
static int edscript(int);
static int merge(size_t, size_t);
static void change(int, struct range *, int);
static void keep(int, struct range *);
static void prange(struct range *);
static void repos(int);
static void separate(const char *);
static void increase(void);
static int diff3_internal(int, char **, const char *, const char *);

int diff3_conflicts = 0;

/*
 * For merge(1).
 */
BUF *
merge_diff3(char **av, int flags)
{
	int argc;
	char *argv[5], *dp13, *dp23, *path1, *path2, *path3;
	BUF *b1, *b2, *b3, *d1, *d2, *diffb;
	u_char *data, *patch;
	size_t dlen, plen;

	b1 = b2 = b3 = d1 = d2 = diffb = NULL;
	dp13 = dp23 = path1 = path2 = path3 = NULL;
	data = patch = NULL;

	if ((flags & MERGE_EFLAG) && !(flags & MERGE_OFLAG))
		oflag = 0;

	if ((b1 = buf_load(av[0])) == NULL)
		goto out;
	if ((b2 = buf_load(av[1])) == NULL)
		goto out;
	if ((b3 = buf_load(av[2])) == NULL)
		goto out;

	d1 = buf_alloc(128);
	d2 = buf_alloc(128);
	diffb = buf_alloc(128);

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
	(void)xasprintf(&path3, "%s/diff3.XXXXXXXXXX", rcs_tmpdir);

	buf_write_stmp(b1, path1);
	buf_write_stmp(b2, path2);
	buf_write_stmp(b3, path3);

	buf_free(b2);
	b2 = NULL;

	if ((diffreg(path1, path3, d1, D_FORCEASCII) == D_ERROR) ||
	    (diffreg(path2, path3, d2, D_FORCEASCII) == D_ERROR)) {
		buf_free(diffb);
		diffb = NULL;
		goto out;
	}

	(void)xasprintf(&dp13, "%s/d13.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(d1, dp13);

	buf_free(d1);
	d1 = NULL;

	(void)xasprintf(&dp23, "%s/d23.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(d2, dp23);

	buf_free(d2);
	d2 = NULL;

	argc = 0;
	diffbuf = diffb;
	argv[argc++] = dp13;
	argv[argc++] = dp23;
	argv[argc++] = path1;
	argv[argc++] = path2;
	argv[argc++] = path3;

	diff3_conflicts = diff3_internal(argc, argv, av[0], av[2]);
	if (diff3_conflicts < 0) {
		buf_free(diffb);
		diffb = NULL;
		goto out;
	}

	plen = buf_len(diffb);
	patch = buf_release(diffb);
	dlen = buf_len(b1);
	data = buf_release(b1);

	if ((diffb = rcs_patchfile(data, dlen, patch, plen, ed_patch_lines)) == NULL)
		goto out;

	if (!(flags & QUIET) && diff3_conflicts != 0)
		warnx("warning: overlaps or other problems during merge");

out:
	buf_free(b2);
	buf_free(b3);
	buf_free(d1);
	buf_free(d2);

	(void)unlink(path1);
	(void)unlink(path2);
	(void)unlink(path3);
	(void)unlink(dp13);
	(void)unlink(dp23);

	free(path1);
	free(path2);
	free(path3);
	free(dp13);
	free(dp23);
	free(data);
	free(patch);

	return (diffb);
}

BUF *
rcs_diff3(RCSFILE *rf, char *workfile, RCSNUM *rev1, RCSNUM *rev2, int flags)
{
	int argc;
	char *argv[5], r1[RCS_REV_BUFSZ], r2[RCS_REV_BUFSZ];
	char *dp13, *dp23, *path1, *path2, *path3;
	BUF *b1, *b2, *b3, *d1, *d2, *diffb;
	size_t dlen, plen;
	u_char *data, *patch;

	b1 = b2 = b3 = d1 = d2 = diffb = NULL;
	dp13 = dp23 = path1 = path2 = path3 = NULL;
	data = patch = NULL;

	if ((flags & MERGE_EFLAG) && !(flags & MERGE_OFLAG))
		oflag = 0;

	rcsnum_tostr(rev1, r1, sizeof(r1));
	rcsnum_tostr(rev2, r2, sizeof(r2));

	if ((b1 = buf_load(workfile)) == NULL)
		goto out;

	if (!(flags & QUIET))
		(void)fprintf(stderr, "retrieving revision %s\n", r1);
	if ((b2 = rcs_getrev(rf, rev1)) == NULL)
		goto out;

	if (!(flags & QUIET))
		(void)fprintf(stderr, "retrieving revision %s\n", r2);
	if ((b3 = rcs_getrev(rf, rev2)) == NULL)
		goto out;

	d1 = buf_alloc(128);
	d2 = buf_alloc(128);
	diffb = buf_alloc(128);

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
	(void)xasprintf(&path3, "%s/diff3.XXXXXXXXXX", rcs_tmpdir);

	buf_write_stmp(b1, path1);
	buf_write_stmp(b2, path2);
	buf_write_stmp(b3, path3);

	buf_free(b2);
	b2 = NULL;

	if ((diffreg(path1, path3, d1, D_FORCEASCII) == D_ERROR) ||
	    (diffreg(path2, path3, d2, D_FORCEASCII) == D_ERROR)) {
		buf_free(diffb);
		diffb = NULL;
		goto out;
	}

	(void)xasprintf(&dp13, "%s/d13.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(d1, dp13);

	buf_free(d1);
	d1 = NULL;

	(void)xasprintf(&dp23, "%s/d23.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(d2, dp23);

	buf_free(d2);
	d2 = NULL;

	argc = 0;
	diffbuf = diffb;
	argv[argc++] = dp13;
	argv[argc++] = dp23;
	argv[argc++] = path1;
	argv[argc++] = path2;
	argv[argc++] = path3;

	diff3_conflicts = diff3_internal(argc, argv, workfile, r2);
	if (diff3_conflicts < 0) {
		buf_free(diffb);
		diffb = NULL;
		goto out;
	}

	plen = buf_len(diffb);
	patch = buf_release(diffb);
	dlen = buf_len(b1);
	data = buf_release(b1);

	if ((diffb = rcs_patchfile(data, dlen, patch, plen, ed_patch_lines)) == NULL)
		goto out;

	if (!(flags & QUIET) && diff3_conflicts != 0)
		warnx("warning: overlaps or other problems during merge");

out:
	buf_free(b2);
	buf_free(b3);
	buf_free(d1);
	buf_free(d2);

	(void)unlink(path1);
	(void)unlink(path2);
	(void)unlink(path3);
	(void)unlink(dp13);
	(void)unlink(dp23);

	free(path1);
	free(path2);
	free(path3);
	free(dp13);
	free(dp23);
	free(data);
	free(patch);

	return (diffb);
}

static int
diff3_internal(int argc, char **argv, const char *fmark, const char *rmark)
{
	ssize_t m, n;
	int i;

	if (argc < 5)
		return (-1);

	if (oflag) {
		i = snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s", fmark);
		if (i < 0 || i >= (int)sizeof(f1mark))
			errx(1, "diff3_internal: string truncated");

		i = snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s", rmark);
		if (i < 0 || i >= (int)sizeof(f3mark))
			errx(1, "diff3_internal: string truncated");
	}

	increase();
	if ((m = readin(argv[0], &d13)) < 0) {
		warn("%s", argv[0]);
		return (-1);
	}
	if ((n = readin(argv[1], &d23)) < 0) {
		warn("%s", argv[1]);
		return (-1);
	}

	for (i = 0; i <= 2; i++)
		if ((fp[i] = fopen(argv[i + 2], "r")) == NULL) {
			warn("%s", argv[i + 2]);
			return (-1);
		}

	return (merge(m, n));
}

int
ed_patch_lines(struct rcs_lines *dlines, struct rcs_lines *plines)
{
	char op, *ep;
	struct rcs_line *sort, *lp, *dlp, *ndlp, *insert_after;
	int start, end, i, lineno;
	u_char tmp;

	dlp = TAILQ_FIRST(&(dlines->l_lines));
	lp = TAILQ_FIRST(&(plines->l_lines));

	end = 0;
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, l_list)) {
		/* Skip blank lines */
		if (lp->l_len < 2)
			continue;

		/* NUL-terminate line buffer for strtol() safety. */
		tmp = lp->l_line[lp->l_len - 1];
		lp->l_line[lp->l_len - 1] = '\0';

		/* len - 1 is NUL terminator so we use len - 2 for 'op' */
		op = lp->l_line[lp->l_len - 2];
		start = (int)strtol(lp->l_line, &ep, 10);

		/* Restore the last byte of the buffer */
		lp->l_line[lp->l_len - 1] = tmp;

		if (op == 'a') {
			if (start > dlines->l_nblines ||
			    start < 0 || *ep != 'a')
				errx(1, "ed_patch_lines");
		} else if (op == 'c') {
			if (start > dlines->l_nblines ||
			    start < 0 || (*ep != ',' && *ep != 'c'))
				errx(1, "ed_patch_lines");

			if (*ep == ',') {
				ep++;
				end = (int)strtol(ep, &ep, 10);
				if (end < 0 || *ep != 'c')
					errx(1, "ed_patch_lines");
			} else {
				end = start;
			}
		}


		for (;;) {
			if (dlp == NULL)
				break;
			if (dlp->l_lineno == start)
				break;
			if (dlp->l_lineno > start) {
				dlp = TAILQ_PREV(dlp, tqh, l_list);
			} else if (dlp->l_lineno < start) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				if (ndlp->l_lineno > start)
					break;
				dlp = ndlp;
			}
		}

		if (dlp == NULL)
			errx(1, "ed_patch_lines");


		if (op == 'c') {
			insert_after = TAILQ_PREV(dlp, tqh, l_list);
			for (i = 0; i <= (end - start); i++) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				TAILQ_REMOVE(&(dlines->l_lines), dlp, l_list);
				dlp = ndlp;
			}
			dlp = insert_after;
		}

		if (op == 'a' || op == 'c') {
			for (;;) {
				ndlp = lp;
				lp = TAILQ_NEXT(lp, l_list);
				if (lp == NULL)
					errx(1, "ed_patch_lines");

				if (!memcmp(lp->l_line, ".", 1))
					break;

				TAILQ_REMOVE(&(plines->l_lines), lp, l_list);
				TAILQ_INSERT_AFTER(&(dlines->l_lines), dlp,
				    lp, l_list);
				dlp = lp;

				lp->l_lineno = start;
				lp = ndlp;
			}
		}

		/*
		 * always resort lines as the markers might be put at the
		 * same line as we first started editing.
		 */
		lineno = 0;
		TAILQ_FOREACH(sort, &(dlines->l_lines), l_list)
			sort->l_lineno = lineno++;
		dlines->l_nblines = lineno - 1;
	}

	return (0);
}

/*
 * Pick up the line numbers of all changes from one change file.
 * (This puts the numbers in a vector, which is not strictly necessary,
 * since the vector is processed in one sequential pass.
 * The vector could be optimized out of existence)
 */
static ssize_t
readin(char *name, struct diff **dd)
{
	int a, b, c, d;
	char kind, *p;
	size_t i;

	fp[0] = fopen(name, "r");
	if (fp[0] == NULL)
		return (-1);
	for (i = 0; (p = getchange(fp[0])); i++) {
		if (i >= szchanges - 1)
			increase();
		a = b = number(&p);
		if (*p == ',') {
			p++;
			b = number(&p);
		}
		kind = *p++;
		c = d = number(&p);
		if (*p==',') {
			p++;
			d = number(&p);
		}
		if (kind == 'a')
			a++;
		if (kind == 'd')
			c++;
		b++;
		d++;
		(*dd)[i].old.from = a;
		(*dd)[i].old.to = b;
		(*dd)[i].new.from = c;
		(*dd)[i].new.to = d;
	}

	if (i) {
		(*dd)[i].old.from = (*dd)[i-1].old.to;
		(*dd)[i].new.from = (*dd)[i-1].new.to;
	}

	(void)fclose(fp[0]);

	return (i);
}

static int
number(char **lc)
{
	int nn;

	nn = 0;
	while (isdigit((unsigned char)(**lc)))
		nn = nn*10 + *(*lc)++ - '0';

	return (nn);
}

static char *
getchange(FILE *b)
{
	char *line;

	while ((line = get_line(b, NULL))) {
		if (isdigit((unsigned char)line[0]))
			return (line);
	}

	return (NULL);
}

static char *
get_line(FILE *b, size_t *n)
{
	char *cp;
	size_t len;
	static char *buf;
	static size_t bufsize;

	if ((cp = fgetln(b, &len)) == NULL)
		return (NULL);

	if (cp[len - 1] != '\n')
		len++;
	if (len + 1 > bufsize) {
		do {
			bufsize += 1024;
		} while (len + 1 > bufsize);
		buf = xreallocarray(buf, 1, bufsize);
	}
	memcpy(buf, cp, len - 1);
	buf[len - 1] = '\n';
	buf[len] = '\0';
	if (n != NULL)
		*n = len;

	return (buf);
}

static int
merge(size_t m1, size_t m2)
{
	struct diff *d1, *d2, *d3;
	int dpl, j, t1, t2;

	d1 = d13;
	d2 = d23;
	j = 0;
	for (;;) {
		t1 = (d1 < d13 + m1);
		t2 = (d2 < d23 + m2);
		if (!t1 && !t2)
			break;

		if (debug) {
			printf("%d,%d=%d,%d %d,%d=%d,%d\n",
			d1->old.from, d1->old.to,
			d1->new.from, d1->new.to,
			d2->old.from, d2->old.to,
			d2->new.from, d2->new.to);
		}

		/* first file is different from others */
		if (!t2 || (t1 && d1->new.to < d2->new.from)) {
			/* stuff peculiar to 1st file */
			if (eflag==0) {
				separate("1");
				change(1, &d1->old, 0);
				keep(2, &d1->new);
				change(3, &d1->new, 0);
			}
			d1++;
			continue;
		}

		/* second file is different from others */
		if (!t1 || (t2 && d2->new.to < d1->new.from)) {
			if (eflag==0) {
				separate("2");
				keep(1, &d2->new);
				change(2, &d2->old, 0);
				change(3, &d2->new, 0);
			}
			d2++;
			continue;
		}

		/*
		 * Merge overlapping changes in first file
		 * this happens after extension (see below).
		 */
		if (d1 + 1 < d13 + m1 && d1->new.to >= d1[1].new.from) {
			d1[1].old.from = d1->old.from;
			d1[1].new.from = d1->new.from;
			d1++;
			continue;
		}

		/* merge overlapping changes in second */
		if (d2 + 1 < d23 + m2 && d2->new.to >= d2[1].new.from) {
			d2[1].old.from = d2->old.from;
			d2[1].new.from = d2->new.from;
			d2++;
			continue;
		}
		/* stuff peculiar to third file or different in all */
		if (d1->new.from == d2->new.from && d1->new.to == d2->new.to) {
			dpl = duplicate(&d1->old,&d2->old);
			if (dpl == -1)
				return (-1);

			/*
			 * dpl = 0 means all files differ
			 * dpl = 1 means files 1 and 2 identical
			 */
			if (eflag==0) {
				separate(dpl ? "3" : "");
				change(1, &d1->old, dpl);
				change(2, &d2->old, 0);
				d3 = d1->old.to > d1->old.from ? d1 : d2;
				change(3, &d3->new, 0);
			} else
				j = edit(d1, dpl, j);
			d1++;
			d2++;
			continue;
		}

		/*
		 * Overlapping changes from file 1 and 2; extend changes
		 * appropriately to make them coincide.
		 */
		if (d1->new.from < d2->new.from) {
			d2->old.from -= d2->new.from-d1->new.from;
			d2->new.from = d1->new.from;
		} else if (d2->new.from < d1->new.from) {
			d1->old.from -= d1->new.from-d2->new.from;
			d1->new.from = d2->new.from;
		}
		if (d1->new.to > d2->new.to) {
			d2->old.to += d1->new.to - d2->new.to;
			d2->new.to = d1->new.to;
		} else if (d2->new.to > d1->new.to) {
			d1->old.to += d2->new.to - d1->new.to;
			d1->new.to = d2->new.to;
		}
	}

	return (edscript(j));
}

static void
separate(const char *s)
{
	diff_output("====%s\n", s);
}

/*
 * The range of lines rold.from thru rold.to in file i is to be changed.
 * It is to be printed only if it does not duplicate something to be
 * printed later.
 */
static void
change(int i, struct range *rold, int fdup)
{
	diff_output("%d:", i);
	last[i] = rold->to;
	prange(rold);
	if (fdup || debug)
		return;
	i--;
	(void)skip(i, rold->from, NULL);
	(void)skip(i, rold->to, "  ");
}

/*
 * print the range of line numbers, rold.from thru rold.to, as n1,n2 or n1
 */
static void
prange(struct range *rold)
{
	if (rold->to <= rold->from)
		diff_output("%da\n", rold->from - 1);
	else {
		diff_output("%d", rold->from);
		if (rold->to > rold->from+1)
			diff_output(",%d", rold->to - 1);
		diff_output("c\n");
	}
}

/*
 * No difference was reported by diff between file 1 (or 2) and file 3,
 * and an artificial dummy difference (trange) must be ginned up to
 * correspond to the change reported in the other file.
 */
static void
keep(int i, struct range *rnew)
{
	int delta;
	struct range trange;

	delta = last[3] - last[i];
	trange.from = rnew->from - delta;
	trange.to = rnew->to - delta;
	change(i, &trange, 1);
}

/*
 * skip to just before line number from in file "i".  If "pr" is non-NULL,
 * print all skipped stuff with string pr as a prefix.
 */
static int
skip(int i, int from, char *pr)
{
	size_t j, n;
	char *line;

	for (n = 0; cline[i] < from - 1; n += j) {
		if ((line = get_line(fp[i], &j)) == NULL)
			return (-1);
		if (pr != NULL)
			diff_output("%s%s", pr, line);
		cline[i]++;
	}
	return ((int) n);
}

/*
 * Return 1 or 0 according as the old range (in file 1) contains exactly
 * the same data as the new range (in file 2).
 */
static int
duplicate(struct range *r1, struct range *r2)
{
	int c,d;
	int nchar;
	int nline;

	if (r1->to-r1->from != r2->to-r2->from)
		return (0);
	(void)skip(0, r1->from, NULL);
	(void)skip(1, r2->from, NULL);
	nchar = 0;
	for (nline=0; nline < r1->to - r1->from; nline++) {
		do {
			c = getc(fp[0]);
			d = getc(fp[1]);
			if (c == -1 || d== -1)
				return (-1);
			nchar++;
			if (c != d) {
				repos(nchar);
				return (0);
			}
		} while (c != '\n');
	}
	repos(nchar);
	return (1);
}

static void
repos(int nchar)
{
	int i;

	for (i = 0; i < 2; i++)
		(void)fseek(fp[i], (long)-nchar, SEEK_CUR);
}

/*
 * collect an editing script for later regurgitation
 */
static int
edit(struct diff *diff, int fdup, int j)
{
	if (((fdup + 1) & eflag) == 0)
		return (j);
	j++;
	overlap[j] = !fdup;
	if (!fdup)
		overlapcnt++;
	de[j].old.from = diff->old.from;
	de[j].old.to = diff->old.to;
	de[j].new.from = de[j-1].new.to + skip(2, diff->new.from, NULL);
	de[j].new.to = de[j].new.from + skip(2, diff->new.to, NULL);
	return (j);
}

/* regurgitate */
static int
edscript(int n)
{
	int j, k;
	char block[BUFSIZ+1];

	for (; n > 0; n--) {
		if (!oflag || !overlap[n])
			prange(&de[n].old);
		else
			diff_output("%da\n=======\n", de[n].old.to -1);
		(void)fseek(fp[2], (long)de[n].new.from, SEEK_SET);
		for (k = de[n].new.to-de[n].new.from; k > 0; k-= j) {
			j = k > BUFSIZ ? BUFSIZ : k;
			if (fread(block, 1, j, fp[2]) != (size_t)j)
				return (-1);
			block[j] = '\0';
			diff_output("%s", block);
		}

		if (!oflag || !overlap[n])
			diff_output(".\n");
		else {
			diff_output("%s\n.\n", f3mark);
			diff_output("%da\n%s\n.\n", de[n].old.from - 1, f1mark);
		}
	}

	return (overlapcnt);
}

static void
increase(void)
{
	size_t newsz, incr;

	/* are the memset(3) calls needed? */
	newsz = szchanges == 0 ? 64 : 2 * szchanges;
	incr = newsz - szchanges;

	d13 = xreallocarray(d13, newsz, sizeof(*d13));
	memset(d13 + szchanges, 0, incr * sizeof(*d13));
	d23 = xreallocarray(d23, newsz, sizeof(*d23));
	memset(d23 + szchanges, 0, incr * sizeof(*d23));
	de = xreallocarray(de, newsz, sizeof(*de));
	memset(de + szchanges, 0, incr * sizeof(*de));
	overlap = xreallocarray(overlap, newsz, sizeof(*overlap));
	memset(overlap + szchanges, 0, incr * sizeof(*overlap));
	szchanges = newsz;
}
@


1.40
log
@Quiet compiler warnings; as applied to usr.bin/cvs by millert@@

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.39 2016/08/26 09:02:54 guenther Exp $	*/
d639 6
a644 1
	while ((t1 = (d1 < d13 + m1)) | (t2 = (d2 < d23 + m2))) {
@


1.39
log
@Pull in <time.h> for struct tm, used in rcs.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.38 2015/11/02 16:45:21 nicm Exp $	*/
d890 1
a890 1
			if (fread(block, 1, j, fp[2]) != j)
@


1.38
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.37 2015/09/05 09:47:08 jsg Exp $	*/
d72 1
@


1.37
log
@Add brackets to clarify assignments that are the result of a test operator.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.36 2015/06/13 20:15:21 nicm Exp $	*/
d237 4
a240 8
	if (b2 != NULL)
		buf_free(b2);
	if (b3 != NULL)
		buf_free(b3);
	if (d1 != NULL)
		buf_free(d1);
	if (d2 != NULL)
		buf_free(d2);
d353 4
a356 8
	if (b2 != NULL)
		buf_free(b2);
	if (b3 != NULL)
		buf_free(b3);
	if (d1 != NULL)
		buf_free(d1);
	if (d2 != NULL)
		buf_free(d2);
@


1.36
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.35 2015/01/16 06:40:11 deraadt Exp $	*/
d646 1
a646 1
	while ((t1 = d1 < d13 + m1) | (t2 = d2 < d23 + m2)) {
@


1.35
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.34 2014/12/01 21:58:46 deraadt Exp $	*/
d252 7
a258 14
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
	if (path3 != NULL)
		xfree(path3);
	if (dp13 != NULL)
		xfree(dp13);
	if (dp23 != NULL)
		xfree(dp23);
	if (data != NULL)
		xfree(data);
	if (patch != NULL)
		xfree(patch);
d372 7
a378 14
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
	if (path3 != NULL)
		xfree(path3);
	if (dp13 != NULL)
		xfree(dp13);
	if (dp23 != NULL)
		xfree(dp23);
	if (data != NULL)
		xfree(data);
	if (patch != NULL)
		xfree(patch);
@


1.34
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.33 2012/03/04 04:05:15 fgsch Exp $	*/
d129 1
a129 1
static char f1mark[MAXPATHLEN], f3mark[MAXPATHLEN];	/* markers for -E and -X */
@


1.33
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.32 2011/04/20 19:34:16 nicm Exp $	*/
d640 1
a640 1
		buf = xrealloc(buf, 1, bufsize);
d937 1
a937 1
	d13 = xrealloc(d13, newsz, sizeof(*d13));
d939 1
a939 1
	d23 = xrealloc(d23, newsz, sizeof(*d23));
d941 1
a941 1
	de = xrealloc(de, newsz, sizeof(*de));
d943 1
a943 1
	overlap = xrealloc(overlap, newsz, sizeof(*overlap));
@


1.32
log
@Remove some unneeded includes and dead code, from Michael W Bombardieri.

ok jasper xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.31 2010/07/28 09:07:11 ray Exp $	*/
d134 1
a134 1
static char *getline(FILE *, size_t *);
d615 1
a615 1
	while ((line = getline(b, NULL))) {
d624 1
a624 1
getline(FILE *b, size_t *n)
d826 1
a826 1
		if ((line = getline(fp[i], &j)) == NULL)
@


1.31
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.30 2010/07/23 21:46:05 ray Exp $	*/
d903 1
a903 1
	for (n = n; n > 0; n--) {
@


1.30
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.29 2010/07/23 08:31:19 ray Exp $	*/
d169 1
a169 1
	if ((b1 = buf_load(av[0], BUF_AUTOEXT)) == NULL)
d171 1
a171 1
	if ((b2 = buf_load(av[1], BUF_AUTOEXT)) == NULL)
d173 1
a173 1
	if ((b3 = buf_load(av[2], BUF_AUTOEXT)) == NULL)
d176 3
a178 3
	d1 = buf_alloc(128, BUF_AUTOEXT);
	d2 = buf_alloc(128, BUF_AUTOEXT);
	diffb = buf_alloc(128, BUF_AUTOEXT);
d290 1
a290 1
	if ((b1 = buf_load(workfile, BUF_AUTOEXT)) == NULL)
d303 3
a305 3
	d1 = buf_alloc(128, BUF_AUTOEXT);
	d2 = buf_alloc(128, BUF_AUTOEXT);
	diffb = buf_alloc(128, BUF_AUTOEXT);
@


1.29
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.28 2009/10/27 23:59:42 deraadt Exp $	*/
d129 1
a129 1
static char f1mark[256], f3mark[256];	/* markers for -E and -X */
d169 1
a169 1
	if ((b1 = rcs_buf_load(av[0], BUF_AUTOEXT)) == NULL)
d171 1
a171 1
	if ((b2 = rcs_buf_load(av[1], BUF_AUTOEXT)) == NULL)
d173 1
a173 1
	if ((b3 = rcs_buf_load(av[2], BUF_AUTOEXT)) == NULL)
d176 3
a178 3
	d1 = rcs_buf_alloc(128, BUF_AUTOEXT);
	d2 = rcs_buf_alloc(128, BUF_AUTOEXT);
	diffb = rcs_buf_alloc(128, BUF_AUTOEXT);
d184 3
a186 3
	rcs_buf_write_stmp(b1, path1);
	rcs_buf_write_stmp(b2, path2);
	rcs_buf_write_stmp(b3, path3);
d188 1
a188 1
	rcs_buf_free(b2);
d193 1
a193 1
		rcs_buf_free(diffb);
d199 1
a199 1
	rcs_buf_write_stmp(d1, dp13);
d201 1
a201 1
	rcs_buf_free(d1);
d205 1
a205 1
	rcs_buf_write_stmp(d2, dp23);
d207 1
a207 1
	rcs_buf_free(d2);
d220 1
a220 1
		rcs_buf_free(diffb);
d225 4
a228 4
	plen = rcs_buf_len(diffb);
	patch = rcs_buf_release(diffb);
	dlen = rcs_buf_len(b1);
	data = rcs_buf_release(b1);
d238 1
a238 1
		rcs_buf_free(b2);
d240 1
a240 1
		rcs_buf_free(b3);
d242 1
a242 1
		rcs_buf_free(d1);
d244 1
a244 1
		rcs_buf_free(d2);
d290 1
a290 1
	if ((b1 = rcs_buf_load(workfile, BUF_AUTOEXT)) == NULL)
d303 3
a305 3
	d1 = rcs_buf_alloc(128, BUF_AUTOEXT);
	d2 = rcs_buf_alloc(128, BUF_AUTOEXT);
	diffb = rcs_buf_alloc(128, BUF_AUTOEXT);
d311 3
a313 3
	rcs_buf_write_stmp(b1, path1);
	rcs_buf_write_stmp(b2, path2);
	rcs_buf_write_stmp(b3, path3);
d315 1
a315 1
	rcs_buf_free(b2);
d320 1
a320 1
		rcs_buf_free(diffb);
d326 1
a326 1
	rcs_buf_write_stmp(d1, dp13);
d328 1
a328 1
	rcs_buf_free(d1);
d332 1
a332 1
	rcs_buf_write_stmp(d2, dp23);
d334 1
a334 1
	rcs_buf_free(d2);
d347 1
a347 1
		rcs_buf_free(diffb);
d352 4
a355 4
	plen = rcs_buf_len(diffb);
	patch = rcs_buf_release(diffb);
	dlen = rcs_buf_len(b1);
	data = rcs_buf_release(b1);
d365 1
a365 1
		rcs_buf_free(b2);
d367 1
a367 1
		rcs_buf_free(b3);
d369 1
a369 1
		rcs_buf_free(d1);
d371 1
a371 1
		rcs_buf_free(d2);
d452 1
d456 1
d460 1
d463 1
d592 1
d911 1
a911 2
			if (fread(block, 1, (size_t)j,
			    fp[2]) != (size_t)j)
@


1.28
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.27 2009/02/25 23:16:20 ray Exp $	*/
d486 1
a486 1
				dlp = TAILQ_PREV(dlp, rcs_tqh, l_list);
d500 1
a500 1
			insert_after = TAILQ_PREV(dlp, rcs_tqh, l_list);
@


1.27
log
@Checking if a file is ASCII should only be done when diffing, because
the non-ASCII characters could be printed to the screen.  For
checking in files, checking out files, merging files, and removing
revisions of files, we do so regardless of whether the files are
ASCII or binary.

Fixes PR6031.

OK joris and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.26 2008/03/02 19:40:58 tobias Exp $	*/
a65 11

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
static const char rcsid[] =
    "$OpenBSD: diff3.c,v 1.26 2008/03/02 19:40:58 tobias Exp $";
#endif /* not lint */
@


1.26
log
@Make sure that temporary file has been successfully opened.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.25 2007/12/23 01:15:12 tedu Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.25 2007/12/23 01:15:12 tedu Exp $";
d202 2
a203 2
	if ((diffreg(path1, path3, d1, 0) == D_ERROR) ||
	    (diffreg(path2, path3, d2, 0) == D_ERROR)) {
d329 2
a330 2
	if ((diffreg(path1, path3, d1, 0) == D_ERROR) ||
	    (diffreg(path2, path3, d2, 0) == D_ERROR)) {
@


1.25
log
@increase the marker buffers, they are not big enough for hg merge
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.24 2007/09/10 14:29:53 tobias Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.24 2007/09/10 14:29:53 tobias Exp $";
d147 1
a147 1
static size_t readin(char *, struct diff **);
d411 1
a411 1
	size_t m, n;
d428 8
a435 2
	m = readin(argv[0], &d13);
	n = readin(argv[1], &d23);
d559 1
a559 1
static size_t
d567 2
@


1.24
log
@Proper use of fseek/fseeko macros.

OK joris@@, otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.23 2007/07/03 00:56:23 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.23 2007/07/03 00:56:23 ray Exp $";
d140 1
a140 1
static char f1mark[40], f3mark[40];	/* markers for -E and -X */
@


1.23
log
@Rename rcs_diffreg() to diffreg().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.22 2007/06/30 08:23:49 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.22 2007/06/30 08:23:49 xsa Exp $";
d872 1
a872 1
		(void)fseek(fp[i], (long)-nchar, 1);
d906 1
a906 1
		(void)fseek(fp[2], (long)de[n].new.from, 0);
@


1.22
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.21 2007/05/29 00:19:10 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.21 2007/05/29 00:19:10 ray Exp $";
d202 2
a203 2
	if ((rcs_diffreg(path1, path3, d1, 0) == D_ERROR) ||
	    (rcs_diffreg(path2, path3, d2, 0) == D_ERROR)) {
d329 2
a330 2
	if ((rcs_diffreg(path1, path3, d1, 0) == D_ERROR) ||
	    (rcs_diffreg(path2, path3, d2, 0) == D_ERROR)) {
@


1.21
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.20 2007/02/27 07:59:13 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.20 2007/02/27 07:59:13 xsa Exp $";
d285 1
a285 1
	char *argv[5], r1[16], r2[16];
@


1.20
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.19 2007/02/22 08:30:45 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.19 2007/02/22 08:30:45 xsa Exp $";
a634 1
		char *newbuf;
d638 1
a638 2
		newbuf = xrealloc(buf, 1, bufsize);
		buf = newbuf;
a929 2
	struct diff *p;
	char *q;
d936 8
a943 12
	p = xrealloc(d13, newsz, sizeof(*d13));
	memset(p + szchanges, 0, incr * sizeof(*d13));
	d13 = p;
	p = xrealloc(d23, newsz, sizeof(*d23));
	memset(p + szchanges, 0, incr * sizeof(*d23));
	d23 = p;
	p = xrealloc(de, newsz, sizeof(*de));
	memset(p + szchanges, 0, incr * sizeof(*de));
	de = p;
	q = xrealloc(overlap, newsz, sizeof(*overlap));
	memset(q + szchanges, 0, incr * sizeof(*overlap));
	overlap = q;
@


1.19
log
@Fix const inconsistencies, void pointer artithmetic;
Based on diff from otto@@ in OpenCVS. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.18 2007/01/11 18:13:33 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.18 2007/01/11 18:13:33 niallo Exp $";
d78 6
a83 1
#include "includes.h"
@


1.18
log
@remove some un-needed buffer NUL-termination.  in openrcs, diff3 is already NUL-terminating its
buffers so we don't need to do it twice.  this allows us to sync rcs_splitlines() with opencvs'
cvs_splitlines().

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.17 2007/01/02 16:43:45 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.17 2007/01/02 16:43:45 niallo Exp $";
d414 1
a414 1
		if (i < 0 || i >= sizeof(f1mark))
d418 1
a418 1
		if (i < 0 || i >= sizeof(f3mark))
@


1.17
log
@- fix support for checking out binary files.

testing from xsa@@ and Igor Sobrado <igor at string1.ciencias.uniovi.es>
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.16 2006/10/24 06:22:53 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.16 2006/10/24 06:22:53 ray Exp $";
a230 4
	rcs_buf_putc(diffb, '\0');
	rcs_buf_putc(b1, '\0');


a356 3

	rcs_buf_putc(diffb, '\0');
	rcs_buf_putc(b1, '\0');
@


1.16
log
@Check that string length != 0 before setting buf[strlen(buf) - 1].

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.15 2006/09/21 15:30:07 millert Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.15 2006/09/21 15:30:07 millert Exp $";
d165 2
d170 1
d234 7
a240 1
	if ((diffb = rcs_patchfile(b1, diffb, ed_patch_lines)) == NULL)
d272 4
d287 2
d292 1
d365 6
a370 1
	if ((diffb = rcs_patchfile(b1, diffb, ed_patch_lines)) == NULL)
d402 4
d448 1
d456 8
a463 3
		if (lp->l_line[0] == '\0')
			errx(1, "ed_patch_lines");
		op = lp->l_line[strlen(lp->l_line) - 1];
d465 2
d523 1
a523 1
				if (!strcmp(lp->l_line, "."))
@


1.15
log
@Add support to rcsdiff for all the other diff flags that
are pertinent to files (not directories) and that do not
conflict with rcsdiff-specific flags.  OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.14 2006/08/11 08:18:19 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.14 2006/08/11 08:18:19 xsa Exp $";
d430 2
@


1.14
log
@correctly handle merge(1) and rcsmerge(1) -e and -E flags; tests and OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.13 2006/08/08 10:22:01 espie Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.13 2006/08/08 10:22:01 espie Exp $";
d194 2
a195 2
	if ((rcs_diffreg(path1, path3, d1) == D_ERROR) ||
	    (rcs_diffreg(path2, path3, d2) == D_ERROR)) {
d312 2
a313 2
	if ((rcs_diffreg(path1, path3, d1) == D_ERROR) ||
	    (rcs_diffreg(path2, path3, d2) == D_ERROR)) {
@


1.13
log
@let ed_patch_lines work with a c command that encompasses the last line
of the file. The TAILQ structures specifically contain an extra `first line'
to avoid this kind of issue, but no extra last line.
Instead of walking beyond the end of the structure, and wondering at the
null pointer, keep a pointer before the deleted block, as this one is
guaranteed to exist.

Fix Matthieu's testcase.

okay joris@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.12 2006/08/07 20:55:28 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.12 2006/08/07 20:55:28 ray Exp $";
d132 2
a133 2
static int eflag;
static int oflag;		/* indicates whether to mark overlaps (-E or -X)*/
d169 3
d268 1
a268 1
rcs_diff3(RCSFILE *rf, char *workfile, RCSNUM *rev1, RCSNUM *rev2, int verbose)
d278 3
d287 1
a287 1
	if (verbose == 1)
d292 1
a292 1
	if (verbose == 1)
d352 1
a352 1
	if (verbose == 1 && diff3_conflicts != 0)
a390 4
	/* XXX */
	eflag = 3;
	oflag = 1;

d394 9
a402 7
	i = snprintf(f1mark, sizeof(f1mark), "<<<<<<< %s", fmark);
	if (i < 0 || i >= sizeof(f1mark))
		errx(1, "diff3_internal: string truncated");

	i = snprintf(f3mark, sizeof(f3mark), ">>>>>>> %s", rmark);
	if (i < 0 || i >= sizeof(f3mark))
		errx(1, "diff3_internal: string truncated");
@


1.12
log
@More strlcpy/strlcat -> snprintf/xasprintf cleanup.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.11 2006/07/08 09:25:44 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.11 2006/07/08 09:25:44 ray Exp $";
d417 1
a417 1
	struct rcs_line *sort, *lp, *dlp, *ndlp;
d468 1
d474 1
a474 1
			dlp = TAILQ_PREV(dlp, rcs_tqh, l_list);
@


1.11
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.10 2006/06/03 03:05:10 niallo Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.10 2006/06/03 03:05:10 niallo Exp $";
d392 2
a393 2
	if (strlcpy(f1mark, "<<<<<<< ", sizeof(f1mark)) >= sizeof(f1mark) ||
	    strlcat(f1mark, fmark, sizeof(f1mark)) >= sizeof(f1mark))
d396 3
a398 3
	if (strlcpy(f3mark, ">>>>>>> ", sizeof(f3mark)) >= sizeof(f3mark) ||
	    strlcat(f3mark, rmark, sizeof(f3mark)) >= sizeof(f3mark))
		errx(1, "diff3_internal: strlcat");
@


1.10
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.9 2006/05/15 06:58:03 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.9 2006/05/15 06:58:03 xsa Exp $";
d184 3
a186 3
	rcs_buf_write_stmp(b1, path1, 0600);
	rcs_buf_write_stmp(b2, path2, 0600);
	rcs_buf_write_stmp(b3, path3, 0600);
d199 1
a199 1
	rcs_buf_write_stmp(d1, dp13, 0600);
d205 1
a205 1
	rcs_buf_write_stmp(d2, dp23, 0600);
d299 3
a301 3
	rcs_buf_write_stmp(b1, path1, 0600);
	rcs_buf_write_stmp(b2, path2, 0600);
	rcs_buf_write_stmp(b3, path3, 0600);
d314 1
a314 1
	rcs_buf_write_stmp(d1, dp13, 0600);
d320 1
a320 1
	rcs_buf_write_stmp(d2, dp23, 0600);
@


1.9
log
@missing bits for a working merge(1). Built and enabled.
OK joris@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.8 2006/05/10 01:10:23 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.8 2006/05/10 01:10:23 ray Exp $";
a162 1
	char *data, *patch;
d228 1
a228 5
	patch = rcs_buf_release(diffb);
	data = rcs_buf_release(b1);
	diffb = b1 = NULL;

	if ((diffb = rcs_patchfile(data, patch, ed_patch_lines)) == NULL)
a233 2
	xfree(data);
	xfree(patch);
a234 2
	if (b1 != NULL)
		rcs_buf_free(b1);
a267 1
	char *data, *patch;
d343 1
a343 5
	patch = rcs_buf_release(diffb);
	data = rcs_buf_release(b1);
	diffb = b1 = NULL;

	if ((diffb = rcs_patchfile(data, patch, ed_patch_lines)) == NULL)
a348 3
	xfree(data);
	xfree(patch);

a349 2
	if (b1 != NULL)
		rcs_buf_free(b1);
@


1.8
log
@Remove (size_t) casts on integer constants.

We should not cover up lint's shortcomings, especially if they no
longer exist.

``This is definately good.'' niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.7 2006/05/08 16:56:40 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.7 2006/05/08 16:56:40 xsa Exp $";
d155 117
@


1.7
log
@check for rcs_diffreg() return value; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.6 2006/05/08 10:19:34 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.6 2006/05/08 10:19:34 xsa Exp $";
d184 3
a186 3
	d1 = rcs_buf_alloc((size_t)128, BUF_AUTOEXT);
	d2 = rcs_buf_alloc((size_t)128, BUF_AUTOEXT);
	diffb = rcs_buf_alloc((size_t)128, BUF_AUTOEXT);
d775 1
a775 1
			if (fread(block, (size_t)1, (size_t)j,
@


1.6
log
@fix error/verbose messages to match gnu/usr.bin/rcs when using rcsmerge(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.5 2006/05/04 07:06:58 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.5 2006/05/04 07:06:58 xsa Exp $";
d166 1
d199 6
a204 2
	rcs_diffreg(path1, path3, d1);
	rcs_diffreg(path2, path3, d2);
@


1.5
log
@finish work wrt TMPDIR; use xasprintf() to simplify code while in there;
"looks fine" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.4 2006/05/03 07:10:39 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.4 2006/05/03 07:10:39 xsa Exp $";
d174 1
a174 1
		printf("Retrieving revision %s\n", r1);
d179 1
a179 1
		printf("Retrieving revision %s\n", r2);
d238 2
a239 5
	if (verbose == 1 && diff3_conflicts != 0) {
		warnx("%d conflict%s found during merge, "
		    "please correct.", diff3_conflicts,
		    (diff3_conflicts > 1) ? "s" : "");
	}
@


1.4
log
@respect TMPDIR; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.3 2006/04/29 05:31:28 ray Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.3 2006/04/29 05:31:28 ray Exp $";
d162 1
a162 2
	char path1[MAXPATHLEN], path2[MAXPATHLEN], path3[MAXPATHLEN];
	char dp13[MAXPATHLEN], dp23[MAXPATHLEN];
d187 3
a189 11
	if (strlcpy(path1, rcs_tmpdir, sizeof(path1)) >= sizeof(path1) ||
	    strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1)) >= sizeof(path1))
		errx(1, "rcs_diff3: string truncated");

	if (strlcpy(path2, rcs_tmpdir, sizeof(path2)) >= sizeof(path2) ||
	    strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2)) >= sizeof(path2))
		errx(1, "rcs_diff3: string truncated");

	if (strlcpy(path3, rcs_tmpdir, sizeof(path3)) >= sizeof(path3) ||
	    strlcat(path3, "/diff3.XXXXXXXXXX", sizeof(path3)) >= sizeof(path3))
		errx(1, "rcs_diff3: string truncated");
d201 1
a201 4
	if (strlcpy(dp13, rcs_tmpdir, sizeof(dp13)) >= sizeof(dp13) ||
	    strlcat(dp13, "/d13.XXXXXXXXXX" , sizeof(dp13)) >= sizeof(dp13))
		errx(1, "rcs_diff3: string truncated");

d207 1
a207 4
	if (strlcpy(dp23, rcs_tmpdir, sizeof(dp23)) >= sizeof(dp23) ||
	    strlcat(dp23, "/d23.XXXXXXXXXX", sizeof(dp23)) >= sizeof(dp23))
		errx(1, "rcs_diff3: string truncated");

d264 11
@


1.3
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.2 2006/04/27 07:59:33 xsa Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.2 2006/04/27 07:59:33 xsa Exp $";
d81 1
a81 2
#include "rcsutil.h"
#include "xmalloc.h"
d188 10
a197 3
	if (strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1)) >= sizeof(path1) ||
	    strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2)) >= sizeof(path2) ||
	    strlcpy(path3, "/tmp/diff3.XXXXXXXXXX", sizeof(path3)) >= sizeof(path3))
d210 2
a211 1
	if (strlcpy(dp13, "/tmp/d13.XXXXXXXXXX", sizeof(dp13)) >= sizeof(dp13))
d213 1
d219 2
a220 1
	if (strlcpy(dp23, "/tmp/d23.XXXXXXXXXX", sizeof(dp23)) >= sizeof(dp23))
d222 1
@


1.2
log
@zap util.[ch] and move the content into rcsutil.[ch].
discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.1 2006/04/26 02:55:13 joris Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.1 2006/04/26 02:55:13 joris Exp $";
d189 5
a193 1
	strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1));
a194 2

	strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2));
a195 2

	strlcpy(path3, "/tmp/diff3.XXXXXXXXXX", sizeof(path3));
d204 2
a205 1
	strlcpy(dp13, "/tmp/d13.XXXXXXXXXX", sizeof(dp13));
d211 2
a212 1
	strlcpy(dp23, "/tmp/d23.XXXXXXXXXX", sizeof(dp23));
d286 7
a292 5
	strlcpy(f1mark, "<<<<<<< ", sizeof(f1mark));
	strlcat(f1mark, fmark, sizeof(f1mark));

	strlcpy(f3mark, ">>>>>>> ", sizeof(f3mark));
	strlcat(f3mark, rmark, sizeof(f3mark));
d298 1
a298 1
	for (i = 0; i <= 2; i++) {
a302 1
	}
@


1.1
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: diff3.c,v 1.23 2006/04/14 02:49:41 deraadt Exp $	*/
d75 1
a75 1
    "$OpenBSD: diff3.c,v 1.23 2006/04/14 02:49:41 deraadt Exp $";
d81 1
a81 1
#include "util.h"
@

