head	1.161;
access;
symbols
	OPENBSD_6_2:1.161.0.4
	OPENBSD_6_2_BASE:1.161
	OPENBSD_6_1:1.161.0.6
	OPENBSD_6_1_BASE:1.161
	OPENBSD_6_0:1.161.0.2
	OPENBSD_6_0_BASE:1.161
	OPENBSD_5_9:1.160.0.2
	OPENBSD_5_9_BASE:1.160
	OPENBSD_5_8:1.156.0.4
	OPENBSD_5_8_BASE:1.156
	OPENBSD_5_7:1.155.0.2
	OPENBSD_5_7_BASE:1.155
	OPENBSD_5_6:1.151.0.16
	OPENBSD_5_6_BASE:1.151
	OPENBSD_5_5:1.151.0.14
	OPENBSD_5_5_BASE:1.151
	OPENBSD_5_4:1.151.0.10
	OPENBSD_5_4_BASE:1.151
	OPENBSD_5_3:1.151.0.8
	OPENBSD_5_3_BASE:1.151
	OPENBSD_5_2:1.151.0.6
	OPENBSD_5_2_BASE:1.151
	OPENBSD_5_1_BASE:1.151
	OPENBSD_5_1:1.151.0.4
	OPENBSD_5_0:1.151.0.2
	OPENBSD_5_0_BASE:1.151
	OPENBSD_4_9:1.150.0.2
	OPENBSD_4_9_BASE:1.150
	OPENBSD_4_8:1.148.0.2
	OPENBSD_4_8_BASE:1.148
	OPENBSD_4_7:1.147.0.4
	OPENBSD_4_7_BASE:1.147
	OPENBSD_4_6:1.147.0.6
	OPENBSD_4_6_BASE:1.147
	OPENBSD_4_5:1.147.0.2
	OPENBSD_4_5_BASE:1.147
	OPENBSD_4_4:1.145.0.2
	OPENBSD_4_4_BASE:1.145
	OPENBSD_4_3:1.141.0.2
	OPENBSD_4_3_BASE:1.141
	OPENBSD_4_2:1.139.0.2
	OPENBSD_4_2_BASE:1.139
	OPENBSD_4_1:1.137.0.2
	OPENBSD_4_1_BASE:1.137
	OPENBSD_4_0:1.132.0.2
	OPENBSD_4_0_BASE:1.132
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.161
date	2016.07.04.01.39.12;	author millert;	state Exp;
branches;
next	1.160;
commitid	9iBcbXzctTwjd6fC;

1.160
date	2015.12.29.19.12.56;	author gsoares;	state Exp;
branches;
next	1.159;
commitid	oXJd47tWszF2wgxD;

1.159
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.158;
commitid	H99PcNtHGZMrNl2r;

1.158
date	2015.10.10.20.35.01;	author deraadt;	state Exp;
branches;
next	1.157;
commitid	m38BXhkh3XknrpM6;

1.157
date	2015.10.10.18.58.53;	author deraadt;	state Exp;
branches;
next	1.156;
commitid	D3I7q2ZnA5r5jD2m;

1.156
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.155;
commitid	FFUg8uzT5GNAfRXp;

1.155
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.154;
commitid	Uu5nFG3wCl0LACBb;

1.154
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	Z3HC5pAWzpo5jsTe;

1.153
date	2014.10.10.08.03.39;	author otto;	state Exp;
branches;
next	1.152;
commitid	1KS236PJYMzMQVaW;

1.152
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.151;
commitid	yRuTsAu91VfT3St0;

1.151
date	2011.07.12.21.00.32;	author sobrado;	state Exp;
branches;
next	1.150;

1.150
date	2010.12.06.22.47.56;	author chl;	state Exp;
branches;
next	1.149;

1.149
date	2010.09.08.15.15.50;	author tobias;	state Exp;
branches;
next	1.148;

1.148
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.147;

1.147
date	2009.02.15.12.58.01;	author joris;	state Exp;
branches;
next	1.146;

1.146
date	2008.11.09.12.34.47;	author tobias;	state Exp;
branches;
next	1.145;

1.145
date	2008.07.08.12.25.47;	author joris;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.10.19.54.58;	author tobias;	state Exp;
branches;
next	1.143;

1.143
date	2008.04.26.19.58.03;	author ray;	state Exp;
branches;
next	1.142;

1.142
date	2008.04.24.19.16.49;	author tobias;	state Exp;
branches;
next	1.141;

1.141
date	2008.03.04.16.43.51;	author joris;	state Exp;
branches;
next	1.140;

1.140
date	2008.02.24.15.13.18;	author xsa;	state Exp;
branches;
next	1.139;

1.139
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.26.21.51.04;	author sobrado;	state Exp;
branches;
next	1.137;

1.137
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.136;

1.136
date	2007.01.10.18.04.25;	author joris;	state Exp;
branches;
next	1.135;

1.135
date	2006.12.27.07.43.24;	author niallo;	state Exp;
branches;
next	1.134;

1.134
date	2006.11.13.11.22.57;	author xsa;	state Exp;
branches;
next	1.133;

1.133
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.132;

1.132
date	2006.08.16.07.39.15;	author ray;	state Exp;
branches;
next	1.131;

1.131
date	2006.05.29.21.17.44;	author ray;	state Exp;
branches;
next	1.130;

1.130
date	2006.05.28.23.16.31;	author ray;	state Exp;
branches;
next	1.129;

1.129
date	2006.05.28.18.55.55;	author ray;	state Exp;
branches;
next	1.128;

1.128
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.127;

1.127
date	2006.05.19.07.52.38;	author xsa;	state Exp;
branches;
next	1.126;

1.126
date	2006.05.15.06.58.03;	author xsa;	state Exp;
branches;
next	1.125;

1.125
date	2006.05.11.09.43.19;	author xsa;	state Exp;
branches;
next	1.124;

1.124
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.123;

1.123
date	2006.05.01.18.07.00;	author joris;	state Exp;
branches;
next	1.122;

1.122
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.121;

1.121
date	2006.04.29.05.10.16;	author ray;	state Exp;
branches;
next	1.120;

1.120
date	2006.04.28.22.26.08;	author jmc;	state Exp;
branches;
next	1.119;

1.119
date	2006.04.27.07.54.15;	author jmc;	state Exp;
branches;
next	1.118;

1.118
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.117;

1.117
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.116;

1.116
date	2006.04.25.13.55.49;	author xsa;	state Exp;
branches;
next	1.115;

1.115
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.114;

1.114
date	2006.04.24.08.10.41;	author xsa;	state Exp;
branches;
next	1.113;

1.113
date	2006.04.24.04.51.57;	author ray;	state Exp;
branches;
next	1.112;

1.112
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.111;

1.111
date	2006.04.21.14.42.12;	author xsa;	state Exp;
branches;
next	1.110;

1.110
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.109;

1.109
date	2006.04.21.07.06.25;	author xsa;	state Exp;
branches;
next	1.108;

1.108
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.107;

1.107
date	2006.04.18.03.35.57;	author ray;	state Exp;
branches;
next	1.106;

1.106
date	2006.04.18.02.46.21;	author ray;	state Exp;
branches;
next	1.105;

1.105
date	2006.04.17.12.11.07;	author xsa;	state Exp;
branches;
next	1.104;

1.104
date	2006.04.15.19.35.19;	author xsa;	state Exp;
branches;
next	1.103;

1.103
date	2006.04.14.23.29.01;	author joris;	state Exp;
branches;
next	1.102;

1.102
date	2006.04.14.01.11.07;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2006.04.13.19.55.41;	author joris;	state Exp;
branches;
next	1.100;

1.100
date	2006.04.13.16.10.29;	author joris;	state Exp;
branches;
next	1.99;

1.99
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.98;

1.98
date	2006.04.12.22.54.23;	author ray;	state Exp;
branches;
next	1.97;

1.97
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.96;

1.96
date	2006.04.11.08.07.35;	author ray;	state Exp;
branches;
next	1.95;

1.95
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.94;

1.94
date	2006.04.07.12.54.40;	author xsa;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.06.10.13.00;	author xsa;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.01.06.19.29;	author ray;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.01.05.58.17;	author ray;	state Exp;
branches;
next	1.90;

1.90
date	2006.03.28.09.51.09;	author xsa;	state Exp;
branches;
next	1.89;

1.89
date	2006.03.27.21.56.32;	author niallo;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.27.08.21.01;	author ray;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.27.07.38.24;	author ray;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.27.06.13.51;	author pat;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.23.09.03.28;	author xsa;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.22.02.58.15;	author ray;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.21.08.34.36;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.21.02.50.15;	author ray;	state Exp;
branches;
next	1.80;

1.80
date	2006.03.21.02.45.09;	author ray;	state Exp;
branches;
next	1.79;

1.79
date	2006.03.20.17.41.37;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2006.03.18.04.00.34;	author ray;	state Exp;
branches;
next	1.77;

1.77
date	2006.03.18.03.41.54;	author ray;	state Exp;
branches;
next	1.76;

1.76
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.75;

1.75
date	2006.03.16.03.51.18;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2006.03.15.03.29.01;	author ray;	state Exp;
branches;
next	1.73;

1.73
date	2006.03.15.02.46.14;	author ray;	state Exp;
branches;
next	1.72;

1.72
date	2006.03.14.03.33.30;	author ray;	state Exp;
branches;
next	1.71;

1.71
date	2006.03.14.01.51.35;	author ray;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.12.01.20.38;	author joris;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.11.22.51.13;	author niallo;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.08.20.19.39;	author joris;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.08.12.25.34;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.06.14.57.32;	author jmc;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.06.14.37.23;	author jmc;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.06.09.41.53;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.21.16.39.23;	author niallo;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.25.08.01.00;	author xsa;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.06.15.30.49;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.27.16.05.21;	author niallo;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.24.16.37.46;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.24.03.48.09;	author joris;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.21.16.10.50;	author xsa;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.14.11.39.12;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.10.20.27.46;	author joris;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.09.07.00.43;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.30.09.36.48;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.27.16.49.15;	author niallo;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.25.14.16.44;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.25.13.50.01;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2005.11.23.09.39.20;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.21.15.16.41;	author niallo;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.21.11.17.19;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.20.08.50.20;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.12.22.49.59;	author niallo;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.12.21.34.48;	author niallo;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.12.09.42.29;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.04.08.19.42;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.03.17.54.34;	author niallo;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.27.07.43.56;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.19.11.37.11;	author niallo;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.19.00.30.22;	author joris;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.18.16.20.31;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.18.01.24.42;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.18.01.22.14;	author joris;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.16.00.25.14;	author joris;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.15.23.39.36;	author joris;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.12.17.43.18;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.11.00.25.18;	author joris;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.10.23.38.21;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.10.14.37.59;	author niallo;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.06.15.39.11;	author joris;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.06.12.56.49;	author joris;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.06.02.00.05;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.06.01.26.12;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.06.01.24.25;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.30.17.34.58;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.30.15.05.47;	author joris;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.30.15.02.26;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.29.21.38.48;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.29.21.38.01;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.29.21.30.10;	author joris;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.29.15.19.51;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.29.15.14.12;	author joris;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.29.15.13.19;	author joris;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.29.00.20.22;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.20.05.03.02;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.20.05.01.31;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.20.04.30.57;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.20.04.29.51;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.20.04.24.41;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.15.15.59.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.15.15.46.21;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.161
log
@The -I flag is documented but not implemented.  This fixes that and
also honors the -I flag from ci/co when prompting like GNU RCS.
OK jca@@
@
text
@/*	$OpenBSD: rcsprog.c,v 1.160 2015/12/29 19:12:56 gsoares Exp $	*/
/*
 * Copyright (c) 2005 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <err.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcsprog.h"

#define RCSPROG_OPTSTRING	"A:a:b::c:e::Iik:Ll::m:Mn:N:o:qt::TUu::Vx::z::"

const char rcs_version[] = "OpenRCS 4.5";

int	 rcsflags;
int	 rcs_optind;
char	*rcs_optarg;
char	*rcs_suffixes = RCS_DEFAULT_SUFFIX;
char	*rcs_tmpdir = RCS_TMPDIR_DEFAULT;

struct rcs_prog {
	char	*prog_name;
	int	(*prog_hdlr)(int, char **);
	void	(*prog_usage)(void);
} programs[] = {
	{ "rcs",	rcs_main,	rcs_usage	},
	{ "ci",		checkin_main,	checkin_usage   },
	{ "co",		checkout_main,	checkout_usage  },
	{ "rcsclean",	rcsclean_main,	rcsclean_usage	},
	{ "rcsdiff",	rcsdiff_main,	rcsdiff_usage	},
	{ "rcsmerge",	rcsmerge_main,	rcsmerge_usage	},
	{ "rlog",	rlog_main,	rlog_usage	},
	{ "ident",	ident_main,	ident_usage	},
	{ "merge",	merge_main,	merge_usage	},
};

struct wklhead temp_files;

void sighdlr(int);
static void  rcs_attach_symbol(RCSFILE *, const char *);

/* ARGSUSED */
void
sighdlr(int sig)
{
	worklist_clean(&temp_files, worklist_unlink);
	_exit(1);
}

int
build_cmd(char ***cmd_argv, char **argv, int argc)
{
	int cmd_argc, i, cur;
	char *cp, *rcsinit, *linebuf, *lp;

	if ((rcsinit = getenv("RCSINIT")) == NULL) {
		*cmd_argv = argv;
		return argc;
	}

	cur = argc + 2;
	cmd_argc = 0;
	*cmd_argv = xcalloc(cur, sizeof(char *));
	(*cmd_argv)[cmd_argc++] = argv[0];

	linebuf = xstrdup(rcsinit);
	for (lp = linebuf; lp != NULL;) {
		cp = strsep(&lp, " \t\b\f\n\r\t\v");
		if (cp == NULL)
			break;
		if (*cp == '\0')
			continue;

		if (cmd_argc == cur) {
			cur += 8;
			*cmd_argv = xreallocarray(*cmd_argv, cur,
			    sizeof(char *));
		}

		(*cmd_argv)[cmd_argc++] = cp;
	}

	if (cmd_argc + argc > cur) {
		cur = cmd_argc + argc + 1;
		*cmd_argv = xreallocarray(*cmd_argv, cur,
		    sizeof(char *));
	}

	for (i = 1; i < argc; i++)
		(*cmd_argv)[cmd_argc++] = argv[i];

	(*cmd_argv)[cmd_argc] = NULL;

	return cmd_argc;
}

int
main(int argc, char **argv)
{
	u_int i;
	char **cmd_argv;
	int ret, cmd_argc;

	if (pledge("stdio rpath wpath cpath fattr flock getpw", NULL) == -1)
		err(2, "pledge");

	ret = -1;
	rcs_optind = 1;
	SLIST_INIT(&temp_files);

	cmd_argc = build_cmd(&cmd_argv, argv, argc);

	if ((rcs_tmpdir = getenv("TMPDIR")) == NULL)
		rcs_tmpdir = RCS_TMPDIR_DEFAULT;

	signal(SIGHUP, sighdlr);
	signal(SIGINT, sighdlr);
	signal(SIGQUIT, sighdlr);
	signal(SIGABRT, sighdlr);
	signal(SIGALRM, sighdlr);
	signal(SIGTERM, sighdlr);

	for (i = 0; i < (sizeof(programs)/sizeof(programs[0])); i++)
		if (strcmp(__progname, programs[i].prog_name) == 0) {
			usage = programs[i].prog_usage;
			ret = programs[i].prog_hdlr(cmd_argc, cmd_argv);
			break;
		}

	/* clean up temporary files */
	worklist_run(&temp_files, worklist_unlink);

	exit(ret);
}


__dead void
rcs_usage(void)
{
	fprintf(stderr,
	    "usage: rcs [-IiLqTUV] [-Aoldfile] [-ausers] [-b[rev]]\n"
	    "           [-cstring] [-e[users]] [-kmode] [-l[rev]] [-mrev:msg]\n"
	    "           [-orev] [-t[str]] [-u[rev]] [-xsuffixes] file ...\n");

	exit(1);
}

/*
 * rcs_main()
 *
 * Handler for the `rcs' program.
 * Returns 0 on success, or >0 on error.
 */
int
rcs_main(int argc, char **argv)
{
	int fd;
	int i, j, ch, flags, kflag, lkmode;
	const char *nflag, *oldfilename, *orange;
	char fpath[PATH_MAX];
	char *logstr, *logmsg, *descfile;
	char *alist, *comment, *elist, *lrev, *urev;
	mode_t fmode;
	RCSFILE *file;
	RCSNUM *logrev;
	struct rcs_access *acp;
	time_t rcs_mtime = -1;

	kflag = RCS_KWEXP_ERR;
	lkmode = RCS_LOCK_INVAL;
	fmode =  S_IRUSR|S_IRGRP|S_IROTH;
	flags = RCS_RDWR|RCS_PARSE_FULLY;
	lrev = urev = descfile = NULL;
	logstr = alist = comment = elist = NULL;
	nflag = oldfilename = orange = NULL;

	/* match GNU */
	if (1 < argc && argv[1][0] != '-')
		warnx("warning: No options were given; "
		    "this usage is obsolescent.");

	while ((ch = rcs_getopt(argc, argv, RCSPROG_OPTSTRING)) != -1) {
		switch (ch) {
		case 'A':
			oldfilename = rcs_optarg;
			rcsflags |= CO_ACLAPPEND;
			break;
		case 'a':
			alist = rcs_optarg;
			break;
		case 'c':
			comment = rcs_optarg;
			break;
		case 'e':
			elist = rcs_optarg;
			rcsflags |= RCSPROG_EFLAG;
			break;
		case 'I':
			rcsflags |= INTERACTIVE;
			break;
		case 'i':
			flags |= RCS_CREATE;
			break;
		case 'k':
			kflag = rcs_kflag_get(rcs_optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				warnx("invalid RCS keyword substitution mode");
				(usage)();
			}
			break;
		case 'L':
			if (lkmode == RCS_LOCK_LOOSE)
				warnx("-U overridden by -L");
			lkmode = RCS_LOCK_STRICT;
			break;
		case 'l':
			if (rcsflags & RCSPROG_UFLAG)
				warnx("-u overridden by -l");
			lrev = rcs_optarg;
			rcsflags &= ~RCSPROG_UFLAG;
			rcsflags |= RCSPROG_LFLAG;
			break;
		case 'm':
			free(logstr);
			logstr = xstrdup(rcs_optarg);
			break;
		case 'M':
			/* ignore for the moment */
			break;
		case 'n':
			nflag = rcs_optarg;
			break;
		case 'N':
			nflag = rcs_optarg;
			rcsflags |= RCSPROG_NFLAG;
			break;
		case 'o':
			orange = rcs_optarg;
			break;
		case 'q':
			rcsflags |= QUIET;
			break;
		case 't':
			descfile = rcs_optarg;
			rcsflags |= DESCRIPTION;
			break;
		case 'T':
			rcsflags |= PRESERVETIME;
			break;
		case 'U':
			if (lkmode == RCS_LOCK_STRICT)
				warnx("-L overridden by -U");
			lkmode = RCS_LOCK_LOOSE;
			break;
		case 'u':
			if (rcsflags & RCSPROG_LFLAG)
				warnx("-l overridden by -u");
			urev = rcs_optarg;
			rcsflags &= ~RCSPROG_LFLAG;
			rcsflags |= RCSPROG_UFLAG;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			/*
			 * kept for compatibility
			 */
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (argc == 0) {
		warnx("no input file");
		(usage)();
	}

	for (i = 0; i < argc; i++) {
		fd = rcs_choosefile(argv[i], fpath, sizeof(fpath));
		if (fd < 0 && !(flags & RCS_CREATE)) {
			warn("%s", fpath);
			continue;
		}

		if (!(rcsflags & QUIET))
			(void)fprintf(stderr, "RCS file: %s\n", fpath);

		if ((file = rcs_open(fpath, fd, flags, fmode)) == NULL) {
			close(fd);
			continue;
		}

		if (rcsflags & DESCRIPTION) {
			if (rcs_set_description(file, descfile, rcsflags) == -1) {
				warn("%s", descfile);
				rcs_close(file);
				continue;
			}
		}
		else if (flags & RCS_CREATE) {
			if (rcs_set_description(file, NULL, rcsflags) == -1) {
				warn("stdin");
				rcs_close(file);
				continue;
			}
		}

		if (rcsflags & PRESERVETIME)
			rcs_mtime = rcs_get_mtime(file);

		if (nflag != NULL)
			rcs_attach_symbol(file, nflag);

		if (logstr != NULL) {
			if ((logmsg = strchr(logstr, ':')) == NULL) {
				warnx("missing log message");
				rcs_close(file);
				continue;
			}

			*logmsg++ = '\0';
			if ((logrev = rcsnum_parse(logstr)) == NULL) {
				warnx("`%s' bad revision number", logstr);
				rcs_close(file);
				continue;
			}

			if (rcs_rev_setlog(file, logrev, logmsg) < 0) {
				warnx("failed to set logmsg for `%s' to `%s'",
				    logstr, logmsg);
				rcs_close(file);
				rcsnum_free(logrev);
				continue;
			}

			rcsnum_free(logrev);
		}

		/* entries to add from <oldfile> */
		if (rcsflags & CO_ACLAPPEND) {
			RCSFILE *oldfile;
			int ofd;
			char ofpath[PATH_MAX];

			ofd = rcs_choosefile(oldfilename, ofpath, sizeof(ofpath));
			if (ofd < 0) {
				if (!(flags & RCS_CREATE))
					warn("%s", ofpath);
				exit(1);
			}
			if ((oldfile = rcs_open(ofpath, ofd, RCS_READ)) == NULL)
				exit(1);

			TAILQ_FOREACH(acp, &(oldfile->rf_access), ra_list)
				rcs_access_add(file, acp->ra_name);

			rcs_close(oldfile);
			(void)close(ofd);
		}

		/* entries to add to the access list */
		if (alist != NULL) {
			struct rcs_argvector *aargv;

			aargv = rcs_strsplit(alist, ",");
			for (j = 0; aargv->argv[j] != NULL; j++)
				rcs_access_add(file, aargv->argv[j]);

			rcs_argv_destroy(aargv);
		}

		if (comment != NULL)
			rcs_comment_set(file, comment);

		if (elist != NULL) {
			struct rcs_argvector *eargv;

			eargv = rcs_strsplit(elist, ",");
			for (j = 0; eargv->argv[j] != NULL; j++)
				rcs_access_remove(file, eargv->argv[j]);

			rcs_argv_destroy(eargv);
		} else if (rcsflags & RCSPROG_EFLAG) {
			struct rcs_access *rap;

			/* XXX rcs_access_remove(file, NULL); ?? */
			while (!TAILQ_EMPTY(&(file->rf_access))) {
				rap = TAILQ_FIRST(&(file->rf_access));
				TAILQ_REMOVE(&(file->rf_access), rap, ra_list);
				free(rap->ra_name);
				free(rap);
			}
			/* not synced anymore */
			file->rf_flags &= ~RCS_SYNCED;
		}

		rcs_kwexp_set(file, kflag);

		if (lkmode != RCS_LOCK_INVAL)
			(void)rcs_lock_setmode(file, lkmode);

		if (rcsflags & RCSPROG_LFLAG) {
			RCSNUM *rev;
			const char *username;
			char rev_str[RCS_REV_BUFSZ];

			if (file->rf_head == NULL) {
				warnx("%s contains no revisions", fpath);
				rcs_close(file);
				continue;
			}

			if ((username = getlogin()) == NULL)
				err(1, "getlogin");
			if (lrev == NULL) {
				rev = rcsnum_alloc();
				rcsnum_cpy(file->rf_head, rev, 0);
			} else if ((rev = rcsnum_parse(lrev)) == NULL) {
				warnx("unable to unlock file");
				rcs_close(file);
				continue;
			}
			rcsnum_tostr(rev, rev_str, sizeof(rev_str));
			/* Make sure revision exists. */
			if (rcs_findrev(file, rev) == NULL)
				errx(1, "%s: cannot lock nonexisting "
				    "revision %s", fpath, rev_str);
			if (rcs_lock_add(file, username, rev) != -1 &&
			    !(rcsflags & QUIET))
				(void)fprintf(stderr, "%s locked\n", rev_str);
			rcsnum_free(rev);
		}

		if (rcsflags & RCSPROG_UFLAG) {
			RCSNUM *rev;
			const char *username;
			char rev_str[RCS_REV_BUFSZ];

			if (file->rf_head == NULL) {
				warnx("%s contains no revisions", fpath);
				rcs_close(file);
				continue;
			}

			if ((username = getlogin()) == NULL)
				err(1, "getlogin");
			if (urev == NULL) {
				rev = rcsnum_alloc();
				rcsnum_cpy(file->rf_head, rev, 0);
			} else if ((rev = rcsnum_parse(urev)) == NULL) {
				warnx("unable to unlock file");
				rcs_close(file);
				continue;
			}
			rcsnum_tostr(rev, rev_str, sizeof(rev_str));
			/* Make sure revision exists. */
			if (rcs_findrev(file, rev) == NULL)
				errx(1, "%s: cannot unlock nonexisting "
				    "revision %s", fpath, rev_str);
			if (rcs_lock_remove(file, username, rev) == -1 &&
			    !(rcsflags & QUIET))
				warnx("%s: warning: No locks are set.", fpath);
			else {
				if (!(rcsflags & QUIET))
					(void)fprintf(stderr,
					    "%s unlocked\n", rev_str);
			}
			rcsnum_free(rev);
		}

		if (orange != NULL) {
			struct rcs_delta *rdp, *nrdp;
			char b[RCS_REV_BUFSZ];

			rcs_rev_select(file, orange);
			for (rdp = TAILQ_FIRST(&(file->rf_delta));
			    rdp != NULL; rdp = nrdp) {
				nrdp = TAILQ_NEXT(rdp, rd_list);

				/*
				 * Delete selected revisions.
				 */
				if (rdp->rd_flags & RCS_RD_SELECT) {
					rcsnum_tostr(rdp->rd_num, b, sizeof(b));
					if (!(rcsflags & QUIET)) {
						(void)fprintf(stderr, "deleting"
						    " revision %s\n", b);
					}
					(void)rcs_rev_remove(file, rdp->rd_num);
				}
			}
		}

		rcs_write(file);

		if (rcsflags & PRESERVETIME)
			rcs_set_mtime(file, rcs_mtime);

		rcs_close(file);

		if (!(rcsflags & QUIET))
			(void)fprintf(stderr, "done\n");
	}

	return (0);
}

static void
rcs_attach_symbol(RCSFILE *file, const char *symname)
{
	char *rnum;
	RCSNUM *rev;
	char rbuf[RCS_REV_BUFSZ];
	int rm;

	rm = 0;
	rev = NULL;
	if ((rnum = strrchr(symname, ':')) != NULL) {
		if (rnum[1] == '\0')
			rev = file->rf_head;
		*(rnum++) = '\0';
	} else {
		rm = 1;
	}

	if (rev == NULL && rm != 1) {
		if ((rev = rcsnum_parse(rnum)) == NULL)
			errx(1, "bad revision %s", rnum);
	}

	if (rcsflags & RCSPROG_NFLAG)
		rm = 1;

	if (rm == 1) {
		if (rcs_sym_remove(file, symname) < 0) {
			if (rcs_errno == RCS_ERR_NOENT &&
			    !(rcsflags & RCSPROG_NFLAG))
				warnx("cannot delete nonexisting symbol %s",
				    symname);
		} else {
			if (rcsflags & RCSPROG_NFLAG)
				rm = 0;
		}
	}

	if (rm == 0) {
		if (rcs_sym_add(file, symname, rev) < 0 &&
		    rcs_errno == RCS_ERR_DUPENT) {
			rcsnum_tostr(rcs_sym_getrev(file, symname),
			    rbuf, sizeof(rbuf));
			errx(1, "symbolic name %s already bound to %s",
			    symname, rbuf);
		}
	}
}
@


1.160
log
@fix exit status on pledge(2) failure.

from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.159 2015/10/16 13:37:44 millert Exp $	*/
d38 1
a38 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::ik:Ll::m:Mn:N:o:qt::TUu::Vx::z::"
d225 3
d330 1
a330 1
			if (rcs_set_description(file, descfile) == -1) {
d337 1
a337 1
			if (rcs_set_description(file, NULL) == -1) {
@


1.159
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.158 2015/10/10 20:35:01 deraadt Exp $	*/
d132 1
a132 1
		err(1, "pledge");
@


1.158
log
@normalize a few more tame request orderings, to help review
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.157 2015/10/10 18:58:53 deraadt Exp $	*/
d131 1
a131 1
	if (pledge("stdio rpath wpath cpath fattr getpw", NULL) == -1)
@


1.157
log
@pledge "stdio getpw rpath wpath cpath fattr".  doug pointed out getpw*
use, and fattr for chmod.
doug
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.156 2015/06/13 20:15:21 nicm Exp $	*/
d131 1
a131 1
	if (pledge("stdio getpw rpath wpath cpath fattr", NULL) == -1)
@


1.156
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.155 2015/01/16 06:40:11 deraadt Exp $	*/
d130 3
@


1.155
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.154 2014/12/01 21:58:46 deraadt Exp $	*/
d245 1
a245 2
			if (logstr != NULL)
				xfree(logstr);
d420 2
a421 2
				xfree(rap->ra_name);
				xfree(rap);
@


1.154
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.153 2014/10/10 08:03:39 otto Exp $	*/
d184 1
a184 1
	char fpath[MAXPATHLEN];
d374 1
a374 1
			char ofpath[MAXPATHLEN];
@


1.153
log
@Explicitly handle -l and -u combinations. From Fritjof Bornebusch; ok daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.152 2014/10/02 06:23:15 otto Exp $	*/
d103 1
a103 1
			*cmd_argv = xrealloc(*cmd_argv, cur,
d112 1
a112 1
		*cmd_argv = xrealloc(*cmd_argv, cur,
@


1.152
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.151 2011/07/12 21:00:32 sobrado Exp $	*/
d238 2
a239 1
			/* XXX - Check with -u flag. */
d241 1
d278 2
a279 1
			/* XXX - Check with -l flag. */
d281 1
@


1.151
log
@argument to -t is optional.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.150 2010/12/06 22:47:56 chl Exp $	*/
d161 1
a161 1
void
d168 2
a229 1
				exit(1);
a293 1
			exit(1);
a302 1
		exit(1);
@


1.150
log
@add missing header to properly use SIG* definitions

ok tobias@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.149 2010/09/08 15:15:50 tobias Exp $	*/
d167 1
a167 1
	    "           [-orev] [-tstr] [-u[rev]] [-xsuffixes] file ...\n");
@


1.149
log
@Set rcs_suffixes to default value on initialization.

ok ray zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.148 2010/07/23 08:31:19 ray Exp $	*/
d30 1
@


1.148
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.147 2009/02/15 12:58:01 joris Exp $	*/
d44 1
a44 1
char	*rcs_suffixes;
@


1.147
log
@bump version to match next release
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.146 2008/11/09 12:34:47 tobias Exp $	*/
d63 1
a63 1
struct rcs_wklhead rcs_temp_files;
d72 1
a72 1
	rcs_worklist_clean(&rcs_temp_files, rcs_worklist_unlink);
d132 1
a132 1
	SLIST_INIT(&rcs_temp_files);
d154 1
a154 1
	rcs_worklist_run(&rcs_temp_files, rcs_worklist_unlink);
@


1.146
log
@typo fixed (overriden -> overridden)

ok espie, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.145 2008/07/08 12:25:47 joris Exp $	*/
d39 1
a39 1
const char rcs_version[] = "OpenRCS 4.4";
@


1.145
log
@bump version to 4.4
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.144 2008/05/10 19:54:58 tobias Exp $	*/
d232 1
a232 1
				warnx("-U overriden by -L");
d270 1
a270 1
				warnx("-L overriden by -U");
@


1.144
log
@OpenRCS only handled a max of 128 arguments on command line + RCSINIT,
which was a bogus limit.  Spotted by naddy.

horribly prodded by and ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.142 2008/04/24 19:16:49 tobias Exp $	*/
d39 1
a39 1
const char rcs_version[] = "OpenRCS 4.3";
@


1.143
log
@Duplicate envstr and free it on error instead of allocating for
each argument and freeing each argument on error.

OK joris, tobias
@
text
@a36 1
#define RCS_CMD_MAXARG	128
d77 1
a77 1
rcs_init(char *envstr, char **argv, int argvlen)
d79 2
a80 2
	int argc, error;
	char *linebuf, *lp, *cp;
d82 9
a90 2
	linebuf = xstrdup(envstr);
	(void)memset(argv, 0, argvlen * sizeof(char *));
d92 1
a92 1
	error = argc = 0;
d97 1
a97 1
		else if (*cp == '\0')
d100 4
a103 3
		if (argc == argvlen) {
			error++;
			break;
d106 1
a106 2
		argv[argc] = cp;
		argc++;
d109 4
a112 3
	if (error != 0) {
		xfree(linebuf);
		argc = -1;
d115 6
a120 1
	return (argc);
d127 1
a127 1
	char *rcsinit, *cmd_argv[RCS_CMD_MAXARG];
d134 1
a134 10
	cmd_argc = 0;
	cmd_argv[cmd_argc++] = argv[0];
	if ((rcsinit = getenv("RCSINIT")) != NULL) {
		ret = rcs_init(rcsinit, cmd_argv + 1,
		    RCS_CMD_MAXARG - 1);
		if (ret < 0)
			errx(1, "failed to prepend RCSINIT options");

		cmd_argc += ret;
	}
a137 5

	if (argc + cmd_argc >= RCS_CMD_MAXARG)
		errx(1, "too many arguments");
	for (ret = 1; ret < argc; ret++)
		cmd_argv[cmd_argc++] = argv[ret];
@


1.142
log
@Prevent overflow of cmd_argv if RCS_INIT and command line arguments
exceed buffer size (diff based on OpenCVS code).

ok ray, xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.141 2008/03/04 16:43:51 joris Exp $	*/
a79 1
	u_int i;
d81 1
a81 1
	char linebuf[256],  *lp, *cp;
d83 1
a83 2
	if (strlcpy(linebuf, envstr, sizeof(linebuf)) >= sizeof(linebuf))
		errx(1, "rcs_init: string truncation");
d99 1
a99 1
		argv[argc] = xstrdup(cp);
d104 1
a104 2
		for (i = 0; i < (u_int)argc; i++)
			xfree(argv[i]);
@


1.141
log
@fix segfault when trying to lock and unlock rcs files that
contain no revisions.

reported by Jean Raby.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.140 2008/02/24 15:13:18 xsa Exp $	*/
d130 2
a131 4
		if (ret < 0) {
			warnx("failed to prepend RCSINIT options");
			exit (1);
		}
d139 2
@


1.140
log
@Bump version. Improvements and fixes since last release.
OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.139 2007/06/30 08:23:49 xsa Exp $	*/
d439 6
d470 6
@


1.139
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.138 2007/04/26 21:51:04 sobrado Exp $	*/
d40 1
a40 1
const char rcs_version[] = "OpenRCS 4.1";
@


1.138
log
@`[-sstate[:rev]]' is not available in rcs(1)

ok by jmc@@, niallo@@, and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.137 2007/02/27 07:59:13 xsa Exp $	*/
d437 1
a437 1
			char rev_str[16];
d463 1
a463 1
			char rev_str[16];
d493 1
a493 1
			char b[16];
d533 1
a533 1
	char rbuf[16];
@


1.137
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.136 2007/01/10 18:04:25 joris Exp $	*/
d171 1
a171 2
	    "           [-orev] [-sstate[:rev]] [-tstr] [-u[rev]]\n"
	    "           [-xsuffixes] file ...\n");
@


1.136
log
@you know what, now that openrcs is in fact working properly and
has been in the previous release - how about we give it a proper
version instead of "OpenCVS RCS 3.6"

okay xsa@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.135 2006/12/27 07:43:24 niallo Exp $	*/
d27 7
a33 1
#include "includes.h"
@


1.135
log
@- no need to mention -e option twice in usage.

pointed out by Igor Sobrado <igor at string1.ciencias.uniovi.es>
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.134 2006/11/13 11:22:57 xsa Exp $	*/
d34 1
a34 1
const char rcs_version[] = "OpenCVS RCS version 3.6";
@


1.134
log
@no magic, use defined RCS_LOCK_INVAL variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.133 2006/10/12 17:20:12 niallo Exp $	*/
d163 1
a163 1
	    "usage: rcs [-eIiLqTUV] [-Aoldfile] [-ausers] [-b[rev]]\n"
@


1.133
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.132 2006/08/16 07:39:15 ray Exp $	*/
d191 1
a191 1
	lkmode = -1;
d426 1
a426 1
		if (lkmode != -1)
@


1.132
log
@Improve rcs_buf_load() by setting errno appropriately on failure and
never print errors or quit on error.

Fix usages of rcs_buf_load() and rcs_set_description.

Also plug an fd leak.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.131 2006/05/29 21:17:44 ray Exp $	*/
d308 1
a308 1
			warnx("%s", fpath);
d375 1
a375 1
					warnx("%s", ofpath);
@


1.131
log
@Plug more memory leaks.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.130 2006/05/28 23:16:31 ray Exp $	*/
d315 2
a316 1
		if ((file = rcs_open(fpath, fd, flags, fmode)) == NULL)
d318 1
d320 14
a333 4
		if (rcsflags & DESCRIPTION)
			rcs_set_description(file, descfile);
		else if (flags & RCS_CREATE)
			rcs_set_description(file, NULL);
@


1.130
log
@Remove a lot of xstrdup() calls in getopt() loops, which are usually
unnecessary.  These xstrdup() calls don't call xfree() before anyway,
so if a flag is given multiple times memory leaks would have resulted.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.129 2006/05/28 18:55:55 ray Exp $	*/
d241 2
a506 3

	if (logstr != NULL)
		xfree(logstr);
@


1.129
log
@Move -A<oldfile> handling into separate chunk of code.  This also
removes a memory leak if -A is given multiple times.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.128 2006/05/27 05:49:14 ray Exp $	*/
d180 1
a180 1
	const char *oldfilename;
d182 2
a183 2
	char *logstr, *logmsg, *nflag, *descfile;
	char *alist, *comment, *elist, *lrev, *urev, *orange;
d194 3
a196 3
	lrev = urev = descfile = nflag = NULL;
	logstr = alist = comment = elist = orange = NULL;
	oldfilename = NULL;
d247 1
a247 1
			nflag = xstrdup(rcs_optarg);
d250 1
a250 1
			nflag = xstrdup(rcs_optarg);
d254 1
a254 1
			orange = xstrdup(rcs_optarg);
a507 6

	if (nflag != NULL)
		xfree(nflag);

	if (orange != NULL)
		xfree(orange);
@


1.128
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.127 2006/05/19 07:52:38 xsa Exp $	*/
d178 1
a178 1
	int fd, ofd;
d180 2
a181 1
	char fpath[MAXPATHLEN], ofpath[MAXPATHLEN];
d185 1
a185 1
	RCSFILE *file, *oldfile;
d196 1
a202 1
	ofd = -1;
d206 1
a206 8
			/* XXX - Should we process this after all flags? */
			ofd = rcs_choosefile(rcs_optarg, ofpath,
			    sizeof(ofpath));
			if (ofd < 0) {
				if (!(flags & RCS_CREATE))
					warnx("%s", ofpath);
				exit(1);
			}
d354 10
a363 1
			/* XXX */
d371 1
a371 1
			ofd = -1;
a513 3

	if (ofd != -1)
		(void)close(ofd);
@


1.127
log
@fix printf + add missing printf when unlocking file (-u).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.126 2006/05/15 06:58:03 xsa Exp $	*/
d205 6
a210 3
			ofd = rcs_statfile(rcs_optarg, ofpath,
			    sizeof(ofpath), flags);
			if (ofd < 0)
d212 1
d310 3
a312 2
		fd = rcs_statfile(argv[i], fpath, sizeof(fpath), flags);
		if (fd < 0 && !(flags & RCS_CREATE))
d314 1
@


1.126
log
@missing bits for a working merge(1). Built and enabled.
OK joris@@ ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.125 2006/05/11 09:43:19 xsa Exp $	*/
d428 1
a428 1
				printf("%s locked\n", rev_str);
d455 5
@


1.125
log
@fix informative msg's wrt to -q and stderr. now matches gnu/usr.bin/rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.124 2006/05/09 12:33:42 ray Exp $	*/
d55 1
@


1.124
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.123 2006/05/01 18:07:00 joris Exp $	*/
d310 1
a310 1
			printf("RCS file: %s\n", fpath);
d471 4
a474 1
					printf("deleting revision %s\n", b);
d488 1
a488 1
			printf("done\n");
@


1.123
log
@using *_FOREACH macros is really bad when we are actually
removing elements from the list inside the loop.

this has been documented *clearly* in queue(3).
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.122 2006/04/29 05:31:28 ray Exp $	*/
a154 1
	/* NOTREACHED */
a279 1
			/* NOTREACHED */
@


1.122
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.121 2006/04/29 05:10:16 ray Exp $	*/
d460 1
a460 1
			struct rcs_delta *rdp;
d464 4
a467 1
			TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
@


1.121
log
@Clarify man pages to match -t behavior and pretty up usage strings.

OK xsa@@ and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.120 2006/04/28 22:26:08 jmc Exp $	*/
d77 3
a79 2
	strlcpy(linebuf, envstr, sizeof(linebuf));
	memset(argv, 0, argvlen * sizeof(char *));
@


1.120
log
@remove -h; ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.119 2006/04/27 07:54:15 jmc Exp $	*/
d164 1
a164 1
	    "           [-orev] [-sstate[:rev]] [-tfile|str] [-u[rev]]\n"
@


1.119
log
@move -M into compat land; ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.118 2006/04/26 21:55:22 joris Exp $	*/
d162 1
a162 1
	    "usage: rcs [-ehIiLqTUV] [-Aoldfile] [-ausers] [-b[rev]]\n"
@


1.118
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.117 2006/04/26 02:55:13 joris Exp $	*/
d162 1
a162 1
	    "usage: rcs [-ehIiLMqTUV] [-Aoldfile] [-ausers] [-b[rev]]\n"
d164 1
a164 1
	    "           [-orange] [-sstate[:rev]] [-tfile|str] [-u[rev]]\n"
@


1.117
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.116 2006/04/25 13:55:49 xsa Exp $	*/
d177 1
d200 1
d204 3
a206 2
			if (rcs_statfile(rcs_optarg, ofpath,
			    sizeof(ofpath), flags) < 0)
d306 2
a307 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath), flags) < 0)
d313 1
a313 1
		if ((file = rcs_open(fpath, flags, fmode)) == NULL)
d322 1
a322 1
			rcs_mtime = rcs_get_mtime(file->rf_path);
d355 1
a355 1
			if ((oldfile = rcs_open(ofpath, RCS_READ)) == NULL)
d362 1
d475 1
a475 1
		rcs_close(file);
d478 3
a480 1
			rcs_set_mtime(fpath, rcs_mtime);
d494 3
@


1.116
log
@quote strings consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.115 2006/04/25 13:36:35 xsa Exp $	*/
d57 1
a57 1
struct cvs_wklhead rcs_temp_files;
d66 1
a66 1
	cvs_worklist_clean(&rcs_temp_files, cvs_worklist_unlink);
d151 1
a151 1
	cvs_worklist_run(&rcs_temp_files, cvs_worklist_unlink);
d362 1
a362 1
			struct cvs_argvector *aargv;
d364 1
a364 1
			aargv = cvs_strsplit(alist, ",");
d368 1
a368 1
			cvs_argv_destroy(aargv);
d375 1
a375 1
			struct cvs_argvector *eargv;
d377 1
a377 1
			eargv = cvs_strsplit(elist, ",");
d381 1
a381 1
			cvs_argv_destroy(eargv);
@


1.115
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.114 2006/04/24 08:10:41 xsa Exp $	*/
d332 1
a332 1
				warnx("'%s' bad revision number", logstr);
d338 1
a338 1
				warnx("failed to set logmsg for '%s' to '%s'",
@


1.114
log
@be consistent in error messages for wrongly specified keyword substitution
mode for `-k'.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.113 2006/04/24 04:51:57 ray Exp $	*/
d407 1
a407 1
				fatal("could not get username");
d419 2
a420 2
				fatal("%s: can't lock nonexisting revision %s",
				    fpath, rev_str);
d433 1
a433 1
				fatal("could not get username");
d445 2
a446 2
				fatal("%s: can't unlock nonexisting revision %s",
				    fpath, rev_str);
d511 1
a511 1
			fatal("bad revision %s", rnum);
d521 1
a521 1
				warnx("can't delete nonexisting symbol %s",
d534 1
a534 1
			fatal("symbolic name %s already bound to %s",
@


1.113
log
@o Better match GNU behavior (a bare -t does NOT read from stdin,
  unlike rcs).
o Share code with rcs by moving rcs_set_description() to rcsutil.c.
o Change description prompt from #define to const char *.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.112 2006/04/21 17:17:29 xsa Exp $	*/
d223 2
a224 2
				warnx("invalid keyword substitution "
				    "mode `%s'", rcs_optarg);
@


1.112
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.111 2006/04/21 14:42:12 xsa Exp $	*/
a33 3
#define DESC_PROMPT	"enter description, terminated with single '.' "      \
			"or end of file:\nNOTE: This is NOT the log message!\n"

a59 1
static void  rcs_set_description(RCSFILE *, const char *);
d259 1
a259 1
			rcsflags |= RCSPROG_TFLAG;
d312 1
a312 1
		if (rcsflags & RCSPROG_TFLAG)
a537 29
}

/*
 * Load description from <in> to <file>.
 * If <in> starts with a `-', <in> is taken as the description.
 * Otherwise <in> is the name of the file containing the description.
 * If <in> is NULL, the description is read from stdin.
 */
static void
rcs_set_description(RCSFILE *file, const char *in)
{
	BUF *bp;
	char *content;

	/* Description is in file <in>. */
	if (in != NULL && *in != '-') {
		bp = cvs_buf_load(in, BUF_AUTOEXT);
		cvs_buf_putc(bp, '\0');
		content = cvs_buf_release(bp);
	/* Description is in <in>. */
	} else if (in != NULL)
		/* Skip leading `-'. */
		content = xstrdup(in + 1);
	/* Get description from stdin. */
	else
		content = rcs_prompt(DESC_PROMPT);

	rcs_desc_set(file, content);
	xfree(content);
@


1.111
log
@match former rcs implementation warning message if no options are
specified when using rcs(1). OK ray@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.110 2006/04/21 14:18:26 xsa Exp $	*/
a38 1
int	 flags;
a73 51
/*
 * Allocate an RCSNUM and store in <rev>.
 */
void
rcs_set_rev(const char *str, RCSNUM **rev)
{
	if (str == NULL || (*rev = rcsnum_parse(str)) == NULL)
		fatal("bad revision number '%s'", str);
}

/*
 * rcs_get_mtime()
 *
 * Get <filename> last modified time.
 * Returns last modified time on success, or -1 on failure.
 */
time_t
rcs_get_mtime(const char *filename)
{
	struct stat st;
	time_t mtime;

	if (stat(filename, &st) == -1) {
		warn("%s", filename);
		return (-1);
	}
	mtime = (time_t)st.st_mtimespec.tv_sec;

	return (mtime);
}

/*
 * rcs_set_mtime()
 *
 * Set <filename> last modified time to <mtime> if it's not set to -1.
 */
void
rcs_set_mtime(const char *filename, time_t mtime)
{
	static struct timeval tv[2];

	if (mtime == -1)
		return;

	tv[0].tv_sec = mtime;
	tv[1].tv_sec = tv[0].tv_sec;

	if (utimes(filename, tv) == -1)
		fatal("error setting utimes: %s", strerror(errno));
}

a110 255
rcs_getopt(int argc, char **argv, const char *optstr)
{
	char *a;
	const char *c;
	static int i = 1;
	int opt, hasargument, ret;

	hasargument = 0;
	rcs_optarg = NULL;

	if (i >= argc)
		return (-1);

	a = argv[i++];
	if (*a++ != '-')
		return (-1);

	ret = 0;
	opt = *a;
	for (c = optstr; *c != '\0'; c++) {
		if (*c == opt) {
			a++;
			ret = opt;

			if (*(c + 1) == ':') {
				if (*(c + 2) == ':') {
					if (*a != '\0')
						hasargument = 1;
				} else {
					if (*a != '\0') {
						hasargument = 1;
					} else {
						ret = 1;
						break;
					}
				}
			}

			if (hasargument == 1)
				rcs_optarg = a;

			if (ret == opt)
				rcs_optind++;
			break;
		}
	}

	if (ret == 0)
		warnx("unknown option -%c", opt);
	else if (ret == 1)
		warnx("missing argument for option -%c", opt);

	return (ret);
}

/*
 * rcs_choosefile()
 *
 * Given a relative filename, decide where the corresponding RCS file
 * should be.  Tries each extension until a file is found.  If no file
 * was found, returns a path with the first extension.
 *
 * Returns pointer to a char array on success, NULL on failure.
 */
char *
rcs_choosefile(const char *filename)
{
	struct stat sb;
	char *p, *ext, name[MAXPATHLEN], *next, *ptr, rcsdir[MAXPATHLEN],
	    *ret, *suffixes, rcspath[MAXPATHLEN];

	/* If -x flag was not given, use default. */
	if (rcs_suffixes == NULL)
		rcs_suffixes = RCS_DEFAULT_SUFFIX;

	/*
	 * If `filename' contains a directory, `rcspath' contains that
	 * directory, including a trailing slash.  Otherwise `rcspath'
	 * contains an empty string.
	 */
	if (strlcpy(rcspath, filename, sizeof(rcspath)) >= sizeof(rcspath))
		return (NULL);
	/* If `/' is found, end string after `/'. */
	if ((ptr = strrchr(rcspath, '/')) != NULL)
		*(++ptr) = '\0';
	else
		rcspath[0] = '\0';

	/* Append RCS/ to `rcspath' if it exists. */
	if (strlcpy(rcsdir, rcspath, sizeof(rcsdir)) >= sizeof(rcsdir) ||
	    strlcat(rcsdir, RCSDIR, sizeof(rcsdir)) >= sizeof(rcsdir))
		return (NULL);
	if (stat(rcsdir, &sb) == 0 && (sb.st_mode & S_IFDIR))
		if (strlcpy(rcspath, rcsdir, sizeof(rcspath)) >= sizeof(rcspath) ||
		    strlcat(rcspath, "/", sizeof(rcspath)) >= sizeof(rcspath))
			return (NULL);

	/* Name of file without path. */
	if ((ptr = strrchr(filename, '/')) == NULL) {
		if (strlcpy(name, filename, sizeof(name)) >= sizeof(name))
			return (NULL);
	} else {
		/* Skip `/'. */
		if (strlcpy(name, ptr + 1, sizeof(name)) >= sizeof(name))
			return (NULL);
	}

	/* Name of RCS file without an extension. */
	if (strlcat(rcspath, name, sizeof(rcspath)) >= sizeof(rcspath))
		return (NULL);

	/*
	 * If only the empty suffix was given, use existing rcspath.
	 * This ensures that there is at least one suffix for strsep().
	 */
	if (strcmp(rcs_suffixes, "") == 0) {
		ret = xstrdup(rcspath);
		return (ret);
	}

	/*
	 * Cycle through slash-separated `rcs_suffixes', appending each
	 * extension to `rcspath' and testing if the file exists.  If it
	 * does, return that string.  Otherwise return path with first
	 * extension.
	 */
	suffixes = xstrdup(rcs_suffixes);
	for (ret = NULL, next = suffixes; (ext = strsep(&next, "/")) != NULL;) {
		char fpath[MAXPATHLEN];

		if ((p = strrchr(rcspath, ',')) != NULL) {
			if (!strcmp(p, ext)) {
				if (stat(rcspath, &sb) == 0) {
					ret = xstrdup(rcspath);
					goto out;
				}
			}

			continue;
		}

		/* Construct RCS file path. */
		if (strlcpy(fpath, rcspath, sizeof(fpath)) >= sizeof(fpath) ||
		    strlcat(fpath, ext, sizeof(fpath)) >= sizeof(fpath))
			goto out;

		/* Don't use `filename' as RCS file. */
		if (strcmp(fpath, filename) == 0)
			continue;

		if (stat(fpath, &sb) == 0) {
			ret = xstrdup(fpath);
			goto out;
		}
	}

	/*
	 * `ret' is still NULL.  No RCS file with any extension exists
	 * so we use the first extension.
	 *
	 * `suffixes' should now be NUL separated, so the first
	 * extension can be read just by reading `suffixes'.
	 */
	if (strlcat(rcspath, suffixes, sizeof(rcspath)) >=
	    sizeof(rcspath))
		goto out;
	ret = xstrdup(rcspath);

out:
	/* `ret' may be NULL, which indicates an error. */
	xfree(suffixes);
	return (ret);
}

/*
 * Find the name of an RCS file, given a file name `fname'.  If an RCS
 * file is found, the name is copied to the `len' sized buffer `out'.
 * Returns 0 if RCS file was found, -1 otherwise.
 */
int
rcs_statfile(char *fname, char *out, size_t len)
{
	struct stat st;
	char *rcspath;

	if ((rcspath = rcs_choosefile(fname)) == NULL)
		fatal("rcs_statfile: path truncation");

	/* Error out if file not found and we are not creating one. */
	if (stat(rcspath, &st) == -1 && !(flags & RCS_CREATE)) {
		if (strcmp(__progname, "rcsclean") != 0 &&
		    strcmp(__progname, "ci") != 0)
			warn("%s", rcspath);
		xfree(rcspath);
		return (-1);
	}

	if (strlcpy(out, rcspath, len) >= len)
		fatal("rcs_statfile: path truncation");

	xfree(rcspath);

	return (0);
}

/*
 * Set <str> to <new_str>.  Print warning if <str> is redefined.
 */
void
rcs_setrevstr(char **str, char *new_str)
{
	if (new_str == NULL)
		return;
	if (*str != NULL)
		warnx("redefinition of revision number");
	*str = new_str;
}

/*
 * Set <str1> or <str2> to <new_str>, depending on which is not set.
 * If both are set, error out.
 */
void
rcs_setrevstr2(char **str1, char **str2, char *new_str)
{
	if (new_str == NULL)
		return;
	if (*str1 == NULL)
		*str1 = new_str;
	else if (*str2 == NULL)
		*str2 = new_str;
	else
		fatal("too many revision numbers");
}

/*
 * Get revision from file.  The revision can be specified as a symbol or
 * a revision number.
 */
RCSNUM *
rcs_getrevnum(const char *rev_str, RCSFILE *file)
{
	RCSNUM *rev;

	/* Search for symbol. */
	rev = rcs_sym_getrev(file, rev_str);

	/* Search for revision number. */
	if (rev == NULL)
		rev = rcsnum_parse(rev_str);

	return (rev);
}

int
d181 1
a181 1
	int i, j, ch, kflag, lkmode;
d206 2
a207 1
			if (rcs_statfile(rcs_optarg, ofpath, sizeof(ofpath)) < 0)
d307 1
a307 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
a570 107
}

/*
 * Prompt for and store user's input in an allocated string.
 *
 * Returns the string's pointer.
 */
char *
rcs_prompt(const char *prompt)
{
	BUF *bp;
	size_t len;
	char *buf;

	bp = cvs_buf_alloc(0, BUF_AUTOEXT);
	if (isatty(STDIN_FILENO))
		(void)fprintf(stderr, "%s", prompt);
	if (isatty(STDIN_FILENO))
		(void)fprintf(stderr, ">> ");
	while ((buf = fgetln(stdin, &len)) != NULL) {
		/* The last line may not be EOL terminated. */
		if (buf[0] == '.' && (len == 1 || buf[1] == '\n'))
			break;
		else
			cvs_buf_append(bp, buf, len);

		if (isatty(STDIN_FILENO))
			(void)fprintf(stderr, ">> ");
	}
	cvs_buf_putc(bp, '\0');

	return (cvs_buf_release(bp));
}

u_int
rcs_rev_select(RCSFILE *file, char *range)
{
	int i;
	u_int nrev;
	char *ep;
	char *lstr, *rstr;
	struct rcs_delta *rdp;
	struct cvs_argvector *revargv, *revrange;
	RCSNUM lnum, rnum;

	nrev = 0;
	(void)memset(&lnum, 0, sizeof(lnum));
	(void)memset(&rnum, 0, sizeof(rnum));

	if (range == NULL) {
		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, file->rf_head, 0) == 0) {
				rdp->rd_flags |= RCS_RD_SELECT;
				return (1);
			}
		return (0);
	}

	revargv = cvs_strsplit(range, ",");
	for (i = 0; revargv->argv[i] != NULL; i++) {
		revrange = cvs_strsplit(revargv->argv[i], ":");
		if (revrange->argv[0] == NULL)
			/* should not happen */
			fatal("invalid revision range: %s", revargv->argv[i]);
		else if (revrange->argv[1] == NULL)
			lstr = rstr = revrange->argv[0];
		else {
			if (revrange->argv[2] != NULL)
				fatal("invalid revision range: %s",
					revargv->argv[i]);
			lstr = revrange->argv[0];
			rstr = revrange->argv[1];
			if (strcmp(lstr, "") == 0)
				lstr = NULL;
			if (strcmp(rstr, "") == 0)
				rstr = NULL;
		}

		if (lstr == NULL)
			lstr = RCS_HEAD_INIT;
		if (rcsnum_aton(lstr, &ep, &lnum) == 0 || (*ep != '\0'))
			fatal("invalid revision: %s", lstr);

		if (rstr != NULL) {
			if (rcsnum_aton(rstr, &ep, &rnum) == 0 || (*ep != '\0'))
				fatal("invalid revision: %s", rstr);
		} else
			rcsnum_cpy(file->rf_head, &rnum, 0);

		cvs_argv_destroy(revrange);

		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, &lnum, 0) <= 0 &&
			    rcsnum_cmp(rdp->rd_num, &rnum, 0) >= 0 &&
			    !(rdp->rd_flags & RCS_RD_SELECT)) {
				rdp->rd_flags |= RCS_RD_SELECT;
				nrev++;
			}
	}
	cvs_argv_destroy(revargv);

	if (lnum.rn_id != NULL)
		xfree(lnum.rn_id);
	if (rnum.rn_id != NULL)
		xfree(rnum.rn_id);

	return (nrev);
@


1.110
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.109 2006/04/21 07:06:25 xsa Exp $	*/
d504 5
@


1.109
log
@switch -p handling to bitwise flags; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.108 2006/04/19 06:53:41 xsa Exp $	*/
d98 1
a98 1
		cvs_log(LP_ERRNO, "failed to stat `%s'", filename);
d211 1
a211 1
		cvs_log(LP_ERR, "unknown option -%c", opt);
d213 1
a213 1
		cvs_log(LP_ERR, "missing argument for option -%c", opt);
d355 1
a355 1
			cvs_log(LP_ERRNO, "%s", rcspath);
d377 1
a377 1
		cvs_log(LP_WARN, "redefinition of revision number");
a425 1
	cvs_log_init(LD_STD, 0);
d434 1
a434 1
			cvs_log(LP_ERRNO, "failed to prepend RCSINIT options");
d528 2
a529 3
				cvs_log(LP_ERR,
				    "invalid keyword substitution mode `%s'",
				    rcs_optarg);
d535 1
a535 1
				cvs_log(LP_WARN, "-U overriden by -L");
d571 1
a571 1
				cvs_log(LP_WARN, "-L overriden by -U");
d602 1
a602 1
		cvs_log(LP_ERR, "no input file");
d630 1
a630 1
				cvs_log(LP_ERR, "missing log message");
d637 1
a637 2
				cvs_log(LP_ERR,
				    "'%s' bad revision number", logstr);
d643 1
a643 2
				cvs_log(LP_ERR,
				    "failed to set logmsg for '%s' to '%s'",
d717 1
a717 1
				cvs_log(LP_ERR, "unable to unlock file");
d743 1
a743 1
				cvs_log(LP_ERR, "unable to unlock file");
d754 1
a754 2
				cvs_log(LP_ERR,
				    "%s: warning: No locks are set.", fpath);
d826 2
a827 2
				cvs_log(LP_WARN,
				    "can't delete nonexisting symbol %s", symname);
@


1.108
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.107 2006/04/18 03:35:57 ray Exp $	*/
a37 1
int pipeout = 0;
@


1.107
log
@Combine code to prompt user for input into a shared function,
reducing some complex fats from ci.c.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.106 2006/04/18 02:46:21 ray Exp $	*/
a37 1
int verbose = 1;
d563 1
a563 1
			verbose = 0;
d614 1
a614 1
		if (verbose == 1)
d732 1
a732 1
			    verbose == 1)
d758 1
a758 1
			    verbose == 1)
d786 1
a786 1
		if (verbose == 1)
@


1.106
log
@Remove -h flag from rcs_getopt loop, which is not in GNU.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.105 2006/04/17 12:11:07 xsa Exp $	*/
d35 1
a35 2
			"or end of file:\nNOTE: This is NOT the log message!" \
			"\n>> "
d862 1
a862 1
	char *content, buf[128];
a863 1
	content = NULL;
d865 1
a865 1
	if (in != NULL && *in != '-')
d867 2
d870 6
a875 3
	else if (in != NULL) {
		size_t len;
		const char *desc;
d877 15
a891 3
		/* Skip leading `-'. */
		desc = in + 1;
		len = strlen(desc);
d893 11
a903 5
		bp = cvs_buf_alloc(len + 1, BUF_AUTOEXT);
		cvs_buf_append(bp, desc, len);
	/* Get description from stdin. */
	} else {
		bp = cvs_buf_alloc(64, BUF_AUTOEXT);
d906 1
a906 12
			(void)fprintf(stderr, "%s", DESC_PROMPT);
		for (;;) {
			/* XXX - fgetln() may be more elegant. */
			fgets(buf, sizeof(buf), stdin);
			if (feof(stdin) || ferror(stdin) ||
			    strcmp(buf, ".\n") == 0 ||
			    strcmp(buf, ".") == 0)
				break;
			cvs_buf_append(bp, buf, strlen(buf));
			if (isatty(STDIN_FILENO))
				(void)fprintf(stderr, ">> ");
		}
a907 1

a908 1
	content = cvs_buf_release(bp);
d910 1
a910 2
	rcs_desc_set(file, content);
	xfree(content);
@


1.105
log
@plug memory leak; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.104 2006/04/15 19:35:19 xsa Exp $	*/
d32 1
a32 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Ll::m:Mn:N:o:qt::TUu::Vx::z::"
a525 4
		case 'h':
			(usage)();
			exit(0);
			/* NOTREACHED */
@


1.104
log
@dont stupidly duplicate code. make rlog use rcs_rev_select() and thus
nuke rlog_rev_select(). OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.103 2006/04/14 23:29:01 joris Exp $	*/
d801 3
@


1.103
log
@- don't append the extension if it's already there (PR 5076).
- show magic branches in rlog (thanks for that nicer hack niall).
- correct output in rcsdiff, so we perfectly match gnu's

all these bugs were found by sturm@@ while he was using cvsweb
(which uses the RCS tools).

"it is in my view that you should put it in" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.102 2006/04/14 01:11:07 deraadt Exp $	*/
a68 1
static u_int rcs_rev_select(RCSFILE *, char *);
d907 1
a907 1
static u_int
@


1.102
log
@excessive addition to brackets is a mental disease.  you will go
blind, too.  seek help.  no binary change, ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.101 2006/04/13 19:55:41 joris Exp $	*/
d235 1
a235 1
	char *ext, name[MAXPATHLEN], *next, *ptr, rcsdir[MAXPATHLEN],
d297 11
a351 1
	/* XXX - do this in rcs_choosefile? */
@


1.101
log
@add support for the openrcs -o'range' option.
-o allows users to delete revisions in the specified RCS files.

example:
	rcs -o1.4:1.6 foo deletes revisions 1.4 - 1.6
	rcs -o1.3 foo deletes revision 1.3

joint work with niallo@@
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.100 2006/04/13 16:10:29 joris Exp $	*/
d259 1
a259 1
	if ((stat(rcsdir, &sb) == 0) && (sb.st_mode & S_IFDIR))
d347 2
a348 2
		if ((strcmp(__progname, "rcsclean") != 0)
		    && (strcmp(__progname, "ci") != 0))
d824 1
a824 1
			if ((rcs_errno == RCS_ERR_NOENT) &&
d835 2
a836 2
		if ((rcs_sym_add(file, symname, rev) < 0) &&
		    (rcs_errno == RCS_ERR_DUPENT)) {
d956 2
a957 2
			if ((rcsnum_cmp(rdp->rd_num, &lnum, 0) <= 0) &&
			    (rcsnum_cmp(rdp->rd_num, &rnum, 0) >= 0) &&
@


1.100
log
@clean up temporary files when we finish running.
"cool" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.99 2006/04/13 00:58:25 ray Exp $	*/
d32 1
a32 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Ll::m:Mn:N:qt::TUu::Vx::z::"
d67 3
a69 2
static void rcs_set_description(RCSFILE *, const char *);
static void rcs_attach_symbol(RCSFILE *, const char *);
d470 1
a470 1
	    "           [-orev] [-sstate[:rev]] [-tfile|str] [-u[rev]]\n"
d486 1
a486 1
	char *alist, *comment, *elist, *lrev, *urev;
d498 1
a498 1
	logstr = alist = comment = elist = NULL;
d556 3
d761 17
d896 75
@


1.99
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.98 2006/04/12 22:54:23 ray Exp $	*/
d454 3
@


1.98
log
@Better match GNU behavior for rcs -l and rcs -u.
Save 2 bytes of newlines.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.97 2006/04/12 08:23:30 ray Exp $	*/
d389 19
@


1.97
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.96 2006/04/11 08:07:35 ray Exp $	*/
d685 1
d697 1
d700 5
a704 3
				fatal("revision does not exist");
			if (rcs_lock_add(file, username, rev) == -1)
				fatal("unable to lock file");
d711 1
d723 1
d726 6
a731 3
				fatal("revision does not exist");
			if (rcs_lock_remove(file, username, rev) == -1)
				fatal("unable to unlock file");
@


1.96
log
@Don't rcs_close() before fatal().  After much hesitation, joris@@
and xsa@@ finally convinced me this is safe (and better).

OK joris@@, niallo@@, and xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.95 2006/04/10 08:08:00 xsa Exp $	*/
d78 3
d84 1
a84 7
	if (str == NULL)
		return;

	if ((*rev != NULL) && (*rev != RCS_HEAD_REV))
		cvs_log(LP_WARN, "redefinition of revision number");

	if ((*rev = rcsnum_parse(str)) == NULL)
d359 30
@


1.95
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.94 2006/04/07 12:54:40 xsa Exp $	*/
d672 1
a672 2
			if (rcs_lock_add(file, username, rev) == -1) {
				rcs_close(file);
a673 1
			}
d694 1
a694 2
			if (rcs_lock_remove(file, username, rev) == -1) {
				rcs_close(file);
a695 1
			}
@


1.94
log
@change rcs_set_mtime() return type to void.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.93 2006/04/06 10:13:00 xsa Exp $	*/
d443 2
a444 1
	kflag = lkmode = -1;
d650 1
a650 2
		if (kflag != -1)
			rcs_kwexp_set(file, kflag);
@


1.93
log
@-z can take no argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.92 2006/04/01 06:19:29 ray Exp $	*/
a115 1
 * Returns 0 on success, or -1 on failure.
d117 1
a117 1
int
d123 1
a123 1
		return (0);
d128 2
a129 6
	if (utimes(filename, tv) == -1) {
		cvs_log(LP_ERRNO, "error setting utimes");
		return (-1);
	}

	return (0);
@


1.92
log
@Add rcs -l, rcs -u, and regression tests.

``put it all in'' joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.91 2006/04/01 05:58:17 ray Exp $	*/
d32 1
a32 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Ll::m:Mn:N:qt::TUu::Vx::z:"
@


1.91
log
@Keep cvs flags in `flags', rcs flags in `rcsflags' in rcsprog.h.
Prevents bitfield pollution between the two.

``This is how it should be.'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.90 2006/03/28 09:51:09 xsa Exp $	*/
d32 1
a32 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Lm:Mn:N:qt::TUVx::z:"
d424 2
a425 2
	    "           [-cstring] [-e[users]] [-kmode] [-mrev:msg]\n"
	    "           [-orev] [-sstate[:rev]] [-tfile|str]\n"
d441 1
a441 1
	char *alist, *comment, *elist;
d451 1
a451 1
	descfile = nflag = NULL;
d492 5
d525 5
d659 48
@


1.90
log
@shudup rcs_set_description(), so regress tests are happy too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.89 2006/03/27 21:56:32 niallo Exp $	*/
a41 5
#define RCSPROG_EFLAG	(1<<0)
#define RCSPROG_NFLAG	(1<<1)
#define RCSPROG_TFLAG	(1<<2)
static int rcsflags = 0;

d43 1
@


1.89
log
@- properly implement GNU file modes.  basically, checkout will inherit
permissions from rcs file and initial checkin will inherit permissions from
working file.

problem spotted by uwe@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.88 2006/03/27 08:21:01 ray Exp $	*/
d752 2
a753 1
		printf(DESC_PROMPT);
d762 2
a763 1
			printf(">> ");
@


1.88
log
@Fix and clean up -t flag:
 - Add comments.
 - Support -t-inline-comments-like-man-page-says.
 - -tfilename still works.
 - When using -t (read description from stdin) don't end when first
   character is `.'.  Instead, end if whole line consists of one `.'.
 - Add regression test.

I also changed the regression Makefile to have a trailing slash on
the final element.  As long as we have a blank line it will be fine,
plus it will save us some trouble when adding new tests.

After adding line breaks, ``rest looks fine.'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.87 2006/03/27 07:38:24 ray Exp $	*/
d453 1
a453 1
	fmode = 0;
@


1.87
log
@Changes:
 - RCS_CREATE is now set in flags.
 - Since flags & RCS_CREATE is used in rcs_statfile(), flags is now a
   global variable.
 - RCS_[ENT]FLAG -> RCSPROG_[ENT]FLAG
 - Call rcs_set_description() if -t flag is given or if RCS_CREATE is
   set, checked in that order.  If the -t flag is given and RCS_CREATE
   is set, don't call rcs_set_description() twice.

``commitski!!'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.86 2006/03/27 06:13:51 pat Exp $	*/
d721 6
d734 2
a735 1
	if (in != NULL) {
d737 12
d754 1
d756 3
a758 1
			if (feof(stdin) || ferror(stdin) || buf[0] == '.')
@


1.86
log
@Plug a memory leak for all cvs_strsplit call sites; ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.85 2006/03/24 05:14:48 ray Exp $	*/
d42 3
a44 3
#define RCS_EFLAG	(1<<0)
#define RCS_NFLAG	(1<<1)
#define RCS_TFLAG	(1<<2)
d47 1
d357 1
a357 1
	if (stat(rcspath, &st) == -1 && !(rcsflags & RCS_CREATE)) {
d442 1
a442 1
	int i, j, ch, flags, kflag, lkmode;
d473 1
a473 1
			rcsflags |= RCS_EFLAG;
a480 1
			rcsflags |= RCS_CREATE;
d507 1
a507 1
			rcsflags |= RCS_NFLAG;
d514 1
a514 1
			rcsflags |= RCS_TFLAG;
d562 3
a564 1
		if (rcsflags & RCS_CREATE)
a566 3
		if (rcsflags & RCS_TFLAG)
			rcs_set_description(file, descfile);

d634 1
a634 1
		} else if (rcsflags & RCS_EFLAG) {
d695 1
a695 1
	if (rcsflags & RCS_NFLAG)
d701 1
a701 1
			    !(rcsflags & RCS_NFLAG))
d705 1
a705 1
			if (rcsflags & RCS_NFLAG)
@


1.85
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.84 2006/03/23 09:03:28 xsa Exp $	*/
d615 1
a615 1
			char **aargv;
d618 2
a619 2
			for (j = 0; aargv[j] != NULL; j++)
				rcs_access_add(file, aargv[j]);
d621 1
a621 1
			xfree(aargv);
d628 1
a628 1
			char **eargv;
d631 2
a632 2
			for (j = 0; eargv[j] != NULL; j++)
				rcs_access_remove(file, eargv[j]);
d634 1
a634 1
			xfree(eargv);
@


1.84
log
@use fatal() in rcs_lock_setmode(); OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.83 2006/03/22 02:58:15 ray Exp $	*/
d32 1
a32 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Lm:Mn:N:qt::TUVx:z:"
d529 2
a530 1
			rcs_suffixes = rcs_optarg;
@


1.83
log
@Clean up xfree() usage in rcs_choosefile().

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.82 2006/03/21 08:34:36 xsa Exp $	*/
d652 1
a652 1
			rcs_lock_setmode(file, lkmode);
@


1.82
log
@add support for `rcs -e[logins]'; "Looks good" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.81 2006/03/21 02:50:15 ray Exp $	*/
d309 2
a310 4
		    strlcat(fpath, ext, sizeof(fpath)) >= sizeof(fpath)) {
			xfree(suffixes);
			return (NULL);
		}
d318 1
a318 1
			break;
d323 1
a323 1
	 * If `ret' is still NULL no RCS file with any extension exists
d325 3
d329 4
a332 11
	if (ret == NULL) {
		/*
		 * `suffixes' should now be NUL separated, so the first
		 * extension can be read just by reading `suffixes'.
		 */
		if (strlcat(rcspath, suffixes, sizeof(rcspath)) >= sizeof(rcspath)) {
			xfree(suffixes);
			return (NULL);
		}
		ret = xstrdup(rcspath);
	}
d334 2
@


1.81
log
@Instead of duplicating rcs_suffixes and running strsep on it again,
just use the previous suffixes.  Since all slashes were replaced
with NULs, reading `suffixes' will give the first extension.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.80 2006/03/21 02:45:09 ray Exp $	*/
d42 3
a44 2
#define RCS_NFLAG	1
#define RCS_TFLAG	2
a474 1
			/* XXX - Not implemented. */
d476 1
d629 22
@


1.80
log
@Allow creation of an RCS file if RCS_CREATE flag set.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.79 2006/03/20 17:41:37 xsa Exp $	*/
a321 1
	xfree(suffixes);
d329 2
a330 2
		 * XXX - We shouldn't need to do strsep again,
		 * suffixes should now be NUL separated.
d332 1
a332 7
		next = suffixes = xstrdup(rcs_suffixes);
		/* Get first extension again. */
		if ((ext = strsep(&next, "/")) == NULL) {
			xfree(suffixes);
			return (NULL);
		}
		if (strlcat(rcspath, ext, sizeof(rcspath)) >= sizeof(rcspath)) {
a336 1
		xfree(suffixes);
d339 1
@


1.79
log
@make `rcs -a' use cvs_strsplit() for easiness; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.78 2006/03/18 04:00:34 ray Exp $	*/
d365 2
a366 2
	/* File not found. */
	if (stat(rcspath, &st) == -1) {
@


1.78
log
@+/* ARGSUSED */
 void
 sighdlr(int sig)

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.77 2006/03/18 03:41:54 ray Exp $	*/
d451 1
a451 1
	int i, ch, flags, kflag, lkmode;
d454 1
a454 1
	char *alist, *comment, *elist, *unp, *sp;
d624 1
a624 5
			unp = alist;
			do {
				sp = strchr(unp, ',');
				if (sp != NULL)
					*(sp++) = '\0';
d626 3
a628 1
				rcs_access_add(file, unp);
d630 1
a630 2
				unp = sp;
			} while (sp != NULL);
@


1.77
log
@strdup() -> xstrdup()

Okay xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.76 2006/03/16 04:04:57 ray Exp $	*/
d72 1
d481 1
@


1.76
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.75 2006/03/16 03:51:18 ray Exp $	*/
d291 1
a291 2
		if ((ret = strdup(rcspath)) == NULL);
			fatal("out of memory");
d301 1
a301 2
	if ((suffixes = strdup(rcs_suffixes)) == NULL)
		fatal("out of memory");
d317 1
a317 2
			if ((ret = strdup(fpath)) == NULL)
				fatal("out of memory");
d332 1
a332 3
		if ((suffixes = strdup(rcs_suffixes)) == NULL)
			fatal("out of memory");
		next = suffixes;
d342 1
a342 2
		if ((ret = strdup(rcspath)) == NULL)
			fatal("out of memory");
@


1.75
log
@Simplify rcs_statfile() by having it call rcs_choosefile().

ok xsa and niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.74 2006/03/15 03:29:01 ray Exp $	*/
d433 1
d491 1
d541 1
@


1.74
log
@Move and rename checkin_choose_rcsfile() to rcs_choosefile().

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.73 2006/03/15 02:46:14 ray Exp $	*/
d355 5
a362 4
	int found;
	char defaultsuffix[] = RCS_DEFAULT_SUFFIX;
	char filev[MAXPATHLEN], fpath[MAXPATHLEN];
	char *ext, *slash;
d364 1
d366 3
a368 21
	found = 0;

	if (rcs_suffixes != NULL)
		ext = rcs_suffixes;
	else
		ext = defaultsuffix;

	for (;;) {
		/*
		 * GNU documentation says -x,v/ specifies two suffixes,
		 * namely the ,v one and an empty one (which matches
		 * everything).
		 * The problem is that they don't follow this rule at
		 * all, and their documentation seems flawed.
		 * We try to be compatible, so let's do so.
		 */
		if (*ext == '\0')
			break;

		if ((slash = strchr(ext, '/')) != NULL)
			*slash = '\0';
d370 2
a371 31
		if (strlcpy(filev, fname, sizeof(filev)) >= sizeof(filev) ||
		    strlcat(filev, ext, sizeof(filev)) >= sizeof(filev))
			fatal("rcs_statfile: path truncation");

		if (stat(RCSDIR, &st) != -1 && (st.st_mode & S_IFDIR)) {
			if (strlcpy(fpath, RCSDIR,
			    sizeof(fpath)) >= sizeof(fpath) ||
			    strlcat(fpath, "/",
			    sizeof(fpath)) >= sizeof(fpath) ||
			    strlcat(fpath, filev,
			    sizeof(fpath)) >= sizeof(fpath))
				fatal("rcs_statfile: path truncation");
		} else {
			if (strlcpy(fpath, filev,
			    sizeof(fpath)) >= sizeof(fpath))
				fatal("rcs_statfile: path truncation");
		}

		if ((stat(fpath, &st) != -1) || (rcsflags & RCS_CREATE)) {
			found++;
			break;
		}

		if (slash == NULL)
			break;

		*slash++ = '/';
		ext = slash;
	}

	if (found != 1) {
d374 2
a375 1
			cvs_log(LP_ERRNO, "%s", fpath);
d379 1
a379 1
	if (strlcpy(out, fpath, len) >= len)
d381 2
@


1.73
log
@Don't assume there is an RCS directory just because the filename
contains the letters `RCS'.

ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.72 2006/03/14 03:33:30 ray Exp $	*/
d226 125
@


1.72
log
@ci currently doesn't parse the -x flag at all, defaulting to ",v/" every
time.  I rewrote checkin_choose_rcsfile() to handle it using these rules:
 - If a directory structure is given (ci -x,abcd dir/dir2/file) then all
   RCS files are under dir/dir2.
 - If the RCS/ directory exists, use it.  Otherwise use current directory.
 - If the -x flag is specified, use those slash-separated extensions.
   Otherwise, use the default (",v/").
 - Look in the rcs directory (RCS/ or current directory) for a file
   with a matching extension, for each extension.  Each extension is
   tried in order.  If a file exists, it is used.  If no file exists
   with any extension, the first one is used.
 - The empty extension is treated as no extension, because I can't
   figure out what its special meaning is.

It sounds complicated, and the code is kinda complicated as well, but it
makes sense if you think about it.

ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.71 2006/03/14 01:51:35 ray Exp $	*/
d233 1
a233 1
	int found, strdir;
d239 1
a239 5
	strdir = found = 0;

	/* we might have gotten the RCS/ dir in the argument string */
	if (strstr(fname, RCSDIR) != NULL)
		strdir = 1;
d265 1
a265 2
		if ((strdir == 0) &&
		    (stat(RCSDIR, &st) != -1) && (st.st_mode & S_IFDIR)) {
@


1.71
log
@OpenRCS currently strips any text in a filename up to and including
the last comma, assuming that it is a `,v' extension.  GNU RCS does
not do this.  This removes that check.

ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.70 2006/03/12 01:20:38 joris Exp $	*/
a31 1
#define RCS_DEFAULT_SUFFIX	",v/"
@


1.70
log
@plug a memleak in rcs_set_description()

okidoki niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.69 2006/03/11 22:51:13 niallo Exp $	*/
a240 4

	/* we might have gotten a RCS file as argument */
	if ((ext = strchr(fname, ',')) != NULL)
		*ext = '\0';
@


1.69
log
@Now that the last diff went in, we just have to remove some checks in
rcs_set_rev() to get the GNU-like behaviour for ci -l0, ci -u0 etc
(admittedly its weird behaviour...but hey, we should support it)

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.68 2006/03/08 20:19:39 joris Exp $	*/
d666 1
@


1.68
log
@make openrcs use the worklist framework to keep track of temporary files
and remove them in case it gets interrupted.

suggested by deraadt@@, ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.67 2006/03/08 12:25:34 xsa Exp $	*/
a82 2
	RCSNUM *t;

a90 17
	/*
	 * If 0 is specified as a revision number, exit and warn the user.
	 * This differs from GNU ci's plainly buggy behaviour, where 0 ends up
	 * being 0.1 and other weird stuff.
	 */
	t = rcsnum_parse("0");
	if (rcsnum_cmp(*rev, t, 0) == 0)
		fatal("0 is not a valid revision number");
	rcsnum_free(t);
	/*
	 * If 1 is specified as revision number, silently assume 1.1.
	 * This is what GNU ci does.
	 */
	t = rcsnum_parse(RCS_HEAD_INIT);
	if (rcsnum_cmp(*rev, t, 0) > 0)
		rcsnum_cpy(t, *rev, 0);
	rcsnum_free(t);
@


1.67
log
@spacing in usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.66 2006/03/06 14:57:32 jmc Exp $	*/
d67 3
d74 7
d343 1
d363 7
@


1.66
log
@update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.65 2006/03/06 14:37:23 jmc Exp $	*/
d369 1
a369 1
	    "		[-cstring] [-e[users]] [-kmode] [-mrev:msg]\n"
d371 1
a371 1
	    "		[-xsuffixes] file ...\n");
@


1.65
log
@move compat flags into a STANDARDS section;
ok niallo xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.64 2006/03/06 09:41:53 deraadt Exp $	*/
d368 4
a371 2
	    "usage: rcs [-hiLMTUV] [-Aoldfile] [-ausers] [-b[rev]] [-cstring]\n"
	    "           [-eusers] [-kmode] [-mrev:msg] [-xsuffixes] file ...\n");
@


1.64
log
@many spacing cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.63 2006/02/21 16:39:23 niallo Exp $	*/
d369 1
a369 1
	    "           [-eusers] [-kmode] [-mrev:msg] [-xsuffixes] [-ztz] file ...\n");
@


1.63
log
@- fix some bugs when handling strange revision numbers (0 and 1). found by
  my automatic tool.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.62 2006/01/25 08:01:00 xsa Exp $	*/
d83 1
a83 1
        /*
d94 1
a94 1
	 * This is what GNU ci does. 
d98 1
a98 1
		rcsnum_cpy(t, *rev, 0); 
a99 1
	
@


1.62
log
@snprintf() cleanup; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.61 2006/01/06 15:30:49 xsa Exp $	*/
d73 2
d83 18
@


1.61
log
@typos;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.60 2006/01/05 10:28:24 xsa Exp $	*/
d224 1
a224 2
	size_t len1;
	int l, found, strdir;
d260 2
a261 2
		l = snprintf(filev, sizeof(filev), "%s%s", fname, ext);
		if (l == -1 || l >= (int)sizeof(filev))
d266 6
a271 3
			l = snprintf(fpath, sizeof(fpath), "%s/%s",
			    RCSDIR, filev);
			if (l == -1 || l >= (int)sizeof(fpath))
d274 2
a275 2
			len1 = strlcpy(fpath, filev, sizeof(fpath));
			if (len1 >= sizeof(fpath))
d298 1
a298 2
	len1 = strlcpy(out, fpath, len);
	if (len1 >= len)
@


1.60
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.59 2006/01/02 08:13:28 xsa Exp $	*/
d141 1
a141 1
		cp = strsep(&lp, " \t\b\f\n\r\t\v");;
@


1.59
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.58 2005/12/27 16:05:21 niallo Exp $	*/
a28 2
#include "log.h"
#include "rcs.h"
@


1.58
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.57 2005/12/24 16:37:46 xsa Exp $	*/
d27 1
a27 12
#include <sys/param.h>
#include <sys/wait.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <pwd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
@


1.57
log
@error message consistency in fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.56 2005/12/24 03:48:09 joris Exp $	*/
d386 1
a386 1
	flags = RCS_RDWR;
@


1.56
log
@- support for -n -N and -t;
- check for path truncation;
- do not pollute flags being passed to rcs_open() with local flags;
- fix rcs initialization stuff;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.55 2005/12/21 16:10:50 xsa Exp $	*/
d287 1
a287 1
				fatal("path truncation in rcs_statfile");
d311 1
a311 1
		fatal("path truncation in rcs_statfile");
@


1.55
log
@use fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.54 2005/12/14 11:39:12 xsa Exp $	*/
d46 5
a50 1
#define RCSPROG_OPTSTRING	"A:a:b::c:e::hik:Lm:MqTUVx:z:"
d56 4
d80 3
d237 1
d285 3
a287 1
			strlcpy(fpath, filev, sizeof(fpath));
d290 1
a290 1
		if (stat(fpath, &st) != -1) {
d309 3
a311 1
	strlcpy(out, fpath, len);
d376 1
a376 1
	char *logstr, *logmsg;
d387 1
d395 1
a395 1
			flags |= CO_ACLAPPEND;
d411 1
d433 7
d443 4
d448 1
a448 1
			flags |= PRESERVETIME;
d491 7
a497 1
		if (flags & PRESERVETIME)
d500 3
d531 1
a531 1
		if (flags & CO_ACLAPPEND) {
d567 1
a567 1
		if (flags & PRESERVETIME)
d577 3
d581 77
@


1.54
log
@correct usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.53 2005/12/10 20:27:46 joris Exp $	*/
d81 2
a82 4
	if ((*rev = rcsnum_parse(str)) == NULL) {
		cvs_log(LP_ERR, "bad revision number '%s'", str);
		exit (1);
	}
d263 2
a264 5
		if (l == -1 || l >= (int)sizeof(filev)) {
			errno = ENAMETOOLONG;
			cvs_log(LP_ERRNO, "%s", filev);
			return (-1);
		}
d270 2
a271 5
			if (l == -1 || l >= (int)sizeof(fpath)) {
				errno = ENAMETOOLONG;
				cvs_log(LP_ERRNO, "%s", fpath);
				return (-1);
			}
@


1.53
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.52 2005/12/09 07:00:43 joris Exp $	*/
d354 1
a354 1
	    "           [-eusers] [-kmode] [-mrev:log] [-xsuffixes] [-ztz] file ...\n");
@


1.52
log
@don't complain too often about 'redefinition of revision number',
specially when rev is actually NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.51 2005/11/30 09:36:48 xsa Exp $	*/
d156 1
a156 7
		argv[argc] = strdup(cp);
		if (argv[argc] == NULL) {
			cvs_log(LP_ERRNO, "failed to copy argument");
			error++;
			break;
		}

d162 1
a162 1
			free(argv[i]);
d418 1
a418 4
			if ((logstr = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "failed to copy logstring");
				exit(1);
			}
d545 1
a545 1
		free(logstr);
@


1.51
log
@`-ztz' is only here for compatibility;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.50 2005/11/28 14:43:59 xsa Exp $	*/
d78 1
a78 1
	if (*rev != RCS_HEAD_REV)
@


1.50
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.49 2005/11/27 16:49:15 niallo Exp $	*/
d46 1
d360 1
a360 1
	    "           [-eusers] [-kmode] [-mrev:log] [-xsuffixes] file ...\n");
d387 1
a387 1
	while ((ch = rcs_getopt(argc, argv, "A:a:b::c:e::hik:Lm:MqTUV")) != -1) {
d448 5
@


1.49
log
@- fix really stupid bug introduced in the last xsa commit.
  problem found by me, joris' eyes spotted the semi colon.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.48 2005/11/25 14:16:44 xsa Exp $	*/
d358 2
a359 2
	    "usage: rcs [-hiLMUV] [-Aoldfile] [-ausers] [-b[rev]] [-cstring]\n"
	    "           [-eusers] [-kmode] [-mrev:log] file ...\n");
@


1.48
log
@add `-T' support for rcsclean(1) and rcs(1);
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.47 2005/11/25 13:50:01 xsa Exp $	*/
d470 1
a470 1
		if ((file = rcs_open(fpath, flags, fmode)) == NULL);
@


1.47
log
@add support for `-T' and enable it for co(1);
tested and OK niallo@@. "Looks good" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.46 2005/11/23 09:39:20 xsa Exp $	*/
d379 1
d469 2
a470 2
		file = rcs_open(fpath, flags, fmode);
		if (file == NULL)
d473 3
d485 2
a486 1
				cvs_log(LP_ERR, "'%s' bad revision number", logstr);
d539 3
@


1.46
log
@initial bits for -T support;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.45 2005/11/21 16:20:29 xsa Exp $	*/
d84 46
@


1.45
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.44 2005/11/21 15:16:41 niallo Exp $	*/
d339 1
a339 1
	while ((ch = rcs_getopt(argc, argv, "A:a:b::c:e::hik:Lm:MqUV")) != -1) {
d386 3
@


1.44
log
@- modularisation; split the two major checkin operations into functions.
- modularisation; split the revert code into checkin_revert()
- a few steps closer to rcsfile initialisation, but things need to be fixed
  in the rcs.c api first (currently we segfault).
- add a new checkin_choose_rcsfile() function to decide where the rcsfile
  should go.
- add a special case for ci to rcs_statfile() so that we don't print out an
  error if the rcsfile doesn't exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.43 2005/11/21 11:17:19 xsa Exp $	*/
d395 3
@


1.43
log
@tweaks;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.42 2005/11/20 08:50:20 xsa Exp $	*/
d256 2
a257 1
		if (strcmp(__progname, "rcsclean"))
@


1.42
log
@rcs_statfile() improvements; initial work from joris + some bits from me;
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.41 2005/11/12 22:49:59 niallo Exp $	*/
d207 1
d224 3
a226 1
		if (l == -1 || l >= (int)sizeof(filev))
d228 1
d234 3
a236 1
			if (l == -1 || l >= (int)sizeof(fpath))
d238 1
@


1.41
log
@- fix xsa breakage. char arrays on the stack are not NULL if empty. use
flags instead.
- add a few more flags defines while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.40 2005/11/12 21:34:48 niallo Exp $	*/
d45 1
d53 1
d187 2
a188 1
	int l;
d190 1
d193 28
a220 3
	l = snprintf(filev, sizeof(filev), "%s%s", fname, RCS_FILE_EXT);
	if (l == -1 || l >= (int)sizeof(filev))
		return (-1);
d222 2
a223 3
	if ((stat(RCSDIR, &st) != -1) && (st.st_mode & S_IFDIR)) {
		l = snprintf(fpath, sizeof(fpath), "%s/%s", RCSDIR, filev);
		if (l == -1 || l >= (int)sizeof(fpath))
d225 21
a245 2
	} else {
		strlcpy(fpath, filev, sizeof(fpath));
d248 1
a248 1
	if (stat(fpath, &st) == -1) {
@


1.40
log
@- remove strtab stuff. serves no useful purpose.

diff is from joris@@, committing on his behalf because his net connection
is very dodgy right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.39 2005/11/12 09:42:29 xsa Exp $	*/
d289 1
d392 1
a392 1
		if (ofpath != NULL) {
@


1.39
log
@support for `-Aoldfile'; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.38 2005/11/04 08:19:42 xsa Exp $	*/
a42 1
#include "strtab.h"
a220 1
	cvs_strtab_init();
a247 2

	cvs_strtab_cleanup();
@


1.38
log
@kill spaces in usage() to match Reality;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.37 2005/11/03 17:54:34 niallo Exp $	*/
d261 1
a261 1
	    "usage: rcs [-hiLMUV] [-ausers] [-b[rev]] [-cstring]\n"
d275 1
a275 1
	char fpath[MAXPATHLEN];
d277 1
a277 1
	char *oldfile, *alist, *comment, *elist, *unp, *sp;
d279 1
a279 1
	RCSFILE *file;
d281 1
d286 1
a286 1
	logstr = oldfile = alist = comment = elist = NULL;
d291 2
a292 1
			oldfile = rcs_optarg;
d392 12
@


1.37
log
@- minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.36 2005/10/27 07:43:56 xsa Exp $	*/
d261 2
a262 2
	    "usage: rcs [-hiLMUV] [-a users] [-b [rev]] [-c string]\n"
	    "           [-e users] [-k opt] [-m rev:log] file ...\n");
@


1.36
log
@TMPDIR support; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.35 2005/10/19 11:37:11 niallo Exp $	*/
d261 2
a262 2
	    "usage: rcs [-hiLMUV] [-a users] [-b [rev]] [-c string] [-e users]\n"
	    "           [-k opt] [-m rev:log] file ...\n");
@


1.35
log
@- make a bunch of changes to how we handle verbose output. this brings us
much closer in line with GNU RCS and cleans things up in general.

ok joris@@, "looks fine to me" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.34 2005/10/19 00:30:22 joris Exp $	*/
d51 1
a51 1
int	rcs_optind;
d53 1
d237 3
@


1.34
log
@add co -p support;
input from xsa@@ and niallo@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.33 2005/10/18 16:20:31 xsa Exp $	*/
a185 1
	char *s;
a207 15
	if ((verbose == 1) && (strcmp(__progname, "rcsclean"))) {
		if (!strcmp(__progname, "co")) {
			printf("%s --> ", fpath);
			if (pipeout == 1) {
				printf("standard output\n");
			} else {
				if ((s = strrchr(filev, ',')) != NULL) {
					*s = '\0';
					printf("%s\n", fname);
				}
			}
		} else {
			printf("RCS file: %s\n", fpath);
		}
	}
d356 2
@


1.33
log
@more rcsmerge(1) bits;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.32 2005/10/18 01:24:42 joris Exp $	*/
d49 1
d212 7
a218 3
			if ((s = strrchr(filev, ',')) != NULL) {
				*s = '\0';
				printf("%s\n", fname);
@


1.32
log
@oops, rcs_set_rev() can't operate when str is NULL of course;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.31 2005/10/18 01:22:14 joris Exp $	*/
d63 1
@


1.31
log
@use rcs_set_rev() instead of duplicating code all over the
place to set a variable to the given revision number;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.30 2005/10/16 00:25:14 joris Exp $	*/
d70 3
@


1.30
log
@fix off-by-one in RCSINIT code, noticed by niallo@@
for this my karma drops by 10 points;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.29 2005/10/15 23:39:36 joris Exp $	*/
d66 12
@


1.29
log
@RCSINIT support;
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.28 2005/10/13 12:35:30 joris Exp $	*/
d220 1
a221 1
		cmd_argv[cmd_argc++] = argv[0];
d340 1
@


1.28
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.27 2005/10/12 17:43:18 xsa Exp $	*/
d45 2
d68 42
d211 2
a212 1
	int ret;
d219 16
d238 1
a238 1
			ret = programs[i].prog_hdlr(argc, argv);
@


1.27
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.26 2005/10/12 17:13:30 deraadt Exp $	*/
d48 3
d66 56
d170 1
d217 1
a217 1
	while ((ch = getopt(argc, argv, "A:a:b::c:e::hik:Lm:MqUV")) != -1) {
d220 1
a220 1
			oldfile = optarg;
d223 1
a223 1
			alist = optarg;
d226 1
a226 1
			comment = optarg;
d229 1
a229 1
			elist = optarg;
d238 1
a238 1
			kflag = rcs_kflag_get(optarg);
d242 1
a242 1
				    optarg);
d252 1
a252 1
			if ((logstr = strdup(optarg)) == NULL) {
d277 2
a278 2
	argc -= optind;
	argv += optind;
@


1.26
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.25 2005/10/11 00:25:18 joris Exp $	*/
d89 1
a89 1
	if (verbose == 1 && strcmp(__progname, "rcsclean")) {
@


1.25
log
@free logrev on error;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.24 2005/10/10 23:38:21 joris Exp $	*/
a34 1
#include <signal.h>
d49 3
a51 3
	char  *prog_name;
	int  (*prog_hdlr)(int, char **);
	void (*prog_usage)(void);
d131 2
a132 2
	    "usage: %s [-hiLMUV] [-a users] [-b [rev]] [-c string]\n"
	    "[-e users] [-k opt] [-m rev:log] file ...\n", __progname);
@


1.24
log
@support -mrevision:logmessage; used to set a log message of a revision
to the specified value;

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.23 2005/10/10 14:37:59 niallo Exp $	*/
d253 1
@


1.23
log
@exit(3) is preferred over return from main().

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.22 2005/10/06 15:39:11 joris Exp $	*/
d132 2
a133 2
	    "usage: %s [-hiLMUV] [-a users] [-b [rev]] [-c string] "
	    "[-e users] [-k opt] file ...\n", __progname);
d147 1
d151 1
d156 1
a156 1
	oldfile = alist = comment = elist = NULL;
d158 1
a158 1
	while ((ch = getopt(argc, argv, "A:a:b::c:e::hik:LMqUV")) != -1) {
d192 6
d234 25
d287 3
@


1.22
log
@ident command, written by xsa@@ but he is too busy with work right now;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.21 2005/10/06 12:56:49 joris Exp $	*/
d124 1
a124 1
	return (ret);
@


1.21
log
@support rlog command;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.20 2005/10/06 02:00:05 joris Exp $	*/
d60 1
a60 1
	{ "ident",	NULL,		NULL		},
@


1.20
log
@rcsclean now works;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.19 2005/10/06 01:26:12 joris Exp $	*/
d59 1
@


1.19
log
@show fpath when checking out files;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.18 2005/10/06 01:24:25 joris Exp $	*/
d57 1
a57 1
	{ "rcsclean",	NULL,		NULL		},
d83 2
a84 1
		cvs_log(LP_ERRNO, "%s", fpath);
d89 1
a89 1
	if (verbose == 1) {
@


1.18
log
@thanks to niallo's diff changes, we now can support rcsdiff;
only basic stuff works, more coming;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.17 2005/09/30 17:34:58 joris Exp $	*/
d90 1
a90 1
			printf("%s --> ", filev);
@


1.17
log
@allow ci to run, niallo forgot this when he commited his ci code;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.16 2005/09/30 15:05:47 joris Exp $	*/
d58 1
a58 1
	{ "rcsdiff",	NULL,		NULL		},
@


1.16
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.15 2005/09/30 15:02:26 niallo Exp $	*/
d55 1
a55 1
	{ "ci",		NULL,		NULL		},
@


1.15
log
@ensure RCSDIR is in fact a directory before deciding to use it.

"go for it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.14 2005/09/29 21:38:48 xsa Exp $	*/
d74 1
a74 1
	if (stat(RCSDIR, &st) != -1 && (st.st_mode & S_IFDIR)) {
@


1.14
log
@hrmz..better.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.13 2005/09/29 21:38:01 xsa Exp $	*/
d74 1
a74 1
	if (stat(RCSDIR, &st) != -1) {
@


1.13
log
@minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.12 2005/09/29 21:30:10 joris Exp $	*/
d88 1
a88 1
	if (verbose != 0) {
d249 1
a249 1
		if (verbose != 0)
@


1.12
log
@support -q flag in 'co' and 'rcs'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.11 2005/09/29 15:19:51 joris Exp $	*/
d88 1
a88 1
	if (verbose) {
d249 1
a249 1
		if (verbose)
@


1.11
log
@stuff needed for 'co'
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.10 2005/09/29 15:14:12 joris Exp $	*/
d47 1
d88 9
a96 5
	if (!strcmp(__progname, "co")) {
		printf("%s --> ", filev);
		if ((s = strrchr(filev, ',')) != NULL) {
			*s = '\0';
			printf("%s\n", fname);
a97 2
	} else {
		printf("RCS file: %s\n", fpath);
d154 1
a154 1
	while ((ch = getopt(argc, argv, "A:a:b::c:e::hik:LMUV")) != -1) {
d191 3
d249 2
a250 1
		printf("done\n");
@


1.10
log
@zap unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.9 2005/09/29 15:13:19 joris Exp $	*/
d55 1
a55 1
	{ "co",		NULL,		NULL		},
@


1.9
log
@- prototypes for the RCS commands go in rcsprog.h
- use rcs_statfile() to obtain the correct path to the RCS file
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.8 2005/09/29 00:20:22 joris Exp $	*/
d141 1
a141 1
	char fpath[MAXPATHLEN], filev[MAXPATHLEN];
a144 1
	struct stat st;
@


1.8
log
@for RCS files look in RCSDIR, if there is no path prefix specified.
if RCSDIR does not exist, look in the parent directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.7 2005/09/20 05:03:02 joris Exp $	*/
d43 1
a45 3
extern char *__progname;


a47 4
void  rcs_usage(void);
int   rcs_main(int, char **);
void (*usage)(void);

d61 38
d108 1
a151 2
	cvs_log_init(LD_STD, 0);

d212 1
a212 16
		/*
		 * Our RCS API does not append the RCS_FILE_EXT extension
		 * automaticly in rcs_open(), so we add it here.
		 */
		snprintf(filev, sizeof(filev), "%s%s", argv[i], RCS_FILE_EXT);
		if (stat(RCSDIR, &st) != -1) {
			strlcpy(fpath, RCSDIR, sizeof(fpath));
			strlcat(fpath, "/", sizeof(fpath));
			strlcat(fpath, filev, sizeof(fpath));
		} else {
			strlcpy(fpath, filev, sizeof(filev));
		}

		if (stat(fpath, &st) != -1) {
			errno = EEXIST;
			cvs_log(LP_ERRNO, "%s", fpath);
a213 1
		}
a214 1
		printf("RCS file: %s\n", fpath);
d243 1
@


1.7
log
@missing 'ident' command in the programs table.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.6 2005/09/20 05:01:31 joris Exp $	*/
d29 1
a97 1

d108 1
a108 1
	char fpath[MAXPATHLEN];
d112 1
d185 14
a198 1
		snprintf(fpath, sizeof(fpath), "%s%s", argv[i], RCS_FILE_EXT);
@


1.6
log
@- create the correct RCS filename before calling rcs_open().
- don't bail out if we cannot open an RCS file, instead try to continue
  with the others (if there are any).
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.5 2005/09/20 04:30:57 joris Exp $	*/
d63 1
@


1.5
log
@be a bit more compatible with gnu rcs in our output.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.4 2005/09/20 04:29:51 joris Exp $	*/
d27 1
a27 1
#include <sys/types.h>
d107 1
d179 10
a188 5
		printf("RCS file: %s\n", argv[i]);
		file = rcs_open(argv[i], flags, fmode);
		if (file == NULL) {
			return (1);
		}
@


1.4
log
@loop through argv[] correctly instead of reusing argv[0] all the time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.3 2005/09/20 04:24:41 joris Exp $	*/
d173 1
@


1.3
log
@sort headers
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.2 2005/04/15 15:59:11 deraadt Exp $	*/
d177 2
a178 2
		printf("RCS file: %s\n", argv[0]);
		file = rcs_open(argv[0], flags, fmode);
@


1.2
log
@seperate usage functions per sub-program
shrink usage for rcs(1), that is what man pages are for
ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.1 2005/04/15 15:46:21 deraadt Exp $	*/
d30 1
d32 1
d34 2
a35 1
#include <errno.h>
a36 1
#include <ctype.h>
a38 2
#include <signal.h>
#include <string.h>
@


1.1
log
@move rcs (and later on, clones of all the other rcs commands) out of the
cvs subdirectory; ok jfb joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.5 2005/04/11 19:55:28 jfb Exp $	*/
d49 3
a51 4
void  rcs_usage (void);
int   rcs_main  (int, char **);


d56 1
d58 5
a62 5
	{ "rcs",	rcs_main	},
	{ "ci",		NULL		},
	{ "co",		NULL		},
	{ "rcsclean",	NULL		},
	{ "rcsdiff",	NULL		},
d76 2
a77 1
		if (strcmp(__progname, programs[i].prog_name) == 0)
d79 2
d92 2
a93 14
	    "Usage: %s [-hiLMUV] [-a users] [-b [rev]] [-c string] "
	    "[-e users] [-k opt] file ...\n"
	    "\t-a users\tAdd the login names in the comma-separated <users>\n"
	    "\t-b rev\t\tSet the head revision to <rev>\n"
	    "\t-c string\tSet the comment leader to <string>\n"
	    "\t-e users\tRemove the login names in the comma-separated <users>\n"
	    "\t-h\t\tPrint the program's usage and exit\n"
	    "\t-i\t\tCreate a new empty RCS file\n"
	    "\t-k opt\t\tSet the keyword expansion mode to <opt>\n"
	    "\t-L\t\tEnable strict locking on the specified files\n"
	    "\t-M\t\tDisable mail warning about lock breaks\n"
	    "\t-U\t\tDisable strict locking on the specified files\n"
	    "\t-V\t\tPrint the program's version string and exit\n",
	    __progname);
d133 1
a133 1
			rcs_usage();
d164 1
a164 1
			rcs_usage();
@

