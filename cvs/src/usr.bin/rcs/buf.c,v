head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.16
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.14
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.10
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.27
date	2016.10.16.13.35.51;	author okan;	state Exp;
branches;
next	1.26;
commitid	RkkF6LzZj7gdsaWi;

1.26
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.25;
commitid	aZp5pu4rATnp3dyP;

1.25
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.24;
commitid	FFUg8uzT5GNAfRXp;

1.24
date	2015.02.05.12.59.58;	author millert;	state Exp;
branches;
next	1.23;
commitid	DTQbfd4poqBW8iSJ;

1.23
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	Z3HC5pAWzpo5jsTe;

1.22
date	2011.07.06.15.36.52;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.20.19.34.16;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.27.18.20.14;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.01.20.25.15;	author chl;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.08.20.49.11;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.08.15.13.39;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.22.08.30.45;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.02.04.34.49;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.02.04.24.09;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.16.07.39.15;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.02.03.28.50;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.01.21.28.24;	author niallo;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.26.15.08.25;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.08.07.12;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Quiet compiler warnings; as applied to usr.bin/cvs by millert@@

ok millert@@
@
text
@/*	$OpenBSD: buf.c,v 1.26 2015/11/02 16:45:21 nicm Exp $	*/
/*
 * Copyright (c) 2003 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/queue.h>
#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "buf.h"
#include "xmalloc.h"
#include "worklist.h"

#define BUF_INCR	128

struct buf {
	/* buffer handle, buffer size, and data length */
	u_char	*cb_buf;
	size_t	 cb_size;
	size_t	 cb_len;
};

#define SIZE_LEFT(b)	(b->cb_size - b->cb_len)

static void	buf_grow(BUF *, size_t);

/*
 * Create a new buffer structure and return a pointer to it.  This structure
 * uses dynamically-allocated memory and must be freed with buf_free(), once
 * the buffer is no longer needed.
 */
BUF *
buf_alloc(size_t len)
{
	BUF *b;

	b = xmalloc(sizeof(*b));
	/* Postpone creation of zero-sized buffers */
	if (len > 0)
		b->cb_buf = xcalloc(1, len);
	else
		b->cb_buf = NULL;

	b->cb_size = len;
	b->cb_len = 0;

	return (b);
}

/*
 * Open the file specified by <path> and load all of its contents into a
 * buffer.
 * Returns the loaded buffer on success or NULL on failure.
 * Sets errno on error.
 */
BUF *
buf_load(const char *path)
{
	int fd;
	ssize_t ret;
	size_t len;
	u_char *bp;
	struct stat st;
	BUF *buf;

	buf = NULL;

	if ((fd = open(path, O_RDONLY, 0600)) == -1)
		goto out;

	if (fstat(fd, &st) == -1)
		goto out;

	if ((uintmax_t)st.st_size > SIZE_MAX) {
		errno = EFBIG;
		goto out;
	}
	buf = buf_alloc(st.st_size);
	for (bp = buf->cb_buf; ; bp += (size_t)ret) {
		len = SIZE_LEFT(buf);
		ret = read(fd, bp, len);
		if (ret == -1) {
			int saved_errno;

			saved_errno = errno;
			buf_free(buf);
			buf = NULL;
			errno = saved_errno;
			goto out;
		} else if (ret == 0)
			break;

		buf->cb_len += (size_t)ret;
	}

out:
	if (fd != -1) {
		int saved_errno;

		/* We may want to preserve errno here. */
		saved_errno = errno;
		(void)close(fd);
		errno = saved_errno;
	}

	return (buf);
}

void
buf_free(BUF *b)
{
	if (b == NULL)
		return;
	free(b->cb_buf);
	free(b);
}

/*
 * Free the buffer <b>'s structural information but do not free the contents
 * of the buffer.  Instead, they are returned and should be freed later using
 * free().
 */
void *
buf_release(BUF *b)
{
	void *tmp;

	tmp = b->cb_buf;
	free(b);
	return (tmp);
}

u_char *
buf_get(BUF *b)
{
	return (b->cb_buf);
}

/*
 * Empty the contents of the buffer <b> and reset pointers.
 */
void
buf_empty(BUF *b)
{
	memset(b->cb_buf, 0, b->cb_size);
	b->cb_len = 0;
}

/*
 * Append a single character <c> to the end of the buffer <b>.
 */
void
buf_putc(BUF *b, int c)
{
	u_char *bp;

	if (SIZE_LEFT(b) == 0)
		buf_grow(b, BUF_INCR);
	bp = b->cb_buf + b->cb_len;
	*bp = (u_char)c;
	b->cb_len++;
}

/*
 * Append a string <s> to the end of buffer <b>.
 */
void
buf_puts(BUF *b, const char *str)
{
	buf_append(b, str, strlen(str));
}

/*
 * Return u_char at buffer position <pos>.
 */
u_char
buf_getc(BUF *b, size_t pos)
{
	return (b->cb_buf[pos]);
}

/*
 * Append <len> bytes of data pointed to by <data> to the buffer <b>.  If the
 * buffer is too small to accept all data, it will get resized to an
 * appropriate size to accept all data.
 * Returns the number of bytes successfully appended to the buffer.
 */
size_t
buf_append(BUF *b, const void *data, size_t len)
{
	size_t left, rlen;
	u_char *bp;

	left = SIZE_LEFT(b);
	rlen = len;

	if (left < len)
		buf_grow(b, len - left);
	bp = b->cb_buf + b->cb_len;
	memcpy(bp, data, rlen);
	b->cb_len += rlen;

	return (rlen);
}

/*
 * Returns the size of the buffer that is being used.
 */
size_t
buf_len(BUF *b)
{
	return (b->cb_len);
}

/*
 * Write the contents of the buffer <b> to the specified <fd>
 */
int
buf_write_fd(BUF *b, int fd)
{
	u_char *bp;
	size_t len;
	ssize_t ret;

	len = b->cb_len;
	bp = b->cb_buf;

	do {
		ret = write(fd, bp, len);
		if (ret == -1) {
			if (errno == EINTR || errno == EAGAIN)
				continue;
			return (-1);
		}

		len -= (size_t)ret;
		bp += (size_t)ret;
	} while (len > 0);

	return (0);
}

/*
 * Write the contents of the buffer <b> to the file whose path is given in
 * <path>.  If the file does not exist, it is created with mode <mode>.
 */
int
buf_write(BUF *b, const char *path, mode_t mode)
{
	int fd;
 open:
	if ((fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, mode)) == -1) {
		if (errno == EACCES && unlink(path) != -1)
			goto open;
		else
			err(1, "%s", path);
	}

	if (buf_write_fd(b, fd) == -1) {
		(void)unlink(path);
		errx(1, "buf_write: buf_write_fd: `%s'", path);
	}

	if (fchmod(fd, mode) < 0)
		warn("permissions not set on file %s", path);

	(void)close(fd);

	return (0);
}

/*
 * Write the contents of the buffer <b> to a temporary file whose path is
 * specified using <template> (see mkstemp.3).
 * NB. This function will modify <template>, as per mkstemp
 */
void
buf_write_stmp(BUF *b, char *template)
{
	int fd;

	if ((fd = mkstemp(template)) == -1)
		err(1, "%s", template);

	worklist_add(template, &temp_files);

	if (buf_write_fd(b, fd) == -1) {
		(void)unlink(template);
		errx(1, "buf_write_stmp: buf_write_fd: `%s'", template);
	}

	(void)close(fd);
}

/*
 * Grow the buffer <b> by <len> bytes.  The contents are unchanged by this
 * operation regardless of the result.
 */
static void
buf_grow(BUF *b, size_t len)
{
	b->cb_buf = xreallocarray(b->cb_buf, 1, b->cb_size + len);
	b->cb_size += len;
}
@


1.26
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.25 2015/06/13 20:15:21 nicm Exp $	*/
d103 1
a103 1
	if (st.st_size > SIZE_MAX) {
@


1.25
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.24 2015/02/05 12:59:58 millert Exp $	*/
d141 2
@


1.24
log
@Include stdint.h, not limits.h to get SIZE_MAX.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.23 2014/12/01 21:58:46 deraadt Exp $	*/
d35 1
d141 2
a142 3
	if (b->cb_buf != NULL)
		xfree(b->cb_buf);
	xfree(b);
d148 1
a148 1
 * xfree().
d156 1
a156 1
	xfree(b);
@


1.23
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.22 2011/07/06 15:36:52 nicm Exp $	*/
d33 1
@


1.22
log
@Replace the keyword expansion code with a faster, more readable version
which additionally also supports $Log$ and $Locker. Written by Joerg
Sonnenberger and tweaked by me.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.21 2011/04/20 19:34:16 nicm Exp $	*/
d328 1
a328 1
	b->cb_buf = xrealloc(b->cb_buf, 1, b->cb_size + len);
@


1.21
log
@Remove some unneeded includes and dead code, from Michael W Bombardieri.

ok jasper xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.20 2011/03/27 18:20:14 jasper Exp $	*/
d188 9
@


1.20
log
@- garbage collect unused buf_fappend(), which was also removed from ocvs's
buf.c some time ago.

from Michael W. Bombardieri
ok chl@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.19 2010/12/01 20:25:15 chl Exp $	*/
a32 1
#include <stdarg.h>
a33 1
#include <stdlib.h>
@


1.19
log
@add missing header needed by mkstemp()

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.18 2010/09/08 20:49:11 nicm Exp $	*/
a222 20
}

size_t
buf_fappend(BUF *b, const char *fmt, ...)
{
	size_t ret;
	int n;
	char *str;
	va_list vap;

	va_start(vap, fmt);
	n = vasprintf(&str, fmt, vap);
	va_end(vap);

	if (n == -1)
		errx(1, "buf_fappend: failed to format data");

	ret = buf_append(b, str, n);
	xfree(str);
	return (ret);
@


1.18
log
@Improve buf.c comments, from zinovik.

ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.17 2010/09/08 15:13:39 tobias Exp $	*/
d35 1
@


1.17
log
@Use SIZE_LEFT macro to determine left size instead of calculating with
pointers.

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.16 2010/07/28 09:07:11 ray Exp $	*/
a55 2
 * buf_alloc()
 *
d57 2
a58 2
 * uses dynamically-allocated memory and must be freed with buf_free(),
 * once the buffer is no longer needed.
a78 2
 * buf_load()
 *
a145 2
 * buf_release()
 *
d148 1
a148 1
 * free().
a159 3
/*
 * buf_get()
 */
a166 2
 * buf_empty()
 *
a176 2
 * buf_putc()
 *
a191 2
 * buf_getc()
 *
a192 1
 *
a200 2
 * buf_append()
 *
d202 2
a203 2
 * buffer is too small to accept all data, it
 * will get resized to an appropriate size to accept all data.
a223 4
/*
 * buf_fappend()
 *
 */
a244 2
 * buf_len()
 *
a253 2
 * buf_write_fd()
 *
a281 2
 * buf_write()
 *
a310 2
 * buf_write_stmp()
 *
d312 2
a313 2
 * specified using <template> (see mkstemp.3). NB. This function will modify
 * <template>, as per mkstemp
a333 2
 * buf_grow()
 *
@


1.16
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.15 2010/07/23 21:46:05 ray Exp $	*/
d197 2
a199 7
	if (bp == (b->cb_buf + b->cb_size)) {
		/* extend */
		buf_grow(b, BUF_INCR);

		/* the buffer might have been moved */
		bp = b->cb_buf + b->cb_len;
	}
d228 1
a228 1
	u_char *bp, *bep;
d230 1
a230 3
	bp = b->cb_buf + b->cb_len;
	bep = b->cb_buf + b->cb_size;
	left = bep - bp;
d233 1
a233 1
	if (left < len) {
d235 1
a235 3
		bp = b->cb_buf + b->cb_len;
	}

@


1.15
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.14 2010/07/23 08:31:19 ray Exp $	*/
a44 2
	u_int	cb_flags;

d63 1
a63 1
buf_alloc(size_t len, u_int flags)
a73 1
	b->cb_flags = flags;
d89 1
a89 1
buf_load(const char *path, u_int flags)
d110 1
a110 1
	buf = buf_alloc(st.st_size, flags);
d200 1
a200 4
		if (b->cb_flags & BUF_AUTOEXT)
			buf_grow(b, (size_t)BUF_INCR);
		else
			errx(1, "buf_putc failed");
d225 1
a225 2
 * buffer is too small to accept all data, it will attempt to append as much
 * data as possible, or if the BUF_AUTOEXT flag is set for the buffer, it
d241 2
a242 5
		if (b->cb_flags & BUF_AUTOEXT) {
			buf_grow(b, len - left);
			bp = b->cb_buf + b->cb_len;
		} else
			rlen = bep - bp;
@


1.14
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.13 2007/05/29 00:19:10 ray Exp $	*/
d44 1
a44 1
struct rcs_buf {
d55 1
a55 1
static void	rcs_buf_grow(BUF *, size_t);
d58 1
a58 1
 * rcs_buf_alloc()
d61 1
a61 1
 * uses dynamically-allocated memory and must be freed with rcs_buf_free(),
d65 1
a65 1
rcs_buf_alloc(size_t len, u_int flags)
d84 1
a84 1
 * rcs_buf_load()
d92 1
a92 1
rcs_buf_load(const char *path, u_int flags)
d113 1
a113 1
	buf = rcs_buf_alloc(st.st_size, flags);
d121 1
a121 1
			rcs_buf_free(buf);
a143 5
/*
 * rcs_buf_free()
 *
 * Free the buffer <b> and all associated data.
 */
d145 1
a145 1
rcs_buf_free(BUF *b)
d153 1
a153 1
 * rcs_buf_release()
d160 1
a160 1
rcs_buf_release(BUF *b)
d170 1
a170 1
 * rcs_buf_get()
d173 1
a173 1
rcs_buf_get(BUF *b)
d179 1
a179 1
 * rcs_buf_empty()
d184 1
a184 1
rcs_buf_empty(BUF *b)
d191 1
a191 1
 * rcs_buf_putc()
d196 1
a196 1
rcs_buf_putc(BUF *b, int c)
d204 1
a204 1
			rcs_buf_grow(b, (size_t)BUF_INCR);
d206 1
a206 1
			errx(1, "rcs_buf_putc failed");
d216 1
a216 1
 * rcs_buf_getc()
d222 1
a222 1
rcs_buf_getc(BUF *b, size_t pos)
d228 1
a228 1
 * rcs_buf_append()
d237 1
a237 1
rcs_buf_append(BUF *b, const void *data, size_t len)
d249 1
a249 1
			rcs_buf_grow(b, len - left);
d262 1
a262 1
 * rcs_buf_fappend()
d266 1
a266 1
rcs_buf_fappend(BUF *b, const char *fmt, ...)
d278 1
a278 1
		errx(1, "rcs_buf_fappend: failed to format data");
d280 1
a280 1
	ret = rcs_buf_append(b, str, n);
d286 1
a286 1
 * rcs_buf_len()
d291 1
a291 1
rcs_buf_len(BUF *b)
d297 1
a297 1
 * rcs_buf_write_fd()
d302 1
a302 1
rcs_buf_write_fd(BUF *b, int fd)
d327 1
a327 1
 * rcs_buf_write()
d333 1
a333 1
rcs_buf_write(BUF *b, const char *path, mode_t mode)
d344 1
a344 1
	if (rcs_buf_write_fd(b, fd) == -1) {
d346 1
a346 1
		errx(1, "rcs_buf_write: rcs_buf_write_fd: `%s'", path);
d358 1
a358 1
 * rcs_buf_write_stmp()
d365 1
a365 1
rcs_buf_write_stmp(BUF *b, char *template)
d374 1
a374 1
	if (rcs_buf_write_fd(b, fd) == -1) {
d376 1
a376 1
		errx(1, "rcs_buf_write_stmp: rcs_buf_write_fd: `%s'", template);
d383 1
a383 1
 * rcs_buf_grow()
d389 1
a389 1
rcs_buf_grow(BUF *b, size_t len)
@


1.13
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.12 2007/02/27 07:59:13 xsa Exp $	*/
d377 1
a377 1
	rcs_worklist_add(template, &rcs_temp_files);
@


1.12
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.11 2007/02/22 08:30:45 xsa Exp $	*/
d396 1
a396 4
	void *tmp;

	tmp = xrealloc(b->cb_buf, 1, b->cb_size + len);
	b->cb_buf = tmp;
@


1.11
log
@Fix const inconsistencies, void pointer artithmetic;
Based on diff from otto@@ in OpenCVS. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.10 2007/02/02 04:34:49 ray Exp $	*/
d27 10
a36 1
#include "includes.h"
@


1.10
log
@Remove cb_cur or replace with cb_buf; cb_cur was the same as cb_buf
most of the time and was never of much use.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.9 2007/02/02 04:24:09 ray Exp $	*/
d168 1
a168 1
void *
@


1.9
log
@Remove unused and buggy {cvs,rcs}_buf_set functions.

Bugginess pointed out and fix provided by Pierre Riteau.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.8 2006/08/16 07:39:15 ray Exp $	*/
d38 1
a38 1
	/* buffer handle and size */
a40 3

	/* start and length of valid data in buffer */
	u_char	*cb_cur;
d44 1
a44 2
#define SIZE_LEFT(b)	(b->cb_size - (size_t)(b->cb_cur - b->cb_buf) \
			    - b->cb_len)
a68 1
	b->cb_cur = b->cb_buf;
d105 1
a105 1
	for (bp = buf->cb_cur; ; bp += (size_t)ret) {
a182 1
	b->cb_cur = b->cb_buf;
d196 1
a196 1
	bp = b->cb_cur + b->cb_len;
d205 1
a205 1
		bp = b->cb_cur + b->cb_len;
d220 1
a220 1
	return (b->cb_cur[pos]);
d238 1
a238 1
	bp = b->cb_cur + b->cb_len;
d246 1
a246 1
			bp = b->cb_cur + b->cb_len;
d305 1
a305 1
	bp = b->cb_cur;
a387 1
	size_t diff;
a388 1
	diff = b->cb_cur - b->cb_buf;
a391 3

	/* readjust pointers in case the buffer moved in memory */
	b->cb_cur = b->cb_buf + diff;
@


1.8
log
@Improve rcs_buf_load() by setting errno appropriately on failure and
never print errors or quit on error.

Fix usages of rcs_buf_load() and rcs_set_description.

Also plug an fd leak.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.7 2006/08/02 03:28:50 ray Exp $	*/
a189 34
}

/*
 * rcs_buf_set()
 *
 * Set the contents of the buffer <b> at offset <off> to the first <len>
 * bytes of data found at <src>.  If the buffer was not created with
 * BUF_AUTOEXT, as many bytes as possible will be copied in the buffer.
 */
size_t
rcs_buf_set(BUF *b, const void *src, size_t len, size_t off)
{
	size_t rlen = 0;

	if (b->cb_size < (len + off)) {
		if ((b->cb_flags & BUF_AUTOEXT)) {
			rcs_buf_grow(b, len + off - b->cb_size);
			rlen = len + off;
		} else {
			rlen = b->cb_size - off;
		}
	} else {
		rlen = len;
	}

	b->cb_len = rlen;
	memcpy((b->cb_buf + off), src, rlen);

	if (b->cb_len == 0) {
		b->cb_cur = b->cb_buf + off;
		b->cb_len = rlen;
	}

	return (rlen);
@


1.7
log
@rcs_buf_set(), rcs_buf_append, and rcs_buf_fappend should not return
ssize_t.  The return values aren't usually checked anyway.

Also remove unnecessary casts and improve type usage.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.6 2006/07/08 09:25:44 ray Exp $	*/
d84 2
a85 1
 * Returns the loaded buffer on success.
d97 4
a100 4
	if ((fd = open(path, O_RDONLY, 0600)) == -1) {
		warn("%s", path);
		return (NULL);
	}
d103 1
a103 1
		err(1, "%s", path);
d105 5
a109 1
	buf = rcs_buf_alloc((size_t)st.st_size, flags);
d114 3
d118 3
a120 1
			err(1, "rcs_buf_load");
d127 9
a135 1
	(void)close(fd);
@


1.6
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.5 2006/06/03 03:05:10 niallo Exp $	*/
d181 1
a181 1
ssize_t
d254 1
a254 1
ssize_t
d283 1
a283 1
ssize_t
d286 2
a287 1
	ssize_t ret;
d292 1
a292 1
	ret = vasprintf(&str, fmt, vap);
d295 1
a295 1
	if (ret == -1)
d298 1
a298 1
	ret = rcs_buf_append(b, str, (size_t)ret);
@


1.5
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.4 2006/06/01 21:28:24 niallo Exp $	*/
d382 1
a382 1
rcs_buf_write_stmp(BUF *b, char *template, mode_t mode)
a394 4

	if (fchmod(fd, mode) < 0)
		warn("permissions not set on temporary file %s",
		    template);
@


1.4
log
@-  rcs_buf_release() has no need for u_char since it returns void *
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.3 2006/04/26 15:08:25 xsa Exp $	*/
d150 9
@


1.3
log
@err() cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.2 2006/04/26 08:07:12 xsa Exp $	*/
d145 1
a145 1
	u_char *tmp;
@


1.2
log
@zap -DRCSPROG leftover.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.1 2006/04/26 02:55:13 joris Exp $	*/
d102 1
a102 1
		err(1, "rcs_buf_load: fstat: %s", path);
d110 1
a110 1
			err(1, "rcs_buf_load: read: %s", strerror(errno));
d349 1
a349 1
			err(1, "open: `%s'", path);
d378 1
a378 1
		err(1, "mkstemp: `%s'", template);
@


1.1
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.c,v 1.50 2006/04/14 02:49:43 deraadt Exp $	*/
a379 1
#if defined(RCSPROG)
a380 1
#endif
@

