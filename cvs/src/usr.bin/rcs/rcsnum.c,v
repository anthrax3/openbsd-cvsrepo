head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.6
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.5.0.2
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.20
date	2017.08.29.16.47.33;	author otto;	state Exp;
branches;
next	1.19;
commitid	H6vFKnpT8IoXUPyV;

1.19
date	2016.08.26.09.02.54;	author guenther;	state Exp;
branches;
next	1.18;
commitid	07zudOJ8CxdoPUjD;

1.18
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.17;
commitid	aZp5pu4rATnp3dyP;

1.17
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.16;
commitid	FFUg8uzT5GNAfRXp;

1.16
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	Uu5nFG3wCl0LACBb;

1.15
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Z3HC5pAWzpo5jsTe;

1.14
date	2014.01.07.14.08.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.20.19.21.10;	author nicm;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.22.07.03.02;	author joris;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.31.16.36.11;	author tobias;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.22.08.31.18;	author tobias;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.09.14.02.56;	author tobias;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.12.17.33.05;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.02.04.53.17;	author ray;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2006.07.27.03.17.10;	author ray;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	;


desc
@@


1.20
log
@kill const and string artithmetic related warnings; ok millert@@
@
text
@/*	$OpenBSD: rcsnum.c,v 1.19 2016/08/26 09:02:54 guenther Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "rcs.h"
#include "xmalloc.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

static void	 rcsnum_setsize(RCSNUM *, u_int);
static char	*rcsnum_itoa(u_int16_t, char *, size_t);

int rcsnum_flags;

/*
 * rcsnum_alloc()
 *
 * Allocate an RCS number structure and return a pointer to it.
 */
RCSNUM *
rcsnum_alloc(void)
{
	RCSNUM *rnp;

	rnp = xmalloc(sizeof(*rnp));
	rnp->rn_len = 0;
	rnp->rn_id = NULL;

	return (rnp);
}

/*
 * rcsnum_addmagic()
 *
 * Adds a magic branch number to an RCS number.
 * Returns 0 on success, or -1 on failure.
 */
int
rcsnum_addmagic(RCSNUM *rn)
{
	if (!rn->rn_len || rn->rn_len > RCSNUM_MAXLEN - 1)
		return -1;
	rcsnum_setsize(rn, rn->rn_len + 1);
	rn->rn_id[rn->rn_len - 1] = rn->rn_id[rn->rn_len - 2];
	rn->rn_id[rn->rn_len - 2] = 0;

	return 0;
}

/*
 * rcsnum_parse()
 *
 * Parse a string specifying an RCS number and return the corresponding RCSNUM.
 */
RCSNUM *
rcsnum_parse(const char *str)
{
	const char *ep;
	RCSNUM *num;

	num = rcsnum_alloc();
	if (rcsnum_aton(str, &ep, num) < 0 || *ep != '\0') {
		rcsnum_free(num);
		num = NULL;
		if (*ep != '\0')
			rcs_errno = RCS_ERR_BADNUM;
	}

	return (num);
}

/*
 * rcsnum_free()
 *
 * Free an RCSNUM structure previously allocated with rcsnum_alloc().
 */
void
rcsnum_free(RCSNUM *rn)
{
	if (rn == NULL)
		return;
	free(rn->rn_id);
	free(rn);
}

/*
 * rcsnum_tostr()
 *
 * Format the RCS number <nump> into a human-readable dot-separated
 * representation and store the resulting string in <buf>, which is of size
 * <blen>.
 * Returns a pointer to the start of <buf>.  On failure <buf> is set to
 * an empty string.
 */
char *
rcsnum_tostr(const RCSNUM *nump, char *buf, size_t blen)
{
	u_int i;
	char tmp[8];

	if (nump == NULL || nump->rn_len == 0) {
		buf[0] = '\0';
		return (buf);
	}

	if (strlcpy(buf, rcsnum_itoa(nump->rn_id[0], buf, blen), blen) >= blen)
		errx(1, "rcsnum_tostr: string truncated");
	for (i = 1; i < nump->rn_len; i++) {
		const char *str;

		str = rcsnum_itoa(nump->rn_id[i], tmp, sizeof(tmp));
		if (strlcat(buf, ".", blen) >= blen ||
		    strlcat(buf, str, blen) >= blen)
			errx(1, "rcsnum_tostr: string truncated");
	}

	return (buf);
}

static char *
rcsnum_itoa(u_int16_t num, char *buf, size_t len)
{
	u_int16_t i;
	char *p;

	if (num == 0)
		return "0";

	p = buf + len - 1;
	i = num;
	bzero(buf, len);
	while (i) {
		*--p = '0' + (i % 10);
		i  /= 10;
	}
	return (p);
}

/*
 * rcsnum_cpy()
 *
 * Copy the number stored in <nsrc> in the destination <ndst> up to <depth>
 * numbers deep.  If <depth> is 0, there is no depth limit.
 */
void
rcsnum_cpy(const RCSNUM *nsrc, RCSNUM *ndst, u_int depth)
{
	u_int len;

	len = nsrc->rn_len;
	if (depth != 0 && len > depth)
		len = depth;

	rcsnum_setsize(ndst, len);
	/* Overflow checked in rcsnum_setsize(). */
	(void)memcpy(ndst->rn_id, nsrc->rn_id,
	    len * sizeof(*(nsrc->rn_id)));
}

/*
 * rcsnum_cmp()
 *
 * Compare the two numbers <n1> and <n2>. Returns -1 if <n1> is larger than
 * <n2>, 0 if they are both the same, and 1 if <n2> is larger than <n1>.
 * The <depth> argument specifies how many numbers deep should be checked for
 * the result.  A value of 0 means that the depth will be the maximum of the
 * two numbers, so that a longer number is considered greater than a shorter
 * number if they are equal up to the minimum length.
 */
int
rcsnum_cmp(const RCSNUM *n1, const RCSNUM *n2, u_int depth)
{
	int res;
	u_int i;
	size_t slen;

	slen = MINIMUM(n1->rn_len, n2->rn_len);
	if (depth != 0 && slen > depth)
		slen = depth;

	for (i = 0; i < slen; i++) {
		res = n1->rn_id[i] - n2->rn_id[i];
		if (res < 0)
			return (1);
		else if (res > 0)
			return (-1);
	}

	/* If an explicit depth was specified, and we've
	 * already checked up to depth, consider the
	 * revision numbers equal. */
	if (depth != 0 && slen == depth)
		return (0);
	else if (n1->rn_len > n2->rn_len)
		return (-1);
	else if (n2->rn_len > n1->rn_len)
		return (1);

	return (0);
}

/*
 * rcsnum_aton()
 *
 * Translate the string <str> containing a sequence of digits and periods into
 * its binary representation, which is stored in <nump>.  The address of the
 * first byte not part of the number is stored in <ep> on return, if it is not
 * NULL.
 * Returns 0 on success, or -1 on failure.
 */
int
rcsnum_aton(const char *str, const char **ep, RCSNUM *nump)
{
	u_int32_t val;
	const char *sp;
	char *s;

	if (nump->rn_id == NULL)
		nump->rn_id = xmalloc(sizeof(*(nump->rn_id)));

	nump->rn_len = 0;
	nump->rn_id[0] = 0;

	for (sp = str;; sp++) {
		if (!isdigit((unsigned char)*sp) && (*sp != '.'))
			break;

		if (*sp == '.') {
			if (nump->rn_len >= RCSNUM_MAXLEN - 1) {
				rcs_errno = RCS_ERR_BADNUM;
				goto rcsnum_aton_failed;
			}

			nump->rn_len++;
			nump->rn_id = xreallocarray(nump->rn_id,
			    nump->rn_len + 1, sizeof(*(nump->rn_id)));
			nump->rn_id[nump->rn_len] = 0;
			continue;
		}

		val = (nump->rn_id[nump->rn_len] * 10) + (*sp - '0');
		if (val > RCSNUM_MAXNUM)
			errx(1, "RCSNUM overflow!");

		nump->rn_id[nump->rn_len] = val;
	}

	if (ep != NULL)
		*ep = sp;

	/*
	 * Handle "magic" RCS branch numbers.
	 *
	 * What are they?
	 *
	 * Magic branch numbers have an extra .0. at the second farmost
	 * rightside of the branch number, so instead of having an odd
	 * number of dot-separated decimals, it will have an even number.
	 *
	 * Now, according to all the documentation I've found on the net
	 * about this, cvs does this for "efficiency reasons", I'd like
	 * to hear one.
	 *
	 * We just make sure we remove the .0. from in the branch number.
	 *
	 * XXX - for compatibility reasons with GNU cvs we _need_
	 * to skip this part for the 'log' command, apparently it does
	 * show the magic branches for an unknown and probably
	 * completely insane and not understandable reason in that output.
	 *
	 */
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0
	    && !(rcsnum_flags & RCSNUM_NO_MAGIC)) {
		/*
		 * Look for ".0.x" at the end of the branch number.
		 */
		if ((s = strrchr(str, '.')) != NULL) {
			s--;
			while (*s != '.')
				s--;

			/*
			 * If we have a "magic" branch, adjust it
			 * so the .0. is removed.
			 */
			if (!strncmp(s, RCS_MAGIC_BRANCH,
			    strlen(RCS_MAGIC_BRANCH))) {
				nump->rn_id[nump->rn_len - 1] =
				    nump->rn_id[nump->rn_len];
				nump->rn_len--;
			}
		}
	}

	/* We can't have a single-digit rcs number. */
	if (nump->rn_len == 0) {
		nump->rn_len++;
		nump->rn_id = xreallocarray(nump->rn_id,
		    nump->rn_len + 1, sizeof(*(nump->rn_id)));
		nump->rn_id[nump->rn_len] = 0;
	}

	nump->rn_len++;
	return (nump->rn_len);

rcsnum_aton_failed:
	nump->rn_len = 0;
	free(nump->rn_id);
	nump->rn_id = NULL;
	return (-1);
}

/*
 * rcsnum_inc()
 *
 * Increment the revision number specified in <num>.
 * Returns a pointer to the <num> on success, or NULL on failure.
 */
RCSNUM *
rcsnum_inc(RCSNUM *num)
{
	if (num->rn_id[num->rn_len - 1] == RCSNUM_MAXNUM)
		return (NULL);
	num->rn_id[num->rn_len - 1]++;
	return (num);
}

/*
 * rcsnum_revtobr()
 *
 * Retrieve the branch number associated with the revision number <num>.
 * If <num> is a branch revision, the returned value will be the same
 * number as the argument.
 */
RCSNUM *
rcsnum_revtobr(const RCSNUM *num)
{
	RCSNUM *brnum;

	if (num->rn_len < 2)
		return (NULL);

	brnum = rcsnum_alloc();
	rcsnum_cpy(num, brnum, 0);

	if (!RCSNUM_ISBRANCH(brnum))
		brnum->rn_len--;

	return (brnum);
}

/*
 * rcsnum_brtorev()
 *
 * Retrieve the initial revision number associated with the branch number <num>.
 * If <num> is a revision number, an error will be returned.
 */
RCSNUM *
rcsnum_brtorev(const RCSNUM *brnum)
{
	RCSNUM *num;

	if (!RCSNUM_ISBRANCH(brnum)) {
		return (NULL);
	}

	num = rcsnum_alloc();
	rcsnum_setsize(num, brnum->rn_len + 1);
	rcsnum_cpy(brnum, num, brnum->rn_len);
	num->rn_id[num->rn_len++] = 1;

	return (num);
}

static void
rcsnum_setsize(RCSNUM *num, u_int len)
{
	num->rn_id = xreallocarray(num->rn_id, len, sizeof(*(num->rn_id)));
	num->rn_len = len;
}
@


1.19
log
@Pull in <time.h> for struct tm, used in rcs.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.18 2015/11/02 16:45:21 nicm Exp $	*/
d87 1
a87 1
	char *ep;
d241 1
a241 1
rcsnum_aton(const char *str, char **ep, RCSNUM *nump)
d278 1
a278 1
		*(const char **)ep = sp;
@


1.18
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.17 2015/06/13 20:15:21 nicm Exp $	*/
d29 1
d32 1
a32 1
#include <limits.h>
@


1.17
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.16 2015/01/16 06:40:11 deraadt Exp $	*/
d108 2
@


1.16
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.15 2014/12/01 21:58:46 deraadt Exp $	*/
d29 1
d108 2
a109 3
	if (rn->rn_id != NULL)
		xfree(rn->rn_id);
	xfree(rn);
d334 1
a334 1
	xfree(nump->rn_id);
@


1.15
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.14 2014/01/07 14:08:16 deraadt Exp $	*/
a26 2
#include <sys/param.h>

d30 1
d35 2
d203 1
a203 1
	slen = MIN(n1->rn_len, n2->rn_len);
@


1.14
log
@ctype cleanups; ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.13 2011/05/20 19:21:10 nicm Exp $	*/
d260 1
a260 1
			nump->rn_id = xrealloc(nump->rn_id,
d323 1
a323 1
		nump->rn_id = xrealloc(nump->rn_id,
d403 1
a403 1
	num->rn_id = xrealloc(num->rn_id, len, sizeof(*(num->rn_id)));
@


1.13
log
@Remove a bunch of unused functions, from Michael W Bombardieri.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.12 2010/07/23 21:46:05 ray Exp $	*/
d250 1
a250 1
		if (!isdigit(*sp) && (*sp != '.'))
@


1.12
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.11 2008/05/22 07:03:02 joris Exp $	*/
a349 17
	return (num);
}

/*
 * rcsnum_dec()
 *
 * Decreases the revision number specified in <num>, if doing so will not
 * result in an ending value below 1. E.g. 4.2 will go to 4.1 but 4.1 will
 * be returned as 4.1.
 */
RCSNUM *
rcsnum_dec(RCSNUM *num)
{
	/* XXX - Is it an error for the number to be 0? */
	if (num->rn_id[num->rn_len - 1] <= 1)
		return (num);
	num->rn_id[num->rn_len - 1]--;
@


1.11
log
@correctly deal with non-zero depths specified in rcsnum_cmp();

from Stefan Sperling
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.10 2008/01/31 16:36:11 tobias Exp $	*/
d285 2
a286 2
	 * Now, according to all the documentation i've found on the net
	 * about this, cvs does this for "efficiency reasons", i'd like
d308 3
a310 3
	 		 * If we have a "magic" branch, adjust it
	 		 * so the .0. is removed.
	 		 */
@


1.10
log
@Revert last patch and add this magic branch number only during
output, this way we don't have to hassle in our internal brach handling.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.9 2008/01/22 08:31:18 tobias Exp $	*/
d191 3
a193 2
 * the result.  A value of 0 means that the depth will be the minimum of the
 * two numbers.
d214 6
a219 1
	if (n1->rn_len > n2->rn_len)
@


1.9
log
@Don't remove magic branch numbers from rcs files, as it breaks compatibility
with GNU cvs.

OK niallo@@, ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.8 2007/12/09 14:02:56 tobias Exp $	*/
d59 18
d235 1
d283 2
d286 4
a289 1
	 * to add these magic branch numbers.
d291 21
a311 6
	if (nump->rn_len > 1 && !(nump->rn_len % 2)) {
		nump->rn_len++;
		nump->rn_id = xrealloc(nump->rn_id, nump->rn_len + 1,
		    sizeof(*(nump->rn_id)));
		nump->rn_id[nump->rn_len] = nump->rn_id[nump->rn_len - 1];
		nump->rn_id[nump->rn_len - 1] = 0;
@


1.8
log
@Fix for an off-by-one.

OK fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.7 2007/05/29 00:19:10 ray Exp $	*/
a216 1
	char *s;
a263 2
	 * We just make sure we remove the .0. from in the branch number.
	 *
d265 1
a265 4
	 * to skip this part for the 'log' command, apparently it does
	 * show the magic branches for an unknown and probably
	 * completely insane and not understandable reason in that output.
	 *
d267 6
a272 21
	if (nump->rn_len > 2 && nump->rn_id[nump->rn_len - 1] == 0
	    && !(rcsnum_flags & RCSNUM_NO_MAGIC)) {
		/*
		 * Look for ".0.x" at the end of the branch number.
		 */
		if ((s = strrchr(str, '.')) != NULL) {
			s--;
			while (*s != '.')
				s--;

			/*
			 * If we have a "magic" branch, adjust it
			 * so the .0. is removed.
			 */
			if (!strncmp(s, RCS_MAGIC_BRANCH,
			    strlen(RCS_MAGIC_BRANCH))) {
				nump->rn_id[nump->rn_len - 1] =
				    nump->rn_id[nump->rn_len];
				nump->rn_len--;
			}
		}
@


1.7
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.6 2007/05/12 17:33:05 ray Exp $	*/
d298 1
d301 1
a301 2
		nump->rn_id[nump->rn_len + 1] = 0;
		nump->rn_len++;
@


1.6
log
@Change 0x30 to more readable '0'.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.5 2007/03/02 04:53:17 ray Exp $	*/
a216 1
	void *tmp;
d236 1
a236 1
			tmp = xrealloc(nump->rn_id,
a237 1
			nump->rn_id = tmp;
d298 1
a298 1
		tmp = xrealloc(nump->rn_id,
a299 1
		nump->rn_id = tmp;
d396 1
a396 4
	void *tmp;

	tmp = xrealloc(num->rn_id, len, sizeof(*(num->rn_id)));
	num->rn_id = tmp;
@


1.5
log
@Sync rcsnum.c with OpenCVS, from Charles Longeau.

OK niallo@@ and xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.4 2007/02/27 07:59:13 xsa Exp $	*/
d244 1
a244 1
		val = (nump->rn_id[nump->rn_len] * 10) + (*sp - 0x30);
@


1.4
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.3 2006/07/27 03:17:10 ray Exp $	*/
a155 1
	void *tmp;
d161 2
a162 4
	tmp = xrealloc(ndst->rn_id, len, sizeof(*(nsrc->rn_id)));
	ndst->rn_id = tmp;
	ndst->rn_len = len;
	/* Overflow checked in xrealloc(). */
@


1.3
log
@Not were we allocating memory for a pointer array, it wasn't even for
the right variable!  Fixes make regress with MALLOC_OPTIONS=PR.

Found by and fix worked on with Joris.

OK niallo@@, tested by pedro@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.2 2006/04/29 05:31:28 ray Exp $	*/
d27 5
a31 1
#include "includes.h"
@


1.2
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.1 2006/04/26 02:55:13 joris Exp $	*/
d158 1
a158 1
	tmp = xrealloc(ndst->rn_id, len, sizeof(len));
d162 2
a163 1
	(void)memcpy(ndst->rn_id, nsrc->rn_id, len * sizeof(len));
@


1.1
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsnum.c,v 1.36 2006/04/14 22:33:15 niallo Exp $	*/
d109 2
a110 1
	strlcpy(buf, rcsnum_itoa(nump->rn_id[0], buf, blen), blen);
d112 6
a117 3
		strlcat(buf, ".", blen);
		strlcat(buf, rcsnum_itoa(nump->rn_id[i], tmp, sizeof(tmp)),
		    blen);
@

