head	1.224;
access;
symbols
	OPENBSD_6_2_BASE:1.224
	OPENBSD_6_1:1.224.0.6
	OPENBSD_6_1_BASE:1.224
	OPENBSD_6_0:1.224.0.2
	OPENBSD_6_0_BASE:1.224
	OPENBSD_5_9:1.223.0.2
	OPENBSD_5_9_BASE:1.223
	OPENBSD_5_8:1.221.0.4
	OPENBSD_5_8_BASE:1.221
	OPENBSD_5_7:1.219.0.2
	OPENBSD_5_7_BASE:1.219
	OPENBSD_5_6:1.217.0.4
	OPENBSD_5_6_BASE:1.217
	OPENBSD_5_5:1.216.0.4
	OPENBSD_5_5_BASE:1.216
	OPENBSD_5_4:1.215.0.2
	OPENBSD_5_4_BASE:1.215
	OPENBSD_5_3:1.214.0.2
	OPENBSD_5_3_BASE:1.214
	OPENBSD_5_2:1.213.0.6
	OPENBSD_5_2_BASE:1.213
	OPENBSD_5_1_BASE:1.213
	OPENBSD_5_1:1.213.0.4
	OPENBSD_5_0:1.213.0.2
	OPENBSD_5_0_BASE:1.213
	OPENBSD_4_9:1.211.0.2
	OPENBSD_4_9_BASE:1.211
	OPENBSD_4_8:1.210.0.2
	OPENBSD_4_8_BASE:1.210
	OPENBSD_4_7:1.205.0.4
	OPENBSD_4_7_BASE:1.205
	OPENBSD_4_6:1.205.0.6
	OPENBSD_4_6_BASE:1.205
	OPENBSD_4_5:1.205.0.2
	OPENBSD_4_5_BASE:1.205
	OPENBSD_4_4:1.204.0.2
	OPENBSD_4_4_BASE:1.204
	OPENBSD_4_3:1.203.0.2
	OPENBSD_4_3_BASE:1.203
	OPENBSD_4_2:1.202.0.2
	OPENBSD_4_2_BASE:1.202
	OPENBSD_4_1:1.196.0.2
	OPENBSD_4_1_BASE:1.196
	OPENBSD_4_0:1.186.0.2
	OPENBSD_4_0_BASE:1.186
	OPENBSD_3_9:1.102.0.2
	OPENBSD_3_9_BASE:1.102;
locks; strict;
comment	@ * @;


1.224
date	2016.07.04.01.39.12;	author millert;	state Exp;
branches;
next	1.223;
commitid	9iBcbXzctTwjd6fC;

1.223
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.222;
commitid	aZp5pu4rATnp3dyP;

1.222
date	2015.09.05.09.38.23;	author jsg;	state Exp;
branches;
next	1.221;
commitid	UpUFsGTtXuYYIcjh;

1.221
date	2015.06.17.08.13.31;	author nicm;	state Exp;
branches;
next	1.220;
commitid	Eub7lo0GzJZ2WvZG;

1.220
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.219;
commitid	FFUg8uzT5GNAfRXp;

1.219
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.218;
commitid	Uu5nFG3wCl0LACBb;

1.218
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.217;
commitid	yRuTsAu91VfT3St0;

1.217
date	2014.05.19.19.42.24;	author jca;	state Exp;
branches;
next	1.216;

1.216
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.215;

1.215
date	2013.04.17.00.20.52;	author deraadt;	state Exp;
branches;
next	1.214;

1.214
date	2013.01.18.11.21.09;	author guenther;	state Exp;
branches;
next	1.213;

1.213
date	2011.07.14.16.31.34;	author sobrado;	state Exp;
branches;
next	1.212;

1.212
date	2011.04.20.19.34.16;	author nicm;	state Exp;
branches;
next	1.211;

1.211
date	2010.09.08.15.15.50;	author tobias;	state Exp;
branches;
next	1.210;

1.210
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.209;

1.209
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.208;

1.208
date	2010.07.23.23.59.32;	author ray;	state Exp;
branches;
next	1.207;

1.207
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.206;

1.206
date	2010.07.22.17.49.18;	author millert;	state Exp;
branches;
next	1.205;

1.205
date	2009.02.25.23.16.20;	author ray;	state Exp;
branches;
next	1.204;

1.204
date	2008.03.22.21.15.54;	author millert;	state Exp;
branches;
next	1.203;

1.203
date	2007.09.06.19.38.47;	author niallo;	state Exp;
branches;
next	1.202;

1.202
date	2007.07.03.00.56.23;	author ray;	state Exp;
branches;
next	1.201;

1.201
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.200;

1.200
date	2007.06.26.02.21.02;	author niallo;	state Exp;
branches;
next	1.199;

1.199
date	2007.06.12.06.09.38;	author xsa;	state Exp;
branches;
next	1.198;

1.198
date	2007.04.26.21.48.37;	author sobrado;	state Exp;
branches;
next	1.197;

1.197
date	2007.03.15.13.05.23;	author bluhm;	state Exp;
branches;
next	1.196;

1.196
date	2007.03.03.21.07.23;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.194;

1.194
date	2007.02.22.19.11.13;	author otto;	state Exp;
branches;
next	1.193;

1.193
date	2007.02.14.16.07.29;	author niallo;	state Exp;
branches;
next	1.192;

1.192
date	2007.01.15.14.34.54;	author millert;	state Exp;
branches;
next	1.191;

1.191
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.190;

1.190
date	2006.11.18.20.18.28;	author niallo;	state Exp;
branches;
next	1.189;

1.189
date	2006.11.09.21.47.52;	author millert;	state Exp;
branches;
next	1.188;

1.188
date	2006.09.27.06.26.35;	author ray;	state Exp;
branches;
next	1.187;

1.187
date	2006.09.21.15.30.07;	author millert;	state Exp;
branches;
next	1.186;

1.186
date	2006.08.23.20.28.47;	author joris;	state Exp;
branches;
next	1.185;

1.185
date	2006.08.16.07.39.15;	author ray;	state Exp;
branches;
next	1.184;

1.184
date	2006.08.02.05.16.18;	author ray;	state Exp;
branches;
next	1.183;

1.183
date	2006.08.02.03.18.40;	author ray;	state Exp;
branches;
next	1.182;

1.182
date	2006.07.27.02.57.17;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.180;

1.180
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.179;

1.179
date	2006.06.02.19.10.23;	author david;	state Exp;
branches;
next	1.178;

1.178
date	2006.06.02.18.04.33;	author niallo;	state Exp;
branches;
next	1.177;

1.177
date	2006.05.29.21.17.44;	author ray;	state Exp;
branches;
next	1.176;

1.176
date	2006.05.29.02.58.16;	author niallo;	state Exp;
branches;
next	1.175;

1.175
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.174;

1.174
date	2006.05.17.19.37.40;	author xsa;	state Exp;
branches;
next	1.173;

1.173
date	2006.05.11.08.24.24;	author xsa;	state Exp;
branches;
next	1.172;

1.172
date	2006.05.10.01.10.23;	author ray;	state Exp;
branches;
next	1.171;

1.171
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.170;

1.170
date	2006.05.08.16.56.40;	author xsa;	state Exp;
branches;
next	1.169;

1.169
date	2006.05.05.01.29.59;	author ray;	state Exp;
branches;
next	1.168;

1.168
date	2006.05.04.07.06.58;	author xsa;	state Exp;
branches;
next	1.167;

1.167
date	2006.04.29.06.32.00;	author ray;	state Exp;
branches;
next	1.166;

1.166
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.165;

1.165
date	2006.04.29.05.10.16;	author ray;	state Exp;
branches;
next	1.164;

1.164
date	2006.04.29.04.59.48;	author ray;	state Exp;
branches;
next	1.163;

1.163
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.162;

1.162
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.161;

1.161
date	2006.04.25.13.55.49;	author xsa;	state Exp;
branches;
next	1.160;

1.160
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.159;

1.159
date	2006.04.25.07.57.10;	author xsa;	state Exp;
branches;
next	1.158;

1.158
date	2006.04.24.21.30.47;	author joris;	state Exp;
branches;
next	1.157;

1.157
date	2006.04.24.04.51.57;	author ray;	state Exp;
branches;
next	1.156;

1.156
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.155;

1.155
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.154;

1.154
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.153;

1.153
date	2006.04.18.03.35.57;	author ray;	state Exp;
branches;
next	1.152;

1.152
date	2006.04.18.02.52.18;	author ray;	state Exp;
branches;
next	1.151;

1.151
date	2006.04.18.02.49.31;	author ray;	state Exp;
branches;
next	1.150;

1.150
date	2006.04.18.02.46.21;	author ray;	state Exp;
branches;
next	1.149;

1.149
date	2006.04.17.12.03.19;	author ray;	state Exp;
branches;
next	1.148;

1.148
date	2006.04.16.12.30.00;	author niallo;	state Exp;
branches;
next	1.147;

1.147
date	2006.04.14.01.11.07;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2006.04.14.00.22.46;	author pat;	state Exp;
branches;
next	1.145;

1.145
date	2006.04.13.16.20.28;	author ray;	state Exp;
branches;
next	1.144;

1.144
date	2006.04.13.16.10.29;	author joris;	state Exp;
branches;
next	1.143;

1.143
date	2006.04.13.13.15.18;	author niallo;	state Exp;
branches;
next	1.142;

1.142
date	2006.04.13.03.18.06;	author joris;	state Exp;
branches;
next	1.141;

1.141
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.140;

1.140
date	2006.04.12.08.27.31;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.138;

1.138
date	2006.04.10.19.49.44;	author joris;	state Exp;
branches;
next	1.137;

1.137
date	2006.04.09.19.22.23;	author niallo;	state Exp;
branches;
next	1.136;

1.136
date	2006.04.06.10.13.00;	author xsa;	state Exp;
branches;
next	1.135;

1.135
date	2006.04.05.01.38.56;	author ray;	state Exp;
branches;
next	1.134;

1.134
date	2006.04.01.13.57.48;	author niallo;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.31.01.39.36;	author joris;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.30.23.19.20;	author joris;	state Exp;
branches;
next	1.131;

1.131
date	2006.03.28.12.48.51;	author xsa;	state Exp;
branches;
next	1.130;

1.130
date	2006.03.28.12.07.10;	author xsa;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.27.22.11.08;	author niallo;	state Exp;
branches;
next	1.128;

1.128
date	2006.03.27.21.56.32;	author niallo;	state Exp;
branches;
next	1.127;

1.127
date	2006.03.27.13.07.37;	author xsa;	state Exp;
branches;
next	1.126;

1.126
date	2006.03.26.12.56.31;	author niallo;	state Exp;
branches;
next	1.125;

1.125
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.124;

1.124
date	2006.03.23.08.50.41;	author xsa;	state Exp;
branches;
next	1.123;

1.123
date	2006.03.20.16.18.13;	author niallo;	state Exp;
branches;
next	1.122;

1.122
date	2006.03.17.07.32.03;	author ray;	state Exp;
branches;
next	1.121;

1.121
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.120;

1.120
date	2006.03.15.20.57.14;	author joris;	state Exp;
branches;
next	1.119;

1.119
date	2006.03.15.16.04.08;	author xsa;	state Exp;
branches;
next	1.118;

1.118
date	2006.03.15.05.05.35;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2006.03.15.03.29.01;	author ray;	state Exp;
branches;
next	1.116;

1.116
date	2006.03.14.03.33.30;	author ray;	state Exp;
branches;
next	1.115;

1.115
date	2006.03.11.22.44.11;	author niallo;	state Exp;
branches;
next	1.114;

1.114
date	2006.03.11.18.38.54;	author niallo;	state Exp;
branches;
next	1.113;

1.113
date	2006.03.10.11.51.19;	author xsa;	state Exp;
branches;
next	1.112;

1.112
date	2006.03.08.20.19.39;	author joris;	state Exp;
branches;
next	1.111;

1.111
date	2006.03.07.01.47.42;	author joris;	state Exp;
branches;
next	1.110;

1.110
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.109;

1.109
date	2006.03.06.15.04.17;	author niallo;	state Exp;
branches;
next	1.108;

1.108
date	2006.03.06.14.49.54;	author jmc;	state Exp;
branches;
next	1.107;

1.107
date	2006.03.06.09.41.53;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2006.03.05.17.35.24;	author niallo;	state Exp;
branches;
next	1.105;

1.105
date	2006.03.05.17.20.35;	author niallo;	state Exp;
branches;
next	1.104;

1.104
date	2006.03.05.17.17.27;	author niallo;	state Exp;
branches;
next	1.103;

1.103
date	2006.03.05.15.47.17;	author niallo;	state Exp;
branches;
next	1.102;

1.102
date	2006.02.20.16.30.18;	author niallo;	state Exp;
branches;
next	1.101;

1.101
date	2006.02.20.16.27.58;	author niallo;	state Exp;
branches;
next	1.100;

1.100
date	2006.02.16.19.15.30;	author niallo;	state Exp;
branches;
next	1.99;

1.99
date	2006.02.16.18.05.47;	author niallo;	state Exp;
branches;
next	1.98;

1.98
date	2006.02.16.17.44.53;	author niallo;	state Exp;
branches;
next	1.97;

1.97
date	2006.02.16.17.30.46;	author niallo;	state Exp;
branches;
next	1.96;

1.96
date	2006.02.16.16.43.45;	author niallo;	state Exp;
branches;
next	1.95;

1.95
date	2006.02.16.13.32.27;	author niallo;	state Exp;
branches;
next	1.94;

1.94
date	2006.02.16.13.22.02;	author niallo;	state Exp;
branches;
next	1.93;

1.93
date	2006.02.14.13.26.43;	author xsa;	state Exp;
branches;
next	1.92;

1.92
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.91;

1.91
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.90;

1.90
date	2005.12.27.16.05.21;	author niallo;	state Exp;
branches;
next	1.89;

1.89
date	2005.12.23.00.59.55;	author joris;	state Exp;
branches;
next	1.88;

1.88
date	2005.12.21.19.59.58;	author alek;	state Exp;
branches;
next	1.87;

1.87
date	2005.12.20.09.04.17;	author xsa;	state Exp;
branches;
next	1.86;

1.86
date	2005.12.19.18.24.12;	author xsa;	state Exp;
branches;
next	1.85;

1.85
date	2005.12.12.09.40.08;	author xsa;	state Exp;
branches;
next	1.84;

1.84
date	2005.12.10.20.27.46;	author joris;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.09.04.27.01;	author joris;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.08.18.56.10;	author joris;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.03.17.11.58;	author niallo;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.03.16.50.48;	author niallo;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.02.14.29.13;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.02.13.53.43;	author xsa;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.02.13.43.32;	author xsa;	state Exp;
branches;
next	1.76;

1.76
date	2005.12.02.01.13.12;	author niallo;	state Exp;
branches;
next	1.75;

1.75
date	2005.12.02.00.15.35;	author niallo;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.28.09.16.32;	author xsa;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.28.08.49.25;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.27.17.47.18;	author niallo;	state Exp;
branches;
next	1.70;

1.70
date	2005.11.27.16.15.26;	author niallo;	state Exp;
branches;
next	1.69;

1.69
date	2005.11.24.15.35.11;	author xsa;	state Exp;
branches;
next	1.68;

1.68
date	2005.11.23.14.21.53;	author xsa;	state Exp;
branches;
next	1.67;

1.67
date	2005.11.23.09.39.20;	author xsa;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.22.11.49.02;	author niallo;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.22.09.54.00;	author xsa;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.21.16.20.28;	author xsa;	state Exp;
branches;
next	1.63;

1.63
date	2005.11.21.15.16.41;	author niallo;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.17.00.22.30;	author niallo;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.17.00.16.35;	author niallo;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.17.00.03.04;	author niallo;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.16.19.23.46;	author niallo;	state Exp;
branches;
next	1.58;

1.58
date	2005.11.16.19.06.41;	author niallo;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.08.15.58.38;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.02.21.42.16;	author niallo;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.02.20.40.56;	author niallo;	state Exp;
branches;
next	1.54;

1.54
date	2005.11.02.20.32.45;	author niallo;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.30.09.46.07;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2005.10.29.19.10.16;	author niallo;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.29.19.05.51;	author niallo;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.27.07.43.56;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.25.17.48.56;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.25.17.27.54;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.19.11.37.11;	author niallo;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.18.01.39.47;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.18.01.22.14;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.18.01.10.28;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.17.22.24.18;	author niallo;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.17.22.04.54;	author niallo;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.17.15.33.12;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.16.23.30.45;	author niallo;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.16.22.56.22;	author niallo;	state Exp;
branches;
next	1.38;

1.38
date	2005.10.16.22.23.54;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2005.10.16.14.10.57;	author niallo;	state Exp;
branches;
next	1.36;

1.36
date	2005.10.16.11.40.56;	author niallo;	state Exp;
branches;
next	1.35;

1.35
date	2005.10.16.11.36.56;	author niallo;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.16.11.35.11;	author niallo;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.16.11.29.28;	author niallo;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.16.01.55.36;	author joris;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.15.23.44.58;	author niallo;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.15.21.33.21;	author niallo;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.15.19.45.23;	author niallo;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.15.18.26.24;	author niallo;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.15.14.23.06;	author niallo;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.13.23.00.49;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.13.22.54.46;	author niallo;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.12.22.57.26;	author niallo;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.11.15.52.13;	author niallo;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.11.15.50.25;	author niallo;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.10.17.12.49;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.10.15.05.48;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.10.14.49.32;	author niallo;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.10.14.21.37;	author niallo;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.09.21.17.59;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.09.19.29.22;	author joris;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.09.17.51.33;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.09.14.48.13;	author niallo;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.08.16.27.41;	author niallo;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.08.16.19.40;	author niallo;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.08.15.26.47;	author niallo;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.08.14.25.55;	author niallo;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.08.14.18.35;	author niallo;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.08.14.09.18;	author niallo;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.08.11.50.59;	author niallo;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.30.17.39.48;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.30.16.49.37;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.30.16.37.27;	author niallo;	state Exp;
branches;
next	;


desc
@@


1.224
log
@The -I flag is documented but not implemented.  This fixes that and
also honors the -I flag from ci/co when prompting like GNU RCS.
OK jca@@
@
text
@/*	$OpenBSD: ci.c,v 1.223 2015/11/02 16:45:21 nicm Exp $	*/
/*
 * Copyright (c) 2005, 2006 Niall O'Higgins <niallo@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

#define CI_OPTSTRING	"d::f::I::i::j::k::l::M::m::N:n:qr::s:Tt::u::Vw:x::z::"
#define DATE_NOW	-1
#define DATE_MTIME	-2

#define KW_ID		"Id"
#define KW_OPENBSD	"OpenBSD"
#define KW_AUTHOR	"Author"
#define KW_DATE		"Date"
#define KW_STATE	"State"
#define KW_REVISION	"Revision"

#define KW_TYPE_ID		1
#define KW_TYPE_AUTHOR		2
#define KW_TYPE_DATE		3
#define KW_TYPE_STATE		4
#define KW_TYPE_REVISION	5

/* Maximum number of tokens in a keyword. */
#define KW_NUMTOKS_MAX		10

#define RCSNUM_ZERO_ENDING(x) (x->rn_id[x->rn_len - 1] == 0)

extern struct rcs_kw rcs_expkw[];

static int workfile_fd;

struct checkin_params {
	int flags, openflags;
	mode_t fmode;
	time_t date;
	RCSFILE *file;
	RCSNUM *frev, *newrev;
	const char *description, *symbol;
	char fpath[PATH_MAX], *rcs_msg, *username, *filename;
	char *author, *state;
	BUF *deltatext;
};

static int	 checkin_attach_symbol(struct checkin_params *);
static int	 checkin_checklock(struct checkin_params *);
static BUF	*checkin_diff_file(struct checkin_params *);
static char	*checkin_getlogmsg(RCSNUM *, RCSNUM *, int);
static int	 checkin_init(struct checkin_params *);
static int	 checkin_keywordscan(BUF *, RCSNUM **, time_t *, char **,
    char **);
static int	 checkin_keywordtype(char *);
static void	 checkin_mtimedate(struct checkin_params *);
static void	 checkin_parsekeyword(char *, RCSNUM **, time_t *, char **,
    char **);
static int	 checkin_update(struct checkin_params *);
static int	 checkin_revert(struct checkin_params *);

__dead void
checkin_usage(void)
{
	fprintf(stderr,
	    "usage: ci [-qV] [-d[date]] [-f[rev]] [-I[rev]] [-i[rev]]\n"
	    "          [-j[rev]] [-k[rev]] [-l[rev]] [-M[rev]] [-mmsg]\n"
	    "          [-Nsymbol] [-nsymbol] [-r[rev]] [-sstate] [-t[str]]\n"
	    "          [-u[rev]] [-wusername] [-xsuffixes] [-ztz] file ...\n");

	exit(1);
}

/*
 * checkin_main()
 *
 * Handler for the `ci' program.
 * Returns 0 on success, or >0 on error.
 */
int
checkin_main(int argc, char **argv)
{
	int fd;
	int i, ch, status;
	int base_flags, base_openflags;
	char *rev_str;
	struct checkin_params pb;

	pb.date = DATE_NOW;
	pb.file = NULL;
	pb.rcs_msg = pb.username = pb.author = pb.state = NULL;
	pb.description = pb.symbol = NULL;
	pb.deltatext = NULL;
	pb.newrev =  NULL;
	pb.fmode = S_IRUSR|S_IRGRP|S_IROTH;
	status = 0;
	base_flags = INTERACTIVE;
	base_openflags = RCS_RDWR|RCS_CREATE|RCS_PARSE_FULLY;
	rev_str = NULL;

	while ((ch = rcs_getopt(argc, argv, CI_OPTSTRING)) != -1) {
		switch (ch) {
		case 'd':
			if (rcs_optarg == NULL)
				pb.date = DATE_MTIME;
			else if ((pb.date = date_parse(rcs_optarg)) == -1)
				errx(1, "invalid date");
			break;
		case 'f':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= FORCE;
			break;
		case 'I':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= INTERACTIVE;
			break;
		case 'i':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_openflags |= RCS_CREATE;
			base_flags |= CI_INIT;
			break;
		case 'j':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_openflags &= ~RCS_CREATE;
			base_flags &= ~CI_INIT;
			break;
		case 'k':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= CI_KEYWORDSCAN;
			break;
		case 'l':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= CO_LOCK;
			break;
		case 'M':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= CO_REVDATE;
			break;
		case 'm':
			pb.rcs_msg = rcs_optarg;
			if (pb.rcs_msg == NULL)
				errx(1, "missing message for -m option");
			base_flags &= ~INTERACTIVE;
			break;
		case 'N':
			base_flags |= CI_SYMFORCE;
			/* FALLTHROUGH */
		case 'n':
			pb.symbol = rcs_optarg;
			if (rcs_sym_check(pb.symbol) != 1)
				errx(1, "invalid symbol `%s'", pb.symbol);
			break;
		case 'q':
			base_flags |= QUIET;
			break;
		case 'r':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= CI_DEFAULT;
			break;
		case 's':
			pb.state = rcs_optarg;
			if (rcs_state_check(pb.state) < 0)
				errx(1, "invalid state `%s'", pb.state);
			break;
		case 'T':
			base_flags |= PRESERVETIME;
			break;
		case 't':
			/* Ignore bare -t; kept for backwards compatibility. */
			if (rcs_optarg == NULL)
				break;
			pb.description = rcs_optarg;
			base_flags |= DESCRIPTION;
			break;
		case 'u':
			rcs_setrevstr(&rev_str, rcs_optarg);
			base_flags |= CO_UNLOCK;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'w':
			free(pb.author);
			pb.author = xstrdup(rcs_optarg);
			break;
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			timezone_flag = rcs_optarg;
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (argc == 0) {
		warnx("no input file");
		(usage)();
	}

	if ((pb.username = getlogin()) == NULL)
		err(1, "getlogin");

	for (i = 0; i < argc; i++) {
		/*
		 * The pb.flags and pb.openflags may change during
		 * loop iteration so restore them for each file.
		 */
		pb.flags = base_flags;
		pb.openflags = base_openflags;

		pb.filename = argv[i];
		rcs_strip_suffix(pb.filename);

		if ((workfile_fd = open(pb.filename, O_RDONLY)) == -1)
			err(1, "%s", pb.filename);

		/* Find RCS file path. */
		fd = rcs_choosefile(pb.filename, pb.fpath, sizeof(pb.fpath));

		if (fd < 0) {
			if (pb.openflags & RCS_CREATE)
				pb.flags |= NEWFILE;
			else {
				/* XXX - Check if errno == ENOENT. */
				warnx("No existing RCS file");
				status = 1;
				(void)close(workfile_fd);
				continue;
			}
		} else {
			if (pb.flags & CI_INIT) {
				warnx("%s already exists", pb.fpath);
				status = 1;
				(void)close(fd);
				(void)close(workfile_fd);
				continue;
			}
			pb.openflags &= ~RCS_CREATE;
		}

		pb.file = rcs_open(pb.fpath, fd, pb.openflags, pb.fmode);
		if (pb.file == NULL)
			errx(1, "failed to open rcsfile `%s'", pb.fpath);

		if ((pb.flags & DESCRIPTION) &&
		    rcs_set_description(pb.file, pb.description, pb.flags) == -1)
			err(1, "%s", pb.filename);

		if (!(pb.flags & QUIET))
			(void)fprintf(stderr,
			    "%s  <--  %s\n", pb.fpath, pb.filename);

		if (rev_str != NULL)
			if ((pb.newrev = rcs_getrevnum(rev_str, pb.file)) ==
			    NULL)
				errx(1, "invalid revision: %s", rev_str);

		if (!(pb.flags & NEWFILE))
			pb.flags |= CI_SKIPDESC;

		/* XXX - support for committing to a file without revisions */
		if (pb.file->rf_ndelta == 0) {
			pb.flags |= NEWFILE;
			pb.file->rf_flags |= RCS_CREATE;
		}

		/*
		 * workfile_fd will be closed in checkin_init or
		 * checkin_update
		 */
		if (pb.flags & NEWFILE) {
			if (checkin_init(&pb) == -1)
				status = 1;
		} else {
			if (checkin_update(&pb) == -1)
				status = 1;
		}

		rcs_close(pb.file);
		if (rev_str != NULL)
			rcsnum_free(pb.newrev);
		pb.newrev = NULL;
	}

	if (!(base_flags & QUIET) && status == 0)
		(void)fprintf(stderr, "done\n");

	return (status);
}

/*
 * checkin_diff_file()
 *
 * Generate the diff between the working file and a revision.
 * Returns pointer to a BUF on success, NULL on failure.
 */
static BUF *
checkin_diff_file(struct checkin_params *pb)
{
	char *path1, *path2;
	BUF *b1, *b2, *b3;

	b1 = b2 = b3 = NULL;
	path1 = path2 = NULL;

	if ((b1 = buf_load(pb->filename)) == NULL) {
		warnx("failed to load file: `%s'", pb->filename);
		goto out;
	}

	if ((b2 = rcs_getrev(pb->file, pb->frev)) == NULL) {
		warnx("failed to load revision");
		goto out;
	}
	b2 = rcs_kwexp_buf(b2, pb->file, pb->frev);
	b3 = buf_alloc(128);

	(void)xasprintf(&path1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b1, path1);

	buf_free(b1);
	b1 = NULL;

	(void)xasprintf(&path2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(b2, path2);

	buf_free(b2);
	b2 = NULL;

	diff_format = D_RCSDIFF;
	if (diffreg(path1, path2, b3, D_FORCEASCII) == D_ERROR)
		goto out;

	return (b3);
out:
	buf_free(b1);
	buf_free(b2);
	buf_free(b3);
	free(path1);
	free(path2);

	return (NULL);
}

/*
 * checkin_getlogmsg()
 *
 * Get log message from user interactively.
 * Returns pointer to a char array on success, NULL on failure.
 */
static char *
checkin_getlogmsg(RCSNUM *rev, RCSNUM *rev2, int flags)
{
	char   *rcs_msg, nrev[RCS_REV_BUFSZ], prev[RCS_REV_BUFSZ];
	const char *prompt =
	    "enter log message, terminated with a single '.' or end of file:\n";
	RCSNUM *tmprev;

	rcs_msg = NULL;
	tmprev = rcsnum_alloc();
	rcsnum_cpy(rev, tmprev, 16);
	rcsnum_tostr(tmprev, prev, sizeof(prev));
	if (rev2 == NULL)
		rcsnum_tostr(rcsnum_inc(tmprev), nrev, sizeof(nrev));
	else
		rcsnum_tostr(rev2, nrev, sizeof(nrev));
	rcsnum_free(tmprev);

	if (!(flags & QUIET))
		(void)fprintf(stderr, "new revision: %s; "
		    "previous revision: %s\n", nrev, prev);

	rcs_msg = rcs_prompt(prompt, flags);

	return (rcs_msg);
}

/*
 * checkin_update()
 *
 * Do a checkin to an existing RCS file.
 *
 * On success, return 0. On error return -1.
 */
static int
checkin_update(struct checkin_params *pb)
{
	char numb1[RCS_REV_BUFSZ], numb2[RCS_REV_BUFSZ];
	struct stat st;
	BUF *bp;

	/*
	 * XXX this is wrong, we need to get the revision the user
	 * has the lock for. So we can decide if we want to create a
	 * branch or not. (if it's not current HEAD we need to branch).
	 */
	pb->frev = pb->file->rf_head;

	/* Load file contents */
	if ((bp = buf_load(pb->filename)) == NULL)
		return (-1);

	/* If this is a zero-ending RCSNUM eg 4.0, increment it (eg to 4.1) */
	if (pb->newrev != NULL && RCSNUM_ZERO_ENDING(pb->newrev))
		pb->newrev = rcsnum_inc(pb->newrev);

	if (checkin_checklock(pb) < 0)
		return (-1);

	/* If revision passed on command line is less than HEAD, bail.
	 * XXX only applies to ci -r1.2 foo for example if HEAD is > 1.2 and
	 * there is no lock set for the user.
	 */
	if (pb->newrev != NULL &&
	    rcsnum_cmp(pb->newrev, pb->frev, 0) != -1) {
		warnx("%s: revision %s too low; must be higher than %s",
		    pb->file->rf_path,
		    rcsnum_tostr(pb->newrev, numb1, sizeof(numb1)),
		    rcsnum_tostr(pb->frev, numb2, sizeof(numb2)));
		return (-1);
	}

	/*
	 * Set the date of the revision to be the last modification
	 * time of the working file if -d has no argument.
	 */
	if (pb->date == DATE_MTIME)
		checkin_mtimedate(pb);

	/* Date from argv/mtime must be more recent than HEAD */
	if (pb->date != DATE_NOW) {
		time_t head_date = rcs_rev_getdate(pb->file, pb->frev);
		if (pb->date <= head_date) {
			static const char fmt[] = "%Y/%m/%d %H:%M:%S";
			char dbuf1[256], dbuf2[256];
			struct tm *t, *t_head;

			t = gmtime(&pb->date);
			strftime(dbuf1, sizeof(dbuf1), fmt, t);
			t_head = gmtime(&head_date);
			strftime(dbuf2, sizeof(dbuf2), fmt, t_head);

			errx(1, "%s: Date %s precedes %s in revision %s.",
			    pb->file->rf_path, dbuf1, dbuf2,
			    rcsnum_tostr(pb->frev, numb2, sizeof(numb2)));
		}
	}

	/* Get RCS patch */
	if ((pb->deltatext = checkin_diff_file(pb)) == NULL) {
		warnx("failed to get diff");
		return (-1);
	}

	/*
	 * If -f is not specified and there are no differences, tell
	 * the user and revert to latest version.
	 */
	if (!(pb->flags & FORCE) && (buf_len(pb->deltatext) < 1)) {
		if (checkin_revert(pb) == -1)
			return (-1);
		else
			return (0);
	}

	/* If no log message specified, get it interactively. */
	if (pb->flags & INTERACTIVE) {
		if (pb->rcs_msg != NULL) {
			fprintf(stderr,
			    "reuse log message of previous file? [yn](y): ");
			if (rcs_yesno('y') != 'y') {
				free(pb->rcs_msg);
				pb->rcs_msg = NULL;
			}
		}
		if (pb->rcs_msg == NULL)
			pb->rcs_msg = checkin_getlogmsg(pb->frev, pb->newrev,
			    pb->flags);
	}

	if ((rcs_lock_remove(pb->file, pb->username, pb->frev) < 0) &&
	    (rcs_lock_getmode(pb->file) != RCS_LOCK_LOOSE)) {
		if (rcs_errno != RCS_ERR_NOENT)
			warnx("failed to remove lock");
		else if (!(pb->flags & CO_LOCK))
			warnx("previous revision was not locked; "
			    "ignoring -l option");
	}

	/* Current head revision gets the RCS patch as rd_text */
	if (rcs_deltatext_set(pb->file, pb->frev, pb->deltatext) == -1)
		errx(1, "failed to set new rd_text for head rev");

	/* Now add our new revision */
	if (rcs_rev_add(pb->file,
	    (pb->newrev == NULL ? RCS_HEAD_REV : pb->newrev),
	    pb->rcs_msg, pb->date, pb->author) != 0) {
		warnx("failed to add new revision");
		return (-1);
	}

	/*
	 * If we are checking in to a non-default (ie user-specified)
	 * revision, set head to this revision.
	 */
	if (pb->newrev != NULL) {
		if (rcs_head_set(pb->file, pb->newrev) < 0)
			errx(1, "rcs_head_set failed");
	} else
		pb->newrev = pb->file->rf_head;

	/* New head revision has to contain entire file; */
	if (rcs_deltatext_set(pb->file, pb->frev, bp) == -1)
		errx(1, "failed to set new head revision");

	/* Attach a symbolic name to this revision if specified. */
	if (pb->symbol != NULL &&
	    (checkin_attach_symbol(pb) < 0))
		return (-1);

	/* Set the state of this revision if specified. */
	if (pb->state != NULL)
		(void)rcs_state_set(pb->file, pb->newrev, pb->state);

	/* Maintain RCSFILE permissions */
	if (fstat(workfile_fd, &st) == -1)
		err(1, "%s", pb->filename);

	/* Strip all the write bits */
	pb->file->rf_mode = st.st_mode & ~(S_IWUSR|S_IWGRP|S_IWOTH);

	(void)close(workfile_fd);
	(void)unlink(pb->filename);

	/* Write out RCSFILE before calling checkout_rev() */
	rcs_write(pb->file);

	/* Do checkout if -u or -l are specified. */
	if (((pb->flags & CO_LOCK) || (pb->flags & CO_UNLOCK)) &&
	    !(pb->flags & CI_DEFAULT))
		checkout_rev(pb->file, pb->newrev, pb->filename, pb->flags,
		    pb->username, pb->author, NULL, NULL);

	if ((pb->flags & INTERACTIVE) && (pb->rcs_msg[0] == '\0')) {
		free(pb->rcs_msg);	/* free empty log message */
		pb->rcs_msg = NULL;
	}

	return (0);
}

/*
 * checkin_init()
 *
 * Does an initial check in, just enough to create the new ,v file
 * On success, return 0. On error return -1.
 */
static int
checkin_init(struct checkin_params *pb)
{
	BUF *bp;
	char numb[RCS_REV_BUFSZ];
	int fetchlog = 0;
	struct stat st;

	/* If this is a zero-ending RCSNUM eg 4.0, increment it (eg to 4.1) */
	if (pb->newrev != NULL && RCSNUM_ZERO_ENDING(pb->newrev)) {
		pb->frev = rcsnum_alloc();
		rcsnum_cpy(pb->newrev, pb->frev, 0);
		pb->newrev = rcsnum_inc(pb->newrev);
		fetchlog = 1;
	}

	/* Load file contents */
	if ((bp = buf_load(pb->filename)) == NULL)
		return (-1);

	/* Get default values from working copy if -k specified */
	if (pb->flags & CI_KEYWORDSCAN)
		checkin_keywordscan(bp, &pb->newrev,
		    &pb->date, &pb->state, &pb->author);

	if (pb->flags & CI_SKIPDESC)
		goto skipdesc;

	/* Get description from user */
	if (pb->description == NULL &&
	    rcs_set_description(pb->file, NULL, pb->flags) == -1) {
		warn("%s", pb->filename);
		return (-1);
	}

skipdesc:

	/*
	 * If the user had specified a zero-ending revision number e.g. 4.0
	 * emulate odd GNU behaviour and fetch log message.
	 */
	if (fetchlog == 1) {
		pb->rcs_msg = checkin_getlogmsg(pb->frev, pb->newrev,
		    pb->flags);
		rcsnum_free(pb->frev);
	}

	/*
	 * Set the date of the revision to be the last modification
	 * time of the working file if -d has no argument.
	 */
	if (pb->date == DATE_MTIME)
		checkin_mtimedate(pb);

	/* Now add our new revision */
	if (rcs_rev_add(pb->file,
	    (pb->newrev == NULL ? RCS_HEAD_REV : pb->newrev),
	    (pb->rcs_msg == NULL ? "Initial revision" : pb->rcs_msg),
	    pb->date, pb->author) != 0) {
		warnx("failed to add new revision");
		return (-1);
	}

	/*
	 * If we are checking in to a non-default (ie user-specified)
	 * revision, set head to this revision.
	 */
	if (pb->newrev != NULL) {
		if (rcs_head_set(pb->file, pb->newrev) < 0)
			errx(1, "rcs_head_set failed");
	} else
		pb->newrev = pb->file->rf_head;

	/* New head revision has to contain entire file; */
	if (rcs_deltatext_set(pb->file, pb->file->rf_head, bp) == -1) {
		warnx("failed to set new head revision");
		return (-1);
	}

	/* Attach a symbolic name to this revision if specified. */
	if (pb->symbol != NULL && checkin_attach_symbol(pb) < 0)
		return (-1);

	/* Set the state of this revision if specified. */
	if (pb->state != NULL)
		(void)rcs_state_set(pb->file, pb->newrev, pb->state);

	/* Inherit RCSFILE permissions from file being checked in */
	if (fstat(workfile_fd, &st) == -1)
		err(1, "%s", pb->filename);

	/* Strip all the write bits */
	pb->file->rf_mode = st.st_mode & ~(S_IWUSR|S_IWGRP|S_IWOTH);

	(void)close(workfile_fd);
	(void)unlink(pb->filename);

	/* Write out RCSFILE before calling checkout_rev() */
	rcs_write(pb->file);

	/* Do checkout if -u or -l are specified. */
	if (((pb->flags & CO_LOCK) || (pb->flags & CO_UNLOCK)) &&
	    !(pb->flags & CI_DEFAULT)) {
		checkout_rev(pb->file, pb->newrev, pb->filename, pb->flags,
		    pb->username, pb->author, NULL, NULL);
	}

	if (!(pb->flags & QUIET)) {
		fprintf(stderr, "initial revision: %s\n",
		    rcsnum_tostr(pb->newrev, numb, sizeof(numb)));
	}

	return (0);
}

/*
 * checkin_attach_symbol()
 *
 * Attempt to attach the specified symbol to the revision.
 * On success, return 0. On error return -1.
 */
static int
checkin_attach_symbol(struct checkin_params *pb)
{
	char rbuf[RCS_REV_BUFSZ];
	int ret;
	if (!(pb->flags & QUIET))
		printf("symbol: %s\n", pb->symbol);
	if (pb->flags & CI_SYMFORCE) {
		if (rcs_sym_remove(pb->file, pb->symbol) < 0) {
			if (rcs_errno != RCS_ERR_NOENT) {
				warnx("problem removing symbol: %s",
				    pb->symbol);
				return (-1);
			}
		}
	}
	if ((ret = rcs_sym_add(pb->file, pb->symbol, pb->newrev)) == -1 &&
	    (rcs_errno == RCS_ERR_DUPENT)) {
		rcsnum_tostr(rcs_sym_getrev(pb->file, pb->symbol),
		    rbuf, sizeof(rbuf));
		warnx("symbolic name %s already bound to %s", pb->symbol, rbuf);
		return (-1);
	} else if (ret == -1) {
		warnx("problem adding symbol: %s", pb->symbol);
		return (-1);
	}
	return (0);
}

/*
 * checkin_revert()
 *
 * If there are no differences between the working file and the latest revision
 * and the -f flag is not specified, simply revert to the latest version and
 * warn the user.
 *
 */
static int
checkin_revert(struct checkin_params *pb)
{
	char rbuf[RCS_REV_BUFSZ];

	rcsnum_tostr(pb->frev, rbuf, sizeof(rbuf));

	if (!(pb->flags & QUIET))
		(void)fprintf(stderr, "file is unchanged; reverting "
		    "to previous revision %s\n", rbuf);

	/* Attach a symbolic name to this revision if specified. */
	if (pb->symbol != NULL) {
		if (checkin_checklock(pb) == -1)
			return (-1);

		pb->newrev = pb->frev;
		if (checkin_attach_symbol(pb) == -1)
			return (-1);
	}

	pb->flags |= CO_REVERT;
	(void)close(workfile_fd);
	(void)unlink(pb->filename);
	
	/* If needed, write out RCSFILE before calling checkout_rev() */
	if (pb->symbol != NULL)
		rcs_write(pb->file);

	if ((pb->flags & CO_LOCK) || (pb->flags & CO_UNLOCK))
		checkout_rev(pb->file, pb->frev, pb->filename,
		    pb->flags, pb->username, pb->author, NULL, NULL);

	return (0);
}

/*
 * checkin_checklock()
 *
 * Check for the existence of a lock on the file.  If there are no locks, or it
 * is not locked by the correct user, return -1.  Otherwise, return 0.
 */
static int
checkin_checklock(struct checkin_params *pb)
{
	struct rcs_lock *lkp;

	if (rcs_lock_getmode(pb->file) == RCS_LOCK_LOOSE)
		return (0);

	TAILQ_FOREACH(lkp, &(pb->file->rf_locks), rl_list) {
		if (!strcmp(lkp->rl_name, pb->username) &&
		    !rcsnum_cmp(lkp->rl_num, pb->frev, 0))
			return (0);
	}

	warnx("%s: no lock set by %s", pb->file->rf_path, pb->username);
	return (-1);
}

/*
 * checkin_mtimedate()
 *
 * Set the date of the revision to be the last modification
 * time of the working file.
 */
static void
checkin_mtimedate(struct checkin_params *pb)
{
	struct stat sb;

	if (fstat(workfile_fd, &sb) == -1)
		err(1, "%s", pb->filename);

	pb->date = sb.st_mtimespec.tv_sec;
}

/*
 * checkin_keywordscan()
 *
 * Searches working file for keyword values to determine its revision
 * number, creation date and author, and uses these values instead of
 * calculating them locally.
 *
 * Params: The data buffer to scan and pointers to pointers of variables in
 * which to store the outputs.
 *
 * On success, return 0. On error return -1.
 */
static int
checkin_keywordscan(BUF *data, RCSNUM **rev, time_t *date, char **author,
    char **state)
{
	BUF *buf;
	size_t left;
	u_int j;
	char *kwstr;
	unsigned char *c, *end, *start;

	end = buf_get(data) + buf_len(data) - 1;
	kwstr = NULL;

	left = buf_len(data);
	for (c = buf_get(data);
	    c <= end && (c = memchr(c, '$', left)) != NULL;
	    left = end - c + 1) {
		size_t len;

		start = c;
		c++;
		if (!isalpha(*c))
			continue;

		/* look for any matching keywords */
		for (j = 0; j < 10; j++) {
			len = strlen(rcs_expkw[j].kw_str);
			if (left < len)
				continue;
			if (memcmp(c, rcs_expkw[j].kw_str, len) != 0) {
				kwstr = rcs_expkw[j].kw_str;
				break;
			}
		}

		/* unknown keyword, continue looking */
		if (kwstr == NULL)
			continue;

		c += len;
		if (c > end) {
			kwstr = NULL;
			break;
		}
		if (*c != ':') {
			kwstr = NULL;
			continue;
		}

		/* Find end of line or end of keyword. */
		while (++c <= end) {
			if (*c == '\n') {
				/* Skip newline since it is definitely not `$'. */
				++c;
				goto loopend;
			}
			if (*c == '$')
				break;
		}

		len = c - start + 1;
		buf = buf_alloc(len + 1);
		buf_append(buf, start, len);

		/* XXX - Not binary safe. */
		buf_putc(buf, '\0');
		checkin_parsekeyword(buf_get(buf), rev, date, author, state);
		buf_free(buf);
loopend:;
	}
	if (kwstr == NULL)
		return (-1);
	else
		return (0);
}

/*
 * checkin_keywordtype()
 *
 * Given an RCS keyword string, determine what type of string it is.
 * This enables us to know what data should be in it.
 *
 * Returns type on success, or -1 on failure.
 */
static int
checkin_keywordtype(char *keystring)
{
	char *p;

	p = keystring;
	p++;
	if (strncmp(p, KW_ID, strlen(KW_ID)) == 0 ||
	    strncmp(p, KW_OPENBSD, strlen(KW_OPENBSD)) == 0)
		return (KW_TYPE_ID);
	else if (strncmp(p, KW_AUTHOR, strlen(KW_AUTHOR)) == 0)
		return (KW_TYPE_AUTHOR);
	else if (strncmp(p, KW_DATE, strlen(KW_DATE)) == 0)
		return (KW_TYPE_DATE);
	else if (strncmp(p, KW_STATE, strlen(KW_STATE)) == 0)
		return (KW_TYPE_STATE);
	else if (strncmp(p, KW_REVISION, strlen(KW_REVISION)) == 0)
		return (KW_TYPE_REVISION);
	else
		return (-1);
}

/*
 * checkin_parsekeyword()
 *
 * Do the actual parsing of an RCS keyword string, setting the values passed
 * to the function to whatever is found.
 *
 * XXX - Don't error out on malformed keywords.
 */
static void
checkin_parsekeyword(char *keystring, RCSNUM **rev, time_t *date,
    char **author, char **state)
{
	char *tokens[KW_NUMTOKS_MAX], *p, *datestring;
	int i = 0;

	for ((p = strtok(keystring, " ")); p; (p = strtok(NULL, " "))) {
		if (i < KW_NUMTOKS_MAX - 1)
			tokens[i++] = p;
		else
			break;
	}

	/* Parse data out of the expanded keyword */
	switch (checkin_keywordtype(keystring)) {
	case KW_TYPE_ID:
		if (i < 3)
			break;
		/* only parse revision if one is not already set */
		if (*rev == NULL) {
			if ((*rev = rcsnum_parse(tokens[2])) == NULL)
				errx(1, "could not parse rcsnum");
		}

		if (i < 5)
			break;
		(void)xasprintf(&datestring, "%s %s", tokens[3], tokens[4]);
		if ((*date = date_parse(datestring)) == -1)
			errx(1, "could not parse date");
		free(datestring);

		if (i < 6)
			break;
		free(*author);
		*author = xstrdup(tokens[5]);

		if (i < 7)
			break;
		free(*state);
		*state = xstrdup(tokens[6]);
		break;
	case KW_TYPE_AUTHOR:
		if (i < 2)
			break;
		free(*author);
		*author = xstrdup(tokens[1]);
		break;
	case KW_TYPE_DATE:
		if (i < 3)
			break;
		(void)xasprintf(&datestring, "%s %s", tokens[1], tokens[2]);
		if ((*date = date_parse(datestring)) == -1)
			errx(1, "could not parse date");
		free(datestring);
		break;
	case KW_TYPE_STATE:
		if (i < 2)
			break;
		free(*state);
		*state = xstrdup(tokens[1]);
		break;
	case KW_TYPE_REVISION:
		if (i < 2)
			break;
		/* only parse revision if one is not already set */
		if (*rev != NULL)
			break;
		if ((*rev = rcsnum_parse(tokens[1])) == NULL)
			errx(1, "could not parse rcsnum");
		break;
	}
}
@


1.223
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.222 2015/09/05 09:38:23 jsg Exp $	*/
d282 1
a282 1
		    rcs_set_description(pb.file, pb.description) == -1)
d409 1
a409 1
	rcs_msg = rcs_prompt(prompt);
d624 1
a624 1
	    rcs_set_description(pb->file, NULL) == -1) {
@


1.222
log
@Avoid unintended problems with operator precedence when doing an
assignment and comparison.

ok deraadt@@ looks correct millert@@ jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.221 2015/06/17 08:13:31 nicm Exp $	*/
d372 3
a374 6
	if (b1 != NULL)
		buf_free(b1);
	if (b2 != NULL)
		buf_free(b2);
	if (b3 != NULL)
		buf_free(b3);
@


1.221
log
@Remove NULL check before free; Fritjof Bornebusch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.220 2015/06/13 20:15:21 nicm Exp $	*/
d734 1
a734 1
	if ((ret = rcs_sym_add(pb->file, pb->symbol, pb->newrev) == -1) &&
@


1.220
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.219 2015/01/16 06:40:11 deraadt Exp $	*/
d213 1
a213 2
			if (pb.author != NULL)
				free(pb.author);
@


1.219
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.218 2014/10/02 06:23:15 otto Exp $	*/
d214 1
a214 1
				xfree(pb.author);
d379 2
a380 4
	if (path1 != NULL)
		xfree(path1);
	if (path2 != NULL)
		xfree(path2);
d512 1
a512 1
				xfree(pb->rcs_msg);
d585 1
a585 1
		xfree(pb->rcs_msg);	/* free empty log message */
d989 1
a989 1
		xfree(datestring);
d993 1
a993 2
		if (*author != NULL)
			xfree(*author);
d998 1
a998 2
		if (*state != NULL)
			xfree(*state);
d1004 1
a1004 2
		if (*author != NULL)
			xfree(*author);
d1013 1
a1013 1
		xfree(datestring);
d1018 1
a1018 2
		if (*state != NULL)
			xfree(*state);
@


1.218
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.217 2014/05/19 19:42:24 jca Exp $	*/
d73 1
a73 1
	char fpath[MAXPATHLEN], *rcs_msg, *username, *filename;
@


1.217
log
@Plug a small memory leak: if we pass checkin_init/checkin_update
a revision thru pb.newrev, it will not be freed.  From Fritjof
Bornebusch, no objections from tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.216 2013/10/27 18:31:24 guenther Exp $	*/
d92 1
a92 1
void
d100 2
a225 1
			exit(1);
a234 1
		exit(1);
@


1.216
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.215 2013/04/17 00:20:52 deraadt Exp $	*/
a289 1
		/* XXX - Should we rcsnum_free(pb.newrev)? */
d317 2
@


1.215
log
@remove time_t cast not needed; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.214 2013/01/18 11:21:09 guenther Exp $	*/
d475 2
a476 1
			char dbuf1[256], dbuf2[256], *fmt;
a477 2

			fmt = "%Y/%m/%d %H:%M:%S";
@


1.214
log
@Document $OpenBSD$ and teach ci's -k option to parse it too

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.213 2011/07/14 16:31:34 sobrado Exp $	*/
d832 1
a832 1
	pb->date = (time_t)sb.st_mtimespec.tv_sec;
@


1.213
log
@str is an optional argument to -t; if no argument is given, this
option is ignored (for compatibility reasons).

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.212 2011/04/20 19:34:16 nicm Exp $	*/
d45 1
d938 2
a939 1
	if (strncmp(p, KW_ID, strlen(KW_ID)) == 0)
@


1.212
log
@Remove some unneeded includes and dead code, from Michael W Bombardieri.

ok jasper xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.211 2010/09/08 15:15:50 tobias Exp $	*/
d97 1
a97 1
	    "          [-Nsymbol] [-nsymbol] [-r[rev]] [-sstate] [-tstr]\n"
@


1.211
log
@Set rcs_suffixes to default value on initialization.

ok ray zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.210 2010/07/30 21:47:18 ray Exp $	*/
a54 6

#define KW_NUMTOKS_ID		10
#define KW_NUMTOKS_AUTHOR	3
#define KW_NUMTOKS_DATE		4
#define KW_NUMTOKS_STATE	3
#define KW_NUMTOKS_REVISION	3
@


1.210
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.209 2010/07/28 09:07:11 ray Exp $	*/
a243 4

	/* If -x flag was not given, use default. */
	if (rcs_suffixes == NULL)
		rcs_suffixes = RCS_DEFAULT_SUFFIX;
@


1.209
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.207 2010/07/23 21:46:05 ray Exp $	*/
d139 1
a139 1
			else if ((pb.date = date_parse(rcs_optarg)) <= 0)
d997 1
a997 1
		if ((*date = date_parse(datestring)) <= 0)
d1024 1
a1024 1
		if ((*date = date_parse(datestring)) <= 0)
@


1.208
log
@Plug mem leak.

OK nicm
@
text
@d351 1
a351 1
	if ((b1 = buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
d361 1
a361 5

	if ((b3 = buf_alloc(128, BUF_AUTOEXT)) == NULL) {
		warnx("failed to allocated buffer for diff");
		goto out;
	}
d450 1
a450 1
	if ((bp = buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d626 1
a626 1
	if ((bp = buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d917 1
a917 1
		buf = buf_alloc(len + 1, 0);
@


1.207
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.206 2010/07/22 17:49:18 millert Exp $	*/
d927 1
@


1.206
log
@Fix the "no changes" detection when a file has RCS keywords.
This is consistent with GNU RCS.  Also g/c an unused variable.
OK xsa@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.205 2009/02/25 23:16:20 ray Exp $	*/
d139 1
a139 1
			else if ((pb.date = rcs_date_parse(rcs_optarg)) <= 0)
d351 1
a351 1
	if ((b1 = rcs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
d362 1
a362 1
	if ((b3 = rcs_buf_alloc(128, BUF_AUTOEXT)) == NULL) {
d368 1
a368 1
	rcs_buf_write_stmp(b1, path1);
d370 1
a370 1
	rcs_buf_free(b1);
d374 1
a374 1
	rcs_buf_write_stmp(b2, path2);
d376 1
a376 1
	rcs_buf_free(b2);
d386 1
a386 1
		rcs_buf_free(b1);
d388 1
a388 1
		rcs_buf_free(b2);
d390 1
a390 1
		rcs_buf_free(b3);
d454 1
a454 1
	if ((bp = rcs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d514 1
a514 1
	if (!(pb->flags & FORCE) && (rcs_buf_len(pb->deltatext) < 1)) {
d630 1
a630 1
	if ((bp = rcs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d870 1
a870 1
	end = rcs_buf_get(data) + rcs_buf_len(data) - 1;
d873 2
a874 2
	left = rcs_buf_len(data);
	for (c = rcs_buf_get(data);
d921 2
a922 2
		buf = rcs_buf_alloc(len + 1, 0);
		rcs_buf_append(buf, start, len);
d925 2
a926 2
		rcs_buf_putc(buf, '\0');
		checkin_parsekeyword(rcs_buf_get(buf), rev, date, author, state);
d1000 1
a1000 1
		if ((*date = rcs_date_parse(datestring)) <= 0)
d1027 1
a1027 1
		if ((*date = rcs_date_parse(datestring)) <= 0)
@


1.205
log
@Checking if a file is ASCII should only be done when diffing, because
the non-ASCII characters could be printed to the screen.  For
checking in files, checking out files, merging files, and removing
revisions of files, we do so regardless of whether the files are
ASCII or binary.

Fixes PR6031.

OK joris and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.204 2008/03/22 21:15:54 millert Exp $	*/
a346 1
	char rbuf[RCS_REV_BUFSZ];
a349 1
	rcsnum_tostr(pb->frev, rbuf, sizeof(rbuf));
d360 1
@


1.204
log
@Fix the freeing of two uninitialized strings.  OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.203 2007/09/06 19:38:47 niallo Exp $	*/
d381 1
a381 1
	if (diffreg(path1, path2, b3, 0) == D_ERROR)
@


1.203
log
@strictly check rcsnum_cmp() return against -1.
fixes a bug in ci -r

from Pierre Riteau <pierre.riteau at free.fr> via ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.202 2007/07/03 00:56:23 ray Exp $	*/
d350 1
@


1.202
log
@Rename rcs_diffreg() to diffreg().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.201 2007/06/30 08:23:49 xsa Exp $	*/
d469 1
a469 1
	    rcsnum_cmp(pb->newrev, pb->frev, 0) > 0) {
@


1.201
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.200 2007/06/26 02:21:02 niallo Exp $	*/
d380 1
a380 1
	if (rcs_diffreg(path1, path2, b3, 0) == D_ERROR)
@


1.200
log
@allow ci -N<tag name> even when no changes.  mimics GNU behaviour.

based on a diff from Tero Koskinen <tero.koskinen at iki.fi>
ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.201 2007/06/17 18:30:04 tkoskine Exp $	*/
d347 1
a347 1
	char rbuf[64];
d408 1
a408 1
	char   *rcs_msg, nrev[16], prev[16];
d442 1
a442 1
	char numb1[64], numb2[64];
d617 1
a617 1
	char numb[64];
d737 1
a737 1
	char rbuf[16];
d774 1
a774 1
	char rbuf[16];
@


1.199
log
@Allow checkin without locking (after rcs -U). Matches GNU's behaviour.
Problem reported by itojun@@. Tests itojun@@; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.198 2007/04/26 21:48:37 sobrado Exp $	*/
d95 1
a95 1
static void	 checkin_revert(struct checkin_params *);
d455 1
a455 1
		goto fail;
d462 1
a462 1
		goto fail;
d474 1
a474 1
		goto fail;
d507 1
a507 1
		goto fail;
d515 4
a518 2
		checkin_revert(pb);
		goto out;
d554 1
a554 1
		goto fail;
d574 1
a574 1
		goto fail;
d603 1
a603 1
out:
a604 3

fail:
	return (-1);
d631 1
a631 1
		goto fail;
d645 1
a645 1
		goto fail;
d673 1
a673 1
		goto fail;
d689 1
a689 1
		goto fail;
d694 1
a694 1
		goto fail;
a725 2
fail:
	return (-1);
d771 1
a771 1
static void
d782 10
d795 5
d803 2
@


1.198
log
@replace tabs by spaces in the message returned by usage()

ok by jmc@@, niallo@@, and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.197 2007/03/15 13:05:23 bluhm Exp $	*/
d534 2
a535 1
	if (rcs_lock_remove(pb->file, pb->username, pb->frev) < 0) {
d803 3
@


1.197
log
@When commiting multiple files with ci, the flags from the previous
files affected the later ones.

ok niallo@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.196 2007/03/03 21:07:23 deraadt Exp $	*/
d102 3
a104 3
	    "	  [-j[rev]] [-k[rev]] [-l[rev]] [-M[rev]] [-mmsg]\n"
	    "	  [-Nsymbol] [-nsymbol] [-r[rev]] [-sstate] [-tstr]\n"
	    "	  [-u[rev]] [-wusername] [-xsuffixes] [-ztz] file ...\n");
@


1.196
log
@make this modern C
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.195 2007/02/27 07:59:13 xsa Exp $	*/
d118 1
a127 1
	pb.flags = status = 0;
d129 3
a131 2
	pb.flags = INTERACTIVE;
	pb.openflags = RCS_RDWR|RCS_CREATE|RCS_PARSE_FULLY;
d144 1
a144 1
			pb.flags |= FORCE;
d148 1
a148 1
			pb.flags |= INTERACTIVE;
d152 2
a153 2
			pb.openflags |= RCS_CREATE;
			pb.flags |= CI_INIT;
d157 2
a158 2
			pb.openflags &= ~RCS_CREATE;
			pb.flags &= ~CI_INIT;
d162 1
a162 1
			pb.flags |= CI_KEYWORDSCAN;
d166 1
a166 1
			pb.flags |= CO_LOCK;
d170 1
a170 1
			pb.flags |= CO_REVDATE;
d176 1
a176 1
			pb.flags &= ~INTERACTIVE;
d179 1
a179 1
			pb.flags |= CI_SYMFORCE;
d187 1
a187 1
			pb.flags |= QUIET;
d191 1
a191 1
			pb.flags |= CI_DEFAULT;
d199 1
a199 1
			pb.flags |= PRESERVETIME;
d206 1
a206 1
			pb.flags |= DESCRIPTION;
d210 1
a210 1
			pb.flags |= CO_UNLOCK;
d250 7
a325 3
		/* reset NEWFILE flag */
		pb.flags &= ~NEWFILE;

d330 1
a330 1
	if (!(pb.flags & QUIET) && status == 0)
@


1.195
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.194 2007/02/22 19:11:13 otto Exp $	*/
d904 1
a904 1
loopend:
@


1.194
log
@If a ,suffix file is given as an arg to ci and co, strip it. Avoids
potential disasters.  Initial diff from niallo@@, ok niallo@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.193 2007/02/14 16:07:29 niallo Exp $	*/
d27 9
a35 1
#include "includes.h"
@


1.193
log
@sync some manual page entries with actual usage.

ok jmc@@, xsa@@
mostly From: Igor Sobrado <igor at string1.ciencias.uniovi.es>
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.192 2007/01/15 14:34:54 millert Exp $	*/
d236 4
d242 1
@


1.192
log
@When checking in multiple files, if no log message is entered for
a file, don't prompt the user to reuse the (non-existent) log
message for the next.  Makes ci behave like the GNU version.
OK xsa@@, joris@@, niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.191 2006/12/23 21:08:01 krw Exp $	*/
d93 1
a93 1
	    "usage: ci [-jMNqV] [-d[date]] [-f[rev]] [-I[rev]] [-i[rev]]\n"
@


1.191
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.190 2006/11/18 20:18:28 niallo Exp $	*/
d577 5
@


1.190
log
@- update comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.189 2006/11/09 21:47:52 millert Exp $	*/
d480 1
a480 1
			errx(1, "%s: Date %s preceeds %s in revision %s.",
@


1.189
log
@Simplify stripping of write bits from file mode.
Add support for reusing the checkin message for multiple files, ala GNU
Fix the message when you abort a checkout and the file was not writable.
OK joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.188 2006/09/27 06:26:35 ray Exp $	*/
d322 1
a322 1
 * Returns pointer to a char array on success, NULL on failure.
@


1.188
log
@Add and correct comments, spacing.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.187 2006/09/21 15:30:07 millert Exp $	*/
d502 13
a514 3
	if (pb->flags & INTERACTIVE)
		pb->rcs_msg = checkin_getlogmsg(pb->frev, pb->newrev,
		    pb->flags);
d564 1
a564 2
	pb->file->rf_mode = st.st_mode &
	    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
a576 6

	if (pb->flags & INTERACTIVE) {
		xfree(pb->rcs_msg);
		pb->rcs_msg = NULL;
	}

d682 1
a682 2
	pb->file->rf_mode = st.st_mode &
	    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
@


1.187
log
@Add support to rcsdiff for all the other diff flags that
are pertinent to files (not directories) and that do not
conflict with rcsdiff-specific flags.  OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.186 2006/08/23 20:28:47 joris Exp $	*/
d249 1
d625 1
a625 1
	 * If the user had specified a zero-ending revision number e.g. 4
d667 1
a667 2
	if (pb->symbol != NULL &&
	    (checkin_attach_symbol(pb) < 0))
@


1.186
log
@use the correct variable in error and warning messages
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.185 2006/08/16 07:39:15 ray Exp $	*/
d361 1
a361 1
	if (rcs_diffreg(path1, path2, b3) == D_ERROR)
@


1.185
log
@Improve rcs_buf_load() by setting errno appropriately on failure and
never print errors or quit on error.

Fix usages of rcs_buf_load() and rcs_set_description.

Also plug an fd leak.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.184 2006/08/02 05:16:18 ray Exp $	*/
d271 1
a271 1
			err(1, "%s", pb.file);
d617 1
a617 1
		warn("%s", pb->file);
@


1.184
log
@strlcpy/strlcat overload made deraadt@@ sick; change to xasprintf.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.183 2006/08/02 03:18:40 ray Exp $	*/
d269 3
a271 2
		if (pb.flags & DESCRIPTION)
			rcs_set_description(pb.file, pb.description);
d615 5
a619 2
	if (pb->description == NULL)
		rcs_set_description(pb->file, NULL);
@


1.183
log
@Fix a lot of buffer overflows and make the code more binary safe.
Also reduce a lot of redundant for() loops.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.182 2006/07/27 02:57:17 deraadt Exp $	*/
a929 1
	size_t len = 0;
d952 2
a953 8
		len = strlen(tokens[3]) + strlen(tokens[4]) + 2;
		datestring = xmalloc(len);
		/* XXX - use snprintf */
		if (strlcpy(datestring, tokens[3], len) >= len ||
		    strlcat(datestring, " ", len) >= len ||
		    strlcat(datestring, tokens[4], len) >= len) {
			errx(1, "date too long");
		} else if ((*date = rcs_date_parse(datestring)) <= 0)
d979 1
a979 6
		len = strlen(tokens[1]) + strlen(tokens[2]) + 2;
		datestring = xmalloc(len);
		if (strlcpy(datestring, tokens[1], len) >= len ||
		    strlcat(datestring, " ", len) >= len ||
		    strlcat(datestring, tokens[2], len) >= len)
			errx(1, "date too long");
@


1.182
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.181 2006/07/08 09:25:44 ray Exp $	*/
d54 3
d80 1
a80 1
static int	 checkin_keywordscan(char *, RCSNUM **, time_t *, char **,
d607 1
a607 1
		checkin_keywordscan((char *)rcs_buf_get(bp), &pb->newrev,
d814 1
a814 1
checkin_keywordscan(char *data, RCSNUM **rev, time_t *date, char **author,
d817 2
a818 1
	size_t end;
d820 2
a821 1
	char *c, *kwstr, *start, buf[128];
d823 1
d826 4
a829 1
	for (c = data; (c = strchr(c, '$')) != NULL;) {
d840 3
a842 1
			if (strncmp(c, rcs_expkw[j].kw_str, len) != 0) {
d853 6
a858 1
		if (*c != ':')
d860 1
d863 9
a871 3
		c += strcspn(c, "$\n");
		if (*c != '$')
			continue;
d873 8
a880 4
		end = c - start + 2;
		if (strlcpy(buf, start, end) >= end)
			errx(1, "keyword buffer too small!");
		checkin_parsekeyword(buf, rev, date, author, state);
d923 1
d926 1
a926 1
checkin_parsekeyword(char *keystring,  RCSNUM **rev, time_t *date,
d929 1
a929 1
	char *tokens[10], *p, *datestring;
d933 7
d943 2
a944 10
		for ((p = strtok(keystring, " ")); p;
		    (p = strtok(NULL, " "))) {
			if (i < KW_NUMTOKS_ID - 1)
				tokens[i++] = p;
		}
		tokens[i] = NULL;
		if (*author != NULL)
			xfree(*author);
		if (*state != NULL)
			xfree(*state);
d950 3
a952 2
		*author = xstrdup(tokens[5]);
		*state = xstrdup(tokens[6]);
d955 1
d958 1
a958 1
		    strlcat(datestring, tokens[4], len) >= len)
d960 1
a960 1
		if ((*date = rcs_date_parse(datestring)) <= 0)
d963 12
d977 2
a978 5
		for ((p = strtok(keystring, " ")); p;
		    (p = strtok(NULL, " "))) {
			if (i < KW_NUMTOKS_AUTHOR - 1)
				tokens[i++] = p;
		}
d984 2
a985 5
		for ((p = strtok(keystring, " ")); p;
		    (p = strtok(NULL, " "))) {
			if (i < KW_NUMTOKS_DATE - 1)
				tokens[i++] = p;
		}
d997 2
a998 5
		for ((p = strtok(keystring, " ")); p;
		    (p = strtok(NULL, " "))) {
			if (i < KW_NUMTOKS_STATE - 1)
				tokens[i++] = p;
		}
d1004 2
a1008 5
		for ((p = strtok(keystring, " ")); p;
		    (p = strtok(NULL, " "))) {
			if (i < KW_NUMTOKS_REVISION - 1)
				tokens[i++] = p;
		}
@


1.181
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.180 2006/06/03 03:05:10 niallo Exp $	*/
d419 1
a419 1
	char *filec, numb1[64], numb2[64];
a421 2

	filec = NULL;
@


1.180
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.179 2006/06/02 19:10:23 david Exp $	*/
d345 1
a345 1
	rcs_buf_write_stmp(b1, path1, 0600);
d351 1
a351 1
	rcs_buf_write_stmp(b2, path2, 0600);
@


1.179
log
@various spelling fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.178 2006/06/02 18:04:33 niallo Exp $	*/
d67 1
a67 1
	char fpath[MAXPATHLEN], *rcs_msg, *username, *deltatext, *filename;
d69 1
d74 1
a74 1
static char	*checkin_diff_file(struct checkin_params *);
d319 1
a319 1
static char *
d324 1
a324 1
	char rbuf[64], *deltatext;
a326 1
	deltatext = NULL;
d360 1
a360 4
	rcs_buf_putc(b3, '\0');
	deltatext = rcs_buf_release(b3);
	b3 = NULL;

d373 1
a373 1
	return (deltatext);
a435 3
	rcs_buf_putc(bp, '\0');
	filec = (char *)rcs_buf_release(bp);

d493 1
a493 1
	if (!(pb->flags & FORCE) && (strlen(pb->deltatext) < 1)) {
d534 1
a534 1
	if (rcs_deltatext_set(pb->file, pb->frev, filec) == -1)
a571 3
	xfree(pb->deltatext);
	xfree(filec);

a574 4
	if (filec != NULL)
		xfree(filec);
	if (pb->deltatext != NULL)
		xfree(pb->deltatext);
d588 1
a588 1
	char *filec, numb[64];
a591 2
	filec = NULL;

a603 3
	rcs_buf_putc(bp, '\0');
	filec = rcs_buf_release(bp);

d606 2
a607 2
		checkin_keywordscan(filec, &pb->newrev, &pb->date, &pb->state,
		    &pb->author);
d655 1
a655 1
	if (rcs_deltatext_set(pb->file, pb->file->rf_head, filec) == -1) {
a676 1
	xfree(filec);
a696 2
	if (filec != NULL)
		xfree(filec);
@


1.178
log
@- at end of checkin_main loop, reset pb.newrev.  fixes a problem with checkin
  of multiple files.

reported by fgsch@@

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.177 2006/05/29 21:17:44 ray Exp $	*/
d281 1
a281 1
		/* XXX - support for commiting to a file without revisions */
@


1.177
log
@Plug more memory leaks.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.176 2006/05/29 02:58:16 niallo Exp $	*/
d303 1
@


1.176
log
@- zap unrequired casts for rcs_buf_release().
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.175 2006/05/27 05:49:14 ray Exp $	*/
d66 1
d68 1
a68 1
	char *author, *description, *state, *symbol;
d112 2
a113 1
	pb.symbol = pb.description = pb.deltatext = NULL;
d169 1
a169 3
			if (pb.symbol != NULL)
				xfree(pb.symbol);
			pb.symbol = xstrdup(rcs_optarg);
@


1.175
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.174 2006/05/17 19:37:40 xsa Exp $	*/
d360 1
a360 1
	deltatext = (char *)rcs_buf_release(b3);
d619 1
a619 1
	filec = (char *)rcs_buf_release(bp);
@


1.174
log
@fix printf's
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.173 2006/05/11 08:24:24 xsa Exp $	*/
d238 2
a239 6
		/*
		 * Test for existence of ,v file. If we are expected to
		 * create one, set NEWFILE flag.
		 */
		fd = rcs_statfile(pb.filename, pb.fpath, sizeof(pb.fpath),
		    pb.flags);
a259 8

		/*
		 * If we are to create a new ,v file, we must decide where it
		 * should go.
		 */
		if (pb.flags & NEWFILE)
			fd = rcs_choosefile(pb.filename,
			    pb.fpath, sizeof(pb.fpath));
@


1.173
log
@fix informative msg's wrt to -q and stderr. now matches gnu/usr.bin/rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.172 2006/05/10 01:10:23 ray Exp $	*/
d415 2
a416 2
		printf("new revision: %s; previous revision: %s\n", nrev,
		    prev);
@


1.172
log
@Remove (size_t) casts on integer constants.

We should not cover up lint's shortcomings, especially if they no
longer exist.

``This is definately good.'' niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.171 2006/05/09 12:33:42 ray Exp $	*/
d281 2
a282 1
			printf("%s  <--  %s\n", pb.fpath, pb.filename);
d318 1
a318 1
		printf("done\n");
d781 5
a785 1
	warnx("file is unchanged; reverting to previous revision %s", rbuf);
@


1.171
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.170 2006/05/08 16:56:40 xsa Exp $	*/
d349 1
a349 1
	if ((b3 = rcs_buf_alloc((size_t)128, BUF_AUTOEXT)) == NULL) {
@


1.170
log
@check for rcs_diffreg() return value; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.169 2006/05/05 01:29:59 ray Exp $	*/
a201 1
			/* NOTREACHED */
@


1.169
log
@o GNU ci returns 0 when a file is reverted (co -l file; ci file).
o Don't unlock file after revert.
o Fix spelling.

Passes extra tests in GNU rcstest.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.168 2006/05/04 07:06:58 xsa Exp $	*/
d368 2
a369 1
	rcs_diffreg(path1, path2, b3);
@


1.168
log
@finish work wrt TMPDIR; use xasprintf() to simplify code while in there;
"looks fine" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.167 2006/04/29 06:32:00 ray Exp $	*/
d511 1
a511 1
		goto fail;
a569 2
	xfree(pb->deltatext);
	xfree(filec);
d586 5
a786 3
	if (rcs_lock_remove(pb->file, pb->username, pb->frev) < 0)
		if (rcs_errno != RCS_ERR_NOENT)
			warnx("failed to remove lock");
@


1.167
log
@o Simplify ci by using strchr and strcspn instead of custom loops.
o Search for the ending `$' until the end of the line instead of
  the end of the string.

OK niallo@@ and xsa@@, possibly joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.166 2006/04/29 05:31:28 ray Exp $	*/
d332 1
a332 1
	char path1[MAXPATHLEN], path2[MAXPATHLEN];
d355 1
a355 3
	if (strlcpy(path1, rcs_tmpdir, sizeof(path1)) >= sizeof(path1) ||
	    strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1)) >= sizeof(path1))
		errx(1, "path truncated");
d361 1
a361 3
	if (strlcpy(path2, rcs_tmpdir, sizeof(path2)) >= sizeof(path2) ||
	    strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2)) >= sizeof(path2))
		errx(1, "path truncated");
d381 4
@


1.166
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.165 2006/04/29 05:10:16 ray Exp $	*/
d844 1
a844 1
	u_int j, found;
d847 1
a847 1
	c = start = kwstr = NULL;
d849 2
a850 1
	found = 0;
d852 11
a862 29
	for (c = data; *c != '\0'; c++) {
		if (*c == '$') {
			start = c;
			c++;
			if (!isalpha(*c)) {
				c = start;
				continue;
			}
			/* look for any matching keywords */
			found = 0;
			for (j = 0; j < 10; j++) {
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
					found = 1;
					kwstr = rcs_expkw[j].kw_str;
					break;
				}
			}

			/* unknown keyword, continue looking */
			if (found == 0) {
				c = start;
				continue;
			}

			c += strlen(kwstr);
			if (*c != ':' && *c != '$') {
				c = start;
				continue;
d864 1
d866 17
a882 19
			if (*c == ':') {
				while (*c++) {
					if (*c == '$') {
						end = c - start + 2;
						if (strlcpy(buf, start, end) >= end)
							errx(1, "keyword buffer"
							    " too small!");
						checkin_parsekeyword(buf, rev,
						    date, author, state);
						break;
					}
				}

				if (*c != '$') {
					c = start;
					continue;
				}
			}
		}
d884 1
a884 1
	if (found == 0)
@


1.165
log
@Clarify man pages to match -t behavior and pretty up usage strings.

OK xsa@@ and jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.164 2006/04/29 04:59:48 ray Exp $	*/
d355 3
a357 2
	strlcpy(path1, rcs_tmpdir, sizeof(path1));
	strlcat(path1, "/diff1.XXXXXXXXXX", sizeof(path1));
d363 3
a365 2
	strlcpy(path2, rcs_tmpdir, sizeof(path2));
	strlcat(path2, "/diff2.XXXXXXXXXX", sizeof(path2));
d886 1
a886 1
						if (end >= sizeof(buf))
a888 1
						strlcpy(buf, start, end);
d974 4
a977 3
		strlcpy(datestring, tokens[3], len);
		strlcat(datestring, " ", len);
		strlcat(datestring, tokens[4], len);
d979 1
a979 1
		    errx(1, "could not parse date");
d1000 4
a1003 3
		strlcpy(datestring, tokens[1], len);
		strlcat(datestring, " ", len);
		strlcat(datestring, tokens[2], len);
d1005 1
a1005 1
		    errx(1, "could not parse date");
@


1.164
log
@Make ci store gmtime instead of localtime in RCS files, like GNU.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.163 2006/04/26 21:55:22 joris Exp $	*/
d90 1
a90 1
	    "	  [-Nsymbol] [-nsymbol] [-r[rev]] [-sstate] [-tfile|str]\n"
@


1.163
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.162 2006/04/26 02:55:13 joris Exp $	*/
d486 1
a486 1
			t = localtime(&pb->date);
d488 1
a488 1
			t_head = localtime(&head_date);
@


1.162
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.161 2006/04/25 13:55:49 xsa Exp $	*/
d103 1
a232 1

d243 4
a246 2
		if (rcs_statfile(pb.filename, pb.fpath,
		    sizeof(pb.fpath), pb.flags) < 0) {
d259 1
d270 3
a272 10
		if (pb.flags & NEWFILE) {
			char *fpath = rcs_choosefile(pb.filename);
			if (fpath == NULL) {
				status = 1;
				(void)close(workfile_fd);
				continue;
			}
			strlcpy(pb.fpath, fpath, sizeof(pb.fpath));
			xfree(fpath);
		}
d274 1
a274 1
		pb.file = rcs_open(pb.fpath, pb.openflags, pb.fmode);
@


1.161
log
@quote strings consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.160 2006/04/25 13:36:35 xsa Exp $	*/
d123 1
a123 1
			else if ((pb.date = cvs_date_parse(rcs_optarg)) <= 0)
d344 1
a344 1
	if ((b1 = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
d354 1
a354 1
	if ((b3 = cvs_buf_alloc((size_t)128, BUF_AUTOEXT)) == NULL) {
d361 1
a361 1
	cvs_buf_write_stmp(b1, path1, 0600);
d363 1
a363 1
	cvs_buf_free(b1);
d368 1
a368 1
	cvs_buf_write_stmp(b2, path2, 0600);
d370 1
a370 1
	cvs_buf_free(b2);
d374 1
a374 1
	cvs_diffreg(path1, path2, b3);
d376 2
a377 2
	cvs_buf_putc(b3, '\0');
	deltatext = (char *)cvs_buf_release(b3);
d382 1
a382 1
		cvs_buf_free(b1);
d384 1
a384 1
		cvs_buf_free(b2);
d386 1
a386 1
		cvs_buf_free(b3);
d448 1
a448 1
	if ((bp = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d451 2
a452 2
	cvs_buf_putc(bp, '\0');
	filec = (char *)cvs_buf_release(bp);
d625 1
a625 1
	if ((bp = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL)
d628 2
a629 2
	cvs_buf_putc(bp, '\0');
	filec = (char *)cvs_buf_release(bp);
d980 1
a980 1
		if ((*date = cvs_date_parse(datestring)) <= 0)
d1005 1
a1005 1
		if ((*date = cvs_date_parse(datestring)) <= 0)
@


1.160
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.159 2006/04/25 07:57:10 xsa Exp $	*/
d280 1
a280 1
			errx(1, "failed to open rcsfile '%s'", pb.fpath);
@


1.159
log
@style;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.158 2006/04/24 21:30:47 joris Exp $	*/
d124 1
a124 1
				fatal("invalid date");
d159 1
a159 1
				fatal("missing message for -m option");
d170 1
a170 1
				fatal("invalid symbol `%s'", pb.symbol);
d182 1
a182 1
				fatal("invalid state `%s'", pb.state);
d230 1
a230 1
		fatal("getlogin failed");
d237 1
a237 1
			fatal("%s: %s", pb.filename, strerror(errno));
d280 1
a280 1
			fatal("failed to open rcsfile '%s'", pb.fpath);
d292 1
a292 1
				fatal("invalid revision: %s", rev_str);
d495 1
a495 1
			fatal("%s: Date %s preceeds %s in revision %s.",
d531 1
a531 1
		fatal("failed to set new rd_text for head rev");
d547 1
a547 1
			fatal("rcs_head_set failed");
d553 1
a553 1
		fatal("failed to set new head revision");
d566 1
a566 1
		fatal("%s: %s", pb->filename, strerror(errno));
d677 1
a677 1
			fatal("rcs_head_set failed");
d698 1
a698 1
		fatal("%s: %s", pb->filename, strerror(errno));
d824 1
a824 1
		fatal("%s: %s", pb->filename, strerror(errno));
d889 1
a889 1
							fatal("keyword buffer"
d971 1
a971 1
				fatal("could not parse rcsnum");
d981 1
a981 1
		    fatal("could not parse date\n");
d1006 1
a1006 1
		    fatal("could not parse date\n");
d1029 1
a1029 1
			fatal("could not parse rcsnum");
@


1.158
log
@prevent a race by keeping an fd for the workfile around until
we are finished with it.

first one of many to come...
okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.157 2006/04/24 04:51:57 ray Exp $	*/
d565 1
a565 1
	if (fstat(workfile_fd, &st))
d697 1
a697 1
	if (fstat(workfile_fd, &st))
d823 1
a823 1
	if (fstat(workfile_fd, &sb))
@


1.157
log
@o Better match GNU behavior (a bare -t does NOT read from stdin,
  unlike rcs).
o Share code with rcs by moving rcs_set_description() to rcsutil.c.
o Change description prompt from #define to const char *.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.156 2006/04/21 17:17:29 xsa Exp $	*/
d58 2
d78 1
a78 1
static int	 checkin_mtimedate(struct checkin_params *);
d236 3
d250 1
d257 1
d262 1
d271 1
d296 1
d303 4
d478 2
a479 3
	if (pb->date == DATE_MTIME &&
	    (checkin_mtimedate(pb) < 0))
		goto fail;
d565 2
a566 2
	if (stat(pb->filename, &st) == -1)
		goto fail;
d574 1
d659 2
a660 3
	if (pb->date == DATE_MTIME &&
	    (checkin_mtimedate(pb) < 0))
		goto fail;
d697 3
a699 2
	if (stat(pb->filename, &st) == -1)
		goto fail;
d705 1
a717 1

d781 1
a816 2
 *
 * On success, return 0. On error return -1.
d818 1
a818 1
static int
d822 4
a825 4
	if (stat(pb->filename, &sb) != 0) {
		warn("%s", pb->filename);
		return (-1);
	}
a826 1
	return (0);
@


1.156
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.155 2006/04/21 14:18:26 xsa Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::I::i::j::k::l::M::m::N:n:qr::s:Tt:u::Vw:x::z::"
a70 1
static char	*checkin_getdesc(void);
d186 5
a190 3
			if (pb.description != NULL)
				xfree(pb.description);
			pb.description = xstrdup(rcs_optarg);
a269 1

d273 3
a409 20

/*
 * checkin_getdesc()
 *
 * Get file description interactively.
 * Returns pointer to a char array on success, NULL on failure.
 */
static char *
checkin_getdesc()
{
	char *description;
	const char *prompt =
	    "enter description, terminated with single '.' or end of file:\n"
	    "NOTE: This is NOT the log message!\n";

	description = rcs_prompt(prompt);

	return (description);
}

d595 1
a595 1
	BUF *bp, *dp;
a597 1
	const char *rcs_desc;
d627 1
a627 17
		rcs_desc = (const char *)checkin_getdesc();
	else {
		if (*pb->description == '-') {
			pb->description++;
			rcs_desc = (const char *)pb->description;
		} else {
			dp = cvs_buf_load(pb->description, BUF_AUTOEXT);
			if (dp == NULL) {
				warnx("failed to load description file '%s'",
				    pb->description);
				goto fail;
			}
			cvs_buf_putc(dp, '\0');
			rcs_desc = (const char *)cvs_buf_release(dp);
		}
	}
	rcs_desc_set(pb->file, rcs_desc);
@


1.155
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.154 2006/04/19 06:53:41 xsa Exp $	*/
d237 2
a238 1
		if (rcs_statfile(pb.filename, pb.fpath, sizeof(pb.fpath)) < 0) {
@


1.154
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.153 2006/04/18 03:35:57 ray Exp $	*/
d221 1
a221 1
		cvs_log(LP_ERR, "no input file");
d241 1
a241 1
				cvs_log(LP_ERR, "No existing RCS file");
d247 1
a247 1
				cvs_log(LP_ERR, "%s already exists", pb.fpath);
d327 1
a327 1
		cvs_log(LP_ERR, "failed to load file: '%s'", pb->filename);
d332 1
a332 1
		cvs_log(LP_ERR, "failed to load revision");
d337 1
a337 1
		cvs_log(LP_ERR, "failed to allocated buffer for diff");
d469 1
a469 2
		cvs_log(LP_ERR,
		    "%s: revision %s too low; must be higher than %s",
d506 1
a506 1
		cvs_log(LP_ERR, "failed to get diff");
d526 1
a526 1
			cvs_log(LP_WARN, "failed to remove lock");
d528 1
a528 1
			cvs_log(LP_WARN, "previous revision was not locked; "
d540 1
a540 1
		cvs_log(LP_ERR, "failed to add new revision");
d652 1
a652 2
				cvs_log(LP_ERR,
				    "failed to load description file '%s'",
d687 1
a687 1
		cvs_log(LP_ERR, "failed to add new revision");
d703 1
a703 1
		cvs_log(LP_ERR, "failed to set new head revision");
d765 2
a766 2
				cvs_log(LP_ERR,
				    "problem removing symbol: %s", pb->symbol);
d775 1
a775 3
		cvs_log(LP_ERR,
		    "symbolic name %s already bound to %s",
		    pb->symbol, rbuf);
d778 1
a778 2
		cvs_log(LP_ERR, "problem adding symbol: %s",
		    pb->symbol);
d798 1
a798 3
	cvs_log(LP_WARN,
	    "file is unchanged; reverting to previous revision %s",
	    rbuf);
d806 1
a806 1
			cvs_log(LP_WARN, "failed to remove lock");
d826 1
a826 2
	cvs_log(LP_ERR,
	    "%s: no lock set by %s", pb->file->rf_path, pb->username);
d843 1
a843 1
		cvs_log(LP_ERRNO, "failed to stat `%s'", pb->filename);
@


1.153
log
@Combine code to prompt user for input into a shared function,
reducing some complex fats from ci.c.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.152 2006/04/18 02:52:18 ray Exp $	*/
d72 1
a72 1
static char	*checkin_getlogmsg(RCSNUM *, RCSNUM *);
d172 1
a172 1
			verbose = 0;
d272 1
a272 1
		if (verbose == 1)
d303 1
a303 1
	if (verbose == 1 && status == 0)
d380 1
a380 1
checkin_getlogmsg(RCSNUM *rev, RCSNUM *rev2)
d397 1
a397 1
	if (verbose == 1)
d522 2
a523 1
		pb->rcs_msg = checkin_getlogmsg(pb->frev, pb->newrev);
d671 2
a672 1
		pb->rcs_msg = checkin_getlogmsg(pb->frev, pb->newrev);
d739 1
a739 1
	if (verbose == 1) {
d762 1
a762 1
	if (verbose == 1)
@


1.152
log
@/* FALLTHROUGH */ to share code between the -N and -n flags.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.151 2006/04/18 02:49:31 ray Exp $	*/
a71 1
static char	*checkin_getinput(const char *);
d383 2
d401 2
a402 2
	rcs_msg = checkin_getinput("enter log message, terminated with a "
	    "single '.' or end of file:\n>> ");
d417 5
a422 3
	description = checkin_getinput("enter description, terminated with "
	    "single '.' or end of file:\n"
	    "NOTE: This is NOT the log message!\n>> ");
a423 36
}

/*
 * checkin_getinput()
 *
 * Get some input from the user, in RCS style, prompting with message <prompt>.
 * Returns pointer to a char array on success, NULL on failure.
 */
static char *
checkin_getinput(const char *prompt)
{
	BUF *inputbuf;
	char *input, buf[128];

	if ((inputbuf = cvs_buf_alloc((size_t)64, BUF_AUTOEXT)) == NULL) {
		cvs_log(LP_ERR, "failed to allocate input buffer");
		return (NULL);
	}

	if (isatty(STDIN_FILENO))
		fprintf(stderr, "%s", prompt);

	for (;;) {
		fgets(buf, (int)sizeof(buf), stdin);
		if (feof(stdin) || ferror(stdin) || buf[0] == '.')
			break;
		cvs_buf_append(inputbuf, buf, strlen(buf));

		if (isatty(STDIN_FILENO))
			fprintf(stderr, ">> ");
	}

	cvs_buf_putc(inputbuf, '\0');
	input = (char *)cvs_buf_release(inputbuf);

	return (input);
@


1.151
log
@Removes memory leaks when flags are called multiple times.  This
is the easy way out.  The code should be able to handle having
pb.author, pb.description, and pb.symbol as const char * strings
pointing to rcs_optarg values without using xstrdup at all.  The
code is a bit hairy so it's difficult to verify that it's done
correctly, so that'll be a plan for another day.  In the meantime,
this works.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.150 2006/04/18 02:46:21 ray Exp $	*/
a162 5
			if (pb.symbol != NULL)
				xfree(pb.symbol);
			pb.symbol = xstrdup(rcs_optarg);
			if (rcs_sym_check(pb.symbol) != 1)
				fatal("invalid symbol `%s'", pb.symbol);
d164 1
a164 1
			break;
@


1.150
log
@Remove -h flag from rcs_getopt loop, which is not in GNU.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.149 2006/04/17 12:03:19 ray Exp $	*/
d65 1
a65 2
	char *author, *state;
	const char *symbol, *description;
d163 2
d171 2
d193 2
d206 2
@


1.149
log
@Relieve checkin_update and checkin_init of the responsibility of
calling rcs_close() so we don't try to rcs_close() the same file
twice if the working file does not exist, resulting in a core dump.

The current code also returns the status of the last file, so if
we do:

	$ touch file
	$ ci nonexistent file

that will return 0.  GNU returns 1.  Fix that.

Additionally, it returns -1 on error, which turns into 255.  It
should return 1.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.148 2006/04/16 12:30:00 niallo Exp $	*/
a130 4
		case 'h':
			(usage)();
			exit(0);
			/* NOTREACHED */
@


1.148
log
@- fix description handling.

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.147 2006/04/14 01:11:07 deraadt Exp $	*/
d292 7
a298 4
		if (pb.flags & NEWFILE)
			status = checkin_init(&pb);
		else
			status = checkin_update(&pb);
d471 1
a471 1
	char  *filec, numb1[64], numb2[64];
d475 2
d485 2
a486 4
	if ((bp = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
		rcs_close(pb->file);
		return (-1);
	}
d630 2
a631 1
	xfree(filec);
d652 2
d663 2
a664 4
	if ((bp = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
		rcs_close(pb->file);
		return (-1);
	}
d779 2
a780 1
	xfree(filec);
@


1.147
log
@excessive addition to brackets is a mental disease.  you will go
blind, too.  seek help.  no binary change, ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.146 2006/04/14 00:22:46 pat Exp $	*/
d284 2
d670 1
a670 1
	if (pb->file->rf_ndelta == 0)
@


1.146
log
@Fix a typo introduced in rev 1.135; ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.145 2006/04/13 16:20:28 ray Exp $	*/
d301 1
a301 1
	if ((verbose == 1) && (status == 0))
d487 1
a487 1
	if ((pb->newrev != NULL) && (RCSNUM_ZERO_ENDING(pb->newrev)))
d497 2
a498 2
	if ((pb->newrev != NULL)
	    && (rcsnum_cmp(pb->newrev, pb->frev, 0) > 0)) {
d511 2
a512 2
	if (pb->date == DATE_MTIME
	    && (checkin_mtimedate(pb) < 0))
d589 2
a590 2
	if (pb->symbol != NULL
	    && (checkin_attach_symbol(pb) < 0))
d613 2
a614 2
	if (((pb->flags & CO_LOCK) || (pb->flags & CO_UNLOCK))
	    && !(pb->flags & CI_DEFAULT))
d647 1
a647 1
	if ((pb->newrev != NULL) && (RCSNUM_ZERO_ENDING(pb->newrev))) {
d707 2
a708 2
	if (pb->date == DATE_MTIME
	    && (checkin_mtimedate(pb) < 0))
d737 2
a738 2
	if (pb->symbol != NULL
	    && (checkin_attach_symbol(pb) < 0))
d759 2
a760 2
	if (((pb->flags & CO_LOCK) || (pb->flags & CO_UNLOCK))
	    && !(pb->flags & CI_DEFAULT)) {
d799 2
a800 2
	if ((ret = rcs_sym_add(pb->file, pb->symbol, pb->newrev) == -1)
	    && (rcs_errno == RCS_ERR_DUPENT)) {
d854 2
a855 2
		if ((!strcmp(lkp->rl_name, pb->username)) &&
		    (!rcsnum_cmp(lkp->rl_num, pb->frev, 0)))
@


1.145
log
@Currently rcs_getopt spits out a generic error message if you do
`ci -m file'.  This changes it so if -m is given without an argument
a customized error message is printed.

While I was there I sorted the optstring according to style(9).

``Oh, I see it now.'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.144 2006/04/13 16:10:29 joris Exp $	*/
d1029 1
a1029 1
		*author = xstrdup(tokens[6]);
@


1.144
log
@clean up temporary files when we finish running.
"cool" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.143 2006/04/13 13:15:18 niallo Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::I::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x::z::"
@


1.143
log
@fix some typos
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.142 2006/04/13 03:18:06 joris Exp $	*/
a360 2
	cvs_worklist_run(&rcs_temp_files, cvs_worklist_unlink);

@


1.142
log
@correctly handle RCS files without any revisions;
original diff from ray@@, crafted into shape by myself.

okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.141 2006/04/13 00:58:25 ray Exp $	*/
d7 1
a7 1
 * modification, are permitted provided that the following cinditions
d10 2
a11 2
 * 1. Redistributions of source cide must retain the above cipyright
 *    notice, this list of cinditions and the following disclaimer.
@


1.141
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.140 2006/04/12 08:27:31 deraadt Exp $	*/
d284 6
d670 3
d693 2
@


1.140
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.139 2006/04/12 08:23:30 ray Exp $	*/
d280 3
a282 1
			rcs_set_rev(rev_str, &pb.newrev);
@


1.139
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.138 2006/04/10 19:49:44 joris Exp $	*/
d602 1
a602 1
	
@


1.138
log
@make sure we add the correct name mkstemp(3) creates for us
to the worklist of temporary files.

this way we definatly don't leave any files behind in /tmp.

tested & okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.137 2006/04/09 19:22:23 niallo Exp $	*/
a94 2


d105 1
a114 1

d117 1
d128 1
a128 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d136 1
a136 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d140 1
a140 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d145 1
a145 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d150 1
a150 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d154 1
a154 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d158 1
a158 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d182 1
a182 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d197 1
a197 1
			rcs_set_rev(rcs_optarg, &pb.newrev);
d277 4
@


1.137
log
@- don't print out warnings about locking when they are actually wrong and
just confuse the user.

ok and input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.136 2006/04/06 10:13:00 xsa Exp $	*/
a329 2

	cvs_worklist_add(path1, &rcs_temp_files);
a336 2

	cvs_worklist_add(path2, &rcs_temp_files);
@


1.136
log
@-z can take no argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.135 2006/04/05 01:38:56 ray Exp $	*/
d822 1
@


1.135
log
@Use variable names for sizeof, remove casts in front of xmalloc,
use xcalloc and xstrdup where appropriate, and other stuff.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.134 2006/04/01 13:57:48 niallo Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::I::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x::z:"
@


1.134
log
@- plug a possible memory leak in checkin_update() error path.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.133 2006/03/31 01:39:36 joris Exp $	*/
d1017 2
a1018 6
		len = strlen(tokens[5]) + 1;
		*author = xmalloc(len);
		strlcpy(*author, tokens[5], len);
		len = strlen(tokens[6]) + 1;
		*state = xmalloc(len);
		strlcpy(*state, tokens[6], len);
d1036 1
a1036 3
		len = strlen(tokens[1]) + 1;
		*author = xmalloc(len);
		strlcpy(*author, tokens[1], len);
d1061 1
a1061 3
		len = strlen(tokens[1]) + 1;
		*state = xmalloc(len);
		strlcpy(*state, tokens[1], len);
@


1.133
log
@spacing;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.132 2006/03/30 23:19:20 joris Exp $	*/
d112 1
a112 1
	pb.symbol = pb.description = NULL;
d621 2
@


1.132
log
@add temporary files to the worklist before creating them, this prevents
a race when the user would interrupt the program when it was returning
from cvs_buf_write_stmp() and leave the temporary files behind.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.131 2006/03/28 12:48:51 xsa Exp $	*/
d690 1
d707 1
d723 1
@


1.131
log
@check rcs_head_set() return value; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.130 2006/03/28 12:07:10 xsa Exp $	*/
d330 2
a333 1
	cvs_worklist_add(path1, &rcs_temp_files);
d339 2
a342 1
	cvs_worklist_add(path2, &rcs_temp_files);
@


1.130
log
@check rcs_sym_remove() return value; OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.129 2006/03/27 22:11:08 niallo Exp $	*/
d571 4
a574 3
	if (pb->newrev != NULL)
		rcs_head_set(pb->file, pb->newrev);
	else
d708 4
a711 3
	if (pb->newrev != NULL)
		rcs_head_set(pb->file, pb->newrev);
	else
@


1.129
log
@- simplify checkin_init() and checkin_update() functions by moving
rcs_close() to the checkin_main() loop.

"Commitzki!!" ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.128 2006/03/27 21:56:32 niallo Exp $	*/
d771 9
a779 2
	if (pb->flags & CI_SYMFORCE)
		rcs_sym_remove(pb->file, pb->symbol);
@


1.128
log
@- properly implement GNU file modes.  basically, checkout will inherit
permissions from rcs file and initial checkin will inherit permissions from
working file.

problem spotted by uwe@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.127 2006/03/27 13:07:37 xsa Exp $	*/
d286 2
a609 2
	rcs_close(pb->file);

a617 1
	rcs_close(pb->file);
a751 2
	rcs_close(pb->file);

a754 1
	rcs_close(pb->file);
@


1.127
log
@check rcs_lock_remove() return value; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.126 2006/03/26 12:56:31 niallo Exp $	*/
d114 2
a115 1
	pb.fmode = pb.flags = status = 0;
d458 1
d587 8
d598 3
a607 1
	/* File will NOW be synced */
d635 1
d727 7
d737 3
d742 1
a742 1
	    && !(pb->flags & CI_DEFAULT))
d745 2
a752 1
	/* File will NOW be synced */
@


1.126
log
@- clean up error handling in checkin_init() and checkin_update()
- plug a couple of memory leaks along the way

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.125 2006/03/24 05:14:48 ray Exp $	*/
d790 3
a792 1
	rcs_lock_remove(pb->file, pb->username, pb->frev);
@


1.125
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.124 2006/03/23 08:50:41 xsa Exp $	*/
d466 9
d480 1
a480 1
		return (-1);
d493 1
a493 2
		rcs_close(pb->file);
		return (-1);
d502 1
a502 1
		return (-1);
a523 9
	/* Load file contents */
	if ((bp = cvs_buf_load(pb->filename, BUF_AUTOEXT)) == NULL) {
		rcs_close(pb->file);
		return (-1);
	}

	cvs_buf_putc(bp, '\0');
	filec = (char *)cvs_buf_release(bp);

d527 1
a527 2
		rcs_close(pb->file);
		return (-1);
d536 1
a536 1
		return (0);
d560 1
a560 2
		rcs_close(pb->file);
		return (-1);
d579 1
a579 1
		return (-1);
d603 5
d659 1
a659 3
				xfree(filec);
				rcs_close(pb->file);
				return (-1);
d681 1
a681 1
		return (-1);
d689 1
a689 2
		rcs_close(pb->file);
		return (-1);
d703 1
a703 2
		rcs_close(pb->file);
		return (-1);
d708 1
a708 1
		return (-1);
d732 4
a759 1
		rcs_close(pb->file);
a763 1
		rcs_close(pb->file);
a790 1
	rcs_close(pb->file);
a811 1
	rcs_close(pb->file);
a828 1
		rcs_close(pb->file);
@


1.124
log
@- cvs_buf_putc() will never return non-zero
- change cvs_buf_putc() return type to void
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.123 2006/03/20 16:18:13 niallo Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::I::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x:z:"
d208 2
a209 1
			rcs_suffixes = rcs_optarg;
@


1.123
log
@delint; cvs_buf_write_stmp() will never return non-zero:

- remove superfluous error handling for cvs_buf_write_stmp()
- change cvs_buf_write_stmp() return type to void

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.122 2006/03/17 07:32:03 ray Exp $	*/
d521 1
a521 5
	if (cvs_buf_putc(bp, '\0') < 0) {
		rcs_close(pb->file);
		return (-1);
	}

d635 1
a635 5
	if (cvs_buf_putc(bp, '\0') < 0) {
		rcs_close(pb->file);
		return (-1);
	}

d660 1
a660 5
			if (cvs_buf_putc(dp, '\0') < 0) {
				xfree(filec);
				rcs_close(pb->file);
				return (-1);
			}
@


1.122
log
@Remove unused variables len and i, change `end' to size_t type.
Found by lint.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.121 2006/03/16 04:04:57 ray Exp $	*/
d326 1
a326 2
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1)
		goto out;
d334 1
a334 2
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1)
		goto out;
@


1.121
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.120 2006/03/15 20:57:14 joris Exp $	*/
d867 2
a868 2
	size_t len;
	u_int i, j, found, end;
d873 1
a873 1
	i =  found =  0;
d875 1
a875 2
	len = strlen(data);
	for (c = data; *c != '\0' && i < len; c++) {
@


1.120
log
@ask for log message when it's not specified, got broken in xsa's previous
commit.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.119 2006/03/15 16:04:08 xsa Exp $	*/
d134 1
d203 1
@


1.119
log
@- check for tty when asking for logmsg or description
- add -I[rev]
- more verbosity checks
OK niallo@@, "Works great" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.118 2006/03/15 05:05:35 deraadt Exp $	*/
d116 1
@


1.118
log
@remove some bizzare idioms; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.117 2006/03/15 03:29:01 ray Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x:z:"
d89 4
a92 4
	    "usage: ci [-jMNqV] [-d[date]] [-f[rev]] [-i[rev]] [-j[rev]]\n"
	    "	  [-k[rev]] [-l[rev]] [-M[rev]] [-mmsg] [-Nsymbol]\n"
	    "	  [-nsymbol] [-r[rev]] [-sstate] [-tfile|str] [-u[rev]]\n"
	    "	  [-wusername] [-xsuffixes] [-ztz] file ...\n");
a115 1
	pb.flags = INTERACTIVE;
d133 4
d425 3
a427 1
	printf(prompt);
d433 3
a435 1
		printf(">> ");
d735 4
a738 2
	printf("initial revision: %s\n",
	    rcsnum_tostr(pb->newrev, numb, sizeof(numb)));
@


1.117
log
@Move and rename checkin_choose_rcsfile() to rcs_choosefile().

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.116 2006/03/14 03:33:30 ray Exp $	*/
d864 1
a864 1
	for (c = data; *c != '\0' && i < len; *c++) {
d867 1
a867 1
			*c++;
d936 1
a936 1
	*p++;
@


1.116
log
@ci currently doesn't parse the -x flag at all, defaulting to ",v/" every
time.  I rewrote checkin_choose_rcsfile() to handle it using these rules:
 - If a directory structure is given (ci -x,abcd dir/dir2/file) then all
   RCS files are under dir/dir2.
 - If the RCS/ directory exists, use it.  Otherwise use current directory.
 - If the -x flag is specified, use those slash-separated extensions.
   Otherwise, use the default (",v/").
 - Look in the rcs directory (RCS/ or current directory) for a file
   with a matching extension, for each extension.  Each extension is
   tried in order.  If a file exists, it is used.  If no file exists
   with any extension, the first one is used.
 - The empty extension is treated as no extension, because I can't
   figure out what its special meaning is.

It sounds complicated, and the code is kinda complicated as well, but it
makes sense if you think about it.

ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.115 2006/03/11 22:44:11 niallo Exp $	*/
a70 1
static char	*checkin_choose_rcsfile(const char *);
d254 1
a254 1
			char *fpath = checkin_choose_rcsfile(pb.filename);
a836 125
}

/*
 * checkin_choose_rcsfile()
 *
 * Given a relative filename, decide where the corresponding RCS file
 * should be.  Tries each extension until a file is found.  If no file
 * was found, returns a path with the first extension.
 *
 * Returns pointer to a char array on success, NULL on failure.
 */
static char *
checkin_choose_rcsfile(const char *filename)
{
	struct stat sb;
	char *ext, name[MAXPATHLEN], *next, *ptr, rcsdir[MAXPATHLEN],
	    *ret, *suffixes, rcspath[MAXPATHLEN];

	/* If -x flag was not given, use default. */
	if (rcs_suffixes == NULL)
		rcs_suffixes = RCS_DEFAULT_SUFFIX;

	/*
	 * If `filename' contains a directory, `rcspath' contains that
	 * directory, including a trailing slash.  Otherwise `rcspath'
	 * contains an empty string.
	 */
	if (strlcpy(rcspath, filename, sizeof(rcspath)) >= sizeof(rcspath))
		return (NULL);
	/* If `/' is found, end string after `/'. */
	if ((ptr = strrchr(rcspath, '/')) != NULL)
		*(++ptr) = '\0';
	else
		rcspath[0] = '\0';

	/* Append RCS/ to `rcspath' if it exists. */
	if (strlcpy(rcsdir, rcspath, sizeof(rcsdir)) >= sizeof(rcsdir) ||
	    strlcat(rcsdir, RCSDIR, sizeof(rcsdir)) >= sizeof(rcsdir))
		return (NULL);
	if ((stat(rcsdir, &sb) == 0) && (sb.st_mode & S_IFDIR))
		if (strlcpy(rcspath, rcsdir, sizeof(rcspath)) >= sizeof(rcspath) ||
		    strlcat(rcspath, "/", sizeof(rcspath)) >= sizeof(rcspath))
			return (NULL);

	/* Name of file without path. */
	if ((ptr = strrchr(filename, '/')) == NULL) {
		if (strlcpy(name, filename, sizeof(name)) >= sizeof(name))
			return (NULL);
	} else {
		/* Skip `/'. */
		if (strlcpy(name, ptr + 1, sizeof(name)) >= sizeof(name))
			return (NULL);
	}

	/* Name of RCS file without an extension. */
	if (strlcat(rcspath, name, sizeof(rcspath)) >= sizeof(rcspath))
		return (NULL);

	/*
	 * If only the empty suffix was given, use existing rcspath.
	 * This ensures that there is at least one suffix for strsep().
	 */
	if (strcmp(rcs_suffixes, "") == 0) {
		if ((ret = strdup(rcspath)) == NULL);
			fatal("out of memory");
		return (ret);
	}

	/*
	 * Cycle through slash-separated `rcs_suffixes', appending each
	 * extension to `rcspath' and testing if the file exists.  If it
	 * does, return that string.  Otherwise return path with first
	 * extension.
	 */
	if ((suffixes = strdup(rcs_suffixes)) == NULL)
		fatal("out of memory");
	for (ret = NULL, next = suffixes; (ext = strsep(&next, "/")) != NULL;) {
		char fpath[MAXPATHLEN];

		/* Construct RCS file path. */
		if (strlcpy(fpath, rcspath, sizeof(fpath)) >= sizeof(fpath) ||
		    strlcat(fpath, ext, sizeof(fpath)) >= sizeof(fpath)) {
			xfree(suffixes);
			return (NULL);
		}

		/* Don't use `filename' as RCS file. */
		if (strcmp(fpath, filename) == 0)
			continue;

		if (stat(fpath, &sb) == 0) {
			if ((ret = strdup(fpath)) == NULL)
				fatal("out of memory");
			break;
		}
	}
	xfree(suffixes);

	/*
	 * If `ret' is still NULL no RCS file with any extension exists
	 * so we use the first extension.
	 */
	if (ret == NULL) {
		/*
		 * XXX - We shouldn't need to do strsep again,
		 * suffixes should now be NUL separated.
		 */
		if ((suffixes = strdup(rcs_suffixes)) == NULL)
			fatal("out of memory");
		next = suffixes;
		/* Get first extension again. */
		if ((ext = strsep(&next, "/")) == NULL) {
			xfree(suffixes);
			return (NULL);
		}
		if (strlcat(rcspath, ext, sizeof(rcspath)) >= sizeof(rcspath)) {
			xfree(suffixes);
			return (NULL);
		}
		if ((ret = strdup(rcspath)) == NULL)
			fatal("out of memory");
		xfree(suffixes);
	}

	return (ret);
@


1.115
log
@- implement GNU-compatible handling of revisions specified as single
digits.  e.g. ci -l4 or ci -u5 will work like GNU now.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.114 2006/03/11 18:38:54 niallo Exp $	*/
d843 3
a845 2
 * Given a relative filename, decide where the corresponding ,v file
 * should be.
a851 3
	char name[MAXPATHLEN], *basepath;
	const char *ptr;
	size_t len;
d853 2
d856 66
a921 12
	basepath = xmalloc(MAXPATHLEN);
	basepath[0] = '\0';
	if (strchr(filename, '/') == NULL) {
		strlcat(basepath, RCSDIR"/", MAXPATHLEN);
		if ((stat(basepath, &sb) == 0) && (sb.st_mode & S_IFDIR)) {
			/* <path>/RCS/<filename>,v */
			strlcat(basepath, filename, MAXPATHLEN);
			strlcat(basepath, RCS_FILE_EXT, MAXPATHLEN);
		} else {
			/* <path>/<filename>,v */
			strlcpy(basepath, filename, MAXPATHLEN);
			strlcat(basepath, RCS_FILE_EXT, MAXPATHLEN);
d923 9
a931 8
	} else {
		ptr = filename;
		/* Walk backwards till we find the base directory */
		len = strlen(filename);
		ptr += len + 1;
		while (filename[len] != '/') {
			len--;
			ptr--;
d933 8
d942 2
a943 2
		 * Need two bytes extra for trailing slash and
		 * NUL-termination.
d945 6
a950 3
		len += 2;
		if (len > MAXPATHLEN) {
			xfree(basepath);
d953 3
a955 11
		strlcpy(basepath, filename, len);
		strlcpy(name, ptr, MAXPATHLEN);
		strlcat(basepath, RCSDIR"/", MAXPATHLEN);
		if ((stat(basepath, &sb) == 0) && (sb.st_mode & S_IFDIR)) {
			/* <path>/RCS/<filename>,v */
			strlcat(basepath, name, MAXPATHLEN);
			strlcat(basepath, RCS_FILE_EXT, MAXPATHLEN);
		} else {
			/* <path>/<filename>,v */
			strlcpy(basepath, filename, MAXPATHLEN);
			strlcat(basepath, RCS_FILE_EXT, MAXPATHLEN);
d957 3
d961 2
a962 1
	return (basepath);
@


1.114
log
@- reset NEWFILE flag on each iteration through main loop.  this stops
strange things happening.

- don't print "done" on error.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.113 2006/03/10 11:51:19 xsa Exp $	*/
d54 2
d458 4
d615 1
d618 8
d671 8
@


1.113
log
@use same date format as gnu/usr.bin/rcs in error message. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.112 2006/03/08 20:19:39 joris Exp $	*/
d274 3
d279 1
a279 1
	if (verbose == 1)
@


1.112
log
@make openrcs use the worklist framework to keep track of temporary files
and remove them in case it gets interrupted.

suggested by deraadt@@, ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.111 2006/03/07 01:47:42 joris Exp $	*/
d483 12
a494 8
			char *head_date_str, *tdate;
			head_date_str = xstrdup(ctime(&head_date));
			head_date_str[strlen(head_date_str) - 1] = '\0';
			tdate = xstrdup(ctime(&pb->date));
			tdate[strlen(tdate) - 1] = '\0';
			cvs_log(LP_ERR,
			    "%s: Date %s preceeds %s in revision %s",
			    pb->file->rf_path, tdate, head_date_str,
a495 4
			rcs_close(pb->file);
			xfree(head_date_str);
			xfree(tdate);
			return (-1);
@


1.111
log
@fix usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.110 2006/03/07 01:40:52 joris Exp $	*/
d295 2
d301 1
a301 1
		return (NULL);
d306 1
a306 2
		cvs_buf_free(b1);
		return (NULL);
d311 1
a311 3
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		return (NULL);
d316 4
a319 6
	if (cvs_buf_write_stmp(b1, path1, 0600) == -1) {
		cvs_log(LP_ERRNO, "could not write temporary file");
		cvs_buf_free(b1);
		cvs_buf_free(b2);
		return (NULL);
	}
d321 1
d325 4
a328 5
	if (cvs_buf_write_stmp(b2, path2, 0600) == -1) {
		cvs_buf_free(b2);
		(void)unlink(path1);
		return (NULL);
	}
d330 1
a333 2
	(void)unlink(path1);
	(void)unlink(path2);
d337 11
@


1.110
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.109 2006/03/06 15:04:17 niallo Exp $	*/
d91 1
a91 1
	    "	  [-wusername] [-xsuffixes] file ...\n");
@


1.109
log
@like gnu ci(1), continue to process valid files in argv even if some are
invalid.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.108 2006/03/06 14:49:54 jmc Exp $	*/
d32 1
a32 1
#define CI_OPTSTRING	"d::f::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x:"
d202 3
@


1.108
log
@update usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.107 2006/03/06 09:41:53 deraadt Exp $	*/
a490 1
		cvs_log(LP_ERR, "failed to load '%s'", pb->filename);
a599 1
		cvs_log(LP_ERR, "failed to load '%s'", pb->filename);
@


1.107
log
@many spacing cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.106 2006/03/05 17:35:24 niallo Exp $	*/
d88 1
a88 1
	    "usage: ci [-MNqTV] [-d[date]] [-f[rev]] [-i[rev]] [-j[rev]]\n"
@


1.106
log
@plug some potential resource leaks in error paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.105 2006/03/05 17:20:35 niallo Exp $	*/
d32 21
a52 26
#define CI_OPTSTRING    "d::f::i::j::k::l::m:M::N:n:qr::s:Tt:u::Vw:x:"
#define DATE_NOW        -1
#define DATE_MTIME      -2

#define KW_ID           "Id"
#define KW_AUTHOR       "Author"
#define KW_DATE         "Date"
#define KW_STATE        "State"
#define KW_REVISION     "Revision"
#define KW_TYPE_ID       1
#define KW_TYPE_AUTHOR   2
#define KW_TYPE_DATE     3
#define KW_TYPE_STATE    4
#define KW_TYPE_REVISION 5
#define KW_NUMTOKS_ID      10
#define KW_NUMTOKS_AUTHOR   3
#define KW_NUMTOKS_DATE     4
#define KW_NUMTOKS_STATE    3
#define KW_NUMTOKS_REVISION 3

#define LOG_INIT        "Initial revision"
#define LOG_PROMPT      "enter log message, terminated with a single '.' "    \
                        "or end of file:\n>> "
#define DESC_PROMPT     "enter description, terminated with single '.' "      \
	                "or end of file:\nNOTE: This is NOT the log message!" \
                        "\n>> "
d75 1
a75 1
static int       checkin_keywordscan(char *, RCSNUM **, time_t *, char **,
d77 1
a77 1
static int       checkin_keywordtype(char *);
d79 1
a79 1
static void      checkin_parsekeyword(char *, RCSNUM **, time_t *, char **,
d89 3
a91 3
	    "          [-k[rev]] [-l[rev]] [-M[rev]] [-mmsg] [-Nsymbol]\n"
	    "          [-nsymbol] [-r[rev]] [-sstate] [-tfile|str] [-u[rev]]\n"
	    "          [-wusername] [-xsuffixes] file ...\n");
d266 1
a266 1
		
d368 2
a369 1
	rcs_msg = checkin_getinput(LOG_PROMPT);
d385 3
a387 1
	description = checkin_getinput(DESC_PROMPT);
d554 1
a554 1
        if (rcs_deltatext_set(pb->file, pb->frev, filec) == -1)
d656 1
a656 1
	    (pb->rcs_msg == NULL ? LOG_INIT : pb->rcs_msg),
d903 15
a917 15
                        found = 0;
                        for (j = 0; j < 10; j++) {
                                if (!strncmp(c, rcs_expkw[j].kw_str,
                                    strlen(rcs_expkw[j].kw_str))) {
                                        found = 1;
                                        kwstr = rcs_expkw[j].kw_str;
                                        break;
                                }
                        }

                        /* unknown keyword, continue looking */
                        if (found == 0) {
                                c = start;
                                continue;
                        }
d934 1
a934 1
						    date, author, state); 
d959 1
a959 1
 */ 
d964 1
a964 1
	
d995 2
a996 1
        /* Parse data out of the expanded keyword */
d1000 1
a1000 1
		     (p = strtok(NULL, " "))) {
d1003 1
a1003 1
	        }
d1031 1
a1031 1
		     (p = strtok(NULL, " "))) {
d1034 1
a1034 1
	        }
d1043 1
a1043 1
		     (p = strtok(NULL, " "))) {
d1058 1
a1058 1
		     (p = strtok(NULL, " "))) {
d1061 1
a1061 1
	        }
d1073 1
a1073 1
		     (p = strtok(NULL, " "))) {
d1076 1
a1076 1
	        }
@


1.105
log
@checkin_parsekeyword() returns void so zap unnecessary return.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.104 2006/03/05 17:17:27 niallo Exp $	*/
d494 1
d498 2
a499 1
	if (cvs_buf_putc(bp, '\0') < 0)
d501 1
d508 1
d542 1
d604 1
d608 2
a609 1
	if (cvs_buf_putc(bp, '\0') < 0)
d611 1
d634 1
d639 1
d661 1
d676 1
@


1.104
log
@GNU ci(1) doesn't allow dates younger than HEAD, neither on the command
line via -d<date> nor via stat mtime on the working file (plain -d).

add a check for this in checkin_update(), abort and warn the user
should we encounter such a situation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.103 2006/03/05 15:47:17 niallo Exp $	*/
a1069 2

	return;
@


1.103
log
@honour -m on initial revision.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.102 2006/02/20 16:30:18 niallo Exp $	*/
d463 28
a531 8

	/*
	 * Set the date of the revision to be the last modification
	 * time of the working file if -d has no argument.
	 */
	if (pb->date == DATE_MTIME
	    && (checkin_mtimedate(pb) < 0))
		return (-1);
@


1.102
log
@- more spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.101 2006/02/20 16:27:58 niallo Exp $	*/
d628 2
a629 1
	    LOG_INIT, pb->date, pb->author) != 0) {
@


1.101
log
@- spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.100 2006/02/16 19:15:30 niallo Exp $	*/
d1040 1
a1040 1
		for ((p =strtok(keystring, " ")); p;
@


1.100
log
@- zap kwtype variable. lint pointed it out wasn't used by anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.99 2006/02/16 18:05:47 niallo Exp $	*/
d967 1
a967 1
		for ((p =strtok(keystring, " ")); p;
d998 1
a998 1
		for ((p =strtok(keystring, " ")); p;
d1010 1
a1010 1
		for ((p =strtok(keystring, " ")); p;
d1025 1
a1025 1
		for ((p =strtok(keystring, " ")); p;
@


1.99
log
@- rename variable k to i
- only initialise i to zero once
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.98 2006/02/16 17:44:53 niallo Exp $	*/
a853 1
	int kwtype;
a860 1
	kwtype = 0;
a877 1
                                        kwtype = rcs_expkw[j].kw_type;
@


1.98
log
@- finally add proper support for `ci -k`. this little-used option requires
quite a lot of parsing code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.97 2006/02/16 17:30:46 niallo Exp $	*/
d966 1
a966 1
	u_int k;
a969 1
		k = 0;
d972 2
a973 2
			if (k < KW_NUMTOKS_ID - 1)
				tokens[k++] = p;
d975 1
a975 1
		tokens[k] = NULL;
a1000 1
		k = 0;
d1003 2
a1004 2
			if (k < KW_NUMTOKS_AUTHOR - 1)
				tokens[k++] = p;
a1012 1
		k = 0;
d1015 2
a1016 2
			if (k < KW_NUMTOKS_DATE - 1)
				tokens[k++] = p;
a1027 1
		k = 0;
d1030 2
a1031 2
			if (k < KW_NUMTOKS_STATE - 1)
				tokens[k++] = p;
a1042 1
		k = 0;
d1045 2
a1046 2
			if (k < KW_NUMTOKS_REVISION - 1)
				tokens[k++] = p;
@


1.97
log
@- ensure we handle -d properly in initial revision, not just updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.96 2006/02/16 16:43:45 niallo Exp $	*/
d3 1
a3 1
 * Copyright (c) 2005 Niall O'Higgins <niallo@@openbsd.org>
d36 16
d59 2
d68 2
a69 2
	char *author;
	const char *symbol, *state, *description;
d80 3
d84 2
d115 2
a116 2
	pb.rcs_msg = pb.username = pb.author = NULL;
	pb.state = pb.symbol = pb.description = NULL;
d148 4
d587 5
d836 223
@


1.96
log
@- make revision specifiers work for initial revision, not just updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.95 2006/02/16 13:32:27 niallo Exp $	*/
d585 8
d596 1
a596 1
	    LOG_INIT, -1, pb->author) != 0) {
@


1.95
log
@`ci -k` is described incorrectly in a number of places.

- fix ci(1) manual page for this option
- fix usage() for this option
- fix CI_OPTSTRING for this option.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.93 2006/02/14 13:26:43 xsa Exp $	*/
d586 3
a588 1
	if (rcs_rev_add(pb->file, RCS_HEAD_REV, LOG_INIT, -1, pb->author) != 0) {
@


1.94
log
@- make function prototypes consistent.
@
text
@d32 1
a32 1
#define CI_OPTSTRING    "d::f::i::j::k:l::m:M::N:n:qr::s:Tt:u::Vw:x:"
d71 1
a71 1
	    "          [-kmode] [-l[rev]] [-M[rev]] [-mmsg] [-Nsymbol]\n"
@


1.93
log
@fix output when checking in a file for the first time. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.92 2006/01/05 10:28:24 xsa Exp $	*/
d54 2
a55 2
static int	 checkin_attach_symbol(struct checkin_params *pb);
static int	 checkin_checklock(struct checkin_params *pb);
d62 3
a64 3
static int	 checkin_mtimedate(struct checkin_params *pb);
static int	 checkin_update(struct checkin_params *pb);
static void	 checkin_revert(struct checkin_params *pb);
@


1.92
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.91 2006/01/02 08:13:28 xsa Exp $	*/
d251 3
d546 1
a546 1
	char *filec;
d622 3
d627 1
a686 2
	if (verbose == 1)
		printf("done\n");
@


1.91
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.90 2005/12/27 16:05:21 niallo Exp $	*/
d29 1
a29 2
#include "log.h"
#include "rcs.h"
a30 1
#include "rcsprog.h"
@


1.90
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.89 2005/12/23 00:59:55 joris Exp $	*/
d27 1
a27 11
#include <sys/param.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <pwd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.89
log
@support co -d, which checks out the first revision who's
date is less than or equal to the given date.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.88 2005/12/21 19:59:58 alek Exp $	*/
d110 1
a110 1
	pb.openflags = RCS_RDWR|RCS_CREATE;
@


1.88
log
@Initialize basepath right after xmalloc()ing it so we won't end up with
not NUL-terminated buffer passed to strlcat()

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.87 2005/12/20 09:04:17 xsa Exp $	*/
d533 1
a533 1
		    pb->username, pb->author, NULL);
d629 1
a629 1
		    pb->username, pb->author, NULL);
d689 1
a689 1
		    pb->flags, pb->username, pb->author, NULL);
@


1.87
log
@spread the use of fatal();
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.86 2005/12/19 18:24:12 xsa Exp $	*/
d757 1
a765 1
			memset(basepath, '\0', MAXPATHLEN);
a795 1
			memset(basepath, '\0', MAXPATHLEN);
@


1.86
log
@use fatal() if getlogin() fails;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.85 2005/12/12 09:40:08 xsa Exp $	*/
d117 2
a118 4
			else if ((pb.date = cvs_date_parse(rcs_optarg)) <= 0) {
				cvs_log(LP_ERR, "invalide date");
				exit(1);
			}
d147 2
a148 5
			if (pb.rcs_msg == NULL) {
				cvs_log(LP_ERR,
				    "missing message for -m option");
				exit(1);
			}
d153 2
a154 5
			if (rcs_sym_check(pb.symbol) != 1) {
				cvs_log(LP_ERR, "invalid symbol `%s'",
				    pb.symbol);
				exit(1);
			}
d159 2
a160 5
			if (rcs_sym_check(pb.symbol) != 1) {
				cvs_log(LP_ERR, "invalid symbol `%s'",
				    pb.symbol);
				exit(1);
			}
d171 2
a172 5
			if (rcs_state_check(pb.state) < 0) {
				cvs_log(LP_ERR, "invalid state `%s'",
				    pb.state);
				exit(1);
			}
d251 2
a252 5
		if (pb.file == NULL) {
			cvs_log(LP_ERR, "failed to open rcsfile '%s'",
			    pb.fpath);
			exit(1);
		}
d484 2
a485 5
	if (rcs_deltatext_set(pb->file, pb->frev, pb->deltatext) == -1) {
		cvs_log(LP_ERR,
		    "failed to set new rd_text for head rev");
		exit (1);
	}
d513 2
a514 4
        if (rcs_deltatext_set(pb->file, pb->frev, filec) == -1) {
		cvs_log(LP_ERR, "failed to set new head revision");
		exit(1);
	}
@


1.85
log
@- sync usage() for `-tfile|str'
- nuke trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.84 2005/12/10 20:27:46 joris Exp $	*/
d222 2
a223 4
	if ((pb.username = getlogin()) == NULL) {
		cvs_log(LP_ERRNO, "failed to get username");
		exit(1);
	}
@


1.84
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.83 2005/12/09 04:27:01 joris Exp $	*/
d84 1
a84 1
	    "          [-nsymbol] [-r[rev]] [-sstate] [-tfile] [-u[rev]]\n"
d441 1
a441 1
	 * has the lock for. So we can decide if we want to create a 
@


1.83
log
@unused vars, my bad;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.82 2005/12/08 18:56:10 joris Exp $	*/
d157 1
a157 4
			if ((pb.symbol = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}
d166 1
a166 4
			if ((pb.symbol = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}
d192 1
a192 4
			if ((pb.description = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}
d202 1
a202 4
			if ((pb.author = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}
d262 1
a262 1
			free(fpath);
d549 2
a550 2
	free(pb->deltatext);
	free(filec);
d563 1
a563 1
		free(pb->rcs_msg);
d606 1
a606 1
				free(filec);
d610 1
a610 1
				free(filec);
d646 1
a646 1
	free(filec);
d780 1
a780 4
	if ((basepath = malloc(MAXPATHLEN)) == NULL) {
		cvs_log(LP_ERRNO, "could not allocate memory");
		return (NULL);
	}
d808 1
a808 1
			free(basepath);
@


1.82
log
@complete and correct rcs locking functionality,
it was only done partially and as a bonus, completely wrong.

seriously guys what was up with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.81 2005/12/03 17:11:58 niallo Exp $	*/
a740 1
	int notlocked = 1;
@


1.81
log
@- whoops, its -t-string or -tfile, not the other way around
- sync checkin_usage() with reality
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.80 2005/12/03 16:50:48 niallo Exp $	*/
d62 1
d104 1
a104 1
	pb.rcs_msg = pb.username = NULL;
d211 4
a214 1
			pb.username = rcs_optarg;
d234 1
a234 1
	if ((pb.username == NULL) && (pb.username = getlogin()) == NULL) {
d451 5
d458 7
a464 1
	/* If revision passed on command line is less than HEAD, bail. */
a475 3
	if (checkin_checklock(pb) < 0)
		return (-1);

d506 1
a506 1
	if (rcs_lock_remove(pb->file, pb->frev) < 0) {
d508 4
a511 1
		    cvs_log(LP_WARN, "failed to remove lock");
d532 1
a532 1
	    pb->rcs_msg, pb->date, pb->username) != 0) {
d569 1
a569 1
		    pb->username);
d631 1
a631 1
	if (rcs_rev_add(pb->file, RCS_HEAD_REV, LOG_INIT, -1, pb->username) != 0) {
d665 1
a665 1
		    pb->username);
d725 2
a726 2
		    pb->flags, pb->username);
	rcs_lock_remove(pb->file, pb->frev);
d741 1
a741 1
	int found = 0, notlocked = 1;
d744 4
a747 11
	if (!TAILQ_EMPTY(&(pb->file->rf_locks))) {
		TAILQ_FOREACH(lkp, &(pb->file->rf_locks), rl_list) {
			if (!strcmp(lkp->rl_name, pb->username))
				notlocked = 0;

			if ((!strcmp(lkp->rl_name, pb->username)) &&
			    (!rcsnum_cmp(lkp->rl_num, pb->frev, 0))) {
				found = 1;
				return (0);
			}
		}
d750 4
a753 7
	if ((found == 0) && (notlocked == 1)) {
		cvs_log(LP_ERR,
		    "%s: no lock set by %s", pb->file->rf_path, pb->username);
		rcs_close(pb->file);
		return (-1);
	}
	return (0);
@


1.80
log
@- add support for -t[description] and -t-[file containing description]
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.79 2005/12/02 14:29:13 xsa Exp $	*/
d83 2
a84 2
	    "          [-nsymbol] [-r[rev]] [-sstate] [-u[rev]] [-wusername]\n"
	    "          [-xsuffixes] file ...\n");
d596 2
a611 2
		else
			rcs_desc = (const char *)pb->description;
@


1.79
log
@in checkin_checklock()
- make it work as expected (e.g. when no lock set at all too)
- add missing word in error message
- minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.78 2005/12/02 13:53:43 xsa Exp $	*/
d44 1
a44 1
#define CI_OPTSTRING    "d::f::i::j::k:l::m:M::N:n:qr::s:Tu::Vw:x:"
d62 1
a62 1
	const char *symbol, *state;
d104 1
a104 1
	pb.state = pb.symbol = NULL;
d196 6
d575 3
a577 2
	BUF *bp;
	char *rcs_desc, *filec;
d591 22
a612 1
	rcs_desc = checkin_getdesc();
@


1.78
log
@better..
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.77 2005/12/02 13:43:32 xsa Exp $	*/
d706 2
a707 2
			if (!strcmp(lkp->rl_name, pb->username) &&
			    !rcsnum_cmp(lkp->rl_num, pb->frev, 0)) {
d714 1
a714 1
	if ((found == 0) && (notlocked == 0)) {
d716 1
a716 1
		    "%s: no lock by %s", pb->file->rf_path, pb->username);
@


1.77
log
@in checkin_update():
- move up the lock check
- better error message if a specified rev is too low
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.76 2005/12/02 01:13:12 niallo Exp $	*/
d455 1
a455 3
	if (checkin_checklock(pb) < 0) {
		cvs_log(LP_ERR, "%s: no lock set by %s",
		    pb->file->rf_path, pb->username);
a456 1
	}
d715 2
a716 1
		cvs_log(LP_ERR, "no locks set for '%s'", pb->username);
@


1.76
log
@- fix up checkin_choose_rcsfile() to give us a path like the one GNU print,
instead of always returning an absolute path.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.75 2005/12/02 00:15:35 niallo Exp $	*/
d438 1
a438 1
	char  *filec;
d446 5
a450 1
		cvs_log(LP_ERR, "revision is too low!");
d455 6
a485 4

	/* Check for a lock belonging to this user. If none, abort check-in. */
	if (checkin_checklock(pb) < 0)
		return (-1);
@


1.75
log
@- fix a typo in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.74 2005/11/28 14:43:59 xsa Exp $	*/
d751 2
a752 1
	char fullpath[MAXPATHLEN], *basepath;
d756 2
a757 2
	if (realpath(filename, fullpath) == NULL) {
		cvs_log(LP_ERRNO, "realpath failed: `%s'", filename);
d760 21
a780 4
	len = strlen(fullpath);
	while (fullpath[len] != '/')
		len--;
	if (len > 0) {
d786 2
a787 2
		if ((basepath = malloc(MAXPATHLEN)) == NULL) {
			cvs_log(LP_ERRNO, "could not allocate memory");
d790 2
a791 1
		strlcpy(basepath, fullpath, len);
d795 1
a795 1
			strlcat(basepath, filename, MAXPATHLEN);
d800 1
a800 2
			strlcpy(basepath, fullpath, len);
			strlcat(basepath, filename, MAXPATHLEN);
d803 2
a804 3
		return (basepath);
	} else
		return (NULL);
@


1.74
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.73 2005/11/28 09:16:32 xsa Exp $	*/
d741 1
a741 1
 * checkin_rcsfile()
@


1.73
log
@shrink some multi-lines comments;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.72 2005/11/28 08:49:25 xsa Exp $	*/
d82 3
a84 3
            "          [-kmode] [-l[rev]] [-M[rev]] [-mmsg] [-Nsymbol]\n"
            "          [-nsymbol] [-r[rev]] [-sstate] [-u[rev]] [-wusername]\n"
            "          file ...\n");
@


1.72
log
@consistency in error messages;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.71 2005/11/27 17:47:18 niallo Exp $	*/
d443 1
a443 3
	/*
	 * If revision passed on command line is less than HEAD, bail.
	 */
d451 1
a451 3
	/*
	 * Load file contents
	 */
d462 1
a462 3
	/*
	 * Get RCS patch
	 */
d477 1
a477 4
	/*
	 * Check for a lock belonging to this user. If none,
	 * abort check-in.
	 */
d481 1
a481 3
	/*
	 * If no log message specified, get it interactively.
	 */
a484 3
	/*
	 * Remove the lock
	 */
d490 1
a490 3
	/*
	 * Current head revision gets the RCS patch as rd_text
	 */
d505 1
a505 3
	/*
	 * Now add our new revision
	 */
d522 1
a522 4
	/*
	 * New head revision has to contain entire file;
	 */

d528 1
a528 3
	/*
	 * Attach a symbolic name to this revision if specified.
	 */
d533 1
a533 3
	/*
	 * Set the state of this revision if specified.
	 */
d541 1
a541 3
	/*
	 * Do checkout if -u or -l are specified.
	 */
d569 1
a569 3
	/*
	 * Load file contents
	 */
d580 1
a580 3
	/*
	 * Get description from user
	 */
d584 1
a584 3
	/*
	 * Now add our new revision
	 */
d598 1
a598 3
	/*
	 * New head revision has to contain entire file;
	 */
d603 1
a603 3
	/*
	 * Attach a symbolic name to this revision if specified.
	 */
d608 1
a608 3
	/*
	 * Set the state of this revision if specified.
	 */
d615 1
a615 3
	/*
	 * Do checkout if -u or -l are specified.
	 */
@


1.71
log
@- only do one rcs_statfile() instead of two; simplify some logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.70 2005/11/27 16:15:26 niallo Exp $	*/
d773 1
a773 2
		cvs_log(LP_ERRNO, "failed to stat: `%s'",
		    pb->filename);
@


1.70
log
@- checkin_init() IS now implemented; update comment with this happy
  new reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.69 2005/11/24 15:35:11 xsa Exp $	*/
d237 8
a244 10
		if ((pb.openflags & RCS_CREATE)
		    && (rcs_statfile(pb.filename, pb.fpath,
			    sizeof(pb.fpath)) < 0)) {
			pb.flags |= NEWFILE;
		} else if (!(pb.openflags & RCS_CREATE)
		    && (rcs_statfile(pb.filename, pb.fpath,
			    sizeof(pb.fpath)) < 0)) {
			cvs_log(LP_ERR, "No existing RCS file");
			status = 1;
			continue;
@


1.69
log
@memset();
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.68 2005/11/23 14:21:53 xsa Exp $	*/
a589 1
 * XXX not fully implemented yet.
@


1.68
log
@knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.67 2005/11/23 09:39:20 xsa Exp $	*/
d825 1
a825 1
			bzero(basepath, MAXPATHLEN);
@


1.67
log
@initial bits for -T support;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.66 2005/11/22 11:49:02 niallo Exp $	*/
d32 1
a32 1
#include <err.h>
a33 1
#include <errno.h>
a34 1
#include <ctype.h>
d36 1
a37 2
#include <string.h>
#include <time.h>
d65 11
a75 11
static int    checkin_attach_symbol(struct checkin_params *pb);
static int    checkin_checklock(struct checkin_params *pb);
static char * checkin_choose_rcsfile(const char *);
static char * checkin_diff_file(struct checkin_params *);
static char * checkin_getdesc(void);
static char * checkin_getinput(const char *);
static char * checkin_getlogmsg(RCSNUM *, RCSNUM *);
static int    checkin_init(struct checkin_params *);
static int    checkin_mtimedate(struct checkin_params *pb);
static int    checkin_update(struct checkin_params *pb);
static void   checkin_revert(struct checkin_params *pb);
@


1.66
log
@- ci(1) can intialise RCS files now!
- support for -j added
- support for -i added

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.65 2005/11/22 09:54:00 xsa Exp $	*/
d47 1
a47 1
#define CI_OPTSTRING    "d::f::i::j::k:l::m:M::N:n:qr::s:u::Vw:x:"
d84 1
a84 1
	    "usage: ci [-MNqV] [-d[date]] [-f[rev]] [-i[rev]] [-j[rev]]\n"
d195 3
@


1.65
log
@nuke trailing whitespaces; no cookie for niallo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.64 2005/11/21 16:20:28 xsa Exp $	*/
d134 1
d139 1
d239 1
a239 1
			    sizeof(pb.fpath)) < 0))
d241 12
a252 1
		else
d254 1
a254 1

a616 1
	printf("set description\n");
d621 1
a621 2
	if (rcs_rev_add(pb->file, RCS_HEAD_REV, LOG_INIT,
	    -1, pb->username) != 0) {
a624 1
	printf("added rev\n");
a632 1
	printf("set head rev\n");
d637 1
a637 1
	if (rcs_deltatext_set(pb->file, pb->frev, filec) == -1) {
d641 23
a663 1
	printf("set delta text\n");
d665 2
@


1.64
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.63 2005/11/21 15:16:41 niallo Exp $	*/
d279 1
a279 1
 * Generate the diff between the working file and a revision. 
d340 1
a340 1
 * checkin_getlogmsg() 
d575 1
a575 1
 * 
d756 1
a756 1
 * should be. 
@


1.63
log
@- modularisation; split the two major checkin operations into functions.
- modularisation; split the revert code into checkin_revert()
- a few steps closer to rcsfile initialisation, but things need to be fixed
  in the rcs.c api first (currently we segfault).
- add a new checkin_choose_rcsfile() function to decide where the rcsfile
  should go.
- add a special case for ci to rcs_statfile() so that we don't print out an
  error if the rcsfile doesn't exist.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.62 2005/11/17 00:22:30 niallo Exp $	*/
d47 1
a47 1
#define CI_OPTSTRING    "d::f::i::j::k:l::m:M::N:n:qr::s:u::Vw:"
d203 3
@


1.62
log
@- "revdate" is something else - function should be called
  checkin_mtimedate() for clarity.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.61 2005/11/17 00:16:35 niallo Exp $	*/
d52 1
a52 1
#define LOG_PROMPT      "enter log message, terminated with a single '.' " \
d54 3
a56 2
#define DESC_PROMPT     "enter description, terminated with single '.' "   \
	                "or end of file:\nNOTE: This is NOT the log message!\n"
d70 1
d75 3
a77 1
static void   checkin_init(struct checkin_params *);
a78 1
static int    checkin_mtimedate(struct checkin_params *pb);
a101 2
	char  *filec;
	struct stat sb;
a102 1
	BUF *bp;
a226 2
		if (rcs_statfile(pb.filename, pb.fpath, sizeof(pb.fpath)) < 0)
			continue;
d232 3
a234 1
		if ((pb.openflags & RCS_CREATE) && (stat(pb.fpath, &sb) < 0))
d239 14
a262 83

		pb.frev = pb.file->rf_head;

		/*
		 * If revision passed on command line is less than HEAD, bail.
		 */
		if ((pb.newrev != NULL)
		    && (rcsnum_cmp(pb.newrev, pb.frev, 0) > 0)) {
			cvs_log(LP_ERR, "revision is too low!");
			status = 1;
			rcs_close(pb.file);
			continue;
		}

		/*
		 * Load file contents
		 */
		if ((bp = cvs_buf_load(argv[i], BUF_AUTOEXT)) == NULL) {
			cvs_log(LP_ERR, "failed to load '%s'", pb.filename);
			exit(1);
		}

		if (cvs_buf_putc(bp, '\0') < 0)
			exit(1);

		filec = (char *)cvs_buf_release(bp);

		/*
		 * Get RCS patch
		 */
		if ((pb.deltatext = checkin_diff_file(&pb)) == NULL) {
			cvs_log(LP_ERR, "failed to get diff");
			exit(1);
		}

		/*
		 * If -f is not specified and there are no differences, tell
		 * the user and revert to latest version.
		 */
		if (!(pb.flags & FORCE) && (strlen(pb.deltatext) < 1)) {
			checkin_revert(&pb);
			continue;
		}

		/*
		 * Check for a lock belonging to this user. If none,
		 * abort check-in.
		 */
		if (checkin_checklock(&pb) < 0) {
			status = 1;
			continue;
		}

		/*
		 * If no log message specified, get it interactively.
		 */
		if (pb.flags & INTERACTIVE)
			pb.rcs_msg = checkin_getlogmsg(pb.frev, pb.newrev);

		/*
		 * Remove the lock
		 */
		if (rcs_lock_remove(pb.file, pb.frev) < 0) {
			if (rcs_errno != RCS_ERR_NOENT)
			    cvs_log(LP_WARN, "failed to remove lock");
                }

		/*
		 * Current head revision gets the RCS patch as rd_text
		 */
		if (rcs_deltatext_set(pb.file, pb.frev, pb.deltatext) == -1) {
			cvs_log(LP_ERR,
			    "failed to set new rd_text for head rev");
			exit (1);
		}

		/*
		 * Set the date of the revision to be the last modification
		 * time of the working file if -d has no argument.
		 */
		if (pb.date == DATE_MTIME
		    && (checkin_mtimedate(&pb) < 0))
			    continue;
d264 2
a265 17

		/*
		 * Now add our new revision
		 */
		if (rcs_rev_add(pb.file,
			(pb.newrev == NULL ? RCS_HEAD_REV : pb.newrev),
		    pb.rcs_msg, pb.date, pb.username) != 0) {
			cvs_log(LP_ERR, "failed to add new revision");
			exit(1);
		}

		/*
		 * If we are checking in to a non-default (ie user-specified)
		 * revision, set head to this revision.
		 */
		if (pb.newrev != NULL)
			rcs_head_set(pb.file, pb.newrev);
d267 1
a267 44
			pb.newrev = pb.file->rf_head;

		/*
		 * New head revision has to contain entire file;
		 */
                if (rcs_deltatext_set(pb.file, pb.frev, filec) == -1) {
			cvs_log(LP_ERR, "failed to set new head revision");
			exit(1);
		}

		/*
		 * Attach a symbolic name to this revision if specified.
		 */
		if (pb.symbol != NULL
		    && (checkin_attach_symbol(&pb) < 0)) {
			status = 1;
			continue;
		}

		/*
		 * Set the state of this revision if specified.
		 */
		if (pb.state != NULL)
			(void)rcs_state_set(pb.file, pb.newrev, pb.state);

		free(pb.deltatext);
		free(filec);
		(void)unlink(pb.filename);

		/*
		 * Do checkout if -u or -l are specified.
		 */
		if (((pb.flags & CO_LOCK) || (pb.flags & CO_UNLOCK))
		    && !(pb.flags & CI_DEFAULT))
			checkout_rev(pb.file, pb.newrev, pb.filename, pb.flags,
			    pb.username);

		/* File will NOW be synced */
		rcs_close(pb.file);

		if (pb.flags & INTERACTIVE) {
			free(pb.rcs_msg);
			pb.rcs_msg = NULL;
		}
d415 156
d575 1
d577 1
a577 1
static void
d588 1
a588 1
		exit(1);
d592 1
a592 1
		exit(1);
d601 1
d607 1
a607 1
		-1, pb->username) != 0) {
d609 19
a627 1
		exit(1);
d629 3
d747 50
@


1.61
log
@- split -d handling into function checkin_setrevdate()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.60 2005/11/17 00:03:04 niallo Exp $	*/
d75 1
a75 1
static int    checkin_setrevdate(struct checkin_params *pb);
d330 1
a330 1
		    && (checkin_setrevdate(&pb) < 0))
d676 1
a676 1
 * checkin_setrevdate()
d679 1
a679 1
 * time of the working file if -d has no argument.
d684 1
a684 1
checkin_setrevdate(struct checkin_params *pb)
@


1.60
log
@- spelling fix
- minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.59 2005/11/16 19:23:46 niallo Exp $	*/
d75 1
d329 4
a332 9
		if (pb.date == DATE_MTIME) {
			if (stat(pb.filename, &sb) != 0) {
				cvs_log(LP_ERRNO, "failed to stat: `%s'",
				    pb.filename);
				rcs_close(pb.file);
				continue;
			}
			pb.date = (time_t)sb.st_mtimespec.tv_sec;
		}
d672 22
@


1.59
log
@- add comments for functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.58 2005/11/16 19:06:41 niallo Exp $	*/
d241 2
a242 1
			cvs_log(LP_ERR, "failed to open rcsfile '%s'", pb.fpath);
d549 1
a549 1
 * XXX not full implemented yet.
@


1.58
log
@lots of changes to allow greater code re-use and modularisation, along with
some support code for rcs file initialisation and -i and -j options (not
yet implemented though).

no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.57 2005/11/08 15:58:38 xsa Exp $	*/
d403 6
d467 2
d470 1
d501 1
a501 1
 * Returns NULL on failure.
d515 2
a516 1
 * Get some input from the user.
d548 1
d585 6
d618 8
d645 6
@


1.57
log
@missing casts;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.56 2005/11/02 21:42:16 niallo Exp $	*/
d47 1
d51 21
a71 1
static char * checkin_diff_file(RCSFILE *, RCSNUM *, const char *);
d73 2
d80 6
a85 3
	    "usage: ci [-jMNqV] [-d[date]] [-f[rev]] [-kmode] [-l[rev]]\n"
	    "          [-M[rev]] [-mmsg] [-Nsymbol] [-nsymbol] [-r[rev]]\n"
	    "          [-sstate] [-u[rev]] [-wusername] file ...\n");
a86 1
}
d97 4
a100 10
	int found, notlocked, ret, status;
	int i, ch, flags;
	mode_t fmode;
	time_t date;
	RCSFILE *file;
	RCSNUM *frev, *newrev;
	char fpath[MAXPATHLEN];
	char *rcs_msg, *filec, *deltatext, *username, rbuf[16];
	const char *symbol, *state;
	struct rcs_lock *lkp;
d103 6
a108 6
	date = DATE_NOW;
	file = NULL;
	rcs_msg = username = NULL;
	state = symbol = NULL;
	newrev =  NULL;
	fmode = flags = status = 0;
d110 2
a111 1
	flags |= INTERACTIVE;
d113 1
a113 1
	while ((ch = rcs_getopt(argc, argv, "d::f::j:k:l::m:M::N:n:qr::s:u::Vw:")) != -1) {
d117 2
a118 2
				date = DATE_MTIME;
			else if ((date = cvs_date_parse(rcs_optarg)) <= 0) {
d124 2
a125 2
			rcs_set_rev(rcs_optarg, &newrev);
			flags |= FORCE;
d130 8
d139 2
a140 2
			rcs_set_rev(rcs_optarg, &newrev);
			flags |= CO_LOCK;
d143 2
a144 2
			rcs_set_rev(rcs_optarg, &newrev);
			flags |= CO_REVDATE;
d147 7
a153 2
			rcs_msg = rcs_optarg;
			flags &= ~INTERACTIVE;
d156 1
a156 1
			if ((symbol = strdup(rcs_optarg)) == NULL) {
d160 3
a162 2
			if (rcs_sym_check(symbol) != 1) {
				cvs_log(LP_ERR, "invalid symbol `%s'", symbol);
d165 1
a165 1
			flags |= CI_SYMFORCE;
d168 1
a168 1
			if ((symbol = strdup(rcs_optarg)) == NULL) {
d172 3
a174 2
			if (rcs_sym_check(symbol) != 1) {
				cvs_log(LP_ERR, "invalid symbol `%s'", symbol);
d182 2
a183 2
			rcs_set_rev(rcs_optarg, &newrev);
			flags |= CI_DEFAULT;
d186 4
a189 3
			state = rcs_optarg;
			if (rcs_state_check(state) < 0) {
				cvs_log(LP_ERR, "invalid state `%s'", state);
d194 2
a195 2
			rcs_set_rev(rcs_optarg, &newrev);
			flags |= CO_UNLOCK;
d201 1
a201 1
			username = rcs_optarg;
d218 1
a218 1
	if ((username == NULL) && (username = getlogin()) == NULL) {
d225 2
a226 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
d229 13
a241 3
		file = rcs_open(fpath, RCS_RDWR, fmode);
		if (file == NULL) {
			cvs_log(LP_ERR, "failed to open rcsfile '%s'", fpath);
d245 2
a246 1
		frev = file->rf_head;
d248 1
a248 2
		if (verbose == 1)
			printf("%s  <--  %s\n", fpath, argv[i]);
d253 2
a254 1
		if ((newrev != NULL) && (rcsnum_cmp(newrev, frev, 0) > 0)) {
d257 1
a257 1
			rcs_close(file);
d265 1
a265 1
			cvs_log(LP_ERR, "failed to load '%s'", argv[i]);
d277 1
a277 1
		if ((deltatext = checkin_diff_file(file, frev, argv[i])) == NULL) {
d283 2
a284 2
		 * If -f is not specified and there are no differences, tell the
		 * user and revert to latest version.
d286 2
a287 13
		if ((flags & FORCE) && (strlen(deltatext) < 1)) {
			rcsnum_tostr(frev, rbuf, sizeof(rbuf));
			cvs_log(LP_WARN,
			    "file is unchanged; reverting to previous revision %s",
			    rbuf);
			(void)unlink(argv[i]);
			if ((flags & CO_LOCK) || (flags & CO_UNLOCK))
				checkout_rev(file, frev, argv[i], flags,
				    username);
			rcs_lock_remove(file, frev);
			rcs_close(file);
			if (verbose == 1)
				printf("done\n");
d295 1
a295 17
		found = 0;
		notlocked = 1;
		if (!TAILQ_EMPTY(&(file->rf_locks))) {
			TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
				if (!strcmp(lkp->rl_name, username))
					notlocked = 0;

				if (!strcmp(lkp->rl_name, username) &&
				    !rcsnum_cmp(lkp->rl_num, frev, 0)) {
					found = 1;
					break;
				}
			}
		}

		if ((found == 0) && (notlocked == 0)) {
			cvs_log(LP_ERR, "no locks set for '%s'", username);
a296 1
			rcs_close(file);
d303 2
a304 2
		if (rcs_msg == NULL)
			rcs_msg = checkin_getlogmsg(frev, newrev);
d309 1
a309 1
		if (rcs_lock_remove(file, frev) < 0) {
d317 1
a317 1
		if (rcs_deltatext_set(file, frev, deltatext) == -1) {
d324 2
a325 2
		 * Set the date of the revision to be the last modification time
		 * of the working file if -d is specified without an argument.
d327 2
a328 3
		if (date == DATE_MTIME) {
			struct stat sb;
			if (stat(argv[i], &sb) != 0) {
d330 2
a331 2
				    argv[i]);
				rcs_close(file);
d334 1
a334 1
			date = (time_t)sb.st_mtimespec.tv_sec;
d340 3
a342 2
		if (rcs_rev_add(file, (newrev == NULL ? RCS_HEAD_REV : newrev),
		    rcs_msg, date, username) != 0) {
d351 2
a352 2
		if (newrev != NULL)
			rcs_head_set(file, newrev);
d354 1
a354 1
			newrev = file->rf_head;
d359 1
a359 1
                if (rcs_deltatext_set(file, frev, filec) == -1) {
d367 4
a370 22
		if (symbol != NULL) {
			if (verbose == 1)
				printf("symbol: %s\n", symbol);
			if (flags & CI_SYMFORCE)
				rcs_sym_remove(file, symbol);
			if ((ret = rcs_sym_add(file, symbol, newrev) == -1)
			    && (rcs_errno == RCS_ERR_DUPENT)) {
				rcsnum_tostr(rcs_sym_getrev(file, symbol),
				    rbuf, sizeof(rbuf));
				cvs_log(LP_ERR,
				    "symbolic name %s already bound to %s",
				    symbol, rbuf);
				status = 1;
				rcs_close(file);
				continue;
			} else if (ret == -1) {
				cvs_log(LP_ERR, "problem adding symbol: %s",
				    symbol);
				status = 1;
				rcs_close(file);
				continue;
			}
d376 2
a377 2
		if (state != NULL)
			(void)rcs_state_set(file, newrev, state);
d379 1
a379 1
		free(deltatext);
d381 1
a381 1
		(void)unlink(argv[i]);
d386 4
a389 3
		if (((flags & CO_LOCK) || (flags & CO_UNLOCK))
		    && !(flags & CI_DEFAULT))
			checkout_rev(file, newrev, argv[i], flags, username);
d392 1
a392 1
		rcs_close(file);
d394 3
a396 3
		if (flags & INTERACTIVE) {
			free(rcs_msg);
			rcs_msg = NULL;
d404 1
a404 1
checkin_diff_file(RCSFILE *rfp, RCSNUM *rev, const char *filename)
d410 1
a410 1
	rcsnum_tostr(rev, rbuf, sizeof(rbuf));
d412 2
a413 2
	if ((b1 = cvs_buf_load(filename, BUF_AUTOEXT)) == NULL) {
		cvs_log(LP_ERR, "failed to load file: '%s'", filename);
d417 1
a417 1
	if ((b2 = rcs_getrev(rfp, rev)) == NULL) {
d466 1
a466 2
	char   *rcs_msg, buf[128], nrev[16], prev[16];
	BUF    *logbuf;
a478 5
	if ((logbuf = cvs_buf_alloc((size_t)64, BUF_AUTOEXT)) == NULL) {
		cvs_log(LP_ERR, "failed to allocate log buffer");
		return (NULL);
	}

a481 3
	printf("enter log message, terminated with single "
	    "'.' or end of file:\n");
	printf(">> ");
d483 37
d524 1
a524 1
		cvs_buf_append(logbuf, buf, strlen(buf));
d528 110
a637 2
	cvs_buf_putc(logbuf, '\0');
	rcs_msg = (char *)cvs_buf_release(logbuf);
d639 6
a644 1
	return (rcs_msg);
@


1.56
log
@- kill two unused constant definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.55 2005/11/02 20:40:56 niallo Exp $	*/
d420 1
a420 1
	if ((b3 = cvs_buf_alloc(128, BUF_AUTOEXT)) == NULL) {
d477 1
a477 1
	if ((logbuf = cvs_buf_alloc(64, BUF_AUTOEXT)) == NULL) {
@


1.55
log
@- sync checkin_usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.54 2005/11/02 20:32:45 niallo Exp $	*/
a45 3

#define LOCK_LOCK	1
#define LOCK_UNLOCK	2
@


1.54
log
@changes from Venice:

- instead of using lots of individual flag variables, use a single int and
  bitwise operations on it. while this saves memory, really it saves code
  space and reduces complexity. checkout_rev() and checkout_state() in
  particular benefit from these changes since their parameters where growing
  really long.

- implement `-s' option in co

- implement `-M' option in ci

"I like this, go for it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.53 2005/10/30 09:46:07 xsa Exp $	*/
d61 3
a63 2
	    "          [-mmsg] [-Nsymbol] [-nsymbol] [-r[rev]] [-sstate]\n"
	    "          [-u[rev]] [-wusername] file ...\n");
@


1.53
log
@string fix;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.52 2005/10/29 19:10:16 niallo Exp $	*/
d74 2
a75 2
	int found, notlocked, ret;
	int i, ch, force, lkmode, interactive, rflag, status, symforce;
d91 1
a91 2
	fmode = force = lkmode = rflag = status = symforce = 0;
	interactive = 1;
d93 1
d95 1
a95 1
	while ((ch = rcs_getopt(argc, argv, "d::f::j:k:l::m:M:N:n:qr::s:u::Vw:")) != -1) {
d107 1
a107 1
			force = 1;
d114 5
a118 1
			lkmode = LOCK_LOCK;
d122 1
a122 1
			interactive = 0;
d133 1
a133 1
			symforce = 1;
d150 1
a150 1
			rflag = 1;
d161 1
a161 1
			lkmode = LOCK_UNLOCK;
d240 1
a240 1
		if ((force == 0) && (strlen(deltatext) < 1)) {
d246 3
a248 3
			if (lkmode != 0)
				checkout_rev(file, frev, argv[i], lkmode,
				    username, 0);
d352 1
a352 1
			if (symforce == 1)
d386 3
a388 2
		if ((lkmode != 0) && (rflag == 0))
			checkout_rev(file, newrev, argv[i], lkmode, username, 0);
d393 1
a393 1
		if (interactive == 1) {
@


1.52
log
@- sync checkin_usage()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.51 2005/10/29 19:05:51 niallo Exp $	*/
d151 1
a151 1
				cvs_log(LP_ERR, "invalid state `%'", state);
@


1.51
log
@- add two new functions to RCS api: rcs_state_set() and rcs_state_check()
- use these two new functions to implement -s<state> option in ci

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.50 2005/10/27 07:43:56 xsa Exp $	*/
d61 2
a62 2
	    "          [-mmsg] [-Nsymbol] [-nsymbol] [-r[rev]] [-u[rev]]\n"
            "          [-wusername] file ...\n");
@


1.50
log
@TMPDIR support; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.49 2005/10/25 17:48:56 xsa Exp $	*/
d82 1
a82 1
	const char *symbol = NULL;
d89 1
d95 1
a95 1
	while ((ch = rcs_getopt(argc, argv, "d::f::j:k:l::m:M:N:n:qr::u::Vw:")) != -1) {
d148 7
d368 6
@


1.49
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.48 2005/10/25 17:27:54 xsa Exp $	*/
d410 2
a411 1
	strlcpy(path1, "/tmp/diff1.XXXXXXXXXX", sizeof(path1));
d420 2
a421 1
	strlcpy(path2, "/tmp/diff2.XXXXXXXXXX", sizeof(path2));
@


1.48
log
@nuke trailing whitespaces;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.47 2005/10/19 11:37:11 niallo Exp $	*/
d228 1
a228 1
		if ((!force) && (strlen(deltatext) < 1)) {
d263 1
a263 1
		if (found == 0 && notlocked == 0) {
d340 1
a340 1
			if (symforce)
d368 1
a368 1
		if (lkmode != 0 && !rflag)
d374 1
a374 1
		if (interactive) {
@


1.47
log
@- make a bunch of changes to how we handle verbose output. this brings us
much closer in line with GNU RCS and cleans things up in general.

ok joris@@, "looks fine to me" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.46 2005/10/18 01:39:47 joris Exp $	*/
d230 1
a230 1
			cvs_log(LP_WARN, 
@


1.46
log
@- no point in using cvs_printf() in openrcs;
- only output info messages if -q flag isn't given;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.45 2005/10/18 01:22:14 joris Exp $	*/
d90 1
a90 1
	fmode = force = lkmode = verbose = rflag = status = symforce = 0;
d463 3
a465 1
	printf("new revision: %s; previous revision: %s\n", nrev, prev);
@


1.45
log
@use rcs_set_rev() instead of duplicating code all over the
place to set a variable to the given revision number;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.44 2005/10/18 01:10:28 joris Exp $	*/
d74 1
a74 1
	int found, notlocked;
d81 1
a81 1
	char *rcs_msg, *filec, *deltatext, *username;
d190 2
a191 1
		cvs_printf("%s  <--  %s\n", fpath, argv[i]);
d229 1
a229 2
			char buf[16];
			rcsnum_tostr(frev, buf, sizeof(buf));
d232 1
a232 1
			    buf);
d239 2
a240 1
			cvs_printf("done\n");
d338 2
a339 2
			cvs_printf("symbol: %s\n", symbol);
			int ret = 0;
a343 1
				char tmp[16];
d345 1
a345 1
				    tmp, sizeof(tmp));
d348 1
a348 1
				    symbol, tmp);
d353 1
a353 1
				cvs_printf("problem adding symbol: %s\n",
d463 2
a464 2
	cvs_printf("new revision: %s; previous revision: %s\n", nrev, prev);
	cvs_printf("enter log message, terminated with single "
d466 1
a466 1
	cvs_printf(">> ");
d473 1
a473 1
		cvs_printf(">> ");
@


1.44
log
@correctly handle locks when commiting something;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.43 2005/10/17 22:24:18 niallo Exp $	*/
d105 1
a105 6
			if (rcs_optarg != NULL) {
				if ((newrev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
			}
d112 1
a112 6
			if (rcs_optarg != NULL) {
				if ((newrev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
			}
d144 1
a145 6
			if (rcs_optarg != NULL) {
				if ((newrev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
			}
d148 1
a148 6
			if (rcs_optarg != NULL) {
				if ((newrev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
			}
@


1.43
log
@- remove a printf which kept in by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.42 2005/10/17 22:04:54 niallo Exp $	*/
d74 1
d267 17
a283 3
		if (TAILQ_EMPTY(&(file->rf_locks))) {
			cvs_log(LP_ERR, "%s: no lock set by %s", fpath,
			    username);
a286 12
		} else {
			TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
				if ((strcmp(lkp->rl_name, username) != 0)
				    && (rcsnum_cmp(lkp->rl_num, frev, 0))) {
					cvs_log(LP_ERR,
					    "%s: no lock set by %s", fpath,
					    username);
					status = 1;
					rcs_close(file);
					continue;
				}
			}
@


1.42
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.41 2005/10/17 15:33:12 joris Exp $	*/
d61 2
a62 2
	    "          [-mmsg] [-nsymbol] [-r[rev]] [-u[rev]] [-wusername]\n"
            "          file ...\n");
d74 1
a74 1
	int i, ch, force, lkmode, interactive, rflag, status;
d89 1
a89 1
	fmode = force = lkmode = verbose = rflag = status = 0;
a126 1
			cvs_printf("rcs_msg: %s\n", rcs_msg);
d137 1
d356 2
@


1.41
log
@support -f flag for co;
'fine' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.40 2005/10/16 23:30:45 niallo Exp $	*/
d129 10
d359 4
a362 2
				rcsnum_tostr(rcs_sym_getrev(file, symbol), tmp, sizeof(tmp));
				cvs_log(LP_ERR, "symbolic name %s already bound to %s",
d368 2
a369 1
				cvs_printf("problem adding symbol: %s\n", symbol);
@


1.40
log
@- remove the lock even if we are just reverting to the previous
  revision (like GNU RCS).
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.39 2005/10/16 22:56:22 niallo Exp $	*/
d245 1
a245 1
				    username);
d371 1
a371 1
			checkout_rev(file, newrev, argv[i], lkmode, username);
@


1.39
log
@- sync checkin_usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.38 2005/10/16 22:23:54 niallo Exp $	*/
d246 1
@


1.38
log
@- add support for `-n<symbol>'
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.37 2005/10/16 14:10:57 niallo Exp $	*/
d61 2
a62 1
	    "          [-mmsg] [-r[rev]] [-u[rev]] [-wusername] file ...\n");
@


1.37
log
@- sort rcs_getopt() string before i add more options.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.36 2005/10/16 11:40:56 niallo Exp $	*/
d80 1
d92 1
a92 1
	while ((ch = rcs_getopt(argc, argv, "d::f::j:k:l::m:M:N:qr::u::Vw:")) != -1) {
d128 10
d336 23
@


1.36
log
@- zap an incorrect comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.35 2005/10/16 11:36:56 niallo Exp $	*/
d91 1
a91 1
	while ((ch = rcs_getopt(argc, argv, "f::j:l::M:N:qu::d::r::m:k:Vw:")) != -1) {
@


1.35
log
@- remove unused `flags' variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.34 2005/10/16 11:35:11 niallo Exp $	*/
a184 4
		/*
		 * If rev is not specified on the command line,
		 * assume HEAD.
		 */
d186 1
@


1.34
log
@- remove unused `rcsfile' parameter from checkin_getlogmsg()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.33 2005/10/16 11:29:28 niallo Exp $	*/
d73 1
a73 1
	int i, ch, flags, force, lkmode, interactive, rflag, status;
a83 1
	flags = RCS_RDWR;
@


1.33
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.32 2005/10/16 01:55:36 joris Exp $	*/
d54 1
a54 1
static char * checkin_getlogmsg(char *, RCSNUM *, RCSNUM *);
d271 1
a271 1
			rcs_msg = checkin_getlogmsg(fpath, frev, newrev);
d412 1
a412 1
checkin_getlogmsg(char *rcsfile, RCSNUM *rev, RCSNUM *rev2)
@


1.32
log
@spacing;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.31 2005/10/15 23:44:58 niallo Exp $	*/
d126 1
d236 2
a237 1
				checkout_rev(file, frev, argv[i], lkmode, username);
d297 2
a298 1
				cvs_log(LP_ERRNO, "failed to stat: `%s'", argv[i]);
@


1.31
log
@- add support for `-wusername'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.30 2005/10/15 21:33:21 niallo Exp $	*/
d287 1
d301 1
d319 1
d429 1
d434 1
d442 1
d445 1
@


1.30
log
@- sort rcs_getopt() switch cases, they got a bit mixed up along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.29 2005/10/15 19:45:23 niallo Exp $	*/
d61 1
a61 1
	    "          [-mmsg] [-r[rev]] [-u[rev]] file ...\n");
d86 1
a86 1
	rcs_msg = NULL;
a90 4
	if ((username = getlogin()) == NULL) {
		cvs_log(LP_ERRNO, "failed to get username");
		exit(1);
	}
d92 1
a92 1
	while ((ch = rcs_getopt(argc, argv, "f::j:l::M:N:qu::d::r::m:k:V")) != -1) {
d151 3
d169 6
d304 1
a304 1
		    rcs_msg, date) != 0) {
@


1.29
log
@- add support for `-f' option.
- if user does not specify `-f', warn them that they are
  checking in an unchanged file and revert to previous
  revision (like GNU RCS).
- update checkin_usage(), removing spaces after options
  since we do not support them with rcs_getopt() (like
  GNU RCS).
- ensure we rcs_close() the file even if we are aborting
  check-in due to lack of a lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.28 2005/10/15 18:26:24 niallo Exp $	*/
d118 9
d134 2
a135 4
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'l':
a141 1
			lkmode = LOCK_LOCK;
d152 3
a154 9
		case 'r':
			rflag = 1;
			if (rcs_optarg != NULL) {
				if ((newrev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit(1);
				}
			}
			break;
@


1.28
log
@modularise checkout code into checkout_rev(). this shaves off a number
of lines in ci.c due to code re-use, and will simplify features which are in
the pipeline. no functional changes.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.27 2005/10/15 14:23:06 niallo Exp $	*/
d54 1
a54 1
static char * checkin_getlogmsg(char *, char *, RCSNUM *, RCSNUM *);
d60 2
a61 2
	    "usage: ci [-jMNqV] [-d [date]] [-k mode] [-l [rev]] [-m msg]\n"
	    "          [-r [rev]] [-u [rev]] file ...\n");
d73 1
a73 1
	int i, ch, flags, lkmode, interactive, rflag, status;
d88 1
a88 1
	fmode = lkmode = verbose = rflag = status = 0;
d96 1
a96 1
	while ((ch = rcs_getopt(argc, argv, "j:l::M:N:qu::d::r::m:k:V")) != -1) {
d106 9
d179 1
d185 2
d211 26
d244 1
d254 1
d264 1
a264 1
			rcs_msg = checkin_getlogmsg(fpath, argv[i], frev, newrev);
a274 8
		 * Get RCS patch
		 */
		if ((deltatext = checkin_diff_file(file, frev, argv[i])) == NULL) {
			cvs_log(LP_ERR, "failed to get diff");
			exit(1);
		}

		/*
a287 1
			tzset();
d401 1
a401 1
checkin_getlogmsg(char *rcsfile, char *workingfile, RCSNUM *rev, RCSNUM *rev2)
a420 1
	cvs_printf("%s  <--  %s\n", rcsfile, workingfile);
@


1.27
log
@minor style change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.26 2005/10/13 23:00:49 niallo Exp $	*/
d296 3
a298 26
		if (lkmode != 0 && !rflag) {
			mode_t mode = 0;
			if ((bp = rcs_getrev(file, newrev)) == NULL) {
				cvs_log(LP_ERR, "cannot get revision");
				goto err;
			}
			if (lkmode == LOCK_LOCK) {
				mode = 0644;
				if (rcs_lock_add(file, username, newrev) < 0) {
					if (rcs_errno != RCS_ERR_DUPENT)
						cvs_log(LP_ERR,
						    "failed to lock revision");
					else
						cvs_log(LP_ERR,
						    "you already have a lock");
				}
			} else if (lkmode == LOCK_UNLOCK) {
				mode = 0444;
			}
			if (cvs_buf_write(bp, argv[i], mode) < 0) {
				cvs_log(LP_ERR,
				    "failed to write revision to file");
			}
			cvs_buf_free(bp);
		}
err:
@


1.26
log
@- sync checkin_usage().
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.25 2005/10/13 22:54:46 niallo Exp $	*/
d75 1
a75 1
	time_t date = DATE_NOW;
d83 1
d256 1
@


1.25
log
@- implement bare `-d' option; this sets the check-in date and time
  to be that of the working file's last modification time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.24 2005/10/13 12:35:30 joris Exp $	*/
d60 1
a60 1
	    "usage: ci [-jMNqV] [-d date] [-k mode] [-l [rev]] [-m msg]\n"
@


1.24
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.23 2005/10/12 22:57:26 niallo Exp $	*/
d50 3
d75 1
a75 1
	time_t date = -1;
d95 1
a95 1
	while ((ch = rcs_getopt(argc, argv, "j:l::M:N:qu::d:r::m:k:V")) != -1) {
d98 3
a100 1
			if ((date = cvs_date_parse(rcs_optarg)) <= 0) {
d248 13
@


1.23
log
@add a cast when doing cvs_buf_release();
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.22 2005/10/12 17:13:30 deraadt Exp $	*/
d92 1
a92 1
	while ((ch = getopt(argc, argv, "j:l::M:N:qu::d:r::m:k:V")) != -1) {
d95 1
a95 1
			if ((date = cvs_date_parse(optarg)) <= 0) {
d104 1
a104 1
			rcs_msg = optarg;
d114 2
a115 2
			if (optarg != NULL) {
				if ((newrev = rcsnum_parse(optarg)) == NULL) {
d123 2
a124 2
			if (optarg != NULL) {
				if ((newrev = rcsnum_parse(optarg)) == NULL) {
d133 2
a134 2
			if (optarg != NULL) {
				if ((newrev = rcsnum_parse(optarg)) == NULL) {
d146 3
a148 2
	argc -= optind;
	argv += optind;
@


1.22
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.21 2005/10/11 15:52:13 niallo Exp $	*/
d189 1
a189 1
		filec = cvs_buf_release(bp);
@


1.21
log
@zap unused variable `dflag'
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.20 2005/10/11 15:50:25 niallo Exp $	*/
a38 1
#include <signal.h>
a46 2
extern char *__progname;

d57 2
a58 2
	    "usage: %s [-jMNqV] [-d date] [-k mode] [-l [rev]] [-m msg]\n"
	    "          [-r [rev]] [-u [rev]] file ...\n", __progname);
@


1.20
log
@- support -d <date> option in ci.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.19 2005/10/10 17:12:49 xsa Exp $	*/
d73 1
a73 1
	int i, ch, dflag, flags, lkmode, interactive, rflag, status;
d87 1
a87 1
	fmode = lkmode = dflag = verbose = rflag = status = 0;
@


1.19
log
@getlogin(2) sets errno;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.18 2005/10/10 15:05:48 niallo Exp $	*/
d41 1
d75 1
d97 6
a180 4
		if (dflag) {
			/* XXX */
		}

d250 1
a250 1
		    rcs_msg, -1) != 0) {
@


1.18
log
@- support <rev> parameter to `-l' and `-u' options.
- sync checkin_usage().

note that with OpenRCS you must do `ci -l -- <file>' and `ci -u -- <file>'
when using bare arguments because our getopt(3) is POSIX compliant.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.17 2005/10/10 14:49:32 niallo Exp $	*/
d89 1
a89 1
		cvs_log(LP_ERR, "failed to get username");
@


1.17
log
@make sure that revision passed on command line is greater than HEAD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.16 2005/10/10 14:21:37 niallo Exp $	*/
d59 2
a60 2
	    "usage: %s [-jlMNquV] [-d date] [-r [rev]] [-m msg] [-k mode] "
	    "file ...\n", __progname);
d93 1
a93 1
	while ((ch = getopt(argc, argv, "j:lM:N:qud:r::m:k:V")) != -1) {
d109 6
d118 6
@


1.16
log
@ensure that the user has a lock on the correct revision before allowing
check-in.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.15 2005/10/09 21:17:59 niallo Exp $	*/
d146 14
a176 6

		/*
		 * If rev is not specified on the command line,
		 * assume HEAD.
		 */
		frev = file->rf_head;
@


1.15
log
@if -r is not specified, we need to set newrev to file->rf_head.

simpler fix than what i had in mind pointed out by joris.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.14 2005/10/09 19:29:22 joris Exp $	*/
d72 1
a72 1
	int i, ch, dflag, flags, lkmode, interactive, rflag;
d78 1
d85 1
a85 1
	fmode = lkmode = dflag = verbose = rflag = 0;
d171 22
d289 1
a289 1
	return (0);
@


1.14
log
@only get the log message when it's not specified on the command-line;
noticed by niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.13 2005/10/09 17:51:33 joris Exp $	*/
d214 2
a215 1

@


1.13
log
@simplify if() conditions;
ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.12 2005/10/09 14:48:13 niallo Exp $	*/
d172 1
a172 1
		if (rcs_msg != NULL)
@


1.12
log
@- sync checkin_usage()
- add support for checking-in to arbitrary revisions via -r option.

eg:

ci -r1.30 <file>

check in file, jump to revision 1.30 and set that revision to HEAD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.11 2005/10/08 16:27:41 niallo Exp $	*/
d168 1
d172 1
a172 3
		if (rcs_msg == NULL && newrev == NULL)
			rcs_msg = checkin_getlogmsg(fpath, argv[i], frev, NULL);
		else if (rcs_msg == NULL && newrev != NULL)
a173 1

@


1.11
log
@remove useless comment about command line options. not needed since this
is all in the manual page now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.10 2005/10/08 16:19:40 niallo Exp $	*/
d53 1
a53 1
static char * checkin_getlogmsg(char *, char *, RCSNUM *);
d59 1
a59 1
	    "usage: %s [-jlMNqruV] [-d date | -r rev] [-m msg] [-k mode] "
d72 1
a72 1
	int i, ch, dflag, flags, lkmode, interactive;
d75 1
a75 1
	RCSNUM *frev;
d77 1
a77 1
	char *rcs_msg, *rev, *filec, *deltatext, *username;
d82 3
a84 2
	rcs_msg = rev = NULL;
	fmode = lkmode = dflag = verbose = 0;
d113 9
d158 10
a167 2
		if (rev == NULL)
			frev = file->rf_head;
d171 4
a174 2
		if (rcs_msg == NULL)
			rcs_msg = checkin_getlogmsg(fpath, argv[i], frev);
a175 4
		if (cvs_buf_putc(bp, '\0') < 0)
			exit(1);

		filec = cvs_buf_release(bp);
d196 1
a196 1
		if (rcs_deltatext_set(file, file->rf_head, deltatext) == -1) {
d204 2
a205 1
		if (rcs_rev_add(file, RCS_HEAD_REV, rcs_msg, -1) != 0) {
d211 7
d232 1
a232 1
		if (lkmode != 0) {
d234 1
a234 1
			if ((bp = rcs_getrev(file, frev)) == NULL) {
d240 1
a240 1
				if (rcs_lock_add(file, username, frev) < 0) {
d329 1
a329 1
checkin_getlogmsg(char *rcsfile, char *workingfile, RCSNUM *rev)
d339 4
a342 1
	rcsnum_tostr(rcsnum_inc(tmprev), nrev, sizeof(nrev));
@


1.10
log
@sync checkin_usage() with manual page
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.9 2005/10/08 15:26:47 niallo Exp $	*/
a68 16
/*
Options:

-r | -r[rev]: check in revision rev
-l[rev]:      ", but do co -l
-u[rev]:      ", but do co -u
-f[rev]:      force a deposit (check in?)
-k[rev]:      ?
-q[rev]:      quiet mode
-i[rev]:      initial check in, errors if RCS file already exists.
-j[rev]:      just checkin and do not initialize, errors if RCS file already exists.
-I[rev]:      user is prompted even if stdin is not a tty
-d[date]:     uses date for checkin date and time.
-M[rev]:      set modification time on any new working file to be that of the retrieved version.
-mmsg:        msg is the log message, don't start editor. log messages with #are comments.
*/
@


1.9
log
@- add support for -u and -l options
- KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.8 2005/10/08 14:25:55 niallo Exp $	*/
d59 1
a59 1
	    "usage: %s [-jlMNqu] [-d date | -r rev] [-m msg] [-k mode] "
@


1.8
log
@remember to NUL-terminate logbuf in checkin_getlogmsg()
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.7 2005/10/08 14:18:35 niallo Exp $	*/
d49 3
d93 1
a93 1
	char *rcs_msg, *rev, *filec, *deltatext;
a95 1
	lkmode = -1;
d99 1
a99 1
	fmode = dflag = verbose = 0;
d102 6
a107 1
	while ((ch = getopt(argc, argv, "j:l:M:N:qu:d:r::m:k:V")) != -1) {
d122 6
d219 1
d221 29
a252 4
		/* XXX:
		 * Delete the working file - we do not support -u/-l just yet
		*/
		(void)unlink(argv[i]);
d330 1
a330 1
	rcsnum_tostr(rev, prev, sizeof(prev));
d345 1
a345 2
		if (feof(stdin) || ferror(stdin)
		    || buf[0] == '.')
@


1.7
log
@KNF;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.6 2005/10/08 14:09:18 niallo Exp $	*/
d312 1
@


1.6
log
@- add support for getting the log message from the user interactively,
  if it is not supplied on the command line.

- correct a couple of typos in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.5 2005/10/08 11:50:59 niallo Exp $	*/
a138 1

a142 1

d184 2
a185 1
			cvs_log(LP_ERR, "failed to set new rd_text for head rev");
d288 1
d296 1
a296 2
		cvs_log(LP_ERR,
		    "failed to allocate log buffer");
d300 1
a300 2
	cvs_printf("new revision: %s; previous revision: %s\n",
	    nrev, prev);
@


1.5
log
@spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.4 2005/10/07 23:59:56 niallo Exp $	*/
d50 1
d71 1
a71 1
-u[rev]:      ", bt do co -u
d78 1
a78 1
-d[date]:     uses date for checkin dat and time.
d85 1
a85 1
	int i, ch, dflag, flags, lkmode;
d97 2
a98 1
	fmode = dflag = 0;
d107 1
a138 4
		if (rcs_msg == NULL) {
			cvs_log(LP_ERR, "no log message");
			exit(1);
		}
d141 1
a141 1
				/* XXX */
a143 2
		if (rev == NULL)
			frev = file->rf_head;
d153 8
a188 1

d215 4
a231 2
	if (verbose)
		printf("retrieving revision %s\n", rbuf);
d277 39
@


1.4
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.3 2005/09/30 17:39:48 joris Exp $	*/
d262 1
a262 1
        diff_format = D_RCSDIFF;
@


1.3
log
@missing flags;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.2 2005/09/30 16:49:37 joris Exp $	*/
d44 1
d49 2
d87 1
d89 2
a90 1
	char *rcs_msg, *rev;
d95 1
a95 1
	rev = rcs_msg = NULL;
a102 3
		case 'l':
			lkmode = RCS_LOCK_STRICT;
			break;
a108 3
		case 'r':
			rev = optarg;
			break;
d130 1
a130 2
		flags = RCS_RDWR;
		file = rcs_open(fpath, flags, fmode);
d132 1
d135 1
d140 2
a141 4
		if (rev != NULL ) {
		 /* XXX */
		} else {
			if (dflag) {
a142 8
			} else {
				if (rcs_rev_add(file, RCS_HEAD_REV, rcs_msg, -1)
				    != 0) {
					cvs_log(LP_ERR,
					    "rcs_rev_add() failure");
					exit(1);
				}
			}
d144 61
d206 24
d232 39
a270 1
	exit(0);
@


1.2
log
@no need for cvs_log_init() here;
@
text
@d1 1
a1 1
/*	$OpenBSD: ci.c,v 1.1 2005/09/30 16:37:27 niallo Exp $	*/
d93 1
a93 1
	while ((ch = getopt(argc, argv, "j:l:M:N:qu:d:r::m:k:")) != -1) {
d103 3
@


1.1
log
@add a basic ci.c as a starting point. requires more changes to rcs api
to work properly.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsprog.c,v 1.2 2005/04/15 15:59:11 deraadt Exp $	*/
a91 2

	cvs_log_init(LD_STD, 0);
@

