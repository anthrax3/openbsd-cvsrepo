head	1.74;
access;
symbols
	OPENBSD_6_2:1.74.0.6
	OPENBSD_6_2_BASE:1.74
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.71.0.8
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.71.0.4
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.71.0.6
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.67.0.6
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.65.0.8
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.6
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.65
	OPENBSD_5_1:1.65.0.4
	OPENBSD_5_0:1.65.0.2
	OPENBSD_5_0_BASE:1.65
	OPENBSD_4_9:1.64.0.4
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.64.0.2
	OPENBSD_4_8_BASE:1.64
	OPENBSD_4_7:1.62.0.4
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.62.0.6
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.61.0.4
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.57.0.2
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23;
locks; strict;
comment	@ * @;


1.74
date	2016.10.16.13.35.51;	author okan;	state Exp;
branches;
next	1.73;
commitid	RkkF6LzZj7gdsaWi;

1.73
date	2016.08.31.13.09.09;	author jcs;	state Exp;
branches;
next	1.72;
commitid	d21193V9eCChgK44;

1.72
date	2016.08.26.09.02.54;	author guenther;	state Exp;
branches;
next	1.71;
commitid	07zudOJ8CxdoPUjD;

1.71
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	Uu5nFG3wCl0LACBb;

1.70
date	2014.11.28.15.09.50;	author otto;	state Exp;
branches;
next	1.69;
commitid	XycG36fadAFAFnzj;

1.69
date	2014.10.10.08.15.25;	author otto;	state Exp;
branches;
next	1.68;
commitid	nj4mpSZoLV0jWhzi;

1.68
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.67;
commitid	yRuTsAu91VfT3St0;

1.67
date	2014.01.07.14.08.16;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2013.06.03.17.04.35;	author jcs;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.14.16.38.39;	author sobrado;	state Exp;
branches;
next	1.64;

1.64
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.63;

1.63
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.15.12.55.18;	author joris;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.02.19.26.24;	author xsa;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.02.16.21.38;	author xsa;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.09.17.01.38;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2006.04.28.12.30.25;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.25.13.36.36;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.15.19.35.19;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.14.23.29.01;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.14.15.15.20;	author ray;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.14.15.04.36;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.14.15.02.15;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.14.01.11.07;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.13.19.16.15;	author joris;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.10.15.32.26;	author niallo;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.06.10.13.00;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.06.10.04.40;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.30.06.11.03;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.28.09.41.35;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.27.06.13.51;	author pat;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.23.13.28.23;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.20.17.14.47;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.17.08.51.45;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.08.12.34.53;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.07.09.19.11;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.06.15.03.37;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.06.14.47.20;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.25.08.02.26;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.24.10.29.45;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.23.17.08.45;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.23.17.02.59;	author xsa;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.12.27.16.36.03;	author niallo;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.02.09.55.39;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.17.18.03.51;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.28.10.15.07;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.28.09.52.56;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.26.19.07.30;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.26.09.53.35;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.25.17.19.31;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.25.16.08.20;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.24.16.14.15;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.06.13.36.53;	author niallo;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.06.12.56.49;	author joris;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Quiet compiler warnings; as applied to usr.bin/cvs by millert@@

ok millert@@
@
text
@/*	$OpenBSD: rlog.c,v 1.73 2016/08/31 13:09:09 jcs Exp $	*/
/*
 * Copyright (c) 2005, 2009 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2005, 2006 Xavier Santolaria <xsa@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <ctype.h>
#include <err.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

#define RLOG_DATE_LATER		0x01
#define RLOG_DATE_EARLIER	0x02
#define RLOG_DATE_SINGLE	0x04
#define RLOG_DATE_RANGE		0x08
#define RLOG_DATE_INCLUSIVE	0x10

static int	rlog_select_daterev(RCSFILE *, char *);
static void	rlog_file(const char *, RCSFILE *);
static void	rlog_rev_print(struct rcs_delta *);

#define RLOG_OPTSTRING	"d:E:hLl::NqRr::S:s:TtVw::x::z::"

static int dflag, hflag, Lflag, lflag, rflag, tflag, Nflag, wflag;
static char *llist = NULL;
static char *slist = NULL;
static char *wlist = NULL;
static char *revisions = NULL;
static char *rlog_dates = NULL;
static char *revsep = "----------------------------";
static char *revend = "====================================================="
    "========================";

__dead void
rlog_usage(void)
{
	fprintf(stderr,
	    "usage: rlog [-bhLNRtV] [-ddates] [-Eendsep] [-l[lockers]] "
	    "[-r[revs]]\n"
	    "            [-Srevsep] [-sstates] [-w[logins]] [-xsuffixes] "
	    "[-ztz] file ...\n");

	exit(1);
}

int
rlog_main(int argc, char **argv)
{
	RCSFILE *file;
	int Rflag;
	int i, ch, fd, status;
	char fpath[PATH_MAX];

	rcsnum_flags |= RCSNUM_NO_MAGIC;
	hflag = Rflag = rflag = status = 0;
	while ((ch = rcs_getopt(argc, argv, RLOG_OPTSTRING)) != -1) {
		switch (ch) {
		case 'd':
			dflag = 1;
			rlog_dates = rcs_optarg;
			break;
		case 'E':
			revend = rcs_optarg;
			break;
		case 'h':
			hflag = 1;
			break;
		case 'L':
			Lflag = 1;
			break;
		case 'l':
			lflag = 1;
			llist = rcs_optarg;
			break;
		case 'N':
			Nflag = 1;
			break;
		case 'q':
			/*
			 * kept for compatibility
			 */
			break;
		case 'R':
			Rflag = 1;
			break;
		case 'r':
			rflag = 1;
			revisions = rcs_optarg;
			break;
		case 'S':
			revsep = rcs_optarg;
			break;
		case 's':
			slist = rcs_optarg;
			break;
		case 'T':
			/*
			 * kept for compatibility
			 */
			break;
		case 't':
			tflag = 1;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'w':
			wflag = 1;
			wlist = rcs_optarg;
			break;
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			timezone_flag = rcs_optarg;
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (argc == 0) {
		warnx("no input file");
		(usage)();
	}

	if (hflag == 1 && tflag == 1) {
		warnx("warning: -t overrides -h.");
		hflag = 0;
	}

	for (i = 0; i < argc; i++) {
		fd = rcs_choosefile(argv[i], fpath, sizeof(fpath));
		if (fd < 0) {
			warn("%s", fpath);
			status = 1;
			continue;
		}

		if ((file = rcs_open(fpath, fd,
		    RCS_READ|RCS_PARSE_FULLY)) == NULL) {
			status = 1;
			continue;
		}

		if (Lflag == 1 && TAILQ_EMPTY(&(file->rf_locks))) {
			rcs_close(file);
			continue;
		}

		if (Rflag == 1) {
			printf("%s\n", fpath);
			rcs_close(file);
			continue;
		}

		rlog_file(argv[i], file);

		rcs_close(file);
	}

	return (status);
}

static int
rlog_select_daterev(RCSFILE *rcsfile, char *date)
{
	int i, nrev, flags;
	struct rcs_delta *rdp;
	struct rcs_argvector *args;
	char *first, *last, delim;
	time_t firstdate, lastdate, rcsdate;

	nrev = 0;
	args = rcs_strsplit(date, ";");

	for (i = 0; args->argv[i] != NULL; i++) {
		flags = 0;
		firstdate = lastdate = -1;

		first = args->argv[i];
		last = strchr(args->argv[i], '<');
		if (last != NULL) {
			delim = *last;
			*last++ = '\0';

			if (*last == '=') {
				last++;
				flags |= RLOG_DATE_INCLUSIVE;
			}
		} else {
			last = strchr(args->argv[i], '>');
			if (last != NULL) {
				delim = *last;
				*last++ = '\0';

				if (*last == '=') {
					last++;
					flags |= RLOG_DATE_INCLUSIVE;
				}
			}
		}

		if (last == NULL) {
			flags |= RLOG_DATE_SINGLE;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
			delim = '\0';
			last = "\0";
		} else {
			while (*last && isspace((unsigned char)*last))
				last++;
		}

		if (delim == '>' && *last == '\0') {
			flags |= RLOG_DATE_EARLIER;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
		}

		if (delim == '>' && *first == '\0' && *last != '\0') {
			flags |= RLOG_DATE_LATER;
			if ((firstdate = date_parse(last)) == -1)
				return -1;
		}

		if (delim == '<' && *last == '\0') {
			flags |= RLOG_DATE_LATER;
			if ((firstdate = date_parse(first)) == -1)
				return -1;
		}

		if (delim == '<' && *first == '\0' && *last != '\0') {
			flags |= RLOG_DATE_EARLIER;
			if ((firstdate = date_parse(last)) == -1)
				return -1;
		}

		if (*first != '\0' && *last != '\0') {
			flags |= RLOG_DATE_RANGE;

			if (delim == '<') {
				firstdate = date_parse(first);
				lastdate = date_parse(last);
			} else {
				firstdate = date_parse(last);
				lastdate = date_parse(first);
			}
			if (firstdate == -1 || lastdate == -1)
				return -1;
		}

		TAILQ_FOREACH(rdp, &(rcsfile->rf_delta), rd_list) {
			rcsdate = mktime(&(rdp->rd_date));

			if (flags & RLOG_DATE_SINGLE) {
				if (rcsdate <= firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					break;
				}
			}

			if (flags & RLOG_DATE_EARLIER) {
				if (rcsdate < firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & RLOG_DATE_INCLUSIVE &&
				    (rcsdate <= firstdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}

			if (flags & RLOG_DATE_LATER) {
				if (rcsdate > firstdate) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & RLOG_DATE_INCLUSIVE &&
				    (rcsdate >= firstdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}

			if (flags & RLOG_DATE_RANGE) {
				if ((rcsdate > firstdate) &&
				    (rcsdate < lastdate)) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}

				if (flags & RLOG_DATE_INCLUSIVE &&
				    ((rcsdate >= firstdate) &&
				    (rcsdate <= lastdate))) {
					rdp->rd_flags |= RCS_RD_SELECT;
					nrev++;
					continue;
				}
			}
		}
	}

	return (nrev);
}

static void
rlog_file(const char *fname, RCSFILE *file)
{
	char numb[RCS_REV_BUFSZ];
	u_int nrev;
	struct rcs_sym *sym;
	struct rcs_access *acp;
	struct rcs_delta *rdp;
	struct rcs_lock *lkp;
	char *workfile, *p;

	if (rflag == 1)
		nrev = rcs_rev_select(file, revisions);
	else if (dflag == 1) {
		if ((nrev = rlog_select_daterev(file, rlog_dates)) == (u_int)-1)
			errx(1, "invalid date: %s", rlog_dates);
	} else
		nrev = file->rf_ndelta;

	if ((workfile = basename(fname)) == NULL)
		err(1, "basename");

	/*
	 * In case they specified 'foo,v' as argument.
	 */
	if ((p = strrchr(workfile, ',')) != NULL)
		*p = '\0';

	printf("\nRCS file: %s", file->rf_path);
	printf("\nWorking file: %s", workfile);
	printf("\nhead:");
	if (file->rf_head != NULL)
		printf(" %s", rcsnum_tostr(file->rf_head, numb, sizeof(numb)));

	printf("\nbranch:");
	if (rcs_branch_get(file) != NULL) {
		printf(" %s", rcsnum_tostr(rcs_branch_get(file),
		    numb, sizeof(numb)));
	}

	printf("\nlocks: %s", (file->rf_flags & RCS_SLOCK) ? "strict" : "");
	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list)
		printf("\n\t%s: %s", lkp->rl_name,
		    rcsnum_tostr(lkp->rl_num, numb, sizeof(numb)));
	printf("\naccess list:\n");
	TAILQ_FOREACH(acp, &(file->rf_access), ra_list)
		printf("\t%s\n", acp->ra_name);

	if (Nflag == 0) {
		printf("symbolic names:\n");
		TAILQ_FOREACH(sym, &(file->rf_symbols), rs_list) {
			printf("\t%s: %s\n", sym->rs_name,
			    rcsnum_tostr(sym->rs_num, numb, sizeof(numb)));
		}
	}

	printf("keyword substitution: %s\n",
	    file->rf_expand == NULL ? "kv" : file->rf_expand);

	printf("total revisions: %u", file->rf_ndelta);

	if (file->rf_head != NULL && hflag == 0 && tflag == 0)
		printf(";\tselected revisions: %u", nrev);

	printf("\n");


	if (hflag == 0 || tflag == 1)
		printf("description:\n%s", file->rf_desc);

	if (hflag == 0 && tflag == 0 &&
	    !(lflag == 1 && TAILQ_EMPTY(&file->rf_locks))) {
		TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
			/*
			 * if selections are enabled verify that entry is
			 * selected.
			 */
			if ((rflag == 0 && dflag == 0)
			    || (rdp->rd_flags & RCS_RD_SELECT))
				rlog_rev_print(rdp);
		}
	}

	printf("%s\n", revend);
}

static void
rlog_rev_print(struct rcs_delta *rdp)
{
	int i, found;
	struct tm t;
	char *author, numb[RCS_REV_BUFSZ], *fmt, timeb[RCS_TIME_BUFSZ];
	struct rcs_argvector *largv, *sargv, *wargv;
	struct rcs_branch *rb;
	struct rcs_delta *nrdp;

	found = 0;
	author = NULL;

	/* -l[lockers] */
	if (lflag == 1) {
		if (rdp->rd_locker != NULL)
			found++;

		if (llist != NULL) {
			/* if locker is empty, no need to go further. */
			if (rdp->rd_locker == NULL)
				return;
			largv = rcs_strsplit(llist, ",");
			for (i = 0; largv->argv[i] != NULL; i++) {
				if (strcmp(rdp->rd_locker, largv->argv[i])
				    == 0) {
					found++;
					break;
				}
				found = 0;
			}
			rcs_argv_destroy(largv);
		}
	}

	/* -sstates */
	if (slist != NULL) {
		sargv = rcs_strsplit(slist, ",");
		for (i = 0; sargv->argv[i] != NULL; i++) {
			if (strcmp(rdp->rd_state, sargv->argv[i]) == 0) {
				found++;
				break;
			}
			found = 0;
		}
		rcs_argv_destroy(sargv);
	}

	/* -w[logins] */
	if (wflag == 1) {
		if (wlist != NULL) {
			wargv = rcs_strsplit(wlist, ",");
			for (i = 0; wargv->argv[i] != NULL; i++) {
				if (strcmp(rdp->rd_author, wargv->argv[i])
				    == 0) {
					found++;
					break;
				}
				found = 0;
			}
			rcs_argv_destroy(wargv);
		} else {
			if ((author = getlogin()) == NULL)
				err(1, "getlogin");

			if (strcmp(rdp->rd_author, author) == 0)
				found++;
		}
	}

	/* XXX dirty... */
	if ((((slist != NULL && wflag == 1) ||
	    (slist != NULL && lflag == 1) ||
	    (lflag == 1 && wflag == 1)) && found < 2) ||
	    (((slist != NULL && lflag == 1 && wflag == 1) ||
	    (slist != NULL || lflag == 1 || wflag == 1)) && found == 0))
		return;

	printf("%s\n", revsep);

	rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));

	printf("revision %s", numb);
	if (rdp->rd_locker != NULL)
		printf("\tlocked by: %s;", rdp->rd_locker);

	if (timezone_flag != NULL) {
		rcs_set_tz(timezone_flag, rdp, &t);
		fmt = "%Y-%m-%d %H:%M:%S%z";
	} else {
		t = rdp->rd_date;
		fmt = "%Y/%m/%d %H:%M:%S";
	}

	(void)strftime(timeb, sizeof(timeb), fmt, &t);

	printf("\ndate: %s;  author: %s;  state: %s;", timeb, rdp->rd_author,
	    rdp->rd_state);

	/*
	 * If we are a branch revision, the diff of this revision is stored
	 * in place.
	 * Otherwise, it is stored in the previous revision as a reversed diff.
	 */
	if (RCSNUM_ISBRANCHREV(rdp->rd_num))
		nrdp = rdp;
	else
		nrdp = TAILQ_NEXT(rdp, rd_list);

	/*
	 * We do not write diff stats for the first revision of the default
	 * branch, since it was not a diff but a full text.
	 */
	if (nrdp != NULL && rdp->rd_num->rn_len == nrdp->rd_num->rn_len) {
		int added, removed;

		rcs_delta_stats(nrdp, &added, &removed);
		if (RCSNUM_ISBRANCHREV(rdp->rd_num))
			printf("  lines: +%d -%d;", added, removed);
		else
			printf("  lines: +%d -%d;", removed, added);
	}

	if (rdp->rd_commitid != NULL)
		printf("  commitid: %s;", rdp->rd_commitid);

	printf("\n");

	if (!TAILQ_EMPTY(&(rdp->rd_branches))) {
		printf("branches:");
		TAILQ_FOREACH(rb, &(rdp->rd_branches), rb_list) {
			RCSNUM *branch;
			branch = rcsnum_revtobr(rb->rb_num);
			(void)rcsnum_tostr(branch, numb, sizeof(numb));
			printf("  %s;", numb);
			rcsnum_free(branch);
		}
		printf("\n");
	}

	printf("%s", rdp->rd_log);
}
@


1.73
log
@rlog: add -E and -S options to configure revision separators, to
work around commits that might have the default strings in them

ok tom deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.72 2016/08/26 09:02:54 guenther Exp $	*/
d362 1
a362 1
		if ((nrev = rlog_select_daterev(file, rlog_dates)) == -1)
@


1.72
log
@Pull in <time.h> for struct tm, used in rcs.h

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.71 2015/01/16 06:40:11 deraadt Exp $	*/
d50 1
a50 4
#define RLOG_OPTSTRING	"d:hLl::NqRr::s:TtVw::x::z::"
#define REVSEP		"----------------------------"
#define REVEND \
 "============================================================================="
d58 3
d66 4
a69 3
	    "usage: rlog [-bhLNRtV] [-ddates] [-l[lockers]] [-r[revs]]\n"
	    "            [-sstates] [-w[logins]] [-xsuffixes]\n"
	    "            [-ztz] file ...\n");
d90 3
d118 3
d431 1
a431 1
	printf("%s\n", REVEND);
d512 1
a512 1
	printf("%s\n", REVSEP);
@


1.71
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.70 2014/11/28 15:09:50 otto Exp $	*/
d34 1
@


1.70
log
@consistency in calling usage, from Fritjof Bornebusch
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.69 2014/10/10 08:15:25 otto Exp $	*/
d78 1
a78 1
	char fpath[MAXPATHLEN];
@


1.69
log
@Zap some stored values never read; From Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.68 2014/10/02 06:23:15 otto Exp $	*/
d139 1
a139 1
			(usage());
@


1.68
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.67 2014/01/07 14:08:16 deraadt Exp $	*/
d436 1
a436 1
	i = found = 0;
@


1.67
log
@ctype cleanups; ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.66 2013/06/03 17:04:35 jcs Exp $	*/
d61 1
a61 1
void
d68 2
a139 1
			exit(1);
a148 1
		exit(1);
@


1.66
log
@properly handle commitid tokens found in rcs files

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.65 2011/07/14 16:38:39 sobrado Exp $	*/
d235 1
a235 1
			while (*last && isspace(*last))
@


1.65
log
@spacing, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.64 2010/07/30 21:47:18 ray Exp $	*/
d544 1
a544 1
			printf("  lines: +%d -%d", added, removed);
d546 1
a546 1
			printf("  lines: +%d -%d", removed, added);
d548 4
@


1.64
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.63 2010/07/23 21:46:05 ray Exp $	*/
d534 1
a534 1
 	 
d549 1
a549 1
 
@


1.63
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.62 2009/02/15 12:55:18 joris Exp $	*/
d230 2
a231 1
			firstdate = date_parse(first);
d241 2
a242 1
			firstdate = date_parse(first);
d247 2
a248 1
			firstdate = date_parse(last);
d253 2
a254 1
			firstdate = date_parse(first);
d259 2
a260 1
			firstdate = date_parse(last);
d273 2
d353 4
a356 3
	else if (dflag == 1)
		nrev = rlog_select_daterev(file, rlog_dates);
	else
@


1.62
log
@support rlog -d
prodded & tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.61 2008/02/02 19:26:24 xsa Exp $	*/
d230 1
a230 1
			firstdate = rcs_date_parse(first);
d240 1
a240 1
			firstdate = rcs_date_parse(first);
d245 1
a245 1
			firstdate = rcs_date_parse(last);
d250 1
a250 1
			firstdate = rcs_date_parse(first);
d255 1
a255 1
			firstdate = rcs_date_parse(last);
d262 2
a263 2
				firstdate = rcs_date_parse(first);
				lastdate = rcs_date_parse(last);
d265 2
a266 2
				firstdate = rcs_date_parse(last);
				lastdate = rcs_date_parse(first);
@


1.61
log
@Fix broken indentation introduced in last commit.
Spotted by Pierre Riteau.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.60 2008/02/02 16:21:38 xsa Exp $	*/
d3 1
a3 1
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
d28 1
d39 7
d49 1
a49 1
#define RLOG_OPTSTRING	"hLl::NqRr::s:TtVw::x::z::"
d54 1
a54 1
static int hflag, Lflag, lflag, rflag, tflag, Nflag, wflag;
d59 1
d82 4
d189 144
d346 2
d409 2
a410 1
			if (rflag == 0 || (rdp->rd_flags & RCS_RD_SELECT))
@


1.60
log
@From src/usr.bin/cvs:

> add changed lines support to log and rlog (the + and - stuff)
> from Pierre Riteau;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.59 2007/09/09 17:01:38 ray Exp $	*/
d373 1
d379 11
d392 1
a392 12
 
		if (!TAILQ_EMPTY(&(rdp->rd_branches))) {
			printf("branches:");
			TAILQ_FOREACH(rb, &(rdp->rd_branches), rb_list) {
				RCSNUM *branch;
				branch = rcsnum_revtobr(rb->rb_num);
				(void)rcsnum_tostr(branch, numb, sizeof(numb));
				printf("  %s;", numb);
				rcsnum_free(branch);
			}
			printf("\n");
		}
@


1.59
log
@Have rlog exit 1 if any of the files could not be opened.
Don't mention -q flag, which is there for compatibility.

From Pierre Riteau.

OK joris for first part, OK niallo and jmc for second.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.58 2007/06/30 08:23:49 xsa Exp $	*/
d265 2
d352 1
a352 1
	strftime(timeb, sizeof(timeb), fmt, &t);
d354 1
a354 1
	printf("\ndate: %s;  author: %s;  state: %s;\n", timeb, rdp->rd_author,
d356 36
@


1.58
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.57 2007/02/27 07:59:13 xsa Exp $	*/
d56 1
a56 1
	    "usage: rlog [-bhLNqRtV] [-ddates] [-l[lockers]] [-r[revs]]\n"
d66 1
a66 1
	int i, ch, fd;
d70 1
a70 1
	hflag = Rflag = rflag = 0;
d147 1
d152 2
a153 1
		    RCS_READ|RCS_PARSE_FULLY)) == NULL)
d155 1
d173 1
a173 1
	return (0);
@


1.57
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.56 2006/10/12 17:20:12 niallo Exp $	*/
d176 1
a176 1
	char numb[64];
d260 1
a260 1
	char *author, numb[64], *fmt, timeb[64];
@


1.56
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.55 2006/05/27 05:49:14 ray Exp $	*/
d28 6
a33 1
#include "includes.h"
@


1.55
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.54 2006/05/09 12:33:42 ray Exp $	*/
d141 1
a141 1
			warnx("%s", fpath);
@


1.54
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.53 2006/04/28 12:30:25 xsa Exp $	*/
d139 3
a141 2
		fd = rcs_statfile(argv[i], fpath, sizeof(fpath), 0);
		if (fd < 0)
d143 1
@


1.53
log
@fix date format output if a timezone is specified (-z);
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.52 2006/04/26 21:55:22 joris Exp $	*/
a106 1
			/* NOTREACHED */
@


1.52
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.51 2006/04/26 02:55:13 joris Exp $	*/
d335 1
a335 1
		fmt = "%Y/%m/%d %H:%M:%S%z";
@


1.51
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.50 2006/04/25 13:36:36 xsa Exp $	*/
d61 1
a61 1
	int i, ch;
d140 2
a141 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath), 0) < 0)
d144 2
a145 1
		if ((file = rcs_open(fpath, RCS_READ|RCS_PARSE_FULLY)) == NULL)
@


1.50
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.49 2006/04/21 17:17:29 xsa Exp $	*/
d253 1
a253 1
	struct cvs_argvector *largv, *sargv, *wargv;
d267 1
a267 1
			largv = cvs_strsplit(llist, ",");
d276 1
a276 1
			cvs_argv_destroy(largv);
d282 1
a282 1
		sargv = cvs_strsplit(slist, ",");
d290 1
a290 1
		cvs_argv_destroy(sargv);
d296 1
a296 1
			wargv = cvs_strsplit(wlist, ",");
d305 1
a305 1
			cvs_argv_destroy(wargv);
@


1.49
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.48 2006/04/21 14:18:26 xsa Exp $	*/
d182 1
a182 1
		fatal("failed to get basename of '%s'", fname);
d308 1
a308 1
				fatal("getlogin failed");
@


1.48
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.47 2006/04/19 06:53:41 xsa Exp $	*/
d140 1
a140 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
@


1.47
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.46 2006/04/15 19:35:19 xsa Exp $	*/
d129 1
a129 1
		cvs_log(LP_ERR, "no input file");
d135 1
a135 1
		cvs_log(LP_WARN, "warning: -t overrides -h.");
@


1.46
log
@dont stupidly duplicate code. make rlog use rcs_rev_select() and thus
nuke rlog_rev_select(). OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.45 2006/04/14 23:29:01 joris Exp $	*/
d82 3
a84 1
			verbose = 0;
@


1.45
log
@- don't append the extension if it's already there (PR 5076).
- show magic branches in rlog (thanks for that nicer hack niall).
- correct output in rcsdiff, so we perfectly match gnu's

all these bugs were found by sturm@@ while he was using cvsweb
(which uses the RCS tools).

"it is in my view that you should put it in" niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.44 2006/04/14 15:15:20 ray Exp $	*/
a34 1
static u_int	rlog_rev_select(RCSFILE *);
d175 1
a175 1
		nrev = rlog_rev_select(file);
a342 75
}

static u_int
rlog_rev_select(RCSFILE *file)
{
	int i;
	u_int nrev;
	char *ep;
	char *lstr, *rstr;
	struct rcs_delta *rdp;
	struct cvs_argvector *revargv, *revrange;
	RCSNUM lnum, rnum;

	nrev = 0;
	(void)memset(&lnum, 0, sizeof(lnum));
	(void)memset(&rnum, 0, sizeof(rnum));

	if (revisions == NULL) {
		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, file->rf_head, 0) == 0) {
				rdp->rd_flags |= RCS_RD_SELECT;
				return (1);
			}
		return (0);
	}

	revargv = cvs_strsplit(revisions, ",");
	for (i = 0; revargv->argv[i] != NULL; i++) {
		revrange = cvs_strsplit(revargv->argv[i], ":");
		if (revrange->argv[0] == NULL)
			/* should not happen */
			fatal("invalid revision range: %s", revargv->argv[i]);
		else if (revrange->argv[1] == NULL)
			lstr = rstr = revrange->argv[0];
		else {
			if (revrange->argv[2] != NULL)
				fatal("invalid revision range: %s",
					revargv->argv[i]);
			lstr = revrange->argv[0];
			rstr = revrange->argv[1];
			if (strcmp(lstr, "") == 0)
				lstr = NULL;
			if (strcmp(rstr, "") == 0)
				rstr = NULL;
		}

		if (lstr == NULL)
			lstr = RCS_HEAD_INIT;
		if (rcsnum_aton(lstr, &ep, &lnum) == 0 || (*ep != '\0'))
			fatal("invalid revision: %s", lstr);

		if (rstr != NULL) {
			if (rcsnum_aton(rstr, &ep, &rnum) == 0 || (*ep != '\0'))
				fatal("invalid revision: %s", rstr);
		} else
			rcsnum_cpy(file->rf_head, &rnum, 0);

		cvs_argv_destroy(revrange);

		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, &lnum, 0) <= 0 &&
			    rcsnum_cmp(rdp->rd_num, &rnum, 0) >= 0 &&
			    !(rdp->rd_flags & RCS_RD_SELECT)) {
				rdp->rd_flags |= RCS_RD_SELECT;
				nrev++;
			}
	}
	cvs_argv_destroy(revargv);

	if (lnum.rn_id != NULL)
		xfree(lnum.rn_id);
	if (rnum.rn_id != NULL)
		xfree(rnum.rn_id);

	return (nrev);
@


1.44
log
@Remove global variable RCSFILE.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.43 2006/04/14 15:04:36 ray Exp $	*/
d65 1
d173 1
d180 9
d190 1
a190 1
	printf("\nWorking file: %s", fname);
@


1.43
log
@Remove extraneous argument from rlog_file().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.42 2006/04/14 15:02:15 ray Exp $	*/
d33 1
a33 1
static void	rlog_file(const char *);
d35 1
a35 1
static u_int	rlog_rev_select(void);
a46 1
static RCSFILE *file;
d60 1
d155 1
a155 1
		rlog_file(argv[i]);
d164 1
a164 1
rlog_file(const char *fname)
d174 1
a174 1
		nrev = rlog_rev_select();
d336 1
a336 1
rlog_rev_select(void)
@


1.42
log
@Short-circuit rlog when the -l flag is specified but there are no locks.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.41 2006/04/14 01:11:07 deraadt Exp $	*/
d33 1
a33 1
static void	rlog_file(const char *, const char *);
d155 1
a155 1
		rlog_file(argv[i], fpath);
d164 1
a164 1
rlog_file(const char *fname, const char *fpath)
d178 1
a178 1
	printf("\nRCS file: %s", fpath);
@


1.41
log
@excessive addition to brackets is a mental disease.  you will go
blind, too.  seek help.  no binary change, ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.40 2006/04/13 19:16:15 joris Exp $	*/
d220 2
a221 1
	if (hflag == 0 && tflag == 0) {
d248 2
a249 6
		/* if no locks at all, abort. */
		if (TAILQ_EMPTY(&(file->rf_locks)))
			return;
		else
			if (rdp->rd_locker != NULL)
				found++;
@


1.40
log
@fix -z option for openrcs, this was broken by xsa
when he yanked the code out of rcs.c and placed it in rcstime.c.

	struct tm ltb, *tb;
	tb = &ltb;
	return (tb);

isn't really the most perfect idiom to return a value to the caller, now is it?

as a bonus -z for rlog now works too.
okay niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.39 2006/04/10 15:32:26 niallo Exp $	*/
d132 1
a132 1
	if ((hflag == 1) && (tflag == 1)) {
d144 1
a144 1
		if ((Lflag == 1) && (TAILQ_EMPTY(&(file->rf_locks)))) {
d211 1
a211 1
	if ((file->rf_head != NULL) && (hflag == 0) && (tflag == 0))
d217 1
a217 1
	if ((hflag == 0) || (tflag == 1))
d220 1
a220 1
	if ((hflag == 0) && (tflag == 0)) {
d226 1
a226 1
			if ((rflag == 0) || (rdp->rd_flags & RCS_RD_SELECT))
d307 5
a311 5
	if (((((slist != NULL) && (wflag == 1)) ||
	    ((slist != NULL) && (lflag == 1)) ||
	    ((lflag == 1) && (wflag == 1))) && (found < 2)) ||
	    ((((slist != NULL) && (lflag == 1) && (wflag == 1)) ||
	    ((slist != NULL) || (lflag == 1) || (wflag == 1))) && (found == 0)))
d333 1
a333 1
	    rdp->rd_state); 
d396 2
a397 2
			if ((rcsnum_cmp(rdp->rd_num, &lnum, 0) <= 0) &&
			    (rcsnum_cmp(rdp->rd_num, &rnum, 0) >= 0) &&
@


1.39
log
@- zap some whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.38 2006/04/06 10:13:00 xsa Exp $	*/
d238 2
a239 1
	char *author, numb[64];
d270 1
d283 1
d321 14
a334 7
	printf("\ndate: %d/%02d/%02d %02d:%02d:%02d;"
	    "  author: %s;  state: %s;\n",
	    rdp->rd_date.tm_year + 1900,
	    rdp->rd_date.tm_mon + 1,
	    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
	    rdp->rd_date.tm_min, rdp->rd_date.tm_sec,
	    rdp->rd_author, rdp->rd_state);
@


1.38
log
@-z can take no argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.37 2006/04/06 10:04:40 xsa Exp $	*/
d224 1
a224 1
			 * selected. 
d266 1
a266 1
			cvs_argv_destroy(largv);	
d279 1
a279 1
		cvs_argv_destroy(sargv);	
d293 1
a293 1
			cvs_argv_destroy(wargv);	
d362 1
a362 1
				fatal("invalid revision range: %s", 
d393 1
a393 1
	cvs_argv_destroy(revargv);	
@


1.37
log
@small knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.36 2006/03/30 06:11:03 ray Exp $	*/
d37 1
a37 1
#define RLOG_OPTSTRING	"hLl::NqRr::s:TtVw::x::z:"
@


1.36
log
@Add rlog -r[REV1][:][REV2] support

From Pierre-Yves Ritschard.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.35 2006/03/28 09:41:35 xsa Exp $	*/
d84 3
a90 3
		case 'R':
			Rflag = 1;
			break;
d358 1
a358 1
		else if (revrange->argv[1] == NULL) {
d360 1
a360 1
		} else {
d366 1
a366 1
			if (strcmp(lstr, "") == 0) {
d368 1
a368 2
			}
			if (strcmp(rstr, "") == 0) {
a369 1
			}
d381 2
a382 1
			(void)rcsnum_cpy(file->rf_head, &rnum, 0);
@


1.35
log
@match GNU's output when no revision are present.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.34 2006/03/27 06:13:51 pat Exp $	*/
d35 1
d37 1
d42 1
a42 1
static int hflag, Lflag, lflag, tflag, Nflag, wflag;
d46 1
d65 2
a66 2
	hflag = Rflag = 0;
	while ((ch = rcs_getopt(argc, argv, "hLl::NqRs:TtVw::x::z:")) != -1) {
d84 4
d167 1
d173 5
d212 1
a212 1
		printf(";\tselected revisions:"); /* XXX */
d221 8
a228 2
		TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list)
			rlog_rev_print(rdp);
d326 76
@


1.34
log
@Plug a memory leak for all cvs_strsplit call sites; ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.33 2006/03/24 05:14:48 ray Exp $	*/
d198 1
a198 1
	if ((hflag == 0) && (tflag == 0))
@


1.33
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.32 2006/03/23 13:28:23 xsa Exp $	*/
d220 1
a220 1
	char **largv, **sargv, **wargv;
d239 3
a241 2
			for (i = 0; largv[i] != NULL; i++) {
				if (strcmp(rdp->rd_locker, largv[i]) == 0) {
d247 1
a247 1
			xfree(largv);
d253 2
a254 2
		for (i = 0; sargv[i] != NULL; i++) {
			if (strcmp(rdp->rd_state, sargv[i]) == 0) {
d260 1
a260 1
		xfree(sargv);
d266 3
a268 2
			for (i = 0; wargv[i] != NULL; i++) {
				if (strcmp(rdp->rd_author, wargv[i]) == 0) {
d274 1
a274 1
			xfree(wargv);
@


1.32
log
@rlog_file() will never return non-zero; change its return type to void.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.31 2006/03/20 17:14:47 xsa Exp $	*/
d63 1
a63 1
	while ((ch = rcs_getopt(argc, argv, "hLl::NqRs:TtVw::x:z:")) != -1) {
d104 2
a105 1
			rcs_suffixes = rcs_optarg;
@


1.31
log
@add missing xfree()'s after we are done with cvs_strsplit();
spotted by ray@@, OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.30 2006/03/17 08:51:45 xsa Exp $	*/
d33 2
a34 2
static int	  rlog_file(const char *, const char *);
static void	  rlog_rev_print(struct rcs_delta *);
d155 1
a155 1
static int
a211 1
	return (0);
@


1.30
log
@rlog_strsplit() -> cvs_strsplit() and move it to util.c so it can be reused
by `cvs log' and some other RCS utilities. "Looks good" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.29 2006/03/16 04:04:57 ray Exp $	*/
d246 1
d259 1
d272 1
@


1.29
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.28 2006/03/08 12:34:53 xsa Exp $	*/
a34 1
static char	**rlog_strsplit(char *, const char *);
d238 1
a238 1
			largv = rlog_strsplit(llist, ",");
d250 1
a250 1
		sargv = rlog_strsplit(slist, ",");
d262 1
a262 1
			wargv = rlog_strsplit(wlist, ",");
a301 26
}

/*
 * rlog_strsplit()
 *
 * Split a string <str> of <sep>-separated values and allocate
 * an argument vector for the values found.
 */
static char **
rlog_strsplit(char *str, const char *sep)
{
	char **argv, **nargv;
	char *cp, *p;
	int i = 0;

	cp = xstrdup(str);
	argv = (char **)xmalloc((i+1) * sizeof(char *));

	while ((p = strsep(&cp, sep)) != NULL) {
		argv[i++] = p;
		nargv = (char **)xrealloc((void *)argv, (i+1) * sizeof(char *));
		argv = nargv;
	}
	argv[i] = NULL;

	return (argv);
@


1.28
log
@fix usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.27 2006/03/07 09:19:11 xsa Exp $	*/
d99 1
@


1.27
log
@missing break;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.26 2006/03/07 01:40:52 joris Exp $	*/
d52 2
a53 2
	    "		[-sstates] [-w[logins]] [-xsuffixes]\n"
	    "		[-ztz] file ...\n");
@


1.26
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.25 2006/03/06 15:03:37 jmc Exp $	*/
d108 1
@


1.25
log
@update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.24 2006/03/06 14:47:20 jmc Exp $	*/
d64 1
a64 1
	while ((ch = rcs_getopt(argc, argv, "hLl::NqRs:TtVw::x:")) != -1) {
d106 2
@


1.24
log
@move compat flags into a STANDARDS section;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.23 2006/01/25 08:02:26 xsa Exp $	*/
d51 3
a53 2
	    "usage: rlog [-hLNqRtV] [-l[lockers]] [-sstates] [-w[logins]]\n"
	    "            [-xsuffixes] file ...\n");
@


1.23
log
@add support for `-l[lockers]'. Some (needed) cleanup will follow.
Test & OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.22 2006/01/24 10:29:45 xsa Exp $	*/
d51 1
a51 1
	    "usage: rlog [-hLNqRTtV] [-l[lockers]] [-sstates] [-w[logins]]\n"
@


1.22
log
@print locker's name if revision is locked;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.21 2006/01/23 17:08:45 xsa Exp $	*/
d33 1
a33 1
static int	  rlog_file(const char *, const char *, RCSFILE *);
d41 2
a42 1
static int hflag, Lflag, tflag, Nflag, wflag;
d45 1
d51 2
a52 2
	    "usage: rlog [-hLNqRTtV] [-sstates] [-w[logins]] "
	    "[-xsuffixes] file ...\n");
a60 1
	RCSFILE *file;
d63 1
a63 1
	while ((ch = rcs_getopt(argc, argv, "hLNqRs:TtVw::x:")) != -1) {
d71 4
d143 1
a143 1
		rlog_file(argv[i], fpath, file);
d152 1
a152 1
rlog_file(const char *fname, const char *fpath, RCSFILE *file)
d216 1
a216 1
	char **sargv, **wargv;
d221 23
d276 5
a280 2
	if ((((slist != NULL) && (wflag == 1)) && (found < 2)) ||
	    (((slist != NULL) || (wflag == 1)) && (found == 0)))
@


1.21
log
@display usage if an unknown option is specified;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.20 2006/01/23 17:02:59 xsa Exp $	*/
d256 4
a259 2
	printf("revision %s\n", numb);
	printf("date: %d/%02d/%02d %02d:%02d:%02d;"
@


1.20
log
@add support for `-sstates' and `-w[logins]' options; tested and OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.19 2006/01/05 10:28:24 xsa Exp $	*/
d45 8
d101 2
a102 1
			break;
a143 8
}

void
rlog_usage(void)
{
	fprintf(stderr,
	    "usage: rlog [-hLNqRTtV] [-sstates] [-w[logins]] "
	    "[-xsuffixes] file ...\n");
@


1.19
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.18 2006/01/02 08:13:28 xsa Exp $	*/
d4 1
d33 3
a35 2
static int	rlog_file(const char *, const char *, RCSFILE *);
static void	rlog_rev_print(RCSFILE *);
d41 3
a43 4
static int hflag;
static int Lflag;
static int tflag;
static int Nflag;
d54 1
a54 1
	while ((ch = rcs_getopt(argc, argv, "hLNqRTtVx:")) != -1) {
d71 3
d85 4
d141 2
a142 1
	    "usage: rlog [-hLNqRTtV] [-xsuffixes] file ...\n");
d151 1
d185 7
a191 1
	printf("total revisions: %u\n", file->rf_ndelta);
d196 4
a199 2
	if ((hflag == 0) && (tflag == 0))
		rlog_rev_print(file);
d206 1
a206 1
rlog_rev_print(RCSFILE *file)
d208 32
a239 2
	char numb[64];
	struct rcs_delta *rdp;
d241 4
a244 2
	TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
		printf("%s\n", REVSEP);
d246 19
a264 1
		rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));
d266 20
a285 9
		printf("revision %s\n", numb);
		printf("date: %d/%02d/%02d %02d:%02d:%02d;"
		    "  author: %s;  state: %s;\n",
		    rdp->rd_date.tm_year + 1900,
		    rdp->rd_date.tm_mon + 1,
		    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
		    rdp->rd_date.tm_min, rdp->rd_date.tm_sec,
		    rdp->rd_author, rdp->rd_state);
		printf("%s", rdp->rd_log);
d287 3
@


1.18
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.17 2005/12/27 16:36:03 niallo Exp $	*/
d29 1
a29 2
#include "log.h"
#include "rcs.h"
a30 1
#include "rcsprog.h"
@


1.17
log
@- rlog(1) needs RCS_PARSE_FULLY too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.16 2005/12/02 09:55:39 xsa Exp $	*/
d27 1
a27 8
#include <sys/param.h>
#include <sys/stat.h>

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.16
log
@split the printing part into a separate function, rlog_rev_print();
might be useful for future work needed in rlog(1);
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.15 2005/11/28 14:43:59 xsa Exp $	*/
d116 1
a116 1
		if ((file = rcs_open(fpath, RCS_READ)) == NULL)
@


1.15
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.14 2005/11/21 16:20:29 xsa Exp $	*/
d41 2
a42 1
static int rlog_file(const char *, const char *, RCSFILE *);
a149 1
	struct rcs_delta *rdp;
d189 2
a190 14
	if ((hflag == 0) && (tflag == 0)) {
		TAILQ_FOREACH(rdp, &(file->rf_delta), rd_list) {
			rcsnum_tostr(rdp->rd_num, numb, sizeof(numb));
			printf("%s\nrevision %s\n", REVSEP, numb);
			printf("date: %d/%02d/%02d %02d:%02d:%02d;"
			    "  author: %s;  state: %s;\n",
			    rdp->rd_date.tm_year + 1900,
			    rdp->rd_date.tm_mon + 1,
			    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
			    rdp->rd_date.tm_min, rdp->rd_date.tm_sec,
			    rdp->rd_author, rdp->rd_state);
			printf("%s", rdp->rd_log);
		}
	}
d194 23
@


1.14
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.13 2005/11/17 18:03:51 xsa Exp $	*/
d141 1
a141 1
	    "usage: rlog [-hLNqRTtV] file ...\n");
@


1.13
log
@indent;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.12 2005/10/28 10:15:07 xsa Exp $	*/
d61 1
a61 1
	while ((ch = rcs_getopt(argc, argv, "hLNqRTtV")) != -1) {
d89 3
@


1.12
log
@print RCS file info too;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.11 2005/10/28 09:52:56 xsa Exp $	*/
d184 1
a184 1
	printf("description:\n%s", file->rf_desc);
@


1.11
log
@add support for `-L'; niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.10 2005/10/26 19:07:30 xsa Exp $	*/
d150 1
@


1.10
log
@print locker's name and rev number for locked revisions; ok joris niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.9 2005/10/26 09:53:35 xsa Exp $	*/
d48 1
d61 1
a61 1
	while ((ch = rcs_getopt(argc, argv, "hNqRTtV")) != -1) {
d66 3
d112 8
d122 1
a125 3
		if ((file = rcs_open(fpath, RCS_READ)) == NULL)
			continue;

d138 1
a138 1
	    "usage: rlog [-hNqRTtV] file ...\n");
@


1.9
log
@correct -R behaviour;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.8 2005/10/25 17:19:31 xsa Exp $	*/
d138 1
d152 3
@


1.8
log
@-T is kept for compatibility with other RCS commands here too;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.7 2005/10/25 16:08:20 xsa Exp $	*/
d108 5
d116 2
a117 2
		if (Rflag == 0)
			rlog_file(argv[i], fpath, file);
@


1.7
log
@missed that in previous commit;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.6 2005/10/24 16:14:15 xsa Exp $	*/
d60 1
a60 1
	while ((ch = rcs_getopt(argc, argv, "hNqRtV")) != -1) {
d74 5
d123 1
a123 1
	    "usage: rlog [-hNqRtV] file ...\n");
@


1.6
log
@output tweaks;
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.5 2005/10/13 12:35:30 joris Exp $	*/
d94 1
a94 1
	if ((hflag == 1) && (tflag == 1))
d96 2
@


1.5
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.4 2005/10/12 17:13:30 deraadt Exp $	*/
d45 1
a45 1
 "============================================================================"
d94 3
d127 1
a127 1
	printf("Working file: %s", fname);
d157 1
a157 1
	printf("description: %s\n", file->rf_desc);
@


1.4
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.3 2005/10/07 23:59:56 niallo Exp $	*/
d60 1
a60 1
	while ((ch = getopt(argc, argv, "hNqRtV")) != -1) {
d85 2
a86 2
	argc -= optind;
	argv += optind;
@


1.3
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.2 2005/10/06 13:36:53 niallo Exp $	*/
a40 1
extern char *__progname;
d112 2
a113 1
	fprintf(stderr, "usage %s [-hNqRtV] file ...\n", __progname);
@


1.2
log
@sync rlog_usage() with reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: rlog.c,v 1.1 2005/10/06 12:56:49 joris Exp $	*/
a35 1
#include "diff.h"
d38 1
@


1.1
log
@support rlog command;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.3 2005/10/06 11:46:03 joris Exp $	*/
d113 1
a113 1
	fprintf(stderr, "usage %s [-qV] file ...\n", __progname);
@

