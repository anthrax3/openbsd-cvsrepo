head	1.46;
access;
symbols
	OPENBSD_6_1:1.45.0.6
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.10
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.8
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.6
	OPENBSD_5_0:1.38.0.4
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.35.0.2
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.33.0.6
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18;
locks; strict;
comment	@ * @;


1.46
date	2017.08.29.16.47.33;	author otto;	state Exp;
branches;
next	1.45;
commitid	H6vFKnpT8IoXUPyV;

1.45
date	2016.07.04.01.39.12;	author millert;	state Exp;
branches;
next	1.44;
commitid	9iBcbXzctTwjd6fC;

1.44
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.43;
commitid	FFUg8uzT5GNAfRXp;

1.43
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	Uu5nFG3wCl0LACBb;

1.42
date	2014.12.01.21.58.46;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Z3HC5pAWzpo5jsTe;

1.41
date	2014.10.10.08.15.25;	author otto;	state Exp;
branches;
next	1.40;
commitid	nj4mpSZoLV0jWhzi;

1.40
date	2014.05.29.16.39.42;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.16.20.24.45;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.06.22.52.55;	author chl;	state Exp;
branches;
next	1.37;

1.37
date	2010.10.20.19.53.53;	author tobias;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.08.15.15.50;	author tobias;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.10.20.23.24;	author joris;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.04.13.45.24;	author chl;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.19.06.37.58;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.22.19.11.13;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.22.08.30.45;	author xsa;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.11.18.13.33;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.10.02.13.23;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.02.16.43.45;	author niallo;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.09.21.47.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.21;

1.21
date	2006.09.25.23.58.05;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.22.05.38.29;	author niallo;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.19.05.52.23;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.16.07.39.15;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.08.09.14.03;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.04.22.14.56;	author niallo;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.23.16.31;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.27.08.12.29;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.27.02.58.02;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.09.12.31.27;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.08.21.55.39;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.27.07.59.33;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.25.13.55.49;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.25.13.36.36;	author xsa;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.24.04.51.57;	author ray;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	;


desc
@@


1.46
log
@kill const and string artithmetic related warnings; ok millert@@
@
text
@/*	$OpenBSD: rcsutil.c,v 1.45 2016/07/04 01:39:12 millert Exp $	*/
/*
 * Copyright (c) 2005, 2006 Joris Vink <joris@@openbsd.org>
 * Copyright (c) 2006 Xavier Santolaria <xsa@@openbsd.org>
 * Copyright (c) 2006 Niall O'Higgins <niallo@@openbsd.org>
 * Copyright (c) 2006 Ray Lai <ray@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <ctype.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcsprog.h"

/*
 * rcs_get_mtime()
 *
 * Get <filename> last modified time.
 * Returns last modified time on success, or -1 on failure.
 */
time_t
rcs_get_mtime(RCSFILE *file)
{
	struct stat st;
	time_t mtime;

	if (file->rf_file == NULL)
		return (-1);

	if (fstat(fileno(file->rf_file), &st) == -1) {
		warn("%s", file->rf_path);
		return (-1);
	}

	mtime = st.st_mtimespec.tv_sec;

	return (mtime);
}

/*
 * rcs_set_mtime()
 *
 * Set <filename> last modified time to <mtime> if it's not set to -1.
 */
void
rcs_set_mtime(RCSFILE *file, time_t mtime)
{
	static struct timeval tv[2];

	if (file->rf_file == NULL || mtime == -1)
		return;

	tv[0].tv_sec = mtime;
	tv[1].tv_sec = tv[0].tv_sec;

	if (futimes(fileno(file->rf_file), tv) == -1)
		err(1, "utimes");
}

int
rcs_getopt(int argc, char **argv, const char *optstr)
{
	char *a;
	const char *c;
	static int i = 1;
	int opt, hasargument, ret;

	hasargument = 0;
	rcs_optarg = NULL;

	if (i >= argc)
		return (-1);

	a = argv[i++];
	if (*a++ != '-')
		return (-1);

	ret = 0;
	opt = *a;
	for (c = optstr; *c != '\0'; c++) {
		if (*c == opt) {
			a++;
			ret = opt;

			if (*(c + 1) == ':') {
				if (*(c + 2) == ':') {
					if (*a != '\0')
						hasargument = 1;
				} else {
					if (*a != '\0') {
						hasargument = 1;
					} else {
						ret = 1;
						break;
					}
				}
			}

			if (hasargument == 1)
				rcs_optarg = a;

			if (ret == opt)
				rcs_optind++;
			break;
		}
	}

	if (ret == 0)
		warnx("unknown option -%c", opt);
	else if (ret == 1)
		warnx("missing argument for option -%c", opt);

	return (ret);
}

/*
 * rcs_choosefile()
 *
 * Given a relative filename, decide where the corresponding RCS file
 * should be.  Tries each extension until a file is found.  If no file
 * was found, returns a path with the first extension.
 *
 * Opens and returns file descriptor to RCS file.
 */
int
rcs_choosefile(const char *filename, char *out, size_t len)
{
	int fd;
	struct stat sb;
	char *p, *ext, name[PATH_MAX], *next, *ptr, rcsdir[PATH_MAX],
	    *suffixes, rcspath[PATH_MAX];

	/*
	 * If `filename' contains a directory, `rcspath' contains that
	 * directory, including a trailing slash.  Otherwise `rcspath'
	 * contains an empty string.
	 */
	if (strlcpy(rcspath, filename, sizeof(rcspath)) >= sizeof(rcspath))
		errx(1, "rcs_choosefile: truncation");

	/* If `/' is found, end string after `/'. */
	if ((ptr = strrchr(rcspath, '/')) != NULL)
		*(++ptr) = '\0';
	else
		rcspath[0] = '\0';

	/* Append RCS/ to `rcspath' if it exists. */
	if (strlcpy(rcsdir, rcspath, sizeof(rcsdir)) >= sizeof(rcsdir) ||
	    strlcat(rcsdir, RCSDIR, sizeof(rcsdir)) >= sizeof(rcsdir))
		errx(1, "rcs_choosefile: truncation");

	if (stat(rcsdir, &sb) == 0 && S_ISDIR(sb.st_mode))
		if (strlcpy(rcspath, rcsdir, sizeof(rcspath))
		    >= sizeof(rcspath) ||
		    strlcat(rcspath, "/", sizeof(rcspath)) >= sizeof(rcspath))
			errx(1, "rcs_choosefile: truncation");

	/* Name of file without path. */
	if ((ptr = strrchr(filename, '/')) == NULL) {
		if (strlcpy(name, filename, sizeof(name)) >= sizeof(name))
			errx(1, "rcs_choosefile: truncation");
	} else {
		/* Skip `/'. */
		if (strlcpy(name, ptr + 1, sizeof(name)) >= sizeof(name))
			errx(1, "rcs_choosefile: truncation");
	}

	/* Name of RCS file without an extension. */
	if (strlcat(rcspath, name, sizeof(rcspath)) >= sizeof(rcspath))
		errx(1, "rcs_choosefile: truncation");

	/*
	 * If only the empty suffix was given, use existing rcspath.
	 * This ensures that there is at least one suffix for strsep().
	 */
	if (strcmp(rcs_suffixes, "") == 0) {
		if (strlcpy(out, rcspath, len) >= len)
			errx(1, "rcs_choosefile: truncation");
		fd = open(rcspath, O_RDONLY);
		return (fd);
	}

	/*
	 * Cycle through slash-separated `rcs_suffixes', appending each
	 * extension to `rcspath' and testing if the file exists.  If it
	 * does, return that string.  Otherwise return path with first
	 * extension.
	 */
	suffixes = xstrdup(rcs_suffixes);
	for (next = suffixes; (ext = strsep(&next, "/")) != NULL;) {
		char fpath[PATH_MAX];

		if ((p = strrchr(rcspath, ',')) != NULL) {
			if (!strcmp(p, ext)) {
				if ((fd = open(rcspath, O_RDONLY)) == -1)
					continue;

				if (fstat(fd, &sb) == -1)
					err(1, "%s", rcspath);

				if (strlcpy(out, rcspath, len) >= len)
					errx(1, "rcs_choosefile; truncation");

				free(suffixes);
				return (fd);
			}

			continue;
		}

		/* Construct RCS file path. */
		if (strlcpy(fpath, rcspath, sizeof(fpath)) >= sizeof(fpath) ||
		    strlcat(fpath, ext, sizeof(fpath)) >= sizeof(fpath))
			errx(1, "rcs_choosefile: truncation");

		/* Don't use `filename' as RCS file. */
		if (strcmp(fpath, filename) == 0)
			continue;

		if ((fd = open(fpath, O_RDONLY)) == -1)
			continue;

		if (fstat(fd, &sb) == -1)
			err(1, "%s", fpath);

		if (strlcpy(out, fpath, len) >= len)
			errx(1, "rcs_choosefile: truncation");

		free(suffixes);
		return (fd);
	}

	/*
	 * `suffixes' should now be NUL separated, so the first
	 * extension can be read just by reading `suffixes'.
	 */
	if (strlcat(rcspath, suffixes, sizeof(rcspath)) >= sizeof(rcspath))
		errx(1, "rcs_choosefile: truncation");

	free(suffixes);

	if (strlcpy(out, rcspath, len) >= len)
		errx(1, "rcs_choosefile: truncation");

	fd = open(rcspath, O_RDONLY);

	return (fd);
}

/*
 * Set <str> to <new_str>.  Print warning if <str> is redefined.
 */
void
rcs_setrevstr(char **str, char *new_str)
{
	if (new_str == NULL)
		return;
	if (*str != NULL)
		warnx("redefinition of revision number");
	*str = new_str;
}

/*
 * Set <str1> or <str2> to <new_str>, depending on which is not set.
 * If both are set, error out.
 */
void
rcs_setrevstr2(char **str1, char **str2, char *new_str)
{
	if (new_str == NULL)
		return;
	if (*str1 == NULL)
		*str1 = new_str;
	else if (*str2 == NULL)
		*str2 = new_str;
	else
		errx(1, "too many revision numbers");
}

/*
 * Get revision from file.  The revision can be specified as a symbol or
 * a revision number.
 */
RCSNUM *
rcs_getrevnum(const char *rev_str, RCSFILE *file)
{
	RCSNUM *rev;

	/* Search for symbol. */
	rev = rcs_sym_getrev(file, rev_str);

	/* Search for revision number. */
	if (rev == NULL)
		rev = rcsnum_parse(rev_str);

	return (rev);
}

/*
 * Prompt for and store user's input in an allocated string.
 *
 * Returns the string's pointer.
 */
char *
rcs_prompt(const char *prompt, int flags)
{
	BUF *bp;
	size_t len;
	char *buf;

	if (!(flags & INTERACTIVE) && isatty(STDIN_FILENO))
		flags |= INTERACTIVE;

	bp = buf_alloc(0);
	if (flags & INTERACTIVE)
		(void)fprintf(stderr, "%s", prompt);
	if (flags & INTERACTIVE)
		(void)fprintf(stderr, ">> ");
	clearerr(stdin);
	while ((buf = fgetln(stdin, &len)) != NULL) {
		/* The last line may not be EOL terminated. */
		if (buf[0] == '.' && (len == 1 || buf[1] == '\n'))
			break;
		else
			buf_append(bp, buf, len);

		if (flags & INTERACTIVE)
			(void)fprintf(stderr, ">> ");
	}
	buf_putc(bp, '\0');

	return (buf_release(bp));
}

u_int
rcs_rev_select(RCSFILE *file, const char *range)
{
	int i;
	u_int nrev;
	const char *ep;
	char *lstr, *rstr;
	struct rcs_delta *rdp;
	struct rcs_argvector *revargv, *revrange;
	RCSNUM lnum, rnum;

	nrev = 0;
	(void)memset(&lnum, 0, sizeof(lnum));
	(void)memset(&rnum, 0, sizeof(rnum));

	if (range == NULL) {
		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, file->rf_head, 0) == 0) {
				rdp->rd_flags |= RCS_RD_SELECT;
				return (1);
			}
		return (0);
	}

	revargv = rcs_strsplit(range, ",");
	for (i = 0; revargv->argv[i] != NULL; i++) {
		revrange = rcs_strsplit(revargv->argv[i], ":");
		if (revrange->argv[0] == NULL)
			/* should not happen */
			errx(1, "invalid revision range: %s", revargv->argv[i]);
		else if (revrange->argv[1] == NULL)
			lstr = rstr = revrange->argv[0];
		else {
			if (revrange->argv[2] != NULL)
				errx(1, "invalid revision range: %s",
				    revargv->argv[i]);
			lstr = revrange->argv[0];
			rstr = revrange->argv[1];
			if (strcmp(lstr, "") == 0)
				lstr = NULL;
			if (strcmp(rstr, "") == 0)
				rstr = NULL;
		}

		if (lstr == NULL)
			lstr = RCS_HEAD_INIT;
		if (rcsnum_aton(lstr, &ep, &lnum) == 0 || (*ep != '\0'))
			errx(1, "invalid revision: %s", lstr);

		if (rstr != NULL) {
			if (rcsnum_aton(rstr, &ep, &rnum) == 0 || (*ep != '\0'))
				errx(1, "invalid revision: %s", rstr);
		} else
			rcsnum_cpy(file->rf_head, &rnum, 0);

		rcs_argv_destroy(revrange);

		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list)
			if (rcsnum_cmp(rdp->rd_num, &lnum, 0) <= 0 &&
			    rcsnum_cmp(rdp->rd_num, &rnum, 0) >= 0 &&
			    !(rdp->rd_flags & RCS_RD_SELECT)) {
				rdp->rd_flags |= RCS_RD_SELECT;
				nrev++;
			}
	}
	rcs_argv_destroy(revargv);

	free(lnum.rn_id);
	free(rnum.rn_id);

	return (nrev);
}

/*
 * Load description from <in> to <file>.
 * If <in> starts with a `-', <in> is taken as the description.
 * Otherwise <in> is the name of the file containing the description.
 * If <in> is NULL, the description is read from stdin.
 * Returns 0 on success, -1 on failure, setting errno.
 */
int
rcs_set_description(RCSFILE *file, const char *in, int flags)
{
	BUF *bp;
	char *content;
	const char *prompt =
	    "enter description, terminated with single '.' or end of file:\n"
	    "NOTE: This is NOT the log message!\n";

	/* Description is in file <in>. */
	if (in != NULL && *in != '-') {
		if ((bp = buf_load(in)) == NULL)
			return (-1);
		buf_putc(bp, '\0');
		content = buf_release(bp);
	/* Description is in <in>. */
	} else if (in != NULL)
		/* Skip leading `-'. */
		content = xstrdup(in + 1);
	/* Get description from stdin. */
	else
		content = rcs_prompt(prompt, flags);

	rcs_desc_set(file, content);
	free(content);
	return (0);
}

/*
 * Split the contents of a file into a list of lines.
 */
struct rcs_lines *
rcs_splitlines(u_char *data, size_t len)
{
	u_char *c, *p;
	struct rcs_lines *lines;
	struct rcs_line *lp;
	size_t i, tlen;

	lines = xcalloc(1, sizeof(*lines));
	TAILQ_INIT(&(lines->l_lines));

	lp = xcalloc(1, sizeof(*lp));
	TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);


	p = c = data;
	for (i = 0; i < len; i++) {
		if (*p == '\n' || (i == len - 1)) {
			tlen = p - c + 1;
			lp = xmalloc(sizeof(*lp));
			lp->l_line = c;
			lp->l_len = tlen;
			lp->l_lineno = ++(lines->l_nblines);
			TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);
			c = p + 1;
		}
		p++;
	}

	return (lines);
}

void
rcs_freelines(struct rcs_lines *lines)
{
	struct rcs_line *lp;

	while ((lp = TAILQ_FIRST(&(lines->l_lines))) != NULL) {
		TAILQ_REMOVE(&(lines->l_lines), lp, l_list);
		free(lp);
	}

	free(lines);
}

BUF *
rcs_patchfile(u_char *data, size_t dlen, u_char *patch, size_t plen,
    int (*p)(struct rcs_lines *, struct rcs_lines *))
{
	struct rcs_lines *dlines, *plines;
	struct rcs_line *lp;
	BUF *res;

	dlines = rcs_splitlines(data, dlen);
	plines = rcs_splitlines(patch, plen);

	if (p(dlines, plines) < 0) {
		rcs_freelines(dlines);
		rcs_freelines(plines);
		return (NULL);
	}

	res = buf_alloc(1024);
	TAILQ_FOREACH(lp, &dlines->l_lines, l_list) {
		if (lp->l_line == NULL)
			continue;
		buf_append(res, lp->l_line, lp->l_len);
	}

	rcs_freelines(dlines);
	rcs_freelines(plines);
	return (res);
}

/*
 * rcs_yesno()
 *
 * Read a char from standard input, returns defc if the
 * user enters an equivalent to defc, else whatever char
 * was entered.  Converts input to lower case.
 */
int
rcs_yesno(int defc)
{
	int c, ret;

	fflush(stderr);
	fflush(stdout);

	clearerr(stdin);
	if (isalpha(c = getchar()))
		c = tolower(c);
	if (c == defc || c == '\n' || (c == EOF && feof(stdin)))
		ret = defc;
	else
		ret = c;

	while (c != EOF && c != '\n')
		c = getchar();

	return (ret);
}

/*
 * rcs_strsplit()
 *
 * Split a string <str> of <sep>-separated values and allocate
 * an argument vector for the values found.
 */
struct rcs_argvector *
rcs_strsplit(const char *str, const char *sep)
{
	struct rcs_argvector *av;
	size_t i = 0;
	char *cp, *p;

	cp = xstrdup(str);
	av = xmalloc(sizeof(*av));
	av->str = cp;
	av->argv = xmalloc(sizeof(*(av->argv)));

	while ((p = strsep(&cp, sep)) != NULL) {
		av->argv[i++] = p;
		av->argv = xreallocarray(av->argv,
		    i + 1, sizeof(*(av->argv)));
	}
	av->argv[i] = NULL;

	return (av);
}

/*
 * rcs_argv_destroy()
 *
 * Free an argument vector previously allocated by rcs_strsplit().
 */
void
rcs_argv_destroy(struct rcs_argvector *av)
{
	free(av->str);
	free(av->argv);
	free(av);
}

/*
 * Strip suffix from filename.
 */
void
rcs_strip_suffix(char *filename)
{
	char *p, *suffixes, *next, *ext;

	if ((p = strrchr(filename, ',')) != NULL) {
		suffixes = xstrdup(rcs_suffixes);
		for (next = suffixes; (ext = strsep(&next, "/")) != NULL;) {
			if (!strcmp(p, ext)) {
				*p = '\0';
				break;
			}
		}
		free(suffixes);
	}
}
@


1.45
log
@The -I flag is documented but not implemented.  This fixes that and
also honors the -I flag from ci/co when prompting like GNU RCS.
OK jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.44 2015/06/13 20:15:21 nicm Exp $	*/
d368 1
a368 1
	char *ep;
@


1.44
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.43 2015/01/16 06:40:11 deraadt Exp $	*/
d333 1
a333 1
rcs_prompt(const char *prompt)
d339 3
d343 1
a343 1
	if (isatty(STDIN_FILENO))
d345 1
a345 1
	if (isatty(STDIN_FILENO))
d355 1
a355 1
		if (isatty(STDIN_FILENO))
d444 1
a444 1
rcs_set_description(RCSFILE *file, const char *in)
d464 1
a464 1
		content = rcs_prompt(prompt);
@


1.43
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.42 2014/12/01 21:58:46 deraadt Exp $	*/
d37 1
d232 1
a232 1
				xfree(suffixes);
d257 1
a257 1
		xfree(suffixes);
d268 1
a268 1
	xfree(suffixes);
d427 2
a428 4
	if (lnum.rn_id != NULL)
		xfree(lnum.rn_id);
	if (rnum.rn_id != NULL)
		xfree(rnum.rn_id);
d464 1
a464 1
	xfree(content);
d510 1
a510 1
		xfree(lp);
d513 1
a513 1
	xfree(lines);
d610 3
a612 3
	xfree(av->str);
	xfree(av->argv);
	xfree(av);
d631 1
a631 1
		xfree(suffixes);
@


1.42
log
@An internal function called xrealloc() is actually a fail-hard
reallocarray()... so rename it.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.41 2014/10/10 08:15:25 otto Exp $	*/
d157 2
a158 2
	char *p, *ext, name[MAXPATHLEN], *next, *ptr, rcsdir[MAXPATHLEN],
	    *suffixes, rcspath[MAXPATHLEN];
d218 1
a218 1
		char fpath[MAXPATHLEN];
@


1.41
log
@Zap some stored values never read; From Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.40 2014/05/29 16:39:42 tedu Exp $	*/
d595 1
a595 1
		av->argv = xrealloc(av->argv,
@


1.40
log
@use calloc, from Benjamin Baier
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.39 2013/04/16 20:24:45 deraadt Exp $	*/
a158 2

	fd = -1;
@


1.39
log
@remove wrong casts; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.38 2010/12/06 22:52:55 chl Exp $	*/
d482 1
a482 2
	lines = xmalloc(sizeof(*lines));
	memset(lines, 0, sizeof(*lines));
d485 1
a485 2
	lp = xmalloc(sizeof(*lp));
	memset(lp, 0, sizeof(*lp));
@


1.38
log
@add missing header needed by futimes()

ok tobias@@ xsa@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.37 2010/10/20 19:53:53 tobias Exp $	*/
d62 1
a62 1
	mtime = (time_t)st.st_mtimespec.tv_sec;
@


1.37
log
@Remove the need for rp_file in parser structure, instead keep only one
FILE pointer in RCSFILE.  This fixes some ugliness in closing an
fdopen()ed FILE and its underlying file descriptor.

Notified by Joerg Sonnenberger <joerg at britannica dot bec to de>

discussed with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.36 2010/09/08 15:15:50 tobias Exp $	*/
d31 1
@


1.36
log
@Set rcs_suffixes to default value on initialization.

ok ray zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.35 2010/07/28 09:07:11 ray Exp $	*/
d53 4
a56 1
	if (fstat(file->rf_fd, &st) == -1) {
d76 1
a76 1
	if (mtime == -1)
d82 1
a82 1
	if (futimes(file->rf_fd, tv) == -1)
@


1.35
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.34 2010/07/23 21:46:05 ray Exp $	*/
a154 4

	/* If -x flag was not given, use default. */
	if (rcs_suffixes == NULL)
		rcs_suffixes = RCS_DEFAULT_SUFFIX;
@


1.34
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.33 2008/05/10 20:23:24 joris Exp $	*/
d340 1
a340 1
	bp = buf_alloc(0, BUF_AUTOEXT);
d454 1
a454 1
		if ((bp = buf_load(in, BUF_AUTOEXT)) == NULL)
d538 1
a538 1
	res = buf_alloc(1024, BUF_AUTOEXT);
@


1.33
log
@properly free suffixes.
OK tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.32 2008/01/04 13:45:24 chl Exp $	*/
d340 1
a340 1
	bp = rcs_buf_alloc(0, BUF_AUTOEXT);
d351 1
a351 1
			rcs_buf_append(bp, buf, len);
d356 1
a356 1
	rcs_buf_putc(bp, '\0');
d358 1
a358 1
	return (rcs_buf_release(bp));
d454 1
a454 1
		if ((bp = rcs_buf_load(in, BUF_AUTOEXT)) == NULL)
d456 2
a457 2
		rcs_buf_putc(bp, '\0');
		content = rcs_buf_release(bp);
d538 1
a538 1
	res = rcs_buf_alloc(1024, BUF_AUTOEXT);
d542 1
a542 1
		rcs_buf_append(res, lp->l_line, lp->l_len);
@


1.32
log
@remove unused function

from tobias@@

ok xsa@@ tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.31 2007/07/19 06:37:58 ray Exp $	*/
d233 1
d258 1
@


1.31
log
@Sync with cvs:
> xcalloc is unneeded here since i is always 0 and we always use the
> memory after initializing it.
>
> Initial diff from Igor Zinovik.
>
> OK niallo and xsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.30 2007/05/29 00:19:10 ray Exp $	*/
a274 10
}

/*
 * Allocate an RCSNUM and store in <rev>.
 */
void
rcs_set_rev(const char *str, RCSNUM **rev)
{
	if (str == NULL || (*rev = rcsnum_parse(str)) == NULL)
		errx(1, "bad revision number `%s'", str);
@


1.30
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.29 2007/02/27 07:59:13 xsa Exp $	*/
d603 1
a603 1
	av->argv = xcalloc(i + 1, sizeof(*(av->argv)));
@


1.29
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.28 2007/02/22 19:11:13 otto Exp $	*/
a597 1
	char **nargv;
d607 1
a607 1
		nargv = xrealloc(av->argv,
a608 1
		av->argv = nargv;
@


1.28
log
@If a ,suffix file is given as an arg to ci and co, strip it. Avoids
potential disasters.  Initial diff from niallo@@, ok niallo@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.27 2007/02/22 08:30:45 xsa Exp $	*/
d30 8
a37 1
#include "includes.h"
@


1.27
log
@Fix const inconsistencies, void pointer artithmetic;
Based on diff from otto@@ in OpenCVS. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.26 2007/01/11 18:13:33 niallo Exp $	*/
d621 20
@


1.26
log
@remove some un-needed buffer NUL-termination.  in openrcs, diff3 is already NUL-terminating its
buffers so we don't need to do it twice.  this allows us to sync rcs_splitlines() with opencvs'
cvs_splitlines().

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.25 2007/01/10 02:13:23 ray Exp $	*/
d476 1
a476 1
rcs_splitlines(const u_char *data, size_t len)
d523 1
a523 1
rcs_patchfile(const u_char *data, size_t dlen, const u_char *patch, size_t plen,
@


1.25
log
@Clear EOF before prompting user for input.

Fixes PR 5342.

OK joris@@ and xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.24 2007/01/02 16:43:45 niallo Exp $	*/
d495 1
a495 3
			tlen = p - c;
			if (*p == '\n')
				tlen++;
@


1.24
log
@- fix support for checking out binary files.

testing from xsa@@ and Igor Sobrado <igor at string1.ciencias.uniovi.es>
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.23 2006/11/09 21:47:52 millert Exp $	*/
d346 1
d568 1
@


1.23
log
@Simplify stripping of write bits from file mode.
Add support for reusing the checkin message for multiple files, ala GNU
Fix the message when you abort a checkout and the file was not writable.
OK joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.22 2006/10/12 17:20:12 niallo Exp $	*/
d475 1
a475 1
rcs_splitlines(BUF *fcont)
d480 1
a480 1
	size_t i, len;
a481 1
	len = rcs_buf_len(fcont);
d483 1
a484 2
	lines->l_nblines = 0;
	lines->l_data = rcs_buf_get(fcont);
d487 1
a487 2
	lp->l_line = NULL;
	lp->l_lineno = 0;
d491 6
a496 4
	p = c = lines->l_data;
	for (i = 0; i < rcs_buf_len(fcont); i++) {
		if (*p == '\n' || (i == rcs_buf_len(fcont) - 1 && *c)) {
			len = p - c;
d498 2
a499 3
			lp->l_line = xmalloc(len + 1);
			memcpy(lp->l_line, c, len);
			lp->l_line[len] = '\0';
a516 2
		if (lp->l_line != NULL)
			xfree(lp->l_line);
a519 1
	xfree(lines->l_data);
d524 1
a524 1
rcs_patchfile(BUF *data, BUF *patch,
a528 2
	size_t len;
	int lineno;
d531 2
a532 4
	len = rcs_buf_len(data);

	dlines = rcs_splitlines(data);
	plines = rcs_splitlines(patch);
d540 1
a540 2
	lineno = 0;
	res = rcs_buf_alloc(len, BUF_AUTOEXT);
d542 3
a544 3
		if (lineno != 0)
			rcs_buf_fappend(res, "%s\n", lp->l_line);
		lineno++;
@


1.22
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.21 2006/09/25 23:58:05 ray Exp $	*/
d565 3
a567 2
 * Read from standart input for `y' or `Y' character.
 * Returns 0 on success, or -1 on failure.
d570 1
a570 1
rcs_yesno(void)
a573 2
	ret = 0;

d577 4
a580 2
	if ((c = getchar()) != 'y' && c != 'Y')
		ret = -1;
d582 4
a585 2
		while (c != EOF && c != '\n')
			c = getchar();
@


1.21
log
@Remove debugging printf accidentally committed.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.20 2006/09/22 05:38:29 niallo Exp $	*/
a198 1
		fd = open(rcspath, O_RDONLY);
d201 1
a261 1
	fd = open(rcspath, O_RDONLY);
d264 2
@


1.20
log
@- handle deltatexts which don't end in a newline character. fixes PR #5241.

ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.19 2006/09/19 05:52:23 otto Exp $	*/
a495 1
			printf("c: %x\n", *c);
@


1.19
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
Paul Stoeber, more to come. ok millert@@ pedro@@ jaredy@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.18 2006/08/16 07:39:15 ray Exp $	*/
d495 2
a496 1
		if (*p == '\n') {
@


1.18
log
@Improve rcs_buf_load() by setting errno appropriately on failure and
never print errors or quit on error.

Fix usages of rcs_buf_load() and rcs_set_description.

Also plug an fd leak.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.17 2006/07/08 09:14:03 ray Exp $	*/
d174 1
a174 1
	if (stat(rcsdir, &sb) == 0 && (sb.st_mode & S_IFDIR))
@


1.17
log
@rcs_splitlines() can never return NULL, so don't check for it.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.16 2006/07/04 22:14:56 niallo Exp $	*/
d440 1
d442 1
a442 1
void
d453 2
a454 1
		bp = rcs_buf_load(in, BUF_AUTOEXT);
d467 1
@


1.16
log
@- plug a memory leak
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.15 2006/06/03 03:05:10 niallo Exp $	*/
d536 2
a537 5
	if ((dlines = rcs_splitlines(data)) == NULL)
		return (NULL);

	if ((plines = rcs_splitlines(patch)) == NULL)
		return (NULL);
@


1.15
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.14 2006/05/28 23:16:31 ray Exp $	*/
d515 2
@


1.14
log
@Remove a lot of xstrdup() calls in getopt() loops, which are usually
unnecessary.  These xstrdup() calls don't call xfree() before anyway,
so if a flag is given multiple times memory leaks would have resulted.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.13 2006/05/27 08:12:29 ray Exp $	*/
d471 1
a471 1
rcs_splitlines(const char *fcont)
d473 1
a473 1
	char *dcp;
d476 1
d478 1
d482 1
a482 1
	lines->l_data = xstrdup(fcont);
a488 5
	for (dcp = lines->l_data; *dcp != '\0';) {
		lp = xmalloc(sizeof(*lp));
		lp->l_line = dcp;
		lp->l_lineno = ++(lines->l_nblines);
		TAILQ_INSERT_TAIL(&(lines->l_lines), lp, l_list);
d490 13
a502 4
		dcp = strchr(dcp, '\n');
		if (dcp == NULL)
			break;
		*(dcp++) = '\0';
d523 1
a523 1
rcs_patchfile(const char *data, const char *patch,
d532 1
a532 1
	len = strlen(data);
@


1.13
log
@Rename RCSFILE.fd to RCSFILE.rf_fd, plus minor spacing nits.  No
binary change.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.12 2006/05/27 05:49:14 ray Exp $	*/
d361 1
a361 1
rcs_rev_select(RCSFILE *file, char *range)
d585 1
a585 1
rcs_strsplit(char *str, const char *sep)
@


1.12
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.11 2006/05/27 02:58:02 ray Exp $	*/
d46 1
a46 1
	if (fstat(file->fd, &st) == -1) {
d72 1
a72 1
	if (futimes(file->fd, tv) == -1)
@


1.11
log
@rcs_choosefile() no longer returns char *, it returns a file
descriptor; fix comment.

Improve spacing.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.10 2006/05/09 12:31:27 ray Exp $	*/
a264 21

	return (fd);
}

/*
 * Find the name of an RCS file, given a file name `fname'.  If an RCS
 * file is found, the name is copied to the `len' sized buffer `out'.
 * Returns 0 if RCS file was found, -1 otherwise.
 */
int
rcs_statfile(char *fname, char *out, size_t len, int flags)
{
	int fd;

	fd = rcs_choosefile(fname, out, len);
	if (fd == -1 && !(flags & RCS_CREATE)) {
		if (strcmp(__progname, "rcsclean") != 0 &&
		    strcmp(__progname, "ci") != 0)
			warnx("%s", out);
		return (-1);
	}
@


1.10
log
@Remove unused variable leftover from race condition cleanup.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.9 2006/05/08 21:55:39 ray Exp $	*/
d139 1
a139 1
 * Returns pointer to a char array on success, NULL on failure.
d257 1
a257 2
	if (strlcat(rcspath, suffixes, sizeof(rcspath)) >=
	    sizeof(rcspath))
@


1.9
log
@Use warnx() when errno is not set.

OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.8 2006/04/29 05:31:28 ray Exp $	*/
d147 1
a147 1
	    *ret, *suffixes, rcspath[MAXPATHLEN];
d212 1
a212 1
	for (ret = NULL, next = suffixes; (ext = strsep(&next, "/")) != NULL;) {
a253 3
	 * `ret' is still NULL.  No RCS file with any extension exists
	 * so we use the first extension.
	 *
@


1.8
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.7 2006/04/27 07:59:33 xsa Exp $	*/
d287 1
a287 1
			warn("%s", out);
@


1.7
log
@zap util.[ch] and move the content into rcsutil.[ch].
discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.6 2006/04/26 21:55:22 joris Exp $	*/
d200 2
a201 1
		strlcpy(out, rcspath, len);
d267 2
a268 1
	strlcpy(out, rcspath, len);
@


1.6
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.5 2006/04/26 02:55:13 joris Exp $	*/
d488 154
@


1.5
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.4 2006/04/25 13:55:49 xsa Exp $	*/
d41 1
a41 1
rcs_get_mtime(const char *filename)
d46 2
a47 2
	if (stat(filename, &st) == -1) {
		warn("%s", filename);
d50 1
d62 1
a62 1
rcs_set_mtime(const char *filename, time_t mtime)
d72 1
a72 1
	if (utimes(filename, tv) == -1)
d141 2
a142 2
char *
rcs_choosefile(const char *filename)
d144 1
d153 2
d161 2
a162 1
		return (NULL);
d172 2
a173 1
		return (NULL);
d175 2
a176 1
		if (strlcpy(rcspath, rcsdir, sizeof(rcspath)) >= sizeof(rcspath) ||
d178 1
a178 1
			return (NULL);
d183 1
a183 1
			return (NULL);
d187 1
a187 1
			return (NULL);
d192 1
a192 1
		return (NULL);
d199 3
a201 2
		ret = xstrdup(rcspath);
		return (ret);
d216 10
a225 4
				if (stat(rcspath, &sb) == 0) {
					ret = xstrdup(rcspath);
					goto out;
				}
d234 1
a234 1
			goto out;
d240 10
a249 4
		if (stat(fpath, &sb) == 0) {
			ret = xstrdup(fpath);
			goto out;
		}
d261 1
a261 2
		goto out;
	ret = xstrdup(rcspath);
a262 2
out:
	/* `ret' may be NULL, which indicates an error. */
d264 5
a268 1
	return (ret);
d279 1
a279 5
	struct stat st;
	char *rcspath;

	if ((rcspath = rcs_choosefile(fname)) == NULL)
		errx(1, "rcs_statfile: path truncation");
d281 2
a282 2
	/* Error out if file not found and we are not creating one. */
	if (stat(rcspath, &st) == -1 && !(flags & RCS_CREATE)) {
d285 1
a285 2
			warn("%s", rcspath);
		xfree(rcspath);
d289 1
a289 6
	if (strlcpy(out, rcspath, len) >= len)
		errx(1, "rcs_statfile: path truncation");

	xfree(rcspath);

	return (0);
@


1.4
log
@quote strings consistently.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.3 2006/04/25 13:36:36 xsa Exp $	*/
d352 1
a352 1
	bp = cvs_buf_alloc(0, BUF_AUTOEXT);
d362 1
a362 1
			cvs_buf_append(bp, buf, len);
d367 1
a367 1
	cvs_buf_putc(bp, '\0');
d369 1
a369 1
	return (cvs_buf_release(bp));
d380 1
a380 1
	struct cvs_argvector *revargv, *revrange;
d396 1
a396 1
	revargv = cvs_strsplit(range, ",");
d398 1
a398 1
		revrange = cvs_strsplit(revargv->argv[i], ":");
d427 1
a427 1
		cvs_argv_destroy(revrange);
d437 1
a437 1
	cvs_argv_destroy(revargv);
d464 3
a466 3
		bp = cvs_buf_load(in, BUF_AUTOEXT);
		cvs_buf_putc(bp, '\0');
		content = cvs_buf_release(bp);
@


1.3
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.2 2006/04/24 04:51:57 ray Exp $	*/
d288 1
a288 1
		errx(1, "bad revision number '%s'", str);
@


1.2
log
@o Better match GNU behavior (a bare -t does NOT read from stdin,
  unlike rcs).
o Share code with rcs by moving rcs_set_description() to rcsutil.c.
o Change description prompt from #define to const char *.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsutil.c,v 1.1 2006/04/21 17:17:29 xsa Exp $	*/
d72 1
a72 1
		fatal("error setting utimes: %s", strerror(errno));
d262 1
a262 1
		fatal("rcs_statfile: path truncation");
d274 1
a274 1
		fatal("rcs_statfile: path truncation");
d288 1
a288 1
		fatal("bad revision number '%s'", str);
d318 1
a318 1
		fatal("too many revision numbers");
d401 1
a401 1
			fatal("invalid revision range: %s", revargv->argv[i]);
d406 2
a407 2
				fatal("invalid revision range: %s",
					revargv->argv[i]);
d419 1
a419 1
			fatal("invalid revision: %s", lstr);
d423 1
a423 1
				fatal("invalid revision: %s", rstr);
@


1.1
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d445 32
@

