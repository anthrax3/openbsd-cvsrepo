head	1.123;
access;
symbols
	OPENBSD_6_2:1.123.0.4
	OPENBSD_6_2_BASE:1.123
	OPENBSD_6_1:1.122.0.8
	OPENBSD_6_1_BASE:1.122
	OPENBSD_6_0:1.122.0.4
	OPENBSD_6_0_BASE:1.122
	OPENBSD_5_9:1.122.0.2
	OPENBSD_5_9_BASE:1.122
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.120.0.2
	OPENBSD_5_7_BASE:1.120
	OPENBSD_5_6:1.117.0.8
	OPENBSD_5_6_BASE:1.117
	OPENBSD_5_5:1.117.0.6
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.117.0.2
	OPENBSD_5_4_BASE:1.117
	OPENBSD_5_3:1.116.0.10
	OPENBSD_5_3_BASE:1.116
	OPENBSD_5_2:1.116.0.8
	OPENBSD_5_2_BASE:1.116
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.6
	OPENBSD_5_0:1.116.0.4
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.116.0.2
	OPENBSD_4_9_BASE:1.116
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.110.0.4
	OPENBSD_4_7_BASE:1.110
	OPENBSD_4_6:1.110.0.6
	OPENBSD_4_6_BASE:1.110
	OPENBSD_4_5:1.110.0.2
	OPENBSD_4_5_BASE:1.110
	OPENBSD_4_4:1.109.0.6
	OPENBSD_4_4_BASE:1.109
	OPENBSD_4_3:1.109.0.4
	OPENBSD_4_3_BASE:1.109
	OPENBSD_4_2:1.109.0.2
	OPENBSD_4_2_BASE:1.109
	OPENBSD_4_1:1.105.0.2
	OPENBSD_4_1_BASE:1.105
	OPENBSD_4_0:1.97.0.2
	OPENBSD_4_0_BASE:1.97
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54;
locks; strict;
comment	@ * @;


1.123
date	2017.08.29.16.47.33;	author otto;	state Exp;
branches;
next	1.122;
commitid	H6vFKnpT8IoXUPyV;

1.122
date	2015.10.21.16.06.57;	author millert;	state Exp;
branches;
next	1.121;
commitid	s2DZTdNXdq9anJGE;

1.121
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.120;
commitid	FFUg8uzT5GNAfRXp;

1.120
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	Uu5nFG3wCl0LACBb;

1.119
date	2014.10.10.08.15.25;	author otto;	state Exp;
branches;
next	1.118;
commitid	nj4mpSZoLV0jWhzi;

1.118
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.117;
commitid	yRuTsAu91VfT3St0;

1.117
date	2013.04.16.20.24.45;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.03.19.44.58;	author chl;	state Exp;
branches;
next	1.115;

1.115
date	2010.10.20.19.53.53;	author tobias;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.08.15.15.50;	author tobias;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.30.21.47.18;	author ray;	state Exp;
branches;
next	1.112;

1.112
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.110;

1.110
date	2009.02.25.23.16.20;	author ray;	state Exp;
branches;
next	1.109;

1.109
date	2007.07.03.00.56.23;	author ray;	state Exp;
branches;
next	1.108;

1.108
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.107;

1.107
date	2007.06.08.16.45.52;	author xsa;	state Exp;
branches;
next	1.106;

1.106
date	2007.06.07.09.08.54;	author xsa;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.22.19.11.13;	author otto;	state Exp;
branches;
next	1.103;

1.103
date	2007.02.21.18.12.36;	author niallo;	state Exp;
branches;
next	1.102;

1.102
date	2007.02.18.20.54.18;	author xsa;	state Exp;
branches;
next	1.101;

1.101
date	2007.02.01.18.01.42;	author millert;	state Exp;
branches;
next	1.100;

1.100
date	2006.11.10.16.31.29;	author millert;	state Exp;
branches;
next	1.99;

1.99
date	2006.11.09.21.47.52;	author millert;	state Exp;
branches;
next	1.98;

1.98
date	2006.10.12.17.20.12;	author niallo;	state Exp;
branches;
next	1.97;

1.97
date	2006.08.07.20.55.28;	author ray;	state Exp;
branches;
next	1.96;

1.96
date	2006.08.01.05.14.17;	author ray;	state Exp;
branches;
next	1.95;

1.95
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.94;

1.94
date	2006.05.28.23.16.31;	author ray;	state Exp;
branches;
next	1.93;

1.93
date	2006.05.27.08.12.29;	author ray;	state Exp;
branches;
next	1.92;

1.92
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.17.19.37.40;	author xsa;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.11.09.43.19;	author xsa;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.88;

1.88
date	2006.05.05.01.29.59;	author ray;	state Exp;
branches;
next	1.87;

1.87
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.86;

1.86
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.85;

1.85
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.84;

1.84
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.83;

1.83
date	2006.04.24.08.10.41;	author xsa;	state Exp;
branches;
next	1.82;

1.82
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.81;

1.81
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.80;

1.80
date	2006.04.21.07.06.25;	author xsa;	state Exp;
branches;
next	1.79;

1.79
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.78;

1.78
date	2006.04.15.16.28.07;	author pat;	state Exp;
branches;
next	1.77;

1.77
date	2006.04.14.01.11.07;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2006.04.13.03.18.06;	author joris;	state Exp;
branches;
next	1.75;

1.75
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.74;

1.74
date	2006.04.12.08.27.31;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.72;

1.72
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.09.19.22.23;	author niallo;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.06.10.13.00;	author xsa;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.30.23.06.25;	author joris;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.29.08.44.08;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.27.21.56.32;	author niallo;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.65;

1.65
date	2006.03.17.13.09.26;	author niallo;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.16.23.53.27;	author niallo;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.16.17.11.30;	author xsa;	state Exp;
branches;
next	1.62;

1.62
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.16.04.01.46;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.15.20.00.50;	author niallo;	state Exp;
branches;
next	1.59;

1.59
date	2006.03.07.01.40.52;	author joris;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.06.14.03.33;	author xsa;	state Exp;
branches;
next	1.57;

1.57
date	2006.03.06.13.49.24;	author xsa;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.06.13.47.34;	author xsa;	state Exp;
branches;
next	1.55;

1.55
date	2006.03.05.14.18.56;	author niallo;	state Exp;
branches;
next	1.54;

1.54
date	2006.02.24.14.34.56;	author xsa;	state Exp;
branches;
next	1.53;

1.53
date	2006.02.14.13.28.38;	author xsa;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.27.16.05.21;	author niallo;	state Exp;
branches;
next	1.49;

1.49
date	2005.12.23.00.59.56;	author joris;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.19.18.24.12;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.10.20.27.46;	author joris;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.09.06.59.27;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.09.04.27.01;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.08.18.56.10;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.05.19.46.24;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.02.11.45.02;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.30.18.50.51;	author xsa;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.30.14.29.22;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.29.11.11.39;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.29.10.55.37;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.25.13.50.01;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.24.15.35.11;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.23.13.59.07;	author xsa;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.23.09.39.20;	author xsa;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.23.09.05.02;	author xsa;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.23.08.42.23;	author xsa;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.22.16.20.45;	author xsa;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.08.09.22.47;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.03.16.08.03;	author niallo;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.03.15.41.52;	author niallo;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.03.15.40.40;	author niallo;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.02.20.44.50;	author niallo;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.02.20.32.45;	author niallo;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.25.17.27.54;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.20.17.10.01;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.19.11.37.11;	author niallo;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.19.00.30.22;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.18.01.22.14;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.17.15.33.12;	author joris;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.16.15.46.07;	author joris;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.16.11.59.06;	author niallo;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.15.21.23.54;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.15.18.26.24;	author niallo;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.12.17.43.18;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.10.17.12.49;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.10.13.32.16;	author niallo;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.10.13.20.20;	author niallo;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.05.12.06.23;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.05.11.52.16;	author joris;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.05.00.44.19;	author joris;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.04.23.04.33;	author joris;	state Exp;
branches;
next	1.3;

1.3
date	2005.09.29.21.30.10;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.29.15.21.57;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.29.15.16.26;	author joris;	state Exp;
branches;
next	;


desc
@@


1.123
log
@kill const and string artithmetic related warnings; ok millert@@
@
text
@/*	$OpenBSD: co.c,v 1.122 2015/10/21 16:06:57 millert Exp $	*/
/*
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/stat.h>
#include <sys/time.h>

#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

#define CO_OPTSTRING	"d:f::I::k:l::M::p::q::r::s:Tu::Vw::x::z::"

static void	checkout_err_nobranch(RCSFILE *, const char *, const char *,
    const char *, int);
static int	checkout_file_has_diffs(RCSFILE *, RCSNUM *, const char *);

int
checkout_main(int argc, char **argv)
{
	int fd, i, ch, flags, kflag, ret;
	RCSNUM *rev;
	RCSFILE *file;
	const char *author, *date, *state;
	char fpath[PATH_MAX];
	char *rev_str, *username;
	time_t rcs_mtime = -1;

	flags = ret = 0;
	kflag = RCS_KWEXP_ERR;
	rev_str = NULL;
	author = date = state = NULL;

	while ((ch = rcs_getopt(argc, argv, CO_OPTSTRING)) != -1) {
		switch (ch) {
		case 'd':
			date = rcs_optarg;
			break;
		case 'f':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= FORCE;
			break;
		case 'I':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= INTERACTIVE;
			break;

		case 'k':
			kflag = rcs_kflag_get(rcs_optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				warnx("invalid RCS keyword substitution mode");
				(usage)();
			}
			break;
		case 'l':
			if (flags & CO_UNLOCK) {
				warnx("warning: -u overridden by -l");
				flags &= ~CO_UNLOCK;
			}
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= CO_LOCK;
			break;
		case 'M':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= CO_REVDATE;
			break;
		case 'p':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= PIPEOUT;
			break;
		case 'q':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= QUIET;
			break;
		case 'r':
			rcs_setrevstr(&rev_str, rcs_optarg);
			break;
		case 's':
			state = rcs_optarg;
			flags |= CO_STATE;
			break;
		case 'T':
			flags |= PRESERVETIME;
			break;
		case 'u':
			rcs_setrevstr(&rev_str, rcs_optarg);
			if (flags & CO_LOCK) {
				warnx("warning: -l overridden by -u");
				flags &= ~CO_LOCK;
			}
			flags |= CO_UNLOCK;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'w':
			/* if no argument, assume current user */
			if (rcs_optarg == NULL) {
				if ((author = getlogin()) == NULL)
					err(1, "getlogin");
			} else
				author = rcs_optarg;
			flags |= CO_AUTHOR;
			break;
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		case 'z':
			timezone_flag = rcs_optarg;
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if (argc == 0) {
		warnx("no input file");
		(usage)();
	}

	if ((username = getlogin()) == NULL)
		err(1, "getlogin");

	for (i = 0; i < argc; i++) {
		fd = rcs_choosefile(argv[i], fpath, sizeof(fpath));
		if (fd < 0) {
			warn("%s", fpath);
			ret = 1;
			continue;
		}
		rcs_strip_suffix(argv[i]);

		if (!(flags & QUIET))
			(void)fprintf(stderr, "%s  -->  %s\n", fpath,
			    (flags & PIPEOUT) ? "standard output" : argv[i]);

		if ((flags & CO_LOCK) && (kflag & RCS_KWEXP_VAL)) {
			warnx("%s: cannot combine -kv and -l", fpath);
			(void)close(fd);
			continue;
		}

		if ((file = rcs_open(fpath, fd,
		    RCS_RDWR|RCS_PARSE_FULLY)) == NULL)
			continue;

		if (flags & PRESERVETIME)
			rcs_mtime = rcs_get_mtime(file);

		rcs_kwexp_set(file, kflag);

		if (rev_str != NULL) {
			if ((rev = rcs_getrevnum(rev_str, file)) == NULL)
				errx(1, "invalid revision: %s", rev_str);
		} else {
			/* no revisions in RCS file, generate empty 0.0 */
			if (file->rf_ndelta == 0) {
				rev = rcsnum_parse("0.0");
				if (rev == NULL)
					errx(1, "failed to generate rev 0.0");
			} else {
				rev = rcsnum_alloc();
				rcsnum_cpy(file->rf_head, rev, 0);
			}
		}

		if (checkout_rev(file, rev, argv[i], flags,
		    username, author, state, date) < 0) {
			rcs_close(file);
			rcsnum_free(rev);
			ret = 1;
			continue;
		}

		if (!(flags & QUIET))
			(void)fprintf(stderr, "done\n");

		rcsnum_free(rev);

		rcs_write(file);
		if (flags & PRESERVETIME)
			rcs_set_mtime(file, rcs_mtime);
		rcs_close(file);
	}

	return (ret);
}

__dead void
checkout_usage(void)
{
	fprintf(stderr,
	    "usage: co [-TV] [-ddate] [-f[rev]] [-I[rev]] [-kmode] [-l[rev]]\n"
	    "          [-M[rev]] [-p[rev]] [-q[rev]] [-r[rev]] [-sstate]\n"
	    "          [-u[rev]] [-w[user]] [-xsuffixes] [-ztz] file ...\n");
	
	exit(1);
}

/*
 * Checkout revision <rev> from RCSFILE <file>, writing it to the path <dst>
 * Currently recognised <flags> are CO_LOCK, CO_UNLOCK and CO_REVDATE.
 *
 * Looks up revision based upon <lockname>, <author>, <state> and <date>
 *
 * Returns 0 on success, -1 on failure.
 */
int
checkout_rev(RCSFILE *file, RCSNUM *frev, const char *dst, int flags,
    const char *lockname, const char *author, const char *state,
    const char *date)
{
	BUF *bp;
	u_int i;
	int fd, lcount;
	char buf[RCS_REV_BUFSZ];
	mode_t mode = DEFFILEMODE;
	struct stat st;
	struct rcs_delta *rdp;
	struct rcs_lock *lkp;
	char *fdate;
	const char *fstatus;
	time_t rcsdate, givendate;
	RCSNUM *rev;

	givendate = -1;
	if (date != NULL && (givendate = date_parse(date)) == -1) {
		warnx("invalid date: %s", date);
		return -1;
	}

	if (file->rf_ndelta == 0 && !(flags & QUIET))
		(void)fprintf(stderr,
		    "no revisions present; generating empty revision 0.0\n");

	/* XXX rcsnum_cmp()
	 * Check out the latest revision if <frev> is greater than HEAD
	 */
	if (file->rf_ndelta != 0) {
		for (i = 0; i < file->rf_head->rn_len; i++) {
			if (file->rf_head->rn_id[i] < frev->rn_id[i]) {
				frev = file->rf_head;
				break;
			}
		}
	}

	lcount = 0;
	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
		if (!strcmp(lkp->rl_name, lockname))
			lcount++;
	}

	/*
	 * If the user didn't specify any revision, we cycle through
	 * revisions to lookup the first one that matches what he specified.
	 *
	 * If we cannot find one, we return an error.
	 */
	rdp = NULL;
	if (file->rf_ndelta != 0 && frev == file->rf_head) {
		if (lcount > 1) {
			warnx("multiple revisions locked by %s; "
			    "please specify one", lockname);
			return (-1);
		}

		TAILQ_FOREACH(rdp, &file->rf_delta, rd_list) {
			if (date != NULL) {
				fdate = asctime(&rdp->rd_date);
				if ((rcsdate = date_parse(fdate)) == -1) {
					warnx("invalid date: %s", fdate);
					return -1;
				}
				if (givendate <= rcsdate)
					continue;
			}

			if (author != NULL &&
			    strcmp(rdp->rd_author, author))
				continue;

			if (state != NULL &&
			    strcmp(rdp->rd_state, state))
				continue;

			frev = rdp->rd_num;
			break;
		}
	} else if (file->rf_ndelta != 0) {
		rdp = rcs_findrev(file, frev);
	}

	if (file->rf_ndelta != 0 && rdp == NULL) {
		checkout_err_nobranch(file, author, date, state, flags);
		return (-1);
	}

	if (file->rf_ndelta == 0)
		rev = frev;
	else
		rev = rdp->rd_num;

	rcsnum_tostr(rev, buf, sizeof(buf));

	if (file->rf_ndelta != 0 && rdp->rd_locker != NULL) {
		if (strcmp(lockname, rdp->rd_locker)) {
			warnx("Revision %s is already locked by %s; %s",
			    buf, rdp->rd_locker,
			    (flags & CO_UNLOCK) ? "use co -r or rcs -u" : "");
			return (-1);
		}
	}

	if (!(flags & QUIET) && !(flags & NEWFILE) &&
	    !(flags & CO_REVERT) && file->rf_ndelta != 0)
		(void)fprintf(stderr, "revision %s", buf);

	if (file->rf_ndelta != 0) {
		if ((bp = rcs_getrev(file, rev)) == NULL) {
			warnx("cannot find revision `%s'", buf);
			return (-1);
		}
	} else {
		bp = buf_alloc(1);
	}

	/*
	 * Do keyword expansion if required.
	 */
	if (file->rf_ndelta != 0)
		bp = rcs_kwexp_buf(bp, file, rev);
	/*
	 * File inherits permissions from its ,v file
	 */
	if (file->rf_file != NULL) {
		if (fstat(fileno(file->rf_file), &st) == -1)
			err(1, "%s", file->rf_path);
		file->rf_mode = mode = st.st_mode;
	} else {
		mode = file->rf_mode;
	}

	if (flags & CO_LOCK) {
		if (file->rf_ndelta != 0) {
			if (lockname != NULL &&
			    rcs_lock_add(file, lockname, rev) < 0) {
				if (rcs_errno != RCS_ERR_DUPENT)
					return (-1);
			}
		}

		/* File should only be writable by owner. */
		mode &= ~(S_IWGRP|S_IWOTH);
		mode |= S_IWUSR;

		if (file->rf_ndelta != 0) {
			if (!(flags & QUIET) && !(flags & NEWFILE) &&
			    !(flags & CO_REVERT))
				(void)fprintf(stderr, " (locked)");
		}
	} else if (flags & CO_UNLOCK) {
		if (file->rf_ndelta != 0) {
			if (rcs_lock_remove(file, lockname, rev) < 0) {
				if (rcs_errno != RCS_ERR_NOENT)
					return (-1);
			}
		}

		/* Strip all write bits from mode */
		mode &= ~(S_IWUSR|S_IWGRP|S_IWOTH);

		if (file->rf_ndelta != 0) {
			if (!(flags & QUIET) && !(flags & NEWFILE) &&
			    !(flags & CO_REVERT))
				(void)fprintf(stderr, " (unlocked)");
		}
	}

	/* If strict locking is disabled, make file writable by owner. */
	if (rcs_lock_getmode(file) == RCS_LOCK_LOOSE)
		mode |= S_IWUSR;

	if (file->rf_ndelta == 0 && !(flags & QUIET) &&
	    ((flags & CO_LOCK) || (flags & CO_UNLOCK))) {
		(void)fprintf(stderr, "no revisions, so nothing can be %s\n",
		    (flags & CO_LOCK) ? "locked" : "unlocked");
	} else if (file->rf_ndelta != 0) {
		/* XXX - Not a good way to detect if a newline is needed. */
		if (!(flags & QUIET) && !(flags & NEWFILE) &&
		    !(flags & CO_REVERT))
			(void)fprintf(stderr, "\n");
	}

	if (flags & CO_LOCK) {
		if (rcs_errno != RCS_ERR_DUPENT)
			lcount++;
		if (!(flags & QUIET) && lcount > 1 && !(flags & CO_REVERT))
			warnx("%s: warning: You now have %d locks.",
			    file->rf_path, lcount);
	}

	if ((flags & (PIPEOUT|FORCE)) == 0 && stat(dst, &st) != -1) {
		/*
		 * Prompt the user if the file is writable or the file is
		 * not writable but is different from the RCS head version.
		 * This is different from GNU which will silently overwrite
		 * the file regardless of its contents so long as it is
		 * read-only.
		 */
		if (st.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH))
			fstatus = "writable";
		else if (checkout_file_has_diffs(file, frev, dst) != D_SAME)
			fstatus = "modified";
		else
			fstatus = NULL;
		if (fstatus) {
			(void)fprintf(stderr, "%s %s exists%s; ", fstatus, dst,
			    (getuid() == st.st_uid) ? "" :
			    ", and you do not own it");
			(void)fprintf(stderr, "remove it? [ny](n): ");
			if (rcs_yesno('n') == 'n') {
				if (!(flags & QUIET) && isatty(STDIN_FILENO))
					warnx("%s %s exists; checkout aborted",
					    fstatus, dst);
				else
					warnx("checkout aborted");
				return (-1);
			}
		}
	}

	if (flags & PIPEOUT)
		buf_write_fd(bp, STDOUT_FILENO);
	else {
		(void)unlink(dst);

		if ((fd = open(dst, O_WRONLY|O_CREAT|O_TRUNC, mode)) < 0)
			err(1, "%s", dst);

		if (buf_write_fd(bp, fd) < 0) {
			warnx("failed to write revision to file");
			buf_free(bp);
			(void)close(fd);
			return (-1);
		}

		if (fchmod(fd, mode) == -1)
			warn("%s", dst);

		if (flags & CO_REVDATE) {
			struct timeval tv[2];
			memset(&tv, 0, sizeof(tv));
			tv[0].tv_sec = rcs_rev_getdate(file, rev);
			tv[1].tv_sec = tv[0].tv_sec;
			if (futimes(fd, (const struct timeval *)&tv) < 0)
				warn("utimes");
		}

		(void)close(fd);
	}

	buf_free(bp);

	return (0);
}

/*
 * checkout_err_nobranch()
 *
 * XXX - should handle the dates too.
 */
static void
checkout_err_nobranch(RCSFILE *file, const char *author, const char *date,
    const char *state, int flags)
{
	if (!(flags & CO_AUTHOR))
		author = NULL;
	if (!(flags & CO_STATE))
		state = NULL;

	warnx("%s: No revision on branch has %s%s%s%s%s%s%s%s.",
	    file->rf_path,
	    date ? "a date before " : "",
	    date ? date : "",
	    (date && author) ? " and " : "",
	    author ? "author " : "",
	    author ? author : "",
	    ((date || author) && state) ? " and " : "",
	    state ? "state " : "",
	    state ? state : "");

}

/*
 * checkout_file_has_diffs()
 *
 * Check for diffs between the working file and its current revision.
 * Same return values as diffreg()
 */
static int
checkout_file_has_diffs(RCSFILE *rfp, RCSNUM *frev, const char *dst)
{
	char *tempfile;
	BUF *bp;
	int ret;

	tempfile = NULL;

	if ((bp = rcs_getrev(rfp, frev)) == NULL) {
		warnx("failed to load revision");
		return (D_ERROR);
	}
	if ((bp = rcs_kwexp_buf(bp, rfp, frev)) == NULL) {
		warnx("failed to expand tags");
		return (D_ERROR);
	}

	(void)xasprintf(&tempfile, "%s/diff.XXXXXXXXXX", rcs_tmpdir);
	buf_write_stmp(bp, tempfile);
	buf_empty(bp);

	diff_format = D_RCSDIFF;
	ret = diffreg(dst, tempfile, bp, D_FORCEASCII);

	buf_free(bp);
	unlink(tempfile);
	free(tempfile);

	return (ret);
}
@


1.122
log
@Style fixes; from Ilya Kaliman
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.121 2015/06/13 20:15:21 nicm Exp $	*/
d514 1
a514 1
	warnx("%s: No revision on branch has%s%s%s%s%s%s.",
d516 1
a516 1
	    date ? " a date before " : "",
d518 2
a519 1
	    author ? " and author " + (date ? 0:4) : "",
d521 4
a524 2
	    state  ? " and state " + (date || author ? 0:4) : "",
	    state  ? state : "");
@


1.121
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.120 2015/01/16 06:40:11 deraadt Exp $	*/
d518 1
a518 1
	    author ? " and author " + (date ? 0:4 ) : "",
@


1.120
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.119 2014/10/10 08:15:25 otto Exp $	*/
d557 1
a557 1
	xfree(tempfile);
@


1.119
log
@Zap some stored values never read; From Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.118 2014/10/02 06:23:15 otto Exp $	*/
d53 1
a53 1
	char fpath[MAXPATHLEN];
@


1.118
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.117 2013/04/16 20:24:45 deraadt Exp $	*/
a58 1
	rev = RCS_HEAD_REV;
d258 1
a258 1
	rcsdate = givendate = -1;
@


1.117
log
@remove wrong casts; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.116 2010/12/03 19:44:58 chl Exp $	*/
a81 1
				exit(1);
a142 1
			exit(1);
a151 1
		exit (1);
d222 1
a222 1
void
d229 2
@


1.116
log
@add missing header needed by futimes()

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.115 2010/10/20 19:53:53 tobias Exp $	*/
d488 1
a488 1
			tv[0].tv_sec = (long)rcs_rev_getdate(file, rev);
@


1.115
log
@Remove the need for rp_file in parser structure, instead keep only one
FILE pointer in RCSFILE.  This fixes some ugliness in closing an
fdopen()ed FILE and its underlying file descriptor.

Notified by Joerg Sonnenberger <joerg at britannica dot bec to de>

discussed with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.114 2010/09/08 15:15:50 tobias Exp $	*/
d28 1
@


1.114
log
@Set rcs_suffixes to default value on initialization.

ok ray zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.113 2010/07/30 21:47:18 ray Exp $	*/
d369 2
a370 2
	if (file->rf_fd != -1) {
		if (fstat(file->rf_fd, &st) == -1)
@


1.113
log
@Check date_parse return values.

OK xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.112 2010/07/28 09:07:11 ray Exp $	*/
a157 4

	/* If -x flag was not given, use default. */
	if (rcs_suffixes == NULL)
		rcs_suffixes = RCS_DEFAULT_SUFFIX;
@


1.112
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.111 2010/07/23 21:46:05 ray Exp $	*/
d264 4
a267 2
	if (date != NULL)
		givendate = date_parse(date);
d308 4
a311 1
				rcsdate = date_parse(fdate);
@


1.111
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.110 2009/02/25 23:16:20 ray Exp $	*/
d357 1
a357 1
		bp = buf_alloc(1, 0);
@


1.110
log
@Checking if a file is ASCII should only be done when diffing, because
the non-ASCII characters could be printed to the screen.  For
checking in files, checking out files, merging files, and removing
revisions of files, we do so regardless of whether the files are
ASCII or binary.

Fixes PR6031.

OK joris and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.109 2007/07/03 00:56:23 ray Exp $	*/
d265 1
a265 1
		givendate = rcs_date_parse(date);
d306 1
a306 1
				rcsdate = rcs_date_parse(fdate);
d357 1
a357 1
		bp = rcs_buf_alloc(1, 0);
d466 1
a466 1
		rcs_buf_write_fd(bp, STDOUT_FILENO);
d473 1
a473 1
		if (rcs_buf_write_fd(bp, fd) < 0) {
d475 1
a475 1
			rcs_buf_free(bp);
d495 1
a495 1
	rcs_buf_free(bp);
d549 2
a550 2
	rcs_buf_write_stmp(bp, tempfile);
	rcs_buf_empty(bp);
d555 1
a555 1
	rcs_buf_free(bp);
@


1.109
log
@Rename rcs_diffreg() to diffreg().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.108 2007/06/30 08:23:49 xsa Exp $	*/
d553 1
a553 1
	ret = diffreg(dst, tempfile, bp, 0);
@


1.108
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.107 2007/06/08 16:45:52 xsa Exp $	*/
d528 1
a528 1
 * Same return values as rcs_diffreg()
d553 1
a553 1
	ret = rcs_diffreg(dst, tempfile, bp, 0);
@


1.107
log
@If strict locking is disabled, make file writable by owner on checkout.
Matches GNU's behaviour. From Pierre Riteau (long time ago).
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.106 2007/06/07 09:08:54 xsa Exp $	*/
d253 1
a253 1
	char buf[16];
@


1.106
log
@Correct exit value when one of the files specified cannot be checked out.
Matches GNU's behaviour. From Pierre Riteau (long time ago).
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.105 2007/02/27 07:59:13 xsa Exp $	*/
d411 4
@


1.105
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.104 2007/02/22 19:11:13 otto Exp $	*/
d48 1
a48 1
	int fd, i, ch, flags, kflag, status;
d56 1
a56 1
	flags = status = 0;
d167 1
d206 2
a207 2
		if ((status = checkout_rev(file, rev, argv[i], flags,
		    username, author, state, date)) < 0) {
d210 1
d225 1
a225 1
	return (status);
@


1.104
log
@If a ,suffix file is given as an arg to ci and co, strip it. Avoids
potential disasters.  Initial diff from niallo@@, ok niallo@@ joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.103 2007/02/21 18:12:36 niallo Exp $	*/
d27 8
a34 1
#include "includes.h"
@


1.103
log
@make sure checkout_rev() sets correct file permissions via file->rf_mode
in case where fstat() of file->rf_fd won't give us right mode.

fixes PR #5383

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.102 2007/02/18 20:54:18 xsa Exp $	*/
d152 4
d162 1
@


1.102
log
@keep correct permissions on the RCS file when locking/unlocking the file
with ci and co. fixes PR 5379.
OK millert@@ joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.101 2007/02/01 18:01:42 millert Exp $	*/
d358 2
@


1.101
log
@When checking to see if a checked-out copy of the file is the same
as what is in the repo, expand keywords before doing the diff.
OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.100 2006/11/10 16:31:29 millert Exp $	*/
d357 1
a357 1
		mode = st.st_mode;
@


1.100
log
@Unlike GNU rcs, our co will not overwrite an existing file, even
if the existing file is not writable.  While safer, this can be
annoying.  I've changed things to compare the version of the file
being checked out with its current contents and, if they are the
same, to allow the checkout without user intervention.  The behavior
when there is a writable version of the file is unchanged.  OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.99 2006/11/09 21:47:52 millert Exp $	*/
d521 4
@


1.99
log
@Simplify stripping of write bits from file mode.
Add support for reusing the checkin message for multiple files, ala GNU
Fix the message when you abort a checkout and the file was not writable.
OK joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.98 2006/10/12 17:20:12 niallo Exp $	*/
d30 1
d36 1
d245 1
d415 1
a415 1
	if (!(flags & PIPEOUT) && stat(dst, &st) != -1 && !(flags & FORCE)) {
d417 5
a421 10
		 * XXX - Not sure what is "right".  If we go according
		 * to GNU's behavior, an existing file with no writable
		 * bits is overwritten without prompting the user.
		 *
		 * This is dangerous, so we always prompt.
		 * Unfortunately this interferes with an unlocked
		 * checkout followed by a locked checkout, which should
		 * not prompt.  One (unimplemented) solution is to check
		 * if the existing file is the same as the checked out
		 * revision, and prompt if there are differences.
d424 18
a441 13
			(void)fprintf(stderr, "writable ");
		(void)fprintf(stderr, "%s exists%s; ", dst,
		    (getuid() == st.st_uid) ? "" :
		    ", and you do not own it");
		(void)fprintf(stderr, "remove it? [ny](n): ");
		if (rcs_yesno('n') == 'n') {
			if (!(flags & QUIET) && isatty(STDIN_FILENO))
				warnx("%s%s exists; checkout aborted",
				    (st.st_mode & (S_IWUSR|S_IWGRP|S_IWOTH)) ?
				    "writable " : "", dst);
			else
				warnx("checkout aborted");
			return (-1);
d502 34
@


1.98
log
@- convert some warnx() to warn(), which fixes a few stupidly un-informative error messages (found by tom@@)
- make rcs_choosefile() save wrt errno, input from ray@@

ok joris@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.97 2006/08/07 20:55:28 ray Exp $	*/
d238 1
a238 1
	mode_t mode = 0444;
d366 2
a367 6
		/* Strip all write bits from mode */
		if (file->rf_fd != -1) {
			mode = st.st_mode &
			    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
		}

d384 1
a384 4
		if (file->rf_fd != -1) {
			mode = st.st_mode &
			    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
		}
d431 1
a431 2
		/* default is n */
		if (rcs_yesno() == -1) {
d433 3
a435 2
				warnx("writable %s exists; "
				    "checkout aborted", dst);
@


1.97
log
@More strlcpy/strlcat -> snprintf/xasprintf cleanup.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.96 2006/08/01 05:14:17 ray Exp $	*/
d153 1
a153 1
			warnx("%s", fpath);
@


1.96
log
@Reduce rcs_buf_release() usage, improving binary support.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.95 2006/06/03 03:05:10 niallo Exp $	*/
d242 1
a242 1
	char msg[128], *fdate;
d323 3
a325 11
			if (strlcpy(msg, "Revision %s is already locked by %s; ",
			    sizeof(msg)) >= sizeof(msg))
				errx(1, "msg too long");

			if (flags & CO_UNLOCK) {
				if (strlcat(msg, "use co -r or rcs -u",
				    sizeof(msg)) >= sizeof(msg))
					errx(1, "msg too long");
			}

			warnx(msg, buf, rdp->rd_locker);
@


1.95
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.94 2006/05/28 23:16:31 ray Exp $	*/
d242 1
a242 1
	char *content, msg[128], *fdate;
d457 3
a459 6
	if (flags & PIPEOUT) {
		rcs_buf_putc(bp, '\0');
		content = rcs_buf_release(bp);
		printf("%s", content);
		xfree(content);
	} else {
a474 2
		rcs_buf_free(bp);

d486 2
@


1.94
log
@Remove a lot of xstrdup() calls in getopt() loops, which are usually
unnecessary.  These xstrdup() calls don't call xfree() before anyway,
so if a flag is given multiple times memory leaks would have resulted.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.93 2006/05/27 08:12:29 ray Exp $	*/
a355 1

@


1.93
log
@Rename RCSFILE.fd to RCSFILE.rf_fd, plus minor spacing nits.  No
binary change.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.92 2006/05/27 05:49:14 ray Exp $	*/
d39 1
a39 1
	int fd, i, ch, flags, kflag, status, warg;
d42 1
d44 1
a44 1
	char *author, *date, *rev_str, *username, *state;
d47 1
a47 1
	warg = flags = status = 0;
d51 1
a51 3
	state = NULL;
	author = NULL;
	date = NULL;
d56 1
a56 1
			date = xstrdup(rcs_optarg);
d99 1
a99 1
			state = xstrdup(rcs_optarg);
d121 2
a122 4
			} else {
				author = xstrdup(rcs_optarg);
				warg = 1;
			}
a207 9

	if (author != NULL && warg)
		xfree(author);

	if (date != NULL)
		xfree(date);

	if (state != NULL)
		xfree(state);
@


1.92
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.91 2006/05/17 19:37:40 xsa Exp $	*/
d372 2
a373 2
	if (file->fd != -1) {
		if (fstat(file->fd, &st) == -1)
d388 1
a388 1
		if (file->fd != -1) {
d409 1
a409 1
		if (file->fd != -1) {
@


1.91
log
@fix printf's
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.90 2006/05/11 09:43:19 xsa Exp $	*/
d154 3
a156 2
		fd = rcs_statfile(argv[i], fpath, sizeof(fpath), flags);
		if (fd < 0)
d158 1
@


1.90
log
@fix informative msg's wrt to -q and stderr. now matches gnu/usr.bin/rcs.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.89 2006/05/09 12:33:42 ray Exp $	*/
d350 1
a350 1
		printf("revision %s", buf);
d396 1
a396 1
				printf(" (locked)");
d415 1
a415 1
				printf(" (unlocked)");
d421 1
a421 1
		(void)fprintf(stderr, "no revisions, so nothing can be %s",
d452 2
a453 2
			printf("writable ");
		printf("%s exists%s; ", dst,
d456 1
a456 1
		printf("remove it? [ny](n): ");
@


1.89
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.88 2006/05/05 01:29:59 ray Exp $	*/
d159 1
a159 1
			printf("%s  -->  %s\n", fpath,
d200 1
a200 1
			printf("done\n");
d260 3
a262 2
	if (file->rf_ndelta == 0)
		printf("no revisions present; generating empty revision 0.0\n");
d419 1
a419 1
	if (file->rf_ndelta == 0 &&
d421 1
a421 1
		warnx("no revisions, so nothing can be %s",
d427 1
a427 1
			printf("\n");
@


1.88
log
@o GNU ci returns 0 when a file is reverted (co -l file; ci file).
o Don't unlock file after revert.
o Fix spelling.

Passes extra tests in GNU rcstest.

OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.87 2006/04/29 05:31:28 ray Exp $	*/
a116 1
			/* NOTREACHED */
@


1.87
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.86 2006/04/26 21:55:22 joris Exp $	*/
d234 1
a234 1
 * Currenly recognised <flags> are CO_LOCK, CO_UNLOCK and CO_REVDATE.
a351 3
	if (!(flags & QUIET) && (flags & CO_REVERT))
		printf("done");

d424 3
a426 1
		if (!(flags & QUIET) && !(flags & NEWFILE))
@


1.86
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.85 2006/04/26 02:55:13 joris Exp $	*/
d333 3
a335 2
			strlcpy(msg, "Revision %s is already locked by %s; ",
			    sizeof(msg));
d338 3
a340 2
				strlcat(msg, "use co -r or rcs -u",
				    sizeof(msg));
@


1.85
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.84 2006/04/25 13:36:35 xsa Exp $	*/
d39 1
a39 1
	int i, ch, flags, kflag, status, warg;
d155 2
a156 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath), flags) < 0)
d165 1
d169 2
a170 1
		if ((file = rcs_open(fpath, RCS_RDWR|RCS_PARSE_FULLY)) == NULL)
d174 1
a174 1
			rcs_mtime = rcs_get_mtime(file->rf_path);
a202 1
		rcs_close(file);
d205 1
d207 2
a208 1
			rcs_set_mtime(fpath, rcs_mtime);
d247 1
a247 1
	int lcount;
d371 5
a375 4
	if (stat(file->rf_path, &st) == -1)
		err(1, "%s", file->rf_path);

	mode = st.st_mode;
d387 5
a391 2
		mode = st.st_mode &
		    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
d408 4
a411 2
		mode = st.st_mode &
		    (S_IXUSR|S_IXGRP|S_IXOTH|S_IRUSR|S_IRGRP|S_IROTH);
d437 1
a437 1
	if (!(flags & PIPEOUT) && stat(dst, &st) == 0 && !(flags & FORCE)) {
d473 6
a478 1
		if (rcs_buf_write(bp, dst, mode) < 0) {
d481 1
d484 4
d489 1
d495 1
a495 1
			if (utimes(dst, (const struct timeval *)&tv) < 0)
d498 2
@


1.84
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.83 2006/04/24 08:10:41 xsa Exp $	*/
d255 1
a255 1
		givendate = cvs_date_parse(date);
d295 1
a295 1
				rcsdate = cvs_date_parse(fdate);
d355 1
a355 1
		bp = cvs_buf_alloc(1, 0);
d447 1
a447 1
		if (cvs_yesno() == -1) {
d458 2
a459 2
		cvs_buf_putc(bp, '\0');
		content = cvs_buf_release(bp);
d463 1
a463 1
		if (cvs_buf_write(bp, dst, mode) < 0) {
d465 1
a465 1
			cvs_buf_free(bp);
d468 1
a468 1
		cvs_buf_free(bp);
@


1.83
log
@be consistent in error messages for wrongly specified keyword substitution
mode for `-k'.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.82 2006/04/21 17:17:29 xsa Exp $	*/
d122 1
a122 1
					fatal("getlogin failed");
d152 1
a152 1
		fatal("getlogin failed");
d177 1
a177 1
				fatal("invalid revision: %s", rev_str);
d183 1
a183 1
					fatal("failed to generate rev 0.0");
d368 1
a368 1
		fatal("could not stat rcsfile");
@


1.82
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.81 2006/04/21 14:18:26 xsa Exp $	*/
d71 1
a71 1
				warnx("invalid RCS keyword expansion mode");
@


1.81
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.80 2006/04/21 07:06:25 xsa Exp $	*/
d155 1
a155 1
		if (rcs_statfile(argv[i], fpath, sizeof(fpath)) < 0)
@


1.80
log
@switch -p handling to bitwise flags; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.79 2006/04/19 06:53:41 xsa Exp $	*/
d71 1
a71 2
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
d78 1
a78 1
				cvs_log(LP_ERR, "warning: -u overridden by -l");
d109 1
a109 1
				cvs_log(LP_ERR, "warning: -l overridden by -u");
d146 1
a146 1
		cvs_log(LP_ERR, "no input file");
d151 2
a152 4
	if ((username = getlogin()) == NULL) {
		cvs_log(LP_ERRNO, "failed to get username");
		exit (1);
	}
d163 1
a163 1
			cvs_log(LP_ERR, "%s: cannot combine -kv and -l", fpath);
d287 1
a287 2
			cvs_log(LP_WARN,
			    "multiple revisions locked by %s; "
d337 1
a337 1
			cvs_log(LP_ERR, msg, buf, rdp->rd_locker);
d351 1
a351 1
			cvs_log(LP_ERR, "cannot find revision `%s'", buf);
d412 1
a412 1
		cvs_log(LP_WARN, "no revisions, so nothing can be %s",
d423 1
a423 1
			cvs_log(LP_WARN, "%s: warning: You now have %d locks.",
d449 2
a450 3
				cvs_log(LP_ERR,
				    "writable %s exists; checkout aborted",
				    dst);
d452 1
a452 1
				cvs_log(LP_ERR, "checkout aborted");
d464 1
a464 1
			cvs_log(LP_ERR, "failed to write revision to file");
d475 1
a475 1
				cvs_log(LP_ERRNO, "error setting utimes");
d496 1
a496 1
	cvs_log(LP_ERR, "%s: No revision on branch has%s%s%s%s%s%s.",
@


1.79
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.78 2006/04/15 16:28:07 pat Exp $	*/
d91 1
a91 1
			pipeout = 1;
d163 1
a163 1
			    (pipeout == 1) ? "standard output" : argv[i]);
d431 1
a431 1
	if (pipeout == 0 && stat(dst, &st) == 0 && !(flags & FORCE)) {
d462 1
a462 1
	if (pipeout == 1) {
@


1.78
log
@Plug some memory leaks; ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.77 2006/04/14 01:11:07 deraadt Exp $	*/
d95 1
a95 1
			verbose = 0;
d161 1
a161 1
		if (verbose == 1)
d200 1
a200 1
		if (verbose == 1)
d346 1
a346 1
	if (verbose == 1 && !(flags & NEWFILE) &&
d350 1
a350 1
	if (verbose == 1 && (flags & CO_REVERT))
d391 1
a391 1
			if (verbose == 1 && !(flags & NEWFILE) &&
d408 1
a408 1
			if (verbose == 1 && !(flags & NEWFILE) &&
d419 1
a419 1
		if (verbose == 1 && !(flags & NEWFILE))
d426 1
a426 1
		if (verbose == 1 && lcount > 1 && !(flags & CO_REVERT))
d452 1
a452 1
			if (verbose == 1 && isatty(STDIN_FILENO))
@


1.77
log
@excessive addition to brackets is a mental disease.  you will go
blind, too.  seek help.  no binary change, ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.76 2006/04/13 03:18:06 joris Exp $	*/
d39 2
a40 2
	int i, ch, flags, kflag, status;
	RCSNUM *frev, *rev;
d43 1
a43 2
	char *author, *date, *rev_str, *username;
	const char *state;
d46 1
a46 1
	flags = status = 0;
a48 1
	frev = NULL;
d124 1
a124 1
			} else
d126 2
a157 1
		frev = NULL;
d210 8
a217 2
	if (rev != RCS_HEAD_REV && frev != NULL)
		rcsnum_free(frev);
@


1.76
log
@correctly handle RCS files without any revisions;
original diff from ray@@, crafted into shape by myself.

okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.75 2006/04/13 00:58:25 ray Exp $	*/
d211 1
a211 1
	if ((rev != RCS_HEAD_REV) && (frev != NULL))
d283 1
a283 1
	if ((file->rf_ndelta != 0) && (frev == file->rf_head)) {
d299 2
a300 2
			if ((author != NULL) &&
			    (strcmp(rdp->rd_author, author)))
d303 2
a304 2
			if ((state != NULL) &&
			    (strcmp(rdp->rd_state, state)))
d314 1
a314 1
	if ((file->rf_ndelta != 0) && (rdp == NULL)) {
d326 1
a326 1
	if ((file->rf_ndelta != 0) && (rdp->rd_locker != NULL)) {
d341 2
a342 2
	if ((verbose == 1) && !(flags & NEWFILE) &&
	    !(flags & CO_REVERT) && (file->rf_ndelta != 0))
d345 1
a345 1
	if ((verbose == 1) && (flags & CO_REVERT))
d373 2
a374 2
			if ((lockname != NULL)
		   	 && (rcs_lock_add(file, lockname, rev) < 0)) {
d386 2
a387 2
			if ((verbose == 1) && !(flags & NEWFILE)
		   	    && !(flags & CO_REVERT))
d403 2
a404 2
			if ((verbose == 1) && !(flags & NEWFILE)
		    	    && !(flags & CO_REVERT))
d409 1
a409 1
	if ((file->rf_ndelta == 0) &&
d414 1
a414 1
		if ((verbose == 1) && !(flags & NEWFILE))
d421 1
a421 1
		if ((verbose == 1) && (lcount > 1) && !(flags & CO_REVERT))
d426 1
a426 1
	if ((pipeout == 0) && (stat(dst, &st) == 0) && !(flags & FORCE)) {
d447 1
a447 1
			if ((verbose == 1) && isatty(STDIN_FILENO))
@


1.75
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.74 2006/04/12 08:27:31 deraadt Exp $	*/
d183 9
a191 2
			rev = rcsnum_alloc();
			rcsnum_cpy(file->rf_head, rev, 0);
d255 3
d261 6
a266 4
	for (i = 0; i < file->rf_head->rn_len; i++) {
		if (file->rf_head->rn_id[i] < frev->rn_id[i]) {
			frev = file->rf_head;
			break;
d283 1
a283 1
	if (frev == file->rf_head) {
d310 1
a310 1
	} else {
d314 1
a314 1
	if (rdp == NULL) {
d319 5
a323 1
	rev = rdp->rd_num;
d326 1
a326 1
	if (rdp->rd_locker != NULL) {
d330 6
a335 2
			if (flags & CO_UNLOCK)
				strlcat(msg, "use co -r or rcs -u", sizeof(msg));
d341 2
a342 1
	if ((verbose == 1) && !(flags & NEWFILE) && !(flags & CO_REVERT))
d348 7
a354 4

	if ((bp = rcs_getrev(file, rev)) == NULL) {
		cvs_log(LP_ERR, "cannot find revision `%s'", buf);
		return (-1);
d360 2
a361 1
	bp = rcs_kwexp_buf(bp, file, rev);
d372 6
a377 4
		if ((lockname != NULL)
		    && (rcs_lock_add(file, lockname, rev) < 0)) {
			if (rcs_errno != RCS_ERR_DUPENT)
				return (-1);
d384 6
a389 3
		if ((verbose == 1) && !(flags & NEWFILE)
		    && !(flags & CO_REVERT))
			printf(" (locked)");
d391 5
a395 3
		if (rcs_lock_remove(file, lockname, rev) < 0) {
			if (rcs_errno != RCS_ERR_NOENT)
				return (-1);
d401 6
a406 3
		if ((verbose == 1) && !(flags & NEWFILE)
		    && !(flags & CO_REVERT))
			printf(" (unlocked)");
d409 8
a416 2
	if ((verbose == 1) && !(flags & NEWFILE))
		printf("\n");
@


1.74
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.73 2006/04/12 08:23:30 ray Exp $	*/
d179 4
a182 3
		if (rev_str != NULL)
			rcs_set_rev(rev_str, &rev);
		else {
@


1.73
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.72 2006/04/10 08:08:00 xsa Exp $	*/
d322 1
a322 1
	
@


1.72
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.71 2006/04/09 19:22:23 niallo Exp $	*/
d43 1
a43 1
	char *author, *username, *date;
d51 1
d62 1
a62 1
			rcs_set_rev(rcs_optarg, &rev);
d66 1
a66 1
			rcs_set_rev(rcs_optarg, &rev);
a79 1
			rcs_set_rev(rcs_optarg, &rev);
d84 1
d88 1
a88 1
			rcs_set_rev(rcs_optarg, &rev);
d92 1
a92 1
			rcs_set_rev(rcs_optarg, &rev);
d96 1
a96 1
			rcs_set_rev(rcs_optarg, &rev);
d100 1
a100 1
			rcs_set_rev(rcs_optarg, &rev);
d110 1
a110 1
			rcs_set_rev(rcs_optarg, &rev);
d179 6
a184 4
		if (rev == RCS_HEAD_REV)
			frev = file->rf_head;
		else
			frev = rev;
d186 1
a186 1
		if ((status = checkout_rev(file, frev, argv[i], flags,
d188 3
a190 2
				rcs_close(file);
				continue;
d197 1
@


1.71
log
@- don't print out warnings about locking when they are actually wrong and
just confuse the user.

ok and input joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.70 2006/04/06 10:13:00 xsa Exp $	*/
d176 1
a176 2
		if (kflag != RCS_KWEXP_ERR)
			rcs_kwexp_set(file, kflag);
@


1.70
log
@-z can take no argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.69 2006/03/30 23:06:25 joris Exp $	*/
d316 1
a316 1
	if ((verbose == 1) && !(flags & NEWFILE))
d318 3
d352 2
a353 1
		if ((verbose == 1) && !(flags & NEWFILE))
d364 2
a365 1
		if ((verbose == 1) && !(flags & NEWFILE))
d373 3
a375 2
		lcount++;
		if ((verbose == 1) && (lcount > 1))
@


1.69
log
@first part of supporting branches in openrcs. right now we can only
check them out. commit is not working yet, but will be soon.

tested by myself and ray@@
okay ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.68 2006/03/29 08:44:08 ray Exp $	*/
d31 1
a31 1
#define CO_OPTSTRING	"d:f::I::k:l::M::p::q::r::s:Tu::Vw::x::z:"
@


1.68
log
@More closely matches GNU behavior, passes more GNU rcstest tests.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.67 2006/03/27 21:56:32 niallo Exp $	*/
d157 1
d199 1
a199 1
	if (rev != RCS_HEAD_REV)
d228 1
d237 1
d243 9
a251 3
	/* Check out the latest revision if <frev> is greater than HEAD */
	if (rcsnum_cmp(frev, file->rf_head, 0) == -1)
		frev = file->rf_head;
d302 2
a303 1
	rcsnum_tostr(frev, buf, sizeof(buf));
d320 1
a320 1
	if ((bp = rcs_getrev(file, frev)) == NULL) {
d324 1
d328 1
a328 1
	bp = rcs_kwexp_buf(bp, file, frev);
d340 1
a340 1
		    && (rcs_lock_add(file, lockname, frev) < 0)) {
d352 1
a352 1
		if (rcs_lock_remove(file, lockname, frev) < 0) {
d420 1
a420 1
			tv[0].tv_sec = (long)rcs_rev_getdate(file, frev);
@


1.67
log
@- properly implement GNU file modes.  basically, checkout will inherit
permissions from rcs file and initial checkin will inherit permissions from
working file.

problem spotted by uwe@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.66 2006/03/24 05:14:48 ray Exp $	*/
d364 13
a376 8
		if (verbose == 0) {
			cvs_log(LP_ERR,
			    "writable %s exists; checkout aborted",
			    dst);
			return (-1);
		}

		if (st.st_mode & S_IWUSR)
d384 6
a389 1
			cvs_log(LP_ERR, "checkout aborted");
@


1.66
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.65 2006/03/17 13:09:26 niallo Exp $	*/
d319 8
d334 4
a337 1
		mode = 0644;
d346 3
a348 1
		mode = 0444;
@


1.65
log
@- co usage() says we support -I, so set the flags and revision.

ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.64 2006/03/16 23:53:27 niallo Exp $	*/
d31 1
a31 1
#define CO_OPTSTRING	"d:f::I::k:l::M::p::q::r::s:Tu::Vw::x:z:"
d130 2
a131 1
			rcs_suffixes = rcs_optarg;
@


1.64
log
@- checkout_rev() can fail, in which case we want a non-zero exit code.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.63 2006/03/16 17:11:30 xsa Exp $	*/
d31 1
a31 1
#define CO_OPTSTRING	"d:f::k:l::M::p::q::r::s:Tu::Vw::x:z:"
d64 5
@


1.63
log
@error message fix; respect -q too. Ok ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.62 2006/03/16 04:04:57 ray Exp $	*/
d39 1
a39 1
	int i, ch, flags, kflag;
d47 1
a47 1
	flags = 0;
d177 2
a178 2
		if (checkout_rev(file, frev, argv[i], flags,
		    username, author, state, date) < 0) {
d195 1
a195 1
	return (0);
@


1.62
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.61 2006/03/16 04:01:46 ray Exp $	*/
d339 3
a341 2
		if (lcount > 1)
			cvs_log(LP_WARN, "You now have %d locks.", lcount);
@


1.61
log
@Currently co(1) overwrites files that the current user doesn't have
write permissions for.  If you own the directory, that means your
existing file, mode 000, is blown away without prompting you.  GNU
RCS does this as well.

This fixes changes co(1) to always prompt if a file exists.  This
breaks GNU compatibility but I think it's more important that we
prevent co(1) from overwriting files with strict permissions without
even prompting.

``makes sense'' xsa to an earlier diff
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.60 2006/03/15 20:00:50 niallo Exp $	*/
d114 1
@


1.60
log
@- use shared cvs_yesno() for yesno prompt, fixing an issue spotted by
deraadt@@

- while here, remove unecessary cast also spotted by deraadt@@

ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.59 2006/03/07 01:40:52 joris Exp $	*/
d343 6
a348 7
		if (st.st_mode & S_IWUSR) {
			if (verbose == 0) {
				cvs_log(LP_ERR,
				    "writable %s exists; checkout aborted",
				    dst);
				return (-1);
			}
d350 10
a359 9
			printf("writable %s exists%s; ", dst,
			    (getuid() == st.st_uid) ? "" :
			    ", and you do not own it");
			printf("remove it? [ny](n): ");
			/* default is n */
			if (cvs_yesno() == -1) {
				cvs_log(LP_ERR, "checkout aborted");
				return (-1);
			}
@


1.59
log
@-z support for RCS;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.58 2006/03/06 14:03:33 xsa Exp $	*/
d221 1
a221 1
	char buf[16], yn;
a343 1
			yn = 0;
d351 6
a356 10
			while ((yn != 'y') && (yn != 'n')) {
				printf("writable %s exists%s; ", dst,
				    ((uid_t)getuid() == st.st_uid) ? "" :
				    ", and you do not own it");
				printf("remove it? [ny](n): ");
				fflush(stdout);
				yn = getchar();
			}

			if (yn == 'n') {
@


1.58
log
@missing informative message after call to checkout_rev().
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.57 2006/03/06 13:49:24 xsa Exp $	*/
d31 1
a31 1
#define CO_OPTSTRING	"d:f::k:l::M::p::q::r::s:Tu::Vw::x:"
d125 3
@


1.57
log
@should also have removed those newlines in previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.56 2006/03/06 13:47:34 xsa Exp $	*/
d178 3
@


1.56
log
@missing newline in checkout_rev(); spotted by joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.55 2006/03/05 14:18:56 niallo Exp $	*/
d315 1
a315 1
			printf(" (locked)\n");
d324 1
a324 1
			printf(" (unlocked)\n");
@


1.55
log
@our deltatexts were sometimes different from gnu.  rcs_getrev() was
unconditionally doing keyword expansion, even when this wasn't what we
wanted e.g. in checkout_rev() and cvs_checkout_rev(). so:

- change semantics of rcs_getrev() to not do keyword expansion
- add an rcs.c api function rcs_kwexp_buf() which does this
- change both checkout_rev() and cvs_checkout_rev() to use this function.

eyeballed by xsa, joris and Ray Lai
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.54 2006/02/24 14:34:56 xsa Exp $	*/
d326 3
@


1.54
log
@remove extra printf;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.53 2006/02/14 13:28:38 xsa Exp $	*/
d301 4
@


1.53
log
@- fix behaviour when using -u and -l at the same time
- do not display some messages when checking in a file for the first time
OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.52 2006/01/05 10:28:24 xsa Exp $	*/
a374 3

		if ((verbose == 1) && !(flags & NEWFILE))
			printf("done\n");
@


1.52
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.51 2006/01/02 08:13:28 xsa Exp $	*/
d75 4
d105 4
d293 1
a293 1
	if (verbose == 1)
d310 2
a311 2
		if (verbose == 1)
			printf(" (locked)");
d319 2
a320 2
		if (verbose == 1)
			printf(" (unlocked)");
a322 3
	if (verbose == 1)
		printf("\n");

d376 1
a376 1
		if (verbose == 1)
@


1.51
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.50 2005/12/27 16:05:21 niallo Exp $	*/
a28 2
#include "log.h"
#include "rcs.h"
@


1.50
log
@- implement lazy-parsing of rcs files, that is only parse as much as we
  need. this can save us much work, particularly with very large rcs files.

first of a few important performance improvements.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.49 2005/12/23 00:59:56 joris Exp $	*/
d27 1
a27 7
#include <sys/param.h>
#include <sys/stat.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.49
log
@support co -d, which checks out the first revision who's
date is less than or equal to the given date.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.48 2005/12/19 18:24:12 xsa Exp $	*/
d159 1
a159 1
		if ((file = rcs_open(fpath, RCS_RDWR)) == NULL)
@


1.48
log
@use fatal() if getlogin() fails;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.47 2005/12/10 20:27:46 joris Exp $	*/
d39 1
a39 1
#define CO_OPTSTRING	"f::k:l::M::p::q::r::s:Tu::Vw::x:"
d51 1
a51 1
	char *author, *username;
d61 1
d65 3
d174 1
a174 1
		    username, author, state) < 0) {
d204 1
a204 1
 * Looks up revision based upon <lockname>, <author>, <state>
d210 2
a211 1
    const char *lockname, const char *author, const char *state)
d220 6
a225 1
	char *content, msg[128];
d253 7
d263 1
d276 1
a276 1
		checkout_err_nobranch(file, author, NULL, state, flags);
@


1.47
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.46 2005/12/09 06:59:27 joris Exp $	*/
d113 2
a114 5
				if ((author = getlogin()) == NULL) {
					cvs_log(LP_ERRNO,
					    "could not get login");
					exit(1);
				}
@


1.46
log
@if we are removing a lock that's not present, just check
out the file without complaining;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.45 2005/12/09 04:27:01 joris Exp $	*/
d97 1
a97 4
			if ((state = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}
d118 2
a119 5
			} else if ((author = strdup(rcs_optarg)) == NULL) {
				cvs_log(LP_ERRNO, "out of memory");
				exit(1);
			}

d347 1
a347 1
		free(content);
@


1.45
log
@unused vars, my bad;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.44 2005/12/08 18:56:10 joris Exp $	*/
d304 4
a307 2
		if (rcs_lock_remove(file, lockname, frev) < 0)
			return (-1);
@


1.44
log
@complete and correct rcs locking functionality,
it was only done partially and as a bonus, completely wrong.

seriously guys what was up with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.43 2005/12/05 19:46:24 xsa Exp $	*/
d50 1
a50 1
	char fpath[MAXPATHLEN], buf[16];
a52 1
	struct rcs_delta *rdp;
@


1.43
log
@correctly handle `-wfoo' and `-sbar' errors; OK joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.41 2005/11/30 18:50:51 xsa Exp $	*/
a40 2
static int	checkout_state(RCSFILE *, RCSNUM *, const char *, int,
    const char *, const char *);
d51 1
a51 1
	char *username;
d60 2
a61 1
	state = username = NULL;
d115 12
a126 1
			username = rcs_optarg;
d147 1
a147 1
	if ((username == NULL) && ((username = getlogin()) == NULL)) {
d179 2
a180 17
		rcsnum_tostr(frev, buf, sizeof(buf));

		if ((rdp = rcs_findrev(file, frev)) == NULL)
			return (-1);

		if (((flags & CO_STATE) &&
		    (strcmp(rdp->rd_state, state) != 0)) ||
		    ((flags & CO_AUTHOR) &&
		    (strcmp(rdp->rd_author, username) != 0))) {
			checkout_err_nobranch(file, username, NULL, state,
			    flags);
			return (-1);
		}

		if (flags & CO_STATE) {
			if (checkout_state(file, frev, argv[i], flags,
			    username, state) < 0) {
a182 7
			}
		} else {
			if (checkout_rev(file, frev, argv[i], flags,
				username) < 0) {
				rcs_close(file);
				continue;
			}
d210 2
d216 1
a216 1
    const char *username)
d218 2
a221 1
	BUF *bp;
d223 3
a225 1
	char *content;
d231 41
d274 11
d288 1
d295 4
a298 4
		if ((username != NULL)
		    && (rcs_lock_add(file, username, frev) < 0)) {
			if ((rcs_errno != RCS_ERR_DUPENT) && (verbose == 1))
				cvs_log(LP_ERR, "failed to lock '%s'", buf);
d305 2
a306 5
		if (rcs_lock_remove(file, frev) < 0) {
			if (rcs_errno != RCS_ERR_NOENT)
				cvs_log(LP_ERR,
				    "failed to remove lock '%s'", buf);
		}
d316 6
a373 26
}

/*
 * checkout_state()
 *
 * Search from supplied revision backwards until we find one
 * with state <state> and check that out.
 *
 * Returns 0 on success, -1 on checkout_rev failure.
 */
static int
checkout_state(RCSFILE *file, RCSNUM *rev, const char *dst, int flags,
    const char *username, const char *state)
{
	const char *tstate;
	
	if (rev == NULL)
		return (-1);
	else {
		if (((tstate = rcs_state_get(file, rev)) != NULL)
		    && (strcmp(state, tstate) == 0))
			return (checkout_rev(file, rev, dst, flags, username));
		else
			rev = rcsnum_dec(rev);
		return (checkout_state(file, rev, dst, flags, username, state));
	}
@


1.42
log
@`-mmsg' does not belong here;
@
text
@d41 1
a41 1
static int checkout_state(RCSFILE *, RCSNUM *, const char *, int,
d43 2
d55 1
d117 1
d171 12
d341 1
a341 3
	if (rev == NULL) {
		cvs_log(LP_ERR, "%s: No revision on branch has state %s",
		    file->rf_path, state);
d343 1
a343 1
	} else {
d351 24
@


1.41
log
@check for ownership of already present writable file when checking out;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.40 2005/11/30 14:29:22 xsa Exp $	*/
d197 3
a199 3
	    "usage: co [-V] [-ddate] [-f[rev]] [-I[rev]] [-kmode] [-l[rev]]\n"
	    "          [-M[rev]] [-mmsg] [-p[rev]] [-q[rev]] [-r[rev]]\n"
	    "          [-sstate] [-u[rev]] [-w[user]] [-xsuffixes] [-ztz] file ...\n");
@


1.40
log
@writeable -> writable
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.39 2005/11/29 11:11:39 xsa Exp $	*/
d257 1
a257 1
	if ((pipeout == 0) && (stat(dst, &st) != -1) && !(flags & FORCE)) {
d266 5
a270 2
			while (yn != 'y' && yn != 'n') {
				printf("writable %s exists; ", dst);
@


1.39
log
@consistency in variables naming;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.38 2005/11/29 10:55:37 xsa Exp $	*/
d262 1
a262 1
				    "writeable %s exists; checkout aborted",
d267 1
a267 1
				printf("writeable %s exists; ", dst);
@


1.38
log
@some more bits for `-w[user]' support;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.37 2005/11/25 13:50:01 xsa Exp $	*/
d218 1
a218 3
	/*
	 * Check out the latest revision if <frev> is greater than HEAD
	 */
d317 1
a317 1
checkout_state(RCSFILE *rfp, RCSNUM *rev, const char *dst, int flags,
d324 1
a324 1
		    rfp->rf_path, state);
d327 1
a327 1
		if (((tstate = rcs_state_get(rfp, rev)) != NULL)
d329 1
a329 1
			return (checkout_rev(rfp, rev, dst, flags, username));
d332 1
a332 1
		return (checkout_state(rfp, rev, dst, flags, username, state));
@


1.37
log
@add support for `-T' and enable it for co(1);
tested and OK niallo@@. "Looks good" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.36 2005/11/24 15:35:11 xsa Exp $	*/
d39 2
d52 1
a52 1
	const char *state = NULL;
d59 1
d61 1
a61 6
	if ((username = getlogin()) == NULL) {
		cvs_log(LP_ERRNO, "failed to get username");
		exit (1);
	}

	while ((ch = rcs_getopt(argc, argv, "f::k:l::M::p::q::r::s:Tu::Vx:")) != -1) {
d112 3
d133 5
d199 1
a199 1
	    "          [-sstate] [-u[rev]] [-wuser] [-xsuffixes] [-ztz] file ...\n");
d328 1
a328 2
	}
	else {
@


1.36
log
@memset();
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.35 2005/11/23 13:59:07 xsa Exp $	*/
d51 1
d63 1
a63 1
	while ((ch = rcs_getopt(argc, argv, "f::k:l::M::p::q::r::s:u::Vx:")) != -1) {
d148 6
a160 3
		if (kflag != RCS_KWEXP_ERR)
			rcs_kwexp_set(file, kflag);

d167 1
a167 2
		}
		else {
d176 3
@


1.35
log
@cannot combine -kv and -l;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.34 2005/11/23 09:39:20 xsa Exp $	*/
d284 1
a284 1
			bzero(&tv, sizeof(tv));
@


1.34
log
@initial bits for -T support;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.33 2005/11/23 09:05:02 xsa Exp $	*/
d138 5
@


1.33
log
@add support for `-kmode';
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.32 2005/11/23 08:42:23 xsa Exp $	*/
d102 3
@


1.32
log
@sync SYNOPSIS with Reality and usage() accordingly;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.31 2005/11/22 16:20:45 xsa Exp $	*/
d45 1
a45 2
	int i, ch;
	int flags;
d53 1
d62 1
a62 1
	while ((ch = rcs_getopt(argc, argv, "f::l::M::p::q::r::s:u::Vx:")) != -1) {
d68 9
d145 3
@


1.31
log
@make `-p' work again as expected;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.30 2005/11/21 16:20:29 xsa Exp $	*/
d62 1
a62 1
	while ((ch = rcs_getopt(argc, argv, "f::l::M::p::qr::s:u::Vx:")) != -1) {
d81 1
d165 3
a167 2
	    "usage: co [-qV] [-l[rev]] [-M[rev]] [-p[rev]] [-r[rev]]\n"
            "          [-sstate] [-u[rev]] file ...\n");
@


1.30
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.29 2005/11/08 09:22:47 xsa Exp $	*/
d225 1
a225 1
	if ((stat(dst, &st) != -1) && !(flags & FORCE)) {
@


1.29
log
@nuke trailing whitespaces;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.28 2005/11/03 16:08:03 niallo Exp $	*/
d62 1
a62 1
	while ((ch = rcs_getopt(argc, argv, "f::l::M::p::qr::s:u::V")) != -1) {
d100 3
@


1.28
log
@- update comment for checkout_rev() for bitwise flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.27 2005/11/03 15:41:52 niallo Exp $	*/
d167 1
a167 1
 * Currenly recognised <flags> are CO_LOCK, CO_UNLOCK and CO_REVDATE. 
@


1.27
log
@- sync checkout_usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.26 2005/11/03 15:40:40 niallo Exp $	*/
d167 1
a167 4
 * <lkmode> is either LOCK_LOCK or LOCK_UNLOCK or something else
 * (which has no effect).
 * In the case of LOCK_LOCK, a lock is set for <username> if it is not NULL.
 * In the case of LOCK_UNLOCK, all locks are removed for that revision.
@


1.26
log
@- implement `-M' option.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.25 2005/11/02 20:44:50 niallo Exp $	*/
d161 2
a162 2
	    "usage: co [-qV] [-l[rev]] [-p[rev]] [-r[rev]] [-sstate]\n"
            "          [-u[rev]] file ...\n");
@


1.25
log
@- update the comment for checkout_state(); it did not tell the truth
  about values returned.
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.24 2005/11/02 20:32:45 niallo Exp $	*/
d62 1
a62 1
	while ((ch = rcs_getopt(argc, argv, "f::l::p::qr::s:u::V")) != -1) {
d71 4
@


1.24
log
@changes from Venice:

- instead of using lots of individual flag variables, use a single int and
  bitwise operations on it. while this saves memory, really it saves code
  space and reduces complexity. checkout_rev() and checkout_state() in
  particular benefit from these changes since their parameters where growing
  really long.

- implement `-s' option in co

- implement `-M' option in ci

"I like this, go for it" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.23 2005/10/25 17:27:54 xsa Exp $	*/
d278 1
a278 2
 * Returns 0 on success, -1 on checkout_rev failure and -2 if there is no 
 * such state.
@


1.23
log
@nuke trailing whitespaces;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.22 2005/10/20 17:10:01 xsa Exp $	*/
d39 2
a40 2
#define LOCK_LOCK	1
#define LOCK_UNLOCK	2
d46 1
a46 1
	int fflag, lock;
d51 1
d53 1
a53 1
	fflag = lock = 0;
d62 1
a62 1
	while ((ch = rcs_getopt(argc, argv, "f::l::p::qr::u::V")) != -1) {
d66 1
a66 1
			fflag = 1;
d70 1
a70 1
			lock = LOCK_LOCK;
d82 7
d91 1
a91 1
			lock = LOCK_UNLOCK;
d129 13
a141 4
		if (checkout_rev(file, frev, argv[i], lock,
		    username, fflag) < 0) {
			rcs_close(file);
			continue;
d157 2
a158 1
	    "usage: co [-qV] [-l[rev]] [-r[rev]] [-u[rev]] file ...\n");
d171 2
a172 2
checkout_rev(RCSFILE *file, RCSNUM *frev, const char *dst, int lkmode,
    const char *username, int force)
d196 1
a196 1
	if (lkmode == LOCK_LOCK) {
d206 1
a206 1
	} else if (lkmode == LOCK_UNLOCK) {
d221 1
a221 1
	if ((stat(dst, &st) != -1) && force == 0) {
d256 8
d272 29
@


1.22
log
@fix output if -p is specified; joris ok
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.21 2005/10/19 11:37:11 niallo Exp $	*/
d121 2
a122 1
		if (checkout_rev(file, frev, argv[i], lock, username, fflag) < 0) { 
d166 1
a166 1
		frev = file->rf_head; 
@


1.21
log
@- make a bunch of changes to how we handle verbose output. this brings us
much closer in line with GNU RCS and cleans things up in general.

ok joris@@, "looks fine to me" xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.20 2005/10/19 00:30:22 joris Exp $	*/
d108 2
a109 1
			printf("%s  <--  %s\n", fpath, argv[i]);
@


1.20
log
@add co -p support;
input from xsa@@ and niallo@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.19 2005/10/18 01:22:14 joris Exp $	*/
d107 3
d179 1
a179 1
			if (rcs_errno != RCS_ERR_DUPENT)
a180 2
			else
				cvs_log(LP_WARN, "you already have a lock");
d204 6
d211 2
a212 2
				printf("writeable '%s' exists; ", dst);
				printf("remove it? [ny] (n):");
d218 1
a218 2
				if (verbose == 1)
					cvs_log(LP_ERR, "checkout aborted");
@


1.19
log
@use rcs_set_rev() instead of duplicating code all over the
place to set a variable to the given revision number;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.18 2005/10/17 15:33:12 joris Exp $	*/
d61 1
a61 1
	while ((ch = rcs_getopt(argc, argv, "f::l::qr::u::V")) != -1) {
d71 4
d155 1
d218 11
a228 2
	if (cvs_buf_write(bp, dst, mode) < 0) {
		cvs_log(LP_ERR, "failed to write revision to file");
d230 3
a232 1
		return (-1);
a233 5

	cvs_buf_free(bp);

	if (verbose == 1)
		printf("done\n");
@


1.18
log
@support -f flag for co;
'fine' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.17 2005/10/16 15:46:07 joris Exp $	*/
d64 1
a64 9
			if (rev != RCS_HEAD_REV)
				cvs_log(LP_WARN,
				    "redefinition of revision number");
			if (rcs_optarg != NULL) {
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit (1);
				}
			}
d68 1
a68 9
			if (rev != RCS_HEAD_REV)
				cvs_log(LP_WARN,
				    "redefinition of revision number");
			if (rcs_optarg != NULL) {
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit (1);
				}
			}
d75 1
a75 9
			if (rev != RCS_HEAD_REV)
				cvs_log(LP_WARN,
				    "redefinition of revision number");
			if (rcs_optarg != NULL) {
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit (1);
				}
			}
d78 1
a78 9
			if (rev != RCS_HEAD_REV)
				cvs_log(LP_WARN,
				    "redefinition of revision number");
			if (rcs_optarg != NULL) {
				if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
					cvs_log(LP_ERR, "bad revision number");
					exit (1);
				}
			}
@


1.17
log
@spacing;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.16 2005/10/16 11:59:06 niallo Exp $	*/
d46 1
a46 1
	int lock;
d52 1
a52 1
	lock = 0;
d61 1
a61 1
	while ((ch = rcs_getopt(argc, argv, "l::qr::u::V")) != -1) {
d63 12
d145 1
a145 1
		if (checkout_rev(file, frev, argv[i], lock, username) < 0) { 
d177 1
a177 1
    const char *username)
d179 1
a179 1
	char buf[16];
d182 1
d192 3
d208 1
d210 2
d218 1
d220 23
d253 2
a254 9
	if (verbose == 1) {
		cvs_printf("revision %s ", buf);
		if (lkmode == LOCK_LOCK)
			cvs_printf("(locked)");
		else if (lkmode == LOCK_UNLOCK)
			cvs_printf("(unlocked)");
		cvs_printf("\n");
		cvs_printf("done\n");
	}
@


1.16
log
@- sync checkout_usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.15 2005/10/15 21:23:54 niallo Exp $	*/
d130 1
d132 1
d137 1
d201 1
d207 1
d209 1
d219 1
@


1.15
log
@- if revision passed to checkout_rev() is > HEAD, assume HEAD
  (like GNU RCS).
- move verbose output into checkout_rev() function itself.

"looks sane" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.14 2005/10/15 18:26:24 niallo Exp $	*/
d148 1
a148 1
	    "usage: co [-qV] [-l [rev]] [-r [rev]] [-u [rev]] file ...\n");
@


1.14
log
@modularise checkout code into checkout_rev(). this shaves off a number
of lines in ci.c due to code re-use, and will simplify features which are in
the pipeline. no functional changes.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.13 2005/10/13 12:35:30 joris Exp $	*/
a135 9
		if (verbose == 1) {
			printf("revision %s ", buf);
			if (lock == LOCK_LOCK)
				printf("(locked)");
			else if (lock == LOCK_UNLOCK)
				printf("(unlocked)");
			printf("\n");
			printf("done\n");
		}
a166 1
	rcsnum_tostr(frev, buf, sizeof(buf));
d169 1
a169 2
	 * XXX: GNU RCS will check out the latest revision if <frev> is
	 * greater than HEAD
d171 5
d204 9
@


1.13
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.12 2005/10/12 17:43:18 xsa Exp $	*/
d49 1
a49 3
	BUF *bp;
	char buf[16];
	char fpath[MAXPATHLEN];
a50 1
	mode_t mode = 0444;
a129 1

d131 1
a131 26

		if ((bp = rcs_getrev(file, frev)) == NULL) {
			cvs_log(LP_ERR, "cannot find '%s' in %s", buf, fpath);
			rcs_close(file);
			continue;
		}

		if (lock == LOCK_LOCK) {
			if (rcs_lock_add(file, username, frev) < 0) {
				if (rcs_errno != RCS_ERR_DUPENT)
					cvs_log(LP_ERR, "failed to lock '%s'", buf);
				else
					cvs_log(LP_WARN, "you already have a lock");
			}
			mode = 0644;
		} else if (lock == LOCK_UNLOCK) {
			if (rcs_lock_remove(file, frev) < 0) {
				if (rcs_errno != RCS_ERR_NOENT)
					cvs_log(LP_ERR,
					    "failed to remove lock '%s'", buf);
			}
			mode = 0444;
		}
		if (cvs_buf_write(bp, argv[i], mode) < 0) {
			cvs_log(LP_ERR, "failed to write revision to file");
			cvs_buf_free(bp);
a134 3

		cvs_buf_free(bp);

d159 54
@


1.12
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.11 2005/10/12 17:13:30 deraadt Exp $	*/
d64 1
a64 1
	while ((ch = getopt(argc, argv, "l::qr::u::V")) != -1) {
d70 2
a71 2
			if (optarg != NULL) {
				if ((rev = rcsnum_parse(optarg)) == NULL) {
d85 2
a86 2
			if (optarg != NULL) {
				if ((rev = rcsnum_parse(optarg)) == NULL) {
d96 2
a97 2
			if (optarg != NULL) {
				if ((rev = rcsnum_parse(optarg)) == NULL) {
d113 2
a114 2
	argc -= optind;
	argv += optind;
@


1.11
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.10 2005/10/10 17:12:49 xsa Exp $	*/
d168 1
a168 1
		if (verbose) {
@


1.10
log
@getlogin(2) sets errno;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.9 2005/10/10 13:32:16 niallo Exp $	*/
a38 2
extern char *__progname;

d121 1
a121 1
	
d188 2
a189 2
	fprintf(stderr, "usage %s [-qV] [-l [rev]] [-r [rev]] [-u [rev]]"
	    " file ...\n", __progname);
@


1.9
log
@sync checkout_usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.8 2005/10/10 13:20:20 niallo Exp $	*/
d62 1
a62 1
		cvs_log(LP_ERR, "failed to get username");
@


1.8
log
@- set permissions on checked out files correctly
- support bare `-u' and `-l' options which will check out HEAD.

note that with OpenRCS you must do `co -l -- <file>' and `co -u -- <file>'
when using bare arguments because our getopt(3) is POSIX compliant.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.7 2005/10/05 12:06:23 joris Exp $	*/
d190 2
a191 2
	fprintf(stderr, "usage %s [-qV] [-l rev] [-r rev] [-u rev] file ...\n",
	    __progname);
@


1.7
log
@sync usage and add V flag;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.6 2005/10/05 11:52:16 joris Exp $	*/
d55 1
d66 1
a66 1
	while ((ch = getopt(argc, argv, "l:qr:u:V")) != -1) {
d72 5
a76 4

			if ((rev = rcsnum_parse(optarg)) == NULL) {
				cvs_log(LP_ERR, "bad revision number");
				exit (1);
a77 1

d87 5
a91 4

			if ((rev = rcsnum_parse(optarg)) == NULL) {
				cvs_log(LP_ERR, "bad revision number");
				exit(1);
a92 1

a94 1
			lock = LOCK_UNLOCK;
d98 5
a102 4

			if ((rev = rcsnum_parse(optarg)) == NULL) {
				cvs_log(LP_ERR, "bad revision number");
				exit (1);
d104 1
a104 1

a143 9
		if (cvs_buf_write(bp, argv[i], 0644) < 0) {
			cvs_log(LP_ERR, "failed to write revision to file");
			cvs_buf_free(bp);
			rcs_close(file);
			continue;
		}

		cvs_buf_free(bp);

d151 2
a152 1
		} else 	if (lock == LOCK_UNLOCK) {
d158 1
d160 8
@


1.6
log
@- stop gcc's yapping;
- better output when locking and unlocking revisions;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.5 2005/10/05 00:44:19 joris Exp $	*/
d65 1
a65 1
	while ((ch = getopt(argc, argv, "l:qr:u:")) != -1) {
d105 3
d188 2
a189 1
	fprintf(stderr, "usage %s [-r rev] file ...\n", __progname);
@


1.5
log
@- better output
- free frev when done
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.4 2005/10/04 23:04:33 joris Exp $	*/
d58 1
d166 6
a171 2
			printf("revision %s (%s)\n", buf, (lock == LOCK_LOCK) ?
			    "locked" : "unlocked");
@


1.4
log
@- support -l and -u flags;
- better output;
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.3 2005/09/29 21:30:10 joris Exp $	*/
a153 3
			} else {
				if (verbose)
					printf("(locked)");
d172 1
a172 1
		rcsnum_free(rev);
@


1.3
log
@support -q flag in 'co' and 'rcs'
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.2 2005/09/29 15:21:57 joris Exp $	*/
d33 1
d41 3
d48 2
a49 1
	RCSNUM *rev;
d53 2
a54 1
	char *s, fpath[MAXPATHLEN];
d56 1
d58 7
a64 1
	while ((ch = getopt(argc, argv, "qr:")) != -1) {
d66 12
d82 4
d90 13
d123 1
a123 1
		if ((file = rcs_open(fpath, RCS_READ)) == NULL)
d126 4
a129 2
		if ((s = strrchr(fpath, ',')) != NULL)
			*s = '\0';
d131 4
a134 3
		if ((bp = rcs_getrev(file, rev)) == NULL) {
			cvs_log(LP_ERR, "cannot find '%s' in %s",
			    rcsnum_tostr(rev, buf, sizeof(buf)), fpath);
d139 1
a139 1
		if (cvs_buf_write(bp, fpath, 0644) < 0)
d141 4
d147 19
d167 5
@


1.2
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: co.c,v 1.1 2005/09/29 15:16:26 joris Exp $	*/
d51 1
a51 1
	while ((ch = getopt(argc, argv, "r:")) != -1) {
d53 3
@


1.1
log
@put it basic checkout code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 1
	fprintf(stderr, "usage %s\n", __progname);
@

