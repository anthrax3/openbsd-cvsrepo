head	1.85;
access;
symbols
	OPENBSD_6_2:1.85.0.4
	OPENBSD_6_2_BASE:1.85
	OPENBSD_6_1:1.85.0.6
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.85.0.2
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.82.0.2
	OPENBSD_5_7_BASE:1.82
	OPENBSD_5_6:1.80.0.6
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.79.0.6
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.79.0.4
	OPENBSD_5_3_BASE:1.79
	OPENBSD_5_2:1.79.0.2
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.4
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.60.0.2
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.54.0.2
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32;
locks; strict;
comment	@ * @;


1.85
date	2016.05.09.13.03.55;	author schwarze;	state Exp;
branches;
next	1.84;
commitid	MpUv5TKAVMeSudmn;

1.84
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.83;
commitid	aZp5pu4rATnp3dyP;

1.83
date	2015.06.13.20.15.21;	author nicm;	state Exp;
branches;
next	1.82;
commitid	FFUg8uzT5GNAfRXp;

1.82
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	Uu5nFG3wCl0LACBb;

1.81
date	2014.10.10.08.15.25;	author otto;	state Exp;
branches;
next	1.80;
commitid	nj4mpSZoLV0jWhzi;

1.80
date	2014.01.07.14.08.16;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2012.03.03.08.34.27;	author nicm;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.14.16.38.39;	author sobrado;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.06.15.36.52;	author nicm;	state Exp;
branches;
next	1.76;

1.76
date	2011.05.20.19.21.10;	author nicm;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.20.19.34.16;	author nicm;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.04.23.08.30;	author djm;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.27.18.22.50;	author jasper;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.10.09.48.43;	author jasper;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.27.08.35.45;	author tobias;	state Exp;
branches;
next	1.70;

1.70
date	2010.10.20.19.55.46;	author tobias;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.20.19.53.53;	author tobias;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.15.08.44.12;	author tobias;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.05.15.16.48;	author tobias;	state Exp;
branches;
next	1.66;

1.66
date	2010.10.05.15.13.04;	author tobias;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.29.09.23.54;	author tobias;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.23.17.59.03;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.11.07.26.00;	author tobias;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.02.00.21.41;	author tobias;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.31.20.43.45;	author tobias;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.23.08.31.19;	author ray;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.21.09.22.19;	author ray;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.13.20.07.24;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.09.20.07.05;	author naddy;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.14.21.16.40;	author jj;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.25.23.16.20;	author ray;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.15.13.40.33;	author joris;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.09.08.51.43;	author tobias;	state Exp;
branches;
next	1.50;

1.50
date	2008.11.08.11.48.49;	author tobias;	state Exp;
branches;
next	1.49;

1.49
date	2008.10.09.21.45.05;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.17.06.47.57;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.11.12.13.41;	author tobias;	state Exp;
branches;
next	1.46;

1.46
date	2008.02.02.16.21.38;	author xsa;	state Exp;
branches;
next	1.45;

1.45
date	2008.01.31.16.36.11;	author tobias;	state Exp;
branches;
next	1.44;

1.44
date	2008.01.06.14.45.50;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.06.09.12.17;	author sturm;	state Exp;
branches;
next	1.42;

1.42
date	2007.08.27.19.18.05;	author xsa;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.03.00.56.23;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.13.18.01.22;	author niallo;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.29.00.19.10;	author ray;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.17.03.33.24;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.35;

1.35
date	2007.01.02.16.43.45;	author niallo;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.21.15.37.44;	author niallo;	state Exp;
branches;
next	1.33;

1.33
date	2006.09.21.15.30.07;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.23.11.49.49;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.07.20.55.28;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.04.06.13.54;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.28.05.41.45;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.27.04.23.37;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.27.02.58.31;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.27.02.57.19;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.21.00.47.35;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.21.00.21.52;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.11.18.36.32;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.08.09.25.44;	author ray;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.08.07.48.58;	author niallo;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.11.22.25.35;	author niallo;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.11.22.21.23;	author niallo;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.09.22.09.33;	author niallo;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.04.18.57.37;	author niallo;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.04.03.00.29;	author niallo;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.04.02.56.53;	author niallo;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.04.02.54.59;	author niallo;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.04.02.54.07;	author niallo;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.03.03.05.10;	author niallo;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.28.18.33.49;	author ray;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.27.08.12.29;	author ray;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.11.07.34.26;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.08.16.56.40;	author xsa;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.04.07.06.58;	author xsa;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.01.18.17.39;	author niallo;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.29.05.31.28;	author ray;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.27.07.59.33;	author xsa;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.26.15.08.25;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	;


desc
@@


1.85
log
@Implement Mdocdate keyword substitution.
In particular, this stops rcsdiff(1) and CVSweb from showing
wrong Mdocdate lines in diffs.
Problem originally reported by tj@@.
OK tobias@@ otto@@ millert@@
@
text
@/*	$OpenBSD: rcs.c,v 1.84 2015/11/02 16:45:21 nicm Exp $	*/
/*
 * Copyright (c) 2004 Jean-Francois Brousseau <jfb@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>	/* MAXBSIZE */
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <libgen.h>
#include <pwd.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "diff.h"
#include "rcs.h"
#include "rcsparse.h"
#include "rcsprog.h"
#include "rcsutil.h"
#include "xmalloc.h"

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))

/* invalid characters in RCS states */
static const char rcs_state_invch[] = RCS_STATE_INVALCHAR;

/* invalid characters in RCS symbol names */
static const char rcs_sym_invch[] = RCS_SYM_INVALCHAR;

struct rcs_kw rcs_expkw[] =  {
	{ "Author",	RCS_KW_AUTHOR   },
	{ "Date",	RCS_KW_DATE     },
	{ "Locker",	RCS_KW_LOCKER   },
	{ "Header",	RCS_KW_HEADER   },
	{ "Id",		RCS_KW_ID       },
	{ "OpenBSD",	RCS_KW_ID       },
	{ "Log",	RCS_KW_LOG      },
	{ "Name",	RCS_KW_NAME     },
	{ "RCSfile",	RCS_KW_RCSFILE  },
	{ "Revision",	RCS_KW_REVISION },
	{ "Source",	RCS_KW_SOURCE   },
	{ "State",	RCS_KW_STATE    },
	{ "Mdocdate",	RCS_KW_MDOCDATE },
};

int rcs_errno = RCS_ERR_NOERR;
char *timezone_flag = NULL;

int		rcs_patch_lines(struct rcs_lines *, struct rcs_lines *);
static int	rcs_movefile(char *, char *, mode_t, u_int);

static void	rcs_freedelta(struct rcs_delta *);
static void	rcs_strprint(const u_char *, size_t, FILE *);

static BUF	*rcs_expand_keywords(char *, struct rcs_delta *, BUF *, int);

RCSFILE *
rcs_open(const char *path, int fd, int flags, ...)
{
	int mode;
	mode_t fmode;
	RCSFILE *rfp;
	va_list vap;
	struct rcs_delta *rdp;
	struct rcs_lock *lkr;

	fmode = S_IRUSR|S_IRGRP|S_IROTH;
	flags &= 0xffff;	/* ditch any internal flags */

	if (flags & RCS_CREATE) {
		va_start(vap, flags);
		mode = va_arg(vap, int);
		va_end(vap);
		fmode = (mode_t)mode;
	}

	rfp = xcalloc(1, sizeof(*rfp));

	rfp->rf_path = xstrdup(path);
	rfp->rf_flags = flags | RCS_SLOCK | RCS_SYNCED;
	rfp->rf_mode = fmode;
	if (fd == -1)
		rfp->rf_file = NULL;
	else if ((rfp->rf_file = fdopen(fd, "r")) == NULL)
		err(1, "rcs_open: fdopen: `%s'", path);

	TAILQ_INIT(&(rfp->rf_delta));
	TAILQ_INIT(&(rfp->rf_access));
	TAILQ_INIT(&(rfp->rf_symbols));
	TAILQ_INIT(&(rfp->rf_locks));

	if (!(rfp->rf_flags & RCS_CREATE)) {
		if (rcsparse_init(rfp))
			errx(1, "could not parse admin data");

		/* fill in rd_locker */
		TAILQ_FOREACH(lkr, &(rfp->rf_locks), rl_list) {
			if ((rdp = rcs_findrev(rfp, lkr->rl_num)) == NULL) {
				rcs_close(rfp);
				return (NULL);
			}

			rdp->rd_locker = xstrdup(lkr->rl_name);
		}
	}

	return (rfp);
}

/*
 * rcs_close()
 *
 * Close an RCS file handle.
 */
void
rcs_close(RCSFILE *rfp)
{
	struct rcs_delta *rdp;
	struct rcs_access *rap;
	struct rcs_lock *rlp;
	struct rcs_sym *rsp;

	if ((rfp->rf_flags & RCS_WRITE) && !(rfp->rf_flags & RCS_SYNCED))
		rcs_write(rfp);

	while (!TAILQ_EMPTY(&(rfp->rf_delta))) {
		rdp = TAILQ_FIRST(&(rfp->rf_delta));
		TAILQ_REMOVE(&(rfp->rf_delta), rdp, rd_list);
		rcs_freedelta(rdp);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_access))) {
		rap = TAILQ_FIRST(&(rfp->rf_access));
		TAILQ_REMOVE(&(rfp->rf_access), rap, ra_list);
		free(rap->ra_name);
		free(rap);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_symbols))) {
		rsp = TAILQ_FIRST(&(rfp->rf_symbols));
		TAILQ_REMOVE(&(rfp->rf_symbols), rsp, rs_list);
		rcsnum_free(rsp->rs_num);
		free(rsp->rs_name);
		free(rsp);
	}

	while (!TAILQ_EMPTY(&(rfp->rf_locks))) {
		rlp = TAILQ_FIRST(&(rfp->rf_locks));
		TAILQ_REMOVE(&(rfp->rf_locks), rlp, rl_list);
		rcsnum_free(rlp->rl_num);
		free(rlp->rl_name);
		free(rlp);
	}

	rcsnum_free(rfp->rf_head);
	rcsnum_free(rfp->rf_branch);

	if (rfp->rf_file != NULL)
		fclose(rfp->rf_file);

	free(rfp->rf_path);
	free(rfp->rf_comment);
	free(rfp->rf_expand);
	free(rfp->rf_desc);
	if (rfp->rf_pdata != NULL)
		rcsparse_free(rfp);

	free(rfp);
}

/*
 * rcs_write()
 *
 * Write the contents of the RCS file handle <rfp> to disk in the file whose
 * path is in <rf_path>.
 */
void
rcs_write(RCSFILE *rfp)
{
	FILE *fp;
	char numbuf[RCS_REV_BUFSZ], *fn;
	struct rcs_access *ap;
	struct rcs_sym *symp;
	struct rcs_branch *brp;
	struct rcs_delta *rdp;
	struct rcs_lock *lkp;
	size_t len;
	int fd;

	fn = NULL;

	if (rfp->rf_flags & RCS_SYNCED)
		return;

	/* Write operations need the whole file parsed */
	if (rcsparse_deltatexts(rfp, NULL))
		errx(1, "problem parsing deltatexts");

	(void)xasprintf(&fn, "%s/rcs.XXXXXXXXXX", rcs_tmpdir);

	if ((fd = mkstemp(fn)) == -1)
		err(1, "%s", fn);

	if ((fp = fdopen(fd, "w+")) == NULL) {
		int saved_errno;

		saved_errno = errno;
		(void)unlink(fn);
		errno = saved_errno;
		err(1, "%s", fn);
	}

	worklist_add(fn, &temp_files);

	if (rfp->rf_head != NULL)
		rcsnum_tostr(rfp->rf_head, numbuf, sizeof(numbuf));
	else
		numbuf[0] = '\0';

	fprintf(fp, "head\t%s;\n", numbuf);

	if (rfp->rf_branch != NULL) {
		rcsnum_tostr(rfp->rf_branch, numbuf, sizeof(numbuf));
		fprintf(fp, "branch\t%s;\n", numbuf);
	}

	fputs("access", fp);
	TAILQ_FOREACH(ap, &(rfp->rf_access), ra_list) {
		fprintf(fp, "\n\t%s", ap->ra_name);
	}
	fputs(";\n", fp);

	fprintf(fp, "symbols");
	TAILQ_FOREACH(symp, &(rfp->rf_symbols), rs_list) {
		if (RCSNUM_ISBRANCH(symp->rs_num))
			rcsnum_addmagic(symp->rs_num);
		rcsnum_tostr(symp->rs_num, numbuf, sizeof(numbuf));
		fprintf(fp, "\n\t%s:%s", symp->rs_name, numbuf);
	}
	fprintf(fp, ";\n");

	fprintf(fp, "locks");
	TAILQ_FOREACH(lkp, &(rfp->rf_locks), rl_list) {
		rcsnum_tostr(lkp->rl_num, numbuf, sizeof(numbuf));
		fprintf(fp, "\n\t%s:%s", lkp->rl_name, numbuf);
	}

	fprintf(fp, ";");

	if (rfp->rf_flags & RCS_SLOCK)
		fprintf(fp, " strict;");
	fputc('\n', fp);

	fputs("comment\t@@", fp);
	if (rfp->rf_comment != NULL) {
		rcs_strprint((const u_char *)rfp->rf_comment,
		    strlen(rfp->rf_comment), fp);
		fputs("@@;\n", fp);
	} else
		fputs("# @@;\n", fp);

	if (rfp->rf_expand != NULL) {
		fputs("expand @@", fp);
		rcs_strprint((const u_char *)rfp->rf_expand,
		    strlen(rfp->rf_expand), fp);
		fputs("@@;\n", fp);
	}

	fputs("\n\n", fp);

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		fprintf(fp, "%s\n", rcsnum_tostr(rdp->rd_num, numbuf,
		    sizeof(numbuf)));
		fprintf(fp, "date\t%d.%02d.%02d.%02d.%02d.%02d;",
		    rdp->rd_date.tm_year + 1900, rdp->rd_date.tm_mon + 1,
		    rdp->rd_date.tm_mday, rdp->rd_date.tm_hour,
		    rdp->rd_date.tm_min, rdp->rd_date.tm_sec);
		fprintf(fp, "\tauthor %s;\tstate %s;\n",
		    rdp->rd_author, rdp->rd_state);
		fputs("branches", fp);
		TAILQ_FOREACH(brp, &(rdp->rd_branches), rb_list) {
			fprintf(fp, "\n\t%s", rcsnum_tostr(brp->rb_num, numbuf,
			    sizeof(numbuf)));
		}
		fputs(";\n", fp);
		fprintf(fp, "next\t%s;\n\n", rcsnum_tostr(rdp->rd_next,
		    numbuf, sizeof(numbuf)));
	}

	fputs("\ndesc\n@@", fp);
	if (rfp->rf_desc != NULL && (len = strlen(rfp->rf_desc)) > 0) {
		rcs_strprint((const u_char *)rfp->rf_desc, len, fp);
		if (rfp->rf_desc[len-1] != '\n')
			fputc('\n', fp);
	}
	fputs("@@\n", fp);

	/* deltatexts */
	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		fprintf(fp, "\n\n%s\n", rcsnum_tostr(rdp->rd_num, numbuf,
		    sizeof(numbuf)));
		fputs("log\n@@", fp);
		if (rdp->rd_log != NULL) {
			len = strlen(rdp->rd_log);
			rcs_strprint((const u_char *)rdp->rd_log, len, fp);
			if (len == 0 || rdp->rd_log[len-1] != '\n')
				fputc('\n', fp);
		}
		fputs("@@\ntext\n@@", fp);
		if (rdp->rd_text != NULL)
			rcs_strprint(rdp->rd_text, rdp->rd_tlen, fp);
		fputs("@@\n", fp);
	}
	(void)fclose(fp);

	if (rcs_movefile(fn, rfp->rf_path, rfp->rf_mode, rfp->rf_flags) == -1) {
		(void)unlink(fn);
		errx(1, "rcs_movefile failed");
	}

	rfp->rf_flags |= RCS_SYNCED;

	free(fn);
}

/*
 * rcs_movefile()
 *
 * Move a file using rename(2) if possible and copying if not.
 * Returns 0 on success, -1 on failure.
 */
static int
rcs_movefile(char *from, char *to, mode_t perm, u_int to_flags)
{
	FILE *src, *dst;
	size_t nread, nwritten;
	char *buf;

	if (rename(from, to) == 0) {
		if (chmod(to, perm) == -1) {
			warn("%s", to);
			return (-1);
		}
		return (0);
	} else if (errno != EXDEV) {
		warn("failed to access temp RCS output file");
		return (-1);
	}

	if ((chmod(to, S_IWUSR) == -1) && !(to_flags & RCS_CREATE)) {
		warnx("chmod(%s, 0%o) failed", to, S_IWUSR);
		return (-1);
	}

	/* different filesystem, have to copy the file */
	if ((src = fopen(from, "r")) == NULL) {
		warn("%s", from);
		return (-1);
	}
	if ((dst = fopen(to, "w")) == NULL) {
		warn("%s", to);
		(void)fclose(src);
		return (-1);
	}
	if (fchmod(fileno(dst), perm)) {
		warn("%s", to);
		(void)unlink(to);
		(void)fclose(src);
		(void)fclose(dst);
		return (-1);
	}

	buf = xmalloc(MAXBSIZE);
	while ((nread = fread(buf, sizeof(char), MAXBSIZE, src)) != 0) {
		if (ferror(src)) {
			warnx("failed to read `%s'", from);
			(void)unlink(to);
			goto out;
		}
		nwritten = fwrite(buf, sizeof(char), nread, dst);
		if (nwritten != nread) {
			warnx("failed to write `%s'", to);
			(void)unlink(to);
			goto out;
		}
	}

	(void)unlink(from);

out:
	(void)fclose(src);
	(void)fclose(dst);
	free(buf);

	return (0);
}

/*
 * rcs_head_set()
 *
 * Set the revision number of the head revision for the RCS file <file> to
 * <rev>, which must reference a valid revision within the file.
 */
int
rcs_head_set(RCSFILE *file, RCSNUM *rev)
{
	if (rcs_findrev(file, rev) == NULL)
		return (-1);

	if (file->rf_head == NULL)
		file->rf_head = rcsnum_alloc();

	rcsnum_cpy(rev, file->rf_head, 0);
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}


/*
 * rcs_branch_get()
 *
 * Retrieve the default branch number for the RCS file <file>.
 * Returns the number on success.  If NULL is returned, then there is no
 * default branch for this file.
 */
const RCSNUM *
rcs_branch_get(RCSFILE *file)
{
	return (file->rf_branch);
}

/*
 * rcs_access_add()
 *
 * Add the login name <login> to the access list for the RCS file <file>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_access_add(RCSFILE *file, const char *login)
{
	struct rcs_access *ap;

	/* first look for duplication */
	TAILQ_FOREACH(ap, &(file->rf_access), ra_list) {
		if (strcmp(ap->ra_name, login) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
			return (-1);
		}
	}

	ap = xmalloc(sizeof(*ap));
	ap->ra_name = xstrdup(login);
	TAILQ_INSERT_TAIL(&(file->rf_access), ap, ra_list);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_access_remove()
 *
 * Remove an entry with login name <login> from the access list of the RCS
 * file <file>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_access_remove(RCSFILE *file, const char *login)
{
	struct rcs_access *ap;

	TAILQ_FOREACH(ap, &(file->rf_access), ra_list)
		if (strcmp(ap->ra_name, login) == 0)
			break;

	if (ap == NULL) {
		rcs_errno = RCS_ERR_NOENT;
		return (-1);
	}

	TAILQ_REMOVE(&(file->rf_access), ap, ra_list);
	free(ap->ra_name);
	free(ap);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_add()
 *
 * Add a symbol to the list of symbols for the RCS file <rfp>.  The new symbol
 * is named <sym> and is bound to the RCS revision <snum>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_sym_add(RCSFILE *rfp, const char *sym, RCSNUM *snum)
{
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
		return (-1);
	}

	/* first look for duplication */
	TAILQ_FOREACH(symp, &(rfp->rf_symbols), rs_list) {
		if (strcmp(symp->rs_name, sym) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
			return (-1);
		}
	}

	symp = xmalloc(sizeof(*symp));
	symp->rs_name = xstrdup(sym);
	symp->rs_num = rcsnum_alloc();
	rcsnum_cpy(snum, symp->rs_num, 0);

	TAILQ_INSERT_HEAD(&(rfp->rf_symbols), symp, rs_list);

	/* not synced anymore */
	rfp->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_remove()
 *
 * Remove the symbol with name <sym> from the symbol list for the RCS file
 * <file>.  If no such symbol is found, the call fails and returns with an
 * error.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_sym_remove(RCSFILE *file, const char *sym)
{
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
		return (-1);
	}

	TAILQ_FOREACH(symp, &(file->rf_symbols), rs_list)
		if (strcmp(symp->rs_name, sym) == 0)
			break;

	if (symp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
		return (-1);
	}

	TAILQ_REMOVE(&(file->rf_symbols), symp, rs_list);
	free(symp->rs_name);
	rcsnum_free(symp->rs_num);
	free(symp);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_sym_getrev()
 *
 * Retrieve the RCS revision number associated with the symbol <sym> for the
 * RCS file <file>.  The returned value is a dynamically-allocated copy and
 * should be freed by the caller once they are done with it.
 * Returns the RCSNUM on success, or NULL on failure.
 */
RCSNUM *
rcs_sym_getrev(RCSFILE *file, const char *sym)
{
	RCSNUM *num;
	struct rcs_sym *symp;

	if (!rcs_sym_check(sym)) {
		rcs_errno = RCS_ERR_BADSYM;
		return (NULL);
	}

	num = NULL;
	TAILQ_FOREACH(symp, &(file->rf_symbols), rs_list)
		if (strcmp(symp->rs_name, sym) == 0)
			break;

	if (symp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
	} else {
		num = rcsnum_alloc();
		rcsnum_cpy(symp->rs_num, num, 0);
	}

	return (num);
}

/*
 * rcs_sym_check()
 *
 * Check the RCS symbol name <sym> for any unsupported characters.
 * Returns 1 if the tag is correct, 0 if it isn't valid.
 */
int
rcs_sym_check(const char *sym)
{
	int ret;
	const unsigned char *cp;

	ret = 1;
	cp = sym;
	if (!isalpha(*cp++))
		return (0);

	for (; *cp != '\0'; cp++)
		if (!isgraph(*cp) || (strchr(rcs_sym_invch, *cp) != NULL)) {
			ret = 0;
			break;
		}

	return (ret);
}

/*
 * rcs_lock_getmode()
 *
 * Retrieve the locking mode of the RCS file <file>.
 */
int
rcs_lock_getmode(RCSFILE *file)
{
	return (file->rf_flags & RCS_SLOCK) ? RCS_LOCK_STRICT : RCS_LOCK_LOOSE;
}

/*
 * rcs_lock_setmode()
 *
 * Set the locking mode of the RCS file <file> to <mode>, which must either
 * be RCS_LOCK_LOOSE or RCS_LOCK_STRICT.
 * Returns the previous mode on success, or -1 on failure.
 */
int
rcs_lock_setmode(RCSFILE *file, int mode)
{
	int pmode;
	pmode = rcs_lock_getmode(file);

	if (mode == RCS_LOCK_STRICT)
		file->rf_flags |= RCS_SLOCK;
	else if (mode == RCS_LOCK_LOOSE)
		file->rf_flags &= ~RCS_SLOCK;
	else
		errx(1, "rcs_lock_setmode: invalid mode `%d'", mode);

	file->rf_flags &= ~RCS_SYNCED;
	return (pmode);
}

/*
 * rcs_lock_add()
 *
 * Add an RCS lock for the user <user> on revision <rev>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_lock_add(RCSFILE *file, const char *user, RCSNUM *rev)
{
	struct rcs_lock *lkp;

	/* first look for duplication */
	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
		if (strcmp(lkp->rl_name, user) == 0 &&
		    rcsnum_cmp(rev, lkp->rl_num, 0) == 0) {
			rcs_errno = RCS_ERR_DUPENT;
			return (-1);
		}
	}

	lkp = xmalloc(sizeof(*lkp));
	lkp->rl_name = xstrdup(user);
	lkp->rl_num = rcsnum_alloc();
	rcsnum_cpy(rev, lkp->rl_num, 0);

	TAILQ_INSERT_TAIL(&(file->rf_locks), lkp, rl_list);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}


/*
 * rcs_lock_remove()
 *
 * Remove the RCS lock on revision <rev>.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_lock_remove(RCSFILE *file, const char *user, RCSNUM *rev)
{
	struct rcs_lock *lkp;

	TAILQ_FOREACH(lkp, &(file->rf_locks), rl_list) {
		if (strcmp(lkp->rl_name, user) == 0 &&
		    rcsnum_cmp(lkp->rl_num, rev, 0) == 0)
			break;
	}

	if (lkp == NULL) {
		rcs_errno = RCS_ERR_NOENT;
		return (-1);
	}

	TAILQ_REMOVE(&(file->rf_locks), lkp, rl_list);
	rcsnum_free(lkp->rl_num);
	free(lkp->rl_name);
	free(lkp);

	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
 * rcs_desc_set()
 *
 * Set the description for the RCS file <file>.
 */
void
rcs_desc_set(RCSFILE *file, const char *desc)
{
	char *tmp;

	tmp = xstrdup(desc);
	free(file->rf_desc);
	file->rf_desc = tmp;
	file->rf_flags &= ~RCS_SYNCED;
}

/*
 * rcs_comment_set()
 *
 * Set the comment leader for the RCS file <file>.
 */
void
rcs_comment_set(RCSFILE *file, const char *comment)
{
	char *tmp;

	tmp = xstrdup(comment);
	free(file->rf_comment);
	file->rf_comment = tmp;
	file->rf_flags &= ~RCS_SYNCED;
}

int
rcs_patch_lines(struct rcs_lines *dlines, struct rcs_lines *plines)
{
	char op, *ep;
	struct rcs_line *lp, *dlp, *ndlp;
	int i, lineno, nbln;
	u_char tmp;

	dlp = TAILQ_FIRST(&(dlines->l_lines));
	lp = TAILQ_FIRST(&(plines->l_lines));

	/* skip first bogus line */
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
	    lp = TAILQ_NEXT(lp, l_list)) {
		if (lp->l_len < 2)
			errx(1, "line too short, RCS patch seems broken");
		op = *(lp->l_line);
		/* NUL-terminate line buffer for strtol() safety. */
		tmp = lp->l_line[lp->l_len - 1];
		lp->l_line[lp->l_len - 1] = '\0';
		lineno = (int)strtol((lp->l_line + 1), &ep, 10);
		if (lineno > dlines->l_nblines || lineno < 0 ||
		    *ep != ' ')
			errx(1, "invalid line specification in RCS patch");
		ep++;
		nbln = (int)strtol(ep, &ep, 10);
		/* Restore the last byte of the buffer */
		lp->l_line[lp->l_len - 1] = tmp;
		if (nbln < 0)
			errx(1,
			    "invalid line number specification in RCS patch");

		/* find the appropriate line */
		for (;;) {
			if (dlp == NULL)
				break;
			if (dlp->l_lineno == lineno)
				break;
			if (dlp->l_lineno > lineno) {
				dlp = TAILQ_PREV(dlp, tqh, l_list);
			} else if (dlp->l_lineno < lineno) {
				if (((ndlp = TAILQ_NEXT(dlp, l_list)) == NULL) ||
				    ndlp->l_lineno > lineno)
					break;
				dlp = ndlp;
			}
		}
		if (dlp == NULL)
			errx(1, "can't find referenced line in RCS patch");

		if (op == 'd') {
			for (i = 0; (i < nbln) && (dlp != NULL); i++) {
				ndlp = TAILQ_NEXT(dlp, l_list);
				TAILQ_REMOVE(&(dlines->l_lines), dlp, l_list);
				free(dlp);
				dlp = ndlp;
				/* last line is gone - reset dlp */
				if (dlp == NULL) {
					ndlp = TAILQ_LAST(&(dlines->l_lines),
					    tqh);
					dlp = ndlp;
				}
			}
		} else if (op == 'a') {
			for (i = 0; i < nbln; i++) {
				ndlp = lp;
				lp = TAILQ_NEXT(lp, l_list);
				if (lp == NULL)
					errx(1, "truncated RCS patch");
				TAILQ_REMOVE(&(plines->l_lines), lp, l_list);
				TAILQ_INSERT_AFTER(&(dlines->l_lines), dlp,
				    lp, l_list);
				dlp = lp;

				/* we don't want lookup to block on those */
				lp->l_lineno = lineno;

				lp = ndlp;
			}
		} else
			errx(1, "unknown RCS patch operation `%c'", op);

		/* last line of the patch, done */
		if (lp->l_lineno == plines->l_nblines)
			break;
	}

	/* once we're done patching, rebuild the line numbers */
	lineno = 0;
	TAILQ_FOREACH(lp, &(dlines->l_lines), l_list)
		lp->l_lineno = lineno++;
	dlines->l_nblines = lineno - 1;

	return (0);
}

/*
 * rcs_getrev()
 *
 * Get the whole contents of revision <rev> from the RCSFILE <rfp>.  The
 * returned buffer is dynamically allocated and should be released using
 * buf_free() once the caller is done using it.
 */
BUF *
rcs_getrev(RCSFILE *rfp, RCSNUM *frev)
{
	u_int i, numlen;
	int isbranch, lookonbranch, found;
	size_t dlen, plen, len;
	RCSNUM *crev, *rev, *brev;
	BUF *rbuf;
	struct rcs_delta *rdp = NULL;
	struct rcs_branch *rb;
	u_char *data, *patch;

	if (rfp->rf_head == NULL)
		return (NULL);

	if (frev == RCS_HEAD_REV)
		rev = rfp->rf_head;
	else
		rev = frev;

	/* XXX rcsnum_cmp() */
	for (i = 0; i < rfp->rf_head->rn_len; i++) {
		if (rfp->rf_head->rn_id[i] < rev->rn_id[i]) {
			rcs_errno = RCS_ERR_NOENT;
			return (NULL);
		}
	}

	/* No matter what, we'll need everything parsed up until the description
           so go for it. */
	if (rcsparse_deltas(rfp, NULL))
		return (NULL);

	rdp = rcs_findrev(rfp, rfp->rf_head);
	if (rdp == NULL) {
		warnx("failed to get RCS HEAD revision");
		return (NULL);
	}

	if (rdp->rd_tlen == 0)
		if (rcsparse_deltatexts(rfp, rfp->rf_head))
			return (NULL);

	len = rdp->rd_tlen;
	if (len == 0) {
		rbuf = buf_alloc(1);
		buf_empty(rbuf);
		return (rbuf);
	}

	rbuf = buf_alloc(len);
	buf_append(rbuf, rdp->rd_text, len);

	isbranch = 0;
	brev = NULL;

	/*
	 * If a branch was passed, get the latest revision on it.
	 */
	if (RCSNUM_ISBRANCH(rev)) {
		brev = rev;
		rdp = rcs_findrev(rfp, rev);
		if (rdp == NULL) {
			buf_free(rbuf);
			return (NULL);
		}

		rev = rdp->rd_num;
	} else {
		if (RCSNUM_ISBRANCHREV(rev)) {
			brev = rcsnum_revtobr(rev);
			isbranch = 1;
		}
	}

	lookonbranch = 0;
	crev = NULL;

	/* Apply patches backwards to get the right version.
	 */
	do {
		found = 0;

		if (rcsnum_cmp(rfp->rf_head, rev, 0) == 0)
			break;

		if (isbranch == 1 && rdp->rd_num->rn_len < rev->rn_len &&
		    !TAILQ_EMPTY(&(rdp->rd_branches)))
			lookonbranch = 1;

		if (isbranch && lookonbranch == 1) {
			lookonbranch = 0;
			TAILQ_FOREACH(rb, &(rdp->rd_branches), rb_list) {
				/* XXX rcsnum_cmp() is totally broken for
				 * this purpose.
				 */
				numlen = MINIMUM(brev->rn_len,
				    rb->rb_num->rn_len - 1);
				for (i = 0; i < numlen; i++) {
					if (rb->rb_num->rn_id[i] !=
					    brev->rn_id[i])
						break;
				}

				if (i == numlen) {
					crev = rb->rb_num;
					found = 1;
					break;
				}
			}
			if (found == 0)
				crev = rdp->rd_next;
		} else {
			crev = rdp->rd_next;
		}

		rdp = rcs_findrev(rfp, crev);
		if (rdp == NULL) {
			buf_free(rbuf);
			return (NULL);
		}

		plen = rdp->rd_tlen;
		dlen = buf_len(rbuf);
		patch = rdp->rd_text;
		data = buf_release(rbuf);
		/* check if we have parsed this rev's deltatext */
		if (rdp->rd_tlen == 0)
			if (rcsparse_deltatexts(rfp, rdp->rd_num))
				return (NULL);

		rbuf = rcs_patchfile(data, dlen, patch, plen, rcs_patch_lines);
		free(data);

		if (rbuf == NULL)
			break;
	} while (rcsnum_cmp(crev, rev, 0) != 0);

	return (rbuf);
}

void
rcs_delta_stats(struct rcs_delta *rdp, int *ladded, int *lremoved)
{
	struct rcs_lines *plines;
	struct rcs_line *lp;
	int added, i, nbln, removed;
	char op, *ep;
	u_char tmp;

	added = removed = 0;

	plines = rcs_splitlines(rdp->rd_text, rdp->rd_tlen);
	lp = TAILQ_FIRST(&(plines->l_lines));

	/* skip first bogus line */
	for (lp = TAILQ_NEXT(lp, l_list); lp != NULL;
		lp = TAILQ_NEXT(lp, l_list)) {
			if (lp->l_len < 2)
				errx(1,
				    "line too short, RCS patch seems broken");
			op = *(lp->l_line);
			/* NUL-terminate line buffer for strtol() safety. */
			tmp = lp->l_line[lp->l_len - 1];
			lp->l_line[lp->l_len - 1] = '\0';
			(void)strtol((lp->l_line + 1), &ep, 10);
			ep++;
			nbln = (int)strtol(ep, &ep, 10);
			/* Restore the last byte of the buffer */
			lp->l_line[lp->l_len - 1] = tmp;
			if (nbln < 0)
				errx(1, "invalid line number specification "
				    "in RCS patch");

			if (op == 'a') {
				added += nbln;
				for (i = 0; i < nbln; i++) {
					lp = TAILQ_NEXT(lp, l_list);
					if (lp == NULL)
						errx(1, "truncated RCS patch");
				}
			} else if (op == 'd')
				removed += nbln;
			else
				errx(1, "unknown RCS patch operation '%c'", op);
	}

	rcs_freelines(plines);

	*ladded = added;
	*lremoved = removed;
}

/*
 * rcs_rev_add()
 *
 * Add a revision to the RCS file <rf>.  The new revision's number can be
 * specified in <rev> (which can also be RCS_HEAD_REV, in which case the
 * new revision will have a number equal to the previous head revision plus
 * one).  The <msg> argument specifies the log message for that revision, and
 * <date> specifies the revision's date (a value of -1 is
 * equivalent to using the current time).
 * If <author> is NULL, set the author for this revision to the current user.
 * Returns 0 on success, or -1 on failure.
 */
int
rcs_rev_add(RCSFILE *rf, RCSNUM *rev, const char *msg, time_t date,
    const char *author)
{
	time_t now;
	struct passwd *pw;
	struct rcs_delta *ordp, *rdp;

	if (rev == RCS_HEAD_REV) {
		if (rf->rf_flags & RCS_CREATE) {
			if ((rev = rcsnum_parse(RCS_HEAD_INIT)) == NULL)
				return (-1);
			rf->rf_head = rev;
		} else {
			rev = rcsnum_inc(rf->rf_head);
		}
	} else {
		if ((rdp = rcs_findrev(rf, rev)) != NULL) {
			rcs_errno = RCS_ERR_DUPENT;
			return (-1);
		}
	}

	rdp = xcalloc(1, sizeof(*rdp));

	TAILQ_INIT(&(rdp->rd_branches));

	rdp->rd_num = rcsnum_alloc();
	rcsnum_cpy(rev, rdp->rd_num, 0);

	rdp->rd_next = rcsnum_alloc();

	if (!(rf->rf_flags & RCS_CREATE)) {
		/* next should point to the previous HEAD */
		ordp = TAILQ_FIRST(&(rf->rf_delta));
		rcsnum_cpy(ordp->rd_num, rdp->rd_next, 0);
	}

	if (!author && !(author = getlogin())) {
		if (!(pw = getpwuid(getuid())))
			errx(1, "getpwuid failed");
		author = pw->pw_name;
	}
	rdp->rd_author = xstrdup(author);
	rdp->rd_state = xstrdup(RCS_STATE_EXP);
	rdp->rd_log = xstrdup(msg);

	if (date != (time_t)(-1))
		now = date;
	else
		time(&now);
	gmtime_r(&now, &(rdp->rd_date));

	TAILQ_INSERT_HEAD(&(rf->rf_delta), rdp, rd_list);
	rf->rf_ndelta++;

	/* not synced anymore */
	rf->rf_flags &= ~RCS_SYNCED;

	return (0);
}

/*
 * rcs_rev_remove()
 *
 * Remove the revision whose number is <rev> from the RCS file <rf>.
 */
int
rcs_rev_remove(RCSFILE *rf, RCSNUM *rev)
{
	char *path_tmp1, *path_tmp2;
	struct rcs_delta *rdp, *prevrdp, *nextrdp;
	BUF *newdeltatext, *nextbuf, *prevbuf, *newdiff;

	nextrdp = prevrdp = NULL;
	path_tmp1 = path_tmp2 = NULL;

	if (rev == RCS_HEAD_REV)
		rev = rf->rf_head;

	/* do we actually have that revision? */
	if ((rdp = rcs_findrev(rf, rev)) == NULL) {
		rcs_errno = RCS_ERR_NOENT;
		return (-1);
	}

	/*
	 * This is confusing, the previous delta is next in the TAILQ list.
	 * the next delta is the previous one in the TAILQ list.
	 *
	 * When the HEAD revision got specified, nextrdp will be NULL.
	 * When the first revision got specified, prevrdp will be NULL.
	 */
	prevrdp = (struct rcs_delta *)TAILQ_NEXT(rdp, rd_list);
	nextrdp = (struct rcs_delta *)TAILQ_PREV(rdp, tqh, rd_list);

	newdeltatext = prevbuf = nextbuf = NULL;

	if (prevrdp != NULL) {
		if ((prevbuf = rcs_getrev(rf, prevrdp->rd_num)) == NULL)
			errx(1, "error getting revision");
	}

	if (prevrdp != NULL && nextrdp != NULL) {
		if ((nextbuf = rcs_getrev(rf, nextrdp->rd_num)) == NULL)
			errx(1, "error getting revision");

		newdiff = buf_alloc(64);

		/* calculate new diff */
		(void)xasprintf(&path_tmp1, "%s/diff1.XXXXXXXXXX", rcs_tmpdir);
		buf_write_stmp(nextbuf, path_tmp1);
		buf_free(nextbuf);

		(void)xasprintf(&path_tmp2, "%s/diff2.XXXXXXXXXX", rcs_tmpdir);
		buf_write_stmp(prevbuf, path_tmp2);
		buf_free(prevbuf);

		diff_format = D_RCSDIFF;
		if (diffreg(path_tmp1, path_tmp2, newdiff, D_FORCEASCII) == D_ERROR)
			errx(1, "diffreg failed");

		newdeltatext = newdiff;
	} else if (nextrdp == NULL && prevrdp != NULL) {
		newdeltatext = prevbuf;
	}

	if (newdeltatext != NULL) {
		if (rcs_deltatext_set(rf, prevrdp->rd_num, newdeltatext) < 0)
			errx(1, "error setting new deltatext");
	}

	TAILQ_REMOVE(&(rf->rf_delta), rdp, rd_list);

	/* update pointers */
	if (prevrdp != NULL && nextrdp != NULL) {
		rcsnum_cpy(prevrdp->rd_num, nextrdp->rd_next, 0);
	} else if (prevrdp != NULL) {
		if (rcs_head_set(rf, prevrdp->rd_num) < 0)
			errx(1, "rcs_head_set failed");
	} else if (nextrdp != NULL) {
		rcsnum_free(nextrdp->rd_next);
		nextrdp->rd_next = rcsnum_alloc();
	} else {
		rcsnum_free(rf->rf_head);
		rf->rf_head = NULL;
	}

	rf->rf_ndelta--;
	rf->rf_flags &= ~RCS_SYNCED;

	rcs_freedelta(rdp);

	free(path_tmp1);
	free(path_tmp2);

	return (0);
}

/*
 * rcs_findrev()
 *
 * Find a specific revision's delta entry in the tree of the RCS file <rfp>.
 * The revision number is given in <rev>.
 *
 * If the given revision is a branch number, we translate it into the latest
 * revision on the branch.
 *
 * Returns a pointer to the delta on success, or NULL on failure.
 */
struct rcs_delta *
rcs_findrev(RCSFILE *rfp, RCSNUM *rev)
{
	u_int cmplen;
	struct rcs_delta *rdp;
	RCSNUM *brev, *frev;

	/*
	 * We need to do more parsing if the last revision in the linked list
	 * is greater than the requested revision.
	 */
	rdp = TAILQ_LAST(&(rfp->rf_delta), rcs_dlist);
	if (rdp == NULL ||
	    rcsnum_cmp(rdp->rd_num, rev, 0) == -1) {
		if (rcsparse_deltas(rfp, rev))
			return (NULL);
	}

	/*
	 * Translate a branch into the latest revision on the branch itself.
	 */
	if (RCSNUM_ISBRANCH(rev)) {
		brev = rcsnum_brtorev(rev);
		frev = brev;
		for (;;) {
			rdp = rcs_findrev(rfp, frev);
			if (rdp == NULL)
				return (NULL);

			if (rdp->rd_next->rn_len == 0)
				break;

			frev = rdp->rd_next;
		}

		rcsnum_free(brev);
		return (rdp);
	}

	cmplen = rev->rn_len;

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		if (rcsnum_cmp(rdp->rd_num, rev, cmplen) == 0)
			return (rdp);
	}

	return (NULL);
}

/*
 * rcs_kwexp_set()
 *
 * Set the keyword expansion mode to use on the RCS file <file> to <mode>.
 */
void
rcs_kwexp_set(RCSFILE *file, int mode)
{
	int i;
	char *tmp, buf[8] = "";

	if (RCS_KWEXP_INVAL(mode))
		return;

	i = 0;
	if (mode == RCS_KWEXP_NONE)
		buf[0] = 'b';
	else if (mode == RCS_KWEXP_OLD)
		buf[0] = 'o';
	else {
		if (mode & RCS_KWEXP_NAME)
			buf[i++] = 'k';
		if (mode & RCS_KWEXP_VAL)
			buf[i++] = 'v';
		if (mode & RCS_KWEXP_LKR)
			buf[i++] = 'l';
	}

	tmp = xstrdup(buf);
	free(file->rf_expand);
	file->rf_expand = tmp;
	/* not synced anymore */
	file->rf_flags &= ~RCS_SYNCED;
}

/*
 * rcs_kwexp_get()
 *
 * Retrieve the keyword expansion mode to be used for the RCS file <file>.
 */
int
rcs_kwexp_get(RCSFILE *file)
{
	if (file->rf_expand == NULL)
		return (RCS_KWEXP_DEFAULT);

	return (rcs_kflag_get(file->rf_expand));
}

/*
 * rcs_kflag_get()
 *
 * Get the keyword expansion mode from a set of character flags given in
 * <flags> and return the appropriate flag mask.  In case of an error, the
 * returned mask will have the RCS_KWEXP_ERR bit set to 1.
 */
int
rcs_kflag_get(const char *flags)
{
	int fl;
	size_t len;
	const char *fp;

	if (flags == NULL || !(len = strlen(flags)))
		return (RCS_KWEXP_ERR);

	fl = 0;
	for (fp = flags; *fp != '\0'; fp++) {
		if (*fp == 'k')
			fl |= RCS_KWEXP_NAME;
		else if (*fp == 'v')
			fl |= RCS_KWEXP_VAL;
		else if (*fp == 'l')
			fl |= RCS_KWEXP_LKR;
		else if (*fp == 'o') {
			if (len != 1)
				fl |= RCS_KWEXP_ERR;
			fl |= RCS_KWEXP_OLD;
		} else if (*fp == 'b') {
			if (len != 1)
				fl |= RCS_KWEXP_ERR;
			fl |= RCS_KWEXP_NONE;
		} else	/* unknown letter */
			fl |= RCS_KWEXP_ERR;
	}

	return (fl);
}

/*
 * rcs_freedelta()
 *
 * Free the contents of a delta structure.
 */
static void
rcs_freedelta(struct rcs_delta *rdp)
{
	struct rcs_branch *rb;

	rcsnum_free(rdp->rd_num);
	rcsnum_free(rdp->rd_next);

	free(rdp->rd_author);
	free(rdp->rd_locker);
	free(rdp->rd_state);
	free(rdp->rd_log);
	free(rdp->rd_text);

	while ((rb = TAILQ_FIRST(&(rdp->rd_branches))) != NULL) {
		TAILQ_REMOVE(&(rdp->rd_branches), rb, rb_list);
		rcsnum_free(rb->rb_num);
		free(rb);
	}

	free(rdp);
}

/*
 * rcs_strprint()
 *
 * Output an RCS string <str> of size <slen> to the stream <stream>.  Any
 * '@@' characters are escaped.  Otherwise, the string can contain arbitrary
 * binary data.
 */
static void
rcs_strprint(const u_char *str, size_t slen, FILE *stream)
{
	const u_char *ap, *ep, *sp;

	if (slen == 0)
		return;

	ep = str + slen - 1;

	for (sp = str; sp <= ep;)  {
		ap = memchr(sp, '@@', ep - sp);
		if (ap == NULL)
			ap = ep;
		(void)fwrite(sp, sizeof(u_char), ap - sp + 1, stream);

		if (*ap == '@@')
			putc('@@', stream);
		sp = ap + 1;
	}
}

/*
 * rcs_expand_keywords()
 *
 * Return expansion any RCS keywords in <data>
 *
 * On error, return NULL.
 */
static BUF *
rcs_expand_keywords(char *rcsfile_in, struct rcs_delta *rdp, BUF *bp, int mode)
{
	BUF *newbuf;
	u_char *c, *kw, *fin;
	char buf[256], *tmpf, resolved[PATH_MAX], *rcsfile;
	u_char *line, *line2;
	u_int i, j;
	int kwtype;
	int found;
	struct tm tb;

	tb = rdp->rd_date;
	if (timezone_flag != NULL)
		rcs_set_tz(timezone_flag, rdp, &tb);

	if (realpath(rcsfile_in, resolved) == NULL)
		rcsfile = rcsfile_in;
	else
		rcsfile = resolved;

	newbuf = buf_alloc(buf_len(bp));

	/*
	 * Keyword formats:
	 * $Keyword$
	 * $Keyword: value$
	 */
	c = buf_get(bp);
	fin = c + buf_len(bp);
	/* Copying to newbuf is deferred until the first keyword. */
	found = 0;

	while (c < fin) {
		kw = memchr(c, '$', fin - c);
		if (kw == NULL)
			break;
		++kw;
		if (found) {
			/* Copy everything up to and including the $. */
			buf_append(newbuf, c, kw - c);
		}
		c = kw;
		/* c points after the $ now. */
		if (c == fin)
			break;
		if (!isalpha(*c)) /* all valid keywords start with a letter */
			continue;

		for (i = 0; i < RCS_NKWORDS; ++i) {
			size_t kwlen;

			kwlen = strlen(rcs_expkw[i].kw_str);
			/*
			 * kwlen must be less than clen since clen includes
			 * either a terminating `$' or a `:'.
			 */
			if (c + kwlen < fin &&
			    memcmp(c , rcs_expkw[i].kw_str, kwlen) == 0 &&
			    (c[kwlen] == '$' || c[kwlen] == ':')) {
				c += kwlen;
				break;
			}
		}
		if (i == RCS_NKWORDS)
			continue;
		kwtype = rcs_expkw[i].kw_type;

		/*
		 * If the next character is ':' we need to look for an '$'
		 * before the end of the line to be sure it is in fact a
		 * keyword.
		 */
		if (*c == ':') {
			for (; c < fin; ++c) {
				if (*c == '$' || *c == '\n')
					break;
			}

			if (*c != '$') {
				if (found)
					buf_append(newbuf, kw, c - kw);
				continue;
			}
		}
		++c;

		if (!found) {
			found = 1;
			/* Copy everything up to and including the $. */
			buf_append(newbuf, buf_get(bp), kw - buf_get(bp));
		}

		if (mode & RCS_KWEXP_NAME) {
			buf_puts(newbuf, rcs_expkw[i].kw_str);
			if (mode & RCS_KWEXP_VAL)
				buf_puts(newbuf, ": ");
		}

		/* Order matters because of RCS_KW_ID and RCS_KW_HEADER. */
		if (mode & RCS_KWEXP_VAL) {
			if (kwtype & (RCS_KW_RCSFILE|RCS_KW_LOG)) {
				if ((kwtype & RCS_KW_FULLPATH) ||
				    (tmpf = strrchr(rcsfile, '/')) == NULL)
					buf_puts(newbuf, rcsfile);
				else
					buf_puts(newbuf, tmpf + 1);
				buf_putc(newbuf, ' ');
			}

			if (kwtype & RCS_KW_REVISION) {
				rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
				buf_puts(newbuf, buf);
				buf_putc(newbuf, ' ');
			}

			if (kwtype & RCS_KW_DATE) {
				strftime(buf, sizeof(buf),
				    "%Y/%m/%d %H:%M:%S ", &tb);
				buf_puts(newbuf, buf);
			}

			if (kwtype & RCS_KW_AUTHOR) {
				buf_puts(newbuf, rdp->rd_author);
				buf_putc(newbuf, ' ');
			}

			if (kwtype & RCS_KW_STATE) {
				buf_puts(newbuf, rdp->rd_state);
				buf_putc(newbuf, ' ');
			}

			/* Order does not matter anymore below. */
			if (kwtype & RCS_KW_SOURCE) {
				buf_puts(newbuf, rcsfile);
				buf_putc(newbuf, ' ');
			}

			if (kwtype & RCS_KW_MDOCDATE) {
				strftime(buf, sizeof(buf), "%B", &tb);
				buf_puts(newbuf, buf);
				/* Only one blank before single-digit day. */
				snprintf(buf, sizeof(buf), " %d", tb.tm_mday);
				buf_puts(newbuf, buf);
				strftime(buf, sizeof(buf), " %Y ", &tb);
				buf_puts(newbuf, buf);
			}

			if (kwtype & RCS_KW_NAME)
				buf_putc(newbuf, ' ');

			if ((kwtype & RCS_KW_LOCKER)) {
				if (rdp->rd_locker) {
					buf_puts(newbuf, rdp->rd_locker);
					buf_putc(newbuf, ' ');
				}
			}
		}

		/* End the expansion. */
		if (mode & RCS_KWEXP_NAME)
			buf_putc(newbuf, '$');

		if (kwtype & RCS_KW_LOG) {
			line = memrchr(buf_get(bp), '\n', kw - buf_get(bp) - 1);
			if (line == NULL)
				line = buf_get(bp);
			else
				++line;
			line2 = kw - 1;
			while (line2 > line && line2[-1] == ' ')
				--line2;

			buf_putc(newbuf, '\n');
			buf_append(newbuf, line, kw - 1 - line);
			buf_puts(newbuf, "Revision ");
			rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
			buf_puts(newbuf, buf);
			buf_puts(newbuf, "  ");
			strftime(buf, sizeof(buf), "%Y/%m/%d %H:%M:%S", &tb);
			buf_puts(newbuf, buf);

			buf_puts(newbuf, "  ");
			buf_puts(newbuf, rdp->rd_author);
			buf_putc(newbuf, '\n');

			for (i = 0; rdp->rd_log[i]; i += j) {
				j = strcspn(rdp->rd_log + i, "\n");
				if (j == 0)
					buf_append(newbuf, line, line2 - line);
				else
					buf_append(newbuf, line, kw - 1 - line);
				if (rdp->rd_log[i + j])
					++j;
				buf_append(newbuf, rdp->rd_log + i, j);
			}
			buf_append(newbuf, line, line2 - line);
			for (j = 0; c + j < fin; ++j) {
				if (c[j] != ' ')
					break;
			}
			if (c + j == fin || c[j] == '\n')
				c += j;
		}
	}

	if (found) {
		buf_append(newbuf, c, fin - c);
		buf_free(bp);
		return (newbuf);
	} else {
		buf_free(newbuf);
		return (bp);
	}
}

/*
 * rcs_deltatext_set()
 *
 * Set deltatext for <rev> in RCS file <rfp> to <dtext>
 * Returns -1 on error, 0 on success.
 */
int
rcs_deltatext_set(RCSFILE *rfp, RCSNUM *rev, BUF *bp)
{
	size_t len;
	u_char *dtext;
	struct rcs_delta *rdp;

	/* Write operations require full parsing */
	if (rcsparse_deltatexts(rfp, NULL))
		return (-1);

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_text);

	len = buf_len(bp);
	dtext = buf_release(bp);
	bp = NULL;

	if (len != 0) {
		rdp->rd_text = xmalloc(len);
		rdp->rd_tlen = len;
		(void)memcpy(rdp->rd_text, dtext, len);
	} else {
		rdp->rd_text = NULL;
		rdp->rd_tlen = 0;
	}

	free(dtext);

	return (0);
}

/*
 * rcs_rev_setlog()
 *
 * Sets the log message of revision <rev> to <logtext>.
 */
int
rcs_rev_setlog(RCSFILE *rfp, RCSNUM *rev, const char *logtext)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_log);

	rdp->rd_log = xstrdup(logtext);
	rfp->rf_flags &= ~RCS_SYNCED;
	return (0);
}
/*
 * rcs_rev_getdate()
 *
 * Get the date corresponding to a given revision.
 * Returns the date on success, -1 on failure.
 */
time_t
rcs_rev_getdate(RCSFILE *rfp, RCSNUM *rev)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	return (mktime(&rdp->rd_date));
}

/*
 * rcs_state_set()
 *
 * Sets the state of revision <rev> to <state>
 * NOTE: default state is 'Exp'. States may not contain spaces.
 *
 * Returns -1 on failure, 0 on success.
 */
int
rcs_state_set(RCSFILE *rfp, RCSNUM *rev, const char *state)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (-1);

	free(rdp->rd_state);

	rdp->rd_state = xstrdup(state);

	rfp->rf_flags &= ~RCS_SYNCED;

	return (0);
}

/*
 * rcs_state_check()
 *
 * Check if string <state> is valid.
 *
 * Returns 0 if the string is valid, -1 otherwise.
 */
int
rcs_state_check(const char *state)
{
	int ret;
	const unsigned char *cp;

	ret = 0;
	cp = state;
	if (!isalpha(*cp++))
		return (-1);

	for (; *cp != '\0'; cp++)
		if (!isgraph(*cp) || (strchr(rcs_state_invch, *cp) != NULL)) {
			ret = -1;
			break;
		}

	return (ret);
}

/*
 * rcs_kwexp_buf()
 *
 * Do keyword expansion on a buffer if necessary
 *
 */
BUF *
rcs_kwexp_buf(BUF *bp, RCSFILE *rf, RCSNUM *rev)
{
	struct rcs_delta *rdp;
	int expmode;

	/*
	 * Do keyword expansion if required.
	 */
	expmode = rcs_kwexp_get(rf);

	if (!(expmode & RCS_KWEXP_NONE)) {
		if ((rdp = rcs_findrev(rf, rev)) == NULL)
			errx(1, "could not fetch revision");
		return (rcs_expand_keywords(rf->rf_path, rdp, bp, expmode));
	}
	return (bp);
}
@


1.84
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.83 2015/06/13 20:15:21 nicm Exp $	*/
d69 1
d1598 10
@


1.83
log
@Convert xfree to free. From Fritjof Bornebusch. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.82 2015/01/16 06:40:11 deraadt Exp $	*/
d180 2
a181 4
	if (rfp->rf_head != NULL)
		rcsnum_free(rfp->rf_head);
	if (rfp->rf_branch != NULL)
		rcsnum_free(rfp->rf_branch);
d1407 2
a1408 4
	if (rdp->rd_num != NULL)
		rcsnum_free(rdp->rd_num);
	if (rdp->rd_next != NULL)
		rcsnum_free(rdp->rd_next);
@


1.82
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.81 2014/10/10 08:15:25 otto Exp $	*/
d160 2
a161 2
		xfree(rap->ra_name);
		xfree(rap);
d168 2
a169 2
		xfree(rsp->rs_name);
		xfree(rsp);
d176 2
a177 2
		xfree(rlp->rl_name);
		xfree(rlp);
d187 5
a191 8
	if (rfp->rf_path != NULL)
		xfree(rfp->rf_path);
	if (rfp->rf_comment != NULL)
		xfree(rfp->rf_comment);
	if (rfp->rf_expand != NULL)
		xfree(rfp->rf_expand);
	if (rfp->rf_desc != NULL)
		xfree(rfp->rf_desc);
d194 2
a195 1
	xfree(rfp);
d350 1
a350 2
	if (fn != NULL)
		xfree(fn);
d420 1
a420 1
	xfree(buf);
d509 2
a510 2
	xfree(ap->ra_name);
	xfree(ap);
d582 1
a582 1
	xfree(symp->rs_name);
d584 1
a584 1
	xfree(symp);
d743 2
a744 2
	xfree(lkp->rl_name);
	xfree(lkp);
d762 1
a762 2
	if (file->rf_desc != NULL)
		xfree(file->rf_desc);
d778 1
a778 2
	if (file->rf_comment != NULL)
		xfree(file->rf_comment);
d837 1
a837 1
				xfree(dlp);
d1018 1
a1018 1
		xfree(data);
d1244 2
a1245 4
	if (path_tmp1 != NULL)
		xfree(path_tmp1);
	if (path_tmp2 != NULL)
		xfree(path_tmp2);
d1339 1
a1339 2
	if (file->rf_expand != NULL)
		xfree(file->rf_expand);
d1414 5
a1418 10
	if (rdp->rd_author != NULL)
		xfree(rdp->rd_author);
	if (rdp->rd_locker != NULL)
		xfree(rdp->rd_locker);
	if (rdp->rd_state != NULL)
		xfree(rdp->rd_state);
	if (rdp->rd_log != NULL)
		xfree(rdp->rd_log);
	if (rdp->rd_text != NULL)
		xfree(rdp->rd_text);
d1423 1
a1423 1
		xfree(rb);
d1426 1
a1426 1
	xfree(rdp);
d1691 1
a1691 2
	if (rdp->rd_text != NULL)
		xfree(rdp->rd_text);
d1706 1
a1706 2
	if (dtext != NULL)
		xfree(dtext);
d1724 1
a1724 2
	if (rdp->rd_log != NULL)
		xfree(rdp->rd_log);
d1763 1
a1763 2
	if (rdp->rd_state != NULL)
		xfree(rdp->rd_state);
@


1.81
log
@Zap some stored values never read; From Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.80 2014/01/07 14:08:16 deraadt Exp $	*/
d27 1
d48 2
d987 1
a987 1
				numlen = MIN(brev->rn_len,
d1483 1
a1483 1
	char buf[256], *tmpf, resolved[MAXPATHLEN], *rcsfile;
@


1.80
log
@ctype cleanups; ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.79 2012/03/03 08:34:27 nicm Exp $	*/
a216 1
	fd = -1;
@


1.79
log
@Remove unused variable, from Michael W Bombardieri who also got an ok
from tobias@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.78 2011/07/14 16:38:39 sobrado Exp $	*/
d636 1
a636 1
	const char *cp;
d1798 1
a1798 1
	const char *cp;
@


1.78
log
@spacing, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.77 2011/07/06 15:36:52 nicm Exp $	*/
a365 3
	int ret;

	ret = -1;
a415 2
	ret = 0;

d423 1
a423 1
	return (ret);
@


1.77
log
@Replace the keyword expansion code with a faster, more readable version
which additionally also supports $Log$ and $Locker. Written by Joerg
Sonnenberger and tweaked by me.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.76 2011/05/20 19:21:10 nicm Exp $	*/
a1085 1
 	 
@


1.76
log
@Remove a bunch of unused functions, from Michael W Bombardieri.

ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.75 2011/04/20 19:34:16 nicm Exp $	*/
d56 1
d1483 1
a1483 1
rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, BUF *bp, int mode)
d1486 4
d1491 1
a1491 3
	u_int j, found;
	u_char *c, *kwstr, *start, *end, *fin;
	char expbuf[256], buf[256];
a1492 5
	char *fmt;
	size_t len;

	kwtype = 0;
	kwstr = NULL;
a1493 3
	/*
	 * -z support for RCS
	 */
d1498 4
a1501 6
	len = buf_len(bp);

	c = buf_get(bp);
	found = 0;
	/* Final character in buffer. */
	fin = c + len - 1;
d1503 1
a1503 2
	/* If no keywords are found, return original buffer. */
	newbuf = bp;
d1510 20
a1529 14
	for (; c < fin; c++) {
		if (*c == '$') {
			BUF *tmpbuf;
			size_t clen;

			/* remember start of this possible keyword */
			start = c;

			/* first following character has to be alphanumeric */
			c++;
			if (!isalpha(*c)) {
				c = start;
				continue;
			}
d1531 2
a1532 2
			/* Number of characters between c and fin, inclusive. */
			clen = fin - c + 1;
d1534 24
a1557 17
			/* look for any matching keywords */
			found = 0;
			for (j = 0; j < RCS_NKWORDS; j++) {
				size_t kwlen;

				kwlen = strlen(rcs_expkw[j].kw_str);
				/*
				 * kwlen must be less than clen since clen
				 * includes either a terminating `$' or a `:'.
				 */
				if (kwlen < clen &&
				    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
					found = 1;
					kwstr = rcs_expkw[j].kw_str;
					kwtype = rcs_expkw[j].kw_type;
					c += kwlen;
a1558 1
				}
d1561 3
a1563 3
			/* unknown keyword, continue looking */
			if (found == 0) {
				c = start;
d1566 2
d1569 11
a1579 10
			/*
			 * if the next character was ':' we need to look for
			 * an '$' before the end of the line to be sure it is
			 * in fact a keyword.
			 */
			if (*c == ':') {
				for (; c <= fin; ++c) {
					if (*c == '$' || *c == '\n')
						break;
				}
d1581 9
a1589 4
				if (*c != '$') {
					c = start;
					continue;
				}
a1590 1
			end = c + 1;
d1592 5
a1596 2
			/* start constructing the expansion */
			expbuf[0] = '\0';
d1598 5
a1602 2
			if (mode & RCS_KWEXP_NAME) {
				char *tmp;
d1604 3
a1606 5
				(void)xasprintf(&tmp, "$%s%s", kwstr,
				    (mode & RCS_KWEXP_VAL) ? ": " : "");
				if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(expbuf))
					errx(1, "rcs_expand_keywords: string truncated");
				xfree(tmp);
d1609 4
a1612 14
			/*
			 * order matters because of RCS_KW_ID and
			 * RCS_KW_HEADER here
			 */
			if (mode & RCS_KWEXP_VAL) {
				if (kwtype & RCS_KW_RCSFILE) {
					char *tmp;

					(void)xasprintf(&tmp, "%s ",
					    (kwtype & RCS_KW_FULLPATH) ? rcsfile : basename(rcsfile));
					if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
					xfree(tmp);
				}
d1614 5
a1618 2
				if (kwtype & RCS_KW_REVISION) {
					char *tmp;
d1620 2
a1621 6
					rcsnum_tostr(rdp->rd_num, buf, sizeof(buf));
					(void)xasprintf(&tmp, "%s ", buf);
					if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(buf))
						errx(1, "rcs_expand_keywords: string truncated");
					xfree(tmp);
				}
d1623 4
a1626 9
				if (kwtype & RCS_KW_DATE) {
					if (timezone_flag != NULL)
						fmt = "%Y/%m/%d %H:%M:%S%z ";
					else
						fmt = "%Y/%m/%d %H:%M:%S ";

					strftime(buf, sizeof(buf), fmt, &tb);
					if (strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
d1628 2
d1631 3
a1633 2
				if (kwtype & RCS_KW_AUTHOR) {
					char *tmp;
d1635 37
a1671 32
					(void)xasprintf(&tmp, "%s ", rdp->rd_author);
					if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
					xfree(tmp);
				}

				if (kwtype & RCS_KW_STATE) {
					char *tmp;

					(void)xasprintf(&tmp, "%s ", rdp->rd_state);
					if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
					xfree(tmp);
				}

				/* order does not matter anymore below */
				if (kwtype & RCS_KW_LOG)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");

				if (kwtype & RCS_KW_SOURCE) {
					char *tmp;

					(void)xasprintf(&tmp, "%s ", rcsfile);
					if (strlcat(expbuf, tmp, sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
					xfree(tmp);
				}

				if (kwtype & RCS_KW_NAME)
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
						errx(1, "rcs_expand_keywords: string truncated");
d1673 2
a1674 27

			/* end the expansion */
			if (mode & RCS_KWEXP_NAME)
				if (strlcat(expbuf, "$", sizeof(expbuf)) >= sizeof(expbuf))
					errx(1, "rcs_expand_keywords: string truncated");

			/* Concatenate everything together. */
			tmpbuf = buf_alloc(len + strlen(expbuf));
			/* Append everything before keyword. */
			buf_append(tmpbuf, buf_get(newbuf),
			    start - (unsigned char *)buf_get(newbuf));
			/* Append keyword. */
			buf_append(tmpbuf, expbuf, strlen(expbuf));
			/* Point c to end of keyword. */
			c = buf_get(tmpbuf) + buf_len(tmpbuf) - 1;
			/* Append everything after keyword. */
			buf_append(tmpbuf, end,
			    ((unsigned char *)buf_get(newbuf) + buf_len(newbuf)) - end);
			/* Point fin to end of data. */
			fin = buf_get(tmpbuf) + buf_len(tmpbuf) - 1;
			/* Recalculate new length. */
			len = buf_len(tmpbuf);

			/* tmpbuf is now ready, free old newbuf if allocated here. */
			if (newbuf != bp)
				buf_free(newbuf);
			newbuf = tmpbuf;
d1678 8
a1685 1
	return (newbuf);
@


1.75
log
@Remove some unneeded includes and dead code, from Michael W Bombardieri.

ok jasper xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.74 2011/04/04 23:08:30 djm Exp $	*/
a52 69
/* comment leaders, depending on the file's suffix */
static const struct rcs_comment {
	const char	*rc_suffix;
	const char	*rc_cstr;
} rcs_comments[] = {
	{ "1",    ".\\\" " },
	{ "2",    ".\\\" " },
	{ "3",    ".\\\" " },
	{ "4",    ".\\\" " },
	{ "5",    ".\\\" " },
	{ "6",    ".\\\" " },
	{ "7",    ".\\\" " },
	{ "8",    ".\\\" " },
	{ "9",    ".\\\" " },
	{ "a",    "-- "    },	/* Ada		 */
	{ "ada",  "-- "    },
	{ "adb",  "-- "    },
	{ "asm",  ";; "    },	/* assembler (MS-DOS) */
	{ "ads",  "-- "    },	/* Ada */
	{ "bat",  ":: "    },	/* batch (MS-DOS) */
	{ "body", "-- "    },	/* Ada */
	{ "c",    " * "    },	/* C */
	{ "c++",  "// "    },	/* C++ */
	{ "cc",   "// "    },
	{ "cpp",  "// "    },
	{ "cxx",  "// "    },
	{ "m",    "// "    },	/* Objective-C */
	{ "cl",   ";;; "   },	/* Common Lisp	 */
	{ "cmd",  ":: "    },	/* command (OS/2) */
	{ "cmf",  "c "     },	/* CM Fortran	 */
	{ "csh",  "# "     },	/* shell	 */
	{ "e",    "# "     },	/* efl		 */
	{ "epsf", "% "     },	/* encapsulated postscript */
	{ "epsi", "% "     },	/* encapsulated postscript */
	{ "el",   "; "     },	/* Emacs Lisp	 */
	{ "f",    "c "     },	/* Fortran	 */
	{ "for",  "c "     },
	{ "h",    " * "    },	/* C-header	 */
	{ "hh",   "// "    },	/* C++ header	 */
	{ "hpp",  "// "    },
	{ "hxx",  "// "    },
	{ "in",   "# "     },	/* for Makefile.in */
	{ "l",    " * "    },	/* lex */
	{ "mac",  ";; "    },	/* macro (DEC-10, MS-DOS, PDP-11, VMS, etc) */
	{ "mak",  "# "     },	/* makefile, e.g. Visual C++ */
	{ "me",   ".\\\" " },	/* me-macros	t/nroff	 */
	{ "ml",   "; "     },	/* mocklisp	 */
	{ "mm",   ".\\\" " },	/* mm-macros	t/nroff	 */
	{ "ms",   ".\\\" " },	/* ms-macros	t/nroff	 */
	{ "man",  ".\\\" " },	/* man-macros	t/nroff	 */
	{ "p",    " * "    },	/* pascal	 */
	{ "pas",  " * "    },
	{ "pl",   "# "     },	/* Perl	(conflict with Prolog) */
	{ "pm",   "# "     },	/* Perl	module */
	{ "ps",   "% "     },	/* postscript */
	{ "psw",  "% "     },	/* postscript wrap */
	{ "pswm", "% "     },	/* postscript wrap */
	{ "r",    "# "     },	/* ratfor	 */
	{ "rc",   " * "    },	/* Microsoft Windows resource file */
	{ "red",  "% "     },	/* psl/rlisp	 */
	{ "sh",   "# "     },	/* shell	 */
	{ "sl",   "% "     },	/* psl		 */
	{ "spec", "-- "    },	/* Ada		 */
	{ "tex",  "% "     },	/* tex		 */
	{ "y",    " * "    },	/* yacc		 */
	{ "ye",   " * "    },	/* yacc-efl	 */
	{ "yr",   " * "    },	/* yacc-ratfor	 */
};

a66 13
#define NB_COMTYPES	(sizeof(rcs_comments)/sizeof(rcs_comments[0]))

static const char *rcs_errstrs[] = {
	"No error",
	"No such entry",
	"Duplicate entry found",
	"Bad RCS number",
	"Invalid RCS symbol",
	"Parse error",
};

#define RCS_NERR   (sizeof(rcs_errstrs)/sizeof(rcs_errstrs[0]))

a430 11
 * rcs_head_get()
 *
 * Retrieve the revision number of the head revision for the RCS file <file>.
 */
const RCSNUM *
rcs_head_get(RCSFILE *file)
{
	return (file->rf_head);
}

/*
a464 17
 * rcs_branch_set()
 *
 * Set the default branch for the RCS file <file> to <bnum>.
 * Returns 0 on success, -1 on failure.
 */
int
rcs_branch_set(RCSFILE *file, const RCSNUM *bnum)
{
	if (file->rf_branch == NULL)
		file->rf_branch = rcsnum_alloc();

	rcsnum_cpy(bnum, file->rf_branch, 0);
	file->rf_flags &= ~RCS_SYNCED;
	return (0);
}

/*
a756 11
 * rcs_desc_get()
 *
 * Retrieve the description for the RCS file <file>.
 */
const char *
rcs_desc_get(RCSFILE *file)
{
	return (file->rf_desc);
}

/*
a773 35
 * rcs_comment_lookup()
 *
 * Lookup the assumed comment leader based on a file's suffix.
 * Returns a pointer to the string on success, or NULL on failure.
 */
const char *
rcs_comment_lookup(const char *filename)
{
	int i;
	const char *sp;

	if ((sp = strrchr(filename, '.')) == NULL) {
		rcs_errno = RCS_ERR_NOENT;
		return (NULL);
	}
	sp++;

	for (i = 0; i < (int)NB_COMTYPES; i++)
		if (strcmp(rcs_comments[i].rc_suffix, sp) == 0)
			return (rcs_comments[i].rc_cstr);
	return (NULL);
}

/*
 * rcs_comment_get()
 *
 * Retrieve the comment leader for the RCS file <file>.
 */
const char *
rcs_comment_get(RCSFILE *file)
{
	return (file->rf_comment);
}

/*
a1410 19
 * rcs_errstr()
 *
 * Get the error string matching the RCS error code <code>.
 */
const char *
rcs_errstr(int code)
{
	const char *esp;

	if (code < 0 || (code >= (int)RCS_NERR && code != RCS_ERR_ERRNO))
		esp = NULL;
	else if (code == RCS_ERR_ERRNO)
		esp = strerror(errno);
	else
		esp = rcs_errstrs[code];
	return (esp);
}

/*
a1828 18
}

/*
 * rcs_state_get()
 *
 * Get the state for a given revision of a specified RCSFILE.
 *
 * Returns NULL on failure.
 */
const char *
rcs_state_get(RCSFILE *rfp, RCSNUM *rev)
{
	struct rcs_delta *rdp;

	if ((rdp = rcs_findrev(rfp, rev)) == NULL)
		return (NULL);

	return (rdp->rd_state);
@


1.74
log
@previous commit introduced a crash: the removed strtol was being used to
skip past a value and it couldn't just be nuked
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.73 2011/03/27 18:22:50 jasper Exp $	*/
a45 3

#define RCS_KWEXP_SIZE  1024

@


1.73
log
@- remove unused variables

from Michael W. Bombardieri
ok chl@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.72 2010/12/10 09:48:43 jasper Exp $	*/
d1217 1
@


1.72
log
@- plug an fd leak

help/ok chl@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.71 2010/10/27 08:35:45 tobias Exp $	*/
d1198 1
a1198 1
	int added, i, lineno, nbln, removed;
a1216 1
			lineno = (int)strtol((lp->l_line + 1), &ep, 10);
@


1.71
log
@Merge -k and expand @@@@ parsing code between OpenCVS and OpenRCS, resulting
in a performance gain in OpenCVS in some "cvs update" scenarios.

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.70 2010/10/20 19:55:46 tobias Exp $	*/
d477 1
d483 2
a504 2
	(void)fclose(src);
	(void)fclose(dst);
d508 2
@


1.70
log
@Merge OpenCVS' rcs_deltatext_set into OpenRCS, fixing a memory leak.

ok nicm zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.69 2010/10/20 19:53:53 tobias Exp $	*/
d1520 4
a1523 1
	return rcs_kflag_get(file->rf_expand);
d1540 3
a1543 2
	len = strlen(flags);

d1558 1
d2039 1
a2039 4
	if (rf->rf_expand != NULL)
		expmode = rcs_kwexp_get(rf);
	else
		expmode = RCS_KWEXP_DEFAULT;
@


1.69
log
@Remove the need for rp_file in parser structure, instead keep only one
FILE pointer in RCSFILE.  This fixes some ugliness in closing an
fdopen()ed FILE and its underlying file descriptor.

Notified by Joerg Sonnenberger <joerg at britannica dot bec to de>

discussed with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.68 2010/10/15 08:44:12 tobias Exp $	*/
a1899 1
		xfree(dtext);
d1904 3
@


1.68
log
@Replaced RCS parser code with new rcsparse.{c,h}:
- be very strict about things we parse
- print more information about errors if they occur
- do not fatal() directly in parser, give caller a chance to react
- fix an rcs design issue when it comes to login names

tested by many on tech@@

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.67 2010/10/05 15:16:48 tobias Exp $	*/
d188 4
a191 1
	rfp->rf_fd = fd;
d266 2
@


1.67
log
@Zapped unused function rcs_tag_resolve.

ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.66 2010/10/05 15:13:04 tobias Exp $	*/
d42 1
a46 2
#define RCS_BUFSIZE	16384
#define RCS_BUFEXTSIZE	8192
a48 50
/* RCS token types */
#define RCS_TOK_ERR	-1
#define RCS_TOK_EOF	0
#define RCS_TOK_NUM	1
#define RCS_TOK_ID	2
#define RCS_TOK_STRING	3
#define RCS_TOK_SCOLON	4
#define RCS_TOK_COLON	5

#define RCS_TOK_HEAD		8
#define RCS_TOK_BRANCH		9
#define RCS_TOK_ACCESS		10
#define RCS_TOK_SYMBOLS		11
#define RCS_TOK_LOCKS		12
#define RCS_TOK_COMMENT		13
#define RCS_TOK_EXPAND		14
#define RCS_TOK_DATE		15
#define RCS_TOK_AUTHOR		16
#define RCS_TOK_STATE		17
#define RCS_TOK_NEXT		18
#define RCS_TOK_BRANCHES	19
#define RCS_TOK_DESC		20
#define RCS_TOK_LOG		21
#define RCS_TOK_TEXT		22
#define RCS_TOK_STRICT		23
#define RCS_TOK_COMMITID	24

#define RCS_ISKEY(t)	(((t) >= RCS_TOK_HEAD) && ((t) <= RCS_TOK_BRANCHES))

#define RCS_NOSCOL	0x01	/* no terminating semi-colon */
#define RCS_VOPT	0x02	/* value is optional */

/* opaque parse data */
struct rcs_pdata {
	u_int	rp_lines;

	char	*rp_buf;
	size_t	 rp_blen;
	char	*rp_bufend;
	size_t	 rp_tlen;

	/* pushback token buffer */
	char	rp_ptok[128];
	int	rp_pttype;	/* token type, RCS_TOK_ERR if no token */

	FILE	*rp_file;
};

#define RCS_TOKSTR(rfp)	((struct rcs_pdata *)rfp->rf_pdata)->rp_buf
#define RCS_TOKLEN(rfp)	((struct rcs_pdata *)rfp->rf_pdata)->rp_tlen
a140 27
static struct rcs_key {
	char	rk_str[16];
	int	rk_id;
	int	rk_val;
	int	rk_flags;
} rcs_keys[] = {
	{ "access",   RCS_TOK_ACCESS,   RCS_TOK_ID,     RCS_VOPT     },
	{ "author",   RCS_TOK_AUTHOR,   RCS_TOK_ID,     0            },
	{ "branch",   RCS_TOK_BRANCH,   RCS_TOK_NUM,    RCS_VOPT     },
	{ "branches", RCS_TOK_BRANCHES, RCS_TOK_NUM,    RCS_VOPT     },
	{ "comment",  RCS_TOK_COMMENT,  RCS_TOK_STRING, RCS_VOPT     },
	{ "commitid", RCS_TOK_COMMITID, RCS_TOK_ID,     0            },
	{ "date",     RCS_TOK_DATE,     RCS_TOK_NUM,    0            },
	{ "desc",     RCS_TOK_DESC,     RCS_TOK_STRING, RCS_NOSCOL   },
	{ "expand",   RCS_TOK_EXPAND,   RCS_TOK_STRING, RCS_VOPT     },
	{ "head",     RCS_TOK_HEAD,     RCS_TOK_NUM,    RCS_VOPT     },
	{ "locks",    RCS_TOK_LOCKS,    RCS_TOK_ID,     0            },
	{ "log",      RCS_TOK_LOG,      RCS_TOK_STRING, RCS_NOSCOL   },
	{ "next",     RCS_TOK_NEXT,     RCS_TOK_NUM,    RCS_VOPT     },
	{ "state",    RCS_TOK_STATE,    RCS_TOK_ID,     RCS_VOPT     },
	{ "strict",   RCS_TOK_STRICT,   0,              0,           },
	{ "symbols",  RCS_TOK_SYMBOLS,  0,              0            },
	{ "text",     RCS_TOK_TEXT,     RCS_TOK_STRING, RCS_NOSCOL   },
};

#define RCS_NKEYS	(sizeof(rcs_keys)/sizeof(rcs_keys[0]))

d157 1
a157 12
static void	rcs_parse_init(RCSFILE *);
static int	rcs_parse_admin(RCSFILE *);
static int	rcs_parse_delta(RCSFILE *);
static void	rcs_parse_deltas(RCSFILE *, RCSNUM *);
static int	rcs_parse_deltatext(RCSFILE *);
static void	rcs_parse_deltatexts(RCSFILE *, RCSNUM *);
static void	rcs_parse_desc(RCSFILE *);

static int	rcs_parse_access(RCSFILE *);
static int	rcs_parse_symbols(RCSFILE *);
static int	rcs_parse_locks(RCSFILE *);
static int	rcs_parse_branches(RCSFILE *, struct rcs_delta *);
a158 4
static void	rcs_freepdata(struct rcs_pdata *);
static int	rcs_gettok(RCSFILE *);
static int	rcs_pushtok(RCSFILE *, const char *, int);
static void	rcs_growbuf(RCSFILE *);
d196 2
a197 1
		rcs_parse_init(rfp);
d272 1
a272 1
		rcs_freepdata(rfp->rf_pdata);
d302 2
a303 1
	rcs_parse_deltatexts(rfp, NULL);
d1074 2
a1075 1
	rcs_parse_desc(rfp);
d1084 2
a1085 1
		rcs_parse_deltatexts(rfp, rfp->rf_head);
d1172 2
a1173 1
			rcs_parse_deltatexts(rfp, rdp->rd_num);
d1436 2
a1437 1
		rcs_parse_deltas(rfp, rev);
a1574 708
/* rcs_parse_deltas()
 *
 * Parse deltas. If <rev> is not NULL, parse only as far as that
 * revision. If <rev> is NULL, parse all deltas.
 */
static void
rcs_parse_deltas(RCSFILE *rfp, RCSNUM *rev)
{
	int ret;
	struct rcs_delta *enddelta;

	if ((rfp->rf_flags & PARSED_DELTAS) || (rfp->rf_flags & RCS_CREATE))
		return;

	for (;;) {
		ret = rcs_parse_delta(rfp);
		if (rev != NULL) {
			enddelta = TAILQ_LAST(&(rfp->rf_delta), rcs_dlist);
			if (rcsnum_cmp(enddelta->rd_num, rev, 0) == 0)
				break;
		}
		if (ret == 0) {
			rfp->rf_flags |= PARSED_DELTAS;
			break;
		}
		else if (ret == -1)
			errx(1, "error parsing deltas");
	}
}

/* rcs_parse_deltatexts()
 *
 * Parse deltatexts. If <rev> is not NULL, parse only as far as that
 * revision. If <rev> is NULL, parse everything.
 */
static void
rcs_parse_deltatexts(RCSFILE *rfp, RCSNUM *rev)
{
	int ret;
	struct rcs_delta *rdp;

	if ((rfp->rf_flags & PARSED_DELTATEXTS) ||
	    (rfp->rf_flags & RCS_CREATE))
		return;

	if (!(rfp->rf_flags & PARSED_DESC))
		rcs_parse_desc(rfp);
	for (;;) {
		if (rev != NULL) {
			rdp = rcs_findrev(rfp, rev);
			if (rdp->rd_text != NULL)
				break;
			else
				ret = rcs_parse_deltatext(rfp);
		} else
			ret = rcs_parse_deltatext(rfp);
		if (ret == 0) {
			rfp->rf_flags |= PARSED_DELTATEXTS;
			break;
		}
		else if (ret == -1)
			errx(1, "problem parsing deltatexts");
	}
}

/* rcs_parse_desc()
 *
 * Parse RCS description.
 */
static void
rcs_parse_desc(RCSFILE *rfp)
{
	int ret = 0;

	if ((rfp->rf_flags & PARSED_DESC) || (rfp->rf_flags & RCS_CREATE))
		return;
	if (!(rfp->rf_flags & PARSED_DELTAS))
		rcs_parse_deltas(rfp, NULL);
	/* do parsing */
	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_DESC)
		errx(1, "token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));

	ret = rcs_gettok(rfp);
	if (ret != RCS_TOK_STRING)
		errx(1, "token `%s' found where RCS desc expected",
		    RCS_TOKSTR(rfp));

	rfp->rf_desc = xstrdup(RCS_TOKSTR(rfp));
	rfp->rf_flags |= PARSED_DESC;
}

/*
 * rcs_parse_init()
 *
 * Initial parsing of file <path>, which is in the RCS format.
 * Just does admin section.
 */
static void
rcs_parse_init(RCSFILE *rfp)
{
	struct rcs_pdata *pdp;

	if (rfp->rf_flags & RCS_PARSED)
		return;

	pdp = xcalloc(1, sizeof(*pdp));

	pdp->rp_lines = 0;
	pdp->rp_pttype = RCS_TOK_ERR;

	if ((pdp->rp_file = fdopen(rfp->rf_fd, "r")) == NULL)
		err(1, "fdopen: `%s'", rfp->rf_path);

	pdp->rp_buf = xmalloc((size_t)RCS_BUFSIZE);
	pdp->rp_blen = RCS_BUFSIZE;
	pdp->rp_bufend = pdp->rp_buf + pdp->rp_blen - 1;

	/* ditch the strict lock */
	rfp->rf_flags &= ~RCS_SLOCK;
	rfp->rf_pdata = pdp;

	if (rcs_parse_admin(rfp) < 0) {
		rcs_freepdata(pdp);
		errx(1, "could not parse admin data");
	}

	if (rfp->rf_flags & RCS_PARSE_FULLY)
		rcs_parse_deltatexts(rfp, NULL);

	rfp->rf_flags |= RCS_SYNCED;
}

/*
 * rcs_parse_admin()
 *
 * Parse the administrative portion of an RCS file.
 * Returns the type of the first token found after the admin section on
 * success, or -1 on failure.
 */
static int
rcs_parse_admin(RCSFILE *rfp)
{
	u_int i;
	int tok, ntok, hmask;
	struct rcs_key *rk;

	/* hmask is a mask of the headers already encountered */
	hmask = 0;
	for (;;) {
		tok = rcs_gettok(rfp);
		if (tok == RCS_TOK_ERR) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("parse error in RCS admin section");
			goto fail;
		} else if (tok == RCS_TOK_NUM || tok == RCS_TOK_DESC) {
			/*
			 * Assume this is the start of the first delta or
			 * that we are dealing with an empty RCS file and
			 * we just found the description.
			 */
			rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
			return (tok);
		}

		rk = NULL;
		for (i = 0; i < RCS_NKEYS; i++)
			if (rcs_keys[i].rk_id == tok)
				rk = &(rcs_keys[i]);

		if (hmask & (1 << tok)) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("duplicate RCS key");
			goto fail;
		}
		hmask |= (1 << tok);

		switch (tok) {
		case RCS_TOK_HEAD:
		case RCS_TOK_BRANCH:
		case RCS_TOK_COMMENT:
		case RCS_TOK_EXPAND:
			ntok = rcs_gettok(rfp);
			if (ntok == RCS_TOK_SCOLON)
				break;
			if (ntok != rk->rk_val) {
				rcs_errno = RCS_ERR_PARSE;
				warnx("invalid value type for RCS key `%s'",
				    rk->rk_str);
			}

			if (tok == RCS_TOK_HEAD) {
				if (rfp->rf_head == NULL)
					rfp->rf_head = rcsnum_alloc();
				rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_head);
			} else if (tok == RCS_TOK_BRANCH) {
				if (rfp->rf_branch == NULL)
					rfp->rf_branch = rcsnum_alloc();
				if (rcsnum_aton(RCS_TOKSTR(rfp), NULL,
				    rfp->rf_branch) < 0)
					goto fail;
			} else if (tok == RCS_TOK_COMMENT) {
				rfp->rf_comment = xstrdup(RCS_TOKSTR(rfp));
			} else if (tok == RCS_TOK_EXPAND) {
				rfp->rf_expand = xstrdup(RCS_TOKSTR(rfp));
			}

			/* now get the expected semi-colon */
			ntok = rcs_gettok(rfp);
			if (ntok != RCS_TOK_SCOLON) {
				rcs_errno = RCS_ERR_PARSE;
				warnx("missing semi-colon after RCS `%s' key",
				    rk->rk_str);
				goto fail;
			}
			break;
		case RCS_TOK_ACCESS:
			if (rcs_parse_access(rfp) < 0)
				goto fail;
			break;
		case RCS_TOK_SYMBOLS:
			if (rcs_parse_symbols(rfp) < 0)
				goto fail;
			break;
		case RCS_TOK_LOCKS:
			if (rcs_parse_locks(rfp) < 0)
				goto fail;
			break;
		default:
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in RCS admin section",
			    RCS_TOKSTR(rfp));
			goto fail;
		}
	}

fail:
	return (-1);
}

/*
 * rcs_parse_delta()
 *
 * Parse an RCS delta section and allocate the structure to store that delta's
 * information in the <rfp> delta list.
 * Returns 1 if the section was parsed OK, 0 if it is the last delta, and
 * -1 on error.
 */
static int
rcs_parse_delta(RCSFILE *rfp)
{
	int ret, tok, ntok, hmask;
	u_int i;
	char *tokstr;
	RCSNUM *datenum;
	struct rcs_delta *rdp;
	struct rcs_key *rk;

	tok = rcs_gettok(rfp);
	if (tok == RCS_TOK_DESC) {
		rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
		return (0);
	} else if (tok != RCS_TOK_NUM) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' at start of delta",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	rdp = xcalloc(1, sizeof(*rdp));

	rdp->rd_num = rcsnum_alloc();
	rdp->rd_next = rcsnum_alloc();

	TAILQ_INIT(&(rdp->rd_branches));

	rcsnum_aton(RCS_TOKSTR(rfp), NULL, rdp->rd_num);

	hmask = 0;
	ret = 0;
	tokstr = NULL;

	for (;;) {
		tok = rcs_gettok(rfp);
		if (tok == RCS_TOK_ERR) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("parse error in RCS delta section");
			rcs_freedelta(rdp);
			return (-1);
		} else if (tok == RCS_TOK_NUM || tok == RCS_TOK_DESC) {
			rcs_pushtok(rfp, RCS_TOKSTR(rfp), tok);
			ret = (tok == RCS_TOK_NUM ? 1 : 0);
			break;
		}

		rk = NULL;
		for (i = 0; i < RCS_NKEYS; i++)
			if (rcs_keys[i].rk_id == tok)
				rk = &(rcs_keys[i]);

		if (hmask & (1 << tok)) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("duplicate RCS key");
			rcs_freedelta(rdp);
			return (-1);
		}
		hmask |= (1 << tok);

		switch (tok) {
		case RCS_TOK_DATE:
		case RCS_TOK_AUTHOR:
		case RCS_TOK_STATE:
		case RCS_TOK_NEXT:
		case RCS_TOK_COMMITID:
			ntok = rcs_gettok(rfp);
			if (ntok == RCS_TOK_SCOLON) {
				if (rk->rk_flags & RCS_VOPT)
					break;
				else {
					rcs_errno = RCS_ERR_PARSE;
					warnx("missing mandatory "
					    "value to RCS key `%s'",
					    rk->rk_str);
					rcs_freedelta(rdp);
					return (-1);
				}
			}

			if (ntok != rk->rk_val) {
				rcs_errno = RCS_ERR_PARSE;
				warnx("invalid value type for RCS key `%s'",
				    rk->rk_str);
				rcs_freedelta(rdp);
				return (-1);
			}

			if (tokstr != NULL)
				xfree(tokstr);
			tokstr = xstrdup(RCS_TOKSTR(rfp));
			/* now get the expected semi-colon */
			ntok = rcs_gettok(rfp);
			if (ntok != RCS_TOK_SCOLON) {
				rcs_errno = RCS_ERR_PARSE;
				warnx("missing semi-colon after RCS `%s' key",
				    rk->rk_str);
				xfree(tokstr);
				rcs_freedelta(rdp);
				return (-1);
			}

			if (tok == RCS_TOK_DATE) {
				if ((datenum = rcsnum_parse(tokstr)) == NULL) {
					xfree(tokstr);
					rcs_freedelta(rdp);
					return (-1);
				}
				if (datenum->rn_len != 6) {
					rcs_errno = RCS_ERR_PARSE;
					warnx("RCS date specification has %s "
					    "fields",
					    (datenum->rn_len > 6) ? "too many" :
					    "missing");
					xfree(tokstr);
					rcs_freedelta(rdp);
					rcsnum_free(datenum);
					return (-1);
				}
				rdp->rd_date.tm_year = datenum->rn_id[0];
				if (rdp->rd_date.tm_year >= 1900)
					rdp->rd_date.tm_year -= 1900;
				rdp->rd_date.tm_mon = datenum->rn_id[1] - 1;
				rdp->rd_date.tm_mday = datenum->rn_id[2];
				rdp->rd_date.tm_hour = datenum->rn_id[3];
				rdp->rd_date.tm_min = datenum->rn_id[4];
				rdp->rd_date.tm_sec = datenum->rn_id[5];
				rcsnum_free(datenum);
			} else if (tok == RCS_TOK_AUTHOR) {
				rdp->rd_author = tokstr;
				tokstr = NULL;
			} else if (tok == RCS_TOK_STATE) {
				rdp->rd_state = tokstr;
				tokstr = NULL;
			} else if (tok == RCS_TOK_NEXT) {
				rcsnum_aton(tokstr, NULL, rdp->rd_next);
			} else if (tok == RCS_TOK_COMMITID) {
				/* XXX just parse it, no action yet */
			}
			break;
		case RCS_TOK_BRANCHES:
			if (rcs_parse_branches(rfp, rdp) < 0) {
				rcs_freedelta(rdp);
				return (-1);
			}
			break;
		default:
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in RCS delta",
			    RCS_TOKSTR(rfp));
			rcs_freedelta(rdp);
			return (-1);
		}
	}

	if (tokstr != NULL)
		xfree(tokstr);

	TAILQ_INSERT_TAIL(&(rfp->rf_delta), rdp, rd_list);
	rfp->rf_ndelta++;

	return (ret);
}

/*
 * rcs_parse_deltatext()
 *
 * Parse an RCS delta text section and fill in the log and text field of the
 * appropriate delta section.
 * Returns 1 if the section was parsed OK, 0 if it is the last delta, and
 * -1 on error.
 */
static int
rcs_parse_deltatext(RCSFILE *rfp)
{
	int tok;
	RCSNUM *tnum;
	struct rcs_delta *rdp;

	tok = rcs_gettok(rfp);
	if (tok == RCS_TOK_EOF)
		return (0);

	if (tok != RCS_TOK_NUM) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' at start of RCS delta text",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tnum = rcsnum_alloc();
	rcsnum_aton(RCS_TOKSTR(rfp), NULL, tnum);

	TAILQ_FOREACH(rdp, &(rfp->rf_delta), rd_list) {
		if (rcsnum_cmp(tnum, rdp->rd_num, 0) == 0)
			break;
	}
	rcsnum_free(tnum);

	if (rdp == NULL) {
		warnx("RCS delta text `%s' has no matching delta",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_LOG) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' where RCS log expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_STRING) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' where RCS log expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}
	rdp->rd_log = xstrdup(RCS_TOKSTR(rfp));
	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_TEXT) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' where RCS text expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	tok = rcs_gettok(rfp);
	if (tok != RCS_TOK_STRING) {
		rcs_errno = RCS_ERR_PARSE;
		warnx("unexpected token `%s' where RCS text expected",
		    RCS_TOKSTR(rfp));
		return (-1);
	}

	if (RCS_TOKLEN(rfp) == 0) {
		rdp->rd_text = xmalloc(1);
		rdp->rd_text[0] = '\0';
		rdp->rd_tlen = 0;
	} else {
		rdp->rd_text = xmalloc(RCS_TOKLEN(rfp));
		memcpy(rdp->rd_text, RCS_TOKSTR(rfp), (RCS_TOKLEN(rfp)));
		rdp->rd_tlen = RCS_TOKLEN(rfp);
	}

	return (1);
}

/*
 * rcs_parse_access()
 *
 * Parse the access list given as value to the `access' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_access(RCSFILE *rfp)
{
	int type;

	while ((type = rcs_gettok(rfp)) != RCS_TOK_SCOLON) {
		if (type != RCS_TOK_ID) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in access list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		if (rcs_access_add(rfp, RCS_TOKSTR(rfp)) < 0)
			return (-1);
	}

	return (0);
}

/*
 * rcs_parse_symbols()
 *
 * Parse the symbol list given as value to the `symbols' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_symbols(RCSFILE *rfp)
{
	int type;
	struct rcs_sym *symp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_ID) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		symp = xmalloc(sizeof(*symp));
		symp->rs_name = xstrdup(RCS_TOKSTR(rfp));
		symp->rs_num = rcsnum_alloc();

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_COLON) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_NUM) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		if (rcsnum_aton(RCS_TOKSTR(rfp), NULL, symp->rs_num) < 0) {
			warnx("failed to parse RCS NUM `%s'",
			    RCS_TOKSTR(rfp));
			rcsnum_free(symp->rs_num);
			xfree(symp->rs_name);
			xfree(symp);
			return (-1);
		}

		TAILQ_INSERT_TAIL(&(rfp->rf_symbols), symp, rs_list);
	}

	return (0);
}

/*
 * rcs_parse_locks()
 *
 * Parse the lock list given as value to the `locks' keyword.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_locks(RCSFILE *rfp)
{
	int type;
	struct rcs_lock *lkp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_ID) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in lock list",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		lkp = xmalloc(sizeof(*lkp));
		lkp->rl_name = xstrdup(RCS_TOKSTR(rfp));
		lkp->rl_num = rcsnum_alloc();

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_COLON) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_NUM) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in symbol list",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		if (rcsnum_aton(RCS_TOKSTR(rfp), NULL, lkp->rl_num) < 0) {
			warnx("failed to parse RCS NUM `%s'",
			    RCS_TOKSTR(rfp));
			rcsnum_free(lkp->rl_num);
			xfree(lkp->rl_name);
			xfree(lkp);
			return (-1);
		}

		TAILQ_INSERT_HEAD(&(rfp->rf_locks), lkp, rl_list);
	}

	/* check if we have a `strict' */
	type = rcs_gettok(rfp);
	if (type != RCS_TOK_STRICT) {
		rcs_pushtok(rfp, RCS_TOKSTR(rfp), type);
	} else {
		rfp->rf_flags |= RCS_SLOCK;

		type = rcs_gettok(rfp);
		if (type != RCS_TOK_SCOLON) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("missing semi-colon after `strict' keyword");
			return (-1);
		}
	}

	return (0);
}

/*
 * rcs_parse_branches()
 *
 * Parse the list of branches following a `branches' keyword in a delta.
 * Returns 0 on success, or -1 on failure.
 */
static int
rcs_parse_branches(RCSFILE *rfp, struct rcs_delta *rdp)
{
	int type;
	struct rcs_branch *brp;

	for (;;) {
		type = rcs_gettok(rfp);
		if (type == RCS_TOK_SCOLON)
			break;

		if (type != RCS_TOK_NUM) {
			rcs_errno = RCS_ERR_PARSE;
			warnx("unexpected token `%s' in list of branches",
			    RCS_TOKSTR(rfp));
			return (-1);
		}

		brp = xmalloc(sizeof(*brp));
		brp->rb_num = rcsnum_parse(RCS_TOKSTR(rfp));
		if (brp->rb_num == NULL) {
			xfree(brp);
			return (-1);
		}

		TAILQ_INSERT_TAIL(&(rdp->rd_branches), brp, rb_list);
	}

	return (0);
}

a1610 189
 * rcs_freepdata()
 *
 * Free the contents of the parser data structure.
 */
static void
rcs_freepdata(struct rcs_pdata *pd)
{
	if (pd->rp_file != NULL)
		(void)fclose(pd->rp_file);
	if (pd->rp_buf != NULL)
		xfree(pd->rp_buf);
	xfree(pd);
}

/*
 * rcs_gettok()
 *
 * Get the next RCS token from the string <str>.
 */
static int
rcs_gettok(RCSFILE *rfp)
{
	u_int i;
	int ch, last, type;
	size_t len;
	char *bp;
	struct rcs_pdata *pdp = (struct rcs_pdata *)rfp->rf_pdata;

	type = RCS_TOK_ERR;
	bp = pdp->rp_buf;
	pdp->rp_tlen = 0;
	*bp = '\0';

	if (pdp->rp_pttype != RCS_TOK_ERR) {
		type = pdp->rp_pttype;
		if (strlcpy(pdp->rp_buf, pdp->rp_ptok, pdp->rp_blen) >=
		    pdp->rp_blen)
			errx(1, "rcs_gettok: strlcpy");
		pdp->rp_pttype = RCS_TOK_ERR;
		return (type);
	}

	/* skip leading whitespace */
	/* XXX we must skip backspace too for compatibility, should we? */
	do {
		ch = getc(pdp->rp_file);
		if (ch == '\n')
			pdp->rp_lines++;
	} while (isspace(ch));

	if (ch == EOF) {
		type = RCS_TOK_EOF;
	} else if (ch == ';') {
		type = RCS_TOK_SCOLON;
	} else if (ch == ':') {
		type = RCS_TOK_COLON;
	} else if (isalpha(ch)) {
		type = RCS_TOK_ID;
		*(bp++) = ch;
		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			} else if (!isgraph(ch) ||
			    strchr(rcs_sym_invch, ch) != NULL) {
				ungetc(ch, pdp->rp_file);
				break;
			}
			*(bp++) = ch;
			pdp->rp_tlen++;
			if (bp == pdp->rp_bufend - 1) {
				len = bp - pdp->rp_buf;
				rcs_growbuf(rfp);
				bp = pdp->rp_buf + len;
			}
		}
		*bp = '\0';

		if (type != RCS_TOK_ERR) {
			for (i = 0; i < RCS_NKEYS; i++) {
				if (strcmp(rcs_keys[i].rk_str,
				    pdp->rp_buf) == 0) {
					type = rcs_keys[i].rk_id;
					break;
				}
			}
		}
	} else if (ch == '@@') {
		/* we have a string */
		type = RCS_TOK_STRING;
		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			} else if (ch == '@@') {
				ch = getc(pdp->rp_file);
				if (ch != '@@') {
					ungetc(ch, pdp->rp_file);
					break;
				}
			} else if (ch == '\n')
				pdp->rp_lines++;

			*(bp++) = ch;
			pdp->rp_tlen++;
			if (bp == pdp->rp_bufend - 1) {
				len = bp - pdp->rp_buf;
				rcs_growbuf(rfp);
				bp = pdp->rp_buf + len;
			}
		}

		*bp = '\0';
	} else if (isdigit(ch)) {
		*(bp++) = ch;
		last = ch;
		type = RCS_TOK_NUM;

		for (;;) {
			ch = getc(pdp->rp_file);
			if (ch == EOF) {
				type = RCS_TOK_EOF;
				break;
			}
			if (bp == pdp->rp_bufend)
				break;
			if (isalpha(ch) && ch != '.') {
				type = RCS_TOK_ID;
			} else if (!isdigit(ch) && ch != '.') {
				ungetc(ch, pdp->rp_file);
				break;
			}

			if (last == '.' && ch == '.') {
				type = RCS_TOK_ERR;
				break;
			}
			last = ch;
			*(bp++) = ch;
			pdp->rp_tlen++;
		}
		*bp = '\0';
	}

	return (type);
}

/*
 * rcs_pushtok()
 *
 * Push a token back in the parser's token buffer.
 */
static int
rcs_pushtok(RCSFILE *rfp, const char *tok, int type)
{
	struct rcs_pdata *pdp = (struct rcs_pdata *)rfp->rf_pdata;

	if (pdp->rp_pttype != RCS_TOK_ERR)
		return (-1);

	pdp->rp_pttype = type;
	if (strlcpy(pdp->rp_ptok, tok, sizeof(pdp->rp_ptok)) >=
	    sizeof(pdp->rp_ptok))
		errx(1, "rcs_pushtok: strlcpy");
	return (0);
}


/*
 * rcs_growbuf()
 *
 * Attempt to grow the internal parse buffer for the RCS file <rf> by
 * RCS_BUFEXTSIZE.
 * In case of failure, the original buffer is left unmodified.
 */
static void
rcs_growbuf(RCSFILE *rf)
{
	struct rcs_pdata *pdp = (struct rcs_pdata *)rf->rf_pdata;

	pdp->rp_buf = xrealloc(pdp->rp_buf, 1,
	    pdp->rp_blen + RCS_BUFEXTSIZE);
	pdp->rp_blen += RCS_BUFEXTSIZE;
	pdp->rp_bufend = pdp->rp_buf + pdp->rp_blen - 1;
}

/*
d1878 2
a1879 1
	rcs_parse_deltatexts(rfp, NULL);
@


1.66
log
@rcs_state_check must check for more invalid characters than just space.

ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.65 2010/09/29 09:23:54 tobias Exp $	*/
a1029 18
}

/*
 * rcs_tag_resolve()
 *
 * Retrieve the revision number corresponding to the tag <tag> for the RCS
 * file <file>.
 */
RCSNUM *
rcs_tag_resolve(RCSFILE *file, const char *tag)
{
	RCSNUM *num;

	if ((num = rcsnum_parse(tag)) == NULL) {
		num = rcs_sym_getrev(file, tag);
	}

	return (num);
@


1.65
log
@Ensure that we always parse all deltas before expecting "desc" keyword.

ok nicm, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.64 2010/09/23 17:59:03 nicm Exp $	*/
d101 3
d2978 6
a2983 1
	if (strchr(state, ' ') != NULL)
d2986 7
a2992 1
	return (0);
@


1.64
log
@Plug memory leak in rcs_getrev, from zinovik.

ok me stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.63 2010/09/11 07:26:00 tobias Exp $	*/
d238 1
a238 1
static void	rcs_parse_desc(RCSFILE *, RCSNUM *);
d1180 1
a1180 1
	rcs_parse_desc(rfp, NULL);
d1723 1
a1723 1
		rcs_parse_desc(rfp, rev);
d1747 1
a1747 1
rcs_parse_desc(RCSFILE *rfp, RCSNUM *rev)
d1754 1
a1754 1
		rcs_parse_deltas(rfp, rev);
@


1.63
log
@Fixed typo.

ok ray, zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.62 2010/09/02 00:21:41 tobias Exp $	*/
d1210 2
a1211 1
		if (rdp == NULL)
d1213 1
d1279 1
@


1.62
log
@rcsnum_parse() allocates already an RCSNUM struct, so it's not needed to
copy it into a newly allocated one (which is even a memory leak).

ok zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.61 2010/08/31 20:43:45 tobias Exp $	*/
d1770 1
a1770 1
 * Initial parsing of file <path>, which are in the RCS format.
@


1.61
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.60 2010/07/28 09:07:11 ray Exp $	*/
d1362 1
a1362 2
			rf->rf_head = rcsnum_alloc();
			rcsnum_cpy(rev, rf->rf_head, 0);
@


1.60
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.59 2010/07/23 21:46:05 ray Exp $	*/
d1150 1
a1150 1
BUF*
@


1.59
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.58 2010/07/23 08:31:19 ray Exp $	*/
d1193 1
a1193 1
		rbuf = buf_alloc(1, 0);
d1198 1
a1198 1
	rbuf = buf_alloc(len, BUF_AUTOEXT);
d1458 1
a1458 1
		newdiff = buf_alloc(64, BUF_AUTOEXT);
d2835 1
a2835 1
			tmpbuf = buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
@


1.58
log
@Rename a bunch of variables and functions, removing the cvs_/rcs_
prefixes to reduce differences between cvs and rcs files.

"yes!" nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.57 2010/07/21 09:22:19 ray Exp $	*/
d1148 1
a1148 1
 * rcs_buf_free() once the caller is done using it.
d1193 2
a1194 2
		rbuf = rcs_buf_alloc(1, 0);
		rcs_buf_empty(rbuf);
d1198 2
a1199 2
	rbuf = rcs_buf_alloc(len, BUF_AUTOEXT);
	rcs_buf_append(rbuf, rdp->rd_text, len);
d1264 1
a1264 1
			rcs_buf_free(rbuf);
d1269 1
a1269 1
		dlen = rcs_buf_len(rbuf);
d1271 1
a1271 1
		data = rcs_buf_release(rbuf);
d1458 1
a1458 1
		newdiff = rcs_buf_alloc(64, BUF_AUTOEXT);
d1462 2
a1463 2
		rcs_buf_write_stmp(nextbuf, path_tmp1);
		rcs_buf_free(nextbuf);
d1466 2
a1467 2
		rcs_buf_write_stmp(prevbuf, path_tmp2);
		rcs_buf_free(prevbuf);
d2665 1
a2665 1
	len = rcs_buf_len(bp);
d2667 1
a2667 1
	c = rcs_buf_get(bp);
d2835 1
a2835 1
			tmpbuf = rcs_buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
d2837 2
a2838 2
			rcs_buf_append(tmpbuf, rcs_buf_get(newbuf),
			    start - (unsigned char *)rcs_buf_get(newbuf));
d2840 1
a2840 1
			rcs_buf_append(tmpbuf, expbuf, strlen(expbuf));
d2842 1
a2842 1
			c = rcs_buf_get(tmpbuf) + rcs_buf_len(tmpbuf) - 1;
d2844 2
a2845 2
			rcs_buf_append(tmpbuf, end,
			    ((unsigned char *)rcs_buf_get(newbuf) + rcs_buf_len(newbuf)) - end);
d2847 1
a2847 1
			fin = rcs_buf_get(tmpbuf) + rcs_buf_len(tmpbuf) - 1;
d2849 1
a2849 1
			len = rcs_buf_len(tmpbuf);
d2853 1
a2853 1
				rcs_buf_free(newbuf);
d2883 2
a2884 2
	len = rcs_buf_len(bp);
	dtext = rcs_buf_release(bp);
d2886 1
@


1.57
log
@Only use username if author is NULL. Fixes "ci -wusername" when run
as root.

OK nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.56 2010/07/13 20:07:24 nicm Exp $	*/
d407 1
a407 1
	rcs_worklist_add(fn, &rcs_temp_files);
d1086 1
a1086 1
				dlp = TAILQ_PREV(dlp, rcs_tqh, l_list);
d1106 1
a1106 1
					    rcs_tqh);
d1445 1
a1445 1
	nextrdp = (struct rcs_delta *)TAILQ_PREV(rdp, rcs_tqh, rd_list);
@


1.56
log
@Don't read before the beginning of the log message if it is zero-length
(possible when it comes from stdin).

Tweaked version of a fix from Peter Hendrickson in PR 6423.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.55 2010/07/09 20:07:05 naddy Exp $	*/
d1347 1
a1347 2
 * If <username> is NULL, set the author for this revision to the current user.
 * Otherwise, set it to <username>.
d1352 1
a1352 1
    const char *username)
a1356 1
	uid_t uid;
a1373 4
	uid = getuid();
	if ((pw = getpwuid(uid)) == NULL)
		errx(1, "getpwuid failed");

d1389 6
a1394 6
	if (uid == 0)
		username = getlogin();
	if (username == NULL || *username == '\0')
		username = pw->pw_name;

	rdp->rd_author = xstrdup(username);
@


1.55
log
@Make cvs and rcs consistent in what characters they'll accept in
symbol/tag names: require the first character to be a letter and
allow any printable character (except the RCS specials $,.:;@@)
afterwards.  This matches GNU cvs.

ok xsa@@ zinovik@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.54 2009/04/14 21:16:40 jj Exp $	*/
d500 1
a500 1
			if (rdp->rd_log[len-1] != '\n')
@


1.54
log
@tried to fix a the-the in the comment, ended up rewriting it. with/from joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.53 2009/02/25 23:16:20 ray Exp $	*/
d2481 1
a2481 1
	} else if (isalpha(ch) || ch == '_' || ch == '$' || ch == '.' || ch == '-') {
d2489 2
a2490 2
			} else if (!isalnum(ch) && ch != '_' && ch != '-' &&
			    ch != '/' && ch != '.' && ch != '$') {
@


1.53
log
@Checking if a file is ASCII should only be done when diffing, because
the non-ASCII characters could be printed to the screen.  For
checking in files, checking out files, merging files, and removing
revisions of files, we do so regardless of whether the files are
ASCII or binary.

Fixes PR6031.

OK joris and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.52 2009/02/15 13:40:33 joris Exp $	*/
d1178 2
a1179 1
	/* No matter what, we're going to need up the the description parsed */
@


1.52
log
@add our temporary RCS file to our temp_files worklist in case
for some reason we get interrupted before calling rename().

we hate leaving behind temporary files.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.51 2008/11/09 08:51:43 tobias Exp $	*/
d1475 1
a1475 1
		if (diffreg(path_tmp1, path_tmp2, newdiff, 0) == D_ERROR)
@


1.51
log
@Removed unneeded conversion from RCSNUM to string in rcs_rev_setlog.

oki joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.50 2008/11/08 11:48:49 tobias Exp $	*/
d406 2
@


1.50
log
@Support for retrieving revisions from branches in branches was missing.

Reported by chl@@, ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.49 2008/10/09 21:45:05 deraadt Exp $	*/
d2905 1
a2905 1
 * Sets the log message of revision <rev> to <logtext>
a2910 3
	char buf[RCS_REV_BUFSZ];

	rcsnum_tostr(rev, buf, sizeof(buf));
@


1.49
log
@cvs(1) uses a config file to know about the $OpenBSD$ expansion keyword,
but unfortunately rcs is not so lucky, and it will have to encoded inside.
A bit gross, but what can we do? PR 5953, ok tobias
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.48 2008/09/17 06:47:57 reyk Exp $	*/
d1239 2
a1240 1
				numlen = MIN(brev->rn_len, rb->rb_num->rn_len);
@


1.48
log
@try getlogin() to get the real username when comitting files as root.
this gives better information in log messages when the user logged in
with a different uid and used sudo or su to become root. matches the
behaviour of gcvs except that we don't fallback to LOGNAME or USER
since getlogin() should not lie.

ok tobias@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.47 2008/05/11 12:13:41 tobias Exp $	*/
d178 1
@


1.47
log
@Memory leak in rcs_delta_stats plugged.

ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.46 2008/02/02 16:21:38 xsa Exp $	*/
d1353 1
d1371 2
a1372 1
	if ((pw = getpwuid(getuid())) == NULL)
d1390 3
a1392 2

	if (username == NULL)
@


1.46
log
@From src/usr.bin/cvs:

> add changed lines support to log and rlog (the + and - stuff)
> from Pierre Riteau;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.45 2008/01/31 16:36:11 tobias Exp $	*/
d1325 2
@


1.45
log
@Revert last patch and add this magic branch number only during
output, this way we don't have to hassle in our internal brach handling.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.44 2008/01/06 14:45:50 tobias Exp $	*/
d1279 51
@


1.44
log
@Branches are separated with \n\t in GNU rcs/cvs.
This makes regress tests easier to check with OpenCVS and GNU cvs.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.43 2008/01/06 09:12:17 sturm Exp $	*/
d426 2
@


1.43
log
@gnu cvs added a new keyword 'commitid', this diff adds just enough code
to parse the commitid so that cvsweb (using rcs) continues to work on
those files

ok niallo@@, xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.42 2007/08/27 19:18:05 xsa Exp $	*/
d471 1
a471 1
			fprintf(fp, " %s", rcsnum_tostr(brp->rb_num, numbuf,
@


1.42
log
@typo in error msg; from Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.41 2007/07/03 00:56:23 ray Exp $	*/
d75 1
d199 1
d1933 1
d2004 2
d2490 3
a2492 1
			if (!isdigit(ch) && ch != '.') {
@


1.41
log
@Rename rcs_diffreg() to diffreg().

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.40 2007/06/30 08:23:49 xsa Exp $	*/
d1729 1
a1729 1
		err(1, "fopen: `%s'", rfp->rf_path);
@


1.40
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.39 2007/06/13 18:01:22 niallo Exp $	*/
d1411 2
a1412 2
		if (rcs_diffreg(path_tmp1, path_tmp2, newdiff, 0) == D_ERROR)
			errx(1, "rcs_diffreg failed");
@


1.39
log
@value of 'author' in an rcs file is effectively a system username.
therefore, we should allow it to contain the same characters as a username.

pointed out by jcs@@
ok ray@@ xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.38 2007/05/29 00:19:10 ray Exp $	*/
d372 1
a372 1
	char numbuf[64], *fn;
d2844 1
a2844 1
	char buf[16];
@


1.38
log
@Since xrealloc dies on failure it is safe to directly assign to the
original pointer.  Theo agrees, and so does the rest of the tree
(ssh, etc. all do this already).

Saves a bunch of variables and assignments.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.37 2007/05/17 03:33:24 ray Exp $	*/
d2413 1
a2413 1
	} else if (isalpha(ch)) {
d2422 1
a2422 1
			    ch != '/') {
@


1.37
log
@Don't free unused variable, from tbert.

OK niallo && xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.36 2007/02/27 07:59:13 xsa Exp $	*/
a2534 1
	void *tmp;
d2537 2
a2538 2
	tmp = xrealloc(pdp->rp_buf, 1, pdp->rp_blen + RCS_BUFEXTSIZE);
	pdp->rp_buf = tmp;
@


1.36
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.35 2007/01/02 16:43:45 niallo Exp $	*/
a1883 1
		rcs_freedelta(rdp);
@


1.35
log
@- fix support for checking out binary files.

testing from xsa@@ and Igor Sobrado <igor at string1.ciencias.uniovi.es>
ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.34 2006/12/21 15:37:44 niallo Exp $	*/
d27 12
a38 1
#include "includes.h"
@


1.34
log
@- plug memleak in rcs_parse_delta()

same as opencvs diff, ok xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.33 2006/09/21 15:30:07 millert Exp $	*/
d486 1
a486 1
		if (rdp->rd_text != NULL) {
a487 6

			if (rdp->rd_tlen != 0) {
				if (rdp->rd_text[rdp->rd_tlen-1] != '\n')
					fputc('\n', fp);
			}
		}
d1035 1
d1043 2
d1046 3
d1055 3
a1057 1
		if (nbln < 0 || *ep != '\0')
a1082 2
				if (dlp->l_line != NULL)
					xfree(dlp->l_line);
d1137 1
a1137 1
	size_t len;
d1139 1
a1139 1
	BUF *rbuf, *dtext;
d1142 1
d1248 4
a1251 2
		rcs_buf_putc(rbuf, '\0');

d1256 1
a1256 4

		dtext = rcs_buf_alloc(len, BUF_AUTOEXT);
		rcs_buf_append(dtext, rdp->rd_text, rdp->rd_tlen);
		rbuf = rcs_patchfile(rbuf, dtext, rcs_patch_lines);
a1260 4

	if (rcs_buf_getc(rbuf, rcs_buf_len(rbuf)-1) != '\n' &&
	    rbuf != NULL)
		rcs_buf_putc(rbuf, '\n');
@


1.33
log
@Add support to rcsdiff for all the other diff flags that
are pertinent to files (not directories) and that do not
conflict with rcsdiff-specific flags.  OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.32 2006/08/23 11:49:49 millert Exp $	*/
a1868 7
	rdp = xcalloc(1, sizeof(*rdp));

	rdp->rd_num = rcsnum_alloc();
	rdp->rd_next = rcsnum_alloc();

	TAILQ_INIT(&(rdp->rd_branches));

d1880 8
@


1.32
log
@Add missing checks for EOF when parsing rcs file sections.
OK xsa@@ joris@@ niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.31 2006/08/07 20:55:28 ray Exp $	*/
d1404 1
a1404 1
		if (rcs_diffreg(path_tmp1, path_tmp2, newdiff) == D_ERROR)
@


1.31
log
@More strlcpy/strlcat -> snprintf/xasprintf cleanup.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.30 2006/08/04 06:13:54 ray Exp $	*/
d2411 4
a2414 1
			if (!isalnum(ch) && ch != '_' && ch != '-' &&
d2443 4
a2446 1
			if (ch == '@@') {
d2472 4
@


1.30
log
@Remove unnecessary strlcpy/strlcat.

``Oh man!'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.29 2006/07/28 05:41:45 ray Exp $	*/
d2667 5
a2671 5
				if (strlcat(expbuf, "$", sizeof(expbuf)) >= sizeof(expbuf) ||
				    strlcat(expbuf, kwstr, sizeof(expbuf)) >= sizeof(expbuf))
					errx(1, "rcs_expand_keywords: string truncated");
				if ((mode & RCS_KWEXP_VAL) &&
				    strlcat(expbuf, ": ", sizeof(expbuf)) >= sizeof(expbuf))
d2673 1
d2682 5
a2686 5
					if (!(kwtype & RCS_KW_FULLPATH))
						(void)strlcat(expbuf, basename(rcsfile), sizeof(expbuf));
					else
						(void)strlcat(expbuf, rcsfile, sizeof(expbuf));
					if (strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
d2688 1
d2692 2
d2695 2
a2696 2
					if (strlcat(buf, " ", sizeof(buf)) >= sizeof(buf) ||
					    strlcat(expbuf, buf, sizeof(expbuf)) >= sizeof(buf))
d2698 1
d2713 4
a2716 2
					if (strlcat(expbuf, rdp->rd_author, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
d2718 1
d2722 4
a2725 2
					if (strlcat(expbuf, rdp->rd_state, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
d2727 1
d2736 4
a2739 2
					if (strlcat(expbuf, rcsfile, sizeof(expbuf)) >= sizeof(expbuf) ||
					    strlcat(expbuf, " ", sizeof(expbuf)) >= sizeof(expbuf))
d2741 1
@


1.29
log
@Recalculate buffer length after each expansion.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.28 2006/07/27 04:23:37 ray Exp $	*/
d361 1
a361 1
	char buf[1024], numbuf[64], *fn;
d414 1
a414 5
		if (strlcpy(buf, symp->rs_name, sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, ":", sizeof(buf)) >= sizeof(buf) ||
		    strlcat(buf, numbuf, sizeof(buf)) >= sizeof(buf))
			errx(1, "rcs_write: string overflow");
		fprintf(fp, "\n\t%s", buf);
@


1.28
log
@Second try at adding binary file support to rcs_expand_keywords(),
using BUFs instead of C strings.  Also remove initial keyword search,
which is a premature optimization, slower, and apparently too hard for
me to get right.

OK niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.27 2006/07/27 02:58:31 deraadt Exp $	*/
d2758 2
@


1.27
log
@unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.26 2006/07/27 02:57:19 deraadt Exp $	*/
d2570 1
a2570 2
	ptrdiff_t c_offset, sizdiff, start_offset;
	size_t i;
d2573 1
a2573 1
	u_char *c, *data, *kwstr, *start, *end, *tbuf, *fin;
d2577 1
a2577 1
	size_t len, tbuflen;
d2593 2
a2594 18
	for (i = 0; i < len; i++) {
		if (*c == '$') {
			c++;
			i++;
			for (j = 0; j < RCS_NKWORDS; j++) {
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
					found = 1;
					kwstr = rcs_expkw[j].kw_str;
					kwtype = rcs_expkw[j].kw_type;
					break;
				}
			}
		}
		c++;
	}
	if (found == 0)
		return (bp);
d2596 2
a2597 5
	rcs_buf_putc(bp, '\0');
	data = rcs_buf_release(bp);
	c = data;
	fin = c + len;
	len++;
d2606 3
a2610 1
			start_offset = start - data;
d2619 3
d2625 10
a2634 2
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
d2638 1
a2648 7
			/* next character has to be ':' or '$' */
			c += strlen(kwstr);
			if (*c != ':' && *c != '$') {
				c = start;
				continue;
			}

d2655 1
a2655 1
				while (*c++) {
a2664 1
			c_offset = c - data;
d2744 19
a2762 24
			sizdiff = strlen(expbuf) - (end - start);
			tbuflen = fin - end;
			tbuf = xmalloc(tbuflen);
			memcpy(tbuf, end, tbuflen);
			/* only realloc if we have to */
			if (sizdiff > 0) {
				char *newdata;

				len += sizdiff;
				newdata = xrealloc(data, 1, len);
				data = newdata;
				/*
				 * ensure string pointers are not invalidated
				 * after realloc()
				 */
				start = data + start_offset;
				fin = data + len;
				c = data + c_offset;
			}
			memcpy(start, expbuf, strlen(expbuf) + 1);
			start += strlen(expbuf);
			memcpy(start, tbuf, tbuflen);
			xfree(tbuf);
			c = start + strlen(expbuf);
d2766 1
a2766 5
	bp = rcs_buf_alloc(len - 1, BUF_AUTOEXT);
	rcs_buf_set(bp, data, len - 1, 0);
	xfree(data);

	return (bp);
@


1.26
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.25 2006/07/21 00:47:35 ray Exp $	*/
d368 1
a368 1
	int fd, from_fd, to_fd;
d371 1
a371 1
	from_fd = to_fd = fd = -1;
@


1.25
log
@Revert; keywords did not expand.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.23 2006/07/11 18:36:32 markus Exp $	*/
d1212 1
a1212 1
		
@


1.24
log
@Add binary file support to rcs_expand_keywords(), using BUFs instead
of C strings.

OK niallo@@
@
text
@d2570 2
a2571 1
	BUF *newbuf;
d2574 1
a2574 1
	u_char *c, *kwstr, *start, *end, *fin;
d2578 1
a2578 1
	size_t len;
d2594 1
a2594 5
	/* Final character in buffer. */
	fin = c + len - 1;

	/* If no keywords exist, return original BUF. */
	while (c < fin && !found) {
a2595 3
			size_t clen;

			/* Skip initial `$'. */
d2597 1
a2597 2
			/* Number of characters between c and fin, inclusive. */
			clen = fin - c + 1;
d2599 2
a2600 10
				size_t kwlen;

				kwlen = strlen(rcs_expkw[j].kw_str);
				/*
				 * kwlen must be less than clen since clen
				 * includes either a terminating `$' or a `:'.
				 */
				if (kwlen < clen &&
				    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
d2613 5
a2617 2
	/* If no keywords are found, return original buffer. */
	newbuf = bp;
a2625 3
			BUF *tmpbuf;
			size_t clen;

d2628 1
a2636 3
			/* Number of characters between c and fin, inclusive. */
			clen = fin - c + 1;

d2640 2
a2641 10
				size_t kwlen;

				kwlen = strlen(rcs_expkw[j].kw_str);
				/*
				 * kwlen must be less than clen since clen
				 * includes either a terminating `$' or a `:'.
				 */
				if (kwlen < clen &&
				    memcmp(c, rcs_expkw[j].kw_str, kwlen) == 0 &&
				    (c[kwlen] == '$' || c[kwlen] == ':')) {
a2644 1
					c += kwlen;
d2655 7
d2668 1
a2668 1
				for (; c <= fin; ++c) {
d2678 1
d2758 24
a2781 19
			/* Concatenate everything together. */
			tmpbuf = rcs_buf_alloc(len + strlen(expbuf), BUF_AUTOEXT);
			/* Append everything before keyword. */
			rcs_buf_append(tmpbuf, rcs_buf_get(newbuf),
			    start - (unsigned char *)rcs_buf_get(newbuf));
			/* Append keyword. */
			rcs_buf_append(tmpbuf, expbuf, strlen(expbuf));
			/* Point c to end of keyword. */
			c = rcs_buf_get(tmpbuf) + rcs_buf_len(tmpbuf) - 1;
			/* Append everything after keyword. */
			rcs_buf_append(tmpbuf, end,
			    ((unsigned char *)rcs_buf_get(newbuf) + rcs_buf_len(newbuf)) - end);
			/* Point fin to end of data. */
			fin = rcs_buf_get(tmpbuf) + rcs_buf_len(tmpbuf) - 1;

			/* tmpbuf is now ready, free old newbuf if allocated here. */
			if (newbuf != bp)
				rcs_buf_free(newbuf);
			newbuf = tmpbuf;
d2785 5
a2789 1
	return (newbuf);
@


1.23
log
@fix out of bound read in rcs_expand_keywords(); ok niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.22 2006/07/08 09:25:44 ray Exp $	*/
d2570 1
a2570 2
	ptrdiff_t c_offset, sizdiff, start_offset;
	size_t i;
d2573 1
a2573 1
	u_char *c, *data, *kwstr, *start, *end, *tbuf, *fin;
d2577 1
a2577 1
	size_t len, tbuflen;
d2593 5
a2597 1
	for (i = 0; i < len; i++) {
d2599 3
d2603 2
a2604 1
			i++;
d2606 10
a2615 2
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
d2628 2
a2629 5
	rcs_buf_putc(bp, '\0');
	data = rcs_buf_release(bp);
	c = data;
	fin = c + len;
	len++;
d2638 3
a2642 1
			start_offset = start - data;
d2651 3
d2657 10
a2666 2
				if (!strncmp(c, rcs_expkw[j].kw_str,
				    strlen(rcs_expkw[j].kw_str))) {
d2670 1
a2680 7
			/* next character has to be ':' or '$' */
			c += strlen(kwstr);
			if (*c != ':' && *c != '$') {
				c = start;
				continue;
			}

d2687 1
a2687 1
				while (*c++) {
a2696 1
			c_offset = c - data;
d2776 19
a2794 24
			sizdiff = strlen(expbuf) - (end - start);
			tbuflen = fin - end;
			tbuf = xmalloc(tbuflen);
			memcpy(tbuf, end, tbuflen);
			/* only realloc if we have to */
			if (sizdiff > 0) {
				char *newdata;

				len += sizdiff;
				newdata = xrealloc(data, 1, len);
				data = newdata;
				/*
				 * ensure string pointers are not invalidated
				 * after realloc()
				 */
				start = data + start_offset;
				fin = data + len;
				c = data + c_offset;
			}
			memcpy(start, expbuf, strlen(expbuf) + 1);
			start += strlen(expbuf);
			memcpy(start, tbuf, tbuflen);
			xfree(tbuf);
			c = start + strlen(expbuf);
d2798 1
a2798 5
	bp = rcs_buf_alloc(len - 1, BUF_AUTOEXT);
	rcs_buf_set(bp, data, len - 1, 0);
	xfree(data);

	return (bp);
@


1.22
log
@Remove file mode argument from {cvs|rcs}_buf_write_stmp().  We
always set the temporary file to mode 600, which is already done
by mkstemp().

OK joris@@ and xsa@@ over a month ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.21 2006/07/08 07:48:58 niallo Exp $	*/
d2759 1
a2759 1
			tbuflen = len - (end - start);
@


1.21
log
@- plug an old memory leak in patching code.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.20 2006/06/11 22:25:35 niallo Exp $	*/
d1400 1
a1400 1
		rcs_buf_write_stmp(nextbuf, path_tmp1, 0600);
d1404 1
a1404 1
		rcs_buf_write_stmp(prevbuf, path_tmp2, 0600);
@


1.20
log
@- clean up rcs_expand_keywords() a little more.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.19 2006/06/11 22:21:23 niallo Exp $	*/
d1085 3
@


1.19
log
@- zap unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.18 2006/06/09 22:09:33 niallo Exp $	*/
a2578 1
	i = 0;
a2628 1
			i++;
a2777 1
			i += sizdiff;
@


1.18
log
@- fix rcs_expand_keywords().

reported by Andreas Kahari <andreas.kahari at gmail>, input from joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.17 2006/06/04 18:57:37 niallo Exp $	*/
d2575 1
a2575 1
	size_t len, newlen, tbuflen;
a2588 1
	newlen = 0;
@


1.17
log
@- explicitly set some pointers to NULL since they are tested on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.16 2006/06/04 03:00:29 niallo Exp $	*/
d2617 1
d2623 1
a2623 1
	for (; c != fin; c++) {
d2775 1
d2777 2
a2778 2
			memcpy(start, expbuf, strlen(expbuf));
			start += sizdiff;
d2782 1
d2785 1
@


1.16
log
@- we can just use the 'sizdiff' variable instead of calling strlen(expbuf);
  simplifies things a little.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.15 2006/06/04 02:56:53 niallo Exp $	*/
d370 1
d1361 1
@


1.15
log
@- ensure fin pointer is not invalidated after realloc
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.14 2006/06/04 02:54:59 niallo Exp $	*/
d2774 1
a2774 1
			start += strlen(expbuf);
d2777 1
a2777 1
			i += strlen(expbuf);
@


1.14
log
@- don't forget to free data in rcs_expand_keywords()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.13 2006/06/04 02:54:07 niallo Exp $	*/
d2771 1
@


1.13
log
@- fix off-by-one in rcs_expand_keywords()
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.12 2006/06/03 03:05:10 niallo Exp $	*/
d2781 1
@


1.12
log
@- correctly handle binary files; say bye bye to using c strings for deltatexts.

"slap it in" joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.11 2006/05/28 18:33:49 ray Exp $	*/
d2779 2
a2780 2
	bp = rcs_buf_alloc(len, BUF_AUTOEXT);
	rcs_buf_set(bp, data, len, 0);
@


1.11
log
@Don't fill in the rd_locker if we are creating a new RCS file.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.10 2006/05/27 08:12:29 ray Exp $	*/
d237 1
a237 2
static char*   rcs_expand_keywords(char *, struct rcs_delta *, char *,
                    size_t, int);
a1137 1
	void *bp;
d1139 1
a1139 1
	BUF *rbuf;
d1253 4
a1256 4
		bp = rcs_buf_release(rbuf);
		rbuf = rcs_patchfile((char *)bp, (char *)rdp->rd_text,
		    rcs_patch_lines);
		xfree(bp);
d1355 1
a1355 1
	char *newdeltatext, *path_tmp1, *path_tmp2;
d1357 3
a1359 1
	BUF *nextbuf, *prevbuf, *newdiff;
d1380 1
a1380 2
	newdeltatext = NULL;
	prevbuf = nextbuf = NULL;
d1406 1
a1406 1
		newdeltatext = rcs_buf_release(newdiff);
d1408 1
a1408 1
		newdeltatext = rcs_buf_release(prevbuf);
a1436 3
	if (newdeltatext != NULL)
		xfree(newdeltatext);

d2092 9
a2100 5
	rdp->rd_text = xmalloc(RCS_TOKLEN(rfp) + 1);
	if (strlcpy(rdp->rd_text, RCS_TOKSTR(rfp), (RCS_TOKLEN(rfp) + 1)) >=
	    RCS_TOKLEN(rfp) + 1)
		errx(1, "rcs_parse_deltatext: strlcpy");
	rdp->rd_tlen = RCS_TOKLEN(rfp);
d2562 2
a2563 3
static char *
rcs_expand_keywords(char *rcsfile, struct rcs_delta *rdp, char *data,
    size_t len, int mode)
d2569 1
a2569 1
	char *c, *kwstr, *start, *end, *tbuf;
d2573 1
d2586 29
d2620 1
a2620 1
	for (c = data; *c != '\0' && i < len; c++) {
d2628 1
d2756 3
a2758 1
			tbuf = xstrdup(end);
a2770 1
				c = data + c_offset;
d2772 3
a2774 3
			if (strlcpy(start, expbuf, len) >= len ||
			    strlcat(data, tbuf, len) >= len)
				errx(1, "rcs_expand_keywords: string truncated");
d2779 2
d2782 1
a2782 1
	return (data);
d2792 1
a2792 1
rcs_deltatext_set(RCSFILE *rfp, RCSNUM *rev, const char *dtext)
d2795 1
d2807 3
a2809 1
	len = strlen(dtext);
d2811 1
a2811 2
		/* XXX - use xstrdup() if rd_text changes to char *. */
		rdp->rd_text = xmalloc(len + 1);
d2813 2
a2814 1
		(void)memcpy(rdp->rd_text, dtext, len + 1);
a2932 1
	char *expanded, *tbuf;
a2933 1
	size_t len;
d2946 1
a2946 8
		rcs_buf_putc(bp, '\0');
		len = rcs_buf_len(bp);
		tbuf = rcs_buf_release(bp);
		expanded = rcs_expand_keywords(rf->rf_path, rdp,
		    tbuf, len, expmode);
		bp = rcs_buf_alloc(len, BUF_AUTOEXT);
		rcs_buf_set(bp, expanded, strlen(expanded), 0);
		xfree(expanded);
@


1.10
log
@Rename RCSFILE.fd to RCSFILE.rf_fd, plus minor spacing nits.  No
binary change.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.9 2006/05/11 07:34:26 xsa Exp $	*/
d272 1
a272 1
	if (!(rfp->rf_flags & RCS_CREATE))
d275 8
a282 5
	/* fill in rd_locker */
	TAILQ_FOREACH(lkr, &(rfp->rf_locks), rl_list) {
		if ((rdp = rcs_findrev(rfp, lkr->rl_num)) == NULL) {
			rcs_close(rfp);
			return (NULL);
a283 2

		rdp->rd_locker = xstrdup(lkr->rl_name);
@


1.9
log
@first round of rcs_write() cleanup; prodded by joris@@; input/OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.8 2006/05/08 16:56:40 xsa Exp $	*/
d265 1
a265 1
	rfp->fd = fd;
d1723 1
a1723 1
	if ((pdp->rp_file = fdopen(rfp->fd, "r")) == NULL)
@


1.8
log
@check for rcs_diffreg() return value; OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.7 2006/05/04 07:06:58 xsa Exp $	*/
d217 1
a355 1
 * Returns 0 on success, or -1 on failure.
d357 1
a357 1
int
a361 1
	void *bp;
a366 1
	ssize_t nread, nwritten;
d368 1
a368 1
	int fd, from_fd, to_fd, ret;
a370 1
	ret = -1;
d373 1
a373 1
		return (0);
d499 1
a499 1
	fclose(fp);
d501 4
a504 12
	/*
	 * We try to use rename() to atomically put the new file in place.
	 * If that fails, we try a copy.
	 */
	if (rename(fn, rfp->rf_path) == -1) {
		if (errno == EXDEV) {
			/* rename() not supported so we have to copy. */
			if (chmod(rfp->rf_path, S_IWUSR) == -1 &&
			    !(rfp->rf_flags & RCS_CREATE)) {
				errx(1, "chmod(%s, 0%o) failed",
				    rfp->rf_path, S_IWUSR);
			}
d506 1
a506 4
			if ((from_fd = open(fn, O_RDONLY)) == -1) {
				warn("failed to open `%s'", rfp->rf_path);
				goto out;
			}
d508 3
a510 5
			if ((to_fd = open(rfp->rf_path,
			    O_WRONLY|O_TRUNC|O_CREAT)) == -1) {
				warn("failed to open `%s'", fn);
				goto out;
			}
d512 13
a524 10
			bp = xmalloc(MAXBSIZE);
			for (;;) {
				if ((nread = read(from_fd, bp, MAXBSIZE)) == 0)
					break;
				if (nread == -1)
					goto err;
				nwritten = write(to_fd, bp, (size_t)nread);
				if (nwritten == -1 || nwritten != nread)
					goto err;
			}
d526 1
a526 8
			if (nread < 0) {
err:				if (unlink(rfp->rf_path) == -1)
					warn("failed to unlink `%s'",
					    rfp->rf_path);
				xfree(bp);
				goto out;
			}
			xfree(bp);
d528 4
a531 7
			if (unlink(fn) == -1) {
				warn("failed to unlink `%s'", fn);
				goto out;
			}
		} else {
			warn("failed to access temp RCS output file");
			goto out;
d533 4
d539 3
a541 3
	if (chmod(rfp->rf_path, rfp->rf_mode) == -1) {
		warn("failed to chmod `%s'", rfp->rf_path);
		goto out;
d544 29
a572 1
	rfp->rf_flags |= RCS_SYNCED;
d575 5
d581 1
a581 5
	(void)close(from_fd);
	(void)close(to_fd);

	if (fn != NULL)
		xfree(fn);
@


1.7
log
@finish work wrt TMPDIR; use xasprintf() to simplify code while in there;
"looks fine" ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.6 2006/05/01 18:17:39 niallo Exp $	*/
d1393 2
a1394 1
		rcs_diffreg(path_tmp1, path_tmp2, newdiff);
@


1.6
log
@- fix a case in rcs_getrev() handling of branches where variant was not being
  increased and thus no progress could be made in the loop.

bug noticed in rcsdiff(1) by sturm@@

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.5 2006/04/29 05:31:28 ray Exp $	*/
d361 1
a361 1
	char buf[1024], numbuf[64], fn[20] = "";
d370 1
a370 1
	int fd, from_fd, to_fd;
d373 1
d381 2
a382 2
	if (strlcpy(fn, "/tmp/rcs.XXXXXXXXXX", sizeof(fn)) >= sizeof(fn))
		errx(1, "rcs_write: string truncated");
d518 2
a519 3
				warn("failed to open `%s'",
				    rfp->rf_path);
				return (-1);
d525 1
a525 2
				close(from_fd);
				return (-1);
a542 2
				close(from_fd);
				close(to_fd);
d544 1
a544 1
				return (-1);
a545 3

			close(from_fd);
			close(to_fd);
d550 1
a550 1
				return (-1);
d554 1
a554 1
			return (-1);
d560 1
a560 1
		return (-1);
d565 9
a573 1
	return (0);
d1346 1
a1346 3
	size_t len;
	char *tmpdir;
	char *newdeltatext, path_tmp1[MAXPATHLEN], path_tmp2[MAXPATHLEN];
a1349 2
	tmpdir = rcs_tmpdir;

d1384 1
a1384 9
		len = strlcpy(path_tmp1, tmpdir, sizeof(path_tmp1));
		if (len >= sizeof(path_tmp1))
			errx(1, "path truncation in rcs_rev_remove");

		len = strlcat(path_tmp1, "/diff1.XXXXXXXXXX",
		    sizeof(path_tmp1));
		if (len >= sizeof(path_tmp1))
			errx(1, "path truncation in rcs_rev_remove");

d1388 1
a1388 9
		len = strlcpy(path_tmp2, tmpdir, sizeof(path_tmp2));
		if (len >= sizeof(path_tmp2))
			errx(1, "path truncation in rcs_rev_remove");

		len = strlcat(path_tmp2, "/diff2.XXXXXXXXXX",
		    sizeof(path_tmp2));
		if (len >= sizeof(path_tmp2))
			errx(1, "path truncation in rcs_rev_remove");

d1428 5
@


1.5
log
@Check return values for all strlcpy, and strlcat calls.

OK xsa@@ and probably others.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.4 2006/04/27 07:59:33 xsa Exp $	*/
d1124 1
a1124 1
	int isbranch, lookonbranch;
d1196 2
d1220 1
d1224 2
@


1.4
log
@zap util.[ch] and move the content into rcsutil.[ch].
discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.3 2006/04/26 21:55:22 joris Exp $	*/
d361 1
a361 1
	char buf[1024], numbuf[64], fn[19] = "";
d380 2
a381 1
	strlcpy(fn, "/tmp/rcs.XXXXXXXXXX", sizeof(fn));
d386 3
d390 1
d415 4
a418 3
		strlcpy(buf, symp->rs_name, sizeof(buf));
		strlcat(buf, ":", sizeof(buf));
		strlcat(buf, numbuf, sizeof(buf));
d2093 3
a2095 1
	strlcpy(rdp->rd_text, RCS_TOKSTR(rfp), (RCS_TOKLEN(rfp) + 1));
d2380 3
a2382 1
		strlcpy(pdp->rp_buf, pdp->rp_ptok, pdp->rp_blen);
d2496 3
a2498 1
	strlcpy(pdp->rp_ptok, tok, sizeof(pdp->rp_ptok));
d2648 6
a2653 4
				strlcat(expbuf, "$", sizeof(expbuf));
				strlcat(expbuf, kwstr, sizeof(expbuf));
				if (mode & RCS_KWEXP_VAL)
					strlcat(expbuf, ": ", sizeof(expbuf));
d2663 1
a2663 3
						strlcat(expbuf,
						    basename(rcsfile),
						    sizeof(expbuf));
d2665 3
a2667 3
						strlcat(expbuf, rcsfile,
						    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2671 4
a2674 4
					rcsnum_tostr(rdp->rd_num, buf,
					    sizeof(buf));
					strlcat(buf, " ", sizeof(buf));
					strlcat(expbuf, buf, sizeof(expbuf));
d2684 2
a2685 1
					strlcat(expbuf, buf, sizeof(expbuf));
d2689 3
a2691 3
					strlcat(expbuf, rdp->rd_author,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2695 3
a2697 3
					strlcat(expbuf, rdp->rd_state,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2702 2
a2703 1
					strlcat(expbuf, " ", sizeof(expbuf));
d2706 3
a2708 3
					strlcat(expbuf, rcsfile,
					    sizeof(expbuf));
					strlcat(expbuf, " ", sizeof(expbuf));
d2712 2
a2713 1
					strlcat(expbuf, " ", sizeof(expbuf));
d2718 2
a2719 1
				strlcat(expbuf, "$", sizeof(expbuf));
d2737 3
a2739 2
			strlcpy(start, expbuf, len);
			strlcat(data, tbuf, len);
d2907 1
a2907 1
		    errx(1, "could not fetch revision");
@


1.3
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.2 2006/04/26 15:08:25 xsa Exp $	*/
a29 1
#include "util.h"
d32 1
@


1.2
log
@err() cleanup;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.1 2006/04/26 02:55:13 joris Exp $	*/
a238 12
/*
 * rcs_open()
 *
 * Open a file containing RCS-formatted information.  The file's path is
 * given in <path>, and the opening flags are given in <flags>, which is either
 * RCS_READ, RCS_WRITE, or RCS_RDWR.  If the open requests write access and
 * the file does not exist, the RCS_CREATE flag must also be given, in which
 * case it will be created with the mode specified in a third argument of
 * type mode_t.  If the file exists and RCS_CREATE is passed, the open will
 * fail.
 * Returns a handle to the opened file on success, or NULL on failure.
 */
d240 1
a240 1
rcs_open(const char *path, int flags, ...)
d242 1
a242 1
	int ret, mode;
a244 1
	struct stat st;
d252 5
a256 13
	if (((ret = stat(path, &st)) == -1) && errno == ENOENT) {
		if (flags & RCS_CREATE) {
			va_start(vap, flags);
			mode = va_arg(vap, int);
			va_end(vap);
			fmode = (mode_t)mode;
		} else {
			rcs_errno = RCS_ERR_NOENT;
			return (NULL);
		}
	} else if (ret == 0 && (flags & RCS_CREATE)) {
		warnx("RCS file `%s' exists", path);
		return (NULL);
d264 1
d1714 2
a1715 2
	if ((pdp->rp_file = fopen(rfp->rf_path, "r")) == NULL)
		err(1, "%s", rfp->rf_path);
@


1.1
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcs.c,v 1.170 2006/04/25 10:31:39 xsa Exp $	*/
d402 1
a402 1
		err(1, "mkstemp: `%s'", fn);
d405 2
a406 3
		fd = errno;
		unlink(fn);
		err(1, "fdopen: %s", fn);
d1735 1
a1735 1
		err(1, "fopen: `%s'", rfp->rf_path);
@

