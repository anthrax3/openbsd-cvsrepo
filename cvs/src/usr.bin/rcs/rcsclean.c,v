head	1.56;
access;
symbols
	OPENBSD_6_1:1.56.0.2
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.20
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.52.0.18
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.52.0.14
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.52.0.12
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.52.0.10
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.8
	OPENBSD_5_0:1.52.0.6
	OPENBSD_5_0_BASE:1.52
	OPENBSD_4_9:1.52.0.4
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.52.0.2
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.50.0.10
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.12
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.8
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.6
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.4
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.48.0.2
	OPENBSD_4_1_BASE:1.48
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23;
locks; strict;
comment	@ * @;


1.56
date	2016.08.26.09.02.54;	author guenther;	state Exp;
branches;
next	1.55;
commitid	07zudOJ8CxdoPUjD;

1.55
date	2015.11.02.16.45.21;	author nicm;	state Exp;
branches;
next	1.54;
commitid	aZp5pu4rATnp3dyP;

1.54
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	Uu5nFG3wCl0LACBb;

1.53
date	2014.10.02.06.23.15;	author otto;	state Exp;
branches;
next	1.52;
commitid	yRuTsAu91VfT3St0;

1.52
date	2010.07.28.09.07.11;	author ray;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.23.21.46.05;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.30.08.23.49;	author xsa;	state Exp;
branches;
next	1.49;

1.49
date	2007.04.16.07.35.10;	author xsa;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.27.07.59.13;	author xsa;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.27.05.49.14;	author ray;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.09.12.33.42;	author ray;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.26.21.55.22;	author joris;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.26.02.55.13;	author joris;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.25.13.36.35;	author xsa;	state Exp;
branches;
next	1.42;

1.42
date	2006.04.25.03.21.16;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.24.16.20.33;	author jmc;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.24.08.10.41;	author xsa;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.21.17.17.29;	author xsa;	state Exp;
branches;
next	1.38;

1.38
date	2006.04.21.14.18.26;	author xsa;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.19.06.53.41;	author xsa;	state Exp;
branches;
next	1.36;

1.36
date	2006.04.17.04.50.08;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.14.16.28.24;	author ray;	state Exp;
branches;
next	1.34;

1.34
date	2006.04.14.16.16.02;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.14.01.11.07;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.13.16.23.31;	author ray;	state Exp;
branches;
next	1.31;

1.31
date	2006.04.13.00.58.25;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.12.08.23.30;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.10.08.08.00;	author xsa;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.24.15.57.29;	author xsa;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.24.05.14.48;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.16.04.04.57;	author ray;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.15.05.05.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.06.14.59.06;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.05.10.28.24;	author xsa;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.02.08.13.28;	author xsa;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.19.18.24.12;	author xsa;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.10.20.27.46;	author joris;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.08.18.56.10;	author joris;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.28.14.43.59;	author xsa;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.25.14.16.44;	author xsa;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.23.09.39.20;	author xsa;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.21.16.20.29;	author xsa;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.17.18.14.12;	author xsa;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.16.11.42.03;	author xsa;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.02.11.01.40;	author xsa;	state Exp;
branches;
next	1.11;

1.11
date	2005.10.29.09.27.02;	author xsa;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.19.18.28.13;	author xsa;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.19.16.15.36;	author xsa;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.18.01.22.14;	author joris;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.13.12.35.30;	author joris;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.12.17.43.18;	author xsa;	state Exp;
branches;
next	1.5;

1.5
date	2005.10.12.17.13.30;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.07.23.59.56;	author niallo;	state Exp;
branches;
next	1.3;

1.3
date	2005.10.06.11.46.03;	author joris;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.06.02.12.53;	author joris;	state Exp;
branches;
next	1.1;

1.1
date	2005.10.06.02.00.05;	author joris;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Pull in <time.h> for struct tm, used in rcs.h

ok deraadt@@
@
text
@/*	$OpenBSD: rcsclean.c,v 1.55 2015/11/02 16:45:21 nicm Exp $	*/
/*
 * Copyright (c) 2005 Joris Vink <joris@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>

#include <dirent.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#include "rcsprog.h"
#include "diff.h"

static void	rcsclean_file(char *, const char *);

static int nflag = 0;
static int kflag = RCS_KWEXP_ERR;
static int uflag = 0;
static int flags = 0;
static char *locker = NULL;

int
rcsclean_main(int argc, char **argv)
{
	int i, ch;
	char *rev_str;
	DIR *dirp;
	struct dirent *dp;

	rev_str = NULL;

	while ((ch = rcs_getopt(argc, argv, "k:n::q::r::Tu::Vx::")) != -1) {
		switch (ch) {
		case 'k':
			kflag = rcs_kflag_get(rcs_optarg);
			if (RCS_KWEXP_INVAL(kflag)) {
				warnx("invalid RCS keyword substitution mode");
				(usage)();
			}
			break;
		case 'n':
			rcs_setrevstr(&rev_str, rcs_optarg);
			nflag = 1;
			break;
		case 'q':
			rcs_setrevstr(&rev_str, rcs_optarg);
			flags |= QUIET;
			break;
		case 'r':
			rcs_setrevstr(&rev_str, rcs_optarg);
			break;
		case 'T':
			flags |= PRESERVETIME;
			break;
		case 'u':
			rcs_setrevstr(&rev_str, rcs_optarg);
			uflag = 1;
			break;
		case 'V':
			printf("%s\n", rcs_version);
			exit(0);
		case 'x':
			/* Use blank extension if none given. */
			rcs_suffixes = rcs_optarg ? rcs_optarg : "";
			break;
		default:
			(usage)();
		}
	}

	argc -= rcs_optind;
	argv += rcs_optind;

	if ((locker = getlogin()) == NULL)
		err(1, "getlogin");

	if (argc == 0) {
		if ((dirp = opendir(".")) == NULL) {
			warn("opendir");
			(usage)();
		}

		while ((dp = readdir(dirp)) != NULL) {
			if (dp->d_type == DT_DIR)
				continue;
			rcsclean_file(dp->d_name, rev_str);
		}

		(void)closedir(dirp);
	} else
		for (i = 0; i < argc; i++)
			rcsclean_file(argv[i], rev_str);

	return (0);
}

__dead void
rcsclean_usage(void)
{
	fprintf(stderr,
	    "usage: rcsclean [-TV] [-kmode] [-n[rev]] [-q[rev]] [-r[rev]]\n"
	    "                [-u[rev]] [-xsuffixes] [-ztz] [file ...]\n");

	exit(1);
}

static void
rcsclean_file(char *fname, const char *rev_str)
{
	int fd, match;
	RCSFILE *file;
	char fpath[PATH_MAX], numb[RCS_REV_BUFSZ];
	RCSNUM *rev;
	BUF *b1, *b2;
	time_t rcs_mtime = -1;

	b1 = b2 = NULL;
	file = NULL;
	rev = NULL;

	if ((fd = rcs_choosefile(fname, fpath, sizeof(fpath))) < 0)
		goto out;

	if ((file = rcs_open(fpath, fd, RCS_RDWR)) == NULL)
		goto out;

	if (flags & PRESERVETIME)
		rcs_mtime = rcs_get_mtime(file);

	rcs_kwexp_set(file, kflag);

	if (rev_str == NULL)
		rev = file->rf_head;
	else if ((rev = rcs_getrevnum(rev_str, file)) == NULL) {
		warnx("%s: Symbolic name `%s' is undefined.", fpath, rev_str);
		goto out;
	}

	if ((b1 = rcs_getrev(file, rev)) == NULL) {
		warnx("failed to get needed revision");
		goto out;
	}
	if ((b2 = buf_load(fname)) == NULL) {
		warnx("failed to load `%s'", fname);
		goto out;
	}

	/* If buffer lengths are the same, compare contents as well. */
	if (buf_len(b1) != buf_len(b2))
		match = 0;
	else {
		size_t len, n;

		len = buf_len(b1);

		match = 1;
		for (n = 0; n < len; ++n)
			if (buf_getc(b1, n) != buf_getc(b2, n)) {
				match = 0;
				break;
			}
	}

	if (match == 1) {
		if (uflag == 1 && !TAILQ_EMPTY(&(file->rf_locks))) {
			if (!(flags & QUIET) && nflag == 0) {
				printf("rcs -u%s %s\n",
				    rcsnum_tostr(rev, numb, sizeof(numb)),
				    fpath);
			}
			(void)rcs_lock_remove(file, locker, rev);
		}

		if (TAILQ_EMPTY(&(file->rf_locks))) {
			if (!(flags & QUIET))
				printf("rm -f %s\n", fname);

			if (nflag == 0)
				(void)unlink(fname);
		}
	}

	rcs_write(file);
	if (flags & PRESERVETIME)
		rcs_set_mtime(file, rcs_mtime);

out:
	buf_free(b1);
	buf_free(b2);
	if (file != NULL)
		rcs_close(file);
}
@


1.55
log
@Allow rcsnum_free and buf_free to accept NULL and remove various NULL
checks that are now unnecessary, from Michael W Bombardieri. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.54 2015/01/16 06:40:11 deraadt Exp $	*/
d33 1
@


1.54
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.53 2014/10/02 06:23:15 otto Exp $	*/
d212 2
a213 4
	if (b1 != NULL)
		buf_free(b1);
	if (b2 != NULL)
		buf_free(b2);
@


1.53
log
@exit in usage functions themselves; from  Fritjof Bornebusch; ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.52 2010/07/28 09:07:11 ray Exp $	*/
d136 1
a136 1
	char fpath[MAXPATHLEN], numb[RCS_REV_BUFSZ];
@


1.52
log
@Make BUFs autoextend by default.  This was already done in OpenCVS
a while ago.

OK zinovik nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.51 2010/07/23 21:46:05 ray Exp $	*/
a62 1
				exit(1);
a91 1
			exit(1);
a104 1
			exit(1);
d121 1
a121 1
void
d127 2
@


1.51
log
@Reduce variable/function name and whitespace differences between
cvs/rcs.

OK xsa zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.50 2007/06/30 08:23:49 xsa Exp $	*/
d168 1
a168 1
	if ((b2 = buf_load(fname, 0)) == NULL) {
@


1.50
log
@Sync revisions and time buffers size to be consistent with each others.
Simplifies further size tweaks if needed.
OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.49 2007/04/16 07:35:10 xsa Exp $	*/
d168 1
a168 1
	if ((b2 = rcs_buf_load(fname, 0)) == NULL) {
d174 1
a174 1
	if (rcs_buf_len(b1) != rcs_buf_len(b2))
d179 1
a179 1
		len = rcs_buf_len(b1);
d183 1
a183 1
			if (rcs_buf_getc(b1, n) != rcs_buf_getc(b2, n)) {
d214 1
a214 1
		rcs_buf_free(b1);
d216 1
a216 1
		rcs_buf_free(b2);
@


1.49
log
@file argument is not mandatory, say so.
from Pierre Riteau via ray@@; OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.48 2007/02/27 07:59:13 xsa Exp $	*/
d137 1
a137 1
	char fpath[MAXPATHLEN], numb[64];
@


1.48
log
@As done in OpenCVS, general includes cleanup sweep. OK otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.47 2006/05/27 05:49:14 ray Exp $	*/
d129 1
a129 1
	    "                [-u[rev]] [-xsuffixes] [-ztz] [file] ...\n");
@


1.47
log
@Remove rcs_statfile().  It was just a wrapper for rcs_choosefile(),
handling exceptions oddly.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.46 2006/05/09 12:33:42 ray Exp $	*/
d27 7
a33 1
#include "includes.h"
@


1.46
log
@Remove /* NOTREACHED */ comments, now that lint is smart about
__dead.  I never should have put them there.

OK xsa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.45 2006/04/26 21:55:22 joris Exp $	*/
d140 1
a140 1
	if ((fd = rcs_statfile(fname, fpath, sizeof(fpath), flags)) < 0)
@


1.45
log
@prevent file races by obtaining an fd for the RCS file and
do our operations on that, this is safe and guarantees we
can operate on the file until we close(2) it.

a fix is coming for the remaining races in our diff code.
okay niallo@@ and ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.44 2006/04/26 02:55:13 joris Exp $	*/
a80 1
			/* NOTREACHED */
@


1.44
log
@fork our code we shared between openrcs/cvs into the openrcs dir.

this was starting to become inhuman to maintain without
ugly ugly hacks in the shared code, and it will be easier
to make specific changes for openrcs without touching the
soon-to-be-replaced opencvs code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.43 2006/04/25 13:36:35 xsa Exp $	*/
d130 1
a130 1
	int match;
d141 1
a141 1
	if (rcs_statfile(fname, fpath, sizeof(fpath), flags) < 0)
d144 1
a144 1
	if ((file = rcs_open(fpath, RCS_RDWR)) == NULL)
d148 1
a148 1
		rcs_mtime = rcs_get_mtime(file->rf_path);
d203 1
d205 1
a205 1
		rcs_set_mtime(fpath, rcs_mtime);
@


1.43
log
@fatal() -> err()/errx() as we try to not depend on heavy cvs_log().
OK joriski.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.42 2006/04/25 03:21:16 ray Exp $	*/
d163 1
a163 1
	if ((b2 = cvs_buf_load(fname, 0)) == NULL) {
d169 1
a169 1
	if (cvs_buf_len(b1) != cvs_buf_len(b2))
d174 1
a174 1
		len = cvs_buf_len(b1);
d178 1
a178 1
			if (cvs_buf_getc(b1, n) != cvs_buf_getc(b2, n)) {
d208 1
a208 1
		cvs_buf_free(b1);
d210 1
a210 1
		cvs_buf_free(b2);
@


1.42
log
@The -r flag without an argument signifies HEAD for rcsclean.

OK xsa@@ and joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.41 2006/04/24 16:20:33 jmc Exp $	*/
d96 1
a96 1
		fatal("getlogin failed");
@


1.41
log
@- the argument to -r is optional
- beef up DESCRIPTION
- better descriptions of -r and -u
- sync usage()

help/ok xsa
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.40 2006/04/24 08:10:41 xsa Exp $	*/
d50 1
a50 1
	while ((ch = rcs_getopt(argc, argv, "k:n::q::r:Tu::Vx::")) != -1) {
@


1.40
log
@be consistent in error messages for wrongly specified keyword substitution
mode for `-k'.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.39 2006/04/21 17:17:29 xsa Exp $	*/
d123 2
a124 2
	    "usage: rcsclean [-TV] [-kmode] [-n[rev]] [-q[rev]]\n"
	    "                [-rrev] [-u[rev]] [-xsuffixes] [-ztz] [file] ...\n");
@


1.39
log
@move shared functions into rcsutil.[ch]; this makes rcsprog.c cleaner;
"the voices in my head say OK!" joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.38 2006/04/21 14:18:26 xsa Exp $	*/
d55 1
a55 1
				warnx("invalid RCS keyword expansion mode");
@


1.38
log
@remove overkill cvs_log() and rather use warn()/warnx().
OK ray@@ and discussed with joris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.37 2006/04/19 06:53:41 xsa Exp $	*/
d141 1
a141 1
	if (rcs_statfile(fname, fpath, sizeof(fpath)) < 0)
@


1.37
log
@switch -q handling to bitwise flags; OK ray@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.36 2006/04/17 04:50:08 ray Exp $	*/
d55 1
a55 2
				cvs_log(LP_ERR,
				    "invalid RCS keyword expansion mode");
d100 1
a100 1
			cvs_log(LP_ERRNO, "failed to open directory '.'");
d111 1
a111 1
		closedir(dirp);
d155 1
a155 2
		cvs_log(LP_ERR, "%s: Symbolic name `%s' is undefined.",
		    fpath, rev_str);
d160 1
a160 1
		cvs_log(LP_ERR, "failed to get needed revision");
d164 1
a164 1
		cvs_log(LP_ERRNO, "failed to load '%s'", fname);
@


1.36
log
@Remove pointless stat() call.

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.35 2006/04/14 16:28:24 ray Exp $	*/
d67 1
a67 1
			verbose = 0;
d188 1
a188 1
			if (verbose == 1 && nflag == 0) {
d197 1
a197 1
			if (verbose == 1)
@


1.35
log
@Add missing usage() calls.

``crazy'' joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.34 2006/04/14 16:16:02 ray Exp $	*/
a135 1
	struct stat st;
a140 3

	if (stat(fname, &st) == -1)
		goto out;
@


1.34
log
@Plug obvious memory leaks.

The comparison function was previously changed by me to use strcmp,
which is probably wrong since a buffer can theoretically have NULs
in it.  This fixes it.  (In my defense, the original code converted
the buffer text to char * values and compared until there was either
a difference or until a NUL was reached, so my previous change was
no worse.)

OK joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.33 2006/04/14 01:11:07 deraadt Exp $	*/
d88 2
a89 1
			break;
@


1.33
log
@excessive addition to brackets is a mental disease.  you will go
blind, too.  seek help.  no binary change, ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.32 2006/04/13 16:23:31 ray Exp $	*/
a134 1
	char *c1, *c2;
d138 3
a140 1
	match = 1;
d143 1
a143 1
		return;
d146 1
a146 1
		return;
d149 1
a149 1
		return;
d161 1
a161 2
		rcs_close(file);
		return;
d166 1
a166 2
		rcs_close(file);
		return;
d168 1
a168 2

	if ((b2 = cvs_buf_load(fname, BUF_AUTOEXT)) == NULL) {
d170 1
a170 2
		rcs_close(file);
		return;
d173 5
a177 2
	cvs_buf_putc(b1, '\0');
	cvs_buf_putc(b2, '\0');
d179 1
a179 2
	c1 = cvs_buf_release(b1);
	c2 = cvs_buf_release(b2);
d181 7
a187 6
	/* XXX - Compare using cvs_buf_len() first. */
	if (strcmp(c1, c2) != 0)
		match = 0;

	xfree(c1);
	xfree(c2);
a207 2
	rcs_close(file);

d210 8
@


1.32
log
@Remove unused variable.

Found by lint.

OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.31 2006/04/13 00:58:25 ray Exp $	*/
d190 2
a191 2
		if ((uflag == 1) && (!TAILQ_EMPTY(&(file->rf_locks)))) {
			if ((verbose == 1) && (nflag == 0)) {
@


1.31
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.30 2006/04/12 08:23:30 ray Exp $	*/
a44 1
	RCSNUM *rev;
a47 1
	rev = RCS_HEAD_REV;
@


1.30
log
@Clean up <rev> handling.  Whenever a revision is specified after a
flag, it calls one of two new functions: rcs_setrevstr() or
rcs_setrevstr2().  rcs_setrevstr() sets a string to another string,
and complains if it was set more than once.  rcs_setrevstr2() takes
two strings, sets one after the other, and fatal()s if more than
two strings were given.

All <rev> handling is now done in the loop that goes through each
argv.  This is necessary for parsing symbols, which will be much
easier after this.

Along the way a lot of memory leaks were cleaned up.  There is one
area where rcs_set_rev() is called, which allocates a RCSNUM and
stores it in pb.newrev, but it segfaults whenever I try to rcsnum_free()
it.  I put an /* XXX */ comment there for now.

Passes regression tests and the code is less complicated in some
ways (to me).

Suggestions and OK xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.29 2006/04/10 08:08:00 xsa Exp $	*/
d32 1
a32 1
static void	rcsclean_file(char *, RCSNUM *);
d110 1
a110 3
			rcs_set_rev(rev_str, &rev);
			rcsclean_file(dp->d_name, rev);
			rcsnum_free(rev);
d115 2
a116 5
		for (i = 0; i < argc; i++) {
			rcs_set_rev(rev_str, &rev);
			rcsclean_file(argv[i], rev);
			rcsnum_free(rev);
		}
d130 1
a130 1
rcsclean_file(char *fname, RCSNUM *rev)
d135 1
a135 1
	RCSNUM *frev;
d137 1
a137 1
	char *s1, *s2, *c1, *c2;
d157 8
a164 4
	if (rev == RCS_HEAD_REV)
		frev = file->rf_head;
	else
		frev = rev;
d166 1
a166 1
	if ((b1 = rcs_getrev(file, frev)) == NULL) {
d184 3
a186 6
	for (s1 = c1, s2 = c2; *s1 && *s2; s1++, s2++) {
		if (*s1 != *s2) {
			match = 0;
			break;
		}
	}
d195 1
a195 1
				    rcsnum_tostr(frev, numb, sizeof(numb)),
d198 1
a198 1
			(void)rcs_lock_remove(file, locker, frev);
@


1.29
log
@change rcs_kwexp_set() return type to void and simplify its use. OK niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.28 2006/03/24 15:57:29 xsa Exp $	*/
d44 1
d50 1
d64 1
a64 1
			rcs_set_rev(rcs_optarg, &rev);
d68 1
a68 1
			rcs_set_rev(rcs_optarg, &rev);
d72 1
a72 1
			rcs_set_rev(rcs_optarg, &rev);
d78 1
a78 1
			rcs_set_rev(rcs_optarg, &rev);
d110 1
d112 1
d116 3
a118 2
	} else {
		for (i = 0; i < argc; i++)
d120 2
a121 1
	}
@


1.28
log
@change rcsclean_file() return type to void as it does not need
to be checked. OK ray@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.27 2006/03/24 05:14:48 ray Exp $	*/
d154 1
a154 2
	if (!RCS_KWEXP_INVAL(kflag))
		rcs_kwexp_set(file, kflag);
@


1.27
log
@Allow the -x flag to be used without an extension.

``that makes sense'' xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.26 2006/03/16 04:04:57 ray Exp $	*/
d32 2
a33 1
static int rcsclean_file(char *, RCSNUM *);
d128 1
a128 1
static int
d143 1
a143 1
		return (-1);
d146 1
a146 1
		return (-1);
d149 1
a149 1
		return (-1);
d165 1
a165 1
		return (-1);
d171 1
a171 1
		return (-1);
a212 2

	return (0);
@


1.26
log
@Follow exit() with /* NOTREACHED*/ for lint.

``OK niallo@@'' niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.25 2006/03/15 05:05:36 deraadt Exp $	*/
d49 1
a49 1
	while ((ch = rcs_getopt(argc, argv, "k:n::q::r:Tu::Vx:")) != -1) {
d83 2
a84 1
			rcs_suffixes = rcs_optarg;
@


1.25
log
@remove some bizzare idioms; ok ray
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.24 2006/03/06 14:59:06 jmc Exp $	*/
d81 1
@


1.24
log
@update usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.23 2006/01/05 10:28:24 xsa Exp $	*/
d177 1
a177 1
	for (s1 = c1, s2 = c2; *s1 && *s2; *s1++, *s2++) {
@


1.23
log
@cleanup, move log.h and rcs.h inclusion into rcsprog.h;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.22 2006/01/02 08:13:28 xsa Exp $	*/
d121 2
a122 2
	    "usage: rcsclean [-V] [-kmode] [-n[rev]] [-q[rev]]\n"
	    "                [-rrev] [-u[rev]] [-xsuffixes] [file] ...\n");
@


1.22
log
@#include's cleanup; ok joris@@ niallo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.21 2005/12/19 18:24:12 xsa Exp $	*/
d29 1
a29 2
#include "log.h"
#include "rcs.h"
a30 1
#include "rcsprog.h"
@


1.21
log
@use fatal() if getlogin() fails;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.20 2005/12/10 20:27:46 joris Exp $	*/
d27 1
a27 8
#include <sys/param.h>
#include <sys/stat.h>

#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
@


1.20
log
@switch to xmalloc stuff, me and xsa@@ agreed on this a long
time ago, but we were being held back by jfb. too bad for him.

next step is to use fatal() through out the code for unrecoverable
errors instead of trying to be all nice and fluffy and reach main() again.

ok niallo@@ and xsa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.19 2005/12/08 18:56:10 joris Exp $	*/
d102 1
a102 1
		exit(1);
@


1.19
log
@complete and correct rcs locking functionality,
it was only done partially and as a bonus, completely wrong.

seriously guys what was up with that?
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.18 2005/11/28 14:43:59 xsa Exp $	*/
d193 2
a194 2
	free(c1);
	free(c2);
@


1.18
log
@sync usage() for `-xsuffixes';
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.17 2005/11/25 14:16:44 xsa Exp $	*/
d46 1
d101 3
d203 1
a203 1
			(void)rcs_lock_remove(file, frev);
@


1.17
log
@add `-T' support for rcsclean(1) and rcs(1);
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.16 2005/11/23 09:39:20 xsa Exp $	*/
d127 1
a127 1
	    "                [-rrev] [-u[rev]] [file] ...\n");
@


1.16
log
@initial bits for -T support;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.15 2005/11/21 16:20:29 xsa Exp $	*/
d45 1
d50 1
a50 1
	int i, ch, flags;
a54 1
	flags = 0;
d140 1
d153 3
d212 4
@


1.15
log
@enable `-xsuffixes' support as it has been added a few days ago
in rcs_statfile();
niallo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.14 2005/11/17 18:14:12 xsa Exp $	*/
d49 1
a49 1
	int i, ch;
d54 1
d57 1
a57 1
	while ((ch = rcs_getopt(argc, argv, "k:n::q::r:u::Vx:")) != -1) {
d78 3
@


1.14
log
@yet another output fix;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.13 2005/11/16 11:42:03 xsa Exp $	*/
d56 1
a56 1
	while ((ch = rcs_getopt(argc, argv, "k:n::q::r:u::V")) != -1) {
d85 3
@


1.13
log
@fix output if file is not locked;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.12 2005/11/02 11:01:40 xsa Exp $	*/
a187 1

d191 3
a193 2
		if (verbose == 1)
			printf("rm -f %s\n", fname);
d195 3
a197 2
		if ((nflag == 0) && (TAILQ_EMPTY(&(file->rf_locks))))
			(void)unlink(fname);
@


1.12
log
@sync with Reality;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.11 2005/10/29 09:27:02 xsa Exp $	*/
d182 1
a182 1
		if (uflag == 1) {
@


1.11
log
@rcsclean -u support; ok joris niallo
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.10 2005/10/19 18:28:13 xsa Exp $	*/
d56 1
a56 1
	while ((ch = rcs_getopt(argc, argv, "k:nqr:uV")) != -1) {
d68 1
d72 1
d79 1
d119 2
a120 1
	    "usage: rcsclean [-nquV] [-kmode] [-rrev] [file] ...\n");
@


1.10
log
@sync usage();
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.9 2005/10/19 16:15:36 xsa Exp $	*/
d44 1
d56 1
a56 1
	while ((ch = rcs_getopt(argc, argv, "k:nqr:V")) != -1) {
d76 3
d116 1
a116 1
	    "usage: rcsclean [-nqV] [-kmode] [-rrev] [file] ...\n");
d124 1
a124 1
	char fpath[MAXPATHLEN];
d178 10
d190 2
a191 1
		if (nflag == 0)
@


1.9
log
@.Xr rcsmerge(1) + one style nitpick;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.8 2005/10/18 01:22:14 joris Exp $	*/
d112 1
a112 1
	    "usage: rcsclean [-qV] [-r rev] [file] ...\n");
@


1.8
log
@use rcs_set_rev() instead of duplicating code all over the
place to set a variable to the given revision number;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.7 2005/10/13 12:35:30 joris Exp $	*/
d173 1
a173 1
	if (match) {
@


1.7
log
@To be fully compatibly with the GNU RCS tools we need to have the
same way of parsing commandline options. Since getopt(3) allows spaces
between arguments and GNU RCS tools does not we needed to roll out our
own way of option handling, and here it is.

ok niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.6 2005/10/12 17:43:18 xsa Exp $	*/
d73 1
a73 4
			if ((rev = rcsnum_parse(rcs_optarg)) == NULL) {
				cvs_log(LP_ERR, "bad revision number");
				exit(1);
			}
@


1.6
log
@minor knf;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.5 2005/10/12 17:13:30 deraadt Exp $	*/
d55 1
a55 1
	while ((ch = getopt(argc, argv, "k:nqr:V")) != -1) {
d58 1
a58 1
			kflag = rcs_kflag_get(optarg);
d73 1
a73 1
			if ((rev = rcsnum_parse(optarg)) == NULL) {
d86 2
a87 2
	argc -= optind;
	argv += optind;
@


1.5
log
@various usage cleanup; ok joris
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.4 2005/10/07 23:59:56 niallo Exp $	*/
d177 1
a177 1
		if (verbose)
@


1.4
log
@basic `ci' support is here! more coming soon.

combined effort with joris.

ok joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.3 2005/10/06 11:46:03 joris Exp $	*/
a40 1
extern char *__progname;
d114 2
a115 1
	fprintf(stderr, "usage %s [-qV] [-r rev] [file] ...\n", __progname);
@


1.3
log
@support -n and -k flags;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.2 2005/10/06 02:12:53 joris Exp $	*/
a35 1
#include "diff.h"
d38 1
@


1.2
log
@add -r flag and sync usage;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsclean.c,v 1.1 2005/10/06 02:00:05 joris Exp $	*/
d43 2
d56 1
a56 1
	while ((ch = getopt(argc, argv, "qr:V")) != -1) {
d58 12
d127 1
d130 4
d140 3
d179 2
a180 1
		(void)unlink(fname);
@


1.1
log
@rcsclean now works;
@
text
@d1 1
a1 1
/*	$OpenBSD: rcsdiff.c,v 1.1 2005/10/06 01:24:25 joris Exp $	*/
d54 1
a54 1
	while ((ch = getopt(argc, argv, "qV")) != -1) {
d59 6
d101 1
a101 1
	fprintf(stderr, "usage %s [file] ...\n", __progname);
@

