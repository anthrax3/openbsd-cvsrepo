head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.4
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.12.0.8
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.12
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.14
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.10
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.12
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.8
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.16
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.14
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.2.0.6
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.05.03.09.51.39;	author mestre;	state Exp;
branches;
next	1.12;
commitid	CaQOrlCeSyj26bDl;

1.12
date	2015.10.15.19.30.03;	author bluhm;	state Exp;
branches;
next	1.11;
commitid	N9azH12yVdaSCNnZ;

1.11
date	2015.10.15.17.23.09;	author bluhm;	state Exp;
branches;
next	1.10;
commitid	f1F8LPQG0McRVMmE;

1.10
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	Uu5nFG3wCl0LACBb;

1.9
date	2013.11.27.00.13.22;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.15.10.18.42;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.29.10.59.13;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.13.17.27.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.13.02.02.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.17.06.52;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.04.22.36.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.01.22.20.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.01.21.22.16;	author millert;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Use the safe idiom of cleaning sensitive data from memory with explicit_bzero,
instead of relying on other methods, after readpassphrase. Some programs on
this diff won't benefit that much since it happens near the terminal path, but
someone might copy the unsafe idiom to another program and place it where it
may leak sensitive data.

Discussed aeons ago with tb@@, OK deraadt@@ and beck@@
@
text
@/*	$OpenBSD: x99token.c,v 1.12 2015/10/15 19:30:03 bluhm Exp $	*/

/*
 * X9.9 calculator
 * This software is provided AS IS with no express or implied warranty
 * October 1995, Paul Borman <prb@@krystal.com>
 *
 * Donated to the Public Domain by Paul Borman
 */

#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <openssl/des.h>

#define	KEYFILE		".keyfile.des"
#define	HEXDIGITS	"0123456789abcdef"
#define	DECDIGITS	"0123456789012345"

void predict(DES_key_schedule, const char *, int);

char *digits = HEXDIGITS;
extern char *__progname;

int
main(int argc, char **argv)
{
	int i;
	char buf[256];
	DES_key_schedule ks;
	DES_cblock key;
	char _keyfile[PATH_MAX];
	char *keyfile = 0;
	FILE *fp;
	int init = 0;
	int hex = 1;
	int cnt = 1;
	unsigned int pin;
	struct passwd *pwd;

	if (pledge("stdio rpath wpath cpath getpw tty", NULL) == -1)
		err(1, "pledge");

	while ((i = getopt(argc, argv, "dk:in:")) != -1) {
		switch (i) {
		case 'k':
			keyfile = optarg;
			break;
		case 'i':
			init = 1;
			break;
		case 'd':
			hex = 0;
			break;
		case 'n':
			cnt = atoi(optarg);
			if (cnt <= 0)
				err(1, "invalid count: %s", optarg);
			break;
		default:
			fprintf(stderr,
			    "usage: %s [-d] [-k keyfile] [-n count]\n"
			    "       %s -i [-k keyfile]\n",
			    __progname, __progname);
			exit(1);
		}
	}

	if (!keyfile) {
		if ((pwd = getpwuid(getuid())) == NULL) {
			fprintf(stderr, "Say, just who are you, anyhow?\n");
			exit(1);
		}
		snprintf(_keyfile, sizeof(_keyfile), "%s/%s", pwd->pw_dir,
		    KEYFILE);
		keyfile = _keyfile;
	}

	if (init)
		readpassphrase("Enter Key: ", buf, sizeof(buf), 0);
	else if ((fp = fopen(keyfile, "r")) == NULL)
		err(1, "unable to open %s", keyfile);
	else {
		if (fgets(buf, sizeof(buf), fp) == NULL) {
			fprintf(stderr, "No key in %s\n", keyfile);
			exit(1);
		}
		fclose(fp);
	}

	memset(key, 0, sizeof(key));
	if (init && buf[3] == ' ') {
		char *b = buf;
		/* Assume octal input */
		for (i = 0; i < 8; ++i) {
			if (!*b)
				fprintf(stderr, "%s: invalid key\n", buf);
			while (isdigit((unsigned char)*b))
				key[i] = key[i] << 3 | (*b++ - '0');
			while (*b && !isdigit((unsigned char)*b))
				++b;
		}
	} else {
		for (i = 0; i < 16; ++i) {
			int d;

			if (islower((unsigned char)buf[i]))
				buf[i] = toupper((unsigned char)buf[i]);
			if (buf[i] >= '0' && buf[i] <= '9')
				d = buf[i] - '0';
			else if (buf[i] >= 'A' && buf[i] <= 'F')
				d = buf[i] - 'A' + 10;
			else {
				fprintf(stderr, "invalid key: %s\n", buf);
				exit(1);
			}
			key[i>>1] |= d << ((i & 1) ? 0 : 4);
		}
	}

	/* XXX - should warn on non-space or non-digit */
	readpassphrase("Enter Pin: ", buf, sizeof(buf), 0);
	for (i = 0, pin = 0; buf[i] && buf[i] != '\n'; ++i)
		if (isdigit((unsigned char)buf[i]))
			pin = pin * 16 + buf[i] - '0' + 1;

	if ((pin & 0xffff0000) == 0)
		pin |= pin << 16;

	for (i = 0; i < 8; ++i)
		key[0] ^= (pin >> ((i * 7) % 26)) & 0x7f;

	if (init) {
		umask(S_IRWXG | S_IRWXO);
		unlink(keyfile);
		if ((fp = fopen(keyfile, "w")) == NULL)
			err(1, "could not open %s for writing", keyfile);
		for (i = 0; i < 8; ++i) {
			fprintf(fp, "%c", digits[(key[i]>>4)&0xf]);
			fprintf(fp, "%c", digits[(key[i]>>0)&0xf]);
		}
		fputc('\n', fp);
		fclose(fp);
		exit(0);
	}

	DES_fixup_key_parity(&key);
	DES_key_sched(&key, &ks);

	buf[0] = '\0';
	readpassphrase("Enter challenge: ", buf, sizeof(buf), RPP_ECHO_ON);
	if (buf[0] == '\0')
		exit(0);

	for (i = 0; i < 8; ++i)
		if (buf[i] == '\n')
			buf[i] = '\0';

	if (!hex)
		digits = DECDIGITS;

	predict(ks, buf, cnt);

	explicit_bzero(&ks, sizeof(ks));
	explicit_bzero(buf, sizeof(buf));

	exit(0);
}

void
predict(DES_key_schedule ks, const char *chal, int cnt)
{
	int i;
	DES_cblock cb;

	memcpy(&cb, chal, sizeof(cb));
	while (cnt-- > 0) {
		printf("%.8s: ", (char *)cb);
		DES_ecb_encrypt(&cb, &cb, &ks, DES_ENCRYPT);
		for (i = 0; i < 4; ++i) {
			printf("%c", digits[(cb[i]>>4) & 0xf]);
			printf("%c", digits[(cb[i]>>0) & 0xf]);
		}
		putchar('\n');
		for (i = 0; i < 8; ++i) {
			if ((cb[i] &= 0xf) > 9)
				cb[i] -= 10;
			cb[i] |= 0x30;
		}
	}
	memset(&cb, 0, sizeof(cb));
}
@


1.12
log
@Avoid a race between fopen(3) and fchmod(2).  Use umask(2) and
unlink(2) and fopen(3) to prevent an attacker to open an old file
with wrong permissions before the secret is written into it.  This
also guarantees that a new file with correct permissions is created.
Without fchmod(2) "fattr" can be removed from pledge.
with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.11 2015/10/15 17:23:09 bluhm Exp $	*/
d172 2
a173 2
	memset(&ks, 0, sizeof(ks));
	memset(buf, 0, sizeof(buf));
@


1.11
log
@Plegde x99token with "stdio rpath wpath cpath fattr getpw tty".
with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.10 2015/01/16 06:40:14 deraadt Exp $	*/
d49 1
a49 1
	if (pledge("stdio rpath wpath cpath fattr getpw tty", NULL) == -1)
d142 2
a145 1
		fchmod(fileno(fp), 0600);
@


1.10
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.9 2013/11/27 00:13:22 deraadt Exp $	*/
d48 3
@


1.9
log
@unsigned char for ctype
ok okan
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.8 2010/10/15 10:18:42 jsg Exp $	*/
d10 1
a10 1
#include <sys/param.h>
d21 1
d40 1
a40 1
	char _keyfile[MAXPATHLEN];
@


1.8
log
@Switch the remaining users of libdes in src to libcrypto,
telnet portion partially from the latest heimdal.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.7 2007/03/29 10:59:13 jmc Exp $	*/
d102 1
a102 1
			while (isdigit(*b))
d104 1
a104 1
			while (*b && !isdigit(*b))
d111 2
a112 2
			if (islower(buf[i]))
				buf[i] = toupper(buf[i]);
d128 1
a128 1
		if (isdigit(buf[i]))
@


1.7
log
@tidy up SYNOPSIS and usage(); from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: x99token.c,v 1.6 2003/06/13 17:27:41 millert Exp $	*/
d21 1
a21 1
#include <des.h>
d27 1
a27 1
void predict(des_key_schedule, const char *, int);
d37 2
a38 2
	des_key_schedule ks;
	des_cblock key;
d150 2
a151 2
	des_fixup_key_parity(&key);
	des_key_sched(&key, ks);
d174 1
a174 1
predict(des_key_schedule ks, const char *chal, int cnt)
d177 1
a177 1
	des_cblock cb;
d182 1
a182 1
		des_ecb_encrypt(&cb, &cb, ks, DES_ENCRYPT);
@


1.6
log
@add cvs tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 4
a68 3
			fprintf(stderr, "usage: %s [-n cnt] [-h] [-k keyfile]\n"
			    "       %s -i [-k keyfile]\n", __progname,
			    __progname);
@


1.5
log
@Like the man page, this file is in the public domain; confirmed with
the author.
@
text
@d1 2
@


1.4
log
@predict() was broken for n > 1 in rev 1.2; this fixes it and closes PR 3306
@
text
@d5 2
@


1.3
log
@spelling
@
text
@d23 1
a23 1
void predict(des_key_schedule, char *, int);
d95 1
a95 1
			if (!*b) {
a96 1
			}
d98 1
a98 1
				key[i] = key[i] << 3 | *b++ - '0';
d169 1
a169 1
predict(des_key_schedule ks, char *chal, int cnt)
d174 1
d176 2
a177 2
		printf("%.8s: ", chal);
		des_ecb_encrypt((des_cblock *)chal, &cb, ks, DES_ENCRYPT);
@


1.2
log
@Cleanup and remove DOS #ifdefs
@
text
@d150 1
a150 1
	readpassphrase("Enter challange: ", buf, sizeof(buf), RPP_ECHO_ON);
@


1.1
log
@x99token, a software x99 token calculator from Paul Borman that can
be used with login_token and friends.
@
text
@d6 5
a10 7
#if	defined(KRBDES) && !defined(__unix__)
#define	__unix__
#endif
#ifdef	__unix__
#ifdef	LITTLE_ENDIAN
#undef	LITTLE_ENDIAN
#endif
d12 1
a12 4
#else
#include <dos.h>
#endif
#include <ctype.h>
d17 1
a17 11
#include <sys/stat.h>
extern char *optarg;


#ifdef	__unix__
#define	KEYFILE	".keyfile.des"
#define	MPL	1024
#else
#define	KEYFILE	"keyfile.des"
#define	MPL	256
#endif
d19 1
d23 2
d26 1
a26 23

#ifdef	KRBDES
#include <des.h>
#define setkey	dessetkey

void desinit(int i) { ; }
void dessetkey(char ks[16][8], char key[8])
{
	des_key_schedule *k = (des_key_schedule *)ks;
	des_fixup_key_parity((des_cblock *)key);
	des_key_sched((des_cblock *)key, *k);
}
void endes(char ks[16][8], char key[8])
{
	des_cblock cb;
	des_key_schedule *k = (des_key_schedule *)ks;

	des_ecb_encrypt((des_cblock *)key, &cb, *k, DES_ENCRYPT);
	memcpy(key, &cb, 8);
}
#endif

void predict(char ks[16][8], char *chal, int cnt);
d29 1
a29 1
main(int ac, char **av)
a31 1
	char ks[16][8];
d33 3
a35 2
	char key[8];
	char _keyfile[MPL];
d41 1
a41 2
	unsigned long pin;
#ifdef	__unix__
a42 1
#endif
d44 1
a44 1
	while ((i = getopt(ac, av, "dk:in:")) != EOF)
d57 2
a58 4
			if (cnt <= 0) {
				fprintf(stderr, "%s: invalid count\n", optarg);
				exit(1);
			}
d61 3
a63 2
			fprintf(stderr, "Usage: x99token [-n cnt] [-h] [-k keyfile]\n"
					"       x99token -i [-k keyfile]\n");
d66 1
a66 2

	desinit(0);
d69 1
a69 2
#ifdef	__unix__
		if ((pwd = getpwuid(getuid())) == 0) {
d73 2
a74 1
		sprintf(_keyfile, "%s/%s", pwd->pw_dir, KEYFILE);
a75 3
#else
		keyfile = KEYFILE;
#endif
d78 5
a82 12
	if (init) {
#ifdef	__unix__
		strcpy(buf, (char *)getpass("Enter Key: "));
#else
		printf("Enter key: ");
		if (fgets(buf, sizeof(buf), stdin) == NULL)
			exit(0);
#endif
	} else if ((fp = fopen(keyfile, "r")) == NULL) {
		fprintf(stderr, "Failed to open %s\n", keyfile);
		exit(1);
	} else {
d103 1
a103 1
	} else
d119 1
d121 3
a123 9
#ifdef	__unix__
	strcpy(buf, (char *)getpass("Enter Pin: "));
#else
	printf("Enter Pin: ");
	if (fgets(buf, sizeof(buf), stdin) == NULL)
		exit(0);
#endif

	for (i = 0; buf[i] && buf[i] != '\n'; ++i)
d127 1
a127 1
	if ((pin & 0xffff0000L) == 0)
d134 3
a136 5
		if ((fp = fopen(keyfile, "w")) == NULL) {
			fprintf(stderr, "could not open %s for writing\n",
				keyfile);
			exit(1);
		}
d141 1
a141 1
		fprintf(fp, "\n");
a142 5
#ifdef	__unix__
		chmod(keyfile, 0600);
#else
		dos_setfileattr(keyfile, FA_HIDDEN | FA_SYSTEM);
#endif
d146 2
a147 1
	setkey(ks, key);
d149 3
a151 3
	printf("Enter challange: ");
	memset(buf, 0, sizeof(buf));
	if (fgets(buf, sizeof(buf), stdin) == NULL)
d163 3
d170 1
a170 1
predict(char ks[16][8], char *chal, int cnt)
d173 1
d177 1
a177 1
		endes(ks, chal);
d179 2
a180 2
			printf("%c", digits[(chal[i]>>4) & 0xf]);
			printf("%c", digits[(chal[i]>>0) & 0xf]);
d182 1
a182 1
		printf("\n");
d184 3
a186 3
			if ((chal[i] &= 0xf) > 9)
				chal[i] -= 10;
			chal[i] |= 0x30;
d189 1
@

