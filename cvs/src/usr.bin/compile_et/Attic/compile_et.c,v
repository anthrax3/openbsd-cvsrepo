head	1.14;
access;
symbols
	OPENBSD_5_3:1.13.0.30
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.28
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.26
	OPENBSD_5_0:1.13.0.24
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.22
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.20
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.16
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.18
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.14
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.12
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.10
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.8
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.6
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.4
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.10
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2013.06.17.19.17.15;	author robert;	state dead;
branches;
next	1.13;

1.13
date	2005.10.17.07.35.29;	author biorn;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.13.05.05.22;	author jaredy;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.14.16.14.43;	author mho;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.25.21.19.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.24.11.53.11;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.24.11.52.12;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.24.11.48.57;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.22.12.51.47;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.19.12.07.18;	author hin;	state Exp;
branches;
next	1.4;

1.4
date	98.05.13.17.54.20;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.06.17.20.28.56;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.11.13.44.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.11.11.05.06.34;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove asn1_compile and compile_et from usr.bin because they
have found a new home in src/kerberosV/tools
@
text
@/*	$OpenBSD: compile_et.c,v 1.13 2005/10/17 07:35:29 biorn Exp $	*/
/*
 * Copyright (c) 1998-2002 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 *
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 */

#undef ROKEN_RENAME
#include "compile_et.h"

/* RCSID("$KTH: compile_et.c,v 1.17 2005/05/16 08:42:45 lha Exp $"); */

#include <err.h>
#include "error_table.h"

int numerror;
extern FILE *yyin;

extern void yyparse(void);

long base;
int number;
char *prefix;
char *id_str;

char name[128];
char Basename[128];

#ifdef YYDEBUG
extern int yydebug = 1;
#endif

char *filename;
char hfn[128];
char cfn[128];

struct error_code *codes = NULL;

static int
generate_c(void)
{
	int n;
	struct error_code *ec;
	FILE *c_file = fopen(cfn, "w");

	if (c_file == NULL)
		return 1;

	fprintf(c_file, "/* Generated from %s */\n", filename);
	if (id_str) 
		fprintf(c_file, "/* %s */\n", id_str);

	fprintf(c_file, "\n");
	fprintf(c_file, "#include <stddef.h>\n");
	fprintf(c_file, "#include <com_err.h>\n");
	fprintf(c_file, "#include \"%s\"\n", hfn);
	fprintf(c_file, "\n");

	fprintf(c_file, "static const char *%s_error_strings[] = {\n", name);

	for (ec = codes, n = 0; ec; ec = ec->next, n++) {
		while (n < ec->number) {
			fprintf(c_file,
			    "\t/* %03d */ \"Reserved %s error (%d)\",\n",
			    n, name, n);
			n++;
		}
		fprintf(c_file,
		    "\t/* %03d */ \"%s\",\n", ec->number, ec->string);
	}

	fprintf(c_file, "\tNULL\n");
	fprintf(c_file, "};\n");
	fprintf(c_file, "\n");
	fprintf(c_file, "#define num_errors %d\n", number);
	fprintf(c_file, "\n");
	fprintf(c_file, 
	    "void initialize_%s_error_table_r(struct et_list **list)\n", name);
	fprintf(c_file, "{\n");
	fprintf(c_file, 
	    "    initialize_error_table_r(list, %s_error_strings, "
	    "num_errors, ERROR_TABLE_BASE_%s);\n", name, name);
	fprintf(c_file, "}\n");
	fprintf(c_file, "\n");
	fprintf(c_file, "void initialize_%s_error_table(void)\n", name);
	fprintf(c_file, "{\n");
	fprintf(c_file,
	    "    init_error_table(%s_error_strings, ERROR_TABLE_BASE_%s, "
	    "num_errors);\n", name, name);
	fprintf(c_file, "}\n");

	fclose(c_file);
	return 0;
}

static int
generate_h(void)
{
	struct error_code *ec;
	char fn[128], *p;
	FILE *h_file = fopen(hfn, "w");

	if (h_file == NULL)
		return 1;

	snprintf(fn, sizeof(fn), "__%s__", hfn);
	for (p = fn; *p; p++) {
		if(!isalnum((unsigned char)*p))
			*p = '_';
	}

	fprintf(h_file, "/* Generated from %s */\n", filename);
	if (id_str) 
		fprintf(h_file, "/* %s */\n", id_str);

	fprintf(h_file, "\n");
	fprintf(h_file, "#ifndef %s\n", fn);
	fprintf(h_file, "#define %s\n", fn);
	fprintf(h_file, "\n");
	fprintf(h_file, "struct et_list;\n");
	fprintf(h_file, "\n");
	fprintf(h_file, 
	    "void initialize_%s_error_table_r(struct et_list **);\n",
	    name);
	fprintf(h_file, "\n");
	fprintf(h_file, "void initialize_%s_error_table(void);\n", name);
	fprintf(h_file, "#define init_%s_err_tbl initialize_%s_error_table\n", 
	    name, name);
	fprintf(h_file, "\n");
	fprintf(h_file, "typedef enum %s_error_number{\n", name);

	for (ec = codes; ec; ec = ec->next)
		fprintf(h_file, "\t%s = %ld%s\n", ec->name, base + ec->number,
		    (ec->next != NULL) ? "," : "");

	fprintf(h_file, "} %s_error_number;\n", name);
	fprintf(h_file, "\n");
	fprintf(h_file, "#define ERROR_TABLE_BASE_%s %ld\n", name, base);
	fprintf(h_file, "\n");
	fprintf(h_file, "#endif /* %s */\n", fn);

	fclose(h_file);
	return 0;
}

static int
generate(void)
{
	return generate_c() || generate_h();
}

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr, "usage: %s file\n", __progname);
	exit(1);
}

int
main(int argc, char **argv)
{
	char *p;

	if (argc != 2)
		usage();

	filename = argv[1];
	yyin = fopen(filename, "r");
	if (yyin == NULL)
		err(1, "%s", filename);
	
	p = strrchr(filename, '/');
	if (p)
		p++;
	else
		p = filename;

	strlcpy(Basename, p, sizeof(Basename));
	Basename[strcspn(Basename, ".")] = '\0';

	snprintf(hfn, sizeof(hfn), "%s.h", Basename);
	snprintf(cfn, sizeof(cfn), "%s.c", Basename);

	yyparse();
	if (numerror)
		return 1;

	return generate();
}
@


1.13
log
@sync with heimdal 0.7
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.12 2005/05/13 05:05:22 jaredy Exp $	*/
@


1.12
log
@minor fixes
- some strn* to strl*
- allocation failure checks
- fix overflow in getstring()

ok otto, moritz
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.11 2003/07/14 16:14:43 mho Exp $	*/
d3 1
a3 1
 * Copyright (c) 1998, 1999 Kungliga Tekniska Högskolan
d18 1
a18 6
 * 3. All advertising materials mentioning features or use of this software 
 *    must display the following acknowledgement: 
 *      This product includes software developed by Kungliga Tekniska 
 *      Högskolan and its contributors. 
 *
 * 4. Neither the name of the Institute nor the names of its contributors 
d38 1
a38 1
/* RCSID("$KTH: compile_et.c,v 1.12 1999/04/01 09:13:52 joda Exp $"); */
d86 1
a86 1
	fprintf(c_file, "static const char *text[] = {\n");
d102 2
d108 2
a109 2
	    "    initialize_error_table_r(list, text, "
	    "%s_num_errors, ERROR_TABLE_BASE_%s);\n", name, name);
d115 2
a116 2
	    "    init_error_table(text, ERROR_TABLE_BASE_%s, "
	    "%s_num_errors);\n", name, name);
d147 1
a147 1
	fprintf(h_file, "#include <kerberosV/com_err.h>\n");
a157 2
	fprintf(h_file, "\tERROR_TABLE_BASE_%s = %ld,\n", name, base);
	fprintf(h_file, "\t%s_err_base = %ld,\n", name, base);
d160 2
a161 1
		fprintf(h_file, "\t%s = %ld,\n", ec->name, base + ec->number);
a162 1
	fprintf(h_file, "\t%s_num_errors = %d\n", name, number);
d164 2
@


1.11
log
@Enable build of unified libkrb5. ok deraadt, todd. Testing by hin, jakob, David Krause, ...
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.10 2003/06/25 21:19:34 deraadt Exp $	*/
d210 1
a210 2
	strncpy(Basename, p, sizeof(Basename));
	Basename[sizeof(Basename) - 1] = '\0';
@


1.10
log
@add a missing proto
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.9 2000/12/24 11:53:11 aaron Exp $	*/
d150 1
a150 1
	fprintf(h_file, "#include <com_err.h>\n");
@


1.9
log
@Get rid of unused usage() exit code; pointed out by mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.8 2000/12/24 11:52:12 aaron Exp $	*/
d183 1
a183 1
usage()
@


1.8
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.7 2000/12/24 11:48:57 aaron Exp $	*/
d183 1
a183 1
usage(int code)
d197 1
a197 1
		usage(1);
@


1.7
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.6 2000/11/22 12:51:47 aaron Exp $	*/
d83 1
a83 1
		frintf(c_file, "/* %s */\n", id_str);
@


1.6
log
@Sync usage() output with man page; mpech@@prosoft.org.lv
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.5 2000/02/19 12:07:18 hin Exp $	*/
d74 28
a101 24
    int n;
    struct error_code *ec;

    FILE *c_file = fopen(cfn, "w");
    if(c_file == NULL)
	return 1;

    fprintf(c_file, "/* Generated from %s */\n", filename);
    if(id_str) 
	fprintf(c_file, "/* %s */\n", id_str);
    fprintf(c_file, "\n");
    fprintf(c_file, "#include <stddef.h>\n");
    fprintf(c_file, "#include <com_err.h>\n");
    fprintf(c_file, "#include \"%s\"\n", hfn);
    fprintf(c_file, "\n");

    fprintf(c_file, "static const char *text[] = {\n");

    for(ec = codes, n = 0; ec; ec = ec->next, n++) {
	while(n < ec->number) {
	    fprintf(c_file, "\t/* %03d */ \"Reserved %s error (%d)\",\n",
		    n, name, n);
	    n++;
	    
a102 2
	fprintf(c_file, "\t/* %03d */ \"%s\",\n", ec->number, ec->string);
    }
d104 7
a110 8
    fprintf(c_file, "\tNULL\n");
    fprintf(c_file, "};\n");
    fprintf(c_file, "\n");
    fprintf(c_file, 
	    "void initialize_%s_error_table_r(struct et_list **list)\n", 
	    name);
    fprintf(c_file, "{\n");
    fprintf(c_file, 
d113 5
a117 5
    fprintf(c_file, "}\n");
    fprintf(c_file, "\n");
    fprintf(c_file, "void initialize_%s_error_table(void)\n", name);
    fprintf(c_file, "{\n");
    fprintf(c_file,
d120 1
a120 1
    fprintf(c_file, "}\n");
d122 2
a123 2
    fclose(c_file);
    return 0;
d129 24
a152 23
    struct error_code *ec;
    char fn[128];
    FILE *h_file = fopen(hfn, "w");
    char *p;

    if(h_file == NULL)
	return 1;

    snprintf(fn, sizeof(fn), "__%s__", hfn);
    for(p = fn; *p; p++)
	if(!isalnum((unsigned char)*p))
	    *p = '_';
    
    fprintf(h_file, "/* Generated from %s */\n", filename);
    if(id_str) 
	fprintf(h_file, "/* %s */\n", id_str);
    fprintf(h_file, "\n");
    fprintf(h_file, "#ifndef %s\n", fn);
    fprintf(h_file, "#define %s\n", fn);
    fprintf(h_file, "\n");
    fprintf(h_file, "#include <com_err.h>\n");
    fprintf(h_file, "\n");
    fprintf(h_file, 
d155 3
a157 3
    fprintf(h_file, "\n");
    fprintf(h_file, "void initialize_%s_error_table(void);\n", name);
    fprintf(h_file, "#define init_%s_err_tbl initialize_%s_error_table\n", 
d159 12
a170 14
    fprintf(h_file, "\n");
    fprintf(h_file, "typedef enum %s_error_number{\n", name);
    fprintf(h_file, "\tERROR_TABLE_BASE_%s = %ld,\n", name, base);
    fprintf(h_file, "\t%s_err_base = %ld,\n", name, base);

    for(ec = codes; ec; ec = ec->next) {
	fprintf(h_file, "\t%s = %ld,\n", ec->name, base + ec->number);
    }

    fprintf(h_file, "\t%s_num_errors = %d\n", name, number);
    fprintf(h_file, "} %s_error_number;\n", name);
    fprintf(h_file, "\n");
    fprintf(h_file, "#endif /* %s */\n", fn);

d172 2
a173 2
    fclose(h_file);
    return 0;
d179 1
a179 1
    return generate_c() || generate_h();
d185 4
a188 3
    extern char *__progname;
    fprintf(stderr, "usage: %s file\n", __progname);
    exit(1);
d194 1
a194 1
    char *p;
d196 2
a197 2
    if(argc != 2)
	usage(1);
d199 4
a202 4
    filename = argv[1];
    yyin = fopen(filename, "r");
    if(yyin == NULL)
	err(1, "%s", filename);
d204 16
a219 17
    
    p = strrchr(filename, '/');
    if(p)
	p++;
    else
	p = filename;
    strncpy(Basename, p, sizeof(Basename));
    Basename[sizeof(Basename) - 1] = '\0';
    
    Basename[strcspn(Basename, ".")] = '\0';
    
    snprintf(hfn, sizeof(hfn), "%s.h", Basename);
    snprintf(cfn, sizeof(cfn), "%s.c", Basename);
    
    yyparse();
    if(numerror)
	return 1;
d221 1
a221 1
    return generate();
@


1.5
log
@Update to a newer version from KTH-Kerberos.
(most work by art@@)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 1
    fprintf(stderr, "Usage: %s <file>\n", __progname);
@


1.4
log
@generate int errorcodes instead of long to match the new libcom_err
This should solve the problems with having kerberos servers on alphas.
@
text
@d1 1
a1 2
/*	$OpenBSD: compile_et.c,v 1.3 1997/06/17 20:28:56 kstailey Exp $	*/

d3 23
a25 2
 * Copyright 1986, 1987, 1988
 * by MIT Student Information Processing Board.
d27 11
a37 1
 * For copyright info, see "mit-sipb-copyright.h".
d40 12
a51 6
#include <stdio.h>
#include <sys/types.h>
#include <sys/file.h>
#include <string.h>
#include <sys/param.h>
#include "compiler.h"
d53 4
a56 3
#ifndef __STDC__
#define const
#endif
d58 2
a59 3
#ifndef lint
static const char copyright[] =
    "Copyright 1987,1988 by MIT Student Information Processing Board";
d61 2
a62 2
static const char rcsid_compile_et_c[] =
    "$Id: compile_et.c,v 1.3 1997/06/17 20:28:56 kstailey Exp $";
d65 36
a100 10
extern char *gensym();
extern char *current_token;
extern int table_number, current;
char buffer[BUFSIZ];
char *table_name = NULL;
FILE *hfile, *cfile;

/* C library */
extern char *malloc();
extern int errno;
d102 18
a119 3
/* lex stuff */
extern FILE *yyin;
extern unsigned lineno;
d121 2
a122 7
char * xmalloc (size) unsigned int size; {
    char * p = malloc (size);
    if (!p) {
	perror (whoami);
	exit (1);
    }
    return p;
d125 48
a172 4
static int check_arg (str_list, arg) char const *const *str_list, *arg; {
    while (*str_list)
	if (!strcmp(arg, *str_list++))
	    return 1;
d176 4
a179 60
static const char *const debug_args[] = {
    "d",
    "debug",
    0,
};

static const char *const lang_args[] = {
    "lang",
    "language",
    0,
};

static const char *const language_names[] = {
    "C",
    "K&R C",
    "C++",
    0,
};

static const char * const c_src_prolog[] = {
    "static const char * const text[] = {\n",
    0,
};

static const char * const krc_src_prolog[] = {
    "#ifdef __STDC__\n",
    "#define NOARGS void\n",
    "#else\n",
    "#define NOARGS\n",
    "#define const\n",
    "#endif\n\n",
    "static const char * const text[] = {\n",
    0,
};

static const char *const struct_def[] = {
    "struct error_table {\n",
    "    char const * const * msgs;\n",
    "    long base;\n",
    "    int n_msgs;\n",
    "};\n",
    "struct et_list {\n",
    "    struct et_list *next;\n",
    "    const struct error_table * table;\n",
    "};\n",
    "extern struct et_list *_et_list;\n",
    "\n", 0,
};

static const char warning[] =
    "/*\n * %s:\n * This file is automatically generated; please do not edit it.\n */\n";

/* pathnames */
char c_file[MAXPATHLEN];	/* output file */
char h_file[MAXPATHLEN];	/* output */

static void usage () {
    fprintf (stderr, "usage: %s ERROR_TABLE\n",
	     whoami);
    exit (1);
d182 6
a187 4
static void dup_err (type, one, two) char const *type, *one, *two; {
    fprintf (stderr, "%s: multiple %s specified: `%s' and `%s'\n",
	     whoami, type, one, two);
    usage ();
d190 7
a196 67
int main (argc, argv) int argc; char **argv; {
    char *p, *ename;
    int len;
    char const * const *cpp;
    int got_language = 0;

    /* argument parsing */
    debug = 0;
    filename = 0;
    whoami = argv[0];
    p = strrchr (whoami, '/');
    if (p)
	whoami = p+1;
    while (argv++, --argc) {
	char *arg = *argv;
	if (arg[0] != '-') {
	    if (filename)
		dup_err ("filenames", filename, arg);
	    filename = arg;
	}
	else {
	    arg++;
	    if (check_arg (debug_args, arg))
		debug++;
	    else if (check_arg (lang_args, arg)) {
		got_language++;
		arg = *++argv, argc--;
		if (!arg)
		    usage ();
		if (language)
		    dup_err ("languanges", language_names[(int)language], arg);
#define check_lang(x,v) else if (!strcasecmp(arg,x)) language = v
		check_lang ("c", lang_C);
		check_lang ("ansi_c", lang_C);
		check_lang ("ansi-c", lang_C);
		check_lang ("krc", lang_KRC);
		check_lang ("kr_c", lang_KRC);
		check_lang ("kr-c", lang_KRC);
		check_lang ("k&r-c", lang_KRC);
		check_lang ("k&r_c", lang_KRC);
		check_lang ("c++", lang_CPP);
		check_lang ("cplusplus", lang_CPP);
		check_lang ("c-plus-plus", lang_CPP);
#undef check_lang
		else {
		    fprintf (stderr, "%s: unknown language name `%s'\n",
			     whoami, arg);
		    fprintf (stderr, "\tpick one of: C K&R-C\n");
		    exit (1);
		}
	    }
	    else {
		fprintf (stderr, "%s: unknown control argument -`%s'\n",
			 whoami, arg);
		usage ();
	    }
	}
    }
    if (!filename)
	usage ();
    if (!got_language)
	language = lang_KRC;
    else if (language == lang_CPP) {
	fprintf (stderr, "%s: Sorry, C++ support is not yet finished.\n",
		 whoami);
	exit (1);
    }
d198 6
a203 3
    p = xmalloc (strlen (filename) + 5);
    strcpy (p, filename);
    filename = p;
d205 1
a205 3
    if (p == NULL)
	p = filename;
    else
a206 39
    ename = p;
    len = strlen (ename);
    p += len - 3;
    if (strcmp (p, ".et"))
	p += 3;
    *p++ = '.';
    /* now p points to where "et" suffix should start */
    /* generate new filenames */
    strcpy (p, "c");
    strcpy (c_file, ename);
    *p = 'h';
    strcpy (h_file, ename);
    strcpy (p, "et");

    yyin = fopen(filename, "r");
    if (!yyin) {
	perror(filename);
	exit(1);
    }

    hfile = fopen(h_file, "w");
    if (hfile == NULL) {
	perror(h_file);
	exit(1);
    }
    fprintf (hfile, warning, h_file);

    cfile = fopen(c_file, "w");
    if (cfile == NULL) {
	perror(c_file);
	exit(1);
    }
    fprintf (cfile, warning, c_file);

    /* prologue */
    if (language == lang_C)
	cpp = c_src_prolog;
    else if (language == lang_KRC)
	cpp = krc_src_prolog;
d208 9
a216 5
	abort ();
    while (*cpp)
	fputs (*cpp++, cfile);

    /* parse it */
d218 2
a219 31
    fclose(yyin);		/* bye bye input file */

    fputs ("    0\n};\n\n", cfile);
    for (cpp = struct_def; *cpp; cpp++)
	fputs (*cpp, cfile);
    fprintf(cfile,
	    "static const struct error_table et = { text, %d, %d };\n\n",
	    table_number, current);
    fputs("static struct et_list link = { 0, 0 };\n\n",
	  cfile);
    fprintf(cfile, "void initialize_%s_error_table (%s) {\n",
	    table_name, (language == lang_C) ? "void" : "NOARGS");
    fputs("    if (!link.table) {\n", cfile);
    fputs("        link.next = _et_list;\n", cfile);
    fputs("        link.table = &et;\n", cfile);
    fputs("        _et_list = &link;\n", cfile);
    fputs("    }\n", cfile);
    fputs("}\n", cfile);
    fclose(cfile);

    fprintf (hfile, "extern void initialize_%s_error_table ();\n",
	     table_name);
    fprintf (hfile, "#define ERROR_TABLE_BASE_%s (%dL)\n",
	     table_name, table_number);
    /* compatibility... */
    fprintf (hfile, "\n/* for compatibility with older versions... */\n");
    fprintf (hfile, "#define init_%s_err_tbl initialize_%s_error_table\n",
	     table_name, table_name);
    fprintf (hfile, "#define %s_err_base ERROR_TABLE_BASE_%s\n", table_name,
	     table_name);
    fclose(hfile);		/* bye bye include file */
d221 1
a221 9
    return 0;
}

int yyerror(s) char *s; {
    fputs(s, stderr);
    fprintf(stderr, "\nLine number %d; last token was '%s'\n",
	    lineno, current_token);

    return 0;
@


1.3
log
@minor cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.2 1996/12/11 13:44:56 deraadt Exp $	*/
d26 1
a26 1
    "$Id: compile_et.c,v 1.2 1996/12/11 13:44:56 deraadt Exp $";
d256 1
a256 1
	    "static const struct error_table et = { text, %dL, %d };\n\n",
@


1.2
log
@fix usage line
@
text
@d1 1
a1 1
/*	$OpenBSD: compile_et.c,v 1.1 1996/11/11 05:06:34 downsj Exp $	*/
d26 1
a26 1
    "$Id: compile_et.c,v 1.1 1996/11/11 05:06:34 downsj Exp $";
d33 1
a33 1
char *table_name = (char *)NULL;
d200 1
a200 1
    if (p == (char *)NULL)
d225 1
a225 1
    if (hfile == (FILE *)NULL) {
d232 1
a232 1
    if (cfile == (FILE *)NULL) {
d256 1
a256 1
	    "static const struct error_table et = { text, %ldL, %d };\n\n",
d272 1
a272 1
    fprintf (hfile, "#define ERROR_TABLE_BASE_%s (%ldL)\n",
d289 2
@


1.1
log
@compile_et now resides in /usr/libexec.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d26 1
a26 1
    "$Id: compile_et.c,v 1.1.1.1 1995/12/14 06:52:49 tholo Exp $";
d117 2
a118 2
    fprintf (stderr, "%s: usage: %s ERROR_TABLE\n",
	     whoami, whoami);
@
