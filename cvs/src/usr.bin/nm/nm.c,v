head	1.51;
access;
symbols
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.33.0.12
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.10
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.8
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.10
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.8
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.6
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2015.12.09.19.28.34;	author mmcc;	state Exp;
branches;
next	1.50;
commitid	33ajac6ZyR1t2xod;

1.50
date	2015.11.13.15.22.44;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	6ygNipdTxqEnPqTV;

1.49
date	2015.10.09.01.37.08;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	sbrB3Q5CNxcwZpfU;

1.48
date	2015.10.05.07.16.03;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	8VV4fFPFrFARGNeJ;

1.47
date	2015.08.13.19.13.28;	author miod;	state Exp;
branches;
next	1.46;
commitid	QZhVyD7WxxvCXibW;

1.46
date	2015.05.17.21.41.50;	author guenther;	state Exp;
branches;
next	1.45;
commitid	jGfTFBHfz7ha7Qty;

1.45
date	2015.05.17.20.19.08;	author guenther;	state Exp;
branches;
next	1.44;
commitid	CuoIx9MPLElIHvnd;

1.44
date	2015.04.09.04.46.18;	author guenther;	state Exp;
branches;
next	1.43;
commitid	D8uy8dZNh36bsfBL;

1.43
date	2015.04.08.04.23.15;	author guenther;	state Exp;
branches;
next	1.42;
commitid	W57ifSOPnrmZFJ9F;

1.42
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Uu5nFG3wCl0LACBb;

1.41
date	2014.04.28.18.49.28;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.12.19.37.39;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.12.14.07.53;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.24.19.53.43;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.24.18.28.03;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.21.02.59.52;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.19.08.59.48;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2011.02.06.18.34.00;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.27.23.51.21;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.03.14.49.39;	author espie;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.10.16.45.00;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.09.20.26.57;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.11.07.08.46;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.04.23.09.07;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.29.13.34.37;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.14.04.23.26;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.14.02.52.04;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.13.17.32.32;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.05.01.27.22;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.10.22.20.49;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.03.02.56.14;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.05.17.15.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.17.16.29.33;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.14.25.26;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.16.15.45.05;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.31.16.28.51;	author smart;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.18.21.45.09;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.10.15.33.12;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	99.05.10.16.14.07;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	98.05.11.20.34.58;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.05.31.08.26.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.04.18.27.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.42.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.16.00.57.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: nm.c,v 1.50 2015/11/13 15:22:44 deraadt Exp $	*/
/*	$NetBSD: nm.c,v 1.7 1996/01/14 23:04:03 pk Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Hans Huebner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <a.out.h>
#include <elf_abi.h>
#include <ar.h>
#include <ranlib.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <link.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include "util.h"
#include "elfuncs.h"

#define	SYMTABMAG	"/ "
#define	STRTABMAG	"//"
#define	SYM64MAG	"/SYM64/         "

union hdr {
	Elf32_Ehdr elf32;
	Elf64_Ehdr elf64;
};

int armap;
int demangle;
int non_object_warning;
int print_only_external_symbols;
int print_only_undefined_symbols;
int print_all_symbols;
int print_file_each_line;
int show_extensions;
int issize;
char posix_fmtstr[6];
int posix_output;
char posix_radix = 'x';
int usemmap = 1;
int dynamic_only;

/* size vars */
unsigned long total_text, total_data, total_bss, total_total;
int non_object_warning, print_totals;

int rev;
int fname(const void *, const void *);
int rname(const void *, const void *);
int value(const void *, const void *);
char *otherstring(struct xnlist *);
int (*sfunc)(const void *, const void *) = fname;
char typeletter(struct xnlist *);
int mmbr_name(struct ar_hdr *, char **, int, int *, FILE *);
int show_symtab(off_t, u_long, const char *, FILE *);
int show_symdef(off_t, u_long, const char *, FILE *);

/* some macros for symbol type (nlist.n_type) handling */
#define	IS_EXTERNAL(x)		((x) & N_EXT)
#define	SYMBOL_TYPE(x)		((x) & (N_TYPE | N_STAB))

void	 pipe2cppfilt(void);
void	 usage(void);
char	*symname(struct xnlist *);
int	process_file(int, const char *);
int	show_archive(int, const char *, FILE *);
int	show_file(int, int, const char *, FILE *fp, off_t, union hdr *);
void	print_symbol(const char *, struct xnlist *);

#define	OPTSTRING_NM	"aABCDegnopPrst:uvw"
const struct option longopts_nm[] = {
	{ "debug-syms",		no_argument,		0,	'a' },
	{ "demangle",		no_argument,		0,	'C' },
	{ "dynamic",		no_argument,		0,	'D' },
	{ "extern-only",	no_argument,		0,	'g' },
/*	{ "line-numbers",	no_argument,		0,	'l' }, */
	{ "no-sort",		no_argument,		0,	'p' },
	{ "numeric-sort",	no_argument,		0,	'n' },
	{ "print-armap",	no_argument,		0,	's' },
	{ "print-file-name",	no_argument,		0,	'o' },
	{ "reverse-sort",	no_argument,		0,	'r' },
/*	{ "size-sort",		no_argument,		&szval,	1 }, */
	{ "undefined-only",	no_argument,		0,	'u' },
	{ "help",		no_argument,		0,	'?' },
	{ NULL }
};

/*
 * main()
 *	parse command line, execute process_file() for each file
 *	specified on the command line.
 */
int
main(int argc, char *argv[])
{
	extern char *__progname;
	extern int optind;
	const char *optstr;
	const struct option *lopts;
	int ch, eval;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	optstr = OPTSTRING_NM;
	lopts = longopts_nm;
	if (!strcmp(__progname, "size")) {
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");

		issize = 1;
		optstr = "tw";
		lopts = NULL;
	}

	while ((ch = getopt_long(argc, argv, optstr, lopts, NULL)) != -1) {
		switch (ch) {
		case 'a':
			print_all_symbols = 1;
			break;
		case 'B':
			/* no-op, compat with gnu-nm */
			break;
		case 'C':
			demangle = 1;
			break;
		case 'D':
			dynamic_only = 1;
			break;
		case 'e':
			show_extensions = 1;
			break;
		case 'g':
			print_only_external_symbols = 1;
			break;
		case 'n':
		case 'v':
			sfunc = value;
			break;
		case 'A':
		case 'o':
			print_file_each_line = 1;
			break;
		case 'p':
			sfunc = NULL;
			break;
		case 'P':
			posix_output = 1;
			break;
		case 'r':
			rev = 1;
			break;
		case 's':
			armap = 1;
			break;
		case 'u':
			print_only_undefined_symbols = 1;
			break;
		case 'w':
			non_object_warning = 1;
			break;
		case 't':
			if (issize) {
				print_totals = 1;
			} else {
				posix_radix = *optarg;
				if (strlen(optarg) != 1 ||
				    (posix_radix != 'd' && posix_radix != 'o' &&
				     posix_radix != 'x'))
					usage();
			}
			break;
		case '?':
		default:
			usage();
		}
	}

	if (posix_output)
		(void)snprintf(posix_fmtstr, sizeof posix_fmtstr, "%%%c %%%c",
		    posix_radix, posix_radix);
	if (demangle)
		pipe2cppfilt();

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	argv += optind;
	argc -= optind;

	if (rev && sfunc == fname)
		sfunc = rname;

	eval = 0;
	if (*argv)
		do {
			eval |= process_file(argc, *argv);
		} while (*++argv);
	else
		eval |= process_file(1, "a.out");

	if (issize && print_totals)
		printf("\n%lu\t%lu\t%lu\t%lu\t%lx\tTOTAL\n",
		    total_text, total_data, total_bss,
		    total_total, total_total);
	exit(eval);
}

/*
 * process_file()
 *	show symbols in the file given as an argument.  Accepts archive and
 *	object files as input.
 */
int
process_file(int count, const char *fname)
{
	union hdr exec_head;
	FILE *fp;
	int retval;
	size_t bytes;
	char magic[SARMAG];

	if (!(fp = fopen(fname, "r"))) {
		warn("cannot read %s", fname);
		return(1);
	}

	if (!issize && count > 1)
		(void)printf("\n%s:\n", fname);

	/*
	 * first check whether this is an object file - read a object
	 * header, and skip back to the beginning
	 */
	bzero(&exec_head, sizeof(exec_head));
	bytes = fread((char *)&exec_head, 1, sizeof(exec_head), fp);
	if (bytes < sizeof(exec_head)) {
		if (bytes < sizeof(exec_head.elf32) || IS_ELF(exec_head.elf32)) {
			warnx("%s: bad format", fname);
			(void)fclose(fp);
			return(1);
		}
	}
	rewind(fp);

	/* this could be an archive */
	if (!IS_ELF(exec_head.elf32)) {
		if (fread(magic, sizeof(magic), (size_t)1, fp) != 1 ||
		    strncmp(magic, ARMAG, SARMAG)) {
			warnx("%s: not object file or archive", fname);
			(void)fclose(fp);
			return(1);
		}
		retval = show_archive(count, fname, fp);
	} else
		retval = show_file(count, 1, fname, fp, 0, &exec_head);
	(void)fclose(fp);
	return(retval);
}

char *nametab;

/*
 *
 *	given the archive member header -- produce member name
 */
int
mmbr_name(struct ar_hdr *arh, char **name, int baselen, int *namelen, FILE *fp)
{
	char *p = *name + strlen(*name);
	long i;

	if (nametab && arh->ar_name[0] == '/') {
		int len;

		i = atol(&arh->ar_name[1]);
		len = strlen(&nametab[i]);
		if (len > *namelen) {
			p -= (long)*name;
			if ((*name = realloc(*name, baselen+len)) == NULL)
				err(1, NULL);
			*namelen = len;
			p += (long)*name;
		}
		strlcpy(p, &nametab[i], len);
		p += len;
	} else
#ifdef AR_EFMT1
	/*
	 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
	 * first <namelen> bytes of the file
	 */
	if ((arh->ar_name[0] == '#') &&
	    (arh->ar_name[1] == '1') &&
	    (arh->ar_name[2] == '/') &&
	    (isdigit((unsigned char)arh->ar_name[3]))) {
		int len = atoi(&arh->ar_name[3]);

		if (len > *namelen) {
			p -= (long)*name;
			if ((*name = realloc(*name, baselen+len)) == NULL)
				err(1, NULL);
			*namelen = len;
			p += (long)*name;
		}
		if (fread(p, len, 1, fp) != 1) {
			warnx("%s: premature EOF", *name);
			free(*name);
			return(1);
		}
		p += len;
	} else
#endif
	for (i = 0; i < sizeof(arh->ar_name); ++i)
		if (arh->ar_name[i] && arh->ar_name[i] != ' ')
			*p++ = arh->ar_name[i];
	*p = '\0';
	if (p[-1] == '/')
		*--p = '\0';

	return (0);
}

/*
 * show_symtab()
 *	show archive ranlib index (fs5)
 */
int
show_symtab(off_t off, u_long len, const char *name, FILE *fp)
{
	struct ar_hdr ar_head;
	int *symtab, *ps;
	char *strtab, *p;
	int num, rval = 0;
	int namelen;
	off_t restore;

	restore = ftello(fp);

	MMAP(symtab, len, PROT_READ, MAP_PRIVATE|MAP_FILE, fileno(fp), off);
	if (symtab == MAP_FAILED)
		return (1);

	namelen = sizeof(ar_head.ar_name);
	if ((p = malloc(sizeof(ar_head.ar_name))) == NULL) {
		warn("%s: malloc", name);
		MUNMAP(symtab, len);
	}

	printf("\nArchive index:\n");
	num = betoh32(*symtab);
	strtab = (char *)(symtab + num + 1);
	for (ps = symtab + 1; num--; ps++, strtab += strlen(strtab) + 1) {
		if (fseeko(fp, betoh32(*ps), SEEK_SET)) {
			warn("%s: fseeko", name);
			rval = 1;
			break;
		}

		if (fread(&ar_head, sizeof(ar_head), 1, fp) != 1 ||
		    memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: member fseeko", name);
			rval = 1;
			break;
		}

		*p = '\0';
		if (mmbr_name(&ar_head, &p, 0, &namelen, fp)) {
			rval = 1;
			break;
		}

		printf("%s in %s\n", strtab, p);
	}

	fseeko(fp, restore, SEEK_SET);

	free(p);
	MUNMAP(symtab, len);
	return (rval);
}

/*
 * show_symdef()
 *	show archive ranlib index (gob)
 */
int
show_symdef(off_t off, u_long len, const char *name, FILE *fp)
{
	struct ranlib *prn, *eprn;
	struct ar_hdr ar_head;
	char *symdef;
	char *strtab, *p;
	u_long size;
	int namelen, rval = 0;

	MMAP(symdef, len, PROT_READ, MAP_PRIVATE|MAP_FILE, fileno(fp), off);
	if (symdef == MAP_FAILED)
		return (1);
	if (usemmap)
		(void)madvise(symdef, len, MADV_SEQUENTIAL);

	namelen = sizeof(ar_head.ar_name);
	if ((p = malloc(sizeof(ar_head.ar_name))) == NULL) {
		warn("%s: malloc", name);
		MUNMAP(symdef, len);
		return (1);
	}

	size = *(u_long *)symdef;
	prn = (struct ranlib *)(symdef + sizeof(u_long));
	eprn = prn + size / sizeof(*prn);
	strtab = symdef + sizeof(u_long) + size + sizeof(u_long);

	printf("\nArchive index:\n");
	for (; prn < eprn; prn++) {
		if (fseeko(fp, prn->ran_off, SEEK_SET)) {
			warn("%s: fseeko", name);
			rval = 1;
			break;
		}

		if (fread(&ar_head, sizeof(ar_head), 1, fp) != 1 ||
		    memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: member fseeko", name);
			rval = 1;
			break;
		}

		*p = '\0';
		if (mmbr_name(&ar_head, &p, 0, &namelen, fp)) {
			rval = 1;
			break;
		}

		printf("%s in %s\n", strtab + prn->ran_un.ran_strx, p);
	}

	free(p);
	MUNMAP(symdef, len);
	return (rval);
}

/*
 * show_archive()
 *	show symbols in the given archive file
 */
int
show_archive(int count, const char *fname, FILE *fp)
{
	struct ar_hdr ar_head;
	union hdr exec_head;
	int i, rval;
	off_t last_ar_off, foff, symtaboff;
	char *name;
	int baselen, namelen;
	u_long mmbrlen, symtablen;

	baselen = strlen(fname) + 3;
	if (posix_output)
		baselen += 2;
	namelen = sizeof(ar_head.ar_name);
	if ((name = malloc(baselen + namelen)) == NULL)
		err(1, NULL);

	rval = 0;
	nametab = NULL;
	symtaboff = 0;
	symtablen = 0;

	/* while there are more entries in the archive */
	while (fread(&ar_head, sizeof(ar_head), 1, fp) == 1) {
		/* bad archive entry - stop processing this archive */
		if (memcmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
			warnx("%s: bad format archive header", fname);
			rval = 1;
			break;
		}

		/* remember start position of current archive object */
		last_ar_off = ftello(fp);
		mmbrlen = atol(ar_head.ar_size);

		if (strncmp(ar_head.ar_name, RANLIBMAG,
		    sizeof(RANLIBMAG) - 1) == 0) {
			if (!issize && armap &&
			    show_symdef(last_ar_off, mmbrlen, fname, fp)) {
				rval = 1;
				break;
			}
			goto skip;
		} else if (strncmp(ar_head.ar_name, SYMTABMAG,
		    sizeof(SYMTABMAG) - 1) == 0) {
			/* if nametab hasn't been seen yet -- doit later */
			if (!nametab) {
				symtablen = mmbrlen;
				symtaboff = last_ar_off;
				goto skip;
			}

			/* load the Sys5 long names table */
		} else if (strncmp(ar_head.ar_name, STRTABMAG,
		    sizeof(STRTABMAG) - 1) == 0) {
			char *p;

			if ((nametab = malloc(mmbrlen)) == NULL) {
				warn("%s: nametab", fname);
				rval = 1;
				break;
			}

			if (fread(nametab, mmbrlen, (size_t)1, fp) != 1) {
				warnx("%s: premature EOF", fname);
				rval = 1;
				break;
			}

			for (p = nametab, i = mmbrlen; i--; p++)
				if (*p == '\n')
					*p = '\0';

			if (issize || !armap || !symtablen || !symtaboff)
				goto skip;
		}
#ifdef __mips64
		else if (memcmp(ar_head.ar_name, SYM64MAG,
		    sizeof(ar_head.ar_name)) == 0) {
			/* IRIX6-compatible archive map */
			goto skip;
		}
#endif

		if (!issize && armap && symtablen && symtaboff) {
			if (show_symtab(symtaboff, symtablen, fname, fp)) {
				rval = 1;
				break;
			} else {
				symtaboff = 0;
				symtablen = 0;
			}
		}

		/*
		 * construct a name of the form "archive.a:obj.o:" for the
		 * current archive entry if the object name is to be printed
		 * on each output line
		 */
		*name = '\0';
		if (posix_output)
			snprintf(name, baselen - 1, "%s[", fname);
		else if (count > 1)
			snprintf(name, baselen - 1, "%s:", fname);

		if (mmbr_name(&ar_head, &name, baselen, &namelen, fp)) {
			rval = 1;
			break;
		}

		if (posix_output)
			strlcat(name, "]", baselen + namelen);

		foff = ftello(fp);

		/* get and check current object's header */
		if (fread((char *)&exec_head, sizeof(exec_head),
		    (size_t)1, fp) != 1) {
			warnx("%s: premature EOF", fname);
			rval = 1;
			break;
		}

		rval |= show_file(2, non_object_warning, name, fp, foff, &exec_head);
		/*
		 * skip to next archive object - it starts at the next
		 * even byte boundary
		 */
#define even(x) (((x) + 1) & ~1)
skip:		if (fseeko(fp, last_ar_off + even(mmbrlen), SEEK_SET)) {
			warn("%s", fname);
			rval = 1;
			break;
		}
	}
	free(nametab);
	nametab = NULL;
	free(name);
	return(rval);
}

char *stab;

/*
 * show_file()
 *	show symbols from the object file pointed to by fp.  The current
 *	file pointer for fp is expected to be at the beginning of an object
 *	file header.
 */
int
show_file(int count, int warn_fmt, const char *name, FILE *fp, off_t foff, union hdr *head)
{
	u_long text, data, bss, total;
	struct xnlist *np, *names, **snames;
	int i, nrawnames, nnames;
	size_t stabsize;

	if (IS_ELF(head->elf32) &&
	    head->elf32.e_ident[EI_CLASS] == ELFCLASS32 &&
	    head->elf32.e_ident[EI_VERSION] == ELF_TARG_VER) {
		void *shdr;

		if (!(shdr = elf32_load_shdrs(name, fp, foff, &head->elf32)))
			return (1);

		i = issize?
		    elf32_size(&head->elf32, shdr, &text, &data, &bss) :
		    elf32_symload(name, fp, foff, &head->elf32, shdr,
			&names, &snames, &stabsize, &nrawnames);
		free(shdr);
		if (i)
			return (i);

	} else if (IS_ELF(head->elf64) &&
	    head->elf64.e_ident[EI_CLASS] == ELFCLASS64 &&
	    head->elf64.e_ident[EI_VERSION] == ELF_TARG_VER) {
		void *shdr;

		if (!(shdr = elf64_load_shdrs(name, fp, foff, &head->elf64)))
			return (1);

		i = issize?
		    elf64_size(&head->elf64, shdr, &text, &data, &bss) :
		    elf64_symload(name, fp, foff, &head->elf64, shdr,
			&names, &snames, &stabsize, &nrawnames);
		free(shdr);
		if (i)
			return (i);
	} else {
		if (warn_fmt)
			warnx("%s: bad format", name);
		return (1);
	}

	if (issize) {
		static int first = 1;

		if (first) {
			first = 0;
			printf("text\tdata\tbss\tdec\thex\n");
		}

		total = text + data + bss;
		printf("%lu\t%lu\t%lu\t%lu\t%lx",
		    text, data, bss, total, total);
		if (count > 1)
			(void)printf("\t%s", name);

		total_text += text;
		total_data += data;
		total_bss += bss;
		total_total += total;

		printf("\n");
		return (0);
	}
	/* else we are nm */

	/*
	 * it seems that string table is sequential
	 * relative to the symbol table order
	 */
	if (sfunc == NULL && usemmap)
		(void)madvise(stab, stabsize, MADV_SEQUENTIAL);

	/*
	 * fix up the symbol table and filter out unwanted entries
	 *
	 * common symbols are characterized by a n_type of N_UNDF and a
	 * non-zero n_value -- change n_type to N_COMM for all such
	 * symbols to make life easier later.
	 *
	 * filter out all entries which we don't want to print anyway
	 */
	for (np = names, i = nnames = 0; i < nrawnames; np++, i++) {
		/*
		 * make n_un.n_name a character pointer by adding the string
		 * table's base to n_un.n_strx
		 *
		 * don't mess with zero offsets
		 */
		if (np->nl.n_un.n_strx)
			np->nl.n_un.n_name = stab + np->nl.n_un.n_strx;
		else
			np->nl.n_un.n_name = "";
		if (print_only_external_symbols && !IS_EXTERNAL(np->nl.n_type))
			continue;
		if (print_only_undefined_symbols &&
		    SYMBOL_TYPE(np->nl.n_type) != N_UNDF)
			continue;

		snames[nnames++] = np;
	}

	/* sort the symbol table if applicable */
	if (sfunc)
		qsort(snames, (size_t)nnames, sizeof(*snames), sfunc);

	if (count > 1)
		(void)printf("\n%s:\n", name);

	/* print out symbols */
	for (i = 0; i < nnames; i++)
		print_symbol(name, snames[i]);

	free(snames);
	free(names);
	MUNMAP(stab, stabsize);
	return(0);
}

char *
symname(struct xnlist *sym)
{
	return sym->nl.n_un.n_name;
}

/*
 * print_symbol()
 *	show one symbol
 */
void
print_symbol(const char *name, struct xnlist *sym)
{
	if (print_file_each_line) {
		if (posix_output)
			(void)printf("%s: ", name);
		else
			(void)printf("%s:", name);
	}

	if (posix_output) {
		(void)printf("%s %c ", symname(sym), typeletter(sym));
		if (SYMBOL_TYPE(sym->nl.n_type) != N_UNDF)
			(void)printf(posix_fmtstr, sym->nl.n_value,
			    sym->n_size);
		(void)printf("\n");
	} else {
		/*
		 * handle undefined-only format especially (no space is
		 * left for symbol values, no type field is printed)
		 */
		if (!print_only_undefined_symbols) {
			/* print symbol's value */
			if (SYMBOL_TYPE(sym->nl.n_type) == N_UNDF)
				(void)printf("        ");
			else
				(void)printf("%08lx", sym->nl.n_value);

			/* print type information */
			if (show_extensions)
				(void)printf(" %c   ", typeletter(sym));
			else
				(void)printf(" %c ", typeletter(sym));
		}

		(void)puts(symname(sym));
	}
}

/*
 * typeletter()
 *	return a description letter for the given basic type code of an
 *	symbol table entry.  The return value will be upper case for
 *	external, lower case for internal symbols.
 */
char
typeletter(struct xnlist *np)
{
	int ext = IS_EXTERNAL(np->nl.n_type);

	if (np->nl.n_other)
		return np->nl.n_other;

	switch(SYMBOL_TYPE(np->nl.n_type)) {
	case N_ABS:
		return(ext? 'A' : 'a');
	case N_BSS:
		return(ext? 'B' : 'b');
	case N_COMM:
		return(ext? 'C' : 'c');
	case N_DATA:
		return(ext? 'D' : 'd');
	case N_FN:
		/* NOTE: N_FN == N_WARNING,
		 * in this case, the N_EXT bit is to considered as
		 * part of the symbol's type itself.
		 */
		return(ext? 'F' : 'W');
	case N_TEXT:
		return(ext? 'T' : 't');
	case N_SIZE:
		return(ext? 'S' : 's');
	case N_UNDF:
		return(ext? 'U' : 'u');
	}
	return('?');
}

int
fname(const void *a0, const void *b0)
{
	struct xnlist * const *a = a0, * const *b = b0;

	return(strcmp((*a)->nl.n_un.n_name, (*b)->nl.n_un.n_name));
}

int
rname(const void *a0, const void *b0)
{
	struct xnlist * const *a = a0, * const *b = b0;

	return(strcmp((*b)->nl.n_un.n_name, (*a)->nl.n_un.n_name));
}

int
value(const void *a0, const void *b0)
{
	struct xnlist * const *a = a0, * const *b = b0;

	if (SYMBOL_TYPE((*a)->nl.n_type) == N_UNDF)
		if (SYMBOL_TYPE((*b)->nl.n_type) == N_UNDF)
			return(0);
		else
			return(-1);
	else if (SYMBOL_TYPE((*b)->nl.n_type) == N_UNDF)
		return(1);
	if (rev) {
		if ((*a)->nl.n_value == (*b)->nl.n_value)
			return(rname(a0, b0));
		return((*b)->nl.n_value > (*a)->nl.n_value ? 1 : -1);
	} else {
		if ((*a)->nl.n_value == (*b)->nl.n_value)
			return(fname(a0, b0));
		return((*a)->nl.n_value > (*b)->nl.n_value ? 1 : -1);
	}
}

#define CPPFILT	"/usr/bin/c++filt"

void
pipe2cppfilt(void)
{
	int pip[2];
	char *argv[2];

	argv[0] = "c++filt";
	argv[1] = NULL;

	if (pipe(pip) == -1)
		err(1, "pipe");
	switch(fork()) {
	case -1:
		err(1, "fork");
	default:
		dup2(pip[0], 0);
		close(pip[0]);
		close(pip[1]);
		execve(CPPFILT, argv, NULL);
		err(1, "execve");
	case 0:
		dup2(pip[1], 1);
		close(pip[1]);
		close(pip[0]);
	}
}

void
usage(void)
{
	extern char *__progname;

	if (issize)
		fprintf(stderr, "usage: %s [-tw] [file ...]\n", __progname);
	else
		fprintf(stderr, "usage: %s [-AaCDegnoPprsuw] [-t d|o|x] [file ...]\n",
		    __progname);
	exit(1);
}
@


1.50
log
@ratchet pledge from the start; from Theo Buehler
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.49 2015/10/09 01:37:08 deraadt Exp $	*/
d620 2
a621 4
	if (nametab) {
		free(nametab);
		nametab = NULL;
	}
@


1.49
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.48 2015/10/05 07:16:03 deraadt Exp $	*/
d138 3
d144 4
a147 1
		issize++;
@


1.48
log
@tame "stdio rpath" works fine, as long as we sidestep the demangling
process which involves fork+execve....
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.47 2015/08/13 19:13:28 miod Exp $	*/
d215 2
a216 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
@


1.47
log
@Grow -P (POSIX output) and -t (POSIX output radix) support. Several 3rd-party
software depend upon this.

Requested by feinerer@@, ok millert@@; manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.46 2015/05/17 21:41:50 guenther Exp $	*/
d214 4
@


1.46
log
@Add 'D' to usage optstring.  Prodded by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.45 2015/05/17 20:19:08 guenther Exp $	*/
d52 1
a53 1
#include "util.h"
d73 3
d87 1
a87 1
char *otherstring(struct nlist *);
d89 1
a89 1
char typeletter(struct nlist *);
d100 1
a100 1
char	*symname(struct nlist *);
d104 1
a104 1
void	print_symbol(const char *, struct nlist *);
d106 1
a106 1
#define	OPTSTRING_NM	"aABCDegnoprsuvw"
d177 3
d195 6
a200 1
				break;
d202 1
d209 3
d486 2
d575 3
a577 1
		if (count > 1)
d585 3
d630 1
a630 1
	struct nlist *np, *names, **snames;
d718 2
a719 2
		if (np->n_un.n_strx)
			np->n_un.n_name = stab + np->n_un.n_strx;
d721 2
a722 2
			np->n_un.n_name = "";
		if (print_only_external_symbols && !IS_EXTERNAL(np->n_type))
d725 1
a725 1
		    SYMBOL_TYPE(np->n_type) != N_UNDF)
d749 1
a749 1
symname(struct nlist *sym)
d751 1
a751 1
	return sym->n_un.n_name;
d759 1
a759 1
print_symbol(const char *name, struct nlist *sym)
d761 6
a766 2
	if (print_file_each_line)
		(void)printf("%s:", name);
d768 24
a791 10
	/*
	 * handle undefined-only format especially (no space is
	 * left for symbol values, no type field is printed)
	 */
	if (!print_only_undefined_symbols) {
		/* print symbol's value */
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF)
			(void)printf("        ");
		else
			(void)printf("%08lx", sym->n_value);
d793 1
a793 5
		/* print type information */
		if (show_extensions)
			(void)printf(" %c   ", typeletter(sym));
		else
			(void)printf(" %c ", typeletter(sym));
a794 2

	(void)puts(symname(sym));
d804 1
a804 1
typeletter(struct nlist *np)
d806 1
a806 1
	int ext = IS_EXTERNAL(np->n_type);
d808 2
a809 2
	if (np->n_other)
		return np->n_other;
d811 1
a811 1
	switch(SYMBOL_TYPE(np->n_type)) {
d839 1
a839 1
	struct nlist * const *a = a0, * const *b = b0;
d841 1
a841 1
	return(strcmp((*a)->n_un.n_name, (*b)->n_un.n_name));
d847 1
a847 1
	struct nlist * const *a = a0, * const *b = b0;
d849 1
a849 1
	return(strcmp((*b)->n_un.n_name, (*a)->n_un.n_name));
d855 1
a855 1
	struct nlist * const *a = a0, * const *b = b0;
d857 2
a858 2
	if (SYMBOL_TYPE((*a)->n_type) == N_UNDF)
		if (SYMBOL_TYPE((*b)->n_type) == N_UNDF)
d862 1
a862 1
	else if (SYMBOL_TYPE((*b)->n_type) == N_UNDF)
d865 1
a865 1
		if ((*a)->n_value == (*b)->n_value)
d867 1
a867 1
		return((*b)->n_value > (*a)->n_value ? 1 : -1);
d869 1
a869 1
		if ((*a)->n_value == (*b)->n_value)
d871 1
a871 1
		return((*a)->n_value > (*b)->n_value ? 1 : -1);
d912 1
a912 1
		fprintf(stderr, "usage: %s [-aCDegnoprsuw] [file ...]\n",
@


1.45
log
@Add -D option for displaying the dynamic symbol table

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.44 2015/04/09 04:46:18 guenther Exp $	*/
d878 1
a878 1
		fprintf(stderr, "usage: %s [-aCegnoprsuw] [file ...]\n",
@


1.44
log
@ELF weak symbols are _not_ like a.out indirect symbols.  Nothing in ELF is,
so remove N_INDR handling.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.43 2015/04/08 04:23:15 guenther Exp $	*/
d74 1
d103 1
a103 1
#define	OPTSTRING_NM	"aABCegnoprsuvw"
d107 1
a107 1
/*	{ "dynamic",		no_argument,		0,	'D' }, */
d153 3
@


1.43
log
@Delete another piece of a.out detritus
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.42 2015/01/16 06:40:10 deraadt Exp $	*/
d713 1
a713 4
	for (i = 0; i < nnames; i++) {
		if (show_extensions && snames[i] != names &&
		    SYMBOL_TYPE((snames[i] -1)->n_type) == N_INDR)
			continue;
a714 1
	}
d744 1
a744 3
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF ||
		    (show_extensions && SYMBOL_TYPE(sym->n_type) == N_INDR &&
		    sym->n_value == 0))
d756 1
a756 4
	if (SYMBOL_TYPE(sym->n_type) == N_INDR && show_extensions)
		printf("%s -> %s\n", symname(sym), symname(sym+1));
	else
		(void)puts(symname(sym));
a789 2
	case N_INDR:
		return(ext? 'I' : 'i');
@


1.42
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.41 2014/04/28 18:49:28 miod Exp $	*/
a62 9

/* a funky nlist overload for reading 32bit a.out on 64bit toys */
struct nlist32 {
	u_int32_t	strx;
	u_int8_t	type;
	u_int8_t	other;
	u_int16_t	desc;
	u_int32_t	value;
} __packed;
@


1.41
log
@Ignore IRIX6-compatible archive map on mips64 platform, since the mips64
toolchain creates them. This lets nm -w correctly return 0 for valid archives.

ok jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.40 2013/11/26 13:19:07 deraadt Exp $	*/
d36 1
a36 1
#include <sys/param.h>
@


1.40
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.39 2013/11/12 19:37:39 deraadt Exp $	*/
d57 1
d539 7
@


1.39
log
@avoid math on void * pointers; delete an unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.38 2013/11/12 14:07:53 deraadt Exp $	*/
d311 1
a311 1
	    (isdigit(arh->ar_name[3]))) {
@


1.38
log
@remove more code accidentally left behind during the a.out purge
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.37 2013/10/24 19:53:43 miod Exp $	*/
d94 3
d407 1
a407 1
	void *symdef;
d426 1
a426 1
	prn = symdef + sizeof(u_long);
a607 1
	off_t staboff;
@


1.37
log
@Redo 1.34+1.35, but ignore incorrect files in show_file() as done in 1.33.
Fixes nm output on archives on mips.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.35 2013/10/21 02:59:52 deraadt Exp $	*/
a53 3

/* XXX get shared code to handle a.out byte-order swaps */
#include "byte.c"
@


1.36
log
@back out to 1.33, subtle bug being hunted...
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.33 2011/02/06 18:34:00 jasper Exp $	*/
a39 1
#include <stab.h>
d47 1
a47 3
#ifdef __ELF__
#include <link_aout.h>
#endif
a61 1
	struct exec aout;
d94 1
d96 1
a96 3
char *otherstring(struct nlist *);
char *typestring(unsigned int);
char typeletter(struct nlist *, int);
a98 1
#define	IS_DEBUGGER_SYMBOL(x)	((x) & N_STAB)
d104 1
a104 1
char	*symname(struct nlist *, int);
d108 1
a108 1
void	print_symbol(const char *, struct nlist *, int);
d253 1
a253 1
		if (bytes < sizeof(exec_head.aout) || IS_ELF(exec_head.elf32)) {
d262 1
a262 1
	if (!IS_ELF(exec_head.elf32) && N_BADMAG(exec_head.aout)) {
d606 1
a606 1
	int i, aout, nrawnames, nnames;
a609 1
	aout = 0;
d641 1
a641 2

	} else if (BAD_OBJECT(head->aout)) {
d645 1
a645 97
	} else do {
		u_int32_t w;

		aout++;

		fix_header_order(&head->aout);

		if (issize) {
			text = head->aout.a_text;
			data = head->aout.a_data;
			bss = head->aout.a_bss;
			break;
		}

		/* stop if the object file contains no symbol table */
		if (!head->aout.a_syms) {
			warnx("%s: no name list", name);
			return(1);
		}

		if (fseeko(fp, foff + N_SYMOFF(head->aout), SEEK_SET)) {
			warn("%s", name);
			return(1);
		}

#ifdef __LP64__
		nrawnames = head->aout.a_syms / sizeof(struct nlist32);
#else
		nrawnames = head->aout.a_syms / sizeof(*names);
#endif
		/* get memory for the symbol table */
		if ((names = calloc(nrawnames, sizeof(struct nlist))) == NULL) {
			warn("%s: malloc names", name);
			return (1);
		}

		if ((snames = calloc(nrawnames, sizeof(struct nlist *))) == NULL) {
			warn("%s: malloc snames", name);
			free(names);
			return (1);
		}

#ifdef __LP64__
		for (np = names, i = nrawnames; i--; np++) {
			struct nlist32 nl32;

			if (fread(&nl32, sizeof(nl32), 1, fp) != 1) {
				warnx("%s: cannot read symbol table", name);
				free(snames);
				free(names);
				return (1);
			}
			np->n_type = nl32.type;
			np->n_other = nl32.other;
			if (byte_sex(N_GETMID(head->aout)) != BYTE_ORDER) {
				np->n_un.n_strx = swap32(nl32.strx);
				np->n_desc = swap16(nl32.desc);
				np->n_value = swap32(nl32.value);
			} else {
				np->n_un.n_strx = nl32.strx;
				np->n_desc = nl32.desc;
				np->n_value = nl32.value;
			}
		}
#else
		if (fread(names, head->aout.a_syms, 1, fp) != 1) {
			warnx("%s: cannot read symbol table", name);
			free(snames);
			free(names);
			return (1);
		}
		fix_nlists_order(names, nrawnames, N_GETMID(head->aout));
#endif

		staboff = ftello(fp);
		/*
		 * Following the symbol table comes the string table.
		 * The first 4-byte-integer gives the total size of the
		 * string table _including_ the size specification itself.
		 */
		if (fread(&w, sizeof(w), (size_t)1, fp) != 1) {
			warnx("%s: cannot read stab size", name);
			free(snames);
			free(names);
			return(1);
		}
		stabsize = fix_32_order(w, N_GETMID(head->aout));
		MMAP(stab, stabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
		    fileno(fp), staboff);
		if (stab == MAP_FAILED) {
			free(snames);
			free(names);
			return (1);
		}

		stabsize -= 4;		/* we already have the size */
	} while (0);
a697 4
		if (aout && SYMBOL_TYPE(np->n_type) == N_UNDF && np->n_value)
			np->n_type = N_COMM | (np->n_type & N_EXT);
		if (!print_all_symbols && IS_DEBUGGER_SYMBOL(np->n_type))
			continue;
d719 1
a719 1
		print_symbol(name, snames[i], aout);
d729 1
a729 1
symname(struct nlist *sym, int aout)
d731 1
a731 4
	if (demangle && sym->n_un.n_name[0] == '_' && aout)
		return sym->n_un.n_name + 1;
	else
		return sym->n_un.n_name;
d739 1
a739 1
print_symbol(const char *name, struct nlist *sym, int aout)
d758 2
a759 6
		if (IS_DEBUGGER_SYMBOL(sym->n_type))
			(void)printf(" - %02x %04x %5s ", sym->n_other,
			    sym->n_desc&0xffff, typestring(sym->n_type));
		else if (show_extensions)
			(void)printf(" %c%2s ", typeletter(sym, aout),
			    otherstring(sym));
d761 1
a761 1
			(void)printf(" %c ", typeletter(sym, aout));
d764 2
a765 3
	if (SYMBOL_TYPE(sym->n_type) == N_INDR && show_extensions) {
		printf("%s -> %s\n", symname(sym, aout), symname(sym+1, aout));
	}
d767 1
a767 71
		(void)puts(symname(sym, aout));
}

char *
otherstring(struct nlist *sym)
{
	static char buf[3];
	char *result;

	result = buf;

	if (N_BIND(sym) == BIND_WEAK)
		*result++ = 'w';
	if (N_AUX(sym) == AUX_OBJECT)
		*result++ = 'o';
	else if (N_AUX(sym) == AUX_FUNC)
		*result++ = 'f';
	*result++ = 0;
	return buf;
}

/*
 * typestring()
 *	return the a description string for an STAB entry
 */
char *
typestring(unsigned int type)
{
	switch(type) {
	case N_BCOMM:
		return("BCOMM");
	case N_ECOML:
		return("ECOML");
	case N_ECOMM:
		return("ECOMM");
	case N_ENTRY:
		return("ENTRY");
	case N_FNAME:
		return("FNAME");
	case N_FUN:
		return("FUN");
	case N_GSYM:
		return("GSYM");
	case N_LBRAC:
		return("LBRAC");
	case N_LCSYM:
		return("LCSYM");
	case N_LENG:
		return("LENG");
	case N_LSYM:
		return("LSYM");
	case N_PC:
		return("PC");
	case N_PSYM:
		return("PSYM");
	case N_RBRAC:
		return("RBRAC");
	case N_RSYM:
		return("RSYM");
	case N_SLINE:
		return("SLINE");
	case N_SO:
		return("SO");
	case N_SOL:
		return("SOL");
	case N_SSYM:
		return("SSYM");
	case N_STSYM:
		return("STSYM");
	}
	return("???");
d777 1
a777 1
typeletter(struct nlist *np, int aout)
d781 1
a781 1
	if (!aout && !IS_DEBUGGER_SYMBOL(np->n_type) && np->n_other)
@


1.35
log
@remove a space that snuck into the output
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.34 2013/10/19 08:59:48 deraadt Exp $	*/
d40 1
d48 3
a50 1

d65 1
d98 1
d100 2
a101 2
int (*sfunc)(const void *, const void *) = fname;
char typeletter(struct nlist *);
d104 1
d110 1
a110 1
char	*symname(struct nlist *);
d114 1
a114 1
void	print_symbol(const char *, struct nlist *);
d259 1
a259 1
		if (bytes < sizeof(exec_head.elf32) || IS_ELF(exec_head.elf32)) {
d268 1
a268 1
	if (!IS_ELF(exec_head.elf32)) {
d612 1
a612 1
	int i, nrawnames, nnames;
d616 1
d648 102
a749 1
	}
d802 4
d827 1
a827 1
		print_symbol(name, snames[i]);
d837 1
a837 1
symname(struct nlist *sym)
d839 4
a842 1
	return sym->n_un.n_name;
d850 1
a850 1
print_symbol(const char *name, struct nlist *sym)
d869 6
a874 2
		if (show_extensions)
			(void)printf(" %c   ", typeletter(sym));
d876 1
a876 1
			(void)printf(" %c ", typeletter(sym));
d879 3
a881 2
	if (SYMBOL_TYPE(sym->n_type) == N_INDR && show_extensions)
		printf("%s -> %s\n", symname(sym), symname(sym+1));
d883 71
a953 1
		(void)puts(symname(sym));
d963 1
a963 1
typeletter(struct nlist *np)
d967 1
a967 1
	if (np->n_other)
@


1.34
log
@Remove a.out/stab knowledge from nm.
(As a side effect of this repair, the -e option no longer reports that
all weak objects are functions)
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.33 2011/02/06 18:34:00 jasper Exp $	*/
d757 1
a757 1
			(void)printf(" %c  ", typeletter(sym));
@


1.33
log
@- nm -s omitted the symbol list for first object file in an archive. fix this
  by forcing show_symtab() to restore its original file offset after processing.

  fix from pr #6385.
  ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.32 2009/10/27 23:51:21 deraadt Exp $	*/
a39 1
#include <stab.h>
d47 1
a47 3
#ifdef __ELF__
#include <link_aout.h>
#endif
a61 1
	struct exec aout;
d94 1
d96 1
a96 3
char *otherstring(struct nlist *);
char *typestring(unsigned int);
char typeletter(struct nlist *, int);
a98 1
#define	IS_DEBUGGER_SYMBOL(x)	((x) & N_STAB)
d104 1
a104 1
char	*symname(struct nlist *, int);
d108 1
a108 1
void	print_symbol(const char *, struct nlist *, int);
d253 1
a253 1
		if (bytes < sizeof(exec_head.aout) || IS_ELF(exec_head.elf32)) {
d262 1
a262 1
	if (!IS_ELF(exec_head.elf32) && N_BADMAG(exec_head.aout)) {
d606 1
a606 1
	int i, aout, nrawnames, nnames;
a609 1
	aout = 0;
d641 1
a641 102

	} else if (BAD_OBJECT(head->aout)) {
		if (warn_fmt)
			warnx("%s: bad format", name);
		return (1);
	} else do {
		u_int32_t w;

		aout++;

		fix_header_order(&head->aout);

		if (issize) {
			text = head->aout.a_text;
			data = head->aout.a_data;
			bss = head->aout.a_bss;
			break;
		}

		/* stop if the object file contains no symbol table */
		if (!head->aout.a_syms) {
			warnx("%s: no name list", name);
			return(1);
		}

		if (fseeko(fp, foff + N_SYMOFF(head->aout), SEEK_SET)) {
			warn("%s", name);
			return(1);
		}

#ifdef __LP64__
		nrawnames = head->aout.a_syms / sizeof(struct nlist32);
#else
		nrawnames = head->aout.a_syms / sizeof(*names);
#endif
		/* get memory for the symbol table */
		if ((names = calloc(nrawnames, sizeof(struct nlist))) == NULL) {
			warn("%s: malloc names", name);
			return (1);
		}

		if ((snames = calloc(nrawnames, sizeof(struct nlist *))) == NULL) {
			warn("%s: malloc snames", name);
			free(names);
			return (1);
		}

#ifdef __LP64__
		for (np = names, i = nrawnames; i--; np++) {
			struct nlist32 nl32;

			if (fread(&nl32, sizeof(nl32), 1, fp) != 1) {
				warnx("%s: cannot read symbol table", name);
				free(snames);
				free(names);
				return (1);
			}
			np->n_type = nl32.type;
			np->n_other = nl32.other;
			if (byte_sex(N_GETMID(head->aout)) != BYTE_ORDER) {
				np->n_un.n_strx = swap32(nl32.strx);
				np->n_desc = swap16(nl32.desc);
				np->n_value = swap32(nl32.value);
			} else {
				np->n_un.n_strx = nl32.strx;
				np->n_desc = nl32.desc;
				np->n_value = nl32.value;
			}
		}
#else
		if (fread(names, head->aout.a_syms, 1, fp) != 1) {
			warnx("%s: cannot read symbol table", name);
			free(snames);
			free(names);
			return (1);
		}
		fix_nlists_order(names, nrawnames, N_GETMID(head->aout));
#endif

		staboff = ftello(fp);
		/*
		 * Following the symbol table comes the string table.
		 * The first 4-byte-integer gives the total size of the
		 * string table _including_ the size specification itself.
		 */
		if (fread(&w, sizeof(w), (size_t)1, fp) != 1) {
			warnx("%s: cannot read stab size", name);
			free(snames);
			free(names);
			return(1);
		}
		stabsize = fix_32_order(w, N_GETMID(head->aout));
		MMAP(stab, stabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
		    fileno(fp), staboff);
		if (stab == MAP_FAILED) {
			free(snames);
			free(names);
			return (1);
		}

		stabsize -= 4;		/* we already have the size */
	} while (0);
a693 4
		if (aout && SYMBOL_TYPE(np->n_type) == N_UNDF && np->n_value)
			np->n_type = N_COMM | (np->n_type & N_EXT);
		if (!print_all_symbols && IS_DEBUGGER_SYMBOL(np->n_type))
			continue;
d715 1
a715 1
		print_symbol(name, snames[i], aout);
d725 1
a725 1
symname(struct nlist *sym, int aout)
d727 1
a727 4
	if (demangle && sym->n_un.n_name[0] == '_' && aout)
		return sym->n_un.n_name + 1;
	else
		return sym->n_un.n_name;
d735 1
a735 1
print_symbol(const char *name, struct nlist *sym, int aout)
d754 2
a755 6
		if (IS_DEBUGGER_SYMBOL(sym->n_type))
			(void)printf(" - %02x %04x %5s ", sym->n_other,
			    sym->n_desc&0xffff, typestring(sym->n_type));
		else if (show_extensions)
			(void)printf(" %c%2s ", typeletter(sym, aout),
			    otherstring(sym));
d757 1
a757 1
			(void)printf(" %c ", typeletter(sym, aout));
d760 2
a761 3
	if (SYMBOL_TYPE(sym->n_type) == N_INDR && show_extensions) {
		printf("%s -> %s\n", symname(sym, aout), symname(sym+1, aout));
	}
d763 1
a763 71
		(void)puts(symname(sym, aout));
}

char *
otherstring(struct nlist *sym)
{
	static char buf[3];
	char *result;

	result = buf;

	if (N_BIND(sym) == BIND_WEAK)
		*result++ = 'w';
	if (N_AUX(sym) == AUX_OBJECT)
		*result++ = 'o';
	else if (N_AUX(sym) == AUX_FUNC)
		*result++ = 'f';
	*result++ = 0;
	return buf;
}

/*
 * typestring()
 *	return the a description string for an STAB entry
 */
char *
typestring(unsigned int type)
{
	switch(type) {
	case N_BCOMM:
		return("BCOMM");
	case N_ECOML:
		return("ECOML");
	case N_ECOMM:
		return("ECOMM");
	case N_ENTRY:
		return("ENTRY");
	case N_FNAME:
		return("FNAME");
	case N_FUN:
		return("FUN");
	case N_GSYM:
		return("GSYM");
	case N_LBRAC:
		return("LBRAC");
	case N_LCSYM:
		return("LCSYM");
	case N_LENG:
		return("LENG");
	case N_LSYM:
		return("LSYM");
	case N_PC:
		return("PC");
	case N_PSYM:
		return("PSYM");
	case N_RBRAC:
		return("RBRAC");
	case N_RSYM:
		return("RSYM");
	case N_SLINE:
		return("SLINE");
	case N_SO:
		return("SO");
	case N_SOL:
		return("SOL");
	case N_SSYM:
		return("SSYM");
	case N_STSYM:
		return("STSYM");
	}
	return("???");
d773 1
a773 1
typeletter(struct nlist *np, int aout)
d777 1
a777 1
	if (!aout && !IS_DEBUGGER_SYMBOL(np->n_type) && np->n_other)
@


1.32
log
@nm -V is silly, and prining the rcsid even more so
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.31 2007/09/02 15:19:33 deraadt Exp $	*/
d357 3
d397 2
a551 1
				goto skip;
@


1.31
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.30 2007/08/06 19:16:06 sobrado Exp $	*/
a35 11
#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#if 0
static const char sccsid[] = "@@(#)nm.c	8.1 (Berkeley) 6/6/93";
#endif
static const char rcsid[] = "$OpenBSD: nm.c,v 1.30 2007/08/06 19:16:06 sobrado Exp $";

d116 1
a116 1
#define	OPTSTRING_NM	"aABCegnoprsuvVw"
a129 1
	{ "version",		no_argument,		0,	'V' },
a192 3
		case 'V':
			fprintf(stderr, "%s\n", rcsid);
			exit(0);
d1069 1
a1069 1
		fprintf(stderr, "usage: %s [-aCegnoprsuVw] [file ...]\n",
@


1.30
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.29 2005/01/03 14:49:39 espie Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.29 2005/01/03 14:49:39 espie Exp $";
d695 1
a695 1
		if ((names = malloc(nrawnames * sizeof(struct nlist))) == NULL) {
d700 1
a700 1
		if ((snames = malloc(nrawnames * sizeof(struct nlist *))) == NULL) {
@


1.29
log
@don't try to demangle C symbols if we're ELF.
looks okay mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.28 2004/10/10 16:45:00 mickey Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.28 2004/10/10 16:45:00 mickey Exp $";
d1084 1
a1084 1
		fprintf(stderr, "usage: %s [-aABCegnoprsuvVw] [file ...]\n",
@


1.28
log
@now that no cpu assumptions are left in -- remove the cross-glue
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.27 2004/10/09 20:26:57 mickey Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.27 2004/10/09 20:26:57 mickey Exp $";
d121 1
a121 1
char	*symname(struct nlist *);
d615 2
a616 2
 *	file pointer for fp is expected to be at the beginning of an a.out
 *	header.
d848 1
a848 1
symname(struct nlist *sym)
d850 1
a850 1
	if (demangle && sym->n_un.n_name[0] == '_')
d891 1
a891 1
		printf("%s -> %s\n", symname(sym), symname(sym+1));
d894 1
a894 1
		(void)puts(symname(sym));
@


1.27
log
@move out elf code into elf.c and generate 32 and 64 versions of it;
allow operation on size-mixed host-target as well as ensianess for
both a.out and elf (though a.out 64bit probably does not exist ;)
tested on hppa-sparc64-i386-vax intermixen
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.26 2004/07/11 07:08:46 mickey Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.26 2004/07/11 07:08:46 mickey Exp $";
a70 5

#ifdef MID_MACHINE_OVERRIDE
#undef MID_MACHINE
#define	MID_MACHINE	MID_MACHINE_OVERRIDE
#endif
@


1.26
log
@need to byteswap string table size before use for the alien endian a.out
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.25 2004/05/04 23:09:07 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.25 2004/05/04 23:09:07 deraadt Exp $";
d66 4
a69 1
/* XXX get shared code to handle byte-order swaps */
a70 1
#include "elf.c"
d82 2
a83 1
	Elf_Ehdr elf;
d86 9
a130 1
int	elf_symload(const char *, FILE *, off_t, Elf_Ehdr *, Elf_Shdr *);
d279 1
a279 1
		if (bytes < sizeof(exec_head.aout) || IS_ELF(exec_head.elf)) {
d288 1
a288 1
	if (!IS_ELF(exec_head.elf) && N_BADMAG(exec_head.aout)) {
a364 23
#define	MMAP(ptr, len, prot, flags, fd, off)	do {		\
	if ((ptr = mmap(NULL, len, prot, flags, fd, off)) == MAP_FAILED) { \
		usemmap = 0;						\
		if (errno != EINVAL)					\
			warn("mmap");					\
		else if ((ptr = malloc(len)) == NULL) {			\
			ptr = MAP_FAILED;				\
			warn("malloc");					\
		} else if (pread(fd, ptr, len, off) != len) {		\
			free(ptr);					\
			ptr = MAP_FAILED;				\
			warn("pread");					\
		}							\
	}								\
} while (0)

#define MUNMAP(addr, len)	do {					\
	if (usemmap)							\
		munmap(addr, len);					\
	else								\
		free(addr);						\
} while (0)

a614 2
struct nlist *names;
struct nlist **snames;
a615 1
int nnames, nrawnames, stabsize;
d627 3
a629 2
	struct nlist *np;
	Elf_Shdr *shdr;
a630 1
	int i, aout;
d633 4
a636 11
	if (IS_ELF(head->elf) &&
	    head->elf.e_ident[EI_CLASS] == ELF_TARG_CLASS &&
	    head->elf.e_ident[EI_VERSION] == ELF_TARG_VER) {

		elf_fix_header(&head->elf);

		if ((shdr = malloc(head->elf.e_shentsize *
		    head->elf.e_shnum)) == NULL) {
			warn("%s: malloc shdr", name);
			return (1);
		}
d638 1
a638 3
		if (fseeko(fp, foff + head->elf.e_shoff, SEEK_SET)) {
			warn("%s: fseeko", name);
			free(shdr);
a639 1
		}
d641 12
a652 6
		if (fread(shdr, head->elf.e_shentsize, head->elf.e_shnum,
		    fp) != head->elf.e_shnum) {
			warnx("%s: premature EOF", name);
			free(shdr);
			return(1);
		}
d654 2
a655 1
		elf_fix_shdrs(&head->elf, shdr);
d657 7
a663 20
		if (issize) {
			text = data = bss = 0;
			for (i = 0; i < head->elf.e_shnum; i++) {
				if (!(shdr[i].sh_flags & SHF_ALLOC))
					;
				else if (shdr[i].sh_flags & SHF_EXECINSTR ||
				    !(shdr[i].sh_flags & SHF_WRITE))
					text += shdr[i].sh_size;
				else if (shdr[i].sh_type == SHT_NOBITS)
					bss += shdr[i].sh_size;
				else
					data += shdr[i].sh_size;
			}
			free(shdr);
		} else {
			i = elf_symload(name, fp, foff, &head->elf, shdr);
			free(shdr);
			if (i)
				return (i);
		}
d670 2
d694 5
d700 1
a700 1
		if ((names = malloc(head->aout.a_syms)) == NULL) {
d704 1
a704 1
		nrawnames = head->aout.a_syms / sizeof(*names);
d711 23
d738 1
a738 1
			return(1);
d741 1
d749 1
a749 1
		if (fread(&stabsize, sizeof(stabsize), (size_t)1, fp) != 1) {
d755 1
a755 1
		stabsize = fix_long_order(stabsize, N_GETMID(head->aout));
a849 115
}

int
elf_symload(const char *name, FILE *fp, off_t foff, Elf_Ehdr *eh, Elf_Shdr *shdr)
{
	long symsize, shstrsize;
	struct nlist *np;
	Elf_Sym sbuf;
	char *shstr;
	int i;

	shstrsize = shdr[eh->e_shstrndx].sh_size;
	if ((shstr = malloc(shstrsize)) == NULL) {
		warn("%s: malloc shsrt", name);
		return (1);
	}

	if (fseeko(fp, foff + shdr[eh->e_shstrndx].sh_offset, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(shstr);
		return (1);
	}

	if (fread(shstr, 1, shstrsize, fp) != shstrsize) {
		warnx("%s: premature EOF", name);
		free(shstr);
		return(1);
	}

	stab = NULL;
	names = NULL; snames = NULL;
	for (i = 0; i < eh->e_shnum; i++) {
		if (!strcmp(shstr + shdr[i].sh_name, ELF_STRTAB)) {
			stabsize = shdr[i].sh_size;
			if (stabsize > SIZE_T_MAX) {
				warnx("%s: corrupt file", name);
				free(shstr);
				return (1);
			}

			MMAP(stab, stabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
			    fileno(fp), foff + shdr[i].sh_offset);
			if (stab == MAP_FAILED) {
				free(shstr);
				return (1);
			}
		}
	}
	for (i = 0; i < eh->e_shnum; i++) {
		if (!strcmp(shstr + shdr[i].sh_name, ELF_SYMTAB)) {
			symsize = shdr[i].sh_size;
			if (fseeko(fp, foff + shdr[i].sh_offset, SEEK_SET)) {
				warn("%s: fseeko", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(shstr);
				return (1);
			}

			nrawnames = symsize / sizeof(sbuf);
			if ((names = calloc(nrawnames, sizeof(*np))) == NULL) {
				warn("%s: malloc names", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(names);
				free(shstr);
				return (1);
			}
			if ((snames = malloc(nrawnames * sizeof(np))) == NULL) {
				warn("%s: malloc snames", name);
				if (stab)
					MUNMAP(stab, stabsize);
				free(shstr);
				free(names);
				free(snames);
				return (1);
			}

			for (np = names; symsize > 0; symsize -= sizeof(sbuf)) {
				if (fread(&sbuf, 1, sizeof(sbuf),
				    fp) != sizeof(sbuf)) {
					warn("%s: read symbol", name);
					if (stab)
						MUNMAP(stab, stabsize);
					free(shstr);
					free(names);
					free(snames);
					return (1);
				}

				elf_fix_sym(eh, &sbuf);

				if (!sbuf.st_name)
					continue;

				elf2nlist(&sbuf, eh, shdr, shstr, np);
				np->n_value = sbuf.st_value;
				np->n_un.n_strx = sbuf.st_name;
				np++;
			}
			nrawnames = np - names;
		}
	}

	free(shstr);
	if (stab == NULL) {
		warnx("%s: no name list", name);
		if (names)
			free(names);
		if (snames)
			free(snames);
		return (1);
	}

	return (0);
@


1.25
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.24 2004/04/29 13:34:37 miod Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.24 2004/04/29 13:34:37 miod Exp $";
d755 1
@


1.24
log
@Correctly report empty a.out objects as "no name list" instead of "bad format".

ok mickey@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.23 2004/01/14 04:23:26 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.23 2004/01/14 04:23:26 millert Exp $";
d118 1
a118 1
void 	print_symbol(const char *, struct nlist *, int);
d252 1
a252 1
    
d260 1
a260 1
    
d325 1
a325 1
	    (arh->ar_name[2] == '/') && 
d610 1
a610 1
	 	 * even byte boundary
d962 1
a962 1
		
d969 1
a969 1
	if (demangle && sym->n_un.n_name[0] == '_') 
d991 3
a993 3
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF || 
		    (show_extensions && SYMBOL_TYPE(sym->n_type) == N_INDR && 
		     sym->n_value == 0))
@


1.23
log
@Fix the mmap case; inadequate testing on my part!
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.22 2004/01/14 02:52:04 millert Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.22 2004/01/14 02:52:04 millert Exp $";
d250 1
d265 8
a272 4
	if (fread((char *)&exec_head, sizeof(exec_head), (size_t)1, fp) != 1) {
		warnx("%s: bad format", fname);
		(void)fclose(fp);
		return(1);
@


1.22
log
@Fallback to malloc + pread if mmap fails; fixes "nm /dev/ksyms".  OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.21 2004/01/13 17:32:32 mickey Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.21 2004/01/13 17:32:32 mickey Exp $";
d56 1
d92 1
d350 5
a354 3
	didmmap = (ptr = mmap(NULL, len, prot, flags, fd, off)) != MAP_FAILED; \
	if (!didmmap) {							\
		if ((ptr = malloc(len)) == NULL) {			\
d366 1
a366 1
	if (didmmap)							\
d383 1
a383 1
	int namelen, didmmap;
d438 1
a438 1
	int namelen, didmmap, rval = 0;
d443 1
a443 1
	if (didmmap)
d640 1
a640 1
	int i, aout, didmmap;
d789 2
a790 7
	if (sfunc == NULL && madvise(stab, stabsize, MADV_SEQUENTIAL)) {
		warn("%s: madvise", name);
		free(snames);
		free(names);
		MUNMAP(stab, stabsize);
		return (1);
	}
d853 1
a853 1
	int i, didmmap = 0;
@


1.21
log
@kill unused local vars; from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.20 2004/01/05 01:27:22 mickey Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.20 2004/01/05 01:27:22 mickey Exp $";
d347 21
d379 1
a379 1
	int namelen;
d381 2
a382 3
	if ((symtab = mmap(NULL, len, PROT_READ,
	    MAP_PRIVATE|MAP_FILE, fileno(fp), off)) == MAP_FAILED) {
		warn("%s: mmap", name);
a383 1
	}
d388 1
a388 2
		munmap(symtab, len);
		return (1);
d418 1
a418 1
	munmap(symtab, len);
d434 1
a434 7
	int namelen, rval = 0;

	if ((symdef = mmap(NULL, len, PROT_READ,
	    MAP_PRIVATE|MAP_FILE, fileno(fp), off)) == MAP_FAILED) {
		warn("%s: mmap", name);
		return (1);
	}
d436 2
a437 3
	if (madvise(symdef, len, MADV_SEQUENTIAL)) {
		warn("%s: madvise", name);
		munmap(symdef, len);
d439 2
a440 1
	}
d445 1
a445 1
		munmap(symdef, len);
d479 1
a479 1
	munmap(symdef, len);
d636 1
a636 1
	int i, aout;
d746 3
a748 4
		stabsize = fix_long_order(stabsize, N_GETMID(head->aout));
		if ((stab = mmap(NULL, stabsize, PROT_READ,
		    MAP_PRIVATE|MAP_FILE, fileno(fp), staboff)) == MAP_FAILED) {
			warn("%s: mmap", name);
d789 1
a789 1
		munmap(stab, stabsize);
d843 1
a843 1
	munmap(stab, stabsize);
d854 1
a854 1
	int i;
d885 3
a887 4
			if ((stab = mmap(NULL, stabsize, PROT_READ,
			    MAP_PRIVATE|MAP_FILE, fileno(fp),
			    foff + shdr[i].sh_offset)) == MAP_FAILED) {
				warn("%s: mmap", name);
d899 1
a899 1
					munmap(stab, stabsize);
d908 1
a908 1
					munmap(stab, stabsize);
d916 1
a916 1
					munmap(stab, stabsize);
d928 1
a928 1
						munmap(stab, stabsize);
@


1.20
log
@nm digs elf and merges w/ size; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.19 2003/06/10 22:20:49 deraadt Exp $	*/
d45 1
a45 1
static const char rcsid[] = "$OpenBSD: nm.c,v 1.19 2003/06/10 22:20:49 deraadt Exp $";
d839 1
a839 1
	long symsize, shstrsize, nlistsize;
@


1.19
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.18 2003/06/03 02:56:14 millert Exp $	*/
d37 1
a37 1
static char copyright[] =
a41 1
#ifndef lint
d43 1
a43 1
static char sccsid[] = "@@(#)nm.c	8.1 (Berkeley) 6/6/93";
d45 1
a45 2
static char rcsid[] = "$OpenBSD: nm.c,v 1.18 2003/06/03 02:56:14 millert Exp $";
#endif /* not lint */
d48 1
a48 1
#include <sys/types.h>
d50 1
d58 3
d64 1
d67 1
d69 4
d74 11
a84 2
int demangle = 0;
int ignore_bad_archive_entries = 1;
d89 6
a94 2
int show_extensions = 0;
int fcount;
d103 1
a103 2
char typeletter(unsigned int);

a109 1
void	*emalloc(size_t);
d113 24
a136 1
void 	print_symbol(const char *, struct nlist *);
d143 1
d146 1
d148 11
a158 1
	int ch, errors;
d160 1
a160 1
	while ((ch = getopt(argc, argv, "aBCegnopruw")) != -1) {
d178 1
d181 1
d191 3
d197 3
d201 1
a201 1
			ignore_bad_archive_entries = 0;
d203 5
a215 1
	fcount = argc - optind;
d217 1
d222 2
a223 4
	if (!fcount)
		errors = process_file("a.out");
	else {
		errors = 0;
d225 1
a225 1
			errors |= process_file(*argv);
d227 8
a234 2
	}
	exit(errors);
d242 2
a243 1
process_file(char *fname)
d245 1
a245 1
	struct exec exec_head;
d255 1
a255 1
	if (fcount > 1)
a268 1
	if (BAD_OBJECT(exec_head)) {
d270 1
d277 1
a277 1
		retval = show_archive(fname, fp);
d279 1
a279 1
		retval = show_objfile(fname, fp);
d284 187
d475 2
a476 1
show_archive(char *fname, FILE *fp)
d479 1
a479 1
	struct exec exec_head;
d481 2
a482 2
	long last_ar_off;
	char *p, *name;
d484 1
d488 2
a489 1
	name = emalloc(baselen + namelen);
d492 3
d497 1
a497 1
	while (fread((char *)&ar_head, sizeof(ar_head), (size_t)1, fp) == 1) {
d499 1
a499 1
		if (strncmp(ar_head.ar_fmag, ARFMAG, sizeof(ar_head.ar_fmag))) {
d501 2
a502 2
			(void)free(name);
			return(1);
d506 2
a507 1
		last_ar_off = ftell(fp);
d509 7
a515 2
		/* skip ranlib entries */
		if (!strncmp(ar_head.ar_name, RANLIBMAG, sizeof(RANLIBMAG) - 1))
d517 44
d567 7
a573 4
		p = name;
		if (print_file_each_line) {
			snprintf(p, baselen, "%s:", fname);
			p += strlen(p);
d575 2
a576 30
#ifdef AR_EFMT1
		/*
		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the
		 * first <namelen> bytes of the file
		 */
		if (		(ar_head.ar_name[0] == '#') &&
				(ar_head.ar_name[1] == '1') &&
				(ar_head.ar_name[2] == '/') && 
				(isdigit(ar_head.ar_name[3]))) {

			int len = atoi(&ar_head.ar_name[3]);
			if (len > namelen) {
				p -= (long)name;
				if ((name = realloc(name, baselen+len)) == NULL)
					err(1, NULL);
				namelen = len;
				p += (long)name;
			}
			if (fread(p, len, 1, fp) != 1) {
				warnx("%s: premature EOF", name);
				(void)free(name);
				return 1;
			}
			p += len;
		} else
#endif
		for (i = 0; i < sizeof(ar_head.ar_name); ++i)
			if (ar_head.ar_name[i] && ar_head.ar_name[i] != ' ')
				*p++ = ar_head.ar_name[i];
		*p++ = '\0';
d581 3
a583 15
			warnx("%s: premature EOF", name);
			(void)free(name);
			return(1);
		}

		if (BAD_OBJECT(exec_head)) {
			if (!ignore_bad_archive_entries) {
				 warnx("%s: bad format", name);
				rval = 1;
			}
		} else {
			(void)fseek(fp, (long)-sizeof(exec_head), SEEK_CUR);
			if (!print_file_each_line)
				(void)printf("\n%s:\n", name);
			rval |= show_objfile(name, fp);
d586 1
d592 1
a592 2
skip:		if (fseek(fp, last_ar_off + even(atol(ar_head.ar_size)),
		    SEEK_SET)) {
d594 2
a595 2
			(void)free(name);
			return(1);
d598 5
a602 1
	(void)free(name);
d606 5
d612 1
a612 1
 * show_objfile()
d617 2
a618 1
show_objfile(char *objname, FILE *fp)
d620 93
a712 12
	struct nlist *names, *np;
	struct nlist **snames;
	int i, nnames, nrawnames;
	struct exec head;
	long stabsize;
	char *stab;

	/* read a.out header */
	if (fread((char *)&head, sizeof(head), (size_t)1, fp) != 1) {
		warnx("%s: cannot read header", objname);
		return(1);
	}
d714 7
a720 8
	/*
	 * skip back to the header - the N_-macros return values relative
	 * to the beginning of the a.out header
	 */
	if (fseek(fp, (long)-sizeof(head), SEEK_CUR)) {
		warn("%s", objname);
		return(1);
	}
d722 20
a741 7
	/* stop if this is no valid object file, or a format we don't dare
	 * playing with
	 */
	if (BAD_OBJECT(head)) {
		warnx("%s: bad format", objname);
		return(1);
	}
d743 2
a744 1
	fix_header_order(&head);
d746 2
a747 5
	/* stop if the object file contains no symbol table */
	if (!head.a_syms) {
		warnx("%s: no name list", objname);
		return(1);
	}
d749 4
a752 4
	if (fseek(fp, (long)N_SYMOFF(head), SEEK_CUR)) {
		warn("%s", objname);
		return(1);
	}
d754 10
a763 10
	/* get memory for the symbol table */
	names = emalloc((size_t)head.a_syms);
	nrawnames = head.a_syms / sizeof(*names);
	snames = emalloc(nrawnames*sizeof(struct nlist *));
	if (fread((char *)names, (size_t)head.a_syms, (size_t)1, fp) != 1) {
		warnx("%s: cannot read symbol table", objname);
		(void)free((char *)names);
		return(1);
	}
	fix_nlists_order(names, nrawnames, N_GETMID(head));
d765 2
a766 9
	/*
	 * Following the symbol table comes the string table.  The first
	 * 4-byte-integer gives the total size of the string table
	 * _including_ the size specification itself.
	 */
	if (fread((char *)&stabsize, sizeof(stabsize), (size_t)1, fp) != 1) {
		warnx("%s: cannot read stab size", objname);
		(void)free((char *)names);
		return(1);
d768 1
a768 2
	stabsize = fix_long_order(stabsize, N_GETMID(head));
	stab = emalloc((size_t)stabsize);
d771 2
a772 2
	 * read the string table offset by 4 - all indices into the string
	 * table include the size specification.
d774 6
a779 6
	stabsize -= 4;		/* we already have the size */
	if (fread(stab + 4, (size_t)stabsize, (size_t)1, fp) != 1) {
		warnx("%s: stab truncated..", objname);
		(void)free((char *)names);
		(void)free(stab);
		return(1);
d802 1
a802 1
		if (SYMBOL_TYPE(np->n_type) == N_UNDF && np->n_value)
d819 3
d827 1
a827 1
		print_symbol(objname, snames[i]);
d830 3
a832 3
	(void)free(snames);
	(void)free(names);
	(void)free(stab);
d836 116
d966 1
a966 1
print_symbol(const char *objname, struct nlist *sym)
d969 1
a969 1
		(void)printf("%s:", objname);
d989 1
a989 1
			(void)printf(" %c%2s ", typeletter(sym->n_type),
d992 1
a992 1
			(void)printf(" %c ", typeletter(sym->n_type));
d1079 1
a1079 1
typeletter(unsigned int type)
d1081 6
a1086 1
	switch(SYMBOL_TYPE(type)) {
d1088 1
a1088 1
		return(IS_EXTERNAL(type) ? 'A' : 'a');
d1090 1
a1090 1
		return(IS_EXTERNAL(type) ? 'B' : 'b');
d1092 1
a1092 1
		return(IS_EXTERNAL(type) ? 'C' : 'c');
d1094 1
a1094 1
		return(IS_EXTERNAL(type) ? 'D' : 'd');
d1100 1
a1100 1
		return(IS_EXTERNAL(type) ? 'F' : 'W');
d1102 1
a1102 1
		return(IS_EXTERNAL(type) ? 'T' : 't');
d1104 1
a1104 1
		return(IS_EXTERNAL(type) ? 'I' : 'i');
d1106 1
a1106 1
		return(IS_EXTERNAL(type) ? 'S' : 's');
d1108 1
a1108 1
		return(IS_EXTERNAL(type) ? 'U' : 'u');
a1151 11
void *
emalloc(size_t size)
{
	char *p;

	/* NOSTRICT */
	if (p = malloc(size))
		return(p);
	err(1, NULL);
}

d1184 7
a1190 1
	(void)fprintf(stderr, "usage: nm [-aCgnopruw] [file ...]\n");
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.17 2003/04/05 17:15:06 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.17 2003/04/05 17:15:06 deraadt Exp $";
d101 1
a101 3
main(argc, argv)
	int argc;
	char **argv;
d171 1
a171 2
process_file(fname)
	char *fname;
d216 1
a216 3
show_archive(fname, fp)
	char *fname;
	FILE *fp;
d330 1
a330 3
show_objfile(objname, fp)
	char *objname;
	FILE *fp;
d463 1
a463 2
symname(sym)
	struct nlist *sym;
d476 1
a476 3
print_symbol(objname, sym)
	const char *objname;
	struct nlist *sym;
d513 1
a513 2
otherstring(sym)
	struct nlist *sym;
d535 1
a535 2
typestring(type)
	unsigned int type;
d589 1
a589 2
typeletter(type)
	unsigned int type;
d619 1
a619 2
fname(a0, b0)
	const void *a0, *b0;
d627 1
a627 2
rname(a0, b0)
	const void *a0, *b0;
d635 1
a635 2
value(a0, b0)
	const void *a0, *b0;
d658 1
a658 2
emalloc(size)
	size_t size;
d671 1
a671 1
pipe2cppfilt()
d698 1
a698 1
usage()
@


1.17
log
@snprintf; ok miod ho henning
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.16 2002/02/16 21:27:50 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.16 2002/02/16 21:27:50 millert Exp $";
@


1.16
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.15 2001/11/19 19:02:15 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.15 2001/11/19 19:02:15 mpech Exp $";
d262 4
a265 2
		if (print_file_each_line)
			p += sprintf(p, "%s:", fname);
@


1.15
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.14 2001/08/17 16:29:33 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.14 2001/08/17 16:29:33 espie Exp $";
d80 7
a86 7
int fname __P((const void *, const void *));
int rname __P((const void *, const void *));
int value __P((const void *, const void *));
int (*sfunc) __P((const void *, const void *)) = fname;
char *otherstring __P((struct nlist *));
char *typestring __P((unsigned int));
char typeletter __P((unsigned int));
d94 5
a98 5
void	*emalloc __P((size_t));
void	 pipe2cppfilt __P((void));
void	 usage __P((void));
char	*symname __P((struct nlist *));
void 	print_symbol __P((const char *, struct nlist *));
@


1.14
log
@Some missing protos. Use macros from <link.h> instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.13 2001/08/17 14:25:26 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.13 2001/08/17 14:25:26 espie Exp $";
d343 1
a343 1
	register int i, nnames, nrawnames;
@


1.13
log
@Show indirect symbols in -e mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.12 2001/08/16 15:45:05 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.12 2001/08/16 15:45:05 espie Exp $";
d62 1
d84 3
a489 2
	char *typestring(), typeletter(), *otherstring();

d512 1
a512 1
			    otherstring(sym->n_other));
a523 4
#define AUX_OBJECT 1
#define AUX_FUNC 2
#define BIND_WEAK 2

d525 2
a526 2
otherstring(other)
	u_char other;
a529 2
	u_char bindtype;
	u_char aux;
d533 1
a533 3
	bindtype = other >> 4;
	aux = other & 0x0f;
	if (bindtype == BIND_WEAK)
d535 1
a535 1
	if (aux == AUX_OBJECT)
d537 1
a537 1
	else if (aux == AUX_FUNC)
d549 1
a549 1
	register u_char type;
d604 1
a604 1
	u_char type;
@


1.12
log
@-e switch, show extra symbol information such as weak symbol status.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.11 2001/05/31 16:28:51 smart Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.11 2001/05/31 16:28:51 smart Exp $";
d79 4
a82 2
int fname(), rname(), value();
int (*sfunc)() = fname;
d93 2
d337 2
a338 1
	register struct nlist *names, *np;
d383 1
d426 10
d446 1
a446 11
		/*
		 * make n_un.n_name a character pointer by adding the string
		 * table's base to n_un.n_strx
		 *
		 * don't mess with zero offsets
		 */
		if (np->n_un.n_strx)
			np->n_un.n_name = stab + np->n_un.n_strx;
		else
			np->n_un.n_name = "";
		names[nnames++] = *np;
d451 1
a451 1
		qsort((char *)names, (size_t)nnames, sizeof(*names), sfunc);
d454 6
a459 2
	for (np = names, i = 0; i < nnames; np++, i++)
		print_symbol(objname, np);
d461 2
a462 1
	(void)free((char *)names);
d467 10
d481 1
d483 2
a484 2
	char *objname;
	register struct nlist *sym;
d497 3
a499 1
		if (SYMBOL_TYPE(sym->n_type) == N_UNDF)
d515 3
a517 3
	/* print the symbol's name */
	if (demangle && sym->n_un.n_name[0] == '_') 
		(void)puts(sym->n_un.n_name + 1);
d519 1
a519 1
		(void)puts(sym->n_un.n_name);
d639 1
d641 1
a641 1
	void *a0, *b0;
d643 1
a643 1
	struct nlist *a = a0, *b = b0;
d645 1
a645 1
	return(strcmp(a->n_un.n_name, b->n_un.n_name));
d648 1
d650 1
a650 1
	void *a0, *b0;
d652 1
a652 1
	struct nlist *a = a0, *b = b0;
d654 1
a654 1
	return(strcmp(b->n_un.n_name, a->n_un.n_name));
d657 1
d659 1
a659 1
	void *a0, *b0;
d661 1
a661 1
	register struct nlist *a = a0, *b = b0;
d663 2
a664 2
	if (SYMBOL_TYPE(a->n_type) == N_UNDF)
		if (SYMBOL_TYPE(b->n_type) == N_UNDF)
d668 1
a668 1
	else if (SYMBOL_TYPE(b->n_type) == N_UNDF)
d671 1
a671 1
		if (a->n_value == b->n_value)
d673 1
a673 1
		return(b->n_value > a->n_value ? 1 : -1);
d675 1
a675 1
		if (a->n_value == b->n_value)
d677 1
a677 1
		return(a->n_value > b->n_value ? 1 : -1);
@


1.11
log
@- remove erealloc() wrapper function
- standard function prototypes
- remove extraneous exit(1) after an err(1,...)

Shrinks source by 11 lines and executable by 22 bytes on i386.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.10 2001/02/18 21:45:09 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.10 2001/02/18 21:45:09 espie Exp $";
d75 1
d104 1
a104 1
	while ((ch = getopt(argc, argv, "aBCgnopruw")) != -1) {
d115 3
d464 1
a464 1
	char *typestring(), typeletter();
d484 3
d496 27
@


1.10
log
@-C support.
Recognize -B, for better gnu-nm compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.9 2000/11/10 15:33:12 provos Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.9 2000/11/10 15:33:12 provos Exp $";
d87 3
a89 3
void *emalloc(), *erealloc();

void pipe2cppfilt();
d265 2
a266 1
				name = (char *)erealloc(name, baselen+len);
a629 13
	exit(1);
}

void *
erealloc(p, size)
	void   *p;
	size_t size;
{
	/* NOSTRICT */
	if (p = realloc(p, size))
		return(p);
	err(1, NULL);
	exit(1);
d661 1
@


1.9
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.8 1999/05/10 16:14:07 espie Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.8 1999/05/10 16:14:07 espie Exp $";
d69 1
d89 2
d103 1
a103 1
	while ((ch = getopt(argc, argv, "agnopruw")) != -1) {
d108 6
d140 3
d465 1
a465 1
	 * handle undefined-only format separately (no space is
d468 13
a480 3
	if (print_only_undefined_symbols) {
		(void)puts(sym->n_un.n_name);
		return;
d483 3
a485 3
	/* print symbol's value */
	if (SYMBOL_TYPE(sym->n_type) == N_UNDF)
		(void)printf("        ");
d487 1
a487 11
		(void)printf("%08lx", sym->n_value);

	/* print type information */
	if (IS_DEBUGGER_SYMBOL(sym->n_type))
		(void)printf(" - %02x %04x %5s ", sym->n_other,
		    sym->n_desc&0xffff, typestring(sym->n_type));
	else
		(void)printf(" %c ", typeletter(sym->n_type));

	/* print the symbol's name */
	(void)puts(sym->n_un.n_name);
d644 29
d675 1
a675 1
	(void)fprintf(stderr, "usage: nm [-agnopruw] [file ...]\n");
@


1.8
log
@Fixes endianess problems with old a.out tools. This makes building
some cross toolchains possible.

This also changes some utilities's behavior slightly:
- nm, strip, size now handle any a.out format they know about.
- ranlib complains if it detects mixed archives (several object
formats for different boxes).

In the presence of mixed objects, you still have file, ranlib or ld
to prevent you from getting too confused...
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.7 1998/05/11 20:34:58 niklas Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.7 1998/05/11 20:34:58 niklas Exp $";
d453 1
a453 1
	 * handle undefined-only format seperately (no space is
@


1.7
log
@Build nm ok for cross-envs
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.6 1997/05/31 08:26:19 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.6 1997/05/31 08:26:19 deraadt Exp $";
d65 2
a67 4
#ifdef MID_MACHINE_OVERRIDE
#undef MID_MACHINE
#define MID_MACHINE MID_MACHINE_OVERRIDE
#endif
d80 1
d180 1
a181 6
#if (MID_MACHINE == MID_M68K)
	if (N_BADMAG(exec_head) || ((N_GETMID(exec_head) != MID_MACHINE) &&
	    (N_GETMID(exec_head) != MID_M68K4K))) {
#else
	if (N_BADMAG(exec_head) || N_GETMID(exec_head) != MID_MACHINE) {
#endif
d278 1
a278 1
		if (N_BADMAG(exec_head)) {
d337 4
a340 2
	/* stop if this is no valid object file */
	if (N_BADMAG(head)) {
d345 2
d366 1
d378 1
@


1.6
log
@warn instead of warnx; kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.5 1997/04/04 18:27:07 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.5 1997/04/04 18:27:07 deraadt Exp $";
d65 5
@


1.5
log
@check MID field like strip(1) does; PR#149, mickey; fix by me
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.4 1997/01/15 23:42:59 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.4 1997/01/15 23:42:59 millert Exp $";
d158 1
a158 1
		warnx("cannot read %s", fname);
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.3 1996/06/26 05:37:33 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.3 1996/06/26 05:37:33 deraadt Exp $";
d53 1
d177 6
a182 1
	if (N_BADMAG(exec_head)) {
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: nm.c,v 1.7 1996/01/14 23:04:03 pk Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: nm.c,v 1.7 1996/01/14 23:04:03 pk Exp $";
d95 1
a95 1
	while ((ch = getopt(argc, argv, "agnopruw")) != EOF) {
@


1.2
log
@from netbsd; Use err() & warn()
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: nm.c,v 1.7 1996/01/14 23:04:03 pk Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: nm.c,v 1.6 1995/08/31 23:42:00 jtc Exp $	*/
d49 1
a49 1
static char rcsid[] = "$NetBSD: nm.c,v 1.6 1995/08/31 23:42:00 jtc Exp $";
d58 1
a58 1
#include <errno.h>
d156 1
a156 1
		(void)fprintf(stderr, "nm: cannot read %s.\n", fname);
d168 1
a168 1
		(void)fprintf(stderr, "nm: %s: bad format.\n", fname);
d178 1
a178 2
			(void)fprintf(stderr,
			    "nm: %s: not object file or archive.\n", fname);
d214 1
a214 2
			(void)fprintf(stderr,
			    "nm: %s: bad format archive header", fname);
d252 1
a252 2
				(void)fprintf(stderr,
				    "nm: %s: premature EOF.\n", name);
d267 1
a267 1
			(void)fprintf(stderr, "nm: %s: premature EOF.\n", name);
d274 1
a274 2
				(void)fprintf(stderr,
				    "nm: %s: bad format.\n", name);
d278 1
a278 2
			(void)fseek(fp, (long)-sizeof(exec_head),
			    SEEK_CUR);
d291 1
a291 2
			(void)fprintf(stderr,
			    "nm: %s: %s\n", fname, strerror(errno));
d318 1
a318 2
		(void)fprintf(stderr,
		    "nm: %s: cannot read header.\n", objname);
d327 1
a327 2
		(void)fprintf(stderr,
		    "nm: %s: %s\n", objname, strerror(errno));
d333 1
a333 2
		(void)fprintf(stderr,
		    "nm: %s: bad format.\n", objname);
d339 1
a339 2
		(void)fprintf(stderr,
		    "nm: %s: no name list.\n", objname);
d344 1
a344 2
		(void)fprintf(stderr,
		    "nm: %s: %s\n", objname, strerror(errno));
d352 1
a352 2
		(void)fprintf(stderr,
		    "nm: %s: cannot read symbol table.\n", objname);
d363 1
a363 2
		(void)fprintf(stderr,
		    "nm: %s: cannot read stab size.\n", objname);
d375 1
a375 2
		(void)fprintf(stderr,
		    "nm: %s: stab truncated..\n", objname);
d604 1
a604 1
	(void)fprintf(stderr, "nm: %s\n", strerror(errno));
d616 1
a616 1
	(void)fprintf(stderr, "nm: %s\n", strerror(errno));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
