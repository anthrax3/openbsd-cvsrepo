head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.6
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.4
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.20.0.6
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.4
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.34
date	2015.12.09.19.28.34;	author mmcc;	state Exp;
branches;
next	1.33;
commitid	33ajac6ZyR1t2xod;

1.33
date	2015.08.13.19.13.28;	author miod;	state Exp;
branches;
next	1.32;
commitid	QZhVyD7WxxvCXibW;

1.32
date	2015.06.23.15.16.34;	author semarie;	state Exp;
branches;
next	1.31;
commitid	PQPTWpHw6X75ubEO;

1.31
date	2015.06.23.15.13.29;	author semarie;	state Exp;
branches;
next	1.30;
commitid	ofxPLI9PxiLe9GOZ;

1.30
date	2015.06.23.15.02.58;	author semarie;	state Exp;
branches;
next	1.29;
commitid	Qfmm3ww0sj5ozCMw;

1.29
date	2015.06.23.13.43.08;	author semarie;	state Exp;
branches;
next	1.28;
commitid	SmicACKmFhJbWo9o;

1.28
date	2015.05.17.20.19.08;	author guenther;	state Exp;
branches;
next	1.27;
commitid	CuoIx9MPLElIHvnd;

1.27
date	2015.04.09.04.46.18;	author guenther;	state Exp;
branches;
next	1.26;
commitid	D8uy8dZNh36bsfBL;

1.26
date	2015.02.06.23.21.59;	author millert;	state Exp;
branches;
next	1.25;
commitid	STdsVrA5MGLlnbLm;

1.25
date	2015.01.19.20.25.36;	author miod;	state Exp;
branches;
next	1.24;
commitid	uHkczPQ0EuQrBclO;

1.24
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	Uu5nFG3wCl0LACBb;

1.23
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.13.06.37.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.30.21.26.09;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.28.19.58.14;	author uwe;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.27.23.59.41;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.02.15.19.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.18.19.03.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.08.03.50.49;	author ray;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.07.10.20.40;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.30.14.34.13;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.19.19.37.29;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.11.04.50.47;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.10.16.41.18;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.09.20.26.57;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.09.20.17.52;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.20.04.42.51;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.19.19.23.08;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.04.23.07.53;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.30.15.35.51;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.30.15.29.44;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.30.15.12.38;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.13.17.32.32;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.05.01.27.22;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/*	$OpenBSD: elf.c,v 1.33 2015/08/13 19:13:28 miod Exp $	*/

/*
 * Copyright (c) 2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/mman.h>
#include <unistd.h>
#include <a.out.h>
#include <elf_abi.h>
#include <errno.h>
#include <err.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "util.h"
#include "elfuncs.h"

#if ELFSIZE == 32
#define	swap_addr	swap32
#define	swap_off	swap32
#define	swap_sword	swap32
#define	swap_word	swap32
#define	swap_sxword	swap32
#define	swap_xword	swap32
#define	swap_half	swap16
#define	swap_quarter	swap16
#define	elf_fix_header	elf32_fix_header
#define	elf_load_shdrs	elf32_load_shdrs
#define	elf_load_phdrs	elf32_load_phdrs
#define	elf_fix_shdrs	elf32_fix_shdrs
#define	elf_fix_phdrs	elf32_fix_phdrs
#define	elf_fix_sym	elf32_fix_sym
#define	elf_size	elf32_size
#define	elf_symloadx	elf32_symloadx
#define	elf_symload	elf32_symload
#define	elf2nlist	elf32_2nlist
#define	elf_shn2type	elf32_shn2type
#elif ELFSIZE == 64
#define	swap_addr	swap64
#define	swap_off	swap64
#ifdef __alpha__
#define	swap_sword	swap64
#define	swap_word	swap64
#else
#define	swap_sword	swap32
#define	swap_word	swap32
#endif
#define	swap_sxword	swap64
#define	swap_xword	swap64
#define	swap_half	swap64
#define	swap_quarter	swap16
#define	elf_fix_header	elf64_fix_header
#define	elf_load_shdrs	elf64_load_shdrs
#define	elf_load_phdrs	elf64_load_phdrs
#define	elf_fix_shdrs	elf64_fix_shdrs
#define	elf_fix_phdrs	elf64_fix_phdrs
#define	elf_fix_sym	elf64_fix_sym
#define	elf_size	elf64_size
#define	elf_symloadx	elf64_symloadx
#define	elf_symload	elf64_symload
#define	elf2nlist	elf64_2nlist
#define	elf_shn2type	elf64_shn2type
#else
#error "Unsupported ELF class"
#endif

#define	ELF_SDATA	".sdata"
#define	ELF_TDATA	".tdata"
#define	ELF_SBSS	".sbss"
#define	ELF_TBSS	".tbss"
#define	ELF_PLT		".plt"

#ifndef	SHN_MIPS_ACOMMON
#define	SHN_MIPS_ACOMMON	SHN_LOPROC + 0
#endif
#ifndef	SHN_MIPS_TEXT
#define	SHN_MIPS_TEXT		SHN_LOPROC + 1
#endif
#ifndef	SHN_MIPS_DATA
#define	SHN_MIPS_DATA		SHN_LOPROC + 2
#endif
#ifndef	SHN_MIPS_SUNDEFINED
#define	SHN_MIPS_SUNDEFINED	SHN_LOPROC + 4
#endif
#ifndef	SHN_MIPS_SCOMMON
#define	SHN_MIPS_SCOMMON	SHN_LOPROC + 3
#endif

#ifndef	STT_PARISC_MILLI
#define	STT_PARISC_MILLI	STT_LOPROC + 0
#endif

int elf_shn2type(Elf_Ehdr *, u_int, const char *);
int elf2nlist(Elf_Sym *, Elf_Ehdr *, Elf_Shdr *, char *, struct xnlist *);

int
elf_fix_header(Elf_Ehdr *eh)
{
	/* nothing to do */
	if (eh->e_ident[EI_DATA] == ELF_TARG_DATA)
		return (0);

	eh->e_type = swap16(eh->e_type);
	eh->e_machine = swap16(eh->e_machine);
	eh->e_version = swap32(eh->e_version);
	eh->e_entry = swap_addr(eh->e_entry);
	eh->e_phoff = swap_off(eh->e_phoff);
	eh->e_shoff = swap_off(eh->e_shoff);
	eh->e_flags = swap32(eh->e_flags);
	eh->e_ehsize = swap16(eh->e_ehsize);
	eh->e_phentsize = swap16(eh->e_phentsize);
	eh->e_phnum = swap16(eh->e_phnum);
	eh->e_shentsize = swap16(eh->e_shentsize);
	eh->e_shnum = swap16(eh->e_shnum);
	eh->e_shstrndx = swap16(eh->e_shstrndx);

	return (1);
}

Elf_Shdr *
elf_load_shdrs(const char *name, FILE *fp, off_t foff, Elf_Ehdr *head)
{
	Elf_Shdr *shdr;

	elf_fix_header(head);

	if (head->e_shnum == 0) {
		warnx("%s: no section header table", name);
		return (NULL);
	}

	if (head->e_shstrndx >= head->e_shnum) {
		warnx("%s: inconsistent section header table", name);
		return (NULL);
	}

	if (head->e_shentsize < sizeof(Elf_Shdr)) {
		warnx("%s: inconsistent section header size", name);
		return (NULL);
	}

	if ((shdr = calloc(head->e_shnum, head->e_shentsize)) == NULL) {
		warn("%s: malloc shdr", name);
		return (NULL);
	}

	if (fseeko(fp, foff + head->e_shoff, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(shdr);
		return (NULL);
	}

	if (fread(shdr, head->e_shentsize, head->e_shnum, fp) != head->e_shnum) {
		warnx("%s: premature EOF", name);
		free(shdr);
		return (NULL);
	}

	elf_fix_shdrs(head, shdr);
	return (shdr);
}

Elf_Phdr *
elf_load_phdrs(const char *name, FILE *fp, off_t foff, Elf_Ehdr *head)
{
	Elf_Phdr *phdr;

	if ((phdr = calloc(head->e_phentsize, head->e_phnum)) == NULL) {
		warn("%s: malloc phdr", name);
		return (NULL);
	}

	if (fseeko(fp, foff + head->e_phoff, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(phdr);
		return (NULL);
	}

	if (fread(phdr, head->e_phentsize, head->e_phnum, fp) != head->e_phnum) {
		warnx("%s: premature EOF", name);
		free(phdr);
		return (NULL);
	}

	elf_fix_phdrs(head, phdr);
	return (phdr);
}

int
elf_fix_shdrs(Elf_Ehdr *eh, Elf_Shdr *shdr)
{
	int i;

	/* nothing to do */
	if (eh->e_ident[EI_DATA] == ELF_TARG_DATA)
		return (0);

	for (i = eh->e_shnum; i--; shdr++) {
		shdr->sh_name = swap32(shdr->sh_name);
		shdr->sh_type = swap32(shdr->sh_type);
		shdr->sh_flags = swap_xword(shdr->sh_flags);
		shdr->sh_addr = swap_addr(shdr->sh_addr);
		shdr->sh_offset = swap_off(shdr->sh_offset);
		shdr->sh_size = swap_xword(shdr->sh_size);
		shdr->sh_link = swap32(shdr->sh_link);
		shdr->sh_info = swap32(shdr->sh_info);
		shdr->sh_addralign = swap_xword(shdr->sh_addralign);
		shdr->sh_entsize = swap_xword(shdr->sh_entsize);
	}

	return (1);
}

int
elf_fix_phdrs(Elf_Ehdr *eh, Elf_Phdr *phdr)
{
	int i;

	/* nothing to do */
	if (eh->e_ident[EI_DATA] == ELF_TARG_DATA)
		return (0);

	for (i = eh->e_phnum; i--; phdr++) {
		phdr->p_type = swap32(phdr->p_type);
		phdr->p_flags = swap32(phdr->p_flags);
		phdr->p_offset = swap_off(phdr->p_offset);
		phdr->p_vaddr = swap_addr(phdr->p_vaddr);
		phdr->p_paddr = swap_addr(phdr->p_paddr);
		phdr->p_filesz = swap_xword(phdr->p_filesz);
		phdr->p_memsz = swap_xword(phdr->p_memsz);
		phdr->p_align = swap_xword(phdr->p_align);
	}

	return (1);
}

int
elf_fix_sym(Elf_Ehdr *eh, Elf_Sym *sym)
{
	/* nothing to do */
	if (eh->e_ident[EI_DATA] == ELF_TARG_DATA)
		return (0);

	sym->st_name = swap32(sym->st_name);
	sym->st_shndx = swap16(sym->st_shndx);
	sym->st_value = swap_addr(sym->st_value);
	sym->st_size = swap_xword(sym->st_size);

	return (1);
}

int
elf_shn2type(Elf_Ehdr *eh, u_int shn, const char *sn)
{
	switch (shn) {
	case SHN_MIPS_SUNDEFINED:
		if (eh->e_machine == EM_MIPS)
			return (N_UNDF | N_EXT);
		break;

	case SHN_UNDEF:
		return (N_UNDF | N_EXT);

	case SHN_ABS:
		return (N_ABS);

	case SHN_MIPS_ACOMMON:
		if (eh->e_machine == EM_MIPS)
			return (N_COMM);
		break;

	case SHN_MIPS_SCOMMON:
		if (eh->e_machine == EM_MIPS)
			return (N_COMM);
		break;

	case SHN_COMMON:
		return (N_COMM);

	case SHN_MIPS_TEXT:
		if (eh->e_machine == EM_MIPS)
			return (N_TEXT);
		break;

	case SHN_MIPS_DATA:
		if (eh->e_machine == EM_MIPS)
			return (N_DATA);
		break;

	default:
		/* TODO: beyond 8 a table-driven binsearch should be used */
		if (sn == NULL)
			return (-1);
		else if (!strcmp(sn, ELF_TEXT))
			return (N_TEXT);
		else if (!strcmp(sn, ELF_RODATA))
			return (N_SIZE);
		else if (!strcmp(sn, ELF_DATA))
			return (N_DATA);
		else if (!strcmp(sn, ELF_SDATA))
			return (N_DATA);
		else if (!strcmp(sn, ELF_TDATA))
			return (N_DATA);
		else if (!strcmp(sn, ELF_BSS))
			return (N_BSS);
		else if (!strcmp(sn, ELF_SBSS))
			return (N_BSS);
		else if (!strcmp(sn, ELF_TBSS))
			return (N_BSS);
		else if (!strncmp(sn, ELF_GOT, sizeof(ELF_GOT) - 1))
			return (N_DATA);
		else if (!strncmp(sn, ELF_PLT, sizeof(ELF_PLT) - 1))
			return (N_DATA);
	}

	return (-1);
}

/*
 * Devise xnlist's type from Elf_Sym.
 * XXX this task is done as well in libc and kvm_mkdb.
 */
int
elf2nlist(Elf_Sym *sym, Elf_Ehdr *eh, Elf_Shdr *shdr, char *shstr,
    struct xnlist *np)
{
	u_char stt;
	const char *sn;
	int type;

	if (sym->st_shndx < eh->e_shnum)
		sn = shstr + shdr[sym->st_shndx].sh_name;
	else
		sn = NULL;
#if 0
	{
		extern char *stab;
		printf("%d:%s %d %d %s\n", sym->st_shndx, sn? sn : "",
		    ELF_ST_TYPE(sym->st_info), ELF_ST_BIND(sym->st_info),
		    stab + sym->st_name);
	}
#endif

	switch (stt = ELF_ST_TYPE(sym->st_info)) {
	case STT_NOTYPE:
	case STT_OBJECT:
	case STT_TLS:
		type = elf_shn2type(eh, sym->st_shndx, sn);
		if (type < 0) {
			if (sn == NULL)
				np->nl.n_other = '?';
			else
				np->nl.n_type = stt == STT_NOTYPE ?
				    N_COMM : N_DATA;
		} else {
			/* a hack for .rodata check (; */
			if (type == N_SIZE) {
				np->nl.n_type = N_DATA;
				np->nl.n_other = 'r';
			} else
				np->nl.n_type = type;
		}
		if (ELF_ST_BIND(sym->st_info) == STB_WEAK)
			np->nl.n_other = 'W';
		break;

	case STT_FUNC:
		type = elf_shn2type(eh, sym->st_shndx, NULL);
		np->nl.n_type = type < 0? N_TEXT : type;
		if (ELF_ST_BIND(sym->st_info) == STB_WEAK) {
			np->nl.n_other = 'W';
		} else if (sn != NULL && *sn != 0 &&
		    strcmp(sn, ELF_INIT) &&
		    strcmp(sn, ELF_TEXT) &&
		    strcmp(sn, ELF_FINI))	/* XXX GNU compat */
			np->nl.n_other = '?';
		break;

	case STT_SECTION:
		type = elf_shn2type(eh, sym->st_shndx, NULL);
		if (type < 0)
			np->nl.n_other = '?';
		else
			np->nl.n_type = type;
		break;

	case STT_FILE:
		np->nl.n_type = N_FN | N_EXT;
		break;

	case STT_PARISC_MILLI:
		if (eh->e_machine == EM_PARISC)
			np->nl.n_type = N_TEXT;
		else
			np->nl.n_other = '?';
		break;

	default:
		np->nl.n_other = '?';
		break;
	}
	if (np->nl.n_type != N_UNDF && ELF_ST_BIND(sym->st_info) != STB_LOCAL) {
		np->nl.n_type |= N_EXT;
		if (np->nl.n_other)
			np->nl.n_other = toupper((unsigned char)np->nl.n_other);
	}

	return (0);
}

int
elf_size(Elf_Ehdr *head, Elf_Shdr *shdr,
    u_long *ptext, u_long *pdata, u_long *pbss)
{
	int i;

	*ptext = *pdata = *pbss = 0;

	for (i = 0; i < head->e_shnum; i++) {
		if (!(shdr[i].sh_flags & SHF_ALLOC))
			;
		else if (shdr[i].sh_flags & SHF_EXECINSTR ||
		    !(shdr[i].sh_flags & SHF_WRITE))
			*ptext += shdr[i].sh_size;
		else if (shdr[i].sh_type == SHT_NOBITS)
			*pbss += shdr[i].sh_size;
		else
			*pdata += shdr[i].sh_size;
	}

	return (0);
}

int
elf_symloadx(const char *name, FILE *fp, off_t foff, Elf_Ehdr *eh,
    Elf_Shdr *shdr, char *shstr, long shstrsize, struct xnlist **pnames,
    struct xnlist ***psnames, size_t *pstabsize, int *pnrawnames,
    const char *strtab, const char *symtab)
{
	long symsize;
	struct xnlist *np;
	Elf_Sym sbuf;
	int i;

	for (i = 0; i < eh->e_shnum; i++) {
		if (shdr[i].sh_name >= shstrsize) {
			warnx("%s: corrupt file", name);
			return (1);
		}
		if (!strcmp(shstr + shdr[i].sh_name, strtab)) {
			*pstabsize = shdr[i].sh_size;
			if (*pstabsize > SIZE_MAX) {
				warnx("%s: corrupt file", name);
				return (1);
			}

			MMAP(stab, *pstabsize, PROT_READ, MAP_PRIVATE|MAP_FILE,
			    fileno(fp), foff + shdr[i].sh_offset);
			if (stab == MAP_FAILED)
				return (1);
		}
	}
	for (i = 0; i < eh->e_shnum; i++) {
		if (!strcmp(shstr + shdr[i].sh_name, symtab)) {
			symsize = shdr[i].sh_size;
			if (fseeko(fp, foff + shdr[i].sh_offset, SEEK_SET)) {
				warn("%s: fseeko", name);
				if (stab)
					MUNMAP(stab, *pstabsize);
				return (1);
			}

			*pnrawnames = symsize / sizeof(sbuf);
			if ((*pnames = calloc(*pnrawnames, sizeof(*np))) == NULL) {
				warn("%s: malloc names", name);
				if (stab)
					MUNMAP(stab, *pstabsize);
				*pnrawnames = 0;
				return (1);
			}
			if ((*psnames = calloc(*pnrawnames, sizeof(np))) == NULL) {
				warn("%s: malloc snames", name);
				if (stab)
					MUNMAP(stab, *pstabsize);
				free(*pnames);
				*pnames = NULL;
				*pnrawnames = 0;
				return (1);
			}

			for (np = *pnames; symsize > 0; symsize -= sizeof(sbuf)) {
				if (fread(&sbuf, 1, sizeof(sbuf),
				    fp) != sizeof(sbuf)) {
					warn("%s: read symbol", name);
					if (stab)
						MUNMAP(stab, *pstabsize);
					free(*pnames);
					free(*psnames);
					*pnames = NULL;
					*psnames = NULL;
					*pnrawnames = 0;
					return (1);
				}

				elf_fix_sym(eh, &sbuf);

				if (!sbuf.st_name ||
				    sbuf.st_name > *pstabsize)
					continue;

				elf2nlist(&sbuf, eh, shdr, shstr, np);
				np->nl.n_value = sbuf.st_value;
				np->nl.n_un.n_strx = sbuf.st_name;
				np->n_size = sbuf.st_size;
				np++;
			}
			*pnrawnames = np - *pnames;
		}
	}
	return (0);
}

int
elf_symload(const char *name, FILE *fp, off_t foff, Elf_Ehdr *eh,
    Elf_Shdr *shdr, struct xnlist **pnames, struct xnlist ***psnames,
    size_t *pstabsize, int *pnrawnames)
{
	long shstrsize;
	char *shstr;

	shstrsize = shdr[eh->e_shstrndx].sh_size;
	if (shstrsize == 0) {
		warnx("%s: no name list", name);
		return (1);
	}

	if ((shstr = malloc(shstrsize)) == NULL) {
		warn("%s: malloc shsrt", name);
		return (1);
	}

	if (fseeko(fp, foff + shdr[eh->e_shstrndx].sh_offset, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(shstr);
		return (1);
	}

	if (fread(shstr, 1, shstrsize, fp) != shstrsize) {
		warnx("%s: premature EOF", name);
		free(shstr);
		return(1);
	}

	stab = NULL;
	*pnames = NULL; *psnames = NULL; *pnrawnames = 0;
	if (!dynamic_only) {
		elf_symloadx(name, fp, foff, eh, shdr, shstr, shstrsize, pnames,
		    psnames, pstabsize, pnrawnames, ELF_STRTAB, ELF_SYMTAB);
	}
	if (stab == NULL) {
		elf_symloadx(name, fp, foff, eh, shdr, shstr, shstrsize, pnames,
		    psnames, pstabsize, pnrawnames, ELF_DYNSTR, ELF_DYNSYM);
	}

	free(shstr);
	if (stab == NULL) {
		warnx("%s: no name list", name);
		free(*pnames);
		free(*psnames);
		return (1);
	}

	return (0);
}
@


1.33
log
@Grow -P (POSIX output) and -t (POSIX output radix) support. Several 3rd-party
software depend upon this.

Requested by feinerer@@, ok millert@@; manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.32 2015/06/23 15:16:34 semarie Exp $	*/
d593 2
a594 4
		if (*pnames)
			free(*pnames);
		if (*psnames)
			free(*psnames);
@


1.32
log
@This patch ensure that when an error is detected, the freed variables in
elf_symloadx() are reinitialised.

Else show_file() in nm.c will used these variables, even if they has
just been freed. (nm.c +689).

Problem found by afl.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.31 2015/06/23 15:13:29 semarie Exp $	*/
d40 1
a41 1
#include "util.h"
d119 1
a119 1
int elf2nlist(Elf_Sym *, Elf_Ehdr *, Elf_Shdr *, char *, struct nlist *);
d345 1
a345 1
 * Devise nlist's type from Elf_Sym.
d349 2
a350 1
elf2nlist(Elf_Sym *sym, Elf_Ehdr *eh, Elf_Shdr *shdr, char *shstr, struct nlist *np)
d376 1
a376 1
				np->n_other = '?';
d378 2
a379 1
				np->n_type = stt == STT_NOTYPE? N_COMM : N_DATA;
d383 2
a384 2
				np->n_type = N_DATA;
				np->n_other = 'r';
d386 1
a386 1
				np->n_type = type;
d389 1
a389 1
			np->n_other = 'W';
d394 1
a394 1
		np->n_type = type < 0? N_TEXT : type;
d396 1
a396 1
			np->n_other = 'W';
d401 1
a401 1
			np->n_other = '?';
d407 1
a407 1
			np->n_other = '?';
d409 1
a409 1
			np->n_type = type;
d413 1
a413 1
		np->n_type = N_FN | N_EXT;
d418 1
a418 1
			np->n_type = N_TEXT;
d420 1
a420 1
			np->n_other = '?';
d424 1
a424 1
		np->n_other = '?';
d427 4
a430 4
	if (np->n_type != N_UNDF && ELF_ST_BIND(sym->st_info) != STB_LOCAL) {
		np->n_type |= N_EXT;
		if (np->n_other)
			np->n_other = toupper((unsigned char)np->n_other);
d461 2
a462 2
    Elf_Shdr *shdr, char *shstr, long shstrsize, struct nlist **pnames,
    struct nlist ***psnames, size_t *pstabsize, int *pnrawnames,
d466 1
a466 1
	struct nlist *np;
d537 3
a539 2
				np->n_value = sbuf.st_value;
				np->n_un.n_strx = sbuf.st_name;
d550 1
a550 1
    Elf_Shdr *shdr, struct nlist **pnames, struct nlist ***psnames,
@


1.31
log
@This patch ensure that e_shentsize (sections header's size in bytes) is
big enough to fill at least one Elf_Shdr.

While here, inverts calloc() arguments to be calloc(nmemb, size),
according to fread() call after.

This problem was found with afl, with e_shentsize=1.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.30 2015/06/23 15:02:58 semarie Exp $	*/
d501 1
d509 2
d522 3
@


1.30
log
@corrects a read after bound that occurs in strcmp (line just
after the added bound check).

Found with afl.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.29 2015/06/23 13:43:08 semarie Exp $	*/
d162 6
a167 1
	if ((shdr = calloc(head->e_shentsize, head->e_shnum)) == NULL) {
@


1.29
log
@add some check before accessing data:
 - if section header table is be present
 - consistency of section header table size

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.28 2015/05/17 20:19:08 guenther Exp $	*/
d454 1
a454 1
    Elf_Shdr *shdr, char *shstr, struct nlist **pnames,
d464 4
d568 1
a568 1
		elf_symloadx(name, fp, foff, eh, shdr, shstr, pnames,
d572 1
a572 1
		elf_symloadx(name, fp, foff, eh, shdr, shstr, pnames,
@


1.28
log
@Add -D option for displaying the dynamic symbol table

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.27 2015/04/09 04:46:18 guenther Exp $	*/
d151 10
@


1.27
log
@ELF weak symbols are _not_ like a.out indirect symbols.  Nothing in ELF is,
so remove N_INDR handling.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.26 2015/02/06 23:21:59 millert Exp $	*/
d553 4
a556 2
	elf_symloadx(name, fp, foff, eh, shdr, shstr, pnames,
	    psnames, pstabsize, pnrawnames, ELF_STRTAB, ELF_SYMTAB);
@


1.26
log
@SIZE_MAX is standard, we should be using it in preference to the
obsolete SIZE_T_MAX.  OK miod@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.25 2015/01/19 20:25:36 miod Exp $	*/
a378 1
			np->n_type = N_INDR;
@


1.25
log
@Missing initialization; tjenahej@@speedmail.se
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.24 2015/01/16 06:40:10 deraadt Exp $	*/
d35 1
a38 1
#include <limits.h>
d457 1
a457 1
			if (*pstabsize > SIZE_T_MAX) {
@


1.24
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.23 2013/11/26 13:19:07 deraadt Exp $	*/
d553 1
a553 1
	*pnames = NULL; *psnames = NULL;
@


1.23
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.22 2013/11/13 06:37:24 deraadt Exp $	*/
a28 1
#include <sys/param.h>
d38 1
@


1.22
log
@proto and such cleanup
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.21 2013/03/30 21:26:09 miod Exp $	*/
d414 1
a414 1
			np->n_other = toupper(np->n_other);
@


1.21
log
@Correctly report `weak' status of non-function symbols. Makes nm agree with
objdump -t on, say, _DYNAMIC in libpthread.
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.20 2011/09/28 19:58:14 uwe Exp $	*/
d118 3
d518 1
a518 1

@


1.20
log
@Support symbols in .tbss and .tdata ELF sections

With this change nm(1) prints the expected symbol type ('B' or 'D')
for variables in the .tbss and .tdata sections respectively, instead
of '?'.  This would be what binutils do for non-automatic variables
that are marked as thread-local with the __thread attribute in GCC.

help and ok miod@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.19 2009/10/27 23:59:41 deraadt Exp $	*/
d344 3
a346 2
		printf("%d:%s %d %s\n", sym->st_shndx, sn? sn : "",
		    ELF_ST_TYPE(sym->st_info), stab + sym->st_name);
d368 2
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.18 2007/09/02 15:19:33 deraadt Exp $	*/
d93 1
d95 1
d298 1
a298 1
		/* beyond 8 a table-driven binsearch shall be used */
d309 2
d315 2
d352 1
@


1.18
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.17 2007/04/18 19:03:04 miod Exp $	*/
a27 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: elf.c,v 1.17 2007/04/18 19:03:04 miod Exp $";
#endif /* not lint */
@


1.17
log
@Fix a NULL dereference if the symbol table size is zero; ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.16 2007/02/08 03:50:49 ray Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: elf.c,v 1.16 2007/02/08 03:50:49 ray Exp $";
d151 1
a151 1
	if ((shdr = malloc(head->e_shentsize * head->e_shnum)) == NULL) {
d177 1
a177 1
	if ((phdr = malloc(head->e_phentsize * head->e_phnum)) == NULL) {
d476 1
a476 1
			if ((*psnames = malloc(*pnrawnames * sizeof(np))) == NULL) {
@


1.16
log
@Do all allocation and deallocation of shstr in elf_symload() to
prevent double-freeing shstr.

Also don't free known NULL values (*pnames and *psnames).

Initially inspired by Charles Longeau's first diff to tech@@; he
later sent a second diff to tech@@ nearly identical to this commit.
Freaky.

OK mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.15 2007/02/07 10:20:40 mickey Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: elf.c,v 1.15 2007/02/07 10:20:40 mickey Exp $";
d521 5
@


1.15
log
@check st_name validity also check for overflow and not only for zero; found by Charles Longeau <chl@@tuxfamily.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.14 2006/09/30 14:34:13 kettenis Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: elf.c,v 1.14 2006/09/30 14:34:13 kettenis Exp $";
a449 1
				free(shstr);
d455 1
a455 2
			if (stab == MAP_FAILED) {
				free(shstr);
a456 1
			}
a465 1
				free(shstr);
a473 2
				free(*pnames);
				free(shstr);
a479 1
				free(shstr);
a480 1
				free(*psnames);
a489 1
					free(shstr);
@


1.14
log
@Some fixes for running nm on ELF binaries.
- Fix printing the symbol type of undefined symbols.
- Fall back onto the dynamic symbol table if the normal symbol table is not
  available (i.e. if the binary has been stripped).

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.13 2005/01/19 19:37:29 grange Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: elf.c,v 1.13 2005/01/19 19:37:29 grange Exp $";
d506 2
a507 1
				if (!sbuf.st_name)
@


1.13
log
@Add elf{32,64}_load_phdrs() for loading program headers.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.12 2004/10/11 04:50:47 mickey Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD: elf.c,v 1.12 2004/10/11 04:50:47 mickey Exp $";
d63 1
d88 1
d372 1
a372 1
		} else if (sn != NULL &&
d435 4
a438 3
elf_symload(const char *name, FILE *fp, off_t foff, Elf_Ehdr *eh,
    Elf_Shdr *shdr, struct nlist **pnames, struct nlist ***psnames,
    size_t *pstabsize, int *pnrawnames)
d440 1
a440 1
	long symsize, shstrsize;
a442 1
	char *shstr;
a444 20
	shstrsize = shdr[eh->e_shstrndx].sh_size;
	if ((shstr = malloc(shstrsize)) == NULL) {
		warn("%s: malloc shsrt", name);
		return (1);
	}

	if (fseeko(fp, foff + shdr[eh->e_shstrndx].sh_offset, SEEK_SET)) {
		warn("%s: fseeko", name);
		free(shstr);
		return (1);
	}

	if (fread(shstr, 1, shstrsize, fp) != shstrsize) {
		warnx("%s: premature EOF", name);
		free(shstr);
		return(1);
	}

	stab = NULL;
	*pnames = NULL; *psnames = NULL;
d446 1
a446 1
		if (!strcmp(shstr + shdr[i].sh_name, ELF_STRTAB)) {
d463 1
a463 1
		if (!strcmp(shstr + shdr[i].sh_name, ELF_SYMTAB)) {
d516 37
@


1.12
log
@add rcisd[]
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.11 2004/10/10 16:41:18 mickey Exp $	*/
d30 1
a30 1
static const char rcsid[] = "$OpenBSD$";
d58 1
d82 1
d168 26
@


1.11
log
@parse the cpu-specific ids based on the e_machine
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.10 2004/10/09 20:26:57 mickey Exp $	*/
d28 4
@


1.10
log
@move out elf code into elf.c and generate 32 and 64 versions of it;
allow operation on size-mixed host-target as well as ensianess for
both a.out and elf (though a.out 64bit probably does not exist ;)
tested on hppa-sparc64-i386-vax intermixen
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.9 2004/10/09 20:17:52 mickey Exp $	*/
d92 20
d228 1
a228 1
elf_shn2type(u_int shn, const char *sn)
a230 1
#ifdef SHN_MIPS_SUNDEFINED
d232 4
a235 1
#endif
d238 1
d241 1
a241 1
#ifdef SHN_MIPS_ACOMMON
d243 4
a246 2
#endif
#ifdef SHN_MIPS_SCOMMON
d248 4
a251 1
#endif
d254 1
a254 1
#ifdef SHN_MIPS_TEXT
d256 4
a259 3
		return (N_TEXT);
#endif
#ifdef SHN_MIPS_DATA
d261 4
a264 2
		return (N_DATA);
#endif
a284 1
		return (-1);
d286 2
d316 1
a316 1
		type = elf_shn2type(sym->st_shndx, sn);
d333 1
a333 1
		type = elf_shn2type(sym->st_shndx, NULL);
d346 1
a346 1
		type = elf_shn2type(sym->st_shndx, NULL);
a356 2
	/* XXX how about cross-nm then ? */
#ifdef STT_PARISC_MILLI
d358 4
a361 1
		np->n_type = N_TEXT;
d363 1
a363 1
#endif
@


1.9
log
@factor out code for mapping section index into nlist type
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.8 2004/08/20 04:42:51 mickey Exp $	*/
d29 15
a43 1
#if ELF_TARG_CLASS == ELFCLASS32
d52 10
a61 1
#elif ELF_TARG_CLASS == ELFCLASS64
d75 9
d116 28
d339 140
@


1.8
log
@grok STT_SECTION and beautify STT_OBJECT
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.7 2004/08/19 19:23:08 mickey Exp $	*/
d56 1
d147 51
d205 1
d207 1
d212 1
a212 1
		sn = "";
d216 1
a216 1
		printf("%d:%s %d %s\n", sym->st_shndx, sn,
d220 2
a221 1
	switch(ELF_ST_TYPE(sym->st_info)) {
d223 10
a232 19
		switch (sym->st_shndx) {
		case SHN_UNDEF:
			np->n_type = N_UNDF | N_EXT;
			break;
		case SHN_ABS:
			np->n_type = N_ABS;
			break;
		case SHN_COMMON:
			np->n_type = N_COMM;
			break;
		default:
			if (sym->st_shndx >= eh->e_shnum)
				np->n_type = N_COMM | N_EXT;
			else if (!strcmp(sn, ELF_TEXT))
				np->n_type = N_TEXT;
			else if (!strcmp(sn, ELF_RODATA)) {
				np->n_type = N_DATA;
				np->n_other = 'r';
			} else if (!strcmp(sn, ELF_DATA))
a233 31
			else if (!strncmp(sn, ELF_GOT, sizeof(ELF_GOT) - 1))
				np->n_type = N_DATA;
			else if (!strncmp(sn, ELF_PLT, sizeof(ELF_PLT) - 1))
				np->n_type = N_DATA;
			else if (!strcmp(sn, ELF_BSS))
				np->n_type = N_BSS;
			else if (!strcmp(sn, ELF_SBSS))
				np->n_type = N_BSS;
			else
				np->n_other = '?';
			break;
		}
		break;

	case STT_OBJECT:
		np->n_type = N_DATA;
		switch (sym->st_shndx) {
		case SHN_ABS:
			np->n_type = N_ABS;
			break;
		case SHN_COMMON:
			np->n_type = N_COMM;
			break;
		default:
			if (sym->st_shndx >= eh->e_shnum)
				break;
			else if (!strcmp(sn, ELF_SBSS))
				np->n_type = N_BSS;
			else if (!strcmp(sn, ELF_BSS))
				np->n_type = N_BSS;
			else if (!strcmp(sn, ELF_RODATA))
d235 2
d241 2
a242 1
		np->n_type = N_TEXT;
d246 2
a247 5
		} else if (sym->st_shndx == SHN_ABS)
			np->n_type = N_ABS;
		else if (sym->st_shndx == SHN_UNDEF)
			np->n_type = N_UNDF | N_EXT;
		else if (strcmp(sn, ELF_INIT) &&
d254 2
a255 8
		switch (sym->st_shndx) {
		case SHN_ABS:
			np->n_type = N_ABS;
			break;
		case SHN_COMMON:
			np->n_type = N_COMM;
			break;
		default:
d257 2
a258 1
		}
@


1.7
log
@STT_FUNC can be an absolute too
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.6 2004/05/04 23:07:53 mickey Exp $	*/
d202 21
d238 3
a240 3
	case STT_OBJECT:
		np->n_type = N_DATA;
		if (sym->st_shndx == SHN_ABS)
d242 2
a243 1
		if (sym->st_shndx == SHN_COMMON)
a244 1
		else if (sym->st_shndx >= eh->e_shnum)
d246 3
a248 6
		else if (!strcmp(sn, ELF_SBSS))
			np->n_type = N_BSS;
		else if (!strcmp(sn, ELF_BSS))
			np->n_type = N_BSS;
		else if (!strcmp(sn, ELF_RODATA))
			np->n_other = 'r';
@


1.6
log
@dig .plt*, .got*, .init, .fini sections
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.5 2004/03/30 15:35:51 mickey Exp $	*/
d207 3
a209 1
		} else if (sym->st_shndx == SHN_UNDEF)
@


1.5
log
@no need to force N_EXT as deducted later from type
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.4 2004/03/30 15:29:44 mickey Exp $	*/
d57 1
a152 1
	/* extern char *stab; */
d159 7
a165 1

d188 4
d209 3
a211 1
		else if (strcmp(sn, ELF_TEXT))	/* XXX GNU compat */
@


1.4
log
@there is more than one way to define symbol type in elf...; kill a debugging printf too
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.3 2004/03/30 15:12:38 mickey Exp $	*/
d183 1
a183 1
				np->n_type = N_BSS | N_EXT;
d214 1
a214 1
			np->n_type = N_BSS | N_EXT;
@


1.3
log
@translate names in .sbss section as static N_BSS; found by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.2 2004/01/13 17:32:32 mickey Exp $	*/
a159 1
/* printf("%s 0x%x %s(0x%x)\n", stab + sym->st_name, sym->st_info, sn, sym->st_shndx); */
d211 2
d214 1
a214 1
			np->n_type = N_BSS;
@


1.2
log
@kill unused local vars; from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: elf.c,v 1.1 2004/01/05 01:27:22 mickey Exp $	*/
d56 2
d184 2
@


1.1
log
@nm digs elf and merges w/ size; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a150 1
	unsigned char n_type;
@

