head	1.7;
access;
symbols
	OPENBSD_5_4:1.6.0.36
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.34
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.32
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.30
	OPENBSD_5_0:1.6.0.28
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.26
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.24
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.20
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.22
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.18
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.16
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.14
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.12
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.10
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.8
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2013.11.12.14.07.53;	author deraadt;	state dead;
branches;
next	1.6;

1.6
date	2004.10.09.20.26.57;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.28.18.05.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.07.04.43.14;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.19.23.21.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.08.29.17.22.05;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	99.05.10.16.14.07;	author espie;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove more code accidentally left behind during the a.out purge
@
text
@/* $OpenBSD: byte.c,v 1.6 2004/10/09 20:26:57 mickey Exp $ */
/*
 * Copyright (c) 1999
 *	Marc Espie.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 */

/*
 * A set of routines to read object files and compensate for host
 * endianness
 */
static int
byte_sex(int mid)
{
	switch (mid) {
	case MID_I386:
	case MID_VAX:
	case MID_ALPHA:
	case MID_PMAX:
		return LITTLE_ENDIAN;
	case MID_M68K:
	case MID_M68K4K:
	case MID_M88K:
	case MID_SUN010:
	case MID_SUN020:
	case MID_HP200:
	case MID_HP300:
	case MID_HPPA:
	case MID_HPUX800:
	case MID_HPUX:
	case MID_SPARC:
	case MID_MIPS:
	case MID_SPARC64:
	case MID_POWERPC:
		return BIG_ENDIAN;
	default:
		/* we don't know what this is, so we don't want to process it */
		return 0;
	}
}

#define BAD_OBJECT(h)  (N_BADMAG(h) || !byte_sex(N_GETMID(h)))

/* handles endianess swaps */
static void
swap_u32s(u_int32_t *h, size_t n)
{
	size_t i;

	for (i = 0; i < n; i++)
		h[i] = swap32(h[i]);
}

static void
fix_header_order(struct exec *h)
{
	if (byte_sex(N_GETMID(*h)) != BYTE_ORDER)
		swap_u32s( ((u_int32_t *)(h))+1, sizeof *h/sizeof(u_int32_t) - 1);
}

static long
fix_32_order(u_int32_t l, int mid)
{
	if (byte_sex(mid) != BYTE_ORDER)
		return swap32(l);
	else
		return l;
}

static void
swap_nlist(struct nlist *p)
{
	p->n_un.n_strx = swap32(p->n_un.n_strx);
	p->n_desc = swap16(p->n_desc);
	p->n_value = swap32(p->n_value);
}

static void
fix_nlist_order(struct nlist *p, int mid)
{
	if (byte_sex(mid) != BYTE_ORDER)
		swap_nlist(p);
}

static void
fix_nlists_order(struct nlist *p, size_t n, int mid)
{
	size_t i;

	if (byte_sex(mid) != BYTE_ORDER)
		for (i = 0; i < n; i++)
			swap_nlist(p+i);
}

static void
fix_ranlib_order(struct ranlib *r, int mid)
{
	if (byte_sex(mid) != BYTE_ORDER) {
		r->ran_un.ran_strx = swap32(r->ran_un.ran_strx);
		r->ran_off = swap32(r->ran_off);
	}
}
@


1.6
log
@move out elf code into elf.c and generate 32 and 64 versions of it;
allow operation on size-mixed host-target as well as ensianess for
both a.out and elf (though a.out 64bit probably does not exist ;)
tested on hppa-sparc64-i386-vax intermixen
@
text
@d1 1
a1 1
/* $OpenBSD: byte.c,v 1.5 2004/01/28 18:05:10 deraadt Exp $ */
@


1.5
log
@knf; millert ok
@
text
@d1 1
a1 1
/* $OpenBSD: byte.c,v 1.4 2003/11/07 04:43:14 mickey Exp $ */
d67 1
a67 1
fix_long_order(long l, int mid)
@


1.4
log
@hppa is bigendian
@
text
@d1 1
a1 1
/* $OpenBSD: byte.c,v 1.3 2001/08/19 23:21:40 espie Exp $ */
d3 1
a3 1
 * Copyright (c) 1999  
d13 2
a14 1
/* a set of routines to read object files and compensate for host
d17 2
a18 4


static int byte_sex(mid)
	int mid;
d20 1
a20 1
	switch(mid) {
d41 2
a42 1
	default:	/* we don't know what this is, so we don't want to process it */
d50 2
a51 3
static void swap_u32s(h, n)
	u_int32_t *h;
	size_t n;
d59 2
a60 2
static void fix_header_order(h)
	struct exec *h;
d66 2
a67 3
static long fix_long_order(l, mid)
	long l;
	int mid;
d75 2
a76 2
static void swap_nlist(p)
	struct nlist *p;
d83 2
a84 3
static void fix_nlist_order(p, mid)
	struct nlist *p;
	int mid;
d90 2
a91 4
static void fix_nlists_order(p, n, mid)
	struct nlist *p;
	size_t n;
	int mid;
d100 2
a101 3
static void fix_ranlib_order(r, mid)
	struct ranlib *r;
	int mid;
@


1.3
log
@Knowledge about sparc68/ppc endianess. Who knows where oldish a.out files
may come from ?
@
text
@d1 1
a1 1
/* $OpenBSD: byte.c,v 1.2 1999/08/29 17:22:05 espie Exp $ */
d34 1
@


1.2
log
@Fix -Wall warnings.
@
text
@d1 1
a1 1
/* $OpenBSD: byte.c,v 1.1 1999/05/10 16:14:07 espie Exp $ */
d38 2
@


1.1
log
@Fixes endianess problems with old a.out tools. This makes building
some cross toolchains possible.

This also changes some utilities's behavior slightly:
- nm, strip, size now handle any a.out format they know about.
- ranlib complains if it detects mixed archives (several object
formats for different boxes).

In the presence of mixed objects, you still have file, ranlib or ld
to prevent you from getting too confused...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d95 1
a95 1
	int i;
d102 1
a102 1
static fix_ranlib_order(r, mid)
@

