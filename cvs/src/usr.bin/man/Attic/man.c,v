head	1.50;
access;
symbols
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.8
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.6
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.45.0.6
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.4
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.28.0.8
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.6
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.15.0.6
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2015.03.27.01.59.26;	author schwarze;	state dead;
branches;
next	1.49;
commitid	rDngoF6qkinMsOSK;

1.49
date	2015.01.16.06.40.09;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	Uu5nFG3wCl0LACBb;

1.48
date	2013.07.01.18.47.39;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2013.07.01.17.16.03;	author jca;	state Exp;
branches;
next	1.46;

1.46
date	2013.06.26.19.56.45;	author jca;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.05.18.51.18;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.05.21.46.15;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.07.04.24.35;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.05.05.47.20;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2011.05.25.14.36.04;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.22.14.08.53;	author mikeb;	state Exp;
branches;
next	1.39;

1.39
date	2010.03.19.21.04.25;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.30.13.14.41;	author jmc;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.04.22.37.54;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.06.19.16.06;	author sobrado;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.04.20.40.10;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.09.18.01.53;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.14.19.25.58;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.12.00.51.13;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.31.10.38.04;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.17.19.08.46;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.23.14.14.14;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.16.18.58.46;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.10.22.20.48;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.03.02.56.12;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.13.09.09.32;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.12.08.16.50.07;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.23.18.43.29;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2002.09.17.19.37.39;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.16.21.27.48;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.17.03.09.44;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.18.21.59.37;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.04.10.02.32.33;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.31.19.26.51;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.10.18.01.46.36;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.07.28.01.17.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.06.10.22.38.02;	author pjanzen;	state Exp;
branches;
next	1.12;

1.12
date	98.11.16.06.28.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.09.14.05.44.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.07.20.01.15.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.07.01.11.23.40;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	98.04.25.00.25.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.03.09.23.20.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.10.04.16.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.15.23.42.52;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.09.16.02.26.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.07.18.22.52.58;	author michaels;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.37.01;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.46;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Move help(1) to share/man and send the remains of man(1) to the Attic.
It is implemented by the code in usr.bin/mandoc since OpenBSD 5.7.
@
text
@/*	$OpenBSD: man.c,v 1.49 2015/01/16 06:40:09 deraadt Exp $	*/
/*	$NetBSD: man.c,v 1.7 1995/09/28 06:05:34 tls Exp $	*/

/*
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 1987, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <fnmatch.h>
#include <glob.h>
#include <signal.h>
#include <stdio.h>
#include <libgen.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "config.h"
#include "pathnames.h"

int f_all, f_where;
static char gbuf[MAXPATHLEN * 2];
static TAG *section;

extern char *__progname;

static void	 clearlist(TAG *);
static void	 parse_path(TAG *, const char *);
static void	 append_subdirs(TAG *, const char *);
static void	 build_page(char *, char **);
static void	 cat(char *);
static int	 cleanup(int);
static void	 how(char *);
static void	 jump(char **, char *, char *);
static int	 manual(const char *, TAG *, glob_t *);
static void	 check_companion(char **, TAG *);
static void	 onsig(int);
static void	 usage(void);

sigset_t	blocksigs;

int
main(int argc, char *argv[])
{
	extern char *optarg;
	extern int optind;
	TAG *searchlist;
	glob_t pg;
	size_t len;
	int ch, f_cat, f_how, found;
	const char *pager, *p_path;
	char **ap, *cmd, *machine, *p, *p_add, *sflag;
	char *conffile;

	if (argv[1] == NULL && strcmp(basename(__progname), "help") == 0) {
		static char *nargv[3];
		nargv[0] = "man";
		nargv[1] = "help";
		nargv[2] = NULL;
		argv = nargv;
		argc = 2;
	}

	machine = sflag = NULL;
	f_cat = f_how = 0;
	conffile = p_add = NULL;
	p_path = (const char *)NULL;
	while ((ch = getopt(argc, argv, "aC:cfhkM:m:P:s:S:w-")) != -1)
		switch (ch) {
		case 'a':
			f_all = 1;
			break;
		case 'C':
			conffile = optarg;
			break;
		case 'c':
		case '-':		/* Deprecated. */
			f_cat = 1;
			break;
		case 'h':
			f_how = 1;
			break;
		case 'm':
			p_add = optarg;
			break;
		case 'M':
		case 'P':		/* Backward compatibility. */
			p_path = optarg;
			break;
		case 's':		/* SVR4 compatibility. */
			sflag = optarg;
			break;
		case 'S':
			machine = optarg;
			break;
		/*
		 * The -f and -k options are backward compatible
		 * ways of calling whatis(1) and apropos(1).
		 */
		case 'f':
			jump(argv, "-f", "whatis");
			/* NOTREACHED */
		case 'k':
			jump(argv, "-k", "apropos");
			/* NOTREACHED */
		case 'w':
			f_where = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (!*argv)
		usage();

	if (!f_cat && !f_how && !f_where) {
		if (!isatty(1))
			f_cat = 1;
		else {
			pager = getenv("MANPAGER");
			if (pager == NULL || *pager == '\0')
				pager = getenv("PAGER");
			if (pager == NULL || *pager == '\0')
				pager = _PATH_PAGER;
		}
	}

	/* Read the configuration file. */
	config(conffile);

	/*
	 * 1: If the user specified a section,
	 *    use the section list from the configuration file.
	 *    Otherwise, fall back to the default list or to an empty list.
	 */
	if (sflag && (section = getlist(sflag)) == NULL)
		errx(1, "unknown manual section `%s'", sflag);
	else if (argv[1] && (section = getlist(*argv)) != NULL)
		++argv;

	searchlist = section;
	if (searchlist == NULL)
		searchlist = getlist("_default");
	if (searchlist == NULL)
		searchlist = addlist("_default");

	/*
	 * 2: If the user set the -M option or defined the MANPATH variable,
	 *    clear what we have and take the user's list instead.
	 */
	if (p_path == NULL)
		p_path = getenv("MANPATH");

	if (p_path) {
		clearlist(searchlist);
		parse_path(searchlist, p_path);
	}

	/*
	 * 3: If the user set the -m option, insert the user's list before
	 *    whatever list we have.
	 */
	if (p_add)
		parse_path(searchlist, p_add);

	/*
	 * 4: Append the _subdir list where appropriate,
	 *    and always append the machine type.
	 */
	if (machine || (machine = getenv("MACHINE"))) {
		/* Avoid mangling argv/environment. */
		if ((machine = strdup(machine)) == NULL)
			err(1, NULL);
		for (p = machine; *p; ++p)
			*p = tolower(*p);
	} else
		machine = MACHINE;

	append_subdirs(searchlist, machine);

	/*
	 * 5: Search for the files.  Set up an interrupt handler, so the
	 *    temporary files go away.
	 */
	(void)signal(SIGINT, onsig);
	(void)signal(SIGHUP, onsig);

	sigemptyset(&blocksigs);
	sigaddset(&blocksigs, SIGINT);
	sigaddset(&blocksigs, SIGHUP);

	memset(&pg, 0, sizeof(pg));
	for (found = 0; *argv; ++argv)
		if (manual(*argv, searchlist, &pg))
			found = 1;

	/* 6: If nothing found, we're done. */
	if (!found) {
		(void)cleanup(0);
		exit (1);
	}

	/* 7: If it's simple, display it fast. */
	if (f_cat) {
		for (ap = pg.gl_pathv; *ap != NULL; ++ap) {
			if (**ap == '\0')
				continue;
			cat(*ap);
		}
		exit (cleanup(0));
	}
	if (f_how) {
		for (ap = pg.gl_pathv; *ap != NULL; ++ap) {
			if (**ap == '\0')
				continue;
			how(*ap);
		}
		exit(cleanup(0));
	}
	if (f_where) {
		for (ap = pg.gl_pathv; *ap != NULL; ++ap) {
			if (**ap == '\0')
				continue;
			(void)puts(*ap);
		}
		exit(cleanup(0));
	}

	/*
	 * 8: We display things in a single command; build a list of things
	 *    to display.
	 */
	for (ap = pg.gl_pathv, len = strlen(pager) + 1; *ap != NULL; ++ap) {
		if (**ap == '\0')
			continue;
		len += strlen(*ap) + 1;
	}
	if ((cmd = malloc(len)) == NULL) {
		warn(NULL);
		(void)cleanup(0);
		exit(1);
	}
	p = cmd;
	len = strlen(pager);
	memcpy(p, pager, len);
	p += len;
	*p++ = ' ';
	for (ap = pg.gl_pathv; *ap != NULL; ++ap) {
		if (**ap == '\0')
			continue;
		len = strlen(*ap);
		memcpy(p, *ap, len);
		p += len;
		*p++ = ' ';
	}
	*--p = '\0';

	/* Use system(3) in case someone's pager is "pager arg1 arg2". */
	(void)system(cmd);

	exit(cleanup(0));
}

/*
 * clearlist --
 *	Remove all entries from a list,
 * 	but leave the list header intact.
 */
static void
clearlist(TAG *t)
{
	ENTRY *e;

	while ((e = TAILQ_FIRST(&t->list)) != NULL) {
		free(e->s);
		TAILQ_REMOVE(&t->list, e, q);
		free(e);
	}
}

/*
 * parse_path --
 *	Split the -M or -m argument or the MANPATH variable at colons,
 *	and insert the parts into the searchlist.
 */
static void
parse_path(TAG *t, const char *path)
{
	ENTRY *eplast = NULL, *ep;
	char *p, *slashp, *path_copy;

	if ((path_copy = strdup(path)) == NULL)
		err(1, NULL);

	while ((p = strsep(&path_copy, ":")) != NULL) {
		/* Skip empty fields */
		if (*p == '\0')
			continue;

		if ((ep = malloc(sizeof(ENTRY))) == NULL)
			err(1, NULL);

		/* 
		 * Bring section specific paths to the same format as
		 * used in the configuration file, ending in /{cat,man}N.
		 */
		if (section) {
			slashp = p[strlen(p) - 1] == '/' ? "" : "/";
			(void)snprintf(gbuf, sizeof(gbuf),
			    "%s%s{cat,man}%s", p, slashp, t->s);
			if ((ep->s = strdup(gbuf)) == NULL)
				err(1, NULL);
		}

		/* Without a section, subdirs will be appended later. */
		else
			if ((ep->s = strdup(p)) == NULL)
				err(1, NULL);

		/*
		 * Even in case of -M, inserting in front is fine:
		 * We have just cleared the list.
		 */
		if (eplast)
			TAILQ_INSERT_AFTER(&t->list, eplast, ep, q);
		else
			TAILQ_INSERT_HEAD(&t->list, ep, q);
		eplast = ep;
	}

	free(path_copy);
}

/*
 * append_subdirs --
 *	Iterate the searchlist and append section and machine
 *	subdirectories as needed.
 */
static void
append_subdirs(TAG *t, const char *machine)
{
	TAG *tsub;
	ENTRY *eold, *elast, *enew, *esub;
	char *slashp;

	eold = elast = TAILQ_FIRST(&t->list);
	while (eold) {

		/*
		 * Section subdirectories *not* ending in a slash
		 * only get the machine suffix: They already had
		 * the {cat,man}N part in the configuration file
		 * or got it in parse_path().
		 */
		if (section && eold->s[strlen(eold->s)-1] != '/') {
			(void)snprintf(gbuf, sizeof(gbuf), "%s{/%s,}",
			    eold->s, machine);
			free(eold->s);
			if ((eold->s = strdup(gbuf)) == NULL)
				err(1, NULL);
			eold = elast = TAILQ_NEXT(eold, q);
			continue;
		}

		/*
		 * Without a section, expand each entry using the
		 * subdir list, then drop the original entry.
		 */
		esub = (tsub = getlist("_subdir")) == NULL ?
		    NULL : TAILQ_FIRST(&tsub->list);
		while (esub) {
			slashp = eold->s[strlen(eold->s)-1] == '/' ? "" : "/";
			(void)snprintf(gbuf, sizeof(gbuf), "%s%s%s{/%s,}",
			    eold->s, slashp, esub->s, machine);
			if ((enew = malloc(sizeof(ENTRY))) == NULL ||
			    (enew->s = strdup(gbuf)) == NULL)
				err(1, NULL);
			TAILQ_INSERT_AFTER(&t->list, elast, enew, q);
			elast = enew;
			esub = TAILQ_NEXT(esub, q);
		}
		elast = TAILQ_NEXT(elast, q);
		TAILQ_REMOVE(&t->list, eold, q);
		eold = elast;
	}
}

/*
 * manual --
 *	Search the manuals for the pages.
 */
static int
manual(const char *page, TAG *tag, glob_t *pg)
{
	ENTRY *ep, *e_sufp, *e_tag;
	TAG *missp, *sufp;
	int anyfound, cnt, found;
	char *p, buf[MAXPATHLEN];

	anyfound = 0;
	buf[0] = '*';

	/* Expand the search path. */
	if (f_all != f_where) {
		e_tag = tag == NULL ? NULL : TAILQ_FIRST(&tag->list);
		while (e_tag != NULL) {
			if (glob(e_tag->s, GLOB_BRACE | GLOB_NOSORT,
			    NULL, pg)) {
				/* No GLOB_NOMATCH here due to {arch,}. */
				warn("globbing directories");
				(void)cleanup(0);
				exit(1);
			}
			for (cnt = 0; cnt < pg->gl_pathc; cnt++) {
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(pg->gl_pathv[cnt])) ==
						NULL) {
					warn(NULL);
					(void)cleanup(0);
					exit(1);
				}
				TAILQ_INSERT_BEFORE(e_tag, ep, q);
			}
			ep = e_tag;
			e_tag = TAILQ_NEXT(e_tag, q);
			free(ep->s);
			TAILQ_REMOVE(&tag->list, ep, q);
			free(ep);
			globfree(pg);
			pg->gl_pathc = 0;
		}
	}

	/* For each element in the list... */
	e_tag = tag == NULL ? NULL : TAILQ_FIRST(&tag->list);
	for (; e_tag != NULL; e_tag = TAILQ_NEXT(e_tag, q)) {
		(void)snprintf(buf, sizeof(buf), "%s/%s.*", e_tag->s, page);
		switch (glob(buf, GLOB_APPEND | GLOB_BRACE | GLOB_NOSORT,
		    NULL, pg)) {
		case (0):
			break;
		case (GLOB_NOMATCH):
			continue;
		default:
			warn("globbing files");
			(void)cleanup(0);
			exit(1);
		}
		if (pg->gl_matchc == 0)
			continue;

		/* Find out if it's really a man page. */
		for (cnt = pg->gl_pathc - pg->gl_matchc;
		    cnt < pg->gl_pathc; ++cnt) {

			if (!f_all || !f_where) {
				check_companion(pg->gl_pathv + cnt, tag);
				if (*pg->gl_pathv[cnt] == '\0')
					continue;
			}

			/*
			 * Try the _suffix key words first.
			 *
			 * XXX
			 * Older versions of man.conf didn't have the suffix
			 * key words, it was assumed that everything was a .0.
			 * We just test for .0 first, it's fast and probably
			 * going to hit.
			 */
			(void)snprintf(buf, sizeof(buf), "*/%s.0", page);
			if (!fnmatch(buf, pg->gl_pathv[cnt], 0))
				goto next;

			e_sufp = (sufp = getlist("_suffix")) == NULL ?
			    NULL : TAILQ_FIRST(&sufp->list);
			for (found = 0;
			    e_sufp != NULL; e_sufp = TAILQ_NEXT(e_sufp, q)) {
				(void)snprintf(buf,
				     sizeof(buf), "*/%s%s", page, e_sufp->s);
				if (!fnmatch(buf, pg->gl_pathv[cnt], 0)) {
					found = 1;
					break;
				}
			}
			if (found)
				goto next;

			/* Try the _build key words next. */
			e_sufp = (sufp = getlist("_build")) == NULL ?
			    NULL : TAILQ_FIRST(&sufp->list);
			for (found = 0;
			    e_sufp != NULL; e_sufp = TAILQ_NEXT(e_sufp, q)) {
				for (p = e_sufp->s;
				    *p != '\0' && !isspace(*p); ++p);
				if (*p == '\0')
					continue;
				*p = '\0';
				(void)snprintf(buf,
				     sizeof(buf), "*/%s%s", page, e_sufp->s);
				if (!fnmatch(buf, pg->gl_pathv[cnt], 0)) {
					if (!f_where)
						build_page(p + 1,
						    &pg->gl_pathv[cnt]);
					*p = ' ';
					found = 1;
					break;
				}
				*p = ' ';
			}
			if (found) {
next:				anyfound = 1;
				if (!f_all && !f_where) {
					/* Delete any other matches. */
					while (++cnt< pg->gl_pathc)
						pg->gl_pathv[cnt] = "";
					break;
				}
				continue;
			}

			/* It's not a man page, forget about it. */
			pg->gl_pathv[cnt] = "";
		}

		if (anyfound && !f_all && !f_where)
			break;
	}

	/* If not found, enter onto the missing list. */
	if (!anyfound) {
		sigset_t osigs;

		sigprocmask(SIG_BLOCK, &blocksigs, &osigs);

		if ((missp = getlist("_missing")) == NULL)
			missp = addlist("_missing");
		if ((ep = malloc(sizeof(ENTRY))) == NULL ||
		    (ep->s = strdup(page)) == NULL) {
			warn(NULL);
			(void)cleanup(0);
			exit(1);
		}
		TAILQ_INSERT_TAIL(&missp->list, ep, q);
		sigprocmask(SIG_SETMASK, &osigs, NULL);
	}
	return (anyfound);
}

/*
 * check_companion --
 *	Check for a companion [un]formatted page.
 *	If one is found, skip this page.
 *	Use the companion instead, unless it will be found anyway.
 */
static void
check_companion(char **orig, TAG *tag) {
	struct stat sb_orig, sb_comp;
	char *p, *pext, comp[MAXPATHLEN];
	ENTRY *entry;
	size_t len;
	int found;

	len = strlcpy(comp, *orig, sizeof(comp));
	/* The minus 2 avoids a buffer overrun in case of a trailing dot. */
	p = comp + len - 2;

	/* Locate the file name extension. */
	while (p > comp && *p != '.' && *p != '/')
		p--;
	if (*p != '.')
		return;
	pext = p + 1;

	/* Search for slashes. */
	for (found = 0; 1; p--) {
		if (*p != '/')
			continue;

		/* Did not find /{cat,man}. */
		if (p == comp)
			return;

		/* Pass over one slash, the one before "page". */
		if (!found++) {
			len = p - comp;
			continue;
		}

		/* Rewrite manN/page.N <-> catN/page.0. */
		if (!strncmp(p+1, "man", 3)) {
			memcpy(++p, "cat", 3);
			*pext++ = '0';
			break;
		} else if (!strncmp(p+1, "cat", 3)) {
			memcpy(++p, "man", 3);
			p += 3;
			while (*p != '/' && pext < comp + sizeof(comp) - 1)
				*pext++ = *p++;
			break;

		/* Accept one architecture subdir, but not more. */
		} else if (found > 2)
			return;
	}
	*pext = '\0';

	/* Check whether both files exist. */
	if (stat(*orig, &sb_orig) || stat(comp, &sb_comp))
		return;

	/* No action if the companion file is older. */
	if (sb_orig.st_mtim.tv_sec  > sb_comp.st_mtim.tv_sec || (
	    sb_orig.st_mtim.tv_sec == sb_comp.st_mtim.tv_sec &&
	    sb_orig.st_mtim.tv_nsec > sb_comp.st_mtim.tv_nsec))
		return;

	/* Drop the companion if it is in the path, too. */
	if (f_all || f_where)
		for(entry = TAILQ_FIRST(&tag->list); entry != NULL;
		    entry = TAILQ_NEXT(entry, q))
			if (!strncmp(entry->s, comp, len)) {
				**orig = '\0';
				return;
			}

	/* The companion file is newer, use it. */
	free(*orig);
	if ((p = strdup(comp)) == NULL) {
		warn(NULL);
		(void)cleanup(0);
		exit(1);
	}
	*orig = p;
}

/*
 * build_page --
 *	Build a man page for display.
 */
static void
build_page(char *fmt, char **pathp)
{
	ENTRY *ep;
	TAG *intmpp;
	int fd, n;
	char *p, *b;
	char buf[MAXPATHLEN], cmd[MAXPATHLEN], tpath[MAXPATHLEN];
	sigset_t osigs;

       /*
        * Historically man chdir'd to the root of the man tree.
        * This was used in man pages that contained relative ".so"
        * directives (including other man pages for command aliases etc.)
        * It even went one step farther, by examining the first line
        * of the man page and parsing the .so filename so it would
        * make hard(?) links to the cat'ted man pages for space savings.
        * (We don't do that here, but we could).
        */

       /* copy and find the end */
       for (b = buf, p = *pathp; (*b++ = *p++) != '\0';)
               continue;

       /* skip the last two path components, page name and man[n] */
       for (--b, n = 2; b != buf; b--)
               if (*b == '/')
                       if (--n == 0) {
                               *b = '\0';
                               (void) chdir(buf);
                       }


	/* Add a remove-when-done list. */
	sigprocmask(SIG_BLOCK, &blocksigs, &osigs);
	if ((intmpp = getlist("_intmp")) == NULL)
		intmpp = addlist("_intmp");
	sigprocmask(SIG_SETMASK, &osigs, NULL);

	/* Move to the printf(3) format string. */
	for (; *fmt && isspace(*fmt); ++fmt)
		;

	/*
	 * Get a temporary file and build a version of the file
	 * to display.  Replace the old file name with the new one.
	 */
	(void)strlcpy(tpath, _PATH_TMPFILE, sizeof(tpath));
	if ((fd = mkstemp(tpath)) == -1) {
		warn("%s", tpath);
		(void)cleanup(0);
		exit(1);
	}
	(void)snprintf(buf, sizeof(buf), "%s > %s", fmt, tpath);
	(void)snprintf(cmd, sizeof(cmd), buf, *pathp);
	(void)system(cmd);
	(void)close(fd);
	if ((*pathp = strdup(tpath)) == NULL) {
		warn(NULL);
		(void)cleanup(0);
		exit(1);
	}

	/* Link the built file into the remove-when-done list. */
	if ((ep = malloc(sizeof(ENTRY))) == NULL) {
		warn(NULL);
		(void)cleanup(0);
		exit(1);
	}
	ep->s = *pathp;

	sigprocmask(SIG_BLOCK, &blocksigs, &osigs);
	TAILQ_INSERT_TAIL(&intmpp->list, ep, q);
	sigprocmask(SIG_SETMASK, &osigs, NULL);
}

/*
 * how --
 *	display how information
 */
static void
how(char *fname)
{
	FILE *fp;

	int lcnt, print;
	char *p, buf[256];

	if (!(fp = fopen(fname, "r"))) {
		warn("%s", fname);
		(void)cleanup(0);
		exit (1);
	}
#define	S1	"SYNOPSIS"
#define	S2	"S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS"
	for (lcnt = print = 0; fgets(buf, sizeof(buf), fp);) {
		if (!strncmp(buf, S1, sizeof(S1) - 1) ||
		    !strncmp(buf, S2, sizeof(S2) - 1)) {
			print = 1;
			continue;
		} else if (print) {
			char *p = buf;
			int allcaps = 0;

			while (*p) {
				if (!allcaps && isalpha(*p))
					allcaps = 1;
				if (isalpha(*p) && !isupper(*p)) {
					allcaps = 0;
					break;
				}
				p++;
			}
			if (allcaps) {
				(void)fclose(fp);
				return;
			}
		}
		if (!print)
			continue;
		if (*buf == '\n')
			++lcnt;
		else {
			while (lcnt) {
				--lcnt;
				(void)putchar('\n');
			}
			for (p = buf; isspace(*p); ++p)
				;
			(void)fputs(p, stdout);
		}
	}
	(void)fclose(fp);
}

/*
 * cat --
 *	cat out the file
 */
static void
cat(char *fname)
{
	int fd, n;
	char buf[2048];

	if ((fd = open(fname, O_RDONLY, 0)) < 0) {
		warn("%s", fname);
		(void)cleanup(0);
		exit(1);
	}
	while ((n = read(fd, buf, sizeof(buf))) > 0)
		if (write(STDOUT_FILENO, buf, n) != n) {
			warn("write");
			(void)cleanup(0);
			exit (1);
		}
	if (n == -1) {
		warn("read");
		(void)cleanup(0);
		exit(1);
	}
	(void)close(fd);
}

/*
 * jump --
 *	strip out flag argument and jump
 */
static void
jump(char **argv, char *flag, char *name)
{
	char **arg;

	argv[0] = name;
	for (arg = argv + 1; *arg; ++arg)
		if (!strcmp(*arg, flag))
			break;
	for (; *arg; ++arg)
		arg[0] = arg[1];
	execvp(name, argv);
	(void)fprintf(stderr, "%s: Command not found.\n", name);
	exit(1);
}

/*
 * onsig --
 *	If signaled, delete the temporary files.
 */
static void
onsig(int signo)
{
	(void)cleanup(1);

	(void)signal(signo, SIG_DFL);
	(void)kill(getpid(), signo);

	/* NOTREACHED */
	_exit(1);
}

/*
 * cleanup --
 *	Clean up temporary files, show any error messages.
 */
static int
cleanup(int insig)
{
	TAG *intmpp, *missp;
	ENTRY *ep;
	int rval = 0;

	if (insig == 0) {
		ep = (missp = getlist("_missing")) == NULL ?
		    NULL : TAILQ_FIRST(&missp->list);
		if (ep != NULL)
			for (; ep != NULL; ep = TAILQ_NEXT(ep, q)) {
				if (section)
					warnx("no entry for %s in "
					    "section %s of the manual.",
						ep->s, section->s);
				else
					warnx("no entry for %s in the manual.",
					    ep->s);
				rval = 1;
			}
	}

	ep = (intmpp = getlist("_intmp")) == NULL ?
	    NULL : TAILQ_FIRST(&intmpp->list);
	for (; ep != NULL; ep = TAILQ_NEXT(ep, q))
		(void)unlink(ep->s);
	return (rval);
}

/*
 * usage --
 *	print usage message and die
 */
static void
usage(void)
{
	(void)fprintf(stderr, "usage: %s [-achw] [-C file] [-M path] [-m path] "
	    "[-S subsection] [-s section]\n\t   [section] name ...\n",
	    __progname);
	(void)fprintf(stderr, "       %s -f command ...\n", __progname);
	(void)fprintf(stderr, "       %s -k keyword ...\n", __progname);
	exit(1);
}
@


1.49
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.48 2013/07/01 18:47:39 schwarze Exp $	*/
@


1.48
log
@Make some variables const that are filled from getenv(3), from argv,
from optarg and from literal strings - for clarity and to make sure
that future code changes do not attempt to write to them.
No functional change.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.47 2013/07/01 17:16:03 jca Exp $	*/
a49 1
#include <sys/param.h>
@


1.47
log
@Kill off some code that undocumently added an "-s" switch if user had
specified "more" as (MAN)PAGER.  Document the default pager used while
here.  Discussed with schwarze@@, ok schwarze@@ millert@@, jasper@@ agrees.

Users can get the previous behaviour by specifying eg.
export MANPAGER="more -s".
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.46 2013/06/26 19:56:45 jca Exp $	*/
d84 1
a84 1
static int	 manual(char *, TAG *, glob_t *);
d100 2
a101 1
	char **ap, *cmd, *machine, *p, *p_add, *p_path, *pager, *sflag;
d115 2
a116 1
	conffile = p_add = p_path = NULL;
d445 1
a445 1
manual(char *page, TAG *tag, glob_t *pg)
@


1.46
log
@Avoid mangling argv and environment variables.
ok schwarze@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.45 2012/02/05 18:51:18 schwarze Exp $	*/
a80 1
static char	*check_pager(char *);
d169 7
a175 7
		else if ((pager = getenv("MANPAGER")) != NULL &&
				(*pager != '\0'))
			pager = check_pager(pager);
		else if ((pager = getenv("PAGER")) != NULL && (*pager != '\0'))
			pager = check_pager(pager);
		else
			pager = _PATH_PAGER;
a852 30
}

/*
 * check_pager --
 *	check the user supplied page information
 */
static char *
check_pager(char *name)
{
	char *p, *save;

	/*
	 * if the user uses "more", we make it "more -s"; watch out for
	 * PAGER = "mypager /usr/bin/more"
	 */
	for (p = name; *p && !isspace(*p); ++p)
		;
	for (; p > name && *p != '/'; --p)
		;
	if (p != name)
		++p;

	/* make sure it's "more", not "morex" */
	if (!strncmp(p, "more", 4) && (p[4] == '\0' || isspace(p[4]))){
		save = name;
		/* allocate space to add the "-s" */
		if (asprintf(&name, "%s -s", save) == -1)
			err(1, "asprintf");
	}
	return(name);
@


1.45
log
@Do not insert an empty ENTRY into the manpath list;
it's useless and causes out-of-bounds array access later.
While here, remove two unused local variables and two unused struct members.
From Tobias Ulmer <tobiasu at tmux dot org> on tech@@, thanks.
"off to you" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.44 2012/01/05 21:46:15 schwarze Exp $	*/
d77 1
a77 1
static void	 parse_path(TAG *, char *);
d221 4
a224 1
	if (machine || (machine = getenv("MACHINE")))
d227 1
a227 1
	else
d338 1
a338 1
parse_path(TAG *t, char *path)
d341 4
a344 1
	char *p, *slashp;
d346 1
a346 1
	while ((p = strsep(&path, ":")) != NULL) {
d381 2
@


1.44
log
@When iterating a TAILQ list replacing elements,
get a pointer to the next element before freeing the previous one,
do not access free'd pointers.  Problem found the hard way
by fgsch@@ running "man -a x" with malloc.conf -> S on amd64.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.43 2011/07/07 04:24:35 schwarze Exp $	*/
a97 1
	ENTRY *ep;
d341 4
d440 1
a440 1
	int anyfound, cnt, found, globres;
@


1.43
log
@For man -a and -w, drop companion pages that are also in the path,
such that we don't display them twice.
To be able to do that path check, we have to brace-expand the search
path up front - of course, for -a and -w only, so it doesn't slow
us down in the standard case.

As a free bonus, let -wa print all the filenames without looking
at the timestamps.  In the past, -w implied -a, so that's not
introducing any incompatibility.

Issue originally reported and fix OK'd by guenther@@,
and deraadt@@ agrees with the semantics.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.42 2011/07/05 05:47:20 schwarze Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d446 1
a446 1
		for (; e_tag != NULL; e_tag = TAILQ_NEXT(e_tag, q)) {
a453 1
			ep = e_tag;
d455 2
a456 2
				if ((e_tag = malloc(sizeof(ENTRY))) == NULL ||
				    (e_tag->s = strdup(pg->gl_pathv[cnt])) ==
d462 1
a462 1
				TAILQ_INSERT_BEFORE(ep, e_tag, q);
d464 2
@


1.42
log
@When both a formatted and an unformatted version of the same manual page
are available in the same tree, only show the newer of the two.
So far, this only handles the case without -a;
i need to look at the case with -a next.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.41 2011/05/25 14:36:04 deraadt Exp $	*/
d86 1
a86 1
static void	 check_companion(char **);
d156 1
a156 1
			f_all = f_where = 1;
d437 1
a437 1
	int anyfound, cnt, found;
d443 30
d477 1
a477 2
		if (glob(buf,
		    GLOB_APPEND | GLOB_BRACE | GLOB_NOSORT | GLOB_QUOTE,
d479 6
a484 1
			warn("globbing");
d495 5
a499 2
			if (!f_all)
				check_companion(pg->gl_pathv + cnt);
d552 1
a552 1
				if (!f_all) {
d565 1
a565 1
		if (anyfound && !f_all)
d591 3
a593 2
 *	Check for a companion [un]formatted page
 *	and use the newer one of the two.
d596 1
a596 1
check_companion(char **orig) {
d599 1
d616 2
d624 2
a625 1
		if (*p != '/' || !found++)
d627 1
d656 9
@


1.41
log
@add one more signal block for handling '_intmp' (the list of files scheduled
to be deleted at termination), and then make the signal handler race safe.
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.40 2010/10/22 14:08:53 mikeb Exp $	*/
d5 1
a5 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d49 1
d52 1
d86 1
d461 3
d550 72
@


1.40
log
@whining verboten;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.39 2010/03/19 21:04:25 schwarze Exp $	*/
d80 1
a80 1
static int	 cleanup(void);
d245 1
a245 1
		(void)cleanup();
d256 1
a256 1
		exit (cleanup());
d264 1
a264 1
		exit(cleanup());
d272 1
a272 1
		exit(cleanup());
d286 1
a286 1
		(void)cleanup();
d307 1
a307 1
	exit(cleanup());
d448 1
a448 1
			(void)cleanup();
d537 1
a537 1
			(void)cleanup();
d600 1
a600 1
		(void)cleanup();
d609 1
a609 1
		(void)cleanup();
d616 1
a616 1
		(void)cleanup();
d620 2
d623 1
d640 1
a640 1
		(void)cleanup();
d697 1
a697 1
		(void)cleanup();
d703 1
a703 1
			(void)cleanup();
d708 1
a708 1
		(void)cleanup();
d771 1
a771 1
	(void)cleanup();	/* XXX signal race */
d785 1
a785 1
cleanup(void)
d789 1
a789 1
	int rval;
d791 15
a805 12
	rval = 0;
	ep = (missp = getlist("_missing")) == NULL ?
	    NULL : TAILQ_FIRST(&missp->list);
	if (ep != NULL)
		for (; ep != NULL; ep = TAILQ_NEXT(ep, q)) {
			if (section)
				warnx("no entry for %s in section %s of the manual.",
					ep->s, section->s);
			else
				warnx("no entry for %s in the manual.", ep->s);
			rval = 1;
		}
@


1.39
log
@Fix three bugs in man(1):
 * when combining -m $path with -s $section, -s was ignored
 * when combining -m with -s, ONLY $path was searched, like with -M
 * when combining -M (or $MANPATH) with -s, -M was ignored

Instead, when combining -m, -M or $MANPATH with -s, let's simply look into
$path/{cat,man}$section{/$arch,} first (for -m) or only (for -M or $MANPATH).
Do not change the behaviour in other cases.

This required a rewrite of the whole path handling,
as a bonus also making the code easier to understand.
Hopefully, it helps to fix www.openbsd.org/cgi-bin/man.cgi properly.

Jason convinced me that changing the manual is not really needed.
Regression tests will follow when the tree unlocks completely.

"you are on the right track" beck@@
tested and agreed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.38 2009/10/27 23:59:40 deraadt Exp $	*/
a552 1
	static int warned;
a558 6

	/* Let the user know this may take awhile. */
	if (!warned) {
		warned = 1;
		warnx("Formatting manual page...");
	}
@


1.38
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.37 2008/12/30 13:14:41 jmc Exp $	*/
d5 16
d69 2
a70 1
static TAG *section;	/* could be passed to cleanup() instead */
d74 3
d94 2
a95 2
	TAG *defp, *defnewp, *sectnewp, *subp;
	ENTRY *e_defp, *e_sectp, *e_subp, *ep;
d99 2
a100 2
	char **ap, *cmd, *machine, *p, *p_add, *p_path, *pager, *sflag, *slashp;
	char *conffile, buf[MAXPATHLEN * 2];
d180 15
a194 10
	/* Get the machine type unless specified by -S. */
	if (machine || (machine = getenv("MACHINE")))
		for (p = machine; *p; ++p)
			*p = tolower(*p);
	else
		machine = MACHINE;

	/* If there's no _default list, create an empty one. */
	if ((defp = getlist("_default")) == NULL)
		defp = addlist("_default");
d197 2
a198 3
	 * 1: If the user specified a MANPATH variable, or set the -M
	 *    option, we replace the _default list with the user's list,
	 *    appending the entries in the _subdir list and the machine.
a201 20
	if (p_path != NULL) {
		while ((e_defp = TAILQ_FIRST(&defp->list)) != NULL) {
			free(e_defp->s);
			TAILQ_REMOVE(&defp->list, e_defp, q);
		}
		for (p = strtok(p_path, ":");
		    p != NULL; p = strtok(NULL, ":")) {
			slashp = p[strlen(p) - 1] == '/' ? "" : "/";
			e_subp = (subp = getlist("_subdir")) == NULL ?
			    NULL : TAILQ_FIRST(&subp->list);
			for (; e_subp != NULL; e_subp = TAILQ_NEXT(e_subp, q)) {
				(void)snprintf(buf, sizeof(buf), "%s%s%s{/%s,}",
				    p, slashp, e_subp->s, machine);
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(buf)) == NULL)
					err(1, NULL);
				TAILQ_INSERT_TAIL(&defp->list, ep, q);
			}
		}
	}
d203 3
a205 40
	/*
	 * 2: If the user did not specify MANPATH, -M or a section, rewrite
	 *    the _default list to include the _subdir list and the machine.
	 */
	if (sflag == NULL && argv[1] == NULL)
		section = NULL;
	else {
		if (sflag != NULL && (section = getlist(sflag)) == NULL)
			errx(1, "unknown manual section `%s'", sflag);
		else if (sflag == NULL && (section = getlist(*argv)) != NULL)
			++argv;
	}
	if (p_path == NULL && section == NULL) {
		defnewp = addlist("_default_new");
		e_defp = TAILQ_FIRST(&defp->list);
		for (; e_defp != NULL; e_defp = TAILQ_NEXT(e_defp, q)) {
			slashp =
			    e_defp->s[strlen(e_defp->s) - 1] == '/' ? "" : "/";
			e_subp = (subp = getlist("_subdir")) == NULL ?
			    NULL : TAILQ_FIRST(&subp->list);
			for (; e_subp != NULL; e_subp = TAILQ_NEXT(e_subp, q)) {
				(void)snprintf(buf, sizeof(buf), "%s%s%s{/%s,}",
				e_defp->s, slashp, e_subp->s, machine);
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(buf)) == NULL)
					err(1, NULL);
				TAILQ_INSERT_TAIL(&defnewp->list, ep, q);
			}
		}
		defp = getlist("_default");
		while ((e_defp = TAILQ_FIRST(&defp->list)) != NULL) {
			free(e_defp->s);
			TAILQ_REMOVE(&defp->list, e_defp, q);
		}
		free(defp->s);
		TAILQ_REMOVE(&head, defp, q);
		defnewp = getlist("_default_new");
		free(defnewp->s);
		defnewp->s = "_default";
		defp = defnewp;
d210 1
a210 2
	 *    whatever list we have, again appending the _subdir list and
	 *    the machine.
d212 3
a214 22
	if (p_add != NULL) {
		e_sectp = NULL;
		for (p = strtok(p_add, ":"); p != NULL; p = strtok(NULL, ":")) {
			slashp = p[strlen(p) - 1] == '/' ? "" : "/";
			e_subp = (subp = getlist("_subdir")) == NULL ?
			    NULL : TAILQ_FIRST(&subp->list);
			for (; e_subp != NULL; e_subp = TAILQ_NEXT(e_subp, q)) {
				(void)snprintf(buf, sizeof(buf), "%s%s%s{/%s,}",
				    p, slashp, e_subp->s, machine);
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(buf)) == NULL)
					err(1, NULL);

				if (e_sectp == NULL)
					TAILQ_INSERT_HEAD(&defp->list, ep, q);
				else
					TAILQ_INSERT_AFTER(&defp->list, e_sectp,
					    ep, q);
				e_sectp = ep;
			}
		}
	}
d216 2
a217 3
	 * 4: If no -m was specified, and a section was, rewrite the section's
	 *    paths (if they have a trailing slash) to append the _subdir list
	 *    and the machine.  This then becomes the _default list.
d219 7
a225 27
	if (p_add == NULL && section != NULL) {
		sectnewp = addlist("_section_new");
		TAILQ_FOREACH(e_sectp, &section->list, q) {
			if (e_sectp->s[strlen(e_sectp->s) - 1] != '/') {
				(void)snprintf(buf, sizeof(buf),
				    "%s{/%s,}", e_sectp->s, machine);
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(buf)) == NULL)
					err(1, NULL);
				TAILQ_INSERT_TAIL(&sectnewp->list, ep, q);
				continue;
			}
			e_subp = (subp = getlist("_subdir")) == NULL ?
			    NULL : TAILQ_FIRST(&subp->list);
			for (; e_subp != NULL; e_subp = TAILQ_NEXT(e_subp, q)) {
				(void)snprintf(buf, sizeof(buf), "%s%s{/%s,}",
				    e_sectp->s, e_subp->s, machine);
				if ((ep = malloc(sizeof(ENTRY))) == NULL ||
				    (ep->s = strdup(buf)) == NULL)
					err(1, NULL);
				TAILQ_INSERT_TAIL(&sectnewp->list, ep, q);
			}
		}
		sectnewp->s = section->s;
		defp = sectnewp;
		TAILQ_REMOVE(&head, section, q);
	}
d240 1
a240 1
		if (manual(*argv, defp, &pg))
d308 115
@


1.37
log
@make -S case insensitive; this avoids any confusion over the fact
that MD page headers use mixed case; tidy up the man page regarding this;

diff from Ingo Schwarze
ok sobrado millert krw
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.36 2008/01/04 22:37:54 jmc Exp $	*/
a31 14

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1987, 1993, 1994, 1995\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)man.c	8.17 (Berkeley) 1/31/95";
#else
static char rcsid[] = "$OpenBSD: man.c,v 1.36 2008/01/04 22:37:54 jmc Exp $";
#endif
#endif /* not lint */
@


1.36
log
@-k and -f accept multiple arguments; from Pierre Riteau
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.35 2007/08/06 19:16:06 sobrado Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.35 2007/08/06 19:16:06 sobrado Exp $";
d175 4
a178 1
	if (machine == NULL && (machine = getenv("MACHINE")) == NULL)
@


1.35
log
@the ellipsis is not an optional argument; while here, sync the usage
and synopsis of commands

lots of good ideas by jmc@@

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.34 2007/06/04 20:40:10 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.34 2007/06/04 20:40:10 otto Exp $";
d795 2
a796 2
	(void)fprintf(stderr, "       %s -f command\n", __progname);
	(void)fprintf(stderr, "       %s -k keyword\n", __progname);
@


1.34
log
@make jmc happy by somewhat smarter synopsis scanning code for -h; ok
jaredy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.33 2007/01/09 18:01:53 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.33 2007/01/09 18:01:53 deraadt Exp $";
d793 1
a793 1
	    "[-S subsection] [-s section]\n\t   [section] name [...]\n",
@


1.33
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.32 2006/12/14 19:25:58 jasper Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.32 2006/12/14 19:25:58 jasper Exp $";
a618 2
#define	D1	"DESCRIPTION"
#define	D2	"D\bDE\bES\bSC\bCR\bRI\bIP\bPT\bTI\bIO\bON\bN"
d624 17
a640 4
		} else if (!strncmp(buf, D1, sizeof(D1) - 1) ||
		    !strncmp(buf, D2, sizeof(D2) - 1)) {
		    	(void)fclose(fp);
			return;
@


1.32
log
@Coverity CID 2996: Don't return without closing fp.
Fix from christos NetBSD.

ok otto@@, millert@@ (earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.31 2005/11/12 00:51:13 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.31 2005/11/12 00:51:13 deraadt Exp $";
d784 2
a785 2
	(void)fprintf(stderr, "usage: %s -f command\n", __progname);
	(void)fprintf(stderr, "usage: %s -k keyword\n", __progname);
@


1.31
log
@use asprintf instead; dhill@@mindcry.org
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.30 2005/10/31 10:38:04 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.30 2005/10/31 10:38:04 otto Exp $";
d627 2
a628 1
		    !strncmp(buf, D2, sizeof(D2) - 1))
d630 1
@


1.30
log
@Rewrite -m processing to not use queue internals and make it more
simple as well. ok hshoexer@@ jaredy@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.29 2005/10/17 19:08:46 otto Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.29 2005/10/17 19:08:46 otto Exp $";
a682 1
	int len;
d699 2
a700 4
		len = strlen(save) + 1 + sizeof("-s");
		if ((name = malloc(len)) == NULL)
			err(1, NULL);
		(void)snprintf(name, len, "%s %s", save, "-s");
@


1.29
log
@Use queue macros instead of directly accessing fields. ok pat@@ "put it
in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.28 2004/02/23 14:14:14 jmc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.28 2004/02/23 14:14:14 jmc Exp $";
d269 1
a269 6
				/*
				 * puts it at the end, should be at the top,
				 * but then the added entries would be in
				 * reverse order, fix later when all are added
				 */
				TAILQ_INSERT_TAIL(&defp->list, ep, q);
d271 5
a275 2
				 	/* save first added, to-be the new top */
					e_sectp = ep;
a276 8
		}
		if (e_sectp != NULL) { /* entries added, fix order */
			/* save original head */
			TAILQ_NEXT(ep, q) = TAILQ_FIRST(&defp->list);
			/* first added entry, new top */
			TAILQ_FIRST(&defp->list) = e_sectp;
			/* terminate list */
			*e_sectp->q.tqe_prev = NULL;
@


1.28
log
@- mark up punctuation
- use more suitable macros where necessary
- a little grammar
- sort options and sync usage() (last part checked by henning)
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.27 2003/12/16 18:58:46 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.27 2003/12/16 18:58:46 millert Exp $";
d190 1
a190 1
		while ((e_defp = defp->list.tqh_first) != NULL) {
d198 2
a199 2
			    NULL : subp->list.tqh_first;
			for (; e_subp != NULL; e_subp = e_subp->q.tqe_next) {
d224 2
a225 3
		e_defp =
		    defp->list.tqh_first == NULL ? NULL : defp->list.tqh_first;
		for (; e_defp != NULL; e_defp = e_defp->q.tqe_next) {
d229 2
a230 2
			    NULL : subp->list.tqh_first;
			for (; e_subp != NULL; e_subp = e_subp->q.tqe_next) {
d240 1
a240 1
		while ((e_defp = defp->list.tqh_first) != NULL) {
d262 2
a263 2
			    NULL : subp->list.tqh_first;
			for (; e_subp != NULL; e_subp = e_subp->q.tqe_next) {
d282 1
a282 1
			ep->q.tqe_next = defp->list.tqh_first;
d284 1
a284 1
			defp->list.tqh_first = e_sectp;
d296 1
a296 2
		for (e_sectp = section->list.tqh_first;
		    e_sectp != NULL; e_sectp = e_sectp->q.tqe_next) {
d307 2
a308 2
			    NULL : subp->list.tqh_first;
			for (; e_subp != NULL; e_subp = e_subp->q.tqe_next) {
d421 2
a422 2
	e_tag = tag == NULL ? NULL : tag->list.tqh_first;
	for (; e_tag != NULL; e_tag = e_tag->q.tqe_next) {
d452 1
a452 1
			    NULL : sufp->list.tqh_first;
d454 1
a454 1
			    e_sufp != NULL; e_sufp = e_sufp->q.tqe_next) {
d467 1
a467 1
			    NULL : sufp->list.tqh_first;
d469 1
a469 1
			    e_sufp != NULL; e_sufp = e_sufp->q.tqe_next) {
d767 1
a767 1
	    NULL : missp->list.tqh_first;
d769 1
a769 1
		for (; ep != NULL; ep = ep->q.tqe_next) {
d779 2
a780 2
	    NULL : intmpp->list.tqh_first;
	for (; ep != NULL; ep = ep->q.tqe_next)
@


1.27
log
@Support MANPAGER environment variable plus some KNF I had in my tree.
Closes PR 3563
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.26 2003/06/10 22:20:48 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.26 2003/06/10 22:20:48 deraadt Exp $";
d795 3
a797 1
	    "[-s section] [-S subsection] [section] title ...\n", __progname);
a798 1
	(void)fprintf(stderr, "usage: %s -f command\n", __progname);
@


1.26
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.25 2003/06/03 02:56:12 millert Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.25 2003/06/03 02:56:12 millert Exp $";
d162 3
d709 1
a709 1
	if (!strncmp(p, "more", 4) && (!p[4] || isspace(p[4]))){
d713 1
a713 1
		if (!(name =malloc(len)))
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.24 2003/03/13 09:09:32 deraadt Exp $	*/
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.24 2003/03/13 09:09:32 deraadt Exp $";
d409 1
a409 4
manual(page, tag, pg)
	char *page;
	TAG *tag;
	glob_t *pg;
@


1.24
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.23 2002/12/08 16:50:07 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d43 1
a43 1
static char rcsid[] = "$OpenBSD: man.c,v 1.23 2002/12/08 16:50:07 millert Exp $";
@


1.23
log
@GNU semantics say that if optstring begins with '-' then
each non-option shall be treated as arguments to option '\1'.

BSD getopt match '-' in optstring with a '-' on the command line.
This is used to support deprecated options like "su -" that would
otherwise prevent the use of getopt().

Resolving this simply requires that the leading '-' be moved somewhere
else (I moved it to the end of optstring) since position within
optstring is not meaningful.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.22 2002/11/23 18:43:29 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.22 2002/11/23 18:43:29 espie Exp $";
d699 1
d716 2
a717 2
		if (!(name =
		    malloc(strlen(save) + 1 + sizeof("-s"))))
d719 1
a719 1
		(void)sprintf(name, "%s %s", save, "-s");
@


1.22
log
@let comment match reality. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.21 2002/09/17 19:37:39 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.21 2002/09/17 19:37:39 deraadt Exp $";
d112 1
a112 1
	while ((ch = getopt(argc, argv, "-aC:cfhkM:m:P:s:S:w")) != -1)
@


1.21
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.20 2002/02/16 21:27:48 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.20 2002/02/16 21:27:48 millert Exp $";
d141 2
a142 2
		 * The -f and -k options are backward compatible,
		 * undocumented ways of calling whatis(1) and apropos(1).
@


1.20
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.19 2001/11/17 03:09:44 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.19 2001/11/17 03:09:44 deraadt Exp $";
d88 1
a88 3
main(argc, argv)
	int argc;
	char *argv[];
d271 5
a275 2
				/* puts it at the end, should be at the top, but then the added
					entries would be in reverse order, fix later when all are added*/
d277 2
a278 1
				if (e_sectp == NULL) 	/* save first added, to-be the new top */
d283 6
a288 3
			ep->q.tqe_next = defp->list.tqh_first;	/* save original head			*/
			defp->list.tqh_first = e_sectp;			/* first added entry, new top */
			*e_sectp->q.tqe_prev = NULL; 				/* terminate list					*/
d537 1
a537 2
build_page(fmt, pathp)
	char *fmt, **pathp;
d621 1
a621 2
how(fname)
	char *fname;
d667 1
a667 2
cat(fname)
	char *fname;
d696 1
a696 2
check_pager(name)
	char *name;
d728 1
a728 2
jump(argv, flag, name)
	char **argv, *flag, *name;
d748 1
a748 2
onsig(signo)
	int signo;
d750 1
a750 1
	(void)cleanup();
d764 1
a764 1
cleanup()
d795 1
a795 1
usage()
@


1.19
log
@make signal handler safe, by blocking signals around the things that it cares about; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.18 2001/08/18 21:59:37 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.18 2001/08/18 21:59:37 deraadt Exp $";
d75 9
a83 9
static void	 build_page __P((char *, char **));
static void	 cat __P((char *));
static char	*check_pager __P((char *));
static int	 cleanup __P((void));
static void	 how __P((char *));
static void	 jump __P((char **, char *, char *));
static int	 manual __P((char *, TAG *, glob_t *));
static void	 onsig __P((int));
static void	 usage __P((void));
@


1.18
log
@whack strcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.17 2001/04/10 02:32:33 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.17 2001/04/10 02:32:33 millert Exp $";
d85 2
d327 4
d509 4
d522 1
d541 1
d573 1
d576 1
d757 1
a757 1
	exit (1);
@


1.17
log
@space police + pet peeves
use memcpy() not memmove() when we don't care about overlapping segments
use puts(foo) instead of print("%s\n", foo)
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.16 2001/01/31 19:26:51 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.16 2001/01/31 19:26:51 deraadt Exp $";
d572 1
a572 1
	(void)strcpy(tpath, _PATH_TMPFILE);
@


1.16
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.15 1999/10/18 01:46:36 aaron Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.15 1999/10/18 01:46:36 aaron Exp $";
d163 1
a163 1
	if (!f_cat && !f_how && !f_where)
d170 1
d257 1
a257 1
	 *    the machine. 
d273 1
a273 1
				TAILQ_INSERT_TAIL(&defp->list, ep, q);  
d283 1
a283 1
	}	
d357 1
a357 1
			(void)printf("%s\n", *ap);
d361 1
a361 1
		
d378 1
a378 1
	memmove(p, pager, len);
d385 1
a385 1
		memmove(p, *ap, len);
d516 1
a516 1
/* 
d538 1
a538 1
        * Historically man chdir'd to the root of the man tree. 
d546 1
a546 1
 
d550 1
a550 1
 
d633 2
a634 1
			for(; lcnt; --lcnt)
d636 3
a638 1
			for (p = buf; isspace(*p); ++p);
d687 1
a687 1
	 * PAGER = "mypager /usr/ucb/more"
d701 1
a701 1
		    malloc((u_int)(strlen(save) + 1 + sizeof("-s")))))
d729 1
a729 1
/* 
@


1.15
log
@Add a help(1) man page -- help for new users and administrators.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.14 1999/07/28 01:17:56 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.14 1999/07/28 01:17:56 deraadt Exp $";
d564 2
a565 1
	for (; *fmt && isspace(*fmt); ++fmt);
d685 4
a688 2
	for (p = name; *p && !isspace(*p); ++p);
	for (; p > name && *p != '/'; --p);
@


1.14
log
@clarify
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.13 1999/06/10 22:38:02 pjanzen Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.13 1999/06/10 22:38:02 pjanzen Exp $";
d103 1
a103 1
		nargv[1] = "man";
@


1.13
log
@Handle PAGER in a manner consistent with the Single Unix Specification:
that is, use PAGER rather than "more" if it is defined and non-null, not
just if it is defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.12 1998/11/16 06:28:32 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.12 1998/11/16 06:28:32 deraadt Exp $";
d694 1
a694 1
		    malloc((u_int)(strlen(save) + sizeof("-s") + 1))))
@


1.12
log
@off by one string termination; wsanchez
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.11 1998/09/14 05:44:12 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.11 1998/09/14 05:44:12 deraadt Exp $";
d166 1
a166 1
		else if ((pager = getenv("PAGER")) != NULL)
@


1.11
log
@/usr/bin/help == man man"
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.10 1998/07/20 01:15:25 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.10 1998/07/20 01:15:25 deraadt Exp $";
d388 1
a388 1
	*p = '\0';
@


1.10
log
@finish off fixing PR 536 completely
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.9 1998/07/01 11:23:40 espie Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.9 1998/07/01 11:23:40 espie Exp $";
d62 1
d99 9
@


1.9
log
@
Fix confusing error message
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.8 1998/04/25 00:25:37 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.8 1998/04/25 00:25:37 millert Exp $";
d769 2
@


1.8
log
@fix usage
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.7 1998/03/09 23:20:13 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.7 1998/03/09 23:20:13 millert Exp $";
d70 1
d91 1
a91 1
	TAG *defp, *defnewp, *section, *sectnewp, *subp;
d745 5
a749 1
			warnx("no entry for %s in the manual.", ep->s);
@


1.7
log
@Add -s section for svr4 compat and -S subsection ala:
    man -s 4 -S alpha scc
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.6 1997/09/10 04:16:30 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.6 1997/09/10 04:16:30 deraadt Exp $";
d71 2
d762 2
a763 2
	(void)fprintf(stderr,
    "usage: man [-achw] [-C file] [-M path] [-m path] [section] title ...\n");
@


1.6
log
@path buf too small; tron@@lyssa.owl.de
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.5 1997/01/15 23:42:52 millert Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.5 1997/01/15 23:42:52 millert Exp $";
d93 1
a93 1
	char **ap, *cmd, *machine, *p, *p_add, *p_path, *pager, *slashp;
d96 1
d99 1
a99 1
	while ((ch = getopt(argc, argv, "-aC:cfhkM:m:P:w")) != -1)
d121 6
d161 2
a162 2
	/* Get the machine type. */
	if ((machine = getenv("MACHINE")) == NULL)
d201 1
a201 1
	if (argv[1] == NULL)
d203 6
a208 2
	else if ((section = getlist(*argv)) != NULL)
		++argv;
@


1.5
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.4 1996/09/16 02:26:10 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.4 1996/09/16 02:26:10 deraadt Exp $";
d385 1
a385 1
	char *p, buf[128];
@


1.4
log
@_PATH_TMP -> _PATH_TMPFILE; avoid /tmp//fooXXXX where possible too
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.3 1996/07/18 22:52:58 michaels Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.3 1996/07/18 22:52:58 michaels Exp $";
d98 1
a98 1
	while ((ch = getopt(argc, argv, "-aC:cfhkM:m:P:w")) != EOF)
@


1.3
log
@bugfix, paths added with -w should now be searched in the same order
as the rest, and not in reverse.
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.2 1996/06/26 05:37:01 deraadt Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.2 1996/06/26 05:37:01 deraadt Exp $";
d504 1
a504 1
	char buf[MAXPATHLEN], cmd[MAXPATHLEN], tpath[sizeof(_PATH_TMP)];
d546 1
a546 1
	(void)strcpy(tpath, _PATH_TMP);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: man.c,v 1.7 1995/09/28 06:05:34 tls Exp $	*/
d47 1
a47 1
static char rcsid[] = "$OpenBSD: man.c,v 1.7 1995/09/28 06:05:34 tls Exp $";
d232 1
a232 1
	 *    the machine.
d234 2
a235 1
	if (p_add != NULL)
d246 5
a250 1
				TAILQ_INSERT_HEAD(&defp->list, ep, q);
d253 6
a258 1

@


1.1
log
@Initial revision
@
text
@d1 1
d47 1
a47 1
static char rcsid[] = "$NetBSD: man.c,v 1.7 1995/09/28 06:05:34 tls Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

