head	1.102;
access;
symbols
	OPENBSD_6_1:1.102.0.4
	OPENBSD_6_1_BASE:1.102
	OPENBSD_6_0:1.101.0.2
	OPENBSD_6_0_BASE:1.101
	OPENBSD_5_9:1.100.0.2
	OPENBSD_5_9_BASE:1.100
	OPENBSD_5_8:1.94.0.6
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.94.0.2
	OPENBSD_5_7_BASE:1.94
	OPENBSD_5_6:1.92.0.6
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.91.0.2
	OPENBSD_5_4_BASE:1.91
	OPENBSD_5_3:1.90.0.6
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.90.0.4
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.2
	OPENBSD_5_0:1.89.0.2
	OPENBSD_5_0_BASE:1.89
	OPENBSD_4_9:1.88.0.4
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.84.0.12
	OPENBSD_4_6_BASE:1.84
	OPENBSD_4_5:1.84.0.8
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.84.0.6
	OPENBSD_4_4_BASE:1.84
	OPENBSD_4_3:1.84.0.4
	OPENBSD_4_3_BASE:1.84
	OPENBSD_4_2:1.84.0.2
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.83.0.2
	OPENBSD_4_1_BASE:1.83
	OPENBSD_4_0:1.82.0.8
	OPENBSD_4_0_BASE:1.82
	OPENBSD_3_9:1.82.0.6
	OPENBSD_3_9_BASE:1.82
	OPENBSD_3_8:1.82.0.4
	OPENBSD_3_8_BASE:1.82
	OPENBSD_3_7:1.82.0.2
	OPENBSD_3_7_BASE:1.82
	OPENBSD_3_6:1.81.0.2
	OPENBSD_3_6_BASE:1.81
	OPENBSD_3_5:1.76.0.2
	OPENBSD_3_5_BASE:1.76
	OPENBSD_3_4:1.75.0.2
	OPENBSD_3_4_BASE:1.75
	OPENBSD_3_3:1.63.0.2
	OPENBSD_3_3_BASE:1.63
	OPENBSD_3_2:1.57.0.2
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.102
date	2017.03.16.10.32.01;	author bluhm;	state Exp;
branches;
next	1.101;
commitid	kYAoVC2vixUfXe7V;

1.101
date	2016.06.01.16.57.48;	author tedu;	state Exp;
branches;
next	1.100;
commitid	0hGQp6C7l1vn45IO;

1.100
date	2016.01.11.19.26.04;	author tb;	state Exp;
branches;
next	1.99;
commitid	24k4E2DBG2zAaYnb;

1.99
date	2015.12.09.19.28.34;	author mmcc;	state Exp;
branches;
next	1.98;
commitid	33ajac6ZyR1t2xod;

1.98
date	2015.11.19.08.23.48;	author sthen;	state Exp;
branches;
next	1.97;
commitid	pGHyfcfzMIugSV5H;

1.97
date	2015.11.18.19.59.24;	author sthen;	state Exp;
branches;
next	1.96;
commitid	FWmnOfKBv6gdTQue;

1.96
date	2015.11.17.14.51.42;	author benno;	state Exp;
branches;
next	1.95;
commitid	MLMij098jZenifCJ;

1.95
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	0Dp7Dy9FuNZesYo2;

1.94
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	yGZX28AeTChVE8eY;

1.93
date	2015.01.16.06.40.10;	author deraadt;	state Exp;
branches;
next	1.92;
commitid	Uu5nFG3wCl0LACBb;

1.92
date	2013.11.26.13.19.07;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2013.04.05.01.29.07;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2012.01.15.13.02.12;	author phessler;	state Exp;
branches;
next	1.89;

1.89
date	2011.05.19.05.11.39;	author lum;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.24.00.54.46;	author nicm;	state Exp;
branches;
next	1.87;

1.87
date	2010.03.20.15.15.45;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.27.23.59.40;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2009.09.10.13.03.35;	author millert;	state Exp;
branches;
next	1.84;

1.84
date	2007.03.20.03.50.39;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2006.12.11.20.50.54;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2004.09.14.22.25.33;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2004.07.11.17.21.21;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2004.05.10.05.32.16;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.09.19.21.15;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.06.22.23.04;	author millert;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.05.19.41.50;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.16.19.32.45;	author otto;	state Exp;
branches;
next	1.75;

1.75
date	2003.07.25.10.28.53;	author mpech;	state Exp;
branches;
next	1.74;

1.74
date	2003.07.01.23.43.12;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.26.21.59.10;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.17.21.56.25;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.10.22.58.45;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.09.20.43.44;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.09.20.29.10;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.09.20.21.36;	author millert;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.03.21.09.02;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.15.03.25.02;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2003.04.25.20.07.09;	author pvalchev;	state Exp;
branches;
next	1.63;

1.63
date	2003.02.12.19.17.36;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.25.05.16.50;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.25.05.13.02;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2002.12.23.00.09.52;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.11.27.22.56.16;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.11.07.15.25.13;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.21.23.19.43;	author millert;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2002.09.19.21.22.59;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.19.20.58.50;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.19.15.27.31;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.09.17.20.44.38;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.17.20.16.43;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.09.17.20.03.40;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.16.01.41.54;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.09.13.18.50.09;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.13.00.16.13;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.12.19.58.38;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.08.12.00.42.56;	author aaron;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.26.23.36.14;	author wcobb;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.16.21.27.50;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.27.18.17.38;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.24.19.53.22;	author marc;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.23.04.20.56;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.19.19.02.15;	author mpech;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.16.23.49.07;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.09.07.04.50;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.01.20.34.10;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.12.16.24.06;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.30.16.00.19;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.14.22.55.19;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.12.17.41.21;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.10.02.49.41;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	99.11.11.22.24.14;	author millert;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	99.11.09.03.28.41;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	99.11.09.03.03.27;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	99.11.07.05.31.53;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	99.11.07.05.16.28;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	99.11.07.03.59.12;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.11.06.21.02.05;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.11.06.20.46.31;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.11.06.20.45.26;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.10.13.17.24.23;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.08.27.08.49.29;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	99.06.08.15.42.54;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	99.03.08.03.16.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.01.05.00.43.44;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.04.19.24.17;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.12.28.06.28.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.09.24.03.36.58;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.04.25.18.12.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.07.10.17.37.10;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.07.08.04.26.00;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	97.07.07.22.50.56;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.04.27.13.48.55;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.01.15.23.42.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.12.07.08.00.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.02.18.47.16;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.14.20.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.22.10.09.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.37.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.07.36.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.51;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2000.06.10.20.26.02;	author jason;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2000.10.06.21.16.16;	author jason;	state Exp;
branches;
next	;

1.57.2.1
date	2002.11.15.19.16.29;	author millert;	state Exp;
branches;
next	;


desc
@@


1.102
log
@syslogd(8) -Z generates log files with time in ISO format and UTC.
newsyslog(8) still used the traditional BSD syslog timstamps in
local time zone.  Convert the latter to the new format unconditionally.
It is usefull to have a distinct timestamp including the year at
the beginning of every logfile.
OK deraadt@@ jung@@
@
text
@/*	$OpenBSD: newsyslog.c,v 1.101 2016/06/01 16:57:48 tedu Exp $	*/

/*
 * Copyright (c) 1999, 2002, 2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */

/*
 * Copyright (c) 1997, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This file contains changes from the Open Software Foundation.
 */

/*
 * Copyright 1988, 1989 by the Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for any purpose and without fee is
 * hereby granted, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation,
 * and that the names of M.I.T. and the M.I.T. S.I.P.B. not be
 * used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * M.I.T. and the M.I.T. S.I.P.B. make no representations about
 * the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 */

/*
 *      newsyslog - roll over selected logs at the appropriate time,
 *              keeping the specified number of backup files around.
 *
 */

#define CONF "/etc/newsyslog.conf"
#define PIDFILE "/var/run/syslog.pid"
#define COMPRESS "/usr/bin/gzip"
#define COMPRESS_POSTFIX ".gz"
#define STATS_DIR "/var/run"
#define SENDMAIL "/usr/sbin/sendmail"

#include <sys/param.h>	/* DEV_BSIZE */
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define CE_ROTATED	0x01		/* Log file has been rotated */
#define CE_COMPACT	0x02		/* Compact the archived log files */
#define CE_BINARY	0x04		/* Logfile is in binary, don't add */
					/* status messages */
#define CE_MONITOR	0x08		/* Monitor for changes */
#define CE_FOLLOW	0x10		/* Follow symbolic links */
#define CE_TRIMAT	0x20		/* Trim at a specific time */

#define	MIN_PID		2		/* Don't touch pids lower than this */
#define	MIN_SIZE	256		/* Don't rotate if smaller (in bytes) */

#define	DPRINTF(x)	do { if (verbose) printf x ; } while (0)

struct conf_entry {
	char    *log;		/* Name of the log */
	char    *logbase;	/* Basename of the log */
	char    *backdir;	/* Directory in which to store backups */
	uid_t   uid;		/* Owner of log */
	gid_t   gid;		/* Group of log */
	int     numlogs;	/* Number of logs to keep */
	off_t   size;		/* Size cutoff to trigger trimming the log */
	int     hours;		/* Hours between log trimming */
	time_t  trim_at;	/* Specific time at which to do trimming */
	mode_t  permissions;	/* File permissions on the log */
	int	signal;		/* Signal to send (defaults to SIGHUP) */
	int     flags;		/* Flags (CE_COMPACT & CE_BINARY)  */
	char	*whom;		/* Whom to notify if logfile changes */
	char	*pidfile;	/* Path to file containing pid to signal */
	char	*runcmd;	/* Command to run instead of sending a signal */
	struct conf_entry *next; /* Linked list pointer */
};

struct pidinfo {
	char	*file;
	int	signal;
};

int	verbose = 0;		/* Print out what's going on */
int	needroot = 1;		/* Root privs are necessary */
int	noaction = 0;		/* Don't do anything, just show it */
int	monitormode = 0;	/* Don't do monitoring by default */
int	force = 0;		/* Force the logs to be rotated */
char	*conf = CONF;		/* Configuration file to use */
time_t	timenow;
char	hostname[HOST_NAME_MAX+1]; /* Hostname */
char	daytime[33];		/* timenow in human readable form */
char	*arcdir;		/* Dir to put archives in (if it exists) */

FILE   *openmail(void);
char   *lstat_log(char *, size_t, int);
char   *missing_field(char *, char *, int);
char   *sob(char *);
char   *son(char *);
int	age_old_log(struct conf_entry *);
int	domonitor(struct conf_entry *);
int	isnumberstr(char *);
int	log_trim(char *);
int	movefile(char *, char *, uid_t, gid_t, mode_t);
int	stat_suffix(char *, size_t, char *, struct stat *,
	    int (*)(const char *, struct stat *));
off_t	sizefile(struct stat *);
struct conf_entry *
	parse_file(int *);
time_t	parse8601(char *);
time_t	parseDWM(char *);
void	child_killer(int);
void	compress_log(struct conf_entry *);
void	do_entry(struct conf_entry *);
void	dotrim(struct conf_entry *);
void	rotate(struct conf_entry *, const char *);
void	parse_args(int, char **);
void	run_command(char *);
void	send_signal(char *, int);
void	usage(void);

int
main(int argc, char **argv)
{
	struct conf_entry *p, *q, *x, *y;
	struct pidinfo *pidlist, *pl;
	int status, listlen;
	char **av;
	
	parse_args(argc, argv);
	argc -= optind;
	argv += optind;

	if (needroot && getuid() && geteuid())
		errx(1, "You must be root.");

	p = parse_file(&listlen);
	if (argc > 0) {
		/* Only rotate specified files. */
		x = y = NULL;
		listlen = 0;
		for (av = argv; *av; av++) {
			for (q = p; q; q = q->next)
				if (strcmp(*av, q->log) == 0) {
					if (x == NULL)
						x = y = q;
					else {
						y->next = q;
						y = q;
					}
					listlen++;
					break;
				}
			if (q == NULL)
				warnx("%s: %s not found", conf, *av);
		}
		if (x == NULL)
			errx(1, "%s: no specified log files", conf);
		y->next = NULL;
		p = x;
	}

	pidlist = calloc(listlen + 1, sizeof(struct pidinfo));
	if (pidlist == NULL)
		err(1, "calloc");

	signal(SIGCHLD, child_killer);

	/* Step 1, rotate all log files */
	for (q = p; q; q = q->next)
		do_entry(q);

	/* Step 2, make a list of unique pid files */
	for (q = p, pl = pidlist; q; ) {
		if (q->flags & CE_ROTATED) {
			struct pidinfo *pltmp;

			for (pltmp = pidlist; pltmp < pl; pltmp++) {
				if ((q->pidfile && pltmp->file &&
				    strcmp(pltmp->file, q->pidfile) == 0 &&
				    pltmp->signal == q->signal) ||
				    (q->runcmd && pltmp->file &&
				    strcmp(q->runcmd, pltmp->file) == 0))
					break;
			}
			if (pltmp == pl) {	/* unique entry */
				if (q->runcmd) {
					pl->file = q->runcmd;
					pl->signal = -1;
				} else {
					pl->file = q->pidfile;
					pl->signal = q->signal;
				}
				pl++;
			}
		}
		q = q->next;
	}

	/* Step 3, send a signal or run a command */
	for (pl--; pl >= pidlist; pl--) {
		if (pl->file != NULL) {
			if (pl->signal == -1)
				run_command(pl->file);
			else
				send_signal(pl->file, pl->signal);
		}
	}
	if (!noaction)
		sleep(5);

	/* Step 4, compress the log.0 file if configured to do so and free */
	while (p) {
		if ((p->flags & CE_COMPACT) && (p->flags & CE_ROTATED) &&
		    p->numlogs > 0)
			compress_log(p);
		q = p;
		p = p->next;
		free(q);
	}

	/* Wait for children to finish, then exit */
	while (waitpid(-1, &status, 0) != -1)
		;
	exit(0);
}

void
do_entry(struct conf_entry *ent)
{
	struct stat sb;
	int modhours;
	off_t size;

	if (lstat(ent->log, &sb) != 0)
		return;
	if (!S_ISREG(sb.st_mode) &&
	    (!S_ISLNK(sb.st_mode) || !(ent->flags & CE_FOLLOW))) {
		DPRINTF(("--> not a regular file, skipping\n"));
		return;
	}
	if (S_ISLNK(sb.st_mode) && stat(ent->log, &sb) != 0) {
		DPRINTF(("--> link target does not exist, skipping\n"));
		return;
	}
	if (ent->uid == (uid_t)-1)
		ent->uid = sb.st_uid;
	if (ent->gid == (gid_t)-1)
		ent->gid = sb.st_gid;

	DPRINTF(("%s <%d%s%s%s%s>: ", ent->log, ent->numlogs,
	    (ent->flags & CE_COMPACT) ? "Z" : "",
	    (ent->flags & CE_BINARY) ? "B" : "",
	    (ent->flags & CE_FOLLOW) ? "F" : "",
	    (ent->flags & CE_MONITOR) && monitormode ? "M" : ""));
	size = sizefile(&sb);
	modhours = age_old_log(ent);
	if (ent->flags & CE_TRIMAT && !force) {
		if (timenow < ent->trim_at ||
		    difftime(timenow, ent->trim_at) >= 60 * 60) {
			DPRINTF(("--> will trim at %s",
			    ctime(&ent->trim_at)));
			return;
		} else if (ent->hours <= 0) {
			DPRINTF(("--> time is up\n"));
		}
	}
	if (ent->size > 0)
		DPRINTF(("size (KB): %.2f [%d] ", size / 1024.0,
		    (int)(ent->size / 1024)));
	if (ent->hours > 0)
		DPRINTF(("age (hr): %d [%d] ", modhours, ent->hours));
	if (monitormode && (ent->flags & CE_MONITOR) && domonitor(ent))
		DPRINTF(("--> monitored\n"));
	else if (!monitormode &&
	    (force || (ent->size > 0 && size >= ent->size) ||
	    (ent->hours <= 0 && (ent->flags & CE_TRIMAT)) ||
	    (ent->hours > 0 && (modhours >= ent->hours || modhours < 0)
	    && ((ent->flags & CE_BINARY) || size >= MIN_SIZE)))) {
		DPRINTF(("--> trimming log....\n"));
		if (noaction && !verbose)
			printf("%s <%d%s%s%s>\n", ent->log,
			    ent->numlogs,
			    (ent->flags & CE_COMPACT) ? "Z" : "",
			    (ent->flags & CE_BINARY) ? "B" : "",
			    (ent->flags & CE_FOLLOW) ? "F" : "");
		dotrim(ent);
		ent->flags |= CE_ROTATED;
	} else
		DPRINTF(("--> skipping\n"));
}

/* Run the specified command */
void
run_command(char *cmd)
{
	if (noaction)
		(void)printf("run %s\n", cmd);
	else
		system(cmd);
}

/* Send a signal to the pid specified by pidfile */
void
send_signal(char *pidfile, int signal)
{
	char line[BUFSIZ], *ep, *err;
	pid_t pid;
	long lval;
	FILE *f;

	if ((f = fopen(pidfile, "r")) == NULL) {
		warn("can't open %s", pidfile);
		return;
	}

	pid = 0;
	errno = 0;
	err = NULL;
	if (fgets(line, sizeof(line), f)) {
		lval = strtol(line, &ep, 10);
		if (line[0] == '\0' || (*ep != '\0' && *ep != '\n'))
			err = "invalid number in";
		else if (lval < 0 || (errno == ERANGE && lval == LONG_MAX))
			err = "out of range number in";
		else if (lval == 0)
			err = "no number in";
		else if (lval < MIN_PID)
			err = "preposterous process number in";
		else
			pid = (pid_t)lval;
	} else {
		if (errno == 0)
			err = "empty";
		else
			err = "error reading";
	}
	(void)fclose(f);

	if (err)
		warnx("%s pid file: %s", err, pidfile);
	else if (noaction)
		(void)printf("kill -%s %ld\n", sys_signame[signal], (long)pid);
	else if (kill(pid, signal))
		warnx("warning - could not send SIG%s to PID from pid file %s",
		    sys_signame[signal], pidfile);
}

void
parse_args(int argc, char **argv)
{
	struct timeval now;
	struct tm *tm;
	size_t l;
	char *p;
	int ch;

	gettimeofday(&now, NULL);
	timenow = now.tv_sec;
	tm = gmtime(&now.tv_sec);
	l = strftime(daytime, sizeof(daytime), "%FT%T", tm);
	snprintf(daytime + l, sizeof(daytime) - l, ".%03ldZ",
	    now.tv_usec / 1000);

	/* Let's get our hostname */
	(void)gethostname(hostname, sizeof(hostname));

	/* Truncate domain */
	if ((p = strchr(hostname, '.')) != NULL)
		*p = '\0';

	while ((ch = getopt(argc, argv, "Fmnrva:f:")) != -1) {
		switch (ch) {
		case 'a':
			arcdir = optarg;
			break;
		case 'n':
			noaction = 1;	/* This implies needroot as off */
			/* fall through */
		case 'r':
			needroot = 0;
			break;
		case 'v':
			verbose = 1;
			break;
		case 'f':
			conf = optarg;
			break;
		case 'm':
			monitormode = 1;
			break;
		case 'F':
			force = 1;
			break;
		default:
			usage();
		}
	}
	if (monitormode && force)
		errx(1, "cannot specify both -m and -F flags");
}

void
usage(void)
{
	extern const char *__progname;

	(void)fprintf(stderr, "usage: %s [-Fmnrv] [-a directory] "
	    "[-f config_file] [log ...]\n", __progname);
	exit(1);
}

/*
 * Parse a configuration file and return a linked list of all the logs
 * to process
 */
struct conf_entry *
parse_file(int *nentries)
{
	char line[BUFSIZ], *parse, *q, *errline, *group, *tmp, *ep;
	struct conf_entry *working = NULL, *first = NULL;
	struct passwd *pwd;
	struct group *grp;
	struct stat sb;
	int lineno;
	FILE *f;
	long l;

	if (strcmp(conf, "-") == 0)
		f = stdin;
	else if ((f = fopen(conf, "r")) == NULL)
		err(1, "can't open %s", conf);

	*nentries = 0;
	for (lineno = 1; fgets(line, sizeof(line), f); lineno++) {
		tmp = sob(line);
		if (*tmp == '\0' || *tmp == '#')
			continue;
		errline = strdup(tmp);
		if (errline == NULL)
			err(1, "strdup");
		(*nentries)++;
		if (!first) {
			working = malloc(sizeof(struct conf_entry));
			if (working == NULL)
				err(1, "malloc");
			first = working;
		} else {
			working->next = malloc(sizeof(struct conf_entry));
			if (working->next == NULL)
				err(1, "malloc");
			working = working->next;
		}

		q = parse = missing_field(sob(line), errline, lineno);
		*(parse = son(line)) = '\0';
		working->log = strdup(q);
		if (working->log == NULL)
			err(1, "strdup");

		if ((working->logbase = strrchr(working->log, '/')) != NULL)
			working->logbase++;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		if ((group = strchr(q, ':')) != NULL ||
		    (group = strrchr(q, '.')) != NULL)  {
			*group++ = '\0';
			if (*q) {
				if (!(isnumberstr(q))) {
					if ((pwd = getpwnam(q)) == NULL)
						errx(1, "%s:%d: unknown user: %s",
						    conf, lineno, q);
					working->uid = pwd->pw_uid;
				} else
					working->uid = atoi(q);
			} else
				working->uid = (uid_t)-1;
			
			q = group;
			if (*q) {
				if (!(isnumberstr(q))) {
					if ((grp = getgrnam(q)) == NULL)
						errx(1, "%s:%d: unknown group: %s",
						    conf, lineno, q);
					working->gid = grp->gr_gid;
				} else
					working->gid = atoi(q);
			} else
				working->gid = (gid_t)-1;
			
			q = parse = missing_field(sob(++parse), errline, lineno);
			*(parse = son(parse)) = '\0';
		} else {
			working->uid = (uid_t)-1;
			working->gid = (gid_t)-1;
		}

		l = strtol(q, &ep, 8);
		if (*ep != '\0' || l < 0 || l > ALLPERMS)
			errx(1, "%s:%d: bad permissions: %s", conf, lineno, q);
		working->permissions = (mode_t)l;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		l = strtol(q, &ep, 10);
		if (*ep != '\0' || l < 0 || l >= INT_MAX)
			errx(1, "%s:%d: bad number: %s", conf, lineno, q);
		working->numlogs = (int)l;

		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		if (isdigit((unsigned char)*q))
			working->size = atoi(q) * 1024;
		else
			working->size = -1;
		
		working->flags = 0;
		q = parse = missing_field(sob(++parse), errline, lineno);
		*(parse = son(parse)) = '\0';
		l = strtol(q, &ep, 10);
		if (l < 0 || l >= INT_MAX)
			errx(1, "%s:%d: interval out of range: %s", conf,
			    lineno, q);
		working->hours = (int)l;
		switch (*ep) {
		case '\0':
			break;
		case '@@':
			working->trim_at = parse8601(ep + 1);
			if (working->trim_at == (time_t) - 1)
				errx(1, "%s:%d: bad time: %s", conf, lineno, q);
			working->flags |= CE_TRIMAT;
			break;
		case '$':
			working->trim_at = parseDWM(ep + 1);
			if (working->trim_at == (time_t) - 1)
				errx(1, "%s:%d: bad time: %s", conf, lineno, q);
			working->flags |= CE_TRIMAT;
			break;
		case '*':
			if (q == ep)
				break;
			/* FALLTHROUGH */
		default:
			errx(1, "%s:%d: bad interval/at: %s", conf, lineno, q);
			break;
		}

		q = sob(++parse);	/* Optional field */
		if (*q == 'Z' || *q == 'z' || *q == 'B' || *q == 'b' ||
		    *q == 'M' || *q == 'm') {
			*(parse = son(q)) = '\0';
			while (*q) {
				switch (*q) {
				case 'Z':
				case 'z':
					working->flags |= CE_COMPACT;
					break;
				case 'B':
				case 'b':
					working->flags |= CE_BINARY;
					break;
				case 'M':
				case 'm':
					working->flags |= CE_MONITOR;
					break;
				case 'F':
				case 'f':
					working->flags |= CE_FOLLOW;
					break;
				default:
					errx(1, "%s:%d: illegal flag: `%c'",
					    conf, lineno, *q);
					break;
				}
				q++;
			}
		} else
			parse--;	/* no flags so undo */

		working->pidfile = PIDFILE;
		working->signal = SIGHUP;
		working->runcmd = NULL;
		working->whom = NULL;
		for (;;) {
			q = parse = sob(++parse);	/* Optional field */
			if (q == NULL || *q == '\0')
				break;
			if (*q == '/') {
				*(parse = son(parse)) = '\0';
				if (strlen(q) >= PATH_MAX)
					errx(1, "%s:%d: pathname too long: %s",
					    conf, lineno, q);
				working->pidfile = strdup(q);
				if (working->pidfile == NULL)
					err(1, "strdup");
			} else if (*q == '"' && (tmp = strchr(q + 1, '"'))) {
				*(parse = tmp) = '\0';
				if (*++q != '\0') {
					working->runcmd = strdup(q);
					if (working->runcmd == NULL)
						err(1, "strdup");
				}
				working->pidfile = NULL;
				working->signal = -1;
			} else if (strncmp(q, "SIG", 3) == 0) {
				int i;

				*(parse = son(parse)) = '\0';
				for (i = 1; i < NSIG; i++) {
					if (!strcmp(sys_signame[i], q + 3)) {
						working->signal = i;
						break;
					}
				}
				if (i == NSIG)
					errx(1, "%s:%d: unknown signal: %s",
					    conf, lineno, q);
			} else if (working->flags & CE_MONITOR) {
				*(parse = son(parse)) = '\0';
				working->whom = strdup(q);
				if (working->whom == NULL)
					err(1, "strdup");
			} else
				errx(1, "%s:%d: unrecognized field: %s",
				    conf, lineno, q);
		}
		free(errline);

		if ((working->flags & CE_MONITOR) && working->whom == NULL)
			errx(1, "%s:%d: missing monitor notification field",
			    conf, lineno);

		/* If there is an arcdir, set working->backdir. */
		if (arcdir != NULL && working->logbase != NULL) {
			if (*arcdir == '/') {
				/* Fully qualified arcdir */
				working->backdir = arcdir;
			} else {
				/* arcdir is relative to log's parent dir */
				*(working->logbase - 1) = '\0';
				if ((asprintf(&working->backdir, "%s/%s",
				    working->log, arcdir)) == -1)
					err(1, "malloc");
				*(working->logbase - 1) = '/';
			}
			/* Ignore arcdir if it doesn't exist. */
			if (stat(working->backdir, &sb) != 0 ||
			    !S_ISDIR(sb.st_mode)) {
				if (working->backdir != arcdir)
					free(working->backdir);
				working->backdir = NULL;
			}
		} else
			working->backdir = NULL;

		/* Make sure we can't oflow PATH_MAX */
		if (working->backdir != NULL) {
			if (snprintf(line, sizeof(line), "%s/%s.%d%s",
			    working->backdir, working->logbase,
			    working->numlogs, COMPRESS_POSTFIX) >= PATH_MAX)
				errx(1, "%s:%d: pathname too long: %s",
				    conf, lineno, q);
		} else {
			if (snprintf(line, sizeof(line), "%s.%d%s",
			    working->log, working->numlogs, COMPRESS_POSTFIX)
			    >= PATH_MAX)
				errx(1, "%s:%d: pathname too long: %s",
				    conf, lineno, working->log);
		}
	}
	if (working)
		working->next = NULL;
	(void)fclose(f);
	return (first);
}

char *
missing_field(char *p, char *errline, int lineno)
{
	if (p == NULL || *p == '\0') {
		warnx("%s:%d: missing field", conf, lineno);
		fputs(errline, stderr);
		exit(1);
	}
	return (p);
}

void
rotate(struct conf_entry *ent, const char *oldlog)
{
	char file1[PATH_MAX], file2[PATH_MAX], *suffix;
	int numdays = ent->numlogs - 1;
	int done = 0;

	/* Remove old logs */
	do {
		(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
		(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog,
		    numdays, COMPRESS_POSTFIX);
		if (noaction) {
			printf("\trm -f %s %s\n", file1, file2);
			done = access(file1, 0) && access(file2, 0);
		} else {
			done = unlink(file1) && unlink(file2);
		}
		numdays++;
	} while (done == 0);

	/* Move down log files */
	for (numdays = ent->numlogs - 2; numdays >= 0; numdays--) {
		/*
		 * If both the compressed archive and the non-compressed archive
		 * exist, we decide which to rotate based on the CE_COMPACT flag
		 */
		(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
		suffix = lstat_log(file1, sizeof(file1), ent->flags);
		if (suffix == NULL)
			continue;
		(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog,
		    numdays + 1, suffix);

		if (noaction) {
			printf("\tmv %s %s\n", file1, file2);
			printf("\tchmod %o %s\n", ent->permissions, file2);
			printf("\tchown %u:%u %s\n", ent->uid, ent->gid, file2);
		} else {
			if (rename(file1, file2))
				warn("can't mv %s to %s", file1, file2);
			if (chmod(file2, ent->permissions))
				warn("can't chmod %s", file2);
			if (chown(file2, ent->uid, ent->gid))
				warn("can't chown %s", file2);
		}
	}
}

void
dotrim(struct conf_entry *ent)
{
	char file1[PATH_MAX], file2[PATH_MAX], oldlog[PATH_MAX];
	int fd;

	/* Is there a separate backup dir? */
	if (ent->backdir != NULL)
		snprintf(oldlog, sizeof(oldlog), "%s/%s", ent->backdir,
		    ent->logbase);
	else
		strlcpy(oldlog, ent->log, sizeof(oldlog));

	if (ent->numlogs > 0)
		rotate(ent, oldlog);
	if (!noaction && !(ent->flags & CE_BINARY))
		(void)log_trim(ent->log);

	(void)snprintf(file2, sizeof(file2), "%s.XXXXXXXXXX", ent->log);
	if (noaction)  {
		printf("\tmktemp %s\n", file2);
	} else {
		if ((fd = mkstemp(file2)) < 0)
			err(1, "can't start '%s' log", file2);
		if (fchmod(fd, ent->permissions))
			err(1, "can't chmod '%s' log file", file2);
		if (fchown(fd, ent->uid, ent->gid))
			err(1, "can't chown '%s' log file", file2);
		(void)close(fd);
		/* Add status message */
		if (!(ent->flags & CE_BINARY) && log_trim(file2))
			err(1, "can't add status message to log '%s'", file2);
	}

	if (ent->numlogs == 0) {
		if (noaction)
			printf("\trm %s\n", ent->log);
		else if (unlink(ent->log))
			warn("can't rm %s", ent->log);
	} else {
		(void)snprintf(file1, sizeof(file1), "%s.0", oldlog);
		if (noaction) {
			printf("\tmv %s to %s\n", ent->log, file1);
			printf("\tchmod %o %s\n", ent->permissions, file1);
			printf("\tchown %u:%u %s\n", ent->uid, ent->gid, file1);
		} else if (movefile(ent->log, file1, ent->uid, ent->gid,
		    ent->permissions))
			warn("can't mv %s to %s", ent->log, file1);
	}

	/* Now move the new log file into place */
	if (noaction)
		printf("\tmv %s to %s\n", file2, ent->log);
	else if (rename(file2, ent->log))
		warn("can't mv %s to %s", file2, ent->log);
}

/* Log the fact that the logs were turned over */
int
log_trim(char *log)
{
	FILE    *f;

	if ((f = fopen(log, "a")) == NULL)
		return (-1);
	(void)fprintf(f, "%s %s newsyslog[%ld]: logfile turned over\n",
	    daytime, hostname, (long)getpid());
	if (fclose(f) == EOF)
		err(1, "log_trim: fclose");
	return (0);
}

/* Fork off compress or gzip to compress the old log file */
void
compress_log(struct conf_entry *ent)
{
	char *base, tmp[PATH_MAX];
	pid_t pid;

	if (ent->backdir != NULL)
		snprintf(tmp, sizeof(tmp), "%s/%s.0", ent->backdir,
		    ent->logbase);
	else
		snprintf(tmp, sizeof(tmp), "%s.0", ent->log);

	if ((base = strrchr(COMPRESS, '/')) == NULL)
		base = COMPRESS;
	else
		base++;
	if (noaction) {
		printf("%s %s\n", base, tmp);
		return;
	}
	pid = fork();
	if (pid < 0) {
		err(1, "fork");
	} else if (pid == 0) {
		(void)execl(COMPRESS, base, "-f", tmp, (char *)NULL);
		warn(COMPRESS);
		_exit(1);
	}
}

/* Return size in bytes of a file */
off_t
sizefile(struct stat *sb)
{
	/* For sparse files, return the size based on number of blocks used. */
	if (sb->st_size / DEV_BSIZE > sb->st_blocks)
		return (sb->st_blocks * DEV_BSIZE);
	else
		return (sb->st_size);
}

/* Return the age (in hours) of old log file (file.0), or -1 if none */
int
age_old_log(struct conf_entry *ent)
{
	char file[PATH_MAX];
	struct stat sb;

	if (ent->backdir != NULL)
		(void)snprintf(file, sizeof(file), "%s/%s.0", ent->backdir,
		    ent->logbase);
	else
		(void)snprintf(file, sizeof(file), "%s.0", ent->log);
	if (ent->flags & CE_COMPACT) {
		if (stat_suffix(file, sizeof(file), COMPRESS_POSTFIX, &sb,
		    stat) < 0 && stat(file, &sb) < 0)
			return (-1);
	} else {
		if (stat(file, &sb) < 0 && stat_suffix(file, sizeof(file),
		    COMPRESS_POSTFIX, &sb, stat) < 0)
			return (-1);
	}
	return ((int)(timenow - sb.st_mtime + 1800) / 3600);
}

/* Skip Over Blanks */
char *
sob(char *p)
{
	if (p == NULL)
		return(p);
	while (isspace((unsigned char)*p))
		p++;
	return (p);
}

/* Skip Over Non-Blanks */
char *
son(char *p)
{
	while (p && *p && !isspace((unsigned char)*p))
		p++;
	return (p);
}

/* Check if string is actually a number */
int
isnumberstr(char *string)
{
	while (*string) {
		if (!isdigit((unsigned char)*string++))
			return (0);
	}
	return (1);
}

int
domonitor(struct conf_entry *ent)
{
	char fname[PATH_MAX], *flog, *p, *rb = NULL;
	struct stat sb, tsb;
	off_t osize;
	FILE *fp;
	int rd;

	if (stat(ent->log, &sb) < 0)
		return (0);

	if (noaction) {
		if (!verbose)
			printf("%s: monitored\n", ent->log);
		return (1);
	}

	flog = strdup(ent->log);
	if (flog == NULL)
		err(1, "strdup");

	for (p = flog; *p != '\0'; p++) {
		if (*p == '/')
			*p = '_';
	}
	snprintf(fname, sizeof(fname), "%s/newsyslog.%s.size",
	    STATS_DIR, flog);

	/* ..if it doesn't exist, simply record the current size. */
	if ((sb.st_size == 0) || stat(fname, &tsb) < 0)
		goto update;

	fp = fopen(fname, "r");
	if (fp == NULL) {
		warn("%s", fname);
		goto cleanup;
	}
	if (fscanf(fp, "%lld\n", &osize) != 1) {
		fclose(fp);
		goto update;
	}

	fclose(fp);

	/* If the file is smaller, mark the entire thing as changed. */
	if (sb.st_size < osize)
		osize = 0;

	/* Now see if current size is larger. */
	if (sb.st_size > osize) {
		rb = malloc(sb.st_size - osize);
		if (rb == NULL)
			err(1, "malloc");

		/* Open logfile, seek. */
		fp = fopen(ent->log, "r");
		if (fp == NULL) {
			warn("%s", ent->log);
			goto cleanup;
		}
		fseek(fp, osize, SEEK_SET);
		rd = fread(rb, 1, sb.st_size - osize, fp);
		if (rd < 1) {
			warn("fread");
			fclose(fp);
			goto cleanup;
		}
		
		/* Send message. */
		fclose(fp);

		fp = openmail();
		if (fp == NULL) {
			warn("openmail");
			goto cleanup;
		}
		fprintf(fp, "Auto-Submitted: auto-generated\n");
		fprintf(fp, "To: %s\nSubject: LOGFILE NOTIFICATION: %s\n\n\n",
		    ent->whom, ent->log);
		fwrite(rb, 1, rd, fp);
		fputs("\n\n", fp);

		pclose(fp);
	}
update:
	/* Reopen for writing and update file. */
	fp = fopen(fname, "w");
	if (fp == NULL) {
		warn("%s", fname);
		goto cleanup;
	}
	fprintf(fp, "%lld\n", (long long)sb.st_size);
	fclose(fp);

cleanup:
	free(flog);
	free(rb);
	return (1);
}

FILE *
openmail(void)
{
	char *cmdbuf = NULL;
	FILE *ret;

	if (asprintf(&cmdbuf, "%s -t", SENDMAIL) != -1) {
		ret = popen(cmdbuf, "w");
		free(cmdbuf);
		return (ret);
	}
	return (NULL);
}

/* ARGSUSED */
void
child_killer(int signo)
{
	int save_errno = errno;
	int status;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	errno = save_errno;
}

int
stat_suffix(char *file, size_t size, char *suffix, struct stat *sp,
    int (*func)(const char *, struct stat *))
{
	size_t n;

	n = strlcat(file, suffix, size);
	if (n < size && func(file, sp) == 0)
		return (0);
	file[n - strlen(suffix)] = '\0';
	return (-1);
}

/*
 * lstat() a log, possibly appending a suffix; order is based on flags.
 * Returns the suffix appended (may be empty string) or NULL if no file.
 */
char *
lstat_log(char *file, size_t size, int flags)
{
	struct stat sb;

	if (flags & CE_COMPACT) {
		if (stat_suffix(file, size, COMPRESS_POSTFIX, &sb, lstat) == 0)
			return (COMPRESS_POSTFIX);
		if (lstat(file, &sb) == 0)
			return ("");
	} else {
		if (lstat(file, &sb) == 0)
			return ("");
		if (stat_suffix(file, size, COMPRESS_POSTFIX, &sb, lstat) == 0)
			return (COMPRESS_POSTFIX);

	}
	return (NULL);
}

/*
 * Parse a limited subset of ISO 8601. The specific format is as follows:
 *
 * [CC[YY[MM[DD]]]][THH[MM[SS]]]	(where `T' is the literal letter)
 *
 * We don't accept a timezone specification; missing fields (including timezone)
 * are defaulted to the current date but time zero.
 */
time_t
parse8601(char *s)
{
	struct tm tm, *tmp;
	char *t;
	long l;

	tmp = localtime(&timenow);
	tm = *tmp;

	tm.tm_hour = tm.tm_min = tm.tm_sec = 0;

	l = strtol(s, &t, 10);
	if (l < 0 || l >= INT_MAX || (*t != '\0' && *t != 'T'))
		return (-1);

	/*
	 * Now t points either to the end of the string (if no time was
	 * provided) or to the letter `T' which separates date and time in
	 * ISO 8601.  The pointer arithmetic is the same for either case.
	 */
	switch (t - s) {
	case 8:
		tm.tm_year = ((l / 1000000) - 19) * 100;
		l = l % 1000000;
	case 6:
		tm.tm_year -= tm.tm_year % 100;
		tm.tm_year += l / 10000;
		l = l % 10000;
	case 4:
		tm.tm_mon = (l / 100) - 1;
		l = l % 100;
	case 2:
		tm.tm_mday = l;
	case 0:
		break;
	default:
		return (-1);
	}

	/* sanity check */
	if (tm.tm_year < 70 || tm.tm_mon < 0 || tm.tm_mon > 12 ||
	    tm.tm_mday < 1 || tm.tm_mday > 31)
		return (-1);

	if (*t != '\0') {
		s = ++t;
		l = strtol(s, &t, 10);
		if (l < 0 || l >= INT_MAX ||
		    (*t != '\0' && !isspace((unsigned char)*t)))
			return (-1);

		switch (t - s) {
		case 6:
			tm.tm_sec = l % 100;
			l /= 100;
		case 4:
			tm.tm_min = l % 100;
			l /= 100;
		case 2:
			tm.tm_hour = l;
		case 0:
			break;
		default:
			return (-1);
		}

		/* sanity check */
		if (tm.tm_sec < 0 || tm.tm_sec > 60 || tm.tm_min < 0 ||
		    tm.tm_min > 59 || tm.tm_hour < 0 || tm.tm_hour > 23)
			return (-1);
	}
	return (mktime(&tm));
}

/*-
 * Parse a cyclic time specification, the format is as follows:
 *
 *	[Dhh] or [Wd[Dhh]] or [Mdd[Dhh]]
 *
 * to rotate a logfile cyclic at
 *
 *	- every day (D) within a specific hour (hh)	(hh = 0...23)
 *	- once a week (W) at a specific day (d)     OR	(d = 0..6, 0 = Sunday)
 *	- once a month (M) at a specific day (d)	(d = 1..31,l|L)
 *
 * We don't accept a timezone specification; missing fields
 * are defaulted to the current date but time zero.
 */
time_t
parseDWM(char *s)
{
	static int mtab[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	int WMseen = 0, Dseen = 0, nd;
	struct tm tm, *tmp;
	char *t;
	long l;

	tmp = localtime(&timenow);
	tm = *tmp;

	/* set no. of days per month */

	nd = mtab[tm.tm_mon];

	if (tm.tm_mon == 1) {
		if (((tm.tm_year + 1900) % 4 == 0) &&
		    ((tm.tm_year + 1900) % 100 != 0) &&
		    ((tm.tm_year + 1900) % 400 == 0)) {
			nd++;	/* leap year, 29 days in february */
		}
	}
	tm.tm_hour = tm.tm_min = tm.tm_sec = 0;

	for (;;) {
		switch (*s) {
		case 'D':
			if (Dseen)
				return (-1);
			Dseen++;
			s++;
			l = strtol(s, &t, 10);
			if (l < 0 || l > 23)
				return (-1);
			tm.tm_hour = l;
			break;

		case 'W':
			if (WMseen)
				return (-1);
			WMseen++;
			s++;
			l = strtol(s, &t, 10);
			if (l < 0 || l > 6)
				return (-1);
			if (l != tm.tm_wday) {
				int save;

				if (l < tm.tm_wday) {
					save = 6 - tm.tm_wday;
					save += (l + 1);
				} else {
					save = l - tm.tm_wday;
				}

				tm.tm_mday += save;

				if (tm.tm_mday > nd) {
					tm.tm_mon++;
					tm.tm_mday = tm.tm_mday - nd;
				}
			}
			break;

		case 'M':
			if (WMseen)
				return (-1);
			WMseen++;
			s++;
			if (tolower((unsigned char)*s) == 'l') {
				tm.tm_mday = nd;
				s++;
				t = s;
			} else {
				l = strtol(s, &t, 10);
				if (l < 1 || l > 31)
					return (-1);

				if (l > nd)
					return (-1);
				if (l < tm.tm_mday)
					tm.tm_mon++;
				tm.tm_mday = l;
			}
			break;

		default:
			return (-1);
			break;
		}

		if (*t == '\0' || isspace((unsigned char)*t))
			break;
		else
			s = t;
	}
	return (mktime(&tm));
}

/*
 * Move a file using rename(2) if possible and copying if not.
 */
int
movefile(char *from, char *to, uid_t owner_uid, gid_t group_gid, mode_t perm)
{
	FILE *src, *dst;
	int i;

	/* try rename(2) first */
	if (rename(from, to) == 0) {
		if (chmod(to, perm))
			warn("can't chmod %s", to);
		if (chown(to, owner_uid, group_gid))
			warn("can't chown %s", to);
		return (0);
	} else if (errno != EXDEV)
		return (-1);

	/* different filesystem, have to copy the file */
	if ((src = fopen(from, "r")) == NULL)
		err(1, "can't fopen %s for reading", from);
	if ((dst = fopen(to, "w")) == NULL)
		err(1, "can't fopen %s for writing", to);
	if (fchmod(fileno(dst), perm))
		err(1, "can't fchmod %s", to);
	if (fchown(fileno(dst), owner_uid, group_gid))
		err(1, "can't fchown %s", to);

	while ((i = getc(src)) != EOF) {
		if ((putc(i, dst)) == EOF)
			err(1, "error writing to %s", to);
	}

	if (ferror(src))
		err(1, "error reading from %s", from);
	if ((fclose(src)) != 0)
		err(1, "can't fclose %s", from);
	if ((fclose(dst)) != 0)
		err(1, "can't fclose %s", to);
	if ((unlink(from)) != 0)
		err(1, "can't unlink %s", from);

	return (0);
}
@


1.101
log
@instead of using the makefile to override ancient defaults in the code,
change the code to reflect modern reality.
ok deraadt millert natano
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.100 2016/01/11 19:26:04 tb Exp $	*/
d145 1
a145 1
char	*daytime;		/* timenow in human readable form */
d405 3
d411 6
a416 3
	timenow = time(NULL);
	daytime = ctime(&timenow) + 4;
	daytime[15] = '\0';
@


1.100
log
@ajacoutot@@ reported seeing

newsyslog: preposterous process number in pid file: /var/run/syslog.pid

in his log since syslogd ran as pid 2.

Nowadays only init runs with a reserved low pid, so decrease MIN_PID
from 4 to 2, as suggested by espie@@.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.99 2015/12/09 19:28:34 mmcc Exp $	*/
d74 6
a79 18
#ifndef CONF
#define CONF "/etc/newsyslog.conf" /* Configuration file */
#endif
#ifndef PIDFILE
#define PIDFILE "/etc/syslog.pid"
#endif
#ifndef COMPRESS
#define COMPRESS "/usr/bin/compress" /* File compression program */
#endif
#ifndef COMPRESS_POSTFIX
#define COMPRESS_POSTFIX ".Z"
#endif
#ifndef STATS_DIR
#define STATS_DIR "/etc"
#endif
#ifndef SENDMAIL
#define SENDMAIL "/usr/lib/sendmail"
#endif
a992 1
#ifdef QUAD_OFF_T
a993 3
#else
	if (fscanf(fp, "%ld\n", &osize) != 1) {
#endif	/* QUAD_OFF_T */
a1046 1
#ifdef QUAD_OFF_T
a1047 3
#else
	fprintf(fp, "%ld\n", (long)sb.st_size);
#endif	/* QUAD_OFF_T */
@


1.99
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.98 2015/11/19 08:23:48 sthen Exp $	*/
d120 1
a120 1
#define	MIN_PID		4		/* Don't touch pids lower than this */
@


1.98
log
@backout pledge completely for now, newsyslog needs chown() which is restricted
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.95 2015/08/20 22:32:41 deraadt Exp $	*/
d1072 1
a1072 2
	if (rb != NULL)
		free(rb);
@


1.97
log
@don't drop "pledge exec", it's needed for compression. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.96 2015/11/17 14:51:42 benno Exp $	*/
a193 3

	if (pledge("stdio rpath wpath cpath fattr exec proc", NULL) == -1)
		err(1,"pledge");
a198 3
	if (noaction && pledge("stdio rpath", NULL) == -1)
		err(1,"pledge");
	
@


1.96
log
@pledge() in newsyslog.
go deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.95 2015/08/20 22:32:41 deraadt Exp $	*/
a202 3
		err(1,"pledge");
	else if (!monitormode && pledge("stdio rpath wpath cpath fattr proc",
	    NULL) == -1)
@


1.95
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.94 2015/02/08 23:40:34 deraadt Exp $	*/
d194 3
d202 6
@


1.94
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.93 2015/01/16 06:40:10 deraadt Exp $	*/
d228 1
a228 1
	pidlist = (struct pidinfo *)calloc(listlen + 1, sizeof(struct pidinfo));
d1022 1
a1022 1
		rb = (char *) malloc(sb.st_size - osize);
@


1.93
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.92 2013/11/26 13:19:07 deraadt Exp $	*/
d437 1
a437 1
			noaction++; /* This implies needroot as off */
d443 1
a443 1
			verbose++;
d449 1
a449 1
			monitormode++;
d452 1
a452 1
			force++;
@


1.92
log
@unsigned char casts for ctype
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.91 2013/04/05 01:29:07 tedu Exp $	*/
d93 1
a93 1
#include <sys/param.h>
d156 1
a156 1
char	hostname[MAXHOSTNAMELEN]; /* Hostname */
d651 1
a651 1
				if (strlen(q) >= MAXPATHLEN)
d717 1
a717 1
		/* Make sure we can't oflow MAXPATHLEN */
d721 1
a721 1
			    working->numlogs, COMPRESS_POSTFIX) >= MAXPATHLEN)
d727 1
a727 1
			    >= MAXPATHLEN)
d752 1
a752 1
	char file1[MAXPATHLEN], file2[MAXPATHLEN], *suffix;
d801 1
a801 1
	char file1[MAXPATHLEN], file2[MAXPATHLEN], oldlog[MAXPATHLEN];
d874 1
a874 1
	char *base, tmp[MAXPATHLEN];
d916 1
a916 1
	char file[MAXPATHLEN];
d970 1
a970 1
	char fname[MAXPATHLEN], *flog, *p, *rb = NULL;
@


1.91
log
@rename a variable to hours so it doesn't look like time. ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.90 2012/01/15 13:02:12 phessler Exp $	*/
d572 1
a572 1
		if (isdigit(*q))
d942 1
a942 1
	while (isspace(*p))
d951 1
a951 1
	while (p && *p && !isspace(*p))
d961 1
a961 1
		if (!isdigit(*string++))
d1196 2
a1197 1
		if (l < 0 || l >= INT_MAX || (*t != '\0' && !isspace(*t)))
d1307 1
a1307 1
			if (tolower(*s) == 'l') {
d1329 1
a1329 1
		if (*t == '\0' || isspace(*t))
@


1.90
log
@When we only rotate a log file once a month, the "next rotate" output
shows the current month, even when that date has passed.

Fix to show the correct rotation date.

pointed out by jeremy@@
OK jeremy@@, guenther@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.89 2011/05/19 05:11:39 lum Exp $	*/
d297 1
a297 1
	int modtime;
d322 1
a322 1
	modtime = age_old_log(ent);
d337 1
a337 1
		DPRINTF(("age (hr): %d [%d] ", modtime, ent->hours));
d343 1
a343 1
	    (ent->hours > 0 && (modtime >= ent->hours || modtime < 0)
@


1.89
log
@sync manpage and comment with reality. From Nathanael Rensen.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.88 2010/07/24 00:54:46 nicm Exp $	*/
d1317 2
@


1.88
log
@Include pid file name in error message for a failed kill(). Prompted by
PR 6288.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.87 2010/03/20 15:15:45 schwarze Exp $	*/
d901 1
a901 1
/* Return size in kilobytes of a file */
@


1.87
log
@The newsyslog(8) utility used to keep one archived log file more than
requested; bug reported and patch sent by David Alten.
I resolved the problem in a different way, also fixing the following
additional issue:  When you reduced the "count" in newsyslog.conf(5),
the archived logs with higher numbers got orphaned and never deleted.
Nic fixed another off-by-one error in this patch, thanks!

"I like it; definitely cleaner"  DAlten at friedkin dot com
ok nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.86 2009/10/27 23:59:40 deraadt Exp $	*/
d410 2
a411 2
		warnx("warning - could not send SIG%s to daemon",
		    sys_signame[signal]);
@


1.86
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.85 2009/09/10 13:03:35 millert Exp $	*/
d753 2
a754 1
	int numdays = ent->numlogs;
d756 13
a768 11
	/* Remove oldest log (may not exist) */
	(void)snprintf(file1, sizeof(file1), "%s.%d", oldlog, numdays);
	(void)snprintf(file2, sizeof(file2), "%s.%d%s", oldlog, numdays,
	    COMPRESS_POSTFIX);

	if (noaction) {
		printf("\trm -f %s %s\n", file1, file2);
	} else {
		(void)unlink(file1);
		(void)unlink(file2);
	}
d771 1
a771 1
	while (numdays--) {
@


1.85
log
@Correct error message when fclose() fails.  From Brian Poole.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.84 2007/03/20 03:50:39 tedu Exp $	*/
a72 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.84 2007/03/20 03:50:39 tedu Exp $";
#endif /* not lint */
@


1.84
log
@remove some bogus *p tests from charles longeau
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.83 2006/12/11 20:50:54 deraadt Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.83 2006/12/11 20:50:54 deraadt Exp $";
d1336 1
a1336 1
 * Move a file using rename(2) is possible and copying if not.
d1372 2
a1374 2
	if ((fclose(dst)) != 0)
		err(1, "can't fclose %s", from);
@


1.83
log
@rfc 3834 support: Auto-Submitted: auto-generated on lots of things; from Tamas TEVESZ; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.82 2004/09/14 22:25:33 deraadt Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.82 2004/09/14 22:25:33 deraadt Exp $";
d941 3
a943 1
	while (p && *p && isspace(*p))
@


1.82
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.81 2004/07/11 17:21:21 millert Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.81 2004/07/11 17:21:21 millert Exp $";
d1047 1
@


1.81
log
@Make newsyslog(8) deal correctly with a count of 0 in newsyslog.conf.
Based on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.80 2004/05/10 05:32:16 deraadt Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.80 2004/05/10 05:32:16 deraadt Exp $";
d1089 1
@


1.80
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.79 2004/04/09 19:21:15 millert Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.79 2004/04/09 19:21:15 millert Exp $";
d185 1
d283 2
a284 1
		if ((p->flags & CE_COMPACT) && (p->flags & CE_ROTATED))
d754 1
a754 1
dotrim(struct conf_entry *ent)
d756 2
a757 10
	char    file1[MAXPATHLEN], file2[MAXPATHLEN];
	char    oldlog[MAXPATHLEN], *suffix;
	int	numdays = ent->numlogs, fd;

	/* Is there a separate backup dir? */
	if (ent->backdir != NULL)
		snprintf(oldlog, sizeof(oldlog), "%s/%s", ent->backdir,
		    ent->logbase);
	else
		strlcpy(oldlog, ent->log, sizeof(oldlog));
d797 17
d815 1
a815 1
		(void)log_trim(ent->log);  /* Report the trimming to the old log */
@


1.79
log
@If no user/group is specified for the log file in newsyslog.conf,
use the uid/gid of the existing log file.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.78 2004/04/06 22:23:04 millert Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.78 2004/04/06 22:23:04 millert Exp $";
d195 1
a196 1
	int status, listlen;
d298 1
a300 1
	struct stat sb;
d374 1
d376 1
a377 2
	char line[BUFSIZ], *ep, *err;
	long lval;
d419 1
a420 1
	char *p;
a480 1
	FILE *f;
d482 1
a482 4
	int lineno;
	long l;
	struct conf_entry *first = NULL;
	struct conf_entry *working = NULL;
d486 3
d505 1
a505 1
			working = (struct conf_entry *) malloc(sizeof(struct conf_entry));
d510 1
a510 1
			working->next = (struct conf_entry *) malloc(sizeof(struct conf_entry));
a544 1

d756 1
a756 2
	int     fd;
	int	numdays = ent->numlogs;
d864 1
a865 1
	char *base, tmp[MAXPATHLEN];
d906 1
a907 1
	char file[MAXPATHLEN];
d958 1
d960 1
a960 1
	char fname[MAXPATHLEN], *flog, *p, *rb = NULL;
a961 1
	off_t osize;
d1067 1
a1068 1
	char *cmdbuf = NULL;
d1137 1
a1138 1
	struct tm tm, *tmp;
d1175 2
a1176 2
	if (tm.tm_year < 70 || tm.tm_mon < 0 || tm.tm_mon > 12
	    || tm.tm_mday < 1 || tm.tm_mday > 31)
d1201 2
a1202 2
		if (tm.tm_sec < 0 || tm.tm_sec > 60 || tm.tm_min < 0
		    || tm.tm_min > 59 || tm.tm_hour < 0 || tm.tm_hour > 23)
d1225 3
a1228 1
	struct tm tm, *tmp;
a1229 4
	int nd;
	static int mtab[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	int WMseen = 0;
	int Dseen = 0;
@


1.78
log
@Set mode and ownership when renaming file -> file.0 like we do when
moving the file across filesystems or renaming from file.0 -> file.1.
Problem noticed by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.77 2004/04/05 19:41:50 millert Exp $	*/
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.77 2004/04/05 19:41:50 millert Exp $";
d176 1
a176 1
off_t	sizefile(char *);
d309 8
d323 1
a323 2

	size = sizefile(ent->log);
d325 8
a332 12
	if (size < 0) {
		DPRINTF(("does not exist.\n"));
	} else {
		if (ent->flags & CE_TRIMAT && !force) {
			if (timenow < ent->trim_at ||
			    difftime(timenow, ent->trim_at) >= 60 * 60) {
				DPRINTF(("--> will trim at %s",
				    ctime(&ent->trim_at)));
				return;
			} else if (ent->hours <= 0) {
				DPRINTF(("--> time is up\n"));
			}
a333 23
		if (ent->size > 0)
			DPRINTF(("size (KB): %.2f [%d] ", size / 1024.0,
			    (int)(ent->size / 1024)));
		if (ent->hours > 0)
			DPRINTF(("age (hr): %d [%d] ", modtime, ent->hours));
		if (monitormode && (ent->flags & CE_MONITOR) && domonitor(ent))
			DPRINTF(("--> monitored\n"));
		else if (!monitormode &&
		    (force || (ent->size > 0 && size >= ent->size) ||
		    (ent->hours <= 0 && (ent->flags & CE_TRIMAT)) ||
		    (ent->hours > 0 && (modtime >= ent->hours || modtime < 0)
		    && ((ent->flags & CE_BINARY) || size >= MIN_SIZE)))) {
			DPRINTF(("--> trimming log....\n"));
			if (noaction && !verbose)
				printf("%s <%d%s%s%s>\n", ent->log,
				    ent->numlogs,
				    (ent->flags & CE_COMPACT) ? "Z" : "",
				    (ent->flags & CE_BINARY) ? "B" : "",
				    (ent->flags & CE_FOLLOW) ? "F" : "");
			dotrim(ent);
			ent->flags |= CE_ROTATED;
		} else
			DPRINTF(("--> skipping\n"));
d335 23
d796 1
a796 3
			if (ent->uid != (uid_t)-1 || ent->gid != (gid_t)-1)
				printf("\tchown %u:%u %s\n",
				    ent->uid, ent->gid, file2);
d802 2
a803 3
			if (ent->uid != (uid_t)-1 || ent->gid != (gid_t)-1)
				if (chown(file2, ent->uid, ent->gid))
					warn("can't chown %s", file2);
a814 3
		if (ent->uid != (uid_t)-1 || ent->gid != (gid_t)-1)
			if (fchown(fd, ent->uid, ent->gid))
				err(1, "can't chown '%s' log file", file2);
d817 2
d835 1
a835 3
			if (ent->uid != (uid_t)-1 || ent->gid != (gid_t)-1)
				printf("\tchown %u:%u %s\n",
				    ent->uid, ent->gid, file1);
d896 1
a896 1
sizefile(char *file)
a897 5
	struct stat sb;

	if (stat(file, &sb) < 0)
		return (-1);

d899 2
a900 2
	if (sb.st_size / DEV_BSIZE > sb.st_blocks)
		return (sb.st_blocks * DEV_BSIZE);
d902 1
a902 1
		return (sb.st_size);
d1338 2
a1339 3
		if (owner_uid != (uid_t)-1 || group_gid != (gid_t)-1)
			if (chown(to, owner_uid, group_gid))
				warn("can't chown %s", to);
a1348 4
	if (owner_uid != (uid_t)-1 || group_gid != (gid_t)-1) {
		if (fchown(fileno(dst), owner_uid, group_gid))
			err(1, "can't fchown %s", to);
	}
d1351 2
@


1.77
log
@o use mode_t, not int for permissions.
o use strtol() instead of sscanf() to parse numbers in config file
This has been sitting in my tree for a long time...
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.76 2003/12/16 19:32:45 otto Exp $	*/
d17 1
d75 1
a75 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.76 2003/12/16 19:32:45 otto Exp $";
d833 1
a833 1
		if (noaction)
d835 5
a839 1
		else if (movefile(ent->log, file1, ent->uid, ent->gid,
d1343 9
a1351 3
	i = rename(from, to);
	if (i == 0 || errno != EXDEV)
		return (i);
@


1.76
log
@Avoid segmentation fault when empty commands are specified in the
config file; resolves PR 3578.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.75 2003/07/25 10:28:53 mpech Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.75 2003/07/25 10:28:53 mpech Exp $";
d138 1
a138 1
	int     permissions;	/* File permissions on the log */
d172 1
a172 1
int	movefile(char *, char *, uid_t, gid_t, int);
d558 2
a559 1
		if (!sscanf(q, "%o", &working->permissions))
d561 1
d565 2
a566 1
		if (!sscanf(q, "%d", &working->numlogs) || working->numlogs < 0)
d568 1
d1332 1
a1332 1
movefile(char *from, char *to, uid_t owner_uid, gid_t group_gid, int perm)
@


1.75
log
@When parser_file() fails, print correct line number.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.74 2003/07/01 23:43:12 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.74 2003/07/01 23:43:12 millert Exp $";
d246 1
a246 1
				if ((q->pidfile &&
d249 1
a249 1
				    (q->runcmd &&
d268 1
a268 1
	for (pl = pidlist; pl->file; pl++) {
@


1.74
log
@Add support for -a dirs on different filesystems.
From FreeBSD via S. Deinhard.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.73 2003/06/26 21:59:10 deraadt Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.73 2003/06/26 21:59:10 deraadt Exp $";
d493 1
a493 1
	for (lineno = 0; fgets(line, sizeof(line), f); lineno++) {
@


1.73
log
@more proto fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.72 2003/06/17 21:56:25 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.72 2003/06/17 21:56:25 millert Exp $";
d163 25
a187 23
void do_entry(struct conf_entry *);
void parse_args(int, char **);
void usage(void);
struct conf_entry *parse_file(int *);
char *missing_field(char *, char *, int);
void dotrim(struct conf_entry *);
int log_trim(char *);
void compress_log(struct conf_entry *);
off_t sizefile(char *);
int age_old_log(struct conf_entry *);
char *sob(char *);
char *son(char *);
int isnumberstr(char *);
int domonitor(struct conf_entry *);
FILE *openmail(void);
void child_killer(int);
void run_command(char *);
void send_signal(char *, int);
char *lstat_log(char *, size_t, int);
int stat_suffix(char *, size_t, char *, struct stat *,
    int (*)(const char *, struct stat *));
time_t parse8601(char *);
time_t parseDWM(char *);
d830 2
a831 1
		else if (rename(ent->log, file1))
d1322 43
@


1.72
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.71 2003/06/10 22:58:45 millert Exp $	*/
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.71 2003/06/10 22:58:45 millert Exp $";
d182 2
a183 1
int stat_suffix(char *, size_t, char *, struct stat *, int (*)());
d1089 2
a1090 1
stat_suffix(char *file, size_t size, char *suffix, struct stat *sp, int (*func)())
@


1.71
log
@Whoops, <= 0 should be < 0.  Problem noticed by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.70 2003/06/09 20:43:44 millert Exp $	*/
d10 10
a19 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
d74 1
a74 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.70 2003/06/09 20:43:44 millert Exp $";
@


1.70
log
@o replace remaining strtoul() with strtol() and check for < 0
o use %lld, not %qd in printf and scanf
o fix some whitespace issues
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.69 2003/06/09 20:29:10 millert Exp $	*/
d71 1
a71 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.69 2003/06/09 20:29:10 millert Exp $";
d571 1
a571 1
		if (l <= 0 || l >= INT_MAX)
@


1.69
log
@Use strtol() not strtoul() so we can detect a negative number in a pid file.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.68 2003/06/09 20:21:36 millert Exp $	*/
d71 1
a71 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.68 2003/06/09 20:21:36 millert Exp $";
d474 1
a474 1
	unsigned long ul;
d570 2
a571 2
		ul = strtoul(q, &ep, 10);
		if (ul > INT_MAX)
d574 1
a574 1
		working->hours = (int)ul;
d770 1
a770 1
		 * exist, we decide which to rotate based on the CE_COMPACT flag.
d806 1
a806 1
			    err(1, "can't chown '%s' log file", file2);
d989 1
a989 1
	if (fscanf(fp, "%qd\n", &osize) != 1) {
d1046 1
a1046 1
	fprintf(fp, "%qd\n", sb.st_size);
d1048 1
a1048 1
	fprintf(fp, "%ld\n", sb.st_size);
d1133 1
a1133 1
	unsigned long ul;
d1140 2
a1141 2
	ul = strtoul(s, &t, 10);
	if (*t != '\0' && *t != 'T')
d1151 2
a1152 2
		tm.tm_year = ((ul / 1000000) - 19) * 100;
		ul = ul % 1000000;
d1155 2
a1156 2
		tm.tm_year += ul / 10000;
		ul = ul % 10000;
d1158 2
a1159 2
		tm.tm_mon = (ul / 100) - 1;
		ul = ul % 100;
d1161 1
a1161 1
		tm.tm_mday = ul;
d1175 2
a1176 2
		ul = strtoul(s, &t, 10);
		if (*t != '\0' && !isspace(*t))
d1181 2
a1182 2
			tm.tm_sec = ul % 100;
			ul /= 100;
d1184 2
a1185 2
			tm.tm_min = ul % 100;
			ul /= 100;
d1187 1
a1187 1
			tm.tm_hour = ul;
@


1.68
log
@Need to include time.h to get ctime() proto.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.67 2003/06/03 21:09:02 deraadt Exp $	*/
d71 1
a71 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.67 2003/06/03 21:09:02 deraadt Exp $";
d367 1
a367 1
	unsigned long ulval;
d378 1
a378 1
		ulval = strtoul(line, &ep, 10);
d381 1
a381 1
		else if (errno == ERANGE && ulval == ULONG_MAX)
d383 1
a383 1
		else if (ulval == 0)
d385 1
a385 1
		else if (ulval < MIN_PID)
d388 1
a388 1
			pid = ulval;
@


1.67
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.66 2003/06/03 01:52:41 millert Exp $	*/
d71 1
a71 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.66 2003/06/03 01:52:41 millert Exp $";
d109 1
@


1.66
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.65 2003/05/15 03:25:02 millert Exp $	*/
a29 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jason Downs for the
 *      OpenBSD system.
 * 4. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
d71 1
a71 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.65 2003/05/15 03:25:02 millert Exp $";
@


1.65
log
@From Brian Poole
o fix typos
o remove a redundant check for verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.64 2003/04/25 20:07:09 pvalchev Exp $	*/
a4 1
 * All rights reserved.
d6 11
a16 21
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d78 1
a78 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.64 2003/04/25 20:07:09 pvalchev Exp $";
@


1.64
log
@check asprintf return value for error, as the pointer is not guaranteed
to be NULL in such case; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.63 2003/02/12 19:17:36 millert Exp $	*/
d84 1
a84 1
 *              keeping the a specified number of backup files around.
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.63 2003/02/12 19:17:36 millert Exp $";
d130 1
a130 1
#define CE_COMPACT	0x02		/* Compact the achived log files */
d133 1
a133 1
#define CE_MONITOR	0x08		/* Monitory for changes */
d135 1
a135 1
#define CE_TRIMAT	0x20		/* trim at a specific time */
d156 1
a156 1
	char	*pidfile;	/* Path to file containg pid to signal */
d173 1
a173 1
char	hostname[MAXHOSTNAMELEN]; /* hostname */
d175 1
a175 1
char	*arcdir;		/* dir to put archives in (if it exists) */
d337 1
a337 1
			} else if (verbose && ent->hours <= 0) {
d786 2
a787 2
		 * If both the compressed archive or the non-compressed archive
		 * exist, we one or the other based on the CE_COMPACT flag.
d1114 1
a1114 1
 * lstat() a log, possibily appending a suffix; order is based on flags.
@


1.63
log
@Add support for rotating files at a specific time; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.62 2003/01/25 05:16:50 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.62 2003/01/25 05:16:50 millert Exp $";
d1082 1
a1082 2
	asprintf(&cmdbuf, "%s -t", SENDMAIL);
	if (cmdbuf) {
@


1.62
log
@it is 2003 now
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.61 2003/01/25 05:13:02 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.61 2003/01/25 05:13:02 millert Exp $";
d135 1
d151 1
d197 2
d331 10
d350 1
d489 1
a489 1
	char line[BUFSIZ], *parse, *q, *errline, *group, *tmp;
d491 1
d535 2
a536 1
		if ((group = strchr(q, '.')) != NULL) {
d584 1
d587 28
a614 4
		if (isdigit(*q))
			working->hours = atoi(q);
		else
			working->hours = -1;
a615 1
		working->flags = 0;
d1136 196
@


1.61
log
@Move parsing of the monitor notification user with the rest of the
optional arguments and add some sanity checking (if the M flag is
specified a notification user must be specified as well).
Also make the -n flag work in conjunction with -m and make verbose
mode more monitor-friendly.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.60 2002/12/23 00:09:52 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999, 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.60 2002/12/23 00:09:52 millert Exp $";
@


1.60
log
@Display offending line number in error messages.
Based on a patch from Sam Smith.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.59 2002/11/27 22:56:16 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.59 2002/11/27 22:56:16 millert Exp $";
d188 1
a188 1
void domonitor(char *, char *);
d316 1
a316 1
	DPRINTF(("%s <%d%s%s%s>: ", ent->log, ent->numlogs,
d319 2
a320 1
	    (ent->flags & CE_FOLLOW) ? "F" : ""));
d332 4
a335 4
		if (monitormode && ent->flags & CE_MONITOR)
			domonitor(ent->log, ent->whom);
		if (!monitormode && (force ||
		    (ent->size > 0 && size >= ent->size) ||
a606 10
		working->whom = NULL;
		if (working->flags & CE_MONITOR) {	/* Optional field */
			q = parse = sob(++parse);
			*(parse = son(parse)) = '\0';

			working->whom = strdup(q);
			if (working->log == NULL)
				err(1, "strdup");
		}

d610 1
d645 5
d656 4
d926 2
a927 2
void
domonitor(char *log, char *whom)
d935 8
a942 2
	if (stat(log, &sb) < 0)
		return;
d944 1
a944 1
	flog = strdup(log);
d986 1
a986 1
		fp = fopen(log, "r");
d988 1
a988 1
			warn("%s", log);
d1008 1
a1008 1
		    whom, log);
d1032 1
@


1.59
log
@typo; Tor Houghton
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.58 2002/11/07 15:25:13 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.58 2002/11/07 15:25:13 millert Exp $";
d179 1
a179 1
char *missing_field(char *, char *);
d229 1
a229 1
				warnx("%s is not listed in %s", *av, conf);
d232 1
a232 1
			errx(1, "no specified log files found in %s", conf);
d474 1
d487 1
a487 1
	while (fgets(line, sizeof(line), f)) {
d507 1
a507 1
		q = parse = missing_field(sob(line), errline);
d516 1
a516 1
		q = parse = missing_field(sob(++parse), errline);
d523 2
a524 1
						errx(1, "Error in config file; unknown user: %s", q);
d535 3
a537 1
						errx(1, "Error in config file; unknown group: %s", q);
d544 1
a544 1
			q = parse = missing_field(sob(++parse), errline);
d552 1
a552 1
			errx(1, "Error in config file; bad permissions: %s", q);
d554 1
a554 1
		q = parse = missing_field(sob(++parse), errline);
d557 1
a557 1
			errx(1, "Error in config file; bad number: %s", q);
d559 1
a559 1
		q = parse = missing_field(sob(++parse), errline);
d566 1
a566 1
		q = parse = missing_field(sob(++parse), errline);
d597 2
a598 1
					errx(1, "Illegal flag in config file: %c", *q);
d626 2
a627 1
					errx(1, "%s: pathname too long", q);
d651 2
a652 1
					errx(1, "unknown signal: %s", q);
d654 2
a655 1
				errx(1, "unrecognized field: %s", q);
d687 2
a688 1
				errx(1, "%s: pathname too long", working->log);
d693 2
a694 1
				errx(1, "%s: pathname too long", working->log);
d704 1
a704 1
missing_field(char *p, char *errline)
d706 2
a707 2
	if (!p || !*p) {
		warnx("Missing field in config file line:");
@


1.58
log
@Sigh, sizes are in KB, not bytes, which made the cutoff size for
rotating a file 512KB instead of 512 bytes, as was intended.  Change
things to deal in bytes internally and drop the cutoff to 256 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.57 2002/09/21 23:19:43 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.57 2002/09/21 23:19:43 millert Exp $";
d790 1
a790 1
			warn("can't to mv %s to %s", ent->log, file1);
d797 1
a797 1
		warn("can't to mv %s to %s", file2, ent->log);
@


1.57
log
@When rotating files or checking the age of a file, check for both
compressed and uncompressed logs but consult the flags to see which
we one prefer should both exist.  This keeps things from getting
hosed if someone compresses or uncompresses one of the archived log files.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.56 2002/09/19 21:22:59 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.56 2002/09/19 21:22:59 millert Exp $";
d137 1
a137 1
#define	MIN_SIZE	512		/* Don't rotate if smaller than this */
d148 1
a148 1
	int     size;		/* Size cutoff to trigger trimming the log */
d183 1
a183 1
int sizefile(char *);
d304 2
a305 1
	int modtime, size;
d327 2
a328 1
			DPRINTF(("size (Kb): %d [%d] ", size, ent->size));
d558 1
a558 1
			working->size = atoi(q);
d847 1
a847 1
int
d854 6
a859 1
	return (sb.st_blocks / (1024.0 / DEV_BSIZE));
@


1.57.2.1
log
@Pull in a fix from -current:
Sizes are in KB, not bytes, which made the cutoff size for
rotating a file 512KB instead of 512 bytes, as was intended.  Change
things to deal in bytes internally and drop the cutoff to 256 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.57 2002/09/21 23:19:43 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.57 2002/09/21 23:19:43 millert Exp $";
d137 1
a137 1
#define	MIN_SIZE	256		/* Don't rotate if smaller (in bytes) */
d148 1
a148 1
	off_t   size;		/* Size cutoff to trigger trimming the log */
d183 1
a183 1
off_t sizefile(char *);
d304 1
a304 2
	int modtime;
	off_t size;
d326 1
a326 2
			DPRINTF(("size (KB): %.2f [%d] ", size / 1024.0,
			    (int)(ent->size / 1024)));
d556 1
a556 1
			working->size = atoi(q) * 1024;
d845 1
a845 1
off_t
d852 1
a852 6

	/* For sparse files, return the size based on number of blocks used. */
	if (sb.st_size / DEV_BSIZE > sb.st_blocks)
		return (sb.st_blocks * DEV_BSIZE);
	else
		return (sb.st_size);
@


1.56
log
@Deal with someone specifying an empty string for the command to run
and make it mean "send no signal and run no command".
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.55 2002/09/19 20:58:50 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.55 2002/09/19 20:58:50 millert Exp $";
d193 2
d706 1
a706 2
	char    zfile1[MAXPATHLEN], zfile2[MAXPATHLEN];
	char    oldlog[MAXPATHLEN];
a707 1
	struct  stat sb;
d719 1
a719 1
	(void)snprintf(zfile1, sizeof(zfile1), "%s.%d%s", oldlog, numdays,
d723 1
a723 1
		printf("\trm -f %s %s\n", file1, zfile1);
d726 1
a726 1
		(void)unlink(zfile1);
d731 4
a734 1
		(void)strlcpy(file2, file1, sizeof(file2));
d736 6
a741 8
		(void)strlcpy(zfile1, file1, sizeof(zfile1));
		(void)strlcpy(zfile2, file2, sizeof(zfile2));
		if (lstat(file1, &sb)) {
			(void)strlcat(zfile1, COMPRESS_POSTFIX, sizeof(zfile1));
			(void)strlcat(zfile2, COMPRESS_POSTFIX, sizeof(zfile2));
			if (lstat(zfile1, &sb))
				continue;
		}
d743 2
a744 2
			printf("\tmv %s %s\n", zfile1, zfile2);
			printf("\tchmod %o %s\n", ent->permissions, zfile2);
d747 1
a747 1
				    ent->uid, ent->gid, zfile2);
d749 4
a752 4
			if (rename(zfile1, zfile2))
				warn("can't mv %s to %s", zfile1, zfile2);
			if (chmod(zfile2, ent->permissions))
				warn("can't chmod %s", zfile2);
d754 2
a755 2
				if (chown(zfile2, ent->uid, ent->gid))
					warn("can't chown %s", zfile2);
d784 1
d860 1
a860 1
	char tmp[MAXPATHLEN];
d863 13
a875 9
		snprintf(tmp, sizeof(tmp), "%s/%s.0", ent->backdir, ent->logbase);
	else {
		strlcpy(tmp, ent->log, sizeof(tmp));
		strlcat(tmp, ".0", sizeof(tmp));
	}
	if (ent->flags & CE_COMPACT)
		strlcat(tmp, COMPRESS_POSTFIX, sizeof(tmp));
	if (stat(tmp, &sb) < 0)
		return (-1);
d1034 36
@


1.55
log
@Fix long-standing bug.  When specifying a command to run instead of sending
a signal, the command was never actually run.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.54 2002/09/19 15:27:31 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.54 2002/09/19 15:27:31 millert Exp $";
d274 6
a279 4
		if (pl->signal == -1)
			run_command(pl->file);
		else
			send_signal(pl->file, pl->signal);
d623 5
a627 3
				working->runcmd = strdup(++q);
				if (working->runcmd == NULL)
					err(1, "strdup");
@


1.54
log
@Since isspace() considers \n to be a space we need to check for start
of line == \0, not \n after stripping leading blanks.  Otherwise blank
lines give an error.  Noticed by marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.53 2002/09/17 20:44:38 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.53 2002/09/17 20:44:38 millert Exp $";
d251 4
a254 2
				if ((strcmp(pltmp->file, q->pidfile) == 0 &&
				    pltmp->signal == q->signal) || (q->runcmd &&
d350 1
a350 1
		(void)printf("\trun %s\n", cmd);
d624 2
@


1.53
log
@Allow user to restrict logs to be rotated by specifying pathnames on
the command line.  The default is to rotate all files in newsyslog.conf
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.52 2002/09/17 20:16:43 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.52 2002/09/17 20:16:43 millert Exp $";
d480 1
a480 1
		if (*tmp == '\n' || *tmp == '#')
@


1.52
log
@Add -F (force) flag; inspired by FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.51 2002/09/17 20:03:40 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.51 2002/09/17 20:03:40 millert Exp $";
d197 1
a197 1
	struct conf_entry *p, *q;
d199 1
d203 3
d208 26
a233 2
	p = q = parse_file(&listlen);
	signal(SIGCHLD, child_killer);
d239 2
d242 1
a242 1
	while (q) {
a243 2
		q = q->next;
	}
d453 1
a453 1
	    "[-f config_file]\n", __progname);
@


1.51
log
@Add -a flag to specify a directory to store archived logs.  Based on
changes I made years ago to a private version of newsyslog but with
the option renamed to match FreeBSD.  Note that unlike the FreeBSD
-a flag, we don't automagically create the archive dir if it doesn't exist.
OK deraadt@@ and todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.50 2002/09/16 01:41:54 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.50 2002/09/16 01:41:54 millert Exp $";
d164 3
a166 3
int     verbose = 0;		/* Print out what's going on */
int     needroot = 1;		/* Root privs are necessary */
int     noaction = 0;		/* Don't do anything, just show it */
d168 6
a173 5
char    *conf = CONF;		/* Configuration file to use */
time_t  timenow;
char    hostname[MAXHOSTNAMELEN]; /* hostname */
char    *daytime;		/* timenow in human readable form */
char    *arcdir;		/* dir to put archives in (if it exists) */
d297 2
a298 1
		if (!monitormode && ((ent->size > 0 && size >= ent->size) ||
d388 1
a388 1
	while ((ch = getopt(argc, argv, "nrvma:f:")) != -1) {
d408 3
d415 2
d424 1
a424 1
	(void)fprintf(stderr, "usage: %s [-mnrv] [-a directory] "
d429 2
a430 1
/* Parse a configuration file and return a linked list of all the logs
@


1.50
log
@o Remove "NONE" #define and check uid_t and gid_t against -1 with proper casts
o Don't call chown/fchown if neither uid nor gid was specified
o Fix check for symlinks in non-verbose mode
o Add DPRINTF macro to simplify code in verbose mode
o Print B and F flags in -v and -n modes
o Add a leading tab to lines printed in -n mode for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.49 2002/09/13 18:50:09 millert Exp $	*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.49 2002/09/13 18:50:09 millert Exp $";
d143 2
d172 1
d179 1
a179 1
void dotrim(char *, int, int, int, uid_t, gid_t);
d181 1
a181 1
void compress_log(char *);
d183 1
a183 1
int age_old_log(char *);
d254 1
a254 1
			compress_log(p->log);
d272 1
a272 1
	if (lstat(ent->log, &sb) != 0)  
d281 3
a283 3
		(ent->flags & CE_COMPACT) ? "Z" : "",
		(ent->flags & CE_BINARY) ? "B" : "",
		(ent->flags & CE_FOLLOW) ? "F" : ""));
d286 1
a286 1
	modtime = age_old_log(ent->log);
d306 1
a306 2
			dotrim(ent->log, ent->numlogs, ent->flags,
			    ent->permissions, ent->uid, ent->gid);
d386 1
a386 1
	while ((ch = getopt(argc, argv, "nrvmf:")) != -1) {
d388 3
d417 2
a418 2
	(void)fprintf(stderr, "usage: %s [-mnrv] [-f config_file]\n",
	    __progname);
d434 1
d468 3
d601 24
d627 11
a637 7
		if (asprintf(&tmp, "%s.%d%s", working->log, working->numlogs,
		    COMPRESS_POSTFIX) >= MAXPATHLEN)
			errx(1, "%s: pathname too long", working->log);

		if (tmp)
			free(tmp);
		free(errline);
d657 1
a657 2
dotrim(char *log, int numdays, int flags, int perm, uid_t owner_uid,
    gid_t group_gid)
d661 1
d664 8
a671 1
	int	days = numdays;
d674 2
a675 2
	(void)snprintf(file1, sizeof(file1), "%s.%d", log, numdays);
	(void)snprintf(zfile1, sizeof(zfile1), "%s.%d%s", log, numdays,
d688 1
a688 1
		(void)snprintf(file1, sizeof(file1), "%s.%d", log, numdays);
d699 2
a700 2
			printf("\tchmod %o %s\n", perm, zfile2);
			if (owner_uid != (uid_t)-1 || group_gid != (gid_t)-1)
d702 1
a702 1
				    owner_uid, group_gid, zfile2);
d706 1
a706 1
			if (chmod(zfile2, perm))
d708 2
a709 2
			if (owner_uid != (uid_t)-1 || group_gid != (gid_t)-1)
				if (chown(zfile2, owner_uid, group_gid))
d713 2
a714 2
	if (!noaction && !(flags & CE_BINARY))
		(void)log_trim(log);  /* Report the trimming to the old log */
d716 1
a716 1
	(void)snprintf(file2, sizeof(file2), "%s.XXXXXXXXXX", log);
d722 4
a725 4
		if (owner_uid != (uid_t)-1 || group_gid != (gid_t)-1)
			if (fchown(fd, owner_uid, group_gid))
				err(1, "can't chown '%s' log file", file2);
		if (fchmod(fd, perm))
d729 1
a729 1
		if (!(flags & CE_BINARY) && log_trim(file2))
d733 1
a733 1
	if (days == 0) {
d735 3
a737 3
			printf("\trm %s\n", log);
		else if (unlink(log))
			warn("can't rm %s", log);
d739 4
a742 4
		if (noaction) 
			printf("\tmv %s to %s\n", log, file1);
		else if (rename(log, file1))
			warn("can't to mv %s to %s", log, file1);
d747 3
a749 3
		printf("\tmv %s to %s\n", file2, log);
	else if (rename(file2, log))
		warn("can't to mv %s to %s", file2, log);
d769 1
a769 1
compress_log(char *log)
d773 7
a779 1
	
d785 1
a785 1
		printf("%s %s.0\n", base, log);
a788 1
	(void)snprintf(tmp, sizeof(tmp), "%s.0", log);
d811 1
a811 1
age_old_log(char *file)
d816 7
a822 3
	(void)strlcpy(tmp, file, sizeof(tmp));
	strlcat(tmp, ".0", sizeof(tmp));
	if (stat(tmp, &sb) < 0) {
d824 2
a825 3
		if (stat(tmp, &sb) < 0)
			return (-1);
	}
@


1.49
log
@Don't rotate log files < 512 bytes unless in binary mode.  This
prevents newsyslog from rotating a file that only contains the
messages that the log file was turned over.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.48 2002/09/13 00:16:13 millert Exp $	*/
d67 14
a80 16

Copyright 1988, 1989 by the Massachusetts Institute of Technology

Permission to use, copy, modify, and distribute this software
and its documentation for any purpose and without fee is
hereby granted, provided that the above copyright notice
appear in all copies and that both that copyright notice and
this permission notice appear in supporting documentation,
and that the names of M.I.T. and the M.I.T. S.I.P.B. not be
used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.
M.I.T. and the M.I.T. S.I.P.B. make no representations about
the suitability of this software for any purpose.  It is
provided "as is" without express or implied warranty.

*/
d89 1
a89 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.48 2002/09/13 00:16:13 millert Exp $";
a134 1
#define NONE -1
d139 2
d269 6
a274 10
	if (!(ent->flags & CE_FOLLOW)) {
		if (lstat(ent->log, &sb) != 0)
			return;
		if ((sb.st_mode & S_IFLNK) != S_IFREG) {
			if (verbose) {
				printf("--> %s is not a regular file, skip\n",
				    ent->log);
				return;
			}
		}
d277 5
a281 3
	if (verbose)
		printf("%s <%d%s>: ", ent->log, ent->numlogs,
			(ent->flags & CE_COMPACT) ? "Z" : "");
d285 1
a285 2
		if (verbose)
			printf("does not exist.\n");
d287 4
a290 4
		if (verbose && (ent->size > 0))
			printf("size (Kb): %d [%d] ", size, ent->size);
		if (verbose && (ent->hours > 0))
			printf(" age (hr): %d [%d] ", modtime, ent->hours);
d296 1
a296 2
			if (verbose)
				printf("--> trimming log....\n");
d298 5
a302 2
				printf("%s <%d%s>: ", ent->log, ent->numlogs,
					(ent->flags & CE_COMPACT) ? "Z" : "");
d306 2
a307 2
		} else if (verbose)
			printf("--> skipping\n");
d316 1
a316 1
		(void)printf("run %s\n", cmd);
d474 1
a474 1
				working->uid = NONE;
d485 1
a485 1
				working->gid = NONE;
d489 4
a492 2
		} else 
			working->uid = working->gid = NONE;
d635 1
a635 1
		printf("rm -f %s %s\n", file1, zfile1);
d654 5
a658 4
			printf("mv %s %s\n", zfile1, zfile2);
			printf("chmod %o %s\n", perm, zfile2);
			printf("chown %u:%u %s\n",
			    owner_uid, group_gid, zfile2);
d664 3
a666 2
			if (chown(zfile2, owner_uid, group_gid))
				warn("can't chown %s", zfile2);
d674 1
a674 1
		printf("Create new log file...\n");
d678 3
a680 2
		if (fchown(fd, owner_uid, group_gid))
			err(1, "can't chown '%s' log file", file2);
d691 1
a691 1
			printf("rm %s\n", log);
d696 1
a696 1
			printf("mv %s to %s\n", log, file1);
d703 1
a703 1
		printf("mv %s to %s\n", file2, log);
d742 1
a742 1
	} else if (!pid) {
@


1.48
log
@KNF + ANSI; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.47 2002/09/12 19:58:38 millert Exp $	*/
d91 1
a91 1
static const char rcsid[] = "$OpenBSD: newsyslog.c,v 1.47 2002/09/12 19:58:38 millert Exp $";
d139 3
a168 1
#define MIN_PID		4
d297 3
a299 3
		if (!monitormode && (((ent->size > 0) && (size >= ent->size)) ||
		    ((ent->hours > 0) && ((modtime >= ent->hours) ||
		    (modtime < 0))))) {
@


1.47
log
@add missing include of limits.h
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.46 2002/08/12 00:42:56 aaron Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Todd C. Miller <Todd.Miller@@courtesan.com>
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.46 2002/08/12 00:42:56 aaron Exp $";
d113 2
a114 2
#include <stdio.h>
#include <sys/types.h>
a115 2
#include <sys/stat.h>
#include <sys/param.h>
d117 1
a117 2
#include <stdlib.h>
#include <string.h>
d119 2
a120 1
#include <signal.h>
a121 1
#include <pwd.h>
d124 5
a128 1
#include <errno.h>
a129 1
#include <err.h>
a169 1

d171 1
a171 1
void PRS(int, char **);
a184 1
void closemail(FILE *);
d190 1
a190 3
main(argc, argv)
	int argc;
	char **argv;
d196 1
a196 1
	PRS(argc, argv);
d263 1
a263 3
do_entry(ent)
	struct conf_entry       *ent;
	
d265 2
a266 2
	int	modtime, size;
	struct	stat sta;
d269 1
a269 1
		if (lstat(ent->log, &sta) != 0)
d271 1
a271 1
		if ((sta.st_mode & S_IFLNK) != S_IFREG) {
d313 1
a313 2
run_command(cmd)
	char	*cmd;
a314 1

d323 1
a323 3
send_signal(pidfile, signal)
	char	*pidfile;
	int	signal;
d325 3
a327 3
	char    line[BUFSIZ];
	pid_t	pid = 0;
	FILE	*f;
a328 2
	char *ep;
	char *err;
d335 1
d368 1
a368 3
PRS(argc, argv)
	int argc;
	char **argv;
d370 2
a371 2
	int     c;
	char	*p;
d381 1
a381 2
	p = strchr(hostname, '.');
	if (p)
d384 2
a385 3
	optind = 1;	     /* Start options parsing */
	while ((c = getopt(argc, argv, "nrvmf:")) != -1) {
		switch (c) {
d408 1
a408 1
usage()
d421 1
a421 2
parse_file(nentries)
	int *nentries;
d423 2
a424 3
	FILE    *f;
	char    line[BUFSIZ], *parse, *q;
	char    *errline, *group, *tmp;
d427 1
a427 1
	struct passwd *pass;
d432 2
a433 4
	else {
		if ((f = fopen(conf, "r")) == NULL)
			err(1, "can't open %s", conf);
	}
d437 2
a438 1
		if ((line[0] == '\n') || (line[0] == '#'))
d440 1
a440 1
		errline = strdup(line);
d468 1
a468 1
					if ((pass = getpwnam(q)) == NULL)
d470 1
a470 1
					working->uid = pass->pw_uid;
d603 1
a603 1
	return(first);
d607 1
a607 3
missing_field(p, errline)
	char    *p;
	char    *errline;
d614 1
a614 1
	return(p);
d618 2
a619 7
dotrim(log, numdays, flags, perm, owner_uid, group_gid)
	char    *log;
	int     numdays;
	int     flags;
	int     perm;
	uid_t   owner_uid;
	gid_t   group_gid;
d624 1
a624 1
	struct  stat st;
d628 2
a629 2
	(void)snprintf(file1, sizeof file1, "%s.%d", log, numdays);
	(void)snprintf(zfile1, sizeof zfile1, "%s.%d%s", log, numdays,
d641 8
a648 8
		(void)strlcpy(file2, file1, sizeof file2);
		(void)snprintf(file1, sizeof file1, "%s.%d", log, numdays);
		(void)strlcpy(zfile1, file1, sizeof zfile1);
		(void)strlcpy(zfile2, file2, sizeof zfile2);
		if (lstat(file1, &st)) {
			(void)strlcat(zfile1, COMPRESS_POSTFIX, sizeof zfile1);
			(void)strlcat(zfile2, COMPRESS_POSTFIX, sizeof zfile2);
			if (lstat(zfile1, &st))
d705 1
a705 2
log_trim(log)
	char    *log;
d710 1
a710 1
		return(-1);
d715 1
a715 1
	return(0);
d720 1
a720 2
compress_log(log)
	char    *log;
d722 2
a723 3
	pid_t   pid;
	char	*base;
	char    tmp[MAXPATHLEN];
d734 1
a734 1
	(void)snprintf(tmp, sizeof tmp, "%s.0", log);
d746 1
a746 2
sizefile(file)
	char    *file;
d751 2
a752 2
		return(-1);
	return(sb.st_blocks / (1024.0 / DEV_BSIZE));
d757 1
a757 2
age_old_log(file)
	char    *file;
d762 2
a763 2
	(void)strlcpy(tmp, file, sizeof tmp);
	strlcat(tmp, ".0", sizeof tmp);
d765 1
a765 1
		strlcat(tmp, COMPRESS_POSTFIX, sizeof tmp);
d767 1
a767 1
			return(-1);
d769 1
a769 1
	return( (int) (timenow - sb.st_mtime + 1800) / 3600);
d774 1
a774 2
sob(p)
	char   *p;
d778 1
a778 1
	return(p);
d783 1
a783 2
son(p)
	char   *p;
d787 1
a787 1
	return(p);
d792 1
a792 2
isnumberstr(string)
	char *string;
d796 1
a796 1
			return(0);
d798 1
a798 1
	return(1);
d802 1
a802 2
domonitor(log, whom)
	char *log, *whom;
d821 1
a821 1
	snprintf(fname, sizeof fname, "%s/newsyslog.%s.size",
d881 1
a881 1
		closemail(fp);
d904 1
a904 1
openmail()
d906 1
a907 1
	FILE *ret;
d919 1
a919 9
closemail(pfp)
	FILE *pfp;
{
	pclose(pfp);
}

void
child_killer(signum)
	int signum;
@


1.46
log
@Swap args to calloc(3) so they are in the correct order; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.45 2002/06/26 23:36:14 wcobb Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.45 2002/06/26 23:36:14 wcobb Exp $";
d95 1
a95 1
#define CONF "/etc/athena/newsyslog.conf" /* Configuration file */
d101 1
a101 1
#define COMPRESS "/usr/ucb/compress" /* File compression program */
d126 1
@


1.45
log
@Don't follow symbolic links for (ie. user-owned) log files by default;
closes pr #1913.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.44 2002/06/12 06:07:16 mpech Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.44 2002/06/12 06:07:16 mpech Exp $";
d205 1
a205 1
	pidlist = (struct pidinfo *)calloc(sizeof(struct pidinfo), listlen + 1);
@


1.44
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.43 2002/02/16 21:27:50 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.43 2002/02/16 21:27:50 millert Exp $";
d135 1
d271 13
d549 4
@


1.43
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.42 2001/11/27 18:17:38 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.42 2001/11/27 18:17:38 millert Exp $";
d357 1
a357 1
		(void)printf("kill -%s %u\n", sys_signame[signal], pid);
d718 2
a719 2
	(void)fprintf(f, "%s %s newsyslog[%u]: logfile turned over\n",
	    daytime, hostname, getpid());
@


1.42
log
@Fix uninitialized variable introduced in rev 1.40; found by lebel@@
If fgets() fails, set err to a reasonable value.  Otherwise we
could send the signal to pid 0 which would be bad...
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.41 2001/11/24 19:53:22 marc Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.41 2001/11/24 19:53:22 marc Exp $";
d169 19
a187 19
void do_entry __P((struct conf_entry *));
void PRS __P((int, char **));
void usage __P((void));
struct conf_entry *parse_file __P((int *));
char *missing_field __P((char *, char *));
void dotrim __P((char *, int, int, int, uid_t, gid_t));
int log_trim __P((char *));
void compress_log __P((char *));
int sizefile __P((char *));
int age_old_log __P((char *));
char *sob __P((char *));
char *son __P((char *));
int isnumberstr __P((char *));
void domonitor __P((char *, char *));
FILE *openmail __P((void));
void closemail __P((FILE *));
void child_killer __P((int));
void run_command __P((char *));
void send_signal __P((char *, int));
@


1.41
log
@handle NL terminated pid files correctly, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.40 2001/11/23 04:20:56 deraadt Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.40 2001/11/23 04:20:56 deraadt Exp $";
d332 2
a334 1
		errno = 0;
d346 5
@


1.40
log
@greater care at reading pidfiles; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.39 2001/11/19 19:02:15 mpech Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.39 2001/11/19 19:02:15 mpech Exp $";
d335 1
a335 1
		if (line[0] == '\0' || *ep != '\0')
@


1.39
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.38 2001/11/16 23:49:07 deraadt Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.38 2001/11/16 23:49:07 deraadt Exp $";
d287 2
a288 2
		    ((ent->hours > 0) && ((modtime >= ent->hours)
					|| (modtime < 0))))) {
d295 1
a295 1
			       ent->permissions, ent->uid, ent->gid);
a319 1
	FILE	*f;
d322 4
d332 14
a345 2
	if (fgets(line, sizeof(line), f))
		pid = atoi(line);
d348 4
a351 6
	if (noaction)
		(void)printf("kill -%s %d\n", sys_signame[signal], pid);
	else if (pid == 0)
		warnx("empty pid file: %s", pidfile);
	else if (pid < MIN_PID)
		warnx("preposterous process number: %d", pid);
d537 1
a537 1
		    parse--;	/* no flags so undo */
d654 2
a655 2
			printf("chown %d:%d %s\n",
			       owner_uid, group_gid, zfile2);
d712 1
a712 1
	(void)fprintf(f, "%s %s newsyslog[%d]: logfile turned over\n",
@


1.38
log
@errno safety in SIGCHLD handler
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.37 2001/07/09 07:04:50 deraadt Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.37 2001/07/09 07:04:50 deraadt Exp $";
d767 1
a767 1
	register char   *p;
d777 1
a777 1
	register char   *p;
@


1.37
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.36 2001/03/01 20:34:10 aaron Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.36 2001/03/01 20:34:10 aaron Exp $";
d126 1
d925 1
d930 1
@


1.36
log
@Remove -t option from getopt() since it doesn't exist; mpech@@prosoft.org.lv.
Also rearrage options in the man page while I'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.35 2001/01/12 16:24:06 deraadt Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.35 2001/01/12 16:24:06 deraadt Exp $";
d727 1
a727 1
		(void)execl(COMPRESS, base, "-f", tmp, 0);
@


1.35
log
@various small cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.34 2000/06/30 16:00:19 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.34 2000/06/30 16:00:19 millert Exp $";
d364 1
a364 1
	while ((c = getopt(argc, argv, "nrvmf:t:")) != -1) {
d392 1
a392 1
	(void)fprintf(stderr, "usage: %s [-nrvm] [-f config-file]\n",
@


1.34
log
@warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.33 2000/06/14 22:55:19 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.33 2000/06/14 22:55:19 millert Exp $";
d135 1
a135 1
        
d137 7
a143 7
        char    *log;           /* Name of the log */
        uid_t   uid;            /* Owner of log */
        gid_t   gid;            /* Group of log */
        int     numlogs;        /* Number of logs to keep */
        int     size;           /* Size cutoff to trigger trimming the log */
        int     hours;          /* Hours between log trimming */
        int     permissions;    /* File permissions on the log */
d145 1
a145 1
        int     flags;          /* Flags (CE_COMPACT & CE_BINARY)  */
d149 1
a149 1
        struct conf_entry       *next; /* Linked list pointer */
d157 3
a159 3
int     verbose = 0;            /* Print out what's going on */
int     needroot = 1;           /* Root privs are necessary */
int     noaction = 0;           /* Don't do anything, just show it */
d161 1
a161 1
char    *conf = CONF;           /* Configuration file to use */
d165 1
a165 1
char    *daytime;               /* timenow in human readable form */
d190 2
a191 2
        int argc;
        char **argv;
d193 1
a193 1
        struct conf_entry *p, *q;
d196 3
a198 3
        
        PRS(argc, argv);
        if (needroot && getuid() && geteuid())
d200 1
a200 1
        p = q = parse_file(&listlen);
d208 4
a211 4
        while (q) {
                do_entry(q);
                q = q->next;
        }
d235 2
a236 2
                q = q->next;
        }
d249 1
a249 1
        while (p) {
d253 3
a255 3
                p = p->next;
                free(q);
        }
d260 1
a260 1
        exit(0);
d265 2
a266 2
        struct conf_entry       *ent;
        
d273 10
a282 10
        size = sizefile(ent->log);
        modtime = age_old_log(ent->log);
        if (size < 0) {
                if (verbose)
                        printf("does not exist.\n");
        } else {
                if (verbose && (ent->size > 0))
                        printf("size (Kb): %d [%d] ", size, ent->size);
                if (verbose && (ent->hours > 0))
                        printf(" age (hr): %d [%d] ", modtime, ent->hours);
d285 5
a289 5
                if (!monitormode && (((ent->size > 0) && (size >= ent->size)) ||
                    ((ent->hours > 0) && ((modtime >= ent->hours)
                                        || (modtime < 0))))) {
                        if (verbose)
                                printf("--> trimming log....\n");
d293 2
a294 2
                        dotrim(ent->log, ent->numlogs, ent->flags,
                               ent->permissions, ent->uid, ent->gid);
d296 1
a296 1
                } else if (verbose)
d298 1
a298 1
        }
d320 1
a320 1
        char    line[BUFSIZ];
d323 1
a323 1
        if ((f = fopen(pidfile, "r")) == NULL) {
d332 2
a333 2
        if (noaction)
                (void)printf("kill -%s %d\n", sys_signame[signal], pid);
d345 2
a346 2
        int argc;
        char **argv;
d348 1
a348 1
        int     c;
d351 3
a353 3
        timenow = time(NULL);
        daytime = ctime(&timenow) + 4;
        daytime[15] = '\0';
d355 2
a356 2
        /* Let's get our hostname */
        (void)gethostname(hostname, sizeof(hostname));
d363 15
a377 15
        optind = 1;             /* Start options parsing */
        while ((c = getopt(argc, argv, "nrvmf:t:")) != -1) {
                switch (c) {
                case 'n':
                        noaction++; /* This implies needroot as off */
                        /* fall through */
                case 'r':
                        needroot = 0;
                        break;
                case 'v':
                        verbose++;
                        break;
                case 'f':
                        conf = optarg;
                        break;
d381 4
a384 4
                default:
                        usage();
                }
        }
d404 7
a410 7
        FILE    *f;
        char    line[BUFSIZ], *parse, *q;
        char    *errline, *group, *tmp;
        struct conf_entry *first = NULL;
        struct conf_entry *working;
        struct passwd *pass;
        struct group *grp;
d412 2
a413 2
        if (strcmp(conf, "-") == 0)
                f = stdin;
d415 1
a415 1
                if ((f = fopen(conf, "r")) == NULL)
d420 4
a423 4
        while (fgets(line, sizeof(line), f)) {
                if ((line[0] == '\n') || (line[0] == '#'))
                        continue;
                errline = strdup(line);
d427 2
a428 2
                if (!first) {
                        working = (struct conf_entry *) malloc(sizeof(struct conf_entry));
d431 3
a433 3
                        first = working;
                } else {
                        working->next = (struct conf_entry *) malloc(sizeof(struct conf_entry));
d436 2
a437 2
                        working = working->next;
                }
d439 3
a441 3
                q = parse = missing_field(sob(line), errline);
                *(parse = son(line)) = '\0';
                working->log = strdup(q);
d445 2
a446 2
                q = parse = missing_field(sob(++parse), errline);
                *(parse = son(parse)) = '\0';
d475 1
a475 1
                if (!sscanf(q, "%o", &working->permissions))
d478 3
a480 3
                q = parse = missing_field(sob(++parse), errline);
                *(parse = son(parse)) = '\0';
                if (!sscanf(q, "%d", &working->numlogs) || working->numlogs < 0)
d483 13
a495 13
                q = parse = missing_field(sob(++parse), errline);
                *(parse = son(parse)) = '\0';
                if (isdigit(*q))
                        working->size = atoi(q);
                else
                        working->size = -1;
                
                q = parse = missing_field(sob(++parse), errline);
                *(parse = son(parse)) = '\0';
                if (isdigit(*q))
                        working->hours = atoi(q);
                else
                        working->hours = -1;
d497 2
a498 2
                working->flags = 0;
                q = sob(++parse);	/* Optional field */
d574 9
a582 8
                
                free(tmp);
                free(errline);
        }
        if (working)
                working->next = NULL;
        (void)fclose(f);
        return(first);
d587 1
a587 1
        char    *p;
d590 1
a590 1
        if (!p || !*p) {
d592 4
a595 4
                fputs(errline, stderr);
                exit(1);
        }
        return(p);
d600 11
a610 11
        char    *log;
        int     numdays;
        int     flags;
        int     perm;
        uid_t   owner_uid;
        gid_t   group_gid;
{
        char    file1[MAXPATHLEN], file2[MAXPATHLEN];
        char    zfile1[MAXPATHLEN], zfile2[MAXPATHLEN];
        int     fd;
        struct  stat st;
d613 31
a643 30
        /* Remove oldest log (may not exist) */
        (void)sprintf(file1, "%s.%d", log, numdays);
        (void)strcpy(zfile1, file1);
        (void)strcat(zfile1, COMPRESS_POSTFIX);
        if (noaction) {
                printf("rm -f %s %s\n", file1, zfile1);
        } else {
                (void)unlink(file1);
                (void)unlink(zfile1);
        }

        /* Move down log files */
        while (numdays--) {
                (void)strcpy(file2, file1);
                (void)sprintf(file1, "%s.%d", log, numdays);
                (void)strcpy(zfile1, file1);
                (void)strcpy(zfile2, file2);
                if (lstat(file1, &st)) {
                        (void)strcat(zfile1, COMPRESS_POSTFIX);
                        (void)strcat(zfile2, COMPRESS_POSTFIX);
                        if (lstat(zfile1, &st))
                        	continue;
                }
                if (noaction) {
                        printf("mv %s %s\n", zfile1, zfile2);
                        printf("chmod %o %s\n", perm, zfile2);
                        printf("chown %d:%d %s\n",
                               owner_uid, group_gid, zfile2);
                } else {
                        if (rename(zfile1, zfile2))
d645 1
a645 1
                        if (chmod(zfile2, perm))
d647 1
a647 1
                        if (chown(zfile2, owner_uid, group_gid))
d649 4
a652 4
                }
        }
        if (!noaction && !(flags & CE_BINARY))
                (void)log_trim(log);  /* Report the trimming to the old log */
d655 4
a658 4
        if (noaction)  {
                printf("Create new log file...\n");
        } else {
                if ((fd = mkstemp(file2)) < 0)
d660 1
a660 1
                if (fchown(fd, owner_uid, group_gid))
d662 1
a662 1
                if (fchmod(fd, perm))
d664 1
a664 1
                (void)close(fd);
d666 1
a666 1
                if (!(flags & CE_BINARY) && log_trim(file2))
d668 1
a668 1
        }
d677 2
a678 2
	                printf("mv %s to %s\n", log, file1);
	        else if (rename(log, file1))
d694 1
a694 1
        FILE    *f;
d696 3
a698 3
        if ((f = fopen(log, "a")) == NULL)
                return(-1);
        (void)fprintf(f, "%s %s newsyslog[%d]: logfile turned over\n",
d700 3
a702 3
        if (fclose(f) == EOF)
                err(1, "log_trim: fclose");
        return(0);
d708 1
a708 1
        char    *log;
d710 1
a710 1
        pid_t   pid;
d712 2
a713 2
        char    tmp[MAXPATHLEN];
        
d722 3
a724 3
        pid = fork();
        (void)sprintf(tmp, "%s.0", log);
        if (pid < 0) {
d726 2
a727 2
        } else if (!pid) {
                (void)execl(COMPRESS, base, "-f", tmp, 0);
d730 1
a730 1
        }
d736 1
a736 1
        char    *file;
d738 1
a738 1
        struct stat sb;
d740 3
a742 3
        if (stat(file, &sb) < 0)
                return(-1);
        return(sb.st_blocks / (1024.0 / DEV_BSIZE));
d748 1
a748 1
        char    *file;
d750 2
a751 2
        struct stat sb;
        char tmp[MAXPATHLEN];
d753 8
a760 5
        (void)strcpy(tmp, file);
        if (stat(strcat(tmp, ".0"), &sb) < 0)
            if (stat(strcat(tmp, COMPRESS_POSTFIX), &sb) < 0)
                return(-1);
        return( (int) (timenow - sb.st_mtime + 1800) / 3600);
d766 1
a766 1
        register char   *p;
d768 3
a770 3
        while (p && *p && isspace(*p))
                p++;
        return(p);
d776 1
a776 1
        register char   *p;
d778 3
a780 3
        while (p && *p && !isspace(*p))
                p++;
        return(p);
d788 5
a792 5
        while (*string) {
            if (!isdigit(*string++))
		return(0);
        }
        return(1);
d800 1
a800 1
	char *fname, *flog, *p, *rb = NULL;
d816 2
a817 5
	fname = (char *) malloc(sizeof(STATS_DIR) + strlen(flog) + 16);
	if (fname == NULL)
		err(1, "malloc");

	sprintf(fname, "%s/newsyslog.%s.size", STATS_DIR, flog);
a893 1
	free(fname);
d901 1
a901 1
	char *cmdbuf;
d904 7
a910 9
	cmdbuf = (char *) malloc(sizeof(SENDMAIL) + 3);
	if (cmdbuf == NULL)
		return(NULL);

	sprintf(cmdbuf, "%s -t", SENDMAIL);
	ret = popen(cmdbuf, "w");

	free(cmdbuf);
	return(ret);
@


1.33
log
@monitor -> monitormode because some OSes have a monitor(3)
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.32 2000/06/12 17:41:21 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.32 2000/06/12 17:41:21 millert Exp $";
d823 1
a823 1
		warn(fname);
d850 1
a850 1
			warn(log);
d880 1
a880 1
		warn(fname);
@


1.32
log
@Make the flags field truly optional.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.31 2000/06/10 02:49:41 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.31 2000/06/10 02:49:41 millert Exp $";
d160 1
a160 1
int	monitor = 0;		/* Don't do monitoring by default */
d283 1
a283 1
		if (monitor && ent->flags & CE_MONITOR)
d285 1
a285 1
                if (!monitor && (((ent->size > 0) && (size >= ent->size)) ||
d379 1
a379 1
			monitor++;
@


1.31
log
@Increment pl when filling in pidlist.  It was just overwriting the first
entry each time.  Unless you have multiple pid files you don't notice
which is why this slipped through the cracks.  Noted by Jonathan Rozes.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.30 1999/11/11 22:24:14 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.30 1999/11/11 22:24:14 millert Exp $";
a496 2
                q = parse = sob(++parse); /* Optional field */
                *(parse = son(parse)) = '\0';
d498 26
a523 11
                while (q && *q && !isspace(*q)) {
                        if ((*q == 'Z') || (*q == 'z'))
                                working->flags |= CE_COMPACT;
                        else if ((*q == 'B') || (*q == 'b'))
                                working->flags |= CE_BINARY;
			else if ((*q == 'M') || (*q == 'm'))
				working->flags |= CE_MONITOR;
                        else
				errx(1, "Illegal flag in config file: %c", *q);
                        q++;
                }
@


1.30
log
@Add support for sending signals other than SIGHUP and optionally
run a command instead of sending a signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.28 1999/11/09 03:03:27 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.28 1999/11/09 03:03:27 millert Exp $";
d232 1
@


1.30.2.1
log
@Pull in patch from current:
Fix (millert):
Increment pl when filling in pidlist.  It was just overwriting the first
entry each time.  Unless you have multiple pid files you don't notice
which is why this slipped through the cracks.  Noted by Jonathan Rozes.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.31 2000/06/10 02:49:41 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.31 2000/06/10 02:49:41 millert Exp $";
a231 1
				pl++;
@


1.30.2.2
log
@Pull in patch from current (even more to come):
Fix (millert):
warnx?/errx? paranoia (use "%s" not a bare string unless it is a
constant).  These are not security holes but it is worth fixing
them anyway both for robustness and so folks looking for examples
in the tree are not misled into doing something potentially dangerous.
Furthermore, it is a bad idea to assume that pathnames will not
include '%' in them and that error routines don't return strings
with '%' in them (especially in light of the possibility of locales).
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.34 2000/06/30 16:00:19 millert Exp $	*/
d91 1
a91 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.30.2.1 2000/06/10 20:26:02 jason Exp $";
d810 1
a810 1
		warn("%s", fname);
d837 1
a837 1
			warn("%s", log);
d867 1
a867 1
		warn("%s", fname);
@


1.29
log
@calloc an array of char *, not pid_t (left over from previous implementation).
@
text
@d4 27
d144 1
d147 2
a148 1
	char	*pidfile;	/* Path to file containg pid to HUP */
d152 5
d185 2
a186 1
void send_hup __P((char *));
d194 1
a194 1
	char **pidfiles, **pf;
d203 2
a204 2
	pidfiles = calloc(sizeof(char *), listlen + 1);
	if (pidfiles == NULL)
d214 1
a214 1
	for (q = p, pf = pidfiles; q; ) {
d216 1
a216 1
			char **pftmp;
d218 4
a221 2
			for (pftmp = pidfiles; pftmp < pf; pftmp++)
				if (strcmp(*pftmp, q->pidfile) == 0)
d223 10
a232 2
			if (pftmp == pf)
				*pf++ = q->pidfile;
d237 7
a243 3
	/* Step 3, send a HUP to relevant processes */
	for (pf = pidfiles; *pf; pf++)
		send_hup(*pf);
d300 13
a312 1
/* Send a HUP to the pid specified by pidfile */
d314 1
a314 1
send_hup(pidfile)
d316 1
d332 1
a332 1
                (void)printf("kill -HUP %d\n", pid);
d337 3
a339 2
	else if (kill(pid, SIGHUP))
		warnx("warning - could not HUP daemon");
d522 32
a553 8
                q = parse = sob(++parse); /* Optional field */
                *(parse = son(parse)) = '\0';
		if (q && *q != '\0') {
			if (strlen(q) >= MAXPATHLEN)
				errx(1, "%s: pathname too long", q);
			working->pidfile = strdup(q);
			if (working->pidfile == NULL)
				err(1, "strdup");
@


1.28
log
@Avoid sending a HUP to a process multiple times.  Ie: instead of one
per log file, do one per pid file (but only if the pid file corresponds
to a log file that was rotated).
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.27 1999/11/07 05:31:53 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.27 1999/11/07 05:31:53 millert Exp $";
d168 1
a168 1
	pidfiles = calloc(sizeof(pid_t), listlen + 1);
@


1.27
log
@compress_log() now needs to check for noaction != 0
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.26 1999/11/07 05:16:28 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.26 1999/11/07 05:16:28 millert Exp $";
d137 1
a137 1
struct conf_entry *parse_file __P((void));
d159 2
a160 1
	int status;
d165 1
a165 1
        p = q = parse_file();
d168 4
d178 11
a188 6
	/* Step 2, send a HUP to relevant processes */
	/* XXX - should avoid HUP'ing the same process multiple times */
	q = p;
        while (q) {
		if (q->flags & CE_ROTATED)
			send_hup(q->pidfile);
d192 7
a198 1
	/* Step 3, compress the log.0 file if configured to do so and free */
d337 2
a338 1
parse_file()
d355 1
d362 1
@


1.26
log
@Don't send a HUP or compress the log files until _everything_ has been
rotated.  Fixes a race condition between syslogd and newsyslog whereby
syslogd could be reinitializing (due to SIGHUP) while newsyslog was
rotating the next log file.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.25 1999/11/07 03:59:12 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.25 1999/11/07 03:59:12 millert Exp $";
d589 1
d592 8
d605 1
a605 1
                (void)execl(COMPRESS, "compress", "-f", tmp, 0);
@


1.25
log
@o Some KNF + consistent indentation for readability
o When pid file cannot be opened give a sensible warning
o Use fchmod when we can
o Check more return values
o Use uid_t/gid_t when sensible
o When computing kbytes from blocks do so in such a way that is not likely
to cause wrap.
o Sanity check path lengths to avoid chance of oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.24 1999/11/06 21:02:05 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.24 1999/11/06 21:02:05 millert Exp $";
d102 3
a104 2
#define CE_COMPACT	0x01		/* Compact the achived log files */
#define CE_BINARY	0x02		/* Logfile is in binary, don't add */
d106 1
a106 1
#define CE_MONITOR	0x04		/* Monitory for changes */
d139 1
a139 1
void dotrim __P((char *, int, int, int, uid_t, gid_t, pid_t));
d151 1
d166 17
d184 3
a186 1
                do_entry(p);
a188 1
                q = p;
a202 3
	pid_t	pid;
        char    line[BUFSIZ];
        FILE    *f;
a203 9
        /* First find the pid to HUP */
        pid = (pid_t)-1;
        if ((f = fopen(ent->pidfile, "r")) != NULL) {
        	if (fgets(line, sizeof(line), f))
                	pid = atoi(line);
		(void)fclose(f);
	} else
		warn("can't open %s", ent->pidfile);
        
d228 2
a229 1
                               ent->permissions, ent->uid, ent->gid, pid);
d235 28
d478 1
a478 1
dotrim(log, numdays, flags, perm, owner_uid, group_gid, daemon_pid)
a484 1
	pid_t	daemon_pid;
d497 1
a497 2
                printf("rm -f %s\n", file1);
                printf("rm -f %s\n", zfile1);
d532 16
d560 5
a564 29
        if (noaction)  {
                printf("Start new log...");
        } else {
                fd = open(log, O_WRONLY|O_TRUNC|O_CREAT, perm);
                if (fd < 0)
			err(1, "can't start '%s' log", log);
                if (fchown(fd, owner_uid, group_gid))
			err(1, "can't chown '%s' log file", log);
                if (fchmod(fd, perm))
			err(1, "can't chmod '%s' log file", log);
                (void)close(fd);
		/* Add status message */
                if (!(flags & CE_BINARY) && log_trim(log))
			err(1, "can't add status message to log '%s'", log);
        }
        if (noaction)
                (void)printf("kill -HUP %d\n", daemon_pid);
	else if (daemon_pid != (pid_t)-1) {
		if (daemon_pid < MIN_PID)
			warnx("preposterous process number: %d", daemon_pid);
		else if (kill(daemon_pid, SIGHUP))
			warnx("warning - could not HUP daemon");
	}
	if (flags & CE_COMPACT) {
		if (noaction)
			(void)printf("Compress %s.0\n", log);
		else
			compress_log(log);
	}
@


1.24
log
@Back out version 1.21 since it breaks age rotation.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.23 1999/11/06 20:46:31 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.23 1999/11/06 20:46:31 millert Exp $";
a101 2
#define kbytes(size)  (((size) + 1023) >> 10)

d110 2
a111 2
        int     uid;            /* Owner of log */
        int     gid;            /* Group of log */
a121 2
extern const char *__progname;

d138 1
a138 1
void dotrim __P((char *, int, int, int, int, int, int));
d151 2
a152 1
int main(argc, argv)
d159 1
a159 1
        PRS(argc,argv);
d166 1
a166 1
                p=p->next;
d168 1
a168 1
                q=p;
d177 2
a178 1
void do_entry(ent)
d182 2
a183 1
        int     size, modtime, pid;
d188 3
a190 3
        pid = -1;
        if ((f = fopen(ent->pidfile,"r")) != NULL) {
        	if (fgets(line,BUFSIZ,f))
d193 2
a194 1
	}
d211 1
a211 1
                if (!monitor && ((ent->size > 0) && (size >= ent->size)) ||
d213 1
a213 1
                                        || (modtime < 0)))) {
d221 2
a222 4
                } else {
                        if (verbose)
                                printf("--> skipping\n");
                }
d226 2
a227 1
void PRS(argc, argv)
d239 1
a239 1
        (void) gethostname(hostname, sizeof(hostname));
d247 1
a247 1
        while ((c = getopt(argc,argv,"nrvmf:t:")) != -1) {
d270 2
a271 1
void usage()
d273 4
a276 1
	fprintf(stderr, "usage: %s [-nrvm] [-f config-file]\n", __progname);
d283 2
a284 1
struct conf_entry *parse_file()
d288 1
a288 1
        char    *errline, *group;
d294 1
a294 3
        if (strcmp(conf,"-"))
                f = fopen(conf,"r");
        else
d296 4
a299 2
        if (!f)
		err(1, conf);
d301 2
a302 2
        while (fgets(line,BUFSIZ,f)) {
                if ((line[0]== '\n') || (line[0] == '#'))
d319 1
a319 1
                q = parse = missing_field(sob(line),errline);
d325 1
a325 1
                q = parse = missing_field(sob(++parse),errline);
d327 27
a353 27
                if ((group = strchr(q, '.')) != NULL) {
                    *group++ = '\0';
                    if (*q) {
                        if (!(isnumberstr(q))) {
                            if ((pass = getpwnam(q)) == NULL)
				errx(1, "Error in config file; unknown user: %s", q);
                            working->uid = pass->pw_uid;
                        } else
                            working->uid = atoi(q);
                    } else
                        working->uid = NONE;
                    
                    q = group;
                    if (*q) {
                        if (!(isnumberstr(q))) {
                            if ((grp = getgrnam(q)) == NULL)
				errx(1, "Error in config file; unknown group: %s", q);
                            working->gid = grp->gr_gid;
                        } else
                            working->gid = atoi(q);
                    } else
                        working->gid = NONE;
                    
                    q = parse = missing_field(sob(++parse),errline);
                    *(parse = son(parse)) = '\0';
                } else 
                    working->uid = working->gid = NONE;
d355 1
a355 1
                if (!sscanf(q,"%o",&working->permissions))
d358 1
a358 1
                q = parse = missing_field(sob(++parse),errline);
d360 1
a360 1
                if (!sscanf(q,"%d",&working->numlogs) || working->numlogs < 0)
d363 1
a363 1
                q = parse = missing_field(sob(++parse),errline);
d370 1
a370 1
                q = parse = missing_field(sob(++parse),errline);
d406 2
d412 5
d418 1
d423 1
a423 1
        (void) fclose(f);
d427 4
a430 2
char *missing_field(p, errline)
        char    *p,*errline;
d440 2
a441 1
void dotrim(log, numdays, flags, perm, owner_uid, group_gid, daemon_pid)
d446 3
a448 3
        int     owner_uid;
        int     group_gid;
	int	daemon_pid;
d456 4
a459 5
        /* Remove oldest log */
        (void) sprintf(file1,"%s.%d",log,numdays);
        (void) strcpy(zfile1, file1);
        (void) strcat(zfile1, COMPRESS_POSTFIX);

d464 2
a465 2
                (void) unlink(file1);
                (void) unlink(zfile1);
d470 4
a473 4
                (void) strcpy(file2,file1);
                (void) sprintf(file1,"%s.%d",log,numdays);
                (void) strcpy(zfile1, file1);
                (void) strcpy(zfile2, file2);
d475 4
a478 3
                        (void) strcat(zfile1, COMPRESS_POSTFIX);
                        (void) strcat(zfile2, COMPRESS_POSTFIX);
                        if (lstat(zfile1, &st)) continue;
d481 1
a481 1
                        printf("mv %s %s\n",zfile1,zfile2);
d483 1
a483 1
                        printf("chown %d.%d %s\n",
d486 6
a491 3
                        (void) rename(zfile1, zfile2);
                        (void) chmod(zfile2, perm);
                        (void) chown(zfile2, owner_uid, group_gid);
d495 1
a495 1
                (void) log_trim(log);  /* Report the trimming to the old log */
d499 3
a501 3
			printf("rm %s\n",log);
		else
			(void) unlink(log);
d504 3
a506 3
	                printf("mv %s to %s\n",log,file1);
	        else
	                (void) rename(log,file1);
d514 1
a514 1
			err(1, "can't start \'%s\' log", log);
d516 1
a516 1
			err(1, "can't chown \'%s\' log file", log);
d518 5
a522 5
			err(1, "can't chmod \'%s\' log file", log, perm);
                (void) close(fd);
                if (!(flags & CE_BINARY))
                        if (log_trim(log))	/* Add status message */
                                err(1, "can't add status message to log \'%s\'", log);
d525 7
a531 5
                printf("kill -HUP %d\n",daemon_pid);
        else if (daemon_pid < MIN_PID)
		warnx("preposterous process number: %d", daemon_pid);
        else if (kill(daemon_pid,SIGHUP))
		warnx("warning - could not HUP daemon");
d534 1
a534 1
			printf("Compress %s.0\n",log);
d541 2
a542 1
int log_trim(log)
d546 2
a547 1
        if ((f = fopen(log,"a")) == NULL)
d549 2
a550 2
        fprintf(f,"%s %s newsyslog[%d]: logfile turned over\n",
                daytime, hostname, getpid());
d557 2
a558 1
void compress_log(log)
d561 1
a561 1
        int     pid;
d565 1
a565 1
        (void) sprintf(tmp,"%s.0",log);
d569 1
a569 1
                (void) execl(COMPRESS,"compress","-f",tmp,0);
d576 2
a577 1
int sizefile(file)
d582 1
a582 1
        if (stat(file,&sb) < 0)
d584 1
a584 1
        return(kbytes(dbtob(sb.st_blocks)));
d587 3
a589 2
/* Return the age of old log file (file.0) or -1 if no old log file */
int age_old_log(file)
d595 3
a597 3
        (void) strcpy(tmp,file);
        if (stat(strcat(tmp,".0"),&sb) < 0)
            if (stat(strcat(tmp,COMPRESS_POSTFIX), &sb) < 0)
d603 2
a604 1
char *sob(p)
d613 2
a614 1
char *son(p)
a621 1
        
d623 2
a624 2

int isnumberstr(string)
d627 1
a627 1
        while (*string != '\0') {
d634 2
a635 1
void domonitor(log, whom)
d741 2
a742 1
FILE *openmail()
d758 2
a759 1
void closemail(pfp)
d765 2
a766 1
void child_killer(signum)
@


1.23
log
@back out unwanted private change
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.22 1999/11/06 20:45:26 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.22 1999/11/06 20:45:26 millert Exp $";
d146 1
a146 1
int age_old_log __P((char *, int *));
d200 1
a200 2
	if (age_old_log(ent->log, &modtime) == -1)
		modtime = 0;
d529 1
a529 1
        if (fclose(f) == EOF) {
a530 1
        }
d563 2
a564 2
/* Return the age of old log file (file.0) */
int age_old_log(file, mtime)
a565 1
	int	*mtime;
d574 1
a574 2
	*mtime = (int) (timenow - sb.st_mtime + 1800) / 3600;
	return(0);
@


1.22
log
@Use fchmod instead of chmod and open() instead of creat().
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.21 1999/10/13 17:24:23 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.21 1999/10/13 17:24:23 millert Exp $";
d201 1
a201 1
		modtime = -1;
@


1.21
log
@age_old_log() now takes an int * as a parameter so it can return -1
on failure w/o the caller thinking the difference in mtime is -1.
Just set modtime to 0 in this case in the caller which effectively
ignores it.  This fixes a problem where if there was now foo.0 file
newsyslog would rotate an empty file.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.20 1999/08/27 08:49:29 fgsch Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.20 1999/08/27 08:49:29 fgsch Exp $";
d201 1
a201 1
		modtime = 0;
d492 1
a492 1
        if (noaction) 
d494 2
a495 2
        else {
                fd = creat(log,perm);
d500 2
a506 4
        if (noaction)
                printf("chmod %o %s...",perm,log);
        else
                (void) chmod(log,perm);
@


1.20
log
@Replace some strlen with sizeof() - 1.
Don't forget to malloc space for newline.
Suggested by aazubel@@cnba.uba.ar; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.19 1999/06/08 15:42:54 kstailey Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.19 1999/06/08 15:42:54 kstailey Exp $";
d146 1
a146 1
int age_old_log __P((char *));
d200 2
a201 1
        modtime = age_old_log(ent->log);
d568 1
a568 1
int age_old_log(file)
d570 1
d579 2
a580 1
        return( (int) (timenow - sb.st_mtime + 1800) / 3600);
@


1.19
log
@fewer strings
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.18 1999/03/08 03:16:34 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.18 1999/03/08 03:16:34 millert Exp $";
d631 1
a631 1
	fname = (char *) malloc(strlen(STATS_DIR) + strlen(flog) + 17);
d722 1
a722 1
	cmdbuf = (char *) malloc(strlen(SENDMAIL) + 3);
@


1.18
log
@numlogs cannot be negative; karls@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.17 1999/01/05 00:43:44 deraadt Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.17 1999/01/05 00:43:44 deraadt Exp $";
d196 3
a198 6
        if (verbose) {
                if (ent->flags & CE_COMPACT)
                        printf("%s <%dZ>: ",ent->log,ent->numlogs);
                else
                        printf("%s <%d>: ",ent->log,ent->numlogs);
        }
d216 3
a218 8
                        if (noaction && !verbose) {
                                if (ent->flags & CE_COMPACT)
                                        printf("%s <%dZ>: trimming",
                                               ent->log,ent->numlogs);
                                else
                                        printf("%s <%d>: trimming",
                                               ent->log,ent->numlogs);
                        }
@


1.17
log
@do not concern ourselves with MAX_PID
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.16 1999/01/04 19:24:17 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.16 1999/01/04 19:24:17 millert Exp $";
d364 1
a364 1
                if (!sscanf(q,"%d",&working->numlogs))
@


1.16
log
@MIN_PID should be 4 since update is proc 3 now
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.15 1998/12/28 06:28:15 deraadt Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.15 1998/12/28 06:28:15 deraadt Exp $";
a132 1
#define MAX_PID		99999
d518 1
a518 1
        else if (daemon_pid < MIN_PID || daemon_pid > MAX_PID)
d521 7
a527 7
                        warnx("warning - could not HUP daemon");
        if (flags & CE_COMPACT) {
                if (noaction)
                        printf("Compress %s.0\n",log);
                else
                        compress_log(log);
        }
d532 1
a532 1
        char    *log;
@


1.15
log
@crank PID_MAX to 99999
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.14 1998/09/24 03:36:58 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.14 1998/09/24 03:36:58 millert Exp $";
d132 1
a132 1
#define MIN_PID		3
d154 1
d161 1
d167 1
d174 4
d546 1
a546 1
/* Fork of /usr/ucb/compress to compress the old log file */
d559 2
a560 1
		err(1, COMPRESS);
d746 9
@


1.14
log
@Add optional support for pid files other than /var/run/syslog.pid
Useful for rotating httpd logs.
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.13 1998/04/25 18:12:58 mickey Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.13 1998/04/25 18:12:58 mickey Exp $";
d133 1
a133 1
#define MAX_PID		30000
@


1.13
log
@be more verbose on errors.
one typo in fchown error msg
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.12 1997/07/10 17:37:10 kstailey Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.12 1997/07/10 17:37:10 kstailey Exp $";
d120 1
a131 1
int     syslog_pid;             /* read in from /etc/syslog.pid */
d133 1
a133 1
#define MAX_PID		65534
d143 1
a143 1
void dotrim __P((char *, int, int, int, int, int));
d178 11
a188 1
        int     size, modtime;
d222 1
a222 1
                               ent->permissions, ent->uid, ent->gid);
a234 2
        FILE    *f;
        char    line[BUFSIZ];
a240 8
        /* Let's find the pid of syslogd */
        syslog_pid = 0;
        f = fopen(PIDFILE,"r");
        if (f && fgets(line,BUFSIZ,f))
                syslog_pid = atoi(line);
	if (f)
		(void)fclose(f);

d275 2
a276 1
	errx(1, "usage: %s <-nrvm> <-f config-file>", __progname);
d399 9
d421 1
a421 2
                fprintf(stderr, "%s: Missing field in config file line:\n",
		    __progname);
d428 1
a428 1
void dotrim(log, numdays, flags, perm, owner_uid, group_gid)
d435 1
d511 5
a515 5
                printf("kill -HUP %d (syslogd)\n",syslog_pid);
        else if (syslog_pid < MIN_PID || syslog_pid > MAX_PID)
		warnx("preposterous process number: %d", syslog_pid);
        else if (kill(syslog_pid,SIGHUP))
                        warnx("warning - could not restart syslogd");
@


1.12
log
@NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.11 1997/07/08 04:26:00 downsj Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.11 1997/07/08 04:26:00 downsj Exp $";
d488 1
a488 1
			err(1, "can't start new log");
d490 1
a490 1
			err(1, "can't chmod new log file");
d494 1
a494 1
                                err(1, "can't add status message to log");
@


1.11
log
@err()/warn()
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.10 1997/07/07 22:50:56 downsj Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.10 1997/07/07 22:50:56 downsj Exp $";
d229 1
a229 1
        timenow = time((time_t *) 0);
d402 1
a402 1
                working->next = (struct conf_entry *) NULL;
@


1.10
log
@Add rudimentary logfile monitoring capabilities; enable by placing an 'M'
in the flags field, followed by the username to be notified in an additional
(optional, based on the presence of 'M' in flags) field.

Man page to follow...
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.9 1997/04/27 13:48:55 downsj Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.9 1997/04/27 13:48:55 downsj Exp $";
d100 1
d123 2
a124 1
char    *progname;              /* contains argv[0] */
d162 2
a163 4
        if (needroot && getuid() && geteuid()) {
                fprintf(stderr,"%s: must have root privs\n",progname);
                exit(1);
        }
d168 1
a168 1
                free((char *) q);
a228 1
        progname = argv[0];
d275 1
a275 3
        fprintf(stderr,
                "Usage: %s <-nrv> <-f config-file>\n", progname);
        exit(1);
d295 3
a297 5
        if (!f) {
                (void) fprintf(stderr,"%s: ",progname);
                perror(conf);
                exit(1);
        }
d302 2
a303 5
		if (errline == NULL) {
			(void) fprintf(stderr,"%s: ",progname);
			perror("strdup()");
			exit(1);
		}
d306 2
a307 5
			if (working == NULL) {
				(void) fprintf(stderr,"%s: ",progname);
				perror("malloc()");
				exit(1);
			}
d311 2
a312 5
			if (working->next == NULL) {
				(void) fprintf(stderr,"%s: ",progname);
				perror("malloc()");
				exit(1);
			}
d319 2
a320 5
		if (working->log == NULL) {
			(void) fprintf(stderr,"%s: ",progname);
			perror("strdup()");
			exit(1);
		}
d328 2
a329 6
                            if ((pass = getpwnam(q)) == NULL) {
                                fprintf(stderr,
                                    "Error in config file; unknown user:\n");
                                fputs(errline,stderr);
                                exit(1);
                            }
d339 2
a340 6
                            if ((grp = getgrnam(q)) == NULL) {
                                fprintf(stderr,
                                    "Error in config file; unknown group:\n");
                                fputs(errline,stderr);
                                exit(1);
                            }
d349 1
a349 2
                }
                else 
d352 2
a353 6
                if (!sscanf(q,"%o",&working->permissions)) {
                        fprintf(stderr,
                                "Error in config file; bad permissions:\n");
                        fputs(errline,stderr);
                        exit(1);
                }
d357 2
a358 6
                if (!sscanf(q,"%d",&working->numlogs)) {
                        fprintf(stderr,
                                "Error in config file; bad number:\n");
                        fputs(errline,stderr);
                        exit(1);
                }
d384 2
a385 6
                        else {
                                fprintf(stderr,
                                        "Illegal flag in config file -- %c\n",
                                        *q);
                                exit(1);
                        }
d395 2
a396 5
			if (working->log == NULL) {
				(void) fprintf(stderr,"%s: ",progname);
				perror("strdup()");
				exit(1);
			}
d411 3
a413 2
                fprintf(stderr,"Missing field in config file:\n");
                fputs(errline,stderr);
d487 4
a490 8
                if (fd < 0) {
                        perror("can't start new log");
                        exit(1);
                }               
                if (fchown(fd, owner_uid, group_gid)) {
                        perror("can't chmod new log file");
                        exit(1);
                }
d493 2
a494 4
                        if (log_trim(log)) {    /* Add status message */
                                perror("can't add status message to log");
                                exit(1);
                        }
d502 4
a505 8
        else
	if (syslog_pid < MIN_PID || syslog_pid > MAX_PID) {
		fprintf(stderr,"%s: preposterous process number: %d\n",
				progname, syslog_pid);
        } else if (kill(syslog_pid,SIGHUP)) {
                        fprintf(stderr,"%s: ",progname);
                        perror("warning - could not restart syslogd");
                }
d524 1
a524 2
                perror("log_trim: fclose:");
                exit(1);
d539 1
a539 3
                fprintf(stderr,"%s: ",progname);
                perror("fork");
                exit(1);
d542 1
a542 3
                fprintf(stderr,"%s: ",progname);
                perror(COMPRESS);
                exit(1);
d615 3
a617 5
	if (flog == NULL) {
		(void) fprintf(stderr,"%s: ",progname);
		perror("strdup()");
		exit(1);
	}
d623 3
a625 5
	if (fname == NULL) {
		(void) fprintf(stderr,"%s: ",progname);
		perror("malloc()");
		exit(1);
	}
d634 1
a634 2
		(void) fprintf(stderr,"%s: ",progname);
		perror(fname);
d655 2
a656 5
		if (rb == NULL) {
			(void) fprintf(stderr,"%s: ",progname);
			perror("malloc()");
			exit(1);
		}
d661 1
a661 2
			(void) fprintf(stderr,"%s: ",progname);
			perror(log);
d667 1
a667 2
			(void) fprintf(stderr,"%s: ",progname);
			perror("fread()");
d677 1
a677 2
			(void) fprintf(stderr,"%s: ",progname);
			perror("openmail()");
d691 1
a691 2
		(void) fprintf(stderr,"%s: ",progname);
		perror(fname);
@


1.9
log
@Prototype fixes and cruft removal.
@
text
@d1 33
a33 1
/*	$OpenBSD: newsyslog.c,v 1.8 1997/01/15 23:42:56 millert Exp $	*/
d64 1
a64 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.8 1997/01/15 23:42:56 millert Exp $";
d79 6
d103 4
a106 3
#define CE_COMPACT 1            /* Compact the achived log files */
#define CE_BINARY 2             /* Logfile is in binary, don't add */
                                /* status messages */
d118 1
d126 1
d148 4
a151 1
int isnumber __P((char *));
d196 3
a198 1
                if (((ent->size > 0) && (size >= ent->size)) ||
d251 1
a251 1
        while ((c = getopt(argc,argv,"nrvf:t:")) != -1) {
d265 3
d307 5
d314 5
d322 5
d333 5
d344 1
a344 1
                        if (!(isnumber(q))) {
d359 1
a359 1
                        if (!(isnumber(q))) {
d416 2
d426 13
d647 2
a648 2
int isnumber(string)
char *string;
d655 140
@


1.8
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.7 1996/12/07 08:00:45 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.7 1996/12/07 08:00:45 deraadt Exp $";
d49 5
d58 1
d61 1
a61 5
#include <sys/types.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/param.h>
#include <sys/wait.h>
a63 4
#ifdef _IBMR2
/* Calculates (db * DEV_BSIZE) */
#define dbtob(db)  ((unsigned)(db) << UBSHIFT) 
#endif
a81 6
extern int      optind;
extern char     *optarg;
extern char *malloc();
extern uid_t getuid(),geteuid();
extern time_t time();

d95 13
a107 2
struct conf_entry *parse_file();
char *sob(), *son(), *strdup(), *missing_field();
d109 1
a109 1
main(argc,argv)
d130 1
a130 1
do_entry(ent)
d174 1
a174 1
PRS(argc,argv)
d200 2
a201 1
	if (p = strchr(hostname, '.')) {
a202 1
	}
d205 1
a205 1
        while ((c = getopt(argc,argv,"nrvf:t:")) != -1)
d223 1
d225 1
a225 1
usage()
d364 1
a364 1
char *missing_field(p,errline)
d375 1
a375 1
dotrim(log,numdays,flags,perm,owner_uid,group_gid)
a388 8
#ifdef _IBMR2
/* AIX 3.1 has a broken fchown- if the owner_uid is -1, it will actually */
/* change it to be owned by uid -1, instead of leaving it as is, as it is */
/* supposed to. */
                if (owner_uid == -1)
                  owner_uid = geteuid();
#endif

d481 1
a481 1
log_trim(log)
d497 1
a497 1
compress_log(log)
a541 15

#ifndef OSF
/* Duplicate a string using malloc */

char *strdup(strp)
register char   *strp;
{
        register char *cp;

        if ((cp = malloc((unsigned) strlen(strp) + 1)) == NULL)
                abort();
        return(strcpy (cp, strp));
}
#endif

d563 1
a563 1
isnumber(string)
d567 2
a568 2
            if (*string < '0' || *string > '9') return(0);
            string++;
@


1.7
log
@increase buf sizes, hacked w/ bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.6 1996/09/02 18:47:16 tholo Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.6 1996/09/02 18:47:16 tholo Exp $";
d202 1
a202 1
        while ((c=getopt(argc,argv,"nrvf:t:")) != EOF)
@


1.6
log
@Save the log file if the original number of days was > 0; don't rely on
being able to use numdays after aging the existing logfiles
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.5 1996/08/31 14:20:36 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.5 1996/08/31 14:20:36 deraadt Exp $";
d99 1
a99 1
char    hostname[64];           /* hostname */
d379 2
a380 2
        char    file1[128], file2[128];
        char    zfile1[128], zfile2[128];
d505 1
a505 1
        char    tmp[128];
d537 1
a537 1
        char tmp[MAXPATHLEN+3];
@


1.5
log
@do ngen == 0 correctly; netbsd pr#2724; kstailey@@dol-esa.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.4 1996/07/22 10:09:17 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.4 1996/07/22 10:09:17 deraadt Exp $";
d383 1
d431 1
a431 1
	if (numdays == -1) {
@


1.4
log
@rcsid cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: newsyslog.c,v 1.3 1996/06/26 05:37:29 deraadt Exp $	*/
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.3 1996/06/26 05:37:29 deraadt Exp $";
d430 12
a441 4
        if (noaction) 
                printf("mv %s to %s\n",log,file1);
        else
                (void) rename(log,file1);
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a28 2
 *      $Source: /cvs/src/usr.bin/newsyslog/newsyslog.c,v $
 *      $Author: deraadt $
d32 1
a32 1
static char rcsid[] = "$OpenBSD: newsyslog.c,v 1.2 1996/01/07 07:36:11 deraadt Exp $";
@


1.2
log
@date formatting glitch; from kashmir@@umiacs.UMD.EDU; netbsd pr#1906
@
text
@d1 2
d34 1
a34 1
static char rcsid[] = "$Id: newsyslog.c,v 1.1.1.1 1995/10/18 08:45:51 deraadt Exp $";
@


1.1
log
@Initial revision
@
text
@d27 2
a28 2
 *      $Source: /a/cvsroot/src/usr.bin/newsyslog/newsyslog.c,v $
 *      $Author: jtc $
d32 1
a32 1
static char rcsid[] = "$Id: newsyslog.c,v 1.9 1995/01/21 21:53:46 jtc Exp $";
d183 1
a183 1
        daytime[16] = '\0';
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
