head	1.28;
access;
symbols
	OPENBSD_6_0:1.25.0.4
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.10
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.4
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.2
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.14
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.12
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.10
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.8
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2016.12.22.16.42.55;	author krw;	state Exp;
branches;
next	1.27;
commitid	Af8jL6Z5UssXxIBS;

1.27
date	2016.12.20.22.19.08;	author krw;	state Exp;
branches;
next	1.26;
commitid	he6NK9EzIygmfrzo;

1.26
date	2016.12.20.21.10.29;	author krw;	state Exp;
branches;
next	1.25;
commitid	eUUrhVUzBaA6QlWo;

1.25
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	0Dp7Dy9FuNZesYo2;

1.24
date	2013.11.28.18.24.54;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.16.07.31.05;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.09.22.22.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.19.20.31.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.06.18.49.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.13.09.09.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.07.18.44.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	97.10.11.21.10.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.10.15.29.34;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Avoid "unused variable 'i'" warnings in generated .c files by only emitting
the "int i;" for non-opaque arrays. Opaque arrays use xdr_opaque() rather
than iterating over the array.

Eliminates another couple of dozen warnings from snap build output.

ok deraadt@@ millert@@
@
text
@/*	$OpenBSD: rpc_cout.c,v 1.27 2016/12/20 22:19:08 krw Exp $	*/
/*	$NetBSD: rpc_cout.c,v 1.6 1996/10/01 04:13:53 cgd Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_cout.c, XDR routine outputter for the RPC protocol compiler
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "rpc_parse.h"
#include "rpc_util.h"

static int findtype(definition *, char *);
static int undefined(char *);
static void print_generic_header(char *, int);
static void print_header(definition *);
static void print_prog_header(proc_list *);
static void print_trailer(void);
static void print_ifopen(int, char *);
static void print_ifarg(char *);
static void print_ifsizeof(char *, char *);
static void print_ifclose(int);
static void print_ifstat(int, char *, char *, relation, char *, char *, char *);
static void emit_program(definition *);
static void emit_enum(definition *);
static void emit_union(definition *);
static void emit_struct(definition *);
static void emit_typedef(definition *);
static void print_stat(int, declaration *);
void emit_inline(declaration *, int);
void emit_single_in_line(declaration *, int, relation);

/*
 * Emit the C-routine for the given definition
 */
void
emit(def)
	definition *def;
{
	if (def->def_kind == DEF_CONST) {
		return;
	}
	if (def->def_kind == DEF_PROGRAM) {
		emit_program(def);
		return;
	}
	if (def->def_kind == DEF_TYPEDEF) {
		/* now we need to handle declarations like struct typedef foo
		 * foo; since we dont want this to be expanded into 2 calls to
		 * xdr_foo */

		if (strcmp(def->def.ty.old_type, def->def_name) == 0)
			return;
	}

	print_header(def);
	switch (def->def_kind) {
	case DEF_UNION:
		emit_union(def);
		break;
	case DEF_ENUM:
		emit_enum(def);
		break;
	case DEF_STRUCT:
		emit_struct(def);
		break;
	case DEF_TYPEDEF:
		emit_typedef(def);
		break;
	default:
		break;
	}
	print_trailer();
}

static int
findtype(def, type)
	definition *def;
	char	*type;
{

	if (def->def_kind == DEF_PROGRAM || def->def_kind == DEF_CONST) {
		return (0);
	} else {
		return (streq(def->def_name, type));
	}
}

static int
undefined(type)
	char	*type;
{
	definition *def;

	def = (definition *) FINDVAL(defined, type, findtype);
	return (def == NULL);
}

static void
print_generic_header(procname, pointerp)
	char	*procname;
	int	pointerp;
{
	fprintf(fout, "\n");
	fprintf(fout, "bool_t\n");
	if (Cflag) {
		fprintf(fout, "xdr_%s(", procname);
		fprintf(fout, "XDR *xdrs, ");
		fprintf(fout, "%s ", procname);
		if (pointerp)
			fprintf(fout, "*");
		fprintf(fout, "objp)\n{\n");
	} else {
		fprintf(fout, "xdr_%s(xdrs, objp)\n", procname);
		fprintf(fout, "\tXDR *xdrs;\n");
		fprintf(fout, "\t%s ", procname);
		if (pointerp)
			fprintf(fout, "*");
		fprintf(fout, "objp;\n{\n");
	}
}

static void
print_header(def)
	definition *def;
{
	print_generic_header(def->def_name,
	    def->def_kind != DEF_TYPEDEF ||
	    !isvectordef(def->def.ty.old_type, def->def.ty.rel));

	/* Now add Inline support */

	if (doinline == 0)
		return;
}

static void
print_prog_header(plist)
	proc_list *plist;
{
	print_generic_header(plist->args.argname, 1);
}

static void
print_trailer()
{
	fprintf(fout, "\treturn (TRUE);\n");
	fprintf(fout, "}\n");
}

static void
print_ifopen(indent, name)
	int     indent;
	char   *name;
{
	tabify(fout, indent);
	fprintf(fout, "if (!xdr_%s(xdrs", name);
}

static void
print_ifarg(arg)
	char   *arg;
{
	fprintf(fout, ", %s", arg);
}

static void
print_ifsizeof(prefix, type)
	char   *prefix;
	char   *type;
{
	if (streq(type, "bool")) {
		fprintf(fout, ", sizeof(bool_t), (xdrproc_t)xdr_bool");
	} else {
		fprintf(fout, ", sizeof(");
		if (undefined(type) && prefix) {
			fprintf(fout, "%s ", prefix);
		}
		fprintf(fout, "%s), (xdrproc_t)xdr_%s", type, type);
	}
}

static void
print_ifclose(indent)
	int     indent;
{
	fprintf(fout, "))\n");
	tabify(fout, indent);
	fprintf(fout, "\treturn (FALSE);\n");
}

static void
print_ifstat(indent, prefix, type, rel, amax, objname, name)
	int     indent;
	char   *prefix;
	char   *type;
	relation rel;
	char   *amax;
	char   *objname;
	char   *name;
{
	char   *alt = NULL;

	switch (rel) {
	case REL_POINTER:
		print_ifopen(indent, "pointer");
		print_ifarg("(char **)");
		fprintf(fout, "%s", objname);
		print_ifsizeof(prefix, type);
		break;
	case REL_VECTOR:
		if (streq(type, "string")) {
			alt = "string";
		} else
			if (streq(type, "opaque")) {
				alt = "opaque";
			}
		if (alt) {
			print_ifopen(indent, alt);
			print_ifarg(objname);
			print_ifarg(amax);
		} else {
			print_ifopen(indent, "vector");
			print_ifarg("(char *)");
			fprintf(fout, "%s,\n", objname);
			tabify(fout, indent);
			fprintf(fout, "    %s", amax);
		}
		if (!alt) {
			print_ifsizeof(prefix, type);
		}
		break;
	case REL_ARRAY:
		if (streq(type, "string")) {
			alt = "string";
		} else
			if (streq(type, "opaque")) {
				alt = "bytes";
			}
		if (streq(type, "string")) {
			print_ifopen(indent, alt);
			print_ifarg(objname);
			print_ifarg(amax);
		} else {
			if (alt) {
				print_ifopen(indent, alt);
			} else {
				print_ifopen(indent, "array");
			}
			print_ifarg("(char **)");
			if (*objname == '&') {
				fprintf(fout, "%s.%s_val,\n\t    (u_int *)%s.%s_len",
				    objname, name, objname, name);
			} else {
				fprintf(fout, "&%s->%s_val,\n\t    (u_int *)&%s->%s_len",
				    objname, name, objname, name);
			}
			fprintf(fout, ",\n\t    %s", amax);
		}
		if (!alt) {
			print_ifsizeof(prefix, type);
		}
		break;
	case REL_ALIAS:
		print_ifopen(indent, type);
		print_ifarg(objname);
		break;
	}
	print_ifclose(indent);
}

/* ARGSUSED */
static void
emit_enum(def)
	definition *def;
{
	fprintf(fout, "\n");

	print_ifopen(1, "enum");
	print_ifarg("(enum_t *)objp");
	print_ifclose(1);
}

static void
emit_program(def)
	definition *def;
{
	decl_list *dl;
	version_list *vlist;
	proc_list *plist;

	for (vlist = def->def.pr.versions; vlist != NULL; vlist = vlist->next)
		for (plist = vlist->procs; plist != NULL; plist = plist->next) {
			if (!newstyle || plist->arg_num < 2)
				continue;	/* old style, or single
						 * argument */
			print_prog_header(plist);
			for (dl = plist->args.decls; dl != NULL;
			    dl = dl->next)
				print_stat(1, &dl->decl);
			print_trailer();
		}
}

static void
emit_union(def)
	definition *def;
{
	declaration *dflt;
	case_list *cl;
	declaration *cs;
	char   *object;
	static const char vecformat[] = "objp->%s_u.%s";
	static const char format[] = "&objp->%s_u.%s";

	fprintf(fout, "\n");
	print_stat(1, &def->def.un.enum_decl);
	fprintf(fout, "\tswitch (objp->%s) {\n", def->def.un.enum_decl.name);
	for (cl = def->def.un.cases; cl != NULL; cl = cl->next) {
		fprintf(fout, "\tcase %s:\n", cl->case_name);
		if (cl->contflag == 1)	/* a continued case statement */
			continue;
		cs = &cl->case_decl;
		if (!streq(cs->type, "void")) {
			int len = strlen(def->def_name) + strlen(format) +
			    strlen(cs->name) + 1;

			object = malloc(len);
			if (object == NULL) {
				fprintf(stderr, "Fatal error: no memory\n");
				crash();
			}
			if (isvectordef(cs->type, cs->rel)) {
				snprintf(object, len, vecformat, def->def_name,
				    cs->name);
			} else {
				snprintf(object, len, format, def->def_name,
				    cs->name);
			}
			print_ifstat(2, cs->prefix, cs->type, cs->rel, cs->array_max,
			    object, cs->name);
			free(object);
		}
		fprintf(fout, "\t\tbreak;\n");
	}
	dflt = def->def.un.default_decl;
	fprintf(fout, "\tdefault:\n");
	if (dflt != NULL) {
		if (!streq(dflt->type, "void")) {
			int len = strlen(def->def_name) + strlen(format) +
			    strlen(dflt->name) + 1;

			object = malloc(len);
			if (object == NULL) {
				fprintf(stderr, "Fatal error: no memory\n");
				crash();
			}
			if (isvectordef(dflt->type, dflt->rel)) {
				snprintf(object, len, vecformat, def->def_name,
				    dflt->name);
			} else {
				snprintf(object, len, format, def->def_name,
				    dflt->name);
			}

			print_ifstat(2, dflt->prefix, dflt->type, dflt->rel,
			    dflt->array_max, object, dflt->name);
			free(object);
		}
		fprintf(fout, "\t\tbreak;\n");
	} else {
		fprintf(fout, "\t\treturn (FALSE);\n");
	}

	fprintf(fout, "\t}\n");
}

static void
emit_struct(def)
	definition *def;
{
	decl_list *dl;
	int     i, j, size, flag;
	decl_list *cur, *psav;
	bas_type *ptr;
	char   *sizestr, *plus;
	char    ptemp[256];
	int     can_inline;

	if (doinline == 0) {
		for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
			print_stat(1, &dl->decl);
		return;
	}
	for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
		if (dl->decl.rel == REL_VECTOR &&
		    strcmp(dl->decl.type, "opaque") != 0) {
			fprintf(fout, "\tint i;\n");
			break;
		}
	fprintf(fout, "\n");

	size = 0;
	can_inline = 0;
	for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
		if (dl->decl.prefix == NULL &&
		    (ptr = find_type(dl->decl.type)) != NULL &&
		    (dl->decl.rel == REL_ALIAS || dl->decl.rel == REL_VECTOR)) {
			if (dl->decl.rel == REL_ALIAS)
				size += ptr->length;
			else {
				can_inline = 1;
				break;	/* can be inlined */
			}
		} else {
			if (size >= doinline) {
				can_inline = 1;
				break;	/* can be inlined */
			}
			size = 0;
		}
	if (size > doinline)
		can_inline = 1;

	if (can_inline == 0) {	/* can not inline, drop back to old mode */
		fprintf(fout, "\n");
		for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
			print_stat(1, &dl->decl);
		return;
	}

	/* May cause lint to complain. but  ... */
	fprintf(fout, "\tint32_t *buf;\n");

	flag = PUT;
	for (j = 0; j < 2; j++) {
		if (flag == PUT)
			fprintf(fout, "\n\tif (xdrs->x_op == XDR_ENCODE) {\n");
		else
			fprintf(fout, "\t\treturn (TRUE);\n\t} else if (xdrs->x_op == XDR_DECODE) {\n");

		i = 0;
		size = 0;
		sizestr = NULL;
		for (dl = def->def.st.decls; dl != NULL; dl = dl->next) {	/* xxx */

			/* now walk down the list and check for basic types */
			if (dl->decl.prefix == NULL &&
			    (ptr = find_type(dl->decl.type)) != NULL &&
			    (dl->decl.rel == REL_ALIAS || dl->decl.rel == REL_VECTOR)) {
				if (i == 0)
					cur = dl;
				i++;

				if (dl->decl.rel == REL_ALIAS)
					size += ptr->length;
				else {
					/* this is required to handle arrays */

					if (sizestr == NULL)
						plus = "";
					else
						plus = "+";

					if (ptr->length != 1)
						snprintf(ptemp, sizeof ptemp,
						    "%s%s* %d", plus,
						    dl->decl.array_max,
						    ptr->length);
					else
						snprintf(ptemp, sizeof ptemp,
						    "%s%s", plus,
						    dl->decl.array_max);

					/* now concatenate to sizestr !!!! */
					if (sizestr == NULL) {
						sizestr = strdup(ptemp);
						if (sizestr == NULL) {
							fprintf(stderr,
							    "Fatal error: no memory\n");
							crash();
						}
					} else {
						size_t len;

						len = strlen(sizestr) +
						    strlen(ptemp) + 1;
						sizestr = realloc(sizestr, len);
						if (sizestr == NULL) {
							fprintf(stderr,
							    "Fatal error: no memory\n");
							crash();
						}
						/* build up length of array */
						strlcat(sizestr, ptemp, len);
					}
				}

			} else {
				if (i > 0) {
					if (sizestr == NULL && size < doinline) {
						/* don't expand into inline
						 * code if size < doinline */
						while (cur != dl) {
							print_stat(2, &cur->decl);
							cur = cur->next;
						}
					} else {
						/* were already looking at a
						 * xdr_inlineable structure */
						if (sizestr == NULL)
							fprintf(fout,
							    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    %d * BYTES_PER_XDR_UNIT);", size);
						else if (size == 0)
							fprintf(fout,
							    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    %s * BYTES_PER_XDR_UNIT);",
								    sizestr);
						else
							fprintf(fout,
							    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    (%d + %s) * BYTES_PER_XDR_UNIT);", size, sizestr);

						fprintf(fout,
						    "\n\t\tif (buf == NULL) {\n");

						psav = cur;
						while (cur != dl) {
							print_stat(3, &cur->decl);
							cur = cur->next;
						}

						fprintf(fout, "\t\t} else {\n");

						cur = psav;
						while (cur != dl) {
							emit_inline(&cur->decl, flag);
							cur = cur->next;
						}
						fprintf(fout, "\t\t}\n");
					}
				}
				size = 0;
				i = 0;
				sizestr = NULL;
				print_stat(2, &dl->decl);
			}
		}
		if (i > 0) {
			if (sizestr == NULL && size < doinline) {
				/* don't expand into inline code if size <
				 * doinline */
				while (cur != dl) {
					print_stat(2, &cur->decl);
					cur = cur->next;
				}
			} else {
				/* were already looking at a xdr_inlineable
				 * structure */
				if (sizestr == NULL)
					fprintf(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    %d * BYTES_PER_XDR_UNIT);",
					    size);
				else
					if (size == 0)
						fprintf(fout,
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    %s * BYTES_PER_XDR_UNIT);",
						    sizestr);
					else
						fprintf(fout,
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,\n\t\t    (%d + %s) * BYTES_PER_XDR_UNIT);",
						    size, sizestr);

				fprintf(fout, "\n\t\tif (buf == NULL) {\n");

				psav = cur;
				while (cur != NULL) {
					print_stat(3, &cur->decl);
					cur = cur->next;
				}
				fprintf(fout, "\t\t} else {\n");

				cur = psav;
				while (cur != dl) {
					emit_inline(&cur->decl, flag);
					cur = cur->next;
				}

				fprintf(fout, "\t\t}\n");

			}
		}
		flag = GET;
	}
	fprintf(fout, "\t\treturn (TRUE);\n\t}\n\n");

	/* now take care of XDR_FREE case */

	for (dl = def->def.st.decls; dl != NULL; dl = dl->next)
		print_stat(1, &dl->decl);
}

static void
emit_typedef(def)
	definition *def;
{
	char   *prefix = def->def.ty.old_prefix;
	char   *type = def->def.ty.old_type;
	char   *amax = def->def.ty.array_max;
	relation rel = def->def.ty.rel;

	fprintf(fout, "\n");
	print_ifstat(1, prefix, type, rel, amax, "objp", def->def_name);
}

static void
print_stat(indent, dec)
	declaration *dec;
	int     indent;
{
	char   *prefix = dec->prefix;
	char   *type = dec->type;
	char   *amax = dec->array_max;
	relation rel = dec->rel;
	char    name[256];

	if (isvectordef(type, rel)) {
		snprintf(name, sizeof name, "objp->%s", dec->name);
	} else {
		snprintf(name, sizeof name, "&objp->%s", dec->name);
	}
	print_ifstat(indent, prefix, type, rel, amax, name, dec->name);
}

char   *upcase(char *);

void
emit_inline(decl, flag)
	declaration *decl;
	int     flag;
{
	/*check whether an array or not */

	switch (decl->rel) {
	case REL_ALIAS:
		fprintf(fout, "\t");
		emit_single_in_line(decl, flag, REL_ALIAS);
		break;
	case REL_VECTOR:
		fprintf(fout, "\t\t\t{\n\t\t\t\t%s *genp;\n\n", decl->type);
		fprintf(fout, "\t\t\t\tfor (i = 0, genp = objp->%s;\n\t\t\t\t    i < %s; i++) {\n\t\t\t",
		    decl->name, decl->array_max);
		emit_single_in_line(decl, flag, REL_VECTOR);
		fprintf(fout, "\t\t\t\t}\n\t\t\t}\n");
		break;
	default:
		break;

	}
}

void
emit_single_in_line(decl, flag, rel)
	declaration *decl;
	int     flag;
	relation rel;
{
	char   *upp_case;
	int     freed = 0;

	if (flag == PUT)
		fprintf(fout, "\t\tIXDR_PUT_");
	else
		if (rel == REL_ALIAS)
			fprintf(fout, "\t\tobjp->%s = IXDR_GET_", decl->name);
		else
			fprintf(fout, "\t\t*genp++ = IXDR_GET_");

	upp_case = upcase(decl->type);

	/* hack  - XX */
	if (strcmp(upp_case, "INT") == 0) {
		free(upp_case);
		freed = 1;
		upp_case = "LONG";
	}
	if (strcmp(upp_case, "U_INT") == 0) {
		free(upp_case);
		freed = 1;
		upp_case = "U_LONG";
	}
	if (flag == PUT)
		if (rel == REL_ALIAS)
			fprintf(fout, "%s(buf, objp->%s);\n", upp_case, decl->name);
		else
			fprintf(fout, "%s(buf, *genp++);\n", upp_case);

	else
		fprintf(fout, "%s(buf);\n", upp_case);
	if (!freed)
		free(upp_case);
}

char *
upcase(str)
	char   *str;
{
	char   *ptr, *hptr;

	ptr = malloc(strlen(str)+1);
	if (ptr == (char *) NULL) {
		fprintf(stderr, "malloc failed\n");
		exit(1);
	}

	hptr = ptr;
	while (*str != '\0')
		*ptr++ = toupper((unsigned char)*str++);

	*ptr = '\0';
	return (hptr);
}
@


1.27
log
@Add 'default:' cases to switch statements that gcc whines about.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.26 2016/12/20 21:10:29 krw Exp $	*/
d428 2
a429 1
		if (dl->decl.rel == REL_VECTOR) {
@


1.26
log
@Tweak generated .c output so switch statements always have a
'default:' case.

Several hundred "not handled" warnings go away.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.25 2015/08/20 22:32:41 deraadt Exp $	*/
d102 2
d683 3
@


1.25
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.24 2013/11/28 18:24:54 deraadt Exp $	*/
d377 1
a382 1
			fprintf(fout, "\tdefault:\n");
a398 1
			fprintf(fout, "\t\tbreak;\n");
d400 1
a401 1
		fprintf(fout, "\tdefault:\n");
@


1.24
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.23 2013/10/27 18:31:24 guenther Exp $	*/
d358 1
a358 1
			object = alloc(len);
d383 1
a383 1
			object = alloc(len);
d518 1
a518 1
						sizestr = (char *)realloc(sizestr, len);
d734 1
a734 1
	ptr = (char *) malloc(strlen(str)+1);
@


1.23
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.22 2012/12/05 23:20:26 deraadt Exp $	*/
d742 1
a742 1
		*ptr++ = toupper(*str++);
@


1.22
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.21 2010/09/01 14:43:34 millert Exp $	*/
d343 2
a344 2
	char   *vecformat = "objp->%s_u.%s";
	char   *format = "&objp->%s_u.%s";
@


1.21
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.20 2009/10/27 23:59:42 deraadt Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.20
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.19 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 7
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
d7 3
a9 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d11 9
a19 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d21 12
a32 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.19
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.18 2004/07/16 07:31:05 matthieu Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_cout.c 1.13 89/02/22 (C) 1987 SMI";
#endif
@


1.18
log
@Avoid generating an unused variable. From NetBSD. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.17 2004/05/09 22:22:45 deraadt Exp $	*/
d34 1
a34 1
static char sccsid[] = "@@(#)rpc_cout.c 1.13 89/02/22 (C) 1987 SMI";
@


1.17
log
@delint
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.16 2003/06/19 20:31:08 deraadt Exp $	*/
a167 2
	/* May cause lint to complain. but  ... */
	fprintf(fout, "\tint32_t *buf;\n");
d459 1
d465 3
d471 1
a471 1
			fprintf(fout, "\tif (xdrs->x_op == XDR_ENCODE) {\n");
@


1.16
log
@generate code that is much more ANSI and even KNF too
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.15 2003/04/06 18:49:18 deraadt Exp $	*/
a58 1
static void emit_num(definition *);
@


1.15
log
@use strlcat
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.14 2003/03/13 09:09:34 deraadt Exp $	*/
d170 1
a170 1
	fprintf(fout, "\tint32_t *buf;\n\n");
d223 1
a223 1
	fprintf(fout, ")) {\n");
a225 2
	tabify(fout, indent);
	fprintf(fout, "}\n");
d257 1
d261 3
a263 1
			fprintf(fout, "%s", objname);
a264 1
		print_ifarg(amax);
d279 1
d288 1
a288 1
				fprintf(fout, "%s.%s_val, (u_int *)%s.%s_len",
d291 1
a291 1
				fprintf(fout, "&%s->%s_val, (u_int *)&%s->%s_len",
d294 1
a295 1
		print_ifarg(amax);
d313 2
d352 1
d366 1
a366 1
				fprintf(stderr, "Fatal error : no memory\n");
d391 1
a391 1
				fprintf(stderr, "Fatal error : no memory\n");
d437 2
d470 1
a470 1
			fprintf(fout, "\n\tif (xdrs->x_op == XDR_ENCODE) {\n");
d493 1
a493 1
						plus = " ";
d499 1
a499 1
						    " %s %s * %d", plus,
d504 1
a504 1
						    " %s %s ", plus,
d512 1
a512 1
							    "Fatal error : no memory\n");
d523 1
a523 1
							    "Fatal error : no memory\n");
d544 6
a549 2
							fprintf(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %d * BYTES_PER_XDR_UNIT);",
							    size);
d551 2
a552 8
							if (size == 0)
								fprintf(fout,
								    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %s * BYTES_PER_XDR_UNIT);",
								    sizestr);
							else
								fprintf(fout,
								    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, (%d + %s)* BYTES_PER_XDR_UNIT);",
								    size, sizestr);
d554 2
a555 1
						fprintf(fout, "\n\t\tif (buf == NULL) {\n");
a569 1

a577 1

d591 1
a591 1
					fprintf(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %d * BYTES_PER_XDR_UNIT);",
d596 1
a596 1
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %s * BYTES_PER_XDR_UNIT);",
d600 1
a600 1
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, (%d + %s)* BYTES_PER_XDR_UNIT);",
d641 1
@


1.14
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.13 2002/07/05 05:39:42 deraadt Exp $	*/
d510 5
a514 2
						sizestr = (char *)realloc(sizestr,
						    strlen(sizestr) + strlen(ptemp) + 1);
d521 1
a521 1
						sizestr = strcat(sizestr, ptemp);
@


1.13
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.12 2002/06/01 01:40:38 deraadt Exp $	*/
d357 4
a360 2
			object = alloc(strlen(def->def_name) + strlen(format) +
			    strlen(cs->name) + 1);
d366 1
a366 1
				sprintf(object, vecformat, def->def_name,
d369 1
a369 1
				sprintf(object, format, def->def_name,
d381 3
d385 1
a385 2
			object = alloc(strlen(def->def_name) + strlen(format) +
			    strlen(dflt->name) + 1);
d391 1
a391 1
				sprintf(object, vecformat, def->def_name,
d394 1
a394 1
				sprintf(object, format, def->def_name,
@


1.12
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.11 2002/02/16 21:27:51 millert Exp $	*/
d359 4
d382 4
d498 1
a498 1
					if (sizestr == NULL)
a499 2
					else {
						sizestr = (char *)realloc(sizestr, strlen(sizestr) + strlen(ptemp) + 1);
d501 2
a502 1
							fprintf(stderr, "Fatal error : no memory\n");
d505 10
a514 3
						sizestr = strcat(sizestr, ptemp);	/* build up length of
											 * array */

@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.10 2001/12/05 09:50:31 deraadt Exp $	*/
d138 2
a139 2
	f_print(fout, "\n");
	f_print(fout, "bool_t\n");
d141 3
a143 3
		f_print(fout, "xdr_%s(", procname);
		f_print(fout, "XDR *xdrs, ");
		f_print(fout, "%s ", procname);
d145 2
a146 2
			f_print(fout, "*");
		f_print(fout, "objp)\n{\n");
d148 3
a150 3
		f_print(fout, "xdr_%s(xdrs, objp)\n", procname);
		f_print(fout, "\tXDR *xdrs;\n");
		f_print(fout, "\t%s ", procname);
d152 2
a153 2
			f_print(fout, "*");
		f_print(fout, "objp;\n{\n");
d170 1
a170 1
	f_print(fout, "\tint32_t *buf;\n\n");
d183 2
a184 2
	f_print(fout, "\treturn (TRUE);\n");
	f_print(fout, "}\n");
d193 1
a193 1
	f_print(fout, "if (!xdr_%s(xdrs", name);
d200 1
a200 1
	f_print(fout, ", %s", arg);
d209 1
a209 1
		f_print(fout, ", sizeof(bool_t), (xdrproc_t)xdr_bool");
d211 1
a211 1
		f_print(fout, ", sizeof(");
d213 1
a213 1
			f_print(fout, "%s ", prefix);
d215 1
a215 1
		f_print(fout, "%s), (xdrproc_t)xdr_%s", type, type);
d223 1
a223 1
	f_print(fout, ")) {\n");
d225 1
a225 1
	f_print(fout, "\treturn (FALSE);\n");
d227 1
a227 1
	f_print(fout, "}\n");
d246 1
a246 1
		f_print(fout, "%s", objname);
d262 1
a262 1
			f_print(fout, "%s", objname);
d287 1
a287 1
				f_print(fout, "%s.%s_val, (u_int *)%s.%s_len",
d290 1
a290 1
				f_print(fout, "&%s->%s_val, (u_int *)&%s->%s_len",
d350 1
a350 1
	f_print(fout, "\tswitch (objp->%s) {\n", def->def.un.enum_decl.name);
d352 1
a352 1
		f_print(fout, "\tcase %s:\n", cl->case_name);
d360 1
a360 1
				s_print(object, vecformat, def->def_name,
d363 1
a363 1
				s_print(object, format, def->def_name,
d370 1
a370 1
		f_print(fout, "\t\tbreak;\n");
d375 1
a375 1
			f_print(fout, "\tdefault:\n");
d379 1
a379 1
				s_print(object, vecformat, def->def_name,
d382 1
a382 1
				s_print(object, format, def->def_name,
d389 1
a389 1
			f_print(fout, "\t\tbreak;\n");
d392 2
a393 2
		f_print(fout, "\tdefault:\n");
		f_print(fout, "\t\treturn (FALSE);\n");
d396 1
a396 1
	f_print(fout, "\t}\n");
d418 1
a418 1
			f_print(fout, "\tint i;\n");
d452 1
a452 1
			f_print(fout, "\n\tif (xdrs->x_op == XDR_ENCODE) {\n");
d454 1
a454 1
			f_print(fout, "\t\treturn (TRUE);\n\t} else if (xdrs->x_op == XDR_DECODE) {\n");
d480 4
a483 1
						s_print(ptemp, " %s %s * %d", plus, dl->decl.array_max, ptr->length);
d485 3
a487 1
						s_print(ptemp, " %s %s ", plus, dl->decl.array_max);
d495 1
a495 1
							f_print(stderr, "Fatal error : no memory\n");
d517 1
a517 1
							f_print(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %d * BYTES_PER_XDR_UNIT);",
d521 1
a521 1
								f_print(fout,
d525 1
a525 1
								f_print(fout,
d529 1
a529 1
						f_print(fout, "\n\t\tif (buf == NULL) {\n");
d537 1
a537 1
						f_print(fout, "\t\t} else {\n");
d545 1
a545 1
						f_print(fout, "\t\t}\n");
d567 1
a567 1
					f_print(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs, %d * BYTES_PER_XDR_UNIT);",
d571 1
a571 1
						f_print(fout,
d575 1
a575 1
						f_print(fout,
d579 1
a579 1
				f_print(fout, "\n\t\tif (buf == NULL) {\n");
d586 1
a586 1
				f_print(fout, "\t\t} else {\n");
d594 1
a594 1
				f_print(fout, "\t\t}\n");
d600 1
a600 1
	f_print(fout, "\t\treturn (TRUE);\n\t}\n\n");
d632 1
a632 1
		s_print(name, "objp->%s", dec->name);
d634 1
a634 1
		s_print(name, "&objp->%s", dec->name);
d650 1
a650 1
		f_print(fout, "\t");
d654 2
a655 2
		f_print(fout, "\t\t\t{\n\t\t\t\t%s *genp;\n\n", decl->type);
		f_print(fout, "\t\t\t\tfor (i = 0, genp = objp->%s;\n\t\t\t\t    i < %s; i++) {\n\t\t\t",
d658 1
a658 1
		f_print(fout, "\t\t\t\t}\n\t\t\t}\n");
d673 1
a673 1
		f_print(fout, "\t\tIXDR_PUT_");
d676 1
a676 1
			f_print(fout, "\t\tobjp->%s = IXDR_GET_", decl->name);
d678 1
a678 1
			f_print(fout, "\t\t*genp++ = IXDR_GET_");
d695 1
a695 1
			f_print(fout, "%s(buf, objp->%s);\n", upp_case, decl->name);
d697 1
a697 1
			f_print(fout, "%s(buf, *genp++);\n", upp_case);
d700 1
a700 1
		f_print(fout, "%s(buf);\n", upp_case);
d713 1
a713 1
		f_print(stderr, "malloc failed\n");
@


1.10
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.8 2001/11/24 19:17:47 deraadt Exp $	*/
d48 20
a67 20
static int findtype __P((definition *, char *));
static int undefined __P((char *));
static void print_generic_header __P((char *, int));
static void print_header __P((definition *));
static void print_prog_header __P((proc_list *));
static void print_trailer __P((void));
static void print_ifopen __P((int, char *));
static void print_ifarg __P((char *));
static void print_ifsizeof __P((char *, char *));
static void print_ifclose __P((int));
static void print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static void emit_num __P((definition *));
static void emit_program __P((definition *));
static void emit_enum __P((definition *));
static void emit_union __P((definition *));
static void emit_struct __P((definition *));
static void emit_typedef __P((definition *));
static void print_stat __P((int, declaration *));
void emit_inline __P((declaration *, int));
void emit_single_in_line __P((declaration *, int, relation));
d634 1
a634 1
char   *upcase __P((char *));
@


1.9
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.7 2001/11/07 18:44:28 deraadt Exp $	*/
d44 1
d48 20
a67 19
static findtype __P((definition *, char *));
static undefined __P((char *));
static print_generic_header __P((char *, int));
static print_header __P((definition *));
static print_prog_header __P((proc_list *));
static print_trailer __P((void));
static print_ifopen __P((int, char *));
static print_ifarg __P((char *));
static print_ifsizeof __P((char *, char *));
static print_ifclose __P((int));
static print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static emit_num __P((definition *));
static emit_program __P((definition *));
static emit_enum __P((definition *));
static emit_union __P((definition *));
static emit_struct __P((definition *));
static emit_typedef __P((definition *));
static print_stat __P((int, declaration *));

d110 1
a110 1
static
d113 1
a113 1
	char   *type;
d123 1
a123 1
static
d125 1
a125 1
	char   *type;
a129 2


d133 1
a133 1
static
d135 2
a136 2
	char   *procname;
	int     pointerp;
d157 1
a157 1
static
a160 6

	decl_list *dl;
	bas_type *ptr;
	int     i;


a166 1

a170 1

d173 1
a173 1
static
d180 1
a180 1
static
d187 1
a187 2

static
d196 1
a196 1
static
d203 1
a203 1
static
d219 1
a219 1
static
d230 1
a230 1
static
d308 1
a308 1
static
d317 1
a317 1
static
d338 1
a338 2

static
a351 1

d399 1
a399 1
static
a410 1

d424 3
a426 4
		if ((dl->decl.prefix == NULL) &&
		    ((ptr = find_type(dl->decl.type)) != NULL) &&
		    ((dl->decl.rel == REL_ALIAS) || (dl->decl.rel == REL_VECTOR))) {

a448 3



a450 1

a455 1

d462 3
a464 1
			if ((dl->decl.prefix == NULL) && ((ptr = find_type(dl->decl.type)) != NULL) && ((dl->decl.rel == REL_ALIAS) || (dl->decl.rel == REL_VECTOR))) {
a489 1

d500 1
a500 1
				if (i > 0)
a508 3



d542 1
d550 1
a550 1
		if (i > 0)
a558 1

d592 1
d603 1
a603 1
static
a611 1

d615 1
a615 1
static
a633 1

d636 1
a636 1

d641 1
a641 2

/*check whether an array or not */
d658 1
a666 2


a697 1

a699 1

a705 1

a717 1

@


1.8
log
@half finished KNF
@
text
@a43 1
#include <ctype.h>
d47 19
a65 20
static int findtype __P((definition *, char *));
static int undefined __P((char *));
static void print_generic_header __P((char *, int));
static void print_header __P((definition *));
static void print_prog_header __P((proc_list *));
static void print_trailer __P((void));
static void print_ifopen __P((int, char *));
static void print_ifarg __P((char *));
static void print_ifsizeof __P((char *, char *));
static void print_ifclose __P((int));
static void print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static void emit_num __P((definition *));
static void emit_program __P((definition *));
static void emit_enum __P((definition *));
static void emit_union __P((definition *));
static void emit_struct __P((definition *));
static void emit_typedef __P((definition *));
static void print_stat __P((int, declaration *));
void emit_inline __P((declaration *, int));
void emit_single_in_line __P((declaration *, int, relation));
d108 1
a108 1
static int
d111 1
a111 1
	char	*type;
d121 1
a121 1
static int
d123 1
a123 1
	char	*type;
d128 2
d133 1
a133 1
static void
d135 2
a136 2
	char	*procname;
	int	pointerp;
d157 1
a157 1
static void
d161 6
d173 1
d178 1
d181 1
a181 1
static void
d188 1
a188 1
static void
d195 2
a196 1
static void
d205 1
a205 1
static void
d212 1
a212 1
static void
d228 1
a228 1
static void
d239 1
a239 1
static void
d317 1
a317 1
static void
d326 1
a326 1
static void
d347 2
a348 1
static void
d362 1
d410 1
a410 1
static void
d422 1
d439 1
d462 3
d467 1
d473 1
d506 1
d517 1
a517 1
				if (i > 0) {
d526 3
a561 1
				}
d569 1
a569 1
		if (i > 0) {
d578 1
a612 1
		}
d622 1
a622 1
static void
d631 1
d635 1
a635 1
static void
d654 1
d657 1
a657 1
void
d662 2
a663 1
	/*check whether an array or not */
a679 1
void
d688 2
d721 1
d724 1
d731 1
d744 1
@


1.7
log
@rpcgen is not nearly KNF, but it now generates close to KNF code
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.6 2001/07/18 22:26:00 deraadt Exp $	*/
d44 1
d48 20
a67 19
static findtype __P((definition *, char *));
static undefined __P((char *));
static print_generic_header __P((char *, int));
static print_header __P((definition *));
static print_prog_header __P((proc_list *));
static print_trailer __P((void));
static print_ifopen __P((int, char *));
static print_ifarg __P((char *));
static print_ifsizeof __P((char *, char *));
static print_ifclose __P((int));
static print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static emit_num __P((definition *));
static emit_program __P((definition *));
static emit_enum __P((definition *));
static emit_union __P((definition *));
static emit_struct __P((definition *));
static emit_typedef __P((definition *));
static print_stat __P((int, declaration *));

d110 1
a110 1
static
d113 1
a113 1
	char   *type;
d123 1
a123 1
static
d125 1
a125 1
	char   *type;
a129 2


d133 1
a133 1
static
d135 2
a136 2
	char   *procname;
	int     pointerp;
d157 1
a157 1
static
a160 6

	decl_list *dl;
	bas_type *ptr;
	int     i;


a166 1

a170 1

d173 1
a173 1
static
d180 1
a180 1
static
d187 1
a187 2

static
d196 1
a196 1
static
d203 1
a203 1
static
d219 1
a219 1
static
d230 1
a230 1
static
d308 1
a308 1
static
d317 1
a317 1
static
d338 1
a338 2

static
a351 1

d399 1
a399 1
static
a410 1

a426 1

a448 3



a450 1

a455 1

a487 1

d498 1
a498 1
				if (i > 0)
a506 3



d540 1
d548 1
a548 1
		if (i > 0)
a556 1

d591 1
d601 1
a601 1
static
a609 1

d613 1
a613 1
static
a631 1

d634 1
a634 1

d639 1
a639 2

/*check whether an array or not */
d656 1
a664 2


a695 1

a697 1

a703 1

a715 1

@


1.6
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.4 1997/10/11 21:10:41 deraadt Exp $	*/
d88 1
a88 1
	};
d146 1
a146 1
		f_print(fout, "objp)\n{\n\n");
d153 1
a153 1
		f_print(fout, "objp;\n{\n\n");
d177 1
a177 1
	f_print(fout, "\t register int32_t *buf;\n\n");
d202 1
a202 1
	f_print(fout, " if (!xdr_%s(xdrs", name);
d234 1
a234 1
	f_print(fout, "\t return (FALSE);\n");
d236 1
a236 1
	f_print(fout, " }\n");
d430 1
a430 1
			f_print(fout, "\t int i;\n");
d445 1
a445 1
			};
d460 1
a460 1
	};
d469 1
a469 1
			f_print(fout, "\n\t if (xdrs->x_op == XDR_ENCODE) {\n");
d471 1
a471 1
			f_print(fout, "\n \t return (TRUE);\n\t} else if (xdrs->x_op == XDR_DECODE) {\n");
d507 1
a507 1
							f_print(stderr, "Fatal error : no memory \n");
d509 1
a509 1
						};
d522 1
a522 1
							print_stat(1, &cur->decl);
d532 1
a532 1
							f_print(fout, "\t buf = (int32_t *)XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
d537 1
a537 1
								    "\t buf = (int32_t *)XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
d541 1
a541 1
								    "\t buf = (int32_t *)XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
d544 1
a544 1
						f_print(fout, "\n\t   if (buf == NULL) {\n");
d548 1
a548 1
							print_stat(2, &cur->decl);
d552 1
a552 1
						f_print(fout, "\n\t  }\n\t  else {\n");
d560 1
a560 1
						f_print(fout, "\t  }\n");
d565 1
a565 1
				print_stat(1, &dl->decl);
d574 1
a574 1
					print_stat(1, &cur->decl);
d582 1
a582 1
					f_print(fout, "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
d587 1
a587 1
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
d591 1
a591 1
						    "\t\tbuf = (int32_t *)XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
d598 1
a598 1
					print_stat(2, &cur->decl);
d601 1
a601 1
				f_print(fout, "\n\t  }\n\t  else {\n");
d609 1
a609 1
				f_print(fout, "\t  }\n");
d614 1
a614 1
	f_print(fout, "\t return(TRUE);\n\t}\n\n");
d667 1
d671 2
a672 2
		f_print(fout, "\t\t{ register %s *genp; \n", decl->type);
		f_print(fout, "\t\t  for ( i = 0,genp=objp->%s;\n \t\t\ti < %s; i++){\n\t\t",
d675 1
a675 1
		f_print(fout, "\t\t   }\n\t\t };\n");
d691 1
a691 1
		f_print(fout, "\t\t IXDR_PUT_");
d694 1
a694 1
			f_print(fout, "\t\t objp->%s = IXDR_GET_", decl->name);
d696 1
a696 1
			f_print(fout, "\t\t *genp++ = IXDR_GET_");
d713 1
a713 1
			f_print(fout, "%s(buf,objp->%s);\n", upp_case, decl->name);
d715 1
a715 1
			f_print(fout, "%s(buf,*genp++);\n", upp_case);
d734 1
a734 1
		f_print(stderr, "malloc failed \n");
d736 1
a736 1
	};
@


1.5
log
@-Wall cleanup; ok deraadt
@
text
@a43 2
#include <ctype.h>
#include <err.h>
d47 18
a64 17
static int findtype __P((definition *, char *));
static int undefined __P((char *));
static void print_generic_header __P((char *, int));
static void print_header __P((definition *));
static void print_prog_header __P((proc_list *));
static void print_trailer __P((void));
static void print_ifopen __P((int, char *));
static void print_ifarg __P((char *));
static void print_ifsizeof __P((char *, char *));
static void print_ifclose __P((int));
static void print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static void emit_program __P((definition *));
static void emit_enum __P((definition *));
static void emit_union __P((definition *));
static void emit_struct __P((definition *));
static void emit_typedef __P((definition *));
static void print_stat __P((int, declaration *));
a103 5
	case DEF_CONST:
	case DEF_PROGRAM:
		errx(1, "Internal error %s, %d: Case %d not handled\n",
		    __FILE__, __LINE__, def->def_kind);
		break;
d108 1
a108 1
static int
d121 1
a121 1
static int
d133 1
a133 1
static void
d157 1
a157 1
static void
d162 5
d181 1
a181 1
static void
d188 1
a188 1
static void
d196 1
a196 1
static void
d205 1
a205 1
static void
d212 1
a212 1
static void
d228 1
a228 1
static void
d239 1
a239 1
static void
d317 1
a317 1
static void
d326 1
a326 1
static void
d348 1
a348 1
static void
d410 1
a410 1
static void
d517 1
a517 1
				if (i > 0) {
a561 1
				}
d569 1
a569 1
		if (i > 0) {
a612 1
		}
d622 1
a622 1
static void
d635 1
a635 1
static void
a657 1
void
a674 4
	case REL_ARRAY:
	case REL_POINTER:
		errx(1, "Internal error %s, %d: Case %d not handled\n",
		    __FILE__, __LINE__, decl->rel);
a678 1
void
@


1.4
log
@s/inline/doinline/; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.3 1996/12/10 15:29:34 deraadt Exp $	*/
d44 2
d49 17
a65 18
static findtype __P((definition *, char *));
static undefined __P((char *));
static print_generic_header __P((char *, int));
static print_header __P((definition *));
static print_prog_header __P((proc_list *));
static print_trailer __P((void));
static print_ifopen __P((int, char *));
static print_ifarg __P((char *));
static print_ifsizeof __P((char *, char *));
static print_ifclose __P((int));
static print_ifstat __P((int, char *, char *, relation, char *, char *, char *));
static emit_num __P((definition *));
static emit_program __P((definition *));
static emit_enum __P((definition *));
static emit_union __P((definition *));
static emit_struct __P((definition *));
static emit_typedef __P((definition *));
static print_stat __P((int, declaration *));
d105 5
d114 1
a114 1
static
d127 1
a127 1
static
d139 1
a139 1
static
d163 1
a163 1
static
a167 5
	decl_list *dl;
	bas_type *ptr;
	int     i;


d182 1
a182 1
static
d189 1
a189 1
static
d197 1
a197 1
static
d206 1
a206 1
static
d213 1
a213 1
static
d229 1
a229 1
static
d240 1
a240 1
static
d318 1
a318 1
static
d327 1
a327 1
static
d349 1
a349 1
static
d411 1
a411 1
static
d518 1
a518 1
				if (i > 0)
d563 1
d571 1
a571 1
		if (i > 0)
d615 1
d625 1
a625 1
static
d638 1
a638 1
static
d661 1
d679 4
d687 1
@


1.3
log
@from netbsd; treat arrays used with XDR_INLINE as arrays of 'int32_t's,
rather than arrays of 'long's.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_cout.c,v 1.2 1996/06/26 05:38:35 deraadt Exp $	*/
d174 1
a174 1
	if (inline == 0)
d423 1
a423 1
	if (inline == 0) {
d447 1
a447 1
			if (size >= inline) {
d453 1
a453 1
	if (size > inline)
d518 1
a518 1
					if (sizestr == NULL && size < inline) {
d520 1
a520 1
						 * code if size < inline */
d570 1
a570 1
			if (sizestr == NULL && size < inline) {
d572 1
a572 1
				 * inline */
@


1.2
log
@rcsid
@
text
@d1 2
a2 2
/*	$OpenBSD: rpc_cout.c,v 1.5 1995/08/29 23:05:49 cgd Exp $	*/
/*	$NetBSD: rpc_cout.c,v 1.5 1995/08/29 23:05:49 cgd Exp $	*/
d177 1
a177 1
	f_print(fout, "\t register long *buf;\n\n");
d532 1
a532 1
							f_print(fout, "\t buf = (long *)XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
d537 1
a537 1
								    "\t buf = (long *)XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
d541 1
a541 1
								    "\t buf = (long *)XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
d582 1
a582 1
					f_print(fout, "\t\tbuf = (long *)XDR_INLINE(xdrs,%d * BYTES_PER_XDR_UNIT);",
d587 1
a587 1
						    "\t\tbuf = (long *)XDR_INLINE(xdrs,%s * BYTES_PER_XDR_UNIT);",
d591 1
a591 1
						    "\t\tbuf = (long *)XDR_INLINE(xdrs,(%d + %s)* BYTES_PER_XDR_UNIT);",
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
