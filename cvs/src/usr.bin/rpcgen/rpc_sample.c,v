head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.22
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.20
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.16
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.12
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.14
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.6
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.10
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.8
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.4
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.18
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.16
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.09.03.35.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.24.17.59.22;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.07.18.44.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	97.11.15.22.10.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@/*	$OpenBSD: rpc_sample.c,v 1.17 2010/09/01 14:43:34 millert Exp $	*/
/*	$NetBSD: rpc_sample.c,v 1.2 1995/06/11 21:50:01 pk Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_sample.c, Sample client-server code outputter for the RPC protocol compiler
 */

#include <stdio.h>
#include <string.h>
#include "rpc_parse.h"
#include "rpc_util.h"

static char RQSTP[] = "rqstp";

static void write_sample_client(char *, version_list *);
static void write_sample_server(definition *);
static void return_type(proc_list *);

void
write_sample_svc(def)
	definition *def;
{

	if (def->def_kind != DEF_PROGRAM)
		return;
	write_sample_server(def);
}


int
write_sample_clnt(def)
	definition *def;
{
	version_list *vp;
	int count = 0;

	if (def->def_kind != DEF_PROGRAM)
		return(0);
	/* generate sample code for each version */
	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
		write_sample_client(def->def_name, vp);
		++count;
	}
	return(count);
}


static void
write_sample_client(program_name, vp)
	char *program_name;
	version_list *vp;
{
	proc_list *proc;
	int i;
	decl_list *l;

	fprintf(fout, "\n\nvoid\n");
	pvname(program_name, vp->vers_num);
	if (Cflag)
		fprintf(fout,"(char *host)\n{\n");
	else
		fprintf(fout, "(host)\nchar *host;\n{\n");
	fprintf(fout, "\tCLIENT *clnt;\n");

	i = 0;
	for (proc = vp->procs; proc != NULL; proc = proc->next) {
		fprintf(fout, "\t");
		ptype(proc->res_prefix, proc->res_type, 1);
		fprintf(fout, " *result_%d;\n",++i);
		/* print out declarations for arguments */
		if (proc->arg_num < 2 && !newstyle) {
			fprintf(fout, "\t");
			if (!streq(proc->args.decls->decl.type, "void"))
				ptype(proc->args.decls->decl.prefix,
				    proc->args.decls->decl.type, 1);
			else
				fprintf(fout, "char *"); /* cannot have "void" type */
			fprintf(fout, " ");
			pvname(proc->proc_name, vp->vers_num);
			fprintf(fout, "_arg;\n");
		} else if (!streq(proc->args.decls->decl.type, "void")) {
			for (l = proc->args.decls; l != NULL; l = l->next) {
				fprintf(fout, "\t");
				ptype(l->decl.prefix, l->decl.type, 1);
				fprintf(fout, " ");
				pvname(proc->proc_name, vp->vers_num);
				fprintf(fout, "_%s;\n", l->decl.name);
		/*		pdeclaration(proc->args.argname, &l->decl, 1, ";\n");*/
			}
		}
	}

	/* generate creation of client handle */
	fprintf(fout, "\tclnt = clnt_create(host, %s, %s, \"%s\");\n",
	    program_name, vp->vers_name, tirpcflag? "netpath" : "udp");
	fprintf(fout, "\tif (clnt == NULL) {\n");
	fprintf(fout, "\t\tclnt_pcreateerror(host);\n");
	fprintf(fout, "\t\texit(1);\n\t}\n");

	/* generate calls to procedures */
	i = 0;
	for (proc = vp->procs; proc != NULL; proc = proc->next) {
		fprintf(fout, "\tresult_%d = ",++i);
		pvname(proc->proc_name, vp->vers_num);
		if (proc->arg_num < 2 && !newstyle) {
			fprintf(fout, "(");
			if (streq(proc->args.decls->decl.type, "void"))
				fprintf(fout, "(void*)");
			fprintf(fout, "&");
			pvname(proc->proc_name, vp->vers_num);
			fprintf(fout, "_arg, clnt);\n");
		} else if (streq(proc->args.decls->decl.type, "void")) {
			fprintf(fout, "(clnt);\n");
		} else {
			fprintf(fout, "(");
			for (l = proc->args.decls;	l != NULL; l = l->next) {
				pvname(proc->proc_name, vp->vers_num);
				fprintf(fout, "_%s, ", l->decl.name);
			}
			fprintf(fout, "clnt);\n");
		}
		fprintf(fout, "\tif (result_%d == NULL) {\n", i);
		fprintf(fout, "\t\tclnt_perror(clnt, \"call failed:\");\n");
		fprintf(fout, "\t}\n");
	}

	fprintf(fout, "\tclnt_destroy(clnt);\n");
	fprintf(fout, "}\n");
}

static void
write_sample_server(def)
	definition *def;
{
	version_list *vp;
	proc_list *proc;

	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
		for (proc = vp->procs; proc != NULL; proc = proc->next) {
			fprintf(fout, "\n");
/*			if (Cflag)
				fprintf(fout, "extern \"C\"{\n");
*/
			return_type(proc);
			fprintf(fout, "* \n");
			pvname_svc(proc->proc_name, vp->vers_num);
			printarglist(proc, RQSTP, "struct svc_req *");

			fprintf(fout, "{\n");
			fprintf(fout, "\n\tstatic ");
			if (!streq(proc->res_type, "void"))
				return_type(proc);
			else
				fprintf(fout, "char*");  /* cannot have void type */
			fprintf(fout, " result;\n");
			fprintf(fout,
			    "\n\t/*\n\t * insert server code here\n\t */\n\n");
			if (!streq(proc->res_type, "void"))
				fprintf(fout, "\treturn(&result);\n}\n");
			else  /* cast back to void * */
				fprintf(fout, "\treturn((void*) &result);\n}\n");
/*			if (Cflag)
				fprintf(fout, "}\n");
*/
		}
	}
}

static void
return_type(plist)
	proc_list *plist;
{
	ptype(plist->res_prefix, plist->res_type, 1);
}

void
add_sample_msg(void)
{
	fprintf(fout, "/*\n");
	fprintf(fout, " * This is sample code generated by rpcgen.\n");
	fprintf(fout, " * These are only templates and you can use them\n");
	fprintf(fout, " * as a guideline for developing your own functions.\n");
	fprintf(fout, " */\n\n");
}

void
write_sample_clnt_main()
{
	list *l;
	definition *def;
	version_list *vp;

	fprintf(fout, "\n\n");
	if (Cflag)
		fprintf(fout,"main(int argc, char *argv[])\n{\n");
	else
		fprintf(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n");

	fprintf(fout, "\tchar *host;");
	fprintf(fout, "\n\n\tif (argc < 2) {");
	fprintf(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n");
	fprintf(fout, "\t\texit(1);\n\t}");
	fprintf(fout, "\n\thost = argv[1];\n");

	for (l = defined; l != NULL; l = l->next) {
		def = l->val;
		if (def->def_kind != DEF_PROGRAM)
			continue;
		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
			fprintf(fout, "\t");
			pvname(def->def_name, vp->vers_num);
			fprintf(fout, "(host);\n");
		}
	}
	fprintf(fout, "}\n");
}
@


1.17
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.16 2009/10/27 23:59:42 deraadt Exp $	*/
a38 1
#include <sys/cdefs.h>
@


1.16
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.15 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 7
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
d7 3
a9 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d11 9
a19 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d21 12
a32 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.15
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.14 2003/07/09 03:35:21 deraadt Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_sample.c  1.1  90/08/30  (C) 1987 SMI";
#endif
@


1.14
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.13 2002/07/05 05:39:42 deraadt Exp $	*/
d34 1
a34 2
static char sccsid[] = "@@(#)rpc_sample.c  1.1  90/08/30  (C) 1987 SMI";

@


1.13
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.12 2002/06/01 01:40:38 deraadt Exp $	*/
a49 1
void printarglist();
d212 1
a212 1
add_sample_msg()
@


1.12
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.11 2002/02/16 21:27:51 millert Exp $	*/
d57 1
a57 1
     definition *def;
d68 1
a68 1
     definition *def;
d70 1
a70 1
        version_list *vp;
d86 2
a87 2
     char *program_name;
     version_list *vp;
d89 8
a96 22
  proc_list *proc;
  int i;
  decl_list *l;

  fprintf(fout, "\n\nvoid\n");
  pvname(program_name, vp->vers_num);
  if (Cflag)
    fprintf(fout,"(char *host)\n{\n");
  else
    fprintf(fout, "(host)\nchar *host;\n{\n");
  fprintf(fout, "\tCLIENT *clnt;\n");

  i = 0;
  for (proc = vp->procs; proc != NULL; proc = proc->next) {
      fprintf(fout, "\t");
      ptype(proc->res_prefix, proc->res_type, 1);
      fprintf(fout, " *result_%d;\n",++i);
      /* print out declarations for arguments */
      if (proc->arg_num < 2 && !newstyle) {
	fprintf(fout, "\t");
	if (!streq(proc->args.decls->decl.type, "void"))
	  ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
d98 29
a126 12
	  fprintf(fout, "char *");  /* cannot have "void" type */
	fprintf(fout, " ");
	pvname(proc->proc_name, vp->vers_num);
	fprintf(fout, "_arg;\n");
      } else if (!streq(proc->args.decls->decl.type, "void")) {
	for (l = proc->args.decls; l != NULL; l = l->next) {
	  fprintf(fout, "\t");
	  ptype(l->decl.prefix, l->decl.type, 1);
	  fprintf(fout, " ");
	  pvname(proc->proc_name, vp->vers_num);
	  fprintf(fout, "_%s;\n", l->decl.name);
/*	  pdeclaration(proc->args.argname, &l->decl, 1, ";\n");*/
a127 2
      }
    }
d129 32
a160 27
  /* generate creation of client handle */
  fprintf(fout, "\tclnt = clnt_create(host, %s, %s, \"%s\");\n",
	  program_name, vp->vers_name, tirpcflag? "netpath" : "udp");
  fprintf(fout, "\tif (clnt == NULL) {\n");
  fprintf(fout, "\t\tclnt_pcreateerror(host);\n");
  fprintf(fout, "\t\texit(1);\n\t}\n");

  /* generate calls to procedures */
  i = 0;
  for (proc = vp->procs; proc != NULL; proc = proc->next) {
      fprintf(fout, "\tresult_%d = ",++i);
      pvname(proc->proc_name, vp->vers_num);
      if (proc->arg_num < 2 && !newstyle) {
	fprintf(fout, "(");
	if (streq(proc->args.decls->decl.type, "void"))  /* cast to void* */
	  fprintf(fout, "(void*)");
	fprintf(fout, "&");
	pvname(proc->proc_name, vp->vers_num);
	fprintf(fout, "_arg, clnt);\n");
      } else if (streq(proc->args.decls->decl.type, "void")) {
	    fprintf(fout, "(clnt);\n");
	  }
      else {
	fprintf(fout, "(");
	for (l = proc->args.decls;  l != NULL; l = l->next) {
	  pvname(proc->proc_name, vp->vers_num);
	  fprintf(fout, "_%s, ", l->decl.name);
a161 6
	fprintf(fout, "clnt);\n");
      }
      fprintf(fout, "\tif (result_%d == NULL) {\n", i);
      fprintf(fout, "\t\tclnt_perror(clnt, \"call failed:\");\n");
      fprintf(fout, "\t}\n");
    }
d163 2
a164 2
  fprintf(fout, "\tclnt_destroy(clnt);\n");
  fprintf(fout, "}\n");
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.10 2001/12/05 09:50:31 deraadt Exp $	*/
d93 1
a93 1
  f_print(fout, "\n\nvoid\n");
d96 1
a96 1
    f_print(fout,"(char *host)\n{\n");
d98 2
a99 2
    f_print(fout, "(host)\nchar *host;\n{\n");
  f_print(fout, "\tCLIENT *clnt;\n");
d103 1
a103 1
      f_print(fout, "\t");
d105 1
a105 1
      f_print(fout, " *result_%d;\n",++i);
d108 1
a108 1
	f_print(fout, "\t");
d112 2
a113 2
	  f_print(fout, "char *");  /* cannot have "void" type */
	f_print(fout, " ");
d115 1
a115 1
	f_print(fout, "_arg;\n");
d118 1
a118 1
	  f_print(fout, "\t");
d120 1
a120 1
	  f_print(fout, " ");
d122 1
a122 1
	  f_print(fout, "_%s;\n", l->decl.name);
d129 1
a129 1
  f_print(fout, "\tclnt = clnt_create(host, %s, %s, \"%s\");\n",
d131 3
a133 3
  f_print(fout, "\tif (clnt == NULL) {\n");
  f_print(fout, "\t\tclnt_pcreateerror(host);\n");
  f_print(fout, "\t\texit(1);\n\t}\n");
d138 1
a138 1
      f_print(fout, "\tresult_%d = ",++i);
d141 1
a141 1
	f_print(fout, "(");
d143 2
a144 2
	  f_print(fout, "(void*)");
	f_print(fout, "&");
d146 1
a146 1
	f_print(fout, "_arg, clnt);\n");
d148 1
a148 1
	    f_print(fout, "(clnt);\n");
d151 1
a151 1
	f_print(fout, "(");
d154 1
a154 1
	  f_print(fout, "_%s, ", l->decl.name);
d156 1
a156 1
	f_print(fout, "clnt);\n");
d158 3
a160 3
      f_print(fout, "\tif (result_%d == NULL) {\n", i);
      f_print(fout, "\t\tclnt_perror(clnt, \"call failed:\");\n");
      f_print(fout, "\t}\n");
d163 2
a164 2
  f_print(fout, "\tclnt_destroy(clnt);\n");
  f_print(fout, "}\n");
d176 1
a176 1
			f_print(fout, "\n");
d178 1
a178 1
				f_print(fout, "extern \"C\"{\n");
d181 1
a181 1
			f_print(fout, "* \n");
d185 2
a186 2
			f_print(fout, "{\n");
			f_print(fout, "\n\tstatic ");
d190 3
a192 3
				f_print(fout, "char*");  /* cannot have void type */
			f_print(fout, " result;\n");
			f_print(fout,
d195 1
a195 1
				f_print(fout, "\treturn(&result);\n}\n");
d197 1
a197 1
				f_print(fout, "\treturn((void*) &result);\n}\n");
d199 1
a199 1
				f_print(fout, "}\n");
d215 5
a219 5
	f_print(fout, "/*\n");
	f_print(fout, " * This is sample code generated by rpcgen.\n");
	f_print(fout, " * These are only templates and you can use them\n");
	f_print(fout, " * as a guideline for developing your own functions.\n");
	f_print(fout, " */\n\n");
d229 1
a229 1
	f_print(fout, "\n\n");
d231 1
a231 1
		f_print(fout,"main(int argc, char *argv[])\n{\n");
d233 1
a233 1
		f_print(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n");
d235 5
a239 5
	f_print(fout, "\tchar *host;");
	f_print(fout, "\n\n\tif (argc < 2) {");
	f_print(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n");
	f_print(fout, "\t\texit(1);\n\t}");
	f_print(fout, "\n\thost = argv[1];\n");
d246 1
a246 1
			f_print(fout, "\t");
d248 1
a248 1
			f_print(fout, "(host);\n");
d251 1
a251 1
	f_print(fout, "}\n");
@


1.10
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.8 2001/11/24 19:17:47 deraadt Exp $	*/
d51 3
a53 3
static void write_sample_client __P((char *, version_list *));
static void write_sample_server __P((definition *));
static void return_type __P((proc_list *));
@


1.9
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.7 2001/11/24 17:59:22 miod Exp $	*/
d51 3
a53 3
static write_sample_client __P((char *, version_list *));
static write_sample_server __P((definition *));
static return_type __P((proc_list *));
d60 2
a61 2
	if (def->def_kind != DEF_PROGRAM) 
	  return;
d73 2
a74 2
	if (def->def_kind != DEF_PROGRAM) 
	  return( 0 );
d77 2
a78 2
	  write_sample_client(def->def_name, vp );
	  ++count;
d80 1
a80 1
	return( count );
d84 3
a86 3
static
write_sample_client(program_name, vp )
     char* program_name;
d93 4
a96 4
  f_print(fout, "\n\nvoid\n" );
  pvname( program_name, vp->vers_num );
  if( Cflag )
    f_print(fout,"( char* host )\n{\n" );
d98 1
a98 1
    f_print(fout, "(host)\nchar *host;\n{\n" );
d107 3
a109 3
      if( proc->arg_num < 2 && !newstyle) {
	f_print( fout, "\t" );
	if( !streq( proc->args.decls->decl.type, "void") )
d112 1
a112 1
	  f_print(fout, "char* ");  /* cannot have "void" type */
d114 1
a114 1
	pvname( proc->proc_name, vp->vers_num );
d116 1
a116 1
      } else if (!streq( proc->args.decls->decl.type, "void")) {
d118 1
a118 1
	  f_print( fout, "\t" );
d120 4
a123 4
	  f_print( fout, " ");
	  pvname( proc->proc_name, vp->vers_num );
	  f_print(fout, "_%s;\n", l->decl.name );
/*	  pdeclaration(proc->args.argname, &l->decl, 1, ";\n" );*/
d129 1
a129 1
  f_print(fout, "\tclnt = clnt_create(host, %s, %s, \"%s\");\n", 
d138 1
a138 1
      f_print(fout, "\tresult_%d = ",++i);      
d141 2
a142 2
	f_print(fout, "(" );
	if( streq( proc->args.decls->decl.type, "void") )  /* cast to void* */
d144 2
a145 2
	f_print(fout, "&" );
	pvname(proc->proc_name, vp->vers_num );
d147 1
a147 1
      } else if (streq( proc->args.decls->decl.type, "void")) {
d153 1
a153 1
	  pvname( proc->proc_name, vp->vers_num );
d163 1
a163 1
  f_print(fout, "\tclnt_destroy( clnt );\n" );
d167 1
a167 1
static
d177 2
a178 2
/*			if( Cflag )
			  f_print( fout, "extern \"C\"{\n");
d183 1
a183 1
			printarglist( proc, RQSTP, "struct svc_req *" );
d187 2
a188 2
			if( !streq( proc->res_type, "void") )
			  return_type(proc);
d190 1
a190 1
			  f_print(fout, "char*" );  /* cannot have void type */
d192 4
a195 4
			f_print(fout, 
				"\n\t/*\n\t * insert server code here\n\t */\n\n");
			if( !streq( proc->res_type, "void") )
			  f_print(fout, "\treturn(&result);\n}\n");
d197 3
a199 3
			  f_print(fout, "\treturn((void*) &result);\n}\n"); 
/*			if( Cflag)
			  f_print( fout, "}\n");
d201 1
a201 2

		} 		
d205 1
a205 1
static 
d209 1
a209 1
	ptype( plist->res_prefix, plist->res_type, 1 );
d212 1
d225 9
a233 9
  list *l;
  definition *def;
  version_list *vp;

  f_print(fout, "\n\n" );
  if( Cflag )
    f_print(fout,"main( int argc, char* argv[] )\n{\n" );
  else
    f_print(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n" );
d235 5
a239 5
  f_print(fout, "\tchar *host;");
  f_print(fout, "\n\n\tif(argc < 2) {");
  f_print(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n" );
  f_print(fout, "\t\texit(1);\n\t}");
  f_print(fout, "\n\thost = argv[1];\n");
d241 1
a241 1
  for (l = defined; l != NULL; l = l->next) {
d243 1
a243 1
		if (def->def_kind != DEF_PROGRAM) {
a244 1
		}
d246 1
a246 1
		        f_print( fout, "\t" );
d248 1
a248 2
			f_print( fout, "( host );\n" );
		      }
d250 2
a251 1
  f_print(fout, "}\n");
@


1.8
log
@half finished KNF
@
text
@d51 3
a53 3
static void write_sample_client __P((char *, version_list *));
static void write_sample_server __P((definition *));
static void return_type __P((proc_list *));
d61 1
a61 1
		return;
d74 1
a74 1
		return(0);
d77 2
a78 2
		write_sample_client(def->def_name, vp);
		++count;
d80 1
a80 1
	return(count);
d84 3
a86 3
static void
write_sample_client(program_name, vp)
     char *program_name;
d93 4
a96 4
  f_print(fout, "\n\nvoid\n");
  pvname(program_name, vp->vers_num);
  if (Cflag)
    f_print(fout,"(char *host)\n{\n");
d98 1
a98 1
    f_print(fout, "(host)\nchar *host;\n{\n");
d107 3
a109 3
      if (proc->arg_num < 2 && !newstyle) {
	f_print(fout, "\t");
	if (!streq(proc->args.decls->decl.type, "void"))
d112 1
a112 1
	  f_print(fout, "char *");  /* cannot have "void" type */
d114 1
a114 1
	pvname(proc->proc_name, vp->vers_num);
d116 1
a116 1
      } else if (!streq(proc->args.decls->decl.type, "void")) {
d118 1
a118 1
	  f_print(fout, "\t");
d120 4
a123 4
	  f_print(fout, " ");
	  pvname(proc->proc_name, vp->vers_num);
	  f_print(fout, "_%s;\n", l->decl.name);
/*	  pdeclaration(proc->args.argname, &l->decl, 1, ";\n");*/
d141 2
a142 2
	f_print(fout, "(");
	if (streq(proc->args.decls->decl.type, "void"))  /* cast to void* */
d144 2
a145 2
	f_print(fout, "&");
	pvname(proc->proc_name, vp->vers_num);
d147 1
a147 1
      } else if (streq(proc->args.decls->decl.type, "void")) {
d153 1
a153 1
	  pvname(proc->proc_name, vp->vers_num);
d163 1
a163 1
  f_print(fout, "\tclnt_destroy(clnt);\n");
d167 1
a167 1
static void
d177 2
a178 2
/*			if (Cflag)
				f_print(fout, "extern \"C\"{\n");
d183 1
a183 1
			printarglist(proc, RQSTP, "struct svc_req *");
d187 2
a188 2
			if (!streq(proc->res_type, "void"))
				return_type(proc);
d190 1
a190 1
				f_print(fout, "char*");  /* cannot have void type */
d193 3
a195 3
			    "\n\t/*\n\t * insert server code here\n\t */\n\n");
			if (!streq(proc->res_type, "void"))
				f_print(fout, "\treturn(&result);\n}\n");
d197 3
a199 3
				f_print(fout, "\treturn((void*) &result);\n}\n"); 
/*			if (Cflag)
				f_print(fout, "}\n");
d201 2
a202 1
		}
d206 1
a206 1
static void
d210 1
a210 1
	ptype(plist->res_prefix, plist->res_type, 1);
a212 1
void
d225 9
a233 9
	list *l;
	definition *def;
	version_list *vp;

	f_print(fout, "\n\n");
	if (Cflag)
		f_print(fout,"main(int argc, char *argv[])\n{\n");
	else
		f_print(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n");
d235 5
a239 5
	f_print(fout, "\tchar *host;");
	f_print(fout, "\n\n\tif (argc < 2) {");
	f_print(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n");
	f_print(fout, "\t\texit(1);\n\t}");
	f_print(fout, "\n\thost = argv[1];\n");
d241 1
a241 1
	for (l = defined; l != NULL; l = l->next) {
d243 1
a243 1
		if (def->def_kind != DEF_PROGRAM)
d245 1
d247 1
a247 1
			f_print(fout, "\t");
d249 2
a250 1
			f_print(fout, "(host);\n");
d252 1
a252 2
	}
	f_print(fout, "}\n");
@


1.7
log
@Fix a couple of printf().
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.6 2001/11/07 18:44:28 deraadt Exp $	*/
d51 3
a53 3
static write_sample_client __P((char *, version_list *));
static write_sample_server __P((definition *));
static return_type __P((proc_list *));
d61 1
a61 1
	  return;
d74 1
a74 1
	  return( 0 );
d77 2
a78 2
	  write_sample_client(def->def_name, vp );
	  ++count;
d80 1
a80 1
	return( count );
d84 3
a86 3
static
write_sample_client(program_name, vp )
     char* program_name;
d93 4
a96 4
  f_print(fout, "\n\nvoid\n" );
  pvname( program_name, vp->vers_num );
  if( Cflag )
    f_print(fout,"( char* host )\n{\n" );
d98 1
a98 1
    f_print(fout, "(host)\nchar *host;\n{\n" );
d107 3
a109 3
      if( proc->arg_num < 2 && !newstyle) {
	f_print( fout, "\t" );
	if( !streq( proc->args.decls->decl.type, "void") )
d112 1
a112 1
	  f_print(fout, "char* ");  /* cannot have "void" type */
d114 1
a114 1
	pvname( proc->proc_name, vp->vers_num );
d116 1
a116 1
      } else if (!streq( proc->args.decls->decl.type, "void")) {
d118 1
a118 1
	  f_print( fout, "\t" );
d120 4
a123 4
	  f_print( fout, " ");
	  pvname( proc->proc_name, vp->vers_num );
	  f_print(fout, "_%s;\n", l->decl.name );
/*	  pdeclaration(proc->args.argname, &l->decl, 1, ";\n" );*/
d141 2
a142 2
	f_print(fout, "(" );
	if( streq( proc->args.decls->decl.type, "void") )  /* cast to void* */
d144 2
a145 2
	f_print(fout, "&" );
	pvname(proc->proc_name, vp->vers_num );
d147 1
a147 1
      } else if (streq( proc->args.decls->decl.type, "void")) {
d153 1
a153 1
	  pvname( proc->proc_name, vp->vers_num );
d163 1
a163 1
  f_print(fout, "\tclnt_destroy( clnt );\n" );
d167 1
a167 1
static
d177 2
a178 2
/*			if( Cflag )
			  f_print( fout, "extern \"C\"{\n");
d183 1
a183 1
			printarglist( proc, RQSTP, "struct svc_req *" );
d187 2
a188 2
			if( !streq( proc->res_type, "void") )
			  return_type(proc);
d190 1
a190 1
			  f_print(fout, "char*" );  /* cannot have void type */
d193 3
a195 3
				"\n\t/*\n\t * insert server code here\n\t */\n\n");
			if( !streq( proc->res_type, "void") )
			  f_print(fout, "\treturn(&result);\n}\n");
d197 3
a199 3
			  f_print(fout, "\treturn((void*) &result);\n}\n"); 
/*			if( Cflag)
			  f_print( fout, "}\n");
d201 1
a201 2

		} 		
d205 1
a205 1
static 
d209 1
a209 1
	ptype( plist->res_prefix, plist->res_type, 1 );
d212 1
d225 9
a233 9
  list *l;
  definition *def;
  version_list *vp;

  f_print(fout, "\n\n" );
  if( Cflag )
    f_print(fout,"main( int argc, char* argv[] )\n{\n" );
  else
    f_print(fout, "main(argc, argv)\nint argc;\nchar *argv[];\n{\n" );
d235 5
a239 5
  f_print(fout, "\tchar *host;");
  f_print(fout, "\n\n\tif(argc < 2) {");
  f_print(fout, "\n\t\tprintf(\"usage: %%s server_host\\n\", argv[0]);\n" );
  f_print(fout, "\t\texit(1);\n\t}");
  f_print(fout, "\n\thost = argv[1];\n");
d241 1
a241 1
  for (l = defined; l != NULL; l = l->next) {
d243 1
a243 1
		if (def->def_kind != DEF_PROGRAM) {
a244 1
		}
d246 1
a246 1
		        f_print( fout, "\t" );
d248 1
a248 2
			f_print( fout, "( host );\n" );
		      }
d250 2
a251 1
  f_print(fout, "}\n");
@


1.6
log
@rpcgen is not nearly KNF, but it now generates close to KNF code
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.5 2001/07/18 22:26:00 deraadt Exp $	*/
d191 1
a191 1
			f_print(fout, " result;\n", proc->res_type);
@


1.5
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.3 1997/11/15 22:10:53 deraadt Exp $	*/
d199 1
a199 1
			  f_print( fout, "};\n");
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@a44 1
#include "rpc_scan.h"
d51 3
a53 3
static void write_sample_client __P((char *, version_list *));
static void write_sample_server __P((definition *));
static void return_type __P((proc_list *));
d84 1
a84 1
static void
d167 1
a167 1
static void
d187 2
a188 2
			if(streq( proc->res_type, "void"))
			  f_print(fout, "char*");  /* cannot have void type */
d190 2
a191 2
			  return_type(proc);
			f_print(fout, " result;\n");
d206 1
a206 1
static void
a212 1
void
@


1.3
log
@make -Ss code correct; ghudson@@mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.2 1996/06/26 05:38:38 deraadt Exp $	*/
d45 1
d52 3
a54 3
static write_sample_client __P((char *, version_list *));
static write_sample_server __P((definition *));
static return_type __P((proc_list *));
d85 1
a85 1
static
d168 1
a168 1
static
d188 3
a190 1
			if( !streq( proc->res_type, "void") )
d192 1
a192 3
			else
			  f_print(fout, "char*" );  /* cannot have void type */
			f_print(fout, " result;\n", proc->res_type);
d207 1
a207 1
static 
d214 1
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_sample.c,v 1.2 1995/06/11 21:50:01 pk Exp $	*/
d182 1
a182 4
			if( Cflag )
			  pvname_svc(proc->proc_name, vp->vers_num);
			else
			  pvname(proc->proc_name, vp->vers_num);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
