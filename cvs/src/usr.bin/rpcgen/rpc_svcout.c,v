head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.18
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.20
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.16
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.12
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.14
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.6
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.10
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.8
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.10
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.8
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.6
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.10
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.8
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.6
	OPENBSD_3_6_BASE:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.03.15.12.13;	author weingart;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.20.21.44.42;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.16.23.09.40;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.09.03.35.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.06.21.26.00;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.11.23.31.51;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.01.15.53.36;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.12.06.07.16;	author mpech;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.09.01.28.06;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.24.17.59.22;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.07.18.44.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.19.24.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.40;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@/*	$OpenBSD: rpc_svcout.c,v 1.26 2010/09/01 14:43:34 millert Exp $	*/
/*	$NetBSD: rpc_svcout.c,v 1.7 1995/06/24 14:59:59 pk Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_svcout.c, Server-skeleton outputter for the RPC protocol compiler
 */
#include <stdio.h>
#include <string.h>
#include "rpc_parse.h"
#include "rpc_util.h"

static char RQSTP[] = "rqstp";
static char TRANSP[] = "transp";
static char ARG[] = "argument";
static char RESULT[] = "result";
static char ROUTINE[] = "local";

char _errbuf[256];	/* For all messages */

void internal_proctype(proc_list *);
static void write_real_program(definition *);
static void write_program(definition *, char *);
static void printerr(char *, char *);
static void printif(char *, char *, char *, char *);
static void write_inetmost(char *);
static void print_return(char *);
static void print_pmapunset(char *);
static void print_err_message(char *);
static void write_timeout_func(void);
static void write_pm_most(char *, int);
static void write_caller_func(void);
static void write_rpc_svc_fg(char *, char *);
static void write_msg_out(void);
static void open_log_file(char *, char *);

static void
p_xdrfunc(char *rname, char *typename)
{
	if (Cflag)
		fprintf(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n",
		    rname, stringfix(typename));
	else
		fprintf(fout, "\t\txdr_%s = xdr_%s;\n", rname,
		    stringfix(typename));
}

void
internal_proctype(plist)
	proc_list *plist;
{
	fprintf(fout, "static ");
	ptype(plist->res_prefix, plist->res_type, 1);
	fprintf(fout, "*");
}

/*
 * write most of the service, that is, everything but the registrations.
 */
void
write_most(infile, netflag, nomain)
	char *infile;		/* our name */
	int netflag;
	int nomain;
{
	if (inetdflag || pmflag) {
		char *var_type;
		var_type = (nomain? "extern" : "static");
		fprintf(fout, "%s int _rpcpmstart;", var_type);
		fprintf(fout, "\t\t/* Started by a port monitor ? */\n");
		fprintf(fout, "%s int _rpcfdtype;", var_type);
		fprintf(fout, "\t\t/* Whether Stream or Datagram ? */\n");
		if (timerflag) {
			fprintf(fout, "%s int _rpcsvcdirty;", var_type);
			fprintf(fout, "\t/* Still serving ? */\n");
		}
		write_svc_aux(nomain);
	}
	/* write out dispatcher and stubs */
	write_programs(nomain? (char *)NULL : "static");

	if (nomain)
		return;

	fprintf(fout, "\nmain()\n");
	fprintf(fout, "{\n");
	if (inetdflag) {
		write_inetmost(infile); /* Includes call to write_rpc_svc_fg() */
	} else {
		if (tirpcflag) {
			if (netflag) {
				fprintf(fout, "\tSVCXPRT *%s;\n", TRANSP);
				fprintf(fout, "\tstruct netconfig *nconf = NULL;\n");
			}
			fprintf(fout, "\tpid_t pid;\n");
			fprintf(fout, "\tint i;\n");
			fprintf(fout, "\tchar mname[FMNAMESZ + 1];\n\n");
			write_pm_most(infile, netflag);
			fprintf(fout, "\telse {\n");
			write_rpc_svc_fg(infile, "\t\t");
			fprintf(fout, "\t}\n");
		} else {
			fprintf(fout, "\tSVCXPRT *%s;\n", TRANSP);
			fprintf(fout, "\n");
			print_pmapunset("\t");
		}
	}

	if (logflag && !inetdflag) {
		open_log_file(infile, "\t");
	}
}

/*
 * write a registration for the given transport
 */
void
write_netid_register(transp)
	char *transp;
{
	list *l;
	definition *def;
	version_list *vp;
	char *sp;
	char tmpbuf[32];

	sp = "";
	fprintf(fout, "\n");
	fprintf(fout, "%s\tnconf = getnetconfigent(\"%s\");\n", sp, transp);
	fprintf(fout, "%s\tif (nconf == NULL) {\n", sp);
	(void) snprintf(_errbuf, sizeof _errbuf, "cannot find %s netid.", transp);
	snprintf(tmpbuf, sizeof tmpbuf, "%s\t\t", sp);
	print_err_message(tmpbuf);
	fprintf(fout, "%s\t\texit(1);\n", sp);
	fprintf(fout, "%s\t}\n", sp);
	fprintf(fout, "%s\t%s = svc_tli_create(RPC_ANYFD, nconf, 0, 0, 0);\n",
	    sp, TRANSP);
	fprintf(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
	(void) snprintf(_errbuf, sizeof _errbuf, "cannot create %s service.", transp);
	print_err_message(tmpbuf);
	fprintf(fout, "%s\t\texit(1);\n", sp);
	fprintf(fout, "%s\t}\n", sp);

	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind != DEF_PROGRAM)
			continue;
		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
			fprintf(fout,
			    "%s\t(void) rpcb_unset(%s, %s, nconf);\n",
			    sp, def->def_name, vp->vers_name);
			fprintf(fout,
			    "%s\tif (!svc_reg(%s, %s, %s, ",
			    sp, TRANSP, def->def_name, vp->vers_name);
			pvname(def->def_name, vp->vers_num);
			fprintf(fout, ", nconf)) {\n");
			(void) snprintf(_errbuf, sizeof _errbuf,
			    "unable to register (%s, %s, %s).",
			    def->def_name, vp->vers_name, transp);
			print_err_message(tmpbuf);
			fprintf(fout, "%s\t\texit(1);\n", sp);
			fprintf(fout, "%s\t}\n", sp);
		}
	}
	fprintf(fout, "%s\tfreenetconfigent(nconf);\n", sp);
}

/*
 * write a registration for the given transport for TLI
 */
void
write_nettype_register(transp)
	char *transp;
{
	list *l;
	definition *def;
	version_list *vp;

	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind != DEF_PROGRAM)
			continue;
		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
			fprintf(fout, "\tif (!svc_create(");
			pvname(def->def_name, vp->vers_num);
			fprintf(fout, ", %s, %s, \"%s\")) {\n",
			    def->def_name, vp->vers_name, transp);
			(void) snprintf(_errbuf, sizeof _errbuf,
			    "unable to create (%s, %s) for %s.",
			    def->def_name, vp->vers_name, transp);
			print_err_message("\t\t");
			fprintf(fout, "\t\texit(1);\n");
			fprintf(fout, "\t}\n");
		}
	}
}

/*
 * write the rest of the service
 */
void
write_rest()
{
	fprintf(fout, "\n");
	if (inetdflag) {
		fprintf(fout, "\tif (%s == (SVCXPRT *)NULL) {\n", TRANSP);
		(void) snprintf(_errbuf, sizeof _errbuf, "could not create a handle");
		print_err_message("\t\t");
		fprintf(fout, "\t\texit(1);\n");
		fprintf(fout, "\t}\n");
		if (timerflag) {
			fprintf(fout, "\tif (_rpcpmstart) {\n");
			fprintf(fout,
			    "\t\t(void) signal(SIGALRM, %s closedown);\n",
			    Cflag? "(SIG_PF)" : "(void(*)())");
			fprintf(fout, "\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
			fprintf(fout, "\t}\n");
		}
	}
	fprintf(fout, "\tsvc_run();\n");
	(void) snprintf(_errbuf, sizeof _errbuf, "svc_run returned");
	print_err_message("\t");
	fprintf(fout, "\texit(1);\n");
	fprintf(fout, "\t/* NOTREACHED */\n");
	fprintf(fout, "}\n");
}

void
write_programs(storage)
	char *storage;
{
	definition *def;
	list *l;

	/* write out stubs for procedure  definitions */
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind == DEF_PROGRAM)
			write_real_program(def);
	}

	/* write out dispatcher for each program */
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind == DEF_PROGRAM)
			write_program(def, storage);
	}
}

/* write out definition of internal function (e.g. _printmsg_1(...))
   which calls server's definition of actual function (e.g. printmsg_1(...)).
   Unpacks single user argument of printmsg_1 to call-by-value format
   expected by printmsg_1. */
static void
write_real_program(def)
	definition *def;
{
	version_list *vp;
	proc_list *proc;
	decl_list *l;

	if (!newstyle) return;  /* not needed for old style */
	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
		for (proc = vp->procs; proc != NULL; proc = proc->next) {
			fprintf(fout, "\n");
			internal_proctype(proc);
			fprintf(fout, "\n_");
			pvname(proc->proc_name, vp->vers_num);
			if (Cflag) {
				fprintf(fout, "(");
				/* arg name */
				if (proc->arg_num > 1)
					fprintf(fout, "%s", proc->args.argname);
				else
					ptype(proc->args.decls->decl.prefix,
					    proc->args.decls->decl.type, 0);
				fprintf(fout, " *argp, struct svc_req *%s)\n",
				    RQSTP);
			} else {
				fprintf(fout, "(argp, %s)\n", RQSTP);
				/* arg name */
				if (proc->arg_num > 1)
					fprintf(fout, "\t%s *argp;\n",
					    proc->args.argname);
				else {
					fprintf(fout, "\t");
					ptype(proc->args.decls->decl.prefix,
					    proc->args.decls->decl.type, 0);
					fprintf(fout, " *argp;\n");
				}
				fprintf(fout, "	struct svc_req *%s;\n", RQSTP);
			}

			fprintf(fout, "{\n");
			fprintf(fout, "\treturn(");
			pvname_svc(proc->proc_name, vp->vers_num);
			fprintf(fout, "(");
			if (proc->arg_num < 2) { /* single argument */
				if (!streq(proc->args.decls->decl.type, "void"))
					fprintf(fout, "*argp, ");  /* non-void */
			} else {
				for (l = proc->args.decls;  l != NULL; l = l->next)
					fprintf(fout, "argp->%s, ", l->decl.name);
			}
			fprintf(fout, "%s));\n}\n", RQSTP);
		}
	}
}

static void
write_program(def, storage)
	definition *def;
	char *storage;
{
	version_list *vp;
	proc_list *proc;
	int filled;

	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
		fprintf(fout, "\n");
		if (storage != NULL)
			fprintf(fout, "%s ", storage);
		fprintf(fout, "void\t");
		pvname(def->def_name, vp->vers_num);

		if (Cflag) {
			fprintf(fout, "(struct svc_req *%s, ", RQSTP);
			fprintf(fout, "SVCXPRT *%s);\n", TRANSP);
		} else {
			fprintf(fout, "();\n");
		}
		fprintf(fout, "\n");

		if (storage != NULL)
			fprintf(fout, "%s ", storage);
		fprintf(fout, "void\n");
		pvname(def->def_name, vp->vers_num);

		if (Cflag) {
			fprintf(fout, "(struct svc_req *%s, ", RQSTP);
			fprintf(fout, "SVCXPRT *%s)\n", TRANSP);
		} else {
			fprintf(fout, "(%s, %s)\n", RQSTP, TRANSP);
			fprintf(fout, "    struct svc_req *%s;\n", RQSTP);
			fprintf(fout, "    SVCXPRT *%s;\n", TRANSP);
		}
		fprintf(fout, "{\n");

		filled = 0;
		fprintf(fout, "\tunion {\n");
		for (proc = vp->procs; proc != NULL; proc = proc->next) {
			if (proc->arg_num < 2) { /* single argument */
				if (streq(proc->args.decls->decl.type,
				    "void"))
					continue;
				filled = 1;
				fprintf(fout, "\t\t");
				ptype(proc->args.decls->decl.prefix,
				    proc->args.decls->decl.type, 0);
				pvname(proc->proc_name, vp->vers_num);
				fprintf(fout, "_arg;\n");

			} else {
				filled = 1;
				fprintf(fout, "\t\t%s", proc->args.argname);
				fprintf(fout, " ");
				pvname(proc->proc_name, vp->vers_num);
				fprintf(fout, "_arg;\n");
			}
		}
		if (!filled)
			fprintf(fout, "\t\tint fill;\n");
		fprintf(fout, "\t} %s;\n", ARG);
		fprintf(fout, "\tchar *%s;\n", RESULT);

		if (Cflag) {
			fprintf(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
			fprintf(fout,
			    "\tchar *(*%s)(char *, struct svc_req *);\n",
			    ROUTINE);
		} else {
			fprintf(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n",
			    ARG, RESULT);
			fprintf(fout, "\tchar *(*%s)();\n", ROUTINE);
		}
		fprintf(fout, "\n");

		if (callerflag)
			fprintf(fout, "\tcaller = transp;\n"); /*EVAS*/
		if (timerflag)
			fprintf(fout, "\t_rpcsvcdirty = 1;\n");
		fprintf(fout, "\tswitch (%s->rq_proc) {\n", RQSTP);
		if (!nullproc(vp->procs)) {
			fprintf(fout, "\tcase NULLPROC:\n");
			fprintf(fout,
			    Cflag
			    ? "\t\t(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);\n"
			    : "\t\t(void) svc_sendreply(%s, xdr_void, (char *)NULL);\n",
			    TRANSP);
			print_return("\t\t");
			fprintf(fout, "\n");
		}
		for (proc = vp->procs; proc != NULL; proc = proc->next) {
			fprintf(fout, "\tcase %s:\n", proc->proc_name);
			if (proc->arg_num < 2) { /* single argument */
				p_xdrfunc(ARG, proc->args.decls->decl.type);
			} else {
				p_xdrfunc(ARG, proc->args.argname);
			}
			p_xdrfunc(RESULT, proc->res_type);
			if (Cflag)
				fprintf(fout,
				    "\t\t%s = (char *(*)(char *, struct svc_req *)) ",
				    ROUTINE);
			else
				fprintf(fout, "\t\t%s = (char *(*)()) ", ROUTINE);

			if (newstyle) { /* new style: calls internal routine */
				fprintf(fout,"_");
			}
			if (!newstyle)
				pvname_svc(proc->proc_name, vp->vers_num);
			else
				pvname(proc->proc_name, vp->vers_num);
			fprintf(fout, ";\n");
			fprintf(fout, "\t\tbreak;\n\n");
		}
		fprintf(fout, "\tdefault:\n");
		printerr("noproc", TRANSP);
		print_return("\t\t");
		fprintf(fout, "\t}\n");

		fprintf(fout, "\t(void) memset((char *)&%s, 0, sizeof (%s));\n", ARG, ARG);
		printif ("getargs", TRANSP, "(caddr_t) &", ARG);
		printerr("decode", TRANSP);
		print_return("\t\t");
		fprintf(fout, "\t}\n");

		if (Cflag)
			fprintf(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
			    RESULT, ROUTINE, ARG, RQSTP);
		else
			fprintf(fout, "\t%s = (*%s)(&%s, %s);\n",
			    RESULT, ROUTINE, ARG, RQSTP);
		fprintf(fout,
		    "\tif (%s != NULL && !svc_sendreply(%s, xdr_%s, %s)) {\n",
		    RESULT, TRANSP, RESULT, RESULT);
		printerr("systemerr", TRANSP);
		fprintf(fout, "\t}\n");

		printif ("freeargs", TRANSP, "(caddr_t) &", ARG);
		(void) snprintf(_errbuf, sizeof _errbuf, "unable to free arguments");
		print_err_message("\t\t");
		fprintf(fout, "\t\texit(1);\n");
		fprintf(fout, "\t}\n");
		print_return("\t");
		fprintf(fout, "}\n");
	}
}

static void
printerr(err, transp)
	char *err;
	char *transp;
{
	fprintf(fout, "\t\tsvcerr_%s(%s);\n", err, transp);
}

static void
printif(proc, transp, prefix, arg)
	char *proc;
	char *transp;
	char *prefix;
	char *arg;
{
	fprintf(fout, "\tif (!svc_%s(%s, xdr_%s, %s%s)) {\n",
	    proc, transp, arg, prefix, arg);
}

int
nullproc(proc)
	proc_list *proc;
{
	for (; proc != NULL; proc = proc->next) {
		if (streq(proc->proc_num, "0"))
			return (1);
	}
	return (0);
}

static void
write_inetmost(infile)
	char *infile;
{
	fprintf(fout, "\tSVCXPRT *%s;\n", TRANSP);
	fprintf(fout, "\tint sock;\n");
	fprintf(fout, "\tint proto;\n");
	fprintf(fout, "\tstruct sockaddr_in saddr;\n");
	fprintf(fout, "\tint asize = sizeof (saddr);\n");
	fprintf(fout, "\n");
	fprintf(fout,
	"\tif (getsockname(0, (struct sockaddr *)&saddr, &asize) == 0) {\n");
	fprintf(fout, "\t\tint ssize = sizeof (int);\n\n");
	fprintf(fout, "\t\tif (saddr.sin_family != AF_INET)\n");
	fprintf(fout, "\t\t\texit(1);\n");
	fprintf(fout, "\t\tif (getsockopt(0, SOL_SOCKET, SO_TYPE,\n");
	fprintf(fout, "\t\t    (char *)&_rpcfdtype, &ssize) == -1)\n");
	fprintf(fout, "\t\t\texit(1);\n");
	fprintf(fout, "\t\tsock = 0;\n");
	fprintf(fout, "\t\t_rpcpmstart = 1;\n");
	fprintf(fout, "\t\tproto = 0;\n");
	open_log_file(infile, "\t\t");
	fprintf(fout, "\t} else {\n");
	write_rpc_svc_fg(infile, "\t\t");
	fprintf(fout, "\t\tsock = RPC_ANYSOCK;\n");
	print_pmapunset("\t\t");
	fprintf(fout, "\t}\n");
}

static void
print_return(space)
	char *space;
{
	if (exitnow)
		fprintf(fout, "%sexit(0);\n", space);
	else {
		if (timerflag)
			fprintf(fout, "%s_rpcsvcdirty = 0;\n", space);
		fprintf(fout, "%sreturn;\n", space);
	}
}

static void
print_pmapunset(space)
	char *space;
{
	version_list *vp;
	definition *def;
	list *l;

	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind == DEF_PROGRAM) {
			for (vp = def->def.pr.versions; vp != NULL;
			    vp = vp->next) {
				fprintf(fout, "%s(void) pmap_unset(%s, %s);\n",
				    space, def->def_name, vp->vers_name);
			}
		}
	}
}

static void
print_err_message(space)
	char *space;
{
	if (logflag)
		fprintf(fout, "%ssyslog(LOG_ERR, \"%%s\", \"%s\");\n", space, _errbuf);
	else if (inetdflag || pmflag)
		fprintf(fout, "%s_msgout(\"%s\");\n", space, _errbuf);
	else
		fprintf(fout, "%sfprintf(stderr, \"%s\");\n", space, _errbuf);
}

/*
 * Write the server auxiliary function (_msgout, timeout)
 */
void
write_svc_aux(nomain)
	int nomain;
{
	if (!logflag)
		write_msg_out();
	if (!nomain)
		write_timeout_func();
	if (callerflag)			/*EVAS*/
		write_caller_func();	/*EVAS*/
}

/*
 * Write the _msgout function
 */

void
write_msg_out()
{
	fprintf(fout, "\n");
	fprintf(fout, "static\n");
	if (!Cflag) {
		fprintf(fout, "void _msgout(msg)\n");
		fprintf(fout, "\tchar *msg;\n");
	} else {
		fprintf(fout, "void _msgout(char *msg)\n");
	}
	fprintf(fout, "{\n");
	fprintf(fout, "#ifdef RPC_SVC_FG\n");
	if (inetdflag || pmflag)
		fprintf(fout, "\tif (_rpcpmstart)\n");
	fprintf(fout, "\t\tsyslog(LOG_ERR, \"%%s\", msg);\n");
	fprintf(fout, "\telse {\n");
	fprintf(fout, "\t\t(void) write(STDERR_FILENO, msg, strlen(msg));\n");
	fprintf(fout, "\t\t(void) write(STDERR_FILENO, \"\\n\", 1);\n");
	fprintf(fout, "\t}\n#else\n");
	fprintf(fout, "\tsyslog(LOG_ERR, \"%%s\", msg);\n");
	fprintf(fout, "#endif\n");
	fprintf(fout, "}\n");
}

/*
 * Write the timeout function
 */
static void
write_timeout_func()
{
	if (!timerflag)
		return;
	fprintf(fout, "\n");
	fprintf(fout, "static void\n");
	fprintf(fout, "closedown()\n");
	fprintf(fout, "{\n");
	fprintf(fout, "\tint save_errno = errno;\n\n");
	fprintf(fout, "\tif (_rpcsvcdirty == 0) {\n");
	fprintf(fout, "\t\textern fd_set *__svc_fdset;\n");
	fprintf(fout, "\t\textern int __svc_fdsetsize;\n");
	fprintf(fout, "\t\tint i, openfd;\n");
	if (tirpcflag && pmflag) {
		fprintf(fout, "\t\tstruct t_info tinfo;\n\n");
		fprintf(fout, "\t\tif (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))\n");
	} else {
		fprintf(fout, "\n\t\tif (_rpcfdtype == SOCK_DGRAM)\n");
	}
	fprintf(fout, "\t\t\t_exit(0);\n");
	fprintf(fout, "\t\tfor (i = 0, openfd = 0; i < __svc_fdsetsize && openfd < 2; i++)\n");
	fprintf(fout, "\t\t\tif (FD_ISSET(i, __svc_fdset))\n");
	fprintf(fout, "\t\t\t\topenfd++;\n");
	fprintf(fout, "\t\tif (openfd <= (_rpcpmstart?0:1))\n");
	fprintf(fout, "\t\t\t_exit(0);\n");
	fprintf(fout, "\t}\n");
	fprintf(fout, "\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
	fprintf(fout, "\terrno = save_errno;\n");
	fprintf(fout, "}\n");
}

static void
write_caller_func()			/*EVAS*/
{
#define	P(s)	fprintf(fout, s);

P("\n");
P("char *svc_caller()\n");
P("{\n");
P("	struct sockaddr_in actual;\n");
P("	struct hostent *hp;\n");
P("	static struct in_addr prev;\n");
P("	static char cname[256];\n\n");

P("	actual = *svc_getcaller(caller);\n\n");

P("	if (memcmp((char *)&actual.sin_addr, (char *)&prev,\n");
P("		 sizeof(struct in_addr)) == 0)\n");
P("		return (cname);\n\n");

P("	prev = actual.sin_addr;\n\n");

P("	hp = gethostbyaddr((char *) &actual.sin_addr, sizeof(actual.sin_addr), AF_INET);\n");
P("	if (hp == NULL) {                       /* dummy one up */\n");
P("		extern char *inet_ntoa();\n");
P("		strlcpy(cname, inet_ntoa(actual.sin_addr), sizeof cname);\n");
P("	} else {\n");
P("		strlcpy(cname, hp->h_name, sizeof cname);\n");
P("	}\n\n");

P("	return (cname);\n");
P("}\n");

#undef P
}

/*
 * Write the most of port monitor support
 */
static void
write_pm_most(infile, netflag)
	char *infile;
	int netflag;
{
	list *l;
	definition *def;
	version_list *vp;

	fprintf(fout, "\tif (!ioctl(0, I_LOOK, mname) &&\n");
	fprintf(fout, "\t\t(!strcmp(mname, \"sockmod\") ||");
	fprintf(fout, " !strcmp(mname, \"timod\"))) {\n");
	fprintf(fout, "\t\tchar *netid;\n");
	if (!netflag) {	/* Not included by -n option */
		fprintf(fout, "\t\tstruct netconfig *nconf = NULL;\n");
		fprintf(fout, "\t\tSVCXPRT *%s;\n", TRANSP);
	}
	if (timerflag)
		fprintf(fout, "\t\tint pmclose;\n");
/* not necessary, defined in /usr/include/stdlib */
/*	fprintf(fout, "\t\textern char *getenv();\n");*/
	fprintf(fout, "\n");
	fprintf(fout, "\t\t_rpcpmstart = 1;\n");
	if (logflag)
		open_log_file(infile, "\t\t");
	fprintf(fout, "\t\tif ((netid = getenv(\"NLSPROVIDER\")) == NULL) {\n");
	snprintf(_errbuf, sizeof _errbuf, "cannot get transport name");
	print_err_message("\t\t\t");
	fprintf(fout, "\t\t} else if ((nconf = getnetconfigent(netid)) == NULL) {\n");
	snprintf(_errbuf, sizeof _errbuf, "cannot get transport info");
	print_err_message("\t\t\t");
	fprintf(fout, "\t\t}\n");
	/*
	 * A kludgy support for inetd services. Inetd only works with
	 * sockmod, and RPC works only with timod, hence all this jugglery
	 */
	fprintf(fout, "\t\tif (strcmp(mname, \"sockmod\") == 0) {\n");
	fprintf(fout, "\t\t\tif (ioctl(0, I_POP, 0) || ioctl(0, I_PUSH, \"timod\")) {\n");
	snprintf(_errbuf, sizeof _errbuf, "could not get the right module");
	print_err_message("\t\t\t\t");
	fprintf(fout, "\t\t\t\texit(1);\n");
	fprintf(fout, "\t\t\t}\n");
	fprintf(fout, "\t\t}\n");
	if (timerflag)
		fprintf(fout, "\t\tpmclose = (t_getstate(0) != T_DATAXFER);\n");
	fprintf(fout, "\t\tif ((%s = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {\n",
			TRANSP);
	snprintf(_errbuf, sizeof _errbuf, "cannot create server handle");
	print_err_message("\t\t\t");
	fprintf(fout, "\t\t\texit(1);\n");
	fprintf(fout, "\t\t}\n");
	fprintf(fout, "\t\tif (nconf)\n");
	fprintf(fout, "\t\t\tfreenetconfigent(nconf);\n");
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind != DEF_PROGRAM) {
			continue;
		}
		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
			fprintf(fout,
				"\t\tif (!svc_reg(%s, %s, %s, ",
				TRANSP, def->def_name, vp->vers_name);
			pvname(def->def_name, vp->vers_num);
			fprintf(fout, ", 0)) {\n");
			(void) snprintf(_errbuf, sizeof _errbuf, "unable to register (%s, %s).",
					def->def_name, vp->vers_name);
			print_err_message("\t\t\t");
			fprintf(fout, "\t\t\texit(1);\n");
			fprintf(fout, "\t\t}\n");
		}
	}
	if (timerflag) {
		fprintf(fout, "\t\tif (pmclose) {\n");
		fprintf(fout, "\t\t\t(void) signal(SIGALRM, %s closedown);\n",
				Cflag? "(SIG_PF)" : "(void(*)())");
		fprintf(fout, "\t\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
		fprintf(fout, "\t\t}\n");
	}
	fprintf(fout, "\t\tsvc_run();\n");
	fprintf(fout, "\t\texit(1);\n");
	fprintf(fout, "\t\t/* NOTREACHED */\n");
	fprintf(fout, "\t}\n");
}

/*
 * Support for backgrounding the server if self started.
 */
static void
write_rpc_svc_fg(infile, sp)
	char *infile;
	char *sp;
{
	fprintf(fout, "#ifndef RPC_SVC_FG\n");
	fprintf(fout, "%sint size;\n", sp);
	if (tirpcflag)
		fprintf(fout, "%sstruct rlimit rl;\n", sp);
	if (inetdflag) {
		fprintf(fout, "%sint i;\n\n", sp);
		fprintf(fout, "%spid_t pid;\n\n", sp);
	}
	fprintf(fout, "%spid = fork();\n", sp);
	fprintf(fout, "%sif (pid < 0) {\n", sp);
	fprintf(fout, "%s\tperror(\"cannot fork\");\n", sp);
	fprintf(fout, "%s\texit(1);\n", sp);
	fprintf(fout, "%s}\n", sp);
	fprintf(fout, "%sif (pid)\n", sp);
	fprintf(fout, "%s\texit(0);\n", sp);
	/* get number of file descriptors */
	if (tirpcflag) {
		fprintf(fout, "%srl.rlim_max = 0;\n", sp);
		fprintf(fout, "%sgetrlimit(RLIMIT_NOFILE, &rl);\n", sp);
		fprintf(fout, "%sif ((size = rl.rlim_max) == 0)\n", sp);
		fprintf(fout, "%s\texit(1);\n", sp);
	} else {
		fprintf(fout, "%ssize = getdtablesize();\n", sp);
	}

	fprintf(fout, "%sfor (i = 0; i < size; i++)\n", sp);
	fprintf(fout, "%s\t(void) close(i);\n", sp);
	/* Redirect stderr and stdout to console */
	fprintf(fout, "%si = open(\"/dev/console\", 2);\n", sp);
	fprintf(fout, "%s(void) dup2(i, 1);\n", sp);
	fprintf(fout, "%s(void) dup2(i, 2);\n", sp);
	/* This removes control of the controlling terminal */
	if (tirpcflag)
		fprintf(fout, "%ssetsid();\n", sp);
	else {
		fprintf(fout, "%si = open(\"/dev/tty\", 2);\n", sp);
		fprintf(fout, "%sif (i >= 0) {\n", sp);
		fprintf(fout, "%s\t(void) ioctl(i, TIOCNOTTY, (char *)NULL);\n", sp);
		fprintf(fout, "%s\t(void) close(i);\n", sp);
		fprintf(fout, "%s}\n", sp);
	}
	if (!logflag)
		open_log_file(infile, sp);
	fprintf(fout, "#endif\n");
	if (logflag)
		open_log_file(infile, sp);
}

static void
open_log_file(infile, sp)
	char *infile;
	char *sp;
{
	char *s;

	s = strrchr(infile, '.');
	if (s)
		*s = '\0';
	fprintf(fout,"%sopenlog(\"%s\", LOG_PID, LOG_DAEMON);\n", sp, infile);
	if (s)
		*s = '.';
}

/*
 * write a registration for the given transport for Inetd
 */
void
write_inetd_register(transp)
	char *transp;
{
	list *l;
	definition *def;
	version_list *vp;
	char *sp;
	int isudp;
	char tmpbuf[32];

	if (inetdflag)
		sp = "\t";
	else
		sp = "";
	if (streq(transp, "udp"))
		isudp = 1;
	else
		isudp = 0;
	fprintf(fout, "\n");
	if (inetdflag) {
		fprintf(fout, "\tif (_rpcfdtype == 0 || _rpcfdtype == %s) {\n",
				isudp ? "SOCK_DGRAM" : "SOCK_STREAM");
	}
	if (inetdflag && streq(transp, "tcp")) {
		fprintf(fout, "%s\tif (_rpcpmstart)\n", sp);

		fprintf(fout, "%s\t\t%s = svc%s_create(%s",
			sp, TRANSP, "fd", inetdflag? "sock": "RPC_ANYSOCK");
		if (!isudp)
			fprintf(fout, ", 0, 0");
		fprintf(fout, ");\n");

		fprintf(fout, "%s\telse\n", sp);

		fprintf(fout, "%s\t\t%s = svc%s_create(%s",
			sp, TRANSP, transp, inetdflag? "sock": "RPC_ANYSOCK");
		if (!isudp)
			fprintf(fout, ", 0, 0");
		fprintf(fout, ");\n");

	} else {
		fprintf(fout, "%s\t%s = svc%s_create(%s",
			sp, TRANSP, transp, inetdflag? "sock": "RPC_ANYSOCK");
		if (!isudp)
			fprintf(fout, ", 0, 0");
		fprintf(fout, ");\n");
	}
	fprintf(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
	(void) snprintf(_errbuf, sizeof _errbuf, "cannot create %s service.", transp);
	(void) snprintf(tmpbuf, sizeof tmpbuf, "%s\t\t", sp);
	print_err_message(tmpbuf);
	fprintf(fout, "%s\t\texit(1);\n", sp);
	fprintf(fout, "%s\t}\n", sp);

	if (inetdflag) {
		fprintf(fout, "%s\tif (!_rpcpmstart)\n\t", sp);
		fprintf(fout, "%s\tproto = IPPROTO_%s;\n",
				sp, isudp ? "UDP": "TCP");
	}
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind != DEF_PROGRAM) {
			continue;
		}
		for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
			fprintf(fout, "%s\tif (!svc_register(%s, %s, %s, ",
				sp, TRANSP, def->def_name, vp->vers_name);
			pvname(def->def_name, vp->vers_num);
			if (inetdflag)
				fprintf(fout, ", proto)) {\n");
			else
				fprintf(fout, ", IPPROTO_%s)) {\n",
					isudp ? "UDP": "TCP");
			(void) snprintf(_errbuf, sizeof _errbuf, "unable to register (%s, %s, %s).",
					def->def_name, vp->vers_name, transp);
			print_err_message(tmpbuf);
			fprintf(fout, "%s\t\texit(1);\n", sp);
			fprintf(fout, "%s\t}\n", sp);
		}
	}
	if (inetdflag)
		fprintf(fout, "\t}\n");
}
@


1.26
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.25 2009/10/27 23:59:42 deraadt Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.25
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.24 2007/10/03 15:12:13 weingart Exp $	*/
d3 1
d5 1
a5 7
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
d7 3
a9 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d11 9
a19 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d21 12
a32 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.24
log
@nullproc() is used in more than one file.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.23 2007/10/03 14:35:48 weingart Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_svcout.c 1.29 89/03/30 (C) 1987 SMI";
#endif
@


1.23
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.22 2005/10/20 21:44:42 jmc Exp $	*/
a68 1
int nullproc(proc_list *proc);
@


1.22
log
@defintion -> definition;
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.21 2003/08/16 23:09:40 deraadt Exp $	*/
d34 1
a34 1
 static char sccsid[] = "@@(#)rpc_svcout.c 1.29 89/03/30 (C) 1987 SMI";
@


1.21
log
@missing comma in non-ansi mode; spotted by pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.20 2003/08/06 21:08:07 millert Exp $	*/
d285 1
a285 1
   which calls server's defintion of actual function (e.g. printmsg_1(...)).
@


1.20
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.19 2003/07/09 03:35:21 deraadt Exp $	*/
d364 1
a364 1
			fprintf(fout, "()\n");
@


1.19
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.18 2003/07/06 21:26:00 deraadt Exp $	*/
d845 1
a845 1
		fprintf(fout, "%s\t(void) ioctl(i, TIOCNOTTY, (char *)NULL);\n", sp);;
@


1.18
log
@generate protos for functions
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.17 2003/06/11 23:31:51 deraadt Exp $	*/
d67 1
a67 1
static void write_msg_out();
d72 1
a72 3
p_xdrfunc(rname, typename)
char *rname;
char *typename;
@


1.17
log
@de-register
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.16 2003/06/01 15:53:36 deraadt Exp $	*/
d357 13
@


1.16
log
@various format string cleanups; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.15 2002/07/05 05:39:42 deraadt Exp $	*/
d364 1
a364 1
			fprintf(fout, "register SVCXPRT *%s)\n", TRANSP);
d367 2
a368 2
			fprintf(fout, "	struct svc_req *%s;\n", RQSTP);
			fprintf(fout, "	register SVCXPRT *%s;\n", TRANSP);
d518 1
a518 1
	fprintf(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
@


1.15
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.14 2002/06/12 06:07:16 mpech Exp $	*/
d309 1
a309 1
					fprintf(fout, proc->args.argname);
@


1.14
log
@a real pid_t cleanup.

espie@@ ok for make/,
deraadt@@ one extra eye,
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.13 2002/06/09 01:28:06 deraadt Exp $	*/
d55 15
a69 13
static write_real_program(definition *);
static write_program(definition *, char *);
static printerr(char *, char *);
static printif(char *, char *, char *, char *);
static write_inetmost(char *);
static print_return(char *);
static print_pmapunset(char *);
static print_err_message(char *);
static write_timeout_func(void);
static write_pm_most(char *, int);
static write_caller_func(void);
static write_rpc_svc_fg(char *, char *);
static open_log_file(char *, char *);
d71 1
a71 1
static
d103 1
a103 1
	        char *var_type;
d118 1
a118 1
        if (nomain)
d126 13
a138 2
	  if (tirpcflag) {
		if (netflag) {
d140 2
a141 1
			fprintf(fout, "\tstruct netconfig *nconf = NULL;\n");
a142 12
		fprintf(fout, "\tpid_t pid;\n");
		fprintf(fout, "\tint i;\n");
		fprintf(fout, "\tchar mname[FMNAMESZ + 1];\n\n");
		write_pm_most(infile, netflag);
		fprintf(fout, "\telse {\n");
		write_rpc_svc_fg(infile, "\t\t");
		fprintf(fout, "\t}\n");
	      } else {
		fprintf(fout, "\tSVCXPRT *%s;\n", TRANSP);
		fprintf(fout, "\n");
		print_pmapunset("\t");
	      }
d290 1
a290 1
static
d306 9
a314 9
			  fprintf(fout, "(");
			  /* arg name */
			  if (proc->arg_num > 1)
			    fprintf(fout, proc->args.argname);
			  else
			    ptype(proc->args.decls->decl.prefix,
				  proc->args.decls->decl.type, 0);
			  fprintf(fout, " *argp, struct svc_req *%s)\n",
				  RQSTP);
d316 12
a327 11
			  fprintf(fout, "(argp, %s)\n", RQSTP);
			  /* arg name */
			  if (proc->arg_num > 1)
			    fprintf(fout, "\t%s *argp;\n", proc->args.argname);
			  else {
			    fprintf(fout, "\t");
			    ptype(proc->args.decls->decl.prefix,
				  proc->args.decls->decl.type, 0);
			    fprintf(fout, " *argp;\n");
			  }
			  fprintf(fout, "	struct svc_req *%s;\n", RQSTP);
d335 2
a336 2
			  if (!streq(proc->args.decls->decl.type, "void"))
			    fprintf(fout, "*argp, ");  /* non-void */
d338 2
a339 2
			  for (l = proc->args.decls;  l != NULL; l = l->next)
			    fprintf(fout, "argp->%s, ", l->decl.name);
d346 1
a346 1
static
d484 1
a484 1
static
d492 2
a493 2
static
printif (proc, transp, prefix, arg)
d503 1
d514 1
a514 1
static
d543 1
a543 1
static
d556 1
a556 1
static
d576 1
a576 1
static
d593 1
a593 1
     int nomain;
d607 1
d635 1
a635 1
static
d667 1
a667 1
static
d705 1
a705 1
static
d723 1
a723 1
	  fprintf(fout, "\t\tint pmclose;\n");
d749 1
a749 1
	  fprintf(fout, "\t\tpmclose = (t_getstate(0) != T_DATAXFER);\n");
d792 1
a792 1
static
d800 1
a800 1
	        fprintf(fout, "%sstruct rlimit rl;\n", sp);
d814 4
a817 4
	  fprintf(fout, "%srl.rlim_max = 0;\n", sp);
	  fprintf(fout, "%sgetrlimit(RLIMIT_NOFILE, &rl);\n", sp);
	  fprintf(fout, "%sif ((size = rl.rlim_max) == 0)\n", sp);
	  fprintf(fout, "%s\texit(1);\n", sp);
d819 1
a819 1
	  fprintf(fout, "%ssize = getdtablesize();\n", sp);
d830 1
a830 1
	  fprintf(fout, "%ssetsid();\n", sp);
d832 5
a836 5
	  fprintf(fout, "%si = open(\"/dev/tty\", 2);\n", sp);
	  fprintf(fout, "%sif (i >= 0) {\n", sp);
	  fprintf(fout, "%s\t(void) ioctl(i, TIOCNOTTY, (char *)NULL);\n", sp);;
	  fprintf(fout, "%s\t(void) close(i);\n", sp);
	  fprintf(fout, "%s}\n", sp);
d845 1
a845 1
static
@


1.13
log
@i think the TLI rpcgen side generates a format string bug on output... but
we do not use that stuff.  attempt to fix it, but unable to test
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.12 2002/06/01 01:40:38 deraadt Exp $	*/
d796 4
a799 2
	if (inetdflag)
		fprintf(fout, "%sint pid, i;\n\n", sp);
@


1.12
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.11 2002/02/16 21:27:51 millert Exp $	*/
d577 1
a577 1
		fprintf(fout, "%ssyslog(LOG_ERR, \"%s\");\n", space, _errbuf);
d617 1
a617 1
	fprintf(fout, "\t\tsyslog(LOG_ERR, msg);\n");
d622 1
a622 1
	fprintf(fout, "\tsyslog(LOG_ERR, msg);\n");
@


1.11
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.10 2001/12/05 09:50:31 deraadt Exp $	*/
d75 1
a75 1
		f_print(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n",
d78 1
a78 1
		f_print(fout, "\t\txdr_%s = xdr_%s;\n", rname,
d86 1
a86 1
	f_print(fout, "static ");
d88 1
a88 1
	f_print(fout, "*");
d103 4
a106 4
		f_print(fout, "%s int _rpcpmstart;", var_type);
		f_print(fout, "\t\t/* Started by a port monitor ? */\n");
		f_print(fout, "%s int _rpcfdtype;", var_type);
		f_print(fout, "\t\t/* Whether Stream or Datagram ? */\n");
d108 2
a109 2
			f_print(fout, "%s int _rpcsvcdirty;", var_type);
			f_print(fout, "\t/* Still serving ? */\n");
d119 2
a120 2
	f_print(fout, "\nmain()\n");
	f_print(fout, "{\n");
d126 2
a127 2
			f_print(fout, "\tSVCXPRT *%s;\n", TRANSP);
			f_print(fout, "\tstruct netconfig *nconf = NULL;\n");
d129 3
a131 3
		f_print(fout, "\tpid_t pid;\n");
		f_print(fout, "\tint i;\n");
		f_print(fout, "\tchar mname[FMNAMESZ + 1];\n\n");
d133 1
a133 1
		f_print(fout, "\telse {\n");
d135 1
a135 1
		f_print(fout, "\t}\n");
d137 2
a138 2
		f_print(fout, "\tSVCXPRT *%s;\n", TRANSP);
		f_print(fout, "\n");
d162 4
a165 4
	f_print(fout, "\n");
	f_print(fout, "%s\tnconf = getnetconfigent(\"%s\");\n", sp, transp);
	f_print(fout, "%s\tif (nconf == NULL) {\n", sp);
	(void) sprintf(_errbuf, "cannot find %s netid.", transp);
d168 3
a170 3
	f_print(fout, "%s\t\texit(1);\n", sp);
	f_print(fout, "%s\t}\n", sp);
	f_print(fout, "%s\t%s = svc_tli_create(RPC_ANYFD, nconf, 0, 0, 0);\n",
d172 2
a173 2
	f_print(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
	(void) sprintf(_errbuf, "cannot create %s service.", transp);
d175 2
a176 2
	f_print(fout, "%s\t\texit(1);\n", sp);
	f_print(fout, "%s\t}\n", sp);
d183 1
a183 1
			f_print(fout,
d186 1
a186 1
			f_print(fout,
d190 3
a192 2
			f_print(fout, ", nconf)) {\n");
			(void) sprintf(_errbuf, "unable to register (%s, %s, %s).",
d195 2
a196 2
			f_print(fout, "%s\t\texit(1);\n", sp);
			f_print(fout, "%s\t}\n", sp);
d199 1
a199 1
	f_print(fout, "%s\tfreenetconfigent(nconf);\n", sp);
d218 1
a218 1
			f_print(fout, "\tif (!svc_create(");
d220 1
a220 1
			f_print(fout, ", %s, %s, \"%s\")) {\n",
d222 1
a222 1
			(void) sprintf(_errbuf,
d226 2
a227 2
			f_print(fout, "\t\texit(1);\n");
			f_print(fout, "\t}\n");
d238 1
a238 1
	f_print(fout, "\n");
d240 2
a241 2
		f_print(fout, "\tif (%s == (SVCXPRT *)NULL) {\n", TRANSP);
		(void) sprintf(_errbuf, "could not create a handle");
d243 2
a244 2
		f_print(fout, "\t\texit(1);\n");
		f_print(fout, "\t}\n");
d246 2
a247 2
			f_print(fout, "\tif (_rpcpmstart) {\n");
			f_print(fout,
d250 2
a251 2
			f_print(fout, "\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
			f_print(fout, "\t}\n");
d254 2
a255 2
	f_print(fout, "\tsvc_run();\n");
	(void) sprintf(_errbuf, "svc_run returned");
d257 3
a259 3
	f_print(fout, "\texit(1);\n");
	f_print(fout, "\t/* NOTREACHED */\n");
	f_print(fout, "}\n");
d299 1
a299 1
			f_print(fout, "\n");
d301 1
a301 1
			f_print(fout, "\n_");
d304 1
a304 1
			  f_print(fout, "(");
d307 1
a307 1
			    f_print(fout, proc->args.argname);
d311 1
a311 1
			  f_print(fout, " *argp, struct svc_req *%s)\n",
d314 1
a314 1
			  f_print(fout, "(argp, %s)\n", RQSTP);
d317 1
a317 1
			    f_print(fout, "\t%s *argp;\n", proc->args.argname);
d319 1
a319 1
			    f_print(fout, "\t");
d322 1
a322 1
			    f_print(fout, " *argp;\n");
d324 1
a324 1
			  f_print(fout, "	struct svc_req *%s;\n", RQSTP);
d327 2
a328 2
			f_print(fout, "{\n");
			f_print(fout, "\treturn(");
d330 1
a330 1
			f_print(fout, "(");
d333 1
a333 1
			    f_print(fout, "*argp, ");  /* non-void */
d336 1
a336 1
			    f_print(fout, "argp->%s, ", l->decl.name);
d338 1
a338 1
			f_print(fout, "%s));\n}\n", RQSTP);
d353 1
a353 1
		f_print(fout, "\n");
d355 2
a356 2
			f_print(fout, "%s ", storage);
		f_print(fout, "void\n");
d360 2
a361 2
			f_print(fout, "(struct svc_req *%s, ", RQSTP);
			f_print(fout, "register SVCXPRT *%s)\n", TRANSP);
d363 3
a365 3
			f_print(fout, "(%s, %s)\n", RQSTP, TRANSP);
			f_print(fout, "	struct svc_req *%s;\n", RQSTP);
			f_print(fout, "	register SVCXPRT *%s;\n", TRANSP);
d367 1
a367 1
		f_print(fout, "{\n");
d370 1
a370 1
		f_print(fout, "\tunion {\n");
d377 1
a377 1
				f_print(fout, "\t\t");
d381 1
a381 1
				f_print(fout, "_arg;\n");
d385 2
a386 2
				f_print(fout, "\t\t%s", proc->args.argname);
				f_print(fout, " ");
d388 1
a388 1
				f_print(fout, "_arg;\n");
d392 3
a394 3
			f_print(fout, "\t\tint fill;\n");
		f_print(fout, "\t} %s;\n", ARG);
		f_print(fout, "\tchar *%s;\n", RESULT);
d397 2
a398 2
			f_print(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
			f_print(fout,
d402 1
a402 1
			f_print(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n",
d404 1
a404 1
			f_print(fout, "\tchar *(*%s)();\n", ROUTINE);
d406 1
a406 1
		f_print(fout, "\n");
d409 1
a409 1
			f_print(fout, "\tcaller = transp;\n"); /*EVAS*/
d411 2
a412 2
			f_print(fout, "\t_rpcsvcdirty = 1;\n");
		f_print(fout, "\tswitch (%s->rq_proc) {\n", RQSTP);
d414 2
a415 2
			f_print(fout, "\tcase NULLPROC:\n");
			f_print(fout,
d421 1
a421 1
			f_print(fout, "\n");
d424 1
a424 1
			f_print(fout, "\tcase %s:\n", proc->proc_name);
d432 1
a432 1
				f_print(fout,
d436 1
a436 1
				f_print(fout, "\t\t%s = (char *(*)()) ", ROUTINE);
d439 1
a439 1
				f_print(fout,"_");
d445 2
a446 2
			f_print(fout, ";\n");
			f_print(fout, "\t\tbreak;\n\n");
d448 1
a448 1
		f_print(fout, "\tdefault:\n");
d451 1
a451 1
		f_print(fout, "\t}\n");
d453 1
a453 1
		f_print(fout, "\t(void) memset((char *)&%s, 0, sizeof (%s));\n", ARG, ARG);
d457 1
a457 1
		f_print(fout, "\t}\n");
d460 1
a460 1
			f_print(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
d463 1
a463 1
			f_print(fout, "\t%s = (*%s)(&%s, %s);\n",
d465 1
a465 1
		f_print(fout,
d469 1
a469 1
		f_print(fout, "\t}\n");
d472 1
a472 1
		(void) sprintf(_errbuf, "unable to free arguments");
d474 2
a475 2
		f_print(fout, "\t\texit(1);\n");
		f_print(fout, "\t}\n");
d477 1
a477 1
		f_print(fout, "}\n");
d486 1
a486 1
	f_print(fout, "\t\tsvcerr_%s(%s);\n", err, transp);
d496 1
a496 1
	f_print(fout, "\tif (!svc_%s(%s, xdr_%s, %s%s)) {\n",
d514 7
a520 7
	f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
	f_print(fout, "\tint sock;\n");
	f_print(fout, "\tint proto;\n");
	f_print(fout, "\tstruct sockaddr_in saddr;\n");
	f_print(fout, "\tint asize = sizeof (saddr);\n");
	f_print(fout, "\n");
	f_print(fout,
d522 9
a530 9
	f_print(fout, "\t\tint ssize = sizeof (int);\n\n");
	f_print(fout, "\t\tif (saddr.sin_family != AF_INET)\n");
	f_print(fout, "\t\t\texit(1);\n");
	f_print(fout, "\t\tif (getsockopt(0, SOL_SOCKET, SO_TYPE,\n");
	f_print(fout, "\t\t    (char *)&_rpcfdtype, &ssize) == -1)\n");
	f_print(fout, "\t\t\texit(1);\n");
	f_print(fout, "\t\tsock = 0;\n");
	f_print(fout, "\t\t_rpcpmstart = 1;\n");
	f_print(fout, "\t\tproto = 0;\n");
d532 1
a532 1
	f_print(fout, "\t} else {\n");
d534 1
a534 1
	f_print(fout, "\t\tsock = RPC_ANYSOCK;\n");
d536 1
a536 1
	f_print(fout, "\t}\n");
d544 1
a544 1
		f_print(fout, "%sexit(0);\n", space);
d547 2
a548 2
			f_print(fout, "%s_rpcsvcdirty = 0;\n", space);
		f_print(fout, "%sreturn;\n", space);
d565 1
a565 1
				f_print(fout, "%s(void) pmap_unset(%s, %s);\n",
d577 1
a577 1
		f_print(fout, "%ssyslog(LOG_ERR, \"%s\");\n", space, _errbuf);
d579 1
a579 1
		f_print(fout, "%s_msgout(\"%s\");\n", space, _errbuf);
d581 1
a581 1
		f_print(fout, "%sfprintf(stderr, \"%s\");\n", space, _errbuf);
d605 2
a606 2
	f_print(fout, "\n");
	f_print(fout, "static\n");
d608 2
a609 2
		f_print(fout, "void _msgout(msg)\n");
		f_print(fout, "\tchar *msg;\n");
d611 1
a611 1
		f_print(fout, "void _msgout(char *msg)\n");
d613 2
a614 2
	f_print(fout, "{\n");
	f_print(fout, "#ifdef RPC_SVC_FG\n");
d616 9
a624 9
		f_print(fout, "\tif (_rpcpmstart)\n");
	f_print(fout, "\t\tsyslog(LOG_ERR, msg);\n");
	f_print(fout, "\telse {\n");
	f_print(fout, "\t\t(void) write(STDERR_FILENO, msg, strlen(msg));\n");
	f_print(fout, "\t\t(void) write(STDERR_FILENO, \"\\n\", 1);\n");
	f_print(fout, "\t}\n#else\n");
	f_print(fout, "\tsyslog(LOG_ERR, msg);\n");
	f_print(fout, "#endif\n");
	f_print(fout, "}\n");
d635 9
a643 9
	f_print(fout, "\n");
	f_print(fout, "static void\n");
	f_print(fout, "closedown()\n");
	f_print(fout, "{\n");
	f_print(fout, "\tint save_errno = errno;\n\n");
	f_print(fout, "\tif (_rpcsvcdirty == 0) {\n");
	f_print(fout, "\t\textern fd_set *__svc_fdset;\n");
	f_print(fout, "\t\textern int __svc_fdsetsize;\n");
	f_print(fout, "\t\tint i, openfd;\n");
d645 2
a646 2
		f_print(fout, "\t\tstruct t_info tinfo;\n\n");
		f_print(fout, "\t\tif (!t_getinfo(0, &tinfo) && (tinfo.servtype == T_CLTS))\n");
d648 1
a648 1
		f_print(fout, "\n\t\tif (_rpcfdtype == SOCK_DGRAM)\n");
d650 10
a659 10
	f_print(fout, "\t\t\t_exit(0);\n");
	f_print(fout, "\t\tfor (i = 0, openfd = 0; i < __svc_fdsetsize && openfd < 2; i++)\n");
	f_print(fout, "\t\t\tif (FD_ISSET(i, __svc_fdset))\n");
	f_print(fout, "\t\t\t\topenfd++;\n");
	f_print(fout, "\t\tif (openfd <= (_rpcpmstart?0:1))\n");
	f_print(fout, "\t\t\t_exit(0);\n");
	f_print(fout, "\t}\n");
	f_print(fout, "\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
	f_print(fout, "\terrno = save_errno;\n");
	f_print(fout, "}\n");
d665 1
a665 1
#define	P(s)	f_print(fout, s);
d673 1
a673 1
P("	static char cname[128];\n\n");
d686 1
a686 1
P("		strcpy(cname, inet_ntoa(actual.sin_addr));\n");
d688 1
a688 1
P("		strcpy(cname, hp->h_name);\n");
d709 4
a712 4
	f_print(fout, "\tif (!ioctl(0, I_LOOK, mname) &&\n");
	f_print(fout, "\t\t(!strcmp(mname, \"sockmod\") ||");
	f_print(fout, " !strcmp(mname, \"timod\"))) {\n");
	f_print(fout, "\t\tchar *netid;\n");
d714 2
a715 2
		f_print(fout, "\t\tstruct netconfig *nconf = NULL;\n");
		f_print(fout, "\t\tSVCXPRT *%s;\n", TRANSP);
d718 1
a718 1
	  f_print(fout, "\t\tint pmclose;\n");
d720 3
a722 3
/*	f_print(fout, "\t\textern char *getenv();\n");*/
	f_print(fout, "\n");
	f_print(fout, "\t\t_rpcpmstart = 1;\n");
d725 2
a726 2
	f_print(fout, "\t\tif ((netid = getenv(\"NLSPROVIDER\")) == NULL) {\n");
	sprintf(_errbuf, "cannot get transport name");
d728 2
a729 2
	f_print(fout, "\t\t} else if ((nconf = getnetconfigent(netid)) == NULL) {\n");
	sprintf(_errbuf, "cannot get transport info");
d731 1
a731 1
	f_print(fout, "\t\t}\n");
d736 3
a738 3
	f_print(fout, "\t\tif (strcmp(mname, \"sockmod\") == 0) {\n");
	f_print(fout, "\t\t\tif (ioctl(0, I_POP, 0) || ioctl(0, I_PUSH, \"timod\")) {\n");
	sprintf(_errbuf, "could not get the right module");
d740 3
a742 3
	f_print(fout, "\t\t\t\texit(1);\n");
	f_print(fout, "\t\t\t}\n");
	f_print(fout, "\t\t}\n");
d744 2
a745 2
	  f_print(fout, "\t\tpmclose = (t_getstate(0) != T_DATAXFER);\n");
	f_print(fout, "\t\tif ((%s = svc_tli_create(0, nconf, NULL, 0, 0)) == NULL) {\n",
d747 1
a747 1
	sprintf(_errbuf, "cannot create server handle");
d749 4
a752 4
	f_print(fout, "\t\t\texit(1);\n");
	f_print(fout, "\t\t}\n");
	f_print(fout, "\t\tif (nconf)\n");
	f_print(fout, "\t\t\tfreenetconfigent(nconf);\n");
d759 1
a759 1
			f_print(fout,
d763 2
a764 2
			f_print(fout, ", 0)) {\n");
			(void) sprintf(_errbuf, "unable to register (%s, %s).",
d767 2
a768 2
			f_print(fout, "\t\t\texit(1);\n");
			f_print(fout, "\t\t}\n");
d772 2
a773 2
		f_print(fout, "\t\tif (pmclose) {\n");
		f_print(fout, "\t\t\t(void) signal(SIGALRM, %s closedown);\n",
d775 2
a776 2
		f_print(fout, "\t\t\t(void) alarm(_RPCSVC_CLOSEDOWN);\n");
		f_print(fout, "\t\t}\n");
d778 4
a781 4
	f_print(fout, "\t\tsvc_run();\n");
	f_print(fout, "\t\texit(1);\n");
	f_print(fout, "\t\t/* NOTREACHED */\n");
	f_print(fout, "\t}\n");
d792 2
a793 2
	f_print(fout, "#ifndef RPC_SVC_FG\n");
	f_print(fout, "%sint size;\n", sp);
d795 1
a795 1
	        f_print(fout, "%sstruct rlimit rl;\n", sp);
d797 8
a804 8
		f_print(fout, "%sint pid, i;\n\n", sp);
	f_print(fout, "%spid = fork();\n", sp);
	f_print(fout, "%sif (pid < 0) {\n", sp);
	f_print(fout, "%s\tperror(\"cannot fork\");\n", sp);
	f_print(fout, "%s\texit(1);\n", sp);
	f_print(fout, "%s}\n", sp);
	f_print(fout, "%sif (pid)\n", sp);
	f_print(fout, "%s\texit(0);\n", sp);
d807 4
a810 4
	  f_print(fout, "%srl.rlim_max = 0;\n", sp);
	  f_print(fout, "%sgetrlimit(RLIMIT_NOFILE, &rl);\n", sp);
	  f_print(fout, "%sif ((size = rl.rlim_max) == 0)\n", sp);
	  f_print(fout, "%s\texit(1);\n", sp);
d812 1
a812 1
	  f_print(fout, "%ssize = getdtablesize();\n", sp);
d815 2
a816 2
	f_print(fout, "%sfor (i = 0; i < size; i++)\n", sp);
	f_print(fout, "%s\t(void) close(i);\n", sp);
d818 3
a820 3
	f_print(fout, "%si = open(\"/dev/console\", 2);\n", sp);
	f_print(fout, "%s(void) dup2(i, 1);\n", sp);
	f_print(fout, "%s(void) dup2(i, 2);\n", sp);
d823 1
a823 1
	  f_print(fout, "%ssetsid();\n", sp);
d825 5
a829 5
	  f_print(fout, "%si = open(\"/dev/tty\", 2);\n", sp);
	  f_print(fout, "%sif (i >= 0) {\n", sp);
	  f_print(fout, "%s\t(void) ioctl(i, TIOCNOTTY, (char *)NULL);\n", sp);;
	  f_print(fout, "%s\t(void) close(i);\n", sp);
	  f_print(fout, "%s}\n", sp);
d833 1
a833 1
	f_print(fout, "#endif\n");
d848 1
a848 1
	f_print(fout,"%sopenlog(\"%s\", LOG_PID, LOG_DAEMON);\n", sp, infile);
d875 1
a875 1
	f_print(fout, "\n");
d877 1
a877 1
		f_print(fout, "\tif (_rpcfdtype == 0 || _rpcfdtype == %s) {\n",
d881 1
a881 1
		f_print(fout, "%s\tif (_rpcpmstart)\n", sp);
d883 1
a883 1
		f_print(fout, "%s\t\t%s = svc%s_create(%s",
d886 2
a887 2
			f_print(fout, ", 0, 0");
		f_print(fout, ");\n");
d889 1
a889 1
		f_print(fout, "%s\telse\n", sp);
d891 1
a891 1
		f_print(fout, "%s\t\t%s = svc%s_create(%s",
d894 2
a895 2
			f_print(fout, ", 0, 0");
		f_print(fout, ");\n");
d898 1
a898 1
		f_print(fout, "%s\t%s = svc%s_create(%s",
d901 2
a902 2
			f_print(fout, ", 0, 0");
		f_print(fout, ");\n");
d904 3
a906 3
	f_print(fout, "%s\tif (%s == NULL) {\n", sp, TRANSP);
	(void) sprintf(_errbuf, "cannot create %s service.", transp);
	(void) sprintf(tmpbuf, "%s\t\t", sp);
d908 2
a909 2
	f_print(fout, "%s\t\texit(1);\n", sp);
	f_print(fout, "%s\t}\n", sp);
d912 2
a913 2
		f_print(fout, "%s\tif (!_rpcpmstart)\n\t", sp);
		f_print(fout, "%s\tproto = IPPROTO_%s;\n",
d922 1
a922 1
			f_print(fout, "%s\tif (!svc_register(%s, %s, %s, ",
d926 1
a926 1
				f_print(fout, ", proto)) {\n");
d928 1
a928 1
				f_print(fout, ", IPPROTO_%s)) {\n",
d930 1
a930 1
			(void) sprintf(_errbuf, "unable to register (%s, %s, %s).",
d933 2
a934 2
			f_print(fout, "%s\t\texit(1);\n", sp);
			f_print(fout, "%s\t}\n", sp);
d938 1
a938 1
		f_print(fout, "\t}\n");
@


1.10
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.8 2001/11/24 19:17:47 deraadt Exp $	*/
d54 14
a67 14
void internal_proctype __P((proc_list *));
static write_real_program __P((definition *));
static write_program __P((definition *, char *));
static printerr __P((char *, char *));
static printif __P((char *, char *, char *, char *));
static write_inetmost __P((char *));
static print_return __P((char *));
static print_pmapunset __P((char *));
static print_err_message __P((char *));
static write_timeout_func __P((void));
static write_pm_most __P((char *, int));
static write_caller_func __P((void));
static write_rpc_svc_fg __P((char *, char *));
static open_log_file __P((char *, char *));
@


1.9
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.7 2001/11/24 17:59:22 miod Exp $	*/
d70 11
a80 10
p_xdrfunc( rname, typename )
char* rname;
char* typename;
{
  if( Cflag )
    f_print(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n", rname, 
	    stringfix(typename) );
  else
    f_print(fout, "\t\txdr_%s = xdr_%s;\n", rname, stringfix(typename) );
}    
d87 2
a88 2
	ptype( plist->res_prefix, plist->res_type, 1 );
	f_print( fout, "*" );
a90 1

d92 1
a92 1
 * write most of the service, that is, everything but the registrations. 
d98 1
a98 1
        int nomain;
d101 1
a101 1
	        char* var_type;
d103 3
a105 3
		f_print(fout, "%s int _rpcpmstart;", var_type );
		f_print(fout, "\t\t/* Started by a port monitor ? */\n"); 
		f_print(fout, "%s int _rpcfdtype;", var_type );
d108 1
a108 1
			f_print(fout, "%s int _rpcsvcdirty;", var_type );
d111 1
a111 1
		write_svc_aux( nomain );
d114 1
a114 1
	write_programs( nomain? (char *)NULL : "static" );
d116 2
a117 2
        if( nomain ) 
	  return;
d124 1
a124 1
	  if( tirpcflag ) {
d149 1
a149 1
 * write a registration for the given transport 
d166 1
a166 1
	sprintf(tmpbuf, "%s\t\t", sp);
d171 1
a171 1
			sp, TRANSP);
d180 1
a180 1
		if (def->def_kind != DEF_PROGRAM) {
a181 1
		}
d184 2
a185 2
				"%s\t(void) rpcb_unset(%s, %s, nconf);\n",
				sp, def->def_name, vp->vers_name);
d187 2
a188 2
				"%s\tif (!svc_reg(%s, %s, %s, ",
				sp, TRANSP, def->def_name, vp->vers_name);
d192 1
a192 1
					def->def_name, vp->vers_name, transp);
d214 1
a214 1
		if (def->def_kind != DEF_PROGRAM) {
a215 1
		}
d220 1
a220 1
				def->def_name, vp->vers_name, transp);
d222 2
a223 2
				"unable to create (%s, %s) for %s.",
					def->def_name, vp->vers_name, transp);
d232 1
a232 1
 * write the rest of the service 
d246 3
a248 3
			f_print(fout, 
				"\t\t(void) signal(SIGALRM, %s closedown);\n",
				Cflag? "(SIG_PF)" : "(void(*)())" );
d265 1
a266 1
	definition *def;
d271 1
a271 1
		if (def->def_kind == DEF_PROGRAM) {
a272 1
		}
d278 1
a278 1
		if (def->def_kind == DEF_PROGRAM) {
a279 1
		}
a280 2


d295 1
a295 1
	if( !newstyle ) return;  /* not needed for old style */
d302 2
a303 2
			if( Cflag ) {
			  f_print(fout, "(" );
d308 1
a308 1
			    ptype(proc->args.decls->decl.prefix, 
d310 1
a310 1
			  f_print(fout, " *argp, struct svc_req *%s)\n", 
d313 1
a313 1
			  f_print(fout, "(argp, %s)\n", RQSTP );
d319 1
a319 1
			    ptype(proc->args.decls->decl.prefix, 
d331 1
a331 1
			  if (!streq( proc->args.decls->decl.type, "void"))
d334 1
a334 1
			  for (l = proc->args.decls;  l != NULL; l = l->next) 
d338 1
a338 1
		} 		
d342 1
a342 1
static 
d353 1
a353 1
		if (storage != NULL) {
a354 1
		}
d359 2
a360 2
		   f_print(fout, "(struct svc_req *%s, ", RQSTP);
		   f_print(fout, "register SVCXPRT *%s)\n", TRANSP);
d362 3
a364 3
		   f_print(fout, "(%s, %s)\n", RQSTP, TRANSP);
		   f_print(fout, "	struct svc_req *%s;\n", RQSTP);
		   f_print(fout, "	register SVCXPRT *%s;\n", TRANSP);
a365 1

d372 2
a373 2
				if (streq(proc->args.decls->decl.type, 
					  "void")) {
a374 1
				}
d377 2
a378 2
				ptype(proc->args.decls->decl.prefix, 
				      proc->args.decls->decl.type, 0);
d382 1
a382 2
			}
			else {
d390 1
a390 1
		if (!filled) {
a391 1
		}
d396 2
a397 2
		    f_print(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
		    f_print(fout,
d401 3
a403 2
		    f_print(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n", ARG, RESULT);
		    f_print(fout, "\tchar *(*%s)();\n", ROUTINE);
a404 1

d407 1
a407 1
		if (callerflag) 
d415 4
a418 4
			Cflag
			? "\t\t(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);\n"
			: "\t\t(void) svc_sendreply(%s, xdr_void, (char *)NULL);\n",
					TRANSP);
d425 1
a425 1
			  p_xdrfunc( ARG, proc->args.decls->decl.type);
d427 1
a427 1
			  p_xdrfunc( ARG, proc->args.argname);
d429 3
a431 3
			p_xdrfunc( RESULT, proc->res_type);
			if( Cflag )
			    f_print(fout,
d435 1
a435 1
			    f_print(fout, "\t\t%s = (char *(*)()) ", ROUTINE);
d440 2
a441 2
			if (!newstyle )
			  pvname_svc(proc->proc_name, vp->vers_num);
d443 1
a443 1
			  pvname(proc->proc_name, vp->vers_num);
d453 1
a453 1
		printif("getargs", TRANSP, "(caddr_t) &", ARG);
d459 1
a459 1
		    f_print(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
d462 1
a462 1
		    f_print(fout, "\t%s = (*%s)(&%s, %s);\n",
d464 3
a466 3
		f_print(fout, 
			"\tif (%s != NULL && !svc_sendreply(%s, xdr_%s, %s)) {\n",
			RESULT, TRANSP, RESULT, RESULT);
d470 1
a470 1
		printif("freeargs", TRANSP, "(caddr_t) &", ARG);
d489 1
a489 1
printif(proc, transp, prefix, arg)
d496 1
a496 1
		proc, transp, arg, prefix, arg);
d503 1
a503 1
		if (streq(proc->proc_num, "0")) {
a504 1
		}
d519 1
a519 1
	f_print(fout, 
d555 2
a557 2
	definition *def;
	version_list *vp;
d563 1
a563 1
					vp = vp->next) {
d565 1
a565 1
					space, def->def_name, vp->vers_name);
d584 1
a584 1
 * Write the server auxiliary function ( _msgout, timeout)
d587 1
a587 1
write_svc_aux( nomain )
d592 2
a593 2
	if( !nomain )
	  write_timeout_func();
d606 3
a608 3
	if( !Cflag ) {
	  f_print(fout, "void _msgout(msg)\n");
	  f_print(fout, "\tchar *msg;\n");
d610 1
a610 1
	  f_print(fout, "void _msgout(char* msg)\n");
d716 1
a716 1
	if( timerflag )
d742 1
a742 1
	if( timerflag )
d773 1
a773 1
				Cflag? "(SIG_PF)" : "(void(*)())" );
d793 1
a793 1
	if( tirpcflag )
d805 1
a805 1
	if( tirpcflag ) {
d821 1
a821 1
	if( tirpcflag )
d845 1
a845 1
	if (s) 
a851 3



d926 1
a926 1
			else 
@


1.8
log
@half finished KNF
@
text
@d70 10
a79 11
p_xdrfunc(rname, typename)
char *rname;
char *typename;
{
	if (Cflag)
		f_print(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n",
		    rname, stringfix(typename));
	else
		f_print(fout, "\t\txdr_%s = xdr_%s;\n", rname,
		    stringfix(typename));
}
d86 2
a87 2
	ptype(plist->res_prefix, plist->res_type, 1);
	f_print(fout, "*");
d90 1
d92 1
a92 1
 * write most of the service, that is, everything but the registrations.
d98 1
a98 1
	int nomain;
d101 1
a101 1
	        char *var_type;
d103 3
a105 3
		f_print(fout, "%s int _rpcpmstart;", var_type);
		f_print(fout, "\t\t/* Started by a port monitor ? */\n");
		f_print(fout, "%s int _rpcfdtype;", var_type);
d108 1
a108 1
			f_print(fout, "%s int _rpcsvcdirty;", var_type);
d111 1
a111 1
		write_svc_aux(nomain);
d114 1
a114 1
	write_programs(nomain? (char *)NULL : "static");
d116 2
a117 2
        if (nomain)
		return;
d124 1
a124 1
	  if (tirpcflag) {
d149 1
a149 1
 * write a registration for the given transport
d166 1
a166 1
	snprintf(tmpbuf, sizeof tmpbuf, "%s\t\t", sp);
d171 1
a171 1
	    sp, TRANSP);
d180 1
a180 1
		if (def->def_kind != DEF_PROGRAM)
d182 1
d185 2
a186 2
			    "%s\t(void) rpcb_unset(%s, %s, nconf);\n",
			    sp, def->def_name, vp->vers_name);
d188 2
a189 2
			    "%s\tif (!svc_reg(%s, %s, %s, ",
			    sp, TRANSP, def->def_name, vp->vers_name);
d193 1
a193 1
			    def->def_name, vp->vers_name, transp);
d215 1
a215 1
		if (def->def_kind != DEF_PROGRAM)
d217 1
d222 1
a222 1
			    def->def_name, vp->vers_name, transp);
d224 2
a225 2
			    "unable to create (%s, %s) for %s.",
			    def->def_name, vp->vers_name, transp);
d234 1
a234 1
 * write the rest of the service
d248 3
a250 3
			f_print(fout,
			    "\t\t(void) signal(SIGALRM, %s closedown);\n",
			    Cflag? "(SIG_PF)" : "(void(*)())");
d267 1
a268 1
	list *l;
d273 1
a273 1
		if (def->def_kind == DEF_PROGRAM)
d275 1
d281 1
a281 1
		if (def->def_kind == DEF_PROGRAM)
d283 1
d285 2
d301 1
a301 1
	if (!newstyle) return;  /* not needed for old style */
d308 2
a309 2
			if (Cflag) {
			  f_print(fout, "(");
d314 1
a314 1
			    ptype(proc->args.decls->decl.prefix,
d316 1
a316 1
			  f_print(fout, " *argp, struct svc_req *%s)\n",
d319 1
a319 1
			  f_print(fout, "(argp, %s)\n", RQSTP);
d325 1
a325 1
			    ptype(proc->args.decls->decl.prefix,
d337 1
a337 1
			  if (!streq(proc->args.decls->decl.type, "void"))
d340 1
a340 1
			  for (l = proc->args.decls;  l != NULL; l = l->next)
d344 1
a344 1
		}
d348 1
a348 1
static
d359 1
a359 1
		if (storage != NULL)
d361 1
d366 2
a367 2
			f_print(fout, "(struct svc_req *%s, ", RQSTP);
			f_print(fout, "register SVCXPRT *%s)\n", TRANSP);
d369 3
a371 3
			f_print(fout, "(%s, %s)\n", RQSTP, TRANSP);
			f_print(fout, "	struct svc_req *%s;\n", RQSTP);
			f_print(fout, "	register SVCXPRT *%s;\n", TRANSP);
d373 1
d380 2
a381 2
				if (streq(proc->args.decls->decl.type,
				    "void"))
d383 1
d386 2
a387 2
				ptype(proc->args.decls->decl.prefix,
				    proc->args.decls->decl.type, 0);
d391 2
a392 1
			} else {
d400 1
a400 1
		if (!filled)
d402 1
d407 2
a408 2
			f_print(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
			f_print(fout,
d412 2
a413 3
			f_print(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n",
			    ARG, RESULT);
			f_print(fout, "\tchar *(*%s)();\n", ROUTINE);
d415 1
d418 1
a418 1
		if (callerflag)
d426 4
a429 4
			    Cflag
			    ? "\t\t(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);\n"
			    : "\t\t(void) svc_sendreply(%s, xdr_void, (char *)NULL);\n",
			    TRANSP);
d436 1
a436 1
				p_xdrfunc(ARG, proc->args.decls->decl.type);
d438 1
a438 1
				p_xdrfunc(ARG, proc->args.argname);
d440 3
a442 3
			p_xdrfunc(RESULT, proc->res_type);
			if (Cflag)
				f_print(fout,
d446 1
a446 1
				f_print(fout, "\t\t%s = (char *(*)()) ", ROUTINE);
d451 2
a452 2
			if (!newstyle)
				pvname_svc(proc->proc_name, vp->vers_num);
d454 1
a454 1
				pvname(proc->proc_name, vp->vers_num);
d464 1
a464 1
		printif ("getargs", TRANSP, "(caddr_t) &", ARG);
d470 1
a470 1
			f_print(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
d473 1
a473 1
			f_print(fout, "\t%s = (*%s)(&%s, %s);\n",
d475 3
a477 3
		f_print(fout,
		    "\tif (%s != NULL && !svc_sendreply(%s, xdr_%s, %s)) {\n",
		    RESULT, TRANSP, RESULT, RESULT);
d481 1
a481 1
		printif ("freeargs", TRANSP, "(caddr_t) &", ARG);
d500 1
a500 1
printif (proc, transp, prefix, arg)
d507 1
a507 1
	    proc, transp, arg, prefix, arg);
d514 1
a514 1
		if (streq(proc->proc_num, "0"))
d516 1
d531 1
a531 1
	f_print(fout,
d567 2
a569 2
	definition *def;
	list *l;
d575 1
a575 1
			    vp = vp->next) {
d577 1
a577 1
				    space, def->def_name, vp->vers_name);
d596 1
a596 1
 * Write the server auxiliary function (_msgout, timeout)
d599 1
a599 1
write_svc_aux(nomain)
d604 2
a605 2
	if (!nomain)
		write_timeout_func();
d618 3
a620 3
	if (!Cflag) {
		f_print(fout, "void _msgout(msg)\n");
		f_print(fout, "\tchar *msg;\n");
d622 1
a622 1
		f_print(fout, "void _msgout(char *msg)\n");
d728 1
a728 1
	if (timerflag)
d754 1
a754 1
	if (timerflag)
d785 1
a785 1
				Cflag? "(SIG_PF)" : "(void(*)())");
d805 1
a805 1
	if (tirpcflag)
d817 1
a817 1
	if (tirpcflag) {
d833 1
a833 1
	if (tirpcflag)
d857 1
a857 1
	if (s)
d864 3
d941 1
a941 1
			else
@


1.7
log
@Fix a couple of printf().
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.6 2001/11/07 18:44:28 deraadt Exp $	*/
d70 11
a80 10
p_xdrfunc( rname, typename )
char* rname;
char* typename;
{
  if( Cflag )
    f_print(fout, "\t\txdr_%s = (xdrproc_t) xdr_%s;\n", rname, 
	    stringfix(typename) );
  else
    f_print(fout, "\t\txdr_%s = xdr_%s;\n", rname, stringfix(typename) );
}    
d87 2
a88 2
	ptype( plist->res_prefix, plist->res_type, 1 );
	f_print( fout, "*" );
a90 1

d92 1
a92 1
 * write most of the service, that is, everything but the registrations. 
d98 1
a98 1
        int nomain;
d101 1
a101 1
	        char* var_type;
d103 3
a105 3
		f_print(fout, "%s int _rpcpmstart;", var_type );
		f_print(fout, "\t\t/* Started by a port monitor ? */\n"); 
		f_print(fout, "%s int _rpcfdtype;", var_type );
d108 1
a108 1
			f_print(fout, "%s int _rpcsvcdirty;", var_type );
d111 1
a111 1
		write_svc_aux( nomain );
d114 1
a114 1
	write_programs( nomain? (char *)NULL : "static" );
d116 2
a117 2
        if( nomain ) 
	  return;
d124 1
a124 1
	  if( tirpcflag ) {
d149 1
a149 1
 * write a registration for the given transport 
d166 1
a166 1
	sprintf(tmpbuf, "%s\t\t", sp);
d171 1
a171 1
			sp, TRANSP);
d180 1
a180 1
		if (def->def_kind != DEF_PROGRAM) {
a181 1
		}
d184 2
a185 2
				"%s\t(void) rpcb_unset(%s, %s, nconf);\n",
				sp, def->def_name, vp->vers_name);
d187 2
a188 2
				"%s\tif (!svc_reg(%s, %s, %s, ",
				sp, TRANSP, def->def_name, vp->vers_name);
d192 1
a192 1
					def->def_name, vp->vers_name, transp);
d214 1
a214 1
		if (def->def_kind != DEF_PROGRAM) {
a215 1
		}
d220 1
a220 1
				def->def_name, vp->vers_name, transp);
d222 2
a223 2
				"unable to create (%s, %s) for %s.",
					def->def_name, vp->vers_name, transp);
d232 1
a232 1
 * write the rest of the service 
d246 3
a248 3
			f_print(fout, 
				"\t\t(void) signal(SIGALRM, %s closedown);\n",
				Cflag? "(SIG_PF)" : "(void(*)())" );
d265 1
a266 1
	definition *def;
d271 1
a271 1
		if (def->def_kind == DEF_PROGRAM) {
a272 1
		}
d278 1
a278 1
		if (def->def_kind == DEF_PROGRAM) {
a279 1
		}
a280 2


d295 1
a295 1
	if( !newstyle ) return;  /* not needed for old style */
d302 2
a303 2
			if( Cflag ) {
			  f_print(fout, "(" );
d308 1
a308 1
			    ptype(proc->args.decls->decl.prefix, 
d310 1
a310 1
			  f_print(fout, " *argp, struct svc_req *%s)\n", 
d313 1
a313 1
			  f_print(fout, "(argp, %s)\n", RQSTP );
d319 1
a319 1
			    ptype(proc->args.decls->decl.prefix, 
d331 1
a331 1
			  if (!streq( proc->args.decls->decl.type, "void"))
d334 1
a334 1
			  for (l = proc->args.decls;  l != NULL; l = l->next) 
d338 1
a338 1
		} 		
d342 1
a342 1
static 
d353 1
a353 1
		if (storage != NULL) {
a354 1
		}
d359 2
a360 2
		   f_print(fout, "(struct svc_req *%s, ", RQSTP);
		   f_print(fout, "register SVCXPRT *%s)\n", TRANSP);
d362 3
a364 3
		   f_print(fout, "(%s, %s)\n", RQSTP, TRANSP);
		   f_print(fout, "	struct svc_req *%s;\n", RQSTP);
		   f_print(fout, "	register SVCXPRT *%s;\n", TRANSP);
a365 1

d372 2
a373 2
				if (streq(proc->args.decls->decl.type, 
					  "void")) {
a374 1
				}
d377 2
a378 2
				ptype(proc->args.decls->decl.prefix, 
				      proc->args.decls->decl.type, 0);
d382 1
a382 2
			}
			else {
d390 1
a390 1
		if (!filled) {
a391 1
		}
d396 2
a397 2
		    f_print(fout, "\txdrproc_t xdr_%s, xdr_%s;\n", ARG, RESULT);
		    f_print(fout,
d401 3
a403 2
		    f_print(fout, "\tbool_t (*xdr_%s)(), (*xdr_%s)();\n", ARG, RESULT);
		    f_print(fout, "\tchar *(*%s)();\n", ROUTINE);
a404 1

d407 1
a407 1
		if (callerflag) 
d415 4
a418 4
			Cflag
			? "\t\t(void) svc_sendreply(%s, (xdrproc_t) xdr_void, (char *)NULL);\n"
			: "\t\t(void) svc_sendreply(%s, xdr_void, (char *)NULL);\n",
					TRANSP);
d425 1
a425 1
			  p_xdrfunc( ARG, proc->args.decls->decl.type);
d427 1
a427 1
			  p_xdrfunc( ARG, proc->args.argname);
d429 3
a431 3
			p_xdrfunc( RESULT, proc->res_type);
			if( Cflag )
			    f_print(fout,
d435 1
a435 1
			    f_print(fout, "\t\t%s = (char *(*)()) ", ROUTINE);
d440 2
a441 2
			if (!newstyle )
			  pvname_svc(proc->proc_name, vp->vers_num);
d443 1
a443 1
			  pvname(proc->proc_name, vp->vers_num);
d453 1
a453 1
		printif("getargs", TRANSP, "(caddr_t) &", ARG);
d459 1
a459 1
		    f_print(fout, "\t%s = (*%s)((char *)&%s, %s);\n",
d462 1
a462 1
		    f_print(fout, "\t%s = (*%s)(&%s, %s);\n",
d464 3
a466 3
		f_print(fout, 
			"\tif (%s != NULL && !svc_sendreply(%s, xdr_%s, %s)) {\n",
			RESULT, TRANSP, RESULT, RESULT);
d470 1
a470 1
		printif("freeargs", TRANSP, "(caddr_t) &", ARG);
d489 1
a489 1
printif(proc, transp, prefix, arg)
d496 1
a496 1
		proc, transp, arg, prefix, arg);
d503 1
a503 1
		if (streq(proc->proc_num, "0")) {
a504 1
		}
d519 1
a519 1
	f_print(fout, 
d555 2
a557 2
	definition *def;
	version_list *vp;
d563 1
a563 1
					vp = vp->next) {
d565 1
a565 1
					space, def->def_name, vp->vers_name);
d584 1
a584 1
 * Write the server auxiliary function ( _msgout, timeout)
d587 1
a587 1
write_svc_aux( nomain )
d592 2
a593 2
	if( !nomain )
	  write_timeout_func();
d606 3
a608 3
	if( !Cflag ) {
	  f_print(fout, "void _msgout(msg)\n");
	  f_print(fout, "\tchar *msg;\n");
d610 1
a610 1
	  f_print(fout, "void _msgout(char* msg)\n");
d716 1
a716 1
	if( timerflag )
d742 1
a742 1
	if( timerflag )
d773 1
a773 1
				Cflag? "(SIG_PF)" : "(void(*)())" );
d793 1
a793 1
	if( tirpcflag )
d805 1
a805 1
	if( tirpcflag ) {
d821 1
a821 1
	if( tirpcflag )
d845 1
a845 1
	if (s) 
a851 3



d926 1
a926 1
			else 
@


1.6
log
@rpcgen is not nearly KNF, but it now generates close to KNF code
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.5 2001/07/18 22:26:00 deraadt Exp $	*/
d171 1
a171 1
			sp, TRANSP, transp);
@


1.5
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.3 2001/01/11 19:24:24 deraadt Exp $	*/
d126 1
a126 1
			f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
d137 1
a137 1
		f_print(fout, "\tregister SVCXPRT *%s;\n", TRANSP);
d221 1
a221 1
			f_print(fout, ", %s, %s, \"%s\")) {\n ",
d537 1
a537 1
	f_print(fout, "\t\t\t\t(char *)&_rpcfdtype, &ssize) == -1)\n");
d629 4
a632 3
	f_print(fout, "\telse\n");
	f_print(fout, "\t\t(void) fprintf(stderr, \"%%s\\n\", msg);\n");
	f_print(fout, "#else\n");
d650 1
d661 1
a661 1
	f_print(fout, "\t\t\texit(0);\n");
d666 1
a666 1
	f_print(fout, "\t\t\texit(0);\n");
d669 1
d891 1
a891 1
		f_print(fout, "\tif ((_rpcfdtype == 0) || (_rpcfdtype == %s)) {\n",
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@a42 1
#include "rpc_scan.h"
d54 14
a67 14
static void internal_proctype __P((proc_list *));
static void write_real_program __P((definition *));
static void write_program __P((definition *, char *));
static void printerr __P((char *, char *));
static void printif __P((char *, char *, char *, char *));
static void write_inetmost __P((char *));
static void print_return __P((char *));
static void print_pmapunset __P((char *));
static void print_err_message __P((char *));
static void write_timeout_func __P((void));
static void write_pm_most __P((char *, int));
static void write_caller_func __P((void));
static void write_rpc_svc_fg __P((char *, char *));
static void open_log_file __P((char *, char *));
d69 1
a69 1
static void
d81 1
a81 1
static void
d171 1
a171 1
			sp, TRANSP);
d293 1
a293 1
static void
d348 1
a348 1
static void
d491 1
a491 1
static void
d499 1
a499 1
static void
a509 1
int
d521 1
a521 1
static void
d550 1
a550 1
static void
d563 1
a563 1
static void
d583 1
a583 1
static void
a613 1
void
d640 1
a640 1
static void
d670 1
a670 1
static void
d708 1
a708 1
static void
d795 1
a795 1
static void
d846 1
a846 1
static void
@


1.3
log
@make closedown() use __svc_fdset, so that large fd_set sizes close down nice
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.2 1996/06/26 05:38:40 deraadt Exp $	*/
d43 1
d55 14
a68 14
void internal_proctype __P((proc_list *));
static write_real_program __P((definition *));
static write_program __P((definition *, char *));
static printerr __P((char *, char *));
static printif __P((char *, char *, char *, char *));
static write_inetmost __P((char *));
static print_return __P((char *));
static print_pmapunset __P((char *));
static print_err_message __P((char *));
static write_timeout_func __P((void));
static write_pm_most __P((char *, int));
static write_caller_func __P((void));
static write_rpc_svc_fg __P((char *, char *));
static open_log_file __P((char *, char *));
d70 1
a70 1
static
d82 1
a82 1
void
d172 1
a172 1
			sp, TRANSP, transp);
d294 1
a294 1
static
d349 1
a349 1
static 
d492 1
a492 1
static
d500 1
a500 1
static
d511 1
d523 1
a523 1
static
d552 1
a552 1
static
d565 1
a565 1
static
d585 1
a585 1
static
d616 1
d643 1
a643 1
static
d673 1
a673 1
static
d711 1
a711 1
static
d798 1
a798 1
static
d849 1
a849 1
static
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_svcout.c,v 1.7 1995/06/24 14:59:59 pk Exp $	*/
d650 2
a651 2
	f_print(fout, "\t\textern fd_set svc_fdset;\n");
	f_print(fout, "\t\tstatic int size;\n");
d660 2
a661 13
	f_print(fout, "\t\tif (size == 0) {\n");
	if( tirpcflag ) {
	  f_print(fout, "\t\t\tstruct rlimit rl;\n\n");
	  f_print(fout, "\t\t\trl.rlim_max = 0;\n");
	  f_print(fout, "\t\t\tgetrlimit(RLIMIT_NOFILE, &rl);\n");
	  f_print(fout, "\t\t\tif ((size = rl.rlim_max) == 0)\n");
	  f_print(fout, "\t\t\t\treturn;\n");
	} else {
	  f_print(fout, "\t\t\tsize = getdtablesize();\n");
	}
	f_print(fout, "\t\t}\n");
	f_print(fout, "\t\tfor (i = 0, openfd = 0; i < size && openfd < 2; i++)\n");
	f_print(fout, "\t\t\tif (FD_ISSET(i, &svc_fdset))\n");
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
