head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.28
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.24
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.20
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.22
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.14
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.18
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.16
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.12
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.18
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.16
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.14
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.09.03.35.21;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.3;

1.3
date	97.06.11.08.27.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@/*	$OpenBSD: rpc_clntout.c,v 1.14 2009/10/27 23:59:42 deraadt Exp $	*/
/*	$NetBSD: rpc_clntout.c,v 1.4 1995/06/11 21:49:52 pk Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_clntout.c, Client-stub outputter for the RPC protocol compiler
 */
#include <stdio.h>
#include <string.h>
#include <rpc/types.h>
#include "rpc_parse.h"
#include "rpc_util.h"

static void write_program(definition *);
static void printbody(proc_list *);

#define DEFAULT_TIMEOUT 25	/* in seconds */
static char RESULT[] = "clnt_res";


void
write_stubs()
{
	list *l;
	definition *def;

	fprintf(fout,
		"\n/* Default timeout can be changed using clnt_control() */\n");
	fprintf(fout, "static struct timeval TIMEOUT = { %d, 0 };\n",
		DEFAULT_TIMEOUT);
	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind == DEF_PROGRAM) {
			write_program(def);
		}
	}
}

static void
write_program(def)
	definition *def;
{
	version_list *vp;
	proc_list *proc;

	for (vp = def->def.pr.versions; vp != NULL; vp = vp->next) {
		for (proc = vp->procs; proc != NULL; proc = proc->next) {
			fprintf(fout, "\n");
			ptype(proc->res_prefix, proc->res_type, 1);
			fprintf(fout, "*\n");
			pvname(proc->proc_name, vp->vers_num);
			printarglist(proc, "clnt", "CLIENT *");
			fprintf(fout, "{\n");
			printbody(proc);
			fprintf(fout, "}\n");
		}
	}
}

/*
 * Writes out declarations of procedure's argument list.
 * In either ANSI C style, in one of old rpcgen style (pass by reference),
 * or new rpcgen style (multiple arguments, pass by value);
 */

/* sample addargname = "clnt"; sample addargtype = "CLIENT * " */

void printarglist(proc, addargname, addargtype)
	proc_list *proc;
	char *addargname, *addargtype;
{
	decl_list *l;

	if (!newstyle) {	/* old style: always pass argument by reference */
		if (Cflag) {			/* C++ style heading */
			fprintf(fout, "(");
			ptype(proc->args.decls->decl.prefix,
			    proc->args.decls->decl.type, 1);
			fprintf(fout, "*argp, %s%s)\n", addargtype, addargname);
		} else {
			fprintf(fout, "(argp, %s)\n", addargname);
			fprintf(fout, "\t");
			ptype(proc->args.decls->decl.prefix,
			    proc->args.decls->decl.type, 1);
			fprintf(fout, "*argp;\n");
		}
	} else if (streq(proc->args.decls->decl.type, "void")) {
		/* newstyle, 0 argument */
		if (Cflag)
			fprintf(fout, "(%s%s)\n", addargtype, addargname);
		else
			fprintf(fout, "(%s)\n", addargname);
	} else {
		/* new style, 1 or multiple arguments */
		if (!Cflag) {
			fprintf(fout, "(");
			for (l = proc->args.decls; l != NULL; l = l->next)
				fprintf(fout, "%s, ", l->decl.name);
			fprintf(fout, "%s)\n", addargname);
			for (l = proc->args.decls; l != NULL; l = l->next)
				pdeclaration(proc->args.argname, &l->decl, 1, ";\n");
		} else {	/* C++ style header */
			fprintf(fout, "(");
			for (l = proc->args.decls; l != NULL; l = l->next)
				pdeclaration(proc->args.argname, &l->decl, 0, ", ");
			fprintf(fout, " %s%s)\n", addargtype, addargname);
		}
	}

	if (!Cflag)
		fprintf(fout, "\t%s%s;\n", addargtype, addargname);
}

static char *
ampr(char *type)
{
	if (isvectordef(type, REL_ALIAS)) {
		return ("");
	} else {
		return ("&");
	}
}

static void
printbody(proc)
	proc_list *proc;
{
	decl_list *l;
	bool_t args2 = (proc->arg_num > 1);

	/*
	 * For new style with multiple arguments, need a structure in which
	 * to stuff the arguments.
	 */
	if (newstyle && args2) {
		fprintf(fout, "\t%s", proc->args.argname);
		fprintf(fout, " arg;\n");
	}
	fprintf(fout, "\tstatic ");
	if (streq(proc->res_type, "void")) {
		fprintf(fout, "char ");
	} else {
		ptype(proc->res_prefix, proc->res_type, 0);
	}
	fprintf(fout, "%s;\n",RESULT);
	fprintf(fout, "\n");
	fprintf(fout, "\tmemset((char *)%s%s, 0, sizeof(%s));\n",
	    ampr(proc->res_type), RESULT, RESULT);
	if (newstyle && !args2 && (streq(proc->args.decls->decl.type, "void"))) {
		/* newstyle, 0 arguments */
		fprintf(fout,
		    "\tif (clnt_call(clnt, %s, xdr_void", proc->proc_name);
		fprintf(fout,
		    ", NULL, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
		    stringfix(proc->res_type), ampr(proc->res_type), RESULT);
	} else if (newstyle && args2) {
		/* newstyle, multiple arguments:  stuff arguments into structure */
		for (l = proc->args.decls;  l != NULL; l = l->next) {
			fprintf(fout, "\targ.%s = %s;\n",
			    l->decl.name, l->decl.name);
		}
		fprintf(fout,
		    "\tif (clnt_call(clnt, %s, xdr_%s", proc->proc_name,
		    proc->args.argname);
		fprintf(fout,
		    ", &arg, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
		    stringfix(proc->res_type),
		    ampr(proc->res_type), RESULT);
	} else {  /* single argument, new or old style */
		fprintf(fout,
		    "\tif (clnt_call(clnt, %s, xdr_%s, %s%s, xdr_%s, "
		    "%s%s, TIMEOUT) != RPC_SUCCESS) {\n",
		    proc->proc_name,
		    stringfix(proc->args.decls->decl.type),
		    (newstyle ? "&" : ""),
		    (newstyle ? proc->args.decls->decl.name : "argp"),
		    stringfix(proc->res_type),
		    ampr(proc->res_type),RESULT);
	}
	fprintf(fout, "\t\treturn (NULL);\n");
	fprintf(fout, "\t}\n");
	if (streq(proc->res_type, "void")) {
		fprintf(fout, "\treturn ((void *)%s%s);\n",
		    ampr(proc->res_type),RESULT);
	} else {
		fprintf(fout, "\treturn (%s%s);\n", ampr(proc->res_type),RESULT);
	}
}

@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.13 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 15
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d7 3
a9 3
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
d11 9
a19 3
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
d21 12
a32 3
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a36 1
 * Copyright (C) 1987, Sun Microsytsems, Inc.
@


1.13
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.12 2003/07/09 03:35:21 deraadt Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_clntout.c 1.11 89/02/22 (C) 1987 SMI";
#endif
@


1.12
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.11 2002/07/05 05:39:42 deraadt Exp $	*/
d34 1
a34 1
static char sccsid[] = "@@(#)rpc_clntout.c 1.11 89/02/22 (C) 1987 SMI";
@


1.11
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.10 2002/06/01 01:40:38 deraadt Exp $	*/
a49 2
extern void pdeclaration();

d148 1
a148 2
ampr(type)
	char *type;
@


1.10
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.9 2002/02/16 21:27:51 millert Exp $	*/
d87 1
a87 1
			printarglist( proc, "clnt", "CLIENT *" );
d95 5
a99 4
/* Writes out declarations of procedure's argument list.
   In either ANSI C style, in one of old rpcgen style (pass by reference),
   or new rpcgen style (multiple arguments, pass by value);
   */
d103 3
a105 3
void printarglist( proc, addargname, addargtype )
     proc_list *proc;
     char *addargname, *addargtype;
d107 1
d109 35
a143 37
  decl_list *l;

  if (!newstyle) {    /* old style: always pass argument by reference */
    if (Cflag) {      /* C++ style heading */
      fprintf(fout, "(");
      ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
      fprintf(fout, "*argp, %s%s)\n", addargtype, addargname );
    } else {
      fprintf(fout, "(argp, %s)\n", addargname);
      fprintf(fout, "\t");
      ptype(proc->args.decls->decl.prefix, proc->args.decls->decl.type, 1);
      fprintf(fout, "*argp;\n");
    }
  } else if (streq( proc->args.decls->decl.type, "void")) {
    /* newstyle, 0 argument */
    if (Cflag)
      fprintf(fout, "(%s%s)\n", addargtype, addargname );
    else
      fprintf(fout, "(%s)\n", addargname);
  } else {
    /* new style, 1 or multiple arguments */
    if (!Cflag) {
      fprintf(fout, "(");
      for (l = proc->args.decls;  l != NULL; l = l->next)
	fprintf(fout, "%s, ", l->decl.name);
      fprintf(fout, "%s)\n", addargname );
      for (l = proc->args.decls; l != NULL; l = l->next) {
	pdeclaration(proc->args.argname, &l->decl, 1, ";\n" );
      }
    } else {  /* C++ style header */
      fprintf(fout, "(");
      for(l = proc->args.decls; l != NULL; l = l->next) {
	pdeclaration(proc->args.argname, &l->decl, 0, ", " );
      }
      fprintf(fout, " %s%s)\n", addargtype, addargname );
    }
  }
d145 2
a146 2
  if (!Cflag)
    fprintf(fout, "\t%s%s;\n", addargtype, addargname );
a148 2


d164 2
a165 2
  decl_list *l;
  bool_t args2 = (proc->arg_num > 1);
d167 5
a171 3
  /* For new style with multiple arguments, need a structure in which
     to stuff the arguments. */
	if ( newstyle && args2) {
d183 5
a187 5
        fprintf(fout, "\tmemset((char *)%s%s, 0, sizeof(%s));\n",
		ampr(proc->res_type ), RESULT, RESULT);
	if (newstyle && !args2 && (streq( proc->args.decls->decl.type, "void"))) {
	  /* newstyle, 0 arguments */
	  fprintf(fout,
d189 16
a204 17
	  fprintf(fout,
 		  ", NULL, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
 		  stringfix(proc->res_type), ampr(proc->res_type), RESULT);

	} else if ( newstyle && args2) {
	  /* newstyle, multiple arguments:  stuff arguments into structure */
	  for (l = proc->args.decls;  l != NULL; l = l->next) {
	    fprintf(fout, "\targ.%s = %s;\n",
		    l->decl.name, l->decl.name);
	  }
	  fprintf(fout,
		  "\tif (clnt_call(clnt, %s, xdr_%s", proc->proc_name,
		  proc->args.argname);
	  fprintf(fout,
 		  ", &arg, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
 		  stringfix(proc->res_type),
		  ampr(proc->res_type), RESULT);
d206 10
a215 9
	      fprintf(fout,
 		      "\tif (clnt_call(clnt, %s, xdr_%s, %s%s, xdr_%s, %s%s, TIMEOUT) != RPC_SUCCESS) {\n",
		      proc->proc_name,
		      stringfix(proc->args.decls->decl.type),
		      (newstyle ? "&" : ""),
		      (newstyle ? proc->args.decls->decl.name : "argp"),
		      stringfix(proc->res_type),
		      ampr(proc->res_type),RESULT);
	    }
d220 1
a220 1
			ampr(proc->res_type),RESULT);
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.8 2001/12/05 09:50:31 deraadt Exp $	*/
d62 1
a62 1
	f_print(fout,
d64 1
a64 1
	f_print(fout, "static struct timeval TIMEOUT = { %d, 0 };\n",
d83 1
a83 1
			f_print(fout, "\n");
d85 1
a85 1
			f_print(fout, "*\n");
d88 1
a88 1
			f_print(fout, "{\n");
d90 1
a90 1
			f_print(fout, "}\n");
d111 1
a111 1
      f_print(fout, "(");
d113 1
a113 1
      f_print(fout, "*argp, %s%s)\n", addargtype, addargname );
d115 2
a116 2
      f_print(fout, "(argp, %s)\n", addargname);
      f_print(fout, "\t");
d118 1
a118 1
      f_print(fout, "*argp;\n");
d123 1
a123 1
      f_print(fout, "(%s%s)\n", addargtype, addargname );
d125 1
a125 1
      f_print(fout, "(%s)\n", addargname);
d129 1
a129 1
      f_print(fout, "(");
d131 2
a132 2
	f_print(fout, "%s, ", l->decl.name);
      f_print(fout, "%s)\n", addargname );
d137 1
a137 1
      f_print(fout, "(");
d141 1
a141 1
      f_print(fout, " %s%s)\n", addargtype, addargname );
d146 1
a146 1
    f_print(fout, "\t%s%s;\n", addargtype, addargname );
d172 2
a173 2
		f_print(fout, "\t%s", proc->args.argname);
		f_print(fout, " arg;\n");
d175 1
a175 1
	f_print(fout, "\tstatic ");
d177 1
a177 1
		f_print(fout, "char ");
d181 3
a183 3
	f_print(fout, "%s;\n",RESULT);
	f_print(fout, "\n");
        f_print(fout, "\tmemset((char *)%s%s, 0, sizeof(%s));\n",
d187 1
a187 1
	  f_print(fout,
d189 1
a189 1
	  f_print(fout,
d196 1
a196 1
	    f_print(fout, "\targ.%s = %s;\n",
d199 1
a199 1
	  f_print(fout,
d202 1
a202 1
	  f_print(fout,
d207 1
a207 1
	      f_print(fout,
d216 2
a217 2
	f_print(fout, "\t\treturn (NULL);\n");
	f_print(fout, "\t}\n");
d219 1
a219 1
		f_print(fout, "\treturn ((void *)%s%s);\n",
d222 1
a222 1
		f_print(fout, "\treturn (%s%s);\n", ampr(proc->res_type),RESULT);
@


1.8
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.6 2001/11/24 19:17:47 deraadt Exp $	*/
d47 2
a48 2
static void write_program __P((definition *));
static void printbody __P((proc_list *));
@


1.7
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.5 2001/07/18 22:26:00 deraadt Exp $	*/
d47 1
a47 1
static write_program __P((definition *));
d50 1
a50 1
extern pdeclaration();
d62 1
a62 1
	f_print(fout, 
d74 1
a74 1
static
d120 1
a120 1
  } else if (streq( proc->args.decls->decl.type, "void")) { 
d122 1
a122 1
    if( Cflag ) 
d128 1
a128 1
    if( !Cflag ) {
d130 1
a130 1
      for (l = proc->args.decls;  l != NULL; l = l->next) 
d145 1
a145 1
  if( !Cflag ) 
a167 1
  int i;
d173 1
a173 1
		f_print(fout, " arg;\n");	
d189 1
a189 1
	  f_print(fout, 
d202 1
a202 1
	  f_print(fout, 
d209 2
a210 2
		      proc->proc_name, 
		      stringfix(proc->args.decls->decl.type), 
d219 1
a219 1
		f_print(fout, "\treturn ((void *)%s%s);\n", 
@


1.6
log
@half finished KNF
@
text
@d47 1
a47 1
static void write_program __P((definition *));
d50 1
a50 1
extern void pdeclaration();
d62 1
a62 1
	f_print(fout,
d74 1
a74 1
static void
d120 1
a120 1
  } else if (streq( proc->args.decls->decl.type, "void")) {
d122 1
a122 1
    if (Cflag)
d128 1
a128 1
    if (!Cflag) {
d130 1
a130 1
      for (l = proc->args.decls;  l != NULL; l = l->next)
d145 1
a145 1
  if (!Cflag)
d168 1
d174 1
a174 1
		f_print(fout, " arg;\n");
d190 1
a190 1
	  f_print(fout,
d203 1
a203 1
	  f_print(fout,
d210 2
a211 2
		      proc->proc_name,
		      stringfix(proc->args.decls->decl.type),
d220 1
a220 1
		f_print(fout, "\treturn ((void *)%s%s);\n",
@


1.5
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.3 1997/06/11 08:27:27 deraadt Exp $	*/
d47 1
a47 1
static write_program __P((definition *));
d50 1
a50 1
extern pdeclaration();
d62 1
a62 1
	f_print(fout, 
d74 1
a74 1
static
d120 1
a120 1
  } else if (streq( proc->args.decls->decl.type, "void")) { 
d122 1
a122 1
    if( Cflag ) 
d128 1
a128 1
    if( !Cflag ) {
d130 1
a130 1
      for (l = proc->args.decls;  l != NULL; l = l->next) 
d145 1
a145 1
  if( !Cflag ) 
a167 1
  int i;
d173 1
a173 1
		f_print(fout, " arg;\n");	
d189 1
a189 1
	  f_print(fout, 
d202 1
a202 1
	  f_print(fout, 
d209 2
a210 2
		      proc->proc_name, 
		      stringfix(proc->args.decls->decl.type), 
d219 1
a219 1
		f_print(fout, "\treturn ((void *)%s%s);\n", 
@


1.4
log
@-Wall cleanup; ok deraadt
@
text
@d47 1
a47 1
static void write_program __P((definition *));
d50 2
d74 1
a74 1
static void
d168 1
@


1.3
log
@remove spurious ,; jtk
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.2 1996/06/26 05:38:35 deraadt Exp $	*/
d47 1
a47 1
static write_program __P((definition *));
a49 2
extern pdeclaration();

d72 1
a72 1
static
a165 1
  int i;
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_clntout.c,v 1.4 1995/06/11 21:49:52 pk Exp $	*/
d191 1
a191 1
 		  ", NULL, xdr_%s, %s,%s, TIMEOUT) != RPC_SUCCESS) {\n",
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
