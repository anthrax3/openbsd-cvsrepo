head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.16
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.12
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.14
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.6
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.10
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.8
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.4
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.10
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.6
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.4
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.16.0.16
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.14
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.12
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.10
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.10
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.12.20.22.19.08;	author krw;	state Exp;
branches;
next	1.21;
commitid	he6NK9EzIygmfrzo;

1.21
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.06.11.36.26;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.01.15.34.26;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.25.16.04.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.19.20.31.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.21.05.39;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.08.52.41;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Add 'default:' cases to switch statements that gcc whines about.

ok jung@@
@
text
@/*	$OpenBSD: rpc_hout.c,v 1.21 2012/12/05 23:20:26 deraadt Exp $	*/
/*	$NetBSD: rpc_hout.c,v 1.4 1995/06/11 21:49:55 pk Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_hout.c, Header file outputter for the RPC protocol compiler
 */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "rpc_parse.h"
#include "rpc_util.h"

static void pconstdef(definition *);
static void pargdef(definition *);
static void pstructdef(definition *);
static void puniondef(definition *);
static void pprogramdef(definition *);
static void penumdef(definition *);
static void ptypedef(definition *);
static void pdefine(char *, char *);
static void puldefine(char *, char *);
static int define_printed(proc_list *, version_list *);
static int undefined2(char *, char *);
static void parglist(proc_list *, char *);
void pxdrfuncdecl(char *, int);
void pprocdef(proc_list *, version_list *, char *, int, int);
void pdeclaration(char *, declaration *, int, char *);

/*
 * Print the C-version of an xdr definition
 */
void
print_datadef(def)
	definition *def;
{

	if (def->def_kind == DEF_PROGRAM)  /* handle data only */
		return;

	if (def->def_kind != DEF_CONST)
		fprintf(fout, "\n");
	switch (def->def_kind) {
	case DEF_STRUCT:
		pstructdef(def);
		break;
	case DEF_UNION:
		puniondef(def);
		break;
	case DEF_ENUM:
		penumdef(def);
		break;
	case DEF_TYPEDEF:
		ptypedef(def);
		break;
	case DEF_PROGRAM:
		pprogramdef(def);
		break;
	case DEF_CONST:
		pconstdef(def);
		break;
	default:
		break;
	}
	if (def->def_kind != DEF_PROGRAM && def->def_kind != DEF_CONST) {
		pxdrfuncdecl(def->def_name,
		    def->def_kind != DEF_TYPEDEF ||
		    !isvectordef(def->def.ty.old_type, def->def.ty.rel));
	}
}


void
print_funcdef(def)
	definition *def;
{
	switch (def->def_kind) {
	case DEF_PROGRAM:
		fprintf(fout, "\n");
		pprogramdef(def);
		break;
	default:
		break;
	}
}

void
pxdrfuncdecl(name, pointerp)
	char *name;
	int pointerp;
{

	fprintf(fout,"#ifdef __cplusplus\n");
	fprintf(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s %s);\n",
	    name, name, pointerp ? ("*") : "");
	fprintf(fout,"#elif defined(__STDC__)\n");
	fprintf(fout, "extern bool_t xdr_%s(XDR *, %s %s);\n",
	    name, name, pointerp ? ("*") : "");
	fprintf(fout,"#else /* Old Style C */\n");
	fprintf(fout, "bool_t xdr_%s();\n", name);
	fprintf(fout,"#endif /* Old Style C */\n\n");
}


static void
pconstdef(def)
	definition *def;
{
	pdefine(def->def_name, def->def.co);
}

/*
 * print out the definitions for the arguments of functions in the
 * header file
 */
static void
pargdef(def)
	definition *def;
{
	decl_list *l;
	version_list *vers;
	char *name;
	proc_list *plist;

	for (vers = def->def.pr.versions; vers != NULL; vers = vers->next) {
		for (plist = vers->procs; plist != NULL;
		    plist = plist->next) {
			if (!newstyle || plist->arg_num < 2) {
				continue; /* old style or single args */
			}
			name = plist->args.argname;
			fprintf(fout, "struct %s {\n", name);
			for (l = plist->args.decls;
			    l != NULL; l = l->next) {
				pdeclaration(name, &l->decl, 1, ";\n");
			}
			fprintf(fout, "};\n");
			fprintf(fout, "typedef struct %s %s;\n", name, name);
			pxdrfuncdecl(name, 0);
			fprintf(fout, "\n");
		}
	}
}

static void
pstructdef(def)
	definition *def;
{
	char *name = def->def_name;
	decl_list *l;

	fprintf(fout, "struct %s {\n", name);
	for (l = def->def.st.decls; l != NULL; l = l->next)
		pdeclaration(name, &l->decl, 1, ";\n");
	fprintf(fout, "};\n");
	fprintf(fout, "typedef struct %s %s;\n", name, name);
}

static void
puniondef(def)
	definition *def;
{
	case_list *l;
	char *name = def->def_name;
	declaration *decl;

	fprintf(fout, "struct %s {\n", name);
	decl = &def->def.un.enum_decl;
	if (streq(decl->type, "bool")) {
		fprintf(fout, "\tbool_t %s;\n", decl->name);
	} else {
		fprintf(fout, "\t%s %s;\n", decl->type, decl->name);
	}
	fprintf(fout, "\tunion {\n");
	for (l = def->def.un.cases; l != NULL; l = l->next) {
	  if (l->contflag == 0)
		pdeclaration(name, &l->case_decl, 2, ";\n");
	}
	decl = def->def.un.default_decl;
	if (decl && !streq(decl->type, "void")) {
		pdeclaration(name, decl, 2, ";\n");
	}
	fprintf(fout, "\t} %s_u;\n", name);
	fprintf(fout, "};\n");
	fprintf(fout, "typedef struct %s %s;\n", name, name);
}

static void
pdefine(name, num)
	char *name;
	char *num;
{
	fprintf(fout, "#define %s %s\n", name, num);
}

static void
puldefine(name, num)
	char *name;
	char *num;
{
	fprintf(fout, "#define %s ((u_long)%s)\n", name, num);
}

static int
define_printed(stop, start)
	proc_list *stop;
	version_list *start;
{
	version_list *vers;
	proc_list *proc;

	for (vers = start; vers != NULL; vers = vers->next) {
		for (proc = vers->procs; proc != NULL; proc = proc->next) {
			if (proc == stop) {
				return (0);
			} else if (streq(proc->proc_name, stop->proc_name)) {
				return (1);
			}
		}
	}
	abort();
	/* NOTREACHED */
}

static void
pprogramdef(def)
	definition *def;
{
	version_list *vers;
	proc_list *proc;
	int i;
	char *ext;

	pargdef(def);

	puldefine(def->def_name, def->def.pr.prog_num);
	for (vers = def->def.pr.versions; vers != NULL; vers = vers->next) {
		if (tblflag) {
			fprintf(fout, "extern struct rpcgen_table %s_%s_table[];\n",
			    locase(def->def_name), vers->vers_num);
			fprintf(fout, "extern %s_%s_nproc;\n",
			    locase(def->def_name), vers->vers_num);
		}
		puldefine(vers->vers_name, vers->vers_num);

		/*
		 * Print out 3 definitions, one for ANSI-C, another for C++,
		 * a third for old style C
		 */
		for (i=0; i<3; i++) {
			if (i==0) {
				fprintf(fout,"\n#ifdef __cplusplus\n");
				ext = "extern \"C\" ";
			} else if (i==1) {
				fprintf(fout,"\n#elif defined(__STDC__)\n");
				ext = "extern ";
			} else {
				fprintf(fout,"\n#else /* Old Style C */\n");
				ext = "extern ";
			}

			for (proc = vers->procs; proc != NULL; proc = proc->next) {
				if (!define_printed(proc, def->def.pr.versions))
					puldefine(proc->proc_name, proc->proc_num);
				fprintf(fout,"%s",ext);
				pprocdef(proc, vers, "CLIENT *", 0,i);
				fprintf(fout,"%s",ext);
				pprocdef(proc, vers, "struct svc_req *", 1,i);
			}
		}
		fprintf(fout,"#endif /* Old Style C */\n");
	}
}

void
pprocdef(proc, vp, addargtype, server_p,mode)
	proc_list *proc;
	version_list *vp;
	char *addargtype;
	int server_p;
	int mode;
{

	ptype(proc->res_prefix, proc->res_type, 1);
	fprintf(fout, "* ");
	if (server_p)
		pvname_svc(proc->proc_name, vp->vers_num);
	else
		pvname(proc->proc_name, vp->vers_num);

	/*
	 * mode  0 == cplusplus, mode  1 = ANSI-C, mode 2 = old style C
	 */
	if (mode == 0 || mode == 1)
		parglist(proc, addargtype);
	else
		fprintf(fout, "();\n");
}

/* print out argument list of procedure */
static void
parglist(proc, addargtype)
	proc_list *proc;
	char *addargtype;
{
	decl_list *dl;

	fprintf(fout,"(");

	if (proc->arg_num < 2 && newstyle &&
	   streq(proc->args.decls->decl.type, "void")) {
		/* 0 argument in new style:  do nothing */
	} else {
		for (dl = proc->args.decls; dl != NULL; dl = dl->next) {
			ptype(dl->decl.prefix, dl->decl.type, 1);
			if (!newstyle)
				fprintf(fout, "*"); /* old style passes by reference */
			fprintf(fout, ", ");
		}
	}
	fprintf(fout, "%s);\n", addargtype);
}

static void
penumdef(def)
	definition *def;
{
	char *name = def->def_name;
	enumval_list *l;
	char *last = NULL;
	int count = 0;

	fprintf(fout, "enum %s {\n", name);
	for (l = def->def.en.vals; l != NULL; l = l->next) {
		fprintf(fout, "\t%s", l->name);
		if (l->assignment) {
			fprintf(fout, " = %s", l->assignment);
			last = l->assignment;
			count = 1;
		} else {
			if (last == NULL) {
				fprintf(fout, " = %d", count++);
			} else {
				fprintf(fout, " = %s + %d", last, count++);
			}
		}
		if (l->next)
			fprintf(fout, ",\n");
		else
			fprintf(fout, "\n");
	}
	fprintf(fout, "};\n");
	fprintf(fout, "typedef enum %s %s;\n", name, name);
}

static void
ptypedef(def)
	definition *def;
{
	char *name = def->def_name;
	char *old = def->def.ty.old_type;
	char prefix[8];	/* enough to contain "struct ", including NUL */
	relation rel = def->def.ty.rel;

	if (!streq(name, old)) {
		if (streq(old, "string")) {
			old = "char";
			rel = REL_POINTER;
		} else if (streq(old, "opaque")) {
			old = "char";
		} else if (streq(old, "bool")) {
			old = "bool_t";
		}
		if (undefined2(old, name) && def->def.ty.old_prefix) {
			snprintf(prefix, sizeof prefix, "%s ", def->def.ty.old_prefix);
		} else {
			prefix[0] = 0;
		}
		fprintf(fout, "typedef ");
		switch (rel) {
		case REL_ARRAY:
			fprintf(fout, "struct {\n");
			fprintf(fout, "\tu_int %s_len;\n", name);
			fprintf(fout, "\t%s%s *%s_val;\n", prefix, old, name);
			fprintf(fout, "} %s", name);
			break;
		case REL_POINTER:
			fprintf(fout, "%s%s *%s", prefix, old, name);
			break;
		case REL_VECTOR:
			fprintf(fout, "%s%s %s[%s]", prefix, old, name,
				def->def.ty.array_max);
			break;
		case REL_ALIAS:
			fprintf(fout, "%s%s %s", prefix, old, name);
			break;
		}
		fprintf(fout, ";\n");
	}
}

void
pdeclaration(name, dec, tab, separator)
	char *name;
	declaration *dec;
	int tab;
	char *separator;
{
	char buf[8];	/* enough to hold "struct ", include NUL */
	char *prefix;
	char *type;

	if (streq(dec->type, "void"))
		return;
	tabify(fout, tab);
	if (streq(dec->type, name) && !dec->prefix) {
		fprintf(fout, "struct ");
	}
	if (streq(dec->type, "string")) {
		fprintf(fout, "char *%s", dec->name);
	} else {
		prefix = "";
		if (streq(dec->type, "bool")) {
			type = "bool_t";
		} else if (streq(dec->type, "opaque")) {
			type = "char";
		} else {
			if (dec->prefix) {
				snprintf(buf, sizeof buf, "%s ", dec->prefix);
				prefix = buf;
			}
			type = dec->type;
		}
		switch (dec->rel) {
		case REL_ALIAS:
			fprintf(fout, "%s%s %s", prefix, type, dec->name);
			break;
		case REL_VECTOR:
			fprintf(fout, "%s%s %s[%s]", prefix, type, dec->name,
				dec->array_max);
			break;
		case REL_POINTER:
			fprintf(fout, "%s%s *%s", prefix, type, dec->name);
			break;
		case REL_ARRAY:
			fprintf(fout, "struct {\n");
			tabify(fout, tab);
			fprintf(fout, "\tu_int %s_len;\n", dec->name);
			tabify(fout, tab);
			fprintf(fout, "\t%s%s *%s_val;\n", prefix, type, dec->name);
			tabify(fout, tab);
			fprintf(fout, "} %s", dec->name);
			break;
		}
	}
	fprintf(fout, "%s", separator);
}

static int
undefined2(type, stop)
	char *type;
	char *stop;
{
	list *l;
	definition *def;

	for (l = defined; l != NULL; l = l->next) {
		def = (definition *) l->val;
		if (def->def_kind != DEF_PROGRAM) {
			if (streq(def->def_name, stop)) {
				return (1);
			} else if (streq(def->def_name, type)) {
				return (0);
			}
		}
	}
	return (1);
}
@


1.21
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.20 2011/04/06 11:36:26 miod Exp $	*/
d92 2
d111 2
@


1.20
log
@Avoid using NULL in non-pointer contexts: use 0 for integer values and '\0'
for chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.19 2010/09/01 14:43:34 millert Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.19
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.18 2009/10/27 23:59:42 deraadt Exp $	*/
d166 1
a166 1
			pxdrfuncdecl(name, NULL);
@


1.18
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.17 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 7
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
d7 3
a9 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d11 9
a19 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d21 12
a32 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.17
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.16 2003/12/01 15:34:26 grange Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_hout.c 1.12 89/02/22 (C) 1987 SMI";
#endif
@


1.16
log
@Format string fixes from art's amd64 tree.
ok rohee@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.15 2003/07/10 00:06:51 david Exp $	*/
d34 1
a34 1
static char sccsid[] = "@@(#)rpc_hout.c 1.12 89/02/22 (C) 1987 SMI";
@


1.15
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.14 2003/06/25 16:04:45 deraadt Exp $	*/
d485 1
a485 1
	fprintf(fout, separator);
@


1.14
log
@better output C
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.13 2003/06/19 20:31:08 deraadt Exp $	*/
d42 1
@


1.13
log
@generate code that is much more ANSI and even KNF too
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.12 2002/07/05 05:39:42 deraadt Exp $	*/
d122 1
a122 1
	fprintf(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n",
d125 1
a125 1
	fprintf(fout, "extern bool_t xdr_%s(XDR *, %s%s);\n",
@


1.12
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.11 2002/06/01 01:40:38 deraadt Exp $	*/
d125 1
a125 1
	fprintf(fout, "extern  bool_t xdr_%s(XDR *, %s%s);\n",
d284 1
a284 1
				ext = "extern  ";
d287 1
a287 1
				ext = "extern  ";
@


1.11
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.10 2002/02/16 21:27:51 millert Exp $	*/
d71 1
a71 1
	        return;
d96 1
a96 1
		pxdrfuncdecl( def->def_name,
d140 4
a143 3
/* print out the definitions for the arguments of functions in the
   header file
*/
d154 1
a154 1
		for(plist = vers->procs; plist != NULL;
d162 1
a162 1
			     l != NULL; l = l->next) {
d278 1
a278 1
		for(i=0; i<3; i++) {
d435 1
a435 1
        char *separator;
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.9 2001/12/05 09:50:31 deraadt Exp $	*/
d74 1
a74 1
		f_print(fout, "\n");
d109 1
a109 1
		f_print(fout, "\n");
d121 2
a122 2
	f_print(fout,"#ifdef __cplusplus\n");
	f_print(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n",
d124 2
a125 2
	f_print(fout,"#elif defined(__STDC__)\n");
	f_print(fout, "extern  bool_t xdr_%s(XDR *, %s%s);\n",
d127 3
a129 3
	f_print(fout,"#else /* Old Style C */\n");
	f_print(fout, "bool_t xdr_%s();\n", name);
	f_print(fout,"#endif /* Old Style C */\n\n");
d159 1
a159 1
			f_print(fout, "struct %s {\n", name);
d164 2
a165 2
			f_print(fout, "};\n");
			f_print(fout, "typedef struct %s %s;\n", name, name);
d167 1
a167 1
			f_print(fout, "\n");
d179 1
a179 1
	f_print(fout, "struct %s {\n", name);
d182 2
a183 2
	f_print(fout, "};\n");
	f_print(fout, "typedef struct %s %s;\n", name, name);
d194 1
a194 1
	f_print(fout, "struct %s {\n", name);
d197 1
a197 1
		f_print(fout, "\tbool_t %s;\n", decl->name);
d199 1
a199 1
		f_print(fout, "\t%s %s;\n", decl->type, decl->name);
d201 1
a201 1
	f_print(fout, "\tunion {\n");
d210 3
a212 3
	f_print(fout, "\t} %s_u;\n", name);
	f_print(fout, "};\n");
	f_print(fout, "typedef struct %s %s;\n", name, name);
d220 1
a220 1
	f_print(fout, "#define %s %s\n", name, num);
d228 1
a228 1
	f_print(fout, "#define %s ((u_long)%s)\n", name, num);
d266 1
a266 1
			f_print(fout, "extern struct rpcgen_table %s_%s_table[];\n",
d268 1
a268 1
			f_print(fout, "extern %s_%s_nproc;\n",
d279 1
a279 1
				f_print(fout,"\n#ifdef __cplusplus\n");
d282 1
a282 1
				f_print(fout,"\n#elif defined(__STDC__)\n");
d285 1
a285 1
				f_print(fout,"\n#else /* Old Style C */\n");
d292 1
a292 1
				f_print(fout,"%s",ext);
d294 1
a294 1
				f_print(fout,"%s",ext);
d298 1
a298 1
		f_print(fout,"#endif /* Old Style C */\n");
d312 1
a312 1
	f_print(fout, "* ");
d324 1
a324 1
		f_print(fout, "();\n");
d335 1
a335 1
	f_print(fout,"(");
d344 2
a345 2
				f_print(fout, "*"); /* old style passes by reference */
			f_print(fout, ", ");
d348 1
a348 1
	f_print(fout, "%s);\n", addargtype);
d360 1
a360 1
	f_print(fout, "enum %s {\n", name);
d362 1
a362 1
		f_print(fout, "\t%s", l->name);
d364 1
a364 1
			f_print(fout, " = %s", l->assignment);
d369 1
a369 1
				f_print(fout, " = %d", count++);
d371 1
a371 1
				f_print(fout, " = %s + %d", last, count++);
d375 1
a375 1
			f_print(fout, ",\n");
d377 1
a377 1
			f_print(fout, "\n");
d379 2
a380 2
	f_print(fout, "};\n");
	f_print(fout, "typedef enum %s %s;\n", name, name);
d402 1
a402 1
			s_print(prefix, "%s ", def->def.ty.old_prefix);
d406 1
a406 1
		f_print(fout, "typedef ");
d409 4
a412 4
			f_print(fout, "struct {\n");
			f_print(fout, "\tu_int %s_len;\n", name);
			f_print(fout, "\t%s%s *%s_val;\n", prefix, old, name);
			f_print(fout, "} %s", name);
d415 1
a415 1
			f_print(fout, "%s%s *%s", prefix, old, name);
d418 1
a418 1
			f_print(fout, "%s%s %s[%s]", prefix, old, name,
d422 1
a422 1
			f_print(fout, "%s%s %s", prefix, old, name);
d425 1
a425 1
		f_print(fout, ";\n");
d444 1
a444 1
		f_print(fout, "struct ");
d447 1
a447 1
		f_print(fout, "char *%s", dec->name);
d456 1
a456 1
				s_print(buf, "%s ", dec->prefix);
d463 1
a463 1
			f_print(fout, "%s%s %s", prefix, type, dec->name);
d466 1
a466 1
			f_print(fout, "%s%s %s[%s]", prefix, type, dec->name,
d470 1
a470 1
			f_print(fout, "%s%s *%s", prefix, type, dec->name);
d473 1
a473 1
			f_print(fout, "struct {\n");
d475 1
a475 1
			f_print(fout, "\tu_int %s_len;\n", dec->name);
d477 1
a477 1
			f_print(fout, "\t%s%s *%s_val;\n", prefix, type, dec->name);
d479 1
a479 1
			f_print(fout, "} %s", dec->name);
d483 1
a483 1
	f_print(fout, separator);
@


1.9
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.7 2001/11/24 19:17:47 deraadt Exp $	*/
d46 12
a57 12
static void pconstdef __P((definition *));
static void pargdef __P((definition *));
static void pstructdef __P((definition *));
static void puniondef __P((definition *));
static void pprogramdef __P((definition *));
static void penumdef __P((definition *));
static void ptypedef __P((definition *));
static void pdefine __P((char *, char *));
static void puldefine __P((char *, char *));
static int define_printed __P((proc_list *, version_list *));
static int undefined2 __P((char *, char *));
static void parglist __P((proc_list *, char *));
@


1.8
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.6 2001/07/18 22:26:00 deraadt Exp $	*/
d38 1
a38 1
 * rpc_hout.c, Header file outputter for the RPC protocol compiler 
d46 15
a60 12
static pconstdef __P((definition *));
static pargdef __P((definition *));
static pstructdef __P((definition *));
static puniondef __P((definition *));
static pprogramdef __P((definition *));
static penumdef __P((definition *));
static ptypedef __P((definition *));
static pdefine __P((char *, char *));
static puldefine __P((char *, char *));
static define_printed __P((proc_list *, version_list *));
static undefined2 __P((char *, char *));
static parglist __P((proc_list *, char *));
d63 1
a63 1
 * Print the C-version of an xdr definition 
d70 1
a70 1
	if (def->def_kind == DEF_PROGRAM )  /* handle data only */
d73 1
a73 1
	if (def->def_kind != DEF_CONST) {
a74 1
	}
d96 3
a98 4
	  pxdrfuncdecl( def->def_name,
		       def->def_kind != DEF_TYPEDEF ||
		       !isvectordef(def->def.ty.old_type, def->def.ty.rel));

d112 1
a112 1
	      }
d115 4
a118 3
pxdrfuncdecl( name, pointerp )
char* name;
int pointerp;
d121 9
a129 11
  f_print(fout,"#ifdef __cplusplus\n");
    f_print(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n",
	name,
	name, pointerp ? ("*") : "");
  f_print(fout,"#elif defined(__STDC__)\n");
    f_print(fout, "extern  bool_t xdr_%s(XDR *, %s%s);\n",
	name,
	name, pointerp ? ("*") : "");
  f_print(fout,"#else /* Old Style C */\n");
    f_print(fout, "bool_t xdr_%s();\n", name);
  f_print(fout,"#endif /* Old Style C */\n\n");
d133 1
a133 1
static
d140 2
a141 2
/* print out the definitions for the arguments of functions in the 
   header file 
d143 1
a143 1
static 
a151 1
	
d153 10
a162 16
			for(plist = vers->procs; plist != NULL; 
			    plist = plist->next) {
				
				if (!newstyle || plist->arg_num < 2) {
					continue; /* old style or single args */
				}
				name = plist->args.argname;
				f_print(fout, "struct %s {\n", name);
				for (l = plist->args.decls; 
				     l != NULL; l = l->next) {
					pdeclaration(name, &l->decl, 1, ";\n" );
				}
				f_print(fout, "};\n");
				f_print(fout, "typedef struct %s %s;\n", name, name);
				pxdrfuncdecl( name,NULL );
				f_print( fout, "\n" );
d164 4
d169 1
a169 1

d172 1
a172 2

static 
d176 1
a177 1
	char *name = def->def_name;
d180 1
a180 1
	for (l = def->def.st.decls; l != NULL; l = l->next) {
a181 1
	}
d186 1
a186 1
static
d203 2
a204 2
	  if(l->contflag == 0)
		pdeclaration(name, &l->case_decl, 2, ";\n" );
d208 1
a208 1
		pdeclaration(name, decl, 2, ";\n" );
d215 1
a215 1
static
d223 1
a223 1
static
d231 1
a231 1
static
d252 1
a252 1
static
d260 1
a260 1
	
d267 1
a267 1
				locase(def->def_name), vers->vers_num);
d269 1
a269 1
				locase(def->def_name), vers->vers_num);
d273 3
a275 3
		/* 
		 * Print out 3 definitions, one for ANSI-C, another for C++, 
		 * a third for old style C 
d277 2
a278 3
		   
		for(i=0;i<3;i++){
			if(i==0){
d280 2
a281 2
				ext="extern \"C\" ";
			}else if ( i== 1){
d283 2
a284 2
				ext="extern  "  ;
			}else{
d286 1
a286 1
				ext="extern  ";
d288 1
a288 2
			
			
d290 1
a290 1
				if (!define_printed(proc, def->def.pr.versions)) {
a291 1
				}
a295 1
				
a296 1

d302 1
d306 1
a306 1
	char* addargtype;
d311 3
a313 3
	ptype( proc->res_prefix, proc->res_type, 1 );
	f_print( fout, "* " );
	if( server_p )
d319 1
a319 1
	 * mode  0 == cplusplus, mode  1 = ANSI-C, mode 2 = old style C 
d321 2
a322 2
	if(mode == 0 || mode ==1) 
		parglist( proc, addargtype );
a326 1

d328 1
a328 1
static 
d331 1
a331 1
	char* addargtype;
d337 2
a338 2
	if( proc->arg_num < 2 && newstyle &&
	   streq( proc->args.decls->decl.type, "void")) {
d342 4
a345 5
			ptype( dl->decl.prefix, dl->decl.type, 1 );
			if( !newstyle )
				f_print( fout, "*" ); /* old style passes by reference */

			f_print( fout, ", " );
a347 1

d351 1
a351 1
static
d383 1
a383 1
static
a391 1

d429 1
d440 1
a440 1
	if (streq(dec->type, "void")) {
a441 1
	}
d483 1
a483 1
	f_print(fout, separator );
d486 1
a486 1
static
@


1.7
log
@half finished KNF
@
text
@d46 12
a57 15
static void pconstdef __P((definition *));
static void pargdef __P((definition *));
static void pstructdef __P((definition *));
static void puniondef __P((definition *));
static void pprogramdef __P((definition *));
static void penumdef __P((definition *));
static void ptypedef __P((definition *));
static void pdefine __P((char *, char *));
static void puldefine __P((char *, char *));
static int define_printed __P((proc_list *, version_list *));
static int undefined2 __P((char *, char *));
static void parglist __P((proc_list *, char *));
void pxdrfuncdecl(char *, int);
void pprocdef(proc_list *, version_list *, char *, int, int);
void pdeclaration(char *, declaration *, int, char *);
d67 1
a67 1
	if (def->def_kind == DEF_PROGRAM)  /* handle data only */
d70 1
a70 1
	if (def->def_kind != DEF_CONST)
d72 1
d94 4
a97 3
		pxdrfuncdecl( def->def_name,
		    def->def_kind != DEF_TYPEDEF ||
		    !isvectordef(def->def.ty.old_type, def->def.ty.rel));
d111 1
a111 1
	}
d114 3
a116 4
void
pxdrfuncdecl(name, pointerp)
	char *name;
	int pointerp;
d119 11
a129 9
	f_print(fout,"#ifdef __cplusplus\n");
	f_print(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n",
	    name, name, pointerp ? ("*") : "");
	f_print(fout,"#elif defined(__STDC__)\n");
	f_print(fout, "extern  bool_t xdr_%s(XDR *, %s%s);\n",
	    name, name, pointerp ? ("*") : "");
	f_print(fout,"#else /* Old Style C */\n");
	f_print(fout, "bool_t xdr_%s();\n", name);
	f_print(fout,"#endif /* Old Style C */\n\n");
d133 1
a133 1
static void
d143 1
a143 1
static void
d152 1
d154 16
a169 10
		for(plist = vers->procs; plist != NULL; 
		    plist = plist->next) {
			if (!newstyle || plist->arg_num < 2) {
				continue; /* old style or single args */
			}
			name = plist->args.argname;
			f_print(fout, "struct %s {\n", name);
			for (l = plist->args.decls; 
			     l != NULL; l = l->next) {
				pdeclaration(name, &l->decl, 1, ";\n");
a170 4
			f_print(fout, "};\n");
			f_print(fout, "typedef struct %s %s;\n", name, name);
			pxdrfuncdecl(name, NULL);
			f_print(fout, "\n");
d172 1
a172 1
	}
d175 2
a176 1
static void
d180 1
a181 1
	decl_list *l;
d184 1
a184 1
	for (l = def->def.st.decls; l != NULL; l = l->next)
d186 1
d191 1
a191 1
static void
d208 2
a209 2
	  if (l->contflag == 0)
		pdeclaration(name, &l->case_decl, 2, ";\n");
d213 1
a213 1
		pdeclaration(name, decl, 2, ";\n");
d220 1
a220 1
static void
d228 1
a228 1
static void
d236 1
a236 1
static int
d257 1
a257 1
static void
d265 1
a265 1

d272 1
a272 1
			    locase(def->def_name), vers->vers_num);
d274 1
a274 1
			    locase(def->def_name), vers->vers_num);
d282 3
a284 2
		for(i=0; i<3; i++) {
			if (i==0) {
d286 2
a287 2
				ext = "extern \"C\" ";
			} else if (i==1) {
d289 2
a290 2
				ext = "extern  ";
			} else {
d292 1
a292 1
				ext = "extern  ";
d294 2
a295 1

d297 1
a297 1
				if (!define_printed(proc, def->def.pr.versions))
d299 1
d304 1
d306 1
a311 1
void
d315 1
a315 1
	char *addargtype;
d320 3
a322 3
	ptype(proc->res_prefix, proc->res_type, 1);
	f_print(fout, "* ");
	if (server_p)
d330 2
a331 2
	if (mode == 0 || mode == 1)
		parglist(proc, addargtype);
d336 1
d338 1
a338 1
static void
d341 1
a341 1
	char *addargtype;
d347 2
a348 2
	if (proc->arg_num < 2 && newstyle &&
	   streq(proc->args.decls->decl.type, "void")) {
d352 5
a356 4
			ptype(dl->decl.prefix, dl->decl.type, 1);
			if (!newstyle)
				f_print(fout, "*"); /* old style passes by reference */
			f_print(fout, ", ");
d359 1
d363 1
a363 1
static void
d395 1
a395 1
static void
d404 1
a441 1
void
d452 1
a452 1
	if (streq(dec->type, "void"))
d454 1
d496 1
a496 1
	f_print(fout, separator);
d499 1
a499 1
static int
@


1.6
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.4 1997/07/25 21:05:39 mickey Exp $	*/
d46 15
a60 12
static pconstdef __P((definition *));
static pargdef __P((definition *));
static pstructdef __P((definition *));
static puniondef __P((definition *));
static pprogramdef __P((definition *));
static penumdef __P((definition *));
static ptypedef __P((definition *));
static pdefine __P((char *, char *));
static puldefine __P((char *, char *));
static define_printed __P((proc_list *, version_list *));
static undefined2 __P((char *, char *));
static parglist __P((proc_list *, char *));
d70 1
a70 1
	if (def->def_kind == DEF_PROGRAM )  /* handle data only */
d73 1
a73 1
	if (def->def_kind != DEF_CONST) {
a74 1
	}
d96 3
a98 4
	  pxdrfuncdecl( def->def_name,
		       def->def_kind != DEF_TYPEDEF ||
		       !isvectordef(def->def.ty.old_type, def->def.ty.rel));

d112 1
a112 1
	      }
d115 4
a118 3
pxdrfuncdecl( name, pointerp )
char* name;
int pointerp;
d121 9
a129 11
  f_print(fout,"#ifdef __cplusplus\n");
    f_print(fout, "extern \"C\" bool_t xdr_%s(XDR *, %s%s);\n",
	name,
	name, pointerp ? ("*") : "");
  f_print(fout,"#elif defined(__STDC__)\n");
    f_print(fout, "extern  bool_t xdr_%s(XDR *, %s%s);\n",
	name,
	name, pointerp ? ("*") : "");
  f_print(fout,"#else /* Old Style C */\n");
    f_print(fout, "bool_t xdr_%s();\n", name);
  f_print(fout,"#endif /* Old Style C */\n\n");
d133 1
a133 1
static
d143 1
a143 1
static 
a151 1
	
d153 10
a162 16
			for(plist = vers->procs; plist != NULL; 
			    plist = plist->next) {
				
				if (!newstyle || plist->arg_num < 2) {
					continue; /* old style or single args */
				}
				name = plist->args.argname;
				f_print(fout, "struct %s {\n", name);
				for (l = plist->args.decls; 
				     l != NULL; l = l->next) {
					pdeclaration(name, &l->decl, 1, ";\n" );
				}
				f_print(fout, "};\n");
				f_print(fout, "typedef struct %s %s;\n", name, name);
				pxdrfuncdecl( name,NULL );
				f_print( fout, "\n" );
d164 4
d169 1
a169 1

d172 1
a172 2

static 
d176 1
a177 1
	char *name = def->def_name;
d180 1
a180 1
	for (l = def->def.st.decls; l != NULL; l = l->next) {
a181 1
	}
d186 1
a186 1
static
d203 2
a204 2
	  if(l->contflag == 0)
		pdeclaration(name, &l->case_decl, 2, ";\n" );
d208 1
a208 1
		pdeclaration(name, decl, 2, ";\n" );
d215 1
a215 1
static
d223 1
a223 1
static
d231 1
a231 1
static
d252 1
a252 1
static
d260 1
a260 1
	
d267 1
a267 1
				locase(def->def_name), vers->vers_num);
d269 1
a269 1
				locase(def->def_name), vers->vers_num);
d277 2
a278 3
		   
		for(i=0;i<3;i++){
			if(i==0){
d280 2
a281 2
				ext="extern \"C\" ";
			}else if ( i== 1){
d283 2
a284 2
				ext="extern  "  ;
			}else{
d286 1
a286 1
				ext="extern  ";
d288 1
a288 2
			
			
d290 1
a290 1
				if (!define_printed(proc, def->def.pr.versions)) {
a291 1
				}
a295 1
				
a296 1

d302 1
d306 1
a306 1
	char* addargtype;
d311 3
a313 3
	ptype( proc->res_prefix, proc->res_type, 1 );
	f_print( fout, "* " );
	if( server_p )
d321 2
a322 2
	if(mode == 0 || mode ==1) 
		parglist( proc, addargtype );
a326 1

d328 1
a328 1
static 
d331 1
a331 1
	char* addargtype;
d337 2
a338 2
	if( proc->arg_num < 2 && newstyle &&
	   streq( proc->args.decls->decl.type, "void")) {
d342 4
a345 5
			ptype( dl->decl.prefix, dl->decl.type, 1 );
			if( !newstyle )
				f_print( fout, "*" ); /* old style passes by reference */

			f_print( fout, ", " );
a347 1

d351 1
a351 1
static
d383 1
a383 1
static
a391 1

d429 1
d440 1
a440 1
	if (streq(dec->type, "void")) {
a441 1
	}
d483 1
a483 1
	f_print(fout, separator );
d486 1
a486 1
static
@


1.5
log
@-Wall cleanup; ok deraadt
@
text
@d46 12
a57 12
static void pconstdef __P((definition *));
static void pargdef __P((definition *));
static void pstructdef __P((definition *));
static void puniondef __P((definition *));
static void pprogramdef __P((definition *));
static void penumdef __P((definition *));
static void ptypedef __P((definition *));
static void pdefine __P((char *, char *));
static void puldefine __P((char *, char *));
static int define_printed __P((proc_list *, version_list *));
static int undefined2 __P((char *, char *));
static void parglist __P((proc_list *, char *));
d111 1
a111 7
	case DEF_CONST:
	case DEF_STRUCT:
	case DEF_UNION:
	case DEF_ENUM:
	case DEF_TYPEDEF:
		break;
	}
a113 1
void
d115 2
a116 2
	char* name;
	int pointerp;
d133 1
a133 1
static void
d143 1
a143 1
static void
d176 1
a176 1
static void
d191 1
a191 1
static void
d220 1
a220 1
static void
d228 1
a228 1
static void
d236 1
a236 1
static int
d257 1
a257 1
static void
a311 1
void
d338 1
a338 1
static void
d363 1
a363 1
static void
d395 1
a395 1
static void
a441 1
void
d499 1
a499 1
static int
@


1.4
log
@#if __STDC__ --> #ifdef __STDC__
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.3 1996/09/15 08:52:41 tholo Exp $	*/
d46 12
a57 12
static pconstdef __P((definition *));
static pargdef __P((definition *));
static pstructdef __P((definition *));
static puniondef __P((definition *));
static pprogramdef __P((definition *));
static penumdef __P((definition *));
static ptypedef __P((definition *));
static pdefine __P((char *, char *));
static puldefine __P((char *, char *));
static define_printed __P((proc_list *, version_list *));
static undefined2 __P((char *, char *));
static parglist __P((proc_list *, char *));
d111 7
a117 1
	      }
d120 1
d122 2
a123 2
char* name;
int pointerp;
d140 1
a140 1
static
d150 1
a150 1
static 
d183 1
a183 1
static 
d198 1
a198 1
static
d227 1
a227 1
static
d235 1
a235 1
static
d243 1
a243 1
static
d264 1
a264 1
static
d319 1
d346 1
a346 1
static 
d371 1
a371 1
static
d403 1
a403 1
static
d450 1
d508 1
a508 1
static
@


1.3
log
@Don't add a comma after the last entry in an enum
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.2 1996/06/26 05:38:36 deraadt Exp $	*/
d119 1
a119 1
  f_print(fout,"#ifdef __cplusplus \n");
d123 1
a123 1
  f_print(fout,"#elif __STDC__ \n");
d127 1
a127 1
  f_print(fout,"#else /* Old Style C */ \n");
d129 1
a129 1
  f_print(fout,"#endif /* Old Style C */ \n\n");
d288 1
a288 1
				f_print(fout,"\n#elif __STDC__\n");
d291 1
a291 1
				f_print(fout,"\n#else /* Old Style C */ \n");
d308 1
a308 1
		f_print(fout,"#endif /* Old Style C */ \n");
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_hout.c,v 1.4 1995/06/11 21:49:55 pk Exp $	*/
d386 4
a389 1
		f_print(fout, ",\n");
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
