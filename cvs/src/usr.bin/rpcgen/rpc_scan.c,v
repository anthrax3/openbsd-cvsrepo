head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.8
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.10
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.01.15.10.14.32;	author jasper;	state Exp;
branches;
next	1.18;
commitid	oNnDSVT5PSPEdENG;

1.18
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	0Dp7Dy9FuNZesYo2;

1.17
date	2013.11.28.18.24.54;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2012.12.05.23.20.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.22.18.20.31;	author dhill;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.30.20.57.27;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.39;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Add support for parsing 'hyper' and 'quad' types, as per RFC4506.
From FreeBSD

ok millert@@
@
text
@/*	$OpenBSD: rpc_scan.c,v 1.18 2015/08/20 22:32:41 deraadt Exp $	*/
/*	$NetBSD: rpc_scan.c,v 1.4 1995/06/11 21:50:02 pk Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_scan.c, Scanner for the RPC protocol compiler
 */
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include "rpc_scan.h"
#include "rpc_parse.h"
#include "rpc_util.h"

static void unget_token(token *tokp);
static void findstrconst(char **, char **);
static void findchrconst(char **, char **);
static void findconst(char **, char **);
static void findkind(char **, token *);
static int cppline(char *);
static int directive(char *);
static void printdirective(char *);
static void docppline(char *, int *, char **);

#define startcomment(where) (where[0] == '/' && where[1] == '*')
#define endcomment(where) (where[-1] == '*' && where[0] == '/')

static int pushed = 0;	/* is a token pushed */
static token lasttok;	/* last token, if pushed */

/*
 * scan expecting 1 given token
 */
void
scan(expect, tokp)
	tok_kind expect;
	token *tokp;
{
	get_token(tokp);
	if (tokp->kind != expect)
		expected1(expect);
}

/*
 * scan expecting any of the 2 given tokens
 */
void
scan2(expect1, expect2, tokp)
	tok_kind expect1;
	tok_kind expect2;
	token *tokp;
{
	get_token(tokp);
	if (tokp->kind != expect1 && tokp->kind != expect2)
		expected2(expect1, expect2);
}

/*
 * scan expecting any of the 3 given token
 */
void
scan3(expect1, expect2, expect3, tokp)
	tok_kind expect1;
	tok_kind expect2;
	tok_kind expect3;
	token *tokp;
{
	get_token(tokp);
	if (tokp->kind != expect1 && tokp->kind != expect2 &&
	    tokp->kind != expect3)
		expected3(expect1, expect2, expect3);
}

/*
 * scan expecting a constant, possibly symbolic
 */
void
scan_num(tokp)
	token *tokp;
{
	get_token(tokp);
	switch (tokp->kind) {
	case TOK_IDENT:
		break;
	default:
		error("constant or identifier expected");
	}
}

/*
 * Peek at the next token
 */
void
peek(tokp)
	token *tokp;
{
	get_token(tokp);
	unget_token(tokp);
}

/*
 * Peek at the next token and scan it if it matches what you expect
 */
int
peekscan(expect, tokp)
	tok_kind expect;
	token *tokp;
{
	peek(tokp);
	if (tokp->kind == expect) {
		get_token(tokp);
		return (1);
	}
	return (0);
}

/*
 * Get the next token, printing out any directive that are encountered.
 */
void
get_token(tokp)
	token *tokp;
{
	int commenting;

	if (pushed) {
		pushed = 0;
		*tokp = lasttok;
		return;
	}
	commenting = 0;
	for (;;) {
		if (*where == 0) {
			for (;;) {
				if (!fgets(curline, MAXLINESIZE, fin)) {
					tokp->kind = TOK_EOF;
					*where = 0;
					return;
				}
				linenum++;
				if (commenting) {
					break;
				} else if (cppline(curline)) {
					docppline(curline, &linenum,
					    &infilename);
				} else if (directive(curline)) {
					printdirective(curline);
				} else {
					break;
				}
			}
			where = curline;
		} else if (isspace((unsigned char)*where)) {
			while (isspace((unsigned char)*where)) {
				where++;	/* eat */
			}
		} else if (commenting) {
			for (where++; *where; where++) {
				if (endcomment(where)) {
					where++;
					commenting--;
					break;
				}
			}
		} else if (startcomment(where)) {
			where += 2;
			commenting++;
		} else {
			break;
		}
	}

	/*
	 * 'where' is not whitespace, comment or directive Must be a token!
	 */
	switch (*where) {
	case ':':
		tokp->kind = TOK_COLON;
		where++;
		break;
	case ';':
		tokp->kind = TOK_SEMICOLON;
		where++;
		break;
	case ',':
		tokp->kind = TOK_COMMA;
		where++;
		break;
	case '=':
		tokp->kind = TOK_EQUAL;
		where++;
		break;
	case '*':
		tokp->kind = TOK_STAR;
		where++;
		break;
	case '[':
		tokp->kind = TOK_LBRACKET;
		where++;
		break;
	case ']':
		tokp->kind = TOK_RBRACKET;
		where++;
		break;
	case '{':
		tokp->kind = TOK_LBRACE;
		where++;
		break;
	case '}':
		tokp->kind = TOK_RBRACE;
		where++;
		break;
	case '(':
		tokp->kind = TOK_LPAREN;
		where++;
		break;
	case ')':
		tokp->kind = TOK_RPAREN;
		where++;
		break;
	case '<':
		tokp->kind = TOK_LANGLE;
		where++;
		break;
	case '>':
		tokp->kind = TOK_RANGLE;
		where++;
		break;

	case '"':
		tokp->kind = TOK_STRCONST;
		findstrconst(&where, &tokp->str);
		break;
	case '\'':
		tokp->kind = TOK_CHARCONST;
		findchrconst(&where, &tokp->str);
		break;

	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		tokp->kind = TOK_IDENT;
		findconst(&where, &tokp->str);
		break;

	default:
		if (!(isalpha((unsigned char)*where) || *where == '_')) {
			char buf[100], chs[20];

			if (isprint((unsigned char)*where)) {
				snprintf(chs, sizeof chs, "%c", *where);
			} else {
				snprintf(chs, sizeof chs, "%d", *where);
			}

			snprintf(buf, sizeof buf,
			    "illegal character in file: %s", chs);
			error(buf);
		}
		findkind(&where, tokp);
		break;
	}
}

static void
unget_token(tokp)
	token *tokp;
{
	lasttok = *tokp;
	pushed = 1;
}

static void
findstrconst(str, val)
	char **str;
	char **val;
{
	char *p;
	int size;

	p = *str;
	do {
		p++;
	} while (*p && *p != '"');
	if (*p == 0) {
		error("unterminated string constant");
	}
	p++;
	size = p - *str;
	*val = malloc(size + 1);
	if (val == NULL)
		error("alloc failed");
	(void) strncpy(*val, *str, size);
	(*val)[size] = 0;
	*str = p;
}

static void
findchrconst(str, val)
	char **str;
	char **val;
{
	char *p;
	int size;

	p = *str;
	do {
		p++;
	} while (*p && *p != '\'');
	if (*p == 0) {
		error("unterminated string constant");
	}
	p++;
	size = p - *str;
	if (size != 3) {
		error("empty char string");
	}
	*val = malloc(size + 1);
	if (val == NULL)
		error("alloc failed");
	(void) strncpy(*val, *str, size);
	(*val)[size] = 0;
	*str = p;
}

static void
findconst(str, val)
	char **str;
	char **val;
{
	char *p;
	int size;

	p = *str;
	if (*p == '0' && *(p + 1) == 'x') {
		p++;
		do {
			p++;
		} while (isxdigit((unsigned char)*p));
	} else {
		do {
			p++;
		} while (isdigit((unsigned char)*p));
	}
	size = p - *str;
	*val = malloc(size + 1);
	if (val == NULL)
		error("alloc failed");
	(void) strncpy(*val, *str, size);
	(*val)[size] = 0;
	*str = p;
}

static token symbols[] = {
	{TOK_CONST, "const"},
	{TOK_UNION, "union"},
	{TOK_SWITCH, "switch"},
	{TOK_CASE, "case"},
	{TOK_DEFAULT, "default"},
	{TOK_STRUCT, "struct"},
	{TOK_TYPEDEF, "typedef"},
	{TOK_ENUM, "enum"},
	{TOK_OPAQUE, "opaque"},
	{TOK_BOOL, "bool"},
	{TOK_VOID, "void"},
	{TOK_CHAR, "char"},
	{TOK_INT, "int"},
	{TOK_UNSIGNED, "unsigned"},
	{TOK_SHORT, "short"},
	{TOK_LONG, "long"},
	{TOK_HYPER, "hyper"},
	{TOK_FLOAT, "float"},
	{TOK_DOUBLE, "double"},
	{TOK_QUAD, "quadruple"},
	{TOK_STRING, "string"},
	{TOK_PROGRAM, "program"},
	{TOK_VERSION, "version"},
	{TOK_EOF, "??????"},
};

static void
findkind(mark, tokp)
	char **mark;
	token *tokp;
{
	int len;
	token *s;
	char *str;

	str = *mark;
	for (s = symbols; s->kind != TOK_EOF; s++) {
		len = strlen(s->str);
		if (strncmp(str, s->str, len) == 0) {
			if (!isalnum((unsigned char)str[len]) &&
			    str[len] != '_') {
				tokp->kind = s->kind;
				tokp->str = s->str;
				*mark = str + len;
				return;
			}
		}
	}
	tokp->kind = TOK_IDENT;
	for (len = 0; isalnum((unsigned char)str[len]) || str[len] == '_';
	    len++)
		;
	tokp->str = malloc(len + 1);
	if (tokp->str == NULL)
		error("alloc failed");
	(void) strncpy(tokp->str, str, len);
	tokp->str[len] = 0;
	*mark = str + len;
}

static int
cppline(line)
	char *line;
{
	return (line == curline && *line == '#');
}

static int
directive(line)
	char *line;
{
	return (line == curline && *line == '%');
}

static void
printdirective(line)
	char *line;
{
	fprintf(fout, "%s", line + 1);
}

static void
docppline(line, lineno, fname)
	char *line;
	int *lineno;
	char **fname;
{
	char *file;
	int num;
	char *p;

	line++;
	while (isspace((unsigned char)*line)) {
		line++;
	}
	num = atoi(line);
	while (isdigit((unsigned char)*line)) {
		line++;
	}
	while (isspace((unsigned char)*line)) {
		line++;
	}
	if (*line != '"') {
		error("preprocessor error");
	}
	line++;
	p = file = malloc(strlen(line) + 1);
	if (p == NULL)
		error("alloc failed");
	while (*line && *line != '"') {
		*p++ = *line++;
	}
	if (*line == 0) {
		error("preprocessor error");
	}
	*p = 0;
	if (*file == 0) {
		*fname = NULL;
		free(file);
	} else {
		*fname = file;
	}
	*lineno = num - 1;
}
@


1.18
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.17 2013/11/28 18:24:54 deraadt Exp $	*/
d410 1
d413 1
@


1.17
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.16 2012/12/05 23:20:26 deraadt Exp $	*/
d329 1
a329 1
	*val = alloc(size + 1);
d357 1
a357 1
	*val = alloc(size + 1);
d385 1
a385 1
	*val = alloc(size + 1);
d444 1
a444 1
	tokp->str = alloc(len + 1);
d498 1
a498 1
	p = file = alloc(strlen(line) + 1);
@


1.16
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.15 2010/09/01 14:43:34 millert Exp $	*/
d184 2
a185 2
		} else if (isspace(*where)) {
			while (isspace(*where)) {
d286 1
a286 1
		if (!(isalpha(*where) || *where == '_')) {
d289 1
a289 1
			if (isprint(*where)) {
d378 1
a378 1
		} while (isxdigit(*p));
d382 1
a382 1
		} while (isdigit(*p));
d431 2
a432 1
			if (!isalnum(str[len]) && str[len] != '_') {
d441 3
a443 1
	for (len = 0; isalnum(str[len]) || str[len] == '_'; len++);
d484 1
a484 1
	while (isspace(*line)) {
d488 1
a488 1
	while (isdigit(*line)) {
d491 1
a491 1
	while (isspace(*line)) {
@


1.15
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.14 2009/10/27 23:59:42 deraadt Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.13 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 15
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d7 3
a9 3
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
d11 9
a19 3
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
d21 12
a32 3
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a36 1
 * Copyright (C) 1987, Sun Microsystems, Inc.
@


1.13
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.12 2006/03/22 18:20:31 dhill Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_scan.c 1.11 89/02/22 (C) 1987 SMI";
#endif
@


1.12
log
@NetBSD  - plug leak in generate_guard()
        - plug leak in h_output(), coverity cid 100
NetBSD plug leak, coverity cid 98.
NetBSD plug leak, coverity cid 94.

ok ray@@ jaredy@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.11 2003/03/30 20:57:27 deraadt Exp $	*/
d34 1
a34 1
static char sccsid[] = "@@(#)rpc_scan.c 1.11 89/02/22 (C) 1987 SMI";
@


1.11
log
@snprintf; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.10 2002/07/05 05:39:42 deraadt Exp $	*/
d511 1
@


1.10
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.9 2002/06/01 01:40:38 deraadt Exp $	*/
d291 1
a291 2
			char buf[100];
			char *p;
a292 2
			snprintf(buf, sizeof buf, "illegal character in file: ");
			p = buf + strlen(buf);
d294 1
a294 1
				sprintf(p, "%c", *where);
d296 1
a296 1
				sprintf(p, "%d", *where);
d298 3
@


1.9
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.8 2002/02/16 21:27:51 millert Exp $	*/
d50 9
a58 9
static unget_token(token *tokp);
static findstrconst(char **, char **);
static findchrconst(char **, char **);
static findconst(char **, char **);
static findkind(char **, token *);
static cppline(char *);
static directive(char *);
static printdirective(char *);
static docppline(char *, int *, char **);
d308 1
a308 1
static
d316 1
a316 1
static
d326 1
a326 1
		*p++;
d334 2
d341 1
a341 1
static
d351 1
a351 1
		*p++;
d362 2
d369 1
a369 1
static
d390 2
d422 1
a422 1
static
d446 2
d453 1
a453 1
static
d460 1
a460 1
static
d467 1
a467 1
static
d474 1
a474 1
static
d500 2
@


1.8
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.7 2001/12/05 09:50:31 deraadt Exp $	*/
d294 1
a294 1
			s_print(buf, "illegal character in file: ");
d297 1
a297 1
				s_print(p, "%c", *where);
d299 1
a299 1
				s_print(p, "%d", *where);
d463 1
a463 1
	f_print(fout, "%s", line + 1);
@


1.7
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.5 2001/11/24 19:17:47 deraadt Exp $	*/
d50 9
a58 9
static unget_token __P((token *tokp));
static findstrconst __P((char **, char **));
static findchrconst __P((char **, char **));
static findconst __P((char **, char **));
static findkind __P((char **, token *));
static cppline __P((char *));
static directive __P((char *));
static printdirective __P((char *));
static docppline __P((char *, int *, char **));
@


1.6
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.4 2001/07/18 22:26:00 deraadt Exp $	*/
d38 2
a39 2
 * rpc_scan.c, Scanner for the RPC protocol compiler 
 * Copyright (C) 1987, Sun Microsystems, Inc. 
d67 1
a67 1
 * scan expecting 1 given token 
d75 1
a75 1
	if (tokp->kind != expect) {
a76 1
	}
d80 1
a80 1
 * scan expecting any of the 2 given tokens 
d89 1
a89 1
	if (tokp->kind != expect1 && tokp->kind != expect2) {
a90 1
	}
d94 1
a94 1
 * scan expecting any of the 3 given token 
d104 2
a105 2
	if (tokp->kind != expect1 && tokp->kind != expect2
	    && tokp->kind != expect3) {
a106 1
	}
d110 1
a110 1
 * scan expecting a constant, possibly symbolic 
d126 1
a126 1
 * Peek at the next token 
d137 1
a137 1
 * Peek at the next token and scan it if it matches what you expect 
d153 1
a153 1
 * Get the next token, printing out any directive that are encountered. 
d179 2
a180 2
					docppline(curline, &linenum, 
						  &infilename);
d209 1
a209 1
	 * 'where' is not whitespace, comment or directive Must be a token! 
d392 22
a413 22
			  {TOK_CONST, "const"},
			  {TOK_UNION, "union"},
			  {TOK_SWITCH, "switch"},
			  {TOK_CASE, "case"},
			  {TOK_DEFAULT, "default"},
			  {TOK_STRUCT, "struct"},
			  {TOK_TYPEDEF, "typedef"},
			  {TOK_ENUM, "enum"},
			  {TOK_OPAQUE, "opaque"},
			  {TOK_BOOL, "bool"},
			  {TOK_VOID, "void"},
			  {TOK_CHAR, "char"},
			  {TOK_INT, "int"},
			  {TOK_UNSIGNED, "unsigned"},
			  {TOK_SHORT, "short"},
			  {TOK_LONG, "long"},
			  {TOK_FLOAT, "float"},
			  {TOK_DOUBLE, "double"},
			  {TOK_STRING, "string"},
			  {TOK_PROGRAM, "program"},
			  {TOK_VERSION, "version"},
			  {TOK_EOF, "??????"},
@


1.5
log
@half finished KNF
@
text
@d38 2
a39 2
 * rpc_scan.c, Scanner for the RPC protocol compiler
 * Copyright (C) 1987, Sun Microsystems, Inc.
d67 1
a67 1
 * scan expecting 1 given token
d75 1
a75 1
	if (tokp->kind != expect)
d77 1
d81 1
a81 1
 * scan expecting any of the 2 given tokens
d90 1
a90 1
	if (tokp->kind != expect1 && tokp->kind != expect2)
d92 1
d96 1
a96 1
 * scan expecting any of the 3 given token
d106 2
a107 2
	if (tokp->kind != expect1 && tokp->kind != expect2 &&
	    tokp->kind != expect3)
d109 1
d113 1
a113 1
 * scan expecting a constant, possibly symbolic
d129 1
a129 1
 * Peek at the next token
d140 1
a140 1
 * Peek at the next token and scan it if it matches what you expect
d156 1
a156 1
 * Get the next token, printing out any directive that are encountered.
d182 2
a183 2
					docppline(curline, &linenum,
					    &infilename);
d212 1
a212 1
	 * 'where' is not whitespace, comment or directive Must be a token!
d395 22
a416 22
	{TOK_CONST, "const"},
	{TOK_UNION, "union"},
	{TOK_SWITCH, "switch"},
	{TOK_CASE, "case"},
	{TOK_DEFAULT, "default"},
	{TOK_STRUCT, "struct"},
	{TOK_TYPEDEF, "typedef"},
	{TOK_ENUM, "enum"},
	{TOK_OPAQUE, "opaque"},
	{TOK_BOOL, "bool"},
	{TOK_VOID, "void"},
	{TOK_CHAR, "char"},
	{TOK_INT, "int"},
	{TOK_UNSIGNED, "unsigned"},
	{TOK_SHORT, "short"},
	{TOK_LONG, "long"},
	{TOK_FLOAT, "float"},
	{TOK_DOUBLE, "double"},
	{TOK_STRING, "string"},
	{TOK_PROGRAM, "program"},
	{TOK_VERSION, "version"},
	{TOK_EOF, "??????"},
@


1.4
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.2 1996/06/26 05:38:39 deraadt Exp $	*/
d38 2
a39 2
 * rpc_scan.c, Scanner for the RPC protocol compiler 
 * Copyright (C) 1987, Sun Microsystems, Inc. 
d67 1
a67 1
 * scan expecting 1 given token 
d75 1
a75 1
	if (tokp->kind != expect) {
a76 1
	}
d80 1
a80 1
 * scan expecting any of the 2 given tokens 
d89 1
a89 1
	if (tokp->kind != expect1 && tokp->kind != expect2) {
a90 1
	}
d94 1
a94 1
 * scan expecting any of the 3 given token 
d104 2
a105 2
	if (tokp->kind != expect1 && tokp->kind != expect2
	    && tokp->kind != expect3) {
a106 1
	}
d110 1
a110 1
 * scan expecting a constant, possibly symbolic 
d126 1
a126 1
 * Peek at the next token 
d137 1
a137 1
 * Peek at the next token and scan it if it matches what you expect 
d153 1
a153 1
 * Get the next token, printing out any directive that are encountered. 
d179 2
a180 2
					docppline(curline, &linenum, 
						  &infilename);
d209 1
a209 1
	 * 'where' is not whitespace, comment or directive Must be a token! 
d392 22
a413 22
			  {TOK_CONST, "const"},
			  {TOK_UNION, "union"},
			  {TOK_SWITCH, "switch"},
			  {TOK_CASE, "case"},
			  {TOK_DEFAULT, "default"},
			  {TOK_STRUCT, "struct"},
			  {TOK_TYPEDEF, "typedef"},
			  {TOK_ENUM, "enum"},
			  {TOK_OPAQUE, "opaque"},
			  {TOK_BOOL, "bool"},
			  {TOK_VOID, "void"},
			  {TOK_CHAR, "char"},
			  {TOK_INT, "int"},
			  {TOK_UNSIGNED, "unsigned"},
			  {TOK_SHORT, "short"},
			  {TOK_LONG, "long"},
			  {TOK_FLOAT, "float"},
			  {TOK_DOUBLE, "double"},
			  {TOK_STRING, "string"},
			  {TOK_PROGRAM, "program"},
			  {TOK_VERSION, "version"},
			  {TOK_EOF, "??????"},
@


1.3
log
@-Wall cleanup; ok deraadt
@
text
@d50 9
a58 9
static void unget_token __P((token *tokp));
static void findstrconst __P((char **, char **));
static void findchrconst __P((char **, char **));
static void findconst __P((char **, char **));
static void findkind __P((char **, token *));
static int cppline __P((char *));
static int directive __P((char *));
static void printdirective __P((char *));
static void docppline __P((char *, int *, char **));
d311 1
a311 1
static void
d319 1
a319 1
static void
d329 1
a329 1
		p++;
d342 1
a342 1
static void
d352 1
a352 1
		p++;
d368 1
a368 1
static void
d419 1
a419 1
static void
d448 1
a448 1
static int
d455 1
a455 1
static int
d462 1
a462 1
static void
d469 1
a469 1
static void
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_scan.c,v 1.4 1995/06/11 21:50:02 pk Exp $	*/
d50 9
a58 9
static unget_token __P((token *tokp));
static findstrconst __P((char **, char **));
static findchrconst __P((char **, char **));
static findconst __P((char **, char **));
static findkind __P((char **, token *));
static cppline __P((char *));
static directive __P((char *));
static printdirective __P((char *));
static docppline __P((char *, int *, char **));
d311 1
a311 1
static
d319 1
a319 1
static
d329 1
a329 1
		*p++;
d342 1
a342 1
static
d352 1
a352 1
		*p++;
d368 1
a368 1
static
d419 1
a419 1
static
d448 1
a448 1
static
d455 1
a455 1
static
d462 1
a462 1
static
d469 1
a469 1
static
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
