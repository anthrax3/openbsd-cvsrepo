head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.2
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.12
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.10
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.01.21.08.33.07;	author krw;	state Exp;
branches;
next	1.32;
commitid	l2fu419jw6ah0BY2;

1.32
date	2015.11.11.02.52.46;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	6fvHpVQjE6wYuHzb;

1.31
date	2015.10.10.20.57.00;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	zox6M3mR14SDJyc4;

1.30
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	0Dp7Dy9FuNZesYo2;

1.29
date	2015.01.16.06.40.11;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Uu5nFG3wCl0LACBb;

1.28
date	2014.11.18.20.54.28;	author krw;	state Exp;
branches;
next	1.27;
commitid	yCis8OrOsfixbKpI;

1.27
date	2013.11.28.18.24.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.10.27.18.31.24;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.03.14.52.31;	author weingart;	state Exp;
branches;
next	1.22;

1.22
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.22.18.20.31;	author dhill;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.09.22.22.45;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.09.03.35.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.14.19.59.36;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.14.19.45.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.14.04.51.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.27.03.14.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.07.18.44.28;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.21.22.02.52;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.12.04.21.58.31;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.11.21.10.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.27.19.32.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Nuke whitespace foolish enough to expose itself during the great
"warning:" rectification.
@
text
@/* $OpenBSD: rpc_main.c,v 1.32 2015/11/11 02:52:46 deraadt Exp $	 */
/* $NetBSD: rpc_main.c,v 1.9 1996/02/19 11:12:43 pk Exp $	 */

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_main.c, Top level of the RPC protocol compiler.
 */

#define RPCGEN_VERSION	"199506"/* This program's version (year & month) */

#include <sys/types.h>
#include <sys/file.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>
#include <ctype.h>
#include <sys/stat.h>
#include "rpc_parse.h"
#include "rpc_util.h"
#include "rpc_scan.h"

#define EXTEND	1		/* alias for TRUE */
#define DONT_EXTEND	0	/* alias for FALSE */

#define SVR4_CPP "/usr/ccs/lib/cpp"
#define SUNOS_CPP "/lib/cpp"
static int      cppDefined = 0;	/* explicit path for C preprocessor */

struct commandline {
	int cflag;	/* xdr C routines */
	int hflag;	/* header file */
	int lflag;	/* client side stubs */
	int mflag;	/* server side stubs */
	int nflag;	/* netid flag */
	int sflag;	/* server stubs for the given transport */
	int tflag;	/* dispatch Table file */
	int Ssflag;	/* produce server sample code */
	int Scflag;	/* produce client sample code */
	char *infile;	/* input module name */
	char *outfile;/* output module name */
};

static char    *cmdname;

static char    *svcclosetime = "120";
static char    *CPP = "/usr/bin/cpp";
static char     CPPFLAGS[] = "-C";
static char     pathbuf[PATH_MAX];
static char    *allv[] = {
	"rpcgen", "-s", "udp", "-s", "tcp",
};
static int      allc = sizeof(allv) / sizeof(allv[0]);
static char    *allnv[] = {
	"rpcgen", "-s", "netpath",
};
static int      allnc = sizeof(allnv) / sizeof(allnv[0]);

#define ARGLISTLEN	20
#define FIXEDARGS         2

static char    *arglist[ARGLISTLEN];
static int      argcount = FIXEDARGS;


int             nonfatalerrors;	/* errors */
int             inetdflag /* = 1 */ ;	/* Support for inetd *//* is now the
					 * default */
int             pmflag;		/* Support for port monitors */
int             logflag;	/* Use syslog instead of fprintf for errors */
int             tblflag;	/* Support for dispatch table file */
int             callerflag;	/* Generate svc_caller() function */

#define INLINE 3
/* length at which to start doing an inline */

int doinline = INLINE;	/* length at which to start doing an
			 * inline. 3 = default if 0, no
			 * xdr_inline code */

int indefinitewait;	/* If started by port monitors, hang till it
			 * wants */
int exitnow;	/* If started by port monitors, exit after
		 * the call */
int timerflag;	/* TRUE if !indefinite && !exitnow */
int newstyle;	/* newstyle of passing arguments (by value) */
int Cflag = 0;	/* ANSI C syntax */
static int allfiles;	/* generate all files */
int tirpcflag = 0;	/* generating code for tirpc, by default */

static void c_output(char *, char *, int, char *);
static void h_output(char *, char *, int, char *);
static void s_output(int, char **, char *, char *, int, char *, int, int);
static void l_output(char *, char *, int, char *);
static void t_output(char *, char *, int, char *);
static void svc_output(char *, char *, int, char *);
static void clnt_output(char *, char *, int, char *);
static int do_registers(int, char **);
static void addarg(char *);
static void putarg(int, char *);
static void clear_args(void);
static void checkfiles(char *, char *);
static int parseargs(int, char **, struct commandline *);
static void usage(void);
void c_initialize(void);

int
main(int argc, char *argv[])
{
	struct commandline cmd;

	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1) {
		perror("pledge");
		exit(1);
	}

	(void) memset((char *) &cmd, 0, sizeof(struct commandline));
	clear_args();
	if (!parseargs(argc, argv, &cmd))
		usage();

	if (cmd.cflag || cmd.hflag || cmd.lflag || cmd.tflag || cmd.sflag ||
	    cmd.mflag || cmd.nflag || cmd.Ssflag || cmd.Scflag) {
		checkfiles(cmd.infile, cmd.outfile);
	} else
		checkfiles(cmd.infile, NULL);

	if (cmd.cflag) {
		c_output(cmd.infile, "-DRPC_XDR", DONT_EXTEND, cmd.outfile);
	} else if (cmd.hflag) {
		h_output(cmd.infile, "-DRPC_HDR", DONT_EXTEND, cmd.outfile);
	} else if (cmd.lflag) {
		l_output(cmd.infile, "-DRPC_CLNT", DONT_EXTEND, cmd.outfile);
	} else if (cmd.sflag || cmd.mflag || (cmd.nflag)) {
		s_output(argc, argv, cmd.infile, "-DRPC_SVC", DONT_EXTEND,
			 cmd.outfile, cmd.mflag, cmd.nflag);
	} else if (cmd.tflag) {
		t_output(cmd.infile, "-DRPC_TBL", DONT_EXTEND, cmd.outfile);
	} else if (cmd.Ssflag) {
		svc_output(cmd.infile, "-DRPC_SERVER", DONT_EXTEND, cmd.outfile);
	} else if (cmd.Scflag) {
		clnt_output(cmd.infile, "-DRPC_CLIENT", DONT_EXTEND, cmd.outfile);
	} else {
		/* the rescans are required, since cpp may effect input */
		c_output(cmd.infile, "-DRPC_XDR", EXTEND, "_xdr.c");
		reinitialize();
		h_output(cmd.infile, "-DRPC_HDR", EXTEND, ".h");
		reinitialize();
		l_output(cmd.infile, "-DRPC_CLNT", EXTEND, "_clnt.c");
		reinitialize();
		if (inetdflag || !tirpcflag)
			s_output(allc, allv, cmd.infile, "-DRPC_SVC", EXTEND,
			    "_svc.c", cmd.mflag, cmd.nflag);
		else
			s_output(allnc, allnv, cmd.infile, "-DRPC_SVC",
			    EXTEND, "_svc.c", cmd.mflag, cmd.nflag);
		if (tblflag) {
			reinitialize();
			t_output(cmd.infile, "-DRPC_TBL", EXTEND, "_tbl.i");
		}
		if (allfiles) {
			reinitialize();
			svc_output(cmd.infile, "-DRPC_SERVER", EXTEND, "_server.c");
		}
		if (allfiles) {
			reinitialize();
			clnt_output(cmd.infile, "-DRPC_CLIENT", EXTEND, "_client.c");
		}
	}
	exit(nonfatalerrors);
	/* NOTREACHED */
}

/*
 * add extension to filename
 */
static char *
extendfile(char *path, char *ext)
{
	char *file;
	char *res;
	char *p;
	size_t len;

	if ((file = strrchr(path, '/')) == NULL)
		file = path;
	else
		file++;

	len = strlen(file) + strlen(ext) + 1;
	res = malloc(len);
	if (res == NULL) {
		fprintf(stderr, "could not allocate memory\n");
		exit(1);
	}
	p = strrchr(file, '.');
	if (p == NULL)
		p = file + strlen(file);
	(void) strlcpy(res, file, len);
	(void) strlcpy(res + (p - file), ext, len - (p - file));
	return (res);
}

/*
 * Open output file with given extension
 */
static void
open_output(char *infile, char *outfile)
{

	if (outfile == NULL) {
		fout = stdout;
		return;
	}
	if (infile != NULL && streq(outfile, infile)) {
		fprintf(stderr, "%s: output would overwrite %s\n", cmdname,
		    infile);
		crash();
	}
	fout = fopen(outfile, "w");
	if (fout == NULL) {
		fprintf(stderr, "%s: unable to open ", cmdname);
		perror(outfile);
		crash();
	}
	record_open(outfile);

}

static void
add_warning(void)
{
	fprintf(fout, "/*\n");
	fprintf(fout, " * Please do not edit this file.\n");
	fprintf(fout, " * It was generated using rpcgen.\n");
	fprintf(fout, " */\n\n");
}

/* clear list of arguments */
static void
clear_args(void)
{
	int             i;
	for (i = FIXEDARGS; i < ARGLISTLEN; i++)
		arglist[i] = NULL;
	argcount = FIXEDARGS;
}

/* make sure that a CPP exists */
static void
find_cpp(void)
{
	struct stat     buf;

	/* SVR4 or explicit cpp does not exist */
	if (stat(CPP, &buf) < 0) {
		if (cppDefined) {
			fprintf(stderr, "cannot find C preprocessor: %s \n", CPP);
			crash();
		} else {
			/* try the other one */
			CPP = SUNOS_CPP;
			if (stat(CPP, &buf) < 0) {	/* can't find any cpp */
				fprintf(stderr,
				    "cannot find any C preprocessor: %s\n", CPP);
				crash();
			}
		}
	}
}

/*
 * Open input file with given define for C-preprocessor
 */
static void
open_input(char *infile, char *define)
{
	int             pd[2];

	infilename = (infile == NULL) ? "<stdin>" : infile;
	(void) pipe(pd);
	switch (fork()) {
	case 0:
		find_cpp();
		putarg(0, CPP);
		putarg(1, CPPFLAGS);
		addarg(define);
		addarg(infile);
		addarg((char *) NULL);
		(void) close(1);
		(void) dup2(pd[1], 1);
		(void) close(pd[0]);
		execv(arglist[0], arglist);
		perror("execv");
		exit(1);
	case -1:
		perror("fork");
		exit(1);
	}
	(void) close(pd[1]);
	fin = fdopen(pd[0], "r");
	if (fin == NULL) {
		fprintf(stderr, "%s: ", cmdname);
		perror(infilename);
		crash();
	}
}

/* valid tirpc nettypes */
static char    *valid_ti_nettypes[] = {
	"netpath",
	"visible",
	"circuit_v",
	"datagram_v",
	"circuit_n",
	"datagram_n",
	"udp",
	"tcp",
	"raw",
	NULL
};

/* valid inetd nettypes */
static char    *valid_i_nettypes[] = {
	"udp",
	"tcp",
	NULL
};

static int
check_nettype(char *name, char *list_to_check[])
{
	int             i;
	for (i = 0; list_to_check[i] != NULL; i++) {
		if (strcmp(name, list_to_check[i]) == 0)
			return 1;
	}
	fprintf(stderr, "illegal nettype :\'%s\'\n", name);
	return 0;
}

/*
 * Compile into an XDR routine output file
 */

static void
c_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	definition     *def;
	char           *include;
	char           *outfilename;
	long            tell;

	c_initialize();
	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	open_output(infile, outfilename);
	add_warning();
	if (infile && (include = extendfile(infile, ".h"))) {
		fprintf(fout, "#include \"%s\"\n", include);
		free(include);
		/* .h file already contains rpc/rpc.h */
	} else
		fprintf(fout, "#include <rpc/rpc.h>\n");
	tell = ftell(fout);
	while ((def = get_definition())) {
		emit(def);
	}
	if (extend && tell == ftell(fout)) {
		(void) unlink(outfilename);
	}
}


void
c_initialize(void)
{

	/* add all the starting basic types */

	add_type(1, "int");
	add_type(1, "long");
	add_type(1, "short");
	add_type(1, "bool");

	add_type(1, "u_int");
	add_type(1, "u_long");
	add_type(1, "u_short");

}

static const char rpcgen_table_dcl[] = "struct rpcgen_table {\n\
	char	*(*proc)();\n\
	xdrproc_t	xdr_arg;\n\
	unsigned int	len_arg;\n\
	xdrproc_t	xdr_res;\n\
	unsigned int	len_res;\n\
};\n";


static char *
generate_guard(char *pathname)
{
	char           *filename, *guard, *tmp, *tmp2;

	filename = strrchr(pathname, '/');	/* find last component */
	filename = ((filename == 0) ? pathname : filename + 1);
	guard = strdup(filename);
	if (guard == NULL) {
		fprintf(stderr, "out of memory while processing %s\n", filename);
		crash();
	}

	/* convert to upper case */
	tmp = guard;
	while (*tmp) {
		if (islower((unsigned char)*tmp))
			*tmp = toupper((unsigned char)*tmp);
		tmp++;
	}

	tmp2 = extendfile(guard, "_H_RPCGEN");
	free(guard);
	guard = tmp2;

	return (guard);
}

/*
 * Compile into an XDR header file
 */

static void
h_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	definition     *def;
	char           *outfilename;
	long            tell;
	char           *guard;
	list           *l;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	open_output(infile, outfilename);
	add_warning();
	guard = generate_guard(outfilename ? outfilename : infile);

	fprintf(fout, "#ifndef _%s\n#define _%s\n\n", guard,
		guard);

	fprintf(fout, "#define RPCGEN_VERSION\t%s\n\n", RPCGEN_VERSION);
	fprintf(fout, "#include <rpc/rpc.h>\n\n");

	tell = ftell(fout);
	/* print data definitions */
	while ((def = get_definition())) {
		print_datadef(def);
	}

	/*
	 * print function declarations. Do this after data definitions
	 * because they might be used as arguments for functions
	 */
	for (l = defined; l != NULL; l = l->next) {
		print_funcdef(l->val);
	}
	if (extend && tell == ftell(fout)) {
		(void) unlink(outfilename);
	} else if (tblflag) {
		fprintf(fout, rpcgen_table_dcl);
	}
	fprintf(fout, "\n#endif /* !_%s */\n", guard);

	free(guard);
}

/*
 * Compile into an RPC service
 */
static void
s_output(argc, argv, infile, define, extend, outfile, nomain, netflag)
	int             argc;
	char           *argv[];
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
	int             nomain;
	int             netflag;
{
	char           *include;
	definition     *def;
	int             foundprogram = 0;
	char           *outfilename;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	open_output(infile, outfilename);
	add_warning();
	if (infile && (include = extendfile(infile, ".h"))) {
		fprintf(fout, "#include \"%s\"\n", include);
		free(include);
	} else
		fprintf(fout, "#include <rpc/rpc.h>\n");

	fprintf(fout, "#include <unistd.h>\n");
	fprintf(fout, "#include <stdio.h>\n");
	fprintf(fout, "#include <stdlib.h>/* getenv, exit */\n");
	if (Cflag) {
		fprintf(fout,
			"#include <rpc/pmap_clnt.h> /* for pmap_unset */\n");
		fprintf(fout, "#include <string.h> /* strcmp */ \n");
	}
	fprintf(fout, "#include <netdb.h>\n");	/* evas */
	if (strcmp(svcclosetime, "-1") == 0)
		indefinitewait = 1;
	else if (strcmp(svcclosetime, "0") == 0)
		exitnow = 1;
	else if (inetdflag || pmflag) {
		fprintf(fout, "#include <signal.h>\n");
		timerflag = 1;
	}
	if (!tirpcflag && inetdflag)
		fprintf(fout, "#include <sys/ttycom.h>/* TIOCNOTTY */\n");
	if (Cflag && (inetdflag || pmflag)) {
		fprintf(fout, "#ifdef __cplusplus\n");
		fprintf(fout, "#include <sysent.h> /* getdtablesize, open */\n");
		fprintf(fout, "#endif /* __cplusplus */\n");

		if (tirpcflag)
			fprintf(fout, "#include <unistd.h> /* setsid */\n");
	}
	if (tirpcflag)
		fprintf(fout, "#include <sys/types.h>\n");

	fprintf(fout, "#include <memory.h>\n");
	if (tirpcflag)
		fprintf(fout, "#include <stropts.h>\n");

	if (inetdflag || !tirpcflag) {
		fprintf(fout, "#include <sys/socket.h>\n");
		fprintf(fout, "#include <netinet/in.h>\n");
	}
	if ((netflag || pmflag) && tirpcflag) {
		fprintf(fout, "#include <netconfig.h>\n");
	}
	if (/* timerflag && */ tirpcflag)
		fprintf(fout, "#include <sys/resource.h> /* rlimit */\n");
	if (logflag || inetdflag || pmflag) {
		fprintf(fout, "#include <syslog.h>\n");
		fprintf(fout, "#include <errno.h>\n");
	}
	/* for ANSI-C */
	fprintf(fout, "\n#ifdef __STDC__\n#define SIG_PF void(*)(int)\n#endif\n");

	fprintf(fout, "\n#ifdef DEBUG\n#define RPC_SVC_FG\n#endif\n");
	if (timerflag)
		fprintf(fout, "\n#define _RPCSVC_CLOSEDOWN %s\n", svcclosetime);
	while ((def = get_definition())) {
		foundprogram |= (def->def_kind == DEF_PROGRAM);
	}
	if (extend && !foundprogram) {
		(void) unlink(outfilename);
		return;
	}
	if (callerflag)		/* EVAS */
		fprintf(fout, "\nstatic SVCXPRT *caller;\n");	/* EVAS */
	write_most(infile, netflag, nomain);
	if (!nomain) {
		if (!do_registers(argc, argv)) {
			if (outfilename)
				(void) unlink(outfilename);
			usage();
		}
		write_rest();
	}
}

/*
 * generate client side stubs
 */
static void
l_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	char           *include;
	definition     *def;
	int             foundprogram = 0;
	char           *outfilename;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	open_output(infile, outfilename);
	add_warning();
	if (Cflag)
		fprintf(fout, "#include <memory.h> /* for memset */\n");
	if (infile && (include = extendfile(infile, ".h"))) {
		fprintf(fout, "#include \"%s\"\n", include);
		free(include);
	} else
		fprintf(fout, "#include <rpc/rpc.h>\n");
	while ((def = get_definition()))
		foundprogram |= (def->def_kind == DEF_PROGRAM);

	if (extend && !foundprogram) {
		(void) unlink(outfilename);
		return;
	}
	write_stubs();
}

/*
 * generate the dispatch table
 */
static void
t_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	definition     *def;
	int             foundprogram = 0;
	char           *outfilename;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	open_output(infile, outfilename);
	add_warning();
	while ((def = get_definition()))
		foundprogram |= (def->def_kind == DEF_PROGRAM);

	if (extend && !foundprogram) {
		(void) unlink(outfilename);
		return;
	}
	write_tables();
}

/* sample routine for the server template */
static void
svc_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	definition     *def;
	char           *include;
	char           *outfilename;
	long            tell;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;
	checkfiles(infile, outfilename);	/* check if outfile already
						 * exists. if so, print an
						 * error message and exit */
	open_output(infile, outfilename);
	add_sample_msg();

	if (infile && (include = extendfile(infile, ".h"))) {
		fprintf(fout, "#include \"%s\"\n", include);
		free(include);
	} else
		fprintf(fout, "#include <rpc/rpc.h>\n");

	tell = ftell(fout);
	while ((def = get_definition()))
		write_sample_svc(def);

	if (extend && tell == ftell(fout))
		(void) unlink(outfilename);
}


/* sample main routine for client */
static void
clnt_output(infile, define, extend, outfile)
	char           *infile;
	char           *define;
	int             extend;
	char           *outfile;
{
	definition *def;
	char *include, *outfilename;
	long tell;
	int has_program = 0;

	open_input(infile, define);
	outfilename = extend ? extendfile(infile, outfile) : outfile;

	/*
	 * check if outfile already exists. if so,
	 * print an error message and exit
	 */
	checkfiles(infile, outfilename);

	open_output(infile, outfilename);
	add_sample_msg();
	if (infile && (include = extendfile(infile, ".h"))) {
		fprintf(fout, "#include \"%s\"\n", include);
		free(include);
	} else
		fprintf(fout, "#include <rpc/rpc.h>\n");
	tell = ftell(fout);
	while ((def = get_definition()))
		has_program += write_sample_clnt(def);

	if (has_program)
		write_sample_clnt_main();

	if (extend && tell == ftell(fout))
		(void) unlink(outfilename);
}

/*
 * Perform registrations for service output
 * Return 0 if failed; 1 otherwise.
 */
static int
do_registers(argc, argv)
	int             argc;
	char           *argv[];
{
	int             i;

	if (inetdflag || !tirpcflag) {
		for (i = 1; i < argc; i++) {
			if (streq(argv[i], "-s")) {
				if (!check_nettype(argv[i + 1], valid_i_nettypes))
					return 0;
				write_inetd_register(argv[i + 1]);
				i++;
			}
		}
	} else {
		for (i = 1; i < argc; i++)
			if (streq(argv[i], "-s")) {
				if (!check_nettype(argv[i + 1], valid_ti_nettypes))
					return 0;
				write_nettype_register(argv[i + 1]);
				i++;
			} else if (streq(argv[i], "-n")) {
				write_netid_register(argv[i + 1]);
				i++;
			}
	}
	return 1;
}

/*
 * Add another argument to the arg list
 */
static void
addarg(cp)
	char           *cp;
{
	if (argcount >= ARGLISTLEN) {
		fprintf(stderr, "rpcgen: too many defines\n");
		crash();
		/* NOTREACHED */
	}
	arglist[argcount++] = cp;

}

static void
putarg(where, cp)
	char           *cp;
	int             where;
{
	if (where >= ARGLISTLEN) {
		fprintf(stderr, "rpcgen: arglist coding error\n");
		crash();
		/* NOTREACHED */
	}
	arglist[where] = cp;
}

/*
 * if input file is stdin and an output file is specified then complain
 * if the file already exists. Otherwise the file may get overwritten
 * If input file does not exist, exit with an error
 */
static void
checkfiles(infile, outfile)
	char           *infile;
	char           *outfile;
{
	struct stat     buf;

	if (infile)		/* infile ! = NULL */
		if (stat(infile, &buf) < 0) {
			perror(infile);
			crash();
		}
#if 0
	if (outfile) {
		if (stat(outfile, &buf) < 0)
			return;	/* file does not exist */
		else {
			fprintf(stderr,
			    "file '%s' already exists and may be overwritten\n",
			    outfile);
			crash();
		}
	}
#endif
}

/*
 * Parse command line arguments
 */
static int
parseargs(argc, argv, cmd)
	int argc;
	char *argv[];
	struct commandline *cmd;
{
	int i, j, nflags;
	char c, flag[(1 << 8 * sizeof(char))];

	cmdname = argv[0];
	cmd->infile = cmd->outfile = NULL;
	if (argc < 2)
		return (0);

	allfiles = 0;
	flag['c'] = 0;
	flag['h'] = 0;
	flag['l'] = 0;
	flag['m'] = 0;
	flag['o'] = 0;
	flag['s'] = 0;
	flag['n'] = 0;
	flag['t'] = 0;
	flag['S'] = 0;
	flag['C'] = 0;
	for (i = 1; i < argc; i++) {
		if (argv[i][0] != '-') {
			if (cmd->infile) {
				fprintf(stderr,
				    "Cannot specify more than one input file!\n");
				return (0);
			}
			cmd->infile = argv[i];
		} else {
			for (j = 1; argv[i][j] != 0; j++) {
				c = argv[i][j];
				switch (c) {
				case 'A':
					callerflag = 1;
					break;
				case 'a':
					allfiles = 1;
					break;
				case 'c':
				case 'h':
				case 'l':
				case 'm':
				case 't':
					if (flag[(unsigned char)c])
						return (0);
					flag[(unsigned char)c] = 1;
					break;
				case 'S':
					/*
					 * sample flag: Ss or Sc. Ss means
					 * set flag['S']; Sc means set
					 * flag['C'];
					 */
					c = argv[i][++j];	/* get next char */
					if (c == 's')
						c = 'S';
					else if (c == 'c')
						c = 'C';
					else
						return (0);

					if (flag[(unsigned char)c])
						return (0);
					flag[(unsigned char)c] = 1;
					break;
				case 'C':	/* ANSI C syntax */
					Cflag = 1;
					break;

				case 'b':
					/*
					 * turn TIRPC flag off for
					 * generating backward compatible
					 */
					tirpcflag = 0;
					break;

				case 'I':
					inetdflag = 1;
					break;
				case 'N':
					newstyle = 1;
					break;
				case 'L':
					logflag = 1;
					break;
				case 'K':
					if (++i == argc)
						return (0);
					svcclosetime = argv[i];
					goto nextarg;
				case 'T':
					tblflag = 1;
					break;
				case 'i':
					if (++i == argc)
						return (0);
					doinline = atoi(argv[i]);
					goto nextarg;
				case 'n':
				case 'o':
				case 's':
					if (argv[i][j - 1] != '-' ||
					    argv[i][j + 1] != 0)
						return (0);
					flag[(unsigned char)c] = 1;
					if (++i == argc)
						return (0);
					if (c == 's') {
						if (!streq(argv[i], "udp") &&
						    !streq(argv[i], "tcp"))
							return (0);
					} else if (c == 'o') {
						if (cmd->outfile)
							return (0);
						cmd->outfile = argv[i];
					}
					goto nextarg;
				case 'D':
					if (argv[i][j - 1] != '-')
						return (0);
					(void) addarg(argv[i]);
					goto nextarg;
				case 'Y':
					if (++i == argc)
						return (0);
					if (snprintf(pathbuf, sizeof pathbuf,
					    "%s/cpp", argv[i]) >= sizeof pathbuf)
						usage();
					CPP = pathbuf;
					cppDefined = 1;
					goto nextarg;
				default:
					return (0);
				}
			}
	nextarg:
			;
		}
	}

	cmd->cflag = flag['c'];
	cmd->hflag = flag['h'];
	cmd->lflag = flag['l'];
	cmd->mflag = flag['m'];
	cmd->nflag = flag['n'];
	cmd->sflag = flag['s'];
	cmd->tflag = flag['t'];
	cmd->Ssflag = flag['S'];
	cmd->Scflag = flag['C'];

	if (tirpcflag) {
		pmflag = inetdflag ? 0 : 1;	/* pmflag or inetdflag is
						 * always TRUE */
		if (inetdflag && cmd->nflag) {
			/* netid not allowed with inetdflag */
			fprintf(stderr, "Cannot use netid flag with inetd flag!\n");
			return (0);
		}
	} else {
		/* 4.1 mode */
		pmflag = 0;	/* set pmflag only in tirpcmode */
		inetdflag = 1;	/* inetdflag is TRUE by default */
		if (cmd->nflag) {
			/* netid needs TIRPC */
			fprintf(stderr, "Cannot use netid flag without TIRPC!\n");
			return (0);
		}
	}

	if (newstyle && (tblflag || cmd->tflag)) {
		fprintf(stderr, "Cannot use table flags with newstyle!\n");
		return (0);
	}
	/* check no conflicts with file generation flags */
	nflags = cmd->cflag + cmd->hflag + cmd->lflag + cmd->mflag +
	    cmd->sflag + cmd->nflag + cmd->tflag + cmd->Ssflag + cmd->Scflag;

	if (nflags == 0) {
		if (cmd->outfile != NULL || cmd->infile == NULL)
			return (0);
	} else if (nflags > 1) {
		fprintf(stderr, "Cannot have more than one file generation flag!\n");
		return (0);
	}
	return (1);
}

static void
usage(void)
{
	fprintf(stderr, "usage: %s [-abACILNT] [-Dname[=value]] [-i lines] "
	    "[-K seconds] infile\n", cmdname);
	fprintf(stderr, "       %s [-c | -h | -l | -m | -t | -Sc | -Ss] "
	    "[-o outfile] [infile]\n", cmdname);
	fprintf(stderr, "       %s [-s nettype]* [-o outfile] [infile]\n", cmdname);
	exit(1);
}
@


1.32
log
@exit() after perror() for pledge failure.  Perhaps this got introduced
as a test idiom, either when pledge was young or during the transition
to strings.... dunno
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.31 2015/10/10 20:57:00 deraadt Exp $	 */
d144 1
a144 1
		perror("pledge");		
@


1.31
log
@pledge "stdio rpath wpath cpath proc exec"; this spawns cpp.
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.30 2015/08/20 22:32:41 deraadt Exp $	 */
d143 1
a143 1
	if (pledge("stdio rpath wpath cpath proc exec", NULL) == -1)
d145 2
@


1.30
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.29 2015/01/16 06:40:11 deraadt Exp $	 */
d142 3
@


1.29
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.28 2014/11/18 20:54:28 krw Exp $	 */
d217 1
a217 1
	res = alloc(len);
@


1.28
log
@Nuke more obvious #include duplications.

ok deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.27 2013/11/28 18:24:54 deraadt Exp $	 */
a41 1
#include <sys/param.h>
d47 1
d80 1
a80 1
static char     pathbuf[MAXPATHLEN];
@


1.27
log
@unsigned char for ctype
ok krw okan
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.26 2013/10/27 18:31:24 guenther Exp $	 */
a47 1
#include <stdlib.h>
@


1.26
log
@If a constant string needs a name, use a static const array instead of a
pointer or non-const array, as that minimizes the symbols, maximizes the
placement into read-only memory, and avoids warnings from gcc -Wformat=2
when they're used as format strings.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.25 2010/09/01 14:43:34 millert Exp $	 */
d448 2
a449 2
		if (islower(*tmp))
			*tmp = toupper(*tmp);
@


1.25
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.24 2009/10/27 23:59:42 deraadt Exp $	 */
d423 1
a423 1
char            rpcgen_table_dcl[] = "struct rpcgen_table {\n\
@


1.24
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.23 2007/10/03 14:52:31 weingart Exp $	 */
d3 1
d5 1
a5 7
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
d7 3
a9 3
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
d11 9
a19 3
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d21 12
a32 11
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
@


1.23
log
@Nuke MSDOS portion.  Add <unistd.h> for STDERR_FILENO in the
generated files.

"Yes, with extreme prejudice." millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.22 2007/10/03 14:35:48 weingart Exp $	 */
a31 6

#ifndef lint
static const char sccsid[] = "@@(#)rpc_main.c 1.30 89/03/30 (C) 1987 SMI";
static const char cvsid[] =
	"$OpenBSD: rpc_main.c,v 1.22 2007/10/03 14:35:48 weingart Exp $";
#endif
@


1.22
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.21 2006/03/22 18:20:31 dhill Exp $	 */
d36 1
a36 1
	"$OpenBSD: rpc_main.c,v 1.21 2006/03/22 18:20:31 dhill Exp $";
a126 4
#ifdef __MSDOS__
static char    *dos_cppfile = NULL;
#endif

a200 6
#ifdef __MSDOS__
	if (dos_cppfile != NULL) {
		(void) fclose(fin);
		(void) unlink(dos_cppfile);
	}
#endif
a311 41
#ifdef __MSDOS__
#define	DOSCPP	"\\prog\\bc31\\bin\\cpp.exe"
	{
		int             retval;
		char            drive[MAXDRIVE], dir[MAXDIR], name[MAXFILE],
		                ext[MAXEXT];
		char            cppfile[MAXPATH];
		char           *cpp;

		if ((cpp = searchpath("cpp.exe")) == NULL &&
		    (cpp = getenv("RPCGENCPP")) == NULL)
			cpp = DOSCPP;

		putarg(0, cpp);
		putarg(1, "-P-");
		putarg(2, CPPFLAGS);
		addarg(define);
		addarg(infile);
		addarg(NULL);

		retval = spawnvp(P_WAIT, arglist[0], arglist);
		if (retval != 0) {
			fprintf(stderr, "%s: C PreProcessor failed\n", cmdname);
			crash();
		}
		fnsplit(infile, drive, dir, name, ext);
		fnmerge(cppfile, drive, dir, name, ".i");

		fin = fopen(cppfile, "r");
		if (fin == NULL) {
			fprintf(stderr, "%s: ", cmdname);
			perror(cppfile);
			crash();
		}
		dos_cppfile = strdup(cppfile);
		if (dos_cppfile == NULL) {
			fprintf(stderr, "%s: out of memory\n", cmdname);
			crash();
		}
	}
#else
a332 1
#endif
d545 1
@


1.21
log
@NetBSD  - plug leak in generate_guard()
        - plug leak in h_output(), coverity cid 100
NetBSD plug leak, coverity cid 98.
NetBSD plug leak, coverity cid 94.

ok ray@@ jaredy@@ moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.20 2004/05/09 22:22:45 deraadt Exp $	 */
d34 3
a36 2
static char     sccsid[] = "@@(#)rpc_main.c 1.30 89/03/30 (C) 1987 SMI";
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.20 2004/05/09 22:22:45 deraadt Exp $";
@


1.20
log
@delint
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.19 2003/07/09 03:35:21 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.19 2003/07/09 03:35:21 deraadt Exp $";
d490 1
a490 1
	char           *filename, *guard, *tmp;
d508 4
a511 1
	guard = extendfile(guard, "_H_RPCGEN");
d563 2
@


1.19
log
@protos
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.18 2003/04/14 19:59:36 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.18 2003/04/14 19:59:36 deraadt Exp $";
a876 1

@


1.18
log
@recommit, with the typo fixed
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.16 2003/04/14 04:51:28 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.17 2003/04/14 19:45:59 deraadt Exp $";
d147 1
a147 3
main(argc, argv)
	int argc;
	char *argv[];
d218 1
a218 3
extendfile(path, ext)
	char *path;
	char *ext;
d248 1
a248 3
open_output(infile, outfile)
	char *infile;
	char *outfile;
d271 1
a271 1
add_warning()
d281 1
a281 1
clear_args()
d291 1
a291 1
find_cpp()
d316 1
a316 3
open_input(infile, define)
	char           *infile;
	char           *define;
d413 1
a413 3
check_nettype(name, list_to_check)
	char           *name;
	char           *list_to_check[];
d487 2
a488 3
char *
generate_guard(pathname)
	char           *pathname;
@


1.17
log
@oops
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.15 2002/07/05 05:39:42 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.15 2002/07/05 05:39:42 deraadt Exp $";
d227 1
d234 2
a235 1
	res = alloc(strlen(file) + strlen(ext) + 1);
d243 2
a244 2
	(void) strcpy(res, file);
	(void) strcpy(res + (p - file), ext);
@


1.16
log
@strlcpy, pretty easy
@
text
@a226 1
	size_t len;
d233 1
a233 2
	len = strlen(file) + strlen(ext) + 1;
	res = alloc(len);
d241 2
a242 2
	(void) strlcpy(res, file, len);
	(void) strlcpy(res, ext, len - (p - file));
@


1.15
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.14 2002/06/01 01:40:38 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.14 2002/06/01 01:40:38 deraadt Exp $";
d227 1
d234 2
a235 1
	res = alloc(strlen(file) + strlen(ext) + 1);
d243 2
a244 2
	(void) strcpy(res, file);
	(void) strcpy(res + (p - file), ext);
@


1.14
log
@cleanups
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.13 2002/05/27 03:14:22 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.13 2002/05/27 03:14:22 deraadt Exp $";
d44 3
d50 3
a52 9
#include <sys/types.h>
#ifdef __TURBOC__
#define	MAXPATHLEN	80
#include <process.h>
#include <dir.h>
#else
#include <sys/param.h>
#include <sys/file.h>
#endif
d130 8
a137 8
static c_output(char *, char *, int, char *);
static h_output(char *, char *, int, char *);
static s_output(int, char **, char *, char *, int, char *, int, int);
static l_output(char *, char *, int, char *);
static t_output(char *, char *, int, char *);
static svc_output(char *, char *, int, char *);
static clnt_output(char *, char *, int, char *);
static do_registers(int, char **);
d143 2
a144 2
static usage(void);

d234 4
a237 2
	if (res == NULL)
		abort();
d274 1
a274 1
static
d284 1
a284 1
static void 
d294 1
a294 1
static void 
d319 1
a319 1
static
d418 1
a418 1
static int 
d436 1
a436 1
static
d460 1
a460 1
	while (def = get_definition()) {
d469 2
a470 1
c_initialize()
d495 1
a495 1
char           *
d504 5
d525 1
a525 1
static
d552 1
a552 1
	while (def = get_definition()) {
d574 1
a574 1
static
d640 1
a640 1
	if ( /* timerflag && */ tirpcflag)
d652 1
a652 1
	while (def = get_definition()) {
d675 1
a675 1
static
d698 1
a698 1
	while (def = get_definition())
d711 1
a711 1
static
d726 1
a726 1
	while (def = get_definition())
d737 1
a737 1
static
d764 1
a764 1
	while (def = get_definition())
d773 1
a773 1
static
d802 1
a802 1
	while (def = get_definition())
d816 1
a816 2
static
int 
d959 1
a959 1
					if (flag[c])
d961 1
a961 1
					flag[c] = 1;
d977 1
a977 1
					if (flag[c])
d979 1
a979 1
					flag[c] = 1;
d1021 1
a1021 1
					flag[c] = 1;
d1104 2
a1105 2
static
usage()
@


1.13
log
@unsigned vs unsigned int
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.12 2002/02/16 21:27:51 millert Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.12 2002/02/16 21:27:51 millert Exp $";
d261 1
a261 1
		f_print(stderr, "%s: output would overwrite %s\n", cmdname,
d267 1
a267 1
		f_print(stderr, "%s: unable to open ", cmdname);
d278 4
a281 4
	f_print(fout, "/*\n");
	f_print(fout, " * Please do not edit this file.\n");
	f_print(fout, " * It was generated using rpcgen.\n");
	f_print(fout, " */\n\n");
d358 1
a358 1
			f_print(stderr, "%s: ", cmdname);
d392 1
a392 1
		f_print(stderr, "%s: ", cmdname);
d429 1
a429 1
	f_print(stderr, "illegal nettype :\'%s\'\n", name);
d455 1
a455 1
		f_print(fout, "#include \"%s\"\n", include);
d459 1
a459 1
		f_print(fout, "#include <rpc/rpc.h>\n");
d539 1
a539 1
	f_print(fout, "#ifndef _%s\n#define _%s\n\n", guard,
d542 2
a543 2
	f_print(fout, "#define RPCGEN_VERSION\t%s\n\n", RPCGEN_VERSION);
	f_print(fout, "#include <rpc/rpc.h>\n\n");
d561 1
a561 1
		f_print(fout, rpcgen_table_dcl);
d563 1
a563 1
	f_print(fout, "\n#endif /* !_%s */\n", guard);
d590 1
a590 1
		f_print(fout, "#include \"%s\"\n", include);
d593 1
a593 1
		f_print(fout, "#include <rpc/rpc.h>\n");
d595 2
a596 2
	f_print(fout, "#include <stdio.h>\n");
	f_print(fout, "#include <stdlib.h>/* getenv, exit */\n");
d598 1
a598 1
		f_print(fout,
d600 1
a600 1
		f_print(fout, "#include <string.h> /* strcmp */ \n");
d602 1
a602 1
	f_print(fout, "#include <netdb.h>\n");	/* evas */
d608 1
a608 1
		f_print(fout, "#include <signal.h>\n");
d612 1
a612 1
		f_print(fout, "#include <sys/ttycom.h>/* TIOCNOTTY */\n");
d614 3
a616 3
		f_print(fout, "#ifdef __cplusplus\n");
		f_print(fout, "#include <sysent.h> /* getdtablesize, open */\n");
		f_print(fout, "#endif /* __cplusplus */\n");
d619 1
a619 1
			f_print(fout, "#include <unistd.h> /* setsid */\n");
d622 1
a622 1
		f_print(fout, "#include <sys/types.h>\n");
d624 1
a624 1
	f_print(fout, "#include <memory.h>\n");
d626 1
a626 1
		f_print(fout, "#include <stropts.h>\n");
d629 2
a630 2
		f_print(fout, "#include <sys/socket.h>\n");
		f_print(fout, "#include <netinet/in.h>\n");
d633 1
a633 1
		f_print(fout, "#include <netconfig.h>\n");
d636 1
a636 1
		f_print(fout, "#include <sys/resource.h> /* rlimit */\n");
d638 2
a639 2
		f_print(fout, "#include <syslog.h>\n");
		f_print(fout, "#include <errno.h>\n");
d642 1
a642 1
	f_print(fout, "\n#ifdef __STDC__\n#define SIG_PF void(*)(int)\n#endif\n");
d644 1
a644 1
	f_print(fout, "\n#ifdef DEBUG\n#define RPC_SVC_FG\n#endif\n");
d646 1
a646 1
		f_print(fout, "\n#define _RPCSVC_CLOSEDOWN %s\n", svcclosetime);
d655 1
a655 1
		f_print(fout, "\nstatic SVCXPRT *caller;\n");	/* EVAS */
d687 1
a687 1
		f_print(fout, "#include <memory.h> /* for memset */\n");
d689 1
a689 1
		f_print(fout, "#include \"%s\"\n", include);
d692 1
a692 1
		f_print(fout, "#include <rpc/rpc.h>\n");
d753 1
a753 1
		f_print(fout, "#include \"%s\"\n", include);
d756 1
a756 1
		f_print(fout, "#include <rpc/rpc.h>\n");
d792 1
a792 1
		f_print(fout, "#include \"%s\"\n", include);
d795 1
a795 1
		f_print(fout, "#include <rpc/rpc.h>\n");
d851 1
a851 1
		f_print(stderr, "rpcgen: too many defines\n");
d865 1
a865 1
		f_print(stderr, "rpcgen: arglist coding error\n");
d895 1
a895 1
			f_print(stderr,
d935 1
a935 1
				f_print(stderr,
d1068 1
a1068 1
			f_print(stderr, "Cannot use netid flag with inetd flag!\n");
d1077 1
a1077 1
			f_print(stderr, "Cannot use netid flag without TIRPC!\n");
d1083 1
a1083 1
		f_print(stderr, "Cannot use table flags with newstyle!\n");
d1094 1
a1094 1
		f_print(stderr, "Cannot have more than one file generation flag!\n");
d1103 1
a1103 1
	f_print(stderr, "usage: %s [-abACILNT] [-Dname[=value]] [-i lines] "
d1105 1
a1105 1
	f_print(stderr, "       %s [-c | -h | -l | -m | -t | -Sc | -Ss] "
d1107 1
a1107 1
	f_print(stderr, "       %s [-s nettype]* [-o outfile] [infile]\n", cmdname);
@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.11 2001/12/05 09:50:31 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.11 2001/12/05 09:50:31 deraadt Exp $";
d489 1
a489 1
	unsigned	len_arg;\n\
d491 1
a491 1
	unsigned	len_res;\n\
@


1.11
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/* $OpenBSD: rpc_main.c,v 1.9 2001/11/24 19:17:47 deraadt Exp $	 */
d35 1
a35 1
static char     cvsid[] = "$OpenBSD: rpc_main.c,v 1.9 2001/11/24 19:17:47 deraadt Exp $";
d133 14
a146 14
static c_output __P((char *, char *, int, char *));
static h_output __P((char *, char *, int, char *));
static s_output __P((int, char **, char *, char *, int, char *, int, int));
static l_output __P((char *, char *, int, char *));
static t_output __P((char *, char *, int, char *));
static svc_output __P((char *, char *, int, char *));
static clnt_output __P((char *, char *, int, char *));
static do_registers __P((int, char **));
static void addarg __P((char *));
static void putarg __P((int, char *));
static void clear_args __P((void));
static void checkfiles __P((char *, char *));
static int parseargs __P((int, char **, struct commandline *));
static usage    __P((void));
@


1.10
log
@argh!  i messed something up!
@
text
@d1 2
a2 2
/*	$OpenBSD: rpc_main.c,v 1.8 2001/11/07 18:44:28 deraadt Exp $	*/
/*	$NetBSD: rpc_main.c,v 1.9 1996/02/19 11:12:43 pk Exp $	*/
d34 2
a35 2
static char sccsid[] = "@@(#)rpc_main.c 1.30 89/03/30 (C) 1987 SMI";
static char cvsid[] = "$OpenBSD: rpc_main.c,v 1.8 2001/11/07 18:44:28 deraadt Exp $";
d39 1
a39 1
 * rpc_main.c, Top level of the RPC protocol compiler. 
d42 1
a42 1
#define RPCGEN_VERSION	"199506"    /* This program's version (year & month) */
d62 1
a62 1
#define DONT_EXTEND	0		/* alias for FALSE */
d66 1
a66 1
static int cppDefined = 0;          /* explicit path for C preprocessor */
d69 11
a79 11
	int cflag;		/* xdr C routines */
	int hflag;		/* header file */
	int lflag;		/* client side stubs */
	int mflag;		/* server side stubs */
	int nflag;		/* netid flag */
	int sflag;		/* server stubs for the given transport */
	int tflag;		/* dispatch Table file */
	int Ssflag;		/* produce server sample code */
	int Scflag;		/* produce client sample code */
	char *infile;		/* input module name */
	char *outfile;		/* output module name */
d82 1
d84 5
a88 7
static char *cmdname;

static char *svcclosetime = "120";
static char *CPP = "/usr/bin/cpp";
static char CPPFLAGS[] = "-C";
static char pathbuf[MAXPATHLEN];
static char *allv[] = {
d91 2
a92 2
static int allc = sizeof(allv)/sizeof(allv[0]);
static char *allnv[] = {
d95 1
a95 1
static int allnc = sizeof(allnv)/sizeof(allnv[0]);
d100 2
a101 2
static char *arglist[ARGLISTLEN];
static int argcount = FIXEDARGS;
d104 7
a110 6
int nonfatalerrors;	/* errors */
int inetdflag/* = 1*/;	/* Support for inetd */ /* is now the default */
int pmflag;		/* Support for port monitors */
int logflag;		/* Use syslog instead of fprintf for errors */
int tblflag;		/* Support for dispatch table file */
int callerflag;		/* Generate svc_caller() function */
d113 1
a113 4
/*length at which to start doing an inline */

int doinline=INLINE;  /* length at which to start doing an inline. 3 = default
		if 0, no xdr_inline code */
d115 13
a127 7
int indefinitewait;	/* If started by port monitors, hang till it wants */
int exitnow;		/* If started by port monitors, exit after the call */
int timerflag;		/* TRUE if !indefinite && !exitnow */
int newstyle;           /* newstyle of passing arguments (by value) */
int Cflag = 0 ;         /* ANSI C syntax */
static int allfiles;   /* generate all files */
int tirpcflag = 0;       /* generating code for tirpc, by default */
d130 1
a130 1
static char *dos_cppfile = NULL;
d146 1
a146 3
static usage __P((void));
static options_usage __P((void));

d149 1
d156 1
a156 1
	(void) memset((char *)&cmd, 0, sizeof (struct commandline));
d161 5
a165 6
	if (cmd.cflag || cmd.hflag || cmd.lflag || cmd.tflag || cmd.sflag || 
		cmd.mflag || cmd.nflag || cmd.Ssflag || cmd.Scflag ) {
	  checkfiles(cmd.infile, cmd.outfile);
	}
	else 
	  checkfiles(cmd.infile,NULL);
d174 1
a174 1
		s_output(argc, argv, cmd.infile, "-DRPC_SVC", DONT_EXTEND, 
d178 2
a179 2
	} else if  (cmd.Ssflag) {
		  svc_output(cmd.infile, "-DRPC_SERVER", DONT_EXTEND, cmd.outfile);
d181 1
a181 1
		  clnt_output(cmd.infile, "-DRPC_CLIENT", DONT_EXTEND, cmd.outfile);
d190 3
a192 3
		if (inetdflag || !tirpcflag )
			s_output(allc, allv, cmd.infile, "-DRPC_SVC", EXTEND, 
				 "_svc.c", cmd.mflag, cmd.nflag);
d194 2
a195 2
			s_output(allnc, allnv, cmd.infile, "-DRPC_SVC", 
				 EXTEND, "_svc.c", cmd.mflag, cmd.nflag);
d201 2
a202 2
		  reinitialize();
		  svc_output(cmd.infile, "-DRPC_SERVER", EXTEND, "_server.c");
d205 3
a207 3
		  reinitialize();
		  clnt_output(cmd.infile, "-DRPC_CLIENT", EXTEND, "_client.c");
		}	
d220 1
a220 1
 * add extension to filename 
d237 1
a237 1
	if (res == NULL) {
a238 1
	}
d240 1
a240 1
	if (p == NULL) {
a241 1
	}
d248 1
a248 1
 * Open output file with given extension 
d250 1
a250 1
static
a259 1

d262 1
a262 1
			infile);
d285 2
a286 1
static void clear_args()
d288 4
a291 4
  int i;
  for( i=FIXEDARGS; i<ARGLISTLEN; i++ )
    arglist[i] = NULL;
  argcount = FIXEDARGS;
d295 2
a296 1
static void find_cpp()
d298 1
a298 1
  struct stat buf;
d300 15
a314 12
  if( stat(CPP, &buf) < 0 )  {	/* SVR4 or explicit cpp does not exist */
    if (cppDefined) {
      fprintf( stderr, "cannot find C preprocessor: %s \n", CPP );
      crash();
    } else {			/* try the other one */
      CPP = SUNOS_CPP;
      if( stat( CPP, &buf ) < 0 ) { /* can't find any cpp */
	fprintf( stderr, "cannot find any C preprocessor: %s\n", CPP );
	crash();
      }
    }
  }
d318 1
a318 1
 * Open input file with given define for C-preprocessor 
d322 2
a323 2
	char *infile;
	char *define;
d325 1
a325 1
	int pd[2];
d330 17
a346 21
	{ int retval;
	char drive[MAXDRIVE], dir[MAXDIR], name[MAXFILE], ext[MAXEXT];
	char cppfile[MAXPATH];
	char *cpp;

	if ((cpp = searchpath("cpp.exe")) == NULL
	&& (cpp = getenv("RPCGENCPP")) == NULL)
		cpp = DOSCPP;

	putarg(0, cpp);
	putarg(1, "-P-");
	putarg(2, CPPFLAGS);
	addarg(define);
	addarg(infile);
	addarg(NULL);

	retval = spawnvp(P_WAIT, arglist[0], arglist);
	if (retval != 0) {
		fprintf(stderr, "%s: C PreProcessor failed\n", cmdname);
		crash();
	}
d348 7
a354 2
	fnsplit(infile, drive, dir, name, ext);
	fnmerge(cppfile, drive, dir, name, ".i");
d356 11
a366 11
	fin = fopen(cppfile, "r");
	if (fin == NULL) {
		f_print(stderr, "%s: ", cmdname);
		perror(cppfile);
		crash();
	}
	dos_cppfile = strdup(cppfile);
	if (dos_cppfile == NULL) {
		fprintf(stderr, "%s: out of memory\n", cmdname);
		crash();
	}
d377 1
a377 1
		addarg((char *)NULL);
d399 12
a410 13
static char* valid_ti_nettypes[] =
{
  "netpath",
  "visible",
  "circuit_v",
  "datagram_v",
  "circuit_n",
  "datagram_n",
  "udp",
  "tcp",
  "raw",
  NULL
  };
d413 4
a416 5
static char* valid_i_nettypes[] =
{
  "udp",
  "tcp",
  NULL
d419 12
a430 12
static int check_nettype( name, list_to_check )
char* name;
char* list_to_check[];
{
  int i;
  for( i = 0; list_to_check[i] != NULL; i++ ) {
	  if( strcmp( name, list_to_check[i] ) == 0 ) {
	    return 1;
	  }
  }
  f_print( stderr, "illegal nettype :\'%s\'\n", name );
  return 0;
d439 9
a447 9
	char *infile;
	char *define;
	int extend;
	char *outfile;
{
	definition *def;
	char *include;
	char *outfilename;
	long tell;
d450 1
a450 1
	open_input(infile, define);	
d459 1
a459 1
	  f_print(fout, "#include <rpc/rpc.h>\n");
d473 1
a473 1
  /* add all the starting basic types */
d475 4
a478 4
  add_type(1,"int");
  add_type(1,"long");
  add_type(1,"short");
  add_type(1,"bool");
d480 3
a482 3
  add_type(1,"u_int");
  add_type(1,"u_long");
  add_type(1,"u_short");
d486 1
a486 1
char rpcgen_table_dcl[] = "struct rpcgen_table {\n\
d495 3
a497 2
char* generate_guard( pathname )
     char* pathname;
d499 1
a499 1
        char* filename, *guard, *tmp;
d501 2
a502 2
	filename = strrchr(pathname, '/' );  /* find last component */
	filename = ((filename == 0) ? pathname : filename+1);
d511 1
a511 1
		
d513 1
a513 1
	return( guard );
d522 10
a531 10
	char *infile;
	char *define;
	int extend;
	char *outfile;
{
	definition *def;
	char *outfilename;
	long tell;
	char *guard;
	list *l;
d534 1
a534 1
	outfilename =  extend ? extendfile(infile, outfile) : outfile;
d537 1
a537 1
	guard = generate_guard(  outfilename ? outfilename: infile );
d539 1
a539 1
	f_print(fout,"#ifndef _%s\n#define _%s\n\n", guard,
d551 4
a554 3
	/* print function declarations.  
	   Do this after data definitions because they might be used as
	   arguments for functions */
d571 13
a583 13
	int argc;
	char *argv[];
	char *infile;
	char *define;
	int extend;
	char *outfile;
	int nomain;
	int netflag;
{
	char *include;
	definition *def;
	int foundprogram = 0;
	char *outfilename;
d593 1
a593 1
	  f_print(fout, "#include <rpc/rpc.h>\n");
d596 1
a596 1
	f_print(fout, "#include <stdlib.h>/* getenv, exit */\n"); 
d598 1
a598 1
		f_print (fout,
d600 1
a600 1
		f_print (fout, "#include <string.h> /* strcmp */ \n"); 
d602 1
a602 1
	f_print(fout, "#include <netdb.h>\n"); /*evas*/
d609 1
a609 1
	  timerflag = 1;
d611 6
d618 2
a619 9
	if( !tirpcflag && inetdflag )
	  f_print(fout, "#include <sys/ttycom.h>/* TIOCNOTTY */\n");
	if( Cflag && (inetdflag || pmflag ) ) {
	  f_print(fout, "#ifdef __cplusplus\n");
	  f_print(fout, "#include <sysent.h> /* getdtablesize, open */\n"); 
	  f_print(fout, "#endif /* __cplusplus */\n");
	  
	  if( tirpcflag )
	    f_print(fout, "#include <unistd.h> /* setsid */\n");
d621 2
a622 2
	if( tirpcflag )
	  f_print(fout, "#include <sys/types.h>\n");
d628 1
a628 1
	if (inetdflag || !tirpcflag ) {
d631 2
a632 3
	} 

	if ( (netflag || pmflag) && tirpcflag ) {
d635 1
a635 1
	if (/*timerflag &&*/ tirpcflag)
a640 1

d654 2
a655 2
	if (callerflag)						/*EVAS*/
		f_print(fout, "\nstatic SVCXPRT *caller;\n");	/*EVAS*/
d658 4
a661 4
		if( !do_registers(argc, argv) ) {
		  if (outfilename)
		    (void) unlink(outfilename);
		  usage();
d672 9
a680 9
	char *infile;
	char *define;
	int extend;
	char *outfile;
{
	char *include;
	definition *def;
	int foundprogram = 0;
	char *outfilename;
d687 1
a687 1
	  f_print (fout, "#include <memory.h> /* for memset */\n");
d692 2
a693 2
	  f_print(fout, "#include <rpc/rpc.h>\n");
	while (def = get_definition()) {
d695 1
a695 1
	}
d708 8
a715 8
	char *infile;
	char *define;
	int extend;
	char *outfile;
{
	definition *def;
	int foundprogram = 0;
	char *outfilename;
d721 1
a721 1
	while (def = get_definition()) {
d723 1
a723 1
	}
d732 1
a732 1
static 
d734 30
a763 30
     char *infile;
     char *define;
     int extend;
     char *outfile;
{
  definition *def;
  char *include;
  char *outfilename;
  long tell;
  
  open_input(infile, define);	
  outfilename = extend ? extendfile(infile, outfile) : outfile;
  checkfiles(infile,outfilename); /*check if outfile already exists.
				  if so, print an error message and exit*/
  open_output(infile, outfilename);
  add_sample_msg();

  if (infile && (include = extendfile(infile, ".h"))) {
    f_print(fout, "#include \"%s\"\n", include);
    free(include);
  } else
    f_print(fout, "#include <rpc/rpc.h>\n");

  tell = ftell(fout);
  while (def = get_definition()) {
	  write_sample_svc(def);
  }
  if (extend && tell == ftell(fout)) {
	  (void) unlink(outfilename);
  }
d768 1
a768 1
static 
d770 35
a804 34
     char *infile;
     char *define;
     int extend;
     char *outfile;
{
  definition *def;
  char *include;
  char *outfilename;
  long tell;
  int has_program = 0;
  
  open_input(infile, define);	
  outfilename = extend ? extendfile(infile, outfile) : outfile;
  checkfiles(infile,outfilename); /*check if outfile already exists.
				  if so, print an error message and exit*/

  open_output(infile, outfilename);
  add_sample_msg();
  if (infile && (include = extendfile(infile, ".h"))) {
    f_print(fout, "#include \"%s\"\n", include);
    free(include);
  } else
    f_print(fout, "#include <rpc/rpc.h>\n");
  tell = ftell(fout);
  while (def = get_definition()) {
    has_program += write_sample_clnt(def);
  }

  if( has_program )
    write_sample_clnt_main();

  if (extend && tell == ftell(fout)) {
    (void) unlink(outfilename);
  }
d808 1
a808 1
 * Perform registrations for service output 
d812 4
a815 3
int do_registers(argc, argv)
	int argc;
	char *argv[];
d817 1
a817 1
	int i;
d819 1
a819 1
	if ( inetdflag || !tirpcflag) {
d822 2
a823 2
			        if(!check_nettype( argv[i + 1], valid_i_nettypes ))
				  return 0;
d830 3
a832 3
		        if (streq(argv[i], "-s")) {
			        if(!check_nettype( argv[i + 1], valid_ti_nettypes ))
				  return 0;
d848 1
a848 1
	char *cp;
d853 1
a853 1
		/*NOTREACHED*/
d861 2
a862 2
	char *cp;
        int where;
d867 1
a867 1
		/*NOTREACHED*/
a869 1
	
d875 1
a875 1
 * If input file does not exist, exit with an error 
a876 1

d878 3
a880 3
checkfiles(infile, outfile) 
char *infile;
char *outfile;
d883 7
a889 8
  struct stat buf;

  if(infile)			/* infile ! = NULL */
    if(stat(infile,&buf) < 0)
      {
	perror(infile);
	crash();
      }
d891 10
a900 9
  if (outfile) {
    if (stat(outfile, &buf) < 0) 
      return;			/* file does not exist */
    else {
      f_print(stderr, 
	      "file '%s' already exists and may be overwritten\n", outfile);
      crash();
    }
  }
d905 1
a905 1
 * Parse command line arguments 
d913 2
a914 5
	int i;
	int j;
	char c;
	char flag[(1 << 8 * sizeof(char))];
	int nflags;
d918 1
a918 1
	if (argc < 2) {
d920 1
a920 1
	}
d935 2
a936 2
			        f_print( stderr, "Cannot specify more than one input file!\n");

d955 1
a955 1
					if (flag[c]) {
a956 1
					}
d959 11
a969 9
				case 'S':  
					/* sample flag: Ss or Sc.
					   Ss means set flag['S'];
					   Sc means set flag['C']; */
					c = argv[i][++j];  /* get next char */
					if( c == 's' )
					  c = 'S';
					else if( c == 'c' )
					  c = 'C';
d971 1
a971 1
					  return( 0 );
d973 1
a973 1
					if (flag[c]) {
a974 1
					}
d977 1
a977 1
				case 'C':  /* ANSI C syntax */
d981 5
a985 3
				case 'b':  /* turn TIRPC flag off for
					    generating backward compatible
					    */
d999 1
a999 1
					if (++i == argc) {
a1000 1
					}
d1006 2
a1007 2
				case 'i' :
				  	if (++i == argc) {
a1008 1
					}
d1014 2
a1015 2
					if (argv[i][j - 1] != '-' || 
					    argv[i][j + 1] != 0) {
a1016 1
					}
d1018 1
a1018 1
					if (++i == argc) {
a1019 1
					}
d1022 1
a1022 1
						    !streq(argv[i], "tcp")) {
a1023 1
						}
d1025 1
a1025 1
						if (cmd->outfile) {
a1026 1
						}
d1031 1
a1031 1
					if (argv[i][j - 1] != '-') {
a1032 1
					}
d1036 1
a1036 1
					if (++i == argc) {
a1037 1
					}
a1043 3



d1063 17
a1079 18
	if( tirpcflag ) {
	  pmflag = inetdflag ? 0 : 1;	  /* pmflag or inetdflag is always TRUE */
	  if( (inetdflag && cmd->nflag)) { /* netid not allowed with inetdflag */
	    f_print(stderr, "Cannot use netid flag with inetd flag!\n");
	    return (0);
	  }
	} else {  /* 4.1 mode */
	  pmflag = 0;               /* set pmflag only in tirpcmode */
	  inetdflag = 1;            /* inetdflag is TRUE by default */
	  if( cmd->nflag ) {          /* netid needs TIRPC */
	    f_print( stderr, "Cannot use netid flag without TIRPC!\n");
	    return( 0 );
	  }
	}

	if( newstyle && ( tblflag || cmd->tflag) ) {
	  f_print( stderr, "Cannot use table flags with newstyle!\n");
	  return( 0 );
d1082 4
d1088 1
a1088 1
		cmd->sflag + cmd->nflag + cmd->tflag + cmd->Ssflag + cmd->Scflag;
d1091 1
a1091 1
		if (cmd->outfile != NULL || cmd->infile == NULL) {
a1092 1
		}
d1094 1
a1094 1
	        f_print( stderr, "Cannot have more than one file generation flag!\n");
d1103 5
a1107 38
	f_print(stderr, "usage:  %s infile\n", cmdname);
	f_print(stderr, "\t%s [-a][-b][-C][-Dname[=value]] -i size  [-I [-K seconds]] [-A][-L][-M toolkit][-N][-T] infile\n",
			cmdname);
	f_print(stderr, "\t%s [-c | -h | -l | -m | -t | -Sc | -Ss] [-o outfile] [infile]\n",
			cmdname);
	f_print(stderr, "\t%s [-s nettype]* [-o outfile] [infile]\n", cmdname);
	f_print(stderr, "\t%s [-n netid]* [-o outfile] [infile]\n", cmdname);
	options_usage();
	exit(1);
}

static
options_usage()
{
	f_print(stderr, "options:\n");
	f_print(stderr, "-A\t\tgenerate svc_caller() function\n");
	f_print(stderr, "-a\t\tgenerate all files, including samples\n");
	f_print(stderr, "-b\t\tbackward compatibility mode (generates code for SunOS 4.1)\n");
	f_print(stderr, "-c\t\tgenerate XDR routines\n");
	f_print(stderr, "-C\t\tANSI C mode\n");
	f_print(stderr, "-Dname[=value]\tdefine a symbol (same as #define)\n");
	f_print(stderr, "-h\t\tgenerate header file\n");
	f_print(stderr, "-i size\t\tsize at which to start generating inline code\n");
	f_print(stderr, "-I\t\tgenerate code for inetd support in server (for SunOS 4.1)\n");
	f_print(stderr, "-K seconds\tserver exits after K seconds of inactivity\n");
	f_print(stderr, "-l\t\tgenerate client side stubs\n");
	f_print(stderr, "-L\t\tserver errors will be printed to syslog\n");
	f_print(stderr, "-m\t\tgenerate server side stubs\n");
	f_print(stderr, "-n netid\tgenerate server code that supports named netid\n");
	f_print(stderr, "-N\t\tsupports multiple arguments and call-by-value\n");
	f_print(stderr, "-o outfile\tname of the output file\n");
	f_print(stderr, "-s nettype\tgenerate server code that supports named nettype\n");
	f_print(stderr, "-Sc\t\tgenerate sample client code that uses remote procedures\n");
	f_print(stderr, "-Ss\t\tgenerate sample server code that defines remote procedures\n");
	f_print(stderr, "-t\t\tgenerate RPC dispatch table\n");
	f_print(stderr, "-T\t\tgenerate code to support RPC dispatch tables\n");
	f_print(stderr, "-Y path\t\tdirectory name to find C preprocessor (cpp)\n");

@


1.9
log
@half finished KNF
@
text
@d206 1
a206 1
		}
d300 1
a300 1
  if (stat(CPP, &buf) < 0 )  {	/* SVR4 or explicit cpp does not exist */
d306 1
a306 1
      if (stat( CPP, &buf ) < 0 ) { /* can't find any cpp */
d395 1
a395 1
static char *valid_ti_nettypes[] =
d410 1
a410 1
static char *valid_i_nettypes[] =
d418 2
a419 2
char *name;
char *list_to_check[];
d421 8
a428 7
	int i;
	for( i = 0; list_to_check[i] != NULL; i++ ) {
		if (strcmp( name, list_to_check[i] ) == 0)
			return 1;
	}
	f_print(stderr, "illegal nettype :\'%s\'\n", name);
	return 0;
d448 1
a448 1
	open_input(infile, define);
d493 2
a494 2
char *generate_guard( pathname )
     char *pathname;
d496 1
a496 1
        char *filename, *guard, *tmp;
d508 1
a508 1

d608 1
a608 1
	if (!tirpcflag && inetdflag)
d610 1
a610 1
	if (Cflag && (inetdflag || pmflag )) {
d615 1
a615 1
	  if (tirpcflag)
d618 1
a618 1
	if (tirpcflag)
d657 1
a657 1
		if (!do_registers(argc, argv)) {
d743 1
a743 1
  open_input(infile, define);
d780 1
a780 1
  open_input(infile, define);
d797 1
a797 1
  if (has_program)
d819 1
a819 1
			        if (!check_nettype( argv[i + 1], valid_i_nettypes ))
d828 1
a828 1
			        if (!check_nettype( argv[i + 1], valid_ti_nettypes ))
d867 1
d884 2
a885 2
  if (infile)			/* infile ! = NULL */
    if (stat(infile,&buf) < 0)
d967 1
a967 1
					if(c == 's')
d969 1
a969 1
					else if(c == 'c')
d1074 1
a1074 1
	if(tirpcflag) {
d1076 1
a1076 1
	  if((inetdflag && cmd->nflag)) { /* netid not allowed with inetdflag */
d1083 1
a1083 1
	  if (cmd->nflag) {          /* netid needs TIRPC */
d1089 1
a1089 1
	if (newstyle && ( tblflag || cmd->tflag)) {
@


1.8
log
@rpcgen is not nearly KNF, but it now generates close to KNF code
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_main.c,v 1.7 2001/07/18 22:26:00 deraadt Exp $	*/
d35 1
a35 1
static char cvsid[] = "$OpenBSD: rpc_main.c,v 1.7 2001/07/18 22:26:00 deraadt Exp $";
d206 1
a206 1
		}	
d300 1
a300 1
  if( stat(CPP, &buf) < 0 )  {	/* SVR4 or explicit cpp does not exist */
d306 1
a306 1
      if( stat( CPP, &buf ) < 0 ) { /* can't find any cpp */
d395 1
a395 1
static char* valid_ti_nettypes[] =
d410 1
a410 1
static char* valid_i_nettypes[] =
d418 2
a419 2
char* name;
char* list_to_check[];
d421 7
a427 8
  int i;
  for( i = 0; list_to_check[i] != NULL; i++ ) {
	  if( strcmp( name, list_to_check[i] ) == 0 ) {
	    return 1;
	  }
  }
  f_print( stderr, "illegal nettype :\'%s\'\n", name );
  return 0;
d447 1
a447 1
	open_input(infile, define);	
d492 2
a493 2
char* generate_guard( pathname )
     char* pathname;
d495 1
a495 1
        char* filename, *guard, *tmp;
d507 1
a507 1
		
d607 1
a607 1
	if( !tirpcflag && inetdflag )
d609 1
a609 1
	if( Cflag && (inetdflag || pmflag ) ) {
d614 1
a614 1
	  if( tirpcflag )
d617 1
a617 1
	if( tirpcflag )
d656 1
a656 1
		if( !do_registers(argc, argv) ) {
d742 1
a742 1
  open_input(infile, define);	
d779 1
a779 1
  open_input(infile, define);	
d796 1
a796 1
  if( has_program )
d818 1
a818 1
			        if(!check_nettype( argv[i + 1], valid_i_nettypes ))
d827 1
a827 1
			        if(!check_nettype( argv[i + 1], valid_ti_nettypes ))
a865 1
	
d882 2
a883 2
  if(infile)			/* infile ! = NULL */
    if(stat(infile,&buf) < 0)
d965 1
a965 1
					if( c == 's' )
d967 1
a967 1
					else if( c == 'c' )
d1072 1
a1072 1
	if( tirpcflag ) {
d1074 1
a1074 1
	  if( (inetdflag && cmd->nflag)) { /* netid not allowed with inetdflag */
d1081 1
a1081 1
	  if( cmd->nflag ) {          /* netid needs TIRPC */
d1087 1
a1087 1
	if( newstyle && ( tblflag || cmd->tflag) ) {
@


1.7
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_main.c,v 1.5 2001/01/21 22:02:52 deraadt Exp $	*/
d35 1
a35 1
static char cvsid[] = "$OpenBSD: rpc_main.c,v 1.5 2001/01/21 22:02:52 deraadt Exp $";
a635 1
		f_print(fout, "#ifdef SYSLOG\n");
d637 1
a637 4
		f_print(fout, "#else\n");
		f_print(fout, "#define LOG_ERR 1\n");
		f_print(fout, "#define openlog(a, b, c)\n");
		f_print(fout, "#endif\n");
d889 1
a889 1
      };
@


1.6
log
@-Wall cleanup; ok deraadt
@
text
@a46 1
#include <ctype.h>
a52 1
#include <unistd.h>
d130 8
a137 17
static char *extendfile __P((char *, char *));
static void open_output __P((char *, char *));
static void add_warning __P((void));
static void clear_args __P((void));
static void find_cpp __P((void));
static void open_input __P((char *, char *));
static int check_nettype __P((char *, char *[]));
static void c_output __P((char *, char *, int, char *));
static void c_initialize __P((void));
static char *generate_guard __P((char *));
static void h_output __P((char *, char *, int, char *));
static void s_output __P((int, char *[], char *, char *, int, char *, int, int));
static void l_output __P((char *, char *, int, char *));
static void t_output __P((char *, char *, int, char *));
static void svc_output __P((char *, char *, int, char *));
static void clnt_output __P((char *, char *, int, char *));
static int do_registers __P((int, char *[]));
d140 1
d142 5
a146 3
static int parseargs __P((int, char *[], struct commandline *));
static void usage __P((void));
static void options_usage __P((void));
a147 1
int
d251 1
a251 1
static void
d277 1
a277 1
static void
d317 1
a317 1
static void
d435 1
a435 1
static void
a467 1
static void
d517 1
a517 1
static void
d565 1
a565 1
static void
d673 1
a673 1
static void
d709 1
a709 1
static void
d735 1
a735 1
static void
d771 1
a771 1
static void
d813 2
a814 2
static int
do_registers(argc, argv)
d882 2
a883 2
	char *infile;
	char *outfile;
d918 1
a918 1
	int c;
d1113 1
a1113 1
static void
d1127 1
a1127 1
static void
@


1.5
log
@give actual cpp name that failed; obrien
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_main.c,v 1.4 1999/12/04 21:58:31 deraadt Exp $	*/
d35 1
a35 1
static char cvsid[] = "$OpenBSD: rpc_main.c,v 1.4 1999/12/04 21:58:31 deraadt Exp $";
d47 1
d54 1
d132 17
a148 8
static c_output __P((char *, char *, int, char *));
static h_output __P((char *, char *, int, char *));
static s_output __P((int, char **, char *, char *, int, char *, int, int));
static l_output __P((char *, char *, int, char *));
static t_output __P((char *, char *, int, char *));
static svc_output __P((char *, char *, int, char *));
static clnt_output __P((char *, char *, int, char *));
static do_registers __P((int, char **));
a150 1
static void clear_args __P((void));
d152 3
a154 5
static int parseargs __P((int, char **, struct commandline *));
static usage __P((void));
static options_usage __P((void));


d156 1
d260 1
a260 1
static
d286 1
a286 1
static
d326 1
a326 1
static
d444 1
a444 1
static
d477 1
d527 1
a527 1
static
d575 1
a575 1
static
d683 1
a683 1
static
d719 1
a719 1
static
d745 1
a745 1
static 
d781 1
a781 1
static 
d823 2
a824 2
static
int do_registers(argc, argv)
d892 2
a893 2
char *infile;
char *outfile;
d928 1
a928 1
	char c;
d1123 1
a1123 1
static
d1137 1
a1137 1
static
@


1.4
log
@oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_main.c,v 1.3 1997/10/11 21:10:41 deraadt Exp $	*/
d35 1
a35 1
static char cvsid[] = "$OpenBSD: rpc_main.c,v 1.3 1997/10/11 21:10:41 deraadt Exp $";
d307 1
a307 1
	fprintf( stderr, "cannot find any C preprocessor (cpp)\n" );
@


1.3
log
@s/inline/doinline/; christos
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
static char cvsid[] = "$OpenBSD$";
d88 1
a88 1
static char pathbuf[MAXPATHLEN + 1];
d1050 3
a1052 2
					(void) strcpy(pathbuf, argv[i]);
					(void) strcat(pathbuf, "/cpp");
@


1.2
log
@From NetBSD: merge of 960317
@
text
@d115 1
a115 1
int inline=INLINE;  /* length at which to start doing an inline. 3 = default
d1015 1
a1015 1
					inline = atoi(argv[i]);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: rpc_main.c,v 1.8 1995/08/29 23:05:53 cgd Exp $	*/
d35 1
a35 1
static char cvsid[] = "$Id: rpc_main.c,v 1.8 1995/08/29 23:05:53 cgd Exp $";
d42 2
d539 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
