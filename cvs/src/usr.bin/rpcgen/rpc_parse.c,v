head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.22
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.14
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.18
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.16
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.12
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.20
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.01.15.10.14.32;	author jasper;	state Exp;
branches;
next	1.19;
commitid	oNnDSVT5PSPEdENG;

1.19
date	2015.08.20.22.32.41;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	0Dp7Dy9FuNZesYo2;

1.18
date	2010.09.01.14.43.34;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.42;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.03.14.35.48;	author weingart;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.22.18.20.31;	author dhill;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.09.03.35.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.25.21.09.26;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.26.18.29.51;	author pvalchev;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.05.05.39.42;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.01.01.40.38;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.51;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.05.09.50.31;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.24.19.19.59;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.24.19.17.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.07.18.44.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.18.22.26.00;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.17.02.23.59;	author pvalchev;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.38.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.01;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Add support for parsing 'hyper' and 'quad' types, as per RFC4506.
From FreeBSD

ok millert@@
@
text
@/*	$OpenBSD: rpc_parse.c,v 1.19 2015/08/20 22:32:41 deraadt Exp $	*/
/*	$NetBSD: rpc_parse.c,v 1.5 1995/08/29 23:05:55 cgd Exp $	*/

/*
 * Copyright (c) 2010, Oracle America, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the "Oracle America, Inc." nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * rpc_parse.c, Parser for the RPC protocol compiler
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "rpc/types.h"
#include "rpc_scan.h"
#include "rpc_parse.h"
#include "rpc_util.h"

#define ARGNAME "arg"

static void isdefined(definition *);
static void def_struct(definition *);
static void def_program(definition *);
static void def_enum(definition *);
static void def_const(definition *);
static void def_union(definition *);
static void def_typedef(definition *);
static void get_declaration(declaration *, defkind);
static void get_prog_declaration(declaration *, defkind, int);
static void get_type(char **, char **, defkind);
static void unsigned_dec(char **);

/*
 * return the next definition you see
 */
definition *
get_definition(void)
{
	definition *defp;
	token tok;

	defp = malloc(sizeof(definition));
	get_token(&tok);
	switch (tok.kind) {
	case TOK_STRUCT:
		def_struct(defp);
		break;
	case TOK_UNION:
		def_union(defp);
		break;
	case TOK_TYPEDEF:
		def_typedef(defp);
		break;
	case TOK_ENUM:
		def_enum(defp);
		break;
	case TOK_PROGRAM:
		def_program(defp);
		break;
	case TOK_CONST:
		def_const(defp);
		break;
	case TOK_EOF:
		free(defp);
		return (NULL);
	default:
		error("definition keyword expected");
	}
	scan(TOK_SEMICOLON, &tok);
	isdefined(defp);
	return (defp);
}

static void
isdefined(defp)
	definition *defp;
{
	STOREVAL(&defined, defp);
}

static void
def_struct(defp)
	definition *defp;
{
	token tok;
	declaration dec;
	decl_list *decls;
	decl_list **tailp;

	defp->def_kind = DEF_STRUCT;

	scan(TOK_IDENT, &tok);
	defp->def_name = tok.str;
	scan(TOK_LBRACE, &tok);
	tailp = &defp->def.st.decls;
	do {
		get_declaration(&dec, DEF_STRUCT);
		decls = malloc(sizeof(decl_list));
		decls->decl = dec;
		*tailp = decls;
		tailp = &decls->next;
		scan(TOK_SEMICOLON, &tok);
		peek(&tok);
	} while (tok.kind != TOK_RBRACE);
	get_token(&tok);
	*tailp = NULL;
}

static void
def_program(defp)
	definition *defp;
{
	token tok;
	declaration dec;
	decl_list *decls;
	decl_list **tailp;
	version_list *vlist;
	version_list **vtailp;
	proc_list *plist;
	proc_list **ptailp;
	int num_args;
	bool_t isvoid = FALSE; /* whether first argument is void */
	defp->def_kind = DEF_PROGRAM;
	scan(TOK_IDENT, &tok);
	defp->def_name = tok.str;
	scan(TOK_LBRACE, &tok);
	vtailp = &defp->def.pr.versions;
	tailp = &defp->def.st.decls;
	scan(TOK_VERSION, &tok);
	do {
		scan(TOK_IDENT, &tok);
		vlist = malloc(sizeof(version_list));
		vlist->vers_name = tok.str;
		scan(TOK_LBRACE, &tok);
		ptailp = &vlist->procs;
		do {
			/* get result type */
			plist = malloc(sizeof(proc_list));
			get_type(&plist->res_prefix, &plist->res_type,
			    DEF_PROGRAM);
			if (streq(plist->res_type, "opaque")) {
				error("illegal result type");
			}
			scan(TOK_IDENT, &tok);
			plist->proc_name = tok.str;
			scan(TOK_LPAREN, &tok);
			/* get args - first one*/
			num_args = 1;
			isvoid = FALSE;
			/* type of DEF_PROGRAM in the first
			 * get_prog_declaration and DEF_STURCT in the next
			 * allows void as argument if it is the only argument
			 */
			get_prog_declaration(&dec, DEF_PROGRAM, num_args);
			if (streq(dec.type, "void"))
				isvoid = TRUE;
			decls = malloc(sizeof(decl_list));
			plist->args.decls = decls;
			decls->decl = dec;
			tailp = &decls->next;
			/* get args */
			while (peekscan(TOK_COMMA, &tok)) {
				num_args++;
				get_prog_declaration(&dec, DEF_STRUCT,
				    num_args);
				decls = malloc(sizeof(decl_list));
				decls->decl = dec;
				*tailp = decls;
				if (streq(dec.type, "void"))
					isvoid = TRUE;
				tailp = &decls->next;
			}
			/* multiple arguments are only allowed in newstyle */
			if (!newstyle && num_args > 1) {
				error("only one argument is allowed");
			}
			if (isvoid && num_args > 1) {
				error("illegal use of void in program definition");
			}
			*tailp = NULL;
			scan(TOK_RPAREN, &tok);
			scan(TOK_EQUAL, &tok);
			scan_num(&tok);
			scan(TOK_SEMICOLON, &tok);
			plist->proc_num = tok.str;
			plist->arg_num = num_args;
			*ptailp = plist;
			ptailp = &plist->next;
			peek(&tok);
		} while (tok.kind != TOK_RBRACE);
		*ptailp = NULL;
		*vtailp = vlist;
		vtailp = &vlist->next;
		scan(TOK_RBRACE, &tok);
		scan(TOK_EQUAL, &tok);
		scan_num(&tok);
		vlist->vers_num = tok.str;
		/* make the argument structure name for each arg*/
		for (plist = vlist->procs; plist != NULL;
		    plist = plist->next) {
			plist->args.argname = make_argname(plist->proc_name,
			    vlist->vers_num);
			/* free the memory ??*/
		}
		scan(TOK_SEMICOLON, &tok);
		scan2(TOK_VERSION, TOK_RBRACE, &tok);
	} while (tok.kind == TOK_VERSION);
	scan(TOK_EQUAL, &tok);
	scan_num(&tok);
	defp->def.pr.prog_num = tok.str;
	*vtailp = NULL;
}


static void
def_enum(defp)
	definition *defp;
{
	token tok;
	enumval_list *elist;
	enumval_list **tailp;

	defp->def_kind = DEF_ENUM;
	scan(TOK_IDENT, &tok);
	defp->def_name = tok.str;
	scan(TOK_LBRACE, &tok);
	tailp = &defp->def.en.vals;
	do {
		scan(TOK_IDENT, &tok);
		elist = malloc(sizeof(enumval_list));
		elist->name = tok.str;
		elist->assignment = NULL;
		scan3(TOK_COMMA, TOK_RBRACE, TOK_EQUAL, &tok);
		if (tok.kind == TOK_EQUAL) {
			scan_num(&tok);
			elist->assignment = tok.str;
			scan2(TOK_COMMA, TOK_RBRACE, &tok);
		}
		*tailp = elist;
		tailp = &elist->next;
	} while (tok.kind != TOK_RBRACE);
	*tailp = NULL;
}

static void
def_const(defp)
	definition *defp;
{
	token tok;

	defp->def_kind = DEF_CONST;
	scan(TOK_IDENT, &tok);
	defp->def_name = tok.str;
	scan(TOK_EQUAL, &tok);
	scan2(TOK_IDENT, TOK_STRCONST, &tok);
	defp->def.co = tok.str;
}

static void
def_union(defp)
	definition *defp;
{
	token tok;
	declaration dec;
	case_list *cases;
	case_list **tailp;
	int flag;

	defp->def_kind = DEF_UNION;
	scan(TOK_IDENT, &tok);
	defp->def_name = tok.str;
	scan(TOK_SWITCH, &tok);
	scan(TOK_LPAREN, &tok);
	get_declaration(&dec, DEF_UNION);
	defp->def.un.enum_decl = dec;
	tailp = &defp->def.un.cases;
	scan(TOK_RPAREN, &tok);
	scan(TOK_LBRACE, &tok);
	scan(TOK_CASE, &tok);
	while (tok.kind == TOK_CASE) {
		scan2(TOK_IDENT, TOK_CHARCONST, &tok);
		cases = malloc(sizeof(case_list));
		cases->case_name = tok.str;
		scan(TOK_COLON, &tok);
		/* now peek at next token */
		flag=0;
		if (peekscan(TOK_CASE,&tok)) {
			do {
				scan2(TOK_IDENT, TOK_CHARCONST, &tok);
				cases->contflag=1;	/* continued case statement */
				*tailp = cases;
				tailp = &cases->next;
				cases = malloc(sizeof(case_list));
				cases->case_name = tok.str;
				scan(TOK_COLON, &tok);
			} while (peekscan(TOK_CASE,&tok));
		} else if (flag) {
			*tailp = cases;
			tailp = &cases->next;
			cases = malloc(sizeof(case_list));
		}
		get_declaration(&dec, DEF_UNION);
		cases->case_decl = dec;
		cases->contflag=0;		/* no continued case statement */
		*tailp = cases;
		tailp = &cases->next;
		scan(TOK_SEMICOLON, &tok);

		scan3(TOK_CASE, TOK_DEFAULT, TOK_RBRACE, &tok);
	}
	*tailp = NULL;

	if (tok.kind == TOK_DEFAULT) {
		scan(TOK_COLON, &tok);
		get_declaration(&dec, DEF_UNION);
		defp->def.un.default_decl = malloc(sizeof(declaration));
		*defp->def.un.default_decl = dec;
		scan(TOK_SEMICOLON, &tok);
		scan(TOK_RBRACE, &tok);
	} else {
		defp->def.un.default_decl = NULL;
	}
}

static char *reserved_words[] = {
	"array",
	"bytes",
	"destroy",
	"free",
	"getpos",
	"inline",
	"pointer",
	"reference",
	"setpos",
	"sizeof",
	"union",
	"vector",
	NULL
};

static char *reserved_types[] = {
	"opaque",
	"string",
	NULL
};

/* check that the given name is not one that would eventually result in
   xdr routines that would conflict with internal XDR routines. */
static void
check_type_name(char *name, int new_type)
{
	int i;
	char tmp[100];

	for (i = 0; reserved_words[i] != NULL; i++) {
		if (strcmp(name, reserved_words[i]) == 0) {
			snprintf(tmp, sizeof tmp,
			    "illegal (reserved) name :\'%s\' in type definition", name);
			error(tmp);
		}
	}
	if (new_type) {
		for (i = 0; reserved_types[i] != NULL; i++) {
			if (strcmp(name, reserved_types[i]) == 0) {
				snprintf(tmp, sizeof tmp,
				    "illegal (reserved) name :\'%s\' in"
				    " type definition", name);
				error(tmp);
			}
		}
	}
}

static void
def_typedef(defp)
	definition *defp;
{
	declaration dec;

	defp->def_kind = DEF_TYPEDEF;
	get_declaration(&dec, DEF_TYPEDEF);
	defp->def_name = dec.name;
	check_type_name(dec.name, 1);
	defp->def.ty.old_prefix = dec.prefix;
	defp->def.ty.old_type = dec.type;
	defp->def.ty.rel = dec.rel;
	defp->def.ty.array_max = dec.array_max;
}

static void
get_declaration(dec, dkind)
	declaration *dec;
	defkind dkind;
{
	token tok;

	get_type(&dec->prefix, &dec->type, dkind);
	dec->rel = REL_ALIAS;
	if (streq(dec->type, "void")) {
		return;
	}

	check_type_name(dec->type, 0);

	scan2(TOK_STAR, TOK_IDENT, &tok);
	if (tok.kind == TOK_STAR) {
		dec->rel = REL_POINTER;
		scan(TOK_IDENT, &tok);
	}
	dec->name = tok.str;
	if (peekscan(TOK_LBRACKET, &tok)) {
		if (dec->rel == REL_POINTER) {
			error("no array-of-pointer declarations -- use typedef");
		}
		dec->rel = REL_VECTOR;
		scan_num(&tok);
		dec->array_max = tok.str;
		scan(TOK_RBRACKET, &tok);
	} else if (peekscan(TOK_LANGLE, &tok)) {
		if (dec->rel == REL_POINTER) {
			error("no array-of-pointer declarations -- use typedef");
		}
		dec->rel = REL_ARRAY;
		if (peekscan(TOK_RANGLE, &tok)) {
			dec->array_max = "~0";	/* unspecified size, use max */
		} else {
			scan_num(&tok);
			dec->array_max = tok.str;
			scan(TOK_RANGLE, &tok);
		}
	}
	if (streq(dec->type, "opaque")) {
		if (dec->rel != REL_ARRAY && dec->rel != REL_VECTOR) {
			error("array declaration expected");
		}
	} else if (streq(dec->type, "string")) {
		if (dec->rel != REL_ARRAY) {
			error("variable-length array declaration expected");
		}
	}
}

static void
get_prog_declaration(dec, dkind, num)
	declaration *dec;
	defkind dkind;
	int num;  /* arg number */
{
	token tok;

	if (dkind == DEF_PROGRAM) {
		peek(&tok);
		if (tok.kind == TOK_RPAREN) { /* no arguments */
			dec->rel = REL_ALIAS;
			dec->type = "void";
			dec->prefix = NULL;
			dec->name = NULL;
			return;
		}
	}
	get_type(&dec->prefix, &dec->type, dkind);
	dec->rel = REL_ALIAS;
	if (peekscan(TOK_IDENT, &tok)) {  /* optional name of argument */
		dec->name = (char *)strdup(tok.str);
		if (dec->name == NULL)
			error("out of memory");
	} else {
		/* default name of argument */
		if (asprintf(&dec->name, "%s%d", ARGNAME, num) == -1)
			error("out of memory");
	}

	if (streq(dec->type, "void"))
		return;

	if (streq(dec->type, "opaque"))
		error("opaque -- illegal argument type");

	if (peekscan(TOK_STAR, &tok)) {
		if (streq(dec->type, "string"))
			error("pointer to string not allowed in program arguments\n");

		dec->rel = REL_POINTER;
		if (peekscan(TOK_IDENT, &tok)) { /* optional name of argument */
			dec->name = (char *)strdup(tok.str);
			if (dec->name == NULL)
				error("out of memory");
		}
	}
	if (peekscan(TOK_LANGLE, &tok)) {
		if (!streq(dec->type, "string"))
			error("arrays cannot be declared as arguments to "
			    "procedures -- use typedef");
		dec->rel = REL_ARRAY;
		if (peekscan(TOK_RANGLE, &tok)) {
			dec->array_max = "~0";/* unspecified size, use max */
		} else {
			scan_num(&tok);
			dec->array_max = tok.str;
			scan(TOK_RANGLE, &tok);
		}
	}
	if (streq(dec->type, "string")) {
		/* .x specifies just string as
		 * type of argument
		 * - make it string<>
		 */
		if (dec->rel != REL_ARRAY) {
			dec->rel = REL_ARRAY;
			dec->array_max = "~0";/* unspecified size, use max */
		}
	}
}

static void
get_type(prefixp, typep, dkind)
	char **prefixp;
	char **typep;
	defkind dkind;
{
	token tok;

	*prefixp = NULL;
	get_token(&tok);
	switch (tok.kind) {
	case TOK_IDENT:
		*typep = tok.str;
		break;
	case TOK_STRUCT:
	case TOK_ENUM:
	case TOK_UNION:
		*prefixp = tok.str;
		scan(TOK_IDENT, &tok);
		*typep = tok.str;
		break;
	case TOK_UNSIGNED:
		unsigned_dec(typep);
		break;
	case TOK_SHORT:
		*typep = "short";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_LONG:
		*typep = "long";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_HYPER:
		*typep = "int64_t";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_VOID:
		if (dkind != DEF_UNION && dkind != DEF_PROGRAM) {
			error("voids allowed only inside union and program definitions with one argument");
		}
		*typep = tok.str;
		break;
	case TOK_STRING:
	case TOK_OPAQUE:
	case TOK_CHAR:
	case TOK_INT:
	case TOK_FLOAT:
	case TOK_DOUBLE:
	case TOK_QUAD:
	case TOK_BOOL:
		*typep = tok.str;
		break;
	default:
		error("expected type specifier");
	}
}

static void
unsigned_dec(typep)
	char **typep;
{
	token tok;

	peek(&tok);
	switch (tok.kind) {
	case TOK_CHAR:
		get_token(&tok);
		*typep = "u_char";
		break;
	case TOK_SHORT:
		get_token(&tok);
		*typep = "u_short";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_LONG:
		get_token(&tok);
		*typep = "u_long";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_HYPER:
		get_token(&tok);
		*typep = "u_int64_t";
		(void) peekscan(TOK_INT, &tok);
		break;
	case TOK_INT:
		get_token(&tok);
		*typep = "u_int";
		break;
	default:
		*typep = "u_int";
		break;
	}
}
@


1.19
log
@Do not cast result of malloc/calloc/realloc* if stdlib.h is in scope
ok krw millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.18 2010/09/01 14:43:34 millert Exp $	*/
d574 4
d590 1
d619 5
@


1.18
log
@Oracle has re-licensed sunrpc under a three-clause BSD license.
Update our sources appropriately.  OK deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.17 2009/10/27 23:59:42 deraadt Exp $	*/
d69 1
a69 1
	defp = ALLOC(definition);
d125 1
a125 1
		decls = ALLOC(decl_list);
d159 1
a159 1
		vlist = ALLOC(version_list);
d165 1
a165 1
			plist = ALLOC(proc_list);
d184 1
a184 1
			decls = ALLOC(decl_list);
d193 1
a193 1
				decls = ALLOC(decl_list);
d257 1
a257 1
		elist = ALLOC(enumval_list);
d309 1
a309 1
		cases = ALLOC(case_list);
d320 1
a320 1
				cases = ALLOC(case_list);
d327 1
a327 1
			cases = ALLOC(case_list);
d343 1
a343 1
		defp->def.un.default_decl = ALLOC(declaration);
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.16 2007/10/03 14:35:48 weingart Exp $	*/
d3 1
d5 1
a5 15
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user or with the express written consent of
 * Sun Microsystems, Inc.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
d7 3
a9 3
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
d11 9
a19 3
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
d21 12
a32 3
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
a36 1
 * Copyright (C) 1987 Sun Microsystems, Inc.
@


1.16
log
@Some -Wall cleanup to help fix other bugs.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.15 2006/03/22 18:20:31 dhill Exp $	*/
a31 4

#ifndef lint
static const char sccsid[] = "@@(#)rpc_parse.c 1.8 89/02/22 (C) 1987 SMI";
#endif
@


1.15
log
@NetBSD  - plug leak in generate_guard()
        - plug leak in h_output(), coverity cid 100
NetBSD plug leak, coverity cid 98.
NetBSD plug leak, coverity cid 94.

ok ray@@ jaredy@@ moritz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.14 2003/07/09 03:35:21 deraadt Exp $	*/
d34 1
a34 1
static char sccsid[] = "@@(#)rpc_parse.c 1.8 89/02/22 (C) 1987 SMI";
@


1.14
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.13 2003/06/25 21:09:26 deraadt Exp $	*/
d94 1
@


1.13
log
@protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.12 2003/04/26 18:29:51 pvalchev Exp $	*/
d379 1
a379 3
check_type_name(name, new_type)
	int new_type;
	char *name;
@


1.12
log
@get rid of incorrectly sized buffer by using strdup/asprintf,
also simplifies things; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.11 2002/07/05 05:39:42 deraadt Exp $	*/
d67 1
a67 1
get_definition()
@


1.11
log
@allocation mischecks by cloder@@acm.org; lots of other cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.10 2002/06/01 01:40:38 deraadt Exp $	*/
a480 1
	char name[10]; /* argument name */
d494 5
a498 3
	if (peekscan(TOK_IDENT, &tok))  /* optional name of argument */
		strlcpy(name, tok.str, sizeof name);
	else {
d500 2
a501 1
		snprintf(name, sizeof name, "%s%d", ARGNAME, num);
a502 4

	dec->name = (char *)strdup(name);
	if (dec->name == NULL)
		error("out of memory");
@


1.10
log
@cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.9 2002/02/16 21:27:51 millert Exp $	*/
d51 11
a61 11
static isdefined(definition *);
static def_struct(definition *);
static def_program(definition *);
static def_enum(definition *);
static def_const(definition *);
static def_union(definition *);
static def_typedef(definition *);
static get_declaration(declaration *, defkind);
static get_prog_declaration(declaration *, defkind, int);
static get_type(char **, char **, defkind);
static unsigned_dec(char **);
d103 1
a103 1
static
d110 1
a110 1
static
d138 1
a138 1
static
d169 1
a169 1
				 DEF_PROGRAM);
d185 1
a185 1
			  isvoid = TRUE;
d192 9
a200 9
			  num_args++;
			  get_prog_declaration(&dec, DEF_STRUCT,
					       num_args);
			  decls = ALLOC(decl_list);
			  decls->decl = dec;
			  *tailp = decls;
			  if (streq(dec.type, "void"))
			    isvoid = TRUE;
			  tailp = &decls->next;
d203 2
a204 2
			if( !newstyle && num_args > 1 ) {
			  error("only one argument is allowed" );
d207 1
a207 1
			  error("illegal use of void in program definition");
d228 1
a228 1
		for(plist = vlist->procs; plist != NULL;
d231 1
a231 1
							   vlist->vers_num);
d244 1
a244 1
static
d274 1
a274 1
static
d288 1
a288 1
static
d292 60
a351 68
  token tok;
  declaration dec;
  case_list *cases,*tcase;
  case_list **tailp;
  int flag;

  defp->def_kind = DEF_UNION;
  scan(TOK_IDENT, &tok);
  defp->def_name = tok.str;
  scan(TOK_SWITCH, &tok);
  scan(TOK_LPAREN, &tok);
  get_declaration(&dec, DEF_UNION);
  defp->def.un.enum_decl = dec;
  tailp = &defp->def.un.cases;
  scan(TOK_RPAREN, &tok);
  scan(TOK_LBRACE, &tok);
  scan(TOK_CASE, &tok);
  while (tok.kind == TOK_CASE) {
    scan2(TOK_IDENT, TOK_CHARCONST, &tok);
    cases = ALLOC(case_list);
    cases->case_name = tok.str;
    scan(TOK_COLON, &tok);
    /* now peek at next token */
    flag=0;
    if(peekscan(TOK_CASE,&tok))
      {

	do
	  {
	    scan2(TOK_IDENT, TOK_CHARCONST, &tok);
	    cases->contflag=1;	/* continued case statement */
	    *tailp = cases;
	    tailp = &cases->next;
	    cases = ALLOC(case_list);
	    cases->case_name = tok.str;
	    scan(TOK_COLON, &tok);

	  } while (peekscan(TOK_CASE,&tok));
      }
    else
      if(flag)
	{

	  *tailp = cases;
	  tailp = &cases->next;
	  cases = ALLOC(case_list);
	}

    get_declaration(&dec, DEF_UNION);
    cases->case_decl = dec;
    cases->contflag=0;		/* no continued case statement */
    *tailp = cases;
    tailp = &cases->next;
    scan(TOK_SEMICOLON, &tok);

    scan3(TOK_CASE, TOK_DEFAULT, TOK_RBRACE, &tok);
  }
  *tailp = NULL;
  if (tok.kind == TOK_DEFAULT) {
    scan(TOK_COLON, &tok);
    get_declaration(&dec, DEF_UNION);
    defp->def.un.default_decl = ALLOC(declaration);
    *defp->def.un.default_decl = dec;
    scan(TOK_SEMICOLON, &tok);
    scan(TOK_RBRACE, &tok);
  } else {
    defp->def.un.default_decl = NULL;
  }
d378 25
a402 23
static check_type_name( name, new_type )
int new_type;
char *name;
{
  int i;
  char tmp[100];

  for( i = 0; reserved_words[i] != NULL; i++ ) {
    if( strcmp( name, reserved_words[i] ) == 0 ) {
      snprintf(tmp, sizeof tmp,
	      "illegal (reserved) name :\'%s\' in type definition", name );
      error(tmp);
    }
  }
  if( new_type ) {
    for( i = 0; reserved_types[i] != NULL; i++ ) {
      if( strcmp( name, reserved_types[i] ) == 0 ) {
	snprintf(tmp, sizeof tmp,
		"illegal (reserved) name :\'%s\' in type definition", name );
	error(tmp);
      }
    }
  }
d405 1
a405 1
static
d414 1
a414 1
	check_type_name( dec.name, 1 );
d421 1
a421 1
static
d434 1
a434 1
	check_type_name( dec->type, 0 );
d474 1
a474 1
static
d478 1
a478 1
        int num;  /* arg number */
d484 8
a491 8
	  peek(&tok);
	  if (tok.kind == TOK_RPAREN) { /* no arguments */
	    	dec->rel = REL_ALIAS;
		dec->type = "void";
		dec->prefix = NULL;
		dec->name = NULL;
		return;
	      }
d497 4
a500 2
	else
		snprintf(name, sizeof name, "%s%d", ARGNAME, num); /* default name of argument */
d503 2
d506 1
a506 1
	if (streq(dec->type, "void")) {
a507 1
	}
d509 1
a509 1
	if (streq(dec->type, "opaque")) {
d511 1
a511 1
	}
d513 3
a515 3
	  if (streq(dec->type, "string")) {
	    error("pointer to string not allowed in program arguments\n");
	  }
d517 10
a526 7
		if (peekscan(TOK_IDENT, &tok))  /* optional name of argument */
		  dec->name = (char *)strdup(tok.str);
      }
	  if (peekscan(TOK_LANGLE, &tok)) {
	    if (!streq(dec->type, "string")) {
	      error("arrays cannot be declared as arguments to procedures -- use typedef");
	    }
d537 5
a541 4
		if (dec->rel != REL_ARRAY) {  /* .x specifies just string as
					       * type of argument
					       * - make it string<>
					       */
d548 1
a548 3


static
d600 1
a600 1
static
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.8 2001/12/05 09:50:31 deraadt Exp $	*/
d395 1
a395 1
      sprintf(tmp,
d403 1
a403 1
	sprintf(tmp,
d502 1
a502 1
		strcpy(name, tok.str);
d504 1
a504 1
		sprintf(name, "%s%d", ARGNAME, num); /* default name of argument */
@


1.8
log
@KNF, and remove part of the TLI garbage
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.6 2001/11/24 19:17:47 deraadt Exp $	*/
d51 11
a61 11
static isdefined __P((definition *));
static def_struct __P((definition *));
static def_program __P((definition *));
static def_enum __P((definition *));
static def_const __P((definition *));
static def_union __P((definition *));
static def_typedef __P((definition *));
static get_declaration __P((declaration *, defkind));
static get_prog_declaration __P((declaration *, defkind, int));
static get_type __P((char **, char **, defkind));
static unsigned_dec __P((char **));
@


1.7
log
@argh!  i messed something up!
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.5 2001/11/07 18:44:28 deraadt Exp $	*/
d38 1
a38 1
 * rpc_parse.c, Parser for the RPC protocol compiler 
d168 1
a168 1
			get_type(&plist->res_prefix, &plist->res_type, 
d179 1
a179 1
			/* type of DEF_PROGRAM in the first 
d191 1
a191 1
			while(peekscan(TOK_COMMA, &tok)) {
d193 1
a193 1
			  get_prog_declaration(&dec, DEF_STRUCT, 
d206 1
a206 1
			if (isvoid && num_args > 1) { 
d228 1
a228 1
		for(plist = vlist->procs; plist != NULL; 
d231 1
a231 1
							   vlist->vers_num); 
d319 1
a319 1
	do 
d328 2
a329 2
      
	  }while(peekscan(TOK_CASE,&tok));
d362 1
a362 1
static char* reserved_words[] = {
d378 1
a378 1
static char* reserved_types[] = {
d388 1
a388 1
char* name;
d395 1
a395 1
      sprintf(tmp, 
d403 1
a403 1
	sprintf(tmp, 
d489 1
a489 1
	if (dkind == DEF_PROGRAM) { 
d503 1
a503 1
	else 
d506 2
a507 2
	dec->name = (char *)strdup(name); 
	
d515 1
a515 1
	if (peekscan(TOK_STAR, &tok)) { 
d538 1
a538 1
					       * type of argument 
@


1.6
log
@half finished KNF
@
text
@d191 1
a191 1
			while (peekscan(TOK_COMMA, &tok)) {
d329 1
a329 1
	  } while (peekscan(TOK_CASE,&tok));
d362 1
a362 1
static char *reserved_words[] = {
d378 1
a378 1
static char *reserved_types[] = {
d388 1
a388 1
char *name;
d507 1
a507 1

@


1.5
log
@rpcgen is not nearly KNF, but it now generates close to KNF code
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.4 2001/07/18 22:26:00 deraadt Exp $	*/
d191 1
a191 1
			while(peekscan(TOK_COMMA, &tok)) {
d329 1
a329 1
	  }while(peekscan(TOK_CASE,&tok));
d362 1
a362 1
static char* reserved_words[] = {
d378 1
a378 1
static char* reserved_types[] = {
d388 1
a388 1
char* name;
d507 1
a507 1
	
@


1.4
log
@Uhmm, nope, this broke everything
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.2 1996/06/26 05:38:37 deraadt Exp $	*/
d338 1
a338 1
	};
@


1.3
log
@-Wall cleanup; ok deraadt
@
text
@d51 11
a61 11
static void isdefined __P((definition *));
static void def_struct __P((definition *));
static void def_program __P((definition *));
static void def_enum __P((definition *));
static void def_const __P((definition *));
static void def_union __P((definition *));
static void def_typedef __P((definition *));
static void get_declaration __P((declaration *, defkind));
static void get_prog_declaration __P((declaration *, defkind, int));
static void get_type __P((char **, char **, defkind));
static void unsigned_dec __P((char **));
d103 1
a103 1
static void
d110 1
a110 1
static void
d138 1
a138 1
static void
d244 1
a244 1
static void
d274 1
a274 1
static void
d288 1
a288 1
static void
d294 1
a294 1
  case_list *cases;
d386 3
a388 4
static void
check_type_name( name, new_type )
	int new_type;
	char* name;
d411 1
a411 1
static void
d427 1
a427 1
static void
d480 1
a480 1
static void
d549 1
a549 1
static void
d601 1
a601 1
static void
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc_parse.c,v 1.5 1995/08/29 23:05:55 cgd Exp $	*/
d51 11
a61 11
static isdefined __P((definition *));
static def_struct __P((definition *));
static def_program __P((definition *));
static def_enum __P((definition *));
static def_const __P((definition *));
static def_union __P((definition *));
static def_typedef __P((definition *));
static get_declaration __P((declaration *, defkind));
static get_prog_declaration __P((declaration *, defkind, int));
static get_type __P((char **, char **, defkind));
static unsigned_dec __P((char **));
d103 1
a103 1
static
d110 1
a110 1
static
d138 1
a138 1
static
d244 1
a244 1
static
d274 1
a274 1
static
d288 1
a288 1
static
d294 1
a294 1
  case_list *cases,*tcase;
d386 4
a389 3
static check_type_name( name, new_type )
int new_type;
char* name;
d412 1
a412 1
static
d428 1
a428 1
static
d481 1
a481 1
static
d550 1
a550 1
static
d602 1
a602 1
static
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
