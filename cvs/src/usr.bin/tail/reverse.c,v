head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.6
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.22
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.20
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.16
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.14
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.12
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.10
	OPENBSD_5_0:1.19.0.8
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.6
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.10
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.8
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2015.11.19.17.50.04;	author tedu;	state Exp;
branches;
next	1.20;
commitid	nAQIOMPhgiIlY8Mk;

1.20
date	2015.07.22.16.37.04;	author tobias;	state Exp;
branches;
next	1.19;
commitid	iFvBoU01BhotuPza;

1.19
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.29.12.31.28;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.24.17.10.02;	author kjell;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.22.19.43.29;	author kjell;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.16.19.48.21;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.01.11.12.59;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.17.02.23.58;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.17.00.27.21;	author pjanzen;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.12.10.18.37;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.23.17.04.46;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	99.08.04.18.24.10;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.04.29.04.18.43;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.02.03.02.09.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.12.23.43.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.40.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.21
log
@another try to allow tailing multiple files. maybe it works?
commit now to allow people to test.
from Martijn van Duren
@
text
@/*	$OpenBSD: reverse.c,v 1.20 2015/07/22 16:37:04 tobias Exp $	*/
/*	$NetBSD: reverse.c,v 1.6 1994/11/23 07:42:10 jtc Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Edward Sze-Tyan Wang.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/stat.h>

#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "extern.h"

static void r_buf(FILE *);
static int r_reg(struct tailfile *, enum STYLE, off_t);

#define COPYCHAR(tf, ch)				\
	do {						\
		if ((ch = getc(tf->fp)) == EOF) {	\
			ierr(tf->fname);		\
			return (0);			\
		}					\
		if (putchar(ch) == EOF) {		\
			oerr();				\
			return (0);			\
		}					\
	} while (0)

/*
 * reverse -- display input in reverse order by line.
 *
 * There are six separate cases for this -- regular and non-regular
 * files by bytes, lines or the whole file.
 *
 * BYTES	display N bytes
 *	REG	reverse scan and display the lines
 *	NOREG	cyclically read characters into a wrap-around buffer
 *
 * LINES	display N lines
 *	REG	reverse scan and display the lines
 *	NOREG	cyclically read lines into a wrap-around array of buffers
 *
 * FILE		display the entire file
 *	REG	reverse scan and display the lines
 *	NOREG	cyclically read input into a linked list of buffers
 */
void
reverse(struct tailfile *tf, int nfiles, enum STYLE style, off_t off)
{
	int i;

	if (style != REVERSE && off == 0)
		return;

	for (i = 0; i < nfiles; i++) {
		if (nfiles > 1)
			printfname(tf[i].fname);
		if (!S_ISREG(tf[i].sb.st_mode) ||
		    r_reg(&(tf[i]), style, off) != 0) {
			switch(style) {
			case FBYTES:
			case RBYTES:
				(void)bytes(&(tf[i]), off);
				break;
			case FLINES:
			case RLINES:
				(void)lines(&(tf[i]), off);
				break;
			case REVERSE:
				r_buf(tf[i].fp);
				break;
			default:
				err(1, "Unsupported style");
			}
		}
	}
}

/*
 * r_reg -- display a regular file in reverse order by line.
 */
static int
r_reg(struct tailfile *tf, enum STYLE style, off_t off)
{
	off_t start, pos, end;
	int ch;

	end = tf->sb.st_size;
	if (end == 0)
		return (0);

	/* Position before char, ignore last char whether newline or not */
	pos = end-2;
	ch = EOF;
	start = 0;

	if (style == RBYTES && off < end)
		start = end - off;

	for (; pos >= start; pos--) {
		/* A seek per char isn't a problem with a smart stdio */
		if (fseeko(tf->fp, pos, SEEK_SET) != 0) {
			ierr(tf->fname);
			return (0);
		}
		if ((ch = getc(tf->fp)) == '\n') {
			while (--end > pos) 
				COPYCHAR(tf, ch);
			end++;
			if (style == RLINES && --off == 0)
				break;
		}
		else if (ch == EOF) {
			ierr(tf->fname);
			return (0);
		}
	}
	if (pos < start) {
		if (ch != EOF && ungetc(ch, tf->fp) == EOF) {
			ierr(tf->fname);
			return (0);
		}
		while (--end >= start)
			COPYCHAR(tf, ch);
	}
	return (0);
}

#define	BSZ	(128 * 1024)
struct bf {
	struct bf *next;
	struct bf *prev;
	size_t len;
	char l[BSZ];
};

/*
 * r_buf -- display a non-regular file in reverse order by line.
 *
 * This is the function that saves the entire input, storing the data in a
 * doubly linked list of buffers and then displays them in reverse order.
 * It has the usual nastiness of trying to find the newlines, as there's no
 * guarantee that a newline occurs anywhere in the file, let alone in any
 * particular buffer.  If we run out of memory, input is discarded (and the
 * user warned).
 */
static void
r_buf(FILE *fp)
{
	struct bf *mark, *tr, *tl = NULL;
	int ch;
	size_t len, llen;
	char *p;
	off_t enomem;

	for (mark = NULL, enomem = 0;;) {
		/*
		 * Allocate a new block and link it into place in a doubly
		 * linked list.  If out of memory, toss the LRU block and
		 * keep going.
		 */
		if (enomem || (tl = malloc(sizeof(*tl))) == NULL) {
			if (!mark)
				err(1, NULL);
			tl = enomem ? tl->next : mark;
			enomem += tl->len;
		} else if (mark) {
			tl->next = mark;
			tl->prev = mark->prev;
			mark->prev->next = tl;
			mark->prev = tl;
		} else {
			mark = tl;
			mark->next = mark->prev = mark;
		}

		if (!enomem)
			tl->len = 0;

		/* Fill the block with input data. */
		for (p = tl->l, len = 0;
		    len < BSZ && (ch = getc(fp)) != EOF; ++len)
			*p++ = ch;

		/*
		 * If no input data for this block and we tossed some data,
		 * recover it.
		 */
		if (!len) {
			if (enomem)
				enomem -= tl->len;
			tl = tl->prev;
			break;
		}

		tl->len = len;
		if (ch == EOF)
			break;
	}

	if (enomem) {
		(void)fprintf(stderr,
		    "tail: warning: %lld bytes discarded\n", (long long)enomem);
		rval = 1;
	}

	/*
	 * Step through the blocks in the reverse order read.  The last char
	 * is special, ignore whether newline or not.
	 */
	for (mark = tl;;) {
		for (p = tl->l + (len = tl->len) - 1, llen = 0; len--;
		    --p, ++llen)
			if (*p == '\n') {
				if (llen) {
					WR(p + 1, llen);
					llen = 0;
				}
				if (tl == mark)
					continue;
				for (tr = tl->next; tr->len; tr = tr->next) {
					WR(tr->l, tr->len);
					tr->len = 0;
					if (tr == mark)
						break;
				}
			}
		tl->len = llen;
		if ((tl = tl->prev) == mark)
			break;
	}
	tl = tl->next;
	if (tl->len) {
		WR(tl->l, tl->len);
		tl->len = 0;
	}
	while ((tl = tl->next)->len) {
		WR(tl->l, tl->len);
		tl->len = 0;
	}

	tl->prev->next = NULL;
	while (tl != NULL) {
		tr = tl->next;
		free(tl);
		tl = tr;
	}
}
@


1.20
log
@Fix memory leak when tail -r is used with anything but regular files.

ok schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.19 2009/10/27 23:59:44 deraadt Exp $	*/
d46 1
a46 1
static int r_reg(FILE *, enum STYLE, off_t, struct stat *);
d48 1
a48 1
#define COPYCHAR(fp, ch)				\
d50 2
a51 2
		if ((ch = getc(fp)) == EOF) {		\
			ierr();				\
d79 1
a79 1
reverse(FILE *fp, enum STYLE style, off_t off, struct stat *sbp)
d81 2
d86 20
a105 13
	if (!S_ISREG(sbp->st_mode) || r_reg(fp, style, off, sbp) != 0)
		switch(style) {
		case FBYTES:
		case RBYTES:
			(void)bytes(fp, off);
			break;
		case FLINES:
		case RLINES:
			(void)lines(fp, off);
			break;
		case REVERSE:
			r_buf(fp);
			break;
d107 1
d114 1
a114 1
r_reg(FILE *fp, enum STYLE style, off_t off, struct stat *sbp)
d119 1
a119 1
	end = sbp->st_size;
d133 2
a134 2
		if (fseeko(fp, pos, SEEK_SET) != 0) {
			ierr();
d137 1
a137 1
		if ((ch = getc(fp)) == '\n') {
d139 1
a139 1
				COPYCHAR(fp, ch);
d145 1
a145 1
			ierr();
d150 2
a151 2
		if (ch != EOF && ungetc(ch, fp) == EOF) {
			ierr();
d155 1
a155 1
			COPYCHAR(fp, ch);
@


1.19
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.18 2007/09/29 12:31:28 otto Exp $	*/
d150 2
a151 1
typedef struct bf {
d155 2
a156 2
	char *l;
} BF;
d171 1
a171 1
	BF *mark, *tr, *tl = NULL;
a176 1
#define	BSZ	(128 * 1024)
d183 1
a183 2
		if (enomem || (tl = malloc(sizeof(BF))) == NULL ||
		    (tl->l = malloc(BSZ)) == NULL) {
d261 7
@


1.18
log
@unneeded includes and whitespace police; from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.17 2006/03/24 17:10:02 kjell Exp $	*/
a34 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)reverse.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: reverse.c,v 1.17 2006/03/24 17:10:02 kjell Exp $";
#endif /* not lint */
@


1.17
log
@ANSIfy. Ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.16 2006/03/22 19:43:29 kjell Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.16 2006/03/22 19:43:29 kjell Exp $";
a42 1
#include <sys/param.h>
a43 1
#include <sys/mman.h>
a45 2
#include <errno.h>
#include <limits.h>
a47 1
#include <string.h>
@


1.16
log
@Clean up some lint and -Wall.
Changed many signed types ->size_t for consistency. Also, fix
some realloc usage.

Original from <jasonrcrawford at gmail.com> (ok ray@@)
Additions and additional cleanup to fix some off_t -> size_t issue by me.

"looks good" otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.15 2004/02/16 19:48:21 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.15 2004/02/16 19:48:21 otto Exp $";
d91 1
a91 5
reverse(fp, style, off, sbp)
	FILE *fp;
	enum STYLE style;
	off_t off;
	struct stat *sbp;
d180 1
a180 2
r_buf(fp)
	FILE *fp;
@


1.15
log
@make -b and -c work with large offsets; tweak from millert@@
ok henning@@ itojun@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.14 2003/07/01 11:12:59 henning Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.14 2003/07/01 11:12:59 henning Exp $";
d169 1
a169 1
	int len;
d188 2
a189 1
	int ch, len, llen;
@


1.14
log
@rewrite to not use mmap(2). solves a bunch of issues:
- No more I/O related SEGVs (PR 2337?).
- Performance linear to size of output, not input file size, even for very large files.
  Same for -r.
- Reverse tail also works for very large files.
- Very large values of n possible, even for very large files. Same for -r.

work by Otto Moerbeek <otto@@drijf.net>
tested by and ok millert@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.13 2003/06/03 02:56:17 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.13 2003/06/03 02:56:17 millert Exp $";
d58 1
a58 1
static int r_reg(FILE *, enum STYLE, long, struct stat *);
d94 1
a94 1
	long off;
d120 1
a120 1
r_reg(FILE *fp, enum STYLE style, long off, struct stat *sbp)
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.12 2002/02/16 21:27:54 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.12 2002/02/16 21:27:54 millert Exp $";
d60 12
d79 1
a79 1
 *	REG	mmap the file and display the lines
d83 1
a83 1
 *	REG	mmap the file and display the lines
d87 1
a87 1
 *	REG	mmap the file and display the lines
d120 1
a120 5
r_reg(fp, style, off, sbp)
	FILE *fp;
	enum STYLE style;
	long off;
	struct stat *sbp;
d122 2
a123 4
	off_t size;
	int llen;
	char *p;
	char *start;
d125 2
a126 1
	if (!(size = sbp->st_size))
d129 19
a147 18
	if (size > SIZE_T_MAX)
		return (1);

	if ((start = mmap(NULL, (size_t)size, PROT_READ, MAP_PRIVATE,
	    fileno(fp), (off_t)0)) == MAP_FAILED)
		return (1);
	p = start + size - 1;

	if (style == RBYTES && off < size)
		size = off;

	/* Last char is special, ignore whether newline or not. */
	for (llen = 1; --size; ++llen)
		if (*--p == '\n') {
			WR(p + 1, llen);
			llen = 0;
			if (style == RLINES && !--off) {
				++p;
a148 1
			}
d150 13
a162 5
	if (llen)
		WR(p, llen);
	if (munmap(start, (size_t)sbp->st_size))
		ierr();

@


1.12
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.11 2001/11/19 19:02:16 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.11 2001/11/19 19:02:16 mpech Exp $";
@


1.11
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.10 2001/07/17 02:23:58 pvalchev Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.10 2001/07/17 02:23:58 pvalchev Exp $";
d61 2
a62 2
static void r_buf __P((FILE *));
static int r_reg __P((FILE *, enum STYLE, long, struct stat *));
@


1.10
log
@-Wall cleanup; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.9 2001/01/17 00:27:21 pjanzen Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.9 2001/01/17 00:27:21 pjanzen Exp $";
d114 1
a114 1
	register enum STYLE style;
d118 3
a120 3
	register off_t size;
	register int llen;
	register char *p;
d176 3
a178 3
	register BF *mark, *tr, *tl = NULL;
	register int ch, len, llen;
	register char *p;
@


1.9
log
@avoid C sequence point issues; found by cgd@@netbsd.org using a development
version of gcc.
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.8 2000/10/12 10:18:37 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.8 2000/10/12 10:18:37 art Exp $";
d230 1
a230 1
		    "tail: warning: %qd bytes discarded\n", enomem);
@


1.8
log
@MAP_FAILED, not -1
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.7 2000/06/23 17:04:46 ericj Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.7 2000/06/23 17:04:46 ericj Exp $";
d199 4
a202 2
		} else
			mark->next = mark->prev = (mark = tl);
@


1.7
log
@Get rid of repeating error messages; From netbsd millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.6 1999/08/04 18:24:10 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.6 1999/08/04 18:24:10 mickey Exp $";
d130 1
a130 1
	    fileno(fp), (off_t)0)) == (caddr_t)-1)
@


1.6
log
@supply particular mapping type to the mmap(2) instead of bogus 0
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.5 1999/04/29 04:18:43 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.5 1999/04/29 04:18:43 mickey Exp $";
d96 1
a96 1
			bytes(fp, off);
d100 1
a100 1
			lines(fp, off);
@


1.5
log
@don't step on the tail if there is no one, or core dumps; millert - yes
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.4 1999/02/03 02:09:30 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.4 1999/02/03 02:09:30 millert Exp $";
d129 2
a130 2
	if ((start = mmap(NULL, (size_t)size, PROT_READ, 0, fileno(fp),
	    (off_t)0)) == (caddr_t)-1)
@


1.4
log
@Fix broken conversion of private err() function and make ierr() and oerr()
back into functions, not macros.  Also make functions that call mmap()
return an int so we can fall back to non-mmap (slow) version on mmap failure.
Noticable effects:
 o when you tail multiple files, if one of the files doesn't exist or
   is otherwise broken, keep on going to the next file.
 o it is now possible to tail files > 2gig, though it will be *very* slow
   since tail will be unable to use mmap()
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.3 1997/01/12 23:43:06 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.3 1997/01/12 23:43:06 millert Exp $";
d201 3
@


1.3
log
@Fix core dump and use libc err(3) instead of private one (which had
slightly different semantics).  Also clean up some gcc -Wall'isms.
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.2 1996/06/26 05:40:17 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.2 1996/06/26 05:40:17 deraadt Exp $";
d62 1
a62 1
static void r_reg __P((FILE *, enum STYLE, long, struct stat *));
d92 1
a92 3
	if (S_ISREG(sbp->st_mode))
		r_reg(fp, style, off, sbp);
	else
d111 1
a111 1
static void
d124 1
a124 1
		return;
d126 2
a127 4
	if (size > SIZE_T_MAX) {
		errx(0, "%s: %s", fname, strerror(EFBIG));
		return;
	}
d129 3
a131 5
	if ((start = mmap(NULL, (size_t)size,
	    PROT_READ, 0, fileno(fp), (off_t)0)) == (caddr_t)-1) {
		errx(0, "%s: %s", fname, strerror(EFBIG));
		return;
	}
d150 3
a152 1
		err(0, fname);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: reverse.c,v 1.6 1994/11/23 07:42:10 jtc Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: reverse.c,v 1.6 1994/11/23 07:42:10 jtc Exp $";
d51 2
a53 2
#include <errno.h>
#include <unistd.h>
d57 2
d129 1
a129 1
		err(0, "%s: %s", fname, strerror(EFBIG));
d135 1
a135 1
		err(0, "%s: %s", fname, strerror(EFBIG));
d156 1
a156 1
		err(0, "%s: %s", fname, strerror(errno));
d180 1
a180 1
	register BF *mark, *tl, *tr;
d195 1
a195 1
				err(1, "%s", strerror(errno));
d229 1
a229 1
		    "tail: warning: %ld bytes discarded\n", enomem);
@


1.1
log
@Initial revision
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: reverse.c,v 1.6 1994/11/23 07:42:10 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
