head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.4
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.26.0.26
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.18
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.22
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.20
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.16
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.14
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.12
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.07.05.05.06.27;	author jsg;	state Exp;
branches;
next	1.30;
commitid	kjMR4XUwim4lQsId;

1.30
date	2016.01.25.21.44.01;	author martijn;	state Exp;
branches;
next	1.29;
commitid	e7RmW6FrIxJ6foXq;

1.29
date	2015.11.21.13.58.56;	author tedu;	state Exp;
branches;
next	1.28;
commitid	RuMHbivoyBFwWain;

1.28
date	2015.11.20.01.15.22;	author tedu;	state Exp;
branches;
next	1.27;
commitid	kQP4sAB93l960wr8;

1.27
date	2015.11.19.17.50.04;	author tedu;	state Exp;
branches;
next	1.26;
commitid	nAQIOMPhgiIlY8Mk;

1.26
date	2009.10.27.23.59.44;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.13.18.33.03;	author landry;	state Exp;
branches;
next	1.24;

1.24
date	2008.10.17.11.38.20;	author landry;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.22.01.14.26;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.29.12.31.28;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.24.17.10.02;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.12.19.40.05;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.01.16.35.05;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.16.19.48.21;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.14.08.06.06;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.01.11.12.59;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.03.02.56.17;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.16.21.27.54;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.19.19.02.16;	author mpech;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.18.14.49.15;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.21.22.01.47;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.12.10.18.38;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.23.17.04.46;	author ericj;	state Exp;
branches;
next	1.8;

1.8
date	99.08.04.18.24.10;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	99.02.03.02.09.30;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.05.30.19.33.44;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.05.29.14.57.31;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	97.01.12.23.43.05;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.40.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.23.15.10.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.11;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Modify code added in rev 1.30 to use the correct variable instead of a
different uninitialised one.

ok martijn@@
@
text
@/*	$OpenBSD: forward.c,v 1.30 2016/01/25 21:44:01 martijn Exp $	*/
/*	$NetBSD: forward.c,v 1.7 1996/02/13 16:49:10 ghudson Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Edward Sze-Tyan Wang.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/event.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "extern.h"

static int rlines(struct tailfile *, off_t);
static inline void tfprint(FILE *fp);
static int tfqueue(struct tailfile *tf);
static const struct timespec *tfreopen(struct tailfile *tf);

static int kq = -1;

/*
 * forward -- display the file, from an offset, forward.
 *
 * There are eight separate cases for this -- regular and non-regular
 * files, by bytes or lines and from the beginning or end of the file.
 *
 * FBYTES	byte offset from the beginning of the file
 *	REG	seek
 *	NOREG	read, counting bytes
 *
 * FLINES	line offset from the beginning of the file
 *	REG	read, counting lines
 *	NOREG	read, counting lines
 *
 * RBYTES	byte offset from the end of the file
 *	REG	seek
 *	NOREG	cyclically read characters into a wrap-around buffer
 *
 * RLINES
 *	REG	step back until the correct offset is reached.
 *	NOREG	cyclically read lines into a wrap-around array of buffers
 */
void
forward(struct tailfile *tf, int nfiles, enum STYLE style, off_t origoff)
{
	int ch;
	struct tailfile *ctf, *ltf;
	struct kevent ke;
	const struct timespec *ts = NULL;
	int i;
	int nevents;

	if (nfiles < 1)
		return;

	if (fflag && (kq = kqueue()) < 0)
		warn("kqueue");

	for (i = 0; i < nfiles; i++) {
		off_t off = origoff;
		if (nfiles > 1)
			printfname(tf[i].fname);

		switch(style) {
		case FBYTES:
			if (off == 0)
				break;
			if (S_ISREG(tf[i].sb.st_mode)) {
				if (tf[i].sb.st_size < off)
					off = tf[i].sb.st_size;
				if (fseeko(tf[i].fp, off, SEEK_SET) == -1) {
					ierr(tf[i].fname);
					return;
				}
			} else while (off--)
				if ((ch = getc(tf[i].fp)) == EOF) {
					if (ferror(tf[i].fp)) {
						ierr(tf[i].fname);
						return;
					}
					break;
				}
			break;
		case FLINES:
			if (off == 0)
				break;
			for (;;) {
				if ((ch = getc(tf[i].fp)) == EOF) {
					if (ferror(tf[i].fp)) {
						ierr(tf[i].fname);
						return;
					}
					break;
				}
				if (ch == '\n' && !--off)
					break;
			}
			break;
		case RBYTES:
			if (S_ISREG(tf[i].sb.st_mode)) {
				if (tf[i].sb.st_size >= off &&
				    fseeko(tf[i].fp, -off, SEEK_END) == -1) {
					ierr(tf[i].fname);
					return;
				}
			} else if (off == 0) {
				while (getc(tf[i].fp) != EOF)
					;
				if (ferror(tf[i].fp)) {
					ierr(tf[i].fname);
					return;
				}
			} else {
				if (bytes(&(tf[i]), off))
					return;
			}
			break;
		case RLINES:
			if (S_ISREG(tf[i].sb.st_mode)) {
				if (!off) {
					if (fseeko(tf[i].fp, (off_t)0,
					    SEEK_END) == -1) {
						ierr(tf[i].fname);
						return;
					}
				} else if (rlines(&(tf[i]), off) != 0)
					lines(&(tf[i]), off);
			} else if (off == 0) {
				while (getc(tf[i].fp) != EOF)
					;
				if (ferror(tf[i].fp)) {
					ierr(tf[i].fname);
					return;
				}
			} else {
				if (lines(&(tf[i]), off))
					return;
			}
			break;
		default:
			err(1, "Unsupported style");
		}

		tfprint(tf[i].fp);
		if (fflag && tfqueue(&(tf[i])) == -1)
			warn("Unable to follow %s", tf[i].fname);

	}
	ltf = &(tf[i-1]);

	(void)fflush(stdout);
	if (!fflag || kq < 0)
		return;

	while (1) {
		if ((nevents = kevent(kq, NULL, 0, &ke, 1, ts)) <= 0) {
			if (errno == EINTR) {
				close(kq);
				return;
			}
		}

		ctf = ke.udata;
		if (nevents > 0) {
			if (ke.filter == EVFILT_READ) {
				if (ctf != ltf) {
					printfname(ctf->fname);
					ltf = ctf;
				}
				clearerr(ctf->fp);
				tfprint(ctf->fp);
				if (ferror(ctf->fp)) {
					ierr(ctf->fname);
					fclose(ctf->fp);
					warn("Lost file %s", ctf->fname);
					continue;
				}
				(void)fflush(stdout);
				clearerr(ctf->fp);
			} else if (ke.filter == EVFILT_VNODE) {
				if (ke.fflags & (NOTE_DELETE | NOTE_RENAME)) {
					/*
					 * File was deleted or renamed.
					 *
					 * Continue to look at it until
					 * a new file reappears with
					 * the same name. 
					 */
					(void) tfreopen(ctf);
				} else if (ke.fflags & NOTE_TRUNCATE) {
					warnx("%s has been truncated, "
					    "resetting.", ctf->fname);
					fpurge(ctf->fp);
					rewind(ctf->fp);
				}
			}
		}
		ts = tfreopen(NULL);
	}
}

/*
 * rlines -- display the last offset lines of the file.
 */
static int
rlines(struct tailfile *tf, off_t off)
{
	off_t pos;
	int ch;

	pos = tf->sb.st_size;
	if (pos == 0)
		return (0);

	/*
	 * Position before char.
	 * Last char is special, ignore it whether newline or not.
	 */
	pos -= 2;
	ch = EOF;
	for (; off > 0 && pos >= 0; pos--) {
		/* A seek per char isn't a problem with a smart stdio */
		if (fseeko(tf[0].fp, pos, SEEK_SET) == -1) {
			ierr(tf->fname);
			return (1);
		}
		if ((ch = getc(tf[0].fp)) == '\n')
			off--;
		else if (ch == EOF) {
			if (ferror(tf[0].fp)) {
				ierr(tf->fname);
				return (1);
			}
			break;
		}
	}
	/* If we read until start of file, put back last read char */
	if (pos < 0 && off > 0 && ch != EOF && ungetc(ch, tf[0].fp) == EOF) {
		ierr(tf->fname);
		return (1);
	}

	while (!feof(tf[0].fp) && (ch = getc(tf[0].fp)) != EOF)
		if (putchar(ch) == EOF)
			oerr();
	if (ferror(tf[0].fp)) {
		ierr(tf->fname);
		return (1);
	}

	return (0);
}

static inline void
tfprint(FILE *fp)
{
	int ch;

	while (!feof(fp) && (ch = getc(fp)) != EOF)
		if (putchar(ch) == EOF)
			oerr();
}

static int
tfqueue(struct tailfile *tf)
{
	struct kevent ke[2];
	int i = 1;

	if (kq < 0) {
		errno = EBADF;
		return -1;
	}

	EV_SET(&(ke[0]), fileno(tf->fp), EVFILT_READ,
	    EV_ENABLE | EV_ADD | EV_CLEAR, 0, 0, tf);

	if (S_ISREG(tf->sb.st_mode)) {
		i = 2;
		EV_SET(&(ke[1]), fileno(tf->fp), EVFILT_VNODE,
		    EV_ENABLE | EV_ADD | EV_CLEAR,
		    NOTE_DELETE | NOTE_RENAME | NOTE_TRUNCATE,
		    0, tf);
	}
	if (kevent(kq, ke, i, NULL, 0, NULL) < 0) {
		ierr(tf->fname);
		return -1;
	}
	return 0;
}

#define AFILESINCR 8
static const struct timespec *
tfreopen(struct tailfile *tf) {
	static struct tailfile		**reopen = NULL;
	static int			  nfiles = 0, afiles = 0;
	static const struct timespec	  ts = {1, 0};

	struct stat			  sb;
	struct tailfile			**treopen, *ttf;
	int				  i;

	if (tf && ((stat(tf->fname, &sb) != 0) || sb.st_ino != tf->sb.st_ino)) {
		if (afiles < ++nfiles) {
			afiles += AFILESINCR;
			treopen = reallocarray(reopen, afiles, sizeof(*reopen));
			if (treopen)
				reopen = treopen;
			else
				afiles -= AFILESINCR;
		}
		if (nfiles <= afiles) {
			for (i = 0; i < nfiles - 1; i++)
				if (strcmp(reopen[i]->fname, tf->fname) == 0)
					break;
			if (i < nfiles - 1)
				nfiles--;
			else
				reopen[nfiles-1] = tf;
		} else {
			warnx("Lost track of %s", tf->fname);
			nfiles--;
		}
	}

	for (i = 0; i < nfiles; i++) {
		ttf = reopen[i];
		if (stat(ttf->fname, &sb) == -1)
			continue;
		if (sb.st_ino != ttf->sb.st_ino) {
			(void) memcpy(&(ttf->sb), &sb, sizeof(ttf->sb));
			ttf->fp = freopen(ttf->fname, "r", ttf->fp);
			if (ttf->fp == NULL)
				ierr(ttf->fname);
			else {
				warnx("%s has been replaced, reopening.",
				    ttf->fname);
				tfqueue(ttf);
			}
		}
		reopen[i] = reopen[--nfiles];
	}

	return nfiles ? &ts : NULL;
}
@


1.30
log
@Fix a crash as found by sthen@@

tested and OK sthen@@
OK with minor tweak schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.29 2015/11/21 13:58:56 tedu Exp $	*/
d356 1
a356 1
			warnx("Lost track of %s", ttf->fname);
@


1.29
log
@better fixes for running tail without -f. from Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.28 2015/11/20 01:15:22 tedu Exp $	*/
d347 12
a358 2
		if (nfiles < afiles)
			reopen[nfiles-1] = tf;
@


1.28
log
@quick hack to fix "tail +n", reported broken by Mikolaj Kucharski.
this doesn't attempt to repair all cases, but restoring basic functionality
is a first step.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.27 2015/11/19 17:50:04 tedu Exp $	*/
d50 1
a55 10
static void
printtail(FILE *fp)
{
	int ch;

	while (!feof(fp) && (ch = getc(fp)) != EOF)
		if (putchar(ch) == EOF)
			oerr();
}

d91 1
a91 1
	if ((kq = kqueue()) < 0)
d130 1
a130 3
				if (ch == '\n' && !--off) {
					if (!fflag)
						printtail(tf[i].fp);
a131 1
				}
d179 2
a180 1
		if (tfqueue(&(tf[i])) == -1)
d206 1
a206 5
				while (!feof(ctf->fp) &&
				    (ch = getc(ctf->fp)) != EOF) {
					if (putchar(ch) == EOF)
						oerr();
				}
d287 10
@


1.27
log
@another try to allow tailing multiple files. maybe it works?
commit now to allow people to test.
from Martijn van Duren
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.26 2009/10/27 23:59:44 deraadt Exp $	*/
d55 10
d88 1
a88 1
forward(struct tailfile *tf, int nfiles, enum STYLE style, off_t off)
d104 1
d139 3
a141 1
				if (ch == '\n' && !--off)
d143 1
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.25 2008/11/13 18:33:03 landry Exp $	*/
d41 1
d43 1
d49 5
a53 1
static int rlines(FILE *, off_t, struct stat *);
d78 1
a78 1
forward(FILE *fp, enum STYLE style, off_t off, struct stat *sbp)
d81 1
a81 2
	struct stat nsb;
	int kq, queue;
d83 23
a105 16

	switch(style) {
	case FBYTES:
		if (off == 0)
			break;
		if (S_ISREG(sbp->st_mode)) {
			if (sbp->st_size < off)
				off = sbp->st_size;
			if (fseeko(fp, off, SEEK_SET) == -1) {
				ierr();
				return;
			}
		} else while (off--)
			if ((ch = getc(fp)) == EOF) {
				if (ferror(fp)) {
					ierr();
d108 11
d120 10
a130 3
		break;
	case FLINES:
		if (off == 0)
d132 12
a143 4
		for (;;) {
			if ((ch = getc(fp)) == EOF) {
				if (ferror(fp)) {
					ierr();
d146 3
a148 1
				break;
d150 16
a165 28
			if (ch == '\n' && !--off)
				break;
		}
		break;
	case RBYTES:
		if (S_ISREG(sbp->st_mode)) {
			if (sbp->st_size >= off &&
			    fseeko(fp, -off, SEEK_END) == -1) {
				ierr();
				return;
			}
		} else if (off == 0) {
			while (getc(fp) != EOF)
				;
			if (ferror(fp)) {
				ierr();
				return;
			}
		} else {
			if (bytes(fp, off))
				return;
		}
		break;
	case RLINES:
		if (S_ISREG(sbp->st_mode)) {
			if (!off) {
				if (fseeko(fp, (off_t)0, SEEK_END) == -1) {
					ierr();
d168 3
a170 8
			} else if (rlines(fp, off, sbp) != 0)
				lines(fp, off);
		} else if (off == 0) {
			while (getc(fp) != EOF)
				;
			if (ferror(fp)) {
				ierr();
				return;
d172 3
a174 3
		} else {
			if (lines(fp, off))
				return;
d176 4
a179 1
		break;
d181 1
d183 7
a189 16
	kq = -1;
kq_retry:
	if (fflag && ((kq = kqueue()) >= 0)) {
		EV_SET(&ke, fileno(fp), EVFILT_READ,
		    EV_ENABLE | EV_ADD | EV_CLEAR,
		    0,
		    0, NULL);
		if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0) {
			close(kq);
			kq = -1;
		} else if (S_ISREG(sbp->st_mode)) {
			EV_SET(&ke, fileno(fp), EVFILT_VNODE,
			    EV_ENABLE | EV_ADD | EV_CLEAR,
			    NOTE_DELETE | NOTE_RENAME | NOTE_TRUNCATE,
			    0, NULL);
			if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0) {
d191 1
a191 1
				kq = -1;
a193 1
	}
d195 37
a231 42
	for (;;) {
		while (!feof(fp) && (ch = getc(fp)) != EOF)
			if (putchar(ch) == EOF)
				oerr();
		if (ferror(fp)) {
			ierr();
			if (kq != -1)
				close(kq);
			return;
		}
		(void)fflush(stdout);
		if (!fflag)
			break;
		clearerr(fp);
		queue = 1;
		if (kq < 0 || kevent(kq, NULL, 0, &ke, 1, NULL) <= 0) {
			queue = 0;
			sleep(1);
		} else if (ke.filter == EVFILT_READ) {
			continue;
		} else if ((ke.fflags & NOTE_TRUNCATE) == 0) {
			/*
			 * File was renamed or deleted.
			 *
			 * Continue to look at it until a new file reappears
			 * with the same name. 
			 * Fall back to the old algorithm for that.
			 */
			close(kq);
			kq = -1;
		}

		if (is_stdin || stat(fname, &nsb) != 0)
			continue;
		/* Reopen file if the inode changes or file was truncated */
		if (nsb.st_ino != sbp->st_ino) {
			warnx("%s has been replaced, reopening.", fname);
			if ((fp = freopen(fname, "r", fp)) == NULL) {
				ierr();
				if (kq >= 0)
					close(kq);
				return;
a232 7
			(void)memcpy(sbp, &nsb, sizeof(nsb));
			goto kq_retry;
		} else if ((queue && (ke.fflags & NOTE_TRUNCATE)) ||
		    (!queue && nsb.st_size < sbp->st_size)) {
			warnx("%s has been truncated, resetting.", fname);
			fpurge(fp);
			rewind(fp);
d234 1
a234 1
		(void)memcpy(sbp, &nsb, sizeof(nsb));
a235 2
	if (kq >= 0)
		close(kq);
d242 1
a242 1
rlines(FILE *fp, off_t off, struct stat *sbp)
d247 1
a247 1
	pos = sbp->st_size;
d259 2
a260 2
		if (fseeko(fp, pos, SEEK_SET) == -1) {
			ierr();
d263 1
a263 1
		if ((ch = getc(fp)) == '\n')
d266 2
a267 2
			if (ferror(fp)) {
				ierr();
d274 2
a275 2
	if (pos < 0 && off > 0 && ch != EOF && ungetc(ch, fp) == EOF) {
		ierr();
d279 1
a279 1
	while (!feof(fp) && (ch = getc(fp)) != EOF)
d282 2
a283 2
	if (ferror(fp)) {
		ierr();
d288 73
@


1.25
log
@Backout previous commit, there are still some issues with it.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.23 2007/10/22 01:14:26 deraadt Exp $	*/
a34 7

#ifndef lint
#if 0
static char sccsid[] = "@@(#)forward.c	8.1 (Berkeley) 6/6/93";
#endif
static char rcsid[] = "$OpenBSD: forward.c,v 1.23 2007/10/22 01:14:26 deraadt Exp $";
#endif /* not lint */
@


1.24
log
@Permit tail -f to follow multiple files, useful when you want to monitor
several logfiles in a single terminal. split forward() and move the
corresponding -rewritten- code to follow().
Closes PR 5092.

ok millert@@ gilles@@ sobrado@@
@
text
@a50 1
#include <stdlib.h>
d82 3
a162 31
	while (!feof(fp) && (ch = getc(fp)) != EOF)
		if (putchar(ch) == EOF)
			oerr();
	if (ferror(fp)) {
		ierr();
		return;
	}
	(void)fflush(stdout);
}

struct file_info {
	FILE *fp;
	char *fname;
	struct stat fst;
};

/*
 * follow one or multiple files, i.e don't stop when end-of-file is reached,
 * but rather wait for additional data to be appended to the input.
 * this implements -f switch.
 */
void
follow(char **fnames, int nbfiles, enum STYLE style, off_t off)
{
	int ch, first, i;
	int kq;
	struct kevent ke;
	struct stat cst;
	FILE *fp;
	struct file_info *files;

d164 2
a165 46
	if ((kq = kqueue()) < 0)
		err(2, "kqueue() failed");

	if ((files = calloc(nbfiles, sizeof(struct file_info))) == NULL)
		err(1, "calloc() failed");

	for (first = 1, i = 0; (files[i].fname = *fnames++); i++) {
		if ((fp = fopen(files[i].fname, "r")) == NULL ||
		    fstat(fileno(fp), &(files[i].fst))) {
			warn("%s",files[i].fname);
			nbfiles--;
			i--;
			continue;
		}
		if (S_ISDIR(files[i].fst.st_mode)) {
			warnx("%s is a directory, skipping.",files[i].fname);
			nbfiles--;
			i--;
			continue;
		}
		files[i].fp = fp;
		if (nbfiles > 1) {
			(void)printf("%s==> %s <==\n",
			    first ? "" : "\n", files[i].fname);
			first = 0;
		}

		/* print from the given offset to the end */
		if (off != 0) {
			if (style == RBYTES) {
				if (S_ISREG(files[i].fst.st_mode)) {
					if (files[i].fst.st_size >= off &&
					    fseeko(fp, -off, SEEK_END) == -1) {
						ierr();
						goto cleanup;
					}
				}
				if (bytes(fp, off))
					goto cleanup;
			} else if (rlines(fp, off, &(files[i].fst)) != 0)
				lines(fp, off);
		}
		(void)fflush(stdout);

		/* one event to see if there is data to read */
		ke.ident = fileno(fp);
d168 6
a173 5
		    NULL, 0, NULL);
		if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0)
			goto cleanup;
		else if (S_ISREG(files[i].fst.st_mode)) {
			/* one event to detect if inode changed */
d178 4
a181 2
			if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0)
				goto cleanup;
a184 7
	/* no files to read */
	if (nbfiles == 0)
		goto cleanup;

	if (fp == NULL)
		fp = files[nbfiles - 1].fp;

d189 6
a194 3
		if (ferror(fp))
			goto cleanup;

d196 2
d199 3
a201 2
		/* give it a chance to fail.. */
		if (kevent(kq, NULL, 0, &ke, 1, NULL) <= 0) {
d203 1
d205 11
a215 5
		} else {
			/* an event occured on file #i */
			for (i = 0 ; i < nbfiles ; i++)
				if (fileno(files[i].fp) == ke.ident)
					break;
d217 10
a226 53
			/* EVFILT_READ event, check that it's on the current fp */
			if (ke.filter == EVFILT_READ) {
				if (fp != files[i].fp) {
					(void)printf("\n==> %s <==\n",files[i].fname);
					fp = files[i].fp;
					clearerr(fp);
				}
			/* EVFILT_VNODE event and File was renamed or deleted */
			} else if (ke.fflags & (NOTE_DELETE | NOTE_RENAME)) {
				/* file didn't reappear */
				if (stat(files[i].fname, &cst) != 0) {
					warnx("%s has been renamed or deleted.", files[i].fname);
					if (--nbfiles == 0)
						goto cleanup;
					/* overwrite with the latest file_info */
					fp = files[nbfiles].fp;
					(void)memcpy(&files[i], &files[nbfiles], sizeof(struct file_info));
				} else {
					/* Reopen file if the inode changed */
					if (cst.st_ino != files[i].fst.st_ino) {
						warnx("%s has been replaced, reopening.", files[i].fname);
						if ((fp = freopen(files[i].fname, "r", files[i].fp)) == NULL) {
							ierr();
							goto cleanup;
						}
						/*
						 * on freopen(), events corresponding to the fp
						 * were deleted from kqueue, we readd them
						*/
						ke.ident = fileno(fp);
						EV_SET(&ke, fileno(fp), EVFILT_READ,
						    EV_ENABLE | EV_ADD | EV_CLEAR,
						    NULL, 0, NULL);
						if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0)
							goto cleanup;
						else if (S_ISREG(files[i].fst.st_mode)) {
							EV_SET(&ke, fileno(fp), EVFILT_VNODE,
							    EV_ENABLE | EV_ADD | EV_CLEAR,
							    NOTE_DELETE | NOTE_RENAME | NOTE_TRUNCATE,
							    0, NULL);
							if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0)
								goto cleanup;
						}
						files[i].fp = fp;
					}
					(void)memcpy(&(files[i].fst), &cst, sizeof(cst));
				}
			} else if (ke.fflags & NOTE_TRUNCATE) {
				/* reset file if it was truncated */
				warnx("%s has been truncated, resetting.", files[i].fname);
				fpurge(files[i].fp);
				rewind(files[i].fp);
				continue;
d228 7
d236 1
a237 2

cleanup:
a239 2
	free(files);
	return;
@


1.23
log
@use EV_SET() instead of doing it by hand; Iruata Souza
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.22 2007/09/29 12:31:28 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.22 2007/09/29 12:31:28 otto Exp $";
d51 1
a82 3
	struct stat nsb;
	int kq, queue;
	struct kevent ke;
d161 31
d193 46
a238 2
kq_retry:
	if (fflag && ((kq = kqueue()) >= 0)) {
d241 5
a245 6
		    0,
		    0, NULL);
		if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0) {
			close(kq);
			kq = -1;
		} else if (S_ISREG(sbp->st_mode)) {
d250 2
a251 4
			if (kevent(kq, &ke, 1, NULL, 0, NULL) < 0) {
				close(kq);
				kq = -1;
			}
d255 7
d266 3
a268 6
		if (ferror(fp)) {
			ierr();
			if (kq != -1)
				close(kq);
			return;
		}
a269 2
		if (!fflag)
			break;
d271 2
a272 3
		queue = 1;
		if (kq < 0 || kevent(kq, NULL, 0, &ke, 1, NULL) <= 0) {
			queue = 0;
a273 1
		} else if (ke.filter == EVFILT_READ) {
d275 59
a333 22
		} else if ((ke.fflags & NOTE_TRUNCATE) == 0) {
			/*
			 * File was renamed or deleted.
			 *
			 * Continue to look at it until a new file reappears
			 * with the same name. 
			 * Fall back to the old algorithm for that.
			 */
			close(kq);
			kq = -1;
		}

		if (is_stdin || stat(fname, &nsb) != 0)
			continue;
		/* Reopen file if the inode changes or file was truncated */
		if (nsb.st_ino != sbp->st_ino) {
			warnx("%s has been replaced, reopening.", fname);
			if ((fp = freopen(fname, "r", fp)) == NULL) {
				ierr();
				if (kq >= 0)
					close(kq);
				return;
a334 7
			(void)memcpy(sbp, &nsb, sizeof(nsb));
			goto kq_retry;
		} else if ((queue && (ke.fflags & NOTE_TRUNCATE)) ||
		    (!queue && nsb.st_size < sbp->st_size)) {
			warnx("%s has been truncated, resetting.", fname);
			fpurge(fp);
			rewind(fp);
a335 1
		(void)memcpy(sbp, &nsb, sizeof(nsb));
d337 2
d341 2
@


1.22
log
@unneeded includes and whitespace police; from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.21 2006/03/24 17:10:02 kjell Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.21 2006/03/24 17:10:02 kjell Exp $";
d166 4
a169 5
		ke.ident = fileno(fp);
		ke.flags = EV_ENABLE|EV_ADD|EV_CLEAR;
		ke.filter = EVFILT_READ;
		ke.fflags = ke.data = 0;
		ke.udata = NULL;
d174 4
a177 4
			ke.ident = fileno(fp);
			ke.flags = EV_ENABLE|EV_ADD|EV_CLEAR;
			ke.filter = EVFILT_VNODE;
			ke.fflags = NOTE_DELETE | NOTE_RENAME | NOTE_TRUNCATE;
@


1.21
log
@ANSIfy. Ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.20 2004/03/12 19:40:05 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.20 2004/03/12 19:40:05 otto Exp $";
a44 1
#include <sys/mman.h>
a47 3
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
a48 1
#include <stdlib.h>
@


1.20
log
@If kqueue is not available, revert back to old behavior. Unbreaks tail -f
on NFS and other filesystems not supporting kqueues.
ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.19 2004/03/01 16:35:05 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.19 2004/03/01 16:35:05 otto Exp $";
d84 1
a84 5
forward(fp, style, off, sbp)
	FILE *fp;
	enum STYLE style;
	off_t off;
	struct stat *sbp;
@


1.19
log
@Unbreak file truncation handling. Resolves PR 3689.
ok tdeval@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.18 2004/02/16 19:48:21 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.18 2004/02/16 19:48:21 otto Exp $";
d92 1
a92 1
	int kq;
d209 1
d211 1
d240 2
a241 1
		} else if (ke.fflags & NOTE_TRUNCATE) {
@


1.18
log
@make -b and -c work with large offsets; tweak from millert@@
ok henning@@ itojun@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.17 2003/07/14 08:06:06 otto Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.17 2003/07/14 08:06:06 otto Exp $";
d187 1
a187 1
			ke.fflags = NOTE_DELETE | NOTE_RENAME;
d213 1
a213 1
		} else {
d238 1
a238 1
		} else if (nsb.st_size < sbp->st_size) {
d240 1
a241 1
			(void)memcpy(sbp, &nsb, sizeof(nsb));
d243 1
@


1.17
log
@typo in comment. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.16 2003/07/01 11:12:59 henning Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.16 2003/07/01 11:12:59 henning Exp $";
d59 1
a59 1
static int rlines(FILE *, long, struct stat *);
d87 1
a87 1
	long off;
d102 1
a102 1
			if (fseek(fp, off, SEEK_SET) == -1) {
d133 1
a133 1
			    fseek(fp, -off, SEEK_END) == -1) {
d152 1
a152 1
				if (fseek(fp, 0L, SEEK_END) == -1) {
d252 1
a252 1
rlines(FILE *fp, long off, struct stat *sbp)
@


1.16
log
@rewrite to not use mmap(2). solves a bunch of issues:
- No more I/O related SEGVs (PR 2337?).
- Performance linear to size of output, not input file size, even for very large files.
  Same for -r.
- Reverse tail also works for very large files.
- Very large values of n possible, even for very large files. Same for -r.

work by Otto Moerbeek <otto@@drijf.net>
tested by and ok millert@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.15 2003/06/03 02:56:17 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.15 2003/06/03 02:56:17 millert Exp $";
d263 1
a263 1
	 * Last char is special, ignore if whether newline or not.
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.14 2002/02/16 21:27:54 millert Exp $	*/
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.14 2002/02/16 21:27:54 millert Exp $";
d80 1
a80 1
 *	REG	mmap the file and step back until reach the correct offset.
d252 1
a252 4
rlines(fp, off, sbp)
	FILE *fp;
	long off;
	struct stat *sbp;
d254 2
a255 3
	off_t size;
	char *p;
	char *start;
d257 2
a258 1
	if (!(size = sbp->st_size))
d261 19
a279 11
	if (size > SIZE_T_MAX)
		return (1);

	if ((start = mmap(NULL, (size_t)size, PROT_READ, MAP_PRIVATE,
	    fileno(fp), (off_t)0)) == MAP_FAILED)
		return (1);

	/* Last char is special, ignore whether newline or not. */
	for (p = start + size - 1; --size;)
		if (*--p == '\n' && !--off) {
			++p;
d282 3
a284 5

	/* Set the file pointer to reflect the length displayed. */
	size = sbp->st_size - size;
	WR(p, size);
	if (fseek(fp, (long)sbp->st_size, SEEK_SET) == -1) {
d288 5
a292 1
	if (munmap(start, (size_t)sbp->st_size)) {
@


1.14
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.13 2001/11/19 19:02:16 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d40 1
a40 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.13 2001/11/19 19:02:16 mpech Exp $";
@


1.13
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.12 2001/08/18 14:49:15 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.12 2001/08/18 14:49:15 art Exp $";
d63 1
a63 1
static int rlines __P((FILE *, long, struct stat *));
@


1.12
log
@Use kqueue for -f.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.11 2000/11/21 22:01:47 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.11 2000/11/21 22:01:47 art Exp $";
d261 2
a262 2
	register off_t size;
	register char *p;
@


1.11
log
@When doing tail -f from stdin don't reopen a local file named stdin.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.10 2000/10/12 10:18:38 art Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.10 2000/10/12 10:18:38 art Exp $";
d50 1
d94 1
a94 1
	register int ch;
d96 2
d176 23
d205 2
a211 1
		sleep(1);
d213 15
d236 2
d241 1
d248 2
@


1.10
log
@MAP_FAILED, not -1
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.9 2000/06/23 17:04:46 ericj Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.9 2000/06/23 17:04:46 ericj Exp $";
d187 1
a187 1
		if (stat(fname, &nsb) != 0)
@


1.9
log
@Get rid of repeating error messages; From netbsd millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.8 1999/08/04 18:24:10 mickey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.8 1999/08/04 18:24:10 mickey Exp $";
d225 1
a225 1
	    fileno(fp), (off_t)0)) == (caddr_t)-1)
@


1.8
log
@supply particular mapping type to the mmap(2) instead of bogus 0
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.7 1999/02/03 02:09:30 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.7 1999/02/03 02:09:30 millert Exp $";
d145 4
a148 2
		} else
			bytes(fp, off);
d166 4
a169 2
		} else
			lines(fp, off);
@


1.7
log
@Fix broken conversion of private err() function and make ierr() and oerr()
back into functions, not macros.  Also make functions that call mmap()
return an int so we can fall back to non-mmap (slow) version on mmap failure.
Noticable effects:
 o when you tail multiple files, if one of the files doesn't exist or
   is otherwise broken, keep on going to the next file.
 o it is now possible to tail files > 2gig, though it will be *very* slow
   since tail will be unable to use mmap()
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.6 1997/05/30 19:33:44 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.6 1997/05/30 19:33:44 millert Exp $";
d220 2
a221 2
	if ((start = mmap(NULL, (size_t)size, PROT_READ, 0, fileno(fp),
	    (off_t)0)) == (caddr_t)-1)
@


1.6
log
@In -f mode notice when the file has been replace or truncated and
deal.  Useful for tail'ing log files that get rotated.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.5 1997/05/29 14:57:31 kstailey Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.5 1997/05/29 14:57:31 kstailey Exp $";
d62 1
a62 1
static void rlines __P((FILE *, long, struct stat *));
d139 2
a140 1
			while (getc(fp) != EOF);
d149 1
a149 1
		if (S_ISREG(sbp->st_mode))
d155 5
a159 4
			} else
				rlines(fp, off, sbp);
		else if (off == 0) {
			while (getc(fp) != EOF);
d204 1
a204 1
static void
d215 1
a215 1
		return;
d217 2
a218 4
	if (size > SIZE_T_MAX) {
		errx(0, "%s: %s", fname, strerror(EFBIG));
		return;
	}
d220 3
a222 5
	if ((start = mmap(NULL, (size_t)size,
	    PROT_READ, 0, fileno(fp), (off_t)0)) == (caddr_t)-1) {
		errx(0, "%s: %s", fname, strerror(EFBIG));
		return;
	}
d236 1
a236 1
		return;
d239 2
a240 2
		err(0, fname);
		return;
d242 2
@


1.5
log
@why select(2) when you can sleep(3) cheap?
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.4 1997/01/12 23:43:05 millert Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.4 1997/01/12 23:43:05 millert Exp $";
d94 1
d168 1
a168 1
		while ((ch = getc(fp)) != EOF)
d180 16
@


1.4
log
@Fix core dump and use libc err(3) instead of private one (which had
slightly different semantics).  Also clean up some gcc -Wall'isms.
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.3 1996/06/26 05:40:15 deraadt Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.3 1996/06/26 05:40:15 deraadt Exp $";
a48 1
#include <sys/time.h>
a93 1
	struct timeval second;
d177 1
a177 9
		/*
		 * We pause for one second after displaying any data that has
		 * accumulated since we read the file.  Since sleep(3) takes
		 * eight system calls, use select() instead.
		 */
		second.tv_sec = 1;
		second.tv_usec = 0;
		if (select(0, NULL, NULL, NULL, &second) == -1)
			err(1, "select");
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: forward.c,v 1.7 1996/02/13 16:49:10 ghudson Exp $	*/
d44 1
a44 1
static char rcsid[] = "$OpenBSD: forward.c,v 1.7 1996/02/13 16:49:10 ghudson Exp $";
d52 3
a55 3
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
d59 2
d187 1
a187 1
			err(1, "select: %s", strerror(errno));
d209 1
a209 1
		err(0, "%s: %s", fname, strerror(EFBIG));
d215 1
a215 1
		err(0, "%s: %s", fname, strerror(EFBIG));
d234 1
a234 1
		err(0, "%s: %s", fname, strerror(errno));
@


1.2
log
@From NetBSD:
Don't rely on select() not to modify the timeval argument.  Also,
simplify the code by passing in NULL rather than an empty fd_set to
indicate no file descriptors.
@
text
@d1 1
d44 1
a44 1
static char rcsid[] = "$NetBSD: forward.c,v 1.7 1996/02/13 16:49:10 ghudson Exp $";
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: forward.c,v 1.6 1994/11/23 07:42:02 jtc Exp $	*/
d43 1
a43 1
static char rcsid[] = "$NetBSD: forward.c,v 1.6 1994/11/23 07:42:02 jtc Exp $";
a92 1
	fd_set zero;
a164 10
	/*
	 * We pause for one second after displaying any data that has
	 * accumulated since we read the file.
	 */
	if (fflag) {
		FD_ZERO(&zero);
		second.tv_sec = 1;
		second.tv_usec = 0;
	}

d176 8
a183 2
		/* Sleep(3) is eight system calls.  Do it fast. */
		if (select(0, &zero, &zero, &zero, &second) == -1)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
