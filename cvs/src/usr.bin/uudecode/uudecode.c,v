head	1.23;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.10
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.6
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.4
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.2
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.8
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.4
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.14.0.16
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.14
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.8.0.8
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.01.03.14.43.20;	author tb;	state Exp;
branches;
next	1.22;
commitid	fwTRMLEbNu4nxfnO;

1.22
date	2015.10.09.01.37.09;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	sbrB3Q5CNxcwZpfU;

1.21
date	2015.10.07.06.00.33;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	yGUKAoCI7GO4WvSe;

1.20
date	2015.01.16.06.40.13;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	Uu5nFG3wCl0LACBb;

1.19
date	2014.05.20.01.25.23;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.27.23.59.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.29.18.25.28;	author sobrado;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.05.20.59.42;	author sobrado;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.09.22.54.02;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.09.01.31.42;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.10.00.06.51;	author david;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.10.22.20.53;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.17;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.01.03.23.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.09.15.15.59.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.08.31.02.13.41;	author dgregor;	state Exp;
branches;
next	1.5;

1.5
date	98.05.29.21.07.22;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.05.11.01.19.05;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.01.17.07.13.47;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.42.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.46.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.46.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Add missing pledge "getpw".  If -s or -o were specified on the command
line and the `remote file name' is subject to `tilde expansion', a call
to getpwnam(3) happens.

ok semarie@@
@
text
@/*	$OpenBSD: uudecode.c,v 1.22 2015/10/09 01:37:09 deraadt Exp $	*/
/*	$FreeBSD: uudecode.c,v 1.49 2003/05/03 19:44:46 obrien Exp $	*/

/*-
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Create the specified file, decoding as you go.
 * Used with uuencode.
 */

#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <locale.h>
#include <pwd.h>
#include <resolv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

static const char *infile, *outfile;
static FILE *infp, *outfp;
static int base64, cflag, iflag, oflag, pflag, rflag, sflag;

static void	usage(void);
static int	decode(void);
static int	decode2(void);
static int	uu_decode(void);
static int	base64_decode(void);

enum program_mode {
	MODE_DECODE,
	MODE_B64DECODE
} pmode;

int
main(int argc, char *argv[])
{
	int rval, ch;
	extern char *__progname;
	static const char *optstr[2] = {
		"cimo:prs",
		"cio:prs"
	};

	pmode = MODE_DECODE;
	if (strcmp(__progname, "b64decode") == 0) {
		base64 = 1;
		pmode = MODE_B64DECODE;
	}

	setlocale(LC_ALL, "");
	while ((ch = getopt(argc, argv, optstr[pmode])) != -1) {
		switch(ch) {
		case 'c':
			if (oflag || rflag)
				usage();
			cflag = 1; /* multiple uudecode'd files */
			break;
		case 'i':
			iflag = 1; /* ask before override files */
			break;
		case 'm':
			base64 = 1;
			break;
		case 'o':
			if (cflag || pflag || rflag || sflag)
				usage();
			oflag = 1; /* output to the specified file */
			sflag = 1; /* do not strip pathnames for output */
			outfile = optarg; /* set the output filename */
			break;
		case 'p':
			if (oflag)
				usage();
			pflag = 1; /* print output to stdout */
			break;
		case 'r':
			if (cflag || oflag)
				usage();
			rflag = 1; /* decode raw data */
			break;
		case 's':
			if (oflag)
				usage();
			sflag = 1; /* do not strip pathnames for output */
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (sflag) {
		if (pledge("stdio rpath wpath cpath getpw", NULL) == -1)
			err(1, "pledge");
	} else if (pflag == 0) {
		if (pledge("stdio rpath wpath cpath", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");
	}

	if (*argv) {
		rval = 0;
		do {
			infp = fopen(infile = *argv, "r");
			if (infp == NULL) {
				warn("%s", *argv);
				rval = 1;
				continue;
			}
			rval |= decode();
			fclose(infp);
		} while (*++argv);
	} else {
		infile = "stdin";
		infp = stdin;
		rval = decode();
	}
	exit(rval);
}

static int
decode(void)
{
	int r, v;

	if (rflag) {
		/* relaxed alternative to decode2() */
		outfile = "/dev/stdout";
		outfp = stdout;
		if (base64)
			return (base64_decode());
		else
			return (uu_decode());
	}
	v = decode2();
	if (v == EOF) {
		warnx("%s: missing or bad \"begin\" line", infile);
		return (1);
	}
	for (r = v; cflag; r |= v) {
		v = decode2();
		if (v == EOF)
			break;
	}
	return (r);
}

static int
decode2(void)
{
	int flags, fd, mode;
	size_t n, m;
	char *p, *q;
	void *handle;
	struct passwd *pw;
	struct stat st;
	char buf[PATH_MAX];

	base64 = 0;
	/* search for header line */
	for (;;) {
		if (fgets(buf, sizeof(buf), infp) == NULL)
			return (EOF);
		p = buf;
		if (strncmp(p, "begin-base64 ", 13) == 0) {
			base64 = 1;
			p += 13;
		} else if (strncmp(p, "begin ", 6) == 0)
			p += 6;
		else
			continue;
		/* p points to mode */
		q = strchr(p, ' ');
		if (q == NULL)
			continue;
		*q++ = '\0';
		/* q points to filename */
		n = strlen(q);
		while (n > 0 && (q[n-1] == '\n' || q[n-1] == '\r'))
			q[--n] = '\0';
		/* found valid header? */
		if (n > 0)
			break;
	}

	handle = setmode(p);
	if (handle == NULL) {
		warnx("%s: unable to parse file mode", infile);
		return (1);
	}
	mode = getmode(handle, 0) & 0666;
	free(handle);

	if (sflag) {
		/* don't strip, so try ~user/file expansion */
		p = NULL;
		pw = NULL;
		if (*q == '~')
			p = strchr(q, '/');
		if (p != NULL) {
			*p = '\0';
			pw = getpwnam(q + 1);
			*p = '/';
		}
		if (pw != NULL) {
			n = strlen(pw->pw_dir);
			if (buf + n > p) {
				/* make room */
				m = strlen(p);
				if (sizeof(buf) < n + m) {
					warnx("%s: bad output filename",
					    infile);
					return (1);
				}
				p = memmove(buf + n, p, m);
			}
			q = memcpy(p - n, pw->pw_dir, n);
		}
	} else {
		/* strip down to leaf name */
		p = strrchr(q, '/');
		if (p != NULL)
			q = p + 1;
	}
	if (!oflag)
		outfile = q;

	/* POSIX says "/dev/stdout" is a 'magic cookie' not a special file. */
	if (pflag || strcmp(outfile, "/dev/stdout") == 0)
		outfp = stdout;
	else {
		flags = O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW;
		if (lstat(outfile, &st) == 0) {
			if (iflag) {
				warnc(EEXIST, "%s: %s", infile, outfile);
				return (0);
			}
			switch (st.st_mode & S_IFMT) {
			case S_IFREG:
			case S_IFLNK:
				/* avoid symlink attacks */
				if (unlink(outfile) == 0 || errno == ENOENT)
					break;
				warn("%s: unlink %s", infile, outfile);
				return (1);
			case S_IFDIR:
				warnc(EISDIR, "%s: %s", infile, outfile);
				return (1);
			default:
				if (oflag) {
					/* trust command-line names */
					flags &= ~(O_EXCL|O_NOFOLLOW);
					break;
				}
				warnc(EEXIST, "%s: %s", infile, outfile);
				return (1);
			}
		} else if (errno != ENOENT) {
			warn("%s: %s", infile, outfile);
			return (1);
		}
		if ((fd = open(outfile, flags, mode)) < 0 ||
		    (outfp = fdopen(fd, "w")) == NULL) {
			warn("%s: %s", infile, outfile);
			return (1);
		}
	}

	if (base64)
		return (base64_decode());
	else
		return (uu_decode());
}

static int
get_line(char *buf, size_t size)
{
	if (fgets(buf, size, infp) != NULL)
		return (2);
	if (rflag)
		return (0);
	warnx("%s: %s: short file", infile, outfile);
	return (1);
}

static int
checkend(const char *ptr, const char *end, const char *msg)
{
	size_t n;

	n = strlen(end);
	if (strncmp(ptr, end, n) != 0 ||
	    strspn(ptr + n, " \t\r\n") != strlen(ptr + n)) {
		warnx("%s: %s: %s", infile, outfile, msg);
		return (1);
	}
	if (fclose(outfp) != 0) {
		warn("%s: %s", infile, outfile);
		return (1);
	}
	return (0);
}

static int
uu_decode(void)
{
	int i, ch;
	char *p;
	char buf[PATH_MAX];

	/* for each input line */
	for (;;) {
		switch (get_line(buf, sizeof(buf))) {
		case 0:
			return (0);
		case 1:
			return (1);
		}

#define	DEC(c)	(((c) - ' ') & 077)		/* single character decode */
#define IS_DEC(c) ( (((c) - ' ') >= 0) && (((c) - ' ') <= 077 + 1) )

#define OUT_OF_RANGE do {						\
	warnx("%s: %s: character out of range: [%d-%d]",		\
	    infile, outfile, 1 + ' ', 077 + ' ' + 1);			\
	return (1);							\
} while (0)

		/*
		 * `i' is used to avoid writing out all the characters
		 * at the end of the file.
		 */
		p = buf;
		if ((i = DEC(*p)) <= 0)
			break;
		for (++p; i > 0; p += 4, i -= 3)
			if (i >= 3) {
				if (!(IS_DEC(*p) && IS_DEC(*(p + 1)) &&
				     IS_DEC(*(p + 2)) && IS_DEC(*(p + 3))))
					OUT_OF_RANGE;

				ch = DEC(p[0]) << 2 | DEC(p[1]) >> 4;
				putc(ch, outfp);
				ch = DEC(p[1]) << 4 | DEC(p[2]) >> 2;
				putc(ch, outfp);
				ch = DEC(p[2]) << 6 | DEC(p[3]);
				putc(ch, outfp);
			}
			else {
				if (i >= 1) {
					if (!(IS_DEC(*p) && IS_DEC(*(p + 1))))
						OUT_OF_RANGE;
					ch = DEC(p[0]) << 2 | DEC(p[1]) >> 4;
					putc(ch, outfp);
				}
				if (i >= 2) {
					if (!(IS_DEC(*(p + 1)) &&
					    IS_DEC(*(p + 2))))
						OUT_OF_RANGE;

					ch = DEC(p[1]) << 4 | DEC(p[2]) >> 2;
					putc(ch, outfp);
				}
				if (i >= 3) {
					if (!(IS_DEC(*(p + 2)) &&
					    IS_DEC(*(p + 3))))
						OUT_OF_RANGE;
					ch = DEC(p[2]) << 6 | DEC(p[3]);
					putc(ch, outfp);
				}
			}
	}
	switch (get_line(buf, sizeof(buf))) {
	case 0:
		return (0);
	case 1:
		return (1);
	default:
		return (checkend(buf, "end", "no \"end\" line"));
	}
}

static int
base64_decode(void)
{
	int n;
	char inbuf[PATH_MAX];
	unsigned char outbuf[PATH_MAX * 4];

	for (;;) {
		switch (get_line(inbuf, sizeof(inbuf))) {
		case 0:
			return (0);
		case 1:
			return (1);
		}
		n = b64_pton(inbuf, outbuf, sizeof(outbuf));
		if (n < 0)
			break;
		fwrite(outbuf, 1, n, outfp);
	}
	return (checkend(inbuf, "====",
		    "error decoding base64 input stream"));
}

static void
usage(void)
{
	switch (pmode) {
	case MODE_DECODE:
		(void)fprintf(stderr,
		    "usage: uudecode [-cimprs] [file ...]\n"
		    "       uudecode [-i] -o output_file [file]\n");
		break;
	case MODE_B64DECODE:
		(void)fprintf(stderr,
		    "usage: b64decode [-ciprs] [file ...]\n"
		    "       b64decode [-i] -o output_file [file]\n");
		break;
	}
	exit(1);
}
@


1.22
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.21 2015/10/07 06:00:33 deraadt Exp $	*/
d129 4
a132 1
	if (oflag || pflag == 0) {
@


1.21
log
@tame "stdio rpath wpath cpath" or a more mundane "stdio rpath", depending
on which arguments the programs are run under.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.20 2015/01/16 06:40:13 deraadt Exp $	*/
d130 2
a131 2
		if (tame("stdio rpath wpath cpath", NULL) == -1)
			err(1, "tame");
d133 2
a134 2
		if (tame("stdio rpath", NULL) == -1)
			err(1, "tame");
@


1.20
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.19 2014/05/20 01:25:23 guenther Exp $	*/
d128 8
@


1.19
log
@Use errc/warnc to simplify code.
Also, in 'ftp', always put the error message last, after the hostname/ipaddr.

ok jsing@@ krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.18 2012/03/04 04:05:15 fgsch Exp $	*/
a37 1
#include <sys/param.h>
d53 1
d185 1
a185 1
	char buf[MAXPATHLEN];
d337 1
a337 1
	char buf[MAXPATHLEN];
d415 2
a416 2
	char inbuf[MAXPATHLEN];
	unsigned char outbuf[MAXPATHLEN * 4];
@


1.18
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.17 2009/10/27 23:59:46 deraadt Exp $	*/
d263 1
a263 2
				errno = EEXIST;
				warn("%s: %s", infile, outfile);
d275 1
a275 2
				errno = EISDIR;
				warn("%s: %s", infile, outfile);
d283 1
a283 2
				errno = EEXIST;
				warn("%s: %s", infile, outfile);
@


1.17
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.16 2008/07/29 18:25:28 sobrado Exp $	*/
d307 1
a307 1
getline(char *buf, size_t size)
d344 1
a344 1
		switch (getline(buf, sizeof(buf))) {
d404 1
a404 1
	switch (getline(buf, sizeof(buf))) {
d422 1
a422 1
		switch (getline(inbuf, sizeof(inbuf))) {
@


1.16
log
@an enum specifier is more elegant than a set of #defines;
storing the program mode variable (pmode) as a global let us have
a more consistent prototype for usage().

changes suggested by pyr@@.

ok millert@@, pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.15 2008/07/05 20:59:42 sobrado Exp $	*/
a31 13

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1983, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)uudecode.c	8.2 (Berkeley) 4/2/94";
#endif
static const char rcsid[] = "$OpenBSD: uudecode.c,v 1.15 2008/07/05 20:59:42 sobrado Exp $";
#endif /* not lint */
@


1.15
log
@each utility must have its own usage and its own set of options;
b64encode and b64decode are equivalent to running uuencode and uudecode
respectively with the -m flag specified, so this flag should not be
available in these utilities; while here, fix synopsis.

based on millert's diff for compress/gzip.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.14 2004/04/09 22:54:02 millert Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: uudecode.c,v 1.14 2004/04/09 22:54:02 millert Exp $";
d72 1
a72 1
static void	usage(int);
d78 4
a81 5
/*
 * program modes
 */
#define MODE_DECODE	0
#define MODE_B64DECODE	1
d86 1
a86 1
	int rval, ch, mode;
d93 1
a93 2
	mode = 0;

d96 1
a96 1
		mode = MODE_B64DECODE;
d100 1
a100 1
	while ((ch = getopt(argc, argv, optstr[mode])) != -1) {
d104 1
a104 1
				usage(mode);
d115 1
a115 1
				usage(mode);
d122 1
a122 1
				usage(mode);
d127 1
a127 1
				usage(mode);
d132 1
a132 1
				usage(mode);
d136 1
a136 1
			usage(mode);
d451 1
a451 1
usage(int mode)
d453 1
a453 1
	switch (mode) {
@


1.14
log
@Sync with FreeBSD; adds base64 support and other options.
OK deraadt@@, some man page tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.13 2003/12/09 01:31:42 mickey Exp $	*/
d43 1
a43 1
static const char rcsid[] = "$OpenBSD: uudecode.c,v 1.13 2003/12/09 01:31:42 mickey Exp $";
d72 1
a72 1
static void	usage(void);
d78 6
d87 1
a87 1
	int rval, ch;
d89 4
d94 3
a96 1
	if (strcmp(__progname, "b64decode") == 0)
d98 2
d102 1
a102 1
	while ((ch = getopt(argc, argv, "cimo:prs")) != -1) {
d106 1
a106 1
				usage();
d117 1
a117 1
				usage();
d124 1
a124 1
				usage();
d129 1
a129 1
				usage();
d134 1
a134 1
				usage();
d138 1
a138 1
			usage();
d453 1
a453 1
usage(void)
d455 12
a466 5
	(void)fprintf(stderr,
	    "usage: uudecode [-cimprs] [file ...]\n"
	    "       uudecode [-i] -o output_file [file]\n"
	    "       b64decode [-cimprs] [file ...]\n"
	    "       b64decode [-i] -o output_file [file]\n");
@


1.13
log
@user err/warn
@
text
@d1 2
a2 2
/*	$OpenBSD: uudecode.c,v 1.12 2003/07/10 00:06:51 david Exp $	*/
/*	$NetBSD: uudecode.c,v 1.6 1994/11/17 07:40:43 jtc Exp $	*/
d33 2
a34 1
char copyright[] =
d37 1
d41 1
a41 1
static char sccsid[] = "@@(#)uudecode.c	8.2 (Berkeley) 4/2/94";
d43 1
a43 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.12 2003/07/10 00:06:51 david Exp $";
d47 2
a48 7
 * uudecode [-p] [file ...]
 *
 * create the specified file, decoding as you go.
 * used with uuencode.
 *
 * Write to stdout if '-p' is specified.  Use this option if you care about
 * security at all.
d50 1
a50 5
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <errno.h>
d52 1
d55 6
d62 4
a66 1
#include <err.h>
d68 9
a76 3
static int decode(int);
static void usage(void);
char *filename;
d81 5
a85 3
	int rval;
	int ch;
	int tostdout = 0;
d88 20
a107 3

	while ((ch = getopt(argc, argv, "p")) != -1)
		switch((char)ch) {
d109 13
a121 1
			tostdout++;
a122 1
		case '?':
d126 1
d133 2
a134 1
			if (!freopen(filename = *argv, "r", stdin)) {
d139 2
a140 1
			rval |= decode(tostdout);
d143 3
a145 2
		filename = "stdin";
		rval = decode(tostdout);
d151 1
a151 1
decode(int tostdout)
d153 31
d185 1
a185 3
	int n;
	char ch, *p;
	int mode, n1;
d188 1
d190 108
a297 36
	do {
		if (!fgets(buf, sizeof(buf), stdin)) {
			warnx("%s: no \"begin\" line", filename);
			return(1);
		}
	} while (strncmp(buf, "begin ", 6));
	(void)sscanf(buf, "begin %o %1023[^\n\r]", &mode, buf);

	/* handle ~user/file format */
	if (buf[0] == '~') {
		if (!(p = strchr(buf, '/'))) {
			warnx("%s: illegal ~user", filename);
			return(1);
		}
		*p++ = NULL;
		if (!(pw = getpwnam(buf + 1))) {
			warnx("%s: no user %s", filename, buf);
			return(1);
		}
		n = strlen(pw->pw_dir);
		n1 = strlen(p);
		if (n + n1 + 2 > MAXPATHLEN) {
			warnx("%s: path too long", filename);
			return(1);
		}
		bcopy(p, buf + n + 1, n1 + 1);
		bcopy(pw->pw_dir, buf, n);
		buf[n] = '/';
	}

	if (!tostdout) {
		/* create output file, set mode */
		if (!freopen(buf, "w", stdout) ||
		    fchmod(fileno(stdout), mode&0666)) {
			warn("%s: %s", buf, filename);
			return(1);
d301 42
d345 5
a349 3
		if (!fgets(p = buf, sizeof(buf), stdin)) {
			warnx("%s: short file", filename);
			return(1);
d351 1
d353 8
d362 1
a362 1
		 * `n' is used to avoid writing out all the characters
d365 2
a366 1
		if ((n = DEC(*p)) <= 0)
d368 6
a373 2
		for (++p; n > 0; p += 4, n -= 3)
			if (n >= 3) {
d375 1
a375 1
				putchar(ch);
d377 1
a377 1
				putchar(ch);
d379 1
a379 1
				putchar(ch);
d382 3
a384 1
				if (n >= 1) {
d386 1
a386 1
					putchar(ch);
d388 5
a392 1
				if (n >= 2) {
d394 1
a394 1
					putchar(ch);
d396 4
a399 1
				if (n >= 3) {
d401 1
a401 1
					putchar(ch);
d405 28
a432 3
	if (!fgets(buf, sizeof(buf), stdin) || strcmp(buf, "end\n")) {
		warnx("%s: no \"end\" line", filename);
		return(1);
d434 2
a435 1
	return(0);
d441 5
a445 1
	(void)fprintf(stderr, "usage: uudecode [-p] [file ...]\n");
@


1.12
log
@add missing includes
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.11 2003/06/10 22:20:53 deraadt Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.11 2003/06/10 22:20:53 deraadt Exp $";
d63 1
d94 1
a94 2
				(void)fprintf(stderr, "uudecode: %s: %s\n",
				    *argv, strerror(errno));
d119 1
a119 2
			(void)fprintf(stderr,
			    "uudecode: %s: no \"begin\" line\n", filename);
d128 1
a128 2
			(void)fprintf(stderr, "uudecode: %s: illegal ~user.\n",
			    filename);
d133 1
a133 2
			(void)fprintf(stderr, "uudecode: %s: no user %s.\n",
			    filename, buf);
d139 1
a139 2
			(void)fprintf(stderr, "uudecode: %s: path too long.\n",
			    filename);
d151 1
a151 2
			(void)fprintf(stderr, "uudecode: %s: %s: %s\n", buf,
			    filename, strerror(errno));
d159 1
a159 2
			(void)fprintf(stderr, "uudecode: %s: short file.\n",
			    filename);
d194 1
a194 2
		(void)fprintf(stderr, "uudecode: %s: no \"end\" line.\n",
		    filename);
@


1.11
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.10 2003/06/03 02:56:21 millert Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.10 2003/06/03 02:56:21 millert Exp $";
d54 1
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.9 2001/11/19 19:02:17 mpech Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.9 2001/11/19 19:02:17 mpech Exp $";
d64 1
a64 1
static void usage();
d68 1
a68 3
main(argc, argv)
	int argc;
	char *argv[];
d207 1
a207 1
usage()
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.8 2000/02/01 03:23:46 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.8 2000/02/01 03:23:46 deraadt Exp $";
@


1.8
log
@no need to extern int errno if errno.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.7 1998/09/15 15:59:44 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.7 1998/09/15 15:59:44 millert Exp $";
d116 2
a117 2
	register int n;
	register char ch, *p;
@


1.7
log
@getopt returns int, not char; rahnds@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.6 1998/08/31 02:13:41 dgregor Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.6 1998/08/31 02:13:41 dgregor Exp $";
a114 1
	extern int errno;
@


1.6
log
@Add pass-through ('-p') option to uudecode.
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.5 1998/05/29 21:07:22 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.5 1998/05/29 21:07:22 deraadt Exp $";
d77 1
a77 1
	char ch;
@


1.5
log
@accept spaces in name
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.4 1998/05/11 01:19:05 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.4 1998/05/11 01:19:05 deraadt Exp $";
d49 1
a49 1
 * uudecode [file ...]
d53 3
d67 1
a67 1
static int decode();
d77 2
d82 9
a90 2
	while (getopt(argc, argv, "") != -1)
		usage();
d103 1
a103 1
			rval |= decode();
d107 1
a107 1
		rval = decode();
d113 1
a113 1
decode()
d157 8
a164 6
	/* create output file, set mode */
	if (!freopen(buf, "w", stdout) ||
	    fchmod(fileno(stdout), mode&0666)) {
		(void)fprintf(stderr, "uudecode: %s: %s: %s\n", buf,
		    filename, strerror(errno));
		return(1);
d216 1
a216 1
	(void)fprintf(stderr, "usage: uudecode [file ...]\n");
@


1.4
log
@set max field width of %s correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.3 1997/01/17 07:13:47 millert Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.3 1997/01/17 07:13:47 millert Exp $";
d118 1
a118 1
	(void)sscanf(buf, "begin %o %1023s", &mode, buf);
@


1.3
log
@r?index -> strr?chr
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.2 1996/06/26 05:42:21 deraadt Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.2 1996/06/26 05:42:21 deraadt Exp $";
d118 1
a118 1
	(void)sscanf(buf, "begin %o %s", &mode, buf);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: uudecode.c,v 1.6 1994/11/17 07:40:43 jtc Exp $	*/
d45 1
a45 1
static char rcsid[] = "$OpenBSD: uudecode.c,v 1.6 1994/11/17 07:40:43 jtc Exp $";
d122 1
a122 1
		if (!(p = index(buf, '/'))) {
@


1.1
log
@Initial revision
@
text
@d1 1
d45 1
a45 1
static char rcsid[] = "$NetBSD: uudecode.c,v 1.6 1994/11/17 07:40:43 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
