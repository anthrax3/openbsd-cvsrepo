head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.15
date	2015.11.05.20.07.15;	author florian;	state Exp;
branches;
next	1.14;
commitid	b6X6IgkdHiUHyPUP;

1.14
date	2015.10.16.13.37.44;	author millert;	state Exp;
branches;
next	1.13;
commitid	H99PcNtHGZMrNl2r;

1.13
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	sbrB3Q5CNxcwZpfU;

1.12
date	2015.10.07.06.44.01;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	5tdYgFXUJ1xTDxKq;

1.11
date	2015.02.08.23.40.34;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	yGZX28AeTChVE8eY;

1.10
date	2014.03.24.20.33.01;	author florian;	state Exp;
branches;
next	1.9;

1.9
date	2014.03.20.15.04.35;	author florian;	state Exp;
branches;
next	1.8;

1.8
date	2014.03.19.14.56.44;	author florian;	state Exp;
branches;
next	1.7;

1.7
date	2014.03.18.17.47.04;	author florian;	state Exp;
branches;
next	1.6;

1.6
date	2014.03.17.22.39.19;	author florian;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.17.22.37.53;	author florian;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.17.21.25.09;	author benno;	state Exp;
branches;
next	1.3;

1.3
date	2014.03.17.13.54.58;	author florian;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.17.12.51.58;	author florian;	state Exp;
branches;
next	1.1;

1.1
date	2014.03.17.12.49.13;	author florian;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Make our initial pledge stricter once we figured out in which mode we
are running.
In batch mode we are only reading from stdin and writing to stdout.
If no file is specified we are reading from stdin, writing to stdout
and need to control the tty for readpassphrase.
OK deraadt@@ on an earlier version some time ago.
@
text
@/*	$OpenBSD: htpasswd.c,v 1.14 2015/10/16 13:37:44 millert Exp $ */
/*
 * Copyright (c) 2014 Florian Obser <florian@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/stat.h>

#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pwd.h>
#include <readpassphrase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

__dead void	usage(void);
void		nag(char*);

extern char *__progname;

__dead void
usage(void)
{
	fprintf(stderr, "usage:\t%s [file] login\n", __progname);
	fprintf(stderr, "\t%s -I [file]\n", __progname);
	exit(1);
}

#define MAXNAG 5
int nagcount;

int
main(int argc, char** argv)
{
	char salt[_PASSWORD_LEN], tmpl[sizeof("/tmp/htpasswd-XXXXXXXXXX")];
	char hash[_PASSWORD_LEN], pass[1024], pass2[1024];
	char *line = NULL, *login = NULL, *tok;
	int c, fd, loginlen, batch = 0;
	FILE *in = NULL, *out = NULL;
	const char *file = NULL;
	size_t linesize = 0;
	ssize_t linelen;
	mode_t old_umask;

	if (pledge("stdio rpath wpath cpath flock tmppath tty", NULL) == -1)
		err(1, "pledge");

	while ((c = getopt(argc, argv, "I")) != -1) {
		switch (c) {
		case 'I':
			batch = 1;
			break;
		default:
			usage();
			/* NOT REACHED */
			break;
		}
	}

	argc -= optind;
	argv += optind;

	if (batch) {
		if (argc == 1)
			file = argv[0];
		else if (argc > 1)
			usage();
		else if (pledge("stdio", NULL) == -1)
			err(1, "pledge");

		if ((linelen = getline(&line, &linesize, stdin)) == -1)
			err(1, "cannot read login:password from stdin");
		line[linelen-1] = '\0';

		if ((tok = strstr(line, ":")) == NULL)
			errx(1, "cannot find ':' in input");
		*tok++ = '\0';

		if ((loginlen = asprintf(&login, "%s:", line)) == -1)
			err(1, "asprintf");

		if (strlcpy(pass, tok, sizeof(pass)) >= sizeof(pass))
			errx(1, "password too long");
	} else {

		switch (argc) {
		case 1:
			if (pledge("stdio tty", NULL) == -1)
				err(1, "pledge");
			if ((loginlen = asprintf(&login, "%s:", argv[0])) == -1)
				err(1, "asprintf");
			break;
		case 2:
			file = argv[0];
			if ((loginlen = asprintf(&login, "%s:", argv[1])) == -1)
				err(1, "asprintf");
			break;
		default:
			usage();
			/* NOT REACHED */
			break;
		}

		if (!readpassphrase("Password: ", pass, sizeof(pass),
		    RPP_ECHO_OFF))
			err(1, "unable to read password");
		if (!readpassphrase("Retype Password: ", pass2, sizeof(pass2),
		    RPP_ECHO_OFF)) {
			explicit_bzero(pass, sizeof(pass));
			err(1, "unable to read password");
		}
		if (strcmp(pass, pass2) != 0) {
			explicit_bzero(pass, sizeof(pass));
			explicit_bzero(pass2, sizeof(pass2));
			errx(1, "passwords don't match");
		}

		explicit_bzero(pass2, sizeof(pass2));
	}

	if (strlcpy(salt, bcrypt_gensalt(8), sizeof(salt)) >= sizeof(salt))
		errx(1, "salt too long");
	if (strlcpy(hash, bcrypt(pass, salt), sizeof(hash)) >= sizeof(hash))
		errx(1, "hash too long");
	explicit_bzero(pass, sizeof(pass));

	if (file == NULL)
		printf("%s%s\n", login, hash);
	else {
		if ((in = fopen(file, "r+")) == NULL) {
			if (errno == ENOENT) {
				old_umask = umask(S_IXUSR|
				    S_IWGRP|S_IRGRP|S_IXGRP|
				    S_IWOTH|S_IROTH|S_IXOTH);
				if ((out = fopen(file, "w")) == NULL)
					err(1, "cannot open password file for"
					    " reading or writing");
				umask(old_umask);
			} else
				err(1, "cannot open password file for"
					" reading or writing");
		} else
			if (flock(fileno(in), LOCK_EX|LOCK_NB) == -1)
				errx(1, "cannot lock password file");

		/* file already exits, copy content and filter login out */
		if (out == NULL) {
			strlcpy(tmpl, "/tmp/htpasswd-XXXXXXXXXX", sizeof(tmpl));
			if ((fd = mkstemp(tmpl)) == -1)
				err(1, "mkstemp");

			if ((out = fdopen(fd, "w+")) == NULL)
				err(1, "cannot open tempfile");

			while ((linelen = getline(&line, &linesize, in))
			    != -1) {
				if (strncmp(line, login, loginlen) != 0) {
					if (fprintf(out, "%s", line) == -1)
						errx(1, "cannot write to temp "
						    "file");
					nag(line);
				}
			}
		}
		if (fprintf(out, "%s%s\n", login, hash) == -1)
			errx(1, "cannot write new password hash");

		/* file already exists, overwrite it */
		if (in != NULL) {
			if (fseek(in, 0, SEEK_SET) == -1)
				err(1, "cannot seek in password file");
			if (fseek(out, 0, SEEK_SET) == -1)
				err(1, "cannot seek in temp file");
			if (ftruncate(fileno(in), 0) == -1)
				err(1, "cannot truncate password file");
			while ((linelen = getline(&line, &linesize, out))
			    != -1)
				if (fprintf(in, "%s", line) == -1)
					errx(1, "cannot write to password "
					    "file");
			if (fclose(in) == EOF)
				err(1, "cannot close password file");
		}
		if (fclose(out) == EOF) {
			if (in != NULL)
				err(1, "cannot close temp file");
			else
				err(1, "cannot close password file");
		}
		if (in != NULL && unlink(tmpl) == -1)
			err(1, "cannot delete temp file (%s)", tmpl);
	}
	if (nagcount >= MAXNAG)
		warnx("%d more logins not using bcryt.", nagcount - MAXNAG);
	exit(0);
}

void
nag(char* line)
{
	const char *tok;
	if (strtok(line, ":") != NULL)
		if ((tok = strtok(NULL, ":")) != NULL)
			if (strncmp(tok, "$2a$", 4) != 0 &&
			     strncmp(tok, "$2b$", 4) != 0) {
				nagcount++;
				if (nagcount <= MAXNAG)
					warnx("%s doesn't use bcrypt."
					    " Update the password.", line);
			}
}
@


1.14
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.13 2015/10/09 01:37:07 deraadt Exp $ */
d83 3
d103 2
@


1.13
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.12 2015/10/07 06:44:01 deraadt Exp $ */
d60 1
a60 1
	if (pledge("stdio rpath wpath cpath tmppath tty", NULL) == -1)
@


1.12
log
@tame "stdio rpath wpath cpath tmppath tty".  "tty" is the important part
here, permitting use of readpassphrase()
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.11 2015/02/08 23:40:34 deraadt Exp $ */
d60 2
a61 2
	if (tame("stdio rpath wpath cpath tmppath tty", NULL) == -1)
		err(1, "tame");
@


1.11
log
@in getopt() blocks, stop incrementing flag variable which are supposed
to just be 0/1
ok miod florian
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.10 2014/03/24 20:33:01 florian Exp $ */
d50 7
a56 2
	FILE *in, *out;
	size_t linesize;
a58 5
	int c, fd, loginlen, batch;
	char hash[_PASSWORD_LEN], *line, *login, pass[1024], pass2[1024];
	char salt[_PASSWORD_LEN], tmpl[sizeof("/tmp/htpasswd-XXXXXXXXXX")];
	char *tok;
	const char *file;
d60 2
a61 7
	file = NULL;
	login = NULL;
	in = NULL;
	out = NULL;
	line = NULL;
	linesize = 0;
	batch = 0;
@


1.10
log
@sf@@ pointed out that the -B flag is already in use by apache's
htpasswd (since version 2.4); change it to -I. The -B flag was not in
use for a long time so this change should not cause too much trouble.
OK sf@@, jmc@@
no objections from sthen@@
"kein problem damit" benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.9 2014/03/20 15:04:35 florian Exp $ */
d71 1
a71 1
			batch++;
@


1.9
log
@Various fixes from Tiago Cunha tcunha _AT_ gmx _DOT_ com:
- const for file and tok
- remove \n from err(3)
- typo in error message
- s/err/errx/ for functions that do not set errno
- s/fprintf(stderr,...)/warnx/

Thanks!

OK sthen, benno
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.8 2014/03/19 14:56:44 florian Exp $ */
d40 1
a40 1
	fprintf(stderr, "\t%s -B [file]\n", __progname);
d68 1
a68 1
	while ((c = getopt(argc, argv, "B")) != -1) {
d70 1
a70 1
		case 'B':
@


1.8
log
@missing -B in second usage line
pointed out by jmc@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.7 2014/03/18 17:47:04 florian Exp $ */
d55 1
a55 1
	char hash[_PASSWORD_LEN], *file, *line, *login, pass[1024], pass2[1024];
d58 1
d89 1
a89 1
			err(1, "cannot read login:password from stdin\n");
d93 1
a93 1
			errx(1, "cannot find ';' in input");
d100 1
a100 1
			errx(1, "password too long\n");
d137 1
a137 1
		err(1, "salt too long");
d139 1
a139 1
		err(1, "hash too long");
d174 1
a174 1
						err(1, "cannot write to temp "
d181 1
a181 1
			err(1, "cannot write new password hash");
d194 2
a195 1
					err(1, "cannot write to password file");
d209 1
a209 2
		fprintf(stderr, "%d more logins not using bcryt.\n",
		    nagcount - MAXNAG);
d216 1
a216 1
	char *tok;
d223 2
a224 2
					fprintf(stderr, "%s doesn't use bcrypt."
					    " Update the password.\n", line);
@


1.7
log
@Batch mode; read exactly one line "login:unencrypted-password" from
stdin.
OK benno
man page tweak and OK sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.6 2014/03/17 22:39:19 florian Exp $ */
d40 1
a40 1
	fprintf(stderr, "\t%s [file]\n", __progname);
@


1.6
log
@Stop nagging after 5 non-bcrypt hashes
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.5 2014/03/17 22:37:53 florian Exp $ */
d39 2
a40 1
	fprintf(stderr, "usage: %s [file] login\n", __progname);
d54 1
a54 1
	int fd, loginlen;
d57 1
d65 1
d67 29
a95 3
	switch (argc) {
	case 2:
		if ((loginlen = asprintf(&login, "%s:", argv[1])) == -1)
a96 11
		break;
	case 3:
		file = argv[1];
		if ((loginlen = asprintf(&login, "%s:", argv[2])) == -1)
			err(1, "asprintf");
		break;
	default:
		usage();
		/* NOT REACHED */
		break;
	}
d98 34
a131 9
	if (!readpassphrase("Password: ", pass, sizeof(pass), RPP_ECHO_OFF))
		err(1, "unable to read password");
	if (!readpassphrase("Retype Password: ", pass2, sizeof(pass2),
	    RPP_ECHO_OFF)) {
		explicit_bzero(pass, sizeof(pass));
		err(1, "unable to read password");
	}
	if (strcmp(pass, pass2) != 0) {
		explicit_bzero(pass, sizeof(pass));
a132 1
		errx(1, "passwords don't match");
a134 1
	explicit_bzero(pass2, sizeof(pass2));
@


1.5
log
@flock password file
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.4 2014/03/17 21:25:09 benno Exp $ */
d43 3
d165 3
d178 6
a183 3
			     strncmp(tok, "$2b$", 4) != 0)
				fprintf(stderr, "%s doesn't use bcrypt."
				    " Update the password.\n", line);
@


1.4
log
@move ftruncate down, lessen the chance that the file it might be left
empty. while there, fix an error msg.
ok florian
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.3 2014/03/17 13:54:58 florian Exp $ */
d22 1
d112 4
a115 1
		}
@


1.3
log
@No need for \t in usage(), pointed out by sthen and should have been
in the initial commit. Sorry about that.
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.2 2014/03/17 12:51:58 florian Exp $ */
d109 2
a110 1
				err(1, "cannot open password file for reading");
d138 2
a141 2
			if (fseek(out, 0, SEEK_SET) == -1)
				err(1, "cannot seek in temp file");
@


1.2
log
@The correct idiom is of course the umask song and dance. Brain-fart by
me.
pointed out by deraadt
OK benno
@
text
@d1 1
a1 1
/*	$OpenBSD: htpasswd.c,v 1.1 2014/03/17 12:49:13 florian Exp $ */
d38 1
a38 1
	fprintf(stderr, "usage:\t%s [file] login\n", __progname);
@


1.1
log
@Re-implement htpasswd from scratch. There is so much bad advice on the
internet that it's better to have a known tool in base.
Intentionally not switch compatible with the old htpasswd. The only
switch really needed would be for batch mode, but that was inherently
insecure in the old htpasswd. Batch mode will be coming shortly.
OK sthen, tedu, benno
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d48 1
d101 3
d107 1
a107 4
				if (fchmod(fileno(out), S_IRUSR | S_IWUSR)
				    == -1)
					err(1, "cannot chmod new password"
					    " file");
@

