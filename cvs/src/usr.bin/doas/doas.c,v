head	1.70;
access;
symbols
	OPENBSD_6_0:1.60.0.2
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34;
locks; strict;
comment	@ * @;


1.70
date	2017.03.09.21.25.01;	author tedu;	state Exp;
branches;
next	1.69;
commitid	YUchw9zGSdX3FqNM;

1.69
date	2017.01.14.18.51.24;	author tedu;	state Exp;
branches;
next	1.68;
commitid	3MaGu3f4JP8OdmlZ;

1.68
date	2016.10.05.23.28.28;	author tb;	state Exp;
branches;
next	1.67;
commitid	AhuM5yTSLkTY5QRt;

1.67
date	2016.10.05.17.40.25;	author tedu;	state Exp;
branches;
next	1.66;
commitid	LX6l0SvyemQxMchQ;

1.66
date	2016.10.05.17.36.53;	author tedu;	state Exp;
branches;
next	1.65;
commitid	82M7dxXP7itRBRZW;

1.65
date	2016.09.15.00.58.23;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	jUUEan3Kanf6WvvC;

1.64
date	2016.09.03.11.03.18;	author tedu;	state Exp;
branches;
next	1.63;
commitid	IWdntRWB5rz6pNL7;

1.63
date	2016.09.02.18.12.30;	author tedu;	state Exp;
branches;
next	1.62;
commitid	6VZ1JPJuzXuXcUz8;

1.62
date	2016.09.01.17.30.52;	author tedu;	state Exp;
branches;
next	1.61;
commitid	7e61GfsDDbYyVwXo;

1.61
date	2016.09.01.13.16.38;	author tedu;	state Exp;
branches;
next	1.60;
commitid	wbpa5qxXhbtWZnUn;

1.60
date	2016.07.18.16.46.30;	author zhuk;	state Exp;
branches;
next	1.59;
commitid	UZ0dejcq3zYEr4so;

1.59
date	2016.07.12.12.10.42;	author semarie;	state Exp;
branches;
next	1.58;
commitid	S7brQBKin5bRZ4W6;

1.58
date	2016.06.24.20.49.56;	author tedu;	state Exp;
branches;
next	1.57;
commitid	adB7rfgJ7E3bgQoG;

1.57
date	2016.06.19.19.29.43;	author martijn;	state Exp;
branches;
next	1.56;
commitid	vJP1y2NiYr0CmjHu;

1.56
date	2016.06.16.17.40.30;	author tedu;	state Exp;
branches;
next	1.55;
commitid	kwCFU8ML8KNeONv7;

1.55
date	2016.06.07.16.49.23;	author tedu;	state Exp;
branches;
next	1.54;
commitid	CRAPRajOEq58XUlb;

1.54
date	2016.06.07.14.11.16;	author tedu;	state Exp;
branches;
next	1.53;
commitid	NxhIlBOlOSgsJvPH;

1.53
date	2016.06.05.00.46.34;	author djm;	state Exp;
branches;
next	1.52;
commitid	zmRA0Q6jBCGEttFd;

1.52
date	2016.04.28.04.48.56;	author tedu;	state Exp;
branches;
next	1.51;
commitid	gjq77Zf5PKJ20VdP;

1.51
date	2016.02.15.19.56.11;	author martijn;	state Exp;
branches;
next	1.50;
commitid	g0KyJ5UxCx7zirdB;

1.50
date	2016.02.07.20.01.58;	author tedu;	state Exp;
branches;
next	1.49;
commitid	qzzPnBA5CWuapJpC;

1.49
date	2016.01.24.13.19.21;	author gsoares;	state Exp;
branches;
next	1.48;
commitid	meIFzTNzCJETpuYU;

1.48
date	2015.12.08.14.45.36;	author tedu;	state Exp;
branches;
next	1.47;
commitid	eM6TiLvyS0HhF3cV;

1.47
date	2015.12.08.13.39.40;	author sthen;	state Exp;
branches;
next	1.46;
commitid	BueVeGaGrRzCMKM9;

1.46
date	2015.12.03.08.12.15;	author tedu;	state Exp;
branches;
next	1.45;
commitid	Ppy3ypt9ZwyOQuTG;

1.45
date	2015.10.24.19.23.48;	author miod;	state Exp;
branches;
next	1.44;
commitid	CUU2THHGDlkHECRp;

1.44
date	2015.10.22.12.43.26;	author tedu;	state Exp;
branches;
next	1.43;
commitid	yzIwCxY3lQb4quEM;

1.43
date	2015.10.22.04.57.20;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	sKRpXSLmeghVEmqf;

1.42
date	2015.09.19.02.47.46;	author tedu;	state Exp;
branches;
next	1.41;
commitid	UCoJDbLHQYoChFJi;

1.41
date	2015.09.03.20.05.58;	author tedu;	state Exp;
branches;
next	1.40;
commitid	RdHT7LkqINABgNS3;

1.40
date	2015.09.01.13.20.53;	author tedu;	state Exp;
branches;
next	1.39;
commitid	PajKc5RFOakT4P3p;

1.39
date	2015.08.27.16.31.02;	author tedu;	state Exp;
branches;
next	1.38;
commitid	OuppCl2nMr8CEbNg;

1.38
date	2015.08.22.16.01.05;	author doug;	state Exp;
branches;
next	1.37;
commitid	wXnHzIJce2FWv9yw;

1.37
date	2015.08.20.18.42.11;	author rzalamena;	state Exp;
branches;
next	1.36;
commitid	o5ZGN2rCsQ5N7ZSJ;

1.36
date	2015.08.13.16.27.22;	author espie;	state Exp;
branches;
next	1.35;
commitid	CJvNRKMXVxne6Zu4;

1.35
date	2015.08.12.15.59.53;	author espie;	state Exp;
branches;
next	1.34;
commitid	mXL506nmhK1R5ymv;

1.34
date	2015.08.03.15.31.05;	author tedu;	state Exp;
branches;
next	1.33;
commitid	jphzum3RcDRnGIuc;

1.33
date	2015.07.30.17.04.33;	author tedu;	state Exp;
branches;
next	1.32;
commitid	c9uYtzgwOtJSB1aR;

1.32
date	2015.07.29.00.00.31;	author tedu;	state Exp;
branches;
next	1.31;
commitid	ph5j9KvWhF9BO9N0;

1.31
date	2015.07.28.21.36.03;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	CXT7uYKGxfAfQx3l;

1.30
date	2015.07.28.19.49.04;	author zhuk;	state Exp;
branches;
next	1.29;
commitid	6r84NEePx0fBj3f9;

1.29
date	2015.07.28.14.08.52;	author zhuk;	state Exp;
branches;
next	1.28;
commitid	Y7hXC8ns2zabDfZj;

1.28
date	2015.07.27.15.38.11;	author espie;	state Exp;
branches;
next	1.27;
commitid	IRC6P1R6EcArJ6VU;

1.27
date	2015.07.26.22.44.33;	author tedu;	state Exp;
branches;
next	1.26;
commitid	XPk7mxxXYYSGNRCr;

1.26
date	2015.07.26.20.47.01;	author espie;	state Exp;
branches;
next	1.25;
commitid	hORzonxEylWw0ngd;

1.25
date	2015.07.26.19.49.11;	author zhuk;	state Exp;
branches;
next	1.24;
commitid	PQtZz9HuPhtqaVLf;

1.24
date	2015.07.26.19.14.46;	author tedu;	state Exp;
branches;
next	1.23;
commitid	ztG2Ymx7zowPtrfy;

1.23
date	2015.07.26.19.08.17;	author zhuk;	state Exp;
branches;
next	1.22;
commitid	r44KZleNdMeMytga;

1.22
date	2015.07.26.17.24.02;	author zhuk;	state Exp;
branches;
next	1.21;
commitid	qy8dXDJHprpAdhJv;

1.21
date	2015.07.24.06.36.42;	author zhuk;	state Exp;
branches;
next	1.20;
commitid	yfM2cEfXpqdeoUpn;

1.20
date	2015.07.22.16.35.03;	author zhuk;	state Exp;
branches;
next	1.19;
commitid	D6EKSVQCK53vyNbu;

1.19
date	2015.07.22.05.37.23;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	QaDlphCqblKkOggn;

1.18
date	2015.07.21.17.49.33;	author jmc;	state Exp;
branches;
next	1.17;
commitid	98c5aoWCxUyOPHTX;

1.17
date	2015.07.21.16.15.20;	author tedu;	state Exp;
branches;
next	1.16;
commitid	lkOfdgwVqsNO3TYH;

1.16
date	2015.07.21.16.12.04;	author tedu;	state Exp;
branches;
next	1.15;
commitid	W4YlDHDIbBNVx6Mv;

1.15
date	2015.07.21.11.04.06;	author zhuk;	state Exp;
branches;
next	1.14;
commitid	H7gCQhORmxwF32W8;

1.14
date	2015.07.20.01.04.37;	author tedu;	state Exp;
branches;
next	1.13;
commitid	Yfd2U1pdCUGJ805y;

1.13
date	2015.07.20.01.00.48;	author tedu;	state Exp;
branches;
next	1.12;
commitid	rLC6XiZ21kyhHjsN;

1.12
date	2015.07.20.00.57.53;	author tedu;	state Exp;
branches;
next	1.11;
commitid	2T9FZpyl0jqgFvJd;

1.11
date	2015.07.20.00.54.01;	author tedu;	state Exp;
branches;
next	1.10;
commitid	7MQZfMGGnPt5s9PM;

1.10
date	2015.07.19.01.19.22;	author tedu;	state Exp;
branches;
next	1.9;
commitid	j3tctJ07zocFTW37;

1.9
date	2015.07.18.18.44.26;	author tedu;	state Exp;
branches;
next	1.8;
commitid	qC3Kjb4Uz7Qu2zmr;

1.8
date	2015.07.18.06.33.23;	author nicm;	state Exp;
branches;
next	1.7;
commitid	mFBxrbyYSHpkhD0D;

1.7
date	2015.07.18.00.19.38;	author doug;	state Exp;
branches;
next	1.6;
commitid	W3fkglNDS6TKzvev;

1.6
date	2015.07.16.23.22.08;	author nicm;	state Exp;
branches;
next	1.5;
commitid	iwFCX5Q3zIEmwiaA;

1.5
date	2015.07.16.22.11.01;	author nicm;	state Exp;
branches;
next	1.4;
commitid	e5IIRDvhjsuvynHd;

1.4
date	2015.07.16.21.57.54;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	kebVYeDdHXydH2iK;

1.3
date	2015.07.16.21.55.03;	author tedu;	state Exp;
branches;
next	1.2;
commitid	rFLEsw1udQWLzeS6;

1.2
date	2015.07.16.21.00.59;	author tedu;	state Exp;
branches;
next	1.1;
commitid	LY1FdyQ7yGHabFfl;

1.1
date	2015.07.16.20.44.21;	author tedu;	state Exp;
branches;
next	;
commitid	XJUTPk2EaAhf0EJC;


desc
@@


1.70
log
@exit test for -L was reversed. spotted by Michael Forney
@
text
@/* $OpenBSD: doas.c,v 1.69 2017/01/14 18:51:24 tedu Exp $ */
/*
 * Copyright (c) 2015 Ted Unangst <tedu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>

#include <limits.h>
#include <login_cap.h>
#include <bsd_auth.h>
#include <readpassphrase.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>
#include <syslog.h>
#include <errno.h>
#include <fcntl.h>

#include "doas.h"

static void __dead
usage(void)
{
	fprintf(stderr, "usage: doas [-Lns] [-a style] [-C config] [-u user]"
	    " command [args]\n");
	exit(1);
}

static int
parseuid(const char *s, uid_t *uid)
{
	struct passwd *pw;
	const char *errstr;

	if ((pw = getpwnam(s)) != NULL) {
		*uid = pw->pw_uid;
		return 0;
	}
	*uid = strtonum(s, 0, UID_MAX, &errstr);
	if (errstr)
		return -1;
	return 0;
}

static int
uidcheck(const char *s, uid_t desired)
{
	uid_t uid;

	if (parseuid(s, &uid) != 0)
		return -1;
	if (uid != desired)
		return -1;
	return 0;
}

static int
parsegid(const char *s, gid_t *gid)
{
	struct group *gr;
	const char *errstr;

	if ((gr = getgrnam(s)) != NULL) {
		*gid = gr->gr_gid;
		return 0;
	}
	*gid = strtonum(s, 0, GID_MAX, &errstr);
	if (errstr)
		return -1;
	return 0;
}

static int
match(uid_t uid, gid_t *groups, int ngroups, uid_t target, const char *cmd,
    const char **cmdargs, struct rule *r)
{
	int i;

	if (r->ident[0] == ':') {
		gid_t rgid;
		if (parsegid(r->ident + 1, &rgid) == -1)
			return 0;
		for (i = 0; i < ngroups; i++) {
			if (rgid == groups[i])
				break;
		}
		if (i == ngroups)
			return 0;
	} else {
		if (uidcheck(r->ident, uid) != 0)
			return 0;
	}
	if (r->target && uidcheck(r->target, target) != 0)
		return 0;
	if (r->cmd) {
		if (strcmp(r->cmd, cmd))
			return 0;
		if (r->cmdargs) {
			/* if arguments were given, they should match explicitly */
			for (i = 0; r->cmdargs[i]; i++) {
				if (!cmdargs[i])
					return 0;
				if (strcmp(r->cmdargs[i], cmdargs[i]))
					return 0;
			}
			if (cmdargs[i])
				return 0;
		}
	}
	return 1;
}

static int
permit(uid_t uid, gid_t *groups, int ngroups, struct rule **lastr,
    uid_t target, const char *cmd, const char **cmdargs)
{
	int i;

	*lastr = NULL;
	for (i = 0; i < nrules; i++) {
		if (match(uid, groups, ngroups, target, cmd,
		    cmdargs, rules[i]))
			*lastr = rules[i];
	}
	if (!*lastr)
		return 0;
	return (*lastr)->action == PERMIT;
}

static void
parseconfig(const char *filename, int checkperms)
{
	extern FILE *yyfp;
	extern int yyparse(void);
	struct stat sb;

	yyfp = fopen(filename, "r");
	if (!yyfp)
		err(1, checkperms ? "doas is not enabled, %s" :
		    "could not open config file %s", filename);

	if (checkperms) {
		if (fstat(fileno(yyfp), &sb) != 0)
			err(1, "fstat(\"%s\")", filename);
		if ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)
			errx(1, "%s is writable by group or other", filename);
		if (sb.st_uid != 0)
			errx(1, "%s is not owned by root", filename);
	}

	yyparse();
	fclose(yyfp);
	if (parse_errors)
		exit(1);
}

static void __dead
checkconfig(const char *confpath, int argc, char **argv,
    uid_t uid, gid_t *groups, int ngroups, uid_t target)
{
	struct rule *rule;

	setresuid(uid, uid, uid);
	parseconfig(confpath, 0);
	if (!argc)
		exit(0);

	if (permit(uid, groups, ngroups, &rule, target, argv[0],
	    (const char **)argv + 1)) {
		printf("permit%s\n", (rule->options & NOPASS) ? " nopass" : "");
		exit(0);
	} else {
		printf("deny\n");
		exit(1);
	}
}

static void
authuser(char *myname, char *login_style, int persist)
{
	char *challenge = NULL, *response, rbuf[1024], cbuf[128];
	auth_session_t *as;
	int fd = -1;

	if (persist)
		fd = open("/dev/tty", O_RDWR);
	if (fd != -1) {
		if (ioctl(fd, TIOCCHKVERAUTH) == 0)
			goto good;
	}

	if (!(as = auth_userchallenge(myname, login_style, "auth-doas",
	    &challenge)))
		errx(1, "Authorization failed");
	if (!challenge) {
		char host[HOST_NAME_MAX + 1];
		if (gethostname(host, sizeof(host)))
			snprintf(host, sizeof(host), "?");
		snprintf(cbuf, sizeof(cbuf),
		    "\rdoas (%.32s@@%.32s) password: ", myname, host);
		challenge = cbuf;
	}
	response = readpassphrase(challenge, rbuf, sizeof(rbuf),
	    RPP_REQUIRE_TTY);
	if (response == NULL && errno == ENOTTY) {
		syslog(LOG_AUTHPRIV | LOG_NOTICE,
		    "tty required for %s", myname);
		errx(1, "a tty is required");
	}
	if (!auth_userresponse(as, response, 0)) {
		syslog(LOG_AUTHPRIV | LOG_NOTICE,
		    "failed auth for %s", myname);
		errc(1, EPERM, NULL);
	}
	explicit_bzero(rbuf, sizeof(rbuf));
good:
	if (fd != -1) {
		int secs = 5 * 60;
		ioctl(fd, TIOCSETVERAUTH, &secs);
		close(fd);
	}
}

int
main(int argc, char **argv)
{
	const char *safepath = "/bin:/sbin:/usr/bin:/usr/sbin:"
	    "/usr/local/bin:/usr/local/sbin";
	const char *confpath = NULL;
	char *shargv[] = { NULL, NULL };
	char *sh;
	const char *cmd;
	char cmdline[LINE_MAX];
	char myname[_PW_NAME_LEN + 1];
	struct passwd *pw;
	struct rule *rule;
	uid_t uid;
	uid_t target = 0;
	gid_t groups[NGROUPS_MAX + 1];
	int ngroups;
	int i, ch;
	int sflag = 0;
	int nflag = 0;
	char cwdpath[PATH_MAX];
	const char *cwd;
	char *login_style = NULL;
	char **envp;

	setprogname("doas");

	closefrom(STDERR_FILENO + 1);

	uid = getuid();

	while ((ch = getopt(argc, argv, "a:C:Lnsu:")) != -1) {
		switch (ch) {
		case 'a':
			login_style = optarg;
			break;
		case 'C':
			confpath = optarg;
			break;
		case 'L':
			i = open("/dev/tty", O_RDWR);
			if (i != -1)
				ioctl(i, TIOCCLRVERAUTH);
			exit(i == -1);
		case 'u':
			if (parseuid(optarg, &target) != 0)
				errx(1, "unknown user");
			break;
		case 'n':
			nflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		default:
			usage();
			break;
		}
	}
	argv += optind;
	argc -= optind;

	if (confpath) {
		if (sflag)
			usage();
	} else if ((!sflag && !argc) || (sflag && argc))
		usage();

	pw = getpwuid(uid);
	if (!pw)
		err(1, "getpwuid failed");
	if (strlcpy(myname, pw->pw_name, sizeof(myname)) >= sizeof(myname))
		errx(1, "pw_name too long");
	ngroups = getgroups(NGROUPS_MAX, groups);
	if (ngroups == -1)
		err(1, "can't get groups");
	groups[ngroups++] = getgid();

	if (sflag) {
		sh = getenv("SHELL");
		if (sh == NULL || *sh == '\0') {
			shargv[0] = strdup(pw->pw_shell);
			if (shargv[0] == NULL)
				err(1, NULL);
		} else
			shargv[0] = sh;
		argv = shargv;
		argc = 1;
	}

	if (confpath) {
		checkconfig(confpath, argc, argv, uid, groups, ngroups,
		    target);
		exit(1);	/* fail safe */
	}

	if (geteuid())
		errx(1, "not installed setuid");

	parseconfig("/etc/doas.conf", 1);

	/* cmdline is used only for logging, no need to abort on truncate */
	(void)strlcpy(cmdline, argv[0], sizeof(cmdline));
	for (i = 1; i < argc; i++) {
		if (strlcat(cmdline, " ", sizeof(cmdline)) >= sizeof(cmdline))
			break;
		if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
			break;
	}

	cmd = argv[0];
	if (!permit(uid, groups, ngroups, &rule, target, cmd,
	    (const char **)argv + 1)) {
		syslog(LOG_AUTHPRIV | LOG_NOTICE,
		    "failed command for %s: %s", myname, cmdline);
		errc(1, EPERM, NULL);
	}

	if (!(rule->options & NOPASS)) {
		if (nflag)
			errx(1, "Authorization required");

		authuser(myname, login_style, rule->options & PERSIST);
	}

	if (pledge("stdio rpath getpw exec id", NULL) == -1)
		err(1, "pledge");

	pw = getpwuid(target);
	if (!pw)
		errx(1, "no passwd entry for target");

	if (setusercontext(NULL, pw, target, LOGIN_SETGROUP |
	    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |
	    LOGIN_SETUSER) != 0)
		errx(1, "failed to set user context for target");

	if (pledge("stdio rpath exec", NULL) == -1)
		err(1, "pledge");

	if (getcwd(cwdpath, sizeof(cwdpath)) == NULL)
		cwd = "(failed)";
	else
		cwd = cwdpath;

	if (pledge("stdio exec", NULL) == -1)
		err(1, "pledge");

	syslog(LOG_AUTHPRIV | LOG_INFO, "%s ran command %s as %s from %s",
	    myname, cmdline, pw->pw_name, cwd);

	envp = prepenv(rule);

	if (rule->cmd) {
		if (setenv("PATH", safepath, 1) == -1)
			err(1, "failed to set PATH '%s'", safepath);
	}
	execvpe(cmd, argv, envp);
	if (errno == ENOENT)
		errx(1, "%s: command not found", cmd);
	err(1, "%s", cmd);
}
@


1.69
log
@add a geteuid check to make sure we're root before plowing into setauth.
spare some debugging effort in case doas is not installed setuid.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.68 2016/10/05 23:28:28 tb Exp $ */
d285 1
a285 1
			exit(i != -1);
@


1.68
log
@Add back the call to yyparse() that was accidentally dropped in the
previous commit. Fortunately, doas fails closed...

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.67 2016/10/05 17:40:25 tedu Exp $ */
d337 3
@


1.67
log
@move yyparse decl next to yyfp
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.66 2016/10/05 17:36:53 tedu Exp $ */
d169 1
@


1.66
log
@as a result of the env rework, arraylen() is only used in parse.y.
move it there and make it static.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.65 2016/09/15 00:58:23 deraadt Exp $ */
d152 1
a168 1
	yyparse();
@


1.65
log
@use static in the right places to seperate modules better
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.64 2016/09/03 11:03:18 tedu Exp $ */
a44 12
}

size_t
arraylen(const char **arr)
{
	size_t cnt = 0;

	while (*arr) {
		cnt++;
		arr++;
	}
	return cnt;
@


1.64
log
@the sudo timeout was 5 minutes i believe, so we'll match that.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.63 2016/09/02 18:12:30 tedu Exp $ */
a163 1
	extern int yyparse(void);
@


1.63
log
@add support for the verified auth ioctls using 'persist' rules.
ok deraadt henning
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.62 2016/09/01 17:30:52 tedu Exp $ */
d248 1
a248 1
		int secs = 10 * 60;
@


1.62
log
@unconst these parameters; i won't be changing bsd auth today.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.61 2016/09/01 13:16:38 tedu Exp $ */
d20 1
d35 1
d42 1
a42 1
	fprintf(stderr, "usage: doas [-ns] [-a style] [-C config] [-u user]"
d209 1
a209 1
authuser(char *myname, char *login_style)
d213 8
d246 6
a280 3
	if (pledge("stdio rpath getpw tty recvfd proc exec id", NULL) == -1)
		err(1, "pledge");

d285 1
a285 1
	while ((ch = getopt(argc, argv, "a:C:nsu:")) != -1) {
d293 5
d373 1
a373 1
		authuser(myname, login_style);
@


1.61
log
@move the authentication code to a function
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.60 2016/07/18 16:46:30 zhuk Exp $ */
d207 1
a207 1
authuser(const char *myname, const char *login_style)
@


1.60
log
@The string with path to shell could be taken directly from struct passwd.
At some point later the data it points to is overridden by getpwuid() call,
resulting in garbage. The problem could be easily demonstreated by double
doas call:

  $ doas doas -su _sndio
  doas: mpty: command not found

The fix is easy: just strdup() the pw_shell field value.

okay tedu@@, tweaks from & okay natano@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.59 2016/07/12 12:10:42 semarie Exp $ */
d206 32
a351 3
		char *challenge = NULL, *response, rbuf[1024], cbuf[128];
		auth_session_t *as;

d355 1
a355 24
		if (!(as = auth_userchallenge(myname, login_style, "auth-doas",
		    &challenge)))
			errx(1, "Authorization failed");
		if (!challenge) {
			char host[HOST_NAME_MAX + 1];
			if (gethostname(host, sizeof(host)))
				snprintf(host, sizeof(host), "?");
			snprintf(cbuf, sizeof(cbuf),
			    "\rdoas (%.32s@@%.32s) password: ", myname, host);
			challenge = cbuf;
		}
		response = readpassphrase(challenge, rbuf, sizeof(rbuf),
		    RPP_REQUIRE_TTY);
		if (response == NULL && errno == ENOTTY) {
			syslog(LOG_AUTHPRIV | LOG_NOTICE,
			    "tty required for %s", myname);
			errx(1, "a tty is required");
		}
		if (!auth_userresponse(as, response, 0)) {
			syslog(LOG_AUTHPRIV | LOG_NOTICE,
			    "failed auth for %s", myname);
			errc(1, EPERM, NULL);
		}
		explicit_bzero(rbuf, sizeof(rbuf));
@


1.59
log
@add "recvfd" to doas(1) for use with skey.

ok tb@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.58 2016/06/24 20:49:56 tedu Exp $ */
d284 5
a288 3
		if (sh == NULL || *sh == '\0')
			shargv[0] = pw->pw_shell;
		else
@


1.58
log
@move a space to the correct spot
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.57 2016/06/19 19:29:43 martijn Exp $ */
d233 1
a233 1
	if (pledge("stdio rpath getpw tty proc exec id", NULL) == -1)
@


1.57
log
@Move the RB_ code from doas.h to env.c, and limit the environment interface to a
simple prepenv function.

OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.56 2016/06/16 17:40:30 tedu Exp $ */
d301 1
a301 1
	(void) strlcpy(cmdline, argv[0], sizeof(cmdline));
d311 1
a311 1
	    (const char**)argv + 1)) {
@


1.56
log
@the environment handling code was showing its age. just because environ
is a char** array doesn't mean we must exclusively operate on such.
convert to a red-black tree, manipulate as desired, then flatten to array.
potentially overkill for the current operations, but reading the tea leaves
i see that more manipulations are desired.
ok tb
(and some thought provoking disagreement from martijn)
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.55 2016/06/07 16:49:23 tedu Exp $ */
d207 1
a207 1
main(int argc, char **argv, char **envp)
a214 1
	struct env *env;
d229 1
d376 1
a376 3
	env = createenv(envp);
	env = filterenv(env, rule);
	envp = flattenenv(env);
@


1.55
log
@revert recent changes to allow setenv. everybody now has an idea about
how to do things better, so let's take a step back and reconsider.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.52 2016/04/28 04:48:56 tedu Exp $ */
a184 99
/*
 * Copy the environment variables in safeset from oldenvp to envp.
 */
static int
copyenvhelper(const char **oldenvp, const char **safeset, int nsafe,
    char **envp, int ei)
{
	int i;

	for (i = 0; i < nsafe; i++) {
		const char **oe = oldenvp;
		while (*oe) {
			size_t len = strlen(safeset[i]);
			if (strncmp(*oe, safeset[i], len) == 0 &&
			    (*oe)[len] == '=') {
				if (!(envp[ei++] = strdup(*oe)))
					err(1, "strdup");
				break;
			}
			oe++;
		}
	}
	return ei;
}

static char **
copyenv(const char **oldenvp, struct rule *rule)
{
	const char *safeset[] = {
		"DISPLAY", "HOME", "LOGNAME", "MAIL",
		"PATH", "TERM", "USER", "USERNAME",
		NULL
	};
	const char *badset[] = {
		"ENV",
		NULL
	};
	char **envp;
	const char **extra;
	int ei;
	int nsafe, nbad;
	int nextras = 0;

	/* if there was no envvar whitelist, pass all except badset ones */
	nbad = arraylen(badset);
	if ((rule->options & KEEPENV) && !rule->envlist) {
		size_t iold, inew;
		size_t oldlen = arraylen(oldenvp);
		envp = reallocarray(NULL, oldlen + 1, sizeof(char *));
		if (!envp)
			err(1, "reallocarray");
		for (inew = iold = 0; iold < oldlen; iold++) {
			size_t ibad;
			for (ibad = 0; ibad < nbad; ibad++) {
				size_t len = strlen(badset[ibad]);
				if (strncmp(oldenvp[iold], badset[ibad], len) == 0 &&
				    oldenvp[iold][len] == '=') {
					break;
				}
			}
			if (ibad == nbad) {
				if (!(envp[inew] = strdup(oldenvp[iold])))
					err(1, "strdup");
				inew++;
			}
		}
		envp[inew] = NULL;
		return envp;
	}

	nsafe = arraylen(safeset);
	if ((extra = rule->envlist)) {
		size_t isafe;
		nextras = arraylen(extra);
		for (isafe = 0; isafe < nsafe; isafe++) {
			size_t iextras;
			for (iextras = 0; iextras < nextras; iextras++) {
				if (strcmp(extra[iextras], safeset[isafe]) == 0) {
					nextras--;
					extra[iextras] = extra[nextras];
					extra[nextras] = NULL;
					iextras--;
				}
			}
		}
	}

	envp = reallocarray(NULL, nsafe + nextras + 1, sizeof(char *));
	if (!envp)
		err(1, "can't allocate new environment");

	ei = 0;
	ei = copyenvhelper(oldenvp, safeset, nsafe, envp, ei);
	ei = copyenvhelper(oldenvp, rule->envlist, nextras, envp, ei);
	envp[ei] = NULL;

	return envp;
}

d215 1
d376 3
a378 1
	envp = copyenv((const char **)envp, rule);
@


1.54
log
@merge setenv feature into keepenv. less grammar, more better.
minimal changes to implementation for now, but some refinement to the way
in which the new environment is constructed would be nice.
ok djm
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.53 2016/06/05 00:46:34 djm Exp $ */
a195 2
		if (strchr(safeset[i], '='))
			continue;
a283 75
/* find index of 'name' in environment envp */
static int
findenv(const char **envp, const char *name, size_t namelen)
{
	int i;

	for (i = 0 ; envp[i] != NULL; i++) {
		if (strlen(envp[i]) < namelen + 1)
			continue;
		if (strncmp(envp[i], name, namelen) == 0 &&
		    envp[i][namelen] == '=')
			return i;
	}
	return -1;
}

/* merge rule->envlist into environment list; frees oldenvp */
static char **
dosetenv(char **oldenvp, struct rule *rule)
{
	size_t n, i, nset, nold;
	char **envp, *cp, *cp2;
	int found;

	if (!(rule->options & SETENV))
		return oldenvp;

	nset = arraylen(rule->envlist);
	nold = arraylen((const char**)oldenvp);

	/* insert new variables */
	n = 0;
	envp = NULL;
	for (i = 0; i < nset; i++) {
		if ((cp = strchr(rule->envlist[i], '=')) == NULL)
			continue;
		if (cp[1] == '\0' || cp - rule->envlist[i] > INT_MAX)
			continue; /* skip variables with empty values */
		if ((envp = reallocarray(envp, n + 2, sizeof(*envp))) == NULL)
			errx(1, "reallocarray failed");
		if (cp[1] == '$') {
			/* FOO=$BAR: lookup and copy */
			if ((cp2 = getenv(cp + 2)) == NULL)
				continue; /* not found; skip */
			if (asprintf(&(envp[n++]), "%.*s=%s",
			    (int)(cp - rule->envlist[i]),
			    rule->envlist[i], cp2) == -1)
				errx(1, "asprintf failed");
			continue;
		} else {
			/* plain setenv */
			if ((envp[n++] = strdup(rule->envlist[i])) == NULL)
				errx(1, "strdup failed");
		}
	}
	/* move old variables, dropping ones already set */
	for (i = 0; i < nold; i++) {
		if ((cp = strchr(oldenvp[i], '=')) == NULL)
			errx(1, "invalid env"); /* shouldn't happen */
		found = findenv(rule->envlist, oldenvp[i], cp - oldenvp[i]);
		if (found != -1)
			free(oldenvp[i]); /* discard */
		else {
			if ((envp = reallocarray(envp, n + 2,
			    sizeof(*envp))) == NULL)
				errx(1, "reallocarray failed");
			envp[n++] = oldenvp[i]; /* move */
		}
	}
	free(oldenvp);
	if (n > 0)
		envp[n] = NULL;
	return envp;
}

a474 2

	envp = dosetenv(envp, rule);
@


1.53
log
@add a doas.conf setenv directive that allows setting environment
variables explicitly and by copying existing environment variables
of a different name. E.g.

permit nopass setenv { PS1=$SUDO_PS1 FOO=bar } keepenv :wheel

ok tedu@@ benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.52 2016/04/28 04:48:56 tedu Exp $ */
d196 2
d302 1
a302 1
/* merge rule->setenvlist into environment list; frees oldenvp */
d313 1
a313 1
	nset = arraylen(rule->setenvlist);
d320 3
a322 3
		if ((cp = strchr(rule->setenvlist[i], '=')) == NULL)
			errx(1, "invalid setenv"); /* shouldn't happen */
		if (cp[1] == '\0' || cp - rule->setenvlist[i] > INT_MAX)
d331 2
a332 2
			    (int)(cp - rule->setenvlist[i]),
			    rule->setenvlist[i], cp2) == -1)
d337 1
a337 1
			if ((envp[n++] = strdup(rule->setenvlist[i])) == NULL)
d345 1
a345 1
		found = findenv(rule->setenvlist, oldenvp[i], cp - oldenvp[i]);
@


1.52
log
@set progname to doas so users can't create bizarro fake logs
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.51 2016/02/15 19:56:11 martijn Exp $ */
d284 75
d550 2
@


1.51
log
@Do a carriage return before password prompt.

OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.50 2016/02/07 20:01:58 tedu Exp $ */
d328 2
@


1.50
log
@require a tty for the password.
sudo regression noted by miod, fix by millert
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.49 2016/01/24 13:19:21 gsoares Exp $ */
d428 1
a428 1
			    "doas (%.32s@@%.32s) password: ", myname, host);
@


1.49
log
@make sure of cleaning rbuf with explicit_bzero(3)
OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.48 2015/12/08 14:45:36 tedu Exp $ */
d431 7
a437 1
		response = readpassphrase(challenge, rbuf, sizeof(rbuf), 0);
@


1.48
log
@semarie noticed that auth failures don't set errno. just print a generic
message and leave it to the user to find the tea leaves.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.47 2015/12/08 13:39:40 sthen Exp $ */
d437 1
@


1.47
log
@Support -a <auth_style> in doas(1). Allows specifying a non-default auth
style, for example if you have "auth-doas=yubikey,passwd" in login.conf,
doas will usually want yubikey authentication, but will allow a fallback
of "doas -a passwd".

Avoids the need for sudo in a number of cases, at the expense of 5 added
lines of code (and one of those is only to avoid >80 columns).

Adapted from a diff by Renaud Allard, ok dlg@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.46 2015/12/03 08:12:15 tedu Exp $ */
d422 1
a422 1
			err(1, "auth challenge failed");
@


1.46
log
@use the more direct auth interfaces so we can provide a custom password
prompt to the user (including username and host) so it's always clear what
program is asking. request from henning with a hint from millert.
ok deraadt jung zhuk
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.45 2015/10/24 19:23:48 miod Exp $ */
d40 2
a41 1
	fprintf(stderr, "usage: doas [-ns] [-C config] [-u user] command [args]\n");
d327 1
d336 1
a336 1
	while ((ch = getopt(argc, argv, "C:nsu:")) != -1) {
d338 3
d420 1
a420 1
		if (!(as = auth_userchallenge(myname, NULL, "auth-doas",
@


1.45
log
@setusercontext() may still need "getpw" pledge rights; unbreaks doas on yp
accounts after 1.43; found the hard way by matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.44 2015/10/22 12:43:26 tedu Exp $ */
d24 1
d327 1
a327 1
	if (pledge("stdio rpath getpw proc exec id", NULL) == -1)
d409 3
d414 14
a427 1
		if (!auth_userokay(myname, NULL, "auth-doas", NULL)) {
d429 1
a429 1
			    "failed password for %s", myname);
@


1.44
log
@copying of the environment can be done later, as the user running
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.43 2015/10/22 04:57:20 deraadt Exp $ */
a422 3

	if (pledge("stdio rpath id exec", NULL) == -1)
		err(1, "pledge");
@


1.43
log
@pledge in doas.  startup pledge "stdio rpath getpw proc exec id".  4
more times after that more attributes are dropped: "proc" after bsd
auth has spawned/received result from the login_* program; "getpw"
after the final getpwent lookup, "id" after the final uid changing,
and "rpath" after constructing getcwd.  leaving only "exec", for the
ride into execve().
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.42 2015/09/19 02:47:46 tedu Exp $ */
a419 2
	envp = copyenv((const char **)envp, rule);

d445 2
@


1.42
log
@doas doesn't need any files to be passed in. closefrom STDERR+1. ok benno
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.41 2015/09/03 20:05:58 tedu Exp $ */
d326 3
d416 4
d425 4
d434 3
d441 3
@


1.41
log
@replace permfail calls with errc. the permfail calls had been retained for
clarity and/or future use, but if people send me diffs fixing it, it's
not worth fighting for. from Martin Natano
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.40 2015/09/01 13:20:53 tedu Exp $ */
d325 2
@


1.40
log
@only need to restrict exec path if the rule specifies a command.
add a hint about path restrictions to man page.
ok deraadt espie
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.39 2015/08/27 16:31:02 tedu Exp $ */
a282 7
permfail(void)
{
	errno = EPERM;
	err(1, NULL);
}

static void __dead
d399 1
a399 1
		permfail();
d408 1
a408 1
			permfail();
@


1.39
log
@add a type of "auth-doas" to the perm check to allow login.conf fiddling
originally proposed by halex
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.38 2015/08/22 16:01:05 doug Exp $ */
d436 4
a439 2
	if (setenv("PATH", safepath, 1) == -1)
		err(1, "failed to set PATH '%s'", safepath);
@


1.38
log
@Add cwd context to syslog entry.

input + ok tedu@@, ok benno@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.37 2015/08/20 18:42:11 rzalamena Exp $ */
d412 1
a412 1
		if (!auth_userokay(myname, NULL, NULL, NULL)) {
@


1.37
log
@Show program name for permission failure messages.

ok espie@@, tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.36 2015/08/13 16:27:22 espie Exp $ */
d330 2
d428 8
a435 2
	syslog(LOG_AUTHPRIV | LOG_INFO, "%s ran command as %s: %s",
	    myname, pw->pw_name, cmdline);
@


1.36
log
@and now we can unify the code. okay tedu@@
err() suggestion by Martijn van Duren
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.35 2015/08/12 15:59:53 espie Exp $ */
d283 1
a283 1
fail(void)
d285 2
a286 2
	fprintf(stderr, "Permission denied\n");
	exit(1);
d404 1
a404 1
		fail();
d413 1
a413 1
			fail();
@


1.35
log
@more explicit warnings. Okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.34 2015/08/03 15:31:05 tedu Exp $ */
d164 3
a166 7
	if (!yyfp) {
		if (checkperms)
			warn("doas is not enabled, %s", filename);
		else
			warn("could not open config file %s", filename);
		exit(1);
	}
@


1.34
log
@remove an extra getuid call, reported by Martijn van Duren
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.33 2015/07/30 17:04:33 tedu Exp $ */
d166 1
a166 1
			fprintf(stderr, "doas is not enabled.\n");
d168 1
a168 1
			warn("could not open config file");
@


1.33
log
@make gid parsing look like uid parsing. from Martijn van Duren
ack deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.32 2015/07/29 00:00:31 tedu Exp $ */
d336 1
a365 1
	uid = getuid();
@


1.32
log
@refine a comment
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.31 2015/07/28 21:36:03 deraadt Exp $ */
d83 2
a84 2
static gid_t
strtogid(const char *s)
a87 1
	gid_t gid;
d89 5
a93 3
	if ((gr = getgrnam(s)) != NULL)
		return gr->gr_gid;
	gid = strtonum(s, 0, GID_MAX, &errstr);
d96 1
a96 1
	return gid;
d106 2
a107 2
		gid_t rgid = strtogid(r->ident + 1);
		if (rgid == -1)
@


1.31
log
@wrap some exceedingly long lines
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.30 2015/07/28 19:49:04 zhuk Exp $ */
d187 1
a187 2
 * Copy to envp environment variables from oldenvp which names are
 * in safeset.
@


1.30
log
@Rename some variables and add few comments in keepenv handling code.
Makes the code more readable.

okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.29 2015/07/28 14:08:52 zhuk Exp $ */
d146 2
a147 1
		if (match(uid, groups, ngroups, target, cmd, cmdargs, rules[i]))
@


1.29
log
@Fix keepenv handling. Initially reported by Ze Loff on misc@@.

tedu@@ agrees.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.28 2015/07/27 15:38:11 espie Exp $ */
d185 4
d229 1
d232 1
a232 1
		size_t i, ii;
d237 6
a242 6
		for (ii = i = 0; i < oldlen; i++) {
			size_t j;
			for (j = 0; j < nbad; j++) {
				size_t len = strlen(badset[j]);
				if (strncmp(oldenvp[i], badset[j], len) == 0 &&
				    oldenvp[i][len] == '=') {
d246 2
a247 2
			if (j == nbad) {
				if (!(envp[ii] = strdup(oldenvp[i])))
d249 1
a249 1
				ii++;
d252 1
a252 1
		envp[ii] = NULL;
d258 1
a258 1
		size_t i;
d260 4
a263 4
		for (i = 0; i < nsafe; i++) {
			size_t j;
			for (j = 0; j < nextras; j++) {
				if (strcmp(extra[j], safeset[i]) == 0) {
d265 1
a265 1
					extra[j] = extra[nextras];
d267 1
a267 1
					j--;
@


1.28
log
@Add -n to usage. As noticed by Theo Buehler.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.27 2015/07/26 22:44:33 tedu Exp $ */
d259 2
a260 1
					extra[j--] = extra[nextras--];
d262 1
@


1.27
log
@checkconfig doesn't return anymore, noted by zhuk
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.26 2015/07/26 20:47:01 espie Exp $ */
d39 1
a39 1
	fprintf(stderr, "usage: doas [-s] [-C config] [-u user] command [args]\n");
@


1.26
log
@nflag (as in sudo, force non-interactive mode)
as discussed with ted@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.25 2015/07/26 19:49:11 zhuk Exp $ */
d285 1
a285 1
static int
@


1.25
log
@Oops, CVS mismerged changes, resulting in compilable and mostly working,
but somewhat wrong code. Well, the CVS mismerged but I just missed.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.24 2015/07/26 19:14:46 tedu Exp $ */
d325 1
d327 2
a328 1
	while ((ch = getopt(argc, argv, "C:su:")) != -1) {
d337 3
d404 2
@


1.24
log
@tweak config checking slightly
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.23 2015/07/26 19:08:17 zhuk Exp $ */
d382 1
a382 3
	(void) strlcpy(cmdline, argv[0], sizeof(cmdline)) < sizeof(cmdline);
	if (strlcpy(cmdline, argv[0], sizeof(cmdline)) >= sizeof(cmdline))
		errx(1, "command line too long");
@


1.23
log
@Stop exiting on cmdline overflow: it's used only for logging, so aborting
the whole process is stupid, and actually breaks things.

Noticed and analyzed by as well as input from nigel@@.

Okay tedu@@, espie@@ and (if I understood correctly) hall@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.22 2015/07/26 17:24:02 zhuk Exp $ */
d287 2
a288 1
    uid_t uid, gid_t *groups, int ngroups, uid_t target) {
d299 1
a299 1
		return 1;
d302 1
a302 1
		return 0;
d373 6
a378 3
	if (confpath)
		exit(!checkconfig(confpath, argc, argv, uid, groups, ngroups,
		    target));
@


1.22
log
@Implement command matching without execution. This just extends
functionality of the -C flag, so we are not introducing more garbage.

Input and okay from jmc@@ (documentation) and tedu@@ (everything).
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.21 2015/07/24 06:36:42 zhuk Exp $ */
d377 2
a378 1
	cmd = argv[0];
d383 1
a383 1
			errx(1, "command line too long");
d385 1
a385 1
			errx(1, "command line too long");
d388 1
@


1.21
log
@Further improve syntax error reporting in doas:

  - teach parser to recover after error, allowing to report many errors
    instead of the first one only;
  - fix remaining error printouts without exact position.

Some ideas were taken from diff sent by dlg@@ earlier, thanks!

okay tedu@@, dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.20 2015/07/22 16:35:03 zhuk Exp $ */
d155 1
a155 1
parseconfig(const char *filename)
d163 4
a166 1
		fprintf(stderr, "doas is not enabled.\n");
d170 8
a177 6
	if (fstat(fileno(yyfp), &sb) != 0)
		err(1, "fstat(\"%s\")", filename);
	if ((sb.st_mode & (S_IWGRP|S_IWOTH)) != 0)
		errx(1, "%s is writable by group or other", filename);
	if (sb.st_uid != 0)
		errx(1, "%s is not owned by root", filename);
d285 20
d310 1
a324 1
	uid = getuid();
d328 2
a329 3
			setresuid(uid, uid, uid);
			parseconfig(optarg);
			exit(0);
d345 4
a348 1
	if ((!sflag && !argc) || (sflag && argc))
d351 1
a351 2
	parseconfig("/etc/doas.conf");

d371 5
@


1.20
log
@Small tweaks:

 - whitespace on empty line;
 - use getuid() consistently.

okay tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.19 2015/07/22 05:37:23 deraadt Exp $ */
d176 2
@


1.19
log
@one whitespace out of place
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.18 2015/07/21 17:49:33 jmc Exp $ */
d217 1
a217 1
	
d297 1
d301 1
a301 2
			target = getuid();
			setresuid(target, target, target);
a323 1
	uid = getuid();
@


1.18
log
@options w/o args go first in SYNOPSIS, and add -C to usage();
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.17 2015/07/21 16:15:20 tedu Exp $ */
d230 1
a230 1
			    	    oldenvp[i][len] == '=') {
@


1.17
log
@oops, previous commit regarding cases should have just been for parse.y.

then a commit that says:
add a -C option to check config files without running. ok halex

then *this* commit:
use setresuid to be explicit. suggested by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.16 2015/07/21 16:12:04 tedu Exp $ */
d39 1
a39 1
	fprintf(stderr, "usage: doas [-s] [-u user] command [args]\n");
@


1.16
log
@cases should line up with switch, from Dimitris Papastamos
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.15 2015/07/21 11:04:06 zhuk Exp $ */
d300 2
a301 1
			setuid(getuid());
@


1.15
log
@Add argument matching support to doas.

Input and generic support from many. Final okay from tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.14 2015/07/20 01:04:37 tedu Exp $ */
d297 1
a297 3
	parseconfig("/etc/doas.conf");

	while ((ch = getopt(argc, argv, "su:")) != -1) {
d299 4
d320 2
@


1.14
log
@sf points out sudo doesn't allow SHELL in children
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.13 2015/07/20 01:00:48 tedu Exp $ */
d100 1
a100 1
    struct rule *r)
d120 15
a134 2
	if (r->cmd && strcmp(r->cmd, cmd) != 0)
		return 0;
d140 1
a140 1
    uid_t target, const char *cmd)
d146 1
a146 1
		if (match(uid, groups, ngroups, target, cmd, rules[i]))
d350 2
a351 1
	if (!permit(uid, groups, ngroups, &rule, target, cmd)) {
@


1.13
log
@check that badlisted env has = after the name
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.12 2015/07/20 00:57:53 tedu Exp $ */
d191 1
a191 1
		"DISPLAY", "HOME", "LOGNAME", "MAIL", "SHELL",
@


1.12
log
@rescope and rename some variables to reduce pressure on the alphabet
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.11 2015/07/20 00:54:01 tedu Exp $ */
d216 2
a217 1
				if (strncmp(oldenvp[i], badset[j], len) == 0) {
@


1.11
log
@introduce a minimal badset ($ENV) for environment stripping so that
root shells read the right .kshrc
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.10 2015/07/19 01:19:22 tedu Exp $ */
a201 1
	int i, ii, j, jj;
d207 3
a209 2
		j = arraylen(oldenvp);
		envp = reallocarray(NULL, j + 1, sizeof(char *));
d212 5
a216 4
		for (ii = i = 0; i < j; i++) {
			for (jj = 0; jj < nbad; jj++) {
				size_t len = strlen(badset[jj]);
				if (strncmp(oldenvp[i], badset[jj], len) == 0) {
d220 1
a220 1
			if (jj == nbad) {
d232 1
d235 1
@


1.10
log
@sudo emulation: if execvpe fails with ENOENT, print "command not found"
requested by krw
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.9 2015/07/18 18:44:26 tedu Exp $ */
d193 5
a197 1
		NULL,
d202 2
a203 2
	int i, j;
	int nsafe;
d206 1
d212 12
a223 3
		for (i = 0; i < j; i++) {
			if (!(envp[i] = strdup(oldenvp[i])))
				err(1, "strdup");
d225 1
a225 1
		envp[i] = NULL;
@


1.9
log
@rearrange variable decls a little
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.8 2015/07/18 06:33:23 nicm Exp $ */
d32 1
d347 2
@


1.8
log
@Add doas -s as a shorthand for doas $SHELL. ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.7 2015/07/18 00:19:38 doug Exp $ */
d46 1
d169 1
a193 2
	int nsafe;
	int nextras = 0;
d198 2
d249 5
d256 4
a259 1
	uid_t uid, target = 0;
a261 3
	struct passwd *pw;
	struct rule *rule;
	const char *cmd;
a262 2
	const char *safepath = "/bin:/sbin:/usr/bin:/usr/sbin:"
	    "/usr/local/bin:/usr/local/sbin";
a263 2
	char *shargv[] = { NULL, NULL };
	char *sh;
@


1.7
log
@Add more error checking and use named constants when useful.

ok sthen@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.6 2015/07/16 23:22:08 nicm Exp $ */
d38 1
a38 1
	fprintf(stderr, "usage: doas [-u user] command [args]\n");
d258 3
d264 1
a264 1
	while ((ch = getopt(argc, argv, "u:")) != -1) {
d270 3
d281 1
a281 1
	if (!argc)
a283 10
	cmd = argv[0];
	if (strlcpy(cmdline, argv[0], sizeof(cmdline)) >= sizeof(cmdline))
		errx(1, "command line too long");
	for (i = 1; i < argc; i++) {
		if (strlcat(cmdline, " ", sizeof(cmdline)) >= sizeof(cmdline))
			errx(1, "command line too long");
		if (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))
			errx(1, "command line too long");
	}

d294 20
@


1.6
log
@Fail if /etc/doas.conf is g+w or o+w or is not owned by root. ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.5 2015/07/16 22:11:01 nicm Exp $ */
d247 2
a248 2
	char cmdline[1024];
	char myname[32];
d279 2
a280 1
	strlcpy(cmdline, argv[0], sizeof(cmdline));
d282 4
a285 2
		strlcat(cmdline, " ", sizeof(cmdline));
		strlcat(cmdline, argv[i], sizeof(cmdline));
d292 2
a293 1
	strlcpy(myname, pw->pw_name, sizeof(myname));
d324 2
a325 1
	setenv("PATH", safepath, 1);
@


1.5
log
@Missing reallocarray check in doas.c (ok tedu) and a calloc in parse.y
as well.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.4 2015/07/16 21:57:54 deraadt Exp $ */
d17 1
d19 1
d144 1
d151 8
@


1.4
log
@wrap long lines
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.3 2015/07/16 21:55:03 tedu Exp $ */
d191 2
@


1.3
log
@doas grows up. no insults.
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.2 2015/07/16 21:00:59 tedu Exp $ */
d153 2
a154 1
copyenvhelper(const char **oldenvp, const char **safeset, int nsafe, char **envp, int ei)
d243 2
a244 1
	const char *safepath = "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin";
d283 2
a284 1
		syslog(LOG_AUTHPRIV | LOG_NOTICE, "failed command for %s: %s", myname, cmdline);
d290 2
a291 1
			syslog(LOG_AUTHPRIV | LOG_NOTICE, "failed password for %s", myname);
d305 2
a306 1
	syslog(LOG_AUTHPRIV | LOG_INFO, "%s ran command as %s: %s", myname, pw->pw_name, cmdline);
@


1.2
log
@combine fprintfs and use a constant format string. hint from reyk
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.1 2015/07/16 20:44:21 tedu Exp $ */
d226 1
a226 16
	const char *msgs[] = {
		"No lollygagging!",
		"Better luck next time.",
		"PEBKAC detected.",
		"That's what happens when you're lazy.",
		"It is clear that this has not been thought through.",
		"That's the most ridiculous thing I've heard in the last two or three minutes!",
		"No sane people allowed here.  Go home.",
		"I would explain, but I am too drunk.",
		"You're not allowed to have an opinion.",
		"Complaint forms are handled in another department.",
	};
	const char *m;

	m = msgs[arc4random_uniform(sizeof(msgs) / sizeof(msgs[0]))];
	fprintf(stderr, "%s\n", m);
@


1.1
log
@import doas. still subject to changes, large and small.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d241 1
a241 2
	fprintf(stderr, m);
	fprintf(stderr, "\n");
@

