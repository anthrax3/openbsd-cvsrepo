head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.2
	OPENBSD_6_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.5
date	2016.09.15.00.58.23;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	jUUEan3Kanf6WvvC;

1.4
date	2016.07.10.03.24.31;	author tedu;	state Exp;
branches;
next	1.3;
commitid	uJAdIZkI2579KMUO;

1.3
date	2016.06.27.15.41.17;	author tedu;	state Exp;
branches;
next	1.2;
commitid	8jC1nXqjGNHahD9H;

1.2
date	2016.06.19.19.29.43;	author martijn;	state Exp;
branches;
next	1.1;
commitid	vJP1y2NiYr0CmjHu;

1.1
date	2016.06.16.17.40.30;	author tedu;	state Exp;
branches;
next	;
commitid	kwCFU8ML8KNeONv7;


desc
@@


1.5
log
@use static in the right places to seperate modules better
ok tedu
@
text
@/* $OpenBSD: env.c,v 1.4 2016/07/10 03:24:31 tedu Exp $ */
/*
 * Copyright (c) 2016 Ted Unangst <tedu@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/tree.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <unistd.h>
#include <errno.h>

#include "doas.h"

struct envnode {
	RB_ENTRY(envnode) node;
	const char *key;
	const char *value;
};

struct env {
	RB_HEAD(envtree, envnode) root;
	u_int count;
};

static int
envcmp(struct envnode *a, struct envnode *b)
{
	return strcmp(a->key, b->key);
}
RB_GENERATE_STATIC(envtree, envnode, node, envcmp)

static struct envnode *
createnode(const char *key, const char *value)
{
	struct envnode *node;

	node = malloc(sizeof(*node));
	if (!node)
		err(1, NULL);
	node->key = strdup(key);
	node->value = strdup(value);
	if (!node->key || !node->value)
		err(1, NULL);
	return node;
}

static void
freenode(struct envnode *node)
{
	free((char *)node->key);
	free((char *)node->value);
	free(node);
}

static struct env *
createenv(struct rule *rule)
{
	struct env *env;
	u_int i;

	env = malloc(sizeof(*env));
	if (!env)
		err(1, NULL);
	RB_INIT(&env->root);
	env->count = 0;

	if (rule->options & KEEPENV) {
		extern const char **environ;

		for (i = 0; environ[i] != NULL; i++) {
			struct envnode *node;
			const char *e, *eq;
			size_t len;
			char name[1024];

			e = environ[i];

			/* ignore invalid or overlong names */
			if ((eq = strchr(e, '=')) == NULL || eq == e)
				continue;
			len = eq - e;
			if (len > sizeof(name) - 1)
				continue;
			memcpy(name, e, len);
			name[len] = '\0';

			node = createnode(name, eq + 1);
			if (RB_INSERT(envtree, &env->root, node)) {
				/* ignore any later duplicates */
				freenode(node);
			} else {
				env->count++;
			}
		}
	}

	return env;
}

static char **
flattenenv(struct env *env)
{
	char **envp;
	struct envnode *node;
	u_int i;

	envp = reallocarray(NULL, env->count + 1, sizeof(char *));
	if (!envp)
		err(1, NULL);
	i = 0;
	RB_FOREACH(node, envtree, &env->root) {
		if (asprintf(&envp[i], "%s=%s", node->key, node->value) == -1)
			err(1, NULL);
		i++;
	}
	envp[i] = NULL;
	return envp;
}

static void
fillenv(struct env *env, const char **envlist)
{
	struct envnode *node, key;
	const char *e, *eq;
	const char *val;
	char name[1024];
	u_int i;
	size_t len;

	for (i = 0; envlist[i]; i++) {
		e = envlist[i];

		/* parse out env name */
		if ((eq = strchr(e, '=')) == NULL)
			len = strlen(e);
		else
			len = eq - e;
		if (len > sizeof(name) - 1)
			continue;
		memcpy(name, e, len);
		name[len] = '\0';

		/* delete previous copies */
		key.key = name;
		if (*name == '-')
			key.key = name + 1;
		if ((node = RB_FIND(envtree, &env->root, &key))) {
			RB_REMOVE(envtree, &env->root, node);
			freenode(node);
			env->count--;
		}
		if (*name == '-')
			continue;

		/* assign value or inherit from environ */
		if (eq) {
			val = eq + 1;
			if (*val == '$')
				val = getenv(val + 1);
		} else {
			val = getenv(name);
		}
		/* at last, we have something to insert */
		if (val) {
			node = createnode(name, val);
			RB_INSERT(envtree, &env->root, node);
			env->count++;
		}
	}
}

char **
prepenv(struct rule *rule)
{
	static const char *safeset[] = {
		"DISPLAY", "HOME", "LOGNAME", "MAIL",
		"PATH", "TERM", "USER", "USERNAME",
		NULL
	};
	struct env *env;

	env = createenv(rule);

	/* if we started with blank, fill some defaults then apply rules */
	if (!(rule->options & KEEPENV))
		fillenv(env, safeset);
	if (rule->envlist)
		fillenv(env, rule->envlist);

	return flattenenv(env);
}
@


1.4
log
@rename variable for consistency
@
text
@d1 1
a1 1
/* $OpenBSD: env.c,v 1.3 2016/06/27 15:41:17 tedu Exp $ */
d197 1
a197 1
	
@


1.3
log
@revise environment handling.
Add a setenv keyword for manipulating the environment. keepenv now means
only retain everything. (for one release, the old use of keepenv will still
work.)
Allow setting variables to new or existing values, and also removing vars
when keepenv is used.
ok djm martijn tb
@
text
@d1 1
a1 1
/* $OpenBSD: env.c,v 1.2 2016/06/19 19:29:43 martijn Exp $ */
d90 1
a90 1
			char keybuf[1024];
d98 1
a98 1
			if (len > sizeof(keybuf) - 1)
d100 2
a101 2
			memcpy(keybuf, e, len);
			keybuf[len] = '\0';
d103 1
a103 1
			node = createnode(keybuf, eq + 1);
@


1.2
log
@Move the RB_ code from doas.h to env.c, and limit the environment interface to a
simple prepenv function.

OK tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: env.c,v 1.1 2016/06/16 17:40:30 tedu Exp $ */
d41 1
a41 1
int
d48 4
a51 3
struct env *createenv(char **);
struct env *filterenv(struct env *, struct rule *);
char **flattenenv(struct env *);
d53 20
a72 2
struct env *
createenv(char **envp)
d83 2
a84 3
	for (i = 0; envp[i] != NULL; i++) {
		struct envnode *node;
		const char *e, *eq;
d86 24
a109 18
		e = envp[i];

		if ((eq = strchr(e, '=')) == NULL || eq == e)
			continue;
		node = malloc(sizeof(*node));
		if (!node)
			err(1, NULL);
		node->key = strndup(envp[i], eq - e);
		node->value = strdup(eq + 1);
		if (!node->key || !node->value)
			err(1, NULL);
		if (RB_FIND(envtree, &env->root, node)) {
			free((char *)node->key);
			free((char *)node->value);
			free(node);
		} else {
			RB_INSERT(envtree, &env->root, node);
			env->count++;
d112 1
d116 1
a116 1
char **
d137 1
a137 1
copyenv(struct env *orig, struct env *copy, const char **envlist)
d140 3
d144 1
d147 37
a183 6
		key.key = envlist[i];
		if ((node = RB_FIND(envtree, &orig->root, &key))) {
			RB_REMOVE(envtree, &orig->root, node);
			orig->count--;
			RB_INSERT(envtree, &copy->root, node);
			copy->count++;
d188 2
a189 2
struct env *
filterenv(struct env *orig, struct rule *rule)
d191 1
a191 1
	const char *safeset[] = {
d196 3
a198 27
	const char *badset[] = {
		"ENV",
		NULL
	};
	struct env *copy;
	struct envnode *node, key;
	u_int i;

	if ((rule->options & KEEPENV) && !rule->envlist) {
		for (i = 0; badset[i]; i++) {
			key.key = badset[i];
			if ((node = RB_FIND(envtree, &orig->root, &key))) {
				RB_REMOVE(envtree, &orig->root, node);
				free((char *)node->key);
				free((char *)node->value);
				free(node);
				orig->count--;
			}
		}
		return orig;
	}

	copy = malloc(sizeof(*copy));
	if (!copy)
		err(1, NULL);
	RB_INIT(&copy->root);
	copy->count = 0;
d200 3
d204 1
a204 5
		copyenv(orig, copy, rule->envlist);
	copyenv(orig, copy, safeset);

	return copy;
}
a205 8
char **
prepenv(struct rule *rule)
{
	extern char **environ;
	struct env *env;
	
	env = createenv(environ);
	env = filterenv(env, rule);
@


1.1
log
@the environment handling code was showing its age. just because environ
is a char** array doesn't mean we must exclusively operate on such.
convert to a red-black tree, manipulate as desired, then flatten to array.
potentially overkill for the current operations, but reading the tea leaves
i see that more manipulations are desired.
ok tb
(and some thought provoking disagreement from martijn)
@
text
@d1 1
a1 1
/* $OpenBSD: doas.c,v 1.55 2016/06/07 16:49:23 tedu Exp $ */
d19 1
d30 11
d46 5
a50 1
RB_GENERATE(envtree, envnode, node, envcmp)
d169 11
@

