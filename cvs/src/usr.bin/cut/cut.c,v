head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.6
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.8
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.15.0.16
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2015.12.02.00.56.46;	author schwarze;	state Exp;
branches;
next	1.22;
commitid	KBaCUoUP1gj9htiq;

1.22
date	2015.11.03.04.57.20;	author mmcc;	state Exp;
branches;
next	1.21;
commitid	wDCzisjFNVst9hzK;

1.21
date	2015.10.09.01.37.07;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	sbrB3Q5CNxcwZpfU;

1.20
date	2015.10.05.13.27.45;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	e584WVLYbO2Ux9ue;

1.19
date	2015.08.18.17.10.48;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	MYkMCiUyvbFHTWKE;

1.18
date	2014.02.02.11.44.01;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2014.02.01.23.34.49;	author sobrado;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.23.17.30.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.23.00.32.12;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.27.08.02.13;	author sobrado;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.15.22.38.24;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.10.22.20.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.02.56.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.21.27.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.19.19.02.13;	author mpech;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.04.23.52.19;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	98.11.28.03.41.46;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	97.11.05.00.18.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.09.12.04.12.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.01.15.23.42.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.05.32.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.45.05;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.45.05;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.23
log
@UTF-8 support: Implement -c and -n
and let -d accept a multibyte delimiter character.
While here, simplify the code by switching from fgetln(3) to getline(3)
and from hand-crafted string parsing to strstr(3) and strchr(3).
OK tedu@@ czarkoff@@ zhuk@@.
@
text
@/*	$OpenBSD: cut.c,v 1.22 2015/11/03 04:57:20 mmcc Exp $	*/
/*	$NetBSD: cut.c,v 1.9 1995/09/02 05:59:23 jtc Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Adam S. Moskowitz of Menlo Consulting and Marciano Pitargue.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char	dchar[5];
int	dlen;

int	bflag;
int	cflag;
int	dflag;
int	fflag;
int	nflag;
int	sflag;

void	b_cut(FILE *, char *);
void	c_cut(FILE *, char *);
void	f_cut(FILE *, char *);
void	get_list(char *);
void	usage(void);

int
main(int argc, char *argv[])
{
	FILE *fp;
	void (*fcn)(FILE *, char *);
	int ch, rval;

	setlocale(LC_CTYPE, "");

	if (pledge("stdio rpath", NULL) == -1)
		err(1, "pledge");

	dchar[0] = '\t';		/* default delimiter */
	dchar[1] = '\0';
	dlen = 1;

	while ((ch = getopt(argc, argv, "b:c:d:f:sn")) != -1)
		switch(ch) {
		case 'b':
			get_list(optarg);
			bflag = 1;
			break;
		case 'c':
			get_list(optarg);
			cflag = 1;
			break;
		case 'd':
			if ((dlen = mblen(optarg, MB_CUR_MAX)) == -1)
				usage();
			assert(dlen < sizeof(dchar));
			(void)memcpy(dchar, optarg, dlen);
			dchar[dlen] = '\0';
			dflag = 1;
			break;
		case 'f':
			get_list(optarg);
			fflag = 1;
			break;
		case 'n':
			nflag = 1;
			break;
		case 's':
			sflag = 1;
			break;
		case '?':
		default:
			usage();
		}
	argc -= optind;
	argv += optind;

	if (bflag + cflag + fflag != 1 ||
	    (nflag && !bflag) ||
	    ((dflag || sflag) && !fflag))
		usage();

	if (MB_CUR_MAX == 1) {
		nflag = 0;
		if (cflag) {
			bflag = 1;
			cflag = 0;
		}
	}

	fcn = fflag ? f_cut : (cflag || nflag) ? c_cut : b_cut;

	rval = 0;
	if (*argv)
		for (; *argv; ++argv) {
			if (strcmp(*argv, "-") == 0)
				fcn(stdin, "stdin");
			else {
				if ((fp = fopen(*argv, "r"))) {
					fcn(fp, *argv);
					(void)fclose(fp);
				} else {
					rval = 1;
					warn("%s", *argv);
				}
			}
		}
	else {
		if (pledge("stdio rpath", NULL) == -1)
			err(1, "pledge");

		fcn(stdin, "stdin");
	}
	exit(rval);
}

int autostart, autostop, maxval;

char positions[_POSIX2_LINE_MAX + 1];

void
get_list(char *list)
{
	int setautostart, start, stop;
	char *pos;
	char *p;

	/*
	 * set a byte in the positions array to indicate if a field or
	 * column is to be selected; use +1, it's 1-based, not 0-based.
	 * This parser is less restrictive than the Draft 9 POSIX spec.
	 * POSIX doesn't allow lists that aren't in increasing order or
	 * overlapping lists.  We also handle "-3-5" although there's no
	 * real reason too.
	 */
	while ((p = strsep(&list, ", \t"))) {
		setautostart = start = stop = 0;
		if (*p == '-') {
			++p;
			setautostart = 1;
		}
		if (isdigit((unsigned char)*p)) {
			start = stop = strtol(p, &p, 10);
			if (setautostart && start > autostart)
				autostart = start;
		}
		if (*p == '-') {
			if (isdigit((unsigned char)p[1]))
				stop = strtol(p + 1, &p, 10);
			if (*p == '-') {
				++p;
				if (!autostop || autostop > stop)
					autostop = stop;
			}
		}
		if (*p)
			errx(1, "[-bcf] list: illegal list value");
		if (!stop || !start)
			errx(1, "[-bcf] list: values may not include zero");
		if (stop > _POSIX2_LINE_MAX)
			errx(1, "[-bcf] list: %d too large (max %d)",
			    stop, _POSIX2_LINE_MAX);
		if (maxval < stop)
			maxval = stop;
		for (pos = positions + start; start++ <= stop; *pos++ = 1)
			;
	}

	/* overlapping ranges */
	if (autostop && maxval > autostop)
		maxval = autostop;

	/* set autostart */
	if (autostart)
		memset(positions + 1, '1', autostart);
}

/* ARGSUSED */
void
b_cut(FILE *fp, char *fname)
{
	int ch, col;
	char *pos;

	for (;;) {
		pos = positions + 1;
		for (col = maxval; col; --col) {
			if ((ch = getc(fp)) == EOF)
				return;
			if (ch == '\n')
				break;
			if (*pos++)
				(void)putchar(ch);
		}
		if (ch != '\n') {
			if (autostop)
				while ((ch = getc(fp)) != EOF && ch != '\n')
					(void)putchar(ch);
			else
				while ((ch = getc(fp)) != EOF && ch != '\n')
					;
		}
		(void)putchar('\n');
	}
}

void
c_cut(FILE *fp, char *fname)
{
	static char	*line = NULL;
	static size_t	 linesz = 0;
	ssize_t		 linelen;
	char		*cp, *pos, *maxpos;
	int		 len;

	while ((linelen = getline(&line, &linesz, fp)) != -1) {
		if (line[linelen - 1] == '\n')
			line[linelen - 1] = '\0';

		cp = line;
		pos = positions + 1;
		maxpos = pos + maxval;
		while(pos < maxpos && *cp != '\0') {
			len = mblen(cp, MB_CUR_MAX);
			if (len == -1)
				len = 1;
			pos += nflag ? len : 1;
			if (pos[-1] == '\0')
				cp += len;
			else
				while (len--)
					putchar(*cp++);
		}
		if (autostop)
			puts(cp);
		else
			putchar('\n');
	}
}

void
f_cut(FILE *fp, char *fname)
{
	static char	*line = NULL;
	static size_t	 linesz = 0;
	ssize_t		 linelen;
	char		*sp, *ep, *pos, *maxpos;
	int		 output;

	while ((linelen = getline(&line, &linesz, fp)) != -1) {
		if (line[linelen - 1] == '\n')
			line[linelen - 1] = '\0';

		if ((ep = strstr(line, dchar)) == NULL) {
			if (!sflag)
				puts(line);
			continue;
		}

		pos = positions + 1;
		maxpos = pos + maxval;
		output = 0;
		sp = line;
		for (;;) {
			if (*pos++) {
				if (output)
					fputs(dchar, stdout);
				while (sp < ep)
					putchar(*sp++);
				output = 1;
			} else
				sp = ep;
			if (*sp == '\0' || pos == maxpos)
				break;
			sp += dlen;
			if ((ep = strstr(sp, dchar)) == NULL)
				ep = strchr(sp, '\0');
		}
		if (autostop)
			puts(sp);
		else
			putchar('\n');
	}
}

void
usage(void)
{
	(void)fprintf(stderr,
	    "usage: cut -b list [-n] [file ...]\n"
	    "       cut -c list [file ...]\n"
	    "       cut -f list [-s] [-d delim] [file ...]\n");
	exit(1);
}
@


1.22
log
@Blank line after pledge().
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.21 2015/10/09 01:37:07 deraadt Exp $	*/
d36 1
d47 4
a51 1
char	dchar;
d54 1
d57 1
d70 1
a70 1
	setlocale (LC_ALL, "");
d75 3
a77 1
	dchar = '\t';			/* default delimiter is \t */
a78 2
	/* Since we don't support multi-byte characters, the -c and -b 
	   options are equivalent, and the -n option is meaningless. */
d82 3
a85 1
			fcn = c_cut;
d90 5
a94 1
			dchar = *optarg;
a98 1
			fcn = f_cut;
d101 3
a106 2
		case 'n':
			break;
d114 3
a116 4
	if (fflag) {
		if (cflag)
			usage();
	} else if (!cflag || dflag || sflag)
d119 10
d216 1
a216 1
c_cut(FILE *fp, char *fname)
d244 1
a244 1
f_cut(FILE *fp, char *fname)
d246 9
a254 5
	int ch, field, isdelim;
	char *pos, *p, sep;
	int output;
	size_t len;
	char *lbuf, *tbuf;
d256 13
a268 20
	for (sep = dchar, tbuf = NULL; (lbuf = fgetln(fp, &len));) {
		output = 0;
		if (lbuf[len - 1] != '\n') {
			/* no newline at the end of the last line so add one */
			if ((tbuf = malloc(len + 1)) == NULL)
				err(1, NULL);
			memcpy(tbuf, lbuf, len);
			tbuf[len] = '\n';
			lbuf = tbuf;
		}
		for (isdelim = 0, p = lbuf;; ++p) {
			ch = *p;
			/* this should work if newline is delimiter */
			if (ch == sep)
				isdelim = 1;
			if (ch == '\n') {
				if (!isdelim && !sflag)
					(void)fwrite(lbuf, len, 1, stdout);
				break;
			}
d270 23
a292 1
		if (!isdelim)
d294 1
d297 10
a306 6
		for (field = maxval, p = lbuf; field; --field, ++pos) {
			if (*pos) {
				if (output++)
					(void)putchar(sep);
				while ((ch = *p++) != '\n' && ch != sep)
					(void)putchar(ch);
d308 2
a309 3
				while ((ch = *p++) != '\n' && ch != sep)
					;
			if (ch == '\n')
d311 8
a318 12
		}
		if (ch != '\n') {
			if (autostop) {
				if (output)
					(void)putchar(sep);
				for (; (ch = *p) != '\n'; ++p)
					(void)putchar(ch);
			} else
				for (; (ch = *p) != '\n'; ++p)
					;
		}
		(void)putchar('\n');
a319 2
	if (tbuf)
		free(tbuf);
@


1.21
log
@Change all tame callers to namechange to pledge(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.20 2015/10/05 13:27:45 deraadt Exp $	*/
d126 1
@


1.20
log
@This can use tame "stdio rpath" from the top.  If we are only working on
stdin, an additional tame "stdio" is easy.
same diff from sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.19 2015/08/18 17:10:48 deraadt Exp $	*/
d66 2
a67 2
	if (tame("stdio rpath", NULL) == -1)
		err(1, "tame");
d124 2
a125 2
		if (tame("stdio rpath", NULL) == -1)
			err(1, "tame");
@


1.19
log
@do not cast malloc() return if stdlib.h is included
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.18 2014/02/02 11:44:01 sobrado Exp $	*/
d66 3
d123 3
a125 1
	else
d127 1
@


1.18
log
@style nit-picking on previous commit: keep apart declaration from
initialization; use a variable name consistent with the rest of our tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.17 2014/02/01 23:34:49 sobrado Exp $	*/
d228 1
a228 1
			if ((tbuf = (char *)malloc(len + 1)) == NULL)
@


1.17
log
@improve POSIX compliance by continuing to process the remaining file
operands after not finding an input file.

from the IEEE Std 1003.1-2008 (``POSIX.1'') rationale:

    "Unlike other utilities, some historical implementations of cut
     exit after not finding an input file, rather than continuing to
     process the remaining file operands.  This behavior is prohibited
     by this volume of POSIX.1-2008, where only the exit status is
     affected by this problem."

joint work with jmc@@, who identified the compliance issue, and millert@@

ok millert@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.16 2013/11/23 17:30:29 deraadt Exp $	*/
d62 1
a62 1
	int ch, eval = 0;
d105 1
d115 1
a115 1
					eval = 1;
d122 1
a122 1
	exit(eval);
@


1.16
log
@obvious unsigned casts for ctype
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.15 2010/01/23 00:32:12 schwarze Exp $	*/
d62 1
a62 1
	int ch;
d107 11
a117 4
			if (!(fp = fopen(*argv, "r")))
				err(1, "%s", *argv);
			fcn(fp, *argv);
			(void)fclose(fp);
d121 1
a121 1
	exit(0);
@


1.15
log
@It's wrong to complain about illegal -c arguments when finding
illegal -b arguments, so fix the error messages;
patch from Laurent Ghigonis <ooookiwi at gmail dot com> on tech@@.

While here, improve the manual, too:
 * arguments need not be in increasing order
 * CAVEAT: -b and -c do the same right now

feedback and ok  jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.14 2009/10/27 23:59:37 deraadt Exp $	*/
d142 1
a142 1
		if (isdigit(*p)) {
d148 1
a148 1
			if (isdigit(p[1]))
@


1.14
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.13 2008/06/27 08:02:13 sobrado Exp $	*/
d157 1
a157 1
			errx(1, "[-cf] list: illegal list value");
d159 1
a159 1
			errx(1, "[-cf] list: values may not include zero");
d161 1
a161 1
			errx(1, "[-cf] list: %d too large (max %d)",
@


1.13
log
@sort flags; align usage output.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.12 2007/03/15 22:38:24 jmc Exp $	*/
a34 13

#ifndef lint
static char copyright[] =
"@@(#) Copyright (c) 1989, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static char sccsid[] = "@@(#)cut.c	8.3 (Berkeley) 5/4/95";
#endif
static char rcsid[] = "$OpenBSD: cut.c,v 1.12 2007/03/15 22:38:24 jmc Exp $";
#endif /* not lint */
@


1.12
log
@simplify synopsis/usage() and sort options;
from Igor Sobrado
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.11 2003/06/10 22:20:45 deraadt Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.11 2003/06/10 22:20:45 deraadt Exp $";
d286 3
a288 3
		"usage:  cut -b list [-n] [file ...]\n"
		"\tcut -c list [file ...]\n"
		"\tcut -f list [-d delim] [-s] [file ...]\n");
@


1.11
log
@mostly ansi cleanup; pval ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.10 2003/06/03 02:56:07 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.10 2003/06/03 02:56:07 millert Exp $";
d286 3
a288 3
		"usage:\tcut -c list [file1 ...]\n"
		"\tcut -f list [-s] [-d delim] [file ...]\n"
		"\tcut -b list [-n] [file ...]\n");
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.9 2002/02/16 21:27:45 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.9 2002/02/16 21:27:45 millert Exp $";
d71 1
a71 3
main(argc, argv)
	int argc;
	char *argv[];
d135 1
a135 2
get_list(list)
	char *list;
d193 1
a193 3
c_cut(fp, fname)
	FILE *fp;
	char *fname;
d221 1
a221 3
f_cut(fp, fname)
	FILE *fp;
	char *fname;
d283 1
a283 1
usage()
@


1.9
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.8 2001/11/19 19:02:13 mpech Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.8 2001/11/19 19:02:13 mpech Exp $";
@


1.8
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.7 2000/06/04 23:52:19 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.7 2000/06/04 23:52:19 aaron Exp $";
d69 4
a72 4
void	c_cut __P((FILE *, char *));
void	f_cut __P((FILE *, char *));
void	get_list __P((char *));
void	usage __P((void));
d80 1
a80 1
	void (*fcn) __P((FILE *, char *));
@


1.7
log
@Handle the case where the last line of input does not contain a newline; issue
reported by marc@@snafu.org. The main thing here is we use fgetln() instead of
fgets(), also giving us the advantage of being able to handle lines of
unlimited length. Some -Wall and other fixes from millert@@ as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.6 1998/11/28 03:41:46 aaron Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.6 1998/11/28 03:41:46 aaron Exp $";
d144 2
a145 2
	register int setautostart, start, stop;
	register char *pos;
d204 2
a205 2
	register int ch, col;
	register char *pos;
d234 2
a235 2
	register int ch, field, isdelim;
	register char *pos, *p, sep;
@


1.6
log
@use strsep() instead of strtok(), in particular to avoid an infinite loop
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.5 1997/11/05 00:18:44 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.5 1997/11/05 00:18:44 deraadt Exp $";
d156 1
a156 1
	for (; p = strsep(&list, ", \t");) {
d185 2
a186 1
		for (pos = positions + start; start++ <= stop; *pos++ = 1);
d217 1
a217 1
		if (ch != '\n')
d222 3
a224 1
				while ((ch = getc(fp)) != EOF && ch != '\n');
d237 2
a238 1
	char lbuf[_POSIX2_LINE_MAX + 1];
d240 1
a240 1
	for (sep = dchar; fgets(lbuf, sizeof(lbuf), fp);) {
d242 8
d251 1
a251 2
			if (!(ch = *p))
				errx(1, "%s: line too long.", fname);
d257 1
a257 1
					(void)printf("%s", lbuf);
d272 2
a273 1
				while ((ch = *p++) != '\n' && ch != sep);
d277 1
a277 1
		if (ch != '\n')
d284 3
a286 1
				for (; (ch = *p) != '\n'; ++p);
d289 2
@


1.5
log
@sync usage to man page
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.4 1997/09/12 04:12:51 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.4 1997/09/12 04:12:51 millert Exp $";
d156 1
a156 1
	for (; p = strtok(list, ", \t"); list = NULL) {
@


1.4
log
@Kill extra newline in err()/warn().
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.3 1997/01/15 23:42:24 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.3 1997/01/15 23:42:24 millert Exp $";
d281 3
a283 1
"usage:\tcut -c list [file1 ...]\n\tcut -f list [-s] [-d delim] [file ...]\n");
@


1.3
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.2 1996/06/26 05:32:34 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.2 1996/06/26 05:32:34 deraadt Exp $";
d177 1
a177 1
			errx(1, "[-cf] list: illegal list value\n");
d179 1
a179 1
			errx(1, "[-cf] list: values may not include zero\n");
d181 1
a181 1
			errx(1, "[-cf] list: %d too large (max %d)\n",
d240 1
a240 1
				errx(1, "%s: line too long.\n", fname);
@


1.2
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: cut.c,v 1.9 1995/09/02 05:59:23 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: cut.c,v 1.9 1995/09/02 05:59:23 jtc Exp $";
d89 1
a89 1
	while ((ch = getopt(argc, argv, "b:c:d:f:sn")) != EOF)
@


1.1
log
@Initial revision
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: cut.c,v 1.9 1995/09/02 05:59:23 jtc Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
