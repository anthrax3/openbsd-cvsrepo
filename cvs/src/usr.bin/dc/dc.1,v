head	1.30;
access;
symbols
	OPENBSD_6_2:1.30.0.6
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.28.0.4
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.14
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.6
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.10
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.8
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.4
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.12
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.8
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.6
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18;
locks; strict;
comment	@.\" @;


1.30
date	2017.02.23.06.40.17;	author otto;	state Exp;
branches;
next	1.29;
commitid	ZyO2h2TEPTzcwEtk;

1.29
date	2016.12.10.21.13.25;	author schwarze;	state Exp;
branches;
next	1.28;
commitid	4coMobrzJtYgMso4;

1.28
date	2015.10.03.17.15.26;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	0cOo8MQvYD2L3i6o;

1.27
date	2012.08.19.12.07.21;	author jmc;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.18.14.48.49;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.19.21.30.04;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2010.01.02.19.48.56;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.31.19.20.09;	author jmc;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.24.08.56.42;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.07.16.40.09;	author kjell;	state Exp;
branches;
next	1.20;

1.20
date	2005.09.30.20.34.25;	author jaredy;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.18.07.49.00;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.01.09.13.55;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.17.11.12.35;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.14.20.25.16;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.06.19.48.55;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.04.08.10.06;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.23.09.01.42;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.12.16.25;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.20.05.02.58;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.19.18.39.13;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.18.21.00.17;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.18.19.47.10;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.11.18.31.19;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.01.08.19.29;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.30.18.33.35;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.22.14.50.32;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.22.14.49.16;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.22.04.59.00;	author jmc;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.19.17.59.47;	author otto;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Introduce e command, equivalent to p, but writes to stderr
@
text
@.\"	$OpenBSD: dc.1,v 1.29 2016/12/10 21:13:25 schwarze Exp $
.\"
.\" Copyright (C) Caldera International Inc.  2001-2002.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code and documentation must retain the above
.\"    copyright notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed or owned by Caldera
.\"	International, Inc.
.\" 4. Neither the name of Caldera International, Inc. nor the names of other
.\"    contributors may be used to endorse or promote products derived from
.\"    this software without specific prior written permission.
.\"
.\" USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
.\" INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE LIABLE FOR ANY DIRECT,
.\" INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.\"	@@(#)dc.1	8.1 (Berkeley) 6/6/93
.\"
.Dd $Mdocdate: December 10 2016 $
.Dt DC 1
.Os
.Sh NAME
.Nm dc
.Nd desk calculator
.Sh SYNOPSIS
.Nm
.Op Fl x
.Op Fl e Ar expression
.Op Ar file
.Sh DESCRIPTION
.Nm
is an arbitrary precision arithmetic package.
The overall structure of
.Nm
is
a stacking (reverse Polish) calculator i.e.\&
numbers are stored on a stack.
Adding a number pushes it onto the stack.
Arithmetic operations pop arguments off the stack
and push the results.
See also the
.Xr bc 1
utility, which is a preprocessor for
.Nm
providing infix notation and a C-like syntax
which implements functions and reasonable control
structures for programs.
The options are as follows:
.Bl -tag -width Ds
.It Fl e Ar expression
Evaluate
.Ar expression .
If multiple
.Fl e
options are specified, they will be processed in the order given.
.It Fl x
Enable extended register mode.
This mode is used by
.Xr bc 1
to allow more than 256 registers.
See
.Sx Registers
for a more detailed description.
.El
.Pp
If neither
.Ar expression
nor
.Ar file
are specified on the command line,
.Nm
reads from the standard input.
Otherwise
.Ar expression
and
.Ar file
are processed and
.Nm
exits.
.Pp
Ordinarily,
.Nm
operates on decimal integers,
but one may specify an input base, output base,
and a number of fractional digits (scale) to be maintained.
Whitespace is ignored, except where it signals the end of a number,
end of a line or when a register name is expected.
The following constructions are recognized:
.Bl -tag -width "number"
.It Va number
The value of the number is pushed on the stack.
A number is an unbroken string of the digits 0\-9 and letters A\-F.
It may be preceded by an underscore
.Pq Sq _
to input a negative number.
A number may contain a single decimal point.
A number may also contain the characters A\-F, with the values 10\-15.
.It Cm "+ - / * % ~ ^"
The
top two values on the stack are added
(+),
subtracted
(\-),
multiplied (*),
divided (/),
remaindered (%),
divided and remaindered (~),
or exponentiated (^).
The two entries are popped off the stack;
the result is pushed on the stack in their place.
Any fractional part of an exponent is ignored.
.Pp
For addition and subtraction, the scale of the result is the maximum
of scales of the operands.
For division the scale of the result is defined
by the scale set by the
.Ic k
operation.
For multiplication, the scale is defined by the expression
.Sy min(a+b,max(a,b,scale)) ,
where
.Sy a
and
.Sy b
are the scales of the operands, and
.Sy scale
is the scale defined by the
.Ic k
operation.
For exponentiation with a non-negative exponent, the scale of the result is
.Sy min(a*b,max(scale,a)) ,
where
.Sy a
is the scale of the base, and
.Sy b
is the
.Em value
of the exponent.
If the exponent is negative, the scale of the result is the scale
defined by the
.Ic k
operation.
.Pp
In the case of the division and modulus operator (~),
the resultant quotient is pushed first followed by the remainder.
This is a shorthand for the sequence:
.Bd -literal -offset indent -compact
x y / x y %
.Ed
The division and modulus operator is a non-portable extension.
.It Ic a
Pop the top value from the stack.
If that value is a number, compute the integer part of the number modulo 256.
If the result is zero, push an empty string.
Otherwise push a one character string by interpreting the computed value
as an
.Tn ASCII
character.
.Pp
If the top value is a string, push a string containing the first character
of the original string.
If the original string is empty, an empty string is pushed back.
The
.Ic a
operator is a non-portable extension.
.It Ic c
All values on the stack are popped.
.It Ic d
The top value on the stack is duplicated.
.It Ic e
Equivalent to
.Ic p ,
except that the output is written to the standard error stream.
.It Ic f
All values on the stack are printed, separated by newlines.
.It Ic G
The top two numbers are popped from the stack and compared.
A one is pushed if the top of the stack is equal to the second number
on the stack.
A zero is pushed otherwise.
This is a non-portable extension.
.It Ic I
Pushes the input base on the top of the stack.
.It Ic i
The top value on the stack is popped and used as the
base for further input.
The initial input base is 10.
.It Ic J
Pop the top value from the stack.
The recursion level is popped by that value and, following that,
the input is skipped until the first occurrence of the
.Ic M
operator.
The
.Ic J
operator is a non-portable extension, used by the
.Xr bc 1
command.
.It Ic K
The current scale factor is pushed onto the stack.
.It Ic k
The top of the stack is popped, and that value is used as
a non-negative scale factor:
the appropriate number of places
are printed on output,
and maintained during multiplication, division, and exponentiation.
The interaction of scale factor,
input base, and output base will be reasonable if all are changed
together.
.It Ic L Ns Ar x
Register
.Ar x
is treated as a stack and its top value is popped onto the main stack.
.It Ic l Ns Ar x
The
value in register
.Ar x
is pushed on the stack.
The register
.Ar x
is not altered.
Initially, all registers contain the value zero.
.It Ic M
Mark used by the
.Ic J
operator.
The
.Ic M
operator is a non-portable extensions, used by the
.Xr bc 1
command.
.It Ic N
The top of the stack is replaced by one if the top of the stack
is equal to zero.
If the top of the stack is unequal to zero, it is replaced by zero.
This is a non-portable extension.
.It Ic n
The top value on the stack is popped and printed without a newline.
This is a non-portable extension.
.It Ic O
Pushes the output base on the top of the stack.
.It Ic o
The top value on the stack is popped and used as the
base for further output.
The initial output base is 10.
.It Ic P
The top of the stack is popped.
If the top of the stack is a string, it is printed without a trailing newline.
If the top of the stack is a number, it is interpreted as a
base 256 number, and each digit of this base 256 number is printed as
an
.Tn ASCII
character, without a trailing newline.
.It Ic p
The top value on the stack is printed with a trailing newline.
The top value remains unchanged.
.It Ic Q
The top value on the stack is popped and the string execution level is popped
by that value.
.It Ic q
Exits the program.
If executing a string, the recursion level is
popped by two.
.It Ic R
The top of the stack is removed (popped).
This is a non-portable extension.
.It Ic r
The top two values on the stack are reversed (swapped).
This is a non-portable extension.
.It Ic S Ns Ar x
Register
.Ar x
is treated as a stack.
The top value of the main stack is popped and pushed on it.
.It Ic s Ns Ar x
The
top of the stack is popped and stored into
a register named
.Ar x .
.It Ic v
Replaces the top element on the stack by its square root.
The scale of the result is the maximum of the scale of the argument
and the current value of scale.
.It Ic X
Replaces the number on the top of the stack with its scale factor.
If the top of the stack is a string, replace it with the integer 0.
.It Ic x
Treats the top element of the stack as a character string
and executes it as a string of
.Nm
commands.
.It Ic Z
Replaces the number on the top of the stack with its length.
The length of a string is its number of characters.
The length of a number is its number of digits, not counting the minus sign
and decimal point.
.It Ic z
The stack level is pushed onto the stack.
.It Cm \&[ Ns ... Ns Cm \&]
Puts the bracketed
.Tn ASCII
string onto the top of the stack.
If the string includes brackets, these must be properly balanced.
The backslash character
.Pq Sq \e
may be used as an escape character, making it
possible to include unbalanced brackets in strings.
To include a backslash in a string, use a double backslash.
.It Xo
.Cm < Ns Va x
.Cm > Ns Va x
.Cm = Ns Va x
.Cm !< Ns Va x
.Cm !> Ns Va x
.Cm != Ns Va x
.Xc
The top two elements of the stack are popped and compared.
Register
.Ar x
is executed if they obey the stated
relation.
.It Xo
.Cm < Ns Va x Ns e Ns Va y
.Cm > Ns Va x Ns e Ns Va y
.Cm = Ns Va x Ns e Ns Va y
.Cm !< Ns Va x Ns e Ns Va y
.Cm !> Ns Va x Ns e Ns Va y
.Cm != Ns Va x Ns e Ns Va y
.Xc
These operations are variants of the comparison operations above.
The first register name is followed by the letter
.Sq e
and another register name.
Register
.Ar x
will be executed if the relation is true, and register
.Ar y
will be executed if the relation is false.
This is a non-portable extension.
.It Ic \&(
The top two numbers are popped from the stack and compared.
A one is pushed if the top of the stack is less than the second number
on the stack.
A zero is pushed otherwise.
This is a non-portable extension.
.It Ic {
The top two numbers are popped from the stack and compared.
A one is pushed if the top of stack is less than or equal to the
second number on the stack.
A zero is pushed otherwise.
This is a non-portable extension.
.It Ic \&?
A line of input is taken from the input source (usually the terminal)
and executed.
.It Ic \&: Ns Ar r
Pop two values from the stack.
The second value on the stack is stored into the array
.Ar r
indexed by the top of stack.
.It Ic \&; Ns Ar r
Pop a value from the stack.
The value is used as an index into register
.Ar r .
The value in this register is pushed onto the stack.
.Pp
Array elements initially have the value zero.
Each level of a stacked register has its own array associated with
it.
The command sequence
.Bd -literal -offset indent
[first] 0:a [dummy] Sa [second] 0:a 0;a p La 0;a p
.Ed
.Pp
will print
.Bd -literal -offset indent
second
first
.Ed
.Pp
since the string
.Ql second
is written in an array that is later popped, to reveal the array that
stored
.Ql first .
.It Ic #
Skip the rest of the line.
This is a non-portable extension.
.El
.Ss Registers
Registers have a single character name
.Ar x ,
where
.Ar x
may be any character, including space, tab or any other special character.
If extended register mode is enabled using the
.Fl x
option and the register identifier
.Ar x
has the value 255, the next two characters are interpreted as a
two-byte register index.
The set of standard single character registers and the set of extended
registers do not overlap.
Extended register mode is a non-portable extension.
.Sh EXAMPLES
An example which prints the first ten values of
.Ic n! :
.Bd -literal -offset indent
[la1+dsa*pla10>y]sy
0sa1
lyx
.Ed
.Pp
Independent of the current input base, the command
.Bd -literal -offset indent
Ai
.Ed
.Pp
will reset the input base to decimal 10.
.Sh DIAGNOSTICS
.Bl -diag
.It %c (0%o) is unimplemented
an undefined operation was called.
.It stack empty
for not enough elements on the stack to do what was asked.
.It stack register '%c' (0%o) is empty
for an
.Ar L
operation from a stack register that is empty.
.It Runtime warning: non-zero scale in exponent
for a fractional part of an exponent that is being ignored.
.It divide by zero
for trying to divide by zero.
.It remainder by zero
for trying to take a remainder by zero.
.It square root of negative number
for trying to take the square root of a negative number.
.It index too big
for an array index that is larger than 2048.
.It negative index
for a negative array index.
.It "input base must be a number between 2 and 16"
for trying to set an illegal input base.
.It output base must be a number greater than 1
for trying to set an illegal output base.
.It scale must be a nonnegative number
for trying to set a negative or zero scale.
.It scale too large
for trying to set a scale that is too large.
A scale must be representable as a 32-bit unsigned number.
.It Q command argument exceeded string execution depth
for trying to pop the recursion level more than the current
recursion level.
.It Q command requires a number >= 1
for trying to pop an illegal number of recursion levels.
.It recursion too deep
for too many levels of nested execution.
.Pp
The recursion level is increased by one if the
.Ar x
or
.Ar ?\&
operation or one of the compare operations resulting in the execution
of register is executed.
As an exception, the recursion level is not increased if the operation
is executed as the last command of a string.
For example, the commands
.Bd -literal -offset indent
[lax]sa
1 lax
.Ed
.Pp
will execute an endless loop, while the commands
.Bd -literal -offset indent
[laxp]sa
1 lax
.Ed
.Pp
will terminate because of a too deep recursion level.
.It J command argument exceeded string execution depth
for trying to pop the recursion level more than the current
recursion level.
.It mark not found
for a failed scan for an occurrence of the
.Ic M
operator.
.El
.Sh SEE ALSO
.Xr bc 1
.Sh STANDARDS
The arithmetic operations of the
.Nm
utility are expected to conform to the definition listed in the
.Xr bc 1
section of the
.St -p1003.2
specification.
.Sh HISTORY
The
.Nm
command first appeared in
.At v6 .
A complete rewrite of the
.Nm
command using the
.Xr BN_new 3
big number routines first appeared in
.Ox 3.5 .
.Sh AUTHORS
.An -nosplit
The original version of the
.Nm
command was written by
.An Robert Morris
and
.An Lorinda Cherry .
The current version of the
.Nm
utility was written by
.An Otto Moerbeek .
@


1.29
log
@replace all references to bn(3) with BN_new(3),
and make sure all BN*(3) pages point back to BN_new(3)
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.28 2015/10/03 17:15:26 deraadt Exp $
d37 1
a37 1
.Dd $Mdocdate: October 3 2015 $
d188 4
@


1.28
log
@delete documentation for ! command
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.28 2015/10/03 17:13:24 deraadt Exp $
d519 1
a519 1
.Xr bn 3
@


1.27
log
@Stefan Unterweger pointed out that, contrary to the man page,
dc exited after processing any expressions and/or files;

this is the doc fix, as requested by (and ok) otto
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.26 2010/10/18 14:48:49 jmc Exp $
d37 1
a37 1
.Dd $Mdocdate: October 18 2010 $
a365 4
.It Ic \&!
Interprets the rest of the line as a
.Ux
command.
@


1.26
log
@more usd/psd stuff lurking...
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.25 2010/09/19 21:30:04 jmc Exp $
d37 1
a37 1
.Dd $Mdocdate: September 19 2010 $
a73 6
If no
.Ar file
argument is given, execution will stop after processing the expressions
given on the command line,
otherwise processing will continue with the contents of
.Ar file .
d84 15
a103 3
If an argument is given,
input is taken from that file until its end,
then from the standard input.
@


1.25
log
@more wacky macro fixing;
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.24 2010/01/02 19:48:56 schwarze Exp $
d37 1
a37 1
.Dd $Mdocdate: January 2 2010 $
a500 6
.Rs
.%B USD:05
.%A L. L. Cherry
.%A R. Morris
.%T "DC \- An Interactive Desk Calculator"
.Re
@


1.24
log
@The .Os macro is not optional.  Even with groff(1),
forgetting it lets the footer line look incomplete and unbalanced.
Markup error found by mandoc(1), also required to fix the mandoc build.
ok jmc@@ sobrado@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.23 2007/05/31 19:20:09 jmc Exp $
d37 1
a37 1
.Dd $Mdocdate: May 31 2007 $
d307 1
a307 1
.It Cm [ Ns ... Ns Cm ]
d367 1
a367 1
.It Ic : Ns Ar r
d372 1
a372 1
.It Ic ; Ns Ar r
@


1.23
log
@convert to new .Dd format;
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.22 2007/02/24 08:56:42 jmc Exp $
d37 1
a37 1
.Dd $Mdocdate$
d39 1
@


1.22
log
@put `I' in the right place; from Igor Sobrado
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.21 2006/03/07 16:40:09 kjell Exp $
d37 1
a37 1
.Dd June 6, 1993
@


1.21
log
@Typo. ok otto@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.20 2005/09/30 20:34:25 jaredy Exp $
d189 2
a194 2
.It Ic I
Pushes the input base on the top of the stack.
@


1.20
log
@deploy .An -nosplit; ok jmc
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.19 2004/10/18 07:49:00 otto Exp $
d97 1
a97 1
Whitespace is ignored, expect where it signals the end of a number,
@


1.19
log
@Implement command line evaluation of expressions by implementing the -e option.
ok weingart@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.18 2003/12/01 09:13:55 otto Exp $
d526 1
@


1.18
log
@Allow for more registers using a 2 byte index. This feature is
enabled by supplying the -x option on the command line. Allows long
variable names in bc(1) (to appear soon). If no -x option is given,
behave exactly as before.

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.17 2003/11/17 11:12:35 otto Exp $
d45 1
d67 12
@


1.17
log
@A basic stack operation that is missing from the original dc (and
GNU dc as well): drop ('R').
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.16 2003/11/14 20:25:16 otto Exp $
d44 1
d64 11
d273 1
a273 4
.Ar x ,
where
.Ar x
may be any character, including space, tab or any other special character.
d387 15
d442 1
a442 1
for trying to set an illegal input base.
@


1.16
log
@Implement new boolean operations 'N' (not), 'G' (equals), '(' (less)
and '{' (less or equal). These operations push their result back
to the stack. Used by soon to appear boolean operations in bc(1).

man page tweaks and ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.15 2003/11/06 19:48:55 otto Exp $
d246 3
@


1.15
log
@Describe non-portable extension # (comment), n (print w/o newline),
and a (byte to char).

Tweaks and ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.14 2003/11/04 08:10:06 otto Exp $
d158 6
d214 5
d322 12
d460 6
a465 3
.Pp
USD:05
.Em "DC \- An Interactive Desk Calculator"
@


1.14
log
@Duh, a stack machine without swap; implement GNU compatible 'r'
(swap) operator. Prompted by Michael Knudsen <e at molioner dot dk>
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.13 2003/10/23 09:01:42 jmc Exp $
d137 15
d165 1
a165 1
Pop the top value of the stack.
d172 1
a172 1
operator is a non-portable extensions, used by the
d208 3
d348 3
@


1.13
log
@quote args to make them expand properly;
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.12 2003/10/22 12:16:25 otto Exp $
d217 3
@


1.12
log
@Document new extended comparison operators.

ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.11 2003/10/20 05:02:58 jmc Exp $
d365 1
a365 1
.It input base must be a number between 2 and 16
@


1.11
log
@typos from Jared Yanovich;
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.10 2003/10/19 18:39:13 otto Exp $
d272 18
@


1.10
log
@Reorder descriptions of operators alphabetically.
ok jmc@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.9 2003/10/18 21:00:17 jmc Exp $
d116 1
a116 1
For exponentation with a non-negative exponent, the scale of the result is
@


1.9
log
@- new sentence, new line
- spelling
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.8 2003/10/18 19:47:10 otto Exp $
d137 18
a154 1
.It Ic s Ns Ar x
d156 17
a172 4
top of the stack is popped and stored into
a register named
.Ar x ,
where
d174 1
a174 6
may be any character, including space, tab or any other special character.
If the
.Ic s
is capitalized,
.Ar x
is treated as a stack and the value is pushed on it.
d184 15
a198 11
If the
.Ar l
is capitalized,
register
.Ar x
is treated as a stack and its top value is popped onto the main stack.
.It Ic d
The top value on the stack is duplicated.
.It Ic p
The top value on the stack is printed with a trailing newline.
The top value remains unchanged.
d207 6
a212 2
.It Ic f
All values on the stack are printed, separated by newlines.
d217 20
a236 5
If
.Ic q
is capitalized,
the top value on the stack is popped and the string execution level is popped
by that value.
d242 7
a248 3
.It Ic X
Replaces the number on the top of the stack with its scale factor.
If the top of the stack is a string, replace it with the integer 0.
a271 4
.It Ic v
Replaces the top element on the stack by its square root.
The scale of the result is the maximum of the scale of the argument
and the current value of scale.
a275 32
.It Ic c
All values on the stack are popped.
.It Ic i
The top value on the stack is popped and used as the
base for further input.
The initial input base is 10.
.Ic I
Pushes the input base on the top of the stack.
.It Ic o
The top value on the stack is popped and used as the
base for further output.
The initial output base is 10.
.It Ic O
Pushes the output base on the top of the stack.
.It Ic k
The top of the stack is popped, and that value is used as
a non-negative scale factor:
the appropriate number of places
are printed on output,
and maintained during multiplication, division, and exponentiation.
The interaction of scale factor,
input base, and output base will be reasonable if all are changed
together.
.It Ic K
The current scale factor is pushed onto the stack.
.It Ic z
The stack level is pushed onto the stack.
.It Ic Z
Replaces the number on the top of the stack with its length.
The length of a string is its number of characters.
The length of a number is its number of digits, not counting the minus sign
and decimal point.
a308 17
.It Ic J
Pop the top value of the stack.
The recursion level is popped by that value and, following that,
the input is skipped until the first occurrence of the
.Ic M
operator.
.It Ic M
Mark used by the
.Ic J
operator.
The
.Ic J
and
.Ic M
operators are non-portable extensions, used by the
.Xr bc 1
command.
@


1.8
log
@Describe new J and M operators. Also some small cleanup.
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.7 2003/10/11 18:31:19 otto Exp $
d294 3
a296 3
Pop the top value of the stack. The recursion level is popped by that value,
and following that, the input is skipped until the first occurence of
the
d390 1
a390 1
for a failed scan for an occurence of the
@


1.7
log
@Division and modulus operator (~). From hugh@@.
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.6 2003/10/01 08:19:29 jmc Exp $
d103 1
a103 1
.Ar k
d114 1
a114 1
.Ar k
d127 1
a127 1
.Ar k
d146 1
a146 1
.Ar s
d185 1
a185 1
.Ar q
d293 17
d386 7
@


1.6
log
@tweak;
ok otto@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.5 2003/09/30 18:33:35 otto Exp $
d84 1
a84 1
.It Cm "+ - / * % ^"
d93 1
d129 8
@


1.5
log
@Teach dc(1) how to read strings with unbalanced braces by introducing
backslash as an escape char. This is needed for bc(1), which is
required by Posix to handle strings with brackets in them.
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.4 2003/09/22 14:50:32 otto Exp $
d193 3
a195 1
The backslash character \e\ may be used as an escape character, making it
d197 1
a197 1
To include a backslash into a string, use a double backslash.
@


1.4
log
@Typo.
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.3 2003/09/22 14:49:16 otto Exp $
d192 4
a195 1
The brackets may be nested.
@


1.3
log
@Make registers contain zero initially. Needed for new bc(1) and original dc(1)
compatible.
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.2 2003/09/22 04:59:00 jmc Exp $
d149 1
a149 1
Initally, all registers contain the value zero.
@


1.2
log
@tweaks;
ok otto@@
@
text
@d1 1
a1 1
.\"	$OpenBSD: dc.1,v 1.1 2003/09/19 17:59:47 otto Exp $
d149 1
a300 4
.It register '%c' (0%o) is empty
for an
.Ar l
operation from a register that was never written.
@


1.1
log
@Man page based on 4.4 BSD man page, using the Caldera license.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
.\"	$OpenBSD$
d44 1
a44 1
.Op  file
a47 3
Ordinarily it operates on decimal integers,
but one may specify an input base, output base,
and a number of fractional digits (scale) to be maintained.
d51 18
a68 1
a stacking (reverse Polish) calculator.
d72 1
a72 1
White space is ignored, expect where it signals the end of a number,
d75 1
a75 1
.Bl -tag -width flag
d79 4
a82 3
It may be preceded by an underscore _ to input a
negative number.
A numbers may contain a single decimal point.
d84 1
a84 1
.It Cm "+  - / * % ^"
d104 2
a105 2
For multiplication, the scale is the defined by the expression
.Sy min(a+b,max(a,b,scale))
d112 1
a112 1
is the schale defined by the
d116 1
a116 1
.Sy min(a*b,max(scale,a))
d162 1
a162 1
If the top of stack is a string, it is printed without a trailing newline.
d185 2
a186 2
replaces the number on the top of the stack with its scale factor.
If the top of stack is a string, replace it with the integer 0.
d209 1
a209 1
.It Ic !
d217 2
a218 1
base for further input. The initial input base is 10.
d223 2
a224 1
base for further output. The initial output base is 10.
d245 1
a245 1
.It Ic ?
d249 2
a250 2
Pop two values from the stack. The second value on the stack is stored
into the array
d254 2
a255 2
Pop a value from the stack. The value is used as an index into
register
d259 1
a259 1
Array element initially have the value zero.
d263 1
a263 2
.Pp
.Bd -literal -offset indent -compact
d268 1
a268 2
.Pp
.Bd -literal -offset indent -compact
d281 2
a282 3
.Ic n\&! :
.Pp
.Bd -literal -offset indent -compact
d289 1
a289 2
.Pp
.Bd -literal -offset indent -compact
d295 2
a296 2
.Bl -tag -width flag
.It Li %c (0%o) is unimplemented
d298 1
a298 1
.It Li stack empty
d300 2
a301 2
.It Li register '%c' (0%o) is empty
for a
d304 2
a305 2
.It Li stack register '%c' (0%o) is empty
for a
d308 1
a308 1
.It Li Runtime warning: non-zero scale in exponent
d310 1
a310 1
.It Li divide by zero
d312 1
a312 1
.It Li remainder by zero
d314 1
a314 1
.It Li square root of negative number
d316 1
a316 1
.It Li index too big
d318 1
a318 1
.It Li negative index
d320 1
a320 1
.It Li input base must be a number between 2 and 16
d322 1
a322 1
.It Li output base must be a number greater than 1
d324 1
a324 1
.It Li scale must be a nonnegative number
d326 1
a326 1
.It Li scale too large
d328 2
a329 2
A scale must be representable as a 32 bits unsigned number.
.It Li Q command argument exceeded string execution depth
d332 1
a332 1
.It Li Q command requires a number >= 1
d334 1
a334 1
.It Li recursion too deep
d340 1
a340 1
.Ar ?
d345 2
a346 3
for example, the commands
.Pp
.Bd -literal -offset indent -compact
d352 1
a352 2
.Pp
.Bd -literal -offset indent -compact
d360 1
a360 6
.Xr \&bc 1 ,
which is a preprocessor for
.Nm
providing infix notation and a C-like syntax
which implements functions and reasonable control
structures for programs.
a393 1

@

