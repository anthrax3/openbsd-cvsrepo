head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.22
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.20
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.16
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.9.0.10
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.8
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.6
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.14
date	2016.03.27.15.55.13;	author otto;	state Exp;
branches;
next	1.13;
commitid	Ub6HhCtkGLEDvl58;

1.13
date	2014.12.01.13.13.00;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	W5fMdNZS0R2ZH1P6;

1.12
date	2014.11.26.15.05.51;	author otto;	state Exp;
branches;
next	1.11;
commitid	dab0npz6Brks6Wy3;

1.11
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.28.06.35.09;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.16.08.09.25;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.15.19.11.59;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.28.17.39.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.26.19.30.52;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.04.08.10.06;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.18.20.34.26;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.28.19.29.33;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.19.19.00.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.19.17.58.25;	author otto;	state Exp;
branches;
next	;


desc
@@


1.14
log
@some style(9) and redundant tests for NULL, from Michael W. Bombardieri
@
text
@/*	$OpenBSD: stack.c,v 1.13 2014/12/01 13:13:00 deraadt Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <stdlib.h>
#include <string.h>

#include "extern.h"

static __inline bool	stack_empty(const struct stack *);
static void		stack_grow(struct stack *);
static struct array	*array_new(void);
static __inline void	array_free(struct array *);
static struct array *	array_dup(const struct array *);
static __inline void	array_grow(struct array *, size_t);
static __inline void	array_assign(struct array *, size_t, const struct value *);
static __inline struct value	*array_retrieve(const struct array *, size_t);

void
stack_init(struct stack *stack)
{
	stack->size = 0;
	stack->sp = -1;
	stack->stack = NULL;
}

static __inline bool
stack_empty(const struct stack *stack)
{
	bool empty = stack->sp == -1;
	if (empty)
		warnx("stack empty");
	return empty;
}

/* Clear number or string, but leave value itself */
void
stack_free_value(struct value *v)
{
	switch (v->type) {
	case BCODE_NONE:
		break;
	case BCODE_NUMBER:
		free_number(v->u.num);
		break;
	case BCODE_STRING:
		free(v->u.string);
		break;
	}
	array_free(v->array);
	v->array = NULL;
}

/* Copy number or string content into already allocated target */
struct value *
stack_dup_value(const struct value *a, struct value *copy)
{
	copy->type = a->type;

	switch (a->type) {
	case BCODE_NONE:
		break;
	case BCODE_NUMBER:
		copy->u.num = dup_number(a->u.num);
		break;
	case BCODE_STRING:
		copy->u.string = strdup(a->u.string);
		if (copy->u.string == NULL)
			err(1, NULL);
		break;
	}

	copy->array = a->array == NULL ? NULL : array_dup(a->array);

	return copy;
}

size_t
stack_size(const struct stack *stack)
{
	return stack->sp + 1;
}

void
stack_dup(struct stack *stack)
{
	struct value	*value;
	struct value	copy;

	value = stack_tos(stack);
	if (value == NULL) {
		warnx("stack empty");
		return;
	}
	stack_push(stack, stack_dup_value(value, &copy));
}

void
stack_swap(struct stack *stack)
{
	struct value	copy;

	if (stack->sp < 1) {
		warnx("stack empty");
		return;
	}
	copy = stack->stack[stack->sp];
	stack->stack[stack->sp] = stack->stack[stack->sp-1];
	stack->stack[stack->sp-1] = copy;
}

static void
stack_grow(struct stack *stack)
{
	size_t new_size;

	if (++stack->sp == stack->size) {
		new_size = stack->size * 2 + 1;
		stack->stack = breallocarray(stack->stack,
		    new_size, sizeof(*stack->stack));
		stack->size = new_size;
	}
}

void
stack_pushnumber(struct stack *stack, struct number *b)
{
	stack_grow(stack);
	stack->stack[stack->sp].type = BCODE_NUMBER;
	stack->stack[stack->sp].u.num = b;
	stack->stack[stack->sp].array = NULL;
}

void
stack_pushstring(struct stack *stack, char *string)
{
	stack_grow(stack);
	stack->stack[stack->sp].type = BCODE_STRING;
	stack->stack[stack->sp].u.string = string;
	stack->stack[stack->sp].array = NULL;
}

void
stack_push(struct stack *stack, struct value *v)
{
	switch (v->type) {
	case BCODE_NONE:
		stack_grow(stack);
		stack->stack[stack->sp].type = BCODE_NONE;
		break;
	case BCODE_NUMBER:
		stack_pushnumber(stack, v->u.num);
		break;
	case BCODE_STRING:
		stack_pushstring(stack, v->u.string);
		break;
	}
	stack->stack[stack->sp].array = v->array == NULL ?
	    NULL : array_dup(v->array);
}

struct value *
stack_tos(const struct stack *stack)
{
	if (stack->sp == -1)
		return NULL;
	return &stack->stack[stack->sp];
}

void
stack_set_tos(struct stack *stack, struct value *v)
{
	if (stack->sp == -1)
		stack_push(stack, v);
	else {
		stack_free_value(&stack->stack[stack->sp]);
		stack->stack[stack->sp] = *v;
		stack->stack[stack->sp].array = v->array == NULL ?
		    NULL : array_dup(v->array);
	}
}

struct value *
stack_pop(struct stack *stack)
{
	if (stack_empty(stack))
		return NULL;
	return &stack->stack[stack->sp--];
}

struct number *
stack_popnumber(struct stack *stack)
{
	if (stack_empty(stack))
		return NULL;
	array_free(stack->stack[stack->sp].array);
	stack->stack[stack->sp].array = NULL;
	if (stack->stack[stack->sp].type != BCODE_NUMBER) {
		warnx("not a number"); /* XXX remove */
		return NULL;
	}
	return stack->stack[stack->sp--].u.num;
}

char *
stack_popstring(struct stack *stack)
{
	if (stack_empty(stack))
		return NULL;
	array_free(stack->stack[stack->sp].array);
	stack->stack[stack->sp].array = NULL;
	if (stack->stack[stack->sp].type != BCODE_STRING) {
		warnx("not a string"); /* XXX remove */
		return NULL;
	}
	return stack->stack[stack->sp--].u.string;
}

void
stack_clear(struct stack *stack)
{
	while (stack->sp >= 0)
		stack_free_value(&stack->stack[stack->sp--]);
	free(stack->stack);
	stack_init(stack);
}

void
stack_print(FILE *f, const struct stack *stack, const char *prefix, u_int base)
{
	ssize_t i;

	for (i = stack->sp; i >= 0; i--) {
		print_value(f, &stack->stack[i], prefix, base);
		(void)putc('\n', f);
	}
}


static struct array *
array_new(void)
{
	struct array *a;

	a = bmalloc(sizeof(*a));
	a->data = NULL;
	a->size = 0;
	return a;
}

static __inline void
array_free(struct array *a)
{
	size_t i;

	if (a == NULL)
		return;
	for (i = 0; i < a->size; i++)
		stack_free_value(&a->data[i]);
	free(a->data);
	free(a);
}

static struct array *
array_dup(const struct array *a)
{
	struct array	*n;
	size_t		i;

	if (a == NULL)
		return NULL;
	n = array_new();
	array_grow(n, a->size);
	for (i = 0; i < a->size; i++)
		(void)stack_dup_value(&a->data[i], &n->data[i]);
	return n;
}

static __inline void
array_grow(struct array *array, size_t newsize)
{
	size_t i;

	array->data = breallocarray(array->data, newsize, sizeof(*array->data));
	for (i = array->size; i < newsize; i++) {
		array->data[i].type = BCODE_NONE;
		array->data[i].array = NULL;
	}
	array->size = newsize;
}

static __inline void
array_assign(struct array *array, size_t index, const struct value *v)
{
	if (index >= array->size)
		array_grow(array, index+1);
	stack_free_value(&array->data[index]);
	array->data[index] = *v;
}

static __inline struct value *
array_retrieve(const struct array *array, size_t index)
{
	if (index >= array->size)
		return NULL;
	return &array->data[index];
}

void
frame_assign(struct stack *stack, size_t index, const struct value *v)
{
	struct array *a;
	struct value n;

	if (stack->sp == -1) {
		n.type = BCODE_NONE;
		n.array = NULL;
		stack_push(stack, &n);
	}

	a = stack->stack[stack->sp].array;
	if (a == NULL)
		a = stack->stack[stack->sp].array = array_new();
	array_assign(a, index, v);
}

struct value *
frame_retrieve(const struct stack *stack, size_t index)
{
	struct array *a;

	if (stack->sp == -1)
		return NULL;
	a = stack->stack[stack->sp].array;
	if (a == NULL)
		a = stack->stack[stack->sp].array = array_new();
	return array_retrieve(a, index);
}
@


1.13
log
@more opportunity to use reallocarray(); ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.13 2014/12/01 13:11:21 deraadt Exp $	*/
d65 2
a66 4
	if (v->array != NULL) {
		array_free(v->array);
		v->array = NULL;
	}
d211 2
a212 4
	if (stack->stack[stack->sp].array != NULL) {
		array_free(stack->stack[stack->sp].array);
		stack->stack[stack->sp].array = NULL;
	}
d225 2
a226 4
	if (stack->stack[stack->sp].array != NULL) {
		array_free(stack->stack[stack->sp].array);
		stack->stack[stack->sp].array = NULL;
	}
d237 1
a237 1
	while (stack->sp >= 0) {
a238 1
	}
@


1.12
log
@init array field in the proper place, see regress test t27;
from Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.11 2009/10/27 23:59:37 deraadt Exp $	*/
d136 2
a137 2
		stack->stack = brealloc(stack->stack,
		    new_size * sizeof(*stack->stack));
d306 1
a306 1
	array->data = brealloc(array->data, newsize * sizeof(*array->data));
@


1.11
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.10 2008/04/28 06:35:09 otto Exp $	*/
d132 1
a132 1
	size_t new_size, i;
a137 2
		for (i = stack->size; i < new_size; i++)
			stack->stack[i].array = NULL;
d148 1
d157 1
@


1.10
log
@plug three leaks, one reported and fixed by Andreas Gunnarsson in PR 5802,
the others by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.9 2006/01/16 08:09:25 otto Exp $	*/
a17 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: stack.c,v 1.9 2006/01/16 08:09:25 otto Exp $";
#endif /* not lint */
@


1.9
log
@delint; use size_t as stack size and ssize_t as stack pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.8 2006/01/15 19:11:59 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.8 2006/01/15 19:11:59 otto Exp $";
d311 2
a312 1
	for (i = array->size; i < newsize; i++)
d314 1
d323 1
@


1.8
log
@delint wrt return values, including some missing BN return
values checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.7 2005/03/28 17:39:20 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.7 2005/03/28 17:39:20 deraadt Exp $";
d99 1
a99 1
int
d136 1
a136 1
	int new_size, i;
d257 1
a257 1
	int i;
d280 1
a280 1
	u_int i;
d294 1
a294 1
	u_int		i;
@


1.7
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.6 2003/11/26 19:30:52 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.6 2003/11/26 19:30:52 otto Exp $";
d261 1
a261 1
		putc('\n', f);
d301 1
a301 1
		stack_dup_value(&a->data[i], &n->data[i]);
@


1.6
log
@Avoid a core dump on reading uninitiazed array locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.5 2003/11/04 08:10:06 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.5 2003/11/04 08:10:06 otto Exp $";
d47 1
a47 1
stack_empty(const struct stack * stack)
d100 1
a100 1
stack_size(const struct stack * stack)
d200 1
a200 1
			NULL : array_dup(v->array);
@


1.5
log
@Duh, a stack machine without swap; implement GNU compatible 'r'
(swap) operator. Prompted by Michael Knudsen <e at molioner dot dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.4 2003/10/18 20:34:26 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.4 2003/10/18 20:34:26 otto Exp $";
d355 2
a361 14

/*
void
frame_free(struct stack *stack)
{
	struct array *a;

	a = stack->stack[stack->sp].array;
	if (a != NULL) {
		array_free(a);
		stack->stack[stack->sp].array = NULL;
	}
}
*/
@


1.4
log
@err(1, "out of mem") -> err(1, NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.3 2003/09/28 19:29:33 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.3 2003/09/28 19:29:33 otto Exp $";
d117 14
@


1.3
log
@realloc cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $";
d90 1
a90 1
			err(1, "cannot dup string");
@


1.2
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: stack.c,v 1.1 2003/09/19 17:58:25 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: stack.c,v 1.1 2003/09/19 17:58:25 otto Exp $";
d122 1
a122 1
	int old_size, i;
d125 1
a125 2
		old_size = stack->size;
		stack->size *= 2;
d127 2
a128 2
		    ++stack->size * sizeof(*stack->stack));
		for (i = old_size; i < stack->size; i++)
d130 1
@


1.1
log
@A complete, BSD licensed rewrite of dc(1), using the bn(3) big number routines.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD$";
d286 1
a286 1
	for (i = 0; i < a->size; i++) 
@

