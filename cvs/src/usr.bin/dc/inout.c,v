head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.2
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.10
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.8
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.18
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.14
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.20
date	2017.02.26.11.29.55;	author otto;	state Exp;
branches;
next	1.19;
commitid	RIwMw6QjJ5TMoCzX;

1.19
date	2015.02.16.20.53.34;	author jca;	state Exp;
branches;
next	1.18;
commitid	B2pYYUIr8jLmV0VS;

1.18
date	2014.12.01.13.13.00;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	W5fMdNZS0R2ZH1P6;

1.17
date	2012.11.07.11.06.14;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2012.11.06.16.00.05;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.15.19.11.59;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.14.08.10.02;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.29.10.53.54;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.28.19.19.36;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.27.18.10.42;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.15.10.28.38;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.14.20.18.47;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.22.12.03.54;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.18.20.34.26;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.30.18.33.35;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.28.19.29.32;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.19.19.06.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.19.19.00.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.19.17.58.25;	author otto;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Move away from BN_zero, the one returning an int is deprecated and the
new one is a void function. From Daniel Cegielka.
@
text
@/*	$OpenBSD: inout.c,v 1.19 2015/02/16 20:53:34 jca Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <ctype.h>
#include <err.h>
#include <string.h>

#include "extern.h"

#define MAX_CHARS_PER_LINE 68

static int	lastchar;
static int	charcount;

static int	src_getcharstream(struct source *);
static void	src_ungetcharstream(struct source *);
static char	*src_getlinestream(struct source *);
static void	src_freestream(struct source *);
static int	src_getcharstring(struct source *);
static void	src_ungetcharstring(struct source *);
static char	*src_getlinestring(struct source *);
static void	src_freestring(struct source *);
static void	flushwrap(FILE *);
static void	putcharwrap(FILE *, int);
static void	printwrap(FILE *, const char *);
static char	*get_digit(u_long, int, u_int);

static struct vtable stream_vtable = {
	src_getcharstream,
	src_ungetcharstream,
	src_getlinestream,
	src_freestream
};

static struct vtable string_vtable = {
	src_getcharstring,
	src_ungetcharstring,
	src_getlinestring,
	src_freestring
};

void
src_setstream(struct source *src, FILE *stream)
{
	src->u.stream = stream;
	src->vtable = &stream_vtable;
}

void
src_setstring(struct source *src, char *p)
{
	src->u.string.buf = (u_char *)p;
	src->u.string.pos = 0;
	src->vtable = &string_vtable;
}

static int
src_getcharstream(struct source *src)
{
	return src->lastchar = getc(src->u.stream);
}

static void
src_ungetcharstream(struct source *src)
{
	(void)ungetc(src->lastchar, src->u.stream);
}

/* ARGSUSED */
static void
src_freestream(struct source *src)
{
}

static char *
src_getlinestream(struct source *src)
{
	char buf[BUFSIZ];

	if (fgets(buf, BUFSIZ, src->u.stream) == NULL)
		return bstrdup("");
	return bstrdup(buf);
}

static int
src_getcharstring(struct source *src)
{
	src->lastchar = src->u.string.buf[src->u.string.pos];
	if (src->lastchar == '\0')
		return EOF;
	else {
		src->u.string.pos++;
		return src->lastchar;
	}
}

static void
src_ungetcharstring(struct source *src)
{
	if (src->u.string.pos > 0) {
		if (src->lastchar != '\0')
			--src->u.string.pos;
	}
}

static char *
src_getlinestring(struct source *src)
{
	char buf[BUFSIZ];
	int ch, i;

	i = 0;
	while (i < BUFSIZ-1) {
		ch = src_getcharstring(src);
		if (ch == EOF)
			break;
		buf[i++] = ch;
		if (ch == '\n')
			break;
	}
	buf[i] = '\0';
	return bstrdup(buf);
}

static void
src_freestring(struct source *src)
{
	free(src->u.string.buf);
}

static void
flushwrap(FILE *f)
{
	if (lastchar != -1)
		(void)putc(lastchar, f);
}

static void
putcharwrap(FILE *f, int ch)
{
	if (charcount >= MAX_CHARS_PER_LINE) {
		charcount = 0;
		(void)fputs("\\\n", f);
	}
	if (lastchar != -1) {
		charcount++;
		(void)putc(lastchar, f);
	}
	lastchar = ch;
}

static void
printwrap(FILE *f, const char *p)
{
	char	buf[12];
	char	*q = buf;

	(void)strlcpy(buf, p, sizeof(buf));
	while (*q)
		putcharwrap(f, *q++);
}

struct number *
readnumber(struct source *src, u_int base)
{
	struct number	*n;
	int		ch;
	bool		sign = false;
	bool		dot = false;
	BN_ULONG	v;
	u_int		i;

	n = new_number();
	bn_check(BN_set_word(n->number, 0));

	while ((ch = (*src->vtable->readchar)(src)) != EOF) {

		if ('0' <= ch && ch <= '9')
			v = ch - '0';
		else if ('A' <= ch && ch <= 'F')
			v = ch - 'A' + 10;
		else if (ch == '_') {
			sign = true;
			continue;
		} else if (ch == '.') {
			if (dot)
				break;
			dot = true;
			continue;
		} else {
			(*src->vtable->unreadchar)(src);
			break;
		}
		if (dot)
			n->scale++;

		bn_check(BN_mul_word(n->number, base));

#if 0
		/* work around a bug in BN_add_word: 0 += 0 is buggy.... */
		if (v > 0)
#endif
			bn_check(BN_add_word(n->number, v));
	}
	if (base != 10) {
		scale_number(n->number, n->scale);
		for (i = 0; i < n->scale; i++)
			(void)BN_div_word(n->number, base);
	}
	if (sign)
		negate(n);
	return n;
}

char *
read_string(struct source *src)
{
	int count, i, sz, new_sz, ch;
	char *p;
	bool escape;

	escape = false;
	count = 1;
	i = 0;
	sz = 15;
	p = bmalloc(sz + 1);

	while ((ch = (*src->vtable->readchar)(src)) != EOF) {
		if (!escape) {
			if (ch == '[')
				count++;
			else if (ch == ']')
				count--;
			if (count == 0)
				break;
		}
		if (ch == '\\' && !escape)
			escape = true;
		else {
			escape = false;
			if (i == sz) {
				new_sz = sz * 2;
				p = breallocarray(p, 1, new_sz + 1);
				sz = new_sz;
			}
			p[i++] = ch;
		}
	}
	p[i] = '\0';
	return p;
}

static char *
get_digit(u_long num, int digits, u_int base)
{
	char *p;

	if (base <= 16) {
		p = bmalloc(2);
		p[0] = num >= 10 ? num + 'A' - 10 : num + '0';
		p[1] = '\0';
	} else {
		if (asprintf(&p, "%0*lu", digits, num) == -1)
			err(1, NULL);
	}
	return p;
}

void
printnumber(FILE *f, const struct number *b, u_int base)
{
	struct number	*int_part, *fract_part;
	int		digits;
	char		buf[11];
	size_t		sz;
	int		i;
	struct stack	stack;
	char		*p;

	charcount = 0;
	lastchar = -1;
	if (BN_is_zero(b->number))
		putcharwrap(f, '0');

	int_part = new_number();
	fract_part = new_number();
	fract_part->scale = b->scale;

	if (base <= 16)
		digits = 1;
	else {
		digits = snprintf(buf, sizeof(buf), "%u", base-1);
	}
	split_number(b, int_part->number, fract_part->number);

	i = 0;
	stack_init(&stack);
	while (!BN_is_zero(int_part->number)) {
		BN_ULONG rem = BN_div_word(int_part->number, base);
		stack_pushstring(&stack, get_digit(rem, digits, base));
		i++;
	}
	sz = i;
	if (BN_is_negative(b->number))
		putcharwrap(f, '-');
	for (i = 0; i < sz; i++) {
		p = stack_popstring(&stack);
		if (base > 16)
			putcharwrap(f, ' ');
		printwrap(f, p);
		free(p);
	}
	stack_clear(&stack);
	if (b->scale > 0) {
		struct number	*num_base;
		BIGNUM		mult, stop;

		putcharwrap(f, '.');
		num_base = new_number();
		bn_check(BN_set_word(num_base->number, base));
		BN_init(&mult);
		bn_check(BN_one(&mult));
		BN_init(&stop);
		bn_check(BN_one(&stop));
		scale_number(&stop, b->scale);

		i = 0;
		while (BN_cmp(&mult, &stop) < 0) {
			u_long	rem;

			if (i && base > 16)
				putcharwrap(f, ' ');
			i = 1;

			bmul_number(fract_part, fract_part, num_base,
			    bmachine_scale());
			split_number(fract_part, int_part->number, NULL);
			rem = BN_get_word(int_part->number);
			p = get_digit(rem, digits, base);
			int_part->scale = 0;
			normalize(int_part, fract_part->scale);
			bn_check(BN_sub(fract_part->number, fract_part->number,
			    int_part->number));
			printwrap(f, p);
			free(p);
			bn_check(BN_mul_word(&mult, base));
		}
		free_number(num_base);
		BN_free(&mult);
		BN_free(&stop);
	}
	flushwrap(f);
	free_number(int_part);
	free_number(fract_part);
}

void
print_value(FILE *f, const struct value *value, const char *prefix, u_int base)
{
	(void)fputs(prefix, f);
	switch (value->type) {
	case BCODE_NONE:
		if (value->array != NULL)
			(void)fputs("<array>", f);
		break;
	case BCODE_NUMBER:
		printnumber(f, value->u.num, base);
		break;
	case BCODE_STRING:
		(void)fputs(value->u.string, f);
		break;
	}
}

void
print_ascii(FILE *f, const struct number *n)
{
	BIGNUM *v;
	int numbits, i, ch;

	v = BN_dup(n->number);
	bn_checkp(v);

	if (BN_is_negative(v))
		BN_set_negative(v, 0);

	numbits = BN_num_bytes(v) * 8;
	while (numbits > 0) {
		ch = 0;
		for (i = 0; i < 8; i++)
			ch |= BN_is_bit_set(v, numbits-i-1) << (7 - i);
		(void)putc(ch, f);
		numbits -= 8;
	}
	BN_free(v);
}
@


1.19
log
@Include bn.h and err.h from <openssl/...>, not the old <ssl/...> location.

Remove unneeded ssl.h includes.  Also built-checked against openssl-1.0.1e.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.18 2014/12/01 13:13:00 deraadt Exp $	*/
d189 1
a189 1
	bn_check(BN_zero(n->number));
@


1.18
log
@more opportunity to use reallocarray(); ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.18 2014/12/01 13:11:21 deraadt Exp $	*/
a18 1
#include <ssl/ssl.h>
@


1.17
log
@fix fractional number exponentiation, especially for negative exponents
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.16 2012/11/06 16:00:05 otto Exp $	*/
d259 1
a259 1
				p = brealloc(p, new_sz + 1);
@


1.16
log
@use BN_set_negative() and BN_is_negative() instead of subtracting or
comparing to zero
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.15 2009/10/27 23:59:37 deraadt Exp $	*/
d351 2
a352 1
			bmul_number(fract_part, fract_part, num_base);
@


1.15
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.14 2006/01/15 19:11:59 otto Exp $	*/
d320 1
a320 1
	if (BN_cmp(b->number, &zero) < 0)
d399 2
a400 2
	if (BN_cmp(v, &zero) < 0)
		bn_check(BN_sub(v, &zero, v));
@


1.14
log
@delint wrt return values, including some missing BN return
values checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.13 2005/12/14 08:10:02 otto Exp $	*/
a17 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: inout.c,v 1.13 2005/12/14 08:10:02 otto Exp $";
#endif /* not lint */
@


1.13
log
@Fix parsing  of non-decimal fractions, which was giving bogus results.
Noted by Zvezdan Petkovic in PR 4940.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.12 2005/03/29 10:53:54 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.12 2005/03/29 10:53:54 otto Exp $";
d36 1
a36 1
static int	src_ungetcharstream(struct source *);
d40 1
a40 1
static int	src_ungetcharstring(struct source *);
d83 1
a83 1
static int
d86 1
a86 1
	return ungetc(src->lastchar, src->u.stream);
d89 1
d117 1
a117 1
static int
a119 2
	int ch;

d123 1
a123 4
		ch = src->u.string.buf[src->u.string.pos];
		return ch == '\0' ? EOF : ch;
	} else
		return EOF;
d155 1
a155 1
		putc(lastchar, f);
d163 1
a163 1
		fputs("\\\n", f);
d167 1
a167 1
		putc(lastchar, f);
d178 1
a178 1
	strlcpy(buf, p, sizeof(buf));
d228 1
a228 1
			BN_div_word(n->number, base);
d340 1
a340 1
		BN_set_word(num_base->number, base);
d342 1
a342 1
		BN_one(&mult);
d344 1
a344 1
		BN_one(&stop);
d361 2
a362 2
			BN_sub(fract_part->number, fract_part->number,
			    int_part->number);
d365 1
a365 1
			BN_mul_word(&mult, base);
d379 1
a379 1
	fputs(prefix, f);
d383 1
a383 1
			fputs("<array>", f);
d389 1
a389 1
		fputs(value->u.string, f);
d411 1
a411 1
		putc(ch, f);
@


1.12
log
@Nicer wrapping. We used to mimick the old dc(1), which prints
...\<newline><newline> in some cases. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.11 2005/03/28 19:19:36 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.11 2005/03/28 19:19:36 otto Exp $";
d195 1
d228 5
@


1.11
log
@Linefeed is part of a line according to POSIX, so take that into account
when computing line wraps. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.10 2005/03/27 18:10:42 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.10 2005/03/27 18:10:42 otto Exp $";
d32 2
a33 2
static int	charCount;

d43 1
d156 7
d165 2
a166 3
	putc(ch, f);
	if (++charCount >= MAX_CHARS_PER_LINE) {
		charCount = 0;
d169 5
d298 2
a321 1
	charCount = 0;
d369 1
@


1.10
log
@Use inclusive bound check for line length, it is more clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.9 2005/03/15 10:28:38 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.9 2005/03/15 10:28:38 otto Exp $";
d30 1
a30 1
#define MAX_CHARS_PER_LINE 69
@


1.9
log
@snprintf(buf, sizeof(buf), "%s", p) is silly, use strlcpy(). From Bruno Rohee.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.8 2003/11/14 20:18:47 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.8 2003/11/14 20:18:47 otto Exp $";
d30 1
a30 1
#define MAX_CHARS_PER_LINE 68
d158 1
a158 1
	if (++charCount > MAX_CHARS_PER_LINE) {
@


1.8
log
@The BN_add_word() bug has been squashed, so we don't need a workaround
any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.7 2003/10/22 12:03:54 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.7 2003/10/22 12:03:54 otto Exp $";
d170 1
a170 1
	snprintf(buf, sizeof(buf), "%s", p);
@


1.7
log
@Make ungetting a char read form a string behave the same as ungetting
a char from a stream.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.6 2003/10/18 20:34:26 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.6 2003/10/18 20:34:26 otto Exp $";
d210 1
d213 1
@


1.6
log
@err(1, "out of mem") -> err(1, NULL)
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.5 2003/09/30 18:33:35 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.5 2003/09/30 18:33:35 otto Exp $";
d118 8
a125 3
	if (src->u.string.pos > 0)
		return src->u.string.buf[--src->u.string.pos];
	else
@


1.5
log
@Teach dc(1) how to read strings with unbalanced braces by introducing
backslash as an escape char. This is needed for bc(1), which is
required by Posix to handle strings with brackets in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.4 2003/09/28 19:29:32 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.4 2003/09/28 19:29:32 otto Exp $";
d263 1
a263 1
			err(1, "cannot allocate string");
@


1.4
log
@realloc cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.3 2003/09/19 19:06:29 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.3 2003/09/19 19:06:29 deraadt Exp $";
d219 1
d221 1
d228 18
a245 10
		if (ch == '[')
			count++;
		else if (ch == ']')
			count--;
		if (count == 0)
			break;
		if (i == sz) {
			new_sz = sz * 2;
			p = brealloc(p, new_sz + 1);
			sz = new_sz;
a246 1
		p[i++] = ch;
@


1.3
log
@blanks
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $";
d217 1
a217 1
	int count, i, sz, ch;
d233 3
a235 2
			sz *= 2;
			p = brealloc(p, sz + 1);
@


1.2
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: inout.c,v 1.1 2003/09/19 17:58:25 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: inout.c,v 1.1 2003/09/19 17:58:25 otto Exp $";
d246 1
@


1.1
log
@A complete, BSD licensed rewrite of dc(1), using the bn(3) big number routines.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD$";
d248 1
a248 1
		p[0] = num >= 10 ? num + 'A' - 10 : num + '0'; 
@

