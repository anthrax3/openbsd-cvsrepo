head	1.51;
access;
symbols
	OPENBSD_6_2:1.51.0.6
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.49.0.2
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.47.0.6
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.47.0.2
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.45.0.10
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.8
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.8
	OPENBSD_5_0:1.41.0.6
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.4
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.8
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.6
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22;
locks; strict;
comment	@ * @;


1.51
date	2017.02.26.11.29.55;	author otto;	state Exp;
branches;
next	1.50;
commitid	RIwMw6QjJ5TMoCzX;

1.50
date	2017.02.23.06.40.17;	author otto;	state Exp;
branches;
next	1.49;
commitid	ZyO2h2TEPTzcwEtk;

1.49
date	2016.03.27.15.55.13;	author otto;	state Exp;
branches;
next	1.48;
commitid	Ub6HhCtkGLEDvl58;

1.48
date	2015.10.03.16.24.53;	author otto;	state Exp;
branches;
next	1.47;
commitid	UzASDKCM23sVkGth;

1.47
date	2015.02.16.20.53.34;	author jca;	state Exp;
branches;
next	1.46;
commitid	B2pYYUIr8jLmV0VS;

1.46
date	2014.10.08.03.59.56;	author doug;	state Exp;
branches;
next	1.45;
commitid	dJytjUXavBFW7bJm;

1.45
date	2012.11.07.11.06.14;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.06.16.00.05;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.06.15.46.46;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.08.08.15.37;	author otto;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.15.10.59.29;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.27.23.59.37;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.06.13.33.33;	author otto;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.24.08.48.48;	author otto;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.28.06.35.09;	author otto;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.26.20.13.22;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.02.23.50.04;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.19.20.06.55;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.16.08.09.25;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.15.19.14.40;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.15.19.11.59;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.25.19.02.38;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.02.18.05.04;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.28.17.39.20;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.27.17.50.55;	author otto;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.01.08.40.12;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.01.08.29.38;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.18.07.49.00;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.14.22.22.46;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.11.20.44.31;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.20.21.41.20;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.19.19.23.16;	author otto;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.02.13.43.02;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.01.09.13.24;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.17.11.12.35;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.14.20.25.16;	author otto;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.09.20.33.09;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.06.19.48.13;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.04.08.10.06;	author otto;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.14.58.32;	author otto;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.22.12.15.20;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.18.20.33.48;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.18.19.45.42;	author otto;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.11.18.31.18;	author otto;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.30.18.27.01;	author otto;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.28.19.15.53;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.22.14.49.16;	author otto;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.20.06.28.24;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.19.20.58.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.19.19.00.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.19.17.58.25;	author otto;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Move away from BN_zero, the one returning an int is deprecated and the
new one is a void function. From Daniel Cegielka.
@
text
@/*	$OpenBSD: bcode.c,v 1.50 2017/02/23 06:40:17 otto Exp $	*/

/*
 * Copyright (c) 2003, Otto Moerbeek <otto@@drijf.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <err.h>
#include <limits.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "extern.h"

/* #define	DEBUGGING */

#define MAX_ARRAY_INDEX		2048
#define READSTACK_SIZE		8

#define NO_ELSE			-2	/* -1 is EOF */
#define REG_ARRAY_SIZE_SMALL	(UCHAR_MAX + 1)
#define REG_ARRAY_SIZE_BIG	(UCHAR_MAX + 1 + USHRT_MAX + 1)

struct bmachine {
	struct stack		stack;
	u_int			scale;
	u_int			obase;
	u_int			ibase;
	size_t			readsp;
	bool			extended_regs;
	size_t			reg_array_size;
	struct stack		*reg;
	volatile sig_atomic_t	interrupted;
	struct source		*readstack;
	size_t			readstack_sz;
};

static struct bmachine	bmachine;
static void sighandler(int);

static __inline int	readch(void);
static __inline void	unreadch(void);
static __inline char	*readline(void);
static __inline void	src_free(void);

static __inline u_int	max(u_int, u_int);
static u_long		get_ulong(struct number *);

static __inline void	push_number(struct number *);
static __inline void	push_string(char *);
static __inline void	push(struct value *);
static __inline struct value *tos(void);
static __inline struct number	*pop_number(void);
static __inline char	*pop_string(void);
static __inline void	clear_stack(void);
static __inline void	print_tos(void);
static void		print_err(void);
static void		pop_print(void);
static void		pop_printn(void);
static __inline void	print_stack(void);
static __inline void	dup(void);
static void		swap(void);
static void		drop(void);

static void		get_scale(void);
static void		set_scale(void);
static void		get_obase(void);
static void		set_obase(void);
static void		get_ibase(void);
static void		set_ibase(void);
static void		stackdepth(void);
static void		push_scale(void);
static u_int		count_digits(const struct number *);
static void		num_digits(void);
static void		to_ascii(void);
static void		push_line(void);
static void		comment(void);
static void		badd(void);
static void		bsub(void);
static void		bmul(void);
static void		bdiv(void);
static void		bmod(void);
static void		bdivmod(void);
static void		bexp(void);
static bool		bsqrt_stop(const BIGNUM *, const BIGNUM *, u_int *);
static void		bsqrt(void);
static void		not(void);
static void		equal_numbers(void);
static void		less_numbers(void);
static void		lesseq_numbers(void);
static void		equal(void);
static void		not_equal(void);
static void		less(void);
static void		not_less(void);
static void		greater(void);
static void		not_greater(void);
static void		not_compare(void);
static bool		compare_numbers(enum bcode_compare, struct number *,
			    struct number *);
static void		compare(enum bcode_compare);
static int		readreg(void);
static void		load(void);
static void		store(void);
static void		load_stack(void);
static void		store_stack(void);
static void		load_array(void);
static void		store_array(void);
static void		nop(void);
static void		quit(void);
static void		quitN(void);
static void		skipN(void);
static void		skip_until_mark(void);
static void		parse_number(void);
static void		unknown(void);
static void		eval_string(char *);
static void		eval_line(void);
static void		eval_tos(void);


typedef void		(*opcode_function)(void);

struct jump_entry {
	u_char		ch;
	opcode_function	f;
};

static opcode_function jump_table[UCHAR_MAX];

static const struct jump_entry jump_table_data[] = {
	{ ' ',	nop		},
	{ '!',	not_compare	},
	{ '#',	comment		},
	{ '%',	bmod		},
	{ '(',	less_numbers	},
	{ '*',	bmul		},
	{ '+',	badd		},
	{ '-',	bsub		},
	{ '.',	parse_number	},
	{ '/',	bdiv		},
	{ '0',	parse_number	},
	{ '1',	parse_number	},
	{ '2',	parse_number	},
	{ '3',	parse_number	},
	{ '4',	parse_number	},
	{ '5',	parse_number	},
	{ '6',	parse_number	},
	{ '7',	parse_number	},
	{ '8',	parse_number	},
	{ '9',	parse_number	},
	{ ':',	store_array	},
	{ ';',	load_array	},
	{ '<',	less		},
	{ '=',	equal		},
	{ '>',	greater		},
	{ '?',	eval_line	},
	{ 'A',	parse_number	},
	{ 'B',	parse_number	},
	{ 'C',	parse_number	},
	{ 'D',	parse_number	},
	{ 'E',	parse_number	},
	{ 'F',	parse_number	},
	{ 'G',	equal_numbers	},
	{ 'I',	get_ibase	},
	{ 'J',	skipN		},
	{ 'K',	get_scale	},
	{ 'L',	load_stack	},
	{ 'M',	nop		},
	{ 'N',	not		},
	{ 'O',	get_obase	},
	{ 'P',	pop_print	},
	{ 'Q',	quitN		},
	{ 'R',	drop		},
	{ 'S',	store_stack	},
	{ 'X',	push_scale	},
	{ 'Z',	num_digits	},
	{ '[',	push_line	},
	{ '\f',	nop		},
	{ '\n',	nop		},
	{ '\r',	nop		},
	{ '\t',	nop		},
	{ '^',	bexp		},
	{ '_',	parse_number	},
	{ 'a',	to_ascii	},
	{ 'c',	clear_stack	},
	{ 'd',	dup		},
	{ 'e',	print_err	},
	{ 'f',	print_stack	},
	{ 'i',	set_ibase	},
	{ 'k',	set_scale	},
	{ 'l',	load		},
	{ 'n',	pop_printn	},
	{ 'o',	set_obase	},
	{ 'p',	print_tos	},
	{ 'q',	quit		},
	{ 'r',	swap		},
	{ 's',	store		},
	{ 'v',	bsqrt		},
	{ 'x',	eval_tos	},
	{ 'z',	stackdepth	},
	{ '{',	lesseq_numbers	},
	{ '~',	bdivmod		}
};

#define JUMP_TABLE_DATA_SIZE \
	(sizeof(jump_table_data)/sizeof(jump_table_data[0]))

/* ARGSUSED */
static void
sighandler(int ignored)
{
	bmachine.interrupted = true;
}

void
init_bmachine(bool extended_registers)
{
	int i;

	bmachine.extended_regs = extended_registers;
	bmachine.reg_array_size = bmachine.extended_regs ?
	    REG_ARRAY_SIZE_BIG : REG_ARRAY_SIZE_SMALL;

	bmachine.reg = calloc(bmachine.reg_array_size,
	    sizeof(bmachine.reg[0]));
	if (bmachine.reg == NULL)
		err(1, NULL);

	for (i = 0; i < UCHAR_MAX; i++)
		jump_table[i] = unknown;
	for (i = 0; i < JUMP_TABLE_DATA_SIZE; i++)
		jump_table[jump_table_data[i].ch] = jump_table_data[i].f;

	stack_init(&bmachine.stack);

	for (i = 0; i < bmachine.reg_array_size; i++)
		stack_init(&bmachine.reg[i]);

	bmachine.readstack_sz = READSTACK_SIZE;
	bmachine.readstack = calloc(sizeof(struct source),
	    bmachine.readstack_sz);
	if (bmachine.readstack == NULL)
		err(1, NULL);
	bmachine.obase = bmachine.ibase = 10;
	(void)signal(SIGINT, sighandler);
}

u_int
bmachine_scale(void)
{
	return bmachine.scale;
}

/* Reset the things needed before processing a (new) file */
void
reset_bmachine(struct source *src)
{
	bmachine.readsp = 0;
	bmachine.readstack[0] = *src;
}

static __inline int
readch(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	return src->vtable->readchar(src);
}

static __inline void
unreadch(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	src->vtable->unreadchar(src);
}

static __inline char *
readline(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	return src->vtable->readline(src);
}

static __inline void
src_free(void)
{
	struct source *src = &bmachine.readstack[bmachine.readsp];

	src->vtable->free(src);
}

#ifdef DEBUGGING
void
pn(const char *str, const struct number *n)
{
	char *p = BN_bn2dec(n->number);
	if (p == NULL)
		err(1, "BN_bn2dec failed");
	(void)fputs(str, stderr);
	(void)fprintf(stderr, " %s (%u)\n" , p, n->scale);
	OPENSSL_free(p);
}

void
pbn(const char *str, const BIGNUM *n)
{
	char *p = BN_bn2dec(n);
	if (p == NULL)
		err(1, "BN_bn2dec failed");
	(void)fputs(str, stderr);
	(void)fprintf(stderr, " %s\n", p);
	OPENSSL_free(p);
}

#endif

static __inline u_int
max(u_int a, u_int b)
{
	return a > b ? a : b;
}

static unsigned long factors[] = {
	0, 10, 100, 1000, 10000, 100000, 1000000, 10000000,
	100000000, 1000000000
};

void
scale_number(BIGNUM *n, int s)
{
	int abs_scale;

	if (s == 0)
		return;

	abs_scale = s > 0 ? s : -s;

	if (abs_scale < sizeof(factors)/sizeof(factors[0])) {
		if (s > 0)
			bn_check(BN_mul_word(n, factors[abs_scale]));
		else
			(void)BN_div_word(n, factors[abs_scale]);
	} else {
		BIGNUM *a, *p;
		BN_CTX *ctx;

		a = BN_new();
		bn_checkp(a);
		p = BN_new();
		bn_checkp(p);
		ctx = BN_CTX_new();
		bn_checkp(ctx);

		bn_check(BN_set_word(a, 10));
		bn_check(BN_set_word(p, abs_scale));
		bn_check(BN_exp(a, a, p, ctx));
		if (s > 0)
			bn_check(BN_mul(n, n, a, ctx));
		else
			bn_check(BN_div(n, NULL, n, a, ctx));
		BN_CTX_free(ctx);
		BN_free(a);
		BN_free(p);
	}
}

void
split_number(const struct number *n, BIGNUM *i, BIGNUM *f)
{
	u_long rem;

	bn_checkp(BN_copy(i, n->number));

	if (n->scale == 0 && f != NULL)
		bn_check(BN_set_word(f, 0));
	else if (n->scale < sizeof(factors)/sizeof(factors[0])) {
		rem = BN_div_word(i, factors[n->scale]);
		if (f != NULL)
			bn_check(BN_set_word(f, rem));
	} else {
		BIGNUM *a, *p;
		BN_CTX *ctx;

		a = BN_new();
		bn_checkp(a);
		p = BN_new();
		bn_checkp(p);
		ctx = BN_CTX_new();
		bn_checkp(ctx);

		bn_check(BN_set_word(a, 10));
		bn_check(BN_set_word(p, n->scale));
		bn_check(BN_exp(a, a, p, ctx));
		bn_check(BN_div(i, f, n->number, a, ctx));
		BN_CTX_free(ctx);
		BN_free(a);
		BN_free(p);
	}
}

void
normalize(struct number *n, u_int s)
{
	scale_number(n->number, s - n->scale);
	n->scale = s;
}

static u_long
get_ulong(struct number *n)
{
	normalize(n, 0);
	return BN_get_word(n->number);
}

void
negate(struct number *n)
{
	BN_set_negative(n->number, !BN_is_negative(n->number));
}

static __inline void
push_number(struct number *n)
{
	stack_pushnumber(&bmachine.stack, n);
}

static __inline void
push_string(char *string)
{
	stack_pushstring(&bmachine.stack, string);
}

static __inline void
push(struct value *v)
{
	stack_push(&bmachine.stack, v);
}

static __inline struct value *
tos(void)
{
	return stack_tos(&bmachine.stack);
}

static __inline struct value *
pop(void)
{
	return stack_pop(&bmachine.stack);
}

static __inline struct number *
pop_number(void)
{
	return stack_popnumber(&bmachine.stack);
}

static __inline char *
pop_string(void)
{
	return stack_popstring(&bmachine.stack);
}

static __inline void
clear_stack(void)
{
	stack_clear(&bmachine.stack);
}

static __inline void
print_stack(void)
{
	stack_print(stdout, &bmachine.stack, "", bmachine.obase);
}

static __inline void
print_tos(void)
{
	struct value *value = tos();
	if (value != NULL) {
		print_value(stdout, value, "", bmachine.obase);
		(void)putchar('\n');
	}
	else
		warnx("stack empty");
}

static void
print_err(void)
{
	struct value *value = tos();
	if (value != NULL) {
		print_value(stderr, value, "", bmachine.obase);
		(void)putc('\n', stderr);
	}
	else
		warnx("stack empty");
}

static void
pop_print(void)
{
	struct value *value = pop();

	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			break;
		case BCODE_NUMBER:
			normalize(value->u.num, 0);
			print_ascii(stdout, value->u.num);
			(void)fflush(stdout);
			break;
		case BCODE_STRING:
			(void)fputs(value->u.string, stdout);
			(void)fflush(stdout);
			break;
		}
		stack_free_value(value);
	}
}

static void
pop_printn(void)
{
	struct value *value = pop();

	if (value != NULL) {
		print_value(stdout, value, "", bmachine.obase);
		(void)fflush(stdout);
		stack_free_value(value);
	}
}

static __inline void
dup(void)
{
	stack_dup(&bmachine.stack);
}

static void
swap(void)
{
	stack_swap(&bmachine.stack);
}

static void
drop(void)
{
	struct value *v = pop();
	if (v != NULL)
		stack_free_value(v);
}

static void
get_scale(void)
{
	struct number	*n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.scale));
	push_number(n);
}

static void
set_scale(void)
{
	struct number	*n;
	u_long		scale;

	n = pop_number();
	if (n != NULL) {
		if (BN_is_negative(n->number))
			warnx("scale must be a nonnegative number");
		else {
			scale = get_ulong(n);
			if (scale != BN_MASK2 && scale <= UINT_MAX)
				bmachine.scale = (u_int)scale;
			else
				warnx("scale too large");
			}
		free_number(n);
	}
}

static void
get_obase(void)
{
	struct number	*n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.obase));
	push_number(n);
}

static void
set_obase(void)
{
	struct number	*n;
	u_long		base;

	n = pop_number();
	if (n != NULL) {
		base = get_ulong(n);
		if (base != BN_MASK2 && base > 1 && base <= UINT_MAX)
			bmachine.obase = (u_int)base;
		else
			warnx("output base must be a number greater than 1");
		free_number(n);
	}
}

static void
get_ibase(void)
{
	struct number *n;

	n = new_number();
	bn_check(BN_set_word(n->number, bmachine.ibase));
	push_number(n);
}

static void
set_ibase(void)
{
	struct number	*n;
	u_long		base;

	n = pop_number();
	if (n != NULL) {
		base = get_ulong(n);
		if (base != BN_MASK2 && 2 <= base && base <= 16)
			bmachine.ibase = (u_int)base;
		else
			warnx("input base must be a number between 2 and 16 "
			    "(inclusive)");
		free_number(n);
	}
}

static void
stackdepth(void)
{
	size_t i;
	struct number *n;

	i = stack_size(&bmachine.stack);
	n = new_number();
	bn_check(BN_set_word(n->number, i));
	push_number(n);
}

static void
push_scale(void)
{
	struct value	*value;
	u_int		scale = 0;
	struct number	*n;


	value = pop();
	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			return;
		case BCODE_NUMBER:
			scale = value->u.num->scale;
			break;
		case BCODE_STRING:
			break;
		}
		stack_free_value(value);
		n = new_number();
		bn_check(BN_set_word(n->number, scale));
		push_number(n);
	}
}

static u_int
count_digits(const struct number *n)
{
	struct number	*int_part, *fract_part;
	u_int		i;

	if (BN_is_zero(n->number))
		return n->scale ? n->scale : 1;

	int_part = new_number();
	fract_part = new_number();
	fract_part->scale = n->scale;
	split_number(n, int_part->number, fract_part->number);

	i = 0;
	while (!BN_is_zero(int_part->number)) {
		(void)BN_div_word(int_part->number, 10);
		i++;
	}
	free_number(int_part);
	free_number(fract_part);
	return i + n->scale;
}

static void
num_digits(void)
{
	struct value	*value;
	size_t		digits;
	struct number	*n = NULL;

	value = pop();
	if (value != NULL) {
		switch (value->type) {
		case BCODE_NONE:
			return;
		case BCODE_NUMBER:
			digits = count_digits(value->u.num);
			n = new_number();
			bn_check(BN_set_word(n->number, digits));
			break;
		case BCODE_STRING:
			digits = strlen(value->u.string);
			n = new_number();
			bn_check(BN_set_word(n->number, digits));
			break;
		}
		stack_free_value(value);
		push_number(n);
	}
}

static void
to_ascii(void)
{
	char		str[2];
	struct value	*value;
	struct number	*n;

	value = pop();
	if (value != NULL) {
		str[1] = '\0';
		switch (value->type) {
		case BCODE_NONE:
			return;
		case BCODE_NUMBER:
			n = value->u.num;
			normalize(n, 0);
			if (BN_num_bits(n->number) > 8)
				bn_check(BN_mask_bits(n->number, 8));
			str[0] = (char)BN_get_word(n->number);
			break;
		case BCODE_STRING:
			str[0] = value->u.string[0];
			break;
		}
		stack_free_value(value);
		push_string(bstrdup(str));
	}
}

static int
readreg(void)
{
	int idx, ch1, ch2;

	idx = readch();
	if (idx == 0xff && bmachine.extended_regs) {
		ch1 = readch();
		ch2 = readch();
		if (ch1 == EOF || ch2 == EOF) {
			warnx("unexpected eof");
			idx = -1;
		} else
			idx = (ch1 << 8) + ch2 + UCHAR_MAX + 1;
	}
	if (idx < 0 || idx >= bmachine.reg_array_size) {
		warnx("internal error: reg num = %d", idx);
		idx = -1;
	}
	return idx;
}

static void
load(void)
{
	int		idx;
	struct value	*v, copy;
	struct number	*n;

	idx = readreg();
	if (idx >= 0) {
		v = stack_tos(&bmachine.reg[idx]);
		if (v == NULL) {
			n = new_number();
			bn_check(BN_set_word(n->number, 0));
			push_number(n);
		} else
			push(stack_dup_value(v, &copy));
	}
}

static void
store(void)
{
	int		idx;
	struct value	*val;

	idx = readreg();
	if (idx >= 0) {
		val = pop();
		if (val == NULL) {
			return;
		}
		stack_set_tos(&bmachine.reg[idx], val);
	}
}

static void
load_stack(void)
{
	int		idx;
	struct stack	*stack;
	struct value	*value;

	idx = readreg();
	if (idx >= 0) {
		stack = &bmachine.reg[idx];
		value = NULL;
		if (stack_size(stack) > 0) {
			value = stack_pop(stack);
		}
		if (value != NULL)
			push(value);
		else
			warnx("stack register '%c' (0%o) is empty",
			    idx, idx);
	}
}

static void
store_stack(void)
{
	int		idx;
	struct value	*value;

	idx = readreg();
	if (idx >= 0) {
		value = pop();
		if (value == NULL)
			return;
		stack_push(&bmachine.reg[idx], value);
	}
}

static void
load_array(void)
{
	int			reg;
	struct number		*inumber, *n;
	u_long			idx;
	struct stack		*stack;
	struct value		*v, copy;

	reg = readreg();
	if (reg >= 0) {
		inumber = pop_number();
		if (inumber == NULL)
			return;
		idx = get_ulong(inumber);
		if (BN_is_negative(inumber->number))
			warnx("negative idx");
		else if (idx == BN_MASK2 || idx > MAX_ARRAY_INDEX)
			warnx("idx too big");
		else {
			stack = &bmachine.reg[reg];
			v = frame_retrieve(stack, idx);
			if (v == NULL || v->type == BCODE_NONE) {
				n = new_number();
				bn_check(BN_set_word(n->number, 0));
				push_number(n);
			}
			else
				push(stack_dup_value(v, &copy));
		}
		free_number(inumber);
	}
}

static void
store_array(void)
{
	int			reg;
	struct number		*inumber;
	u_long			idx;
	struct value		*value;
	struct stack		*stack;

	reg = readreg();
	if (reg >= 0) {
		inumber = pop_number();
		if (inumber == NULL)
			return;
		value = pop();
		if (value == NULL) {
			free_number(inumber);
			return;
		}
		idx = get_ulong(inumber);
		if (BN_is_negative(inumber->number)) {
			warnx("negative idx");
			stack_free_value(value);
		} else if (idx == BN_MASK2 || idx > MAX_ARRAY_INDEX) {
			warnx("idx too big");
			stack_free_value(value);
		} else {
			stack = &bmachine.reg[reg];
			frame_assign(stack, idx, value);
		}
		free_number(inumber);
	}
}

static void
push_line(void)
{
	push_string(read_string(&bmachine.readstack[bmachine.readsp]));
}

static void
comment(void)
{
	free(readline());
}

static void
badd(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	r->scale = max(a->scale, b->scale);
	if (r->scale > a->scale)
		normalize(a, r->scale);
	else if (r->scale > b->scale)
		normalize(b, r->scale);
	bn_check(BN_add(r->number, a->number, b->number));
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bsub(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();

	r->scale = max(a->scale, b->scale);
	if (r->scale > a->scale)
		normalize(a, r->scale);
	else if (r->scale > b->scale)
		normalize(b, r->scale);
	bn_check(BN_sub(r->number, b->number, a->number));
	push_number(r);
	free_number(a);
	free_number(b);
}

void
bmul_number(struct number *r, struct number *a, struct number *b, u_int scale)
{
	BN_CTX		*ctx;

	/* Create copies of the scales, since r might be equal to a or b */
	u_int ascale = a->scale;
	u_int bscale = b->scale;
	u_int rscale = ascale + bscale;

	ctx = BN_CTX_new();
	bn_checkp(ctx);
	bn_check(BN_mul(r->number, a->number, b->number, ctx));
	BN_CTX_free(ctx);

	r->scale = rscale;
	if (rscale > bmachine.scale && rscale > ascale && rscale > bscale)
		normalize(r, max(scale, max(ascale, bscale)));
}

static void
bmul(void)
{
	struct number	*a, *b;
	struct number	*r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	bmul_number(r, a, b, bmachine.scale);

	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bdiv(void)
{
	struct number	*a, *b;
	struct number	*r;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	r->scale = bmachine.scale;
	scale = max(a->scale, b->scale);

	if (BN_is_zero(a->number))
		warnx("divide by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + r->scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_div(r->number, NULL, b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bmod(void)
{
	struct number	*a, *b;
	struct number	*r;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	r = new_number();
	scale = max(a->scale, b->scale);
	r->scale = max(b->scale, a->scale + bmachine.scale);

	if (BN_is_zero(a->number))
		warnx("remainder by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + bmachine.scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_mod(r->number, b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(r);
	free_number(a);
	free_number(b);
}

static void
bdivmod(void)
{
	struct number	*a, *b;
	struct number	*rdiv, *rmod;
	u_int		scale;
	BN_CTX		*ctx;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	rdiv = new_number();
	rmod = new_number();
	rdiv->scale = bmachine.scale;
	rmod->scale = max(b->scale, a->scale + bmachine.scale);
	scale = max(a->scale, b->scale);

	if (BN_is_zero(a->number))
		warnx("divide by zero");
	else {
		normalize(a, scale);
		normalize(b, scale + bmachine.scale);

		ctx = BN_CTX_new();
		bn_checkp(ctx);
		bn_check(BN_div(rdiv->number, rmod->number,
		    b->number, a->number, ctx));
		BN_CTX_free(ctx);
	}
	push_number(rdiv);
	push_number(rmod);
	free_number(a);
	free_number(b);
}

static void
bexp(void)
{
	struct number	*a, *p;
	struct number	*r;
	bool		neg;
	u_int		rscale;

	p = pop_number();
	if (p == NULL)
		return;
	a = pop_number();
	if (a == NULL) {
		push_number(p);
		return;
	}

	if (p->scale != 0) {
		BIGNUM *i, *f;
		i = BN_new();
		bn_checkp(i);
		f = BN_new();
		bn_checkp(f);
		split_number(p, i, f);
		if (!BN_is_zero(f))
			warnx("Runtime warning: non-zero fractional part in exponent");
		BN_free(i);
		BN_free(f);
	}

	normalize(p, 0);

	neg = false;
	if (BN_is_negative(p->number)) {
		neg = true;
		negate(p);
		rscale = bmachine.scale;
	} else {
		/* Posix bc says min(a.scale * b, max(a.scale, scale) */
		u_long	b;
		u_int	m;

		b = BN_get_word(p->number);
		m = max(a->scale, bmachine.scale);
		rscale = a->scale * (u_int)b;
		if (rscale > m || (a->scale > 0 && (b == BN_MASK2 ||
		    b > UINT_MAX)))
			rscale = m;
	}

	if (BN_is_zero(p->number)) {
		r = new_number();
		bn_check(BN_one(r->number));
		normalize(r, rscale);
	} else {
		u_int ascale, mscale;

		ascale = a->scale;
		while (!BN_is_bit_set(p->number, 0)) {
			ascale *= 2;
			bmul_number(a, a, a, ascale);
			bn_check(BN_rshift1(p->number, p->number));
		}

		r = dup_number(a);
		bn_check(BN_rshift1(p->number, p->number));

		mscale = ascale;
		while (!BN_is_zero(p->number)) {
			ascale *= 2;
			bmul_number(a, a, a, ascale);
			if (BN_is_bit_set(p->number, 0)) {
				mscale += ascale;
				bmul_number(r, r, a, mscale);
			}
			bn_check(BN_rshift1(p->number, p->number));
		}

		if (neg) {
			BN_CTX	*ctx;
			BIGNUM	*one;

			one = BN_new();
			bn_checkp(one);
			bn_check(BN_one(one));
			ctx = BN_CTX_new();
			bn_checkp(ctx);
			scale_number(one, r->scale + rscale);

			if (BN_is_zero(r->number))
				warnx("divide by zero");
			else
				bn_check(BN_div(r->number, NULL, one,
				    r->number, ctx));
			BN_free(one);
			BN_CTX_free(ctx);
			r->scale = rscale;
		} else
			normalize(r, rscale);
	}
	push_number(r);
	free_number(a);
	free_number(p);
}

static bool
bsqrt_stop(const BIGNUM *x, const BIGNUM *y, u_int *onecount)
{
	BIGNUM *r;
	bool ret;

	r = BN_new();
	bn_checkp(r);
	bn_check(BN_sub(r, x, y));
	if (BN_is_one(r))
		(*onecount)++;
	ret = BN_is_zero(r);
	BN_free(r);
	return ret || *onecount > 1;
}

static void
bsqrt(void)
{
	struct number	*n;
	struct number	*r;
	BIGNUM		*x, *y;
	u_int		scale, onecount;
	BN_CTX		*ctx;

	onecount = 0;
	n = pop_number();
	if (n == NULL)
		return;
	if (BN_is_zero(n->number)) {
		r = new_number();
		push_number(r);
	} else if (BN_is_negative(n->number))
		warnx("square root of negative number");
	else {
		scale = max(bmachine.scale, n->scale);
		normalize(n, 2*scale);
		x = BN_dup(n->number);
		bn_checkp(x);
		bn_check(BN_rshift(x, x, BN_num_bits(x)/2));
		y = BN_new();
		bn_checkp(y);
		ctx = BN_CTX_new();
		bn_checkp(ctx);
		for (;;) {
			bn_checkp(BN_copy(y, x));
			bn_check(BN_div(x, NULL, n->number, x, ctx));
			bn_check(BN_add(x, x, y));
			bn_check(BN_rshift1(x, x));
			if (bsqrt_stop(x, y, &onecount))
				break;
		}
		r = bmalloc(sizeof(*r));
		r->scale = scale;
		r->number = y;
		BN_free(x);
		BN_CTX_free(ctx);
		push_number(r);
	}

	free_number(n);
}

static void
not(void)
{
	struct number	*a;

	a = pop_number();
	if (a == NULL)
		return;
	a->scale = 0;
	bn_check(BN_set_word(a->number, BN_get_word(a->number) ? 0 : 1));
	push_number(a);
}

static void
equal(void)
{
	compare(BCODE_EQUAL);
}

static void
equal_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_EQUAL, a, b) ? 1 : 0));
	push_number(r);
}

static void
less_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_LESS, a, b) ? 1 : 0));
	push_number(r);
}

static void
lesseq_numbers(void)
{
	struct number *a, *b, *r;

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}
	r = new_number();
	bn_check(BN_set_word(r->number,
	    compare_numbers(BCODE_NOT_GREATER, a, b) ? 1 : 0));
	push_number(r);
}

static void
not_equal(void)
{
	compare(BCODE_NOT_EQUAL);
}

static void
less(void)
{
	compare(BCODE_LESS);
}

static void
not_compare(void)
{
	switch (readch()) {
	case '<':
		not_less();
		break;
	case '>':
		not_greater();
		break;
	case '=':
		not_equal();
		break;
	default:
		unreadch();
		(void)fprintf(stderr, "! command is deprecated\n");
		break;
	}
}

static void
not_less(void)
{
	compare(BCODE_NOT_LESS);
}

static void
greater(void)
{
	compare(BCODE_GREATER);
}

static void
not_greater(void)
{
	compare(BCODE_NOT_GREATER);
}

static bool
compare_numbers(enum bcode_compare type, struct number *a, struct number *b)
{
	u_int	scale;
	int	cmp;

	scale = max(a->scale, b->scale);

	if (scale > a->scale)
		normalize(a, scale);
	else if (scale > b->scale)
		normalize(b, scale);

	cmp = BN_cmp(a->number, b->number);

	free_number(a);
	free_number(b);

	switch (type) {
	case BCODE_EQUAL:
		return cmp == 0;
	case BCODE_NOT_EQUAL:
		return cmp != 0;
	case BCODE_LESS:
		return cmp < 0;
	case BCODE_NOT_LESS:
		return cmp >= 0;
	case BCODE_GREATER:
		return cmp > 0;
	case BCODE_NOT_GREATER:
		return cmp <= 0;
	}
	return false;
}

static void
compare(enum bcode_compare type)
{
	int		idx, elseidx;
	struct number	*a, *b;
	bool		ok;
	struct value	*v;

	elseidx = NO_ELSE;
	idx = readreg();
	if (readch() == 'e')
		elseidx = readreg();
	else
		unreadch();

	a = pop_number();
	if (a == NULL)
		return;
	b = pop_number();
	if (b == NULL) {
		push_number(a);
		return;
	}

	ok = compare_numbers(type, a, b);

	if (!ok && elseidx != NO_ELSE)
		idx = elseidx;

	if (idx >= 0 && (ok || (!ok && elseidx != NO_ELSE))) {
		v = stack_tos(&bmachine.reg[idx]);
		if (v == NULL)
			warnx("register '%c' (0%o) is empty", idx, idx);
		else {
			switch(v->type) {
			case BCODE_NONE:
				warnx("register '%c' (0%o) is empty", idx, idx);
				break;
			case BCODE_NUMBER:
				warn("eval called with non-string argument");
				break;
			case BCODE_STRING:
				eval_string(bstrdup(v->u.string));
				break;
			}
		}
	}
}


static void
nop(void)
{
}

static void
quit(void)
{
	if (bmachine.readsp < 2)
		exit(0);
	src_free();
	bmachine.readsp--;
	src_free();
	bmachine.readsp--;
}

static void
quitN(void)
{
	struct number	*n;
	u_long		i;

	n = pop_number();
	if (n == NULL)
		return;
	i = get_ulong(n);
	free_number(n);
	if (i == BN_MASK2 || i == 0)
		warnx("Q command requires a number >= 1");
	else if (bmachine.readsp < i)
		warnx("Q command argument exceeded string execution depth");
	else {
		while (i-- > 0) {
			src_free();
			bmachine.readsp--;
		}
	}
}

static void
skipN(void)
{
	struct number	*n;
	u_long		i;

	n = pop_number();
	if (n == NULL)
		return;
	i = get_ulong(n);
	if (i == BN_MASK2)
		warnx("J command requires a number >= 0");
	else if (i > 0 && bmachine.readsp < i)
		warnx("J command argument exceeded string execution depth");
	else {
		while (i-- > 0) {
			src_free();
			bmachine.readsp--;
		}
		skip_until_mark();
	}
}

static void
skip_until_mark(void)
{
	int ch;

	for (;;) {
		ch = readch();
		switch (ch) {
		case 'M':
			return;
		case EOF:
			errx(1, "mark not found");
			return;
		case 'l':
		case 'L':
		case 's':
		case 'S':
		case ':':
		case ';':
		case '<':
		case '>':
		case '=':
			(void)readreg();
			if (readch() == 'e')
				(void)readreg();
			else
				unreadch();
			break;
		case '[':
			free(read_string(&bmachine.readstack[bmachine.readsp]));
			break;
		case '!':
			switch (ch = readch()) {
				case '<':
				case '>':
				case '=':
					(void)readreg();
					if (readch() == 'e')
						(void)readreg();
					else
						unreadch();
					break;
				default:
					free(readline());
					break;
			}
			break;
		default:
			break;
		}
	}
}

static void
parse_number(void)
{
	unreadch();
	push_number(readnumber(&bmachine.readstack[bmachine.readsp],
	    bmachine.ibase));
}

static void
unknown(void)
{
	int ch = bmachine.readstack[bmachine.readsp].lastchar;
	warnx("%c (0%o) is unimplemented", ch, ch);
}

static void
eval_string(char *p)
{
	int ch;

	if (bmachine.readsp > 0) {
		/* Check for tail call. Do not recurse in that case. */
		ch = readch();
		if (ch == EOF) {
			src_free();
			src_setstring(&bmachine.readstack[bmachine.readsp], p);
			return;
		} else
			unreadch();
	}
	if (bmachine.readsp == bmachine.readstack_sz - 1) {
		size_t newsz = bmachine.readstack_sz * 2;
		struct source *stack;
		stack = reallocarray(bmachine.readstack, newsz,
		    sizeof(struct source));
		if (stack == NULL)
			err(1, "recursion too deep");
		bmachine.readstack_sz = newsz;
		bmachine.readstack = stack;
	}
	src_setstring(&bmachine.readstack[++bmachine.readsp], p);
}

static void
eval_line(void)
{
	/* Always read from stdin */
	struct source	in;
	char		*p;

	clearerr(stdin);
	src_setstream(&in, stdin);
	p = (*in.vtable->readline)(&in);
	eval_string(p);
}

static void
eval_tos(void)
{
	char *p;

	p = pop_string();
	if (p != NULL)
		eval_string(p);
}

void
eval(void)
{
	int	ch;

	for (;;) {
		ch = readch();
		if (ch == EOF) {
			if (bmachine.readsp == 0)
				return;
			src_free();
			bmachine.readsp--;
			continue;
		}
		if (bmachine.interrupted) {
			if (bmachine.readsp > 0) {
				src_free();
				bmachine.readsp--;
				continue;
			} else
				bmachine.interrupted = false;
		}
#ifdef DEBUGGING
		(void)fprintf(stderr, "# %c\n", ch);
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		(void)fprintf(stderr, "%zd =>\n", bmachine.readsp);
#endif

		if (0 <= ch && ch < UCHAR_MAX)
			(*jump_table[ch])();
		else
			warnx("internal error: opcode %d", ch);

#ifdef DEBUGGING
		stack_print(stderr, &bmachine.stack, "* ",
		    bmachine.obase);
		(void)fprintf(stderr, "%zd ==\n", bmachine.readsp);
#endif
	}
}
@


1.50
log
@Introduce e command, equivalent to p, but writes to stderr
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.49 2016/03/27 15:55:13 otto Exp $	*/
d389 1
a389 1
		bn_check(BN_zero(f));
d807 1
a807 1
			bn_check(BN_zero(n->number));
d891 1
a891 1
				bn_check(BN_zero(n->number));
@


1.49
log
@some style(9) and redundant tests for NULL, from Michael W. Bombardieri
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.48 2015/10/03 16:24:53 otto Exp $	*/
d70 1
d199 1
d496 12
@


1.48
log
@disable ! command, makes dc(1) more tameable
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.47 2015/02/16 20:53:34 jca Exp $	*/
d940 1
a940 1
	if (a == NULL) {
a941 1
	}
d967 1
a967 1
	if (a == NULL) {
a968 1
	}
d1015 1
a1015 1
	if (a == NULL) {
a1016 1
	}
d1040 1
a1040 1
	if (a == NULL) {
a1041 1
	}
d1077 1
a1077 1
	if (a == NULL) {
a1078 1
	}
d1114 1
a1114 1
	if (a == NULL) {
a1115 1
	}
d1155 1
a1155 1
	if (p == NULL) {
a1156 1
	}
d1278 1
a1278 1
	if (n == NULL) {
a1279 1
	}
d1320 1
a1320 1
	if (a == NULL) {
a1321 1
	}
d1339 1
a1339 1
	if (a == NULL) {
a1340 1
	}
d1358 1
a1358 1
	if (a == NULL) {
a1359 1
	}
d1377 1
a1377 1
	if (a == NULL) {
a1378 1
	}
d1702 2
a1703 3
	if (p == NULL)
		return;
	eval_string(p);
@


1.47
log
@Include bn.h and err.h from <openssl/...>, not the old <ssl/...> location.

Remove unneeded ssl.h includes.  Also built-checked against openssl-1.0.1e.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.46 2014/10/08 03:59:56 doug Exp $	*/
a89 1
static void		bexec(char *);
a933 7
bexec(char *line)
{
	(void)system(line);
	free(line);
}

static void
d1429 1
a1429 1
		bexec(readline());
@


1.46
log
@userland reallocarray audit.

Replace malloc() and realloc() calls that may have integer overflow in the
multiplication of the arguments with reallocarray().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.45 2012/11/07 11:06:14 otto Exp $	*/
a18 1
#include <ssl/ssl.h>
@


1.45
log
@fix fractional number exponentiation, especially for negative exponents
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.44 2012/11/06 16:00:05 otto Exp $	*/
d1694 1
a1694 1
		stack = realloc(bmachine.readstack, newsz *
@


1.44
log
@use BN_set_negative() and BN_is_negative() instead of subtracting or
comparing to zero
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.43 2012/11/06 15:46:46 otto Exp $	*/
d260 6
d1000 1
a1000 1
bmul_number(struct number *r, struct number *a, struct number *b)
d1014 3
a1016 5
	if (rscale > bmachine.scale && rscale > ascale && rscale > bscale) {
		r->scale = rscale;
		normalize(r, max(bmachine.scale, max(ascale, bscale)));
	} else
		r->scale = rscale;
d1036 1
a1036 1
	bmul_number(r, a, b);
d1167 1
a1167 1
	u_int		scale;
d1198 1
a1198 1
		scale = bmachine.scale;
d1206 2
a1207 2
		scale = a->scale * (u_int)b;
		if (scale > m || (a->scale > 0 && (b == BN_MASK2 ||
d1209 1
a1209 1
			scale = m;
d1215 1
a1215 1
		normalize(r, scale);
d1217 3
d1221 2
a1222 1
			bmul_number(a, a, a);
a1226 1
		normalize(r, scale);
d1229 1
d1231 6
a1236 3
			bmul_number(a, a, a);
			if (BN_is_bit_set(p->number, 0))
				bmul_number(r, r, a);
d1249 1
a1249 2
			scale_number(one, r->scale + scale);
			normalize(r, scale);
d1258 1
d1260 1
a1260 1
			normalize(r, scale);
@


1.43
log
@For exponenttion, only warn if the fractional part of the exponent
is non-zero and avoid div by zero. Prompted by Andres Perera.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.42 2012/03/08 08:15:37 otto Exp $	*/
a28 2
BIGNUM		zero;

a256 2
	BN_init(&zero);
	bn_check(BN_zero(&zero));
d426 1
a426 1
	bn_check(BN_sub(n->number, &zero, n->number));
d568 1
a568 1
		if (BN_cmp(n->number, &zero) < 0)
d864 1
a864 1
		if (BN_cmp(inumber->number, &zero) < 0)
d903 1
a903 1
		if (BN_cmp(inumber->number, &zero) < 0) {
d1289 1
a1289 1
	} else if (BN_cmp(n->number, &zero) < 0)
@


1.42
log
@let length(0.000) conform to what gnu bc does; from AIDA Shinra
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.41 2010/05/15 10:59:29 otto Exp $	*/
d1179 13
a1191 2
	if (p->scale != 0)
		warnx("Runtime warning: non-zero scale in exponent");
d1195 1
a1195 1
	if (BN_cmp(p->number, &zero) < 0) {
d1244 6
a1249 1
			bn_check(BN_div(r->number, NULL, one, r->number, ctx));
@


1.41
log
@normalize() cannot be inline and extern at the same time; prompted by
jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.40 2009/10/27 23:59:37 deraadt Exp $	*/
d685 1
a685 1
		return 1;
@


1.40
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.39 2009/09/06 13:33:33 otto Exp $	*/
d413 1
a413 1
__inline void
@


1.39
log
@check for unitialized elements when accessing an array; from Simon Kellner.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.38 2008/11/24 08:48:48 otto Exp $	*/
a17 4

#ifndef lint
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.38 2008/11/24 08:48:48 otto Exp $";
#endif /* not lint */
@


1.38
log
@although there's no EOF condition defined for the handling of '?',
but anyway reset the eof condition on stdin, so you don't get an
infinite loop in the typical program after a ^D.
reported by Tamas TEVESZ.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.37 2008/04/28 06:35:09 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.37 2008/04/28 06:35:09 otto Exp $";
d879 1
a879 1
			if (v == NULL) {
@


1.37
log
@plug three leaks, one reported and fixed by Andreas Gunnarsson in PR 5802,
the others by myself
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.36 2008/04/26 20:13:22 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.36 2008/04/26 20:13:22 otto Exp $";
d1692 1
@


1.36
log
@use correct printf format for size_t (debug only code)
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.35 2007/09/02 23:50:04 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.35 2007/09/02 23:50:04 deraadt Exp $";
d825 1
a825 1
	struct value	*value, copy;
d835 1
a835 1
			push(stack_dup_value(value, &copy));
d1553 1
@


1.35
log
@more malloc(n * m) -> calloc(n, m); from Igor Zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.34 2006/01/19 20:06:55 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.34 2006/01/19 20:06:55 otto Exp $";
d1733 1
a1733 1
		(void)fprintf(stderr, "%d =>\n", bmachine.readsp);
d1744 1
a1744 1
		(void)fprintf(stderr, "%d ==\n", bmachine.readsp);
@


1.34
log
@delint: check value against UINT_MAX before casting to u_int; while
there fix a buglet in bexp(): x * UINT_MAX only overflows if x > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.33 2006/01/16 08:09:25 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.33 2006/01/16 08:09:25 otto Exp $";
d242 1
a242 1
	bmachine.reg = malloc(bmachine.reg_array_size *
d258 1
a258 1
	bmachine.readstack = malloc(sizeof(struct source) *
@


1.33
log
@delint; use size_t as stack size and ssize_t as stack pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.32 2006/01/15 19:14:40 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.32 2006/01/15 19:14:40 otto Exp $";
d580 2
a581 2
			if (scale != BN_MASK2)
				bmachine.scale = scale;
d608 2
a609 2
		if (base != BN_MASK2 && base > 1)
			bmachine.obase = base;
d636 1
a636 1
			bmachine.ibase = base;
d710 1
a710 1
	u_int		digits;
d1199 3
a1201 2
		scale = a->scale * b;
		if (scale > m || b == BN_MASK2)
@


1.32
log
@delint; index is a global symbol, so rename some locals to avoid
hiding
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.31 2006/01/15 19:11:59 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.31 2006/01/15 19:11:59 otto Exp $";
d647 1
a647 1
	u_int i;
d752 1
a752 1
			str[0] = BN_get_word(n->number);
@


1.31
log
@delint wrt return values, including some missing BN return
values checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.30 2005/09/25 19:02:38 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.30 2005/09/25 19:02:38 otto Exp $";
d766 1
a766 1
	int index, ch1, ch2;
d768 2
a769 2
	index = readch();
	if (index == 0xff && bmachine.extended_regs) {
d774 1
a774 1
			index = -1;
d776 1
a776 1
			index = (ch1 << 8) + ch2 + UCHAR_MAX + 1;
d778 3
a780 3
	if (index < 0 || index >= bmachine.reg_array_size) {
		warnx("internal error: reg num = %d", index);
		index = -1;
d782 1
a782 1
	return index;
d788 1
a788 1
	int		index;
d792 3
a794 3
	index = readreg();
	if (index >= 0) {
		v = stack_tos(&bmachine.reg[index]);
d807 1
a807 1
	int		index;
d810 2
a811 2
	index = readreg();
	if (index >= 0) {
d816 1
a816 1
		stack_set_tos(&bmachine.reg[index], val);
d823 1
a823 1
	int		index;
d827 3
a829 3
	index = readreg();
	if (index >= 0) {
		stack = &bmachine.reg[index];
d838 1
a838 1
			    index, index);
d845 1
a845 1
	int		index;
d848 2
a849 2
	index = readreg();
	if (index >= 0) {
d853 1
a853 1
		stack_push(&bmachine.reg[index], value);
d862 1
a862 1
	u_long			index;
d871 1
a871 1
		index = get_ulong(inumber);
d873 3
a875 3
			warnx("negative index");
		else if (index == BN_MASK2 || index > MAX_ARRAY_INDEX)
			warnx("index too big");
d878 1
a878 1
			v = frame_retrieve(stack, index);
d896 1
a896 1
	u_long			index;
d910 1
a910 1
		index = get_ulong(inumber);
d912 1
a912 1
			warnx("negative index");
d914 2
a915 2
		} else if (index == BN_MASK2 || index > MAX_ARRAY_INDEX) {
			warnx("index too big");
d919 1
a919 1
			frame_assign(stack, index, value);
d1479 1
a1479 1
	int		index, elseindex;
d1484 2
a1485 2
	elseindex = NO_ELSE;
	index = readreg();
d1487 1
a1487 1
		elseindex = readreg();
d1502 2
a1503 2
	if (!ok && elseindex != NO_ELSE)
		index = elseindex;
d1505 2
a1506 2
	if (index >= 0 && (ok || (!ok && elseindex != NO_ELSE))) {
		v = stack_tos(&bmachine.reg[index]);
d1508 1
a1508 1
			warnx("register '%c' (0%o) is empty", index, index);
d1512 1
a1512 2
				warnx("register '%c' (0%o) is empty",
				    index, index);
@


1.30
log
@Fix wrong normalization in compare. From andreas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.29 2005/04/02 18:05:04 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.29 2005/04/02 18:05:04 otto Exp $";
d62 1
a62 1
static __inline int	unreadch(void);
d265 1
a265 1
	signal(SIGINT, sighandler);
d284 1
a284 1
static __inline int
d289 1
a289 1
	return src->vtable->unreadchar(src);
d315 2
a316 2
	fputs(str, stderr);
	fprintf(stderr, " %s (%u)\n" , p, n->scale);
d326 2
a327 2
	fputs(str, stderr);
	fprintf(stderr, " %s\n", p);
d358 1
a358 1
			BN_div_word(n, factors[abs_scale]);
d391 1
a391 1
		BN_zero(f);
d395 1
a395 1
			BN_set_word(f, rem);
d497 1
a497 1
		putchar('\n');
d515 1
a515 1
			fflush(stdout);
d518 2
a519 2
			fputs(value->u.string, stdout);
			fflush(stdout);
d533 1
a533 1
		fflush(stdout);
d698 1
a698 1
		BN_div_word(int_part->number, 10);
d940 1
a940 1
	system(line);
d1231 1
a1231 1
			BN_one(one);
d1610 1
a1610 1
			readreg();
d1612 1
a1612 1
				readreg();
d1624 1
a1624 1
					readreg();
d1626 1
a1626 1
						readreg();
d1730 1
a1730 1
		fprintf(stderr, "# %c\n", ch);
d1733 1
a1733 1
		fprintf(stderr, "%d =>\n", bmachine.readsp);
d1744 1
a1744 1
		fprintf(stderr, "%d ==\n", bmachine.readsp);
@


1.29
log
@- Fix raise for negative exponents (noted by naddy@@)
- Fix wrong scale for mantissa < 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.28 2005/03/28 17:39:20 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.28 2005/03/28 17:39:20 deraadt Exp $";
d1451 1
a1451 1
	else if (scale > scale)
@


1.28
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.27 2005/03/27 17:50:55 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.27 2005/03/27 17:50:55 otto Exp $";
d1193 1
a1193 1
		/* Posix bc says min(a.scale *b, max(a.scale, scale) */
d1234 2
a1235 2
			r->scale = scale;
			scale_number(one, r->scale);
d1239 2
a1240 1
		}
@


1.27
log
@Make call stack auto-growing, instead of fixed size. Enables much deeper
recursion.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.26 2004/12/01 08:40:12 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.26 2004/12/01 08:40:12 otto Exp $";
d310 1
a310 1
pn(const char * str, const struct number *n)
d321 1
a321 1
pbn(const char * str, const BIGNUM *n)
d1193 1
a1193 1
		/* Posix bc says min(a.scale * b, max(a.scale, scale) */
@


1.26
log
@use volatile sig_atomic_t for vars set in signal handlers. spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.25 2004/12/01 08:29:38 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.25 2004/12/01 08:29:38 otto Exp $";
d38 1
a38 1
#define RECURSION_STACK_SIZE	100
d49 1
a49 1
	int			readsp;
d54 2
a55 1
	struct source		readstack[RECURSION_STACK_SIZE];
d257 5
d1670 10
a1679 2
	if (bmachine.readsp == RECURSION_STACK_SIZE-1)
		errx(1, "recursion too deep");
@


1.25
log
@Fix stop condition for sqrt. Due to the fact that we're doing Newton
iteration with intgeres, the stop condition is reached if x_n == x_n+1, or
the difference is one, but only stop if that is hit a second time. Avoids
looping with difference 1,-1,1,-1... Problem spotted by Paul de Weerd.
Regress tested against 4.2BSD dc(1) and GNU dc(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.24 2004/10/18 07:49:00 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.24 2004/10/18 07:49:00 otto Exp $";
d53 1
a53 1
	volatile bool		interrupted;
@


1.24
log
@Implement command line evaluation of expressions by implementing the -e option.
ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.23 2004/09/14 22:22:46 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.23 2004/09/14 22:22:46 deraadt Exp $";
d104 1
a104 1
static bool		bsqrt_stop(const BIGNUM *, const BIGNUM *);
d1241 1
a1241 1
bsqrt_stop(const BIGNUM *x, const BIGNUM *y)
d1249 3
a1251 1
	ret = BN_is_one(r) || BN_is_zero(r);
d1253 1
a1253 1
	return ret;
d1262 1
a1262 1
	u_int		scale;
d1265 1
d1290 1
a1290 1
			if (bsqrt_stop(x, y))
@


1.23
log
@ARGSUSED before signal handler with unused signo
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.22 2004/02/11 20:44:31 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.22 2004/02/11 20:44:31 otto Exp $";
d1698 1
a1698 1
				exit(0);
@


1.22
log
@Make flag set in signal handler volatile
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.21 2004/01/20 21:41:20 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.21 2004/01/20 21:41:20 deraadt Exp $";
d225 1
@


1.21
log
@duplicated entry; evarts@@amazon.com
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.20 2003/12/19 19:23:16 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.20 2003/12/19 19:23:16 otto Exp $";
d53 1
a53 1
	bool			interrupted;
d1707 1
a1707 1
			} else {
a1708 1
			}
@


1.20
log
@Do something sensible on ^C: unwind stack and be ready for new input.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.19 2003/12/02 13:43:02 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.19 2003/12/02 13:43:02 otto Exp $";
a210 1
	{ 'p',	print_tos	},
@


1.19
log
@Fix a max recursion off-by-one.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.18 2003/12/01 09:13:24 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.18 2003/12/01 09:13:24 otto Exp $";
d26 1
d53 1
d58 1
d226 6
d259 1
d1702 9
@


1.18
log
@Allow for more registers using a 2 byte index. This feature is
enabled by supplying the -x option on the command line. Allows long
variable names in bc(1) (to appear soon). If no -x option is given,
behave exactly as before.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.17 2003/11/17 11:12:35 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.17 2003/11/17 11:12:35 otto Exp $";
d37 1
a37 1
#define MAX_RECURSION		100
d52 1
a52 1
	struct source		readstack[MAX_RECURSION];
d1651 1
a1651 1
	if (bmachine.readsp == MAX_RECURSION)
@


1.17
log
@A basic stack operation that is missing from the original dc (and
GNU dc as well): drop ('R').
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.16 2003/11/14 20:25:16 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.16 2003/11/14 20:25:16 otto Exp $";
d40 2
d49 3
a51 1
	struct stack		reg[UCHAR_MAX];
d75 1
a75 1
static __inline void	print_stack();
d117 1
d224 1
a224 1
init_bmachine(void)
d228 9
d244 1
a244 1
	for (i = 0; i < UCHAR_MAX; i++)
d747 22
d776 2
a777 2
	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
d785 1
a785 2
	} else
		warnx("internal error: reg num = %d", index);
d794 2
a795 2
	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
d801 1
a801 2
	} else
		warnx("internal error: reg num = %d", index);
d811 2
a812 2
	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
d823 1
a823 2
	} else
		warnx("internal error: reg num = %d", index);
d832 2
a833 2
	index = readch();
	if (0 <= index && index < UCHAR_MAX) {
d838 1
a838 2
	} else
		warnx("internal error: reg num = %d", index);
d850 2
a851 2
	reg = readch();
	if (0 <= reg && reg < UCHAR_MAX) {
d872 1
a872 2
	} else
		warnx("internal error: reg num = %d", reg);
d884 2
a885 2
	reg = readch();
	if (0 <= reg && reg < UCHAR_MAX) {
d906 1
a906 2
	} else
		warnx("internal error: reg num = %d", reg);
d1465 1
a1465 1
	index = readch();
d1467 1
a1467 1
		elseindex = readch();
d1485 1
a1485 3
	if (index < 0 || index > UCHAR_MAX)
		warnx("internal error: reg num = %d", index);
	else if (ok || (!ok && elseindex != NO_ELSE)) {
d1590 1
a1590 1
			readch();
d1592 1
a1592 1
				readch();
d1604 1
a1604 1
					readch();
d1606 1
a1606 1
						readch();
@


1.16
log
@Implement new boolean operations 'N' (not), 'G' (equals), '(' (less)
and '{' (less or equal). These operations push their result back
to the stack. Used by soon to appear boolean operations in bc(1).

man page tweaks and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.15 2003/11/09 20:33:09 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.15 2003/11/09 20:33:09 otto Exp $";
d74 1
d183 1
d518 8
@


1.15
log
@Flush after 'n' operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.14 2003/11/06 19:48:13 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.14 2003/11/06 19:48:13 otto Exp $";
d98 4
d109 2
d144 1
d172 1
d178 1
a179 3
	{ 'd',	dup		},
	{ 'r',	swap		},
	{ 'p',	print_tos	},
d202 1
d204 1
d209 1
d1252 14
d1272 60
d1381 35
a1420 2
	u_int		scale;
	int		cmp;
d1440 1
a1440 32
	scale = max(a->scale, b->scale);
	if (scale > a->scale)
		normalize(a, scale);
	else if (scale > scale)
		normalize(b, scale);

	cmp = BN_cmp(a->number, b->number);

	free_number(a);
	free_number(b);

	ok = false;
	switch (type) {
	case BCODE_EQUAL:
		ok = cmp == 0;
		break;
	case BCODE_NOT_EQUAL:
		ok = cmp != 0;
		break;
	case BCODE_LESS:
		ok = cmp < 0;
		break;
	case BCODE_NOT_LESS:
		ok = cmp >= 0;
		break;
	case BCODE_GREATER:
		ok = cmp > 0;
		break;
	case BCODE_NOT_GREATER:
		ok = cmp <= 0;
		break;
	}
@


1.14
log
@Implement non-portable extension # (comment), n (print w/o newline),
and a (byte to char).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.13 2003/11/04 08:10:06 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.13 2003/11/04 08:10:06 otto Exp $";
d492 1
@


1.13
log
@Duh, a stack machine without swap; implement GNU compatible 'r'
(swap) operator. Prompted by Michael Knudsen <e at molioner dot dk>
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.12 2003/10/22 14:58:32 otto Exp $";
d69 2
a70 1
static __inline void	pop_print(void);
d85 1
a85 1

d87 1
d134 9
d153 6
d165 3
a167 12
	{ '_',	parse_number	},
	{ '.',	parse_number	},
	{ '+',	badd		},
	{ '-',	bsub		},
	{ '*',	bmul		},
	{ '/',	bdiv		},
	{ '%',	bmod		},
	{ '~',	bdivmod		},
	{ '^',	bexp		},
	{ 's',	store		},
	{ 'S',	store_stack	},
	{ 'l',	load		},
d169 2
d175 2
a176 2
	{ 'f',	print_stack	},
	{ 'x',	eval_tos	},
d178 1
d180 7
a186 9
	{ 'q',	quit		},
	{ 'Q',	quitN		},
	{ 'J',	skipN		},
	{ 'M',	nop		},
	{ '<',	less		},
	{ '>',	greater		},
	{ '=',	equal		},
	{ '!',	not_compare	},
	{ 'v',	bsqrt		},
d188 2
d191 3
a193 1
	{ 'I',	get_ibase	},
d195 5
a199 3
	{ 'O',	get_obase	},
	{ 'k',	set_scale	},
	{ 'K',	get_scale	},
d201 1
a201 9
	{ 'Z',	num_digits	},
	{ '?',	eval_line	},
	{ ';',	load_array	},
	{ ':',	store_array	},
	{ ' ',	nop		},
	{ '\t',	nop		},
	{ '\n',	nop		},
	{ '\f',	nop		},
	{ '\r',	nop		}
d462 1
a462 1
static __inline void
d466 1
d485 11
d661 1
a661 1
	struct number	*n;
d667 1
a667 1
			break;
a671 3
			/* free first, then reassign */
			BN_free(value->u.num->number);
			push_number(n);
a676 3
			/* free first, then reassign */
			free(value->u.string);
			push_number(n);
d679 31
d863 6
@


1.12
log
@Make J operator handle extended comparisons correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.11 2003/10/22 12:15:20 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.11 2003/10/22 12:15:20 otto Exp $";
d72 1
d162 1
d481 6
@


1.11
log
@Implement extended comparison operators, to allow for an if ... else construct
in bc(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.10 2003/10/18 20:33:48 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.10 2003/10/18 20:33:48 otto Exp $";
d1409 4
d1423 4
@


1.10
log
@#ifdef debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.9 2003/10/18 19:45:42 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.9 2003/10/18 19:45:42 otto Exp $";
d39 2
d1242 1
a1242 1
	int		index;
d1249 1
d1251 4
d1257 1
a1257 1
	if (a == NULL) {
a1258 1
	}
d1298 6
a1303 1
	if (ok) {
d1306 1
a1306 1
			warn("stack empty");
@


1.9
log
@o Implement new J (jump) and M (mark) operators. The J operator
  pops n recursion levels and then skips to the first occurence of the M
  operator. These operators are used to implement the "continue"
  statement in bc(1).
o Ifdef debug code.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.8 2003/10/11 18:31:18 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.8 2003/10/11 18:31:18 otto Exp $";
d256 1
a256 1
#if 1
@


1.8
log
@Division and modulus operator (~). From hugh@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.7 2003/09/30 18:27:01 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.7 2003/09/30 18:27:01 otto Exp $";
d33 2
a34 1
static bool	trace = false;
d110 2
d167 2
d1353 68
d1492 6
a1497 6
		if (trace) {
			fprintf(stderr, "# %c\n", ch);
			stack_print(stderr, &bmachine.stack, "* ",
			    bmachine.obase);
			fprintf(stderr, "%d =>\n", bmachine.readsp);
		}
d1504 5
a1508 5
		if (trace) {
			stack_print(stderr, &bmachine.stack, "* ",
			    bmachine.obase);
			fprintf(stderr, "%d ==\n", bmachine.readsp);
		}
@


1.7
log
@Flush stdout after P operator. Improves interaction with bc(1).
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.6 2003/09/28 19:15:53 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.6 2003/09/28 19:15:53 otto Exp $";
d88 1
d149 1
d988 42
@


1.6
log
@Fix error check for array store operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.5 2003/09/22 14:49:16 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.5 2003/09/22 14:49:16 otto Exp $";
d455 1
d458 2
a459 1
			printf("%s", value->u.string);
@


1.5
log
@Make registers contain zero initially. Needed for new bc(1) and original dc(1)
compatible.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.4 2003/09/20 06:28:24 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.4 2003/09/20 06:28:24 otto Exp $";
d773 2
d776 2
a777 3
		if (inumber == NULL) {
			if (value != NULL)
				stack_free_value(value);
@


1.4
log
@Remove bogus comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.3 2003/09/19 20:58:58 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.3 2003/09/19 20:58:58 deraadt Exp $";
d655 1
d660 5
a664 3
		if (v == NULL)
			warnx("register '%c' (0%o) is empty", index, index);
		else
a698 1
			/*frame_free(stack);*/
@


1.3
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.2 2003/09/19 19:00:36 deraadt Exp $";
a965 4
	/*
	 * XXX gives incorrect results for scale > 0, but is AT&T and
	 * GNU compatible
	 */
@


1.2
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: bcode.c,v 1.1 2003/09/19 17:58:25 otto Exp $	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD: bcode.c,v 1.1 2003/09/19 17:58:25 otto Exp $";
d194 1
a194 1
	for (i = 0; i < UCHAR_MAX;  i++)
@


1.1
log
@A complete, BSD licensed rewrite of dc(1), using the bn(3) big number routines.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d20 1
a20 1
static const char rcsid[] = "$OpenBSD$";
d45 1
a45 1
	struct source		readstack[MAX_RECURSION];	
d1027 1
a1027 1
		
d1162 1
a1162 1
	default: 
d1222 1
a1222 1
	case BCODE_EQUAL: 
d1225 1
a1225 1
	case BCODE_NOT_EQUAL: 
d1228 1
a1228 1
	case BCODE_LESS: 
d1231 1
a1231 1
	case BCODE_NOT_LESS: 
d1234 1
a1234 1
	case BCODE_GREATER: 
d1269 1
a1269 1
static void 
d1272 1
a1272 1
	if (bmachine.readsp < 2) 
@

