head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2016.02.04.18.33.30;	author millert;	state Exp;
branches;
next	1.8;
commitid	4JC4acRxu0Ag1Vp2;

1.8
date	2015.10.05.23.15.31;	author nicm;	state Exp;
branches;
next	1.7;
commitid	x6PApQ5v6vaG3lGh;

1.7
date	2014.09.21.05.29.47;	author daniel;	state Exp;
branches;
next	1.6;
commitid	WSUjBisPevDtMiBN;

1.6
date	2013.11.12.13.54.51;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.20.19.27.47;	author naddy;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.17.21.10.24;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2012.11.21.19.48.49;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2012.07.11.06.39.32;	author nicm;	state Exp;
branches;
next	1.1;

1.1
date	2012.07.10.11.42.02;	author nicm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Include stdint.h for the uint{8,16}_t types.  OK nicm@@
@
text
@/* $OpenBSD: xmodem.c,v 1.8 2015/10/05 23:15:31 nicm Exp $ */

/*
 * Copyright (c) 2012 Nicholas Marriott <nicm@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>

#include <errno.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#include "cu.h"

#define XMODEM_BLOCK 128
#define XMODEM_RETRIES 10

#define XMODEM_SOH '\001'
#define XMODEM_EOT '\004'
#define XMODEM_ACK '\006'
#define XMODEM_NAK '\025'
#define XMODEM_SUB '\032'
#define XMODEM_C   '\103'

volatile sig_atomic_t xmodem_stop;

void		xmodem_signal(int sig);
uint16_t	xmodem_crc16(const u_char *buf, size_t len);
int		xmodem_read(char *c);
int		xmodem_write(const u_char *buf, size_t len);

void
xmodem_signal(int sig)
{
	xmodem_stop = 1;
}

uint16_t
xmodem_crc16(const u_char *buf, size_t len)
{
	uint16_t	crc;
	u_int		i, j;

	crc = 0;
	for (i = 0; i < len; i++) {
		crc = crc ^ *buf++ << 8;
		for (j = 0; j < 8; j++)
			if (crc & 0x8000)
				crc = crc << 1 ^ 0x1021;
			else
				crc = crc << 1;
	}
	return (crc);
}

int
xmodem_read(char *c)
{
	for (;;) {
		switch (read(line_fd, c, 1)) {
		case -1:
			if (errno == EINTR && !xmodem_stop)
				continue;
			return (-1);
		case 0:
			errno = EPIPE;
			return (-1);
		case 1:
			return (0);
		}
	}
}

int
xmodem_write(const u_char *buf, size_t len)
{
	ssize_t	n;

	while (len > 0) {
		n = write(line_fd, buf, len);
		if (n == -1) {
			if (errno == EINTR && !xmodem_stop)
				continue;
			return (-1);
		}
		buf += n;
		len -= n;
	}
	return (0);
}

void
xmodem_send(const char *file)
{
	FILE			*f;
	u_char			 buf[3 + XMODEM_BLOCK + 2], c;
	size_t			 len, pktlen;
	uint8_t			 num;
	uint16_t		 crc;
	int			 crc_mode;
	u_int			 i, total;
	struct termios		 tio;
	struct sigaction	 act, oact;

	f = fopen(file, "r");
	if (f == NULL) {
		cu_warn("%s", file);
		return;
	}

	memset(&act, 0, sizeof(act));
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	act.sa_handler = xmodem_signal;
	if (sigaction(SIGINT, &act, &oact) != 0)
		cu_err(1, "sigaction");
	xmodem_stop = 0;

	if (isatty(STDIN_FILENO)) {
		memcpy(&tio, &saved_tio, sizeof(tio));
		tio.c_lflag &= ~ECHO;
		if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio) != 0)
			cu_err(1, "tcsetattr");
	}
	set_blocking(line_fd, 1);
	tcflush(line_fd, TCIFLUSH);

	if (xmodem_read(&c) != 0)
		goto fail;
	if (c == XMODEM_C)
		crc_mode = 1;
	else if (c == XMODEM_NAK)
		crc_mode = 0;
	else {
		cu_warnx("%s: unexpected response \\%03hho", file, c);
		goto fail;
	}

	num = 1;
	total = 1;
	pktlen = 3 + XMODEM_BLOCK + (crc_mode ? 2 : 1);
	for (;;) {
		len = fread(buf + 3, 1, XMODEM_BLOCK, f);
		if (len == 0)
			break;
		memset(buf + 3 + len, XMODEM_SUB, XMODEM_BLOCK - len);

		buf[0] = XMODEM_SOH;
		buf[1] = num;
		buf[2] = 255 - num;

		if (crc_mode) {
			crc = xmodem_crc16(buf + 3, XMODEM_BLOCK);
			buf[3 + XMODEM_BLOCK] = crc >> 8;
			buf[3 + XMODEM_BLOCK + 1] = crc & 0xFF;
		} else {
			buf[3 + XMODEM_BLOCK] = 0;
			for (i = 0; i < XMODEM_BLOCK; i++)
				buf[3 + XMODEM_BLOCK] += buf[3 + i];
		}

		for (i = 0; i < XMODEM_RETRIES; i++) {
			if (xmodem_stop) {
				errno = EINTR;
				goto fail;
			}
			cu_warnx("%s: sending block %u (attempt %u)", file,
			    total, 1 + i);
			if (xmodem_write(buf, pktlen) != 0)
				goto fail;

			if (xmodem_read(&c) != 0)
				goto fail;
			if (c == XMODEM_ACK)
				break;
			if (c != XMODEM_NAK) {
				cu_warnx("%s: unexpected response \\%03hho",
				    file, c);
			}
		}
		if (i == XMODEM_RETRIES) {
			cu_warnx("%s: too many retries", file);
			goto out;
		}

		if (len < XMODEM_BLOCK)
			break;
		num++;
		total++;
	}

	buf[0] = XMODEM_EOT;
	if (xmodem_write(buf, 1) != 0)
		goto fail;
	cu_warnx("%s: completed %u blocks", file, num);

	goto out;

fail:
	cu_warn("%s", file);

out:
	set_blocking(line_fd, 0);
	set_termios();

	sigaction(SIGINT, &oact, NULL);

	fclose(f);
}
@


1.8
log
@Set the line file descriptor nonblocking and make it blocking again for
xmodem and child processes, makes xmodem work with -d. Reported by Kim
Zeitler via guenther@@, tested by Jiri B. ok (and a small change) guenther
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.7 2014/09/21 05:29:47 daniel Exp $ */
d23 1
@


1.7
log
@Fix an invalid escape sequence.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.6 2013/11/12 13:54:51 deraadt Exp $ */
d140 2
a142 1
	tcflush(line_fd, TCIFLUSH);
d218 1
@


1.6
log
@simpler prototype repairs
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.5 2013/07/20 19:27:47 naddy Exp $ */
d149 1
a149 1
		cu_warnx("%s: unexpected response \%03hho", file, c);
d191 1
a191 1
				cu_warnx("%s: unexpected response \%03hho",
@


1.5
log
@Add support for XMODEM-CRC and fix transfer initiation.  Successfully
tested in CRC and checksum modes against a Soekris net6501.
tweaks and ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.4 2013/01/17 21:10:24 nicm Exp $ */
d41 5
@


1.4
log
@Fix a couple of spacing/style nits.
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.3 2012/11/21 19:48:49 nicm Exp $ */
d38 1
d48 18
d106 2
a107 2
	u_char			 buf[3 + XMODEM_BLOCK + 1], c;
	size_t			 len;
d109 2
d136 12
d150 1
d161 9
a169 3
		buf[3 + XMODEM_BLOCK] = 0;
		for (i = 0; i < 128; i++)
			buf[3 + XMODEM_BLOCK] += buf[3 + i];
d178 1
a178 1
			if (xmodem_write(buf, sizeof buf) != 0)
@


1.3
log
@Plug fp leak, from rustyBSD at gmx dot fr.
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.2 2012/07/11 06:39:32 nicm Exp $ */
d153 1
a153 1
		};
d176 1
a176 1
	fclose (f);
@


1.2
log
@Separate total block counter (reported to user) from 8-bit block counter
put into the header, pointed out by naddy.
@
text
@d1 1
a1 1
/* $OpenBSD: xmodem.c,v 1.1 2012/07/10 11:42:02 nicm Exp $ */
d176 1
a176 1
	return;
@


1.1
log
@Add builtin XMODEM send support with ~X, only tested with lrz -X so far.
@
text
@d1 1
a1 1
/* $OpenBSD: command.c,v 1.5 2012/07/10 09:32:40 nicm Exp $ */
d90 1
a90 1
	u_int			 i;
d116 1
d137 1
a137 1
			    num, 1 + i);
d158 1
@

