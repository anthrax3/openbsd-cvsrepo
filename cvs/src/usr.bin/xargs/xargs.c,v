head	1.32;
access;
symbols
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.20
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.18
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.8
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.6
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2017.01.19.17.08.41;	author millert;	state Exp;
branches;
next	1.31;
commitid	euJ8asWfpe44QHDB;

1.31
date	2015.12.09.19.29.49;	author mmcc;	state Exp;
branches;
next	1.30;
commitid	T5Y5trrkrbvb2jXC;

1.30
date	2015.10.10.15.52.30;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	OsCkDiyNOwBGLdbn;

1.29
date	2015.04.18.18.28.38;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	6b2lLILbgCR1fvia;

1.28
date	2015.01.16.06.40.14;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	Uu5nFG3wCl0LACBb;

1.27
date	2010.03.25.01.03.57;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.27.23.59.50;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.02.15.19.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.01.04.52.59;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.26.20.32.04;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.12.09.44.59;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.10.23.00.29;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.20.18.52.19;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.08.23.19.09.36;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.08.15.22.46.46;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.15.23.30.47;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.13.16.54.00;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.12.01.15.53;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.12.01.09.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.10.22.20.54;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.02.56.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.18.18.22.54;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.21.27.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.19.19.02.18;	author mpech;	state Exp;
branches;
next	1.8;

1.8
date	98.06.23.00.22.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.04.26.17.12.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.11.04.08.47.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.12.01.47.25;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.15.23.43.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.06.26.05.44.03;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.11.06.48.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.47.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Fix -L/-I processing in -0 mode so that NUL-delimited entries are
treated as "lines".  From FreeBSD.
@
text
@/*	$OpenBSD: xargs.c,v 1.31 2015/12/09 19:29:49 mmcc Exp $	*/
/*	$FreeBSD: xargs.c,v 1.51 2003/05/03 19:09:11 obrien Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * John B. Roll Jr.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $xMach: xargs.c,v 1.6 2002/02/23 05:27:47 tim Exp $
 */

#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <langinfo.h>
#include <locale.h>
#include <paths.h>
#include <regex.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "pathnames.h"

static void	parse_input(int, char *[]);
static void	prerun(int, char *[]);
static int	prompt(void);
static void	run(char **);
static void	usage(void);
void		strnsubst(char **, const char *, const char *, size_t);
static void	waitchildren(const char *, int);

static char **av, **bxp, **ep, **endxp, **xp;
static char *argp, *bbp, *ebp, *inpline, *p, *replstr;
static const char *eofstr;
static int count, insingle, indouble, oflag, pflag, tflag, Rflag, rval, zflag;
static int cnt, Iflag, jfound, Lflag, wasquoted, xflag, runeof = 1;
static int curprocs, maxprocs;
static size_t inpsize;

extern char **environ;

int
main(int argc, char *argv[])
{
	long arg_max;
	int ch, Jflag, nargs, nflag, nline;
	size_t linelen;
	char *endptr;
	const char *errstr;

	inpline = replstr = NULL;
	ep = environ;
	eofstr = "";
	Jflag = nflag = 0;

	(void)setlocale(LC_MESSAGES, "");

	/*
	 * POSIX.2 limits the exec line length to ARG_MAX - 2K.  Running that
	 * caused some E2BIG errors, so it was changed to ARG_MAX - 4K.  Given
	 * that the smallest argument is 2 bytes in length, this means that
	 * the number of arguments is limited to:
	 *
	 *	 (ARG_MAX - 4K - LENGTH(utility + arguments)) / 2.
	 *
	 * We arbitrarily limit the number of arguments to 5000.  This is
	 * allowed by POSIX.2 as long as the resulting minimum exec line is
	 * at least LINE_MAX.  Realloc'ing as necessary is possible, but
	 * probably not worthwhile.
	 */
	nargs = 5000;
	if ((arg_max = sysconf(_SC_ARG_MAX)) == -1)
		errx(1, "sysconf(_SC_ARG_MAX) failed");

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	nline = arg_max - 4 * 1024;
	while (*ep != NULL) {
		/* 1 byte for each '\0' */
		nline -= strlen(*ep++) + 1 + sizeof(*ep);
	}
	maxprocs = 1;
	while ((ch = getopt(argc, argv, "0E:I:J:L:n:oP:pR:rs:tx")) != -1)
		switch (ch) {
		case 'E':
			eofstr = optarg;
			break;
		case 'I':
			Jflag = 0;
			Iflag = 1;
			Lflag = 1;
			replstr = optarg;
			break;
		case 'J':
			Iflag = 0;
			Jflag = 1;
			replstr = optarg;
			break;
		case 'L':
			Lflag = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-L %s: %s", optarg, errstr);
			break;
		case 'n':
			nflag = 1;
			nargs = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-n %s: %s", optarg, errstr);
			break;
		case 'o':
			oflag = 1;
			break;
		case 'P':
			maxprocs = strtonum(optarg, 1, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-P %s: %s", optarg, errstr);
			break;
		case 'p':
			pflag = 1;
			break;
		case 'r':
			runeof = 0;
			break;
		case 'R':
			Rflag = strtol(optarg, &endptr, 10);
			if (*endptr != '\0')
				errx(1, "replacements must be a number");
			break;
		case 's':
			nline = strtonum(optarg, 0, INT_MAX, &errstr);
			if (errstr)
				errx(1, "-s %s: %s", optarg, errstr);
			break;
		case 't':
			tflag = 1;
			break;
		case 'x':
			xflag = 1;
			break;
		case '0':
			zflag = 1;
			break;
		case '?':
		default:
			usage();
	}
	argc -= optind;
	argv += optind;

	if (!Iflag && Rflag)
		usage();
	if (Iflag && !Rflag)
		Rflag = 5;
	if (xflag && !nflag)
		usage();
	if (Iflag || Lflag)
		xflag = 1;
	if (replstr != NULL && *replstr == '\0')
		errx(1, "replstr may not be empty");

	/*
	 * Allocate pointers for the utility name, the utility arguments,
	 * the maximum arguments to be read from stdin and the trailing
	 * NULL.
	 */
	linelen = 1 + argc + nargs + 1;
	if ((av = bxp = calloc(linelen, sizeof(char **))) == NULL)
		err(1, NULL);

	/*
	 * Use the user's name for the utility as argv[0], just like the
	 * shell.  Echo is the default.  Set up pointers for the user's
	 * arguments.
	 */
	if (*argv == NULL)
		cnt = strlen(*bxp++ = _PATH_ECHO);
	else {
		do {
			if (Jflag && strcmp(*argv, replstr) == 0) {
				char **avj;
				jfound = 1;
				argv++;
				for (avj = argv; *avj; avj++)
					cnt += strlen(*avj) + 1;
				break;
			}
			cnt += strlen(*bxp++ = *argv) + 1;
		} while (*++argv != NULL);
	}

	/*
	 * Set up begin/end/traversing pointers into the array.  The -n
	 * count doesn't include the trailing NULL pointer, so the malloc
	 * added in an extra slot.
	 */
	endxp = (xp = bxp) + nargs;

	/*
	 * Allocate buffer space for the arguments read from stdin and the
	 * trailing NULL.  Buffer space is defined as the default or specified
	 * space, minus the length of the utility name and arguments.  Set up
	 * begin/end/traversing pointers into the array.  The -s count does
	 * include the trailing NULL, so the malloc didn't add in an extra
	 * slot.
	 */
	nline -= cnt;
	if (nline <= 0)
		errx(1, "insufficient space for command");

	if ((bbp = malloc((size_t)(nline + 1))) == NULL)
		err(1, NULL);
	ebp = (argp = p = bbp) + nline - 1;
	for (;;)
		parse_input(argc, argv);
}

static void
parse_input(int argc, char *argv[])
{
	int hasblank = 0;
	static int hadblank = 0;
	int ch, foundeof = 0;
	char **avj;

	ch = getchar();
	if (isblank(ch)) {
		/* Quotes escape tabs and spaces. */
		if (insingle || indouble)
			goto addch;
		hasblank = 1;
		if (zflag)
			goto addch;
		goto arg2;
	}

	switch (ch) {
	case EOF:
		/* No arguments since last exec. */
		if (p == bbp) {
			if (runeof)
				prerun(0, av);
			waitchildren(*argv, 1);
			exit(rval);
		}
		goto arg1;
	case '\0':
		if (zflag) {
			/*
			 * Increment 'count', so that nulls will be treated
			 * as end-of-line, as well as end-of-argument.  This
			 * is needed so -0 works properly with -I and -L.
			 */
			count++;
			goto arg2;
		}
		goto addch;
	case '\n':
		if (zflag)
			goto addch;
		hasblank = 1;
		if (hadblank == 0)
			count++;

		/* Quotes do not escape newlines. */
arg1:		if (insingle || indouble)
			errx(1, "unterminated quote");
arg2:
		foundeof = *eofstr != '\0' &&
		    strcmp(argp, eofstr) == 0;

		/* Do not make empty args unless they are quoted */
		if ((argp != p || wasquoted) && !foundeof) {
			*p++ = '\0';
			*xp++ = argp;
			if (Iflag) {
				size_t curlen;

				if (inpline == NULL)
					curlen = 0;
				else {
					/*
					 * If this string is not zero
					 * length, append a space for
					 * separation before the next
					 * argument.
					 */
					if ((curlen = strlen(inpline)))
						strlcat(inpline, " ", inpsize);
				}
				curlen++;
				/*
				 * Allocate enough to hold what we will
				 * be holding in a second, and to append
				 * a space next time through, if we have
				 * to.
				 */
				inpsize = curlen + 2 + strlen(argp);
				inpline = realloc(inpline, inpsize);
				if (inpline == NULL)
					errx(1, "realloc failed");
				if (curlen == 1)
					strlcpy(inpline, argp, inpsize);
				else
					strlcat(inpline, argp, inpsize);
			}
		}

		/*
		 * If max'd out on args or buffer, or reached EOF,
		 * run the command.  If xflag and max'd out on buffer
		 * but not on args, object.  Having reached the limit
		 * of input lines, as specified by -L is the same as
		 * maxing out on arguments.
		 */
		if (xp == endxp || p > ebp || ch == EOF ||
		    (Lflag <= count && xflag) || foundeof) {
			if (xflag && xp != endxp && p > ebp)
				errx(1, "insufficient space for arguments");
			if (jfound) {
				for (avj = argv; *avj; avj++)
					*xp++ = *avj;
			}
			prerun(argc, av);
			if (ch == EOF || foundeof) {
				waitchildren(*argv, 1);
				exit(rval);
			}
			p = bbp;
			xp = bxp;
			count = 0;
		}
		argp = p;
		wasquoted = 0;
		break;
	case '\'':
		if (indouble || zflag)
			goto addch;
		insingle = !insingle;
		wasquoted = 1;
		break;
	case '"':
		if (insingle || zflag)
			goto addch;
		indouble = !indouble;
		wasquoted = 1;
		break;
	case '\\':
		if (zflag)
			goto addch;
		/* Backslash escapes anything, is escaped by quotes. */
		if (!insingle && !indouble && (ch = getchar()) == EOF)
			errx(1, "backslash at EOF");
		/* FALLTHROUGH */
	default:
addch:		if (p < ebp) {
			*p++ = ch;
			break;
		}

		/* If only one argument, not enough buffer space. */
		if (bxp == xp)
			errx(1, "insufficient space for argument");
		/* Didn't hit argument limit, so if xflag object. */
		if (xflag)
			errx(1, "insufficient space for arguments");

		if (jfound) {
			for (avj = argv; *avj; avj++)
				*xp++ = *avj;
		}
		prerun(argc, av);
		xp = bxp;
		cnt = ebp - argp;
		memcpy(bbp, argp, (size_t)cnt);
		p = (argp = bbp) + cnt;
		*p++ = ch;
		break;
	}
	hadblank = hasblank;
}

/*
 * Do things necessary before run()'ing, such as -I substitution,
 * and then call run().
 */
static void
prerun(int argc, char *argv[])
{
	char **tmp, **tmp2, **avj;
	int repls;

	repls = Rflag;
	runeof = 0;

	if (argc == 0 || repls == 0) {
		*xp = NULL;
		run(argv);
		return;
	}

	avj = argv;

	/*
	 * Allocate memory to hold the argument list, and
	 * a NULL at the tail.
	 */
	tmp = calloc(argc + 1, sizeof(char**));
	if (tmp == NULL)
		err(1, NULL);
	tmp2 = tmp;

	/*
	 * Save the first argument and iterate over it, we
	 * cannot do strnsubst() to it.
	 */
	if ((*tmp++ = strdup(*avj++)) == NULL)
		err(1, NULL);

	/*
	 * For each argument to utility, if we have not used up
	 * the number of replacements we are allowed to do, and
	 * if the argument contains at least one occurrence of
	 * replstr, call strnsubst(), else just save the string.
	 * Iterations over elements of avj and tmp are done
	 * where appropriate.
	 */
	while (--argc) {
		*tmp = *avj++;
		if (repls && strstr(*tmp, replstr) != NULL) {
			strnsubst(tmp++, replstr, inpline, (size_t)255);
			if (repls > 0)
				repls--;
		} else {
			if ((*tmp = strdup(*tmp)) == NULL)
				err(1, NULL);
			tmp++;
		}
	}

	/*
	 * Run it.
	 */
	*tmp = NULL;
	run(tmp2);

	/*
	 * Walk from the tail to the head, free along the way.
	 */
	for (; tmp2 != tmp; tmp--)
		free(*tmp);
	/*
	 * Now free the list itself.
	 */
	free(tmp2);

	/*
	 * Free the input line buffer, if we have one.
	 */
	free(inpline);
	inpline = NULL;
}

static void
run(char **argv)
{
	pid_t pid;
	int fd;
	char **avec;

	/*
	 * If the user wants to be notified of each command before it is
	 * executed, notify them.  If they want the notification to be
	 * followed by a prompt, then prompt them.
	 */
	if (tflag || pflag) {
		(void)fprintf(stderr, "%s", *argv);
		for (avec = argv + 1; *avec != NULL; ++avec)
			(void)fprintf(stderr, " %s", *avec);
		/*
		 * If the user has asked to be prompted, do so.
		 */
		if (pflag)
			/*
			 * If they asked not to exec, return without execution
			 * but if they asked to, go to the execution.  If we
			 * could not open their tty, break the switch and drop
			 * back to -t behaviour.
			 */
			switch (prompt()) {
			case 0:
				return;
			case 1:
				goto exec;
			case 2:
				break;
			}
		(void)fprintf(stderr, "\n");
		(void)fflush(stderr);
	}
exec:
	switch (pid = vfork()) {
	case -1:
		err(1, "vfork");
	case 0:
		if (oflag) {
			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1) {
				warn("can't open /dev/tty");
				_exit(1);
			}
		} else {
			fd = open(_PATH_DEVNULL, O_RDONLY);
		}
		if (fd > STDIN_FILENO) {
			if (dup2(fd, STDIN_FILENO) != 0) {
				warn("can't dup2 to stdin");
				_exit(1);
			}
			close(fd);
		}
		execvp(argv[0], argv);
		warn("%s", argv[0]);
		_exit(errno == ENOENT ? 127 : 126);
	}
	curprocs++;
	waitchildren(*argv, 0);
}

static void
waitchildren(const char *name, int waitall)
{
	pid_t pid;
	int status;

	while ((pid = waitpid(-1, &status, !waitall && curprocs < maxprocs ?
	    WNOHANG : 0)) > 0) {
		curprocs--;
		/*
		 * According to POSIX, we have to exit if the utility exits
		 * with a 255 status, or is interrupted by a signal.
		 * We are allowed to return any exit status between 1 and
		 * 125 in these cases, but we'll use 124 and 125, the same
		 * values used by GNU xargs.
		 */
		if (WIFEXITED(status)) {
			if (WEXITSTATUS(status) == 255) {
				warnx("%s exited with status 255", name);
				exit(124);
			} else if (WEXITSTATUS(status) == 127 ||
			    WEXITSTATUS(status) == 126) {
				exit(WEXITSTATUS(status));
			} else if (WEXITSTATUS(status) != 0) {
				rval = 123;
			}
		} else if (WIFSIGNALED(status)) {
			if (WTERMSIG(status) != SIGPIPE) {
				if (WTERMSIG(status) < NSIG)
					warnx("%s terminated by SIG%s", name,
					    sys_signame[WTERMSIG(status)]);
				else
					warnx("%s terminated by signal %d",
					    name, WTERMSIG(status));
			}
			exit(125);
		}
	}
	if (pid == -1 && errno != ECHILD)
		err(1, "waitpid");
}

/*
 * Prompt the user about running a command.
 */
static int
prompt(void)
{
	regex_t cre;
	size_t rsize;
	int match;
	char *response;
	FILE *ttyfp;

	if ((ttyfp = fopen(_PATH_TTY, "r")) == NULL)
		return (2);	/* Indicate that the TTY failed to open. */
	(void)fprintf(stderr, "?...");
	(void)fflush(stderr);
	if ((response = fgetln(ttyfp, &rsize)) == NULL ||
	    regcomp(&cre, nl_langinfo(YESEXPR), REG_BASIC) != 0) {
		(void)fclose(ttyfp);
		return (0);
	}
	response[rsize - 1] = '\0';
	match = regexec(&cre, response, 0, NULL, 0);
	(void)fclose(ttyfp);
	regfree(&cre);
	return (match == 0);
}

static void
usage(void)
{
	fprintf(stderr,
"usage: xargs [-0oprt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr]\n"
"             [-L number] [-n number [-x]] [-P maxprocs] [-s size]\n"
"             [utility [argument ...]]\n");
	exit(1);
}
@


1.31
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.30 2015/10/10 15:52:30 deraadt Exp $	*/
d281 7
a287 1
		if (zflag)
d289 1
d292 2
a296 2
		if (zflag)
			goto addch;
@


1.30
log
@pledge "stdio rpath proc exec".  proc & exec because obviously it
spawns subprocesses.  rpath is only needed for the -o (open /dev/tty)
or no -o (open /dev/null) choice.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.29 2015/04/18 18:28:38 deraadt Exp $	*/
d486 2
a487 4
	if (inpline != NULL) {
		free(inpline);
		inpline = NULL;
	}
@


1.29
log
@Convert many atoi() calls to strtonum(), adding range checks and failure
handling along the way.
Reviews by Brendan MacDonell, Jeremy Devenport, florian, doug, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.28 2015/01/16 06:40:14 deraadt Exp $	*/
d107 4
@


1.28
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.27 2010/03/25 01:03:57 schwarze Exp $	*/
d53 1
d82 1
d130 3
a132 1
			Lflag = atoi(optarg);
d136 3
a138 2
			if ((nargs = atoi(optarg)) <= 0)
				errx(1, "illegal argument count");
d144 3
a146 2
			if ((maxprocs = atoi(optarg)) <= 0)
				errx(1, "max. processes must be >0");
d160 3
a162 1
			nline = atoi(optarg);
@


1.27
log
@Regarding -L, consider a line ending in unescaped white space and the next
non-empty line to form one single line, as required by XPG 4.
While here, use isblank(3) to identify white space instead of assuming
that only blank and tab are white space characters.

Geoff Clare <gwc at opengroup dot org> agrees that the standard for -L
should say "A line is considered to end with the first <newline>
unless the last character of the line is an *unescaped* <blank>;
an *unescaped* trailing <blank> signals continuation to the next
non-empty line, inclusive."  The word *unescaped* is missing from
the standard, but we regard that as a goof in the standard.

Bug noticed by, much feedback from, and "should go in now"  guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.26 2009/10/27 23:59:50 deraadt Exp $	*/
a37 1
#include <sys/param.h>
@


1.26
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.25 2007/09/02 15:19:36 deraadt Exp $	*/
d41 1
d243 2
d248 12
a259 1
	switch (ch = getchar()) {
a268 6
	case ' ':
	case '\t':
		/* Quotes escape tabs and spaces. */
		if (insingle || indouble || zflag)
			goto addch;
		goto arg2;
d274 3
a276 1
		count++;
d395 1
@


1.25
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.24 2005/11/01 04:52:59 deraadt Exp $	*/
a36 14

#ifndef lint
static const char copyright[] =
"@@(#) Copyright (c) 1990, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
#endif /* not lint */

#ifndef lint
#if 0
static const char sccsid[] = "@@(#)xargs.c	8.1 (Berkeley) 6/6/93";
#else
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.24 2005/11/01 04:52:59 deraadt Exp $";
#endif
#endif /* not lint */
@


1.24
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.23 2005/09/26 20:32:04 fgsch Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.23 2005/09/26 20:32:04 fgsch Exp $";
d203 1
a203 1
	if ((av = bxp = malloc(linelen * sizeof(char **))) == NULL)
d426 1
a426 1
	tmp = malloc((argc + 1) * sizeof(char**));
@


1.23
log
@terminate the buffer before calling regexec(3) when prompting for
confirmation. fixes a crash with malloc options; otto@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.22 2005/09/12 09:44:59 jmc Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.22 2005/09/12 09:44:59 jmc Exp $";
d542 1
a542 1
                warn("%s", argv[0]);
d569 1
a569 1
                        } else if (WEXITSTATUS(status) == 127 || 
d612 1
a612 1
	response[rsize - 1] = '\0'; 
@


1.22
log
@- add -r to usage()
- the description of -p uses `maxprocs' as the arg identifier,
as does usage(), so use it in SYNOPSIS too;
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.21 2005/09/10 23:00:29 brad Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.21 2005/09/10 23:00:29 brad Exp $";
d612 1
@


1.21
log
@Make xargs run [utility] program even when zero arguements are provided,
makes xargs POSIX compliant.

Original diff from jason@@, better diff provided by millert@@

Resolves PR 4262

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.20 2005/06/20 18:52:19 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.20 2005/06/20 18:52:19 millert Exp $";
d622 1
a622 1
"usage: xargs [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr]\n"
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.19 2004/08/23 19:09:36 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.19 2004/08/23 19:09:36 millert Exp $";
d82 1
a82 1
static int cnt, Iflag, jfound, Lflag, wasquoted, xflag;
d125 1
a125 1
	while ((ch = getopt(argc, argv, "0E:I:J:L:n:oP:pR:s:tx")) != -1)
d159 3
d263 2
d412 1
@


1.19
log
@Make behavior if the utility was not found or could not be executed
match the documentation.  The old code was making assumptions about
how vfork() is implemented which are not valid on OpenBSD.
From Jason Ish.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.18 2003/08/15 22:46:46 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.18 2003/08/15 22:46:46 millert Exp $";
d126 1
a126 1
		switch(ch) {
d253 1
a253 1
	int ch, foundeof;
d256 1
a256 3
	foundeof = 0;

	switch(ch = getchar()) {
d516 1
a516 1
	switch(pid = vfork()) {
@


1.18
log
@Fix typo (errx vs. err) for malloc failures; Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.17 2003/07/15 23:30:47 tedu Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.17 2003/07/15 23:30:47 tedu Exp $";
a85 2
static volatile int childerr;

a517 1
	childerr = 0;
d538 2
a539 2
		childerr = errno;
		_exit(1);
a553 5
		/* If we couldn't invoke the utility, exit. */
		if (childerr != 0) {
			errno = childerr;
			err(errno == ENOENT ? 127 : 126, "%s", name);
		}
d565 3
@


1.17
log
@can't use err after vfork.  ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.16 2003/06/13 16:54:00 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.16 2003/06/13 16:54:00 millert Exp $";
d246 1
a246 1
		errx(1, NULL);
d426 1
a426 1
		errx(1, NULL);
d434 1
a434 1
		errx(1, NULL);
d452 1
a452 1
				errx(1, NULL);
@


1.16
log
@Close correct fd after dup2(); Maxime Henrion
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.15 2003/06/12 01:15:53 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.15 2003/06/12 01:15:53 millert Exp $";
d526 4
a529 2
			if ((fd = open(_PATH_TTY, O_RDONLY)) == -1)
				err(1, "can't open /dev/tty");
d534 4
a537 2
			if (dup2(fd, STDIN_FILENO) != 0)
				err(1, "can't dup2 to stdin");
@


1.15
log
@Add the -o option to the getopt() string; missed in last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.14 2003/06/12 01:09:23 millert Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.14 2003/06/12 01:09:23 millert Exp $";
d534 1
a534 1
			close(STDIN_FILENO);
@


1.14
log
@Sync with FreeBSD's xargs plus some fixes by me.  This makes us
POSIX-compliant and adds some useful extensions.  Most of the work
in FreeBSD was done by jmallett.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.13 2003/06/10 22:20:54 deraadt Exp $	*/
d48 1
a48 1
static const char rcsid[] = "$OpenBSD: xargs.c,v 1.13 2003/06/10 22:20:54 deraadt Exp $";
d127 1
a127 1
	while ((ch = getopt(argc, argv, "0E:I:J:L:n:P:pR:s:tx")) != -1)
@


1.13
log
@mostly ansi cleanup; pval ok
@
text
@d1 2
a2 2
/*	$OpenBSD: xargs.c,v 1.12 2003/06/03 02:56:24 millert Exp $	*/
/*	$NetBSD: xargs.c,v 1.7 1994/11/14 06:51:41 jtc Exp $	*/
d34 2
d39 1
a39 1
static char copyright[] =
d46 3
a48 1
static char sccsid[] = "@@(#)xargs.c	8.1 (Berkeley) 6/6/93";
a49 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.12 2003/06/03 02:56:24 millert Exp $";
d52 1
a52 1
#include <sys/types.h>
d54 2
d57 6
d67 1
a67 4
#include <limits.h>
#include <locale.h>
#include <signal.h>
#include <err.h>
d70 17
a86 2
int tflag, rval;
int zflag;
d88 1
a88 2
void run(char **);
void usage(void);
d93 9
a101 5
	int ch;
	char *p, *bbp, *ebp, **bxp, **exp, **xp;
	int cnt, indouble, insingle, nargs, nflag, nline, xflag;
	char **av, *argp;
	int arg_max;
d103 1
a103 1
	setlocale(LC_ALL, "");
d122 6
a127 2
	nflag = xflag = 0;
	while ((ch = getopt(argc, argv, "0n:s:tx")) != -1)
d129 17
d151 15
d185 11
d201 2
a202 2
	if (!(av = bxp =
	    malloc((u_int)(1 + argc + nargs + 1) * sizeof(char **))))
d210 1
a210 1
	if (!*argv)
a212 1
		cnt = 0;
d214 8
d223 1
a223 1
		} while (*++argv);
d231 1
a231 1
	exp = (xp = bxp) + nargs;
d245 2
a246 2
	if (!(bbp = malloc((u_int)nline + 1)))
		err(1, NULL);
d248 9
d258 1
a258 6
	for (insingle = indouble = 0;;)
		switch(ch = getchar()) {
		case EOF:
			/* No arguments since last exec. */
			if (p == bbp)
				exit(rval);
d260 16
a275 12
			/* Nothing since end of last argument. */
			if (argp == p) {
				*xp = NULL;
				run(av);
				exit(rval);
			}
			goto arg1;
		case ' ':
		case '\t':
			/* Quotes escape tabs and spaces. */
			if (insingle || indouble || zflag)
				goto addch;
d277 4
a280 3
		case '\0':
			if (zflag)
				goto arg2;
a281 11
		case '\n':
			if (zflag)
				goto addch;

			/* Empty lines are skipped. */
			if (argp == p)
				continue;

			/* Quotes do not escape newlines. */
arg1:			if (insingle || indouble)
				 errx(1, "unterminated quote");
d283 10
a292 1
arg2:			*p = '\0';
d294 2
d297 27
a323 39
			/*
			 * If max'd out on args or buffer, or reached EOF,
			 * run the command.  If xflag and max'd out on buffer
			 * but not on args, object.
			 */
			if (xp == exp || p == ebp || ch == EOF) {
				if (xflag && xp != exp && p == ebp)
					errx(1, "insufficient space for arguments");
				*xp = NULL;
				run(av);
				if (ch == EOF)
					exit(rval);
				p = bbp;
				xp = bxp;
			} else
				++p;
			argp = p;
			break;
		case '\'':
			if (indouble || zflag)
				goto addch;
			insingle = !insingle;
			break;
		case '"':
			if (insingle || zflag)
				goto addch;
			indouble = !indouble;
			break;
		case '\\':
			if (zflag)
				goto addch;
			/* Backslash escapes anything, is escaped by quotes. */
			if (!insingle && !indouble && (ch = getchar()) == EOF)
				errx(1, "backslash at EOF");
			/* FALLTHROUGH */
		default:
addch:			if (p < ebp) {
				*p++ = ch;
				break;
d325 1
d327 10
a336 5
			/* If only one argument, not enough buffer space. */
			if (bxp == xp)
				errx(1, "insufficient space for argument");
			/* Didn't hit argument limit, so if xflag object. */
			if (xflag)
d338 10
a347 3

			*xp = NULL;
			run(av);
d349 26
a374 3
			cnt = ebp - argp;
			bcopy(argp, bbp, cnt);
			p = (argp = bbp) + cnt;
d378 20
a397 1
	/* NOTREACHED */
d400 83
a482 1
void
a484 2
	volatile int noinvoke;
	char **p;
d486 2
a487 1
	int status;
d489 6
a494 1
	if (tflag) {
d496 20
a515 2
		for (p = argv + 1; *p; ++p)
			(void)fprintf(stderr, " %s", *p);
d519 2
a520 1
	noinvoke = 0;
d525 11
d537 1
a537 2
		noinvoke = (errno == ENOENT) ? 127 : 126;
		warn("%s", argv[0]);
d540 3
a542 3
	pid = waitpid(pid, &status, 0);
	if (pid == -1)
		err(1, "waitpid");
d544 5
a548 6
	/*
	 * If we couldn't invoke the utility or the utility didn't exit
	 * properly, quit with 127 or 126 respectively.
	 */
	if (noinvoke)
		exit(noinvoke);
d550 7
a556 12
	/*
	 * According to POSIX, we have to exit if the utility exits with
	 * a 255 status, or is interrupted by a signal.   xargs is allowed
	 * to return any exit status between 1 and 125 in these cases, but
	 * we'll use 124 and 125, the same values used by GNU xargs.
	 */
	if (WIFEXITED(status)) {
		if (WEXITSTATUS(status) == 255) {
			warnx("%s exited with status 255", argv[0]);
			exit(124);
		} else if (WEXITSTATUS(status) != 0) {
			rval = 123;
d558 24
a581 8
	} else if (WIFSIGNALED(status)) {
		if (WTERMSIG(status) != SIGPIPE) {
			if (WTERMSIG(status) < NSIG)
				warnx("%s terminated by SIG%s", argv[0],
				    sys_signame[WTERMSIG(status)]);
			else
				warnx("%s terminated by signal %d", argv[0],
				    WTERMSIG(status));
a582 1
		exit(125);
d584 29
d615 1
a615 1
void
d619 3
a621 2
	    "usage: xargs [-0] [-t] [-n number [-x]] [-s size] "
	    "[utility [argument ...]]\n");
@


1.12
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.11 2002/02/18 18:22:54 millert Exp $	*/
d46 1
a46 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.11 2002/02/18 18:22:54 millert Exp $";
d69 1
a69 3
main(argc, argv)
	int argc;
	char **argv;
d269 1
a269 2
run(argv)
	char **argv;
d331 1
a331 1
usage()
d333 3
a335 2
	(void)fprintf(stderr,
"usage: xargs [-0] [-t] [-n number [-x]] [-s size] [utility [argument ...]]\n");
@


1.11
log
@Don't require the -n flag if -x is specified.  This is consistent with
the manual page as well as xargs on other operating systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.10 2002/02/16 21:27:59 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d46 1
a46 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.10 2002/02/16 21:27:59 millert Exp $";
@


1.10
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.9 2001/11/19 19:02:18 mpech Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.9 2001/11/19 19:02:18 mpech Exp $";
a127 3

	if (xflag && !nflag)
		usage();
@


1.9
log
@kill more registers

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.8 1998/06/23 00:22:58 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.8 1998/06/23 00:22:58 deraadt Exp $";
d69 2
a70 2
void run __P((char **));
void usage __P((void));
@


1.8
log
@use sysconf() to get ARG_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.7 1998/04/26 17:12:48 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.7 1998/04/26 17:12:48 deraadt Exp $";
d77 2
a78 2
	register int ch;
	register char *p, *bbp, *ebp, **bxp, **exp, **xp;
d282 1
a282 1
	register char **p;
@


1.7
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.6 1997/11/04 08:47:15 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.6 1997/11/04 08:47:15 deraadt Exp $";
d81 1
d99 3
a101 1
	nline = ARG_MAX - 4 * 1024;
@


1.6
log
@use sys_signame to print the signal info; cgd
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.5 1997/09/12 01:47:25 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.5 1997/09/12 01:47:25 deraadt Exp $";
d318 2
a319 2
		if (WEXITSTATUS (status) == 255) {
			warnx ("%s exited with status 255", argv[0]);
d321 1
a321 1
		} else if (WEXITSTATUS (status) != 0) {
d324 1
a324 1
	} else if (WIFSIGNALED (status)) {
d327 1
a327 1
				warnx ("%s terminated by SIG%s", argv[0],
d330 1
a330 1
				warnx ("%s terminated by signal %d", argv[0],
@


1.5
log
@s/;;/;/
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.4 1997/01/15 23:43:40 millert Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.4 1997/01/15 23:43:40 millert Exp $";
d62 1
d325 8
a332 1
		warnx ("%s terminated by signal %d", argv[0], WTERMSIG(status));
@


1.4
log
@getopt(3) returns -1 when out of args, not EOF, whee!
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.3 1996/06/26 05:44:03 deraadt Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.3 1996/06/26 05:44:03 deraadt Exp $";
d296 1
a296 1
		warn("%s", argv[0]);;
@


1.3
log
@rcsid
@
text
@d1 1
a1 1
/*	$OpenBSD: xargs.c,v 1.7 1994/11/14 06:51:41 jtc Exp $	*/
d50 1
a50 1
static char rcsid[] = "$OpenBSD: xargs.c,v 1.7 1994/11/14 06:51:41 jtc Exp $";
d99 1
a99 1
	while ((ch = getopt(argc, argv, "0n:s:tx")) != EOF)
@


1.2
log
@add -0 option, written by me
@
text
@d1 1
d50 1
a50 1
static char rcsid[] = "$NetBSD: xargs.c,v 1.7 1994/11/14 06:51:41 jtc Exp $";
@


1.1
log
@Initial revision
@
text
@d65 1
d98 1
a98 1
	while ((ch = getopt(argc, argv, "n:s:tx")) != EOF)
d114 3
d190 1
a190 1
			if (insingle || indouble)
d193 4
d198 3
d231 1
a231 1
			if (indouble)
d236 1
a236 1
			if (insingle)
d241 2
d332 1
a332 1
"usage: xargs [-t] [-n number [-x]] [-s size] [utility [argument ...]]\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
