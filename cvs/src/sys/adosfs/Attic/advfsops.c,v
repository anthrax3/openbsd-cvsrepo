head	1.28;
access;
symbols
	OPENBSD_4_1:1.25.0.16
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.14
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.12
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.10
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.8
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.24
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_8:1.17.0.4
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2007.06.01.08.04.59;	author deraadt;	state dead;
branches;
next	1.27;

1.27
date	2007.06.01.05.37.12;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.06.28.16;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.14.07.46.39;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.15.49;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.25;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.05.16.12.48.31;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.20.01.50.08;	author assar;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.25.06.10.15;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.07.04.57.15;	author assar;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.05.31.17.34.44;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.08.21.23.03.15;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.02.08.22.41.31;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.11.10.23.57.05;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.17.23.09;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.58.01;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.01.20.15.49.53;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.08.23.19.11.00;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.06.10.07.25.19;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.05.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.14.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.26.14.18.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.24.09.37.02;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.05.23.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.38;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2001.04.18.16.00.04;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.07.04.10.14.16;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.03.28.11.26.44;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2003.03.27.22.28.24;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2004.02.19.10.51.21;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.27.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@really gone
@
text
@@


1.27
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@@


1.26
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@a0 758
/*	$OpenBSD: advfsops.c,v 1.25 2003/08/14 07:46:39 mickey Exp $	*/
/*	$NetBSD: advfsops.c,v 1.24 1996/12/22 10:10:12 cgd Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1996 Matthias Scheler
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/disklabel.h>
#include <sys/fcntl.h>
#include <sys/namei.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/buf.h>

#include <machine/endian.h>

#include <miscfs/specfs/specdev.h> /* XXX */
#include <adosfs/adosfs.h>

int	 adosfs_init(struct vfsconf *);
int	 adosfs_mount(struct mount *, const char *, void *, struct nameidata *,
    struct proc *);
int	 adosfs_start(struct mount *, int, struct proc *);
int	 adosfs_unmount(struct mount *, int, struct proc *);
int	 adosfs_root(struct mount *, struct vnode **);
int	 adosfs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int	 adosfs_statfs(struct mount *, struct statfs *, struct proc *);
int	 adosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	 adosfs_vget(struct mount *, ino_t, struct vnode **);
int	 adosfs_fhtovp(struct mount *, struct fid *, struct vnode **);

int	 adosfs_vptofh(struct vnode *, struct fid *);

int	 adosfs_mountfs(struct vnode *, struct mount *, struct proc *);
int	 adosfs_loadbitmap(struct adosfsmount *);

int
adosfs_mount(mp, path, data, ndp, p)
	struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
{
	struct vnode *devvp;
	struct adosfs_args args;
	struct adosfsmount *amp;
	size_t size;
	int error;
	mode_t accessmode;

	error = copyin(data, &args, sizeof(struct adosfs_args));
	if (error)
		return(error);
	
#if 0
	if (mp->mnt_flag & MNT_UPDATE)
		return (EOPNOTSUPP);
#endif
	if ((mp->mnt_flag & MNT_RDONLY) == 0)
		return (EROFS);
	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		amp = VFSTOADOSFS(mp);
		if (args.fspec == 0)
			return (vfs_export(mp, &amp->export, 
			    &args.export_info));
	}
	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
	if ((error = namei(ndp)) != 0)
		return (error);
	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		vrele(devvp);
		return (ENOTBLK);
	}
	if (major(devvp->v_rdev) >= nblkdev) {
		vrele(devvp);
		return (ENXIO);
	}
	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (p->p_ucred->cr_uid != 0) {
		accessmode = VREAD;
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			accessmode |= VWRITE;
		vn_lock(devvp, LK_EXCLUSIVE  | LK_RETRY, p);
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		if (error) {
			vput(devvp);
			return (error);
		}
		VOP_UNLOCK(devvp, 0, p);
	}
/* MNT_UPDATE? */
	if ((error = adosfs_mountfs(devvp, mp, p)) != 0) {
		vrele(devvp);
		return (error);
	}
	amp = VFSTOADOSFS(mp);
	amp->uid = args.uid;
	amp->gid = args.gid;
	amp->mask = args.mask;
	(void)copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	(void)copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	bcopy(&args, &mp->mnt_stat.mount_info.adosfs_args, sizeof(args));
	return (0);
}

int
adosfs_mountfs(devvp, mp, p)
	struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
{
	struct disklabel dl;
	struct partition *parp;
	struct adosfsmount *amp;
	struct buf *bp;
	struct vnode *rvp;
	int error, part, i;

	part = DISKPART(devvp->v_rdev);
	amp = NULL;

	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	if ((error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
		return (error);

	/* 
	 * open blkdev and read root block
	 */
	if ((error = VOP_OPEN(devvp, FREAD, NOCRED, p)) != 0)
		return (error);
	error = VOP_IOCTL(devvp, DIOCGDINFO,(caddr_t)&dl, FREAD, NOCRED, p);
	if (error)
		goto fail;

	parp = &dl.d_partitions[part];
	amp = malloc(sizeof(struct adosfsmount), M_ADOSFSMNT, M_WAITOK);
	bzero((char *)amp, sizeof(struct adosfsmount));
	amp->mp = mp;
	if (dl.d_type == DTYPE_FLOPPY) {
		amp->bsize = dl.d_secsize;
		amp->secsperblk = 1;
	}
	else {
		amp->bsize = DISKLABELV1_FFS_BSIZE(parp->fragblock);
		amp->secsperblk = DISKLABELV1_FFS_FRAG(parp->p_fragblock);
	}
	amp->rootb = (parp->p_size / amp->secsperblk - 1 + parp->p_cpg) >> 1;
	amp->numblks = parp->p_size / amp->secsperblk - parp->p_cpg;

	bp = NULL;
	if ((error = bread(devvp, (daddr_t)BBOFF,
			   amp->bsize, NOCRED, &bp)) != 0)
		goto fail;

	amp->dostype = adoswordn(bp, 0);
	brelse(bp);

	if (amp->dostype < 0x444f5300 || amp->dostype > 0x444f5305) {
		error = EINVAL;
		goto fail;
	}

	amp->nwords = amp->bsize >> 2;
	amp->dbsize = amp->bsize - (IS_FFS(amp) ? 0 : OFS_DATA_OFFSET);
	amp->devvp = devvp;
	
	mp->mnt_data = (qaddr_t)amp;
        mp->mnt_stat.f_fsid.val[0] = (int32_t)devvp->v_rdev;
        mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_ADOSFS);
	mp->mnt_flag |= MNT_LOCAL;
	devvp->v_specmountpoint = mp;

	/*
	 * init anode table.
	 */
	for (i = 0; i < ANODEHASHSZ; i++) 
		LIST_INIT(&amp->anodetab[i]);

	/*
	 * get the root anode, if not a valid fs this will fail.
	 */
	if ((error = VFS_ROOT(mp, &rvp)) != 0)
		goto fail;
	/* allocate and load bitmap, set free space */
	amp->bitmap = malloc(((amp->numblks + 31) / 32) * sizeof(*amp->bitmap),
	    M_ADOSFSBITMAP, M_WAITOK);
	adosfs_loadbitmap(amp);
	if (mp->mnt_flag & MNT_RDONLY && amp->bitmap) {
		/*
		 * Don't need the bitmap any more if it's read-only.
		 */
		free(amp->bitmap, M_ADOSFSBITMAP);
		amp->bitmap = NULL;
	}
	vput(rvp);

	return(0);

fail:
	(void) VOP_CLOSE(devvp, FREAD, NOCRED, p);
	if (amp && amp->bitmap)
		free(amp->bitmap, M_ADOSFSBITMAP);
	if (amp)
		free(amp, M_ADOSFSMNT);
	return (error);
}

int
adosfs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
{

	return (0);
}

int
adosfs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
{
	struct adosfsmount *amp;
	int error, flags;

	flags = 0;
	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;
	if ((error = vflush(mp, NULLVP, flags)) != 0)
		return (error);
	amp = VFSTOADOSFS(mp);
	amp->devvp->v_specmountpoint = NULL;
	error = VOP_CLOSE(amp->devvp, FREAD, NOCRED, p);
	vrele(amp->devvp);
	if (amp->bitmap)
		free(amp->bitmap, M_ADOSFSBITMAP);
	free(amp, M_ADOSFSMNT);
	mp->mnt_data = (qaddr_t)0;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (error);
}

int
adosfs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
{
	struct vnode *nvp;
	int error;

	if ((error = VFS_VGET(mp, ABLKTOINO(VFSTOADOSFS(mp)->rootb), &nvp)) !=
	    0)
		return (error);
	/* XXX verify it's a root block? */
	*vpp = nvp;
	return (0);
}

int
adosfs_statfs(mp, sbp, p)
	struct mount *mp;
	struct statfs *sbp;
	struct proc *p;
{
	struct adosfsmount *amp;

	amp = VFSTOADOSFS(mp);
	sbp->f_bsize = amp->bsize;
	sbp->f_iosize = amp->dbsize;
	sbp->f_blocks = amp->numblks;
	sbp->f_bfree = amp->freeblks;
	sbp->f_bavail = amp->freeblks;
	sbp->f_files = 0;		/* who knows */
	sbp->f_ffree = 0;		/* " " */
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.adosfs_args,
		    &sbp->mount_info.adosfs_args, sizeof(struct adosfs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
	return (0);
}

/* 
 * lookup an anode, check mount's hash table if not found, create
 * return locked and referenced al la vget(vp, 1);
 */
int
adosfs_vget(mp, an, vpp)
	struct mount *mp;
	ino_t an;
	struct vnode **vpp;
{
	struct adosfsmount *amp;
	struct vnode *vp;
	struct anode *ap;
	struct buf *bp;
	char *nam, *tmp;
	int namlen, error;

	error = 0;
	amp = VFSTOADOSFS(mp);
	bp = NULL;

	/* 
	 * check hash table. we are done if found
	 */
 retry:
	if ((*vpp = adosfs_ahashget(mp, an)) != NULL)
		return (0);

	error = getnewvnode(VT_ADOSFS, mp, adosfs_vnodeop_p, &vp);
	if (error)
		return (error);

	/*
	 * setup, insert in hash, and lock before io.
	 */
	vp->v_data = ap = malloc(sizeof(struct anode), M_ANODE, M_WAITOK);
	bzero(ap, sizeof(struct anode));
	lockinit(&ap->a_lock, PINOD, "anode", 0, 0);
	ap->vp = vp;
	ap->amp = amp;
	ap->block = AINOTOBLK(an);
	ap->nwords = amp->nwords;
	error = adosfs_ainshash(amp, ap);

	if (error) {
		vrele (vp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}

	if ((error = bread(amp->devvp, an * amp->secsperblk, amp->bsize,
	    NOCRED, &bp)) != 0) {
		vput(vp);
		return (error);
	}

	/*
	 * get type and fill rest in based on that.
	 */
	switch (ap->type = adosfs_getblktype(amp, bp)) {
	case AROOT:
		vp->v_type = VDIR;
		vp->v_flag |= VROOT;
		ap->mtimev.days = adoswordn(bp, ap->nwords - 10);
		ap->mtimev.mins = adoswordn(bp, ap->nwords - 9);
		ap->mtimev.ticks = adoswordn(bp, ap->nwords - 8);
		ap->created.days = adoswordn(bp, ap->nwords - 7);
		ap->created.mins = adoswordn(bp, ap->nwords - 6);
		ap->created.ticks = adoswordn(bp, ap->nwords - 5);
		break;
	case ALDIR:
	case ADIR:
		vp->v_type = VDIR;
		break;
	case ALFILE:
	case AFILE:
		vp->v_type = VREG;
		ap->fsize = adoswordn(bp, ap->nwords - 47);
		break;
	case ASLINK:		/* XXX soft link */
		vp->v_type = VLNK;
		/*
		 * convert from BCPL string and
		 * from: "part:dir/file" to: "/part/dir/file"
		 */
		nam = bp->b_data + (6 * sizeof(u_int32_t));
		namlen = strlen(nam);
		tmp = nam;
		while (*tmp && *tmp != ':')
			tmp++;
		if (*tmp == 0) {
			ap->slinkto = malloc(namlen + 1, M_ANODE, M_WAITOK);
			bcopy(nam, ap->slinkto, namlen);
		} else if (*nam == ':') {
			ap->slinkto = malloc(namlen + 1, M_ANODE, M_WAITOK);
			bcopy(nam, ap->slinkto, namlen);
			ap->slinkto[0] = '/';
		} else {
			ap->slinkto = malloc(namlen + 2, M_ANODE, M_WAITOK);
			ap->slinkto[0] = '/';
			bcopy(nam, &ap->slinkto[1], namlen);
			ap->slinkto[tmp - nam + 1] = '/';
			namlen++;
		}
		ap->slinkto[namlen] = 0;
		ap->fsize = namlen;
		break;
	default:
		brelse(bp);
		vput(vp);
		return (EINVAL);
	}

	/*
	 * Get appropriate data from this block;  hard link needs
	 * to get other data from the "real" block.
	 */

	/*
	 * copy in name (from original block)
	 */
	nam = bp->b_data + (ap->nwords - 20) * sizeof(u_int32_t);
	namlen = *(u_char *)nam++;
	if (namlen > 30) {
#ifdef DIAGNOSTIC
		printf("adosfs: aget: name length too long blk %d\n", an);
#endif
		brelse(bp);
		vput(vp);
		return (EINVAL);
	}
	bcopy(nam, ap->name, namlen);
	ap->name[namlen] = 0;

	/* 
	 * if dir alloc hash table and copy it in 
	 */
	if (vp->v_type == VDIR) {
		int i;

		ap->ntabent = ANODETABENT(ap);
		ap->tab = malloc(ap->ntabent * (sizeof(daddr_t) + sizeof(int)),
		    M_ANODE, M_WAITOK);
		ap->tabi = (int *)&ap->tab[ap->ntabent];
		bzero(ap->tabi, ANODETABENT(ap) * sizeof(int));
		for (i = 0; i < ap->ntabent; i++)
			ap->tab[i] = (daddr_t)adoswordn(bp, i + 6);
	}

	/*
	 * misc.
	 */
	ap->pblock = (daddr_t)adoswordn(bp, ap->nwords - 3);
	ap->hashf = (daddr_t)adoswordn(bp, ap->nwords - 4);
	ap->linknext = (daddr_t)adoswordn(bp, ap->nwords - 10);
	ap->linkto = (daddr_t)adoswordn(bp, ap->nwords - 11);

	/*
	 * setup last indirect block cache.
	 */
	ap->lastlindblk = 0;
	if (ap->type == AFILE)  {
		ap->lastindblk = ap->block;
		if (adoswordn(bp, ap->nwords - 10))
			ap->linkto = ap->block;
	} else if (ap->type == ALFILE) {
		ap->lastindblk = ap->linkto;
		brelse(bp);
		bp = NULL;
		error = bread(amp->devvp, ap->linkto * amp->secsperblk,
		    amp->bsize, NOCRED, &bp);
		ap->fsize = adoswordn(bp, ap->nwords - 47);
		/*
		 * Should ap->block be set to the real file header block?
		 */
		ap->block = ap->linkto;
	}

	if (ap->type == AROOT) {
		ap->adprot = 15;
		ap->uid = amp->uid;
		ap->gid = amp->gid;
	} else {
		ap->adprot = adoswordn(bp, ap->nwords - 48) ^ 15;
		/*
		 * Get uid/gid from extensions in file header
		 * (really need to know if this is a muFS partition)
		 */
		ap->uid = (adoswordn(bp, ap->nwords - 49) >> 16) & 0xffff;
		ap->gid = adoswordn(bp, ap->nwords - 49) & 0xffff;
		if (ap->uid || ap->gid) {
			if (ap->uid == 0xffff)
				ap->uid = 0;
			if (ap->gid == 0xffff)
				ap->gid = 0;
			ap->adprot |= 0x40000000;	/* Kludge */
		}
		else {
			/*
			 * uid & gid extension don't exist,
			 * so use the mount-point uid/gid
			 */
			ap->uid = amp->uid;
			ap->gid = amp->gid;
		}
	}
	ap->mtime.days = adoswordn(bp, ap->nwords - 23);
	ap->mtime.mins = adoswordn(bp, ap->nwords - 22);
	ap->mtime.ticks = adoswordn(bp, ap->nwords - 21);

	*vpp = vp;		/* return vp */
	brelse(bp);		/* release buffer */
	return (0);
}

/*
 * Load the bitmap into memory, and count the number of available
 * blocks.
 * The bitmap will be released if the filesystem is read-only;  it's
 * only needed to find the free space.
 */
int
adosfs_loadbitmap(amp)
	struct adosfsmount *amp;
{
	struct buf *bp, *mapbp;
	u_int32_t bits;
	daddr_t bn;
	int blkix, endix, mapix, bmsize, n;
	int error;

	bp = mapbp = NULL;
	bn = amp->rootb;
	if ((error = bread(amp->devvp, bn * amp->secsperblk, amp->bsize,
	    NOCRED, &bp)) != 0)
		return (error);
	blkix = amp->nwords - 49;
	endix = amp->nwords - 24;
	mapix = 0;
	bmsize = (amp->numblks + 31) / 32;
	while (mapix < bmsize) {
		if (adoswordn(bp, blkix) == 0)
			break;
		if (mapbp != NULL)
			brelse(mapbp);
		if ((error = bread(amp->devvp,
		    adoswordn(bp, blkix) * amp->secsperblk, amp->bsize,
		     NOCRED, &mapbp)) != 0)
			break;
		if (adoscksum(mapbp, amp->nwords)) {
#ifdef DIAGNOSTIC
			printf("adosfs: loadbitmap - cksum of blk %d failed\n",
			    adoswordn(bp, blkix));
#endif
			/* XXX Force read-only?  Set free space 0? */
			break;
		}
		n = 1;
		while (n < amp->nwords && mapix < bmsize) {
			amp->bitmap[mapix++] = bits = adoswordn(mapbp, n);
			++n;
			if (mapix == bmsize && amp->numblks & 31)
				bits &= ~(0xffffffff << (amp->numblks & 31));
			while (bits) {
				if (bits & 1)
					++amp->freeblks;
				bits >>= 1;
			}
		}
		++blkix;
		if (mapix < bmsize && blkix == endix) {
			bn = (daddr_t)adoswordn(bp, blkix);
			brelse(bp);
			if ((error = bread(amp->devvp, bn * amp->secsperblk,
			    amp->bsize, NOCRED, &bp)) != 0)
				break;
			/*
			 * Why is there no checksum on these blocks?
			 */
			blkix = 0;
			endix = amp->nwords - 1;
		}
	}
	if (bp)
		brelse(bp);
	if (mapbp)
		brelse(mapbp);
	return (error);
}


/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles:
 * - check that the inode number is in range
 * - call iget() to get the locked inode
 * - check for an unallocated inode (i_mode == 0)
 * - check that the generation number matches
 */

/*
 * This is using the same layout as struct fid from mount.h for the first two
 * fields.
 */
struct ifid {
	u_short	ifid_len;
	u_short	ifid_pad;
	ino_t	ifid_ino;
	daddr_t	ifid_start;
};

int
adosfs_fhtovp(mp, fhp, vpp)
	struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
{
	struct ifid *ifhp = (struct ifid *)fhp;
#if 0
	struct anode *ap;
#endif
	struct vnode *nvp;
	int error;

#ifdef ADOSFS_DIAGNOSTIC
	printf("adfhtovp(%x, %x, %x)\n", mp, fhp, vpp);
#endif
	
	if ((error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
#if 0
	ap = VTOA(nvp);
	if (ap->inode.iso_mode == 0) {
		vput(nvp);
		*vpp = NULLVP;
		return (ESTALE);
	}
#endif
	*vpp = nvp;
	return(0);
}

int
adosfs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{
	struct anode *ap = VTOA(vp);
	struct ifid *ifhp;

	ifhp = (struct ifid *)fhp;
	ifhp->ifid_len = sizeof(struct ifid);
	
	ifhp->ifid_ino = ABLKTOINO(ap->block);
	ifhp->ifid_start = ap->block;
	
#ifdef ADOSFS_DIAGNOSTIC
	printf("advptofh(%x, %x)\n", vp, fhp);
#endif
	return(0);
}

int
adosfs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{
	return(EOPNOTSUPP);
}

int
adosfs_sync(mp, waitfor, uc, p)
	struct mount *mp;
	int waitfor;
	struct ucred *uc;
	struct proc *p;
{
#ifdef ADOSFS_DIAGNOSTIC
	printf("ad_sync(%x, %x)\n", mp, waitfor);
#endif
	return(0);
}

int
adosfs_init(struct vfsconf *vfsp)
{
	return (0);
}

/*
 * vfs generic function call table
 */
const struct vfsops adosfs_vfsops = {
	adosfs_mount,
	adosfs_start,
	adosfs_unmount,
	adosfs_root,
	adosfs_quotactl,                
	adosfs_statfs,                  
	adosfs_sync,                    
	adosfs_vget,
	adosfs_fhtovp,                  
	adosfs_vptofh,                  
	adosfs_init,                    
};           
@


1.25
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.24 2002/04/23 18:54:12 espie Exp $	*/
d203 2
a204 2
		amp->bsize = parp->p_fsize * parp->p_frag;
		amp->secsperblk = parp->p_frag;
@


1.24
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.23 2002/03/14 03:15:49 millert Exp $	*/
d746 1
a746 1
struct vfsops adosfs_vfsops = {
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.22 2002/03/14 01:26:25 millert Exp $	*/
d102 2
a103 1
			return (vfs_export(mp, &amp->export, &args.export));
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.21 2001/12/19 08:58:05 art Exp $	*/
d59 1
a59 2
int	 adosfs_quotactl(struct mount *, int, uid_t, caddr_t,
    struct proc *);
@


1.21
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.19 2001/05/16 12:48:31 ho Exp $	*/
d53 12
a64 12
int	 adosfs_init __P((struct vfsconf *));
int	 adosfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
    struct proc *));
int	 adosfs_start __P((struct mount *, int, struct proc *));
int	 adosfs_unmount __P((struct mount *, int, struct proc *));
int	 adosfs_root __P((struct mount *, struct vnode **));
int	 adosfs_quotactl __P((struct mount *, int, uid_t, caddr_t,
    struct proc *));
int	 adosfs_statfs __P((struct mount *, struct statfs *, struct proc *));
int	 adosfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	 adosfs_vget __P((struct mount *, ino_t, struct vnode **));
int	 adosfs_fhtovp __P((struct mount *, struct fid *, struct vnode **));
d66 1
a66 1
int	 adosfs_vptofh __P((struct vnode *, struct fid *));
d68 2
a69 2
int	 adosfs_mountfs __P((struct vnode *, struct mount *, struct proc *));
int	 adosfs_loadbitmap __P((struct adosfsmount *));
@


1.20
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@a559 1
	vp->v_size = ap->fsize;
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.20 2001/12/10 04:45:31 art Exp $	*/
d53 12
a64 11
int	 adosfs_init(struct vfsconf *);
int	 adosfs_mount(struct mount *, const char *, void *, struct nameidata *,
    struct proc *);
int	 adosfs_start(struct mount *, int, struct proc *);
int	 adosfs_unmount(struct mount *, int, struct proc *);
int	 adosfs_root(struct mount *, struct vnode **);
int	 adosfs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int	 adosfs_statfs(struct mount *, struct statfs *, struct proc *);
int	 adosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	 adosfs_vget(struct mount *, ino_t, struct vnode **);
int	 adosfs_fhtovp(struct mount *, struct fid *, struct vnode **);
d66 1
a66 1
int	 adosfs_vptofh(struct vnode *, struct fid *);
d68 2
a69 2
int	 adosfs_mountfs(struct vnode *, struct mount *, struct proc *);
int	 adosfs_loadbitmap(struct adosfsmount *);
d103 1
a103 2
			return (vfs_export(mp, &amp->export, 
			    &args.export_info));
@


1.19
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.18 2001/02/20 01:50:08 assar Exp $	*/
d560 1
@


1.18
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.17 2000/04/25 06:10:15 niklas Exp $	*/
d246 1
a246 2
	if (amp->bitmap)
		adosfs_loadbitmap(amp);
@


1.17
log
@From Assar: make adosfs compile, I was supposed
to commit this long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.16 2000/02/07 04:57:15 assar Exp $	*/
d54 1
a54 1
int	 adosfs_mount __P((struct mount *, const char *, caddr_t, struct nameidata *,
d75 1
a75 1
	caddr_t data;
d86 1
a86 1
	error = copyin(data, (caddr_t)&args, sizeof(struct adosfs_args));
@


1.16
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.15 1999/05/31 17:34:44 millert Exp $	*/
a667 1
	struct adosfsmount *amp = VFSTOADOSFS(mp);
a670 1
	struct netcred *np;
a690 2
	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
@


1.16.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.18 2001/02/20 01:50:08 assar Exp $	*/
d54 1
a54 1
int	 adosfs_mount __P((struct mount *, const char *, void *, struct nameidata *,
d75 1
a75 1
	void *data;
d86 1
a86 1
	error = copyin(data, &args, sizeof(struct adosfs_args));
d668 1
d672 1
d693 2
@


1.16.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.16.2.1 2001/04/18 16:00:04 niklas Exp $	*/
d246 2
a247 1
	adosfs_loadbitmap(amp);
@


1.16.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 12
a64 11
int	 adosfs_init(struct vfsconf *);
int	 adosfs_mount(struct mount *, const char *, void *, struct nameidata *,
    struct proc *);
int	 adosfs_start(struct mount *, int, struct proc *);
int	 adosfs_unmount(struct mount *, int, struct proc *);
int	 adosfs_root(struct mount *, struct vnode **);
int	 adosfs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int	 adosfs_statfs(struct mount *, struct statfs *, struct proc *);
int	 adosfs_sync(struct mount *, int, struct ucred *, struct proc *);
int	 adosfs_vget(struct mount *, ino_t, struct vnode **);
int	 adosfs_fhtovp(struct mount *, struct fid *, struct vnode **);
d66 1
a66 1
int	 adosfs_vptofh(struct vnode *, struct fid *);
d68 2
a69 2
int	 adosfs_mountfs(struct vnode *, struct mount *, struct proc *);
int	 adosfs_loadbitmap(struct adosfsmount *);
@


1.16.2.4
log
@Sync the SMP branch with 3.3
@
text
@d102 1
a102 2
			return (vfs_export(mp, &amp->export, 
			    &args.export_info));
@


1.16.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d746 1
a746 1
const struct vfsops adosfs_vfsops = {
@


1.15
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.14 1998/08/21 23:03:15 csapuntz Exp $	*/
d64 2
a65 2
int	 adosfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
    struct vnode **, int *, struct ucred **));
d662 1
a662 1
adosfs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a664 1
	struct mbuf *nam;
a665 2
	int *exflagsp;
	struct ucred **credanonp;
a679 7
	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &amp->export, nam);
	if (np == NULL)
		return (EACCES);

@


1.14
log
@

Fix malloc race on new anode get.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.13 1998/02/08 22:41:31 tholo Exp $	*/
d152 1
a328 1
	sbp->f_type = 0;
a336 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
d339 2
@


1.13
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.12 1997/11/10 23:57:05 niklas Exp $	*/
d369 1
d387 10
a396 1
	adosfs_ainshash(amp, ap);
@


1.12
log
@Use vfs lite2 lockmanager.  Add advisory locking.  some KNF.
some extra pathconf ops supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.11 1997/11/06 17:23:09 csapuntz Exp $	*/
d54 1
a54 1
int	 adosfs_mount __P((struct mount *, char *, caddr_t, struct nameidata *,
d74 1
a74 1
	char *path;
@


1.11
log
@More fixes for adosfs so it compiles with VFS Lite 2
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.10 1997/11/06 05:58:01 csapuntz Exp $	*/
d48 2
d147 1
a147 1
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
d149 1
a149 1
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
d381 1
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.9 1997/01/20 15:49:53 niklas Exp $	*/
d227 1
a227 1
	devvp->v_specflags |= SI_MOUNTEDON;
d290 1
a290 1
	amp->devvp->v_specflags &= ~SI_MOUNTEDON;
d741 1
a747 1
	MOUNT_ADOSFS,
@


1.9
log
@Type pedantery.. a lot of it too, more could be done as well.  Sync with
NetBSD 970118 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.8 1996/08/23 19:11:00 niklas Exp $	*/
d51 1
a51 1
void	 adosfs_init __P((void));
d128 1
a128 1
		VOP_LOCK(devvp);
d134 1
a134 1
		VOP_UNLOCK(devvp);
d335 1
d339 1
a339 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d738 2
a739 2
void
adosfs_init()
@


1.8
log
@Some style and signedness pedantery
@
text
@d1 2
a2 2
/*	$OpenBSD: advfsops.c,v 1.7 1996/06/10 07:25:19 deraadt Exp $	*/
/*	$NetBSD: advfsops.c,v 1.19.4.1 1996/05/27 10:21:30 is Exp $	*/
a41 1
#include <miscfs/specfs/specdev.h> /* XXX */
d47 2
d51 14
a64 13
void adosfs_init __P((void));
int adosfs_mount __P((struct mount *, char *, caddr_t, struct nameidata *,
		      struct proc *));
int adosfs_start __P((struct mount *, int, struct proc *));
int adosfs_unmount __P((struct mount *, int, struct proc *));
int adosfs_root __P((struct mount *, struct vnode **));
int adosfs_quotactl __P((struct mount *, int, uid_t, caddr_t, struct proc *));
int adosfs_statfs __P((struct mount *, struct statfs *, struct proc *));
int adosfs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int adosfs_vget __P((struct mount *, ino_t, struct vnode **));
int adosfs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
		       struct vnode **, int *, struct ucred **));
int adosfs_vptofh __P((struct vnode *, struct fid *));
d66 2
a67 2
int adosfs_mountfs __P((struct vnode *, struct mount *, struct proc *));
int adosfs_loadbitmap __P((struct adosfsmount *));
d193 1
a193 1
	bzero((char *)amp, (u_long)sizeof(struct adosfsmount));
d224 1
a224 1
        mp->mnt_stat.f_fsid.val[0] = (long)devvp->v_rdev;
d309 2
a310 1
	if ((error = VFS_VGET(mp, (ino_t)VFSTOADOSFS(mp)->rootb, &nvp)) != 0)
d380 1
a380 1
	ap->block = an;
d384 2
a385 2
	if ((error = bread(amp->devvp, an * amp->secsperblk,
			   amp->bsize, NOCRED, &bp)) != 0) {
d419 1
a419 1
		nam = bp->b_data + (6 * sizeof(long));
a473 1
		ap->tab = malloc(ANODETABSZ(ap) * 2, M_ANODE, M_WAITOK);
d475 2
d478 1
a478 1
		bzero(ap->tabi, ANODETABSZ(ap));
d480 1
a480 1
			ap->tab[i] = adoswordn(bp, i + 6);
d486 4
a489 4
	ap->pblock = adoswordn(bp, ap->nwords - 3);
	ap->hashf = adoswordn(bp, ap->nwords - 4);
	ap->linknext = adoswordn(bp, ap->nwords - 10);
	ap->linkto = adoswordn(bp, ap->nwords - 11);
d560 3
a562 3
	u_long bits, bn, n;
	int blkix, endix, mapix;
	int bmsize;
d586 1
a586 1
				adoswordn(bp, blkix));
d605 1
a605 1
			bn = adoswordn(bp, blkix);
d635 4
d640 4
a643 4
	ushort	ifid_len;
	ushort	ifid_pad;
	int	ifid_ino;
	long	ifid_start;
d704 1
a704 1
	ifhp->ifid_ino = ap->block;
@


1.7
log
@internationalize, 64 bit clean
@
text
@d1 1
a1 1
/*	$OpenBSD: advfsops.c,v 1.5 1996/04/21 22:14:39 deraadt Exp $	*/
d556 1
a556 1
	u_long bn;
a570 3
		int n;
		u_long bits;

@


1.6
log
@sync with netbsd
@
text
@d2 1
a2 1
/*	$NetBSD: advfsops.c,v 1.19 1996/04/28 06:18:12 mhitch Exp $	*/
d452 1
a452 1
	nam = bp->b_data + (ap->nwords - 20) * sizeof(long);
d584 2
a585 2
			printf("adosfs: loadbitmap - cksum of blk %ld failed\n",
			    adoswordn(bp, blkix));
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: advfsops.c,v 1.4 1996/02/26 14:18:20 niklas Exp $	*/
/*	$NetBSD: advfsops.c,v 1.14.2.1 1995/11/10 16:05:16 chopps Exp $	*/
d436 1
d584 1
a584 1
			printf("adosfs: loadbitmap - cksum of blk %d failed\n",
@


1.4
log
@Addition of $OpenBSD$ RCSID.
From NetBSD: Rename struct timespec fields to conform to POSIX.1b
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
d65 1
d160 1
d193 24
a216 3
	amp->startb = parp->p_offset;
	amp->endb = parp->p_offset + parp->p_size;
	amp->bsize = dl.d_secsize;
d218 1
a219 2
/*	amp->rootb = (parp->p_size - 1 + 2) >> 1;*/
	amp->rootb = (parp->p_size - 1 + parp->p_cpg) >> 1;
d238 12
d256 2
d291 2
d309 1
d325 4
a328 4
	sbp->f_iosize = amp->bsize;
	sbp->f_blocks = 2;		/* XXX */
	sbp->f_bfree = 0;		/* none */
	sbp->f_bavail = 0;		/* none */
d354 1
a354 1
	int namlen, error, tmplen;
d381 2
a382 1
	if ((error = bread(amp->devvp, an, amp->bsize, NOCRED, &bp)) != 0) {
a401 2
		vp->v_type = VDIR;
		break;
a405 3
		vp->v_type = VREG;
		ap->fsize = adoswordn(bp, ap->nwords - 47);
		break;
d417 1
a417 1
		tmplen = namlen = *(u_char *)nam++;
d419 1
a419 1
		while (tmplen-- && *tmp != ':')
d442 22
d490 1
a490 1
	if (ap->type == AFILE) 
d492 3
a494 1
	else if (ap->type == ALFILE)
d496 10
d508 1
a508 1
		ap->adprot = 0;
d512 1
a512 1
		ap->adprot = adoswordn(bp, ap->nwords - 48);
d539 43
a581 6
	/*
	 * copy in name
	 */
	nam = bp->b_data + (ap->nwords - 20) * sizeof(long);
	namlen = *(u_char *)nam++;
	if (namlen > 30) {
d583 2
a584 1
		printf("adosfs: aget: name length too long blk %d\n", an);
d586 30
d617 3
a619 9
		vput(vp);
		return (EINVAL);
	}
	bcopy(nam, ap->name, namlen);
	ap->name[namlen] = 0;

	*vpp = vp;		/* return vp */
	brelse(bp);		/* release buffer */
	return (0);
@


1.3
log
@Add forward decls.
Fix vop_link, vop_symlink, and vop_remove semantics in several ways:
* Change the argument names to vop_link so they actually make sense.
* Implement vop_link and vop_symlink for all file systems, so they do proper
  cleanup.
* Require the file system to decide whether or not linking and unlinking of
  directories is allowed, and disable it for all current file systems.
Adosfs prototyping changes.  Compiler warning police.
@
text
@d1 1
@


1.2
log
@bzero adosfsmount so that mountd delete does not crash machine; from osymh@@gemini.oscs.montana.edu; netbsd pr#1720
@
text
@d48 16
d79 2
a80 1
	if (error = copyin(data, (caddr_t)&args, sizeof(struct adosfs_args)))
d103 1
a103 1
	if (error = namei(ndp))
d124 2
a125 1
		if (error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p)) {
d132 1
a132 1
	if (error = adosfs_mountfs(devvp, mp, p)) {
d169 1
a169 1
	if (error = vfs_mountedon(devvp))
d173 1
a173 1
	if (error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0))
d179 1
a179 1
	if (error = VOP_OPEN(devvp, FREAD, NOCRED, p))
d181 2
a182 1
	if (error = VOP_IOCTL(devvp, DIOCGDINFO,(caddr_t)&dl, FREAD, NOCRED, p))
d212 1
a212 1
	if (error = VFS_ROOT(mp, &rvp))
d247 1
a247 1
	if (error = vflush(mp, NULLVP, flags))
d267 1
a267 1
	if (error = VFS_VGET(mp, (ino_t)VFSTOADOSFS(mp)->rootb, &nvp))
d322 1
a322 1
	if (*vpp = adosfs_ahashget(mp, an))
d325 2
a326 1
	if (error = getnewvnode(VT_ADOSFS, mp, adosfs_vnodeop_p, &vp))
d340 1
a340 1
	if (error = bread(amp->devvp, an, amp->bsize, NOCRED, &bp)) {
d518 1
d520 1
d536 1
a536 1
	if (error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) {
d586 1
a586 1
adosfs_sync(mp, waitfor)
d589 2
d598 1
a598 1
int
a600 1
	return(0);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: advfsops.c,v 1.14 1995/08/18 15:14:37 chopps Exp $	*/
d168 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
