head	1.37;
access;
symbols
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.30.0.8
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.24
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_8:1.15.0.12
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.10
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.8
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.6
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2007.06.01.08.04.59;	author deraadt;	state dead;
branches;
next	1.36;

1.36
date	2007.06.01.05.37.12;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.21.17.29.31;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.20.23.27.24;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2003.12.21.15.28.59;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.13.17.23.57;	author drahn;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.13.17.19.40;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.17.18.25.06;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.23.16.51.11;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.24.22.00.24;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.23.13.40.50;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.25;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.08.58.05;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.04.22.44.31;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.02.14.21;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.23.14.42.37;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	98.08.21.23.03.16;	author csapuntz;	state Exp;
branches
	1.15.8.1;
next	1.14;

1.14
date	98.08.21.22.04.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.08.06.19.34.18;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	98.07.20.00.49.21;	author espie;	state Exp;
branches;
next	1.11;

1.11
date	97.11.10.23.57.06;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.17.23.09;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.58.01;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.01.20.15.49.54;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.13.21.17.39;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.08.23.19.11.02;	author niklas;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	96.05.02.13.05.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.14.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.26.14.18.21;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.24.09.37.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.38;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.13.21.26.49;	author niklas;	state Exp;
branches;
next	;

1.15.8.1
date	2001.04.18.16.00.04;	author niklas;	state Exp;
branches;
next	1.15.8.2;

1.15.8.2
date	2001.07.04.10.14.17;	author niklas;	state Exp;
branches;
next	1.15.8.3;

1.15.8.3
date	2001.12.05.00.39.08;	author niklas;	state Exp;
branches;
next	1.15.8.4;

1.15.8.4
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.15.8.5;

1.15.8.5
date	2002.03.28.11.26.44;	author niklas;	state Exp;
branches;
next	1.15.8.6;

1.15.8.6
date	2003.03.27.22.28.24;	author niklas;	state Exp;
branches;
next	1.15.8.7;

1.15.8.7
date	2004.02.19.10.51.21;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.06.11.03.27.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@really gone
@
text
@@


1.36
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@@


1.35
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@a0 1077
/*	$OpenBSD: advnops.c,v 1.34 2007/03/21 17:29:31 thib Exp $	*/
/*	$NetBSD: advnops.c,v 1.32 1996/10/13 02:52:09 christos Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1996 Matthias Scheler
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/lockf.h>
#include <sys/mount.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/dirent.h>
#include <sys/malloc.h>
#include <sys/stat.h>
#include <sys/unistd.h>
#include <sys/poll.h>
#include <sys/proc.h>

#include <machine/endian.h>

#include <miscfs/specfs/specdev.h>
#include <adosfs/adosfs.h>

int	adosfs_advlock(void *);
int	adosfs_open(void *);
int	adosfs_getattr(void *);
int	adosfs_read(void *);
int	adosfs_write(void *);
int	adosfs_ioctl(void *);
int	adosfs_poll(void *);
int	adosfs_strategy(void *);
int	adosfs_link(void *);
int	adosfs_symlink(void *);
int	adosfs_lock(void *);
int	adosfs_unlock(void *);
int	adosfs_bmap(void *);
int	adosfs_print(void *);
int	adosfs_readdir(void *);
int	adosfs_access(void *);
int	adosfs_readlink(void *);
int	adosfs_inactive(void *);
int	adosfs_islocked(void *);
int	adosfs_reclaim(void *);
int	adosfs_pathconf(void *);
int	adnullop(void *);
int	adenotsup(void *);

#define adosfs_close 		adnullop
#define adosfs_fsync 		adnullop
#define adosfs_bwrite 		adenotsup
#define adosfs_create 		adenotsup
#define adosfs_mkdir 		adenotsup
#define adosfs_mknod 		adenotsup
#define adosfs_remove 		adenotsup
#define adosfs_rename 		adenotsup
#define adosfs_rmdir 		adenotsup
#define adosfs_setattr 		adenotsup

struct vnodeopv_entry_desc adosfs_vnodeop_entries[] = {
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, adosfs_lookup },		/* lookup */
	{ &vop_create_desc, adosfs_create },		/* create */
	{ &vop_mknod_desc, adosfs_mknod },		/* mknod */
	{ &vop_open_desc, adosfs_open },		/* open */
	{ &vop_close_desc, adosfs_close },		/* close */
	{ &vop_access_desc, adosfs_access },		/* access */
	{ &vop_getattr_desc, adosfs_getattr },		/* getattr */
	{ &vop_setattr_desc, adosfs_setattr },		/* setattr */
	{ &vop_read_desc, adosfs_read },		/* read */
	{ &vop_write_desc, adosfs_write },		/* write */
	{ &vop_ioctl_desc, adosfs_ioctl },		/* ioctl */
	{ &vop_poll_desc, adosfs_poll },		/* poll */
	{ &vop_fsync_desc, adosfs_fsync },		/* fsync */
	{ &vop_remove_desc, adosfs_remove },		/* remove */
	{ &vop_link_desc, adosfs_link },		/* link */
	{ &vop_rename_desc, adosfs_rename },		/* rename */
	{ &vop_mkdir_desc, adosfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, adosfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc, adosfs_symlink },		/* symlink */
	{ &vop_readdir_desc, adosfs_readdir },		/* readdir */
	{ &vop_readlink_desc, adosfs_readlink },	/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },		/* abortop */
	{ &vop_inactive_desc, adosfs_inactive },	/* inactive */
	{ &vop_reclaim_desc, adosfs_reclaim },		/* reclaim */
	{ &vop_lock_desc, adosfs_lock },		/* lock */
	{ &vop_unlock_desc, adosfs_unlock },		/* unlock */
	{ &vop_bmap_desc, adosfs_bmap },		/* bmap */
	{ &vop_strategy_desc, adosfs_strategy },	/* strategy */
	{ &vop_print_desc, adosfs_print },		/* print */
	{ &vop_islocked_desc, adosfs_islocked },	/* islocked */
	{ &vop_pathconf_desc, adosfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc, adosfs_advlock },		/* advlock */
	{ &vop_bwrite_desc, adosfs_bwrite },		/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
};

int	(**adosfs_vnodeop_p)(void *);

struct vnodeopv_desc adosfs_vnodeop_opv_desc =
	{ &adosfs_vnodeop_p, adosfs_vnodeop_entries };

int
adosfs_open(v)
	void *v;
{
#ifdef ADOSFS_DIAGNOSTIC
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *sp = v;
	advopprint(sp);
	printf(" 0)");
#endif
	return(0);
}

int
adosfs_getattr(v)
	void *v;
{
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *sp = v;
	struct vattr *vap;
	struct adosfsmount *amp;
	struct anode *ap;
	u_int32_t fblks;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	vap = sp->a_vap;
	ap = VTOA(sp->a_vp);
	amp = ap->amp;
	vattr_null(vap);
	vap->va_uid = ap->uid;
	vap->va_gid = ap->gid;
	vap->va_fsid = sp->a_vp->v_mount->mnt_stat.f_fsid.val[0];
	vap->va_atime.tv_sec = vap->va_mtime.tv_sec = vap->va_ctime.tv_sec =
		ap->mtime.days * 24 * 60 * 60 + ap->mtime.mins * 60 +
		ap->mtime.ticks / 50 + (8 * 365 + 2) * 24 * 60 * 60;
	vap->va_atime.tv_nsec = vap->va_mtime.tv_nsec = vap->va_ctime.tv_nsec = 0;
	vap->va_gen = 0;
	vap->va_flags = 0;
	vap->va_rdev = NODEV;
	vap->va_fileid = (long)ap->block;
	vap->va_type = sp->a_vp->v_type;
	vap->va_mode = amp->mask & adunixprot(ap->adprot);
	if (sp->a_vp->v_type == VDIR) {
		vap->va_nlink = 1;	/* XXX bogus, oh well */
		vap->va_bytes = amp->bsize;
		vap->va_size = amp->bsize;
	} else {
		/* 
		 * XXX actually we can track this if we were to walk the list
		 * of links if it exists.
		 * XXX for now, just set nlink to 2 if this is a hard link
		 * to a file, or a file with a hard link.
		 */
		vap->va_nlink = 1 + (ap->linkto != 0);
		/*
		 * round up to nearest blocks add number of file list 
		 * blocks needed and multiply by number of bytes per block.
		 */
		fblks = howmany(ap->fsize, amp->dbsize);
		fblks += howmany(fblks, ANODENDATBLKENT(ap));
		vap->va_bytes = fblks * amp->dbsize;
		vap->va_size = (off_t)ap->fsize;

		vap->va_blocksize = amp->dbsize;
	}
#ifdef ADOSFS_DIAGNOSTIC
	printf(" 0)");
#endif
	return(0);
}
/*
 * are things locked??? they need to be to avoid this being 
 * deleted or changed (data block pointer blocks moving about.)
 */
int
adosfs_read(v)
	void *v;
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *sp = v;
	struct adosfsmount *amp;
	struct anode *ap;
	struct uio *uio;
	struct buf *bp;
	daddr_t lbn;
	int size, error, n, on;
	u_int32_t off;
	int64_t diff;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	error = 0;
	uio = sp->a_uio;
	ap = VTOA(sp->a_vp);
	amp = ap->amp;	
	/*
	 * Return EOF for character devices, EIO for others
	 */
	if (sp->a_vp->v_type != VREG) {
		error = EIO;
		goto reterr;
	}
	if (uio->uio_resid == 0)
		goto reterr;
	if (uio->uio_offset < 0 || uio->uio_offset > UINT_MAX) { /* XXX */
		error = EINVAL;
		goto reterr;
	}
	off = (u_int32_t)uio->uio_offset;

	/*
	 * to expensive to let general algorithm figure out that 
	 * we are beyond the file.  Do it now.
	 */
	if (off >= ap->fsize)
		goto reterr;

	/*
	 * taken from ufs_read()
	 */
	do {
		/*
		 * we are only supporting ADosFFS currently
		 * (which have data blocks without headers)
		 */
		size = amp->dbsize;
		lbn = off / size;
		on = off % size;
		n = min((u_int32_t)(size - on), uio->uio_resid);
		diff = ap->fsize - off;
		/* 
		 * check for EOF
		 */
		if (diff <= 0)
			return(0);
		if (diff < n)
			n = (int)diff;
		/*
		 * read ahead could possibly be worth something
		 * but not much as ados makes little attempt to 
		 * make things contiguous
		 */
		error = bread(sp->a_vp, lbn * amp->secsperblk, amp->bsize,
		    NOCRED, &bp);

		if (!IS_FFS(amp)) {
			if (bp->b_resid > 0)
				error = EIO; /* OFS needs the complete block */
			else if (adoswordn(bp, 0) != BPT_DATA) {
#ifdef DIAGNOSTIC
				printf("adosfs: bad primary type blk %d\n",
				    bp->b_blkno / amp->secsperblk);
#endif
				error=EINVAL;
			}
			else if (adoscksum(bp, ap->nwords)) {
#ifdef DIAGNOSTIC
				printf("adosfs: blk %u failed cksum.\n",
				    bp->b_blkno / amp->secsperblk);
#endif
				error=EINVAL;
			}
		}

		if (error) {
			brelse(bp);
			goto reterr;
		}
#ifdef ADOSFS_DIAGNOSTIC
		printf(" %u+%u-%u+%u", lbn, on, lbn, n);
#endif
		n = min(n, size - bp->b_resid);	/* XXX check types */
		error = uiomove(bp->b_data + on + amp->bsize -
		    amp->dbsize, n, uio);
		brelse(bp);
		off = (u_int32_t)uio->uio_offset;
	} while (error == 0 && uio->uio_resid > 0 && n != 0);
reterr:
#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", error);
#endif
	return(error);
}

int
adosfs_write(v)
	void *v;
{
#ifdef ADOSFS_DIAGNOSTIC
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *sp = v;
	advopprint(sp);
	printf(" EOPNOTSUPP)");
#endif
	return(EOPNOTSUPP);
}

/*
 * Device ioctl operation.
 */
/* ARGSUSED */
int
adosfs_ioctl(v)
	void *v;
{
#ifdef ADOSFS_DIAGNOSTIC
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *sp = v;
	advopprint(sp);
	printf(" ENOTTY)");
#endif
	return(ENOTTY);
}

/* ARGSUSED */
int
adosfs_poll(v)
	void *v;
{
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
#ifdef ADOSFS_DIAGNOSTIC
	/*
	 * sure there's something to read...
	 */
	advopprint(sp);
	printf(" %d",
	    ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
#endif
	return(ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

/*
 * Just call the device strategy routine
 */
int
adosfs_strategy(v)
	void *v;
{
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *sp = v;
	struct buf *bp;
	struct anode *ap;
	struct vnode *vp;
	int error;
	int s;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	error = 0;
	bp = sp->a_bp;
	if (bp->b_vp == NULL) {
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
		error = EIO;
		goto reterr;
	}
	vp = bp->b_vp;
	ap = VTOA(vp);
	if (bp->b_blkno == bp->b_lblkno) {
		error = VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL);
		if (error) {
			bp->b_flags |= B_ERROR;
			s = splbio();
			biodone(bp);
			splx(s);
			goto reterr;
		}
	}
#if 0
	if (bp->b_blkno == UINT_MAX) {	/* XXX huh? (was (long)... == -1 */
		biodone(bp);
		error = 0;
		goto reterr;
	}
#endif
	vp = ap->amp->devvp;
	bp->b_dev = vp->v_rdev;
	VOCALL(vp->v_op, VOFFSET(vop_strategy), sp);
reterr:
#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", error);
#endif
	return(error);
}

int
adosfs_link(v) 
	void *v;
{
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;  
		struct componentname *a_cnp;
	} */ *ap = v;
 
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
adosfs_symlink(v)
	void *v;
{
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
  
	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

/*
 * lock the anode
 */
int
adosfs_lock(v)
	void *v;
{
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	int rv;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(ap);
#endif

	rv = lockmgr(&VTOA(vp)->a_lock, ap->a_flags, NULL);

#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", rv);
#endif
	return (rv);
}

/*
 * unlock an anode
 */
int
adosfs_unlock(v)
	void *v;
{
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	int rv;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(ap);
#endif

	rv = lockmgr(&VTOA(vp)->a_lock, ap->a_flags | LK_RELEASE, NULL);

#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", rv);
#endif
	return (rv);
}

/*
 * Wait until the vnode has finished changing state.
 */
int
adosfs_bmap(v)
	void *v;
{
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *sp = v;
	struct anode *ap;
	struct buf *flbp;
	daddr_t *bnp, bn, nb, flblk, fcnt;
	int error, flblkoff; 

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	ap = VTOA(sp->a_vp);
	bn = sp->a_bn / ap->amp->secsperblk;
	bnp = sp->a_bnp;
	error = 0;

	if (sp->a_vpp != NULL)
		*sp->a_vpp = ap->amp->devvp;
	if (bnp == NULL)
		goto reterr;
	if (bn < 0) {
		error = EFBIG;
		goto reterr;
	}
	if (sp->a_vp->v_type != VREG) {
		error = EINVAL;
		goto reterr;
	}

	/*
	 * walk the chain of file list blocks until we find
	 * the one that will yield the block pointer we need.
	 */
	if (ap->type == AFILE)
		nb = ap->block;			/* pointer to ourself */
	else if (ap->type == ALFILE)
		nb = ap->linkto;		/* pointer to real file */
	else {
		error = EINVAL;
		goto reterr;
	}

	flblk = bn / ANODENDATBLKENT(ap);
	flbp = NULL;

	/*
	 * check last indirect block cache
	 */
	if (flblk < ap->lastlindblk) 
		fcnt = 0;
	else {
		flblk -= ap->lastlindblk;
		fcnt = ap->lastlindblk;
		nb = ap->lastindblk;
	}
	while (1) {
		if (flbp)
			brelse(flbp);
		if (nb == 0) {
#ifdef DIAGNOSTIC
			printf("adosfs: bad file list chain.\n");
#endif
			error = EINVAL;
			goto reterr;
		}
		error = bread(ap->amp->devvp, nb * ap->amp->secsperblk,
			      ap->amp->bsize, NOCRED, &flbp);
		if (error)
			goto reterr;
		if (adoscksum(flbp, ap->nwords)) {
#ifdef DIAGNOSTIC
			printf("adosfs: blk %u failed cksum.\n", nb);
#endif
			brelse(flbp);
			error = EINVAL;
			goto reterr;
		}
		/*
		 * update last indirect block cache
		 */
		ap->lastlindblk = fcnt++;
		ap->lastindblk = nb;

		nb = (daddr_t)adoswordn(flbp, ap->nwords - 2);
		if (flblk == 0)
			break;
		flblk--;
	}
	/* 
	 * calculate offset of block number in table.  The table starts
	 * at nwords - 51 and goes to offset 6 or less if indicated by the
	 * valid table entries stored at offset ADBI_NBLKTABENT.
	 */
	flblkoff = bn % ANODENDATBLKENT(ap);
	if (flblkoff < adoswordn(flbp, 2 /* ADBI_NBLKTABENT */)) {
		flblkoff = (ap->nwords - 51) - flblkoff;
		*bnp = adoswordn(flbp, flblkoff) * ap->amp->secsperblk;
	} else {
#ifdef DIAGNOSTIC
		printf("flblk offset %d too large in lblk %u blk %u\n", 
		    flblkoff, bn / ap->amp->secsperblk, flbp->b_blkno);
#endif
		error = EINVAL;
	}
	brelse(flbp);
reterr:
#ifdef ADOSFS_DIAGNOSTIC
	if (error == 0 && bnp)
		printf(" %u => %u", bn, *bnp);
	printf(" %d)", error);
#endif
	return(error);
}

/*
 * Print out the contents of an adosfs vnode.
 */
/* ARGSUSED */
int
adosfs_print(v)
	void *v;
{
#ifdef DIAGNOSTIC
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	struct anode *anp = VTOA(ap->a_vp);
#endif

	/* XXX Fill in more info here.  */
	printf("tag VT_ADOSFS\n");
#ifdef DIAGNOSTIC
	lockmgr_printinfo(&anp->a_lock);
#endif
	return(0);
}

int
adosfs_advlock(v)
	void *v;
{
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t a_id;
		int a_op;
		struct flock *a_fl;
		int a_flags;
	} */ *ap = v;
	register struct anode *anp = VTOA(ap->a_vp);

	return (lf_advlock(&anp->a_lockf, anp->fsize, ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
}

/* This is laid out like a standard dirent, except that it is shorter.  */
struct adirent {
	u_int32_t fileno;
	u_int16_t reclen;
	u_int8_t type;
	u_int8_t namlen;
	char name[32];	/* maxlen of 30 plus 2 NUL's */
};

/* XXX look over the off_t usage below wrt type safety */	
int
adosfs_readdir(v)
	void *v;
{
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long **a_cookies;
		int *a_ncookies;
	} */ *sp = v;
	int error, useri, chainc, hashi, scanned, uavail;
	struct adirent ad, *adp;
	struct anode *pap, *ap;
	struct adosfsmount *amp;
	struct vnode *vp;
	struct uio *uio;
	daddr_t nextbn;
	off_t uoff;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	if (sp->a_vp->v_type != VDIR) {
		error = ENOTDIR;
		goto reterr;
	}
	uio = sp->a_uio;
	uoff = uio->uio_offset;
	if (uoff < 0) {
		error = EINVAL;
		goto reterr;
	}

	pap = VTOA(sp->a_vp);
	amp = pap->amp;
	adp = &ad;
	error = nextbn = hashi = chainc = scanned = 0;
	uavail = uio->uio_resid / sizeof(ad);
	useri = uoff / sizeof(ad);

	/*
	 * if no slots available or offset requested is not on a slot boundary
	 */
	if (uavail < 1 || uoff % sizeof(ad)) {
		error = EINVAL;
		goto reterr;
	}

	while (uavail && (sp->a_cookies == NULL || sp->a_ncookies > 0)) {
		if (hashi == pap->ntabent) {
			*sp->a_eofflag = 1;
			break;
		}
		if (pap->tab[hashi] == 0) {
			hashi++;
			continue;
		}
		if (nextbn == 0)
			nextbn = pap->tab[hashi];

		/*
		 * first determine if we can skip this chain
		 */
		if (chainc == 0) {
			int skip;

			skip = useri - scanned;
			if (pap->tabi[hashi] > 0 && pap->tabi[hashi] <= skip) {
				scanned += pap->tabi[hashi];
				hashi++;
				nextbn = 0;
				continue;
			}
		}

		/*
		 * now [continue to] walk the chain
		 */
		ap = NULL;
		do {
			error = VFS_VGET(amp->mp, ABLKTOINO(nextbn), &vp);
			if (error)
				goto reterr;
			ap = VTOA(vp);
			scanned++;
			chainc++;
			nextbn = ap->hashf;

			/*
			 * check for end of chain.
			 */
			if (nextbn == 0) {
				pap->tabi[hashi] = chainc;
				hashi++;
				chainc = 0;
			} else if (pap->tabi[hashi] <= 0 &&
			    -chainc < pap->tabi[hashi])
				pap->tabi[hashi] = -chainc;

			if (useri >= scanned) {
				vput(vp);
				ap = NULL;
			}
		} while (ap == NULL && nextbn != 0);

		/*
		 * we left the loop but without a result so do main over.
		 */
		if (ap == NULL)
			continue;
		/*
		 * Fill in dirent record
		 */
		bzero(adp, sizeof(struct adirent));
		adp->fileno = (u_int32_t)ap->block;
		/*
		 * this deserves an function in kern/vfs_subr.c
		 */
		switch (ATOV(ap)->v_type) {
		case VREG:
			adp->type = DT_REG;
			break;
		case VDIR:
			adp->type = DT_DIR;
			break;
		case VLNK:
			adp->type = DT_LNK;
			break;
		default:
			adp->type = DT_UNKNOWN;
			break;
		}
		adp->reclen = sizeof(struct adirent);
		adp->namlen = strlen(ap->name);
		bcopy(ap->name, adp->name, adp->namlen);
		vput(vp);

		error = uiomove((caddr_t)adp, sizeof(struct adirent), uio);
		if (error)
			break;
#ifdef FIXME_TO_HAVE_COOKIES
		if (sp->a_cookies) {
			*sp->a_cookies++ = (u_long)uoff;
			sp->a_ncookies--;
		}
#endif
		uoff += sizeof(struct adirent);
		useri++;
		uavail--;
	}
#if doesnt_uiomove_handle_this
	uio->uio_offset = uoff;
#endif
reterr:
#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", error);
#endif
	return(error);
}


int
adosfs_access(v)
	void *v;
{
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *sp = v;
	struct anode *ap;
	int error;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif

	ap = VTOA(sp->a_vp);
#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(sp->a_vp)) {
		vprint("adosfs_access: not locked", sp->a_vp);
		panic("adosfs_access: not locked");
	}
#endif
#ifdef QUOTA
#endif
	error = vaccess(adunixprot(ap->adprot) & ap->amp->mask, ap->uid,
	    ap->gid, sp->a_mode, sp->a_cred);
#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", error);
#endif
	return(error);
}

/*ARGSUSED*/
int
adosfs_readlink(v)
	void *v;
{
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *sp = v;
	struct anode *ap;
	int error;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif
	ap = VTOA(sp->a_vp);
	error = uiomove(ap->slinkto, strlen(ap->slinkto), sp->a_uio);
#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", error);
#endif
	return (error);
}

/*ARGSUSED*/
int
adosfs_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
	} */ *sp = v;
#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
#endif

	VOP_UNLOCK(sp->a_vp, 0, sp->a_p);

	if (sp->a_vp->v_usecount == 0 /* && check for file gone? */)
		vrecycle(sp->a_vp, sp->a_p);

#ifdef ADOSFS_DIAGNOSTIC
	printf(" 0)");
#endif
	return(0);
}

int
adosfs_islocked(v)
	void *v;
{
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
	int locked;

#ifdef ADOSFS_DIAGNOSTIC
	advopprint(ap);
#endif

	locked = lockstatus(&VTOA(ap->a_vp)->a_lock);

#ifdef ADOSFS_DIAGNOSTIC
	printf(" %d)", locked);
#endif
	return(locked);
}

/*
 * the kernel wants its vnode back.
 * no lock needed we are being called from vclean()
 */
int
adosfs_reclaim(v)
	void *v;
{
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *sp = v;
	struct vnode *vp;
	struct anode *ap;

#ifdef ADOSFS_DIAGNOSTIC
	printf("(reclaim 0)");
#endif
	vp = sp->a_vp;
	ap = VTOA(vp);

	adosfs_aremhash(ap);

	cache_purge(vp);
	if (vp->v_type == VDIR && ap->tab)
		free(ap->tab, M_ANODE);
	else if (vp->v_type == VLNK && ap->slinkto)
		free(ap->slinkto, M_ANODE);
	free(ap, M_ANODE);
	vp->v_data = NULL;
	return(0);
}


/*
 * POSIX pathconf info, grabbed from kern/u fs, probably need to 
 * investigate exactly what each return type means as they are probably
 * not valid currently
 */
int
adosfs_pathconf(v)
	void *v;
{
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;

	switch (ap->a_name) {
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		return (0);
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		return (0);
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		return (0);
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		return (0);
	case _PC_NAME_MAX:
		*ap->a_retval = 30;
		return (0);
	case _PC_NO_TRUNC:
		*ap->a_retval = 0;
		return (0);
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
		return (0);
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		return (0);
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
		return (0);
	default:
		return (EINVAL);
	}
	/* NOTREACHED */
}

int
adenotsup(sp)
	void *sp;
{
#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
	printf(" EOPNOTSUPP)");
#endif
	return(EOPNOTSUPP);
}

int
adnullop(sp)
	void *sp;
{
#ifdef ADOSFS_DIAGNOSTIC
	advopprint(sp);
	printf(" NULL)");
#endif
	return(0);
}
@


1.34
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.33 2007/01/16 17:52:18 thib Exp $	*/
d946 1
a946 1
		vrecycle(sp->a_vp, (struct simplelock *)0, sp->a_p);
@


1.33
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.32 2006/01/20 23:27:24 miod Exp $	*/
d502 1
a502 1
	rv = lockmgr(&VTOA(vp)->a_lock, ap->a_flags, &vp->v_interlock);
d527 1
a527 2
	rv = lockmgr(&VTOA(vp)->a_lock, ap->a_flags | LK_RELEASE,
	    &vp->v_interlock);
@


1.32
log
@b_un.b_addr -> b_data; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.31 2005/11/19 02:18:00 pedro Exp $	*/
a80 7
#ifdef NFSSERVER
int	lease_check(void *);
#define	adosfs_lease_check lease_check
#else
#define adosfs_lease_check 	adnullop
#endif

a101 1
	{ &vop_lease_desc, adosfs_lease_check },	/* lease */
@


1.31
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.30 2003/12/21 15:28:59 miod Exp $	*/
d328 1
a328 1
		error = uiomove(bp->b_un.b_addr + on + amp->bsize -
@


1.30
log
@Pass -Wformat.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.29 2003/11/13 17:23:57 drahn Exp $	*/
d510 1
a510 2
	rv = lockmgr(&VTOA(vp)->a_lock, ap->a_flags, &vp->v_interlock,
	    ap->a_p);
d536 1
a536 1
	    &vp->v_interlock, ap->a_p);
@


1.29
log
@common cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.28 2003/11/13 17:19:40 drahn Exp $	*/
d306 1
a306 1
				printf("adosfs: bad primary type blk %ld\n",
@


1.28
log
@Couple of typos in poll changes. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.27 2003/10/17 18:25:06 tedu Exp $	*/
d135 2
@


1.27
log
@comment spelling from Jared Yanovich <jjy2+@@pitt.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.26 2003/09/23 16:51:11 millert Exp $	*/
d387 1
a387 1
	} */ *sp = v;
@


1.26
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.25 2003/07/24 22:00:24 mickey Exp $	*/
d205 1
a205 1
		 * blocks needed and mutiply by number of bytes per block.
d294 1
a294 1
		 * make things contigous
d669 1
a669 1
 * Print out the contents of a adosfs vnode.
d761 1
a761 1
	 * if no slots available or offset requested is not on a slot boundry
@


1.25
log
@kill some externs that are not there anymore and had left other places for a better void ages ago
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.24 2002/05/23 13:40:50 art Exp $	*/
d47 1
d61 1
a61 1
int	adosfs_select(void *);
d111 1
a111 1
	{ &vop_select_desc, adosfs_select },		/* select */
d380 1
a380 1
adosfs_select(v)
d383 1
a383 2
#ifdef ADOSFS_DIAGNOSTIC
	struct vop_select_args /* {
d385 1
a385 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
d388 1
d393 2
a394 1
	printf(" 1)");
d396 1
a396 1
	return(1);
@


1.24
log
@protect biodone calls with splbio
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.23 2002/03/14 01:26:25 millert Exp $	*/
a52 2

extern struct vnodeops adosfs_vnodeops;
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.22 2001/12/19 08:58:05 art Exp $	*/
d415 1
d424 1
d426 1
d436 1
d438 1
@


1.22
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.17 2001/06/23 02:14:21 csapuntz Exp $	*/
d56 23
a78 23
int	adosfs_advlock	__P((void *));
int	adosfs_open	__P((void *));
int	adosfs_getattr	__P((void *));
int	adosfs_read	__P((void *));
int	adosfs_write	__P((void *));
int	adosfs_ioctl	__P((void *));
int	adosfs_select	__P((void *));
int	adosfs_strategy	__P((void *));
int	adosfs_link	__P((void *));
int	adosfs_symlink	__P((void *));
int	adosfs_lock	__P((void *));
int	adosfs_unlock	__P((void *));
int	adosfs_bmap	__P((void *));
int	adosfs_print	__P((void *));
int	adosfs_readdir	__P((void *));
int	adosfs_access	__P((void *));
int	adosfs_readlink	__P((void *));
int	adosfs_inactive	__P((void *));
int	adosfs_islocked	__P((void *));
int	adosfs_reclaim	__P((void *));
int	adosfs_pathconf	__P((void *));
int	adnullop	__P((void *));
int	adenotsup	__P((void *));
d83 1
a83 1
int	lease_check __P((void *));
d134 1
a134 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.21
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.20 2001/12/10 02:19:34 art Exp $	*/
d134 1
a134 3
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_mmap_desc, vop_generic_mmap },
	{ NULL, NULL }
a274 22

	if (sp->a_vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {
			void *win;
			vsize_t bytelen = min(ap->fsize - uio->uio_offset,
					uio->uio_resid);

			if (bytelen == 0) {
				break;
			}
			win = ubc_alloc(&sp->a_vp->v_uobj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}
		}
		goto reterr;
	}

@


1.21.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.21 2001/12/10 04:45:31 art Exp $	*/
a134 1
	{ &vop_putpages_desc, genfs_putpages },
@


1.21.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.21.2.1 2002/02/02 03:28:25 art Exp $	*/
d56 23
a78 23
int	adosfs_advlock(void *);
int	adosfs_open(void *);
int	adosfs_getattr(void *);
int	adosfs_read(void *);
int	adosfs_write(void *);
int	adosfs_ioctl(void *);
int	adosfs_select(void *);
int	adosfs_strategy(void *);
int	adosfs_link(void *);
int	adosfs_symlink(void *);
int	adosfs_lock(void *);
int	adosfs_unlock(void *);
int	adosfs_bmap(void *);
int	adosfs_print(void *);
int	adosfs_readdir(void *);
int	adosfs_access(void *);
int	adosfs_readlink(void *);
int	adosfs_inactive(void *);
int	adosfs_islocked(void *);
int	adosfs_reclaim(void *);
int	adosfs_pathconf(void *);
int	adnullop(void *);
int	adenotsup(void *);
d83 1
a83 1
int	lease_check(void *);
a439 1
	int s;
a447 1
		s = splbio();
a448 1
		splx(s);
a457 1
			s = splbio();
a458 1
			splx(s);
@


1.20
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.19 2001/12/04 22:44:31 art Exp $	*/
d135 1
a135 2
	{ &vop_size_desc, genfs_size },
	{ &vop_mmap_desc, genfs_mmap },
@


1.19
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.18 2001/11/27 05:27:11 art Exp $	*/
d289 1
a289 1
			win = ubc_alloc(&sp->a_vp->v_uvm.u_obj, uio->uio_offset,
@


1.18
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.17 2001/06/23 02:14:21 csapuntz Exp $	*/
d136 1
@


1.17
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.16 2001/02/23 14:42:37 csapuntz Exp $	*/
d134 3
a136 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d277 22
@


1.16
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.15 1998/08/21 23:03:16 csapuntz Exp $	*/
a87 2
#define adosfs_seek 		adnullop
#define adosfs_vfree 		adnullop
a88 1
#define adosfs_blkatoff 	adenotsup
a92 1
#define adosfs_mmap 		adenotsup
a96 3
#define adosfs_truncate 	adenotsup
#define adosfs_update 		adenotsup
#define adosfs_valloc 		adenotsup
a112 1
	{ &vop_mmap_desc, adosfs_mmap },		/* mmap */
a113 1
	{ &vop_seek_desc, adosfs_seek },		/* seek */
a132 5
	{ &vop_blkatoff_desc, adosfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, adosfs_valloc },		/* valloc */
	{ &vop_vfree_desc, adosfs_vfree },		/* vfree */
	{ &vop_truncate_desc, adosfs_truncate },	/* truncate */
	{ &vop_update_desc, adosfs_update },		/* update */
@


1.15
log
@

Fix malloc race on new anode get.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.14 1998/08/21 22:04:42 deraadt Exp $	*/
a312 1
		sp->a_vp->v_lastr = lbn;
@


1.15.8.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.16 2001/02/23 14:42:37 csapuntz Exp $	*/
d313 1
@


1.15.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.15.8.1 2001/04/18 16:00:04 niklas Exp $	*/
d88 2
d91 1
d96 1
d101 3
d120 1
d122 1
d142 5
@


1.15.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.15.8.2 2001/07/04 10:14:17 niklas Exp $	*/
d134 1
a134 3
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_size_desc, genfs_size },
	{ NULL, NULL }
a274 22

	if (sp->a_vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {
			void *win;
			vsize_t bytelen = min(ap->fsize - uio->uio_offset,
					uio->uio_resid);

			if (bytelen == 0) {
				break;
			}
			win = ubc_alloc(&sp->a_vp->v_uvm.u_obj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error) {
				break;
			}
		}
		goto reterr;
	}

@


1.15.8.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 3
a136 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d277 22
@


1.15.8.5
log
@Merge in -current from about a week ago
@
text
@d56 23
a78 23
int	adosfs_advlock(void *);
int	adosfs_open(void *);
int	adosfs_getattr(void *);
int	adosfs_read(void *);
int	adosfs_write(void *);
int	adosfs_ioctl(void *);
int	adosfs_select(void *);
int	adosfs_strategy(void *);
int	adosfs_link(void *);
int	adosfs_symlink(void *);
int	adosfs_lock(void *);
int	adosfs_unlock(void *);
int	adosfs_bmap(void *);
int	adosfs_print(void *);
int	adosfs_readdir(void *);
int	adosfs_access(void *);
int	adosfs_readlink(void *);
int	adosfs_inactive(void *);
int	adosfs_islocked(void *);
int	adosfs_reclaim(void *);
int	adosfs_pathconf(void *);
int	adnullop(void *);
int	adenotsup(void *);
d83 1
a83 1
int	lease_check(void *);
d134 1
a134 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.15.8.6
log
@Sync the SMP branch with 3.3
@
text
@a414 1
	int s;
a422 1
		s = splbio();
a423 1
		splx(s);
a432 1
			s = splbio();
a433 1
			splx(s);
@


1.15.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a46 1
#include <sys/poll.h>
d54 2
d62 1
a62 1
int	adosfs_poll(void *);
d112 1
a112 1
	{ &vop_poll_desc, adosfs_poll },		/* poll */
a136 2
int	(**adosfs_vnodeop_p)(void *);

d206 1
a206 1
		 * blocks needed and multiply by number of bytes per block.
d295 1
a295 1
		 * make things contiguous
d305 1
a305 1
				printf("adosfs: bad primary type blk %d\n",
d381 1
a381 1
adosfs_poll(v)
d384 2
a385 1
	struct vop_poll_args /* {
d387 3
a389 1
		int  a_events;
d391 1
a391 2
	} */ *ap = v;
#ifdef ADOSFS_DIAGNOSTIC
d396 1
a396 2
	printf(" %d",
	    ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
d398 1
a398 1
	return(ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
d671 1
a671 1
 * Print out the contents of an adosfs vnode.
d763 1
a763 1
	 * if no slots available or offset requested is not on a slot boundary
@


1.14
log
@correct readlink(); kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.13 1998/08/06 19:34:18 csapuntz Exp $	*/
d1014 3
a1016 1
	LIST_REMOVE(ap, link);
@


1.13
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.12 1998/07/20 00:49:21 espie Exp $	*/
a942 1
	error = 0;
d944 1
a944 7
	if (ap->type != ASLINK)
		error = EBADF;
	/*
	 * XXX Should this be NULL terminated?
	 */
	if (error == 0)
		error = uiomove(ap->slinkto, strlen(ap->slinkto)+1, sp->a_uio);
d948 1
a948 1
	return(error);
@


1.12
log
@
typo & warnings make gcc unhappy.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.11 1997/11/10 23:57:06 niklas Exp $	*/
a65 1
int	adosfs_abortop	__P((void *));
d131 1
a131 1
	{ &vop_abortop_desc, adosfs_abortop },		/* abortop */
a498 14
}

int
adosfs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
 
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
@


1.11
log
@Use vfs lite2 lockmanager.  Add advisory locking.  some KNF.
some extra pathconf ops supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.10 1997/11/06 17:23:09 csapuntz Exp $	*/
d703 1
d708 1
@


1.10
log
@More fixes for adosfs so it compiles with VFS Lite 2
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.9 1997/11/06 05:58:01 csapuntz Exp $	*/
d37 1
d49 2
d56 1
a91 1
#define adosfs_advlock 		adenotsup
d525 5
a529 3
	} */ *sp = v;
	struct vnode *vp;
	struct anode *ap;
d532 1
a532 1
	advopprint(sp);
d534 4
a537 15
	vp = sp->a_vp;
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		tsleep(vp, PINOD, "adosfs_lock vp", 0);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	ap = VTOA(vp);
	if (ap->flags & ALOCKED) {
		ap->flags |= AWANT;
		tsleep(ap, PINOD, "adosfs_lock ap", 0);
		goto start;
	}
	ap->flags |= ALOCKED;
d539 1
a539 1
	printf(" 0)");
d541 1
a541 1
	return(0);
d553 3
a555 2
	} */ *sp = v;
	struct anode *ap;
d558 1
a558 1
	advopprint(sp);
d560 3
a562 6
	ap = VTOA(sp->a_vp);	
	ap->flags &= ~ALOCKED;
	if (ap->flags & AWANT) {
		ap->flags &= ~AWANT;
		wakeup(ap);
	}
d565 1
a565 1
	printf(" 0)");
d567 1
a567 1
	return(0);
a569 1

a702 1
#if 0
d705 7
a711 1
	} */ *sp = v;
d716 17
d1000 1
a1000 1
	} */ *sp = v;
d1004 1
a1004 1
	advopprint(sp);
d1007 1
a1007 1
	locked = (VTOA(sp->a_vp)->flags & ALOCKED) == ALOCKED;
d1059 1
a1059 1
	} */ *sp = v;
d1061 4
a1064 1
	switch (sp->a_name) {
d1066 1
a1066 1
		*sp->a_retval = LINK_MAX;
d1069 1
a1069 1
		*sp->a_retval = MAX_CANON;
d1072 10
a1081 1
		*sp->a_retval = MAX_INPUT;
d1084 1
a1084 4
		*sp->a_retval = PIPE_BUF;
		return (0);
	case _PC_CHOWN_RESTRICTED:
		*sp->a_retval = 1;
d1087 1
a1087 1
		*sp->a_retval = _POSIX_VDISABLE;
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.8 1997/01/20 15:49:54 niklas Exp $	*/
d739 2
a740 2
		u_long *a_cookies;
		int a_ncookies;
d872 1
d877 1
d970 1
a970 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d973 1
a973 1
		vrecycle(sp->a_vp, (struct simplelock *)0, ap->a_p);
@


1.8
log
@Type pedantery.. a lot of it too, more could be done as well.  Sync with
NetBSD 970118 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.7 1996/10/13 21:17:39 niklas Exp $	*/
d967 3
d971 1
a971 1
		vgone(sp->a_vp);
@


1.7
log
@Fix some type incompatibilities another way round
@
text
@d1 2
a2 2
/*	$OpenBSD: advnops.c,v 1.6 1996/08/23 19:11:02 niklas Exp $	*/
/*	$NetBSD: advnops.c,v 1.28 1996/04/23 05:18:32 veego Exp $	*/
d47 1
d104 42
a145 42
	{ &vop_default_desc,	vn_default_error },
	{ &vop_lookup_desc,	adosfs_lookup },	/* lookup */
	{ &vop_create_desc,	adosfs_create },	/* create */
	{ &vop_mknod_desc,	adosfs_mknod },		/* mknod */
	{ &vop_open_desc,	adosfs_open },		/* open */
	{ &vop_close_desc,	adosfs_close },		/* close */
	{ &vop_access_desc,	adosfs_access },	/* access */
	{ &vop_getattr_desc,	adosfs_getattr },	/* getattr */
	{ &vop_setattr_desc,	adosfs_setattr },	/* setattr */
	{ &vop_read_desc,	adosfs_read },		/* read */
	{ &vop_write_desc,	adosfs_write },		/* write */
	{ &vop_lease_desc,	adosfs_lease_check },	/* lease */
	{ &vop_ioctl_desc,	adosfs_ioctl },		/* ioctl */
	{ &vop_select_desc,	adosfs_select },	/* select */
	{ &vop_mmap_desc,	adosfs_mmap },		/* mmap */
	{ &vop_fsync_desc,	adosfs_fsync },		/* fsync */
	{ &vop_seek_desc,	adosfs_seek },		/* seek */
	{ &vop_remove_desc,	adosfs_remove },	/* remove */
	{ &vop_link_desc,	adosfs_link },		/* link */
	{ &vop_rename_desc,	adosfs_rename },	/* rename */
	{ &vop_mkdir_desc,	adosfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc,	adosfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc,	adosfs_symlink },	/* symlink */
	{ &vop_readdir_desc,	adosfs_readdir },	/* readdir */
	{ &vop_readlink_desc,	adosfs_readlink },	/* readlink */
	{ &vop_abortop_desc,	adosfs_abortop },	/* abortop */
	{ &vop_inactive_desc,	adosfs_inactive },	/* inactive */
	{ &vop_reclaim_desc,	adosfs_reclaim },	/* reclaim */
	{ &vop_lock_desc,	adosfs_lock },		/* lock */
	{ &vop_unlock_desc,	adosfs_unlock },	/* unlock */
	{ &vop_bmap_desc,	adosfs_bmap },		/* bmap */
	{ &vop_strategy_desc,	adosfs_strategy },	/* strategy */
	{ &vop_print_desc,	adosfs_print },		/* print */
	{ &vop_islocked_desc,	adosfs_islocked },	/* islocked */
	{ &vop_pathconf_desc,	adosfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc,	adosfs_advlock },	/* advlock */
	{ &vop_blkatoff_desc,	adosfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc,	adosfs_valloc },	/* valloc */
	{ &vop_vfree_desc,	adosfs_vfree },		/* vfree */
	{ &vop_truncate_desc,	adosfs_truncate },	/* truncate */
	{ &vop_update_desc,	adosfs_update },	/* update */
	{ &vop_bwrite_desc,	adosfs_bwrite },	/* bwrite */
d182 1
a182 1
	u_long fblks;
d201 1
a201 1
	vap->va_fileid = ap->block;
d223 1
a223 1
		vap->va_size = ap->fsize;
d251 3
a253 2
	int size, diff, error;
	long n, on;
d271 1
a271 1
	if (uio->uio_offset < 0) {
d275 1
d281 1
a281 1
	if (uio->uio_offset >= ap->fsize)
d293 4
a296 4
		lbn = uio->uio_offset / size;
		on = uio->uio_offset % size;
		n = min((u_int)(size - on), uio->uio_resid);
		diff = ap->fsize - uio->uio_offset;
d303 1
a303 1
			n = diff;
d309 2
a310 2
		error = bread(sp->a_vp, lbn * amp->secsperblk,
			      amp->bsize, NOCRED, &bp);
d319 1
a319 1
				       bp->b_blkno / amp->secsperblk);
d323 1
a323 1
			else if ( adoscksum(bp, ap->nwords)) {
d325 2
a326 2
				printf("adosfs: blk %ld failed cksum.\n",
				       bp->b_blkno / amp->secsperblk);
d337 1
a337 1
	printf(" %d+%d-%d+%d", lbn, on, lbn, n);
d339 3
a341 3
		n = min(n, (u_int)size - bp->b_resid);
		error = uiomove(bp->b_un.b_addr + on +
				amp->bsize - amp->dbsize, (int)n, uio);
d343 1
d450 2
a451 1
	if ((long)bp->b_blkno == -1) {
d456 1
d595 2
a596 4
	long nb, fcnt, flblk, flblkoff;
	daddr_t *bnp;
	daddr_t bn;
	int error; 
d638 1
a638 1
	if (flblk < (long)ap->lastlindblk) 
d645 1
a645 1
	while (flblk >= 0) {
d661 1
a661 1
			printf("adosfs: blk %ld failed cksum.\n", nb);
d673 3
a675 1
		nb = adoswordn(flbp, ap->nwords - 2);
d684 1
a684 1
	if (flblkoff < (long)adoswordn(flbp, 2 /* ADBI_NBLKTABENT */)) {
d689 2
a690 2
		printf("flblk offset %ld too large in lblk %ld blk %d\n", 
		    flblkoff, bn / ap->amp->secsperblk , flbp->b_blkno);
d698 1
a698 1
		printf(" %d => %d", bn, *bnp);
d720 1
d722 5
a726 5
	u_long  fileno;
	u_short reclen;
	char    type;
	char    namlen;
	char    name[32];	/* maxlen of 30 plus 2 NUL's */
d728 3
a730 2
	
int 
d748 1
a748 1
	u_long nextbn;
d812 1
a812 1
			error = VFS_VGET(amp->mp, (ino_t)nextbn, &vp);
d846 1
a846 1
		adp->fileno = ap->block;
d869 1
a869 1
		error = uiomove((caddr_t) adp, sizeof(struct adirent), uio);
d873 1
a873 1
			*sp->a_cookies++ = uoff;
@


1.6
log
@Some style and signedness pedantery
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.4 1996/04/21 22:14:40 deraadt Exp $	*/
d589 1
a589 2
	long nb, fcnt;
	u_long flblk, flblkoff;
d634 1
a634 1
	if (flblk < ap->lastlindblk) 
d678 1
a678 1
	if (flblkoff < adoswordn(flbp, 2 /* ADBI_NBLKTABENT */)) {
@


1.6.2.1
log
@Pullup: Fix some type incompatibilities another way round
@
text
@d1 1
a1 1
/*	$OpenBSD: advnops.c,v 1.7 1996/10/13 21:17:39 niklas Exp $	*/
d589 2
a590 1
	long nb, fcnt, flblk, flblkoff;
d635 1
a635 1
	if (flblk < (long)ap->lastlindblk) 
d679 1
a679 1
	if (flblkoff < (long)adoswordn(flbp, 2 /* ADBI_NBLKTABENT */)) {
@


1.5
log
@sync with netbsd
@
text
@d589 2
a590 1
	long nb, flblk, flblkoff, fcnt;
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: advnops.c,v 1.3 1996/02/26 14:18:21 niklas Exp $	*/
/*	$NetBSD: advnops.c,v 1.22 1995/08/18 15:14:38 chopps Exp $	*/
d315 1
a315 1
				printf("adosfs: bad primary type blk %d\n",
d322 1
a322 1
				printf("adosfs: blk %d failed cksum.\n",
d657 1
a657 1
			printf("adosfs: blk %d failed cksum.\n", nb);
d683 1
a683 1
		printf("flblk offset %d too large in lblk %d blk %d\n", 
@


1.3
log
@Addition of $OpenBSD$ RCSID.
From NetBSD: Rename struct timespec fields to conform to POSIX.1b
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d6 1
d211 2
d214 1
a214 1
		vap->va_nlink = 1;
d219 1
a219 1
		fblks = howmany(ap->fsize, amp->bsize);
d221 1
a221 1
		vap->va_bytes = fblks * amp->bsize;
d224 1
a224 1
		vap->va_blocksize = amp->bsize;
d287 1
a287 1
		 * (which have data blocks of 512 bytes)
d289 1
a289 1
		size = amp->bsize;
d306 2
a307 1
		error = bread(sp->a_vp, lbn, size, NOCRED, &bp);
d309 20
a328 1
		n = min(n, (u_int)size - bp->b_resid);
d336 3
a338 1
		error = uiomove(bp->b_un.b_addr + on, (int)n, uio);
d597 2
a598 1
	bn = sp->a_bn;
a600 1
	ap = VTOA(sp->a_vp);
d651 2
a652 2
		error = bread(ap->amp->devvp, nb, ap->amp->bsize,
			      NOCRED, &flbp);
d680 1
a680 1
		*bnp = adoswordn(flbp, flblkoff);
d684 1
a684 1
		    flblkoff, bn, flbp->b_blkno);
@


1.2
log
@Add forward decls.
Fix vop_link, vop_symlink, and vop_remove semantics in several ways:
* Change the argument names to vop_link so they actually make sense.
* Implement vop_link and vop_symlink for all file systems, so they do proper
  cleanup.
* Require the file system to decide whether or not linking and unlinking of
  directories is allowed, and disable it for all current file systems.
Adosfs prototyping changes.  Compiler warning police.
@
text
@d1 1
d192 1
a192 1
	vap->va_atime.ts_sec = vap->va_mtime.ts_sec = vap->va_ctime.ts_sec =
d195 1
a195 1
	vap->va_atime.ts_nsec = vap->va_mtime.ts_nsec = vap->va_ctime.ts_nsec = 0;
@


1.1
log
@Initial revision
@
text
@d44 1
d50 99
d150 4
a153 1
adosfs_open(sp)
d159 1
a159 3
	} */ *sp;
{
#ifdef ADOSFS_DIAGNOSTIC
d167 3
a169 1
adosfs_getattr(sp)
d175 1
a175 2
	} */ *sp;
{
d232 3
a234 1
adosfs_read(sp)
d240 1
a240 2
	} */ *sp;
{
d245 1
a245 2
	struct fs *fs;
	daddr_t lbn, bn;
d323 4
a326 1
adosfs_write(sp)
d332 1
a332 3
	} */ *sp;
{
#ifdef ADOSFS_DIAGNOSTIC
d344 4
a347 1
adosfs_ioctl(sp)
d355 1
a355 3
	} */ *sp;
{
#ifdef ADOSFS_DIAGNOSTIC
d364 4
a367 1
adosfs_select(sp)
d374 1
a374 2
	} */ *sp;
{
a377 1
#ifdef ADOSFS_DIAGNOSTIC
d388 3
a390 1
adosfs_strategy(sp)
d393 1
a393 2
	} */ *sp;
{
d413 2
a414 2
		if (error = 
		    VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL)) {
d435 46
d485 3
a487 1
adosfs_lock(sp)
d490 1
a490 2
	} */ *sp;
{
d522 3
a524 1
adosfs_unlock(sp)
d527 1
a527 2
	} */ *sp;
{
d551 3
a553 1
adosfs_bmap(sp)
d560 1
a560 2
	} */ *sp;
{
d625 3
a627 2
		if (error = bread(ap->amp->devvp, nb, ap->amp->bsize, 
		    NOCRED, &flbp))
d677 4
a680 1
adosfs_print(sp)
d683 2
a684 2
	} */ *sp;
{
d697 3
a699 1
adosfs_readdir(sp)
d707 1
a707 2
	} */ *sp;
{
d714 1
a714 1
	u_long nextbn, resid;
d778 2
a779 1
			if (error = VFS_VGET(amp->mp, (ino_t)nextbn, &vp))
d835 1
a835 1
		error = uiomove(adp, sizeof(struct adirent), uio);
d858 3
a860 1
adosfs_access(sp)
d866 1
a866 2
	} */ *sp;
{
d893 3
a895 1
adosfs_readlink(sp)
d900 1
a900 2
	} */ *sp;
{
d924 3
a926 1
adosfs_inactive(sp)
d929 1
a929 2
	} */ *sp;
{
d941 1
d943 3
a945 1
adosfs_islocked(sp)
d948 1
a948 2
	} */ *sp;
{
d968 3
a970 1
adosfs_reclaim(sp)
d973 1
a973 2
	} */ *sp;
{
d999 4
a1002 1
adosfs_pathconf(sp)
d1007 1
a1007 2
	} */ *sp;
{
a1054 77

#define adosfs_close ((int (*) __P((struct vop_close_args *)))adnullop)
#define adosfs_fsync ((int (*) __P((struct vop_fsync_args *)))adnullop)
#ifdef NFSSERVER
int	lease_check __P((struct vop_lease_args *));
#define	adosfs_lease_check lease_check
#else
#define adosfs_lease_check ((int (*) __P((struct vop_lease_args *)))adnullop)
#endif
#define adosfs_seek ((int (*) __P((struct vop_seek_args *)))adnullop)
#define adosfs_vfree ((int (*) __P((struct vop_vfree_args *)))adnullop)

#define adosfs_abortop ((int (*) __P((struct vop_abortop_args *)))adenotsup)
#define adosfs_advlock ((int (*) __P((struct vop_advlock_args *)))adenotsup)
#define adosfs_blkatoff ((int (*) __P((struct vop_blkatoff_args *)))adenotsup)
#define adosfs_bwrite ((int (*) __P((struct vop_bwrite_args *)))adenotsup)
#define adosfs_create ((int (*) __P((struct vop_create_args *)))adenotsup)
#define adosfs_link ((int (*) __P((struct vop_link_args *)))adenotsup)
#define adosfs_mkdir ((int (*) __P((struct vop_mkdir_args *)))adenotsup)
#define adosfs_mknod ((int (*) __P((struct vop_mknod_args *)))adenotsup)
#define adosfs_mmap ((int (*) __P((struct vop_mmap_args *)))adenotsup)
#define adosfs_remove ((int (*) __P((struct vop_remove_args *)))adenotsup)
#define adosfs_rename ((int (*) __P((struct vop_rename_args *)))adenotsup)
#define adosfs_rmdir ((int (*) __P((struct vop_rmdir_args *)))adenotsup)
#define adosfs_setattr ((int (*) __P((struct vop_setattr_args *)))adenotsup)
#define adosfs_symlink ((int (*) __P((struct vop_symlink_args *)))adenotsup)
#define adosfs_truncate ((int (*) __P((struct vop_truncate_args *)))adenotsup)
#define adosfs_update ((int (*) __P((struct vop_update_args *)))adenotsup)
#define adosfs_valloc ((int (*) __P((struct vop_valloc_args *)))adenotsup)

struct vnodeopv_entry_desc adosfs_vnodeop_entries[] = {
	{ &vop_default_desc,	vn_default_error },
	{ &vop_lookup_desc,	adosfs_lookup },	/* lookup */
	{ &vop_create_desc,	adosfs_create },	/* create */
	{ &vop_mknod_desc,	adosfs_mknod },		/* mknod */
	{ &vop_open_desc,	adosfs_open },		/* open */
	{ &vop_close_desc,	adosfs_close },		/* close */
	{ &vop_access_desc,	adosfs_access },	/* access */
	{ &vop_getattr_desc,	adosfs_getattr },	/* getattr */
	{ &vop_setattr_desc,	adosfs_setattr },	/* setattr */
	{ &vop_read_desc,	adosfs_read },		/* read */
	{ &vop_write_desc,	adosfs_write },		/* write */
	{ &vop_lease_desc,	adosfs_lease_check },	/* lease */
	{ &vop_ioctl_desc,	adosfs_ioctl },		/* ioctl */
	{ &vop_select_desc,	adosfs_select },	/* select */
	{ &vop_mmap_desc,	adosfs_mmap },		/* mmap */
	{ &vop_fsync_desc,	adosfs_fsync },		/* fsync */
	{ &vop_seek_desc,	adosfs_seek },		/* seek */
	{ &vop_remove_desc,	adosfs_remove },	/* remove */
	{ &vop_link_desc,	adosfs_link },		/* link */
	{ &vop_rename_desc,	adosfs_rename },	/* rename */
	{ &vop_mkdir_desc,	adosfs_mkdir },		/* mkdir */
	{ &vop_rmdir_desc,	adosfs_rmdir },		/* rmdir */
	{ &vop_symlink_desc,	adosfs_symlink },	/* symlink */
	{ &vop_readdir_desc,	adosfs_readdir },	/* readdir */
	{ &vop_readlink_desc,	adosfs_readlink },	/* readlink */
	{ &vop_abortop_desc,	adosfs_abortop },	/* abortop */
	{ &vop_inactive_desc,	adosfs_inactive },	/* inactive */
	{ &vop_reclaim_desc,	adosfs_reclaim },	/* reclaim */
	{ &vop_lock_desc,	adosfs_lock },		/* lock */
	{ &vop_unlock_desc,	adosfs_unlock },	/* unlock */
	{ &vop_bmap_desc,	adosfs_bmap },		/* bmap */
	{ &vop_strategy_desc,	adosfs_strategy },	/* strategy */
	{ &vop_print_desc,	adosfs_print },		/* print */
	{ &vop_islocked_desc,	adosfs_islocked },	/* islocked */
	{ &vop_pathconf_desc,	adosfs_pathconf },	/* pathconf */
	{ &vop_advlock_desc,	adosfs_advlock },	/* advlock */
	{ &vop_blkatoff_desc,	adosfs_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc,	adosfs_valloc },	/* valloc */
	{ &vop_vfree_desc,	adosfs_vfree },		/* vfree */
	{ &vop_truncate_desc,	adosfs_truncate },	/* truncate */
	{ &vop_update_desc,	adosfs_update },	/* update */
	{ &vop_bwrite_desc,	adosfs_bwrite },	/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
};
struct vnodeopv_desc adosfs_vnodeop_opv_desc =
	{ &adosfs_vnodeop_p, adosfs_vnodeop_entries };
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
