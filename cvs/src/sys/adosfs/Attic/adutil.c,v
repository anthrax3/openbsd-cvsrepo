head	1.19;
access;
symbols
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.18
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.16
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9:1.12.0.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_8:1.12.0.12
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.10
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.8
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.6
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2007.06.01.08.04.59;	author deraadt;	state dead;
branches;
next	1.18;

1.18
date	2007.06.01.05.37.12;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.21.17.29.31;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.19.02.18.00;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.21.15.28.59;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.09.03.15.50.32;	author csapuntz;	state Exp;
branches
	1.12.8.1
	1.12.18.1;
next	1.11;

1.11
date	98.08.21.23.03.14;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.11.10.23.57.05;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.17.23.09;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.01.20.15.49.52;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.10.03.24.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.10.07.25.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.05.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.14.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.26.14.18.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.24.09.37.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.49.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.49.37;	author deraadt;	state Exp;
branches;
next	;

1.12.8.1
date	2002.03.28.11.26.44;	author niklas;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2004.02.19.10.51.21;	author niklas;	state Exp;
branches;
next	;

1.12.18.1
date	2002.06.11.03.27.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@really gone
@
text
@@


1.18
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@@


1.17
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@a0 249
/*	$OpenBSD: adutil.c,v 1.16 2007/03/21 17:29:31 thib Exp $	*/
/*	$NetBSD: adutil.c,v 1.15 1996/10/13 02:52:07 christos Exp $	*/

/*
 * Copyright (c) 1994 Christian E. Hopps
 * Copyright (c) 1996 Matthias Scheler
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christian E. Hopps.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <sys/param.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/lock.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/buf.h>

#include <machine/endian.h>

#include <adosfs/adosfs.h>

/*
 * look for anode in the mount's hash table, return locked.
 */
#define AHASH(an) ((an) & (ANODEHASHSZ - 1))

static __inline char	CapitalChar(char, int);

struct vnode * 
adosfs_ahashget(mp, an)
	struct mount *mp;
	ino_t an;
{
	struct anodechain *hp;
	struct anode *ap;
	struct proc *p = curproc; /* XXX */
	struct vnode *vp;

	hp = &VFSTOADOSFS(mp)->anodetab[AHASH(an)];

	for (;;) {
		LIST_FOREACH(ap, hp, link) {
			if (ABLKTOINO(ap->block) == an) {
				vp = ATOV(ap);
				if (!vget(vp, LK_EXCLUSIVE, p))
					return (vp);
				break;
			}
		}
		if (ap == NULL)
			return (NULL);
	}
	/* NOTREACHED */
}

/*
 * insert in hash table and lock
 */
int
adosfs_ainshash(amp, ap)
	struct adosfsmount *amp;
	struct anode *ap;
{
	struct anodechain *hp;
	struct anode *aq;

	/* lock the inode, then put it on the appropriate hash list */
	lockmgr(&ap->a_lock, LK_EXCLUSIVE, NULL);

	hp = &amp->anodetab[AHASH(ap->block)];

	LIST_FOREACH(aq, hp, link) {
		if (aq->block == ap->block) {
			lockmgr(&ap->a_lock, LK_RELEASE, NULL);
			return (EEXIST);
		}
	}
 
	LIST_INSERT_HEAD(hp, ap, link);
	return (0);
}

void
adosfs_aremhash(ap)
	struct anode *ap;
{

        if (ap->link.le_prev != NULL)
		LIST_REMOVE(ap, link);
}

int
adosfs_getblktype(amp, bp)
	struct adosfsmount *amp;
	struct buf *bp;
{
	if (adoscksum(bp, amp->nwords)) {
#ifdef DIAGNOSTIC
		printf("adosfs: aget: cksum of blk %d failed\n",
		    bp->b_blkno / amp->secsperblk);
#endif
		return (-1);
	}

	/*
	 * check primary block type
	 */
	if (adoswordn(bp, 0) != BPT_SHORT) {
#ifdef DIAGNOSTIC
		printf("adosfs: aget: bad primary type blk %d\n",
		    bp->b_blkno / amp->secsperblk);
#endif
		return (-1);
	}

	switch (adoswordn(bp, amp->nwords - 1)) {
	case BST_RDIR:		/* root block */
		return (AROOT);
	case BST_LDIR:		/* hard link to dir */
		return (ALDIR);
	case BST_UDIR:		/* user dir */
		return (ADIR);
	case BST_LFILE:		/* hard link to file */
		return (ALFILE);
	case BST_FILE:		/* file header */
		return (AFILE);
	case BST_SLINK:		/* soft link */
		return (ASLINK);
	}
	return (-1);
}

int
adunixprot(adprot)
	int adprot;
{
	if (adprot & 0xc000ee00) {
		adprot = (adprot & 0xee0e) >> 1;
		return (((adprot & 0x7) << 6) |
			((adprot & 0x700) >> 5) |
			((adprot & 0x7000) >> 12));
	}
	else {
		adprot = (adprot >> 1) & 0x7;
		return((adprot << 6) | (adprot << 3) | adprot);
	}
}

static __inline char
CapitalChar(ch, inter)
	char ch;
	int inter;
{
	if ((ch >= 'a' && ch <= 'z') || 
	    (inter && ch >= '\xe0' && ch <= '\xfe' && ch != '\xf7'))
		return(ch - ('a' - 'A'));
	return(ch);
}

u_int32_t
adoscksum(bp, n)
	struct buf *bp;
	int n;
{
	u_int32_t sum, *lp;
	
	lp = (u_int32_t *)bp->b_data;
	sum = 0;

	while (n--)
		sum += betoh32(*lp++);
	return(sum);
}

int
adoscaseequ(name1, name2, len, inter)
	const char *name1, *name2;
	int len, inter;
{
	while (len-- > 0) 
		if (CapitalChar(*name1++, inter) != 
		    CapitalChar(*name2++, inter))
			return 0;
	
	return 1;
}

int
adoshash(nam, namlen, nelt, inter)
	const char *nam;
	int namlen, nelt, inter;
{
	int val;

	val = namlen;
	while (namlen--)
		val = ((val * 13) + (u_char)CapitalChar(*nam++, inter)) &
		    0x7ff;
	return(val % nelt);
}

#ifdef notyet
/*
 * datestamp is local time, tv is to be UTC
 */
int
dstotv(dsp, tvp)
	struct datestamp *dsp;
	struct timeval *tvp;
{
}

/*
 * tv is UTC, datestamp is to be local time
 */
int
tvtods(tvp, dsp)
	struct timeval *tvp;
	struct datestamp *dsp;
{
}
#endif
@


1.16
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.15 2005/11/19 02:18:00 pedro Exp $	*/
d68 2
a69 4
	for (;;)
		for (ap = hp->lh_first; ; ap = ap->link.le_next) {
			if (ap == NULL)
				return (NULL);
d77 3
d99 1
a99 1
	for (aq = hp->lh_first; aq ; aq = aq->link.le_next) {
@


1.15
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.14 2003/12/21 15:28:59 miod Exp $	*/
a73 1
				simple_lock(&vp->v_interlock);
@


1.14
log
@Pass -Wformat.
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.13 2002/03/14 01:26:25 millert Exp $	*/
a90 1
	struct proc *p = curproc;		/* XXX */
d95 1
a95 1
	lockmgr(&ap->a_lock, LK_EXCLUSIVE, (struct simplelock *)0, p);
d101 1
a101 3
			lockmgr(&ap->a_lock, LK_RELEASE,
				(struct simplelock *)0, p);

@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.12 1998/09/03 15:50:32 csapuntz Exp $	*/
d129 1
a129 1
		printf("adosfs: aget: cksum of blk %ld failed\n",
d140 1
a140 1
		printf("adosfs: aget: bad primary type blk %ld\n",
@


1.12
log
@

Correct loop termination for adosfs_ihashget
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.11 1998/08/21 23:03:14 csapuntz Exp $	*/
d54 1
a54 1
static __inline char	CapitalChar __P((char, int));
@


1.12.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.12 1998/09/03 15:50:32 csapuntz Exp $	*/
d54 1
a54 1
static __inline char	CapitalChar(char, int);
@


1.12.8.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
static __inline char	CapitalChar(char, int);
@


1.12.8.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d129 1
a129 1
		printf("adosfs: aget: cksum of blk %d failed\n",
d140 1
a140 1
		printf("adosfs: aget: bad primary type blk %d\n",
@


1.11
log
@

Fix malloc race on new anode get.
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.10 1997/11/10 23:57:05 niklas Exp $	*/
d100 1
a100 1
	for (aq = hp->lh_first; ; aq = aq->link.le_next) {
@


1.10
log
@Use vfs lite2 lockmanager.  Add advisory locking.  some KNF.
some extra pathconf ops supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.9 1997/11/06 17:23:09 csapuntz Exp $	*/
d86 1
a86 1
void
d92 2
d97 11
d109 2
a110 2
	LIST_INSERT_HEAD(&amp->anodetab[AHASH(ABLKTOINO(ap->block))], ap,
	    link);
d117 3
a119 1
	LIST_REMOVE(ap, link);
@


1.9
log
@More fixes for adosfs so it compiles with VFS Lite 2
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.8 1997/01/20 15:49:52 niklas Exp $	*/
d40 1
d44 3
d63 2
a64 1
	struct proc  *p = curproc;
d68 11
a78 8
start_over:
	for (ap = hp->lh_first; ap != NULL; ap = ap->link.le_next) {
		if (ABLKTOINO(ap->block) != an)
			continue;
		if (ap->flags & ALOCKED) {
			ap->flags |= AWANT;
			tsleep(ap, PINOD, "ahashget", 0);
			goto start_over;
d80 1
a80 5
		if (vget(ATOV(ap), LK_EXCLUSIVE, p))
			goto start_over;
		return (ATOV(ap));
	}
	return (NULL);
d91 5
a97 1
	ap->flags |= ALOCKED;
d186 1
a186 1
		sum += ntohl(*lp++);
@


1.8
log
@Type pedantery.. a lot of it too, more could be done as well.  Sync with
NetBSD 970118 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.7 1996/08/10 03:24:36 deraadt Exp $	*/
d59 1
d72 1
a72 1
		if (vget(ATOV(ap), 1))
@


1.7
log
@fix decl; netbsd pr#2681; tv@@pobox.com
@
text
@d1 2
a2 2
/*	$OpenBSD: adutil.c,v 1.6 1996/06/10 07:25:19 deraadt Exp $	*/
/*	$NetBSD: adutil.c,v 1.10.4.2 1996/05/27 10:21:29 is Exp $	*/
d49 2
a50 1
static int CapitalChar __P((int, int));
d64 1
a64 1
		if (ap->block != an)
d86 2
a87 1
	LIST_INSERT_HEAD(&amp->anodetab[AHASH(ap->block)], ap, link);
d106 1
a106 1
		       bp->b_blkno / amp->secsperblk);
d117 1
a117 1
		       bp->b_blkno / amp->secsperblk);
d155 1
a155 1
static int
d157 2
a158 1
	int ch, inter;
d161 1
a161 1
	    (inter && ch >= 0xe0 && ch <= 0xfe && ch != 0xf7))
d183 1
a183 1
	const u_char *name1, *name2;
d196 1
a196 1
	const u_char *nam;
d203 2
a204 1
		val = ((val * 13) + CapitalChar(*nam++, inter)) & 0x7ff;
a226 13
}
#endif

#ifndef m68k
u_int32_t
adoswordn(bp, wn)
	struct buf *bp;
	int wn;
{
	/*
	 * ados stored in network (big endian) order
	 */
	return(ntohl(*((u_int32_t *)bp->b_data + wn)));
@


1.6
log
@internationalize, 64 bit clean
@
text
@d1 1
a1 1
/*	$OpenBSD: adutil.c,v 1.4 1996/04/21 22:14:38 deraadt Exp $	*/
d181 1
a181 1
	int len;
@


1.5
log
@sync with netbsd
@
text
@d2 1
a2 1
/*	$NetBSD: adutil.c,v 1.10 1996/04/23 05:18:29 veego Exp $	*/
d163 1
a163 1
long
d166 1
a166 1
	long n;
d168 1
a168 1
	long sum, *lp;
d170 1
a170 1
	lp = (long *)bp->b_data;
d174 1
a174 1
		sum += *lp++;
d179 13
d227 1
a227 1
long
d235 1
a235 1
	return(ntohl(*((long *)bp->b_data + wn)));
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: adutil.c,v 1.3 1996/02/26 14:18:19 niklas Exp $	*/
/*	$NetBSD: adutil.c,v 1.9 1996/04/05 05:06:10 mhitch Exp $	*/
d103 1
a103 1
		printf("adosfs: aget: cksum of blk %d failed\n",
d114 1
a114 1
		printf("adosfs: aget: bad primary type blk %d\n",
@


1.3
log
@Addition of $OpenBSD$ RCSID.
From NetBSD: Rename struct timespec fields to conform to POSIX.1b
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: adutil.c,v 1.8 1996/02/09 19:06:41 christos Exp $	*/
d6 1
d49 1
a49 1
static int toupper __P((int));
d103 2
a104 1
		printf("adosfs: aget: cksum of blk %d failed\n", bp->b_blkno);
d114 2
a115 1
		printf("adosfs: aget: bad primary type blk %d\n", bp->b_blkno);
d142 4
a145 3
		adprot = ((adprot & 0xee00) | (~adprot & 0x000e)) >> 1;
		return (((adprot & 0x7) << 6) | ((adprot & 0x700) >> 5) |
			(adprot >> 12));
d148 1
a148 1
		adprot = (~adprot >> 1) & 0x7;
d154 2
a155 2
toupper(ch)
	int ch;
d157 3
a159 2
	if (ch >= 'a' && ch <= 'z')
		return(ch & ~(0x20));
d179 3
a181 3
adoshash(nam, namlen, nelt)
	const char *nam;
	int namlen, nelt;
d187 1
a187 1
		val = ((val * 13) + toupper(*nam++)) & 0x7ff;
d213 1
d224 1
@


1.2
log
@Add forward decls.
Fix vop_link, vop_symlink, and vop_remove semantics in several ways:
* Change the argument names to vop_link so they actually make sense.
* Implement vop_link and vop_symlink for all file systems, so they do proper
  cleanup.
* Require the file system to decide whether or not linking and unlinking of
  directories is allowed, and disable it for all current file systems.
Adosfs prototyping changes.  Compiler warning police.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: adutil.c,v 1.7 1995/01/18 09:17:33 mycroft Exp $	*/
d36 1
d47 1
d148 1
a148 1
static char
d150 1
a150 1
	char ch;
d185 1
d205 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
