head	1.25;
access;
symbols
	OPENBSD_5_5:1.24.0.14
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.10
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.12
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.10
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.6
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.25
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.24;

1.24
date	2011.07.03.23.59.43;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.03.23.48.41;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.08.15.22.02;	author chl;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.13.20.40.02;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.28.17.16.38;	author henning;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.14.08.42.23;	author kjc;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.03.14.31.02;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.02.16.17.42;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.31.12.35.45;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.27.11.53.13;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.13.16.42.52;	author kjc;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.11.02.25.59;	author kjc;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.02.11.22.31;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.08.13.05.43;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.16.17.27.20;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.09.18.05;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.29.07.52.31;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.26.07.36.46;	author kjc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.08.09.14.32.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.35;	author kjc;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.02.43.21;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.22.28.25;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.13.19.21.26;	author ho;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.51.22;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@bye bye
@
text
@/*	$OpenBSD: altq_priq.c,v 1.24 2011/07/03 23:59:43 henning Exp $	*/
/*	$KAME: altq_priq.c,v 1.1 2000/10/18 09:15:23 kjc Exp $	*/
/*
 * Copyright (C) 2000
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * priority queue
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/queue.h>

#include <net/if.h>
#include <netinet/in.h>

#include <net/pfvar.h>
#include <altq/altq.h>
#include <altq/altq_priq.h>

/*
 * function prototypes
 */
static int priq_clear_interface(struct priq_if *);
static int priq_request(struct ifaltq *, int, void *);
static void priq_purge(struct priq_if *);
static struct priq_class *priq_class_create(struct priq_if *, int, int, int,
    int);
static int priq_class_destroy(struct priq_class *);
static int priq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf *priq_dequeue(struct ifaltq *, int);

static int priq_addq(struct priq_class *, struct mbuf *);
static struct mbuf *priq_getq(struct priq_class *);
static struct mbuf *priq_pollq(struct priq_class *);
static void priq_purgeq(struct priq_class *);

static void get_class_stats(struct priq_classstats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_int32_t);

int
priq_pfattach(struct pf_altq *a)
{
	struct ifnet *ifp;
	int s, error;

	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
		return (EINVAL);
	s = splnet();
	error = altq_attach(&ifp->if_snd, ALTQT_PRIQ, a->altq_disc,
	    priq_enqueue, priq_dequeue, priq_request, NULL, NULL);
	splx(s);
	return (error);
}

int
priq_add_altq(struct pf_altq *a)
{
	struct priq_if	*pif;
	struct ifnet	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (EINVAL);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENODEV);

	pif = malloc(sizeof(struct priq_if), M_DEVBUF, M_WAITOK|M_ZERO);
	pif->pif_bandwidth = a->ifbandwidth;
	pif->pif_maxpri = -1;
	pif->pif_ifq = &ifp->if_snd;

	/* keep the state in pf_altq */
	a->altq_disc = pif;

	return (0);
}

int
priq_remove_altq(struct pf_altq *a)
{
	struct priq_if *pif;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;

	(void)priq_clear_interface(pif);

	free(pif, M_DEVBUF);
	return (0);
}

int
priq_add_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	/* check parameters */
	if (a->priority >= PRIQ_MAXPRI)
		return (EINVAL);
	if (a->qid == 0)
		return (EINVAL);
	if (pif->pif_classes[a->priority] != NULL)
		return (EBUSY);
	if (clh_to_clp(pif, a->qid) != NULL)
		return (EBUSY);

	cl = priq_class_create(pif, a->priority, a->qlimit,
	    a->pq_u.priq_opts.flags, a->qid);
	if (cl == NULL)
		return (ENOMEM);

	return (0);
}

int
priq_remove_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	return (priq_class_destroy(cl));
}

int
priq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	struct priq_if *pif;
	struct priq_class *cl;
	struct priq_classstats stats;
	int error = 0;

	if ((pif = altq_lookup(a->ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
	return (0);
}

/*
 * bring the interface back to the initial state by discarding
 * all the filters and classes.
 */
static int
priq_clear_interface(struct priq_if *pif)
{
	struct priq_class	*cl;
	int pri;

	/* clear out the classes */
	for (pri = 0; pri <= pif->pif_maxpri; pri++)
		if ((cl = pif->pif_classes[pri]) != NULL)
			priq_class_destroy(cl);

	return (0);
}

static int
priq_request(struct ifaltq *ifq, int req, void *arg)
{
	struct priq_if	*pif = (struct priq_if *)ifq->altq_disc;

	switch (req) {
	case ALTRQ_PURGE:
		priq_purge(pif);
		break;
	}
	return (0);
}

/* discard all the queued packets on the interface */
static void
priq_purge(struct priq_if *pif)
{
	struct priq_class *cl;
	int pri;

	for (pri = 0; pri <= pif->pif_maxpri; pri++) {
		if ((cl = pif->pif_classes[pri]) != NULL && !qempty(cl->cl_q))
			priq_purgeq(cl);
	}
	if (ALTQ_IS_ENABLED(pif->pif_ifq))
		pif->pif_ifq->ifq_len = 0;
}

static struct priq_class *
priq_class_create(struct priq_if *pif, int pri, int qlimit, int flags, int qid)
{
	struct priq_class *cl;
	int s;

#ifndef ALTQ_RED
	if (flags & PRCF_RED) {
#ifdef ALTQ_DEBUG
		printf("priq_class_create: RED not configured for PRIQ!\n");
#endif
		return (NULL);
	}
#endif

	if ((cl = pif->pif_classes[pri]) != NULL) {
		/* modify the class instead of creating a new one */
		s = splnet();
		if (!qempty(cl->cl_q))
			priq_purgeq(cl);
		splx(s);
#ifdef ALTQ_RED
		if (q_is_red(cl->cl_q))
			red_destroy(cl->cl_red);
#endif
	} else {
		cl = malloc(sizeof(struct priq_class), M_DEVBUF,
		    M_WAITOK|M_ZERO);

		cl->cl_q = malloc(sizeof(class_queue_t), M_DEVBUF,
		    M_WAITOK|M_ZERO);
	}

	pif->pif_classes[pri] = cl;
	if (flags & PRCF_DEFAULTCLASS)
		pif->pif_default = cl;
	if (qlimit == 0)
		qlimit = 50;  /* use default */
	qlimit(cl->cl_q) = qlimit;
	qtype(cl->cl_q) = Q_DROPTAIL;
	qlen(cl->cl_q) = 0;
	cl->cl_flags = flags;
	cl->cl_pri = pri;
	if (pri > pif->pif_maxpri)
		pif->pif_maxpri = pri;
	cl->cl_pif = pif;
	cl->cl_handle = qid;

#ifdef ALTQ_RED
	if (flags & PRCF_RED) {
		int red_flags, red_pkttime;

		red_flags = 0;
		if (flags & PRCF_ECN)
			red_flags |= REDF_ECN;
		if (pif->pif_bandwidth < 8)
			red_pkttime = 1000 * 1000 * 1000; /* 1 sec */
		else
			red_pkttime = (int64_t)pif->pif_ifq->altq_ifp->if_mtu
			  * 1000 * 1000 * 1000 / (pif->pif_bandwidth / 8);
		if (flags & PRCF_RED) {
			cl->cl_red = red_alloc(0, 0,
			    qlimit(cl->cl_q) * 10/100,
			    qlimit(cl->cl_q) * 30/100,
			    red_flags, red_pkttime);
			qtype(cl->cl_q) = Q_RED;
		}
	}
#endif /* ALTQ_RED */

	return (cl);
}

static int
priq_class_destroy(struct priq_class *cl)
{
	struct priq_if *pif;
	int s, pri;

	s = splnet();

	if (!qempty(cl->cl_q))
		priq_purgeq(cl);

	pif = cl->cl_pif;
	pif->pif_classes[cl->cl_pri] = NULL;
	if (pif->pif_maxpri == cl->cl_pri) {
		for (pri = cl->cl_pri; pri >= 0; pri--)
			if (pif->pif_classes[pri] != NULL) {
				pif->pif_maxpri = pri;
				break;
			}
		if (pri < 0)
			pif->pif_maxpri = -1;
	}
	splx(s);

	if (cl->cl_red != NULL) {
#ifdef ALTQ_RED
		if (q_is_red(cl->cl_q))
			red_destroy(cl->cl_red);
#endif
	}
	free(cl->cl_q, M_DEVBUF);
	free(cl, M_DEVBUF);
	return (0);
}

/*
 * priq_enqueue is an enqueue function to be registered to
 * (*altq_enqueue) in struct ifaltq.
 */
static int
priq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
{
	struct priq_if	*pif = (struct priq_if *)ifq->altq_disc;
	struct priq_class *cl;
	int len;

	/* grab class set by classifier */
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	if ((cl = clh_to_clp(pif, m->m_pkthdr.pf.qid)) == NULL) {
		cl = pif->pif_default;
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		cl->cl_pktattr = NULL;
	}

	len = m_pktlen(m);
	if (priq_addq(cl, m) != 0) {
		/* drop occurred.  mbuf was freed in priq_addq. */
		PKTCNTR_ADD(&cl->cl_dropcnt, len);
		return (ENOBUFS);
	}
	IFQ_INC_LEN(ifq);

	/* successfully queued. */
	return (0);
}

/*
 * priq_dequeue is a dequeue function to be registered to
 * (*altq_dequeue) in struct ifaltq.
 *
 * note: ALTDQ_POLL returns the next packet without removing the packet
 *	from the queue.  ALTDQ_REMOVE is a normal dequeue operation.
 *	ALTDQ_REMOVE must return the same packet if called immediately
 *	after ALTDQ_POLL.
 */
static struct mbuf *
priq_dequeue(struct ifaltq *ifq, int op)
{
	struct priq_if	*pif = (struct priq_if *)ifq->altq_disc;
	struct priq_class *cl;
	struct mbuf *m;
	int pri;

	if (IFQ_IS_EMPTY(ifq))
		/* no packet in the queue */
		return (NULL);

	for (pri = pif->pif_maxpri;  pri >= 0; pri--) {
		if ((cl = pif->pif_classes[pri]) != NULL &&
		    !qempty(cl->cl_q)) {
			if (op == ALTDQ_POLL)
				return (priq_pollq(cl));

			m = priq_getq(cl);
			if (m != NULL) {
				IFQ_DEC_LEN(ifq);
				if (qempty(cl->cl_q))
					cl->cl_period++;
				PKTCNTR_ADD(&cl->cl_xmitcnt, m_pktlen(m));
			}
			return (m);
		}
	}
	return (NULL);
}

static int
priq_addq(struct priq_class *cl, struct mbuf *m)
{

#ifdef ALTQ_RED
	if (q_is_red(cl->cl_q))
		return red_addq(cl->cl_red, cl->cl_q, m, cl->cl_pktattr);
#endif
	if (qlen(cl->cl_q) >= qlimit(cl->cl_q)) {
		m_freem(m);
		return (-1);
	}

	_addq(cl->cl_q, m);

	return (0);
}

static struct mbuf *
priq_getq(struct priq_class *cl)
{
#ifdef ALTQ_RED
	if (q_is_red(cl->cl_q))
		return red_getq(cl->cl_red, cl->cl_q);
#endif
	return _getq(cl->cl_q);
}

static struct mbuf *
priq_pollq(cl)
	struct priq_class *cl;
{
	return qhead(cl->cl_q);
}

static void
priq_purgeq(struct priq_class *cl)
{
	struct mbuf *m;

	if (qempty(cl->cl_q))
		return;

	while ((m = _getq(cl->cl_q)) != NULL) {
		PKTCNTR_ADD(&cl->cl_dropcnt, m_pktlen(m));
		m_freem(m);
	}
	ASSERT(qlen(cl->cl_q) == 0);
}

static void
get_class_stats(struct priq_classstats *sp, struct priq_class *cl)
{
	sp->class_handle = cl->cl_handle;
	sp->qlength = qlen(cl->cl_q);
	sp->qlimit = qlimit(cl->cl_q);
	sp->period = cl->cl_period;
	sp->xmitcnt = cl->cl_xmitcnt;
	sp->dropcnt = cl->cl_dropcnt;

	sp->qtype = qtype(cl->cl_q);
#ifdef ALTQ_RED
	if (q_is_red(cl->cl_q))
		red_getstats(cl->cl_red, &sp->red[0]);
#endif
}

/* convert a class handle to the corresponding class pointer */
static struct priq_class *
clh_to_clp(struct priq_if *pif, u_int32_t chandle)
{
	struct priq_class *cl;
	int idx;

	if (chandle == 0)
		return (NULL);

	for (idx = pif->pif_maxpri; idx >= 0; idx--)
		if ((cl = pif->pif_classes[idx]) != NULL &&
		    cl->cl_handle == chandle)
			return (cl);

	return (NULL);
}
@


1.24
log
@g/c RIO traces (aka clean up after tedu :))
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.23 2011/07/03 23:48:41 henning Exp $	*/
@


1.23
log
@g/c code to read/write the dscp field. with pf as classifier altq has no
business in mucking with it and since the _CLEARDSCP flags were never
possibly set that is effectively dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.22 2008/05/08 15:22:02 chl Exp $	*/
a255 4
#ifdef ALTQ_RIO
		if (q_is_rio(cl->cl_q))
			rio_destroy((rio_t *)cl->cl_red);
#endif
d284 1
a284 1
	if (flags & (PRCF_RED|PRCF_RIO)) {
a294 7
#ifdef ALTQ_RIO
		if (flags & PRCF_RIO) {
			cl->cl_red = (red_t *)rio_alloc(0, NULL,
						red_flags, red_pkttime);
			qtype(cl->cl_q) = Q_RIO;
		} else
#endif
a332 4
#ifdef ALTQ_RIO
		if (q_is_rio(cl->cl_q))
			rio_destroy((rio_t *)cl->cl_red);
#endif
a426 5
#ifdef ALTQ_RIO
	if (q_is_rio(cl->cl_q))
		return rio_addq((rio_t *)cl->cl_red, cl->cl_q, m,
				cl->cl_pktattr);
#endif
a443 4
#ifdef ALTQ_RIO
	if (q_is_rio(cl->cl_q))
		return rio_getq((rio_t *)cl->cl_red, cl->cl_q);
#endif
a487 5
#ifdef ALTQ_RIO
	if (q_is_rio(cl->cl_q))
		rio_getstats((rio_t *)cl->cl_red, &sp->red[0]);
#endif

@


1.22
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.21 2007/09/13 20:40:02 chl Exp $	*/
a293 4
#ifdef ALTQ_RIO
		if (flags & PRCF_CLEARDSCP)
			red_flags |= RIOF_CLEARDSCP;
#endif
a454 3

	if (cl->cl_flags & PRCF_CLEARDSCP)
		write_dsfield(m, cl->cl_pktattr, 0);
@


1.21
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok henning@@ krw@@ canacar@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.20 2007/05/28 17:16:38 henning Exp $	*/
a96 2
	if (pif == NULL)
		return (ENOMEM);
a266 2
		if (cl == NULL)
			return (NULL);
a269 2
		if (cl->cl_q == NULL)
			goto err_ret;
d307 1
a307 2
			if (cl->cl_red != NULL)
				qtype(cl->cl_q) = Q_RIO;
d315 1
a315 2
			if (cl->cl_red != NULL)
				qtype(cl->cl_q) = Q_RED;
a320 16

 err_ret:
	if (cl->cl_red != NULL) {
#ifdef ALTQ_RIO
		if (q_is_rio(cl->cl_q))
			rio_destroy((rio_t *)cl->cl_red);
#endif
#ifdef ALTQ_RED
		if (q_is_red(cl->cl_q))
			red_destroy(cl->cl_red);
#endif
	}
	if (cl->cl_q != NULL)
		free(cl->cl_q, M_DEVBUF);
	free(cl, M_DEVBUF);
	return (NULL);
@


1.20
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.19 2006/03/04 22:40:15 brad Exp $	*/
d96 1
a96 2
	MALLOC(pif, struct priq_if *, sizeof(struct priq_if),
	    M_DEVBUF, M_WAITOK);
a98 1
	bzero(pif, sizeof(struct priq_if));
d120 1
a120 1
	FREE(pif, M_DEVBUF);
d267 2
a268 2
		MALLOC(cl, struct priq_class *, sizeof(struct priq_class),
		       M_DEVBUF, M_WAITOK);
a270 1
		bzero(cl, sizeof(struct priq_class));
d272 2
a273 2
		MALLOC(cl->cl_q, class_queue_t *, sizeof(class_queue_t),
		       M_DEVBUF, M_WAITOK);
a275 1
		bzero(cl->cl_q, sizeof(class_queue_t));
d342 2
a343 2
		FREE(cl->cl_q, M_DEVBUF);
	FREE(cl, M_DEVBUF);
d381 2
a382 2
	FREE(cl->cl_q, M_DEVBUF);
	FREE(cl, M_DEVBUF);
@


1.19
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.18 2005/10/17 08:43:35 henning Exp $	*/
a398 1
	struct pf_mtag *t;
d409 1
a409 3
	t = pf_find_mtag(m);
	if (t == NULL ||
	    (cl = clh_to_clp(pif, t->qid)) == NULL) {
@


1.18
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.17 2004/01/14 08:42:23 kjc Exp $	*/
d78 1
a78 1
	s = splimp();
d256 1
a256 1
		s = splimp();
d357 1
a357 1
	s = splimp();
@


1.17
log
@eliminate the predefined special qids so that qids become simple
identifiers without embedded meanings.

this also allows us to make the semantics of the qid assignment in line
with the tag assignment in the next step.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.16 2003/04/03 14:31:02 henning Exp $	*/
d399 1
a399 1
	struct m_tag *t;
d410 1
a410 1
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
d412 1
a412 1
	    (cl = clh_to_clp(pif, ((struct altq_tag *)(t+1))->qid)) == NULL) {
@


1.16
log
@until now, the queue ID and the priority were tied together with PRIQ. this
diff changes that.
with PRIQ, the queues are in an array, with the priority as key. removing
the tie means we cannot access the array with (queueID - 1) as key any
more but need to traverse the array until the queue ID matches. As the array
has a maximum of 16 entries, traversing linear is okay.
a new queue ID allocation algorithm coming soon will require this.

ok dhartmei@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.15 2003/04/02 16:17:42 henning Exp $	*/
d140 2
a141 2
	if (a->qid > PRIQ_MAXQID)
		return (EINVAL);
a185 3
#if 0
	stats.handle = a->qid;
#endif
d561 1
d568 3
a570 3
		if (pif->pif_classes[idx] != NULL &&
		    pif->pif_classes[idx]->cl_handle == chandle)
			return (pif->pif_classes[idx]);
@


1.15
log
@remove dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.14 2003/03/31 12:35:45 henning Exp $	*/
a137 1

d140 1
a140 3

	/* qid is tied to priority with priq */
	if (a->qid != a->priority + 1)
d564 1
a564 1
	u_int idx;
d568 7
a574 4
	idx = chandle - 1;
	if (idx >= PRIQ_MAXPRI)
		return (NULL);
	return (pif->pif_classes[idx]);
@


1.14
log
@remove queue ID assigning code. it's dead since some time as we assign queue
IDs in userland already.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.13 2003/03/27 11:53:13 henning Exp $	*/
a151 3

	/* return handle to user space. */
	a->qid = cl->cl_handle;
@


1.13
log
@idx is unsigned
from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.12 2003/03/13 16:42:52 kjc Exp $	*/
d139 8
a146 7
	if (a->qid != 0) {
		/* qid is tied to priority with priq */
		if (a->qid != a->priority + 1)
			return (EINVAL);
		if (clh_to_clp(pif, a->qid) != NULL)
			return (EBUSY);
	}
d304 1
a304 4
	if (qid)
		cl->cl_handle = qid;
	else
		cl->cl_handle = pri + 1;
@


1.12
log
@scale the red thresholds according to the queue limit.
the min and max thresholds are set to 10% and 30% of the queue limit.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.11 2003/03/11 02:25:59 kjc Exp $	*/
d572 1
a572 1
	int idx;
@


1.11
log
@add protection against packets without pkthdr.
this should not happen but just in case.
printf() is intended to be annoying so that we'll get reports on it.

original idea from dhartmei@@
ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.10 2003/03/02 11:22:31 henning Exp $	*/
d333 4
a336 2
			cl->cl_red = red_alloc(0, 0, 0, 0,
					       red_flags, red_pkttime);
@


1.10
log
@only assign a new queue id if a->qid is 0. otherwise, check a->qid for
validity and take that.

validity checks provided by kjc@@

ok dhartmei@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.9 2003/02/08 13:05:43 henning Exp $	*/
d412 7
@


1.9
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.8 2002/12/16 17:27:20 henning Exp $	*/
d55 2
a56 1
static struct priq_class *priq_class_create(struct priq_if *, int, int, int);
d139 8
d148 1
a148 1
	    a->pq_u.priq_opts.flags);
d248 1
a248 1
priq_class_create(struct priq_if *pif, int pri, int qlimit, int flags)
d303 4
a306 1
	cl->cl_handle = pri + 1;
@


1.8
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.7 2002/12/16 09:18:05 kjc Exp $	*/
d197 1
a197 2
priq_clear_interface(pif)
	struct priq_if *pif;
d211 1
a211 4
priq_request(ifq, req, arg)
	struct ifaltq *ifq;
	int req;
	void *arg;
d225 1
a225 2
priq_purge(pif)
	struct priq_if *pif;
d239 1
a239 3
priq_class_create(pif, pri, qlimit, flags)
	struct priq_if *pif;
	int pri, qlimit, flags;
d349 1
a349 2
priq_class_destroy(cl)
	struct priq_class *cl;
d392 1
a392 4
priq_enqueue(ifq, m, pktattr)
	struct ifaltq *ifq;
	struct mbuf *m;
	struct altq_pktattr *pktattr;
d433 1
a433 3
priq_dequeue(ifq, op)
	struct ifaltq	*ifq;
	int		op;
d464 1
a464 3
priq_addq(cl, m)
	struct priq_class *cl;
	struct mbuf *m;
d490 1
a490 2
priq_getq(cl)
	struct priq_class *cl;
d511 1
a511 2
priq_purgeq(cl)
	struct priq_class *cl;
d526 1
a526 3
get_class_stats(sp, cl)
	struct priq_classstats *sp;
	struct priq_class *cl;
d549 1
a549 3
clh_to_clp(pif, chandle)
	struct priq_if *pif;
	u_int32_t chandle;
@


1.7
log
@switchover to pf-based altq.
 - remove files which are no longer used, or we don't have plans to support
   in pf in the near future.
 - remove altq ioctl related stuff.
 - convert the PRIQ, HFSC and RIO modules to pf-based altq.
   (these are not enabled in GENERIC, CDNR is not converted yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.6 2002/11/29 07:52:31 kjc Exp $	*/
d87 2
a88 2
	struct priq_if *pif;
	struct ifnet 	*ifp;
@


1.6
log
@supress printf's.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.5 2002/11/26 01:03:34 henning Exp $	*/
a35 1
#include <sys/sockio.h>
d43 1
a43 1
#include <net/if_types.h>
d45 1
a46 1
#include <altq/altq_conf.h>
a51 2
static struct priq_if *priq_attach(struct ifaltq *, u_int);
static int priq_detach(struct priq_if *);
d55 1
a55 2
static struct priq_class *priq_class_create(struct priq_if *,
						 int, int, int);
d66 2
a67 14
int priqopen(dev_t, int, int, struct proc *);
int priqclose(dev_t, int, int, struct proc *);
int priqioctl(dev_t, ioctlcmd_t, caddr_t, int, struct proc *);
static int priqcmd_if_attach(struct priq_interface *);
static int priqcmd_if_detach(struct priq_interface *);
static int priqcmd_add_class(struct priq_add_class *);
static int priqcmd_delete_class(struct priq_delete_class *);
static int priqcmd_modify_class(struct priq_modify_class *);
static int priqcmd_add_filter(struct priq_add_filter *);
static int priqcmd_delete_filter(struct priq_delete_filter *);
static int priqcmd_class_stats(struct priq_class_stats *);
static void get_class_stats(struct class_stats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_long);
static u_long clp_to_clh(struct priq_class *);
d69 14
a82 2
/* pif_list keeps all priq_if's allocated. */
static struct priq_if *pif_list = NULL;
d84 2
a85 4
static struct priq_if *
priq_attach(ifq, bandwidth)
	struct ifaltq *ifq;
	u_int bandwidth;
d88 6
d96 1
a96 1
	       M_DEVBUF, M_WAITOK);
d98 1
a98 1
		return (NULL);
d100 1
a100 1
	pif->pif_bandwidth = bandwidth;
d102 1
a102 1
	pif->pif_ifq = ifq;
d104 2
a105 3
	/* add this state to the priq list */
	pif->pif_next = pif_list;
	pif_list = pif;
d107 1
a107 1
	return (pif);
d110 42
a151 2
static int
priq_detach(pif)
d153 13
d167 13
a179 1
	(void)priq_clear_interface(pif);
d181 4
a184 13
	/* remove this interface from the pif list */
	if (pif_list == pif)
		pif_list = pif->pif_next;
	else {
		struct priq_if *p;

		for (p = pif_list; p != NULL; p = p->pif_next)
			if (p->pif_next == pif) {
				p->pif_next = pif->pif_next;
				break;
			}
		ASSERT(p != NULL);
	}
d186 3
a188 1
	FREE(pif, M_DEVBUF);
a202 3
	/* free the filters for this interface */
	acc_discard_filters(&pif->pif_classifier, NULL, 1);

d301 1
a301 1
	cl->cl_handle = (u_long)cl;  /* XXX: just a pointer to this class */
a363 3
	/* delete filters referencing to this class */
	acc_discard_filters(&cl->cl_pif->pif_classifier, cl, 0);

d407 1
d411 3
a413 1
	if (pktattr == NULL || (cl = pktattr->pattr_class) == NULL)
d415 6
a420 1
	cl->cl_pktattr = pktattr;  /* save proto hdr used by ECN */
d542 3
a544 208
/*
 * priq device interface
 */
int
priqopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	/* everything will be done when the queueing scheme is attached. */
	return 0;
}

int
priqclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct priq_if *pif;
	int err, error = 0;

	while ((pif = pif_list) != NULL) {
		/* destroy all */
		if (ALTQ_IS_ENABLED(pif->pif_ifq))
			altq_disable(pif->pif_ifq);

		err = altq_detach(pif->pif_ifq);
		if (err == 0)
			err = priq_detach(pif);
		if (err != 0 && error == 0)
			error = err;
	}

	return error;
}

int
priqioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	ioctlcmd_t cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct priq_if *pif;
	struct priq_interface *ifacep;
	int	error = 0;

	/* check super-user privilege */
	switch (cmd) {
	case PRIQ_GETSTATS:
		break;
	default:
#if (__FreeBSD_version > 400000)
		if ((error = suser(p)) != 0)
			return (error);
#else
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);
#endif
		break;
	}

	switch (cmd) {

	case PRIQ_IF_ATTACH:
		error = priqcmd_if_attach((struct priq_interface *)addr);
		break;

	case PRIQ_IF_DETACH:
		error = priqcmd_if_detach((struct priq_interface *)addr);
		break;

	case PRIQ_ENABLE:
	case PRIQ_DISABLE:
	case PRIQ_CLEAR:
		ifacep = (struct priq_interface *)addr;
		if ((pif = altq_lookup(ifacep->ifname,
				       ALTQT_PRIQ)) == NULL) {
			error = EBADF;
			break;
		}

		switch (cmd) {
		case PRIQ_ENABLE:
			if (pif->pif_default == NULL) {
#ifdef ALTQ_DEBUG
				printf("priq: no default class\n");
#endif
				error = EINVAL;
				break;
			}
			error = altq_enable(pif->pif_ifq);
			break;

		case PRIQ_DISABLE:
			error = altq_disable(pif->pif_ifq);
			break;

		case PRIQ_CLEAR:
			priq_clear_interface(pif);
			break;
		}
		break;

	case PRIQ_ADD_CLASS:
		error = priqcmd_add_class((struct priq_add_class *)addr);
		break;

	case PRIQ_DEL_CLASS:
		error = priqcmd_delete_class((struct priq_delete_class *)addr);
		break;

	case PRIQ_MOD_CLASS:
		error = priqcmd_modify_class((struct priq_modify_class *)addr);
		break;

	case PRIQ_ADD_FILTER:
		error = priqcmd_add_filter((struct priq_add_filter *)addr);
		break;

	case PRIQ_DEL_FILTER:
		error = priqcmd_delete_filter((struct priq_delete_filter *)addr);
		break;

	case PRIQ_GETSTATS:
		error = priqcmd_class_stats((struct priq_class_stats *)addr);
		break;

	default:
		error = EINVAL;
		break;
	}
	return error;
}

static int
priqcmd_if_attach(ap)
	struct priq_interface *ap;
{
	struct priq_if *pif;
	struct ifnet *ifp;
	int error;

	if ((ifp = ifunit(ap->ifname)) == NULL)
		return (ENXIO);

	if ((pif = priq_attach(&ifp->if_snd, ap->arg)) == NULL)
		return (ENOMEM);

	/*
	 * set PRIQ to this ifnet structure.
	 */
	if ((error = altq_attach(&ifp->if_snd, ALTQT_PRIQ, pif,
				 priq_enqueue, priq_dequeue, priq_request,
				 &pif->pif_classifier, acc_classify)) != 0)
		(void)priq_detach(pif);

	return (error);
}

static int
priqcmd_if_detach(ap)
	struct priq_interface *ap;
{
	struct priq_if *pif;
	int error;

	if ((pif = altq_lookup(ap->ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if (ALTQ_IS_ENABLED(pif->pif_ifq))
		altq_disable(pif->pif_ifq);

	if ((error = altq_detach(pif->pif_ifq)))
		return (error);

	return priq_detach(pif);
}

static int
priqcmd_add_class(ap)
	struct priq_add_class *ap;
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if (ap->pri < 0 || ap->pri >= PRIQ_MAXPRI)
		return (EINVAL);

	if ((cl = priq_class_create(pif, ap->pri,
				    ap->qlimit, ap->flags)) == NULL)
		return (ENOMEM);

	/* return a class handle to the user */
	ap->class_handle = clp_to_clh(cl);
	return (0);
}

static int
priqcmd_delete_class(ap)
	struct priq_delete_class *ap;
{
	struct priq_if *pif;
a545 13

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(pif, ap->class_handle)) == NULL)
		return (EINVAL);

	return priq_class_destroy(cl);
}

static int
priqcmd_modify_class(ap)
	struct priq_modify_class *ap;
d547 1
a547 95
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if (ap->pri < 0 || ap->pri >= PRIQ_MAXPRI)
		return (EINVAL);

	if ((cl = clh_to_clp(pif, ap->class_handle)) == NULL)
		return (EINVAL);

	/*
	 * if priority is changed, move the class to the new priority
	 */
	if (pif->pif_classes[ap->pri] != cl) {
		if (pif->pif_classes[ap->pri] != NULL)
			return (EEXIST);
		pif->pif_classes[cl->cl_pri] = NULL;
		pif->pif_classes[ap->pri] = cl;
		cl->cl_pri = ap->pri;
	}

	/* call priq_class_create to change class parameters */
	if ((cl = priq_class_create(pif, ap->pri,
				    ap->qlimit, ap->flags)) == NULL)
		return (ENOMEM);
	return 0;
}

static int
priqcmd_add_filter(ap)
	struct priq_add_filter *ap;
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(pif, ap->class_handle)) == NULL)
		return (EINVAL);

	return acc_add_filter(&pif->pif_classifier, &ap->filter,
			      cl, &ap->filter_handle);
}

static int
priqcmd_delete_filter(ap)
	struct priq_delete_filter *ap;
{
	struct priq_if *pif;

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	return acc_delete_filter(&pif->pif_classifier,
				 ap->filter_handle);
}

static int
priqcmd_class_stats(ap)
	struct priq_class_stats *ap;
{
	struct priq_if *pif;
	struct priq_class *cl;
	struct class_stats stats, *usp;
	int	pri, error;

	if ((pif = altq_lookup(ap->iface.ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	ap->maxpri = pif->pif_maxpri;

	/* then, read the next N classes in the tree */
	usp = ap->stats;
	for (pri = 0; pri <= pif->pif_maxpri; pri++) {
		cl = pif->pif_classes[pri];
		if (cl != NULL)
			get_class_stats(&stats, cl);
		else
			bzero(&stats, sizeof(stats));
		if ((error = copyout((caddr_t)&stats, (caddr_t)usp++,
				     sizeof(stats))) != 0)
			return (error);
	}
	return (0);
}

static void get_class_stats(sp, cl)
	struct class_stats *sp;
	struct priq_class *cl;
{
	sp->class_handle = clp_to_clh(cl);

d549 1
d570 1
a570 1
	u_long chandle;
d572 1
a572 1
	struct priq_class *cl;
d574 1
a574 5
	cl = (struct priq_class *)chandle;
	if (chandle != ALIGN(cl)) {
#ifdef ALTQ_DEBUG
		printf("clh_to_cl: unaligned pointer %p\n", cl);
#endif
d576 2
a577 3
	}

	if (cl == NULL || cl->cl_handle != chandle || cl->cl_pif != pif)
d579 1
a579 1
	return (cl);
a580 17

/* convert a class pointer to the corresponding class handle */
static u_long
clp_to_clh(cl)
	struct priq_class *cl;
{
	return (cl->cl_handle);
}

#ifdef KLD_MODULE

static struct altqsw priq_sw =
	{"priq", priqopen, priqclose, priqioctl};

ALTQ_MODULE(altq_priq, ALTQT_PRIQ, &priq_sw);

#endif /* KLD_MODULE */
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.4 2002/03/14 01:26:26 millert Exp $	*/
d199 1
d201 1
d570 1
a570 1
#if 1
d828 1
a828 1
#if 1
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.3 2001/10/26 07:36:46 kjc Exp $	*/
d122 1
a122 1
	
d269 1
a269 1
		} else 
d346 1
a346 1
static int 
d434 1
a434 1
	
d544 1
a544 1
    
d625 1
a625 1
	
d631 1
a631 1
	
d652 1
a652 1
	
d678 1
a678 1
		
d696 1
a696 1
	
d772 1
a772 1
	
@


1.3
log
@avoid divide-by-zero when the specified bandwidth is less than 8bps.

PR kernel/2150
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.2 2001/08/09 14:32:59 deraadt Exp $	*/
d53 31
a83 31
static struct priq_if *priq_attach __P((struct ifaltq *, u_int));
static int priq_detach __P((struct priq_if *));
static int priq_clear_interface __P((struct priq_if *));
static int priq_request __P((struct ifaltq *, int, void *));
static void priq_purge __P((struct priq_if *));
static struct priq_class *priq_class_create __P((struct priq_if *,
						 int, int, int));
static int priq_class_destroy __P((struct priq_class *));
static int priq_enqueue __P((struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *));
static struct mbuf *priq_dequeue __P((struct ifaltq *, int));

static int priq_addq __P((struct priq_class *, struct mbuf *));
static struct mbuf *priq_getq __P((struct priq_class *));
static struct mbuf *priq_pollq __P((struct priq_class *));
static void priq_purgeq __P((struct priq_class *));

int priqopen __P((dev_t, int, int, struct proc *));
int priqclose __P((dev_t, int, int, struct proc *));
int priqioctl __P((dev_t, ioctlcmd_t, caddr_t, int, struct proc *));
static int priqcmd_if_attach __P((struct priq_interface *));
static int priqcmd_if_detach __P((struct priq_interface *));
static int priqcmd_add_class __P((struct priq_add_class *));
static int priqcmd_delete_class __P((struct priq_delete_class *));
static int priqcmd_modify_class __P((struct priq_modify_class *));
static int priqcmd_add_filter __P((struct priq_add_filter *));
static int priqcmd_delete_filter __P((struct priq_delete_filter *));
static int priqcmd_class_stats __P((struct priq_class_stats *));
static void get_class_stats __P((struct class_stats *, struct priq_class *));
static struct priq_class *clh_to_clp __P((struct priq_if *, u_long));
static u_long clp_to_clh __P((struct priq_class *));
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.3 2001/10/26 07:36:46 kjc Exp $	*/
d53 31
a83 31
static struct priq_if *priq_attach(struct ifaltq *, u_int);
static int priq_detach(struct priq_if *);
static int priq_clear_interface(struct priq_if *);
static int priq_request(struct ifaltq *, int, void *);
static void priq_purge(struct priq_if *);
static struct priq_class *priq_class_create(struct priq_if *,
						 int, int, int);
static int priq_class_destroy(struct priq_class *);
static int priq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf *priq_dequeue(struct ifaltq *, int);

static int priq_addq(struct priq_class *, struct mbuf *);
static struct mbuf *priq_getq(struct priq_class *);
static struct mbuf *priq_pollq(struct priq_class *);
static void priq_purgeq(struct priq_class *);

int priqopen(dev_t, int, int, struct proc *);
int priqclose(dev_t, int, int, struct proc *);
int priqioctl(dev_t, ioctlcmd_t, caddr_t, int, struct proc *);
static int priqcmd_if_attach(struct priq_interface *);
static int priqcmd_if_detach(struct priq_interface *);
static int priqcmd_add_class(struct priq_add_class *);
static int priqcmd_delete_class(struct priq_delete_class *);
static int priqcmd_modify_class(struct priq_modify_class *);
static int priqcmd_add_filter(struct priq_add_filter *);
static int priqcmd_delete_filter(struct priq_delete_filter *);
static int priqcmd_class_stats(struct priq_class_stats *);
static void get_class_stats(struct class_stats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_long);
static u_long clp_to_clh(struct priq_class *);
@


1.3.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
d44 1
a44 1
#include <netinet/in.h>
a45 1
#include <net/pfvar.h>
d47 1
d53 2
d58 2
a59 2
static struct priq_class *priq_class_create(struct priq_if *, int, int, int,
    int);
d70 22
a91 5
static void get_class_stats(struct priq_classstats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_int32_t);

int
priq_pfattach(struct pf_altq *a)
d93 1
a93 22
	struct ifnet *ifp;
	int s, error;

	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
		return (EINVAL);
	s = splimp();
	error = altq_attach(&ifp->if_snd, ALTQT_PRIQ, a->altq_disc,
	    priq_enqueue, priq_dequeue, priq_request, NULL, NULL);
	splx(s);
	return (error);
}

int
priq_add_altq(struct pf_altq *a)
{
	struct priq_if	*pif;
	struct ifnet	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (EINVAL);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENODEV);
d96 1
a96 1
	    M_DEVBUF, M_WAITOK);
d98 1
a98 1
		return (ENOMEM);
d100 1
a100 1
	pif->pif_bandwidth = a->ifbandwidth;
d102 1
a102 1
	pif->pif_ifq = &ifp->if_snd;
d104 3
a106 2
	/* keep the state in pf_altq */
	a->altq_disc = pif;
d108 1
a108 1
	return (0);
d111 3
a113 2
int
priq_remove_altq(struct pf_altq *a)
d115 1
a115 1
	struct priq_if *pif;
d117 13
a129 5
	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;

	(void)priq_clear_interface(pif);
a134 70
int
priq_add_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	/* check parameters */
	if (a->priority >= PRIQ_MAXPRI)
		return (EINVAL);
	if (a->qid == 0)
		return (EINVAL);
	if (a->qid > PRIQ_MAXQID)
		return (EINVAL);
	if (clh_to_clp(pif, a->qid) != NULL)
		return (EBUSY);

	cl = priq_class_create(pif, a->priority, a->qlimit,
	    a->pq_u.priq_opts.flags, a->qid);
	if (cl == NULL)
		return (ENOMEM);

	return (0);
}

int
priq_remove_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	return (priq_class_destroy(cl));
}

int
priq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	struct priq_if *pif;
	struct priq_class *cl;
	struct priq_classstats stats;
	int error = 0;

	if ((pif = altq_lookup(a->ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);
#if 0
	stats.handle = a->qid;
#endif

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
	return (0);
}

d140 2
a141 1
priq_clear_interface(struct priq_if *pif)
d146 3
d158 4
a161 1
priq_request(struct ifaltq *ifq, int req, void *arg)
d175 2
a176 1
priq_purge(struct priq_if *pif)
d190 3
a192 1
priq_class_create(struct priq_if *pif, int pri, int qlimit, int flags, int qid)
a198 1
#ifdef ALTQ_DEBUG
a199 1
#endif
d245 1
a245 1
	cl->cl_handle = qid;
d269 1
a269 1
		} else
d272 2
a273 4
			cl->cl_red = red_alloc(0, 0,
			    qlimit(cl->cl_q) * 10/100,
			    qlimit(cl->cl_q) * 30/100,
			    red_flags, red_pkttime);
d300 2
a301 1
priq_class_destroy(struct priq_class *cl)
d308 3
d346 5
a350 2
static int
priq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
a353 1
	struct m_tag *t;
d357 1
a357 10
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
	if (t == NULL ||
	    (cl = clh_to_clp(pif, ((struct altq_tag *)(t+1))->qid)) == NULL) {
d359 1
a359 6
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		cl->cl_pktattr = NULL;
	}
d383 3
a385 1
priq_dequeue(struct ifaltq *ifq, int op)
d416 3
a418 1
priq_addq(struct priq_class *cl, struct mbuf *m)
d434 1
a434 1

d444 2
a445 1
priq_getq(struct priq_class *cl)
d466 2
a467 1
priq_purgeq(struct priq_class *cl)
d481 315
a795 2
static void
get_class_stats(struct priq_classstats *sp, struct priq_class *cl)
d797 2
a798 1
	sp->class_handle = cl->cl_handle;
a799 1
	sp->qlimit = qlimit(cl->cl_q);
d818 3
a820 1
clh_to_clp(struct priq_if *pif, u_int32_t chandle)
d822 1
a822 1
	int idx;
d824 5
a828 1
	if (chandle == 0)
d830 1
d832 4
a835 4
	for (idx = pif->pif_maxpri; idx >= 0; idx--)
		if (pif->pif_classes[idx] != NULL &&
		    pif->pif_classes[idx]->cl_handle == chandle)
			return (pif->pif_classes[idx]);
d837 6
a842 1
	return (NULL);
d844 9
@


1.2
log
@change a maze of altq options into just "altq" for the base+red+cbq, and
then altq_* for each of the other * experimental options.  and.. enable
it by default in GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.1 2001/06/27 05:28:35 kjc Exp $	*/
d258 1
a258 1
		if (pif->pif_bandwidth == 0)
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 12
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include "opt_altq.h"
#if (__FreeBSD__ != 2)
#include "opt_inet.h"
#ifdef __FreeBSD__
#include "opt_inet6.h"
#endif
#endif
#endif /* __FreeBSD__ || __NetBSD__ */

#ifdef ALTQ_PRIQ  /* priq is enabled by ALTQ_PRIQ option in opt_altq.h */

a852 2

#endif /* ALTQ_PRIQ */
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.1 2001/06/27 05:28:35 kjc Exp $	*/
d32 12
d270 1
a270 1
		if (pif->pif_bandwidth < 8)
d865 2
@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 31
a83 31
static struct priq_if *priq_attach(struct ifaltq *, u_int);
static int priq_detach(struct priq_if *);
static int priq_clear_interface(struct priq_if *);
static int priq_request(struct ifaltq *, int, void *);
static void priq_purge(struct priq_if *);
static struct priq_class *priq_class_create(struct priq_if *,
						 int, int, int);
static int priq_class_destroy(struct priq_class *);
static int priq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf *priq_dequeue(struct ifaltq *, int);

static int priq_addq(struct priq_class *, struct mbuf *);
static struct mbuf *priq_getq(struct priq_class *);
static struct mbuf *priq_pollq(struct priq_class *);
static void priq_purgeq(struct priq_class *);

int priqopen(dev_t, int, int, struct proc *);
int priqclose(dev_t, int, int, struct proc *);
int priqioctl(dev_t, ioctlcmd_t, caddr_t, int, struct proc *);
static int priqcmd_if_attach(struct priq_interface *);
static int priqcmd_if_detach(struct priq_interface *);
static int priqcmd_add_class(struct priq_add_class *);
static int priqcmd_delete_class(struct priq_delete_class *);
static int priqcmd_modify_class(struct priq_modify_class *);
static int priqcmd_add_filter(struct priq_add_filter *);
static int priqcmd_delete_filter(struct priq_delete_filter *);
static int priqcmd_class_stats(struct priq_class_stats *);
static void get_class_stats(struct class_stats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_long);
static u_long clp_to_clh(struct priq_class *);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d36 1
d44 1
a44 1
#include <netinet/in.h>
a45 1
#include <net/pfvar.h>
d47 1
d53 2
d58 2
a59 2
static struct priq_class *priq_class_create(struct priq_if *, int, int, int,
    int);
d70 22
a91 5
static void get_class_stats(struct priq_classstats *, struct priq_class *);
static struct priq_class *clh_to_clp(struct priq_if *, u_int32_t);

int
priq_pfattach(struct pf_altq *a)
d93 1
a93 22
	struct ifnet *ifp;
	int s, error;

	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
		return (EINVAL);
	s = splimp();
	error = altq_attach(&ifp->if_snd, ALTQT_PRIQ, a->altq_disc,
	    priq_enqueue, priq_dequeue, priq_request, NULL, NULL);
	splx(s);
	return (error);
}

int
priq_add_altq(struct pf_altq *a)
{
	struct priq_if	*pif;
	struct ifnet	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (EINVAL);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENODEV);
d96 1
a96 1
	    M_DEVBUF, M_WAITOK);
d98 1
a98 1
		return (ENOMEM);
d100 1
a100 1
	pif->pif_bandwidth = a->ifbandwidth;
d102 1
a102 1
	pif->pif_ifq = &ifp->if_snd;
d104 3
a106 2
	/* keep the state in pf_altq */
	a->altq_disc = pif;
d108 1
a108 1
	return (0);
d111 3
a113 2
int
priq_remove_altq(struct pf_altq *a)
a114 6
	struct priq_if *pif;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;

d117 12
a128 23
	FREE(pif, M_DEVBUF);
	return (0);
}

int
priq_add_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	/* check parameters */
	if (a->priority >= PRIQ_MAXPRI)
		return (EINVAL);

	if (a->qid != 0) {
		/* qid is tied to priority with priq */
		if (a->qid != a->priority + 1)
			return (EINVAL);
		if (clh_to_clp(pif, a->qid) != NULL)
			return (EBUSY);
d131 1
a131 51
	cl = priq_class_create(pif, a->priority, a->qlimit,
	    a->pq_u.priq_opts.flags, a->qid);
	if (cl == NULL)
		return (ENOMEM);

	/* return handle to user space. */
	a->qid = cl->cl_handle;

	return (0);
}

int
priq_remove_queue(struct pf_altq *a)
{
	struct priq_if *pif;
	struct priq_class *cl;

	if ((pif = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	return (priq_class_destroy(cl));
}

int
priq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	struct priq_if *pif;
	struct priq_class *cl;
	struct priq_classstats stats;
	int error = 0;

	if ((pif = altq_lookup(a->ifname, ALTQT_PRIQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(pif, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);
#if 0
	stats.handle = a->qid;
#endif

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
d140 2
a141 1
priq_clear_interface(struct priq_if *pif)
d146 3
d158 4
a161 1
priq_request(struct ifaltq *ifq, int req, void *arg)
d175 2
a176 1
priq_purge(struct priq_if *pif)
d190 3
a192 1
priq_class_create(struct priq_if *pif, int pri, int qlimit, int flags, int qid)
a198 1
#ifdef ALTQ_DEBUG
a199 1
#endif
d245 1
a245 4
	if (qid)
		cl->cl_handle = qid;
	else
		cl->cl_handle = pri + 1;
d269 1
a269 1
		} else
d272 2
a273 4
			cl->cl_red = red_alloc(0, 0,
			    qlimit(cl->cl_q) * 10/100,
			    qlimit(cl->cl_q) * 30/100,
			    red_flags, red_pkttime);
d300 2
a301 1
priq_class_destroy(struct priq_class *cl)
d308 3
d346 5
a350 2
static int
priq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
a353 1
	struct m_tag *t;
d357 1
a357 10
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
	if (t == NULL ||
	    (cl = clh_to_clp(pif, ((struct altq_tag *)(t+1))->qid)) == NULL) {
d359 1
a359 6
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		cl->cl_pktattr = NULL;
	}
d383 3
a385 1
priq_dequeue(struct ifaltq *ifq, int op)
d416 3
a418 1
priq_addq(struct priq_class *cl, struct mbuf *m)
d434 1
a434 1

d444 2
a445 1
priq_getq(struct priq_class *cl)
d466 2
a467 1
priq_purgeq(struct priq_class *cl)
d481 315
a795 2
static void
get_class_stats(struct priq_classstats *sp, struct priq_class *cl)
d797 2
a798 1
	sp->class_handle = cl->cl_handle;
a799 1
	sp->qlimit = qlimit(cl->cl_q);
d818 3
a820 1
clh_to_clp(struct priq_if *pif, u_int32_t chandle)
d822 1
a822 1
	int idx;
d824 5
a828 1
	if (chandle == 0)
d830 3
a832 2
	idx = chandle - 1;
	if (idx >= PRIQ_MAXPRI)
d834 1
a834 1
	return (pif->pif_classes[idx]);
d836 17
@


1.1.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_priq.c,v 1.1.2.3 2003/03/27 22:28:25 niklas Exp $	*/
d138 8
a145 6
	if (a->qid == 0)
		return (EINVAL);
	if (a->qid > PRIQ_MAXQID)
		return (EINVAL);
	if (clh_to_clp(pif, a->qid) != NULL)
		return (EBUSY);
d152 3
d303 4
a306 1
	cl->cl_handle = qid;
d576 4
a579 7

	for (idx = pif->pif_maxpri; idx >= 0; idx--)
		if (pif->pif_classes[idx] != NULL &&
		    pif->pif_classes[idx]->cl_handle == chandle)
			return (pif->pif_classes[idx]);

	return (NULL);
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 2
a141 2
	if (pif->pif_classes[a->priority] != NULL)
		return (EBUSY);
d186 3
a563 1
	struct priq_class *cl;
d570 3
a572 3
		if ((cl = pif->pif_classes[idx]) != NULL &&
		    cl->cl_handle == chandle)
			return (cl);
@


