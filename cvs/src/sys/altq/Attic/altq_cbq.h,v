head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.10.0.30
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.28
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.24
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.26
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.22
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.20
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.18
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.16
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.14
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.12
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.10
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.8
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.6
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.1.0.10
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.8
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.13;

1.13
date	2011.07.04.01.07.43;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.03.23.48.41;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.03.22.39.12;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.14.08.42.23;	author kjc;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.20.12.33.57;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.02.14.51.45;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.17.27.19;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.09.18.05;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.11.09.30.30;	author kjc;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.10.10.44.02;	author kjc;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.34;	author kjc;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2003.03.27.22.28.24;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.05.13.19.21.26;	author ho;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2004.02.19.10.51.22;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@bye bye
@
text
@/*	$OpenBSD: altq_cbq.h,v 1.13 2011/07/04 01:07:43 henning Exp $	*/
/*	$KAME: altq_cbq.h,v 1.5 2000/12/02 13:44:40 kjc Exp $	*/

/*
 * Copyright (c) Sun Microsystems, Inc. 1993-1998 All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the SMCC Technology
 *      Development Group at Sun Microsystems, Inc.
 *
 * 4. The name of the Sun Microsystems, Inc nor may not be used to endorse or
 *      promote products derived from this software without specific prior
 *      written permission.
 *
 * SUN MICROSYSTEMS DOES NOT CLAIM MERCHANTABILITY OF THIS SOFTWARE OR THE
 * SUITABILITY OF THIS SOFTWARE FOR ANY PARTICULAR PURPOSE.  The software is
 * provided "as is" without express or implied warranty of any kind.
 *
 * These notices must be retained in any copies of any part of this software.
 */

#ifndef _ALTQ_ALTQ_CBQ_H_
#define	_ALTQ_ALTQ_CBQ_H_

#include <altq/altq.h>
#include <altq/altq_rmclass.h>
#include <altq/altq_red.h>

#ifdef __cplusplus
extern "C" {
#endif

#define	NULL_CLASS_HANDLE	0

/* class flags should be same as class flags in rm_class.h */
#define	CBQCLF_RED		0x0001	/* use RED */
#define	CBQCLF_ECN		0x0002  /* use RED/ECN */
#define	CBQCLF_RIO		0x0004  /* use RIO */
#define	CBQCLF_BORROW		0x0020  /* borrow from parent */

/* class flags only for root class */
#define	CBQCLF_WRR		0x0100	/* weighted-round robin */

/* class flags for special classes */
#define	CBQCLF_ROOTCLASS	0x1000	/* root class */
#define	CBQCLF_DEFCLASS		0x2000	/* default class */
#define	CBQCLF_CLASSMASK	0xf000	/* class mask */

#define	CBQ_MAXQSIZE		200
#define	CBQ_MAXPRI		RM_MAXPRIO

typedef struct _cbq_class_stats_ {
	u_int32_t	handle;
	u_int		depth;

	struct pktcntr	xmit_cnt;	/* packets sent in this class */
	struct pktcntr	drop_cnt;	/* dropped packets */
	u_int		over;		/* # times went over limit */
	u_int		borrows;	/* # times tried to borrow */
	u_int		overactions;	/* # times invoked overlimit action */
	u_int		delays;		/* # times invoked delay actions */

	/* other static class parameters useful for debugging */
	int		priority;
	int		maxidle;
	int		minidle;
	int		offtime;
	int		qmax;
	int		ns_per_byte;
	int		wrr_allot;

	int		qcnt;		/* # packets in queue */
	int		avgidle;

	/* red and rio related info */
	int		qtype;
	struct redstats	red[3];
} class_stats_t;

#ifdef _KERNEL
/*
 * Define macros only good for kernel drivers and modules.
 */
#define	CBQ_WATCHDOG		(hz / 20)
#define	CBQ_TIMEOUT		10
#define	CBQ_LS_TIMEOUT		(20 * hz / 1000)

#define	CBQ_MAX_CLASSES		256

/*
 * Define State structures.
 */
typedef struct cbqstate {
	int			 cbq_qlen;	/* # of packets in cbq */
	struct rm_class		*cbq_class_tbl[CBQ_MAX_CLASSES];

	struct rm_ifdat		 ifnp;
	struct callout		 cbq_callout;	/* for timeouts */
} cbq_state_t;

#endif /* _KERNEL */

#ifdef __cplusplus
}
#endif

#endif /* !_ALTQ_ALTQ_CBQ_H_ */
@


1.13
log
@rip out more effectively dead code, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.12 2011/07/03 23:48:41 henning Exp $	*/
@


1.12
log
@g/c code to read/write the dscp field. with pf as classifier altq has no
business in mucking with it and since the _CLEARDSCP flags were never
possibly set that is effectively dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.11 2011/07/03 22:39:12 tedu Exp $	*/
a50 1
#define	CBQCLF_FLOWVALVE	0x0008	/* use flowvalve (aka penalty-box) */
a54 1
#define	CBQCLF_EFFICIENT	0x0200  /* work-conserving */
@


1.11
log
@cdnr and rio disciplines are not being used or supported, clear a path
for new code.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.10 2004/01/14 08:42:23 kjc Exp $	*/
a51 1
#define	CBQCLF_CLEARDSCP	0x0010  /* clear diffserv codepoint */
@


1.10
log
@eliminate the predefined special qids so that qids become simple
identifiers without embedded meanings.

this also allows us to make the semantics of the qid assignment in line
with the tag assignment in the next step.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.9 2003/08/22 21:50:34 david Exp $	*/
a39 1
#include <altq/altq_rio.h>
@


1.9
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.8 2003/08/20 12:33:57 henning Exp $	*/
d46 1
a46 6
/*
 * Define a well known class handles
 */
#define	NULL_CLASS_HANDLE	0xffffffff
#define	ROOT_CLASS_HANDLE	0xfffffffe
#define	DEFAULT_CLASS_HANDLE	0xfffffffd
d100 1
a100 1
#define	CBQ_WATCHDOG		(HZ / 20)
@


1.8
log
@#define CBQ_MAXPRI RM_MAXPRIO and use it
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.7 2003/04/02 14:51:45 henning Exp $	*/
d53 1
a53 1
/* class flags shoud be same as class flags in rm_class.h */
@


1.7
log
@remove what is left over from the control class stuff

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.6 2002/12/16 17:27:19 henning Exp $	*/
d71 1
@


1.6
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.5 2002/12/16 09:18:05 kjc Exp $	*/
a51 1
#define	CTL_CLASS_HANDLE	0xfffffffc
a67 1
#define	CBQCLF_CTLCLASS		0x4000	/* control class */
@


1.5
log
@switchover to pf-based altq.
 - remove files which are no longer used, or we don't have plans to support
   in pf in the near future.
 - remove altq ioctl related stuff.
 - convert the PRIQ, HFSC and RIO modules to pf-based altq.
   (these are not enabled in GENERIC, CDNR is not converted yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.4 2002/11/26 01:03:34 henning Exp $	*/
d72 1
a72 1
#define	CBQ_MAXQSIZE	200
d106 1
a106 1
#define	CBQ_WATCHDOG    	(HZ / 20)
d110 1
a110 1
#define	CBQ_MAX_CLASSES	256
d116 1
a116 1
	int			cbq_qlen;	/* # of packets in cbq */
d119 2
a120 2
	struct rm_ifdat		ifnp;
	struct callout		cbq_callout;	/* for timeouts */
@


1.4
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.3 2002/10/11 09:30:30 kjc Exp $	*/
a36 1
#include <sys/ioccom.h>
a41 2
/* #pragma ident "@@(#)cbq.h  1.18     98/05/13 SMI" */

a53 27
/*
 * Define structures associated with IOCTLS for cbq.
 */

/*
 * Define the CBQ interface structure.  This must be included in all
 * IOCTL's such that the CBQ driver may find the appropriate CBQ module
 * associated with the network interface to be affected.
 */
struct cbq_interface {
	char	cbq_ifacename[IFNAMSIZ];
};

typedef struct cbq_class_spec {
	u_int		priority;
	u_int		nano_sec_per_byte;
	u_int		maxq;
	u_int		maxidle;
	int		minidle;
	u_int		offtime;
	u_int32_t	parent_class_handle;
	u_int32_t	borrow_class_handle;

	u_int		pktsize;
	int		flags;
} cbq_class_spec_t;

a73 32
struct cbq_add_class {
	struct cbq_interface	cbq_iface;

	cbq_class_spec_t	cbq_class;
	u_int32_t		cbq_class_handle;
};

struct cbq_delete_class {
	struct cbq_interface	cbq_iface;
	u_int32_t		cbq_class_handle;
};

struct cbq_modify_class {
	struct cbq_interface	cbq_iface;

	cbq_class_spec_t	cbq_class;
	u_int32_t		cbq_class_handle;
};

struct cbq_add_filter {
	struct cbq_interface	cbq_iface;
	u_int32_t		cbq_class_handle;
	struct flow_filter	cbq_filter;

	u_long			cbq_filter_handle;
};

struct cbq_delete_filter {
	struct cbq_interface	cbq_iface;
	u_long			cbq_filter_handle;
};

a101 22
/* number of classes are returned in nclasses field */
struct cbq_getstats {
	struct cbq_interface	iface;
	int			nclasses;
	class_stats_t		*stats;
};

/*
 * Define IOCTLs for CBQ.
 */
#define	CBQ_IF_ATTACH		_IOW('Q', 1, struct cbq_interface)
#define	CBQ_IF_DETACH		_IOW('Q', 2, struct cbq_interface)
#define	CBQ_ENABLE		_IOW('Q', 3, struct cbq_interface)
#define	CBQ_DISABLE		_IOW('Q', 4, struct cbq_interface)
#define	CBQ_CLEAR_HIERARCHY	_IOW('Q', 5, struct cbq_interface)
#define	CBQ_ADD_CLASS		_IOWR('Q', 7, struct cbq_add_class)
#define	CBQ_DEL_CLASS		_IOW('Q', 8, struct cbq_delete_class)
#define	CBQ_MODIFY_CLASS	_IOWR('Q', 9, struct cbq_modify_class)
#define	CBQ_ADD_FILTER		_IOWR('Q', 10, struct cbq_add_filter)
#define	CBQ_DEL_FILTER		_IOW('Q', 11, struct cbq_delete_filter)
#define	CBQ_GETSTATS		_IOWR('Q', 12, struct cbq_getstats)

a105 4

#define	DISABLE		0x00
#define	ENABLE		0x01

a110 1
#define	CBQ_MAX_FILTERS 256
a115 1
	struct cbqstate		*cbq_next;
d117 1
a117 1
	struct rm_class		**cbq_class_tbl;
a120 2

	struct acc_classifier	cbq_classifier;
@


1.3
log
@make CBQ aware of the pf API so that pf developers can play with CBQ.

for now, implemnet a tentative transition mechanism to allow the old API
and the new API to coexit.
the old API will go away when pfctl(8) becomes ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.2 2002/10/10 10:44:02 kjc Exp $	*/
d30 1
a30 1
 *  
d47 1
a47 1
#endif 
d75 1
a75 1
	int		minidle;	
d107 1
a107 1
	cbq_class_spec_t	cbq_class;	
d119 1
a119 1
	cbq_class_spec_t	cbq_class;	
d171 1
a171 1
/* 
d219 1
a219 1
#endif 
@


1.2
log
@add a borrow flag to be used by pf/altq.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.1 2001/06/27 05:28:34 kjc Exp $	*/
d77 2
a78 2
	u_long		parent_class_handle;
	u_long		borrow_class_handle;
d108 1
a108 1
	u_long			cbq_class_handle;
d113 1
a113 1
	u_long			cbq_class_handle;
d120 1
a120 1
	u_long			cbq_class_handle;
d124 2
a125 2
	struct cbq_interface		cbq_iface;
	u_long			cbq_class_handle;
d137 1
a137 1
	u_int		handle;
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
@


1.1.2.1
log
@Sync the SMP branch with 3.3
@
text
@d30 1
a30 1
 *
d37 1
d43 2
d47 1
a47 1
#endif
d57 27
a89 1
#define	CBQCLF_BORROW		0x0020  /* borrow from parent */
d101 33
a133 1
#define	CBQ_MAXQSIZE		200
d136 1
a136 1
	u_int32_t	handle;
d163 22
d189 5
a193 1
#define	CBQ_WATCHDOG		(HZ / 20)
d197 2
a198 1
#define	CBQ_MAX_CLASSES		256
d204 6
a209 2
	int			 cbq_qlen;	/* # of packets in cbq */
	struct rm_class		*cbq_class_tbl[CBQ_MAX_CLASSES];
d211 1
a211 2
	struct rm_ifdat		 ifnp;
	struct callout		 cbq_callout;	/* for timeouts */
d218 1
a218 1
#endif
@


1.1.2.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.1.2.1 2003/03/27 22:28:24 niklas Exp $	*/
d52 1
d69 1
@


1.1.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 6
a51 1
#define	NULL_CLASS_HANDLE	0
d53 1
a53 1
/* class flags should be same as class flags in rm_class.h */
a70 1
#define	CBQ_MAXPRI		RM_MAXPRIO
d104 1
a104 1
#define	CBQ_WATCHDOG		(hz / 20)
@


1.1.6.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.h,v 1.1 2001/06/27 05:28:34 kjc Exp $	*/
d77 2
a78 2
	u_int32_t	parent_class_handle;
	u_int32_t	borrow_class_handle;
a89 1
#define	CBQCLF_BORROW		0x0020  /* borrow from parent */
d107 1
a107 1
	u_int32_t		cbq_class_handle;
d112 1
a112 1
	u_int32_t		cbq_class_handle;
d119 1
a119 1
	u_int32_t		cbq_class_handle;
d123 2
a124 2
	struct cbq_interface	cbq_iface;
	u_int32_t		cbq_class_handle;
d136 1
a136 1
	u_int32_t	handle;
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
 *
d37 1
d43 2
d47 1
a47 1
#endif
d55 28
d99 1
d102 33
a134 1
#define	CBQ_MAXQSIZE		200
d164 22
d190 5
a194 1
#define	CBQ_WATCHDOG		(HZ / 20)
d198 2
a199 1
#define	CBQ_MAX_CLASSES		256
d205 6
a210 2
	int			 cbq_qlen;	/* # of packets in cbq */
	struct rm_class		*cbq_class_tbl[CBQ_MAX_CLASSES];
d212 1
a212 2
	struct rm_ifdat		 ifnp;
	struct callout		 cbq_callout;	/* for timeouts */
d219 1
a219 1
#endif
@


