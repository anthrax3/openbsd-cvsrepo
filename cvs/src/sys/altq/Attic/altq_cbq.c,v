head	1.27;
access;
symbols
	OPENBSD_5_5:1.26.0.14
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.10
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.12
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.27
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.26;

1.26
date	2011.07.03.23.59.43;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.09.14.10.05;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.08.15.22.02;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.13.20.40.02;	author chl;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.28.17.16.38;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.10.17.47.52;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.14.08.42.23;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.20.12.33.57;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.02.14.51.45;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.31.12.35.45;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.11.02.25.59;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.02.11.22.31;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.05.17.43.12;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.30.09.55.42;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.07.00.29.28;	author cloder;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.16.17.27.19;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.16.09.18.05;	author kjc;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.11.09.30.30;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.05.02.57.58;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.09.14.32.59;	author deraadt;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.06.27.05.28.34;	author kjc;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.10.31.02.43.21;	author nate;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.22.28.24;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.13.19.21.26;	author ho;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.51.21;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.10.29.00.27.59;	author art;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@bye bye
@
text
@/*	$OpenBSD: altq_cbq.c,v 1.26 2011/07/03 23:59:43 henning Exp $	*/
/*	$KAME: altq_cbq.c,v 1.9 2000/12/14 08:12:45 thorpej Exp $	*/

/*
 * Copyright (c) Sun Microsystems, Inc. 1993-1998 All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the SMCC Technology
 *      Development Group at Sun Microsystems, Inc.
 *
 * 4. The name of the Sun Microsystems, Inc nor may not be used to endorse or
 *      promote products derived from this software without specific prior
 *      written permission.
 *
 * SUN MICROSYSTEMS DOES NOT CLAIM MERCHANTABILITY OF THIS SOFTWARE OR THE
 * SUITABILITY OF THIS SOFTWARE FOR ANY PARTICULAR PURPOSE.  The software is
 * provided "as is" without express or implied warranty of any kind.
 *
 * These notices must be retained in any copies of any part of this software.
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/time.h>

#include <net/if.h>
#include <netinet/in.h>

#include <net/pfvar.h>
#include <altq/altq.h>
#include <altq/altq_cbq.h>

/*
 * Forward Declarations.
 */
static int		 cbq_class_destroy(cbq_state_t *, struct rm_class *);
static struct rm_class  *clh_to_clp(cbq_state_t *, u_int32_t);
static int		 cbq_clear_interface(cbq_state_t *);
static int		 cbq_request(struct ifaltq *, int, void *);
static int		 cbq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf	*cbq_dequeue(struct ifaltq *, int);
static void		 cbqrestart(struct ifaltq *);
static void		 get_class_stats(class_stats_t *, struct rm_class *);
static void		 cbq_purge(cbq_state_t *);

/*
 * int
 * cbq_class_destroy(cbq_mod_state_t *, struct rm_class *) - This
 *	function destroys a given traffic class.  Before destroying
 *	the class, all traffic for that class is released.
 */
static int
cbq_class_destroy(cbq_state_t *cbqp, struct rm_class *cl)
{
	int	i;

	/* delete the class */
	rmc_delete_class(&cbqp->ifnp, cl);

	/*
	 * free the class handle
	 */
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if (cbqp->cbq_class_tbl[i] == cl)
			cbqp->cbq_class_tbl[i] = NULL;

	if (cl == cbqp->ifnp.root_)
		cbqp->ifnp.root_ = NULL;
	if (cl == cbqp->ifnp.default_)
		cbqp->ifnp.default_ = NULL;
	return (0);
}

/* convert class handle to class pointer */
static struct rm_class *
clh_to_clp(cbq_state_t *cbqp, u_int32_t chandle)
{
	int i;
	struct rm_class *cl;

	if (chandle == 0)
		return (NULL);
	/*
	 * first, try the slot corresponding to the lower bits of the handle.
	 * if it does not match, do the linear table search.
	 */
	i = chandle % CBQ_MAX_CLASSES;
	if ((cl = cbqp->cbq_class_tbl[i]) != NULL &&
	    cl->stats_.handle == chandle)
		return (cl);
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if ((cl = cbqp->cbq_class_tbl[i]) != NULL &&
		    cl->stats_.handle == chandle)
			return (cl);
	return (NULL);
}

static int
cbq_clear_interface(cbq_state_t *cbqp)
{
	int		 again, i;
	struct rm_class	*cl;

	/* clear out the classes now */
	do {
		again = 0;
		for (i = 0; i < CBQ_MAX_CLASSES; i++) {
			if ((cl = cbqp->cbq_class_tbl[i]) != NULL) {
				if (is_a_parent_class(cl))
					again++;
				else {
					cbq_class_destroy(cbqp, cl);
					cbqp->cbq_class_tbl[i] = NULL;
					if (cl == cbqp->ifnp.root_)
						cbqp->ifnp.root_ = NULL;
					if (cl == cbqp->ifnp.default_)
						cbqp->ifnp.default_ = NULL;
				}
			}
		}
	} while (again);

	return (0);
}

static int
cbq_request(struct ifaltq *ifq, int req, void *arg)
{
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;

	switch (req) {
	case ALTRQ_PURGE:
		cbq_purge(cbqp);
		break;
	}
	return (0);
}

/* copy the stats info in rm_class to class_states_t */
static void
get_class_stats(class_stats_t *statsp, struct rm_class *cl)
{
	statsp->handle		= cl->stats_.handle;
	statsp->xmit_cnt	= cl->stats_.xmit_cnt;
	statsp->drop_cnt	= cl->stats_.drop_cnt;
	statsp->over		= cl->stats_.over;
	statsp->borrows		= cl->stats_.borrows;
	statsp->overactions	= cl->stats_.overactions;
	statsp->delays		= cl->stats_.delays;

	statsp->depth		= cl->depth_;
	statsp->priority	= cl->pri_;
	statsp->maxidle		= cl->maxidle_;
	statsp->minidle		= cl->minidle_;
	statsp->offtime		= cl->offtime_;
	statsp->qmax		= qlimit(cl->q_);
	statsp->ns_per_byte	= cl->ns_per_byte_;
	statsp->wrr_allot	= cl->w_allotment_;
	statsp->qcnt		= qlen(cl->q_);
	statsp->avgidle		= cl->avgidle_;

	statsp->qtype		= qtype(cl->q_);
#ifdef ALTQ_RED
	if (q_is_red(cl->q_))
		red_getstats(cl->red_, &statsp->red[0]);
#endif
}

int
cbq_pfattach(struct pf_altq *a)
{
	struct ifnet	*ifp;
	int		 s, error;

	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
		return (EINVAL);
	s = splnet();
	error = altq_attach(&ifp->if_snd, ALTQT_CBQ, a->altq_disc,
	    cbq_enqueue, cbq_dequeue, cbq_request, NULL, NULL);
	splx(s);
	return (error);
}

int
cbq_add_altq(struct pf_altq *a)
{
	cbq_state_t	*cbqp;
	struct ifnet	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (EINVAL);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENODEV);

	/* allocate and initialize cbq_state_t */
	cbqp = malloc(sizeof(cbq_state_t), M_DEVBUF, M_WAITOK|M_ZERO);
	CALLOUT_INIT(&cbqp->cbq_callout);
	cbqp->cbq_qlen = 0;
	cbqp->ifnp.ifq_ = &ifp->if_snd;	    /* keep the ifq */

	/* keep the state in pf_altq */
	a->altq_disc = cbqp;

	return (0);
}

int
cbq_remove_altq(struct pf_altq *a)
{
	cbq_state_t	*cbqp;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;

	cbq_clear_interface(cbqp);

	if (cbqp->ifnp.default_)
		cbq_class_destroy(cbqp, cbqp->ifnp.default_);
	if (cbqp->ifnp.root_)
		cbq_class_destroy(cbqp, cbqp->ifnp.root_);

	/* deallocate cbq_state_t */
	free(cbqp, M_DEVBUF);

	return (0);
}

int
cbq_add_queue(struct pf_altq *a)
{
	struct rm_class	*borrow, *parent;
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	struct cbq_opts	*opts;
	int		i;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);
	if (a->qid == 0)
		return (EINVAL);

	/*
	 * find a free slot in the class table.  if the slot matching
	 * the lower bits of qid is free, use this slot.  otherwise,
	 * use the first free slot.
	 */
	i = a->qid % CBQ_MAX_CLASSES;
	if (cbqp->cbq_class_tbl[i] != NULL) {
		for (i = 0; i < CBQ_MAX_CLASSES; i++)
			if (cbqp->cbq_class_tbl[i] == NULL)
				break;
		if (i == CBQ_MAX_CLASSES)
			return (EINVAL);
	}

	opts = &a->pq_u.cbq_opts;
	/* check parameters */
	if (a->priority >= CBQ_MAXPRI)
		return (EINVAL);

	/* Get pointers to parent and borrow classes.  */
	parent = clh_to_clp(cbqp, a->parent_qid);
	if (opts->flags & CBQCLF_BORROW)
		borrow = parent;
	else
		borrow = NULL;

	/*
	 * A class must borrow from its parent or it can not
	 * borrow at all.  Hence, borrow can be null.
	 */
	if (parent == NULL && (opts->flags & CBQCLF_ROOTCLASS) == 0) {
		printf("cbq_add_queue: no parent class!\n");
		return (EINVAL);
	}

	if ((borrow != parent)  && (borrow != NULL)) {
		printf("cbq_add_class: borrow class != parent\n");
		return (EINVAL);
	}

	/*
	 * check parameters
	 */
	switch (opts->flags & CBQCLF_CLASSMASK) {
	case CBQCLF_ROOTCLASS:
		if (parent != NULL)
			return (EINVAL);
		if (cbqp->ifnp.root_)
			return (EINVAL);
		break;
	case CBQCLF_DEFCLASS:
		if (cbqp->ifnp.default_)
			return (EINVAL);
		break;
	case 0:
		if (a->qid == 0)
			return (EINVAL);
		break;
	default:
		/* more than two flags bits set */
		return (EINVAL);
	}

	/*
	 * create a class.  if this is a root class, initialize the
	 * interface.
	 */
	if ((opts->flags & CBQCLF_CLASSMASK) == CBQCLF_ROOTCLASS) {
		rmc_init(cbqp->ifnp.ifq_, &cbqp->ifnp, opts->ns_per_byte,
		    cbqrestart, a->qlimit, RM_MAXQUEUED,
		    opts->maxidle, opts->minidle, opts->offtime,
		    opts->flags);
		cl = cbqp->ifnp.root_;
	} else {
		cl = rmc_newclass(a->priority,
				  &cbqp->ifnp, opts->ns_per_byte,
				  rmc_delay_action, a->qlimit, parent, borrow,
				  opts->maxidle, opts->minidle, opts->offtime,
				  opts->pktsize, opts->flags);
	}
	if (cl == NULL)
		return (ENOMEM);

	/* return handle to user space. */
	cl->stats_.handle = a->qid;
	cl->stats_.depth = cl->depth_;

	/* save the allocated class */
	cbqp->cbq_class_tbl[i] = cl;

	if ((opts->flags & CBQCLF_CLASSMASK) == CBQCLF_DEFCLASS)
		cbqp->ifnp.default_ = cl;

	return (0);
}

int
cbq_remove_queue(struct pf_altq *a)
{
	struct rm_class	*cl;
	cbq_state_t	*cbqp;
	int		i;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	/* if we are a parent class, then return an error. */
	if (is_a_parent_class(cl))
		return (EINVAL);

	/* delete the class */
	rmc_delete_class(&cbqp->ifnp, cl);

	/*
	 * free the class handle
	 */
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if (cbqp->cbq_class_tbl[i] == cl) {
			cbqp->cbq_class_tbl[i] = NULL;
			if (cl == cbqp->ifnp.root_)
				cbqp->ifnp.root_ = NULL;
			if (cl == cbqp->ifnp.default_)
				cbqp->ifnp.default_ = NULL;
			break;
		}

	return (0);
}

int
cbq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	class_stats_t	 stats;
	int		 error = 0;

	if ((cbqp = altq_lookup(a->ifname, ALTQT_CBQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
	return (0);
}

/*
 * int
 * cbq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pattr)
 *		- Queue data packets.
 *
 *	cbq_enqueue is set to ifp->if_altqenqueue and called by an upper
 *	layer (e.g. ether_output).  cbq_enqueue queues the given packet
 *	to the cbq, then invokes the driver's start routine.
 *
 *	Assumptions:	called in splnet
 *	Returns:	0 if the queueing is successful.
 *			ENOBUFS if a packet dropping occurred as a result of
 *			the queueing.
 */

static int
cbq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
{
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct rm_class	*cl;
	int		 len;

	/* grab class set by classifier */
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	if ((cl = clh_to_clp(cbqp, m->m_pkthdr.pf.qid)) == NULL) {
		cl = cbqp->ifnp.default_;
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		cl->pktattr_ = NULL;
	}

	len = m_pktlen(m);
	if (rmc_queue_packet(cl, m) != 0) {
		/* drop occurred.  some mbuf was freed in rmc_queue_packet. */
		PKTCNTR_ADD(&cl->stats_.drop_cnt, len);
		return (ENOBUFS);
	}

	/* successfully queued. */
	++cbqp->cbq_qlen;
	IFQ_INC_LEN(ifq);
	return (0);
}

static struct mbuf *
cbq_dequeue(struct ifaltq *ifq, int op)
{
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct mbuf	*m;

	m = rmc_dequeue_next(&cbqp->ifnp, op);

	if (m && op == ALTDQ_REMOVE) {
		--cbqp->cbq_qlen;  /* decrement # of packets in cbq */
		IFQ_DEC_LEN(ifq);

		/* Update the class. */
		rmc_update_class_util(&cbqp->ifnp);
	}
	return (m);
}

/*
 * void
 * cbqrestart(queue_t *) - Restart sending of data.
 * called from rmc_restart in splnet via timeout after waking up
 * a suspended class.
 *	Returns:	NONE
 */

static void
cbqrestart(struct ifaltq *ifq)
{
	cbq_state_t	*cbqp;
	struct ifnet	*ifp;

	if (!ALTQ_IS_ENABLED(ifq))
		/* cbq must have been detached */
		return;

	if ((cbqp = (cbq_state_t *)ifq->altq_disc) == NULL)
		/* should not happen */
		return;

	ifp = ifq->altq_ifp;
	if (ifp->if_start && cbqp->cbq_qlen > 0)
		if_start(ifp);
}

static void cbq_purge(cbq_state_t *cbqp)
{
	struct rm_class	*cl;
	int		 i;

	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if ((cl = cbqp->cbq_class_tbl[i]) != NULL)
			rmc_dropall(cl);
	if (ALTQ_IS_ENABLED(cbqp->ifnp.ifq_))
		cbqp->ifnp.ifq_->ifq_len = 0;
}
@


1.26
log
@g/c RIO traces (aka clean up after tedu :))
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.25 2008/05/09 14:10:05 dlg Exp $	*/
@


1.25
log
@switch altq from ifp->if_start to if_start() to take advantage of tx mit.

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.24 2008/05/08 15:22:02 chl Exp $	*/
a182 4
#endif
#ifdef ALTQ_RIO
	if (q_is_rio(cl->q_))
		rio_getstats((rio_t *)cl->red_, &statsp->red[0]);
@


1.24
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.23 2007/09/13 20:40:02 chl Exp $	*/
d514 2
a515 3
	if (ifp->if_start &&
	    cbqp->cbq_qlen > 0 && (ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
@


1.23
log
@MALLOC/FREE -> malloc/free and M_ZERO changes

ok henning@@ krw@@ canacar@@ ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.22 2007/05/28 17:16:38 henning Exp $	*/
a217 2
	if (cbqp == NULL)
		return (ENOMEM);
@


1.22
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.21 2007/04/10 17:47:52 miod Exp $	*/
d217 1
a217 1
	MALLOC(cbqp, cbq_state_t *, sizeof(cbq_state_t), M_DEVBUF, M_WAITOK);
a219 1
	bzero(cbqp, sizeof(cbq_state_t));
d247 1
a247 1
	FREE(cbqp, M_DEVBUF);
@


1.21
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.20 2006/03/04 22:40:15 brad Exp $	*/
a443 1
	struct pf_mtag	*t;
d454 1
a454 3
	t = pf_find_mtag(m);
	if (t == NULL ||
	    (cl = clh_to_clp(cbqp, t->qid)) == NULL) {
@


1.20
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.19 2005/10/17 08:43:35 henning Exp $	*/
d294 1
a294 1
	 * A class must borrow from it's parent or it can not
@


1.19
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.18 2004/01/14 08:42:23 kjc Exp $	*/
d198 1
a198 1
	s = splimp();
d433 1
a433 1
 *	Assumptions:	called in splimp
d500 1
a500 1
 * called from rmc_restart in splimp via timeout after waking up
@


1.18
log
@eliminate the predefined special qids so that qids become simple
identifiers without embedded meanings.

this also allows us to make the semantics of the qid assignment in line
with the tag assignment in the next step.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.17 2003/08/20 12:33:57 henning Exp $	*/
d444 1
a444 1
	struct m_tag	*t;
d455 1
a455 1
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
d457 1
a457 1
	    (cl = clh_to_clp(cbqp, ((struct altq_tag *)(t+1))->qid)) == NULL) {
@


1.17
log
@#define CBQ_MAXPRI RM_MAXPRIO and use it
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.16 2003/04/02 14:51:45 henning Exp $	*/
d72 1
a72 3
	u_int32_t	chandle;

	chandle = cl->stats_.handle;
d80 5
a84 2
	switch (chandle) {
	case ROOT_CLASS_HANDLE:
d86 1
a86 2
		break;
	case DEFAULT_CLASS_HANDLE:
a87 9
		break;
	case NULL_CLASS_HANDLE:
		break;
	default:
		if (chandle >= CBQ_MAX_CLASSES)
			break;
		cbqp->cbq_class_tbl[chandle] = NULL;
	}

d95 2
a96 8
	switch (chandle) {
	case NULL_CLASS_HANDLE:
		return (NULL);
	case ROOT_CLASS_HANDLE:
		return (cbqp->ifnp.root_);
	case DEFAULT_CLASS_HANDLE:
		return (cbqp->ifnp.default_);
	}
d98 1
a98 1
	if (chandle >= CBQ_MAX_CLASSES)
d100 13
a112 2

	return (cbqp->cbq_class_tbl[chandle]);
d131 4
a137 10
		if (cbqp->ifnp.default_ != NULL &&
		    !is_a_parent_class(cbqp->ifnp.default_)) {
			cbq_class_destroy(cbqp, cbqp->ifnp.default_);
			cbqp->ifnp.default_ = NULL;
		}
		if (cbqp->ifnp.root_ != NULL &&
		    !is_a_parent_class(cbqp->ifnp.root_)) {
			cbq_class_destroy(cbqp, cbqp->ifnp.root_);
			cbqp->ifnp.root_ = NULL;
		}
d160 1
d260 1
d264 16
a315 1
		a->qid = ROOT_CLASS_HANDLE;
a319 1
		a->qid = DEFAULT_CLASS_HANDLE;
a323 5
		if (a->qid >= CBQ_MAX_CLASSES &&
		    a->qid != DEFAULT_CLASS_HANDLE)
			return (EINVAL);
		if (cbqp->cbq_class_tbl[a->qid] != NULL)
			return (EBUSY);
d334 1
a334 1
	if (a->qid == ROOT_CLASS_HANDLE) {
d355 3
a357 5
	switch (a->qid) {
	case NULL_CLASS_HANDLE:
	case ROOT_CLASS_HANDLE:
		break;
	case DEFAULT_CLASS_HANDLE:
d359 1
a359 5
		break;
	default:
		cbqp->cbq_class_tbl[a->qid] = cl;
		break;
	}
d368 1
d386 7
a392 11
	switch (a->qid) {
	case ROOT_CLASS_HANDLE:
		cbqp->ifnp.root_ = NULL;
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = NULL;
		break;
	case NULL_CLASS_HANDLE:
		break;
	default:
		if (a->qid >= CBQ_MAX_CLASSES)
d394 1
a394 2
		cbqp->cbq_class_tbl[a->qid] = NULL;
	}
a416 1
	stats.handle = a->qid;
@


1.16
log
@remove what is left over from the control class stuff

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.15 2003/03/31 12:35:45 henning Exp $	*/
d275 1
a275 1
	if (a->priority >= RM_MAXPRIO)
@


1.15
log
@remove queue ID assigning code. it's dead since some time as we assign queue
IDs in userland already.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.14 2003/03/11 02:25:59 kjc Exp $	*/
a88 3
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = NULL;
		break;
a110 2
	case CTL_CLASS_HANDLE:
		return (cbqp->ifnp.ctl_);
a137 5
		if (cbqp->ifnp.ctl_ != NULL &&
		    !is_a_parent_class(cbqp->ifnp.ctl_)) {
			cbq_class_destroy(cbqp, cbqp->ifnp.ctl_);
			cbqp->ifnp.ctl_ = NULL;
		}
a250 2
	if (cbqp->ifnp.ctl_)
		cbq_class_destroy(cbqp, cbqp->ifnp.ctl_);
d319 1
a319 2
		    a->qid != DEFAULT_CLASS_HANDLE &&
		    a->qid != CTL_CLASS_HANDLE)
a395 3
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = NULL;
@


1.14
log
@add protection against packets without pkthdr.
this should not happen but just in case.
printf() is intended to be annoying so that we'll get reports on it.

original idea from dhartmei@@
ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.13 2003/03/02 11:22:31 henning Exp $	*/
a280 2
	u_int32_t	 chandle;
	int		 i;
d312 1
a312 1
	 * allocate class handle
d320 1
a320 1
		chandle = ROOT_CLASS_HANDLE;
d325 1
a325 1
		chandle = DEFAULT_CLASS_HANDLE;
d327 6
a332 2
	case CBQCLF_CTLCLASS:
		if (cbqp->ifnp.ctl_)
d334 2
a335 1
		chandle = CTL_CLASS_HANDLE;
a336 19
	case 0:
		if (a->qid) {
			chandle = a->qid;
			if (chandle >= CBQ_MAX_CLASSES &&
			    chandle != DEFAULT_CLASS_HANDLE &&
			    chandle != CTL_CLASS_HANDLE)
				return (EINVAL);
			if (cbqp->cbq_class_tbl[chandle] != NULL)
				return (EBUSY);
		} else {
			/* find a free class slot. for now, reserve qid 0 */
			for (i = 1; i < CBQ_MAX_CLASSES; i++)
				if (cbqp->cbq_class_tbl[i] == NULL)
					break;
			if (i == CBQ_MAX_CLASSES)
				return (ENOSPC);
			chandle = (u_int32_t)i;
		}
			break;
d346 1
a346 1
	if (chandle == ROOT_CLASS_HANDLE) {
d363 1
a363 3
	a->qid = chandle;

	cl->stats_.handle = chandle;
d367 1
a367 1
	switch (chandle) {
a373 3
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = cl;
		break;
d375 1
a375 1
		cbqp->cbq_class_tbl[chandle] = cl;
@


1.13
log
@only assign a new queue id if a->qid is 0. otherwise, check a->qid for
validity and take that.

validity checks provided by kjc@@

ok dhartmei@@ kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.12 2003/02/05 17:43:12 henning Exp $	*/
d495 7
@


1.12
log
@missed one during ansification
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.11 2003/01/30 09:55:42 henning Exp $	*/
d335 18
a352 8
		/* find a free class slot. for now, reserve qid 0 */
		for (i = 1; i < CBQ_MAX_CLASSES; i++)
			if (cbqp->cbq_class_tbl[i] == NULL)
				break;
		if (i == CBQ_MAX_CLASSES)
			return (ENOSPC);
		chandle = (u_int32_t)i;
		break;
@


1.11
log
@big KNF & ANSI round
"accidently" typed while hunting a bug ;-)

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.10 2003/01/07 00:29:28 cloder Exp $	*/
d178 1
a178 3
get_class_stats(statsp, cl)
	class_stats_t	*statsp;
	struct rm_class	*cl;
@


1.10
log
@Correct several typos in comments. No code changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.9 2002/12/16 17:27:19 henning Exp $	*/
d70 1
a70 3
cbq_class_destroy(cbqp, cl)
	cbq_state_t *cbqp;
	struct rm_class *cl;
d105 1
a105 3
clh_to_clp(cbqp, chandle)
	cbq_state_t *cbqp;
	u_int32_t chandle;
d125 1
a125 2
cbq_clear_interface(cbqp)
	cbq_state_t *cbqp;
d127 1
a127 1
	int		again, i;
d164 1
a164 4
cbq_request(ifq, req, arg)
	struct ifaltq *ifq;
	int req;
	void *arg;
d166 1
a166 1
	cbq_state_t *cbqp = (cbq_state_t *)ifq->altq_disc;
d214 2
a215 2
	struct ifnet *ifp;
	int s, error;
d283 2
a284 2
	u_int32_t	chandle;
	int		i;
a304 1

d442 2
a443 2
	class_stats_t	stats;
	int error = 0;
a454 1
#if 1
a455 1
#endif
d479 6
a484 9
cbq_enqueue(ifq, m, pktattr)
	struct ifaltq *ifq;
	struct mbuf *m;
	struct altq_pktattr *pktattr;
{
	cbq_state_t *cbqp = (cbq_state_t *)ifq->altq_disc;
	struct rm_class *cl;
	struct m_tag *t;
	int len;
d512 1
a512 3
cbq_dequeue(ifq, op)
	struct ifaltq *ifq;
	int op;
d538 1
a538 2
cbqrestart(ifq)
	struct ifaltq *ifq;
d546 1
d557 1
a557 2
static void cbq_purge(cbqp)
	cbq_state_t *cbqp;
@


1.9
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.8 2002/12/16 09:18:05 kjc Exp $	*/
d66 1
a66 1
 *	function destroys a given traffic class.  Before destorying
d485 1
a485 1
 *			ENOBUFS if a packet dropping occured as a result of
@


1.8
log
@switchover to pf-based altq.
 - remove files which are no longer used, or we don't have plans to support
   in pf in the near future.
 - remove altq ioctl related stuff.
 - convert the PRIQ, HFSC and RIO modules to pf-based altq.
   (these are not enabled in GENERIC, CDNR is not converted yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.7 2002/11/26 01:03:34 henning Exp $	*/
d52 1
a52 1
static int	cbq_class_destroy(cbq_state_t *, struct rm_class *);
d54 8
a61 8
static int	cbq_clear_interface(cbq_state_t *);
static int	cbq_request(struct ifaltq *, int, void *);
static int	cbq_enqueue(struct ifaltq *, struct mbuf *,
    struct altq_pktattr *);
static struct mbuf 	*cbq_dequeue(struct ifaltq *, int);
static void	cbqrestart(struct ifaltq *);
static void 	get_class_stats(class_stats_t *, struct rm_class *);
static void	cbq_purge(cbq_state_t *);
d190 2
a191 2
	statsp->xmit_cnt 	= cl->stats_.xmit_cnt;
	statsp->drop_cnt 	= cl->stats_.drop_cnt;
d193 3
a195 3
	statsp->borrows 	= cl->stats_.borrows;
	statsp->overactions 	= cl->stats_.overactions;
	statsp->delays 		= cl->stats_.delays;
d197 1
a197 1
	statsp->depth 		= cl->depth_;
d238 1
a238 1
	struct ifnet 	*ifp;
d250 1
a250 1
 	CALLOUT_INIT(&cbqp->cbq_callout);
d263 1
a263 1
	cbq_state_t 	*cbqp;
d530 2
a531 2
	cbq_state_t 	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct mbuf 	*m;
d577 1
a577 1
	int 		i;
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.6 2002/10/11 09:30:30 kjc Exp $	*/
a36 1
#include <sys/uio.h>
a38 1
#include <sys/proc.h>
a40 1
#include <sys/kernel.h>
a42 1
#include <net/if_types.h>
a46 1
#include <altq/altq_conf.h>
a49 5
 * Local Data structures.
 */
static cbq_state_t *cbq_list = NULL;

/*
a51 6

static int	cbq_add_class(struct cbq_add_class *);
static int	cbq_delete_class(struct cbq_delete_class *);
static int	cbq_modify_class(struct cbq_modify_class *);
static int 	cbq_class_create(cbq_state_t *, struct cbq_add_class *,
				 struct rm_class *, struct rm_class *);
a53 4
static int	cbq_add_filter(struct cbq_add_filter *);
static int	cbq_delete_filter(struct cbq_delete_filter *);

static int	cbq_clear_hierarchy(struct cbq_interface *);
a55 3
static int	cbq_set_enable(struct cbq_interface *, int);
static int	cbq_ifattach(struct cbq_interface *);
static int	cbq_ifdetach(struct cbq_interface *);
d57 1
a57 1
			    struct altq_pktattr *);
a60 1
static int 	cbq_getstats(struct cbq_getstats *);
a62 188
static int
cbq_add_class(acp)
	struct cbq_add_class *acp;
{
	char		*ifacename;
	struct rm_class	*borrow, *parent;
	cbq_state_t	*cbqp;

	ifacename = acp->cbq_iface.cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	/* check parameters */
	if (acp->cbq_class.priority >= RM_MAXPRIO ||
	    acp->cbq_class.maxq > CBQ_MAXQSIZE)
		return (EINVAL);

	/* Get pointers to parent and borrow classes.  */
	parent = clh_to_clp(cbqp, acp->cbq_class.parent_class_handle);
	borrow = clh_to_clp(cbqp, acp->cbq_class.borrow_class_handle);

	/*
	 * A class must borrow from it's parent or it can not
	 * borrow at all.  Hence, borrow can be null.
	 */
	if (parent == NULL && (acp->cbq_class.flags & CBQCLF_ROOTCLASS) == 0) {
		printf("cbq_add_class: no parent class!\n");
		return (EINVAL);
	}

	if ((borrow != parent)  && (borrow != NULL)) {
		printf("cbq_add_class: borrow class != parent\n");
		return (EINVAL);
	}

	return cbq_class_create(cbqp, acp, parent, borrow);
}

static int
cbq_delete_class(dcp)
	struct cbq_delete_class *dcp;
{
	char		*ifacename;
	struct rm_class	*cl;
	cbq_state_t	*cbqp;

	ifacename = dcp->cbq_iface.cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(cbqp, dcp->cbq_class_handle)) == NULL)
		return (EINVAL);

	/* if we are a parent class, then return an error. */
	if (is_a_parent_class(cl))
		return (EINVAL);

	/* if a filter has a reference to this class delete the filter */
	acc_discard_filters(&cbqp->cbq_classifier, cl, 0);

	return cbq_class_destroy(cbqp, cl);
}

static int
cbq_modify_class(acp)
	struct cbq_modify_class *acp;
{
	char		*ifacename;
	struct rm_class	*cl;
	cbq_state_t	*cbqp;

	ifacename = acp->cbq_iface.cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	/* Get pointer to this class */
	if ((cl = clh_to_clp(cbqp, acp->cbq_class_handle)) == NULL)
		return (EINVAL);

	if (rmc_modclass(cl, acp->cbq_class.nano_sec_per_byte,
			 acp->cbq_class.maxq, acp->cbq_class.maxidle,
			 acp->cbq_class.minidle, acp->cbq_class.offtime,
			 acp->cbq_class.pktsize) < 0)
		return (EINVAL);
	return (0);
}

/*
 * struct rm_class *
 * cbq_class_create(cbq_mod_state_t *cbqp, struct cbq_add_class *acp,
 *		u_int32_t handle, struct rm_class *parent,
 *		struct rm_class *borrow)
 *
 * This function create a new traffic class in the CBQ class hierarchy of
 * given paramters.  The class that created is either the root, default,
 * or a new dynamic class.  If CBQ is not initilaized, the the root class
 * will be created.
 */
static int
cbq_class_create(cbqp, acp, parent, borrow)
	cbq_state_t *cbqp;
	struct cbq_add_class *acp;
	struct rm_class *parent, *borrow;
{
	struct rm_class	*cl;
	cbq_class_spec_t *spec = &acp->cbq_class;
	u_int32_t	chandle;
	int		i;

	/*
	 * allocate class handle
	 */
	switch (spec->flags & CBQCLF_CLASSMASK) {
	case CBQCLF_ROOTCLASS:
		if (parent != NULL)
			return (EINVAL);
		if (cbqp->ifnp.root_)
			return (EINVAL);
		chandle = ROOT_CLASS_HANDLE;
		break;
	case CBQCLF_DEFCLASS:
		if (cbqp->ifnp.default_)
			return (EINVAL);
		chandle = DEFAULT_CLASS_HANDLE;
		break;
	case CBQCLF_CTLCLASS:
		if (cbqp->ifnp.ctl_)
			return (EINVAL);
		chandle = CTL_CLASS_HANDLE;
		break;
	case 0:
		/* find a free class slot */
		for (i = 0; i < CBQ_MAX_CLASSES; i++)
			if (cbqp->cbq_class_tbl[i] == NULL)
				break;
		if (i == CBQ_MAX_CLASSES)
			return (ENOSPC);
		chandle = (u_int32_t)i;
		break;
	default:
		/* more than two flags bits set */
		return (EINVAL);
	}

	/*
	 * create a class.  if this is a root class, initialize the
	 * interface.
	 */
	if (chandle == ROOT_CLASS_HANDLE) {
		rmc_init(cbqp->ifnp.ifq_, &cbqp->ifnp, spec->nano_sec_per_byte,
			 cbqrestart, spec->maxq, RM_MAXQUEUED,
			 spec->maxidle, spec->minidle, spec->offtime,
			 spec->flags);
		cl = cbqp->ifnp.root_;
	} else {
		cl = rmc_newclass(spec->priority,
				  &cbqp->ifnp, spec->nano_sec_per_byte,
				  rmc_delay_action, spec->maxq, parent, borrow,
				  spec->maxidle, spec->minidle, spec->offtime,
				  spec->pktsize, spec->flags);
	}
	if (cl == NULL)
		return (ENOMEM);

	/* return handle to user space. */
	acp->cbq_class_handle = chandle;

	cl->stats_.handle = chandle;
	cl->stats_.depth = cl->depth_;

	/* save the allocated class */
	switch (chandle) {
	case NULL_CLASS_HANDLE:
	case ROOT_CLASS_HANDLE:
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = cl;
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = cl;
		break;
	default:
		cbqp->cbq_class_tbl[chandle] = cl;
		break;
	}
	return (0);
}

a128 53
cbq_add_filter(afp)
	struct cbq_add_filter *afp;
{
	char		*ifacename;
	cbq_state_t	*cbqp;
	struct rm_class	*cl;

	ifacename = afp->cbq_iface.cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	/* Get the pointer to class. */
	if ((cl = clh_to_clp(cbqp, afp->cbq_class_handle)) == NULL)
		return (EINVAL);

	return acc_add_filter(&cbqp->cbq_classifier, &afp->cbq_filter,
			      cl, &afp->cbq_filter_handle);
}

static int
cbq_delete_filter(dfp)
	struct cbq_delete_filter *dfp;
{
	char		*ifacename;
	cbq_state_t	*cbqp;

	ifacename = dfp->cbq_iface.cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	return acc_delete_filter(&cbqp->cbq_classifier,
				 dfp->cbq_filter_handle);
}

/*
 * cbq_clear_hierarchy deletes all classes and their filters on the
 * given interface.
 */
static int
cbq_clear_hierarchy(ifacep)
	struct cbq_interface *ifacep;
{
	char		*ifacename;
	cbq_state_t	*cbqp;

	ifacename = ifacep->cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	return cbq_clear_interface(cbqp);
}

static int
a134 3
	/* free the filters for this interface */
	acc_discard_filters(&cbqp->cbq_classifier, NULL, 1);

a183 47
/*
 * static int
 * cbq_set_enable(struct cbq_enable *ep) - this function processed the
 *	ioctl request to enable class based queueing.  It searches the list
 *	of interfaces for the specified interface and then enables CBQ on
 *	that interface.
 *
 *	Returns:	0, for no error.
 *			EBADF, for specified inteface not found.
 */

static int
cbq_set_enable(ep, enable)
	struct cbq_interface *ep;
	int enable;
{
	int 	error = 0;
	cbq_state_t	*cbqp;
	char 	*ifacename;

	ifacename = ep->cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	switch (enable) {
	case ENABLE:
		if (cbqp->ifnp.root_ == NULL || cbqp->ifnp.default_ == NULL ||
		    cbqp->ifnp.ctl_ == NULL) {
			if (cbqp->ifnp.root_ == NULL)
				printf("No Root Class for %s\n", ifacename);
			if (cbqp->ifnp.default_ == NULL)
				printf("No Default Class for %s\n", ifacename);
			if (cbqp->ifnp.ctl_ == NULL)
				printf("No Control Class for %s\n", ifacename);
			error = EINVAL;
		} else if ((error = altq_enable(cbqp->ifnp.ifq_)) == 0) {
			cbqp->cbq_qlen = 0;
		}
		break;

	case DISABLE:
		error = altq_disable(cbqp->ifnp.ifq_);
		break;
	}
	return (error);
}

a218 60
static int
cbq_getstats(gsp)
	struct cbq_getstats *gsp;
{
	char		*ifacename;
	int		chandle, n, nclasses;
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	class_stats_t	stats, *usp;
	int error = 0;

	ifacename = gsp->iface.cbq_ifacename;
	nclasses = gsp->nclasses;
	usp = gsp->stats;

	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);
	if (nclasses <= 0)
		return (EINVAL);

	for (n = 0, chandle = 0; n < nclasses && chandle < CBQ_MAX_CLASSES;
	     n++) {
		switch(n) {
		case 0:
			cl = cbqp->ifnp.root_;
			stats.handle = ROOT_CLASS_HANDLE;
			break;
		case 1:
			cl = cbqp->ifnp.default_;
			stats.handle = DEFAULT_CLASS_HANDLE;
			break;
		case 2:
			cl = cbqp->ifnp.ctl_;
			stats.handle = CTL_CLASS_HANDLE;
#if 1 /* PFALTQ */
			if (cl != NULL)
#endif
			break;
		default:
			while ((cl = cbqp->cbq_class_tbl[chandle]) == NULL)
				if (++chandle >= CBQ_MAX_CLASSES)
					goto out;
			stats.handle = chandle++;
			break;
		}

		get_class_stats(&stats, cl);

		if ((error = copyout((caddr_t)&stats, (caddr_t)usp++,
				     sizeof(stats))) != 0)
			return (error);
	}

 out:
	gsp->nclasses = n;
	return (error);
}

#if 1 /* PFALTQ */

d241 1
a241 1
		return (ENXIO);
d243 1
a243 1
		return (ENXIO);
a250 7
	MALLOC(cbqp->cbq_class_tbl, struct rm_class **,
	       sizeof(struct rm_class *) * CBQ_MAX_CLASSES, M_DEVBUF, M_WAITOK);
	if (cbqp->cbq_class_tbl == NULL) {
		FREE(cbqp, M_DEVBUF);
		return (ENOMEM);
	}
	bzero(cbqp->cbq_class_tbl, sizeof(struct rm_class *) * CBQ_MAX_CLASSES);
a256 4
	/* prepend to the list of cbq_state_t's. */
	cbqp->cbq_next = cbq_list;
	cbq_list = cbqp;

a277 14
	/* remove from the list of cbq_state_t's. */
	if (cbq_list == cbqp)
		cbq_list = cbqp->cbq_next;
	else {
		cbq_state_t *cp;

		for (cp = cbq_list; cp != NULL; cp = cp->cbq_next)
			if (cp->cbq_next == cbqp) {
				cp->cbq_next = cbqp->cbq_next;
				break;
			}
		ASSERT(cp != NULL);
	}

a278 1
	FREE(cbqp->cbq_class_tbl, M_DEVBUF);
d346 1
a346 3
		/* find a free class slot */
#if 1 /* PFALTQ */
		/* for now, reserve qid 0 */
a347 3
#else
		for (i = 0; i < CBQ_MAX_CLASSES; i++)
#endif
a473 98
#endif /* PFALTQ */

static int
cbq_ifattach(ifacep)
	struct cbq_interface *ifacep;
{
	int		error = 0;
	char		*ifacename;
	cbq_state_t	*new_cbqp;
	struct ifnet 	*ifp;

	ifacename = ifacep->cbq_ifacename;
	if ((ifp = ifunit(ifacename)) == NULL)
		return (ENXIO);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENXIO);

	/* allocate and initialize cbq_state_t */
	MALLOC(new_cbqp, cbq_state_t *, sizeof(cbq_state_t), M_DEVBUF, M_WAITOK);
	if (new_cbqp == NULL)
		return (ENOMEM);
	bzero(new_cbqp, sizeof(cbq_state_t));
 	CALLOUT_INIT(&new_cbqp->cbq_callout);
	MALLOC(new_cbqp->cbq_class_tbl, struct rm_class **,
	       sizeof(struct rm_class *) * CBQ_MAX_CLASSES, M_DEVBUF, M_WAITOK);
	if (new_cbqp->cbq_class_tbl == NULL) {
		FREE(new_cbqp, M_DEVBUF);
		return (ENOMEM);
	}
	bzero(new_cbqp->cbq_class_tbl, sizeof(struct rm_class *) * CBQ_MAX_CLASSES);
	new_cbqp->cbq_qlen = 0;
	new_cbqp->ifnp.ifq_ = &ifp->if_snd;	    /* keep the ifq */

	/*
	 * set CBQ to this ifnet structure.
	 */
	error = altq_attach(&ifp->if_snd, ALTQT_CBQ, new_cbqp,
			    cbq_enqueue, cbq_dequeue, cbq_request,
			    &new_cbqp->cbq_classifier, acc_classify);
	if (error) {
		FREE(new_cbqp->cbq_class_tbl, M_DEVBUF);
		FREE(new_cbqp, M_DEVBUF);
		return (error);
	}

	/* prepend to the list of cbq_state_t's. */
	new_cbqp->cbq_next = cbq_list;
	cbq_list = new_cbqp;

	return (0);
}

static int
cbq_ifdetach(ifacep)
	struct cbq_interface *ifacep;
{
	char		*ifacename;
	cbq_state_t 	*cbqp;

	ifacename = ifacep->cbq_ifacename;
	if ((cbqp = altq_lookup(ifacename, ALTQT_CBQ)) == NULL)
		return (EBADF);

	(void)cbq_set_enable(ifacep, DISABLE);

	cbq_clear_interface(cbqp);

	if (cbqp->ifnp.ctl_)
		cbq_class_destroy(cbqp, cbqp->ifnp.ctl_);
	if (cbqp->ifnp.default_)
		cbq_class_destroy(cbqp, cbqp->ifnp.default_);
	if (cbqp->ifnp.root_)
		cbq_class_destroy(cbqp, cbqp->ifnp.root_);

	/* remove CBQ from the ifnet structure. */
	(void)altq_detach(cbqp->ifnp.ifq_);

	/* remove from the list of cbq_state_t's. */
	if (cbq_list == cbqp)
		cbq_list = cbqp->cbq_next;
	else {
		cbq_state_t *cp;

		for (cp = cbq_list; cp != NULL; cp = cp->cbq_next)
			if (cp->cbq_next == cbqp) {
				cp->cbq_next = cbqp->cbq_next;
				break;
			}
		ASSERT(cp != NULL);
	}

	/* deallocate cbq_state_t */
	FREE(cbqp->cbq_class_tbl, M_DEVBUF);
	FREE(cbqp, M_DEVBUF);

	return (0);
}

d497 1
d501 7
a507 12
	if (PFALTQ_IS_ACTIVE()) {
		struct m_tag *t;

		t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
		if (t == NULL ||
		    (cl = clh_to_clp(cbqp, ((struct altq_tag *)(t+1))->qid))
		    == NULL) {
			cl = cbqp->ifnp.default_;
			if (cl == NULL) {
				m_freem(m);
				return (ENOBUFS);
			}
a509 4
	} else {
		if (pktattr == NULL || (cl = pktattr->pattr_class) == NULL)
			cl = cbqp->ifnp.default_;
		cl->pktattr_ = pktattr;  /* save proto hdr used by ECN */
a584 174

/*
 * cbq device interface
 */

altqdev_decl(cbq);

int
cbqopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	if (PFALTQ_IS_ACTIVE())
		return (EBUSY);
	return (0);
}

int
cbqclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct ifnet *ifp;
	struct cbq_interface iface;
	int err, error = 0;

	while (cbq_list) {
		ifp = cbq_list->ifnp.ifq_->altq_ifp;
#if defined(__NetBSD__) || defined(__OpenBSD__)
		sprintf(iface.cbq_ifacename, "%s", ifp->if_xname);
#else
		sprintf(iface.cbq_ifacename,
			"%s%d", ifp->if_name, ifp->if_unit);
#endif
		err = cbq_ifdetach(&iface);
		if (err != 0 && error == 0)
			error = err;
	}

	return (error);
}

int
cbqioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	ioctlcmd_t cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	int	error = 0;

	/* check cmd for superuser only */
	switch (cmd) {
	case CBQ_GETSTATS:
		/* currently only command that an ordinary user can call */
		break;
	default:
#if (__FreeBSD_version > 400000)
		error = suser(p);
#else
		error = suser(p->p_ucred, &p->p_acflag);
#endif
		if (error)
			return (error);
		break;
	}

	switch (cmd) {

	case CBQ_ENABLE:
		error = cbq_set_enable((struct cbq_interface *)addr, ENABLE);
		break;

	case CBQ_DISABLE:
		error = cbq_set_enable((struct cbq_interface *)addr, DISABLE);
		break;

	case CBQ_ADD_FILTER:
		error = cbq_add_filter((struct cbq_add_filter *)addr);
		break;

	case CBQ_DEL_FILTER:
		error = cbq_delete_filter((struct cbq_delete_filter *)addr);
		break;

	case CBQ_ADD_CLASS:
		error = cbq_add_class((struct cbq_add_class *)addr);
		break;

	case CBQ_DEL_CLASS:
		error = cbq_delete_class((struct cbq_delete_class *)addr);
		break;

	case CBQ_MODIFY_CLASS:
		error = cbq_modify_class((struct cbq_modify_class *)addr);
		break;

	case CBQ_CLEAR_HIERARCHY:
		error = cbq_clear_hierarchy((struct cbq_interface *)addr);
		break;

	case CBQ_IF_ATTACH:
		error = cbq_ifattach((struct cbq_interface *)addr);
		break;

	case CBQ_IF_DETACH:
		error = cbq_ifdetach((struct cbq_interface *)addr);
		break;

	case CBQ_GETSTATS:
		error = cbq_getstats((struct cbq_getstats *)addr);
		break;

	default:
		error = EINVAL;
		break;
	}

	return error;
}

#if 0
/* for debug */
static void cbq_class_dump(int);

static void cbq_class_dump(i)
	int i;
{
	struct rm_class *cl;
	rm_class_stats_t *s;
	struct _class_queue_ *q;

	if (cbq_list == NULL) {
		printf("cbq_class_dump: no cbq_state found\n");
		return;
	}
	cl = cbq_list->cbq_class_tbl[i];

	printf("class %d cl=%p\n", i, cl);
	if (cl != NULL) {
		s = &cl->stats_;
		q = cl->q_;

		printf("pri=%d, depth=%d, maxrate=%d, allotment=%d\n",
		       cl->pri_, cl->depth_, cl->maxrate_, cl->allotment_);
		printf("w_allotment=%d, bytes_alloc=%d, avgidle=%d, maxidle=%d\n",
		       cl->w_allotment_, cl->bytes_alloc_, cl->avgidle_,
		       cl->maxidle_);
		printf("minidle=%d, offtime=%d, sleeping=%d, leaf=%d\n",
		       cl->minidle_, cl->offtime_, cl->sleeping_, cl->leaf_);
		printf("handle=%d, depth=%d, packets=%d, bytes=%d\n",
		       s->handle, s->depth,
		       (int)s->xmit_cnt.packets, (int)s->xmit_cnt.bytes);
		printf("over=%d\n, borrows=%d, drops=%d, overactions=%d, delays=%d\n",
		       s->over, s->borrows, (int)s->drop_cnt.packets,
		       s->overactions, s->delays);
		printf("tail=%p, head=%p, qlen=%d, qlim=%d, qthresh=%d,qtype=%d\n",
		       q->tail_, q->head_, q->qlen_, q->qlim_,
		       q->qthresh_, q->qtype_);
	}
}
#endif /* 0 */

#ifdef KLD_MODULE

static struct altqsw cbq_sw =
	{"cbq", cbqopen, cbqclose, cbqioctl};

ALTQ_MODULE(altq_cbq, ALTQT_CBQ, &cbq_sw);

#endif /* KLD_MODULE */
@


1.6
log
@make CBQ aware of the pf API so that pf developers can play with CBQ.

for now, implemnet a tentative transition mechanism to allow the old API
and the new API to coexit.
the old API will go away when pfctl(8) becomes ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.5 2002/10/05 02:57:58 kjc Exp $	*/
d30 1
a30 1
 *  
d366 1
a366 1
    
d370 1
a370 1
    
d912 1
a912 1
       
d1008 1
a1008 1
		if (t == NULL || 
d1237 1
a1237 1
    
@


1.5
log
@fix a embarrassing list-handling bug in cbq.
this bug is triggered only when 3 or more cbq instances are
created at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.4 2002/03/14 03:15:50 millert Exp $	*/
d49 1
d69 1
a69 1
static struct rm_class  *clh_to_clp(cbq_state_t *, u_long);
d177 1
a177 1
 *		u_long handle, struct rm_class *parent,
d193 1
a193 1
	u_long		chandle;
d224 1
a224 1
		chandle = (u_long)i;
d286 1
a286 1
	u_long	chandle;
d321 1
a321 1
	u_long chandle;
d568 3
d592 290
d1004 19
a1022 3
	if (pktattr == NULL || (cl = pktattr->pattr_class) == NULL)
		cl = cbqp->ifnp.default_;
	cl->pktattr_ = pktattr;  /* save proto hdr used by ECN */
d1110 2
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.3 2002/03/14 01:26:26 millert Exp $	*/
d669 1
a669 1
		for (cp = cbq_list; cp != NULL; cp = cbqp->cbq_next)
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.2 2001/08/09 14:32:59 deraadt Exp $	*/
d66 1
a66 1
				      struct rm_class *, struct rm_class *);
d79 1
a79 1
				 struct altq_pktattr *);
@


1.2
log
@change a maze of altq options into just "altq" for the base+red+cbq, and
then altq_* for each of the other * experimental options.  and.. enable
it by default in GENERIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.1 2001/06/27 05:28:34 kjc Exp $	*/
d62 22
a83 22
static int	cbq_add_class __P((struct cbq_add_class *));
static int	cbq_delete_class __P((struct cbq_delete_class *));
static int	cbq_modify_class __P((struct cbq_modify_class *));
static int 	cbq_class_create __P((cbq_state_t *, struct cbq_add_class *,
				      struct rm_class *, struct rm_class *));
static int	cbq_class_destroy __P((cbq_state_t *, struct rm_class *));
static struct rm_class  *clh_to_clp __P((cbq_state_t *, u_long));
static int	cbq_add_filter __P((struct cbq_add_filter *));
static int	cbq_delete_filter __P((struct cbq_delete_filter *));

static int	cbq_clear_hierarchy __P((struct cbq_interface *));
static int	cbq_clear_interface __P((cbq_state_t *));
static int	cbq_request __P((struct ifaltq *, int, void *));
static int	cbq_set_enable __P((struct cbq_interface *, int));
static int	cbq_ifattach __P((struct cbq_interface *));
static int	cbq_ifdetach __P((struct cbq_interface *));
static int	cbq_enqueue __P((struct ifaltq *, struct mbuf *,
				 struct altq_pktattr *));
static struct mbuf 	*cbq_dequeue __P((struct ifaltq *, int));
static void	cbqrestart __P((struct ifaltq *));
static void 	get_class_stats __P((class_stats_t *, struct rm_class *));
static int 	cbq_getstats __P((struct cbq_getstats *));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.2 2001/08/09 14:32:59 deraadt Exp $	*/
d62 22
a83 22
static int	cbq_add_class(struct cbq_add_class *);
static int	cbq_delete_class(struct cbq_delete_class *);
static int	cbq_modify_class(struct cbq_modify_class *);
static int 	cbq_class_create(cbq_state_t *, struct cbq_add_class *,
				 struct rm_class *, struct rm_class *);
static int	cbq_class_destroy(cbq_state_t *, struct rm_class *);
static struct rm_class  *clh_to_clp(cbq_state_t *, u_long);
static int	cbq_add_filter(struct cbq_add_filter *);
static int	cbq_delete_filter(struct cbq_delete_filter *);

static int	cbq_clear_hierarchy(struct cbq_interface *);
static int	cbq_clear_interface(cbq_state_t *);
static int	cbq_request(struct ifaltq *, int, void *);
static int	cbq_set_enable(struct cbq_interface *, int);
static int	cbq_ifattach(struct cbq_interface *);
static int	cbq_ifdetach(struct cbq_interface *);
static int	cbq_enqueue(struct ifaltq *, struct mbuf *,
			    struct altq_pktattr *);
static struct mbuf 	*cbq_dequeue(struct ifaltq *, int);
static void	cbqrestart(struct ifaltq *);
static void 	get_class_stats(class_stats_t *, struct rm_class *);
static int 	cbq_getstats(struct cbq_getstats *);
@


1.2.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.2.4.1 2002/06/11 03:27:42 art Exp $	*/
a48 1
#include <net/pfvar.h>
d68 1
a68 1
static struct rm_class  *clh_to_clp(cbq_state_t *, u_int32_t);
d176 1
a176 1
 *		u_int32_t handle, struct rm_class *parent,
d192 1
a192 1
	u_int32_t	chandle;
d223 1
a223 1
		chandle = (u_int32_t)i;
d285 1
a285 1
	u_int32_t	chandle;
d320 1
a320 1
	u_int32_t chandle;
a566 3
#if 1 /* PFALTQ */
			if (cl != NULL)
#endif
a587 290
#if 1 /* PFALTQ */

int
cbq_pfattach(struct pf_altq *a)
{
	struct ifnet *ifp;
	int s, error;

	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
		return (EINVAL);
	s = splimp();
	error = altq_attach(&ifp->if_snd, ALTQT_CBQ, a->altq_disc,
	    cbq_enqueue, cbq_dequeue, cbq_request, NULL, NULL);
	splx(s);
	return (error);
}

int
cbq_add_altq(struct pf_altq *a)
{
	cbq_state_t	*cbqp;
	struct ifnet 	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (ENXIO);
	if (!ALTQ_IS_READY(&ifp->if_snd))
		return (ENXIO);

	/* allocate and initialize cbq_state_t */
	MALLOC(cbqp, cbq_state_t *, sizeof(cbq_state_t), M_DEVBUF, M_WAITOK);
	if (cbqp == NULL)
		return (ENOMEM);
	bzero(cbqp, sizeof(cbq_state_t));
 	CALLOUT_INIT(&cbqp->cbq_callout);
	MALLOC(cbqp->cbq_class_tbl, struct rm_class **,
	       sizeof(struct rm_class *) * CBQ_MAX_CLASSES, M_DEVBUF, M_WAITOK);
	if (cbqp->cbq_class_tbl == NULL) {
		FREE(cbqp, M_DEVBUF);
		return (ENOMEM);
	}
	bzero(cbqp->cbq_class_tbl, sizeof(struct rm_class *) * CBQ_MAX_CLASSES);
	cbqp->cbq_qlen = 0;
	cbqp->ifnp.ifq_ = &ifp->if_snd;	    /* keep the ifq */

	/* keep the state in pf_altq */
	a->altq_disc = cbqp;

	/* prepend to the list of cbq_state_t's. */
	cbqp->cbq_next = cbq_list;
	cbq_list = cbqp;

	return (0);
}

int
cbq_remove_altq(struct pf_altq *a)
{
	cbq_state_t 	*cbqp;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;

	cbq_clear_interface(cbqp);

	if (cbqp->ifnp.ctl_)
		cbq_class_destroy(cbqp, cbqp->ifnp.ctl_);
	if (cbqp->ifnp.default_)
		cbq_class_destroy(cbqp, cbqp->ifnp.default_);
	if (cbqp->ifnp.root_)
		cbq_class_destroy(cbqp, cbqp->ifnp.root_);

	/* remove from the list of cbq_state_t's. */
	if (cbq_list == cbqp)
		cbq_list = cbqp->cbq_next;
	else {
		cbq_state_t *cp;

		for (cp = cbq_list; cp != NULL; cp = cp->cbq_next)
			if (cp->cbq_next == cbqp) {
				cp->cbq_next = cbqp->cbq_next;
				break;
			}
		ASSERT(cp != NULL);
	}

	/* deallocate cbq_state_t */
	FREE(cbqp->cbq_class_tbl, M_DEVBUF);
	FREE(cbqp, M_DEVBUF);

	return (0);
}

int
cbq_add_queue(struct pf_altq *a)
{
	struct rm_class	*borrow, *parent;
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	struct cbq_opts	*opts;
	u_int32_t	chandle;
	int		i;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);

	opts = &a->pq_u.cbq_opts;
	/* check parameters */
	if (a->priority >= RM_MAXPRIO)
		return (EINVAL);

	/* Get pointers to parent and borrow classes.  */
	parent = clh_to_clp(cbqp, a->parent_qid);
	if (opts->flags & CBQCLF_BORROW)
		borrow = parent;
	else
		borrow = NULL;

	/*
	 * A class must borrow from it's parent or it can not
	 * borrow at all.  Hence, borrow can be null.
	 */

	if (parent == NULL && (opts->flags & CBQCLF_ROOTCLASS) == 0) {
		printf("cbq_add_queue: no parent class!\n");
		return (EINVAL);
	}

	if ((borrow != parent)  && (borrow != NULL)) {
		printf("cbq_add_class: borrow class != parent\n");
		return (EINVAL);
	}

	/*
	 * allocate class handle
	 */
	switch (opts->flags & CBQCLF_CLASSMASK) {
	case CBQCLF_ROOTCLASS:
		if (parent != NULL)
			return (EINVAL);
		if (cbqp->ifnp.root_)
			return (EINVAL);
		chandle = ROOT_CLASS_HANDLE;
		break;
	case CBQCLF_DEFCLASS:
		if (cbqp->ifnp.default_)
			return (EINVAL);
		chandle = DEFAULT_CLASS_HANDLE;
		break;
	case CBQCLF_CTLCLASS:
		if (cbqp->ifnp.ctl_)
			return (EINVAL);
		chandle = CTL_CLASS_HANDLE;
		break;
	case 0:
		/* find a free class slot */
#if 1 /* PFALTQ */
		/* for now, reserve qid 0 */
		for (i = 1; i < CBQ_MAX_CLASSES; i++)
#else
		for (i = 0; i < CBQ_MAX_CLASSES; i++)
#endif
			if (cbqp->cbq_class_tbl[i] == NULL)
				break;
		if (i == CBQ_MAX_CLASSES)
			return (ENOSPC);
		chandle = (u_int32_t)i;
		break;
	default:
		/* more than two flags bits set */
		return (EINVAL);
	}

	/*
	 * create a class.  if this is a root class, initialize the
	 * interface.
	 */
	if (chandle == ROOT_CLASS_HANDLE) {
		rmc_init(cbqp->ifnp.ifq_, &cbqp->ifnp, opts->ns_per_byte,
		    cbqrestart, a->qlimit, RM_MAXQUEUED,
		    opts->maxidle, opts->minidle, opts->offtime,
		    opts->flags);
		cl = cbqp->ifnp.root_;
	} else {
		cl = rmc_newclass(a->priority,
				  &cbqp->ifnp, opts->ns_per_byte,
				  rmc_delay_action, a->qlimit, parent, borrow,
				  opts->maxidle, opts->minidle, opts->offtime,
				  opts->pktsize, opts->flags);
	}
	if (cl == NULL)
		return (ENOMEM);

	/* return handle to user space. */
	a->qid = chandle;

	cl->stats_.handle = chandle;
	cl->stats_.depth = cl->depth_;

	/* save the allocated class */
	switch (chandle) {
	case NULL_CLASS_HANDLE:
	case ROOT_CLASS_HANDLE:
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = cl;
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = cl;
		break;
	default:
		cbqp->cbq_class_tbl[chandle] = cl;
		break;
	}
	return (0);
}

int
cbq_remove_queue(struct pf_altq *a)
{
	struct rm_class	*cl;
	cbq_state_t	*cbqp;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	/* if we are a parent class, then return an error. */
	if (is_a_parent_class(cl))
		return (EINVAL);

	/* delete the class */
	rmc_delete_class(&cbqp->ifnp, cl);

	/*
	 * free the class handle
	 */
	switch (a->qid) {
	case ROOT_CLASS_HANDLE:
		cbqp->ifnp.root_ = NULL;
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = NULL;
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = NULL;
		break;
	case NULL_CLASS_HANDLE:
		break;
	default:
		if (a->qid >= CBQ_MAX_CLASSES)
			break;
		cbqp->cbq_class_tbl[a->qid] = NULL;
	}

	return (0);
}

int
cbq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	class_stats_t	stats;
	int error = 0;

	if ((cbqp = altq_lookup(a->ifname, ALTQT_CBQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);
#if 1
	stats.handle = a->qid;
#endif

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
	return (0);
}

#endif /* PFALTQ */

d669 1
a669 1
		for (cp = cbq_list; cp != NULL; cp = cp->cbq_next)
d710 3
a712 19
	if (PFALTQ_IS_ACTIVE()) {
		struct m_tag *t;

		t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
		if (t == NULL || 
		    (cl = clh_to_clp(cbqp, ((struct altq_tag *)(t+1))->qid))
		    == NULL) {
			cl = cbqp->ifnp.default_;
			if (cl == NULL) {
				m_freem(m);
				return (ENOBUFS);
			}
		}
		cl->pktattr_ = NULL;
	} else {
		if (pktattr == NULL || (cl = pktattr->pattr_class) == NULL)
			cl = cbqp->ifnp.default_;
		cl->pktattr_ = pktattr;  /* save proto hdr used by ECN */
	}
a799 2
	if (PFALTQ_IS_ACTIVE())
		return (EBUSY);
@


1.2.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
 *
d37 1
d40 1
d43 1
d46 1
d51 1
d55 5
d62 7
a68 1
static int		 cbq_class_destroy(cbq_state_t *, struct rm_class *);
d70 204
a273 8
static int		 cbq_clear_interface(cbq_state_t *);
static int		 cbq_request(struct ifaltq *, int, void *);
static int		 cbq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf	*cbq_dequeue(struct ifaltq *, int);
static void		 cbqrestart(struct ifaltq *);
static void		 get_class_stats(class_stats_t *, struct rm_class *);
static void		 cbq_purge(cbq_state_t *);
d278 1
a278 1
 *	function destroys a given traffic class.  Before destroying
d282 3
a284 1
cbq_class_destroy(cbq_state_t *cbqp, struct rm_class *cl)
d303 3
d319 3
a321 1
clh_to_clp(cbq_state_t *cbqp, u_int32_t chandle)
d330 2
d341 22
a362 1
cbq_clear_interface(cbq_state_t *cbqp)
d364 34
a397 1
	int		 again, i;
d400 3
d416 5
d437 4
a440 1
cbq_request(struct ifaltq *ifq, int req, void *arg)
d442 1
a442 1
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
d452 47
d501 3
a503 1
get_class_stats(class_stats_t *statsp, struct rm_class *cl)
d505 2
a506 2
	statsp->xmit_cnt	= cl->stats_.xmit_cnt;
	statsp->drop_cnt	= cl->stats_.drop_cnt;
d508 3
a510 3
	statsp->borrows		= cl->stats_.borrows;
	statsp->overactions	= cl->stats_.overactions;
	statsp->delays		= cl->stats_.delays;
d512 1
a512 1
	statsp->depth		= cl->depth_;
d534 60
d597 2
a598 2
	struct ifnet	*ifp;
	int		 s, error;
d613 1
a613 1
	struct ifnet	*ifp;
d616 1
a616 1
		return (EINVAL);
d618 1
a618 1
		return (ENODEV);
d625 8
a632 1
	CALLOUT_INIT(&cbqp->cbq_callout);
d639 4
d649 1
a649 1
	cbq_state_t	*cbqp;
d657 2
d664 14
d679 1
d692 2
d714 1
d726 1
a726 1
	 * check parameters
d734 1
a734 1
		a->qid = ROOT_CLASS_HANDLE;
d739 6
a744 1
		a->qid = DEFAULT_CLASS_HANDLE;
d747 12
a758 7
		if (a->qid == 0)
			return (EINVAL);
		if (a->qid >= CBQ_MAX_CLASSES &&
		    a->qid != DEFAULT_CLASS_HANDLE)
			return (EINVAL);
		if (cbqp->cbq_class_tbl[a->qid] != NULL)
			return (EBUSY);
d769 1
a769 1
	if (a->qid == ROOT_CLASS_HANDLE) {
d786 3
a788 1
	cl->stats_.handle = a->qid;
d792 1
a792 1
	switch (a->qid) {
d799 3
d803 1
a803 1
		cbqp->cbq_class_tbl[a->qid] = cl;
d838 3
d857 2
a858 2
	class_stats_t	 stats;
	int		 error = 0;
d870 1
d872 1
d880 98
d989 1
a989 1
 *			ENOBUFS if a packet dropping occurred as a result of
d994 4
a997 1
cbq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
d999 3
a1001 4
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct rm_class	*cl;
	struct m_tag	*t;
	int		 len;
d1004 12
a1015 14
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
	if (t == NULL ||
	    (cl = clh_to_clp(cbqp, ((struct altq_tag *)(t+1))->qid)) == NULL) {
		cl = cbqp->ifnp.default_;
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
d1018 4
d1038 3
a1040 1
cbq_dequeue(struct ifaltq *ifq, int op)
d1042 2
a1043 2
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct mbuf	*m;
d1066 2
a1067 1
cbqrestart(struct ifaltq *ifq)
a1074 1

d1085 2
a1086 1
static void cbq_purge(cbq_state_t *cbqp)
d1089 1
a1089 1
	int		 i;
d1097 174
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a33 13
#if defined(__FreeBSD__) || defined(__NetBSD__)
#include "opt_altq.h"
#if (__FreeBSD__ != 2)
#include "opt_inet.h"
#ifdef __FreeBSD__
#include "opt_inet6.h"
#endif
#endif
#endif /* __FreeBSD__ || __NetBSD__ */
#ifdef ALTQ_CBQ	/* cbq is enabled by ALTQ_CBQ option in opt_altq.h */

/* #pragma ident "@@(#)cbq.c  1.39     98/05/13 SMI" */

a958 2

#endif /* ALTQ_CBQ */
@


1.1.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.1 2001/06/27 05:28:34 kjc Exp $	*/
d34 13
d972 2
@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 22
a83 22
static int	cbq_add_class(struct cbq_add_class *);
static int	cbq_delete_class(struct cbq_delete_class *);
static int	cbq_modify_class(struct cbq_modify_class *);
static int 	cbq_class_create(cbq_state_t *, struct cbq_add_class *,
				 struct rm_class *, struct rm_class *);
static int	cbq_class_destroy(cbq_state_t *, struct rm_class *);
static struct rm_class  *clh_to_clp(cbq_state_t *, u_long);
static int	cbq_add_filter(struct cbq_add_filter *);
static int	cbq_delete_filter(struct cbq_delete_filter *);

static int	cbq_clear_hierarchy(struct cbq_interface *);
static int	cbq_clear_interface(cbq_state_t *);
static int	cbq_request(struct ifaltq *, int, void *);
static int	cbq_set_enable(struct cbq_interface *, int);
static int	cbq_ifattach(struct cbq_interface *);
static int	cbq_ifdetach(struct cbq_interface *);
static int	cbq_enqueue(struct ifaltq *, struct mbuf *,
			    struct altq_pktattr *);
static struct mbuf 	*cbq_dequeue(struct ifaltq *, int);
static void	cbqrestart(struct ifaltq *);
static void 	get_class_stats(class_stats_t *, struct rm_class *);
static int 	cbq_getstats(struct cbq_getstats *);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d30 1
a30 1
 *
d37 1
d40 1
d43 1
d46 1
a48 1
#include <net/pfvar.h>
d50 1
d54 5
d61 212
a272 10
static int		 cbq_class_destroy(cbq_state_t *, struct rm_class *);
static struct rm_class  *clh_to_clp(cbq_state_t *, u_int32_t);
static int		 cbq_clear_interface(cbq_state_t *);
static int		 cbq_request(struct ifaltq *, int, void *);
static int		 cbq_enqueue(struct ifaltq *, struct mbuf *,
			     struct altq_pktattr *);
static struct mbuf	*cbq_dequeue(struct ifaltq *, int);
static void		 cbqrestart(struct ifaltq *);
static void		 get_class_stats(class_stats_t *, struct rm_class *);
static void		 cbq_purge(cbq_state_t *);
d277 1
a277 1
 *	function destroys a given traffic class.  Before destroying
d281 3
a283 1
cbq_class_destroy(cbq_state_t *cbqp, struct rm_class *cl)
d285 1
a285 1
	u_int32_t	chandle;
d318 3
a320 1
clh_to_clp(cbq_state_t *cbqp, u_int32_t chandle)
d340 2
a341 1
cbq_clear_interface(cbq_state_t *cbqp)
d343 2
a344 1
	int		 again, i;
d347 55
d436 4
a439 1
cbq_request(struct ifaltq *ifq, int req, void *arg)
d441 1
a441 1
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
d451 47
d500 3
a502 1
get_class_stats(class_stats_t *statsp, struct rm_class *cl)
d504 2
a505 2
	statsp->xmit_cnt	= cl->stats_.xmit_cnt;
	statsp->drop_cnt	= cl->stats_.drop_cnt;
d507 3
a509 3
	statsp->borrows		= cl->stats_.borrows;
	statsp->overactions	= cl->stats_.overactions;
	statsp->delays		= cl->stats_.delays;
d511 1
a511 1
	statsp->depth		= cl->depth_;
d533 3
a535 2
int
cbq_pfattach(struct pf_altq *a)
d537 10
a546 2
	struct ifnet	*ifp;
	int		 s, error;
d548 3
a550 1
	if ((ifp = ifunit(a->ifname)) == NULL || a->altq_disc == NULL)
d552 33
a584 4
	s = splimp();
	error = altq_attach(&ifp->if_snd, ALTQT_CBQ, a->altq_disc,
	    cbq_enqueue, cbq_dequeue, cbq_request, NULL, NULL);
	splx(s);
d588 3
a590 2
int
cbq_add_altq(struct pf_altq *a)
d592 8
a599 5
	cbq_state_t	*cbqp;
	struct ifnet	*ifp;

	if ((ifp = ifunit(a->ifname)) == NULL)
		return (EINVAL);
d601 1
a601 1
		return (ENODEV);
d604 2
a605 2
	MALLOC(cbqp, cbq_state_t *, sizeof(cbq_state_t), M_DEVBUF, M_WAITOK);
	if (cbqp == NULL)
d607 23
a629 4
	bzero(cbqp, sizeof(cbq_state_t));
	CALLOUT_INIT(&cbqp->cbq_callout);
	cbqp->cbq_qlen = 0;
	cbqp->ifnp.ifq_ = &ifp->if_snd;	    /* keep the ifq */
d631 3
a633 2
	/* keep the state in pf_altq */
	a->altq_disc = cbqp;
d638 3
a640 2
int
cbq_remove_altq(struct pf_altq *a)
d642 6
a647 1
	cbq_state_t	*cbqp;
d649 1
a649 3
	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);
	a->altq_disc = NULL;
d660 2
a661 5
	/* deallocate cbq_state_t */
	FREE(cbqp, M_DEVBUF);

	return (0);
}
d663 12
a674 32
int
cbq_add_queue(struct pf_altq *a)
{
	struct rm_class	*borrow, *parent;
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	struct cbq_opts	*opts;
	u_int32_t	 chandle;
	int		 i;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);

	opts = &a->pq_u.cbq_opts;
	/* check parameters */
	if (a->priority >= RM_MAXPRIO)
		return (EINVAL);

	/* Get pointers to parent and borrow classes.  */
	parent = clh_to_clp(cbqp, a->parent_qid);
	if (opts->flags & CBQCLF_BORROW)
		borrow = parent;
	else
		borrow = NULL;

	/*
	 * A class must borrow from it's parent or it can not
	 * borrow at all.  Hence, borrow can be null.
	 */
	if (parent == NULL && (opts->flags & CBQCLF_ROOTCLASS) == 0) {
		printf("cbq_add_queue: no parent class!\n");
		return (EINVAL);
d677 3
a679 49
	if ((borrow != parent)  && (borrow != NULL)) {
		printf("cbq_add_class: borrow class != parent\n");
		return (EINVAL);
	}

	/*
	 * allocate class handle
	 */
	switch (opts->flags & CBQCLF_CLASSMASK) {
	case CBQCLF_ROOTCLASS:
		if (parent != NULL)
			return (EINVAL);
		if (cbqp->ifnp.root_)
			return (EINVAL);
		chandle = ROOT_CLASS_HANDLE;
		break;
	case CBQCLF_DEFCLASS:
		if (cbqp->ifnp.default_)
			return (EINVAL);
		chandle = DEFAULT_CLASS_HANDLE;
		break;
	case CBQCLF_CTLCLASS:
		if (cbqp->ifnp.ctl_)
			return (EINVAL);
		chandle = CTL_CLASS_HANDLE;
		break;
	case 0:
		if (a->qid) {
			chandle = a->qid;
			if (chandle >= CBQ_MAX_CLASSES &&
			    chandle != DEFAULT_CLASS_HANDLE &&
			    chandle != CTL_CLASS_HANDLE)
				return (EINVAL);
			if (cbqp->cbq_class_tbl[chandle] != NULL)
				return (EBUSY);
		} else {
			/* find a free class slot. for now, reserve qid 0 */
			for (i = 1; i < CBQ_MAX_CLASSES; i++)
				if (cbqp->cbq_class_tbl[i] == NULL)
					break;
			if (i == CBQ_MAX_CLASSES)
				return (ENOSPC);
			chandle = (u_int32_t)i;
		}
			break;
	default:
		/* more than two flags bits set */
		return (EINVAL);
	}
a680 110
	/*
	 * create a class.  if this is a root class, initialize the
	 * interface.
	 */
	if (chandle == ROOT_CLASS_HANDLE) {
		rmc_init(cbqp->ifnp.ifq_, &cbqp->ifnp, opts->ns_per_byte,
		    cbqrestart, a->qlimit, RM_MAXQUEUED,
		    opts->maxidle, opts->minidle, opts->offtime,
		    opts->flags);
		cl = cbqp->ifnp.root_;
	} else {
		cl = rmc_newclass(a->priority,
				  &cbqp->ifnp, opts->ns_per_byte,
				  rmc_delay_action, a->qlimit, parent, borrow,
				  opts->maxidle, opts->minidle, opts->offtime,
				  opts->pktsize, opts->flags);
	}
	if (cl == NULL)
		return (ENOMEM);

	/* return handle to user space. */
	a->qid = chandle;

	cl->stats_.handle = chandle;
	cl->stats_.depth = cl->depth_;

	/* save the allocated class */
	switch (chandle) {
	case NULL_CLASS_HANDLE:
	case ROOT_CLASS_HANDLE:
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = cl;
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = cl;
		break;
	default:
		cbqp->cbq_class_tbl[chandle] = cl;
		break;
	}
	return (0);
}

int
cbq_remove_queue(struct pf_altq *a)
{
	struct rm_class	*cl;
	cbq_state_t	*cbqp;

	if ((cbqp = a->altq_disc) == NULL)
		return (EINVAL);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	/* if we are a parent class, then return an error. */
	if (is_a_parent_class(cl))
		return (EINVAL);

	/* delete the class */
	rmc_delete_class(&cbqp->ifnp, cl);

	/*
	 * free the class handle
	 */
	switch (a->qid) {
	case ROOT_CLASS_HANDLE:
		cbqp->ifnp.root_ = NULL;
		break;
	case DEFAULT_CLASS_HANDLE:
		cbqp->ifnp.default_ = NULL;
		break;
	case CTL_CLASS_HANDLE:
		cbqp->ifnp.ctl_ = NULL;
		break;
	case NULL_CLASS_HANDLE:
		break;
	default:
		if (a->qid >= CBQ_MAX_CLASSES)
			break;
		cbqp->cbq_class_tbl[a->qid] = NULL;
	}

	return (0);
}

int
cbq_getqstats(struct pf_altq *a, void *ubuf, int *nbytes)
{
	cbq_state_t	*cbqp;
	struct rm_class	*cl;
	class_stats_t	 stats;
	int		 error = 0;

	if ((cbqp = altq_lookup(a->ifname, ALTQT_CBQ)) == NULL)
		return (EBADF);

	if ((cl = clh_to_clp(cbqp, a->qid)) == NULL)
		return (EINVAL);

	if (*nbytes < sizeof(stats))
		return (EINVAL);

	get_class_stats(&stats, cl);
	stats.handle = a->qid;

	if ((error = copyout((caddr_t)&stats, ubuf, sizeof(stats))) != 0)
		return (error);
	*nbytes = sizeof(stats);
d695 1
a695 1
 *			ENOBUFS if a packet dropping occurred as a result of
d700 8
a707 6
cbq_enqueue(struct ifaltq *ifq, struct mbuf *m, struct altq_pktattr *pktattr)
{
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct rm_class	*cl;
	struct m_tag	*t;
	int		 len;
d710 1
a710 10
	if ((m->m_flags & M_PKTHDR) == 0) {
		/* should not happen */
		printf("altq: packet for %s does not have pkthdr\n",
		    ifq->altq_ifp->if_xname);
		m_freem(m);
		return (ENOBUFS);
	}
	t = m_tag_find(m, PACKET_TAG_PF_QID, NULL);
	if (t == NULL ||
	    (cl = clh_to_clp(cbqp, ((struct altq_tag *)(t+1))->qid)) == NULL) {
d712 1
a712 6
		if (cl == NULL) {
			m_freem(m);
			return (ENOBUFS);
		}
		cl->pktattr_ = NULL;
	}
d728 3
a730 1
cbq_dequeue(struct ifaltq *ifq, int op)
d732 2
a733 2
	cbq_state_t	*cbqp = (cbq_state_t *)ifq->altq_disc;
	struct mbuf	*m;
d756 2
a757 1
cbqrestart(struct ifaltq *ifq)
a764 1

d775 2
a776 1
static void cbq_purge(cbq_state_t *cbqp)
d779 1
a779 1
	int		 i;
d787 172
@


1.1.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_cbq.c,v 1.1.2.3 2003/03/27 22:28:24 niklas Exp $	*/
d89 3
d114 2
d143 5
d261 2
d281 2
d314 1
a314 1
	 * check parameters
d322 1
a322 1
		a->qid = ROOT_CLASS_HANDLE;
d327 1
a327 1
		a->qid = DEFAULT_CLASS_HANDLE;
d329 2
a330 2
	case 0:
		if (a->qid == 0)
d332 1
a332 5
		if (a->qid >= CBQ_MAX_CLASSES &&
		    a->qid != DEFAULT_CLASS_HANDLE)
			return (EINVAL);
		if (cbqp->cbq_class_tbl[a->qid] != NULL)
			return (EBUSY);
d334 19
d362 1
a362 1
	if (a->qid == ROOT_CLASS_HANDLE) {
d379 3
a381 1
	cl->stats_.handle = a->qid;
d385 1
a385 1
	switch (a->qid) {
d392 3
d396 1
a396 1
		cbqp->cbq_class_tbl[a->qid] = cl;
d430 3
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 3
a74 1
	int	i;
d82 2
a83 5
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if (cbqp->cbq_class_tbl[i] == cl)
			cbqp->cbq_class_tbl[i] = NULL;

	if (cl == cbqp->ifnp.root_)
d85 2
a86 1
	if (cl == cbqp->ifnp.default_)
d88 9
d104 8
a111 2
	int i;
	struct rm_class *cl;
d113 1
a113 1
	if (chandle == 0)
d115 2
a116 13
	/*
	 * first, try the slot corresponding to the lower bits of the handle.
	 * if it does not match, do the linear table search.
	 */
	i = chandle % CBQ_MAX_CLASSES;
	if ((cl = cbqp->cbq_class_tbl[i]) != NULL &&
	    cl->stats_.handle == chandle)
		return (cl);
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if ((cl = cbqp->cbq_class_tbl[i]) != NULL &&
		    cl->stats_.handle == chandle)
			return (cl);
	return (NULL);
a134 4
					if (cl == cbqp->ifnp.root_)
						cbqp->ifnp.root_ = NULL;
					if (cl == cbqp->ifnp.default_)
						cbqp->ifnp.default_ = NULL;
d138 10
a169 1
	statsp->handle		= cl->stats_.handle;
a268 1
	int		i;
a271 16
	if (a->qid == 0)
		return (EINVAL);

	/*
	 * find a free slot in the class table.  if the slot matching
	 * the lower bits of qid is free, use this slot.  otherwise,
	 * use the first free slot.
	 */
	i = a->qid % CBQ_MAX_CLASSES;
	if (cbqp->cbq_class_tbl[i] != NULL) {
		for (i = 0; i < CBQ_MAX_CLASSES; i++)
			if (cbqp->cbq_class_tbl[i] == NULL)
				break;
		if (i == CBQ_MAX_CLASSES)
			return (EINVAL);
	}
d275 1
a275 1
	if (a->priority >= CBQ_MAXPRI)
d308 1
d313 1
d318 5
d333 1
a333 1
	if ((opts->flags & CBQCLF_CLASSMASK) == CBQCLF_ROOTCLASS) {
d354 5
a358 3
	cbqp->cbq_class_tbl[i] = cl;

	if ((opts->flags & CBQCLF_CLASSMASK) == CBQCLF_DEFCLASS)
d360 5
a364 1

a372 1
	int		i;
d390 11
a400 7
	for (i = 0; i < CBQ_MAX_CLASSES; i++)
		if (cbqp->cbq_class_tbl[i] == cl) {
			cbqp->cbq_class_tbl[i] = NULL;
			if (cl == cbqp->ifnp.root_)
				cbqp->ifnp.root_ = NULL;
			if (cl == cbqp->ifnp.default_)
				cbqp->ifnp.default_ = NULL;
d402 2
a403 1
		}
d426 1
@


