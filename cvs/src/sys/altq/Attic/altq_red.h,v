head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.7
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.6;

1.6
date	2011.07.04.01.07.43;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.16.17.27.20;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.16.09.18.05;	author kjc;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.36;	author kjc;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.27.22.28.25;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@bye bye
@
text
@/*	$OpenBSD: altq_red.h,v 1.6 2011/07/04 01:07:43 henning Exp $	*/
/*	$KAME: altq_red.h,v 1.5 2000/12/14 08:12:46 thorpej Exp $	*/

/*
 * Copyright (C) 1997-2002
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _ALTQ_ALTQ_RED_H_
#define	_ALTQ_ALTQ_RED_H_

#include <altq/altq_classq.h>

/* red flags */
#define	REDF_ECN4	0x01	/* use packet marking for IPv4 packets */
#define	REDF_ECN6	0x02	/* use packet marking for IPv6 packets */
#define	REDF_ECN	(REDF_ECN4 | REDF_ECN6)

/*
 * simpler versions of red parameters and statistics used by other
 * disciplines (e.g., CBQ)
 */
struct redparams {
	int	th_min;		/* red min threshold */
	int	th_max;		/* red max threshold */
	int	inv_pmax;	/* inverse of max drop probability */
};

struct redstats {
	int		q_avg;
	struct pktcntr	xmit_cnt;
	struct pktcntr	drop_cnt;
	u_int		drop_forced;
	u_int		drop_unforced;
	u_int		marked_packets;
};

#ifdef _KERNEL

/* weight table structure for idle time calibration */
struct wtab {
	struct wtab	*w_next;
	int		 w_weight;
	int		 w_param_max;
	int		 w_refcount;
	int32_t		 w_tab[32];
};

typedef struct red {
	int		red_pkttime;	/* average packet time in micro sec
					   used for idle calibration */
	int		red_flags;	/* red flags */

	/* red parameters */
	int		red_weight;	/* weight for EWMA */
	int		red_inv_pmax;	/* inverse of max drop probability */
	int		red_thmin;	/* red min threshold */
	int		red_thmax;	/* red max threshold */

	/* variables for internal use */
	int		red_wshift;	/* log(red_weight) */
	int		red_thmin_s;	/* th_min scaled by avgshift */
	int		red_thmax_s;	/* th_max scaled by avgshift */
	int		red_probd;	/* drop probability denominator */

	int		red_avg;	/* queue len avg scaled by avgshift */
	int		red_count;	/* packet count since last dropped/
					   marked packet */
	int		red_idle;	/* queue was empty */
	int		red_old;	/* avg is above th_min */
	struct wtab	*red_wtab;	/* weight table */
	struct timeval	 red_last;	/* time when the queue becomes idle */

	struct {
		struct pktcntr	xmit_cnt;
		struct pktcntr	drop_cnt;
		u_int		drop_forced;
		u_int		drop_unforced;
		u_int		marked_packets;
	} red_stats;
} red_t;

/* red drop types */
#define	DTYPE_NODROP	0	/* no drop */
#define	DTYPE_FORCED	1	/* a "forced" drop */
#define	DTYPE_EARLY	2	/* an "unforced" (early) drop */

extern red_t		*red_alloc(int, int, int, int, int, int);
extern void		 red_destroy(red_t *);
extern void		 red_getstats(red_t *, struct redstats *);
extern int		 red_addq(red_t *, class_queue_t *, struct mbuf *,
			     struct altq_pktattr *);
extern struct mbuf	*red_getq(red_t *, class_queue_t *);
extern int		 drop_early(int, int, int);
extern int		 mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab	*wtab_alloc(int);
extern int		 wtab_destroy(struct wtab *);
extern int32_t		 pow_w(struct wtab *, int);

#endif /* _KERNEL */

#endif /* _ALTQ_ALTQ_RED_H_ */
@


1.6
log
@rip out more effectively dead code, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.5 2002/12/16 17:27:20 henning Exp $	*/
@


1.5
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.4 2002/12/16 09:18:05 kjc Exp $	*/
a38 1
#define	REDF_FLOWVALVE	0x04	/* use flowvalve (aka penalty-box) */
@


1.4
log
@switchover to pf-based altq.
 - remove files which are no longer used, or we don't have plans to support
   in pf in the near future.
 - remove altq ioctl related stuff.
 - convert the PRIQ, HFSC and RIO modules to pf-based altq.
   (these are not enabled in GENERIC, CDNR is not converted yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.3 2002/11/26 01:03:34 henning Exp $	*/
d46 3
a48 3
	int th_min;		/* red min threshold */
	int th_max;		/* red max threshold */
	int inv_pmax;		/* inverse of max drop probability */
d64 5
a68 5
	struct wtab *w_next;
	int w_weight;
	int w_param_max;
	int w_refcount;
	int32_t w_tab[32];
d72 3
a74 3
	int red_pkttime; 	/* average packet time in micro sec
				   used for idle calibration */
	int red_flags;		/* red flags */
d77 4
a80 4
	int red_weight;		/* weight for EWMA */
	int red_inv_pmax;	/* inverse of max drop probability */
	int red_thmin;		/* red min threshold */
	int red_thmax;		/* red max threshold */
d83 12
a94 12
	int red_wshift;		/* log(red_weight) */
	int red_thmin_s;	/* th_min scaled by avgshift */
	int red_thmax_s;	/* th_max scaled by avgshift */
	int red_probd;		/* drop probability denominator */

	int red_avg;		/* queue length average scaled by avgshift */
	int red_count; 	  	/* packet count since the last dropped/marked
				   packet */
	int red_idle;		/* queue was empty */
	int red_old;		/* avg is above th_min */
	struct wtab *red_wtab;	/* weight table */
	struct timeval red_last;  /* timestamp when the queue becomes idle */
d110 11
a120 11
extern red_t *red_alloc(int, int, int, int, int, int);
extern void red_destroy(red_t *);
extern void red_getstats(red_t *, struct redstats *);
extern int red_addq(red_t *, class_queue_t *, struct mbuf *,
			 struct altq_pktattr *);
extern struct mbuf *red_getq(red_t *, class_queue_t *);
extern int drop_early(int, int, int);
extern int mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab *wtab_alloc(int);
extern int wtab_destroy(struct wtab *);
extern int32_t pow_w(struct wtab *, int);
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.2 2002/03/14 01:26:26 millert Exp $	*/
d5 1
a5 1
 * Copyright (C) 1997-2000
a34 41
struct red_interface {
	char	red_ifname[IFNAMSIZ];
};

struct red_stats {
	struct red_interface iface;
	int q_len;
	int q_avg;

	struct pktcntr	xmit_cnt;
	struct pktcntr	drop_cnt;
	u_int		drop_forced;
	u_int		drop_unforced;
	u_int		marked_packets;

	/* static red parameters */
	int q_limit;
	int weight;
	int inv_pmax;
	int th_min;
	int th_max;

	/* flowvalve related stuff */
	u_int fv_flows;
	u_int fv_pass;
	u_int fv_predrop;
	u_int fv_alloc;
	u_int fv_escape;
};

struct red_conf {
	struct red_interface iface;
	int red_weight;		/* weight for EWMA */
	int red_inv_pmax;	/* inverse of max drop probability */
	int red_thmin;		/* red min threshold */
	int red_thmax;		/* red max threshold */
	int red_limit;		/* max queue length */
	int red_pkttime;	/* average packet time in usec */
	int red_flags;		/* see below */
};

a59 12

/*
 * IOCTLs for RED
 */
#define	RED_IF_ATTACH		_IOW('Q', 1, struct red_interface)
#define	RED_IF_DETACH		_IOW('Q', 2, struct red_interface)
#define	RED_ENABLE		_IOW('Q', 3, struct red_interface)
#define	RED_DISABLE		_IOW('Q', 4, struct red_interface)
#define	RED_CONFIG		_IOWR('Q', 6, struct red_conf)
#define	RED_GETSTATS		_IOWR('Q', 12, struct red_stats)
#define	RED_SETDEFAULTS		_IOW('Q', 30, struct redparams)

a61 2
struct flowvalve;

a95 2
	struct flowvalve *red_flowvalve;	/* flowvalve state */

a103 9

typedef struct red_queue {
	struct red_queue *rq_next;	/* next red_state in the list */
	struct ifaltq *rq_ifq;		/* backpointer to ifaltq */

	class_queue_t *rq_q;

	red_t *rq_red;
} red_queue_t;
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d102 1
a102 1
/* 
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d176 11
a186 11
extern red_t *red_alloc __P((int, int, int, int, int, int));
extern void red_destroy __P((red_t *));
extern void red_getstats __P((red_t *, struct redstats *));
extern int red_addq __P((red_t *, class_queue_t *, struct mbuf *,
			 struct altq_pktattr *));
extern struct mbuf *red_getq __P((red_t *, class_queue_t *));
extern int drop_early __P((int, int, int));
extern int mark_ecn __P((struct mbuf *, struct altq_pktattr *, int));
extern struct wtab *wtab_alloc __P((int));
extern int wtab_destroy __P((struct wtab *));
extern int32_t pow_w __P((struct wtab *, int));
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_red.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d176 11
a186 11
extern red_t *red_alloc(int, int, int, int, int, int);
extern void red_destroy(red_t *);
extern void red_getstats(red_t *, struct redstats *);
extern int red_addq(red_t *, class_queue_t *, struct mbuf *,
			 struct altq_pktattr *);
extern struct mbuf *red_getq(red_t *, class_queue_t *);
extern int drop_early(int, int, int);
extern int mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab *wtab_alloc(int);
extern int wtab_destroy(struct wtab *);
extern int32_t pow_w(struct wtab *, int);
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (C) 1997-2002
d35 41
d87 3
a89 3
	int	th_min;		/* red min threshold */
	int	th_max;		/* red max threshold */
	int	inv_pmax;	/* inverse of max drop probability */
d101 12
d115 2
d119 5
a123 5
	struct wtab	*w_next;
	int		 w_weight;
	int		 w_param_max;
	int		 w_refcount;
	int32_t		 w_tab[32];
d127 3
a129 3
	int		red_pkttime;	/* average packet time in micro sec
					   used for idle calibration */
	int		red_flags;	/* red flags */
d132 4
a135 4
	int		red_weight;	/* weight for EWMA */
	int		red_inv_pmax;	/* inverse of max drop probability */
	int		red_thmin;	/* red min threshold */
	int		red_thmax;	/* red max threshold */
d138 14
a151 12
	int		red_wshift;	/* log(red_weight) */
	int		red_thmin_s;	/* th_min scaled by avgshift */
	int		red_thmax_s;	/* th_max scaled by avgshift */
	int		red_probd;	/* drop probability denominator */

	int		red_avg;	/* queue len avg scaled by avgshift */
	int		red_count;	/* packet count since last dropped/
					   marked packet */
	int		red_idle;	/* queue was empty */
	int		red_old;	/* avg is above th_min */
	struct wtab	*red_wtab;	/* weight table */
	struct timeval	 red_last;	/* time when the queue becomes idle */
d162 9
d176 11
a186 11
extern red_t		*red_alloc(int, int, int, int, int, int);
extern void		 red_destroy(red_t *);
extern void		 red_getstats(red_t *, struct redstats *);
extern int		 red_addq(red_t *, class_queue_t *, struct mbuf *,
			     struct altq_pktattr *);
extern struct mbuf	*red_getq(red_t *, class_queue_t *);
extern int		 drop_early(int, int, int);
extern int		 mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab	*wtab_alloc(int);
extern int		 wtab_destroy(struct wtab *);
extern int32_t		 pow_w(struct wtab *, int);
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d176 11
a186 11
extern red_t *red_alloc(int, int, int, int, int, int);
extern void red_destroy(red_t *);
extern void red_getstats(red_t *, struct redstats *);
extern int red_addq(red_t *, class_queue_t *, struct mbuf *,
			 struct altq_pktattr *);
extern struct mbuf *red_getq(red_t *, class_queue_t *);
extern int drop_early(int, int, int);
extern int mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab *wtab_alloc(int);
extern int wtab_destroy(struct wtab *);
extern int32_t pow_w(struct wtab *, int);
@


1.1.2.2
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 1
 * Copyright (C) 1997-2002
d35 41
d87 3
a89 3
	int	th_min;		/* red min threshold */
	int	th_max;		/* red max threshold */
	int	inv_pmax;	/* inverse of max drop probability */
d101 12
d115 2
d119 5
a123 5
	struct wtab	*w_next;
	int		 w_weight;
	int		 w_param_max;
	int		 w_refcount;
	int32_t		 w_tab[32];
d127 3
a129 3
	int		red_pkttime;	/* average packet time in micro sec
					   used for idle calibration */
	int		red_flags;	/* red flags */
d132 4
a135 4
	int		red_weight;	/* weight for EWMA */
	int		red_inv_pmax;	/* inverse of max drop probability */
	int		red_thmin;	/* red min threshold */
	int		red_thmax;	/* red max threshold */
d138 14
a151 12
	int		red_wshift;	/* log(red_weight) */
	int		red_thmin_s;	/* th_min scaled by avgshift */
	int		red_thmax_s;	/* th_max scaled by avgshift */
	int		red_probd;	/* drop probability denominator */

	int		red_avg;	/* queue len avg scaled by avgshift */
	int		red_count;	/* packet count since last dropped/
					   marked packet */
	int		red_idle;	/* queue was empty */
	int		red_old;	/* avg is above th_min */
	struct wtab	*red_wtab;	/* weight table */
	struct timeval	 red_last;	/* time when the queue becomes idle */
d162 9
d176 11
a186 11
extern red_t		*red_alloc(int, int, int, int, int, int);
extern void		 red_destroy(red_t *);
extern void		 red_getstats(red_t *, struct redstats *);
extern int		 red_addq(red_t *, class_queue_t *, struct mbuf *,
			     struct altq_pktattr *);
extern struct mbuf	*red_getq(red_t *, class_queue_t *);
extern int		 drop_early(int, int, int);
extern int		 mark_ecn(struct mbuf *, struct altq_pktattr *, int);
extern struct wtab	*wtab_alloc(int);
extern int		 wtab_destroy(struct wtab *);
extern int32_t		 pow_w(struct wtab *, int);
@


