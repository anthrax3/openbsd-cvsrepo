head	1.17;
access;
symbols
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.8
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.5
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.17
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.16;

1.16
date	2013.10.12.12.13.10;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.07.17.10.08;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.08.18.48.50;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.03.22.39.12;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.31.19.15.59;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.18.12.51.48;	author mpf;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.17.08.43.35;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.17.00.09.00;	author henning;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.16.17.27.20;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.08.05.12.08;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.01.05.06.24;	author kjc;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.36;	author kjc;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.22.28.25;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.06.05.23.12.26;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@bye bye
@
text
@/*	$OpenBSD: if_altq.h,v 1.16 2013/10/12 12:13:10 henning Exp $	*/
/*	$KAME: if_altq.h,v 1.6 2001/01/29 19:59:09 itojun Exp $	*/

/*
 * Copyright (C) 1997-2000
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef _ALTQ_IF_ALTQ_H_
#define	_ALTQ_IF_ALTQ_H_

struct altq_pktattr; struct oldtb_regulator; struct hfsc_if;

#define ALTQ_IFQ_NQUEUES	8

/*
 * Structure defining a queue for a network interface.
 */
struct	ifaltq {
	/* fields compatible with struct ifqueue */
	struct {
		struct	mbuf *head;
		struct	mbuf *tail;
	}	ifq_q[ALTQ_IFQ_NQUEUES];
	int	ifq_len;
	int	ifq_maxlen;
	int	ifq_drops;
	struct	hfsc_if *ifq_hfsc;
	struct	timeout *ifq_congestion;

	/* alternate queueing related fields */
	int	altq_type;		/* discipline type */
	int	altq_flags;		/* flags (e.g. ready, in-use) */
	void	*altq_disc;		/* for discipline-specific use */
	struct	ifnet *altq_ifp;	/* back pointer to interface */

	int	(*altq_enqueue)(struct ifaltq *, struct mbuf *,
				     struct altq_pktattr *);
	struct	mbuf *(*altq_dequeue)(struct ifaltq *, int);
	int	(*altq_request)(struct ifaltq *, int, void *);

	/* classifier fields */
	void	*altq_clfier;		/* classifier-specific use */
	void	*(*altq_classify)(void *, struct mbuf *, int);

	/* token bucket regulator */
	struct	oldtb_regulator *altq_tbr;
};

#ifdef _KERNEL

/*
 * packet attributes used by queueing disciplines.
 * pattr_class is a discipline-dependent scheduling class that is
 * set by a classifier.
 * pattr_hdr and pattr_af may be used by a discipline to access
 * the header within a mbuf.  (e.g. ECN needs to update the CE bit)
 * note that pattr_hdr could be stale after m_pullup, though link
 * layer output routines usually don't use m_pullup.  link-level
 * compression also invalidates these fields.  thus, pattr_hdr needs
 * to be verified when a discipline touches the header.
 */
struct altq_pktattr {
	void	*pattr_class;		/* sched class set by classifier */
	int	pattr_af;		/* address family */
	caddr_t	pattr_hdr;		/* saved header position in mbuf */
};

/*
 * a token-bucket regulator limits the rate that a network driver can
 * dequeue packets from the output queue.
 * modern cards are able to buffer a large amount of packets and dequeue
 * too many packets at a time.  this bursty dequeue behavior makes it
 * impossible to schedule packets by queueing disciplines.
 * a token-bucket is used to control the burst size in a device
 * independent manner.
 */
struct oldtb_regulator {
	int64_t		tbr_rate;	/* (scaled) token bucket rate */
	int64_t		tbr_depth;	/* (scaled) token bucket depth */

	int64_t		tbr_token;	/* (scaled) current token */
	int64_t		tbr_filluptime;	/* (scaled) time to fill up bucket */
	u_int64_t	tbr_last;	/* last time token was updated */

	int		tbr_lastop;	/* last dequeue operation type
					   needed for poll-and-dequeue */
};

/* if_altqflags */
#define	ALTQF_READY	 0x01	/* driver supports alternate queueing */
#define	ALTQF_ENABLED	 0x02	/* altq is in use */
#define	ALTQF_CLASSIFY	 0x04	/* classify packets */
#define	ALTQF_CNDTNING	 0x08	/* altq traffic conditioning is enabled */
#define	ALTQF_DRIVER1	 0x40	/* driver specific */

/* if_altqflags set internally only: */
#define	ALTQF_CANTCHANGE	(ALTQF_READY)

/* altq_dequeue 2nd arg */
#define	ALTDQ_REMOVE		1	/* dequeue mbuf from the queue */
#define	ALTDQ_POLL		2	/* don't dequeue mbuf from the queue */

/* altq request types (currently only purge is defined) */
#define	ALTRQ_PURGE		1	/* purge all packets */

#define	ALTQ_IS_READY(ifq)		((ifq)->altq_flags & ALTQF_READY)
#define	ALTQ_IS_ENABLED(ifq)		((ifq)->altq_flags & ALTQF_ENABLED)
#define	ALTQ_NEEDS_CLASSIFY(ifq)	((ifq)->altq_flags & ALTQF_CLASSIFY)
#define	ALTQ_IS_CNDTNING(ifq)		((ifq)->altq_flags & ALTQF_CNDTNING)

#define	ALTQ_SET_CNDTNING(ifq)		((ifq)->altq_flags |= ALTQF_CNDTNING)
#define	ALTQ_CLEAR_CNDTNING(ifq)	((ifq)->altq_flags &= ~ALTQF_CNDTNING)
#define	ALTQ_IS_ATTACHED(ifq)		((ifq)->altq_disc != NULL)

#define	ALTQ_ENQUEUE(ifq, m, pa, err)					\
	(err) = (*(ifq)->altq_enqueue)((ifq),(m),(pa))
#define	ALTQ_DEQUEUE(ifq, m)						\
	(m) = (*(ifq)->altq_dequeue)((ifq), ALTDQ_REMOVE)
#define	ALTQ_POLL(ifq, m)						\
	(m) = (*(ifq)->altq_dequeue)((ifq), ALTDQ_POLL)
#define	ALTQ_PURGE(ifq)							\
	(void)(*(ifq)->altq_request)((ifq), ALTRQ_PURGE, (void *)0)
#define	ALTQ_IS_EMPTY(ifq)		((ifq)->ifq_len == 0)
#define	OLDTBR_IS_ENABLED(ifq)		((ifq)->altq_tbr != NULL)
#define	TBR_IS_ENABLED(ifq)		OLDTBR_IS_ENABLED(ifq)

extern int altq_attach(struct ifaltq *, int, void *,
			    int (*)(struct ifaltq *, struct mbuf *,
				    struct altq_pktattr *),
			    struct mbuf *(*)(struct ifaltq *, int),
			    int (*)(struct ifaltq *, int, void *),
			    void *,
			    void *(*)(void *, struct mbuf *, int));
extern int altq_detach(struct ifaltq *);
extern int altq_enable(struct ifaltq *);
extern int altq_disable(struct ifaltq *);
extern struct mbuf *oldtbr_dequeue(struct ifaltq *, int);
extern int (*altq_input)(struct mbuf *, int);

#endif /* _KERNEL */

#endif /* _ALTQ_IF_ALTQ_H_ */
@


1.16
log
@new bandwidth shaping subsystem, kernel side
uses hfsc behind the scenes; altq stays in parallel for a migration phase.
if.h even more messy for the transition, but eventuelly it should become
readable...
looked over & tested by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.15 2011/10/07 17:10:08 henning Exp $	*/
@


1.15
log
@rename some vars and functions
unfortunately altq is one giant namespace violation. rename just those that
conflict with new stuff for now only to be found on my laptop. reduce pain,
the diff is huge already. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.13 2011/07/03 22:39:12 tedu Exp $	*/
d32 1
a32 1
struct altq_pktattr; struct tb_regulator;
d48 1
@


1.14
log
@new priority queueing implementation, extremely low overhead, thus fast.
unconditional, always on. 8 priority levels, as every better switch, the
vlan header etc etc. ok ryan mpf sthen, pea tested as well
@
text
@d66 1
a66 1
	struct	tb_regulator *altq_tbr;
d97 1
a97 1
struct tb_regulator {
d144 2
a145 1
#define	TBR_IS_ENABLED(ifq)		((ifq)->altq_tbr != NULL)
d157 1
a157 1
extern struct mbuf *tbr_dequeue(struct ifaltq *, int);
@


1.13
log
@cdnr and rio disciplines are not being used or supported, clear a path
for new code.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.12 2009/05/31 19:15:59 claudio Exp $	*/
d34 2
d41 4
a44 2
	struct	mbuf *ifq_head;
	struct	mbuf *ifq_tail;
a67 1

@


1.12
log
@Remove _KERNEL goo from kernel files because we're setting _KERNEL correctly.
OK deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.11 2007/11/18 12:51:48 mpf Exp $	*/
d32 1
a32 1
struct altq_pktattr; struct tb_regulator; struct top_cdnr;
a62 3

	/* input traffic conditioner (doesn't belong to the output queue...) */
	struct top_cdnr *altq_cdnr;
@


1.11
log
@Sync struct ifaltq to match struct ifqueue.
I wonder why 64-bit archs have not been bitten by this.
OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.10 2005/10/17 08:43:35 henning Exp $	*/
a30 6

#ifdef KERNEL
#ifndef _KERNEL
#define	_KERNEL
#endif
#endif
@


1.10
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.9 2004/04/17 00:09:00 henning Exp $	*/
d50 1
a50 1
	int	ifq_congestion;
@


1.9
log
@add a congestion indicator to if_queue. It is set when the input queue
is full, along with a timer that unsets it again after 10ms.
The input queue beeing full is a reliable indicator for CPU overload, and
this flag allows other subsystems to cope with the situation.
hacked with beck
ok kjc@@ markus@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.8 2003/01/07 09:00:34 kjc Exp $	*/
a91 10
};

/*
 * mbuf tag to carry a queue id (and hints for ECN).
 */
struct altq_tag {
	u_int32_t	qid;		/* queue id */
	/* hints for ecn */
	int		af;		/* address family */
	void		*hdr;		/* saved header position in mbuf */
@


1.8
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.7 2002/12/16 17:27:20 henning Exp $	*/
d50 1
@


1.7
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.6 2002/11/26 01:03:34 henning Exp $	*/
a172 1
void altq_etherclassify(struct ifaltq *, struct mbuf *, struct altq_pktattr *);
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.5 2002/10/08 05:12:08 kjc Exp $	*/
d132 1
a132 1
#define	ALTQF_CANTCHANGE 	(ALTQF_READY)
@


1.5
log
@the first step of pf/altq merge.
this commit is to allow further development in both userland and kernel.

the goal is to replace altq's classifier by pf(4).
- make pf tag a queue id to mbuf and make altq read the queue id
- merge altq config into pf.conf(5)

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.4 2002/03/14 03:15:50 millert Exp $	*/
d164 1
a164 1
			    struct mbuf *(*)(struct ifaltq *, int), 
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.3 2002/03/14 01:26:26 millert Exp $	*/
d91 10
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.2 2002/03/01 05:06:24 kjc Exp $	*/
d151 1
a151 1
extern int altq_attach __P((struct ifaltq *, int, void *,
d157 1
a157 1
			    void *(*)(void *, struct mbuf *, int)));
@


1.2
log
@sync with KAME
move the function prototype of altq_etherclassify() from
netinet/if_ether.h to altq/if_altq.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d57 4
a60 4
	int	(*altq_enqueue) __P((struct ifaltq *, struct mbuf *,
				     struct altq_pktattr *));
	struct	mbuf *(*altq_dequeue) __P((struct ifaltq *, int));
	int	(*altq_request) __P((struct ifaltq *, int, void *));
d64 1
a64 1
	void	*(*altq_classify) __P((void *, struct mbuf *, int));
d158 5
a162 5
extern int altq_detach __P((struct ifaltq *));
extern int altq_enable __P((struct ifaltq *));
extern int altq_disable __P((struct ifaltq *));
extern struct mbuf *tbr_dequeue __P((struct ifaltq *, int));
extern int (*altq_input) __P((struct mbuf *, int));
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d163 1
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d57 4
a60 4
	int	(*altq_enqueue)(struct ifaltq *, struct mbuf *,
				     struct altq_pktattr *);
	struct	mbuf *(*altq_dequeue)(struct ifaltq *, int);
	int	(*altq_request)(struct ifaltq *, int, void *);
d64 1
a64 1
	void	*(*altq_classify)(void *, struct mbuf *, int);
d151 1
a151 1
extern int altq_attach(struct ifaltq *, int, void *,
d157 6
a162 7
			    void *(*)(void *, struct mbuf *, int));
extern int altq_detach(struct ifaltq *);
extern int altq_enable(struct ifaltq *);
extern int altq_disable(struct ifaltq *);
extern struct mbuf *tbr_dequeue(struct ifaltq *, int);
extern int (*altq_input)(struct mbuf *, int);
void altq_etherclassify(struct ifaltq *, struct mbuf *, struct altq_pktattr *);
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_altq.h,v 1.1.6.1 2002/06/11 03:27:42 art Exp $	*/
a90 10
};

/*
 * mbuf tag to carry a queue id (and hints for ECN).
 */
struct altq_tag {
	u_int32_t	qid;		/* queue id */
	/* hints for ecn */
	int		af;		/* address family */
	void		*hdr;		/* saved header position in mbuf */
@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
#define	ALTQF_CANTCHANGE	(ALTQF_READY)
d164 1
a164 1
			    struct mbuf *(*)(struct ifaltq *, int),
d173 1
@


1.1.2.1
log
@Merge in trunk
@
text
@a162 1
void altq_etherclassify(struct ifaltq *, struct mbuf *, struct altq_pktattr *);
@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d57 4
a60 4
	int	(*altq_enqueue)(struct ifaltq *, struct mbuf *,
				     struct altq_pktattr *);
	struct	mbuf *(*altq_dequeue)(struct ifaltq *, int);
	int	(*altq_request)(struct ifaltq *, int, void *);
d64 1
a64 1
	void	*(*altq_classify)(void *, struct mbuf *, int);
d151 1
a151 1
extern int altq_attach(struct ifaltq *, int, void *,
d157 6
a162 6
			    void *(*)(void *, struct mbuf *, int));
extern int altq_detach(struct ifaltq *);
extern int altq_enable(struct ifaltq *);
extern int altq_disable(struct ifaltq *);
extern struct mbuf *tbr_dequeue(struct ifaltq *, int);
extern int (*altq_input)(struct mbuf *, int);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@a93 10
 * mbuf tag to carry a queue id (and hints for ECN).
 */
struct altq_tag {
	u_int32_t	qid;		/* queue id */
	/* hints for ecn */
	int		af;		/* address family */
	void		*hdr;		/* saved header position in mbuf */
};

/*
d122 1
a122 1
#define	ALTQF_CANTCHANGE	(ALTQF_READY)
d154 1
a154 1
			    struct mbuf *(*)(struct ifaltq *, int),
d163 1
@


1.1.2.4
log
@Merge with the trunk
@
text
@a49 1
	int	ifq_congestion;
@


