head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.12
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.8
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.16
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.14
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.12
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.8
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.6
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.4
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.18
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.17;

1.17
date	2011.10.07.17.10.08;	author henning;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.03.23.48.41;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.20.07.05.52;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.27.02.56.20;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.14.08.42.23;	author kjc;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.27.17.51.11;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.18.00.15.21;	author henning;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.16.09.18.06;	author kjc;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.29.07.51.54;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.26.03.44.53;	author kjc;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.11.09.30.30;	author kjc;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.08.05.12.08;	author kjc;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.31.09.44.53;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.15.01.20.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.13.08.06.14;	author kjc;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.36;	author kjc;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.22.28.25;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.05.13.19.21.26;	author ho;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.51.22;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.06.05.23.12.26;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.10.29.00.28.00;	author art;	state Exp;
branches;
next	1.1.6.3;

1.1.6.3
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@bye bye
@
text
@/*	$OpenBSD: altq_var.h,v 1.17 2011/10/07 17:10:08 henning Exp $	*/
/*	$KAME: altq_var.h,v 1.8 2001/02/09 09:44:41 kjc Exp $	*/

/*
 * Copyright (C) 1998-2000
 *	Sony Computer Science Laboratories Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef _ALTQ_ALTQ_VAR_H_
#define	_ALTQ_ALTQ_VAR_H_

#ifdef _KERNEL

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/queue.h>
#include <dev/rndvar.h>

#ifndef ALTQ_RED
#define ALTQ_RED		/* RED is enabled by default */
#endif
#ifndef ALTQ_CBQ
#define ALTQ_CBQ		/* CBQ is enabled by default */
#endif
#ifndef ALTQ_PRIQ
#define ALTQ_PRIQ		/* PRIQ is enabled by default */
#endif
#ifndef ALTQ_HFSC
#define ALTQ_HFSC		/* HFSC is enabled by default */
#endif

/*
 * machine dependent clock
 * a 64bit high resolution time counter.
 */
extern int machclk_usepcc;
extern u_int32_t machclk_freq;
extern u_int32_t machclk_per_tick;
extern void init_machclk(void);
extern u_int64_t read_machclk(void);

/*
 * debug support
 */
#ifdef ALTQ_DEBUG
#ifdef __STDC__
#define	ASSERT(e)	((e) ? (void)0 : altq_assert(__FILE__, __LINE__, #e))
#else	/* PCC */
#define	ASSERT(e)	((e) ? (void)0 : altq_assert(__FILE__, __LINE__, "e"))
#endif
#else
#define	ASSERT(e)	((void)0)
#endif

/*
 * misc stuff for compatibility
 */

/* macro for timeout/untimeout */
#include <sys/timeout.h>
/* callout structure as a wrapper of struct timeout */
struct callout {
	struct timeout	c_to;
};
#define	CALLOUT_INIT(c)		do { bzero((c), sizeof(*(c))); } while (0)
#define	CALLOUT_RESET(c,t,f,a)	do { if (!timeout_initialized(&(c)->c_to))  \
					 timeout_set(&(c)->c_to, (f), (a)); \
				     timeout_add(&(c)->c_to, (t)); } while (0)
#define	CALLOUT_STOP(c)		timeout_del(&(c)->c_to)
#define	CALLOUT_INITIALIZER	{ { { NULL }, NULL, NULL, 0, 0 } }

typedef void (timeout_t)(void *);

#define	m_pktlen(m)		((m)->m_pkthdr.len)

struct ifnet; struct mbuf;
struct pf_altq; struct pf_qstats;

void	*altq_lookup(char *, int);
void	write_dsfield(struct mbuf *, struct altq_pktattr *, u_int8_t);
void	altq_assert(const char *, int, const char *);
int	oldtbr_set(struct ifaltq *, struct oldtb_profile *);
int	oldtbr_get(struct ifaltq *, struct oldtb_profile *);
int	altq_pfattach(struct pf_altq *);

int	altq_pfdetach(struct pf_altq *);
int	altq_add(struct pf_altq *);
int	altq_remove(struct pf_altq *);
int	altq_add_queue(struct pf_altq *);
int	altq_remove_queue(struct pf_altq *);
int	altq_getqstats(struct pf_altq *, void *, int *);

int	cbq_pfattach(struct pf_altq *);
int	cbq_add_altq(struct pf_altq *);
int	cbq_remove_altq(struct pf_altq *);
int	cbq_add_queue(struct pf_altq *);
int	cbq_remove_queue(struct pf_altq *);
int	cbq_getqstats(struct pf_altq *, void *, int *);

int	priq_pfattach(struct pf_altq *);
int	priq_add_altq(struct pf_altq *);
int	priq_remove_altq(struct pf_altq *);
int	priq_add_queue(struct pf_altq *);
int	priq_remove_queue(struct pf_altq *);
int	priq_getqstats(struct pf_altq *, void *, int *);

int	hfsc_pfattach(struct pf_altq *);
int	hfsc_add_altq(struct pf_altq *);
int	hfsc_remove_altq(struct pf_altq *);
int	hfsc_add_queue(struct pf_altq *);
int	hfsc_remove_queue(struct pf_altq *);
int	hfsc_getqstats(struct pf_altq *, void *, int *);

#endif /* _KERNEL */
#endif /* _ALTQ_ALTQ_VAR_H_ */
@


1.17
log
@rename some vars and functions
unfortunately altq is one giant namespace violation. rename just those that
conflict with new stuff for now only to be found on my laptop. reduce pain,
the diff is huge already. ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.15 2008/04/20 07:05:52 deraadt Exp $	*/
@


1.16
log
@g/c code to read/write the dscp field. with pf as classifier altq has no
business in mucking with it and since the _CLEARDSCP flags were never
possibly set that is effectively dead code
@
text
@d102 2
a103 2
int	tbr_set(struct ifaltq *, struct tb_profile *);
int	tbr_get(struct ifaltq *, struct tb_profile *);
@


1.15
log
@Do not use random(), which is supposed to be a scheduler-only API (we
should rename it one day).  Furthermore, do not do random() % value,
but instead solve both problems using arc4random_uniform()
Problem spotted by drahn, fix ok'd by djm
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.14 2004/04/27 02:56:20 kjc Exp $	*/
a99 1
u_int8_t read_dsfield(struct mbuf *, struct altq_pktattr *);
@


1.14
log
@make separate functions to enable/disable altq, and call them when we
reload rules.
this fixes an altq problem that, if you reload pf rules not containing
queues while running altq, the interface shaper is not properly removed.

make pf_altq_running local to pf_ioctl.c since it is no longer used in
altq_subr.c.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.13 2004/01/14 08:42:23 kjc Exp $	*/
d37 1
@


1.13
log
@eliminate the predefined special qids so that qids become simple
identifiers without embedded meanings.

this also allows us to make the semantics of the qid assignment in line
with the tag assignment in the next step.

ok, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.12 2003/03/27 17:51:11 henning Exp $	*/
a93 2

extern int pfaltq_running;
@


1.12
log
@double ;
Patrick Latifi, Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.11 2002/12/18 00:15:21 henning Exp $	*/
d100 1
a100 1
void *altq_lookup(char *, int);
d102 4
a105 4
void write_dsfield(struct mbuf *, struct altq_pktattr *, u_int8_t);
void altq_assert(const char *, int, const char *);
int tbr_set(struct ifaltq *, struct tb_profile *);
int tbr_get(struct ifaltq *, struct tb_profile *);
d107 1
@


1.11
log
@enable PRIQ and HFSC if ALTQ itself is enabled.

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.10 2002/12/16 09:18:06 kjc Exp $	*/
d97 1
a97 1
struct ifnet; struct mbuf;;
@


1.10
log
@switchover to pf-based altq.
 - remove files which are no longer used, or we don't have plans to support
   in pf in the near future.
 - remove altq ioctl related stuff.
 - convert the PRIQ, HFSC and RIO modules to pf-based altq.
   (these are not enabled in GENERIC, CDNR is not converted yet.)
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.9 2002/11/29 07:51:54 kjc Exp $	*/
d43 6
@


1.9
log
@convert read_machclk() from a macro to a real function and
avoid kernel-rebuild with ALTQ_NOPCC for non-pentium users.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.8 2002/11/26 03:44:53 kjc Exp $	*/
a45 61
 * filter structure for altq common classifier
 */
struct acc_filter {
	LIST_ENTRY(acc_filter)	f_chain;
	void			*f_class;	/* pointer to the class */
	u_long			f_handle;	/* filter id */
	u_int32_t		f_fbmask;	/* filter bitmask */
	struct flow_filter	f_filter;	/* filter value */
};

/*
 * XXX ACC_FILTER_TABLESIZE can't be larger than 2048 unless we fix
 * the handle assignment.
 */
#define	ACC_FILTER_TABLESIZE	(256+1)
#define	ACC_FILTER_MASK		(ACC_FILTER_TABLESIZE - 2)
#define	ACC_WILDCARD_INDEX	(ACC_FILTER_TABLESIZE - 1)
#ifdef __GNUC__
#define	ACC_GET_HASH_INDEX(addr) \
	({int x = (addr) + ((addr) >> 16); (x + (x >> 8)) & ACC_FILTER_MASK;})
#else
#define	ACC_GET_HASH_INDEX(addr) \
	(((addr) + ((addr) >> 8) + ((addr) >> 16) + ((addr) >> 24)) \
	& ACC_FILTER_MASK)
#endif
#define	ACC_GET_HINDEX(handle) ((handle) >> 20)

struct acc_classifier {
	u_int32_t			acc_fbmask;
	LIST_HEAD(filt, acc_filter)	acc_filters[ACC_FILTER_TABLESIZE];
};

/*
 * flowinfo mask bits used by classifier
 */
/* for ipv4 */
#define	FIMB4_PROTO	0x0001
#define	FIMB4_TOS	0x0002
#define	FIMB4_DADDR	0x0004
#define	FIMB4_SADDR	0x0008
#define	FIMB4_DPORT	0x0010
#define	FIMB4_SPORT	0x0020
#define	FIMB4_GPI	0x0040
#define	FIMB4_ALL	0x007f
/* for ipv6 */
#define	FIMB6_PROTO	0x0100
#define	FIMB6_TCLASS	0x0200
#define	FIMB6_DADDR	0x0400
#define	FIMB6_SADDR	0x0800
#define	FIMB6_DPORT	0x1000
#define	FIMB6_SPORT	0x2000
#define	FIMB6_GPI	0x4000
#define	FIMB6_FLABEL	0x8000
#define	FIMB6_ALL	0xff00

#define	FIMB_ALL	(FIMB4_ALL|FIMB6_ALL)

#define	FIMB4_PORTS	(FIMB4_DPORT|FIMB4_SPORT|FIMB4_GPI)
#define	FIMB6_PORTS	(FIMB6_DPORT|FIMB6_SPORT|FIMB6_GPI)

/*
a70 23
/* ioctl cmd type */
#if defined(__FreeBSD__) && (__FreeBSD__ < 3)
typedef int ioctlcmd_t;
#else
typedef u_long ioctlcmd_t;
#endif

/*
 * queue macros:
 * the interface of TAILQ_LAST macro changed after the introduction
 * of softupdate. redefine it here to make it work with pre-2.2.7.
 */
#undef TAILQ_LAST
#define	TAILQ_LAST(head, headname) \
	(*(((struct headname *)((head)->tqh_last))->tqh_last))

#ifndef TAILQ_EMPTY
#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)
#endif
#ifndef TAILQ_FOREACH
#define TAILQ_FOREACH(var, head, field)					\
	for (var = TAILQ_FIRST(head); var; var = TAILQ_NEXT(var, field))
#endif
a72 11
#if (__FreeBSD_version > 300000) || defined(__NetBSD__)
/* use callout */
#include <sys/callout.h>

#define	CALLOUT_INIT(c)		callout_init((c))
#define	CALLOUT_RESET(c,t,f,a)	callout_reset((c),(t),(f),(a))
#define	CALLOUT_STOP(c)		callout_stop((c))
#ifndef CALLOUT_INITIALIZER
#define	CALLOUT_INITIALIZER	{ { { NULL } }, 0, NULL, NULL, 0 }
#endif
#elif defined(__OpenBSD__)
d84 1
a84 15
#else
/* use old-style timeout/untimeout */
/* dummy callout structure */
struct callout {
	void		*c_arg;			/* function argument */
	void		(*c_func)(void *);	/* function to call */
};
#define	CALLOUT_INIT(c)		do { bzero((c), sizeof(*(c))); } while (0)
#define	CALLOUT_RESET(c,t,f,a)	do {	(c)->c_arg = (a);	\
					(c)->c_func = (f);	\
					timeout((f),(a),(t)); } while (0)
#define	CALLOUT_STOP(c)		untimeout((c)->c_func,(c)->c_arg)
#define	CALLOUT_INITIALIZER	{ NULL, NULL }
#endif
#if !defined(__FreeBSD__)
a85 1
#endif
a88 3
/* define a macro to check pf/altq until the transition is complete */
#define	PFALTQ_IS_ACTIVE()	(!TAILQ_EMPTY(pf_altqs_active))

d91 1
a91 1
struct ifnet; struct mbuf; struct flowinfo;
a94 6
int altq_extractflow(struct mbuf *, int, struct flowinfo *, u_int32_t);
int acc_add_filter(struct acc_classifier *, struct flow_filter *,
			   void *, u_long *);
int acc_delete_filter(struct acc_classifier *, u_long);
int acc_discard_filters(struct acc_classifier *, void *, int);
void *acc_classify(void *, struct mbuf *, int);
d114 14
@


1.8
log
@fix "pfctl -Fq".
after altq gets flushed, altq forgot that it was enabled since
altq is actually detached with an empty ruleset.
so, add a variable, pfaltq_running, to remember the running state
and re-enable altq when a new ruleset is loaded.

noticed, tested, and oked by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.7 2002/10/11 09:30:30 kjc Exp $	*/
d110 1
a113 24

#if defined(__i386__) && !defined(I586_CPU) && !defined(I686_CPU)
#ifndef ALTQ_NOPCC
#define	ALTQ_NOPCC	/* TSC is not available, ALTQ_NOPCC needed */
#endif
#endif

#if defined(__i386__) && !defined(ALTQ_NOPCC)
/* for pentium tsc */
#include <machine/cpufunc.h>

#define	read_machclk()		rdtsc()
#ifdef __OpenBSD__
static __inline u_int64_t
rdtsc(void)
{
	u_int64_t rv;
	__asm __volatile(".byte 0x0f, 0x31" : "=A" (rv));
	return (rv);
}
#endif /* __OpenBSD__ */

#elif defined(__alpha__) && !defined(ALTQ_NOPCC)
/* for alpha rpcc */
a114 13

#else /* !i386 && !alpha */
/* emulate 256MHz using microtime() */
#define	MACHCLK_SHIFT	8
static __inline u_int64_t
read_machclk(void)
{
	struct timeval tv;
	microtime(&tv);
	return (((u_int64_t)(tv.tv_sec - boottime.tv_sec) * 1000000
		 + tv.tv_usec) << MACHCLK_SHIFT);
}
#endif /* !i386 && !alpha */
@


1.7
log
@make CBQ aware of the pf API so that pf developers can play with CBQ.

for now, implemnet a tentative transition mechanism to allow the old API
and the new API to coexit.
the old API will go away when pfctl(8) becomes ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.6 2002/10/08 05:12:08 kjc Exp $	*/
d237 2
@


1.6
log
@the first step of pf/altq merge.
this commit is to allow further development in both userland and kernel.

the goal is to replace altq's classifier by pf(4).
- make pf tag a queue id to mbuf and make altq read the queue id
- merge altq config into pf.conf(5)

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.5 2002/05/31 09:44:53 kjc Exp $	*/
d235 3
d260 7
@


1.5
log
@define ALTQ_NOPCC if i386 and !I586_CPU and !I686_CPU.
otherwise, kernel fails to compile.
pointed out and ok by fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.4 2002/03/15 01:20:03 millert Exp $	*/
d236 1
d250 7
@


1.4
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.3 2002/03/14 01:26:26 millert Exp $	*/
d113 6
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.2 2002/02/13 08:06:14 kjc Exp $	*/
d214 1
a214 1
	void		(*c_func)(void *);/* functiuon to call */
@


1.2
log
@move ALTQ_RED and ALTQ_CBQ from altq.h to altq_var.h.
protect them from duplicated defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d214 1
a214 1
	void		(*c_func) __P((void *));/* functiuon to call */
d231 12
a242 12
void *altq_lookup __P((char *, int));
int altq_extractflow __P((struct mbuf *, int, struct flowinfo *, u_int32_t));
int acc_add_filter __P((struct acc_classifier *, struct flow_filter *,
			   void *, u_long *));
int acc_delete_filter __P((struct acc_classifier *, u_long));
int acc_discard_filters __P((struct acc_classifier *, void *, int));
void *acc_classify __P((void *, struct mbuf *, int));
u_int8_t read_dsfield __P((struct mbuf *, struct altq_pktattr *));
void write_dsfield __P((struct mbuf *, struct altq_pktattr *, u_int8_t));
void altq_assert __P((const char *, int, const char *));
int tbr_set __P((struct ifaltq *, struct tb_profile *));
int tbr_get __P((struct ifaltq *, struct tb_profile *));
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 7
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
a37 7
#ifndef ALTQ_RED
#define ALTQ_RED		/* RED is enabled by default */
#endif
#ifndef ALTQ_CBQ
#define ALTQ_CBQ		/* CBQ is enabled by default */
#endif

a106 6
#if defined(__i386__) && !defined(I586_CPU) && !defined(I686_CPU)
#ifndef ALTQ_NOPCC
#define	ALTQ_NOPCC	/* TSC is not available, ALTQ_NOPCC needed */
#endif
#endif

d207 1
a207 1
	void		(*c_func)(void *);	/* function to call */
d224 12
a235 12
void *altq_lookup(char *, int);
int altq_extractflow(struct mbuf *, int, struct flowinfo *, u_int32_t);
int acc_add_filter(struct acc_classifier *, struct flow_filter *,
			   void *, u_long *);
int acc_delete_filter(struct acc_classifier *, u_long);
int acc_discard_filters(struct acc_classifier *, void *, int);
void *acc_classify(void *, struct mbuf *, int);
u_int8_t read_dsfield(struct mbuf *, struct altq_pktattr *);
void write_dsfield(struct mbuf *, struct altq_pktattr *, u_int8_t);
void altq_assert(const char *, int, const char *);
int tbr_set(struct ifaltq *, struct tb_profile *);
int tbr_get(struct ifaltq *, struct tb_profile *);
@


1.1.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.1.6.1 2002/06/11 03:27:42 art Exp $	*/
a234 3
/* define a macro to check pf/altq until the transition is complete */
#define	PFALTQ_IS_ACTIVE()	(!TAILQ_EMPTY(pf_altqs_active))

a235 1
struct pf_altq; struct pf_qstats;
a248 14
int	altq_pfattach(struct pf_altq *);
int	altq_pfdetach(struct pf_altq *);
int	altq_add(struct pf_altq *);
int	altq_remove(struct pf_altq *);
int	altq_add_queue(struct pf_altq *);
int	altq_remove_queue(struct pf_altq *);
int	altq_getqstats(struct pf_altq *, void *, int *);

int	cbq_pfattach(struct pf_altq *);
int	cbq_add_altq(struct pf_altq *);
int	cbq_remove_altq(struct pf_altq *);
int	cbq_add_queue(struct pf_altq *);
int	cbq_remove_queue(struct pf_altq *);
int	cbq_getqstats(struct pf_altq *, void *, int *);
@


1.1.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 26
a69 5
#ifndef ALTQ_PRIQ
#define ALTQ_PRIQ		/* PRIQ is enabled by default */
#endif
#ifndef ALTQ_HFSC
#define ALTQ_HFSC		/* HFSC is enabled by default */
d71 34
a109 1
extern int machclk_usepcc;
d113 24
d139 13
d168 23
d193 11
d215 15
a229 1

d231 1
d235 2
a236 1
extern int pfaltq_running;
d238 1
a238 1
struct ifnet; struct mbuf;
d242 6
a266 14

int	priq_pfattach(struct pf_altq *);
int	priq_add_altq(struct pf_altq *);
int	priq_remove_altq(struct pf_altq *);
int	priq_add_queue(struct pf_altq *);
int	priq_remove_queue(struct pf_altq *);
int	priq_getqstats(struct pf_altq *, void *, int *);

int	hfsc_pfattach(struct pf_altq *);
int	hfsc_add_altq(struct pf_altq *);
int	hfsc_remove_altq(struct pf_altq *);
int	hfsc_add_queue(struct pf_altq *);
int	hfsc_remove_queue(struct pf_altq *);
int	hfsc_getqstats(struct pf_altq *, void *, int *);
@


1.1.2.1
log
@Merge in trunk
@
text
@a37 7
#ifndef ALTQ_RED
#define ALTQ_RED		/* RED is enabled by default */
#endif
#ifndef ALTQ_CBQ
#define ALTQ_CBQ		/* CBQ is enabled by default */
#endif

@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d214 1
a214 1
	void		(*c_func)(void *);	/* function to call */
d231 12
a242 12
void *altq_lookup(char *, int);
int altq_extractflow(struct mbuf *, int, struct flowinfo *, u_int32_t);
int acc_add_filter(struct acc_classifier *, struct flow_filter *,
			   void *, u_long *);
int acc_delete_filter(struct acc_classifier *, u_long);
int acc_discard_filters(struct acc_classifier *, void *, int);
void *acc_classify(void *, struct mbuf *, int);
u_int8_t read_dsfield(struct mbuf *, struct altq_pktattr *);
void write_dsfield(struct mbuf *, struct altq_pktattr *, u_int8_t);
void altq_assert(const char *, int, const char *);
int tbr_set(struct ifaltq *, struct tb_profile *);
int tbr_get(struct ifaltq *, struct tb_profile *);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d44 26
a69 5
#ifndef ALTQ_PRIQ
#define ALTQ_PRIQ		/* PRIQ is enabled by default */
#endif
#ifndef ALTQ_HFSC
#define ALTQ_HFSC		/* HFSC is enabled by default */
d71 34
a109 1
extern int machclk_usepcc;
d113 18
d133 13
d162 23
d187 11
d209 15
a223 1

d225 1
d229 1
a229 4
extern int pfaltq_running;

struct ifnet; struct mbuf;;
struct pf_altq; struct pf_qstats;
d232 6
a242 28
int	altq_pfattach(struct pf_altq *);
int	altq_pfdetach(struct pf_altq *);
int	altq_add(struct pf_altq *);
int	altq_remove(struct pf_altq *);
int	altq_add_queue(struct pf_altq *);
int	altq_remove_queue(struct pf_altq *);
int	altq_getqstats(struct pf_altq *, void *, int *);

int	cbq_pfattach(struct pf_altq *);
int	cbq_add_altq(struct pf_altq *);
int	cbq_remove_altq(struct pf_altq *);
int	cbq_add_queue(struct pf_altq *);
int	cbq_remove_queue(struct pf_altq *);
int	cbq_getqstats(struct pf_altq *, void *, int *);

int	priq_pfattach(struct pf_altq *);
int	priq_add_altq(struct pf_altq *);
int	priq_remove_altq(struct pf_altq *);
int	priq_add_queue(struct pf_altq *);
int	priq_remove_queue(struct pf_altq *);
int	priq_getqstats(struct pf_altq *, void *, int *);

int	hfsc_pfattach(struct pf_altq *);
int	hfsc_add_altq(struct pf_altq *);
int	hfsc_remove_altq(struct pf_altq *);
int	hfsc_add_queue(struct pf_altq *);
int	hfsc_remove_queue(struct pf_altq *);
int	hfsc_getqstats(struct pf_altq *, void *, int *);
@


1.1.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_var.h,v 1.1.2.3 2003/03/27 22:28:25 niklas Exp $	*/
d97 1
a97 1
struct ifnet; struct mbuf;
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
void	*altq_lookup(char *, int);
d102 4
a105 4
void	write_dsfield(struct mbuf *, struct altq_pktattr *, u_int8_t);
void	altq_assert(const char *, int, const char *);
int	tbr_set(struct ifaltq *, struct tb_profile *);
int	tbr_get(struct ifaltq *, struct tb_profile *);
a106 1

@


1.1.2.6
log
@Merge with the trunk
@
text
@d95 2
@


