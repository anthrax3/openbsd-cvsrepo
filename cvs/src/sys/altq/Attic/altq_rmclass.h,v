head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.10
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.8
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.4
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.14
date	2014.04.19.16.08.14;	author henning;	state dead;
branches;
next	1.13;

1.13
date	2011.07.04.01.07.43;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.03.23.48.41;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.27.01.37.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.17.19.58.58;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.20.12.33.17;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.16.17.27.20;	author henning;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.26.01.03.34;	author henning;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.15.50;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.13.08.07.57;	author kjc;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.27.05.28.36;	author kjc;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.11.26.45;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.27.22.28.25;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.02.19.10.51.22;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.27.42;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.21.50.54;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@bye bye
@
text
@/*	$OpenBSD: altq_rmclass.h,v 1.13 2011/07/04 01:07:43 henning Exp $	*/
/*	$KAME: altq_rmclass.h,v 1.6 2000/12/09 09:22:44 kjc Exp $	*/

/*
 * Copyright (c) 1991-1997 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Network Research
 *	Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _ALTQ_ALTQ_RMCLASS_H_
#define	_ALTQ_ALTQ_RMCLASS_H_

#include <altq/altq_classq.h>

#ifdef __cplusplus
extern "C" {
#endif

#define	RM_MAXPRIO	8	/* Max priority */

#ifdef _KERNEL

typedef struct mbuf		mbuf_t;
typedef struct rm_ifdat		rm_ifdat_t;
typedef struct rm_class		rm_class_t;

struct red;

/*
 * Macros for dealing with time values.  We assume all times are
 * 'timevals'.  `microtime' is used to get the best available clock
 * resolution.  If `microtime' *doesn't* return a value that's about
 * ten times smaller than the average packet time on the fastest
 * link that will use these routines, a slightly different clock
 * scheme than this one should be used.
 * (Bias due to truncation error in this scheme will overestimate utilization
 * and discriminate against high bandwidth classes.  To remove this bias an
 * integrator needs to be added.  The simplest integrator uses a history of
 * 10 * avg.packet.time / min.tick.time packet completion entries.  This is
 * straight forward to add but we don't want to pay the extra memory
 * traffic to maintain it if it's not necessary (occasionally a vendor
 * accidentally builds a workstation with a decent clock - e.g., Sun & HP).)
 */

#define	RM_GETTIME(now) microtime(&now)

#define	TV_LT(a, b) (((a)->tv_sec < (b)->tv_sec) ||  \
	(((a)->tv_usec < (b)->tv_usec) && ((a)->tv_sec <= (b)->tv_sec)))

#define	TV_DELTA(a, b, delta) { \
	int	xxs;	\
							\
	delta = (a)->tv_usec - (b)->tv_usec; \
	if ((xxs = (a)->tv_sec - (b)->tv_sec)) { \
		switch (xxs) { \
		default: \
			/* if (xxs < 0) \
				printf("rm_class: bogus time values\n"); */ \
			delta = 0; \
			/* FALLTHROUGH */ \
		case 2: \
			delta += 1000000; \
			/* FALLTHROUGH */ \
		case 1: \
			delta += 1000000; \
			break; \
		} \
	} \
}

#define	TV_ADD_DELTA(a, delta, res) { \
	int xxus = (a)->tv_usec + (delta); \
	\
	(res)->tv_sec = (a)->tv_sec; \
	while (xxus >= 1000000) { \
		++((res)->tv_sec); \
		xxus -= 1000000; \
	} \
	(res)->tv_usec = xxus; \
}

#define	RM_TIMEOUT	2	/* 1 Clock tick. */

#if 1
#define	RM_MAXQUEUED	1	/* this isn't used in ALTQ/CBQ */
#else
#define	RM_MAXQUEUED	16	/* Max number of packets downstream of CBQ */
#endif
#define	RM_MAXQUEUE	64	/* Max queue length */
#define	RM_FILTER_GAIN	5	/* log2 of gain, e.g., 5 => 31/32 */
#define	RM_POWER	(1 << RM_FILTER_GAIN)
#define	RM_MAXDEPTH	32
#define	RM_NS_PER_SEC	(1000000000)

typedef struct _rm_class_stats_ {
	u_int		handle;
	u_int		depth;

	struct pktcntr	xmit_cnt;	/* packets sent in this class */
	struct pktcntr	drop_cnt;	/* dropped packets */
	u_int		over;		/* # times went over limit */
	u_int		borrows;	/* # times tried to borrow */
	u_int		overactions;	/* # times invoked overlimit action */
	u_int		delays;		/* # times invoked delay actions */
} rm_class_stats_t;

/*
 * CBQ Class state structure
 */
struct rm_class {
	class_queue_t	*q_;		/* Queue of packets */
	rm_ifdat_t	*ifdat_;
	int		pri_;		/* Class priority. */
	int		depth_;		/* Class depth */
	u_int		ns_per_byte_;	/* NanoSeconds per byte. */
	u_int		maxrate_;	/* Bytes per second for this class. */
	u_int		allotment_;	/* Fraction of link bandwidth. */
	u_int		w_allotment_;	/* Weighted allotment for WRR */
	int		bytes_alloc_;	/* Allocation for round of WRR */

	int		avgidle_;
	int		maxidle_;
	int		minidle_;
	int		offtime_;
	int		sleeping_;	/* != 0 if delaying */
	int		qthresh_;	/* Queue threshold for formal link sharing */
	int		leaf_;		/* Note whether leaf class or not.*/

	rm_class_t	*children_;	/* Children of this class */
	rm_class_t	*next_;		/* Next pointer, used if child */

	rm_class_t	*peer_;		/* Peer class */
	rm_class_t	*borrow_;	/* Borrow class */
	rm_class_t	*parent_;	/* Parent class */

	void	(*overlimit)(struct rm_class *, struct rm_class *);
	void	(*drop)(struct rm_class *);       /* Class drop action. */

	struct red	*red_;		/* RED state pointer */
	struct altq_pktattr *pktattr_;	/* saved hdr used by RED/ECN */
	int		flags_;

	int		last_pkttime_;	/* saved pkt_time */
	struct timeval	undertime_;	/* time can next send */
	struct timeval	last_;		/* time last packet sent */
	struct timeval	overtime_;
	struct callout	callout_;	/* for timeout() calls */

	rm_class_stats_t stats_;	/* Class Statistics */
};

/*
 * CBQ Interface state
 */
struct rm_ifdat {
	int		queued_;	/* # pkts queued downstream */
	int		wrr_;		/* Enable Weighted Round-Robin */
	u_long		ns_per_byte_;	/* Link byte speed. */
	int		maxqueued_;	/* Max packets to queue */
	int		maxpkt_;	/* Max packet size. */
	int		qi_;		/* In/out pointers for downstream */
	int		qo_;		/* packets */

	/*
	 * Active class state and WRR state.
	 */
	rm_class_t	*active_[RM_MAXPRIO];	/* Active cl's in each pri */
	int		na_[RM_MAXPRIO];	/* # of active cl's in a pri */
	int		num_[RM_MAXPRIO];	/* # of cl's per pri */
	int		alloc_[RM_MAXPRIO];	/* Byte Allocation */
	u_long		M_[RM_MAXPRIO];		/* WRR weights. */

	/*
	 * Network Interface/Solaris Queue state pointer.
	 */
	struct ifaltq	*ifq_;
	rm_class_t	*default_;	/* Default Pkt class, BE */
	rm_class_t	*root_;		/* Root Link class. */
	rm_class_t	*ctl_;		/* Control Traffic class. */
	void		(*restart)(struct ifaltq *);	/* Restart routine. */

	/*
	 * Current packet downstream packet state and dynamic state.
	 */
	rm_class_t	*borrowed_[RM_MAXQUEUED]; /* Class borrowed last */
	rm_class_t	*class_[RM_MAXQUEUED];	/* class sending */
	int		curlen_[RM_MAXQUEUED];	/* Current pktlen */
	struct timeval	now_[RM_MAXQUEUED];	/* Current packet time. */
	int		is_overlimit_[RM_MAXQUEUED];/* Current packet time. */

	int		cutoff_;	/* Cut-off depth for borrowing */

	struct timeval	ifnow_;		/* expected xmit completion time */
#if 1 /* ALTQ4PPP */
	int		maxiftime_;	/* max delay inside interface */
#endif
        rm_class_t	*pollcache_;	/* cached rm_class by poll operation */
};

/* flags for rmc_init and rmc_newclass */
/* class flags */
#define	RMCF_RED		0x0001
#define	RMCF_ECN		0x0002
#define	RMCF_RIO		0x0004

/* flags for rmc_init */
#define	RMCF_WRR		0x0100
#define	RMCF_EFFICIENT		0x0200

#define	is_a_parent_class(cl)	((cl)->children_ != NULL)

extern rm_class_t *rmc_newclass(int, struct rm_ifdat *, u_int,
				     void (*)(struct rm_class *,
					      struct rm_class *),
				     int, struct rm_class *, struct rm_class *,
				     u_int, int, u_int, int, int);
extern void	rmc_delete_class(struct rm_ifdat *, struct rm_class *);
extern int	rmc_modclass(struct rm_class *, u_int, int,
				  u_int, int, u_int, int);
extern void	rmc_init(struct ifaltq *, struct rm_ifdat *, u_int,
			      void (*)(struct ifaltq *),
			      int, int, u_int, int, u_int, int);
extern int	rmc_queue_packet(struct rm_class *, mbuf_t *);
extern mbuf_t	*rmc_dequeue_next(struct rm_ifdat *, int);
extern void	rmc_update_class_util(struct rm_ifdat *);
extern void	rmc_delay_action(struct rm_class *, struct rm_class *);
extern void	rmc_dropall(struct rm_class *);
extern int	rmc_get_weight(struct rm_ifdat *, int);

#endif /* _KERNEL */

#ifdef __cplusplus
}
#endif

#endif /* _ALTQ_ALTQ_RMCLASS_H_ */
@


1.13
log
@rip out more effectively dead code, ryan ok
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.12 2011/07/03 23:48:41 henning Exp $	*/
@


1.12
log
@g/c code to read/write the dscp field. with pf as classifier altq has no
business in mucking with it and since the _CLEARDSCP flags were never
possibly set that is effectively dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.11 2008/08/27 01:37:16 deraadt Exp $	*/
a183 1
	int		efficient_;	/* Link Efficiency bit */
a231 1
#define	RMCF_FLOWVALVE		0x0008	/* use flowvalve (aka penalty-box) */
@


1.11
log
@delete unused pragma ident junk
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.10 2007/06/17 19:58:58 jasper Exp $	*/
a233 1
#define	RMCF_CLEARDSCP		0x0010  /* clear diffserv codepoint */
@


1.10
log
@de-register

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.9 2007/02/14 00:53:47 jsg Exp $	*/
a40 2

/* #pragma ident "@@(#)rm_class.h  1.20     97/10/23 SMI" */
@


1.9
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.8 2003/08/22 21:50:34 david Exp $	*/
d80 1
a80 1
	register int	xxs;	\
d101 1
a101 1
	register int xxus = (a)->tv_usec + (delta); \
@


1.8
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.7 2003/08/20 12:33:17 henning Exp $	*/
d89 1
a89 1
			/* fall through */ \
d92 1
a92 1
			/* fall through */ \
@


1.7
log
@move the #define RM_MAXPRIO out of #ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.6 2002/12/16 17:27:20 henning Exp $	*/
d186 1
a186 1
	int		efficient_;	/* Link Efficency bit */
@


1.6
log
@major KNF, Take 2

ok kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.5 2002/11/26 01:03:34 henning Exp $	*/
d48 2
a117 1
#define	RM_MAXPRIO	8	/* Max priority */
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.4 2002/03/14 03:15:50 millert Exp $	*/
d175 1
a175 1
	struct callout	callout_; 	/* for timeout() calls */
d249 1
a249 1
extern int 	rmc_modclass(struct rm_class *, u_int, int,
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.3 2002/03/14 01:26:26 millert Exp $	*/
d140 1
a140 1
	rm_ifdat_t	*ifdat_;			
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.2 2002/02/13 08:07:57 kjc Exp $	*/
d243 1
a243 1
extern rm_class_t *rmc_newclass __P((int, struct rm_ifdat *, u_int,
d247 1
a247 1
				     u_int, int, u_int, int, int));
d251 1
a251 1
extern void	rmc_init __P((struct ifaltq *, struct rm_ifdat *, u_int,
d253 1
a253 1
			      int, int, u_int, int, u_int, int));
@


1.2
log
@sync with KAME.
comment out the warning message for the clock going backwards
in the TV_DELTA macro.
it happens when the clock is adjusted and gives me more trouble
than help.
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d248 3
a250 3
extern void	rmc_delete_class __P((struct rm_ifdat *, struct rm_class *));
extern int 	rmc_modclass __P((struct rm_class *, u_int, int,
				  u_int, int, u_int, int));
d254 6
a259 6
extern int	rmc_queue_packet __P((struct rm_class *, mbuf_t *));
extern mbuf_t	*rmc_dequeue_next __P((struct rm_ifdat *, int));
extern void	rmc_update_class_util __P((struct rm_ifdat *));
extern void	rmc_delay_action __P((struct rm_class *, struct rm_class *));
extern void	rmc_dropall __P((struct rm_class *));
extern int	rmc_get_weight __P((struct rm_ifdat *, int));
@


1.1
log
@import ALTQ, alternate queueing support, from KAME.
ALTQ allows to switch various queueing disciplines on output network
interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
a85 2
			if (xxs < 0) \
				printf("rm_class: bogus time values\n"); \
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: altq_rmclass.h,v 1.1 2001/06/27 05:28:36 kjc Exp $	*/
d84 2
a85 2
			/* if (xxs < 0) \
				printf("rm_class: bogus time values\n"); */ \
d243 1
a243 1
extern rm_class_t *rmc_newclass(int, struct rm_ifdat *, u_int,
d247 5
a251 5
				     u_int, int, u_int, int, int);
extern void	rmc_delete_class(struct rm_ifdat *, struct rm_class *);
extern int 	rmc_modclass(struct rm_class *, u_int, int,
				  u_int, int, u_int, int);
extern void	rmc_init(struct ifaltq *, struct rm_ifdat *, u_int,
d253 7
a259 7
			      int, int, u_int, int, u_int, int);
extern int	rmc_queue_packet(struct rm_class *, mbuf_t *);
extern mbuf_t	*rmc_dequeue_next(struct rm_ifdat *, int);
extern void	rmc_update_class_util(struct rm_ifdat *);
extern void	rmc_delay_action(struct rm_class *, struct rm_class *);
extern void	rmc_dropall(struct rm_class *);
extern int	rmc_get_weight(struct rm_ifdat *, int);
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 1
a140 1
	rm_ifdat_t	*ifdat_;
d175 1
a175 1
	struct callout	callout_;	/* for timeout() calls */
d249 1
a249 1
extern int	rmc_modclass(struct rm_class *, u_int, int,
@


1.1.2.1
log
@Merge in trunk
@
text
@d84 2
a85 2
			/* if (xxs < 0) \
				printf("rm_class: bogus time values\n"); */ \
@


1.1.2.2
log
@Merge in -current from about a week ago
@
text
@d243 1
a243 1
extern rm_class_t *rmc_newclass(int, struct rm_ifdat *, u_int,
d247 5
a251 5
				     u_int, int, u_int, int, int);
extern void	rmc_delete_class(struct rm_ifdat *, struct rm_class *);
extern int 	rmc_modclass(struct rm_class *, u_int, int,
				  u_int, int, u_int, int);
extern void	rmc_init(struct ifaltq *, struct rm_ifdat *, u_int,
d253 7
a259 7
			      int, int, u_int, int, u_int, int);
extern int	rmc_queue_packet(struct rm_class *, mbuf_t *);
extern mbuf_t	*rmc_dequeue_next(struct rm_ifdat *, int);
extern void	rmc_update_class_util(struct rm_ifdat *);
extern void	rmc_delay_action(struct rm_class *, struct rm_class *);
extern void	rmc_dropall(struct rm_class *);
extern int	rmc_get_weight(struct rm_ifdat *, int);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d140 1
a140 1
	rm_ifdat_t	*ifdat_;
d175 1
a175 1
	struct callout	callout_;	/* for timeout() calls */
d249 1
a249 1
extern int	rmc_modclass(struct rm_class *, u_int, int,
@


1.1.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a47 2
#define	RM_MAXPRIO	8	/* Max priority */

d116 1
d185 1
a185 1
	int		efficient_;	/* Link Efficiency bit */
@


