head	1.53;
access;
symbols
	OPENBSD_6_1:1.51.0.6
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.30
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.28
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.26
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.24
	OPENBSD_5_0:1.32.0.22
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.20
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.18
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.14
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.16
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.12
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.10
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.8
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.6
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.29.0.4
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.2
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.8
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.6
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.28
	UBC:1.24.0.4
	UBC_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.21.0.16
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.14
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.12
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.10
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.8
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.6
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.21.0.4
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.16.0.2
	OPENBSD_2_0_BASE:1.16
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.52;
commitid	PnZZkFEIj4rPydZo;

1.52
date	2017.05.27.16.08.23;	author claudio;	state Exp;
branches;
next	1.51;
commitid	BR1mjfoWYfRUrsEF;

1.51
date	2016.03.07.11.26.43;	author mpi;	state Exp;
branches;
next	1.50;
commitid	A6aWk73xtRBVWTBp;

1.50
date	2016.03.06.19.05.30;	author mpi;	state Exp;
branches;
next	1.49;
commitid	Ni38yK63LcOWb30h;

1.49
date	2016.03.01.21.32.02;	author mpi;	state Exp;
branches;
next	1.48;
commitid	8ue8rik6burb9L4V;

1.48
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.47;
commitid	CZXiyhU8oBcz6IpF;

1.47
date	2016.02.28.14.43.03;	author mpi;	state Exp;
branches;
next	1.46;
commitid	WSJUSipxDUoJ3kdy;

1.46
date	2016.02.27.13.17.47;	author mpi;	state Exp;
branches;
next	1.45;
commitid	RePOJ1nAmEf9Lu6X;

1.45
date	2016.02.26.15.27.53;	author mpi;	state Exp;
branches;
next	1.44;
commitid	XYYHoM9XmVPaXGlI;

1.44
date	2016.02.12.10.58.41;	author mpi;	state Exp;
branches;
next	1.43;
commitid	NKjRYS3Mbadvdn0J;

1.43
date	2016.01.27.10.37.12;	author mpi;	state Exp;
branches;
next	1.42;
commitid	Qlm598QQCEyskMtJ;

1.42
date	2016.01.27.08.03.37;	author mpi;	state Exp;
branches;
next	1.41;
commitid	K645DWxJ9sFrj85C;

1.41
date	2016.01.25.14.50.13;	author mpi;	state Exp;
branches;
next	1.40;
commitid	qgQo4LolnAJ3yid5;

1.40
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.39;
commitid	7AkssaZPPd7mA8h3;

1.39
date	2015.12.23.01.39.02;	author mmcc;	state Exp;
branches;
next	1.38;
commitid	KfRgvabVql7qYf97;

1.38
date	2015.08.12.06.19.25;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	laQtIfN3a82NKYjy;

1.37
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.36;
commitid	p4LJxGKbi0BU2cG6;

1.36
date	2014.12.21.16.27.08;	author mlarkin;	state Exp;
branches;
next	1.35;
commitid	dB4lAFOCpyuORTUm;

1.35
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.34;
commitid	uzzBR7hz9ncd4O6G;

1.34
date	2014.03.16.20.31.46;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.17.08.02.19;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.29.05.57.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.19.15.24.22;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.09.22.22.50;	author pefo;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.14.16.13.48;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.13.15.38.58;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.19.17.49.00;	author frantzen;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	2001.08.19.16.41.07;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.10.10.42.35;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.07.19.22.31.20;	author niklas;	state Exp;
branches
	1.21.12.1;
next	1.20;

1.20
date	97.07.06.23.09.25;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.05.29.03.28.44;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.02.07.07.03.40;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.02.07.06.18.48;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	96.08.23.19.53.48;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.08.16.10.12.37;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	96.08.16.06.13.02;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	96.08.13.00.41.34;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.08.04.01.27.46;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.05.31.10.37.25;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.05.20.13.30.07;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.13.58.44;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.05.05.12.23.18;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.19.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.30.04.51.28;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.11.11.16.23;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.13.35.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.02.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.08.03.04.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches;
next	;

1.21.12.1
date	2001.05.14.22.07.00;	author niklas;	state Exp;
branches;
next	1.21.12.2;

1.21.12.2
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.21.12.3;

1.21.12.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.21.12.4;

1.21.12.4
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	;

1.24.4.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@/*	$OpenBSD: db_sym.c,v 1.52 2017/05/27 16:08:23 claudio Exp $	*/
/*	$NetBSD: db_sym.c,v 1.24 2000/08/11 22:50:47 tv Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_lex.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>
#include <ddb/db_command.h>

extern char end[];

/*
 * Initialize the kernel debugger by initializing the master symbol
 * table.  Note that if initializing the master symbol table fails,
 * no other symbol tables can be loaded.
 */
void
ddb_init(void)
{
	const char *name = "bsd";
	extern char *esym;
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__) || \
    defined(__i386__)
	extern char *ssym;
#endif
	char *xssym, *xesym;

	xesym = esym;
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__) || \
    defined(__i386__)
	xssym = ssym;
#else
	xssym = (char *)&end;
#endif
	/*
	 * Do this check now for the master symbol table to avoid printing
	 * the message N times.
	 */
	if ((((vaddr_t)xssym) & (sizeof(long) - 1)) != 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, xssym);
		return;
	}

	if (xesym != NULL && xesym != xssym) {
		if (db_elf_sym_init((vaddr_t)xesym - (vaddr_t)xssym, xssym,
		    xesym, name) == 1)
			return;
	}

	printf("[ no symbol table formats found ]\n");
}

int
db_eqname(char *src, char *dst, int c)
{
	if (!strcmp(src, dst))
	    return (1);
	if (src[0] == c)
	    return (!strcmp(src+1,dst));
	return (0);
}

/*
 * Find the closest symbol to val, and return its name
 * and the difference between val and the symbol found.
 */
Elf_Sym *
db_search_symbol(db_addr_t val, db_strategy_t strategy, db_expr_t *offp)
{
	unsigned int	diff;
	db_expr_t	newdiff;
	Elf_Sym		*ret = NULL, *sym;

	newdiff = diff = ~0;
	sym = db_elf_sym_search(val, strategy, &newdiff);
	if (newdiff < diff) {
		diff = newdiff;
		ret = sym;
	}
	*offp = diff;
	return ret;
}

/*
 * Print a the closest symbol to value
 *
 * After matching the symbol according to the given strategy
 * we print it in the name+offset format, provided the symbol's
 * value is close enough (eg smaller than db_maxoff).
 * We also attempt to print [filename:linenum] when applicable
 * (eg for procedure names).
 *
 * If we could not find a reasonable name+offset representation,
 * then we just print the value in hex.  Small values might get
 * bogus symbol associations, e.g. 3 might get some absolute
 * value like _INCLUDE_VERSION or something, therefore we do
 * not accept symbols whose value is zero (and use plain hex).
 * Also, avoid printing as "end+0x????" which is useless.
 * The variable db_lastsym is used instead of "end" in case we
 * add support for symbols in loadable driver modules.
 */
unsigned long	db_lastsym = (unsigned long)end;
unsigned int	db_maxoff = 0x10000000;


void
db_printsym(db_expr_t off, db_strategy_t strategy,
    int (*pr)(const char *, ...))
{
	db_expr_t	d;
	char 		*filename;
	char		*name;
	db_expr_t	value;
	int 		linenum;
	Elf_Sym		*cursym;
	char		buf[DB_FORMAT_BUF_SIZE];

	if (off <= db_lastsym) {
		cursym = db_search_symbol(off, strategy, &d);
		db_symbol_values(cursym, &name, &value);
		if (name && (d < db_maxoff) && value) {
			(*pr)("%s", name);
			if (d) {
				(*pr)("+%s", db_format(buf, sizeof(buf),
				    d, DB_FORMAT_R, 1, 0));
			}
			if (strategy == DB_STGY_PROC) {
				if (db_elf_line_at_pc(cursym, &filename,
				    &linenum, off))
					(*pr)(" [%s:%d]", filename, linenum);
			}
			return;
		}
	}

	(*pr)("%s", db_format(buf, sizeof(buf), off, DB_FORMAT_N, 1, 0));
	return;
}
@


1.52
log
@Make ddb print again filename and linenumber if a bsd.gdb was loaded.
mpi@@ agrees that this is correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.51 2016/03/07 11:26:43 mpi Exp $	*/
d98 1
a98 1
db_sym_t
d103 1
a103 1
	db_sym_t	ret = NULL, sym;
d146 1
a146 1
	db_sym_t	cursym;
@


1.51
log
@boolean_t/FALSE/TRUE -> int/0/1
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.50 2016/03/06 19:05:30 mpi Exp $	*/
d158 1
a158 1
			if (strategy != DB_STGY_PROC) {
@


1.50
log
@Merge db_elf_sym_values() into db_symbol_values().

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.49 2016/03/01 21:32:02 mpi Exp $	*/
d77 1
a77 1
		    xesym, name) == TRUE)
d84 1
a84 1
boolean_t
d88 1
a88 1
	    return (TRUE);
d91 1
a91 1
	return (FALSE);
@


1.49
log
@Make db_value_of_name() call db_elf_sym_lookup() in order to kill
db_lookup() as requested by mlarkin@@

While here move the function to db_elf.c do keep db_elf_sym_lookup()
private.

ok mikeb@@ appart from the move the function
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.48 2016/03/01 11:56:00 mpi Exp $	*/
a113 20

/*
 * Return name and value of a symbol
 */
void
db_symbol_values(db_sym_t sym, char **namep, db_expr_t *valuep)
{
	db_expr_t	value;

	if (sym == NULL) {
		*namep = NULL;
		return;
	}

	db_elf_sym_values(sym, namep, &value);

	if (valuep)
		*valuep = value;
}

@


1.48
log
@DB_SYM_NULL -> NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.47 2016/02/28 14:43:03 mpi Exp $	*/
a91 22
}

boolean_t
db_value_of_name(char *name, db_expr_t *valuep)
{
	db_sym_t	sym;

	sym = db_lookup(name);
	if (sym == NULL)
	    return (FALSE);
	db_symbol_values(sym, &name, valuep);
	return (TRUE);
}


/*
 * Lookup a symbol.
 */
db_sym_t
db_lookup(char *symstr)
{
	return db_elf_sym_lookup(symstr);
@


1.47
log
@Remove leftovers from mutliple symbol tables support.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.46 2016/02/27 13:17:47 mpi Exp $	*/
d100 1
a100 1
	if (sym == DB_SYM_NULL)
d125 1
a125 1
	db_sym_t	ret = DB_SYM_NULL, sym;
d145 1
a145 1
	if (sym == DB_SYM_NULL) {
@


1.46
log
@Remove the "symbol table" argument of the functions dealing with
symbols.

There's no reason to ask the programmer to supply a specific symbol
table since the kernel only have one.

ok visa@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.45 2016/02/26 15:27:53 mpi Exp $	*/
a38 11

/*
 * Multiple symbol tables
 */
#ifndef MAXLKMS
#define MAXLKMS 20
#endif

#ifndef MAXNOSYMTABS
#define	MAXNOSYMTABS	MAXLKMS+1	/* Room for kernel + LKM's */
#endif
@


1.45
log
@Remove support for multiple symbol tables in ddb(4), we only have one.

ok mlarkin@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.44 2016/02/12 10:58:41 mpi Exp $	*/
a50 2
db_symtab_t	db_symtab;

a94 50
/*
 * Add symbol table, with given name, to list of symbol tables.
 */
int
db_add_symbol_table(char *start, char *end, const char *name, char *ref)
{
	db_symtab.start = start;
	db_symtab.end = end;
	db_symtab.name = name;
	db_symtab.private = ref;

	return 0;
}

/*
 * Delete a symbol table. Caller is responsible for freeing storage.
 */
void
db_del_symbol_table(char *name)
{
	db_symtab.start = 0;
	db_symtab.end = 0;
	db_symtab.name = 0;
	db_symtab.private = 0;
}

/*
 *  db_qualify("vm_map", "bsd") returns "bsd:vm_map".
 *
 *  Note: return value points to static data whose content is
 *  overwritten by each call... but in practice this seems okay.
 */
char *
db_qualify(db_sym_t sym, const char *symtabname)
{
	char		*symname;
	static char     tmp[256];
	char	*s;

	db_symbol_values(sym, &symname, 0);
	s = tmp;
	while ((*s++ = *symtabname++) != '\0')
		;
	s[-1] = ':';
	while ((*s++ = *symname++) != '\0')
		;
	return tmp;
}


d124 1
a124 1
	return db_elf_sym_lookup(&db_symtab, symstr);
d139 1
a139 1
	sym = db_elf_sym_search(&db_symtab, val, strategy, &newdiff);
d161 1
a161 1
	db_elf_sym_values(&db_symtab, sym, namep, &value);
d212 2
a213 2
				if (db_elf_line_at_pc(&db_symtab, cursym,
				    &filename, &linenum, off))
@


1.44
log
@Kill db_symbol_is_ambiguous().  There's no ambiguous symbol since LKMs
are no longer supported.

ok tb@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.43 2016/01/27 10:37:12 mpi Exp $	*/
d51 1
a51 3
db_symtab_t	db_symtabs[MAXNOSYMTABS] = {{0,},};

db_symtab_t	*db_last_symtab;
d103 4
a106 1
	int slot;
d108 1
a108 15
	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name == NULL)
			break;
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("No slots left for %s symbol table", name);
		return(-1);
	}

	db_symtabs[slot].start = start;
	db_symtabs[slot].end = end;
	db_symtabs[slot].name = name;
	db_symtabs[slot].private = ref;

	return(slot);
d117 4
a120 16
	int slot;

	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name &&
		    ! strcmp(db_symtabs[slot].name, name))
			break;
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("Unable to find symbol table slot for %s.", name);
		return;
	}

	db_symtabs[slot].start = 0;
	db_symtabs[slot].end = 0;
	db_symtabs[slot].name = 0;
	db_symtabs[slot].private = 0;
a171 3
 * If the symbol has a qualifier (e.g., ux:vm_map),
 * then only the specified symbol table will be searched;
 * otherwise, all symbol tables will be searched.
d176 1
a176 41
	db_sym_t sp;
	int i;
	int symtab_start = 0;
	int symtab_end = MAXNOSYMTABS;
	char *cp;

	/*
	 * Look for, remove, and remember any symbol table specifier.
	 */
	for (cp = symstr; *cp; cp++) {
		if (*cp == ':') {
			*cp = '\0';
			for (i = 0; i < MAXNOSYMTABS; i++) {
				if (db_symtabs[i].name &&
				    ! strcmp(symstr, db_symtabs[i].name)) {
					symtab_start = i;
					symtab_end = i + 1;
					break;
				}
			}
			*cp = ':';
			if (i == MAXNOSYMTABS) {
				db_error("invalid symbol table name");
				/*NOTREACHED*/
			}
			symstr = cp+1;
		}
	}

	/*
	 * Look in the specified set of symbol tables.
	 * Return on first match.
	 */
	for (i = symtab_start; i < symtab_end; i++) {
		if (db_symtabs[i].name &&
		    (sp = db_elf_sym_lookup(&db_symtabs[i], symstr))) {
			db_last_symtab = &db_symtabs[i];
			return sp;
		}
	}
	return 0;
a187 1
	int		i;
d191 2
a192 7
	db_last_symtab = NULL;
	for (i = 0; i < MAXNOSYMTABS; i++) {
	    if (!db_symtabs[i].name)
	        continue;
	    sym = db_elf_sym_search(&db_symtabs[i], val, strategy, &newdiff);
	    if (newdiff < diff) {
		db_last_symtab = &db_symtabs[i];
a194 1
	    }
d213 1
a213 1
	db_elf_sym_values(db_last_symtab, sym, namep, &value);
d264 1
a264 1
				if (db_elf_line_at_pc(db_last_symtab, cursym,
@


1.43
log
@Removes the abstraction layer to support multiple executable binaries.

Simplifies the API to manipulate symbols now that all our architectures
are ELF.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.42 2016/01/27 08:03:37 mpi Exp $	*/
a247 28
 * Does this symbol name appear in more than one symbol table?
 * Used by db_symbol_values to decide whether to qualify a symbol.
 */
boolean_t db_qualify_ambiguous_names = FALSE;

boolean_t
db_symbol_is_ambiguous(db_sym_t sym)
{
	char		*sym_name;
	int	i;
	boolean_t	found_once = FALSE;

	if (!db_qualify_ambiguous_names)
		return FALSE;

	db_symbol_values(sym, &sym_name, 0);
	for (i = 0; i < MAXNOSYMTABS; i++) {
		if (db_symtabs[i].name &&
		    db_elf_sym_lookup(&db_symtabs[i], sym_name)) {
			if (found_once)
				return TRUE;
			found_once = TRUE;
		}
	}
	return FALSE;
}

/*
a289 2
	if (db_symbol_is_ambiguous(sym))
		*namep = db_qualify(sym, db_last_symtab->name);
@


1.42
log
@Remove unused db_sifting().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.41 2016/01/25 14:50:13 mpi Exp $	*/
a57 21
 * Put the most picky symbol table formats at the top!
 */
const db_symformat_t *db_symformats[] = {
	&db_symformat_elf,
	NULL,
};

const db_symformat_t *db_symformat;

boolean_t	X_db_sym_init(int, void *, void *, const char *);
db_sym_t	X_db_lookup(db_symtab_t *, char *);
db_sym_t	X_db_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		X_db_symbol_values(db_symtab_t *, db_sym_t, char **,
		    db_expr_t *);
boolean_t	X_db_line_at_pc(db_symtab_t *, db_sym_t, char **,
		    int *, db_expr_t);
int		X_db_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);

/*
a64 1
	const db_symformat_t **symf;
d90 3
a92 5
	if (xesym != NULL && xesym != xssym)
		for (symf = db_symformats; *symf != NULL; symf++) {
			db_symformat = *symf;
			if (X_db_sym_init((vaddr_t)xesym - (vaddr_t)xssym,
			    xssym, xesym, name) == TRUE)
d94 1
a94 1
		}
a95 1
	db_symformat = NULL;
d239 1
a239 1
		    (sp = X_db_lookup(&db_symtabs[i], symstr))) {
d266 1
a266 1
		    X_db_lookup(&db_symtabs[i], sym_name)) {
d292 1
a292 1
	    sym = X_db_search_symbol(&db_symtabs[i], val, strategy, &newdiff);
d316 1
a316 1
	X_db_symbol_values(db_last_symtab, sym, namep, &value);
d368 3
a370 2
			if (strategy == DB_STGY_PROC) {
				if (db_line_at_pc(cursym, &filename, &linenum, off))
a378 80
}


boolean_t
db_line_at_pc(db_sym_t sym, char **filename, int *linenum, db_expr_t pc)
{
	return X_db_line_at_pc(db_last_symtab, sym, filename, linenum, pc);
}

int
db_sym_numargs(db_sym_t sym, int *nargp, char **argnames)
{
	return X_db_sym_numargs(db_last_symtab, sym, nargp, argnames);
}

boolean_t
X_db_sym_init(int symsize, void *vss, void *vse, const char *name)
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_init)(symsize, vss, vse, name));
	return (FALSE);
}

db_sym_t
X_db_lookup(db_symtab_t *stab, char *symstr)
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_lookup)(stab, symstr));
	return ((db_sym_t)0);
}

db_sym_t
X_db_search_symbol(db_symtab_t *stab, db_addr_t off, db_strategy_t strategy,
    db_expr_t *diffp)
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_search)(stab, off, strategy,
		    diffp));
	return ((db_sym_t)0);
}

void
X_db_symbol_values(db_symtab_t *stab, db_sym_t sym, char **namep,
    db_expr_t *valuep)
{

	if (db_symformat != NULL)
		(*db_symformat->sym_value)(stab, sym, namep, valuep);
}

boolean_t
X_db_line_at_pc(db_symtab_t *stab, db_sym_t cursym, char **filename,
    int *linenum, db_expr_t off)
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_line_at_pc)(stab, cursym,
		    filename, linenum, off));
	return (FALSE);
}

boolean_t
X_db_sym_numargs(db_symtab_t *stab, db_sym_t cursym, int *nargp,
    char **argnamep)
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_numargs)(stab, cursym, nargp,
		    argnamep));
	return (FALSE);
}

void
X_db_forall(db_symtab_t *stab, db_forall_func_t db_forall_func, void *arg)
{
	if (db_symformat != NULL)
		(*db_symformat->sym_forall)(stab, db_forall_func, arg);
@


1.41
log
@Kill "#if 0" version of ddb_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.40 2016/01/25 14:30:30 mpi Exp $	*/
a54 2
static db_forall_func_t db_sift;

a270 100

/* Private structure for passing args to db_sift() from db_sifting(). */
struct db_sift_args {
	char	*symstr;
	int	mode;
};

/*
 * Does the work of db_sifting(), called once for each
 * symbol via X_db_forall(), prints out symbols matching
 * criteria.
 */
static void
db_sift(db_symtab_t *stab, db_sym_t sym, char *name, char *suffix, int prefix,
    void *arg)
{
	char c, sc;
	char *find, *p;
	size_t len;
	struct db_sift_args *dsa;

	dsa = (struct db_sift_args*)arg;

	find = dsa->symstr;	/* String we're looking for. */
	p = name;		/* String we're searching within. */

	/* Matching algorithm cribbed from strstr(), which is not
	   in the kernel. */
	if ((c = *find++) != 0) {
		len = strlen(find);
		do {
			do {
				if ((sc = *p++) == 0)
					return;
			} while (sc != c);
		} while (strncmp(p, find, len) != 0);
	}
	if (dsa->mode=='F')	/* ala ls -F */
		db_printf("%s%s ", name, suffix);
	else
		db_printf("%s ", name);
}

/*
 * "Sift" for a partial symbol.
 * Named for the Sun OpenPROM command ("sifting").
 * If the symbol has a qualifier (e.g., ux:vm_map),
 * then only the specified symbol table will be searched;
 * otherwise, all symbol tables will be searched..
 *
 * "mode" is how-to-display, set from modifiers.
 */
void
db_sifting(char *symstr, int mode)
{
	char *cp;
	int i;
	int symtab_start = 0;
	int symtab_end = MAXNOSYMTABS;
	struct db_sift_args dsa;

	/*
	 * Look for, remove, and remember any symbol table specifier.
	 */
	for (cp = symstr; *cp; cp++) {
		if (*cp == ':') {
			*cp = '\0';
			for (i = 0; i < MAXNOSYMTABS; i++) {
				if (db_symtabs[i].name &&
				    ! strcmp(symstr, db_symtabs[i].name)) {
					symtab_start = i;
					symtab_end = i + 1;
					break;
				}
			}
			*cp = ':';
			if (i == MAXNOSYMTABS) {
				db_error("invalid symbol table name");
				/*NOTREACHED*/
			}
			symstr = cp+1;
		}
	}

	/* Pass args to db_sift(). */
	dsa.symstr = symstr;
	dsa.mode = mode;

	/*
	 * Look in the specified set of symbol tables.
	 */
	for (i = symtab_start; i < symtab_end; i++)
		if (db_symtabs[i].name) {
			db_printf("Sifting table %s:\n", db_symtabs[i].name);
			X_db_forall(&db_symtabs[i], db_sift, &dsa);
		}

	return;
}

@


1.40
log
@Kill trailing whitespaces.  No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.39 2015/12/23 01:39:02 mmcc Exp $	*/
a84 32
#if 0
void
ddb_init(int symsize, void *vss, void *vse)
{
	const db_symformat_t **symf;
	const char *name = "bsd";

	if (symsize <= 0) {
		printf(" [ no symbols available ]\n");
		return;
	}

	/*
	 * Do this check now for the master symbol table to avoid printing
	 * the message N times.
	 */
	if (ALIGNED_POINTER(vss, long) == 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, vss);
		return;
	}

	for (symf = db_symformats; *symf != NULL; symf++) {
		db_symformat = *symf;
		if (X_db_sym_init(symsize, vss, vse, name) == TRUE)
			return;
	}

	db_symformat = NULL;
	printf("[ no symbol table formats found ]\n");
}
#else
a124 1
#endif
@


1.39
log
@assign pointers NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.38 2015/08/12 06:19:25 mlarkin Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d298 1
a298 1
		if (db_symtabs[i].name && 
d331 1
a331 1
	
d587 1
a587 1
	if (db_symformat != NULL) 
@


1.38
log
@
Use a linker script when building i386 kernels to allow section padding on
PAGE_SIZE boundaries. This is required to enforce proper separation of
sections when adding page protections (coming shortly).

This was in snaps before release with no reported side effects.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.37 2015/03/14 03:38:46 jsg Exp $	*/
d448 1
a448 1
	db_last_symtab = 0;
d472 1
a472 1
		*namep = 0;
@


1.37
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.36 2014/12/21 16:27:08 mlarkin Exp $	*/
d123 2
a124 1
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__)
d130 2
a131 1
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__)
@


1.36
log
@Prevent writing to the kernel area via the direct map. We do this by padding
the end of the kernel area to 2MB, so that the direct map pages can then
have the W permission removed (X permission was already removed in a previous
diff). This creates a VA hole at the end of bss, so adjust for that since
that's where symbols get loaded by the bootloader (for now, map that region
RO until the boot loader can be updated to place the symbols at "end" instead
of "end of bss").

with help from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.35 2014/09/14 14:17:24 jsg Exp $	*/
a37 1
#include <ddb/db_extern.h>
@


1.35
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.34 2014/03/16 20:31:46 guenther Exp $	*/
d124 1
a124 1
#if defined(__sparc64__) || defined(__mips__)
d130 1
a130 1
#if defined(__sparc64__) || defined(__mips__)
@


1.34
log
@DDB supports ELF symbols are all archs, and it's always the same as the
native size, so eliminate the #defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.33 2013/10/17 08:02:19 deraadt Exp $	*/
a30 1
#include <sys/proc.h>
@


1.33
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.32 2006/03/13 06:23:20 jsg Exp $	*/
a64 1
#ifdef DB_ELF_SYMBOLS
a65 1
#endif
@


1.32
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.31 2005/09/29 05:57:14 deraadt Exp $	*/
a66 3
#endif
#ifdef DB_AOUT_SYMBOLS
	&db_symformat_aout,
@


1.31
log
@char end[] vs long end, bad; pr 4288
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.30 2005/04/19 15:24:22 miod Exp $	*/
d94 1
a94 3
ddb_init(symsize, vss, vse)
	int symsize;
	void *vss, *vse;
d125 1
a125 1
ddb_init()
d168 1
a168 5
db_add_symbol_table(start, end, name, ref)
	char *start;
	char *end;
	const char *name;
	char *ref;
d193 1
a193 2
db_del_symbol_table(name)
	char *name;
d220 1
a220 3
db_qualify(sym, symtabname)
	db_sym_t	sym;
	const char	*symtabname;
d238 1
a238 4
db_eqname(src, dst, c)
	char *src;
	char *dst;
	int c;
d248 1
a248 3
db_value_of_name(name, valuep)
	char		*name;
	db_expr_t	*valuep;
d267 1
a267 2
db_lookup(symstr)
	char *symstr;
d324 2
a325 7
db_sift(stab, sym, name, suffix, prefix, arg)
	db_symtab_t	*stab;
	db_sym_t	sym;
	char		*name;
	char		*suffix;
	int		prefix;
	void		*arg;
d364 1
a364 3
db_sifting(symstr, mode)
	char	*symstr;
	int	mode;
d419 1
a419 2
db_symbol_is_ambiguous(sym)
	db_sym_t	sym;
d445 1
a445 4
db_search_symbol( val, strategy, offp)
	db_addr_t		val;
	db_strategy_t		strategy;
	db_expr_t		*offp;
d472 1
a472 4
db_symbol_values(sym, namep, valuep)
	db_sym_t	sym;
	char		**namep;
	db_expr_t	*valuep;
d547 1
a547 5
db_line_at_pc(sym, filename, linenum, pc)
	db_sym_t	sym;
	char		**filename;
	int		*linenum;
	db_expr_t	pc;
d553 1
a553 4
db_sym_numargs(sym, nargp, argnames)
	db_sym_t	sym;
	int		*nargp;
	char		**argnames;
d559 1
a559 4
X_db_sym_init(symsize, vss, vse, name)
	int symsize;
	void *vss, *vse;
	const char *name;
d568 1
a568 3
X_db_lookup(stab, symstr)
	db_symtab_t *stab;
	char *symstr;
d577 2
a578 5
X_db_search_symbol(stab, off, strategy, diffp)
	db_symtab_t *stab;
	db_addr_t off;
	db_strategy_t strategy;
	db_expr_t *diffp;
d588 2
a589 5
X_db_symbol_values(stab, sym, namep, valuep)
	db_symtab_t *stab;
	db_sym_t sym;
	char **namep;
	db_expr_t *valuep;
d597 2
a598 6
X_db_line_at_pc(stab, cursym, filename, linenum, off)
	db_symtab_t *stab;
	db_sym_t cursym;
	char **filename;
	int *linenum;
	db_expr_t off;
d608 2
a609 5
X_db_sym_numargs(stab, cursym, nargp, argnamep)
	db_symtab_t *stab;
	db_sym_t cursym;
	int *nargp;
	char **argnamep;
d619 1
a619 4
X_db_forall(stab, db_forall_func, arg)
	db_symtab_t	*stab;
	db_forall_func_t db_forall_func;
	void *arg;
@


1.30
log
@Do not bother looking for symbols if either esym is zero or the computed
symbol table length is zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.29 2004/08/09 22:22:50 pefo Exp $	*/
d59 2
a133 2
#else
	extern long end;
a536 1
extern char end[];
@


1.29
log
@mips/sgi uses same symbol table style setup as sparc64
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.28 2002/05/16 13:01:41 art Exp $	*/
d153 5
a157 3
	for (symf = db_symformats; *symf != NULL; symf++) {
		db_symformat = *symf;
		if (X_db_sym_init((long)xesym - (long)xssym, xssym, xesym, name) == TRUE)
d159 1
a159 1
	}
@


1.28
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.27 2002/05/14 16:13:48 art Exp $	*/
d130 1
a130 1
#ifdef __sparc64__
d138 1
a138 1
#ifdef __sparc64__
@


1.27
log
@Use db_format in db_printsym (we'll want to be able to use printf in it soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.26 2002/05/13 15:38:58 art Exp $	*/
d541 2
a542 3
db_printsym(off, strategy)
	db_expr_t	off;
	db_strategy_t	strategy;
d556 1
a556 1
			db_printf("%s", name);
d558 1
a558 1
				db_printf("+%s", db_format(buf, sizeof(buf),
d563 1
a563 1
					db_printf(" [%s:%d]", filename, linenum);
d569 1
a569 1
	db_printf("%s", db_format(buf, sizeof(buf), off, DB_FORMAT_N, 1, 0));
@


1.26
log
@minor knf.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.25 2002/03/14 01:26:51 millert Exp $	*/
d551 1
d559 2
a560 1
				db_printf("+%#r", d);
d570 1
a570 1
	db_printf("%#ln", off);
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.24 2001/08/19 17:49:00 frantzen Exp $	*/
d574 1
a574 1
db_line_at_pc( sym, filename, linenum, pc)
d580 1
a580 1
	return X_db_line_at_pc( db_last_symtab, sym, filename, linenum, pc);
@


1.24
log
@Needed a simple cast after a sparc64 change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.23 2001/08/19 16:41:07 art Exp $	*/
d74 10
a83 10
boolean_t	X_db_sym_init __P((int, void *, void *, const char *));
db_sym_t	X_db_lookup __P((db_symtab_t *, char *));
db_sym_t	X_db_search_symbol __P((db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *));
void		X_db_symbol_values __P((db_symtab_t *, db_sym_t, char **,
		    db_expr_t *));
boolean_t	X_db_line_at_pc __P((db_symtab_t *, db_sym_t, char **,
		    int *, db_expr_t));
int		X_db_sym_numargs __P((db_symtab_t *, db_sym_t, int *,
		    char **));
@


1.24.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.24 2001/08/19 17:49:00 frantzen Exp $	*/
d74 10
a83 10
boolean_t	X_db_sym_init(int, void *, void *, const char *);
db_sym_t	X_db_lookup(db_symtab_t *, char *);
db_sym_t	X_db_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		X_db_symbol_values(db_symtab_t *, db_sym_t, char **,
		    db_expr_t *);
boolean_t	X_db_line_at_pc(db_symtab_t *, db_sym_t, char **,
		    int *, db_expr_t);
int		X_db_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
d541 3
a543 2
db_printsym(db_expr_t off, db_strategy_t strategy,
    int (*pr)(const char *, ...))
a550 1
	char		buf[DB_FORMAT_BUF_SIZE];
d556 1
a556 1
			(*pr)("%s", name);
d558 1
a558 2
				(*pr)("+%s", db_format(buf, sizeof(buf),
				    d, DB_FORMAT_R, 1, 0));
d562 1
a562 1
					(*pr)(" [%s:%d]", filename, linenum);
d568 1
a568 1
	(*pr)("%s", db_format(buf, sizeof(buf), off, DB_FORMAT_N, 1, 0));
d574 1
a574 1
db_line_at_pc(sym, filename, linenum, pc)
d580 1
a580 1
	return X_db_line_at_pc(db_last_symtab, sym, filename, linenum, pc);
@


1.23
log
@Ugly hack to make symbols work on sparc64.
We really need to change ddb_init to take args from MD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.22 2001/02/10 10:42:35 niklas Exp $	*/
d141 1
a141 1
	xssym = &end;
@


1.22
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 3
d134 2
d137 6
d147 1
a147 1
	if ((((vaddr_t)&end) & (sizeof(long) - 1)) != 0) {
d149 1
a149 1
		    name, &end);
d155 1
a155 1
		if (X_db_sym_init((long)esym - (long)&end, &end, esym, name) == TRUE)
@


1.21
log
@Include vm/vm.h everywhere it is needed to get at boolean_t (I would prefer
to have it in sys/types.h but that is problematic).  Some KNF.
@
text
@d1 2
a2 2
/*	$OpenBSD: db_sym.c,v 1.20 1997/07/06 23:09:25 niklas Exp $	*/
/*	$NetBSD: db_sym.c,v 1.12 1996/02/05 01:57:15 christos Exp $	*/
a31 1
#include <sys/malloc.h>
a33 2
#include <vm/vm.h>

d36 1
d45 9
a53 3
static TAILQ_HEAD(, db_symtab)	db_symtabs;
static struct db_symtab	db_sym_kernel;
size_t			db_nsymtabs = 0;
d55 3
a57 1
db_symtab_t	db_last_symtab;
d60 1
a60 1
 * Init sym module
d62 29
d92 3
a94 1
db_sym_init(void)
d96 54
a149 1
	TAILQ_INIT(&db_symtabs);
d151 1
d157 1
a157 1
db_add_symbol_table(start, end, name, ref, rend)
d160 1
a160 1
	char *name;
a161 1
	char *rend;
d163 1
a163 1
	db_symtab_t	new = db_nsymtabs? NULL : &db_sym_kernel;
d165 8
a172 11
	if (new == NULL &&
	    (new = malloc(sizeof(*new), M_DEVBUF, M_WAITOK)) == NULL)
		return -1;

	new->start = start;
	new->end = end;
	new->name = name;
	new->private = ref;
	new->rend = rend;
	new->id = db_nsymtabs;
	TAILQ_INSERT_TAIL(&db_symtabs, new, list);
d174 6
a179 1
	return db_nsymtabs++;
d189 1
a189 1
	register db_symtab_t	p;
d191 3
a193 2
	for (p = db_symiter(NULL); p != NULL; p = db_symiter(p))
		if (!strcmp(name, p->name))
d195 5
d201 4
a204 31
	if (p == NULL)
		db_printf("ddb: %s symbol table was not allocated", name);

	if (--db_nsymtabs == 0)
		panic("ddb: kernel symtab delete");

	TAILQ_REMOVE(&db_symtabs, p, list);
	free(p, M_DEVBUF);
}

db_symtab_t
db_istab(i)
	size_t	i;
{
	register db_symtab_t	p;

	for (p = db_symiter(NULL); i && p != NULL ; p = db_symiter(p))
		i--;

	return i? NULL : p;
}

db_symtab_t
db_symiter(st)
	db_symtab_t	st;
{
	if (st == NULL)
		st = db_symtabs.tqh_first;
	else
		st = st->list.tqe_next;
	return st;
d216 1
a216 1
	register char	*symtabname;
d220 1
a220 1
	register char	*s;
a245 1
#ifdef DDB
d260 1
d271 5
a275 3
	db_symtab_t	st = NULL;
	db_sym_t	sp = NULL;
	register char	*cp;
d280 1
a280 1
	for (cp = symstr; *cp; cp++)
d283 5
a287 4
			for (st = db_symiter(NULL);
			     st != NULL;
			     st = db_symiter(st))
				if (!strcmp(symstr, st->name))
d289 2
d292 1
a292 1
			if (st == NULL) {
d294 1
a294 1
				/* NOTREACHED */
d298 1
d304 53
a356 2
	if (st != NULL)
		sp = X_db_lookup(st, symstr);
d358 2
a359 3
		for (st = db_symiter(NULL); st != NULL; st = db_symiter(st))
			if ((sp = X_db_lookup(st, symstr)) != NULL)
				break;
d361 19
a379 2
	if (sp != NULL && st != NULL)
		db_last_symtab = st;
d381 37
a417 1
	return sp;
d419 1
a419 1
#endif
d432 1
a432 2
	register db_symtab_t	st;
	register
d439 3
a441 2
	for (st = db_symiter(NULL); st != NULL; st = db_symiter(st)) {
		if (X_db_lookup(st, sym_name) != NULL) {
d456 1
a456 1
	register db_addr_t	val;
d460 1
a460 2
	register
	db_expr_t	diff;
d462 1
a462 1
	db_symtab_t	st;
d465 1
a465 1
	newdiff = diff = -1;
d467 6
a472 4
	for (st = db_symiter(NULL); st != NULL; st = db_symiter(st)) {
	    sym = X_db_search_symbol(st, val, strategy, &newdiff);
	    if (newdiff < diff || diff < 0) {
		db_last_symtab = st;
d497 1
a497 1
	X_db_symbol_values(sym, namep, &value);
d525 2
a526 2
u_long	db_lastsym = (u_long)end;
db_expr_t db_maxoff = 0x10000000;
d541 1
a541 1
	if ((u_long)off <= db_lastsym) {
d546 1
a546 1
			if (d)
d548 1
d550 2
a551 4
				if (db_line_at_pc(cursym, &filename, &linenum,
				    off))
					db_printf(" [%s:%d]", filename,
				    linenum);
d556 1
d581 37
d619 18
a636 3
db_stub_xh(sym, xh)
	db_symtab_t	sym;
	struct exec	*xh;
d638 5
a642 1
	X_db_stub_xh(sym, xh);
d645 6
a650 3
int
db_symtablen(sym)
	db_symtab_t	sym;
d652 5
a656 1
	return X_db_symtablen(sym);
d659 5
a663 6
int
db_symatoff(sym, off, buf, len)
	db_symtab_t	sym;
	int off;
	void *buf;
	int *len;
d665 2
a666 1
	return X_db_symatoff(sym, off, buf, len);
@


1.21.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: db_sym.c,v 1.22 2001/02/10 10:42:35 niklas Exp $	*/
/*	$NetBSD: db_sym.c,v 1.24 2000/08/11 22:50:47 tv Exp $	*/
d32 1
d35 2
a38 1
#include <ddb/db_lex.h>
d47 3
a49 9
#ifndef MAXLKMS
#define MAXLKMS 20
#endif

#ifndef MAXNOSYMTABS
#define	MAXNOSYMTABS	MAXLKMS+1	/* Room for kernel + LKM's */
#endif

db_symtab_t	db_symtabs[MAXNOSYMTABS] = {{0,},};
d51 1
a51 3
db_symtab_t	*db_last_symtab;

static db_forall_func_t db_sift;
d54 1
a54 1
 * Put the most picky symbol table formats at the top!
a55 29
const db_symformat_t *db_symformats[] = {
#ifdef DB_ELF_SYMBOLS
	&db_symformat_elf,
#endif
#ifdef DB_AOUT_SYMBOLS
	&db_symformat_aout,
#endif
	NULL,
};

const db_symformat_t *db_symformat;

boolean_t	X_db_sym_init __P((int, void *, void *, const char *));
db_sym_t	X_db_lookup __P((db_symtab_t *, char *));
db_sym_t	X_db_search_symbol __P((db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *));
void		X_db_symbol_values __P((db_symtab_t *, db_sym_t, char **,
		    db_expr_t *));
boolean_t	X_db_line_at_pc __P((db_symtab_t *, db_sym_t, char **,
		    int *, db_expr_t));
int		X_db_sym_numargs __P((db_symtab_t *, db_sym_t, int *,
		    char **));

/*
 * Initialize the kernel debugger by initializing the master symbol
 * table.  Note that if initializing the master symbol table fails,
 * no other symbol tables can be loaded.
 */
#if 0
d57 1
a57 3
ddb_init(symsize, vss, vse)
	int symsize;
	void *vss, *vse;
d59 1
a59 54
	const db_symformat_t **symf;
	const char *name = "bsd";

	if (symsize <= 0) {
		printf(" [ no symbols available ]\n");
		return;
	}

	/*
	 * Do this check now for the master symbol table to avoid printing
	 * the message N times.
	 */
	if (ALIGNED_POINTER(vss, long) == 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, vss);
		return;
	}

	for (symf = db_symformats; *symf != NULL; symf++) {
		db_symformat = *symf;
		if (X_db_sym_init(symsize, vss, vse, name) == TRUE)
			return;
	}

	db_symformat = NULL;
	printf("[ no symbol table formats found ]\n");
}
#else
void
ddb_init()
{
	const db_symformat_t **symf;
	const char *name = "bsd";
	extern char *esym;
	extern long end;

	/*
	 * Do this check now for the master symbol table to avoid printing
	 * the message N times.
	 */
	if ((((vaddr_t)&end) & (sizeof(long) - 1)) != 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, &end);
		return;
	}

	for (symf = db_symformats; *symf != NULL; symf++) {
		db_symformat = *symf;
		if (X_db_sym_init((long)esym - (long)&end, &end, esym, name) == TRUE)
			return;
	}

	db_symformat = NULL;
	printf("[ no symbol table formats found ]\n");
a60 1
#endif
d66 1
a66 1
db_add_symbol_table(start, end, name, ref)
d69 1
a69 1
	const char *name;
d71 1
d73 1
a73 1
	int slot;
d75 11
a85 8
	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name == NULL)
			break;
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("No slots left for %s symbol table", name);
		return(-1);
	}
d87 1
a87 6
	db_symtabs[slot].start = start;
	db_symtabs[slot].end = end;
	db_symtabs[slot].name = name;
	db_symtabs[slot].private = ref;

	return(slot);
d97 1
a97 1
	int slot;
d99 2
a100 3
	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name &&
		    ! strcmp(db_symtabs[slot].name, name))
a101 5
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("Unable to find symbol table slot for %s.", name);
		return;
	}
d103 31
a133 4
	db_symtabs[slot].start = 0;
	db_symtabs[slot].end = 0;
	db_symtabs[slot].name = 0;
	db_symtabs[slot].private = 0;
d145 1
a145 1
	const char	*symtabname;
d149 1
a149 1
	char	*s;
d175 1
a189 1

d200 3
a202 5
	db_sym_t sp;
	int i;
	int symtab_start = 0;
	int symtab_end = MAXNOSYMTABS;
	char *cp;
d207 1
a207 1
	for (cp = symstr; *cp; cp++) {
d210 4
a213 5
			for (i = 0; i < MAXNOSYMTABS; i++) {
				if (db_symtabs[i].name &&
				    ! strcmp(symstr, db_symtabs[i].name)) {
					symtab_start = i;
					symtab_end = i + 1;
a214 2
				}
			}
d216 1
a216 1
			if (i == MAXNOSYMTABS) {
d218 1
a218 1
				/*NOTREACHED*/
a221 1
	}
d227 2
a228 53
	for (i = symtab_start; i < symtab_end; i++) {
		if (db_symtabs[i].name && 
		    (sp = X_db_lookup(&db_symtabs[i], symstr))) {
			db_last_symtab = &db_symtabs[i];
			return sp;
		}
	}
	return 0;
}

/* Private structure for passing args to db_sift() from db_sifting(). */
struct db_sift_args {
	char	*symstr;
	int	mode;
};

/*
 * Does the work of db_sifting(), called once for each
 * symbol via X_db_forall(), prints out symbols matching
 * criteria.
 */
static void
db_sift(stab, sym, name, suffix, prefix, arg)
	db_symtab_t	*stab;
	db_sym_t	sym;
	char		*name;
	char		*suffix;
	int		prefix;
	void		*arg;
{
	char c, sc;
	char *find, *p;
	size_t len;
	struct db_sift_args *dsa;

	dsa = (struct db_sift_args*)arg;

	find = dsa->symstr;	/* String we're looking for. */
	p = name;		/* String we're searching within. */
	
	/* Matching algorithm cribbed from strstr(), which is not
	   in the kernel. */
	if ((c = *find++) != 0) {
		len = strlen(find);
		do {
			do {
				if ((sc = *p++) == 0)
					return;
			} while (sc != c);
		} while (strncmp(p, find, len) != 0);
	}
	if (dsa->mode=='F')	/* ala ls -F */
		db_printf("%s%s ", name, suffix);
d230 3
a232 2
		db_printf("%s ", name);
}
d234 2
a235 19
/*
 * "Sift" for a partial symbol.
 * Named for the Sun OpenPROM command ("sifting").
 * If the symbol has a qualifier (e.g., ux:vm_map),
 * then only the specified symbol table will be searched;
 * otherwise, all symbol tables will be searched..
 *
 * "mode" is how-to-display, set from modifiers.
 */
void
db_sifting(symstr, mode)
	char	*symstr;
	int	mode;
{
	char *cp;
	int i;
	int symtab_start = 0;
	int symtab_end = MAXNOSYMTABS;
	struct db_sift_args dsa;
d237 1
a237 37
	/*
	 * Look for, remove, and remember any symbol table specifier.
	 */
	for (cp = symstr; *cp; cp++) {
		if (*cp == ':') {
			*cp = '\0';
			for (i = 0; i < MAXNOSYMTABS; i++) {
				if (db_symtabs[i].name &&
				    ! strcmp(symstr, db_symtabs[i].name)) {
					symtab_start = i;
					symtab_end = i + 1;
					break;
				}
			}
			*cp = ':';
			if (i == MAXNOSYMTABS) {
				db_error("invalid symbol table name");
				/*NOTREACHED*/
			}
			symstr = cp+1;
		}
	}

	/* Pass args to db_sift(). */
	dsa.symstr = symstr;
	dsa.mode = mode;

	/*
	 * Look in the specified set of symbol tables.
	 */
	for (i = symtab_start; i < symtab_end; i++)
		if (db_symtabs[i].name) {
			db_printf("Sifting table %s:\n", db_symtabs[i].name);
			X_db_forall(&db_symtabs[i], db_sift, &dsa);
		}

	return;
d239 1
a239 1

d252 2
a253 1
	int	i;
d260 2
a261 3
	for (i = 0; i < MAXNOSYMTABS; i++) {
		if (db_symtabs[i].name &&
		    X_db_lookup(&db_symtabs[i], sym_name)) {
d276 1
a276 1
	db_addr_t		val;
d280 2
a281 1
	unsigned int	diff;
d283 1
a283 1
	int		i;
d286 1
a286 1
	newdiff = diff = ~0;
d288 4
a291 6
	for (i = 0; i < MAXNOSYMTABS; i++) {
	    if (!db_symtabs[i].name)
	        continue;
	    sym = X_db_search_symbol(&db_symtabs[i], val, strategy, &newdiff);
	    if (newdiff < diff) {
		db_last_symtab = &db_symtabs[i];
d316 1
a316 1
	X_db_symbol_values(db_last_symtab, sym, namep, &value);
d344 2
a345 2
unsigned long	db_lastsym = (unsigned long)end;
unsigned int	db_maxoff = 0x10000000;
d360 1
a360 1
	if (off <= db_lastsym) {
d365 1
a365 1
			if (d) {
a366 1
			}
d368 4
a371 2
				if (db_line_at_pc(cursym, &filename, &linenum, off))
					db_printf(" [%s:%d]", filename, linenum);
a375 1

a399 37
boolean_t
X_db_sym_init(symsize, vss, vse, name)
	int symsize;
	void *vss, *vse;
	const char *name;
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_init)(symsize, vss, vse, name));
	return (FALSE);
}

db_sym_t
X_db_lookup(stab, symstr)
	db_symtab_t *stab;
	char *symstr;
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_lookup)(stab, symstr));
	return ((db_sym_t)0);
}

db_sym_t
X_db_search_symbol(stab, off, strategy, diffp)
	db_symtab_t *stab;
	db_addr_t off;
	db_strategy_t strategy;
	db_expr_t *diffp;
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_search)(stab, off, strategy,
		    diffp));
	return ((db_sym_t)0);
}

d401 3
a403 5
X_db_symbol_values(stab, sym, namep, valuep)
	db_symtab_t *stab;
	db_sym_t sym;
	char **namep;
	db_expr_t *valuep;
d405 1
a405 3

	if (db_symformat != NULL) 
		(*db_symformat->sym_value)(stab, sym, namep, valuep);
d408 3
a410 21
boolean_t
X_db_line_at_pc(stab, cursym, filename, linenum, off)
	db_symtab_t *stab;
	db_sym_t cursym;
	char **filename;
	int *linenum;
	db_expr_t off;
{

	if (db_symformat != NULL)
		return ((*db_symformat->sym_line_at_pc)(stab, cursym,
		    filename, linenum, off));
	return (FALSE);
}

boolean_t
X_db_sym_numargs(stab, cursym, nargp, argnamep)
	db_symtab_t *stab;
	db_sym_t cursym;
	int *nargp;
	char **argnamep;
d412 1
a412 5

	if (db_symformat != NULL)
		return ((*db_symformat->sym_numargs)(stab, cursym, nargp,
		    argnamep));
	return (FALSE);
d415 6
a420 5
void
X_db_forall(stab, db_forall_func, arg)
	db_symtab_t	*stab;
	db_forall_func_t db_forall_func;
	void *arg;
d422 1
a422 2
	if (db_symformat != NULL)
		(*db_symformat->sym_forall)(stab, db_forall_func, arg);
@


1.21.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.21.12.1 2001/05/14 22:07:00 niklas Exp $	*/
a129 3
#ifdef __sparc64__
	extern char *ssym;
#else
a130 2
#endif
	char *xssym, *xesym;
a131 6
	xesym = esym;
#ifdef __sparc64__
	xssym = ssym;
#else
	xssym = (char *)&end;
#endif
d136 1
a136 1
	if ((((vaddr_t)xssym) & (sizeof(long) - 1)) != 0) {
d138 1
a138 1
		    name, xssym);
d144 1
a144 1
		if (X_db_sym_init((long)xesym - (long)xssym, xssym, xesym, name) == TRUE)
@


1.21.12.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 10
a83 10
boolean_t	X_db_sym_init(int, void *, void *, const char *);
db_sym_t	X_db_lookup(db_symtab_t *, char *);
db_sym_t	X_db_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		X_db_symbol_values(db_symtab_t *, db_sym_t, char **,
		    db_expr_t *);
boolean_t	X_db_line_at_pc(db_symtab_t *, db_sym_t, char **,
		    int *, db_expr_t);
int		X_db_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
@


1.21.12.4
log
@Sync the SMP branch with 3.3
@
text
@d541 3
a543 2
db_printsym(db_expr_t off, db_strategy_t strategy,
    int (*pr)(const char *, ...))
a550 1
	char		buf[DB_FORMAT_BUF_SIZE];
d556 1
a556 1
			(*pr)("%s", name);
d558 1
a558 2
				(*pr)("+%s", db_format(buf, sizeof(buf),
				    d, DB_FORMAT_R, 1, 0));
d562 1
a562 1
					(*pr)(" [%s:%d]", filename, linenum);
d568 1
a568 1
	(*pr)("%s", db_format(buf, sizeof(buf), off, DB_FORMAT_N, 1, 0));
d574 1
a574 1
db_line_at_pc(sym, filename, linenum, pc)
d580 1
a580 1
	return X_db_line_at_pc(db_last_symtab, sym, filename, linenum, pc);
@


1.20
log
@64 bit fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.19 1997/05/29 03:28:44 mickey Exp $	*/
d34 2
@


1.19
log
@futher support for kernfs......
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.18 1997/02/07 07:03:40 mickey Exp $	*/
d366 4
a369 2
				if (db_line_at_pc(cursym, &filename, &linenum, off))
					db_printf(" [%s:%d]", filename, linenum);
d374 1
a374 1
	db_printf("%#n", off);
@


1.18
log
@wrong private name
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.17 1997/02/07 06:18:48 mickey Exp $	*/
d85 1
a85 1
	return ++db_nsymtabs;
d173 1
a187 1

d237 1
d402 17
@


1.17
log
@necessary support for kernfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.16 1996/08/23 19:53:48 niklas Exp $	*/
d80 2
a81 2
	new->rstart = ref;
	new->private = rend;
@


1.16
log
@signedness pedanetery
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.15 1996/08/16 10:12:37 mickey Exp $	*/
a78 1
	new->rend = rend;
d80 2
a81 1
	new->private = ref;
d393 8
@


1.15
log
@record real symtab end.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.14 1996/08/16 06:13:02 mickey Exp $	*/
d341 1
a341 1
unsigned long	db_lastsym = (unsigned long)end;
d357 1
a357 1
	if (off <= db_lastsym) {
@


1.14
log
@add symtab list public iterator.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.13 1996/08/13 00:41:34 niklas Exp $	*/
d64 1
a64 1
db_add_symbol_table(start, end, name, ref)
d69 1
d79 1
@


1.13
log
@Kludge to make DDB reverse symbol lookup work again.
I will soon deal with this mess in a 64-bit clean way which the
old code was anything but.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.12 1996/08/04 01:27:46 niklas Exp $	*/
d80 1
d93 1
a93 1
	db_symtab_t	p;
d95 1
a95 1
	for (p = db_symtabs.tqh_first; p != NULL; p = p->list.tqe_next)
d115 1
a115 1
	for (p = db_symtabs.tqh_first; i && p != NULL ; p = p->list.tqe_next)
d121 11
d206 1
a206 1
			for (st = db_symtabs.tqh_first;
d208 1
a208 1
			     st = st->list.tqe_next)
d226 1
a226 3
		for (st = db_symtabs.tqh_first;
		     st != NULL;
		     st = st->list.tqe_next)
d255 1
a255 1
	for (st = db_symtabs.tqh_first; st != NULL; st = st->list.tqe_next) {
d283 1
a283 1
	for (st = db_symtabs.tqh_first; st != NULL; st = st->list.tqe_next) {
@


1.12
log
@Make compile on OpenBSD/alpha.  MD stuff is still missing though.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.11 1996/05/31 10:37:25 niklas Exp $	*/
d271 1
a271 1
	newdiff = diff = ~0;
d275 1
a275 1
	    if (newdiff < diff) {
@


1.11
log
@-Wall and -Wstrict-prototypes cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.10 1996/05/20 13:30:07 mickey Exp $	*/
d266 2
a267 2
	unsigned int	diff;
	unsigned int	newdiff;
d329 1
a329 1
unsigned int	db_lastsym = (unsigned long)end;
@


1.10
log
@remove unused #defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.7 1996/04/21 22:19:13 deraadt Exp $	*/
d33 1
@


1.9
log
@do dynamic symtab allocattion.
@
text
@a43 8
#ifndef MAXLKMS
#define MAXLKMS 20
#endif

#ifndef MAXNOSYMTABS
#define	MAXNOSYMTABS	MAXLKMS+1	/* Room for kernel + LKM's */
#endif

@


1.8
log
@add advanced hang analyzer.
idea by theo.
@
text
@d32 1
d52 3
a54 2
db_symtab_t	db_symtabs[MAXNOSYMTABS] = {{0,},};
size_t		db_nsymtabs = 0;
d56 10
a65 1
db_symtab_t	*db_last_symtab;
d77 1
a77 1
	int slot;
d79 9
a87 8
	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name == NULL)
			break;
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("No slots left for %s symbol table", name);
		return(-1);
	}
d89 1
a89 7
	db_symtabs[slot].start = start;
	db_symtabs[slot].end = end;
	db_symtabs[slot].name = name;
	db_symtabs[slot].private = ref;
	db_nsymtabs++;

	return(slot);
d99 1
a99 1
	int slot;
d101 2
a102 3
	for (slot = 0; slot < MAXNOSYMTABS; slot++) {
		if (db_symtabs[slot].name &&
		    ! strcmp(db_symtabs[slot].name, name))
a103 5
	}
	if (slot >= MAXNOSYMTABS) {
		db_printf("Unable to find symbol table slot for %s.", name);
		return;
	}
d105 8
a112 5
	db_nsymtabs--;
	db_symtabs[slot].start = 0;
	db_symtabs[slot].end = 0;
	db_symtabs[slot].name = 0;
	db_symtabs[slot].private = 0;
d115 1
a115 1
db_symtab_t *
d119 1
a119 1
	register db_symtab_t	*stab;
d121 4
a124 4
	for (stab = db_symtabs; i ; stab++)
		if (stab->name != NULL)
			i--;
	return stab;
d191 3
a193 5
	db_sym_t sp;
	register int i;
	int symtab_start = 0;
	int symtab_end = MAXNOSYMTABS;
	register char *cp;
d198 1
a198 1
	for (cp = symstr; *cp; cp++) {
d201 4
a204 5
			for (i = 0; i < MAXNOSYMTABS; i++) {
				if (db_symtabs[i].name &&
				    ! strcmp(symstr, db_symtabs[i].name)) {
					symtab_start = i;
					symtab_end = i + 1;
a205 2
				}
			}
d207 1
a207 1
			if (i == MAXNOSYMTABS) {
d209 1
a209 1
				/*NOTREACHED*/
a212 1
	}
d218 13
a230 8
	for (i = symtab_start; i < symtab_end; i++) {
		if (db_symtabs[i].name && 
		    (sp = X_db_lookup(&db_symtabs[i], symstr))) {
			db_last_symtab = &db_symtabs[i];
			return sp;
		}
	}
	return 0;
d244 1
a244 1
	register int	i;
d252 2
a253 3
	for (i = 0; i < MAXNOSYMTABS; i++) {
		if (db_symtabs[i].name &&
		    X_db_lookup(&db_symtabs[i], sym_name)) {
d275 1
a275 1
	register int	i;
d280 2
a281 4
	for (i = 0; i < MAXNOSYMTABS; i++) {
	    if (!db_symtabs[i].name)
	        continue;
	    sym = X_db_search_symbol(&db_symtabs[i], val, strategy, &newdiff);
d283 1
a283 1
		db_last_symtab = &db_symtabs[i];
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.6 1996/03/30 04:51:28 mickey Exp $	*/
d52 1
a55 2
static char *db_qualify __P((db_sym_t, char *));

d81 1
d105 1
d112 12
d130 1
a130 1
static char *
@


1.6
log
@Added: sysctl access to the ddb variables.
Fixed: "netbsd" strings in sym table handling routines.
now it is usefull to change max_{width,line} according
to your real console geometry, just w/ sysctl program.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_sym.c,v 1.5 1996/03/11 11:16:23 mickey Exp $	*/
@


1.5
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.4 1996/02/20 13:35:42 mickey Exp $	*/
d111 1
a111 1
 *  db_qualify("vm_map", "netbsd") returns "netbsd:vm_map".
@


1.4
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.c,v 1.12 1996/02/05 01:57:15 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: db_sym.c,v 1.11 1995/11/24 22:13:08 cgd Exp $	*/
d35 3
a37 8

/*
 * We import from the symbol-table dependent routines:
 */
extern db_sym_t	X_db_lookup();
extern db_sym_t	X_db_search_symbol();
extern boolean_t X_db_line_at_pc();
extern void	X_db_symbol_values();
d54 1
a54 1
db_sym_t	db_lookup();	/* forward */
d73 1
a73 1
		printf ("No slots left for %s symbol table", name);
d100 1
a100 1
		printf ("Unable to find symbol table slot for %s.", name);
d111 1
a111 1
 *  db_qualify("vm_map", "bsd") returns "bsd:vm_map".
d127 2
a128 2
	while (*s++ = *symtabname++) {
	}
d130 2
a131 2
	while (*s++ = *symname++) {
	}
d140 1
a140 1
	char c;
a321 1

d323 2
a324 2
unsigned long	db_lastsym = (long)end;
db_expr_t	db_maxoff = 0x10000000;
@


1.2
log
@kernel is called bsd
@
text
@d1 1
a1 1
/*	$NetBSD: db_sym.c,v 1.9 1995/05/24 20:21:00 gwr Exp $	*/
d329 2
a330 2
unsigned int	db_lastsym = (int)end;
unsigned int	db_maxoff = 0x10000000;
@


1.1
log
@Initial revision
@
text
@d116 1
a116 1
 *  db_qualify("vm_map", "netbsd") returns "netbsd:vm_map".
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
