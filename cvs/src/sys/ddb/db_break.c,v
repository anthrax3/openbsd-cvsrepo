head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.16
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.12
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.18
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.14
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.16
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.12
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.10
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.16
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.14
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.12
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.10
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.8
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.6
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.4
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.12
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.04.19.12.23.25;	author mpi;	state Exp;
branches;
next	1.19;
commitid	8RTokESmYJ4rQpkq;

1.19
date	2016.04.19.10.24.42;	author mpi;	state Exp;
branches;
next	1.18;
commitid	cA23wrhtpSoFZEwE;

1.18
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.17;
commitid	7AkssaZPPd7mA8h3;

1.17
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.16;
commitid	p4LJxGKbi0BU2cG6;

1.16
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.15;
commitid	uzzBR7hz9ncd4O6G;

1.15
date	2014.07.08.13.02.57;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	E2I6e8QZgMmNFC95;

1.14
date	2010.11.27.19.59.11;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.28.16.13.29;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.09.11.00.44.59;	author mickey;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.08.07.09.18.40;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.23.34.46;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.07.19.22.31.16;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.18.55;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.11.11.15.58;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.13.35.32;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Do not expose private functions.
@
text
@/*	$OpenBSD: db_break.c,v 1.19 2016/04/19 10:24:42 mpi Exp $	*/
/*	$NetBSD: db_break.c,v 1.7 1996/03/30 22:30:03 christos Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 *	Author: David B. Golub, Carnegie Mellon University
 *	Date:	7/90
 */

/*
 * Breakpoints.
 */
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>		/* type definitions */

#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_break.h>
#include <ddb/db_output.h>

#define	NBREAKPOINTS	100
struct db_breakpoint	db_break_table[NBREAKPOINTS];
db_breakpoint_t		db_next_free_breakpoint = &db_break_table[0];
db_breakpoint_t		db_free_breakpoints = 0;
db_breakpoint_t		db_breakpoint_list = 0;

db_breakpoint_t db_breakpoint_alloc(void);
void db_breakpoint_free(db_breakpoint_t);
void db_set_breakpoint(db_addr_t, int);
void db_delete_breakpoint(db_addr_t);
void db_list_breakpoints(void);

db_breakpoint_t
db_breakpoint_alloc(void)
{
	db_breakpoint_t	bkpt;

	if ((bkpt = db_free_breakpoints) != 0) {
	    db_free_breakpoints = bkpt->link;
	    return (bkpt);
	}
	if (db_next_free_breakpoint == &db_break_table[NBREAKPOINTS]) {
	    db_printf("All breakpoints used.\n");
	    return (0);
	}
	bkpt = db_next_free_breakpoint;
	db_next_free_breakpoint++;

	return (bkpt);
}

void
db_breakpoint_free(db_breakpoint_t bkpt)
{
	bkpt->link = db_free_breakpoints;
	db_free_breakpoints = bkpt;
}

void
db_set_breakpoint(db_addr_t addr, int count)
{
	db_breakpoint_t	bkpt;

	if (db_find_breakpoint(addr)) {
		db_printf("Already set.\n");
		return;
	}

#ifdef DB_VALID_BREAKPOINT
	if (!DB_VALID_BREAKPOINT(addr)) {
		db_printf("Not a valid address for a breakpoint.\n");
		return;
	}
#endif

	bkpt = db_breakpoint_alloc();
	if (bkpt == 0) {
		db_printf("Too many breakpoints.\n");
		return;
	}

	bkpt->address = addr;
	bkpt->flags = 0;
	bkpt->init_count = count;
	bkpt->count = count;

	bkpt->link = db_breakpoint_list;
	db_breakpoint_list = bkpt;
}

void
db_delete_breakpoint(db_addr_t addr)
{
	db_breakpoint_t	bkpt;
	db_breakpoint_t	*prev;

	for (prev = &db_breakpoint_list; (bkpt = *prev) != 0;
	    prev = &bkpt->link) {
		if (bkpt->address == addr) {
			*prev = bkpt->link;
			break;
		}
	}
	if (bkpt == 0) {
		db_printf("Not set.\n");
		return;
	}

	db_breakpoint_free(bkpt);
}

db_breakpoint_t
db_find_breakpoint(db_addr_t addr)
{
	db_breakpoint_t	bkpt;

	for (bkpt = db_breakpoint_list; bkpt != 0; bkpt = bkpt->link)
		if (bkpt->address == addr)
			return (bkpt);

	return (0);
}

int db_breakpoints_inserted = 1;

void
db_set_breakpoints(void)
{
	db_breakpoint_t	bkpt;

	if (!db_breakpoints_inserted) {
		for (bkpt = db_breakpoint_list; bkpt != 0; bkpt = bkpt->link) {
			bkpt->bkpt_inst =
			    db_get_value(bkpt->address, BKPT_SIZE, 0);
			db_put_value(bkpt->address, BKPT_SIZE,
			    BKPT_SET(bkpt->bkpt_inst));
		}
		db_breakpoints_inserted = 1;
	}
}

void
db_clear_breakpoints(void)
{
	db_breakpoint_t	bkpt;

	if (db_breakpoints_inserted) {
		for (bkpt = db_breakpoint_list; bkpt != 0; bkpt = bkpt->link)
			db_put_value(bkpt->address, BKPT_SIZE, bkpt->bkpt_inst);
		db_breakpoints_inserted = 0;
	}
}

/*
 * Set a temporary breakpoint.
 * The instruction is changed immediately,
 * so the breakpoint does not have to be on the breakpoint list.
 */
db_breakpoint_t
db_set_temp_breakpoint(db_addr_t addr)
{
	db_breakpoint_t	bkpt;

#ifdef DB_VALID_BREAKPOINT
	if (!DB_VALID_BREAKPOINT(addr)) {
		db_printf("Not a valid address for a breakpoint.\n");
		return (0);
	}
#endif

	bkpt = db_breakpoint_alloc();
	if (bkpt == 0) {
	    db_printf("Too many breakpoints.\n");
	    return (0);
	}

	bkpt->address = addr;
	bkpt->flags = BKPT_TEMP;
	bkpt->init_count = 1;
	bkpt->count = 1;

	bkpt->bkpt_inst = db_get_value(bkpt->address, BKPT_SIZE, 0);
	db_put_value(bkpt->address, BKPT_SIZE, BKPT_SET(bkpt->bkpt_inst));
	return bkpt;
}

void
db_delete_temp_breakpoint(db_breakpoint_t bkpt)
{
	db_put_value(bkpt->address, BKPT_SIZE, bkpt->bkpt_inst);
	db_breakpoint_free(bkpt);
}

/*
 * List breakpoints.
 */
void
db_list_breakpoints(void)
{
	db_breakpoint_t	bkpt;

	if (db_breakpoint_list == NULL) {
		db_printf("No breakpoints set\n");
		return;
	}

	db_printf(" Count    Address\n");
	for (bkpt = db_breakpoint_list; bkpt != 0; bkpt = bkpt->link) {
		db_printf(" %5d    ", bkpt->init_count);
		db_printsym(bkpt->address, DB_STGY_PROC, db_printf);
		db_printf("\n");
	}
}

/* Delete breakpoint */
/*ARGSUSED*/
void
db_delete_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	db_delete_breakpoint((db_addr_t)addr);
}

/* Set breakpoint with skip count */
/*ARGSUSED*/
void
db_breakpoint_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (count == -1)
		count = 1;

	db_set_breakpoint((db_addr_t)addr, count);
}

/* list breakpoints */
/*ARGSUSED*/
void
db_listbreak_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	db_list_breakpoints();
}
@


1.19
log
@Start reducing the dependence on <uvm/uvm_param.h> by using int-1-0
instead of boolean_t-TRUE-FALSE.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.18 2016/01/25 14:30:30 mpi Exp $	*/
d51 6
@


1.18
log
@Kill trailing whitespaces.  No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.17 2015/03/14 03:38:46 jsg Exp $	*/
d143 1
a143 1
boolean_t	db_breakpoints_inserted = TRUE;
d153 1
a153 1
			    db_get_value(bkpt->address, BKPT_SIZE, FALSE);
d157 1
a157 1
		db_breakpoints_inserted = TRUE;
d169 1
a169 1
		db_breakpoints_inserted = FALSE;
d201 1
a201 1
	bkpt->bkpt_inst = db_get_value(bkpt->address, BKPT_SIZE, FALSE);
@


1.17
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.16 2014/09/14 14:17:24 jsg Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d92 1
a92 1
	}	
d187 1
a187 1
	}	
@


1.16
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.15 2014/07/08 13:02:57 deraadt Exp $	*/
a40 1
#include <ddb/db_lex.h>
@


1.15
log
@These do not need the extremely poorly named uvm/uvm_extern.h (which
pulls in the universe). occasionally they need sys/systm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.14 2010/11/27 19:59:11 miod Exp $	*/
a37 1
#include <sys/proc.h>
@


1.14
log
@Get rid of the vm_map field of ddb breakpoints and watchpoints, and do not
pretend these could work on userland addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.13 2006/03/13 06:23:20 jsg Exp $	*/
d37 1
a38 2

#include <uvm/uvm_extern.h>
@


1.13
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.12 2002/05/16 13:01:41 art Exp $	*/
d82 1
a82 1
db_set_breakpoint(struct vm_map *map, db_addr_t addr, int count)
d86 3
a88 3
	if (db_find_breakpoint(map, addr)) {
	    db_printf("Already set.\n");
	    return;
d100 2
a101 2
	    db_printf("Too many breakpoints.\n");
	    return;
a103 1
	bkpt->map = map;
d114 1
a114 1
db_delete_breakpoint(struct vm_map *map, db_addr_t addr)
d119 6
a124 8
	for (prev = &db_breakpoint_list;
	     (bkpt = *prev) != 0;
	     prev = &bkpt->link) {
	    if (db_map_equal(bkpt->map, map) &&
		(bkpt->address == addr)) {
		*prev = bkpt->link;
		break;
	    }
d127 2
a128 2
	    db_printf("Not set.\n");
	    return;
d135 1
a135 1
db_find_breakpoint(struct vm_map *map, db_addr_t addr)
d139 4
a142 8
	for (bkpt = db_breakpoint_list;
	     bkpt != 0;
	     bkpt = bkpt->link)
	{
	    if (db_map_equal(bkpt->map, map) &&
		(bkpt->address == addr))
		return (bkpt);
	}
a145 6
db_breakpoint_t
db_find_breakpoint_here(db_addr_t addr)
{
    return db_find_breakpoint(db_map_addr(addr), addr);
}

d154 5
a158 9

	    for (bkpt = db_breakpoint_list;
	         bkpt != 0;
	         bkpt = bkpt->link)
		if (db_map_current(bkpt->map)) {
		    bkpt->bkpt_inst = db_get_value(bkpt->address, BKPT_SIZE,
			FALSE);
		    db_put_value(bkpt->address, BKPT_SIZE,
			BKPT_SET(bkpt->bkpt_inst));
d160 1
a160 1
	    db_breakpoints_inserted = TRUE;
d170 3
a172 8

	    for (bkpt = db_breakpoint_list;
	         bkpt != 0;
		 bkpt = bkpt->link)
		if (db_map_current(bkpt->map)) {
		    db_put_value(bkpt->address, BKPT_SIZE, bkpt->bkpt_inst);
		}
	    db_breakpoints_inserted = FALSE;
a198 1
	bkpt->map = NULL;
d224 3
a226 3
	if (db_breakpoint_list == 0) {
	    db_printf("No breakpoints set\n");
	    return;
d229 5
a233 10
	db_printf(" Map      Count    Address\n");
	for (bkpt = db_breakpoint_list;
	     bkpt != 0;
	     bkpt = bkpt->link)
	{
	    db_printf("%s%p %5d    ",
		      db_map_current(bkpt->map) ? "*" : " ",
		      bkpt->map, bkpt->init_count);
	    db_printsym(bkpt->address, DB_STGY_PROC, db_printf);
	    db_printf("\n");
d242 1
a242 1
	db_delete_breakpoint(db_map_addr(addr), (db_addr_t)addr);
d251 1
a251 1
	    count = 1;
d253 1
a253 1
	db_set_breakpoint(db_map_addr(addr), (db_addr_t)addr, count);
a261 50
}

/*
 *	We want ddb to be usable before most of the kernel has been
 *	initialized.  In particular, current_thread() or kernel_map
 *	(or both) may be null.
 */

boolean_t
db_map_equal(struct vm_map *map1, struct vm_map *map2)
{
	return ((map1 == map2) ||
		((map1 == NULL) && (map2 == kernel_map)) ||
		((map1 == kernel_map) && (map2 == NULL)));
}

boolean_t
db_map_current(struct vm_map *map)
{
#if 0
	thread_t	thread;

	return ((map == NULL) ||
		(map == kernel_map) ||
		(((thread = current_thread()) != NULL) &&
		 (map == thread->proc->map)));
#else
	return (1);
#endif
}

struct vm_map *
db_map_addr(vaddr_t addr)
{
#if 0
	thread_t	thread;

	/*
	 *	We want to return kernel_map for all
	 *	non-user addresses, even when debugging
	 *	kernel tasks with their own maps.
	 */

	if ((VM_MIN_ADDRESS <= addr) &&
	    (addr < VM_MAX_ADDRESS) &&
	    ((thread = current_thread()) != NULL))
	    return thread->proc->map;
	else
#endif
	    return kernel_map;
@


1.12
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.11 2001/11/28 16:13:29 art Exp $	*/
d56 1
a56 1
db_breakpoint_alloc()
d58 1
a58 1
	register db_breakpoint_t	bkpt;
d75 1
a75 2
db_breakpoint_free(bkpt)
	register db_breakpoint_t	bkpt;
d82 1
a82 4
db_set_breakpoint(map, addr, count)
	struct vm_map  *map;
	db_addr_t	addr;
	int		count;
d84 1
a84 1
	register db_breakpoint_t	bkpt;
d115 1
a115 3
db_delete_breakpoint(map, addr)
	struct vm_map  *map;
	db_addr_t	addr;
d117 2
a118 2
	register db_breakpoint_t	bkpt;
	register db_breakpoint_t	*prev;
d138 1
a138 3
db_find_breakpoint(map, addr)
	struct vm_map  *map;
	db_addr_t	addr;
d140 1
a140 1
	register db_breakpoint_t	bkpt;
d154 1
a154 2
db_find_breakpoint_here(addr)
	db_addr_t	addr;
d162 1
a162 1
db_set_breakpoints()
d164 1
a164 1
	register db_breakpoint_t	bkpt;
d182 1
a182 1
db_clear_breakpoints()
d184 1
a184 1
	register db_breakpoint_t	bkpt;
d204 1
a204 2
db_set_temp_breakpoint(addr)
	db_addr_t	addr;
d233 1
a233 2
db_delete_temp_breakpoint(bkpt)
	db_breakpoint_t	bkpt;
d243 1
a243 1
db_list_breakpoints()
d245 1
a245 1
	register db_breakpoint_t	bkpt;
d268 1
a268 5
db_delete_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d276 1
a276 5
db_breakpoint_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d287 1
a287 5
db_listbreak_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d299 1
a299 2
db_map_equal(map1, map2)
	struct vm_map *map1, *map2;
d307 1
a307 2
db_map_current(map)
	struct vm_map *map;
d322 1
a322 2
db_map_addr(addr)
	vaddr_t addr;
@


1.11
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.10 2001/11/06 19:53:18 miod Exp $	*/
d271 1
a271 1
	    db_printsym(bkpt->address, DB_STGY_PROC);
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.11 2001/11/28 16:13:29 art Exp $	*/
d271 1
a271 1
	    db_printsym(bkpt->address, DB_STGY_PROC, db_printf);
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.9 2001/09/19 20:50:58 mickey Exp $	*/
d84 1
a84 1
	vm_map_t	map;
d120 1
a120 1
	vm_map_t	map;
d145 1
a145 1
	vm_map_t	map;
d323 1
a323 1
	vm_map_t	map1, map2;
d332 1
a332 1
	vm_map_t	map;
d346 1
a346 1
vm_map_t
@


1.9
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.8 1999/09/11 00:44:59 mickey Exp $	*/
a38 1
#include <vm/vm.h>
@


1.8
log
@s/vm_offset_t/vaddr_t/ s/vm_size_t/vsize_t/
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.7 1997/08/07 09:18:40 niklas Exp $	*/
d40 1
a314 2

#include <vm/vm_kern.h>
@


1.8.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.8 1999/09/11 00:44:59 mickey Exp $	*/
a39 1
#include <uvm/uvm_extern.h>
d314 2
@


1.8.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
@


1.8.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.8.4.2 2001/11/13 21:05:48 niklas Exp $	*/
d84 1
a84 1
	struct vm_map  *map;
d120 1
a120 1
	struct vm_map  *map;
d145 1
a145 1
	struct vm_map  *map;
d323 1
a323 1
	struct vm_map *map1, *map2;
d332 1
a332 1
	struct vm_map *map;
d346 1
a346 1
struct vm_map *
@


1.8.4.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d271 1
a271 1
	    db_printsym(bkpt->address, DB_STGY_PROC, db_printf);
@


1.7
log
@slight KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.6 1997/07/23 23:34:46 niklas Exp $	*/
d350 1
a350 1
	vm_offset_t addr;
@


1.6
log
@Support an DB_VALID_BREAKPOINT option for validation of breakpoints.
This can be very important in SOFTWARE_SSTEP systems as single stepping
otherwise frequently hoses the machine when trying to step through paths
used ny DDB itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.5 1997/07/19 22:31:16 niklas Exp $	*/
d181 4
a184 6
		    bkpt->bkpt_inst = db_get_value(bkpt->address,
						   BKPT_SIZE,
						   FALSE);
		    db_put_value(bkpt->address,
				 BKPT_SIZE,
				 BKPT_SET(bkpt->bkpt_inst));
@


1.5
log
@Include vm/vm.h everywhere it is needed to get at boolean_t (I would prefer
to have it in sys/types.h but that is problematic).  Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.4 1996/04/21 22:18:55 deraadt Exp $	*/
d95 7
d220 7
d230 1
a230 1
	    return 0;
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.3 1996/03/11 11:15:58 mickey Exp $	*/
d39 2
d211 1
a211 1
	register db_breakpoint_t	bkpt;
@


1.3
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_break.c,v 1.2 1996/02/20 13:35:32 mickey Exp $	*/
d254 1
a254 1
	    db_printf("%s%8x %5d    ",
@


1.2
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_break.c,v 1.6 1996/02/05 01:56:50 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d327 1
a327 1
		 (map == thread->task->map)));
d349 1
a349 1
	    return thread->task->map;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: db_break.c,v 1.5 1994/10/09 08:19:32 mycroft Exp $	*/
a40 1
#include <ddb/db_break.h>
d44 1
d289 1
d291 5
a295 1
db_listbreak_cmd()
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
