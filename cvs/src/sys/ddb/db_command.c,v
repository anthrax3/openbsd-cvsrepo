head	1.74;
access;
symbols
	OPENBSD_6_1:1.71.0.6
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.71.0.2
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.62.0.12
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.10
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.8
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.6
	OPENBSD_5_0:1.62.0.4
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.45.0.4
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.40.0.4
	OPENBSD_3_9_BASE:1.40
	OPENBSD_3_8:1.40.0.2
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.29
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.8
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.6
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2017.08.11.20.50.15;	author mpi;	state Exp;
branches;
next	1.73;
commitid	wVXEBQlY9db5AjLx;

1.73
date	2017.08.10.19.39.38;	author mpi;	state Exp;
branches;
next	1.72;
commitid	31PvZ4r4dQH5StiR;

1.72
date	2017.04.20.12.59.36;	author visa;	state Exp;
branches;
next	1.71;
commitid	35AK3Wv48Mc7uWnr;

1.71
date	2016.04.19.12.23.25;	author mpi;	state Exp;
branches;
next	1.70;
commitid	8RTokESmYJ4rQpkq;

1.70
date	2016.04.19.10.12.36;	author mpi;	state Exp;
branches;
next	1.69;
commitid	uzREFYXNwPSah65A;

1.69
date	2016.03.09.09.04.15;	author mpi;	state Exp;
branches;
next	1.68;
commitid	AEIAF7S6Z6Ey8k81;

1.68
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.67;
commitid	7AkssaZPPd7mA8h3;

1.67
date	2016.01.15.11.21.58;	author dlg;	state Exp;
branches;
next	1.66;
commitid	7LVjORDaEDODwOzR;

1.66
date	2015.12.23.01.39.02;	author mmcc;	state Exp;
branches;
next	1.65;
commitid	KfRgvabVql7qYf97;

1.65
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.64;
commitid	p4LJxGKbi0BU2cG6;

1.64
date	2014.07.11.14.36.44;	author uebayasi;	state Exp;
branches;
next	1.63;
commitid	V6bwQMCHbD31pEWD;

1.63
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2010.11.05.15.17.50;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.19.01.08.16;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.17.13.11.58;	author jasper;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.14.21.16.13;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.13.15.42.03;	author thib;	state Exp;
branches;
next	1.57;

1.57
date	2009.08.13.13.49.20;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.09.23.04.49;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2009.08.08.15.04.43;	author beck;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.15.19.05.14;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.20.22.46.49;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.18.13.36.56;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.23.12.31.57;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.14.17.52.36;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2007.11.05.19.23.24;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.01.11.54.03;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.30.14.31.28;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.24.21.10.14;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.11.21.17.58;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.20.18.29.23;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.10.10.50.16;	author uwe;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.03.16.49.56;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.25.08.41.19;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.21.22.41.12;	author andreas;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.13.21.49.23;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.25.03.21.50;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.15.12.56.29;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.10.23.02.53;	author tom;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.03.12.50.33;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.12.19.56.03;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.18.09.49.17;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.01.28.19.31.56;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.02.22.22.00;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.28.16.13.29;	author art;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.04.22.15.15;	author espie;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.04.58.42;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.18.23.17.25;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.07.11.21.39;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.07.09.40.02;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.02.26.01.38.22;	author art;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	98.09.01.04.26.59;	author art;	state Exp;
branches;
next	1.15;

1.15
date	98.08.30.15.38.25;	author art;	state Exp;
branches;
next	1.14;

1.14
date	98.02.25.19.53.46;	author weingart;	state Exp;
branches;
next	1.13;

1.13
date	97.09.08.19.46.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.07.19.45.20;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.01.27.07.53.53;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.01.16.08.03.56;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.31.10.37.24;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.05.12.23.09;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.18.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.19.16.08.30;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.19.07.43.48;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.11.11.16.01;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.13.35.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.02.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches;
next	;

1.17.6.1
date	2001.05.14.22.06.56;	author niklas;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2001.07.04.10.40.05;	author niklas;	state Exp;
branches;
next	1.17.6.3;

1.17.6.3
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.17.6.4;

1.17.6.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.17.6.5;

1.17.6.5
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.17.6.6;

1.17.6.6
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.17.6.7;

1.17.6.7
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.17.6.8;

1.17.6.8
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.17.6.9;

1.17.6.9
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.17.6.10;

1.17.6.10
date	2003.05.17.16.07.37;	author andreas;	state Exp;
branches;
next	1.17.6.11;

1.17.6.11
date	2004.02.19.10.56.12;	author niklas;	state Exp;
branches;
next	1.17.6.12;

1.17.6.12
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.05.19.21.52.44;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Merge DDBCTF into DDB.
@
text
@/*	$OpenBSD: db_command.c,v 1.73 2017/08/10 19:39:38 mpi Exp $	*/
/*	$NetBSD: db_command.c,v 1.20 1996/03/30 22:30:05 christos Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
 * Command dispatcher.
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/reboot.h>
#include <sys/extent.h>
#include <sys/pool.h>
#include <sys/msgbuf.h>
#include <sys/malloc.h>
#include <sys/mount.h>

#include <uvm/uvm_extern.h>
#include <machine/db_machdep.h>		/* type definitions */

#include <ddb/db_access.h>
#include <ddb/db_lex.h>
#include <ddb/db_output.h>
#include <ddb/db_command.h>
#include <ddb/db_break.h>
#include <ddb/db_watch.h>
#include <ddb/db_run.h>
#include <ddb/db_sym.h>
#include <ddb/db_variables.h>
#include <ddb/db_interface.h>
#include <ddb/db_extern.h>

#include <uvm/uvm_ddb.h>

/*
 * Exported global variables
 */
int		db_cmd_loop_done;
label_t		*db_recover;

/*
 * if 'ed' style: 'dot' is set at start of last item printed,
 * and '+' points to next line.
 * Otherwise: 'dot' points to next item, '..' points to last.
 */
boolean_t	db_ed_style = TRUE;

db_addr_t	db_dot;		/* current location */
db_addr_t	db_last_addr;	/* last explicit address typed */
db_addr_t	db_prev;	/* last address examined
				   or written */
db_addr_t	db_next;	/* next address to be examined
				   or written */

int	db_cmd_search(char *, struct db_command *, struct db_command **);
void	db_cmd_list(struct db_command *);
void	db_ctf_pprint_cmd(db_expr_t, int, db_expr_t,char *);
void	db_map_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_buf_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_malloc_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_mbuf_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_mount_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_show_all_mounts(db_expr_t, int, db_expr_t, char *);
void	db_show_all_vnodes(db_expr_t, int, db_expr_t, char *);
void	db_show_all_bufs(db_expr_t, int, db_expr_t, char *);
void	db_object_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_page_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_extent_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_pool_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_proc_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_uvmexp_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_vnode_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_nfsreq_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_nfsnode_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_help_cmd(db_expr_t, int, db_expr_t, char *);
void	db_fncall(db_expr_t, int, db_expr_t, char *);
void	db_boot_sync_cmd(db_expr_t, int, db_expr_t, char *);
void	db_boot_crash_cmd(db_expr_t, int, db_expr_t, char *);
void	db_boot_dump_cmd(db_expr_t, int, db_expr_t, char *);
void	db_boot_halt_cmd(db_expr_t, int, db_expr_t, char *);
void	db_boot_reboot_cmd(db_expr_t, int, db_expr_t, char *);
void	db_boot_poweroff_cmd(db_expr_t, int, db_expr_t, char *);
void	db_stack_trace_cmd(db_expr_t, int, db_expr_t, char *);
void	db_dmesg_cmd(db_expr_t, int, db_expr_t, char *);
void	db_show_panic_cmd(db_expr_t, int, db_expr_t, char *);
void	db_bcstats_print_cmd(db_expr_t, int, db_expr_t, char *);
void	db_struct_offset_cmd(db_expr_t, int, db_expr_t, char *);
void	db_struct_layout_cmd(db_expr_t, int, db_expr_t, char *);
void	db_show_regs(db_expr_t, boolean_t, db_expr_t, char *);
void	db_write_cmd(db_expr_t, boolean_t, db_expr_t, char *);
void	db_witness_display(db_expr_t, int, db_expr_t, char *);
void	db_witness_list(db_expr_t, int, db_expr_t, char *);
void	db_witness_list_all(db_expr_t, int, db_expr_t, char *);


/*
 * Utility routine - discard tokens through end-of-line.
 */
void
db_skip_to_eol(void)
{
	int	t;
	do {
	    t = db_read_token();
	} while (t != tEOL);
}

/*
 * Results of command search.
 */
#define	CMD_UNIQUE	0
#define	CMD_FOUND	1
#define	CMD_NONE	2
#define	CMD_AMBIGUOUS	3

/*
 * Search for command prefix.
 */
int
db_cmd_search(char *name, struct db_command *table, struct db_command **cmdp)
{
	struct db_command	*cmd;
	int			result = CMD_NONE;

	for (cmd = table; cmd->name != 0; cmd++) {
	    char *lp;
	    char *rp;
	    int  c;

	    lp = name;
	    rp = cmd->name;
	    while ((c = *lp) == *rp) {
		if (c == 0) {
		    /* complete match */
		    *cmdp = cmd;
		    return (CMD_UNIQUE);
		}
		lp++;
		rp++;
	    }
	    if (c == 0) {
		/* end of name, not end of command -
		   partial match */
		if (result == CMD_FOUND) {
		    result = CMD_AMBIGUOUS;
		    /* but keep looking for a full match -
		       this lets us match single letters */
		}
		else {
		    *cmdp = cmd;
		    result = CMD_FOUND;
		}
	    }
	}
	return (result);
}

void
db_cmd_list(struct db_command *table)
{
	struct db_command *cmd;

	for (cmd = table; cmd->name != 0; cmd++) {
	    db_printf("%-12s", cmd->name);
	    db_end_line(12);
	}
}

void
db_command(struct db_command **last_cmdp, struct db_command *cmd_table)
{
	struct db_command	*cmd;
	int		t;
	char		modif[TOK_STRING_SIZE];
	db_expr_t	addr, count;
	boolean_t	have_addr = FALSE;
	int		result;

	t = db_read_token();
	if (t == tEOL) {
	    /* empty line repeats last command, at 'next' */
	    cmd = *last_cmdp;
	    addr = (db_expr_t)db_next;
	    have_addr = FALSE;
	    count = 1;
	    modif[0] = '\0';
	}
	else if (t == tEXCL) {
	    db_fncall(0, 0, 0, NULL);
	    return;
	}
	else if (t != tIDENT) {
	    db_printf("?\n");
	    db_flush_lex();
	    return;
	}
	else {
	    /*
	     * Search for command
	     */
	    while (cmd_table) {
		result = db_cmd_search(db_tok_string,
				       cmd_table,
				       &cmd);
		switch (result) {
		    case CMD_NONE:
			db_printf("No such command\n");
			db_flush_lex();
			return;
		    case CMD_AMBIGUOUS:
			db_printf("Ambiguous\n");
			db_flush_lex();
			return;
		    default:
			break;
		}
		if ((cmd_table = cmd->more) != 0) {
		    t = db_read_token();
		    if (t != tIDENT) {
			db_cmd_list(cmd_table);
			db_flush_lex();
			return;
		    }
		}
	    }

	    if ((cmd->flag & CS_OWN) == 0) {
		/*
		 * Standard syntax:
		 * command [/modifier] [addr] [,count]
		 */
		t = db_read_token();
		if (t == tSLASH) {
		    t = db_read_token();
		    if (t != tIDENT) {
			db_printf("Bad modifier\n");
			db_flush_lex();
			return;
		    }
		    db_strlcpy(modif, db_tok_string, sizeof(modif));
		}
		else {
		    db_unread_token(t);
		    modif[0] = '\0';
		}

		if (db_expression(&addr)) {
		    db_dot = (db_addr_t) addr;
		    db_last_addr = db_dot;
		    have_addr = TRUE;
		}
		else {
		    addr = (db_expr_t) db_dot;
		    have_addr = FALSE;
		}
		t = db_read_token();
		if (t == tCOMMA) {
		    if (!db_expression(&count)) {
			db_printf("Count missing\n");
			db_flush_lex();
			return;
		    }
		}
		else {
		    db_unread_token(t);
		    count = -1;
		}
		if ((cmd->flag & CS_MORE) == 0) {
		    db_skip_to_eol();
		}
	    }
	}
	*last_cmdp = cmd;
	if (cmd != 0) {
	    /*
	     * Execute the command.
	     */
	    (*cmd->fcn)(addr, have_addr, count, modif);

	    if (cmd->flag & CS_SET_DOT) {
		/*
		 * If command changes dot, set dot to
		 * previous address displayed (if 'ed' style).
		 */
		if (db_ed_style) {
		    db_dot = db_prev;
		}
		else {
		    db_dot = db_next;
		}
	    }
	    else {
		/*
		 * If command does not change dot,
		 * set 'next' location to be the same.
		 */
		db_next = db_dot;
	    }
	}
}

/*ARGSUSED*/
void
db_buf_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	vfs_buf_print((void *) addr, full, db_printf);
}

/*ARGSUSED*/
void
db_map_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
        boolean_t full = FALSE;

        if (modif[0] == 'f')
                full = TRUE;

        uvm_map_printit((struct vm_map *) addr, full, db_printf);
}

/*ARGSUSED*/
void
db_malloc_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
#if defined(MALLOC_DEBUG)
	extern void debug_malloc_printit(int (*)(const char *, ...), vaddr_t);

	if (!have_addr)
		addr = 0;

	debug_malloc_printit(db_printf, (vaddr_t)addr);
#else
	malloc_printit(db_printf);
#endif
}

/*ARGSUSED*/
void
db_mbuf_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	m_print((void *)addr, db_printf);
}

/*ARGSUSED*/
void
db_socket_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	so_print((void *)addr, db_printf);
}

/*ARGSUSED*/
void
db_mount_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	vfs_mount_print((struct mount *) addr, full, db_printf);
}

void
db_show_all_mounts(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;
	struct mount *mp;

	if (modif[0] == 'f')
		full = TRUE;

	TAILQ_FOREACH(mp, &mountlist, mnt_list)
		vfs_mount_print(mp, full, db_printf);
}

extern struct pool vnode_pool;
void
db_show_all_vnodes(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	pool_walk(&vnode_pool, full, db_printf, vfs_vnode_print);
}

extern struct pool bufpool;
void
db_show_all_bufs(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	pool_walk(&bufpool, full, db_printf, vfs_buf_print);
}

/*ARGSUSED*/
void
db_object_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
        boolean_t full = FALSE;

        if (modif[0] == 'f')
                full = TRUE;

	uvm_object_printit((struct uvm_object *) addr, full, db_printf);
}

/*ARGSUSED*/
void
db_page_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
        boolean_t full = FALSE;

        if (modif[0] == 'f')
                full = TRUE;

	uvm_page_printit((struct vm_page *) addr, full, db_printf);
}

/*ARGSUSED*/
void
db_vnode_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	vfs_vnode_print((void *)addr, full, db_printf);
}

#ifdef NFSCLIENT
/*ARGSUSED*/
void
db_nfsreq_print_cmd(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	nfs_request_print((void *)addr, full, db_printf);
}

/*ARGSUSED*/
void
db_nfsnode_print_cmd(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;

	nfs_node_print((void *)addr, full, db_printf);
}
#endif


/*ARGSUSED*/
void
db_show_panic_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (panicstr)
		db_printf("%s\n", panicstr);
	else
		db_printf("the kernel did not panic\n");	/* yet */
}

/*ARGSUSED*/
void
db_extent_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	extent_print_all();
}

/*ARGSUSED*/
void
db_pool_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	pool_printit((struct pool *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
db_proc_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (!have_addr)
		addr = (db_expr_t)curproc;

	proc_printit((struct proc *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
db_uvmexp_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	uvmexp_print(db_printf);
}

void	bcstats_print(int (*)(const char *, ...));

/*ARGSUSED*/
void
db_bcstats_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	bcstats_print(db_printf);
}

/*
 * 'show' commands
 */

struct db_command db_show_all_cmds[] = {
	{ "procs",	db_show_all_procs,	0, NULL },
	{ "callout",	db_show_callout,	0, NULL },
	{ "pools",	db_show_all_pools,	0, NULL },
	{ "mounts",	db_show_all_mounts,	0, NULL },
	{ "vnodes",	db_show_all_vnodes,	0, NULL },
	{ "bufs",	db_show_all_bufs,	0, NULL },
#ifdef NFSCLIENT
	{ "nfsreqs",	db_show_all_nfsreqs,	0, NULL },
	{ "nfsnodes",	db_show_all_nfsnodes,	0, NULL },
#endif
#ifdef WITNESS
	{ "locks",	db_witness_list_all,	0, NULL },
#endif
	{ NULL, 	NULL, 			0, NULL }
};

struct db_command db_show_cmds[] = {
	{ "all",	NULL,			0,	db_show_all_cmds },
	{ "bcstats",	db_bcstats_print_cmd,	0,	NULL },
	{ "breaks",	db_listbreak_cmd, 	0,	NULL },
	{ "buf",	db_buf_print_cmd,	0,	NULL },
	{ "extents",	db_extent_print_cmd,	0,	NULL },
#ifdef WITNESS
	{ "locks",	db_witness_list,	0,	NULL },
#endif
	{ "malloc",	db_malloc_print_cmd,	0,	NULL },
	{ "map",	db_map_print_cmd,	0,	NULL },
	{ "mbuf",	db_mbuf_print_cmd,	0,	NULL },
	{ "mount",	db_mount_print_cmd,	0,	NULL },
#ifdef NFSCLIENT
	{ "nfsreq",	db_nfsreq_print_cmd,	0,	NULL },
	{ "nfsnode",	db_nfsnode_print_cmd,	0,	NULL },
#endif
	{ "object",	db_object_print_cmd,	0,	NULL },
#ifdef DDB_STRUCT
	{ "offset",	db_struct_offset_cmd,	CS_OWN,	NULL },
#endif
	{ "page",	db_page_print_cmd,	0,	NULL },
	{ "panic",	db_show_panic_cmd,	0,	NULL },
	{ "pool",	db_pool_print_cmd,	0,	NULL },
	{ "proc",	db_proc_print_cmd,	0,	NULL },
	{ "registers",	db_show_regs,		0,	NULL },
	{ "socket",	db_socket_print_cmd,	0,	NULL },
#ifdef DDB_STRUCT
	{ "struct",	db_struct_layout_cmd,	CS_OWN,	NULL },
#endif
	{ "uvmexp",	db_uvmexp_print_cmd,	0,	NULL },
	{ "vnode",	db_vnode_print_cmd,	0,	NULL },
	{ "watches",	db_listwatch_cmd, 	0,	NULL },
#ifdef WITNESS
	{ "witness",	db_witness_display,	0,	NULL },
#endif
	{ NULL,		NULL,			0,	NULL }
};

struct db_command db_boot_cmds[] = {
	{ "sync",	db_boot_sync_cmd,	0,	0 },
	{ "crash",	db_boot_crash_cmd,	0,	0 },
	{ "dump",	db_boot_dump_cmd,	0,	0 },
	{ "halt",	db_boot_halt_cmd,	0,	0 },
	{ "reboot",	db_boot_reboot_cmd,	0,	0 },
	{ "poweroff",	db_boot_poweroff_cmd,	0,	0 },
	{ NULL, }
};

struct db_command db_command_table[] = {
#ifdef DB_MACHINE_COMMANDS
  /* this must be the first entry, if it exists */
	{ "machine",    NULL,                   0,     		NULL},
#endif
	{ "print",	db_ctf_pprint_cmd,	CS_OWN,		NULL },
	{ "p",		db_ctf_pprint_cmd,	CS_OWN,		NULL },
	{ "examine",	db_examine_cmd,		CS_SET_DOT, 	NULL },
	{ "x",		db_examine_cmd,		CS_SET_DOT, 	NULL },
	{ "search",	db_search_cmd,		CS_OWN|CS_SET_DOT, NULL },
	{ "set",	db_set_cmd,		CS_OWN,		NULL },
	{ "write",	db_write_cmd,		CS_MORE|CS_SET_DOT, NULL },
	{ "w",		db_write_cmd,		CS_MORE|CS_SET_DOT, NULL },
	{ "delete",	db_delete_cmd,		0,		NULL },
	{ "d",		db_delete_cmd,		0,		NULL },
	{ "break",	db_breakpoint_cmd,	0,		NULL },
	{ "dwatch",	db_deletewatch_cmd,	0,		NULL },
	{ "watch",	db_watchpoint_cmd,	CS_MORE,	NULL },
	{ "step",	db_single_step_cmd,	0,		NULL },
	{ "s",		db_single_step_cmd,	0,		NULL },
	{ "continue",	db_continue_cmd,	0,		NULL },
	{ "c",		db_continue_cmd,	0,		NULL },
	{ "until",	db_trace_until_call_cmd,0,		NULL },
	{ "next",	db_trace_until_matching_cmd,0,		NULL },
	{ "match",	db_trace_until_matching_cmd,0,		NULL },
	{ "trace",	db_stack_trace_cmd,	0,		NULL },
	{ "call",	db_fncall,		CS_OWN,		NULL },
	{ "ps",		db_show_all_procs,	0,		NULL },
	{ "callout",	db_show_callout,	0,		NULL },
	{ "show",	NULL,			0,		db_show_cmds },
	{ "boot",	NULL,			0,		db_boot_cmds },
	{ "help",	db_help_cmd,		0,		NULL },
	{ "hangman",	db_hangman,		0,		NULL },
	{ "dmesg",	db_dmesg_cmd,		0,		NULL },
	{ NULL, 	NULL,			0,		NULL }
};

#ifdef DB_MACHINE_COMMANDS

/* this function should be called to install the machine dependent
   commands. It should be called before the debugger is enabled  */
void db_machine_commands_install(struct db_command *ptr)
{
  db_command_table[0].more = ptr;
  return;
}

#endif

struct db_command	*db_last_command = NULL;

void
db_help_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	db_cmd_list(db_command_table);
}

void
db_command_loop(void)
{
	label_t		db_jmpbuf;
	label_t		*savejmp;
	extern int	db_output_line;

	/*
	 * Initialize 'prev' and 'next' to dot.
	 */
	db_prev = db_dot;
	db_next = db_dot;

	db_cmd_loop_done = 0;

	savejmp = db_recover;
	db_recover = &db_jmpbuf;
	(void) setjmp(&db_jmpbuf);

	while (!db_cmd_loop_done) {

		if (db_print_position() != 0)
			db_printf("\n");
		db_output_line = 0;

#ifdef MULTIPROCESSOR
		db_printf("ddb{%d}> ", CPU_INFO_UNIT(curcpu()));
#else
		db_printf("ddb> ");
#endif
		(void) db_read_line();

		db_command(&db_last_command, db_command_table);
	}

	db_recover = savejmp;
}

void
db_error(char *s)
{
	if (s)
		db_printf("%s", s);
	db_flush_lex();
	if (db_recover != NULL)
		longjmp(db_recover);
}


/*
 * Call random function:
 * !expr(arg,arg,arg)
 */
/*ARGSUSED*/
void
db_fncall(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	db_expr_t	fn_addr;
#define	MAXARGS		11
	db_expr_t	args[MAXARGS];
	int		nargs = 0;
	db_expr_t	retval;
	db_expr_t	(*func)(db_expr_t, ...);
	int		t;
	char		tmpfmt[28];

	if (!db_expression(&fn_addr)) {
	    db_printf("Bad function\n");
	    db_flush_lex();
	    return;
	}
	func = (db_expr_t (*)(db_expr_t, ...)) fn_addr;

	t = db_read_token();
	if (t == tLPAREN) {
	    if (db_expression(&args[0])) {
		nargs++;
		while ((t = db_read_token()) == tCOMMA) {
		    if (nargs == MAXARGS) {
			db_printf("Too many arguments\n");
			db_flush_lex();
			return;
		    }
		    if (!db_expression(&args[nargs])) {
			db_printf("Argument missing\n");
			db_flush_lex();
			return;
		    }
		    nargs++;
		}
		db_unread_token(t);
	    }
	    if (db_read_token() != tRPAREN) {
		db_printf("?\n");
		db_flush_lex();
		return;
	    }
	}
	db_skip_to_eol();

	while (nargs < MAXARGS) {
	    args[nargs++] = 0;
	}

	retval = (*func)(args[0], args[1], args[2], args[3], args[4],
			 args[5], args[6], args[7], args[8], args[9]);
	db_printf("%s\n", db_format(tmpfmt, sizeof tmpfmt, retval,
	    DB_FORMAT_N, 1, 0));
}

void
db_boot_sync_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_AUTOBOOT | RB_TIMEBAD | RB_USERREQ);
}

void
db_boot_crash_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_NOSYNC | RB_DUMP | RB_TIMEBAD | RB_USERREQ);
}

void
db_boot_dump_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_DUMP | RB_TIMEBAD | RB_USERREQ);
}

void
db_boot_halt_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_NOSYNC | RB_HALT | RB_TIMEBAD | RB_USERREQ);
}

void
db_boot_reboot_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD | RB_USERREQ);
}

void
db_boot_poweroff_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	reboot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD | RB_USERREQ);
}

void
db_dmesg_cmd(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	int i, off;
	char *p;

	if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
		return;
	off = msgbufp->msg_bufx;
	if (off > msgbufp->msg_bufs)
		off = 0;
	for (i = 0, p = msgbufp->msg_bufc + off;
	    i < msgbufp->msg_bufs; i++, p++) {
		if (p >= msgbufp->msg_bufc + msgbufp->msg_bufs)
			p = msgbufp->msg_bufc;
		if (*p != '\0')
			db_putchar(*p);
	}
	db_putchar('\n');
}

void
db_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif)
{
	db_stack_trace_print(addr, have_addr, count, modif, db_printf);
}

void
db_show_regs(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	struct db_variable *regp;
	db_expr_t	value, offset;
	char *		name;
	char		tmpfmt[28];

	for (regp = db_regs; regp < db_eregs; regp++) {
	    db_read_variable(regp, &value);
	    db_printf("%-12s%s", regp->name, db_format(tmpfmt, sizeof tmpfmt,
	      (long)value, DB_FORMAT_N, 1, sizeof(long) * 3));
	    db_find_xtrn_sym_and_offset((db_addr_t)value, &name, &offset);
	    if (name != 0 && offset <= db_maxoff && offset != value) {
		db_printf("\t%s", name);
		if (offset != 0)
		    db_printf("+%s", db_format(tmpfmt, sizeof tmpfmt,
		      (long)offset, DB_FORMAT_R, 1, 0));
	    }
	    db_printf("\n");
	}
	db_print_loc_and_inst(PC_REGS(&ddb_regs));
}

/*
 * Write to file.
 */
/*ARGSUSED*/
void
db_write_cmd(db_expr_t	address, boolean_t have_addr, db_expr_t count,
    char *modif)
{
	db_addr_t	addr;
	db_expr_t	old_value;
	db_expr_t	new_value;
	int		size;
	boolean_t	wrote_one = FALSE;
	char		tmpfmt[28];

	addr = (db_addr_t) address;

	switch (modif[0]) {
	case 'b':
		size = 1;
		break;
	case 'h':
		size = 2;
		break;
	case 'l':
	case '\0':
		size = 4;
		break;
#ifdef __LP64__
	case 'q':
		size = 8;
		break;
#endif
	default:
		size = -1;
		db_error("Unknown size\n");
		/*NOTREACHED*/
	}

	while (db_expression(&new_value)) {
		old_value = db_get_value(addr, size, FALSE);
		db_printsym(addr, DB_STGY_ANY, db_printf);
		db_printf("\t\t%s\t", db_format(tmpfmt, sizeof tmpfmt,
		    old_value, DB_FORMAT_N, 0, 8));
		db_printf("=\t%s\n",  db_format(tmpfmt, sizeof tmpfmt,
		    new_value, DB_FORMAT_N, 0, 8));
		db_put_value(addr, size, new_value);
		addr += size;

		wrote_one = TRUE;
	}

	if (!wrote_one) {
		db_error("Nothing written.\n");
		/*NOTREACHED*/
	}

	db_next = addr;
	db_prev = addr - size;

	db_skip_to_eol();
}
@


1.73
log
@With a CTF kernel, DDB's print command will now pretty-print symbols.

Casting a type is not yet supported.

ok kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.72 2017/04/20 12:59:36 visa Exp $	*/
a619 1
#ifdef DDBCTF
a621 3
#else
	{ "print",	db_print_cmd,		0,		NULL },
#endif
@


1.72
log
@Add a port of witness(4) lock validation tool from FreeBSD.

Go-ahead from kettenis@@, guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.71 2016/04/19 12:23:25 mpi Exp $	*/
d82 1
d620 4
d625 1
@


1.71
log
@Do not expose private functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.70 2016/04/19 10:12:36 mpi Exp $	*/
d115 3
d559 3
d571 3
d598 3
@


1.70
log
@Keep db_write_cmd() in the only place where it is used, just like we did
with db_show_regs().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.69 2016/03/09 09:04:15 mpi Exp $	*/
d80 35
a114 2
void db_show_regs(db_expr_t, boolean_t, db_expr_t, char *);
void db_write_cmd(db_expr_t, boolean_t, db_expr_t, char *);
@


1.69
log
@Move db_show_regs() in the only file where it is used and turn it private.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.68 2016/01/25 14:30:30 mpi Exp $	*/
d46 1
d81 2
d821 63
@


1.68
log
@Kill trailing whitespaces.  No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.67 2016/01/15 11:21:58 dlg Exp $	*/
d52 1
d79 2
d794 24
@


1.67
log
@add a "show socket" command to ddb

should help inspecting socket issues in the future.

enthusiasm from mpi@@ bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.66 2015/12/23 01:39:02 mmcc Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d292 1
a292 1
				   
d301 1
a301 1
        
d392 1
a392 1
        
d404 1
a404 1
        
d412 1
a412 1
void     
d425 1
a425 1
void     
d438 1
a438 1
void     
@


1.66
log
@assign pointers NULL rather than 0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.65 2015/03/14 03:38:46 jsg Exp $	*/
d333 7
d543 1
@


1.65
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.64 2014/07/11 14:36:44 uebayasi Exp $	*/
d603 1
a603 1
struct db_command	*db_last_command = 0;
@


1.64
log
@reboot(9): Add MI reboot entry function

Now, for kernel to "reboot" (reboot, halt, or shutdown), MD boot(9) is called
in some places.  This change introduces a new MI function reboot(9) which is
simply a wrapper to call MD boot(9).

OK kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 1
#include <ddb/db_sym.h>
@


1.63
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.62 2010/11/05 15:17:50 claudio Exp $	*/
d725 1
a725 1
	boot(RB_AUTOBOOT | RB_TIMEBAD | RB_USERREQ);
d731 1
a731 1
	boot(RB_NOSYNC | RB_DUMP | RB_TIMEBAD | RB_USERREQ);
d737 1
a737 1
	boot(RB_DUMP | RB_TIMEBAD | RB_USERREQ);
d743 1
a743 1
	boot(RB_NOSYNC | RB_HALT | RB_TIMEBAD | RB_USERREQ);
d749 1
a749 1
	boot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD | RB_USERREQ);
d755 1
a755 1
	boot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD | RB_USERREQ);
@


1.62
log
@Implement m_print as real ddb command "show mbuf addr" in the way other
such commands are implemented.
"Ja! You'll need to update ddb.4 as well, of course." miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.61 2010/01/19 01:08:16 guenther Exp $	*/
d353 1
a353 1
	CIRCLEQ_FOREACH(mp, &mountlist, mnt_list)
@


1.61
log
@A couple #ifdefs were missed when the final name of the DDB_STRUCT
option was settled on.  Fix those last couple so that the new
commands are actually accessible.

"Oops" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.60 2009/08/17 13:11:58 jasper Exp $	*/
d327 7
d522 1
@


1.60
log
@dd 'show all bufs' to show all the buffers in the system

ok beck@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.59 2009/08/14 21:16:13 thib Exp $	*/
d521 1
a521 1
#ifdef DDB_STRUCT_INFORMATION
d529 1
a529 1
#ifdef DDB_STRUCT_INFORMATION
@


1.59
log
@add ddb functions to be able to show all the nfsnodes in the system
and rewrite the nfsreq code to use pool_walk().

OK beck@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.55 2009/08/08 15:04:43 beck Exp $	*/
d294 1
a294 1
	vfs_buf_print((struct buf *) addr, full, db_printf);
d362 12
d499 1
@


1.58
log
@fix a typo its supposed to be show all vnodes not show all vnodes,

ddb does keyword matching so i missed this.
spotted by jasper@@
@
text
@d401 2
a402 1
db_nfsreq_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
d409 14
a422 1
	db_nfsreq_print((struct nfsreq *) addr, full, db_printf);
d488 2
a489 1
	{ "nfsreq",	db_show_all_nfsreqs,	0, NULL },
d505 1
@


1.57
log
@add a show all vnodes command, use dlg's nice pool_walk() to accomplish
this.

ok beck@@, dlg@@
@
text
@d472 1
a472 1
	{ "vnodes,",	db_show_all_vnodes,	0, NULL },
@


1.56
log
@Introduce option DDB_STRUCT. Kernels compiled with this option (except on
a few arches where toolchain limitations apply) will embed some symbolic
information about the various structs used within the kernel, and have
new ddb commands allowing struct display and some useful information
gathering. Kernel rodata increase varies accross platforms from ~150KB to
~300KB.
This option is not enabled by default.
@
text
@d350 12
d395 1
a395 1
	vfs_vnode_print((struct vnode *) addr, full, db_printf);
d472 1
@


1.55
log
@two things:
1) fix buffer cache low water mark to allow for extremely low memory machines
without dying
2) Add "show bcstats" to ddb to allow for looking at the buffer cache statistics in ddb

ok art@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.53 2009/06/17 01:30:30 thib Exp $	*/
d475 3
d479 3
d487 3
a491 3
#ifdef NFSCLIENT
	{ "nfsreq",	db_nfsreq_print_cmd,	0,	NULL },
#endif
@


1.54
log
@Check db_recover for NULL before longjmp(db_recover) in db_error(), as it can
be NULL on panic. Of course, panic usually never produce enough output to
hit db_more(), except when it's cold and we run an automatic traceback;
aborting the traceback with `q' would then lead to undefined behaviour.
@
text
@d442 9
d468 1
@


1.53
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.52 2009/06/03 22:09:30 thib Exp $	*/
d590 2
a591 1
	longjmp(db_recover);
@


1.52
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.50 2009/01/18 13:36:56 thib Exp $	*/
a41 1
#include <sys/buf.h>
a298 13
db_bufq_print_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t full = FALSE;

	if (modif[0] == 'f')
		full = TRUE;
				   
	db_bufq_print((struct bufq *) addr, full, db_printf);
}


/*ARGSUSED*/
void
a460 1
	{ "bufq",	db_bufq_print_cmd,	0,	NULL },
@


1.51
log
@Let this compile on landisk (and other configs) by wrapping the nfs
debug stuff inside #ifdef NFSCLIENT.

prompted by todd, miod
@
text
@d42 1
d300 13
d475 1
@


1.50
log
@Add nfs ddb hooks, for now only to show all the outstanding nfsreq's
and to print out struct nfsreq.

"get it in so people can pound on it" blambert@@
OK and information_s_ on the manpage from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.49 2008/03/23 12:31:57 miod Exp $	*/
d386 1
d398 1
d451 1
d453 1
d473 1
d475 1
@


1.49
log
@show all mounts command for ddb. From mickey a long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.48 2007/11/14 17:52:36 miod Exp $	*/
d387 13
d449 1
d469 1
@


1.48
log
@Be consistent in db_cmd_loop_done declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.47 2007/11/05 19:23:24 miod Exp $	*/
d41 1
d337 13
d435 1
@


1.47
log
@temporary ddb buffers need to be a bit larger on 64 bit systems to cope with
some radix configurations.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.46 2007/09/01 11:54:03 miod Exp $	*/
d61 1
a61 1
boolean_t	db_cmd_loop_done;
@


1.46
log
@Use db_format() instead of ddb-specific format specifiers; no functional
change inteded.
ok ray@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.45 2006/09/30 14:31:28 mickey Exp $	*/
d573 1
a573 1
	char		tmpfmt[24];
@


1.45
log
@no malloc debug but configured kmemstats allow 'sh mal' to print smth useful; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.44 2006/08/24 21:10:14 miod Exp $	*/
d573 1
d615 2
a616 1
	db_printf("%#n\n", retval);
@


1.44
log
@Off-by-one in ``dmesg'' command; it takes a vax to find such bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.43 2006/07/11 21:17:58 mickey Exp $	*/
d40 1
d320 1
a320 1
	db_printf("Malloc debugging not enabled.\n");
@


1.43
log
@add mount/vnode/buf and softdep printing commands; tested on a few archs and will make pedro happy too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.42 2006/05/20 18:29:23 mickey Exp $	*/
d665 1
a665 1
		if (p > msgbufp->msg_bufc + msgbufp->msg_bufs)
@


1.42
log
@add show all pools command listing all pools as vmstat -m does; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.41 2006/03/13 06:23:20 jsg Exp $	*/
d285 12
d306 1
d325 12
d359 13
d426 1
d430 1
d438 1
@


1.41
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.40 2005/05/10 10:50:16 uwe Exp $	*/
d381 1
@


1.40
log
@db_printf(s) -> db_printf("%s", s) from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.39 2005/01/03 16:49:56 miod Exp $	*/
d81 1
a81 1
db_skip_to_eol()
d101 1
a101 4
db_cmd_search(name, table, cmdp)
	char			*name;
	struct db_command	*table;
	struct db_command	**cmdp;	/* out */
d107 3
a109 3
	    register char *lp;
	    register char *rp;
	    register int  c;
d140 1
a140 2
db_cmd_list(table)
	struct db_command *table;
d142 1
a142 1
	register struct db_command *cmd;
d151 1
a151 3
db_command(last_cmdp, cmd_table)
	struct db_command	**last_cmdp;	/* IN_OUT */
	struct db_command	*cmd_table;
d285 1
a285 5
db_map_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d296 1
a296 5
db_malloc_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d312 1
a312 5
db_object_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d324 1
a324 5
db_page_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d335 1
a335 5
db_show_panic_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d345 1
a345 5
db_extent_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d352 1
a352 5
db_pool_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d359 1
a359 5
db_proc_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d369 1
a369 5
db_uvmexp_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d451 1
a451 2
void db_machine_commands_install(ptr)
struct db_command *ptr;
d462 1
a462 5
db_help_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int	haddr;
	db_expr_t count;
	char	*modif;
d468 1
a468 1
db_command_loop()
d506 1
a506 2
db_error(s)
	char *s;
d521 1
a521 5
db_fncall(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d575 1
a575 5
db_boot_sync_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d581 1
a581 5
db_boot_crash_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d587 1
a587 5
db_boot_dump_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d593 1
a593 5
db_boot_halt_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d599 1
a599 5
db_boot_reboot_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d605 1
a605 5
db_boot_poweroff_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d611 1
a611 5
db_dmesg_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int	haddr;
	db_expr_t count;
	char	*modif;
@


1.39
log
@Add "show panic" command to ddb, to easily retrieve the panic message.
Will hopefully bring us better panic reports.

From Joris Vink.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.38 2004/06/25 08:41:19 art Exp $	*/
d557 1
a557 1
	    db_printf(s);
@


1.38
log
@Instead of accessing ci_dev (that's an MI field), provide a marco that
translates a cpu_info structure into a human-readable cpu number.

drahn@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.37 2004/06/21 22:41:12 andreas Exp $	*/
d356 13
d434 1
@


1.37
log
@Make 'machine ddbcpu' work, and use CPU device number instead of APIC id
KNF lesson and ok from niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.36 2004/06/13 21:49:23 niklas Exp $	*/
d526 1
a526 1
		db_printf("ddb{%d}> ", curcpu()->ci_dev.dv_unit);
@


1.36
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 5
#ifdef MULTIPROCESSOR
boolean_t	db_switch_cpu;
long		db_switch_to_cpu;
#endif

a506 5
#ifdef MULTIPROCESSOR
	db_switch_cpu = 0;
	db_enter_ddb();
#endif /* MULTIPROCESSOR */

d526 1
a526 1
		db_printf("ddb{%ld}> ", (long)cpu_number());
a535 13

#ifdef MULTIPROCESSOR
	if (db_switch_cpu) {
		db_printf("Moving ddb to cpu %d\n", db_switch_to_cpu);
		curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		db_movetocpu(db_switch_to_cpu);
		while (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP
		    || curcpu()->ci_ddb_paused == CI_DDB_STOPPED)
			;	/* Do nothing */
	} else {
		db_leave_ddb();
	}
#endif /* MULTIPROCESSOR */
@


1.35
log
@kill unbounded string op.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.34 2004/03/15 12:56:29 aaron Exp $	*/
d63 5
d512 5
d530 1
d535 3
d539 1
d546 13
@


1.34
log
@Remove errant semi-colon. miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.33 2004/03/10 23:02:53 tom Exp $	*/
d227 1
a227 1
		    db_strcpy(modif, db_tok_string);
@


1.33
log
@Ensure that we obey a user's ddb> boot reboot command even if the system
is cold (during startup).

This adds RB_USERREQ to sys/reboot.h, uses it in the ddb commands, and
ensures that */*/machdep.c:boot() won't set RB_HALT when cold if this
flag is set.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.32 2003/12/03 12:50:33 markus Exp $	*/
d686 1
a686 1
		if (*p != '\0');
@


1.32
log
@add dmesg command; ok deraadt, mcbride, henning and more
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.31 2003/05/12 19:56:03 mickey Exp $	*/
d614 1
a614 1
	boot(RB_AUTOBOOT | RB_TIMEBAD);
d624 1
a624 1
	boot(RB_NOSYNC | RB_DUMP | RB_TIMEBAD);
d634 1
a634 1
	boot(RB_DUMP | RB_TIMEBAD);
d644 1
a644 1
	boot(RB_NOSYNC | RB_HALT | RB_TIMEBAD);
d654 1
a654 1
	boot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD);
d664 1
a664 1
	boot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD);
@


1.31
log
@sho proc [addr] to print some proc's field; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.30 2003/02/12 14:41:07 jason Exp $	*/
d39 1
d471 1
d665 25
@


1.30
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.29 2002/05/18 09:49:17 art Exp $	*/
d379 14
d421 1
@


1.29
log
@Rename the MD db_stack_trace_cmd to db_stack_trace_print. Add an argument
that specifies which printf funciton it should use. Implement
db_stack_trace_cmd in MI code.

Thanks to miod@@ for all the tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.28 2002/03/14 03:16:03 millert Exp $	*/
d68 7
@


1.28
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.27 2002/03/14 01:26:51 millert Exp $	*/
d641 7
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.26 2002/01/28 19:31:56 miod Exp $	*/
d305 1
a305 1
	extern void debug_malloc_printit __P((int (*)(const char *, ...), vaddr_t));
@


1.26
log
@Add "boot reboot" to please jason@@ and "boot poweroff" to please drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.25 2002/01/02 22:22:00 miod Exp $	*/
d305 1
a305 1
	extern void debug_malloc_printit __P((int (*) __P((const char *, ...)), vaddr_t));
d537 1
a537 1
	db_expr_t	(*func) __P((db_expr_t, ...));
d545 1
a545 1
	func = (db_expr_t (*) __P((db_expr_t, ...))) fn_addr;
@


1.25
log
@Add more vocabulary (commands) to ddb, from NetBSD.
ok art@@
(manual page update coming soon)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.24 2001/11/28 16:13:29 art Exp $	*/
d411 2
d621 20
@


1.24
log
@zap some typedefs.
vm_map_t -> struct vm_map *
vm_map_entry_t -> struct vm_map_entry *
simple_lock_data_t -> struct simplelock

(uvm not done yet, coming in the next commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.23 2001/11/06 19:53:18 miod Exp $	*/
d38 1
d334 16
d359 22
a392 1
	{ "registers",	db_show_regs,		0,	NULL },
d394 2
a395 1
	{ "watches",	db_listwatch_cmd, 	0,	NULL },
d398 6
a403 3
	{ "extents",	db_extent_print_cmd,	0,	NULL },
	{ "malloc",	db_malloc_print_cmd,	0,	NULL },
	{ NULL,		NULL,			0,	NULL, }
@


1.24.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.26 2002/01/28 19:31:56 miod Exp $	*/
a37 1
#include <sys/pool.h>
a332 16
db_page_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
        boolean_t full = FALSE;
        
        if (modif[0] == 'f')
                full = TRUE;

	uvm_page_printit((struct vm_page *) addr, full, db_printf);
}

/*ARGSUSED*/
void
a341 22
/*ARGSUSED*/
void
db_pool_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	pool_printit((struct pool *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
db_uvmexp_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	uvmexp_print(db_printf);
}

d354 1
d356 3
d361 1
a361 8
	{ "map",	db_map_print_cmd,	0,	NULL },
	{ "object",	db_object_print_cmd,	0,	NULL },
	{ "page",	db_page_print_cmd,	0,	NULL },
	{ "pool",	db_pool_print_cmd,	0,	NULL },
	{ "registers",	db_show_regs,		0,	NULL },
	{ "uvmexp",	db_uvmexp_print_cmd,	0,	NULL },
	{ "watches",	db_listwatch_cmd, 	0,	NULL },
	{ NULL,		NULL,			0,	NULL }
a368 2
	{ "reboot",	db_boot_reboot_cmd,	0,	0 },
	{ "poweroff",	db_boot_poweroff_cmd,	0,	0 },
a576 20
}

void
db_boot_reboot_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	boot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD);
}

void
db_boot_poweroff_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	boot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD);
@


1.24.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.24.2.1 2002/01/31 22:55:29 niklas Exp $	*/
d305 1
a305 1
	extern void debug_malloc_printit(int (*)(const char *, ...), vaddr_t);
d537 1
a537 1
	db_expr_t	(*func)(db_expr_t, ...);
d545 1
a545 1
	func = (db_expr_t (*)(db_expr_t, ...)) fn_addr;
a640 7
}

void
db_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif)
{
	db_stack_trace_print(addr, have_addr, count, modif, db_printf);
@


1.24.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a68 7
db_addr_t	db_dot;		/* current location */
db_addr_t	db_last_addr;	/* last explicit address typed */
db_addr_t	db_prev;	/* last address examined
				   or written */
db_addr_t	db_next;	/* next address to be examined
				   or written */

a371 14
db_proc_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	if (!have_addr)
		addr = (db_expr_t)curproc;

	proc_printit((struct proc *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
a399 1
	{ "proc",	db_proc_print_cmd,	0,	NULL },
@


1.23
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.22 2001/07/04 22:15:15 espie Exp $	*/
d293 1
a293 1
        uvm_map_printit((vm_map_t) addr, full, db_printf);
@


1.22
log
@missed EOL at EOF
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.21 2001/06/27 04:58:42 art Exp $	*/
d39 1
a39 1
#include <vm/vm.h>
a52 3
#include <vm/vm.h>

#include <uvm/uvm_extern.h>
@


1.21
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.20 2001/04/18 23:17:25 art Exp $	*/
d580 1
a580 1
}@


1.20
log
@New boot command: boot halt.
Don't sync, don't dump, just halt.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.19 2000/06/07 11:21:39 art Exp $	*/
a54 1
#ifdef UVM
a56 1
#endif
a295 1
#if defined(UVM)
a296 3
#else
        _vm_map_print((vm_map_t) addr, full, db_printf);
#endif
a330 1
#if defined(UVM)
a331 3
#else
        _vm_object_print((vm_object_t) addr, full, db_printf);
#endif
@


1.19
log
@Allow passing an address to 'show malloc' and print out some information about
that address.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.18 2000/06/07 09:40:02 art Exp $	*/
d381 2
a382 1
	{ (char *)0, }
d581 10
@


1.18
log
@Add 'show malloc' that prints out malloc debugging information if available.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17 1999/02/26 01:38:22 art Exp $	*/
d313 1
a313 1
	extern void debug_malloc_printit __P((int (*) __P((const char *, ...))));
d315 4
a318 1
	debug_malloc_printit(db_printf);
@


1.17
log
@uvm compat
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.16 1998/09/01 04:26:59 art Exp $	*/
d304 16
d370 1
@


1.17.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.19 2000/06/07 11:21:39 art Exp $	*/
a303 19
/*ARGSUSED*/
void
db_malloc_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
#if defined(MALLOC_DEBUG)
	extern void debug_malloc_printit __P((int (*) __P((const char *, ...)), vaddr_t));

	if (!have_addr)
		addr = 0;

	debug_malloc_printit(db_printf, (vaddr_t)addr);
#else
	db_printf("Malloc debugging not enabled.\n");
#endif
}
a353 1
	{ "malloc",	db_malloc_print_cmd,	0,	NULL },
@


1.17.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17.6.1 2001/05/14 22:06:56 niklas Exp $	*/
d55 1
d58 1
d298 1
d300 3
d337 1
d339 3
d381 1
a381 2
	{ "halt",	db_boot_halt_cmd,	0,	0 },
	{ NULL, }
a579 10

void
db_boot_halt_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	boot(RB_NOSYNC | RB_HALT | RB_TIMEBAD);
}@


1.17.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17.6.2 2001/07/04 10:40:05 niklas Exp $	*/
d580 1
a580 1
}
@


1.17.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
#include <uvm/uvm_extern.h>
d53 3
@


1.17.6.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17.6.4 2001/11/13 21:05:48 niklas Exp $	*/
d293 1
a293 1
        uvm_map_printit((struct vm_map *) addr, full, db_printf);
@


1.17.6.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 1
#include <sys/pool.h>
a332 16
db_page_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
        boolean_t full = FALSE;
        
        if (modif[0] == 'f')
                full = TRUE;

	uvm_page_printit((struct vm_page *) addr, full, db_printf);
}

/*ARGSUSED*/
void
a341 22
/*ARGSUSED*/
void
db_pool_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	pool_printit((struct pool *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
db_uvmexp_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	uvmexp_print(db_printf);
}

d354 1
d356 3
d361 1
a361 8
	{ "map",	db_map_print_cmd,	0,	NULL },
	{ "object",	db_object_print_cmd,	0,	NULL },
	{ "page",	db_page_print_cmd,	0,	NULL },
	{ "pool",	db_pool_print_cmd,	0,	NULL },
	{ "registers",	db_show_regs,		0,	NULL },
	{ "uvmexp",	db_uvmexp_print_cmd,	0,	NULL },
	{ "watches",	db_listwatch_cmd, 	0,	NULL },
	{ NULL,		NULL,			0,	NULL }
a368 2
	{ "reboot",	db_boot_reboot_cmd,	0,	0 },
	{ "poweroff",	db_boot_poweroff_cmd,	0,	0 },
a576 20
}

void
db_boot_reboot_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	boot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD);
}

void
db_boot_poweroff_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	boot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD);
@


1.17.6.7
log
@Merge in -current from about a week ago
@
text
@d305 1
a305 1
	extern void debug_malloc_printit(int (*)(const char *, ...), vaddr_t);
d537 1
a537 1
	db_expr_t	(*func)(db_expr_t, ...);
d545 1
a545 1
	func = (db_expr_t (*)(db_expr_t, ...)) fn_addr;
@


1.17.6.8
log
@Sync the SMP branch with 3.3
@
text
@a68 7
db_addr_t	db_dot;		/* current location */
db_addr_t	db_last_addr;	/* last explicit address typed */
db_addr_t	db_prev;	/* last address examined
				   or written */
db_addr_t	db_next;	/* next address to be examined
				   or written */

a640 7
}

void
db_stack_trace_cmd(db_expr_t addr, boolean_t have_addr, db_expr_t count,
    char *modif)
{
	db_stack_trace_print(addr, have_addr, count, modif, db_printf);
@


1.17.6.9
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a378 14
db_proc_print_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
{
	if (!have_addr)
		addr = (db_expr_t)curproc;

	proc_printit((struct proc *)addr, modif, db_printf);
}

/*ARGSUSED*/
void
a406 1
	{ "proc",	db_proc_print_cmd,	0,	NULL },
@


1.17.6.10
log
@Some i386-specific stuff:
Stop other CPUs when entering ddb
'machine sysregs' shows system registers not usually used by applications
'machine cpuinfo' shows the status of the processors
'machine startcpu n' starts CPU n
'machine stopcpu n' stops CPU n
'machine ddbcpu n' transfers ddb control to CPU n (not very useful yet
though since the second processor can't use the keyboard...)

Niklas said that I should test this first to at least make sure it
compiles, but I'm too anxious to do my first commit. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17.6.9 2003/05/16 00:29:41 niklas Exp $	*/
a61 5
#ifdef MULTIPROCESSOR
boolean_t	db_switch_cpu;
long		db_switch_to_cpu;
#endif

a504 5
#ifdef MULTIPROCESSOR
	db_switch_cpu = 0;
	db_enter_ddb();
#endif /* MULTIPROCESSOR */

a517 1

a521 3
#ifdef MULTIPROCESSOR
		db_printf("ddb{%ld}> ", (long)cpu_number());
#else
a522 1
#endif
a528 13

#ifdef MULTIPROCESSOR
	if (db_switch_cpu) {
		db_printf("Moving ddb to cpu %d\n", db_switch_to_cpu);
		curcpu()->ci_ddb_paused = CI_DDB_STOPPED;
		db_movetocpu(db_switch_to_cpu);
		while (curcpu()->ci_ddb_paused == CI_DDB_SHOULDSTOP
		    || curcpu()->ci_ddb_paused == CI_DDB_STOPPED)
			;	/* Do nothing */
	} else {
		db_leave_ddb();
	}
#endif /* MULTIPROCESSOR */
@


1.17.6.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a38 1
#include <sys/msgbuf.h>
a474 1
	{ "dmesg",	db_dmesg_cmd,		0,		NULL },
a690 25
}

void
db_dmesg_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int	haddr;
	db_expr_t count;
	char	*modif;
{
	int i, off;
	char *p;

	if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
		return;
	off = msgbufp->msg_bufx;
	if (off > msgbufp->msg_bufs)
		off = 0;
	for (i = 0, p = msgbufp->msg_bufc + off;
	    i < msgbufp->msg_bufs; i++, p++) {
		if (p > msgbufp->msg_bufc + msgbufp->msg_bufs)
			p = msgbufp->msg_bufc;
		if (*p != '\0');
			db_putchar(*p);
	}
	db_putchar('\n');
@


1.17.6.12
log
@Merge with the trunk
@
text
@d232 1
a232 1
		    db_strlcpy(modif, db_tok_string, sizeof(modif));
d642 1
a642 1
	boot(RB_AUTOBOOT | RB_TIMEBAD | RB_USERREQ);
d652 1
a652 1
	boot(RB_NOSYNC | RB_DUMP | RB_TIMEBAD | RB_USERREQ);
d662 1
a662 1
	boot(RB_DUMP | RB_TIMEBAD | RB_USERREQ);
d672 1
a672 1
	boot(RB_NOSYNC | RB_HALT | RB_TIMEBAD | RB_USERREQ);
d682 1
a682 1
	boot(RB_AUTOBOOT | RB_NOSYNC | RB_TIMEBAD | RB_USERREQ);
d692 1
a692 1
	boot(RB_NOSYNC | RB_HALT | RB_POWERDOWN | RB_TIMEBAD | RB_USERREQ);
d714 1
a714 1
		if (*p != '\0')
@


1.16
log
@the sync command does not work, back it out
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.14 1998/02/25 19:53:46 weingart Exp $	*/
d55 5
d298 3
d302 1
d318 3
d322 1
@


1.15
log
@add a sync command that does not reboot
@
text
@a33 2
#include <sys/types.h>
#include <sys/mount.h>
a53 2
#include <sys/syscall.h>
#include <sys/syscallargs.h>
a382 1
	{ "sync",	db_sync_cmd,		0,		NULL },
a545 12
}

void
db_sync_cmd(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
{
	register_t rval[2];

	sys_sync(&proc0, NULL, rval);
@


1.14
log
@Add command to print out extents.  This helps in debugging PnP stuff,
and "it's just plain cool".
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.13 1997/09/08 19:46:37 deraadt Exp $	*/
d34 2
d56 2
d387 1
d551 12
@


1.13
log
@put 'help' in front of 'hangman'
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.12 1997/07/07 19:45:20 niklas Exp $	*/
d37 1
d312 11
d340 1
@


1.12
log
@Do not wrap lines so often, much prettier x output
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.11 1997/01/27 07:53:53 deraadt Exp $	*/
a85 1
#define	CMD_HELP	4
a128 6
	if (result == CMD_NONE) {
	    /* check for 'help' */
		if (name[0] == 'h' && name[1] == 'e'
		    && name[2] == 'l' && name[3] == 'p')
			result = CMD_HELP;
	}
a190 4
		    case CMD_HELP:
			db_cmd_list(cmd_table);
			db_flush_lex();
			return;
d368 1
d389 5
a393 1
db_help_cmd()
d395 1
a395 7
	struct db_command *cmd = db_command_table;

	while (cmd->name != 0) {
	    db_printf("%-12s", cmd->name);
	    db_end_line(12);
	    cmd++;
	}
@


1.11
log
@change prompt to ddb to match man page ddb(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.10 1997/01/16 08:03:56 kstailey Exp $	*/
d147 1
a147 1
	    db_end_line();
d405 1
a405 1
	    db_end_line();
@


1.10
log
@use RB_TIMEBAD to indicate that the time is wrong and should not be copied
to the battery backed up clock via resettodr() in boot().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.7 1996/04/21 22:18:57 deraadt Exp $	*/
d434 1
a434 1
		db_printf("db> ");
@


1.9
log
@-Wall and -Wstrict-prototypes cleanup
@
text
@d524 1
a524 1
	boot(RB_AUTOBOOT);
d534 1
a534 1
	boot(RB_NOSYNC | RB_DUMP);
d544 1
a544 1
	boot(RB_DUMP);
@


1.8
log
@add advanced hang analyzer.
idea by theo.
@
text
@a341 4
void	db_boot_sync_cmd();
void	db_boot_crash_cmd();
void	db_boot_dump_cmd();

d518 5
a522 1
db_boot_sync_cmd()
d528 5
a532 1
db_boot_crash_cmd()
d538 5
a542 1
db_boot_dump_cmd()
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.6 1996/04/19 16:08:30 niklas Exp $	*/
d383 1
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: db_command.c,v 1.4 1996/03/11 11:16:01 mickey Exp $	*/
/*	$NetBSD: db_command.c,v 1.19 1996/03/13 21:06:38 christos Exp $	*/
d516 1
a516 1
			 args[5], args[6], args[7], args[8], args[9] );
@


1.5
log
@Fix according to the last changes.
dev_conf.h deleted, longjmp proto changed.
@
text
@d2 1
@


1.4
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.3 1996/02/20 13:35:33 mickey Exp $	*/
d452 1
a452 1
	longjmp(db_recover, 1);
@


1.3
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_command.c,v 1.17 1996/02/13 17:39:01 gwr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
d33 1
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: db_command.c,v 1.15 1995/10/26 14:52:33 gwr Exp $	*/
d34 1
a36 1

d42 7
d50 1
a50 1
#include <setjmp.h>
d56 1
a56 1
jmp_buf		*db_recover;
d158 1
a158 1
	boolean_t	have_addr;
d171 1
a171 2
	    void db_fncall();
	    db_fncall();
a295 1
        extern void	_vm_map_print();
d301 1
a301 1
        _vm_map_print((vm_map_t)addr, full, db_printf);
a311 1
        extern void	_vm_object_print();
d317 1
a317 1
        _vm_object_print((vm_object_t)addr, full, db_printf);
a322 6
extern void	db_show_all_procs();
extern void	db_show_callout();
extern void	db_listbreak_cmd();
extern void	db_listwatch_cmd();
extern void	db_show_regs();
void		db_show_help();
d325 3
a327 3
	{ "procs",	db_show_all_procs,0,	0 },
	{ "callout",	db_show_callout,0,	0 },
	{ (char *)0 }
d331 17
a347 6
	{ "all",	0,			0,	db_show_all_cmds },
	{ "registers",	db_show_regs,		0,	0 },
	{ "breaks",	db_listbreak_cmd, 	0,	0 },
	{ "watches",	db_listwatch_cmd, 	0,	0 },
	{ "map",	db_map_print_cmd,	0,	0 },
	{ "object",	db_object_print_cmd,	0,	0 },
a350 11
extern void	db_print_cmd(), db_examine_cmd(), db_set_cmd();
extern void	db_search_cmd();
extern void	db_write_cmd();
extern void	db_delete_cmd(), db_breakpoint_cmd();
extern void	db_deletewatch_cmd(), db_watchpoint_cmd();
extern void	db_single_step_cmd(), db_trace_until_call_cmd(),
		db_trace_until_matching_cmd(), db_continue_cmd();
extern void	db_stack_trace_cmd();
void		db_help_cmd();
void		db_fncall();

d354 1
a354 1
	{ "machine",    0,                      0,     		0},
d356 26
a381 25
	{ "print",	db_print_cmd,		0,		0 },
	{ "examine",	db_examine_cmd,		CS_SET_DOT, 	0 },
	{ "x",		db_examine_cmd,		CS_SET_DOT, 	0 },
	{ "search",	db_search_cmd,		CS_OWN|CS_SET_DOT, 0 },
	{ "set",	db_set_cmd,		CS_OWN,		0 },
	{ "write",	db_write_cmd,		CS_MORE|CS_SET_DOT, 0 },
	{ "w",		db_write_cmd,		CS_MORE|CS_SET_DOT, 0 },
	{ "delete",	db_delete_cmd,		0,		0 },
	{ "d",		db_delete_cmd,		0,		0 },
	{ "break",	db_breakpoint_cmd,	0,		0 },
	{ "dwatch",	db_deletewatch_cmd,	0,		0 },
	{ "watch",	db_watchpoint_cmd,	CS_MORE,	0 },
	{ "step",	db_single_step_cmd,	0,		0 },
	{ "s",		db_single_step_cmd,	0,		0 },
	{ "continue",	db_continue_cmd,	0,		0 },
	{ "c",		db_continue_cmd,	0,		0 },
	{ "until",	db_trace_until_call_cmd,0,		0 },
	{ "next",	db_trace_until_matching_cmd,0,		0 },
	{ "match",	db_trace_until_matching_cmd,0,		0 },
	{ "trace",	db_stack_trace_cmd,	0,		0 },
	{ "call",	db_fncall,		CS_OWN,		0 },
	{ "ps",		db_show_all_procs,	0,		0 },
	{ "callout",	db_show_callout,	0,		0 },
	{ "show",	0,			0,		db_show_cmds },
	{ (char *)0, }
d414 2
a415 2
	jmp_buf		db_jmpbuf;
	jmp_buf		*savejmp = db_recover;
d425 4
a428 1
	(void) setjmp(*(db_recover = &db_jmpbuf));
d451 1
a451 1
	longjmp(*db_recover, 1);
d459 1
d461 5
a465 1
db_fncall()
d472 1
a472 1
	db_expr_t	(*func)();
d480 1
a480 1
	func = (db_expr_t (*) ()) fn_addr;
d516 18
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: db_command.c,v 1.13 1994/10/09 08:29:59 mycroft Exp $	*/
d35 2
d296 1
a296 1
        _vm_map_print(addr, full, db_printf);
d313 1
a313 1
        _vm_object_print(addr, full, db_printf);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

