head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.4
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.12
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.8
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.6
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.4
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.15.0.6
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.25;
commitid	7AkssaZPPd7mA8h3;

1.25
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2014.07.08.13.02.57;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	E2I6e8QZgMmNFC95;

1.22
date	2010.11.27.19.59.11;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.27.19.57.23;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.14.17.52.36;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.06.19.49.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.04.21.11.44;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.07.04.23.14.53;	author espie;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.24.09.38.03;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	99.06.17.18.17.08;	author art;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	98.03.16.08.44.32;	author pefo;	state Exp;
branches;
next	1.10;

1.10
date	97.08.07.09.18.06;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.07.23.23.35.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.19.22.28.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.06.16.35.27;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.03.25.17.07.39;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	97.03.21.00.48.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.19.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.11.11.16.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.13.35.41;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches;
next	;

1.12.4.1
date	2001.05.14.22.06.59;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2003.05.19.21.52.44;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Kill trailing whitespaces.  No object change.
@
text
@/*	$OpenBSD: db_run.c,v 1.25 2015/03/14 03:38:46 jsg Exp $	*/
/*	$NetBSD: db_run.c,v 1.8 1996/02/05 01:57:12 christos Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 * 	Author: David B. Golub, Carnegie Mellon University
 *	Date:	7/90
 */

/*
 * Commands to run process.
 */
#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_run.h>
#include <ddb/db_break.h>
#include <ddb/db_access.h>

#ifdef SOFTWARE_SSTEP
db_breakpoint_t	db_not_taken_bkpt = 0;
db_breakpoint_t	db_taken_bkpt = 0;
#endif

int		db_inst_count;

#ifndef KGDB

#include <ddb/db_watch.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>
#include <ddb/db_extern.h>

int	db_run_mode;
#define	STEP_NONE	0
#define	STEP_ONCE	1
#define	STEP_RETURN	2
#define	STEP_CALLT	3
#define	STEP_CONTINUE	4
#define STEP_INVISIBLE	5
#define	STEP_COUNT	6

boolean_t	db_sstep_print;
int		db_loop_count;
int		db_call_depth;

boolean_t
db_stop_at_pc(db_regs_t *regs, boolean_t *is_breakpoint)
{
	db_addr_t	pc, old_pc;
	db_breakpoint_t	bkpt;

	db_clear_breakpoints();
	db_clear_watchpoints();
	old_pc = pc = PC_REGS(regs);

#ifdef	FIXUP_PC_AFTER_BREAK
	if (*is_breakpoint) {
		/*
		 * Breakpoint trap.  Fix up the PC if the
		 * machine requires it.
		 */
		FIXUP_PC_AFTER_BREAK(regs);
		pc = PC_REGS(regs);
	}
#endif

	/*
	 * Now check for a breakpoint at this address.
	 */
	bkpt = db_find_breakpoint(pc);
	if (bkpt) {
		if (--bkpt->count == 0) {
			db_clear_single_step(regs);
			bkpt->count = bkpt->init_count;
			*is_breakpoint = TRUE;
			return (TRUE);	/* stop here */
		}
	} else if (*is_breakpoint
#ifdef SOFTWARE_SSTEP
	    && !((db_taken_bkpt && db_taken_bkpt->address == pc) ||
	    (db_not_taken_bkpt && db_not_taken_bkpt->address == pc))
#endif
	    ) {
#ifdef PC_ADVANCE
		PC_ADVANCE(regs);
#else
# ifdef SET_PC_REGS
		SET_PC_REGS(regs, old_pc);
# else
		PC_REGS(regs) = old_pc;
# endif
#endif
	}
	db_clear_single_step(regs);

	*is_breakpoint = FALSE;

	if (db_run_mode == STEP_INVISIBLE) {
		db_run_mode = STEP_CONTINUE;
		return (FALSE);	/* continue */
	}
	if (db_run_mode == STEP_COUNT) {
		return (FALSE); /* continue */
	}
	if (db_run_mode == STEP_ONCE) {
		if (--db_loop_count > 0) {
			if (db_sstep_print) {
				db_printf("\t\t");
				db_print_loc_and_inst(pc);
				db_printf("\n");
			}
			return (FALSE);	/* continue */
		}
	}
	if (db_run_mode == STEP_RETURN) {
	    db_expr_t ins = db_get_value(pc, sizeof(int), FALSE);

	    /* continue until matching return */

	    if (!inst_trap_return(ins) &&
		(!inst_return(ins) || --db_call_depth != 0)) {
		if (db_sstep_print) {
		    if (inst_call(ins) || inst_return(ins)) {
			int i;

			db_printf("[after %6d]     ", db_inst_count);
			for (i = db_call_depth; --i > 0; )
			    db_printf("  ");
			db_print_loc_and_inst(pc);
			db_printf("\n");
		    }
		}
		if (inst_call(ins))
		    db_call_depth++;
		return (FALSE);	/* continue */
	    }
	}
	if (db_run_mode == STEP_CALLT) {
	    db_expr_t ins = db_get_value(pc, sizeof(int), FALSE);

	    /* continue until call or return */

	    if (!inst_call(ins) && !inst_return(ins) &&
		!inst_trap_return(ins)) {
		return (FALSE);	/* continue */
	    }
	}
	db_run_mode = STEP_NONE;
	return (TRUE);
}

void
db_restart_at_pc(db_regs_t *regs, boolean_t watchpt)
{
	db_addr_t pc = PC_REGS(regs);

	if ((db_run_mode == STEP_COUNT) || (db_run_mode == STEP_RETURN) ||
	    (db_run_mode == STEP_CALLT)) {
		db_expr_t	ins;

		/*
		 * We are about to execute this instruction,
		 * so count it now.
		 */
		ins = db_get_value(pc, sizeof(int), FALSE);
		db_inst_count++;
#ifdef	SOFTWARE_SSTEP
		/* XXX works on mips, but... */
		if (inst_branch(ins) || inst_call(ins)) {
			ins = db_get_value(next_instr_address(pc, 1),
			    sizeof(int), FALSE);
			db_inst_count++;
		}
#endif	/* SOFTWARE_SSTEP */
	}

	if (db_run_mode == STEP_CONTINUE) {
		if (watchpt || db_find_breakpoint(pc)) {
			/*
			 * Step over breakpoint/watchpoint.
			 */
			db_run_mode = STEP_INVISIBLE;
			db_set_single_step(regs);
		} else {
			db_set_breakpoints();
			db_set_watchpoints();
		}
	} else {
		db_set_single_step(regs);
	}
}

void
db_single_step(db_regs_t *regs)
{
	if (db_run_mode == STEP_CONTINUE) {
	    db_run_mode = STEP_INVISIBLE;
	    db_set_single_step(regs);
	}
}

/* single-step */
/*ARGSUSED*/
void
db_single_step_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	boolean_t	print = FALSE;

	if (count == -1)
	    count = 1;

	if (modif[0] == 'p')
	    print = TRUE;

	db_run_mode = STEP_ONCE;
	db_loop_count = count;
	db_sstep_print = print;
	db_inst_count = 0;

	db_cmd_loop_done = 1;
}

/* trace and print until call/return */
/*ARGSUSED*/
void
db_trace_until_call_cmd(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif)
{
	boolean_t	print = FALSE;

	if (modif[0] == 'p')
	    print = TRUE;

	db_run_mode = STEP_CALLT;
	db_sstep_print = print;
	db_inst_count = 0;

	db_cmd_loop_done = 1;
}

/*ARGSUSED*/
void
db_trace_until_matching_cmd(db_expr_t addr, int have_addr, db_expr_t count,
    char *modif)
{
	boolean_t	print = FALSE;

	if (modif[0] == 'p')
	    print = TRUE;

	db_run_mode = STEP_RETURN;
	db_call_depth = 1;
	db_sstep_print = print;
	db_inst_count = 0;

	db_cmd_loop_done = 1;
}

/* continue */
/*ARGSUSED*/
void
db_continue_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	if (modif[0] == 'c')
	    db_run_mode = STEP_COUNT;
	else
	    db_run_mode = STEP_CONTINUE;
	db_inst_count = 0;

	db_cmd_loop_done = 1;
}
#endif /* NO KGDB */

#ifdef	SOFTWARE_SSTEP
/*
 *	Software implementation of single-stepping.
 *	If your machine does not have a trace mode
 *	similar to the vax or sun ones you can use
 *	this implementation, done for the mips.
 *	Just define the above conditional and provide
 *	the functions/macros defined below.
 *
 * extern boolean_t
 *	inst_branch(ins),	returns true if the instruction might branch
 * extern unsigned
 *	branch_taken(ins, pc, getreg_val, regs),
 *				return the address the instruction might
 *				branch to
 *	getreg_val(regs, reg),	return the value of a user register,
 *				as indicated in the hardware instruction
 *				encoding, e.g. 8 for r8
 *
 * next_instr_address(pc, bd)	returns the address of the first
 *				instruction following the one at "pc",
 *				which is either in the taken path of
 *				the branch (bd==1) or not.  This is
 *				for machines (mips) with branch delays.
 *
 *	A single-step may involve at most 2 breakpoints -
 *	one for branch-not-taken and one for branch taken.
 *	If one of these addresses does not already have a breakpoint,
 *	we allocate a breakpoint and save it here.
 *	These breakpoints are deleted on return.
 */

void
db_set_single_step(db_regs_t *regs)
{
	db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
	db_addr_t brpc;
	u_int inst;

	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 */
	inst = db_get_value(pc, sizeof(int), FALSE);
	if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
	    brpc = branch_taken(inst, pc, getreg_val, regs);
	    if (brpc != pc) {	/* self-branches are hopeless */
		db_taken_bkpt = db_set_temp_breakpoint(brpc);
	    }
#if 0
	    /* XXX this seems like a true bug, no?  */
	    pc = next_instr_address(pc, 1);
#endif
	}
#endif /*SOFTWARE_SSTEP_EMUL*/
	pc = next_instr_address(pc, 0);
	db_not_taken_bkpt = db_set_temp_breakpoint(pc);
}

void
db_clear_single_step(db_regs_t *regs)
{
	if (db_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_taken_bkpt);
	    db_taken_bkpt = 0;
	}
	if (db_not_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_not_taken_bkpt);
	    db_not_taken_bkpt = 0;
	}
}

#endif	/* SOFTWARE_SSTEP */
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.24 2014/09/14 14:17:24 jsg Exp $	*/
d4 1
a4 1
/* 
d8 1
a8 1
 * 
d14 1
a14 1
 * 
d18 1
a18 1
 * 
d20 1
a20 1
 * 
d25 1
a25 1
 * 
d121 1
a121 1
		
d318 1
a318 1
 *			
d330 1
a330 1
 */			
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.23 2014/07/08 13:02:57 deraadt Exp $	*/
a53 1
#include <ddb/db_lex.h>
@


1.23
log
@These do not need the extremely poorly named uvm/uvm_extern.h (which
pulls in the universe). occasionally they need sys/systm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.22 2010/11/27 19:59:11 miod Exp $	*/
a37 1
#include <sys/proc.h>
@


1.22
log
@Get rid of the vm_map field of ddb breakpoints and watchpoints, and do not
pretend these could work on userland addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.21 2010/11/27 19:57:23 miod Exp $	*/
d37 1
a38 2

#include <uvm/uvm_extern.h>
@


1.21
log
@Remove ddb single-step load and store counters. Most platforms do not
implement them, and they are of questionable usefulness.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.20 2007/11/14 17:52:36 miod Exp $	*/
d99 1
a99 1
	bkpt = db_find_breakpoint_here(pc);
d207 1
a207 1
		if (watchpt || db_find_breakpoint_here(pc)) {
@


1.20
log
@Be consistent in db_cmd_loop_done declaration.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.19 2006/03/13 06:23:20 jsg Exp $	*/
a52 2
int		db_load_count;
int		db_store_count;
a195 2
		db_load_count += inst_load(ins);
		db_store_count += inst_store(ins);
a201 2
			db_load_count += inst_load(ins);
			db_store_count += inst_store(ins);
a247 2
	db_load_count = 0;
	db_store_count = 0;
a265 2
	db_load_count = 0;
	db_store_count = 0;
a283 2
	db_load_count = 0;
	db_store_count = 0;
a297 2
	db_load_count = 0;
	db_store_count = 0;
@


1.19
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.18 2005/09/06 19:49:21 miod Exp $	*/
a235 2

extern int	db_cmd_loop_done;
@


1.18
log
@Remove old m88k workaround, now that we have SET_PC_REGS().
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.17 2005/01/04 21:11:44 espie Exp $	*/
d78 1
a78 3
db_stop_at_pc(regs, is_breakpoint)
	db_regs_t	*regs;
	boolean_t	*is_breakpoint;
d155 1
a155 1
			register int i;
d184 1
a184 3
db_restart_at_pc(regs, watchpt)
	db_regs_t *regs;
	boolean_t watchpt;
d229 1
a229 2
db_single_step(regs)
	db_regs_t *regs;
d242 1
a242 5
db_single_step_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d265 2
a266 5
db_trace_until_call_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d284 2
a285 5
db_trace_until_matching_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d305 1
a305 5
db_continue_cmd(addr, have_addr, count, modif)
	db_expr_t	addr;
	int		have_addr;
	db_expr_t	count;
	char *		modif;
d352 1
a352 2
db_set_single_step(regs)
	register db_regs_t *regs;
d380 1
a380 2
db_clear_single_step(regs)
	db_regs_t *regs;
@


1.17
log
@switch to SET_PC_REGS if available, okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.16 2003/02/12 14:41:07 jason Exp $	*/
a122 1
#  ifndef m88k
a123 1
#  endif
@


1.16
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.15 2001/11/06 19:53:18 miod Exp $	*/
d120 4
a123 7
		/*
		 * XXX why on earth is this ifndef'd?  Please explain!
		 * I believe this was a workaround a bug where singlestep
		 * breakpoints got deleted before recognized as such.  This
		 * bug is now gone and probably this #ifndef should go too.
		 */
#ifndef m88k
d125 2
a126 1
#endif
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.14 2001/07/04 23:14:53 espie Exp $	*/
d51 4
@


1.15.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 4

int		db_inst_count;
int		db_load_count;
int		db_store_count;
@


1.14
log
@Make preprocessor happier, don't give it untasty tokens at end of input.
Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.13 2001/01/24 09:38:03 hugh Exp $	*/
d39 1
a39 1
#include <vm/vm.h>
@


1.13
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.12 1999/06/17 18:17:08 art Exp $	*/
d213 1
a213 1
#endif	SOFTWARE_SSTEP
d413 1
a413 1
#endif	SOFTWARE_SSTEP
@


1.12
log
@fix continuing from breakpoints on sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.11 1998/03/16 08:44:32 pefo Exp $	*/
a43 1
#include <ddb/db_lex.h>
d46 9
a72 5
#ifdef SOFTWARE_SSTEP
db_breakpoint_t	db_not_taken_bkpt = 0;
db_breakpoint_t	db_taken_bkpt = 0;
#endif

a241 77
#ifdef	SOFTWARE_SSTEP
/*
 *	Software implementation of single-stepping.
 *	If your machine does not have a trace mode
 *	similar to the vax or sun ones you can use
 *	this implementation, done for the mips.
 *	Just define the above conditional and provide
 *	the functions/macros defined below.
 *
 * extern boolean_t
 *	inst_branch(ins),	returns true if the instruction might branch
 * extern unsigned
 *	branch_taken(ins, pc, getreg_val, regs),
 *				return the address the instruction might
 *				branch to
 *	getreg_val(regs, reg),	return the value of a user register,
 *				as indicated in the hardware instruction
 *				encoding, e.g. 8 for r8
 *			
 * next_instr_address(pc, bd)	returns the address of the first
 *				instruction following the one at "pc",
 *				which is either in the taken path of
 *				the branch (bd==1) or not.  This is
 *				for machines (mips) with branch delays.
 *
 *	A single-step may involve at most 2 breakpoints -
 *	one for branch-not-taken and one for branch taken.
 *	If one of these addresses does not already have a breakpoint,
 *	we allocate a breakpoint and save it here.
 *	These breakpoints are deleted on return.
 */			

void
db_set_single_step(regs)
	register db_regs_t *regs;
{
	db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
	db_addr_t brpc;
	u_int inst;

	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 */
	inst = db_get_value(pc, sizeof(int), FALSE);
	if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
	    brpc = branch_taken(inst, pc, getreg_val, regs);
	    if (brpc != pc) {	/* self-branches are hopeless */
		db_taken_bkpt = db_set_temp_breakpoint(brpc);
	    }
#if 0
	    /* XXX this seems like a true bug, no?  */
	    pc = next_instr_address(pc, 1);
#endif
	}
#endif /*SOFTWARE_SSTEP_EMUL*/
	pc = next_instr_address(pc, 0);
	db_not_taken_bkpt = db_set_temp_breakpoint(pc);
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (db_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_taken_bkpt);
	    db_taken_bkpt = 0;
	}
	if (db_not_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_not_taken_bkpt);
	    db_not_taken_bkpt = 0;
	}
}

#endif	SOFTWARE_SSTEP

d336 78
@


1.12.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.13 2001/01/24 09:38:03 hugh Exp $	*/
d44 1
a46 9

#ifdef SOFTWARE_SSTEP
db_breakpoint_t	db_not_taken_bkpt = 0;
db_breakpoint_t	db_taken_bkpt = 0;
#endif

#ifndef KGDB

#include <ddb/db_lex.h>
d65 5
d239 77
a409 78
#endif /* NO KGDB */

#ifdef	SOFTWARE_SSTEP
/*
 *	Software implementation of single-stepping.
 *	If your machine does not have a trace mode
 *	similar to the vax or sun ones you can use
 *	this implementation, done for the mips.
 *	Just define the above conditional and provide
 *	the functions/macros defined below.
 *
 * extern boolean_t
 *	inst_branch(ins),	returns true if the instruction might branch
 * extern unsigned
 *	branch_taken(ins, pc, getreg_val, regs),
 *				return the address the instruction might
 *				branch to
 *	getreg_val(regs, reg),	return the value of a user register,
 *				as indicated in the hardware instruction
 *				encoding, e.g. 8 for r8
 *			
 * next_instr_address(pc, bd)	returns the address of the first
 *				instruction following the one at "pc",
 *				which is either in the taken path of
 *				the branch (bd==1) or not.  This is
 *				for machines (mips) with branch delays.
 *
 *	A single-step may involve at most 2 breakpoints -
 *	one for branch-not-taken and one for branch taken.
 *	If one of these addresses does not already have a breakpoint,
 *	we allocate a breakpoint and save it here.
 *	These breakpoints are deleted on return.
 */			

void
db_set_single_step(regs)
	register db_regs_t *regs;
{
	db_addr_t pc = PC_REGS(regs);
#ifndef SOFTWARE_SSTEP_EMUL
	db_addr_t brpc;
	u_int inst;

	/*
	 * User was stopped at pc, e.g. the instruction
	 * at pc was not executed.
	 */
	inst = db_get_value(pc, sizeof(int), FALSE);
	if (inst_branch(inst) || inst_call(inst) || inst_return(inst)) {
	    brpc = branch_taken(inst, pc, getreg_val, regs);
	    if (brpc != pc) {	/* self-branches are hopeless */
		db_taken_bkpt = db_set_temp_breakpoint(brpc);
	    }
#if 0
	    /* XXX this seems like a true bug, no?  */
	    pc = next_instr_address(pc, 1);
#endif
	}
#endif /*SOFTWARE_SSTEP_EMUL*/
	pc = next_instr_address(pc, 0);
	db_not_taken_bkpt = db_set_temp_breakpoint(pc);
}

void
db_clear_single_step(regs)
	db_regs_t *regs;
{
	if (db_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_taken_bkpt);
	    db_taken_bkpt = 0;
	}
	if (db_not_taken_bkpt != 0) {
	    db_delete_temp_breakpoint(db_not_taken_bkpt);
	    db_not_taken_bkpt = 0;
	}
}

#endif	SOFTWARE_SSTEP
@


1.12.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.12.4.1 2001/05/14 22:06:59 niklas Exp $	*/
d213 1
a213 1
#endif	/* SOFTWARE_SSTEP */
d413 1
a413 1
#endif	/* SOFTWARE_SSTEP */
@


1.12.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a39 1
#include <uvm/uvm_extern.h>
@


1.12.4.4
log
@Sync the SMP branch with 3.3
@
text
@a51 4
int		db_inst_count;
int		db_load_count;
int		db_store_count;

@


1.11
log
@Add the option SOFTWARE_SSTEP_EMUL. This is used with mips processors
together with SOFTWARE_SSTEP to do single stepping. We don't need the
dual BP at branch since we always evaluate the correct next location.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.10 1997/08/07 09:18:06 niklas Exp $	*/
d110 3
d121 1
@


1.10
log
@document needed MD funcs for SOFTWARE_SSTEP better
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.9 1997/07/23 23:35:46 niklas Exp $	*/
d271 3
a273 1
	db_addr_t pc = PC_REGS(regs), brpc;
d291 1
@


1.9
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.8 1997/07/19 22:28:19 niklas Exp $	*/
d245 1
a245 1
 *	inst_branch(),		returns true if the instruction might branch
d247 2
a248 1
 *	branch_taken(),		return the address the instruction might
d250 1
a250 1
 *	db_getreg_val();	return the value of a user register,
d254 1
a254 1
 * next_instr_address(pc,bd)	returns the address of the first
@


1.8
log
@SOFTWARE_SSTEP bugs fixed.  KNF.  register specs removed.  Include vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.7 1997/07/06 16:35:27 niklas Exp $	*/
d114 1
a114 1
		 * bug is now gone and probably this #ifndef should go to.
@


1.7
log
@Style nits + provide getreg_val proto conditionally.  Removed unused var.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.6 1997/03/25 17:07:39 rahnds Exp $	*/
d39 2
d65 5
d72 1
a72 1
	db_regs_t *regs;
d75 2
a76 2
	register db_addr_t	pc;
	register db_breakpoint_t bkpt;
a77 1
	db_clear_single_step(regs);
d80 1
a80 1
	pc = PC_REGS(regs);
d84 6
a89 6
	    /*
	     * Breakpoint trap.  Fix up the PC if the
	     * machine requires it.
	     */
	    FIXUP_PC_AFTER_BREAK(regs);
	    pc = PC_REGS(regs);
d98 18
a115 6
	    if (--bkpt->count == 0) {
		bkpt->count = bkpt->init_count;
		*is_breakpoint = TRUE;
		return (TRUE);	/* stop here */
	    }
	} else if (*is_breakpoint) {
d117 1
a117 1
		PC_REGS(regs) += BKPT_SIZE;
d120 1
d125 2
a126 2
	    db_run_mode = STEP_CONTINUE;
	    return (FALSE);	/* continue */
d129 1
a129 1
	    return (FALSE); /* continue */
d132 7
a138 5
	    if (--db_loop_count > 0) {
		if (db_sstep_print) {
		    db_printf("\t\t");
		    db_print_loc_and_inst(pc);
		    db_printf("\n");
a139 2
		return (FALSE);	/* continue */
	    }
d169 1
a169 2
	    if (!inst_call(ins) &&
		!inst_return(ins) &&
d183 1
a183 1
	register db_addr_t pc = PC_REGS(regs);
d185 1
a185 2
	if ((db_run_mode == STEP_COUNT) ||
	    (db_run_mode == STEP_RETURN) ||
d187 1
a187 1
	    db_expr_t		ins;
d189 5
a193 14
	    /*
	     * We are about to execute this instruction,
	     * so count it now.
	     */

	    ins = db_get_value(pc, sizeof(int), FALSE);
	    db_inst_count++;
	    db_load_count += inst_load(ins);
	    db_store_count += inst_store(ins);
#ifdef	SOFTWARE_SSTEP
	    /* XXX works on mips, but... */
	    if (inst_branch(ins) || inst_call(ins)) {
		ins = db_get_value(next_instr_address(pc,1),
				   sizeof(int), FALSE);
d197 9
a205 1
	    }
d210 11
a220 5
	    if (watchpt || db_find_breakpoint_here(pc)) {
		/*
		 * Step over breakpoint/watchpoint.
		 */
		db_run_mode = STEP_INVISIBLE;
a221 6
	    } else {
		db_set_breakpoints();
		db_set_watchpoints();
	    }
	} else {
	    db_set_single_step(regs);
a265 12
/*
 * XXX is this proto right?  We don't use this facility in any of our ports.
 * I've seen it defined to (0) when it is not needed and then the proto will
 * not be correct, so skip it then.
 */
#ifndef getreg_val
extern u_int getreg_val __P((db_regs_t *, int));
#endif

db_breakpoint_t	db_not_taken_bkpt = 0;
db_breakpoint_t	db_taken_bkpt = 0;

d270 2
a271 2
	db_addr_t pc = PC_REGS(regs);
	register unsigned	 inst, brpc;
d274 2
a275 2
	 *	User was stopped at pc, e.g. the instruction
	 *	at pc was not executed.
d278 1
a278 1
	if (inst_branch(inst) || inst_call(inst)) {
d283 2
d286 1
@


1.6
log
@Ok here is the mvme88k userland, minus a few important pieces.
as, ld change need to be merged. It is known that shared libraries and C++
do not work.
If anyone wants to step forward and take over the mvme88k port please do.
It was dumped on me when the original developer, Nivas, left his previous
job and started a new one.

I am trying to get the port in a shape that someone could take over.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.5 1997/03/21 00:48:41 niklas Exp $	*/
d249 10
a274 2
	    extern unsigned getreg_val();

d279 1
a279 1
	    pc = next_instr_address(pc,1);
d281 1
a281 1
	pc = next_instr_address(pc,0);
a288 2
	register db_breakpoint_t	bkpt;

@


1.5
log
@New FIXUP_PC_AFTER_BREAK convention from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.4 1996/04/21 22:19:10 deraadt Exp $	*/
d98 1
d100 1
d265 1
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.3 1996/03/11 11:16:20 mickey Exp $	*/
d82 1
a82 1
	    FIXUP_PC_AFTER_BREAK
@


1.3
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_run.c,v 1.2 1996/02/20 13:35:41 mickey Exp $	*/
@


1.2
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_run.c,v 1.8 1996/02/05 01:57:12 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: db_run.c,v 1.7 1994/10/09 08:30:08 mycroft Exp $	*/
d44 4
a261 1
	    extern unsigned getreg_val();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

