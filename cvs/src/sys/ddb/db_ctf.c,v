head	1.16;
access;
symbols
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.16
date	2017.08.14.19.58.32;	author uwe;	state Exp;
branches;
next	1.15;
commitid	EV1oORLG8B3ZAkCR;

1.15
date	2017.08.14.19.57.05;	author uwe;	state Exp;
branches;
next	1.14;
commitid	nKQwZeuE7ewzzTrR;

1.14
date	2017.08.11.20.47.21;	author mpi;	state Exp;
branches;
next	1.13;
commitid	tQkNcBjA97TK77K5;

1.13
date	2017.08.11.16.57.19;	author mpi;	state Exp;
branches;
next	1.12;
commitid	pF1eaQGp8Wok1ajh;

1.12
date	2017.08.11.15.08.13;	author mpi;	state Exp;
branches;
next	1.11;
commitid	7CR24YSbGTpdtNYu;

1.11
date	2017.08.10.19.39.38;	author mpi;	state Exp;
branches;
next	1.10;
commitid	31PvZ4r4dQH5StiR;

1.10
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.9;
commitid	PnZZkFEIj4rPydZo;

1.9
date	2017.05.29.06.14.10;	author mpi;	state Exp;
branches;
next	1.8;
commitid	kOJ4rx83W4cr7RQt;

1.8
date	2017.05.28.14.24.19;	author mpi;	state Exp;
branches;
next	1.7;
commitid	78V0YPcBVaG7RVc5;

1.7
date	2017.05.28.11.41.52;	author mpi;	state Exp;
branches;
next	1.6;
commitid	yu9JCnXPI4UfHZwC;

1.6
date	2017.05.27.15.05.16;	author mpi;	state Exp;
branches;
next	1.5;
commitid	cECKQ1lNnkS6XMGg;

1.5
date	2017.05.09.11.09.38;	author mpi;	state Exp;
branches;
next	1.4;
commitid	UzmDwJvp8m0SwFZd;

1.4
date	2016.09.18.13.31.12;	author jasper;	state Exp;
branches;
next	1.3;
commitid	NUgpgJSAwH3DK0AA;

1.3
date	2016.09.17.17.45.37;	author jasper;	state Exp;
branches;
next	1.2;
commitid	BdocISuEyIsE3GnQ;

1.2
date	2016.09.17.17.39.34;	author jasper;	state Exp;
branches;
next	1.1;
commitid	yiSnvoseCUtTmo9S;

1.1
date	2016.09.16.19.13.17;	author jasper;	state Exp;
branches;
next	;
commitid	aag1XqKQQN6pS0l5;


desc
@@


1.16
log
@db_ctf_pprintf() doesn't actually support formatting, so s/f$//

ok mpi@@
@
text
@/*	$OpenBSD: db_ctf.c,v 1.15 2017/08/14 19:57:05 uwe Exp $	*/

/*
 * Copyright (c) 2016-2017 Martin Pieuchot
 * Copyright (c) 2016 Jasper Lievisse Adriaanse <jasper@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stdint.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>

#include <machine/db_machdep.h>

#include <ddb/db_extern.h>
#include <ddb/db_command.h>
#include <ddb/db_elf.h>
#include <ddb/db_lex.h>
#include <ddb/db_output.h>
#include <ddb/db_sym.h>

#include <sys/exec_elf.h>
#include <sys/ctf.h>
#include <sys/malloc.h>
#include <lib/libz/zlib.h>

extern db_symtab_t		db_symtab;

struct ddb_ctf {
	struct ctf_header 	*cth;
	const char		*rawctf;	/* raw .SUNW_ctf section */
        size_t			 rawctflen;	/* raw .SUNW_ctf section size */
	const char 		*data;		/* decompressed CTF data */
	size_t			 dlen;		/* decompressed CTF data size */
	char			*strtab;	/* ELF string table */
	uint32_t 		 ctf_found;
};

struct ddb_ctf db_ctf;

static const char	*db_ctf_off2name(uint32_t);
static Elf_Sym		*db_ctf_idx2sym(size_t *, uint8_t);
static char		*db_ctf_decompress(const char *, size_t, off_t);

const struct ctf_type	*db_ctf_type_by_symbol(Elf_Sym *);
const struct ctf_type	*db_ctf_type_by_index(uint16_t);
void			 db_ctf_pprint_struct(const struct ctf_type *, vaddr_t);
void			 db_ctf_pprint_ptr(const struct ctf_type *, vaddr_t);

/*
 * Entrypoint to verify CTF presence, initialize the header, decompress
 * the data, etc.
 */
void
db_ctf_init(void)
{
	db_symtab_t *stab = &db_symtab;
	size_t rawctflen;

	/* Assume nothing was correct found until proven otherwise. */
	db_ctf.ctf_found = 0;

	if (stab->private == NULL)
		return;

	db_ctf.strtab = db_elf_find_strtab(stab);
	if (db_ctf.strtab == NULL)
		return;

	db_ctf.rawctf = db_elf_find_section(stab, &rawctflen, ELF_CTF);
	if (db_ctf.rawctf == NULL)
		return;

	db_ctf.rawctflen = rawctflen;
	db_ctf.cth = (struct ctf_header *)db_ctf.rawctf;
	db_ctf.dlen = db_ctf.cth->cth_stroff + db_ctf.cth->cth_strlen;

	if ((db_ctf.cth->cth_flags & CTF_F_COMPRESS) == 0) {
		printf("unsupported non-compressed CTF section\n");
		return;
	}

	/* Now decompress the section, take into account to skip the header */
	db_ctf.data = db_ctf_decompress(db_ctf.rawctf + sizeof(*db_ctf.cth),
	    db_ctf.rawctflen - sizeof(*db_ctf.cth), db_ctf.dlen);
	if (db_ctf.data == NULL)
		return;

	/* We made it this far, everything seems fine. */
	db_ctf.ctf_found = 1;
}

/*
 * Convert an index to a symbol name while ensuring the type is matched.
 * It must be noted this only works if the CTF table has the same order
 * as the symbol table.
 */
Elf_Sym *
db_ctf_idx2sym(size_t *idx, uint8_t type)
{
	Elf_Sym *symp, *symtab_start, *symtab_end;
	size_t i = *idx + 1;

	symtab_start = STAB_TO_SYMSTART(&db_symtab);
	symtab_end = STAB_TO_SYMEND(&db_symtab);

	for (symp = &symtab_start[i]; symp < symtab_end; i++, symp++) {
		if (ELF_ST_TYPE(symp->st_info) != type)
			continue;

		*idx = i;
		return symp;
	}

	return NULL;
}

/*
 * For a given function name, return the number of arguments.
 */
int
db_ctf_func_numargs(Elf_Sym *st)
{
	Elf_Sym			*symp;
	uint16_t		*fstart, *fend;
	uint16_t		*fsp, kind, vlen;
	size_t			 i, idx = 0;

	if (!db_ctf.ctf_found || st == NULL)
		return -1;

	fstart = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	fend = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff);

	fsp = fstart;
	while (fsp < fend) {
		symp = db_ctf_idx2sym(&idx, STT_FUNC);
		if (symp == NULL)
			break;

		kind = CTF_INFO_KIND(*fsp);
		vlen = CTF_INFO_VLEN(*fsp);
		fsp++;

		if (kind == CTF_K_UNKNOWN && vlen == 0)
			continue;

		/* Skip return type */
		fsp++;

		/* Skip argument types */
		for (i = 0; i < vlen; i++)
			fsp++;

		if (symp == st)
			return vlen;
	}

	return -1;
}

/*
 * Return the length of the type record in the CTF section.
 */
uint32_t
db_ctf_type_len(const struct ctf_type *ctt)
{
	uint16_t		 kind, vlen, i;
	uint32_t		 tlen;
	uint64_t		 size;

	kind = CTF_INFO_KIND(ctt->ctt_info);
	vlen = CTF_INFO_VLEN(ctt->ctt_info);

	if (ctt->ctt_size <= CTF_MAX_SIZE) {
		size = ctt->ctt_size;
		tlen = sizeof(struct ctf_stype);
	} else {
		size = CTF_TYPE_LSIZE(ctt);
		tlen = sizeof(struct ctf_type);
	}

	switch (kind) {
	case CTF_K_UNKNOWN:
	case CTF_K_FORWARD:
		break;
	case CTF_K_INTEGER:
		tlen += sizeof(uint32_t);
		break;
	case CTF_K_FLOAT:
		tlen += sizeof(uint32_t);
		break;
	case CTF_K_ARRAY:
		tlen += sizeof(struct ctf_array);
		break;
	case CTF_K_FUNCTION:
		tlen += (vlen + (vlen & 1)) * sizeof(uint16_t);
		break;
	case CTF_K_STRUCT:
	case CTF_K_UNION:
		if (size < CTF_LSTRUCT_THRESH) {
			for (i = 0; i < vlen; i++) {
				tlen += sizeof(struct ctf_member);
			}
		} else {
			for (i = 0; i < vlen; i++) {
				tlen += sizeof(struct ctf_lmember);
			}
		}
		break;
	case CTF_K_ENUM:
		for (i = 0; i < vlen; i++) {
			tlen += sizeof(struct ctf_enum);
		}
		break;
	case CTF_K_POINTER:
	case CTF_K_TYPEDEF:
	case CTF_K_VOLATILE:
	case CTF_K_CONST:
	case CTF_K_RESTRICT:
		break;
	default:
		return 0;
	}

	return tlen;
}

/*
 * Return the CTF type associated to an ELF symbol.
 */
const struct ctf_type *
db_ctf_type_by_symbol(Elf_Sym *st)
{
	Elf_Sym			*symp;
	uint32_t		 objtoff = db_ctf.cth->cth_objtoff;
	uint16_t		*dsp;
	size_t			 idx = 0;

	if (!db_ctf.ctf_found || st == NULL)
		return NULL;

	while (objtoff < db_ctf.cth->cth_funcoff) {
		dsp = (uint16_t *)(db_ctf.data + objtoff);

		symp = db_ctf_idx2sym(&idx, STT_OBJECT);
		if (symp == NULL)
			break;
		if (symp == st)
			return db_ctf_type_by_index(*dsp);

		objtoff += sizeof(*dsp);
	}

	return NULL;
}

/*
 * Return the CTF type corresponding to a given index in the type section.
 */
const struct ctf_type *
db_ctf_type_by_index(uint16_t index)
{
	uint32_t		 offset = db_ctf.cth->cth_typeoff;
	uint16_t		 idx = 1;

	if (!db_ctf.ctf_found)
		return NULL;

	while (offset < db_ctf.cth->cth_stroff) {
		const struct ctf_type   *ctt;
		uint32_t		 toff;

		ctt = (struct ctf_type *)(db_ctf.data + offset);
		if (idx == index)
			return ctt;

		toff = db_ctf_type_len(ctt);
		if (toff == 0) {
			db_printf("incorrect type at offset %u", offset);
			break;
		}
		offset += toff;
		idx++;
	}

	return NULL;
}

/*
 * Pretty print `addr'.
 */
void
db_ctf_pprint(const struct ctf_type *ctt, vaddr_t addr)
{
	const struct ctf_type	*ref;
	uint16_t		 kind;

	kind = CTF_INFO_KIND(ctt->ctt_info);

	switch (kind) {
	case CTF_K_FLOAT:
	case CTF_K_ENUM:
	case CTF_K_ARRAY:
	case CTF_K_FUNCTION:
		db_printf("%lu", *((unsigned long *)addr));
		break;
	case CTF_K_INTEGER:
		db_printf("%d", *((int *)addr));
		break;
	case CTF_K_STRUCT:
	case CTF_K_UNION:
		db_ctf_pprint_struct(ctt, addr);
		break;
	case CTF_K_POINTER:
		db_ctf_pprint_ptr(ctt, addr);
		break;
	case CTF_K_TYPEDEF:
	case CTF_K_VOLATILE:
	case CTF_K_CONST:
	case CTF_K_RESTRICT:
		ref = db_ctf_type_by_index(ctt->ctt_type);
		db_ctf_pprint(ref, addr);
		break;
	case CTF_K_UNKNOWN:
	case CTF_K_FORWARD:
	default:
		break;
	}
}

void
db_ctf_pprint_struct(const struct ctf_type *ctt, vaddr_t addr)
{
	const char		*name, *p = (const char *)ctt;
	const struct ctf_type	*ref;
	uint32_t		 toff;
	uint64_t		 size;
	uint16_t		 i, vlen;

	vlen = CTF_INFO_VLEN(ctt->ctt_info);

	if (ctt->ctt_size <= CTF_MAX_SIZE) {
		size = ctt->ctt_size;
		toff = sizeof(struct ctf_stype);
	} else {
		size = CTF_TYPE_LSIZE(ctt);
		toff = sizeof(struct ctf_type);
	}

	db_printf("{");
	if (size < CTF_LSTRUCT_THRESH) {

		for (i = 0; i < vlen; i++) {
			struct ctf_member	*ctm;

			ctm = (struct ctf_member *)(p + toff);
			toff += sizeof(struct ctf_member);

			name = db_ctf_off2name(ctm->ctm_name);
			if (name != NULL)
				db_printf("%s = ", name);
			ref = db_ctf_type_by_index(ctm->ctm_type);
			db_ctf_pprint(ref, addr + ctm->ctm_offset / 8);
			if (i < vlen - 1)
				db_printf(", ");
		}
	} else {
		for (i = 0; i < vlen; i++) {
			struct ctf_lmember	*ctlm;

			ctlm = (struct ctf_lmember *)(p + toff);
			toff += sizeof(struct ctf_lmember);

			name = db_ctf_off2name(ctlm->ctlm_name);
			if (name != NULL)
				db_printf("%s = ", name);
			ref = db_ctf_type_by_index(ctlm->ctlm_type);
			db_ctf_pprint(ref, addr +
			    CTF_LMEM_OFFSET(ctlm) / 8);
			if (i < vlen - 1)
				db_printf(", ");
		}
	}
	db_printf("}");
}

void
db_ctf_pprint_ptr(const struct ctf_type *ctt, vaddr_t addr)
{
	const char		*name, *modif = "";
	const struct ctf_type	*ref;
	uint16_t		 kind;

	ref = db_ctf_type_by_index(ctt->ctt_type);
	kind = CTF_INFO_KIND(ref->ctt_info);

	switch (kind) {
	case CTF_K_VOLATILE:
		modif = "volatile ";
		ref = db_ctf_type_by_index(ref->ctt_type);
		break;
	case CTF_K_CONST:
		modif = "const ";
		ref = db_ctf_type_by_index(ref->ctt_type);
		break;
	case CTF_K_STRUCT:
		modif = "struct ";
		break;
	case CTF_K_UNION:
		modif = "union ";
		break;
	default:
		break;
	}

	name = db_ctf_off2name(ref->ctt_name);
	if (name != NULL)
		db_printf("(%s%s *)", modif, name);

	db_printf("0x%lx", addr);
}

static const char *
db_ctf_off2name(uint32_t offset)
{
	const char		*name;

	if (CTF_NAME_STID(offset) != CTF_STRTAB_0)
		return "external";

	if (CTF_NAME_OFFSET(offset) >= db_ctf.cth->cth_strlen)
		return "exceeds strlab";

	if (db_ctf.cth->cth_stroff + CTF_NAME_OFFSET(offset) >= db_ctf.dlen)
		return "invalid";

	name = db_ctf.data + db_ctf.cth->cth_stroff + CTF_NAME_OFFSET(offset);
	if (*name == '\0')
		return NULL;

	return name;
}

static char *
db_ctf_decompress(const char *buf, size_t size, off_t len)
{
	z_stream		 stream;
	char			*data;
	int			 error;

	data = malloc(len, M_TEMP, M_WAITOK|M_ZERO|M_CANFAIL);
	if (data == NULL)
		return NULL;

	memset(&stream, 0, sizeof(stream));
	stream.next_in = (void *)buf;
	stream.avail_in = size;
	stream.next_out = data;
	stream.avail_out = len;

	if ((error = inflateInit(&stream)) != Z_OK) {
		db_printf("zlib inflateInit failed: %s", zError(error));
		goto exit;
	}

	if ((error = inflate(&stream, Z_FINISH)) != Z_STREAM_END) {
		db_printf("zlib inflate failed: %s", zError(error));
		inflateEnd(&stream);
		goto exit;
	}

	if ((error = inflateEnd(&stream)) != Z_OK) {
		db_printf("zlib inflateEnd failed: %s", zError(error));
		goto exit;
	}

	if (stream.total_out != len) {
		db_printf("decompression failed: %llu != %llu",
		    stream.total_out, len);
		goto exit;
	}

	return data;

exit:
	free(data, M_DEVBUF, sizeof(*data));
	return NULL;
}

/*
 * pprint <symbol name>
 */
void
db_ctf_pprint_cmd(db_expr_t addr, int have_addr, db_expr_t count, char *modif)
{
	Elf_Sym *st;
	const struct ctf_type *ctt;
	int t;

	/*
	 * Read the struct name from the debugger input.
	 */
	t = db_read_token();
	if (t != tIDENT) {
		db_printf("Bad symbol name\n");
		db_flush_lex();
		return;
	}

	if ((st = db_symbol_by_name(db_tok_string, &addr)) == NULL) {
		db_printf("Symbol not found %s\n", db_tok_string);
		db_flush_lex();
		return;
	}

	if ((ctt = db_ctf_type_by_symbol(st)) == NULL) {
	        modif[0] = '\0';
		db_print_cmd(addr, 0, 0, modif);
		db_flush_lex();
		return;
	}

	db_printf("%s:\t", db_tok_string);
	db_ctf_pprint(ctt, addr);
	db_printf("\n");
}
@


1.15
log
@Restore "print" in ddb; add "pp[rint]" for pretty-printing

Changing the "print" command to use db_ctf_pprint_cmd() broke all documented
uses and "examine" does not allow printing variables, or individual registers.

For now it is better to leave the "print" command intact, and in sync with the
ddb(4) man page, but we still want "pp[rint]" to replace the "print" command
when it works better.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.14 2017/08/11 20:47:21 mpi Exp $	*/
d307 1
a307 1
db_ctf_pprintf(const struct ctf_type *ctt, vaddr_t addr)
d336 1
a336 1
		db_ctf_pprintf(ref, addr);
d377 1
a377 1
			db_ctf_pprintf(ref, addr + ctm->ctm_offset / 8);
d392 1
a392 1
			db_ctf_pprintf(ref, addr +
d538 1
a538 1
	db_ctf_pprintf(ctt, addr);
@


1.14
log
@Fall back using db_print_cmd() if no CTF data has been found.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.13 2017/08/11 16:57:19 mpi Exp $	*/
d505 1
a505 1
 * print <symbol name>
@


1.13
log
@Improve pretty printing of pointers.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.12 2017/08/11 15:08:13 mpi Exp $	*/
d253 3
d508 1
a508 2
db_ctf_pprint_cmd(db_expr_t addr, int have_addr, db_expr_t count,
    char *modifiers)
a513 3
	if (!db_ctf.ctf_found)
		return;

a529 1

d531 2
a532 1
		db_printf("Type not found %s\n", db_tok_string);
@


1.12
log
@Remove debugging leftovers, document functions, bump copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.11 2017/08/10 19:39:38 mpi Exp $	*/
d61 1
a307 1
	const char		*name;
d326 1
a326 5
		ref = db_ctf_type_by_index(ctt->ctt_type);
		name = db_ctf_off2name(ref->ctt_name);
		if (name != NULL)
			db_printf("(%s *)", name);
		db_printf("0x%lx", addr);
d396 36
@


1.11
log
@With a CTF kernel, DDB's print command will now pretty-print symbols.

Casting a type is not yet supported.

ok kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.10 2017/05/30 15:39:05 mpi Exp $	*/
d4 1
a5 1
 * Copyright (c) 2016 Martin Pieuchot <mpi@@openbsd.org>
d241 3
a243 25
void
db_ctf_dump_object()
{
	uint32_t		 objtoff = db_ctf.cth->cth_objtoff;
	size_t			 idx = 0, i = 0;
	uint16_t		*dsp;
	Elf_Sym			*st;
	int			 l;
	char			*name;

	while (objtoff < db_ctf.cth->cth_funcoff) {
		dsp = (uint16_t *)(db_ctf.data + objtoff);

		l = db_printf("  [%zu] %u", i++, *dsp);
		if ((st = db_ctf_idx2sym(&idx, STT_OBJECT)) != NULL) {
			db_symbol_values(st, &name, NULL);
			db_printf("%*s %s (%zu)\n", (14 - l), "", name, idx);
		} else
			db_printf("\n");

		objtoff += sizeof(*dsp);
	}
	db_printf("\n");
}

d267 3
d299 3
@


1.10
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.9 2017/05/29 06:14:10 mpi Exp $	*/
d29 1
a29 1
#include <ddb/db_sym.h>
d31 1
d33 1
d54 1
a54 1
static const char	*db_ctf_lookup_name(uint32_t);
d58 4
a104 27
void
db_dump_ctf_header(void)
{
	if (!db_ctf.ctf_found)
		return;

	db_printf("CTF header found at %p (%ld)\n", db_ctf.rawctf,
		  db_ctf.rawctflen);
	db_printf("cth_magic: 0x%04x\n", db_ctf.cth->cth_magic);
	db_printf("cth_verion: %d\n", db_ctf.cth->cth_version);
	db_printf("cth_flags: 0x%02x", db_ctf.cth->cth_flags);
	if (db_ctf.cth->cth_flags & CTF_F_COMPRESS) {
		db_printf(" (compressed)");
	}
	db_printf("\n");
	db_printf("cth_parlabel: %s\n",
		  db_ctf_lookup_name(db_ctf.cth->cth_parlabel));
	db_printf("cth_parname: %s\n",
		  db_ctf_lookup_name(db_ctf.cth->cth_parname));
	db_printf("cth_lbloff: %d\n", db_ctf.cth->cth_lbloff);
	db_printf("cth_objtoff: %d\n", db_ctf.cth->cth_objtoff);
	db_printf("cth_funcoff: %d\n", db_ctf.cth->cth_funcoff);
	db_printf("cth_typeoff: %d\n", db_ctf.cth->cth_typeoff);
	db_printf("cth_stroff: %d\n", db_ctf.cth->cth_stroff);
	db_printf("cth_strlen: %d\n", db_ctf.cth->cth_strlen);
}

d136 1
a136 1
	Elf_Sym			*symp, *stp = (Elf_Sym *)st;
d141 1
a141 1
	if (!db_ctf.ctf_found || stp == NULL)
d167 1
a167 1
		if (symp == stp)
d174 244
d419 1
a419 1
db_ctf_lookup_name(uint32_t offset)
d434 1
a434 1
		return "(anon)";
d483 42
@


1.9
log
@Pass the symbol instead of its name when looking for CTF infos.

ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.8 2017/05/28 14:24:19 mpi Exp $	*/
d155 1
a155 1
db_ctf_func_numargs(db_sym_t st)
@


1.8
log
@If a function is not found in the CTF data, do not assume it takes no
argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.7 2017/05/28 11:41:52 mpi Exp $	*/
d53 1
a53 1
static const char	*db_ctf_idx2sym(size_t *, uint8_t);
d131 1
a131 1
static const char *
d145 1
a145 1
		return db_ctf.strtab + symp->st_name;
d155 1
a155 1
db_ctf_func_numargs(const char *funcname)
d157 1
a158 1
	const char		*fname;
d162 1
a162 1
	if (!db_ctf.ctf_found)
d170 2
a171 2
		fname = db_ctf_idx2sym(&idx, STT_FUNC);
		if (fname == NULL)
d188 1
a188 1
		if (strcmp(funcname, fname) == 0)
@


1.7
log
@Merge two functions to lookup ELF sections by name.

ok claudio@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.6 2017/05/27 15:05:16 mpi Exp $	*/
d163 1
a163 1
		return 0;
d192 1
a192 1
	return 0;
@


1.6
log
@Spring cleanup:

- Cache the string table pointer
- Unify return statements
- Use the end of the symbol table rather than counting symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.5 2017/05/09 11:09:38 mpi Exp $	*/
a53 1
static const char	*db_elf_find_ctf(db_symtab_t *, size_t *);
d76 1
a76 1
	db_ctf.rawctf = db_elf_find_ctf(stab, &rawctflen);
a96 24
}

/*
 * Internal helper function - return a pointer to the CTF section
 */
static const char *
db_elf_find_ctf(db_symtab_t *stab, size_t *size)
{
	Elf_Ehdr *elf = STAB_TO_EHDR(stab);
	Elf_Shdr *shp = STAB_TO_SHDR(stab, elf);
	char *shstrtab;
	int i;

	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;

	for (i = 0; i < elf->e_shnum; i++) {
		if ((shp[i].sh_flags & SHF_ALLOC) != 0 &&
		    strcmp(ELF_CTF, shstrtab+shp[i].sh_name) == 0) {
			*size = shp[i].sh_size;
			return ((char *)elf + shp[i].sh_offset);
		}
	}

	return (NULL);
@


1.5
log
@Use C99 types.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.4 2016/09/18 13:31:12 jasper Exp $	*/
d42 5
a46 2
	const char 		*data;
	off_t			 dlen;
a47 3
	uint32_t 		 nsyms;
        size_t			 ctftab_size;
	const char		*ctftab;
a51 9
/*
 * We need a way to get the number of symbols, so (ab)use db_elf_sym_forall()
 * to give us the count.
 */
struct db_ctf_forall_arg {
	int		cnt;
	db_sym_t	sym;
};

d54 1
a54 1
static const char	*db_elf_find_ctftab(db_symtab_t *, size_t *);
a55 2
static int		 db_ctf_print_functions();
static void		 db_ctf_forall(db_sym_t, char *, char *, int, void *);
a63 1
	struct db_ctf_forall_arg dfa;
d65 1
a65 3
	const char *ctftab;
	size_t ctftab_size;
	int nsyms;
d70 9
a78 2
	ctftab = db_elf_find_ctftab(stab, &ctftab_size);
	if (ctftab == NULL) {
a79 1
	}
d81 2
a82 3
	db_ctf.ctftab = ctftab;
	db_ctf.ctftab_size = ctftab_size;
	db_ctf.cth = (struct ctf_header *)ctftab;
d85 2
a86 9
	/* Now decompress the section, take into account to skip the header */
	if (db_ctf.cth->cth_flags & CTF_F_COMPRESS) {
		if ((db_ctf.data =
		     db_ctf_decompress(db_ctf.ctftab + sizeof(*db_ctf.cth),
				      db_ctf.ctftab_size - sizeof(*db_ctf.cth),
				       db_ctf.dlen)) == NULL)
			return;
	} else {
		db_printf("Unsupported non-compressed CTF section encountered\n");
d90 4
a93 10
	/*
	 * Lookup the total number of kernel symbols. It's unlikely for the
	 * kernel to have zero symbols so bail out if that's what we end
	 * up finding.
	 */
	dfa.cnt = 0;
	db_elf_sym_forall(db_ctf_forall, &dfa);
	nsyms = -dfa.cnt;

	if (nsyms == 0)
a94 2
	else
		db_ctf.nsyms = nsyms;
a99 9
static void
db_ctf_forall(db_sym_t sym, char *name, char *suff, int pre, void *varg)
{
	struct db_ctf_forall_arg *arg = varg;

	if (arg->cnt-- == 0)
		arg->sym = sym;
}

d101 1
a101 2
 * Internal helper function - return a pointer to the CTF table
 * for the current symbol table (and update the size).
d104 1
a104 1
db_elf_find_ctftab(db_symtab_t *stab, size_t *size)
d130 2
a131 2
	db_printf("CTF header found at %p (%ld)\n", db_ctf.ctftab,
		  db_ctf.ctftab_size);
a148 4

#if 1
	db_ctf_print_functions();
#endif
d159 2
a160 15
	db_symtab_t *stab = &db_symtab;
	Elf_Sym *symp, *symtab_start;
	const Elf_Sym *st;
	char *strtab;
	size_t i;

	if (stab->private == NULL)
		return (NULL);

	strtab = db_elf_find_strtab(stab);
	if (strtab == NULL)
		return (NULL);

	symtab_start = STAB_TO_SYMSTART(stab);
	symp = symtab_start;
d162 2
a163 2
	for (i = *idx + 1; i < db_ctf.nsyms; i++) {
		st = &symp[i];
d165 2
a166 1
		if (ELF_ST_TYPE(st->st_info) != type)
d170 1
a170 1
		return strtab + st->st_name;
d173 1
a173 1
	return (NULL);
d182 2
a183 1
	const char		*s;
d185 1
a185 2
	size_t			 idx = 0;
	int			 nargs;
d188 10
a197 1
		return (0);
a198 2
	fsp = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
a200 1
		s = db_ctf_idx2sym(&idx, STT_FUNC);
d206 5
a210 10
		nargs = 0;
		if (s != NULL) {
			/*
			 * We have to keep increasing fsp++ while walking the
			 * table even if we discard the value at that location.
			 * This is required to keep a moving index.
			 *
			 * First increment for the return type, then for each
			 * parameter type.
			 */
d213 2
a214 9
			while (vlen-- > 0) {
				nargs++;
				fsp++;
			}

			if (strncmp(funcname, s, strlen(funcname)) == 0) {
				return (nargs);
			}
		}
a216 32
	return (0);
}

static int
db_ctf_print_functions(void)
{
	uint16_t		*fsp, kind, vlen;
	size_t			 idx = 0, i = 0;
	const char		*s;
	int			 l;

	if (!db_ctf.ctf_found)
		return 1;

	fsp = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
		kind = CTF_INFO_KIND(*fsp);
		vlen = CTF_INFO_VLEN(*fsp);
		fsp++;

		if (kind == CTF_K_UNKNOWN && vlen == 0)
			continue;

		l = db_printf("  [%zu] FUNC ", i++);
		if ((s = db_ctf_idx2sym(&idx, STT_FUNC)) != NULL)
			db_printf("(%s)", s);
		db_printf(" returns: %u args: (", *fsp++);
		while (vlen-- > 0)
			db_printf("%u%s", *fsp++, (vlen > 0) ? ", " : "");
		db_printf(") idx: %zu\n", idx);
	}
	db_printf("\n");
a247 1
	/* XXX: drop malloc(9) usage */
d249 2
a250 3
	if (data == NULL) {
		return (NULL);
	}
d280 1
a280 1
	return (data);
d284 1
a284 1
	return (NULL);
@


1.4
log
@- inline db_ctf_nsyms() into it's only caller. the value remains cached and
  won't change, so there's no reason to call it again.
- remove explicit return from void function

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.3 2016/09/17 17:45:37 jasper Exp $	*/
d44 2
a45 2
	unsigned int 		 ctf_found;
	unsigned int 		 nsyms;
d61 2
a62 2
static const char	*db_ctf_lookup_name(unsigned int);
static const char	*db_ctf_idx2sym(size_t *, unsigned char);
d195 1
a195 1
db_ctf_idx2sym(size_t *idx, unsigned char type)
d233 1
a233 1
	unsigned short		*fsp, kind, vlen;
d240 2
a241 2
	fsp = (unsigned short *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (unsigned short *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
d279 1
a279 1
	unsigned short		*fsp, kind, vlen;
d287 2
a288 2
	fsp = (unsigned short *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (unsigned short *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
d309 1
a309 1
db_ctf_lookup_name(unsigned int offset)
@


1.3
log
@rename ddb/db_ctf.h to sys/ctf.h which is the expected location for the public
CTF bits.

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.2 2016/09/17 17:39:34 jasper Exp $	*/
d52 9
d66 1
a66 1
static int		 db_ctf_nsyms(void);
d75 1
d106 10
a115 2
	/* Lookup the total number of kernel symbols. */
	if ((nsyms = db_ctf_nsyms()) == 0)
d124 9
a186 35
	return;
}

/*
 * We need a way to get the number of symbols, so (ab)use db_elf_sym_forall()
 * to give us the count.
 */
struct db_ctf_forall_arg {
	int cnt;
	db_sym_t sym;
};

static void db_ctf_forall(db_sym_t, char *, char *, int, void *);

static void
db_ctf_forall(db_sym_t sym, char *name, char *suff, int pre, void *varg)
{
	struct db_ctf_forall_arg *arg = varg;

	if (arg->cnt-- == 0)
		arg->sym = sym;
}

static int
db_ctf_nsyms(void)
{
	int nsyms;
	struct db_ctf_forall_arg dfa;

	dfa.cnt = 0;
	db_elf_sym_forall(db_ctf_forall, &dfa);
	nsyms = -dfa.cnt;

	/* The caller must make sure to handle zero symbols. */
	return nsyms;
@


1.2
log
@move the .SUNW_ctf section name definition to exec_elf.h and document it in elf(5)

feedback from guenther@@
ok guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.1 2016/09/16 19:13:17 jasper Exp $	*/
a31 1
#include <ddb/db_ctf.h>
d34 1
@


1.1
log
@teach ddb(4) about CTF. currently it only loads the CTF and uses it on amd64
to lookup the number of function parameters. however having this basic
facility allows us to expand it's usage.

currently hidden behind the (disabled) DDBCTF kernel option as some of the
required tools are not available in base yet. in addition to that one
also needs recent bootblocks that load the .SUNW_ctf kernel section.

discussed with mpi@@ over many a cider and ale in cambridge
feedback and ok guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a57 2

#define	ELF_CTF ".SUNW_ctf"
@

