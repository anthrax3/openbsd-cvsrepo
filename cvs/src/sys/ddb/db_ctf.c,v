head	1.9;
access;
symbols
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2017.05.29.06.14.10;	author mpi;	state Exp;
branches;
next	1.8;
commitid	kOJ4rx83W4cr7RQt;

1.8
date	2017.05.28.14.24.19;	author mpi;	state Exp;
branches;
next	1.7;
commitid	78V0YPcBVaG7RVc5;

1.7
date	2017.05.28.11.41.52;	author mpi;	state Exp;
branches;
next	1.6;
commitid	yu9JCnXPI4UfHZwC;

1.6
date	2017.05.27.15.05.16;	author mpi;	state Exp;
branches;
next	1.5;
commitid	cECKQ1lNnkS6XMGg;

1.5
date	2017.05.09.11.09.38;	author mpi;	state Exp;
branches;
next	1.4;
commitid	UzmDwJvp8m0SwFZd;

1.4
date	2016.09.18.13.31.12;	author jasper;	state Exp;
branches;
next	1.3;
commitid	NUgpgJSAwH3DK0AA;

1.3
date	2016.09.17.17.45.37;	author jasper;	state Exp;
branches;
next	1.2;
commitid	BdocISuEyIsE3GnQ;

1.2
date	2016.09.17.17.39.34;	author jasper;	state Exp;
branches;
next	1.1;
commitid	yiSnvoseCUtTmo9S;

1.1
date	2016.09.16.19.13.17;	author jasper;	state Exp;
branches;
next	;
commitid	aag1XqKQQN6pS0l5;


desc
@@


1.9
log
@Pass the symbol instead of its name when looking for CTF infos.

ok jasper@@
@
text
@/*	$OpenBSD: db_ctf.c,v 1.8 2017/05/28 14:24:19 mpi Exp $	*/

/*
 * Copyright (c) 2016 Jasper Lievisse Adriaanse <jasper@@openbsd.org>
 * Copyright (c) 2016 Martin Pieuchot <mpi@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/types.h>
#include <sys/stdint.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>

#include <machine/db_machdep.h>

#include <ddb/db_extern.h>
#include <ddb/db_sym.h>
#include <ddb/db_elf.h>
#include <ddb/db_output.h>

#include <sys/exec_elf.h>
#include <sys/ctf.h>
#include <sys/malloc.h>
#include <lib/libz/zlib.h>

extern db_symtab_t		db_symtab;

struct ddb_ctf {
	struct ctf_header 	*cth;
	const char		*rawctf;	/* raw .SUNW_ctf section */
        size_t			 rawctflen;	/* raw .SUNW_ctf section size */
	const char 		*data;		/* decompressed CTF data */
	size_t			 dlen;		/* decompressed CTF data size */
	char			*strtab;	/* ELF string table */
	uint32_t 		 ctf_found;
};

struct ddb_ctf db_ctf;

static const char	*db_ctf_lookup_name(uint32_t);
static Elf_Sym		*db_ctf_idx2sym(size_t *, uint8_t);
static char		*db_ctf_decompress(const char *, size_t, off_t);

/*
 * Entrypoint to verify CTF presence, initialize the header, decompress
 * the data, etc.
 */
void
db_ctf_init(void)
{
	db_symtab_t *stab = &db_symtab;
	size_t rawctflen;

	/* Assume nothing was correct found until proven otherwise. */
	db_ctf.ctf_found = 0;

	if (stab->private == NULL)
		return;

	db_ctf.strtab = db_elf_find_strtab(stab);
	if (db_ctf.strtab == NULL)
		return;

	db_ctf.rawctf = db_elf_find_section(stab, &rawctflen, ELF_CTF);
	if (db_ctf.rawctf == NULL)
		return;

	db_ctf.rawctflen = rawctflen;
	db_ctf.cth = (struct ctf_header *)db_ctf.rawctf;
	db_ctf.dlen = db_ctf.cth->cth_stroff + db_ctf.cth->cth_strlen;

	if ((db_ctf.cth->cth_flags & CTF_F_COMPRESS) == 0) {
		printf("unsupported non-compressed CTF section\n");
		return;
	}

	/* Now decompress the section, take into account to skip the header */
	db_ctf.data = db_ctf_decompress(db_ctf.rawctf + sizeof(*db_ctf.cth),
	    db_ctf.rawctflen - sizeof(*db_ctf.cth), db_ctf.dlen);
	if (db_ctf.data == NULL)
		return;

	/* We made it this far, everything seems fine. */
	db_ctf.ctf_found = 1;
}

void
db_dump_ctf_header(void)
{
	if (!db_ctf.ctf_found)
		return;

	db_printf("CTF header found at %p (%ld)\n", db_ctf.rawctf,
		  db_ctf.rawctflen);
	db_printf("cth_magic: 0x%04x\n", db_ctf.cth->cth_magic);
	db_printf("cth_verion: %d\n", db_ctf.cth->cth_version);
	db_printf("cth_flags: 0x%02x", db_ctf.cth->cth_flags);
	if (db_ctf.cth->cth_flags & CTF_F_COMPRESS) {
		db_printf(" (compressed)");
	}
	db_printf("\n");
	db_printf("cth_parlabel: %s\n",
		  db_ctf_lookup_name(db_ctf.cth->cth_parlabel));
	db_printf("cth_parname: %s\n",
		  db_ctf_lookup_name(db_ctf.cth->cth_parname));
	db_printf("cth_lbloff: %d\n", db_ctf.cth->cth_lbloff);
	db_printf("cth_objtoff: %d\n", db_ctf.cth->cth_objtoff);
	db_printf("cth_funcoff: %d\n", db_ctf.cth->cth_funcoff);
	db_printf("cth_typeoff: %d\n", db_ctf.cth->cth_typeoff);
	db_printf("cth_stroff: %d\n", db_ctf.cth->cth_stroff);
	db_printf("cth_strlen: %d\n", db_ctf.cth->cth_strlen);
}

/*
 * Convert an index to a symbol name while ensuring the type is matched.
 * It must be noted this only works if the CTF table has the same order
 * as the symbol table.
 */
Elf_Sym *
db_ctf_idx2sym(size_t *idx, uint8_t type)
{
	Elf_Sym *symp, *symtab_start, *symtab_end;
	size_t i = *idx + 1;

	symtab_start = STAB_TO_SYMSTART(&db_symtab);
	symtab_end = STAB_TO_SYMEND(&db_symtab);

	for (symp = &symtab_start[i]; symp < symtab_end; i++, symp++) {
		if (ELF_ST_TYPE(symp->st_info) != type)
			continue;

		*idx = i;
		return symp;
	}

	return NULL;
}

/*
 * For a given function name, return the number of arguments.
 */
int
db_ctf_func_numargs(db_sym_t st)
{
	Elf_Sym			*symp, *stp = (Elf_Sym *)st;
	uint16_t		*fstart, *fend;
	uint16_t		*fsp, kind, vlen;
	size_t			 i, idx = 0;

	if (!db_ctf.ctf_found || stp == NULL)
		return -1;

	fstart = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	fend = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff);

	fsp = fstart;
	while (fsp < fend) {
		symp = db_ctf_idx2sym(&idx, STT_FUNC);
		if (symp == NULL)
			break;

		kind = CTF_INFO_KIND(*fsp);
		vlen = CTF_INFO_VLEN(*fsp);
		fsp++;

		if (kind == CTF_K_UNKNOWN && vlen == 0)
			continue;

		/* Skip return type */
		fsp++;

		/* Skip argument types */
		for (i = 0; i < vlen; i++)
			fsp++;

		if (symp == stp)
			return vlen;
	}

	return -1;
}

static const char *
db_ctf_lookup_name(uint32_t offset)
{
	const char		*name;

	if (CTF_NAME_STID(offset) != CTF_STRTAB_0)
		return "external";

	if (CTF_NAME_OFFSET(offset) >= db_ctf.cth->cth_strlen)
		return "exceeds strlab";

	if (db_ctf.cth->cth_stroff + CTF_NAME_OFFSET(offset) >= db_ctf.dlen)
		return "invalid";

	name = db_ctf.data + db_ctf.cth->cth_stroff + CTF_NAME_OFFSET(offset);
	if (*name == '\0')
		return "(anon)";

	return name;
}

static char *
db_ctf_decompress(const char *buf, size_t size, off_t len)
{
	z_stream		 stream;
	char			*data;
	int			 error;

	data = malloc(len, M_TEMP, M_WAITOK|M_ZERO|M_CANFAIL);
	if (data == NULL)
		return NULL;

	memset(&stream, 0, sizeof(stream));
	stream.next_in = (void *)buf;
	stream.avail_in = size;
	stream.next_out = data;
	stream.avail_out = len;

	if ((error = inflateInit(&stream)) != Z_OK) {
		db_printf("zlib inflateInit failed: %s", zError(error));
		goto exit;
	}

	if ((error = inflate(&stream, Z_FINISH)) != Z_STREAM_END) {
		db_printf("zlib inflate failed: %s", zError(error));
		inflateEnd(&stream);
		goto exit;
	}

	if ((error = inflateEnd(&stream)) != Z_OK) {
		db_printf("zlib inflateEnd failed: %s", zError(error));
		goto exit;
	}

	if (stream.total_out != len) {
		db_printf("decompression failed: %llu != %llu",
		    stream.total_out, len);
		goto exit;
	}

	return data;

exit:
	free(data, M_DEVBUF, sizeof(*data));
	return NULL;
}
@


1.8
log
@If a function is not found in the CTF data, do not assume it takes no
argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.7 2017/05/28 11:41:52 mpi Exp $	*/
d53 1
a53 1
static const char	*db_ctf_idx2sym(size_t *, uint8_t);
d131 1
a131 1
static const char *
d145 1
a145 1
		return db_ctf.strtab + symp->st_name;
d155 1
a155 1
db_ctf_func_numargs(const char *funcname)
d157 1
a158 1
	const char		*fname;
d162 1
a162 1
	if (!db_ctf.ctf_found)
d170 2
a171 2
		fname = db_ctf_idx2sym(&idx, STT_FUNC);
		if (fname == NULL)
d188 1
a188 1
		if (strcmp(funcname, fname) == 0)
@


1.7
log
@Merge two functions to lookup ELF sections by name.

ok claudio@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.6 2017/05/27 15:05:16 mpi Exp $	*/
d163 1
a163 1
		return 0;
d192 1
a192 1
	return 0;
@


1.6
log
@Spring cleanup:

- Cache the string table pointer
- Unify return statements
- Use the end of the symbol table rather than counting symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.5 2017/05/09 11:09:38 mpi Exp $	*/
a53 1
static const char	*db_elf_find_ctf(db_symtab_t *, size_t *);
d76 1
a76 1
	db_ctf.rawctf = db_elf_find_ctf(stab, &rawctflen);
a96 24
}

/*
 * Internal helper function - return a pointer to the CTF section
 */
static const char *
db_elf_find_ctf(db_symtab_t *stab, size_t *size)
{
	Elf_Ehdr *elf = STAB_TO_EHDR(stab);
	Elf_Shdr *shp = STAB_TO_SHDR(stab, elf);
	char *shstrtab;
	int i;

	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;

	for (i = 0; i < elf->e_shnum; i++) {
		if ((shp[i].sh_flags & SHF_ALLOC) != 0 &&
		    strcmp(ELF_CTF, shstrtab+shp[i].sh_name) == 0) {
			*size = shp[i].sh_size;
			return ((char *)elf + shp[i].sh_offset);
		}
	}

	return (NULL);
@


1.5
log
@Use C99 types.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.4 2016/09/18 13:31:12 jasper Exp $	*/
d42 5
a46 2
	const char 		*data;
	off_t			 dlen;
a47 3
	uint32_t 		 nsyms;
        size_t			 ctftab_size;
	const char		*ctftab;
a51 9
/*
 * We need a way to get the number of symbols, so (ab)use db_elf_sym_forall()
 * to give us the count.
 */
struct db_ctf_forall_arg {
	int		cnt;
	db_sym_t	sym;
};

d54 1
a54 1
static const char	*db_elf_find_ctftab(db_symtab_t *, size_t *);
a55 2
static int		 db_ctf_print_functions();
static void		 db_ctf_forall(db_sym_t, char *, char *, int, void *);
a63 1
	struct db_ctf_forall_arg dfa;
d65 1
a65 3
	const char *ctftab;
	size_t ctftab_size;
	int nsyms;
d70 9
a78 2
	ctftab = db_elf_find_ctftab(stab, &ctftab_size);
	if (ctftab == NULL) {
a79 1
	}
d81 2
a82 3
	db_ctf.ctftab = ctftab;
	db_ctf.ctftab_size = ctftab_size;
	db_ctf.cth = (struct ctf_header *)ctftab;
d85 2
a86 9
	/* Now decompress the section, take into account to skip the header */
	if (db_ctf.cth->cth_flags & CTF_F_COMPRESS) {
		if ((db_ctf.data =
		     db_ctf_decompress(db_ctf.ctftab + sizeof(*db_ctf.cth),
				      db_ctf.ctftab_size - sizeof(*db_ctf.cth),
				       db_ctf.dlen)) == NULL)
			return;
	} else {
		db_printf("Unsupported non-compressed CTF section encountered\n");
d90 4
a93 10
	/*
	 * Lookup the total number of kernel symbols. It's unlikely for the
	 * kernel to have zero symbols so bail out if that's what we end
	 * up finding.
	 */
	dfa.cnt = 0;
	db_elf_sym_forall(db_ctf_forall, &dfa);
	nsyms = -dfa.cnt;

	if (nsyms == 0)
a94 2
	else
		db_ctf.nsyms = nsyms;
a99 9
static void
db_ctf_forall(db_sym_t sym, char *name, char *suff, int pre, void *varg)
{
	struct db_ctf_forall_arg *arg = varg;

	if (arg->cnt-- == 0)
		arg->sym = sym;
}

d101 1
a101 2
 * Internal helper function - return a pointer to the CTF table
 * for the current symbol table (and update the size).
d104 1
a104 1
db_elf_find_ctftab(db_symtab_t *stab, size_t *size)
d130 2
a131 2
	db_printf("CTF header found at %p (%ld)\n", db_ctf.ctftab,
		  db_ctf.ctftab_size);
a148 4

#if 1
	db_ctf_print_functions();
#endif
d159 2
a160 15
	db_symtab_t *stab = &db_symtab;
	Elf_Sym *symp, *symtab_start;
	const Elf_Sym *st;
	char *strtab;
	size_t i;

	if (stab->private == NULL)
		return (NULL);

	strtab = db_elf_find_strtab(stab);
	if (strtab == NULL)
		return (NULL);

	symtab_start = STAB_TO_SYMSTART(stab);
	symp = symtab_start;
d162 2
a163 2
	for (i = *idx + 1; i < db_ctf.nsyms; i++) {
		st = &symp[i];
d165 2
a166 1
		if (ELF_ST_TYPE(st->st_info) != type)
d170 1
a170 1
		return strtab + st->st_name;
d173 1
a173 1
	return (NULL);
d182 2
a183 1
	const char		*s;
d185 1
a185 2
	size_t			 idx = 0;
	int			 nargs;
d188 10
a197 1
		return (0);
a198 2
	fsp = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
a200 1
		s = db_ctf_idx2sym(&idx, STT_FUNC);
d206 5
a210 10
		nargs = 0;
		if (s != NULL) {
			/*
			 * We have to keep increasing fsp++ while walking the
			 * table even if we discard the value at that location.
			 * This is required to keep a moving index.
			 *
			 * First increment for the return type, then for each
			 * parameter type.
			 */
d213 2
a214 9
			while (vlen-- > 0) {
				nargs++;
				fsp++;
			}

			if (strncmp(funcname, s, strlen(funcname)) == 0) {
				return (nargs);
			}
		}
a216 32
	return (0);
}

static int
db_ctf_print_functions(void)
{
	uint16_t		*fsp, kind, vlen;
	size_t			 idx = 0, i = 0;
	const char		*s;
	int			 l;

	if (!db_ctf.ctf_found)
		return 1;

	fsp = (uint16_t *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (uint16_t *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
		kind = CTF_INFO_KIND(*fsp);
		vlen = CTF_INFO_VLEN(*fsp);
		fsp++;

		if (kind == CTF_K_UNKNOWN && vlen == 0)
			continue;

		l = db_printf("  [%zu] FUNC ", i++);
		if ((s = db_ctf_idx2sym(&idx, STT_FUNC)) != NULL)
			db_printf("(%s)", s);
		db_printf(" returns: %u args: (", *fsp++);
		while (vlen-- > 0)
			db_printf("%u%s", *fsp++, (vlen > 0) ? ", " : "");
		db_printf(") idx: %zu\n", idx);
	}
	db_printf("\n");
a247 1
	/* XXX: drop malloc(9) usage */
d249 2
a250 3
	if (data == NULL) {
		return (NULL);
	}
d280 1
a280 1
	return (data);
d284 1
a284 1
	return (NULL);
@


1.4
log
@- inline db_ctf_nsyms() into it's only caller. the value remains cached and
  won't change, so there's no reason to call it again.
- remove explicit return from void function

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.3 2016/09/17 17:45:37 jasper Exp $	*/
d44 2
a45 2
	unsigned int 		 ctf_found;
	unsigned int 		 nsyms;
d61 2
a62 2
static const char	*db_ctf_lookup_name(unsigned int);
static const char	*db_ctf_idx2sym(size_t *, unsigned char);
d195 1
a195 1
db_ctf_idx2sym(size_t *idx, unsigned char type)
d233 1
a233 1
	unsigned short		*fsp, kind, vlen;
d240 2
a241 2
	fsp = (unsigned short *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (unsigned short *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
d279 1
a279 1
	unsigned short		*fsp, kind, vlen;
d287 2
a288 2
	fsp = (unsigned short *)(db_ctf.data + db_ctf.cth->cth_funcoff);
	while (fsp < (unsigned short *)(db_ctf.data + db_ctf.cth->cth_typeoff)) {
d309 1
a309 1
db_ctf_lookup_name(unsigned int offset)
@


1.3
log
@rename ddb/db_ctf.h to sys/ctf.h which is the expected location for the public
CTF bits.

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.2 2016/09/17 17:39:34 jasper Exp $	*/
d52 9
d66 1
a66 1
static int		 db_ctf_nsyms(void);
d75 1
d106 10
a115 2
	/* Lookup the total number of kernel symbols. */
	if ((nsyms = db_ctf_nsyms()) == 0)
d124 9
a186 35
	return;
}

/*
 * We need a way to get the number of symbols, so (ab)use db_elf_sym_forall()
 * to give us the count.
 */
struct db_ctf_forall_arg {
	int cnt;
	db_sym_t sym;
};

static void db_ctf_forall(db_sym_t, char *, char *, int, void *);

static void
db_ctf_forall(db_sym_t sym, char *name, char *suff, int pre, void *varg)
{
	struct db_ctf_forall_arg *arg = varg;

	if (arg->cnt-- == 0)
		arg->sym = sym;
}

static int
db_ctf_nsyms(void)
{
	int nsyms;
	struct db_ctf_forall_arg dfa;

	dfa.cnt = 0;
	db_elf_sym_forall(db_ctf_forall, &dfa);
	nsyms = -dfa.cnt;

	/* The caller must make sure to handle zero symbols. */
	return nsyms;
@


1.2
log
@move the .SUNW_ctf section name definition to exec_elf.h and document it in elf(5)

feedback from guenther@@
ok guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_ctf.c,v 1.1 2016/09/16 19:13:17 jasper Exp $	*/
a31 1
#include <ddb/db_ctf.h>
d34 1
@


1.1
log
@teach ddb(4) about CTF. currently it only loads the CTF and uses it on amd64
to lookup the number of function parameters. however having this basic
facility allows us to expand it's usage.

currently hidden behind the (disabled) DDBCTF kernel option as some of the
required tools are not available in base yet. in addition to that one
also needs recent bootblocks that load the .SUNW_ctf kernel section.

discussed with mpi@@ over many a cider and ale in cambridge
feedback and ok guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a57 2

#define	ELF_CTF ".SUNW_ctf"
@

