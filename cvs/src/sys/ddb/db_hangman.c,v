head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.2
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.22
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.20
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.18
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.16
	OPENBSD_5_0:1.28.0.14
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.12
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.10
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.6
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.8
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.23
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.4
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.13.0.8
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.13.0.6
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.37
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.36;
commitid	PnZZkFEIj4rPydZo;

1.36
date	2016.09.16.19.00.25;	author jasper;	state Exp;
branches;
next	1.35;
commitid	8eN8HXmO8EJhSS23;

1.35
date	2016.02.27.13.17.47;	author mpi;	state Exp;
branches;
next	1.34;
commitid	RePOJ1nAmEf9Lu6X;

1.34
date	2016.02.26.15.27.53;	author mpi;	state Exp;
branches;
next	1.33;
commitid	XYYHoM9XmVPaXGlI;

1.33
date	2016.01.27.10.37.12;	author mpi;	state Exp;
branches;
next	1.32;
commitid	Qlm598QQCEyskMtJ;

1.32
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.31;
commitid	p4LJxGKbi0BU2cG6;

1.31
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.30;
commitid	Z1vcFtHO8wRH0yRt;

1.30
date	2014.07.08.13.02.57;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	E2I6e8QZgMmNFC95;

1.29
date	2014.01.18.01.58.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.07.12.42.13;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.08.19.36.30;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.19.27.14;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.14.07.45.23;	author mdw;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.11.09.31.33;	author mdw;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.11.07.54.22;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.06.29.05.28.18;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.29.04.52.17;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.10.10.42.35;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.08.23.06.32;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.05.21.54.48;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	98.04.26.21.40.50;	author deraadt;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	97.09.08.19.46.19;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.19.22.31.17;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.11.29.06.51.49;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.11.28.19.01.49;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.10.21.05.11.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.29.09.26.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.17.12.07.00;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.31.10.37.25;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.14.00.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.13.58.43;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.12.34.37;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.05.12.23.14;	author mickey;	state Exp;
branches;
next	;

1.13.8.1
date	2001.05.14.22.06.58;	author niklas;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2001.07.04.10.40.07;	author niklas;	state Exp;
branches;
next	1.13.8.3;

1.13.8.3
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.13.8.4;

1.13.8.4
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.13.8.5;

1.13.8.5
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.13.8.6;

1.13.8.6
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@/*	$OpenBSD: db_hangman.c,v 1.36 2016/09/16 19:00:25 jasper Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt, Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <machine/db_machdep.h>

#include <ddb/db_sym.h>
#include <ddb/db_output.h>

#include <dev/cons.h>

#define ABC_ISCLR(c)	sabc->abc[(c)-'a']==0
#define ABC_ISWRONG(c)	sabc->abc[(c)-'a']=='_'
#define ABC_SETWRONG(c)		(sabc->abc[(c)-'a']='_')
#define ABC_SETRIGHT(c)		(sabc->abc[(c)-'a']='+')
#define ABC_CLR()	memset(sabc->abc,0,sizeof sabc->abc)
struct _abc {
	char	abc[26+2];	/* for int32 alignment */
};

#define	TOLOWER(c)	((c)|0x20)
#define	ISLOWALPHA(c)	('a'<=(c) && (c)<='z')
#define	ISALPHA(c)	ISLOWALPHA(TOLOWER(c))

void	 db_hang(int, char *, struct _abc *);

u_long		db_plays, db_guesses;

static const char hangpic[]=
	"\n88888\r\n"
	"9 7 6\r\n"
	"97  5\r\n"
	"9  423\r\n"
	"9   2\r\n"
	"9  1 0\r\n"
	"9\r\n"
	"9  ";
static const char substchar[]="\\/|\\/O|/-|";

struct db_hang_forall_arg {
	int cnt;
	Elf_Sym *sym;
};

/*
 * Horrible abuse of the forall function, but we're not in a hurry.
 */
static void db_hang_forall(Elf_Sym *, char *, char *, int, void *);

static void
db_hang_forall(Elf_Sym *sym, char *name, char *suff, int pre, void *varg)
{
	struct db_hang_forall_arg *arg = varg;

	if (arg->cnt-- == 0)
		arg->sym = sym;
}

static __inline char *
db_randomsym(size_t *lenp)
{
	int nsyms;
	char	*p, *q;
	struct db_hang_forall_arg dfa;

	dfa.cnt = 0;
	db_elf_sym_forall(db_hang_forall, &dfa);
	nsyms = -dfa.cnt;

	if (nsyms == 0)
		return (NULL);

	dfa.cnt = arc4random_uniform(nsyms);
	db_elf_sym_forall(db_hang_forall, &dfa);

	db_symbol_values(dfa.sym, &q, 0);

	/* strlen(q) && ignoring underscores and colons */
	for ((*lenp) = 0, p = q; *p; p++)
		if (ISALPHA(*p))
			(*lenp)++;

	return (q);
}

void
db_hang(int tries, char *word, struct _abc *sabc)
{
	const char	*p;
	int i;
	int c;
#ifdef ABC_BITMASK
	int m;
#endif

	for (p = hangpic; *p; p++)
		cnputc((*p >= '0' && *p <= '9') ? ((tries <= (*p) - '0') ?
		    substchar[(*p) - '0'] : ' ') : *p);

	for (p = word; *p; p++) {
		c = TOLOWER(*p);
		cnputc(ISLOWALPHA(c) && ABC_ISCLR(c) ? '-' : *p);
	}

#ifdef ABC_WRONGSTR
	db_printf(" (%s)\r", ABC_WRONGSTR);
#else
	db_printf(" (");

#ifdef ABC_BITMASK
	m = sabc->wrong;
	for (i = 'a'; i <= 'z'; ++i, m >>= 1)
		if (m&1)
			cnputc(i);
#else
	for (i = 'a'; i <= 'z'; ++i)
		if (ABC_ISWRONG(i))
			cnputc(i);
#endif

	db_printf(")\r");
#endif
}

void
db_hangman(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	char	*word;
	size_t	tries;
	size_t	len;
	struct _abc sabc[1];
	int	skill;

	if (modif[0] != 's' || (skill = modif[1] - '0') > 9U)
		skill = 3;
	word = NULL;
	tries = 0;
	for (;;) {

		if (word == NULL) {
			ABC_CLR();

			tries = skill + 1;
			word = db_randomsym(&len);
			if (word == NULL)
				break;

			db_plays++;
		}

		{
			int c;

			db_hang(tries, word, sabc);
			c = cngetc();
			c = TOLOWER(c);

			if (ISLOWALPHA(c) && ABC_ISCLR(c)) {
				char	*p;
				size_t	n;

					/* strchr(word,c) */
				for (n = 0, p = word; *p ; p++)
					if (TOLOWER(*p) == c)
						n++;

				if (n) {
					ABC_SETRIGHT(c);
					len -= n;
				} else {
					ABC_SETWRONG(c);
					tries--;
				}
			}
		}

		if (tries && len)
			continue;

		if (!tries && skill > 2) {
			char	*p = word;
			for (; *p; p++)
				if (ISALPHA(*p))
					ABC_SETRIGHT(TOLOWER(*p));
		}
		if (tries)
			db_guesses++;
		db_hang(tries, word, sabc);
		db_printf("\nScore: %lu/%lu\n", db_plays, db_guesses);
		word = NULL;
		if (tries)
			break;
	}
}
@


1.36
log
@drop unneeded casting noise

pointed out by guenther@@ in a separate diff
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.35 2016/02/27 13:17:47 mpi Exp $	*/
d69 1
a69 1
	db_sym_t sym;
d75 1
a75 1
static void db_hang_forall(db_sym_t, char *, char *, int, void *);
d78 1
a78 1
db_hang_forall(db_sym_t sym, char *name, char *suff, int pre, void *varg)
@


1.35
log
@Remove the "symbol table" argument of the functions dealing with
symbols.

There's no reason to ask the programmer to supply a specific symbol
table since the kernel only have one.

ok visa@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.34 2016/02/26 15:27:53 mpi Exp $	*/
d80 1
a80 1
	struct db_hang_forall_arg *arg = (struct db_hang_forall_arg *)varg;
@


1.34
log
@Remove support for multiple symbol tables in ddb(4), we only have one.

ok mlarkin@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.33 2016/01/27 10:37:12 mpi Exp $	*/
d75 1
a75 2
static void db_hang_forall(db_symtab_t *, db_sym_t, char *, char *, int,
			void *);
d78 1
a78 2
db_hang_forall(db_symtab_t *stab, db_sym_t sym, char *name, char *suff, int pre,
    void *varg)
a88 2
	extern db_symtab_t db_symtab;
	db_symtab_t *stab = &db_symtab;
a92 3
	if (stab->start == 0)
		return (NULL);

d94 1
a94 1
	db_elf_sym_forall(stab, db_hang_forall, &dfa);
d101 1
a101 3
	db_elf_sym_forall(stab, db_hang_forall, &dfa);

	q = db_qualify(dfa.sym, stab->name);
d103 1
a103 3
	/* don't show symtab name */
	while (*q++ != ':')
		;
@


1.33
log
@Removes the abstraction layer to support multiple executable binaries.

Simplifies the API to manipulate symbols now that all our architectures
are ELF.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.32 2015/03/14 03:38:46 jsg Exp $	*/
d91 3
a93 3
	extern db_symtab_t db_symtabs[];
	db_symtab_t *stab;
	int nsymtabs, nsyms;
d97 1
a97 4
	for (nsymtabs = 0; db_symtabs[nsymtabs].name != NULL; nsymtabs++)
		;

	if (nsymtabs == 0)
a99 2
	stab = &db_symtabs[arc4random_uniform(nsymtabs)];

d112 3
a114 3
	/* don't show symtab name if there are less than 3 of 'em */
	if (nsymtabs < 3)
		while (*q++ != ':');
@


1.32
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.31 2014/11/18 02:37:30 tedu Exp $	*/
d106 1
a106 1
	X_db_forall(stab, db_hang_forall, &dfa);
d113 1
a113 1
	X_db_forall(stab, db_hang_forall, &dfa);
@


1.31
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.30 2014/07/08 13:02:57 deraadt Exp $	*/
a34 1
#include <ddb/db_extern.h>
@


1.30
log
@These do not need the extremely poorly named uvm/uvm_extern.h (which
pulls in the universe). occasionally they need sys/systm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.29 2014/01/18 01:58:33 deraadt Exp $	*/
a38 1
#include <dev/rndvar.h>
@


1.29
log
@Use arc4random_uniform to increase the slightly difficulty of winning.
Kidding, the fix is to stop using the scheduler's PRNG.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.28 2008/04/18 06:42:20 djm Exp $	*/
d30 1
a30 2

#include <uvm/uvm_extern.h>
@


1.28
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.27 2006/07/07 12:42:13 mickey Exp $	*/
a69 8
static size_t
db_random(size_t mod)
{
	if (cold)
		return (random() % mod);
	return (arc4random_uniform(mod));
}

d106 1
a106 1
	stab = &db_symtabs[db_random(nsymtabs)];
d115 1
a115 1
	dfa.cnt = db_random(nsyms);
@


1.27
log
@only count right guess when had been guessed right; from Leonardo Chiquitto Filho <leonardo@@iken.com.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.26 2006/03/13 06:23:20 jsg Exp $	*/
d75 1
a75 1
	return (arc4random() % mod);
@


1.26
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.25 2005/01/08 19:36:30 mickey Exp $	*/
d130 1
a130 1
		while(*q++ != ':');
d150 1
a150 1
	for(p = hangpic; *p; p++)
d240 2
d243 1
a243 1
		db_printf("\nScore: %lu/%lu\n", db_plays, ++db_guesses);
d245 2
a246 1
		if (tries) break;
@


1.25
log
@radical size reduction from andreas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.24 2003/06/02 19:27:14 mickey Exp $	*/
d90 2
a91 7
db_hang_forall(stab, sym, name, suff, pre, varg)
	db_symtab_t *stab;
	db_sym_t sym;
	char *name;
	char *suff;
	int pre;
	void *varg;
d141 1
a141 4
db_hang(tries, word, sabc)
	int	tries;
	register char	*word;
	register struct _abc *sabc;
d143 1
a143 1
	register const char	*p;
d180 1
a180 5
db_hangman(addr, haddr, count, modif)
	db_expr_t addr;
	int	haddr;
	db_expr_t count;
	char	*modif;
d206 1
a206 1
			register int c;
d213 2
a214 2
				register char	*p;
				register size_t	n;
d235 1
a235 1
			register char	*p = word;
@


1.24
log
@kill the clauses three and four on my sources
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.23 2002/06/14 07:45:23 mdw Exp $	*/
d51 3
a53 2
#define	TOLOWER(c)	(('A'<=(c)&&(c)<='Z')?(c)-'A'+'a':(c))
#define	ISALPHA(c)	(('a'<=(c)&&(c)<='z')||('A'<=(c)&&(c)<='Z'))
d162 4
a165 2
	for (p = word; (c = TOLOWER(*p)); p++)
		cnputc(ISALPHA(c) && ABC_ISCLR(c) ? '-' : *p);
d224 1
a224 1
			if (ISALPHA(c) && ABC_ISCLR(c)) {
@


1.23
log
@992 bytes.  Also works if random function returns 0 first time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.22 2002/06/11 09:31:33 mdw Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.22
log
@Saves 4 bytes of filespace
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.21 2002/06/11 07:54:22 jason Exp $	*/
d47 9
d59 1
a59 1
void	 db_hang(int, char *, char *);
a60 1
static int	skill;
d63 12
a74 1
static __inline size_t
d104 1
a104 1
	if (--arg->cnt == 0)
d125 1
a125 1
	dfa.cnt = 1000000;
d127 1
a127 3
	if (dfa.cnt <= 0)
		return (NULL);
	nsyms = 1000000 - dfa.cnt;
a148 11
static const char hangpic[]=
	"\n88888 \r\n"
	"9 7 6 \r\n"
	"97  5 \r\n"
	"9  423\r\n"
	"9   2 \r\n"
	"9  1 0\r\n"
	"9\r\n"
	"9  ";
static const char substchar[]="\\/|\\/O|/-|";

d150 1
a150 1
db_hang(tries, word, abc)
d153 1
a153 1
	register char	*abc;
d156 5
d166 2
a167 2
	for (p = word; *p; p++)
		cnputc(ISALPHA(*p) && abc[TOLOWER(*p) - 'a'] == '-'? '-' : *p);
d169 3
d174 10
a183 3
	for (p = abc; *p; p++)
		if (*p == '_')
			cnputc('a' + (p - abc));
d186 1
d189 21
d211 4
a214 19
static __inline int
db_hangon(void)
{
	static size_t	len;
	static size_t	tries;
	static char	*word;
	static char	abc[26+1];	/* for '\0' */

	if (word == NULL) {
		register char	*p;

		for (p = abc; p < &abc[sizeof(abc)-1]; p++)
			*p = '-';
		*p = '\0';

		tries = skill + 1;
		word = db_randomsym(&len);
		if (word == NULL)
			return (0);
d216 2
a217 2
		db_plays++;
	}
d219 2
a220 2
	{
		register char	c;
d222 20
a241 19
		db_hang(tries, word, abc);
		c = cngetc();
		c = TOLOWER(c);

		if (ISALPHA(c) && abc[c - 'a'] == '-') {
			register char	*p;
			register size_t	n;

				/* strchr(word,c) */
			for (n = 0, p = word; *p ; p++)
				if (TOLOWER(*p) == c)
					n++;

			if (n) {
				abc[c - 'a'] = c;
				len -= n;
			} else {
				abc[c - 'a'] = '_';
				tries--;
a243 1
	}
d245 2
a246 2
	if (tries && len)
		return (1);
d248 10
a257 5
	if (!tries && skill > 2) {
		register char	*p = word;
		for (; *p; p++)
			if (ISALPHA(*p))
				abc[TOLOWER(*p) - 'a'] = *p;
a258 20
	db_hang(tries, word, abc);
	db_printf("\nScore: %lu/%lu\n", db_plays, ++db_guesses);
	word = NULL;

	return (!tries);
}

void
db_hangman(addr, haddr, count, modif)
	db_expr_t addr;
	int	haddr;
	db_expr_t count;
	char	*modif;
{
	if (modif[0] == 's' && '0' <= modif[1] && modif[1] <= '9')
		skill = modif[1] - '0';
	else
		skill = 3;

	while (db_hangon());
@


1.21
log
@can't call arc4random() before timeouts are enabled, use random() if cold.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.20 2002/03/14 01:26:51 millert Exp $	*/
d173 1
a173 1
	static char	*word = NULL;
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.19 2001/11/06 19:53:18 miod Exp $	*/
d58 3
a60 1
	return arc4random() % mod;
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.18 2001/06/29 05:28:18 mickey Exp $	*/
d50 1
a50 1
void	 db_hang __P((int, char *, char *));
d69 2
a70 2
static void db_hang_forall __P((db_symtab_t *, db_sym_t, char *, char *, int,
			void *));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.19 2001/11/06 19:53:18 miod Exp $	*/
d50 1
a50 1
void	 db_hang(int, char *, char *);
d69 2
a70 2
static void db_hang_forall(db_symtab_t *, db_sym_t, char *, char *, int,
			void *);
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.19.2.1 2002/06/11 03:28:48 art Exp $	*/
a46 9
#define ABC_ISCLR(c)	sabc->abc[(c)-'a']==0
#define ABC_ISWRONG(c)	sabc->abc[(c)-'a']=='_'
#define ABC_SETWRONG(c)		(sabc->abc[(c)-'a']='_')
#define ABC_SETRIGHT(c)		(sabc->abc[(c)-'a']='+')
#define ABC_CLR()	memset(sabc->abc,0,sizeof sabc->abc)
struct _abc {
	char	abc[26+2];	/* for int32 alignment */
};

d50 1
a50 1
void	 db_hang(int, char *, struct _abc *);
d52 1
d55 1
a55 12
static const char hangpic[]=
	"\n88888\r\n"
	"9 7 6\r\n"
	"97  5\r\n"
	"9  423\r\n"
	"9   2\r\n"
	"9  1 0\r\n"
	"9\r\n"
	"9  ";
static const char substchar[]="\\/|\\/O|/-|";

static size_t
d58 1
a58 3
	if (cold)
		return (random() % mod);
	return (arc4random() % mod);
d83 1
a83 1
	if (arg->cnt-- == 0)
d104 1
a104 1
	dfa.cnt = 0;
d106 3
a108 1
	nsyms = -dfa.cnt;
d130 11
d142 1
a142 1
db_hang(tries, word, sabc)
d145 1
a145 1
	register struct _abc *sabc;
a147 5
	int i;
	int c;
#ifdef ABC_BITMASK
	int m;
#endif
d153 2
a154 2
	for (p = word; (c = TOLOWER(*p)); p++)
		cnputc(ISALPHA(c) && ABC_ISCLR(c) ? '-' : *p);
a155 3
#ifdef ABC_WRONGSTR
	db_printf(" (%s)\r", ABC_WRONGSTR);
#else
d158 3
a160 10
#ifdef ABC_BITMASK
	m = sabc->wrong;
	for (i = 'a'; i <= 'z'; ++i, m >>= 1)
		if (m&1)
			cnputc(i);
#else
	for (i = 'a'; i <= 'z'; ++i)
		if (ABC_ISWRONG(i))
			cnputc(i);
#endif
d163 66
a228 1
#endif
d238 3
a240 7
	char	*word;
	size_t	tries;
	size_t	len;
	struct _abc sabc[1];
	int	skill;

	if (modif[0] != 's' || (skill = modif[1] - '0') > 9U)
a241 3
	word = NULL;
	tries = 0;
	for (;;) {
d243 1
a243 51
		if (word == NULL) {
			ABC_CLR();

			tries = skill + 1;
			word = db_randomsym(&len);
			if (word == NULL)
				break;

			db_plays++;
		}

		{
			register int c;

			db_hang(tries, word, sabc);
			c = cngetc();
			c = TOLOWER(c);

			if (ISALPHA(c) && ABC_ISCLR(c)) {
				register char	*p;
				register size_t	n;

					/* strchr(word,c) */
				for (n = 0, p = word; *p ; p++)
					if (TOLOWER(*p) == c)
						n++;

				if (n) {
					ABC_SETRIGHT(c);
					len -= n;
				} else {
					ABC_SETWRONG(c);
					tries--;
				}
			}
		}

		if (tries && len)
			continue;

		if (!tries && skill > 2) {
			register char	*p = word;
			for (; *p; p++)
				if (ISALPHA(*p))
					ABC_SETRIGHT(TOLOWER(*p));
		}
		db_hang(tries, word, sabc);
		db_printf("\nScore: %lu/%lu\n", db_plays, ++db_guesses);
		word = NULL;
		if (tries) break;
	}
@


1.18
log
@print the total score, size permitting
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.17 2001/06/29 04:52:17 mickey Exp $	*/
d36 1
a36 1
#include <vm/vm.h>
@


1.17
log
@cleanup, including removing the size rule which nobody
gives a shit about anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.16 2001/02/10 10:42:35 niklas Exp $	*/
d149 3
a151 3
	for(p=hangpic; *p; p++)
		cnputc((*p>='0' && *p<='9') ? ((tries<=(*p)-'0') ?
		    substchar[(*p)-'0'] : ' ') : *p);
d154 1
a154 1
		cnputc(ISALPHA(*p) && abc[TOLOWER(*p) - 'a'] == '-'?'-':*p);
d225 1
a225 1
	cnputc('\n');
a226 1
	db_guesses++;
@


1.16
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.15 2001/02/08 23:06:32 niklas Exp $	*/
a49 10
/*
 * if [ `size db_hangman.o | awk 'BEGIN {getline} {print $$1+$$2}'` -gt 1024 ];
 * then
 *	echo 'hangman is too big!!!'
 * fi
 *
 */

static __inline size_t db_random __P((size_t));
static __inline char *db_randomsym __P((size_t *));
a50 1
static __inline int db_hangon __P((void));
d53 1
d56 1
a56 2
db_random(mod)
	size_t	mod;
d88 1
a88 2
db_randomsym(lenp)
	size_t	*lenp;
d130 10
a139 10
static char hangpic[]=
    "\n88888 \r\n"
    "9 7 6 \r\n"
    "97  5 \r\n"
    "9  423\r\n"
    "9   2 \r\n"
    "9  1 0\r\n"
    "9\r\n"
    "9  ";
static char substchar[]="\\/|\\/O|/-|";
d147 1
a147 1
	register char	*p;
d185 2
d227 1
@


1.15
log
@Capital punishment,  just in case :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.14 2000/04/05 21:54:48 mickey Exp $	*/
d42 1
d61 1
a61 1
int	 db_hangon __P((void));
d67 1
a67 1
	register size_t	mod;
d72 26
d102 5
a106 3
	register char	*p, *q;
		/* choose random symtab */
	register db_symtab_t	stab = db_istab(db_random(db_nsymtabs));
d108 2
a109 2
		/* choose random symbol from the table */
	q = db_qualify(X_db_isym(stab, db_random(X_db_nsyms(stab))),stab->name);
d111 21
a131 2
		/* don't show symtab name if there are less than 3 of 'em */
	if (db_nsymtabs < 3)
d134 1
a134 1
		/* strlen(q) && ignoring underscores and colons */
d139 1
a139 1
	return q;
d143 8
a150 8
	"\n88888 \r\n"
	  "9 7 6 \r\n"
	  "97  5 \r\n"
	  "9  423\r\n"
	  "9   2 \r\n"
	  "9  1 0\r\n"
	  "9\r\n"
	  "9  ";
d161 3
a163 9
	for(p=hangpic; *p; p++) {
		if(*p>='0' && *p<='9') {
			if(tries<=(*p)-'0')
				cnputc(substchar[(*p)-'0']);
			else
				cnputc(' ');
		} else
			cnputc(*p);
	}
d166 1
a166 4
		if (ISALPHA(*p) && abc[TOLOWER(*p) - 'a'] == '-')
			cnputc('-');
		else
			cnputc(*p);
d168 1
a168 2
	cnputc(' ');
	cnputc('(');
d174 1
a174 2
	cnputc(')');
	cnputc('\r');
d178 1
a178 1
int
d193 1
a193 1
		tries = 2 * (1 + skill / 3);
d195 2
d226 1
a226 1
		return 1;
d238 1
a238 1
	return !tries;
d251 1
a251 1
		skill = 5;
@


1.14
log
@do not exhaust the random pool while debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.13 1998/04/26 21:40:50 deraadt Exp $	*/
d124 2
a125 2
		if (ISALPHA(*p))
			cnputc(abc[TOLOWER(*p) - 'a']);
d161 1
a161 1
		register char	c, c1;
d164 2
a165 1
		c1 = cngetc();
a166 1
		c = TOLOWER(c1);
d173 1
a173 1
				if (*p == c)
d177 1
a177 1
				abc[c - 'a'] = c1;
@


1.13
log
@correct copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.12 1997/09/08 19:46:19 deraadt Exp $	*/
d68 1
a68 3
	size_t	ret;
	get_random_bytes(&ret, sizeof(ret));
	return ret % mod;
@


1.13.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.16 2001/02/10 10:42:35 niklas Exp $	*/
a41 1
#include <ddb/db_output.h>
d60 1
a60 1
static __inline int db_hangon __P((void));
d66 1
a66 1
	size_t	mod;
d68 3
a70 27
	return arc4random() % mod;
}

struct db_hang_forall_arg {
	int cnt;
	db_sym_t sym;
};

/*
 * Horrible abuse of the forall function, but we're not in a hurry.
 */
static void db_hang_forall __P((db_symtab_t *, db_sym_t, char *, char *, int,
			void *));

static void
db_hang_forall(stab, sym, name, suff, pre, varg)
	db_symtab_t *stab;
	db_sym_t sym;
	char *name;
	char *suff;
	int pre;
	void *varg;
{
	struct db_hang_forall_arg *arg = (struct db_hang_forall_arg *)varg;

	if (--arg->cnt == 0)
		arg->sym = sym;
d77 3
a79 5
	extern db_symtab_t db_symtabs[];
	db_symtab_t *stab;
	int nsymtabs, nsyms;
	char	*p, *q;
	struct db_hang_forall_arg dfa;
d81 2
a82 2
	for (nsymtabs = 0; db_symtabs[nsymtabs].name != NULL; nsymtabs++)
		;
d84 2
a85 21
	if (nsymtabs == 0)
		return (NULL);

	stab = &db_symtabs[db_random(nsymtabs)];

	dfa.cnt = 1000000;
	X_db_forall(stab, db_hang_forall, &dfa);
	if (dfa.cnt <= 0)
		return (NULL);
	nsyms = 1000000 - dfa.cnt;

	if (nsyms == 0)
		return (NULL);

	dfa.cnt = db_random(nsyms);
	X_db_forall(stab, db_hang_forall, &dfa);

	q = db_qualify(dfa.sym, stab->name);

	/* don't show symtab name if there are less than 3 of 'em */
	if (nsymtabs < 3)
d88 1
a88 1
	/* strlen(q) && ignoring underscores and colons */
d93 1
a93 1
	return (q);
d97 8
a104 8
    "\n88888 \r\n"
    "9 7 6 \r\n"
    "97  5 \r\n"
    "9  423\r\n"
    "9   2 \r\n"
    "9  1 0\r\n"
    "9\r\n"
    "9  ";
d115 9
a123 3
	for(p=hangpic; *p; p++)
		cnputc((*p>='0' && *p<='9') ? ((tries<=(*p)-'0') ?
		    substchar[(*p)-'0'] : ' ') : *p);
d126 4
a129 1
		cnputc(ISALPHA(*p) && abc[TOLOWER(*p) - 'a'] == '-'?'-':*p);
d131 2
a132 1
	db_printf(" (");
d138 2
a139 1
	db_printf(")\r");
d143 1
a143 1
static __inline int
d158 1
a158 1
		tries = skill + 1;
a159 2
		if (word == NULL)
			return (0);
d163 1
a163 1
		register char	c;
d166 1
a166 2
		c = cngetc();
		c = TOLOWER(c);
d168 1
d175 1
a175 1
				if (TOLOWER(*p) == c)
d179 1
a179 1
				abc[c - 'a'] = c;
d189 1
a189 1
		return (1);
d201 1
a201 1
	return (!tries);
d214 1
a214 1
		skill = 3;
@


1.13.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.13.8.1 2001/05/14 22:06:58 niklas Exp $	*/
d50 10
d61 1
a63 1
u_long		db_plays, db_guesses;
d66 2
a67 1
db_random(size_t mod)
d99 2
a100 1
db_randomsym(size_t *lenp)
d142 10
a151 10
static const char hangpic[]=
	"\n88888 \r\n"
	"9 7 6 \r\n"
	"97  5 \r\n"
	"9  423\r\n"
	"9   2 \r\n"
	"9  1 0\r\n"
	"9\r\n"
	"9  ";
static const char substchar[]="\\/|\\/O|/-|";
d159 1
a159 1
	register const char	*p;
d161 3
a163 3
	for(p = hangpic; *p; p++)
		cnputc((*p >= '0' && *p <= '9') ? ((tries <= (*p) - '0') ?
		    substchar[(*p) - '0'] : ' ') : *p);
d166 1
a166 1
		cnputc(ISALPHA(*p) && abc[TOLOWER(*p) - 'a'] == '-'? '-' : *p);
a196 2

		db_plays++;
d235 1
a235 1
	db_printf("\nScore: %lu/%lu\n", db_plays, ++db_guesses);
@


1.13.8.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 1
a36 1
#include <uvm/uvm_extern.h>
@


1.13.8.4
log
@Merge in -current from about a week ago
@
text
@d50 1
a50 1
void	 db_hang(int, char *, char *);
d69 2
a70 2
static void db_hang_forall(db_symtab_t *, db_sym_t, char *, char *, int,
			void *);
@


1.13.8.5
log
@Sync the SMP branch with 3.3
@
text
@a46 9
#define ABC_ISCLR(c)	sabc->abc[(c)-'a']==0
#define ABC_ISWRONG(c)	sabc->abc[(c)-'a']=='_'
#define ABC_SETWRONG(c)		(sabc->abc[(c)-'a']='_')
#define ABC_SETRIGHT(c)		(sabc->abc[(c)-'a']='+')
#define ABC_CLR()	memset(sabc->abc,0,sizeof sabc->abc)
struct _abc {
	char	abc[26+2];	/* for int32 alignment */
};

d50 1
a50 1
void	 db_hang(int, char *, struct _abc *);
d52 1
d55 1
a55 12
static const char hangpic[]=
	"\n88888\r\n"
	"9 7 6\r\n"
	"97  5\r\n"
	"9  423\r\n"
	"9   2\r\n"
	"9  1 0\r\n"
	"9\r\n"
	"9  ";
static const char substchar[]="\\/|\\/O|/-|";

static size_t
d58 1
a58 3
	if (cold)
		return (random() % mod);
	return (arc4random() % mod);
d83 1
a83 1
	if (arg->cnt-- == 0)
d104 1
a104 1
	dfa.cnt = 0;
d106 3
a108 1
	nsyms = -dfa.cnt;
d130 11
d142 1
a142 1
db_hang(tries, word, sabc)
d145 1
a145 1
	register struct _abc *sabc;
a147 5
	int i;
	int c;
#ifdef ABC_BITMASK
	int m;
#endif
d153 2
a154 2
	for (p = word; (c = TOLOWER(*p)); p++)
		cnputc(ISALPHA(c) && ABC_ISCLR(c) ? '-' : *p);
a155 3
#ifdef ABC_WRONGSTR
	db_printf(" (%s)\r", ABC_WRONGSTR);
#else
d158 3
a160 10
#ifdef ABC_BITMASK
	m = sabc->wrong;
	for (i = 'a'; i <= 'z'; ++i, m >>= 1)
		if (m&1)
			cnputc(i);
#else
	for (i = 'a'; i <= 'z'; ++i)
		if (ABC_ISWRONG(i))
			cnputc(i);
#endif
d163 66
a228 1
#endif
d238 3
a240 7
	char	*word;
	size_t	tries;
	size_t	len;
	struct _abc sabc[1];
	int	skill;

	if (modif[0] != 's' || (skill = modif[1] - '0') > 9U)
a241 3
	word = NULL;
	tries = 0;
	for (;;) {
d243 1
a243 51
		if (word == NULL) {
			ABC_CLR();

			tries = skill + 1;
			word = db_randomsym(&len);
			if (word == NULL)
				break;

			db_plays++;
		}

		{
			register int c;

			db_hang(tries, word, sabc);
			c = cngetc();
			c = TOLOWER(c);

			if (ISALPHA(c) && ABC_ISCLR(c)) {
				register char	*p;
				register size_t	n;

					/* strchr(word,c) */
				for (n = 0, p = word; *p ; p++)
					if (TOLOWER(*p) == c)
						n++;

				if (n) {
					ABC_SETRIGHT(c);
					len -= n;
				} else {
					ABC_SETWRONG(c);
					tries--;
				}
			}
		}

		if (tries && len)
			continue;

		if (!tries && skill > 2) {
			register char	*p = word;
			for (; *p; p++)
				if (ISALPHA(*p))
					ABC_SETRIGHT(TOLOWER(*p));
		}
		db_hang(tries, word, sabc);
		db_printf("\nScore: %lu/%lu\n", db_plays, ++db_guesses);
		word = NULL;
		if (tries) break;
	}
@


1.13.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.13.8.5 2003/03/28 00:00:19 niklas Exp $	*/
d15 5
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.11 1997/07/19 22:31:17 niklas Exp $	*/
d21 10
a30 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.11
log
@Include vm/vm.h everywhere it is needed to get at boolean_t (I would prefer
to have it in sys/types.h but that is problematic).  Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.10 1996/11/29 06:51:49 mickey Exp $	*/
d66 1
a66 1
db_random( mod )
d70 1
a70 1
	get_random_bytes(&ret, sizeof(ret) );
d117 1
a117 2
		if(*p>='0' && *p<='9')
		{
d192 1
a192 2
	if (!tries && skill > 2)
	{
d206 1
a206 1
db_hangman( addr, haddr, count, modif)
@


1.10
log
@note 1024 limit on text+data.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.9 1996/11/28 19:01:49 niklas Exp $	*/
d36 3
d40 1
d43 1
@


1.9
log
@Actually draw the hanging.  Remove some statics.  Fix a bug in
case handling.  Still less than 1 K!  Most stuff from Andreas Gunnarsson,
<zzlevo@@dd.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.8 1996/10/21 05:11:47 deraadt Exp $	*/
d44 8
@


1.8
log
@random is stock
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.7 1996/08/29 09:26:34 deraadt Exp $	*/
d21 2
a22 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d42 1
a42 1
#define	TOLOWER(c)	(('A'<=(c)&&(c)<='Z')?(c)-'a'+'A':(c))
d45 6
a50 4
static	__inline size_t db_random __P((size_t));
static	__inline char *db_randomsym __P((size_t *));
static	void db_hang __P((int, char *, char *));
static	int db_hangon __P((void));
a60 2
static int	skill;

d84 10
d95 1
a95 1
static void
d103 11
a113 1
	cnputc(' ');
a121 2
	cnputc('0' + tries);
	cnputc(' ');
d132 1
a132 1
static int
d178 1
a178 1
		return db_hangon();
@


1.7
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.6 1996/06/17 12:07:00 mickey Exp $	*/
a39 2
#include "random.h"
#if NRANDOM > 0
a40 1
#endif
a53 1
#if NRANDOM > 0
a56 4
#else
	u_int random __P((void));
	return (size_t)(random() % mod);
#endif
@


1.6
log
@set default level to 5, misc cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_hangman.c,v 1.5 1996/05/31 10:37:25 niklas Exp $	*/
d40 2
a41 2
#include "rnd.h"
#if NRND
d57 1
a57 1
#if NRND
@


1.5
log
@-Wall and -Wstrict-prototypes cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a99 1
	register int	n = 6;
d102 1
a102 1
	for (p = word; *p; p++, n++)
d114 1
a114 1
		if (*p == '_') {
a115 2
			n++;
		}
d118 1
a118 4

		/* position to the beginning of the line */
	while (n--)
		cnputc('\b');
d194 1
a194 1
		skill = 0;
@


1.4
log
@fix symtab skip loop (s,p,q,).
@
text
@d48 5
d62 1
a62 1
	u_int random();
d93 1
a93 1
static int
@


1.3
log
@do dynamic symtab allocattion.
@
text
@d77 1
a77 1
		while(*p++ != ':');
@


1.2
log
@show symtab name when no less than 3 of them.
@
text
@d70 1
a70 1
	register db_symtab_t	*stab = db_istab(db_random(db_nsymtabs));
@


1.1
log
@add advanced hang analyzer.
idea by theo.
@
text
@d75 4
@
