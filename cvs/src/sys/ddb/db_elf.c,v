head	1.28;
access;
symbols
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.26
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.22
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.20
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.18
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.16
	OPENBSD_5_0:1.9.0.14
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.12
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.10
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.6
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.8
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.28
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	uRv5pa9QDlZaYgwD;

1.27
date	2017.08.10.19.39.38;	author mpi;	state Exp;
branches;
next	1.26;
commitid	31PvZ4r4dQH5StiR;

1.26
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.25;
commitid	PnZZkFEIj4rPydZo;

1.25
date	2017.05.28.11.41.52;	author mpi;	state Exp;
branches;
next	1.24;
commitid	yu9JCnXPI4UfHZwC;

1.24
date	2017.02.08.04.30.45;	author guenther;	state Exp;
branches;
next	1.23;
commitid	dv6uoVthRxwkYsk2;

1.23
date	2016.09.16.19.13.17;	author jasper;	state Exp;
branches;
next	1.22;
commitid	aag1XqKQQN6pS0l5;

1.22
date	2016.04.20.08.02.59;	author mpi;	state Exp;
branches;
next	1.21;
commitid	czffqpDI3wpnc3Dz;

1.21
date	2016.03.07.11.26.43;	author mpi;	state Exp;
branches;
next	1.20;
commitid	A6aWk73xtRBVWTBp;

1.20
date	2016.03.06.19.05.30;	author mpi;	state Exp;
branches;
next	1.19;
commitid	Ni38yK63LcOWb30h;

1.19
date	2016.03.01.21.32.02;	author mpi;	state Exp;
branches;
next	1.18;
commitid	8ue8rik6burb9L4V;

1.18
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.17;
commitid	CZXiyhU8oBcz6IpF;

1.17
date	2016.02.27.13.17.47;	author mpi;	state Exp;
branches;
next	1.16;
commitid	RePOJ1nAmEf9Lu6X;

1.16
date	2016.01.27.10.37.12;	author mpi;	state Exp;
branches;
next	1.15;
commitid	Qlm598QQCEyskMtJ;

1.15
date	2016.01.25.14.56.03;	author mpi;	state Exp;
branches;
next	1.14;
commitid	oDTpc6b16jRoL5rf;

1.14
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.13;
commitid	7AkssaZPPd7mA8h3;

1.13
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.12;
commitid	p4LJxGKbi0BU2cG6;

1.12
date	2014.10.09.08.21.48;	author matthew;	state Exp;
branches;
next	1.11;
commitid	36xObzDB3RrngiY3;

1.11
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.10;
commitid	uzzBR7hz9ncd4O6G;

1.10
date	2014.03.16.20.31.46;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.06.19.49.52;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.01.16.19.00;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.19.16.25.00;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.03.15.07.35.46;	author niklas;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.02.10.10.43.18;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.06.57;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: db_elf.c,v 1.27 2017/08/10 19:39:38 mpi Exp $	*/
/*	$NetBSD: db_elf.c,v 1.13 2000/07/07 21:55:18 jhawk Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/stdint.h>
#include <sys/systm.h>
#include <sys/exec.h>

#include <machine/db_machdep.h>

#include <ddb/db_elf.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>

#include <sys/exec_elf.h>

db_symtab_t db_symtab;

Elf_Sym		*db_elf_sym_lookup(char *);

/*
 * Find the symbol table and strings; tell ddb about them.
 *
 * symsize:	size of symbol table
 * symtab:	pointer to start of symbol table
 * esymtab:	pointer to end of string table, for checking - rounded up to
 *		    integer boundry
 */
int
db_elf_sym_init(int symsize, void *symtab, void *esymtab, const char *name)
{
	Elf_Ehdr *elf;
	Elf_Shdr *shp;
	Elf_Sym *symp, *symtab_start, *symtab_end;
	char *shstrtab, *strtab_start, *strtab_end;
	int i;
	char *errstr = "";

	if (ALIGNED_POINTER(symtab, long) == 0) {
		db_printf("[ %s symbol table has bad start address %p ]\n",
		    name, symtab);
		return (0);
	}

	symtab_start = symtab_end = NULL;
	strtab_start = strtab_end = NULL;

	/*
	 * The format of the symbols loaded by the boot program is:
	 *
	 *	Elf exec header
	 *	first section header
	 *	. . .
	 *	. . .
	 *	last section header
	 *	first symbol, string, or line table section
	 *	. . .
	 *	. . .
	 *	last symbol, string, or line table section
	 */

	/*
	 * Validate the Elf header.
	 */
	elf = (Elf_Ehdr *)symtab;
	if (memcmp(elf->e_ident, ELFMAG, SELFMAG) != 0 ||
	    elf->e_ident[EI_CLASS] != ELFCLASS) {
		errstr = "bad magic";
		goto badheader;
	}

	if (elf->e_machine != ELF_TARG_MACH) {
		errstr = "bad e_machine";
		goto badheader;
	}

	/*
	 * Find the section header string table (.shstrtab), and look up
	 * the symbol table (.symtab) and string table (.strtab) via their
	 * names in shstrtab, rather than by table type.
	 * This works in the presence of multiple string tables, such as
	 * stabs data found when booting bsd.gdb.
	 */
	shp = (Elf_Shdr *)((char *)symtab + elf->e_shoff);
	shstrtab = (char *)symtab + shp[elf->e_shstrndx].sh_offset;
	for (i = 0; i < elf->e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB) {
			int j;

			if (shp[i].sh_offset == 0)
				continue;
			symtab_start = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset);
			symtab_end = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset + shp[i].sh_size);
			j = shp[i].sh_link;
			if (shp[j].sh_offset == 0)
				continue;
			strtab_start = (char *)symtab + shp[j].sh_offset;
			strtab_end = (char *)symtab + shp[j].sh_offset +
			    shp[j].sh_size;
			break;
		}

		/*
		 * This is the old way of doing things.
		 * XXX - verify that it's not needed.
		 */
		if (strcmp(".strtab", shstrtab+shp[i].sh_name) == 0) {
			strtab_start = (char *)symtab + shp[i].sh_offset;
			strtab_end = (char *)symtab + shp[i].sh_offset +
			    shp[i].sh_size;
		} else if (strcmp(".symtab", shstrtab+shp[i].sh_name) == 0) {
			symtab_start = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset);
			symtab_end = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset + shp[i].sh_size);
		}
	}

	/*
	 * Now, sanity check the symbols against the string table.
	 */
	if (symtab_start == NULL || strtab_start == NULL ||
	    ALIGNED_POINTER(symtab_start, long) == 0 ||
	    ALIGNED_POINTER(strtab_start, long) == 0) {
		errstr = "symtab unaligned";
		goto badheader;
	}
	for (symp = symtab_start; symp < symtab_end; symp++)
		if (symp->st_name + strtab_start > strtab_end) {
			errstr = "symtab corrupted";
			goto badheader;
		}

	/*
	 * Link the symbol table into the debugger.
	 */
	db_symtab.start = (char *)symtab_start;
	db_symtab.end = (char *)symtab_end;
	db_symtab.name = name;
	db_symtab.private = (char *)symtab;

	db_printf("[ using %lu bytes of %s ELF symbol table ]\n",
	    (u_long)roundup(((char *)esymtab - (char *)symtab), sizeof(u_long)),
	    name);

	return (1);

 badheader:
	db_printf("[ %s ELF symbol table not valid: %s ]\n", name, errstr);
	return (0);
}

/*
 * Internal helper function - return a pointer to the string table
 * for the current symbol table.
 */
char *
db_elf_find_strtab(db_symtab_t *stab)
{
	Elf_Ehdr *elf = STAB_TO_EHDR(stab);
	Elf_Shdr *shp = STAB_TO_SHDR(stab, elf);
	char *shstrtab;
	int i;

	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;
	for (i = 0; i < elf->e_shnum; i++) {
		if (shp[i].sh_type == SHT_SYMTAB)
			return ((char *)elf + shp[shp[i].sh_link].sh_offset);
		if (strcmp(".strtab", shstrtab+shp[i].sh_name) == 0)
			return ((char *)elf + shp[i].sh_offset);
	}

	return (NULL);
}

/*
 * Internal helper function - return a pointer to the section
 * named ``sname''.
 */
const char *
db_elf_find_section(db_symtab_t *stab, size_t *size, const char *sname)
{
	Elf_Ehdr *elf = STAB_TO_EHDR(stab);
	Elf_Shdr *shp = STAB_TO_SHDR(stab, elf);
	char *shstrtab;
	int i;

	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;
	for (i = 0; i < elf->e_shnum; i++) {
		if ((shp[i].sh_flags & SHF_ALLOC) != 0 &&
		    strcmp(sname, shstrtab+shp[i].sh_name) == 0) {
			*size = shp[i].sh_size;
			return ((char *)elf + shp[i].sh_offset);
		}
	}

	return (NULL);
}

/*
 * Lookup the symbol with the given name.
 */
Elf_Sym *
db_elf_sym_lookup(char *symstr)
{
	db_symtab_t *stab = &db_symtab;
	Elf_Sym *symp, *symtab_start, *symtab_end;
	char *strtab;

	if (stab->private == NULL)
		return (NULL);

	symtab_start = STAB_TO_SYMSTART(stab);
	symtab_end = STAB_TO_SYMEND(stab);

	strtab = db_elf_find_strtab(stab);
	if (strtab == NULL)
		return (NULL);

	for (symp = symtab_start; symp < symtab_end; symp++) {
		if (symp->st_name != 0 &&
		    db_eqname(strtab + symp->st_name, symstr, 0))
			return (symp);
	}

	return (NULL);
}

/*
 * Search for the symbol with the given address (matching within the
 * provided threshold).
 */
Elf_Sym *
db_elf_sym_search(db_addr_t off, db_strategy_t strategy,
    db_expr_t *diffp)
{
	db_symtab_t *stab = &db_symtab;
	Elf_Sym *rsymp, *symp, *symtab_start, *symtab_end;
	db_expr_t diff = *diffp;

	if (stab->private == NULL)
		return (NULL);

	symtab_start = STAB_TO_SYMSTART(stab);
	symtab_end = STAB_TO_SYMEND(stab);

	rsymp = NULL;

	for (symp = symtab_start; symp < symtab_end; symp++) {
		if (symp->st_name == 0)
			continue;
#if 0
		/* This prevents me from seeing anythin in locore.s -- eeh */
		if (ELF_SYM_TYPE(symp->st_info) != Elf_estt_object &&
		    ELF_SYM_TYPE(symp->st_info) != Elf_estt_func)
			continue;
#endif

		if (off >= symp->st_value) {
			if ((off - symp->st_value) < diff) {
				diff = off - symp->st_value;
				rsymp = symp;
				if (diff == 0) {
					if (strategy == DB_STGY_PROC &&
					    ELF_ST_TYPE(symp->st_info)
					      == STT_FUNC &&
					    ELF_ST_BIND(symp->st_info)
					      != STB_LOCAL)
						break;
					if (strategy == DB_STGY_ANY &&
					    ELF_ST_BIND(symp->st_info)
					      != STB_LOCAL)
						break;
				}
			} else if ((off - symp->st_value) == diff) {
				if (rsymp == NULL)
					rsymp = symp;
				else if (ELF_ST_BIND(rsymp->st_info)
				      == STB_LOCAL &&
				    ELF_ST_BIND(symp->st_info)
				      != STB_LOCAL) {
					/* pick the external symbol */
					rsymp = symp;
				}
			}
		}
	}

	if (rsymp == NULL)
		*diffp = off;
	else
		*diffp = diff;

	return (rsymp);
}

/*
 * Return the name and value for a symbol.
 */
void
db_symbol_values(Elf_Sym *sym, char **namep, db_expr_t *valuep)
{
	db_symtab_t *stab = &db_symtab;
	Elf_Sym *symp = (Elf_Sym *)sym;
	char *strtab;

	if (sym == NULL) {
		*namep = NULL;
		return;
	}

	if (stab->private == NULL)
		return;

	if (namep) {
		strtab = db_elf_find_strtab(stab);
		if (strtab == NULL)
			*namep = NULL;
		else
			*namep = strtab + symp->st_name;
	}

	if (valuep)
		*valuep = symp->st_value;
}

/*
 * Return the file and line number of the current program counter
 * if we can find the appropriate debugging symbol.
 */
int
db_elf_line_at_pc(Elf_Sym *cursym, char **filename,
    int *linenum, db_expr_t off)
{
	db_symtab_t *stab = &db_symtab;
	static char path[PATH_MAX];
	const char *linetab, *dirname, *basename;
	size_t linetab_size;

	if (stab->private == NULL)
		return (0);

	linetab = db_elf_find_section(stab, &linetab_size, ".debug_line");
	if (linetab == NULL)
		return (0);

	if (!db_dwarf_line_at_pc(linetab, linetab_size, off,
	    &dirname, &basename, linenum))
		return (0);

	if (dirname == NULL)
		strlcpy(path, basename, sizeof(path));
	else
		snprintf(path, sizeof(path), "%s/%s", dirname, basename);
	*filename = path;
	return (1);
}

void
db_elf_sym_forall(db_forall_func_t db_forall_func, void *arg)
{
	db_symtab_t *stab = &db_symtab;
	char *strtab;
	static char suffix[2];
	Elf_Sym *symp, *symtab_start, *symtab_end;

	if (stab->private == NULL)
		return;

	symtab_start = STAB_TO_SYMSTART(stab);
	symtab_end = STAB_TO_SYMEND(stab);

	strtab = db_elf_find_strtab(stab);
	if (strtab == NULL)
		return;

	for (symp = symtab_start; symp < symtab_end; symp++)
		if (symp->st_name != 0) {
			suffix[1] = '\0';
			switch (ELF_ST_TYPE(symp->st_info)) {
			case STT_OBJECT:
				suffix[0] = '+';
				break;
			case STT_FUNC:
				suffix[0] = '*';
				break;
			case STT_SECTION:
				suffix[0] = '&';
				break;
			case STT_FILE:
				suffix[0] = '/';
				break;
			default:
				suffix[0] = '\0';
			}
			(*db_forall_func)(symp,
			    strtab + symp->st_name, suffix, 0, arg);
		}
}

Elf_Sym *
db_symbol_by_name(char *name, db_expr_t *valuep)
{
	Elf_Sym		*sym;

	sym = db_elf_sym_lookup(name);
	if (sym == NULL)
	    return (NULL);
	db_symbol_values(sym, &name, valuep);
	return (sym);
}
@


1.27
log
@With a CTF kernel, DDB's print command will now pretty-print symbols.

Casting a type is not yet supported.

ok kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.26 2017/05/30 15:39:05 mpi Exp $	*/
d34 1
a34 1
#include <sys/types.h>
a35 1
#include <sys/param.h>
@


1.26
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.25 2017/05/28 11:41:52 mpi Exp $	*/
d434 2
a435 2
int
db_value_of_name(char *name, db_expr_t *valuep)
d441 1
a441 1
	    return (0);
d443 1
a443 1
	return (1);
@


1.25
log
@Merge two functions to lookup ELF sections by name.

ok claudio@@, jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.24 2017/02/08 04:30:45 guenther Exp $	*/
d266 1
a266 1
db_sym_t
d327 1
a327 1
	return ((db_sym_t)rsymp);
d334 1
a334 1
db_symbol_values(db_sym_t sym, char **namep, db_expr_t *valuep)
d365 1
a365 1
db_elf_line_at_pc(db_sym_t cursym, char **filename,
d429 1
a429 1
			(*db_forall_func)((db_sym_t)symp,
d442 1
a442 1
	db_symbol_values((db_sym_t)sym, &name, valuep);
@


1.24
log
@Use ELF_ST_{BIND,TYPE} instead of ELFDEFNNAME(ST_{BIND,TYPE})

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.23 2016/09/16 19:13:17 jasper Exp $	*/
a50 1
static char	*db_elf_find_linetab(db_symtab_t *, size_t *);
d210 2
a211 2
 * Internal helper function - return a pointer to the line table
 * for the current symbol table.
d213 2
a214 2
static char *
db_elf_find_linetab(db_symtab_t *stab, size_t *size)
d224 1
a224 1
		    strcmp(".debug_line", shstrtab+shp[i].sh_name) == 0) {
d376 1
a376 1
	linetab = db_elf_find_linetab(stab, &linetab_size);
@


1.23
log
@teach ddb(4) about CTF. currently it only loads the CTF and uses it on amd64
to lookup the number of function parameters. however having this basic
facility allows us to expand it's usage.

currently hidden behind the (disabled) DDBCTF kernel option as some of the
required tools are not available in base yet. in addition to that one
also needs recent bootblocks that load the .SUNW_ctf kernel section.

discussed with mpi@@ over many a cider and ale in cambridge
feedback and ok guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.22 2016/04/20 08:02:59 mpi Exp $	*/
d299 1
a299 1
					    ELFDEFNNAME(ST_TYPE)(symp->st_info)
d301 1
a301 1
					    ELFDEFNNAME(ST_BIND)(symp->st_info)
d305 1
a305 1
					    ELFDEFNNAME(ST_BIND)(symp->st_info)
d312 1
a312 1
				else if (ELFDEFNNAME(ST_BIND)(rsymp->st_info)
d314 1
a314 1
				    ELFDEFNNAME(ST_BIND)(symp->st_info)
d414 1
a414 1
			switch (ELFDEFNNAME(ST_TYPE)(symp->st_info)) {
@


1.22
log
@Collapse db_dwarf.h into db_sym.h

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.21 2016/03/07 11:26:43 mpi Exp $	*/
d42 1
a47 8

typedef struct {
	const char	*name;		/* symtab name */
	char		*start;		/* symtab location */
	char		*end;
	char		*private;	/* optional machdep pointer */
} db_symtab_t;

a50 1
static char	*db_elf_find_strtab(db_symtab_t *);
a52 5
#define	STAB_TO_SYMSTART(stab)	((Elf_Sym *)((stab)->start))
#define	STAB_TO_SYMEND(stab)	((Elf_Sym *)((stab)->end))
#define	STAB_TO_EHDR(stab)	((Elf_Ehdr *)((stab)->private))
#define	STAB_TO_SHDR(stab, e)	((Elf_Shdr *)((stab)->private + (e)->e_shoff))

d191 1
a191 1
static char *
@


1.21
log
@boolean_t/FALSE/TRUE -> int/0/1
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.20 2016/03/06 19:05:30 mpi Exp $	*/
a41 1
#include <ddb/db_dwarf.h>
@


1.20
log
@Merge db_elf_sym_values() into db_symbol_values().

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.19 2016/03/01 21:32:02 mpi Exp $	*/
d75 1
a75 1
boolean_t
d88 1
a88 1
		return (FALSE);
d194 1
a194 1
	return (TRUE);
d198 1
a198 1
	return (FALSE);
d379 1
a379 1
boolean_t
d389 1
a389 1
		return (FALSE);
d393 1
a393 1
		return (FALSE);
d397 1
a397 1
		return (FALSE);
d404 1
a404 1
	return (TRUE);
@


1.19
log
@Make db_value_of_name() call db_elf_sym_lookup() in order to kill
db_lookup() as requested by mlarkin@@

While here move the function to db_elf.c do keep db_elf_sym_lookup()
private.

ok mikeb@@ appart from the move the function
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.18 2016/03/01 11:56:00 mpi Exp $	*/
d349 1
a349 2
db_elf_sym_values(db_sym_t sym, char **namep,
    db_expr_t *valuep)
d354 5
@


1.18
log
@DB_SYM_NULL -> NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.17 2016/02/27 13:17:47 mpi Exp $	*/
d58 3
a60 2
static char *db_elf_find_strtab(db_symtab_t *);
static char *db_elf_find_linetab(db_symtab_t *, size_t *);
d251 1
a251 1
db_sym_t
d271 1
a271 1
			return ((db_sym_t)symp);
d443 12
@


1.17
log
@Remove the "symbol table" argument of the functions dealing with
symbols.

There's no reason to ask the programmer to supply a specific symbol
table since the kernel only have one.

ok visa@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.16 2016/01/27 10:37:12 mpi Exp $	*/
d258 1
a258 1
		return ((db_sym_t)0);
d265 1
a265 1
		return ((db_sym_t)0);
d273 1
a273 1
	return ((db_sym_t)0);
d289 1
a289 1
		return ((db_sym_t)0);
@


1.16
log
@Removes the abstraction layer to support multiple executable binaries.

Simplifies the API to manipulate symbols now that all our architectures
are ELF.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.15 2016/01/25 14:56:03 mpi Exp $	*/
d48 10
d184 8
a191 7
	if (db_add_symbol_table((char *)symtab_start,
	    (char *)symtab_end, name, (char *)symtab) != -1) {
		db_printf("[ using %lu bytes of %s ELF symbol table ]\n",
		    (u_long)roundup(((char *)esymtab - (char *)symtab),
				    sizeof(u_long)), name);
		return (TRUE);
	}
d193 1
a193 1
	return (FALSE);
d251 1
a251 1
db_elf_sym_lookup(db_symtab_t *stab, char *symstr)
d253 1
d257 3
d281 1
a281 1
db_elf_sym_search(db_symtab_t *symtab, db_addr_t off, db_strategy_t strategy,
d284 1
d288 5
a292 2
	symtab_start = STAB_TO_SYMSTART(symtab);
	symtab_end = STAB_TO_SYMEND(symtab);
d348 1
a348 1
db_elf_sym_values(db_symtab_t *symtab, db_sym_t sym, char **namep,
d351 1
d355 3
d359 1
a359 1
		strtab = db_elf_find_strtab(symtab);
d375 1
a375 1
db_elf_line_at_pc(db_symtab_t *symtab, db_sym_t cursym, char **filename,
d378 1
d383 4
a386 1
	linetab = db_elf_find_linetab(symtab, &linetab_size);
d403 1
a403 1
db_elf_sym_forall(db_symtab_t *stab, db_forall_func_t db_forall_func, void *arg)
d405 1
d410 3
d439 1
a439 1
			(*db_forall_func)(stab, (db_sym_t)symp,
a441 1
	return;
@


1.15
log
@Do not mix variable declaration and logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.14 2016/01/25 14:30:30 mpi Exp $	*/
a55 24
boolean_t	db_elf_sym_init(int, void *, void *, const char *);
db_sym_t	db_elf_lookup(db_symtab_t *, char *);
db_sym_t	db_elf_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_elf_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_elf_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_elf_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_elf_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);

db_symformat_t db_symformat_elf = {
	"ELF",
	db_elf_sym_init,
	db_elf_lookup,
	db_elf_search_symbol,
	db_elf_symbol_values,
	db_elf_line_at_pc,
	db_elf_sym_numargs,
	db_elf_forall
};

d240 1
a240 1
db_elf_lookup(db_symtab_t *stab, char *symstr)
d266 1
a266 1
db_elf_search_symbol(db_symtab_t *symtab, db_addr_t off, db_strategy_t strategy,
d329 1
a329 1
db_elf_symbol_values(db_symtab_t *symtab, db_sym_t sym, char **namep,
a374 15
/*
 * Returns the number of arguments to a function and their
 * names if we can find the appropriate debugging symbol.
 */
boolean_t
db_elf_sym_numargs(db_symtab_t *symtab, db_sym_t cursym, int *nargp,
    char **argnamep)
{

	/*
	 * XXX We don't support this (yet).
	 */
	return (FALSE);
}

d376 1
a376 1
db_elf_forall(db_symtab_t *stab, db_forall_func_t db_forall_func, void *arg)
@


1.14
log
@Kill trailing whitespaces.  No object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.13 2015/03/14 03:38:46 jsg Exp $	*/
d379 2
a380 1
	const char *linetab;
a386 1
	const char *dirname, *basename;
a390 1
	static char path[PATH_MAX];
@


1.13
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.12 2014/10/09 08:21:48 matthew Exp $	*/
d37 1
a37 1
#include <sys/systm.h>  
d173 1
a173 1
			symtab_start = (Elf_Sym *)((char *)symtab + 
d175 1
a175 1
			symtab_end = (Elf_Sym *)((char *)symtab + 
d201 1
a201 1
		    (u_long)roundup(((char *)esymtab - (char *)symtab), 
@


1.12
log
@ddb: add support for DWARF line number decoding

This allows ddb's "trace" command to include file and line numbers:

  ddb{0}> trace
  Debugger() at Debugger+0x9 [../../../../arch/amd64/amd64/db_interface.c:405]
  ddb_sysctl() at ddb_sysctl+0x1b4 [../../../../ddb/db_usrreq.c:104]
  sys___sysctl() at sys___sysctl+0x216 [../../../../kern/kern_sysctl.c:229]
  syscall() at syscall+0x297 [../../../../sys/syscall_mi.h:84]
  --- syscall (number 202) ---
  end of kernel
  end trace frame: 0x7f7ffffcf1d7, count: -4
  acpi_pdirpa+0x4117aa:

For this to work, it requires using a new version of boot(8), and
booting a kernel with the .debug_line section present (e.g., building
with ``makeoptions DEBUG="-g"'' and then booting the bsd.gdb kernel
instead of the stripped bsd kernel).

Still a WIP, but no failure reports yet.  Committing so further
development and testing can happen in tree.

prodding deraadt, guenther, mlarkin
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.11 2014/09/14 14:17:24 jsg Exp $	*/
a44 1
#include <ddb/db_extern.h>
@


1.11
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.10 2014/03/16 20:31:46 guenther Exp $	*/
d35 1
d42 1
d50 1
d116 1
a116 1
	 *	first symbol or string table section
d119 1
a119 1
	 *	last symbol or string table section
d238 24
d380 6
d387 12
a398 4
	/*
	 * XXX We don't support this (yet).
	 */
	return (FALSE);
@


1.10
log
@DDB supports ELF symbols are all archs, and it's always the same as the
native size, so eliminate the #defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.9 2008/06/26 05:42:14 ray Exp $	*/
a36 1
#include <sys/proc.h>
@


1.9
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.8 2007/10/06 19:49:52 kettenis Exp $	*/
a45 8
#ifdef DB_ELF_SYMBOLS

#ifndef DB_ELFSIZE
#error Must define DB_ELFSIZE!
#endif

#define	ELFSIZE		DB_ELFSIZE

a413 1
#endif /* DB_ELF_SYMBOLS */
@


1.8
log
@Use db_printf instead of printf, to prevent problems with locking
kprintf_mutex in the early stages of booting.

ok miod@@ (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.7 2006/03/13 06:23:20 jsg Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.7
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.6 2003/06/01 16:19:00 art Exp $	*/
d113 1
a113 1
		printf("[ %s symbol table has bad start address %p ]\n",
d214 1
a214 1
		printf("[ using %lu bytes of %s ELF symbol table ]\n",
d223 1
a223 1
	printf("[ %s ELF symbol table not valid: %s ]\n", name, errstr);
@


1.6
log
@When searching for the symbol table and string table we were looking
for ".symtab" and ".strtab" in the section names. Instead of doing that,
look for section type SHT_SYMTAB for the symbol table and follow the link
in sh_link to find the corresponding string table. This is a more correct
way of doing things and will work better when the toolchain doesn't
generate ".symtab" and ".strtab" names and it will work when there are
multiple symbol tables.

noone objected to this diff for at least a week.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.5 2002/03/14 03:16:03 millert Exp $	*/
d96 5
d103 1
a103 7
db_elf_sym_init(symsize, symtab, esymtab, name)
	int symsize;		/* size of symbol table */
	void *symtab;		/* pointer to start of symbol table */
	void *esymtab;		/* pointer to end of string table,
				   for checking - rounded up to integer
				   boundary */
	const char *name;
d232 1
a232 2
db_elf_find_strtab(stab)
	db_symtab_t *stab;
d254 1
a254 3
db_elf_lookup(stab, symstr)
	db_symtab_t *stab;
	char *symstr;
d280 2
a281 5
db_elf_search_symbol(symtab, off, strategy, diffp)
	db_symtab_t *symtab;
	db_addr_t off;
	db_strategy_t strategy;
	db_expr_t *diffp;		/* in/out */
d343 2
a344 5
db_elf_symbol_values(symtab, sym, namep, valuep)
	db_symtab_t *symtab;
	db_sym_t sym;
	char **namep;
	db_expr_t *valuep;
d366 2
a367 6
db_elf_line_at_pc(symtab, cursym, filename, linenum, off)
	db_symtab_t *symtab;
	db_sym_t cursym;
	char **filename;
	int *linenum;
	db_expr_t off;
d381 2
a382 5
db_elf_sym_numargs(symtab, cursym, nargp, argnamep)
	db_symtab_t *symtab;
	db_sym_t cursym;
	int *nargp;
	char **argnamep;
d392 1
a392 4
db_elf_forall(stab, db_forall_func, arg)
	db_symtab_t *stab;
	db_forall_func_t db_forall_func;
	void *arg;
@


1.5
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.4 2002/03/14 01:26:51 millert Exp $	*/
d161 22
d243 2
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.3 2001/08/19 16:25:00 art Exp $	*/
d159 1
a159 1
	shstrtab = (char*)symtab + shp[elf->e_shstrndx].sh_offset;
d219 1
a219 1
	shstrtab = (char*)elf + shp[elf->e_shstrndx].sh_offset;
d222 1
a222 1
			return ((char*)elf + shp[i].sh_offset);
@


1.3
log
@Print a reason for failing to init the symbol table.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.2 2001/03/15 07:35:46 niklas Exp $	*/
d63 1
a63 1
static char *db_elf_find_strtab __P((db_symtab_t *));
d70 12
a81 12
boolean_t	db_elf_sym_init __P((int, void *, void *, const char *));
db_sym_t	db_elf_lookup __P((db_symtab_t *, char *));
db_sym_t	db_elf_search_symbol __P((db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *));
void		db_elf_symbol_values __P((db_symtab_t *, db_sym_t,
		    char **, db_expr_t *));
boolean_t	db_elf_line_at_pc __P((db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t));
boolean_t	db_elf_sym_numargs __P((db_symtab_t *, db_sym_t, int *,
		    char **));
void		db_elf_forall __P((db_symtab_t *,
		    db_forall_func_t db_forall_func, void *));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.3 2001/08/19 16:25:00 art Exp $	*/
d63 1
a63 1
static char *db_elf_find_strtab(db_symtab_t *);
d70 12
a81 12
boolean_t	db_elf_sym_init(int, void *, void *, const char *);
db_sym_t	db_elf_lookup(db_symtab_t *, char *);
db_sym_t	db_elf_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_elf_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_elf_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_elf_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_elf_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
d159 1
a159 1
	shstrtab = (char *)symtab + shp[elf->e_shstrndx].sh_offset;
d219 1
a219 1
	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;
d222 1
a222 1
			return ((char *)elf + shp[i].sh_offset);
@


1.2
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.13 2000/07/07 21:55:18 jhawk Exp $	*/
d111 1
d141 2
a142 1
	    elf->e_ident[EI_CLASS] != ELFCLASS)
d144 1
d146 2
a147 1
	if (elf->e_machine != ELF_TARG_MACH)
d149 1
d178 2
a179 1
	    ALIGNED_POINTER(strtab_start, long) == 0)
d181 1
d183 2
a184 1
		if (symp->st_name + strtab_start > strtab_end)
d186 1
d202 1
a202 1
	printf("[ %s ELF symbol table not valid ]\n", name);
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.2 2001/03/15 07:35:46 niklas Exp $	*/
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.2.4.1 2001/05/14 22:06:57 niklas Exp $	*/
a110 1
	char *errstr = "";
d140 1
a140 2
	    elf->e_ident[EI_CLASS] != ELFCLASS) {
		errstr = "bad magic";
a141 1
	}
d143 1
a143 2
	if (elf->e_machine != ELF_TARG_MACH) {
		errstr = "bad e_machine";
a144 1
	}
d173 1
a173 2
	    ALIGNED_POINTER(strtab_start, long) == 0) {
		errstr = "symtab unaligned";
a174 1
	}
d176 1
a176 2
		if (symp->st_name + strtab_start > strtab_end) {
			errstr = "symtab corrupted";
a177 1
		}
d193 1
a193 1
	printf("[ %s ELF symbol table not valid: %s ]\n", name, errstr);
@


1.2.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
static char *db_elf_find_strtab(db_symtab_t *);
d70 12
a81 12
boolean_t	db_elf_sym_init(int, void *, void *, const char *);
db_sym_t	db_elf_lookup(db_symtab_t *, char *);
db_sym_t	db_elf_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_elf_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_elf_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_elf_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_elf_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
d159 1
a159 1
	shstrtab = (char *)symtab + shp[elf->e_shstrndx].sh_offset;
d219 1
a219 1
	shstrtab = (char *)elf + shp[elf->e_shstrndx].sh_offset;
d222 1
a222 1
			return ((char *)elf + shp[i].sh_offset);
@


1.2.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_elf.c,v 1.2.4.3 2002/03/28 11:43:03 niklas Exp $	*/
a160 22
		if (shp[i].sh_type == SHT_SYMTAB) {
			int j;

			if (shp[i].sh_offset == 0)
				continue;
			symtab_start = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset);
			symtab_end = (Elf_Sym *)((char *)symtab +
			    shp[i].sh_offset + shp[i].sh_size);
			j = shp[i].sh_link;
			if (shp[j].sh_offset == 0)
				continue;
			strtab_start = (char *)symtab + shp[j].sh_offset;
			strtab_end = (char *)symtab + shp[j].sh_offset +
			    shp[j].sh_size;
			break;
		}

		/*
		 * This is the old way of doing things.
		 * XXX - verify that it's not needed.
		 */
a220 2
		if (shp[i].sh_type == SHT_SYMTAB)
			return ((char *)elf + shp[shp[i].sh_link].sh_offset);
@


1.1
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d1 1
@

