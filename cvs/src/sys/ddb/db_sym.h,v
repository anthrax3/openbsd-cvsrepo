head	1.33;
access;
symbols
	OPENBSD_6_1:1.28.0.6
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.17.0.8
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.34
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.32
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.30
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.28
	OPENBSD_5_0:1.15.0.26
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.24
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.22
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.18
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.12
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.16
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.14
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.12
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.10
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.8
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.09.06.04.47.26;	author dlg;	state Exp;
branches;
next	1.32;
commitid	Xwnvn1uP5LxqVUhD;

1.32
date	2017.08.11.20.50.15;	author mpi;	state Exp;
branches;
next	1.31;
commitid	wVXEBQlY9db5AjLx;

1.31
date	2017.08.10.19.39.38;	author mpi;	state Exp;
branches;
next	1.30;
commitid	31PvZ4r4dQH5StiR;

1.30
date	2017.05.30.15.39.05;	author mpi;	state Exp;
branches;
next	1.29;
commitid	PnZZkFEIj4rPydZo;

1.29
date	2017.05.29.06.14.10;	author mpi;	state Exp;
branches;
next	1.28;
commitid	kOJ4rx83W4cr7RQt;

1.28
date	2016.04.20.08.02.59;	author mpi;	state Exp;
branches;
next	1.27;
commitid	czffqpDI3wpnc3Dz;

1.27
date	2016.03.07.11.26.43;	author mpi;	state Exp;
branches;
next	1.26;
commitid	A6aWk73xtRBVWTBp;

1.26
date	2016.03.06.19.05.30;	author mpi;	state Exp;
branches;
next	1.25;
commitid	Ni38yK63LcOWb30h;

1.25
date	2016.03.01.21.35.13;	author mpi;	state Exp;
branches;
next	1.24;
commitid	cgyWVaMY5TPuOMDK;

1.24
date	2016.03.01.21.32.02;	author mpi;	state Exp;
branches;
next	1.23;
commitid	8ue8rik6burb9L4V;

1.23
date	2016.03.01.11.56.00;	author mpi;	state Exp;
branches;
next	1.22;
commitid	CZXiyhU8oBcz6IpF;

1.22
date	2016.02.27.13.17.47;	author mpi;	state Exp;
branches;
next	1.21;
commitid	RePOJ1nAmEf9Lu6X;

1.21
date	2016.02.12.10.58.41;	author mpi;	state Exp;
branches;
next	1.20;
commitid	NKjRYS3Mbadvdn0J;

1.20
date	2016.01.27.10.37.12;	author mpi;	state Exp;
branches;
next	1.19;
commitid	Qlm598QQCEyskMtJ;

1.19
date	2016.01.27.08.03.37;	author mpi;	state Exp;
branches;
next	1.18;
commitid	K645DWxJ9sFrj85C;

1.18
date	2016.01.25.14.30.30;	author mpi;	state Exp;
branches;
next	1.17;
commitid	7AkssaZPPd7mA8h3;

1.17
date	2014.03.16.20.31.46;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.10.17.08.02.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.19.15.23.37;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.13.01.41;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.10.10.42.35;	author niklas;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	97.05.29.03.28.45;	author mickey;	state Exp;
branches
	1.11.12.1;
next	1.10;

1.10
date	97.02.07.07.03.41;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.08.16.10.12.38;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.16.06.13.03;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.05.11.07.44.43;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.10.13.58.44;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.05.05.12.23.19;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.19.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.11.11.16.25;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.13.35.43;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches;
next	;

1.11.12.1
date	2001.05.14.22.07.00;	author niklas;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.11.12.3;

1.11.12.3
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@replace the DDB_STRUCT backend for "show struct" with ctf code.

this lets you inspect arbitrary memory in the kernel as a specified
struct.

ok mpi@@ jasper@@
@
text
@/*	$NetBSD: db_sym.h,v 1.13 2000/05/25 19:57:36 jhawk Exp $	*/

/*
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 *
 * 	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	8/90
 */

#ifndef _DDB_DB_SYM_H_
#define _DDB_DB_SYM_H_

#include <sys/stdint.h>
#include <sys/exec_elf.h>

/*
 * Non-stripped symbol tables will have duplicates, for instance
 * the same string could match a parameter name, a local var, a
 * global var, etc.
 * We are most concern with the following matches.
 */
typedef int		db_strategy_t;	/* search strategy */

#define	DB_STGY_ANY	0			/* anything goes */
#define DB_STGY_XTRN	1			/* only external symbols */
#define DB_STGY_PROC	2			/* only procedures */


/*
 * Internal db_forall function calling convention:
 *
 * (*db_forall_func)(stab, sym, name, suffix, prefix, arg);
 *
 * stab is the symbol table, symbol the (opaque) symbol pointer,
 * name the name of the symbol, suffix a string representing
 * the type, prefix an initial ignorable function prefix (e.g. "_"
 * in a.out), and arg an opaque argument to be passed in.
 */
typedef void (db_forall_func_t)(Elf_Sym *, char *, char *, int, void *);

extern unsigned int db_maxoff;		/* like gdb's "max-symbolic-offset" */

int db_eqname(char *, char *, int);
					/* strcmp, modulo leading char */

Elf_Sym * db_symbol_by_name(char *, db_expr_t *);
					/* find symbol value given name */

Elf_Sym * db_search_symbol(db_addr_t, db_strategy_t, db_expr_t *);
					/* find symbol given value */

void db_symbol_values(Elf_Sym *, char **, db_expr_t *);
					/* return name and value of symbol */

#define db_find_sym_and_offset(val,namep,offp)	\
	db_symbol_values(db_search_symbol(val,DB_STGY_ANY,offp),namep,0)
					/* find name&value given approx val */

#define db_find_xtrn_sym_and_offset(val,namep,offp)	\
	db_symbol_values(db_search_symbol(val,DB_STGY_XTRN,offp),namep,0)
					/* ditto, but no locals */

void db_printsym(db_expr_t, db_strategy_t, int (*)(const char *, ...));
					/* print closest symbol to a value */

int db_elf_sym_init(int, void *, void *, const char *);
Elf_Sym * db_elf_sym_search(db_addr_t, db_strategy_t, db_expr_t *);
int db_elf_line_at_pc(Elf_Sym *, char **, int *, db_expr_t);
void db_elf_sym_forall(db_forall_func_t db_forall_func, void *);

bool db_dwarf_line_at_pc(const char *, size_t, uintptr_t,
    const char **, const char **, int *);

struct ctf_type;

int			 db_ctf_func_numargs(Elf_Sym *);

#endif /* _DDB_DB_SYM_H_ */
@


1.32
log
@Merge DDBCTF into DDB.
@
text
@a98 1
const struct ctf_type	*db_ctf_type_by_name(char *);
@


1.31
log
@With a CTF kernel, DDB's print command will now pretty-print symbols.

Casting a type is not yet supported.

ok kettenis@@, jasper@@
@
text
@a95 1
#ifdef DDBCTF
a99 1
#endif
@


1.30
log
@Kill db_sym_t.

ok deraadt@@, kettenis@@, jasper@@
@
text
@d68 1
a68 1
int db_value_of_name(char *, db_expr_t *);
d97 4
a100 1
int	db_ctf_func_numargs(Elf_Sym *);
@


1.29
log
@Pass the symbol instead of its name when looking for CTF infos.

ok jasper@@
@
text
@d36 1
a36 7

/*
 * Symbol representation is specific to the symtab style:
 * BSD compilers use dbx' nlist, other compilers might use
 * a different one
 */
typedef	char *		db_sym_t;	/* opaque handle on symbols */
d61 1
a61 1
typedef void (db_forall_func_t)(db_sym_t, char *, char *, int, void *);
d71 1
a71 1
db_sym_t db_search_symbol(db_addr_t, db_strategy_t, db_expr_t *);
d74 1
a74 1
void db_symbol_values(db_sym_t, char **, db_expr_t *);
d89 2
a90 2
db_sym_t db_elf_sym_search(db_addr_t, db_strategy_t, db_expr_t *);
int db_elf_line_at_pc(db_sym_t, char **, int *, db_expr_t);
d97 1
a97 1
int	db_ctf_func_numargs(db_sym_t);
@


1.28
log
@Collapse db_dwarf.h into db_sym.h

ok matthew@@
@
text
@d102 4
@


1.27
log
@boolean_t/FALSE/TRUE -> int/0/1
@
text
@d32 5
d98 5
@


1.26
log
@Merge db_elf_sym_values() into db_symbol_values().

ok stefan@@
@
text
@d66 1
a66 1
boolean_t db_eqname(char *, char *, int);
d89 1
a89 1
boolean_t db_elf_sym_init(int, void *, void *, const char *);
d91 1
a91 1
boolean_t db_elf_line_at_pc(db_sym_t, char **, int *, db_expr_t);
@


1.25
log
@db_sym_numargs() has always been defined to FALSE so nuke it with all
its associated dead code.

ok mikeb@@
@
text
@a89 1
void db_elf_sym_values(db_sym_t, char **, db_expr_t *);
@


1.24
log
@Make db_value_of_name() call db_elf_sym_lookup() in order to kill
db_lookup() as requested by mlarkin@@

While here move the function to db_elf.c do keep db_elf_sym_lookup()
private.

ok mikeb@@ appart from the move the function
@
text
@a88 2
#define db_sym_numargs(sym, nargp, argnames) (FALSE)

@


1.23
log
@DB_SYM_NULL -> NULL.
@
text
@a71 2
db_sym_t db_lookup(char *);

a91 1
db_sym_t db_elf_sym_lookup(char *);
@


1.22
log
@Remove the "symbol table" argument of the functions dealing with
symbols.

There's no reason to ask the programmer to supply a specific symbol
table since the kernel only have one.

ok visa@@, guenther@@
@
text
@a37 1
#define	DB_SYM_NULL	((db_sym_t)0)
@


1.21
log
@Kill db_symbol_is_ambiguous().  There's no ambiguous symbol since LKMs
are no longer supported.

ok tb@@, guenther@@
@
text
@a32 12
 * This module can handle multiple symbol tables
 */
typedef struct {
	const char	*name;		/* symtab name */
	char		*start;		/* symtab location */
	char		*end;
	char		*private;	/* optional machdep pointer */
} db_symtab_t;

extern db_symtab_t	*db_last_symtab; /* where last symbol was found */

/*
d63 1
a63 1
typedef void (db_forall_func_t)(db_symtab_t *, db_sym_t, char *, char *, int, void *);
a65 8
/*
 * Functions exported by the symtable module
 */
int db_add_symbol_table(char *, char *, const char *, char *);
					/* extend the list of symbol tables */

void db_del_symbol_table(char *);
					/* remove a symbol table from list */
a93 2
char *db_qualify(db_sym_t, const char *);

d95 5
a99 5
db_sym_t db_elf_sym_lookup(db_symtab_t *, char *);
void db_elf_sym_values(db_symtab_t *, db_sym_t, char **, db_expr_t *);
db_sym_t db_elf_sym_search(db_symtab_t *, db_addr_t, db_strategy_t, db_expr_t *);
boolean_t db_elf_line_at_pc(db_symtab_t *, db_sym_t, char **, int *, db_expr_t);
void db_elf_sym_forall(db_symtab_t *, db_forall_func_t db_forall_func, void *);
@


1.20
log
@Removes the abstraction layer to support multiple executable binaries.

Simplifies the API to manipulate symbols now that all our architectures
are ELF.

ok tb@@
@
text
@a76 5
extern boolean_t	db_qualify_ambiguous_names;
					/* if TRUE, check across symbol tables
					 * for multiple occurrences of a name.
					 * Might slow down quite a bit */

a93 2

boolean_t db_symbol_is_ambiguous(db_sym_t);
@


1.19
log
@Remove unused db_sifting().
@
text
@a76 23
void		X_db_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);

/*
 * A symbol table may be in one of many formats.  All symbol tables
 * must be of the same format as the master kernel symbol table.
 */
typedef struct {
	const char *sym_format;
	boolean_t (*sym_init)(int, void *, void *, const char *);
	db_sym_t (*sym_lookup)(db_symtab_t *, char *);
	db_sym_t (*sym_search)(db_symtab_t *, db_addr_t, db_strategy_t,
		db_expr_t *);
	void	(*sym_value)(db_symtab_t *, db_sym_t, char **,
		db_expr_t *);
	boolean_t (*sym_line_at_pc)(db_symtab_t *, db_sym_t,
		char **, int *, db_expr_t);
	boolean_t (*sym_numargs)(db_symtab_t *, db_sym_t, int *,
		char **);
	void	(*sym_forall)(db_symtab_t *,
		db_forall_func_t *db_forall_func, void *);
} db_symformat_t;

d119 1
a119 1
boolean_t db_line_at_pc(db_sym_t, char **, int *, db_expr_t);
a120 1
int db_sym_numargs(db_sym_t, int *, char **);
d123 6
a128 1
extern	db_symformat_t db_symformat_elf;
@


1.18
log
@Kill trailing whitespaces.  No object change.
@
text
@a122 3
void db_sifting(char *, int);
				/* print partially matching symbol names */

@


1.17
log
@DDB supports ELF symbols are all archs, and it's always the same as the
native size, so eliminate the #defines.

ok miod@@
@
text
@d3 1
a3 1
/* 
d7 1
a7 1
 * 
d13 1
a13 1
 * 
d17 1
a17 1
 * 
d19 1
a19 1
 * 
d24 1
a24 1
 * 
@


1.16
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@a149 1
#ifdef DB_ELF_SYMBOLS
a150 1
#endif
@


1.15
log
@Nuke DB_NO_AOUT, and have platforms with a.out symbols explicitely provide
DB_AOUT_SYMBOLS.
@
text
@a149 3
#ifdef DB_AOUT_SYMBOLS
extern	db_symformat_t db_symformat_aout;
#endif
@


1.14
log
@Add a an argument to db_printsym that specifies the printf function
we'll use for printing the information.
miod@@ ok
@
text
@a149 7
/*
 * XXX - should explicitly ask for aout symbols in machine/db_machdep.h
 */
#ifndef DB_NO_AOUT
#define DB_AOUT_SYMBOLS
#endif

@


1.13
log
@First round of __P removal in sys
@
text
@d142 1
a142 1
void db_printsym(db_expr_t, db_strategy_t);
@


1.12
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d75 1
a75 2
typedef void (db_forall_func_t)
	__P((db_symtab_t *, db_sym_t, char *, char *, int, void *));
d77 2
a78 2
void		X_db_forall __P((db_symtab_t *,
		    db_forall_func_t db_forall_func, void *));
d86 12
a97 12
	boolean_t (*sym_init) __P((int, void *, void *, const char *));
	db_sym_t (*sym_lookup) __P((db_symtab_t *, char *));
	db_sym_t (*sym_search) __P((db_symtab_t *, db_addr_t, db_strategy_t,
		db_expr_t *));
	void	(*sym_value) __P((db_symtab_t *, db_sym_t, char **,
		db_expr_t *));
	boolean_t (*sym_line_at_pc) __P((db_symtab_t *, db_sym_t,
		char **, int *, db_expr_t));
	boolean_t (*sym_numargs) __P((db_symtab_t *, db_sym_t, int *,
		char **));
	void	(*sym_forall) __P((db_symtab_t *,
		db_forall_func_t *db_forall_func, void *));
d109 1
a109 1
int db_add_symbol_table __P((char *, char *, const char *, char *));
d112 1
a112 1
void db_del_symbol_table __P((char *));
d115 1
a115 1
boolean_t db_eqname __P((char *, char *, int));
d118 1
a118 1
int db_value_of_name __P((char *, db_expr_t *));
d121 1
a121 1
db_sym_t db_lookup __P((char *));
d123 1
a123 1
void db_sifting __P((char *, int));
d126 1
a126 1
boolean_t db_symbol_is_ambiguous __P((db_sym_t));
d128 1
a128 1
db_sym_t db_search_symbol __P((db_addr_t, db_strategy_t, db_expr_t *));
d131 1
a131 1
void db_symbol_values __P((db_sym_t, char **, db_expr_t *));
d142 1
a142 1
void db_printsym __P((db_expr_t, db_strategy_t));
d145 1
a145 1
boolean_t db_line_at_pc __P((db_sym_t, char **, int *, db_expr_t));
d147 2
a148 2
int db_sym_numargs __P((db_sym_t, int *, char **));
char *db_qualify __P((db_sym_t, const char *));
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d75 2
a76 1
typedef void (db_forall_func_t)(db_symtab_t *, db_sym_t, char *, char *, int, void *);
d78 2
a79 2
void		X_db_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
d87 12
a98 12
	boolean_t (*sym_init)(int, void *, void *, const char *);
	db_sym_t (*sym_lookup)(db_symtab_t *, char *);
	db_sym_t (*sym_search)(db_symtab_t *, db_addr_t, db_strategy_t,
		db_expr_t *);
	void	(*sym_value)(db_symtab_t *, db_sym_t, char **,
		db_expr_t *);
	boolean_t (*sym_line_at_pc)(db_symtab_t *, db_sym_t,
		char **, int *, db_expr_t);
	boolean_t (*sym_numargs)(db_symtab_t *, db_sym_t, int *,
		char **);
	void	(*sym_forall)(db_symtab_t *,
		db_forall_func_t *db_forall_func, void *);
d110 1
a110 1
int db_add_symbol_table(char *, char *, const char *, char *);
d113 1
a113 1
void db_del_symbol_table(char *);
d116 1
a116 1
boolean_t db_eqname(char *, char *, int);
d119 1
a119 1
int db_value_of_name(char *, db_expr_t *);
d122 1
a122 1
db_sym_t db_lookup(char *);
d124 1
a124 1
void db_sifting(char *, int);
d127 1
a127 1
boolean_t db_symbol_is_ambiguous(db_sym_t);
d129 1
a129 1
db_sym_t db_search_symbol(db_addr_t, db_strategy_t, db_expr_t *);
d132 1
a132 1
void db_symbol_values(db_sym_t, char **, db_expr_t *);
d143 1
a143 1
void db_printsym(db_expr_t, db_strategy_t, int (*)(const char *, ...));
d146 1
a146 1
boolean_t db_line_at_pc(db_sym_t, char **, int *, db_expr_t);
d148 2
a149 2
int db_sym_numargs(db_sym_t, int *, char **);
char *db_qualify(db_sym_t, const char *);
@


1.11
log
@futher support for kernfs......
@
text
@d1 1
a1 2
/*	$OpenBSD: db_sym.h,v 1.10 1997/02/07 07:03:41 mickey Exp $	*/
/*	$NetBSD: db_sym.h,v 1.7 1996/02/05 01:57:16 christos Exp $	*/
a31 3
#ifndef _DDB_DB_SYM_
#define _DDB_DB_SYM_

d35 2
a36 7

#include <sys/queue.h>

typedef struct db_symtab {
	TAILQ_ENTRY(db_symtab)	list;	/* all the tabs */
	char		*name;		/* symtab name */
	u_int		id;		/* id */
d38 1
a38 2
	char		*end;		/* end of symtab */
	char		*rend;		/* real end (as it passed) */
d40 1
a40 1
}	*db_symtab_t;
d42 1
a42 2
extern db_symtab_t	db_last_symtab; /* where last symbol was found */
extern size_t		db_nsymtabs;	/* number of symbol tables */
d64 37
d106 1
d110 1
a110 2
void db_sym_init __P((void));
int db_add_symbol_table __P((char *, char *, char *, char *, char *));
a114 3
db_symtab_t db_istab __P((size_t));
db_symtab_t db_symiter __P((db_symtab_t));
				/* iterate through all the symtabs, if any */
d124 2
a125 1
char *db_qualify __P((db_sym_t, char *));
d149 1
a149 4
struct exec;
void db_stub_xh __P((db_symtab_t, struct exec *));
int db_symtablen __P((db_symtab_t));
int db_symatoff __P((db_symtab_t, int, void*, int*));
d151 13
a163 4
/* db_hangman.c */
void db_hangman __P((db_expr_t, int, db_expr_t, char *));

#endif /* _DDB_DB_SYM_H_ */
@


1.11.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/*	$NetBSD: db_sym.h,v 1.13 2000/05/25 19:57:36 jhawk Exp $	*/
d33 3
d39 7
a45 2
typedef struct {
	const char	*name;		/* symtab name */
d47 2
a48 1
	char		*end;
d50 1
a50 1
} db_symtab_t;
d52 2
a53 1
extern db_symtab_t	*db_last_symtab; /* where last symbol was found */
a74 37

/*
 * Internal db_forall function calling convention:
 *
 * (*db_forall_func)(stab, sym, name, suffix, prefix, arg);
 *
 * stab is the symbol table, symbol the (opaque) symbol pointer,
 * name the name of the symbol, suffix a string representing
 * the type, prefix an initial ignorable function prefix (e.g. "_"
 * in a.out), and arg an opaque argument to be passed in.
 */
typedef void (db_forall_func_t)
	__P((db_symtab_t *, db_sym_t, char *, char *, int, void *));

void		X_db_forall __P((db_symtab_t *,
		    db_forall_func_t db_forall_func, void *));

/*
 * A symbol table may be in one of many formats.  All symbol tables
 * must be of the same format as the master kernel symbol table.
 */
typedef struct {
	const char *sym_format;
	boolean_t (*sym_init) __P((int, void *, void *, const char *));
	db_sym_t (*sym_lookup) __P((db_symtab_t *, char *));
	db_sym_t (*sym_search) __P((db_symtab_t *, db_addr_t, db_strategy_t,
		db_expr_t *));
	void	(*sym_value) __P((db_symtab_t *, db_sym_t, char **,
		db_expr_t *));
	boolean_t (*sym_line_at_pc) __P((db_symtab_t *, db_sym_t,
		char **, int *, db_expr_t));
	boolean_t (*sym_numargs) __P((db_symtab_t *, db_sym_t, int *,
		char **));
	void	(*sym_forall) __P((db_symtab_t *,
		db_forall_func_t *db_forall_func, void *));
} db_symformat_t;

a79 1
extern unsigned int db_maxoff;		/* like gdb's "max-symbolic-offset" */
d83 2
a84 1
int db_add_symbol_table __P((char *, char *, const char *, char *));
d89 3
d101 1
a101 2
void db_sifting __P((char *, int));
				/* print partially matching symbol names */
d125 7
a131 1
char *db_qualify __P((db_sym_t, const char *));
d133 1
a133 13
/*
 * XXX - should explicitly ask for aout symbols in machine/db_machdep.h
 */
#ifndef DB_NO_AOUT
#define DB_AOUT_SYMBOLS
#endif

#ifdef DB_AOUT_SYMBOLS
extern	db_symformat_t db_symformat_aout;
#endif
#ifdef DB_ELF_SYMBOLS
extern	db_symformat_t db_symformat_elf;
#endif
@


1.11.12.2
log
@Merge in -current from about a week ago
@
text
@d75 2
a76 1
typedef void (db_forall_func_t)(db_symtab_t *, db_sym_t, char *, char *, int, void *);
d78 2
a79 2
void		X_db_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
d87 12
a98 12
	boolean_t (*sym_init)(int, void *, void *, const char *);
	db_sym_t (*sym_lookup)(db_symtab_t *, char *);
	db_sym_t (*sym_search)(db_symtab_t *, db_addr_t, db_strategy_t,
		db_expr_t *);
	void	(*sym_value)(db_symtab_t *, db_sym_t, char **,
		db_expr_t *);
	boolean_t (*sym_line_at_pc)(db_symtab_t *, db_sym_t,
		char **, int *, db_expr_t);
	boolean_t (*sym_numargs)(db_symtab_t *, db_sym_t, int *,
		char **);
	void	(*sym_forall)(db_symtab_t *,
		db_forall_func_t *db_forall_func, void *);
d110 1
a110 1
int db_add_symbol_table(char *, char *, const char *, char *);
d113 1
a113 1
void db_del_symbol_table(char *);
d116 1
a116 1
boolean_t db_eqname(char *, char *, int);
d119 1
a119 1
int db_value_of_name(char *, db_expr_t *);
d122 1
a122 1
db_sym_t db_lookup(char *);
d124 1
a124 1
void db_sifting(char *, int);
d127 1
a127 1
boolean_t db_symbol_is_ambiguous(db_sym_t);
d129 1
a129 1
db_sym_t db_search_symbol(db_addr_t, db_strategy_t, db_expr_t *);
d132 1
a132 1
void db_symbol_values(db_sym_t, char **, db_expr_t *);
d143 1
a143 1
void db_printsym(db_expr_t, db_strategy_t);
d146 1
a146 1
boolean_t db_line_at_pc(db_sym_t, char **, int *, db_expr_t);
d148 2
a149 2
int db_sym_numargs(db_sym_t, int *, char **);
char *db_qualify(db_sym_t, const char *);
@


1.11.12.3
log
@Sync the SMP branch with 3.3
@
text
@d142 1
a142 1
void db_printsym(db_expr_t, db_strategy_t, int (*)(const char *, ...));
@


1.10
log
@wrong private name
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.h,v 1.9 1996/08/16 10:12:38 mickey Exp $	*/
d127 2
@


1.9
log
@record real symtab end.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.h,v 1.8 1996/08/16 06:13:03 mickey Exp $	*/
d125 2
@


1.8
log
@add symtab list public iterator.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.h,v 1.4 1996/04/21 22:19:15 deraadt Exp $	*/
d47 2
a48 1
	char		*end;
d84 1
a84 1
int db_add_symbol_table __P((char *, char *, char *, char *));
@


1.7
log
@Include sys/queue.h, and add multiple include protection
@
text
@d45 1
d89 2
@


1.6
log
@do dynamic symtab allocattion.
@
text
@d33 3
d39 3
d124 2
@


1.5
log
@add advanced hang analyzer.
idea by theo.
@
text
@d36 2
a37 1
typedef struct {
d42 1
a42 1
} db_symtab_t;
d44 1
a44 1
extern db_symtab_t	*db_last_symtab; /* where last symbol was found */
d75 1
d81 1
a81 1
db_symtab_t *db_istab __P((size_t));
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.h,v 1.3 1996/03/11 11:16:25 mickey Exp $	*/
d44 1
d79 1
d89 2
d113 3
@


1.3
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_sym.h,v 1.2 1996/02/20 13:35:43 mickey Exp $	*/
@


1.2
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_sym.h,v 1.7 1996/02/05 01:57:16 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: db_sym.h,v 1.6 1994/10/09 08:19:41 mycroft Exp $	*/
d78 3
d84 4
a101 3
int db_eqname __P((char *, char *, char));
					/* strcmp, modulo leading char */

d104 4
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
