head	1.31;
access;
symbols
	OPENBSD_5_4:1.30.0.30
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.28
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.26
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.24
	OPENBSD_5_0:1.30.0.22
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.20
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.18
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.14
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.16
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.12
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.10
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.18
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.16
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.14
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.12
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.10
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.8
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.6
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.4
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.28
	UBC:1.27.0.6
	UBC_BASE:1.27
	OPENBSD_3_0:1.27.0.4
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.24.0.8
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.24.0.6
	OPENBSD_2_7_BASE:1.24
	SMP:1.24.0.4
	SMP_BASE:1.24
	kame_19991208:1.24
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.21.0.4
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2013.10.17.08.02.18;	author deraadt;	state dead;
branches;
next	1.30;

1.30
date	2006.07.06.18.12.50;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.13.06.23.20;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.10.20.40.03;	author millert;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2001.02.10.10.42.35;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.06.07.03.56;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	99.09.11.00.44.59;	author mickey;	state Exp;
branches
	1.24.4.1;
next	1.23;

1.23
date	98.12.20.23.49.56;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.08.21.23.29.03;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.07.19.22.31.15;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	97.07.08.20.20.31;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.07.08.10.48.32;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.06.12.03.46.57;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.05.29.03.55.06;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.05.29.03.28.43;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.07.08.32.15;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.02.07.08.04.10;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.07.07.03.38;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.02.07.06.18.44;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.08.23.19.53.46;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.08.16.10.12.35;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.08.13.00.41.33;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.10.13.58.43;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.05.05.12.23.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.19.16.08.28;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.30.04.51.28;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.11.11.15.57;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.13.35.31;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.08.03.04.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.27;	author deraadt;	state Exp;
branches;
next	;

1.24.4.1
date	2001.05.14.22.06.56;	author niklas;	state Exp;
branches;
next	1.24.4.2;

1.24.4.2
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	;

1.27.6.1
date	2002.06.11.03.28.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@/*	$OpenBSD: db_aout.c,v 1.30 2006/07/06 18:12:50 miod Exp $	*/
/*	$NetBSD: db_aout.c,v 1.29 2000/07/07 21:55:18 jhawk Exp $	*/

/* 
 * Mach Operating System
 * Copyright (c) 1993,1992,1991,1990 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>

#include <machine/db_machdep.h>		/* data types */

#include <ddb/db_sym.h>
#include <ddb/db_output.h>
#include <ddb/db_extern.h>

#ifdef	DB_AOUT_SYMBOLS

#include <ddb/db_aout.h>

boolean_t	db_aout_sym_init(int, void *, void *, const char *);
db_sym_t	db_aout_lookup(db_symtab_t *, char *);
db_sym_t	db_aout_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_aout_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_aout_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_aout_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_aout_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);

db_symformat_t db_symformat_aout = {
	"a.out",
	db_aout_sym_init,
	db_aout_lookup,
	db_aout_search_symbol,
	db_aout_symbol_values,
	db_aout_line_at_pc,
	db_aout_sym_numargs,
	db_aout_forall
};

/*
 * An a.out symbol table as loaded into the kernel debugger:
 *
 * symtab	-> size of symbol entries, in bytes
 * sp		-> first symbol entry
 *		   ...
 * ep		-> last symbol entry + 1
 * strtab	== start of string table
 *		   size of string table in bytes,
 *		   including this word
 *		-> strings
 */
static char *strtab;
static int slen;

#define X_db_getname(t, s)	(s->n_un.n_strx ? t->end + s->n_un.n_strx : NULL)

/*
 * Find the symbol table and strings; tell ddb about them.
 *
 * symsize:	size of symbol table
 * vsymtab:	pointer to end of string table
 * vesymtab:	pointer to end of string table, for checking - rounded up to
 * 		    integer boundry
 */
boolean_t
db_aout_sym_init(int symsize, void *vsymtab, void *vesymtab, const char *name)
{
	struct nlist	*sym_start, *sym_end;
	struct nlist	*sp;
	int bad = 0;
	char *estrtab;

	/*
	 * XXX - ddb_init should take arguments.
	 *       Fixup the arguments.
	 */
	symsize = *(long *)vsymtab;
	vsymtab = (void *)((long *)vsymtab + 1);
	

	if (ALIGNED_POINTER(vsymtab, long) == 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, vsymtab);
		return (FALSE);
	}

	/*
	 * Find pointers to the start and end of the symbol entries,
	 * given a pointer to the start of the symbol table.
	 */
	sym_start = (struct nlist *)vsymtab;
	sym_end   = (struct nlist *)((char *)sym_start + symsize);

	strtab = (char *)sym_end;
	if (ALIGNED_POINTER(strtab, int) == 0) {
		printf("[ %s symbol table has bad string table address %p ]\n",
		    name, strtab);
		return (FALSE);
	}
	slen = *(int *)strtab;

	estrtab = strtab + slen;

#define	round_to_size(x) \
    (((vaddr_t)(x) + sizeof(vsize_t) - 1) & ~(sizeof(vsize_t) - 1))

	if (round_to_size(estrtab) != round_to_size(vesymtab)) {
		printf("[ %s a.out symbol table not valid ]\n", name);
		return (FALSE);
        }
#undef	round_to_size
        
	for (sp = sym_start; sp < sym_end; sp++) {
		int strx;
		strx = sp->n_un.n_strx;
		if (strx != 0) {
			if (strx > slen) {
				printf("[ %s has bad a.out string table index "
				    "(0x%x) ]\n",
				    name, strx);
				bad = 1;
				continue;
			}
		}
	}

	if (bad)
		return (FALSE);

	if (db_add_symbol_table((char *)sym_start, (char *)sym_end, name,
	    NULL) !=  -1) {
                printf("[ using %ld bytes of %s a.out symbol table ]\n",
                    (long)vesymtab - (long)vsymtab, name);
		return (TRUE);
        }

	return (FALSE);
}

db_sym_t
db_aout_lookup(db_symtab_t *stab, char *symstr)
{
	struct nlist *sp, *ep;
	char *n_name;

	sp = (struct nlist *)stab->start;
	ep = (struct nlist *)stab->end;

	for (; sp < ep; sp++) {
		if ((n_name = X_db_getname(stab, sp)) == 0)
			continue;
		if ((sp->n_type & N_STAB) == 0 &&
		    db_eqname(n_name, symstr, '_'))
			return ((db_sym_t)sp);
	}
	return ((db_sym_t)0);
}

db_sym_t
db_aout_search_symbol(db_symtab_t *symtab, db_addr_t off,
    db_strategy_t strategy, db_expr_t *diffp)
{
	unsigned int	diff = *diffp;
	struct nlist	*symp = 0;
	struct nlist	*sp, *ep;

	sp = (struct nlist *)symtab->start;
	ep = (struct nlist *)symtab->end;

	for (; sp < ep; sp++) {
		if ((sp->n_type & N_STAB) != 0 ||
		    (sp->n_type & N_TYPE) == N_FN)
			continue;
		if (X_db_getname(symtab, sp) == 0)
			continue;
		if (off >= sp->n_value) {
			if (off - sp->n_value < diff) {
				diff = off - sp->n_value;
				symp = sp;
				if (diff == 0 && ((strategy == DB_STGY_PROC &&
				    sp->n_type == (N_TEXT|N_EXT)) ||
				    (strategy == DB_STGY_ANY &&
				    (sp->n_type & N_EXT))))
					break;
			} else if (off - sp->n_value == diff) {
				if (symp == 0)
					symp = sp;
				else if ((symp->n_type & N_EXT) == 0 &&
				    (sp->n_type & N_EXT) != 0)
					symp = sp;	/* pick the ext. sym */
			}
		}
	}
	if (symp == 0) {
		*diffp = off;
	} else {
		*diffp = diff;
	}
	return ((db_sym_t)symp);
}

/*
 * Return the name and value for a symbol.
 */
void
db_aout_symbol_values(db_symtab_t *symtab, db_sym_t sym, char **namep,
    db_expr_t *valuep)
{
	struct nlist *sp;

	sp = (struct nlist *)sym;
	if (namep)
		*namep = X_db_getname(symtab, sp);
	if (valuep)
		*valuep = sp->n_value;
}


boolean_t
db_aout_line_at_pc(db_symtab_t *symtab, db_sym_t cursym, char **filename,
    int *linenum, db_expr_t off)
{
	struct nlist	*sp, *ep;
	unsigned long	sodiff = -1UL, lndiff = -1UL, ln = 0;
	char		*fname = NULL;

	sp = (struct nlist *)symtab->start;
	ep = (struct nlist *)symtab->end;

/* XXX - gcc specific */
#define NEWSRC(str)	((str) != NULL && \
    (str)[0] == 'g' && strcmp((str), "gcc_compiled.") == 0)

	for (; sp < ep; sp++) {

		/*
		 * Prevent bogus linenumbers in case module not compiled
		 * with debugging options
		 */
#if 0
		if (sp->n_value <= off && (off - sp->n_value) <= sodiff &&
		    NEWSRC(X_db_getname(symtab, sp))) {
#endif
		if ((sp->n_type & N_TYPE) == N_FN ||
		    NEWSRC(X_db_getname(symtab, sp))) {
			sodiff = lndiff = -1UL;
			ln = 0;
			fname = NULL;
		}

		if (sp->n_type == N_SO) {
			if (sp->n_value <= off &&
			    (off - sp->n_value) < sodiff) {
				sodiff = off - sp->n_value;
				fname = X_db_getname(symtab, sp);
			}
			continue;
		}

		if (sp->n_type != N_SLINE)
			continue;

		if (sp->n_value > off)
			break;

		if (off - sp->n_value < lndiff) {
			lndiff = off - sp->n_value;
			ln = sp->n_desc;
		}
	}

	if (fname != NULL && ln != 0) {
		*filename = fname;
		*linenum = ln;
		return (TRUE);
	}

	return (FALSE);
}

boolean_t
db_aout_sym_numargs(db_symtab_t *symtab, db_sym_t cursym, int *nargp,
    char **argnamep)
{
	struct nlist	*sp, *ep;
	u_long		addr;
	int		maxnarg = *nargp, nargs = 0;
	char		*n_name;

	if (cursym == NULL)
		return (FALSE);

	addr = ((struct nlist *)cursym)->n_value;
	sp = (struct nlist *)symtab->start;
	ep = (struct nlist *)symtab->end;

	for (; sp < ep; sp++) {
		if (sp->n_type == N_FUN && sp->n_value == addr) {
			while (++sp < ep && sp->n_type == N_PSYM) {
				if (nargs >= maxnarg)
					break;
				nargs++;
				n_name = X_db_getname(symtab, sp);
				*argnamep++ = n_name ? n_name : "???";
				{
					/* XXX - remove trailers */
					char *cp = *(argnamep - 1);

					while (*cp != '\0' && *cp != ':')
						cp++;
					if (*cp == ':') *cp = '\0';
				}
			}
			*nargp = nargs;
			return (TRUE);
		}
	}
	return (FALSE);
}

void
db_aout_forall(db_symtab_t *stab, db_forall_func_t db_forall_func, void *arg)
{
	static char suffix[2];
	struct nlist *sp, *ep;

	sp = (struct nlist *)stab->start;
	ep = (struct nlist *)stab->end;

	for (; sp < ep; sp++) {
		if (X_db_getname(stab, sp) == 0)
			continue;
		if ((sp->n_type & N_STAB) == 0) {
			suffix[1] = '\0';
			switch(sp->n_type & N_TYPE) {
			case N_ABS:
				suffix[0] = '@@';
				break;
			case N_TEXT:
				suffix[0] = '*';
				break;
			case N_DATA:
				suffix[0] = '+';
				break;
			case N_BSS:
				suffix[0] = '-';
				break;
			case N_FN:
				suffix[0] = '/';
				break;
			default:
				suffix[0] = '\0';
			}
			(*db_forall_func)(stab, (db_sym_t)sp,
			    X_db_getname(stab, sp), suffix, '_', arg);
		}
	}
	return;
}

	
#endif	/* DB_AOUT_SYMBOLS */
@


1.30
log
@ALIGNED_POINTER is defined on all platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.29 2006/03/13 06:23:20 jsg Exp $	*/
@


1.29
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.28 2002/03/14 01:26:51 millert Exp $	*/
a84 5

/* XXX */
#ifndef ALIGNED_POINTER
#define ALIGNED_POINTER(p,t)        ((((u_long)(p)) & (sizeof(t)-1)) == 0)
#endif
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.27 2001/02/10 20:40:03 millert Exp $	*/
d93 5
d100 1
a100 7
db_aout_sym_init(symsize, vsymtab, vesymtab, name)
	int symsize;		/* size of symbol table */
	void *vsymtab;		/* pointer to start of symbol table */
	void *vesymtab;		/* pointer to end of string table,
				   for checking - rounded up to integer
				   boundary */
	const char *name;
d175 1
a175 3
db_aout_lookup(stab, symstr)
	db_symtab_t	*stab;
	char *		symstr;
d194 2
a195 5
db_aout_search_symbol(symtab, off, strategy, diffp)
	db_symtab_t *	symtab;
	db_addr_t	off;
	db_strategy_t	strategy;
	db_expr_t	*diffp;		/* in/out */
d240 2
a241 5
db_aout_symbol_values(symtab, sym, namep, valuep)
	db_symtab_t	*symtab;
	db_sym_t	sym;
	char		**namep;
	db_expr_t	*valuep;
d254 2
a255 6
db_aout_line_at_pc(symtab, cursym, filename, linenum, off)
	db_symtab_t *	symtab;
	db_sym_t	cursym;
	char 		**filename;
	int 		*linenum;
	db_expr_t	off;
d316 2
a317 5
db_aout_sym_numargs(symtab, cursym, nargp, argnamep)
	db_symtab_t *	symtab;
	db_sym_t	cursym;
	int		*nargp;
	char		**argnamep;
d356 1
a356 4
db_aout_forall(stab, db_forall_func, arg)
	db_symtab_t		*stab;
	db_forall_func_t	db_forall_func;
	void			*arg;
@


1.27
log
@When computing the value of an entry in the string table, don't
just add strtab to s->n_un.n_strx since we may have multiple string
tables (for instance in the case of lkms).  Instead, add in t->end
whcih in a.out will be the start of the string table for this symtab.
OK'd by niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.26 2001/02/10 10:42:35 niklas Exp $	*/
d45 12
a56 12
boolean_t	db_aout_sym_init __P((int, void *, void *, const char *));
db_sym_t	db_aout_lookup __P((db_symtab_t *, char *));
db_sym_t	db_aout_search_symbol __P((db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *));
void		db_aout_symbol_values __P((db_symtab_t *, db_sym_t,
		    char **, db_expr_t *));
boolean_t	db_aout_line_at_pc __P((db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t));
boolean_t	db_aout_sym_numargs __P((db_symtab_t *, db_sym_t, int *,
		    char **));
void		db_aout_forall __P((db_symtab_t *,
		    db_forall_func_t db_forall_func, void *));
@


1.27.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.27 2001/02/10 20:40:03 millert Exp $	*/
d45 12
a56 12
boolean_t	db_aout_sym_init(int, void *, void *, const char *);
db_sym_t	db_aout_lookup(db_symtab_t *, char *);
db_sym_t	db_aout_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_aout_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_aout_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_aout_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_aout_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
@


1.26
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
#define X_db_getname(s)	(s->n_un.n_strx > slen ? NULL : strtab + s->n_un.n_strx)
d187 1
a187 1
		if ((n_name = X_db_getname(sp)) == 0)
a210 2
		if (X_db_getname(sp) == 0)
			continue;
d214 2
d256 1
a256 1
		*namep = X_db_getname(sp);
d289 1
a289 1
		    NEWSRC(X_db_getname(sp))) {
d292 1
a292 1
		    NEWSRC(X_db_getname(sp))) {
d302 1
a302 1
				fname = X_db_getname(sp);
d353 1
a353 1
				n_name = X_db_getname(sp);
d384 1
a384 1
		if (X_db_getname(sp) == 0)
d407 2
a408 2
			(*db_forall_func)(stab, (db_sym_t)sp, X_db_getname(sp),
			    suffix, '_', arg);
@


1.25
log
@Allow booting on alphas with DDB, although no symbols will be seen.
@
text
@d1 2
a2 2
/*	$OpenBSD: db_aout.c,v 1.24 1999/09/11 00:44:59 mickey Exp $	*/
/*	$NetBSD: db_aout.c,v 1.14 1996/02/27 20:54:43 gwr Exp $	*/
a33 5
#include <sys/exec.h>
#include <sys/conf.h>
#include <sys/lkm.h>

#include <vm/vm.h>
d41 1
a41 1
#ifndef	DB_NO_AOUT
d45 24
a80 5

#ifdef	SYMTAB_SPACE
int db_symtabsize = SYMTAB_SPACE;
int db_symtab[SYMTAB_SPACE/sizeof(int)] = { 0, 1 };
#endif
a83 3
#ifdef	SYMTAB_SPACE
#define X_db_getname(s)		(s->n_un.n_name)
#else
d85 4
d94 5
a98 4
void
X_db_sym_init(symtab, esymtab, name)
	long *symtab;		/* pointer to start of symbol table */
	char *esymtab;		/* pointer to end of string table,
d101 1
a101 1
	char *name;
d104 3
a106 1
	char		*estrtab;
d108 12
a119 9
#ifdef __alpha__
	printf ("DDB: no symbols\n");
	return;
#endif

#ifdef SYMTAB_SPACE
	if (*symtab < sizeof(int)) {
		printf ("DDB: no symbols\n");
		return;
a120 1
#endif
d126 2
a127 2
	sym_start = (struct nlist *)(symtab + 1);
	sym_end   = (struct nlist *)((char *)sym_start + *symtab);
d130 5
a136 8
#ifdef	SYMTAB_SPACE
	printf("DDB: found symbols [%d + %d bytes]\n",
		   *symtab, slen);
	if ((*symtab + slen) > db_symtabsize) {
		printf("DDB: symbols larger than SYMTAB_SPACE?\n");
		return;
	}
#else
d140 1
a140 1
	(((vaddr_t)(x) + sizeof(vsize_t) - 1) & ~(sizeof(vsize_t) - 1))
d142 3
a144 3
	if (round_to_size(estrtab) != round_to_size(esymtab)) {
	    db_printf("[ %s symbol table not valid ]\n", name);
	    return;
d148 16
a163 1
#endif
d166 4
a169 5
	    (char *)symtab, esymtab) !=  -1) {
#ifndef	SYMTAB_SPACE
                db_printf("[ preserving %d bytes of %s symbol table ]\n",
                          esymtab - (char *)symtab, name);
#endif
a170 1
}
d172 1
a172 5
size_t
X_db_nsyms(stab)
	db_symtab_t	stab;
{
	return (struct nlist *)stab->end - (struct nlist *)stab->start;
d176 2
a177 13
X_db_isym(stab, i)
	db_symtab_t	stab;
	size_t		i;
{
	if (i >= X_db_nsyms(stab))
		return NULL;
	else
		return (db_sym_t)((struct nlist *)stab->start + i);
}

db_sym_t
X_db_lookup(stab, symstr)
	db_symtab_t	stab;
d180 1
a180 1
	register struct nlist *sp, *ep;
d187 5
a191 4
	    if ((n_name = X_db_getname(sp)) == 0)
		continue;
	    if ((sp->n_type & N_STAB) == 0 && db_eqname(n_name, symstr, '_'))
		return ((db_sym_t)sp);
d197 2
a198 3
X_db_search_symbol(symtab, off, strategy, diffp)
	db_symtab_t	symtab;
	register
d203 3
a205 3
	register db_expr_t	diff = *diffp;
	register struct nlist	*symp = 0;
	register struct nlist	*sp, *ep;
d211 21
a231 21
	    if (X_db_getname(sp) == 0)
		continue;
	    if ((sp->n_type & N_STAB) != 0 || (sp->n_type & N_TYPE) == N_FN)
		continue;
	    if (off >= sp->n_value) {
		if ((db_expr_t)(off - sp->n_value) < diff || diff < 0) {
		    diff = off - sp->n_value;
		    symp = sp;
		    if (diff == 0 &&
				((strategy == DB_STGY_PROC &&
					sp->n_type == (N_TEXT|N_EXT)) ||
				 (strategy == DB_STGY_ANY &&
					(sp->n_type & N_EXT))))
			break;
		}
		else if ((db_expr_t)(off - sp->n_value) == diff) {
		    if (symp == 0)
			symp = sp;
		    else if ((symp->n_type & N_EXT) == 0 &&
				(sp->n_type & N_EXT) != 0)
			symp = sp;	/* pick the external symbol */
a232 1
	    }
d235 3
a237 4
	    *diffp = off;
	}
	else {
	    *diffp = diff;
d246 2
a247 1
X_db_symbol_values(sym, namep, valuep)
d252 1
a252 1
	register struct nlist *sp;
d254 1
a254 2
	if ((sp = (struct nlist *)sym) == NULL)
	    return;
d256 1
a256 1
	    *namep = X_db_getname(sp);
d258 1
a258 1
	    *valuep = sp->n_value;
d263 2
a264 2
X_db_line_at_pc(symtab, cursym, filename, linenum, off)
	db_symtab_t	symtab;
d270 3
a272 3
	register struct nlist	*sp, *ep;
	unsigned long		sodiff = -1UL, lndiff = -1UL, ln = 0;
	char			*fname = NULL;
d279 1
a279 1
			(str)[0] == 'g' && strcmp((str), "gcc_compiled.") == 0)
d283 4
a286 4
	    /*
	     * Prevent bogus linenumbers in case module not compiled
	     * with debugging options
	     */
d288 2
a289 2
	    if (sp->n_value <= off && (off - sp->n_value) <= sodiff &&
		NEWSRC(X_db_getname(sp))) {
d291 14
a304 11
	    if ((sp->n_type & N_TYPE) == N_FN || NEWSRC(X_db_getname(sp))) {
		sodiff = lndiff = -1UL;
		ln = 0;
		fname = NULL;
	    }

	    if (sp->n_type == N_SO) {
		if ((db_expr_t)sp->n_value <= off &&
		    (off - sp->n_value) < sodiff) {
			sodiff = off - sp->n_value;
			fname = X_db_getname(sp);
a305 2
		continue;
	    }
d307 2
a308 2
	    if (sp->n_type != N_SLINE)
		continue;
d310 2
a311 2
	    if ((db_expr_t)sp->n_value > off)
		break;
d313 4
a316 4
	    if (off - sp->n_value < lndiff) {
		lndiff = off - sp->n_value;
		ln = sp->n_desc;
	    }
d322 1
a322 1
		return TRUE;
d329 2
a330 2
X_db_sym_numargs(symtab, cursym, nargp, argnamep)
	db_symtab_t	symtab;
d335 4
a338 4
	register struct nlist	*sp, *ep;
	u_long			addr;
	int			maxnarg = *nargp, nargs = 0;
	char			*n_name;
d341 1
a341 1
		return FALSE;
d348 15
a362 13
	    if (sp->n_type == N_FUN && sp->n_value == addr) {
		while (++sp < ep && sp->n_type == N_PSYM) {
			if (nargs >= maxnarg)
				break;
			nargs++;
			n_name = X_db_getname(sp);
			*argnamep++ = n_name ? n_name : "???";
			{
			/* XXX - remove trailers */
			/* XXX - this could hose /dev/ksyms! */
			char *cp = *(argnamep-1);
			while (*cp != '\0' && *cp != ':') cp++;
			if (*cp == ':') *cp = '\0';
d364 2
a366 3
		*nargp = nargs;
		return TRUE;
	    }
d368 1
a368 1
	return FALSE;
d372 4
a375 3
X_db_stub_xh(sym, xh)
	db_symtab_t sym;
	struct exec *xh;
d377 2
a378 1
	extern char kernel_text[], etext[];
d380 29
a408 15
	bzero(xh, sizeof(*xh));
	N_SETMAGIC(*xh, ZMAGIC, MID_MACHINE, 0);
	xh->a_entry  = (u_long)kernel_text; /* XXX not right, but who cares? */
	xh->a_syms = *(int *)sym->private;
	xh->a_text = etext - kernel_text;
	xh->a_data = 0;
	if (sym->id != 0) {	/* lkm */
#ifdef LKM
		struct lkm_table *p;
		for (p = lkm_list(NULL);
		     p != NULL && p->sym_id != sym->id; p = lkm_list(p))
			;
		if (p != NULL) {
			xh->a_entry = (u_long)p->entry;
			xh->a_syms = p->sym_symsize;
a409 7
#ifdef DIAGNOSTIC
		else
			printf("X_db_stub_xh: no lkm for symtab (ghost?)\n");
#endif
#else
		panic("X_db_stub_xh: symtab w/o lkm itself");
#endif
d411 1
d414 2
a415 58
int
X_db_symtablen(sym)
	db_symtab_t sym;
{
	return sym->rend - sym->start;
}

int
X_db_symatoff(sym, off, buf, len)
	db_symtab_t sym;
	int off;
	void *buf;
	int *len;
{
	/* symtab */
	if (off < (sym->end - sym->start)) {
		struct nlist n;

		bcopy (&((struct nlist *)sym->start)[off / sizeof(n)],
		       &n, sizeof(n));
		*len = min(*len, sizeof(n) - off % sizeof(n));
		bcopy ((u_int8_t*)&n + off % sizeof(n), buf, *len);
	} else {
		/* strtab */
		off -= sym->end - sym->start;
		if (off < (sym->rend - sym->end)) {
			/* no preprocessing for string table */
			*len = min(*len, (sym->rend - sym->end - off));
			bcopy(sym->end + off, buf, *len);
		} else
			return -1;
	}

	return 0;
}

/*
 * Initialization routine for a.out files.
 */
void
ddb_init()
{
#ifndef SYMTAB_SPACE
	extern char	*esym;
	extern long	end;

	db_sym_init();

	if (esym > (char *)&end)
	    X_db_sym_init(&end, esym, "bsd");
#else
	db_sym_init();

	X_db_sym_init (db_symtab, 0, "bsd");
#endif
}

#endif	/* DB_NO_AOUT */
@


1.24
log
@s/vm_offset_t/vaddr_t/ s/vm_size_t/vsize_t/
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.23 1998/12/20 23:49:56 millert Exp $	*/
d89 5
@


1.24.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: db_aout.c,v 1.27 2001/02/10 20:40:03 millert Exp $	*/
/*	$NetBSD: db_aout.c,v 1.29 2000/07/07 21:55:18 jhawk Exp $	*/
d34 5
d46 1
a46 1
#ifdef	DB_AOUT_SYMBOLS
a49 24
boolean_t	db_aout_sym_init __P((int, void *, void *, const char *));
db_sym_t	db_aout_lookup __P((db_symtab_t *, char *));
db_sym_t	db_aout_search_symbol __P((db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *));
void		db_aout_symbol_values __P((db_symtab_t *, db_sym_t,
		    char **, db_expr_t *));
boolean_t	db_aout_line_at_pc __P((db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t));
boolean_t	db_aout_sym_numargs __P((db_symtab_t *, db_sym_t, int *,
		    char **));
void		db_aout_forall __P((db_symtab_t *,
		    db_forall_func_t db_forall_func, void *));

db_symformat_t db_symformat_aout = {
	"a.out",
	db_aout_sym_init,
	db_aout_lookup,
	db_aout_search_symbol,
	db_aout_symbol_values,
	db_aout_line_at_pc,
	db_aout_sym_numargs,
	db_aout_forall
};

d62 5
d70 4
a73 5
#define X_db_getname(t, s)	(s->n_un.n_strx ? t->end + s->n_un.n_strx : NULL)

/* XXX */
#ifndef ALIGNED_POINTER
#define ALIGNED_POINTER(p,t)        ((((u_long)(p)) & (sizeof(t)-1)) == 0)
d79 4
a82 5
boolean_t
db_aout_sym_init(symsize, vsymtab, vesymtab, name)
	int symsize;		/* size of symbol table */
	void *vsymtab;		/* pointer to start of symbol table */
	void *vesymtab;		/* pointer to end of string table,
d85 1
a85 1
	const char *name;
d88 1
a88 3
	struct nlist	*sp;
	int bad = 0;
	char *estrtab;
d90 4
a93 12
	/*
	 * XXX - ddb_init should take arguments.
	 *       Fixup the arguments.
	 */
	symsize = *(long *)vsymtab;
	vsymtab = (void *)((long *)vsymtab + 1);
	

	if (ALIGNED_POINTER(vsymtab, long) == 0) {
		printf("[ %s symbol table has bad start address %p ]\n",
		    name, vsymtab);
		return (FALSE);
d95 1
d101 2
a102 2
	sym_start = (struct nlist *)vsymtab;
	sym_end   = (struct nlist *)((char *)sym_start + symsize);
a104 5
	if (ALIGNED_POINTER(strtab, int) == 0) {
		printf("[ %s symbol table has bad string table address %p ]\n",
		    name, strtab);
		return (FALSE);
	}
d107 8
d118 1
a118 1
    (((vaddr_t)(x) + sizeof(vsize_t) - 1) & ~(sizeof(vsize_t) - 1))
d120 3
a122 3
	if (round_to_size(estrtab) != round_to_size(vesymtab)) {
		printf("[ %s a.out symbol table not valid ]\n", name);
		return (FALSE);
d126 1
a126 16
	for (sp = sym_start; sp < sym_end; sp++) {
		int strx;
		strx = sp->n_un.n_strx;
		if (strx != 0) {
			if (strx > slen) {
				printf("[ %s has bad a.out string table index "
				    "(0x%x) ]\n",
				    name, strx);
				bad = 1;
				continue;
			}
		}
	}

	if (bad)
		return (FALSE);
d129 5
a133 4
	    NULL) !=  -1) {
                printf("[ using %ld bytes of %s a.out symbol table ]\n",
                    (long)vesymtab - (long)vsymtab, name);
		return (TRUE);
d135 8
d144 9
a152 1
	return (FALSE);
d156 2
a157 2
db_aout_lookup(stab, symstr)
	db_symtab_t	*stab;
d160 1
a160 1
	struct nlist *sp, *ep;
d167 4
a170 5
		if ((n_name = X_db_getname(stab, sp)) == 0)
			continue;
		if ((sp->n_type & N_STAB) == 0 &&
		    db_eqname(n_name, symstr, '_'))
			return ((db_sym_t)sp);
d176 3
a178 2
db_aout_search_symbol(symtab, off, strategy, diffp)
	db_symtab_t *	symtab;
d183 3
a185 3
	unsigned int	diff = *diffp;
	struct nlist	*symp = 0;
	struct nlist	*sp, *ep;
d191 21
a211 21
		if ((sp->n_type & N_STAB) != 0 ||
		    (sp->n_type & N_TYPE) == N_FN)
			continue;
		if (X_db_getname(symtab, sp) == 0)
			continue;
		if (off >= sp->n_value) {
			if (off - sp->n_value < diff) {
				diff = off - sp->n_value;
				symp = sp;
				if (diff == 0 && ((strategy == DB_STGY_PROC &&
				    sp->n_type == (N_TEXT|N_EXT)) ||
				    (strategy == DB_STGY_ANY &&
				    (sp->n_type & N_EXT))))
					break;
			} else if (off - sp->n_value == diff) {
				if (symp == 0)
					symp = sp;
				else if ((symp->n_type & N_EXT) == 0 &&
				    (sp->n_type & N_EXT) != 0)
					symp = sp;	/* pick the ext. sym */
			}
d213 1
d216 4
a219 3
		*diffp = off;
	} else {
		*diffp = diff;
d228 1
a228 2
db_aout_symbol_values(symtab, sym, namep, valuep)
	db_symtab_t	*symtab;
d233 1
a233 1
	struct nlist *sp;
d235 2
a236 1
	sp = (struct nlist *)sym;
d238 1
a238 1
		*namep = X_db_getname(symtab, sp);
d240 1
a240 1
		*valuep = sp->n_value;
d245 2
a246 2
db_aout_line_at_pc(symtab, cursym, filename, linenum, off)
	db_symtab_t *	symtab;
d252 3
a254 3
	struct nlist	*sp, *ep;
	unsigned long	sodiff = -1UL, lndiff = -1UL, ln = 0;
	char		*fname = NULL;
d261 1
a261 1
    (str)[0] == 'g' && strcmp((str), "gcc_compiled.") == 0)
d265 4
a268 4
		/*
		 * Prevent bogus linenumbers in case module not compiled
		 * with debugging options
		 */
d270 2
a271 2
		if (sp->n_value <= off && (off - sp->n_value) <= sodiff &&
		    NEWSRC(X_db_getname(symtab, sp))) {
d273 11
a283 14
		if ((sp->n_type & N_TYPE) == N_FN ||
		    NEWSRC(X_db_getname(symtab, sp))) {
			sodiff = lndiff = -1UL;
			ln = 0;
			fname = NULL;
		}

		if (sp->n_type == N_SO) {
			if (sp->n_value <= off &&
			    (off - sp->n_value) < sodiff) {
				sodiff = off - sp->n_value;
				fname = X_db_getname(symtab, sp);
			}
			continue;
d285 2
d288 2
a289 2
		if (sp->n_type != N_SLINE)
			continue;
d291 2
a292 2
		if (sp->n_value > off)
			break;
d294 4
a297 4
		if (off - sp->n_value < lndiff) {
			lndiff = off - sp->n_value;
			ln = sp->n_desc;
		}
d303 1
a303 1
		return (TRUE);
d310 2
a311 2
db_aout_sym_numargs(symtab, cursym, nargp, argnamep)
	db_symtab_t *	symtab;
d316 4
a319 4
	struct nlist	*sp, *ep;
	u_long		addr;
	int		maxnarg = *nargp, nargs = 0;
	char		*n_name;
d322 1
a322 1
		return (FALSE);
d329 13
a341 15
		if (sp->n_type == N_FUN && sp->n_value == addr) {
			while (++sp < ep && sp->n_type == N_PSYM) {
				if (nargs >= maxnarg)
					break;
				nargs++;
				n_name = X_db_getname(symtab, sp);
				*argnamep++ = n_name ? n_name : "???";
				{
					/* XXX - remove trailers */
					char *cp = *(argnamep - 1);

					while (*cp != '\0' && *cp != ':')
						cp++;
					if (*cp == ':') *cp = '\0';
				}
a342 2
			*nargp = nargs;
			return (TRUE);
d344 3
d348 1
a348 1
	return (FALSE);
d352 3
a354 4
db_aout_forall(stab, db_forall_func, arg)
	db_symtab_t		*stab;
	db_forall_func_t	db_forall_func;
	void			*arg;
d356 1
a356 2
	static char suffix[2];
	struct nlist *sp, *ep;
d358 32
a389 2
	sp = (struct nlist *)stab->start;
	ep = (struct nlist *)stab->end;
d391 24
a414 27
	for (; sp < ep; sp++) {
		if (X_db_getname(stab, sp) == 0)
			continue;
		if ((sp->n_type & N_STAB) == 0) {
			suffix[1] = '\0';
			switch(sp->n_type & N_TYPE) {
			case N_ABS:
				suffix[0] = '@@';
				break;
			case N_TEXT:
				suffix[0] = '*';
				break;
			case N_DATA:
				suffix[0] = '+';
				break;
			case N_BSS:
				suffix[0] = '-';
				break;
			case N_FN:
				suffix[0] = '/';
				break;
			default:
				suffix[0] = '\0';
			}
			(*db_forall_func)(stab, (db_sym_t)sp,
			    X_db_getname(stab, sp), suffix, '_', arg);
		}
d416 23
a438 1
	return;
d441 1
a441 2
	
#endif	/* DB_AOUT_SYMBOLS */
@


1.24.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 12
a56 12
boolean_t	db_aout_sym_init(int, void *, void *, const char *);
db_sym_t	db_aout_lookup(db_symtab_t *, char *);
db_sym_t	db_aout_search_symbol(db_symtab_t *, db_addr_t,
		    db_strategy_t, db_expr_t *);
void		db_aout_symbol_values(db_symtab_t *, db_sym_t,
		    char **, db_expr_t *);
boolean_t	db_aout_line_at_pc(db_symtab_t *, db_sym_t,
		    char **, int *, db_expr_t);
boolean_t	db_aout_sym_numargs(db_symtab_t *, db_sym_t, int *,
		    char **);
void		db_aout_forall(db_symtab_t *,
		    db_forall_func_t db_forall_func, void *);
@


1.23
log
@The "end" symbol should be a long, not an int to make 64-bit machines happy.  This allows us to remove a bogus cast of int * to long * later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.22 1998/08/21 23:29:03 millert Exp $	*/
d118 1
a118 1
	(((vm_offset_t)(x) + sizeof(vm_size_t) - 1) & ~(sizeof(vm_size_t) - 1))
@


1.22
log
@Don't make symbols strings absolute in the symbol table so we can share it with /dev/ksyms
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.21 1997/07/19 22:31:15 niklas Exp $	*/
d428 1
a428 1
	extern int	end;
d432 2
a433 3
	if (esym > (char *)&end) {
	    X_db_sym_init((long *)&end, esym, "bsd");
	}
@


1.21
log
@Include vm/vm.h everywhere it is needed to get at boolean_t (I would prefer
to have it in sys/types.h but that is problematic).  Some KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.20 1997/07/08 20:20:31 niklas Exp $	*/
d67 8
a87 3
	struct nlist	*sp;
	char		*strtab;
	int		slen;
a88 1
	long		strx;
a127 12
	for (sp = sym_start; sp < sym_end; sp++) {
	    strx = sp->n_un.n_strx;
	    if (strx != 0) {
		if (strx > slen) {
		    db_printf("Bad string table index (%#x)\n", strx);
		    sp->n_un.n_name = 0;
		    continue;
		}
		sp->n_un.n_name = strtab + strx;
	    }
	}

d161 1
d167 1
a167 1
	    if (sp->n_un.n_name == 0)
d169 1
a169 4
	    if ((sp->n_type & N_STAB) == 0 &&
		sp->n_un.n_name != 0 &&
		db_eqname(sp->n_un.n_name, symstr, '_'))
	    {
a170 1
	    }
d191 1
a191 1
	    if (sp->n_un.n_name == 0)
d238 1
a238 1
	    *namep = sp->n_un.n_name;
d271 1
a271 1
		NEWSRC(sp->n_un.n_name)) {
d273 1
a273 1
	    if ((sp->n_type & N_TYPE) == N_FN || NEWSRC(sp->n_un.n_name)) { 
d283 1
a283 1
			fname = sp->n_un.n_name;
d319 1
d334 2
a335 1
			*argnamep++ = sp->n_un.n_name?sp->n_un.n_name:"???";
d338 1
a403 1
		n.n_un.n_strx = n.n_un.n_name - sym->end;
@


1.20
log
@remove register, move strx decl, and change it to long as it is meant to take
an addr which cannot fit in an int
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.19 1997/07/08 10:48:32 niklas Exp $	*/
d37 2
@


1.19
log
@Let the count of symbols be long, so the nlist array will get proper
alignment everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.18 1997/06/12 03:46:57 mickey Exp $	*/
d77 6
a82 5
	register struct nlist	*sym_start, *sym_end;
	register struct nlist	*sp;
	register char *strtab;
	register int slen;
	char *estrtab;
a122 1
	    register int strx;
@


1.18
log
@MI exec header
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.17 1997/05/29 03:55:06 mickey Exp $	*/
d71 1
a71 1
	int *symtab;		/* pointer to start of symbol table */
d440 1
a440 1
	    X_db_sym_init((int *)&end, esym, "bsd");
@


1.17
log
@correct case KERNFS && !LKM
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.16 1997/05/29 03:28:43 mickey Exp $	*/
d362 1
a362 1
	extern char kernel_text[];
d364 3
a366 1
	bcopy(kernel_text, xh, sizeof(*xh));
d368 1
d385 1
a385 1
		panic("X_db_stub_zh: symtab w/o lkm itself");
@


1.16
log
@futher support for kernfs......
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.15 1997/02/07 08:32:15 mickey Exp $	*/
d368 1
d380 3
@


1.15
log
@i hate militarists, pacifists either.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.14 1997/02/07 08:04:10 deraadt Exp $	*/
d34 3
a36 1
#include <sys/exec_aout.h>
d364 54
a417 4
	bzero(xh, sizeof(*xh));
	xh->a_midmag = htonl((((0 << 10) | MID_ZERO) << 16) | ZMAGIC);
	xh->a_syms   = *sym->private;
	xh->a_entry  = (u_long)kernel_text;
@


1.14
log
@Untested changes SUCK
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.13 1997/02/07 07:03:38 mickey Exp $	*/
a359 1
#if 0
a360 1
#endif
a364 1
#if 0
a365 1
#endif
@


1.13
log
@wrong private name
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.12 1997/02/07 06:18:44 mickey Exp $	*/
d360 1
d362 1
d367 1
d369 1
@


1.12
log
@necessary support for kernfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.11 1996/08/23 19:53:46 niklas Exp $	*/
d364 1
a364 1
	xh->a_syms   = *sym->rstart;
@


1.11
log
@signedness pedanetery
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.10 1996/08/16 10:12:35 mickey Exp $	*/
d34 1
d353 13
@


1.10
log
@record real symtab end.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.9 1996/08/13 00:41:33 niklas Exp $	*/
d202 1
a202 1
		if (off - sp->n_value < diff || diff < 0) {
d212 1
a212 1
		else if (off - sp->n_value == diff) {
d286 2
a287 1
		if (sp->n_value <= off && (off - sp->n_value) < sodiff) {
d297 1
a297 1
	    if (sp->n_value > off)
@


1.9
log
@Kludge to make DDB reverse symbol lookup work again.
I will soon deal with this mess in a 64-bit clean way which the
old code was anything but.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.6 1996/04/19 16:08:28 niklas Exp $	*/
d132 1
a132 1
	    (char *)symtab) !=  -1) {
@


1.8
log
@do dynamic symtab allocattion.
@
text
@d189 1
a189 1
	register unsigned int	diff = *diffp;
d202 1
a202 1
		if (off - sp->n_value < diff) {
@


1.7
log
@add advanced hang analyzer.
idea by theo.
@
text
@d142 1
a142 1
	db_symtab_t	*stab;
d149 1
a149 1
	db_symtab_t	*stab;
d160 1
a160 1
	db_symtab_t	*stab;
d183 1
a183 1
	db_symtab_t *	symtab;
d252 1
a252 1
	db_symtab_t *	symtab;
d316 1
a316 1
	db_symtab_t *	symtab;
d363 2
d369 2
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.5 1996/03/30 04:51:28 mickey Exp $	*/
d140 18
d241 2
a242 1
	sp = (struct nlist *)sym;
@


1.5
log
@Added: sysctl access to the ddb variables.
Fixed: "netbsd" strings in sym table handling routines.
now it is usefull to change max_{width,line} according
to your real console geometry, just w/ sysctl program.
@
text
@d1 2
a2 1
/*	$OpenBSD: db_aout.c,v 1.4 1996/03/11 11:15:57 mickey Exp $	*/
d43 1
a43 3
#define _AOUT_INCLUDE_
#include <nlist.h>
#include <stab.h>
@


1.4
log
@Debbuger changed towards the latest Mach.
Some minor changes for Linux ;) emulation.
Small bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.3 1996/02/20 13:35:31 mickey Exp $	*/
d346 1
a346 1
	    X_db_sym_init((int *)&end, esym, "netbsd");
d349 1
a349 1
	X_db_sym_init (db_symtab, 0, "netbsd");
@


1.3
log
@netbsd-current import & 'boot' cmd addition.
@
text
@d1 1
a1 1
/*	$OpenBSD: db_aout.c,v 1.13 1996/02/05 01:56:47 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1991,1990 Carnegie Mellon University
d14 1
a14 1
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
d25 2
a26 2
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
@


1.2
log
@kernel is called bsd
@
text
@d1 1
a1 1
/*	$NetBSD: db_aout.c,v 1.12 1994/10/09 08:19:31 mycroft Exp $	*/
d37 2
d67 1
d69 2
a70 2
	int *	symtab;		/* pointer to start of symbol table */
	char *	esymtab;	/* pointer to end of string table,
d73 1
a73 1
	char *	name;
d77 3
a79 3
	register char *	strtab;
	register int	strlen;
	char *		estrtab;
d96 1
a96 1
	strlen = *(int *)strtab;
d100 2
a101 2
		   *symtab, strlen);
	if ((*symtab + strlen) > db_symtabsize) {
d106 1
a106 1
	estrtab = strtab + strlen;
d123 1
a123 1
		if (strx > strlen) {
d189 4
a192 4
				(strategy == DB_STGY_PROC &&
					sp->n_type == (N_TEXT|N_EXT)   ||
				strategy == DB_STGY_ANY &&
					(sp->n_type & N_EXT)))
a240 1
	register struct nlist	*sym = (struct nlist *)cursym;
d338 1
d346 1
a346 1
	    X_db_sym_init((int *)&end, esym, "bsd");
d349 1
a349 1
	X_db_sym_init (db_symtab, 0, "bsd");
@


1.1
log
@Initial revision
@
text
@d343 1
a343 1
	    X_db_sym_init((int *)&end, esym, "netbsd");
d346 1
a346 1
	X_db_sym_init (db_symtab, 0, "netbsd");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
