head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.6
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.12
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.8
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.6
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.4
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.6
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.01.11.17.29.43;	author stefan;	state Exp;
branches;
next	1.30;
commitid	0DnIJziE802Uz234;

1.30
date	2015.08.29.01.58.39;	author guenther;	state Exp;
branches;
next	1.29;
commitid	tXJb6vLxru5vPZNh;

1.29
date	2015.08.12.06.19.25;	author mlarkin;	state Exp;
branches;
next	1.28;
commitid	laQtIfN3a82NKYjy;

1.28
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.27;
commitid	p4LJxGKbi0BU2cG6;

1.27
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.26;
commitid	C5iGb36LQxjM60Q3;

1.26
date	2014.12.22.02.55.48;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	faG8Njkacd0Q71Gh;

1.25
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	EF98ch02VpFassUi;

1.24
date	2014.06.11.20.31.15;	author matthew;	state Exp;
branches;
next	1.23;
commitid	HbZNzcr97Yc07mCW;

1.23
date	2013.10.17.08.02.19;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.03.31.17.03.25;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.23.16.02.33;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.08.17.59.23;	author gilles;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.12.18.09.24;	author martin;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.09.22.22.50;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.03.01.22.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.10.22.08.47;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.01.12.13.47;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.17.05.16.05;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.08.08.09.36;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.12.13.28.04;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.03.21.25.26;	author art;	state Exp;
branches;
next	1.5;

1.5
date	99.11.26.16.41.17;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.11.02.00.16.29;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.09.14.14.19.56;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.11.20.16.43.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.08.24.05.26.49;	author millert;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.23.01;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.40.10;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.03.28.12.29.44;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Use uiomove() instead of uiomovei(); from Martin Natano

ok kettenis@@
@
text
@/*	$OpenBSD: ksyms.c,v 1.30 2015/08/29 01:58:39 guenther Exp $	*/
/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@@courtesan.com>
 * Copyright (c) 2001 Artur Grabowski <art@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/exec.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/conf.h>
#include <sys/exec_elf.h>

extern char *esym;				/* end of symbol table */
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__) || \
    defined(__i386__)
extern char *ssym;				/* end of kernel */
#else
extern long end;				/* end of kernel */
#endif

static caddr_t ksym_head;
static caddr_t ksym_syms;
static size_t ksym_head_size;
static size_t ksym_syms_size;

void	ksymsattach(int);

/*
 * We assume __LDPGSZ is a multiple of PAGE_SIZE (it is)
 */

void
ksymsattach(int num)
{

#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__) || \
    defined(__i386__)
	if (esym <= ssym) {
		printf("/dev/ksyms: Symbol table not valid.\n");
		return;
	}
#else
	if (esym <= (char *)&end) {
		printf("/dev/ksyms: Symbol table not valid.\n");
		return;
	}
#endif

	do {
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__) || \
    defined(__i386__)
		caddr_t symtab = ssym;
#else
		caddr_t symtab = (caddr_t)&end;
#endif
		Elf_Ehdr *elf;
		Elf_Shdr *shdr;
		int i;

		elf = (Elf_Ehdr *)symtab;
		if (memcmp(elf->e_ident, ELFMAG, SELFMAG) != 0 ||
		    elf->e_ident[EI_CLASS] != ELFCLASS ||
		    elf->e_machine != ELF_TARG_MACH)
			break;

		shdr = (Elf_Shdr *)&symtab[elf->e_shoff];
		for (i = 0; i < elf->e_shnum; i++) {
			if (shdr[i].sh_type == SHT_SYMTAB) {
				break;
			}
		}

		/*
		 * No symbol table found.
		 */
		if (i == elf->e_shnum)
			break;

		/*
		 * No additional header.
		 */
		ksym_head_size = 0;
		ksym_syms = symtab;
		ksym_syms_size = (size_t)(esym - symtab);

		return;
	} while (0);
}

int
ksymsopen(dev_t dev, int flag, int mode, struct proc *p)
{

	/* There are no non-zero minor devices */
	if (minor(dev) != 0)
		return (ENXIO);

	/* This device is read-only */
	if ((flag & FWRITE))
		return (EPERM);

	/* ksym_syms must be initialized */
	if (ksym_syms == NULL)
		return (ENXIO);

	return (0);
}

int
ksymsclose(dev_t dev, int flag, int mode, struct proc *p)
{

	return (0);
}

int
ksymsread(dev_t dev, struct uio *uio, int flags)
{
	int error;
	size_t len;
	caddr_t v;
	size_t off;

	if (uio->uio_offset < 0)
		return (EINVAL);

	while (uio->uio_resid > 0) {
		if (uio->uio_offset >= ksym_head_size + ksym_syms_size)
			break;

		if (uio->uio_offset < ksym_head_size) {
			v = ksym_head + uio->uio_offset;
			len = ksym_head_size - uio->uio_offset;
		} else {
			off = uio->uio_offset - ksym_head_size;
			v = ksym_syms + off;
			len = ksym_syms_size - off;
		}

		if (len > uio->uio_resid)
			len = uio->uio_resid;

		if ((error = uiomove(v, len, uio)) != 0)
			return (error);
	}

	return (0);
}
@


1.30
log
@_NLIST_DO_ELF is no longer needed: it's the only option

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.29 2015/08/12 06:19:25 mlarkin Exp $	*/
d167 1
a167 1
		if ((error = uiomovei(v, len, uio)) != 0)
@


1.29
log
@
Use a linker script when building i386 kernels to allow section padding on
PAGE_SIZE boundaries. This is required to enforce proper separation of
sections when adding page protections (coming shortly).

This was in snaps before release with no reported side effects.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.28 2015/03/14 03:38:46 jsg Exp $	*/
a34 2

#ifdef _NLIST_DO_ELF
a35 1
#endif
a55 1
/*ARGSUSED*/
a72 1
#ifdef _NLIST_DO_ELF
a111 1
#endif
a113 1
/*ARGSUSED*/
a132 1
/*ARGSUSED*/
a139 1
/*ARGSUSED*/
@


1.28
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.27 2015/02/10 21:56:09 miod Exp $	*/
d41 2
a42 1
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__)
d64 2
a65 1
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__)
d79 2
a80 1
#if defined(__sparc64__) || defined(__mips__) || defined(__amd64__)
@


1.27
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.26 2014/12/22 02:55:48 deraadt Exp $	*/
a28 1
#include <sys/buf.h>
@


1.26
log
@amd64 now also uses the ssyms mechanism.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.25 2014/07/08 17:19:25 deraadt Exp $	*/
d174 1
a174 1
		if ((error = uiomove(v, len, uio)) != 0)
@


1.25
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.24 2014/06/11 20:31:15 matthew Exp $	*/
d42 1
a42 1
#if defined(__sparc64__) || defined(__mips__)
d64 1
a64 1
#if defined(__sparc64__) || defined(__mips__)
d78 1
a78 1
#if defined(__sparc64__) || defined(__mips__)
@


1.24
log
@Reject negative file offsets in /dev/ksyms.

ok deraadt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.23 2013/10/17 08:02:19 deraadt Exp $	*/
a35 2

#include <uvm/uvm_extern.h>
@


1.23
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.22 2013/03/31 17:03:25 deraadt Exp $	*/
d156 3
@


1.22
log
@do not need machine/cpu.h directly
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.21 2011/06/23 16:02:33 tedu Exp $	*/
a116 30
#endif

#ifdef _NLIST_DO_AOUT
	{
		/*
		 * a.out header.
		 * Fake up a struct exec.
		 * We only fill in the following non-zero entries:
		 *	a_text - fake text segment (struct exec only)
		 *	a_syms - size of symbol table
		 */
		caddr_t symtab = (char *)(&end + 1);
		struct exec *k1;

		ksym_head_size = __LDPGSZ;
		ksym_head = malloc(ksym_head_size, M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ksym_head == NULL) {
			printf("failed to allocate memory for /dev/ksyms\n");
			return;
		}

		k1 = (struct exec *)ksym_head;

		N_SETMAGIC(*k1, ZMAGIC, MID_MACHINE, 0);
		k1->a_text = __LDPGSZ;
		k1->a_syms = end;

		ksym_syms = symtab;
		ksym_syms_size = (size_t)(esym - symtab);
	}
@


1.21
log
@ansify a few files.  ok deraadt dlg krw matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.20 2010/12/26 15:41:00 miod Exp $	*/
a41 2

#include <machine/cpu.h>
@


1.20
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.19 2007/09/11 13:39:33 gilles Exp $	*/
d65 1
a65 2
ksymsattach(num)
	int num;
d154 1
a154 4
ksymsopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d174 1
a174 4
ksymsclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d182 1
a182 4
ksymsread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
a210 29

/* XXX - not yet */
#if 0
paddr_t
ksymsmmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
{
	vaddr_t va;
	paddr_t pa;

	if (off < 0)
		return (-1);
	if (off >= ksym_head_size + ksym_syms_size)
		return (-1);

	if ((vaddr_t)off < ksym_head_size) {
		va = (vaddr_t)ksym_head + off;
	} else {
		va = (vaddr_t)ksym_syms + off;
	}

	if (pmap_extract(pmap_kernel, va, &pa) == FALSE)
		panic("ksymsmmap: unmapped page");

	return (pa);
}
#endif
@


1.19
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.18 2007/09/08 17:59:23 gilles Exp $	*/
d247 1
a247 1
	return atop(pa);
@


1.18
log
@more M_ZERO changes

ok pyr@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.17 2006/07/12 18:09:24 martin Exp $	*/
d135 1
a135 1
		ksym_head = malloc(ksym_head_size, M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.17
log
@include uvm_extern.h for atop()
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.16 2004/08/09 22:22:50 pefo Exp $	*/
d135 1
a135 1
		ksym_head = malloc(ksym_head_size, M_DEVBUF, M_NOWAIT);
a139 1
		bzero(ksym_head, ksym_head_size);
@


1.16
log
@mips/sgi uses same symbol table style setup as sparc64
OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.15 2004/01/09 21:32:23 brad Exp $	*/
d36 2
@


1.15
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.14 2003/06/03 01:22:55 millert Exp $	*/
d44 1
a44 1
#ifdef __sparc64__
d67 1
a67 1
#ifdef __sparc64__
d81 1
a81 1
#ifdef __sparc64__
@


1.14
log
@Convert to 2 term license; OK with art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.13 2002/07/10 22:08:47 mickey Exp $	*/
a41 2

#include <uvm/uvm_extern.h>
@


1.13
log
@proper cdev_decl(ksyms), fix ksyms's broken functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.12 2002/03/14 01:26:52 millert Exp $	*/
a14 2
 * 3. The name of the authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.11 2001/11/06 19:53:18 miod Exp $	*/
d37 1
a59 3
int	ksymsopen(dev_t, int, int);
int	ksymsclose(dev_t, int, int);
int	ksymsread(dev_t, struct uio *, int);
d158 1
a158 1
ksymsopen(dev, flag, mode)
d161 1
d181 1
a181 1
ksymsclose(dev, flag, mode)
d184 1
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.10 2001/11/01 12:13:47 art Exp $	*/
d58 4
a61 4
void	ksymsattach __P((int));
int	ksymsopen __P((dev_t, int, int));
int	ksymsclose __P((dev_t, int, int));
int	ksymsread __P((dev_t, struct uio *, int));
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.11 2001/11/06 19:53:18 miod Exp $	*/
d58 4
a61 4
void	ksymsattach(int);
int	ksymsopen(dev_t, int, int);
int	ksymsclose(dev_t, int, int);
int	ksymsread(dev_t, struct uio *, int);
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.11.2.1 2002/06/11 03:42:15 art Exp $	*/
a36 1
#include <sys/conf.h>
d59 3
d160 1
a160 1
ksymsopen(dev, flag, mode, p)
a162 1
	struct proc *p;
d182 1
a182 1
ksymsclose(dev, flag, mode, p)
a184 1
	struct proc *p;
@


1.10
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.9 2001/09/17 05:16:05 jason Exp $	*/
d44 1
a44 1
#include <vm/vm.h>
@


1.9
log
@make ksyms work on sparc64 (requires essentially same goop as db_sym)
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.8 2001/06/08 08:09:36 art Exp $	*/
d227 1
a227 1
int
d230 2
a231 1
	int off, prot;
@


1.8
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.7 2001/02/12 13:28:04 art Exp $	*/
d47 3
d51 1
d73 6
d83 1
d87 3
d91 1
d106 1
a106 1
  			}
@


1.7
log
@Remove debuging printf left by accident.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.6 2001/02/03 21:25:26 art Exp $	*/
d231 2
a232 2
	if ((pa = pmap_extract(pmap_kernel, va)) == 0)
		panic("ksymsmmap: null pa");
@


1.6
log
@Violent cleanup of the code. Lots of effort duplication removed.
Don't look into the headers in read, just build the headers in attach and
ignore them.
mmap should now work (when boot loaders are fixed to align the tables).
Support for ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a99 1
		printf("symbols at: %p\n", symtab);
@


1.5
log
@Another comment change. (NBPG -> PAGE_SIZE).
@
text
@d1 1
d4 1
d15 1
a15 1
 * 3. The name of the author may not be used to endorse or promote products
d21 1
a21 1
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
a29 7
/*
 * kernel symbols special file (masquerades as a ZMAGIC a.out file)
 *
 * TODO: get boot loaders to put symbols on a page boundary so we
 *       can mmap them too (also requires minor change to db_aout.c).
 */

d38 4
d49 4
a52 2
static struct exec *k1;				/* first page of /dev/ksyms */
static caddr_t symtab = (caddr_t)(&end + 1);	/* start of symbol table */
d59 4
d69 32
a100 1
	if (esym > (char *)&end) {
d102 15
a116 1
		 * If we have a symbol table, fake up a struct exec.
a119 2
		 *
		 * We assume __LDPGSZ is a multiple of PAGE_SIZE (it is)
d121 13
a133 2
		k1 = (struct exec *)malloc(__LDPGSZ, M_TEMP, M_WAITOK);
		bzero(k1, __LDPGSZ);
d137 3
d141 1
a141 1
	return;
d158 3
a160 3
		
	/* Must have symbols at the end of the kernel to work */
	if (esym <= (char *)&end)
d183 4
a186 13
	register vaddr_t v;
	register size_t c, len;
	int error = 0;

#define iov	(uio->uio_iov)
	while (uio->uio_resid > 0 && error == 0) {
		/* Done with this iov?  Fill the next one... */
		if (iov->iov_len == 0) {
			uio->uio_iov++;
			uio->uio_iovcnt--;
			if (uio->uio_iovcnt < 0)
				panic("ksymread");
		}
d188 2
a189 2
		/* Can't read past size of symbol table... */
		if (uio->uio_offset >= (vaddr_t)(esym - symtab) + k1->a_text)
d192 3
a194 16
		if (uio->uio_offset < k1->a_text) {
			/*
			 * If they asked for more that a_text,
			 * read the part of k1 first, then the
			 * part of symtab next time throug the loop.
			 */
			if (iov->iov_len + (size_t)uio->uio_offset >
			    k1->a_text)
				len = k1->a_text;
			else
				len = iov->iov_len;

			/* Make offset relative to struct exec */
			v = uio->uio_offset + (vaddr_t)k1;
			c = min(len, MAXPHYS);
			error = uiomove((caddr_t)v, c, uio);
d196 3
a198 8
			/* Make offset relative to symtab */
			v = uio->uio_offset - k1->a_text + (vaddr_t)symtab;
			c = min(iov->iov_len, MAXPHYS);

			/* Don't read past esym, truncate. */
			if (v + c > (vaddr_t)esym)
				c = (vaddr_t)esym - v;
			error = uiomove((caddr_t)v, c, uio);
d200 6
d207 2
a208 1
	return (error);
d211 1
a211 1
/* XXX - can't do mmap until boot loaders make the symbol table page aligned */
d218 3
a220 1
#define ksyms_btop(x)	((vaddr_t)(x) >> PGSHIFT
d223 1
a223 1
	if ((unsigned)off >= (unsigned)(esym - symtab) + k1->a_text)
d226 10
a235 4
	if ((unsigned)off < k1->a_text)
		return (ksyms_btop(off + (unsigned)k1));
	else
		return (ksyms_btop(off + (unsigned)symtab - k1->a_text));
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: ksyms.c,v 1.7 2001/02/12 13:28:04 art Exp $	*/
a2 1
 * Copyright (c) 2001 Artur Grabowski <art@@openbsd.org>
d13 1
a13 1
 * 3. The name of the authors may not be used to endorse or promote products
d19 1
a19 1
 * THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
d28 7
a42 4
#ifdef _NLIST_DO_ELF
#include <sys/exec_elf.h>
#endif

d50 2
a51 4
static caddr_t ksym_head;
static caddr_t ksym_syms;
static size_t ksym_head_size;
static size_t ksym_syms_size;
a57 4
/*
 * We assume __LDPGSZ is a multiple of PAGE_SIZE (it is)
 */

d64 1
a64 31
	if (esym <= (char *)&end) {
		printf("/dev/ksyms: Symbol table not valid.\n");
		return;
	}

#ifdef _NLIST_DO_ELF
	do {
		caddr_t symtab = (caddr_t)&end;
		Elf_Ehdr *elf;
		Elf_Shdr *shdr;
		int i;

		elf = (Elf_Ehdr *)symtab;
		if (memcmp(elf->e_ident, ELFMAG, SELFMAG) != 0 ||
		    elf->e_ident[EI_CLASS] != ELFCLASS ||
		    elf->e_machine != ELF_TARG_MACH)
			break;

		shdr = (Elf_Shdr *)&symtab[elf->e_shoff];
		for (i = 0; i < elf->e_shnum; i++) {
			if (shdr[i].sh_type == SHT_SYMTAB) {
				break;
  			}
		}

		/*
		 * No symbol table found.
		 */
		if (i == elf->e_shnum)
			break;

d66 1
a66 15
		 * No additional header.
		 */
		ksym_head_size = 0;
		ksym_syms = symtab;
		ksym_syms_size = (size_t)(esym - symtab);

		return;
	} while (0);
#endif

#ifdef _NLIST_DO_AOUT
	{
		/*
		 * a.out header.
		 * Fake up a struct exec.
d70 2
d73 2
a74 13
		caddr_t symtab = (char *)(&end + 1);
		struct exec *k1;

		ksym_head_size = __LDPGSZ;
		ksym_head = malloc(ksym_head_size, M_DEVBUF, M_NOWAIT);
		if (ksym_head == NULL) {
			printf("failed to allocate memory for /dev/ksyms\n");
			return;
		}
		bzero(ksym_head, ksym_head_size);

		k1 = (struct exec *)ksym_head;

a77 3

		ksym_syms = symtab;
		ksym_syms_size = (size_t)(esym - symtab);
d79 1
a79 1
#endif
d96 3
a98 3

	/* ksym_syms must be initialized */
	if (ksym_syms == NULL)
d121 13
a133 4
	int error;
	size_t len;
	caddr_t v;
	size_t off;
d135 2
a136 2
	while (uio->uio_resid > 0) {
		if (uio->uio_offset >= ksym_head_size + ksym_syms_size)
d139 16
a154 3
		if (uio->uio_offset < ksym_head_size) {
			v = ksym_head + uio->uio_offset;
			len = ksym_head_size - uio->uio_offset;
d156 8
a163 3
			off = uio->uio_offset - ksym_head_size;
			v = ksym_syms + off;
			len = ksym_syms_size - off;
a164 6

		if (len > uio->uio_resid)
			len = uio->uio_resid;

		if ((error = uiomove(v, len, uio)) != 0)
			return (error);
d166 1
a166 2

	return (0);
d169 1
a169 1
/* XXX - not yet */
d176 1
a176 3
	vaddr_t va;
	paddr_t pa;

d179 1
a179 1
	if (off >= ksym_head_size + ksym_syms_size)
d182 4
a185 10
	if ((vaddr_t)off < ksym_head_size) {
		va = (vaddr_t)ksym_head + off;
	} else {
		va = (vaddr_t)ksym_syms + off;
	}

	if ((pa = pmap_extract(pmap_kernel, va)) == 0)
		panic("ksymsmmap: null pa");

	return atop(pa);
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.5.2.1 2001/05/14 22:23:01 niklas Exp $	*/
d231 2
a232 2
	if (pmap_extract(pmap_kernel, va, &pa) == FALSE)
		panic("ksymsmmap: unmapped page");
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.5.2.2 2001/07/04 10:40:10 niklas Exp $	*/
a46 3
#ifdef __sparc64__
extern char *ssym;				/* end of kernel */
#else
a47 1
#endif
a68 6
#ifdef __sparc64__
	if (esym <= ssym) {
		printf("/dev/ksyms: Symbol table not valid.\n");
		return;
	}
#else
a72 1
#endif
a75 3
#ifdef __sparc64__
		caddr_t symtab = ssym;
#else
a76 1
#endif
d91 1
a91 1
			}
@


1.5.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#include <uvm/uvm_extern.h>
d227 1
a227 1
paddr_t
d230 1
a230 2
	off_t off;
	int prot;
@


1.5.2.5
log
@Merge in -current from about a week ago
@
text
@d58 4
a61 4
void	ksymsattach(int);
int	ksymsopen(dev_t, int, int);
int	ksymsclose(dev_t, int, int);
int	ksymsread(dev_t, struct uio *, int);
@


1.5.2.6
log
@Sync the SMP branch with 3.3
@
text
@a36 1
#include <sys/conf.h>
d59 3
d160 1
a160 1
ksymsopen(dev, flag, mode, p)
a162 1
	struct proc *p;
d182 1
a182 1
ksymsclose(dev, flag, mode, p)
a184 1
	struct proc *p;
@


1.5.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ksyms.c,v 1.5.2.6 2003/03/28 00:38:09 niklas Exp $	*/
d15 2
@


1.5.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 2
@


1.4
log
@Fix comment typo.
@
text
@d71 1
a71 1
		 * We assume __LDPGSZ is a multiple of NBPG (it is)
@


1.3
log
@vaddr_t/vsize_t
@
text
@d68 1
a68 1
		 *	a_text - fake text sement (struct exec only)
@


1.2
log
@careful with mmap off
@
text
@d121 1
a121 1
	register vm_offset_t v;
d136 1
a136 2
		if (uio->uio_offset >= (vm_offset_t)(esym - symtab) +
		    k1->a_text)
d152 1
a152 1
			v = uio->uio_offset + (vm_offset_t)k1;
d157 1
a157 2
			v = uio->uio_offset - k1->a_text +
			    (vm_offset_t)symtab;
d161 2
a162 2
			if (v + c > (vm_offset_t)esym)
				c = (vm_offset_t)esym - v;
d176 1
a176 1
#define ksyms_btop(x)	((vm_offset_t)(x) >> PGSHIFT
@


1.1
log
@/dev/ksyms; kernel symbols pseudo-device that masquerades as an a.out binary for ports that copy the symbol table to the end of kernel space (all that use DDB do this)
@
text
@d179 2
@

