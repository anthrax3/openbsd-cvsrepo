head	1.18;
access;
symbols
	OPENBSD_6_2:1.18.0.12
	OPENBSD_6_2_BASE:1.18
	OPENBSD_6_1:1.18.0.10
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.6
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.14.0.32
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.30
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.28
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.24
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.22
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.20
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.18
	OPENBSD_5_0:1.14.0.16
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.14
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.12
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.8
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.8
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.6
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.4
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.17;
commitid	EA6IpjJSgQH2WTCf;

1.17
date	2015.06.04.06.03.11;	author jsg;	state Exp;
branches;
next	1.16;
commitid	CwwbDt9ODByGv84R;

1.16
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.15;
commitid	RaOGL5SyOGOZylwx;

1.15
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2007.10.23.19.54.36;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.17.08.35.33;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.14.01.24.20;	author pascoe;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.23.23.59.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.27.00.23.43;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.06.02.34.57;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.31.04.14.00;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.01.01.54.43;	author aaron;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.05.01.01.49.48;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.20.21.44.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.10.28.18.01.01;	author downsj;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	98.04.26.21.03.10;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.11.07.08.06.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.4.6.1
date	2001.05.14.22.23.02;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.07.04.10.40.11;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.4.6.5;

1.4.6.5
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.4.6.6;

1.4.6.6
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@/*	$OpenBSD: mulaw.c,v 1.17 2015/06/04 06:03:11 jsg Exp $ */
/*	$NetBSD: mulaw.c,v 1.15 2001/01/18 20:28:20 jdolecek Exp $	*/

/*
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <dev/mulaw.h>

/*
 * This table converts a (8 bit) mu-law value two a 16 bit value.
 * The 16 bits are represented as an array of two bytes for easier access
 * to the individual bytes.
 */
static const u_char mulawtolin16[256][2] = {
	{0x02,0x84}, {0x06,0x84}, {0x0a,0x84}, {0x0e,0x84},
	{0x12,0x84}, {0x16,0x84}, {0x1a,0x84}, {0x1e,0x84},
	{0x22,0x84}, {0x26,0x84}, {0x2a,0x84}, {0x2e,0x84},
	{0x32,0x84}, {0x36,0x84}, {0x3a,0x84}, {0x3e,0x84},
	{0x41,0x84}, {0x43,0x84}, {0x45,0x84}, {0x47,0x84},
	{0x49,0x84}, {0x4b,0x84}, {0x4d,0x84}, {0x4f,0x84},
	{0x51,0x84}, {0x53,0x84}, {0x55,0x84}, {0x57,0x84},
	{0x59,0x84}, {0x5b,0x84}, {0x5d,0x84}, {0x5f,0x84},
	{0x61,0x04}, {0x62,0x04}, {0x63,0x04}, {0x64,0x04},
	{0x65,0x04}, {0x66,0x04}, {0x67,0x04}, {0x68,0x04},
	{0x69,0x04}, {0x6a,0x04}, {0x6b,0x04}, {0x6c,0x04},
	{0x6d,0x04}, {0x6e,0x04}, {0x6f,0x04}, {0x70,0x04},
	{0x70,0xc4}, {0x71,0x44}, {0x71,0xc4}, {0x72,0x44},
	{0x72,0xc4}, {0x73,0x44}, {0x73,0xc4}, {0x74,0x44},
	{0x74,0xc4}, {0x75,0x44}, {0x75,0xc4}, {0x76,0x44},
	{0x76,0xc4}, {0x77,0x44}, {0x77,0xc4}, {0x78,0x44},
	{0x78,0xa4}, {0x78,0xe4}, {0x79,0x24}, {0x79,0x64},
	{0x79,0xa4}, {0x79,0xe4}, {0x7a,0x24}, {0x7a,0x64},
	{0x7a,0xa4}, {0x7a,0xe4}, {0x7b,0x24}, {0x7b,0x64},
	{0x7b,0xa4}, {0x7b,0xe4}, {0x7c,0x24}, {0x7c,0x64},
	{0x7c,0x94}, {0x7c,0xb4}, {0x7c,0xd4}, {0x7c,0xf4},
	{0x7d,0x14}, {0x7d,0x34}, {0x7d,0x54}, {0x7d,0x74},
	{0x7d,0x94}, {0x7d,0xb4}, {0x7d,0xd4}, {0x7d,0xf4},
	{0x7e,0x14}, {0x7e,0x34}, {0x7e,0x54}, {0x7e,0x74},
	{0x7e,0x8c}, {0x7e,0x9c}, {0x7e,0xac}, {0x7e,0xbc},
	{0x7e,0xcc}, {0x7e,0xdc}, {0x7e,0xec}, {0x7e,0xfc},
	{0x7f,0x0c}, {0x7f,0x1c}, {0x7f,0x2c}, {0x7f,0x3c},
	{0x7f,0x4c}, {0x7f,0x5c}, {0x7f,0x6c}, {0x7f,0x7c},
	{0x7f,0x88}, {0x7f,0x90}, {0x7f,0x98}, {0x7f,0xa0},
	{0x7f,0xa8}, {0x7f,0xb0}, {0x7f,0xb8}, {0x7f,0xc0},
	{0x7f,0xc8}, {0x7f,0xd0}, {0x7f,0xd8}, {0x7f,0xe0},
	{0x7f,0xe8}, {0x7f,0xf0}, {0x7f,0xf8}, {0x80,0x00},
	{0xfd,0x7c}, {0xf9,0x7c}, {0xf5,0x7c}, {0xf1,0x7c},
	{0xed,0x7c}, {0xe9,0x7c}, {0xe5,0x7c}, {0xe1,0x7c},
	{0xdd,0x7c}, {0xd9,0x7c}, {0xd5,0x7c}, {0xd1,0x7c},
	{0xcd,0x7c}, {0xc9,0x7c}, {0xc5,0x7c}, {0xc1,0x7c},
	{0xbe,0x7c}, {0xbc,0x7c}, {0xba,0x7c}, {0xb8,0x7c},
	{0xb6,0x7c}, {0xb4,0x7c}, {0xb2,0x7c}, {0xb0,0x7c},
	{0xae,0x7c}, {0xac,0x7c}, {0xaa,0x7c}, {0xa8,0x7c},
	{0xa6,0x7c}, {0xa4,0x7c}, {0xa2,0x7c}, {0xa0,0x7c},
	{0x9e,0xfc}, {0x9d,0xfc}, {0x9c,0xfc}, {0x9b,0xfc},
	{0x9a,0xfc}, {0x99,0xfc}, {0x98,0xfc}, {0x97,0xfc},
	{0x96,0xfc}, {0x95,0xfc}, {0x94,0xfc}, {0x93,0xfc},
	{0x92,0xfc}, {0x91,0xfc}, {0x90,0xfc}, {0x8f,0xfc},
	{0x8f,0x3c}, {0x8e,0xbc}, {0x8e,0x3c}, {0x8d,0xbc},
	{0x8d,0x3c}, {0x8c,0xbc}, {0x8c,0x3c}, {0x8b,0xbc},
	{0x8b,0x3c}, {0x8a,0xbc}, {0x8a,0x3c}, {0x89,0xbc},
	{0x89,0x3c}, {0x88,0xbc}, {0x88,0x3c}, {0x87,0xbc},
	{0x87,0x5c}, {0x87,0x1c}, {0x86,0xdc}, {0x86,0x9c},
	{0x86,0x5c}, {0x86,0x1c}, {0x85,0xdc}, {0x85,0x9c},
	{0x85,0x5c}, {0x85,0x1c}, {0x84,0xdc}, {0x84,0x9c},
	{0x84,0x5c}, {0x84,0x1c}, {0x83,0xdc}, {0x83,0x9c},
	{0x83,0x6c}, {0x83,0x4c}, {0x83,0x2c}, {0x83,0x0c},
	{0x82,0xec}, {0x82,0xcc}, {0x82,0xac}, {0x82,0x8c},
	{0x82,0x6c}, {0x82,0x4c}, {0x82,0x2c}, {0x82,0x0c},
	{0x81,0xec}, {0x81,0xcc}, {0x81,0xac}, {0x81,0x8c},
	{0x81,0x74}, {0x81,0x64}, {0x81,0x54}, {0x81,0x44},
	{0x81,0x34}, {0x81,0x24}, {0x81,0x14}, {0x81,0x04},
	{0x80,0xf4}, {0x80,0xe4}, {0x80,0xd4}, {0x80,0xc4},
	{0x80,0xb4}, {0x80,0xa4}, {0x80,0x94}, {0x80,0x84},
	{0x80,0x78}, {0x80,0x70}, {0x80,0x68}, {0x80,0x60},
	{0x80,0x58}, {0x80,0x50}, {0x80,0x48}, {0x80,0x40},
	{0x80,0x38}, {0x80,0x30}, {0x80,0x28}, {0x80,0x20},
	{0x80,0x18}, {0x80,0x10}, {0x80,0x08}, {0x80,0x00},
};

static const u_char lintomulaw[256] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
	0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,
	0x03, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05,
	0x05, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07,
	0x07, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09,
	0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
	0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d, 0x0d,
	0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f,
	0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13,
	0x13, 0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17,
	0x17, 0x18, 0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b,
	0x1b, 0x1c, 0x1c, 0x1d, 0x1d, 0x1e, 0x1e, 0x1f,
	0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
	0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
	0x2f, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c,
	0x3e, 0x41, 0x45, 0x49, 0x4d, 0x53, 0x5b, 0x67,
	0xff, 0xe7, 0xdb, 0xd3, 0xcd, 0xc9, 0xc5, 0xc1,
	0xbe, 0xbc, 0xba, 0xb8, 0xb6, 0xb4, 0xb2, 0xb0,
	0xaf, 0xae, 0xad, 0xac, 0xab, 0xaa, 0xa9, 0xa8,
	0xa7, 0xa6, 0xa5, 0xa4, 0xa3, 0xa2, 0xa1, 0xa0,
	0x9f, 0x9f, 0x9e, 0x9e, 0x9d, 0x9d, 0x9c, 0x9c,
	0x9b, 0x9b, 0x9a, 0x9a, 0x99, 0x99, 0x98, 0x98,
	0x97, 0x97, 0x96, 0x96, 0x95, 0x95, 0x94, 0x94,
	0x93, 0x93, 0x92, 0x92, 0x91, 0x91, 0x90, 0x90,
	0x8f, 0x8f, 0x8f, 0x8f, 0x8e, 0x8e, 0x8e, 0x8e,
	0x8d, 0x8d, 0x8d, 0x8d, 0x8c, 0x8c, 0x8c, 0x8c,
	0x8b, 0x8b, 0x8b, 0x8b, 0x8a, 0x8a, 0x8a, 0x8a,
	0x89, 0x89, 0x89, 0x89, 0x88, 0x88, 0x88, 0x88,
	0x87, 0x87, 0x87, 0x87, 0x86, 0x86, 0x86, 0x86,
	0x85, 0x85, 0x85, 0x85, 0x84, 0x84, 0x84, 0x84,
	0x83, 0x83, 0x83, 0x83, 0x82, 0x82, 0x82, 0x82,
	0x81, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x80,
};

void
mulaw_to_slinear8(u_char *p, int cc)
{
	/* Use the 16 bit table for 8 bits too. */
	while (--cc >= 0) {
		*p = mulawtolin16[*p][0] ^ 0x80;
		++p;
	}
}

void
slinear8_to_mulaw(u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintomulaw[*p ^ 0x80];
		++p;
	}
}

void
mulaw24_to_slinear24(u_char *p, int cc)
{
	int s, *q = (int *)p;

	while ((cc -= 4) >= 0) {
		s = (*q >> 16) & 0xff;
		*q = (int)((signed char)mulawtolin16[s][0] ^ 0x80) << 16 |
		    (u_int)mulawtolin16[s][1] << 8;
		q++;
	}
}

void
slinear24_to_mulaw24(u_char *p, int cc)
{
	u_int *q = (u_int *)p;

	while ((cc -= 4) >= 0) {
		*q = lintomulaw[((*q >> 16) & 0xff) ^ 0x80] << 16;
		q++;
	}
}
@


1.17
log
@remove the now unused alawtolin16 table
ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.16 2015/05/11 06:46:21 ratchov Exp $ */
d149 1
a149 1
mulaw_to_slinear8(void *v, u_char *p, int cc)
d159 1
a159 1
slinear8_to_mulaw(void *v, u_char *p, int cc)
d168 1
a168 1
mulaw24_to_slinear24(void *v, u_char *p, int cc)
d181 1
a181 1
slinear24_to_mulaw24(void *v, u_char *p, int cc)
@


1.16
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.15 2015/03/14 03:38:46 jsg Exp $ */
a145 67
};

static const u_char alawtolin16[256][2] = {
	{0x6a,0x80}, {0x6b,0x80}, {0x68,0x80}, {0x69,0x80},
	{0x6e,0x80}, {0x6f,0x80}, {0x6c,0x80}, {0x6d,0x80},
	{0x62,0x80}, {0x63,0x80}, {0x60,0x80}, {0x61,0x80},
	{0x66,0x80}, {0x67,0x80}, {0x64,0x80}, {0x65,0x80},
	{0x75,0x40}, {0x75,0xc0}, {0x74,0x40}, {0x74,0xc0},
	{0x77,0x40}, {0x77,0xc0}, {0x76,0x40}, {0x76,0xc0},
	{0x71,0x40}, {0x71,0xc0}, {0x70,0x40}, {0x70,0xc0},
	{0x73,0x40}, {0x73,0xc0}, {0x72,0x40}, {0x72,0xc0},
	{0x2a,0x00}, {0x2e,0x00}, {0x22,0x00}, {0x26,0x00},
	{0x3a,0x00}, {0x3e,0x00}, {0x32,0x00}, {0x36,0x00},
	{0x0a,0x00}, {0x0e,0x00}, {0x02,0x00}, {0x06,0x00},
	{0x1a,0x00}, {0x1e,0x00}, {0x12,0x00}, {0x16,0x00},
	{0x55,0x00}, {0x57,0x00}, {0x51,0x00}, {0x53,0x00},
	{0x5d,0x00}, {0x5f,0x00}, {0x59,0x00}, {0x5b,0x00},
	{0x45,0x00}, {0x47,0x00}, {0x41,0x00}, {0x43,0x00},
	{0x4d,0x00}, {0x4f,0x00}, {0x49,0x00}, {0x4b,0x00},
	{0x7e,0xa8}, {0x7e,0xb8}, {0x7e,0x88}, {0x7e,0x98},
	{0x7e,0xe8}, {0x7e,0xf8}, {0x7e,0xc8}, {0x7e,0xd8},
	{0x7e,0x28}, {0x7e,0x38}, {0x7e,0x08}, {0x7e,0x18},
	{0x7e,0x68}, {0x7e,0x78}, {0x7e,0x48}, {0x7e,0x58},
	{0x7f,0xa8}, {0x7f,0xb8}, {0x7f,0x88}, {0x7f,0x98},
	{0x7f,0xe8}, {0x7f,0xf8}, {0x7f,0xc8}, {0x7f,0xd8},
	{0x7f,0x28}, {0x7f,0x38}, {0x7f,0x08}, {0x7f,0x18},
	{0x7f,0x68}, {0x7f,0x78}, {0x7f,0x48}, {0x7f,0x58},
	{0x7a,0xa0}, {0x7a,0xe0}, {0x7a,0x20}, {0x7a,0x60},
	{0x7b,0xa0}, {0x7b,0xe0}, {0x7b,0x20}, {0x7b,0x60},
	{0x78,0xa0}, {0x78,0xe0}, {0x78,0x20}, {0x78,0x60},
	{0x79,0xa0}, {0x79,0xe0}, {0x79,0x20}, {0x79,0x60},
	{0x7d,0x50}, {0x7d,0x70}, {0x7d,0x10}, {0x7d,0x30},
	{0x7d,0xd0}, {0x7d,0xf0}, {0x7d,0x90}, {0x7d,0xb0},
	{0x7c,0x50}, {0x7c,0x70}, {0x7c,0x10}, {0x7c,0x30},
	{0x7c,0xd0}, {0x7c,0xf0}, {0x7c,0x90}, {0x7c,0xb0},
	{0x95,0x80}, {0x94,0x80}, {0x97,0x80}, {0x96,0x80},
	{0x91,0x80}, {0x90,0x80}, {0x93,0x80}, {0x92,0x80},
	{0x9d,0x80}, {0x9c,0x80}, {0x9f,0x80}, {0x9e,0x80},
	{0x99,0x80}, {0x98,0x80}, {0x9b,0x80}, {0x9a,0x80},
	{0x8a,0xc0}, {0x8a,0x40}, {0x8b,0xc0}, {0x8b,0x40},
	{0x88,0xc0}, {0x88,0x40}, {0x89,0xc0}, {0x89,0x40},
	{0x8e,0xc0}, {0x8e,0x40}, {0x8f,0xc0}, {0x8f,0x40},
	{0x8c,0xc0}, {0x8c,0x40}, {0x8d,0xc0}, {0x8d,0x40},
	{0xd6,0x00}, {0xd2,0x00}, {0xde,0x00}, {0xda,0x00},
	{0xc6,0x00}, {0xc2,0x00}, {0xce,0x00}, {0xca,0x00},
	{0xf6,0x00}, {0xf2,0x00}, {0xfe,0x00}, {0xfa,0x00},
	{0xe6,0x00}, {0xe2,0x00}, {0xee,0x00}, {0xea,0x00},
	{0xab,0x00}, {0xa9,0x00}, {0xaf,0x00}, {0xad,0x00},
	{0xa3,0x00}, {0xa1,0x00}, {0xa7,0x00}, {0xa5,0x00},
	{0xbb,0x00}, {0xb9,0x00}, {0xbf,0x00}, {0xbd,0x00},
	{0xb3,0x00}, {0xb1,0x00}, {0xb7,0x00}, {0xb5,0x00},
	{0x81,0x58}, {0x81,0x48}, {0x81,0x78}, {0x81,0x68},
	{0x81,0x18}, {0x81,0x08}, {0x81,0x38}, {0x81,0x28},
	{0x81,0xd8}, {0x81,0xc8}, {0x81,0xf8}, {0x81,0xe8},
	{0x81,0x98}, {0x81,0x88}, {0x81,0xb8}, {0x81,0xa8},
	{0x80,0x58}, {0x80,0x48}, {0x80,0x78}, {0x80,0x68},
	{0x80,0x18}, {0x80,0x08}, {0x80,0x38}, {0x80,0x28},
	{0x80,0xd8}, {0x80,0xc8}, {0x80,0xf8}, {0x80,0xe8},
	{0x80,0x98}, {0x80,0x88}, {0x80,0xb8}, {0x80,0xa8},
	{0x85,0x60}, {0x85,0x20}, {0x85,0xe0}, {0x85,0xa0},
	{0x84,0x60}, {0x84,0x20}, {0x84,0xe0}, {0x84,0xa0},
	{0x87,0x60}, {0x87,0x20}, {0x87,0xe0}, {0x87,0xa0},
	{0x86,0x60}, {0x86,0x20}, {0x86,0xe0}, {0x86,0xa0},
	{0x82,0xb0}, {0x82,0x90}, {0x82,0xf0}, {0x82,0xd0},
	{0x82,0x30}, {0x82,0x10}, {0x82,0x70}, {0x82,0x50},
	{0x83,0xb0}, {0x83,0x90}, {0x83,0xf0}, {0x83,0xd0},
	{0x83,0x30}, {0x83,0x10}, {0x83,0x70}, {0x83,0x50},
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.14 2007/10/23 19:54:36 jakemsr Exp $ */
a214 45
static const u_char lintoalaw[256] = {
	0x2a, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b, 0x2b, 0x2b,
	0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x29,
	0x2e, 0x2e, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f,
	0x2c, 0x2c, 0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2d,
	0x22, 0x22, 0x22, 0x22, 0x23, 0x23, 0x23, 0x23,
	0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x21,
	0x26, 0x26, 0x26, 0x26, 0x27, 0x27, 0x27, 0x27,
	0x24, 0x24, 0x24, 0x24, 0x25, 0x25, 0x25, 0x25,
	0x3a, 0x3a, 0x3b, 0x3b, 0x38, 0x38, 0x39, 0x39,
	0x3e, 0x3e, 0x3f, 0x3f, 0x3c, 0x3c, 0x3d, 0x3d,
	0x32, 0x32, 0x33, 0x33, 0x30, 0x30, 0x31, 0x31,
	0x36, 0x36, 0x37, 0x37, 0x34, 0x34, 0x35, 0x35,
	0x0a, 0x0b, 0x08, 0x09, 0x0e, 0x0f, 0x0c, 0x0d,
	0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05,
	0x1a, 0x18, 0x1e, 0x1c, 0x12, 0x10, 0x16, 0x14,
	0x6a, 0x6e, 0x62, 0x66, 0x7a, 0x72, 0x4a, 0x5a,
	0xd5, 0xc5, 0xf5, 0xfd, 0xe5, 0xe1, 0xed, 0xe9,
	0x95, 0x97, 0x91, 0x93, 0x9d, 0x9f, 0x99, 0x9b,
	0x85, 0x84, 0x87, 0x86, 0x81, 0x80, 0x83, 0x82,
	0x8d, 0x8c, 0x8f, 0x8e, 0x89, 0x88, 0x8b, 0x8a,
	0xb5, 0xb5, 0xb4, 0xb4, 0xb7, 0xb7, 0xb6, 0xb6,
	0xb1, 0xb1, 0xb0, 0xb0, 0xb3, 0xb3, 0xb2, 0xb2,
	0xbd, 0xbd, 0xbc, 0xbc, 0xbf, 0xbf, 0xbe, 0xbe,
	0xb9, 0xb9, 0xb8, 0xb8, 0xbb, 0xbb, 0xba, 0xba,
	0xa5, 0xa5, 0xa5, 0xa5, 0xa4, 0xa4, 0xa4, 0xa4,
	0xa7, 0xa7, 0xa7, 0xa7, 0xa6, 0xa6, 0xa6, 0xa6,
	0xa1, 0xa1, 0xa1, 0xa1, 0xa0, 0xa0, 0xa0, 0xa0,
	0xa3, 0xa3, 0xa3, 0xa3, 0xa2, 0xa2, 0xa2, 0xa2,
	0xad, 0xad, 0xad, 0xad, 0xac, 0xac, 0xac, 0xac,
	0xaf, 0xaf, 0xaf, 0xaf, 0xae, 0xae, 0xae, 0xae,
	0xa9, 0xa9, 0xa9, 0xa9, 0xa8, 0xa8, 0xa8, 0xa8,
	0xab, 0xab, 0xab, 0xab, 0xaa, 0xaa, 0xaa, 0xaa,
};

void
mulaw_to_ulinear8(void *v, u_char *p, int cc)
{
	/* Use the 16 bit table for 8 bits too. */
	while (--cc >= 0) {
		*p = mulawtolin16[*p][0];
		++p;
	}
}

a225 110
mulaw_to_ulinear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = mulawtolin16[*p][0];
		q[0] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_ulinear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = mulawtolin16[*p][0];
		q[1] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_slinear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = mulawtolin16[*p][0] ^ 0x80;
		q[0] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_slinear16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = mulawtolin16[*p][0] ^ 0x80;
		q[0] = q[2] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_slinear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = mulawtolin16[*p][0] ^ 0x80;
		q[1] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_slinear16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = mulawtolin16[*p][0] ^ 0x80;
		q[1] = q[3] = mulawtolin16[*p][1];
	}
}

void
slinear16_to_mulaw_le(void *v, u_char* p, int cc)
{
	u_char *q = p + 1;	/* q points higher byte. */

	while ((cc-= 2) >= 0) {
		*p++ = lintomulaw[*q ^ 0x80];
		q +=2 ;
	}
}

void
ulinear8_to_mulaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintomulaw[*p];
		++p;
	}
}

void
d235 1
a235 241
alaw_to_ulinear8(void *v, u_char *p, int cc)
{
	/* Use the 16 bit table for 8 bits too. */
	while (--cc >= 0) {
		*p = alawtolin16[*p][0];
		++p;
	}
}

void
alaw_to_slinear8(void *v, u_char *p, int cc)
{
	/* Use the 16 bit table for 8 bits too. */
	while (--cc >= 0) {
		*p = alawtolin16[*p][0] ^ 0x80;
		++p;
	}
}

void
alaw_to_ulinear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = alawtolin16[*p][0];
		q[0] = alawtolin16[*p][1];
	}
}

void
alaw_to_ulinear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = alawtolin16[*p][0];
		q[1] = alawtolin16[*p][1];
	}
}

void
alaw_to_slinear16_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = alawtolin16[*p][0] ^ 0x80;
		q[0] = alawtolin16[*p][1];
	}
}

void
alaw_to_slinear16_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = alawtolin16[*p][0] ^ 0x80;
		q[1] = alawtolin16[*p][1];
	}
}

void
ulinear8_to_alaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintoalaw[*p];
		++p;
	}
}

void
slinear8_to_alaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintoalaw[*p ^ 0x80];
		++p;
	}
}

void
slinear16_to_alaw_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*p = lintoalaw[q[1] ^ 0x80];
		++p;
		q += 2;
	}
}


void
slinear16_to_alaw_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 2) >= 0) {
		*p = lintoalaw[q[0] ^ 0x80];
		++p;
		q += 2;
	}
}

/*
 * same as mulaw_to_ulinear16_le(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = mulawtolin16[*p][0];
		q[0] = q[2] = mulawtolin16[*p][1];
	}
}

/*
 * same as mulaw_to_ulinear16_be(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = mulawtolin16[*p][0];
		q[1] = q[3] = mulawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_le(), plus expand mono to stereo
 */
void
alaw_to_slinear16_le_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = alawtolin16[*p][0] ^ 0x80;
		q[0] = q[2] = alawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_be(), plus expand mono to stereo
 */
void
alaw_to_slinear16_be_mts(void *v, u_char *p, int cc)
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = alawtolin16[*p][0] ^ 0x80;
		q[1] = q[3] = alawtolin16[*p][1];
	}
}

void
alaw_to_mulaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintomulaw[alawtolin16[*p][0]];
		++p;
	}
}

void
mulaw_to_alaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintoalaw[mulawtolin16[*p][0]];
		++p;
	}
}



void
slinear16_to_alaw_le_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*p = lintoalaw[q[1] ^ 0x80];
		++p;
		q += 4;
	}
}


void
slinear16_to_alaw_be_stm(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while ((cc -= 4) >= 0) {
		*p = lintoalaw[q[0] ^ 0x80];
		++p;
		q += 4;
	}
}

void
slinear16_to_mulaw_le_stm(void *v, u_char* p, int cc)
d237 1
a237 1
	u_char *q = p;
d240 4
a243 2
		*p++ = lintomulaw[q[1] ^ 0x80];
		q += 4 ;
d248 1
a248 1
slinear16_to_mulaw_be_stm(void *v, u_char* p, int cc)
d250 1
a250 1
	u_char *q = p;
d253 2
a254 2
		*p++ = lintomulaw[q[0] ^ 0x80];
		q += 4 ;
@


1.14
log
@- add a couple more mono-to-stereo conversions
- add stereo-to-mono conversions for mono recording
  on stereo only devices
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.13 2007/07/17 08:35:33 jakemsr Exp $ */
a38 1
#include <sys/audioio.h>
@


1.13
log
@when looping through an array and advancing your pointer to the array
2x on each loop, only loop .5x times

fixes hard hangs on i386 and "hiccups" on sgi when these functions are
used through e.g. dd if=/dev/audio of=foo, since mulaw is the default
encoding.

the commit history wrt this code is interesting.  I am responsible for
introducing this braindamage to OpenBSD ... and note that
linear16_to_linear8_[lb]e had it right ...
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.12 2005/04/14 01:24:20 pascoe Exp $ */
d600 49
@


1.12
log
@Correct signed/unsigned mismatches in compatibility macros and add
mono-to-stereo variants for mulaw_to_slinear16

ok dlg@@ jason@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.11 2004/02/23 23:59:21 deraadt Exp $ */
d366 1
a366 1
	while (--cc >= 0) {
d493 1
a493 1
	while (--cc >= 0) {
d506 1
a506 1
	while (--cc >= 0) {
@


1.11
log
@slinear to alaw converters; from netbsd, via jakemsr@@jakemsr.com
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.10 2003/06/27 00:23:43 jason Exp $ */
d317 15
d343 15
@


1.10
log
@ansify and add an alaw <-> mulaw conversion
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.9 2002/05/06 02:34:57 nate Exp $ */
d43 1
a43 1
 * This table converts a (8 bit) mulaw value two a 16 bit value.
d455 25
@


1.9
log
@new conversion functions from NetBSD for uaudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.8 2001/12/31 04:14:00 mickey Exp $ */
d252 1
a252 4
mulaw_to_ulinear8(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d262 1
a262 4
mulaw_to_slinear8(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d272 1
a272 4
mulaw_to_ulinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d287 1
a287 4
mulaw_to_ulinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d302 1
a302 4
mulaw_to_slinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d317 1
a317 4
mulaw_to_slinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d343 1
a343 4
ulinear8_to_mulaw(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d352 1
a352 4
slinear8_to_mulaw(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d361 1
a361 4
alaw_to_ulinear8(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d371 1
a371 4
alaw_to_slinear8(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d381 1
a381 4
alaw_to_ulinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d396 1
a396 4
alaw_to_ulinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d411 1
a411 4
alaw_to_slinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d426 1
a426 4
alaw_to_slinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d441 1
a441 4
ulinear8_to_alaw(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d450 1
a450 4
slinear8_to_alaw(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d462 1
a462 4
mulaw_to_ulinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d480 1
a480 4
mulaw_to_ulinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d498 1
a498 4
alaw_to_slinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d516 1
a516 4
alaw_to_slinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
d527 18
@


1.8
log
@add a mono-to-stereo versions; from Kazuhiko Fukuhara <zaa83571@@oak.zero.ad.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.7 2001/05/01 01:54:43 aaron Exp $ */
d346 11
@


1.7
log
@Fix a typo in comment. Constify. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.6 2001/05/01 01:49:48 aaron Exp $ */
d492 84
@


1.7.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.8 2001/12/31 04:14:00 mickey Exp $ */
a491 84
	}
}

/*
 * same as mulaw_to_ulinear16_le(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = mulawtolin16[*p][0];
		q[0] = q[2] = mulawtolin16[*p][1];
	}
}

/*
 * same as mulaw_to_ulinear16_be(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = mulawtolin16[*p][0];
		q[1] = q[3] = mulawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_le(), plus expand mono to stereo
 */
void
alaw_to_slinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = alawtolin16[*p][0] ^ 0x80;
		q[0] = q[2] = alawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_be(), plus expand mono to stereo
 */
void
alaw_to_slinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = alawtolin16[*p][0] ^ 0x80;
		q[1] = q[3] = alawtolin16[*p][1];
@


1.7.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mulaw.c,v 1.7.4.1 2002/01/31 22:55:29 niklas Exp $ */
a345 11
	}
}

void
slinear16_to_mulaw_le(void *v, u_char* p, int cc)
{
	u_char *q = p + 1;	/* q points higher byte. */

	while (--cc >= 0) {
		*p++ = lintomulaw[*q ^ 0x80];
		q +=2 ;
@


1.6
log
@Add $OpenBSD$ tags.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: mulaw.c,v 1.13 1999/11/01 18:12:19 augustss Exp $	*/
d44 1
a44 1
 * The 16 bits are represented as an array of two butes for easier access
d47 1
a47 1
static u_char mulawtolin16[256][2] = {
d114 1
a114 1
static u_char lintomulaw[256] = {
d149 1
a149 1
static u_char alawtolin16[256][2] = {
d216 1
a216 1
static u_char lintoalaw[256] = {
@


1.5
log
@extend with new netbsd api, and add backwards compat hacks for drivers
@
text
@d1 1
@


1.4
log
@More conversion routines, from NetBSD
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: mulaw.c,v 1.12 1998/08/09 21:41:45 mycroft Exp $	*/
a38 1
#include <machine/endian.h>
a40 8
#if BYTE_ORDER == LITTLE_ENDIAN
#define LO 0
#define HI 1
#else
#define LO 1
#define HI 0
#endif

d277 37
a313 1
mulaw_to_ulinear16(v, p, cc)
d325 2
a326 2
		q[HI] = mulawtolin16[*p][0];
		q[LO] = mulawtolin16[*p][1];
d331 1
a331 1
mulaw_to_slinear16(v, p, cc)
d343 2
a344 2
		q[HI] = mulawtolin16[*p][0] ^ 0x80;
		q[LO] = mulawtolin16[*p][1];
d399 37
a435 1
alaw_to_ulinear16(v, p, cc)
d447 2
a448 2
		q[HI] = alawtolin16[*p][0];
		q[LO] = alawtolin16[*p][1];
d453 1
a453 1
alaw_to_slinear16(v, p, cc)
d465 2
a466 2
		q[HI] = alawtolin16[*p][0] ^ 0x80;
		q[LO] = alawtolin16[*p][1];
@


1.4.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 1
/*	$NetBSD: mulaw.c,v 1.13 1999/11/01 18:12:19 augustss Exp $	*/
d40 1
d43 8
d287 1
a287 37
mulaw_to_ulinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = mulawtolin16[*p][0];
		q[0] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_ulinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = mulawtolin16[*p][0];
		q[1] = mulawtolin16[*p][1];
	}
}

void
mulaw_to_slinear16_le(v, p, cc)
d299 2
a300 2
		q[1] = mulawtolin16[*p][0] ^ 0x80;
		q[0] = mulawtolin16[*p][1];
d305 1
a305 1
mulaw_to_slinear16_be(v, p, cc)
d317 2
a318 2
		q[0] = mulawtolin16[*p][0] ^ 0x80;
		q[1] = mulawtolin16[*p][1];
d373 1
a373 37
alaw_to_ulinear16_le(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[1] = alawtolin16[*p][0];
		q[0] = alawtolin16[*p][1];
	}
}

void
alaw_to_ulinear16_be(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc << 1;
	while (--cc >= 0) {
		--p;
		q -= 2;
		q[0] = alawtolin16[*p][0];
		q[1] = alawtolin16[*p][1];
	}
}

void
alaw_to_slinear16_le(v, p, cc)
d385 2
a386 2
		q[1] = alawtolin16[*p][0] ^ 0x80;
		q[0] = alawtolin16[*p][1];
d391 1
a391 1
alaw_to_slinear16_be(v, p, cc)
d403 2
a404 2
		q[0] = alawtolin16[*p][0] ^ 0x80;
		q[1] = alawtolin16[*p][1];
@


1.4.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 2
/*	$OpenBSD$ */
/*	$NetBSD: mulaw.c,v 1.15 2001/01/18 20:28:20 jdolecek Exp $	*/
d43 1
a43 1
 * The 16 bits are represented as an array of two bytes for easier access
d46 1
a46 1
static const u_char mulawtolin16[256][2] = {
d113 1
a113 1
static const u_char lintomulaw[256] = {
d148 1
a148 1
static const u_char alawtolin16[256][2] = {
d215 1
a215 1
static const u_char lintoalaw[256] = {
@


1.4.6.3
log
@Merge in trunk
@
text
@a493 84

/*
 * same as mulaw_to_ulinear16_le(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = mulawtolin16[*p][0];
		q[0] = q[2] = mulawtolin16[*p][1];
	}
}

/*
 * same as mulaw_to_ulinear16_be(), plus expand mono to stereo
 */
void
mulaw_to_ulinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = mulawtolin16[*p][0];
		q[1] = q[3] = mulawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_le(), plus expand mono to stereo
 */
void
alaw_to_slinear16_le_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[1] = q[3] = alawtolin16[*p][0] ^ 0x80;
		q[0] = q[2] = alawtolin16[*p][1];
	}
}

/*
 * same as alaw_to_slinear16_be(), plus expand mono to stereo
 */
void
alaw_to_slinear16_be_mts(v, p, cc)
	void *v;
	u_char *p;
	int cc;
{
	u_char *q = p;

	p += cc;
	q += cc * 4;
	while (--cc >= 0) {
		--p;
		q -= 4;
		q[0] = q[2] = alawtolin16[*p][0] ^ 0x80;
		q[1] = q[3] = alawtolin16[*p][1];
	}
}
@


1.4.6.4
log
@Sync the SMP branch with 3.3
@
text
@a349 11
slinear16_to_mulaw_le(void *v, u_char* p, int cc)
{
	u_char *q = p + 1;	/* q points higher byte. */

	while (--cc >= 0) {
		*p++ = lintomulaw[*q ^ 0x80];
		q +=2 ;
	}
}

void
@


1.4.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d252 4
a255 1
mulaw_to_ulinear8(void *v, u_char *p, int cc)
d265 4
a268 1
mulaw_to_slinear8(void *v, u_char *p, int cc)
d278 4
a281 1
mulaw_to_ulinear16_le(void *v, u_char *p, int cc)
d296 4
a299 1
mulaw_to_ulinear16_be(void *v, u_char *p, int cc)
d314 4
a317 1
mulaw_to_slinear16_le(void *v, u_char *p, int cc)
d332 4
a335 1
mulaw_to_slinear16_be(void *v, u_char *p, int cc)
d361 4
a364 1
ulinear8_to_mulaw(void *v, u_char *p, int cc)
d373 4
a376 1
slinear8_to_mulaw(void *v, u_char *p, int cc)
d385 4
a388 1
alaw_to_ulinear8(void *v, u_char *p, int cc)
d398 4
a401 1
alaw_to_slinear8(void *v, u_char *p, int cc)
d411 4
a414 1
alaw_to_ulinear16_le(void *v, u_char *p, int cc)
d429 4
a432 1
alaw_to_ulinear16_be(void *v, u_char *p, int cc)
d447 4
a450 1
alaw_to_slinear16_le(void *v, u_char *p, int cc)
d465 4
a468 1
alaw_to_slinear16_be(void *v, u_char *p, int cc)
d483 4
a486 1
ulinear8_to_alaw(void *v, u_char *p, int cc)
d495 4
a498 1
slinear8_to_alaw(void *v, u_char *p, int cc)
d510 4
a513 1
mulaw_to_ulinear16_le_mts(void *v, u_char *p, int cc)
d531 4
a534 1
mulaw_to_ulinear16_be_mts(void *v, u_char *p, int cc)
d552 4
a555 1
alaw_to_slinear16_le_mts(void *v, u_char *p, int cc)
d573 4
a576 1
alaw_to_slinear16_be_mts(void *v, u_char *p, int cc)
a586 18
	}
}

void
alaw_to_mulaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintomulaw[alawtolin16[*p][0]];
		++p;
	}
}

void
mulaw_to_alaw(void *v, u_char *p, int cc)
{
	while (--cc >= 0) {
		*p = lintoalaw[mulawtolin16[*p][0]];
		++p;
@


1.4.6.6
log
@Merge with the trunk
@
text
@d43 1
a43 1
 * This table converts a (8 bit) mu-law value two a 16 bit value.
a454 25
	}
}

void
slinear16_to_alaw_le(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*p = lintoalaw[q[1] ^ 0x80];
		++p;
		q += 2;
	}
}


void
slinear16_to_alaw_be(void *v, u_char *p, int cc)
{
	u_char *q = p;

	while (--cc >= 0) {
		*p = lintoalaw[q[0] ^ 0x80];
		++p;
		q += 2;
@


1.3
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 2
a2 2
/*	$OpenBSD: mulaw.c,v 1.2 1997/11/07 08:06:36 niklas Exp $	*/
/*	$NetBSD: mulaw.c,v 1.8 1997/08/04 09:29:53 augustss Exp $	*/
d274 13
d295 1
a295 1
	q += cc * 2;
d297 22
a318 2
		*--q = mulawtolin16[*--p][LO];
		*--q = mulawtolin16[*p  ][HI];
d335 12
d360 13
d381 19
a399 1
	q += cc * 2;
d401 4
a404 2
		*--q = alawtolin16[*--p][LO];
		*--q = alawtolin16[*p  ][HI];
d420 11
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 1
/*	$OpenBSD$	*/
d40 1
d43 78
a120 33
static u_char mulawtolin[256] = {
	128, 4, 8, 12, 16, 20, 24, 28, 
	32, 36, 40, 44, 48, 52, 56, 60, 
	64, 66, 68, 70, 72, 74, 76, 78, 
	80, 82, 84, 86, 88, 90, 92, 94, 
	96, 97, 98, 99, 100, 101, 102, 103, 
	104, 105, 106, 107, 108, 109, 110, 111, 
	112, 112, 113, 113, 114, 114, 115, 115, 
	116, 116, 117, 117, 118, 118, 119, 119, 
	120, 120, 120, 121, 121, 121, 121, 122, 
	122, 122, 122, 123, 123, 123, 123, 124, 
	124, 124, 124, 124, 125, 125, 125, 125, 
	125, 125, 125, 125, 126, 126, 126, 126, 
	126, 126, 126, 126, 126, 126, 126, 126, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	127, 127, 127, 127, 127, 127, 127, 127, 
	255, 251, 247, 243, 239, 235, 231, 227, 
	223, 219, 215, 211, 207, 203, 199, 195, 
	191, 189, 187, 185, 183, 181, 179, 177, 
	175, 173, 171, 169, 167, 165, 163, 161, 
	159, 158, 157, 156, 155, 154, 153, 152, 
	151, 150, 149, 148, 147, 146, 145, 144, 
	143, 143, 142, 142, 141, 141, 140, 140, 
	139, 139, 138, 138, 137, 137, 136, 136, 
	135, 135, 135, 134, 134, 134, 134, 133, 
	133, 133, 133, 132, 132, 132, 132, 131, 
	131, 131, 131, 131, 130, 130, 130, 130, 
	130, 130, 130, 130, 129, 129, 129, 129, 
	129, 129, 129, 129, 129, 129, 129, 129, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
d124 134
a257 32
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 2, 2, 2, 2, 3, 3, 3, 
	3, 4, 4, 4, 4, 5, 5, 5, 
	5, 6, 6, 6, 6, 7, 7, 7, 
	7, 8, 8, 8, 8, 9, 9, 9, 
	9, 10, 10, 10, 10, 11, 11, 11, 
	11, 12, 12, 12, 12, 13, 13, 13, 
	13, 14, 14, 14, 14, 15, 15, 15, 
	15, 16, 16, 17, 17, 18, 18, 19, 
	19, 20, 20, 21, 21, 22, 22, 23, 
	23, 24, 24, 25, 25, 26, 26, 27, 
	27, 28, 28, 29, 29, 30, 30, 31, 
	31, 32, 33, 34, 35, 36, 37, 38, 
	39, 40, 41, 42, 43, 44, 45, 46, 
	47, 48, 50, 52, 54, 56, 58, 60, 
	62, 65, 69, 73, 77, 83, 91, 103, 
	255, 231, 219, 211, 205, 201, 197, 193, 
	190, 188, 186, 184, 182, 180, 178, 176, 
	175, 174, 173, 172, 171, 170, 169, 168, 
	167, 166, 165, 164, 163, 162, 161, 160, 
	159, 159, 158, 158, 157, 157, 156, 156, 
	155, 155, 154, 154, 153, 153, 152, 152, 
	151, 151, 150, 150, 149, 149, 148, 148, 
	147, 147, 146, 146, 145, 145, 144, 144, 
	143, 143, 143, 143, 142, 142, 142, 142, 
	141, 141, 141, 141, 140, 140, 140, 140, 
	139, 139, 139, 139, 138, 138, 138, 138, 
	137, 137, 137, 137, 136, 136, 136, 136, 
	135, 135, 135, 135, 134, 134, 134, 134, 
	133, 133, 133, 133, 132, 132, 132, 132, 
	131, 131, 131, 131, 130, 130, 130, 130, 
	129, 129, 129, 129, 128, 128, 128, 128, 
d261 2
a262 3
mulaw_compress(hdl, e, p, cc)
	void *hdl;
	int e;
d266 22
a287 1
	u_char *tab;
d289 9
a297 6
	switch (e) {
	case AUDIO_ENCODING_ULAW:
		tab = lintomulaw;
		break;
	default:
		return;
d299 1
d301 7
d309 1
a309 1
		*p = tab[*p];
d315 2
a316 3
mulaw_expand(hdl, e, p, cc)
	void *hdl;
	int e;
d320 1
a320 1
	u_char *tab;
d322 5
a326 6
	switch (e) {
	case AUDIO_ENCODING_ULAW:
		tab = mulawtolin;
		break;
	default:
		return;
d328 8
a335 1
	
d337 1
a337 1
		*p = tab[*p];
@


1.1
log
@Initial revision
@
text
@d1 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
