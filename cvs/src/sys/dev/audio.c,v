head	1.162;
access;
symbols
	OPENBSD_6_1:1.162.0.2
	OPENBSD_6_1_BASE:1.162
	OPENBSD_6_0:1.150.0.2
	OPENBSD_6_0_BASE:1.150
	OPENBSD_5_9:1.144.0.2
	OPENBSD_5_9_BASE:1.144
	OPENBSD_5_8:1.138.0.4
	OPENBSD_5_8_BASE:1.138
	OPENBSD_5_7:1.129.0.4
	OPENBSD_5_7_BASE:1.129
	OPENBSD_5_6:1.122.0.4
	OPENBSD_5_6_BASE:1.122
	OPENBSD_5_5:1.120.0.4
	OPENBSD_5_5_BASE:1.120
	OPENBSD_5_4:1.115.0.2
	OPENBSD_5_4_BASE:1.115
	OPENBSD_5_3:1.114.0.8
	OPENBSD_5_3_BASE:1.114
	OPENBSD_5_2:1.114.0.6
	OPENBSD_5_2_BASE:1.114
	OPENBSD_5_1_BASE:1.114
	OPENBSD_5_1:1.114.0.4
	OPENBSD_5_0:1.114.0.2
	OPENBSD_5_0_BASE:1.114
	OPENBSD_4_9:1.111.0.2
	OPENBSD_4_9_BASE:1.111
	OPENBSD_4_8:1.108.0.2
	OPENBSD_4_8_BASE:1.108
	OPENBSD_4_7:1.107.0.2
	OPENBSD_4_7_BASE:1.107
	OPENBSD_4_6:1.104.0.4
	OPENBSD_4_6_BASE:1.104
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.96.0.2
	OPENBSD_4_4_BASE:1.96
	OPENBSD_4_3:1.90.0.2
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.51.0.2
	OPENBSD_4_0_BASE:1.51
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.44.0.4
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.41.0.4
	OPENBSD_3_4_BASE:1.41
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.41.0.2
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	UBC_SYNC_B:1.40
	UBC:1.32.0.2
	UBC_BASE:1.32
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.21.0.2
	OPENBSD_2_7_BASE:1.21
	SMP:1.20.0.2
	SMP_BASE:1.20
	kame_19991208:1.19
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.162
date	2017.03.28.05.20.22;	author ratchov;	state Exp;
branches;
next	1.161;
commitid	rKMbZydFa7cxKMtt;

1.161
date	2017.03.11.10.12.45;	author ratchov;	state Exp;
branches;
next	1.160;
commitid	lYK2Pvw6qiuQyEex;

1.160
date	2017.01.03.06.42.11;	author ratchov;	state Exp;
branches;
next	1.159;
commitid	vqcJd1uxomPzWyJK;

1.159
date	2016.12.20.15.59.07;	author ratchov;	state Exp;
branches;
next	1.158;
commitid	4iVYz1P8iHvCmpyG;

1.158
date	2016.12.12.06.23.03;	author ratchov;	state Exp;
branches;
next	1.157;
commitid	LdX4iQg0kWEzYvDJ;

1.157
date	2016.11.08.06.04.25;	author ratchov;	state Exp;
branches;
next	1.156;
commitid	axsj1c6W4ljlz1MF;

1.156
date	2016.10.09.11.37.23;	author kettenis;	state Exp;
branches;
next	1.155;
commitid	nJg3EPXd8dKlTTJ3;

1.155
date	2016.10.06.05.29.19;	author ratchov;	state Exp;
branches;
next	1.154;
commitid	e4EVbQodQ9NSJ1aG;

1.154
date	2016.10.04.23.02.03;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	ICCPVr3HYKMBRCBP;

1.153
date	2016.09.19.06.46.43;	author ratchov;	state Exp;
branches;
next	1.152;
commitid	qGgYgJTgEFuAoGj4;

1.152
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.151;
commitid	pi1a9KN0itEngOc4;

1.151
date	2016.08.31.07.22.43;	author ratchov;	state Exp;
branches;
next	1.150;
commitid	u524ZaNwqXxsCXa2;

1.150
date	2016.06.21.06.38.28;	author ratchov;	state Exp;
branches;
next	1.149;
commitid	5qTyuLKWaNmDh5Qu;

1.149
date	2016.06.18.07.59.30;	author ratchov;	state Exp;
branches;
next	1.148;
commitid	fEJswg099P796SWr;

1.148
date	2016.06.01.09.48.20;	author mglocker;	state Exp;
branches;
next	1.147;
commitid	RaPpcmMm3TxnbPGc;

1.147
date	2016.05.11.16.16.58;	author ratchov;	state Exp;
branches;
next	1.146;
commitid	JWDcjrSyFSrgWaEU;

1.146
date	2016.05.11.07.51.45;	author ratchov;	state Exp;
branches;
next	1.145;
commitid	hYHqbFCi2Bjcwav9;

1.145
date	2016.03.16.06.46.39;	author ratchov;	state Exp;
branches;
next	1.144;
commitid	QZGe5AFBhlhD5xcQ;

1.144
date	2016.01.29.15.14.23;	author ratchov;	state Exp;
branches;
next	1.143;
commitid	CvVNQ9cS5Y25T9kb;

1.143
date	2016.01.20.19.01.39;	author ratchov;	state Exp;
branches;
next	1.142;
commitid	7cqtmkwWhPdsdIiU;

1.142
date	2016.01.20.07.59.55;	author ratchov;	state Exp;
branches;
next	1.141;
commitid	153nU3W1oORYvkIv;

1.141
date	2016.01.09.23.24.31;	author jsg;	state Exp;
branches;
next	1.140;
commitid	nX5GVGohUTQX3Rh6;

1.140
date	2015.12.14.03.04.10;	author mmcc;	state Exp;
branches;
next	1.139;
commitid	QRx2J32q7BBN5PYO;

1.139
date	2015.09.04.16.02.19;	author ratchov;	state Exp;
branches;
next	1.138;
commitid	q4NDdxmMHhZadqxb;

1.138
date	2015.07.29.21.13.32;	author ratchov;	state Exp;
branches;
next	1.137;
commitid	l7OHIGHKMm80b72f;

1.137
date	2015.07.28.21.04.28;	author ratchov;	state Exp;
branches;
next	1.136;
commitid	1ieYqj56FERhJxK3;

1.136
date	2015.07.28.20.57.35;	author ratchov;	state Exp;
branches;
next	1.135;
commitid	zwdOWTPL143iDvp9;

1.135
date	2015.07.28.20.45.02;	author ratchov;	state Exp;
branches;
next	1.134;
commitid	eZrQAVJUnWy2oIFo;

1.134
date	2015.07.24.08.56.45;	author ratchov;	state Exp;
branches;
next	1.133;
commitid	vPm2C1ZOXclLSjEe;

1.133
date	2015.07.22.19.06.28;	author ratchov;	state Exp;
branches;
next	1.132;
commitid	o655NQplBOt2o1sC;

1.132
date	2015.06.25.06.43.45;	author ratchov;	state Exp;
branches;
next	1.131;
commitid	EA6IpjJSgQH2WTCf;

1.131
date	2015.05.22.12.46.38;	author jsg;	state Exp;
branches;
next	1.130;
commitid	pr7OLOSLADIdkfIM;

1.130
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.129;
commitid	RaOGL5SyOGOZylwx;

1.129
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.128;
commitid	C5iGb36LQxjM60Q3;

1.128
date	2015.02.07.01.49.05;	author kettenis;	state Exp;
branches;
next	1.127;
commitid	D7S2KHS8SDgNjAUK;

1.127
date	2015.01.27.03.17.35;	author dlg;	state Exp;
branches;
next	1.126;
commitid	MyKPm9Q3dQu92BiX;

1.126
date	2015.01.20.04.54.23;	author dlg;	state Exp;
branches;
next	1.125;
commitid	rC9mzjLdRCeWo9jd;

1.125
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.124;
commitid	LS2TNeCue5R9L67C;

1.124
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	yv0ECmCdICvq576h;

1.123
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.122;
commitid	uzzBR7hz9ncd4O6G;

1.122
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.121;
commitid	I19imNlAX05zJOED;

1.121
date	2014.05.19.07.00.15;	author ratchov;	state Exp;
branches;
next	1.120;

1.120
date	2013.12.17.14.55.16;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2013.11.28.00.38.50;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.04.11.57.26;	author mpi;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.30.02.13.52;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.114;

1.114
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2011.06.06.06.13.45;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2010.11.18.21.15.14;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.21.20.08.11;	author jakemsr;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.12.02.01.17;	author jakemsr;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.106;

1.106
date	2009.10.27.12.13.33;	author jakemsr;	state Exp;
branches;
next	1.105;

1.105
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.18.22.55.56;	author jakemsr;	state Exp;
branches;
next	1.103;

1.103
date	2009.03.21.13.16.21;	author ratchov;	state Exp;
branches;
next	1.102;

1.102
date	2009.03.16.19.45.09;	author ratchov;	state Exp;
branches;
next	1.101;

1.101
date	2009.01.16.23.07.33;	author jakemsr;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2008.10.30.03.46.56;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.98;

1.98
date	2008.09.29.02.27.38;	author jakemsr;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.10.12.03.53;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2008.07.29.05.59.11;	author ratchov;	state Exp;
branches;
next	1.95;

1.95
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.94;

1.94
date	2008.04.04.04.57.16;	author jakemsr;	state Exp;
branches;
next	1.93;

1.93
date	2008.03.22.11.05.31;	author ratchov;	state Exp;
branches;
next	1.92;

1.92
date	2008.03.22.07.48.58;	author ratchov;	state Exp;
branches;
next	1.91;

1.91
date	2008.03.12.20.33.13;	author ratchov;	state Exp;
branches;
next	1.90;

1.90
date	2008.02.28.09.15.04;	author jakemsr;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.17.13.31.30;	author ratchov;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.28.13.27.05;	author ratchov;	state Exp;
branches;
next	1.87;

1.87
date	2007.10.28.13.23.01;	author ratchov;	state Exp;
branches;
next	1.86;

1.86
date	2007.10.27.08.52.47;	author ratchov;	state Exp;
branches;
next	1.85;

1.85
date	2007.10.25.18.13.42;	author ratchov;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.25.18.11.15;	author ratchov;	state Exp;
branches;
next	1.83;

1.83
date	2007.10.23.17.43.41;	author ratchov;	state Exp;
branches;
next	1.82;

1.82
date	2007.10.19.15.31.02;	author ratchov;	state Exp;
branches;
next	1.81;

1.81
date	2007.10.03.21.49.13;	author jakemsr;	state Exp;
branches;
next	1.80;

1.80
date	2007.09.24.19.45.03;	author ratchov;	state Exp;
branches;
next	1.79;

1.79
date	2007.09.24.19.23.41;	author ratchov;	state Exp;
branches;
next	1.78;

1.78
date	2007.09.17.13.46.11;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2007.09.17.13.35.46;	author jakemsr;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.17.13.33.29;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2007.09.10.22.24.04;	author ratchov;	state Exp;
branches;
next	1.74;

1.74
date	2007.09.10.05.34.32;	author ratchov;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.09.02.55.18;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2007.08.08.05.51.23;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.02.07.24.46;	author jakemsr;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.02.07.15.49;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.31.03.11.14;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.18.19.27.08;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2007.07.18.18.34.32;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.17.22.59.19;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.17.10.35.10;	author jakemsr;	state Exp;
branches;
next	1.64;

1.64
date	2007.07.14.02.31.33;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2007.07.10.08.45.37;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2007.07.09.09.18.47;	author jakemsr;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.09.09.13.04;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.06.04.40.20;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.06.04.25.28;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2007.07.06.04.12.50;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.06.04.10.34;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2007.07.06.03.20.07;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.31.22.23.13;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.07.13.35.51;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.11.29.13.34.31;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.01.03.37.23;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.29.20.23.13;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.12.10.34.50;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.02.05.21.37;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.21.18.16.38;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.02.19.04.18;	author joris;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.14.05.39.17;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2004.07.10.11.48.30;	author vincent;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.26.23.16.14;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.26.16.20.04;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.16.01.36.22;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.06.14.25.09;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.04.20.42.25;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.10.18.49.07;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2002.01.09.17.59.37;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.11.01.12.13.46;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.11.22.49.19;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.27.15.26.16;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.03.07.41.53;	author hugh;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.28.09.45.26;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.09.21.31.33;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.19.09.04.37;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.24.13.44.17;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.10.19.49.14;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.03.19.38.12;	author fgsch;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	99.12.05.18.35.33;	author espie;	state Exp;
branches;
next	1.18;

1.18
date	99.11.20.18.51.58;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	99.06.19.19.49.02;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	99.01.02.00.02.39;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	98.11.20.15.57.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.11.03.21.00.09;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	98.07.24.01.59.38;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	98.04.26.21.03.06;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.04.25.04.57.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.07.10.23.06.29;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.04.09.14.46.12;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.05.26.00.26.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.19.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.23.46.55;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.02.00.29.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.27.09.43.15;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.08.07.44.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.20.09.36.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.28;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.05.14.22.23.00;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2002.03.28.12.29.44;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.32.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;

1.101.2.1
date	2009.04.27.20.45.26;	author ratchov;	state Exp;
branches;
next	;


desc
@@


1.162
log
@Simplify rate/channels/bits bounds checking code. From
Michael W. Bombardieri <mb at ii.net>. Thanks.
@
text
@/*	$OpenBSD: audio.c,v 1.161 2017/03/11 10:12:45 ratchov Exp $	*/
/*
 * Copyright (c) 2015 Alexandre Ratchov <alex@@caoua.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>
#include <sys/fcntl.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/poll.h>
#include <sys/kernel.h>
#include <sys/task.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/mulaw.h>
#include "audio.h"
#include "wskbd.h"

#ifdef AUDIO_DEBUG
#define DPRINTF(...)				\
	do {					\
		if (audio_debug)		\
			printf(__VA_ARGS__);	\
	} while(0)
#define DPRINTFN(n, ...)			\
	do {					\
		if (audio_debug > (n))		\
			printf(__VA_ARGS__);	\
	} while(0)
#else
#define DPRINTF(...) do {} while(0)
#define DPRINTFN(n, ...) do {} while(0)
#endif

#define DEVNAME(sc)		((sc)->dev.dv_xname)
#define AUDIO_UNIT(n)		(minor(n) & 0x0f)
#define AUDIO_DEV(n)		(minor(n) & 0xf0)
#define AUDIO_DEV_SOUND		0	/* minor of /dev/sound0 */
#define AUDIO_DEV_MIXER		0x10	/* minor of /dev/mixer0 */
#define AUDIO_DEV_AUDIO		0x80	/* minor of /dev/audio0 */
#define AUDIO_DEV_AUDIOCTL	0xc0	/* minor of /dev/audioctl */
#define AUDIO_BUFSZ		65536	/* buffer size in bytes */

/*
 * dma buffer
 */
struct audio_buf {
	unsigned char *data;		/* DMA memory block */
	size_t datalen;			/* size of DMA memory block */
	size_t len;			/* size of DMA FIFO */
	size_t start;			/* first byte used in the FIFO */
	size_t used;			/* bytes used in the FIFO */
	size_t blksz;			/* DMA block size */
	struct selinfo sel;		/* to record & wakeup poll(2) */
	unsigned int pos;		/* bytes transferred */
	unsigned int xrun;		/* bytes lost by xruns */
	int blocking;			/* read/write blocking */
};

#if NWSKBD > 0
struct wskbd_vol
{
	int val;			/* index of the value control */
	int mute;			/* index of the mute control */
	int step;			/* increment/decrement step */
	int nch;			/* channels in the value control */
	int val_pending;		/* pending change of val */
	int mute_pending;		/* pending change of mute */
#define WSKBD_MUTE_TOGGLE	1
#define WSKBD_MUTE_DISABLE	2
#define WSKBD_MUTE_ENABLE	3
};
#endif

/*
 * device structure
 */
struct audio_softc {
	struct device dev;
	struct audio_hw_if *ops;	/* driver funcs */
	void *arg;			/* first arg to driver funcs */
	int mode;			/* bitmask of AUMODE_* */
	int quiesce;			/* device suspended */
	struct audio_buf play, rec;
	unsigned int sw_enc;		/* user exposed AUDIO_ENCODING_* */
	unsigned int hw_enc;		/* hardware AUDIO_ENCODING_* */
	unsigned int bits;		/* bits per sample */
	unsigned int bps;		/* bytes-per-sample */
	unsigned int msb;		/* sample are MSB aligned */
	unsigned int rate;		/* rate in Hz */
	unsigned int round;		/* block size in frames */
	unsigned int nblks;		/* number of play blocks */
	unsigned int pchan, rchan;	/* number of channels */
	unsigned char silence[4];	/* a sample of silence */
	int pause;			/* not trying to start DMA */
	int active;			/* DMA in process */
	int offs;			/* offset between play & rec dir */
	void (*conv_enc)(unsigned char *, int);	/* encode to native */
	void (*conv_dec)(unsigned char *, int);	/* decode to user */
#if NWSKBD > 0
	struct wskbd_vol spkr, mic;
	struct task wskbd_task;
	int wskbd_taskset;
#endif
};

int audio_match(struct device *, void *, void *);
void audio_attach(struct device *, struct device *, void *);
int audio_activate(struct device *, int);
int audio_detach(struct device *, int);
void audio_pintr(void *);
void audio_rintr(void *);
#if NWSKBD > 0
void wskbd_mixer_init(struct audio_softc *);
#endif

const struct cfattach audio_ca = {
	sizeof(struct audio_softc), audio_match, audio_attach,
	audio_detach, audio_activate
};

struct cfdriver audio_cd = {
	NULL, "audio", DV_DULL
};

/*
 * This mutex protects data structures (including registers on the
 * sound-card) that are manipulated by both the interrupt handler and
 * syscall code-paths.
 *
 * Note that driver methods may sleep (e.g. in malloc); consequently the
 * audio layer calls them with the mutex unlocked. Driver methods are
 * responsible for locking the mutex when they manipulate data used by
 * the interrupt handler and interrupts may occur.
 *
 * Similarly, the driver is responsible for locking the mutex in its
 * interrupt handler and to call the audio layer call-backs (i.e.
 * audio_{p,r}int()) with the mutex locked.
 */
struct mutex audio_lock = MUTEX_INITIALIZER(IPL_AUDIO);

#ifdef AUDIO_DEBUG
/*
 * 0 - nothing, as if AUDIO_DEBUG isn't defined
 * 1 - initialisations & setup
 * 2 - blocks & interrupts
 */
int audio_debug = 1;
#endif

unsigned int
audio_gcd(unsigned int a, unsigned int b)
{
	unsigned int r;

	while (b > 0) {
		r = a % b;
		a = b;
		b = r;
	}
	return a;
}

int
audio_buf_init(struct audio_softc *sc, struct audio_buf *buf, int dir)
{
	if (sc->ops->round_buffersize) {
		buf->datalen = sc->ops->round_buffersize(sc->arg,
		    dir, AUDIO_BUFSZ);
	} else
		buf->datalen = AUDIO_BUFSZ;
	if (sc->ops->allocm) {
		buf->data = sc->ops->allocm(sc->arg, dir, buf->datalen,
		    M_DEVBUF, M_WAITOK);
	} else
		buf->data = malloc(buf->datalen, M_DEVBUF, M_WAITOK);
	if (buf->data == NULL)
		return ENOMEM;
	return 0;
}

void
audio_buf_done(struct audio_softc *sc, struct audio_buf *buf)
{
	if (sc->ops->freem)
		sc->ops->freem(sc->arg, buf->data, M_DEVBUF);
	else
		free(buf->data, M_DEVBUF, buf->datalen);
}

/*
 * return the reader pointer and the number of bytes available
 */
unsigned char *
audio_buf_rgetblk(struct audio_buf *buf, size_t *rsize)
{
	size_t count;

	count = buf->len - buf->start;
	if (count > buf->used)
		count = buf->used;
	*rsize = count;
	return buf->data + buf->start;
}

/*
 * discard "count" bytes at the start position.
 */
void
audio_buf_rdiscard(struct audio_buf *buf, size_t count)
{
#ifdef AUDIO_DEBUG
	if (count > buf->used) {
		panic("audio_buf_rdiscard: bad count = %zu, "
		    "start = %zu, used = %zu\n", count, buf->start, buf->used);
	}
#endif
	buf->used -= count;
	buf->start += count;
	if (buf->start >= buf->len)
		buf->start -= buf->len;
}

/*
 * advance the writer pointer by "count" bytes
 */
void
audio_buf_wcommit(struct audio_buf *buf, size_t count)
{
#ifdef AUDIO_DEBUG
	if (count > (buf->len - buf->used)) {
		panic("audio_buf_wcommit: bad count = %zu, "
		    "start = %zu, used = %zu\n", count, buf->start, buf->used);
	}
#endif
	buf->used += count;
}

/*
 * get writer pointer and the number of bytes writable
 */
unsigned char *
audio_buf_wgetblk(struct audio_buf *buf, size_t *rsize)
{
	size_t end, avail, count;

	end = buf->start + buf->used;
	if (end >= buf->len)
		end -= buf->len;
	avail = buf->len - buf->used;
	count = buf->len - end;
	if (count > avail)
		count = avail;
	*rsize = count;
	return buf->data + end;
}

void
audio_calc_sil(struct audio_softc *sc)
{
	unsigned char *q;
	unsigned int s, i;
	int d, e;

	e = sc->sw_enc;
#ifdef AUDIO_DEBUG
	switch (e) {
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_BE:
		break;
	default:
		printf("%s: unhandled play encoding %d\n", DEVNAME(sc), e);
		memset(sc->silence, 0, sc->bps);
		return;
	}
#endif
	if (e == AUDIO_ENCODING_SLINEAR_BE || e == AUDIO_ENCODING_ULINEAR_BE) {
		d = -1;
		q = sc->silence + sc->bps - 1;
	} else {
		d = 1;
		q = sc->silence;
	}
	if (e == AUDIO_ENCODING_SLINEAR_LE || e == AUDIO_ENCODING_SLINEAR_BE) {
		s = 0;
	} else {
		s = 0x80000000;
		if (sc->msb)
			s >>= 32 - 8 * sc->bps;
		else
			s >>= 32 - sc->bits;
	}
	for (i = 0; i < sc->bps; i++) {
		*q = s;
		q += d;
		s >>= 8;
	}
	if (sc->conv_enc)
		sc->conv_enc(sc->silence, sc->bps);
}

void
audio_fill_sil(struct audio_softc *sc, unsigned char *ptr, size_t count)
{
	unsigned char *q, *p;
	size_t i, j;

	q = ptr;
	for (j = count / sc->bps; j > 0; j--) {
		p = sc->silence;
		for (i = sc->bps; i > 0; i--)
			*q++ = *p++;
	}
}

void
audio_clear(struct audio_softc *sc)
{
	if (sc->mode & AUMODE_PLAY) {
		sc->play.used = sc->play.start = 0;
		sc->play.pos = sc->play.xrun = 0;
		audio_fill_sil(sc, sc->play.data, sc->play.len);
	}
	if (sc->mode & AUMODE_RECORD) {
		sc->rec.used = sc->rec.start = 0;
		sc->rec.pos = sc->rec.xrun = 0;
		audio_fill_sil(sc, sc->rec.data, sc->rec.len);
	}
}

/*
 * called whenever a block is consumed by the driver
 */
void
audio_pintr(void *addr)
{
	struct audio_softc *sc = addr;
	unsigned char *ptr;
	size_t count;
	int error, nblk, todo;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!(sc->mode & AUMODE_PLAY) || !sc->active) {
		printf("%s: play interrupt but not playing\n", DEVNAME(sc));
		return;
	}
	if (sc->quiesce) {
		DPRINTF("%s: quiesced, skipping play intr\n", DEVNAME(sc));
		return;
	}

	/*
	 * check if record pointer wrapped, see explanation
	 * in audio_rintr()
	 */
	if (sc->mode & AUMODE_RECORD) {
		sc->offs--;
		nblk = sc->rec.len / sc->rec.blksz;
		todo = -sc->offs;
		if (todo >= nblk) {
			todo -= todo % nblk;
			DPRINTFN(1, "%s: rec ptr wrapped, moving %d blocks\n",
			    DEVNAME(sc), todo);
			while (todo-- > 0)
				audio_rintr(sc);
		}
	}

	sc->play.pos += sc->play.blksz;
	audio_fill_sil(sc, sc->play.data + sc->play.start, sc->play.blksz);
	audio_buf_rdiscard(&sc->play, sc->play.blksz);
	if (sc->play.used < sc->play.blksz) {
		DPRINTFN(1, "%s: play underrun\n", DEVNAME(sc));
		sc->play.xrun += sc->play.blksz;
		audio_buf_wcommit(&sc->play, sc->play.blksz);
	}

	DPRINTFN(1, "%s: play intr, used -> %zu, start -> %zu\n",
	    DEVNAME(sc), sc->play.used, sc->play.start);

	if (!sc->ops->trigger_output) {
		ptr = audio_buf_rgetblk(&sc->play, &count);
		error = sc->ops->start_output(sc->arg,
		    ptr, sc->play.blksz, audio_pintr, (void *)sc);
		if (error) {
			printf("%s: play restart failed: %d\n",
			    DEVNAME(sc), error);
		}
	}

	if (sc->play.used < sc->play.len) {
		DPRINTFN(1, "%s: play wakeup, chan = %d\n",
		    DEVNAME(sc), sc->play.blocking);
		if (sc->play.blocking) {
			wakeup(&sc->play.blocking);
			sc->play.blocking = 0;
		}
		selwakeup(&sc->play.sel);
	}
}

/*
 * called whenever a block is produced by the driver
 */
void
audio_rintr(void *addr)
{
	struct audio_softc *sc = addr;
	unsigned char *ptr;
	size_t count;
	int error, nblk, todo;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!(sc->mode & AUMODE_RECORD) || !sc->active) {
		printf("%s: rec interrupt but not recording\n", DEVNAME(sc));
		return;
	}
	if (sc->quiesce) {
		DPRINTF("%s: quiesced, skipping rec intr\n", DEVNAME(sc));
		return;
	}

	/*
	 * Interrupts may be masked by other sub-systems during 320ms
	 * and more. During such a delay the hardware doesn't stop
	 * playing and the play buffer pointers may wrap, this can't be
	 * detected and corrected by low level drivers. This makes the
	 * record stream ahead of the play stream; this is detected as a
	 * hardware anomaly by userland and cause programs to misbehave.
	 *
	 * We fix this by advancing play position by an integer count of
	 * full buffers, so it reaches the record position.
	 */
	if (sc->mode & AUMODE_PLAY) {
		sc->offs++;
		nblk = sc->play.len / sc->play.blksz;
		todo = sc->offs;
		if (todo >= nblk) {
			todo -= todo % nblk;
			DPRINTFN(1, "%s: play ptr wrapped, moving %d blocks\n",
			    DEVNAME(sc), todo);
			while (todo-- > 0)
				audio_pintr(sc);
		}
	}

	sc->rec.pos += sc->rec.blksz;
	audio_buf_wcommit(&sc->rec, sc->rec.blksz);
	if (sc->rec.used == sc->rec.len) {
		DPRINTFN(1, "%s: rec overrun\n", DEVNAME(sc));
		sc->rec.xrun += sc->rec.blksz;
		audio_buf_rdiscard(&sc->rec, sc->rec.blksz);
	}
	DPRINTFN(1, "%s: rec intr, used -> %zu\n", DEVNAME(sc), sc->rec.used);

	if (!sc->ops->trigger_input) {
		ptr = audio_buf_wgetblk(&sc->rec, &count);
		error = sc->ops->start_input(sc->arg,
		    ptr, sc->rec.blksz, audio_rintr, (void *)sc);
		if (error) {
			printf("%s: rec restart failed: %d\n",
			    DEVNAME(sc), error);
		}
	}

	if (sc->rec.used > 0) {
		DPRINTFN(1, "%s: rec wakeup, chan = %d\n",
		    DEVNAME(sc), sc->rec.blocking);
		if (sc->rec.blocking) {
			wakeup(&sc->rec.blocking);
			sc->rec.blocking = 0;
		}
		selwakeup(&sc->rec.sel);
	}
}

int
audio_start_do(struct audio_softc *sc)
{
	int error;
	struct audio_params p;
	unsigned char *ptr;
	size_t count;

	DPRINTF("%s: starting\n", DEVNAME(sc));

	error = 0;
	sc->offs = 0;
	if (sc->mode & AUMODE_PLAY) {
		if (sc->ops->trigger_output) {
			p.encoding = sc->hw_enc;
			p.precision = sc->bits;
			p.bps = sc->bps;
			p.msb = sc->msb;
			p.sample_rate = sc->rate;
			p.channels = sc->pchan;
			error = sc->ops->trigger_output(sc->arg,
			    sc->play.data,
			    sc->play.data + sc->play.len,
			    sc->play.blksz,
			    audio_pintr, (void *)sc, &p);
		} else {
			mtx_enter(&audio_lock);
			ptr = audio_buf_rgetblk(&sc->play, &count);
			error = sc->ops->start_output(sc->arg,
			    ptr, sc->play.blksz, audio_pintr, (void *)sc);
			mtx_leave(&audio_lock);
		}
		if (error)
			printf("%s: failed to start playback\n", DEVNAME(sc));
	}
	if (sc->mode & AUMODE_RECORD) {
		if (sc->ops->trigger_input) {
			p.encoding = sc->hw_enc;
			p.precision = sc->bits;
			p.bps = sc->bps;
			p.msb = sc->msb;
			p.sample_rate = sc->rate;
			p.channels = sc->rchan;
			error = sc->ops->trigger_input(sc->arg,
			    sc->rec.data,
			    sc->rec.data + sc->rec.len,
			    sc->rec.blksz,
			    audio_rintr, (void *)sc, &p);
		} else {
			mtx_enter(&audio_lock);
			ptr = audio_buf_wgetblk(&sc->rec, &count);
			error = sc->ops->start_input(sc->arg,
			    ptr, sc->rec.blksz, audio_rintr, (void *)sc);
			mtx_leave(&audio_lock);
		}
		if (error)
			printf("%s: failed to start recording\n", DEVNAME(sc));
	}
	return error;
}

int
audio_stop_do(struct audio_softc *sc)
{
	if (sc->mode & AUMODE_PLAY)
		sc->ops->halt_output(sc->arg);
	if (sc->mode & AUMODE_RECORD)
		sc->ops->halt_input(sc->arg);
	DPRINTF("%s: stopped\n", DEVNAME(sc));
	return 0;
}

int
audio_start(struct audio_softc *sc)
{
	sc->active = 1;
	sc->play.xrun = sc->play.pos = sc->rec.xrun = sc->rec.pos = 0;
	return audio_start_do(sc);
}

int
audio_stop(struct audio_softc *sc)
{
	int error;

	error = audio_stop_do(sc);
	if (error)
		return error;
	audio_clear(sc);
	sc->active = 0;
	return 0;
}

int
audio_canstart(struct audio_softc *sc)
{
	if (sc->active || sc->pause)
		return 0;
	if ((sc->mode & AUMODE_RECORD) && sc->rec.used != 0)
		return 0;
	if ((sc->mode & AUMODE_PLAY) && sc->play.used != sc->play.len)
		return 0;
	return 1;
}

int
audio_setpar(struct audio_softc *sc)
{
	struct audio_params p, r;
	unsigned int nr, np, max, min, mult;
	unsigned int blk_mult, blk_max;
	int error;

	DPRINTF("%s: setpar: req enc=%d bits=%d, bps=%d, msb=%d "
	    "rate=%d, pchan=%d, rchan=%d, round=%u, nblks=%d\n",
	    DEVNAME(sc), sc->sw_enc, sc->bits, sc->bps, sc->msb,
	    sc->rate, sc->pchan, sc->rchan, sc->round, sc->nblks);

	/*
	 * check if requested parameters are in the allowed ranges
	 */
	if (sc->mode & AUMODE_PLAY) {
		if (sc->pchan < 1)
			sc->pchan = 1;
		else if (sc->pchan > 64)
			sc->pchan = 64;
	}
	if (sc->mode & AUMODE_RECORD) {
		if (sc->rchan < 1)
			sc->rchan = 1;
		else if (sc->rchan > 64)
			sc->rchan = 64;
	}
	switch (sc->sw_enc) {
	case AUDIO_ENCODING_ULAW:
	case AUDIO_ENCODING_ALAW:
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		break;
	default:
		sc->sw_enc = AUDIO_ENCODING_SLINEAR_LE;
	}
	if (sc->bits < 8)
		sc->bits = 8;
	else if (sc->bits > 32)
		sc->bits = 32;
	if (sc->bps < 1)
		sc->bps = 1;
	else if (sc->bps > 4)
		sc->bps = 4;
	if (sc->rate < 4000)
		sc->rate = 4000;
	else if (sc->rate > 192000)
		sc->rate = 192000;

	/*
	 * copy into struct audio_params, required by drivers
	 */
	p.encoding = r.encoding = sc->sw_enc;
	p.precision = r.precision = sc->bits;
	p.bps = r.bps = sc->bps;
	p.msb = r.msb = sc->msb;
	p.sample_rate = r.sample_rate = sc->rate;
	p.channels = sc->pchan;
	r.channels = sc->rchan;

	/*
	 * set parameters
	 */
	error = sc->ops->set_params(sc->arg, sc->mode, sc->mode, &p, &r);
	if (error)
		return error;
	if (sc->mode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (p.encoding != r.encoding ||
		    p.precision != r.precision ||
		    p.bps != r.bps ||
		    p.msb != r.msb ||
		    p.sample_rate != r.sample_rate) {
			printf("%s: different play and record parameters "
			    "returned by hardware\n", DEVNAME(sc));
			return ENODEV;
		}
	}
	if (sc->mode & AUMODE_PLAY) {
		sc->hw_enc = p.encoding;
		sc->bits = p.precision;
		sc->bps = p.bps;
		sc->msb = p.msb;
		sc->rate = p.sample_rate;
		sc->pchan = p.channels;
	}
	if (sc->mode & AUMODE_RECORD) {
		sc->hw_enc = r.encoding;
		sc->bits = r.precision;
		sc->bps = r.bps;
		sc->msb = r.msb;
		sc->rate = r.sample_rate;
		sc->rchan = r.channels;
	}
	if (sc->rate == 0 || sc->bps == 0 || sc->bits == 0) {
		printf("%s: invalid parameters returned by hardware\n",
		    DEVNAME(sc));
		return ENODEV;
	}
	if (sc->ops->commit_settings) {
		error = sc->ops->commit_settings(sc->arg);
		if (error)
			return error;
	}

	/*
	 * conversion from/to exotic/dead encoding, for drivers not supporting
	 * linear
	 */
	switch (sc->hw_enc) {
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		sc->sw_enc = sc->hw_enc;
		sc->conv_dec = sc->conv_enc = NULL;
		break;
	case AUDIO_ENCODING_ULAW:
#if BYTE_ORDER == LITTLE_ENDIAN
		sc->sw_enc = AUDIO_ENCODING_SLINEAR_LE;
#else
		sc->sw_enc = AUDIO_ENCODING_SLINEAR_BE;
#endif
		if (sc->bits == 8) {
			sc->conv_enc = slinear8_to_mulaw;
			sc->conv_dec = mulaw_to_slinear8;
			break;
		} else if (sc->bits == 24) {
			sc->conv_enc = slinear24_to_mulaw24;
			sc->conv_dec = mulaw24_to_slinear24;
			break;
		}
		sc->sw_enc = sc->hw_enc;
		sc->conv_dec = sc->conv_enc = NULL;
		break;
	default:
		printf("%s: setpar: enc = %d, bits = %d: emulation skipped\n",
		    DEVNAME(sc), sc->hw_enc, sc->bits);
		sc->sw_enc = sc->hw_enc;
		sc->conv_dec = sc->conv_enc = NULL;
	}
	audio_calc_sil(sc);

	/*
	 * get least multiplier of the number of frames per block
	 */
	if (sc->ops->round_blocksize) {
		blk_mult = sc->ops->round_blocksize(sc->arg, 1);
		if (blk_mult == 0) {
			printf("%s: 0x%x: bad block size multiplier\n",
			    DEVNAME(sc), blk_mult);
			return ENODEV;
		}
	} else
		blk_mult = 1;
	DPRINTF("%s: hw block size multiplier: %u\n", DEVNAME(sc), blk_mult);
	if (sc->mode & AUMODE_PLAY) {
		np = blk_mult / audio_gcd(sc->pchan * sc->bps, blk_mult);
		if (!(sc->mode & AUMODE_RECORD))
			nr = np;
		DPRINTF("%s: play number of frames multiplier: %u\n",
		    DEVNAME(sc), np);
	}
	if (sc->mode & AUMODE_RECORD) {
		nr = blk_mult / audio_gcd(sc->rchan * sc->bps, blk_mult);
		if (!(sc->mode & AUMODE_PLAY))
			np = nr;
		DPRINTF("%s: record number of frames multiplier: %u\n",
		    DEVNAME(sc), nr);
	}
	mult = nr * np / audio_gcd(nr, np);
	DPRINTF("%s: least common number of frames multiplier: %u\n",
	    DEVNAME(sc), mult);

	/*
	 * get minimum and maximum frames per block
	 */
	if (sc->ops->round_blocksize)
		blk_max = sc->ops->round_blocksize(sc->arg, AUDIO_BUFSZ);
	else
		blk_max = AUDIO_BUFSZ;
	if ((sc->mode & AUMODE_PLAY) && blk_max > sc->play.datalen / 2)
		blk_max = sc->play.datalen / 2;
	if ((sc->mode & AUMODE_RECORD) && blk_max > sc->rec.datalen / 2)
		blk_max = sc->rec.datalen / 2;
	if (sc->mode & AUMODE_PLAY) {
		np = blk_max / (sc->pchan * sc->bps);
		if (!(sc->mode & AUMODE_RECORD))
			nr = np;
	}
	if (sc->mode & AUMODE_RECORD) {
		nr = blk_max / (sc->rchan * sc->bps);
		if (!(sc->mode & AUMODE_PLAY))
			np = nr;
	}
	max = np < nr ? np : nr;
	max -= max % mult;
	min = sc->rate / 1000 + mult - 1;
	min -= min % mult;
	DPRINTF("%s: frame number range: %u..%u\n", DEVNAME(sc), min, max);
	if (max < min) {
		printf("%s: %u: bad max frame number\n", DEVNAME(sc), max);
		return EIO;
	}

	/*
	 * adjust the frame per block to match our constraints
	 */
	sc->round += mult / 2;
	sc->round -= sc->round % mult;
	if (sc->round > max)
		sc->round = max;
	else if (sc->round < min)
		sc->round = min;
	sc->round = sc->round;

	/*
	 * set buffer size (number of blocks)
	 */
	if (sc->mode & AUMODE_PLAY) {
		sc->play.blksz = sc->round * sc->pchan * sc->bps;
		max = sc->play.datalen / sc->play.blksz;
		if (sc->nblks > max)
			sc->nblks = max;
		else if (sc->nblks < 2)
			sc->nblks = 2;
		sc->play.len = sc->nblks * sc->play.blksz;
		sc->nblks = sc->nblks;
	}
	if (sc->mode & AUMODE_RECORD) {
		/*
		 * for recording, buffer size is not the latency (it's
		 * exactly one block), so let's get the maximum buffer
		 * size of maximum reliability during xruns
		 */
		sc->rec.blksz = sc->round * sc->rchan * sc->bps;
		sc->rec.len = sc->rec.datalen;
		sc->rec.len -= sc->rec.datalen % sc->rec.blksz;
	}

	DPRINTF("%s: setpar: new enc=%d bits=%d, bps=%d, msb=%d "
	    "rate=%d, pchan=%d, rchan=%d, round=%u, nblks=%d\n",
	    DEVNAME(sc), sc->sw_enc, sc->bits, sc->bps, sc->msb,
	    sc->rate, sc->pchan, sc->rchan, sc->round, sc->nblks);
	return 0;
}

int
audio_ioc_start(struct audio_softc *sc)
{
	if (!sc->pause) {
		DPRINTF("%s: can't start: already started\n", DEVNAME(sc));
		return EBUSY;
	}
	if ((sc->mode & AUMODE_PLAY) && sc->play.used != sc->play.len) {
		DPRINTF("%s: play buffer not ready\n", DEVNAME(sc));
		return EBUSY;
	}
	if ((sc->mode & AUMODE_RECORD) && sc->rec.used != 0) {
		DPRINTF("%s: record buffer not ready\n", DEVNAME(sc));
		return EBUSY;
	}
	sc->pause = 0;
	return audio_start(sc);
}

int
audio_ioc_stop(struct audio_softc *sc)
{
	if (sc->pause) {
		DPRINTF("%s: can't stop: not started\n", DEVNAME(sc));
		return EBUSY;
	}
	sc->pause = 1;
	if (sc->active)
		return audio_stop(sc);
	return 0;
}

int
audio_ioc_getpar(struct audio_softc *sc, struct audio_swpar *p)
{
	p->rate = sc->rate;
	p->sig = sc->sw_enc == AUDIO_ENCODING_SLINEAR_LE ||
	    sc->sw_enc == AUDIO_ENCODING_SLINEAR_BE;
	p->le = sc->sw_enc == AUDIO_ENCODING_SLINEAR_LE ||
	    sc->sw_enc == AUDIO_ENCODING_ULINEAR_LE;
	p->bits = sc->bits;
	p->bps = sc->bps;
	p->msb = sc->msb;
	p->pchan = sc->pchan;
	p->rchan = sc->rchan;
	p->nblks = sc->nblks;
	p->round = sc->round;
	return 0;
}

int
audio_ioc_setpar(struct audio_softc *sc, struct audio_swpar *p)
{
	int error, le, sig;

	if (sc->active) {
		DPRINTF("%s: can't change params during dma\n",
		    DEVNAME(sc));
		return EBUSY;
	}

	/*
	 * copy desired parameters into the softc structure
	 */
	if (p->sig != ~0U || p->le != ~0U || p->bits != ~0U) {
		sig = 1;
		le = (BYTE_ORDER == LITTLE_ENDIAN);
		sc->bits = 16;
		sc->bps = 2;
		sc->msb = 1;
		if (p->sig != ~0U)
			sig = p->sig;
		if (p->le != ~0U)
			le = p->le;
		if (p->bits != ~0U) {
			sc->bits = p->bits;
			sc->bps = sc->bits <= 8 ?
			    1 : (sc->bits <= 16 ? 2 : 4);
			if (p->bps != ~0U)
				sc->bps = p->bps;
			if (p->msb != ~0U)
				sc->msb = p->msb ? 1 : 0;
		}
		sc->sw_enc = (sig) ?
		    (le ? AUDIO_ENCODING_SLINEAR_LE :
			AUDIO_ENCODING_SLINEAR_BE) :
		    (le ? AUDIO_ENCODING_ULINEAR_LE :
			AUDIO_ENCODING_ULINEAR_BE);
	}
	if (p->rate != ~0)
		sc->rate = p->rate;
	if (p->pchan != ~0)
		sc->pchan = p->pchan;
	if (p->rchan != ~0)
		sc->rchan = p->rchan;
	if (p->round != ~0)
		sc->round = p->round;
	if (p->nblks != ~0)
		sc->nblks = p->nblks;

	/*
	 * if the device is not opened for playback or recording don't
	 * touch the hardware yet (ex. if this is /dev/audioctlN)
	 */
	if (sc->mode == 0)
		return 0;

	/*
	 * negociate parameters with the hardware
	 */
	error = audio_setpar(sc);
	if (error)
		return error;
	audio_clear(sc);
	if ((sc->mode & AUMODE_PLAY) && sc->ops->init_output) {
		error = sc->ops->init_output(sc->arg,
		    sc->play.data, sc->play.len);
		if (error)
			return error;
	}
	if ((sc->mode & AUMODE_RECORD) && sc->ops->init_input) {
		error = sc->ops->init_input(sc->arg,
		    sc->rec.data, sc->rec.len);
		if (error)
			return error;
	}
	return 0;
}

int
audio_ioc_getstatus(struct audio_softc *sc, struct audio_status *p)
{
	p->mode = sc->mode;
	p->pause = sc->pause;
	p->active = sc->active;
	return 0;
}

int
audio_match(struct device *parent, void *match, void *aux)
{
	struct audio_attach_args *sa = aux;

	return (sa->type == AUDIODEV_TYPE_AUDIO) ? 1 : 0;
}

void
audio_attach(struct device *parent, struct device *self, void *aux)
{
	struct audio_softc *sc = (void *)self;
	struct audio_attach_args *sa = aux;
	struct audio_hw_if *ops = sa->hwif;
	void *arg = sa->hdl;
	int error;

	printf("\n");

#ifdef DIAGNOSTIC
	if (ops == 0 ||
	    ops->open == 0 ||
	    ops->close == 0 ||
	    ops->set_params == 0 ||
	    (ops->start_output == 0 && ops->trigger_output == 0) ||
	    (ops->start_input == 0 && ops->trigger_input == 0) ||
	    ops->halt_output == 0 ||
	    ops->halt_input == 0 ||
	    ops->set_port == 0 ||
	    ops->get_port == 0 ||
	    ops->query_devinfo == 0 ||
	    ops->get_props == 0) {
		printf("%s: missing method\n", DEVNAME(sc));
		sc->ops = 0;
		return;
	}
#endif
	sc->ops = ops;
	sc->arg = arg;

#if NWSKBD > 0
	wskbd_mixer_init(sc);
#endif /* NWSKBD > 0 */

	error = audio_buf_init(sc, &sc->play, AUMODE_PLAY);
	if (error) {
		sc->ops = 0;
		printf("%s: could not allocate play buffer\n", DEVNAME(sc));
		return;
	}
	error = audio_buf_init(sc, &sc->rec, AUMODE_RECORD);
	if (error) {
		audio_buf_done(sc, &sc->play);
		sc->ops = 0;
		printf("%s: could not allocate record buffer\n", DEVNAME(sc));
		return;
	}

	/* set defaults */
#if BYTE_ORDER == LITTLE_ENDIAN
	sc->sw_enc = AUDIO_ENCODING_SLINEAR_LE;
#else
	sc->sw_enc = AUDIO_ENCODING_SLINEAR_BE;
#endif
	sc->bits = 16;
	sc->bps = 2;
	sc->msb = 1;
	sc->rate = 48000;
	sc->pchan = 2;
	sc->rchan = 2;
	sc->round = 960;
	sc->nblks = 2;
	sc->play.pos = sc->play.xrun = sc->rec.pos = sc->rec.xrun = 0;
}

int
audio_activate(struct device *self, int act)
{
	struct audio_softc *sc = (struct audio_softc *)self;

	switch (act) {
	case DVACT_QUIESCE:
		/*
		 * good drivers run play and rec handlers in a single
		 * interrupt. Grab the lock to ensure we expose the same
		 * sc->quiesce value to both play and rec handlers
		 */
		mtx_enter(&audio_lock);
		sc->quiesce = 1;
		mtx_leave(&audio_lock);

		/*
		 * once sc->quiesce is set, interrupts may occur, but
		 * counters are not advanced and consequently processes
		 * keep sleeping.
		 *
		 * XXX: ensure read/write/ioctl don't start/stop
		 * DMA at the same time, this needs a "ready" condvar
		 */
		if (sc->mode != 0 && sc->active)
			audio_stop_do(sc);
		DPRINTF("%s: quiesce: active = %d\n", DEVNAME(sc), sc->active);
		break;
	case DVACT_WAKEUP:
		DPRINTF("%s: wakeup: active = %d\n", DEVNAME(sc), sc->active);

		/*
		 * keep buffer usage the same, but set start pointer to
		 * the beginning of the buffer.
		 *
		 * No need to grab the audio_lock as DMA is stopped and
		 * this is the only thread running (caller ensures this)
		 */
		sc->quiesce = 0;
		wakeup(&sc->quiesce);

		if (sc->mode != 0) {
			if (audio_setpar(sc) != 0)
				break;
			if (sc->mode & AUMODE_PLAY) {
				sc->play.start = 0;
				audio_fill_sil(sc, sc->play.data, sc->play.len);
			}
			if (sc->mode & AUMODE_RECORD) {
				sc->rec.start = sc->rec.len - sc->rec.used;
				audio_fill_sil(sc, sc->rec.data, sc->rec.len);
			}
			if (sc->active)
				audio_start_do(sc);
		}
		break;
	}
	return 0;
}

int
audio_detach(struct device *self, int flags)
{
	struct audio_softc *sc = (struct audio_softc *)self;
	int maj, mn;

	DPRINTF("%s: audio_detach: flags = %d\n", DEVNAME(sc), flags);

	wakeup(&sc->quiesce);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == audioopen)
			break;
	/*
	 * Nuke the vnodes for any open instances, calls close but as
	 * close uses device_lookup, it returns EXIO and does nothing
	 */
	mn = self->dv_unit;
	vdevgone(maj, mn | AUDIO_DEV_SOUND, mn | AUDIO_DEV_SOUND, VCHR);
	vdevgone(maj, mn | AUDIO_DEV_AUDIO, mn | AUDIO_DEV_AUDIO, VCHR);
	vdevgone(maj, mn | AUDIO_DEV_AUDIOCTL, mn | AUDIO_DEV_AUDIOCTL, VCHR);
	vdevgone(maj, mn | AUDIO_DEV_MIXER, mn | AUDIO_DEV_MIXER, VCHR);

	/*
	 * The close() method did nothing, quickly halt DMA (normally
	 * parent is already gone, and code below is no-op), and wake-up
	 * user-land blocked in read/write/ioctl, which return EIO.
	 */
	if (sc->mode != 0) {
		if (sc->active) {
			wakeup(&sc->play.blocking);
			selwakeup(&sc->play.sel);
			wakeup(&sc->rec.blocking);
			selwakeup(&sc->rec.sel);
			audio_stop(sc);
		}
		sc->ops->close(sc->arg);
		sc->mode = 0;
	}

	/* free resources */
	audio_buf_done(sc, &sc->play);
	audio_buf_done(sc, &sc->rec);
	return 0;
}

int
audio_submatch(struct device *parent, void *match, void *aux)
{
        struct cfdata *cf = match;

	return (cf->cf_driver == &audio_cd);
}

struct device *
audio_attach_mi(struct audio_hw_if *ops, void *arg, struct device *dev)
{
	struct audio_attach_args aa;

	aa.type = AUDIODEV_TYPE_AUDIO;
	aa.hwif = ops;
	aa.hdl = arg;

	/*
	 * attach this driver to the caller (hardware driver), this
	 * checks the kernel config and possibly calls audio_attach()
	 */
	return config_found_sm(dev, &aa, audioprint, audio_submatch);
}

int
audioprint(void *aux, const char *pnp)
{
	struct audio_attach_args *arg = aux;
	const char *type;

	if (pnp != NULL) {
		switch (arg->type) {
		case AUDIODEV_TYPE_AUDIO:
			type = "audio";
			break;
		case AUDIODEV_TYPE_OPL:
			type = "opl";
			break;
		case AUDIODEV_TYPE_MPU:
			type = "mpu";
			break;
		default:
			panic("audioprint: unknown type %d", arg->type);
		}
		printf("%s at %s", type, pnp);
	}
	return UNCONF;
}

int
audio_open(struct audio_softc *sc, int flags)
{
	int error;
	int props;

	if (sc->mode)
		return EBUSY;
	error = sc->ops->open(sc->arg, flags);
	if (error)
		return error;
	sc->active = 0;
	sc->pause = 1;
	sc->rec.blocking = 0;
	sc->play.blocking = 0;
	sc->mode = 0;
	if (flags & FWRITE)
		sc->mode |= AUMODE_PLAY;
	if (flags & FREAD)
		sc->mode |= AUMODE_RECORD;
	props = sc->ops->get_props(sc->arg);
	if (sc->mode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (!(props & AUDIO_PROP_FULLDUPLEX)) {
			error = ENOTTY;
			goto bad;
		}
		if (sc->ops->setfd) {
			error = sc->ops->setfd(sc->arg, 1);
			if (error)
				goto bad;
		}
	}

	if (sc->ops->speaker_ctl) {
		/*
		 * XXX: what is this used for?
		 */
		sc->ops->speaker_ctl(sc->arg,
		    (sc->mode & AUMODE_PLAY) ? SPKR_ON : SPKR_OFF);
	}

	error = audio_setpar(sc);
	if (error)
		goto bad;
	audio_clear(sc);

	/*
	 * allow read(2)/write(2) to automatically start DMA, without
	 * the need for ioctl(), to make /dev/audio usable in scripts
	 */
	sc->pause = 0;
	return 0;
bad:
	sc->ops->close(sc->arg);
	sc->mode = 0;
	return error;
}

int
audio_drain(struct audio_softc *sc)
{
	int error, xrun;
	unsigned char *ptr;
	size_t count, bpf;

	DPRINTF("%s: drain: mode = %d, pause = %d, active = %d, used = %zu\n",
	    DEVNAME(sc), sc->mode, sc->pause, sc->active, sc->play.used);
	if (!(sc->mode & AUMODE_PLAY) || sc->pause)
		return 0;

	/* discard partial samples, required by audio_fill_sil() */
	mtx_enter(&audio_lock);
	bpf = sc->pchan * sc->bps;
	sc->play.used -= sc->play.used % bpf;
	if (sc->play.used == 0) {
		mtx_leave(&audio_lock);
		return 0;
	}

	if (!sc->active) {
		/*
		 * dma not started yet because buffer was not full
		 * enough to start automatically. Pad it and start now.
		 */
		for (;;) {
			ptr = audio_buf_wgetblk(&sc->play, &count);
			if (count == 0)
				break;
			audio_fill_sil(sc, ptr, count);
			audio_buf_wcommit(&sc->play, count);
		}
		mtx_leave(&audio_lock);
		error = audio_start(sc);
		if (error)
			return error;
		mtx_enter(&audio_lock);
	}

	xrun = sc->play.xrun;
	while (sc->play.xrun == xrun) {
		DPRINTF("%s: drain: used = %zu, xrun = %d\n",
		    DEVNAME(sc), sc->play.used, sc->play.xrun);

		/*
		 * set a 5 second timeout, in case interrupts don't
		 * work, useful only for debugging drivers
		 */
		sc->play.blocking = 1;
		error = msleep(&sc->play.blocking, &audio_lock,
		    PWAIT | PCATCH, "au_dr", 5 * hz);
		if (!(sc->dev.dv_flags & DVF_ACTIVE))
			error = EIO;
		if (error) {
			DPRINTF("%s: drain, err = %d\n", DEVNAME(sc), error);
			break;
		}
	}
	mtx_leave(&audio_lock);
	return error;
}

int
audio_close(struct audio_softc *sc)
{
	audio_drain(sc);
	if (sc->active)
		audio_stop(sc);
	sc->ops->close(sc->arg);
	sc->mode = 0;
	DPRINTF("%s: close: done\n", DEVNAME(sc));
	return 0;
}

int
audio_read(struct audio_softc *sc, struct uio *uio, int ioflag)
{
	unsigned char *ptr;
	size_t count;
	int error;

	DPRINTFN(1, "%s: read: resid = %zd\n", DEVNAME(sc), uio->uio_resid);

	/* block if quiesced */
	while (sc->quiesce)
		tsleep(&sc->quiesce, 0, "au_qrd", 0);

	/* start automatically if audio_ioc_start() was never called */
	mtx_enter(&audio_lock);
	if (audio_canstart(sc)) {
		mtx_leave(&audio_lock);
		error = audio_start(sc);
		if (error)
			return error;
		mtx_enter(&audio_lock);
	}

	/* if there is no data then sleep */
	while (sc->rec.used == 0) {
		if (ioflag & IO_NDELAY) {
			mtx_leave(&audio_lock);
			return EWOULDBLOCK;
		}
		DPRINTFN(1, "%s: read sleep\n", DEVNAME(sc));
		sc->rec.blocking = 1;
		error = msleep(&sc->rec.blocking,
		    &audio_lock, PWAIT | PCATCH, "au_rd", 0);
		if (!(sc->dev.dv_flags & DVF_ACTIVE))
			error = EIO;
		if (error) {
			DPRINTF("%s: read woke up error = %d\n",
			    DEVNAME(sc), error);
			mtx_leave(&audio_lock);
			return error;
		}
	}

	/* at this stage, there is data to transfer */
	while (uio->uio_resid > 0 && sc->rec.used > 0) {
		ptr = audio_buf_rgetblk(&sc->rec, &count);
		if (count > uio->uio_resid)
			count = uio->uio_resid;
		audio_buf_rdiscard(&sc->rec, count);
		mtx_leave(&audio_lock);
		DPRINTFN(1, "%s: read: start = %zu, count = %zu\n",
		    DEVNAME(sc), ptr - sc->rec.data, count);
		if (sc->conv_dec)
			sc->conv_dec(ptr, count);
		error = uiomove(ptr, count, uio);
		if (error)
			return error;
		mtx_enter(&audio_lock);
	}
	mtx_leave(&audio_lock);
	return 0;
}

int
audio_write(struct audio_softc *sc, struct uio *uio, int ioflag)
{
	unsigned char *ptr;
	size_t count;
	int error;

	DPRINTFN(1, "%s: write: resid = %zd\n",  DEVNAME(sc), uio->uio_resid);

	/* block if quiesced */
	while (sc->quiesce)
		tsleep(&sc->quiesce, 0, "au_qwr", 0);

	/*
	 * if IO_NDELAY flag is set then check if there is enough room
	 * in the buffer to store at least one byte. If not then don't
	 * start the write process.
	 */
	mtx_enter(&audio_lock);
	if (uio->uio_resid > 0 && (ioflag & IO_NDELAY)) {
		if (sc->play.used == sc->play.len) {
			mtx_leave(&audio_lock);
			return EWOULDBLOCK;
		}
	}

	while (uio->uio_resid > 0) {
		while (1) {
			ptr = audio_buf_wgetblk(&sc->play, &count);
			if (count > 0)
				break;
			if (ioflag & IO_NDELAY) {
				/*
				 * At this stage at least one byte is already
				 * moved so we do not return EWOULDBLOCK
				 */
				mtx_leave(&audio_lock);
				return 0;
			}
			DPRINTFN(1, "%s: write sleep\n", DEVNAME(sc));
			sc->play.blocking = 1;
			error = msleep(&sc->play.blocking,
			    &audio_lock, PWAIT | PCATCH, "au_wr", 0);
			if (!(sc->dev.dv_flags & DVF_ACTIVE))
				error = EIO;
			if (error) {
				DPRINTF("%s: write woke up error = %d\n",
				    DEVNAME(sc), error);
				mtx_leave(&audio_lock);
				return error;
			}
		}
		if (count > uio->uio_resid)
			count = uio->uio_resid;
		audio_buf_wcommit(&sc->play, count);
		mtx_leave(&audio_lock);
		error = uiomove(ptr, count, uio);
		if (error)
			return 0;
		if (sc->conv_enc) {
			sc->conv_enc(ptr, count);
			DPRINTFN(1, "audio_write: converted count = %zu\n",
			    count);
		}

		/* start automatically if audio_ioc_start() was never called */
		if (audio_canstart(sc)) {
			error = audio_start(sc);
			if (error)
				return error;
		}
		mtx_enter(&audio_lock);
	}
	mtx_leave(&audio_lock);
	return 0;
}

int
audio_getdev(struct audio_softc *sc, struct audio_device *adev)
{
	memset(adev, 0, sizeof(struct audio_device));
	if (sc->dev.dv_parent == NULL)
		return EIO;
	strlcpy(adev->name, sc->dev.dv_parent->dv_xname, MAX_AUDIO_DEV_LEN);
	return 0;
}

int
audio_ioctl(struct audio_softc *sc, unsigned long cmd, void *addr)
{
	struct audio_pos *ap;
	int error = 0;

	/* block if quiesced */
	while (sc->quiesce)
		tsleep(&sc->quiesce, 0, "au_qio", 0);

	switch (cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer. */
		break;
	case AUDIO_GETPOS:
		mtx_enter(&audio_lock);
		ap = (struct audio_pos *)addr;
		ap->play_pos = sc->play.pos;
		ap->play_xrun = sc->play.xrun;
		ap->rec_pos = sc->rec.pos;
		ap->rec_xrun = sc->rec.xrun;
		mtx_leave(&audio_lock);
		break;
	case AUDIO_START:
		return audio_ioc_start(sc);
	case AUDIO_STOP:
		return audio_ioc_stop(sc);
	case AUDIO_SETPAR:
		error = audio_ioc_setpar(sc, (struct audio_swpar *)addr);
		break;
	case AUDIO_GETPAR:
		error = audio_ioc_getpar(sc, (struct audio_swpar *)addr);
		break;
	case AUDIO_GETSTATUS:
		error = audio_ioc_getstatus(sc, (struct audio_status *)addr);
		break;
	case AUDIO_GETDEV:
		error = audio_getdev(sc, (struct audio_device *)addr);
		break;
	default:
		DPRINTF("%s: unknown ioctl 0x%lx\n", DEVNAME(sc), cmd);
		error = ENOTTY;
		break;
	}
	return error;
}

int
audio_ioctl_mixer(struct audio_softc *sc, unsigned long cmd, void *addr)
{
	int error;

	/* block if quiesced */
	while (sc->quiesce)
		tsleep(&sc->quiesce, 0, "mix_qio", 0);

	switch (cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer. */
		break;
	case AUDIO_MIXER_DEVINFO:
		((mixer_devinfo_t *)addr)->un.v.delta = 0;
		return sc->ops->query_devinfo(sc->arg, (mixer_devinfo_t *)addr);
	case AUDIO_MIXER_READ:
		return sc->ops->get_port(sc->arg, (mixer_ctrl_t *)addr);
	case AUDIO_MIXER_WRITE:
		error = sc->ops->set_port(sc->arg, (mixer_ctrl_t *)addr);
		if (error)
			return error;
		if (sc->ops->commit_settings)
			return sc->ops->commit_settings(sc->arg);
		break;
	default:
		return ENOTTY;
	}
	return 0;
}

int
audio_poll(struct audio_softc *sc, int events, struct proc *p)
{
	int revents = 0;

	mtx_enter(&audio_lock);
	if ((sc->mode & AUMODE_RECORD) && sc->rec.used > 0)
		revents |= events & (POLLIN | POLLRDNORM);
	if ((sc->mode & AUMODE_PLAY) && sc->play.used < sc->play.len)
		revents |= events & (POLLOUT | POLLWRNORM);
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->rec.sel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->play.sel);
	}
	mtx_leave(&audio_lock);
	return revents;
}

int
audioopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct audio_softc *sc;
	int error;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return ENXIO;
	if (sc->ops == NULL)
		error = ENXIO;
	else {
		switch (AUDIO_DEV(dev)) {
		case AUDIO_DEV_SOUND:
		case AUDIO_DEV_AUDIO:
			error = audio_open(sc, flags);
			break;
		case AUDIO_DEV_AUDIOCTL:
		case AUDIO_DEV_MIXER:
			error = 0;
			break;
		default:
			error = ENXIO;
		}
	}
	device_unref(&sc->dev);
	return error;
}

int
audioclose(dev_t dev, int flags, int ifmt, struct proc *p)
{
	struct audio_softc *sc;
	int error;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return ENXIO;
	switch (AUDIO_DEV(dev)) {
	case AUDIO_DEV_SOUND:
	case AUDIO_DEV_AUDIO:
		error = audio_close(sc);
		break;
	case AUDIO_DEV_MIXER:
	case AUDIO_DEV_AUDIOCTL:
		error = 0;
		break;
	default:
		error = ENXIO;
	}
	device_unref(&sc->dev);
	return error;
}

int
audioread(dev_t dev, struct uio *uio, int ioflag)
{
	struct audio_softc *sc;
	int error;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return ENXIO;
	switch (AUDIO_DEV(dev)) {
	case AUDIO_DEV_SOUND:
	case AUDIO_DEV_AUDIO:
		error = audio_read(sc, uio, ioflag);
		break;
	case AUDIO_DEV_AUDIOCTL:
	case AUDIO_DEV_MIXER:
		error = ENODEV;
		break;
	default:
		error = ENXIO;
	}
	device_unref(&sc->dev);
	return error;
}

int
audiowrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct audio_softc *sc;
	int error;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return ENXIO;
	switch (AUDIO_DEV(dev)) {
	case AUDIO_DEV_SOUND:
	case AUDIO_DEV_AUDIO:
		error = audio_write(sc, uio, ioflag);
		break;
	case AUDIO_DEV_AUDIOCTL:
	case AUDIO_DEV_MIXER:
		error = ENODEV;
		break;
	default:
		error = ENXIO;
	}
	device_unref(&sc->dev);
	return error;
}

int
audioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct audio_softc *sc;
	int error;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return ENXIO;
	switch (AUDIO_DEV(dev)) {
	case AUDIO_DEV_SOUND:
	case AUDIO_DEV_AUDIO:
		error = audio_ioctl(sc, cmd, addr);
		break;
	case AUDIO_DEV_AUDIOCTL:
		if (cmd == AUDIO_SETPAR && sc->mode != 0) {
			error = EBUSY;
			break;
		}
		if (cmd == AUDIO_START || cmd == AUDIO_STOP) {
			error = ENXIO;
			break;
		}
		error = audio_ioctl(sc, cmd, addr);
		break;
	case AUDIO_DEV_MIXER:
		error = audio_ioctl_mixer(sc, cmd, addr);
		break;
	default:
		error = ENXIO;
	}
	device_unref(&sc->dev);
	return error;
}

int
audiopoll(dev_t dev, int events, struct proc *p)
{
	struct audio_softc *sc;
	int revents;

	sc = (struct audio_softc *)device_lookup(&audio_cd, AUDIO_UNIT(dev));
	if (sc == NULL)
		return POLLERR;
	switch (AUDIO_DEV(dev)) {
	case AUDIO_DEV_SOUND:
	case AUDIO_DEV_AUDIO:
		revents = audio_poll(sc, events, p);
		break;
	case AUDIO_DEV_AUDIOCTL:
	case AUDIO_DEV_MIXER:
		revents = 0;
		break;
	default:
		revents = 0;
	}
	device_unref(&sc->dev);
	return revents;
}

#if NWSKBD > 0
int
wskbd_initmute(struct audio_softc *sc, struct mixer_devinfo *vol)
{
	struct mixer_devinfo *mi;
	int index = -1;

	mi = malloc(sizeof(struct mixer_devinfo), M_TEMP, M_WAITOK);

	for (mi->index = vol->next; mi->index != -1; mi->index = mi->next) {
		if (sc->ops->query_devinfo(sc->arg, mi) != 0)
			break;
		if (strcmp(mi->label.name, AudioNmute) == 0) {
			index = mi->index;
			break;
		}
	}

	free(mi, M_TEMP, sizeof(struct mixer_devinfo));
	return index;
}

int
wskbd_initvol(struct audio_softc *sc, struct wskbd_vol *vol, char *cn, char *dn)
{
	struct mixer_devinfo *dev, *cls;

	vol->val = vol->mute = -1;
	dev = malloc(sizeof(struct mixer_devinfo), M_TEMP, M_WAITOK);
	cls = malloc(sizeof(struct mixer_devinfo), M_TEMP, M_WAITOK);

	for (dev->index = 0; ; dev->index++) {
		if (sc->ops->query_devinfo(sc->arg, dev) != 0)
			break;
		if (dev->type != AUDIO_MIXER_VALUE)
			continue;
		cls->index = dev->mixer_class;
		if (sc->ops->query_devinfo(sc->arg, cls) != 0)
			continue;
		if (strcmp(cls->label.name, cn) == 0 &&
		    strcmp(dev->label.name, dn) == 0) {
			vol->val = dev->index;
			vol->nch = dev->un.v.num_channels;
			vol->step = dev->un.v.delta > 8 ? dev->un.v.delta : 8;
			vol->mute = wskbd_initmute(sc, dev);
			vol->val_pending = vol->mute_pending = 0;
			DPRINTF("%s: wskbd using %s.%s%s\n", DEVNAME(sc),
			    cn, dn, vol->mute >= 0 ? ", mute control" : "");
			break;
		}
	}

	free(cls, M_TEMP, sizeof(struct mixer_devinfo));
	free(dev, M_TEMP, sizeof(struct mixer_devinfo));
	return (vol->val != -1);
}

void
wskbd_mixer_init(struct audio_softc *sc)
{
	static struct {
		char *cn, *dn;
	} spkr_names[] = {
		{AudioCoutputs, AudioNmaster},
		{AudioCinputs,  AudioNdac},
		{AudioCoutputs, AudioNdac},
		{AudioCoutputs, AudioNoutput}
	}, mic_names[] = {
		{AudioCrecord, AudioNrecord},
		{AudioCrecord, AudioNvolume},
		{AudioCinputs, AudioNrecord},
		{AudioCinputs, AudioNvolume},
		{AudioCinputs, AudioNinput}
	};
	int i;

	if (sc->dev.dv_unit != 0) {
		DPRINTF("%s: not configuring wskbd keys\n", DEVNAME(sc));
		return;
	}
	for (i = 0; i < sizeof(spkr_names) / sizeof(spkr_names[0]); i++) {
		if (wskbd_initvol(sc, &sc->spkr,
			spkr_names[i].cn, spkr_names[i].dn))
			break;
	}
	for (i = 0; i < sizeof(mic_names) / sizeof(mic_names[0]); i++) {
		if (wskbd_initvol(sc, &sc->mic,
			mic_names[i].cn, mic_names[i].dn))
			break;
	}
}

void
wskbd_mixer_update(struct audio_softc *sc, struct wskbd_vol *vol)
{
	struct mixer_ctrl ctrl;
	int val_pending, mute_pending, i, gain, error, s;

	s = spltty();
	val_pending = vol->val_pending;
	vol->val_pending = 0;
	mute_pending = vol->mute_pending;
	vol->mute_pending = 0;
	splx(s);

	if (sc->ops == NULL)
		return;
	if (vol->mute >= 0 && mute_pending) {
		ctrl.dev = vol->mute;
		ctrl.type = AUDIO_MIXER_ENUM;
		error = sc->ops->get_port(sc->arg, &ctrl);
		if (error) {
			DPRINTF("%s: get mute err = %d\n", DEVNAME(sc), error);
			return;
		}
		switch (mute_pending) {
		case WSKBD_MUTE_TOGGLE:
			ctrl.un.ord = !ctrl.un.ord;
			break;
		case WSKBD_MUTE_DISABLE:
			ctrl.un.ord = 0;
			break;
		case WSKBD_MUTE_ENABLE:
			ctrl.un.ord = 1;
			break;
		}
		DPRINTFN(1, "%s: wskbd mute setting to %d\n",
		    DEVNAME(sc), ctrl.un.ord);
		error = sc->ops->set_port(sc->arg, &ctrl);
		if (error) {
			DPRINTF("%s: set mute err = %d\n", DEVNAME(sc), error);
			return;
		}
	}
	if (vol->val >= 0 && val_pending) {
		ctrl.dev = vol->val;
		ctrl.type = AUDIO_MIXER_VALUE;
		ctrl.un.value.num_channels = vol->nch;
		error = sc->ops->get_port(sc->arg, &ctrl);
		if (error) {
			DPRINTF("%s: get mute err = %d\n", DEVNAME(sc), error);
			return;
		}
		for (i = 0; i < vol->nch; i++) {
			gain = ctrl.un.value.level[i] + vol->step * val_pending;
			if (gain > AUDIO_MAX_GAIN)
				gain = AUDIO_MAX_GAIN;
			else if (gain < AUDIO_MIN_GAIN)
				gain = AUDIO_MIN_GAIN;
			ctrl.un.value.level[i] = gain;
			DPRINTFN(1, "%s: wskbd level %d set to %d\n",
			    DEVNAME(sc), i, gain);
		}
		error = sc->ops->set_port(sc->arg, &ctrl);
		if (error) {
			DPRINTF("%s: set vol err = %d\n", DEVNAME(sc), error);
			return;
		}
	}
}

void
wskbd_mixer_cb(void *addr)
{
	struct audio_softc *sc = addr;
	int s;

	wskbd_mixer_update(sc, &sc->spkr);
	wskbd_mixer_update(sc, &sc->mic);
	s = spltty();
	sc->wskbd_taskset = 0;
	splx(s);
	device_unref(&sc->dev);
}

int
wskbd_set_mixermute(long mute, long out)
{
	struct audio_softc *sc;
	struct wskbd_vol *vol;

	sc = (struct audio_softc *)device_lookup(&audio_cd, 0);
	if (sc == NULL)
		return ENODEV;
	vol = out ? &sc->spkr : &sc->mic;
	vol->mute_pending = mute ? WSKBD_MUTE_ENABLE : WSKBD_MUTE_DISABLE;
	if (!sc->wskbd_taskset) {
		task_set(&sc->wskbd_task, wskbd_mixer_cb, sc);
		task_add(systq, &sc->wskbd_task);
		sc->wskbd_taskset = 1;
	}
	return 0;
}

int
wskbd_set_mixervolume(long dir, long out)
{
	struct audio_softc *sc;
	struct wskbd_vol *vol;

	sc = (struct audio_softc *)device_lookup(&audio_cd, 0);
	if (sc == NULL)
		return ENODEV;
	vol = out ? &sc->spkr : &sc->mic;
	if (dir == 0)
		vol->mute_pending ^= WSKBD_MUTE_TOGGLE;
	else
		vol->val_pending += dir;
	if (!sc->wskbd_taskset) {
		task_set(&sc->wskbd_task, wskbd_mixer_cb, sc);
		task_add(systq, &sc->wskbd_task);
		sc->wskbd_taskset = 1;
	}
	return 0;
}
#endif /* NWSKBD > 0 */
@


1.161
log
@AUDIO_ENCODING_{S,U}LINEAR constants are neither used by low level
drivers nor exposed to user-land. Remove definitions and code to
handle convertions.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.160 2017/01/03 06:42:11 ratchov Exp $	*/
d618 1
a618 1
		if (sc->pchan > 64)
d624 1
a624 1
		if (sc->rchan > 64)
d640 1
a640 1
	if (sc->bits > 32)
d644 1
a644 1
	if (sc->bps > 4)
d648 1
a648 1
	if (sc->rate > 192000)
d813 1
a813 1
	if (sc->round < min)
d825 1
a825 1
		if (sc->nblks < 2)
@


1.160
log
@If gain is above MAX, no need to check whether it's below MIN.
From Michael W. Bombardieri. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.159 2016/12/20 15:59:07 ratchov Exp $	*/
a610 19

	/*
	 * AUDIO_ENCODING_SLINEAR and AUDIO_ENCODING_ULINEAR are not
	 * used anymore, promote them to the _LE and _BE equivalents
	 */
	if (sc->sw_enc == AUDIO_ENCODING_SLINEAR) {
#if BYTE_ORDER == LITTLE_ENDIAN
		sc->sw_enc = AUDIO_ENCODING_SLINEAR_LE;
#else
		sc->sw_enc = AUDIO_ENCODING_SLINEAR_BE;
#endif
	}
	if (sc->sw_enc == AUDIO_ENCODING_ULINEAR) {
#if BYTE_ORDER == LITTLE_ENDIAN
		sc->sw_enc = AUDIO_ENCODING_ULINEAR_LE;
#else
		sc->sw_enc = AUDIO_ENCODING_ULINEAR_BE;
#endif
	}
@


1.159
log
@Fix many typos. From Michael W. Bombardieri <mb at ii.net>. Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.158 2016/12/12 06:23:03 ratchov Exp $	*/
d1928 1
a1928 1
			if (gain < AUDIO_MIN_GAIN)
@


1.158
log
@Remove few useless #ifdef AUDIO_DEBUG, spotted by
Michael W. Bombardieri <mb at ii.net>. Thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.157 2016/11/08 06:04:25 ratchov Exp $	*/
d222 1
a222 1
 * discard "count" bytes at the start postion.
d365 1
a365 1
		DPRINTF("%s: quesced, skipping play intr\n", DEVNAME(sc));
d436 1
a436 1
		DPRINTF("%s: quesced, skipping rec intr\n", DEVNAME(sc));
d795 1
a795 1
	 * get minumum and maximum frames per block
d1106 1
a1106 1
		DPRINTF("%s: quesce: active = %d\n", DEVNAME(sc), sc->active);
d1121 1
a1121 1
		if(sc->mode != 0) {
d1447 1
a1447 1
	 * in the buffer to store at least one byte. If not then dont
@


1.157
log
@Log start/stop of DMA if AUDIO_DEBUG is defined and be less verbose
about buffer parameters. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.156 2016/10/09 11:37:23 kettenis Exp $	*/
a1403 1
#ifdef AUDIO_DEBUG
a1406 3
		}
#endif
		if (error) {
d1417 1
a1426 1
		audio_buf_rdiscard(&sc->rec, count);
a1476 1
#ifdef AUDIO_DEBUG
a1479 3
			}
#endif
			if (error) {
d1486 1
a1495 2
		mtx_enter(&audio_lock);
		audio_buf_wcommit(&sc->play, count);
a1498 1
			mtx_leave(&audio_lock);
a1501 1
			mtx_enter(&audio_lock);
d1503 1
@


1.156
log
@Don't allocate struct mixer_devinfo instances on the stack.  It is a fairly
large data structure and if the compiler gets clever and inlines some code
we hit the stack size compiler warning.  This makes things compile with clang.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.155 2016/10/06 05:29:19 ratchov Exp $	*/
d502 1
a502 10
	DPRINTFN(1, "%s: start play: "
	    "start = %zu, used = %zu, "
	    "len = %zu, blksz = %zu\n",
	    DEVNAME(sc), sc->play.start, sc->play.used,
	    sc->play.len, sc->play.blksz);
	DPRINTFN(1, "%s: start rec: "
	    "start = %zu, used = %zu, "
	    "len = %zu, blksz = %zu\n",
	    DEVNAME(sc), sc->rec.start, sc->rec.used,
	    sc->rec.len, sc->rec.blksz);
d562 1
@


1.155
log
@Fix the condition used to decide whether to automatically start the
device, and factor it into a single function. Without this fix, if the
device is open in full-duplex mode, it could start with empty play
buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.154 2016/10/04 23:02:03 deraadt Exp $	*/
d1803 2
a1804 1
	struct mixer_devinfo mi;
d1806 7
a1812 3
	mi.index = vol->next;
	for (mi.index = vol->next; mi.index != -1; mi.index = mi.next) {
		if (sc->ops->query_devinfo(sc->arg, &mi) != 0)
d1814 1
a1814 2
		if (strcmp(mi.label.name, AudioNmute) == 0)
			return mi.index;
d1816 3
a1818 1
	return -1;
d1824 5
a1828 1
	struct mixer_devinfo dev, cls;
d1830 2
a1831 2
	for (dev.index = 0; ; dev.index++) {
		if (sc->ops->query_devinfo(sc->arg, &dev) != 0)
d1833 1
a1833 1
		if (dev.type != AUDIO_MIXER_VALUE)
d1835 2
a1836 2
		cls.index = dev.mixer_class;
		if (sc->ops->query_devinfo(sc->arg, &cls) != 0)
d1838 6
a1843 6
		if (strcmp(cls.label.name, cn) == 0 &&
		    strcmp(dev.label.name, dn) == 0) {
			vol->val = dev.index;
			vol->nch = dev.un.v.num_channels;
			vol->step = dev.un.v.delta > 8 ? dev.un.v.delta : 8;
			vol->mute = wskbd_initmute(sc, &dev);
d1845 3
a1847 3
			DPRINTF("%s: wskbd using %s.%s%s\n",
			    DEVNAME(sc), cn, dn, vol->mute >= 0 ? ", mute control" : "");
			return 1;
d1850 4
a1853 2
	vol->val = vol->mute = -1;
	return 0;
@


1.154
log
@At acpithinkpad attach time determine the value of the mute, and defer
telling the audio subsystem about this later on in boot.  (Mute state
is maintained by the BIOS over a suspend, hibernate, reboot, etc -- this
may be last missing piece of the puzzle we tore our hair out in Brisbane)
diagnosis and code by Anton Lindqvist, ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.153 2016/09/19 06:46:43 ratchov Exp $	*/
d596 12
d1392 1
a1392 1
	if (!sc->active && !sc->pause && sc->rec.used == 0) {
d1515 1
a1515 2
		if (!sc->active && !sc->pause &&
		    sc->play.used == sc->play.len) {
@


1.153
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.152 2016/09/14 06:12:19 ratchov Exp $	*/
d83 4
a86 1
	int mute_pending;		/* pending mute toggles */
d1891 11
a1901 1
		ctrl.un.ord = ctrl.un.ord ^ mute_pending;
d1952 19
d1981 1
a1981 1
		vol->mute_pending ^= 1;
@


1.152
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.147 2016/05/11 16:16:58 ratchov Exp $	*/
a1025 1
	    ops->getdev == 0 ||
@


1.151
log
@Delete unused ioctls and associated macros. Move macros that are still
used internally by low-level drivers from sys/audioio.h to
dev/audio_if.h instead of deleting them.
@
text
@a1020 1
	    ops->query_encoding == 0 ||
@


1.150
log
@fix typos in comments and spacing
@
text
@a860 174
audio_setinfo(struct audio_softc *sc, struct audio_info *ai)
{
	struct audio_prinfo *r = &ai->record, *p = &ai->play;
	int error;
	int set;

	/*
	 * stop the device if requested to stop
	 */
	if (sc->mode != 0) {
		if (sc->mode & AUMODE_PLAY) {
			if (p->pause != (unsigned char)~0)
				sc->pause = p->pause;
		}
		if (sc->mode & AUMODE_RECORD) {
			if (r->pause != (unsigned char)~0)
				sc->pause = r->pause;
		}
		if (sc->pause) {
			if (sc->active)
				audio_stop(sc);
		}
	}

	/*
	 * copy parameters into the softc structure
	 */
	set = 0;
	if (ai->play.encoding != ~0) {
		sc->sw_enc = ai->play.encoding;
		set = 1;
	}
	if (ai->play.precision != ~0) {
		sc->bits = ai->play.precision;
		set = 1;
	}
	if (ai->play.bps != ~0) {
		sc->bps = ai->play.bps;
		set = 1;
	}
	if (ai->play.msb != ~0) {
		sc->msb = ai->play.msb;
		set = 1;
	}
	if (ai->play.sample_rate != ~0) {
		sc->rate = ai->play.sample_rate;
		set = 1;
	}
	if (ai->play.channels != ~0) {
		sc->pchan = ai->play.channels;
		set = 1;
	}
	if (ai->play.block_size != ~0) {
		sc->round = ai->play.block_size /
		    (sc->bps * sc->pchan);
		set = 1;
	}
	if (ai->hiwat != ~0) {
		sc->nblks = ai->hiwat;
		set = 1;
	}
	if (ai->record.encoding != ~0) {
		sc->sw_enc = ai->record.encoding;
		set = 1;
	}
	if (ai->record.precision != ~0) {
		sc->bits = ai->record.precision;
		set = 1;
	}
	if (ai->record.bps != ~0) {
		sc->bps = ai->record.bps;
		set = 1;
	}
	if (ai->record.msb != ~0) {
		sc->msb = ai->record.msb;
		set = 1;
	}
	if (ai->record.sample_rate != ~0) {
		sc->rate = ai->record.sample_rate;
		set = 1;
	}
	if (ai->record.channels != ~0) {
		sc->rchan = ai->record.channels;
		set = 1;
	}
	if (ai->record.block_size != ~0) {
		sc->round = ai->record.block_size /
		    (sc->bps * sc->rchan);
		set = 1;
	}

	DPRINTF("%s: setinfo: set = %d, mode = %d, pause = %d\n",
	    DEVNAME(sc), set, sc->mode, sc->pause);

	/*
	 * if the device not opened, we're done, don't touch the hardware
	 */
	if (sc->mode == 0)
		return 0;

	/*
	 * change parameters and recalculate buffer sizes
	 */
	if (set) {
		if (sc->active) {
			DPRINTF("%s: can't change params during dma\n",
			    DEVNAME(sc));
			return EBUSY;
		}
		error = audio_setpar(sc);
		if (error)
			return error;
		audio_clear(sc);
		if ((sc->mode & AUMODE_PLAY) && sc->ops->init_output) {
			error = sc->ops->init_output(sc->arg,
			    sc->play.data, sc->play.len);
			if (error)
				return error;
		}
		if ((sc->mode & AUMODE_RECORD) && sc->ops->init_input) {
			error = sc->ops->init_input(sc->arg,
			    sc->rec.data, sc->rec.len);
			if (error)
				return error;
		}
	}

	/*
	 * if unpaused, start
	 */
	if (!sc->pause && !sc->active) {
		error = audio_start(sc);
		if (error)
			return error;
	}
	return 0;
}

int
audio_getinfo(struct audio_softc *sc, struct audio_info *ai)
{
	ai->play.sample_rate = ai->record.sample_rate = sc->rate;
	ai->play.encoding = ai->record.encoding = sc->sw_enc;
	ai->play.precision = ai->record.precision = sc->bits;
	ai->play.bps = ai->record.bps = sc->bps;
	ai->play.msb = ai->record.msb = sc->msb;
	ai->play.channels = sc->pchan;
	ai->record.channels = sc->rchan;

	/*
	 * XXX: this is used only to display counters through audioctl
	 * and the pos counters are more useful
	 */
	mtx_enter(&audio_lock);
	ai->play.samples = sc->play.pos - sc->play.xrun;
	ai->record.samples = sc->rec.pos - sc->rec.xrun;
	mtx_leave(&audio_lock);

	ai->play.pause = ai->record.pause = sc->pause;
	ai->play.active = ai->record.active = sc->active;

	ai->play.buffer_size = sc->play.datalen;
	ai->record.buffer_size = sc->rec.datalen;

	ai->play.block_size =  sc->round * sc->bps * sc->pchan;
	ai->record.block_size = sc->round * sc->bps * sc->rchan;

	ai->hiwat = sc->nblks;
	ai->lowat = sc->nblks;
	ai->mode = sc->mode;
	return 0;
}

int
a1527 1
	struct audio_offset *ao;
d1529 1
a1529 1
	int error = 0, fd;
a1538 22
	case AUDIO_PERROR:
		mtx_enter(&audio_lock);
		*(int *)addr = sc->play.xrun / (sc->pchan * sc->bps);
		mtx_leave(&audio_lock);
		break;
	case AUDIO_RERROR:
		mtx_enter(&audio_lock);
		*(int *)addr = sc->rec.xrun / (sc->rchan * sc->bps);
		mtx_leave(&audio_lock);
		break;
	case AUDIO_GETOOFFS:
		mtx_enter(&audio_lock);
		ao = (struct audio_offset *)addr;
		ao->samples = sc->play.pos;
		mtx_leave(&audio_lock);
		break;
	case AUDIO_GETIOFFS:
		mtx_enter(&audio_lock);
		ao = (struct audio_offset *)addr;
		ao->samples = sc->rec.pos;
		mtx_leave(&audio_lock);
		break;
a1560 6
	case AUDIO_SETINFO:
		error = audio_setinfo(sc, (struct audio_info *)addr);
		break;
	case AUDIO_GETINFO:
		error = audio_getinfo(sc, (struct audio_info *)addr);
		break;
a1563 17
	case AUDIO_GETENC:
		error = sc->ops->query_encoding(sc->arg,
		    (struct audio_encoding *)addr);
		break;
	case AUDIO_GETFD:
		*(int *)addr = (sc->mode & (AUMODE_PLAY | AUMODE_RECORD)) ==
		    (AUMODE_PLAY | AUMODE_RECORD);
		break;
	case AUDIO_SETFD:
		fd = *(int *)addr;
		if ((sc->mode & (AUMODE_PLAY | AUMODE_RECORD)) !=
		    (AUMODE_PLAY | AUMODE_RECORD) || !fd)
			return EINVAL;
		break;
	case AUDIO_GETPROPS:
		*(int *)addr = sc->ops->get_props(sc->arg);
		break;
a1741 4
		if (cmd == AUDIO_SETINFO && sc->mode != 0) {
			error = EBUSY;
			break;
		}
@


1.149
log
@Add a new AUDIO_GETSTATUS ioctl to get various audio driver variables.
It's intended for use with diagnostic tools (like audioctl) and is of
no use to audio programs.
@
text
@d1545 1
a1545 1
	DPRINTFN(1, "%s: read: resid = %zd\n",  DEVNAME(sc), uio->uio_resid);
d1551 1
a1551 1
	/* start automatically if setinfo() was never called */
d1675 1
a1675 1
		/* start automatically if setinfo() was never called */
@


1.148
log
@New USB device driver for Audio/Video capture devices based on the
Fushicai USBTV007 chip.

The chip specific code has been written by Lubomir Rintel and Federico
Simoncelli.  Patrick Keshishian has ported it to OpenBSD and wrote the
remaining code based on uvideo(4).

Input and help also from mpi@@ and ratchov@@.

ok mpi
@
text
@d1164 9
d1754 3
@


1.147
log
@Use round_blocksize() to determine the maximum hardware block size (in
bytes) then, adjust the block size accordingly. Fixes zaudio(4) not
starting when large blocks are requested. Found and reported by
Andre Smagin <as at smagin.com>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.140 2015/12/14 03:04:10 mmcc Exp $	*/
d1347 8
d1368 1
a1368 1
	return config_found(dev, &aa, audioprint);
@


1.146
log
@Dont reuse "mult" local variable. Use separate variable for hardware
block size multiplier (in bytes) and for the driver block size
multiplier (in frames). No behaviour change.
@
text
@d597 1
a597 1
	unsigned int blk_mult;
d790 8
d799 1
a799 1
		np = sc->play.datalen / (sc->pchan * sc->bps * 2);
d804 1
a804 1
		nr = sc->rec.datalen / (sc->rchan * sc->bps * 2);
@


1.145
log
@Expose new audio ioctls that do one thing only: start and stop DMA,
set and get parameters. This is much simpler.

ok semarie, armani, tweaks from jmc
@
text
@d597 1
d760 2
a761 2
		mult = sc->ops->round_blocksize(sc->arg, 1);
		if (mult == 0) {
d763 1
a763 1
			    DEVNAME(sc), mult);
d767 2
a768 2
		mult = 1;
	DPRINTF("%s: hw block size multiplier: %u\n", DEVNAME(sc), mult);
d770 1
a770 1
		np = mult / audio_gcd(sc->pchan * sc->bps, mult);
d777 1
a777 1
		nr = mult / audio_gcd(sc->rchan * sc->bps, mult);
@


1.144
log
@Move the AUDIO_GETDEV ioctl in its own routine.
@
text
@d1026 129
d1719 10
d1935 8
@


1.143
log
@make AUDIO_GETDEV ioctl return the device name (ex "azalia0") rather
than driver specific strings.

ok kettenis
@
text
@d1535 10
d1597 1
a1597 5
		memset(addr, 0, sizeof(struct audio_device));
		if (sc->dev.dv_parent)
			strlcpy(((struct audio_device *)addr)->name,
			    sc->dev.dv_parent->dv_xname,
			    MAX_AUDIO_DEV_LEN);
@


1.142
log
@Set byte order the default encoding in the attach method to
native byte order. No behaviour change, as attach time
parameters are just hints, except thay this makes audioctl
output nicer if the device was never opened.
@
text
@d1587 5
a1591 1
		error = sc->ops->getdev(sc->arg, (audio_device_t *)addr);
@


1.141
log
@missing break
ok ratchov@@ deraadt@@
@
text
@d1086 5
a1090 1
	sc->sw_enc = AUDIO_ENCODING_SLINEAR;
@


1.140
log
@"harware" -> "hardware"
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.139 2015/09/04 16:02:19 ratchov Exp $	*/
d1707 1
@


1.139
log
@Fix condition used while seaching candidates for "record level"
control for wskbd. This may fix "record level" keys on certain
keyboards.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.138 2015/07/29 21:13:32 ratchov Exp $	*/
d98 1
a98 1
	unsigned int hw_enc;		/* harware AUDIO_ENCODING_* */
@


1.138
log
@Fix spacing and be more verbose in printfs under #ifdef AUDIO_DEBUG.
No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.137 2015/07/28 21:04:28 ratchov Exp $	*/
d1844 2
d1856 2
a1857 2
			DPRINTF("%s: wskbd using %s.%s, %s\n",
			    DEVNAME(sc), cn, dn, vol->mute >= -1 ? "mute control" : "");
@


1.137
log
@add missing space, from Donovan Watteau <tsoomi at gmail.com>
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.136 2015/07/28 20:57:35 ratchov Exp $	*/
d226 2
a227 1
		panic("audio_buf_rdiscard: bad count = %zu\n", count);
d244 2
a245 1
		panic("audio_buf_wcommit: bad count = %zu\n", count);
d1466 1
a1466 1
		if (sc->play.used == sc->play.len ) {
@


1.136
log
@In case the system misses enough audio interrupts for DMA
pointers to wrap, recover by detecting and compensating
for the missed interrupts. Fixes certain audio hangs on
MP machines.

with help from armani@@, typos fixed by Alexey Suslikov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.135 2015/07/28 20:45:02 ratchov Exp $	*/
d683 1
a683 1
			printf("%s: different play and record parameters"
@


1.135
log
@Add the AUDIO_GETPOS ioctl() to fetch a snapshot of the 4 counters
returned by AUDIO_GETxOFFS and AUDIO_xERROR ioctls.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.134 2015/07/24 08:56:45 ratchov Exp $	*/
d109 1
d352 1
a352 1
	int error;
d364 17
d423 1
a423 1
	int error;
d435 24
d509 1
@


1.134
log
@Switch back into counting bytes rather than blocks. We can't just
multiply the block count by the block size to get the bytes count
because they won't wrap correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.133 2015/07/22 19:06:28 ratchov Exp $	*/
a68 2
	unsigned long pos;		/* bytes transferred */
	unsigned long xrun;		/* bytes lost by xruns */
d70 2
d1301 1
a1301 1
		DPRINTF("%s: drain: used = %zu, xrun = %ld\n",
d1489 1
d1520 9
@


1.133
log
@Represent the current stream position in blocks rather than bytes
just because it's simpler this way. No behaviour change.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.132 2015/06/25 06:43:45 ratchov Exp $	*/
d69 1
a69 1
	unsigned long ticks;		/* blocks transferred */
d122 2
d332 1
a332 1
		sc->play.ticks = sc->play.xrun = 0;
d337 1
a337 1
		sc->rec.ticks = sc->rec.xrun = 0;
d363 1
a363 1
	sc->play.ticks++;
d417 1
a417 1
	sc->rec.ticks++;
d530 1
a530 1
	sc->play.xrun = sc->play.ticks = sc->rec.xrun = sc->rec.ticks = 0;
d961 2
a962 2
	ai->play.samples = sc->play.ticks * sc->play.blksz - sc->play.xrun;
	ai->record.samples = sc->rec.ticks * sc->rec.blksz - sc->rec.xrun;
d1050 1
a1050 1
	sc->play.ticks = sc->play.xrun = sc->rec.ticks = sc->rec.xrun = 0;
d1512 1
a1512 1
		ao->samples = sc->play.ticks * sc->play.blksz;
d1518 1
a1518 1
		ao->samples = sc->rec.ticks * sc->rec.blksz;
@


1.132
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
	unsigned long pos;		/* bytes transferred */
d330 1
a330 1
		sc->play.pos = sc->play.xrun = 0;
d335 1
a335 1
		sc->rec.pos = sc->rec.xrun = 0;
d361 1
a361 1
	sc->play.pos += sc->play.blksz;
d415 1
a415 1
	sc->rec.pos += sc->rec.blksz;
d528 1
a528 1
	sc->play.xrun = sc->play.pos = sc->rec.xrun = sc->rec.pos = 0;
d959 2
a960 2
	ai->play.samples = sc->play.pos - sc->play.xrun;
	ai->record.samples = sc->rec.pos - sc->rec.xrun;
d1048 1
a1048 1
	sc->play.pos = sc->play.xrun = sc->rec.pos = sc->rec.xrun = 0;
d1510 1
a1510 1
		ao->samples = sc->play.pos;
d1516 1
a1516 1
		ao->samples = sc->rec.pos;
@


1.131
log
@LITTE_ENDIAN -> LITTLE_ENDIAN
ok ratchov@@
@
text
@d1 1
a1 3
/*	$OpenBSD: audio.c,v 1.130 2015/05/11 06:46:21 ratchov Exp $	*/
/*	$NetBSD: audio.c,v 1.119 1999/11/09 16:50:47 augustss Exp $	*/

d3 1
a3 2
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
d5 3
a7 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
d9 7
a15 11
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
a16 1

d18 2
d21 4
a24 1
#include <sys/fcntl.h>
a25 2
#include <sys/selinfo.h>
#include <sys/poll.h>
d27 1
a27 5
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>
#include <sys/conf.h>
a28 4
#include <sys/device.h>
#include <sys/task.h>
#include <sys/endian.h>

d31 2
a32 3
#include <dev/rndvar.h>

#include "wskbd.h"	/* NWSKBD (mixer tuning using keyboard) */
d35 10
a44 3
#define DPRINTF(x)	if (audiodebug) printf x
#define DPRINTFN(n,x)	if (audiodebug>(n)) printf x
int	audiodebug = 0;
d46 2
a47 2
#define DPRINTF(x)
#define DPRINTFN(n,x)
d50 8
a57 1
#define ROUNDSIZE(x) x &= -16	/* round to nice boundary */
d60 1
a60 1
 * Initial/default block duration is both configurable and patchable.
d62 11
a72 29
#ifndef AUDIO_BLK_MS
#define AUDIO_BLK_MS	50	/* 50 ms */
#endif

#ifndef AU_RING_SIZE
#define AU_RING_SIZE		65536
#endif

#define AUMINBUF 512
#define AUMINBLK 32
#define AUMINNOBLK 2
struct audio_ringbuffer {
	int	bufsize;	/* allocated memory */
	int	blksize;	/* I/O block size */
	int	maxblks;	/* no of blocks in ring */
	u_char	*start;		/* start of buffer area */
	u_char	*end;		/* end of buffer area */
	u_char	*inp;		/* input pointer (to buffer) */
	u_char	*outp;		/* output pointer (from buffer) */
	int	used;		/* no of used bytes */
	int	usedlow;	/* start writer when used falls below this */
	int	usedhigh;	/* stop writer when used goes above this */
	u_long	stamp;		/* bytes transferred */
	u_long	stamp_last;	/* old value of bytes transferred */
	u_long	drops;		/* missed samples from over/underrun */
	u_long	pdrops;		/* paused samples */
	char	pause;		/* transfer is paused */
	char	mmapped;	/* device is mmap()-ed */
	u_char	blkset;		/* blksize has been set, for stickiness */
d75 9
a83 16
#define AUDIO_N_PORTS 4

struct au_mixer_ports {
	int	index;
	int	master;
	int	nports;
	u_char	isenum;
	u_int	allports;
	u_int	aumask[AUDIO_N_PORTS];
	u_int	misel [AUDIO_N_PORTS];
	u_int	miport[AUDIO_N_PORTS];
};

struct audio_emu {
	void	(*sw_code)(void *, u_char *, int);	/* conv routine */
	int	encoding;				/* emulated encoding */
d85 1
d88 1
a88 1
 * Software state, per audio device.
d91 24
a114 67
	struct	device dev;
	void	*hw_hdl;	/* Hardware driver handle */
	struct	audio_hw_if *hw_if; /* Hardware interface */
	struct	device *sc_dev;	/* Hardware device struct */
	u_char	sc_open;	/* single use device */
#define AUOPEN_READ	0x01
#define AUOPEN_WRITE	0x02
	u_char	sc_mode;	/* bitmask for RECORD/PLAY */

	struct	selinfo sc_wsel; /* write selector */
	struct	selinfo sc_rsel; /* read selector */
	struct	proc *sc_async_audio;	/* process who wants audio SIGIO */
	struct	mixer_asyncs {
		struct mixer_asyncs *next;
		struct proc *proc;
	} *sc_async_mixer;  /* processes who want mixer SIGIO */

	/* Sleep channels for reading and writing. */
	int	sc_rchan;
	int	sc_wchan;

	/* Ring buffers, separate for record and play. */
	struct	audio_ringbuffer sc_rr; /* Record ring */
	struct	audio_ringbuffer sc_pr; /* Play ring */

	u_char	*sc_sil_start;	/* start of silence in buffer */
	int	sc_sil_count;	/* # of silence bytes */

	u_char	sc_rbus;	/* input dma in progress */
	u_char	sc_pbus;	/* output dma in progress */

	u_char	sc_rqui;	/* input dma quiesced */
	u_char	sc_pqui;	/* output dma quiesced */

	struct	audio_params sc_pparams;	/* play encoding parameters */
	struct	audio_params sc_rparams;	/* record encoding parameters */

	struct	audio_emu sc_pemu;		/* play conversion params */
	struct	audio_emu sc_remu;		/* record conversion params */

	int	sc_eof;		/* EOF, i.e. zero sized write, counter */
	u_long	sc_wstamp;
	u_long	sc_playdrop;

	int	sc_full_duplex;	/* device in full duplex mode */

	struct	au_mixer_ports sc_inports, sc_outports;
	int	sc_monitor_port;

	int     sc_refcnt;
	int     sc_dying;

	int	sc_quiesce;
#define	AUDIO_QUIESCE_START	1
#define	AUDIO_QUIESCE_SILENT	2
	struct task sc_mixer_task;
	u_char	sc_mute;

#ifdef AUDIO_INTR_TIME
	u_long	sc_pfirstintr;	/* first time we saw a play interrupt */
	int	sc_pnintr;	/* number of interrupts */
	u_long	sc_plastintr;	/* last time we saw a play interrupt */
	long	sc_pblktime;	/* nominal time between interrupts */
	u_long	sc_rfirstintr;	/* first time we saw a rec interrupt */
	int	sc_rnintr;	/* number of interrupts */
	u_long	sc_rlastintr;	/* last time we saw a rec interrupt */
	long	sc_rblktime;	/* nominal time between interrupts */
d118 7
a124 96
int	audio_blk_ms = AUDIO_BLK_MS;

int	audiosetinfo(struct audio_softc *, struct audio_info *);
int	audiogetinfo(struct audio_softc *, struct audio_info *);
int	audiogetbufinfo(struct audio_softc *, struct audio_bufinfo *, int);
int	audio_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	audio_close(dev_t, int, int, struct proc *);
int	audio_read(dev_t, struct uio *, int);
int	audio_write(dev_t, struct uio *, int);
int	audio_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	audio_poll(dev_t, int, struct proc *);
paddr_t	audio_mmap(dev_t, off_t, int);

int	mixer_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	mixer_close(dev_t, int, int, struct proc *);
int	mixer_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
static	void mixer_remove(struct audio_softc *, struct proc *p);
static	void mixer_signal(struct audio_softc *);

void	audio_init_record(struct audio_softc *);
void	audio_init_play(struct audio_softc *);
int	audiostartr(struct audio_softc *);
int	audiostartp(struct audio_softc *);
void	audio_rint(void *);
void	audio_pint(void *);
int	audio_check_params(struct audio_params *);
void	audio_emu_setup(int, struct audio_params *, struct audio_emu *);

void	audio_set_blksize(struct audio_softc *, int, int);
void	audio_calc_blksize(struct audio_softc *, int);
void	audio_fill_silence(struct audio_params *, u_char *, u_char *, int);
int	audio_silence_copyout(struct audio_softc *, int, struct uio *);

void	audio_init_ringbuffer(struct audio_ringbuffer *);
int	audio_initbufs(struct audio_softc *);
void	audio_calcwater(struct audio_softc *);
static __inline int audio_sleep_timo(int *, char *, int);
static __inline int audio_sleep(int *, char *);
static __inline void audio_wake(int *);
void	audio_selwakeup(struct audio_softc *sc, int play);
int	audio_drain(struct audio_softc *);
void	audio_clear(struct audio_softc *);
static __inline void audio_pint_silence(struct audio_softc *, struct audio_ringbuffer *, u_char *, int);

int	audio_quiesce(struct audio_softc *);
void	audio_wakeup(struct audio_softc *);

int	audio_alloc_ring(struct audio_softc *, struct audio_ringbuffer *, int, int);
void	audio_free_ring(struct audio_softc *, struct audio_ringbuffer *);

int	audioprint(void *, const char *);

int	audioprobe(struct device *, void *, void *);
void	audioattach(struct device *, struct device *, void *);
int	audiodetach(struct device *, int);
int	audioactivate(struct device *, int);

struct portname {
	char	*name;
	int	mask;
};
static struct portname itable[] = {
	{ AudioNmicrophone,	AUDIO_MICROPHONE },
	{ AudioNline,		AUDIO_LINE_IN },
	{ AudioNcd,		AUDIO_CD },
	{ 0 }
};
static struct portname otable[] = {
	{ AudioNspeaker,	AUDIO_SPEAKER },
	{ AudioNheadphone,	AUDIO_HEADPHONE },
	{ AudioNline,		AUDIO_LINE_OUT },
	{ 0 }
};
struct gainpref {
	char *class, *device;
};
static struct gainpref ipreftab[] = {
	{ AudioCinputs, AudioNvolume },
	{ AudioCinputs, AudioNinput  },
	{ AudioCinputs, AudioNrecord },
	{ AudioCrecord, AudioNvolume },
	{ AudioCrecord, AudioNrecord },
	{ NULL, NULL}
};
static struct gainpref opreftab[] = {
	{ AudioCoutputs, AudioNoutput },
	{ AudioCoutputs, AudioNdac },
	{ AudioCinputs,  AudioNdac },
	{ AudioCoutputs, AudioNmaster },
	{ NULL, NULL}
};
static struct gainpref mpreftab[] = {
	{ AudioCoutputs, AudioNmonitor },
	{ AudioCmonitor, AudioNmonitor },
	{ NULL, NULL}
};
d126 3
a128 28
void	au_gain_match(struct audio_softc *, struct gainpref *, 
		mixer_devinfo_t *, mixer_devinfo_t *, int *, int *);			    
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *,
		            mixer_devinfo_t *, mixer_devinfo_t *, 
		            char *, char *, struct portname *);
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *,
			 int, int);
void	au_get_gain(struct audio_softc *, struct au_mixer_ports *,
			 u_int *, u_char *);
int	au_set_port(struct audio_softc *, struct au_mixer_ports *,
			 u_int);
int	au_get_port(struct audio_softc *, struct au_mixer_ports *);
int	au_set_mute(struct audio_softc *, struct au_mixer_ports *, u_char);
int	au_get_mute(struct audio_softc *, struct au_mixer_ports *, u_char *);
int	au_get_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int *, int *r);
int	au_set_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int, int);
int	au_portof(struct audio_softc *, char *);


/* The default audio mode: 8 kHz mono ulaw */
struct audio_params audio_default =
	{8000, AUDIO_ENCODING_ULAW, 8, 1, 1, 1};

struct cfattach audio_ca = {
	sizeof(struct audio_softc), audioprobe, audioattach,
	audiodetach, audioactivate
a134 18
void filt_audiowdetach(struct knote *);
int filt_audiowrite(struct knote *, long);

struct filterops audiowrite_filtops =
	{ 1, NULL, filt_audiowdetach, filt_audiowrite};

void filt_audiordetach(struct knote *);
int filt_audioread(struct knote *, long);

struct filterops audioread_filtops =
	{ 1, NULL, filt_audiordetach, filt_audioread};

#if NWSKBD > 0
/* Mixer manipulation using keyboard */
int wskbd_set_mixervolume(long, long);
void wskbd_set_mixervolume_callback(void *);
#endif

d151 22
d174 1
a174 1
audioprobe(struct device *parent, void *match, void *aux)
d176 14
a189 1
	struct audio_attach_args *sa = aux;
d191 7
a197 3
	DPRINTF(("audioprobe: type=%d sa=%p hw=%p\n",
		   sa->type, sa, sa->hwif));
	return (sa->type == AUDIODEV_TYPE_AUDIO) ? 1 : 0;
d200 5
a204 2
void
audioattach(struct device *parent, struct device *self, void *aux)
d206 1
a206 7
	struct audio_softc *sc = (void *)self;
	struct audio_attach_args *sa = aux;
	struct audio_hw_if *hwp = sa->hwif;
	void *hdlp = sa->hdl;
	int error;
	mixer_devinfo_t mi, cl;
	int ipref, opref, mpref;
d208 6
a213 1
	printf("\n");
d215 9
a223 18
#ifdef DIAGNOSTIC
	if (hwp == 0 ||
	    hwp->open == 0 ||
	    hwp->close == 0 ||
	    hwp->query_encoding == 0 ||
	    hwp->set_params == 0 ||
	    (hwp->start_output == 0 && hwp->trigger_output == 0) ||
	    (hwp->start_input == 0 && hwp->trigger_input == 0) ||
	    hwp->halt_output == 0 ||
	    hwp->halt_input == 0 ||
	    hwp->getdev == 0 ||
	    hwp->set_port == 0 ||
	    hwp->get_port == 0 ||
	    hwp->query_devinfo == 0 ||
	    hwp->get_props == 0) {
		printf("audio: missing method\n");
		sc->hw_if = 0;
		return;
d226 5
d232 9
a240 17
	sc->hw_if = hwp;
	sc->hw_hdl = hdlp;
	sc->sc_dev = parent;
	sc->sc_async_mixer = NULL;

	error = audio_alloc_ring(sc, &sc->sc_pr, AUMODE_PLAY, AU_RING_SIZE);
	if (error) {
		sc->hw_if = 0;
		printf("audio: could not allocate play buffer\n");
		return;
	}
	error = audio_alloc_ring(sc, &sc->sc_rr, AUMODE_RECORD, AU_RING_SIZE);
	if (error) {
		audio_free_ring(sc, &sc->sc_pr);
		sc->hw_if = 0;
		printf("audio: could not allocate record buffer\n");
		return;
d242 3
d246 7
a252 47
	/*
	 * Set default softc params
	 */
	if (hwp->get_default_params) {
		hwp->get_default_params(hdlp, AUMODE_PLAY, &sc->sc_pparams);
		hwp->get_default_params(hdlp, AUMODE_RECORD, &sc->sc_rparams);
	} else {
		sc->sc_pparams = audio_default;
		sc->sc_rparams = audio_default;
	}
	sc->sc_pemu.encoding = sc->sc_pparams.encoding;
	sc->sc_pemu.sw_code = NULL;
	sc->sc_remu.encoding = sc->sc_rparams.encoding;
	sc->sc_remu.sw_code = NULL;

	/* Set up some default values */
	sc->sc_rr.blkset = sc->sc_pr.blkset = 0;
	audio_calc_blksize(sc, AUMODE_RECORD);
	audio_calc_blksize(sc, AUMODE_PLAY);
	audio_init_ringbuffer(&sc->sc_rr);
	audio_init_ringbuffer(&sc->sc_pr);
	audio_calcwater(sc);

	ipref = opref = mpref = -1;
	sc->sc_inports.index = -1;
	sc->sc_inports.nports = 0;
	sc->sc_inports.isenum = 0;
	sc->sc_inports.allports = 0;
	sc->sc_inports.master = -1;
	sc->sc_outports.index = -1;
	sc->sc_outports.nports = 0;
	sc->sc_outports.isenum = 0;
	sc->sc_outports.allports = 0;
	sc->sc_outports.master = -1;
	sc->sc_monitor_port = -1;
	for(mi.index = 0; ; mi.index++) {
		if (hwp->query_devinfo(hdlp, &mi) != 0)
			break;
		if (mi.type == AUDIO_MIXER_CLASS)
			continue;
		cl.index = mi.mixer_class;
		if (hwp->query_devinfo(hdlp, &cl) != 0)
			continue;

		au_gain_match(sc, ipreftab, &cl, &mi, &sc->sc_inports.master, &ipref);
		au_gain_match(sc, opreftab, &cl, &mi, &sc->sc_outports.master, &opref);
		au_gain_match(sc, mpreftab, &cl, &mi, &sc->sc_monitor_port, &mpref);
d254 9
a262 7
		au_check_ports(sc, &sc->sc_inports,  &cl, &mi,
		    AudioCrecord, AudioNsource, itable);
		au_check_ports(sc, &sc->sc_outports, &cl, &mi,
		    AudioCoutputs, AudioNselect, otable);
	}
	DPRINTF(("audio_attach: inputs ports=0x%x, output ports=0x%x\n",
		 sc->sc_inports.allports, sc->sc_outports.allports));
d265 2
a266 2
int
audioactivate(struct device *self, int act)
d268 3
a270 1
	struct audio_softc *sc = (struct audio_softc *)self;
d272 7
a278 9
	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	case DVACT_QUIESCE:
		audio_quiesce(sc);
		break;
	case DVACT_WAKEUP:
		audio_wakeup(sc);
d280 26
d307 2
a308 1
	return (0);
d311 2
a312 2
int
audiodetach(struct device *self, int flags)
d314 2
a315 4
	struct audio_softc *sc = (struct audio_softc *)self;
	int maj, mn;

	DPRINTF(("audio_detach: sc=%p flags=%d\n", sc, flags));
d317 5
a321 10
	sc->sc_dying = 1;

	wakeup(&sc->sc_quiesce);
	wakeup(&sc->sc_wchan);
	wakeup(&sc->sc_rchan);
	mtx_enter(&audio_lock);
	if (--sc->sc_refcnt >= 0) {
		if (msleep(&sc->sc_refcnt, &audio_lock, PZERO, "auddet", hz * 120))
			printf("audiodetach: %s didn't detach\n",
			    sc->dev.dv_xname);
a322 19
	mtx_leave(&audio_lock);

	/* free resources */
	audio_free_ring(sc, &sc->sc_pr);
	audio_free_ring(sc, &sc->sc_rr);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == audioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn | SOUND_DEVICE,    mn | SOUND_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIO_DEVICE,    mn | AUDIO_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIOCTL_DEVICE, mn | AUDIOCTL_DEVICE, VCHR);
	vdevgone(maj, mn | MIXER_DEVICE,    mn | MIXER_DEVICE, VCHR);

	return (0);
d325 2
a326 2
int
au_portof(struct audio_softc *sc, char *name)
d328 10
a337 8
	mixer_devinfo_t mi;

	for(mi.index = 0;
	    sc->hw_if->query_devinfo(sc->hw_hdl, &mi) == 0;
	    mi.index++)
		if (strcmp(mi.label.name, name) == 0)
			return mi.index;
	return -1;
d340 3
d344 1
a344 3
au_check_ports(struct audio_softc *sc, struct au_mixer_ports *ports,
    mixer_devinfo_t *cl, mixer_devinfo_t *mi, char *cname, char *mname, 
    struct portname *tbl)
d346 4
a349 1
	int i, j;
d351 7
a357 2
	if (strcmp(cl->label.name, cname) != 0 ||
	    strcmp(mi->label.name, mname) != 0)
d359 30
a388 27
	if (mi->type == AUDIO_MIXER_ENUM) {
	    ports->index = mi->index;
	    for(i = 0; tbl[i].name; i++) {
		for(j = 0; j < mi->un.e.num_mem; j++) {
		    if (strcmp(mi->un.e.member[j].label.name,
			    tbl[i].name) == 0) {
			ports->aumask[ports->nports] = tbl[i].mask;
			ports->misel [ports->nports] = mi->un.e.member[j].ord;
			ports->miport[ports->nports++] =
				au_portof(sc, mi->un.e.member[j].label.name);
			ports->allports |= tbl[i].mask;
		    }
		}
	    }
	    ports->isenum = 1;
	} else if (mi->type == AUDIO_MIXER_SET) {
	    ports->index = mi->index;
	    for(i = 0; tbl[i].name; i++) {
		for(j = 0; j < mi->un.s.num_mem; j++) {
		    if (strcmp(mi->un.s.member[j].label.name,
			    tbl[i].name) == 0) {
			ports->aumask[ports->nports] = tbl[i].mask;
			ports->misel [ports->nports] = mi->un.s.member[j].mask;
			ports->miport[ports->nports++] =
				au_portof(sc, mi->un.s.member[j].label.name);
			ports->allports |= tbl[i].mask;
		    }
d390 1
a390 1
	    }
d395 1
a395 3
 * check if the given (class, device) is better
 * than the current setting (*index), if so, set the
 * current setting.
d398 1
a398 2
au_gain_match(struct audio_softc *sc, struct gainpref *tbl, 
    mixer_devinfo_t *cls, mixer_devinfo_t *dev, int *index, int *pref) 
d400 14
a413 1
	int i;
d415 16
a430 10
	for (i = *pref + 1; tbl[i].class != NULL; i++) {
		if (strcmp(tbl[i].class, cls->label.name) == 0 &&
		    strcmp(tbl[i].device, dev->label.name) == 0) {
			if (*pref < i) {
				DPRINTF(("au_gain_match: found %s.%s\n", 
				    cls->label.name, dev->label.name));
				*index = dev->index;
				*pref = i;
			}
			break;
a432 1
}
d434 8
a441 13
/*
 * Called from hardware driver.  This is where the MI audio driver gets
 * probed/attached to the hardware driver.
 */
struct device *
audio_attach_mi(struct audio_hw_if *ahwp, void *hdlp, struct device *dev)
{
	struct audio_attach_args arg;

#ifdef DIAGNOSTIC
	if (ahwp == NULL) {
		printf ("audio_attach_mi: NULL\n");
		return 0;
a442 6
#endif

	arg.type = AUDIODEV_TYPE_AUDIO;
	arg.hwif = ahwp;
	arg.hdl = hdlp;
	return config_found(dev, &arg, audioprint);
d446 1
a446 1
audioprint(void *aux, const char *pnp)
d448 15
a462 2
	struct audio_attach_args *arg = aux;
	const char *type;
d464 43
a506 13
	if (pnp != NULL) {
		switch (arg->type) {
		case AUDIODEV_TYPE_AUDIO:
			type = "audio";
			break;
		case AUDIODEV_TYPE_OPL:
			type = "opl";
			break;
		case AUDIODEV_TYPE_MPU:
			type = "mpu";
			break;
		default:
			panic("audioprint: unknown type %d", arg->type);
d508 2
a509 1
		printf("%s at %s", type, pnp);
d511 1
a511 1
	return (UNCONF);
d514 2
a515 6
#ifdef AUDIO_DEBUG
void	audio_printsc(struct audio_softc *);
void	audio_print_params(char *, struct audio_params *);

void
audio_printsc(struct audio_softc *sc)
d517 5
a521 7
	printf("hwhandle %p hw_if %p ", sc->hw_hdl, sc->hw_if);
	printf("open 0x%x mode 0x%x\n", sc->sc_open, sc->sc_mode);
	printf("rchan 0x%x wchan 0x%x ", sc->sc_rchan, sc->sc_wchan);
	printf("rring used 0x%x pring used=%d\n", sc->sc_rr.used, sc->sc_pr.used);
	printf("rbus 0x%x pbus 0x%x ", sc->sc_rbus, sc->sc_pbus);
	printf("pblksz %d, rblksz %d", sc->sc_pr.blksize, sc->sc_rr.blksize);
	printf("hiwat %d lowat %d\n", sc->sc_pr.usedhigh, sc->sc_pr.usedlow);
d524 2
a525 2
void
audio_print_params(char *s, struct audio_params *p)
d527 3
a529 2
	printf("audio: %s sr=%ld, enc=%d, chan=%d, prec=%d bps=%d\n", s,
	    p->sample_rate, p->encoding, p->channels, p->precision, p->bps);
a530 1
#endif
d533 1
a533 2
audio_alloc_ring(struct audio_softc *sc, struct audio_ringbuffer *r,
    int direction, int bufsize)
d535 7
a541 18
	struct audio_hw_if *hw = sc->hw_if;
	void *hdl = sc->hw_hdl;
	/*
	 * Alloc DMA play and record buffers
	 */
	if (bufsize < AUMINBUF)
		bufsize = AUMINBUF;
	ROUNDSIZE(bufsize);
	if (hw->round_buffersize)
		bufsize = hw->round_buffersize(hdl, direction, bufsize);
	r->bufsize = bufsize;
	if (hw->allocm)
		r->start = hw->allocm(hdl, direction, r->bufsize, M_DEVBUF,
		    M_WAITOK);
	else
		r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);
	if (r->start == 0)
		return ENOMEM;
a544 10
void
audio_free_ring(struct audio_softc *sc, struct audio_ringbuffer *r)
{
	if (sc->hw_if->freem) {
		sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);
	} else {
		free(r->start, M_DEVBUF, 0);
	}
}

d546 1
a546 1
audioopen(dev_t dev, int flags, int ifmt, struct proc *p)
d548 2
a549 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d552 4
a555 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d557 18
a574 2
	if (sc->sc_dying)
		return (EIO);
d576 22
a597 12
	if (!sc->hw_if)
		return (ENXIO);

	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
	case AUDIOCTL_DEVICE:
		error = audio_open(dev, sc, flags, ifmt, p);
		break;
	case MIXER_DEVICE:
		error = mixer_open(dev, sc, flags, ifmt, p);
d600 1
a600 2
		error = ENXIO;
		break;
d602 12
d615 10
a624 2
	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
d626 43
a668 2
	return (error);
}
d670 30
a699 12
int
audioclose(dev_t dev, int flags, int ifmt, struct proc *p)
{

	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
		return (audio_close(dev, flags, ifmt, p));
	case MIXER_DEVICE:
		return (mixer_close(dev, flags, ifmt, p));
	case AUDIOCTL_DEVICE:
		return 0;
d701 4
a704 1
		return (ENXIO);
d706 1
a706 1
}
d708 30
a737 6
int
audioread(dev_t dev, struct uio *uio, int ioflag)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;
d739 22
a760 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d762 10
a771 2
	if (sc->sc_dying)
		return (EIO);
d773 22
a794 13
	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
		error = audio_read(dev, uio, ioflag);
		break;
	case AUDIOCTL_DEVICE:
	case MIXER_DEVICE:
		error = ENODEV;
		break;
	default:
		error = ENXIO;
		break;
d797 5
a801 3
	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
	return (error);
d805 1
a805 1
audiowrite(dev_t dev, struct uio *uio, int ioflag)
d807 1
a807 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d809 1
d811 17
a827 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d829 65
a893 16
	if (sc->sc_dying)
		return (EIO);

	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
		error = audio_write(dev, uio, ioflag);
		break;
	case AUDIOCTL_DEVICE:
	case MIXER_DEVICE:
		error = ENODEV;
		break;
	default:
		error = ENXIO;
		break;
d896 2
a897 4
	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
	return (error);
}
d899 5
a903 6
int
audioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;
d905 26
a930 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d932 7
a938 16
	if (sc->sc_dying)
		return (EIO);

	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
	case AUDIOCTL_DEVICE:
		error = audio_ioctl(dev, cmd, addr, flag, p);
		break;
	case MIXER_DEVICE:
		error = mixer_ioctl(dev, cmd, addr, flag, p);
		break;
	default:
		error = ENXIO;
		break;
d940 1
a940 4

	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
	return (error);
d944 1
a944 1
audiopoll(dev_t dev, int events, struct proc *p)
d946 16
a961 3
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;
d963 2
a964 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return POLLERR;
d966 2
a967 2
	if (sc->sc_dying)
		return POLLERR;
d969 2
a970 14
	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
		error = audio_poll(dev, events, p);
		break;
	case AUDIOCTL_DEVICE:
	case MIXER_DEVICE:
		error = 0;
		break;
	default:
		error = 0;
		break;
	}
d972 4
a975 3
	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
	return (error);
d978 2
a979 2
paddr_t
audiommap(dev_t dev, off_t off, int prot)
d981 1
a981 3
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int ret;
d983 1
a983 25
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return (-1);

	if (sc->sc_dying)
		return (-1);

	sc->sc_refcnt ++;
	switch (AUDIODEV(dev)) {
	case SOUND_DEVICE:
	case AUDIO_DEVICE:
		ret = audio_mmap(dev, off, prot);
		break;
	case AUDIOCTL_DEVICE:
	case MIXER_DEVICE:
		ret = -1;
		break;
	default:
		ret = -1;
		break;
	}

	if (--sc->sc_refcnt < 0)
		wakeup(&sc->sc_refcnt);
	return (ret);
a985 3
/*
 * Audio driver
 */
d987 1
a987 1
audio_init_ringbuffer(struct audio_ringbuffer *rp)
d989 4
a992 28
	int nblks;
	int blksize = rp->blksize;

	if (blksize < AUMINBLK)
		blksize = AUMINBLK;
	nblks = rp->bufsize / blksize;
	if (nblks < AUMINNOBLK) {
		nblks = AUMINNOBLK;
		blksize = rp->bufsize / nblks;
		ROUNDSIZE(blksize);
	}
	DPRINTF(("audio_init_ringbuffer: blksize=%d\n", blksize));
	rp->blksize = blksize;
	rp->maxblks = nblks;
	rp->used = 0;
	rp->end = rp->start + nblks * blksize;
	rp->inp = rp->outp = rp->start;
	rp->stamp = 0;
	rp->stamp_last = 0;
	rp->drops = 0;
	rp->pdrops = 0;
	rp->mmapped = 0;
}

int
audio_initbufs(struct audio_softc *sc)
{
	struct audio_hw_if *hw = sc->hw_if;
d995 1
a995 8
	DPRINTF(("audio_initbufs: mode=0x%x\n", sc->sc_mode));
	audio_init_ringbuffer(&sc->sc_rr);
	if (hw->init_input && (sc->sc_mode & AUMODE_RECORD)) {
		error = hw->init_input(sc->hw_hdl, sc->sc_rr.start,
		    sc->sc_rr.end - sc->sc_rr.start);
		if (error)
			return error;
	}
d997 18
a1014 7
	audio_init_ringbuffer(&sc->sc_pr);
	sc->sc_sil_count = 0;
	if (hw->init_output && (sc->sc_mode & AUMODE_PLAY)) {
		error = hw->init_output(sc->hw_hdl, sc->sc_pr.start,
					sc->sc_pr.end - sc->sc_pr.start);
		if (error)
			return error;
a1015 18

#ifdef AUDIO_INTR_TIME
	sc->sc_pnintr = 0;
	sc->sc_pblktime = (u_long)(
	    (u_long)sc->sc_pr.blksize * 100000 /
	    (u_long)(sc->sc_pparams.bps *
		sc->sc_pparams.channels *
		sc->sc_pparams.sample_rate)) * 10;
	DPRINTF(("audio: play blktime = %lu for %d\n",
		 sc->sc_pblktime, sc->sc_pr.blksize));
	sc->sc_rnintr = 0;
	sc->sc_rblktime = (u_long)(
	    (u_long)sc->sc_rr.blksize * 100000 /
	    (u_long)(sc->sc_rparams.bps *
		sc->sc_rparams.channels *
		sc->sc_rparams.sample_rate)) * 10;
	DPRINTF(("audio: record blktime = %lu for %d\n",
		 sc->sc_rblktime, sc->sc_rr.blksize));
d1017 2
d1020 3
a1022 2
	return 0;
}
d1024 13
a1036 4
void
audio_calcwater(struct audio_softc *sc)
{
	int hiwat, lowat;
d1038 11
a1048 8
	hiwat = (sc->sc_pr.end - sc->sc_pr.start) / sc->sc_pr.blksize;
	lowat = hiwat * 3 / 4;
	if (lowat == hiwat)
		lowat = hiwat - 1;
	sc->sc_pr.usedhigh = hiwat * sc->sc_pr.blksize;
	sc->sc_pr.usedlow = lowat * sc->sc_pr.blksize;
	sc->sc_rr.usedhigh = sc->sc_rr.end - sc->sc_rr.start;
	sc->sc_rr.usedlow = 0;
d1051 2
a1052 2
static __inline int
audio_sleep_timo(int *chan, char *label, int timo)
d1054 1
a1054 1
	int st;
d1056 10
a1065 2
	if (!label)
		label = "audio";
d1067 14
a1080 11
	DPRINTFN(3, ("audio_sleep_timo: chan=%p, label=%s, timo=%d\n",
	    chan, label, timo));
	*chan = 1;
	st = msleep(chan, &audio_lock, PWAIT | PCATCH, label, timo);
	*chan = 0;
#ifdef AUDIO_DEBUG
	if (st != 0)
	    printf("audio_sleep: woke up st=%d\n", st);
#endif
	return (st);
}
d1082 9
a1090 5
static __inline int
audio_sleep(int *chan, char *label)
{
	return audio_sleep_timo(chan, label, 0);
}
d1092 15
a1106 8
/* call with audio_lock */
static __inline void
audio_wake(int *chan)
{
	DPRINTFN(3, ("audio_wakeup: chan=%p, *chan=%d\n", chan, *chan));
	if (*chan) {
		wakeup(chan);
		*chan = 0;
d1108 1
d1112 1
a1112 2
audio_open(dev_t dev, struct audio_softc *sc, int flags, int ifmt,
    struct proc *p)
d1114 2
a1115 3
	int error;
	int mode;
	struct audio_info ai;
d1117 1
a1117 1
	DPRINTF(("audio_open: dev=0x%x flags=0x%x sc=%p hdl=%p\n", dev, flags, sc, sc->hw_hdl));
d1119 1
a1119 2
	if (ISDEVAUDIOCTL(dev))
		return 0;
d1121 13
a1133 31
	if ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0)
		return (EBUSY);

	error = sc->hw_if->open(sc->hw_hdl, flags);
	if (error)
		return (error);

	sc->sc_async_audio = 0;
	sc->sc_rchan = 0;
	sc->sc_wchan = 0;
	sc->sc_sil_count = 0;
	sc->sc_rbus = 0;
	sc->sc_pbus = 0;
	sc->sc_eof = 0;
	sc->sc_playdrop = 0;

	sc->sc_full_duplex = 0;
/* doesn't always work right on SB.
		(flags & (FWRITE|FREAD)) == (FWRITE|FREAD) &&
		(sc->hw_if->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);
*/

	mode = 0;
	if (flags & FREAD) {
		sc->sc_open |= AUOPEN_READ;
		mode |= AUMODE_RECORD;
	}
	if (flags & FWRITE) {
		sc->sc_open |= AUOPEN_WRITE;
		mode |= AUMODE_PLAY | AUMODE_PLAY_ALL;
	}
d1136 3
a1138 3
	 * Multiplex device: /dev/audio (default) and /dev/sound (last)
	 * The /dev/audio is always (re)set to the default parameters.
	 * For the other devices, you get what they were last set to.
d1140 7
a1146 10
	if (ISDEVAUDIO(dev)) {
		/* /dev/audio */
		if (sc->hw_if->get_default_params) {
			sc->hw_if->get_default_params(sc->hw_hdl, AUMODE_PLAY,
			    &sc->sc_pparams);
			sc->hw_if->get_default_params(sc->hw_hdl, AUMODE_RECORD,
			    &sc->sc_rparams);
		} else {
			sc->sc_rparams = audio_default;
			sc->sc_pparams = audio_default;
d1148 2
a1150 35
#ifdef DIAGNOSTIC
	/*
	 * Sample rate and precision are supposed to be set to proper
	 * default values by the hardware driver, so that it may give
	 * us these values.
	 */
	if (sc->sc_rparams.precision == 0 || sc->sc_pparams.precision == 0) {
		printf("audio_open: 0 precision\n");
		error = EINVAL;
		goto bad;
	}
#endif
	AUDIO_INITINFO(&ai);
	ai.record.sample_rate = sc->sc_rparams.sample_rate;
	ai.record.encoding    = sc->sc_remu.encoding;
	ai.record.channels    = sc->sc_rparams.channels;
	ai.record.precision   = sc->sc_rparams.precision;
	ai.record.bps         = sc->sc_rparams.bps;
	ai.record.msb         = sc->sc_rparams.msb;
	ai.record.pause	      = 0;
	ai.play.sample_rate   = sc->sc_pparams.sample_rate;
	ai.play.encoding      = sc->sc_pemu.encoding;
	ai.play.channels      = sc->sc_pparams.channels;
	ai.play.precision     = sc->sc_pparams.precision;
	ai.play.bps           = sc->sc_pparams.bps;
	ai.play.msb           = sc->sc_pparams.msb;
	ai.play.pause	      = 0;
	ai.mode		      = mode;
	sc->sc_rr.blkset = sc->sc_pr.blkset = 0; /* Block sizes not set yet */
	sc->sc_pr.blksize = sc->sc_rr.blksize = 0; /* force recalculation */
	error = audiosetinfo(sc, &ai);
	if (error)
		goto bad;

	DPRINTF(("audio_open: done sc_mode = 0x%x\n", sc->sc_mode));
d1152 3
a1155 7

bad:
	sc->hw_if->close(sc->hw_hdl);
	sc->sc_open = 0;
	sc->sc_mode = 0;
	sc->sc_full_duplex = 0;
	return error;
d1158 2
a1159 5
/*
 * Must be called from task context.
 */
void
audio_init_record(struct audio_softc *sc)
d1161 5
a1165 5
	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	if (sc->hw_if->speaker_ctl &&
	    (!sc->sc_full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))
		sc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_OFF);
}
d1167 5
a1171 10
/*
 * Must be called from task context.
 */
void
audio_init_play(struct audio_softc *sc)
{
	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	sc->sc_wstamp = sc->sc_pr.stamp;
	if (sc->hw_if->speaker_ctl)
		sc->hw_if->speaker_ctl(sc->hw_hdl, SPKR_ON);
d1175 1
a1175 1
audio_drain(struct audio_softc *sc)
d1177 2
a1178 2
	int error, drops;
	struct audio_ringbuffer *cb = &sc->sc_pr;
d1180 15
a1194 45
	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	DPRINTF(("audio_drain: enter busy=%d used=%d\n",
	    sc->sc_pbus, sc->sc_pr.used));
	if (sc->sc_pr.mmapped || sc->sc_pr.used <= 0)
		return 0;
	if (!sc->sc_pbus) {
		/* We've never started playing, probably because the
		 * block was too short.  Pad it and start now.
		 */
		int cc;
		u_char *inp = cb->inp;

		cc = cb->blksize - (inp - cb->start) % cb->blksize;
		if (sc->sc_pemu.sw_code) {
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);
			sc->sc_pemu.sw_code(sc->hw_hdl, inp, cc);
		} else
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);
		inp += cc;
		if (inp >= cb->end)
			inp = cb->start;
		cb->used += cc;
		cb->inp = inp;
		error = audiostartp(sc);
		if (error)
			return error;
	}
	/*
	 * Play until a silence block has been played, then we
	 * know all has been drained.
	 * XXX This should be done some other way to avoid
	 * playing silence.
	 */
	mtx_enter(&audio_lock);
	drops = cb->drops;
	error = 0;
	while (cb->drops == drops && !error) {
		DPRINTF(("audio_drain: used=%d, drops=%ld\n", sc->sc_pr.used, cb->drops));
		/*
		 * When the process is exiting, it ignores all signals and
		 * we can't interrupt this sleep, so we set a timeout just in case.
		 */
		error = audio_sleep_timo(&sc->sc_wchan, "aud_dr", 30 * hz);
		if (sc->sc_dying)
			error = EIO;
d1196 1
a1196 2
	mtx_leave(&audio_lock);
	return error;
d1200 1
a1200 1
audio_quiesce(struct audio_softc *sc)
d1202 2
a1203 1
	sc->sc_quiesce = AUDIO_QUIESCE_START;
d1205 26
a1230 6
	mtx_enter(&audio_lock);
	while (sc->sc_pbus && !sc->sc_pqui)
		audio_sleep(&sc->sc_wchan, "audpqui");
	while (sc->sc_rbus && !sc->sc_rqui)
		audio_sleep(&sc->sc_rchan, "audrqui");
	mtx_leave(&audio_lock);
d1232 7
a1238 1
	sc->sc_quiesce = AUDIO_QUIESCE_SILENT;
d1240 4
a1243 7
	au_get_mute(sc, &sc->sc_outports, &sc->sc_mute);
	au_set_mute(sc, &sc->sc_outports, 1);

	if (sc->sc_pbus)
		sc->hw_if->halt_output(sc->hw_hdl);
	if (sc->sc_rbus)
		sc->hw_if->halt_input(sc->hw_hdl);
d1245 5
d1251 4
d1257 2
a1258 2
void
audio_wakeup(struct audio_softc *sc)
d1260 8
a1267 1
	int setmode = 0;
d1269 7
a1275 23
	sc->sc_pqui = sc->sc_rqui = 0;

	au_set_mute(sc, &sc->sc_outports, sc->sc_mute);

	if (sc->sc_pbus)
		setmode |= AUMODE_PLAY;
	if (sc->sc_rbus)
		setmode |= AUMODE_RECORD;

	if (setmode) {
		sc->hw_if->set_params(sc->hw_hdl, setmode,
		    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD),
		    &sc->sc_pparams, &sc->sc_rparams);
	}

	if (sc->sc_pbus) {
		if (sc->hw_if->trigger_output)
			sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,
			    sc->sc_pr.end, sc->sc_pr.blksize,
			    audio_pint, (void *)sc, &sc->sc_pparams);
		else
			sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,
			    sc->sc_pr.blksize, audio_pint, (void *)sc);
a1276 26
	if (sc->sc_rbus) {
		if (sc->hw_if->trigger_input)
			sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,
			    sc->sc_rr.end, sc->sc_rr.blksize,
			    audio_rint, (void *)sc, &sc->sc_rparams);
		else
			sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.inp,
			    sc->sc_rr.blksize, audio_rint, (void *)sc);
	}

	sc->sc_quiesce = 0;
	wakeup(&sc->sc_quiesce);
}

/*
 * Close an audio chip.
 */
/* ARGSUSED */
int
audio_close(dev_t dev, int flags, int ifmt, struct proc *p)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_hw_if *hw = sc->hw_if;

	DPRINTF(("audio_close: unit=%d flags=0x%x\n", unit, flags));
d1278 1
a1278 3
	
	/* Stop recording. */
	if ((flags & FREAD) && sc->sc_rbus) {
d1280 2
a1281 3
		 * XXX Some drivers (e.g. SB) use the same routine
		 * to halt input and output so don't halt input if
		 * in full duplex mode.  These drivers should be fixed.
d1283 6
a1288 3
		if (!sc->sc_full_duplex ||
		    sc->hw_if->halt_input != sc->hw_if->halt_output) {
			sc->hw_if->halt_input(sc->hw_hdl);
d1290 5
a1294 1
		sc->sc_rbus = 0;
d1297 5
a1301 5
	/*
	 * If there is pending output, let it drain (unless
	 * the output is paused).
	 */
	if ((flags & FWRITE) && sc->sc_pbus) {
d1303 2
a1304 2
		 * Block until output drains, but allow ^C interrupt.
		 * XXX: drain is never used, remove it!
d1306 8
a1313 7
		mtx_enter(&audio_lock);
		/* avoid excessive wakeups */
		sc->sc_pr.usedlow = sc->sc_pr.blksize;
		mtx_leave(&audio_lock);
		if (!sc->sc_pr.pause) {
			if (!audio_drain(sc) && hw->drain)
				(void)hw->drain(sc->hw_hdl);
a1314 2
		sc->hw_if->halt_output(sc->hw_hdl);
		sc->sc_pbus = 0;
d1316 3
d1320 10
a1329 20
	hw->close(sc->hw_hdl);

	/*
	 * If flags has neither read nor write then reset both
	 * directions. Encountered when someone runs revoke(2).
	 */

	if ((flags & FREAD) || ((flags & (FREAD|FWRITE)) == 0)) {
		sc->sc_open &= ~AUOPEN_READ;
		sc->sc_mode &= ~AUMODE_RECORD;
	}
	if ((flags & FWRITE) || ((flags & (FREAD|FWRITE)) == 0)) {
		sc->sc_open &= ~AUOPEN_WRITE;
		sc->sc_mode &= ~(AUMODE_PLAY|AUMODE_PLAY_ALL);
	}

	sc->sc_async_audio = 0;
	sc->sc_full_duplex = 0;
	DPRINTF(("audio_close: done\n"));
	return (0);
d1333 1
a1333 1
audio_read(dev_t dev, struct uio *uio, int ioflag)
d1335 3
a1337 5
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_ringbuffer *cb = &sc->sc_rr;
	u_char *outp;
	int error, cc, n, resid;
d1339 1
a1339 2
	if (cb->mmapped)
		return EINVAL;
d1341 3
a1343 2
	DPRINTFN(1,("audio_read: cc=%ld mode=%d\n",
	    uio->uio_resid, sc->sc_mode));
d1345 9
a1353 7
	/*
	 * Block if fully quiesced.  Don't block when quiesce
	 * has started, as the buffer position may still need
	 * to advance.
	 */
	while (sc->sc_quiesce == AUDIO_QUIESCE_SILENT)
		tsleep(&sc->sc_quiesce, 0, "aud_qrd", 0);
d1355 19
a1373 27
	error = 0;
	/*
	 * If hardware is half-duplex and currently playing, return
	 * silence blocks based on the number of blocks we have output.
	 */
	if (!sc->sc_full_duplex &&
	    (sc->sc_mode & AUMODE_PLAY)) {
		while (uio->uio_resid > 0 && !error) {
			mtx_enter(&audio_lock);
			for(;;) {
				cc = sc->sc_pr.stamp - sc->sc_wstamp;
				if (cc > 0)
					break;
				DPRINTF(("audio_read: stamp=%lu, wstamp=%lu\n",
					 sc->sc_pr.stamp, sc->sc_wstamp));
				if (ioflag & IO_NDELAY) {
					mtx_leave(&audio_lock);
					return EWOULDBLOCK;
				}
				error = audio_sleep(&sc->sc_rchan, "aud_hr");
				if (sc->sc_dying)
					error = EIO;
				if (error) {
					mtx_leave(&audio_lock);
					return error;
				}
			}
d1375 1
a1375 6

			if (uio->uio_resid < cc)
				cc = uio->uio_resid;
			DPRINTFN(1, ("audio_read: reading in write mode, cc=%d\n", cc));
			error = audio_silence_copyout(sc, cc, uio);
			sc->sc_wstamp += cc;
a1376 1
		return (error);
d1378 6
a1383 37
	while (uio->uio_resid > 0) {
		mtx_enter(&audio_lock);
		while (cb->used <= 0) {
			if (!sc->sc_rbus && !sc->sc_rr.pause) {
				mtx_leave(&audio_lock);
				error = audiostartr(sc);
				if (error)
					return error;
				mtx_enter(&audio_lock);
				continue;
			}
			if (ioflag & IO_NDELAY) {
				mtx_leave(&audio_lock);
				return (EWOULDBLOCK);
			}
			DPRINTFN(2, ("audio_read: sleep used=%d\n", cb->used));
			error = audio_sleep(&sc->sc_rchan, "aud_rd");
			if (sc->sc_dying)
				error = EIO;
			if (error) {
				mtx_leave(&audio_lock);
				return error;
			}
		}
		resid = uio->uio_resid;
		outp = cb->outp;
		cc = cb->used - cb->usedlow; /* maximum to read */
		n = cb->end - outp;
		if (cc > n)
			cc = n;		/* don't read beyond end of buffer */
		
		if (cc > resid)
			cc = resid;	/* and no more than we want */
		cb->used -= cc;
		cb->outp += cc;
		if (cb->outp >= cb->end)
			cb->outp = cb->start;
d1385 5
a1389 4
		DPRINTFN(1,("audio_read: outp=%p, cc=%d\n", outp, cc));
		if (sc->sc_remu.sw_code)
			sc->sc_remu.sw_code(sc->hw_hdl, outp, cc);
		error = uiomove(outp, cc, uio);
d1392 2
d1395 1
a1398 120
void
audio_clear(struct audio_softc *sc)
{
	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	if (sc->sc_rbus) {
		audio_wake(&sc->sc_rchan);
		sc->hw_if->halt_input(sc->hw_hdl);
		sc->sc_rbus = 0;
	}
	if (sc->sc_pbus) {
		audio_wake(&sc->sc_wchan);
		sc->hw_if->halt_output(sc->hw_hdl);
		sc->sc_pbus = 0;
	}
}

void
audio_set_blksize(struct audio_softc *sc, int mode, int fpb) {
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_params *parm;
	struct audio_ringbuffer *rb;
	int bs, fs, maxbs;

	if (mode == AUMODE_PLAY) {
		parm = &sc->sc_pparams;
		rb = &sc->sc_pr;
	} else {
		parm = &sc->sc_rparams;
		rb = &sc->sc_rr;
	}

	fs = parm->channels * parm->bps;
	bs = fpb * fs;
	maxbs = rb->bufsize / 2;
	if (bs > maxbs)
		bs = (maxbs / fs) * fs;

	ROUNDSIZE(bs);
	if (hw->round_blocksize)
		bs = hw->round_blocksize(sc->hw_hdl, bs);
	rb->blksize = bs;

	DPRINTF(("audio_set_blksize: %s blksize=%d\n",
		 mode == AUMODE_PLAY ? "play" : "record", bs));
}

void
audio_calc_blksize(struct audio_softc *sc, int mode)
{
	struct audio_params *param;

	if (mode == AUMODE_PLAY) {
		if (sc->sc_pr.blkset)
			return;
		param = &sc->sc_pparams;
	} else {
		if (sc->sc_rr.blkset)
			return;
		param = &sc->sc_rparams;
	}
	audio_set_blksize(sc, mode, param->sample_rate * audio_blk_ms / 1000);
}

void
audio_fill_silence(struct audio_params *params, u_char *start, u_char *p, int n)
{
	size_t rounderr;
	int i, nsamples;
	u_char auzero[4] = {0, 0, 0, 0};

	/*
	 * p may point the middle of a sample; round it to the
	 * beginning of the sample, so we overwrite partially written
	 * ones.
	 */
	rounderr = (p - start) % params->bps;
	p -= rounderr;
	n += rounderr;
	nsamples = n / params->bps;

	switch (params->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
		break;
	case AUDIO_ENCODING_ULAW:
		auzero[0] = 0x7f;
		break;
	case AUDIO_ENCODING_ALAW:
		auzero[0] = 0x55;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		if (params->msb == 1)
			auzero[params->bps - 1] = 0x80;
		else
			auzero[params->bps - 1] = 1 << ((params->precision + 7) % NBBY);
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		if (params->msb == 1)
			auzero[0] = 0x80;
		else
			auzero[0] = 1 << ((params->precision + 7) % NBBY);
		break;
	case AUDIO_ENCODING_MPEG_L1_STREAM:
	case AUDIO_ENCODING_MPEG_L1_PACKETS:
	case AUDIO_ENCODING_MPEG_L1_SYSTEM:
	case AUDIO_ENCODING_MPEG_L2_STREAM:
	case AUDIO_ENCODING_MPEG_L2_PACKETS:
	case AUDIO_ENCODING_MPEG_L2_SYSTEM:
	case AUDIO_ENCODING_ADPCM: /* is this right XXX */
		break;
	default:
		DPRINTF(("audio: bad encoding %d\n", params->encoding));
		break;
	}
	while (--nsamples >= 0) {
		for (i = 0; i < params->bps; i++) 
			*p++ = auzero[i];
	}
}

d1400 1
a1400 1
audio_silence_copyout(struct audio_softc *sc, int n, struct uio *uio)
d1402 2
a1404 22
	int k;
	u_char zerobuf[128];

	audio_fill_silence(&sc->sc_rparams, zerobuf, zerobuf, sizeof zerobuf);

	error = 0;
	while (n > 0 && uio->uio_resid > 0 && !error) {
		k = min(n, min(uio->uio_resid, sizeof zerobuf));
		error = uiomovei(zerobuf, k, uio);
		n -= k;
	}
	return (error);
}

int
audio_write(dev_t dev, struct uio *uio, int ioflag)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_ringbuffer *cb = &sc->sc_pr;
	u_char *inp;
	int error, n, cc, resid, avail;
d1406 1
a1406 2
	DPRINTFN(2, ("audio_write: sc=%p(unit=%d) count=%zd used=%d(hi=%d)\n", sc, unit,
		 uio->uio_resid, sc->sc_pr.used, sc->sc_pr.usedhigh));
d1408 3
a1410 2
	if (cb->mmapped)
		return EINVAL;
d1413 3
a1415 3
	 * Block if fully quiesced.  Don't block when quiesce
	 * has started, as the buffer position may still need
	 * to advance.
d1417 6
a1422 27
	while (sc->sc_quiesce == AUDIO_QUIESCE_SILENT)
		tsleep(&sc->sc_quiesce, 0, "aud_qwr", 0);

	if (uio->uio_resid == 0) {
		sc->sc_eof++;
		return 0;
	}

	/*
	 * If half-duplex and currently recording, throw away data.
	 */
	if (!sc->sc_full_duplex &&
	    (sc->sc_mode & AUMODE_RECORD)) {
		uio->uio_offset += uio->uio_resid;
		uio->uio_resid = 0;
		DPRINTF(("audio_write: half-dpx read busy\n"));
		return (0);
	}

	if (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) {
		n = min(sc->sc_playdrop, uio->uio_resid);
		DPRINTF(("audio_write: playdrop %d\n", n));
		uio->uio_offset += n;
		uio->uio_resid -= n;
		sc->sc_playdrop -= n;
		if (uio->uio_resid == 0)
			return 0;
a1424 4
	DPRINTFN(1, ("audio_write: sr=%ld, enc=%d, prec=%d, chan=%d\n",
		sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
		sc->sc_pparams.precision, sc->sc_pparams.channels));

d1426 4
a1429 4
		mtx_enter(&audio_lock);
		while (cb->used >= cb->usedhigh) {
			DPRINTFN(2, ("audio_write: sleep used=%d lowat=%d hiwat=%d\n",
				 cb->used, cb->usedlow, cb->usedhigh));
d1431 4
d1436 1
a1436 1
				return (EWOULDBLOCK);
d1438 5
a1442 2
			error = audio_sleep(&sc->sc_wchan, "aud_wr");
			if (sc->sc_dying)
d1444 6
d1455 4
a1458 27
		resid = uio->uio_resid;
		avail = cb->end - cb->inp;
		inp = cb->inp;
		cc = cb->usedhigh - cb->used;
		if (cc > resid)
			cc = resid;
		if (cc > avail)
			cc = avail;
		cb->inp += cc;
		if (cb->inp >= cb->end)
			cb->inp = cb->start;
		cb->used += cc;
		/*
		 * This is a very suboptimal way of keeping track of
		 * silence in the buffer, but it is simple.
		 */
		sc->sc_sil_count = 0;
		if (!sc->sc_pbus && !cb->pause && cb->used >= cb->blksize) {
			mtx_leave(&audio_lock);
			error = audiostartp(sc);
			if (error)
				return error;
		} else
			mtx_leave(&audio_lock);
		DPRINTFN(1, ("audio_write: uiomove cc=%d inp=%p, left=%zd\n",
		    cc, inp, uio->uio_resid));
		error = uiomovei(inp, cc, uio);
d1461 4
a1464 3
		if (sc->sc_pemu.sw_code) {
			sc->sc_pemu.sw_code(sc->hw_hdl, inp, cc);
			DPRINTFN(1, ("audio_write: expanded cc=%d\n", cc));
d1466 2
a1467 1474
	}
	return 0;
}

int
audio_ioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_offset *ao;
	struct audio_info ai;
	int error = 0, offs, fd;
	int rbus, pbus;

	/*
	 * Block if fully quiesced.  Don't block when quiesce
	 * has started, as the buffer position may still need
	 * to advance.  An ioctl may be used to determine how
	 * much to read or write.
	 */
	while (sc->sc_quiesce == AUDIO_QUIESCE_SILENT)
		tsleep(&sc->sc_quiesce, 0, "aud_qio", 0);

	DPRINTF(("audio_ioctl(%ld,'%c',%ld)\n",
		IOCPARM_LEN(cmd), (int)IOCGROUP(cmd), cmd&0xff));
	switch (cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer. */
		break;

	case FIOASYNC:
		if (*(int *)addr) {
			if (sc->sc_async_audio)
				return (EBUSY);
			sc->sc_async_audio = p;
			DPRINTF(("audio_ioctl: FIOASYNC %p\n", p));
		} else
			sc->sc_async_audio = 0;
		break;

	case AUDIO_FLUSH:
		DPRINTF(("AUDIO_FLUSH\n"));
		rbus = sc->sc_rbus;
		pbus = sc->sc_pbus;
		audio_clear(sc);
		error = audio_initbufs(sc);
		if (error) {
			return error;
		}
		sc->sc_rr.pause = 0;
		sc->sc_pr.pause = 0;
		if ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pbus && pbus)
			error = audiostartp(sc);
		if (!error &&
		    (sc->sc_mode & AUMODE_RECORD) && !sc->sc_rbus && rbus)
			error = audiostartr(sc);
		break;

	/*
	 * Number of read (write) samples dropped.  We don't know where or
	 * when they were dropped.
	 * 
	 * The audio_ringbuffer->drops count is the number of buffer
	 * sample size bytes.  Convert it to userland sample size bytes,
	 * then convert to samples.  There is no easy way to get the
	 * buffer sample size, but the userland sample size can be
	 * calculated with userland channels and userland precision.
	 *
	 * original formula:
	 *  sc->sc_rr.drops /
	 *  (sc->sc_rparams.channels * sc->sc_rparams.bps)
	 */
	case AUDIO_RERROR:
		*(int *)addr = sc->sc_rr.drops /
		    (sc->sc_rparams.channels * sc->sc_rparams.bps);
		break;

	case AUDIO_PERROR:
		*(int *)addr = sc->sc_pr.drops /
		    (sc->sc_pparams.channels * sc->sc_pparams.bps);
		break;

	/*
	 * Offsets into buffer.
	 */
	case AUDIO_GETIOFFS:
		mtx_enter(&audio_lock);
		/* figure out where next DMA will start */
		ao = (struct audio_offset *)addr;
		ao->samples = sc->sc_rr.stamp;
		ao->deltablks = (sc->sc_rr.stamp - sc->sc_rr.stamp_last) / sc->sc_rr.blksize;
		sc->sc_rr.stamp_last = sc->sc_rr.stamp;
		ao->offset = sc->sc_rr.inp - sc->sc_rr.start;
		mtx_leave(&audio_lock);
		break;

	case AUDIO_GETOOFFS:
		mtx_enter(&audio_lock);
		/* figure out where next DMA will start */
		ao = (struct audio_offset *)addr;
		offs = sc->sc_pr.outp - sc->sc_pr.start + sc->sc_pr.blksize;
		if (sc->sc_pr.start + offs >= sc->sc_pr.end)
			offs = 0;
		ao->samples = sc->sc_pr.stamp;
		ao->deltablks = (sc->sc_pr.stamp - sc->sc_pr.stamp_last) / sc->sc_pr.blksize;
		sc->sc_pr.stamp_last = sc->sc_pr.stamp;
		ao->offset = offs;
		mtx_leave(&audio_lock);
		break;

	/*
	 * How many bytes will elapse until mike hears the first
	 * sample of what we write next?
	 */
	case AUDIO_WSEEK:
		*(u_long *)addr = sc->sc_pr.used;
		break;

	case AUDIO_SETINFO:
		DPRINTF(("AUDIO_SETINFO mode=0x%x\n", sc->sc_mode));
		error = audiosetinfo(sc, (struct audio_info *)addr);
		break;

	case AUDIO_GETINFO:
		DPRINTF(("AUDIO_GETINFO\n"));
		error = audiogetinfo(sc, (struct audio_info *)addr);
		break;

	case AUDIO_DRAIN:
		DPRINTF(("AUDIO_DRAIN\n"));
		error = audio_drain(sc);
		if (!error && hw->drain)
		    error = hw->drain(sc->hw_hdl);
		break;

	case AUDIO_GETDEV:
		DPRINTF(("AUDIO_GETDEV\n"));
		error = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);
		break;

	case AUDIO_GETENC:
		DPRINTF(("AUDIO_GETENC\n"));
		/* Pass read/write info down to query_encoding */
		((struct audio_encoding *)addr)->flags = sc->sc_open;
		error = hw->query_encoding(sc->hw_hdl, (struct audio_encoding *)addr);
		break;

	case AUDIO_GETFD:
		DPRINTF(("AUDIO_GETFD\n"));
		*(int *)addr = sc->sc_full_duplex;
		break;

	case AUDIO_SETFD:
		DPRINTF(("AUDIO_SETFD\n"));
		fd = *(int *)addr;
		if (hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX) {
			if (hw->setfd)
				error = hw->setfd(sc->hw_hdl, fd);
			else
				error = 0;
			if (!error) {
				sc->sc_full_duplex = fd;
				if (fd) {
					AUDIO_INITINFO(&ai);
					ai.mode = sc->sc_mode |
					    (AUMODE_PLAY | AUMODE_RECORD);
					error = audiosetinfo(sc, &ai);
				}
			}
		} else {
			if (fd)
				error = ENOTTY;
			else
				error = 0;
		}
		break;

	case AUDIO_GETPROPS:
		DPRINTF(("AUDIO_GETPROPS\n"));
		*(int *)addr = hw->get_props(sc->hw_hdl);
		break;

	case AUDIO_GETPRINFO:
		DPRINTF(("AUDIO_GETPRINFO\n"));
		error = audiogetbufinfo(sc, (struct audio_bufinfo *)addr,
		    AUMODE_PLAY);
		break;

	case AUDIO_GETRRINFO:
		DPRINTF(("AUDIO_GETRRINFO\n"));
		error = audiogetbufinfo(sc, (struct audio_bufinfo *)addr,
		    AUMODE_RECORD);
		break;

	default:
		DPRINTF(("audio_ioctl: unknown ioctl\n"));
		error = ENOTTY;
		break;
	}
	DPRINTF(("audio_ioctl(%ld,'%c',%ld) result %d\n",
		IOCPARM_LEN(cmd), (int)IOCGROUP(cmd), cmd&0xff, error));
	return (error);
}

void
audio_selwakeup(struct audio_softc *sc, int play)
{
	struct selinfo *si;

	si = play? &sc->sc_wsel : &sc->sc_rsel;

	audio_wake(play? &sc->sc_wchan : &sc->sc_rchan);
	selwakeup(si);
	if (sc->sc_async_audio)
		psignal(sc->sc_async_audio, SIGIO);
}

#define	AUDIO_FILTREAD(sc) ( \
    (!sc->sc_full_duplex && (sc->sc_mode & AUMODE_PLAY)) ? \
    sc->sc_pr.stamp > sc->sc_wstamp : sc->sc_rr.used > sc->sc_rr.usedlow)
    
#define	AUDIO_FILTWRITE(sc) ( \
    (!sc->sc_full_duplex && (sc->sc_mode & AUMODE_RECORD)) ||		\
    (!(sc->sc_mode & AUMODE_PLAY_ALL) && sc->sc_playdrop > 0) || 	\
    (sc->sc_pr.used < (sc->sc_pr.usedlow + sc->sc_pr.blksize)))

int
audio_poll(dev_t dev, int events, struct proc *p)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	int revents = 0;

	mtx_enter(&audio_lock);

	DPRINTF(("audio_poll: events=0x%x mode=%d\n", events, sc->sc_mode));

	if (events & (POLLIN | POLLRDNORM)) {
		if (AUDIO_FILTREAD(sc))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (AUDIO_FILTWRITE(sc))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->sc_rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->sc_wsel);
	}
	mtx_leave(&audio_lock);
	return (revents);
}

paddr_t
audio_mmap(dev_t dev, off_t off, int prot)
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_ringbuffer *cb;

	DPRINTF(("audio_mmap: off=%lld, prot=%d\n", off, prot));

	if (!(hw->get_props(sc->hw_hdl) & AUDIO_PROP_MMAP) || !hw->mappage)
		return -1;
#if 0
/* XXX
 * The idea here was to use the protection to determine if
 * we are mapping the read or write buffer, but it fails.
 * The VM system is broken in (at least) two ways.
 * 1) If you map memory PROT_WRITE you SIGSEGV
 *    when writing to it, so PROT_READ|PROT_WRITE
 *    has to be used for mmapping the play buffer.
 * 2) Even if calling mmap() with PROT_READ|PROT_WRITE
 *    audio_mmap will get called at some point with PROT_READ
 *    only.
 * So, alas, we always map the play buffer for now.
 */
	if (prot == (PROT_READ | PROT_WRITE) ||
	    prot == PROT_WRITE)
		cb = &sc->sc_pr;
	else if (prot == PROT_READ)
		cb = &sc->sc_rr;
	else
		return -1;
#else
	cb = &sc->sc_pr;
#endif

	if ((u_int)off >= cb->bufsize)
		return -1;
	if (!cb->mmapped) {
		cb->mmapped = 1;
		if (cb == &sc->sc_pr) {
			audio_fill_silence(&sc->sc_pparams, cb->start, cb->start, cb->bufsize);
			if (!sc->sc_pbus && !sc->sc_pr.pause)
				(void)audiostartp(sc);
		} else {
			if (!sc->sc_rbus && !sc->sc_rr.pause)
				(void)audiostartr(sc);
		}
	}

	return hw->mappage(sc->hw_hdl, cb->start, off, prot);
}

int
audiostartr(struct audio_softc *sc)
{
	int error;

	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	DPRINTF(("audiostartr: start=%p used=%d(hi=%d) mmapped=%d\n",
		 sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh,
		 sc->sc_rr.mmapped));

	if (sc->hw_if->trigger_input)
		error = sc->hw_if->trigger_input(sc->hw_hdl, sc->sc_rr.start,
		    sc->sc_rr.end, sc->sc_rr.blksize,
		    audio_rint, (void *)sc, &sc->sc_rparams);
	else
		error = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start,
		    sc->sc_rr.blksize, audio_rint, (void *)sc);
	if (error) {
		DPRINTF(("audiostartr failed: %d\n", error));
		return error;
	}
	sc->sc_rbus = 1;
	return 0;
}

int
audiostartp(struct audio_softc *sc)
{
	int error;

	MUTEX_ASSERT_UNLOCKED(&audio_lock);
	DPRINTF(("audiostartp: start=%p used=%d(hi=%d) mmapped=%d\n",
		 sc->sc_pr.start, sc->sc_pr.used, sc->sc_pr.usedhigh,
		 sc->sc_pr.mmapped));

	if (!sc->sc_pr.mmapped && sc->sc_pr.used < sc->sc_pr.blksize)
		return 0;

	if (sc->hw_if->trigger_output)
		error = sc->hw_if->trigger_output(sc->hw_hdl, sc->sc_pr.start,
		    sc->sc_pr.end, sc->sc_pr.blksize,
		    audio_pint, (void *)sc, &sc->sc_pparams);
	else
		error = sc->hw_if->start_output(sc->hw_hdl, sc->sc_pr.outp,
		    sc->sc_pr.blksize, audio_pint, (void *)sc);
	if (error) {
		DPRINTF(("audiostartp failed: %d\n", error));
		return error;
	}
	sc->sc_pbus = 1;
	return 0;
}

/*
 * When the play interrupt routine finds that the write isn't keeping
 * the buffer filled it will insert silence in the buffer to make up
 * for this.  The part of the buffer that is filled with silence
 * is kept track of in a very approximate way: it starts at sc_sil_start
 * and extends sc_sil_count bytes.  If there is already silence in
 * the requested area nothing is done; so when the whole buffer is
 * silent nothing happens.  When the writer starts again sc_sil_count
 * is set to 0.
 */
/* XXX
 * Putting silence into the output buffer should not really be done
 * with audio_lock, but there is no softaudio level to do it at yet.
 */
static __inline void
audio_pint_silence(struct audio_softc *sc, struct audio_ringbuffer *cb,
    u_char *inp, int cc)
{
	u_char *s, *e, *p, *q;

	if (sc->sc_sil_count > 0) {
		s = sc->sc_sil_start; /* start of silence */
		e = s + sc->sc_sil_count; /* end of silence, may be beyond end */
		p = inp;	/* adjusted pointer to area to fill */
		if (p < s)
			p += cb->end - cb->start;
		q = p+cc;
		/* Check if there is already silence. */
		if (!(s <= p && p <  e &&
		      s <= q && q <= e)) {
			if (s <= p)
				sc->sc_sil_count = max(sc->sc_sil_count, q-s);
			DPRINTFN(5, ("audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\n",
			    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));

			if (sc->sc_pemu.sw_code) {
				audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);
				sc->sc_pemu.sw_code(sc->hw_hdl, inp, cc);
			} else
				audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);

		} else {
			DPRINTFN(5, ("audio_pint_silence: already silent cc=%d inp=%p\n", cc, inp));

		}
	} else {
		sc->sc_sil_start = inp;
		sc->sc_sil_count = cc;
		DPRINTFN(5, ("audio_pint_silence: start fill %p %d\n",
		    inp, cc));

		if (sc->sc_pemu.sw_code) {
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);
			sc->sc_pemu.sw_code(sc->hw_hdl, inp, cc);
		} else
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, cc);

	}
}

/*
 * Called from HW driver module on completion of dma output.
 * Start output of new block, wrap in ring buffer if needed.
 * If no more buffers to play, output zero instead.
 * Do a wakeup if necessary.
 */
void
audio_pint(void *v)
{
	struct audio_softc *sc = v;
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_ringbuffer *cb = &sc->sc_pr;
	u_char *inp;
	int cc;
	int blksize;
	int error;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */

	if (sc->sc_pqui)
		return;

	blksize = cb->blksize;

	add_audio_randomness((long)cb);

	cb->outp += blksize;
	if (cb->outp >= cb->end)
		cb->outp = cb->start;
	cb->stamp += blksize;
	if (cb->mmapped) {
		DPRINTFN(5, ("audio_pint: mmapped outp=%p cc=%d inp=%p\n",
		    cb->outp, blksize, cb->inp));
		if (!hw->trigger_output)
			(void)hw->start_output(sc->hw_hdl, cb->outp,
			    blksize, audio_pint, (void *)sc);
		return;
	}

#ifdef AUDIO_INTR_TIME
	{
		struct timeval tv;
		u_long t;
		microtime(&tv);
		t = tv.tv_usec + 1000000 * tv.tv_sec;
		if (sc->sc_pnintr) {
			long lastdelta, totdelta;
			lastdelta = t - sc->sc_plastintr - sc->sc_pblktime;
			if (lastdelta > sc->sc_pblktime / 3) {
				printf("audio: play interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_pnintr, lastdelta, sc->sc_pblktime);
			}
			totdelta = t - sc->sc_pfirstintr - sc->sc_pblktime * sc->sc_pnintr;
			if (totdelta > sc->sc_pblktime) {
				printf("audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\n",
				    sc->sc_pnintr, totdelta, sc->sc_pblktime);
				sc->sc_pnintr++; /* avoid repeated messages */
			}
		} else
			sc->sc_pfirstintr = t;
		sc->sc_plastintr = t;
		sc->sc_pnintr++;
	}
#endif

	cb->used -= blksize;
	if (cb->used < blksize) {
		/* we don't have a full block to use */
		inp = cb->inp;
		cc = blksize - (inp - cb->start) % blksize;
		if (cb->pause)
			cb->pdrops += cc;
		else {
			cb->drops += cc;
			sc->sc_playdrop += cc;
		}
		audio_pint_silence(sc, cb, inp, cc);
		inp += cc;
		if (inp >= cb->end)
			inp = cb->start;
		cb->inp = inp;
		cb->used += cc;

		/* Clear next block so we keep ahead of the DMA. */
		if (cb->used + cc < cb->usedhigh)
			audio_pint_silence(sc, cb, inp, blksize);
	}

	DPRINTFN(5, ("audio_pint: outp=%p cc=%d\n", cb->outp, blksize));
	if (!hw->trigger_output) {
		error = hw->start_output(sc->hw_hdl, cb->outp, blksize,
		    audio_pint, (void *)sc);
		if (error) {
			/* XXX does this really help? */
			DPRINTF(("audio_pint restart failed: %d\n", error));
		}
	}

	DPRINTFN(2, ("audio_pint: mode=%d pause=%d used=%d lowat=%d\n",
	    sc->sc_mode, cb->pause, cb->used, cb->usedlow));
	if ((sc->sc_mode & AUMODE_PLAY) && !cb->pause &&
	    cb->used <= cb->usedlow)
		audio_selwakeup(sc, 1);

	/* Possible to return one or more "phantom blocks" now. */
	if (!sc->sc_full_duplex && sc->sc_rchan)
		audio_selwakeup(sc, 0);

	/*
	 * If quiesce requested, halt output when the ring buffer position
	 * is at the beginning, because when the hardware is resumed, it's
	 * buffer position is reset to the beginning.  This will put
	 * hardware and software positions in sync across a suspend cycle.
	 */
	if (sc->sc_quiesce == AUDIO_QUIESCE_START && cb->outp == cb->start) {
		sc->sc_pqui = 1;
		audio_wake(&sc->sc_wchan);
	}
}

/*
 * Called from HW driver module on completion of dma input.
 * Mark it as input in the ring buffer (fiddle pointers).
 * Do a wakeup if necessary.
 */
void
audio_rint(void *v)
{
	struct audio_softc *sc = v;
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_ringbuffer *cb = &sc->sc_rr;
	int blksize;
	int error;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */

	if (sc->sc_rqui)
		return;

	add_audio_randomness((long)cb);

	blksize = cb->blksize;

	cb->inp += blksize;
	if (cb->inp >= cb->end)
		cb->inp = cb->start;
	cb->stamp += blksize;
	if (cb->mmapped) {
		DPRINTFN(2, ("audio_rint: mmapped inp=%p cc=%d\n",
		    cb->inp, blksize));
		if (!hw->trigger_input)
			(void)hw->start_input(sc->hw_hdl, cb->inp, blksize,
			    audio_rint, (void *)sc);
		return;
	}

#ifdef AUDIO_INTR_TIME
	{
		struct timeval tv;
		u_long t;
		microtime(&tv);
		t = tv.tv_usec + 1000000 * tv.tv_sec;
		if (sc->sc_rnintr) {
			long lastdelta, totdelta;
			lastdelta = t - sc->sc_rlastintr - sc->sc_rblktime;
			if (lastdelta > sc->sc_rblktime / 5) {
				printf("audio: record interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_rnintr, lastdelta, sc->sc_rblktime);
			}
			totdelta = t - sc->sc_rfirstintr - sc->sc_rblktime * sc->sc_rnintr;
			if (totdelta > sc->sc_rblktime / 2) {
				sc->sc_rnintr++;
				printf("audio: record interrupt(%d) off absolute by %ld us (%lu)\n",
				    sc->sc_rnintr, totdelta, sc->sc_rblktime);
				sc->sc_rnintr++; /* avoid repeated messages */
			}
		} else
			sc->sc_rfirstintr = t;
		sc->sc_rlastintr = t;
		sc->sc_rnintr++;
	}
#endif

	cb->used += blksize;
	if (cb->pause) {
		DPRINTFN(1, ("audio_rint: pdrops %lu\n", cb->pdrops));
		cb->pdrops += blksize;
		cb->outp += blksize;
		if (cb->outp >= cb->end)
			cb->outp = cb->start;
		cb->used -= blksize;
	} else if (cb->used >= cb->usedhigh) {
		DPRINTFN(1, ("audio_rint: drops %lu\n", cb->drops));
		cb->drops += blksize;
		cb->outp += blksize;
		if (cb->outp >= cb->end)
			cb->outp = cb->start;
		cb->used -= blksize;
	}

	DPRINTFN(2, ("audio_rint: inp=%p cc=%d used=%d\n",
	    cb->inp, blksize, cb->used));
	if (!hw->trigger_input) {
		error = hw->start_input(sc->hw_hdl, cb->inp, blksize,
		    audio_rint, (void *)sc);
		if (error) {
			/* XXX does this really help? */
			DPRINTF(("audio_rint: restart failed: %d\n", error));
		}
	}

	audio_selwakeup(sc, 0);

	/*
	 * If quiesce requested, halt input when the ring buffer position
	 * is at the beginning, because when the hardware is resumed, it's
	 * buffer position is reset to the beginning.  This will put
	 * hardware and software positions in sync across a suspend cycle.
	 */
	if (sc->sc_quiesce == AUDIO_QUIESCE_START && cb->inp == cb->start) {
		sc->sc_rqui = 1;
		audio_wake(&sc->sc_rchan);
	}
}

int
audio_check_params(struct audio_params *p)
{
	if (p->channels < 1 || p->channels > 12)
		return (EINVAL);

	if (p->precision < 8 || p->precision > 32)
		return (EINVAL);

	if (p->encoding == AUDIO_ENCODING_PCM16) {
		if (p->precision == 8)
			p->encoding = AUDIO_ENCODING_ULINEAR;
		else
			p->encoding = AUDIO_ENCODING_SLINEAR;
	} else if (p->encoding == AUDIO_ENCODING_PCM8) {
		if (p->precision == 8)
			p->encoding = AUDIO_ENCODING_ULINEAR;
		else
			return EINVAL;
	}

	if (p->encoding == AUDIO_ENCODING_SLINEAR)
#if BYTE_ORDER == LITTLE_ENDIAN
		p->encoding = AUDIO_ENCODING_SLINEAR_LE;
#else
		p->encoding = AUDIO_ENCODING_SLINEAR_BE;
#endif
	if (p->encoding == AUDIO_ENCODING_ULINEAR)
#if BYTE_ORDER == LITTLE_ENDIAN
		p->encoding = AUDIO_ENCODING_ULINEAR_LE;
#else
		p->encoding = AUDIO_ENCODING_ULINEAR_BE;
#endif

	switch (p->encoding) {
	case AUDIO_ENCODING_ADPCM:
		if (p->precision != 8)
			p->precision = 8;
		break;
	case AUDIO_ENCODING_ULAW:
	case AUDIO_ENCODING_ALAW:
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
	case AUDIO_ENCODING_MPEG_L1_STREAM:
	case AUDIO_ENCODING_MPEG_L1_PACKETS:
	case AUDIO_ENCODING_MPEG_L1_SYSTEM:
	case AUDIO_ENCODING_MPEG_L2_STREAM:
	case AUDIO_ENCODING_MPEG_L2_PACKETS:
	case AUDIO_ENCODING_MPEG_L2_SYSTEM:
		break;
	default:
		return (EINVAL);
	}

	return (0);
}

void
audio_emu_setup(int mode, struct audio_params *p, struct audio_emu *e)
{
	if (p->encoding == e->encoding) {
		e->sw_code = NULL;
		return;
	}
	switch (p->encoding) {
	case AUDIO_ENCODING_ULAW:
#if BYTE_ORDER == LITTLE_ENDIAN
		e->encoding = AUDIO_ENCODING_SLINEAR_LE;
#else
		e->encoding = AUDIO_ENCODING_SLINEAR_BE;
#endif
		if (p->precision == 8) {
			e->sw_code = (mode == AUMODE_PLAY) ?
			    slinear8_to_mulaw : mulaw_to_slinear8;
			break;
		} else if (p->precision == 24) {
			e->sw_code = (mode == AUMODE_PLAY) ?
			    slinear24_to_mulaw24 : mulaw24_to_slinear24;
			break;
		}
		/* FALLTHROUGH */
	default:
		e->encoding = p->encoding;
		e->sw_code = NULL;
	}
}

int
au_set_lr_value(struct audio_softc *sc, mixer_ctrl_t *ct, int l, int r)
{
	ct->type = AUDIO_MIXER_VALUE;
	ct->un.value.num_channels = 2;
	ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
	ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
	if (sc->hw_if->set_port(sc->hw_hdl, ct) == 0)
		return 0;
	ct->un.value.num_channels = 1;
	ct->un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;
	return sc->hw_if->set_port(sc->hw_hdl, ct);
}

int
au_get_mute(struct audio_softc *sc, struct au_mixer_ports *ports, u_char *mute)
{
	mixer_devinfo_t mi;
	mixer_ctrl_t ct;
	int error;

	*mute = 0;

	 /* if no master, silently ignore request */
	if (ports->master == -1)
		return 0;

	mi.index = ports->master;
	error = sc->hw_if->query_devinfo(sc->hw_hdl, &mi);
	if (error != 0)
		return error;

	/* master mute control should be the next device, if it exists */
	if (mi.next < 0)
		return 0;

	ct.dev = mi.next;
	ct.type = AUDIO_MIXER_ENUM;
	error = sc->hw_if->get_port(sc->hw_hdl, &ct);
	if (error != 0)
		return error;

	*mute = ct.un.ord;

	return error;
}

int
au_set_mute(struct audio_softc *sc, struct au_mixer_ports *ports, u_char mute)
{
	mixer_devinfo_t mi;
	mixer_ctrl_t ct;
	int error;

	 /* if no master, silently ignore request */
	if (ports->master == -1)
		return 0;

	mi.index = ports->master;
	error = sc->hw_if->query_devinfo(sc->hw_hdl, &mi);
	if (error != 0)
		return error;

	/* master mute control should be the next device, if it exists */
	if (mi.next < 0)
		return 0;

	ct.dev = mi.next;
	ct.type = AUDIO_MIXER_ENUM;
	error = sc->hw_if->get_port(sc->hw_hdl, &ct);
	if (error != 0)
		return error;

	DPRINTF(("au_set_mute: mute (old): %d, mute (new): %d\n",
	    ct.un.ord, mute));

	ct.un.ord = (mute != 0 ? 1 : 0);
	error = sc->hw_if->set_port(sc->hw_hdl, &ct);

	if (!error)
		mixer_signal(sc);
	return error;
}

int
au_set_gain(struct audio_softc *sc, struct au_mixer_ports *ports, int gain,
    int balance)
{
	mixer_ctrl_t ct;
	int i, error;
	int l, r;
	u_int mask;
	int nset;

	/* XXX silently adjust to within limits or return EINVAL ? */
	if (gain > AUDIO_MAX_GAIN)
		gain = AUDIO_MAX_GAIN;
	else if (gain < AUDIO_MIN_GAIN)
		gain = AUDIO_MIN_GAIN;

	if (balance == AUDIO_MID_BALANCE) {
		l = r = gain;
	} else if (balance < AUDIO_MID_BALANCE) {
		r = gain;
		l = (balance * gain) / AUDIO_MID_BALANCE;
	} else {
		l = gain;
		r = ((AUDIO_RIGHT_BALANCE - balance) * gain)
		    / AUDIO_MID_BALANCE;
	}
	DPRINTF(("au_set_gain: gain=%d balance=%d, l=%d r=%d\n",
		 gain, balance, l, r));

	if (ports->index == -1) {
	usemaster:
		if (ports->master == -1)
			return 0; /* just ignore it silently */
		ct.dev = ports->master;
		error = au_set_lr_value(sc, &ct, l, r);
	} else {
		ct.dev = ports->index;
		if (ports->isenum) {
			ct.type = AUDIO_MIXER_ENUM;
			error = sc->hw_if->get_port(sc->hw_hdl, &ct);
			if (error)
				return error;
			for(i = 0; i < ports->nports; i++) {
				if (ports->misel[i] == ct.un.ord) {
					ct.dev = ports->miport[i];
					if (ct.dev == -1 ||
					    au_set_lr_value(sc, &ct, l, r))
						goto usemaster;
					else
						break;
				}
			}
		} else {
			ct.type = AUDIO_MIXER_SET;
			error = sc->hw_if->get_port(sc->hw_hdl, &ct);
			if (error)
				return error;
			mask = ct.un.mask;
			nset = 0;
			for(i = 0; i < ports->nports; i++) {
				if (ports->misel[i] & mask) {
				    ct.dev = ports->miport[i];
				    if (ct.dev != -1 &&
					au_set_lr_value(sc, &ct, l, r) == 0)
					    nset++;
				}
			}
			if (nset == 0)
				goto usemaster;
		}
	}
	if (!error)
		mixer_signal(sc);
	return error;
}

int
au_get_lr_value(struct audio_softc *sc, mixer_ctrl_t *ct, int *l, int *r)
{
	int error;

	ct->un.value.num_channels = 2;
	if (sc->hw_if->get_port(sc->hw_hdl, ct) == 0) {
		*l = ct->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		*r = ct->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
	} else {
		ct->un.value.num_channels = 1;
		error = sc->hw_if->get_port(sc->hw_hdl, ct);
		if (error)
			return error;
		*r = *l = ct->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	}
	return 0;
}

void
au_get_gain(struct audio_softc *sc, struct au_mixer_ports *ports, u_int *pgain,
    u_char *pbalance)
{
	mixer_ctrl_t ct;
	int i, l, r, n;
	int lgain = AUDIO_MAX_GAIN/2, rgain = AUDIO_MAX_GAIN/2;

	if (ports->index == -1) {
	usemaster:
		if (ports->master == -1)
			goto bad;
		ct.dev = ports->master;
		ct.type = AUDIO_MIXER_VALUE;
		if (au_get_lr_value(sc, &ct, &lgain, &rgain))
			goto bad;
	} else {
		ct.dev = ports->index;
		if (ports->isenum) {
			ct.type = AUDIO_MIXER_ENUM;
			if (sc->hw_if->get_port(sc->hw_hdl, &ct))
				goto bad;
			ct.type = AUDIO_MIXER_VALUE;
			for(i = 0; i < ports->nports; i++) {
				if (ports->misel[i] == ct.un.ord) {
					ct.dev = ports->miport[i];
					if (ct.dev == -1 ||
					    au_get_lr_value(sc, &ct,
							    &lgain, &rgain))
						goto usemaster;
					else
						break;
				}
			}
		} else {
			ct.type = AUDIO_MIXER_SET;
			if (sc->hw_if->get_port(sc->hw_hdl, &ct))
				goto bad;
			ct.type = AUDIO_MIXER_VALUE;
			lgain = rgain = n = 0;
			for(i = 0; i < ports->nports; i++) {
				if (ports->misel[i] & ct.un.mask) {
					ct.dev = ports->miport[i];
					if (ct.dev == -1 ||
					    au_get_lr_value(sc, &ct, &l, &r))
						goto usemaster;
					else {
						lgain += l;
						rgain += r;
						n++;
					}
				}
			}
			if (n != 0) {
				lgain /= n;
				rgain /= n;
			}
		}
	}
bad:
	if (lgain == rgain) {	/* handles lgain==rgain==0 */
		*pgain = lgain;
		*pbalance = AUDIO_MID_BALANCE;
	} else if (lgain < rgain) {
		*pgain = rgain;
		*pbalance = (AUDIO_MID_BALANCE * lgain) / rgain;
	} else /* lgain > rgain */ {
		*pgain = lgain;
		*pbalance = AUDIO_RIGHT_BALANCE -
			    (AUDIO_MID_BALANCE * rgain) / lgain;
	}
}

int
au_set_port(struct audio_softc *sc, struct au_mixer_ports *ports, u_int port)
{
	mixer_ctrl_t ct;
	int i, error;

	if (port == 0)	/* allow this special case */
		return 0;

	if (ports->index == -1)
		return EINVAL;
	ct.dev = ports->index;
	if (ports->isenum) {
		if (port & (port-1))
			return EINVAL; /* Only one port allowed */
		ct.type = AUDIO_MIXER_ENUM;
		error = EINVAL;
		for(i = 0; i < ports->nports; i++)
			if (ports->aumask[i] == port) {
				ct.un.ord = ports->misel[i];
				error = sc->hw_if->set_port(sc->hw_hdl, &ct);
				break;
			}
	} else {
		ct.type = AUDIO_MIXER_SET;
		ct.un.mask = 0;
		for(i = 0; i < ports->nports; i++)
			if (ports->aumask[i] & port)
				ct.un.mask |= ports->misel[i];
		if (port != 0 && ct.un.mask == 0)
			error = EINVAL;
		else
			error = sc->hw_if->set_port(sc->hw_hdl, &ct);
	}
	if (!error)
		mixer_signal(sc);
	return error;
}

int
au_get_port(struct audio_softc *sc, struct au_mixer_ports *ports)
{
	mixer_ctrl_t ct;
	int i, aumask;

	if (ports->index == -1)
		return 0;
	ct.dev = ports->index;
	ct.type = ports->isenum ? AUDIO_MIXER_ENUM : AUDIO_MIXER_SET;
	if (sc->hw_if->get_port(sc->hw_hdl, &ct))
		return 0;
	aumask = 0;
	if (ports->isenum) {
		for(i = 0; i < ports->nports; i++)
			if (ct.un.ord == ports->misel[i])
				aumask = ports->aumask[i];
	} else {
		for(i = 0; i < ports->nports; i++)
			if (ct.un.mask & ports->misel[i])
				aumask |= ports->aumask[i];
	}
	return aumask;
}

int
audiosetinfo(struct audio_softc *sc, struct audio_info *ai)
{
	struct audio_prinfo *r = &ai->record, *p = &ai->play;
	int cleared;
	int setmode, modechange = 0;
	int error;
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_params pp, rp;
	int np, nr;
	unsigned int blks;
	int oldpblksize, oldrblksize;
	int rbus, pbus;
	int fpb;
	int fs;
	u_int gain;
	u_char balance;

	if (hw == 0)		/* HW has not attached */
		return(ENXIO);

	rbus = sc->sc_rbus;
	pbus = sc->sc_pbus;
	error = 0;
	cleared = 0;

	pp = sc->sc_pparams;	/* Temporary encoding storage in */
	rp = sc->sc_rparams;	/* case setting the modes fails. */
	nr = np = 0;

	if (p->sample_rate != ~0) {
		pp.sample_rate = p->sample_rate;
		np++;
	}
	if (r->sample_rate != ~0) {
		rp.sample_rate = r->sample_rate;
		nr++;
	}
	if (p->encoding != ~0) {
		pp.encoding = p->encoding;
		np++;
	}
	if (r->encoding != ~0) {
		rp.encoding = r->encoding;
		nr++;
	}
	if (p->precision != ~0) {
		pp.precision = p->precision;
		np++;
	}
	if (r->precision != ~0) {
		rp.precision = r->precision;
		nr++;
	}
	if (p->bps != ~0) {
		pp.bps = p->bps;
		np++;
	}
	if (r->bps != ~0) {
		rp.bps = r->bps;
		nr++;
	}
	if (p->msb != ~0) {
		pp.msb = p->msb;
		np++;
	}
	if (r->msb != ~0) {
		rp.msb = r->msb;
		nr++;
	}
	if (p->channels != ~0) {
		pp.channels = p->channels;
		np++;
	}
	if (r->channels != ~0) {
		rp.channels = r->channels;
		nr++;
	}
#ifdef AUDIO_DEBUG
	if (audiodebug && nr)
	    audio_print_params("Setting record params", &rp);
	if (audiodebug && np)
	    audio_print_params("Setting play params", &pp);
#endif
	if (nr && (error = audio_check_params(&rp)))
		return error;
	if (np && (error = audio_check_params(&pp)))
		return error;
	setmode = 0;
	if (nr) {
		if (!cleared)
			audio_clear(sc);
		modechange = cleared = 1;
		setmode |= AUMODE_RECORD;
	}
	if (np) {
		if (!cleared)
			audio_clear(sc);
		modechange = cleared = 1;
		setmode |= AUMODE_PLAY;
	}

	if (ai->mode != ~0) {
		if (!cleared)
			audio_clear(sc);
		modechange = cleared = 1;
		sc->sc_mode = ai->mode;
		if (sc->sc_mode & AUMODE_PLAY_ALL)
			sc->sc_mode |= AUMODE_PLAY;
		if ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_full_duplex)
			/* Play takes precedence */
			sc->sc_mode &= ~AUMODE_RECORD;
	}

	if (modechange) {
		int indep = hw->get_props(sc->hw_hdl) & AUDIO_PROP_INDEPENDENT;
		if (!indep) {
			if (setmode == AUMODE_RECORD)
				pp = rp;
			else
				rp = pp;
		}
		sc->sc_pemu.encoding = pp.encoding;
		sc->sc_remu.encoding = rp.encoding;
		error = hw->set_params(sc->hw_hdl, setmode,
		    sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD), &pp, &rp);
		if (error)
			return (error);
		if (sc->sc_mode & AUMODE_PLAY)
			audio_emu_setup(AUMODE_PLAY, &pp, &sc->sc_pemu);
		if (sc->sc_mode & AUMODE_RECORD)
			audio_emu_setup(AUMODE_RECORD, &rp, &sc->sc_remu);
		if (!indep) {
			if (setmode == AUMODE_RECORD) {
				pp.sample_rate = rp.sample_rate;
				pp.encoding    = rp.encoding;
				pp.channels    = rp.channels;
				pp.precision   = rp.precision;
				pp.bps         = rp.bps;
				pp.msb         = rp.msb;
			} else if (setmode == AUMODE_PLAY) {
				rp.sample_rate = pp.sample_rate;
				rp.encoding    = pp.encoding;
				rp.channels    = pp.channels;
				rp.precision   = pp.precision;
				rp.bps         = pp.bps;
				rp.msb         = pp.msb;
			}
		}
		sc->sc_rparams = rp;
		sc->sc_pparams = pp;
	}

	oldpblksize = sc->sc_pr.blksize;
	oldrblksize = sc->sc_rr.blksize;

	/*
	 * allow old-style blocksize changes, for compatibility;
	 * individual play/record block sizes have precedence
	 */
	if (ai->blocksize != ~0) {
		if (r->block_size == ~0)
			r->block_size = ai->blocksize;
		if (p->block_size == ~0)
			p->block_size = ai->blocksize;
	}
	if (r->block_size != ~0) {
		sc->sc_rr.blkset = 0;
		if (!cleared)
			audio_clear(sc);
		cleared = 1;
		nr++;
	}
	if (p->block_size != ~0) {
		sc->sc_pr.blkset = 0;
		if (!cleared)
			audio_clear(sc);
		cleared = 1;
		np++;
	}
	if (nr) {
		if (r->block_size == ~0 || r->block_size == 0) {
			fpb = rp.sample_rate * audio_blk_ms / 1000;
		} else {
			fs = rp.channels * rp.bps; 
			fpb = r->block_size / fs;
		}
		if (sc->sc_rr.blkset == 0)
			audio_set_blksize(sc, AUMODE_RECORD, fpb);
	}
	if (np) {
		if (p->block_size == ~0 || p->block_size == 0) {
			fpb = pp.sample_rate * audio_blk_ms / 1000;
		} else {
			fs = pp.channels * pp.bps;
			fpb = p->block_size / fs;
		}
		if (sc->sc_pr.blkset == 0)
			audio_set_blksize(sc, AUMODE_PLAY, fpb);
	}
	if (r->block_size != ~0 && r->block_size != 0)
		sc->sc_rr.blkset = 1;
	if (p->block_size != ~0 && p->block_size != 0)
		sc->sc_pr.blkset = 1;

#ifdef AUDIO_DEBUG
	if (audiodebug > 1 && nr)
	    audio_print_params("After setting record params", &sc->sc_rparams);
	if (audiodebug > 1 && np)
	    audio_print_params("After setting play params", &sc->sc_pparams);
#endif

	if (p->port != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		error = au_set_port(sc, &sc->sc_outports, p->port);
		if (error)
			return(error);
	}
	if (r->port != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		error = au_set_port(sc, &sc->sc_inports, r->port);
		if (error)
			return(error);
	}
	if (p->gain != ~0) {
		au_get_gain(sc, &sc->sc_outports, &gain, &balance);
		error = au_set_gain(sc, &sc->sc_outports, p->gain, balance);
		if (error)
			return(error);
	}
	if ((r->gain != ~0) && (r->port != 0)) {
		au_get_gain(sc, &sc->sc_inports, &gain, &balance);
		error = au_set_gain(sc, &sc->sc_inports, r->gain, balance);
		if (error)
			return(error);
	}

	if (p->balance != (u_char)~0) {
		au_get_gain(sc, &sc->sc_outports, &gain, &balance);
		error = au_set_gain(sc, &sc->sc_outports, gain, p->balance);
		if (error)
			return(error);
	}
	if ((r->balance != (u_char)~0) && (r->port != 0)) {
		au_get_gain(sc, &sc->sc_inports, &gain, &balance);
		error = au_set_gain(sc, &sc->sc_inports, gain, r->balance);
		if (error)
			return(error);
	}

	if (ai->output_muted != (u_char)~0) {
		error = au_set_mute(sc, &sc->sc_outports, ai->output_muted);
		if (error)
			return(error);
	}

	if (ai->monitor_gain != ~0 &&
	    sc->sc_monitor_port != -1) {
		mixer_ctrl_t ct;

		ct.dev = sc->sc_monitor_port;
		ct.type = AUDIO_MIXER_VALUE;
		ct.un.value.num_channels = 1;
		ct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = ai->monitor_gain;
		error = sc->hw_if->set_port(sc->hw_hdl, &ct);
		if (error)
			return(error);
	}

	if (ai->mode != ~0) {
		if (sc->sc_mode & AUMODE_PLAY)
			audio_init_play(sc);
		if (sc->sc_mode & AUMODE_RECORD)
			audio_init_record(sc);
	}

	if (hw->commit_settings) {
		error = hw->commit_settings(sc->hw_hdl);
		if (error)
			return (error);
	}

	if (cleared) {
		error = audio_initbufs(sc);
		if (error)
			goto err;
		if (sc->sc_pr.blksize != oldpblksize ||
		    sc->sc_rr.blksize != oldrblksize)
			audio_calcwater(sc);
		if ((sc->sc_mode & AUMODE_PLAY) &&
		    pbus && !sc->sc_pbus && !sc->sc_pr.pause)
			error = audiostartp(sc);
		if (!error &&
		    (sc->sc_mode & AUMODE_RECORD) &&
		    rbus && !sc->sc_rbus && !sc->sc_rr.pause)
			error = audiostartr(sc);
	err:
		if (error)
			return error;
	}

	/* Change water marks after initializing the buffers. */
	if (ai->hiwat != ~0) {
		blks = ai->hiwat;
		if (blks > sc->sc_pr.maxblks)
			blks = sc->sc_pr.maxblks;
		if (blks < 2)
			blks = 2;
		sc->sc_pr.usedhigh = blks * sc->sc_pr.blksize;
	}
	if (ai->lowat != ~0) {
		blks = ai->lowat;
		if (blks > sc->sc_pr.maxblks - 1)
			blks = sc->sc_pr.maxblks - 1;
		sc->sc_pr.usedlow = blks * sc->sc_pr.blksize;
	}
	if (ai->hiwat != ~0 || ai->lowat != ~0) {
		if (sc->sc_pr.usedlow > sc->sc_pr.usedhigh - sc->sc_pr.blksize)
			sc->sc_pr.usedlow = sc->sc_pr.usedhigh - sc->sc_pr.blksize;
	}

	if (p->pause != (u_char)~0) {
		sc->sc_pr.pause = p->pause;
		if (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {
			error = audiostartp(sc);
			if (error)
				return error;
		}
	}
	if (r->pause != (u_char)~0) {
		sc->sc_rr.pause = r->pause;
		if (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {
			error = audiostartr(sc);
			if (error)
				return error;
		}
	}

	return (0);
}

int
audiogetinfo(struct audio_softc *sc, struct audio_info *ai)
{
	struct audio_prinfo *r = &ai->record, *p = &ai->play;
	struct audio_hw_if *hw = sc->hw_if;

	if (hw == 0)		/* HW has not attached */
		return(ENXIO);

	p->sample_rate = sc->sc_pparams.sample_rate;
	r->sample_rate = sc->sc_rparams.sample_rate;
	p->channels = sc->sc_pparams.channels;
	r->channels = sc->sc_rparams.channels;
	p->precision = sc->sc_pparams.precision;
	r->precision = sc->sc_rparams.precision;
	p->bps = sc->sc_pparams.bps;
	r->bps = sc->sc_rparams.bps;
	p->msb = sc->sc_pparams.msb;
	r->msb = sc->sc_rparams.msb;
	p->encoding = sc->sc_pemu.encoding;
	r->encoding = sc->sc_remu.encoding;
	r->port = au_get_port(sc, &sc->sc_inports);
	p->port = au_get_port(sc, &sc->sc_outports);

	r->avail_ports = sc->sc_inports.allports;
	p->avail_ports = sc->sc_outports.allports;

	au_get_gain(sc, &sc->sc_inports,  &r->gain, &r->balance);
	au_get_gain(sc, &sc->sc_outports, &p->gain, &p->balance);

	if (sc->sc_monitor_port != -1) {
		mixer_ctrl_t ct;

		ct.dev = sc->sc_monitor_port;
		ct.type = AUDIO_MIXER_VALUE;
		ct.un.value.num_channels = 1;
		if (sc->hw_if->get_port(sc->hw_hdl, &ct))
			ai->monitor_gain = 0;
		else
			ai->monitor_gain =
				ct.un.value.level[AUDIO_MIXER_LEVEL_MONO];
	} else
		ai->monitor_gain = 0;

	au_get_mute(sc, &sc->sc_outports, &ai->output_muted);

	p->seek = sc->sc_pr.used;
	r->seek = sc->sc_rr.used;

	p->samples = sc->sc_pr.stamp - sc->sc_pr.drops;
	r->samples = sc->sc_rr.stamp - sc->sc_rr.drops;

	p->eof = sc->sc_eof;
	r->eof = 0;

	p->pause = sc->sc_pr.pause;
	r->pause = sc->sc_rr.pause;

	p->error = sc->sc_pr.drops != 0;
	r->error = sc->sc_rr.drops != 0;

	p->waiting = r->waiting = 0;		/* open never hangs */

	p->open = (sc->sc_open & AUOPEN_WRITE) != 0;
	r->open = (sc->sc_open & AUOPEN_READ) != 0;

	p->active = sc->sc_pbus;
	r->active = sc->sc_rbus;

	p->buffer_size = sc->sc_pr.bufsize;
	r->buffer_size = sc->sc_rr.bufsize;
d1469 9
a1477 7
	r->block_size = sc->sc_rr.blksize;
	p->block_size = sc->sc_pr.blksize;
	if (p->block_size != 0) {
		ai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;
		ai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;
	} else {
		ai->hiwat = ai->lowat = 0;
d1479 2
a1480 4
	ai->blocksize = p->block_size;	/* for compatibility, remove this */
	ai->mode = sc->sc_mode;

	return (0);
d1484 1
a1484 1
audiogetbufinfo(struct audio_softc *sc, struct audio_bufinfo *info, int mode)
d1486 2
a1487 1
	struct audio_ringbuffer *buf;
d1489 3
a1491 5
	if (mode == AUMODE_PLAY) {
		buf = &sc->sc_pr;
	} else {
		buf = &sc->sc_rr;
	}
d1493 56
a1548 8
	info->seek = buf->used;
	info->blksize = buf->blksize;
	if (buf->blksize != 0) {
		info->hiwat = buf->usedhigh / buf->blksize;
		info->lowat = buf->usedlow / buf->blksize;
	} else {
		info->hiwat = 0;
		info->lowat = 0;
d1550 1
a1550 2

	return (0);
a1552 4

/*
 * Mixer driver
 */
d1554 1
a1554 2
mixer_open(dev_t dev, struct audio_softc *sc, int flags, int ifmt,
    struct proc *p)
d1556 1
a1556 1
	DPRINTF(("mixer_open: dev=0x%x flags=0x%x sc=%p\n", dev, flags, sc));
d1558 24
a1581 1
	return (0);
d1584 2
a1585 5
/*
 * Remove a process from those to be signalled on mixer activity.
 */
static void
mixer_remove(struct audio_softc *sc, struct proc *p)
d1587 1
a1587 1
	struct mixer_asyncs **pm, *m;
d1589 10
a1598 7
	for(pm = &sc->sc_async_mixer; *pm; pm = &(*pm)->next) {
		if ((*pm)->proc == p) {
			m = *pm;
			*pm = m->next;
			free(m, M_DEVBUF, 0);
			return;
		}
d1600 2
d1604 2
a1605 5
/*
 * Signal all processes waiting for the mixer.
 */
static void
mixer_signal(struct audio_softc *sc)
d1607 2
a1608 1
	struct mixer_asyncs *m;
d1610 21
a1630 2
	for(m = sc->sc_async_mixer; m; m = m->next)
		psignal(m->proc, SIGIO);
a1632 4
/*
 * Close a mixer device
 */
/* ARGSUSED */
d1634 1
a1634 1
mixer_close(dev_t dev, int flags, int ifmt, struct proc *p)
d1636 2
a1637 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
d1639 16
a1654 5
	DPRINTF(("mixer_close: unit %d\n", AUDIOUNIT(dev)));

	mixer_remove(sc, p);

	return (0);
d1658 1
a1658 1
mixer_ioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d1660 2
a1661 4
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct audio_hw_if *hw = sc->hw_if;
	int error = EINVAL;
d1663 7
a1669 19
	DPRINTF(("mixer_ioctl(%ld,'%c',%ld)\n",
		IOCPARM_LEN(cmd), (int)IOCGROUP(cmd), cmd & 0xff));

	/* Block when fully quiesced.  No need to block earlier. */
	while (sc->sc_quiesce == AUDIO_QUIESCE_SILENT)
		tsleep(&sc->sc_quiesce, 0, "aud_qmi", 0);

	switch (cmd) {
	case FIOASYNC:
		mixer_remove(sc, p); /* remove old entry */
		if (*(int *)addr) {
			struct mixer_asyncs *ma;
			ma = malloc(sizeof (struct mixer_asyncs),
			    M_DEVBUF, M_WAITOK);
			ma->next = sc->sc_async_mixer;
			ma->proc = p;
			sc->sc_async_mixer = ma;
		}
		error = 0;
d1671 3
a1673 4

	case AUDIO_GETDEV:
		DPRINTF(("AUDIO_GETDEV\n"));
		error = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);
d1675 6
d1682 5
a1686 5
	case AUDIO_MIXER_DEVINFO:
		DPRINTF(("AUDIO_MIXER_DEVINFO\n"));
		((mixer_devinfo_t *)addr)->un.v.delta = 0; /* default */
		error = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);
		break;
d1688 7
a1694 3
	case AUDIO_MIXER_READ:
		DPRINTF(("AUDIO_MIXER_READ\n"));
		error = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);
d1696 3
a1698 10

	case AUDIO_MIXER_WRITE:
		if (!(flag & FWRITE))
			return (EACCES);
		DPRINTF(("AUDIO_MIXER_WRITE\n"));
		error = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);
		if (!error && hw->commit_settings)
			error = hw->commit_settings(sc->hw_hdl);
		if (!error)
			mixer_signal(sc);
a1699 1

d1701 1
a1701 2
		error = ENOTTY;
		break;
d1703 2
a1704 3
	DPRINTF(("mixer_ioctl(%ld,'%c',%ld) result %d\n",
		IOCPARM_LEN(cmd), (int)IOCGROUP(cmd), cmd & 0xff, error));
	return (error);
d1708 1
a1708 1
audiokqfilter(dev_t dev, struct knote *kn)
d1710 2
a1711 3
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct klist *klist;
d1713 14
a1726 4
	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_rsel.si_note;
		kn->kn_fop = &audioread_filtops;
d1728 2
a1729 3
	case EVFILT_WRITE:
		klist = &sc->sc_wsel.si_note;
		kn->kn_fop = &audiowrite_filtops;
d1732 1
a1732 1
		return (EINVAL);
d1734 2
a1735 7
	kn->kn_hook = (void *)sc;

	mtx_enter(&audio_lock);
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	mtx_leave(&audio_lock);

	return (0);
d1738 2
a1739 2
void
filt_audiordetach(struct knote *kn)
d1741 2
a1742 1
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
d1744 17
a1760 3
	mtx_enter(&audio_lock);
	SLIST_REMOVE(&sc->sc_rsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&audio_lock);
d1763 1
d1765 1
a1765 1
filt_audioread(struct knote *kn, long hint)
d1767 1
a1767 1
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
d1769 8
a1776 11
	return AUDIO_FILTREAD(sc);
}

void
filt_audiowdetach(struct knote *kn)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;

	mtx_enter(&audio_lock);
	SLIST_REMOVE(&sc->sc_wsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&audio_lock);
d1780 1
a1780 1
filt_audiowrite(struct knote *kn, long hint)
d1782 1
a1782 1
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
d1784 20
a1803 1
	return AUDIO_FILTWRITE(sc);
d1806 2
a1807 9
#if NWSKBD > 0
struct wskbd_vol_change {
	struct task t;
	long dir;
	long out;
};

int
wskbd_set_mixervolume(long dir, long out)
d1809 15
a1823 2
	struct audio_softc *sc;
	struct wskbd_vol_change *ch;
d1825 13
a1837 3
	if (audio_cd.cd_ndevs == 0 || (sc = audio_cd.cd_devs[0]) == NULL) {
		DPRINTF(("wskbd_set_mixervolume: audio_cd\n"));
		return (ENXIO);
a1838 11

	ch = malloc(sizeof(*ch), M_TEMP, M_NOWAIT);
	if (ch == NULL)
		return (ENOMEM);

	task_set(&ch->t, wskbd_set_mixervolume_callback, ch);
	ch->dir = dir;
	ch->out = out;
	task_add(systq, &ch->t);

	return (0);
d1842 1
a1842 1
wskbd_set_mixervolume_callback(void *xch)
d1844 2
a1845 8
	struct wskbd_vol_change *ch = xch;
	struct audio_softc *sc;
	struct au_mixer_ports *ports;
	mixer_devinfo_t mi;
	u_char balance, mute;
	long dir, out;
	u_int gain;
	int error;
d1847 6
a1852 3
	dir = ch->dir;
	out = ch->out;
	free(ch, M_TEMP, sizeof(*ch));
d1854 1
a1854 2
	sc = (struct audio_softc *)device_lookup(&audio_cd, 0);
	if (sc == NULL)
d1856 16
a1871 6

	ports = out ? &sc->sc_outports : &sc->sc_inports;

	if (ports->master == -1) {
		DPRINTF(("%s: master == -1\n", __func__));
		goto done;
d1873 8
a1880 8

	if (dir == 0) {
		/* Mute */

		error = au_get_mute(sc, ports, &mute);
		if (error != 0) {
			DPRINTF(("%s: au_get_mute: %d\n", __func__, error));
			goto done;
d1882 9
a1890 7

		mute = !mute;

		error = au_set_mute(sc, ports, mute);
		if (error != 0) {
			DPRINTF(("%s: au_set_mute: %d\n", __func__, error));
			goto done;
d1892 4
a1895 8
	} else {
		/* Raise or lower volume */

		mi.index = ports->master;
		error = sc->hw_if->query_devinfo(sc->hw_hdl, &mi);
		if (error != 0) {
			DPRINTF(("%s: query_devinfo: %d\n", __func__, error));
			goto done;
d1897 2
d1900 5
a1904 1
		au_get_gain(sc, ports, &gain, &balance);
d1906 7
a1912 4
		if (dir > 0)
			gain += mi.un.v.delta;
		else
			gain -= mi.un.v.delta;
d1914 5
a1918 5
		error = au_set_gain(sc, ports, gain, balance);
		if (error != 0) {
			DPRINTF(("%s: au_set_gain: %d\n", __func__, error));
			goto done;
		}
d1920 12
a1931 11
		/*
		 * Unmute whenever we raise or lower the volume.  This
		 * mimicks the behaviour of the hardware volume
		 * buttons on Thinkpads making sure that our software
		 * mute state follows the hardware mute state.
		 */
		error = au_set_mute(sc, ports, 0);
		if (error != 0) {
			DPRINTF(("%s: au_set_mute: %d\n", __func__, error));
			goto done;
		}
d1933 1
a1933 3

done:
	device_unref(&sc->dev);
@


1.130
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.129 2015/02/10 21:56:09 miod Exp $	*/
d2475 1
a2475 1
#if BYTE_ORDER == LITTE_ENDIAN
@


1.129
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.128 2015/02/07 01:49:05 kettenis Exp $	*/
d55 1
a55 1

d118 5
d164 3
d223 1
d317 1
a317 1
	{ 8000, AUDIO_ENCODING_ULAW, 8, 1, 1, 1, 0, 1 };
a427 1

d435 4
a1153 1

d1156 1
a1156 1
	ai.record.encoding    = sc->sc_rparams.encoding;
d1163 1
a1163 1
	ai.play.encoding      = sc->sc_pparams.encoding;
d1231 3
a1233 4
		if (sc->sc_pparams.sw_code) {
			int ncc = cc / sc->sc_pparams.factor;
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, ncc);
			sc->sc_pparams.sw_code(sc->hw_hdl, inp, ncc);
d1459 2
a1460 2
			if (uio->uio_resid < cc / sc->sc_rparams.factor)
				cc = uio->uio_resid * sc->sc_rparams.factor;
d1462 1
a1462 2
			error = audio_silence_copyout(sc,
			    cc / sc->sc_rparams.factor, uio);
d1491 1
a1491 1
		resid = uio->uio_resid * sc->sc_rparams.factor;
d1506 3
a1508 3
		if (sc->sc_rparams.sw_code)
			sc->sc_rparams.sw_code(sc->hw_hdl, outp, cc);
		error = uiomovei(outp, cc / sc->sc_rparams.factor, uio);
d1693 1
a1693 1
		n = min(sc->sc_playdrop, uio->uio_resid * sc->sc_pparams.factor);
d1695 2
a1696 2
		uio->uio_offset += n / sc->sc_pparams.factor;
		uio->uio_resid -= n / sc->sc_pparams.factor;
d1702 3
a1704 4
	DPRINTFN(1, ("audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\n",
	    sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
	    sc->sc_pparams.precision, sc->sc_pparams.channels,
	    sc->sc_pparams.sw_code, sc->sc_pparams.factor));
d1723 1
a1723 1
		resid = uio->uio_resid * sc->sc_pparams.factor;
a1746 1
		cc /= sc->sc_pparams.factor;
d1752 2
a1753 2
		if (sc->sc_pparams.sw_code) {
			sc->sc_pparams.sw_code(sc->hw_hdl, inp, cc);
a1826 1
	 *  sc->sc_rparams.factor /
d1831 1
a1831 2
		    (sc->sc_rparams.factor * sc->sc_rparams.channels *
		    sc->sc_rparams.bps);
d1836 1
a1836 2
		    (sc->sc_pparams.factor * sc->sc_pparams.channels *
		    sc->sc_pparams.bps);
d1846 1
a1846 1
		ao->samples = sc->sc_rr.stamp / sc->sc_rparams.factor;
d1849 1
a1849 1
		ao->offset = (sc->sc_rr.inp - sc->sc_rr.start) / sc->sc_rparams.factor;
d1860 1
a1860 1
		ao->samples = sc->sc_pr.stamp / sc->sc_pparams.factor;
d1863 1
a1863 1
		ao->offset = offs / sc->sc_pparams.factor;
d1872 1
a1872 1
		*(u_long *)addr = sc->sc_pr.used / sc->sc_pparams.factor;
d2153 3
a2155 4
			if (sc->sc_pparams.sw_code) {
				int ncc = cc / sc->sc_pparams.factor;
				audio_fill_silence(&sc->sc_pparams, cb->start, inp, ncc);
				sc->sc_pparams.sw_code(sc->hw_hdl, inp, ncc);
d2169 3
a2171 4
		if (sc->sc_pparams.sw_code) {
			int ncc = cc / sc->sc_pparams.factor;
			audio_fill_silence(&sc->sc_pparams, cb->start, inp, ncc);
			sc->sc_pparams.sw_code(sc->hw_hdl, inp, ncc);
a2441 2
	case AUDIO_ENCODING_ULAW:
	case AUDIO_ENCODING_ALAW:
d2446 2
d2466 30
a2904 2
		rp.sw_code = 0;
		rp.factor = 1;
a2910 2
		pp.sw_code = 0;
		pp.factor = 1;
d2934 2
d2940 4
d2997 1
a2997 1
			fpb = (r->block_size * rp.factor) / fs;
d3007 1
a3007 1
			fpb = (p->block_size * pp.factor) / fs;
d3178 2
a3179 3
	p->encoding = sc->sc_pparams.encoding;
	r->encoding = sc->sc_rparams.encoding;

d3205 2
a3206 2
	p->seek = sc->sc_pr.used / sc->sc_pparams.factor;
	r->seek = sc->sc_rr.used / sc->sc_rparams.factor;
d3228 2
a3229 2
	p->buffer_size = sc->sc_pr.bufsize / sc->sc_pparams.factor;
	r->buffer_size = sc->sc_rr.bufsize / sc->sc_rparams.factor;
d3231 2
a3232 2
	r->block_size = sc->sc_rr.blksize / sc->sc_rparams.factor;
	p->block_size = sc->sc_pr.blksize / sc->sc_pparams.factor;
a3248 1
	int factor;
a3249 1
	factor = 1;
a3251 1
		factor = sc->sc_pparams.factor;
a3253 1
		factor = sc->sc_rparams.factor;
d3256 2
a3257 2
	info->seek = buf->used / factor;
	info->blksize = buf->blksize / factor;
@


1.128
log
@Let a volume key event unmute.  This makes the software state follow the
hardware behaviour on Thinkpads making it harder for software state and
hardware state get out of sync.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.127 2015/01/27 03:17:35 dlg Exp $	*/
d1499 1
a1499 1
		error = uiomove(outp, cc / sc->sc_rparams.factor, uio);
d1638 1
a1638 1
		error = uiomove(zerobuf, k, uio);
d1742 1
a1742 1
		error = uiomove(inp, cc, uio);
@


1.127
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.126 2015/01/20 04:54:23 dlg Exp $	*/
d3522 12
@


1.126
log
@rework the audio key handling to allocate a message to send to the
task, rather than abusing task arguments to carry long values around.

this is unreliable, but so was the previous mechanism, just in a
different way. if you're so low on memory that you cant change the
volume, you probably have other more important problems going on
too.

tested by jim smith
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.125 2014/12/19 22:44:58 guenther Exp $	*/
d334 1
a334 1
void wskbd_set_mixervolume_callback(void *, void *);
d3451 1
a3451 1
	task_set(&ch->t, wskbd_set_mixervolume_callback, ch, NULL);
d3460 1
a3460 1
wskbd_set_mixervolume_callback(void *xch, void *null)
@


1.125
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.124 2014/11/16 12:30:59 deraadt Exp $	*/
a467 5

#if NWSKBD > 0
	task_set(&sc->sc_mixer_task, wskbd_set_mixervolume_callback, NULL,
	    NULL);
#endif /* NWSKBD > 0 */
d3430 6
d3440 1
d3447 8
a3454 4
	task_del(systq, &sc->sc_mixer_task);
	task_set(&sc->sc_mixer_task, wskbd_set_mixervolume_callback,
	    (void *)dir, (void *)out);
	task_add(systq, &sc->sc_mixer_task);
d3460 1
a3460 1
wskbd_set_mixervolume_callback(void *arg1, void *arg2)
d3462 1
d3471 6
a3476 2
	if (audio_cd.cd_ndevs == 0 || (sc = audio_cd.cd_devs[0]) == NULL) {
		DPRINTF(("%s: audio_cd\n", __func__));
a3477 4
	}

	dir = (long)arg1;
	out = (long)arg2;
d3483 1
a3483 1
		return;
d3492 1
a3492 1
			return;
d3500 1
a3500 1
			return;
d3509 1
a3509 1
			return;
d3522 1
a3522 1
			return;
d3525 3
@


1.124
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.123 2014/09/14 14:17:24 jsg Exp $	*/
d52 1
a56 2

#include <machine/endian.h>
@


1.123
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.122 2014/07/12 18:48:17 tedu Exp $	*/
d2031 2
a2032 2
 * 1) If you map memory VM_PROT_WRITE you SIGSEGV
 *    when writing to it, so VM_PROT_READ|VM_PROT_WRITE
d2034 2
a2035 2
 * 2) Even if calling mmap() with VM_PROT_READ|VM_PROT_WRITE
 *    audio_mmap will get called at some point with VM_PROT_READ
d2039 2
a2040 2
	if (prot == (VM_PROT_READ|VM_PROT_WRITE) ||
	    prot == VM_PROT_WRITE)
d2042 1
a2042 1
	else if (prot == VM_PROT_READ)
@


1.122
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.121 2014/05/19 07:00:15 ratchov Exp $	*/
a43 1
#include <sys/proc.h>
@


1.121
log
@fix format mistakes visible if AUDIO_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.120 2013/12/17 14:55:16 deraadt Exp $	*/
d718 1
a718 1
		free(r->start, M_DEVBUF);
d3272 1
a3272 1
			free(m, M_DEVBUF);
@


1.120
log
@don't do a timeout+task song and dance, instead use DVACT_WAKEUP directly.
There will be slight burps on resume due to other drivers being slow with
wakeup.
ok kettenis ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.119 2013/12/06 21:03:02 deraadt Exp $	*/
d1416 1
a1416 1
	DPRINTFN(1,("audio_read: cc=%d mode=%d\n",
d1660 1
a1660 1
	DPRINTFN(2, ("audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\n", sc, unit,
d1747 1
a1747 1
		DPRINTFN(1, ("audio_write: uiomove cc=%d inp=%p, left=%d\n",
d1780 2
a1781 2
	DPRINTF(("audio_ioctl(%d,'%c',%d)\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d1959 2
a1960 2
	DPRINTF(("audio_ioctl(%d,'%c',%d) result %d\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
d2023 1
a2023 1
	DPRINTF(("audio_mmap: off=%d, prot=%d\n", off, prot));
d3315 2
a3316 2
	DPRINTF(("mixer_ioctl(%d,'%c',%d)\n",
		 IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d3367 2
a3368 2
	DPRINTF(("mixer_ioctl(%d,'%c',%d) result %d\n",
		 IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
@


1.119
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.118 2013/11/28 00:38:50 dlg Exp $	*/
a175 2
	struct timeout sc_resume_to;
	struct task sc_resume_task;
d228 1
a228 1
static __inline void audio_wakeup(int *);
d235 1
a235 3
void	audio_resume(struct audio_softc *);
void	audio_resume_to(void *);
void	audio_resume_task(void *, void *);
a470 2
	timeout_set(&sc->sc_resume_to, audio_resume_to, sc);
	task_set(&sc->sc_resume_task, audio_resume_task, sc, NULL);
d489 2
a490 2
	case DVACT_RESUME:
		audio_resume(sc);
a505 1
	timeout_del(&sc->sc_resume_to);
d1066 1
a1066 1
audio_wakeup(int *chan)
d1291 1
a1291 1
audio_resume(struct audio_softc *sc)
a1292 14
	timeout_add_msec(&sc->sc_resume_to, 1500);
}

void
audio_resume_to(void *v)
{
	struct audio_softc *sc = v;
	task_add(systq, &sc->sc_resume_task);
}

void
audio_resume_task(void *arg1, void *arg2)
{
	struct audio_softc *sc = arg1;
d1518 1
a1518 1
		audio_wakeup(&sc->sc_rchan);
d1523 1
a1523 1
		audio_wakeup(&sc->sc_wchan);
d1971 1
a1971 1
	audio_wakeup(play? &sc->sc_wchan : &sc->sc_rchan);
d2301 1
a2301 1
		audio_wakeup(&sc->sc_wchan);
d2408 1
a2408 1
		audio_wakeup(&sc->sc_rchan);
@


1.118
log
@the stuff in audiovar.h is only used in audio.c, so move it in there to
take the temptation of using it elsewhere and fumbling with audio internals
away from the rest of the kernel.

ok mpi@@ ratchov@@
"if it is worth doing, just do it." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.117 2013/11/04 11:57:26 mpi Exp $	*/
d489 3
a494 2
	case DVACT_SUSPEND:
		break;
a496 3
		break;
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
@


1.117
log
@Convert wskbd_set_mixervolume() to use a task internally instead of
being called in a workq.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.116 2013/10/30 02:13:52 dlg Exp $	*/
a54 1
#include <dev/audiovar.h>
d72 120
@


1.116
log
@replace workqs with tasks.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.115 2013/05/15 08:29:24 ratchov Exp $	*/
d220 2
a221 1
int wskbd_set_mixervolume(long, int);
d358 4
d3342 19
a3360 1
wskbd_set_mixervolume(long dir, int out)
d3363 1
d3365 3
a3368 3
	u_int gain;
	u_char balance, mute;
	struct au_mixer_ports *ports;
d3371 2
a3372 2
		DPRINTF(("wskbd_set_mixervolume: audio_cd\n"));
		return (ENXIO);
d3375 3
d3381 2
a3382 2
		DPRINTF(("wskbd_set_mixervolume: master == -1\n"));
		return (ENXIO);
d3390 2
a3391 3
			DPRINTF(("wskbd_set_mixervolume:"
			    " au_get_mute: %d\n", error));
			return (error);
d3398 2
a3399 3
			DPRINTF(("wskbd_set_mixervolume:"
			    " au_set_mute: %d\n", error));
			return (error);
d3407 2
a3408 3
			DPRINTF(("wskbd_set_mixervolume:"
			    " query_devinfo: %d\n", error));
			return (error);
d3420 2
a3421 3
			DPRINTF(("wskbd_set_mixervolume:"
			    " au_set_gain: %d\n", error));
			return (error);
a3423 2

	return (0);
@


1.115
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.114 2011/07/03 15:47:16 matthew Exp $	*/
d52 1
a52 1
#include <sys/workq.h>
d356 1
d1185 1
a1185 2
	workq_queue_task(NULL, &sc->sc_resume_task, 0,
	    audio_resume_task, sc, 0);
@


1.114
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.113 2011/07/02 22:20:07 nicm Exp $	*/
a36 27
/*
 * This is a (partially) SunOS-compatible /dev/audio driver for NetBSD.
 *
 * This code tries to do something half-way sensible with
 * half-duplex hardware, such as with the SoundBlaster hardware.  With
 * half-duplex hardware allowing O_RDWR access doesn't really make
 * sense.  However, closing and opening the device to "turn around the
 * line" is relatively expensive and costs a card reset (which can
 * take some time, at least for the SoundBlaster hardware).  Instead
 * we allow O_RDWR access, and provide an ioctl to set the "mode",
 * i.e. playing or recording.
 *
 * If you write to a half-duplex device in record mode, the data is
 * tossed.  If you read from the device in play mode, you get silence
 * filled buffers at the rate at which samples are naturally
 * generated.
 *
 * If you try to set both play and record mode on a half-duplex
 * device, playing takes precedence.
 */

/*
 * Todo:
 * - Add softaudio() isr processing for wakeup, poll, signals,
 *   and silence fill.
 */

d223 16
a383 1
	int s;
d393 1
a393 1
	s = splaudio();
d395 1
a395 1
		if (tsleep(&sc->sc_refcnt, PZERO, "auddet", hz * 120))
d399 1
a399 1
	splx(s);
d933 1
a933 1
	st = tsleep(chan, PWAIT | PCATCH, label, timo);
d948 1
a948 1
/* call at splaudio() */
d1074 1
a1074 2
	int s = splaudio();

a1077 1
	splx(s);
d1086 1
a1086 2
	int s = splaudio();

a1089 1
	splx(s);
a1096 1
	int s;
d1098 1
a1119 1
		s = splaudio();
a1122 1
		splx(s);
d1132 1
a1134 1
	s = splaudio();
d1141 1
a1141 1
		error = audio_sleep_timo(&sc->sc_wchan, "aud_dr", 30*hz);
d1145 1
a1145 1
	splx(s);
d1154 1
d1159 1
a1241 1
	int s;
d1245 1
a1245 1
	s = splaudio();
d1253 2
a1254 1
		if (!sc->sc_full_duplex || sc->hw_if->halt_input != sc->hw_if->halt_output)
d1256 1
d1259 1
a1259 4
	/*
	 * Block until output drains, but allow ^C interrupt.
	 */
	sc->sc_pr.usedlow = sc->sc_pr.blksize;	/* avoid excessive wakeups */
d1265 12
a1276 2
		if (!sc->sc_pr.pause && !audio_drain(sc) && hw->drain)
			(void)hw->drain(sc->hw_hdl);
a1298 1
	splx(s);
a1299 1

d1310 1
a1310 1
	int error, s, cc, n, resid;
d1334 1
a1334 1
			s = splaudio();
d1342 1
a1342 1
					splx(s);
d1349 1
a1349 1
					splx(s);
d1353 1
a1353 1
			splx(s);
d1365 1
a1365 1
		s = splaudio();
d1368 1
d1370 1
a1370 2
				if (error) {
					splx(s);
d1372 2
a1373 1
				}
d1376 1
a1376 1
				splx(s);
d1384 1
a1384 1
				splx(s);
d1401 1
a1401 1
		splx(s);
d1415 1
a1415 2
	int s = splaudio();

a1425 1
	splx(s);
d1557 1
a1557 1
	int error, s, n, cc, resid, avail;
d1605 1
a1605 1
		s = splaudio();
d1610 1
a1610 1
				splx(s);
d1617 1
a1617 1
				splx(s);
d1639 1
d1641 1
a1641 2
			if (error) {
				splx(s);
d1643 2
a1644 3
			}
		}
		splx(s);
d1667 1
a1667 1
	int error = 0, s, offs, fd;
a1700 1
		s = splaudio();
a1702 1
			splx(s);
a1711 1
		splx(s);
d1745 1
a1745 1
		s = splaudio();
d1752 1
a1752 1
		splx(s);
d1756 1
a1756 1
		s = splaudio();
d1766 1
a1766 1
		splx(s);
d1890 3
a1892 1
	int revents = 0, s = splaudio();
d1910 1
a1910 1
	splx(s);
a1916 1
	int s;
a1955 1
			s = splaudio();
a1957 1
			splx(s);
a1958 1
			s = splaudio();
a1960 1
			splx(s);
d1972 1
d1997 1
d2032 1
a2032 1
 * at splaudio, but there is no softaudio level to do it at yet.
d2099 1
a2178 1
			audio_clear(sc);
d2218 1
a2293 1
			audio_clear(sc);
d2691 1
a2691 1
	int s, setmode, modechange = 0;
a2972 1
		s = splaudio();
d2974 2
a2975 1
		if (error) goto err;
a2986 1
		splx(s);
a3013 1
			s = splaudio();
a3014 1
			splx(s);
a3021 1
			s = splaudio();
a3022 1
			splx(s);
a3276 1
	int s;
d3292 1
a3292 1
	s = splaudio();
d3294 1
a3294 1
	splx(s);
a3302 1
	int s = splaudio();
d3304 1
d3306 1
a3306 1
	splx(s);
a3320 1
	int s = splaudio();
d3322 1
d3324 1
a3324 1
	splx(s);
@


1.113
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.112 2011/06/06 06:13:45 deraadt Exp $	*/
a374 2
	case DVACT_ACTIVATE:
		break;
@


1.112
log
@Microphone mute button support from acpithinkpad (or elsewhere).
The audio side is a bit lacking; it does not yet mute all types of
devices.
from Alexander Polakov
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.111 2010/11/18 21:15:14 miod Exp $	*/
d3312 1
a3312 1
		return (1);
@


1.111
log
@Don't
  #include "foo.h"
  #if NFOO > 0
  (whole file)
  #endif
since config(8) file inclusion rules already do it for you.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.110 2010/09/21 20:08:11 jakemsr Exp $	*/
d247 1
a247 1
int wskbd_set_mixervolume(long);
d3361 1
a3361 1
wskbd_set_mixervolume(long dir)
d3368 1
d3375 3
a3377 1
	if (sc->sc_outports.master == -1) {
d3385 1
a3385 1
		error = au_get_mute(sc, &sc->sc_outports, &mute);
d3394 1
a3394 1
		error = au_set_mute(sc, &sc->sc_outports, mute);
d3403 1
a3403 1
		mi.index = sc->sc_outports.master;
d3411 1
a3411 1
		au_get_gain(sc, &sc->sc_outports, &gain, &balance);
d3418 1
a3418 1
		error = au_set_gain(sc, &sc->sc_outports, gain, balance);
@


1.110
log
@change quiescing to not call the audio_hw_if halt method in interrupt
context, because drivers (like eso(4) and envy(4)) might want to sleep
in their halt method.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.109 2010/09/12 02:01:17 jakemsr Exp $	*/
a63 3
#include "audio.h"
#if NAUDIO > 0

a535 1
#if NAUDIO > 0
a560 2
#endif /* NAUDIO > 0 */

a3292 1
#endif
d3359 1
a3359 1
#if NAUDIO > 0 && NWSKBD > 0
d3425 1
a3425 1
#endif /* NAUDIO > 0 && NWSKBD > 0 */
@


1.109
log
@DVACT_{QUIESCE,RESUME} for audio(4)
DVACT_QUIESCE:
1) waits until ringbuffer current position wraps back to the start of
the buffer
2) stops playback and/or recording by way of the hardware drivers' "halt"
audio_hw_if method
3) blocks userland access to audio device
4) saves the current state of the master mute, then mutes it
DVACT_RESUME:
1) reprogram hardware stream parameters for playback or recording
if they were active at DVACT_QUIESCE by way of hardware drivers'
"set_params" audio_hw_if method
2) start playback or recording if they were active at DVACT_QUIESCE
by way of hardware drivers' "trigger" or "start" audio_hw_if method
3) restores master mute state as it was at DVACT_QUIESCE
4) wakes up blocked userland processes accessing the hardware
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.108 2010/07/15 03:43:11 jakemsr Exp $	*/
d1180 4
a1183 8
	if (sc->sc_pbus) {
		while (sc->sc_pr.outp != sc->sc_pr.start)
			audio_sleep(&sc->sc_wchan, "aud_qui");
	}
	if (sc->sc_rbus) {
		while (sc->sc_rr.inp != sc->sc_rr.start)
			audio_sleep(&sc->sc_rchan, "aud_qui");
	}
d1190 5
d1218 2
d2126 3
d2222 2
a2223 2
	if (sc->sc_quiesce && cb->outp == cb->start) {
		sc->hw_if->halt_output(sc->hw_hdl);
d2245 3
d2329 2
a2330 2
	if (sc->sc_quiesce && cb->inp == cb->start) {
		sc->hw_if->halt_input(sc->hw_hdl);
@


1.108
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.107 2009/11/09 17:53:39 nicm Exp $	*/
d82 1
d147 5
d368 2
d380 8
a387 1

d406 2
d1175 78
d1333 8
d1581 8
d1687 9
d2209 11
d2313 11
d3236 4
@


1.107
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.106 2009/10/27 12:13:33 jakemsr Exp $	*/
a102 2
#define AUDIO_BPS(bits)	((bits) <= 8 ? 1 : (((bits) <= 16) ? 2 : 4))

d219 1
a219 1
	{ 8000, AUDIO_ENCODING_ULAW, 8, 1, 0, 1 };
d569 2
a570 2
	printf("audio: %s sr=%ld, enc=%d, chan=%d, prec=%d\n", s,
	    p->sample_rate, p->encoding, p->channels, p->precision);
d892 1
a892 1
	    (u_long)(AUDIO_BPS(sc->sc_pparams.precision) *
d900 1
a900 1
	    (u_long)(AUDIO_BPS(sc->sc_rparams.precision) *
d1042 2
d1046 1
a1046 1
	ai.play.encoding       = sc->sc_pparams.encoding;
d1049 2
d1356 1
a1356 1
	fs = parm->channels * AUDIO_BPS(parm->precision);
d1392 1
a1392 1
	int i, samplesz, nsamples;
d1400 1
a1400 2
	samplesz = AUDIO_BPS(params->precision);
	rounderr = (p - start) % samplesz;
d1403 1
a1403 1
	nsamples = n / samplesz;
d1416 4
a1419 1
		auzero[samplesz - 1] = 0x80; 
d1422 4
a1425 1
		auzero[0] = 0x80;
d1440 1
a1440 1
		for (i = 0; i < samplesz; i++) 
d1627 1
a1627 1
	 *  (sc->sc_rparams.channels * AUDIO_BPS(sc->sc_rparams.precision))
d1632 1
a1632 1
		    AUDIO_BPS(sc->sc_rparams.precision));
d1638 1
a1638 1
		    AUDIO_BPS(sc->sc_pparams.precision));
d2613 16
d2695 2
d2702 2
d2741 1
a2741 1
			fs = rp.channels * AUDIO_BPS(rp.precision); 
d2751 1
a2751 1
			fs = pp.channels * AUDIO_BPS(pp.precision);
d2924 4
@


1.106
log
@in the get_default_parameters method, give the low level drivers a
pointer to the low level driver's softc, not audio's softc.  nothing
is actually using this yet.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.105 2009/10/13 19:33:16 pirofti Exp $	*/
a1766 1
	KNOTE(&si->si_note, 0);
@


1.105
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.104 2009/06/18 22:55:56 jakemsr Exp $	*/
d317 2
a318 2
		hwp->get_default_params(sc, AUMODE_PLAY, &sc->sc_pparams);
		hwp->get_default_params(sc, AUMODE_RECORD, &sc->sc_rparams);
d1017 1
a1017 1
			sc->hw_if->get_default_params(sc, AUMODE_PLAY,
d1019 1
a1019 1
			sc->hw_if->get_default_params(sc, AUMODE_RECORD,
@


1.104
log
@fix previous: start playback when at least one block of data has
been written to the device, instead of waiting for a write(2)
when the buffer is or will be over the high water mark.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.103 2009/03/21 13:16:21 ratchov Exp $	*/
d156 1
a156 1
int	audioactivate(struct device *, enum devact);
d367 1
a367 1
audioactivate(struct device *self, enum devact act)
@


1.103
log
@don't call uiomove(9) at IPL_AUDIO, slightly simplify the code
help from and ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.102 2009/03/16 19:45:09 ratchov Exp $	*/
a1506 7
			if (!sc->sc_pbus && !cb->pause) {
				error = audiostartp(sc);
				if (error) {
					splx(s);
					return error;
				}
			}
d1536 7
@


1.102
log
@first stage of removing ``copying & needfeel'' flags that
make the audio driver missing blocks and, thus, breaking
full-duplex apps.
help and ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.101 2009/01/16 23:07:33 jakemsr Exp $	*/
d1228 1
a1228 1
	int error, s, used, cc, n;
d1274 1
a1274 1
	while (uio->uio_resid > 0 && !error) {
d1297 1
a1297 1
		used = cb->used;
d1299 1
a1299 1
		cc = used - cb->usedlow; /* maximum to read */
d1301 11
a1311 7
		if (n < cc)
			cc = n;	/* don't read beyond end of buffer */
		 /* and no more than we want */
		if (uio->uio_resid < cc / sc->sc_rparams.factor)
			cc = uio->uio_resid * sc->sc_rparams.factor;
		if (cb->blksize < cc)
			cc = cb->blksize;	/* splx() quickly */
a1313 1
		DPRINTFN(1,("audio_read: outp=%p, cc=%d\n", outp, cc));
d1315 2
a1316 7
		used -= cc;
		outp += cc;
		if (outp >= cb->end)
			outp = cb->start;
		cb->outp = outp;
		cb->used = used;
		splx(s);
d1318 1
a1318 1
	return (error);
d1463 1
a1463 1
	int saveerror, error, s, n, cc, used;
d1502 1
a1502 2
	error = 0;
	while (uio->uio_resid > 0 && !error) {
d1507 7
d1526 2
a1527 1
		used = cb->used;
d1529 9
a1537 15
		cc = cb->usedhigh - used;	/* maximum to write */
		n = cb->end - inp;
		if (sc->sc_pparams.factor != 1) {
			/* Compensate for software coding expansion factor. */
			n /= sc->sc_pparams.factor;
			cc /= sc->sc_pparams.factor;
		}
		if (n < cc)
			cc = n;			/* don't write beyond end of buffer */
		if (uio->uio_resid < cc)
			cc = uio->uio_resid;	/* and no more than we have */
		if (cb->blksize < cc)
			cc = cb->blksize;	/* splx() quickly */

#ifdef DIAGNOSTIC
d1539 2
a1540 2
		 * This should never happen since the block size and and
		 * block pointers are always nicely aligned.
d1542 3
a1544 7
		if (cc == 0) {
			printf("audio_write: cc == 0, swcode=%p, factor=%d\n",
			    sc->sc_pparams.sw_code, sc->sc_pparams.factor);
			splx(s);
			return EINVAL;
		}
#endif
a1546 1
		n = uio->uio_resid;
a1547 2
		cc = n - uio->uio_resid; /* number of bytes actually moved */
#ifdef AUDIO_DEBUG
d1549 1
a1549 8
			printf("audio_write:(1) uiomove failed %d; cc=%d inp=%p\n",
			    error, cc, inp);
#endif
		/*
		 * Continue even if uiomove() failed because we may have
		 * gotten a partial block.
		 */

a1551 2
			/* Adjust count after the expansion. */
			cc *= sc->sc_pparams.factor;
a1553 22

		inp = cb->inp + cc;
		if (inp >= cb->end)
			inp = cb->start;
		cb->inp = inp;
		cb->used += cc;

		/*
		 * This is a very suboptimal way of keeping track of
		 * silence in the buffer, but it is simple.
		 */
		sc->sc_sil_count = 0;

		if (!sc->sc_pbus && !cb->pause) {
			saveerror = error;
			error = audiostartp(sc);
			if (saveerror != 0) {
				/* Report the first error that occurred. */
				error = saveerror;
			}
		}
		splx(s);
d1555 1
a1555 1
	return (error);
@


1.101
log
@deal with sample precisions that are not a power of 2.

discussed with and ok ratchov; manpage tweak from naddy, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.100 2008/10/30 03:46:56 jakemsr Exp $	*/
a862 2
	rp->copying = 0;
	rp->needfill = 0;
a1138 6
#ifdef DIAGNOSTIC
	if (cb->copying) {
		printf("audio_drain: copying in progress!?!\n");
		cb->copying = 0;
	}
#endif
a1298 2
		cb->copying = 1;
		splx(s);
a1302 1

d1306 2
a1307 1

a1315 1
		s = splaudio();
a1317 1
		cb->copying = 0;
d1464 1
a1464 1
	u_char *inp, *einp;
a1523 2
		cb->copying = 1;
		splx(s);
d1535 2
d1546 1
a1546 1
			cb->copying = 0;
d1572 5
a1576 3
		einp = cb->inp + cc;
		if (einp >= cb->end)
			einp = cb->start;
a1577 1
		s = splaudio();
a1583 16
		cb->inp = einp;
		cb->used += cc;
		/* If the interrupt routine wants the last block filled AND
		 * the copy did not fill the last block completely it needs to
		 * be padded.
		 */
		if (cb->needfill &&
		    (inp  - cb->start) / cb->blksize ==
		    (einp - cb->start) / cb->blksize) {
			/* Figure out how many bytes there is to a block boundary. */
			cc = cb->blksize - (einp - cb->start) % cb->blksize;
			DPRINTF(("audio_write: partial fill %d\n", cc));
		} else
			cc = 0;
		cb->needfill = 0;
		cb->copying = 0;
a1592 9
		if (cc) {
			DPRINTFN(1, ("audio_write: fill %d\n", cc));
			if (sc->sc_pparams.sw_code) {
				int ncc = cc / sc->sc_pparams.factor;
				audio_fill_silence(&sc->sc_pparams, cb->start, einp, ncc);
				sc->sc_pparams.sw_code(sc->hw_hdl, einp, ncc);
			} else
				audio_fill_silence(&sc->sc_pparams, cb->start, einp, cc);
		}
d2082 7
a2088 23
		if (cb->copying) {
			/* writer is in progress, don't disturb */
			cb->needfill = 1;
			DPRINTFN(1, ("audio_pint: copying in progress\n"));
		} else {
			inp = cb->inp;
			cc = blksize - (inp - cb->start) % blksize;
			if (cb->pause)
				cb->pdrops += cc;
			else {
				cb->drops += cc;
				sc->sc_playdrop += cc;
			}
			audio_pint_silence(sc, cb, inp, cc);
			inp += cc;
			if (inp >= cb->end)
				inp = cb->start;
			cb->inp = inp;
			cb->used += cc;

			/* Clear next block so we keep ahead of the DMA. */
			if (cb->used + cc < cb->usedhigh)
				audio_pint_silence(sc, cb, inp, blksize);
d2090 10
d2193 1
a2193 1
	} else if (cb->used >= cb->usedhigh && !cb->copying) {
@


1.101.2.1
log
@On very high system load, an audio interrupt may occur while the audio
process is filling audio ring buffers. This triggers bogus (and useless)
correction code in the audio(4) driver causing the audio application to go
out of sync, and in turn causing continuous stuttering until the application
is restarted.

from current, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.101 2009/01/16 23:07:33 jakemsr Exp $	*/
d863 2
d1141 6
d1236 1
a1236 1
	int error, s, cc, n, resid;
d1282 1
a1282 1
	while (uio->uio_resid > 0) {
d1305 1
a1305 1
		resid = uio->uio_resid * sc->sc_rparams.factor;
d1307 3
a1309 1
		cc = cb->used - cb->usedlow; /* maximum to read */
d1311 7
a1317 11
		if (cc > n)
			cc = n;		/* don't read beyond end of buffer */
		
		if (cc > resid)
			cc = resid;	/* and no more than we want */
		cb->used -= cc;
		cb->outp += cc;
		if (cb->outp >= cb->end)
			cb->outp = cb->start;
		splx(s);
		DPRINTFN(1,("audio_read: outp=%p, cc=%d\n", outp, cc));
d1320 1
d1322 9
a1330 2
		if (error)
			return error;
d1332 1
a1332 1
	return 0;
d1476 2
a1477 2
	u_char *inp;
	int error, s, n, cc, resid, avail;
d1516 2
a1517 1
	while (uio->uio_resid > 0) {
a1521 7
			if (!sc->sc_pbus && !cb->pause) {
				error = audiostartp(sc);
				if (error) {
					splx(s);
					return error;
				}
			}
d1534 1
a1534 2
		resid = uio->uio_resid * sc->sc_pparams.factor;
		avail = cb->end - cb->inp;
d1536 15
a1550 9
		cc = cb->usedhigh - cb->used;
		if (cc > resid)
			cc = resid;
		if (cc > avail)
			cc = avail;
		cb->inp += cc;
		if (cb->inp >= cb->end)
			cb->inp = cb->start;
		cb->used += cc;
d1552 2
a1553 2
		 * This is a very suboptimal way of keeping track of
		 * silence in the buffer, but it is simple.
d1555 7
a1561 3
		sc->sc_sil_count = 0;
		splx(s);
		cc /= sc->sc_pparams.factor;
d1564 1
d1566 2
d1569 8
a1576 1
			return 0;
d1579 2
d1583 46
d1630 1
a1630 1
	return 0;
d2118 23
a2140 7
		inp = cb->inp;
		cc = blksize - (inp - cb->start) % blksize;
		if (cb->pause)
			cb->pdrops += cc;
		else {
			cb->drops += cc;
			sc->sc_playdrop += cc;
a2141 10
		audio_pint_silence(sc, cb, inp, cc);
		inp += cc;
		if (inp >= cb->end)
			inp = cb->start;
		cb->inp = inp;
		cb->used += cc;

		/* Clear next block so we keep ahead of the DMA. */
		if (cb->used + cc < cb->usedhigh)
			audio_pint_silence(sc, cb, inp, blksize);
d2235 1
a2235 1
	} else if (cb->used >= cb->usedhigh) {
@


1.100
log
@
for devices that do not allow independent setting of recording and
playback parameters (like the macppc i2s devices), be sure to
synchronise recording parameters to playback parameters when
configuring for full-duplex operation, as audio(4) dictates.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.99 2008/10/25 22:30:43 jakemsr Exp $	*/
d103 2
d896 1
a896 1
	    (u_long)(sc->sc_pparams.precision / NBBY *
d904 1
a904 1
	    (u_long)(sc->sc_rparams.precision / NBBY *
d1368 1
a1368 1
	fs = parm->channels * parm->precision / NBBY;
d1412 1
a1412 1
	samplesz = params->precision / 8;
d1695 1
a1695 1
	 *  (sc->sc_rparams.channels * (sc->sc_rparams.precision / NBBY))
d1698 1
a1698 1
		*(int *)addr = (sc->sc_rr.drops * NBBY) /
d1700 1
a1700 1
		    sc->sc_rparams.precision);
d1704 1
a1704 1
		*(int *)addr = (sc->sc_pr.drops * NBBY) /
d1706 1
a1706 1
		    sc->sc_pparams.precision);
a2303 2
		p->precision = (p->precision + 7) & ~7;
		break;
d2796 1
a2796 1
			fs = rp.channels * (rp.precision / 8); 
d2806 1
a2806 1
			fs = pp.channels * (pp.precision / 8);
@


1.99
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.98 2008/09/29 02:27:38 jakemsr Exp $	*/
d2741 1
a2741 1
			else if (setmode == AUMODE_PLAY)
@


1.98
log
@account for data expansion due to emulation in AUDIO_GET{I,O}OFFS
ioctls.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.97 2008/08/10 12:03:53 krw Exp $	*/
d2260 6
d2296 1
a2296 1
			return (EINVAL);
d2302 1
a2302 3
		if (p->precision != 8 && p->precision != 16 && 
		    p->precision != 32)
			return (EINVAL);
a2313 4

	/* sanity check # of channels */
	if (p->channels < 1 || p->channels > 12)
		return (EINVAL);
@


1.97
log
@'flus' -> 'flush', 'waitinf' -> 'waiting'. From Dawe via tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.96 2008/07/29 05:59:11 ratchov Exp $	*/
d1714 1
a1714 1
		ao->samples = sc->sc_rr.stamp;
d1717 1
a1717 1
		ao->offset = sc->sc_rr.inp - sc->sc_rr.start;
d1728 1
a1728 1
		ao->samples = sc->sc_pr.stamp;
d1731 1
a1731 1
		ao->offset = offs;
@


1.96
log
@When paused (or overrun), the record ring pointers are not incremented
properly in audio_rint(), the periodic boundary conditions aren't met. This
causes, later read(2) to return EFAULT while trying to access unmapped
regions of the kernel address space. Fix this by using the correct pointer
arithmetic.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.95 2008/04/21 00:32:42 jakemsr Exp $	*/
d3107 1
a3107 1
 * Signal all processes waitinf for the mixer.
@


1.95
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.94 2008/04/04 04:57:16 jakemsr Exp $	*/
d2230 2
d2237 2
@


1.94
log
@if full-duplex is being turned on, also set the oprtational mode to
for both recording and playback.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.93 2008/03/22 11:05:31 ratchov Exp $	*/
d313 8
a320 2
	sc->sc_pparams = audio_default;
	sc->sc_rparams = audio_default;
d1010 2
a1011 2
	 * Multiplex device: /dev/audio (MU-Law) and /dev/sound (linear)
	 * The /dev/audio is always (re)set to 8-bit MU-Law mono
d1016 9
a1024 2
		sc->sc_rparams = audio_default;
		sc->sc_pparams = audio_default;
@


1.93
log
@add audio(4) driver the ability to use different block sizes for play and
record modes. This makes possible to have blocks of the same duration if the
play and record formats are different. The API change is backward
compatible, so it shouldn't be noticed by current audio ports.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.92 2008/03/22 07:48:58 ratchov Exp $	*/
d1625 1
d1772 1
a1772 1
			if (!error)
d1774 7
@


1.92
log
@when setting the block size, use the scale factor only once in
audiosetinfo(), so the block size don't get scaled twice. Also fix the
formula used in audiosetinfo().

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.91 2008/03/12 20:33:13 ratchov Exp $	*/
d317 1
a317 1
	sc->sc_blkset = 0;
d556 1
a556 1
	printf("blksize %d", sc->sc_pr.blksize);
a980 1
	sc->sc_blkset = 0; /* Block sizes not set yet */
d1038 1
d1373 9
a1381 4
	if (sc->sc_blkset)
		return;

	param = (mode == AUMODE_PLAY) ? &sc->sc_pparams : &sc->sc_rparams;
d2742 5
d2748 7
a2754 1
		sc->sc_blkset = 0;
d2759 6
d2768 1
a2768 1
		if (ai->blocksize == ~0 || ai->blocksize == 0) {
d2772 1
a2772 1
			fpb = (ai->blocksize * rp.factor) / fs;
d2774 1
a2774 1
		if (sc->sc_blkset == 0)
d2778 1
a2778 1
		if (ai->blocksize == ~0 || ai->blocksize == 0) {
d2782 1
a2782 1
			fpb = (ai->blocksize * pp.factor) / fs;
d2784 1
a2784 1
		if (sc->sc_blkset == 0)
d2787 4
a2790 2
	if ((ai->blocksize != ~0) && (ai->blocksize != 0))
		sc->sc_blkset = 1;
d3008 3
a3010 1
	if ((ai->blocksize = sc->sc_pr.blksize / sc->sc_pparams.factor) != 0) {
d3016 1
@


1.91
log
@Set the default high water mark to the buffer size, instead of the buffer
size minus one block. Otherwise, recording cannot work with 32kB blocks.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.90 2008/02/28 09:15:04 jakemsr Exp $	*/
d1353 1
a1353 1
	fs = parm->channels * parm->precision / NBBY * parm->factor;
d2749 2
a2750 2
			fs = rp.channels * (rp.precision / 8) * rp.factor; 
			fpb = ai->blocksize / fs;
d2759 2
a2760 2
			fs = pp.channels * (pp.precision / 8) * pp.factor; 
			fpb = ai->blocksize / fs;
@


1.90
log
@
from audio(4):

      blocksize sets the current audio blocksize.  The generic audio
      driver layer and the hardware driver have the opportunity to ad-
      just this block size to get it within implementation-required
      limits.  Upon return from an AUDIO_SETINFO call, the actual
      blocksize set is returned in this field.  Normally the blocksize
      is calculated to correspond to 50ms of sound and it is recalcu-
      lated when the encoding parameter changes, but if the blocksize
      is set explicitly this value becomes sticky, i.e., it remains
      even when the encoding is changed.  The stickiness can be cleared
      by reopening the device or setting the blocksize to 0.

however, there were insufficient checks to make the blocksize is
actually sticky once it is set by the user.  this adds them.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.89 2007/11/17 13:31:30 ratchov Exp $	*/
d917 1
a917 1
	sc->sc_rr.usedhigh = sc->sc_rr.end - sc->sc_rr.start - sc->sc_rr.blksize;
@


1.89
log
@use tables to determine the best control to use for play.gain, record.gain
and monitor_gain; this makes play.gain always usable as general purpose
volume knob even on devices that don't have outputs.master.

ok jakemsr@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.88 2007/10/28 13:27:05 ratchov Exp $	*/
d2738 1
d2752 2
a2753 2
		audio_set_blksize(sc, AUMODE_RECORD, fpb);
		sc->sc_blkset = 1;
d2762 4
a2765 1
		audio_set_blksize(sc, AUMODE_PLAY, fpb);
a2766 1
	}
@


1.88
log
@prepare audio(4) for addition of the envy(4) driver: enable 32bit samples
(basically only audio_fill_silence() must be updated) and bump max channel
number to 12

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.87 2007/10/28 13:23:01 ratchov Exp $	*/
d172 26
d199 2
a200 2
			    mixer_devinfo_t *, int, char *, char *,
			    struct portname *);
d265 2
a266 2
	mixer_devinfo_t mi;
	int iclass, oclass, mclass;
d324 1
a324 1
	iclass = oclass = mclass = -1;
a338 13
		if (mi.type == AUDIO_MIXER_CLASS &&
		    strcmp(mi.label.name, AudioCrecord) == 0)
			iclass = mi.index;
		if (mi.type == AUDIO_MIXER_CLASS &&
		    strcmp(mi.label.name, AudioCmonitor) == 0)
			mclass = mi.index;
		if (mi.type == AUDIO_MIXER_CLASS &&
		    strcmp(mi.label.name, AudioCoutputs) == 0)
			oclass = mi.index;
	}
	for(mi.index = 0; ; mi.index++) {
		if (hwp->query_devinfo(hdlp, &mi) != 0)
			break;
d341 12
a352 10
		au_check_ports(sc, &sc->sc_inports,  &mi, iclass,
		    AudioNsource, AudioNrecord, itable);
		au_check_ports(sc, &sc->sc_outports, &mi, oclass,
		    AudioNoutput, AudioNmaster, otable);
		if (mi.mixer_class == mclass &&
		    (strcmp(mi.label.name, AudioNmonitor) == 0))
			sc->sc_monitor_port = mi.index;
		if ((sc->sc_monitor_port == -1) && (mi.mixer_class == oclass) &&
		    (strcmp(mi.label.name, AudioNmonitor) == 0))
			sc->sc_monitor_port = mi.index;
d429 2
a430 1
    mixer_devinfo_t *mi, int cls, char *name, char *mname, struct portname *tbl)
d434 2
a435 7
	if (mi->mixer_class != cls)
		return;
	if (strcmp(mi->label.name, mname) == 0) {
		ports->master = mi->index;
		return;
	}
	if (strcmp(mi->label.name, name) != 0)
d466 25
@


1.87
log
@the pointer we give to audio_fill_silence() may point in the middle of a
sample (eg. if write(2) have written an odd number of bytes and 16bit
encoding is used), so we'll not properly write silence. To fix this,
round start pointer to fill with silence uncomplete samples too.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.86 2007/10/27 08:52:47 ratchov Exp $	*/
d1348 2
a1349 2
	u_char auzero0, auzero1 = 0; /* initialize to please gcc */
	int nfill = 1;
d1356 2
a1357 1
	rounderr = (p - start) % (params->precision / 8);
d1360 1
d1363 3
d1367 1
a1367 1
		auzero0 = 0x7f;
d1370 7
a1376 1
		auzero0 = 0x55;
a1384 17
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_SLINEAR_BE:
		auzero0 = 0;	/* fortunately this works for both 8 and 16 bits */
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_BE:
		if (params->precision == 16) {
			nfill = 2;
			if (params->encoding == AUDIO_ENCODING_ULINEAR_LE) {
				auzero0 = 0;
				auzero1 = 0x80;
			} else {
				auzero0 = 0x80;
				auzero1 = 0;
			}
		} else
			auzero0 = 0x80;
a1387 1
		auzero0 = 0;
d1390 3
a1392 9
	if (nfill == 1) {
		while (--n >= 0)
			*p++ = auzero0; /* XXX memset */
	} else /* nfill must be 2 */ {
		while (n > 1) {
			*p++ = auzero0;
			*p++ = auzero1;
			n -= 2;
		}
d2230 2
a2231 1
		if (p->precision != 8 && p->precision != 16)
d2245 2
a2246 1
	if (p->channels < 1 || p->channels > 8)	/* sanity check # of channels */
@


1.86
log
@fix: when a block is captured audio_rint() is called, we must
consider that the ring buffer has overrrun if (used >= usedhigh) and not
if (used >= usedhigh + blksize), otherwise recording doesn't work when
large enough blocks are used

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.85 2007/10/25 18:13:42 ratchov Exp $	*/
d132 1
a132 1
void	audio_fill_silence(struct audio_params *, u_char *, int);
d1069 1
a1069 1
			audio_fill_silence(&sc->sc_pparams, inp, ncc);
d1072 1
a1072 1
			audio_fill_silence(&sc->sc_pparams, inp, cc);
d1345 1
a1345 1
audio_fill_silence(struct audio_params *params, u_char *p, int n)
d1347 1
d1351 9
d1416 1
a1416 1
	audio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);
d1581 1
a1581 1
				audio_fill_silence(&sc->sc_pparams, einp, ncc);
d1584 1
a1584 1
				audio_fill_silence(&sc->sc_pparams, einp, cc);
d1872 1
a1872 1
			audio_fill_silence(&sc->sc_pparams, cb->start, cb->bufsize);
d1976 1
a1976 1
				audio_fill_silence(&sc->sc_pparams, inp, ncc);
d1979 1
a1979 1
				audio_fill_silence(&sc->sc_pparams, inp, cc);
d1993 1
a1993 1
			audio_fill_silence(&sc->sc_pparams, inp, ncc);
d1996 1
a1996 1
			audio_fill_silence(&sc->sc_pparams, inp, cc);
@


1.85
log
@sc->sc_pr.usedlow must be multiple of the block size, fix
audio_calcwater() to do so

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.84 2007/10/25 18:11:15 ratchov Exp $	*/
d2172 1
a2172 1
	} else if (cb->used + blksize >= cb->usedhigh && !cb->copying) {
@


1.84
log
@return POLLOUT as long as (lowat + 1) isn't reached. without this audio(4)
is unusable with lowat = 1

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.83 2007/10/23 17:43:41 ratchov Exp $	*/
d873 8
a880 4
	sc->sc_pr.usedhigh = sc->sc_pr.end - sc->sc_pr.start;
	sc->sc_pr.usedlow = sc->sc_pr.usedhigh * 3 / 4;	/* set lowater at 75% */
	if (sc->sc_pr.usedlow == sc->sc_pr.usedhigh)
		sc->sc_pr.usedlow -= sc->sc_pr.blksize;
@


1.83
log
@add a new audio_set_blksize() function that sets (and adjusts) the block
size to the given number of frames per second, all changes pass through it.
If parameters are changed or the user requested a new block size (or both),
the block size is recalculated.

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.82 2007/10/19 15:31:02 ratchov Exp $	*/
d1787 1
a1787 1
    (sc->sc_pr.used <= sc->sc_pr.usedlow))
@


1.82
log
@fix audio_calc_blksize() not to return larger block sizes than
the buffer size

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.81 2007/10/03 21:49:13 jakemsr Exp $	*/
d130 1
d1299 1
a1299 2
audio_calc_blksize(struct audio_softc *sc, int mode)
{
d1303 1
a1303 4
	int bs, maxbs, fs;

	if (sc->sc_blkset)
		return;
d1314 1
a1314 1
	bs = parm->sample_rate * audio_blk_ms / 1000 * fs;
d1324 1
a1324 1
	DPRINTF(("audio_calc_blksize: %s blksize=%d\n",
d1329 12
d2578 2
d2698 6
a2703 4
	/* Play params can affect the record params, so recalculate blksize. */
	if (nr || np) {
		audio_calc_blksize(sc, AUMODE_RECORD);
		audio_calc_blksize(sc, AUMODE_PLAY);
d2705 21
a2793 23
	}

	if (ai->blocksize != ~0) {
		/* Block size specified explicitly. */
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		if (ai->blocksize == 0) {
			audio_calc_blksize(sc, AUMODE_RECORD);
			audio_calc_blksize(sc, AUMODE_PLAY);
			sc->sc_blkset = 0;
		} else {
			int rbs = ai->blocksize * sc->sc_rparams.factor;
			int pbs = ai->blocksize * sc->sc_pparams.factor;
			if (hw->round_blocksize) {
				rbs = hw->round_blocksize(sc->hw_hdl, rbs);
				pbs = hw->round_blocksize(sc->hw_hdl, pbs);
			}
			sc->sc_rr.blksize = rbs;
			sc->sc_pr.blksize = pbs;
			sc->sc_blkset = 1;
		}
@


1.81
log
@
add two new audio ioctls, AUDIO_GETPRINFO and AUDIO_GETRRINFO, and the
data structure these ioctls use, audio_bufinfo.

these ioctls return information about the play and record buffers
into the audio_bufinfo structure.

these are being added to aid in porting non-native audio applications
and libraries, and to fix issues in our OSS audio emulation.  these
ioctls exist only on OpenBSD and should not be used in code intended
for distribution.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.80 2007/09/24 19:45:03 ratchov Exp $	*/
d1303 1
a1303 1
	int bs;
d1316 6
a1321 3
	bs = parm->sample_rate * audio_blk_ms / 1000 *
	     parm->channels * parm->precision / NBBY *
	     parm->factor;
@


1.80
log
@accept values > 1 for "output_muted". That's what SunOS do. Suggested
by deanna@@

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.79 2007/09/24 19:23:41 ratchov Exp $	*/
d107 1
a107 1

d1732 12
d2938 29
@


1.79
log
@fix audioctl(1) returning  bugus values of 'output_muted' because of
uninitialized variable.

found by deanna@@, ok jackmsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.78 2007/09/17 13:46:11 jakemsr Exp $	*/
d2301 1
a2301 1
	ct.un.ord = mute;
@


1.78
log
@implement the output_muted member of audio_info_t as found in original
Sun audio.

input from and ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.77 2007/09/17 13:35:46 jakemsr Exp $	*/
d2245 2
@


1.77
log
@
use au_get_gain()/au_set_gain() and the new au_get_mute()/au_set_mute()
functions instead of doing things the hard way.

also add some bits to au_set_gain() so it sets a gain that is within
limits.  its possible to pass in an out-of-range value through
audioctl(1) as well.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.76 2007/09/17 13:33:29 jakemsr Exp $	*/
d2726 6
d2885 2
@


1.76
log
@add functions to mute/unmute output

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.75 2007/09/10 22:24:04 ratchov Exp $	*/
a216 1
int wskbd_get_mixerdev(struct audio_softc *, int, int *);
d2317 6
a3104 57
wskbd_get_mixerdev(struct audio_softc *sc, int dir, int *index)
{
	mixer_devinfo_t mi;
	int mixer_class;
	int error;

	/* looking for ``outputs'' */
	for (mi.index = 0; ; mi.index++) {
		error = sc->hw_if->query_devinfo(sc->hw_hdl, &mi);
		if (error != 0)
			return (-1);

		if (mi.type == AUDIO_MIXER_CLASS &&
		    strcmp(mi.label.name, AudioCoutputs) == 0) {
			mixer_class = mi.mixer_class;
			break;
		}
	}

	/*
	 * looking for ``outputs.master''
	 * start mi.index from 0 because ''outputs.master'' can precede
	 * ''outputs''.
	 */
	for (mi.index = 0; ; mi.index++) {
		error = sc->hw_if->query_devinfo(sc->hw_hdl, &mi);
		if (error != 0)
			return (-1);

		if (mi.type == AUDIO_MIXER_VALUE &&
		    mi.mixer_class == mixer_class &&
		    strcmp(mi.label.name, AudioNmaster) == 0) {
			if (dir == 0) {
				/* looking for ``outputs.master.mute'' */
				if (mi.next < 0)
					return (-1);

				mi.index = mi.next;
				error = sc->hw_if->query_devinfo(sc->hw_hdl,
				    &mi);
				if (error != 0)
					return (-1);

				if (mi.type != AUDIO_MIXER_ENUM ||
				    strcmp(mi.label.name, AudioNmute) != 0)
					return (-1);
			}

			*index = mi.index;
			return (0);
		}
	}

	return (-1);
}

int
a3108 2
	mixer_ctrl_t ct;
	int l, r;
d3110 2
d3118 2
a3119 3
	error = wskbd_get_mixerdev(sc, dir, &ct.dev);
	if (error == -1) {
		DPRINTF(("wskbd_set_mixervolume: wskbd_get_mixerdev\n"));
d3124 3
a3126 6
		/*
		 * Mute.
		 * Use mixer_ioctl() for writing. It does many things for us.
		 */
		ct.type = AUDIO_MIXER_ENUM;
		error = sc->hw_if->get_port(sc->hw_hdl, &ct);
d3129 1
a3129 1
			    " get_port: %d\n", error));
d3133 1
a3133 1
		ct.un.ord = !ct.un.ord;	/* toggle */
d3135 1
a3135 2
		error = mixer_ioctl(MIXER_DEVICE,
		    AUDIO_MIXER_WRITE, (caddr_t)&ct, FWRITE, curproc);
d3138 1
a3138 1
			    " mixer_ioctl: %d\n", error));
d3142 3
a3144 1
		mi.index = ct.dev;
d3152 1
a3152 1
		ct.type = AUDIO_MIXER_VALUE;
d3154 4
a3157 15
		error = au_get_lr_value(sc, &ct, &l, &r);
		if (error != 0) {
			DPRINTF(("wskbd_set_mixervolume:"
			    " au_get_lr_value: %d\n", error));
			return (error);
		}

		if (dir > 0) {
			/*
			 * Raise volume
			 */
			if (l > AUDIO_MAX_GAIN - mi.un.v.delta)
				l = AUDIO_MAX_GAIN;
			else
				l += mi.un.v.delta;
d3159 1
a3159 21
			if (r > AUDIO_MAX_GAIN - mi.un.v.delta)
				r = AUDIO_MAX_GAIN;
			else
				r += mi.un.v.delta;

		} else {
			/*
			 * Lower volume
			 */
			if (l < AUDIO_MIN_GAIN + mi.un.v.delta)
				l = AUDIO_MIN_GAIN;
			else
				l -= mi.un.v.delta;

			if (r < AUDIO_MIN_GAIN + mi.un.v.delta)
				r = AUDIO_MIN_GAIN;
			else
				r -= mi.un.v.delta;
		}

		error = au_set_lr_value(sc, &ct, l, r);
d3162 1
a3162 1
			    " au_set_lr_value: %d\n", error));
@


1.75
log
@fix uninitialized linked list head

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.74 2007/09/10 05:34:32 ratchov Exp $	*/
d181 2
d2238 68
@


1.74
log
@initialize sc_outports->master and sc_inports->master. Fixes "set failed"
errors when running audioctl(1) on devices without master controls

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.73 2007/09/09 02:55:18 jakemsr Exp $	*/
d266 1
@


1.73
log
@don't try to set the recording gain or balance through /dev/audio[ctl]
if the selected recording port is not a port the limited /dev/audio[ctl]
interface to mixer controls supports.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.72 2007/08/08 05:51:23 jakemsr Exp $	*/
d300 1
d305 1
@


1.72
log
@revert the change in rev 1.60 of audio.c and the corresponding
documentation change

the audio layer is still too "imperfect" for this change

fixes problems reported aanriot, matthieu and dtucker

requested by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.71 2007/08/02 07:24:46 jakemsr Exp $	*/
d2628 1
a2628 1
	if (r->gain != ~0) {
d2641 1
a2641 1
	if (r->balance != (u_char)~0) {
@


1.71
log
@for consistency, keep the count of dropped data in HW sample size, and
convert to userland sample size when needed.

why this subsystem wasn't written with samples as the basic unit of
measure is beyond me.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.70 2007/08/02 07:15:49 jakemsr Exp $	*/
d943 2
a944 1
	sc->sc_full_duplex =
d947 1
@


1.70
log
@the MI audio layer never really knows what encoding the hardware uses;
the hardware drivers just set a conversion function.

when the MI audio layer needs to add silence, it adds silence in the
userland format, but the amount added is for the hardware sample size.

this diff fixes both record mode by sending the right amount, and
play mode by converting the silence to the right format.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.69 2007/07/31 03:11:14 jakemsr Exp $	*/
d1427 1
a1427 1
		n = min(sc->sc_playdrop, uio->uio_resid);
d1429 2
a1430 2
		uio->uio_offset += n;
		uio->uio_resid -= n;
d1609 11
d1622 3
a1624 1
		*(int *)addr = sc->sc_rr.drops;
d1628 3
a1630 1
		*(int *)addr = sc->sc_pr.drops;
d1970 1
a1970 1
	int cc, ccr;
a2029 1
			ccr = cc / sc->sc_pparams.factor;
d2031 1
a2031 1
				cb->pdrops += ccr;
d2033 2
a2034 2
				cb->drops += ccr;
				sc->sc_playdrop += ccr;
@


1.69
log
@always ignore attempts to set the record or play port to 0.

this interface to mixer functionality is very limited, and is only
used for recording.  it only recognizes 'mic', 'cd', and 'line' as
valid recording inputs.  many devices have other inputs.  because of
the way AUDIO_INITINFO works, it is impossible to expand this API to
include all devices.

this fixes another common cause of audioctl(1) problems.  AUDIO_GETINFO
returns 0 for record.port when the recording port is something other
than 'mic', 'cd', or 'line', and the subsequent AUDIO_SETINFO would
fail on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.68 2007/07/18 19:27:08 jakemsr Exp $	*/
d1056 6
a1061 1
		audio_fill_silence(&sc->sc_pparams, inp, cc);
d1211 2
a1212 2
			if (uio->uio_resid < cc)
				cc = uio->uio_resid;
d1214 2
a1215 1
			error = audio_silence_copyout(sc, cc, uio);
d1547 6
a1552 1
			audio_fill_silence(&sc->sc_pparams, einp, cc);
d1914 8
a1921 1
			audio_fill_silence(&sc->sc_pparams, inp, cc);
d1931 8
a1938 1
		audio_fill_silence(&sc->sc_pparams, inp, cc);
@


1.68
log
@- when traversing mixer fields in the attach routine and connecting
  the mixer layer to the audio layer, differentiate between the
  'monitor' class and the 'outputs' class instead of lumping them
  together.  not all mixers have a monitor class entry which was
  causing the outputs class to be ignored.

- look for monitor port in the monitor class, but if the monitor
  port is not found in the monitor class look in the outputs class
  as well.  the code was effectively looking in both the monitor and
  outputs classes before, so this is no real change.

sets up audio_info.play.[gain|balance] correctly on at least emu(4),
auich(4), auvia(4) and snapper(4) ... probably most other AC'97 devices
as well.  as a result, audioctl(1) works much better and the overall
volume can be set with /dev/audio instead of needing to go through
/dev/mixer.

from deanna@@

thanks again to those who tested this change
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.67 2007/07/18 18:34:32 jakemsr Exp $	*/
d2362 2
a2363 2
	if (port == 0 && ports->allports == 0)
		return 0;	/* allow this special case */
@


1.67
log
@
move the processing of the pause attribute to the end of audiosetinfo(),
to allow buffer sizes and pointer to the buffer to be set to reasonable
values for the sample size of the data to be read/written.

fixes kernel corruption seen with azalia and probably other drivers
that are using something other than 8kHz monaural mulaw as the default
encoding when doing 'dd if=/dev/audio of=foo' as the first audio
operation after boot.

problem reported by deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.66 2007/07/18 18:28:39 jakemsr Exp $	*/
d238 1
a238 1
	int iclass, oclass;
d295 1
a295 1
	iclass = oclass = -1;
d313 3
d327 4
a330 1
		if (mi.mixer_class == oclass &&
@


1.66
log
@
more places where the difference between the hardware sample size
and the userland sample size matters.

there may be different sample size factors for play and record,
so use the appropriate factor when userland sets the blocksize.

the reported blocksize, hiwat and lowat are only for the play buffer.
IMO, it would be good to report the record blocksize, hiwat and lowat
as well, but that is another issue.

tested with emu(4) and an auvia(4) modified to only do stereo in
hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.65 2007/07/17 10:35:10 jakemsr Exp $	*/
a2613 21
	if (p->pause != (u_char)~0) {
		sc->sc_pr.pause = p->pause;
		if (!p->pause && !sc->sc_pbus && (sc->sc_mode & AUMODE_PLAY)) {
			s = splaudio();
			error = audiostartp(sc);
			splx(s);
			if (error)
				return error;
		}
	}
	if (r->pause != (u_char)~0) {
		sc->sc_rr.pause = r->pause;
		if (!r->pause && !sc->sc_rbus && (sc->sc_mode & AUMODE_RECORD)) {
			s = splaudio();
			error = audiostartr(sc);
			splx(s);
			if (error)
				return error;
		}
	}

d2688 21
@


1.65
log
@- the data in the read buffer, that was put there by the hardware,
  may not be the same sample size as what userland is to receive.
  account for the discrepency between the sample sizes when comparing
  how much to copy out with what userland expects.

- only copy out the part of the buffer that is in the format userland
  expects.

emu(4) can now record with all encodings it claims to be able to.
that is, dd if=/dev/audio of=foo does as audio(4) says (monaural
mu-law) and does it correctly.

AFAIKS, the only other driver that sets a read factor is uaudio(4),
and that depends on what the hardware supports.

tested on i386, amd64 and sgi with 3 different emu(4) cards
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.64 2007/07/14 02:31:33 jakemsr Exp $	*/
d2646 8
a2653 4
			int bs = ai->blocksize;
			if (hw->round_blocksize)
				bs = hw->round_blocksize(sc->hw_hdl, bs);
			sc->sc_pr.blksize = sc->sc_rr.blksize = bs;
d2755 2
a2756 2
	p->seek = sc->sc_pr.used;
	r->seek = sc->sc_rr.used;
d2778 2
a2779 2
	p->buffer_size = sc->sc_pr.bufsize;
	r->buffer_size = sc->sc_rr.bufsize;
d2781 1
a2781 1
	if ((ai->blocksize = sc->sc_pr.blksize) != 0) {
@


1.64
log
@- ANSI function declarations
- remove argument names from function prototypes

OK jasper@@, ray@@, "Didn't notice any errors" marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.63 2007/07/10 08:45:37 jakemsr Exp $	*/
d1240 3
a1242 2
		if (uio->uio_resid < cc)
			cc = uio->uio_resid; /* and no more than we want */
d1247 1
a1247 1
		error = uiomove(outp, cc, uio);
@


1.63
log
@fix the bug rev 1.56 uncovered and rev 1.62 worked around.

data is expanded before it goes in the buffer.  all sizes
and offsets used internally are of this expanded data.
there's no need to compensate for this fact except when
showing information to the user in case their actions
depend on how many bytes are in the buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.62 2007/07/09 09:18:47 jakemsr Exp $	*/
d201 2
a202 2
void filt_audiowdetach(struct knote *kn);
int filt_audiowrite(struct knote *kn, long hint);
d207 2
a208 2
void filt_audiordetach(struct knote *kn);
int filt_audioread(struct knote *kn, long hint);
d215 2
a216 2
int wskbd_get_mixerdev(struct audio_softc *sc, int dir, int *index);
int wskbd_set_mixervolume(long dir);
d220 1
a220 4
audioprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d230 1
a230 3
audioattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d333 1
a333 3
audioactivate(self, act)
	struct device *self;
	enum devact act;
d349 1
a349 3
audiodetach(self, flags)
	struct device *self;
	int flags;
d389 1
a389 3
au_portof(sc, name)
	struct	audio_softc *sc;
	char	*name;
d402 2
a403 8
au_check_ports(sc, ports, mi, cls, name, mname, tbl)
	struct	audio_softc *sc;
	struct	au_mixer_ports *ports;
	mixer_devinfo_t *mi;
	int	cls;
	char	*name;
	char	*mname;
	struct	portname *tbl;
d452 1
a452 4
audio_attach_mi(ahwp, hdlp, dev)
	struct audio_hw_if *ahwp;
	void *hdlp;
	struct device *dev;
d471 1
a471 3
audioprint(aux, pnp)
	void *aux;
	const char *pnp;
d502 1
a502 2
audio_printsc(sc)
	struct audio_softc *sc;
d514 1
a514 3
audio_print_params(s, p)
	char *s;
	struct audio_params *p;
d522 2
a523 5
audio_alloc_ring(sc, r, direction, bufsize)
	struct audio_softc *sc;
	struct audio_ringbuffer *r;
	int direction;
	int bufsize;
d547 1
a547 3
audio_free_ring(sc, r)
	struct audio_softc *sc;
	struct audio_ringbuffer *r;
d557 1
a557 4
audioopen(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
d595 1
a595 4
audioclose(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
d612 1
a612 4
audioread(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d646 1
a646 4
audiowrite(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d680 1
a680 6
audioioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d714 1
a714 4
audiopoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d748 1
a748 4
audiommap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d785 1
a785 2
audio_init_ringbuffer(rp)
	struct audio_ringbuffer *rp;
d814 1
a814 2
audio_initbufs(sc)
	struct audio_softc *sc;
d860 1
a860 2
audio_calcwater(sc)
	struct audio_softc *sc;
d871 1
a871 4
audio_sleep_timo(chan, label, timo)
	int *chan;
	char *label;
	int timo;
d891 1
a891 3
audio_sleep(chan, label)
	int *chan;
	char *label;
d898 1
a898 2
audio_wakeup(chan)
	int *chan;
d908 2
a909 5
audio_open(dev, sc, flags, ifmt, p)
	dev_t dev;
	struct audio_softc *sc;
	int flags, ifmt;
	struct proc *p;
d1007 1
a1007 2
audio_init_record(sc)
	struct audio_softc *sc;
d1021 1
a1021 2
audio_init_play(sc)
	struct audio_softc *sc;
d1032 1
a1032 2
audio_drain(sc)
	struct audio_softc *sc;
d1096 1
a1096 4
audio_close(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
d1157 1
a1157 4
audio_read(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d1261 1
a1261 2
audio_clear(sc)
	struct audio_softc *sc;
d1279 1
a1279 3
audio_calc_blksize(sc, mode)
	struct audio_softc *sc;
	int mode;
d1310 1
a1310 4
audio_fill_silence(params, p, n)
	struct audio_params *params;
	u_char *p;
	int n;
d1365 1
a1365 4
audio_silence_copyout(sc, n, uio)
	struct audio_softc *sc;
	int n;
	struct uio *uio;
d1383 1
a1383 4
audio_write(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d1541 1
a1541 6
audio_ioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d1727 1
a1727 4
audio_poll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1754 1
a1754 4
audio_mmap(dev, off, prot)
	dev_t dev;
	off_t off;
	int prot;
d1812 1
a1812 2
audiostartr(sc)
	struct audio_softc *sc;
d1836 1
a1836 2
audiostartp(sc)
	struct audio_softc *sc;
d1877 2
a1878 5
audio_pint_silence(sc, cb, inp, cc)
	struct audio_softc *sc;
	struct audio_ringbuffer *cb;
	u_char *inp;
	int cc;
d1917 1
a1917 2
audio_pint(v)
	void *v;
d2031 1
a2031 2
audio_rint(v)
	void *v;
d2115 1
a2115 2
audio_check_params(p)
	struct audio_params *p;
d2174 1
a2174 4
au_set_lr_value(sc, ct, l, r)
	struct	audio_softc *sc;
	mixer_ctrl_t *ct;
	int l, r;
d2188 2
a2189 5
au_set_gain(sc, ports, gain, balance)
	struct	audio_softc *sc;
	struct	au_mixer_ports *ports;
	int	gain;
	int	balance;
d2258 1
a2258 4
au_get_lr_value(sc, ct, l, r)
	struct	audio_softc *sc;
	mixer_ctrl_t *ct;
	int *l, *r;
d2277 2
a2278 5
au_get_gain(sc, ports, pgain, pbalance)
	struct	audio_softc *sc;
	struct	au_mixer_ports *ports;
	u_int	*pgain;
	u_char	*pbalance;
d2350 1
a2350 4
au_set_port(sc, ports, port)
	struct	audio_softc *sc;
	struct	au_mixer_ports *ports;
	u_int	port;
d2389 1
a2389 3
au_get_port(sc, ports)
	struct	audio_softc *sc;
	struct	au_mixer_ports *ports;
d2414 1
a2414 3
audiosetinfo(sc, ai)
	struct audio_softc *sc;
	struct audio_info *ai;
d2710 1
a2710 3
audiogetinfo(sc, ai)
	struct audio_softc *sc;
	struct audio_info *ai;
d2791 2
a2792 5
mixer_open(dev, sc, flags, ifmt, p)
	dev_t dev;
	struct audio_softc *sc;
	int flags, ifmt;
	struct proc *p;
d2803 1
a2803 3
mixer_remove(sc, p)
	struct audio_softc *sc;
	struct proc *p;
d2821 1
a2821 2
mixer_signal(sc)
	struct audio_softc *sc;
d2834 1
a2834 4
mixer_close(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
d2847 1
a2847 6
mixer_ioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d2909 1
a2909 3
audiokqfilter(dev, kn)
	dev_t	dev;
	struct knote *kn;
@


1.62
log
@take into account possible expansion and be more careful not to
try to go past the end of the buffer.

this and the last commit allow ffplay and gnash to work properly
on devices that may need to do mono to stereo conversion, like
auich(4).

problem reported by and much debugging deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.60 2007/07/06 04:40:20 jakemsr Exp $	*/
d1815 1
a1815 1
    (sc->sc_pr.used * sc->sc_pparams.factor <= sc->sc_pr.usedlow))
d2040 1
a2040 1
	cb->stamp += blksize / sc->sc_pparams.factor;
@


1.61
log
@give the user what they expect instead of what we're working with
by taking into account expansion we may have done in cases such as
playing monoaural media on a device that only plays stereo, like
auich(4).
@
text
@d1815 1
a1815 1
    (sc->sc_pr.used < sc->sc_pr.usedhigh))
@


1.60
log
@- enable full-duplex mode by default if a device is opened
  read-write and it supports full-duplex operation.
- update documentation to match this behaviour.

see http://marc.info/?l=openbsd-tech&m=118310788926431&w=2 for
more background on this change

"patches look correct to me" marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.59 2007/07/06 04:25:28 jakemsr Exp $	*/
d1724 1
a1724 1
		*(u_long *)addr = sc->sc_pr.used;
@


1.59
log
@the AUDIO_WSEEK ioctl should return the number of bytes in the play
buffer, not the record buffer.

inspired by recent similar change in NetBSD.

"patches look correct to me" marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.58 2007/07/06 04:12:50 jakemsr Exp $	*/
d1002 1
a1002 2
	sc->sc_full_duplex = 0;
/* doesn't always work right on SB.
a1004 1
*/
@


1.58
log
@be sure to respect the pause attribute

originally from Alexandre Ratchov

"patches look correct to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.57 2007/07/06 04:10:34 jakemsr Exp $	*/
d1726 1
a1726 1
		*(u_long *)addr = sc->sc_rr.used;
@


1.57
log
@- there is no need for audio_init_ringbuffer() to always set the "pause"
  attribute to '0'.  this function may be called when executing an
  AUDIO_SETINFO ioctl where the pause attribute was set to '1', and
  setting it to '0' in this function will cause unexpected bahaviour.
- according to audio(4), the AUDIO_FLUSH ioctl "restarts recording
  and playback".  therefor, it should set the pause attributes to '0'.
  this was previously accomplished indirectly, because it calls
  audio_init_ringbuffer(), which was setting pause to '0'.
- the pause attribute must be set to '0' in audio_open() so that
  recording and playback buffers can be "activated" when the device
  is opened.  this was apparently forgotten when audiosetinfo()
  was split off of audio_open() and the logic in audiosetinfo()
  was changed to accomodate being run at times other than open().
  also, this only really affects read() with poll(), which may
  explain why the problem was not noticed for some time.

originally part of a patch Alexandre Ratchov sent to tech@@ a
while back

fixes PR 3813

"patches look correct to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.56 2007/07/06 03:20:07 jakemsr Exp $	*/
d1287 1
a1287 1
			if (!sc->sc_rbus) {
d1896 1
a1896 1
			if (!sc->sc_pbus)
d1901 1
a1901 1
			if (!sc->sc_rbus)
d2800 1
a2800 1
		    pbus && !sc->sc_pbus)
d2804 1
a2804 1
		    rbus && !sc->sc_rbus)
@


1.56
log
@The poll(2) syscall doesn't work correctly on audio(4) devices.
For instance, it may not set POLLIN when samples become available,
or may set POLLOUT when write(2) will block.

Fix this by making conditions used by poll (FILTREAD and FILTWRITE
macros) match the blocking conditions in audio_read() and audio_write().

originally from Alexandre Ratchov, with a small tweak by me.

"patches look correct to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.55 2007/05/31 22:23:13 tedu Exp $	*/
a861 1
	rp->pause = 0;
d1046 1
d1051 1
d1671 2
@


1.55
log
@switch wskbd hotkeys over to workq.  this eliminates quite a bit of code,
so remove the option too.  if you have audio and wskbd, you have hotkeys.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.54 2007/01/07 13:35:51 miod Exp $	*/
d1807 2
a1808 1
#define	AUDIO_FILTREAD(sc) ((sc->sc_mode & AUMODE_PLAY) ? \
d1810 5
a1814 2
#define	AUDIO_FILTWRITE(sc) \
    (sc->sc_mode & AUMODE_RECORD || sc->sc_pr.used <= sc->sc_pr.usedlow)
@


1.54
log
@Protect against zero blocksize (causing a divide by zero) in audiogetinfo().
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.53 2006/11/29 13:34:31 miod Exp $	*/
d90 1
a90 1
#include "wskbd.h"	/* NWSKBD_HOTKEY (mixer tuning using keyboard) */
d213 1
a213 1
#if NWSKBD_HOTKEY > 0
d216 1
a216 1
int wskbd_set_mixervolume(int dir);
d3110 1
a3110 1
#if NAUDIO > 0 && NWSKBD_HOTKEY > 0
d3169 1
a3169 1
wskbd_set_mixervolume(int dir)
d3267 1
a3267 1
#endif /* NAUDIO > 0 && NWSKBD_HOTKEY > 0 */
@


1.53
log
@Compile the mixer tuning via keyboard code if NWSKBD_HOTKEY if nonzero
rather than NWSKBD being nonzero.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.52 2006/11/01 03:37:23 tedu Exp $	*/
d2897 6
a2902 3
	ai->blocksize = sc->sc_pr.blksize;
	ai->hiwat = sc->sc_pr.usedhigh / sc->sc_pr.blksize;
	ai->lowat = sc->sc_pr.usedlow / sc->sc_pr.blksize;
@


1.52
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.51 2006/06/23 06:27:11 miod Exp $	*/
d90 1
a90 1
#include "wskbd.h"		/* NWSKBD (mixer tuning using keyboard) */
d213 1
a213 1
#if NWSKBD > 0
d3107 1
a3107 1
#if NAUDIO > 0 && NWSKBD > 0
d3264 1
a3264 1
#endif /* NAUDIO > 0 && NWSKBD > 0 */
@


1.51
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.50 2006/05/29 20:23:13 miod Exp $	*/
d772 1
a772 1
		return ENXIO;
d775 1
a775 1
		return (EIO);
@


1.50
log
@Add support for the audio volume keys found on many laptops' builtin
keyboard. These specific keys are posted to a kernel thread which will
issue mixer commands if an audio device exists.

Written by Alexey Vatchenko <avv , mail zp ua> with tweaks by deraadt@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.49 2006/03/12 10:34:50 jakemsr Exp $	*/
a345 1
		return (EOPNOTSUPP);
@


1.49
log
@explicitly initialize a couple variables

OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.48 2006/01/02 05:21:37 brad Exp $	*/
d90 2
d213 6
d3107 159
@


1.48
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.47 2005/11/21 18:16:38 millert Exp $	*/
d852 1
d854 1
@


1.47
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.46 2005/06/02 19:04:18 joris Exp $	*/
a147 2
#define __BROKEN_INDIRECT_CONFIG /* XXX */
#ifdef __BROKEN_INDIRECT_CONFIG
a148 3
#else
int	audioprobe(struct device *, struct cfdata *, void *);
#endif
a213 1
#ifdef __BROKEN_INDIRECT_CONFIG
a214 3
#else
	struct cfdata *match;
#endif
@


1.46
log
@

correctly close the audio device in audio_open() if one of the
precision parameters is zero.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.45 2005/04/14 05:39:17 brad Exp $	*/
d71 1
a71 1
#include <sys/select.h>
@


1.45
log
@Make sure recording is started before we return EWOULDBLOCK in a read().

From NetBSD

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.44 2004/07/10 11:48:30 vincent Exp $	*/
d1037 2
a1038 1
		return EINVAL;
@


1.44
log
@replace strange cpp magic by straight code

ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: audio.c,v 1.43 2004/01/09 21:32:23 brad Exp $	*/
/*	$NetBSD: audio.c,v 1.105 1998/09/27 16:43:56 christos Exp $	*/
d331 1
a331 1
		    strcmp(mi.label.name, AudioNmonitor) == 0)
a1284 4
			if (ioflag & IO_NDELAY) {
				splx(s);
				return EWOULDBLOCK;
			}
d1291 4
@


1.43
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.42 2003/09/23 16:51:12 millert Exp $	*/
a893 1
#define double u_long
d896 2
a897 2
	    (double)sc->sc_pr.blksize * 100000 /
	    (double)(sc->sc_pparams.precision / NBBY *
d904 2
a905 2
	    (double)sc->sc_rr.blksize * 100000 /
	    (double)(sc->sc_rparams.precision / NBBY *
a909 1
#undef double
@


1.42
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.41 2003/01/26 23:16:14 jason Exp $	*/
a86 2

#include <uvm/uvm_extern.h>
@


1.41
log
@compute record high water mark from record parameters not play parameters; from NetBSD kern/19614
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.40 2002/08/26 16:20:04 mickey Exp $	*/
d113 1
a113 1
int	audio_select(dev_t, int, struct proc *);
d765 1
a765 1
audioselect(dev, events, p)
d785 1
a785 1
		error = audio_select(dev, events, p);
d1816 1
a1816 1
audio_select(dev, rw, p)
d1818 1
a1818 1
	int rw;
d1823 1
a1823 3
	int rv, s = splaudio();

	DPRINTF(("audio_select: rw=0x%x mode=%d\n", rw, sc->sc_mode));
d1825 1
a1825 9
	switch (rw) {

	case FREAD:
		rv = AUDIO_FILTREAD(sc);
		splx(s);
		if (rv)
			return (1);
		selrecord(p, &sc->sc_rsel);
		break;
d1827 13
a1839 7
	case FWRITE:
		rv = AUDIO_FILTWRITE(sc);
		splx(s);
		if (rv)
			return (1);
		selrecord(p, &sc->sc_wsel);
		break;
d1842 1
a1842 1
	return (0);
@


1.40
log
@space cleanup; some from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.39 2002/06/16 01:36:22 mickey Exp $	*/
d927 1
a927 1
	sc->sc_rr.usedhigh = sc->sc_pr.end - sc->sc_pr.start - sc->sc_pr.blksize;
@


1.39
log
@implement kqueue for audio; tested on wiggy and niels@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.38 2002/03/14 01:26:51 millert Exp $	*/
d39 1
a39 1
 * 
d60 1
a60 1
 * - Add softaudio() isr processing for wakeup, poll, signals, 
d121 1
a121 1
    
d161 2
a162 2
	char 	*name;
	int 	mask;
d176 1
a176 1
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *, 
d179 1
a179 1
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *, 
d194 1
a194 1
struct audio_params audio_default = 
d207 2
a208 2
int filt_audiowrite(struct knote *kn, long hint); 
        
d210 1
a210 1
	{ 1, NULL, filt_audiowdetach, filt_audiowrite};  
d213 2
a214 2
int filt_audioread(struct knote *kn, long hint); 
        
d216 1
a216 1
	{ 1, NULL, filt_audiordetach, filt_audioread};  
d230 1
a230 1
	DPRINTF(("audioprobe: type=%d sa=%p hw=%p\n", 
d268 1
a268 1
        }
d288 1
a288 1
	
d328 5
a332 5
		au_check_ports(sc, &sc->sc_inports,  &mi, iclass, 
			       AudioNsource, AudioNrecord, itable);
		au_check_ports(sc, &sc->sc_outports, &mi, oclass, 
			       AudioNoutput, AudioNmaster, otable);
		if (mi.mixer_class == oclass && 
d342 2
a343 2
        struct device *self;
        enum devact act;
d345 6
a350 1
        struct audio_softc *sc = (struct audio_softc *)self;
d352 5
a356 10
        switch (act) {
        case DVACT_ACTIVATE:
                return (EOPNOTSUPP);
                break;

        case DVACT_DEACTIVATE:
                sc->sc_dying = 1;
                break;
        }
        return (0);
d361 2
a362 2
        struct device *self;
        int flags;
d364 26
a389 33
        struct audio_softc *sc = (struct audio_softc *)self;
        int maj, mn;
        int s;

        DPRINTF(("audio_detach: sc=%p flags=%d\n", sc, flags));

        sc->sc_dying = 1;

        wakeup(&sc->sc_wchan);
        wakeup(&sc->sc_rchan);
        s = splaudio();
        if (--sc->sc_refcnt >= 0) {
                if (tsleep(&sc->sc_refcnt, PZERO, "auddet", hz * 120))
                        printf("audiodetach: %s didn't detach\n",
                               sc->dev.dv_xname);
        }
        splx(s);

        /* free resources */
        audio_free_ring(sc, &sc->sc_pr);
        audio_free_ring(sc, &sc->sc_rr);

        /* locate the major number */
        for (maj = 0; maj < nchrdev; maj++)
                if (cdevsw[maj].d_open == audioopen)
                        break;

        /* Nuke the vnodes for any open instances (calls close). */
        mn = self->dv_unit;
        vdevgone(maj, mn | SOUND_DEVICE,    mn | SOUND_DEVICE, VCHR);
        vdevgone(maj, mn | AUDIO_DEVICE,    mn | AUDIO_DEVICE, VCHR);
        vdevgone(maj, mn | AUDIOCTL_DEVICE, mn | AUDIOCTL_DEVICE, VCHR);
        vdevgone(maj, mn | MIXER_DEVICE,    mn | MIXER_DEVICE, VCHR);
d391 8
a398 1
        return (0);
d408 1
a408 1
	for(mi.index = 0; 
d441 1
a441 1
			       tbl[i].name) == 0) {
d444 1
a444 1
			ports->miport[ports->nports++] = 
d456 1
a456 1
			       tbl[i].name) == 0) {
d459 1
a459 1
			ports->miport[ports->nports++] = 
d482 1
a482 1
	        printf ("audio_attach_mi: NULL\n");
d501 1
a501 1
 
d546 1
a546 1
	       p->sample_rate, p->encoding, p->channels, p->precision);
d569 1
a569 1
		r->start = hw->allocm(hdl, direction, r->bufsize, M_DEVBUF, 
d600 1
a600 1
        if (unit >= audio_cd.cd_ndevs ||
d605 1
a605 1
	        return (EIO);
d618 1
a618 1
	        error = mixer_open(dev, sc, flags, ifmt, p);
d626 1
a626 1
	        wakeup(&sc->sc_refcnt);
d661 3
a663 3
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;
d665 2
a666 2
        if (sc->sc_dying)
                return (EIO);
d682 1
a682 1
	
d684 1
a684 1
	        wakeup(&sc->sc_refcnt);
d699 1
a699 1
            (sc = audio_cd.cd_devs[unit]) == NULL)
d702 2
a703 2
        if (sc->sc_dying)
	  	return (EIO);
d709 1
a709 1
	  	error = audio_write(dev, uio, ioflag);
d719 1
a719 1
	
d721 1
a721 1
	        wakeup(&sc->sc_refcnt);
d737 3
a739 3
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;
d741 2
a742 2
        if (sc->sc_dying)
                return (EIO);
d758 1
a758 1
	
d760 1
a760 1
	        wakeup(&sc->sc_refcnt);
d770 2
a771 2
        int unit = AUDIOUNIT(dev);
        struct audio_softc *sc;
d774 3
a776 3
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;
d778 2
a779 2
        if (sc->sc_dying)
                return (EIO);
d795 1
a795 1
	
d797 1
a797 1
	        wakeup(&sc->sc_refcnt);
d807 2
a808 2
        int unit = AUDIOUNIT(dev);
        struct audio_softc *sc;
d811 3
a813 3
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return (-1);
d815 2
a816 2
        if (sc->sc_dying)
                return (-1);
d834 1
a834 1
	        wakeup(&sc->sc_refcnt);
d881 1
a881 1
				       sc->sc_rr.end - sc->sc_rr.start);
d899 5
a903 5
	    (double)sc->sc_pr.blksize * 100000 / 
	    (double)(sc->sc_pparams.precision / NBBY * 
                     sc->sc_pparams.channels * 
		     sc->sc_pparams.sample_rate)) * 10;
	DPRINTF(("audio: play blktime = %lu for %d\n", 
d907 5
a911 5
	    (double)sc->sc_rr.blksize * 100000 / 
	    (double)(sc->sc_rparams.precision / NBBY * 
                     sc->sc_rparams.channels * 
		     sc->sc_rparams.sample_rate)) * 10;
	DPRINTF(("audio: record blktime = %lu for %d\n", 
d942 2
a943 2
        DPRINTFN(3, ("audio_sleep_timo: chan=%p, label=%s, timo=%d\n", 
                    chan, label, timo));
d1051 1
a1051 1
	ai.play.encoding      = sc->sc_pparams.encoding;
d1061 1
a1061 1
	
d1110 2
a1111 2
        DPRINTF(("audio_drain: enter busy=%d used=%d\n", 
                 sc->sc_pbus, sc->sc_pr.used));
d1134 1
a1134 1
	/* 
d1157 1
a1157 1
		        error = EIO;
d1181 1
a1181 1
        /* Stop recording. */
d1183 1
a1183 1
		/* 
d1206 1
a1206 1
	
d1208 1
a1208 1
	
d1246 2
a1247 2
	DPRINTFN(1,("audio_read: cc=%d mode=%d\n", 
                    uio->uio_resid, sc->sc_mode));
d1262 1
a1262 1
				DPRINTF(("audio_read: stamp=%lu, wstamp=%lu\n", 
d1270 1
a1270 1
				        error = EIO;
d1283 1
a1283 1
		} 
d1303 1
a1303 1
			        error = EIO;
d1317 1
a1317 1
		
d1365 1
a1365 1
    	int bs;
d1377 1
a1377 1
	
d1386 1
a1386 1
	DPRINTF(("audio_calc_blksize: %s blksize=%d\n", 
d1393 2
a1394 2
        u_char *p;
        int n;
d1401 1
a1401 1
	    	auzero0 = 0x7f; 
d1461 1
a1461 1
        while (n > 0 && uio->uio_resid > 0 && !error) {
d1466 1
a1466 1
        return (error);
d1514 3
a1516 3
                     sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
                     sc->sc_pparams.precision, sc->sc_pparams.channels,
                     sc->sc_pparams.sw_code, sc->sc_pparams.factor));
d1522 1
a1522 1
			DPRINTFN(2, ("audio_write: sleep used=%d lowat=%d hiwat=%d\n", 
d1530 1
a1530 1
			        error = EIO;
d1540 1
a1540 1
		cc = cb->usedhigh - used; 	/* maximum to write */
d1550 1
a1550 1
			cc = uio->uio_resid; 	/* and no more than we have */
d1553 1
a1553 1
		/* 
d1555 1
a1555 1
		 * block pointers are always nicely aligned. 
d1559 1
a1559 1
			       sc->sc_pparams.sw_code, sc->sc_pparams.factor);
d1564 2
a1565 2
		DPRINTFN(1, ("audio_write: uiomove cc=%d inp=%p, left=%d\n", 
                             cc, inp, uio->uio_resid));
d1571 2
a1572 2
		        printf("audio_write:(1) uiomove failed %d; cc=%d inp=%p\n",
			       error, cc, inp);
d1574 1
a1574 1
		/* 
d1604 1
a1604 1
		    (inp  - cb->start) / cb->blksize == 
d1643 1
a1643 1
        int rbus, pbus;
d1646 1
a1646 1
	          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d1664 2
a1665 2
                rbus = sc->sc_rbus;
                pbus = sc->sc_pbus;
d1750 1
a1750 1
		
d1792 1
a1792 1
	          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
d1915 3
a1917 3
    
    	DPRINTF(("audiostartr: start=%p used=%d(hi=%d) mmapped=%d\n", 
		 sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh, 
d1925 1
a1925 1
		error = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, 
d1940 2
a1941 2
    
    	DPRINTF(("audiostartp: start=%p used=%d(hi=%d) mmapped=%d\n", 
d1944 1
a1944 1
    
d1957 1
a1957 1
	    	return error;
d1998 2
a1999 2
			DPRINTFN(5, ("audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\n", 
                                    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));
d2003 1
a2003 1
			
d2008 2
a2009 2
		DPRINTFN(5, ("audio_pint_silence: start fill %p %d\n", 
                             inp, cc));
d2032 2
a2033 2
        if (!sc->sc_open)
        	return;         /* ignore interrupt if not open */
d2044 2
a2045 2
		DPRINTFN(5, ("audio_pint: mmapped outp=%p cc=%d inp=%p\n", 
                             cb->outp, blksize, cb->inp));
d2051 1
a2051 1
		
d2062 2
a2063 2
				printf("audio: play interrupt(%d) off relative by %ld us (%lu)\n", 
				       sc->sc_pnintr, lastdelta, sc->sc_pblktime);
d2067 2
a2068 2
				printf("audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\n", 
				       sc->sc_pnintr, totdelta, sc->sc_pblktime);
d2120 1
a2120 1
                     sc->sc_mode, cb->pause, cb->used, cb->usedlow));
d2145 2
a2146 2
        if (!sc->sc_open)
        	return;         /* ignore interrupt if not open */
d2157 2
a2158 2
		DPRINTFN(2, ("audio_rint: mmapped inp=%p cc=%d\n", 
                             cb->inp, blksize));
d2175 2
a2176 2
				printf("audio: record interrupt(%d) off relative by %ld us (%lu)\n", 
				       sc->sc_rnintr, lastdelta, sc->sc_rblktime);
d2181 2
a2182 2
				printf("audio: record interrupt(%d) off absolute by %ld us (%lu)\n", 
				       sc->sc_rnintr, totdelta, sc->sc_rblktime);
d2205 2
a2206 2
	DPRINTFN(2, ("audio_rint: inp=%p cc=%d used=%d\n", 
                     cb->inp, blksize, cb->used));
d2422 1
a2422 1
					    au_get_lr_value(sc, &ct, 
d2498 1
a2498 1
			if (ports->aumask[i] & port) 
d2554 1
a2554 1
	
d2578 1
a2578 1
	}	
d2712 1
a2712 1
	
d2729 1
a2729 1
		
d2802 1
a2802 1
		if (!error && 
d2811 1
a2811 1
	
d2842 1
a2842 1
	
d2845 1
a2845 1
	
d2866 1
a2866 1
		
d2873 1
a2873 1
			ai->monitor_gain = 
d2974 1
a2974 1
	
d3002 1
a3002 1
                                    M_DEVBUF, M_WAITOK);
d3014 1
a3014 1
		
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.37 2002/02/06 14:25:09 fgsch Exp $	*/
d140 1
d206 12
d1796 19
d1823 1
a1823 1
	int s = splaudio();
d1830 3
a1832 4
		if ((sc->sc_mode & AUMODE_PLAY) ?
		    sc->sc_pr.stamp > sc->sc_wstamp : 
		    sc->sc_rr.used > sc->sc_rr.usedlow) {
			splx(s);
a1833 1
		}
d1838 3
a1840 3
		if (sc->sc_mode & AUMODE_RECORD ||
		    sc->sc_pr.used <= sc->sc_pr.usedlow) {
			splx(s);
a1841 1
		}
d2121 3
a2123 11
	if ((sc->sc_mode & AUMODE_PLAY) && !cb->pause) {
		if (cb->used <= cb->usedlow) {
			audio_wakeup(&sc->sc_wchan);
			selwakeup(&sc->sc_wsel);
			if (sc->sc_async_audio) {
				DPRINTFN(3, ("audio_pint: sending SIGIO %p\n", 
                                             sc->sc_async_audio));
				psignal(sc->sc_async_audio, SIGIO);
			}
		}
	}
d2126 2
a2127 6
	if (!sc->sc_full_duplex && sc->sc_rchan) {
		audio_wakeup(&sc->sc_rchan);
		selwakeup(&sc->sc_rsel);
		if (sc->sc_async_audio)
			psignal(sc->sc_async_audio, SIGIO);
	}
d2217 1
a2217 4
	audio_wakeup(&sc->sc_rchan);
	selwakeup(&sc->sc_rsel);
	if (sc->sc_async_audio)
		psignal(sc->sc_async_audio, SIGIO);
d3046 67
@


1.37
log
@correct monitor port matching.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.36 2002/02/04 20:42:25 fgsch Exp $	*/
d105 2
a106 2
int	audiosetinfo __P((struct audio_softc *, struct audio_info *));
int	audiogetinfo __P((struct audio_softc *, struct audio_info *));
d108 13
a120 13
int	audio_open __P((dev_t, struct audio_softc *, int, int, struct proc *));
int	audio_close __P((dev_t, int, int, struct proc *));
int	audio_read __P((dev_t, struct uio *, int));
int	audio_write __P((dev_t, struct uio *, int));
int	audio_ioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	audio_select __P((dev_t, int, struct proc *));
paddr_t	audio_mmap __P((dev_t, off_t, int));

int	mixer_open __P((dev_t, struct audio_softc *, int, int, struct proc *));
int	mixer_close __P((dev_t, int, int, struct proc *));
int	mixer_ioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
static	void mixer_remove __P((struct audio_softc *, struct proc *p));
static	void mixer_signal __P((struct audio_softc *));
d122 21
a142 21
void	audio_init_record __P((struct audio_softc *));
void	audio_init_play __P((struct audio_softc *));
int	audiostartr __P((struct audio_softc *));
int	audiostartp __P((struct audio_softc *));
void	audio_rint __P((void *));
void	audio_pint __P((void *));
int	audio_check_params __P((struct audio_params *));

void	audio_calc_blksize __P((struct audio_softc *, int));
void	audio_fill_silence __P((struct audio_params *, u_char *, int));
int	audio_silence_copyout __P((struct audio_softc *, int, struct uio *));

void	audio_init_ringbuffer __P((struct audio_ringbuffer *));
int	audio_initbufs __P((struct audio_softc *));
void	audio_calcwater __P((struct audio_softc *));
static __inline int audio_sleep_timo __P((int *, char *, int));
static __inline int audio_sleep __P((int *, char *));
static __inline void audio_wakeup __P((int *));
int	audio_drain __P((struct audio_softc *));
void	audio_clear __P((struct audio_softc *));
static __inline void audio_pint_silence __P((struct audio_softc *, struct audio_ringbuffer *, u_char *, int));
d144 2
a145 2
int	audio_alloc_ring __P((struct audio_softc *, struct audio_ringbuffer *, int, int));
void	audio_free_ring __P((struct audio_softc *, struct audio_ringbuffer *));
d147 1
a147 1
int	audioprint __P((void *, const char *));
d151 1
a151 1
int	audioprobe __P((struct device *, void *, void *));
d153 1
a153 1
int	audioprobe __P((struct device *, struct cfdata *, void *));
d155 3
a157 3
void	audioattach __P((struct device *, struct device *, void *));
int	audiodetach __P((struct device *, int));
int	audioactivate __P((struct device *, enum devact));
d175 1
a175 1
void	au_check_ports __P((struct audio_softc *, struct au_mixer_ports *, 
d177 13
a189 13
			    struct portname *));
int	au_set_gain __P((struct audio_softc *, struct au_mixer_ports *, 
			 int, int));
void	au_get_gain __P((struct audio_softc *, struct au_mixer_ports *,
			 u_int *, u_char *));
int	au_set_port __P((struct audio_softc *, struct au_mixer_ports *,
			 u_int));
int	au_get_port __P((struct audio_softc *, struct au_mixer_ports *));
int	au_get_lr_value __P((struct audio_softc *, mixer_ctrl_t *,
			     int *, int *r));
int	au_set_lr_value __P((struct audio_softc *, mixer_ctrl_t *,
			     int, int));
int	au_portof __P((struct audio_softc *, char *));
d511 2
a512 2
void	audio_printsc __P((struct audio_softc *));
void	audio_print_params __P((char *, struct audio_params *));
@


1.36
log
@if we have a monitor port, don't get it, set it.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.35 2002/01/20 19:56:53 ericj Exp $	*/
d320 1
a320 1
		    strcmp(mi.label.name, AudioNmonitor))
@


1.35
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.34 2002/01/10 18:49:07 mickey Exp $	*/
d2720 1
a2720 1
		error = sc->hw_if->get_port(sc->hw_hdl, &ct);
@


1.34
log
@return ENOTTY not EINVAL in default: in *ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.33 2002/01/09 17:59:37 mickey Exp $	*/
a553 2
	else if (hw->round_buffersize_old)
		bufsize = hw->round_buffersize_old(hdl, bufsize);
a557 2
	else if (hw->allocm_old)
		r->start = hw->allocm_old(hdl, r->bufsize, M_DEVBUF, M_WAITOK);
@


1.33
log
@make sure mixer was opened for write for AUDIO_MIXER_WRITE
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.32 2001/11/06 19:53:18 miod Exp $	*/
d1779 1
a1779 1
		error = EINVAL;
d3028 1
a3028 1
		error = EINVAL;
@


1.32
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.31 2001/11/01 12:13:46 art Exp $	*/
d3017 2
@


1.32.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.35 2002/01/20 19:56:53 ericj Exp $	*/
d554 2
d560 2
d1779 1
a1779 1
		error = ENOTTY;
a3016 2
		if (!(flag & FWRITE))
			return (EACCES);
d3026 1
a3026 1
		error = ENOTTY;
@


1.32.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.32.2.1 2002/01/31 22:55:29 niklas Exp $	*/
d105 2
a106 2
int	audiosetinfo(struct audio_softc *, struct audio_info *);
int	audiogetinfo(struct audio_softc *, struct audio_info *);
d108 13
a120 13
int	audio_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	audio_close(dev_t, int, int, struct proc *);
int	audio_read(dev_t, struct uio *, int);
int	audio_write(dev_t, struct uio *, int);
int	audio_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	audio_select(dev_t, int, struct proc *);
paddr_t	audio_mmap(dev_t, off_t, int);

int	mixer_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	mixer_close(dev_t, int, int, struct proc *);
int	mixer_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
static	void mixer_remove(struct audio_softc *, struct proc *p);
static	void mixer_signal(struct audio_softc *);
d122 21
a142 21
void	audio_init_record(struct audio_softc *);
void	audio_init_play(struct audio_softc *);
int	audiostartr(struct audio_softc *);
int	audiostartp(struct audio_softc *);
void	audio_rint(void *);
void	audio_pint(void *);
int	audio_check_params(struct audio_params *);

void	audio_calc_blksize(struct audio_softc *, int);
void	audio_fill_silence(struct audio_params *, u_char *, int);
int	audio_silence_copyout(struct audio_softc *, int, struct uio *);

void	audio_init_ringbuffer(struct audio_ringbuffer *);
int	audio_initbufs(struct audio_softc *);
void	audio_calcwater(struct audio_softc *);
static __inline int audio_sleep_timo(int *, char *, int);
static __inline int audio_sleep(int *, char *);
static __inline void audio_wakeup(int *);
int	audio_drain(struct audio_softc *);
void	audio_clear(struct audio_softc *);
static __inline void audio_pint_silence(struct audio_softc *, struct audio_ringbuffer *, u_char *, int);
d144 2
a145 2
int	audio_alloc_ring(struct audio_softc *, struct audio_ringbuffer *, int, int);
void	audio_free_ring(struct audio_softc *, struct audio_ringbuffer *);
d147 1
a147 1
int	audioprint(void *, const char *);
d151 1
a151 1
int	audioprobe(struct device *, void *, void *);
d153 1
a153 1
int	audioprobe(struct device *, struct cfdata *, void *);
d155 3
a157 3
void	audioattach(struct device *, struct device *, void *);
int	audiodetach(struct device *, int);
int	audioactivate(struct device *, enum devact);
d175 1
a175 1
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *, 
d177 13
a189 13
			    struct portname *);
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *, 
			 int, int);
void	au_get_gain(struct audio_softc *, struct au_mixer_ports *,
			 u_int *, u_char *);
int	au_set_port(struct audio_softc *, struct au_mixer_ports *,
			 u_int);
int	au_get_port(struct audio_softc *, struct au_mixer_ports *);
int	au_get_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int *, int *r);
int	au_set_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int, int);
int	au_portof(struct audio_softc *, char *);
d320 1
a320 1
		    strcmp(mi.label.name, AudioNmonitor) == 0)
d511 2
a512 2
void	audio_printsc(struct audio_softc *);
void	audio_print_params(char *, struct audio_params *);
d2720 1
a2720 1
		error = sc->hw_if->set_port(sc->hw_hdl, &ct);
@


1.32.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.32.2.2 2002/06/11 03:42:15 art Exp $	*/
d39 1
a39 1
 *
d60 1
a60 1
 * - Add softaudio() isr processing for wakeup, poll, signals,
d121 1
a121 1

a139 1
void	audio_selwakeup(struct audio_softc *sc, int play);
d160 2
a161 2
	char	*name;
	int	mask;
d175 1
a175 1
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *,
d178 1
a178 1
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *,
d193 1
a193 1
struct audio_params audio_default =
a204 12
void filt_audiowdetach(struct knote *kn);
int filt_audiowrite(struct knote *kn, long hint);

struct filterops audiowrite_filtops =
	{ 1, NULL, filt_audiowdetach, filt_audiowrite};

void filt_audiordetach(struct knote *kn);
int filt_audioread(struct knote *kn, long hint);

struct filterops audioread_filtops =
	{ 1, NULL, filt_audiordetach, filt_audioread};

d217 1
a217 1
	DPRINTF(("audioprobe: type=%d sa=%p hw=%p\n",
d255 1
a255 1
	}
d275 1
a275 1

d315 5
a319 5
		au_check_ports(sc, &sc->sc_inports,  &mi, iclass,
		    AudioNsource, AudioNrecord, itable);
		au_check_ports(sc, &sc->sc_outports, &mi, oclass,
		    AudioNoutput, AudioNmaster, otable);
		if (mi.mixer_class == oclass &&
d329 2
a330 2
	struct device *self;
	enum devact act;
d332 1
a332 1
	struct audio_softc *sc = (struct audio_softc *)self;
d334 10
a343 10
	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
d348 2
a349 2
	struct device *self;
	int flags;
d351 33
a383 3
	struct audio_softc *sc = (struct audio_softc *)self;
	int maj, mn;
	int s;
d385 1
a385 31
	DPRINTF(("audio_detach: sc=%p flags=%d\n", sc, flags));

	sc->sc_dying = 1;

	wakeup(&sc->sc_wchan);
	wakeup(&sc->sc_rchan);
	s = splaudio();
	if (--sc->sc_refcnt >= 0) {
		if (tsleep(&sc->sc_refcnt, PZERO, "auddet", hz * 120))
			printf("audiodetach: %s didn't detach\n",
			    sc->dev.dv_xname);
	}
	splx(s);

	/* free resources */
	audio_free_ring(sc, &sc->sc_pr);
	audio_free_ring(sc, &sc->sc_rr);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == audioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn | SOUND_DEVICE,    mn | SOUND_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIO_DEVICE,    mn | AUDIO_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIOCTL_DEVICE, mn | AUDIOCTL_DEVICE, VCHR);
	vdevgone(maj, mn | MIXER_DEVICE,    mn | MIXER_DEVICE, VCHR);

	return (0);
d395 1
a395 1
	for(mi.index = 0;
d428 1
a428 1
			    tbl[i].name) == 0) {
d431 1
a431 1
			ports->miport[ports->nports++] =
d443 1
a443 1
			    tbl[i].name) == 0) {
d446 1
a446 1
			ports->miport[ports->nports++] =
d469 1
a469 1
		printf ("audio_attach_mi: NULL\n");
d488 1
a488 1

d533 1
a533 1
	    p->sample_rate, p->encoding, p->channels, p->precision);
d556 1
a556 1
		r->start = hw->allocm(hdl, direction, r->bufsize, M_DEVBUF,
d587 1
a587 1
	if (unit >= audio_cd.cd_ndevs ||
d592 1
a592 1
		return (EIO);
d605 1
a605 1
		error = mixer_open(dev, sc, flags, ifmt, p);
d613 1
a613 1
		wakeup(&sc->sc_refcnt);
d648 3
a650 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d652 2
a653 2
	if (sc->sc_dying)
		return (EIO);
d669 1
a669 1

d671 1
a671 1
		wakeup(&sc->sc_refcnt);
d686 1
a686 1
	    (sc = audio_cd.cd_devs[unit]) == NULL)
d689 2
a690 2
	if (sc->sc_dying)
		return (EIO);
d696 1
a696 1
		error = audio_write(dev, uio, ioflag);
d706 1
a706 1

d708 1
a708 1
		wakeup(&sc->sc_refcnt);
d724 3
a726 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d728 2
a729 2
	if (sc->sc_dying)
		return (EIO);
d745 1
a745 1

d747 1
a747 1
		wakeup(&sc->sc_refcnt);
d757 2
a758 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d761 3
a763 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d765 2
a766 2
	if (sc->sc_dying)
		return (EIO);
d782 1
a782 1

d784 1
a784 1
		wakeup(&sc->sc_refcnt);
d794 2
a795 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d798 3
a800 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return (-1);
d802 2
a803 2
	if (sc->sc_dying)
		return (-1);
d821 1
a821 1
		wakeup(&sc->sc_refcnt);
d868 1
a868 1
		    sc->sc_rr.end - sc->sc_rr.start);
d886 5
a890 5
	    (double)sc->sc_pr.blksize * 100000 /
	    (double)(sc->sc_pparams.precision / NBBY *
		sc->sc_pparams.channels *
		sc->sc_pparams.sample_rate)) * 10;
	DPRINTF(("audio: play blktime = %lu for %d\n",
d894 5
a898 5
	    (double)sc->sc_rr.blksize * 100000 /
	    (double)(sc->sc_rparams.precision / NBBY *
		sc->sc_rparams.channels *
		sc->sc_rparams.sample_rate)) * 10;
	DPRINTF(("audio: record blktime = %lu for %d\n",
d929 2
a930 2
	DPRINTFN(3, ("audio_sleep_timo: chan=%p, label=%s, timo=%d\n",
	    chan, label, timo));
d1038 1
a1038 1
	ai.play.encoding       = sc->sc_pparams.encoding;
d1048 1
a1048 1

d1097 2
a1098 2
	DPRINTF(("audio_drain: enter busy=%d used=%d\n",
	    sc->sc_pbus, sc->sc_pr.used));
d1121 1
a1121 1
	/*
d1144 1
a1144 1
			error = EIO;
d1168 1
a1168 1
	/* Stop recording. */
d1170 1
a1170 1
		/*
d1193 1
a1193 1

d1195 1
a1195 1

d1233 2
a1234 2
	DPRINTFN(1,("audio_read: cc=%d mode=%d\n",
	    uio->uio_resid, sc->sc_mode));
d1249 1
a1249 1
				DPRINTF(("audio_read: stamp=%lu, wstamp=%lu\n",
d1257 1
a1257 1
					error = EIO;
d1270 1
a1270 1
		}
d1290 1
a1290 1
				error = EIO;
d1304 1
a1304 1

d1352 1
a1352 1
	int bs;
d1364 1
a1364 1

d1373 1
a1373 1
	DPRINTF(("audio_calc_blksize: %s blksize=%d\n",
d1380 2
a1381 2
	u_char *p;
	int n;
d1388 1
a1388 1
		auzero0 = 0x7f;
d1448 1
a1448 1
	while (n > 0 && uio->uio_resid > 0 && !error) {
d1453 1
a1453 1
	return (error);
d1501 3
a1503 3
	    sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
	    sc->sc_pparams.precision, sc->sc_pparams.channels,
	    sc->sc_pparams.sw_code, sc->sc_pparams.factor));
d1509 1
a1509 1
			DPRINTFN(2, ("audio_write: sleep used=%d lowat=%d hiwat=%d\n",
d1517 1
a1517 1
				error = EIO;
d1527 1
a1527 1
		cc = cb->usedhigh - used;	/* maximum to write */
d1537 1
a1537 1
			cc = uio->uio_resid;	/* and no more than we have */
d1540 1
a1540 1
		/*
d1542 1
a1542 1
		 * block pointers are always nicely aligned.
d1546 1
a1546 1
			    sc->sc_pparams.sw_code, sc->sc_pparams.factor);
d1551 2
a1552 2
		DPRINTFN(1, ("audio_write: uiomove cc=%d inp=%p, left=%d\n",
		    cc, inp, uio->uio_resid));
d1558 2
a1559 2
			printf("audio_write:(1) uiomove failed %d; cc=%d inp=%p\n",
			    error, cc, inp);
d1561 1
a1561 1
		/*
d1591 1
a1591 1
		    (inp  - cb->start) / cb->blksize ==
d1630 1
a1630 1
	int rbus, pbus;
d1633 1
a1633 1
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d1651 2
a1652 2
		rbus = sc->sc_rbus;
		pbus = sc->sc_pbus;
d1737 1
a1737 1

d1779 1
a1779 1
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
a1782 19
void
audio_selwakeup(struct audio_softc *sc, int play)
{
	struct selinfo *si;

	si = play? &sc->sc_wsel : &sc->sc_rsel;

	audio_wakeup(play? &sc->sc_wchan : &sc->sc_rchan);
	selwakeup(si);
	if (sc->sc_async_audio)
		psignal(sc->sc_async_audio, SIGIO);
	KNOTE(&si->si_note, 0);
}

#define	AUDIO_FILTREAD(sc) ((sc->sc_mode & AUMODE_PLAY) ? \
    sc->sc_pr.stamp > sc->sc_wstamp : sc->sc_rr.used > sc->sc_rr.usedlow)
#define	AUDIO_FILTWRITE(sc) \
    (sc->sc_mode & AUMODE_RECORD || sc->sc_pr.used <= sc->sc_pr.usedlow)

d1791 1
a1791 1
	int rv, s = splaudio();
d1798 4
a1801 3
		rv = AUDIO_FILTREAD(sc);
		splx(s);
		if (rv)
d1803 1
d1808 3
a1810 3
		rv = AUDIO_FILTWRITE(sc);
		splx(s);
		if (rv)
d1812 1
d1886 3
a1888 3

	DPRINTF(("audiostartr: start=%p used=%d(hi=%d) mmapped=%d\n",
		 sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh,
d1896 1
a1896 1
		error = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start,
d1911 2
a1912 2

	DPRINTF(("audiostartp: start=%p used=%d(hi=%d) mmapped=%d\n",
d1915 1
a1915 1

d1928 1
a1928 1
		return error;
d1969 2
a1970 2
			DPRINTFN(5, ("audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\n",
			    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));
d1974 1
a1974 1

d1979 2
a1980 2
		DPRINTFN(5, ("audio_pint_silence: start fill %p %d\n",
		    inp, cc));
d2003 2
a2004 2
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */
d2015 2
a2016 2
		DPRINTFN(5, ("audio_pint: mmapped outp=%p cc=%d inp=%p\n",
		    cb->outp, blksize, cb->inp));
d2022 1
a2022 1

d2033 2
a2034 2
				printf("audio: play interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_pnintr, lastdelta, sc->sc_pblktime);
d2038 2
a2039 2
				printf("audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\n",
				    sc->sc_pnintr, totdelta, sc->sc_pblktime);
d2091 12
a2102 4
	    sc->sc_mode, cb->pause, cb->used, cb->usedlow));
	if ((sc->sc_mode & AUMODE_PLAY) && !cb->pause &&
	    cb->used <= cb->usedlow)
		audio_selwakeup(sc, 1);
d2105 6
a2110 2
	if (!sc->sc_full_duplex && sc->sc_rchan)
		audio_selwakeup(sc, 0);
d2128 2
a2129 2
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */
d2140 2
a2141 2
		DPRINTFN(2, ("audio_rint: mmapped inp=%p cc=%d\n",
		    cb->inp, blksize));
d2158 2
a2159 2
				printf("audio: record interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_rnintr, lastdelta, sc->sc_rblktime);
d2164 2
a2165 2
				printf("audio: record interrupt(%d) off absolute by %ld us (%lu)\n",
				    sc->sc_rnintr, totdelta, sc->sc_rblktime);
d2188 2
a2189 2
	DPRINTFN(2, ("audio_rint: inp=%p cc=%d used=%d\n",
	    cb->inp, blksize, cb->used));
d2200 4
a2203 1
	audio_selwakeup(sc, 0);
d2408 1
a2408 1
					    au_get_lr_value(sc, &ct,
d2484 1
a2484 1
			if (ports->aumask[i] & port)
d2540 1
a2540 1

d2564 1
a2564 1
	}
d2698 1
a2698 1

d2715 1
a2715 1

d2788 1
a2788 1
		if (!error &&
d2797 1
a2797 1

d2828 1
a2828 1

d2831 1
a2831 1

d2852 1
a2852 1

d2859 1
a2859 1
			ai->monitor_gain =
d2960 1
a2960 1

d2988 1
a2988 1
			    M_DEVBUF, M_WAITOK);
d3000 1
a3000 1

a3031 67

int
audiokqfilter(dev, kn)
	dev_t	dev;
	struct knote *kn;
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_rsel.si_note;
		kn->kn_fop = &audioread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &sc->sc_wsel.si_note;
		kn->kn_fop = &audiowrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)sc;

	s = splaudio();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_audiordetach(struct knote *kn)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
	int s = splaudio();

	SLIST_REMOVE(&sc->sc_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_audioread(struct knote *kn, long hint)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;

	return AUDIO_FILTREAD(sc);
}

void
filt_audiowdetach(struct knote *kn)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
	int s = splaudio();

	SLIST_REMOVE(&sc->sc_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_audiowrite(struct knote *kn, long hint)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;

	return AUDIO_FILTWRITE(sc);
}
@


1.32.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d927 1
a927 1
	sc->sc_rr.usedhigh = sc->sc_rr.end - sc->sc_rr.start - sc->sc_rr.blksize;
@


1.31
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.30 2001/10/31 11:00:24 art Exp $	*/
d88 1
a88 1
#include <vm/vm.h>
@


1.30
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.29 2001/09/20 17:02:31 mpech Exp $	*/
d792 1
a792 1
int
d795 2
a796 1
	int off, prot;
@


1.29
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.28 2001/08/11 22:49:19 art Exp $	*/
d114 1
a114 1
int	audio_mmap __P((dev_t, int, int));
d799 1
a799 1
	int error;
d812 1
a812 1
		error = audio_mmap(dev, off, prot);
d816 1
a816 1
		error = -1;
d819 1
a819 1
		error = -1;
d825 1
a825 1
	return (error);
d1823 1
a1823 1
int
d1826 2
a1827 1
	int off, prot;
@


1.28
log
@no need to include vm_prot.h here.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.27 2001/07/27 15:26:16 art Exp $	*/
d1607 1
a1607 1
				/* Report the first error that occured. */
@


1.27
log
@Correct return values from audiommap.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.26 2001/07/03 07:41:53 hugh Exp $	*/
a88 1
#include <vm/vm_prot.h>
@


1.26
log
@Make the audio device play nice with revoke(2) by having it reset
both directions if neither read nor write flags are set on close.
Cleared by niklas and with some analysis by bjc.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.25 2001/01/28 09:45:26 aaron Exp $	*/
d804 1
a804 1
                return ENXIO;
d807 1
a807 1
                return (EIO);
@


1.25
log
@Add a field to mixer_devinto_t that indicates the minimum delta to change
mixer value. A value of 0 indicates that the driver doesn't supply a delta.
The change is backwards compatible. From NetBSD (needed for uaudio(4) update).
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.24 2000/11/09 21:31:33 mickey Exp $	*/
d1169 1
a1169 1
	DPRINTF(("audio_close: unit=%d\n", unit));
d1200 6
a1205 1
	if (flags & FREAD) {
d1209 1
a1209 1
	if (flags & FWRITE) {
@


1.24
log
@cast pointer to a long for alpha's sake; pointed out by ericj@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.23 2000/07/19 09:04:37 csapuntz Exp $	*/
d3001 1
@


1.23
log
@

As in NetBSD, added direction to allocm/round_buffer_size APIs.
Accomplished by adding functions to audio_hw_if instead of redoing
current ones so as to minimize need to change drivers.

For Neomagic, tell the AC97 subsystem that we don't support reads.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.22 2000/05/24 13:44:17 ho Exp $	*/
d2006 1
a2006 1
	add_audio_randomness(cb);
d2129 1
a2129 1
	add_audio_randomness(cb);
@


1.22
log
@Permit detach of audio devices, such as uaudio. Selected code
from NetBSD/Lennart Augustsson. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.21 2000/04/10 19:49:14 mickey Exp $	*/
d145 1
a145 1
int	audio_alloc_ring __P((struct audio_softc *, struct audio_ringbuffer *, int));
d263 1
a263 1
	error = audio_alloc_ring(sc, &sc->sc_pr, AU_RING_SIZE);
d269 1
a269 1
	error = audio_alloc_ring(sc, &sc->sc_rr, AU_RING_SIZE);
d314 2
d539 1
a539 1
audio_alloc_ring(sc, r, bufsize)
d542 1
a549 1
	ROUNDSIZE(bufsize);
d552 1
d554 3
a556 1
		bufsize = hw->round_buffersize(hdl, bufsize);
d559 4
a562 1
	    r->start = hw->allocm(hdl, r->bufsize, M_DEVBUF, M_WAITOK);
d564 1
a564 1
	    r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);
d576 1
a576 1
	    sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);
d578 1
a578 1
	    free(r->start, M_DEVBUF);
@


1.21
log
@make .mpg playing more usefull, i.e. supply entropy
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.20 2000/01/03 19:38:12 fgsch Exp $	*/
d109 1
a109 1
int	audio_open __P((dev_t, int, int, struct proc *));
d117 1
a117 1
int	mixer_open __P((dev_t, int, int, struct proc *));
d157 2
d198 2
a199 1
	sizeof(struct audio_softc), audioprobe, audioattach
d327 61
d458 1
a458 1
void
d466 4
a469 5
	if (ahwp != NULL) {
		arg.type = AUDIODEV_TYPE_AUDIO;
		arg.hwif = ahwp;
		arg.hdl = hdlp;
		(void)config_found(dev, &arg, audioprint);
d471 6
d580 13
d594 1
d599 2
a600 1
		return (audio_open(dev, flags, ifmt, p));
d602 2
a603 1
		return (mixer_open(dev, flags, ifmt, p));
d605 2
a606 1
		return (ENXIO);
d608 5
d641 3
d645 8
d656 2
a657 1
		return (audio_read(dev, uio, ioflag));
d660 2
a661 1
		return (ENODEV);
d663 2
a664 1
		return (ENXIO);
d666 4
d678 7
d686 4
d693 2
a694 1
		return (audio_write(dev, uio, ioflag));
d697 2
a698 1
		return (ENODEV);
d700 2
a701 1
		return (ENXIO);
d703 4
d717 3
d721 8
d733 2
a734 1
		return (audio_ioctl(dev, cmd, addr, flag, p));
d736 2
a737 1
		return (mixer_ioctl(dev, cmd, addr, flag, p));
d739 2
a740 1
		return (ENXIO);
d742 4
d754 10
d765 1
d769 2
a770 1
		return (audio_select(dev, events, p));
d773 2
a774 1
		return (0);
d776 2
a777 1
		return (0);
d779 4
d790 10
d801 1
d805 2
a806 1
		return (audio_mmap(dev, off, prot));
d809 2
a810 1
		return -1;
d812 2
a813 1
		return -1;
d815 4
d958 1
a958 1
audio_open(dev, flags, ifmt, p)
d960 1
a963 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
a965 1
	struct audio_hw_if *hw;
a967 8
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	hw = sc->hw_if;
	if (!hw)
		return ENXIO;

d976 1
a976 1
	error = hw->open(sc->hw_hdl, flags);
d993 1
a993 1
		(hw->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);
d1048 1
a1048 1
	hw->close(sc->hw_hdl);
d1139 2
d1247 2
d1280 2
d1507 2
d2892 1
a2892 1
mixer_open(dev, flags, ifmt, p)
d2894 1
a2897 10
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;

	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	if (!sc->hw_if)
		return (ENXIO);

@


1.20
log
@Remove dependencies between midi & audio. midi now will compile on
speaker only systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.19 1999/12/05 18:35:33 espie Exp $	*/
d86 2
d1819 2
d1941 2
@


1.20.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.25 2001/01/28 09:45:26 aaron Exp $	*/
a85 2
#include <dev/rndvar.h>

d107 1
a107 1
int	audio_open __P((dev_t, struct audio_softc *, int, int, struct proc *));
d115 1
a115 1
int	mixer_open __P((dev_t, struct audio_softc *, int, int, struct proc *));
d143 1
a143 1
int	audio_alloc_ring __P((struct audio_softc *, struct audio_ringbuffer *, int, int));
a154 2
int	audiodetach __P((struct device *, int));
int	audioactivate __P((struct device *, enum devact));
d194 1
a194 2
	sizeof(struct audio_softc), audioprobe, audioattach,
	audiodetach, audioactivate
d258 1
a258 1
	error = audio_alloc_ring(sc, &sc->sc_pr, AUMODE_PLAY, AU_RING_SIZE);
d264 1
a264 1
	error = audio_alloc_ring(sc, &sc->sc_rr, AUMODE_RECORD, AU_RING_SIZE);
a308 2
		if (mi.type == AUDIO_MIXER_CLASS)
			continue;
a321 61
audioactivate(self, act)
        struct device *self;
        enum devact act;
{
        struct audio_softc *sc = (struct audio_softc *)self;

        switch (act) {
        case DVACT_ACTIVATE:
                return (EOPNOTSUPP);
                break;

        case DVACT_DEACTIVATE:
                sc->sc_dying = 1;
                break;
        }
        return (0);
}

int
audiodetach(self, flags)
        struct device *self;
        int flags;
{
        struct audio_softc *sc = (struct audio_softc *)self;
        int maj, mn;
        int s;

        DPRINTF(("audio_detach: sc=%p flags=%d\n", sc, flags));

        sc->sc_dying = 1;

        wakeup(&sc->sc_wchan);
        wakeup(&sc->sc_rchan);
        s = splaudio();
        if (--sc->sc_refcnt >= 0) {
                if (tsleep(&sc->sc_refcnt, PZERO, "auddet", hz * 120))
                        printf("audiodetach: %s didn't detach\n",
                               sc->dev.dv_xname);
        }
        splx(s);

        /* free resources */
        audio_free_ring(sc, &sc->sc_pr);
        audio_free_ring(sc, &sc->sc_rr);

        /* locate the major number */
        for (maj = 0; maj < nchrdev; maj++)
                if (cdevsw[maj].d_open == audioopen)
                        break;

        /* Nuke the vnodes for any open instances (calls close). */
        mn = self->dv_unit;
        vdevgone(maj, mn | SOUND_DEVICE,    mn | SOUND_DEVICE, VCHR);
        vdevgone(maj, mn | AUDIO_DEVICE,    mn | AUDIO_DEVICE, VCHR);
        vdevgone(maj, mn | AUDIOCTL_DEVICE, mn | AUDIOCTL_DEVICE, VCHR);
        vdevgone(maj, mn | MIXER_DEVICE,    mn | MIXER_DEVICE, VCHR);

        return (0);
}

int
d392 1
a392 1
struct device *
d400 5
a404 4
#ifdef DIAGNOSTIC
	if (ahwp == NULL) {
	        printf ("audio_attach_mi: NULL\n");
		return 0;
a405 6
#endif

	arg.type = AUDIODEV_TYPE_AUDIO;
	arg.hwif = ahwp;
	arg.hdl = hdlp;
	return config_found(dev, &arg, audioprint);
d466 1
a466 1
audio_alloc_ring(sc, r, direction, bufsize)
a468 1
	int direction;
d476 1
a478 1
	ROUNDSIZE(bufsize);
d480 1
a480 3
		bufsize = hw->round_buffersize(hdl, direction, bufsize);
	else if (hw->round_buffersize_old)
		bufsize = hw->round_buffersize_old(hdl, bufsize);
d483 1
a483 4
		r->start = hw->allocm(hdl, direction, r->bufsize, M_DEVBUF, 
		    M_WAITOK);
	else if (hw->allocm_old)
		r->start = hw->allocm_old(hdl, r->bufsize, M_DEVBUF, M_WAITOK);
d485 1
a485 1
		r->start = malloc(bufsize, M_DEVBUF, M_WAITOK);
d497 1
a497 1
		sc->hw_if->freem(sc->hw_hdl, r->start, M_DEVBUF);
d499 1
a499 1
		free(r->start, M_DEVBUF);
a508 13
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;

        if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	if (sc->sc_dying)
	        return (EIO);

	if (!sc->hw_if)
		return (ENXIO);
a509 1
	sc->sc_refcnt ++;
d514 1
a514 2
		error = audio_open(dev, sc, flags, ifmt, p);
		break;
d516 1
a516 2
	        error = mixer_open(dev, sc, flags, ifmt, p);
		break;
d518 1
a518 2
		error = ENXIO;
		break;
a519 5

	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);

	return (error);
a547 3
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;
a548 8
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;

        if (sc->sc_dying)
                return (EIO);

	sc->sc_refcnt ++;
d552 1
a552 2
		error = audio_read(dev, uio, ioflag);
		break;
d555 1
a555 2
		error = ENODEV;
		break;
d557 1
a557 2
		error = ENXIO;
		break;
a558 4
	
	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);
	return (error);
a566 3
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;
a567 8
	if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;

        if (sc->sc_dying)
	  	return (EIO);

	sc->sc_refcnt ++;
d571 1
a571 2
	  	error = audio_write(dev, uio, ioflag);
		break;
d574 1
a574 2
		error = ENODEV;
		break;
d576 1
a576 2
		error = ENXIO;
		break;
a577 4
	
	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);
	return (error);
a587 10
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
	int error;

        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;

        if (sc->sc_dying)
                return (EIO);
a588 1
	sc->sc_refcnt ++;
d593 1
a593 2
		error = audio_ioctl(dev, cmd, addr, flag, p);
		break;
d595 1
a595 2
		error = mixer_ioctl(dev, cmd, addr, flag, p);
		break;
d597 1
a597 2
		error = ENXIO;
		break;
a598 4
	
	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);
	return (error);
a606 3
        int unit = AUDIOUNIT(dev);
        struct audio_softc *sc;
	int error;
a607 8
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;

        if (sc->sc_dying)
                return (EIO);

	sc->sc_refcnt ++;
d611 1
a611 2
		error = audio_select(dev, events, p);
		break;
d614 1
a614 2
		error = 0;
		break;
d616 1
a616 2
		error = 0;
		break;
a617 4
	
	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);
	return (error);
a624 3
        int unit = AUDIOUNIT(dev);
        struct audio_softc *sc;
	int error;
a625 8
        if (unit >= audio_cd.cd_ndevs ||
            (sc = audio_cd.cd_devs[unit]) == NULL)
                return ENXIO;

        if (sc->sc_dying)
                return (EIO);

	sc->sc_refcnt ++;
d629 1
a629 2
		error = audio_mmap(dev, off, prot);
		break;
d632 1
a632 2
		error = -1;
		break;
d634 1
a634 2
		error = -1;
		break;
a635 4

	if (--sc->sc_refcnt < 0)
	        wakeup(&sc->sc_refcnt);
	return (error);
d775 1
a775 1
audio_open(dev, sc, flags, ifmt, p)
a776 1
	struct audio_softc *sc;
d780 2
d784 1
d787 8
d803 1
a803 1
	error = sc->hw_if->open(sc->hw_hdl, flags);
d820 1
a820 1
		(sc->hw_if->get_props(sc->hw_hdl) & AUDIO_PROP_FULLDUPLEX);
d875 1
a875 1
	sc->hw_if->close(sc->hw_hdl);
a965 2
		if (sc->sc_dying)
		        error = EIO;
a1071 2
				if (sc->sc_dying)
				        error = EIO;
a1102 2
			if (sc->sc_dying)
			        error = EIO;
a1327 2
			if (sc->sc_dying)
			        error = EIO;
a1816 2
	add_audio_randomness((long)cb);

a1937 2
	add_audio_randomness((long)cb);

d2707 1
a2707 1
mixer_open(dev, sc, flags, ifmt, p)
a2708 1
	struct audio_softc *sc;
d2712 10
a2816 1
		((mixer_devinfo_t *)addr)->un.v.delta = 0; /* default */
@


1.20.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.20.2.1 2001/05/14 22:23:00 niklas Exp $	*/
d89 1
d804 1
a804 1
                return (-1);
d807 1
a807 1
                return (-1);
d1169 1
a1169 1
	DPRINTF(("audio_close: unit=%d flags=0x%x\n", unit, flags));
d1200 1
a1200 6
	/*
	 * If flags has neither read nor write then reset both
	 * directions. Encountered when someone runs revoke(2).
	 */

	if ((flags & FREAD) || ((flags & (FREAD|FWRITE)) == 0)) {
d1204 1
a1204 1
	if ((flags & FWRITE) || ((flags & (FREAD|FWRITE)) == 0)) {
d1603 1
a1603 1
				/* Report the first error that occurred. */
@


1.20.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
#include <uvm/uvm_extern.h>
d114 1
a114 1
paddr_t	audio_mmap __P((dev_t, off_t, int));
d792 1
a792 1
paddr_t
d795 1
a795 2
	off_t off;
	int prot;
d799 1
a799 1
	int ret;
d812 1
a812 1
		ret = audio_mmap(dev, off, prot);
d816 1
a816 1
		ret = -1;
d819 1
a819 1
		ret = -1;
d825 1
a825 1
	return (ret);
d1823 1
a1823 1
paddr_t
d1826 1
a1826 2
	off_t off;
	int prot;
@


1.20.2.4
log
@Merge in trunk
@
text
@d320 1
a320 1
		    strcmp(mi.label.name, AudioNmonitor) == 0)
d554 2
d560 2
d1779 1
a1779 1
		error = ENOTTY;
d2724 1
a2724 1
		error = sc->hw_if->set_port(sc->hw_hdl, &ct);
a3016 2
		if (!(flag & FWRITE))
			return (EACCES);
d3026 1
a3026 1
		error = ENOTTY;
@


1.20.2.5
log
@Merge in -current from about a week ago
@
text
@d105 2
a106 2
int	audiosetinfo(struct audio_softc *, struct audio_info *);
int	audiogetinfo(struct audio_softc *, struct audio_info *);
d108 13
a120 13
int	audio_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	audio_close(dev_t, int, int, struct proc *);
int	audio_read(dev_t, struct uio *, int);
int	audio_write(dev_t, struct uio *, int);
int	audio_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	audio_select(dev_t, int, struct proc *);
paddr_t	audio_mmap(dev_t, off_t, int);

int	mixer_open(dev_t, struct audio_softc *, int, int, struct proc *);
int	mixer_close(dev_t, int, int, struct proc *);
int	mixer_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
static	void mixer_remove(struct audio_softc *, struct proc *p);
static	void mixer_signal(struct audio_softc *);
d122 21
a142 21
void	audio_init_record(struct audio_softc *);
void	audio_init_play(struct audio_softc *);
int	audiostartr(struct audio_softc *);
int	audiostartp(struct audio_softc *);
void	audio_rint(void *);
void	audio_pint(void *);
int	audio_check_params(struct audio_params *);

void	audio_calc_blksize(struct audio_softc *, int);
void	audio_fill_silence(struct audio_params *, u_char *, int);
int	audio_silence_copyout(struct audio_softc *, int, struct uio *);

void	audio_init_ringbuffer(struct audio_ringbuffer *);
int	audio_initbufs(struct audio_softc *);
void	audio_calcwater(struct audio_softc *);
static __inline int audio_sleep_timo(int *, char *, int);
static __inline int audio_sleep(int *, char *);
static __inline void audio_wakeup(int *);
int	audio_drain(struct audio_softc *);
void	audio_clear(struct audio_softc *);
static __inline void audio_pint_silence(struct audio_softc *, struct audio_ringbuffer *, u_char *, int);
d144 2
a145 2
int	audio_alloc_ring(struct audio_softc *, struct audio_ringbuffer *, int, int);
void	audio_free_ring(struct audio_softc *, struct audio_ringbuffer *);
d147 1
a147 1
int	audioprint(void *, const char *);
d151 1
a151 1
int	audioprobe(struct device *, void *, void *);
d153 1
a153 1
int	audioprobe(struct device *, struct cfdata *, void *);
d155 3
a157 3
void	audioattach(struct device *, struct device *, void *);
int	audiodetach(struct device *, int);
int	audioactivate(struct device *, enum devact);
d175 1
a175 1
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *, 
d177 13
a189 13
			    struct portname *);
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *, 
			 int, int);
void	au_get_gain(struct audio_softc *, struct au_mixer_ports *,
			 u_int *, u_char *);
int	au_set_port(struct audio_softc *, struct au_mixer_ports *,
			 u_int);
int	au_get_port(struct audio_softc *, struct au_mixer_ports *);
int	au_get_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int *, int *r);
int	au_set_lr_value(struct audio_softc *, mixer_ctrl_t *,
			     int, int);
int	au_portof(struct audio_softc *, char *);
d511 2
a512 2
void	audio_printsc(struct audio_softc *);
void	audio_print_params(char *, struct audio_params *);
@


1.20.2.6
log
@Sync the SMP branch with 3.3
@
text
@d39 1
a39 1
 *
d60 1
a60 1
 * - Add softaudio() isr processing for wakeup, poll, signals,
d121 1
a121 1

a139 1
void	audio_selwakeup(struct audio_softc *sc, int play);
d160 2
a161 2
	char	*name;
	int	mask;
d175 1
a175 1
void	au_check_ports(struct audio_softc *, struct au_mixer_ports *,
d178 1
a178 1
int	au_set_gain(struct audio_softc *, struct au_mixer_ports *,
d193 1
a193 1
struct audio_params audio_default =
a204 12
void filt_audiowdetach(struct knote *kn);
int filt_audiowrite(struct knote *kn, long hint);

struct filterops audiowrite_filtops =
	{ 1, NULL, filt_audiowdetach, filt_audiowrite};

void filt_audiordetach(struct knote *kn);
int filt_audioread(struct knote *kn, long hint);

struct filterops audioread_filtops =
	{ 1, NULL, filt_audiordetach, filt_audioread};

d217 1
a217 1
	DPRINTF(("audioprobe: type=%d sa=%p hw=%p\n",
d255 1
a255 1
	}
d275 1
a275 1

d315 5
a319 5
		au_check_ports(sc, &sc->sc_inports,  &mi, iclass,
		    AudioNsource, AudioNrecord, itable);
		au_check_ports(sc, &sc->sc_outports, &mi, oclass,
		    AudioNoutput, AudioNmaster, otable);
		if (mi.mixer_class == oclass &&
d329 2
a330 2
	struct device *self;
	enum devact act;
d332 1
a332 1
	struct audio_softc *sc = (struct audio_softc *)self;
d334 10
a343 10
	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
d348 2
a349 2
	struct device *self;
	int flags;
d351 33
a383 3
	struct audio_softc *sc = (struct audio_softc *)self;
	int maj, mn;
	int s;
d385 1
a385 31
	DPRINTF(("audio_detach: sc=%p flags=%d\n", sc, flags));

	sc->sc_dying = 1;

	wakeup(&sc->sc_wchan);
	wakeup(&sc->sc_rchan);
	s = splaudio();
	if (--sc->sc_refcnt >= 0) {
		if (tsleep(&sc->sc_refcnt, PZERO, "auddet", hz * 120))
			printf("audiodetach: %s didn't detach\n",
			    sc->dev.dv_xname);
	}
	splx(s);

	/* free resources */
	audio_free_ring(sc, &sc->sc_pr);
	audio_free_ring(sc, &sc->sc_rr);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == audioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn | SOUND_DEVICE,    mn | SOUND_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIO_DEVICE,    mn | AUDIO_DEVICE, VCHR);
	vdevgone(maj, mn | AUDIOCTL_DEVICE, mn | AUDIOCTL_DEVICE, VCHR);
	vdevgone(maj, mn | MIXER_DEVICE,    mn | MIXER_DEVICE, VCHR);

	return (0);
d395 1
a395 1
	for(mi.index = 0;
d428 1
a428 1
			    tbl[i].name) == 0) {
d431 1
a431 1
			ports->miport[ports->nports++] =
d443 1
a443 1
			    tbl[i].name) == 0) {
d446 1
a446 1
			ports->miport[ports->nports++] =
d469 1
a469 1
		printf ("audio_attach_mi: NULL\n");
d488 1
a488 1

d533 1
a533 1
	    p->sample_rate, p->encoding, p->channels, p->precision);
d556 1
a556 1
		r->start = hw->allocm(hdl, direction, r->bufsize, M_DEVBUF,
d587 1
a587 1
	if (unit >= audio_cd.cd_ndevs ||
d592 1
a592 1
		return (EIO);
d605 1
a605 1
		error = mixer_open(dev, sc, flags, ifmt, p);
d613 1
a613 1
		wakeup(&sc->sc_refcnt);
d648 3
a650 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d652 2
a653 2
	if (sc->sc_dying)
		return (EIO);
d669 1
a669 1

d671 1
a671 1
		wakeup(&sc->sc_refcnt);
d686 1
a686 1
	    (sc = audio_cd.cd_devs[unit]) == NULL)
d689 2
a690 2
	if (sc->sc_dying)
		return (EIO);
d696 1
a696 1
		error = audio_write(dev, uio, ioflag);
d706 1
a706 1

d708 1
a708 1
		wakeup(&sc->sc_refcnt);
d724 3
a726 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d728 2
a729 2
	if (sc->sc_dying)
		return (EIO);
d745 1
a745 1

d747 1
a747 1
		wakeup(&sc->sc_refcnt);
d757 2
a758 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d761 3
a763 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return ENXIO;
d765 2
a766 2
	if (sc->sc_dying)
		return (EIO);
d782 1
a782 1

d784 1
a784 1
		wakeup(&sc->sc_refcnt);
d794 2
a795 2
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc;
d798 3
a800 3
	if (unit >= audio_cd.cd_ndevs ||
	    (sc = audio_cd.cd_devs[unit]) == NULL)
		return (-1);
d802 2
a803 2
	if (sc->sc_dying)
		return (-1);
d821 1
a821 1
		wakeup(&sc->sc_refcnt);
d868 1
a868 1
		    sc->sc_rr.end - sc->sc_rr.start);
d886 5
a890 5
	    (double)sc->sc_pr.blksize * 100000 /
	    (double)(sc->sc_pparams.precision / NBBY *
		sc->sc_pparams.channels *
		sc->sc_pparams.sample_rate)) * 10;
	DPRINTF(("audio: play blktime = %lu for %d\n",
d894 5
a898 5
	    (double)sc->sc_rr.blksize * 100000 /
	    (double)(sc->sc_rparams.precision / NBBY *
		sc->sc_rparams.channels *
		sc->sc_rparams.sample_rate)) * 10;
	DPRINTF(("audio: record blktime = %lu for %d\n",
d914 1
a914 1
	sc->sc_rr.usedhigh = sc->sc_rr.end - sc->sc_rr.start - sc->sc_rr.blksize;
d929 2
a930 2
	DPRINTFN(3, ("audio_sleep_timo: chan=%p, label=%s, timo=%d\n",
	    chan, label, timo));
d1038 1
a1038 1
	ai.play.encoding       = sc->sc_pparams.encoding;
d1048 1
a1048 1

d1097 2
a1098 2
	DPRINTF(("audio_drain: enter busy=%d used=%d\n",
	    sc->sc_pbus, sc->sc_pr.used));
d1121 1
a1121 1
	/*
d1144 1
a1144 1
			error = EIO;
d1168 1
a1168 1
	/* Stop recording. */
d1170 1
a1170 1
		/*
d1193 1
a1193 1

d1195 1
a1195 1

d1233 2
a1234 2
	DPRINTFN(1,("audio_read: cc=%d mode=%d\n",
	    uio->uio_resid, sc->sc_mode));
d1249 1
a1249 1
				DPRINTF(("audio_read: stamp=%lu, wstamp=%lu\n",
d1257 1
a1257 1
					error = EIO;
d1270 1
a1270 1
		}
d1290 1
a1290 1
				error = EIO;
d1304 1
a1304 1

d1352 1
a1352 1
	int bs;
d1364 1
a1364 1

d1373 1
a1373 1
	DPRINTF(("audio_calc_blksize: %s blksize=%d\n",
d1380 2
a1381 2
	u_char *p;
	int n;
d1388 1
a1388 1
		auzero0 = 0x7f;
d1448 1
a1448 1
	while (n > 0 && uio->uio_resid > 0 && !error) {
d1453 1
a1453 1
	return (error);
d1501 3
a1503 3
	    sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
	    sc->sc_pparams.precision, sc->sc_pparams.channels,
	    sc->sc_pparams.sw_code, sc->sc_pparams.factor));
d1509 1
a1509 1
			DPRINTFN(2, ("audio_write: sleep used=%d lowat=%d hiwat=%d\n",
d1517 1
a1517 1
				error = EIO;
d1527 1
a1527 1
		cc = cb->usedhigh - used;	/* maximum to write */
d1537 1
a1537 1
			cc = uio->uio_resid;	/* and no more than we have */
d1540 1
a1540 1
		/*
d1542 1
a1542 1
		 * block pointers are always nicely aligned.
d1546 1
a1546 1
			    sc->sc_pparams.sw_code, sc->sc_pparams.factor);
d1551 2
a1552 2
		DPRINTFN(1, ("audio_write: uiomove cc=%d inp=%p, left=%d\n",
		    cc, inp, uio->uio_resid));
d1558 2
a1559 2
			printf("audio_write:(1) uiomove failed %d; cc=%d inp=%p\n",
			    error, cc, inp);
d1561 1
a1561 1
		/*
d1591 1
a1591 1
		    (inp  - cb->start) / cb->blksize ==
d1630 1
a1630 1
	int rbus, pbus;
d1633 1
a1633 1
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d1651 2
a1652 2
		rbus = sc->sc_rbus;
		pbus = sc->sc_pbus;
d1737 1
a1737 1

d1779 1
a1779 1
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
a1782 19
void
audio_selwakeup(struct audio_softc *sc, int play)
{
	struct selinfo *si;

	si = play? &sc->sc_wsel : &sc->sc_rsel;

	audio_wakeup(play? &sc->sc_wchan : &sc->sc_rchan);
	selwakeup(si);
	if (sc->sc_async_audio)
		psignal(sc->sc_async_audio, SIGIO);
	KNOTE(&si->si_note, 0);
}

#define	AUDIO_FILTREAD(sc) ((sc->sc_mode & AUMODE_PLAY) ? \
    sc->sc_pr.stamp > sc->sc_wstamp : sc->sc_rr.used > sc->sc_rr.usedlow)
#define	AUDIO_FILTWRITE(sc) \
    (sc->sc_mode & AUMODE_RECORD || sc->sc_pr.used <= sc->sc_pr.usedlow)

d1791 1
a1791 1
	int rv, s = splaudio();
d1798 4
a1801 3
		rv = AUDIO_FILTREAD(sc);
		splx(s);
		if (rv)
d1803 1
d1808 3
a1810 3
		rv = AUDIO_FILTWRITE(sc);
		splx(s);
		if (rv)
d1812 1
d1886 3
a1888 3

	DPRINTF(("audiostartr: start=%p used=%d(hi=%d) mmapped=%d\n",
		 sc->sc_rr.start, sc->sc_rr.used, sc->sc_rr.usedhigh,
d1896 1
a1896 1
		error = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start,
d1911 2
a1912 2

	DPRINTF(("audiostartp: start=%p used=%d(hi=%d) mmapped=%d\n",
d1915 1
a1915 1

d1928 1
a1928 1
		return error;
d1969 2
a1970 2
			DPRINTFN(5, ("audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\n",
			    cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start)));
d1974 1
a1974 1

d1979 2
a1980 2
		DPRINTFN(5, ("audio_pint_silence: start fill %p %d\n",
		    inp, cc));
d2003 2
a2004 2
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */
d2015 2
a2016 2
		DPRINTFN(5, ("audio_pint: mmapped outp=%p cc=%d inp=%p\n",
		    cb->outp, blksize, cb->inp));
d2022 1
a2022 1

d2033 2
a2034 2
				printf("audio: play interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_pnintr, lastdelta, sc->sc_pblktime);
d2038 2
a2039 2
				printf("audio: play interrupt(%d) off absolute by %ld us (%lu) (LOST)\n",
				    sc->sc_pnintr, totdelta, sc->sc_pblktime);
d2091 12
a2102 4
	    sc->sc_mode, cb->pause, cb->used, cb->usedlow));
	if ((sc->sc_mode & AUMODE_PLAY) && !cb->pause &&
	    cb->used <= cb->usedlow)
		audio_selwakeup(sc, 1);
d2105 6
a2110 2
	if (!sc->sc_full_duplex && sc->sc_rchan)
		audio_selwakeup(sc, 0);
d2128 2
a2129 2
	if (!sc->sc_open)
		return;		/* ignore interrupt if not open */
d2140 2
a2141 2
		DPRINTFN(2, ("audio_rint: mmapped inp=%p cc=%d\n",
		    cb->inp, blksize));
d2158 2
a2159 2
				printf("audio: record interrupt(%d) off relative by %ld us (%lu)\n",
				    sc->sc_rnintr, lastdelta, sc->sc_rblktime);
d2164 2
a2165 2
				printf("audio: record interrupt(%d) off absolute by %ld us (%lu)\n",
				    sc->sc_rnintr, totdelta, sc->sc_rblktime);
d2188 2
a2189 2
	DPRINTFN(2, ("audio_rint: inp=%p cc=%d used=%d\n",
	    cb->inp, blksize, cb->used));
d2200 4
a2203 1
	audio_selwakeup(sc, 0);
d2408 1
a2408 1
					    au_get_lr_value(sc, &ct,
d2484 1
a2484 1
			if (ports->aumask[i] & port)
d2540 1
a2540 1

d2564 1
a2564 1
	}
d2698 1
a2698 1

d2715 1
a2715 1

d2788 1
a2788 1
		if (!error &&
d2797 1
a2797 1

d2828 1
a2828 1

d2831 1
a2831 1

d2852 1
a2852 1

d2859 1
a2859 1
			ai->monitor_gain =
d2960 1
a2960 1

d2988 1
a2988 1
			    M_DEVBUF, M_WAITOK);
d3000 1
a3000 1

a3031 67

int
audiokqfilter(dev, kn)
	dev_t	dev;
	struct knote *kn;
{
	int unit = AUDIOUNIT(dev);
	struct audio_softc *sc = audio_cd.cd_devs[unit];
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_rsel.si_note;
		kn->kn_fop = &audioread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &sc->sc_wsel.si_note;
		kn->kn_fop = &audiowrite_filtops;
		break;
	default:
		return (1);
	}
	kn->kn_hook = (void *)sc;

	s = splaudio();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_audiordetach(struct knote *kn)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
	int s = splaudio();

	SLIST_REMOVE(&sc->sc_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_audioread(struct knote *kn, long hint)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;

	return AUDIO_FILTREAD(sc);
}

void
filt_audiowdetach(struct knote *kn)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;
	int s = splaudio();

	SLIST_REMOVE(&sc->sc_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_audiowrite(struct knote *kn, long hint)
{
	struct audio_softc *sc = (struct audio_softc *)kn->kn_hook;

	return AUDIO_FILTWRITE(sc);
}
@


1.20.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d88 2
d113 1
a113 1
int	audio_poll(dev_t, int, struct proc *);
d765 1
a765 1
audiopoll(dev, events, p)
d785 1
a785 1
		error = audio_poll(dev, events, p);
d1816 1
a1816 1
audio_poll(dev, events, p)
d1818 1
a1818 1
	int events;
d1823 3
a1825 1
	int revents = 0, s = splaudio();
d1827 1
a1827 1
	DPRINTF(("audio_poll: events=0x%x mode=%d\n", events, sc->sc_mode));
d1829 15
a1843 13
	if (events & (POLLIN | POLLRDNORM)) {
		if (AUDIO_FILTREAD(sc))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (AUDIO_FILTWRITE(sc))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->sc_rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->sc_wsel);
d1846 1
a1846 1
	return (revents);
@


1.19
log
@Pass device mode to query_encoding in the structure to fill, so
that devices that don't need it are not affected.

eso has those weird 16 bits mode that differ in endianess depending
on READ/WRITE. Use this to avoid setting AUDIO_FLAGS_EMULATED needlessly.

Reorder eso modes slightly so that emulated modes are always last.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.18 1999/11/20 18:51:58 espie Exp $	*/
d408 1
a408 11
#include "midi.h"

#if NAUDIO == 0 && (NMIDI > 0 || NMIDIBUS > 0)
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/audioio.h>
#include <dev/audio_if.h>
#endif

#if NAUDIO > 0 || (NMIDI > 0 || NMIDIBUS > 0)
a421 3
		case AUDIODEV_TYPE_MIDI:
			type = "midi";
			break;
d436 1
a436 1
#endif /* NAUDIO > 0 || (NMIDI > 0 || NMIDIBUS > 0) */
@


1.18
log
@ioctl arguments are u_long.
Replaces `undefined' code with `defined' behavior...

gcc 2.96 performs switch cases range analysis, warns about unreachable
cases, and weeds them out.

In

switch(i) {
case VALUE:
}

VALUE is first coerced into the type of i.  If i is signed, VALUE is
unsigned and exceeds i range, you lose... the result of the conversion
is undefined.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.17 1999/06/19 19:49:02 jason Exp $	*/
d1563 2
@


1.17
log
@From NetBSD:
Don't clobber the error returned by uiomove() when starting the audio
output (in case we got a partial block).
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.16 1999/01/02 00:02:39 niklas Exp $	*/
d111 1
a111 1
int	audio_ioctl __P((dev_t, int, caddr_t, int, struct proc *));
d117 1
a117 1
int	mixer_ioctl __P((dev_t, int, caddr_t, int, struct proc *));
d1443 1
a1443 1
	int cmd;
d2794 1
a2794 1
	int cmd;
@


1.16
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.15 1998/11/20 15:57:19 deraadt Exp $	*/
d1291 1
a1291 1
	int error, s, n, cc, used;
d1423 8
a1430 2
		if (!sc->sc_pbus && !cb->pause)
			error = audiostartp(sc); /* XXX should not clobber error */
@


1.15
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.14 1998/11/03 21:00:09 downsj Exp $	*/
d393 1
a393 1
audio_attach_mi(ahwp, mhwp, hdlp, dev)
a394 1
	struct midi_hw_if *mhwp;
a405 6
	if (mhwp != NULL) {
		arg.type = AUDIODEV_TYPE_MIDI;
		arg.hwif = mhwp;
		arg.hdl = hdlp;
		(void)config_found(dev, &arg, audioprint);
	}
d408 11
d435 6
d448 2
@


1.14
log
@Partial sync with NetBSD, adds new trigger methods.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.13 1998/07/24 01:59:38 downsj Exp $	*/
d1662 1
a1662 1
	if (off >= cb->bufsize)
@


1.13
log
@Kill the god damned COMPAT_12.  Thanks, guys.
@
text
@d1 2
a2 2
/*	$OpenBSD: audio.c,v 1.12 1998/04/26 21:03:06 provos Exp $	*/
/*	$NetBSD: audio.c,v 1.71 1997/09/06 01:14:48 augustss Exp $	*/
d93 1
d97 1
d239 2
a240 2
	    hwp->start_output == 0 ||
	    hwp->start_input == 0 ||
d261 1
d268 1
d305 1
a305 1
 	}
d483 2
a484 2
	if (hw->alloc)
	    r->start = hw->alloc(hdl, r->bufsize, M_DEVBUF, M_WAITOK);
d497 2
a498 2
	if (sc->hw_if->free) {
	    sc->hw_if->free(sc->hw_hdl, r->start, M_DEVBUF);
d626 1
d697 1
d700 1
a700 1
	    (double)sc->sc_pr.blksize * 1e6 / 
d703 1
a703 1
		     sc->sc_pparams.sample_rate));
d708 1
a708 1
	    (double)sc->sc_rr.blksize * 1e6 / 
d711 1
a711 1
		     sc->sc_rparams.sample_rate));
d714 1
d743 2
d750 1
a750 1
	    printf("audio_sleep: %d\n", st);
d768 1
d921 2
d989 1
d991 1
a991 1
	if (sc->sc_rbus) {
a1004 1
	s = splaudio();
d1009 2
a1010 2
	if ((sc->sc_mode & AUMODE_PLAY) && !sc->sc_pr.pause) {
		if (!audio_drain(sc) && hw->drain)
d1012 2
d1018 1
a1018 1
	if (flags & FREAD)
d1020 3
a1022 1
	if (flags & FWRITE)
d1024 2
a1027 1
	sc->sc_mode = 0;
d1050 2
a1051 4
#ifdef AUDIO_DEBUG
	if (audiodebug > 1)
		printf("audio_read: cc=%d mode=%d\n", uio->uio_resid, sc->sc_mode);
#endif
d1082 1
a1082 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 1)
				printf("audio_read: reading in write mode, cc=%d\n", cc);
#endif	
d1102 1
a1102 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 2)
				printf("audio_read: sleep used=%d\n", cb->used);
#endif
d1123 1
a1123 4
#ifdef AUDIO_DEBUG
		if (audiodebug > 1)
			printf("audio_read: outp=%p, cc=%d\n", outp, cc);
#endif	
d1281 1
a1281 1
	DPRINTF(("audio_write: sc=%p(unit=%d) count=%d used=%d(hi=%d)\n", sc, unit,
d1313 4
a1316 7
#ifdef AUDIO_DEBUG
	if (audiodebug > 1)
		printf("audio_write: sr=%ld, enc=%d, prec=%d, chan=%d, sw=%p, fact=%d\n",
		       sc->sc_pparams.sample_rate, sc->sc_pparams.encoding,
		       sc->sc_pparams.precision, sc->sc_pparams.channels,
		       sc->sc_pparams.sw_code, sc->sc_pparams.factor);
#endif
d1322 1
a1322 1
			DPRINTF(("audio_write: sleep used=%d lowat=%d hiwat=%d\n", 
d1362 2
a1363 4
#ifdef AUDIO_DEBUG
		if (audiodebug > 1)
		    printf("audio_write: uiomove cc=%d inp=%p, left=%d\n", cc, inp, uio->uio_resid);
#endif
d1381 1
a1381 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 1)
				printf("audio_write: expanded cc=%d\n", cc);
#endif
d1415 1
a1415 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 1)
				printf("audio_write: fill %d\n", cc);
#endif
d1435 1
a1435 1
	int rbus, pbus;
d1456 2
a1457 2
		rbus = sc->sc_rbus;
		pbus = sc->sc_pbus;
d1693 7
a1699 2
	error = sc->hw_if->start_input(sc->hw_hdl, sc->sc_rr.start, 
				       sc->sc_rr.blksize, audio_rint, (void *)sc);
d1718 8
a1725 1
	if (sc->sc_pr.used >= sc->sc_pr.blksize || sc->sc_pr.mmapped) {
d1727 4
a1730 6
					sc->sc_pr.blksize, audio_pint, (void *)sc);
		if (error) {
			DPRINTF(("audiostartp failed: %d\n", error));
		    	return error;
		}
		sc->sc_pbus = 1;
d1732 1
d1740 5
a1744 4
 * is kept track of in a very approcimate way: it starts at sc_sil_start
 * and extends sc_sil_count bytes.  If the writer doesn't write sc_sil_count
 * get to encompass the whole buffer after which no more filling needs
 * to be done.  When the writer starts again sc_sil_count is set to 0.
d1770 3
a1772 6
				sc->sc_sil_count = max(sc->sc_sil_count, q - s);
#ifdef AUDIO_DEBUG
			if (audiodebug > 2)
				printf("audio_pint_silence: fill cc=%d inp=%p, count=%d size=%d\n", 
				       cc, inp, sc->sc_sil_count, (int)(cb->end - cb->start));
#endif
d1775 1
a1775 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 2)
				printf("audio_pint_silence: already silent cc=%d inp=%p\n", cc, inp);
#endif
d1781 2
a1782 4
#ifdef AUDIO_DEBUG
		if (audiodebug > 2)
			printf("audio_pint_silence: start fill %p %d\n", inp, cc);
#endif
d1802 1
d1808 3
a1810 1
	cb->outp += cb->blksize;
d1813 1
a1813 1
	cb->stamp += cb->blksize / sc->sc_pparams.factor;
d1815 5
a1819 7
#ifdef AUDIO_DEBUG
		if (audiodebug > 2)
			printf("audio_pint: mmapped outp=%p cc=%d inp=%p\n", 
			       cb->outp, cb->blksize, cb->inp);
#endif
		(void)hw->start_output(sc->hw_hdl, cb->outp, cb->blksize,
				       audio_pint, (void *)sc);
d1832 1
a1832 1
			if (lastdelta > sc->sc_pblktime / 5) {
d1837 2
a1838 3
			if (totdelta > sc->sc_pblktime / 2) {
				sc->sc_pnintr++;
				printf("audio: play interrupt(%d) off absolute by %ld us (%lu)\n", 
d1849 2
a1850 2
	cb->used -= cb->blksize;
	if (cb->used < cb->blksize) {
d1855 1
a1855 4
#ifdef AUDIO_DEBUG
			if (audiodebug > 1)
			    printf("audio_pint: copying in progress\n");
#endif
d1858 1
a1858 1
			cc = cb->blksize - (inp - cb->start) % cb->blksize;
d1875 1
a1875 1
				audio_pint_silence(sc, cb, inp, cb->blksize);
d1879 9
a1887 10
#ifdef AUDIO_DEBUG
	if (audiodebug > 3)
		printf("audio_pint: outp=%p cc=%d\n", cb->outp, cb->blksize);
#endif
	error = hw->start_output(sc->hw_hdl, cb->outp, cb->blksize,
				 audio_pint, (void *)sc);
	if (error) {
		/* XXX does this really help? */
		DPRINTF(("audio_pint restart failed: %d\n", error));
		audio_clear(sc);
d1890 2
a1891 5
#ifdef AUDIO_DEBUG
	if (audiodebug > 3)
		printf("audio_pint: mode=%d pause=%d used=%d lowat=%d\n",
			 sc->sc_mode, cb->pause, cb->used, cb->usedlow);
#endif
d1897 2
a1898 5
#ifdef AUDIO_DEBUG
				if (audiodebug > 3)
					printf("audio_pint: sending SIGIO %p\n", 
					       sc->sc_async_audio);
#endif
d1925 1
d1931 3
a1933 1
	cb->inp += cb->blksize;
d1936 1
a1936 1
	cb->stamp += cb->blksize;
d1938 5
a1942 7
#ifdef AUDIO_DEBUG
		if (audiodebug > 2)
			printf("audio_rint: mmapped inp=%p cc=%d\n", 
			       cb->inp, cb->blksize);
#endif
		(void)hw->start_input(sc->hw_hdl, cb->inp, cb->blksize,
				      audio_rint, (void *)sc);
d1973 1
a1973 1
	cb->used += cb->blksize;
d1975 21
a1995 28
#ifdef AUDIO_DEBUG
		if (audiodebug > 1)
			printf("audio_rint: pdrops %lu\n", cb->pdrops);
#endif
		cb->pdrops += cb->blksize;
		cb->outp += cb->blksize;
		cb->used -= cb->blksize;
	} else if (cb->used + cb->blksize >= cb->usedhigh && !cb->copying) {
#ifdef AUDIO_DEBUG
		if (audiodebug > 1)
			printf("audio_rint: drops %lu\n", cb->drops);
#endif
		cb->drops += cb->blksize;
		cb->outp += cb->blksize;
		cb->used -= cb->blksize;
	}

#ifdef AUDIO_DEBUG
	if (audiodebug > 2)
		printf("audio_rint: inp=%p cc=%d used=%d\n", 
		       cb->inp, cb->blksize, cb->used);
#endif
	error = hw->start_input(sc->hw_hdl, cb->inp, cb->blksize,
				audio_rint, (void *)sc);
	if (error) {
		/* XXX does this really help? */
		DPRINTF(("audio_rint: restart failed: %d\n", error));
		audio_clear(sc);
d2328 1
a2328 1
	int s, setmode;
d2397 1
a2397 1
		cleared = 1;
d2405 1
a2405 1
		cleared = 1;
d2414 1
a2414 1
		cleared = 1;
d2423 1
a2423 1
	if (setmode) {
d2431 2
a2432 1
		error = hw->set_params(sc->hw_hdl, setmode, sc->sc_mode, &pp, &rp);
d2448 2
a2449 4
		if (setmode & AUMODE_RECORD)
			sc->sc_rparams = rp;
		if (setmode & AUMODE_PLAY)
			sc->sc_pparams = pp;
d2522 1
a2522 1
	
d2741 1
a2741 1
 * Signal all processes waiting for the mixer.
d2794 2
a2795 1
			ma = malloc(sizeof (struct mixer_asyncs), M_DEVBUF, M_WAITOK);
@


1.12
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.71 1997/09/06 01:14:48 augustss Exp $	*/
a2024 1
#if defined(COMPAT_12)
a2035 1
#endif
@


1.11
log
@Change a '< sc->sc_lowat' to '<= sc->sc_lowat' for consistency with rest of
source.  I've had this in my tree forever and I don't recall the originator.
@
text
@d1 2
a2 2
/*	$OpenBSD: audio.c,v 1.10 1997/07/10 23:06:29 provos Exp $	*/
/*	$NetBSD: audio.c,v 1.26 1996/05/13 02:26:15 mycroft Exp $	*/
d60 2
a61 5
 * - Add softaudio() isr processing for wakeup, select and signals.
 * - Allow opens for READ and WRITE (one open each)
 * - Setup for single isr for full-duplex
 * - Add SIGIO generation for changes in the mixer device
 * - Fixup SunOS compat for mixer device changes in ioctl.
d72 1
d81 1
d83 1
a84 1
#include <dev/audio_if.h>
d86 2
a87 2
#ifdef AUDIO_DEBUG
#include <machine/stdarg.h>
d89 1
a89 1
void Dprintf __P((const char *, ...));
d91 2
a92 16
void
#ifdef __STDC__
Dprintf(const char *fmt, ...)
#else
Dprintf(fmt, va_alist)
	char *fmt;
#endif
{
	va_list ap;

	va_start(ap, fmt);
	log(LOG_DEBUG, "%:", fmt, ap);
	va_end(ap);
}

#define DPRINTF(x)	if (audiodebug) Dprintf x
d98 1
a98 4
int naudio;	/* Count of attached hardware drivers */

int audio_blk_ms = AUDIO_BLK_MS;
int audio_backlog = AUDIO_BACKLOG;
d100 1
a100 1
struct audio_softc *audio_softc[NAUDIO];
d116 2
d121 2
a122 2
void	audiostartr __P((struct audio_softc *));
void	audiostartp __P((struct audio_softc *));
d125 1
a125 2
void	audio_rpint __P((void *));
int	audio_check_format __P((u_int *, u_int *));
d127 2
a128 2
int	audio_calc_blksize __P((struct audio_softc *));
void	audio_fill_silence __P((int, u_char *, int));
a129 1
void	audio_alloc_auzero __P((struct audio_softc *, int));
d131 3
a133 5
void	audio_printsc __P((struct audio_softc *));
void	audioattach __P((int));
int	audio_hardware_attach __P((struct audio_hw_if *, void *));
void	audio_init_ring __P((struct audio_buffer *, int));
void	audio_initbufs __P((struct audio_softc *));
d139 4
d144 7
a150 15
#ifdef AUDIO_DEBUG
void
audio_printsc(sc)
	struct audio_softc *sc;
{
	printf("hwhandle %p hw_if %p ", sc->hw_hdl, sc->hw_if);
	printf("open %x mode %x\n", sc->sc_open, sc->sc_mode);
	printf("rchan %x wchan %x ", sc->sc_rchan, sc->sc_wchan);
	printf("rring blk %x pring nblk %x\n", sc->rr.nblk, sc->pr.nblk);
	printf("rbus %x pbus %x ", sc->sc_rbus, sc->sc_pbus);
	printf("blksz %d sib %d ", sc->sc_blksize, sc->sc_smpl_in_blk);
	printf("sp50ms %d backlog %d\n", sc->sc_50ms, sc->sc_backlog);
	printf("hiwat %d lowat %d rblks %d\n", sc->sc_hiwat, sc->sc_lowat,
	    sc->sc_rblks);
}
d152 1
d154 54
a207 3
void
audioattach(num)
	int num;
d209 5
d216 12
a227 15
/*
 * Called from hardware driver.
 */
int
audio_hardware_attach(hwp, hdlp)
	struct audio_hw_if *hwp;
	void *hdlp;
{
	struct audio_softc *sc;

	if (naudio >= NAUDIO) {
	    DPRINTF(("audio_hardware_attach: not enough audio devices: %d > %d\n",
		     naudio, NAUDIO));
	    return(EINVAL);
	}
d229 1
a229 7
	/*
	 * Malloc a softc for the device
	 */
	/* XXX Find the first free slot */
	audio_softc[naudio] = malloc(sizeof(struct audio_softc), M_DEVBUF, M_WAITOK);
	sc = audio_softc[naudio];	
	bzero(sc, sizeof(struct audio_softc));
d231 3
a233 2
	/* XXX too paranoid? */
	if (hwp->open == 0 ||
d235 2
a236 15
	    hwp->set_in_sr == 0 ||
	    hwp->get_in_sr == 0 ||
	    hwp->set_out_sr == 0 ||
	    hwp->get_out_sr == 0 ||
	    hwp->set_format == 0 ||
	    hwp->get_encoding == 0 ||
	    hwp->get_precision == 0 ||
	    hwp->set_channels == 0 ||
	    hwp->get_channels == 0 ||
	    hwp->round_blocksize == 0 ||
	    hwp->set_out_port == 0 ||
	    hwp->get_out_port == 0 ||
	    hwp->set_in_port == 0 ||
	    hwp->get_in_port == 0 ||
	    hwp->commit_settings == 0 ||
a240 2
	    hwp->cont_output == 0 ||
	    hwp->cont_input == 0 ||
d244 7
a250 2
	    hwp->query_devinfo == 0)
		return(EINVAL);
d254 13
d269 1
a269 1
	 * Alloc DMA play and record buffers
d271 110
a380 8
	sc->rr.bp = malloc(AU_RING_SIZE, M_DEVBUF, M_WAITOK);
	if (sc->rr.bp == 0) {
		return (ENOMEM);
	}
	sc->pr.bp = malloc(AU_RING_SIZE, M_DEVBUF, M_WAITOK);
	if (sc->pr.bp == 0) {
		free(sc->rr.bp, M_DEVBUF);
		return (ENOMEM);
d382 1
d384 12
a395 4
	/*
	 * Set default softc params
	 */
	sc->sc_pencoding = sc->sc_rencoding = AUDIO_ENCODING_LINEAR;
d397 12
a408 10
	/*
	 * Return the audio unit number
	 */
	hwp->audio_unit = naudio++;

#ifdef AUDIO_DEBUG
	printf("audio: unit %d attached\n", hwp->audio_unit);
#endif
	
	return(0);
d412 3
a414 2
audio_hardware_detach(hwp)
	struct audio_hw_if *hwp;
d416 18
a433 9
	struct audio_softc *sc;
	
#ifdef DIAGNOSTIC
	if (!hwp)
	    panic("audio_hardware_detach: null hwp");
	
	if (hwp->audio_unit > naudio)
	    panic("audio_hardware_detach: invalid audio unit");
#endif
d435 3
a437 1
	sc = audio_softc[hwp->audio_unit];
d439 12
a450 5
	if (hwp != sc->hw_if)
		return(EINVAL);
	
	if (sc->sc_open != 0)
		return(EBUSY);
d452 9
a460 1
	sc->hw_if = 0;
d462 25
a486 3
	/* Free audio buffers */
	free(sc->rr.bp, M_DEVBUF);
	free(sc->pr.bp, M_DEVBUF);
d488 10
a497 4
	free(sc, M_DEVBUF);
	audio_softc[hwp->audio_unit] = NULL;

	return(0);
d510 1
d532 2
d550 1
d569 1
d589 1
d609 1
a621 1

d626 1
d628 1
a628 1
		return (ENODEV);
d630 1
a630 1
		return (ENXIO);
d638 26
a663 12
audio_init_ring(rp, blksize)
	struct audio_buffer *rp;
	int blksize;
{
	int nblk = AU_RING_SIZE / blksize;

	rp->ep = rp->bp + nblk * blksize;
	rp->hp = rp->tp = rp->bp;
	rp->maxblk = nblk;
	rp->nblk = 0;
	rp->cb_drops = 0;
	rp->cb_pdrops = 0;
d666 1
a666 1
void
d670 2
a671 1
	int nblk = AU_RING_SIZE / sc->sc_blksize;
d673 50
a722 4
	audio_init_ring(&sc->rr, sc->sc_blksize);
	audio_init_ring(&sc->pr, sc->sc_blksize);
	sc->sc_lowat = nblk / 2;
	sc->sc_hiwat = nblk;
d735 1
a735 1
	
d737 1
a737 1
	st = (tsleep(chan, PWAIT | PCATCH, label, timo));
d739 4
a742 3
	if (st != 0) {
	    DPRINTF(("audio_sleep: %d\n", st));
	}
d751 1
a751 1
    return audio_sleep_timo(chan, label, 0);
d754 1
d773 2
a774 1
	int s, error;
d776 1
d778 3
a780 4
	if (unit >= NAUDIO || !audio_softc[unit]) {
	    DPRINTF(("audio_open: invalid device unit - %d\n", unit));
	    return (ENODEV);
	}
a781 1
	sc = audio_softc[unit];
d783 2
d786 4
a789 3
	DPRINTF(("audio_open: dev=0x%x flags=0x%x sc=0x%x hdl=0x%x\n", dev, flags, sc, sc->hw_hdl));
	if (hw == 0)		/* Hardware has not attached to us... */
		return (ENXIO);
d791 1
a791 1
	if ((sc->sc_open & (AUOPEN_READ|AUOPEN_WRITE)) != 0) /* XXX use flags */
d794 2
a795 1
	if ((error = hw->open(dev, flags)) != 0)
d798 18
a815 1
	if (flags&FREAD)
d817 3
a819 1
	if (flags&FWRITE)
d821 2
d831 2
a832 6
		hw->set_format(sc->hw_hdl, AUDIO_ENCODING_ULAW, 8);
		hw->set_in_sr(sc->hw_hdl, 8000);
		hw->set_out_sr(sc->hw_hdl, 8000);
		hw->set_channels(sc->hw_hdl, 1);

		sc->sc_pencoding = sc->sc_rencoding = AUDIO_ENCODING_ULAW;
d834 1
a834 1

d840 4
a843 3
#ifdef DIAGNOSTIC
	if (hw->get_precision(sc->hw_hdl) == 0)
	    panic("audio_open: hardware driver returned 0 for get_precision");
a844 1
	sc->sc_50ms = 50 * hw->get_out_sr(sc->hw_hdl) / 1000;
d846 14
a859 7
	sc->sc_blksize = audio_calc_blksize(sc);
	audio_alloc_auzero(sc, sc->sc_blksize);
	sc->sc_smpl_in_blk = sc->sc_blksize / 
	    (hw->get_precision(sc->hw_hdl) / NBBY);
	audio_initbufs(sc);

	sc->sc_backlog = audio_backlog;
d861 1
a861 2
	DPRINTF(("audio_open: rr.bp=%x-%x pr.bp=%x-%x\n",
		 sc->rr.bp, sc->rr.ep, sc->pr.bp, sc->pr.ep));
d863 1
a863 1
	hw->commit_settings(sc->hw_hdl);
d865 6
a870 41
	s = splaudio();

	/* nothing read or written yet */
	sc->sc_rseek = 0;
	sc->sc_wseek = 0;

	sc->sc_rchan = 0;
	sc->sc_wchan = 0;

	sc->sc_rbus = 0;
	sc->sc_pbus = 0;

	if ((flags & FWRITE) != 0) {
		audio_init_play(sc);
		/* audio_pint(sc);		??? */
	}
	if ((flags & FREAD) != 0) {
		/* Play takes precedence if HW is half-duplex */
		if (hw->full_duplex || ((flags & FWRITE) == 0)) {
			audio_init_record(sc);
			/* audiostartr(sc); don't start recording until read */
		}
	}
	if (ISDEVAUDIO(dev)) {
	    /* if open only for read or only for write, then set specific mode */
	    if ((flags & (FWRITE|FREAD)) == FWRITE) {
		sc->sc_mode = AUMODE_PLAY;
		sc->pr.cb_pause = 0;
		sc->rr.cb_pause = 1;
		audiostartp(sc);
	    } else if ((flags & (FWRITE|FREAD)) == FREAD) {
		sc->sc_mode = AUMODE_RECORD;
		sc->rr.cb_pause = 0;
		sc->pr.cb_pause = 1;
		audiostartr(sc);
	    }
	}
	/* Play all sample, and don't pad short writes by default */
	sc->sc_mode |= AUMODE_PLAY_ALL;
	splx(s);
	return (0);
a881 1
	sc->sc_mode |= AUMODE_RECORD;
d883 1
a883 1
	    (!sc->hw_if->full_duplex || (sc->sc_mode & AUMODE_PLAY) == 0))
d897 1
a897 2
	sc->sc_mode |= AUMODE_PLAY;
	sc->sc_rblks = sc->sc_wblks = 0;
d907 12
a918 1
	int error;
d920 30
a949 2
	while (sc->pr.nblk > 0) {
		DPRINTF(("audio_drain: nblk=%d\n", sc->pr.nblk));
a950 1
		 * XXX
d952 1
a952 2
		 * we can't interrupt this sleep, so we set a 1-minute
		 * timeout.
d954 1
a954 3
		error = audio_sleep_timo(&sc->sc_wchan, "aud_dr", 60*hz);
		if (error)
			return (error);
d956 2
a957 1
	return (0);
d971 1
a971 1
	struct audio_softc *sc = audio_softc[unit];
d977 11
d991 1
a991 1
	sc->sc_lowat = 0;	/* avoid excessive wakeups */
d997 1
a997 1
	if (sc->sc_pbus && sc->pr.nblk > 0 && !sc->pr.cb_pause) {
d1004 1
a1004 1
	if (flags&FREAD)
d1006 1
a1006 1
	if (flags&FWRITE)
d1009 3
a1011 1
	sc->sc_async = 0;
d1025 4
a1028 6
	struct audio_softc *sc = audio_softc[unit];
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_buffer *cb = &sc->rr;
	u_char *hp;
	int blocksize = sc->sc_blksize;
	int error, s;
d1030 2
a1031 2
	DPRINTF(("audio_read: cc=%d mode=%d rblks=%d\n",
	         uio->uio_resid, sc->sc_mode, sc->sc_rblks));
d1033 4
a1036 8
	if (uio->uio_resid == 0)
		return (0);

	if (uio->uio_resid < blocksize)
		return (EINVAL);

	/* First sample we'll read in sample space */
	sc->sc_rseek = cb->au_stamp - AU_RING_LEN(cb);
d1038 1
d1043 1
a1043 1
	if ((!hw->full_duplex) &&
d1045 1
a1045 1
		do {
d1047 6
a1052 2
			while (sc->sc_rblks <= 0) {
				DPRINTF(("audio_read: sc_rblks=%d\n", sc->sc_rblks));
d1055 1
a1055 1
					return (EWOULDBLOCK);
d1057 1
a1057 1
				error = audio_sleep(&sc->sc_rchan, "aud hr");
d1060 1
a1060 1
					return (error);
d1064 10
a1073 7
			error = audio_silence_copyout(sc, blocksize, uio);
			if (error)
				break;
			s = splaudio();
			--sc->sc_rblks;
			splx(s);
		} while (uio->uio_resid >= blocksize);
d1076 3
a1078 3
	error = 0;
	do {
		while (cb->nblk <= 0) {
d1080 18
a1097 2
				error = EWOULDBLOCK;
				return (error);
a1098 7
			s = splaudio();
			if (!sc->sc_rbus)
				audiostartr(sc);
			error = audio_sleep(&sc->sc_rchan, "aud rd");
			splx(s);
			if (error)
				return (error);
d1100 11
a1110 12
		hp = cb->hp;
		if (hw->sw_decode)
			hw->sw_decode(sc->hw_hdl, sc->sc_rencoding, hp, blocksize);
		error = uiomove(hp, blocksize, uio);
		if (error)
			break;
		hp += blocksize;
		if (hp >= cb->ep)
			hp = cb->bp;
		cb->hp = hp;
		--cb->nblk;
	} while (uio->uio_resid >= blocksize);
d1112 17
d1138 2
a1139 2
	if (sc->sc_rbus || sc->sc_pbus) {
		sc->hw_if->halt_output(sc->hw_hdl);
d1142 4
a1147 4
	AU_RING_INIT(&sc->rr);
	AU_RING_INIT(&sc->pr);
	sc->sc_rblks = sc->sc_wblks = 0;

d1151 2
a1152 2
int
audio_calc_blksize(sc)
d1154 1
d1157 2
d1160 11
d1172 7
a1178 10
	bs =  hw->get_out_sr(sc->hw_hdl) * audio_blk_ms / 1000;
	if (bs == 0)
		bs = 1;
	bs *= hw->get_channels(sc->hw_hdl);
	bs *= hw->get_precision(sc->hw_hdl) / NBBY;
	if (bs > AU_RING_SIZE/2)
		bs = AU_RING_SIZE/2;
	bs =  hw->round_blocksize(sc->hw_hdl, bs);
	if (bs > AU_RING_SIZE)
		bs = AU_RING_SIZE;
d1180 2
a1181 1
	return(bs);
d1185 2
a1186 2
audio_fill_silence(encoding, p, n)
	int encoding;
d1190 4
a1193 4
	u_int auzero;
	u_char *q;
    
	switch (encoding) {
d1195 1
a1195 1
	    	auzero = 0x7f; 
d1198 1
a1198 1
		auzero = 0x55;
d1200 6
d1207 18
a1224 2
	case AUDIO_ENCODING_PCM8:
	case AUDIO_ENCODING_PCM16:
d1226 2
a1227 1
		auzero = 0;	/* fortunately this works for both 8 and 16 bits */
d1230 10
a1239 3
	q = p;
	while (--n >= 0)
		*q++ = auzero;
a1241 1
#define NSILENCE 128 /* An arbitrary even constant >= 2 */
d1248 1
a1248 3
	struct iovec *iov;
	int error = 0;
	u_char zerobuf[NSILENCE];
d1250 1
d1252 1
a1252 1
	audio_fill_silence(sc->sc_rencoding, zerobuf, NSILENCE);
d1254 6
a1259 25
        while (n > 0 && uio->uio_resid) {
                iov = uio->uio_iov;
                if (iov->iov_len == 0) {
                        uio->uio_iov++;
                        uio->uio_iovcnt--;
                        continue;
                }
		k = min(min(n, iov->iov_len), NSILENCE);
                switch (uio->uio_segflg) {
                case UIO_USERSPACE:
			error = copyout(zerobuf, iov->iov_base, k);
			if (error)
				return (error);
			break;

                case UIO_SYSSPACE:
                        bcopy(zerobuf, iov->iov_base, k);
                        break;
                }
                iov->iov_base += k;
                iov->iov_len -= k;
                uio->uio_resid -= k;
                uio->uio_offset += k;
                n -= k;
        }
a1262 22
void
audio_alloc_auzero(sc, bs)
	struct audio_softc *sc;
	int bs;
{
	struct audio_hw_if *hw = sc->hw_if;

	if (sc->auzero_block)
		free(sc->auzero_block, M_DEVBUF);

	sc->auzero_block = malloc(bs, M_DEVBUF, M_WAITOK);
#ifdef DIAGNOSTIC
	if (sc->auzero_block == 0) {
		panic("audio_alloc_auzero: malloc auzero_block failed");
	}
#endif
	audio_fill_silence(sc->sc_pencoding, sc->auzero_block, bs);
	if (hw->sw_encode)
		hw->sw_encode(sc->hw_hdl, sc->sc_pencoding, sc->auzero_block, bs);
}

    
d1270 15
a1284 6
	struct audio_softc *sc = audio_softc[unit];
	struct audio_hw_if *hw = sc->hw_if;
	struct audio_buffer *cb = &sc->pr;
	u_char *tp;
	int error, s, cc;
	int blocksize = sc->sc_blksize;
a1285 1
	DPRINTF(("audio_write: cc=%d hiwat=%d\n", uio->uio_resid, sc->sc_hiwat));
d1289 1
a1289 1
	if (!hw->full_duplex &&
d1296 19
d1316 13
a1328 26

	while (uio->uio_resid > 0) {
		if (cb->fill > 0) {
			if (sc->sc_pbus == 0) {
				/* playing has stopped, ignore fill */
				cb->fill = 0;
			} else {
				/* Write samples in the silence fill space.
				 * We don't know where the DMA is
				 * happening in the buffer, but if we
				 * are lucky we will fill the buffer before
				 * playing has reached the point we move to.
				 * If we are unlucky some sample will
				 * not be played.
				 */
				cc = min(cb->fill, uio->uio_resid);
				error = uiomove(cb->otp, cc, uio);
				if (error == 0) {
					if (hw->sw_encode)
						hw->sw_encode(sc->hw_hdl,
						    sc->sc_pencoding, cb->otp,
						    cc);
					cb->fill -= cc;
					cb->otp += cc;
				}
				continue;
d1331 10
a1340 9
		if (cb->nblk >= sc->sc_hiwat) {
			do {
				DPRINTF(("audio_write: nblk=%d hiwat=%d lowat=%d\n", cb->nblk, sc->sc_hiwat, sc->sc_lowat));
				if (ioflag & IO_NDELAY)
					return (EWOULDBLOCK);
				error = audio_sleep(&sc->sc_wchan, "aud wr");
				if (error)
					return (error);
			} while (cb->nblk >= sc->sc_lowat);
d1342 15
a1356 25
#if 0
		if (cb->nblk == 0 &&
		    cb->maxblk > sc->sc_backlog &&
		    uio->uio_resid <= blocksize &&
		    (cb->au_stamp - sc->sc_wseek) > sc->sc_50ms) {
			/*
			 * the write is 'small', the buffer is empty
			 * and we have been silent for at least 50ms
			 * so we might be dealing with an application
			 * that writes frames synchronously with
			 * reading them.  If so, we need an output
			 * backlog to cover scheduling delays or
			 * there will be gaps in the sound output.
			 * Also take this opportunity to reset the
			 * buffer pointers in case we ended up on
			 * a bad boundary (odd byte, blksize bytes
			 * from end, etc.).
			 */
		        DPRINTF(("audiowrite: set backlog %d\n", sc->sc_backlog));
			s = splaudio();
			cb->hp = cb->bp;
			cb->nblk = sc->sc_backlog;
			cb->tp = cb->hp + sc->sc_backlog * blocksize;
			splx(s);
			audio_fill_silence(sc->sc_pencoding, cb->hp, sc->sc_backlog * blocksize);
d1359 16
a1374 7
		/* Calculate sample number of first sample in block we write */
		s = splaudio();
		sc->sc_wseek = AU_RING_LEN(cb) + cb->au_stamp;
		splx(s);
		
		tp = cb->tp;
		cc = uio->uio_resid;
d1376 4
d1381 3
a1383 37
		if (audiodebug > 1) {
		    int left = cb->ep - tp;
		    Dprintf("audio_write: cc=%d tp=%p bs=%d nblk=%d left=%d\n", cc, tp, blocksize, cb->nblk, left);
		}
#endif		
#ifdef DIAGNOSTIC
  {
		int towrite = (cc < blocksize)?cc:blocksize;
      
		/* check for an overwrite. Should never happen */
		if ((tp + towrite) > cb->ep) {
			DPRINTF(("audio_write: overwrite tp=%p towrite=%d ep=0x%x bs=%d\n",
			         tp, towrite, cb->ep, blocksize));
			printf("audio_write: overwrite tp=%p towrite=%d ep=%p\n",
			         tp, towrite, cb->ep);
			tp = cb->bp;
		}
  }
#endif
		if (cc < blocksize) {
			error = uiomove(tp, cc, uio);
			if (error == 0) {
				/* fill with audio silence */
				tp += cc;
				cc = blocksize - cc;
				cb->fill = cc;
				cb->otp = tp;
				audio_fill_silence(sc->sc_pencoding, tp, cc);
				DPRINTF(("audio_write: auzero 0x%x %d 0x%x\n",
				         tp, cc, *(int *)tp));
				tp += cc;
			}
		} else {
			error = uiomove(tp, blocksize, uio);
			if (error == 0) {
				tp += blocksize;
			}
a1384 6
		if (error) {
#ifdef AUDIO_DEBUG
		        printf("audio_write:(1) uiomove failed %d; cc=%d tp=%p bs=%d\n", error, cc, tp, blocksize);
#endif
			break;
		}		    
d1386 3
a1388 3
		if (hw->sw_encode)
			hw->sw_encode(sc->hw_hdl, sc->sc_pencoding, cb->tp,
			    blocksize);
a1389 1
		/* wrap the ring buffer if at end */
d1391 31
a1421 19
		if ((sc->sc_mode & AUMODE_PLAY_ALL) == 0 && sc->sc_wblks)
			/*
			 * discard the block if we sent out a silence
			 * packet that hasn't yet been countered
			 * by user data.  (They must supply enough
			 * data to catch up to "real time").
			 */
			sc->sc_wblks--;
		else {
			if (tp >= cb->ep)
				tp = cb->bp;
			cb->tp = tp;
			++cb->nblk;	/* account for buffer filled */

			/*
			 * If output isn't active, start it up.
			 */
			if (sc->sc_pbus == 0)
				audiostartp(sc);
a1422 1
		splx(s);
d1436 1
a1436 1
	struct audio_softc *sc = audio_softc[unit];
d1438 3
a1440 1
	int error = 0, s;
d1445 3
d1451 1
a1451 1
			if (sc->sc_async)
d1453 2
a1454 1
			sc->sc_async = p;
d1456 1
a1456 1
			sc->sc_async = 0;
d1461 2
d1465 10
a1474 7
		if ((sc->sc_mode & AUMODE_PLAY) && (sc->sc_pbus == 0))
			audiostartp(sc);
		/* Again, play takes precedence on half-duplex hardware */
		if ((sc->sc_mode & AUMODE_RECORD) &&
		    (hw->full_duplex ||
		     ((sc->sc_mode & AUMODE_PLAY) == 0)))
			audiostartr(sc);
d1483 1
a1483 1
		*(int *)addr = sc->rr.cb_drops;
d1487 1
a1487 1
		*(int *)addr = sc->pr.cb_drops;
d1491 1
a1491 2
	 * How many samples will elapse until mike hears the first
	 * sample of what we last wrote?
d1493 12
a1504 1
	case AUDIO_WSEEK:
d1506 9
a1514 2
		*(u_long *)addr = sc->sc_wseek - sc->pr.au_stamp
				  + AU_RING_LEN(&sc->rr);
d1517 9
d1527 1
a1527 1
		DPRINTF(("AUDIO_SETINFO\n"));
d1555 1
a1555 1
		*(int *)addr = hw->full_duplex;
d1560 19
a1578 1
		error = hw->setfd(sc->hw_hdl, *(int *)addr);
d1598 1
a1598 1
	struct audio_softc *sc = audio_softc[unit];
d1601 2
a1602 4
#if 0
	DPRINTF(("audio_select: rw=%d mode=%d rblks=%d rr.nblk=%d\n",
	         rw, sc->sc_mode, sc->sc_rblks, sc->rr.nblk));
#endif
d1606 3
a1608 6
		if (sc->sc_mode & AUMODE_PLAY) {
			if (sc->sc_rblks > 0) {
				splx(s);
				return (1);
			}
		} else if (sc->rr.nblk > 0) {
a1615 10
		/*
		 * Can write if we're recording because it gets preempted.
		 * Otherwise, can write when below low water.
		 * XXX this won't work right if we're in 
		 * record mode -- we need to note that a write
		 * select has happed and flip the speaker.
		 *
		 * XXX The above XXX-comment is SoundBlaster-dependent,
		 * right? Or maybe specific to half-duplex devices?
		 */
d1617 1
a1617 1
		    sc->pr.nblk <= sc->sc_lowat) {
d1633 53
a1685 2
	/* XXX placeholder */
	return (-1);
d1688 1
a1688 1
void
d1694 3
a1696 1
    	DPRINTF(("audiostartr: tp=%p\n", sc->rr.tp));
d1698 2
a1699 2
	error = sc->hw_if->start_input(sc->hw_hdl, sc->rr.tp, sc->sc_blksize,
	    			       audio_rint, (void *)sc);
d1702 1
a1702 1
		audio_clear(sc);
d1704 2
a1705 2
	else
		sc->sc_rbus = 1;
d1708 1
a1708 1
void
d1714 3
a1716 1
    	DPRINTF(("audiostartp: hp=0x%x nblk=%d\n", sc->pr.hp, sc->pr.nblk));
d1718 3
a1720 4
	if (sc->pr.nblk > 0) {
		u_char *hp = sc->pr.hp;
		error = sc->hw_if->start_output(sc->hw_hdl, hp, sc->sc_blksize,
					        audio_rpint, (void *)sc);
d1722 2
a1723 8
		    	DPRINTF(("audiostartp: failed: %d\n", error));
		}
		else {
			sc->sc_pbus = 1;
			hp += sc->sc_blksize;
			if (hp >= sc->pr.ep)
				hp = sc->pr.bp;
			sc->pr.hp = hp;
d1725 1
d1727 1
d1731 11
a1741 2
 * Use this routine as DMA callback if we played user data.  We need to
 * account for user data and silence separately.
d1743 43
a1785 7
void
audio_rpint(v)
	void *v;
{
	struct audio_softc *sc = v;
	sc->pr.nblk--;
	audio_pint(v);		/* 'twas a real audio block */
a1798 2
	u_char *hp;
	int cc = sc->sc_blksize;
d1800 3
a1802 1
	struct audio_buffer *cb = &sc->pr;
a1803 34
	
	/*
	 * XXX
	 * if there is only one buffer in the ring, this test
	 * always fails and the output is always silence after the
	 * first block.
	 */
	if (cb->nblk > 0) {
		hp = cb->hp;
		if (cb->cb_pause) {
		    cb->cb_pdrops++;
#ifdef AUDIO_DEBUG
		    if (audiodebug > 1)
			Dprintf("audio_pint: paused %d\n", cb->cb_pdrops);
#endif
		    goto psilence;
		}
		else {
#ifdef AUDIO_DEBUG
		    if (audiodebug > 1)
		    	Dprintf("audio_pint: hp=0x%x cc=%d\n", hp, cc);
#endif
		    error = hw->start_output(sc->hw_hdl, hp, cc,
					     audio_rpint, (void *)sc);
		    if (error) {
			    DPRINTF(("audio_pint restart failed: %d\n", error));
			    audio_clear(sc);
		    }
		    else {
		    	    hp += cc;
			    if (hp >= cb->ep)
				    hp = cb->bp;
			    cb->hp = hp;
			    cb->au_stamp += sc->sc_smpl_in_blk;
d1805 75
a1879 2
			    ++sc->sc_rblks;
		    }
d1882 1
a1882 2
	else {
		cb->cb_drops++;
d1884 2
a1885 2
		if (audiodebug > 1)
		    Dprintf("audio_pint: drops=%d auzero %d 0x%x\n", cb->cb_drops, cc, *(int *)sc->auzero_block);
d1887 6
a1892 9
 psilence:
		error = hw->start_output(sc->hw_hdl,
		    			 sc->auzero_block, cc,
					 audio_pint, (void *)sc);
		if (error) {
			DPRINTF(("audio_pint zero failed: %d\n", error));
			audio_clear(sc);
		} else
			++sc->sc_wblks;
d1896 3
a1898 2
	DPRINTF(("audio_pint: mode=%d pause=%d nblk=%d lowat=%d\n",
		sc->sc_mode, cb->cb_pause, cb->nblk, sc->sc_lowat));
d1900 2
a1901 2
	if ((sc->sc_mode & AUMODE_PLAY) && !cb->cb_pause) {
		if (cb->nblk <= sc->sc_lowat) {
d1904 8
a1911 2
			if (sc->sc_async)
				psignal(sc->sc_async, SIGIO);
d1915 2
a1916 6
	/*
	 * XXX
	 * possible to return one or more "phantom blocks" now.
	 * Only in half duplex?
	 */
	if (hw->full_duplex) {
d1919 2
a1920 2
		if (sc->sc_async)
			psignal(sc->sc_async, SIGIO);
a1933 2
	u_char *tp;
	int cc = sc->sc_blksize;
d1935 1
a1935 1
	struct audio_buffer *cb = &sc->rr;
d1937 9
a1945 11
	
	tp = cb->tp;
	if (cb->cb_pause) {
		cb->cb_pdrops++;
		DPRINTF(("audio_rint: pdrops %d\n", cb->cb_pdrops));
	}
	else {
		tp += cc;
	    	if (tp >= cb->ep)
			tp = cb->bp;
	    	if (++cb->nblk < cb->maxblk) {
d1947 3
a1949 2
		    	if (audiodebug > 1)
				Dprintf("audio_rint: tp=%p cc=%d\n", tp, cc);
d1951 24
a1974 6
			error = hw->start_input(sc->hw_hdl, tp, cc,
						audio_rint, (void *)sc);
			if (error) {
				DPRINTF(("audio_rint: start failed: %d\n",
					 error));
				audio_clear(sc);
d1976 4
a1979 19
			cb->au_stamp += sc->sc_smpl_in_blk;
		    } else {
			/* 
			 * XXX 
			 * How do we count dropped input samples due to overrun?
			 * Start a "dummy DMA transfer" when the input ring buffer
			 * is full and count # of these?  Seems pretty lame to
			 * me, but how else are we going to do this?
			 */
			cb->cb_drops++;
			sc->sc_rbus = 0;
			DPRINTF(("audio_rint: drops %d\n", cb->cb_drops));
	    	}
	    	cb->tp = tp;

	    	audio_wakeup(&sc->sc_rchan);
	    	selwakeup(&sc->sc_rsel);
		if (sc->sc_async)
			psignal(sc->sc_async, SIGIO);
d1981 38
d2022 29
a2050 15
audio_check_format(encodingp, precisionp)
	u_int *encodingp, *precisionp;
{

	if (*encodingp == AUDIO_ENCODING_LINEAR)
		switch (*precisionp) {
		case 8:
			*encodingp = AUDIO_ENCODING_PCM8;
			return (0);
		case 16:
			*encodingp = AUDIO_ENCODING_PCM16;
			return (0);
		default:
			return (EINVAL);
		}
d2052 1
a2052 1
	switch (*encodingp) {
a2054 1
	case AUDIO_ENCODING_PCM8:
d2056 1
a2056 1
		if (*precisionp != 8)
d2059 5
a2063 2
	case AUDIO_ENCODING_PCM16:
		if (*precisionp != 16)
d2066 7
d2077 3
d2084 257
d2346 3
a2348 2
	int cleared = 0, init = 0;
	int bsize, error = 0;
d2350 7
a2356 2
	mixer_ctrl_t ct;
	int s;
d2361 4
a2364 4
	if (p->sample_rate != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;
d2366 3
a2368 3
		error = hw->set_out_sr(sc->hw_hdl, p->sample_rate);
		if (error)
			return(error);
d2370 3
a2372 2
		sc->sc_50ms = 50 * hw->get_out_sr(sc->hw_hdl) / 1000;
		init = 1;
d2375 39
d2417 3
a2419 7

		error = hw->set_in_sr(sc->hw_hdl, r->sample_rate);
		if (error)
			return(error);

		sc->sc_50ms = 50 * hw->get_in_sr(sc->hw_hdl) / 1000;
		init = 1;
d2421 1
a2421 1
	if (p->encoding != ~0 || p->precision != ~0) {
d2425 4
d2430 1
a2430 15
		if (p->encoding == ~0)
			p->encoding = hw->get_encoding(sc->hw_hdl);
		if (p->precision == ~0)
			p->precision = hw->get_precision(sc->hw_hdl);
		error = audio_check_format(&p->encoding, &p->precision);
		if (error)
			return(error);
		error = hw->set_format(sc->hw_hdl, p->encoding, p->precision);
		if (error)
			return(error);

		sc->sc_pencoding = p->encoding;
		init = 1;
	}	
	if (r->encoding != ~0 || r->precision != ~0) {
d2434 7
d2442 9
a2450 5
		if (r->encoding == ~0)
			r->encoding = hw->get_encoding(sc->hw_hdl);
		if (r->precision == ~0)
			r->precision = hw->get_precision(sc->hw_hdl);
		error = audio_check_format(&r->encoding, &r->precision);
d2452 19
a2470 4
			return(error);
		error = hw->set_format(sc->hw_hdl, r->encoding, r->precision);
		if (error)
			return(error);
d2472 6
a2477 2
		sc->sc_rencoding = r->encoding;
		init = 1;
d2479 8
a2486 1
	if (p->channels != ~0) {
d2491 1
a2491 1
		error = hw->set_channels(sc->hw_hdl, p->channels);
a2493 2

		init = 1;
d2495 1
a2495 1
	if (r->channels != ~0) {
d2500 7
a2506 1
		error = hw->set_channels(sc->hw_hdl, r->channels);
a2508 2

		init = 1;
d2510 3
a2512 6
	if (p->port != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		error = hw->set_out_port(sc->hw_hdl, p->port);
d2516 4
a2519 6
	if (r->port != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		error = hw->set_in_port(sc->hw_hdl, r->port);
d2523 3
a2525 6
	if (p->gain != ~0) {
		ct.dev = hw->get_out_port(sc->hw_hdl);
		ct.type = AUDIO_MIXER_VALUE;
		ct.un.value.num_channels = 1;
		ct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = p->gain;
		error = hw->set_port(sc->hw_hdl, &ct);
d2529 6
a2534 2
	if (r->gain != ~0) {
		ct.dev = hw->get_in_port(sc->hw_hdl);
d2537 2
a2538 2
		ct.un.value.level[AUDIO_MIXER_LEVEL_MONO] = r->gain;
		error = hw->set_port(sc->hw_hdl, &ct);
d2544 2
a2545 2
		sc->pr.cb_pause = p->pause;
		if (!p->pause) {
d2547 1
a2547 1
			audiostartp(sc);
d2549 2
d2554 2
a2555 2
		sc->rr.cb_pause = r->pause;
		if (!r->pause) {
d2557 1
a2557 1
			audiostartr(sc);
d2559 2
d2570 11
a2580 22
		if (ai->blocksize == 0)
			bsize = sc->sc_blksize;
		else if (ai->blocksize > AU_RING_SIZE/2)
			bsize = AU_RING_SIZE/2;
		else
			bsize = ai->blocksize;
		bsize = hw->round_blocksize(sc->hw_hdl, bsize);
		if (bsize > AU_RING_SIZE)
			bsize = AU_RING_SIZE;

		sc->sc_blksize = bsize;
		init = 1;
	} else if (init) {
		/* Block size calculated from other parameter changes. */
		sc->sc_blksize = audio_calc_blksize(sc);
	}

	if (init) {
		audio_alloc_auzero(sc, sc->sc_blksize);
		sc->sc_smpl_in_blk = sc->sc_blksize / 
		    (hw->get_precision(sc->hw_hdl) / NBBY);
		audio_initbufs(sc);
a2582 16
	if (ai->hiwat != ~0) {
		if ((unsigned)ai->hiwat > sc->pr.maxblk)
			ai->hiwat = sc->pr.maxblk;
		if (sc->sc_hiwat != 0)
			sc->sc_hiwat = ai->hiwat;
	}
	if (ai->lowat != ~0) {
		if ((unsigned)ai->lowat > sc->pr.maxblk)
			ai->lowat = sc->pr.maxblk;
		sc->sc_lowat = ai->lowat;
	}
	if (ai->backlog != ~0) {
		if ((unsigned)ai->backlog > (sc->pr.maxblk/2))
			ai->backlog = sc->pr.maxblk/2;
		sc->sc_backlog = ai->backlog;
	}
d2584 1
a2584 6
		if (!cleared)
			audio_clear(sc);
		cleared = 1;

		sc->sc_mode = ai->mode;
		if (sc->sc_mode & AUMODE_PLAY) {
a2585 3
			if (!hw->full_duplex) /* Play takes precedence */
				sc->sc_mode &= ~(AUMODE_RECORD);
		}
d2590 5
a2594 3
	error = hw->commit_settings(sc->hw_hdl);
	if (error)
		return (error);
d2598 13
a2610 4
		if (sc->sc_mode & AUMODE_PLAY)
			audiostartp(sc);
		if (sc->sc_mode & AUMODE_RECORD)
			audiostartr(sc);
d2612 2
d2616 20
a2645 1
	mixer_ctrl_t ct;
d2650 54
a2703 17
	p->sample_rate = hw->get_out_sr(sc->hw_hdl);
	r->sample_rate = hw->get_in_sr(sc->hw_hdl);
	p->channels = r->channels = hw->get_channels(sc->hw_hdl);
	p->precision = r->precision = hw->get_precision(sc->hw_hdl);
	p->encoding = hw->get_encoding(sc->hw_hdl);
	r->encoding = hw->get_encoding(sc->hw_hdl);

	r->port = hw->get_in_port(sc->hw_hdl);
	p->port = hw->get_out_port(sc->hw_hdl);

	ct.dev = r->port;
	ct.type = AUDIO_MIXER_VALUE;
	ct.un.value.num_channels = 1;
	if (hw->get_port(sc->hw_hdl, &ct) == 0)
	    r->gain = ct.un.value.level[AUDIO_MIXER_LEVEL_MONO];
	else
	    r->gain = AUDIO_MAX_GAIN/2;
d2705 2
a2706 6
	ct.dev = p->port;
	ct.un.value.num_channels = 1;
	if (hw->get_port(sc->hw_hdl, &ct) == 0)
	    p->gain = ct.un.value.level[AUDIO_MIXER_LEVEL_MONO];
	else
	    p->gain = AUDIO_MAX_GAIN/2;
d2708 3
a2710 18
	p->pause = sc->pr.cb_pause;
	r->pause = sc->rr.cb_pause;
	p->error = sc->pr.cb_drops != 0;
	r->error = sc->rr.cb_drops != 0;

	p->open = ((sc->sc_open & AUOPEN_WRITE) != 0);
	r->open = ((sc->sc_open & AUOPEN_READ) != 0);

	p->samples = sc->pr.au_stamp - sc->pr.cb_pdrops;
	r->samples = sc->rr.au_stamp - sc->rr.cb_pdrops;

	p->seek = sc->sc_wseek;
	r->seek = sc->sc_rseek;

	ai->blocksize = sc->sc_blksize;
	ai->hiwat = sc->sc_hiwat;
	ai->lowat = sc->sc_lowat;
	ai->backlog = sc->sc_backlog;
a2726 1
	struct audio_hw_if *hw;
d2728 3
a2730 4
	if (unit >= NAUDIO || !audio_softc[unit]) {
	    DPRINTF(("mixer_open: invalid device unit - %d\n", unit));
	    return (ENODEV);
	}
d2732 2
a2733 2
	sc = audio_softc[unit];
	hw = sc->hw_if;
d2735 1
a2735 3
	DPRINTF(("mixer_open: dev=%x flags=0x%x sc=0x%x\n", dev, flags, sc));
	if (hw == 0)		/* Hardware has not attached to us... */
		return (ENXIO);
d2741 33
d2783 3
d2788 2
d2802 1
a2802 1
	struct audio_softc *sc = audio_softc[unit];
d2807 1
a2807 1
	          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff));
d2810 12
d2823 3
a2825 3
	    DPRINTF(("AUDIO_GETDEV\n"));
	    error = hw->getdev(sc->hw_hdl, (audio_device_t *)addr);
	    break;
d2828 3
a2830 3
	    DPRINTF(("AUDIO_MIXER_DEVINFO\n"));
	    error = hw->query_devinfo(sc->hw_hdl, (mixer_devinfo_t *)addr);
	    break;
d2833 3
a2835 3
	    DPRINTF(("AUDIO_MIXER_READ\n"));
	    error = hw->get_port(sc->hw_hdl, (mixer_ctrl_t *)addr);
	    break;
d2838 7
a2844 5
	    DPRINTF(("AUDIO_MIXER_WRITE\n"));
	    error = hw->set_port(sc->hw_hdl, (mixer_ctrl_t *)addr);
	    if (error == 0)
		error = hw->commit_settings(sc->hw_hdl);
	    break;
d2847 2
a2848 2
	    error = EINVAL;
	    break;
d2851 1
a2851 1
	          IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd&0xff, error));
@


1.10
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.9 1997/04/09 14:46:12 kstailey Exp $	*/
d1258 1
a1258 1
		    sc->pr.nblk < sc->sc_lowat) {
@


1.9
log
@change space to "_" in tsleep() string
@
text
@d1 1
a1 1
/*	$OpenBSD: audio.c,v 1.7 1996/04/21 22:19:38 deraadt Exp $	*/
d90 2
a116 4
int audio_blocksize;

/* A block of silence */
char *auzero_block;
d129 1
d142 1
d145 1
a145 1
void	audio_silence_fill __P((struct audio_softc *, u_char *, int));
d173 1
a173 1
		sc->sc_rblks);
d214 1
a214 1
	    hwp->set_encoding == 0 ||
a215 1
	    hwp->set_precision == 0 ||
a224 1
	    hwp->get_silence == 0 ||
d310 2
a311 1
	switch(AUDIODEV(dev)) {
d314 1
a314 2
	    return audio_open(dev, flags, ifmt, p);
	    /*NOTREACHED*/
d316 1
a316 2
	    return mixer_open(dev, flags, ifmt, p);
	    /*NOTREACHED*/
d318 1
a318 1
	    break;
a319 1
	return EIO;
a321 1
/* ARGSUSED */
d328 2
a329 1
	switch(AUDIODEV(dev)) {
d332 1
a332 2
	    return audio_close(dev, flags, ifmt, p);
	    /*NOTREACHED*/
d334 1
a334 2
	    return mixer_close(dev, flags, ifmt, p);
	    /*NOTREACHED*/
d336 1
a336 1
	    break;
a337 1
	return EIO;
d346 2
a347 1
	switch(AUDIODEV(dev)) {
d350 1
a350 2
	    return audio_read(dev, uio, ioflag);
	    /*NOTREACHED*/
d352 1
a352 2
	    return ENODEV;
	    /*NOTREACHED*/
d354 1
a354 1
	    break;
a355 1
	return EIO;
d364 2
a365 1
	switch(AUDIODEV(dev)) {
d368 1
a368 2
	    return audio_write(dev, uio, ioflag);
	    /*NOTREACHED*/
d370 1
a370 2
	    return ENODEV;
	    /*NOTREACHED*/
d372 1
a372 1
	    break;
a373 1
	return EIO;
d384 2
a385 1
	switch(AUDIODEV(dev)) {
d388 1
a388 2
	    return audio_ioctl(dev, cmd, addr, flag, p);
	    /*NOTREACHED*/
d390 1
a390 2
	    return mixer_ioctl(dev, cmd, addr, flag, p);
	    /*NOTREACHED*/
d392 1
a392 1
	    break;
a393 1
	return EIO;
d397 1
a397 1
audioselect(dev, rw, p)
d399 1
a399 1
	int rw;
d402 2
a403 1
	switch(AUDIODEV(dev)) {
d406 1
a406 2
	    return audio_select(dev, rw, p);
	    /*NOTREACHED*/
d408 1
a408 2
	    return 1;
	    /*NOTREACHED*/
d410 18
a427 1
	    break;
a428 1
	return EIO;
d540 1
a540 2
		hw->set_precision(sc->hw_hdl, 8);
		hw->set_encoding(sc->hw_hdl, AUDIO_ENCODING_ULAW);
d545 1
a545 2
		sc->sc_pencoding = AUDIO_ENCODING_ULAW;
		sc->sc_rencoding = AUDIO_ENCODING_ULAW;
d557 3
a559 1
	sc->sc_blksize = audio_blocksize = audio_calc_blksize(sc);
d561 1
a561 2
	    
	sc->sc_smpl_in_blk = audio_blocksize / 
d563 2
a564 1
	sc->sc_50ms = 50 * hw->get_out_sr(sc->hw_hdl) / 1000;
a566 1
	audio_initbufs(sc);
d609 2
d706 1
d841 2
a842 2
audio_silence_fill(sc, p, n)
	struct audio_softc *sc;
a845 1
	struct audio_hw_if *hw = sc->hw_if;
d847 17
a863 3

	auzero = hw->get_silence(sc->sc_pencoding);

d865 1
a865 1
	    *p++ = auzero;
d868 1
a874 1
	struct audio_hw_if *hw = sc->hw_if;
d877 2
a878 1
	u_int auzero;
d880 1
a880 1
	auzero = hw->get_silence(sc->sc_rencoding);
d889 1
d892 1
a892 1
			error = copyout(&auzero, iov->iov_base, 1);
d898 1
a898 1
                        bcopy(&auzero, iov->iov_base, 1);
d901 5
a905 5
                iov->iov_base++;
                iov->iov_len--;
                uio->uio_resid--;
                uio->uio_offset++;
                n--;
a915 5
	u_char *p, silence;
	int i;
	
	if (auzero_block)
		free(auzero_block, M_DEVBUF);
d917 4
a920 1
	auzero_block = malloc(bs, M_DEVBUF, M_WAITOK);
d922 1
a922 1
	if (auzero_block == 0) {
d926 1
a926 6
	silence = hw->get_silence(sc->sc_pencoding);

	p = auzero_block;
	for (i = 0; i < bs; i++)
		*p++ = silence;

d928 1
a928 1
		hw->sw_encode(sc->hw_hdl, sc->sc_pencoding, auzero_block, bs);
d960 26
d1020 1
a1020 1
			audio_silence_fill(sc, cb->hp, sc->sc_backlog * blocksize);
d1057 3
a1059 1
				audio_silence_fill(sc, tp, cc);
d1077 3
a1079 3
		if (hw->sw_encode) {
			hw->sw_encode(sc->hw_hdl, sc->sc_pencoding, cb->tp, blocksize);
		}
d1269 9
d1393 1
a1393 1
		    Dprintf("audio_pint: drops=%d auzero %d 0x%x\n", cb->cb_drops, cc, *(int *)auzero_block);
d1397 1
a1397 1
		    			 auzero_block, cc,
d1492 36
d1533 2
a1534 2
	int cleared = 0;
	int bsize, bps, error = 0;
d1537 1
d1546 1
d1550 1
d1552 1
d1558 1
d1562 1
d1564 1
d1566 1
a1566 1
	if (p->encoding != ~0) {
d1570 9
a1578 1
		error = hw->set_encoding(sc->hw_hdl, p->encoding);
d1581 1
d1583 1
d1585 1
a1585 1
	if (r->encoding != ~0) {
d1589 6
a1594 1
		error = hw->set_encoding(sc->hw_hdl, r->encoding);
d1597 1
a1597 7
		sc->sc_rencoding = r->encoding;
	}
	if (p->precision != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;
		error = hw->set_precision(sc->hw_hdl, p->precision);
d1600 3
a1602 20
		
		sc->sc_blksize = audio_blocksize = audio_calc_blksize(sc);
		audio_alloc_auzero(sc, sc->sc_blksize);
		bps = hw->get_precision(sc->hw_hdl) / NBBY;
		sc->sc_smpl_in_blk = sc->sc_blksize / bps;
		audio_initbufs(sc);
	}
	if (r->precision != ~0) {
		if (!cleared)
			audio_clear(sc);
		cleared = 1;
		error = hw->set_precision(sc->hw_hdl, r->precision);
		if (error)
			return(error);
		
		sc->sc_blksize = audio_blocksize = audio_calc_blksize(sc);
		audio_alloc_auzero(sc, sc->sc_blksize);
		bps = hw->get_precision(sc->hw_hdl) / NBBY;
		sc->sc_smpl_in_blk = sc->sc_blksize / bps;
		audio_initbufs(sc);
d1608 1
d1613 1
a1613 5
		sc->sc_blksize = audio_blocksize = audio_calc_blksize(sc);
		audio_alloc_auzero(sc, sc->sc_blksize);
		bps = hw->get_precision(sc->hw_hdl) / NBBY;
		sc->sc_smpl_in_blk = sc->sc_blksize / bps;
		audio_initbufs(sc);
d1619 1
d1624 1
a1624 5
		sc->sc_blksize = audio_blocksize = audio_calc_blksize(sc);
		audio_alloc_auzero(sc, sc->sc_blksize);
		bps = hw->get_precision(sc->hw_hdl) / NBBY;
		sc->sc_smpl_in_blk = sc->sc_blksize / bps;
		audio_initbufs(sc);
d1630 1
d1639 1
d1666 1
a1666 1
		    int s = splaudio();
d1668 1
a1668 1
		    splx(s);
d1674 1
a1674 1
		    int s = splaudio();
d1676 1
a1676 1
		    splx(s);
d1680 2
a1681 2
	if (ai->blocksize != ~0) { /* Explicitly specified, possibly */
				   /* overriding changes done above. */
d1685 1
d1687 1
a1687 1
			bsize = audio_blocksize;
d1695 9
a1703 1
		ai->blocksize = sc->sc_blksize = bsize;
d1705 2
a1706 2
		bps = hw->get_precision(sc->hw_hdl) / NBBY;
		sc->sc_smpl_in_blk = bsize / bps;
d1709 1
d1730 1
d1740 1
d1746 1
a1746 1
		int s = splaudio();
@


1.8
log
@sync 0521
@
text
@d658 1
a658 1
		error = audio_sleep_timo(&sc->sc_wchan, "aud dr", 60*hz);
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: audio.c,v 1.6 1996/04/18 23:46:55 niklas Exp $	*/
/*	$NetBSD: audio.c,v 1.24 1996/03/30 22:51:23 christos Exp $	*/
d82 1
a83 1
#include <sys/audioio.h>
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: audio.c,v 1.5 1996/03/02 00:29:19 niklas Exp $	*/
/*	$NetBSD: audio.c,v 1.22 1996/03/14 19:08:32 christos Exp $	*/
d81 1
a88 4
#ifndef TOLOG
#define TOLOG	0x04
#endif
void kprintf __P((const char *fmt, int flags, struct tty *tp, va_list ap));
d101 1
a101 1
	kprintf(fmt, TOLOG, NULL, ap);
a151 6
int	audioopen __P((dev_t, int, int, struct proc *));
int	audioclose __P((dev_t, int, int, struct proc *));
int	audioread __P((dev_t, struct uio *, int));
int	audiowrite __P((dev_t, struct uio *, int));
int	audioioctl __P((dev_t, int, caddr_t, int, struct proc *));
int	audioselect __P((dev_t, int, struct proc *));
d165 1
a165 1
	printf("hwhandle %x hw_if %x ", sc->hw_hdl, sc->hw_if);
d390 1
a390 1
	int cmd;
d996 1
a996 1
		    Dprintf("audio_write: cc=%d tp=0x%x bs=%d nblk=%d left=%d\n", cc, tp, blocksize, cb->nblk, left);
d1005 1
a1005 1
			DPRINTF(("audio_write: overwrite tp=0x%x towrite=%d ep=0x%x bs=%d\n",
d1032 1
a1032 1
		        printf("audio_write:(1) uiomove failed %d; cc=%d tp=0x%x bs=%d\n", error, cc, tp, blocksize);
d1235 1
a1235 1
    	DPRINTF(("audiostartr: tp=0x%x\n", sc->rr.tp));
d1411 1
a1411 1
				Dprintf("audio_rint: tp=0x%x cc=%d\n", tp, cc);
@


1.5
log
@From NetBSD: sync with 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: audio.c,v 1.20 1996/02/20 11:47:22 mycroft Exp $	*/
d80 1
d143 3
a145 3
void	audio_rint __P((struct audio_softc *));
void	audio_pint __P((struct audio_softc *));
void	audio_rpint __P((struct audio_softc *));
d152 17
d171 2
a172 1
audio_printsc(struct audio_softc *sc)
a199 1
	int *zp, i;
d468 1
a468 1
static inline int
d488 1
a488 1
static inline int
d496 1
a496 1
static inline void
a851 1
	int i;
d860 1
d1016 1
a1016 1
			printf("audio_write: overwrite tp=0x%x towrite=%d ep=0x%x\n",
d1242 1
a1242 1
	int err;
d1246 4
a1249 3
	if (err = sc->hw_if->start_input(sc->hw_hdl, sc->rr.tp, sc->sc_blksize,
	    				 audio_rint, (void *)sc)) {
		DPRINTF(("audiostartr failed: %d\n", err));
d1260 1
a1260 1
	int rval;
d1266 4
a1269 3
		if (rval = sc->hw_if->start_output(sc->hw_hdl, hp, sc->sc_blksize,
		    				   audio_rpint, (void *)sc)) {
		    	DPRINTF(("audiostartp: failed: %d\n", rval));
d1286 2
a1287 2
audio_rpint(sc)
	struct audio_softc *sc;
d1289 1
a1289 1

d1291 1
a1291 1
	audio_pint(sc);		/* 'twas a real audio block */
d1301 2
a1302 2
audio_pint(sc)
	struct audio_softc *sc;
d1304 1
d1309 1
a1309 1
	int err;
d1332 4
a1335 3
		    if (err = hw->start_output(sc->hw_hdl, hp, cc,
					       audio_rpint, (void *)sc)) {
			    DPRINTF(("audio_pint restart failed: %d\n", err));
d1356 5
a1360 4
		if (err = hw->start_output(sc->hw_hdl,
		    			   auzero_block, cc,
					   audio_pint, (void *)sc)) {
			DPRINTF(("audio_pint zero failed: %d\n", err));
d1398 2
a1399 2
audio_rint(sc)
	struct audio_softc *sc;
d1401 1
d1406 1
a1406 1
	int err;
d1422 5
a1426 3
			if (err = hw->start_input(sc->hw_hdl, tp, cc,
						  audio_rint, (void *)sc)) {
				DPRINTF(("audio_rint: start failed: %d\n", err));
@


1.4
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: audio.c,v 1.17 1996/02/16 02:25:43 mycroft Exp $	*/
d629 1
a629 1
	sc->sc_rblks = 0;
d650 1
a650 1
		if (error != 0)
d741 1
a741 1
				if (error != 0) {
d750 1
d752 1
d768 1
a768 1
			if (error != 0)
d801 1
d1034 13
a1046 4
		if (tp >= cb->ep)
			tp = cb->bp;
		cb->tp = tp;
		++cb->nblk;	/* account for buffer filled */
d1048 6
a1053 5
		/*
		 * If output isn't active, start it up.
		 */
		if (sc->sc_pbus == 0)
			audiostartp(sc);
d1076 9
d1100 1
a1100 1
	 * Number of read samples dropped.  We don't know where or
d1104 5
a1108 1
		*(int *)addr = sc->rr.cb_drops != 0;
d1339 2
a1340 1
		}
d1351 2
d1364 2
d1420 2
d1444 1
a1444 1
		if (error != 0)
d1453 1
a1453 1
		if (error != 0)
d1462 1
a1462 1
		if (error != 0)
d1471 1
a1471 1
		if (error != 0)
d1480 1
a1480 1
		if (error != 0)
d1494 1
a1494 1
		if (error != 0)
d1508 1
a1508 1
		if (error != 0)
d1522 1
a1522 1
		if (error != 0)
d1536 1
a1536 1
		if (error != 0)
d1544 1
a1544 1
		if (error != 0)
d1552 3
a1554 1
		hw->set_port(sc->hw_hdl, &ct);
d1561 3
a1563 1
		hw->set_port(sc->hw_hdl, &ct);
d1633 1
a1633 1
	if (error != 0)
@


1.3
log
@from netbsd; Make the block size always a whole number of samples
@
text
@d1 2
a2 1
/*	$NetBSD: audio.c,v 1.14 1996/01/07 06:21:02 mycroft Exp $	*/
d144 1
d446 2
a447 5
	sc->sc_lowat = 1;
	if (nblk == 1)
	  sc->sc_hiwat = 1;
	else
	  sc->sc_hiwat = nblk - sc->sc_lowat;
d936 9
a944 12
		int watermark = sc->sc_hiwat;
		while (cb->nblk > watermark) {
			DPRINTF(("audio_write: nblk=%d watermark=%d\n", cb->nblk, watermark));
			if (ioflag & IO_NDELAY) {
				error = EWOULDBLOCK;
				return (error);
			}
			error = audio_sleep(&sc->sc_wchan, "aud wr");
			if (error != 0) {
				return (error);
			}
			watermark = sc->sc_lowat;
d1222 1
a1222 1
		    				   audio_pint, (void *)sc)) {
d1236 13
d1270 1
a1270 1
	if (--cb->nblk > 0) {
d1286 1
a1286 1
					       audio_pint, (void *)sc)) {
@


1.2
log
@provide floor for sampling rate; from khym@@bga.com; netbsd pr#1770
@
text
@d1 1
a1 1
/*	$NetBSD: audio.c,v 1.11 1995/07/19 19:58:16 brezak Exp $	*/
a33 1
 *
d811 3
a813 2
	bs =  hw->get_precision(sc->hw_hdl) / NBBY;
	bs =  hw->get_out_sr(sc->hw_hdl) * audio_blk_ms * bs / 1000;
d815 1
a821 3
	bs &= ~1;		/* make it even, in case of stereo  */
	if (bs == 0)
		bs = 2;
@


1.1
log
@Initial revision
@
text
@d822 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
