head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.14.0.4
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.16
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.6.0.6
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.4
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2016.06.07.01.31.54;	author tedu;	state Exp;
branches;
next	1.15;
commitid	37V3kDRiYRccnYvB;

1.15
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2015.02.10.21.58.16;	author miod;	state Exp;
branches;
next	1.13;
commitid	8W7jyIoa34bQUU1a;

1.13
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.12;
commitid	C5iGb36LQxjM60Q3;

1.12
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.15.03.34.33;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.02.04.12.35;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.28.16.43.49;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.28.01.33.50;	author mk;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.08.18.57.38;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.15.18.58.59;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.30.05.36.32;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.05.19.40.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.05.19.39.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.30.08.11.26;	author grange;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.16
log
@per trending style, add continue to empty loops.
ok mglocker
@
text
@/*	$OpenBSD: hotplug.c,v 1.15 2015/03/14 03:38:46 jsg Exp $	*/
/*
 * Copyright (c) 2004 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Device attachment and detachment notifications.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/fcntl.h>
#include <sys/hotplug.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/vnode.h>

#define HOTPLUG_MAXEVENTS	64

static int opened;
static struct hotplug_event evqueue[HOTPLUG_MAXEVENTS];
static int evqueue_head, evqueue_tail, evqueue_count;
static struct selinfo hotplug_sel;

void filt_hotplugrdetach(struct knote *);
int  filt_hotplugread(struct knote *, long);

struct filterops hotplugread_filtops =
	{ 1, NULL, filt_hotplugrdetach, filt_hotplugread};

#define EVQUEUE_NEXT(p) (p == HOTPLUG_MAXEVENTS - 1 ? 0 : p + 1)


int hotplug_put_event(struct hotplug_event *);
int hotplug_get_event(struct hotplug_event *);

void hotplugattach(int);

void
hotplugattach(int count)
{
	opened = 0;
	evqueue_head = 0;
	evqueue_tail = 0;
	evqueue_count = 0;
}

void
hotplug_device_attach(enum devclass class, char *name)
{
	struct hotplug_event he;

	he.he_type = HOTPLUG_DEVAT;
	he.he_devclass = class;
	strlcpy(he.he_devname, name, sizeof(he.he_devname));
	hotplug_put_event(&he);
}

void
hotplug_device_detach(enum devclass class, char *name)
{
	struct hotplug_event he;

	he.he_type = HOTPLUG_DEVDT;
	he.he_devclass = class;
	strlcpy(he.he_devname, name, sizeof(he.he_devname));
	hotplug_put_event(&he);
}

int
hotplug_put_event(struct hotplug_event *he)
{
	if (evqueue_count == HOTPLUG_MAXEVENTS && opened) {
		printf("hotplug: event lost, queue full\n");
		return (1);
	}

	evqueue[evqueue_head] = *he;
	evqueue_head = EVQUEUE_NEXT(evqueue_head);
	if (evqueue_count == HOTPLUG_MAXEVENTS)
		evqueue_tail = EVQUEUE_NEXT(evqueue_tail);
	else 
		evqueue_count++;
	wakeup(&evqueue);
	selwakeup(&hotplug_sel);
	return (0);
}

int
hotplug_get_event(struct hotplug_event *he)
{
	int s;

	if (evqueue_count == 0)
		return (1);

	s = splbio();
	*he = evqueue[evqueue_tail];
	evqueue_tail = EVQUEUE_NEXT(evqueue_tail);
	evqueue_count--;
	splx(s);
	return (0);
}

int
hotplugopen(dev_t dev, int flag, int mode, struct proc *p)
{
	if (minor(dev) != 0)
		return (ENXIO);
	if ((flag & FWRITE))
		return (EPERM);
	if (opened)
		return (EBUSY);
	opened = 1;
	return (0);
}

int
hotplugclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct hotplug_event he;

	while (hotplug_get_event(&he) == 0)
		continue;
	opened = 0;
	return (0);
}

int
hotplugread(dev_t dev, struct uio *uio, int flags)
{
	struct hotplug_event he;
	int error;

	if (uio->uio_resid != sizeof(he))
		return (EINVAL);

again:
	if (hotplug_get_event(&he) == 0)
		return (uiomove(&he, sizeof(he), uio));
	if (flags & IO_NDELAY)
		return (EAGAIN);

	error = tsleep(&evqueue, PRIBIO | PCATCH, "htplev", 0);
	if (error)
		return (error);
	goto again;
}

int
hotplugioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	case FIOASYNC:
		/* ignore */
	case FIONBIO:
		/* handled in the upper fs layer */
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}

int
hotplugpoll(dev_t dev, int events, struct proc *p)
{
	int revents = 0;

	if (events & (POLLIN | POLLRDNORM)) {
		if (evqueue_count > 0)
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &hotplug_sel);
	}

	return (revents);
}

int
hotplugkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &hotplug_sel.si_note;
		kn->kn_fop = &hotplugread_filtops;
		break;
	default:
		return (EINVAL);
	}

	s = splbio();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);
	return (0);
}

void
filt_hotplugrdetach(struct knote *kn)
{
	int s;

	s = splbio();
	SLIST_REMOVE(&hotplug_sel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_hotplugread(struct knote *kn, long hint)
{
	kn->kn_data = evqueue_count;

	return (evqueue_count > 0);
}
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.14 2015/02/10 21:58:16 miod Exp $	*/
d137 1
a137 1
		;
@


1.14
log
@Switch uiomovei(..., sizeof whatever, ...) to uiomove().
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.13 2015/02/10 21:56:09 miod Exp $	*/
a23 1
#include <sys/conf.h>
@


1.13
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.12 2011/07/02 22:20:07 nicm Exp $	*/
d154 1
a154 1
		return (uiomovei(&he, sizeof(he), uio));
@


1.12
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.11 2010/12/15 03:34:33 tedu Exp $	*/
d154 1
a154 1
		return (uiomove(&he, sizeof(he), uio));
@


1.11
log
@revert the malloc change, as it meant dropping events before the device is
opened.  keep the array expansion.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.10 2010/12/02 04:12:35 tedu Exp $	*/
d207 1
a207 1
		return (1);
@


1.10
log
@make hotplug queue dynamic, allowing us to increase size without waste.
ok deraadt kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.9 2009/11/09 17:53:39 nicm Exp $	*/
a28 1
#include <sys/malloc.h>
d35 1
a35 1
static struct hotplug_event *evqueue;
a90 2
	if (!evqueue)
		return (1);
a121 2
	struct hotplug_event *q;

a127 8
	if (!evqueue) {
		q = malloc(sizeof(*q) * HOTPLUG_MAXEVENTS, M_DEVBUF, M_WAITOK);
		if (opened) {
			free(q, M_DEVBUF);
			return (EBUSY);
		}
		evqueue = q;
	}
@


1.9
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.8 2006/05/28 16:43:49 mk Exp $	*/
d29 1
d33 1
a33 1
#define HOTPLUG_MAXEVENTS	16
d36 1
a36 1
static struct hotplug_event evqueue[HOTPLUG_MAXEVENTS];
d92 2
d125 2
d133 8
d171 1
a171 1
	error = tsleep(evqueue, PRIBIO | PCATCH, "htplev", 0);
@


1.8
log
@Remove device id from hotplug events.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.7 2006/05/28 01:33:50 mk Exp $	*/
a99 1
	KNOTE(&hotplug_sel.si_note, 0);
@


1.7
log
@Include device id in hotplug events.  This will be used by ntpd to check
sensors on attach/detach.  hotplugd changes following in a minute.

ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.6 2004/10/08 18:57:38 drahn Exp $	*/
d63 1
a63 1
hotplug_device_attach(enum devclass class, char *name, int id)
a66 1
	he.he_devid = id;
d74 1
a74 1
hotplug_device_detach(enum devclass class, char *name, int id)
a77 1
	he.he_devid = id;
@


1.6
log
@If the hotplug queue is full, bump the tail pointer in the circular buffer.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.5 2004/09/15 18:58:59 grange Exp $	*/
d63 1
a63 1
hotplug_device_attach(enum devclass class, char *name)
d67 1
d75 1
a75 1
hotplug_device_detach(enum devclass class, char *name)
d79 1
@


1.5
log
@Return the ability to queue events before hotplugd started.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.4 2004/07/30 05:36:32 miod Exp $	*/
d94 4
a97 1
	evqueue_count++;
@


1.4
log
@Correctly drain event queue on close. Fixes PR #3874
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.3 2004/07/05 19:40:38 deraadt Exp $	*/
d87 1
a87 4
	if (opened == 0)
		return (0);

	if (evqueue_count == HOTPLUG_MAXEVENTS) {
@


1.3
log
@clean & knf
@
text
@d1 1
a1 1
/*	$OpenBSD: hotplug.c,v 1.1 2004/05/30 08:11:26 grange Exp $	*/
d138 1
a138 1
	while (hotplug_get_event(&he) == 1)
@


1.2
log
@do not queue events when no daemon running.  flush all events on last close.
ok tedu
@
text
@a69 1

a80 1

a100 1

d107 2
d112 1
d116 1
a116 1

a129 1

a140 1

d154 1
a154 1
	if (hotplug_get_event(&he) == 0) {
d156 1
a156 3
	}

	if (flags & IO_NDELAY) {
a157 1
	}
d160 1
a160 1
	if (error) {
a161 1
	}
a213 1

@


1.1
log
@Devices hot plugging support.
The hotplug pseudo-device passes device attachment and detachment events
to userland.  When a device attaches or detaches, the corresponding event
is queued.  The events can then be obtained from the queue through the
read(2) call on the /dev/hotplug device file. Each event consists of
event type (attach/detach), device class (DV_*) and device name (sd1 e.g.).

We have hotplug pseudo-device on alpha, amd64, i386, macppc and sparc64.
Since it was tested only on i386 other archs has it commented out
in GENERIC until tested.

The idea liked peter@@ tedu@@ drahn@@ millert@@ marco@@ henning@@.
Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 3
d137 4
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

