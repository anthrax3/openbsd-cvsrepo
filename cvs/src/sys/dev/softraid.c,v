head	1.382;
access;
symbols
	OPENBSD_6_1:1.379.0.4
	OPENBSD_6_1_BASE:1.379
	OPENBSD_6_0:1.377.0.2
	OPENBSD_6_0_BASE:1.377
	OPENBSD_5_9:1.366.0.2
	OPENBSD_5_9_BASE:1.366
	OPENBSD_5_8:1.363.0.4
	OPENBSD_5_8_BASE:1.363
	OPENBSD_5_7:1.349.0.4
	OPENBSD_5_7_BASE:1.349
	OPENBSD_5_6:1.338.0.2
	OPENBSD_5_6_BASE:1.338
	OPENBSD_5_5:1.331.0.4
	OPENBSD_5_5_BASE:1.331
	OPENBSD_5_4:1.311.0.2
	OPENBSD_5_4_BASE:1.311
	OPENBSD_5_3:1.288.0.2
	OPENBSD_5_3_BASE:1.288
	OPENBSD_5_2:1.274.0.4
	OPENBSD_5_2_BASE:1.274
	OPENBSD_5_1_BASE:1.274
	OPENBSD_5_1:1.274.0.2
	OPENBSD_5_0:1.246.0.2
	OPENBSD_5_0_BASE:1.246
	OPENBSD_4_9:1.221.0.2
	OPENBSD_4_9_BASE:1.221
	OPENBSD_4_8:1.210.0.2
	OPENBSD_4_8_BASE:1.210
	OPENBSD_4_7:1.194.0.2
	OPENBSD_4_7_BASE:1.194
	OPENBSD_4_6:1.161.0.4
	OPENBSD_4_6_BASE:1.161
	OPENBSD_4_5:1.127.0.2
	OPENBSD_4_5_BASE:1.127
	OPENBSD_4_4:1.119.0.2
	OPENBSD_4_4_BASE:1.119
	OPENBSD_4_3:1.104.0.2
	OPENBSD_4_3_BASE:1.104
	OPENBSD_4_2:1.82.0.2
	OPENBSD_4_2_BASE:1.82;
locks; strict;
comment	@ * @;


1.382
date	2017.06.12.15.43.25;	author jsing;	state Exp;
branches;
next	1.381;
commitid	7x1SDOeNw256z7o8;

1.381
date	2017.06.06.19.01.27;	author krw;	state Exp;
branches;
next	1.380;
commitid	AbWoGvNep8Ol1O4k;

1.380
date	2017.04.14.15.11.31;	author bluhm;	state Exp;
branches;
next	1.379;
commitid	0ifmKLHPmgcK2529;

1.379
date	2017.03.27.17.42.19;	author deraadt;	state Exp;
branches;
next	1.378;
commitid	lAc3eJjCchEB5Ep3;

1.378
date	2017.03.19.16.01.08;	author tb;	state Exp;
branches;
next	1.377;
commitid	tGb4wtGdB4gOMn8S;

1.377
date	2016.07.20.20.45.13;	author krw;	state Exp;
branches;
next	1.376;
commitid	UDn0VaO9os11UzJp;

1.376
date	2016.05.31.15.19.12;	author jsing;	state Exp;
branches;
next	1.375;
commitid	cwFTIUrXuiupYWGN;

1.375
date	2016.04.29.14.01.37;	author krw;	state Exp;
branches;
next	1.374;
commitid	xJXoq4euXlxN5KOP;

1.374
date	2016.04.26.13.42.39;	author krw;	state Exp;
branches;
next	1.373;
commitid	6u4lCk9y5S64nv66;

1.373
date	2016.04.26.13.38.24;	author krw;	state Exp;
branches;
next	1.372;
commitid	iZVjgDUo9httsm0X;

1.372
date	2016.04.26.13.22.16;	author krw;	state Exp;
branches;
next	1.371;
commitid	dHFuEDNyml9S7snM;

1.371
date	2016.04.19.21.47.56;	author krw;	state Exp;
branches;
next	1.370;
commitid	PjzjRwAxZXoRDxg8;

1.370
date	2016.04.19.21.40.48;	author krw;	state Exp;
branches;
next	1.369;
commitid	0C35HpFqr5smnTab;

1.369
date	2016.04.19.21.19.58;	author krw;	state Exp;
branches;
next	1.368;
commitid	PzIayIniUseZIQmm;

1.368
date	2016.04.12.16.26.54;	author krw;	state Exp;
branches;
next	1.367;
commitid	ATfj2h1H9b585gss;

1.367
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.366;
commitid	1ISokwrtQ24zRrhW;

1.366
date	2016.02.14.12.47.27;	author krw;	state Exp;
branches;
next	1.365;
commitid	vBSS0cfom5SO57fr;

1.365
date	2015.12.29.04.46.28;	author mmcc;	state Exp;
branches;
next	1.364;
commitid	QKSTqnEw1KIrhSLM;

1.364
date	2015.08.19.19.05.24;	author krw;	state Exp;
branches;
next	1.363;
commitid	E4XBb5rIeFmzI9iR;

1.363
date	2015.07.29.12.58.16;	author krw;	state Exp;
branches;
next	1.362;
commitid	0S4rpK3pWZ69Z0E4;

1.362
date	2015.07.28.15.42.23;	author krw;	state Exp;
branches;
next	1.361;
commitid	69Quj6akhwKmFLgv;

1.361
date	2015.07.27.04.11.58;	author halex;	state Exp;
branches;
next	1.360;
commitid	DIYFP8pVQzzZj4ER;

1.360
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.359;
commitid	TJiPw62Nfq0KhqBx;

1.359
date	2015.07.20.18.27.36;	author mlarkin;	state Exp;
branches;
next	1.358;
commitid	lLIVxF9KfcfzI4SQ;

1.358
date	2015.07.19.18.24.16;	author krw;	state Exp;
branches;
next	1.357;
commitid	soWovNPxU9gU33mQ;

1.357
date	2015.07.19.18.03.03;	author krw;	state Exp;
branches;
next	1.356;
commitid	mqOfHwE1KnLpNRix;

1.356
date	2015.07.19.17.04.31;	author krw;	state Exp;
branches;
next	1.355;
commitid	WthDQr0yYlXab4V8;

1.355
date	2015.07.19.16.12.10;	author krw;	state Exp;
branches;
next	1.354;
commitid	Dc93N2P6UBq5IEZc;

1.354
date	2015.05.29.13.48.45;	author krw;	state Exp;
branches;
next	1.353;
commitid	4T685JZ45NUupSv2;

1.353
date	2015.05.20.15.21.57;	author pelikan;	state Exp;
branches;
next	1.352;
commitid	fJdCn9XC3nZtTYhD;

1.352
date	2015.05.11.12.24.06;	author pelikan;	state Exp;
branches;
next	1.351;
commitid	s3OxZGtHZN6uMliY;

1.351
date	2015.04.11.17.10.17;	author jsing;	state Exp;
branches;
next	1.350;
commitid	a6KWLRyWf2ABBYYE;

1.350
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.349;
commitid	p4LJxGKbi0BU2cG6;

1.349
date	2015.02.09.03.15.41;	author dlg;	state Exp;
branches;
next	1.348;
commitid	jVd0KngVszV2FEfg;

1.348
date	2015.01.27.03.17.35;	author dlg;	state Exp;
branches;
next	1.347;
commitid	MyKPm9Q3dQu92BiX;

1.347
date	2014.12.19.17.15.16;	author tedu;	state Exp;
branches;
next	1.346;
commitid	xhVw3ZjvZRpIXwAb;

1.346
date	2014.12.16.19.51.33;	author tedu;	state Exp;
branches;
next	1.345;
commitid	a8J7nItA1nFtAfF2;

1.345
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.344;
commitid	P6Av4XGqOi3rFasL;

1.344
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.343;
commitid	Z1vcFtHO8wRH0yRt;

1.343
date	2014.10.30.19.07.54;	author tedu;	state Exp;
branches;
next	1.342;
commitid	CbwxHINFLzA6QecA;

1.342
date	2014.10.30.17.23.45;	author tedu;	state Exp;
branches;
next	1.341;
commitid	dxRuG7Wc0MTa8cji;

1.341
date	2014.10.07.20.23.32;	author tedu;	state Exp;
branches;
next	1.340;
commitid	1hbxZJRSxjvGk5Dm;

1.340
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.339;
commitid	uzzBR7hz9ncd4O6G;

1.339
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.338;
commitid	jdBY2kKXhfcoQitp;

1.338
date	2014.08.01.01.32.09;	author jsing;	state Exp;
branches;
next	1.337;
commitid	Kk5m2bPMLupkauzo;

1.337
date	2014.07.20.18.10.15;	author deraadt;	state Exp;
branches;
next	1.336;
commitid	hpaSQZfWngIImDRA;

1.336
date	2014.07.20.18.05.21;	author mlarkin;	state Exp;
branches;
next	1.335;
commitid	F1K1yInguabWnn54;

1.335
date	2014.07.13.23.10.23;	author deraadt;	state Exp;
branches;
next	1.334;
commitid	JtO5uXxVcnZfhUkR;

1.334
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.333;
commitid	OBNa5kfxQ2UXoiIw;

1.333
date	2014.07.12.07.39.11;	author blambert;	state Exp;
branches;
next	1.332;
commitid	d0e1MLWWcCZIgJ1z;

1.332
date	2014.07.10.12.21.09;	author mpi;	state Exp;
branches;
next	1.331;
commitid	rMrMHPG4SqHlsP5W;

1.331
date	2014.01.22.23.32.42;	author jsing;	state Exp;
branches;
next	1.330;

1.330
date	2014.01.22.09.42.13;	author jsing;	state Exp;
branches;
next	1.329;

1.329
date	2014.01.22.09.03.19;	author jsing;	state Exp;
branches;
next	1.328;

1.328
date	2014.01.22.05.42.39;	author jsing;	state Exp;
branches;
next	1.327;

1.327
date	2014.01.22.05.11.36;	author jsing;	state Exp;
branches;
next	1.326;

1.326
date	2014.01.22.04.24.29;	author jsing;	state Exp;
branches;
next	1.325;

1.325
date	2014.01.21.06.42.52;	author jsing;	state Exp;
branches;
next	1.324;

1.324
date	2014.01.21.04.23.14;	author jsing;	state Exp;
branches;
next	1.323;

1.323
date	2014.01.21.03.50.44;	author jsing;	state Exp;
branches;
next	1.322;

1.322
date	2014.01.21.03.27.38;	author jsing;	state Exp;
branches;
next	1.321;

1.321
date	2014.01.20.04.47.31;	author jsing;	state Exp;
branches;
next	1.320;

1.320
date	2014.01.20.00.11.50;	author jsing;	state Exp;
branches;
next	1.319;

1.319
date	2014.01.19.22.21.39;	author jsing;	state Exp;
branches;
next	1.318;

1.318
date	2014.01.18.09.33.53;	author jsing;	state Exp;
branches;
next	1.317;

1.317
date	2014.01.18.09.23.26;	author jsing;	state Exp;
branches;
next	1.316;

1.316
date	2014.01.18.09.01.01;	author jsing;	state Exp;
branches;
next	1.315;

1.315
date	2014.01.05.15.03.57;	author jsing;	state Exp;
branches;
next	1.314;

1.314
date	2013.11.19.15.12.13;	author krw;	state Exp;
branches;
next	1.313;

1.313
date	2013.11.04.21.02.57;	author deraadt;	state Exp;
branches;
next	1.312;

1.312
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.311;

1.311
date	2013.07.19.17.14.13;	author krw;	state Exp;
branches;
next	1.310;

1.310
date	2013.07.01.11.33.21;	author jsing;	state Exp;
branches;
next	1.309;

1.309
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.308;

1.308
date	2013.05.21.15.21.16;	author jsing;	state Exp;
branches;
next	1.307;

1.307
date	2013.05.21.15.15.43;	author jsing;	state Exp;
branches;
next	1.306;

1.306
date	2013.05.21.15.01.52;	author jsing;	state Exp;
branches;
next	1.305;

1.305
date	2013.05.21.14.36.10;	author jsing;	state Exp;
branches;
next	1.304;

1.304
date	2013.05.21.14.30.00;	author jsing;	state Exp;
branches;
next	1.303;

1.303
date	2013.05.21.14.25.23;	author jsing;	state Exp;
branches;
next	1.302;

1.302
date	2013.04.26.15.45.35;	author jsing;	state Exp;
branches;
next	1.301;

1.301
date	2013.04.23.12.49.52;	author jsing;	state Exp;
branches;
next	1.300;

1.300
date	2013.04.21.13.00.21;	author jsing;	state Exp;
branches;
next	1.299;

1.299
date	2013.03.31.15.46.11;	author jsing;	state Exp;
branches;
next	1.298;

1.298
date	2013.03.31.11.37.40;	author jsing;	state Exp;
branches;
next	1.297;

1.297
date	2013.03.31.11.30.59;	author jsing;	state Exp;
branches;
next	1.296;

1.296
date	2013.03.31.11.12.06;	author jsing;	state Exp;
branches;
next	1.295;

1.295
date	2013.03.30.14.41.36;	author jsing;	state Exp;
branches;
next	1.294;

1.294
date	2013.03.30.02.02.13;	author jsing;	state Exp;
branches;
next	1.293;

1.293
date	2013.03.29.12.00.59;	author jsing;	state Exp;
branches;
next	1.292;

1.292
date	2013.03.29.11.46.43;	author jsing;	state Exp;
branches;
next	1.291;

1.291
date	2013.03.25.16.01.48;	author jsing;	state Exp;
branches;
next	1.290;

1.290
date	2013.03.10.09.05.12;	author jsing;	state Exp;
branches;
next	1.289;

1.289
date	2013.03.05.10.24.00;	author jsing;	state Exp;
branches;
next	1.288;

1.288
date	2013.01.18.23.19.44;	author jsing;	state Exp;
branches;
next	1.287;

1.287
date	2013.01.18.09.56.52;	author jsing;	state Exp;
branches;
next	1.286;

1.286
date	2013.01.18.09.39.03;	author jsing;	state Exp;
branches;
next	1.285;

1.285
date	2013.01.18.01.19.38;	author jsing;	state Exp;
branches;
next	1.284;

1.284
date	2013.01.16.07.07.38;	author jsing;	state Exp;
branches;
next	1.283;

1.283
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.282;

1.282
date	2013.01.16.06.29.14;	author jsing;	state Exp;
branches;
next	1.281;

1.281
date	2013.01.15.09.51.22;	author jsing;	state Exp;
branches;
next	1.280;

1.280
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.279;

1.279
date	2013.01.15.03.47.10;	author jsing;	state Exp;
branches;
next	1.278;

1.278
date	2012.10.09.11.57.33;	author jsing;	state Exp;
branches;
next	1.277;

1.277
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.276;

1.276
date	2012.10.08.13.25.46;	author jsing;	state Exp;
branches;
next	1.275;

1.275
date	2012.10.08.13.01.22;	author jsing;	state Exp;
branches;
next	1.274;

1.274
date	2012.01.30.13.13.03;	author jsing;	state Exp;
branches;
next	1.273;

1.273
date	2012.01.28.14.40.04;	author jsing;	state Exp;
branches;
next	1.272;

1.272
date	2012.01.22.11.13.31;	author jsing;	state Exp;
branches;
next	1.271;

1.271
date	2012.01.22.10.46.12;	author jsing;	state Exp;
branches;
next	1.270;

1.270
date	2012.01.22.10.43.50;	author jsing;	state Exp;
branches;
next	1.269;

1.269
date	2012.01.21.15.38.44;	author jsing;	state Exp;
branches;
next	1.268;

1.268
date	2012.01.20.14.43.05;	author jsing;	state Exp;
branches;
next	1.267;

1.267
date	2012.01.17.13.53.02;	author jsing;	state Exp;
branches;
next	1.266;

1.266
date	2012.01.17.12.56.38;	author jsing;	state Exp;
branches;
next	1.265;

1.265
date	2012.01.11.15.17.48;	author jsing;	state Exp;
branches;
next	1.264;

1.264
date	2012.01.11.14.10.50;	author jsing;	state Exp;
branches;
next	1.263;

1.263
date	2011.12.31.17.06.10;	author jsing;	state Exp;
branches;
next	1.262;

1.262
date	2011.12.28.16.19.52;	author jsing;	state Exp;
branches;
next	1.261;

1.261
date	2011.12.28.16.02.45;	author jsing;	state Exp;
branches;
next	1.260;

1.260
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.259;

1.259
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.258;

1.258
date	2011.11.13.14.07.17;	author jsing;	state Exp;
branches;
next	1.257;

1.257
date	2011.11.13.13.57.43;	author jsing;	state Exp;
branches;
next	1.256;

1.256
date	2011.11.11.17.26.24;	author jsing;	state Exp;
branches;
next	1.255;

1.255
date	2011.11.11.17.23.39;	author jsing;	state Exp;
branches;
next	1.254;

1.254
date	2011.11.11.12.32.11;	author jsing;	state Exp;
branches;
next	1.253;

1.253
date	2011.11.11.12.28.37;	author jsing;	state Exp;
branches;
next	1.252;

1.252
date	2011.11.08.18.02.37;	author krw;	state Exp;
branches;
next	1.251;

1.251
date	2011.09.19.21.47.37;	author jsing;	state Exp;
branches;
next	1.250;

1.250
date	2011.09.19.21.39.31;	author jsing;	state Exp;
branches;
next	1.249;

1.249
date	2011.09.19.14.55.10;	author jsing;	state Exp;
branches;
next	1.248;

1.248
date	2011.09.18.19.40.49;	author jsing;	state Exp;
branches;
next	1.247;

1.247
date	2011.09.18.13.11.08;	author jsing;	state Exp;
branches;
next	1.246;

1.246
date	2011.08.08.18.18.22;	author marco;	state Exp;
branches;
next	1.245;

1.245
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.244;

1.244
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.243;

1.243
date	2011.07.07.18.04.25;	author jsing;	state Exp;
branches;
next	1.242;

1.242
date	2011.07.07.15.24.59;	author jsing;	state Exp;
branches;
next	1.241;

1.241
date	2011.07.06.17.37.22;	author jsing;	state Exp;
branches;
next	1.240;

1.240
date	2011.07.06.17.32.47;	author jsing;	state Exp;
branches;
next	1.239;

1.239
date	2011.07.06.15.55.25;	author jsing;	state Exp;
branches;
next	1.238;

1.238
date	2011.07.06.15.44.11;	author jsing;	state Exp;
branches;
next	1.237;

1.237
date	2011.07.06.15.29.17;	author jsing;	state Exp;
branches;
next	1.236;

1.236
date	2011.07.04.22.55.11;	author matthew;	state Exp;
branches;
next	1.235;

1.235
date	2011.07.03.15.41.32;	author matthew;	state Exp;
branches;
next	1.234;

1.234
date	2011.07.02.17.39.12;	author jsing;	state Exp;
branches;
next	1.233;

1.233
date	2011.06.24.12.45.19;	author jsing;	state Exp;
branches;
next	1.232;

1.232
date	2011.06.23.17.20.16;	author matthew;	state Exp;
branches;
next	1.231;

1.231
date	2011.06.20.09.16.05;	author matthew;	state Exp;
branches;
next	1.230;

1.230
date	2011.05.03.17.08.51;	author matthew;	state Exp;
branches;
next	1.229;

1.229
date	2011.04.29.13.04.38;	author dlg;	state Exp;
branches;
next	1.228;

1.228
date	2011.04.29.13.03.12;	author dlg;	state Exp;
branches;
next	1.227;

1.227
date	2011.04.14.02.11.23;	author marco;	state Exp;
branches;
next	1.226;

1.226
date	2011.04.06.15.36.13;	author marco;	state Exp;
branches;
next	1.225;

1.225
date	2011.04.06.02.35.51;	author marco;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.06.02.00.10;	author marco;	state Exp;
branches;
next	1.223;

1.223
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.222;

1.222
date	2011.03.15.13.29.41;	author jsing;	state Exp;
branches;
next	1.221;

1.221
date	2011.01.29.15.01.22;	author marco;	state Exp;
branches;
next	1.220;

1.220
date	2011.01.23.14.21.20;	author jsing;	state Exp;
branches;
next	1.219;

1.219
date	2011.01.22.15.23.45;	author jsing;	state Exp;
branches;
next	1.218;

1.218
date	2011.01.12.20.38.33;	author marco;	state Exp;
branches;
next	1.217;

1.217
date	2010.12.20.17.47.48;	author krw;	state Exp;
branches;
next	1.216;

1.216
date	2010.11.06.23.01.56;	author marco;	state Exp;
branches;
next	1.215;

1.215
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.213;

1.213
date	2010.09.07.17.14.06;	author deraadt;	state Exp;
branches;
next	1.212;

1.212
date	2010.08.30.19.05.08;	author deraadt;	state Exp;
branches;
next	1.211;

1.211
date	2010.08.30.17.32.40;	author jsing;	state Exp;
branches;
next	1.210;

1.210
date	2010.07.03.03.04.55;	author tedu;	state Exp;
branches;
next	1.209;

1.209
date	2010.07.02.09.26.05;	author jsing;	state Exp;
branches;
next	1.208;

1.208
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.207;

1.207
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2010.06.15.10.59.52;	author dlg;	state Exp;
branches;
next	1.205;

1.205
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.204;

1.204
date	2010.05.21.20.52.38;	author marco;	state Exp;
branches;
next	1.203;

1.203
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.202;

1.202
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.201;

1.201
date	2010.03.28.16.38.57;	author jsing;	state Exp;
branches;
next	1.200;

1.200
date	2010.03.28.09.13.55;	author jsing;	state Exp;
branches;
next	1.199;

1.199
date	2010.03.28.09.08.32;	author jsing;	state Exp;
branches;
next	1.198;

1.198
date	2010.03.27.16.20.29;	author jsing;	state Exp;
branches;
next	1.197;

1.197
date	2010.03.26.16.50.59;	author jsing;	state Exp;
branches;
next	1.196;

1.196
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.195;

1.195
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.194;

1.194
date	2010.02.13.22.10.01;	author jsing;	state Exp;
branches;
next	1.193;

1.193
date	2010.02.13.21.23.36;	author jsing;	state Exp;
branches;
next	1.192;

1.192
date	2010.02.13.21.19.26;	author jsing;	state Exp;
branches;
next	1.191;

1.191
date	2010.02.13.21.16.10;	author jsing;	state Exp;
branches;
next	1.190;

1.190
date	2010.02.08.23.28.06;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.188;

1.188
date	2009.12.31.14.00.45;	author jsing;	state Exp;
branches;
next	1.187;

1.187
date	2009.12.15.15.51.43;	author jsing;	state Exp;
branches;
next	1.186;

1.186
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.185;

1.185
date	2009.12.15.13.04.04;	author jsing;	state Exp;
branches;
next	1.184;

1.184
date	2009.12.07.14.33.38;	author jsing;	state Exp;
branches;
next	1.183;

1.183
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.182;

1.182
date	2009.11.24.02.19.35;	author jsing;	state Exp;
branches;
next	1.181;

1.181
date	2009.11.23.16.33.59;	author jsing;	state Exp;
branches;
next	1.180;

1.180
date	2009.11.22.17.01.18;	author jsing;	state Exp;
branches;
next	1.179;

1.179
date	2009.11.22.16.56.06;	author jsing;	state Exp;
branches;
next	1.178;

1.178
date	2009.11.15.13.32.04;	author jsing;	state Exp;
branches;
next	1.177;

1.177
date	2009.10.29.15.21.31;	author jsing;	state Exp;
branches;
next	1.176;

1.176
date	2009.10.28.15.22.23;	author marco;	state Exp;
branches;
next	1.175;

1.175
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.174;

1.174
date	2009.09.21.16.38.13;	author marco;	state Exp;
branches;
next	1.173;

1.173
date	2009.09.03.13.26.38;	author jsing;	state Exp;
branches;
next	1.172;

1.172
date	2009.09.03.13.20.29;	author jsing;	state Exp;
branches;
next	1.171;

1.171
date	2009.08.17.13.04.05;	author martynas;	state Exp;
branches;
next	1.170;

1.170
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.169;

1.169
date	2009.07.31.16.05.25;	author jsing;	state Exp;
branches;
next	1.168;

1.168
date	2009.07.23.15.15.25;	author jordan;	state Exp;
branches;
next	1.167;

1.167
date	2009.07.12.21.48.03;	author jsing;	state Exp;
branches;
next	1.166;

1.166
date	2009.07.12.21.46.36;	author jsing;	state Exp;
branches;
next	1.165;

1.165
date	2009.07.12.16.31.56;	author jsing;	state Exp;
branches;
next	1.164;

1.164
date	2009.07.12.13.30.59;	author jsing;	state Exp;
branches;
next	1.163;

1.163
date	2009.07.11.15.42.50;	author jsing;	state Exp;
branches;
next	1.162;

1.162
date	2009.07.09.19.24.42;	author mglocker;	state Exp;
branches;
next	1.161;

1.161
date	2009.06.26.14.50.44;	author jsing;	state Exp;
branches;
next	1.160;

1.160
date	2009.06.24.12.08.15;	author jsing;	state Exp;
branches;
next	1.159;

1.159
date	2009.06.24.12.06.00;	author jsing;	state Exp;
branches;
next	1.158;

1.158
date	2009.06.23.15.54.44;	author jsing;	state Exp;
branches;
next	1.157;

1.157
date	2009.06.23.15.51.35;	author jsing;	state Exp;
branches;
next	1.156;

1.156
date	2009.06.19.02.59.42;	author marco;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.18.15.51.56;	author jsing;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.18.15.47.38;	author jsing;	state Exp;
branches;
next	1.153;

1.153
date	2009.06.17.23.13.36;	author jordan;	state Exp;
branches;
next	1.152;

1.152
date	2009.06.17.22.44.42;	author marco;	state Exp;
branches;
next	1.151;

1.151
date	2009.06.17.19.05.26;	author jordan;	state Exp;
branches;
next	1.150;

1.150
date	2009.06.12.17.22.52;	author jsing;	state Exp;
branches;
next	1.149;

1.149
date	2009.06.12.16.00.25;	author jsing;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.11.19.42.59;	author marco;	state Exp;
branches;
next	1.147;

1.147
date	2009.06.10.21.37.17;	author marco;	state Exp;
branches;
next	1.146;

1.146
date	2009.06.10.03.24.02;	author marco;	state Exp;
branches;
next	1.145;

1.145
date	2009.06.03.21.04.36;	author marco;	state Exp;
branches;
next	1.144;

1.144
date	2009.06.03.17.39.26;	author ckuethe;	state Exp;
branches;
next	1.143;

1.143
date	2009.06.03.06.30.10;	author marco;	state Exp;
branches;
next	1.142;

1.142
date	2009.06.03.06.28.56;	author marco;	state Exp;
branches;
next	1.141;

1.141
date	2009.06.03.02.55.04;	author marco;	state Exp;
branches;
next	1.140;

1.140
date	2009.06.02.21.23.11;	author marco;	state Exp;
branches;
next	1.139;

1.139
date	2009.06.02.19.21.49;	author marco;	state Exp;
branches;
next	1.138;

1.138
date	2009.06.02.19.15.58;	author marco;	state Exp;
branches;
next	1.137;

1.137
date	2009.06.02.12.32.08;	author deraadt;	state Exp;
branches;
next	1.136;

1.136
date	2009.06.02.05.49.35;	author marco;	state Exp;
branches;
next	1.135;

1.135
date	2009.06.02.00.58.16;	author marco;	state Exp;
branches;
next	1.134;

1.134
date	2009.05.30.21.20.34;	author marco;	state Exp;
branches;
next	1.133;

1.133
date	2009.05.11.14.17.55;	author jsing;	state Exp;
branches;
next	1.132;

1.132
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.131;

1.131
date	2009.04.29.00.52.30;	author marco;	state Exp;
branches;
next	1.130;

1.130
date	2009.04.28.03.29.00;	author marco;	state Exp;
branches;
next	1.129;

1.129
date	2009.04.28.02.54.53;	author marco;	state Exp;
branches;
next	1.128;

1.128
date	2009.04.26.17.04.53;	author marco;	state Exp;
branches;
next	1.127;

1.127
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2008.12.24.19.32.02;	author marco;	state Exp;
branches;
next	1.125;

1.125
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.124;

1.124
date	2008.11.25.22.48.22;	author marco;	state Exp;
branches;
next	1.123;

1.123
date	2008.11.23.23.44.01;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2008.11.23.22.06.43;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2008.10.11.20.31.48;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2008.09.22.19.44.00;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2008.07.21.14.49.40;	author marco;	state Exp;
branches;
next	1.118;

1.118
date	2008.07.20.21.57.51;	author djm;	state Exp;
branches;
next	1.117;

1.117
date	2008.07.19.22.41.58;	author marco;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.25.17.43.09;	author thib;	state Exp;
branches;
next	1.115;

1.115
date	2008.06.14.18.40.50;	author hshoexer;	state Exp;
branches;
next	1.114;

1.114
date	2008.06.14.00.16.38;	author hshoexer;	state Exp;
branches;
next	1.113;

1.113
date	2008.06.13.18.26.59;	author hshoexer;	state Exp;
branches;
next	1.112;

1.112
date	2008.06.12.23.29.27;	author hshoexer;	state Exp;
branches;
next	1.111;

1.111
date	2008.06.12.21.29.02;	author marco;	state Exp;
branches;
next	1.110;

1.110
date	2008.06.12.18.13.27;	author hshoexer;	state Exp;
branches;
next	1.109;

1.109
date	2008.06.12.01.26.16;	author marco;	state Exp;
branches;
next	1.108;

1.108
date	2008.06.12.00.19.15;	author marco;	state Exp;
branches;
next	1.107;

1.107
date	2008.06.11.00.26.18;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.105;

1.105
date	2008.04.02.21.32.03;	author martin;	state Exp;
branches;
next	1.104;

1.104
date	2008.02.15.05.29.25;	author ckuethe;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.14.22.04.34;	author ckuethe;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.07.15.08.49;	author marco;	state Exp;
branches;
next	1.101;

1.101
date	2008.02.05.16.49.25;	author marco;	state Exp;
branches;
next	1.100;

1.100
date	2008.02.05.16.24.12;	author marco;	state Exp;
branches;
next	1.99;

1.99
date	2008.02.05.16.15.35;	author marco;	state Exp;
branches;
next	1.98;

1.98
date	2008.02.03.00.25.21;	author marco;	state Exp;
branches;
next	1.97;

1.97
date	2008.01.29.23.25.02;	author marco;	state Exp;
branches;
next	1.96;

1.96
date	2008.01.24.19.58.08;	author marco;	state Exp;
branches;
next	1.95;

1.95
date	2008.01.24.17.50.17;	author marco;	state Exp;
branches;
next	1.94;

1.94
date	2008.01.24.13.54.47;	author marco;	state Exp;
branches;
next	1.93;

1.93
date	2008.01.20.17.20.10;	author marco;	state Exp;
branches;
next	1.92;

1.92
date	2008.01.19.23.53.53;	author marco;	state Exp;
branches;
next	1.91;

1.91
date	2008.01.19.15.33.13;	author marco;	state Exp;
branches;
next	1.90;

1.90
date	2008.01.05.07.33.37;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.27.17.21.52;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.27.16.37.05;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.26.20.14.42;	author marco;	state Exp;
branches;
next	1.86;

1.86
date	2007.11.26.13.49.26;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.16.05.08.39;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.08.17.59.23;	author gilles;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.06.23.06.02;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.05.16.30.02;	author marco;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.05.03.08.10;	author todd;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.04.04.53.31;	author marco;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.03.22.36.27;	author tedu;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.03.22.33.35;	author tedu;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.03.12.57.51;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.03.04.27.09;	author marco;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.02.01.52.25;	author marco;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.02.01.49.27;	author marco;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.02.00.53.35;	author marco;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.02.00.27.44;	author marco;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.01.22.23.03;	author marco;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.01.18.50.56;	author marco;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.01.17.43.05;	author marco;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.01.01.16.48;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.31.22.04.23;	author marco;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.31.18.56.27;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.31.06.26.23;	author grunk;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.30.17.56.37;	author marco;	state Exp;
branches;
next	1.60;

1.60
date	2007.05.30.16.54.07;	author marco;	state Exp;
branches;
next	1.59;

1.59
date	2007.05.30.15.59.35;	author marco;	state Exp;
branches;
next	1.58;

1.58
date	2007.05.30.13.55.47;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.29.23.20.02;	author marco;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.29.22.12.42;	author marco;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.29.18.35.00;	author marco;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.29.16.36.35;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.29.16.31.38;	author marco;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.29.08.15.32;	author marco;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.29.02.09.45;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.28.21.54.26;	author marco;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.27.00.10.47;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.26.23.59.09;	author marco;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.26.23.07.28;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.26.14.49.50;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.26.14.30.26;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.24.13.15.31;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.23.21.27.13;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.12.02.50.22;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.08.23.54.37;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.02.03.51.26;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.02.03.19.03;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.01.22.53.51;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2007.04.30.01.58.36;	author todd;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.23.22.48.40;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.23.20.11.31;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.23.17.06.10;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.22.13.02.56;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.22.04.05.36;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.22.00.41.31;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.22.00.06.09;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.21.23.50.47;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.21.23.39.18;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.21.23.22.42;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.21.23.05.19;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.19.22.12.41;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.19.02.44.29;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.19.02.36.56;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.17.23.18.23;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.17.05.59.20;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.14.21.28.08;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.14.15.50.28;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.12.03.31.54;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.11.22.58.33;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.11.22.52.33;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.11.22.05.09;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.31.12.57.08;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.31.12.31.27;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.31.12.07.50;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.30.23.15.30;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.30.20.12.28;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.27.04.05.22;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.26.01.44.06;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.24.05.15.19;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2007.03.20.03.31.24;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2007.03.20.02.48.22;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.19.22.33.15;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.19.15.00.08;	author mk;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.19.14.33.28;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.19.03.02.08;	author marco;	state Exp;
branches;
next	;


desc
@@


1.382
log
@Upon failure, only return zero from the softraid ioctl handler when there
is at least one bio status message. It is a much nicer user experience when
we properly report failures, however in the case that we fail to do this,
getting an errno back from the ioctl is somewhat better than simply
printing "unknown error" from bioctl(8).
@
text
@/* $OpenBSD: softraid.c,v 1.381 2017/06/06 19:01:27 krw Exp $ */
/*
 * Copyright (c) 2007, 2008, 2009 Marco Peereboom <marco@@peereboom.us>
 * Copyright (c) 2008 Chris Kuethe <ckuethe@@openbsd.org>
 * Copyright (c) 2009 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/kernel.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/task.h>
#include <sys/kthread.h>
#include <sys/dkio.h>
#include <sys/stdint.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>

#ifdef HIBERNATE
#include <lib/libsa/aes_xts.h>
#include <sys/hibernate.h>
#include <scsi/sdvar.h>
#endif /* HIBERNATE */

/* #define SR_FANCY_STATS */

#ifdef SR_DEBUG
#define SR_FANCY_STATS
uint32_t	sr_debug = 0
		    /* | SR_D_CMD */
		    /* | SR_D_MISC */
		    /* | SR_D_INTR */
		    /* | SR_D_IOCTL */
		    /* | SR_D_CCB */
		    /* | SR_D_WU */
		    /* | SR_D_META */
		    /* | SR_D_DIS */
		    /* | SR_D_STATE */
		    /* | SR_D_REBUILD */
		;
#endif

struct sr_softc	*softraid0;
struct sr_uuid	sr_bootuuid;
u_int8_t	sr_bootkey[SR_CRYPTO_MAXKEYBYTES];

int		sr_match(struct device *, void *, void *);
void		sr_attach(struct device *, struct device *, void *);
int		sr_detach(struct device *, int);
void		sr_map_root(void);

struct cfattach softraid_ca = {
	sizeof(struct sr_softc), sr_match, sr_attach, sr_detach,
};

struct cfdriver softraid_cd = {
	NULL, "softraid", DV_DULL
};

/* scsi & discipline */
void			sr_scsi_cmd(struct scsi_xfer *);
void			sr_minphys(struct buf *, struct scsi_link *);
int			sr_scsi_probe(struct scsi_link *);
void			sr_copy_internal_data(struct scsi_xfer *,
			    void *, size_t);
int			sr_scsi_ioctl(struct scsi_link *, u_long,
			    caddr_t, int);
int			sr_bio_ioctl(struct device *, u_long, caddr_t);
int			sr_bio_handler(struct sr_softc *,
			    struct sr_discipline *, u_long, struct bio *);
int			sr_ioctl_inq(struct sr_softc *, struct bioc_inq *);
int			sr_ioctl_vol(struct sr_softc *, struct bioc_vol *);
int			sr_ioctl_disk(struct sr_softc *, struct bioc_disk *);
int			sr_ioctl_setstate(struct sr_softc *,
			    struct bioc_setstate *);
int			sr_ioctl_createraid(struct sr_softc *,
			    struct bioc_createraid *, int, void *);
int			sr_ioctl_deleteraid(struct sr_softc *,
			    struct sr_discipline *, struct bioc_deleteraid *);
int			sr_ioctl_discipline(struct sr_softc *,
			    struct sr_discipline *, struct bioc_discipline *);
int			sr_ioctl_installboot(struct sr_softc *,
			    struct sr_discipline *, struct bioc_installboot *);
void			sr_chunks_unwind(struct sr_softc *,
			    struct sr_chunk_head *);
void			sr_discipline_free(struct sr_discipline *);
void			sr_discipline_shutdown(struct sr_discipline *, int);
int			sr_discipline_init(struct sr_discipline *, int);
int			sr_alloc_resources(struct sr_discipline *);
void			sr_free_resources(struct sr_discipline *);
void			sr_set_chunk_state(struct sr_discipline *, int, int);
void			sr_set_vol_state(struct sr_discipline *);

/* utility functions */
void			sr_shutdown(void);
void			sr_uuid_generate(struct sr_uuid *);
char			*sr_uuid_format(struct sr_uuid *);
void			sr_uuid_print(struct sr_uuid *, int);
void			sr_checksum_print(u_int8_t *);
int			sr_boot_assembly(struct sr_softc *);
int			sr_already_assembled(struct sr_discipline *);
int			sr_hotspare(struct sr_softc *, dev_t);
void			sr_hotspare_rebuild(struct sr_discipline *);
int			sr_rebuild_init(struct sr_discipline *, dev_t, int);
void			sr_rebuild_start(void *);
void			sr_rebuild_thread(void *);
void			sr_rebuild(struct sr_discipline *);
void			sr_roam_chunks(struct sr_discipline *);
int			sr_chunk_in_use(struct sr_softc *, dev_t);
int			sr_rw(struct sr_softc *, dev_t, char *, size_t,
			    daddr_t, long);
void			sr_wu_done_callback(void *);

/* don't include these on RAMDISK */
#ifndef SMALL_KERNEL
void			sr_sensors_refresh(void *);
int			sr_sensors_create(struct sr_discipline *);
void			sr_sensors_delete(struct sr_discipline *);
#endif

/* metadata */
int			sr_meta_probe(struct sr_discipline *, dev_t *, int);
int			sr_meta_attach(struct sr_discipline *, int, int);
int			sr_meta_rw(struct sr_discipline *, dev_t, void *, long);
int			sr_meta_clear(struct sr_discipline *);
void			sr_meta_init(struct sr_discipline *, int, int);
void			sr_meta_init_complete(struct sr_discipline *);
void			sr_meta_opt_handler(struct sr_discipline *,
			    struct sr_meta_opt_hdr *);

/* hotplug magic */
void			sr_disk_attach(struct disk *, int);

struct sr_hotplug_list {
	void			(*sh_hotplug)(struct sr_discipline *,
				    struct disk *, int);
	struct sr_discipline	*sh_sd;

	SLIST_ENTRY(sr_hotplug_list) shl_link;
};
SLIST_HEAD(sr_hotplug_list_head, sr_hotplug_list);

struct			sr_hotplug_list_head	sr_hotplug_callbacks;
extern void		(*softraid_disk_attach)(struct disk *, int);

/* scsi glue */
struct scsi_adapter sr_switch = {
	sr_scsi_cmd, sr_minphys, sr_scsi_probe, NULL, sr_scsi_ioctl
};

/* native metadata format */
int			sr_meta_native_bootprobe(struct sr_softc *, dev_t,
			    struct sr_boot_chunk_head *);
#define SR_META_NOTCLAIMED	(0)
#define SR_META_CLAIMED		(1)
int			sr_meta_native_probe(struct sr_softc *,
			   struct sr_chunk *);
int			sr_meta_native_attach(struct sr_discipline *, int);
int			sr_meta_native_write(struct sr_discipline *, dev_t,
			    struct sr_metadata *,void *);

#ifdef SR_DEBUG
void			sr_meta_print(struct sr_metadata *);
#else
#define			sr_meta_print(m)
#endif

/* the metadata driver should remain stateless */
struct sr_meta_driver {
	daddr_t			smd_offset;	/* metadata location */
	u_int32_t		smd_size;	/* size of metadata */

	int			(*smd_probe)(struct sr_softc *,
				   struct sr_chunk *);
	int			(*smd_attach)(struct sr_discipline *, int);
	int			(*smd_detach)(struct sr_discipline *);
	int			(*smd_read)(struct sr_discipline *, dev_t,
				    struct sr_metadata *, void *);
	int			(*smd_write)(struct sr_discipline *, dev_t,
				    struct sr_metadata *, void *);
	int			(*smd_validate)(struct sr_discipline *,
				    struct sr_metadata *, void *);
} smd[] = {
	{ SR_META_OFFSET, SR_META_SIZE * DEV_BSIZE,
	  sr_meta_native_probe, sr_meta_native_attach, NULL,
	  sr_meta_native_read, sr_meta_native_write, NULL },
	{ 0, 0, NULL, NULL, NULL, NULL }
};

int
sr_meta_attach(struct sr_discipline *sd, int chunk_no, int force)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl;
	struct sr_chunk		*ch_entry, *chunk1, *chunk2;
	int			rv = 1, i = 0;

	DNPRINTF(SR_D_META, "%s: sr_meta_attach(%d)\n", DEVNAME(sc), chunk_no);

	/* in memory copy of metadata */
	sd->sd_meta = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF,
	    M_ZERO | M_NOWAIT);
	if (!sd->sd_meta) {
		sr_error(sc, "could not allocate memory for metadata");
		goto bad;
	}

	if (sd->sd_meta_type != SR_META_F_NATIVE) {
		/* in memory copy of foreign metadata */
		sd->sd_meta_foreign = malloc(smd[sd->sd_meta_type].smd_size,
		    M_DEVBUF, M_ZERO | M_NOWAIT);
		if (!sd->sd_meta_foreign) {
			/* unwind frees sd_meta */
			sr_error(sc, "could not allocate memory for foreign "
			    "metadata");
			goto bad;
		}
	}

	/* we have a valid list now create an array index */
	cl = &sd->sd_vol.sv_chunk_list;
	sd->sd_vol.sv_chunks = mallocarray(chunk_no, sizeof(struct sr_chunk *),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	/* fill out chunk array */
	i = 0;
	SLIST_FOREACH(ch_entry, cl, src_link)
		sd->sd_vol.sv_chunks[i++] = ch_entry;

	/* attach metadata */
	if (smd[sd->sd_meta_type].smd_attach(sd, force))
		goto bad;

	/* Force chunks into correct order now that metadata is attached. */
	SLIST_INIT(cl);
	for (i = 0; i < chunk_no; i++) {
		ch_entry = sd->sd_vol.sv_chunks[i];
		chunk2 = NULL;
		SLIST_FOREACH(chunk1, cl, src_link) {
			if (chunk1->src_meta.scmi.scm_chunk_id >
			    ch_entry->src_meta.scmi.scm_chunk_id)
				break;
			chunk2 = chunk1;
		}
		if (chunk2 == NULL)
			SLIST_INSERT_HEAD(cl, ch_entry, src_link);
		else
			SLIST_INSERT_AFTER(chunk2, ch_entry, src_link);
	}
	i = 0;
	SLIST_FOREACH(ch_entry, cl, src_link)
		sd->sd_vol.sv_chunks[i++] = ch_entry;

	rv = 0;
bad:
	return (rv);
}

int
sr_meta_probe(struct sr_discipline *sd, dev_t *dt, int no_chunk)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct vnode		*vn;
	struct sr_chunk		*ch_entry, *ch_prev = NULL;
	struct sr_chunk_head	*cl;
	char			devname[32];
	int			i, d, type, found, prevf, error;
	dev_t			dev;

	DNPRINTF(SR_D_META, "%s: sr_meta_probe(%d)\n", DEVNAME(sc), no_chunk);

	if (no_chunk == 0)
		goto unwind;

	cl = &sd->sd_vol.sv_chunk_list;

	for (d = 0, prevf = SR_META_F_INVALID; d < no_chunk; d++) {
		ch_entry = malloc(sizeof(struct sr_chunk), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		/* keep disks in user supplied order */
		if (ch_prev)
			SLIST_INSERT_AFTER(ch_prev, ch_entry, src_link);
		else
			SLIST_INSERT_HEAD(cl, ch_entry, src_link);
		ch_prev = ch_entry;
		dev = dt[d];
		ch_entry->src_dev_mm = dev;

		if (dev == NODEV) {
			ch_entry->src_meta.scm_status = BIOC_SDOFFLINE;
			continue;
		} else {
			sr_meta_getdevname(sc, dev, devname, sizeof(devname));
			if (bdevvp(dev, &vn)) {
				sr_error(sc, "sr_meta_probe: cannot allocate "
				    "vnode");
				goto unwind;
			}

			/*
			 * XXX leaving dev open for now; move this to attach
			 * and figure out the open/close dance for unwind.
			 */
			error = VOP_OPEN(vn, FREAD | FWRITE, NOCRED, curproc);
			if (error) {
				DNPRINTF(SR_D_META,"%s: sr_meta_probe can't "
				    "open %s\n", DEVNAME(sc), devname);
				vput(vn);
				goto unwind;
			}

			strlcpy(ch_entry->src_devname, devname,
			    sizeof(ch_entry->src_devname));
			ch_entry->src_vn = vn;
		}

		/* determine if this is a device we understand */
		for (i = 0, found = SR_META_F_INVALID; smd[i].smd_probe; i++) {
			type = smd[i].smd_probe(sc, ch_entry);
			if (type == SR_META_F_INVALID)
				continue;
			else {
				found = type;
				break;
			}
		}

		if (found == SR_META_F_INVALID)
			goto unwind;
		if (prevf == SR_META_F_INVALID)
			prevf = found;
		if (prevf != found) {
			DNPRINTF(SR_D_META, "%s: prevf != found\n",
			    DEVNAME(sc));
			goto unwind;
		}
	}

	return (prevf);
unwind:
	return (SR_META_F_INVALID);
}

void
sr_meta_getdevname(struct sr_softc *sc, dev_t dev, char *buf, int size)
{
	int			maj, unit, part;
	char			*name;

	DNPRINTF(SR_D_META, "%s: sr_meta_getdevname(%p, %d)\n",
	    DEVNAME(sc), buf, size);

	if (!buf)
		return;

	maj = major(dev);
	part = DISKPART(dev);
	unit = DISKUNIT(dev);

	name = findblkname(maj);
	if (name == NULL)
		return;

	snprintf(buf, size, "%s%d%c", name, unit, part + 'a');
}

int
sr_rw(struct sr_softc *sc, dev_t dev, char *buf, size_t size, daddr_t blkno,
    long flags)
{
	struct vnode		*vp;
	struct buf		b;
	size_t			bufsize, dma_bufsize;
	int			rv = 1;
	char			*dma_buf;

	DNPRINTF(SR_D_MISC, "%s: sr_rw(0x%x, %p, %zu, %lld 0x%lx)\n",
	    DEVNAME(sc), dev, buf, size, (long long)blkno, flags);

	dma_bufsize = (size > MAXPHYS) ? MAXPHYS : size;
	dma_buf = dma_alloc(dma_bufsize, PR_WAITOK);

	if (bdevvp(dev, &vp)) {
		printf("%s: sr_rw: failed to allocate vnode\n", DEVNAME(sc));
		goto done;
	}

	while (size > 0) {
		DNPRINTF(SR_D_MISC, "%s: dma_buf %p, size %zu, blkno %lld)\n",
		    DEVNAME(sc), dma_buf, size, (long long)blkno);

		bufsize = (size > MAXPHYS) ? MAXPHYS : size;
		if (flags == B_WRITE)
			memcpy(dma_buf, buf, bufsize);

		bzero(&b, sizeof(b));
		b.b_flags = flags | B_PHYS;
		b.b_proc = curproc;
		b.b_dev = dev;
		b.b_iodone = NULL;
		b.b_error = 0;
		b.b_blkno = blkno;
		b.b_data = dma_buf;
		b.b_bcount = bufsize;
		b.b_bufsize = bufsize;
		b.b_resid = bufsize;
		b.b_vp = vp;

		if ((b.b_flags & B_READ) == 0)
			vp->v_numoutput++;

		LIST_INIT(&b.b_dep);
		VOP_STRATEGY(&b);
		biowait(&b);

		if (b.b_flags & B_ERROR) {
			printf("%s: I/O error %d on dev 0x%x at block %llu\n",
			    DEVNAME(sc), b.b_error, dev, b.b_blkno);
			goto done;
		}

		if (flags == B_READ)
			memcpy(buf, dma_buf, bufsize);

		size -= bufsize;
		buf += bufsize;
		blkno += howmany(bufsize, DEV_BSIZE);
	}

	rv = 0;

done:
	if (vp)
		vput(vp);

	dma_free(dma_buf, dma_bufsize);

	return (rv);
}

int
sr_meta_rw(struct sr_discipline *sd, dev_t dev, void *md, long flags)
{
	int			rv = 1;

	DNPRINTF(SR_D_META, "%s: sr_meta_rw(0x%x, %p, 0x%lx)\n",
	    DEVNAME(sd->sd_sc), dev, md, flags);

	if (md == NULL) {
		printf("%s: sr_meta_rw: invalid metadata pointer\n",
		    DEVNAME(sd->sd_sc));
		goto done;
	}

	rv = sr_rw(sd->sd_sc, dev, md, SR_META_SIZE * DEV_BSIZE,
	    SR_META_OFFSET, flags);

done:
	return (rv);
}

int
sr_meta_clear(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_chunk		*ch_entry;
	void			*m;
	int			rv = 1;

	DNPRINTF(SR_D_META, "%s: sr_meta_clear\n", DEVNAME(sc));

	if (sd->sd_meta_type != SR_META_F_NATIVE) {
		sr_error(sc, "cannot clear foreign metadata");
		goto done;
	}

	m = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_WAITOK | M_ZERO);
	SLIST_FOREACH(ch_entry, cl, src_link) {
		if (sr_meta_native_write(sd, ch_entry->src_dev_mm, m, NULL)) {
			/* XXX mark disk offline */
			DNPRINTF(SR_D_META, "%s: sr_meta_clear failed to "
			    "clear %s\n", DEVNAME(sc), ch_entry->src_devname);
			rv++;
			continue;
		}
		bzero(&ch_entry->src_meta, sizeof(ch_entry->src_meta));
	}

	bzero(sd->sd_meta, SR_META_SIZE * DEV_BSIZE);

	free(m, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);
	rv = 0;
done:
	return (rv);
}

void
sr_meta_init(struct sr_discipline *sd, int level, int no_chunk)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_metadata	*sm = sd->sd_meta;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_meta_chunk	*scm;
	struct sr_chunk		*chunk;
	int			cid = 0;
	u_int64_t		max_chunk_sz = 0, min_chunk_sz = 0;
	u_int32_t		secsize = DEV_BSIZE;

	DNPRINTF(SR_D_META, "%s: sr_meta_init\n", DEVNAME(sc));

	if (!sm)
		return;

	/* Initialise volume metadata. */
	sm->ssdi.ssd_magic = SR_MAGIC;
	sm->ssdi.ssd_version = SR_META_VERSION;
	sm->ssdi.ssd_vol_flags = sd->sd_meta_flags;
	sm->ssdi.ssd_volid = 0;
	sm->ssdi.ssd_chunk_no = no_chunk;
	sm->ssdi.ssd_level = level;

	sm->ssd_data_blkno = SR_DATA_OFFSET;
	sm->ssd_ondisk = 0;

	sr_uuid_generate(&sm->ssdi.ssd_uuid);

	/* Initialise chunk metadata and get min/max chunk sizes & secsize. */
	SLIST_FOREACH(chunk, cl, src_link) {
		scm = &chunk->src_meta;
		scm->scmi.scm_size = chunk->src_size;
		scm->scmi.scm_chunk_id = cid++;
		scm->scm_status = BIOC_SDONLINE;
		scm->scmi.scm_volid = 0;
		strlcpy(scm->scmi.scm_devname, chunk->src_devname,
		    sizeof(scm->scmi.scm_devname));
		memcpy(&scm->scmi.scm_uuid, &sm->ssdi.ssd_uuid,
		    sizeof(scm->scmi.scm_uuid));
		sr_checksum(sc, scm, &scm->scm_checksum,
		    sizeof(scm->scm_checksum));

		if (min_chunk_sz == 0)
			min_chunk_sz = scm->scmi.scm_size;
		if (chunk->src_secsize > secsize)
			secsize = chunk->src_secsize;
		min_chunk_sz = MIN(min_chunk_sz, scm->scmi.scm_size);
		max_chunk_sz = MAX(max_chunk_sz, scm->scmi.scm_size);
	}

	sm->ssdi.ssd_secsize = secsize;

	/* Equalize chunk sizes. */
	SLIST_FOREACH(chunk, cl, src_link)
		chunk->src_meta.scmi.scm_coerced_size = min_chunk_sz;

	sd->sd_vol.sv_chunk_minsz = min_chunk_sz;
	sd->sd_vol.sv_chunk_maxsz = max_chunk_sz;
}

void
sr_meta_init_complete(struct sr_discipline *sd)
{
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif
	struct sr_metadata	*sm = sd->sd_meta;

	DNPRINTF(SR_D_META, "%s: sr_meta_complete\n", DEVNAME(sc));

	/* Complete initialisation of volume metadata. */
	strlcpy(sm->ssdi.ssd_vendor, "OPENBSD", sizeof(sm->ssdi.ssd_vendor));
	snprintf(sm->ssdi.ssd_product, sizeof(sm->ssdi.ssd_product),
	    "SR %s", sd->sd_name);
	snprintf(sm->ssdi.ssd_revision, sizeof(sm->ssdi.ssd_revision),
	    "%03d", sm->ssdi.ssd_version);
}

void
sr_meta_opt_handler(struct sr_discipline *sd, struct sr_meta_opt_hdr *om)
{
	if (om->som_type != SR_OPT_BOOT)
		panic("unknown optional metadata type");
}

void
sr_meta_save_callback(void *xsd)
{
	struct sr_discipline	*sd = xsd;
	int			s;

	s = splbio();

	if (sr_meta_save(sd, SR_META_DIRTY))
		printf("%s: save metadata failed\n", DEVNAME(sd->sd_sc));

	sd->sd_must_flush = 0;
	splx(s);
}

int
sr_meta_save(struct sr_discipline *sd, u_int32_t flags)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_metadata	*sm = sd->sd_meta, *m;
	struct sr_meta_driver	*s;
	struct sr_chunk		*src;
	struct sr_meta_chunk	*cm;
	struct sr_workunit	wu;
	struct sr_meta_opt_hdr	*omh;
	struct sr_meta_opt_item *omi;
	int			i;

	DNPRINTF(SR_D_META, "%s: sr_meta_save %s\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname);

	if (!sm) {
		printf("%s: no in memory copy of metadata\n", DEVNAME(sc));
		goto bad;
	}

	/* meta scratchpad */
	s = &smd[sd->sd_meta_type];
	m = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_ZERO | M_NOWAIT);
	if (!m) {
		printf("%s: could not allocate metadata scratch area\n",
		    DEVNAME(sc));
		goto bad;
	}

	/* from here on out metadata is updated */
restart:
	sm->ssd_ondisk++;
	sm->ssd_meta_flags = flags;
	memcpy(m, sm, sizeof(*m));

	/* Chunk metadata. */
	cm = (struct sr_meta_chunk *)(m + 1);
	for (i = 0; i < sm->ssdi.ssd_chunk_no; i++) {
		src = sd->sd_vol.sv_chunks[i];
		memcpy(cm, &src->src_meta, sizeof(*cm));
		cm++;
	}

	/* Optional metadata. */
	omh = (struct sr_meta_opt_hdr *)(cm);
	SLIST_FOREACH(omi, &sd->sd_meta_opt, omi_link) {
		DNPRINTF(SR_D_META, "%s: saving optional metadata type %u with "
		    "length %u\n", DEVNAME(sc), omi->omi_som->som_type,
		    omi->omi_som->som_length);
		bzero(&omi->omi_som->som_checksum, MD5_DIGEST_LENGTH);
		sr_checksum(sc, omi->omi_som, &omi->omi_som->som_checksum,
		    omi->omi_som->som_length);
		memcpy(omh, omi->omi_som, omi->omi_som->som_length);
		omh = (struct sr_meta_opt_hdr *)((u_int8_t *)omh +
		    omi->omi_som->som_length);
	}

	for (i = 0; i < sm->ssdi.ssd_chunk_no; i++) {
		src = sd->sd_vol.sv_chunks[i];

		/* skip disks that are offline */
		if (src->src_meta.scm_status == BIOC_SDOFFLINE)
			continue;

		/* calculate metadata checksum for correct chunk */
		m->ssdi.ssd_chunk_id = i;
		sr_checksum(sc, m, &m->ssd_checksum,
		    sizeof(struct sr_meta_invariant));

#ifdef SR_DEBUG
		DNPRINTF(SR_D_META, "%s: sr_meta_save %s: volid: %d "
		    "chunkid: %d checksum: ",
		    DEVNAME(sc), src->src_meta.scmi.scm_devname,
		    m->ssdi.ssd_volid, m->ssdi.ssd_chunk_id);

		if (sr_debug & SR_D_META)
			sr_checksum_print((u_int8_t *)&m->ssd_checksum);
		DNPRINTF(SR_D_META, "\n");
		sr_meta_print(m);
#endif

		/* translate and write to disk */
		if (s->smd_write(sd, src->src_dev_mm, m, NULL /* XXX */)) {
			printf("%s: could not write metadata to %s\n",
			    DEVNAME(sc), src->src_devname);
			/* restart the meta write */
			src->src_meta.scm_status = BIOC_SDOFFLINE;
			/* XXX recalculate volume status */
			goto restart;
		}
	}

	/* not all disciplines have sync */
	if (sd->sd_scsi_sync) {
		bzero(&wu, sizeof(wu));
		wu.swu_flags |= SR_WUF_FAKE;
		wu.swu_dis = sd;
		sd->sd_scsi_sync(&wu);
	}
	free(m, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);
	return (0);
bad:
	return (1);
}

int
sr_meta_read(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_metadata	*sm;
	struct sr_chunk		*ch_entry;
	struct sr_meta_chunk	*cp;
	struct sr_meta_driver	*s;
	void			*fm = NULL;
	int			no_disk = 0, got_meta = 0;

	DNPRINTF(SR_D_META, "%s: sr_meta_read\n", DEVNAME(sc));

	sm = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_WAITOK | M_ZERO);
	s = &smd[sd->sd_meta_type];
	if (sd->sd_meta_type != SR_META_F_NATIVE)
		fm = malloc(s->smd_size, M_DEVBUF, M_WAITOK | M_ZERO);

	cp = (struct sr_meta_chunk *)(sm + 1);
	SLIST_FOREACH(ch_entry, cl, src_link) {
		/* skip disks that are offline */
		if (ch_entry->src_meta.scm_status == BIOC_SDOFFLINE) {
			DNPRINTF(SR_D_META,
			    "%s: %s chunk marked offline, spoofing status\n",
			    DEVNAME(sc), ch_entry->src_devname);
			cp++; /* adjust chunk pointer to match failure */
			continue;
		} else if (s->smd_read(sd, ch_entry->src_dev_mm, sm, fm)) {
			/* read and translate */
			/* XXX mark chunk offline, elsewhere!! */
			ch_entry->src_meta.scm_status = BIOC_SDOFFLINE;
			cp++; /* adjust chunk pointer to match failure */
			DNPRINTF(SR_D_META, "%s: sr_meta_read failed\n",
			    DEVNAME(sc));
			continue;
		}

		if (sm->ssdi.ssd_magic != SR_MAGIC) {
			DNPRINTF(SR_D_META, "%s: sr_meta_read !SR_MAGIC\n",
			    DEVNAME(sc));
			continue;
		}

		/* validate metadata */
		if (sr_meta_validate(sd, ch_entry->src_dev_mm, sm, fm)) {
			DNPRINTF(SR_D_META, "%s: invalid metadata\n",
			    DEVNAME(sc));
			no_disk = -1;
			goto done;
		}

		/* assume first chunk contains metadata */
		if (got_meta == 0) {
			sr_meta_opt_load(sc, sm, &sd->sd_meta_opt);
			memcpy(sd->sd_meta, sm, sizeof(*sd->sd_meta));
			got_meta = 1;
		}

		memcpy(&ch_entry->src_meta, cp, sizeof(ch_entry->src_meta));

		no_disk++;
		cp++;
	}

	free(sm, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);
	free(fm, M_DEVBUF, s->smd_size);

done:
	DNPRINTF(SR_D_META, "%s: sr_meta_read found %d parts\n", DEVNAME(sc),
	    no_disk);
	return (no_disk);
}

void
sr_meta_opt_load(struct sr_softc *sc, struct sr_metadata *sm,
    struct sr_meta_opt_head *som)
{
	struct sr_meta_opt_hdr	*omh;
	struct sr_meta_opt_item *omi;
	u_int8_t		checksum[MD5_DIGEST_LENGTH];
	int			i;

	/* Process optional metadata. */
	omh = (struct sr_meta_opt_hdr *)((u_int8_t *)(sm + 1) +
	    sizeof(struct sr_meta_chunk) * sm->ssdi.ssd_chunk_no);
	for (i = 0; i < sm->ssdi.ssd_opt_no; i++) {

		omi = malloc(sizeof(struct sr_meta_opt_item), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		SLIST_INSERT_HEAD(som, omi, omi_link);

		if (omh->som_length == 0) {

			/* Load old fixed length optional metadata. */
			DNPRINTF(SR_D_META, "%s: old optional metadata of type "
			    "%u\n", DEVNAME(sc), omh->som_type);

			/* Validate checksum. */
			sr_checksum(sc, (void *)omh, &checksum,
			    SR_OLD_META_OPT_SIZE - MD5_DIGEST_LENGTH);
			if (bcmp(&checksum, (void *)omh + SR_OLD_META_OPT_MD5,
			    sizeof(checksum)))
				panic("%s: invalid optional metadata "
				    "checksum", DEVNAME(sc));

			/* Determine correct length. */
			switch (omh->som_type) {
			case SR_OPT_CRYPTO:
				omh->som_length = sizeof(struct sr_meta_crypto);
				break;
			case SR_OPT_BOOT:
				omh->som_length = sizeof(struct sr_meta_boot);
				break;
			case SR_OPT_KEYDISK:
				omh->som_length =
				    sizeof(struct sr_meta_keydisk);
				break;
			default:
				panic("unknown old optional metadata "
				    "type %u\n", omh->som_type);
			}

			omi->omi_som = malloc(omh->som_length, M_DEVBUF,
			    M_WAITOK | M_ZERO);
			memcpy((u_int8_t *)omi->omi_som + sizeof(*omi->omi_som),
			    (u_int8_t *)omh + SR_OLD_META_OPT_OFFSET,
			    omh->som_length - sizeof(*omi->omi_som));
			omi->omi_som->som_type = omh->som_type;
			omi->omi_som->som_length = omh->som_length;

			omh = (struct sr_meta_opt_hdr *)((void *)omh +
			    SR_OLD_META_OPT_SIZE);
		} else {

			/* Load variable length optional metadata. */
			DNPRINTF(SR_D_META, "%s: optional metadata of type %u, "
			    "length %u\n", DEVNAME(sc), omh->som_type,
			    omh->som_length);
			omi->omi_som = malloc(omh->som_length, M_DEVBUF,
			    M_WAITOK | M_ZERO);
			memcpy(omi->omi_som, omh, omh->som_length);

			/* Validate checksum. */
			memcpy(&checksum, &omi->omi_som->som_checksum,
			    MD5_DIGEST_LENGTH);
			bzero(&omi->omi_som->som_checksum, MD5_DIGEST_LENGTH);
			sr_checksum(sc, omi->omi_som,
			    &omi->omi_som->som_checksum, omh->som_length);
			if (bcmp(&checksum, &omi->omi_som->som_checksum,
			    sizeof(checksum)))
				panic("%s: invalid optional metadata checksum",
				    DEVNAME(sc));

			omh = (struct sr_meta_opt_hdr *)((void *)omh +
			    omh->som_length);
		}
	}
}

int
sr_meta_validate(struct sr_discipline *sd, dev_t dev, struct sr_metadata *sm,
    void *fm)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_meta_driver	*s;
#ifdef SR_DEBUG
	struct sr_meta_chunk	*mc;
#endif
	u_int8_t		checksum[MD5_DIGEST_LENGTH];
	char			devname[32];
	int			rv = 1;

	DNPRINTF(SR_D_META, "%s: sr_meta_validate(%p)\n", DEVNAME(sc), sm);

	sr_meta_getdevname(sc, dev, devname, sizeof(devname));

	s = &smd[sd->sd_meta_type];
	if (sd->sd_meta_type != SR_META_F_NATIVE)
		if (s->smd_validate(sd, sm, fm)) {
			sr_error(sc, "invalid foreign metadata");
			goto done;
		}

	/*
	 * at this point all foreign metadata has been translated to the native
	 * format and will be treated just like the native format
	 */

	if (sm->ssdi.ssd_magic != SR_MAGIC) {
		sr_error(sc, "not valid softraid metadata");
		goto done;
	}

	/* Verify metadata checksum. */
	sr_checksum(sc, sm, &checksum, sizeof(struct sr_meta_invariant));
	if (bcmp(&checksum, &sm->ssd_checksum, sizeof(checksum))) {
		sr_error(sc, "invalid metadata checksum");
		goto done;
	}

	/* Handle changes between versions. */
	if (sm->ssdi.ssd_version == 3) {

		/*
		 * Version 3 - update metadata version and fix up data blkno
		 * value since this did not exist in version 3.
		 */
		if (sm->ssd_data_blkno == 0)
			sm->ssd_data_blkno = SR_META_V3_DATA_OFFSET;
		sm->ssdi.ssd_secsize = DEV_BSIZE;

	} else if (sm->ssdi.ssd_version == 4) {

		/*
		 * Version 4 - original metadata format did not store
		 * data blkno so fix this up if necessary.
		 */
		if (sm->ssd_data_blkno == 0)
			sm->ssd_data_blkno = SR_DATA_OFFSET;
		sm->ssdi.ssd_secsize = DEV_BSIZE;

	} else if (sm->ssdi.ssd_version == 5) {

		/*
		 * Version 5 - variable length optional metadata. Migration
		 * from earlier fixed length optional metadata is handled
		 * in sr_meta_read().
		 */
		sm->ssdi.ssd_secsize = DEV_BSIZE;

	} else if (sm->ssdi.ssd_version == SR_META_VERSION) {

		/*
		 * Version 6 - store & report a sector size.
		 */

	} else {

		sr_error(sc, "cannot read metadata version %u on %s, "
		    "expected version %u or earlier",
		    sm->ssdi.ssd_version, devname, SR_META_VERSION);
		goto done;

	}

	/* Update version number and revision string. */
	sm->ssdi.ssd_version = SR_META_VERSION;
	snprintf(sm->ssdi.ssd_revision, sizeof(sm->ssdi.ssd_revision),
	    "%03d", SR_META_VERSION);

#ifdef SR_DEBUG
	/* warn if disk changed order */
	mc = (struct sr_meta_chunk *)(sm + 1);
	if (strncmp(mc[sm->ssdi.ssd_chunk_id].scmi.scm_devname, devname,
	    sizeof(mc[sm->ssdi.ssd_chunk_id].scmi.scm_devname)))
		DNPRINTF(SR_D_META, "%s: roaming device %s -> %s\n",
		    DEVNAME(sc), mc[sm->ssdi.ssd_chunk_id].scmi.scm_devname,
		    devname);
#endif

	/* we have meta data on disk */
	DNPRINTF(SR_D_META, "%s: sr_meta_validate valid metadata %s\n",
	    DEVNAME(sc), devname);

	rv = 0;
done:
	return (rv);
}

int
sr_meta_native_bootprobe(struct sr_softc *sc, dev_t devno,
    struct sr_boot_chunk_head *bch)
{
	struct vnode		*vn;
	struct disklabel	label;
	struct sr_metadata	*md = NULL;
	struct sr_discipline	*fake_sd = NULL;
	struct sr_boot_chunk	*bc;
	char			devname[32];
	dev_t			chrdev, rawdev;
	int			error, i;
	int			rv = SR_META_NOTCLAIMED;

	DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe\n", DEVNAME(sc));

	/*
	 * Use character raw device to avoid SCSI complaints about missing
	 * media on removable media devices.
	 */
	chrdev = blktochr(devno);
	rawdev = MAKEDISKDEV(major(chrdev), DISKUNIT(devno), RAW_PART);
	if (cdevvp(rawdev, &vn)) {
		sr_error(sc, "sr_meta_native_bootprobe: cannot allocate vnode");
		goto done;
	}

	/* open device */
	error = VOP_OPEN(vn, FREAD, NOCRED, curproc);
	if (error) {
		DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe open "
		    "failed\n", DEVNAME(sc));
		vput(vn);
		goto done;
	}

	/* get disklabel */
	error = VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED,
	    curproc);
	if (error) {
		DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe ioctl "
		    "failed\n", DEVNAME(sc));
		VOP_CLOSE(vn, FREAD, NOCRED, curproc);
		vput(vn);
		goto done;
	}

	/* we are done, close device */
	error = VOP_CLOSE(vn, FREAD, NOCRED, curproc);
	if (error) {
		DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe close "
		    "failed\n", DEVNAME(sc));
		vput(vn);
		goto done;
	}
	vput(vn);

	md = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_ZERO | M_NOWAIT);
	if (md == NULL) {
		sr_error(sc, "not enough memory for metadata buffer");
		goto done;
	}

	/* create fake sd to use utility functions */
	fake_sd = malloc(sizeof(struct sr_discipline), M_DEVBUF,
	    M_ZERO | M_NOWAIT);
	if (fake_sd == NULL) {
		sr_error(sc, "not enough memory for fake discipline");
		goto done;
	}
	fake_sd->sd_sc = sc;
	fake_sd->sd_meta_type = SR_META_F_NATIVE;

	for (i = 0; i < MAXPARTITIONS; i++) {
		if (label.d_partitions[i].p_fstype != FS_RAID)
			continue;

		/* open partition */
		rawdev = MAKEDISKDEV(major(devno), DISKUNIT(devno), i);
		if (bdevvp(rawdev, &vn)) {
			sr_error(sc, "sr_meta_native_bootprobe: cannot "
			    "allocate vnode for partition");
			goto done;
		}
		error = VOP_OPEN(vn, FREAD, NOCRED, curproc);
		if (error) {
			DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe "
			    "open failed, partition %d\n",
			    DEVNAME(sc), i);
			vput(vn);
			continue;
		}

		if (sr_meta_native_read(fake_sd, rawdev, md, NULL)) {
			sr_error(sc, "native bootprobe could not read native "
			    "metadata");
			VOP_CLOSE(vn, FREAD, NOCRED, curproc);
			vput(vn);
			continue;
		}

		/* are we a softraid partition? */
		if (md->ssdi.ssd_magic != SR_MAGIC) {
			VOP_CLOSE(vn, FREAD, NOCRED, curproc);
			vput(vn);
			continue;
		}

		sr_meta_getdevname(sc, rawdev, devname, sizeof(devname));
		if (sr_meta_validate(fake_sd, rawdev, md, NULL) == 0) {
			/* XXX fix M_WAITOK, this is boot time */
			bc = malloc(sizeof(struct sr_boot_chunk),
			    M_DEVBUF, M_WAITOK | M_ZERO);
			bc->sbc_metadata = malloc(sizeof(struct sr_metadata),
			    M_DEVBUF, M_WAITOK | M_ZERO);
			memcpy(bc->sbc_metadata, md, sizeof(struct sr_metadata));
			bc->sbc_mm = rawdev;
			SLIST_INSERT_HEAD(bch, bc, sbc_link);
			rv = SR_META_CLAIMED;
		}

		/* we are done, close partition */
		VOP_CLOSE(vn, FREAD, NOCRED, curproc);
		vput(vn);
	}

done:
	free(fake_sd, M_DEVBUF, sizeof(struct sr_discipline));
	free(md, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);

	return (rv);
}

int
sr_boot_assembly(struct sr_softc *sc)
{
	struct sr_boot_volume_head bvh;
	struct sr_boot_chunk_head bch, kdh;
	struct sr_boot_volume	*bv, *bv1, *bv2;
	struct sr_boot_chunk	*bc, *bcnext, *bc1, *bc2;
	struct sr_disk_head	sdklist;
	struct sr_disk		*sdk;
	struct disk		*dk;
	struct bioc_createraid	bcr;
	struct sr_meta_chunk	*hm;
	struct sr_chunk_head	*cl;
	struct sr_chunk		*hotspare, *chunk, *last;
	u_int64_t		*ondisk = NULL;
	dev_t			*devs = NULL;
	void			*data;
	char			devname[32];
	int			rv = 0, i;

	DNPRINTF(SR_D_META, "%s: sr_boot_assembly\n", DEVNAME(sc));

	SLIST_INIT(&sdklist);
	SLIST_INIT(&bvh);
	SLIST_INIT(&bch);
	SLIST_INIT(&kdh);

	dk = TAILQ_FIRST(&disklist);
	while (dk != NULL) {

		/* See if this disk has been checked. */
		SLIST_FOREACH(sdk, &sdklist, sdk_link)
			if (sdk->sdk_devno == dk->dk_devno)
				break;

		if (sdk != NULL || dk->dk_devno == NODEV) {
			dk = TAILQ_NEXT(dk, dk_link);
			continue;
		}

		/* Add this disk to the list that we've checked. */
		sdk = malloc(sizeof(struct sr_disk), M_DEVBUF,
		    M_NOWAIT | M_CANFAIL | M_ZERO);
		if (sdk == NULL)
			goto unwind;
		sdk->sdk_devno = dk->dk_devno;
		SLIST_INSERT_HEAD(&sdklist, sdk, sdk_link);

		/* Only check sd(4) and wd(4) devices. */
		if (strncmp(dk->dk_name, "sd", 2) &&
		    strncmp(dk->dk_name, "wd", 2)) {
			dk = TAILQ_NEXT(dk, dk_link);
			continue;
		}

		/* native softraid uses partitions */
		rw_enter_write(&sc->sc_lock);
		bio_status_init(&sc->sc_status, &sc->sc_dev);
		sr_meta_native_bootprobe(sc, dk->dk_devno, &bch);
		rw_exit_write(&sc->sc_lock);

		/* probe non-native disks if native failed. */

		/* Restart scan since we may have slept. */
		dk = TAILQ_FIRST(&disklist);
	}

	/*
	 * Create a list of volumes and associate chunks with each volume.
	 */
	for (bc = SLIST_FIRST(&bch); bc != NULL; bc = bcnext) {

		bcnext = SLIST_NEXT(bc, sbc_link);
		SLIST_REMOVE(&bch, bc, sr_boot_chunk, sbc_link);
		bc->sbc_chunk_id = bc->sbc_metadata->ssdi.ssd_chunk_id;

		/* Handle key disks separately. */
		if (bc->sbc_metadata->ssdi.ssd_level == SR_KEYDISK_LEVEL) {
			SLIST_INSERT_HEAD(&kdh, bc, sbc_link);
			continue;
		}

		SLIST_FOREACH(bv, &bvh, sbv_link) {
			if (bcmp(&bc->sbc_metadata->ssdi.ssd_uuid,
			    &bv->sbv_uuid,
			    sizeof(bc->sbc_metadata->ssdi.ssd_uuid)) == 0)
				break;
		}

		if (bv == NULL) {
			bv = malloc(sizeof(struct sr_boot_volume),
			    M_DEVBUF, M_NOWAIT | M_CANFAIL | M_ZERO);
			if (bv == NULL) {
				printf("%s: failed to allocate boot volume\n",
				    DEVNAME(sc));
				goto unwind;
			}

			bv->sbv_level = bc->sbc_metadata->ssdi.ssd_level;
			bv->sbv_volid = bc->sbc_metadata->ssdi.ssd_volid;
			bv->sbv_chunk_no = bc->sbc_metadata->ssdi.ssd_chunk_no;
			bv->sbv_flags = bc->sbc_metadata->ssdi.ssd_vol_flags;
			memcpy(&bv->sbv_uuid, &bc->sbc_metadata->ssdi.ssd_uuid,
			    sizeof(bc->sbc_metadata->ssdi.ssd_uuid));
			SLIST_INIT(&bv->sbv_chunks);

			/* Maintain volume order. */
			bv2 = NULL;
			SLIST_FOREACH(bv1, &bvh, sbv_link) {
				if (bv1->sbv_volid > bv->sbv_volid)
					break;
				bv2 = bv1;
			}
			if (bv2 == NULL) {
				DNPRINTF(SR_D_META, "%s: insert volume %u "
				    "at head\n", DEVNAME(sc), bv->sbv_volid);
				SLIST_INSERT_HEAD(&bvh, bv, sbv_link);
			} else {
				DNPRINTF(SR_D_META, "%s: insert volume %u "
				    "after %u\n", DEVNAME(sc), bv->sbv_volid,
				    bv2->sbv_volid);
				SLIST_INSERT_AFTER(bv2, bv, sbv_link);
			}
		}

		/* Maintain chunk order. */
		bc2 = NULL;
		SLIST_FOREACH(bc1, &bv->sbv_chunks, sbc_link) {
			if (bc1->sbc_chunk_id > bc->sbc_chunk_id)
				break;
			bc2 = bc1;
		}
		if (bc2 == NULL) {
			DNPRINTF(SR_D_META, "%s: volume %u insert chunk %u "
			    "at head\n", DEVNAME(sc), bv->sbv_volid,
			    bc->sbc_chunk_id);
			SLIST_INSERT_HEAD(&bv->sbv_chunks, bc, sbc_link);
		} else {
			DNPRINTF(SR_D_META, "%s: volume %u insert chunk %u "
			    "after %u\n", DEVNAME(sc), bv->sbv_volid,
			    bc->sbc_chunk_id, bc2->sbc_chunk_id);
			SLIST_INSERT_AFTER(bc2, bc, sbc_link);
		}

		bv->sbv_chunks_found++;
	}

	/* Allocate memory for device and ondisk version arrays. */
	devs = mallocarray(BIOC_CRMAXLEN, sizeof(dev_t), M_DEVBUF,
	    M_NOWAIT | M_CANFAIL);
	if (devs == NULL) {
		printf("%s: failed to allocate device array\n", DEVNAME(sc));
		goto unwind;
	}
	ondisk = mallocarray(BIOC_CRMAXLEN, sizeof(u_int64_t), M_DEVBUF,
	    M_NOWAIT | M_CANFAIL);
	if (ondisk == NULL) {
		printf("%s: failed to allocate ondisk array\n", DEVNAME(sc));
		goto unwind;
	}

	/*
	 * Assemble hotspare "volumes".
	 */
	SLIST_FOREACH(bv, &bvh, sbv_link) {

		/* Check if this is a hotspare "volume". */
		if (bv->sbv_level != SR_HOTSPARE_LEVEL ||
		    bv->sbv_chunk_no != 1)
			continue;

#ifdef SR_DEBUG
		DNPRINTF(SR_D_META, "%s: assembling hotspare volume ",
		    DEVNAME(sc));
		if (sr_debug & SR_D_META)
			sr_uuid_print(&bv->sbv_uuid, 0);
		DNPRINTF(SR_D_META, " volid %u with %u chunks\n",
		    bv->sbv_volid, bv->sbv_chunk_no);
#endif

		/* Create hotspare chunk metadata. */
		hotspare = malloc(sizeof(struct sr_chunk), M_DEVBUF,
		    M_NOWAIT | M_CANFAIL | M_ZERO);
		if (hotspare == NULL) {
			printf("%s: failed to allocate hotspare\n",
			    DEVNAME(sc));
			goto unwind;
		}

		bc = SLIST_FIRST(&bv->sbv_chunks);
		sr_meta_getdevname(sc, bc->sbc_mm, devname, sizeof(devname));
		hotspare->src_dev_mm = bc->sbc_mm;
		strlcpy(hotspare->src_devname, devname,
		    sizeof(hotspare->src_devname));
		hotspare->src_size = bc->sbc_metadata->ssdi.ssd_size;

		hm = &hotspare->src_meta;
		hm->scmi.scm_volid = SR_HOTSPARE_VOLID;
		hm->scmi.scm_chunk_id = 0;
		hm->scmi.scm_size = bc->sbc_metadata->ssdi.ssd_size;
		hm->scmi.scm_coerced_size = bc->sbc_metadata->ssdi.ssd_size;
		strlcpy(hm->scmi.scm_devname, devname,
		    sizeof(hm->scmi.scm_devname));
		memcpy(&hm->scmi.scm_uuid, &bc->sbc_metadata->ssdi.ssd_uuid,
		    sizeof(struct sr_uuid));

		sr_checksum(sc, hm, &hm->scm_checksum,
		    sizeof(struct sr_meta_chunk_invariant));

		hm->scm_status = BIOC_SDHOTSPARE;

		/* Add chunk to hotspare list. */
		rw_enter_write(&sc->sc_hs_lock);
		cl = &sc->sc_hotspare_list;
		if (SLIST_EMPTY(cl))
			SLIST_INSERT_HEAD(cl, hotspare, src_link);
		else {
			SLIST_FOREACH(chunk, cl, src_link)
				last = chunk;
			SLIST_INSERT_AFTER(last, hotspare, src_link);
		}
		sc->sc_hotspare_no++;
		rw_exit_write(&sc->sc_hs_lock);

	}

	/*
	 * Assemble RAID volumes.
	 */
	SLIST_FOREACH(bv, &bvh, sbv_link) {

		bzero(&bcr, sizeof(bcr));
		data = NULL;

		/* Check if this is a hotspare "volume". */
		if (bv->sbv_level == SR_HOTSPARE_LEVEL &&
		    bv->sbv_chunk_no == 1)
			continue;

		/*
		 * Skip volumes that are marked as no auto assemble, unless
		 * this was the volume which we actually booted from.
		 */
		if (bcmp(&sr_bootuuid, &bv->sbv_uuid, sizeof(sr_bootuuid)) != 0)
			if (bv->sbv_flags & BIOC_SCNOAUTOASSEMBLE)
				continue;

#ifdef SR_DEBUG
		DNPRINTF(SR_D_META, "%s: assembling volume ", DEVNAME(sc));
		if (sr_debug & SR_D_META)
			sr_uuid_print(&bv->sbv_uuid, 0);
		DNPRINTF(SR_D_META, " volid %u with %u chunks\n",
		    bv->sbv_volid, bv->sbv_chunk_no);
#endif

		/*
		 * If this is a crypto volume, try to find a matching
		 * key disk...
		 */
		bcr.bc_key_disk = NODEV;
		if (bv->sbv_level == 'C') {
			SLIST_FOREACH(bc, &kdh, sbc_link) {
				if (bcmp(&bc->sbc_metadata->ssdi.ssd_uuid,
				    &bv->sbv_uuid,
				    sizeof(bc->sbc_metadata->ssdi.ssd_uuid))
				    == 0)
					bcr.bc_key_disk = bc->sbc_mm;
			}
		}

		for (i = 0; i < BIOC_CRMAXLEN; i++) {
			devs[i] = NODEV; /* mark device as illegal */
			ondisk[i] = 0;
		}

		SLIST_FOREACH(bc, &bv->sbv_chunks, sbc_link) {
			if (devs[bc->sbc_chunk_id] != NODEV) {
				bv->sbv_chunks_found--;
				sr_meta_getdevname(sc, bc->sbc_mm, devname,
				    sizeof(devname));
				printf("%s: found duplicate chunk %u for "
				    "volume %u on device %s\n", DEVNAME(sc),
				    bc->sbc_chunk_id, bv->sbv_volid, devname);
			}

			if (devs[bc->sbc_chunk_id] == NODEV ||
			    bc->sbc_metadata->ssd_ondisk >
			    ondisk[bc->sbc_chunk_id]) {
				devs[bc->sbc_chunk_id] = bc->sbc_mm;
				ondisk[bc->sbc_chunk_id] =
				    bc->sbc_metadata->ssd_ondisk;
				DNPRINTF(SR_D_META, "%s: using ondisk "
				    "metadata version %llu for chunk %u\n",
				    DEVNAME(sc), ondisk[bc->sbc_chunk_id],
				    bc->sbc_chunk_id);
			}
		}

		if (bv->sbv_chunk_no != bv->sbv_chunks_found) {
			printf("%s: not all chunks were provided; "
			    "attempting to bring volume %d online\n",
			    DEVNAME(sc), bv->sbv_volid);
		}

		bcr.bc_level = bv->sbv_level;
		bcr.bc_dev_list_len = bv->sbv_chunk_no * sizeof(dev_t);
		bcr.bc_dev_list = devs;
		bcr.bc_flags = BIOC_SCDEVT |
		    (bv->sbv_flags & BIOC_SCNOAUTOASSEMBLE);

		if (bv->sbv_level == 'C' &&
		    bcmp(&sr_bootuuid, &bv->sbv_uuid, sizeof(sr_bootuuid)) == 0)
			data = sr_bootkey;

		rw_enter_write(&sc->sc_lock);
		bio_status_init(&sc->sc_status, &sc->sc_dev);
		sr_ioctl_createraid(sc, &bcr, 0, data);
		rw_exit_write(&sc->sc_lock);

		rv++;
	}

	/* done with metadata */
unwind:
	/* Free boot volumes and associated chunks. */
	for (bv1 = SLIST_FIRST(&bvh); bv1 != NULL; bv1 = bv2) {
		bv2 = SLIST_NEXT(bv1, sbv_link);
		for (bc1 = SLIST_FIRST(&bv1->sbv_chunks); bc1 != NULL;
		    bc1 = bc2) {
			bc2 = SLIST_NEXT(bc1, sbc_link);
			free(bc1->sbc_metadata, M_DEVBUF, 0);
			free(bc1, M_DEVBUF, 0);
		}
		free(bv1, M_DEVBUF, 0);
	}
	/* Free keydisks chunks. */
	for (bc1 = SLIST_FIRST(&kdh); bc1 != NULL; bc1 = bc2) {
		bc2 = SLIST_NEXT(bc1, sbc_link);
		free(bc1->sbc_metadata, M_DEVBUF, 0);
		free(bc1, M_DEVBUF, 0);
	}
	/* Free unallocated chunks. */
	for (bc1 = SLIST_FIRST(&bch); bc1 != NULL; bc1 = bc2) {
		bc2 = SLIST_NEXT(bc1, sbc_link);
		free(bc1->sbc_metadata, M_DEVBUF, 0);
		free(bc1, M_DEVBUF, 0);
	}

	while (!SLIST_EMPTY(&sdklist)) {
		sdk = SLIST_FIRST(&sdklist);
		SLIST_REMOVE_HEAD(&sdklist, sdk_link);
		free(sdk, M_DEVBUF, 0);
	}

	free(devs, M_DEVBUF, BIOC_CRMAXLEN * sizeof(dev_t));
	free(ondisk, M_DEVBUF, BIOC_CRMAXLEN * sizeof(u_int64_t));

	return (rv);
}

void
sr_map_root(void)
{
	struct sr_softc		*sc = softraid0;
	struct sr_discipline	*sd;
	struct sr_meta_opt_item	*omi;
	struct sr_meta_boot	*sbm;
	u_char			duid[8];
	int			i;

	DNPRINTF(SR_D_MISC, "%s: sr_map_root\n", DEVNAME(sc));

	if (sc == NULL)
		return;

	bzero(duid, sizeof(duid));
	if (bcmp(rootduid, duid, sizeof(duid)) == 0) {
		DNPRINTF(SR_D_MISC, "%s: root duid is zero\n", DEVNAME(sc));
		return;
	}

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		SLIST_FOREACH(omi, &sd->sd_meta_opt, omi_link) {
			if (omi->omi_som->som_type != SR_OPT_BOOT)
				continue;
			sbm = (struct sr_meta_boot *)omi->omi_som;
			for (i = 0; i < SR_MAX_BOOT_DISKS; i++) {
				if (bcmp(rootduid, sbm->sbm_boot_duid[i],
				    sizeof(rootduid)) == 0) {
					memcpy(rootduid, sbm->sbm_root_duid,
					    sizeof(rootduid));
					DNPRINTF(SR_D_MISC, "%s: root duid "
					    "mapped to %02hx%02hx%02hx%02hx"
					    "%02hx%02hx%02hx%02hx\n",
					    DEVNAME(sc), rootduid[0],
					    rootduid[1], rootduid[2],
					    rootduid[3], rootduid[4],
					    rootduid[5], rootduid[6],
					    rootduid[7]);
					return;
				}
			}
		}
	}
}

int
sr_meta_native_probe(struct sr_softc *sc, struct sr_chunk *ch_entry)
{
	struct disklabel	label;
	char			*devname;
	int			error, part;
	u_int64_t		size;

	DNPRINTF(SR_D_META, "%s: sr_meta_native_probe(%s)\n",
	   DEVNAME(sc), ch_entry->src_devname);

	devname = ch_entry->src_devname;
	part = DISKPART(ch_entry->src_dev_mm);

	/* get disklabel */
	error = VOP_IOCTL(ch_entry->src_vn, DIOCGDINFO, (caddr_t)&label, FREAD,
	    NOCRED, curproc);
	if (error) {
		DNPRINTF(SR_D_META, "%s: %s can't obtain disklabel\n",
		    DEVNAME(sc), devname);
		goto unwind;
	}
	memcpy(ch_entry->src_duid, label.d_uid, sizeof(ch_entry->src_duid));

	/* make sure the partition is of the right type */
	if (label.d_partitions[part].p_fstype != FS_RAID) {
		DNPRINTF(SR_D_META,
		    "%s: %s partition not of type RAID (%d)\n", DEVNAME(sc),
		    devname,
		    label.d_partitions[part].p_fstype);
		goto unwind;
	}

	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part]));
	if (size <= SR_DATA_OFFSET) {
		DNPRINTF(SR_D_META, "%s: %s partition too small\n", DEVNAME(sc),
		    devname);
		goto unwind;
	}
	size -= SR_DATA_OFFSET;
	if (size > INT64_MAX) {
		DNPRINTF(SR_D_META, "%s: %s partition too large\n", DEVNAME(sc),
		    devname);
		goto unwind;
	}
	ch_entry->src_size = size;
	ch_entry->src_secsize = label.d_secsize;

	DNPRINTF(SR_D_META, "%s: probe found %s size %lld\n", DEVNAME(sc),
	    devname, (long long)size);

	return (SR_META_F_NATIVE);
unwind:
	DNPRINTF(SR_D_META, "%s: invalid device: %s\n", DEVNAME(sc),
	    devname ? devname : "nodev");
	return (SR_META_F_INVALID);
}

int
sr_meta_native_attach(struct sr_discipline *sd, int force)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_metadata	*md = NULL;
	struct sr_chunk		*ch_entry, *ch_next;
	struct sr_uuid		uuid;
	u_int64_t		version = 0;
	int			sr, not_sr, rv = 1, d, expected = -1, old_meta = 0;

	DNPRINTF(SR_D_META, "%s: sr_meta_native_attach\n", DEVNAME(sc));

	md = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_ZERO | M_NOWAIT);
	if (md == NULL) {
		sr_error(sc, "not enough memory for metadata buffer");
		goto bad;
	}

	bzero(&uuid, sizeof uuid);

	sr = not_sr = d = 0;
	SLIST_FOREACH(ch_entry, cl, src_link) {
		if (ch_entry->src_dev_mm == NODEV)
			continue;

		if (sr_meta_native_read(sd, ch_entry->src_dev_mm, md, NULL)) {
			sr_error(sc, "could not read native metadata");
			goto bad;
		}

		if (md->ssdi.ssd_magic == SR_MAGIC) {
			sr++;
			ch_entry->src_meta.scmi.scm_chunk_id =
			    md->ssdi.ssd_chunk_id;
			if (d == 0) {
				memcpy(&uuid, &md->ssdi.ssd_uuid, sizeof uuid);
				expected = md->ssdi.ssd_chunk_no;
				version = md->ssd_ondisk;
				d++;
				continue;
			} else if (bcmp(&md->ssdi.ssd_uuid, &uuid,
			    sizeof uuid)) {
				sr_error(sc, "not part of the same volume");
				goto bad;
			}
			if (md->ssd_ondisk != version) {
				old_meta++;
				version = MAX(md->ssd_ondisk, version);
			}
		} else
			not_sr++;
	}

	if (sr && not_sr) {
		sr_error(sc, "not all chunks are of the native metadata "
		    "format");
		goto bad;
	}

	/* mixed metadata versions; mark bad disks offline */
	if (old_meta) {
		d = 0;
		for (ch_entry = SLIST_FIRST(cl); ch_entry != NULL;
		    ch_entry = ch_next, d++) {
			ch_next = SLIST_NEXT(ch_entry, src_link);

			/* XXX do we want to read this again? */
			if (ch_entry->src_dev_mm == NODEV)
				panic("src_dev_mm == NODEV");
			if (sr_meta_native_read(sd, ch_entry->src_dev_mm, md,
			    NULL))
				sr_warn(sc, "could not read native metadata");
			if (md->ssd_ondisk != version)
				sd->sd_vol.sv_chunks[d]->src_meta.scm_status =
				    BIOC_SDOFFLINE;
		}
	}

	if (expected != sr && !force && expected != -1) {
		DNPRINTF(SR_D_META, "%s: not all chunks were provided, trying "
		    "anyway\n", DEVNAME(sc));
	}

	rv = 0;
bad:
	free(md, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);
	return (rv);
}

int
sr_meta_native_read(struct sr_discipline *sd, dev_t dev,
    struct sr_metadata *md, void *fm)
{
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif
	DNPRINTF(SR_D_META, "%s: sr_meta_native_read(0x%x, %p)\n",
	    DEVNAME(sc), dev, md);

	return (sr_meta_rw(sd, dev, md, B_READ));
}

int
sr_meta_native_write(struct sr_discipline *sd, dev_t dev,
    struct sr_metadata *md, void *fm)
{
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif
	DNPRINTF(SR_D_META, "%s: sr_meta_native_write(0x%x, %p)\n",
	    DEVNAME(sc), dev, md);

	return (sr_meta_rw(sd, dev, md, B_WRITE));
}

void
sr_hotplug_register(struct sr_discipline *sd, void *func)
{
	struct sr_hotplug_list	*mhe;

	DNPRINTF(SR_D_MISC, "%s: sr_hotplug_register: %p\n",
	    DEVNAME(sd->sd_sc), func);

	/* make sure we aren't on the list yet */
	SLIST_FOREACH(mhe, &sr_hotplug_callbacks, shl_link)
		if (mhe->sh_hotplug == func)
			return;

	mhe = malloc(sizeof(struct sr_hotplug_list), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	mhe->sh_hotplug = func;
	mhe->sh_sd = sd;
	SLIST_INSERT_HEAD(&sr_hotplug_callbacks, mhe, shl_link);
}

void
sr_hotplug_unregister(struct sr_discipline *sd, void *func)
{
	struct sr_hotplug_list	*mhe;

	DNPRINTF(SR_D_MISC, "%s: sr_hotplug_unregister: %s %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, func);

	/* make sure we are on the list yet */
	SLIST_FOREACH(mhe, &sr_hotplug_callbacks, shl_link) {
		if (mhe->sh_hotplug == func)
			break;
	}
	if (mhe != NULL) {
		SLIST_REMOVE(&sr_hotplug_callbacks, mhe,
		    sr_hotplug_list, shl_link);
		free(mhe, M_DEVBUF, 0);
	}
}

void
sr_disk_attach(struct disk *diskp, int action)
{
	struct sr_hotplug_list	*mhe;

	SLIST_FOREACH(mhe, &sr_hotplug_callbacks, shl_link)
		if (mhe->sh_sd->sd_ready)
			mhe->sh_hotplug(mhe->sh_sd, diskp, action);
}

int
sr_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
sr_attach(struct device *parent, struct device *self, void *aux)
{
	struct sr_softc		*sc = (void *)self;
	struct scsibus_attach_args saa;

	DNPRINTF(SR_D_MISC, "\n%s: sr_attach", DEVNAME(sc));

	if (softraid0 == NULL)
		softraid0 = sc;

	rw_init(&sc->sc_lock, "sr_lock");
	rw_init(&sc->sc_hs_lock, "sr_hs_lock");

	SLIST_INIT(&sr_hotplug_callbacks);
	TAILQ_INIT(&sc->sc_dis_list);
	SLIST_INIT(&sc->sc_hotspare_list);

#if NBIO > 0
	if (bio_register(&sc->sc_dev, sr_bio_ioctl) != 0)
		printf("%s: controller registration failed", DEVNAME(sc));
#endif /* NBIO > 0 */

#ifndef SMALL_KERNEL
	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));
	sensordev_install(&sc->sc_sensordev);
#endif /* SMALL_KERNEL */

	printf("\n");

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &sr_switch;
	sc->sc_link.adapter_target = SR_MAX_LD;
	sc->sc_link.adapter_buswidth = SR_MAX_LD;
	sc->sc_link.luns = 1;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_scsibus = (struct scsibus_softc *)config_found(&sc->sc_dev,
	    &saa, scsiprint);

	softraid_disk_attach = sr_disk_attach;

	sr_boot_assembly(sc);

	explicit_bzero(sr_bootkey, sizeof(sr_bootkey));
}

int
sr_detach(struct device *self, int flags)
{
	struct sr_softc		*sc = (void *)self;
	int			rv;

	DNPRINTF(SR_D_MISC, "%s: sr_detach\n", DEVNAME(sc));

	softraid_disk_attach = NULL;

	sr_shutdown();

#ifndef SMALL_KERNEL
	if (sc->sc_sensor_task != NULL)
		sensor_task_unregister(sc->sc_sensor_task);
	sensordev_deinstall(&sc->sc_sensordev);
#endif /* SMALL_KERNEL */

	if (sc->sc_scsibus != NULL) {
		rv = config_detach((struct device *)sc->sc_scsibus, flags);
		if (rv != 0)
			return (rv);
		sc->sc_scsibus = NULL;
	}

	return (0);
}

void
sr_info(struct sr_softc *sc, const char *fmt, ...)
{
	va_list			ap;

	rw_assert_wrlock(&sc->sc_lock);

	va_start(ap, fmt);
	bio_status(&sc->sc_status, 0, BIO_MSG_INFO, fmt, &ap);
	va_end(ap);
}

void
sr_warn(struct sr_softc *sc, const char *fmt, ...)
{
	va_list			ap;

	rw_assert_wrlock(&sc->sc_lock);

	va_start(ap, fmt);
	bio_status(&sc->sc_status, 1, BIO_MSG_WARN, fmt, &ap);
	va_end(ap);
}

void
sr_error(struct sr_softc *sc, const char *fmt, ...)
{
	va_list			ap;

	rw_assert_wrlock(&sc->sc_lock);

	va_start(ap, fmt);
	bio_status(&sc->sc_status, 1, BIO_MSG_ERROR, fmt, &ap);
	va_end(ap);
}

void
sr_minphys(struct buf *bp, struct scsi_link *sl)
{
	DNPRINTF(SR_D_MISC, "sr_minphys: %ld\n", bp->b_bcount);

	/* XXX currently using SR_MAXFER = MAXPHYS */
	if (bp->b_bcount > SR_MAXFER)
		bp->b_bcount = SR_MAXFER;
	minphys(bp);
}

void
sr_copy_internal_data(struct scsi_xfer *xs, void *v, size_t size)
{
	size_t			copy_cnt;

	DNPRINTF(SR_D_MISC, "sr_copy_internal_data xs: %p size: %zu\n",
	    xs, size);

	if (xs->datalen) {
		copy_cnt = MIN(size, xs->datalen);
		memcpy(xs->data, v, copy_cnt);
	}
}

int
sr_ccb_alloc(struct sr_discipline *sd)
{
	struct sr_ccb		*ccb;
	int			i;

	if (!sd)
		return (1);

	DNPRINTF(SR_D_CCB, "%s: sr_ccb_alloc\n", DEVNAME(sd->sd_sc));

	if (sd->sd_ccb)
		return (1);

	sd->sd_ccb = mallocarray(sd->sd_max_wu,
	    sd->sd_max_ccb_per_wu * sizeof(struct sr_ccb),
	    M_DEVBUF, M_WAITOK | M_ZERO);
	TAILQ_INIT(&sd->sd_ccb_freeq);
	for (i = 0; i < sd->sd_max_wu * sd->sd_max_ccb_per_wu; i++) {
		ccb = &sd->sd_ccb[i];
		ccb->ccb_dis = sd;
		sr_ccb_put(ccb);
	}

	DNPRINTF(SR_D_CCB, "%s: sr_ccb_alloc ccb: %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_max_wu * sd->sd_max_ccb_per_wu);

	return (0);
}

void
sr_ccb_free(struct sr_discipline *sd)
{
	struct sr_ccb		*ccb;

	if (!sd)
		return;

	DNPRINTF(SR_D_CCB, "%s: sr_ccb_free %p\n", DEVNAME(sd->sd_sc), sd);

	while ((ccb = TAILQ_FIRST(&sd->sd_ccb_freeq)) != NULL)
		TAILQ_REMOVE(&sd->sd_ccb_freeq, ccb, ccb_link);

	free(sd->sd_ccb, M_DEVBUF, 0);
}

struct sr_ccb *
sr_ccb_get(struct sr_discipline *sd)
{
	struct sr_ccb		*ccb;
	int			s;

	s = splbio();

	ccb = TAILQ_FIRST(&sd->sd_ccb_freeq);
	if (ccb) {
		TAILQ_REMOVE(&sd->sd_ccb_freeq, ccb, ccb_link);
		ccb->ccb_state = SR_CCB_INPROGRESS;
	}

	splx(s);

	DNPRINTF(SR_D_CCB, "%s: sr_ccb_get: %p\n", DEVNAME(sd->sd_sc),
	    ccb);

	return (ccb);
}

void
sr_ccb_put(struct sr_ccb *ccb)
{
	struct sr_discipline	*sd = ccb->ccb_dis;
	int			s;

	DNPRINTF(SR_D_CCB, "%s: sr_ccb_put: %p\n", DEVNAME(sd->sd_sc),
	    ccb);

	s = splbio();

	ccb->ccb_wu = NULL;
	ccb->ccb_state = SR_CCB_FREE;
	ccb->ccb_target = -1;
	ccb->ccb_opaque = NULL;

	TAILQ_INSERT_TAIL(&sd->sd_ccb_freeq, ccb, ccb_link);

	splx(s);
}

struct sr_ccb *
sr_ccb_rw(struct sr_discipline *sd, int chunk, daddr_t blkno,
    long len, u_int8_t *data, int xsflags, int ccbflags)
{
	struct sr_chunk		*sc = sd->sd_vol.sv_chunks[chunk];
	struct sr_ccb		*ccb = NULL;

	ccb = sr_ccb_get(sd);
	if (ccb == NULL)
		goto out;

	ccb->ccb_flags = ccbflags;
	ccb->ccb_target = chunk;

	ccb->ccb_buf.b_flags = B_PHYS | B_CALL;
	if (ISSET(xsflags, SCSI_DATA_IN))
		ccb->ccb_buf.b_flags |= B_READ;
	else
		ccb->ccb_buf.b_flags |= B_WRITE;

	ccb->ccb_buf.b_blkno = blkno + sd->sd_meta->ssd_data_blkno;
	ccb->ccb_buf.b_bcount = len;
	ccb->ccb_buf.b_bufsize = len;
	ccb->ccb_buf.b_resid = len;
	ccb->ccb_buf.b_data = data;
	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_iodone = sd->sd_scsi_intr;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_buf.b_dev = sc->src_dev_mm;
	ccb->ccb_buf.b_vp = sc->src_vn;
	ccb->ccb_buf.b_bq = NULL;

	if (!ISSET(ccb->ccb_buf.b_flags, B_READ))
		ccb->ccb_buf.b_vp->v_numoutput++;

	LIST_INIT(&ccb->ccb_buf.b_dep);

	DNPRINTF(SR_D_DIS, "%s: %s %s ccb "
	    "b_bcount %ld b_blkno %lld b_flags 0x%0lx b_data %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name,
	    ccb->ccb_buf.b_bcount, (long long)ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);

out:
	return ccb;
}

void
sr_ccb_done(struct sr_ccb *ccb)
{
	struct sr_workunit	*wu = ccb->ccb_wu;
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_softc		*sc = sd->sd_sc;

	DNPRINTF(SR_D_INTR, "%s: %s %s ccb done b_bcount %ld b_resid %zu"
	    " b_flags 0x%0lx block %lld target %d\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname, sd->sd_name,
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    (long long)ccb->ccb_buf.b_blkno, ccb->ccb_target);

	splassert(IPL_BIO);

	if (ccb->ccb_target == -1)
		panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);

	if (ccb->ccb_buf.b_flags & B_ERROR) {
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target %d\n",
		    DEVNAME(sc), (long long)ccb->ccb_buf.b_blkno,
		    ccb->ccb_target);
		if (ISSET(sd->sd_capabilities, SR_CAP_REDUNDANT))
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			printf("%s: %s: i/o error %d @@ %s block %lld\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname,
			    ccb->ccb_buf.b_error, sd->sd_name,
			    (long long)ccb->ccb_buf.b_blkno);
		ccb->ccb_state = SR_CCB_FAILED;
		wu->swu_ios_failed++;
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}

	wu->swu_ios_complete++;
}

int
sr_wu_alloc(struct sr_discipline *sd, int wu_size)
{
	struct sr_workunit	*wu;
	int			i, no_wu;

	DNPRINTF(SR_D_WU, "%s: sr_wu_alloc %p %d\n", DEVNAME(sd->sd_sc),
	    sd, sd->sd_max_wu);

	no_wu = sd->sd_max_wu;
	sd->sd_wu_pending = no_wu;

	mtx_init(&sd->sd_wu_mtx, IPL_BIO);
	TAILQ_INIT(&sd->sd_wu);
	TAILQ_INIT(&sd->sd_wu_freeq);
	TAILQ_INIT(&sd->sd_wu_pendq);
	TAILQ_INIT(&sd->sd_wu_defq);

	for (i = 0; i < no_wu; i++) {
		wu = malloc(wu_size, M_DEVBUF, M_WAITOK | M_ZERO);
		TAILQ_INSERT_TAIL(&sd->sd_wu, wu, swu_next);
		TAILQ_INIT(&wu->swu_ccb);
		wu->swu_dis = sd;
		task_set(&wu->swu_task, sr_wu_done_callback, wu);
		sr_wu_put(sd, wu);
	}

	return (0);
}

void
sr_wu_free(struct sr_discipline *sd)
{
	struct sr_workunit	*wu;

	DNPRINTF(SR_D_WU, "%s: sr_wu_free %p\n", DEVNAME(sd->sd_sc), sd);

	while ((wu = TAILQ_FIRST(&sd->sd_wu_freeq)) != NULL)
		TAILQ_REMOVE(&sd->sd_wu_freeq, wu, swu_link);
	while ((wu = TAILQ_FIRST(&sd->sd_wu_pendq)) != NULL)
		TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
	while ((wu = TAILQ_FIRST(&sd->sd_wu_defq)) != NULL)
		TAILQ_REMOVE(&sd->sd_wu_defq, wu, swu_link);

	while ((wu = TAILQ_FIRST(&sd->sd_wu)) != NULL) {
		TAILQ_REMOVE(&sd->sd_wu, wu, swu_next);
		free(wu, M_DEVBUF, 0);
	}
}

void *
sr_wu_get(void *xsd)
{
	struct sr_discipline	*sd = (struct sr_discipline *)xsd;
	struct sr_workunit	*wu;

	mtx_enter(&sd->sd_wu_mtx);
	wu = TAILQ_FIRST(&sd->sd_wu_freeq);
	if (wu) {
		TAILQ_REMOVE(&sd->sd_wu_freeq, wu, swu_link);
		sd->sd_wu_pending++;
	}
	mtx_leave(&sd->sd_wu_mtx);

	DNPRINTF(SR_D_WU, "%s: sr_wu_get: %p\n", DEVNAME(sd->sd_sc), wu);

	return (wu);
}

void
sr_wu_put(void *xsd, void *xwu)
{
	struct sr_discipline	*sd = (struct sr_discipline *)xsd;
	struct sr_workunit	*wu = (struct sr_workunit *)xwu;

	DNPRINTF(SR_D_WU, "%s: sr_wu_put: %p\n", DEVNAME(sd->sd_sc), wu);

	sr_wu_release_ccbs(wu);
	sr_wu_init(sd, wu);

	mtx_enter(&sd->sd_wu_mtx);
	TAILQ_INSERT_TAIL(&sd->sd_wu_freeq, wu, swu_link);
	sd->sd_wu_pending--;
	mtx_leave(&sd->sd_wu_mtx);
}

void
sr_wu_init(struct sr_discipline *sd, struct sr_workunit *wu)
{
	int			s;

	s = splbio();
	if (wu->swu_cb_active == 1)
		panic("%s: sr_wu_init got active wu", DEVNAME(sd->sd_sc));
	splx(s);

	wu->swu_xs = NULL;
	wu->swu_state = SR_WU_FREE;
	wu->swu_flags = 0;
	wu->swu_blk_start = 0;
	wu->swu_blk_end = 0;
	wu->swu_collider = NULL;
}

void
sr_wu_enqueue_ccb(struct sr_workunit *wu, struct sr_ccb *ccb)
{
	struct sr_discipline	*sd = wu->swu_dis;
	int			s;

	s = splbio();
	if (wu->swu_cb_active == 1)
		panic("%s: sr_wu_enqueue_ccb got active wu",
		    DEVNAME(sd->sd_sc));
	ccb->ccb_wu = wu;
	wu->swu_io_count++;
	TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);
	splx(s);
}

void
sr_wu_release_ccbs(struct sr_workunit *wu)
{
	struct sr_ccb		*ccb;

	/* Return all ccbs that are associated with this workunit. */
	while ((ccb = TAILQ_FIRST(&wu->swu_ccb)) != NULL) {
		TAILQ_REMOVE(&wu->swu_ccb, ccb, ccb_link);
		sr_ccb_put(ccb);
	}

	wu->swu_io_count = 0;
	wu->swu_ios_complete = 0;
	wu->swu_ios_failed = 0;
	wu->swu_ios_succeeded = 0;
}

void
sr_wu_done(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;

	DNPRINTF(SR_D_INTR, "%s: sr_wu_done count %d completed %d failed %d\n",
	    DEVNAME(sd->sd_sc), wu->swu_io_count, wu->swu_ios_complete,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete < wu->swu_io_count)
		return;

	task_add(sd->sd_taskq, &wu->swu_task);
}

void
sr_wu_done_callback(void *xwu)
{
	struct sr_workunit	*wu = xwu;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_workunit	*wup;
	int			s;

	/*
	 * The SR_WUF_DISCIPLINE or SR_WUF_REBUILD flag must be set if
	 * the work unit is not associated with a scsi_xfer.
	 */
	KASSERT(xs != NULL ||
	    (wu->swu_flags & (SR_WUF_DISCIPLINE|SR_WUF_REBUILD)));

	s = splbio();

	if (xs != NULL) {
		if (wu->swu_ios_failed)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;
	}

	if (sd->sd_scsi_wu_done) {
		if (sd->sd_scsi_wu_done(wu) == SR_WU_RESTART)
			goto done;
	}

	/* Remove work unit from pending queue. */
	TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link)
		if (wup == wu)
			break;
	if (wup == NULL)
		panic("%s: wu %p not on pending queue",
		    DEVNAME(sd->sd_sc), wu);
	TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

	if (wu->swu_collider) {
		if (wu->swu_ios_failed)
			sr_raid_recreate_wu(wu->swu_collider);

		/* XXX Should the collider be failed if this xs failed? */
		sr_raid_startwu(wu->swu_collider);
	}

	/*
	 * If a discipline provides its own sd_scsi_done function, then it
	 * is responsible for calling sr_scsi_done() once I/O is complete.
	 */
	if (wu->swu_flags & SR_WUF_REBUILD)
		wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
	if (wu->swu_flags & SR_WUF_WAKEUP)
		wakeup(wu);
	if (sd->sd_scsi_done)
		sd->sd_scsi_done(wu);
	else if (wu->swu_flags & SR_WUF_DISCIPLINE)
		sr_scsi_wu_put(sd, wu);
	else if (!(wu->swu_flags & SR_WUF_REBUILD))
		sr_scsi_done(sd, xs);

done:
	splx(s);
}

struct sr_workunit *
sr_scsi_wu_get(struct sr_discipline *sd, int flags)
{
	return scsi_io_get(&sd->sd_iopool, flags);
}

void
sr_scsi_wu_put(struct sr_discipline *sd, struct sr_workunit *wu)
{
	scsi_io_put(&sd->sd_iopool, wu);

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
}

void
sr_scsi_done(struct sr_discipline *sd, struct scsi_xfer *xs)
{
	DNPRINTF(SR_D_DIS, "%s: sr_scsi_done: xs %p\n", DEVNAME(sd->sd_sc), xs);

	if (xs->error == XS_NOERROR)
		xs->resid = 0;

	scsi_done(xs);

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
}

void
sr_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link	*link = xs->sc_link;
	struct sr_softc		*sc = link->adapter_softc;
	struct sr_workunit	*wu = xs->io;
	struct sr_discipline	*sd;

	DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd target %d xs %p flags %#x\n",
	    DEVNAME(sc), link->target, xs, xs->flags);

	sd = sc->sc_targets[link->target];
	if (sd == NULL)
		panic("%s: sr_scsi_cmd NULL discipline", DEVNAME(sc));

	if (sd->sd_deleted) {
		printf("%s: %s device is being deleted, failing io\n",
		    DEVNAME(sc), sd->sd_meta->ssd_devname);
		goto stuffup;
	}

	/* scsi layer *can* re-send wu without calling sr_wu_put(). */
	sr_wu_release_ccbs(wu);
	sr_wu_init(sd, wu);
	wu->swu_state = SR_WU_INPROGRESS;
	wu->swu_xs = xs;

	switch (xs->cmd->opcode) {
	case READ_COMMAND:
	case READ_BIG:
	case READ_16:
	case WRITE_COMMAND:
	case WRITE_BIG:
	case WRITE_16:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: READ/WRITE %02x\n",
		    DEVNAME(sc), xs->cmd->opcode);
		if (sd->sd_scsi_rw(wu))
			goto stuffup;
		break;

	case SYNCHRONIZE_CACHE:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: SYNCHRONIZE_CACHE\n",
		    DEVNAME(sc));
		if (sd->sd_scsi_sync(wu))
			goto stuffup;
		goto complete;

	case TEST_UNIT_READY:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: TEST_UNIT_READY\n",
		    DEVNAME(sc));
		if (sd->sd_scsi_tur(wu))
			goto stuffup;
		goto complete;

	case START_STOP:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: START_STOP\n",
		    DEVNAME(sc));
		if (sd->sd_scsi_start_stop(wu))
			goto stuffup;
		goto complete;

	case INQUIRY:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: INQUIRY\n",
		    DEVNAME(sc));
		if (sd->sd_scsi_inquiry(wu))
			goto stuffup;
		goto complete;

	case READ_CAPACITY:
	case READ_CAPACITY_16:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd READ CAPACITY 0x%02x\n",
		    DEVNAME(sc), xs->cmd->opcode);
		if (sd->sd_scsi_read_cap(wu))
			goto stuffup;
		goto complete;

	case REQUEST_SENSE:
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd REQUEST SENSE\n",
		    DEVNAME(sc));
		if (sd->sd_scsi_req_sense(wu))
			goto stuffup;
		goto complete;

	default:
		DNPRINTF(SR_D_CMD, "%s: unsupported scsi command %x\n",
		    DEVNAME(sc), xs->cmd->opcode);
		/* XXX might need to add generic function to handle others */
		goto stuffup;
	}

	return;
stuffup:
	if (sd->sd_scsi_sense.error_code) {
		xs->error = XS_SENSE;
		memcpy(&xs->sense, &sd->sd_scsi_sense, sizeof(xs->sense));
		bzero(&sd->sd_scsi_sense, sizeof(sd->sd_scsi_sense));
	} else {
		xs->error = XS_DRIVER_STUFFUP;
	}
complete:
	sr_scsi_done(sd, xs);
}

int
sr_scsi_probe(struct scsi_link *link)
{
	struct sr_softc		*sc = link->adapter_softc;
	struct sr_discipline	*sd;

	KASSERT(link->target < SR_MAX_LD && link->lun == 0);

	sd = sc->sc_targets[link->target];
	if (sd == NULL)
		return (ENODEV);

	link->pool = &sd->sd_iopool;
	if (sd->sd_openings)
		link->openings = sd->sd_openings(sd);
	else
		link->openings = sd->sd_max_wu;

	return (0);
}

int
sr_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
	struct sr_softc		*sc = link->adapter_softc;
	struct sr_discipline	*sd;

	sd = sc->sc_targets[link->target];
	if (sd == NULL)
		return (ENODEV);

	DNPRINTF(SR_D_IOCTL, "%s: %s sr_scsi_ioctl cmd: %#lx\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname, cmd);

	/* Pass bio ioctls through to the bio handler. */
	if (IOCGROUP(cmd) == 'B')
		return (sr_bio_handler(sc, sd, cmd, (struct bio *)addr));

	switch (cmd) {
	case DIOCGCACHE:
	case DIOCSCACHE:
		return (EOPNOTSUPP);
	default:
		return (ENOTTY);
	}
}

int
sr_bio_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct sr_softc *sc = (struct sr_softc *) dev;
	DNPRINTF(SR_D_IOCTL, "%s: sr_bio_ioctl\n", DEVNAME(sc));

	return sr_bio_handler(sc, NULL, cmd, (struct bio *)addr);
}

int
sr_bio_handler(struct sr_softc *sc, struct sr_discipline *sd, u_long cmd,
    struct bio *bio)
{
	int			rv = 0;

	DNPRINTF(SR_D_IOCTL, "%s: sr_bio_handler ", DEVNAME(sc));

	rw_enter_write(&sc->sc_lock);

	bio_status_init(&sc->sc_status, &sc->sc_dev);

	switch (cmd) {
	case BIOCINQ:
		DNPRINTF(SR_D_IOCTL, "inq\n");
		rv = sr_ioctl_inq(sc, (struct bioc_inq *)bio);
		break;

	case BIOCVOL:
		DNPRINTF(SR_D_IOCTL, "vol\n");
		rv = sr_ioctl_vol(sc, (struct bioc_vol *)bio);
		break;

	case BIOCDISK:
		DNPRINTF(SR_D_IOCTL, "disk\n");
		rv = sr_ioctl_disk(sc, (struct bioc_disk *)bio);
		break;

	case BIOCALARM:
		DNPRINTF(SR_D_IOCTL, "alarm\n");
		/*rv = sr_ioctl_alarm(sc, (struct bioc_alarm *)bio); */
		break;

	case BIOCBLINK:
		DNPRINTF(SR_D_IOCTL, "blink\n");
		/*rv = sr_ioctl_blink(sc, (struct bioc_blink *)bio); */
		break;

	case BIOCSETSTATE:
		DNPRINTF(SR_D_IOCTL, "setstate\n");
		rv = sr_ioctl_setstate(sc, (struct bioc_setstate *)bio);
		break;

	case BIOCCREATERAID:
		DNPRINTF(SR_D_IOCTL, "createraid\n");
		rv = sr_ioctl_createraid(sc, (struct bioc_createraid *)bio,
		    1, NULL);
		break;

	case BIOCDELETERAID:
		DNPRINTF(SR_D_IOCTL, "deleteraid\n");
		rv = sr_ioctl_deleteraid(sc, sd, (struct bioc_deleteraid *)bio);
		break;

	case BIOCDISCIPLINE:
		DNPRINTF(SR_D_IOCTL, "discipline\n");
		rv = sr_ioctl_discipline(sc, sd, (struct bioc_discipline *)bio);
		break;

	case BIOCINSTALLBOOT:
		DNPRINTF(SR_D_IOCTL, "installboot\n");
		rv = sr_ioctl_installboot(sc, sd,
		    (struct bioc_installboot *)bio);
		break;

	default:
		DNPRINTF(SR_D_IOCTL, "invalid ioctl\n");
		rv = ENOTTY;
	}

	sc->sc_status.bs_status = (rv ? BIO_STATUS_ERROR : BIO_STATUS_SUCCESS);

	if (sc->sc_status.bs_msg_count > 0)
		rv = 0;

	memcpy(&bio->bio_status, &sc->sc_status, sizeof(struct bio_status));

	rw_exit_write(&sc->sc_lock);

	return (rv);
}

int
sr_ioctl_inq(struct sr_softc *sc, struct bioc_inq *bi)
{
	struct sr_discipline	*sd;
	int			vol = 0, disk = 0;

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		vol++;
		disk += sd->sd_meta->ssdi.ssd_chunk_no;
	}

	strlcpy(bi->bi_dev, sc->sc_dev.dv_xname, sizeof(bi->bi_dev));
	bi->bi_novol = vol + sc->sc_hotspare_no;
	bi->bi_nodisk = disk + sc->sc_hotspare_no;

	return (0);
}

int
sr_ioctl_vol(struct sr_softc *sc, struct bioc_vol *bv)
{
	int			vol = -1, rv = EINVAL;
	struct sr_discipline	*sd;
	struct sr_chunk		*hotspare;

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		vol++;
		if (vol != bv->bv_volid)
			continue;

		bv->bv_status = sd->sd_vol_status;
		bv->bv_size = sd->sd_meta->ssdi.ssd_size << DEV_BSHIFT;
		bv->bv_level = sd->sd_meta->ssdi.ssd_level;
		bv->bv_nodisk = sd->sd_meta->ssdi.ssd_chunk_no;

#ifdef CRYPTO
		if (sd->sd_meta->ssdi.ssd_level == 'C' &&
		    sd->mds.mdd_crypto.key_disk != NULL)
			bv->bv_nodisk++;
#endif
		if (bv->bv_status == BIOC_SVREBUILD)
			bv->bv_percent = sr_rebuild_percent(sd);

		strlcpy(bv->bv_dev, sd->sd_meta->ssd_devname,
		    sizeof(bv->bv_dev));
		strlcpy(bv->bv_vendor, sd->sd_meta->ssdi.ssd_vendor,
		    sizeof(bv->bv_vendor));
		rv = 0;
		goto done;
	}

	/* Check hotspares list. */
	SLIST_FOREACH(hotspare, &sc->sc_hotspare_list, src_link) {
		vol++;
		if (vol != bv->bv_volid)
			continue;

		bv->bv_status = BIOC_SVONLINE;
		bv->bv_size = hotspare->src_meta.scmi.scm_size << DEV_BSHIFT;
		bv->bv_level = -1;	/* Hotspare. */
		bv->bv_nodisk = 1;
		strlcpy(bv->bv_dev, hotspare->src_meta.scmi.scm_devname,
		    sizeof(bv->bv_dev));
		strlcpy(bv->bv_vendor, hotspare->src_meta.scmi.scm_devname,
		    sizeof(bv->bv_vendor));
		rv = 0;
		goto done;
	}

done:
	return (rv);
}

int
sr_ioctl_disk(struct sr_softc *sc, struct bioc_disk *bd)
{
	struct sr_discipline	*sd;
	struct sr_chunk		*src, *hotspare;
	int			vol = -1, rv = EINVAL;

	if (bd->bd_diskid < 0)
		goto done;

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		vol++;
		if (vol != bd->bd_volid)
			continue;

		if (bd->bd_diskid < sd->sd_meta->ssdi.ssd_chunk_no)
			src = sd->sd_vol.sv_chunks[bd->bd_diskid];
#ifdef CRYPTO
		else if (bd->bd_diskid == sd->sd_meta->ssdi.ssd_chunk_no &&
		    sd->sd_meta->ssdi.ssd_level == 'C' &&
		    sd->mds.mdd_crypto.key_disk != NULL)
			src = sd->mds.mdd_crypto.key_disk;
#endif
		else
			break;

		bd->bd_status = src->src_meta.scm_status;
		bd->bd_size = src->src_meta.scmi.scm_size << DEV_BSHIFT;
		bd->bd_channel = vol;
		bd->bd_target = bd->bd_diskid;
		strlcpy(bd->bd_vendor, src->src_meta.scmi.scm_devname,
		    sizeof(bd->bd_vendor));
		rv = 0;
		goto done;
	}

	/* Check hotspares list. */
	SLIST_FOREACH(hotspare, &sc->sc_hotspare_list, src_link) {
		vol++;
		if (vol != bd->bd_volid)
			continue;

		if (bd->bd_diskid != 0)
			break;

		bd->bd_status = hotspare->src_meta.scm_status;
		bd->bd_size = hotspare->src_meta.scmi.scm_size << DEV_BSHIFT;
		bd->bd_channel = vol;
		bd->bd_target = bd->bd_diskid;
		strlcpy(bd->bd_vendor, hotspare->src_meta.scmi.scm_devname,
		    sizeof(bd->bd_vendor));
		rv = 0;
		goto done;
	}

done:
	return (rv);
}

int
sr_ioctl_setstate(struct sr_softc *sc, struct bioc_setstate *bs)
{
	int			rv = EINVAL;
	int			vol = -1, found, c;
	struct sr_discipline	*sd;
	struct sr_chunk		*ch_entry;
	struct sr_chunk_head	*cl;

	if (bs->bs_other_id_type == BIOC_SSOTHER_UNUSED)
		goto done;

	if (bs->bs_status == BIOC_SSHOTSPARE) {
		rv = sr_hotspare(sc, (dev_t)bs->bs_other_id);
		goto done;
	}

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		vol++;
		if (vol == bs->bs_volid)
			break;
	}
	if (sd == NULL)
		goto done;

	switch (bs->bs_status) {
	case BIOC_SSOFFLINE:
		/* Take chunk offline */
		found = c = 0;
		cl = &sd->sd_vol.sv_chunk_list;
		SLIST_FOREACH(ch_entry, cl, src_link) {
			if (ch_entry->src_dev_mm == bs->bs_other_id) {
				found = 1;
				break;
			}
			c++;
		}
		if (found == 0) {
			sr_error(sc, "chunk not part of array");
			goto done;
		}

		/* XXX: check current state first */
		sd->sd_set_chunk_state(sd, c, BIOC_SDOFFLINE);

		if (sr_meta_save(sd, SR_META_DIRTY)) {
			sr_error(sc, "could not save metadata for %s",
			    sd->sd_meta->ssd_devname);
			goto done;
		}
		rv = 0;
		break;

	case BIOC_SDSCRUB:
		break;

	case BIOC_SSREBUILD:
		rv = sr_rebuild_init(sd, (dev_t)bs->bs_other_id, 0);
		break;

	default:
		sr_error(sc, "unsupported state request %d", bs->bs_status);
	}

done:
	return (rv);
}

int
sr_chunk_in_use(struct sr_softc *sc, dev_t dev)
{
	struct sr_discipline	*sd;
	struct sr_chunk		*chunk;
	int			i;

	DNPRINTF(SR_D_MISC, "%s: sr_chunk_in_use(%d)\n", DEVNAME(sc), dev);

	if (dev == NODEV)
		return BIOC_SDINVALID;

	/* See if chunk is already in use. */
	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		for (i = 0; i < sd->sd_meta->ssdi.ssd_chunk_no; i++) {
			chunk = sd->sd_vol.sv_chunks[i];
			if (chunk->src_dev_mm == dev)
				return chunk->src_meta.scm_status;
		}
	}

	/* Check hotspares list. */
	SLIST_FOREACH(chunk, &sc->sc_hotspare_list, src_link)
		if (chunk->src_dev_mm == dev)
			return chunk->src_meta.scm_status;

	return BIOC_SDINVALID;
}

int
sr_hotspare(struct sr_softc *sc, dev_t dev)
{
	struct sr_discipline	*sd = NULL;
	struct sr_metadata	*sm = NULL;
	struct sr_meta_chunk    *hm;
	struct sr_chunk_head	*cl;
	struct sr_chunk		*chunk, *last, *hotspare = NULL;
	struct sr_uuid		uuid;
	struct disklabel	label;
	struct vnode		*vn;
	u_int64_t		size;
	char			devname[32];
	int			rv = EINVAL;
	int			c, part, open = 0;

	/*
	 * Add device to global hotspares list.
	 */

	sr_meta_getdevname(sc, dev, devname, sizeof(devname));

	/* Make sure chunk is not already in use. */
	c = sr_chunk_in_use(sc, dev);
	if (c != BIOC_SDINVALID && c != BIOC_SDOFFLINE) {
		if (c == BIOC_SDHOTSPARE)
			sr_error(sc, "%s is already a hotspare", devname);
		else
			sr_error(sc, "%s is already in use", devname);
		goto done;
	}

	/* XXX - See if there is an existing degraded volume... */

	/* Open device. */
	if (bdevvp(dev, &vn)) {
		sr_error(sc, "sr_hotspare: cannot allocate vnode");
		goto done;
	}
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, curproc)) {
		DNPRINTF(SR_D_META,"%s: sr_hotspare cannot open %s\n",
		    DEVNAME(sc), devname);
		vput(vn);
		goto fail;
	}
	open = 1; /* close dev on error */

	/* Get partition details. */
	part = DISKPART(dev);
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD,
	    NOCRED, curproc)) {
		DNPRINTF(SR_D_META, "%s: sr_hotspare ioctl failed\n",
		    DEVNAME(sc));
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
		goto fail;
	}
	if (label.d_partitions[part].p_fstype != FS_RAID) {
		sr_error(sc, "%s partition not of type RAID (%d)",
		    devname, label.d_partitions[part].p_fstype);
		goto fail;
	}

	/* Calculate partition size. */
	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part]));
	if (size <= SR_DATA_OFFSET) {
		DNPRINTF(SR_D_META, "%s: %s partition too small\n", DEVNAME(sc),
		    devname);
		goto fail;
	}
	size -= SR_DATA_OFFSET;
	if (size > INT64_MAX) {
		DNPRINTF(SR_D_META, "%s: %s partition too large\n", DEVNAME(sc),
		    devname);
		goto fail;
	}

	/*
	 * Create and populate chunk metadata.
	 */

	sr_uuid_generate(&uuid);
	hotspare = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_WAITOK | M_ZERO);

	hotspare->src_dev_mm = dev;
	hotspare->src_vn = vn;
	strlcpy(hotspare->src_devname, devname, sizeof(hm->scmi.scm_devname));
	hotspare->src_size = size;

	hm = &hotspare->src_meta;
	hm->scmi.scm_volid = SR_HOTSPARE_VOLID;
	hm->scmi.scm_chunk_id = 0;
	hm->scmi.scm_size = size;
	hm->scmi.scm_coerced_size = size;
	strlcpy(hm->scmi.scm_devname, devname, sizeof(hm->scmi.scm_devname));
	memcpy(&hm->scmi.scm_uuid, &uuid, sizeof(struct sr_uuid));

	sr_checksum(sc, hm, &hm->scm_checksum,
	    sizeof(struct sr_meta_chunk_invariant));

	hm->scm_status = BIOC_SDHOTSPARE;

	/*
	 * Create and populate our own discipline and metadata.
	 */

	sm = malloc(sizeof(struct sr_metadata), M_DEVBUF, M_WAITOK | M_ZERO);
	sm->ssdi.ssd_magic = SR_MAGIC;
	sm->ssdi.ssd_version = SR_META_VERSION;
	sm->ssd_ondisk = 0;
	sm->ssdi.ssd_vol_flags = 0;
	memcpy(&sm->ssdi.ssd_uuid, &uuid, sizeof(struct sr_uuid));
	sm->ssdi.ssd_chunk_no = 1;
	sm->ssdi.ssd_volid = SR_HOTSPARE_VOLID;
	sm->ssdi.ssd_level = SR_HOTSPARE_LEVEL;
	sm->ssdi.ssd_size = size;
	sm->ssdi.ssd_secsize = label.d_secsize;
	strlcpy(sm->ssdi.ssd_vendor, "OPENBSD", sizeof(sm->ssdi.ssd_vendor));
	snprintf(sm->ssdi.ssd_product, sizeof(sm->ssdi.ssd_product),
	    "SR %s", "HOTSPARE");
	snprintf(sm->ssdi.ssd_revision, sizeof(sm->ssdi.ssd_revision),
	    "%03d", SR_META_VERSION);

	sd = malloc(sizeof(struct sr_discipline), M_DEVBUF, M_WAITOK | M_ZERO);
	sd->sd_sc = sc;
	sd->sd_meta = sm;
	sd->sd_meta_type = SR_META_F_NATIVE;
	sd->sd_vol_status = BIOC_SVONLINE;
	strlcpy(sd->sd_name, "HOTSPARE", sizeof(sd->sd_name));
	SLIST_INIT(&sd->sd_meta_opt);

	/* Add chunk to volume. */
	sd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	sd->sd_vol.sv_chunks[0] = hotspare;
	SLIST_INIT(&sd->sd_vol.sv_chunk_list);
	SLIST_INSERT_HEAD(&sd->sd_vol.sv_chunk_list, hotspare, src_link);

	/* Save metadata. */
	if (sr_meta_save(sd, SR_META_DIRTY)) {
		sr_error(sc, "could not save metadata to %s", devname);
		goto fail;
	}

	/*
	 * Add chunk to hotspare list.
	 */
	rw_enter_write(&sc->sc_hs_lock);
	cl = &sc->sc_hotspare_list;
	if (SLIST_EMPTY(cl))
		SLIST_INSERT_HEAD(cl, hotspare, src_link);
	else {
		SLIST_FOREACH(chunk, cl, src_link)
			last = chunk;
		SLIST_INSERT_AFTER(last, hotspare, src_link);
	}
	sc->sc_hotspare_no++;
	rw_exit_write(&sc->sc_hs_lock);

	rv = 0;
	goto done;

fail:
	free(hotspare, M_DEVBUF, 0);

done:
	if (sd)
		free(sd->sd_vol.sv_chunks, M_DEVBUF, 0);
	free(sd, M_DEVBUF, 0);
	free(sm, M_DEVBUF, 0);
	if (open) {
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
	}

	return (rv);
}

void
sr_hotspare_rebuild_callback(void *xsd)
{
	struct sr_discipline *sd = xsd;
	sr_hotspare_rebuild(sd);
}

void
sr_hotspare_rebuild(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl;
	struct sr_chunk		*hotspare, *chunk = NULL;
	struct sr_workunit	*wu;
	struct sr_ccb		*ccb;
	int			i, s, cid, busy;

	/*
	 * Attempt to locate a hotspare and initiate rebuild.
	 */

	/* Find first offline chunk. */
	for (cid = 0; cid < sd->sd_meta->ssdi.ssd_chunk_no; cid++) {
		if (sd->sd_vol.sv_chunks[cid]->src_meta.scm_status ==
		    BIOC_SDOFFLINE) {
			chunk = sd->sd_vol.sv_chunks[cid];
			break;
		}
	}
	if (chunk == NULL) {
		printf("%s: no offline chunk found on %s!\n",
		    DEVNAME(sc), sd->sd_meta->ssd_devname);
		return;
	}

	/* See if we have a suitable hotspare... */
	rw_enter_write(&sc->sc_hs_lock);
	cl = &sc->sc_hotspare_list;
	SLIST_FOREACH(hotspare, cl, src_link)
		if (hotspare->src_size >= chunk->src_size &&
		    hotspare->src_secsize <= sd->sd_meta->ssdi.ssd_secsize)
			break;

	if (hotspare != NULL) {

		printf("%s: %s volume degraded, will attempt to "
		    "rebuild on hotspare %s\n", DEVNAME(sc),
		    sd->sd_meta->ssd_devname, hotspare->src_devname);

		/*
		 * Ensure that all pending I/O completes on the failed chunk
		 * before trying to initiate a rebuild.
		 */
		i = 0;
		do {
			busy = 0;

			s = splbio();
			TAILQ_FOREACH(wu, &sd->sd_wu_pendq, swu_link) {
				TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
					if (ccb->ccb_target == cid)
						busy = 1;
				}
			}
			TAILQ_FOREACH(wu, &sd->sd_wu_defq, swu_link) {
				TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
					if (ccb->ccb_target == cid)
						busy = 1;
				}
			}
			splx(s);

			if (busy) {
				tsleep(sd, PRIBIO, "sr_hotspare", hz);
				i++;
			}

		} while (busy && i < 120);

		DNPRINTF(SR_D_META, "%s: waited %i seconds for I/O to "
		    "complete on failed chunk %s\n", DEVNAME(sc),
		    i, chunk->src_devname);

		if (busy) {
			printf("%s: pending I/O failed to complete on "
			    "failed chunk %s, hotspare rebuild aborted...\n",
			    DEVNAME(sc), chunk->src_devname);
			goto done;
		}

		s = splbio();
		rw_enter_write(&sc->sc_lock);
		bio_status_init(&sc->sc_status, &sc->sc_dev);
		if (sr_rebuild_init(sd, hotspare->src_dev_mm, 1) == 0) {

			/* Remove hotspare from available list. */
			sc->sc_hotspare_no--;
			SLIST_REMOVE(cl, hotspare, sr_chunk, src_link);
			free(hotspare, M_DEVBUF, 0);

		}
		rw_exit_write(&sc->sc_lock);
		splx(s);
	}
done:
	rw_exit_write(&sc->sc_hs_lock);
}

int
sr_rebuild_init(struct sr_discipline *sd, dev_t dev, int hotspare)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk		*chunk = NULL;
	struct sr_meta_chunk	*meta;
	struct disklabel	label;
	struct vnode		*vn;
	u_int64_t		size;
	int64_t			csize;
	char			devname[32];
	int			rv = EINVAL, open = 0;
	int			cid, i, part, status;

	/*
	 * Attempt to initiate a rebuild onto the specified device.
	 */

	if (!(sd->sd_capabilities & SR_CAP_REBUILD)) {
		sr_error(sc, "discipline does not support rebuild");
		goto done;
	}

	/* make sure volume is in the right state */
	if (sd->sd_vol_status == BIOC_SVREBUILD) {
		sr_error(sc, "rebuild already in progress");
		goto done;
	}
	if (sd->sd_vol_status != BIOC_SVDEGRADED) {
		sr_error(sc, "volume not degraded");
		goto done;
	}

	/* Find first offline chunk. */
	for (cid = 0; cid < sd->sd_meta->ssdi.ssd_chunk_no; cid++) {
		if (sd->sd_vol.sv_chunks[cid]->src_meta.scm_status ==
		    BIOC_SDOFFLINE) {
			chunk = sd->sd_vol.sv_chunks[cid];
			break;
		}
	}
	if (chunk == NULL) {
		sr_error(sc, "no offline chunks available to rebuild");
		goto done;
	}

	/* Get coerced size from another online chunk. */
	csize = 0;
	for (i = 0; i < sd->sd_meta->ssdi.ssd_chunk_no; i++) {
		if (sd->sd_vol.sv_chunks[i]->src_meta.scm_status ==
		    BIOC_SDONLINE) {
			meta = &sd->sd_vol.sv_chunks[i]->src_meta;
			csize = meta->scmi.scm_coerced_size;
			break;
		}
	}
	if (csize == 0) {
		sr_error(sc, "no online chunks available for rebuild");
		goto done;
	}

	sr_meta_getdevname(sc, dev, devname, sizeof(devname));
	if (bdevvp(dev, &vn)) {
		printf("%s: sr_rebuild_init: can't allocate vnode\n",
		    DEVNAME(sc));
		goto done;
	}
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, curproc)) {
		DNPRINTF(SR_D_META,"%s: sr_ioctl_setstate can't "
		    "open %s\n", DEVNAME(sc), devname);
		vput(vn);
		goto done;
	}
	open = 1; /* close dev on error */

	/* Get disklabel and check partition. */
	part = DISKPART(dev);
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD,
	    NOCRED, curproc)) {
		DNPRINTF(SR_D_META, "%s: sr_ioctl_setstate ioctl failed\n",
		    DEVNAME(sc));
		goto done;
	}
	if (label.d_partitions[part].p_fstype != FS_RAID) {
		sr_error(sc, "%s partition not of type RAID (%d)",
		    devname, label.d_partitions[part].p_fstype);
		goto done;
	}

	/* Is the partition large enough? */
	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part]));
	if (size <= sd->sd_meta->ssd_data_blkno) {
		sr_error(sc, "%s: %s partition too small", DEVNAME(sc),
		    devname);
		goto done;
	}
	size -= sd->sd_meta->ssd_data_blkno;
	if (size > INT64_MAX) {
		sr_error(sc, "%s: %s partition too large", DEVNAME(sc),
		    devname);
		goto done;
	}
	if (size < csize) {
		sr_error(sc, "%s partition too small, at least %lld bytes "
		    "required", devname, (long long)(csize << DEV_BSHIFT));
		goto done;
	} else if (size > csize)
		sr_warn(sc, "%s partition too large, wasting %lld bytes",
		    devname, (long long)((size - csize) << DEV_BSHIFT));
	if (label.d_secsize > sd->sd_meta->ssdi.ssd_secsize) {
		sr_error(sc, "%s sector size too large, <= %u bytes "
		    "required", devname, sd->sd_meta->ssdi.ssd_secsize);
		goto done;
	}

	/* Ensure that this chunk is not already in use. */
	status = sr_chunk_in_use(sc, dev);
	if (status != BIOC_SDINVALID && status != BIOC_SDOFFLINE &&
	    !(hotspare && status == BIOC_SDHOTSPARE)) {
		sr_error(sc, "%s is already in use", devname);
		goto done;
	}

	/* Reset rebuild counter since we rebuilding onto a new chunk. */
	sd->sd_meta->ssd_rebuild = 0;

	open = 0; /* leave dev open from here on out */

	/* Fix up chunk. */
	memcpy(chunk->src_duid, label.d_uid, sizeof(chunk->src_duid));
	chunk->src_dev_mm = dev;
	chunk->src_vn = vn;

	/* Reconstruct metadata. */
	meta = &chunk->src_meta;
	meta->scmi.scm_volid = sd->sd_meta->ssdi.ssd_volid;
	meta->scmi.scm_chunk_id = cid;
	strlcpy(meta->scmi.scm_devname, devname,
	    sizeof(meta->scmi.scm_devname));
	meta->scmi.scm_size = size;
	meta->scmi.scm_coerced_size = csize;
	memcpy(&meta->scmi.scm_uuid, &sd->sd_meta->ssdi.ssd_uuid,
	    sizeof(meta->scmi.scm_uuid));
	sr_checksum(sc, meta, &meta->scm_checksum,
	    sizeof(struct sr_meta_chunk_invariant));

	sd->sd_set_chunk_state(sd, cid, BIOC_SDREBUILD);

	if (sr_meta_save(sd, SR_META_DIRTY)) {
		sr_error(sc, "could not save metadata to %s", devname);
		open = 1;
		goto done;
	}

	sr_warn(sc, "rebuild of %s started on %s",
	    sd->sd_meta->ssd_devname, devname);

	sd->sd_reb_abort = 0;
	kthread_create_deferred(sr_rebuild_start, sd);

	rv = 0;
done:
	if (open) {
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
	}

	return (rv);
}

int
sr_rebuild_percent(struct sr_discipline *sd)
{
	daddr_t			rb, sz;

	sz = sd->sd_meta->ssdi.ssd_size;
	rb = sd->sd_meta->ssd_rebuild;

	if (rb > 0)
		return (100 - ((sz * 100 - rb * 100) / sz) - 1);

	return (0);
}

void
sr_roam_chunks(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk		*chunk;
	struct sr_meta_chunk	*meta;
	int			roamed = 0;

	/* Have any chunks roamed? */
	SLIST_FOREACH(chunk, &sd->sd_vol.sv_chunk_list, src_link) {
		meta = &chunk->src_meta;
		if (strncmp(meta->scmi.scm_devname, chunk->src_devname,
		    sizeof(meta->scmi.scm_devname))) {

			printf("%s: roaming device %s -> %s\n", DEVNAME(sc),
			    meta->scmi.scm_devname, chunk->src_devname);

			strlcpy(meta->scmi.scm_devname, chunk->src_devname,
			    sizeof(meta->scmi.scm_devname));

			roamed++;
		}
	}

	if (roamed)
		sr_meta_save(sd, SR_META_DIRTY);
}

int
sr_ioctl_createraid(struct sr_softc *sc, struct bioc_createraid *bc,
    int user, void *data)
{
	struct sr_meta_opt_item *omi;
	struct sr_chunk_head	*cl;
	struct sr_discipline	*sd = NULL;
	struct sr_chunk		*ch_entry;
	struct scsi_link	*link;
	struct device		*dev;
	char			*uuid, devname[32];
	dev_t			*dt = NULL;
	int			i, no_chunk, rv = EINVAL, target, vol;
	int			no_meta;

	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_createraid(%d)\n",
	    DEVNAME(sc), user);

	/* user input */
	if (bc->bc_dev_list_len > BIOC_CRMAXLEN)
		goto unwind;

	dt = malloc(bc->bc_dev_list_len, M_DEVBUF, M_WAITOK | M_ZERO);
	if (user) {
		if (copyin(bc->bc_dev_list, dt, bc->bc_dev_list_len) != 0)
			goto unwind;
	} else
		memcpy(dt, bc->bc_dev_list, bc->bc_dev_list_len);

	/* Initialise discipline. */
	sd = malloc(sizeof(struct sr_discipline), M_DEVBUF, M_WAITOK | M_ZERO);
	sd->sd_sc = sc;
	SLIST_INIT(&sd->sd_meta_opt);
	sd->sd_taskq = taskq_create("srdis", 1, IPL_BIO, 0);
	if (sd->sd_taskq == NULL) {
		sr_error(sc, "could not create discipline taskq");
		goto unwind;
	}
	if (sr_discipline_init(sd, bc->bc_level)) {
		sr_error(sc, "could not initialize discipline");
		goto unwind;
	}

	no_chunk = bc->bc_dev_list_len / sizeof(dev_t);
	cl = &sd->sd_vol.sv_chunk_list;
	SLIST_INIT(cl);

	/* Ensure that chunks are not already in use. */
	for (i = 0; i < no_chunk; i++) {
		if (sr_chunk_in_use(sc, dt[i]) != BIOC_SDINVALID) {
			sr_meta_getdevname(sc, dt[i], devname, sizeof(devname));
			sr_error(sc, "chunk %s already in use", devname);
			goto unwind;
		}
	}

	sd->sd_meta_type = sr_meta_probe(sd, dt, no_chunk);
	if (sd->sd_meta_type == SR_META_F_INVALID) {
		sr_error(sc, "invalid metadata format");
		goto unwind;
	}

	if (sr_meta_attach(sd, no_chunk, bc->bc_flags & BIOC_SCFORCE))
		goto unwind;

	/* force the raid volume by clearing metadata region */
	if (bc->bc_flags & BIOC_SCFORCE) {
		/* make sure disk isn't up and running */
		if (sr_meta_read(sd))
			if (sr_already_assembled(sd)) {
				uuid = sr_uuid_format(
				    &sd->sd_meta->ssdi.ssd_uuid);
				sr_error(sc, "disk %s is currently in use; "
				    "cannot force create", uuid);
				free(uuid, M_DEVBUF, 0);
				goto unwind;
			}

		if (sr_meta_clear(sd)) {
			sr_error(sc, "failed to clear metadata");
			goto unwind;
		}
	}

	no_meta = sr_meta_read(sd);
	if (no_meta == -1) {

		/* Corrupt metadata on one or more chunks. */
		sr_error(sc, "one of the chunks has corrupt metadata; "
		    "aborting assembly");
		goto unwind;

	} else if (no_meta == 0) {

		/* Initialise volume and chunk metadata. */
		sr_meta_init(sd, bc->bc_level, no_chunk);
		sd->sd_vol_status = BIOC_SVONLINE;
		sd->sd_meta_flags = bc->bc_flags & BIOC_SCNOAUTOASSEMBLE;
		if (sd->sd_create) {
			if ((i = sd->sd_create(sd, bc, no_chunk,
			    sd->sd_vol.sv_chunk_minsz))) {
				rv = i;
				goto unwind;
			}
		}
		sr_meta_init_complete(sd);

		DNPRINTF(SR_D_IOCTL,
		    "%s: sr_ioctl_createraid: vol_size: %lld\n",
		    DEVNAME(sc), sd->sd_meta->ssdi.ssd_size);

		/* Warn if we've wasted chunk space due to coercing. */
		if ((sd->sd_capabilities & SR_CAP_NON_COERCED) == 0 &&
		    sd->sd_vol.sv_chunk_minsz != sd->sd_vol.sv_chunk_maxsz)
			sr_warn(sc, "chunk sizes are not equal; up to %llu "
			    "blocks wasted per chunk",
			    sd->sd_vol.sv_chunk_maxsz -
			    sd->sd_vol.sv_chunk_minsz);

	} else {

		/* Ensure metadata level matches requested assembly level. */
		if (sd->sd_meta->ssdi.ssd_level != bc->bc_level) {
			sr_error(sc, "volume level does not match metadata "
			    "level");
			goto unwind;
		}

		if (sr_already_assembled(sd)) {
			uuid = sr_uuid_format(&sd->sd_meta->ssdi.ssd_uuid);
			sr_error(sc, "disk %s already assembled", uuid);
			free(uuid, M_DEVBUF, 0);
			goto unwind;
		}

		if (user == 0 && sd->sd_meta_flags & BIOC_SCNOAUTOASSEMBLE) {
			DNPRINTF(SR_D_META, "%s: disk not auto assembled from "
			    "metadata\n", DEVNAME(sc));
			goto unwind;
		}

		if (no_meta != no_chunk)
			sr_warn(sc, "trying to bring up %s degraded",
			    sd->sd_meta->ssd_devname);

		if (sd->sd_meta->ssd_meta_flags & SR_META_DIRTY)
			sr_warn(sc, "%s was not shutdown properly",
			    sd->sd_meta->ssd_devname);

		SLIST_FOREACH(omi, &sd->sd_meta_opt, omi_link)
			if (sd->sd_meta_opt_handler == NULL ||
			    sd->sd_meta_opt_handler(sd, omi->omi_som) != 0)
				sr_meta_opt_handler(sd, omi->omi_som);

		if (sd->sd_assemble) {
			if ((i = sd->sd_assemble(sd, bc, no_chunk, data))) {
				rv = i;
				goto unwind;
			}
		}

		DNPRINTF(SR_D_META, "%s: disk assembled from metadata\n",
		    DEVNAME(sc));

	}

	/* Metadata MUST be fully populated by this point. */
	TAILQ_INSERT_TAIL(&sc->sc_dis_list, sd, sd_link);

	/* Allocate all resources. */
	if ((rv = sd->sd_alloc_resources(sd)))
		goto unwind;

	/* Adjust flags if necessary. */
	if ((sd->sd_capabilities & SR_CAP_AUTO_ASSEMBLE) &&
	    (bc->bc_flags & BIOC_SCNOAUTOASSEMBLE) !=
	    (sd->sd_meta->ssdi.ssd_vol_flags & BIOC_SCNOAUTOASSEMBLE)) {
		sd->sd_meta->ssdi.ssd_vol_flags &= ~BIOC_SCNOAUTOASSEMBLE;
		sd->sd_meta->ssdi.ssd_vol_flags |=
		    bc->bc_flags & BIOC_SCNOAUTOASSEMBLE;
	}

	if (sd->sd_capabilities & SR_CAP_SYSTEM_DISK) {
		/* Initialise volume state. */
		sd->sd_set_vol_state(sd);
		if (sd->sd_vol_status == BIOC_SVOFFLINE) {
			sr_error(sc, "%s is offline, will not be brought "
			    "online", sd->sd_meta->ssd_devname);
			goto unwind;
		}

		/* Setup SCSI iopool. */
		scsi_iopool_init(&sd->sd_iopool, sd, sr_wu_get, sr_wu_put);

		/*
		 * All checks passed - return ENXIO if volume cannot be created.
		 */
		rv = ENXIO;

		/*
		 * Find a free target.
		 *
		 * XXX: We reserve sd_target == 0 to indicate the
		 * discipline is not linked into sc->sc_targets, so begin
		 * the search with target = 1.
		 */
		for (target = 1; target < SR_MAX_LD; target++)
			if (sc->sc_targets[target] == NULL)
				break;
		if (target == SR_MAX_LD) {
			sr_error(sc, "no free target for %s",
			    sd->sd_meta->ssd_devname);
			goto unwind;
		}

		/* Clear sense data. */
		bzero(&sd->sd_scsi_sense, sizeof(sd->sd_scsi_sense));

		/* Attach discipline and get midlayer to probe it. */
		sd->sd_target = target;
		sc->sc_targets[target] = sd;
		if (scsi_probe_lun(sc->sc_scsibus, target, 0) != 0) {
			sr_error(sc, "scsi_probe_lun failed");
			sc->sc_targets[target] = NULL;
			sd->sd_target = 0;
			goto unwind;
		}

		link = scsi_get_link(sc->sc_scsibus, target, 0);
		if (link == NULL)
			goto unwind;

		dev = link->device_softc;
		DNPRINTF(SR_D_IOCTL, "%s: sr device added: %s at target %d\n",
		    DEVNAME(sc), dev->dv_xname, sd->sd_target);

		/* XXX - Count volumes, not targets. */
		for (i = 0, vol = -1; i <= sd->sd_target; i++)
			if (sc->sc_targets[i])
				vol++;

		rv = 0;

		if (sd->sd_meta->ssd_devname[0] != '\0' &&
		    strncmp(sd->sd_meta->ssd_devname, dev->dv_xname,
		    sizeof(dev->dv_xname)))
			sr_warn(sc, "volume %s is roaming, it used to be %s, "
			    "updating metadata", dev->dv_xname,
			    sd->sd_meta->ssd_devname);

		/* Populate remaining volume metadata. */
		sd->sd_meta->ssdi.ssd_volid = vol;
		strlcpy(sd->sd_meta->ssd_devname, dev->dv_xname,
		    sizeof(sd->sd_meta->ssd_devname));

		sr_info(sc, "%s volume attached as %s",
		    sd->sd_name, sd->sd_meta->ssd_devname);

		/* Update device name on any roaming chunks. */
		sr_roam_chunks(sd);

#ifndef SMALL_KERNEL
		if (sr_sensors_create(sd))
			sr_warn(sc, "unable to create sensor for %s",
			    dev->dv_xname);
#endif /* SMALL_KERNEL */
	} else {
		/* This volume does not attach as a system disk. */
		ch_entry = SLIST_FIRST(cl); /* XXX */
		strlcpy(sd->sd_meta->ssd_devname, ch_entry->src_devname,
		    sizeof(sd->sd_meta->ssd_devname));

		if (sd->sd_start_discipline(sd))
			goto unwind;
	}

	/* Save current metadata to disk. */
	rv = sr_meta_save(sd, SR_META_DIRTY);

	if (sd->sd_vol_status == BIOC_SVREBUILD)
		kthread_create_deferred(sr_rebuild_start, sd);

	sd->sd_ready = 1;

	free(dt, M_DEVBUF, bc->bc_dev_list_len);

	return (rv);

unwind:
	free(dt, M_DEVBUF, bc->bc_dev_list_len);

	sr_discipline_shutdown(sd, 0);

	if (rv == EAGAIN)
		rv = 0;

	return (rv);
}

int
sr_ioctl_deleteraid(struct sr_softc *sc, struct sr_discipline *sd,
    struct bioc_deleteraid *bd)
{
	int			rv = 1;

	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_deleteraid %s\n",
	    DEVNAME(sc), bd->bd_dev);

	if (sd == NULL) {
		TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
			if (!strncmp(sd->sd_meta->ssd_devname, bd->bd_dev,
			    sizeof(sd->sd_meta->ssd_devname)))
				break;
		}
		if (sd == NULL) {
			sr_error(sc, "volume %s not found", bd->bd_dev);
			goto bad;
		}
	}

	sd->sd_deleted = 1;
	sd->sd_meta->ssdi.ssd_vol_flags = BIOC_SCNOAUTOASSEMBLE;
	sr_discipline_shutdown(sd, 1);

	rv = 0;
bad:
	return (rv);
}

int
sr_ioctl_discipline(struct sr_softc *sc, struct sr_discipline *sd,
    struct bioc_discipline *bd)
{
	int			rv = 1;

	/* Dispatch a discipline specific ioctl. */

	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_discipline %s\n", DEVNAME(sc),
	    bd->bd_dev);

	if (sd == NULL) {
		TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
			if (!strncmp(sd->sd_meta->ssd_devname, bd->bd_dev,
			    sizeof(sd->sd_meta->ssd_devname)))
				break;
		}
		if (sd == NULL) {
			sr_error(sc, "volume %s not found", bd->bd_dev);
			goto bad;
		}
	}

	if (sd->sd_ioctl_handler)
		rv = sd->sd_ioctl_handler(sd, bd);

bad:
	return (rv);
}

int
sr_ioctl_installboot(struct sr_softc *sc, struct sr_discipline *sd,
    struct bioc_installboot *bb)
{
	void			*bootblk = NULL, *bootldr = NULL;
	struct sr_chunk		*chunk;
	struct sr_meta_opt_item *omi;
	struct sr_meta_boot	*sbm;
	struct disk		*dk;
	u_int32_t		bbs, bls, secsize;
	u_char			duid[8];
	int			rv = EINVAL;
	int			i;

	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_installboot %s\n", DEVNAME(sc),
	    bb->bb_dev);

	if (sd == NULL) {
		TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
			if (!strncmp(sd->sd_meta->ssd_devname, bb->bb_dev,
			    sizeof(sd->sd_meta->ssd_devname)))
				break;
		}
		if (sd == NULL) {
			sr_error(sc, "volume %s not found", bb->bb_dev);
			goto done;
		}
	}

	bzero(duid, sizeof(duid));
	TAILQ_FOREACH(dk, &disklist,  dk_link)
		if (!strncmp(dk->dk_name, bb->bb_dev, sizeof(bb->bb_dev)))
			break;
	if (dk == NULL || dk->dk_label == NULL ||
	    (dk->dk_flags & DKF_LABELVALID) == 0 ||
	    bcmp(dk->dk_label->d_uid, &duid, sizeof(duid)) == 0) {
		sr_error(sc, "failed to get DUID for softraid volume");
		goto done;
	}
	memcpy(duid, dk->dk_label->d_uid, sizeof(duid));

	/* Ensure that boot storage area is large enough. */
	if (sd->sd_meta->ssd_data_blkno < (SR_BOOT_OFFSET + SR_BOOT_SIZE)) {
		sr_error(sc, "insufficient boot storage");
		goto done;
	}

	if (bb->bb_bootblk_size > SR_BOOT_BLOCKS_SIZE * DEV_BSIZE)
		goto done;

	if (bb->bb_bootldr_size > SR_BOOT_LOADER_SIZE * DEV_BSIZE)
		goto done;

	secsize = sd->sd_meta->ssdi.ssd_secsize;

	/* Copy in boot block. */
	bbs = howmany(bb->bb_bootblk_size, secsize) * secsize;
	bootblk = malloc(bbs, M_DEVBUF, M_WAITOK | M_ZERO);
	if (copyin(bb->bb_bootblk, bootblk, bb->bb_bootblk_size) != 0)
		goto done;

	/* Copy in boot loader. */
	bls = howmany(bb->bb_bootldr_size, secsize) * secsize;
	bootldr = malloc(bls, M_DEVBUF, M_WAITOK | M_ZERO);
	if (copyin(bb->bb_bootldr, bootldr, bb->bb_bootldr_size) != 0)
		goto done;

	/* Create or update optional meta for bootable volumes. */
	SLIST_FOREACH(omi, &sd->sd_meta_opt, omi_link)
		if (omi->omi_som->som_type == SR_OPT_BOOT)
			break;
	if (omi == NULL) {
		omi = malloc(sizeof(struct sr_meta_opt_item), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		omi->omi_som = malloc(sizeof(struct sr_meta_crypto), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		omi->omi_som->som_type = SR_OPT_BOOT;
		omi->omi_som->som_length = sizeof(struct sr_meta_boot);
		SLIST_INSERT_HEAD(&sd->sd_meta_opt, omi, omi_link);
		sd->sd_meta->ssdi.ssd_opt_no++;
	}
	sbm = (struct sr_meta_boot *)omi->omi_som;

	memcpy(sbm->sbm_root_duid, duid, sizeof(sbm->sbm_root_duid));
	bzero(&sbm->sbm_boot_duid, sizeof(sbm->sbm_boot_duid));
	sbm->sbm_bootblk_size = bbs;
	sbm->sbm_bootldr_size = bls;

	DNPRINTF(SR_D_IOCTL, "sr_ioctl_installboot: root duid is "
	    "%02x%02x%02x%02x%02x%02x%02x%02x\n", sbm->sbm_root_duid[0],
	    sbm->sbm_root_duid[1], sbm->sbm_root_duid[2], sbm->sbm_root_duid[3],
	    sbm->sbm_root_duid[4], sbm->sbm_root_duid[5], sbm->sbm_root_duid[6],
	    sbm->sbm_root_duid[7]);

	/* Save boot block and boot loader to each chunk. */
	for (i = 0; i < sd->sd_meta->ssdi.ssd_chunk_no; i++) {

		chunk = sd->sd_vol.sv_chunks[i];
		if (chunk->src_meta.scm_status != BIOC_SDONLINE &&
		    chunk->src_meta.scm_status != BIOC_SDREBUILD)
			continue;

		if (i < SR_MAX_BOOT_DISKS)
			memcpy(&sbm->sbm_boot_duid[i], chunk->src_duid,
			    sizeof(sbm->sbm_boot_duid[i]));

		/* Save boot blocks. */
		DNPRINTF(SR_D_IOCTL,
		    "sr_ioctl_installboot: saving boot block to %s "
		    "(%u bytes)\n", chunk->src_devname, bbs);

		if (sr_rw(sc, chunk->src_dev_mm, bootblk, bbs,
		    SR_BOOT_BLOCKS_OFFSET, B_WRITE)) {
			sr_error(sc, "failed to write boot block", DEVNAME(sc));
			goto done;
		}

		/* Save boot loader.*/
		DNPRINTF(SR_D_IOCTL,
		    "sr_ioctl_installboot: saving boot loader to %s "
		    "(%u bytes)\n", chunk->src_devname, bls);

		if (sr_rw(sc, chunk->src_dev_mm, bootldr, bls,
		    SR_BOOT_LOADER_OFFSET, B_WRITE)) {
			sr_error(sc, "failed to write boot loader");
			goto done;
		}
	}

	/* XXX - Install boot block on disk - MD code. */

	/* Mark volume as bootable and save metadata. */
	sd->sd_meta->ssdi.ssd_vol_flags |= BIOC_SCBOOTABLE;
	if (sr_meta_save(sd, SR_META_DIRTY)) {
		sr_error(sc, "could not save metadata to %s", DEVNAME(sc));
		goto done;
	}

	rv = 0;

done:
	free(bootblk, M_DEVBUF, 0);
	free(bootldr, M_DEVBUF, 0);

	return (rv);
}

void
sr_chunks_unwind(struct sr_softc *sc, struct sr_chunk_head *cl)
{
	struct sr_chunk		*ch_entry, *ch_next;

	DNPRINTF(SR_D_IOCTL, "%s: sr_chunks_unwind\n", DEVNAME(sc));

	if (!cl)
		return;

	for (ch_entry = SLIST_FIRST(cl); ch_entry != NULL; ch_entry = ch_next) {
		ch_next = SLIST_NEXT(ch_entry, src_link);

		DNPRINTF(SR_D_IOCTL, "%s: sr_chunks_unwind closing: %s\n",
		    DEVNAME(sc), ch_entry->src_devname);
		if (ch_entry->src_vn) {
			/*
			 * XXX - explicitly lock the vnode until we can resolve
			 * the problem introduced by vnode aliasing... specfs
			 * has no locking, whereas ufs/ffs does!
			 */
			vn_lock(ch_entry->src_vn, LK_EXCLUSIVE |
			    LK_RETRY, curproc);
			VOP_CLOSE(ch_entry->src_vn, FREAD | FWRITE, NOCRED,
			    curproc);
			vput(ch_entry->src_vn);
		}
		free(ch_entry, M_DEVBUF, 0);
	}
	SLIST_INIT(cl);
}

void
sr_discipline_free(struct sr_discipline *sd)
{
	struct sr_softc		*sc;
	struct sr_discipline	*sdtmp1;
	struct sr_meta_opt_head *som;
	struct sr_meta_opt_item	*omi, *omi_next;

	if (!sd)
		return;

	sc = sd->sd_sc;

	DNPRINTF(SR_D_DIS, "%s: sr_discipline_free %s\n",
	    DEVNAME(sc),
	    sd->sd_meta ? sd->sd_meta->ssd_devname : "nodev");
	if (sd->sd_free_resources)
		sd->sd_free_resources(sd);
	free(sd->sd_vol.sv_chunks, M_DEVBUF, 0);
	free(sd->sd_meta, M_DEVBUF, 0);
	free(sd->sd_meta_foreign, M_DEVBUF, 0);

	som = &sd->sd_meta_opt;
	for (omi = SLIST_FIRST(som); omi != NULL; omi = omi_next) {
		omi_next = SLIST_NEXT(omi, omi_link);
		free(omi->omi_som, M_DEVBUF, 0);
		free(omi, M_DEVBUF, 0);
	}

	if (sd->sd_target != 0) {
		KASSERT(sc->sc_targets[sd->sd_target] == sd);
		sc->sc_targets[sd->sd_target] = NULL;
	}

	TAILQ_FOREACH(sdtmp1, &sc->sc_dis_list, sd_link) {
		if (sdtmp1 == sd)
			break;
	}
	if (sdtmp1 != NULL)
		TAILQ_REMOVE(&sc->sc_dis_list, sd, sd_link);

	explicit_bzero(sd, sizeof *sd);
	free(sd, M_DEVBUF, 0);
}

void
sr_discipline_shutdown(struct sr_discipline *sd, int meta_save)
{
	struct sr_softc		*sc;
	int			s;

	if (!sd)
		return;
	sc = sd->sd_sc;

	DNPRINTF(SR_D_DIS, "%s: sr_discipline_shutdown %s\n", DEVNAME(sc),
	    sd->sd_meta ? sd->sd_meta->ssd_devname : "nodev");

	/* If rebuilding, abort rebuild and drain I/O. */
	if (sd->sd_reb_active) {
		sd->sd_reb_abort = 1;
		while (sd->sd_reb_active)
			tsleep(sd, PWAIT, "sr_shutdown", 1);
	}

	if (meta_save)
		sr_meta_save(sd, 0);

	s = splbio();

	sd->sd_ready = 0;

	/* make sure there isn't a sync pending and yield */
	wakeup(sd);
	while (sd->sd_sync || sd->sd_must_flush)
		if (tsleep(&sd->sd_sync, MAXPRI, "sr_down", 60 * hz) ==
		    EWOULDBLOCK)
			break;

#ifndef SMALL_KERNEL
	sr_sensors_delete(sd);
#endif /* SMALL_KERNEL */

	if (sd->sd_target != 0)
		scsi_detach_lun(sc->sc_scsibus, sd->sd_target, 0, DETACH_FORCE);

	sr_chunks_unwind(sc, &sd->sd_vol.sv_chunk_list);

	if (sd->sd_taskq)
		taskq_destroy(sd->sd_taskq);

	sr_discipline_free(sd);

	splx(s);
}

int
sr_discipline_init(struct sr_discipline *sd, int level)
{
	int			rv = 1;

	/* Initialise discipline function pointers with defaults. */
	sd->sd_alloc_resources = sr_alloc_resources;
	sd->sd_assemble = NULL;
	sd->sd_create = NULL;
	sd->sd_free_resources = sr_free_resources;
	sd->sd_ioctl_handler = NULL;
	sd->sd_openings = NULL;
	sd->sd_meta_opt_handler = NULL;
	sd->sd_rebuild = sr_rebuild;
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
	sd->sd_scsi_rw = NULL;
	sd->sd_scsi_intr = sr_raid_intr;
	sd->sd_scsi_wu_done = NULL;
	sd->sd_scsi_done = NULL;
	sd->sd_set_chunk_state = sr_set_chunk_state;
	sd->sd_set_vol_state = sr_set_vol_state;
	sd->sd_start_discipline = NULL;

	task_set(&sd->sd_meta_save_task, sr_meta_save_callback, sd);
	task_set(&sd->sd_hotspare_rebuild_task, sr_hotspare_rebuild_callback,
	    sd);

	switch (level) {
	case 0:
		sr_raid0_discipline_init(sd);
		break;
	case 1:
		sr_raid1_discipline_init(sd);
		break;
	case 5:
		sr_raid5_discipline_init(sd);
		break;
	case 6:
		sr_raid6_discipline_init(sd);
		break;
#ifdef CRYPTO
	case 'C':
		sr_crypto_discipline_init(sd);
		break;
#endif
	case 'c':
		sr_concat_discipline_init(sd);
		break;
	default:
		goto bad;
	}

	rv = 0;
bad:
	return (rv);
}

int
sr_raid_inquiry(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct scsi_inquiry	*cdb = (struct scsi_inquiry *)xs->cmd;
	struct scsi_inquiry_data inq;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_inquiry\n", DEVNAME(sd->sd_sc));

	if (xs->cmdlen != sizeof(*cdb))
		return (EINVAL);

	if (ISSET(cdb->flags, SI_EVPD))
		return (EOPNOTSUPP);

	bzero(&inq, sizeof(inq));
	inq.device = T_DIRECT;
	inq.dev_qual2 = 0;
	inq.version = 2;
	inq.response_format = 2;
	inq.additional_length = 32;
	inq.flags |= SID_CmdQue;
	strlcpy(inq.vendor, sd->sd_meta->ssdi.ssd_vendor,
	    sizeof(inq.vendor));
	strlcpy(inq.product, sd->sd_meta->ssdi.ssd_product,
	    sizeof(inq.product));
	strlcpy(inq.revision, sd->sd_meta->ssdi.ssd_revision,
	    sizeof(inq.revision));
	sr_copy_internal_data(xs, &inq, sizeof(inq));

	return (0);
}

int
sr_raid_read_cap(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct scsi_read_cap_data rcd;
	struct scsi_read_cap_data_16 rcd16;
	u_int64_t		addr;
	int			rv = 1;
	u_int32_t		secsize;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_read_cap\n", DEVNAME(sd->sd_sc));

	secsize = sd->sd_meta->ssdi.ssd_secsize;

	addr = ((sd->sd_meta->ssdi.ssd_size * DEV_BSIZE) / secsize) - 1;
	if (xs->cmd->opcode == READ_CAPACITY) {
		bzero(&rcd, sizeof(rcd));
		if (addr > 0xffffffffllu)
			_lto4b(0xffffffff, rcd.addr);
		else
			_lto4b(addr, rcd.addr);
		_lto4b(secsize, rcd.length);
		sr_copy_internal_data(xs, &rcd, sizeof(rcd));
		rv = 0;
	} else if (xs->cmd->opcode == READ_CAPACITY_16) {
		bzero(&rcd16, sizeof(rcd16));
		_lto8b(addr, rcd16.addr);
		_lto4b(secsize, rcd16.length);
		sr_copy_internal_data(xs, &rcd16, sizeof(rcd16));
		rv = 0;
	}

	return (rv);
}

int
sr_raid_tur(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_tur\n", DEVNAME(sd->sd_sc));

	if (sd->sd_vol_status == BIOC_SVOFFLINE) {
		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT;
		sd->sd_scsi_sense.flags = SKEY_NOT_READY;
		sd->sd_scsi_sense.add_sense_code = 0x04;
		sd->sd_scsi_sense.add_sense_code_qual = 0x11;
		sd->sd_scsi_sense.extra_len = 4;
		return (1);
	} else if (sd->sd_vol_status == BIOC_SVINVALID) {
		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT;
		sd->sd_scsi_sense.flags = SKEY_HARDWARE_ERROR;
		sd->sd_scsi_sense.add_sense_code = 0x05;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		return (1);
	}

	return (0);
}

int
sr_raid_request_sense(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_request_sense\n",
	    DEVNAME(sd->sd_sc));

	/* use latest sense data */
	memcpy(&xs->sense, &sd->sd_scsi_sense, sizeof(xs->sense));

	/* clear sense data */
	bzero(&sd->sd_scsi_sense, sizeof(sd->sd_scsi_sense));

	return (0);
}

int
sr_raid_start_stop(struct sr_workunit *wu)
{
	struct scsi_xfer	*xs = wu->swu_xs;
	struct scsi_start_stop	*ss = (struct scsi_start_stop *)xs->cmd;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_start_stop\n",
	    DEVNAME(wu->swu_dis->sd_sc));

	if (!ss)
		return (1);

	/*
	 * do nothing!
	 * a softraid discipline should always reflect correct status
	 */
	return (0);
}

int
sr_raid_sync(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	int			s, rv = 0, ios;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_sync\n", DEVNAME(sd->sd_sc));

	/* when doing a fake sync don't count the wu */
	ios = (wu->swu_flags & SR_WUF_FAKE) ? 0 : 1;

	s = splbio();
	sd->sd_sync = 1;
	while (sd->sd_wu_pending > ios) {
		if (tsleep(sd, PRIBIO, "sr_sync", 15 * hz) == EWOULDBLOCK) {
			DNPRINTF(SR_D_DIS, "%s: sr_raid_sync timeout\n",
			    DEVNAME(sd->sd_sc));
			rv = 1;
			break;
		}
	}
	sd->sd_sync = 0;
	splx(s);

	wakeup(&sd->sd_sync);

	return (rv);
}

void
sr_raid_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
#ifdef SR_DEBUG
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
#endif
	int			s;

	DNPRINTF(SR_D_INTR, "%s: %s %s intr bp %p xs %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name, bp, xs);

	s = splbio();
	sr_ccb_done(ccb);
	sr_wu_done(wu);
	splx(s);
}

void
sr_schedule_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup;
	int			s;

	DNPRINTF(SR_D_WU, "sr_schedule_wu: schedule wu %p state %i "
	    "flags 0x%x\n", wu, wu->swu_state, wu->swu_flags);

	KASSERT(wu->swu_io_count > 0);

	s = splbio();

	/* Construct the work unit, do not schedule it. */
	if (wu->swu_state == SR_WU_CONSTRUCT)
		goto queued;

	/* Deferred work unit being reconstructed, do not start. */
	if (wu->swu_state == SR_WU_REQUEUE)
		goto queued;

	/* Current work unit failed, restart. */
	if (wu->swu_state == SR_WU_RESTART)
		goto start;

	if (wu->swu_state != SR_WU_INPROGRESS)
		panic("sr_schedule_wu: work unit not in progress (state %i)\n",
		    wu->swu_state);

	/* Walk queue backwards and fill in collider if we have one. */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* Defer work unit due to LBA collision. */
		DNPRINTF(SR_D_WU, "sr_schedule_wu: deferring work unit %p\n",
		    wu);
		wu->swu_state = SR_WU_DEFERRED;
		while (wup->swu_collider)
			wup = wup->swu_collider;
		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		goto queued;
	}

start:
	sr_raid_startwu(wu);

queued:
	splx(s);
}

void
sr_raid_startwu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_ccb		*ccb;

	DNPRINTF(SR_D_WU, "sr_raid_startwu: start wu %p\n", wu);

	splassert(IPL_BIO);

	if (wu->swu_state == SR_WU_DEFERRED) {
		TAILQ_REMOVE(&sd->sd_wu_defq, wu, swu_link);
		wu->swu_state = SR_WU_INPROGRESS;
	}

	if (wu->swu_state != SR_WU_RESTART)
		TAILQ_INSERT_TAIL(&sd->sd_wu_pendq, wu, swu_link);

	/* Start all of the individual I/Os. */
	if (wu->swu_cb_active == 1)
		panic("%s: sr_startwu_callback", DEVNAME(sd->sd_sc));
	wu->swu_cb_active = 1;

	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link)
		VOP_STRATEGY(&ccb->ccb_buf);

	wu->swu_cb_active = 0;
}

void
sr_raid_recreate_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup = wu;

	/*
	 * Recreate a work unit by releasing the associated CCBs and reissuing
	 * the SCSI I/O request. This process is then repeated for all of the
	 * colliding work units.
	 */
	do {
		sr_wu_release_ccbs(wup);

		wup->swu_state = SR_WU_REQUEUE;
		if (sd->sd_scsi_rw(wup))
			panic("could not requeue I/O");

		wup = wup->swu_collider;
	} while (wup);
}

int
sr_alloc_resources(struct sr_discipline *sd)
{
	if (sr_wu_alloc(sd, sizeof(struct sr_workunit))) {
		sr_error(sd->sd_sc, "unable to allocate work units");
		return (ENOMEM);
	}
	if (sr_ccb_alloc(sd)) {
		sr_error(sd->sd_sc, "unable to allocate ccbs");
		return (ENOMEM);
	}

	return (0);
}

void
sr_free_resources(struct sr_discipline *sd)
{
	sr_wu_free(sd);
	sr_ccb_free(sd);
}

void
sr_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;

	/* multiple IOs to the same chunk that fail will come through here */
	if (old_state == new_state)
		goto done;

	switch (old_state) {
	case BIOC_SDONLINE:
		if (new_state == BIOC_SDOFFLINE)
			break;
		else
			goto die;
		break;

	case BIOC_SDOFFLINE:
		goto die;

	default:
die:
		splx(s); /* XXX */
		panic("%s: %s: %s: invalid chunk state transition "
		    "%d -> %d", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_chunks[c]->src_meta.scm_status = new_state;
	sd->sd_set_vol_state(sd);

	sd->sd_must_flush = 1;
	task_add(systq, &sd->sd_meta_save_task);
done:
	splx(s);
}

void
sr_set_vol_state(struct sr_discipline *sd)
{
	int			states[SR_MAX_STATES];
	int			new_state, i, nd;
	int			old_state = sd->sd_vol_status;
	u_int32_t		s;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_set_vol_state\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	nd = sd->sd_meta->ssdi.ssd_chunk_no;

	for (i = 0; i < SR_MAX_STATES; i++)
		states[i] = 0;

	for (i = 0; i < nd; i++) {
		s = sd->sd_vol.sv_chunks[i]->src_meta.scm_status;
		if (s >= SR_MAX_STATES)
			panic("%s: %s: %s: invalid chunk state",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scmi.scm_devname);
		states[s]++;
	}

	if (states[BIOC_SDONLINE] == nd)
		new_state = BIOC_SVONLINE;
	else
		new_state = BIOC_SVOFFLINE;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_set_vol_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    old_state, new_state);

	switch (old_state) {
	case BIOC_SVONLINE:
		if (new_state == BIOC_SVOFFLINE || new_state == BIOC_SVONLINE)
			break;
		else
			goto die;
		break;

	case BIOC_SVOFFLINE:
		/* XXX this might be a little too much */
		goto die;

	default:
die:
		panic("%s: %s: invalid volume state transition "
		    "%d -> %d", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol_status = new_state;
}

void *
sr_block_get(struct sr_discipline *sd, long length)
{
	return dma_alloc(length, PR_NOWAIT | PR_ZERO);
}

void
sr_block_put(struct sr_discipline *sd, void *ptr, int length)
{
	dma_free(ptr, length);
}

void
sr_checksum_print(u_int8_t *md5)
{
	int			i;

	for (i = 0; i < MD5_DIGEST_LENGTH; i++)
		printf("%02x", md5[i]);
}

void
sr_checksum(struct sr_softc *sc, void *src, void *md5, u_int32_t len)
{
	MD5_CTX			ctx;

	DNPRINTF(SR_D_MISC, "%s: sr_checksum(%p %p %d)\n", DEVNAME(sc), src,
	    md5, len);

	MD5Init(&ctx);
	MD5Update(&ctx, src, len);
	MD5Final(md5, &ctx);
}

void
sr_uuid_generate(struct sr_uuid *uuid)
{
	arc4random_buf(uuid->sui_id, sizeof(uuid->sui_id));
	/* UUID version 4: random */
	uuid->sui_id[6] &= 0x0f;
	uuid->sui_id[6] |= 0x40;
	/* RFC4122 variant */
	uuid->sui_id[8] &= 0x3f;
	uuid->sui_id[8] |= 0x80;
}

char *
sr_uuid_format(struct sr_uuid *uuid)
{
	char *uuidstr;

	uuidstr = malloc(37, M_DEVBUF, M_WAITOK);

	snprintf(uuidstr, 37,
	    "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-"
	    "%02x%02x%02x%02x%02x%02x",
	    uuid->sui_id[0], uuid->sui_id[1],
	    uuid->sui_id[2], uuid->sui_id[3],
	    uuid->sui_id[4], uuid->sui_id[5],
	    uuid->sui_id[6], uuid->sui_id[7],
	    uuid->sui_id[8], uuid->sui_id[9],
	    uuid->sui_id[10], uuid->sui_id[11],
	    uuid->sui_id[12], uuid->sui_id[13],
	    uuid->sui_id[14], uuid->sui_id[15]);

	return uuidstr;
}

void
sr_uuid_print(struct sr_uuid *uuid, int cr)
{
	char *uuidstr;

	uuidstr = sr_uuid_format(uuid);
	printf("%s%s", uuidstr, (cr ? "\n" : ""));
	free(uuidstr, M_DEVBUF, 37);
}

int
sr_already_assembled(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_discipline	*sdtmp;

	TAILQ_FOREACH(sdtmp, &sc->sc_dis_list, sd_link) {
		if (!bcmp(&sd->sd_meta->ssdi.ssd_uuid,
		    &sdtmp->sd_meta->ssdi.ssd_uuid,
		    sizeof(sd->sd_meta->ssdi.ssd_uuid)))
			return (1);
	}

	return (0);
}

int32_t
sr_validate_stripsize(u_int32_t b)
{
	int			s = 0;

	if (b % DEV_BSIZE)
		return (-1);

	while ((b & 1) == 0) {
		b >>= 1;
		s++;
	}

	/* only multiple of twos */
	b >>= 1;
	if (b)
		return(-1);

	return (s);
}

void
sr_shutdown(void)
{
	struct sr_softc		*sc = softraid0;
	struct sr_discipline	*sd;

	DNPRINTF(SR_D_MISC, "%s: sr_shutdown\n", DEVNAME(sc));

	/*
	 * Since softraid is not under mainbus, we have to explicitly
	 * notify its children that the power is going down, so they
	 * can execute their shutdown hooks.
	 */
	config_suspend((struct device *)sc, DVACT_POWERDOWN);

	/* Shutdown disciplines in reverse attach order. */
	while ((sd = TAILQ_LAST(&sc->sc_dis_list, sr_discipline_list)) != NULL)
		sr_discipline_shutdown(sd, 1);
}

int
sr_validate_io(struct sr_workunit *wu, daddr_t *blkno, char *func)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	int			rv = 1;

	DNPRINTF(SR_D_DIS, "%s: %s 0x%02x\n", DEVNAME(sd->sd_sc), func,
	    xs->cmd->opcode);

	if (sd->sd_meta->ssd_data_blkno == 0)
		panic("invalid data blkno");

	if (sd->sd_vol_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: %s device offline\n",
		    DEVNAME(sd->sd_sc), func);
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count for %s\n",
		    DEVNAME(sd->sd_sc), func, sd->sd_meta->ssd_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		*blkno = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		*blkno = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		*blkno = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen for %s\n",
		    DEVNAME(sd->sd_sc), func, sd->sd_meta->ssd_devname);
		goto bad;
	}

	*blkno *= (sd->sd_meta->ssdi.ssd_secsize / DEV_BSIZE);

	wu->swu_blk_start = *blkno;
	wu->swu_blk_end = *blkno + (xs->datalen >> DEV_BSHIFT) - 1;

	if (wu->swu_blk_end > sd->sd_meta->ssdi.ssd_size) {
		DNPRINTF(SR_D_DIS, "%s: %s out of bounds start: %lld "
		    "end: %lld length: %d\n",
		    DEVNAME(sd->sd_sc), func, (long long)wu->swu_blk_start,
		    (long long)wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}

	rv = 0;
bad:
	return (rv);
}

void
sr_rebuild_start(void *arg)
{
	struct sr_discipline	*sd = arg;
	struct sr_softc		*sc = sd->sd_sc;

	DNPRINTF(SR_D_REBUILD, "%s: %s starting rebuild thread\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	if (kthread_create(sr_rebuild_thread, sd, &sd->sd_background_proc,
	    DEVNAME(sc)) != 0)
		printf("%s: unable to start background operation\n",
		    DEVNAME(sc));
}

void
sr_rebuild_thread(void *arg)
{
	struct sr_discipline	*sd = arg;

	DNPRINTF(SR_D_REBUILD, "%s: %s rebuild thread started\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	sd->sd_reb_active = 1;
	sd->sd_rebuild(sd);
	sd->sd_reb_active = 0;

	kthread_exit(0);
}

void
sr_rebuild(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	u_int64_t		sz, whole_blk, partial_blk, blk, restart;
	daddr_t			lba;
	struct sr_workunit	*wu_r, *wu_w;
	struct scsi_xfer	xs_r, xs_w;
	struct scsi_rw_16	*cr, *cw;
	int			c, s, slept, percent = 0, old_percent = -1;
	u_int8_t		*buf;

	whole_blk = sd->sd_meta->ssdi.ssd_size / SR_REBUILD_IO_SIZE;
	partial_blk = sd->sd_meta->ssdi.ssd_size % SR_REBUILD_IO_SIZE;

	restart = sd->sd_meta->ssd_rebuild / SR_REBUILD_IO_SIZE;
	if (restart > whole_blk) {
		printf("%s: bogus rebuild restart offset, starting from 0\n",
		    DEVNAME(sc));
		restart = 0;
	}
	if (restart) {
		/*
		 * XXX there is a hole here; there is a posibility that we
		 * had a restart however the chunk that was supposed to
		 * be rebuilt is no longer valid; we can reach this situation
		 * when a rebuild is in progress and the box crashes and
		 * on reboot the rebuild chunk is different (like zero'd or
		 * replaced).  We need to check the uuid of the chunk that is
		 * being rebuilt to assert this.
		 */
		percent = sr_rebuild_percent(sd);
		printf("%s: resuming rebuild on %s at %d%%\n",
		    DEVNAME(sc), sd->sd_meta->ssd_devname, percent);
	}

	/* currently this is 64k therefore we can use dma_alloc */
	buf = dma_alloc(SR_REBUILD_IO_SIZE << DEV_BSHIFT, PR_WAITOK);
	for (blk = restart; blk <= whole_blk; blk++) {
		lba = blk * SR_REBUILD_IO_SIZE;
		sz = SR_REBUILD_IO_SIZE;
		if (blk == whole_blk) {
			if (partial_blk == 0)
				break;
			sz = partial_blk;
		}

		/* get some wu */
		wu_r = sr_scsi_wu_get(sd, 0);
		wu_w = sr_scsi_wu_get(sd, 0);

		DNPRINTF(SR_D_REBUILD, "%s: %s rebuild wu_r %p, wu_w %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, wu_r, wu_w);

		/* setup read io */
		bzero(&xs_r, sizeof xs_r);
		xs_r.error = XS_NOERROR;
		xs_r.flags = SCSI_DATA_IN;
		xs_r.datalen = sz << DEV_BSHIFT;
		xs_r.data = buf;
		xs_r.cmdlen = sizeof(*cr);
		xs_r.cmd = &xs_r.cmdstore;
		cr = (struct scsi_rw_16 *)xs_r.cmd;
		cr->opcode = READ_16;
		_lto4b(sz, cr->length);
		_lto8b(lba, cr->addr);
		wu_r->swu_state = SR_WU_CONSTRUCT;
		wu_r->swu_flags |= SR_WUF_REBUILD;
		wu_r->swu_xs = &xs_r;
		if (sd->sd_scsi_rw(wu_r)) {
			printf("%s: could not create read io\n",
			    DEVNAME(sc));
			goto fail;
		}

		/* setup write io */
		bzero(&xs_w, sizeof xs_w);
		xs_w.error = XS_NOERROR;
		xs_w.flags = SCSI_DATA_OUT;
		xs_w.datalen = sz << DEV_BSHIFT;
		xs_w.data = buf;
		xs_w.cmdlen = sizeof(*cw);
		xs_w.cmd = &xs_w.cmdstore;
		cw = (struct scsi_rw_16 *)xs_w.cmd;
		cw->opcode = WRITE_16;
		_lto4b(sz, cw->length);
		_lto8b(lba, cw->addr);
		wu_w->swu_state = SR_WU_CONSTRUCT;
		wu_w->swu_flags |= SR_WUF_REBUILD | SR_WUF_WAKEUP;
		wu_w->swu_xs = &xs_w;
		if (sd->sd_scsi_rw(wu_w)) {
			printf("%s: could not create write io\n",
			    DEVNAME(sc));
			goto fail;
		}

		/*
		 * collide with the read io so that we get automatically
		 * started when the read is done
		 */
		wu_w->swu_state = SR_WU_DEFERRED;
		wu_r->swu_collider = wu_w;
		s = splbio();
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu_w, swu_link);
		splx(s);

		DNPRINTF(SR_D_REBUILD, "%s: %s rebuild scheduling wu_r %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, wu_r);

		wu_r->swu_state = SR_WU_INPROGRESS;
		sr_schedule_wu(wu_r);

		/* wait for write completion */
		slept = 0;
		while ((wu_w->swu_flags & SR_WUF_REBUILDIOCOMP) == 0) {
			tsleep(wu_w, PRIBIO, "sr_rebuild", 0);
			slept = 1;
		}
		/* yield if we didn't sleep */
		if (slept == 0)
			tsleep(sc, PWAIT, "sr_yield", 1);

		sr_scsi_wu_put(sd, wu_r);
		sr_scsi_wu_put(sd, wu_w);

		sd->sd_meta->ssd_rebuild = lba;

		/* XXX - this should be based on size, not percentage. */
		/* save metadata every percent */
		percent = sr_rebuild_percent(sd);
		if (percent != old_percent && blk != whole_blk) {
			if (sr_meta_save(sd, SR_META_DIRTY))
				printf("%s: could not save metadata to %s\n",
				    DEVNAME(sc), sd->sd_meta->ssd_devname);
			old_percent = percent;
		}

		if (sd->sd_reb_abort)
			goto abort;
	}

	/* all done */
	sd->sd_meta->ssd_rebuild = 0;
	for (c = 0; c < sd->sd_meta->ssdi.ssd_chunk_no; c++) {
		if (sd->sd_vol.sv_chunks[c]->src_meta.scm_status ==
		    BIOC_SDREBUILD) {
			sd->sd_set_chunk_state(sd, c, BIOC_SDONLINE);
			break;
		}
	}

abort:
	if (sr_meta_save(sd, SR_META_DIRTY))
		printf("%s: could not save metadata to %s\n",
		    DEVNAME(sc), sd->sd_meta->ssd_devname);
fail:
	dma_free(buf, SR_REBUILD_IO_SIZE << DEV_BSHIFT);
}

#ifndef SMALL_KERNEL
int
sr_sensors_create(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	int			rv = 1;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_sensors_create\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname);

	sd->sd_vol.sv_sensor.type = SENSOR_DRIVE;
	sd->sd_vol.sv_sensor.status = SENSOR_S_UNKNOWN;
	strlcpy(sd->sd_vol.sv_sensor.desc, sd->sd_meta->ssd_devname,
	    sizeof(sd->sd_vol.sv_sensor.desc));

	sensor_attach(&sc->sc_sensordev, &sd->sd_vol.sv_sensor);
	sd->sd_vol.sv_sensor_attached = 1;

	if (sc->sc_sensor_task == NULL) {
		sc->sc_sensor_task = sensor_task_register(sc,
		    sr_sensors_refresh, 10);
		if (sc->sc_sensor_task == NULL)
			goto bad;
	}

	rv = 0;
bad:
	return (rv);
}

void
sr_sensors_delete(struct sr_discipline *sd)
{
	DNPRINTF(SR_D_STATE, "%s: sr_sensors_delete\n", DEVNAME(sd->sd_sc));

	if (sd->sd_vol.sv_sensor_attached)
		sensor_detach(&sd->sd_sc->sc_sensordev, &sd->sd_vol.sv_sensor);
}

void
sr_sensors_refresh(void *arg)
{
	struct sr_softc		*sc = arg;
	struct sr_volume	*sv;
	struct sr_discipline	*sd;

	DNPRINTF(SR_D_STATE, "%s: sr_sensors_refresh\n", DEVNAME(sc));

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		sv = &sd->sd_vol;

		switch(sd->sd_vol_status) {
		case BIOC_SVOFFLINE:
			sv->sv_sensor.value = SENSOR_DRIVE_FAIL;
			sv->sv_sensor.status = SENSOR_S_CRIT;
			break;

		case BIOC_SVDEGRADED:
			sv->sv_sensor.value = SENSOR_DRIVE_PFAIL;
			sv->sv_sensor.status = SENSOR_S_WARN;
			break;

		case BIOC_SVSCRUB:
		case BIOC_SVONLINE:
			sv->sv_sensor.value = SENSOR_DRIVE_ONLINE;
			sv->sv_sensor.status = SENSOR_S_OK;
			break;

		default:
			sv->sv_sensor.value = 0; /* unknown */
			sv->sv_sensor.status = SENSOR_S_UNKNOWN;
		}
	}
}
#endif /* SMALL_KERNEL */

#ifdef SR_FANCY_STATS
void				sr_print_stats(void);

void
sr_print_stats(void)
{
	struct sr_softc		*sc = softraid0;
	struct sr_discipline	*sd;

	if (sc == NULL) {
		printf("no softraid softc found\n");
		return;
	}

	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		printf("%s: ios pending %d, collisions %llu\n",
		    sd->sd_meta->ssd_devname,
		    sd->sd_wu_pending,
		    sd->sd_wu_collisions);
	}
}
#endif /* SR_FANCY_STATS */

#ifdef SR_DEBUG
void
sr_meta_print(struct sr_metadata *m)
{
	int			i;
	struct sr_meta_chunk	*mc;
	struct sr_meta_opt_hdr	*omh;

	if (!(sr_debug & SR_D_META))
		return;

	printf("\tssd_magic 0x%llx\n", m->ssdi.ssd_magic);
	printf("\tssd_version %d\n", m->ssdi.ssd_version);
	printf("\tssd_vol_flags 0x%x\n", m->ssdi.ssd_vol_flags);
	printf("\tssd_uuid ");
	sr_uuid_print(&m->ssdi.ssd_uuid, 1);
	printf("\tssd_chunk_no %d\n", m->ssdi.ssd_chunk_no);
	printf("\tssd_chunk_id %d\n", m->ssdi.ssd_chunk_id);
	printf("\tssd_opt_no %d\n", m->ssdi.ssd_opt_no);
	printf("\tssd_volid %d\n", m->ssdi.ssd_volid);
	printf("\tssd_level %d\n", m->ssdi.ssd_level);
	printf("\tssd_size %lld\n", m->ssdi.ssd_size);
	printf("\tssd_devname %s\n", m->ssd_devname);
	printf("\tssd_vendor %s\n", m->ssdi.ssd_vendor);
	printf("\tssd_product %s\n", m->ssdi.ssd_product);
	printf("\tssd_revision %s\n", m->ssdi.ssd_revision);
	printf("\tssd_strip_size %d\n", m->ssdi.ssd_strip_size);
	printf("\tssd_checksum ");
	sr_checksum_print(m->ssd_checksum);
	printf("\n");
	printf("\tssd_meta_flags 0x%x\n", m->ssd_meta_flags);
	printf("\tssd_ondisk %llu\n", m->ssd_ondisk);

	mc = (struct sr_meta_chunk *)(m + 1);
	for (i = 0; i < m->ssdi.ssd_chunk_no; i++, mc++) {
		printf("\t\tscm_volid %d\n", mc->scmi.scm_volid);
		printf("\t\tscm_chunk_id %d\n", mc->scmi.scm_chunk_id);
		printf("\t\tscm_devname %s\n", mc->scmi.scm_devname);
		printf("\t\tscm_size %lld\n", mc->scmi.scm_size);
		printf("\t\tscm_coerced_size %lld\n",mc->scmi.scm_coerced_size);
		printf("\t\tscm_uuid ");
		sr_uuid_print(&mc->scmi.scm_uuid, 1);
		printf("\t\tscm_checksum ");
		sr_checksum_print(mc->scm_checksum);
		printf("\n");
		printf("\t\tscm_status %d\n", mc->scm_status);
	}

	omh = (struct sr_meta_opt_hdr *)((u_int8_t *)(m + 1) +
	    sizeof(struct sr_meta_chunk) * m->ssdi.ssd_chunk_no);
	for (i = 0; i < m->ssdi.ssd_opt_no; i++) {
		printf("\t\t\tsom_type %d\n", omh->som_type);
		printf("\t\t\tsom_checksum ");
		sr_checksum_print(omh->som_checksum);
		printf("\n");
		omh = (struct sr_meta_opt_hdr *)((void *)omh +
		    omh->som_length);
	}
}

void
sr_dump_block(void *blk, int len)
{
	uint8_t			*b = blk;
	int			i, j, c;

	for (i = 0; i < len; i += 16) {
		for (j = 0; j < 16; j++)
			printf("%.2x ", b[i + j]);
		printf("  ");
		for (j = 0; j < 16; j++) {
			c = b[i + j];
			if (c < ' ' || c > 'z' || i + j > len)
				c = '.';
			printf("%c", c);
		}
		printf("\n");
	}
}

void
sr_dump_mem(u_int8_t *p, int len)
{
	int			i;

	for (i = 0; i < len; i++)
		printf("%02x ", *p++);
	printf("\n");
}

#endif /* SR_DEBUG */

#ifdef HIBERNATE
/*
 * Side-effect free (no malloc, printf, pool, splx) softraid crypto writer.
 *
 * This function must perform the following:
 * 1. Determine the underlying device's own side-effect free I/O function
 *    (eg, ahci_hibernate_io, wd_hibernate_io, etc).
 * 2. Store enough information in the provided page argument for subsequent
 *    I/O calls (such as the crypto discipline structure for the keys, the
 *    offset of the softraid partition on the underlying disk, as well as
 *    the offset of the swap partition within the crypto volume.
 * 3. Encrypt the incoming data using the sr_discipline keys, then pass
 *    the request to the underlying device's own I/O function.
 */
int
sr_hibernate_io(dev_t dev, daddr_t blkno, vaddr_t addr, size_t size, int op, void *page)
{
	/* Struct for stashing data obtained on HIB_INIT.
	 * XXX
	 * We share the page with the underlying device's own
	 * side-effect free I/O function, so we pad our data to
	 * the end of the page. Presently this does not overlap
	 * with either of the two other side-effect free i/o
	 * functions (ahci/wd).
	 */
	struct {
		char pad[3072];
		struct sr_discipline *srd;
		hibio_fn subfn;		/* underlying device i/o fn */
		dev_t subdev;		/* underlying device dev_t */
		daddr_t sr_swapoff;	/* ofs of swap part in sr volume */
		char buf[DEV_BSIZE];	/* encryption performed into this buf */
	} *my = page;
	extern struct cfdriver sd_cd;
	char errstr[128], *dl_ret;
	struct sr_chunk *schunk;
	struct sd_softc *sd;
	struct aes_xts_ctx ctx;
	struct sr_softc *sc;
	struct device *dv;
	daddr_t key_blkno;
	uint32_t sub_raidoff;  /* ofs of sr part in underlying dev */
	struct disklabel dl;
	struct partition *pp;
	size_t i, j;
	u_char iv[8];

	/*
	 * In HIB_INIT, we are passed the swap partition size and offset
	 * in 'size' and 'blkno' respectively. These are relative to the
	 * start of the softraid partition, and we need to save these
	 * for later translation to the underlying device's layout.
	 */
	if (op == HIB_INIT) {
		dv = disk_lookup(&sd_cd, DISKUNIT(dev));
		sd = (struct sd_softc *)dv;
		sc = (struct sr_softc *)dv->dv_parent->dv_parent;

		/*
		 * Look up the sr discipline. This is used to determine
		 * if we are SR crypto and what the underlying device is.
		 */
		my->srd = sc->sc_targets[sd->sc_link->target];
		DNPRINTF(SR_D_MISC, "sr_hibernate_io: discipline is %s\n",
			my->srd->sd_name);
		if (strncmp(my->srd->sd_name, "CRYPTO",
		    sizeof(my->srd->sd_name)))
			return (ENOTSUP);

		/* Find the underlying device */
		schunk = my->srd->sd_vol.sv_chunks[0];
		my->subdev = schunk->src_dev_mm;

		/*
		 * Find the appropriate underlying device side effect free
		 * I/O function, based on the type of device it is.
		 */
		my->subfn = get_hibernate_io_function(my->subdev);
		if (!my->subfn)
			return (ENODEV);

		/*
		 * Find blkno where this raid partition starts on
		 * the underlying disk.
		 */
		dl_ret = disk_readlabel(&dl, my->subdev, errstr,
		    sizeof(errstr));
		if (dl_ret) {
			printf("Hibernate error reading disklabel: %s\n", dl_ret);
			return (ENOTSUP);
		}

		pp = &dl.d_partitions[DISKPART(my->subdev)];
		if (pp->p_fstype != FS_RAID || DL_GETPSIZE(pp) == 0)
			return (ENOTSUP);

		/* Find the blkno of the SR part in the underlying device */
		sub_raidoff = my->srd->sd_meta->ssd_data_blkno +
		    DL_SECTOBLK(&dl, DL_GETPOFFSET(pp));
		DNPRINTF(SR_D_MISC,"sr_hibernate_io: blk trans ofs: %d blks\n",
		    sub_raidoff);

		/* Save the blkno of the swap partition in the SR disk */
		my->sr_swapoff = blkno;

		/* Initialize the sub-device */
		return my->subfn(my->subdev, sub_raidoff + blkno,
		    addr, size, op, page);
	}

	/* Hibernate only uses (and we only support) writes */
	if (op != HIB_W)
		return (ENOTSUP);

	/*
	 * Blocks act as the IV for the encryption. These block numbers
	 * are relative to the start of the sr partition, but the 'blkno'
	 * passed above is relative to the start of the swap partition
	 * inside the sr partition, so bias appropriately.
	 */
	key_blkno = my->sr_swapoff + blkno;

	/* Process each disk block one at a time. */
	for (i = 0; i < size; i += DEV_BSIZE) {
		int res;

		bzero(&ctx, sizeof(ctx));

		/*
		 * Set encryption key (from the sr discipline stashed
		 * during HIB_INIT. This code is based on the softraid
		 * bootblock code.
		 */
		aes_xts_setkey(&ctx, my->srd->mds.mdd_crypto.scr_key[0], 64);
		/* We encrypt DEV_BSIZE bytes at a time in my->buf */
		memcpy(my->buf, ((char *)addr) + i, DEV_BSIZE);

		/* Block number is the IV */
		memcpy(&iv, &key_blkno, sizeof(key_blkno));
		aes_xts_reinit(&ctx, iv);

		/* Encrypt DEV_BSIZE bytes, AES_XTS_BLOCKSIZE bytes at a time */
		for (j = 0; j < DEV_BSIZE; j += AES_XTS_BLOCKSIZE)
			aes_xts_encrypt(&ctx, my->buf + j);

		/*
		 * Write one block out from my->buf to the underlying device
		 * using its own side-effect free I/O function.
		 */
		res = my->subfn(my->subdev, blkno + (i / DEV_BSIZE),
		    (vaddr_t)(my->buf), DEV_BSIZE, op, page);
		if (res != 0)
			return (res);
		key_blkno++;
	}
	return (0);
}
#endif /* HIBERNATE */
@


1.381
log
@Provide sufficient info in error messages to identify
softraid volume and backing disk when i/o errors occur.

Original issue reported by Paul de Weerd.

Suggestions from jsing@@.

ok deraadt@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.380 2017/04/14 15:11:31 bluhm Exp $ */
d2572 3
d2579 1
a2579 1
	return (0);
@


1.380
log
@Avoid some false positives with cppcheck.  No binary change.
OK jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.379 2017/03/27 17:42:19 deraadt Exp $ */
d2080 4
a2083 4
			printf("%s: i/o error on block %lld target %d "
			    "b_error %d\n", DEVNAME(sc),
			    (long long)ccb->ccb_buf.b_blkno, ccb->ccb_target,
			    ccb->ccb_buf.b_error);
@


1.379
log
@If the sub-device of a softraid lacks a side-effect io function, return
failure as early as possible.
ok mlarkin claudio
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.378 2017/03/19 16:01:08 tb Exp $ */
d5061 2
a5062 1
		if (strncmp(my->srd->sd_name, "CRYPTO", 10))
@


1.378
log
@Restore behavior from before r1.376: only set bv_percent if a rebuild is
in progress. This eliminates the spurious and harmless "0% done" message
in the output of 'bioctl softraid0' reported by various on misc.

ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.377 2016/07/20 20:45:13 krw Exp $ */
d5073 2
@


1.377
log
@Plug potential leak of device list.

Problem found by  Michael McConville.

Tested & ok stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.376 2016/05/31 15:19:12 jsing Exp $ */
d2619 2
a2620 1
		bv->bv_percent = sr_rebuild_percent(sd);
@


1.376
log
@Provide a function for calculting the rebuild percentage, rather than
having five copies of the same code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.375 2016/04/29 14:01:37 krw Exp $ */
d3316 1
a3316 1
	dev_t			*dt;
d3589 2
d3594 2
@


1.375
log
@Panic when attempting to execute a scsi command with no discipline
defined. Carrying on is pointless. And will currently cause a NULL
pointer deref anyway.

NULL deref found by mmcc@@ and his friend clang.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.374 2016/04/26 13:42:39 krw Exp $ */
a2602 1
	int64_t			rb, sz;
d2619 1
a2620 9
		if (bv->bv_status == BIOC_SVREBUILD) {
			sz = sd->sd_meta->ssdi.ssd_size;
			rb = sd->sd_meta->ssd_rebuild;
			if (rb > 0)
				bv->bv_percent = 100 -
				    ((sz * 100 - rb * 100) / sz) - 1;
			else
				bv->bv_percent = 0;
		}
d3263 14
d4645 1
a4645 1
	u_int64_t		sz, psz, whole_blk, partial_blk, blk, restart;
a4646 1
	int64_t			rb;
d4672 1
a4672 6
		psz = sd->sd_meta->ssdi.ssd_size;
		rb = sd->sd_meta->ssd_rebuild;
		if (rb > 0)
			percent = 100 - ((psz * 100 - rb * 100) / psz) - 1;
		else
			percent = 0;
d4770 1
a4770 6
		psz = sd->sd_meta->ssdi.ssd_size;
		rb = sd->sd_meta->ssd_rebuild;
		if (rb > 0)
			percent = 100 - ((psz * 100 - rb * 100) / psz) - 1;
		else
			percent = 0;
@


1.374
log
@Display correct value in error message.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.373 2016/04/26 13:38:24 krw Exp $ */
d2353 2
a2354 4
	if (sd == NULL) {
		printf("%s: sr_scsi_cmd NULL discipline\n", DEVNAME(sc));
		goto stuffup;
	}
d2433 1
a2433 1
	if (sd && sd->sd_scsi_sense.error_code) {
@


1.373
log
@Do NOT attempt a rebuild using a hot spare with a sector size
greater than the sector size of the softraid volume. i.e. 512-byte
hot spares should work on 4096-byte volumes but 4096-byte hotspares
will not work on 512-byte volumes.

Pointed out, errors corrected and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.372 2016/04/26 13:22:16 krw Exp $ */
d3215 1
a3215 1
		    "required", devname, label.d_secsize);
@


1.372
log
@Restore intro comment to sr_hotspare_rebuild(), which was erroneously
replaced by comment for first chunk of code.

Pointed out by jsing@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.371 2016/04/19 21:47:56 krw Exp $ */
d3035 2
a3036 1
		if (hotspare->src_size >= chunk->src_size)
d3213 5
@


1.371
log
@Use consistent intro comment when searching for the first offline
chunk and perhaps save the next person reading the code some
confusion.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.370 2016/04/19 21:40:48 krw Exp $ */
d3012 4
@


1.370
log
@Use variable 'cid' in for(;;) rather than 'i' with an assignment
'cid = i;' when break'ing. Makes code consistent with same search
later. No functional change and shrinks later functional diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.369 2016/04/19 21:19:58 krw Exp $ */
d3013 1
a3013 4
	/*
	 * Attempt to locate a hotspare and initiate rebuild.
	 */

@


1.369
log
@Change a variable name (chunk_no -> cid) to make a couple of code
chunks more obviously the same. Reduces size of upcoming diff. No
functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.368 2016/04/12 16:26:54 krw Exp $ */
d3017 2
a3018 2
	for (i = 0; i < sd->sd_meta->ssdi.ssd_chunk_no; i++) {
		if (sd->sd_vol.sv_chunks[i]->src_meta.scm_status ==
d3020 1
a3020 2
			cid = i;
			chunk = sd->sd_vol.sv_chunks[i];
a3023 1

@


1.368
log
@No need to rescan chunks in each discipline to find appropriate
volume sector size.  Determine volume sector size in sr_meta_init().

Pointed out, tweaked and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.367 2016/04/04 18:48:39 krw Exp $ */
d3011 1
a3011 1
	int			i, s, chunk_no, busy;
d3020 1
a3020 1
			chunk_no = i;
d3056 1
a3056 1
					if (ccb->ccb_target == chunk_no)
d3062 1
a3062 1
					if (ccb->ccb_target == chunk_no)
@


1.367
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.366 2016/02/14 12:47:27 krw Exp $ */
d542 1
d562 1
a562 1
	/* Initialise chunk metadata and get min/max chunk sizes. */
d578 2
d583 2
@


1.366
log
@Avoid using uninitialized variables in two corner cases. In one
case check if it was set and bail out with a useful message if not.
In the other the variable was the wrong one anyway, and we can just
use the correct variable.

Found by & ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.365 2015/12/29 04:46:28 mmcc Exp $ */
d945 1
d955 1
d957 1
a957 1
	} else if (sm->ssdi.ssd_version == SR_META_VERSION) {
d964 7
a1061 7
	/* Make sure this is a DEV_BSIZE byte/sector device. */
	if (label.d_secsize != DEV_BSIZE) {
		DNPRINTF(SR_D_META, "%s: %s has unsupported sector size (%d)",
		    DEVNAME(sc), devname, label.d_secsize);
		goto done;
	}

a1567 7
	/* Make sure this is a DEV_BSIZE byte/sector device. */
	if (label.d_secsize != DEV_BSIZE) {
		sr_error(sc, "%s has unsupported sector size (%u)",
		    devname, label.d_secsize);
		goto unwind;
	}

d1590 1
a2869 5
	if (label.d_secsize != DEV_BSIZE) {
		sr_error(sc, "%s has unsupported sector size (%u)",
		    devname, label.d_secsize);
		goto fail;
	}
d2929 1
a3181 5
	if (label.d_secsize != DEV_BSIZE) {
		sr_error(sc, "%s has unsupported sector size (%u)",
		    devname, label.d_secsize);
		goto done;
	}
d3656 1
a3656 1
	u_int32_t		bbs, bls;
d3700 2
d3703 1
a3703 1
	bbs = howmany(bb->bb_bootblk_size, DEV_BSIZE) * DEV_BSIZE;
d3709 1
a3709 1
	bls = howmany(bb->bb_bootldr_size, DEV_BSIZE) * DEV_BSIZE;
d4025 1
a4025 1
	int64_t			addr;
d4027 1
d4031 3
a4033 1
	addr = sd->sd_meta->ssdi.ssd_size - 1;
d4040 1
a4040 1
		_lto4b(DEV_BSIZE, rcd.length);
d4046 1
a4046 1
		_lto4b(DEV_BSIZE, rcd16.length);
d4572 2
@


1.365
log
@Remove NULL-checks before free().

ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.364 2015/08/19 19:05:24 krw Exp $ */
d3154 1
d3163 4
a3784 1

d3792 1
a3792 2
		sr_error(sc, "could not save metadata to %s",
		    chunk->src_devname);
@


1.364
log
@Stop passing around constants for metadata size and location. Just
use the constants where needed.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.363 2015/07/29 12:58:16 krw Exp $ */
d1466 1
a1466 2
			if (bc1->sbc_metadata)
				free(bc1->sbc_metadata, M_DEVBUF, 0);
d1474 1
a1474 2
		if (bc1->sbc_metadata)
			free(bc1->sbc_metadata, M_DEVBUF, 0);
d1480 1
a1480 2
		if (bc1->sbc_metadata)
			free(bc1->sbc_metadata, M_DEVBUF, 0);
d1960 1
a1960 2
	if (sd->sd_ccb)
		free(sd->sd_ccb, M_DEVBUF, 0);
d2984 1
a2984 2
	if (hotspare)
		free(hotspare, M_DEVBUF, 0);
d2987 1
a2987 1
	if (sd && sd->sd_vol.sv_chunks)
d2989 2
a2990 4
	if (sd)
		free(sd, M_DEVBUF, 0);
	if (sm)
		free(sm, M_DEVBUF, 0);
d3796 2
a3797 4
	if (bootblk)
		free(bootblk, M_DEVBUF, 0);
	if (bootldr)
		free(bootldr, M_DEVBUF, 0);
d3852 3
a3854 6
	if (sd->sd_vol.sv_chunks)
		free(sd->sd_vol.sv_chunks, M_DEVBUF, 0);
	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF, 0);
	if (sd->sd_meta_foreign)
		free(sd->sd_meta_foreign, M_DEVBUF, 0);
d3859 1
a3859 2
		if (omi->omi_som)
			free(omi->omi_som, M_DEVBUF, 0);
@


1.363
log
@Zap a SLIST in a more obviously correct/safe way.

Originally from pelikan@@, recent prodding from bluhm@@ and jsg@@.

ok pelikan@@ millert@@ bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.362 2015/07/28 15:42:23 krw Exp $ */
d158 1
a158 2
int			sr_meta_rw(struct sr_discipline *, dev_t, void *,
			    size_t, daddr_t, long);
d476 1
a476 2
sr_meta_rw(struct sr_discipline *sd, dev_t dev, void *md, size_t size,
    daddr_t blkno, long flags)
d480 2
a481 2
	DNPRINTF(SR_D_META, "%s: sr_meta_rw(0x%x, %p, %zu, %lld 0x%lx)\n",
	    DEVNAME(sd->sd_sc), dev, md, size, (long long)blkno, flags);
d489 2
a490 1
	rv = sr_rw(sd->sd_sc, dev, md, size, blkno, flags);
d1709 1
a1709 2
	return (sr_meta_rw(sd, dev, md, SR_META_SIZE * DEV_BSIZE,
	    SR_META_OFFSET, B_READ));
d1722 1
a1722 2
	return (sr_meta_rw(sd, dev, md, SR_META_SIZE * DEV_BSIZE,
	    SR_META_OFFSET, B_WRITE));
@


1.362
log
@Tweak a couple of [SLIST|TAILQ]_REMOVE() usages in loops to a more
obvious idiom.

ok bluhm@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.361 2015/07/27 04:11:58 halex Exp $ */
d270 1
a270 2
	SLIST_FOREACH(ch_entry, cl, src_link)
		SLIST_REMOVE(cl, ch_entry, sr_chunk, src_link);
@


1.361
log
@zap trailing linefeeds from sr_error() and panic() calls

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.360 2015/07/21 03:30:51 krw Exp $ */
d1758 9
a1766 9
	SLIST_FOREACH(mhe, &sr_hotplug_callbacks, shl_link)
		if (mhe->sh_hotplug == func) {
			SLIST_REMOVE(&sr_hotplug_callbacks, mhe,
			    sr_hotplug_list, shl_link);
			free(mhe, M_DEVBUF, 0);
			if (SLIST_EMPTY(&sr_hotplug_callbacks))
				SLIST_INIT(&sr_hotplug_callbacks);
			return;
		}
d3851 1
a3851 1
	struct sr_discipline	*sdtmp1, *sdtmp2;
d3885 2
a3886 3
	TAILQ_FOREACH_SAFE(sdtmp1, &sc->sc_dis_list, sd_link, sdtmp2) {
		if (sdtmp1 == sd) {
			TAILQ_REMOVE(&sc->sc_dis_list, sd, sd_link);
a3887 1
		}
d3889 2
@


1.360
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.359 2015/07/20 18:27:36 mlarkin Exp $ */
d3210 1
a3210 1
		sr_error(sc, "%s: %s partition too small\n", DEVNAME(sc),
d3216 1
a3216 1
		sr_error(sc, "%s: %s partition too large\n", DEVNAME(sc),
d4348 1
a4348 1
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
d4414 1
a4414 1
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
@


1.359
log
@
fix spacing
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.358 2015/07/19 18:24:16 krw Exp $ */
d404 1
a404 1
sr_rw(struct sr_softc *sc, dev_t dev, char *buf, size_t size, daddr_t offset,
d414 1
a414 1
	    DEVNAME(sc), dev, buf, size, (long long)offset, flags);
d425 2
a426 2
		DNPRINTF(SR_D_MISC, "%s: dma_buf %p, size %zu, offset %llu)\n",
		    DEVNAME(sc), dma_buf, size, offset);
d438 1
a438 1
		b.b_blkno = offset;
d463 1
a463 1
		offset += howmany(bufsize, DEV_BSIZE);
d479 1
a479 1
    daddr_t offset, long flags)
d484 1
a484 1
	    DEVNAME(sd->sd_sc), dev, md, size, (long long)offset, flags);
d492 1
a492 1
	rv = sr_rw(sd->sd_sc, dev, md, size, offset, flags);
d558 1
a558 1
	sm->ssd_data_offset = SR_DATA_OFFSET;
d942 1
a942 1
		 * Version 3 - update metadata version and fix up data offset
d945 2
a946 2
		if (sm->ssd_data_offset == 0)
			sm->ssd_data_offset = SR_META_V3_DATA_OFFSET;
d952 1
a952 1
		 * data offset so fix this up if necessary.
d954 2
a955 2
		if (sm->ssd_data_offset == 0)
			sm->ssd_data_offset = SR_DATA_OFFSET;
d2034 1
a2034 1
	ccb->ccb_buf.b_blkno = blkno + sd->sd_meta->ssd_data_offset;
d2612 1
a2612 2
	daddr_t			rb;
	int64_t			sz;
d2836 1
a2836 1
	daddr_t			size;
d3209 1
a3209 1
	if (size <= sd->sd_meta->ssd_data_offset) {
d3214 1
a3214 1
	size -= sd->sd_meta->ssd_data_offset;
d3708 1
a3708 1
	if (sd->sd_meta->ssd_data_offset < (SR_BOOT_OFFSET + SR_BOOT_SIZE)) {
d4050 1
a4050 1
	daddr_t			addr;
d4559 1
a4559 1
sr_validate_io(struct sr_workunit *wu, daddr_t *blk, char *func)
d4568 2
a4569 2
	if (sd->sd_meta->ssd_data_offset == 0)
		panic("invalid data offset");
d4584 1
a4584 1
		*blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
d4586 1
a4586 1
		*blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
d4588 1
a4588 1
		*blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
d4595 2
a4596 2
	wu->swu_blk_start = *blk;
	wu->swu_blk_end = *blk + (xs->datalen >> DEV_BSHIFT) - 1;
d4653 2
a4654 1
	daddr_t			lba, rb;
d5088 1
a5088 1
		 * Find block offset where this raid partition is on
d5102 2
a5103 2
		/* Find the offset of the SR part in the underlying device */
		sub_raidoff = my->srd->sd_meta->ssd_data_offset +
d5108 1
a5108 1
		/* Save the offset of the swap partition in the SR disk */
@


1.358
log
@Stop passing daddr_t parameters for lengths. Use long since that's the type
of the destination fields.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.357 2015/07/19 18:03:03 krw Exp $ */
d5039 1
a5039 1
		daddr_t sr_swapoff; /* ofs of swap part in sr volume */
@


1.357
log
@Change some obviously incorrect usages of daddr_t (a DEV_BSIZE
address) to 64 signed or unsigned ints. Add some paranoia checks
during partition size calculations to account for the fact that
partition sizes (DL_GETPSIZE()) are unsigned values.

More daddr_t rectification to do.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.356 2015/07/19 17:04:31 krw Exp $ */
d2016 1
a2016 1
    daddr_t len, u_int8_t *data, int xsflags, int ccbflags)
d4425 1
a4425 1
sr_block_get(struct sr_discipline *sd, int length)
@


1.356
log
@Stop adding and subtracting data offset. Just keep to chunk relative
block offsets until actual i/o is constructed and needs the physical
offset. Eliminate a number of <<DEV_BSIZE shifts as a bonus.

No intentional functional change.

Fixed and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.355 2015/07/19 16:12:10 krw Exp $ */
d45 1
d1553 1
a1553 1
	daddr_t			size;
d1587 2
a1588 3
	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part])) -
	    SR_DATA_OFFSET;
	if (size <= 0) {
d1593 6
d2612 2
a2613 1
	daddr_t			rb, sz;
d2895 12
a2906 2
	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part])) -
	    SR_DATA_OFFSET;
d3127 2
a3128 1
	daddr_t			size, csize;
d3209 12
a3220 2
	size = DL_SECTOBLK(&label, DL_GETPSIZE(&label.d_partitions[part])) -
	    sd->sd_meta->ssd_data_offset;
d4653 2
a4654 2
	daddr_t			whole_blk, partial_blk, blk, sz, lba;
	daddr_t			psz, rb, restart;
@


1.355
log
@Use DEV_BSIZE instead of 512 where appropriate. Use DL_SECTOBLK()
where appropriate. Noop for disks with 512-byte sectors. i.e. the
only kind currently allowed in softraid volumes. But starts laying
the groundwork to allow disks with other sector sizes.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.354 2015/05/29 13:48:45 krw Exp $ */
d2028 1
a2028 1
	ccb->ccb_buf.b_blkno = blkno;
@


1.354
log
@Nuke annoying whitespace nits to shrink some future diffs.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.353 2015/05/20 15:21:57 pelikan Exp $ */
d218 1
a218 1
	{ SR_META_OFFSET, SR_META_SIZE * 512,
d235 2
a236 1
	sd->sd_meta = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO | M_NOWAIT);
d513 1
a513 1
	m = malloc(SR_META_SIZE * 512, M_DEVBUF, M_WAITOK | M_ZERO);
d525 1
a525 1
	bzero(sd->sd_meta, SR_META_SIZE * 512);
d527 1
a527 1
	free(m, M_DEVBUF, SR_META_SIZE * 512);
d653 1
a653 1
	m = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO | M_NOWAIT);
d730 1
a730 1
	free(m, M_DEVBUF, SR_META_SIZE * 512);
d750 1
a750 1
	sm = malloc(SR_META_SIZE * 512, M_DEVBUF, M_WAITOK | M_ZERO);
d801 1
a801 1
	free(sm, M_DEVBUF, SR_META_SIZE * 512);
d1054 1
a1054 1
	/* Make sure this is a 512-byte/sector device. */
d1061 1
a1061 1
	md = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO | M_NOWAIT);
d1132 1
a1132 1
	free(md, M_DEVBUF, SR_META_SIZE * 512);
d1570 1
a1570 1
	/* Make sure this is a 512-byte/sector device. */
d1618 1
a1618 1
	md = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO | M_NOWAIT);
d1691 1
a1691 1
	free(md, M_DEVBUF, SR_META_SIZE * 512);
d1705 2
a1706 2
	return (sr_meta_rw(sd, dev, md, SR_META_SIZE * 512, SR_META_OFFSET,
	    B_READ));
d1719 2
a1720 2
	return (sr_meta_rw(sd, dev, md, SR_META_SIZE * 512, SR_META_OFFSET,
	    B_WRITE));
d3686 1
a3686 1
	if (bb->bb_bootblk_size > SR_BOOT_BLOCKS_SIZE * 512)
d3689 1
a3689 1
	if (bb->bb_bootldr_size > SR_BOOT_LOADER_SIZE * 512)
d4035 1
a4035 1
		_lto4b(512, rcd.length);
d4041 1
a4041 1
		_lto4b(512, rcd16.length);
d4495 1
a4495 1
	if (b % 512)
d5024 1
d5070 2
a5071 2
		if (dl.d_partitions[DISKPART(my->subdev)].p_fstype != FS_RAID ||
		    DL_GETPSIZE(&dl.d_partitions[DISKPART(my->subdev)]) == 0)
d5076 1
a5076 1
		    DL_GETPOFFSET(&dl.d_partitions[DISKPART(my->subdev)]);
@


1.353
log
@Signed types are bad array indicies - let it panic instead.

ok deraadt krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.352 2015/05/11 12:24:06 pelikan Exp $ */
d739 1
a739 1
	struct sr_chunk_head 	*cl = &sd->sd_vol.sv_chunk_list;
d1608 1
a1608 1
	struct sr_chunk_head 	*cl = &sd->sd_vol.sv_chunk_list;
a3465 1
		
d3539 1
a3539 1
		    sd->sd_name, sd->sd_meta->ssd_devname); 
d4364 1
a4364 1
	else 
@


1.352
log
@Make softraid(4) compile with SR_DEBUG by fixing __kprintf__ specifiers.

ok jsing krw
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.351 2015/04/11 17:10:17 jsing Exp $ */
d4341 1
a4341 1
	int			new_state, i, s, nd;
d4343 1
@


1.351
log
@Directly handle ioctls issued to a SCSI device associated with a softraid
volume, ignoring any device name specified in the bio(4) ioctl struct.

One of bio(4)'s design flaws is that the device name is hardcoded in many
of the ioctl structs, making it basically unusable with DUIDs. In the case
of `bioctl -d' the bioctl(8) code actually uses opendev(3) on the given
name, then issues the ioctl directly to the resulting device. As such, we
already know which device (or in this case, softraid volume) the ioctl was
intended for, however the current softraid(4) code ignores this and instead
attempts to perform a lookup using the name in the bio(4) ioctl struct.

This diff splits the sr_bio_ioctl() code into two parts - one that implements
the API required by bio(4) and the other that contains the ioctl handling
code, which now takes an optional pointer to the softraid discipline. If an
ioctl is issued to a SCSI device associated with a softraid volume, pass
the corresponding softraid discipline struct through and to the bio ioctl
handler and use it in preference to performing a device name lookup.

Amongst other things, this makes bioctl -d now work with DUIDs.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.350 2015/03/14 03:38:46 jsg Exp $ */
d232 1
a232 1
	DNPRINTF(SR_D_META, "%s: sr_meta_attach(%d)\n", DEVNAME(sc));
d411 1
a411 1
	DNPRINTF(SR_D_MISC, "%s: sr_rw(0x%x, %p, %zu, %lld 0x%x)\n",
d423 1
a423 1
		DNPRINTF(SR_D_MISC, "%s: dma_buf %p, size %d, offset %llu)\n",
d481 1
a481 1
	DNPRINTF(SR_D_META, "%s: sr_meta_rw(0x%x, %p, %zu, %lld 0x%x)\n",
d517 1
a517 1
			    "clear %s\n", ch_entry->src_devname);
d1895 1
a1895 1
	DNPRINTF(SR_D_MISC, "sr_minphys: %d\n", bp->b_bcount);
d2045 1
a2045 1
	    "b_bcount %d b_blkno %lld b_flags 0x%0x b_data %p\n",
d2061 2
a2062 2
	DNPRINTF(SR_D_INTR, "%s: %s %s ccb done b_bcount %d b_resid %d"
	    " b_flags 0x%0x block %lld target %d\n",
d2477 1
a2477 1
	DNPRINTF(SR_D_IOCTL, "%s: %s sr_scsi_ioctl cmd: %#x\n",
d2496 1
d2499 1
a2499 2
	return sr_bio_handler((struct sr_softc *)dev, NULL, cmd,
	    (struct bio *)addr);
d3726 4
a3729 5
	    "%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\n",
	    sbm->sbm_root_duid[0], sbm->sbm_root_duid[1],
	    sbm->sbm_root_duid[2], sbm->sbm_root_duid[3],
	    sbm->sbm_root_duid[4], sbm->sbm_root_duid[5],
	    sbm->sbm_root_duid[6], sbm->sbm_root_duid[7]);
@


1.350
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.349 2015/02/09 03:15:41 dlg Exp $ */
d102 2
d112 1
a112 1
			    struct bioc_deleteraid *);
d114 1
a114 1
			    struct bioc_discipline *);
d116 1
a116 1
			    struct bioc_installboot *);
d2470 6
a2475 2
	DNPRINTF(SR_D_IOCTL, "%s: sr_scsi_ioctl cmd: %#x\n",
	    DEVNAME((struct sr_softc *)link->adapter_softc), cmd);
d2477 4
a2480 1
	/* Pass bio ioctls through to bio handler. */
d2482 1
a2482 1
		return (sr_bio_ioctl(link->adapter_softc, cmd, addr));
d2496 10
a2505 2
	struct sr_softc		*sc = (struct sr_softc *)dev;
	struct bio		*bio = (struct bio *)addr;
d2508 1
a2508 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_bio_ioctl ", DEVNAME(sc));
d2517 1
a2517 1
		rv = sr_ioctl_inq(sc, (struct bioc_inq *)addr);
d2522 1
a2522 1
		rv = sr_ioctl_vol(sc, (struct bioc_vol *)addr);
d2527 1
a2527 1
		rv = sr_ioctl_disk(sc, (struct bioc_disk *)addr);
d2532 1
a2532 1
		/*rv = sr_ioctl_alarm(sc, (struct bioc_alarm *)addr); */
d2537 1
a2537 1
		/*rv = sr_ioctl_blink(sc, (struct bioc_blink *)addr); */
d2542 1
a2542 1
		rv = sr_ioctl_setstate(sc, (struct bioc_setstate *)addr);
d2547 1
a2547 1
		rv = sr_ioctl_createraid(sc, (struct bioc_createraid *)addr,
d2553 1
a2553 1
		rv = sr_ioctl_deleteraid(sc, (struct bioc_deleteraid *)addr);
d2558 1
a2558 1
		rv = sr_ioctl_discipline(sc, (struct bioc_discipline *)addr);
d2563 2
a2564 1
		rv = sr_ioctl_installboot(sc, (struct bioc_installboot *)addr);
d3513 3
d3580 2
a3581 1
sr_ioctl_deleteraid(struct sr_softc *sc, struct bioc_deleteraid *bd)
a3582 1
	struct sr_discipline	*sd;
a3587 5
	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		if (!strncmp(sd->sd_meta->ssd_devname, bd->bd_dev,
		    sizeof(sd->sd_meta->ssd_devname)))
			break;
	}
d3589 9
a3597 2
		sr_error(sc, "volume %s not found", bd->bd_dev);
		goto bad;
d3610 2
a3611 1
sr_ioctl_discipline(struct sr_softc *sc, struct bioc_discipline *bd)
a3612 1
	struct sr_discipline	*sd;
a3619 5
	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		if (!strncmp(sd->sd_meta->ssd_devname, bd->bd_dev,
		    sizeof(sd->sd_meta->ssd_devname)))
			break;
	}
d3621 9
a3629 2
		sr_error(sc, "volume %s not found", bd->bd_dev);
		goto bad;
d3640 2
a3641 1
sr_ioctl_installboot(struct sr_softc *sc, struct bioc_installboot *bb)
a3643 1
	struct sr_discipline	*sd;
a3655 5
	TAILQ_FOREACH(sd, &sc->sc_dis_list, sd_link) {
		if (!strncmp(sd->sd_meta->ssd_devname, bb->bb_dev,
		    sizeof(sd->sd_meta->ssd_devname)))
			break;
	}
d3657 9
a3665 2
		sr_error(sc, "volume %s not found", bb->bb_dev);
		goto done;
@


1.349
log
@we want to defer work traditionally (in openbsd) handled in an
interrupt context to a taskq running in a thread. however, there
is a concern that if we do that then we allow accidental use of
sleeping APIs in this work, which will make it harder to move the
work back to interrupts in the future.

guenther and kettenis came up with the idea of marking a proc with
CANTSLEEP which the sleep paths can check and panic on.

this builds on that so you create taskqs that run with CANTSLEEP
set except when they need to sleep for more tasks to run.

the taskq_create api is changed to take a flags argument so users
can specify CANTSLEEP. MPSAFE is also passed via this flags field
now.  this means archs that defined IPL_MPSAFE to 0 can now create
mpsafe taskqs too.

lots of discussion at s2k15
ok guenther@@ miod@@ mpi@@ tedu@@ pelikan@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.348 2015/01/27 03:17:35 dlg Exp $ */
a44 2

#include <crypto/cryptodev.h>
@


1.348
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.347 2014/12/19 17:15:16 tedu Exp $ */
d3300 1
a3300 1
	sd->sd_taskq = taskq_create("srdis", 1, IPL_BIO);
@


1.347
log
@bcopy to memcpy. ok deraadt millert
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.346 2014/12/16 19:51:33 tedu Exp $ */
d145 1
a145 1
void			sr_wu_done_callback(void *, void *);
d615 1
a615 1
sr_meta_save_callback(void *arg1, void *arg2)
d617 1
a617 1
	struct sr_discipline	*sd = arg1;
d622 1
a622 1
	if (sr_meta_save(arg1, SR_META_DIRTY))
a2115 1
		task_set(&wu->swu_task, sr_wu_done_callback, sd, wu);
d2117 1
d2247 1
a2247 1
sr_wu_done_callback(void *arg1, void *arg2)
d2249 2
a2250 2
	struct sr_discipline	*sd = (struct sr_discipline *)arg1;
	struct sr_workunit	*wu = (struct sr_workunit *)arg2;
d2978 1
a2978 1
sr_hotspare_rebuild_callback(void *arg1, void *arg2)
d2980 2
a2981 1
	sr_hotspare_rebuild((struct sr_discipline *)arg1);
d3924 1
a3924 1
	task_set(&sd->sd_meta_save_task, sr_meta_save_callback, sd, NULL);
d3926 1
a3926 1
	    sd, NULL);
@


1.346
log
@only need lock.h here, not all of uvm_extern.h
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.345 2014/12/16 18:30:03 tedu Exp $ */
d428 1
a428 1
			bcopy(buf, dma_buf, bufsize);
d457 1
a457 1
			bcopy(dma_buf, buf, bufsize);
d570 1
a570 1
		bcopy(&sm->ssdi.ssd_uuid, &scm->scmi.scm_uuid,
d663 1
a663 1
	bcopy(sm, m, sizeof(*m));
d669 1
a669 1
		bcopy(&src->src_meta, cm, sizeof(*cm));
d682 1
a682 1
		bcopy(omi->omi_som, omh, omi->omi_som->som_length);
d790 1
a790 1
			bcopy(sm, sd->sd_meta, sizeof(*sd->sd_meta));
d794 1
a794 1
		bcopy(cp, &ch_entry->src_meta, sizeof(ch_entry->src_meta));
d860 2
a861 2
			bcopy((u_int8_t *)omh + SR_OLD_META_OPT_OFFSET,
			    (u_int8_t *)omi->omi_som + sizeof(*omi->omi_som),
d876 1
a876 1
			bcopy(omh, omi->omi_som, omh->som_length);
d879 1
a879 1
			bcopy(&omi->omi_som->som_checksum, &checksum,
d1118 1
a1118 1
			bcopy(md, bc->sbc_metadata, sizeof(struct sr_metadata));
d1238 1
a1238 1
			bcopy(&bc->sbc_metadata->ssdi.ssd_uuid, &bv->sbv_uuid,
d1339 1
a1339 1
		bcopy(&bc->sbc_metadata->ssdi.ssd_uuid, &hm->scmi.scm_uuid,
d1528 1
a1528 1
					bcopy(sbm->sbm_root_duid, rootduid,
d1567 1
a1567 1
	bcopy(label.d_uid, ch_entry->src_duid, sizeof(ch_entry->src_duid));
d1640 1
a1640 1
				bcopy(&md->ssdi.ssd_uuid, &uuid, sizeof uuid);
d1913 1
a1913 1
		bcopy(v, xs->data, copy_cnt);
d2437 1
a2437 1
		bcopy(&sd->sd_scsi_sense, &xs->sense, sizeof(xs->sense));
d2558 1
a2558 1
	bcopy(&sc->sc_status, &bio->bio_status, sizeof(struct bio_status));
d2892 1
a2892 1
	bcopy(&uuid, &hm->scmi.scm_uuid, sizeof(struct sr_uuid));
d2908 1
a2908 1
	bcopy(&uuid, &sm->ssdi.ssd_uuid, sizeof(struct sr_uuid));
d3197 1
a3197 1
	bcopy(label.d_uid, chunk->src_duid, sizeof(chunk->src_duid));
d3209 1
a3209 1
	bcopy(&sd->sd_meta->ssdi.ssd_uuid, &meta->scmi.scm_uuid,
d3293 1
a3293 1
		bcopy(bc->bc_dev_list, dt, bc->bc_dev_list_len);
d3652 1
a3652 1
	bcopy(dk->dk_label->d_uid, duid, sizeof(duid));
d3694 1
a3694 1
	bcopy(duid, sbm->sbm_root_duid, sizeof(sbm->sbm_root_duid));
d3715 1
a3715 1
			bcopy(chunk->src_duid, &sbm->sbm_boot_duid[i],
d4060 1
a4060 1
	bcopy(&sd->sd_scsi_sense, &xs->sense, sizeof(xs->sense));
d5086 1
a5086 1
		bcopy(((char *)addr) + i, my->buf, DEV_BSIZE);
d5089 1
a5089 1
		bcopy(&key_blkno, &iv, sizeof(key_blkno));
@


1.345
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.344 2014/11/18 02:37:30 tedu Exp $ */
d36 1
a44 2

#include <uvm/uvm_extern.h>
@


1.344
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.343 2014/10/30 19:07:54 tedu Exp $ */
d44 2
@


1.343
log
@muliply to get correct size for free. reported by kspillner
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.342 2014/10/30 17:23:45 tedu Exp $ */
a51 1
#include <dev/rndvar.h>
@


1.342
log
@add some sizes to free()
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.341 2014/10/07 20:23:32 tedu Exp $ */
d1493 1
a1493 1
	free(devs, M_DEVBUF, BIOC_CRMAXLEN);
@


1.341
log
@remove preliminary AOE (ata over ethernet) support. not finished after
many years and wide spread demand for support never materialized.
time to pack it in.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.340 2014/09/14 14:17:24 jsg Exp $ */
d526 1
a526 1
	free(m, M_DEVBUF, 0);
d729 1
a729 1
	free(m, M_DEVBUF, 0);
d800 2
a801 3
	free(sm, M_DEVBUF, 0);
	if (fm)
		free(fm, M_DEVBUF, 0);
d1130 2
a1131 4
	if (fake_sd)
		free(fake_sd, M_DEVBUF, 0);
	if (md)
		free(md, M_DEVBUF, 0);
d1493 2
a1494 4
	if (devs)
		free(devs, M_DEVBUF, 0);
	if (ondisk)
		free(ondisk, M_DEVBUF, 0);
d1690 1
a1690 2
	if (md)
		free(md, M_DEVBUF, 0);
d4445 1
a4445 1
	free(uuidstr, M_DEVBUF, 0);
@


1.340
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.339 2014/09/13 16:06:37 doug Exp $ */
a44 5
#ifdef AOE
#include <sys/mbuf.h>
#include <net/if_aoe.h>
#endif /* AOE */

a3945 10
#ifdef AOE
	/* AOE target. */
	case 'A':
		sr_aoe_server_discipline_init(sd);
		break;
	/* AOE initiator. */
	case 'a':
		sr_aoe_discipline_init(sd);
		break;
#endif
@


1.339
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.338 2014/08/01 01:32:09 jsing Exp $ */
a26 1
#include <sys/proc.h>
@


1.338
log
@When attempting to rebuild a softraid volume, use the actual data offset
from the volume metadata rather than the currently defined data offset.
This allows rebuilds to work correctly when the volume metadata has a
different data offset to that currently in use (for example, volumes
created prior to softraid gaining boot support).

Found the hard way by henning@@

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.337 2014/07/20 18:10:15 deraadt Exp $ */
d1173 1
a1173 1
	while (dk != TAILQ_END(&disklist)) {
d1215 1
a1215 1
	for (bc = SLIST_FIRST(&bch); bc != SLIST_END(&bch); bc = bcnext) {
d1470 1
a1470 1
	for (bv1 = SLIST_FIRST(&bvh); bv1 != SLIST_END(&bvh); bv1 = bv2) {
d1472 2
a1473 2
		for (bc1 = SLIST_FIRST(&bv1->sbv_chunks);
		    bc1 != SLIST_END(&bv1->sbv_chunks); bc1 = bc2) {
d1482 1
a1482 1
	for (bc1 = SLIST_FIRST(&kdh); bc1 != SLIST_END(&kdh); bc1 = bc2) {
d1489 1
a1489 1
	for (bc1 = SLIST_FIRST(&bch); bc1 != SLIST_END(&bch); bc1 = bc2) {
d1678 1
a1678 1
		for (ch_entry = SLIST_FIRST(cl); ch_entry != SLIST_END(cl);
d3785 1
a3785 2
	for (ch_entry = SLIST_FIRST(cl);
	    ch_entry != SLIST_END(cl); ch_entry = ch_next) {
d3833 1
a3833 1
	for (omi = SLIST_FIRST(som); omi != SLIST_END(som); omi = omi_next) {
@


1.337
log
@spacing glitches
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.336 2014/07/20 18:05:21 mlarkin Exp $ */
d3186 1
a3186 1
	    SR_DATA_OFFSET;
@


1.336
log
@
Support hibernating to softraid crypto volumes.

much help and ok from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.335 2014/07/13 23:10:23 deraadt Exp $ */
d5007 1
a5007 1
		dev_t subdev;		/* underlying device dev_t */	
d5072 1
a5072 1
			DL_GETPOFFSET(&dl.d_partitions[DISKPART(my->subdev)]);
d5128 1
a5128 2
	}		

@


1.335
log
@Some reallocarray() use; review Jean-Philippe Ouellet, patrick keshishian
ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.334 2014/07/12 18:48:51 tedu Exp $ */
d60 6
d4977 156
@


1.334
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.333 2014/07/12 07:39:11 blambert Exp $ */
d255 1
a255 1
	sd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *) * chunk_no,
d1287 1
a1287 1
	devs = malloc(BIOC_CRMAXLEN * sizeof(dev_t), M_DEVBUF,
d1293 1
a1293 1
	ondisk = malloc(BIOC_CRMAXLEN * sizeof(u_int64_t), M_DEVBUF,
d1937 3
a1939 2
	sd->sd_ccb = malloc(sizeof(struct sr_ccb) *
	    sd->sd_max_wu * sd->sd_max_ccb_per_wu, M_DEVBUF, M_WAITOK | M_ZERO);
@


1.333
log
@essentially mechanical conversion of softraid rebuild from
workq to taskq

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.332 2014/07/10 12:21:09 mpi Exp $ */
d526 1
a526 1
	free(m, M_DEVBUF);
d729 1
a729 1
	free(m, M_DEVBUF);
d800 1
a800 1
	free(sm, M_DEVBUF);
d802 1
a802 1
		free(fm, M_DEVBUF);
d1132 1
a1132 1
		free(fake_sd, M_DEVBUF);
d1134 1
a1134 1
		free(md, M_DEVBUF);
d1470 2
a1471 2
				free(bc1->sbc_metadata, M_DEVBUF);
			free(bc1, M_DEVBUF);
d1473 1
a1473 1
		free(bv1, M_DEVBUF);
d1479 2
a1480 2
			free(bc1->sbc_metadata, M_DEVBUF);
		free(bc1, M_DEVBUF);
d1486 2
a1487 2
			free(bc1->sbc_metadata, M_DEVBUF);
		free(bc1, M_DEVBUF);
d1493 1
a1493 1
		free(sdk, M_DEVBUF);
d1497 1
a1497 1
		free(devs, M_DEVBUF);
d1499 1
a1499 1
		free(ondisk, M_DEVBUF);
d1696 1
a1696 1
		free(md, M_DEVBUF);
d1761 1
a1761 1
			free(mhe, M_DEVBUF);
d1966 1
a1966 1
		free(sd->sd_ccb, M_DEVBUF);
d2145 1
a2145 1
		free(wu, M_DEVBUF);
d2965 1
a2965 1
		free(hotspare, M_DEVBUF);
d2969 1
a2969 1
		free(sd->sd_vol.sv_chunks, M_DEVBUF);
d2971 1
a2971 1
		free(sd, M_DEVBUF);
d2973 1
a2973 1
		free(sm, M_DEVBUF);
d3079 1
a3079 1
			free(hotspare, M_DEVBUF);
d3345 1
a3345 1
				free(uuid, M_DEVBUF);
d3402 1
a3402 1
			free(uuid, M_DEVBUF);
d3761 1
a3761 1
		free(bootblk, M_DEVBUF);
d3763 1
a3763 1
		free(bootldr, M_DEVBUF);
d3796 1
a3796 1
		free(ch_entry, M_DEVBUF);
d3820 1
a3820 1
		free(sd->sd_vol.sv_chunks, M_DEVBUF);
d3822 1
a3822 1
		free(sd->sd_meta, M_DEVBUF);
d3824 1
a3824 1
		free(sd->sd_meta_foreign, M_DEVBUF);
d3830 2
a3831 2
			free(omi->omi_som, M_DEVBUF);
		free(omi, M_DEVBUF);
d3847 1
a3847 1
	free(sd, M_DEVBUF);
d4461 1
a4461 1
	free(uuidstr, M_DEVBUF);
@


1.332
log
@Stop using a shutdown hook for softraid(4) and explicitly shutdown
the disciplines right after vfs_shutdown().

This change is required in order to be able to set `cold' to 1 before
traversing the device (mainbus) tree for DVACT_POWERDOWN when halting
a machine.  Yes, this is ugly because sr_shutdown() needs to sleep.  But
at least it is obvious and hopefully somebody will be ofended and fix
it.

In order to properly flush the cache of the disks under softraid0,
sr_shutdown() now propagates DVACT_POWERDOWN for this particular subtree
of devices which are not under mainbus.  As a side effect sd(4) shutdown
hook should no longer be necessary.

Tested by stsp@@ and Jean-Philippe Ouellet.

ok deraadt@@, stsp@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.331 2014/01/22 23:32:42 jsing Exp $ */
d3930 2
@


1.331
log
@Add some debug messages to the rebuild process and fix a bogus comment.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.330 2014/01/22 09:42:13 jsing Exp $ */
d128 1
a128 2
void			sr_shutdown(struct sr_softc *);
void			sr_shutdownhook(void *);
a1828 2
	sc->sc_shutdownhook = shutdownhook_establish(sr_shutdownhook, sc);

a1841 3
	if (sc->sc_shutdownhook)
		shutdownhook_disestablish(sc->sc_shutdownhook);

d1844 1
a1844 1
	sr_shutdown(sc);
d4500 1
a4500 7
sr_shutdownhook(void *arg)
{
	sr_shutdown((struct sr_softc *)arg);
}

void
sr_shutdown(struct sr_softc *sc)
d4502 1
d4506 7
@


1.330
log
@Add a debug flag for rebuild.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.329 2014/01/22 09:03:19 jsing Exp $ */
d4589 3
d4603 3
d4669 3
d4724 3
d4730 1
a4730 1
		/* wait for read completion */
d4766 1
a4766 1
	for (c = 0; c < sd->sd_meta->ssdi.ssd_chunk_no; c++)
d4772 1
@


1.329
log
@Make rebuild a discipline specific function pointer. For now, this defaults
to the existing rebuild code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.328 2014/01/22 05:42:39 jsing Exp $ */
d74 1
@


1.328
log
@The sr_rebuild function does not actually do the rebuild, it only starts
the rebuild thread. Rename it to sr_rebuild_start to make this clearer.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.327 2014/01/22 05:11:36 jsing Exp $ */
d140 1
d3919 1
d4598 11
a4646 2
	sd->sd_reb_active = 1;

a4765 2
	sd->sd_reb_active = 0;
	kthread_exit(0);
@


1.327
log
@Move sr_dump from the RAID5 code into shared code. Rename it to
sr_dump_block and place it under the debug define in the process.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.326 2014/01/22 04:24:29 jsing Exp $ */
d138 1
a138 1
void			sr_rebuild(void *);
d3235 1
a3235 1
	kthread_create_deferred(sr_rebuild, sd);
d3553 1
a3553 1
		kthread_create_deferred(sr_rebuild, sd);
d4581 1
a4581 1
sr_rebuild(void *arg)
@


1.326
log
@Switch metadata saves from the system workq to the system taskq.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.325 2014/01/21 06:42:52 jsing Exp $ */
d4915 20
@


1.325
log
@Actually use the correct TAILQ field.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.324 2014/01/21 04:23:14 jsing Exp $ */
a42 1
#include <sys/workq.h>
d3932 2
d4324 1
a4324 1
	workq_add_task(NULL, 0, sr_meta_save_callback, sd, NULL);
@


1.324
log
@Allow for variable sized work units.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.323 2014/01/21 03:50:44 jsing Exp $ */
d2149 1
a2149 1
		TAILQ_REMOVE(&sd->sd_wu, wu, swu_link);
@


1.323
log
@Use a TAILQ for tracking work units, rather than an array. This will allow
for variable size work units. While here, remove some pointless checks.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.322 2014/01/21 03:27:38 jsing Exp $ */
d2105 1
a2105 1
sr_wu_alloc(struct sr_discipline *sd)
d2123 1
a2123 2
		wu = malloc(sizeof(struct sr_workunit),
		    M_DEVBUF, M_WAITOK | M_ZERO);
d4261 1
a4261 1
	if (sr_wu_alloc(sd)) {
@


1.322
log
@Stop bzeroing the work unit when it is initialised. Rather, only initialise
the specific fields that are either not persistent for the life of the
workunit and/or not reinitialised in sr_wu_release_ccbs. This is also
necessary for upcoming changes.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.321 2014/01/20 04:47:31 jsing Exp $ */
a2109 3
	if (!sd)
		return (1);

a2112 3
	if (sd->sd_wu)
		return (1);

a2115 2
	sd->sd_wu = malloc(sizeof(struct sr_workunit) * no_wu,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d2117 1
d2121 1
d2123 3
a2125 1
		wu = &sd->sd_wu[i];
a2139 3
	if (!sd)
		return;

d2149 4
a2152 2
	if (sd->sd_wu)
		free(sd->sd_wu, M_DEVBUF);
@


1.321
log
@Convert the softraid work unit workqs to taskqs.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.320 2014/01/20 00:11:50 jsing Exp $ */
d2131 2
d2206 6
a2211 4
	bzero(wu, sizeof(*wu));
	TAILQ_INIT(&wu->swu_ccb);
	task_set(&wu->swu_task, sr_wu_done_callback, sd, wu);
	wu->swu_dis = sd;
@


1.320
log
@Replace dedicated swu_fake variable with a work unit flag.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.319 2014/01/19 22:21:39 jsing Exp $ */
d42 1
d2206 1
d2255 1
a2255 2
	workq_queue_task(sd->sd_workq, &wu->swu_wqt, 0,
	    sr_wu_done_callback, sd, wu);
d3311 3
a3313 3
	sd->sd_workq = workq_create("srdis", 1, IPL_BIO);
	if (sd->sd_workq == NULL) {
		sr_error(sc, "could not create discipline workq");
d3900 2
a3901 2
	if (sd->sd_workq)
		workq_destroy(sd->sd_workq);
@


1.319
log
@Assert that a workunit has ccbs if it is being scheduled. Otherwise we
deadlock since nothing will ever come back to tell us that the workunit
is completed.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.318 2014/01/18 09:33:53 jsing Exp $ */
d724 1
a724 1
		wu.swu_fake = 1;
d4113 1
a4113 1
	ios = wu->swu_fake ? 0 : 1;
@


1.318
log
@Move the block get/put routines into the common code, instead of having
RAID 6 borrow them from RAID 5.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.317 2014/01/18 09:23:26 jsing Exp $ */
d4162 2
@


1.317
log
@Rename softraid RAIDP to softraid RAID5.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.316 2014/01/18 09:01:01 jsing Exp $ */
d4383 12
@


1.316
log
@Remove the RAID 4 discipline from softraid. Anyone sensible would use RAID
5 instead of RAID 4, assuming both were functional.

Discussed with krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.315 2014/01/05 15:03:57 jsing Exp $ */
d3942 1
a3942 1
		sr_raidp_discipline_init(sd, SR_MD_RAID5);
@


1.315
log
@On some architectures you can get away with using an uninitialised mutex;
this is not the case on hppa (practically the only architecture where
unlocked has a non-zero value). This one has been hiding since r1.223...

Found the hard way by juanfra@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.314 2013/11/19 15:12:13 krw Exp $ */
a3939 3
		break;
	case 4:
		sr_raidp_discipline_init(sd, SR_MD_RAID4);
@


1.314
log
@Print daddr_t's with %lld, size_t's with %zu, int's with %d and
u_int32_t's with %u.

Translate DL_GETPSIZE() results to 512-byte-block values with
DL_SECTOBLK().

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.313 2013/11/04 21:02:57 deraadt Exp $ */
d2123 1
a3469 1
		mtx_init(&sd->sd_wu_mtx, IPL_BIO);
@


1.313
log
@substantial namespace cleanup.  Might go a little bit too far, but we
can expose some of the kernel structures with split .h files if need be.
Discussed with various, including jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.312 2013/11/01 17:36:19 krw Exp $ */
d410 2
a411 2
	DNPRINTF(SR_D_MISC, "%s: sr_rw(0x%x, %p, %d, %llu 0x%x)\n",
	    DEVNAME(sc), dev, buf, size, offset, flags);
d480 2
a481 2
	DNPRINTF(SR_D_META, "%s: sr_meta_rw(0x%x, %p, %d, %llu 0x%x)\n",
	    DEVNAME(sd->sd_sc), dev, md, size, offset, flags);
d1575 1
a1575 1
		sr_error(sc, "%s has unsupported sector size (%d)",
d1589 2
a1590 1
	size = DL_GETPSIZE(&label.d_partitions[part]) - SR_DATA_OFFSET;
d1598 2
a1599 2
	DNPRINTF(SR_D_META, "%s: probe found %s size %d\n", DEVNAME(sc),
	    devname, size);
d1918 1
a1918 1
	DNPRINTF(SR_D_MISC, "sr_copy_internal_data xs: %p size: %d\n",
d2870 1
a2870 1
		sr_error(sc, "%s has unsupported sector size (%d)",
d2881 2
a2882 1
	size = DL_GETPSIZE(&label.d_partitions[part]) - SR_DATA_OFFSET;
d3172 1
a3172 1
		sr_error(sc, "%s has unsupported sector size (%d)",
d3183 2
a3184 1
	size = DL_GETPSIZE(&label.d_partitions[part]) - SR_DATA_OFFSET;
d3186 2
a3187 2
		sr_error(sc, "%s partition too small, at least %llu bytes "
		    "required", devname, csize << DEV_BSHIFT);
d3190 2
a3191 2
		sr_warn(sc, "%s partition too large, wasting %llu bytes",
		    devname, (size - csize) << DEV_BSHIFT);
@


1.312
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.311 2013/07/19 17:14:13 krw Exp $ */
d36 1
@


1.311
log
@Don't use uninitialized variable when a simple 0 will do.

Found by Maxime Villard.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.310 2013/07/01 11:33:21 jsing Exp $ */
d2054 1
a2054 1
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
d2072 1
a2072 1
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);
d2081 2
a2082 1
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
d2088 3
a2090 2
			    "b_error %d\n", DEVNAME(sc), ccb->ccb_buf.b_blkno,
			    ccb->ccb_target, ccb->ccb_buf.b_error);
d4548 2
a4549 2
		    DEVNAME(sd->sd_sc), func, wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);
@


1.310
log
@When an I/O error occurs on a softraid chunk, only take it offline if the
discipline supports redundancy. In the non-redundant case, there is little
to gain my failing the chunk, in fact it just makes any form of data
recovery significantly harder.

ok krw@@ todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.309 2013/06/11 16:42:13 deraadt Exp $ */
d1861 1
a1861 1
	return (rv);
@


1.309
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.308 2013/05/21 15:21:16 jsing Exp $ */
d2082 4
a2085 1
		if (!ISSET(sd->sd_capabilities, SR_CAP_REDUNDANT))
a2089 1
		sd->sd_set_chunk_state(sd, ccb->ccb_target, BIOC_SDOFFLINE);
@


1.308
log
@Ensure that sc_lock is held when calling sr_meta_native_bootprobe() - the
softraid status functions will complain otherwise.

Found the hard way by ajacoutot@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.307 2013/05/21 15:15:43 jsing Exp $ */
d142 1
a142 1
			    daddr64_t, long);
d156 1
a156 1
			    size_t, daddr64_t, long);
d202 1
a202 1
	daddr64_t		smd_offset;	/* metadata location */
d400 1
a400 1
sr_rw(struct sr_softc *sc, dev_t dev, char *buf, size_t size, daddr64_t offset,
d475 1
a475 1
    daddr64_t offset, long flags)
d1554 1
a1554 1
	daddr64_t		size;
d2015 2
a2016 2
sr_ccb_rw(struct sr_discipline *sd, int chunk, daddr64_t blkno,
    daddr64_t len, u_int8_t *data, int xsflags, int ccbflags)
d2593 1
a2593 1
	daddr64_t		rb, sz;
d2817 1
a2817 1
	daddr64_t		size;
d3095 1
a3095 1
	daddr64_t		size, csize;
d4010 1
a4010 1
	daddr64_t		addr;
d4502 1
a4502 1
sr_validate_io(struct sr_workunit *wu, daddr64_t *blk, char *func)
d4578 2
a4579 2
	daddr64_t		whole_blk, partial_blk, blk, sz, lba;
	daddr64_t		psz, rb, restart;
@


1.307
log
@sr_raid_startwu() is no longer called from interrupt context, hence does
not need to invoke a workq-based callback.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.306 2013/05/21 15:01:52 jsing Exp $ */
d1193 2
d1196 1
d1230 2
a1231 1
				sr_error(sc, "failed to allocate boot volume");
@


1.306
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.302 2013/04/26 15:45:35 jsing Exp $ */
a140 1
void			sr_startwu_callback(void *, void *);
d4198 1
a4198 1
sr_startwu_callback(void *arg1, void *arg2)
d4200 1
a4200 2
	struct sr_discipline	*sd = arg1;
	struct sr_workunit	*wu = arg2;
a4201 13
	int			s;

	s = splbio();
	if (wu->swu_cb_active == 1)
		panic("%s: sr_startwu_callback", DEVNAME(sd->sd_sc));
	wu->swu_cb_active = 1;

	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link)
		VOP_STRATEGY(&ccb->ccb_buf);

	wu->swu_cb_active = 0;
	splx(s);
}
d4203 1
a4203 4
void
sr_raid_startwu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
d4215 9
a4223 3
	/* start all individual ios */
	workq_queue_task(sd->sd_workq, &wu->swu_wqt, 0, sr_startwu_callback,
	    sd, wu);
@


1.305
log
@Make the sr_raid_startwu() function handle deferred work units, instead of
the caller having to handle the state changes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.304 2013/05/21 14:30:00 jsing Exp $ */
d2350 2
a2351 2
	DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: target %d xs: %p "
	    "flags: %#x\n", DEVNAME(sc), link->target, xs, xs->flags);
d4146 53
a4568 32
int
sr_check_io_collision(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup;

	splassert(IPL_BIO);

	/* walk queue backwards and fill in collider if we have one */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		goto queued;
	}

	return (0);
queued:
	return (1);
}

d4690 1
a4690 4

		/* schedule io */
		if (sr_check_io_collision(wu_r))
			goto queued;
d4693 1
a4693 3
		sr_raid_startwu(wu_r);
queued:
		splx(s);
@


1.304
log
@Fix missing work unit state initialisations.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.303 2013/05/21 14:25:23 jsing Exp $ */
a2290 2
		wu->swu_collider->swu_state = SR_WU_INPROGRESS;
		TAILQ_REMOVE(&sd->sd_wu_defq, wu->swu_collider, swu_link);
d4172 6
a4177 8
	if (wu->swu_state == SR_WU_RESTART)
		/*
		 * no need to put the wu on the pending queue since we
		 * are restarting the io
		 */
		 ;
	else
		/* move wu to pending queue */
@


1.303
log
@Use a state to indicate that a work unit should only be constructed and not
scheduled, rather than trying to imply this from the rebuild flag.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.302 2013/04/26 15:45:35 jsing Exp $ */
d4678 1
@


1.302
log
@Add a SR_WUF_DISCIPLINE flag that identifies work units that have resulted
from discipline specific I/O. Such work units are not associated with a
SCSI xfer and are returned via sr_wu_put() on completion.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.301 2013/04/23 12:49:52 jsing Exp $ */
d4635 1
d4656 1
@


1.301
log
@Rename ccb_flag to ccb_flags.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.300 2013/04/21 13:00:21 jsing Exp $ */
d2256 7
d2265 6
a2270 4
	if (wu->swu_ios_failed)
		xs->error = XS_DRIVER_STUFFUP;
	else
		xs->error = XS_NOERROR;
d2306 2
@


1.300
log
@Convert RAID1 to the new work unit completion functions and generic
interrupt handler. Disciplines such as RAID1/4/5/6 need a way to intercept
I/O when the work unit is complete, but before the SCSI xfer is complete.
This is provided via a sd_scsi_wu_done hook, which enables work units to be
restarted or otherwise modified before the SCSI xfer completion occurs.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.299 2013/03/31 15:46:11 jsing Exp $ */
d2013 1
a2013 1
    daddr64_t len, u_int8_t *data, int xsflags, int ccbflag)
d2022 1
a2022 1
	ccb->ccb_flag = ccbflag;
@


1.299
log
@Use the discipline name instead of the product string when reporting the
attachment.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.298 2013/03/31 11:37:40 jsing Exp $ */
d2258 11
a2271 1

a2274 1

d2278 4
a2286 5
	if (wu->swu_ios_failed)
		xs->error = XS_DRIVER_STUFFUP;
	else
		xs->error = XS_NOERROR;

d2291 4
d2297 1
a2297 1
	else
d2300 1
d3908 1
@


1.298
log
@The return value of sd_free_resources() is never checked and all of the
implementations only ever returned zero. Change the return value from
int to void instead of pretending it might mean something.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.297 2013/03/31 11:30:59 jsing Exp $ */
d3498 1
a3498 1
		    sd->sd_meta->ssdi.ssd_product, sd->sd_meta->ssd_devname); 
@


1.297
log
@Fix compilation with debug.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.296 2013/03/31 11:12:06 jsing Exp $ */
d121 1
a121 1
int			sr_free_resources(struct sr_discipline *);
d4201 1
a4201 1
int
a4205 2

	return (0);
@


1.296
log
@Provide default resource allocation and free functions. Convert all
disciplines except for AOE and CRYPTO, which require custom handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.295 2013/03/30 14:41:36 jsing Exp $ */
d3543 2
a3544 2
	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_deleteraid %s\n", DEVNAME(sc),
	    dr->bd_dev);
@


1.295
log
@Provide wrappers for scsi_io_get() and scsi_io_put(), that also include
the sd_sync check/wakeup. Remove some unnecessary NULL checks whilst here.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.294 2013/03/30 02:02:13 jsing Exp $ */
d120 2
d3880 1
a3880 1
	sd->sd_alloc_resources = NULL;
d3883 1
a3883 1
	sd->sd_free_resources = NULL;
d4184 24
@


1.294
log
@Provide a default discipline interrupt handling function and migrate all of
the disciplines that now have the same interrupt code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.293 2013/03/29 12:00:59 jsing Exp $ */
d2289 15
d4571 2
a4572 4
		if ((wu_r = scsi_io_get(&sd->sd_iopool, 0)) == NULL)
			panic("%s: rebuild exhausted wu_r", DEVNAME(sc));
		if ((wu_w = scsi_io_get(&sd->sd_iopool, 0)) == NULL)
			panic("%s: rebuild exhausted wu_w", DEVNAME(sc));
d4641 2
a4642 5
		scsi_io_put(&sd->sd_iopool, wu_r);
		scsi_io_put(&sd->sd_iopool, wu_w);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
d4646 1
@


1.293
log
@Decouple wakeups on work unit completion from the type of I/O being
performed.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.292 2013/03/29 11:46:43 jsing Exp $ */
d3877 1
a3877 1
	sd->sd_scsi_intr = NULL;
d4083 20
@


1.292
log
@sd_wu_pending is only decremented when scsi_done() or scsi_io_put() are
called. As a result, factor out the the sd_sync check/wakeup code and move
it to after the scsi_done() call in sr_scsi_done(). Perform the same
sd_sync check/wakeup after scsi_io_put() calls (including the addition of
some that were previously missed).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.291 2013/03/25 16:01:48 jsing Exp $ */
d4573 1
a4573 1
		wu_w->swu_flags |= SR_WUF_REBUILD;
@


1.291
log
@Factor out the code that is used to recreate work units - one copy of the
code is sufficient.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.290 2013/03/10 09:05:12 jsing Exp $ */
d2281 1
a2281 1
	if (sd->sd_scsi_done) {
d2283 1
a2283 1
	} else {
a2285 5
		/* XXX - move to sr_scsi_done? */
		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

d2298 3
d4069 1
a4069 2

	while (sd->sd_wu_pending > ios)
d4076 1
a4076 1

d4610 3
@


1.290
log
@Rename sc_dis to sc_targets, since it is an array of targets that also
happen to be softraid disciplines.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.289 2013/03/05 10:24:00 jsing Exp $ */
d4128 22
@


1.289
log
@Track attached softraid disciplines via a queue. This prevents the need to
scan the sparse SCSI targets array and simplifies code. Disciplines are
now also shutdown in reverse attach order, making manually stacked softraid
volumes somewhat more practical.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.288 2013/01/18 23:19:44 jsing Exp $ */
d2316 1
a2316 1
	sd = sc->sc_dis[link->target];
d2418 1
a2418 1
	sd = sc->sc_dis[link->target];
d3433 1
a3433 1
		 * discipline is not linked into sc->sc_dis, so begin
d3437 1
a3437 1
			if (sc->sc_dis[target] == NULL)
d3450 1
a3450 1
		sc->sc_dis[target] = sd;
d3453 1
a3453 1
			sc->sc_dis[target] = NULL;
d3465 1
a3465 1
			if (sc->sc_dis[i])
d3793 2
a3794 2
		KASSERT(sc->sc_dis[sd->sd_target] == sd);
		sc->sc_dis[sd->sd_target] = NULL;
@


1.288
log
@The workunit completion needs to run at IPL_BIO, at least for now.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.287 2013/01/18 09:56:52 jsing Exp $ */
d1501 1
d1505 3
a1507 1
	int			i, j;
a1511 1
	DNPRINTF(SR_D_MISC, "%s: sr_map_root\n", DEVNAME(sc));
d1518 2
a1519 4
	for (i = 0; i < SR_MAX_LD; i++) {
		if (sc->sc_dis[i] == NULL)
			continue;
		SLIST_FOREACH(omi, &sc->sc_dis[i]->sd_meta_opt, omi_link) {
d1523 2
a1524 2
			for (j = 0; j < SR_MAX_BOOT_DISKS; j++) {
				if (bcmp(rootduid, sbm->sbm_boot_duid[j],
d1791 1
d2532 2
a2533 1
	int			i, vol, disk;
d2535 4
a2538 6
	for (i = 0, vol = 0, disk = 0; i < SR_MAX_LD; i++)
		/* XXX this will not work when we stagger disciplines */
		if (sc->sc_dis[i]) {
			vol++;
			disk += sc->sc_dis[i]->sd_meta->ssdi.ssd_chunk_no;
		}
d2550 1
a2550 1
	int			i, vol, rv = EINVAL;
d2555 2
a2556 4
	for (i = 0, vol = -1; i < SR_MAX_LD; i++) {
		/* XXX this will not work when we stagger disciplines */
		if (sc->sc_dis[i])
			vol++;
a2559 4
		if (sc->sc_dis[i] == NULL)
			goto done;

		sd = sc->sc_dis[i];
d2613 1
a2613 1
	int			i, vol, rv = EINVAL, id;
d2615 4
d2620 2
a2621 4
	for (i = 0, vol = -1; i < SR_MAX_LD; i++) {
		/* XXX this will not work when we stagger disciplines */
		if (sc->sc_dis[i])
			vol++;
d2625 2
a2626 7
		if (sc->sc_dis[i] == NULL)
			goto done;

		id = bd->bd_diskid;

		if (id < sc->sc_dis[i]->sd_meta->ssdi.ssd_chunk_no)
			src = sc->sc_dis[i]->sd_vol.sv_chunks[id];
d2628 4
a2631 4
		else if (id == sc->sc_dis[i]->sd_meta->ssdi.ssd_chunk_no &&
		    sc->sc_dis[i]->sd_meta->ssdi.ssd_level == 'C' &&
		    sc->sc_dis[i]->mds.mdd_crypto.key_disk != NULL)
			src = sc->sc_dis[i]->mds.mdd_crypto.key_disk;
d2639 1
a2639 1
		bd->bd_target = id;
d2673 2
a2674 2
	int			i, vol, found, c;
	struct sr_discipline	*sd = NULL;
d2686 4
a2689 8
	for (i = 0, vol = -1; i < SR_MAX_LD; i++) {
		/* XXX this will not work when we stagger disciplines */
		if (sc->sc_dis[i])
			vol++;
		if (vol != bs->bs_volid)
			continue;
		sd = sc->sc_dis[i];
		break;
d2742 1
a2742 1
	int			i, c;
d2750 3
a2752 6
	for (i = 0; i < SR_MAX_LD; i++) {
		if (sc->sc_dis[i] == NULL)
			continue;
		sd = sc->sc_dis[i];
		for (c = 0; c < sd->sd_meta->ssdi.ssd_chunk_no; c++) {
			chunk = sd->sd_vol.sv_chunks[c];
d3395 1
d3463 1
d3523 1
a3523 1
sr_ioctl_deleteraid(struct sr_softc *sc, struct bioc_deleteraid *dr)
d3525 1
a3525 1
	struct sr_discipline	*sd = NULL;
a3526 1
	int			i;
d3531 5
a3535 10
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i]) {
			if (!strncmp(sc->sc_dis[i]->sd_meta->ssd_devname,
			    dr->bd_dev,
			    sizeof(sc->sc_dis[i]->sd_meta->ssd_devname))) {
				sd = sc->sc_dis[i];
				break;
			}
		}

d3537 1
a3537 1
		sr_error(sc, "volume %s not found", dr->bd_dev);
d3553 2
a3554 2
	struct sr_discipline	*sd = NULL;
	int			i, rv = 1;
d3561 9
a3569 9
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i]) {
			if (!strncmp(sc->sc_dis[i]->sd_meta->ssd_devname,
			    bd->bd_dev,
			    sizeof(sc->sc_dis[i]->sd_meta->ssd_devname))) {
				sd = sc->sc_dis[i];
				break;
			}
		}
d3571 1
a3571 1
	if (sd && sd->sd_ioctl_handler)
d3574 1
d3582 1
a3582 1
	struct sr_discipline	*sd = NULL;
d3595 7
a3601 11
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i]) {
			if (!strncmp(sc->sc_dis[i]->sd_meta->ssd_devname,
			    bb->bb_dev,
			    sizeof(sc->sc_dis[i]->sd_meta->ssd_devname))) {
				sd = sc->sc_dis[i];
				break;
			}
		}

	if (sd == NULL)
d3603 1
d3763 1
d3797 7
d3854 1
a3854 2
	if (sd)
		sr_discipline_free(sd);
d4306 1
a4306 1
	int			i;
d4308 6
a4313 6
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i])
			if (!bcmp(&sd->sd_meta->ssdi.ssd_uuid,
			    &sc->sc_dis[i]->sd_meta->ssdi.ssd_uuid,
			    sizeof(sd->sd_meta->ssdi.ssd_uuid)))
				return (1);
d4348 1
a4348 1
	int			i;
d4352 3
a4354 4
	/* XXX this will not work when we stagger disciplines */
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i])
			sr_discipline_shutdown(sc->sc_dis[i], 1);
a4675 1
	int			i, vol;
d4679 1
a4679 6
	for (i = 0, vol = -1; i < SR_MAX_LD; i++) {
		/* XXX this will not work when we stagger disciplines */
		if (!sc->sc_dis[i])
			continue;

		sd = sc->sc_dis[i];
d4713 1
a4713 1
	struct sr_softc		*sc;
a4714 1
	int			i, vol;
d4716 1
a4716 8
	for (i = 0; i < softraid_cd.cd_ndevs; i++)
		if (softraid_cd.cd_devs[i]) {
			sc = softraid_cd.cd_devs[i];
			/* we'll only have one softc */
			break;
		}

	if (!sc) {
d4721 2
a4722 7
	for (i = 0, vol = -1; i < SR_MAX_LD; i++) {
		/* XXX this will not work when we stagger disciplines */
		if (!sc->sc_dis[i])
			continue;

		sd = sc->sc_dis[i];
		printf("%s: ios pending: %d  collisions %llu\n",
@


1.287
log
@Tweak workunit completion.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.286 2013/01/18 09:39:03 jsing Exp $ */
d2251 3
d2282 6
a2287 1
		return;
d2290 1
a2290 4
	sr_scsi_done(sd, xs);

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
@


1.286
log
@Implement common workunit completion functions and handle the completion
via a workq callback. Also provide a discipline specific hook that allows
it to optionally handle the final part of the workunit completion.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.285 2013/01/18 01:19:38 jsing Exp $ */
d2233 3
a2235 2
	DNPRINTF(SR_D_INTR, "%s: sr_wu_done completed %d count %d\n",
	    DEVNAME(sd->sd_sc), wu->swu_ios_complete, wu->swu_io_count);
a2251 5
	if (wu->swu_ios_failed)
		xs->error = XS_DRIVER_STUFFUP;
	else
		xs->error = XS_NOERROR;

d2268 5
d2277 1
a2277 1
	if (sd->sd_scsi_done)
d2279 7
a2285 2
	else
		sr_scsi_done(sd, xs);
@


1.285
log
@Reset I/O counters when releasing ccbs.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.284 2013/01/16 07:07:38 jsing Exp $ */
d142 1
d2229 54
d3884 1
@


1.284
log
@Add a function that handles the completion of a ccb.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.283 2013/01/16 06:42:22 jsing Exp $ */
d2220 5
@


1.283
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.282 2013/01/16 06:29:14 jsing Exp $ */
d2052 36
@


1.282
log
@Factor out code used to release ccbs from a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.281 2013/01/15 09:51:22 jsing Exp $ */
d2190 3
@


1.281
log
@Implement a function that gets and correctly initialises a ccb for I/O,
along with a function that enqueues a ccb on a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.280 2013/01/15 04:03:01 jsing Exp $ */
d2079 1
a2079 1
		wu->swu_dis = sd;
d2134 1
a2145 1
	struct sr_ccb		*ccb;
a2150 4
	while ((ccb = TAILQ_FIRST(&wu->swu_ccb)) != NULL) {
		TAILQ_REMOVE(&wu->swu_ccb, ccb, ccb_link);
		sr_ccb_put(ccb);
	}
d2159 1
a2159 1
sr_wu_ccb_enqueue(struct sr_workunit *wu, struct sr_ccb *ccb)
d2166 1
a2166 1
		panic("%s: sr_wu_ccb_enqueue got active wu",
d2175 12
d2218 1
@


1.280
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.279 2013/01/15 03:47:10 jsing Exp $ */
d2007 47
d2150 1
a2150 1
		panic("%s: sr_wu_put got active wu", DEVNAME(sd->sd_sc));
d2160 16
@


1.279
log
@Factor out workunit initialisation code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.278 2012/10/09 11:57:33 jsing Exp $ */
d3712 1
@


1.278
log
@Provide a mechanism for the kernel to directly pass a mask key through to
a crypto volume when it is assembling it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.277 2012/10/08 14:22:41 jsing Exp $ */
d2060 19
d2084 14
a2098 1

a2100 2
	DNPRINTF(SR_D_WU, "%s: sr_wu_put: %p\n", DEVNAME(sd->sd_sc), wu);

a2112 24

	mtx_enter(&sd->sd_wu_mtx);
	TAILQ_INSERT_TAIL(&sd->sd_wu_freeq, wu, swu_link);
	sd->sd_wu_pending--;
	mtx_leave(&sd->sd_wu_mtx);
}

void *
sr_wu_get(void *xsd)
{
	struct sr_discipline	*sd = (struct sr_discipline *)xsd;
	struct sr_workunit	*wu;

	mtx_enter(&sd->sd_wu_mtx);
	wu = TAILQ_FIRST(&sd->sd_wu_freeq);
	if (wu) {
		TAILQ_REMOVE(&sd->sd_wu_freeq, wu, swu_link);
		sd->sd_wu_pending++;
	}
	mtx_leave(&sd->sd_wu_mtx);

	DNPRINTF(SR_D_WU, "%s: sr_wu_get: %p\n", DEVNAME(sd->sd_sc), wu);

	return (wu);
a2125 1
	int			s;
d2128 1
a2128 1
	struct sr_workunit	*wu = NULL;
a2129 1
	struct sr_ccb		*ccb;
a2145 1
	wu = xs->io;
d2147 1
a2147 11
	s = splbio();
	if (wu->swu_cb_active == 1)
		panic("%s: sr_scsi_cmd got active wu", DEVNAME(sd->sd_sc));
	while ((ccb = TAILQ_FIRST(&wu->swu_ccb)) != NULL) {
		TAILQ_REMOVE(&wu->swu_ccb, ccb, ccb_link);
		sr_ccb_put(ccb);
	}
	splx(s);

	bzero(wu, sizeof(*wu));
	TAILQ_INIT(&wu->swu_ccb);
a2148 1
	wu->swu_dis = sd;
@


1.277
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.276 2012/10/08 13:25:46 jsing Exp $ */
d78 1
d1151 1
d1363 1
d1441 4
d1447 1
a1447 1
		sr_ioctl_createraid(sc, &bcr, 0, NULL);
d1822 2
@


1.276
log
@Change handling for volumes that are marked no-auto assemble. If we booted
from the given volume ignore the no-auto assemble flag, since the root
file system is located on it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.275 2012/10/08 13:01:22 jsing Exp $ */
d107 1
a107 1
			    struct bioc_createraid *, int);
d1440 1
a1440 1
		sr_ioctl_createraid(sc, &bcr, 0);
d2312 2
a2313 1
		rv = sr_ioctl_createraid(sc, (struct bioc_createraid *)addr, 1);
d3062 2
a3063 1
sr_ioctl_createraid(struct sr_softc *sc, struct bioc_createraid *bc, int user)
d3216 1
a3216 1
			if ((i = sd->sd_assemble(sd, bc, no_chunk))) {
@


1.275
log
@bzero the right variable.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.273 2012/01/28 14:40:04 jsing Exp $ */
d76 2
a77 1
struct sr_softc *softraid0;
d1109 9
a1117 16
			if (md->ssdi.ssd_vol_flags & BIOC_SCNOAUTOASSEMBLE) {
				DNPRINTF(SR_D_META, "%s: don't save %s\n",
				    DEVNAME(sc), devname);
			} else {
				/* XXX fix M_WAITOK, this is boot time */
				bc = malloc(sizeof(struct sr_boot_chunk),
				    M_DEVBUF, M_WAITOK | M_ZERO);
				bc->sbc_metadata =
				    malloc(sizeof(struct sr_metadata),
				    M_DEVBUF, M_WAITOK | M_ZERO);
				bcopy(md, bc->sbc_metadata,
				    sizeof(struct sr_metadata));
				bc->sbc_mm = rawdev;
				SLIST_INSERT_HEAD(bch, bc, sbc_link);
				rv = SR_META_CLAIMED;
			}
d1230 1
d1367 8
d1435 2
a1436 1
		bcr.bc_flags = BIOC_SCDEVT;
@


1.274
log
@Prevent softraid from being used with devices that do not have a sector
size of 512 bytes - any other size is not currently supported.

ok krw@@
@
text
@d1365 1
a1365 1
		bzero(&bc, sizeof(bc));
@


1.273
log
@Only pass bio ioctls through to the softraid bio ioctl handler. Rename the
handler to emphasise that it is for bio ioctls only.

Discovered the hard way by dhill@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.272 2012/01/22 11:13:31 jsing Exp $ */
d1048 7
d1555 7
d2651 5
d2950 5
@


1.272
log
@Convert softraid(4) to new bio(4) status interface. This allows bioctl(8)
to provide useful feedback, rather than reporting an ioctl failure and
leaving the user to consult dmesg. For now we continue to print most things
to the console, even if the message is a result of an ioctl.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.269 2012/01/21 15:38:44 jsing Exp $ */
d99 1
a99 1
int			sr_ioctl(struct device *, u_long, caddr_t);
d1768 1
a1768 1
	if (bio_register(&sc->sc_dev, sr_ioctl) != 0)
a1769 2
	else
		sc->sc_ioctl = sr_ioctl;
d2235 4
d2244 1
a2244 1
		return (sr_ioctl(link->adapter_softc, cmd, addr));
d2249 1
a2249 1
sr_ioctl(struct device *dev, u_long cmd, caddr_t addr)
d2255 1
a2255 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl ", DEVNAME(sc));
@


1.271
log
@Disable the softraid disk attach hook on detach.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.270 2012/01/22 10:43:50 jsing Exp $ */
d231 1
a231 2
		printf("%s: could not allocate memory for metadata\n",
		    DEVNAME(sc));
d241 2
a242 2
			printf("%s: could not allocate memory for foreign "
			    "metadata\n", DEVNAME(sc));
d323 2
a324 2
				printf("%s: sr_meta_probe: can't allocate "
				    "vnode\n", DEVNAME(sc));
d502 1
a502 2
		printf("%s: sr_meta_clear can not clear foreign metadata\n",
		    DEVNAME(sc));
d617 1
a617 2
		printf("%s: save metadata failed\n",
		    DEVNAME(sd->sd_sc));
d910 1
a910 1
			printf("%s: invalid foreign metadata\n", DEVNAME(sc));
d920 1
a920 1
		printf("%s: not valid softraid metadata\n", DEVNAME(sc));
d927 1
a927 1
		printf("%s: invalid metadata checksum\n", DEVNAME(sc));
d960 3
a962 3
		printf("%s: %s can not read metadata version %u, expected %u\n",
		    DEVNAME(sc), devname, sm->ssdi.ssd_version,
		    SR_META_VERSION);
d1014 1
a1014 2
		printf("%s: sr_meta_native_bootprobe: can't allocate vnode\n",
		    DEVNAME(sc));
d1050 1
a1050 2
		printf("%s: not enough memory for metadata buffer\n",
		    DEVNAME(sc));
d1058 1
a1058 2
		printf("%s: not enough memory for fake discipline\n",
		    DEVNAME(sc));
d1071 2
a1072 2
			printf("%s: sr_meta_native_bootprobe: can't allocate "
			    "vnode for partition\n", DEVNAME(sc));
d1085 2
a1086 2
			printf("%s: native bootprobe could not read native "
			    "metadata\n", DEVNAME(sc));
d1222 1
a1222 2
				printf("%s: failed to allocate boot volume!\n",
				    DEVNAME(sc));
d1428 1
d1590 1
a1590 2
		printf("%s: not enough memory for metadata buffer\n",
		    DEVNAME(sc));
d1602 1
a1602 2
			printf("%s: could not read native metadata\n",
			    DEVNAME(sc));
d1618 1
a1618 2
				printf("%s: not part of the same volume\n",
				    DEVNAME(sc));
d1630 2
a1631 2
		printf("%s: not all chunks are of the native metadata format\n",
		    DEVNAME(sc));
d1647 1
a1647 2
				printf("%s: could not read native metadata\n",
				    DEVNAME(sc));
d2250 1
d2257 2
d2315 4
d2321 1
a2321 1
	return (rv);
d2516 1
a2516 1
			printf("%s: chunk not part of array\n", DEVNAME(sc));
d2524 2
a2525 2
			printf("%s: could not save metadata to %s\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);
d2539 1
a2539 2
		printf("%s: unsupported state request %d\n",
		    DEVNAME(sc), bs->bs_status);
d2604 1
a2604 2
			printf("%s: %s is already a hotspare\n",
			    DEVNAME(sc), devname);
d2606 1
a2606 2
			printf("%s: %s is already in use\n",
			    DEVNAME(sc), devname);
d2614 1
a2614 1
		printf("%s: sr_hotspare: can't allocate vnode\n", DEVNAME(sc));
d2636 2
a2637 3
		printf("%s: %s partition not of type RAID (%d)\n",
		    DEVNAME(sc), devname,
		    label.d_partitions[part].p_fstype);
d2706 1
a2706 2
		printf("%s: could not save metadata to %s\n",
		    DEVNAME(sc), devname);
d2756 1
d2778 1
a2778 1
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);
d2783 2
a2784 2
	rw_enter_write(&sd->sd_sc->sc_hs_lock);
	cl = &sd->sd_sc->sc_hotspare_list;
d2792 1
a2792 1
		    "rebuild on hotspare %s\n", DEVNAME(sd->sd_sc),
d2826 1
a2826 1
		    "complete on failed chunk %s\n", DEVNAME(sd->sd_sc),
d2832 1
a2832 1
			    DEVNAME(sd->sd_sc), chunk->src_devname);
d2837 2
a2838 1
		rw_enter_write(&sd->sd_sc->sc_lock);
d2842 1
a2842 1
			sd->sd_sc->sc_hotspare_no--;
d2847 1
a2847 1
		rw_exit_write(&sd->sd_sc->sc_lock);
d2851 1
a2851 1
	rw_exit_write(&sd->sd_sc->sc_hs_lock);
d2872 1
a2872 2
		printf("%s: discipline does not support rebuild\n",
		    DEVNAME(sc));
d2878 1
a2878 1
		printf("%s: rebuild already in progress\n", DEVNAME(sc));
d2882 1
a2882 2
		printf("%s: %s not degraded\n", DEVNAME(sc),
		    sd->sd_meta->ssd_devname);
d2895 1
a2895 2
		printf("%s: no offline chunks available for rebuild\n",
		    DEVNAME(sc));
d2932 2
a2933 3
		printf("%s: %s partition not of type RAID (%d)\n",
		    DEVNAME(sc), devname,
		    label.d_partitions[part].p_fstype);
d2940 2
a2941 2
		printf("%s: partition too small, at least %llu B required\n",
		    DEVNAME(sc), csize << DEV_BSHIFT);
d2944 2
a2945 2
		printf("%s: partition too large, wasting %llu B\n",
		    DEVNAME(sc), (size - csize) << DEV_BSHIFT);
d2951 1
a2951 1
		printf("%s: %s is already in use\n", DEVNAME(sc), devname);
d2981 1
a2981 2
		printf("%s: could not save metadata to %s\n",
		    DEVNAME(sc), devname);
d2986 1
a2986 1
	printf("%s: rebuild of %s started on %s\n", DEVNAME(sc),
d3039 1
a3039 1
	char			devname[32];
d3064 1
a3064 1
		printf("%s: could not create workq\n", DEVNAME(sc));
d3068 1
a3068 1
		printf("%s: could not initialize discipline\n", DEVNAME(sc));
d3080 1
a3080 2
			printf("%s: chunk %s already in use\n",
			    DEVNAME(sc), devname);
d3087 1
a3087 1
		printf("%s: invalid metadata format\n", DEVNAME(sc));
d3091 1
a3091 3
	if (sr_meta_attach(sd, no_chunk, bc->bc_flags & BIOC_SCFORCE)) {
		printf("%s: can't attach metadata type %d\n", DEVNAME(sc),
		    sd->sd_meta_type);
a3092 1
	}
d3099 5
a3103 4
				printf("%s: disk ", DEVNAME(sc));
				sr_uuid_print(&sd->sd_meta->ssdi.ssd_uuid, 0);
				printf(" is currently in use; can't force "
				    "create\n");
d3108 1
a3108 1
			printf("%s: failed to clear metadata\n", DEVNAME(sc));
d3117 2
a3118 2
		printf("%s: one of the chunks has corrupt metadata; aborting "
		    "assembly\n", DEVNAME(sc));
d3143 2
a3144 2
			printf("%s: chunk sizes are not equal; up to %llu "
			    "blocks wasted per chunk\n", DEVNAME(sc),
d3152 2
a3153 2
			printf("%s: volume level does not match metadata "
			    "level!\n", DEVNAME(sc));
d3158 3
a3160 3
			printf("%s: disk ", DEVNAME(sc));
			sr_uuid_print(&sd->sd_meta->ssdi.ssd_uuid, 0);
			printf(" already assembled\n");
d3171 2
a3172 2
			printf("%s: trying to bring up %s degraded\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);
d3175 2
a3176 2
			printf("%s: %s was not shutdown properly\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);
d3215 2
a3216 2
			printf("%s: %s offline, will not be brought online\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);
d3240 1
a3240 1
			printf("%s: no free target for %s\n", DEVNAME(sc),
d3252 1
a3252 1
			printf("%s: scsi_probe_lun failed\n", DEVNAME(sc));
d3272 2
a3273 2
			printf("%s: volume %s is roaming, it used to be %s, "
			    "updating metadata\n", DEVNAME(sc), dev->dv_xname,
d3281 3
d3289 2
a3290 2
			printf("%s: unable to create sensor for %s\n",
			    DEVNAME(sc), dev->dv_xname);
d3311 1
a3314 1
	/* XXX - use internal status values! */
d3341 2
a3342 1
	if (sd == NULL)
d3344 1
d3419 1
a3419 2
		printf("%s: failed to get DUID for softraid volume!\n",
		    DEVNAME(sd->sd_sc));
d3426 1
a3426 1
		printf("%s: insufficient boot storage!\n", DEVNAME(sd->sd_sc));
d3495 1
a3495 1
			printf("%s: failed to write boot block\n", DEVNAME(sc));
d3506 1
a3506 2
			printf("%s: failed to write boot loader\n",
			   DEVNAME(sc));
d3517 2
a3518 2
		printf("%s: could not save metadata to %s\n",
		    DEVNAME(sc), chunk->src_devname);
d4256 1
a4256 1
		printf("%s: unable to start backgound operation\n",
@


1.270
log
@Ensure that the sc_lock is held before the status functions are called.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.266 2012/01/17 12:56:38 jsing Exp $ */
d1821 2
@


1.269
log
@Split sr_uuid_print() into two functions - one that formats and one that
prints. Also rename sr_uuid_get() to sr_uuid_generate().
@
text
@d1845 2
d1857 2
d1868 2
@


1.268
log
@Add bio(4) status interface structs and utility functions to softraid(4).
@
text
@d124 2
a125 1
void			sr_uuid_get(struct sr_uuid *);
d555 1
a555 1
	sr_uuid_get(&sm->ssdi.ssd_uuid);
d2647 1
a2647 1
	sr_uuid_get(&uuid);
d4060 1
a4060 1
sr_uuid_get(struct sr_uuid *uuid)
d4071 2
a4072 2
void
sr_uuid_print(struct sr_uuid *uuid, int cr)
d4074 6
a4079 1
	printf("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-"
d4090 11
a4100 2
	if (cr)
		printf("\n");
@


1.267
log
@Check the metadata level against the assembly level before proceeding with
any assembly. This avoids a panic when attempting to assemble a RAID 1 (or
other) volume as a RAID 0 volume. Also reorder some of the other checks and
diagnostics performed during assembly.
@
text
@d1840 30
@


1.266
log
@Add missing ioctl DNPRINTFs and nuke some rogue commas.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.264 2012/01/11 14:10:50 jsing Exp $ */
d3125 4
a3128 11
		if (no_meta != no_chunk)
			printf("%s: trying to bring up %s degraded\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);

		if (sd->sd_meta->ssd_meta_flags & SR_META_DIRTY)
			printf("%s: %s was not shutdown properly\n",
			    DEVNAME(sc), sd->sd_meta->ssd_devname);

		if (user == 0 && sd->sd_meta_flags & BIOC_SCNOAUTOASSEMBLE) {
			DNPRINTF(SR_D_META, "%s: disk not auto assembled from "
			    "metadata\n", DEVNAME(sc));
d3139 14
a3170 7

	/* Make sure that metadata level matches requested assembly level. */
	if (sd->sd_meta->ssdi.ssd_level != bc->bc_level) {
		printf("%s: volume level does not match metadata level!\n",
		    DEVNAME(sc));
		goto unwind;
	}
@


1.265
log
@Move softraid root mapping to later in the boot process - this will allow
us to play some tricks in setroot().
@
text
@d323 1
a323 1
				printf("%s:, sr_meta_probe: can't allocate "
d1016 1
a1016 1
		printf("%s:, sr_meta_native_bootprobe: can't allocate vnode\n",
d1076 1
a1076 1
			printf("%s:, sr_meta_native_bootprobe: can't allocate "
d2264 1
d2269 1
d2274 1
d2581 1
a2581 1
		printf("%s:, sr_hotspare: can't allocate vnode\n", DEVNAME(sc));
d2881 1
a2881 1
		printf("%s:, sr_rebuild_init: can't allocate vnode\n",
@


1.264
log
@Make sr_boot_chunk and sr_boot_volume accessible from userland. Add a
number of variables that are needed to detect and assemble volumes. A
sr_metadata struct can be allocated and used via the sbc_metadata
pointer, which we now do in the kernel boot probe/assembly code.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.262 2011/12/28 16:19:52 jsing Exp $ */
d76 2
d81 1
a127 1
void			sr_map_root(struct sr_softc *);
d1484 1
a1484 1
sr_map_root(struct sr_softc *sc)
d1486 1
d1492 3
d1767 3
a1807 2

	sr_map_root(sc);
@


1.263
log
@Implement a concatenating discipline for softraid.

Many thanks to Marco Peereboom for his assistance with testing and
debugging. Thanks also to Josh Grosse and Chris Jackman for testing.
@
text
@d1109 7
a1115 4
				bc = malloc(sizeof(*bc), M_DEVBUF,
				    M_WAITOK | M_ZERO);
				bcopy(md, &bc->sbc_metadata,
				    sizeof(bc->sbc_metadata));
d1206 1
a1206 1
		bc->sbc_chunk_id = bc->sbc_metadata.ssdi.ssd_chunk_id;
d1209 1
a1209 1
		if (bc->sbc_metadata.ssdi.ssd_level == SR_KEYDISK_LEVEL) {
d1215 1
a1215 1
			if (bcmp(&bc->sbc_metadata.ssdi.ssd_uuid,
d1217 1
a1217 1
			    sizeof(bc->sbc_metadata.ssdi.ssd_uuid)) == 0)
d1230 5
a1234 5
			bv->sbv_level = bc->sbc_metadata.ssdi.ssd_level;
			bv->sbv_volid = bc->sbc_metadata.ssdi.ssd_volid;
			bv->sbv_chunk_no = bc->sbc_metadata.ssdi.ssd_chunk_no;
			bcopy(&bc->sbc_metadata.ssdi.ssd_uuid, &bv->sbv_uuid,
			    sizeof(bc->sbc_metadata.ssdi.ssd_uuid));
d1275 1
a1275 1
		bv->sbv_dev_no++;
d1325 1
a1325 1
		hotspare->src_size = bc->sbc_metadata.ssdi.ssd_size;
d1330 2
a1331 2
		hm->scmi.scm_size = bc->sbc_metadata.ssdi.ssd_size;
		hm->scmi.scm_coerced_size = bc->sbc_metadata.ssdi.ssd_size;
d1334 1
a1334 1
		bcopy(&bc->sbc_metadata.ssdi.ssd_uuid, &hm->scmi.scm_uuid,
d1384 1
a1384 1
				if (bcmp(&bc->sbc_metadata.ssdi.ssd_uuid,
d1386 1
a1386 1
				    sizeof(bc->sbc_metadata.ssdi.ssd_uuid))
d1399 1
a1399 1
				bv->sbv_dev_no--;
d1408 1
a1408 1
			    bc->sbc_metadata.ssd_ondisk >
d1412 1
a1412 1
				    bc->sbc_metadata.ssd_ondisk;
d1420 1
a1420 1
		if (bv->sbv_chunk_no != bv->sbv_dev_no) {
d1446 2
d1455 2
d1462 2
@


1.262
log
@Cleanup the metadata initialisation process - have sr_meta_init()
initialise both the volume and chunk metadata before the discipline
specific sd_create() function is called. The sr_meta_init_complete()
function is then called to complete the initialisation based on values
provided by sd_create().
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.261 2011/12/28 16:02:45 jsing Exp $ */
d3097 2
a3098 1
		if (sd->sd_vol.sv_chunk_minsz != sd->sd_vol.sv_chunk_maxsz)
d3667 3
@


1.261
log
@Avoid the use of an invalid disklabel by setting a DK_LABELVALID flag
if we correctly read and validated the disklabel. Always check that this
flag is set before using the DUID from the disklabel.

Discussed with deraadt@@

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.259 2011/12/25 15:28:17 jsing Exp $ */
d151 2
a152 4
void			sr_meta_chunks_create(struct sr_softc *,
			    struct sr_chunk_head *);
void			sr_meta_init(struct sr_discipline *,
			    struct sr_chunk_head *);
d526 1
a526 1
sr_meta_chunks_create(struct sr_softc *sc, struct sr_chunk_head *cl)
d528 5
a532 2
	struct sr_chunk		*ch_entry;
	struct sr_uuid		uuid;
d534 1
a534 2
	char			*name;
	u_int64_t		max_chunk_sz = 0, min_chunk_sz;
d536 1
a536 1
	DNPRINTF(SR_D_META, "%s: sr_meta_chunks_create\n", DEVNAME(sc));
d538 2
a539 1
	sr_uuid_get(&uuid);
d541 7
a547 10
	/* fill out stuff and get largest chunk size while looping */
	SLIST_FOREACH(ch_entry, cl, src_link) {
		name = ch_entry->src_devname;
		ch_entry->src_meta.scmi.scm_size = ch_entry->src_size;
		ch_entry->src_meta.scmi.scm_chunk_id = cid++;
		ch_entry->src_meta.scm_status = BIOC_SDONLINE;
		strlcpy(ch_entry->src_meta.scmi.scm_devname, name,
		    sizeof(ch_entry->src_meta.scmi.scm_devname));
		bcopy(&uuid, &ch_entry->src_meta.scmi.scm_uuid,
		    sizeof(ch_entry->src_meta.scmi.scm_uuid));
d549 2
a550 3
		if (ch_entry->src_meta.scmi.scm_size > max_chunk_sz)
			max_chunk_sz = ch_entry->src_meta.scmi.scm_size;
	}
d552 1
a552 5
	/* get smallest chunk size */
	min_chunk_sz = max_chunk_sz;
	SLIST_FOREACH(ch_entry, cl, src_link)
		if (ch_entry->src_meta.scmi.scm_size < min_chunk_sz)
			min_chunk_sz = ch_entry->src_meta.scmi.scm_size;
d554 23
a576 3
	/* equalize all sizes */
	SLIST_FOREACH(ch_entry, cl, src_link)
		ch_entry->src_meta.scmi.scm_coerced_size = min_chunk_sz;
d578 2
a579 5
	/* whine if chunks are not the same size */
	if (min_chunk_sz != max_chunk_sz)
		printf("%s: chunk sizes are not equal; up to %llu blocks "
		    "wasted per chunk\n",
		    DEVNAME(sc), max_chunk_sz - min_chunk_sz);
d583 1
a583 1
sr_meta_init(struct sr_discipline *sd, struct sr_chunk_head *cl)
d585 1
d587 1
a588 2
	struct sr_meta_chunk	*im_sc;
	int			i, chunk_no;
d590 1
a590 1
	DNPRINTF(SR_D_META, "%s: sr_meta_init\n", DEVNAME(sc));
d592 6
a597 25
	if (!sm)
		return;

	/* initial metadata */
	sm->ssdi.ssd_magic = SR_MAGIC;
	sm->ssdi.ssd_version = SR_META_VERSION;
	sm->ssd_ondisk = 0;
	sm->ssdi.ssd_vol_flags = sd->sd_meta_flags;
	sm->ssd_data_offset = SR_DATA_OFFSET;

	/* get uuid from chunk 0 */
	bcopy(&sd->sd_vol.sv_chunks[0]->src_meta.scmi.scm_uuid,
	    &sm->ssdi.ssd_uuid,
	    sizeof(struct sr_uuid));

	/* volume is filled in createraid */

	/* add missing chunk bits */
	chunk_no = sm->ssdi.ssd_chunk_no;
	for (i = 0; i < chunk_no; i++) {
		im_sc = &sd->sd_vol.sv_chunks[i]->src_meta;
		im_sc->scmi.scm_volid = sm->ssdi.ssd_volid;
		sr_checksum(sc, im_sc, &im_sc->scm_checksum,
		    sizeof(struct sr_meta_chunk_invariant));
	}
d1167 1
a1167 1
		if (sdk != NULL) {
d2995 1
a2995 1
	int			no_meta, updatemeta = 0;
d3071 2
d3076 1
a3077 3
		/* fill out all chunk metadata */
		sr_meta_chunks_create(sc, cl);
		ch_entry = SLIST_FIRST(cl);
d3079 2
d3082 1
a3082 8
		sd->sd_meta->ssdi.ssd_level = bc->bc_level;
		sd->sd_meta->ssdi.ssd_chunk_no = no_chunk;

		/* Make the volume UUID available. */
		bcopy(&ch_entry->src_meta.scmi.scm_uuid,
		    &sd->sd_meta->ssdi.ssd_uuid,
		    sizeof(sd->sd_meta->ssdi.ssd_uuid));

d3085 1
a3085 1
			    ch_entry->src_meta.scmi.scm_coerced_size))) {
d3090 1
a3091 1
		/* fill out all volume metadata */
a3094 8
		strlcpy(sd->sd_meta->ssdi.ssd_vendor, "OPENBSD",
		    sizeof(sd->sd_meta->ssdi.ssd_vendor));
		snprintf(sd->sd_meta->ssdi.ssd_product,
		    sizeof(sd->sd_meta->ssdi.ssd_product), "SR %s",
		    sd->sd_name);
		snprintf(sd->sd_meta->ssdi.ssd_revision,
		    sizeof(sd->sd_meta->ssdi.ssd_revision), "%03d",
		    SR_META_VERSION);
d3096 7
a3102 2
		sd->sd_meta_flags = bc->bc_flags & BIOC_SCNOAUTOASSEMBLE;
		updatemeta = 1;
d3104 1
d3140 1
a3140 1
		updatemeta = 0;
d3143 1
a3143 1
	/* metadata SHALL be fully filled in at this point */
d3145 1
a3145 1
	/* Make sure that metadata level matches assembly level. */
d3152 1
a3152 1
	/* allocate all resources */
d3166 2
a3167 1
		/* set volume status */
d3175 1
a3175 1
		/* setup scsi iopool */
d3180 1
a3180 1
		 * we passed all checks return ENXIO if volume can't be created
d3200 1
a3200 1
		/* clear sense data */
d3203 1
a3203 1
		/* attach disclipline and kick midlayer to probe it */
a3222 13
		if (updatemeta) {
			/* fill out remaining volume metadata */
			sd->sd_meta->ssdi.ssd_volid = vol;
			strlcpy(sd->sd_meta->ssd_devname, dev->dv_xname,
			    sizeof(sd->sd_meta->ssd_devname));
			sr_meta_init(sd, cl);
		} else {
			if (strncmp(sd->sd_meta->ssd_devname, dev->dv_xname,
			    sizeof(dev->dv_xname))) {
				printf("%s: volume %s is roaming, it used to "
				    "be %s, updating metadata\n",
				    DEVNAME(sc), dev->dv_xname,
				    sd->sd_meta->ssd_devname);
d3224 11
a3234 5
				sd->sd_meta->ssdi.ssd_volid = vol;
				strlcpy(sd->sd_meta->ssd_devname, dev->dv_xname,
				    sizeof(sd->sd_meta->ssd_devname));
			}
		}
d3236 1
a3236 1
		/* Update device name on any chunks which roamed. */
d3245 5
a3249 8
		/* we are not an os disk */
		if (updatemeta) {
			/* fill out remaining volume metadata */
			sd->sd_meta->ssdi.ssd_volid = 0;
			strlcpy(sd->sd_meta->ssd_devname, ch_entry->src_devname,
			    sizeof(sd->sd_meta->ssd_devname));
			sr_meta_init(sd, cl);
		}
d3254 1
a3254 1
	/* save metadata to disk */
@


1.260
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d3392 1
@


1.259
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.257 2011/11/13 13:57:43 jsing Exp $ */
d115 2
d3655 2
a3656 2
	sd->sd_set_chunk_state = NULL;
	sd->sd_set_vol_state = NULL;
d3899 106
@


1.258
log
@When initiating a rebuild update the DUID for the chunk so that
installboot has the correct details. Also zero the boot DUID list before
populating it in installboot, preventing the DUIDs of offline chunks from
remaining around.
@
text
@d3638 19
@


1.257
log
@Cleanup rebuild initialisation code. In particular, reconstruct the chunk
metadata from the volume metadata rather than using the metadata from some
random chunk. The coerced size is gained from another online chunk.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.256 2011/11/11 17:26:24 jsing Exp $ */
d2920 1
d3438 1
@


1.256
log
@Remove a bogus check which dereferences an uninitialised pointer.

From Pedro Martelletto.

ok krw@@ mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.255 2011/11/11 17:23:39 jsing Exp $ */
d2813 3
a2815 3
	int			rv = EINVAL, part;
	int			c, found, open = 0;
	char			devname[32];
d2818 3
a2820 2
	struct disklabel	label;
	struct sr_meta_chunk	*old, *new;
d2843 3
a2845 3
	/* find offline chunk */
	for (c = 0, found = -1; c < sd->sd_meta->ssdi.ssd_chunk_no; c++)
		if (sd->sd_vol.sv_chunks[c]->src_meta.scm_status ==
d2847 2
a2848 9
			found = c;
			new = &sd->sd_vol.sv_chunks[c]->src_meta;
			csize = new->scmi.scm_coerced_size;
			if (c > 0)
				break; /* roll at least once over the for */
		} else {
			old = &sd->sd_vol.sv_chunks[c]->src_meta;
			if (found != -1)
				break;
d2850 2
a2851 1
	if (found == -1) {
d2857 10
a2866 1
	/* populate meta entry */
a2872 1

d2881 1
a2881 1
	/* get partition */
d2896 1
a2896 1
	/* is partition large enough? */
d2906 4
a2909 4
	/* make sure we are not stomping on some other partition */
	c = sr_chunk_in_use(sc, dev);
	if (c != BIOC_SDINVALID && c != BIOC_SDOFFLINE &&
	    !(hotspare && c == BIOC_SDHOTSPARE)) {
a2916 1
	/* recreate metadata */
d2918 16
a2933 11
	sd->sd_vol.sv_chunks[found]->src_dev_mm = dev;
	sd->sd_vol.sv_chunks[found]->src_vn = vn;
	new->scmi.scm_volid = old->scmi.scm_volid;
	new->scmi.scm_chunk_id = found;
	strlcpy(new->scmi.scm_devname, devname,
	    sizeof new->scmi.scm_devname);
	new->scmi.scm_size = size;
	new->scmi.scm_coerced_size = old->scmi.scm_coerced_size;
	bcopy(&old->scmi.scm_uuid, &new->scmi.scm_uuid,
	    sizeof new->scmi.scm_uuid);
	sr_checksum(sc, new, &new->scm_checksum,
d2935 3
a2937 1
	sd->sd_set_chunk_state(sd, found, BIOC_SDREBUILD);
@


1.255
log
@When rebuilding check the size of the replacement chunk against the
coerced size rather than the physical size of another chunk.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.254 2011/11/11 12:32:11 jsing Exp $ */
a2759 3
			if (wu->swu_cb_active == 1)
				panic("%s: sr_hotspare_rebuild",
				    DEVNAME(sd->sd_sc));
@


1.254
log
@Remove unused sv_sensor_valid variable.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.251 2011/09/19 21:47:37 jsing Exp $ */
d2851 1
a2854 1
			csize = sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_size;
@


1.253
log
@When setting up a bootable softraid volume, do not try to save the boot
blocks or boot loader to chunks that are not online.

ok mikeb@@
@
text
@a3255 2
		else
			sd->sd_vol.sv_sensor_valid = 1;
@


1.252
log
@Typo. BIOC_SSOFFLINE is the ioctl command. Pass BIOC_SDOFFLINE to
sd_set_chunk_state() as the new state.

ok jsing@@
@
text
@d3447 4
@


1.251
log
@If the rootduid matches a softraid chunk of a bootable softraid volume,
map the rootduid to the DUID of the softraid volume. This means that
regardless of where the kernel is loaded from we always get the softraid
volume as the root device, providing we booted from one of its chunks.
If we boot from any other disk then the rootduid remains unchanged.

With this diff it is now possible to have the root filesystem on softraid,
however at this stage the kernel still needs to be loaded from a separate
FFS partition.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.249 2011/09/19 14:55:10 jsing Exp $ */
d2473 1
a2473 1
		sd->sd_set_chunk_state(sd, c, BIOC_SSOFFLINE);
@


1.250
log
@When installboot is run on a softraid volume, add boot optional metadata
to store the DUID of the softraid volume and each of the chunks that it
is assembled from. This allows us to correctly identify the root disk.

ok deraadt@@
@
text
@d123 1
d1479 42
d1797 2
@


1.249
log
@Cleanup sr_ioctl_createraid(). There are three clear cases - (1) corrupt
or invalid metadata; (2) a new volume with no existing metadata; and (3)
an existing volume with metadata. This removes duplicated code and
simplifies the code path.

Also ensure that we only process the optional metadata once per volume
and not once per chunk. Move the optional metadata handler calls into
sr_ioctl_createraid().
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.247 2011/09/18 13:11:08 jsing Exp $ */
d1500 1
d3311 3
d3315 1
d3335 12
d3371 27
d3402 3
d3433 1
a3433 1
	/* Save boot details in metadata. */
a3434 4

	/* XXX - Store size of boot block/loader in optional metadata. */

	/* Save metadata. */
@


1.248
log
@Add support for variable length optional metadata in softraid(4). This
will allow new optional metadata types to be added without needing to
change the softraid metadata version.

Note that this commit changes the softraid metadata version, however
an upgrade from older metadata is handled automatically. A full backup
prior to upgrading is still strongly recommended.

With feedback from stsp@@ and marco.
@
text
@a299 1

a743 1
	struct sr_meta_opt_item *omi;
d789 1
d796 1
a796 7
		/* Load and process optional metadata. */
		sr_meta_opt_load(sc, sm, &sd->sd_meta_opt);
		SLIST_FOREACH(omi, &sd->sd_meta_opt, omi_link)
			if (sd->sd_meta_opt_handler == NULL ||
			    sd->sd_meta_opt_handler(sd, omi->omi_som) != 0)
				sr_meta_opt_handler(sd, omi->omi_som);

a797 1
		no_disk++;
d824 2
a825 2
		omi = malloc(sizeof(struct sr_meta_opt_item),
		    M_DEVBUF, M_WAITOK | M_ZERO);
d2940 1
a2940 3
	dev_t			*dt;
	int			i, no_chunk, rv = EINVAL, target, vol;
	int			no_meta, updatemeta = 0;
d2947 3
d3023 6
a3028 1
	if ((no_meta = sr_meta_read(sd)) == 0) {
d3065 5
a3069 1
	} else if (no_meta == no_chunk) {
d3073 1
d3079 1
d3087 5
a3101 22
	} else if (no_meta == -1) {
		printf("%s: one of the chunks has corrupt metadata; aborting "
		    "assembly\n", DEVNAME(sc));
		goto unwind;
	} else {
		if (sr_already_assembled(sd)) {
			printf("%s: disk ", DEVNAME(sc));
			sr_uuid_print(&sd->sd_meta->ssdi.ssd_uuid, 0);
			printf(" already assembled; will not partial "
			    "assemble it\n");
			goto unwind;
		}

		if (sd->sd_assemble) {
			if ((i = sd->sd_assemble(sd, bc, no_chunk))) {
				rv = i;
				goto unwind;
			}
		}

		printf("%s: trying to bring up %s degraded\n", DEVNAME(sc),
		    sd->sd_meta->ssd_devname);
@


1.247
log
@Rename the optional metadata handler function and factor out the optional
metadata handling code. This will simplify upcoming changes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.245 2011/07/17 22:46:48 matthew Exp $ */
d153 1
a153 1
			    struct sr_meta_opt *);
d608 1
a608 1
sr_meta_opt_handler(struct sr_discipline *sd, struct sr_meta_opt *om)
d610 1
a610 1
	if (om->somi.som_type != SR_OPT_BOOT)
d639 1
a640 1
	struct sr_meta_opt	*om;
d675 1
a675 1
	om = (struct sr_meta_opt *)(cm);
d677 9
a685 4
		bcopy(&omi->omi_om, om, sizeof(*om));
		sr_checksum(sc, om, &om->som_checksum,
		    sizeof(struct sr_meta_opt_invariant));
		om++;
d801 2
a802 2
			    sd->sd_meta_opt_handler(sd, &omi->omi_om) != 0)
				sr_meta_opt_handler(sd, &omi->omi_om);
d822 1
d824 1
a824 1
	struct sr_meta_opt	*om;
d828 1
a828 1
	om = (struct sr_meta_opt *)((u_int8_t *)(sm + 1) +
a833 1
		bcopy(om, &omi->omi_om, sizeof(struct sr_meta_opt));
d836 65
a900 1
		om++;
d913 1
a915 1
	u_int8_t		checksum[MD5_DIGEST_LENGTH];
a951 3
		sm->ssdi.ssd_version = SR_META_VERSION;
		snprintf(sm->ssdi.ssd_revision, sizeof(sm->ssdi.ssd_revision),
		    "%03d", SR_META_VERSION);
d955 1
a955 1
	} else if (sm->ssdi.ssd_version == SR_META_VERSION) {
d964 8
d981 5
d3459 1
a3459 1
	struct sr_meta_opt_head *omh;
d3479 2
a3480 2
	omh = &sd->sd_meta_opt;
	for (omi = SLIST_FIRST(omh); omi != SLIST_END(omh); omi = omi_next) {
d3482 2
d4301 1
a4301 1
	struct sr_meta_opt	*mo;
d4343 4
a4346 3
	mo = (struct sr_meta_opt *)(mc);
	for (i = 0; i < m->ssdi.ssd_opt_no; i++, mo++) {
		printf("\t\t\tsom_type %d\n", mo->somi.som_type);
d4348 1
a4348 1
		sr_checksum_print(mo->som_checksum);
d4350 2
@


1.246
log
@Fix a formating bug that caused a bad print on big endian arches.

ok deraadt
@
text
@d152 1
a152 1
void			sr_meta_opt_load(struct sr_discipline *,
d608 1
a608 1
sr_meta_opt_load(struct sr_discipline *sd, struct sr_meta_opt *om)
d610 1
a610 4
	if (om->somi.som_type == SR_OPT_BOOT) {


	} else
a733 1
#ifdef SR_DEBUG
a734 1
#endif
a740 1
	struct sr_meta_opt	*om;
d742 1
a742 1
	int			i, no_disk = 0, got_meta = 0;
d792 6
a797 19
		/* Process optional metadata. */
		om = (struct sr_meta_opt *) ((u_int8_t *)(sm + 1) +
		    sizeof(struct sr_meta_chunk) * sm->ssdi.ssd_chunk_no);
		for (i = 0; i < sm->ssdi.ssd_opt_no; i++) {

			omi = malloc(sizeof(struct sr_meta_opt_item),
			    M_DEVBUF, M_WAITOK | M_ZERO);
			bcopy(om, &omi->omi_om, sizeof(struct sr_meta_opt));
			SLIST_INSERT_HEAD(&sd->sd_meta_opt, omi, omi_link);

			/* See if discipline wants to handle it. */
			if (sd->sd_meta_opt_load &&
			    sd->sd_meta_opt_load(sd, &omi->omi_om) == 0)
				continue;
			else
				sr_meta_opt_load(sd, &omi->omi_om);

			om++;
		}
d811 22
@


1.245
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.244 2011/07/08 22:09:27 matthew Exp $ */
d3961 1
a3961 1
		printf("%s: resuming rebuild on %s at %llu%%\n",
@


1.244
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.243 2011/07/07 18:04:25 jsing Exp $ */
d1665 2
a1669 2
	saa.saa_targets = SR_MAX_LD;
	saa.saa_luns = 1;
@


1.243
log
@Fix the LBA offset calculation for the last block in a rebuild, if there
is a partial block. Also correctly handle the case where there is no
partial block. Whilst here remove a pointless variable.

Issues spotted by and based on diffs from Piotr Durlej - thanks!

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.242 2011/07/07 15:24:59 jsing Exp $ */
a1664 2
	sc->sc_link.adapter_buswidth = SR_MAX_LD;
	sc->sc_link.luns = 1;
d1668 2
@


1.242
log
@Make sr_shutdown() a general function and use this from sr_detach() to
avoid duplication. Implement a sr_shutdownhook() function that simply
calls sr_shutdown() and use this for the shutdown hook.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.241 2011/07/06 17:37:22 jsing Exp $ */
a3929 1
	uint64_t		mysize = 0;
d3970 5
a3974 1
		if (blk == whole_blk)
d3976 1
a3976 4
		else
			sz = SR_REBUILD_IO_SIZE;
		mysize += sz;
		lba = blk * sz;
@


1.241
log
@When checking if a chunk is in use, do not match on NODEV.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.240 2011/07/06 17:32:47 jsing Exp $ */
d117 2
a118 1
void			sr_shutdown(void *);
d1676 1
a1676 1
	sc->sc_shutdownhook = shutdownhook_establish(sr_shutdown, sc);
d1685 1
a1685 1
	int			i, rv;
d1692 1
a1692 4
	/* XXX this will not work when we stagger disciplines */
	for (i = 0; i < SR_MAX_LD; i++)
		if (sc->sc_dis[i])
			sr_discipline_shutdown(sc->sc_dis[i], 1);
d3801 7
a3807 1
sr_shutdown(void *arg)
a3808 1
	struct sr_softc		*sc = arg;
@


1.240
log
@Use a single shutdown hook for the softraid controller instead of
having one per volume.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.239 2011/07/06 15:55:25 jsing Exp $ */
d2387 5
@


1.239
log
@Actually make sr_detach() work. At this stage we never detach softraid(4),
however since this code exists it still should work correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.238 2011/07/06 15:44:11 jsing Exp $ */
d1675 2
d1688 3
a3155 1
	sd->sd_shutdownhook = shutdownhook_establish(sr_shutdown, sd);
a3435 3
	if (sd->sd_shutdownhook)
		shutdownhook_disestablish(sd->sd_shutdownhook);

d3800 4
a3803 6
	struct sr_discipline	*sd = arg;
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif
	DNPRINTF(SR_D_DIS, "%s: sr_shutdown %s\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname);
d3805 4
a3808 1
	sr_discipline_shutdown(sd, 1);
@


1.238
log
@Retain a reference to the registered sensor task so that we can unregister
it again.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.237 2011/07/06 15:29:17 jsing Exp $ */
d1682 14
a1695 1
	int			rv;
d1704 1
a1704 5
#ifndef SMALL_KERNEL
	sensordev_deinstall(&sc->sc_sensordev);
#endif /* SMALL_KERNEL */

	return (0);
@


1.237
log
@Move all volume shutdown code into sr_shutdown_discipline() and use a flag
to indicate if we should force a metadata write.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.235 2011/07/03 15:41:32 matthew Exp $ */
d4092 4
a4095 2
	if (sc->sc_sensors_running == 0) {
		if (sensor_task_register(sc, sr_sensors_refresh, 10) == NULL)
a4096 1
		sc->sc_sensors_running = 1;
@


1.236
log
@Fix debugging prints in softraid(4) so that it can compile with
SR_DEBUG enabled.  Broken since r1.227.
@
text
@d113 1
a113 1
void			sr_discipline_shutdown(struct sr_discipline *);
d3151 1
a3151 1
	sr_discipline_shutdown(sd);
d3185 1
a3185 1
	sr_shutdown(sd);
d3397 1
a3397 1
sr_discipline_shutdown(struct sr_discipline *sd)
d3409 10
d3797 1
a3797 8
	/* abort rebuild and drain io */
	sd->sd_reb_abort = 1;
	while (sd->sd_reb_active)
		tsleep(sd, PWAIT, "sr_shutdown", 1);

	sr_meta_save(sd, 0);

	sr_discipline_shutdown(sd);
@


1.235
log
@Call config_detach() on the child scsibus in sr_detach().

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.234 2011/07/02 17:39:12 jsing Exp $ */
d1932 2
a1933 2
	DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: scsibus%d xs: %p "
	    "flags: %#x\n", DEVNAME(sc), link->scsibus, xs, xs->flags);
d3089 2
a3090 2
		DNPRINTF(SR_D_IOCTL, "%s: sr device added: %s on scsibus%d\n",
		    DEVNAME(sc), dev->dv_xname, sd->sd_link.scsibus);
d3604 1
a3604 1
	    DEVNAME(sd->sd_sc));
@


1.234
log
@Cleanup the softraid boot probe code. Rename the rather poorly named
sr_metadata_list struct to sr_boot_chunk and use a sr_metadata struct
rather than an array of u_int8_t when storing the metadata. Also rename
some variables to keep the boot volume/boot chunk consistency.

This diff also fixes a memory leak where the structures were never freed
for key disks. Otherwise there should be no functional change.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.231 2011/06/20 09:16:05 matthew Exp $ */
a1680 1
#ifndef SMALL_KERNEL
d1682 8
d1691 1
@


1.233
log
@Avoid a possible null dereference.

ok marco@@
@
text
@d176 1
a176 1
			    struct sr_metadata_list_head *);
d924 1
a924 1
    struct sr_metadata_list_head *mlh)
d930 1
a930 1
	struct sr_metadata_list *mle;
d1040 1
a1040 1
				mle = malloc(sizeof(*mle), M_DEVBUF,
d1042 4
a1045 4
				bcopy(md, &mle->sml_metadata,
				    SR_META_SIZE * 512);
				mle->sml_mm = rawdev;
				SLIST_INSERT_HEAD(mlh, mle, sml_link);
d1067 4
a1070 1
	struct disk		*dk;
d1073 2
a1074 6
	struct bioc_createraid	bc;
	struct sr_metadata_list_head mlh, kdh;
	struct sr_metadata_list *mle, *mlenext, *mle1, *mle2;
	struct sr_metadata	*metadata;
	struct sr_boot_volume_head bvh;
	struct sr_boot_volume	*vol, *vp1, *vp2;
a1077 1
	u_int32_t		chunk_id;
a1085 1
	SLIST_INIT(&mlh);
d1087 1
d1119 1
a1119 1
		sr_meta_native_bootprobe(sc, dk->dk_devno, &mlh);
d1130 1
d1132 3
a1134 7
	for (mle = SLIST_FIRST(&mlh); mle != SLIST_END(&mlh); mle = mlenext) {

		mlenext = SLIST_NEXT(mle, sml_link);
		SLIST_REMOVE(&mlh, mle, sr_metadata_list, sml_link);

		metadata = (struct sr_metadata *)&mle->sml_metadata;
		mle->sml_chunk_id = metadata->ssdi.ssd_chunk_id;
d1137 2
a1138 2
		if (metadata->ssdi.ssd_level == SR_KEYDISK_LEVEL) {
			SLIST_INSERT_HEAD(&kdh, mle, sml_link);
d1142 4
a1145 3
		SLIST_FOREACH(vol, &bvh, sbv_link) {
			if (bcmp(&metadata->ssdi.ssd_uuid, &vol->sbv_uuid,
			    sizeof(metadata->ssdi.ssd_uuid)) == 0)
d1149 2
a1150 2
		if (vol == NULL) {
			vol = malloc(sizeof(struct sr_boot_volume),
d1152 1
a1152 1
			if (vol == NULL) {
d1158 6
a1163 6
			vol->sbv_level = metadata->ssdi.ssd_level;
			vol->sbv_volid = metadata->ssdi.ssd_volid;
			vol->sbv_chunk_no = metadata->ssdi.ssd_chunk_no;
			bcopy(&metadata->ssdi.ssd_uuid, &vol->sbv_uuid,
			    sizeof(metadata->ssdi.ssd_uuid));
			SLIST_INIT(&vol->sml);
d1166 3
a1168 3
			vp2 = NULL;
			SLIST_FOREACH(vp1, &bvh, sbv_link) {
				if (vp1->sbv_volid > vol->sbv_volid)
d1170 1
a1170 1
				vp2 = vp1;
d1172 1
a1172 1
			if (vp2 == NULL) {
d1174 2
a1175 2
				    "at head\n", DEVNAME(sc), vol->sbv_volid);
				SLIST_INSERT_HEAD(&bvh, vol, sbv_link);
d1178 3
a1180 3
				    "after %u\n", DEVNAME(sc), vol->sbv_volid,
				    vp2->sbv_volid);
				SLIST_INSERT_AFTER(vp2, vol, sbv_link);
d1185 3
a1187 3
		mle2 = NULL;
		SLIST_FOREACH(mle1, &vol->sml, sml_link) {
			if (mle1->sml_chunk_id > mle->sml_chunk_id)
d1189 1
a1189 1
			mle2 = mle1;
d1191 1
a1191 1
		if (mle2 == NULL) {
d1193 3
a1195 3
			    "at head\n", DEVNAME(sc), vol->sbv_volid,
			    mle->sml_chunk_id);
			SLIST_INSERT_HEAD(&vol->sml, mle, sml_link);
d1198 3
a1200 3
			    "after %u\n", DEVNAME(sc), vol->sbv_volid,
			    mle->sml_chunk_id, mle2->sml_chunk_id);
			SLIST_INSERT_AFTER(mle2, mle, sml_link);
d1203 1
a1203 1
		vol->sbv_dev_no++;
d1223 1
a1223 1
	SLIST_FOREACH(vol, &bvh, sbv_link) {
d1226 2
a1227 2
		if (vol->sbv_level != SR_HOTSPARE_LEVEL ||
		    vol->sbv_chunk_no != 1)
d1234 1
a1234 1
			sr_uuid_print(&vol->sbv_uuid, 0);
d1236 1
a1236 1
		    vol->sbv_volid, vol->sbv_chunk_no);
d1248 3
a1250 3
		mle = SLIST_FIRST(&vol->sml);
		sr_meta_getdevname(sc, mle->sml_mm, devname, sizeof(devname));
		hotspare->src_dev_mm = mle->sml_mm;
d1253 1
a1253 1
		hotspare->src_size = metadata->ssdi.ssd_size;
d1258 2
a1259 2
		hm->scmi.scm_size = metadata->ssdi.ssd_size;
		hm->scmi.scm_coerced_size = metadata->ssdi.ssd_size;
d1262 1
a1262 1
		bcopy(&metadata->ssdi.ssd_uuid, &hm->scmi.scm_uuid,
d1288 1
a1288 1
	SLIST_FOREACH(vol, &bvh, sbv_link) {
d1293 2
a1294 2
		if (vol->sbv_level == SR_HOTSPARE_LEVEL &&
		    vol->sbv_chunk_no == 1)
d1300 1
a1300 1
			sr_uuid_print(&vol->sbv_uuid, 0);
d1302 1
a1302 1
		    vol->sbv_volid, vol->sbv_chunk_no);
d1309 8
a1316 10
		bc.bc_key_disk = NODEV;
		if (vol->sbv_level == 'C') {
			SLIST_FOREACH(mle, &kdh, sml_link) {
				metadata =
				    (struct sr_metadata *)&mle->sml_metadata;
				if (bcmp(&metadata->ssdi.ssd_uuid,
				    &vol->sbv_uuid,
				    sizeof(metadata->ssdi.ssd_uuid)) == 0) {
					bc.bc_key_disk = mle->sml_mm;
				}
d1325 4
a1328 7
		SLIST_FOREACH(mle, &vol->sml, sml_link) {
			metadata = (struct sr_metadata *)&mle->sml_metadata;
			chunk_id = metadata->ssdi.ssd_chunk_id;

			if (devs[chunk_id] != NODEV) {
				vol->sbv_dev_no--;
				sr_meta_getdevname(sc, mle->sml_mm, devname,
d1332 1
a1332 1
				    chunk_id, vol->sbv_volid, devname);
d1335 6
a1340 4
			if (devs[chunk_id] == NODEV ||
			    metadata->ssd_ondisk > ondisk[chunk_id]) {
				devs[chunk_id] = mle->sml_mm;
				ondisk[chunk_id] = metadata->ssd_ondisk;
d1343 2
a1344 1
				    DEVNAME(sc), ondisk[chunk_id], chunk_id);
d1348 1
a1348 1
		if (vol->sbv_chunk_no != vol->sbv_dev_no) {
d1351 1
a1351 1
			    DEVNAME(sc), vol->sbv_volid);
d1354 4
a1357 4
		bc.bc_level = vol->sbv_level;
		bc.bc_dev_list_len = vol->sbv_chunk_no * sizeof(dev_t);
		bc.bc_dev_list = devs;
		bc.bc_flags = BIOC_SCDEVT;
d1360 1
a1360 1
		sr_ioctl_createraid(sc, &bc, 0);
d1368 19
a1386 12
	for (vp1 = SLIST_FIRST(&bvh); vp1 != SLIST_END(&bvh); vp1 = vp2) {
		vp2 = SLIST_NEXT(vp1, sbv_link);
		for (mle1 = SLIST_FIRST(&vp1->sml);
		    mle1 != SLIST_END(&vp1->sml); mle1 = mle2) {
			mle2 = SLIST_NEXT(mle1, sml_link);
			free(mle1, M_DEVBUF);
		}
		free(vp1, M_DEVBUF);
	}
	for (mle = SLIST_FIRST(&mlh); mle != SLIST_END(&mlh); mle = mle2) {
		mle2 = SLIST_NEXT(mle, sml_link);
		free(mle, M_DEVBUF);
a1387 1
	SLIST_INIT(&mlh);
@


1.232
log
@Simplify softraid(4) to behave like other HBAs by using a single
scsibus(4) for all attached disks, rather than one scsibus(4) per
disk.  This takes advantage of recent improvements in the SCSI
midlayer to better support hotplug devices, and also decouples
softraid(4) from scsibus(4) device unit numbers.

ok jsing@@, dlg@@, krw@@, deraadt@@; marco@@'s still unconvinced
@
text
@d3391 1
a3391 1
	struct sr_softc		*sc = sd->sd_sc;
d3394 1
a3394 1
	if (!sd || !sc)
d3396 1
@


1.231
log
@Fix softraid(4) to set xs->cmd = &xs->cmdstore rather than pointing it
to a separately allocated SCSI command structure.

ok marco@@, jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.230 2011/05/03 17:08:51 matthew Exp $ */
d90 2
a91 1
void			sr_minphys(struct buf *bp, struct scsi_link *sl);
d171 1
a171 1
	sr_scsi_cmd, sr_minphys, NULL, NULL, sr_scsi_ioctl
d1636 1
d1661 12
d1927 1
a1927 1
	sd = sc->sc_dis[link->scsibus];
d1929 2
a1930 11
		s = splhigh();
		sd = sc->sc_attach_dis;
		splx(s);

		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: attaching %p\n",
		    DEVNAME(sc), sd);
		if (sd == NULL) {
			printf("%s: sr_scsi_cmd NULL discipline\n",
			    DEVNAME(sc));
			goto stuffup;
		}
a1955 13
	/* the midlayer will query LUNs so report sense to stop scanning */
	if (link->target != 0 || link->lun != 0) {
		DNPRINTF(SR_D_CMD, "%s: bad target:lun %d:%d\n",
		    DEVNAME(sc), link->target, link->lun);
		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x25;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto stuffup;
	}

d2031 22
d2141 1
a2141 1
	for (i = 0, vol = 0, disk = 0; i < SR_MAXSCSIBUS; i++)
d2163 1
a2163 1
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
d2230 1
a2230 1
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
d2303 1
a2303 1
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
d2367 1
a2367 1
	for (i = 0; i < SR_MAXSCSIBUS; i++) {
d2842 1
a2842 1
	int			i, s, no_chunk, rv = EINVAL, vol;
d2847 2
a2848 2
	struct device		*dev, *dev2;
	struct scsibus_attach_args saa;
d3041 1
a3041 1
		/* setup scsi midlayer */
a3043 12
		if (sd->sd_openings)
			sd->sd_link.openings = sd->sd_openings(sd);
		else
			sd->sd_link.openings = sd->sd_max_wu;
		sd->sd_link.device_softc = sc;
		sd->sd_link.adapter_softc = sc;
		sd->sd_link.adapter = &sr_switch;
		sd->sd_link.adapter_target = SR_MAX_LD;
		sd->sd_link.adapter_buswidth = 1;
		sd->sd_link.pool = &sd->sd_iopool;
		bzero(&saa, sizeof(saa));
		saa.saa_sc_link = &sd->sd_link;
d3050 16
d3069 7
a3075 12
		/* use temporary discipline pointer */
		s = splhigh();
		sc->sc_attach_dis = sd;
		splx(s);
		dev2 = config_found(&sc->sc_dev, &saa, scsiprint);
		s = splhigh();
		sc->sc_attach_dis = NULL;
		splx(s);
		TAILQ_FOREACH(dev, &alldevs, dv_list)
			if (dev->dv_parent == dev2)
				break;
		if (dev == NULL)
d3077 1
d3079 2
d3084 1
a3084 2
		sc->sc_dis[sd->sd_link.scsibus] = sd;
		for (i = 0, vol = -1; i <= sd->sd_link.scsibus; i++)
a3086 1
		sd->sd_scsibus_dev = dev2;
d3162 1
a3162 1
	for (i = 0; i < SR_MAXSCSIBUS; i++)
d3195 1
a3195 1
	for (i = 0; i < SR_MAXSCSIBUS; i++)
d3224 1
a3224 1
	for (i = 0; i < SR_MAXSCSIBUS; i++)
a3354 1
	int			i;
d3379 4
a3382 5
	for (i = 0; i < SR_MAXSCSIBUS; i++)
		if (sc->sc_dis[i] == sd) {
			sc->sc_dis[i] = NULL;
			break;
		}
d3418 2
a3419 2
	if (sd->sd_scsibus_dev)
		config_detach(sd->sd_scsibus_dev, DETACH_FORCE);
d3737 1
a3737 1
	for (i = 0; i < SR_MAXSCSIBUS; i++)
d4110 1
a4110 1
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
d4165 1
a4165 1
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
@


1.230
log
@Move SLIST initializations earlier so that failure handling paths can
safely use them.  Found by Clang.

"go for it" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.229 2011/04/29 13:04:38 dlg Exp $ */
d3890 1
a3890 1
	struct scsi_rw_16	cr, cw;
a3942 1
		bzero(&cr, sizeof cr);
d3947 6
a3952 5
		xs_r.cmdlen = 16;
		cr.opcode = READ_16;
		_lto4b(sz, cr.length);
		_lto8b(lba, cr.addr);
		xs_r.cmd = (struct scsi_generic *)&cr;
a3962 1
		bzero(&cw, sizeof cw);
d3967 6
a3972 5
		xs_w.cmdlen = 16;
		cw.opcode = WRITE_16;
		_lto4b(sz, cw.length);
		_lto8b(lba, cw.addr);
		xs_w.cmd = (struct scsi_generic *)&cw;
@


1.229
log
@tiny whitespace fixes
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.228 2011/04/29 13:03:12 dlg Exp $ */
d1088 2
a1130 3

	SLIST_INIT(&bvh);
	SLIST_INIT(&kdh);
@


1.228
log
@only handle vanilla scsi inquiry requests, reject VPD requests since theyre
not handled.

based on atascsi code.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.227 2011/04/14 02:11:23 marco Exp $ */
d1512 1
a1512 1
		     DEVNAME(sc));
d2558 1
a2558 1
	struct sr_ccb           *ccb;
@


1.227
log
@Ignore scsi start stop instead of trying to be clever.  A softraid
discipline should always reflect the correct status.  This fixes unexpected
state changes jordan saw.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.226 2011/04/06 15:36:13 marco Exp $ */
d3471 1
d3475 6
@


1.226
log
@fix installboot.

ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.225 2011/04/06 02:35:51 marco Exp $ */
a3572 1
	struct sr_discipline	*sd = wu->swu_dis;
a3574 1
	int			rv = 1;
d3580 1
a3580 1
		return (rv);
d3582 5
a3586 18
	if (ss->byte2 == 0x00) {
		/* START */
		if (sd->sd_vol_status == BIOC_SVOFFLINE) {
			/* bring volume online */
			/* XXX check to see if volume can be brought online */
			sd->sd_vol_status = BIOC_SVONLINE;
		}
		rv = 0;
	} else /* XXX is this the check? if (byte == 0x01) */ {
		/* STOP */
		if (sd->sd_vol_status == BIOC_SVONLINE) {
			/* bring volume offline */
			sd->sd_vol_status = BIOC_SVOFFLINE;
		}
		rv = 0;
	}

	return (rv);
@


1.225
log
@make rebuild also work in bigmem
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.224 2011/04/06 02:00:10 marco Exp $ */
d397 1
a397 1
	size_t			bufsize, bs;
d399 1
a399 1
	char			*dma_buf, *db;
d404 2
a405 5
	/* XXX this should be pre allocated */
	bs = size;
	db = dma_buf = dma_alloc(size, PR_WAITOK);
	if (flags == B_WRITE)
		bcopy(buf, db, bs);
d417 2
a420 1

d446 3
d450 1
a450 1
		dma_buf += bufsize;
a451 1

a453 3
	if (flags == B_READ)
		bcopy(db, buf, bs);

d460 1
a460 1
	dma_free(db, bs);
@


1.224
log
@handle bigmem for metadata reads and writes.  this should be pre allocated
but for now this allows us to move forward.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.223 2011/04/05 19:52:02 krw Exp $ */
d3937 2
a3938 1
	buf = malloc(SR_REBUILD_IO_SIZE << DEV_BSHIFT, M_DEVBUF, M_WAITOK);
d4057 1
a4057 1
	free(buf, M_DEVBUF);
@


1.223
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.222 2011/03/15 13:29:41 jsing Exp $ */
d397 1
a397 1
	size_t			bufsize;
d399 1
d404 6
d416 2
a417 2
		DNPRINTF(SR_D_MISC, "%s: buf %p, size %d, offset %llu)\n",
		    DEVNAME(sc), buf, size, offset);
d429 1
a429 1
		b.b_data = buf;
d449 1
a449 1
		buf += bufsize;
d454 3
d462 2
@


1.222
log
@Attach one sensordev per softraid device rather than one sensordev per
discipline. This results in a drive sensor being attached for each volume
under the same sensordev, instead of having multiple sensordevs each with
a single drive. Fixes PR6576.

Tested by Mattieu Baptiste.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.220 2011/01/23 14:21:20 jsing Exp $ */
d1808 1
a1808 1
		sr_wu_put(wu);
d1836 1
a1836 1
sr_wu_put(struct sr_workunit *wu)
d1838 2
a1839 1
	struct sr_discipline	*sd = wu->swu_dis;
a1846 13

	wu->swu_xs = NULL;
	wu->swu_state = SR_WU_FREE;
	wu->swu_ios_complete = 0;
	wu->swu_ios_failed = 0;
	wu->swu_ios_succeeded = 0;
	wu->swu_io_count = 0;
	wu->swu_blk_start = 0;
	wu->swu_blk_end = 0;
	wu->swu_collider = NULL;
	wu->swu_fake = 0;
	wu->swu_flags = 0;

d1848 1
a1848 1
		panic("%s: sr_wu_put", DEVNAME(sd->sd_sc));
d1853 3
d1857 1
d1859 1
d1862 1
a1862 10

	/* wake up sleepers */
#ifdef DIAGNOSTIC
	if (sd->sd_wu_sleep < 0)
		panic("negative wu sleepers");
#endif /* DIAGNOSTIC */
	if (sd->sd_wu_sleep)
		wakeup(&sd->sd_wu_sleep);

	splx(s);
d1865 2
a1866 2
struct sr_workunit *
sr_wu_get(struct sr_discipline *sd, int canwait)
d1868 1
a1869 1
	int			s;
d1871 5
a1875 15
	s = splbio();

	for (;;) {
		wu = TAILQ_FIRST(&sd->sd_wu_freeq);
		if (wu) {
			TAILQ_REMOVE(&sd->sd_wu_freeq, wu, swu_link);
			wu->swu_state = SR_WU_INPROGRESS;
			sd->sd_wu_pending++;
			break;
		} else if (wu == NULL && canwait) {
			sd->sd_wu_sleep++;
			tsleep(&sd->sd_wu_sleep, PRIBIO, "sr_wu_get", 0);
			sd->sd_wu_sleep--;
		} else
			break;
d1877 1
a1877 2

	splx(s);
d1900 1
d1926 8
a1933 9
	/*
	 * we'll let the midlayer deal with stalls instead of being clever
	 * and sending sr_wu_get !(xs->flags & SCSI_NOSLEEP) in cansleep
	 */
	if ((wu = sr_wu_get(sd, 0)) == NULL) {
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd no wu\n", DEVNAME(sc));
		xs->error = XS_NO_CCB;
		sr_scsi_done(sd, xs);
		return;
d1935 1
d1937 4
a1940 1
	xs->error = XS_NOERROR;
a2028 2
	if (wu)
		sr_wu_put(wu);
d3020 2
d3031 1
d3935 1
a3935 1
		if ((wu_r = sr_wu_get(sd, 1)) == NULL)
d3937 1
a3937 1
		if ((wu_w = sr_wu_get(sd, 1)) == NULL)
d4007 2
a4008 2
		sr_wu_put(wu_r);
		sr_wu_put(wu_w);
@


1.221
log
@spaces that make my eyes bleed. no binary change.
@
text
@d1643 6
d1659 6
a4080 3
	strlcpy(sd->sd_vol.sv_sensordev.xname, DEVNAME(sc),
	    sizeof(sd->sd_vol.sv_sensordev.xname));

d4086 2
a4087 1
	sensor_attach(&sd->sd_vol.sv_sensordev, &sd->sd_vol.sv_sensor);
a4093 1
	sensordev_install(&sd->sd_vol.sv_sensordev);
d4105 2
a4106 2
	if (sd->sd_vol.sv_sensor_valid)
		sensordev_deinstall(&sd->sd_vol.sv_sensordev);
@


1.220
log
@Factor out block level I/O handling code and correctly handle I/Os that
exceed MAXPHYS in size.

Thanks to ckuethe@@ and stsp@@ for testing.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.219 2011/01/22 15:23:45 jsing Exp $ */
a408 1
	
d877 1
a877 1
		/* 
d1233 1
a1233 1
	
d2322 1
a2322 1
		
d2325 1
a2325 1
		
d2512 1
a2512 1
	
d2610 2
a2611 2
        			TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
                			if (ccb->ccb_target == chunk_no)
d2616 2
a2617 2
        			TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
                			if (ccb->ccb_target == chunk_no)
a2810 1
		
a2811 1
	
@


1.219
log
@Ensure that boot storage area exists and is large enough, before
installing boot code.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.217 2010/12/20 17:47:48 krw Exp $ */
d130 2
d392 2
a393 2
sr_meta_rw(struct sr_discipline *sd, dev_t dev, void *md, size_t sz,
    daddr64_t ofs, long flags)
d395 1
a395 1
	struct sr_softc		*sc = sd->sd_sc;
d397 1
d400 2
a401 4
	DNPRINTF(SR_D_META, "%s: sr_meta_rw(0x%x, %p, %d, %llu 0x%x)\n",
	    DEVNAME(sc), dev, md, sz, ofs, flags);

	bzero(&b, sizeof(b));
d403 2
a404 2
	if (md == NULL) {
		printf("%s: read invalid metadata pointer\n", DEVNAME(sc));
d407 39
a445 25
	b.b_flags = flags | B_PHYS;
	b.b_blkno = ofs;
	b.b_bcount = sz;
	b.b_bufsize = sz;
	b.b_resid = sz;
	b.b_data = md;
	b.b_error = 0;
	b.b_proc = curproc;
	b.b_dev = dev;
	b.b_iodone = NULL;
	if (bdevvp(dev, &b.b_vp)) {
		printf("%s: sr_meta_rw: can't allocate vnode\n", DEVNAME(sc));
		goto done;
	}
	if ((b.b_flags & B_READ) == 0)
		b.b_vp->v_numoutput++;

	LIST_INIT(&b.b_dep);
	VOP_STRATEGY(&b);
	biowait(&b);

	if (b.b_flags & B_ERROR) {
		printf("%s: 0x%x i/o error on block %llu while reading "
		    "metadata %d\n", DEVNAME(sc), dev, b.b_blkno, b.b_error);
		goto done;
d447 1
d449 1
d451 2
a452 2
	if (b.b_vp)
		vput(b.b_vp);
d458 21
a3207 1
	struct buf		b;
d3262 3
a3264 28
		bzero(&b, sizeof(b));
		b.b_flags = B_WRITE | B_PHYS;
		b.b_blkno = SR_BOOT_BLOCKS_OFFSET;
		b.b_bcount = bbs;
		b.b_bufsize = bbs;
		b.b_resid = bbs;
		b.b_data = bootblk;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = chunk->src_dev_mm;
		b.b_vp = NULL;
		b.b_iodone = NULL;
		if (bdevvp(chunk->src_dev_mm, &b.b_vp)) {
			printf("%s: sr_ioctl_installboot: vnode allocation "
			    "failed\n", DEVNAME(sc));
			goto done;
		}
		if ((b.b_flags & B_READ) == 0)
			b.b_vp->v_numoutput++;
		LIST_INIT(&b.b_dep);
		VOP_STRATEGY(&b);
		biowait(&b);
		vput(b.b_vp);

		if (b.b_flags & B_ERROR) {
			printf("%s: 0x%x i/o error on block %llu while "
			    "writing boot block %d\n", DEVNAME(sc),
			    chunk->src_dev_mm, b.b_blkno, b.b_error);
d3273 4
a3276 28
		bzero(&b, sizeof(b));
		b.b_flags = B_WRITE | B_PHYS;
		b.b_blkno = SR_BOOT_LOADER_OFFSET;
		b.b_bcount = bls;
		b.b_bufsize = bls;
		b.b_resid = bls;
		b.b_data = bootldr;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = chunk->src_dev_mm;
		b.b_vp = NULL;
		b.b_iodone = NULL;
		if (bdevvp(chunk->src_dev_mm, &b.b_vp)) {
			printf("%s: sr_ioctl_installboot: vnode alocation "
			    "failed\n", DEVNAME(sc));
			goto done;
		}
		if ((b.b_flags & B_READ) == 0)
			b.b_vp->v_numoutput++;
		LIST_INIT(&b.b_dep);
		VOP_STRATEGY(&b);
		biowait(&b);
		vput(b.b_vp);

		if (b.b_flags & B_ERROR) {
			printf("%s: 0x%x i/o error on block %llu while "
			    "writing boot blocks %d\n", DEVNAME(sc),
			    chunk->src_dev_mm, b.b_blkno, b.b_error);
@


1.218
log
@more explicit_bzero to delete keys.

prodded and ok deraadt
@
text
@d3191 6
@


1.217
log
@READ CAPACITY and READ CAPACITY 16 commands report the last valid
logical block address, not the size of the device. Adjust softraid's
handling of the commands accordingly.

Fixes panics when newfs'ing the 'c' partition of a softraid volume
(one shouldn't newfs 'c' partitions of any device). Reported by
Andreas Bartlet via tech@@. Fix tested by Andreas.

ok marco@@. functionally identical diff developed by dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.216 2010/11/06 23:01:56 marco Exp $ */
d3383 1
@


1.216
log
@Move raid1 and crypto io to a workq.  This is to avoid a potential VOP_
call while in interrupt context.

Contains an additional spl dance as found by thib.

Tested by many opn various arches.  Note that raid 0/4/5/6 have not been
moved over yet.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.215 2010/10/12 00:53:32 krw Exp $ */
d3509 1
d3514 1
d3517 1
a3517 1
		if (sd->sd_meta->ssdi.ssd_size > 0xffffffffllu)
d3520 1
a3520 1
			_lto4b(sd->sd_meta->ssdi.ssd_size, rcd.addr);
d3526 1
a3526 1
		_lto8b(sd->sd_meta->ssdi.ssd_size, rcd16.addr);
@


1.215
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.214 2010/09/23 18:49:39 oga Exp $ */
d129 1
d1810 2
d2569 3
d2825 5
d3421 3
d3642 20
a3664 1
	struct sr_ccb		*ccb;
d3679 2
a3680 3
	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
		VOP_STRATEGY(&ccb->ccb_buf);
	}
@


1.214
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.213 2010/09/07 17:14:06 deraadt Exp $ */
d3476 1
@


1.213
log
@having a ca_activate function which just returns 1 is wrong on about 8 different levels; ok oga kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.212 2010/08/30 19:05:08 deraadt Exp $ */
d325 1
a325 1
			error = VOP_OPEN(vn, FREAD | FWRITE, NOCRED, 0);
d903 1
a903 1
	error = VOP_OPEN(vn, FREAD, NOCRED, 0);
d912 2
a913 1
	error = VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED, 0);
d917 1
a917 1
		VOP_CLOSE(vn, FREAD, NOCRED, 0);
d923 1
a923 1
	error = VOP_CLOSE(vn, FREAD, NOCRED, 0);
d961 1
a961 1
		error = VOP_OPEN(vn, FREAD, NOCRED, 0);
d973 1
a973 1
			VOP_CLOSE(vn, FREAD, NOCRED, 0);
d980 1
a980 1
			VOP_CLOSE(vn, FREAD, NOCRED, 0);
d1003 1
a1003 1
		VOP_CLOSE(vn, FREAD, NOCRED, 0);
d1372 1
a1372 1
	    NOCRED, 0);
d2378 1
a2378 1
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, 0)) {
d2388 2
a2389 1
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED, 0)) {
d2392 1
a2392 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d2503 1
a2503 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d2676 1
a2676 1
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, 0)) {
d2686 2
a2687 1
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED, 0)) {
d2751 1
a2751 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d3324 4
a3327 2
			vn_lock(ch_entry->src_vn, LK_EXCLUSIVE | LK_RETRY, 0);
			VOP_CLOSE(ch_entry->src_vn, FREAD | FWRITE, NOCRED, 0);
@


1.212
log
@fix tailq use; ok thib
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.211 2010/08/30 17:32:40 jsing Exp $ */
a78 1
int		sr_activate(struct device *, int);
a81 1
	sr_activate
a1614 6
}

int
sr_activate(struct device *self, int act)
{
	return (1);
@


1.211
log
@During boot probe walk disklist rather than alldevs. This avoids a race
where disks can be on alldevs, however they are not yet initialised and
have not yet called disk_attach() (in particular this means that dk_label
is a null pointer). Also, if we sleep restart the scan from the top of
the disklist in case things have changed whilst we slept.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.209 2010/07/02 09:26:05 jsing Exp $ */
d1044 1
a1044 1
	while (dk != TAILQ_END()) {
@


1.210
log
@explicitly specify flags to malloc and pool_get instead of relying on 0.
This is more clear, and as thib pointed out, the default in softraid was
wrong.  ok thib.
@
text
@d173 2
a174 2
int			sr_meta_native_bootprobe(struct sr_softc *,
			    struct device *, struct sr_metadata_list_head *);
d877 1
a877 1
sr_meta_native_bootprobe(struct sr_softc *sc, struct device *dv,
d886 2
a887 2
	dev_t			dev, devr;
	int			error, i, majdev;
a891 5
	majdev = findblkmajor(dv);
	if (majdev == -1)
		goto done;
	dev = MAKEDISKDEV(majdev, dv->dv_unit, RAW_PART);

d896 3
a898 2
	dev = MAKEDISKDEV(major(blktochr(dev)), dv->dv_unit, RAW_PART);
	if (cdevvp(dev, &vn)) {
d956 2
a957 2
		devr = MAKEDISKDEV(majdev, dv->dv_unit, i);
		if (bdevvp(devr, &vn)) {
d971 1
a971 1
		if (sr_meta_native_read(fake_sd, devr, md, NULL)) {
d986 2
a987 2
		sr_meta_getdevname(sc, devr, devname, sizeof(devname));
		if (sr_meta_validate(fake_sd, devr, md, NULL) == 0) {
d997 1
a997 1
				mle->sml_mm = devr;
d1020 3
a1022 1
	struct device		*dv;
d1040 1
d1043 10
a1052 2
	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class != DV_DISK)
d1054 9
d1065 3
a1067 2
		if (strcmp(dv->dv_cfdata->cf_driver->cd_name, "sd") &&
		    strcmp(dv->dv_cfdata->cf_driver->cd_name, "wd"))
d1069 1
d1072 3
a1074 2
		if (sr_meta_native_bootprobe(sc, dv, &mlh) == SR_META_CLAIMED)
			continue;
d1076 2
a1077 1
		/* probe non-native disks */
d1342 6
@


1.209
log
@Rename the volume specific flags variable.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.208 2010/07/02 09:20:26 jsing Exp $ */
d222 1
a222 1
	sd->sd_meta = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO);
d232 1
a232 1
		    M_DEVBUF, M_ZERO);
d609 1
a609 1
	m = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO);
d937 1
a937 1
	md = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO);
d945 2
a946 1
	fake_sd = malloc(sizeof(struct sr_discipline), M_DEVBUF, M_ZERO);
d1394 1
a1394 1
	md = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO);
@


1.208
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.206 2010/06/15 10:59:52 dlg Exp $ */
d540 1
a540 1
	sm->ssdi.ssd_flags = sd->sd_meta_flags;
d991 1
a991 1
			if (md->ssdi.ssd_flags & BIOC_SCNOAUTOASSEMBLE) {
d2418 1
a2418 1
	sm->ssdi.ssd_flags = 0;
d2949 3
a2951 3
	    (sd->sd_meta->ssdi.ssd_flags & BIOC_SCNOAUTOASSEMBLE)) {
		sd->sd_meta->ssdi.ssd_flags &= ~BIOC_SCNOAUTOASSEMBLE;
		sd->sd_meta->ssdi.ssd_flags |=
d3096 1
a3096 1
	sd->sd_meta->ssdi.ssd_flags = BIOC_SCNOAUTOASSEMBLE;
d3258 1
a3258 1
	sd->sd_meta->ssdi.ssd_flags |= BIOC_SCBOOTABLE;
d4141 1
a4141 1
	printf("\tssd_flags 0x%x\n", m->ssdi.ssd_flags);
@


1.207
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d541 1
d819 31
a849 1
	if (sm->ssdi.ssd_version != SR_META_VERSION) {
a853 1
	}
a854 4
	sr_checksum(sc, sm, &checksum, sizeof(struct sr_meta_invariant));
	if (bcmp(&checksum, &sm->ssd_checksum, sizeof(checksum))) {
		printf("%s: invalid metadata checksum\n", DEVNAME(sc));
		goto done;
a856 2
	/* XXX do other checksums */

d3744 3
@


1.206
log
@softraid doesnt provide disk cache settings to tweak, mark those ioctls as
not supported.

this prevents a panic caused by recursively entering the ioctl handler that
now happens on boot when sd tries to enable write cache on all disks.

found by ckeuthe@@
tested by todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.205 2010/06/15 04:11:34 dlg Exp $ */
a171 4
struct scsi_device sr_dev = {
	NULL, NULL, NULL, NULL
};

a2944 1
		sd->sd_link.device = &sr_dev;
@


1.205
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.204 2010/05/21 20:52:38 marco Exp $ */
d1970 7
a1976 1
	return (sr_ioctl(link->adapter_softc, cmd, addr));
@


1.204
log
@Make compile with NBIO = 0
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.203 2010/05/20 00:55:17 krw Exp $ */
d96 1
a96 1
			    caddr_t, int, struct proc *);
d1965 1
a1965 2
sr_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
@


1.203
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.202 2010/05/18 04:41:14 dlg Exp $ */
d1552 1
d1557 1
@


1.202
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.201 2010/03/28 16:38:57 jsing Exp $ */
a1819 2
	int			s;

a1821 1
	s = splbio();
a1822 1
	splx(s);
@


1.201
log
@Completely overhaul optional metadata handling, allowing for multiple
optional metadata per volume and discipline specific optional metadata
processing.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.196 2010/03/26 11:20:34 jsing Exp $ */
d43 1
@


1.200
log
@Avoid potential null dereferences in ioctl paths.

Found by jsg@@ using the clang static analyser.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.199 2010/03/28 09:08:32 jsing Exp $ */
d148 2
a470 1
		bzero(&ch_entry->src_opt, sizeof(ch_entry->src_opt));
a531 1
	struct sr_meta_opt	*im_so;
d559 2
d562 4
a565 6
		/* carry optional meta also in chunk area */
		im_so = &sd->sd_vol.sv_chunks[i]->src_opt;
		bzero(im_so, sizeof(*im_so));
		if (sd->sd_type == SR_MD_CRYPTO) {
			sm->ssdi.ssd_opt_no = 1;
			im_so->somi.som_type = SR_OPT_CRYPTO;
a566 7
			/*
			 * copy encrypted key / passphrase into optional
			 * metadata area
			 */
			bcopy(&sd->mds.mdd_crypto.scr_meta,
			    &im_so->somi.som_meta.smm_crypto,
			    sizeof(im_so->somi.som_meta.smm_crypto));
d568 2
a569 4
			sr_checksum(sc, im_so, im_so->som_checksum,
			    sizeof(struct sr_meta_opt_invariant));
		}
	}
d597 1
a617 3
	if (sm->ssdi.ssd_opt_no > 1)
		panic("not yet save > 1 optional metadata members");

d624 2
d628 2
a629 2
		cm = (struct sr_meta_chunk *)(m + 1);
		bcopy(&src->src_meta, cm + i, sizeof(*cm));
d632 4
a635 4
	/* optional metadata */
	om = (struct sr_meta_opt *)(cm + i);
	for (i = 0; i < sm->ssdi.ssd_opt_no; i++) {
		bcopy(&src->src_opt, om + i, sizeof(*om));
d638 1
d700 1
d703 1
a703 1
	int			no_disk = 0, got_meta = 0;
d753 16
a768 2
		if (sm->ssdi.ssd_opt_no > 1)
			panic("not yet read > 1 optional metadata members");
d770 1
a770 13
		if (sm->ssdi.ssd_opt_no) {
			om = (struct sr_meta_opt *) ((u_int8_t *)(sm + 1) +
			    sizeof(struct sr_meta_chunk) *
			    sm->ssdi.ssd_chunk_no);
			bcopy(om, &ch_entry->src_opt,
			    sizeof(ch_entry->src_opt));

			if (om->somi.som_type == SR_OPT_CRYPTO) {
				bcopy(
				    &ch_entry->src_opt.somi.som_meta.smm_crypto,
				    &sd->mds.mdd_crypto.scr_meta,
				    sizeof(sd->mds.mdd_crypto.scr_meta));
			}
d2412 1
d2772 1
d3292 2
d3312 6
@


1.199
log
@Replace a scsi_done() call with sr_scsi_done() which fixes a missing
splx() call.

Found by jsg@@ using the clang static analyser.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.198 2010/03/27 16:20:29 jsing Exp $ */
d2082 3
d2149 3
d2280 1
a2280 1
		if (!sc->sc_dis[i])
@


1.198
log
@Correctly initialise variable to prevent free without malloc in error path.

Found by clang static analyser.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.194 2010/02/13 22:10:01 jsing Exp $ */
d1873 1
a1873 2
		s = splbio();
		scsi_done(xs);
@


1.197
log
@Add an ioctl to softraid to allow the boot block and boot loader to be
installed on a softraid volume. This is work in progress but can continue
in tree.

ok marco@@
@
text
@d2300 1
a2300 1
	struct sr_chunk		*hotspare, *chunk, *last;
@


1.196
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d108 2
d2035 4
d3102 149
@


1.195
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1344 1
a1344 2
	size = DL_GETPSIZE(&label.d_partitions[part]) -
	    SR_META_SIZE - SR_META_OFFSET;
d2353 1
a2353 2
	size = DL_GETPSIZE(&label.d_partitions[part]) -
	    SR_META_SIZE - SR_META_OFFSET;
d2647 1
a2647 2
	size = DL_GETPSIZE(&label.d_partitions[part]) -
	    SR_META_SIZE - SR_META_OFFSET;
@


1.194
log
@Force chunks into correct order once metadata is attached. This prevents
chunks from being reordered on an existing volume.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.193 2010/02/13 21:23:36 jsing Exp $ */
d90 1
a90 1
int			sr_scsi_cmd(struct scsi_xfer *);
d1832 1
a1832 1
int
d1871 4
a1874 1
		return (NO_CCB);
d1956 1
a1956 1
	return (SUCCESSFULLY_QUEUED);
a1968 1
	return (COMPLETE);
@


1.193
log
@Unbreak automatic rebuilds from hotspares.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.192 2010/02/13 21:19:26 jsing Exp $ */
d215 1
a215 1
	struct sr_chunk		*ch_entry;
d254 21
d1398 2
@


1.192
log
@Removed unused variable sml_vn.

ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.191 2010/02/13 21:16:10 jsing Exp $ */
d123 1
a123 1
int			sr_rebuild_init(struct sr_discipline *, dev_t);
d2224 1
a2224 1
		rv = sr_rebuild_init(sd, (dev_t)bs->bs_other_id);
d2525 1
a2525 1
		if (sr_rebuild_init(sd, hotspare->src_dev_mm) == 0) {
d2541 1
a2541 1
sr_rebuild_init(struct sr_discipline *sd, dev_t dev)
d2636 2
a2637 1
	if (c != BIOC_SDINVALID && c != BIOC_SDOFFLINE) {
@


1.191
log
@Pass the number of chunks to sr_meta_attach() rather than recalculating.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.189 2010/01/09 23:15:06 krw Exp $ */
a961 1
				mle->sml_vn = vn;
a1148 1
		hotspare->src_vn = mle->sml_vn;
@


1.190
log
@Use character raw device to read disklabel during bootprobe, as all
other devices do. Silences complaints about missing media on removable
media devices.

ok marco@@ jsing@@
@
text
@d138 1
a138 1
int			sr_meta_attach(struct sr_discipline *, int);
d211 1
a211 1
sr_meta_attach(struct sr_discipline *sd, int force)
d242 1
a242 4
	SLIST_FOREACH(ch_entry, cl, src_link) {
		i++;
	}
	sd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *) * i,
d2769 1
a2769 1
	if (sr_meta_attach(sd, bc->bc_flags & BIOC_SCFORCE)) {
@


1.189
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.188 2009/12/31 14:00:45 jsing Exp $ */
d860 7
a866 1
	if (bdevvp(dev, &vn)) {
@


1.188
log
@Add support for key disks. This allows a crypto volume to be constructed
without using a passphrase - instead the encryption mask key is stored on
the specified key disk partition (ideally being one on a removable device).
This also enables automatic assembly of crypto volumes at boot time.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.184 2009/12/07 14:33:38 jsing Exp $ */
a1936 1
		xs->flags |= ITSDONE;
@


1.187
log
@Allow auto assemble flag to be toggled for disciplines that support it.

"Love it!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.186 2009/12/15 13:19:37 jsing Exp $ */
a138 2
void			sr_meta_getdevname(struct sr_softc *, dev_t, char *,
			    int);
a141 3
int			sr_meta_read(struct sr_discipline *);
int			sr_meta_validate(struct sr_discipline *, dev_t,
			    struct sr_metadata *, void *);
a178 2
int			sr_meta_native_read(struct sr_discipline *, dev_t,
			    struct sr_metadata *, void *);
a206 1
#define SR_META_F_NATIVE	0
a207 1
#define SR_META_F_INVALID	-1
d984 1
a984 1
	struct sr_metadata_list_head mlh;
d1021 1
d1023 2
d1033 6
d1187 2
d1202 17
a1252 1
		bzero(&bc, sizeof(bc));
d2058 7
d2118 10
a2127 1
		if (id >= sc->sc_dis[i]->sd_meta->ssdi.ssd_chunk_no)
a2129 1
		src = sc->sc_dis[i]->sd_vol.sv_chunks[id];
d2800 5
d3059 1
a3059 1
	    dr->bd_dev);
@


1.186
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.185 2009/12/15 13:04:04 jsing Exp $ */
d533 1
d2852 9
@


1.185
log
@Explicitly lock the vnode when deleting a volume. This avoids a potential
panic that is caused by vnode aliasing, where checkalias() switches the
vnode ops for our vnode. This means that we end up using ufs unlocking
rather than specfs unlocking (which is a no-op).

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.184 2009/12/07 14:33:38 jsing Exp $ */
a2683 2
	u_int64_t		vol_size;
	int32_t			strip_size = 0;
d2705 1
d2708 4
d2762 3
a2764 81
		/* no metadata available */
		switch (bc->bc_level) {
		case 0:
			if (no_chunk < 2)
				goto unwind;
			strlcpy(sd->sd_name, "RAID 0", sizeof(sd->sd_name));
			/*
			 * XXX add variable strip size later even though
			 * MAXPHYS is really the clever value, users like
			 * to tinker with that type of stuff
			 */
			strip_size = MAXPHYS;
			vol_size =
			    (ch_entry->src_meta.scmi.scm_coerced_size & 
			    ~((strip_size >> DEV_BSHIFT) - 1)) * no_chunk;
			break;
		case 1:
			if (no_chunk < 2)
				goto unwind;
			strlcpy(sd->sd_name, "RAID 1", sizeof(sd->sd_name));
			vol_size = ch_entry->src_meta.scmi.scm_coerced_size;
			break;
		case 4:
		case 5:
			if (no_chunk < 3)
				goto unwind;
			if (bc->bc_level == 4)
				strlcpy(sd->sd_name, "RAID 4",
				    sizeof(sd->sd_name));
			else
				strlcpy(sd->sd_name, "RAID 5",
				    sizeof(sd->sd_name));
			/*
			 * XXX add variable strip size later even though
			 * MAXPHYS is really the clever value, users like
			 * to tinker with that type of stuff
			 */
			strip_size = MAXPHYS;
			vol_size = 
			    (ch_entry->src_meta.scmi.scm_coerced_size & 
			    ~((strip_size >> DEV_BSHIFT) - 1)) * (no_chunk - 1);
			break;
//#ifdef not_yet
		case 6:
			if (no_chunk < 4)
				goto unwind;
			strlcpy(sd->sd_name, "RAID 6",
			    sizeof(sd->sd_name));
			/*
			 * XXX add variable strip size later even though
			 * MAXPHYS is really the clever value, users like
			 * to tinker with that type of stuff
			 */
			strip_size = MAXPHYS;
			vol_size = 
			    (ch_entry->src_meta.scmi.scm_coerced_size & 
			    ~((strip_size >> DEV_BSHIFT) - 1)) * (no_chunk - 2);
			break;
//#endif /* not_yet */
#ifdef AOE
#ifdef not_yet
		case 'A':
			/* target */
			if (no_chunk != 1)
				goto unwind;
			strlcpy(sd->sd_name, "AOE TARG", sizeof(sd->sd_name));
			vol_size = ch_entry->src_meta.scmi.scm_coerced_size;
			break;
		case 'a':
			/* initiator */
			if (no_chunk != 1)
				goto unwind;
			strlcpy(sd->sd_name, "AOE INIT", sizeof(sd->sd_name));
			break;
#endif /* not_yet */
#endif /* AOE */
#ifdef CRYPTO
		case 'C':
			DNPRINTF(SR_D_IOCTL,
			    "%s: sr_ioctl_createraid: no_chunk %d\n",
			    DEVNAME(sc), no_chunk);
d2766 4
a2769 7
			if (no_chunk != 1)
				goto unwind;

			/* no hint available yet */
			if (bc->bc_opaque_flags & BIOC_SOOUT) {
				bc->bc_opaque_status = BIOC_SOINOUT_FAILED;
				rv = 0;
a2771 16

			if (!(bc->bc_flags & BIOC_SCNOAUTOASSEMBLE))
				goto unwind;

			if (sr_crypto_get_kdf(bc, sd))
				goto unwind;

			strlcpy(sd->sd_name, "CRYPTO", sizeof(sd->sd_name));
			vol_size = ch_entry->src_meta.scmi.scm_size;

			sr_crypto_create_keys(sd);

			break;
#endif /* CRYPTO */
		default:
			goto unwind;
d2777 1
a2777 6
		    DEVNAME(sc), vol_size);
		sd->sd_meta->ssdi.ssd_chunk_no = no_chunk;
		sd->sd_meta->ssdi.ssd_size = vol_size;
		sd->sd_vol_status = BIOC_SVONLINE;
		sd->sd_meta->ssdi.ssd_level = bc->bc_level;
		sd->sd_meta->ssdi.ssd_strip_size = strip_size;
a2803 5
#ifdef CRYPTO
		/* provide userland with kdf hint */
		if (bc->bc_opaque_flags & BIOC_SOOUT) {
			if (bc->bc_opaque == NULL)
				goto unwind;
d2805 3
a2807 6
			if (sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint) <
			    bc->bc_opaque_size)
				goto unwind;

			if (copyout(sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
			    bc->bc_opaque, bc->bc_opaque_size))
d2809 2
a2811 11
			/* we're done */
			bc->bc_opaque_status = BIOC_SOINOUT_OK;
			rv = 0;
			goto unwind;
		}
		/* get kdf with maskkey from userland */
		if (bc->bc_opaque_flags & BIOC_SOIN) {
			if (sr_crypto_get_kdf(bc, sd))
				goto unwind;
		}
#endif	/* CRYPTO */
d2827 8
a2847 5
	if (sr_discipline_init(sd, sd->sd_meta->ssdi.ssd_level)) {
		printf("%s: could not initialize discipline\n", DEVNAME(sc));
		goto unwind;
	}

d2962 4
@


1.184
log
@Cleanup discipline initialisation.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.183 2009/12/07 14:27:12 jsing Exp $ */
d3155 6
@


1.183
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.181 2009/11/23 16:33:59 jsing Exp $ */
d3249 2
d3252 1
a3252 5
		if (level == 4)
			sd->sd_type = SR_MD_RAID4;
		else
			sd->sd_type = SR_MD_RAID5;
		sr_raidp_discipline_init(sd);
a3254 1
		sd->sd_type = SR_MD_RAID6;
@


1.182
log
@Allow the passphrase to be changed on softraid crypto volumes. Ensure that
you backup your data and lock up your pets prior to using this.

Tested by todd@@

ok marco@@
@
text
@d2522 1
a2522 1
	if (!sd->sd_rebuild) {
d2683 1
a2683 1
	int			no_meta, updatemeta = 0, disk = 1;
d2965 1
a2965 1
	if (disk) {
@


1.181
log
@Improve discipline specific ioctl framework and attach to softraid ioctl.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.179 2009/11/22 16:56:06 jsing Exp $ */
a118 2
void			sr_checksum(struct sr_softc *, void *, void *,
			    u_int32_t);
a144 1
int			sr_meta_save(struct sr_discipline *, u_int32_t);
@


1.180
log
@Add a framework for discipline specific ioctls.

ok marco@@
@
text
@d106 2
a107 1
int			sr_ioctl_discipline(struct sr_softc *, u_long, caddr_t);
d1988 5
d3115 1
a3115 1
sr_ioctl_discipline(struct sr_softc *sc, u_long cmd, caddr_t addr)
a3117 1
	struct bio_device	*bc = (struct bio_device *)addr;
d3128 1
a3128 1
			    bc->dev,
d3136 1
a3136 1
		rv = sd->sd_ioctl_handler(sd, cmd, addr);
@


1.179
log
@Ensure that chunks are not already in use when creating a volume.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.176 2009/10/28 15:22:23 marco Exp $ */
d106 1
d3105 28
@


1.178
log
@Fix memory leak in error case. Found by Parfait.

ok marco@@ deraadt@@
@
text
@d2687 1
d2709 10
@


1.177
log
@When probing devices at boot, compare against the full device driver name
rather than the start of the device name. Also, be inclusive with devices
probed rather than exclusive - this means we now only look for RAID
partitions on sd(4) and wd(4) devices.

prodded by deraadt@@

ok marco@@ deraadt@@
@
text
@d855 2
a856 2
	struct sr_metadata	*md;
	struct sr_discipline	*fake_sd;
d916 1
a916 1
		goto nosd;
a978 3
	free(fake_sd, M_DEVBUF);
nosd:
	free(md, M_DEVBUF);
d980 5
@


1.176
log
@Remove FWRITE from closes that aren't opened with FWRITE.
spotted and ok jsing
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.175 2009/10/13 19:33:16 pirofti Exp $ */
d1013 3
a1015 4
		/* XXX is there  a better way of excluding some devices? */
		if (!strncmp(dv->dv_xname, "fd", 2) ||
		    !strncmp(dv->dv_xname, "cd", 2) ||
		    !strncmp(dv->dv_xname, "rx", 2))
@


1.175
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.174 2009/09/21 16:38:13 marco Exp $ */
d889 1
a889 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d895 1
a895 1
	error = VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
@


1.174
log
@Fix use before init on wu.

Found by jsing, tested and ok jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.173 2009/09/03 13:26:38 jsing Exp $ */
d78 1
a78 1
int		sr_activate(struct device *, enum devact);
d1531 1
a1531 1
sr_activate(struct device *self, enum devact act)
@


1.173
log
@Check the return value of copyin().

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.172 2009/09/03 13:20:29 jsing Exp $ */
d1795 1
a1795 1
	struct sr_workunit	*wu;
a1809 1
			wu = NULL;
@


1.172
log
@Don't call VOP_CLOSE() with a null pointer, if the VOP_OPEN() call failed.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.170 2009/08/09 14:12:25 marco Exp $ */
d2696 4
a2699 3
	if (user)
		copyin(bc->bc_dev_list, dt, bc->bc_dev_list_len);
	else
@


1.171
log
@the null check makes more sense when it's done before deref
ok marco@@, jsing@@
@
text
@a321 1
				/* dev isn't open but will be closed anyway */
a3098 1
	dev_t			dev;
a3108 1
		dev = ch_entry->src_dev_mm;
d3111 1
a3111 1
		if (dev != NODEV) {
@


1.170
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.169 2009/07/31 16:05:25 jsing Exp $ */
d3126 1
a3126 1
	struct sr_softc		*sc = sd->sd_sc;
d3131 2
@


1.169
log
@Factor out code for checking if a chunk is already in use.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.167 2009/07/12 21:48:03 jsing Exp $ */
d276 1
a276 1
	struct bdevsw		*bdsw;
d308 5
a312 1
			bdsw = bdevsw_lookup(dev);
d318 1
a318 2
			error = bdsw->d_open(dev, FREAD | FWRITE, S_IFBLK,
			    curproc);
d323 1
d328 2
a329 1
			   sizeof(ch_entry->src_devname));
d393 2
a398 2

	bzero(&b, sizeof(b));
a407 1
	b.b_vp = NULL;
d409 7
d417 1
a417 1
	bdevsw_lookup(b.b_dev)->d_strategy(&b);
d427 3
d854 1
a854 1
	struct bdevsw		*bdsw;
d870 5
a874 8
	bdsw = &bdevsw[majdev];

	/*
	 * The devices are being opened with S_IFCHR instead of
	 * S_IFBLK so that the SCSI mid-layer does not whine when
	 * media is not inserted in certain devices like zip drives
	 * and such.
	 */
d877 1
a877 1
	error = (*bdsw->d_open)(dev, FREAD, S_IFCHR, curproc);
d881 1
d886 1
a886 2
	error = (*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label, FREAD,
	    curproc);
d890 2
a891 1
		error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
d896 1
a896 1
	error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
d900 1
d903 1
d928 6
a933 1
		error = (*bdsw->d_open)(devr, FREAD, S_IFCHR, curproc);
d938 1
d945 2
d951 3
a953 1
		if (md->ssdi.ssd_magic != SR_MAGIC)
d955 2
d969 1
d976 2
a977 6
		error = (*bdsw->d_close)(devr, FREAD, S_IFCHR, curproc);
		if (error) {
			DNPRINTF(SR_D_META, "%s: sr_meta_native_bootprobe "
			    "close failed\n", DEVNAME(sc));
			continue;
		}
d1147 1
a1278 2
	struct bdevsw		*bdsw;
	dev_t			dev;
a1282 1
	dev = ch_entry->src_dev_mm;
d1284 1
a1284 2
	bdsw = bdevsw_lookup(dev);
	part = DISKPART(dev);
d1287 2
a1288 1
	error = bdsw->d_ioctl(dev, DIOCGDINFO, (void *)&label, FREAD, curproc);
d2130 1
a2130 1
	int			i, vol;
d2132 2
d2157 24
d2236 1
a2236 1
	struct bdevsw		*bdsw;
d2263 5
a2267 2
	bdsw = bdevsw_lookup(dev);
	if (bdsw->d_open(dev, FREAD | FWRITE, S_IFBLK, curproc)) {
d2270 1
d2277 1
a2277 2
	if ((*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label, FREAD,
	    curproc)) {
d2280 2
d2303 1
d2390 4
a2393 2
	if (open)
		(*bdsw->d_close)(dev, FREAD | FWRITE, S_IFCHR, curproc);
d2510 1
a2510 1
	struct bdevsw		*bdsw;
d2558 5
a2562 1
	bdsw = bdevsw_lookup(dev);
d2564 1
a2564 1
	if (bdsw->d_open(dev, FREAD | FWRITE, S_IFBLK, curproc)) {
d2567 1
d2574 1
a2574 2
	if ((*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label, FREAD,
	    curproc)) {
d2610 1
d2637 4
a2640 2
	if (open)
		(*bdsw->d_close)(dev, FREAD | FWRITE, S_IFCHR, curproc);
d2786 1
a2786 1
#ifdef not_yet
d2802 1
a2802 1
#endif /* not_yet */
d3114 4
a3117 4
		if (dev != NODEV)
			bdevsw_lookup(dev)->d_close(dev, FWRITE, S_IFBLK,
			    curproc);

d3427 1
a3427 1
		bdevsw_lookup(ccb->ccb_buf.b_dev)->d_strategy(&ccb->ccb_buf);
@


1.168
log
@Adding disabled framework for RAID6
ok marco@@
@
text
@d127 1
d2153 27
d2182 1
a2182 1
	struct sr_discipline	*sw, *sd = NULL;
d2193 1
a2193 1
	int			i, c, part, open = 0;
d2202 7
a2208 18
	for (i = 0; i < SR_MAXSCSIBUS; i++) {
		if (!sc->sc_dis[i])
			continue;
		sw = sc->sc_dis[i];
		for (c = 0; c < sw->sd_meta->ssdi.ssd_chunk_no; c++)
			if (sw->sd_vol.sv_chunks[c]->src_dev_mm == dev &&
			    sw->sd_vol.sv_chunks[c]->src_meta.scm_status !=
			        BIOC_SDOFFLINE) {
				printf("%s: %s chunk already in use\n",
				    DEVNAME(sc), devname);
				goto done;
			}
	}

	/* Check hotspares list. */
	SLIST_FOREACH(hotspare, &sc->sc_hotspare_list, src_link) {
		if (hotspare->src_dev_mm == dev) {
			printf("%s: %s chunk is already a hotspare\n",
d2210 1
a2210 2
			goto done;
		}
d2453 1
a2453 2
	int			i, c, found, vol, open = 0;
	struct sr_discipline	*sw = NULL;
d2539 4
a2542 12
	for (i = 0, vol = -1; i < SR_MAXSCSIBUS; i++) {
		if (!sc->sc_dis[i])
			continue;
		sw = sc->sc_dis[i];
		for (c = 0; c < sw->sd_meta->ssdi.ssd_chunk_no; c++)
			if (sw->sd_vol.sv_chunks[c]->src_dev_mm == dev &&
			    sd->sd_vol.sv_chunks[c]->src_meta.scm_status !=
			        BIOC_SDOFFLINE) {
				printf("%s: %s chunk already in use\n",
				    DEVNAME(sc), devname);
				goto done;
			}
@


1.167
log
@Assert copyright.

suggested by and ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.166 2009/07/12 21:46:36 jsing Exp $ */
d2717 17
d3144 4
@


1.166
log
@Fix rebuild percentage so that it ranges from 0-99% rather than 1-100%.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.165 2009/07/12 16:31:56 jsing Exp $ */
d3 1
a3 1
 * Copyright (c) 2007 Marco Peereboom <marco@@peereboom.us>
d5 1
@


1.165
log
@Add support for global hotspares to softraid.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.164 2009/07/12 13:30:59 jsing Exp $ */
d2016 5
a2020 1
			bv->bv_percent = 100 - ((sz * 100 - rb * 100) / sz);
d3585 4
a3588 1
		percent = 100 - ((psz * 100 - rb * 100) / psz);
d3685 4
a3688 1
		percent = 100 - ((psz * 100 - rb * 100) / psz);
@


1.164
log
@If devices have roamed, complain once then update the metadata, just like
we do for roaming volumes.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.161 2009/06/26 14:50:44 jsing Exp $ */
d120 2
d972 3
d1091 3
d1096 70
d1485 1
d1488 1
d1987 2
a1988 2
	bi->bi_novol = vol;
	bi->bi_nodisk = disk;
d1998 1
d2023 19
a2041 1
		break;
d2044 1
d2052 1
a2052 1
	struct sr_chunk		*src;
d2073 20
a2092 1
		break;
d2095 1
d2109 5
a2132 3
	case BIOC_SSHOTSPARE:
		break;

d2147 281
d2557 1
a2557 1
	printf("%s: trying to rebuild %s to %s\n", DEVNAME(sc),
@


1.163
log
@Ensure that we hold the appropriate lock before calling
sr_ioctl_createraid().

ok marco@@
@
text
@d123 1
d770 1
d772 1
d813 1
d818 4
a821 2
		printf("%s: roaming device %s -> %s\n", DEVNAME(sc),
		    mc[sm->ssdi.ssd_chunk_id].scmi.scm_devname, devname);
d2168 30
d2530 4
@


1.162
log
@Be sure we don't hit a NULL deref.  Pointed out by
remco at d-compu dot dyndns dot org.

OK marco@@
@
text
@d1129 2
d1132 1
@


1.161
log
@Overhaul sr_boot_assembly(). The original code had a number of problems,
including a "chunk id already in use" bug that occurred when assembling
more than one volume at boot. Volumes are now kept in order, as are the
chunks which they are assembled from. Duplicated chunk IDs are now handled
appropriately, with the chunk that has the most recent ondisk metadata
being used.

Also tested by nicm@@ who got bitten by the "chunk id already in use" bug.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.160 2009/06/24 12:08:15 jsing Exp $ */
d1802 1
a1802 1
	if (sd->sd_scsi_sense.error_code) {
@


1.160
log
@Reset the rebuild counter when initiating a rebuild.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.159 2009/06/24 12:06:00 jsing Exp $ */
d958 1
d960 9
a968 5
	struct sr_metadata_list *mle, *mle2;
	struct sr_metadata	*m1, *m2;
	struct bioc_createraid	bc;
	int			rv = 0, no_dev, i;
	dev_t			*dt = NULL;
d992 1
a992 3
	 * XXX poor mans hack that doesn't keep disks in order and does not
	 * roam disks correctly.  replace this with something smarter that
	 * orders disks by volid, chunkid and uuid.
d994 71
a1064 7
	dt = malloc(BIOC_CRMAXLEN * sizeof(dev_t), M_DEVBUF, M_WAITOK);
	for (i = 0; i < BIOC_CRMAXLEN; i++)
		dt[i] = NODEV; /* mark device as illegal */
	SLIST_FOREACH(mle, &mlh, sml_link) {
		/* chunk used already? */
		if (mle->sml_used)
			continue;
d1066 13
a1078 6
		no_dev = 0;
		m1 = (struct sr_metadata *)&mle->sml_metadata;
		SLIST_FOREACH(mle2, &mlh, sml_link) {
			/* chunk used already? */
			if (mle2->sml_used)
				continue;
d1080 1
a1080 1
			m2 = (struct sr_metadata *)&mle2->sml_metadata;
d1082 12
a1093 3
			/* are we the same volume? */
			if (m1->ssdi.ssd_volid != m2->ssdi.ssd_volid)
				continue;
d1095 12
a1106 4
			/* same uuid? */
			if (bcmp(&m1->ssdi.ssd_uuid, &m2->ssdi.ssd_uuid,
			    sizeof(m1->ssdi.ssd_uuid)))
				continue;
d1108 7
a1114 5
			/* sanity */
			if (dt[m2->ssdi.ssd_chunk_id] != NODEV) {
				printf("%s: chunk id already in use; can not "
				    "assemble volume\n", DEVNAME(sc));
				goto unwind;
a1115 3
			dt[m2->ssdi.ssd_chunk_id] = mle2->sml_mm;
			no_dev++;
			mle2->sml_used = 1;
d1117 2
a1118 1
		if (m1->ssdi.ssd_chunk_no != no_dev) {
d1121 1
a1121 2
			    DEVNAME(sc), m1->ssdi.ssd_volid);
			no_dev = m1->ssdi.ssd_chunk_no;
d1125 3
a1127 3
		bc.bc_level = m1->ssdi.ssd_level;
		bc.bc_dev_list_len = no_dev * sizeof(dev_t);
		bc.bc_dev_list = dt;
d1130 1
d1136 9
d1151 4
a1154 2
	if (dt)
		free(dt, M_DEVBUF);
@


1.159
log
@Abort the current rebuild if the rebuild chunk disappears. Whilst here also
rename the abort flag so that it is more generalised.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.158 2009/06/23 15:54:44 jsing Exp $ */
d2018 3
@


1.158
log
@Make sure that the metadata level matches the requested assembly level when
creating a volume.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.157 2009/06/23 15:51:35 jsing Exp $ */
d2043 1
d2885 1
a2885 1
	sd->sd_going_down = 1;
d3135 1
a3135 1
		if (sd->sd_going_down)
@


1.157
log
@Fix some more whitespace issues.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.155 2009/06/18 15:51:56 jsing Exp $ */
d2295 8
a2302 1
	if (sr_discipline_init(sd, bc->bc_level)) {
@


1.156
log
@Either jordan or jsing left some debug prints behind.  tsk tsk.

pointed out by todd.
@
text
@d209 1
a209 1
	  sr_meta_native_read , sr_meta_native_write, NULL },
d226 1
a226 1
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_ZERO);
d431 1
a431 1
	m = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK | M_ZERO);
d688 1
a688 1
		fm = malloc(s->smd_size , M_DEVBUF, M_WAITOK | M_ZERO);
d859 1
a859 1
		    "failed\n" , DEVNAME(sc));
d881 1
a881 1
	md = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_ZERO);
d889 1
a889 1
	fake_sd = malloc(sizeof(struct sr_discipline) , M_DEVBUF, M_ZERO);
d1086 1
a1086 1
		    "%s: %s partition not of type RAID (%d)\n", DEVNAME(sc) ,
d1988 1
a1988 1
		    DEVNAME(sc) , devname,
@


1.155
log
@Check the set state status rather than always assuming a rebuild has been
requested. Also move the rebuild initialisation code into a separate
function whilst here.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.154 2009/06/18 15:47:38 jsing Exp $ */
a1179 2
			printf("ch %p %p\n", ch_entry, md);
			printf("mm %x\n", ch_entry->src_dev_mm);
@


1.154
log
@Fix some typos and whitespace issues.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.152 2009/06/17 22:44:42 marco Exp $ */
d120 1
d1873 3
a1875 9
	int			rv = EINVAL, part;
	int			i, c, found, vol, open = 0;
	struct sr_discipline	*sd = NULL, *sw = NULL;
	char			devname[32];
	struct bdevsw		*bdsw;
	dev_t			dev;
	daddr64_t		size, csize;
	struct disklabel	label;
	struct sr_meta_chunk	*old, *new;
d1892 40
a1969 1
	dev = (dev_t)bs->bs_other_id;
@


1.153
log
@Enabled EXPERIMENTAL RAID4/5 discipline
ok marco@@
@
text
@d472 1
a472 1
		bcopy(&uuid,  &ch_entry->src_meta.scmi.scm_uuid,
d589 1
a589 1
	m = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_ZERO);
d626 1
a626 1
		/* calculate metdata checksum for correct chunk */
d654 1
a654 1
	/* not al disciplines have sync */
d1123 1
a1123 1
	md = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_ZERO);
@


1.152
log
@Make openings variable instead of maxwu; needed for more exotic raid sets.
ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.151 2009/06/17 19:05:26 jordan Exp $ */
a2111 1
#ifdef not_yet
a2131 1
#endif /* not_yet */
@


1.151
log
@Force Raid0/4/5 volume size to multiple of stripe size
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.150 2009/06/12 17:22:52 jsing Exp $ */
d2284 4
a2287 1
		sd->sd_link.openings = sd->sd_max_wu;
@


1.150
log
@KNF and wrap at 80 columns.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.149 2009/06/12 16:00:25 jsing Exp $ */
d2103 2
a2104 1
			    ch_entry->src_meta.scmi.scm_coerced_size * no_chunk;
d2129 3
a2131 2
			vol_size = ch_entry->src_meta.scmi.scm_coerced_size *
			    (no_chunk - 1);
@


1.149
log
@Allow chunks marked as offline to be used for rebuild (ie. once disk has
been replaced).

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.147 2009/06/10 21:37:17 marco Exp $ */
d2117 2
a2118 1
				strlcpy(sd->sd_name, "RAID 4", sizeof(sd->sd_name));
d2120 2
a2121 1
				strlcpy(sd->sd_name, "RAID 5", sizeof(sd->sd_name));
d2128 2
a2129 2
			vol_size =
			    ch_entry->src_meta.scmi.scm_coerced_size * (no_chunk - 1);
@


1.148
log
@Create a hotplug callback mechanism.
@
text
@d1978 3
a1980 1
			if (sw->sd_vol.sv_chunks[c]->src_dev_mm == dev) {
@


1.147
log
@Typo
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.146 2009/06/10 03:24:02 marco Exp $ */
d147 24
d1233 19
a1251 3
struct scsi_adapter sr_switch = {
	sr_scsi_cmd, sr_minphys, NULL, NULL, sr_scsi_ioctl
};
d1253 4
a1256 3
struct scsi_device sr_dev = {
	NULL, NULL, NULL, NULL
};
d1258 2
a1259 1
void sr_disk_attach(struct disk *, int);
d1261 11
a1271 1
extern void (*softraid_disk_attach)(struct disk *, int);
d1276 5
a1280 8
	switch (action) {
	case 1:
		/* disk arrived */
		break;
	case -1:
		/* disk departed */
		break;
	}
d1298 2
d2366 2
d2477 2
@


1.146
log
@Add framework for raid 4 & 5 so that we can work in tree.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.145 2009/06/03 21:04:36 marco Exp $ */
d2063 1
a2063 1
			id ((bc->bc_level == 4)
@


1.145
log
@Slay the running out of wu during rebuild dragon and some cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.144 2009/06/03 17:39:26 ckuethe Exp $ */
d1951 1
d2058 19
d2461 8
@


1.144
log
@whitespace. "Sure" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.143 2009/06/03 06:30:10 marco Exp $ */
d1473 8
d1485 1
a1485 1
sr_wu_get(struct sr_discipline *sd)
d1492 13
a1504 4
	wu = TAILQ_FIRST(&sd->sd_wu_freeq);
	if (wu) {
		TAILQ_REMOVE(&sd->sd_wu_freeq, wu, swu_link);
		wu->swu_state = SR_WU_INPROGRESS;
a1505 1
	sd->sd_wu_pending++;
d1560 5
a1564 1
	if ((wu = sr_wu_get(sd)) == NULL) {
d1954 1
a1954 1
	printf("%s: trying rebuild %s from %s\n", DEVNAME(sc),
d2889 9
d2916 2
a2917 2
		/* XXX be nicer than panic */
		if ((wu_r = sr_wu_get(sd)) == NULL)
d2919 2
d2934 1
a2934 1
		wu_r->swu_flags = SR_WUF_REBUILD;
d2936 5
a2940 7
		/* XXX be nicer than panic */
		if (sd->sd_scsi_rw(wu_r))
			panic("read failed");

		/* XXX be nicer than panic */
		if ((wu_w = sr_wu_get(sd)) == NULL)
			panic("%s: rebuild exhausted wu_w", DEVNAME(sc));
d2954 1
a2954 1
		wu_w->swu_flags = SR_WUF_REBUILD;
d2956 5
a2960 2
		if (sd->sd_scsi_rw(wu_w))
			panic("write failed");
d3022 1
a3022 1

@


1.143
log
@Oops need to kill the XXX comment that we are not enabling softraid rebuild
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.142 2009/06/03 06:28:56 marco Exp $ */
d210 1
a210 1
		sd->sd_meta_foreign =  malloc(smd[sd->sd_meta_type].smd_size ,
d227 1
a227 1
	
d1062 1
a1062 1
		        devname,
@


1.142
log
@Start using the shiny new function pointer to determine if we have disk
arrivals or departures.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.141 2009/06/03 02:55:04 marco Exp $ */
a1809 3

	/* XXX disabled for now */
	//goto done;
@


1.141
log
@Make sure we don't stomp on a RAID partition that is already in use.
Code is now enabled and ready for general testing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.140 2009/06/02 21:23:11 marco Exp $ */
d1217 17
d1255 2
@


1.140
log
@Abuse bio layer a little less by marking fake buffers with B_PHYS.
From beck with lots of squealing and ear bleeds.
Issue originally reported by todd.

ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.139 2009/06/02 19:21:49 marco Exp $ */
d1784 1
a1784 1
	struct sr_discipline	*sd;
d1793 1
a1793 1
	goto done;
d1805 4
d1810 5
a1814 5
		if (!sd->sd_rebuild) {
			printf("%s: discipline does not support rebuild\n",
			    DEVNAME(sc));
			goto done;
		}
d1816 10
a1825 10
		/* make sure volume is in the right state */
		if (sd->sd_vol_status == BIOC_SVREBUILD) {
			printf("%s: rebuild already in progress\n", DEVNAME(sc));
			goto done;
		}
		if (sd->sd_vol_status != BIOC_SVDEGRADED) {
			printf("%s: %s not degraded\n", DEVNAME(sc),
			    sd->sd_meta->ssd_devname);
			goto done;
		}
d1827 12
a1838 6
		/* find offline chunk */
		for (c = 0, found = -1; c < sd->sd_meta->ssdi.ssd_chunk_no; c++)
			if (sd->sd_vol.sv_chunks[c]->src_meta.scm_status ==
			    BIOC_SDOFFLINE) {
				found = c;
				new = &sd->sd_vol.sv_chunks[c]->src_meta;
a1839 8
			} else {
				csize = sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_size;
				old = &sd->sd_vol.sv_chunks[c]->src_meta;
			}
		if (found == -1) {
			printf("%s: no offline chunks available for rebuild\n",
			    DEVNAME(sc));
			goto done;
d1841 5
d1847 4
a1850 11
		/* populate meta entry */
		dev = (dev_t)bs->bs_other_id;
		sr_meta_getdevname(sc, dev, devname, sizeof(devname));
		bdsw = bdevsw_lookup(dev);

		if (bdsw->d_open(dev, FREAD | FWRITE, S_IFBLK, curproc)) {
			DNPRINTF(SR_D_META,"%s: sr_ioctl_setstate can't "
			    "open %s\n", DEVNAME(sc), devname);
			goto done;
		}
		open = 1; /* close dev on error */
d1852 6
a1857 14
		/* get partition */
		part = DISKPART(dev);
		if ((*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label, FREAD,
		    curproc)) {
			DNPRINTF(SR_D_META, "%s: sr_ioctl_setstate ioctl "
			    "failed\n", DEVNAME(sc));
			goto done;
		}
		if (label.d_partitions[part].p_fstype != FS_RAID) {
			printf("%s: %s partition not of type RAID (%d)\n",
			    DEVNAME(sc) , devname,
			    label.d_partitions[part].p_fstype);
			goto done;
		}
d1859 14
a1872 32
		/* is partition large enough? */
		size = DL_GETPSIZE(&label.d_partitions[part]) -
		    SR_META_SIZE - SR_META_OFFSET;
		if (size < csize) {
			printf("%s: partition too small, at least %llu B "
			    "required\n", DEVNAME(sc), csize << DEV_BSHIFT);
			goto done;
		} else if (size > csize)
			printf("%s: partition too large, wasting %llu B\n",
			    DEVNAME(sc), (size - csize) << DEV_BSHIFT);

		/* XXX make sure we are not stomping on some other partition */

		/* recreate metadata */
		open = 0; /* leave dev open from here on out */
		sd->sd_vol.sv_chunks[found]->src_dev_mm = dev;
		new->scmi.scm_volid = old->scmi.scm_volid;
		new->scmi.scm_chunk_id = found;
		strlcpy(new->scmi.scm_devname, devname,
		    sizeof new->scmi.scm_devname);
		new->scmi.scm_size = size;
		new->scmi.scm_coerced_size = old->scmi.scm_coerced_size;
		bcopy(&old->scmi.scm_uuid, &new->scmi.scm_uuid,
		    sizeof new->scmi.scm_uuid);
		sr_checksum(sc, new, &new->scm_checksum,
		    sizeof(struct sr_meta_chunk_invariant));
		sd->sd_set_chunk_state(sd, found, BIOC_SDREBUILD);
		if (sr_meta_save(sd, SR_META_DIRTY)) {
			printf("%s: could not save metadata to %s\n",
			    DEVNAME(sc), devname);
			goto done;
		}
d1874 10
a1883 2
		printf("%s: trying rebuild %s from %s\n", DEVNAME(sc),
		    sd->sd_meta->ssd_devname, devname);
d1885 12
a1896 1
		kthread_create_deferred(sr_rebuild, sd);
d1898 18
a1915 1
		break; /* all done */
d1917 5
@


1.139
log
@space
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.138 2009/06/02 19:15:58 marco Exp $ */
d284 1
a284 1
			error = bdsw->d_open(dev, FREAD | FWRITE , S_IFBLK,
d364 1
a364 1
	b.b_flags = flags;
d1911 1
a1911 1
		(*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
@


1.138
log
@Make rebuilds restartable over reboots.
Abort rebuild and drain IO when shutting down.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.137 2009/06/02 12:32:08 deraadt Exp $ */
a2916 1

@


1.137
log
@Fix some minor format string problems found in a maze of false positives
provided by Parfait
ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.136 2009/06/02 05:49:35 marco Exp $ */
d1155 4
d2241 1
a2241 3
	if (sd->sd_vol_status == BIOC_SVREBUILD) {
		printf("%s: resuming rebuild on %s\n", DEVNAME(sc),
		    sd->sd_meta->ssd_devname);
a2242 1
	}
d2703 5
d2820 1
d2825 1
a2825 1
	int			c, s, slept;
d2831 16
d2848 1
a2848 1
	for (blk = 0; blk <= whole_blk; blk++) {
d2931 14
a2944 1
		/* XXX save metadata periodically */
a2948 1

d2956 1
d2962 1
@


1.136
log
@Add an identifier that tells us if we can rebuild this discipline.
KNF & spelling too
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.135 2009/06/02 00:58:16 marco Exp $ */
d380 1
a380 1
		printf("%s: 0x%x i/o error on block %lld while reading "
@


1.135
log
@First bits for rebuild.  Disabled for now.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.134 2009/05/30 21:20:34 marco Exp $ */
d1802 5
a1806 1
		/* XXX check that we can even do a rebuild on this discipline */
d1810 1
a1810 1
			printf("%s: rebuild already in progres\n", DEVNAME(sc));
d1841 1
a1841 1
		if (bdsw->d_open(dev, FREAD | FWRITE , S_IFBLK, curproc)) {
d1901 1
a1901 1
		break;
@


1.134
log
@Bring up raid sets that have missing memebers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.133 2009/05/11 14:17:55 jsing Exp $ */
d41 1
a57 1
/* #define SR_UNIT_TEST */
d120 2
d1439 1
d1714 1
d1728 5
d1778 9
a1786 1
	int			rv = EINVAL;
d1788 2
a1789 5
#ifdef SR_UNIT_TEST
	int			i, vol, state, found, tg;
	struct sr_discipline	*sd;
	struct sr_chunk		*ch_entry;
	struct sr_chunk_head 	*cl;
d1802 19
a1820 6
		found = 0;
		tg = 0;
		cl = &sd->sd_vol.sv_chunk_list;
		SLIST_FOREACH(ch_entry, cl, src_link) {
			if (ch_entry->src_dev_mm == bs->bs_other_id) {
				found = 1;
d1822 3
d1826 25
a1850 1
			tg++;
d1852 4
a1855 1
		if (found == 0)
d1857 1
d1859 30
a1888 15
		switch (bs->bs_status) {
		case BIOC_SSONLINE:
			state = BIOC_SDONLINE;
			break;
		case BIOC_SSOFFLINE:
			state = BIOC_SDOFFLINE;
			break;
		case BIOC_SSHOTSPARE:
			state = BIOC_SDHOTSPARE;
			break;
		case BIOC_SSREBUILD:
			state = BIOC_SDREBUILD;
			break;
		default:
			printf("invalid state %d\n", bs->bs_status);
d1892 2
a1893 1
		sd->sd_set_chunk_state(sd, tg, bs->bs_status);
d1895 1
a1895 1
		rv = 0;
d1900 1
d1902 3
a1904 1
#endif
d2233 6
d2790 133
@


1.133
log
@When probing for softraid chunks, ensure that a chunk has a valid metadata
signature, rather than just assuming that a partition of type RAID always
has metadata. Add a similar test when validating native metadata. Whilst
here, make sure that the metadata version is printed correctly.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.132 2009/05/11 14:06:21 jsing Exp $ */
a259 16
		dev = dt[d];
		sr_meta_getdevname(sc, dev, devname, sizeof(devname));
		bdsw = bdevsw_lookup(dev);

		/*
		 * XXX leaving dev open for now; move this to attach and figure
		 * out the open/close dance for unwind.
		 */
		error = bdsw->d_open(dev, FREAD | FWRITE , S_IFBLK, curproc);
		if (error) {
			DNPRINTF(SR_D_META,"%s: sr_meta_probe can't open %s\n",
			    DEVNAME(sc), devname);
			/* XXX device isn't open but will be closed anyway */
			goto unwind;
		}

d268 1
a268 2
		strlcpy(ch_entry->src_devname, devname,
		   sizeof(ch_entry->src_devname));
d271 24
d305 1
d935 1
a935 1
	int			rv = 0, no_dev;
d964 3
a966 1
	dt = malloc(BIOC_CRMAXLEN, M_DEVBUF, M_WAITOK);
a973 1
		bzero(dt, BIOC_CRMAXLEN);
d991 1
a991 1
			if (dt[m2->ssdi.ssd_chunk_id]) {
d1001 4
a1004 4
			printf("%s: not assembling partial disk that used to "
			    "be volume %d\n", DEVNAME(sc),
			    m1->ssdi.ssd_volid);
			continue;
d1108 3
d1164 2
a1165 3
		/* XXX make this smart so that we can bring up degraded disks */
		printf("%s: not all chunks were provided\n", DEVNAME(sc));
		goto bad;
d2064 5
@


1.132
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.130 2009/04/28 03:29:00 marco Exp $ */
d755 5
d761 1
a761 1
		printf("%s: %s can not read metadata version %d, expected %d\n",
d884 2
@


1.131
log
@Use NO_CCB when we run out of work units.  This way we don't have to care
about having enough WU + CCB during rebuilds.  This also brings softraid
closer to behaving like the other SCSI devices.
@
text
@d2275 1
a2275 20
		/* fill out discipline members */
		sd->sd_type = SR_MD_RAID0;
		sd->sd_max_ccb_per_wu =
		    (MAXPHYS / sd->sd_meta->ssdi.ssd_strip_size + 1) *
		    SR_RAID0_NOWU * sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_RAID0_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_raid0_alloc_resources;
		sd->sd_free_resources = sr_raid0_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_raid0_rw;
		sd->sd_set_chunk_state = sr_raid0_set_chunk_state;
		sd->sd_set_vol_state = sr_raid0_set_vol_state;
d2278 1
a2278 18
		/* fill out discipline members */
		sd->sd_type = SR_MD_RAID1;
		sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_RAID1_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_raid1_alloc_resources;
		sd->sd_free_resources = sr_raid1_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_raid1_rw;
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
d2281 1
a2281 1
	/* target */
d2283 1
a2283 19
		/* fill out discipline members */
		sd->sd_type = SR_MD_AOE_TARG;
		sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_RAIDAOE_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_aoe_server_alloc_resources;
		sd->sd_free_resources = sr_aoe_server_free_resources;
		sd->sd_start_discipline = sr_aoe_server_start;
		sd->sd_scsi_inquiry = NULL;
		sd->sd_scsi_read_cap = NULL;
		sd->sd_scsi_tur = NULL;
		sd->sd_scsi_req_sense = NULL;
		sd->sd_scsi_start_stop = NULL;
		sd->sd_scsi_sync = NULL;
		sd->sd_scsi_rw = NULL;
		sd->sd_set_chunk_state = NULL;
		sd->sd_set_vol_state = NULL;
		disk = 0; /* we are not a disk */
d2285 1
d2287 1
a2287 20
		/* initiator */
		/* fill out discipline members */
		sd->sd_type = SR_MD_AOE_INIT;
		sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_RAIDAOE_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_aoe_alloc_resources;
		sd->sd_free_resources = sr_aoe_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_aoe_rw;
		/* XXX reuse raid 1 functions for now FIXME */
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
d2292 1
a2292 19
		/* fill out discipline members */
		sd->sd_type = SR_MD_CRYPTO;
		sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_CRYPTO_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_crypto_alloc_resources;
		sd->sd_free_resources = sr_crypto_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_crypto_rw;
		/* XXX reuse raid 1 functions for now FIXME */
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
@


1.130
log
@Move discipline pointer init into its own function
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.129 2009/04/28 02:54:53 marco Exp $ */
d1502 1
a1502 1
		return (TRY_AGAIN_LATER);
@


1.129
log
@Part one of partial bringup volumes.  Plenty of rope to kill your data
use with caution...
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.128 2009/04/26 17:04:53 marco Exp $ */
d109 1
d2034 2
a2035 113
	switch (bc->bc_level) {
	case 0:
		/* fill out discipline members */
		sd->sd_type = SR_MD_RAID0;
		sd->sd_max_ccb_per_wu =
		    (MAXPHYS / sd->sd_meta->ssdi.ssd_strip_size + 1) *
		    SR_RAID0_NOWU * sd->sd_meta->ssdi.ssd_chunk_no;
		sd->sd_max_wu = SR_RAID0_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_raid0_alloc_resources;
		sd->sd_free_resources = sr_raid0_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_raid0_rw;
		sd->sd_set_chunk_state = sr_raid0_set_chunk_state;
		sd->sd_set_vol_state = sr_raid0_set_vol_state;
		break;
	case 1:
		/* fill out discipline members */
		sd->sd_type = SR_MD_RAID1;
		sd->sd_max_ccb_per_wu = no_chunk;
		sd->sd_max_wu = SR_RAID1_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_raid1_alloc_resources;
		sd->sd_free_resources = sr_raid1_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_raid1_rw;
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
		break;
#ifdef AOE
	/* target */
	case 'A':
		/* fill out discipline members */
		sd->sd_type = SR_MD_AOE_TARG;
		sd->sd_max_ccb_per_wu = no_chunk;
		sd->sd_max_wu = SR_RAIDAOE_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_aoe_server_alloc_resources;
		sd->sd_free_resources = sr_aoe_server_free_resources;
		sd->sd_start_discipline = sr_aoe_server_start;
		sd->sd_scsi_inquiry = NULL;
		sd->sd_scsi_read_cap = NULL;
		sd->sd_scsi_tur = NULL;
		sd->sd_scsi_req_sense = NULL;
		sd->sd_scsi_start_stop = NULL;
		sd->sd_scsi_sync = NULL;
		sd->sd_scsi_rw = NULL;
		sd->sd_set_chunk_state = NULL;
		sd->sd_set_vol_state = NULL;
		disk = 0; /* we are not a disk */
		break;
	case 'a':
		/* initiator */
		/* fill out discipline members */
		sd->sd_type = SR_MD_AOE_INIT;
		sd->sd_max_ccb_per_wu = no_chunk;
		sd->sd_max_wu = SR_RAIDAOE_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_aoe_alloc_resources;
		sd->sd_free_resources = sr_aoe_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_aoe_rw;
		/* XXX reuse raid 1 functions for now FIXME */
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
		break;
#endif
#ifdef CRYPTO
	case 'C':
		/* fill out discipline members */
		sd->sd_type = SR_MD_CRYPTO;
		sd->sd_max_ccb_per_wu = no_chunk;
		sd->sd_max_wu = SR_CRYPTO_NOWU;

		/* setup discipline pointers */
		sd->sd_alloc_resources = sr_crypto_alloc_resources;
		sd->sd_free_resources = sr_crypto_free_resources;
		sd->sd_start_discipline = NULL;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_crypto_rw;
		/* XXX reuse raid 1 functions for now FIXME */
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
		break;
#endif
	default:
d2266 126
@


1.128
log
@KNF, typo and an uninteresting if(&=) instead of if(&) bug in debug code
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.127 2009/02/16 21:19:06 miod Exp $ */
d57 1
d193 1
a193 1
	int			rv = 1, i;
d217 8
a224 3
	if (smd[sd->sd_meta_type].smd_attach(sd, force))
		goto bad;

a225 1
	cl = &sd->sd_vol.sv_chunk_list;
d230 4
d645 1
a645 1
	int			no_disk = 0;
d656 12
a667 3
		/* read and translate */
		if (s->smd_read(sd, ch_entry->src_dev_mm, sm, fm)) {
			/* XXX mark disk offline */
d687 2
a688 2
		/* assume chunk 0 contains metadata */
		if (no_disk == 0)
d690 2
d1073 1
a1073 1
	struct sr_chunk		*ch_entry;
d1075 2
a1076 1
	int			sr, not_sr, rv = 1, d, expected = -1;
d1102 2
d1111 4
a1116 2

		d++;
d1124 19
d1753 1
a1753 1
	int			i, vol, state;
d1755 5
d1765 1
a1765 1
		if (vol != bs->bs_channel)
d1767 1
d1769 11
a1779 2
		sd = sc->sc_dis[vol];
		if (bs->bs_target >= sd->sd_meta->ssdi.ssd_chunk_no)
d1800 1
a1800 4
		printf("status change for %u:%u -> %u %u\n",
		    bs->bs_channel, bs->bs_target, bs->bs_status, state);

		sd->sd_set_chunk_state(sd, bs->bs_target, bs->bs_status);
a1845 4
	/* we have a valid list now create an array index */
	sd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *) * no_chunk,
	    M_DEVBUF, M_WAITOK | M_ZERO);

d2027 2
a2028 2
		printf("%s: not yet partial bringup\n", DEVNAME(sc));
		goto unwind;
d2031 1
a2031 1
	/* XXX metadata SHALL be fully filled in at this point */
d2154 3
@


1.127
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.126 2008/12/24 19:32:02 marco Exp $ */
d593 1
a593 1
		if (sr_debug &= SR_D_META)
d682 2
a683 1
			bcopy(om, &ch_entry->src_opt, sizeof(ch_entry->src_opt));
d686 2
a687 1
				bcopy(&ch_entry->src_opt.somi.som_meta.smm_crypto,
a690 1

d2466 1
a2466 1
	/* when doing a fake sync don't coun't the wu */
@


1.126
log
@This creates the notion of a non-disk softraid device.  The aoe target
is such a beast because it doesn't physically add a device to the OS but
exports a RAID partition.  It creates a kernel thread for each
exported aoe target.  Since it reuses all the goodies in softraid upon
reboot the metadata is discovered and therefore the partition is exported
at boot time.

ok tedu dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.125 2008/11/25 23:05:17 marco Exp $ */
d89 1
a89 1
void			sr_minphys(struct buf *bp);
d1185 1
a1185 1
sr_minphys(struct buf *bp)
@


1.125
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.124 2008/11/25 22:48:22 marco Exp $ */
d610 7
a616 5
	bzero(&wu, sizeof(wu));
	wu.swu_fake = 1;
	wu.swu_dis = sd;
	sd->sd_scsi_sync(&wu);

d1760 1
a1760 1
	int			no_meta, updatemeta = 0;
d1850 1
a1850 1
#ifdef notyet
d1855 2
a1856 1
			strlcpy(sd->sd_name, "AOE TARGET", sizeof(sd->sd_name));
a1857 1
#endif /* notyet */
d1862 1
a1862 1
			strlcpy(sd->sd_name, "AOE INITIATOR", sizeof(sd->sd_name));
d1864 1
d1992 1
d2012 1
d2024 1
a2024 1
#ifdef notyet
d2027 1
a2027 1
		sd->sd_type = SR_MD_AOE;
d2032 13
a2044 11
		sd->sd_alloc_resources = sr_aoe_start_server;
		sd->sd_free_resources = sr_aoe_free_resources;
		sd->sd_scsi_inquiry = sr_raid_inquiry;
		sd->sd_scsi_read_cap = sr_raid_read_cap;
		sd->sd_scsi_tur = sr_raid_tur;
		sd->sd_scsi_req_sense = sr_raid_request_sense;
		sd->sd_scsi_start_stop = sr_raid_start_stop;
		sd->sd_scsi_sync = sr_raid_sync;
		sd->sd_scsi_rw = sr_aoe_rw;
		sd->sd_set_chunk_state = sr_raid_set_chunk_state;
		sd->sd_set_vol_state = sr_raid_set_vol_state;
a2045 1
#endif /* notyet */
d2047 1
d2049 1
a2049 1
		sd->sd_type = SR_MD_AOE;
d2056 1
d2079 1
d2100 11
a2110 10
	/* setup scsi midlayer */
	sd->sd_link.openings = sd->sd_max_wu;
	sd->sd_link.device = &sr_dev;
	sd->sd_link.device_softc = sc;
	sd->sd_link.adapter_softc = sc;
	sd->sd_link.adapter = &sr_switch;
	sd->sd_link.adapter_target = SR_MAX_LD;
	sd->sd_link.adapter_buswidth = 1;
	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sd->sd_link;
d2112 4
a2115 2
	/* we passed all checks return ENXIO if volume can't be created */
	rv = ENXIO;
d2117 2
a2118 2
	/* clear sense data */
	bzero(&sd->sd_scsi_sense, sizeof(sd->sd_scsi_sense));
d2120 13
a2132 13
	/* use temporary discipline pointer */
	s = splhigh();
	sc->sc_attach_dis = sd;
	splx(s);
	dev2 = config_found(&sc->sc_dev, &saa, scsiprint);
	s = splhigh();
	sc->sc_attach_dis = NULL;
	splx(s);
	TAILQ_FOREACH(dev, &alldevs, dv_list)
		if (dev->dv_parent == dev2)
			break;
	if (dev == NULL)
		goto unwind;
d2134 2
a2135 2
	DNPRINTF(SR_D_IOCTL, "%s: sr device added: %s on scsibus%d\n",
	    DEVNAME(sc), dev->dv_xname, sd->sd_link.scsibus);
d2137 5
a2141 19
	sc->sc_dis[sd->sd_link.scsibus] = sd;
	for (i = 0, vol = -1; i <= sd->sd_link.scsibus; i++)
		if (sc->sc_dis[i])
			vol++;

	rv = 0;
	if (updatemeta) {
		/* fill out remaining volume metadata */
		sd->sd_meta->ssdi.ssd_volid = vol;
		strlcpy(sd->sd_meta->ssd_devname, dev->dv_xname,
		    sizeof(sd->sd_meta->ssd_devname));
		sr_meta_init(sd, cl);
	} else {
		if (strncmp(sd->sd_meta->ssd_devname, dev->dv_xname,
		    sizeof(dev->dv_xname))) {
			printf("%s: volume %s is roaming, it used to be %s, "
			    "updating metadata\n",
			    DEVNAME(sc), dev->dv_xname,
			    sd->sd_meta->ssd_devname);
d2143 3
d2149 13
d2163 18
a2184 10

#ifndef SMALL_KERNEL
	if (sr_sensors_create(sd))
		printf("%s: unable to create sensor for %s\n", DEVNAME(sc),
		    dev->dv_xname);
	else
		sd->sd_vol.sv_sensor_valid = 1;
#endif /* SMALL_KERNEL */

	sd->sd_scsibus_dev = dev2;
a2187 1

d2206 2
a2207 1
			if (!strncmp(sc->sc_dis[i]->sd_meta->ssd_devname, dr->bd_dev,
d2739 1
a2739 5
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif
	DNPRINTF(SR_D_STATE, "%s: %s: sr_sensors_delete\n",
	    DEVNAME(sc), sd->sd_meta->ssd_devname);
d2845 1
a2845 1
	printf("\tssd_level %lld\n", m->ssdi.ssd_size);
@


1.124
log
@Halt scanning by returning proper sense for illegal LUN.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.123 2008/11/23 23:44:01 tedu Exp $ */
d1406 12
a1546 3
	s = splbio();
	scsi_done(xs);
	splx(s);
d1549 1
@


1.123
log
@softraid support for ata over ethernet (aoe).  this includes a client and
part of a server.  there's no configuration yet, and several other drawbacks,
but it can be hammered into shape.  i haven't moved the code forward in a year,
and marco wants it in the tree to hack on.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.122 2008/11/23 22:06:43 deraadt Exp $ */
d1447 13
@


1.122
log
@missing newline in printf; Thomas Pfaff
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.121 2008/10/11 20:31:48 miod Exp $ */
d40 6
d1824 16
d1995 43
@


1.121
log
@Fix various printf constructs either missing arguments or format specifiers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.120 2008/09/22 19:44:00 miod Exp $ */
d1086 1
a1086 1
		printf("%s: not all chunks are of the native metadata format",
@


1.120
log
@Make sure some possibly uninitialized local variables are assigned correct
values in all cases.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.119 2008/07/21 14:49:40 marco Exp $ */
d333 1
a333 1
		printf("%s: read invalid metadata pointer\n", sc);
d355 1
a355 1
		    "metadata %d\n", sc, dev, b.b_blkno, b.b_error);
d2517 1
a2517 1
		    DEVNAME(sd->sd_sc));
d2522 1
a2522 1
		printf("%s: %s: illegal block count\n",
d2534 2
a2535 2
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc), func,
		    sd->sd_meta->ssd_devname);
@


1.119
log
@Add curproc to ioctl call.

Noticed by todd,  proded by miod.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.118 2008/07/20 21:57:51 djm Exp $ */
d926 1
a932 1
			m1 = (struct sr_metadata *)&mle->sml_metadata;
@


1.118
log
@fill in variant and version components of the UUID
pretty-print the UUID in RFC4122 form
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.117 2008/07/19 22:41:58 marco Exp $ */
d794 2
a795 2
	error = (*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label,
	    FREAD, curproc);
d1003 1
a1003 1
	error = bdsw->d_ioctl(dev, DIOCGDINFO, (void *)&label, 0, NULL);
@


1.117
log
@Full rewrite of metadata handling.  This fixes power failures and crashes
that caused illegal checksums.  The new metadata code is more or less ready
to deal with other vendor's metadata formats.

While here clean up the name space.

Fix thib's pool mess by adding removing bad flags in interrupt context.

tested on macppc, amd64, i386, sparc64 & hppa

sparc64 has issues with crypto however those do not seem to be softraid
specific.

help from okan@@ ckuethe@@ Will Backman and others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.116 2008/06/25 17:43:09 thib Exp $ */
a2425 1
	/* XXX replace with idgen32 */
d2427 6
d2438 10
a2447 5
	int			i;

	for (i = 0; i < SR_UUID_MAX; i++)
		printf("%x%s", uuid->sui_id[i],
		    i < SR_UUID_MAX - 1 ? ":" : "");
@


1.116
log
@
use pools for the uio and iovec allocations in sr_crypto_getcryptop()
instead of malloc;

OK hshoexer@@ and macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.115 2008/06/14 18:40:50 hshoexer Exp $ */
d67 913
a979 1
void		sr_init(void);
d981 85
a1065 4
int		sr_match(struct device *, void *, void *);
void		sr_attach(struct device *, struct device *, void *);
int		sr_detach(struct device *, int);
int		sr_activate(struct device *, enum devact);
d1067 14
a1080 4
struct cfattach softraid_ca = {
	sizeof(struct sr_softc), sr_match, sr_attach, sr_detach,
	sr_activate
};
d1082 2
a1083 3
struct cfdriver softraid_cd = {
	NULL, "softraid", DV_DULL
};
d1085 10
a1094 25
int			sr_scsi_cmd(struct scsi_xfer *);
void			sr_minphys(struct buf *bp);
void			sr_copy_internal_data(struct scsi_xfer *,
			    void *, size_t);
int			sr_scsi_ioctl(struct scsi_link *, u_long,
			    caddr_t, int, struct proc *);
int			sr_ioctl(struct device *, u_long, caddr_t);
int			sr_ioctl_inq(struct sr_softc *, struct bioc_inq *);
int			sr_ioctl_vol(struct sr_softc *, struct bioc_vol *);
int			sr_ioctl_disk(struct sr_softc *, struct bioc_disk *);
int			sr_ioctl_setstate(struct sr_softc *,
			    struct bioc_setstate *);
int			sr_ioctl_createraid(struct sr_softc *,
			    struct bioc_createraid *, int);
int			sr_ioctl_deleteraid(struct sr_softc *,
			    struct bioc_deleteraid *);
int			sr_open_chunks(struct sr_softc *,
			    struct sr_chunk_head *, dev_t *, int);
int			sr_read_meta(struct sr_discipline *);
int			sr_create_chunk_meta(struct sr_softc *,
			    struct sr_chunk_head *);
void			sr_unwind_chunks(struct sr_softc *,
			    struct sr_chunk_head *);
void			sr_free_discipline(struct sr_discipline *);
void			sr_shutdown_discipline(struct sr_discipline *);
d1096 6
a1101 11
/* utility functions */
void			sr_shutdown(void *);
void			sr_get_uuid(struct sr_uuid *);
void			sr_print_uuid(struct sr_uuid *, int);
u_int32_t		sr_checksum(char *, u_int32_t *, u_int32_t);
int			sr_clear_metadata(struct sr_discipline *);
int			sr_save_metadata(struct sr_discipline *, u_int32_t);
int			sr_boot_assembly(struct sr_softc *);
int			sr_already_assembled(struct sr_discipline *);
int			sr_validate_metadata(struct sr_softc *, dev_t,
			    struct sr_metadata *);
d1103 6
a1108 5
/* don't include these on RAMDISK */
#ifndef SMALL_KERNEL
void			sr_refresh_sensors(void *);
int			sr_create_sensors(struct sr_discipline *);
void			sr_delete_sensors(struct sr_discipline *);
d1110 6
d1117 4
d1122 1
a1122 3
void			sr_print_metadata(struct sr_metadata *);
#else
#define			sr_print_metadata(m)
d1124 2
d1127 3
a1129 2
struct pool sr_uiopl;
struct pool sr_iovpl;
a1138 7
void
sr_init(void)
{
	pool_init(&sr_uiopl, sizeof(struct uio), 0, 0, 0, "sr_uiopl", NULL);
	pool_init(&sr_iovpl, sizeof(struct iovec), 0, 0, 0, "sr_iovpl", NULL);
}

a1141 7
	static int called = 0;

	if (!called) {
		sr_init();
		called = 1;
	}

d1202 1
a1202 1
sr_alloc_ccb(struct sr_discipline *sd)
d1210 1
a1210 1
	DNPRINTF(SR_D_CCB, "%s: sr_alloc_ccb\n", DEVNAME(sd->sd_sc));
d1221 1
a1221 1
		sr_put_ccb(ccb);
d1224 1
a1224 1
	DNPRINTF(SR_D_CCB, "%s: sr_alloc_ccb ccb: %d\n",
d1231 1
a1231 1
sr_free_ccb(struct sr_discipline *sd)
d1238 1
a1238 1
	DNPRINTF(SR_D_CCB, "%s: sr_free_ccb %p\n", DEVNAME(sd->sd_sc), sd);
d1248 1
a1248 1
sr_get_ccb(struct sr_discipline *sd)
d1263 1
a1263 1
	DNPRINTF(SR_D_CCB, "%s: sr_get_ccb: %p\n", DEVNAME(sd->sd_sc),
d1270 1
a1270 1
sr_put_ccb(struct sr_ccb *ccb)
d1275 1
a1275 1
	DNPRINTF(SR_D_CCB, "%s: sr_put_ccb: %p\n", DEVNAME(sd->sd_sc),
d1291 1
a1291 1
sr_alloc_wu(struct sr_discipline *sd)
d1299 1
a1299 1
	DNPRINTF(SR_D_WU, "%s: sr_alloc_wu %p %d\n", DEVNAME(sd->sd_sc),
d1316 1
a1316 1
		sr_put_wu(wu);
d1323 1
a1323 1
sr_free_wu(struct sr_discipline *sd)
d1330 1
a1330 1
	DNPRINTF(SR_D_WU, "%s: sr_free_wu %p\n", DEVNAME(sd->sd_sc), sd);
d1344 1
a1344 1
sr_put_wu(struct sr_workunit *wu)
d1351 1
a1351 1
	DNPRINTF(SR_D_WU, "%s: sr_put_wu: %p\n", DEVNAME(sd->sd_sc), wu);
d1368 1
a1368 1
		sr_put_ccb(ccb);
d1379 1
a1379 1
sr_get_wu(struct sr_discipline *sd)
d1395 1
a1395 1
	DNPRINTF(SR_D_WU, "%s: sr_get_wu: %p\n", DEVNAME(sd->sd_sc), wu);
d1430 1
a1430 1
		    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);
d1434 1
a1434 1
	if ((wu = sr_get_wu(sd)) == NULL) {
d1520 1
a1520 1
		sr_put_wu(wu);
d1601 1
a1601 1
			disk += sc->sc_dis[i]->sd_vol.sv_meta.svm_no_chunk;
d1615 1
a1615 1
	struct sr_volume	*sv;
d1624 6
a1629 6
		sv = &sc->sc_dis[i]->sd_vol;
		bv->bv_status = sv->sv_meta.svm_status;
		bv->bv_size = sv->sv_meta.svm_size << DEV_BSHIFT;
		bv->bv_level = sv->sv_meta.svm_level;
		bv->bv_nodisk = sv->sv_meta.svm_no_chunk;
		strlcpy(bv->bv_dev, sv->sv_meta.svm_devname,
d1631 1
a1631 1
		strlcpy(bv->bv_vendor, sv->sv_meta.svm_vendor,
d1654 1
a1654 1
		if (id >= sc->sc_dis[i]->sd_vol.sv_meta.svm_no_chunk)
d1659 1
a1659 1
		bd->bd_size = src->src_meta.scm_size << DEV_BSHIFT;
d1662 1
a1662 1
		strlcpy(bd->bd_vendor, src->src_meta.scm_devname,
d1688 1
a1688 1
		if (bs->bs_target >= sd->sd_vol.sv_meta.svm_no_chunk)
a1756 5
	if (sr_open_chunks(sc, cl, dt, no_chunk))
		goto unwind;

	/* in memory copy of metadata */
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK | M_ZERO);
d1762 12
d1777 1
a1777 1
		if (sr_read_meta(sd))
d1780 1
a1780 1
				sr_print_uuid(&sd->sd_meta->ssd_uuid, 0);
d1786 1
a1786 6
		/* zero out pointers and metadata again to create disk */
		bzero(sd->sd_vol.sv_chunks,
		    sizeof(struct sr_chunk *) * no_chunk);
		bzero(sd->sd_meta, SR_META_SIZE  * 512);

		if (sr_clear_metadata(sd)) {
d1792 1
a1792 6
	if ((no_meta = sr_read_meta(sd)) == 0) {
		/* fill out chunk array */
		i = 0;
		SLIST_FOREACH(ch_entry, cl, src_link)
			sd->sd_vol.sv_chunks[i++] = ch_entry;

d1794 1
a1794 1
		sr_create_chunk_meta(sc, cl);
d1810 1
a1810 1
			    ch_entry->src_meta.scm_coerced_size * no_chunk;
d1816 1
a1816 1
			vol_size = ch_entry->src_meta.scm_coerced_size;
d1841 1
a1841 1
			vol_size = ch_entry->src_meta.scm_size;
d1855 9
a1863 9
		sd->sd_vol.sv_meta.svm_no_chunk = no_chunk;
		sd->sd_vol.sv_meta.svm_size = vol_size;
		sd->sd_vol.sv_meta.svm_status = BIOC_SVONLINE;
		sd->sd_vol.sv_meta.svm_level = bc->bc_level;
		sd->sd_vol.sv_meta.svm_strip_size = strip_size;
		strlcpy(sd->sd_vol.sv_meta.svm_vendor, "OPENBSD",
		    sizeof(sd->sd_vol.sv_meta.svm_vendor));
		snprintf(sd->sd_vol.sv_meta.svm_product,
		    sizeof(sd->sd_vol.sv_meta.svm_product), "SR %s",
d1865 2
a1866 2
		snprintf(sd->sd_vol.sv_meta.svm_revision,
		    sizeof(sd->sd_vol.sv_meta.svm_revision), "%03d",
d1872 3
d1882 1
a1882 1
			sr_print_uuid(&sd->sd_meta->ssd_uuid, 0);
d1914 4
d1921 1
a1921 1
			sr_print_uuid(&sd->sd_meta->ssd_uuid, 0);
d1937 2
a1938 2
		    (MAXPHYS / sd->sd_vol.sv_meta.svm_strip_size + 1) *
		    SR_RAID0_NOWU * sd->sd_vol.sv_meta.svm_no_chunk;
d2045 16
a2060 3
		sd->sd_vol.sv_meta.svm_volid = vol;
		strlcpy(sd->sd_vol.sv_meta.svm_devname, dev->dv_xname,
		    sizeof(sd->sd_vol.sv_meta.svm_devname));
d2064 1
a2064 1
	rv = sr_save_metadata(sd, SR_VOL_DIRTY);
d2067 1
a2067 1
	if (sr_create_sensors(sd))
d2080 1
a2080 1
	sr_shutdown_discipline(sd);
d2092 2
a2093 294
	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_deleteraid %s\n", DEVNAME(sc),
	    dr->bd_dev);

	for (i = 0; i < SR_MAXSCSIBUS; i++)
		if (sc->sc_dis[i]) {
			if (!strncmp(sc->sc_dis[i]->sd_vol.sv_meta.svm_devname, dr->bd_dev,
			    sizeof(sc->sc_dis[i]->sd_vol.sv_meta.svm_devname))) {
				sd = sc->sc_dis[i];
				break;
			}
		}

	if (sd == NULL)
		goto bad;

	sd->sd_deleted = 1;
	sd->sd_meta->ssd_flags = BIOC_SCNOAUTOASSEMBLE;
	sr_shutdown(sd);

	rv = 0;
bad:
	return (rv);
}

int
sr_open_chunks(struct sr_softc *sc, struct sr_chunk_head *cl, dev_t *dt,
    int no_chunk)
{
	struct sr_chunk		*ch_entry, *ch_prev = NULL;
	struct disklabel	label;
	struct bdevsw		*bdsw;
	char			*name;
	int			maj, unit, part, i, error;
	daddr64_t		size;
	dev_t			dev;

	DNPRINTF(SR_D_IOCTL, "%s: sr_open_chunks(%d)\n", DEVNAME(sc), no_chunk);

	/* fill out chunk list */
	for (i = 0; i < no_chunk; i++) {
		ch_entry = malloc(sizeof(struct sr_chunk), M_DEVBUF,
		    M_WAITOK | M_ZERO);
		/* keep disks in user supplied order */
		if (ch_prev)
			SLIST_INSERT_AFTER(ch_prev, ch_entry, src_link);
		else
			SLIST_INSERT_HEAD(cl, ch_entry, src_link);
		ch_prev = ch_entry;

		dev = dt[i];
		maj = major(dev);
		part = DISKPART(dev);
		unit = DISKUNIT(dev);
		bdsw = &bdevsw[maj];

		name = findblkname(maj);
		if (name == NULL)
			goto unwind;

		snprintf(ch_entry->src_devname, sizeof(ch_entry->src_devname),
		    "%s%d%c", name, unit, part + 'a');
		name = ch_entry->src_devname;

		/* open device */
		error = bdsw->d_open(dev, FREAD | FWRITE , S_IFBLK, curproc);

		/* get disklabel */
		error = bdsw->d_ioctl(dev, DIOCGDINFO, (void *)&label,
		    0, NULL);
		if (error) {
			printf("%s: %s can't obtain disklabel\n",
			    DEVNAME(sc), name);
			bdsw->d_close(dev, FWRITE, S_IFBLK, curproc);
			goto unwind;
		}

		/* make sure the partition is of the right type */
		if (label.d_partitions[part].p_fstype != FS_RAID) {
			printf("%s: %s partition not of type RAID (%d)\n",
			    DEVNAME(sc), name,
			    label.d_partitions[part].p_fstype);
			bdsw->d_close(dev, FWRITE, S_IFBLK, curproc);
			goto unwind;
		}

		/* get partition size while accounting for metadata! */
		ch_entry->src_size = size =
		    DL_GETPSIZE(&label.d_partitions[part]) -
		    SR_META_SIZE - SR_META_OFFSET;
		if (size <= 0) {
			printf("%s: %s partition too small\n",
			    DEVNAME(sc), name);
			bdsw->d_close(dev, FWRITE, S_IFBLK, curproc);
			goto unwind;
		}


		ch_entry->src_dev_mm = dev; /* major/minor */

		DNPRINTF(SR_D_IOCTL, "%s: found %s size %d\n", DEVNAME(sc),
		    name, size);
	}

	return (0);
unwind:
	printf("%s: invalid device: %s\n", DEVNAME(sc), name ? name : "nodev");
	return (1);
}

int
sr_read_meta(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_metadata	*sm = sd->sd_meta, *m;
	struct sr_chunk		*ch_entry;
	struct buf		b;
	struct sr_vol_meta	*mv;
	struct sr_chunk_meta	*mc;
	struct sr_opt_meta	*mo;
	size_t			sz = SR_META_SIZE * 512;
	int			no_chunk = 0;
	u_int32_t		volid, ondisk = 0, cid;

	DNPRINTF(SR_D_META, "%s: sr_read_meta\n", DEVNAME(sc));

	m = malloc(sz , M_DEVBUF, M_WAITOK | M_ZERO);

	SLIST_FOREACH(ch_entry, cl, src_link) {
		bzero(&b, sizeof(b));

		b.b_flags = B_READ;
		b.b_blkno = SR_META_OFFSET;
		b.b_bcount = sz;
		b.b_bufsize = sz;
		b.b_resid = sz;
		b.b_data = (void *)m;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = ch_entry->src_dev_mm;
		b.b_vp = NULL;
		b.b_iodone = NULL;
		LIST_INIT(&b.b_dep);
		bdevsw_lookup(b.b_dev)->d_strategy(&b);
		biowait(&b);

		/* XXX mark chunk offline and restart metadata write */
		if (b.b_flags & B_ERROR) {
			printf("%s: %s i/o error on block %lld while reading "
			    "metadata %d\n", DEVNAME(sc),
			    ch_entry->src_devname, b.b_blkno, b.b_error);
			continue;
		}

		if (m->ssd_magic != SR_MAGIC)
			continue;

		/* validate metadata */
		if (sr_validate_metadata(sc, ch_entry->src_dev_mm, m)) {
			printf("%s: invalid metadata\n", DEVNAME(sc));
			no_chunk = -1;
			goto bad;
		}

		mv = (struct sr_vol_meta *)(m + 1);
		mc = (struct sr_chunk_meta *)(mv + 1);

		/* we asssume that the first chunk has the initial metadata */
		if (no_chunk++ == 0) {
			bcopy(m, sm, sz);
			bcopy(m, sd->sd_meta, sizeof(*sd->sd_meta));
			bcopy(mv, &sd->sd_vol.sv_meta,
			    sizeof(sd->sd_vol.sv_meta));

			volid = m->ssd_vd_volid;
			sd->sd_meta_flags = sm->ssd_flags;
		}

		if (bcmp(&sm->ssd_uuid, &sd->sd_vol.sv_meta.svm_uuid,
		    sizeof(struct sr_uuid))) {
			printf("%s: %s invalid chunk uuid ",
			    DEVNAME(sc), ch_entry->src_devname);
			sr_print_uuid(&sm->ssd_uuid, 0);
			printf(", expected ");
			sr_print_uuid(&sd->sd_vol.sv_meta.svm_uuid, 1);
			no_chunk = -1;
			goto bad;
		}

		/* we have meta data on disk */
		ch_entry->src_meta_ondisk = 1;

		/* make sure we are part of this vd */
		if (volid != m->ssd_vd_volid) {
			printf("%s: %s invalid volume id %d, expected %d\n",
			    DEVNAME(sc), ch_entry->src_devname,
			    volid, m->ssd_vd_volid);
			no_chunk = -1;
			goto bad;
		}

		if (m->ssd_chunk_id > m->ssd_chunk_no) {
			printf("%s: %s chunk id out of range %d, expected "
			    "lower than %d\n", DEVNAME(sc),
			    ch_entry->src_devname,
			    m->ssd_chunk_id, m->ssd_chunk_no);
			no_chunk = -1;
			goto bad;
		}

		if (sd->sd_vol.sv_chunks[m->ssd_chunk_id]) {
			printf("%s: %s chunk id %d already in use\n",
			    DEVNAME(sc), ch_entry->src_devname,
			    m->ssd_chunk_id);
			no_chunk = -1;
			goto bad;
		}

		sd->sd_vol.sv_chunks[m->ssd_chunk_id] = ch_entry;
		bcopy(mc + m->ssd_chunk_id, &ch_entry->src_meta,
		    sizeof(ch_entry->src_meta));

		if (ondisk == 0) {
			ondisk = m->ssd_ondisk;
			cid = m->ssd_chunk_id;
		}

		if (m->ssd_ondisk != ondisk) {
			printf("%s: %s chunk id %d contains stale metadata\n",
			    DEVNAME(sc), ch_entry->src_devname,
			    m->ssd_ondisk < ondisk ? m->ssd_chunk_id : cid);
			no_chunk = -1;
			goto bad;
		}

		/* XXX fix this check, sd_type isnt filled in yet */
		if (mv->svm_level == 'C') {
			mo = (struct sr_opt_meta *)(mc + mv->svm_no_chunk);
			if (m->ssd_chunk_id > 1) {
				no_chunk = -1;
				goto bad;
			}
			bcopy(&mo->som_meta,
			    &sd->mds.mdd_crypto.scr_meta,
			    sizeof(sd->mds.mdd_crypto.scr_meta)
			    );
		}
	}

	if (no_chunk != m->ssd_chunk_no) {
		DNPRINTF(SR_D_META, "%s: not enough chunks supplied\n",
		    DEVNAME(sc));
		no_chunk = -1;
		goto bad;
	}

	DNPRINTF(SR_D_META, "%s: sr_read_meta: found %d elements\n",
	    DEVNAME(sc), no_chunk);

	sr_print_metadata(m);

bad:
	/* return nr of chunks that contain metadata */
	free(m, M_DEVBUF);
	return (no_chunk);
}

int
sr_create_chunk_meta(struct sr_softc *sc, struct sr_chunk_head *cl)
{
	struct sr_chunk		*ch_entry;
	struct sr_uuid		uuid;
	int			rv = 1, cid = 0;
	char			*name;
	u_int64_t		max_chunk_sz = 0, min_chunk_sz;

	DNPRINTF(SR_D_IOCTL, "%s: sr_create_chunk_meta\n", DEVNAME(sc));

	sr_get_uuid(&uuid);

	/* fill out stuff and get largest chunk size while looping */
	SLIST_FOREACH(ch_entry, cl, src_link) {
		name = ch_entry->src_devname;
		ch_entry->src_meta.scm_size = ch_entry->src_size;
		ch_entry->src_meta.scm_chunk_id = cid++;
		ch_entry->src_meta.scm_status = BIOC_SDONLINE;
		strlcpy(ch_entry->src_meta.scm_devname, name,
		    sizeof(ch_entry->src_meta.scm_devname));
		bcopy(&uuid,  &ch_entry->src_meta.scm_uuid,
		    sizeof(ch_entry->src_meta.scm_uuid));

		if (ch_entry->src_meta.scm_size > max_chunk_sz)
			max_chunk_sz = ch_entry->src_meta.scm_size;
	}
d2095 8
a2102 5
	/* get smallest chunk size */
	min_chunk_sz = max_chunk_sz;
	SLIST_FOREACH(ch_entry, cl, src_link)
		if (ch_entry->src_meta.scm_size < min_chunk_sz)
			min_chunk_sz = ch_entry->src_meta.scm_size;
d2104 2
a2105 3
	/* equalize all sizes */
	SLIST_FOREACH(ch_entry, cl, src_link)
		ch_entry->src_meta.scm_coerced_size = min_chunk_sz;
d2107 3
a2109 5
	/* whine if chunks are not the same size */
	if (min_chunk_sz != max_chunk_sz)
		printf("%s: chunk sizes are not equal; up to %llu blocks "
		    "wasted per chunk\n",
		    DEVNAME(sc), max_chunk_sz - min_chunk_sz);
d2112 1
a2112 1

d2117 1
a2117 1
sr_unwind_chunks(struct sr_softc *sc, struct sr_chunk_head *cl)
d2122 1
a2122 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_unwind_chunks\n", DEVNAME(sc));
d2132 2
a2133 1

d2144 1
a2144 1
sr_free_discipline(struct sr_discipline *sd)
d2152 3
a2154 3
	DNPRINTF(SR_D_DIS, "%s: sr_free_discipline %s\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);

d2159 4
a2162 1
	free(sd, M_DEVBUF);
d2169 2
d2174 1
a2174 1
sr_shutdown_discipline(struct sr_discipline *sd)
d2182 2
a2183 2
	DNPRINTF(SR_D_DIS, "%s: sr_shutdown_discipline %s\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);
d2198 1
a2198 1
	sr_delete_sensors(sd);
d2204 1
a2204 1
	sr_unwind_chunks(sc, &sd->sd_vol.sv_chunk_list);
d2207 1
a2207 1
		sr_free_discipline(sd);
d2227 1
a2227 1
	strlcpy(inq.vendor, sd->sd_vol.sv_meta.svm_vendor,
d2229 1
a2229 1
	strlcpy(inq.product, sd->sd_vol.sv_meta.svm_product,
d2231 1
a2231 1
	strlcpy(inq.revision, sd->sd_vol.sv_meta.svm_revision,
d2251 1
a2251 1
		if (sd->sd_vol.sv_meta.svm_size > 0xffffffffllu)
d2254 1
a2254 1
			_lto4b(sd->sd_vol.sv_meta.svm_size, rcd.addr);
d2260 1
a2260 1
		_lto8b(sd->sd_vol.sv_meta.svm_size, rcd16.addr);
d2276 1
a2276 1
	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
d2283 1
a2283 1
	} else if (sd->sd_vol.sv_meta.svm_status == BIOC_SVINVALID) {
d2292 1
a2292 392
	return (0);
}

int
sr_raid_request_sense(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_request_sense\n",
	    DEVNAME(sd->sd_sc));

	/* use latest sense data */
	bcopy(&sd->sd_scsi_sense, &xs->sense, sizeof(xs->sense));

	/* clear sense data */
	bzero(&sd->sd_scsi_sense, sizeof(sd->sd_scsi_sense));

	return (0);
}

int
sr_raid_start_stop(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct scsi_start_stop	*ss = (struct scsi_start_stop *)xs->cmd;
	int			rv = 1;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_start_stop\n",
	    DEVNAME(sd->sd_sc));

	if (!ss)
		return (rv);

	if (ss->byte2 == 0x00) {
		/* START */
		if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
			/* bring volume online */
			/* XXX check to see if volume can be brought online */
			sd->sd_vol.sv_meta.svm_status = BIOC_SVONLINE;
		}
		rv = 0;
	} else /* XXX is this the check? if (byte == 0x01) */ {
		/* STOP */
		if (sd->sd_vol.sv_meta.svm_status == BIOC_SVONLINE) {
			/* bring volume offline */
			sd->sd_vol.sv_meta.svm_status = BIOC_SVOFFLINE;
		}
		rv = 0;
	}

	return (rv);
}

int
sr_raid_sync(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	int			s, rv = 0, ios;

	DNPRINTF(SR_D_DIS, "%s: sr_raid_sync\n", DEVNAME(sd->sd_sc));

	/* when doing a fake sync don't coun't the wu */
	ios = wu->swu_fake ? 0 : 1;

	s = splbio();
	sd->sd_sync = 1;

	while (sd->sd_wu_pending > ios)
		if (tsleep(sd, PRIBIO, "sr_sync", 15 * hz) == EWOULDBLOCK) {
			DNPRINTF(SR_D_DIS, "%s: sr_raid_sync timeout\n",
			    DEVNAME(sd->sd_sc));
			rv = 1;
			break;
		}

	sd->sd_sync = 0;
	splx(s);

	wakeup(&sd->sd_sync);

	return (rv);
}

void
sr_raid_startwu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_ccb		*ccb;

	splassert(IPL_BIO);

	if (wu->swu_state == SR_WU_RESTART)
		/*
		 * no need to put the wu on the pending queue since we
		 * are restarting the io
		 */
		 ;
	else
		/* move wu to pending queue */
		TAILQ_INSERT_TAIL(&sd->sd_wu_pendq, wu, swu_link);

	/* start all individual ios */
	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
		bdevsw_lookup(ccb->ccb_buf.b_dev)->d_strategy(&ccb->ccb_buf);
	}
}

u_int32_t
sr_checksum(char *s, u_int32_t *p, u_int32_t size)
{
	u_int32_t		chk = 0;
	int			i;

	DNPRINTF(SR_D_MISC, "%s: sr_checksum %p %d\n", s, p, size);

	if (size % sizeof(u_int32_t))
		return (0); /* 0 is failure */

	for (i = 0; i < size / sizeof(u_int32_t); i++)
		chk ^= p[i];

	return (chk);
}

void
sr_get_uuid(struct sr_uuid *uuid)
{
	arc4random_buf(uuid->sui_id, sizeof(uuid->sui_id));
}

void
sr_print_uuid(struct sr_uuid *uuid, int cr)
{
	int			i;

	for (i = 0; i < SR_UUID_MAX; i++)
		printf("%x%s", uuid->sui_id[i],
		    i < SR_UUID_MAX - 1 ? ":" : "");

	if (cr)
		printf("\n");
}

int
sr_clear_metadata(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_chunk_head	*cl = &sd->sd_vol.sv_chunk_list;
	struct sr_chunk		*ch_entry;
	struct buf		b;
	size_t			sz = SR_META_SIZE * 512;
	void			*m;
	int			rv = 0;

	DNPRINTF(SR_D_META, "%s: sr_clear_metadata\n", DEVNAME(sc));

	m = malloc(sz , M_DEVBUF, M_WAITOK | M_ZERO);

	SLIST_FOREACH(ch_entry, cl, src_link) {
		bzero(&b, sizeof(b));

		b.b_flags = B_WRITE;
		b.b_blkno = SR_META_OFFSET;
		b.b_bcount = sz;
		b.b_bufsize = sz;
		b.b_resid = sz;
		b.b_data = (void *)m;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = ch_entry->src_dev_mm;
		b.b_vp = NULL;
		b.b_iodone = NULL;
		LIST_INIT(&b.b_dep);
		bdevsw_lookup(b.b_dev)->d_strategy(&b);
		biowait(&b);

		if (b.b_flags & B_ERROR) {
			printf("%s: %s i/o error on block %lld while clearing "
			    "metadata %d\n", DEVNAME(sc),
			    ch_entry->src_devname, b.b_blkno, b.b_error);
			rv++;
			continue;
		}
	}

	free(m, M_DEVBUF);
	return (rv);
}

int
sr_already_assembled(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	int			i;

	for (i = 0; i < SR_MAXSCSIBUS; i++)
		if (sc->sc_dis[i])
			if (!bcmp(&sd->sd_meta->ssd_uuid,
			    &sc->sc_dis[i]->sd_meta->ssd_uuid,
			    sizeof(sd->sd_meta->ssd_uuid)))
				return (1);

	return (0);
}

void
sr_save_metadata_callback(void *arg1, void *arg2)
{
	struct sr_discipline	*sd = arg1;
	int			s;

	s = splbio();

	if (sr_save_metadata(arg1, SR_VOL_DIRTY))
		printf("%s: save metadata failed\n",
		    DEVNAME(sd->sd_sc));

	sd->sd_must_flush = 0;
	splx(s);
}

int
sr_save_metadata(struct sr_discipline *sd, u_int32_t flags)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_metadata	*sm = sd->sd_meta;
	struct sr_vol_meta	*sv = &sd->sd_vol.sv_meta, *im_sv;
	struct sr_chunk_meta	*im_sc;
	struct sr_opt_meta	*im_so;
	struct sr_chunk		*src;
	struct buf		b;
	struct sr_workunit	wu;
	int			i, rv = 1, ch = 0, no_chunk, sz_opt;
	size_t			sz = SR_META_SIZE * 512;

	DNPRINTF(SR_D_META, "%s: sr_save_metadata %s\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);

	if (!sm) {
		printf("%s: no in memory copy of metadata\n", DEVNAME(sc));
		goto bad;
	}

	im_sv = (struct sr_vol_meta *)(sm + 1);
	im_sc = (struct sr_chunk_meta *)(im_sv + 1);
	no_chunk = sd->sd_vol.sv_meta.svm_no_chunk;
	im_so = (struct sr_opt_meta *)(im_sc + no_chunk);

	/* XXX this is a temporary hack until meta is properly redone */
	if (sd->sd_type == SR_MD_CRYPTO)
		sz_opt = sizeof(struct sr_opt_meta);
	else
		sz_opt = 0;

	if (sizeof(struct sr_metadata) + sizeof(struct sr_vol_meta) +
	    (sizeof(struct sr_chunk_meta) * no_chunk) +
	    sz_opt > sz) {
		printf("%s: too much metadata; metadata NOT written\n",
		    DEVNAME(sc));
		goto bad;
	}

	if (sm->ssd_magic == 0) {
		/* initial metadata */
		sm->ssd_magic = SR_MAGIC;
		sm->ssd_version = SR_META_VERSION;
		sm->ssd_size = sizeof(struct sr_metadata);
		sm->ssd_ondisk = 0;
		sm->ssd_flags = sd->sd_meta_flags;
		/* get uuid from chunk 0 */
		bcopy(&sd->sd_vol.sv_chunks[0]->src_meta.scm_uuid,
		    &sm->ssd_uuid,
		    sizeof(struct sr_uuid));

		/* volume */
		bcopy(sv, im_sv, sizeof(struct sr_vol_meta));
		bcopy(&sm->ssd_uuid, &im_sv->svm_uuid,
		    sizeof(im_sv->svm_uuid));
		sm->ssd_vd_ver = SR_VOL_VERSION;
		sm->ssd_vd_size = sizeof(struct sr_vol_meta);

		/* chunk */
		for (i = 0; i < no_chunk; i++)
			bcopy(sd->sd_vol.sv_chunks[i], &im_sc[i],
			    sizeof(struct sr_chunk_meta));

		sm->ssd_chunk_ver = SR_CHUNK_VERSION;
		sm->ssd_chunk_size = sizeof(struct sr_chunk_meta);
		sm->ssd_chunk_no = no_chunk;

		/* optional */
		sm->ssd_opt_ver = SR_OPT_VERSION;
		if (sd->sd_type == SR_MD_CRYPTO) {
			bzero(im_so, sizeof(*im_so));
			sm->ssd_opt_size = sizeof(struct sr_opt_meta);
			sm->ssd_opt_no = 1;
		} else {
			sm->ssd_opt_size = 0;
			sm->ssd_opt_no = 0;
		}
	}

	/* from here on out metadata is updated */
	sm->ssd_ondisk++;
	im_sv->svm_flags |= flags;
	sm->ssd_vd_chk = sr_checksum(DEVNAME(sc),
	    (u_int32_t *)im_sv, sm->ssd_vd_size);

	sm->ssd_chunk_chk = 0;
	for (ch = 0; ch < sm->ssd_chunk_no; ch++)
		sm->ssd_chunk_chk ^= sr_checksum(DEVNAME(sc),
		    (u_int32_t *)&im_sc[ch], sm->ssd_chunk_size);

	/* XXX do checksum on optional meta too */

	sr_print_metadata(sm);

	for (i = 0; i < sm->ssd_chunk_no; i++) {
		memset(&b, 0, sizeof(b));

		src = sd->sd_vol.sv_chunks[i];

		/* skip disks that are offline */
		if (src->src_meta.scm_status == BIOC_SDOFFLINE)
			continue;

		/* copy encrypted key / passphrase into optinal metadata area */
		if (sd->sd_type == SR_MD_CRYPTO && i < 2) {
			im_so->som_type = SR_OPT_CRYPTO;
			bcopy(&sd->mds.mdd_crypto.scr_meta,
			    &im_so->som_meta.smm_crypto,
			    sizeof(im_so->som_meta.smm_crypto));
		}

		/* calculate metdata checksum and ids */
		sm->ssd_vd_volid = im_sv->svm_volid;
		sm->ssd_chunk_id = i;
		sm->ssd_checksum = sr_checksum(DEVNAME(sc),
		    (u_int32_t *)sm, sm->ssd_size);

		DNPRINTF(SR_D_META, "%s: sr_save_metadata %s: volid: %d "
		    "chunkid: %d checksum: 0x%x\n",
		    DEVNAME(sc), src->src_meta.scm_devname,
		    sm->ssd_vd_volid, sm->ssd_chunk_id,
		    sm->ssd_checksum);

		b.b_flags = B_WRITE;
		b.b_blkno = SR_META_OFFSET;
		b.b_bcount = sz;
		b.b_bufsize = sz;
		b.b_resid = sz;
		b.b_data = (void *)sm;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = src->src_dev_mm;
		b.b_vp = NULL;
		b.b_iodone = NULL;
		LIST_INIT(&b.b_dep);
		bdevsw_lookup(b.b_dev)->d_strategy(&b);

		biowait(&b);

		/* make sure in memory copy is clean */
		if (sd->sd_type == SR_MD_CRYPTO)
			bzero(im_so, sizeof(*im_so));
		sm->ssd_vd_volid = 0;
		sm->ssd_chunk_id = 0;
		sm->ssd_checksum = 0;

		/* XXX do something smart here */
		/* mark chunk offline and restart metadata write */
		if (b.b_flags & B_ERROR) {
			printf("%s: %s i/o error on block %lld while writing "
			    "metadata %d\n", DEVNAME(sc),
			    src->src_meta.scm_devname, b.b_blkno, b.b_error);
			goto bad;
		}

		DNPRINTF(SR_D_META, "%s: sr_save_metadata written to %s\n",
		    DEVNAME(sc), src->src_meta.scm_devname);
	}

	bzero(&wu, sizeof(wu));
	wu.swu_fake = 1;
	wu.swu_dis = sd;
	sd->sd_scsi_sync(&wu);

	rv = 0;
bad:
	return (rv);
d2296 1
a2296 1
sr_boot_assembly(struct sr_softc *sc)
d2298 2
a2299 12
	struct device		*dv;
	struct buf		*bp;
	struct bdevsw		*bdsw;
	struct disklabel	label;
	struct sr_metadata	*sm;
	struct sr_metadata_list_head mlh;
	struct sr_metadata_list *mle, *mle2;
	struct sr_vol_meta	*vm;
	struct bioc_createraid	bc;
	dev_t			dev, devr, *dt = NULL;
	int			error, majdev, i, no_dev, rv = 0;
	size_t			sz = SR_META_SIZE * 512;
d2301 2
a2302 1
	DNPRINTF(SR_D_META, "%s: sr_boot_assembly\n", DEVNAME(sc));
d2304 2
a2305 4
	SLIST_INIT(&mlh);
	bp = geteblk(sz);
	if (!bp)
		return (ENOMEM);
d2307 2
a2308 3
	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class != DV_DISK)
			continue;
d2310 2
a2311 3
		majdev = findblkmajor(dv);
		if (majdev == -1)
			continue;
d2313 7
a2319 2
		bp->b_dev = dev = MAKEDISKDEV(majdev, dv->dv_unit, RAW_PART);
		bdsw = &bdevsw[majdev];
d2321 2
a2322 11
		/* XXX is there  a better way of excluding some devices? */
		if (!strncmp(dv->dv_xname, "fd", 2) ||
		    !strncmp(dv->dv_xname, "cd", 2) ||
		    !strncmp(dv->dv_xname, "rx", 2))
			continue;
		/*
		 * The devices are being opened with S_IFCHR instead of
		 * S_IFBLK so that the SCSI mid-layer does not whine when
		 * media is not inserted in certain devices like zip drives
		 * and such.
		 */
d2324 2
a2325 7
		/* open device */
		error = (*bdsw->d_open)(dev, FREAD, S_IFCHR, curproc);
		if (error) {
			DNPRINTF(SR_D_META, "%s: sr_boot_assembly open failed"
			    "\n", DEVNAME(sc));
			continue;
		}
d2327 6
a2332 8
		/* get disklabel */
		error = (*bdsw->d_ioctl)(dev, DIOCGDINFO, (void *)&label,
		    FREAD, curproc);
		if (error) {
			DNPRINTF(SR_D_META, "%s: sr_boot_assembly ioctl "
			    "failed\n", DEVNAME(sc));
			error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
			continue;
d2334 6
a2339 7

		/* we are done, close device */
		error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
		if (error) {
			DNPRINTF(SR_D_META, "%s: sr_boot_assembly close "
			    "failed\n", DEVNAME(sc));
			continue;
d2341 2
d2344 2
a2345 4
		/* are we a softraid partition? */
		for (i = 0; i < MAXPARTITIONS; i++) {
			if (label.d_partitions[i].p_fstype != FS_RAID)
				continue;
d2347 5
a2351 25
			/* open device */
			bp->b_dev = devr = MAKEDISKDEV(majdev, dv->dv_unit, i);
			error = (*bdsw->d_open)(devr, FREAD, S_IFCHR, curproc);
			if (error) {
				DNPRINTF(SR_D_META, "%s: sr_boot_assembly "
				    "open failed, partition %d\n",
				    DEVNAME(sc), i);
				continue;
			}
			/* read metadat */
			bp->b_flags = B_BUSY | B_READ;
			bp->b_blkno = SR_META_OFFSET;
			bp->b_cylinder = 0;
			bp->b_bcount = sz;
			bp->b_bufsize = sz;
			bp->b_resid = sz;
			(*bdsw->d_strategy)(bp);
			if ((error = biowait(bp))) {
				DNPRINTF(SR_D_META, "%s: sr_boot_assembly "
				    "strategy failed, partition %d\n",
				    DEVNAME(sc));
				error = (*bdsw->d_close)(devr, FREAD, S_IFCHR,
				    curproc);
				continue;
			}
d2353 1
a2353 11
			sm = (struct sr_metadata *)bp->b_data;
			if (!sr_validate_metadata(sc, devr, sm)) {
				/* we got one; save it off */
				mle = malloc(sizeof(*mle), M_DEVBUF,
				    M_WAITOK | M_ZERO);
				mle->sml_metadata = malloc(sz, M_DEVBUF,
				    M_WAITOK | M_ZERO);
				bcopy(sm, mle->sml_metadata, sz);
				mle->sml_mm = devr;
				SLIST_INSERT_HEAD(&mlh, mle, sml_link);
			}
d2355 2
a2356 10
			/* we are done, close device */
			error = (*bdsw->d_close)(devr, FREAD, S_IFCHR,
			    curproc);
			if (error) {
				DNPRINTF(SR_D_META, "%s: sr_boot_assembly "
				    "close failed\n", DEVNAME(sc));
				continue;
			}
		}
	}
d2358 2
a2359 10
	/*
	 * XXX poor mans hack that doesn't keep disks in order and does not
	 * roam disks correctly.  replace this with something smarter that
	 * orders disks by volid, chunkid and uuid.
	 */
	dt = malloc(BIOC_CRMAXLEN, M_DEVBUF, M_WAITOK);
	SLIST_FOREACH(mle, &mlh, sml_link) {
		/* chunk used already? */
		if (mle->sml_used)
			continue;
d2361 7
a2367 6
		no_dev = 0;
		bzero(dt, BIOC_CRMAXLEN);
		SLIST_FOREACH(mle2, &mlh, sml_link) {
			/* chunk used already? */
			if (mle2->sml_used)
				continue;
d2369 2
a2370 4
			/* are we the same volume? */
			if (mle->sml_metadata->ssd_vd_volid !=
			    mle2->sml_metadata->ssd_vd_volid)
				continue;
d2372 1
a2372 5
			/* same uuid? */
			if (bcmp(&mle->sml_metadata->ssd_uuid,
			    &mle2->sml_metadata->ssd_uuid,
			    sizeof(mle->sml_metadata->ssd_uuid)))
				continue;
d2374 2
a2375 16
			/* sanity */
			if (dt[mle2->sml_metadata->ssd_chunk_id]) {
				printf("%s: chunk id already in use; can not "
				    "assemble volume\n", DEVNAME(sc));
				goto unwind;
			}
			dt[mle2->sml_metadata->ssd_chunk_id] = mle2->sml_mm;
			no_dev++;
			mle2->sml_used = 1;
		}
		if (mle->sml_metadata->ssd_chunk_no != no_dev) {
			printf("%s: not assembling partial disk that used to "
			    "be volume %d\n", DEVNAME(sc),
			    mle->sml_metadata->ssd_vd_volid);
			continue;
		}
d2377 5
a2381 9
		bzero(&bc, sizeof(bc));
		vm = (struct sr_vol_meta *)(mle->sml_metadata + 1);
		bc.bc_level = vm->svm_level;
		bc.bc_dev_list_len = no_dev * sizeof(dev_t);
		bc.bc_dev_list = dt;
		bc.bc_flags = BIOC_SCDEVT;
		sr_ioctl_createraid(sc, &bc, 0);
		rv++;
	}
d2383 1
a2383 3
unwind:
	if (dt)
		free(dt, M_DEVBUF);
d2385 9
a2393 2
	for (mle = SLIST_FIRST(&mlh); mle != SLIST_END(&mlh); mle = mle2) {
		mle2 = SLIST_NEXT(mle, sml_link);
d2395 3
a2397 2
		free(mle->sml_metadata, M_DEVBUF);
		free(mle, M_DEVBUF);
a2398 3
	SLIST_INIT(&mlh);

	return (rv);
d2401 2
a2402 2
int
sr_validate_metadata(struct sr_softc *sc, dev_t dev, struct sr_metadata *sm)
d2404 1
a2404 5
	struct sr_vol_meta	*mv;
	struct sr_chunk_meta	*mc;
	char			*name, devname[32];
	int			maj, part, unit;
	u_int32_t		chk;
d2406 3
a2408 2
	DNPRINTF(SR_D_META, "%s: sr_validate_metadata(0x%x)\n",
	    DEVNAME(sc), dev);
d2410 4
a2413 1
	bzero(devname, sizeof(devname));
d2415 2
a2416 2
	if (sm->ssd_magic != SR_MAGIC)
		goto bad;
d2418 4
a2421 3
	maj = major(dev);
	part = DISKPART(dev);
	unit = DISKUNIT(dev);
d2423 6
a2428 3
	name = findblkname(maj);
	if (name == NULL)
		goto bad;
d2430 4
a2433 30
	snprintf(devname, sizeof(devname),
	    "%s%d%c", name, unit, part + 'a');
	name = devname;

	/* validate metadata */
	if (sm->ssd_version != SR_META_VERSION) {
		printf("%s: %s can not read metadata version %d, "
		    "expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_version,
		    SR_META_VERSION);
		goto bad;
	}
	if (sm->ssd_size != sizeof(struct sr_metadata)) {
		printf("%s: %s invalid metadata size %d, "
		    "expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_size,
		    sizeof(struct sr_metadata));
		goto bad;
	}
	chk = sr_checksum(DEVNAME(sc), (u_int32_t *)sm, sm->ssd_size);
	/*
	 * since the checksum value is part of the checksum a good
	 * result equals 0
	 */
	if (chk != 0) {
		printf("%s: %s invalid metadata checksum 0x%x, "
		    "expected 0x%x\n", DEVNAME(sc),
		    devname, sm->ssd_checksum, chk);
		goto bad;
	}
d2435 3
a2437 23
	/* validate volume metadata */
	if (sm->ssd_vd_ver != SR_VOL_VERSION) {
		printf("%s: %s can not read volume metadata version "
		    "%d, expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_vd_ver,
		    SR_VOL_VERSION);
		goto bad;
	}
	if (sm->ssd_vd_size != sizeof(struct sr_vol_meta)) {
		printf("%s: %s invalid volume metadata size %d, "
		    "expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_vd_size,
		    sizeof(struct sr_vol_meta));
		goto bad;
	}
	mv = (struct sr_vol_meta *)(sm + 1);
	chk = sr_checksum(DEVNAME(sc), (u_int32_t *)mv, sm->ssd_vd_size);
	if (chk != sm->ssd_vd_chk) {
		printf("%s: %s invalid volume metadata checksum 0x%x, "
		    "expected 0x%x\n", DEVNAME(sc),
		    devname, sm->ssd_vd_chk, chk);
		goto bad;
	}
d2439 3
a2441 15
	/* validate chunk metadata */
	if (sm->ssd_chunk_ver != SR_CHUNK_VERSION) {
		printf("%s: %s can not read chunk metadata version "
		    "%d, expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_chunk_ver,
		    SR_CHUNK_VERSION);
		goto bad;
	}
	if (sm->ssd_chunk_size != sizeof(struct sr_chunk_meta)) {
		printf("%s: %s invalid chunk metadata size %d, "
		    "expected %d\n", DEVNAME(sc),
		    devname, sm->ssd_chunk_size,
		    sizeof(struct sr_chunk_meta));
		goto bad;
	}
d2443 5
a2447 11
	mc = (struct sr_chunk_meta *)(mv + 1);
	/* checksum is calculated over ALL chunks */
	chk = sr_checksum(DEVNAME(sc), (u_int32_t *)(mc),
	    sm->ssd_chunk_size * sm->ssd_chunk_no);

	if (chk != sm->ssd_chunk_chk) {
		printf("%s: %s invalid chunk metadata checksum 0x%x, "
		    "expected 0x%x\n", DEVNAME(sc),
		    devname, sm->ssd_chunk_chk, chk);
		goto bad;
	}
d2449 6
a2454 9
	/* warn if disk changed order */
	if (strncmp(mc[sm->ssd_chunk_id].scm_devname, name,
	    sizeof(mc[sm->ssd_chunk_id].scm_devname)))
		printf("%s: roaming device %s -> %s\n", DEVNAME(sc),
		    mc[sm->ssd_chunk_id].scm_devname, name);

	/* we have meta data on disk */
	DNPRINTF(SR_D_META, "%s: sr_validate_metadata valid metadata %s\n",
	    DEVNAME(sc), devname);
a2456 5
bad:
	DNPRINTF(SR_D_META, "%s: sr_validate_metadata invalid metadata %s\n",
	    DEVNAME(sc), devname);

	return (1);
d2488 1
a2488 1
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);
d2490 1
a2490 1
	sr_save_metadata(sd, 0);
d2492 1
a2492 1
	sr_shutdown_discipline(sd);
d2505 1
a2505 1
	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
d2513 1
a2513 1
		    DEVNAME(sd->sd_sc), func, sd->sd_vol.sv_meta.svm_devname);
d2525 1
a2525 1
		    sd->sd_vol.sv_meta.svm_devname);
d2532 1
a2532 1
	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
d2586 1
a2586 1
sr_create_sensors(struct sr_discipline *sd)
d2591 2
a2592 2
	DNPRINTF(SR_D_STATE, "%s: %s: sr_create_sensors\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);
d2599 1
a2599 1
	strlcpy(sd->sd_vol.sv_sensor.desc, sd->sd_vol.sv_meta.svm_devname,
d2605 1
a2605 1
		if (sensor_task_register(sc, sr_refresh_sensors, 10) == NULL)
d2617 1
a2617 1
sr_delete_sensors(struct sr_discipline *sd)
d2622 2
a2623 2
	DNPRINTF(SR_D_STATE, "%s: %s: sr_delete_sensors\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);
d2630 1
a2630 1
sr_refresh_sensors(void *arg)
d2633 2
a2635 1
	struct sr_volume	*sv;
d2637 1
a2637 1
	DNPRINTF(SR_D_STATE, "%s: sr_refresh_sensors\n", DEVNAME(sc));
d2644 2
a2645 1
		sv = &sc->sc_dis[i]->sd_vol;
d2647 1
a2647 1
		switch(sv->sv_meta.svm_status) {
d2701 1
a2701 1
		    sd->sd_vol.sv_meta.svm_devname,
d2710 1
a2710 1
sr_print_metadata(struct sr_metadata *sm)
d2712 3
a2714 4
	struct sr_vol_meta	*im_sv;
	struct sr_chunk_meta	*im_sc;
	struct sr_opt_meta	*im_so;
	int			ch;
d2719 35
a2753 25
	im_sv = (struct sr_vol_meta *)(sm + 1);
	im_sc = (struct sr_chunk_meta *)(im_sv + 1);
	im_so = (struct sr_opt_meta *)(im_sc + im_sv->svm_no_chunk);

	DNPRINTF(SR_D_META, "\tmeta magic 0x%llx\n", sm->ssd_magic);
	DNPRINTF(SR_D_META, "\tmeta version %d\n", sm->ssd_version);
	DNPRINTF(SR_D_META, "\tmeta checksum 0x%x\n", sm->ssd_checksum);
	DNPRINTF(SR_D_META, "\tmeta size %d\n", sm->ssd_size);
	DNPRINTF(SR_D_META, "\tmeta on disk version %u\n", sm->ssd_ondisk);
	DNPRINTF(SR_D_META, "\tmeta uuid ");
	sr_print_uuid(&sm->ssd_uuid, 1);
	DNPRINTF(SR_D_META, "\tvd version %d\n", sm->ssd_vd_ver);
	DNPRINTF(SR_D_META, "\tvd size %lu\n", sm->ssd_vd_size);
	DNPRINTF(SR_D_META, "\tvd id %u\n", sm->ssd_vd_volid);
	DNPRINTF(SR_D_META, "\tvd checksum 0x%x\n", sm->ssd_vd_chk);
	DNPRINTF(SR_D_META, "\tchunk version %d\n", sm->ssd_chunk_ver);
	DNPRINTF(SR_D_META, "\tchunks %d\n", sm->ssd_chunk_no);
	DNPRINTF(SR_D_META, "\tchunk size %u\n", sm->ssd_chunk_size);
	DNPRINTF(SR_D_META, "\tchunk id %u\n", sm->ssd_chunk_id);
	DNPRINTF(SR_D_META, "\tchunk checksum 0x%x\n", sm->ssd_chunk_chk);
	if (sm->ssd_opt_no) {
		DNPRINTF(SR_D_META, "\topt version %d\n", sm->ssd_opt_ver);
		DNPRINTF(SR_D_META, "\topt items %d\n", sm->ssd_opt_no);
		DNPRINTF(SR_D_META, "\topt size %d\n", sm->ssd_opt_size);
		DNPRINTF(SR_D_META, "\topt chk 0x%x\n", sm->ssd_opt_chk);
d2756 6
a2761 30

	DNPRINTF(SR_D_META, "\t\tvol id %d\n", im_sv->svm_volid);
	DNPRINTF(SR_D_META, "\t\tvol status %d\n", im_sv->svm_status);
	DNPRINTF(SR_D_META, "\t\tvol flags 0x%x\n", im_sv->svm_flags);
	DNPRINTF(SR_D_META, "\t\tvol level %d\n", im_sv->svm_level);
	DNPRINTF(SR_D_META, "\t\tvol size %lld\n", im_sv->svm_size);
	DNPRINTF(SR_D_META, "\t\tvol name %s\n", im_sv->svm_devname);
	DNPRINTF(SR_D_META, "\t\tvol vendor %s\n", im_sv->svm_vendor);
	DNPRINTF(SR_D_META, "\t\tvol prod %s\n", im_sv->svm_product);
	DNPRINTF(SR_D_META, "\t\tvol rev %s\n", im_sv->svm_revision);
	DNPRINTF(SR_D_META, "\t\tvol no chunks %d\n", im_sv->svm_no_chunk);
	DNPRINTF(SR_D_META, "\t\tvol uuid ");
	sr_print_uuid(& im_sv->svm_uuid, 1);
	DNPRINTF(SR_D_META, "\t\tvol stripsize %d\n", im_sv->svm_strip_size);

	for (ch = 0; ch < im_sv->svm_no_chunk; ch++) {
		DNPRINTF(SR_D_META, "\t\t\tchunk vol id %d\n",
		    im_sc[ch].scm_volid);
		DNPRINTF(SR_D_META, "\t\t\tchunk id %d\n",
		    im_sc[ch].scm_chunk_id);
		DNPRINTF(SR_D_META, "\t\t\tchunk status %d\n",
		    im_sc[ch].scm_status);
		DNPRINTF(SR_D_META, "\t\t\tchunk name %s\n",
		    im_sc[ch].scm_devname);
		DNPRINTF(SR_D_META, "\t\t\tchunk size %lld\n",
		    im_sc[ch].scm_size);
		DNPRINTF(SR_D_META, "\t\t\tchunk coerced size %lld\n",
		    im_sc[ch].scm_coerced_size);
		DNPRINTF(SR_D_META, "\t\t\tchunk uuid ");
		sr_print_uuid(&im_sc[ch].scm_uuid, 1);
@


1.115
log
@Provide a status field for operations on the bc_opaque data.  Now we're
able to distinguish cleanly an failing ioctl (ie. return value -1) from
trying to retrieve a KDF hint from a not yet initialized volume.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.114 2008/06/14 00:16:38 hshoexer Exp $ */
d28 1
d67 2
d134 3
d145 7
d155 7
@


1.114
log
@Update bioctl(8) and softraid(4) to recent changes and enable softraid
crypto.  It's still considered experimental!

ok djm marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.113 2008/06/13 18:26:59 hshoexer Exp $ */
d830 7
d901 1
@


1.113
log
@When assembling an already initialized crytpo softraid, correctly copy in
mask key from userland.  Thus, modify sr_crypto_get_kdf() do correclty handle
copying kdf hint and/or mask key.

While there, remove superflous sr_read_meta().

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.112 2008/06/12 23:29:27 hshoexer Exp $ */
a820 1
#if 0
a842 1
#endif
@


1.112
log
@make sure to check that a crypto volume is not yet assembled when
retrieving the kdf blobb.  Pointed out by marco.

while there, use %lld instead of %d when printing b_blkno, which daddr64_t.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.111 2008/06/12 21:29:02 marco Exp $ */
a886 3
			if (sr_read_meta(sd) == 0)
				goto unwind;

d898 5
@


1.111
log
@Clead discipline pointer after delete.  Found by hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.110 2008/06/12 18:13:27 hshoexer Exp $ */
d875 6
a902 6
		if (sr_already_assembled(sd)) {
			printf("%s: disk ", DEVNAME(sc));
			sr_print_uuid(&sd->sd_meta->ssd_uuid, 0);
			printf(" already assembled\n");
			goto unwind;
		}
a1035 1

d1215 1
a1215 1
			printf("%s: %s i/o error on block %d while reading "
d1732 1
a1732 1
			printf("%s: %s i/o error on block %d while clearing "
d1927 1
a1927 1
			printf("%s: %s i/o error on block %d while writing "
@


1.110
log
@Get mask keying for on-disk keys from user space and keep a "hint" for key
generation used by user space in the meta data.

Actually use the masking key for encryption and decryption of on-disk key
at run time.

ok djm marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.109 2008/06/12 01:26:16 marco Exp $ */
a1412 1
#ifdef SR_DEBUG
d1414 2
a1415 1
#endif
d1427 6
@


1.109
log
@Be more paranoid before disestablishing hook

ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.108 2008/06/12 00:19:15 marco Exp $ */
a823 4
			/*
                         * XXX we need the masking keys and salt here,
                         * provided by bioctl.
			 */
d831 6
a839 1
			/* create crypto keys and encrypt them */
d841 1
d875 22
d1306 1
a1306 1
			if (m->ssd_chunk_id > 2) {
@


1.108
log
@Add delete volume functionality.

discussed with krw, kettenis & drahn
ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.107 2008/06/11 00:26:18 hshoexer Exp $ */
d1419 2
a1420 1
	shutdownhook_disestablish(sd->sd_shutdownhook);
@


1.107
log
@Move first pieces of crypto softraid into the tree.  Still totally
disabled, of course, and still work in progress.

help by djm@@, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.106 2008/06/09 07:07:16 djm Exp $ */
d94 2
d428 6
d579 3
d1038 31
d1418 2
@


1.106
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.105 2008/04/02 21:32:03 martin Exp $ */
d813 9
a821 1
			if (no_chunk < 1 || no_chunk > 2)
d823 1
a828 1
			sr_crypto_encrypt_key(sd);
d1245 2
a1246 2
			    &sd->mds.mdd_crypto.scr_meta[m->ssd_chunk_id],
			    sizeof(sd->mds.mdd_crypto.scr_meta[m->ssd_chunk_id])
d1810 1
a1810 1
			bcopy(&sd->mds.mdd_crypto.scr_meta[i],
@


1.105
log
@fix bad printf if metadata clearing failed

from Rainer Giedat

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.104 2008/02/15 05:29:25 ckuethe Exp $ */
d1600 1
a1600 1
	arc4random_bytes(uuid->sui_id, sizeof(uuid->sui_id));
@


1.104
log
@Add myself to the copyrights, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.103 2008/02/14 22:04:34 ckuethe Exp $ */
d774 1
a774 1
			printf("%s: failed to clear metadata\n");
@


1.103
log
@Actually implement the crypto.
ok tedu@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.102 2008/02/07 15:08:49 marco Exp $ */
d4 1
@


1.102
log
@Add optional metadata memebers.
Randomize Crypto password and add salt array.
Add mock key encryption functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.101 2008/02/05 16:49:25 marco Exp $ */
a718 3
#if 0
	u_int32_t		*pk, sz;
#endif
d810 1
d815 1
a815 24
			vol_size = ch_entry->src_meta.scm_coerced_size;

			/* generate crypto key */
			sz = sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_key) / 4;
			pk = (u_int32_t *)
			    sd->mds.mdd_crypto.scr_meta[0].scm_key;
			for (i = 0; i < sz; i++)
				*pk++ = arc4random();

			/* generate salt */
			sz = sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_salt) /4;
			pk = (u_int32_t *)
			    sd->mds.mdd_crypto.scr_meta[0].scm_salt;
			for (i = 0; i < sz; i++)
				*pk++ = arc4random();

			sd->mds.mdd_crypto.scr_meta[0].scm_flags =
			    SR_CRYPTOF_KEY | SR_CRYPTOF_SALT;

			strlcpy(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase,
			    "my super secret passphrase ZOMGPASSWD",
			    sizeof(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase));
			sd->mds.mdd_crypto.scr_meta[1].scm_flags =
			    SR_CRYPTOF_PASSPHRASE;
d817 2
d821 1
@


1.101
log
@Shave off a few more bytes by moving IO collision detection into a generic
fucntion.  Fix bug in the crypto code that could casuse data corruption as
a bonus, bad cut & past tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.100 2008/02/05 16:24:12 marco Exp $ */
d719 3
d814 1
a814 1
			if (no_chunk < 2)
d818 25
d1134 1
d1249 13
d1722 1
d1726 1
a1726 1
	int			i, rv = 1, ch = 0;
d1739 8
d1749 2
a1750 2
	    (sizeof(struct sr_chunk_meta) * sd->sd_vol.sv_meta.svm_no_chunk) >
	    sz) {
d1776 1
a1776 1
		for (i = 0; i < sd->sd_vol.sv_meta.svm_no_chunk; i++)
d1782 1
a1782 1
		sm->ssd_chunk_no = sd->sd_vol.sv_meta.svm_no_chunk;
d1786 8
a1793 2
		sm->ssd_opt_size = 0; /* unused */
		sm->ssd_opt_no = 0; /* unused */
d1807 2
d1820 8
d1833 1
d1853 1
d1857 2
d2462 1
d2470 1
d2488 7
d2527 11
@


1.100
log
@Add strip size to debug print.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.99 2008/02/05 16:15:35 marco Exp $ */
d2229 32
@


1.99
log
@Create a generic function to validate IO instead of copying and pasting
same code in all disciplines.  This shaves of a few bytes.

crypto 3185 -> 2690
raid 0 2843 -> 2378
raid 1 3474 -> 2689
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.98 2008/02/03 00:25:21 marco Exp $ */
d2396 1
@


1.98
log
@There is no such thing as RAIDCRYPTO so rename to CRYPTO
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.97 2008/01/29 23:25:02 marco Exp $ */
d2172 57
@


1.97
log
@Improve performance dramatically by preventing severeal context switches.
Decrypt only once on entry or exit instead of on in and out regardless of
direction.

There is still room for improvement but this is the first stab.

Tested by many ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.96 2008/01/24 19:58:08 marco Exp $ */
d914 1
a914 1
		sd->sd_type = SR_MD_RAIDCRYPTO;
d916 1
a916 1
		sd->sd_max_wu = SR_RAIDCRYPTO_NOWU;
@


1.96
log
@Create chunk and state transition functions for RAID 0.
Move RAID 1 chunk and state transition functions into proper file.
Let Crypto use RAID 1 chunk and state transition functions for now but this
needs fixing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.95 2008/01/24 17:50:17 marco Exp $ */
d280 1
d811 1
a811 1
			if (no_chunk != 1)
@


1.95
log
@Bring softraid into the world of 16 byte commands; this allows for > 2TB disks
Fix bioctl size output which was off by *512; diagnosed by otto
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.94 2008/01/24 13:54:47 marco Exp $ */
a109 1
void			sr_save_metadata_callback(void *, void *);
d888 2
a889 2
		sd->sd_set_chunk_state = sr_raid_set_chunk_state;
		sd->sd_set_vol_state = sr_raid_set_vol_state;
d907 2
a908 2
		sd->sd_set_chunk_state = sr_raid_set_chunk_state;
		sd->sd_set_vol_state = sr_raid_set_vol_state;
d927 3
a929 2
		sd->sd_set_chunk_state = sr_raid_set_chunk_state;
		sd->sd_set_vol_state = sr_raid_set_vol_state;
a1555 196
}

void
sr_raid_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;

	/* multiple IOs to the same chunk that fail will come through here */
	if (old_state == new_state)
		goto done;

	switch (old_state) {
	case BIOC_SDONLINE:
		switch (new_state) {
		case BIOC_SDOFFLINE:
			break;
		case BIOC_SDSCRUB:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDOFFLINE:
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
			goto die;
		break;

	case BIOC_SDSCRUB:
		if (new_state == BIOC_SDONLINE) {
			;
		} else
			goto die;
		break;

	case BIOC_SDREBUILD:
		if (new_state == BIOC_SDONLINE) {
			;
		} else
			goto die;
		break;

	case BIOC_SDHOTSPARE:
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
			goto die;
		break;

	default:
die:
		splx(s); /* XXX */
		panic("%s: %s: %s: invalid chunk state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_chunks[c]->src_meta.scm_status = new_state;
	sd->sd_set_vol_state(sd);

	sd->sd_must_flush = 1;
	workq_add_task(NULL, 0, sr_save_metadata_callback, sd, NULL);
done:
	splx(s);
}

void
sr_raid_set_vol_state(struct sr_discipline *sd)
{
	int			states[SR_MAX_STATES];
	int			new_state, i, s, nd;
	int			old_state = sd->sd_vol.sv_meta.svm_status;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);

	nd = sd->sd_vol.sv_meta.svm_no_chunk;

	for (i = 0; i < SR_MAX_STATES; i++)
		states[i] = 0;

	for (i = 0; i < nd; i++) {
		s = sd->sd_vol.sv_chunks[i]->src_meta.scm_status;
		if (s > SR_MAX_STATES)
			panic("%s: %s: %s: invalid chunk state",
			    DEVNAME(sd->sd_sc),
			    sd->sd_vol.sv_meta.svm_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_devname);
		states[s]++;
	}

	if (states[BIOC_SDONLINE] == nd)
		new_state = BIOC_SVONLINE;
	else if (states[BIOC_SDONLINE] == 0)
		new_state = BIOC_SVOFFLINE;
	else if (states[BIOC_SDSCRUB] != 0)
		new_state = BIOC_SVSCRUB;
	else if (states[BIOC_SDREBUILD] != 0)
		new_state = BIOC_SVREBUILD;
	else if (states[BIOC_SDOFFLINE] != 0)
		new_state = BIOC_SVDEGRADED;
	else {
		printf("old_state = %d, ", old_state);
		for (i = 0; i < nd; i++)
			printf("%d = %d, ", i,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_status);
		panic("invalid new_state");
	}

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    old_state, new_state);

	switch (old_state) {
	case BIOC_SVONLINE:
		switch (new_state) {
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVOFFLINE:
		/* XXX this might be a little too much */
		goto die;

	case BIOC_SVSCRUB:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVSCRUB: /* can go to same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVBUILDING:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVBUILDING: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVREBUILD:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVREBUILD: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVDEGRADED:
		switch (new_state) {
		case BIOC_SVOFFLINE:
		case BIOC_SVREBUILD:
		case BIOC_SVDEGRADED: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	default:
die:
		panic("%s: %s: invalid volume state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_meta.svm_status = new_state;
@


1.94
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.93 2008/01/20 17:20:10 marco Exp $ */
d436 1
d439 1
d475 3
a477 2
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd READ CAPACITY\n",
		    DEVNAME(sc));
d614 1
a614 1
		bv->bv_size = sv->sv_meta.svm_size;
d647 1
a647 1
		bd->bd_size = src->src_meta.scm_size;
d718 1
a718 1
	int64_t			vol_size;
d1401 2
d1406 16
a1421 4
	bzero(&rcd, sizeof(rcd));
	_lto4b(sd->sd_vol.sv_meta.svm_size, rcd.addr);
	_lto4b(512, rcd.length);
	sr_copy_internal_data(xs, &rcd, sizeof(rcd));
d1423 1
a1423 1
	return (0);
@


1.93
log
@debug kruft
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.92 2008/01/19 23:53:53 marco Exp $ */
d826 1
a826 1
		 sd->sd_vol.sv_meta.svm_strip_size = strip_size;
d1068 3
a1070 2
		/* get partition size */
		ch_entry->src_size = size = DL_GETPSIZE(&label.d_partitions[part]) -
@


1.92
log
@Add initial scaffold for RAID 0.  No IO just yet.

Much prodding todd
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.91 2008/01/19 15:33:13 marco Exp $ */
a789 1
			printf("1 ");
a790 1
			printf("2 ");
a795 1
			printf("3 ");
a796 1
			printf("4 ");
a798 1
			printf("5 ");
a818 1
		printf("6 ");
@


1.91
log
@Remove printf that doesn't make sense.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.90 2008/01/05 07:33:37 brad Exp $ */
d716 1
d776 9
d787 18
d809 1
d816 1
a822 8
		/* fill out chunk array */
		i = 0;
		SLIST_FOREACH(ch_entry, cl, src_link)
			sd->sd_vol.sv_chunks[i++] = ch_entry;

		/* fill out all chunk metadata */
		sr_create_chunk_meta(sc, cl);

d824 1
a824 2
		ch_entry = SLIST_FIRST(cl);
		vol_size = ch_entry->src_meta.scm_coerced_size;
d832 1
d874 21
d2321 21
d2486 3
@


1.90
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok krw@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.89 2007/11/27 17:21:52 tedu Exp $ */
a892 1
		printf("default %d\n", bc->bc_level);
@


1.89
log
@also move softraid raid1 into own file, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.88 2007/11/27 16:37:05 tedu Exp $ */
d569 1
a569 1
		rv = EINVAL;
@


1.88
log
@split crypto functions out into their own file, so softraid.c is not such
a jungle.  ok deraadt marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.87 2007/11/26 20:14:42 marco Exp $ */
a102 6
int			sr_raid1_alloc_resources(struct sr_discipline *);
int			sr_raid1_free_resources(struct sr_discipline *);
int			sr_raid1_rw(struct sr_workunit *);
void			sr_raid1_intr(struct buf *);
void			sr_raid1_recreate_wu(struct sr_workunit *);

a2474 374

/* RAID 1 functions */
int
sr_raid1_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	if (!sd)
		return (rv);

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_alloc_wu(sd))
		goto bad;
	if (sr_alloc_ccb(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_raid1_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	if (!sd)
		return (rv);

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);

	rv = 0;
	return (rv);
}

int
sr_raid1_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_workunit	*wup;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	int			ios, x, i, s, rt;
	daddr64_t		blk;

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw out of bounds start: %lld "
		    "end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}

	/* calculate physical block */
	blk += SR_META_SIZE + SR_META_OFFSET;

	if (xs->flags & SCSI_DATA_IN)
		ios = 1;
	else
		ios = sd->sd_vol.sv_meta.svm_no_chunk;
	wu->swu_io_count = ios;

	for (i = 0; i < ios; i++) {
		ccb = sr_get_ccb(sd);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_vol.sv_meta.svm_devname);
			goto bad;
		}

		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
		} else {
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
		}

		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_wu = wu;

		if (xs->flags & SCSI_DATA_IN) {
			rt = 0;
ragain:
			/* interleave reads */
			x = sd->mds.mdd_raid1.sr1_counter++ %
			    sd->sd_vol.sv_meta.svm_no_chunk;
			scp = sd->sd_vol.sv_chunks[x];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
				ccb->ccb_buf.b_flags |= B_READ;
				break;

			case BIOC_SDOFFLINE:
			case BIOC_SDREBUILD:
			case BIOC_SDHOTSPARE:
				if (rt++ < sd->sd_vol.sv_meta.svm_no_chunk)
					goto ragain;

				/* FALLTHROUGH */
			default:
				/* volume offline */
				printf("%s: is offline, can't read\n",
				    DEVNAME(sd->sd_sc));
				sr_put_ccb(ccb);
				goto bad;
			}
		} else {
			/* writes go on all working disks */
			x = i;
			scp = sd->sd_vol.sv_chunks[x];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
			case BIOC_SDREBUILD:
				ccb->ccb_buf.b_flags |= B_WRITE;
				break;

			case BIOC_SDHOTSPARE: /* should never happen */
			case BIOC_SDOFFLINE:
				wu->swu_io_count--;
				sr_put_ccb(ccb);
				continue;

			default:
				goto bad;
			}

		}
		ccb->ccb_target = x;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[x]->src_dev_mm;
		ccb->ccb_buf.b_vp = NULL;

		LIST_INIT(&ccb->ccb_buf.b_dep);

		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_raid1: b_bcount: %d "
		    "b_blkno: %x b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
	}

	s = splbio();

	/* current io failed, restart */
	if (wu->swu_state == SR_WU_RESTART)
		goto start;

	/* deferred io failed, don't restart */
	if (wu->swu_state == SR_WU_REQUEUE)
		goto queued;

	/* walk queue backwards and fill in collider if we have one */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		goto queued;
	}

	/* XXX deal with polling */
start:
	sr_raid_startwu(wu);
queued:
	splx(s);
	return (0);
bad:
	/* wu is unwound by sr_put_wu */
	return (1);
}

void
sr_raid1_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	int			s, pend;

	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
	    DEVNAME(sc), bp, xs);

	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %lld target: %d\n", DEVNAME(sc),
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);

	s = splbio();

	if (ccb->ccb_buf.b_flags & B_ERROR) {
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;

	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete >= wu->swu_io_count) {
		/* if all ios failed, retry reads and give up on writes */
		if (wu->swu_ios_failed == wu->swu_ios_complete) {
			if (xs->flags & SCSI_DATA_IN) {
				printf("%s: retrying read on block %lld\n",
				    DEVNAME(sc), ccb->ccb_buf.b_blkno);
				sr_put_ccb(ccb);
				TAILQ_INIT(&wu->swu_ccb);
				wu->swu_state = SR_WU_RESTART;
				if (sd->sd_scsi_rw(wu))
					goto bad;
				else
					goto retry;
			} else {
				printf("%s: permanently fail write on block "
				    "%lld\n", DEVNAME(sc),
				    ccb->ccb_buf.b_blkno);
				xs->error = XS_DRIVER_STUFFUP;
				goto bad;
			}
		}

		xs->error = XS_NOERROR;
		xs->resid = 0;
		xs->flags |= ITSDONE;

		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					if (wu->swu_ios_failed)
						/* toss all ccbs and recreate */
						sr_raid1_recreate_wu(wu->swu_collider);

					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
		}

		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		/* do not change the order of these 2 functions */
		sr_put_wu(wu);
		scsi_done(xs);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

retry:
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
	xs->flags |= ITSDONE;
	sr_put_wu(wu);
	scsi_done(xs);
	splx(s);
}

void
sr_raid1_recreate_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup = wu;
	struct sr_ccb		*ccb;

	do {
		DNPRINTF(SR_D_INTR, "%s: sr_raid1_recreate_wu: %p\n", wup);

		/* toss all ccbs */
		while ((ccb = TAILQ_FIRST(&wup->swu_ccb)) != NULL) {
			TAILQ_REMOVE(&wup->swu_ccb, ccb, ccb_link);
			sr_put_ccb(ccb);
		}
		TAILQ_INIT(&wup->swu_ccb);

		/* recreate ccbs */
		wup->swu_state = SR_WU_REQUEUE;
		if (sd->sd_scsi_rw(wup))
			panic("could not requeue io");

		wup = wup->swu_collider;
	} while (wup);
}
@


1.87
log
@Just CRYPTO; RAID CRYPTO doesn't mean anything.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.86 2007/11/26 13:49:26 tedu Exp $ */
a102 22
/* work units & ccbs */
int			sr_alloc_ccb(struct sr_discipline *);
void			sr_free_ccb(struct sr_discipline *);
struct sr_ccb		*sr_get_ccb(struct sr_discipline *);
void			sr_put_ccb(struct sr_ccb *);
int			sr_alloc_wu(struct sr_discipline *);
void			sr_free_wu(struct sr_discipline *);
struct sr_workunit	*sr_get_wu(struct sr_discipline *);
void			sr_put_wu(struct sr_workunit *);

/* discipline functions */
int			sr_raid_inquiry(struct sr_workunit *);
int			sr_raid_read_cap(struct sr_workunit *);
int			sr_raid_tur(struct sr_workunit *);
int			sr_raid_request_sense( struct sr_workunit *);
int			sr_raid_start_stop(struct sr_workunit *);
int			sr_raid_sync(struct sr_workunit *);
void			sr_raid_set_chunk_state(struct sr_discipline *,
			    int, int);
void			sr_raid_set_vol_state(struct sr_discipline *);
void			sr_raid_startwu(struct sr_workunit *);

a108 9
struct cryptop *	sr_raidc_getcryptop(struct sr_workunit *, int);
void *			sr_raidc_putcryptop(struct cryptop *);
int			sr_raidc_alloc_resources(struct sr_discipline *);
int			sr_raidc_free_resources(struct sr_discipline *);
int			sr_raidc_rw(struct sr_workunit *);
int			sr_raidc_rw2(struct cryptop *);
void			sr_raidc_intr(struct buf *);
int			sr_raidc_intr2(struct cryptop *);

d885 2
a886 2
		sd->sd_alloc_resources = sr_raidc_alloc_resources;
		sd->sd_free_resources = sr_raidc_free_resources;
d893 1
a893 1
		sd->sd_scsi_rw = sr_raidc_rw;
a2854 414

#ifdef CRYPTO
/* RAID crypto functions */
struct cryptop *
sr_raidc_getcryptop(struct sr_workunit *wu, int encrypt)
{
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_discipline	*sd = wu->swu_dis;
	struct cryptop		*crp;
	struct cryptodesc	*crd;
	struct uio		*uio;
	int			flags, i, n;
	int			blk = 0;

	DNPRINTF(SR_D_DIS, "%s: sr_raidc_getcryptop wu: %p encrypt: %d\n",
	    DEVNAME(sd->sd_sc), wu, encrypt);

	uio = malloc(sizeof(*uio), M_DEVBUF, M_WAITOK | M_ZERO);
	uio->uio_iov = malloc(sizeof(*uio->uio_iov), M_DEVBUF, M_WAITOK);
	uio->uio_iovcnt = 1;
	uio->uio_iov->iov_base = xs->data;
	uio->uio_iov->iov_len = xs->datalen;

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);

	n = xs->datalen >> 9;
	flags = (encrypt ? CRD_F_ENCRYPT : 0) |
	    CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;

	crp = crypto_getreq(n);

	crp->crp_sid = sd->mds.mdd_raidc.src_sid;
	crp->crp_ilen = xs->datalen;
	crp->crp_alloctype = M_DEVBUF;
	crp->crp_buf = uio;
	for (i = 0, crd = crp->crp_desc; crd; i++, crd = crd->crd_next) {
		crd->crd_skip = 512 * i;
		crd->crd_len = 512;
		crd->crd_inject = 0;
		crd->crd_flags = flags;
		crd->crd_alg = CRYPTO_AES_CBC;
		crd->crd_klen = 256;
		crd->crd_rnd = 14;
		crd->crd_key = sd->mds.mdd_raidc.src_key;
		memset(crd->crd_iv, blk + i, sizeof(crd->crd_iv));
	}

	return (crp);
}

void *
sr_raidc_putcryptop(struct cryptop *crp)
{
	struct uio		*uio = crp->crp_buf;
	void			*opaque = crp->crp_opaque;

	DNPRINTF(SR_D_DIS, "sr_raidc_putcryptop crp: %p\n", crp);

	free(uio->uio_iov, M_DEVBUF);
	free(uio, M_DEVBUF);
	crypto_freereq(crp);

	return (opaque);
}

int
sr_raidc_alloc_resources(struct sr_discipline *sd)
{
	struct cryptoini	cri;

	if (!sd)
		return (EINVAL);

	DNPRINTF(SR_D_DIS, "%s: sr_raidc_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_alloc_wu(sd))
		return (ENOMEM);
	if (sr_alloc_ccb(sd))
		return (ENOMEM);

	/* XXX we need a real key later */
	memset(sd->mds.mdd_raidc.src_key, 'k',
	    sizeof sd->mds.mdd_raidc.src_key);

	bzero(&cri, sizeof(cri));
	cri.cri_alg = CRYPTO_AES_CBC;
	cri.cri_klen = 256;
	cri.cri_rnd = 14;
	cri.cri_key = sd->mds.mdd_raidc.src_key;

	return (crypto_newsession(&sd->mds.mdd_raidc.src_sid, &cri, 0));
}

int
sr_raidc_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	if (!sd)
		return (rv);

	DNPRINTF(SR_D_DIS, "%s: sr_raidc_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);

	rv = 0;
	return (rv);
}

int
sr_raidc_rw(struct sr_workunit *wu)
{
	struct cryptop		*crp;

	DNPRINTF(SR_D_DIS, "%s: sr_raidc_rw wu: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu);

	crp = sr_raidc_getcryptop(wu, 1);
	crp->crp_callback = sr_raidc_rw2;
	crp->crp_opaque = wu;
	crypto_dispatch(crp);

	return (0);
}

int
sr_raidc_rw2(struct cryptop *crp)
{
	struct sr_workunit	*wu = sr_raidc_putcryptop(crp);
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_workunit	*wup;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	int			s, rt;
	daddr64_t		blk;

	DNPRINTF(SR_D_DIS, "%s: sr_raidc_rw2 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_raidc_rw device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_raidc_rw2 out of bounds start: %lld "
		    "end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}

	/* calculate physical block */
	blk += SR_META_SIZE + SR_META_OFFSET;

	wu->swu_io_count = 1;

	ccb = sr_get_ccb(sd);
	if (!ccb) {
		/* should never happen but handle more gracefully */
		printf("%s: %s: too many ccbs queued\n",
		    DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->flags & SCSI_POLL) {
		panic("not yet, crypto poll");
		ccb->ccb_buf.b_flags = 0;
		ccb->ccb_buf.b_iodone = NULL;
	} else {
		ccb->ccb_buf.b_flags = B_CALL;
		ccb->ccb_buf.b_iodone = sr_raidc_intr;
	}

	ccb->ccb_buf.b_blkno = blk;
	ccb->ccb_buf.b_bcount = xs->datalen;
	ccb->ccb_buf.b_bufsize = xs->datalen;
	ccb->ccb_buf.b_resid = xs->datalen;
	ccb->ccb_buf.b_data = xs->data;
	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_wu = wu;

	if (xs->flags & SCSI_DATA_IN) {
		rt = 0;
ragain:
		scp = sd->sd_vol.sv_chunks[0];
		switch (scp->src_meta.scm_status) {
		case BIOC_SDONLINE:
		case BIOC_SDSCRUB:
			ccb->ccb_buf.b_flags |= B_READ;
			break;

		case BIOC_SDOFFLINE:
		case BIOC_SDREBUILD:
		case BIOC_SDHOTSPARE:
			if (rt++ < sd->sd_vol.sv_meta.svm_no_chunk)
				goto ragain;

			/* FALLTHROUGH */
		default:
			/* volume offline */
			printf("%s: is offline, can't read\n",
			    DEVNAME(sd->sd_sc));
			sr_put_ccb(ccb);
			goto bad;
		}
	} else {
		scp = sd->sd_vol.sv_chunks[0];
		switch (scp->src_meta.scm_status) {
		case BIOC_SDONLINE:
		case BIOC_SDSCRUB:
		case BIOC_SDREBUILD:
			ccb->ccb_buf.b_flags |= B_WRITE;
			break;

		case BIOC_SDHOTSPARE: /* should never happen */
		case BIOC_SDOFFLINE:
			wu->swu_io_count--;
			sr_put_ccb(ccb);
			goto bad;

		default:
			goto bad;
		}

	}
	ccb->ccb_target = 0;
	ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[0]->src_dev_mm;
	ccb->ccb_buf.b_vp = NULL;

	LIST_INIT(&ccb->ccb_buf.b_dep);

	TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

	DNPRINTF(SR_D_DIS, "%s: %s: sr_raidc: b_bcount: %d "
	    "b_blkno: %x b_flags 0x%0x b_data %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);


	/* walk queue backwards and fill in collider if we have one */
	s = splbio();
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		goto queued;
	}

	/* XXX deal with polling */

	sr_raid_startwu(wu);

queued:
	splx(s);
	return (0);
bad:
	/* wu is unwound by sr_put_wu */
	return (1);
}

void
sr_raidc_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
	struct cryptop		*crp;
#ifdef SR_DEBUG
	struct sr_softc		*sc = wu->swu_dis->sd_sc;
#endif

	DNPRINTF(SR_D_INTR, "%s: sr_raidc_intr bp: %x xs: %x\n",
	    DEVNAME(sc), bp, wu->swu_xs);

	DNPRINTF(SR_D_INTR, "%s: sr_raidc_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x\n", DEVNAME(sc), ccb->ccb_buf.b_bcount,
	    ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags);

	crp = sr_raidc_getcryptop(wu, 0);
	crp->crp_callback = sr_raidc_intr2;
	crp->crp_opaque = bp;
	crypto_dispatch(crp);
}

int
sr_raidc_intr2(struct cryptop *crp)
{
	struct buf		*bp = sr_raidc_putcryptop(crp);
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	int			s, pend;

	DNPRINTF(SR_D_INTR, "%s: sr_raidc_intr2 crp: %x xs: %x\n",
	    DEVNAME(sc), crp, xs);

	s = splbio();

	if (ccb->ccb_buf.b_flags & B_ERROR) {
		printf("%s: i/o error on block %lld\n", DEVNAME(sc),
		    ccb->ccb_buf.b_blkno);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;

	DNPRINTF(SR_D_INTR, "%s: sr_raidc_intr2: comp: %d count: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count);

	if (wu->swu_ios_complete == wu->swu_io_count) {
		if (wu->swu_ios_failed == wu->swu_ios_complete)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;

		xs->resid = 0;
		xs->flags |= ITSDONE;

		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
		}

		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		/* do not change the order of these 2 functions */
		sr_put_wu(wu);
		scsi_done(xs);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

	splx(s);

	return (0);
}
#endif
@


1.86
log
@rename RAID C to RAID CRYPTO.  makes marco happier
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.85 2007/11/16 05:08:39 djm Exp $ */
d823 1
a823 1
			strlcpy(sd->sd_name, "RAID CRYPTO", sizeof(sd->sd_name));
@


1.85
log
@use arc4random_bytes() instead of multiple arc4random() calls;
ok deraadt@@ dlg@@ henric@@ mcbride@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.84 2007/09/11 13:39:33 gilles Exp $ */
d820 1
a820 1
		case 'c':
d823 1
a823 1
			strlcpy(sd->sd_name, "RAID C", sizeof(sd->sd_name));
d909 1
a909 1
	case 'c':
d911 1
a911 1
		sd->sd_type = SR_MD_RAIDC;
d913 1
a913 1
		sd->sd_max_wu = SR_RAIDC_NOWU;
@


1.84
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.83 2007/09/08 17:59:23 gilles Exp $ */
d1757 1
a1757 4
	int			i;

	for (i = 0; i < SR_UUID_MAX; i++)
		uuid->sui_id[i] = arc4random();
@


1.83
log
@more M_ZERO changes

ok pyr@@ and krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.82 2007/06/24 05:34:35 dlg Exp $ */
d251 1
a251 1
	    sd->sd_max_wu * sd->sd_max_ccb_per_wu, M_DEVBUF, M_WAITOK|M_ZERO);
d343 1
a343 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
d766 1
a766 1
	dt = malloc(bc->bc_dev_list_len, M_DEVBUF, M_WAITOK|M_ZERO);
d772 1
a772 1
	sd = malloc(sizeof(struct sr_discipline), M_DEVBUF, M_WAITOK|M_ZERO);
d782 1
a782 1
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK|M_ZERO);
d786 1
a786 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
d1024 2
a1025 1
		ch_entry = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_WAITOK|M_ZERO);
d1108 1
a1108 1
	m = malloc(sz , M_DEVBUF, M_WAITOK|M_ZERO);
d1789 1
a1789 1
	m = malloc(sz , M_DEVBUF, M_WAITOK|M_ZERO);
d2102 2
a2103 1
				mle = malloc(sizeof(*mle), M_DEVBUF, M_WAITOK|M_ZERO);
d2105 1
a2105 1
				    M_WAITOK|M_ZERO);
d2906 1
a2906 1
	uio = malloc(sizeof(*uio), M_DEVBUF, M_WAITOK|M_ZERO);
@


1.82
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.81 2007/06/06 23:06:02 deraadt Exp $ */
d251 1
a251 3
	    sd->sd_max_wu * sd->sd_max_ccb_per_wu, M_DEVBUF, M_WAITOK);
	memset(sd->sd_ccb, 0, sizeof(struct sr_ccb) *
	    sd->sd_max_wu * sd->sd_max_ccb_per_wu);
d343 1
a343 2
	    M_DEVBUF, M_WAITOK);
	memset(sd->sd_wu, 0, sizeof(struct sr_workunit) * no_wu);
d766 1
a766 2
	dt = malloc(bc->bc_dev_list_len, M_DEVBUF, M_WAITOK);
	bzero(dt, bc->bc_dev_list_len);
d772 1
a772 2
	sd = malloc(sizeof(struct sr_discipline), M_DEVBUF, M_WAITOK);
	memset(sd, 0, sizeof(struct sr_discipline));
d782 1
a782 2
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK);
	bzero(sd->sd_meta, SR_META_SIZE  * 512);
d786 1
a786 2
	    M_DEVBUF, M_WAITOK);
	bzero(sd->sd_vol.sv_chunks, sizeof(struct sr_chunk *) * no_chunk);
d1024 1
a1024 2
		ch_entry = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_WAITOK);
		bzero(ch_entry, sizeof(struct sr_chunk));
d1107 1
a1107 2
	m = malloc(sz , M_DEVBUF, M_WAITOK);
	bzero(m, sz);
d1788 1
a1788 2
	m = malloc(sz , M_DEVBUF, M_WAITOK);
	bzero(m, sz);
d2101 1
a2101 2
				mle = malloc(sizeof(*mle), M_DEVBUF, M_WAITOK);
				bzero(mle, sizeof(*mle));
d2103 1
a2103 2
				    M_WAITOK);
				bzero(mle->sml_metadata, sz);
d2904 1
a2904 2
	uio = malloc(sizeof(*uio), M_DEVBUF, M_WAITOK);
	memset(uio, 0, sizeof(*uio));
@


1.81
log
@correct format strings for large types; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.80 2007/06/05 16:30:02 marco Exp $ */
d2365 1
a2365 1
		if (sensor_task_register(sc, sr_refresh_sensors, 10) != 0)
@


1.80
log
@Shuffle calculation of physical block so that bounds checking is not off by
48 blocks (metadata + metdata offset).  Found by drahn.
Fix panic message while in the same area.

Help from otto who wrote a diff that worked around the issue.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.79 2007/06/05 03:08:10 todd Exp $ */
d106 1
a106 1
struct sr_ccb 		*sr_get_ccb(struct sr_discipline *);
d110 1
a110 1
struct sr_workunit 	*sr_get_wu(struct sr_discipline *);
d225 1
a225 1
	size_t 			copy_cnt;
d250 1
a250 1
	sd->sd_ccb = malloc(sizeof(struct sr_ccb) * 
d446 1
a446 1
	DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd: scsibus: %d xs: %p "
d755 1
a755 1
	u_quad_t		vol_size;
d848 3
a850 2
		DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_createraid: vol_size: %llu\n"
		    , DEVNAME(sc), vol_size);
d976 1
a976 1
	DNPRINTF(SR_D_IOCTL, "%s: sr device added: %s on scsibus: %d\n",
d1024 1
a1024 1
	quad_t			size;
d1075 1
a1075 1
		
d1251 1
a1251 1
	u_quad_t		max_chunk_sz = 0, min_chunk_sz;
d1726 1
a1726 1
 		case BIOC_SVDEGRADED: /* can go to the same state */
d2036 1
a2036 1
		bp->b_dev = dev =  MAKEDISKDEV(majdev, dv->dv_unit, RAW_PART);
d2133 1
a2133 1
	 * XXX poor mans hack that doesn't keep disks in order and does not 
d2156 1
a2156 1
			if (bcmp(&mle->sml_metadata->ssd_uuid, 
d2498 1
a2498 1
	DNPRINTF(SR_D_META, "\t\tvol size %llu\n", im_sv->svm_size);
d2516 1
a2516 1
		DNPRINTF(SR_D_META, "\t\t\tchunk size %llu\n",
d2518 1
a2518 1
		DNPRINTF(SR_D_META, "\t\t\tchunk coerced size %llu\n",
d2721 1
a2721 1
	
d2776 1
a2776 1
	    " b_flags: 0x%0x block: %llu target: %d\n", DEVNAME(sc),
d2783 1
a2783 1
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %llu target: %d\n", 
a2791 2
		

d2806 1
a2806 1
				printf("%s: retrying read on block %llu\n", 
d2817 1
a2817 1
				    "%llu\n", DEVNAME(sc),
a3045 1
	
d3251 1
a3251 1
		printf("%s: i/o error on block %llu\n", DEVNAME(sc),
@


1.79
log
@consistently use one variable instead of deriving it repeatedly
from and ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.78 2007/06/05 00:38:20 deraadt Exp $ */
a2603 7
	if (xs->flags & SCSI_DATA_IN)
		ios = 1;
	else
		ios = sd->sd_vol.sv_meta.svm_no_chunk;

	blk += SR_META_SIZE + SR_META_OFFSET;

a2605 1
	wu->swu_io_count = ios;
d2621 9
a3072 2
	blk += SR_META_SIZE + SR_META_OFFSET;

a3074 1
	wu->swu_io_count = 1;
d3090 5
d3105 1
a3105 1
		panic("p");
@


1.78
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.77 2007/06/04 04:53:31 marco Exp $ */
d2036 1
a2036 1
		bdsw = &bdevsw[major(dev)];
@


1.77
log
@use S_IFCHR instead of S_IFBLK to shut the SCSI midlayer up during
autoconf.

ok drahn@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.76 2007/06/03 22:36:27 tedu Exp $ */
d1076 1
a1076 1
		ch_entry->src_size = size = label.d_partitions[part].p_size -
@


1.76
log
@put raidc inside ifdef CRYPTO, since it won't work without it
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.75 2007/06/03 22:33:35 tedu Exp $ */
d2043 6
d2051 1
a2051 1
		error = (*bdsw->d_open)(dev, FREAD, S_IFBLK, curproc);
d2064 1
a2064 1
			error = (*bdsw->d_close)(dev, FREAD, S_IFBLK, curproc);
d2069 1
a2069 1
		error = (*bdsw->d_close)(dev, FREAD, S_IFBLK, curproc);
d2083 1
a2083 1
			error = (*bdsw->d_open)(devr, FREAD, S_IFBLK, curproc);
d2102 1
a2102 1
				error = (*bdsw->d_close)(devr, FREAD, S_IFBLK,
d2121 1
a2121 1
			error = (*bdsw->d_close)(devr, FREAD, S_IFBLK,
@


1.75
log
@shuffle the raid 1 specific functions to be all together and closer
to the bottom, after common functions.  ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.74 2007/06/03 12:57:51 deraadt Exp $ */
d914 1
d934 1
d2894 1
d3306 1
@


1.74
log
@virtual device drivers tend not to need machine/bus.h.  also important
because mvme68k (and perhaps others) do not have it.  showed it to dlg
who just shook his head
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.73 2007/06/03 04:27:09 marco Exp $ */
a1370 43
/* RAID 1 functions */
int
sr_raid1_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	if (!sd)
		return (rv);

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_alloc_wu(sd))
		goto bad;
	if (sr_alloc_ccb(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_raid1_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	if (!sd)
		return (rv);

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);

	rv = 0;
	return (rv);
}

a1521 192
int
sr_raid1_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_workunit	*wup;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	int			ios, x, i, s, rt;
	daddr64_t		blk;

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->flags & SCSI_DATA_IN)
		ios = 1;
	else
		ios = sd->sd_vol.sv_meta.svm_no_chunk;

	blk += SR_META_SIZE + SR_META_OFFSET;

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;
	wu->swu_io_count = ios;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw out of bounds start: %lld "
		    "end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}

	for (i = 0; i < ios; i++) {
		ccb = sr_get_ccb(sd);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_vol.sv_meta.svm_devname);
			goto bad;
		}

		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
		} else {
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
		}

		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_wu = wu;

		if (xs->flags & SCSI_DATA_IN) {
			rt = 0;
ragain:
			/* interleave reads */
			x = sd->mds.mdd_raid1.sr1_counter++ %
			    sd->sd_vol.sv_meta.svm_no_chunk;
			scp = sd->sd_vol.sv_chunks[x];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
				ccb->ccb_buf.b_flags |= B_READ;
				break;

			case BIOC_SDOFFLINE:
			case BIOC_SDREBUILD:
			case BIOC_SDHOTSPARE:
				if (rt++ < sd->sd_vol.sv_meta.svm_no_chunk)
					goto ragain;

				/* FALLTHROUGH */
			default:
				/* volume offline */
				printf("%s: is offline, can't read\n",
				    DEVNAME(sd->sd_sc));
				sr_put_ccb(ccb);
				goto bad;
			}
		} else {
			/* writes go on all working disks */
			x = i;
			scp = sd->sd_vol.sv_chunks[x];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
			case BIOC_SDREBUILD:
				ccb->ccb_buf.b_flags |= B_WRITE;
				break;

			case BIOC_SDHOTSPARE: /* should never happen */
			case BIOC_SDOFFLINE:
				wu->swu_io_count--;
				sr_put_ccb(ccb);
				continue;

			default:
				goto bad;
			}

		}
		ccb->ccb_target = x;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[x]->src_dev_mm;
		ccb->ccb_buf.b_vp = NULL;

		LIST_INIT(&ccb->ccb_buf.b_dep);

		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_raid1: b_bcount: %d "
		    "b_blkno: %x b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
	}
	
	s = splbio();

	/* current io failed, restart */
	if (wu->swu_state == SR_WU_RESTART)
		goto start;

	/* deferred io failed, don't restart */
	if (wu->swu_state == SR_WU_REQUEUE)
		goto queued;

	/* walk queue backwards and fill in collider if we have one */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
		goto queued;
	}

	/* XXX deal with polling */
start:
	sr_raid_startwu(wu);
queued:
	splx(s);
	return (0);
bad:
	/* wu is unwound by sr_put_wu */
	return (1);
}

d1547 1
a1547 1
sr_raid1_intr(struct buf *bp)
d1549 1
a1549 6
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	int			s, pend;
d1551 3
a1553 7
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
	    DEVNAME(sc), bp, xs);

	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %llu target: %d\n", DEVNAME(sc),
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);
d1555 1
d1557 1
a1557 133

	if (ccb->ccb_buf.b_flags & B_ERROR) {
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %llu target: %d\n", 
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
		

	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;

	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete >= wu->swu_io_count) {
		/* if all ios failed, retry reads and give up on writes */
		if (wu->swu_ios_failed == wu->swu_ios_complete) {
			if (xs->flags & SCSI_DATA_IN) {
				printf("%s: retrying read on block %llu\n", 
				    DEVNAME(sc), ccb->ccb_buf.b_blkno);
				sr_put_ccb(ccb);
				TAILQ_INIT(&wu->swu_ccb);
				wu->swu_state = SR_WU_RESTART;
				if (sd->sd_scsi_rw(wu))
					goto bad;
				else
					goto retry;
			} else {
				printf("%s: permanently fail write on block "
				    "%llu\n", DEVNAME(sc),
				    ccb->ccb_buf.b_blkno);
				xs->error = XS_DRIVER_STUFFUP;
				goto bad;
			}
		}

		xs->error = XS_NOERROR;
		xs->resid = 0;
		xs->flags |= ITSDONE;

		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					if (wu->swu_ios_failed)
						/* toss all ccbs and recreate */
						sr_raid1_recreate_wu(wu->swu_collider);

					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
		}

		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		/* do not change the order of these 2 functions */
		sr_put_wu(wu);
		scsi_done(xs);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

retry:
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
	xs->flags |= ITSDONE;
	sr_put_wu(wu);
	scsi_done(xs);
	splx(s);
}

void
sr_raid1_recreate_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup = wu;
	struct sr_ccb		*ccb;

	do {
		DNPRINTF(SR_D_INTR, "%s: sr_raid1_recreate_wu: %p\n", wup);

		/* toss all ccbs */
		while ((ccb = TAILQ_FIRST(&wup->swu_ccb)) != NULL) {
			TAILQ_REMOVE(&wup->swu_ccb, ccb, ccb_link);
			sr_put_ccb(ccb);
		}
		TAILQ_INIT(&wup->swu_ccb);

		/* recreate ccbs */
		wup->swu_state = SR_WU_REQUEUE;
		if (sd->sd_scsi_rw(wup))
			panic("could not requeue io");

		wup = wup->swu_collider;
	} while (wup);
}

void
sr_raid_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;
d2516 375
@


1.73
log
@During autoassemble get the actual raid level instead of always 1.
Sprinkle debug throughout crypto discipline.
Various knf, bad tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.72 2007/06/02 01:52:25 marco Exp $ */
a39 2

#include <machine/bus.h>
@


1.72
log
@Disable crypto until we figure out proper key management and other stuff
only tedu understands.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.71 2007/06/02 01:49:27 marco Exp $ */
d2389 1
d2547 2
a2548 1
		bc.bc_level = 1;
d2904 4
a2907 1
	int blk = 0;
d2921 1
a2921 1
	n = xs->datalen / 512;
d2942 2
a2943 1
	return crp;
d2951 3
d2958 1
a2958 1
	return opaque;
d2978 3
a2980 1
	memset(sd->mds.mdd_raidc.src_key, 'k', sizeof sd->mds.mdd_raidc.src_key);
d3016 3
d3023 2
a3024 1
	return 0;
d3040 1
a3040 1
	DNPRINTF(SR_D_DIS, "%s: sr_raidc_rw 0x%02x\n", DEVNAME(sd->sd_sc),
d3213 1
a3213 1
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
d3216 1
a3216 1
	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
d3237 3
d3258 1
a3258 1
	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d\n",
d3296 3
d3302 2
a3303 1
	return 0;
@


1.71
log
@Fix collision by not adding data length but blocks instead.
Some clean up.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.70 2007/06/02 00:53:35 marco Exp $ */
d828 1
d834 1
@


1.70
log
@Add optional metadata element.  This will be needed in the future for
certain disciplines.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.69 2007/06/02 00:27:44 marco Exp $ */
d1609 1
a1609 1
	wu->swu_blk_end = blk + xs->datalen - 1;
d1613 4
a1714 19

#if 0
		/* vprint("despatch: ", ccb->ccb_buf.b_vp); */
		ccb->ccb_buf.b_vp->v_numoutput++;
		VOP_STRATEGY(&ccb->ccb_buf);
		if (xs->flags & SCSI_POLL) {
			/* polling, wait for completion */
			biowait(&ccb->ccb_buf);
			if (ccb->ccb_buf.b_flags & B_ERROR) {
				printf("%s: %s: %s: i/o error on block %d\n",
				    DEVNAME(sd->sd_sc),
				    sd->sd_vol.sv_meta.svm_devname,
				    sd->sd_vol.sv_chunks[x]->src_meta.scm_devname,
				    ccb->ccb_buf.b_blkno);
			/* don't abort other ios because of error */
			}
			sr_put_ccb(ccb);
		}
#endif
d3051 1
a3051 1
	wu->swu_blk_end = blk + xs->datalen - 1;
d3053 14
@


1.69
log
@Redo the sense mechanism to become autosense instead of request sense.
General cleanup in the sense code.

This was prompted by grunk.  He found that out of bounds conditions were
knocking disks offline (which was obviously a bug).
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.68 2007/06/01 22:23:03 marco Exp $ */
d2309 5
@


1.68
log
@check return value of findblkmajor; this fixes a crash on vax during boot.
add check for failed geteblk.
exclude rx during boot probe.

help miod todd
ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.67 2007/06/01 18:50:56 marco Exp $ */
a474 13
	/* if we have sense data let the midlayer know */
	if (sd->sd_scsi_sense.flags != SKEY_NO_SENSE &&
	    (!(xs->cmd->opcode == REQUEST_SENSE ||
	    xs->cmd->opcode == INQUIRY))) {
		DNPRINTF(SR_D_CMD, "%s: sr_scsi_cmd opcode 0x%02x sense "
		    "0x%02x 0x%02x\n", DEVNAME(sc), xs->cmd->opcode,
		    sd->sd_scsi_sense.add_sense_code,
		    sd->sd_scsi_sense.add_sense_code_qual);
		xs->error = XS_SENSE;
		xs->flags |= ITSDONE;
		goto complete;
	}

d537 8
a544 2
	xs->error = XS_DRIVER_STUFFUP;
	xs->flags |= ITSDONE;
a757 1
	u_int32_t		sense;
a957 6
	sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT;
	sd->sd_scsi_sense.segment = 0;
	sd->sd_scsi_sense.flags = SKEY_NO_SENSE;
	sense = htole32(0);
	bcopy(&sense, sd->sd_scsi_sense.info, sizeof(sense));
	sd->sd_scsi_sense.extra_len = 0;
a1465 1
		sd->sd_scsi_sense.segment = 0;
d1469 1
a1469 2
		*(u_int32_t*)sd->sd_scsi_sense.info = htole32(0);
		sd->sd_scsi_sense.extra_len = 0;
a1472 1
		sd->sd_scsi_sense.segment = 0;
d1476 1
a1476 2
		*(u_int32_t*)sd->sd_scsi_sense.info = htole32(0);
		sd->sd_scsi_sense.extra_len = 0;
d1493 1
a1493 2
	sr_copy_internal_data(xs, &sd->sd_scsi_sense,
	    sizeof(sd->sd_scsi_sense));
a1496 5
	sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT;
	sd->sd_scsi_sense.segment = 0;
	sd->sd_scsi_sense.flags = SKEY_NO_SENSE;
	*(u_int32_t*)sd->sd_scsi_sense.info = htole32(0);
	sd->sd_scsi_sense.extra_len = 0;
d1611 10
@


1.67
log
@Add additional flag to indicate that we have a metdadata io pending; this
way if we shut down the system we can make sure that it makes it onto disk
before scsibus detach.

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.66 2007/06/01 17:43:05 marco Exp $ */
d2420 2
d2428 3
d2436 2
a2437 1
		    !strncmp(dv->dv_xname, "cd", 2))
@


1.66
log
@Check return code for resource allocation.

prompted by tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.65 2007/06/01 01:16:48 marco Exp $ */
d1365 1
a1365 1
	while (sd->sd_sync)
d2021 1
d2251 5
d2258 4
a2261 1
		    DEVNAME(((struct sr_discipline *)arg1)->sd_sc));
@


1.65
log
@save metdata in context using dlg and tedu's shiny new workq api.
detect stale metadata during bringup.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.64 2007/05/31 22:04:23 marco Exp $ */
d947 2
a948 1
	sd->sd_alloc_resources(sd);
d1397 4
a1400 2
	sr_alloc_wu(sd);
	sr_alloc_ccb(sd);
d1403 1
d2970 4
a2973 2
	sr_alloc_wu(sd);
	sr_alloc_ccb(sd);
@


1.64
log
@Redo the syncer to be a little smarter on interaction while shutting down
the system

help and ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.63 2007/05/31 18:56:27 marco Exp $ */
d149 1
d896 1
a896 1
		printf("%s: not yet partial bringup", DEVNAME(sc));
d1121 1
a1121 1
	u_int32_t		volid;
d1211 1
a1211 1
			printf("%s: %s chunk id %d already in use\n ",
d1221 13
d2017 1
a2017 1
	sr_save_metadata(sd, SR_VOL_DIRTY);
d2241 8
@


1.63
log
@Fix redundancy for RAID 1.  Now one can pull a disk and continue running.

help from drahn
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.62 2007/05/31 06:26:23 grunk Exp $ */
d1338 1
d1346 2
d1350 4
a1353 3
	while (tsleep(sr_shutdown_discipline, MAXPRI, "sr_down", 1 * hz) !=
	    EWOULDBLOCK)
		;
d1366 2
d1556 1
a1556 1
		if (tsleep(sd, PRIBIO, "sr_sync", 60 * hz) == EWOULDBLOCK) {
d1566 2
d2003 1
d2561 2
@


1.62
log
@- zap unnecessary rv variable
- sprinkle an XXX to remember that we have to supply a serious key later

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.61 2007/05/30 17:56:37 marco Exp $ */
d53 1
d131 1
d1719 10
a1730 1
	s = splbio();
d1750 1
a1750 1

a1751 1

d1768 10
a1777 2
	/* move wu to pending queue */
	TAILQ_INSERT_TAIL(&sd->sd_wu_pendq, wu, swu_link);
d1798 3
a1800 2
	    " b_flags: 0x%0x\n", DEVNAME(sc), ccb->ccb_buf.b_bcount,
	    ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags);
d1805 2
a1806 2
		printf("%s: i/o error on block %llu\n", DEVNAME(sc),
		    ccb->ccb_buf.b_blkno);
d1814 2
d1822 25
a1846 8
	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count);

	if (wu->swu_ios_complete == wu->swu_io_count) {
		if (wu->swu_ios_failed == wu->swu_ios_complete)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;
d1848 1
d1860 4
d1887 1
d1889 33
d3148 3
d3153 1
a3153 1
	    DEVNAME(sc), bp, xs);
@


1.61
log
@Make sure that if there are staggered syncs that they complete successfully
before detaching the scsi bus.

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.60 2007/05/30 16:54:07 marco Exp $ */
a2847 1
	int			rv = EINVAL;
d2851 1
a2851 1
		return (rv);
d2858 2
a2865 1
	rv = crypto_newsession(&sd->mds.mdd_raidc.src_sid, &cri, 0);
d2867 1
a2867 1
	return (rv);
@


1.60
log
@Remove ugly print and don't panic when doing a partial bringup.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.59 2007/05/30 15:59:35 marco Exp $ */
d1342 6
@


1.59
log
@Sync after the metadata is saved.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.58 2007/05/30 13:55:47 tedu Exp $ */
d834 1
a834 2
			if (no_chunk != 1) {
				printf("too many c chunks\n");
a835 1
			}
d893 2
a894 1
		panic("not yet partial bringup");
@


1.58
log
@add basic support for a crypto(9) backed raid C discipline
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.57 2007/05/29 23:20:02 marco Exp $ */
d400 1
d1532 1
a1532 1
	int			s, rv = 0;
d1536 3
d1542 1
a1542 1
	while (sd->sd_wu_pending > 1)
d2147 1
d2264 5
@


1.57
log
@Add dirty bit for volumes
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.56 2007/05/29 22:12:42 marco Exp $ */
d37 3
d115 11
a127 1

a128 6
int			sr_raid1_inquiry(struct sr_workunit *);
int			sr_raid1_read_cap(struct sr_workunit *);
int			sr_raid1_tur(struct sr_workunit *);
int			sr_raid1_request_sense( struct sr_workunit *);
int			sr_raid1_start_stop(struct sr_workunit *);
int			sr_raid1_sync(struct sr_workunit *);
d130 9
a138 4
void			sr_raid1_set_chunk_state(struct sr_discipline *,
			    int, int);
void			sr_raid1_set_vol_state(struct sr_discipline *);
void			sr_raid1_startwu(struct sr_workunit *);
d832 7
d909 6
a914 6
		sd->sd_scsi_inquiry = sr_raid1_inquiry;
		sd->sd_scsi_read_cap = sr_raid1_read_cap;
		sd->sd_scsi_tur = sr_raid1_tur;
		sd->sd_scsi_req_sense = sr_raid1_request_sense;
		sd->sd_scsi_start_stop = sr_raid1_start_stop;
		sd->sd_scsi_sync = sr_raid1_sync;
d916 21
a936 2
		sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
		sd->sd_set_vol_state = sr_raid1_set_vol_state;
d939 1
d1397 1
a1397 1
sr_raid1_inquiry(struct sr_workunit *wu)
d1403 1
a1403 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_inquiry\n", DEVNAME(sd->sd_sc));
d1423 1
a1423 1
sr_raid1_read_cap(struct sr_workunit *wu)
d1429 1
a1429 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_read_cap\n", DEVNAME(sd->sd_sc));
d1440 1
a1440 1
sr_raid1_tur(struct sr_workunit *wu)
d1444 1
a1444 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_tur\n", DEVNAME(sd->sd_sc));
d1470 1
a1470 1
sr_raid1_request_sense(struct sr_workunit *wu)
d1475 1
a1475 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_request_sense\n",
d1494 1
a1494 1
sr_raid1_start_stop(struct sr_workunit *wu)
d1501 1
a1501 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_start_stop\n",
d1528 1
a1528 1
sr_raid1_sync(struct sr_workunit *wu)
d1533 1
a1533 1
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_sync\n", DEVNAME(sd->sd_sc));
d1540 1
a1540 1
			DNPRINTF(SR_D_DIS, "%s: sr_raid1_sync timeout\n",
d1731 1
a1731 1
	sr_raid1_startwu(wu);
d1742 1
a1742 1
sr_raid1_startwu(struct sr_workunit *wu)
d1817 1
a1817 1
					sr_raid1_startwu(wu->swu_collider);
d1839 1
a1839 1
sr_raid1_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
d1843 1
a1843 1
	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid1_set_chunk_state %d -> %d\n",
d1914 1
a1914 1
sr_raid1_set_vol_state(struct sr_discipline *sd)
d1920 1
a1920 1
	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid1_set_vol_state\n",
d1956 1
a1956 1
	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid1_set_vol_state %d -> %d\n",
d2769 373
@


1.56
log
@sprinkle some SMALL_KERNEL so that it can run on boot media.

ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.55 2007/05/29 18:35:00 marco Exp $ */
d134 1
a134 1
int			sr_save_metadata(struct sr_discipline *);
a958 3
		rv = sr_save_metadata(sd); /* save metadata to disk */
	} else {
		/* XXX compare scsibus & sdXX to metadata */
d961 3
d1277 3
d2096 1
a2096 1
sr_save_metadata(struct sr_discipline *sd)
d2157 1
d2543 2
@


1.55
log
@Add shutdownhook for all disciplines
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.54 2007/05/29 16:36:35 marco Exp $ */
a134 3
void			sr_refresh_sensors(void *);
int			sr_create_sensors(struct sr_discipline *);
void			sr_delete_sensors(struct sr_discipline *);
d140 7
d964 1
d970 1
d1301 1
d1303 1
d2543 1
d2627 1
d2663 1
a2663 1
#endif
d2723 1
a2723 1
#endif
@


1.54
log
@Kill stale comment
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.53 2007/05/29 16:31:38 marco Exp $ */
d99 1
d129 1
d137 1
d742 1
a742 1
	int			i, s, no_chunk, rv = EINVAL, sb = -1, vol;
a943 1
	sb = sd->sd_link.scsibus;
d960 1
a960 1
	if (sr_create_sensors(sd) != 0)
d963 5
d972 1
a972 10
	if (sb != -1)
		sc->sc_dis[sb] = NULL;

	/* XXX free scsibus */

	if (sc && cl)
		sr_unwind_chunks(sc, cl);

	if (sd)
		sr_free_discipline(sd);
d986 1
a986 1
	quad_t		size;
d1274 3
d1284 22
d2522 13
d2565 14
@


1.53
log
@Fix race in sync code.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.52 2007/05/29 08:15:32 marco Exp $ */
a1464 1
	/* assume that there isn't any more io comming in, count sync wu */
@


1.52
log
@Re-add sync.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.51 2007/05/29 02:09:45 marco Exp $ */
a47 1
#define SR_FANCY_STATS
d1458 1
a1458 1
	int			rv = 0;
d1462 2
a1463 1
	atomic_setbits_int(&sd->sd_sync, 1);
d1467 4
a1470 2
		if (tsleep(sd, PWAIT, "sr_sync", 60 * hz) == EWOULDBLOCK) {
			rv = 0;
d1474 2
a1475 1
	atomic_clearbits_int(&sd->sd_sync, 1);
@


1.51
log
@Sparc64 does not like 32 bit pointers.  Bad me.

help tedu
ok todd
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.50 2007/05/28 21:54:26 marco Exp $ */
d48 1
d323 2
d1459 1
a1459 1
	struct sr_chunk		*ch_entry;
d1463 1
a1463 5
	/* drain all io */
	SLIST_FOREACH(ch_entry, &sd->sd_vol.sv_chunk_list, src_link) {
		DNPRINTF(SR_D_DIS, "%s: %s: %s: sync\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname,
		    ch_entry->src_meta.scm_devname);
d1465 6
a1470 1
		/* quiesce io? or assume that there isn't any comming in*/
d1472 1
a1472 1
	}
d1474 1
a1474 1
	return (0);
d1755 3
d2595 1
a2595 1
		printf("%s: ios in flight: %d  collisions %llu\n",
d2597 1
a2597 1
		    sd->sd_wu_pending + sd->sd_max_wu,
@


1.50
log
@Make disk assembly smarter and add two qualifiers to it:
1) noautoassemble; when set the softraid volume will not be assembled during
   autoconf.
2) force; when set it will overwrite metadata on disk

While writing this I ran into 3 bugs that were fixed along the way
1) bcopy in sr_read_meta was copying data to the wrong pointer
2) in sr_read_meta the wrong metadata was coppied into the chunk
3) sr_free_discipline was freing a pointer that wasn't malloc'd

ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.49 2007/05/27 00:10:47 marco Exp $ */
d740 1
d917 2
a918 1
	*(u_int32_t*)sd->sd_scsi_sense.info = htole32(0);
@


1.49
log
@hack to not open cd & fd devices since they complain at boot time when there
is no media in them.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.48 2007/05/26 23:59:09 marco Exp $ */
d131 1
d136 1
d779 23
d840 1
a841 1

d843 11
d858 7
d966 4
a969 1
	if (sd) {
d971 1
a971 2
		sr_unwind_chunks(sc, cl);
	}
d1079 1
a1079 1
		memset(&b, 0, sizeof(b));
d1120 1
a1120 1
			bcopy(m, &sd->sd_meta, sizeof(sd->sd_meta));
d1125 1
d1169 2
a1170 1
		bcopy(mc, &ch_entry->src_meta, sizeof(ch_entry->src_meta));
d1244 1
a1244 1
	dev_t dev;
a1275 2
	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);
d1463 3
a1465 7
#if 0
		vn_lock(ch_entry->src_dev_vn, LK_EXCLUSIVE | LK_RETRY, curproc);
		/* XXX we want MNT_WAIT but that hangs in fdisk */
		VOP_FSYNC(ch_entry->src_dev_vn, curproc->p_ucred,
		    0 /* MNT_WAIT */, curproc);
		VOP_UNLOCK(ch_entry->src_dev_vn, 0, curproc);
#endif
d1988 63
d2087 1
@


1.48
log
@better spacing
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.47 2007/05/26 23:07:28 tedu Exp $ */
d172 3
a174 2
	if (sr_boot_assembly(sc) == 0)
		printf("\n");
d2102 5
@


1.47
log
@get size from disklabel, d_psize will remain "swap only"
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.46 2007/05/26 14:49:50 marco Exp $ */
d2137 3
a2139 2
				DNPRINTF(SR_D_META, "%s: sr_boot_assembly open "
				    "failed, partition %d\n", DEVNAME(sc), i);
d2173 2
a2174 1
			error = (*bdsw->d_close)(devr, FREAD, S_IFBLK, curproc);
d2176 2
a2177 1
				DNPRINTF(SR_D_META, "%s: sr_boot_assembly close" 				    "failed\n", DEVNAME(sc));
@


1.46
log
@Oops reintroduce check for SR_MAGIC to ensure that we care about metadata;
not doing so resulted in a partial bringup of a volume that was being created;
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.45 2007/05/26 14:30:26 marco Exp $ */
d938 1
a938 1
	u_quad_t		size;
a967 9
		/* get partition size */
		ch_entry->src_size = size = bdsw->d_psize(dev) - SR_META_SIZE -
		    SR_META_OFFSET;
		if (size <= 0) {
			printf("%s: %s partition too small\n",
			    DEVNAME(sc), name);
			goto unwind;
		}

d977 1
a977 1
			error = bdsw->d_close(dev, FWRITE, S_IFBLK, curproc);
d986 1
a986 1
			error = bdsw->d_close(dev, FWRITE, S_IFBLK, curproc);
d989 11
@


1.45
log
@Assemble disks at boot time.  This is not complete yet since it does not
order and roams volumes yet but is useful enough in most environments.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.44 2007/05/24 13:15:31 marco Exp $ */
d1056 3
d1061 1
a1061 1
			printf("%s: invalid metadatada\n", DEVNAME(sc));
@


1.44
log
@create separate function to validate metadata.
remove seeding of checksums.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.43 2007/05/23 21:27:13 marco Exp $ */
d90 1
a90 1
			    struct bioc_createraid *);
d172 2
a173 3
	/* sr_boot_assembly(sc); */

	printf("\n");
d585 1
a585 1
		rv = sr_ioctl_createraid(sc, (struct bioc_createraid *)addr);
d731 1
a731 1
sr_ioctl_createraid(struct sr_softc *sc, struct bioc_createraid *bc)
d743 2
a744 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_createraid\n", DEVNAME(sc));
d752 4
a755 1
	copyin(bc->bc_dev_list, dt, bc->bc_dev_list_len);
d2077 5
a2081 2
	dev_t			dev, devr;
	int			error, majdev, i;
d2086 1
a2087 1
	bzero(bp->b_data, sz);
d2154 11
a2164 1
			sr_validate_metadata(sc, devr, sm);
d2175 68
a2242 1
	return (0);
@


1.43
log
@Remove all vnode dependencies so that we can bootstrap softraid volumes.
Code from tedu.

Replace all kernel string magic with dev_t passed in from bioctl.
Suggestion from beck and tedu.  Help from miod.

Fix chunk crc.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.42 2007/05/12 02:50:22 marco Exp $ */
d135 2
d1020 1
a1020 1
	u_int32_t		chk, volid;
a1052 3
		if (m->ssd_magic != SR_MAGIC)
			continue;

d1054 2
a1055 13
		if (m->ssd_version != SR_META_VERSION) {
			printf("%s: %s can not read metadata version %d, "
			    "expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_version,
			    SR_META_VERSION);
			no_chunk = -1;
			goto bad;
		}
		if (m->ssd_size != sizeof(struct sr_metadata)) {
			printf("%s: %s invalid metadata size %d, "
			    "expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_size,
			    sizeof(struct sr_metadata));
a1058 11
		chk = sr_checksum(DEVNAME(sc), (u_int32_t *)m, m->ssd_size);
		/*
		 * since the checksum value is part of the checksum a good
		 * result equals 0
		 */
		if (chk != 0) {
			printf("%s: %s invalid metadata checksum 0x%x, "
			    "expected 0x%x\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_checksum, chk);
			goto bad;
		}
a1059 17
		/* validate volume metadata */
		if (m->ssd_vd_ver != SR_VOL_VERSION) {
			printf("%s: %s can not read volume metadata version "
			    "%d, expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_vd_ver,
			    SR_VOL_VERSION);
			no_chunk = -1;
			goto bad;
		}
		if (m->ssd_vd_size != sizeof(struct sr_vol_meta)) {
			printf("%s: %s invalid volume metadata size %d, "
			    "expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_vd_size,
			    sizeof(struct sr_vol_meta));
			no_chunk = -1;
			goto bad;
		}
a1060 26
		chk = sr_checksum(DEVNAME(sc), (u_int32_t *)mv, m->ssd_vd_size);
		if (chk != m->ssd_vd_chk) {
			printf("%s: %s invalid volume metadata checksum 0x%x, "
			    "expected 0x%x\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_vd_chk, chk);
			no_chunk = -1;
			goto bad;
		}

		/* validate chunk metadata */
		if (m->ssd_chunk_ver != SR_CHUNK_VERSION) {
			printf("%s: %s can not read chunk metadata version "
			    "%d, expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_chunk_ver,
			    SR_CHUNK_VERSION);
			no_chunk = -1;
			goto bad;
		}
		if (m->ssd_chunk_size != sizeof(struct sr_chunk_meta)) {
			printf("%s: %s invalid chunk metadata size %d, "
			    "expected %d\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_chunk_size,
			    sizeof(struct sr_chunk_meta));
			no_chunk = -1;
			goto bad;
		}
a1061 11
		/* checksum is calculated over ALL chunks */
		chk = SR_META_CRCSEED;
		chk ^= sr_checksum(DEVNAME(sc), (u_int32_t *)(mc),
		    m->ssd_chunk_size * m->ssd_chunk_no);
		if (chk != m->ssd_chunk_chk) {
			printf("%s: %s invalid chunk metadata checksum 0x%x, "
			    "expected 0x%x\n", DEVNAME(sc),
			    ch_entry->src_devname, m->ssd_chunk_chk, chk);
			no_chunk = -1;
			goto bad;
		}
d1901 1
a1901 1
	u_int32_t		chk = SR_META_CRCSEED;
d2081 1
d2119 1
a2119 3
			if (label.d_partitions[i].p_fstype != FS_RAID) {
				error = (*bdsw->d_close)(dev, FREAD, S_IFBLK,
				    curproc);
a2120 1
			}
d2148 1
a2148 1
			sr_print_metadata(sm);
d2163 124
d2412 1
d2417 1
@


1.42
log
@Add initial bits for assembly at boot time.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.41 2007/05/08 23:54:37 marco Exp $ */
a30 2
#include <sys/vnode.h>
#include <sys/namei.h>
a43 2
#include <miscfs/specfs/specdev.h>

a90 2
int			sr_parse_chunks(struct sr_softc *, char *,
			    struct sr_chunk_head *);
d92 1
a92 1
			    struct sr_chunk_head *);
d732 1
a732 1
	char			*devl;
a734 1
	size_t			bytes = 0;
d745 6
a750 4
	devl = malloc(bc->bc_dev_list_len + 1, M_DEVBUF, M_WAITOK);
	memset(devl, 0, bc->bc_dev_list_len + 1);
	copyinstr(bc->bc_dev_list, devl, bc->bc_dev_list_len, &bytes);
	DNPRINTF(SR_D_IOCTL, "%s\n", devl);
d755 2
a757 2

	/* check if we have valid user input */
d759 1
a759 4
	if ((no_chunk = sr_parse_chunks(sc, devl, cl)) == -1)
		goto unwind;

	if (sr_open_chunks(sc, cl))
d769 1
a769 2
	memset(sd->sd_vol.sv_chunks, 0,
	    sizeof(struct sr_chunk *) * no_chunk);
d925 2
a926 1
sr_parse_chunks(struct sr_softc *sc, char *lst, struct sr_chunk_head *cl)
d928 5
a932 69
	struct sr_chunk		*ch_entry, *ch_next, *ch_prev;
	char			*s, *e;
	u_int32_t		sz = 0;
	int			no_chunk = 0;

	DNPRINTF(SR_D_IOCTL, "%s: sr_parse_chunks\n", DEVNAME(sc));

	if (!lst)
		goto bad;

	s = e = lst;
	ch_prev = NULL;
	/* make sure we have a valid device list like /dev/sdNa,/dev/sdNNa */
	while (*e != '\0') {
		if (*e == ',')
			s = e + 1;
		else if (*(e + 1) == '\0' || *(e + 1) == ',') {
			sz = e - s + 1;
			/* got one */
			ch_entry = malloc(sizeof(struct sr_chunk),
			    M_DEVBUF, M_WAITOK);
			memset(ch_entry, 0, sizeof(struct sr_chunk));

			if (sz  + 1 > sizeof(ch_entry->src_devname))
				goto unwind;

			strlcpy(ch_entry->src_devname, s, sz + 1);

			/* keep disks in user supplied order */
			if (ch_prev)
				SLIST_INSERT_AFTER(ch_prev, ch_entry, src_link);
			else
				SLIST_INSERT_HEAD(cl, ch_entry, src_link);
			ch_prev = ch_entry;
			no_chunk++;
		}
		e++;
	}

	/* check for dups */
	SLIST_FOREACH(ch_entry, cl, src_link) {
		SLIST_FOREACH(ch_next, cl, src_link) {
			if (ch_next == ch_entry)
				continue;

			if (!strcmp(ch_next->src_devname,
			    ch_entry->src_devname))
				goto unwind;
		}
	}

	return (no_chunk);
unwind:
	sr_unwind_chunks(sc, cl);
bad:
	printf("%s: invalid device list %s\n", DEVNAME(sc), lst);

	return (-1);
}

int
sr_open_chunks(struct sr_softc *sc, struct sr_chunk_head *cl)
{
	struct sr_chunk		*ch_entry;
	struct nameidata	nd;
	struct vattr		va;
	struct disklabel	*label;
	int			error;
	char			*name, ss;
d934 1
d936 1
a936 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_open_chunks\n", DEVNAME(sc));
d939 9
a947 4
	SLIST_FOREACH(ch_entry, cl, src_link) {
		name = ch_entry->src_devname;
		ch_entry->src_dev_vn = NULL;
		NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, name, curproc);
d949 5
a953 8
		/* open disk */
		error = vn_open(&nd, FREAD | FWRITE, 0);
		if (error) {
			printf("%s: could not open %s error %d\n", DEVNAME(sc),
			    name, error);
			goto unwind; /* open failed */
		}
		ch_entry->src_dev_vn = nd.ni_vp;
d955 3
a957 5
		/* partition already in use? */
		if (nd.ni_vp->v_usecount > 1) {
			printf("%s: %s in use\n", DEVNAME(sc), name);
			goto unlock;
		}
d959 3
a961 7
		/* get attributes */
		error = VOP_GETATTR(nd.ni_vp, &va, curproc->p_ucred, curproc);
		if (error) {
			printf("%s: %s can't retrieve attributes\n",
			    DEVNAME(sc), name);
			goto unlock;
		}
d963 5
a967 3
		/* is partition VBLK? */
		if (va.va_type != VBLK) {
			printf("%s: %s not of VBLK type\n",
d969 1
a969 1
			goto unlock;
d972 2
a973 6
		/* make sure we are not a raw partition */
		if (DISKPART(nd.ni_vp->v_rdev) == RAW_PART) {
			printf("%s: %s can not use raw partitions\n",
			    DEVNAME(sc), name);
			goto unlock;
		}
d976 2
a977 3
		label = &ch_entry->src_label;
		error = VOP_IOCTL(nd.ni_vp, DIOCGDINFO, (caddr_t)label,
		    FREAD, curproc->p_ucred, curproc);
d979 1
a979 11
			printf("%s: %s could not read disklabel err %d\n",
			    DEVNAME(sc), name, error);
			goto unlock; /* disklabel failed */
		}

		/* get partition size */
		ss = name[strlen(name) - 1];
		size = label->d_partitions[ss - 'a'].p_size - SR_META_SIZE -
		    SR_META_OFFSET;
		if (size <= 0) {
			printf("%s: %s partition too small\n",
d981 2
a982 1
			goto unlock;
d986 1
a986 1
		if (label->d_partitions[ss - 'a'].p_fstype != FS_RAID) {
d989 3
a991 2
			    label->d_partitions[ss - 'a'].p_fstype);
			goto unlock;
d994 1
a994 1
		ch_entry->src_dev_mm = nd.ni_vp->v_rdev; /* major/minor */
d997 1
a997 4
		    name, label->d_partitions[ss - 'a'].p_size);

		/* unlock the vnode */
		VOP_UNLOCK(ch_entry->src_dev_vn, 0, curproc);
a1000 2
unlock:
	VOP_UNLOCK(ch_entry->src_dev_vn, 0, curproc);
d1002 1
a1002 3
	sr_unwind_chunks(sc, cl);
	printf("%s: invalid device: %s\n", DEVNAME(sc), name);

d1037 1
a1037 1
		b.b_vp = ch_entry->src_dev_vn;
d1040 1
a1040 2
		b.b_vp->v_numoutput++;
		VOP_STRATEGY(&b);
d1129 2
a1130 1
		chk = sr_checksum(DEVNAME(sc), (u_int32_t *)(mc),
a1215 1
	struct disklabel	*label;
d1218 2
a1219 2
	char			*name, ss;
	u_quad_t		size, max_chunk_sz = 0, min_chunk_sz;
a1226 1
		label = &ch_entry->src_label;
d1228 1
a1228 4
		ss = name[strlen(name) - 1];
		size = label->d_partitions[ss - 'a'].p_size - SR_META_SIZE -
		    SR_META_OFFSET;
		ch_entry->src_meta.scm_size = size;
d1248 1
a1248 1
			ch_entry->src_meta.scm_coerced_size = min_chunk_sz;
d1265 1
d1269 3
d1276 5
a1280 4
		if (ch_entry->src_dev_vn != NULL) {
			vn_close(ch_entry->src_dev_vn, FREAD | FWRITE,
			    curproc->p_ucred, curproc);
		}
d1486 1
d1492 1
d1623 1
a1623 1
		ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[x]->src_dev_vn;
d1699 1
a1699 2
		ccb->ccb_buf.b_vp->v_numoutput++;
		VOP_STRATEGY(&ccb->ccb_buf);
d1978 1
a1978 1
	u_int32_t		chk = 0xdeadbeef;
d2050 1
a2050 1
		sm->ssd_ondisk = 1;
d2114 1
a2114 1
		b.b_vp = src->src_dev_vn;
d2117 1
a2117 2
		b.b_vp->v_numoutput++;
		VOP_STRATEGY(&b);
d2168 1
a2168 1
		error = (*bdsw->d_open)(dev, FREAD, S_IFCHR, curproc);
d2181 1
a2181 1
			error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
d2186 1
a2186 1
		error = (*bdsw->d_close)(dev, FREAD, S_IFCHR, curproc);
d2196 1
a2196 1
				error = (*bdsw->d_close)(dev, FREAD, S_IFCHR,
d2203 1
a2203 1
			error = (*bdsw->d_open)(devr, FREAD, S_IFCHR, curproc);
d2221 1
a2221 1
				error = (*bdsw->d_close)(devr, 0, S_IFCHR,
a2226 1
			/* printf("%s meta:\n", dv->dv_xname); */
d2230 1
a2230 1
			error = (*bdsw->d_close)(devr, FREAD, S_IFCHR, curproc);
@


1.41
log
@Assemble disk from user supplied metadata.
Verify all metada to make sure it is correct; this includes sorting the chunks
Add 2 new functions for printing uuid and metadata.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.40 2007/05/02 03:51:26 marco Exp $ */
d37 2
d140 1
d176 2
d2213 1
a2213 1
		/* make sure in memor copy is clean */
d2234 99
@


1.40
log
@Make meta_read use the metadata memory that is provided in the discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.39 2007/05/02 03:19:03 marco Exp $ */
d133 1
d139 6
d769 6
d787 5
d816 1
a816 3
		/* we got metadata, validate it */
		printf("%s: METADATA BRINGUP IS NOT WORKING YET; "
		    "TREATING AS VOLUME CREATION\n",
d818 1
a824 9
	/* we have a valid list now create an array index into it */
	sd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *) * no_chunk,
	    M_DEVBUF, M_WAITOK);
	memset(sd->sd_vol.sv_chunks, 0,
	    sizeof(struct sr_chunk *) * no_chunk);
	i = 0;
	SLIST_FOREACH(ch_entry, cl, src_link)
		sd->sd_vol.sv_chunks[i++] = ch_entry;

d1099 1
a1099 1
	struct sr_metadata	*sm = sd->sd_meta;
d1102 2
a1103 1
	int			mc = 0;
d1105 2
d1110 3
d1121 1
a1121 1
		b.b_data = (void *)sm;
d1140 1
a1140 1
		if (sm->ssd_magic != SR_MAGIC)
d1143 106
a1249 1
		mc++;
d1251 36
d1290 1
a1290 1
	    DEVNAME(sc), mc);
d1292 3
d1296 2
a1297 1
	return (mc);
d1353 1
d2065 1
a2065 1
	u_int32_t		chk = 0;
d2082 1
a2082 1
	int i;
d2088 13
d2170 1
a2170 54
#ifdef SR_DEBUG
	/* metadata */
	DNPRINTF(SR_D_META, "\tmeta magic 0x%llx\n", sm->ssd_magic);
	DNPRINTF(SR_D_META, "\tmeta version %d\n", sm->ssd_version);
	DNPRINTF(SR_D_META, "\tmeta checksum 0x%x\n", sm->ssd_checksum);
	DNPRINTF(SR_D_META, "\tmeta size %d\n", sm->ssd_size);
	DNPRINTF(SR_D_META, "\tmeta on disk version %u\n", sm->ssd_ondisk);
	DNPRINTF(SR_D_META, "\tmeta uuid ");
	for (i = 0; i < SR_UUID_MAX; i++)
		DNPRINTF(SR_D_META, "%x%s", sm->ssd_uuid.sui_id[i],
		    i < SR_UUID_MAX - 1 ? ":" : "\n");
	DNPRINTF(SR_D_META, "\tvd version %d\n", sm->ssd_vd_ver);
	DNPRINTF(SR_D_META, "\tvd size %lu\n", sm->ssd_vd_size);
	DNPRINTF(SR_D_META, "\tvd checksum 0x%x\n", sm->ssd_vd_chk);
	DNPRINTF(SR_D_META, "\tchunk version %d\n", sm->ssd_chunk_ver);
	DNPRINTF(SR_D_META, "\tchunks %d\n", sm->ssd_chunk_no);
	DNPRINTF(SR_D_META, "\tchunk size %u\n", sm->ssd_chunk_size);
	DNPRINTF(SR_D_META, "\tchunk checksum 0x%x\n", sm->ssd_chunk_chk);

	DNPRINTF(SR_D_META, "\t\tvol id %d\n", im_sv->svm_volid);
	DNPRINTF(SR_D_META, "\t\tvol status %d\n", im_sv->svm_status);
	DNPRINTF(SR_D_META, "\t\tvol flags 0x%x\n", im_sv->svm_flags);
	DNPRINTF(SR_D_META, "\t\tvol level %d\n", im_sv->svm_level);
	DNPRINTF(SR_D_META, "\t\tvol size %llu\n", im_sv->svm_size);
	DNPRINTF(SR_D_META, "\t\tvol name %s\n", im_sv->svm_devname);
	DNPRINTF(SR_D_META, "\t\tvol vendor %s\n", im_sv->svm_vendor);
	DNPRINTF(SR_D_META, "\t\tvol prod %s\n", im_sv->svm_product);
	DNPRINTF(SR_D_META, "\t\tvol rev %s\n", im_sv->svm_revision);
	DNPRINTF(SR_D_META, "\t\tvol no chunks %d\n", im_sv->svm_no_chunk);
	DNPRINTF(SR_D_META, "\t\tvol uuid ");
	for (i = 0; i < SR_UUID_MAX; i++)
		DNPRINTF(SR_D_META, "%x%s", im_sv->svm_uuid.sui_id[i],
		    i < SR_UUID_MAX - 1 ? ":" : "\n");

	for (ch = 0; ch < im_sv->svm_no_chunk; ch++) {
		DNPRINTF(SR_D_META, "\t\t\tchunk vol id %d\n",
		    im_sc[ch].scm_volid);
		DNPRINTF(SR_D_META, "\t\t\tchunk id %d\n",
		    im_sc[ch].scm_chunk_id);
		DNPRINTF(SR_D_META, "\t\t\tchunk status %d\n",
		    im_sc[ch].scm_status);
		DNPRINTF(SR_D_META, "\t\t\tchunk name %s\n",
		    im_sc[ch].scm_devname);
		DNPRINTF(SR_D_META, "\t\t\tchunk size %llu\n",
		    im_sc[ch].scm_size);
		DNPRINTF(SR_D_META, "\t\t\tchunk coerced size %llu\n",
		    im_sc[ch].scm_coerced_size);
		DNPRINTF(SR_D_META, "\t\t\tchunk uuid ");
		for (i = 0; i < SR_UUID_MAX; i++)
			DNPRINTF(SR_D_META, "%x%s",
			    im_sc[ch].scm_uuid.sui_id[i],
			    i < SR_UUID_MAX - 1 ? ":" : "\n");
	}
#endif
d2333 58
@


1.39
log
@Add a function to free all discipline members and the discipline itself.
Move allocation of "in memory copy" of metadata into the new function.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.38 2007/05/01 22:53:51 marco Exp $ */
d97 1
a97 2
int			sr_read_meta(struct sr_softc *,
			    struct sr_chunk_head *);
d762 1
a762 1
	if ((no_meta = sr_read_meta(sc, cl)) == 0) {
d1087 1
a1087 1
sr_read_meta(struct sr_softc *sc, struct sr_chunk_head *cl)
d1089 3
a1092 1
	struct sr_metadata	*sm;
a1098 3
	sm = malloc(sz, M_DEVBUF, M_WAITOK);
	bzero(sm, sz);

d1118 1
a1118 1
		/* mark chunk offline and restart metadata write */
a1131 1
		bcopy(sm, &ch_entry->src_meta, sizeof(ch_entry->src_meta));
a1132 2

	free(sm, M_DEVBUF);
@


1.38
log
@Refactor metadata code; this is the first step to be able to bringup
devices at boot time.

Reset the metadata versions to 1 until this solidifies we wont change
these.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.37 2007/04/30 01:58:36 todd Exp $ */
d103 1
d759 4
d915 1
a915 5
		if (sd->sd_free_resources)
			sd->sd_free_resources(sd);
		if (sd->sd_vol.sv_chunks)
			free(sd->sd_vol.sv_chunks, M_DEVBUF);
		free(sd, M_DEVBUF);
a916 1

d1220 15
a1249 4
	/* -2 because that includes mbr and partition table */
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK);
	bzero(sd->sd_meta, SR_META_SIZE  * 512);

d1268 2
a1269 1
	free(sd->sd_meta, M_DEVBUF);
@


1.37
log
@';;' doesnt work on older gcc..
i.e. my sparc and vax and m68k couldn't build this
problem found by me, fix by pedro
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.36 2007/04/23 22:48:40 marco Exp $ */
d95 6
a136 1
int			sr_meta_exists(struct sr_discipline *);
d728 1
d730 1
a730 1
	u_quad_t		vol_size, max_chunk_sz = 0, min_chunk_sz;
d755 49
d810 1
a810 1
	SLIST_FOREACH(ch_entry, cl, src_link) {
a811 16
		/* while looping get the largest chunk size */
		if (ch_entry->src_meta.scm_size > max_chunk_sz)
			max_chunk_sz = ch_entry->src_meta.scm_size;
	}
	min_chunk_sz = max_chunk_sz;
	SLIST_FOREACH(ch_entry, cl, src_link) {
		if (ch_entry->src_meta.scm_size < min_chunk_sz)
			min_chunk_sz = ch_entry->src_meta.scm_size;
	}
	SLIST_FOREACH(ch_entry, cl, src_link)
			ch_entry->src_meta.scm_coerced_size = min_chunk_sz;
	/* whine if chunks are not the same size */
	if (min_chunk_sz != max_chunk_sz)
		printf("%s: chunk sizes are not equal; up to %llu blocks "
		    "wasted per chunk\n",
		    DEVNAME(sc), max_chunk_sz - min_chunk_sz);
a814 3
		if (no_chunk < 2)
			goto unwind;

a818 2
		strlcpy(sd->sd_name, "RAID 1", sizeof(sd->sd_name));
		vol_size = min_chunk_sz;
d820 1
a820 1
		/* setup pointers */
a822 1

a836 16
	/* fill out all volume meta data */
	DNPRINTF(SR_D_IOCTL, "%s: sr_ioctl_createraid: max_chunk_sz: "
	    "%llu min_chunk_sz: %llu vol_size: %llu\n", DEVNAME(sc),
	    max_chunk_sz, min_chunk_sz, vol_size);
	sd->sd_vol.sv_meta.svm_no_chunk = no_chunk;
	sd->sd_vol.sv_meta.svm_size = vol_size;
	sd->sd_vol.sv_meta.svm_status = BIOC_SVONLINE;
	sd->sd_vol.sv_meta.svm_level = bc->bc_level;
	strlcpy(sd->sd_vol.sv_meta.svm_vendor, "OPENBSD",
	    sizeof(sd->sd_vol.sv_meta.svm_vendor));
	snprintf(sd->sd_vol.sv_meta.svm_product,
	    sizeof(sd->sd_vol.sv_meta.svm_product), "SR %s", sd->sd_name);
	snprintf(sd->sd_vol.sv_meta.svm_revision,
	    sizeof(sd->sd_vol.sv_meta.svm_revision), "%03d",
	    SR_META_VERSION);

d840 1
a840 1
	/* metadata SHALL be fully filled in at this point */
a875 4
	/* fill out volume metadata */

	strlcpy(sd->sd_vol.sv_meta.svm_devname, dev->dv_xname,
	    sizeof(sd->sd_vol.sv_meta.svm_devname));
d880 1
a880 1
	sb = sd->sd_link.scsibus; /* XXX remove this */
a883 1
	sd->sd_vol.sv_meta.svm_volid = vol;
d885 7
a891 6
	if (sr_meta_exists(sd) == no_chunk) {
		printf("%s: chunks already contain metadata, not saving "
		    "again\n",
		    DEVNAME(sc));
		rv = 0;
	} else
d893 3
a924 5
	struct nameidata	nd;
	struct disklabel	label;
	struct vattr		va;
	int			error;
	char			ss, *name;
d927 1
a927 2
	int			i;
	char			dummy = 0;
d931 1
a931 2
	if (!lst) {
		lst = &dummy;
a932 1
	}
d947 1
a947 1
			if (sz  + 1 > sizeof(ch_entry->src_meta.scm_devname))
d950 1
a950 1
			strlcpy(ch_entry->src_meta.scm_devname, s, sz + 1);
d958 1
d969 2
a970 2
			if (!strcmp(ch_next->src_meta.scm_devname,
			    ch_entry->src_meta.scm_devname))
d975 22
a997 1
	i = 0;
d999 1
a999 2
		/* printf("name: %s\n", ch_entry->src_meta.scm_devname); */
		name = ch_entry->src_meta.scm_devname;
d1041 2
a1042 1
		error = VOP_IOCTL(nd.ni_vp, DIOCGDINFO, (caddr_t)&label,
d1052 1
a1052 2
		ch_entry->src_meta.scm_size =
		    label.d_partitions[ss - 'a'].p_size - SR_META_SIZE -
d1054 2
a1055 2
		if (ch_entry->src_meta.scm_size <= 0) {
			printf("%s: %s partition size = 0\n",
d1061 1
a1061 1
		if (label.d_partitions[ss - 'a'].p_fstype != FS_RAID) {
d1064 1
a1064 1
			    label.d_partitions[ss - 'a'].p_fstype);
a1067 3
		/* XXX check for stale metadata */

		ch_entry->src_meta.scm_chunk_id = i++;
d1071 1
a1071 4
		    name, ch_entry->src_meta.scm_size);

		/* mark chunk online */
		ch_entry->src_meta.scm_status = BIOC_SDONLINE;
d1077 1
a1077 2
	return (i);

d1082 59
a1140 2
bad:
	printf("%s: invalid device list %s\n", DEVNAME(sc), lst);
d1142 2
a1143 1
	return (-1);
d1146 53
a1921 62
sr_meta_exists(struct sr_discipline *sd)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_metadata	*sm;
	struct sr_chunk		*src;
	struct buf		b;
	int			i, mc = 0;
	size_t			sz = 512;

	DNPRINTF(SR_D_META, "%s: sr_meta_exists %s\n",
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname);

	sm = malloc(sz, M_DEVBUF, M_WAITOK);
	bzero(sm, sz);

	for (i = 0; i < sd->sd_vol.sv_meta.svm_no_chunk; i++) {
		memset(&b, 0, sizeof(b));

		src = sd->sd_vol.sv_chunks[i];

		/* skip disks that are offline */
		if (src->src_meta.scm_status == BIOC_SDOFFLINE)
			continue;

		b.b_flags = B_READ;
		b.b_blkno = SR_META_OFFSET;
		b.b_bcount = sz;
		b.b_bufsize = sz;
		b.b_resid = sz;
		b.b_data = (void *)sm;
		b.b_error = 0;
		b.b_proc = curproc;
		b.b_dev = src->src_dev_mm;
		b.b_vp = src->src_dev_vn;
		b.b_iodone = NULL;
		LIST_INIT(&b.b_dep);
		b.b_vp->v_numoutput++;
		VOP_STRATEGY(&b);
		biowait(&b);

		/* XXX do something smart here */
		/* mark chunk offline and restart metadata write */
		if (b.b_flags & B_ERROR) {
			printf("%s: %s i/o error on block %d while writing "
			    "metadata %d\n", DEVNAME(sc),
			    src->src_meta.scm_devname, b.b_blkno, b.b_error);
			continue;
		}

		if (sm->ssd_magic == SR_MAGIC)
			mc++;
	}

	free(sm, M_DEVBUF);

	DNPRINTF(SR_D_META, "%s: sr_meta_exists %d\n", DEVNAME(sc), mc);

	/* return nr of chunks that contain metadata */
	return (mc);
}

int
d1958 4
a1961 1
		sr_get_uuid(&sm->ssd_uuid);
d1971 1
a1971 4
		for (i = 0; i < sd->sd_vol.sv_meta.svm_no_chunk; i++) {
			bcopy(&sm->ssd_uuid,
			    &sd->sd_vol.sv_chunks[i]->src_meta.scm_uuid,
			    sizeof(struct sr_uuid));
d1974 1
a1974 1
		}
d2054 11
d2080 5
@


1.36
log
@Add initial test for existing metadata on chunks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.35 2007/04/23 20:11:31 marco Exp $ */
d1855 1
a1855 1
	struct sr_vol_meta	*sv = &sd->sd_vol.sv_meta, *im_sv;;
@


1.35
log
@Add interesting runtime stats.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.34 2007/04/23 17:06:10 marco Exp $ */
d131 1
d873 7
a879 1
	rv = sr_save_metadata(sd); /* save metadata to disk */
d1789 62
d1876 1
a1876 1
		printf("%s: too much metadata.  Metadata NOT written to disk\n",
a1894 1

@


1.34
log
@Keep track of coerced chunk sizes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.33 2007/04/22 13:02:56 marco Exp $ */
d49 2
d255 1
d261 1
d286 1
d371 2
d383 1
d389 2
d1450 1
d2016 24
d2041 10
d2053 1
@


1.33
log
@Calculate metadata checksums.
Add chunks to debug prints.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.32 2007/04/22 04:05:36 marco Exp $ */
d57 1
a57 1
		    | SR_D_META
d755 2
d759 2
a760 2
		printf("%s: chunk sizes are not equal.  Wasted blocks per "
		    "chunk: %llu\n",
a773 2

		/* XXX coerce all chunks here */
@


1.32
log
@Add more debug output for metadata.
Spacing as well.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.31 2007/04/22 00:41:31 marco Exp $ */
d57 1
a57 1
		    /* | SR_D_META */
d1779 1
a1779 1
	int			i, rv = 1;
d1835 5
a1872 1
	//struct sr_uuid 		svm_uuid;	/* volume unique identifier */
d1874 19
@


1.31
log
@Don't use SBLOCK_UFS1.  Don't call it SKIP either.

Pompted by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.30 2007/04/22 00:06:09 marco Exp $ */
d1832 2
d1837 6
a1842 6
	DNPRINTF(SR_D_META, "\tmagic 0x%llx\n", sm->ssd_magic);
	DNPRINTF(SR_D_META, "\tversion %d\n", sm->ssd_version);
	DNPRINTF(SR_D_META, "\tchecksum 0x%x\n", sm->ssd_checksum);
	DNPRINTF(SR_D_META, "\tsize %d\n", sm->ssd_size);
	DNPRINTF(SR_D_META, "\ton disk version %u\n", sm->ssd_ondisk);
	DNPRINTF(SR_D_META, "\tuuid ");
d1846 24
@


1.30
log
@Skip past SBLOCK_UFS1 to make sure that metadata does not destroy anything
filesystem related.

pointed out by deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.29 2007/04/21 23:50:47 marco Exp $ */
d1007 1
a1007 1
		    SR_FFS_SKIP;
d1308 1
a1308 1
	blk += SR_META_SIZE + SR_FFS_SKIP;
d1856 1
a1856 1
		b.b_blkno = SR_FFS_SKIP; /* skip past mbr and partition table */
@


1.29
log
@Make sure we don't write too much metadata.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.28 2007/04/21 23:39:18 marco Exp $ */
d1006 2
a1007 1
		    label.d_partitions[ss - 'a'].p_size - SR_META_SIZE;
d1086 2
a1087 2
	sd->sd_meta = malloc((SR_META_SIZE - 2) * 512 , M_DEVBUF, M_WAITOK);
	bzero(sd->sd_meta, (SR_META_SIZE - 2) * 512);
d1308 1
a1308 1
	blk += SR_META_SIZE;
d1780 1
a1780 1
	size_t			sz = (SR_META_SIZE - 2) * 512;
d1856 1
a1856 1
		b.b_blkno = 2; /* skip past mbr and partition table */
@


1.28
log
@Remove big endian in metadata; prompted by deraadt.
Align metadata to 64 bit; from deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.27 2007/04/21 23:22:42 marco Exp $ */
d1792 8
d1809 1
a1809 1
		bcopy(sv, im_sv, sizeof(struct sr_metadata));
a1816 1
		/* XXX do some sanity to prevent too many disks */
d1871 1
a1871 1
		/* marck chunk offline and restart metadata write */
@


1.27
log
@Account for mbr and partition table when writing meta data.

Error report by Johan Mson Lindman <tybollt@@solace.miun.se>
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.26 2007/04/21 23:05:19 marco Exp $ */
a1795 4
		if (_BYTE_ORDER == _LITTLE_ENDIAN)
			sm->ssd_big_endian = 0;
		else
			sm->ssd_big_endian = 1;
a1828 1
	DNPRINTF(SR_D_META, "\tbig endian %d\n", sm->ssd_big_endian);
@


1.26
log
@Add volumes to sensors.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.25 2007/04/19 22:12:41 marco Exp $ */
d1084 3
a1086 2
	sd->sd_meta = malloc(SR_META_SIZE * 512 , M_DEVBUF, M_WAITOK);
	bzero(sd->sd_meta, SR_META_SIZE * 512);
d1779 1
a1779 1
	size_t			sz = SR_META_SIZE * 512;
@


1.25
log
@Save volume and chunk metadata as well.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.24 2007/04/19 02:44:29 marco Exp $ */
a34 1

d36 1
d127 2
d864 4
d1630 3
d1883 71
@


1.24
log
@Add initial metadata write function and hook it up.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.23 2007/04/19 02:36:56 marco Exp $ */
d709 1
a709 1
	int			i, s, no_chunk, rv = EINVAL, sb = -1;
d846 2
d854 5
a858 1
	sb = sd->sd_link.scsibus;
a1080 1

d1764 2
d1774 8
d1795 3
d1801 1
d1803 8
d1816 3
d1837 5
d1859 1
@


1.23
log
@Silly tedu, partitions are measured in blocks not in bytes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.22 2007/04/17 23:18:23 marco Exp $ */
d123 5
d854 2
a855 1
	rv = 0;
d994 1
a994 1
		    label.d_partitions[ss - 'a'].p_size - SR_META_FUDGE;
d1072 4
d1094 2
d1295 1
a1295 1
	blk += SR_META_FUDGE;
d1333 1
a1333 1
				sd->sd_vol.sv_meta.svm_no_chunk;
d1726 112
@


1.22
log
@Whenever there are mutliple outstanding IOs a chunk can transtion multiple
times to the same state.  Ignore that.

Tested by thib@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.21 2007/04/17 05:59:20 marco Exp $ */
d988 1
a988 1
		    label.d_partitions[ss - 'a'].p_size - (SR_META_FUDGE * 512);
@


1.21
log
@Shuffle ccb contents and clean up a loop
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.20 2007/04/14 21:28:08 tedu Exp $ */
d1538 4
d1596 1
@


1.20
log
@shave some blocks off each chunk to make sure disklabel doesn't get eaten
this can also be used for softraid metadata
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.19 2007/04/14 15:50:28 marco Exp $ */
d1287 1
d1299 17
d1356 1
a1356 1
				ios--;
a1365 8
		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_wu = wu;
d1368 1
a1370 8
		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
		} else {
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
		}

a1397 1
	wu->swu_io_count = ios;
@


1.19
log
@Add degraded raid 1 io path code
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.18 2007/04/12 03:31:54 marco Exp $ */
d764 1
a764 1
		vol_size = min_chunk_sz - (1 + 1 + no_chunk + SR_META_FUDGE);
d988 2
a989 2
		    label.d_partitions[ss - 'a'].p_size;
		if (ch_entry->src_meta.scm_size == 0) {
d1282 2
@


1.18
log
@Add failure statistics per workunit.
Remove BIOC_SFAILED; we'll only use BIOC_SOFFLINE.
Call state change in interrupt handler when a chunk fails.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.17 2007/04/11 22:58:33 marco Exp $ */
d1249 2
a1250 1
	int			rv = 1, ios, x, i, s;
d1256 5
d1296 27
a1322 3
		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
d1324 20
a1343 2
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
d1345 1
a1345 1

d1353 1
a1353 15

		wu->swu_io_count = ios;
		if (xs->flags & SCSI_DATA_IN) {
			/* interleave reads */
			x = sd->mds.mdd_raid1.sr1_counter %
			    sd->sd_vol.sv_meta.svm_no_chunk;
			sd->mds.mdd_raid1.sr1_counter++;
			ccb->ccb_buf.b_flags |= B_READ;
		} else {
			/* writes go on all disks */
			x = i;
			ccb->ccb_buf.b_flags |= B_WRITE;
		}

		ccb->ccb_target = x;
a1355 1

d1358 7
a1364 1
		ccb->ccb_wu = wu;
d1393 1
d1420 1
a1420 1
	rv = 0;
d1422 2
a1423 2
	/* unwind the whole wu */
	return (rv);
d1493 1
a1493 1
				/* io on pendq, remove */
@


1.17
log
@Remove stale comment.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.16 2007/04/11 22:52:33 marco Exp $ */
d272 1
d345 2
d1319 1
d1394 1
a1394 1
	/* move io to pending queue */
d1411 1
a1411 1
	int			s, pend = 0;
d1425 10
a1434 1
		wu->swu_state = SR_WU_FAILED;
d1436 1
a1437 1
	wu->swu_ios_complete++;
d1440 1
d1442 1
a1442 2
		/* do something smarter here instead of failing the whole WU */
		if (wu->swu_state == SR_WU_FAILED)
d1450 1
a1450 1

d1470 2
a1471 1
			printf("wu: %p not on pending queue\n", wu);
a1498 2
		case BIOC_SDFAILED:
			break;
d1513 2
a1514 2
	case BIOC_SDFAILED:
		if (new_state == BIOC_SDREBUILD) {
a1519 11
	case BIOC_SDSCRUB:
		switch (new_state) {
		case BIOC_SDONLINE:
			break;
		case BIOC_SDFAILED:
			break;
		default:
			goto die;
		}
		break;

d1521 3
a1523 6
		switch (new_state) {
		case BIOC_SDONLINE:
			break;
		case BIOC_SDFAILED:
			break;
		default:
a1524 1
		}
@


1.16
log
@Fix thinko where vol was used instead of i (scsibus).
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.15 2007/04/11 22:05:09 marco Exp $ */
d1392 1
a1392 1
	/* XXX create function */
@


1.15
log
@Add infrastructure to run with multiple openings.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.14 2007/03/31 12:57:08 marco Exp $ */
d627 1
a627 1
		if (id >= sc->sc_dis[vol]->sd_vol.sv_meta.svm_no_chunk)
d630 1
a630 1
		src = sc->sc_dis[vol]->sd_vol.sv_chunks[id];
@


1.14
log
@Move offline state up in priority over degraded.
Various cleanups in state functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.13 2007/03/31 12:31:27 marco Exp $ */
d59 1
a59 1
		    | SR_D_STATE
d121 1
d297 2
d320 4
d333 2
d345 9
a353 1
	wu->swu_ios = NULL;
d803 1
a803 1
	sd->sd_link.openings = 1; /* sc->sc_max_cmds; */
d1244 1
d1246 2
a1247 2
	int			rv = 1, ios, x, i;
	daddr_t			blk;
d1274 3
d1323 2
d1331 1
d1348 20
d1370 6
d1378 3
d1382 15
a1396 1
	return (rv);
d1403 1
a1403 1
	struct sr_workunit	*wu = ccb->ccb_wu;
d1407 1
a1407 1
	int			s;
d1416 2
d1419 1
a1419 1
		printf("%s: i/o error on block %d\n", DEVNAME(sc),
a1423 2
	sr_put_ccb(ccb);

d1437 24
a1460 1
		s = splbio();
a1461 2
		splx(s);
		sr_put_wu(wu);
d1463 2
@


1.13
log
@Fix bio disk lookup and make it more paranoia with provided parameters.
Clean up a little while there.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.12 2007/03/31 12:07:50 marco Exp $ */
d610 1
a610 1
		if (id > sc->sc_dis[vol]->sd_vol.sv_meta.svm_no_chunk)
d632 3
a634 2
#if SR_UNIT_TEST
	int			i, vol, disk, state;
d636 1
a636 1
	for (i = 0, vol = -1, disk = -1; i < SR_MAXSCSIBUS; i++) {
d642 4
a645 2
		if (++disk != bs->bs_target)
			continue;
d668 1
a668 2
		sc->sc_dis[vol]->sd_set_chunk_state(sc->sc_dis[vol],
		    bs->bs_target, bs->bs_status);
d1488 2
a1495 2
	else if (states[BIOC_SDONLINE] == 0)
		new_state = BIOC_SVOFFLINE;
@


1.12
log
@Spacing and a stale comment.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.11 2007/03/30 23:15:30 marco Exp $ */
d599 1
a599 1
	int			i, vol, rv = EINVAL;
a601 2
	/* FIXME, wrong disk lookup */

d609 5
a613 1
		src = sc->sc_dis[i]->sd_vol.sv_chunks[bd->bd_diskid];
d616 2
a617 2
		bd->bd_channel = i;
		bd->bd_target = bd->bd_diskid;
@


1.11
log
@Make volume state transitions work
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.10 2007/03/30 20:12:28 marco Exp $ */
a1385 1
	/* there is a race on status here but we don't care for now */
a1467 1

@


1.10
log
@Calculate proper offset in partition table.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.9 2007/03/27 04:05:22 marco Exp $ */
d602 2
d630 42
a671 1
#ifdef SR_UNIT_TEST
a672 1

d1470 2
a1471 1
	for (i = 0; i < nd; i++)
d1484 1
a1484 1
	if (states[BIOC_SVONLINE] == nd)
d1486 1
a1486 1
	else if (states[BIOC_SVSCRUB] != 0)
d1488 1
a1488 3
	else if (states[BIOC_SVBUILDING] != 0)
		new_state = BIOC_SVBUILDING;
	else if (states[BIOC_SVREBUILD] != 0)
d1490 1
a1490 1
	else if (states[BIOC_SVDEGRADED] != 0)
d1492 1
a1492 1
	else if (states[BIOC_SVONLINE] == 0)
d1496 1
a1496 1
		for (i = 0; i < SR_MAX_STATES; i++)
d1574 2
@


1.9
log
@First stab at state transition code for volumes and chunks.
Minor cleanup as well.

prodded by jordan
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.8 2007/03/26 01:44:06 tedu Exp $ */
d922 1
a922 1
		    label.d_partitions['a' - ss].p_size;
d930 4
a933 3
		if (label.d_partitions['a' - ss].p_fstype != FS_RAID) {
			printf("%s: %s partition not of type RAID\n",
			    DEVNAME(sc), name);
@


1.8
log
@typos in comments
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.7 2007/03/24 05:15:19 tedu Exp $ */
d52 1
a52 1
		    | SR_D_MISC
d54 1
a54 1
		    /* | SR_D_IOCTL*/
d56 4
a59 3
		    /* | SR_D_WU  */
		    /* | SR_D_META*/
		    | SR_D_DIS
d87 2
d118 3
d530 1
a530 1
		/*rv = sr_ioctl_setstate(sc, (struct bioc_setstate *)addr); */
d571 1
a571 1
	struct sr_volume	*mv;
d580 6
a585 6
		mv = &sc->sc_dis[i]->sd_vol;
		bv->bv_status = mv->sv_meta.svm_status;
		bv->bv_size = mv->sv_meta.svm_size;
		bv->bv_level = mv->sv_meta.svm_level;
		bv->bv_nodisk = mv->sv_meta.svm_no_chunk;
		strlcpy(bv->bv_dev, mv->sv_meta.svm_devname,
d587 1
a587 1
		strlcpy(bv->bv_vendor, mv->sv_meta.svm_vendor,
d600 1
a600 1
	struct sr_chunk		*mc;
d609 4
a612 3
		mc = sc->sc_dis[i]->sd_vol.sv_chunks[bd->bd_diskid];
		bd->bd_status = mc->src_meta.scm_status;
		bd->bd_size = mc->src_meta.scm_size;
d614 1
a614 1
		strlcpy(bd->bd_vendor, mc->src_meta.scm_devname,
d624 11
d713 2
d1327 204
@


1.7
log
@fix the vnode locking
ok marco pedro
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.6 2007/03/20 03:31:24 marco Exp $ */
d807 1
a807 1
	/* make sure we have a valid device lst like /dev/sdNa,/dev/sdNNa */
d1116 1
a1116 1
			/* XXX check to see if volume can be brough online */
@


1.6
log
@Hook up sd ioctl.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.5 2007/03/20 02:48:22 marco Exp $ */
d865 1
a865 1
			goto unwind;
d873 1
a873 1
			goto unwind;
d880 1
a880 1
			goto unwind;
d887 1
a887 1
			goto unwind;
d896 1
a896 1
			goto unwind; /* disklabel failed */
d906 1
a906 1
			goto unwind;
d913 1
a913 1
			goto unwind;
d933 2
d1145 1
d1149 1
@


1.5
log
@Fake out target id for bioc_disk.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.4 2007/03/19 22:33:15 dlg Exp $ */
d483 1
a483 1
	return (ENOTTY);
@


1.4
log
@the autoconf glue funcs (match/attach/etc) are only used inside softraid.c,
so prototype them there rather than in softraidvar.h.

shuffle these funcs a little bit while here to make it look more like
everything else.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.3 2007/03/19 15:00:08 mk Exp $ */
d606 1
@


1.3
log
@Fix keyword expansion.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d62 5
d68 1
a68 4
	sizeof(struct sr_softc),
	sr_probe,
	sr_attach,
	sr_detach,
d125 1
a125 13
sr_probe(struct device *parent, void *match, void *aux)
{
	return (1);
}

int
sr_detach(struct device *self, int flags)
{
	return (0);
}

int
sr_activate(struct device *self, enum devact act)
d145 12
@


1.2
log
@attach softraid to the root of the device tree in a machine independant
way, rather than requiring some glue in each machines mainbus probe.

it is still commented out.

based on a discussion with miod@@ ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD $ */
@


1.1
log
@Add a new device that provides a framework for IO manipulation.  A very basic
implementation of a RAID 1 is included in this but it does not deal with
failures yet.  Disabled in GENERIC.

Suggestions from and ok beck@@ miod@@ krw@@ dlg@@ deraadt@@
@
text
@a124 6
	struct sr_attach_args	*maa = aux;
	struct cfdata		*cf = match;

	if (strcmp(maa->maa_name, cf->cf_driver->cd_name))
		return (0);

@

