head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.26
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.16
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.24
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.22
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.20
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.18
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.14
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.12
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.10
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.8
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.10
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.12
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.8
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.6
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.4
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2;
locks; strict;
comment	@# @;


1.10
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.13.18.11.21;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.20.22.28.11;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.10.16.15.17;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.08.23.46.11;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.01.17.15.06;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.16.00.53.12;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.15.06.01.32;	author krw;	state Exp;
branches
	1.3.4.1
	1.3.8.1;
next	1.2;

1.2
date	2001.03.01.17.14.27;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.15.04.07.59;	author krw;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.25.17;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.03.28.00.38.19;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2004.02.19.10.56.24;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@;	$OpenBSD: siop.ss,v 1.9 2007/04/13 18:11:21 krw Exp $
;	$NetBSD: siop.ss,v 1.20 2005/11/18 23:10:32 bouyer Exp $

;
;  Copyright (c) 2000 Manuel Bouyer.
;
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions
;  are met:
;  1. Redistributions of source code must retain the above copyright
;     notice, this list of conditions and the following disclaimer.
;  2. Redistributions in binary form must reproduce the above copyright
;     notice, this list of conditions and the following disclaimer in the
;     documentation and/or other materials provided with the distribution.
;
;  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
;  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
;  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
;  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
;  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
;  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
;  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
;  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
;  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

ARCH 720

; offsets in siop_common_xfer
ABSOLUTE t_id = 40;
ABSOLUTE t_msg_in = 60;
ABSOLUTE t_ext_msg_in = 68;
ABSOLUTE t_ext_msg_data = 76;
ABSOLUTE t_msg_out = 84;
ABSOLUTE t_cmd = 92;
ABSOLUTE t_status = 100;
ABSOLUTE t_data = 108;

;; interrupt codes
; interrupts that need a valid DSA
ABSOLUTE int_done	= 0xff00;
ABSOLUTE int_msgin	= 0xff01;
ABSOLUTE int_extmsgin	= 0xff02;
ABSOLUTE int_extmsgdata	= 0xff03;
ABSOLUTE int_disc	= 0xff04;
ABSOLUTE int_saveoffset	= 0xff05;
; interrupts that don't have a valid DSA
ABSOLUTE int_reseltarg	= 0xff80;
ABSOLUTE int_resellun	= 0xff81;
ABSOLUTE int_reseltag	= 0xff82;
ABSOLUTE int_resfail	= 0xff83;
ABSOLUTE int_err 	= 0xffff;

; flags for scratcha0
ABSOLUTE flag_sdp 	= 0x01 ; got save data pointer
ABSOLUTE flag_data 	= 0x02 ; we're in data phase
ABSOLUTE flag_data_mask	= 0xfd ; ~flag_data

; main script symbols

ENTRY waitphase;
ENTRY send_msgout;
ENTRY msgout;
ENTRY msgin;
ENTRY handle_msgin;
ENTRY msgin_ack;
ENTRY dataout;
ENTRY datain;
ENTRY cmdout;
ENTRY status;
ENTRY disconnect;
ENTRY reselect;
ENTRY reselected;
ENTRY selected;
ENTRY script_sched;
ENTRY script_sched_slot0;
ENTRY get_extmsgdata;
ENTRY resel_targ0;
ENTRY msgin_space;
ENTRY lunsw_return;
ENTRY led_on1;
ENTRY led_on2;
ENTRY led_off;
EXTERN abs_script_sched_slot0;
EXTERN abs_targ0;
EXTERN abs_msgin;

; lun switch symbols
ENTRY lun_switch_entry;
ENTRY resel_lun0;
ENTRY restore_scntl3;
EXTERN abs_lunsw_return;

; tag switch symbols
ENTRY tag_switch_entry;
ENTRY resel_tag0;
EXTERN abs_tag0;

; command reselect script symbols
ENTRY rdsa0;
ENTRY rdsa1;
ENTRY rdsa2;
ENTRY rdsa3;
ENTRY ldsa_reload_dsa;
ENTRY ldsa_select;
ENTRY ldsa_data;

EXTERN ldsa_abs_reselected;
EXTERN ldsa_abs_reselect;
EXTERN ldsa_abs_selected;
EXTERN ldsa_abs_data;
EXTERN ldsa_abs_slot;

; main script

PROC  siop_script:

reselected:
; starting a new session, init 'local variables'
	MOVE 0 to SCRATCHA0	; flags
	MOVE 0 to SCRATCHA1	; DSA offset (for S/G save data pointer)
	MOVE SCRATCHA3 to SFBR  ; pending message ?
	JUMP REL(handle_msgin), IF not 0x20;
waitphase:
	JUMP REL(msgout), WHEN MSG_OUT;
	JUMP REL(msgin), WHEN MSG_IN;
	JUMP REL(dataout), WHEN DATA_OUT;
	JUMP REL(datain), WHEN DATA_IN;
	JUMP REL(cmdout), WHEN CMD;
	JUMP REL(status), WHEN STATUS;
	INT int_err;

reselect_fail:
	; check that host asserted SIGP, this'll clear SIGP in ISTAT
	MOVE CTEST2 & 0x40 TO SFBR;
	INT int_resfail,  IF 0x00;
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on1:
	NOP;
script_sched:
	; Clear DSA and init status
	MOVE 0xff to DSA0;
	MOVE 0xff to DSA1;
	MOVE 0xff to DSA2;
	MOVE 0xff to DSA3;
	MOVE 0 to SCRATCHA0	; flags
	MOVE 0 to SCRATCHA1	; DSA offset (for S/G save data pointer)
; the script scheduler: siop_start() we set the absolute jump addr, and then
; changes the FALSE to TRUE. The select script will change it back to false
; once the target is selected.
; The RAM could hold 370 slot entry, we limit it to 40. Should be more than
; enough.
script_sched_slot0:
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
	JUMP abs_script_sched_slot0, IF FALSE;
; Nothing to do, wait for reselect
reselect:
	; Clear DSA and init status
	MOVE 0xff to DSA0;
	MOVE 0xff to DSA1;
	MOVE 0xff to DSA2;
	MOVE 0xff to DSA3;
	MOVE 0x00 to SCRATCHA2; no tag
	MOVE 0x20 to SCRATCHA3; simple tag msg, ignored by reselected:
; a NOP by default; patched with MOVE GPREG | 0x01 to GPREG on compile-time
; option "SIOP_SYMLED"
led_off:
	NOP;
	WAIT RESELECT REL(reselect_fail)
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on2:
	NOP;
	MOVE SSID & 0x8f to SFBR
	MOVE SFBR to SCRATCHA0 ; save reselect ID
; find the right param for this target
resel_targ0:
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	JUMP abs_targ0, IF 0xff;
	INT int_reseltarg;
lunsw_return:
	MOVE 1, abs_msgin, WHEN MSG_IN;
	MOVE SFBR & 0x07 to SCRATCHA1; save LUN
	CLEAR ACK;
	RETURN, WHEN NOT MSG_IN; If no more message, jump to lun sw
	MOVE 1, abs_msgin, WHEN MSG_IN;
	CLEAR ACK;
	MOVE SFBR  to SCRATCHA3; save message
	RETURN, IF NOT 0x20; jump to lun sw if not simple tag msg
	MOVE 1, abs_msgin, WHEN MSG_IN; get tag
	CLEAR ACK;
	MOVE SFBR  to SCRATCHA2; save tag
	RETURN; jump to lun sw

handle_sdp:
	CLEAR ACK;
	MOVE SCRATCHA0 | flag_sdp TO SCRATCHA0;
	; should get a disconnect message now
msgin:
	CLEAR ATN
	MOVE FROM t_msg_in, WHEN MSG_IN;
handle_msgin:
	JUMP REL(handle_cmpl), IF 0x00        ; command complete message
	JUMP REL(handle_sdp), IF 0x02	      ; save data pointer message
	JUMP REL(handle_extin), IF 0x01	      ; extended message
	INT int_msgin, IF not 0x04;
	CALL REL(disconnect)                  ; disconnect message;
; if we didn't get sdp, no need to interrupt
	MOVE SCRATCHA0 & flag_sdp TO SFBR;
	INT int_disc, IF not 0x00;
; update offset if we did some data transfer
	MOVE SCRATCHA1 TO SFBR;
	JUMP REL(script_sched), if 0x00;
	INT int_saveoffset;

msgin_ack:
selected:
	CLEAR ACK;
	JUMP REL(waitphase);

; entry point for msgout after a msgin or status phase
send_msgout:
	SET ATN;
	CLEAR ACK;
msgout:
	MOVE FROM t_msg_out, WHEN MSG_OUT;
	CLEAR ATN;
	JUMP REL(waitphase);
cmdout:
	MOVE FROM t_cmd, WHEN CMD;
	JUMP REL(waitphase);
status:
	MOVE FROM t_status, WHEN STATUS;
	JUMP REL(waitphase);
datain:
	CALL REL(savedsa);
	MOVE SCRATCHA0 | flag_data TO SCRATCHA0;
datain_loop:
	MOVE FROM t_data, WHEN DATA_IN;
	MOVE SCRATCHA1 + 1 TO SCRATCHA1	; adjust offset
	MOVE DSA0 + 8 to DSA0;
	MOVE DSA1 + 0 to DSA1 WITH CARRY;
	MOVE DSA2 + 0 to DSA2 WITH CARRY;
	MOVE DSA3 + 0 to DSA3 WITH CARRY;
	JUMP REL(datain_loop), WHEN DATA_IN;
	CALL REL(restoredsa);
	MOVE SCRATCHA0 & flag_data_mask TO SCRATCHA0;
	JUMP REL(waitphase);

dataout:
	CALL REL(savedsa);
	MOVE SCRATCHA0 | flag_data TO SCRATCHA0;
dataout_loop:
	MOVE FROM t_data, WHEN DATA_OUT;
	MOVE SCRATCHA1 + 1 TO SCRATCHA1	; adjust offset
	MOVE DSA0 + 8 to DSA0;
	MOVE DSA1 + 0 to DSA1 WITH CARRY;
	MOVE DSA2 + 0 to DSA2 WITH CARRY;
	MOVE DSA3 + 0 to DSA3 WITH CARRY;
	JUMP REL(dataout_loop), WHEN DATA_OUT;
	CALL REL(restoredsa);
	MOVE SCRATCHA0 & flag_data_mask TO SCRATCHA0;
	JUMP REL(waitphase);

savedsa:
	MOVE DSA0 to SFBR;
	MOVE SFBR to SCRATCHB0;
	MOVE DSA1 to SFBR;
	MOVE SFBR to SCRATCHB1;
	MOVE DSA2 to SFBR;
	MOVE SFBR to SCRATCHB2;
	MOVE DSA3 to SFBR;
	MOVE SFBR to SCRATCHB3;
	RETURN;

restoredsa:
	MOVE SCRATCHB0 TO SFBR;
	MOVE SFBR TO DSA0;
	MOVE SCRATCHB1 TO SFBR;
	MOVE SFBR TO DSA1;
	MOVE SCRATCHB2 TO SFBR;
	MOVE SFBR TO DSA2;
	MOVE SCRATCHB3 TO SFBR;
	MOVE SFBR TO DSA3;
	RETURN;

disconnect:
	MOVE SCNTL2 & 0x7f TO SCNTL2;
	CLEAR ATN;
	CLEAR ACK;
	WAIT DISCONNECT;
	RETURN;

handle_cmpl:
	CALL REL(disconnect);
	INT int_done;

handle_extin:
	CLEAR ACK;
	MOVE FROM t_ext_msg_in, WHEN MSG_IN;
	INT int_extmsgin; /* let host fill in t_ext_msg_data */
get_extmsgdata:
	CLEAR ACK;
	MOVE FROM t_ext_msg_data, WHEN MSG_IN;
	INT int_extmsgdata;
msgin_space:
	NOP; space to store msgin when reselect


;; per-target switch script for LUNs
; hack: we first do a call to the target-specific code, so that a return
; in the main switch will jump to the lun switch.
PROC lun_switch:
restore_scntl3:
	MOVE 0xff TO SCNTL3;
	MOVE 0xff TO SXFER;
	JUMP abs_lunsw_return;
lun_switch_entry:
	CALL REL(restore_scntl3);
	MOVE SCRATCHA1 TO SFBR;
resel_lun0:
	INT int_resellun;

;; Per-device switch script for tag
PROC tag_switch:
tag_switch_entry:
	MOVE SCRATCHA2 TO SFBR; restore tag
resel_tag0:
	JUMP abs_tag0, IF 0x00;
	JUMP abs_tag0, IF 0x01;
	JUMP abs_tag0, IF 0x02;
	JUMP abs_tag0, IF 0x03;
	JUMP abs_tag0, IF 0x04;
	JUMP abs_tag0, IF 0x05;
	JUMP abs_tag0, IF 0x06;
	JUMP abs_tag0, IF 0x07;
	JUMP abs_tag0, IF 0x08;
	JUMP abs_tag0, IF 0x09;
	JUMP abs_tag0, IF 0x0a;
	JUMP abs_tag0, IF 0x0b;
	JUMP abs_tag0, IF 0x0c;
	JUMP abs_tag0, IF 0x0d;
	JUMP abs_tag0, IF 0x0e;
	JUMP abs_tag0, IF 0x0f;
	INT int_reseltag;

;; per-command script: select, and called after a reselect to load DSA

PROC load_dsa:
; Can't use MOVE MEMORY to load DSA, doesn't work I/O mapped
rdsa0:
	MOVE 0xf0 to DSA0;
rdsa1:
	MOVE 0xf1 to DSA1;
rdsa2:
	MOVE 0xf2 to DSA2;
rdsa3:
	MOVE 0xf3 to DSA3;
	RETURN;
ldsa_reload_dsa:
	CALL REL(rdsa0);
	JUMP ldsa_abs_reselected;
ldsa_select:
	CALL REL(rdsa0);
	SELECT ATN FROM t_id, ldsa_abs_reselect;
	MOVE MEMORY 4, ldsa_abs_data, ldsa_abs_slot;
	JUMP ldsa_abs_selected;
ldsa_data:
	NOP; contains data used by the MOVE MEMORY

PROC siop_led_on:
	MOVE GPREG & 0xfe TO GPREG;

PROC siop_led_off:
	MOVE GPREG | 0x01 TO GPREG;
@


1.9
log
@scsi_generic is now 16 bytes. Adjust offsets into structure being
passed to controller so they point where expected. Fixes martin@@'s
alpha and sparc machines.
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.8 2005/11/20 22:28:11 krw Exp $
a14 5
;  3. All advertising materials mentioning features or use of this software
;     must display the following acknowledgement:
; 	This product includes software developed by Manuel Bouyer.
;  4. The name of the author may not be used to endorse or promote products
;     derived from this software without specific prior written permission.
@


1.8
log
@Add patch from Martin Bouyer to fix NetBSD PR #31990. Will generate
microcode that (in concert with fixes to ic/siop*) fixes problems
found by miod@@, martin@@, otto@@, on some drives.
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.7 2005/10/10 16:15:17 krw Exp $
d36 7
a42 7
ABSOLUTE t_msg_in = 56;
ABSOLUTE t_ext_msg_in = 64;
ABSOLUTE t_ext_msg_data = 72;
ABSOLUTE t_msg_out = 80;
ABSOLUTE t_cmd = 88;
ABSOLUTE t_status = 96;
ABSOLUTE t_data = 104;
@


1.7
log
@Script fix for resid calculation/save data pointer function.
Preparation for larger diff for IGNORE WIDE RESIDUE messages and real
resid calculation. From bouyer via NetBSD. Note we are now sync'd to
latest (r1.19) code from NetBSD.
@
text
@d1 2
a2 2
;	$OpenBSD: siop.ss,v 1.6 2005/10/08 23:46:11 krw Exp $
;	$NetBSD: siop.ss,v 1.19 2005/02/27 00:27:29 perry Exp $
d51 1
d267 3
d271 2
a272 2
; Ok, we need to save data pointers
	INT int_disc;
@


1.6
log
@More trailing whitespace removal (perry via NetBSD).
@
text
@d1 2
a2 2
;	$OpenBSD: siop.ss,v 1.5 2003/07/01 17:15:06 krw Exp $
;	$NetBSD: siop.ss,v 1.17 2002/07/26 14:11:34 wiz Exp $
d264 1
a264 1
; if we didn't get sdp, or if offset is 0, no need to interrupt
a265 2
	JUMP REL(script_sched), if 0x00; 
	MOVE SCRATCHA1 TO SFBR;
@


1.5
log
@Don't dma map the xs->cmd. Copy it to a safe buffer that is already
mapped and sync'ed appropriately, and is guaranteed to be in one
memory page.

Eliminate now unused dmamap_cmd and rs_cmd fields.

Fix another error message (adding active command to reset list) so
that it includes the adapter name.

Add missing letoh32() calls to debug code.

The evils of directly mapping *xs->cmd were pointed out by Mickey
during osiop development. In particular, *xs->cmd may start on one
memory page and run into the next. Since the dma logic in most
cards/drivers (including siop) only allocates one address/size pair to
map *xs->cmd, parts of a command could be lost or corrupted.

The large number of 6 byte dma mappings noted long ago by someone
(Henric?).  This change reduces the dma mapping activity per i/o by
1/3 to 1/2 and may give a performance boost of some kind.

Successfully tested on i386, sparc64 (ultra30 - thanks Jolan,
blade100), macppc and alpha.

Unfortunately these changes don't fix the Blade1000 siop problems.

**NOTE** If scsi_generic is ever upped to 16 bytes the offsets in
siop.ss must be updated!
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.4 2002/09/16 00:53:12 krw Exp $
d6 1
a6 1
; 
d20 1
a20 1
; 
d24 1
a24 1
;  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,     
d153 1
a153 1
; the script scheduler: siop_start() we set the absolute jump addr, and then 
d268 1
a268 1
	JUMP REL(script_sched), if 0x00; 
@


1.4
log
@Resync siop with NetBSD. Make strong effort to minimize
differences, undoing whitespace, spelling, etc. changes
and adopting the NetBSD code instead of equivalent home
grown code for PPR negotiation, etc.

siop.c            1.21 -> 1.64
siop_common.c     1.12 -> 1.30
siopreg.h         1.7  -> 1.13
siopvar.h         1.13 -> 1.18
siopvar_common.h  1.10 -> 1.21
ncr53cxxx.c       1.5  -> 1.10
siop.ss           1.12 -> 1.17
siop_pci.c        1.8  -> 1.11
siop_pci_common.c 1.6  -> 1.17
siop_pci_common.h 1.2  -> 1.4

Many fixes, add 1010-66 support, restructure things to prepare for
addition of esiop, osiop and oosiop drivers.

tested on various archs by art@@, millert@@, wilfried@@, jason@@,
Dan Weeks.

ok deraadt@@.
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.3 2001/04/15 06:01:32 krw Exp $
d36 7
a42 7
ABSOLUTE t_msg_in = 48;
ABSOLUTE t_ext_msg_in = 56;
ABSOLUTE t_ext_msg_data = 64;
ABSOLUTE t_msg_out = 72;
ABSOLUTE t_cmd = 80;
ABSOLUTE t_status = 88;
ABSOLUTE t_data = 96;
@


1.3
log
@Support U160 on 53c1010 chips.

Add support for PPR negotiations and DT transfers,
and the preservation and restoration of the
SCNTL4 register which controls Ultra3 transfers.

Redo sync lookup, since the same period factor
can mean two things depending on whether you are
using DT or ST. Keep a minimum allowed ST period
factor, and a minimum allowd DT period factor for
each adapter.

Currently NO support for QAS or IUS or AIP.
@
text
@d1 2
a2 2
;	$OpenBSD: siop.ss,v 1.2 2001/03/01 17:14:27 krw Exp $
;	$NetBSD: siop.ss,v 1.12 2000/10/23 14:53:53 bouyer Exp $
d17 1
a17 1
; 	This product includes software developed by Manuel Bouyer
d34 1
a34 1
; offsets in sym_xfer
d85 3
d141 4
d208 4
d213 4
a371 1
	MOVE 0xff TO SFBR;
d425 6
@


1.3.8.1
log
@sync to -current
@
text
@d1 2
a2 2
;	$OpenBSD$
;	$NetBSD: siop.ss,v 1.17 2002/07/26 14:11:34 wiz Exp $
d17 1
a17 1
; 	This product includes software developed by Manuel Bouyer.
d34 1
a34 1
; offsets in siop_common_xfer
a84 3
ENTRY led_on1;
ENTRY led_on2;
ENTRY led_off;
a137 4
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on1:
	NOP;
a200 4
; a NOP by default; patched with MOVE GPREG | 0x01 to GPREG on compile-time
; option "SIOP_SYMLED"
led_off:
	NOP;
a201 4
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on2:
	NOP;
d357 1
a410 6

PROC siop_led_on:
	MOVE GPREG & 0xfe TO GPREG;

PROC siop_led_off:
	MOVE GPREG | 0x01 TO GPREG;
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.3 2001/04/15 06:01:32 krw Exp $
@


1.3.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
;	$OpenBSD$
;	$NetBSD: siop.ss,v 1.17 2002/07/26 14:11:34 wiz Exp $
d17 1
a17 1
; 	This product includes software developed by Manuel Bouyer.
d34 1
a34 1
; offsets in siop_common_xfer
a84 3
ENTRY led_on1;
ENTRY led_on2;
ENTRY led_off;
a137 4
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on1:
	NOP;
a200 4
; a NOP by default; patched with MOVE GPREG | 0x01 to GPREG on compile-time
; option "SIOP_SYMLED"
led_off:
	NOP;
a201 4
; a NOP by default; patched with MOVE GPREG & 0xfe to GPREG on compile-time
; option "SIOP_SYMLED"
led_on2:
	NOP;
d357 1
a410 6

PROC siop_led_on:
	MOVE GPREG & 0xfe TO GPREG;

PROC siop_led_off:
	MOVE GPREG | 0x01 TO GPREG;
@


1.3.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d36 7
a42 7
ABSOLUTE t_msg_in = 56;
ABSOLUTE t_ext_msg_in = 64;
ABSOLUTE t_ext_msg_data = 72;
ABSOLUTE t_msg_out = 80;
ABSOLUTE t_cmd = 88;
ABSOLUTE t_status = 96;
ABSOLUTE t_data = 104;
@


1.2
log
@Typo police: various misspelling, capitalizations, etc.
@
text
@d1 1
a1 1
;	$OpenBSD: siop.ss,v 1.1 2001/02/15 04:07:59 krw Exp $
d35 8
a42 8
ABSOLUTE t_id = 24;
ABSOLUTE t_msg_in = 32;
ABSOLUTE t_ext_msg_in = 40;
ABSOLUTE t_ext_msg_data = 48;
ABSOLUTE t_msg_out = 56;
ABSOLUTE t_cmd = 64;
ABSOLUTE t_status = 72;
ABSOLUTE t_data = 80;
d357 1
@


1.1
log
@Import siop, a replacement for the ncr SCSI driver, from NetBSD.

Written for NetBSD by Manuel Bouyer.

Tested with various cards on i386 and alpha.

Outstanding issue: doesn't work with PowerPC yet.
@
text
@d1 1
a1 1
;	$OpenBSD$
d150 1
a150 1
; enouth.
d204 1
a204 1
; find the rigth param for this target
@

