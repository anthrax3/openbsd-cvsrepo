head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.18
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.20
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.16
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.14
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.12
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.10
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.0.44
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.42
	OPENBSD_5_0:1.1.0.40
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.38
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.36
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.32
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.34
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.30
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.28
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.26
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.24
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.22
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.20
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.18
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.16
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.14
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.12
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.10
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.8
	OPENBSD_3_4_BASE:1.1
	UBC:1.1.0.6
	UBC_SYNC_A:1.1
	SMP:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@# @;


1.2
date	2013.01.06.22.06.54;	author martynas;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.08.02.11.38;	author krw;	state Exp;
branches;
next	;


desc
@@


1.2
log
@acknowlege -> acknowledge
compatability -> compatibility

OK jmc@@.
@
text
@;	$OpenBSD: osiop.ss,v 1.1 2003/01/08 02:11:38 krw Exp $	
;	$NetBSD: osiop.ss,v 1.1 2001/04/30 04:47:51 tsutsui Exp $

;
; Copyright (c) 1995 Michael L. Hitch
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 1. Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
; 3. All advertising materials mentioning features or use of this software
;    must display the following acknowledgement:
;      This product includes software developed by Michael L. Hitch.
; 4. The name of the author may not be used to endorse or promote products
;    derived from this software without specific prior written permission
;
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;

; NCR 53c710 script
;
ARCH 710
;
ABSOLUTE ds_Device	= 0
ABSOLUTE ds_MsgOut 	= ds_Device + 8
ABSOLUTE ds_Cmd		= ds_MsgOut + 8
ABSOLUTE ds_Status	= ds_Cmd + 8
ABSOLUTE ds_Msg		= ds_Status + 8
ABSOLUTE ds_MsgIn	= ds_Msg + 8
ABSOLUTE ds_ExtMsg	= ds_MsgIn + 8
ABSOLUTE ds_SyncMsg	= ds_ExtMsg + 8
ABSOLUTE ds_Data1	= ds_SyncMsg + 8
ABSOLUTE ds_Data2	= ds_Data1 + 8
ABSOLUTE ds_Data3	= ds_Data2 + 8
ABSOLUTE ds_Data4	= ds_Data3 + 8
ABSOLUTE ds_Data5	= ds_Data4 + 8
ABSOLUTE ds_Data6	= ds_Data5 + 8
ABSOLUTE ds_Data7	= ds_Data6 + 8
ABSOLUTE ds_Data8	= ds_Data7 + 8
ABSOLUTE ds_Data9	= ds_Data8 + 8
ABSOLUTE ds_Data10	= ds_Data9 + 8
ABSOLUTE ds_Data11	= ds_Data10 + 8
ABSOLUTE ds_Data12	= ds_Data11 + 8
ABSOLUTE ds_Data13	= ds_Data12 + 8
ABSOLUTE ds_Data14	= ds_Data13 + 8
ABSOLUTE ds_Data15	= ds_Data14 + 8
ABSOLUTE ds_Data16	= ds_Data15 + 8
ABSOLUTE ds_Data17	= ds_Data16 + 8


ABSOLUTE ok		= 0xff00
ABSOLUTE int_disc	= 0xff01
ABSOLUTE int_disc_wodp	= 0xff02
ABSOLUTE int_reconnect	= 0xff03
ABSOLUTE int_connect	= 0xff04
ABSOLUTE int_phase	= 0xff05
ABSOLUTE int_msgin	= 0xff06
ABSOLUTE int_extmsg	= 0xff07
ABSOLUTE int_msgsdp	= 0xff08
ABSOLUTE int_identify	= 0xff09
ABSOLUTE int_status	= 0xff0a
ABSOLUTE int_syncmsg	= 0xff0b

ENTRY	scripts
ENTRY	switch
ENTRY	wait_reselect
ENTRY	dataout
ENTRY	datain
ENTRY	clear_ack

PROC	osiop_script:

scripts:

	SELECT ATN FROM ds_Device, REL(reselect)
;
switch:
	JUMP REL(msgin), WHEN MSG_IN
	JUMP REL(msgout), IF MSG_OUT
	JUMP REL(command_phase), IF CMD
	JUMP REL(dataout), IF DATA_OUT
	JUMP REL(datain), IF DATA_IN
	JUMP REL(end), IF STATUS

	INT int_phase			; Unrecognized phase

msgin:
	MOVE FROM ds_MsgIn, WHEN MSG_IN
	JUMP REL(ext_msg), IF 0x01	; extended message
	JUMP REL(disc), IF 0x04		; disconnect message
	JUMP REL(msg_sdp), IF 0x02	; save data pointers
	JUMP REL(msg_rej), IF 0x07	; message reject
	JUMP REL(msg_rdp), IF 0x03	; restore data pointers
	INT int_msgin			; unrecognized message

msg_rej:
; Do we need to interrupt host here to let it handle the reject?
msg_rdp:
clear_ack:
	CLEAR ACK
	CLEAR ATN
	JUMP REL(switch)

ext_msg:
	CLEAR ACK
	MOVE FROM ds_ExtMsg, WHEN MSG_IN
	JUMP REL(sync_msg), IF 0x03
	int int_extmsg			; extended message not SDTR

sync_msg:
	CLEAR ACK
	MOVE FROM ds_SyncMsg, WHEN MSG_IN
	int int_syncmsg			; Let host handle the message
; If we continue from the interrupt, the host has set up a response
; message to be sent.  Set ATN, clear ACK, and continue.
	SET ATN
	CLEAR ACK
	JUMP REL(switch)

disc:
	CLEAR ACK
	WAIT DISCONNECT

	int int_disc_wodp		; signal disconnect w/o save DP

msg_sdp:
	CLEAR ACK			; acknowledge message
	JUMP REL(switch), WHEN NOT MSG_IN
	MOVE FROM ds_ExtMsg, WHEN MSG_IN
	INT int_msgsdp, IF NOT 0x04	; interrupt if not disconnect
	CLEAR ACK
	WAIT DISCONNECT

	INT int_disc			; signal disconnect

reselect:
wait_reselect:
	WAIT RESELECT REL(select_adr)
	MOVE LCRC to SFBR		; Save reselect ID
	MOVE SFBR to SCRATCH0

	INT int_identify, WHEN NOT MSG_IN
	MOVE FROM ds_Msg, WHEN MSG_IN
	INT int_reconnect		; let host know about reconnect
	CLEAR ACK			; acknowledge the message
	JUMP REL(switch)

select_adr:
	MOVE SCNTL1 & 0x10 to SFBR	; get connected status
	INT int_connect, IF 0x00	; tell host if not connected
	MOVE CTEST2 & 0x40 to SFBR	; clear Sig_P
	JUMP REL(wait_reselect)		; and try reselect again

msgout:
	MOVE FROM ds_MsgOut, WHEN MSG_OUT
	JUMP REL(switch)

command_phase:
	CLEAR ATN
	MOVE FROM ds_Cmd, WHEN CMD
	JUMP REL(switch)

dataout:
	MOVE FROM ds_Data1, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data2, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data3, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data4, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data5, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data6, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data7, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data8, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data9, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data10, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data11, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data12, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data13, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data14, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data15, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data16, WHEN DATA_OUT
	CALL REL(switch), WHEN NOT DATA_OUT
	MOVE FROM ds_Data17, WHEN DATA_OUT
	CALL REL(switch)

datain:
	MOVE FROM ds_Data1, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data2, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data3, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data4, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data5, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data6, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data7, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data8, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data9, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data10, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data11, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data12, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data13, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data14, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data15, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data16, WHEN DATA_IN
	CALL REL(switch), WHEN NOT DATA_IN
	MOVE FROM ds_Data17, WHEN DATA_IN
	CALL REL(switch)

end:
	MOVE FROM ds_Status, WHEN STATUS
	int int_status, WHEN NOT MSG_IN	; status not followed by msg
	MOVE FROM ds_Msg, WHEN MSG_IN
	CLEAR ACK
	WAIT DISCONNECT
	INT ok				; signal completion
	JUMP REL(wait_reselect)
@


1.1
log
@Merry Christmas Mickey!

First cut at osiop driver (LSI Logic/Symbios/NCR 53C710). For hppa
only at the moment.

Functional for the most part, but there are known problems:

1) SCSI_CHECK/REQUEST_SENSE not handled at all - simply returns a
zero'ed scsi_sense_data buffer. As a result all osiop sc_link's are
created with the ADEV_NODOORLOCK quirk to suppress PREVENT_ALLOW
commands from being issued (and failing) during probe.

2) Sync negotiation (wide is not supported on this chip) needs to be
validated due to some ominous comments in the source about being valid
only for the 33Mhz Zeus board.

3) Probe message needs fixing/completion to issue useful info. See 2).

4) Timeout/hangs occur under heavy load, e.g. make builds.

From NetBSD.

ok mickey@@
@
text
@d1 1
a1 1
;	$OpenBSD$	
d159 1
a159 1
	CLEAR ACK			; acknowlege the message
@

