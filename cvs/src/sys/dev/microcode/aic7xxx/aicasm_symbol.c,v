head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.14
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.8
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.6
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.8
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.4
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.2
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.26
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.22
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.20
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.18
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.16
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.13
date	2014.07.12.19.01.49;	author tedu;	state Exp;
branches;
next	1.12;
commitid	oZu656PKSRXbpZyM;

1.12
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.11;
commitid	I19imNlAX05zJOED;

1.11
date	2012.12.05.23.20.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.28.23.22.45;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.20.17.22.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.28.02.24.04;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.28.00.34.55;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2000.03.24.09.09.14;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.28.00.38.17;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2003.05.19.22.16.04;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@revert bogus free changes in not kernel files. got a little trigger happy.
@
text
@/* $OpenBSD: aicasm_symbol.c,v 1.12 2014/07/12 18:48:18 tedu Exp $ */
/*	$NetBSD: aicasm_symbol.c,v 1.4 2003/07/14 15:42:40 lukem Exp $	*/

/*
 * Aic7xxx SCSI host adapter firmware asssembler symbol table implementation
 *
 * Copyright (c) 1997 Justin T. Gibbs.
 * Copyright (c) 2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.23 2003/01/20 18:01:37 gibbs Exp $
 */

#include <sys/types.h>

#ifdef __linux__
#include "aicdb.h"
#else
#include <db.h>
#endif
#include <fcntl.h>
#include <inttypes.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>

#include "aicasm_symbol.h"
#include "aicasm.h"

static DB *symtable;

symbol_t *
symbol_create(char *name)
{
	symbol_t *new_symbol;

	new_symbol = (symbol_t *)malloc(sizeof(symbol_t));
	if (new_symbol == NULL) {
		perror("Unable to create new symbol");
		exit(EX_SOFTWARE);
	}
	memset(new_symbol, 0, sizeof(*new_symbol));
	new_symbol->name = strdup(name);
	if (new_symbol->name == NULL)
		 stop("Unable to strdup symbol name", EX_SOFTWARE);
	new_symbol->type = UNINITIALIZED;
	return (new_symbol);
}

void
symbol_delete(symbol_t *symbol)
{
	if (symtable != NULL) {
		DBT	 key;

		key.data = symbol->name;
		key.size = strlen(symbol->name);
		symtable->del(symtable, &key, /*flags*/0);
	}
	switch(symbol->type) {
	case SCBLOC:
	case SRAMLOC:
	case REGISTER:
		if (symbol->info.rinfo != NULL)
			free(symbol->info.rinfo);
		break;
	case ALIAS:
		if (symbol->info.ainfo != NULL)
			free(symbol->info.ainfo);
		break;
	case MASK:
	case FIELD:
	case ENUM:
	case ENUM_ENTRY:
		if (symbol->info.finfo != NULL) {
			symlist_free(&symbol->info.finfo->symrefs);
			free(symbol->info.finfo);
		}
		break;
	case DOWNLOAD_CONST:
	case CONST:
		if (symbol->info.cinfo != NULL)
			free(symbol->info.cinfo);
		break;
	case LABEL:
		if (symbol->info.linfo != NULL)
			free(symbol->info.linfo);
		break;
	case UNINITIALIZED:
	default:
		break;
	}
	free(symbol->name);
	free(symbol);
}

void
symtable_open()
{
	symtable = dbopen(/*filename*/NULL,
			  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,
			  /*openinfo*/NULL);

	if (symtable == NULL) {
		perror("Symbol table creation failed");
		exit(EX_SOFTWARE);
		/* NOTREACHED */
	}
}

void
symtable_close()
{
	if (symtable != NULL) {
		DBT	 key;
		DBT	 data;

		while (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {
			symbol_t *stored_ptr;

			memcpy(&stored_ptr, data.data, sizeof(stored_ptr));
			symbol_delete(stored_ptr);
		}
		symtable->close(symtable);
	}
}

/*
 * The semantics of get is to return an uninitialized symbol entry
 * if a lookup fails.
 */
symbol_t *
symtable_get(char *name)
{
	symbol_t *stored_ptr;
	DBT	  key;
	DBT	  data;
	int	  retval;

	key.data = (void *)name;
	key.size = strlen(name);

	if ((retval = symtable->get(symtable, &key, &data, /*flags*/0)) != 0) {
		if (retval == -1) {
			perror("Symbol table get operation failed");
			exit(EX_SOFTWARE);
			/* NOTREACHED */
		} else if (retval == 1) {
			/* Symbol wasn't found, so create a new one */
			symbol_t *new_symbol;

			new_symbol = symbol_create(name);
			data.data = &new_symbol;
			data.size = sizeof(new_symbol);
			if (symtable->put(symtable, &key, &data,
					  /*flags*/0) !=0) {
				perror("Symtable put failed");
				exit(EX_SOFTWARE);
			}
			return (new_symbol);
		} else {
			perror("Unexpected return value from db get routine");
			exit(EX_SOFTWARE);
			/* NOTREACHED */
		}
	}
	memcpy(&stored_ptr, data.data, sizeof(stored_ptr));
	return (stored_ptr);
}

symbol_node_t *
symlist_search(symlist_t *symlist, char *symname)
{
	symbol_node_t *curnode;

	curnode = SLIST_FIRST(symlist);
	while(curnode != NULL) {
		if (strcmp(symname, curnode->symbol->name) == 0)
			break;
		curnode = SLIST_NEXT(curnode, links);
	}
	return (curnode);
}

void
symlist_add(symlist_t *symlist, symbol_t *symbol, int how)
{
	symbol_node_t *newnode;

	newnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));
	if (newnode == NULL) {
		stop("symlist_add: Unable to malloc symbol_node", EX_SOFTWARE);
		/* NOTREACHED */
	}
	newnode->symbol = symbol;
	if (how == SYMLIST_SORT) {
		symbol_node_t *curnode;
		int field;

		field = FALSE;
		switch(symbol->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			break;
		case FIELD:
		case MASK:
		case ENUM:
		case ENUM_ENTRY:
			field = TRUE;
			break;
		default:
			stop("symlist_add: Invalid symbol type for sorting",
			     EX_SOFTWARE);
			/* NOTREACHED */
		}

		curnode = SLIST_FIRST(symlist);
		if (curnode == NULL
		 || (field
		  && (curnode->symbol->type > newnode->symbol->type
		   || (curnode->symbol->type == newnode->symbol->type
		    && (curnode->symbol->info.finfo->value >
			newnode->symbol->info.finfo->value))))
		 || (!field && (curnode->symbol->info.rinfo->address >
		               newnode->symbol->info.rinfo->address))) {
			SLIST_INSERT_HEAD(symlist, newnode, links);
			return;
		}

		while (1) {
			if (SLIST_NEXT(curnode, links) == NULL) {
				SLIST_INSERT_AFTER(curnode, newnode,
						   links);
				break;
			} else {
				symbol_t *cursymbol;

				cursymbol = SLIST_NEXT(curnode, links)->symbol;
				if ((field
		  		  && (cursymbol->type > symbol->type
				   || (cursymbol->type == symbol->type
				    && (cursymbol->info.finfo->value >
					symbol->info.finfo->value))))
				 || (!field
				   && (cursymbol->info.rinfo->address >
				       symbol->info.rinfo->address))) {
					SLIST_INSERT_AFTER(curnode, newnode,
							   links);
					break;
				}
			}
			curnode = SLIST_NEXT(curnode, links);
		}
	} else {
		SLIST_INSERT_HEAD(symlist, newnode, links);
	}
}

void
symlist_free(symlist_t *symlist)
{
	symbol_node_t *node1, *node2;

	node1 = SLIST_FIRST(symlist);
	while (node1 != NULL) {
		node2 = SLIST_NEXT(node1, links);
		free(node1);
		node1 = node2;
	}
	SLIST_INIT(symlist);
}

void
symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
	      symlist_t *symlist_src2)
{
	symbol_node_t *node;

	*symlist_dest = *symlist_src1;
	while((node = SLIST_FIRST(symlist_src2)) != NULL) {
		SLIST_REMOVE_HEAD(symlist_src2, links);
		SLIST_INSERT_HEAD(symlist_dest, node, links);
	}

	/* These are now empty */
	SLIST_INIT(symlist_src1);
	SLIST_INIT(symlist_src2);
}

void
aic_print_file_prologue(FILE *ofile)
{

	if (ofile == NULL)
		return;

	fprintf(ofile,
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n",
		versions);
}

void
aic_print_include(FILE *dfile, char *include_file)
{

	if (dfile == NULL)
		return;
	fprintf(dfile, "\n#include \"%s\"\n\n", include_file);
}

void
aic_print_reg_dump_types(FILE *ofile)
{
	if (ofile == NULL)
		return;
		
	fprintf(ofile,
"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"
"typedef struct %sreg_parse_entry {\n"
"	char	*name;\n"
"	uint8_t	 value;\n"
"	uint8_t	 mask;\n"
"} %sreg_parse_entry_t;\n"
"\n",
		prefix, prefix, prefix);
}

static void
aic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)
{
	if (dfile == NULL)
		return;

	fprintf(dfile,
"static %sreg_parse_entry_t %s_parse_table[] = {\n",
		prefix,
		regnode->symbol->name);
}

static void
aic_print_reg_dump_end(FILE *ofile, FILE *dfile,
		       symbol_node_t *regnode, u_int num_entries)
{
	char *lower_name;
	char *letter;

	lower_name = strdup(regnode->symbol->name);
	if (lower_name == NULL)
		 stop("Unable to strdup symbol name", EX_SOFTWARE);
	
	for (letter = lower_name; *letter != '\0'; letter++)
		*letter = tolower(*letter);

	if (dfile != NULL) {
		if (num_entries != 0)
			fprintf(dfile,
"\n"
"};\n"
"\n");

		fprintf(dfile,
"int\n"
"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"
"{\n"
"	return (%sprint_register(%s%s, %d, \"%s\",\n"
"	    0x%02x, regvalue, cur_col, wrap));\n"
"}\n"
"\n",
			prefix,
			lower_name,
			prefix,
			num_entries != 0 ? regnode->symbol->name : "NULL",
			num_entries != 0 ? "_parse_table" : "",
			num_entries,
			regnode->symbol->name,
			regnode->symbol->info.rinfo->address);
	}

	fprintf(ofile,
"#if AIC_DEBUG_REGISTERS\n"
"%sreg_print_t %s%s_print;\n"
"#else\n"
"#define %s%s_print(regvalue, cur_col, wrap) \\\n"
"    %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"
"#endif\n"
"\n",
		prefix,
		prefix,
		lower_name,
		prefix,
		lower_name,
		prefix,
		regnode->symbol->name,
		regnode->symbol->info.rinfo->address);
}

static void
aic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)
{
	int num_tabs;

	if (dfile == NULL)
		return;

	fprintf(dfile,
"	{ \"%s\",",
		curnode->symbol->name);

	num_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;

	while (num_tabs-- > 0)
		fputc('\t', dfile);
	fprintf(dfile, "0x%02x, 0x%02x }",
		curnode->symbol->info.finfo->value,
		curnode->symbol->info.finfo->mask);
}

void
symtable_dump(FILE *ofile, FILE *dfile)
{
	/*
	 * Sort the registers by address with a simple insertion sort.
	 * Put bitmasks next to the first register that defines them.
	 * Put constants at the end.
	 */
	symlist_t	 registers;
	symlist_t	 masks;
	symlist_t	 constants;
	symlist_t	 download_constants;
	symlist_t	 aliases;
	symlist_t	 exported_labels;
	symbol_node_t	*curnode;
	symbol_node_t	*regnode;
	DBT		 key;
	DBT		 data;
	int		 flag;
	u_int		 i;

	if (symtable == NULL)
		return;

	SLIST_INIT(&registers);
	SLIST_INIT(&masks);
	SLIST_INIT(&constants);
	SLIST_INIT(&download_constants);
	SLIST_INIT(&aliases);
	SLIST_INIT(&exported_labels);
	flag = R_FIRST;
	while (symtable->seq(symtable, &key, &data, flag) == 0) {
		symbol_t *cursym;

		memcpy(&cursym, data.data, sizeof(cursym));
		switch(cursym->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			symlist_add(&registers, cursym, SYMLIST_SORT);
			break;
		case MASK:
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			symlist_add(&masks, cursym, SYMLIST_SORT);
			break;
		case CONST:
			symlist_add(&constants, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case DOWNLOAD_CONST:
			symlist_add(&download_constants, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case ALIAS:
			symlist_add(&aliases, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case LABEL:
			if (cursym->info.linfo->exported == 0)
				break;
			symlist_add(&exported_labels, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		default:
			break;
		}
		flag = R_NEXT;
	}

	/* Register dianostic functions/declarations first. */
	aic_print_file_prologue(ofile);
	aic_print_reg_dump_types(ofile);
	aic_print_file_prologue(dfile);
	aic_print_include(dfile, stock_include_file);
	SLIST_FOREACH(curnode, &registers, links) {

		switch(curnode->symbol->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
		{
			symlist_t	*fields;
			symbol_node_t	*fieldnode;
			int		 num_entries;

			num_entries = 0;
			fields = &curnode->symbol->info.rinfo->fields;
			SLIST_FOREACH(fieldnode, fields, links) {
				if (num_entries == 0)
					aic_print_reg_dump_start(dfile,
								 curnode);
				else if (dfile != NULL)
					fputs(",\n", dfile);
				num_entries++;
				aic_print_reg_dump_entry(dfile, fieldnode);
			}
			aic_print_reg_dump_end(ofile, dfile,
					       curnode, num_entries);
		}
		default:
			break;
		}
	}

	/* Fold in the masks and bits */
	while (SLIST_FIRST(&masks) != NULL) {
		char *regname;

		curnode = SLIST_FIRST(&masks);
		SLIST_REMOVE_HEAD(&masks, links);

		regnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);
		regname = regnode->symbol->name;
		regnode = symlist_search(&registers, regname);
		SLIST_INSERT_AFTER(regnode, curnode, links);
	}

	/* Add the aliases */
	while (SLIST_FIRST(&aliases) != NULL) {
		char *regname;

		curnode = SLIST_FIRST(&aliases);
		SLIST_REMOVE_HEAD(&aliases, links);

		regname = curnode->symbol->info.ainfo->parent->name;
		regnode = symlist_search(&registers, regname);
		SLIST_INSERT_AFTER(regnode, curnode, links);
	}

	/* Output generated #defines. */
	while (SLIST_FIRST(&registers) != NULL) {
		symbol_node_t *curnode;
		u_int value;
		char *tab_str;
		char *tab_str2;

		curnode = SLIST_FIRST(&registers);
		SLIST_REMOVE_HEAD(&registers, links);
		switch(curnode->symbol->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			fprintf(ofile, "\n");
			value = curnode->symbol->info.rinfo->address;
			tab_str = "\t";
			tab_str2 = "\t\t";
			break;
		case ALIAS:
		{
			symbol_t *parent;

			parent = curnode->symbol->info.ainfo->parent;
			value = parent->info.rinfo->address;
			tab_str = "\t";
			tab_str2 = "\t\t";
			break;
		}
		case MASK:
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			value = curnode->symbol->info.finfo->value;
			tab_str = "\t\t";
			tab_str2 = "\t";
			break;
		default:
			value = 0; /* Quiet compiler */
			tab_str = NULL;
			tab_str2 = NULL;
			stop("symtable_dump: Invalid symbol type "
			     "encountered", EX_SOFTWARE);
			break;
		}
		fprintf(ofile, "#define%s%-16s%s0x%02x\n",
			tab_str, curnode->symbol->name, tab_str2,
			value);
		free(curnode);
	}
	fprintf(ofile, "\n\n");

	while (SLIST_FIRST(&constants) != NULL) {
		symbol_node_t *curnode;

		curnode = SLIST_FIRST(&constants);
		SLIST_REMOVE_HEAD(&constants, links);
		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.cinfo->value);
		free(curnode);
	}

	
	fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");

	for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
		symbol_node_t *curnode;

		curnode = SLIST_FIRST(&download_constants);
		SLIST_REMOVE_HEAD(&download_constants, links);
		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.cinfo->value);
		free(curnode);
	}
	fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);

	fprintf(ofile, "\n\n/* Exported Labels */\n");

	while (SLIST_FIRST(&exported_labels) != NULL) {
		symbol_node_t *curnode;

		curnode = SLIST_FIRST(&exported_labels);
		SLIST_REMOVE_HEAD(&exported_labels, links);
		fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.linfo->address);
		free(curnode);
	}
}

@


1.12
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.11 2012/12/05 23:20:19 deraadt Exp $ */
d99 1
a99 1
			free(symbol->info.rinfo, 0);
d103 1
a103 1
			free(symbol->info.ainfo, 0);
d111 1
a111 1
			free(symbol->info.finfo, 0);
d117 1
a117 1
			free(symbol->info.cinfo, 0);
d121 1
a121 1
			free(symbol->info.linfo, 0);
d127 2
a128 2
	free(symbol->name, 0);
	free(symbol, 0);
d302 1
a302 1
		free(node1, 0);
d635 1
a635 1
		free(curnode, 0);
d647 1
a647 1
		free(curnode, 0);
d661 1
a661 1
		free(curnode, 0);
d675 1
a675 1
		free(curnode, 0);
@


1.11
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.10 2009/10/28 23:22:45 schwarze Exp $ */
d99 1
a99 1
			free(symbol->info.rinfo);
d103 1
a103 1
			free(symbol->info.ainfo);
d111 1
a111 1
			free(symbol->info.finfo);
d117 1
a117 1
			free(symbol->info.cinfo);
d121 1
a121 1
			free(symbol->info.linfo);
d127 2
a128 2
	free(symbol->name);
	free(symbol);
d302 1
a302 1
		free(node1);
d635 1
a635 1
		free(curnode);
d647 1
a647 1
		free(curnode);
d661 1
a661 1
		free(curnode);
d675 1
a675 1
		free(curnode);
@


1.10
log
@a few leftovers from yesterday's SCCS/RCS-ID removal;
survived a full make build on i386;
"sure" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.9 2003/12/24 23:27:55 krw Exp $ */
a45 1
#include <sys/cdefs.h>
@


1.9
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.8 2003/10/20 17:22:13 deraadt Exp $ */
a46 2
/* __RCSID("$NetBSD: aicasm_symbol.c,v 1.4 2003/07/14 15:42:40 lukem Exp $"); */

@


1.8
log
@check strdup failure; nimadeus@@pandora.be
@
text
@d1 3
a3 1
/* $OpenBSD: aicasm_symbol.c,v 1.7 2003/08/28 02:24:04 krw Exp $ */
d8 1
d43 1
a43 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.17 2002/06/06 16:07:18 gibbs Exp $
d46 3
d51 3
d55 1
d57 1
d70 1
a70 2
symbol_create(name)
	char *name;
d80 3
a82 2
	if ((new_symbol->name = strdup(name)) == NULL)
		stop("strdup failed", EX_SOFTWARE);
d88 1
a88 2
symbol_delete(symbol)
	symbol_t *symbol;
d109 6
a114 4
	case BIT:
		if (symbol->info.minfo != NULL) {
			symlist_free(&symbol->info.minfo->symrefs);
			free(symbol->info.minfo);
d170 1
a170 2
symtable_get(name)
	char *name;
d209 1
a209 3
symlist_search(symlist, symname)
	symlist_t *symlist;
	char	  *symname;
d213 2
a214 1
	SLIST_FOREACH(curnode, symlist, links) {
d217 1
d223 1
a223 4
symlist_add(symlist, symbol, how)
	symlist_t *symlist;
	symbol_t  *symbol;
	int	  how;
d235 1
a235 1
		int mask;
d237 1
a237 1
		mask = FALSE;
d243 1
a243 1
		case BIT:
d245 3
a247 1
			mask = TRUE;
d257 6
a262 3
		 || (mask && (curnode->symbol->info.minfo->mask >
		              newnode->symbol->info.minfo->mask))
		 || (!mask && (curnode->symbol->info.rinfo->address >
d269 1
a269 1
			if (SLIST_NEXT(curnode, links) == SLIST_END(symlist)) {
d277 8
a284 4
				if ((mask && (cursymbol->info.minfo->mask >
				              symbol->info.minfo->mask))
				 || (!mask &&(cursymbol->info.rinfo->address >
				              symbol->info.rinfo->address))){
d298 1
a298 2
symlist_free(symlist)
	symlist_t *symlist;
d300 1
a300 1
	symbol_node_t *node;
d302 5
a306 4
	while (!SLIST_EMPTY(symlist)) {
		node = SLIST_FIRST(symlist);
		SLIST_REMOVE_HEAD(symlist, links);
		free(node);
d308 1
d312 2
a313 4
symlist_merge(symlist_dest, symlist_src1, symlist_src2)
	symlist_t *symlist_dest;
	symlist_t *symlist_src1;
	symlist_t *symlist_src2;
d329 133
a461 2
symtable_dump(ofile)
	FILE *ofile;
d468 15
a482 7
	symlist_t registers;
	symlist_t masks;
	symlist_t constants;
	symlist_t download_constants;
	symlist_t aliases;
	symlist_t exported_labels;
	u_int	  i;
d490 3
d494 36
a529 4
	if (symtable != NULL) {
		DBT	 key;
		DBT	 data;
		int	 flag = R_FIRST;
d531 6
a536 2
		while (symtable->seq(symtable, &key, &data, flag) == 0) {
			symbol_t *cursym;
d538 19
a556 31
			memcpy(&cursym, data.data, sizeof(cursym));
			switch(cursym->type) {
			case REGISTER:
			case SCBLOC:
			case SRAMLOC:
				symlist_add(&registers, cursym, SYMLIST_SORT);
				break;
			case MASK:
			case BIT:
				symlist_add(&masks, cursym, SYMLIST_SORT);
				break;
			case CONST:
				symlist_add(&constants, cursym,
						    SYMLIST_INSERT_HEAD);
				break;
			case DOWNLOAD_CONST:
				symlist_add(&download_constants, cursym,
					    SYMLIST_INSERT_HEAD);
				break;
			case ALIAS:
				symlist_add(&aliases, cursym,
					    SYMLIST_INSERT_HEAD);
				break;
			case LABEL:
				if (cursym->info.linfo->exported == 0)
					break;
				symlist_add(&exported_labels, cursym,
					    SYMLIST_INSERT_HEAD);
				break;
			default:
				break;
d558 2
a559 1
			flag = R_NEXT;
d561 4
d566 3
a568 5
		/* Put in the masks and bits */
		while (SLIST_FIRST(&masks) != SLIST_END(&masks)) {
			symbol_node_t *curnode;
			symbol_node_t *regnode;
			char *regname;
d570 8
a577 2
			curnode = SLIST_FIRST(&masks);
			SLIST_REMOVE_HEAD(&masks, links);
d579 39
a617 5
			regnode =
			    SLIST_FIRST(&curnode->symbol->info.minfo->symrefs);
			regname = regnode->symbol->name;
			regnode = symlist_search(&registers, regname);
			SLIST_INSERT_AFTER(regnode, curnode, links);
d619 22
d642 10
a651 5
		/* Add the aliases */
		while (SLIST_FIRST(&aliases) != SLIST_END(&aliases)) {
			symbol_node_t *curnode;
			symbol_node_t *regnode;
			char *regname;
d653 2
a654 2
			curnode = SLIST_FIRST(&aliases);
			SLIST_REMOVE_HEAD(&aliases, links);
d656 2
a657 4
			regname = curnode->symbol->info.ainfo->parent->name;
			regnode = symlist_search(&registers, regname);
			SLIST_INSERT_AFTER(regnode, curnode, links);
		}
d659 8
a666 65
		/* Output what we have */
		fprintf(ofile,
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);
                while (SLIST_FIRST(&registers) != SLIST_END(&registers)) {
			symbol_node_t *curnode;
			u_int value;
			char *tab_str;
			char *tab_str2;

			curnode = SLIST_FIRST(&registers);
			SLIST_REMOVE_HEAD(&registers, links);
			switch(curnode->symbol->type) {
			case REGISTER:
			case SCBLOC:
			case SRAMLOC:
				fprintf(ofile, "\n");
				value = curnode->symbol->info.rinfo->address;
				tab_str = "\t";
				tab_str2 = "\t\t";
				break;
			case ALIAS:
			{
				symbol_t *parent;

				parent = curnode->symbol->info.ainfo->parent;
				value = parent->info.rinfo->address;
				tab_str = "\t";
				tab_str2 = "\t\t";
				break;
			}
			case MASK:
			case BIT:
				value = curnode->symbol->info.minfo->mask;
				tab_str = "\t\t";
				tab_str2 = "\t";
				break;
			default:
				value = 0; /* Quiet compiler */
				tab_str = NULL;
				tab_str2 = NULL;
				stop("symtable_dump: Invalid symbol type "
				     "encountered", EX_SOFTWARE);
				break;
			}
			fprintf(ofile, "#define%s%-16s%s0x%02x\n",
				tab_str, curnode->symbol->name, tab_str2,
				value);
			free(curnode);
		}
		fprintf(ofile, "\n\n");

		while (SLIST_FIRST(&constants) != SLIST_END(&constants)) {
			symbol_node_t *curnode;

			curnode = SLIST_FIRST(&constants);
			SLIST_REMOVE_HEAD(&constants, links);
			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
				curnode->symbol->name,
				curnode->symbol->info.cinfo->value);
			free(curnode);
		}
d668 1
a668 2
		
		fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
d670 2
a671 2
		for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
			symbol_node_t *curnode;
d673 6
a678 22
			curnode = SLIST_FIRST(&download_constants);
			SLIST_REMOVE_HEAD(&download_constants, links);
			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
				curnode->symbol->name,
				curnode->symbol->info.cinfo->value);
			free(curnode);
		}
		fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);

		fprintf(ofile, "\n\n/* Exported Labels */\n");

		while (SLIST_FIRST(&exported_labels) !=
		    SLIST_END(&exported_labels)) {
			symbol_node_t *curnode;

			curnode = SLIST_FIRST(&exported_labels);
			SLIST_REMOVE_HEAD(&exported_labels, links);
			fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
				curnode->symbol->name,
				curnode->symbol->info.linfo->address);
			free(curnode);
		}
@


1.7
log
@Fix use of uninitialized variable by porting NetBSD patch to correctly
initialize it.

Said variable is used as the value of the define DOWNLOAD_CONST_COUNT
in the generated file aic7xxxreg.h.

This define is currently not used anywhere.

Spotted and ok mickey@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.6 2002/11/19 18:36:18 jason Exp $ */
d70 2
a71 1
	new_symbol->name = strdup(name);
@


1.6
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.5 2002/06/30 18:25:58 smurph Exp $ */
d477 1
a477 2
		while (SLIST_FIRST(&download_constants) !=
		    SLIST_END(&download_constants)) {
@


1.5
log
@New aicasm synced with FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.4 2002/06/28 00:34:55 smurph Exp $ */
d203 1
a203 2
	curnode = symlist->slh_first;
	while(curnode != NULL) {
a205 1
		curnode = curnode->links.sle_next;
d244 1
a244 1
		curnode = symlist->slh_first;
d255 1
a255 1
			if (curnode->links.sle_next == NULL) {
d262 1
a262 1
				cursymbol = curnode->links.sle_next->symbol;
d272 1
a272 1
			curnode = curnode->links.sle_next;
d283 1
a283 1
	symbol_node_t *node1, *node2;
d285 4
a288 5
	node1 = symlist->slh_first;
	while (node1 != NULL) {
		node2 = node1->links.sle_next;
		free(node1);
		node1 = node2;
a289 1
	SLIST_INIT(symlist);
d301 1
a301 1
	while((node = symlist_src2->slh_first) != NULL) {
d379 1
a379 1
		while (masks.slh_first != NULL) {
d384 1
a384 1
			curnode = masks.slh_first;
d388 1
a388 1
			    curnode->symbol->info.minfo->symrefs.slh_first;
d395 1
a395 1
		while (aliases.slh_first != NULL) {
d400 1
a400 1
			curnode = aliases.slh_first;
d415 1
a415 1
                while (registers.slh_first != NULL) {
d421 1
a421 1
			curnode = registers.slh_first;
d463 1
a463 1
		while (constants.slh_first != NULL) {
d466 1
a466 1
			curnode = constants.slh_first;
d477 2
a478 1
		while (download_constants.slh_first != NULL) {
d481 1
a481 1
			curnode = download_constants.slh_first;
d492 2
a493 1
		while (exported_labels.slh_first != NULL) {
d496 1
a496 1
			curnode = exported_labels.slh_first;
@


1.4
log
@Return of new ahc
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.3 2002/03/19 02:49:20 millert Exp $ */
d14 8
a21 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d24 2
a25 1
 * GNU Public License ("GPL").
d27 6
a32 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d35 4
a38 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d40 1
a40 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.14 2001/07/18 21:03:32 gibbs Exp $
d47 1
d329 2
d337 1
d359 1
a359 2
				if (cursym->info.cinfo->define == FALSE) {
					symlist_add(&constants, cursym,
a360 1
				}
d370 6
d414 5
a418 5
"/*
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
d421 1
a421 1
			u_int8_t value;
d491 14
d507 1
@


1.3
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.1 2000/03/22 02:50:49 smurph Exp $ */
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_symbol.c,v 1.8 1999/12/06 18:23:30 gibbs Exp $
a34 1

d399 5
a403 3
 * DO NOT EDIT - This file is automatically generated.
 */\n");
		while (registers.slh_first != NULL) {
a476 1

@


1.2
log
@New port of FreeBSD's ahc driver
@
text
@a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.14 2001/07/18 21:03:32 gibbs Exp $
d32 1
d397 3
a399 5
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
                while (registers.slh_first != NULL) {
d473 1
@


1.1
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_symbol.c,v 1.8 1999/12/06 18:23:30 gibbs Exp $
a34 1

d399 5
a403 3
 * DO NOT EDIT - This file is automatically generated.
 */\n");
		while (registers.slh_first != NULL) {
a476 1

@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.1 2000/03/22 02:50:49 smurph Exp $ */
@


1.1.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm_symbol.c,v 1.1.12.1 2002/06/11 03:42:22 art Exp $ */
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.17 2002/06/06 16:07:18 gibbs Exp $
d32 1
a36 1
#include <regex.h>
a317 2
	symlist_t exported_labels;
	u_int	  i;
a323 1
	SLIST_INIT(&exported_labels);
d345 2
a346 1
				symlist_add(&constants, cursym,
d348 1
a357 6
			case LABEL:
				if (cursym->info.linfo->exported == 0)
					break;
				symlist_add(&exported_labels, cursym,
					    SYMLIST_INSERT_HEAD);
				break;
d396 4
a399 6
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);
                while (registers.slh_first != NULL) {
d401 1
a401 1
			u_int value;
a468 14
			free(curnode);
		}
		fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);

		fprintf(ofile, "\n\n/* Exported Labels */\n");

		while (exported_labels.slh_first != NULL) {
			symbol_node_t *curnode;

			curnode = exported_labels.slh_first;
			SLIST_REMOVE_HEAD(&exported_labels, links);
			fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
				curnode->symbol->name,
				curnode->symbol->info.linfo->address);
@


1.1.12.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d203 2
a204 1
	SLIST_FOREACH(curnode, symlist, links) {
d207 1
d246 1
a246 1
		curnode = SLIST_FIRST(symlist);
d257 1
a257 1
			if (SLIST_NEXT(curnode, links) == SLIST_END(symlist)) {
d264 1
a264 1
				cursymbol = SLIST_NEXT(curnode, links)->symbol;
d274 1
a274 1
			curnode = SLIST_NEXT(curnode, links);
d285 1
a285 1
	symbol_node_t *node;
d287 5
a291 4
	while (!SLIST_EMPTY(symlist)) {
		node = SLIST_FIRST(symlist);
		SLIST_REMOVE_HEAD(symlist, links);
		free(node);
d293 1
d305 1
a305 1
	while((node = SLIST_FIRST(symlist_src2)) != NULL) {
d383 1
a383 1
		while (SLIST_FIRST(&masks) != SLIST_END(&masks)) {
d388 1
a388 1
			curnode = SLIST_FIRST(&masks);
d392 1
a392 1
			    SLIST_FIRST(&curnode->symbol->info.minfo->symrefs);
d399 1
a399 1
		while (SLIST_FIRST(&aliases) != SLIST_END(&aliases)) {
d404 1
a404 1
			curnode = SLIST_FIRST(&aliases);
d419 1
a419 1
                while (SLIST_FIRST(&registers) != SLIST_END(&registers)) {
d425 1
a425 1
			curnode = SLIST_FIRST(&registers);
d467 1
a467 1
		while (SLIST_FIRST(&constants) != SLIST_END(&constants)) {
d470 1
a470 1
			curnode = SLIST_FIRST(&constants);
d481 1
a481 2
		while (SLIST_FIRST(&download_constants) !=
		    SLIST_END(&download_constants)) {
d484 1
a484 1
			curnode = SLIST_FIRST(&download_constants);
d495 1
a495 2
		while (SLIST_FIRST(&exported_labels) !=
		    SLIST_END(&exported_labels)) {
d498 1
a498 1
			curnode = SLIST_FIRST(&exported_labels);
@


1.1.2.1
log
@Sync with -current
@
text
@@


1.1.2.2
log
@Merge in trunk
@
text
@a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.14 2001/07/18 21:03:32 gibbs Exp $
d32 1
d397 3
a399 5
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
                while (registers.slh_first != NULL) {
d473 1
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_symbol.c,v 1.8 1999/12/06 18:23:30 gibbs Exp $
a34 1

d399 5
a403 3
 * DO NOT EDIT - This file is automatically generated.
 */\n");
		while (registers.slh_first != NULL) {
a476 1

@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.17 2002/06/06 16:07:18 gibbs Exp $
d32 1
a36 1
#include <regex.h>
d192 2
a193 1
	SLIST_FOREACH(curnode, symlist, links) {
d196 1
d235 1
a235 1
		curnode = SLIST_FIRST(symlist);
d246 1
a246 1
			if (SLIST_NEXT(curnode, links) == SLIST_END(symlist)) {
d253 1
a253 1
				cursymbol = SLIST_NEXT(curnode, links)->symbol;
d263 1
a263 1
			curnode = SLIST_NEXT(curnode, links);
d274 1
a274 1
	symbol_node_t *node;
d276 5
a280 4
	while (!SLIST_EMPTY(symlist)) {
		node = SLIST_FIRST(symlist);
		SLIST_REMOVE_HEAD(symlist, links);
		free(node);
d282 1
d294 1
a294 1
	while((node = SLIST_FIRST(symlist_src2)) != NULL) {
a317 2
	symlist_t exported_labels;
	u_int	  i;
a323 1
	SLIST_INIT(&exported_labels);
d345 2
a346 1
				symlist_add(&constants, cursym,
d348 1
a357 6
			case LABEL:
				if (cursym->info.linfo->exported == 0)
					break;
				symlist_add(&exported_labels, cursym,
					    SYMLIST_INSERT_HEAD);
				break;
d365 1
a365 1
		while (SLIST_FIRST(&masks) != SLIST_END(&masks)) {
d370 1
a370 1
			curnode = SLIST_FIRST(&masks);
d374 1
a374 1
			    SLIST_FIRST(&curnode->symbol->info.minfo->symrefs);
d381 1
a381 1
		while (SLIST_FIRST(&aliases) != SLIST_END(&aliases)) {
d386 1
a386 1
			curnode = SLIST_FIRST(&aliases);
d396 4
a399 6
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);
                while (SLIST_FIRST(&registers) != SLIST_END(&registers)) {
d401 1
a401 1
			u_int value;
d405 1
a405 1
			curnode = SLIST_FIRST(&registers);
d447 1
a447 1
		while (SLIST_FIRST(&constants) != SLIST_END(&constants)) {
d450 1
a450 1
			curnode = SLIST_FIRST(&constants);
d461 1
a461 2
		while (SLIST_FIRST(&download_constants) !=
		    SLIST_END(&download_constants)) {
d464 1
a464 1
			curnode = SLIST_FIRST(&download_constants);
a468 15
			free(curnode);
		}
		fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);

		fprintf(ofile, "\n\n/* Exported Labels */\n");

		while (SLIST_FIRST(&exported_labels) !=
		    SLIST_END(&exported_labels)) {
			symbol_node_t *curnode;

			curnode = SLIST_FIRST(&exported_labels);
			SLIST_REMOVE_HEAD(&exported_labels, links);
			fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
				curnode->symbol->name,
				curnode->symbol->info.linfo->address);
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a1 2
/*	$NetBSD: aicasm_symbol.c,v 1.4 2003/07/14 15:42:40 lukem Exp $	*/

a5 1
 * Copyright (c) 2002 Adaptec Inc.
d40 1
a40 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.23 2003/01/20 18:01:37 gibbs Exp $
a42 3
#include <sys/cdefs.h>
/* __RCSID("$NetBSD: aicasm_symbol.c,v 1.4 2003/07/14 15:42:40 lukem Exp $"); */

a44 3
#ifdef __linux__
#include "aicdb.h"
#else
a45 1
#endif
a46 1
#include <inttypes.h>
d59 2
a60 1
symbol_create(char *name)
a70 2
	if (new_symbol->name == NULL)
		 stop("Unable to strdup symbol name", EX_SOFTWARE);
d76 2
a77 1
symbol_delete(symbol_t *symbol)
d98 4
a101 6
	case FIELD:
	case ENUM:
	case ENUM_ENTRY:
		if (symbol->info.finfo != NULL) {
			symlist_free(&symbol->info.finfo->symrefs);
			free(symbol->info.finfo);
d157 2
a158 1
symtable_get(char *name)
d197 3
a199 1
symlist_search(symlist_t *symlist, char *symname)
d203 1
a203 2
	curnode = SLIST_FIRST(symlist);
	while(curnode != NULL) {
a205 1
		curnode = SLIST_NEXT(curnode, links);
d211 4
a214 1
symlist_add(symlist_t *symlist, symbol_t *symbol, int how)
d226 1
a226 1
		int field;
d228 1
a228 1
		field = FALSE;
d234 1
a234 1
		case FIELD:
d236 1
a236 3
		case ENUM:
		case ENUM_ENTRY:
			field = TRUE;
d246 3
a248 6
		 || (field
		  && (curnode->symbol->type > newnode->symbol->type
		   || (curnode->symbol->type == newnode->symbol->type
		    && (curnode->symbol->info.finfo->value >
			newnode->symbol->info.finfo->value))))
		 || (!field && (curnode->symbol->info.rinfo->address >
d255 1
a255 1
			if (SLIST_NEXT(curnode, links) == NULL) {
d263 4
a266 8
				if ((field
		  		  && (cursymbol->type > symbol->type
				   || (cursymbol->type == symbol->type
				    && (cursymbol->info.finfo->value >
					symbol->info.finfo->value))))
				 || (!field
				   && (cursymbol->info.rinfo->address >
				       symbol->info.rinfo->address))) {
d280 2
a281 1
symlist_free(symlist_t *symlist)
d283 1
a283 1
	symbol_node_t *node1, *node2;
d285 4
a288 5
	node1 = SLIST_FIRST(symlist);
	while (node1 != NULL) {
		node2 = SLIST_NEXT(node1, links);
		free(node1);
		node1 = node2;
a289 1
	SLIST_INIT(symlist);
d293 4
a296 2
symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
	      symlist_t *symlist_src2)
d312 2
a313 133
aic_print_file_prologue(FILE *ofile)
{

	if (ofile == NULL)
		return;

	fprintf(ofile,
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n",
		versions);
}

void
aic_print_include(FILE *dfile, char *include_file)
{

	if (dfile == NULL)
		return;
	fprintf(dfile, "\n#include \"%s\"\n\n", include_file);
}

void
aic_print_reg_dump_types(FILE *ofile)
{
	if (ofile == NULL)
		return;
		
	fprintf(ofile,
"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"
"typedef struct %sreg_parse_entry {\n"
"	char	*name;\n"
"	uint8_t	 value;\n"
"	uint8_t	 mask;\n"
"} %sreg_parse_entry_t;\n"
"\n",
		prefix, prefix, prefix);
}

static void
aic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)
{
	if (dfile == NULL)
		return;

	fprintf(dfile,
"static %sreg_parse_entry_t %s_parse_table[] = {\n",
		prefix,
		regnode->symbol->name);
}

static void
aic_print_reg_dump_end(FILE *ofile, FILE *dfile,
		       symbol_node_t *regnode, u_int num_entries)
{
	char *lower_name;
	char *letter;

	lower_name = strdup(regnode->symbol->name);
	if (lower_name == NULL)
		 stop("Unable to strdup symbol name", EX_SOFTWARE);
	
	for (letter = lower_name; *letter != '\0'; letter++)
		*letter = tolower(*letter);

	if (dfile != NULL) {
		if (num_entries != 0)
			fprintf(dfile,
"\n"
"};\n"
"\n");

		fprintf(dfile,
"int\n"
"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"
"{\n"
"	return (%sprint_register(%s%s, %d, \"%s\",\n"
"	    0x%02x, regvalue, cur_col, wrap));\n"
"}\n"
"\n",
			prefix,
			lower_name,
			prefix,
			num_entries != 0 ? regnode->symbol->name : "NULL",
			num_entries != 0 ? "_parse_table" : "",
			num_entries,
			regnode->symbol->name,
			regnode->symbol->info.rinfo->address);
	}

	fprintf(ofile,
"#if AIC_DEBUG_REGISTERS\n"
"%sreg_print_t %s%s_print;\n"
"#else\n"
"#define %s%s_print(regvalue, cur_col, wrap) \\\n"
"    %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"
"#endif\n"
"\n",
		prefix,
		prefix,
		lower_name,
		prefix,
		lower_name,
		prefix,
		regnode->symbol->name,
		regnode->symbol->info.rinfo->address);
}

static void
aic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)
{
	int num_tabs;

	if (dfile == NULL)
		return;

	fprintf(dfile,
"	{ \"%s\",",
		curnode->symbol->name);

	num_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;

	while (num_tabs-- > 0)
		fputc('\t', dfile);
	fprintf(dfile, "0x%02x, 0x%02x }",
		curnode->symbol->info.finfo->value,
		curnode->symbol->info.finfo->mask);
}

void
symtable_dump(FILE *ofile, FILE *dfile)
d320 7
a326 15
	symlist_t	 registers;
	symlist_t	 masks;
	symlist_t	 constants;
	symlist_t	 download_constants;
	symlist_t	 aliases;
	symlist_t	 exported_labels;
	symbol_node_t	*curnode;
	symbol_node_t	*regnode;
	DBT		 key;
	DBT		 data;
	int		 flag;
	u_int		 i;

	if (symtable == NULL)
		return;
a333 3
	flag = R_FIRST;
	while (symtable->seq(symtable, &key, &data, flag) == 0) {
		symbol_t *cursym;
d335 4
a338 36
		memcpy(&cursym, data.data, sizeof(cursym));
		switch(cursym->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			symlist_add(&registers, cursym, SYMLIST_SORT);
			break;
		case MASK:
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			symlist_add(&masks, cursym, SYMLIST_SORT);
			break;
		case CONST:
			symlist_add(&constants, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case DOWNLOAD_CONST:
			symlist_add(&download_constants, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case ALIAS:
			symlist_add(&aliases, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		case LABEL:
			if (cursym->info.linfo->exported == 0)
				break;
			symlist_add(&exported_labels, cursym,
				    SYMLIST_INSERT_HEAD);
			break;
		default:
			break;
		}
		flag = R_NEXT;
	}
d340 2
a341 6
	/* Register dianostic functions/declarations first. */
	aic_print_file_prologue(ofile);
	aic_print_reg_dump_types(ofile);
	aic_print_file_prologue(dfile);
	aic_print_include(dfile, stock_include_file);
	SLIST_FOREACH(curnode, &registers, links) {
d343 31
a373 19
		switch(curnode->symbol->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
		{
			symlist_t	*fields;
			symbol_node_t	*fieldnode;
			int		 num_entries;

			num_entries = 0;
			fields = &curnode->symbol->info.rinfo->fields;
			SLIST_FOREACH(fieldnode, fields, links) {
				if (num_entries == 0)
					aic_print_reg_dump_start(dfile,
								 curnode);
				else if (dfile != NULL)
					fputs(",\n", dfile);
				num_entries++;
				aic_print_reg_dump_entry(dfile, fieldnode);
d375 1
a375 5
			aic_print_reg_dump_end(ofile, dfile,
					       curnode, num_entries);
		}
		default:
			break;
a376 1
	}
d378 5
a382 3
	/* Fold in the masks and bits */
	while (SLIST_FIRST(&masks) != NULL) {
		char *regname;
d384 2
a385 2
		curnode = SLIST_FIRST(&masks);
		SLIST_REMOVE_HEAD(&masks, links);
d387 6
a392 5
		regnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);
		regname = regnode->symbol->name;
		regnode = symlist_search(&registers, regname);
		SLIST_INSERT_AFTER(regnode, curnode, links);
	}
d394 5
a398 3
	/* Add the aliases */
	while (SLIST_FIRST(&aliases) != NULL) {
		char *regname;
d400 2
a401 2
		curnode = SLIST_FIRST(&aliases);
		SLIST_REMOVE_HEAD(&aliases, links);
d403 4
a406 4
		regname = curnode->symbol->info.ainfo->parent->name;
		regnode = symlist_search(&registers, regname);
		SLIST_INSERT_AFTER(regnode, curnode, links);
	}
d408 64
a471 27
	/* Output generated #defines. */
	while (SLIST_FIRST(&registers) != NULL) {
		symbol_node_t *curnode;
		u_int value;
		char *tab_str;
		char *tab_str2;

		curnode = SLIST_FIRST(&registers);
		SLIST_REMOVE_HEAD(&registers, links);
		switch(curnode->symbol->type) {
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			fprintf(ofile, "\n");
			value = curnode->symbol->info.rinfo->address;
			tab_str = "\t";
			tab_str2 = "\t\t";
			break;
		case ALIAS:
		{
			symbol_t *parent;

			parent = curnode->symbol->info.ainfo->parent;
			value = parent->info.rinfo->address;
			tab_str = "\t";
			tab_str2 = "\t\t";
			break;
a472 22
		case MASK:
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			value = curnode->symbol->info.finfo->value;
			tab_str = "\t\t";
			tab_str2 = "\t";
			break;
		default:
			value = 0; /* Quiet compiler */
			tab_str = NULL;
			tab_str2 = NULL;
			stop("symtable_dump: Invalid symbol type "
			     "encountered", EX_SOFTWARE);
			break;
		}
		fprintf(ofile, "#define%s%-16s%s0x%02x\n",
			tab_str, curnode->symbol->name, tab_str2,
			value);
		free(curnode);
	}
	fprintf(ofile, "\n\n");
d474 2
a475 2
	while (SLIST_FIRST(&constants) != NULL) {
		symbol_node_t *curnode;
d477 26
a502 34
		curnode = SLIST_FIRST(&constants);
		SLIST_REMOVE_HEAD(&constants, links);
		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.cinfo->value);
		free(curnode);
	}

	
	fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");

	for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
		symbol_node_t *curnode;

		curnode = SLIST_FIRST(&download_constants);
		SLIST_REMOVE_HEAD(&download_constants, links);
		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.cinfo->value);
		free(curnode);
	}
	fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);

	fprintf(ofile, "\n\n/* Exported Labels */\n");

	while (SLIST_FIRST(&exported_labels) != NULL) {
		symbol_node_t *curnode;

		curnode = SLIST_FIRST(&exported_labels);
		SLIST_REMOVE_HEAD(&exported_labels, links);
		fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
			curnode->symbol->name,
			curnode->symbol->info.linfo->address);
		free(curnode);
@


