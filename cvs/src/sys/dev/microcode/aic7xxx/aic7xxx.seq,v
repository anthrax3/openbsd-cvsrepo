head	1.22;
access;
symbols
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.40
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.36
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.26
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.34
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.32
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.30
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.28
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.24
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.22
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.20
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.18
	OPENBSD_5_0:1.22.0.16
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.14
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.12
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.8
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.10
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.6
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.13.0.6
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.13
	UBC:1.8.0.10
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.8
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.6
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.14
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.12
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.22
date	2007.11.24.12.59.28;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.07.00.05.01;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.08.00.38.09;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.24.22.40.16;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.05.05.41.03;	author smurph;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.28.00.34.55;	author smurph;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.04.03.48.47;	author smurph;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	96.12.03.11.28.32;	author niklas;	state Exp;
branches
	1.6.14.1;
next	1.5;

1.5
date	96.11.28.23.27.59;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.27.21.15.52;	author shawn;	state Exp;
branches;
next	1.3;

1.3
date	96.05.26.00.27.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.12.42.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches;
next	;

1.6.14.1
date	2000.03.24.09.09.13;	author niklas;	state Exp;
branches;
next	1.6.14.2;

1.6.14.2
date	2001.05.14.22.24.58;	author niklas;	state Exp;
branches;
next	1.6.14.3;

1.6.14.3
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.6.14.4;

1.6.14.4
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.6.14.5;

1.6.14.5
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.6.14.6;

1.6.14.6
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	1.6.14.7;

1.6.14.7
date	2004.06.05.23.12.47;	author niklas;	state Exp;
branches;
next	;

1.8.10.1
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@some spelling fixes from Martynas Venckus
@
text
@/* $OpenBSD: aic7xxx.seq,v 1.21 2007/05/26 00:36:03 krw Exp $ */
/*-
 * Adaptec 274x/284x/294x device driver firmware for Linux and FreeBSD.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.128 2005/01/06 01:42:26 imp Exp $
 */

VERSION = "$Id: aic7xxx.seq,v 1.21 2007/05/26 00:36:03 krw Exp $"
PATCH_ARG_LIST = "struct ahc_softc *ahc"
PREFIX = "ahc_"

#include <dev/microcode/aic7xxx/aic7xxx.reg>
#include <scsi/scsi_message.h>

/*
 * A few words on the waiting SCB list:
 * After starting the selection hardware, we check for reconnecting targets
 * as well as for our selection to complete just in case the reselection wins
 * bus arbitration.  The problem with this is that we must keep track of the
 * SCB that we've already pulled from the QINFIFO and started the selection
 * on just in case the reselection wins so that we can retry the selection at
 * a later time.  This problem cannot be resolved by holding a single entry
 * in scratch ram since a reconnecting target can request sense and this will
 * create yet another SCB waiting for selection.  The solution used here is to 
 * use byte 27 of the SCB as a psuedo-next pointer and to thread a list
 * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, 
 * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to
 * this list everytime a request sense occurs or after completing a non-tagged
 * command for which a second SCB has been queued.  The sequencer will
 * automatically consume the entries.
 */

bus_free_sel:
	/*
	 * Turn off the selection hardware.  We need to reset the
	 * selection request in order to perform a new selection.
	 */
	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP;
	and	SIMODE1, ~ENBUSFREE;
poll_for_work:
	call	clear_target_state;
	and	SXFRCTL0, ~SPIOEN;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		clr	SCSIBUSL;
	}
	test	SCSISEQ, ENSELO	jnz poll_for_selection;
	if ((ahc->features & AHC_TWIN) != 0) {
		xor	SBLKCTL,SELBUSB;	/* Toggle to the other bus */
		test	SCSISEQ, ENSELO		jnz poll_for_selection;
	}
BEGIN_CRITICAL;
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
END_CRITICAL;
poll_for_work_loop:
	if ((ahc->features & AHC_TWIN) != 0) {
		xor	SBLKCTL,SELBUSB;	/* Toggle to the other bus */
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
test_queue:
	/* Has the driver posted any work for us? */
BEGIN_CRITICAL;
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		test	QOFF_CTLSTA, SCB_AVAIL jz poll_for_work_loop;
	} else {
		mov	A, QINPOS;
		cmp	KERNEL_QINPOS, A je poll_for_work_loop;
	}
	mov	ARG_1, NEXT_QUEUED_SCB;

	/*
	 * We have at least one queued SCB now and we don't have any 
	 * SCBs in the list of SCBs awaiting selection.  Allocate a
	 * card SCB for the host's SCB and get to work on it.
	 */
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mov	ALLZEROS	call	get_free_or_disc_scb;
	} else {
		/* In the non-paging case, the SCBID == hardware SCB index */
		mov	SCBPTR, ARG_1;
	}
	or	SEQ_FLAGS2, SCB_DMA;
END_CRITICAL;
dma_queued_scb:
	/*
	 * DMA the SCB from host ram into the current SCB location.
	 */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	ARG_1	call dma_scb;
	/*
	 * Check one last time to see if this SCB was canceled
	 * before we completed the DMA operation.  If it was,
	 * the QINFIFO next pointer will not match our saved
	 * value.
	 */
	mov	A, ARG_1;
BEGIN_CRITICAL;
	cmp	NEXT_QUEUED_SCB, A jne abort_qinscb;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		cmp	SCB_TAG, A je . + 2;
		mvi	SCB_MISMATCH call set_seqint;
	}
	mov	NEXT_QUEUED_SCB, SCB_NEXT;
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		mov	NONE, SNSCB_QOFF;
	} else {
		inc	QINPOS;
	}
	and	SEQ_FLAGS2, ~SCB_DMA;
start_waiting:
	/*
	 * Start the first entry on the waiting SCB list.
	 */
	mov	SCBPTR, WAITING_SCBH;
	call	start_selection;
END_CRITICAL;

poll_for_selection:
	/*
	 * Twin channel devices cannot handle things like SELTO
	 * interrupts on the "background" channel.  So, while
	 * selecting, keep polling the current channel until
	 * either a selection or reselection occurs.
	 */
	test	SSTAT0, SELDO|SELDI	jz poll_for_selection;

selection:
	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	if ((ahc->features & AHC_DT) == 0) {
		or	SIMODE1, ENBUSFREE;
	}

	/*
	 * Guard against a bus free after (re)selection
	 * but prior to enabling the busfree interrupt.  SELDI
	 * and SELDO will be cleared in that case.
	 */
	test	SSTAT0, SELDI|SELDO	jz bus_free_sel;
	test	SSTAT0,SELDO	jnz select_out;
select_in:
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		if ((ahc->flags & AHC_INITIATORROLE) != 0) {
			test	SSTAT0, TARGET	jz initiator_reselect;
		}
		mvi	CLRSINT0, CLRSELDI;

		/*
		 * We've just been selected.  Assert BSY and
		 * setup the phase for receiving messages
		 * from the target.
		 */
		mvi	SCSISIGO, P_MESGOUT|BSYO;

		/*
		 * Setup the DMA for sending the identify and
		 * command information.
		 */
		mvi	SEQ_FLAGS, CMDPHASE_PENDING;

		mov     A, TQINPOS;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	DINDEX, CCHADDR;
			mvi	SHARED_DATA_ADDR call set_32byte_addr;
			mvi	CCSCBCTL, CCSCBRESET;
		} else {
			mvi	DINDEX, HADDR;
			mvi	SHARED_DATA_ADDR call set_32byte_addr;
			mvi	DFCNTRL, FIFORESET;
		}

		/* Initiator that selected us */
		and	SAVED_SCSIID, SELID_MASK, SELID;
		/* The Target ID we were selected at */
		if ((ahc->features & AHC_MULTI_TID) != 0) {
			and	A, OID, TARGIDIN;
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			and	A, OID, SCSIID_ULTRA2;
		} else {
			and	A, OID, SCSIID;
		}
		or	SAVED_SCSIID, A;
		if ((ahc->features & AHC_TWIN) != 0) {
			test 	SBLKCTL, SELBUSB jz . + 2;
			or	SAVED_SCSIID, TWIN_CHNLB;
		}
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_SCSIID;
		} else {
			mov	DFDAT, SAVED_SCSIID;
		}

		/*
		 * If ATN isn't asserted, the target isn't interested
		 * in talking to us.  Go directly to bus free.
		 * XXX SCSI-1 may require us to assume lun 0 if
		 * ATN is false.
		 */
		test	SCSISIGI, ATNI	jz	target_busfree;

		/*
		 * Watch ATN closely now as we pull in messages from the
		 * initiator.  We follow the guidlines from section 6.5
		 * of the SCSI-2 spec for what messages are allowed when.
		 */
		call	target_inb;

		/*
		 * Our first message must be one of IDENTIFY, ABORT, or
		 * BUS_DEVICE_RESET.
		 */
		test	DINDEX, MSG_IDENTIFYFLAG jz host_target_message_loop;
		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}
		and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, DINDEX;

		/* Remember for disconnection decision */
		test	DINDEX, MSG_IDENTIFY_DISCFLAG jnz . + 2;
		/* XXX Honor per target settings too */
		or	SEQ_FLAGS, NO_DISCONNECT;

		test	SCSISIGI, ATNI	jz	ident_messages_done;
		call	target_inb;
		/*
		 * If this is a tagged request, the tagged message must
		 * immediately follow the identify.  We test for a valid
		 * tag message by seeing if it is >= MSG_SIMPLE_Q_TAG and
		 * < MSG_IGN_WIDE_RESIDUE.
		 */
		add	A, -MSG_SIMPLE_Q_TAG, DINDEX;
		jnc	ident_messages_done_msg_pending;
		add	A, -MSG_IGN_WIDE_RESIDUE, DINDEX;
		jc	ident_messages_done_msg_pending;

		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}
		
		/*
		 * If the initiator doesn't feel like providing a tag number,
		 * we've got a failed selection and must transition to bus
		 * free.
		 */
		test	SCSISIGI, ATNI	jz	target_busfree;

		/*
		 * Store the tag for the host.
		 */
		call	target_inb;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}
		mov	INITIATOR_TAG, DINDEX;
		or	SEQ_FLAGS, TARGET_CMD_IS_TAGGED;

ident_messages_done:
		/* Terminate the ident list */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	CCSCBRAM, SCB_LIST_NULL;
		} else {
			mvi	DFDAT, SCB_LIST_NULL;
		}
		or	SEQ_FLAGS, TARG_CMD_PENDING;
		test	SEQ_FLAGS2, TARGET_MSG_PENDING
			jnz target_mesgout_pending;
		test	SCSISIGI, ATNI jnz target_mesgout_continue;
		jmp	target_ITloop;


ident_messages_done_msg_pending:
		or	SEQ_FLAGS2, TARGET_MSG_PENDING;
		jmp	ident_messages_done;

		/*
		 * Pushed message loop to allow the kernel to
		 * run its own target mode message state engine.
		 */
host_target_message_loop:
		mvi	HOST_MSG_LOOP call set_seqint;
		cmp	RETURN_1, EXIT_MSG_LOOP	je target_ITloop;
		test	SSTAT0, SPIORDY jz .;
		jmp	host_target_message_loop;
	}

if ((ahc->flags & AHC_INITIATORROLE) != 0) {
/*
 * Reselection has been initiated by a target. Make a note that we've been
 * reselected, but haven't seen an IDENTIFY message from the target yet.
 */
initiator_reselect:
	/* XXX test for and handle ONE BIT condition */
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	and	SAVED_SCSIID, SELID_MASK, SELID;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, OID, SCSIID_ULTRA2;
	} else {
		and	A, OID, SCSIID;
	}
	or	SAVED_SCSIID, A;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_SCSIID, TWIN_CHNLB;
	}
	mvi	CLRSINT0, CLRSELDI;
	jmp	ITloop;
}

abort_qinscb:
	call	add_scb_to_free_list;
	jmp	poll_for_work_loop;

BEGIN_CRITICAL;
start_selection:
	/*
	 * If bus reset interrupts have been disabled (from a previous
	 * reset), re-enable them now.  Resets are only of interest
	 * when we have outstanding transactions, so we can safely
	 * defer re-enabling the interrupt until, as an initiator,
	 * we start sending out transactions again.
	 */
	test	SIMODE1, ENSCSIRST	jnz . + 3;
	mvi	CLRSINT1, CLRSCSIRSTI;
	or	SIMODE1, ENSCSIRST;
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		test	SCB_SCSIID, TWIN_CHNLB jz . + 2;
		or	SINDEX, SELBUSB;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
initialize_scsiid:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SCSIID_ULTRA2, SCB_SCSIID;
	} else if ((ahc->features & AHC_TWIN) != 0) {
		and	SCSIID, TWIN_TID|OID, SCB_SCSIID;
	} else {
		mov	SCSIID, SCB_SCSIID;
	}
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		mov	SINDEX, SCSISEQ_TEMPLATE;
		test	SCB_CONTROL, TARGET_SCB jz . + 2;
		or	SINDEX, TEMODE;
		mov	SCSISEQ, SINDEX ret;
	} else {
		mov	SCSISEQ, SCSISEQ_TEMPLATE ret;
	}
END_CRITICAL;

/*
 * Initialize transfer settings with SCB provided settings.
 */
set_transfer_settings:
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
	/*
	 * Initialize SCSIRATE with the appropriate value for this target.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
	/*
	 * Drive REQ on the bus by enabling SCSI PIO.
	 */
	or	SXFRCTL0, SPIOEN;
	/* Wait for the byte */
	test	SSTAT0, SPIORDY jz .;
	/* Prevent our read from triggering another REQ */
	and	SXFRCTL0, ~SPIOEN;
	/* Save latched contents */
	mov	DINDEX, SCSIDATL ret;
}

/*
 * After the selection, remove this SCB from the "waiting SCB"
 * list.  This is achieved by simply moving our "next" pointer into
 * WAITING_SCBH.  Our next pointer will be set to null the next time this
 * SCB is used, so don't bother with it now.
 */
select_out:
	/* Turn off the selection hardware */
	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
	mov	SCBPTR, WAITING_SCBH;
	mov	WAITING_SCBH,SCB_NEXT;
	mov	SAVED_SCSIID, SCB_SCSIID;
	and	SAVED_LUN, LID, SCB_LUN;
	call	set_transfer_settings;
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		test	SSTAT0, TARGET	jz initiator_select;

		or	SXFRCTL0, CLRSTCNT|CLRCHN;

		/*
		 * Put tag in connonical location since not
		 * all connections have an SCB.
		 */
		mov	INITIATOR_TAG, SCB_TARGET_ITAG;

		/*
		 * We've just re-selected an initiator.
		 * Assert BSY and setup the phase for
		 * sending our identify messages.
		 */
		mvi	P_MESGIN|BSYO call change_phase;
		mvi	CLRSINT0, CLRSELDO;

		/*
		 * Start out with a simple identify message.
		 */
		or	SAVED_LUN, MSG_IDENTIFYFLAG call target_outb;

		/*
		 * If we are the result of a tagged command, send
		 * a simple Q tag and the tag id.
		 */
		test	SCB_CONTROL, TAG_ENB	jz . + 3;
		mvi	MSG_SIMPLE_Q_TAG call target_outb;
		mov	SCB_TARGET_ITAG call target_outb;
target_synccmd:
		/*
		 * Now determine what phases the host wants us
		 * to go through.
		 */
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
		
		test	SCB_CONTROL, MK_MESSAGE	jz target_ITloop;
		mvi	P_MESGIN|BSYO call change_phase;
		jmp	host_target_message_loop;
target_ITloop:
		/*
		 * Start honoring ATN signals now that
		 * we properly identified ourselves.
		 */
		test	SCSISIGI, ATNI			jnz target_mesgout;
		test	SEQ_FLAGS, CMDPHASE_PENDING	jnz target_cmdphase;
		test	SEQ_FLAGS, DPHASE_PENDING	jnz target_dphase;
		test	SEQ_FLAGS, SPHASE_PENDING	jnz target_sphase;

		/*
		 * No more work to do.  Either disconnect or not depending
		 * on the state of NO_DISCONNECT.
		 */
		test	SEQ_FLAGS, NO_DISCONNECT jz target_disconnect; 
		mvi	TARG_IMMEDIATE_SCB, SCB_LIST_NULL;
		call	complete_target_cmd;
		if ((ahc->flags & AHC_PAGESCBS) != 0) {
			mov	ALLZEROS	call	get_free_or_disc_scb;
		}
		cmp	TARG_IMMEDIATE_SCB, SCB_LIST_NULL je .;
		mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
		mov	TARG_IMMEDIATE_SCB call dma_scb;
		call	set_transfer_settings;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
		jmp	target_synccmd;

target_mesgout:
		mvi	SCSISIGO, P_MESGOUT|BSYO;
target_mesgout_continue:
		call	target_inb;
target_mesgout_pending:
		and	SEQ_FLAGS2, ~TARGET_MSG_PENDING;
		/* Local Processing goes here... */
		jmp	host_target_message_loop;
		
target_disconnect:
		mvi	P_MESGIN|BSYO call change_phase;
		test	SEQ_FLAGS, DPHASE	jz . + 2;
		mvi	MSG_SAVEDATAPOINTER call target_outb;
		mvi	MSG_DISCONNECT call target_outb;

target_busfree_wait:
		/* Wait for preceding I/O session to complete. */
		test	SCSISIGI, ACKI jnz .;
target_busfree:
		and	SIMODE1, ~ENBUSFREE;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			clr	SCSIBUSL;
		}
		clr	SCSISIGO;
		mvi	LASTPHASE, P_BUSFREE;
		call	complete_target_cmd;
		jmp	poll_for_work;

target_cmdphase:
		/*
		 * The target has dropped ATN (doesn't want to abort or BDR)
		 * and we believe this selection to be valid.  If the ring
		 * buffer for new commands is full, return busy or queue full.
		 */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			and	A, HOST_TQINPOS, HS_MAILBOX;
		} else {
			mov	A, KERNEL_TQINPOS;
		}
		cmp	TQINPOS, A jne tqinfifo_has_space;
		mvi	P_STATUS|BSYO call change_phase;
		test	SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
		mvi	STATUS_QUEUE_FULL call target_outb;
		jmp	target_busfree_wait;
		mvi	STATUS_BUSY call target_outb;
		jmp	target_busfree_wait;
tqinfifo_has_space:	
		mvi	P_COMMAND|BSYO call change_phase;
		call	target_inb;
		mov	A, DINDEX;
		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, A;
		} else {
			mov	DFDAT, A;
		}

		/*
		 * Determine the number of bytes to read
		 * based on the command group code via table lookup.
		 * We reuse the first 8 bytes of the TARG_SCSIRATE
		 * BIOS array for this table. Count is one less than
		 * the total for the command since we've already fetched
		 * the first byte.
		 */
		shr	A, CMD_GROUP_CODE_SHIFT;
		add	SINDEX, CMDSIZE_TABLE, A;
		mov	A, SINDIR;

		test	A, 0xFF jz command_phase_done;
		or	SXFRCTL0, SPIOEN;
command_loop:
		test	SSTAT0, SPIORDY jz .;
		cmp	A, 1 jne . + 2;
		and	SXFRCTL0, ~SPIOEN;	/* Last Byte */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SCSIDATL;
		} else {
			mov	DFDAT, SCSIDATL;
		}
		dec	A;
		test	A, 0xFF jnz command_loop;

command_phase_done:
		and	SEQ_FLAGS, ~CMDPHASE_PENDING;
		jmp	target_ITloop;

target_dphase:
		/*
		 * Data phases on the bus are from the
		 * perspective of the initiator.  The DMA
		 * code looks at LASTPHASE to determine the
		 * data direction of the DMA.  Toggle it for
		 * target transfers.
		 */
		xor	LASTPHASE, IOI, SCB_TARGET_DATA_DIR;
		or	SCB_TARGET_DATA_DIR, BSYO call change_phase;
		jmp	p_data;

target_sphase:
		mvi	P_STATUS|BSYO call change_phase;
		mvi	LASTPHASE, P_STATUS;
		mov	SCB_SCSI_STATUS call target_outb;
		/* XXX Watch for ATN or parity errors??? */
		mvi	SCSISIGO, P_MESGIN|BSYO;
		/* MSG_CMDCMPLT is 0, but we can't do an immediate of 0 */
		mov	ALLZEROS call target_outb;
		jmp	target_busfree_wait;
	
complete_target_cmd:
		test	SEQ_FLAGS, TARG_CMD_PENDING	jnz . + 2;
		mov	SCB_TAG jmp complete_post;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			/* Set the valid byte */
			mvi	CCSCBADDR, 24;
			mov	CCSCBRAM, ALLONES;
			mvi	CCHCNT, 28;
			or	CCSCBCTL, CCSCBEN|CCSCBRESET;
			test	CCSCBCTL, CCSCBDONE jz .;
			clr	CCSCBCTL;
		} else {
			/* Set the valid byte */
			or	DFCNTRL, FIFORESET;
			mvi	DFWADDR, 3; /* Third 64bit word or byte 24 */
			mov	DFDAT, ALLONES;
			mvi	28	call set_hcnt;
			or	DFCNTRL, HDMAEN|FIFOFLUSH;
			call	dma_finish;
		}
		inc	TQINPOS;
		mvi	INTSTAT,CMDCMPLT ret;
	}

if ((ahc->flags & AHC_INITIATORROLE) != 0) {
initiator_select:
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	/*
	 * As soon as we get a successful selection, the target
	 * should go into the message out phase since we have ATN
	 * asserted.
	 */
	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
	mvi	SEQ_FLAGS, NO_CDB_SENT;
	mvi	CLRSINT0, CLRSELDO;

	/*
	 * Main loop for information transfer phases.  Wait for the
	 * target to assert REQ before checking MSG, C/D and I/O for
	 * the bus phase.
	 */
mesgin_phasemis:
ITloop:
	call	phase_lock;

	mov	A, LASTPHASE;

	test	A, ~P_DATAIN	jz p_data;
	cmp	A,P_COMMAND	je p_command;
	cmp	A,P_MESGOUT	je p_mesgout;
	cmp	A,P_STATUS	je p_status;
	cmp	A,P_MESGIN	je p_mesgin;

	mvi	BAD_PHASE call set_seqint;
	jmp	ITloop;			/* Try reading the bus again. */

await_busfree:
	and	SIMODE1, ~ENBUSFREE;
	mov	NONE, SCSIDATL;		/* Ack the last byte */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		clr	SCSIBUSL;	/* Prevent bit leakage durint SELTO */
	}
	and	SXFRCTL0, ~SPIOEN;
	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;
	test	SSTAT1,REQINIT|BUSFREE	jz .;
	test	SSTAT1, BUSFREE jnz poll_for_work;
	mvi	MISSED_BUSFREE call set_seqint;
}
	
clear_target_state:
	/*
	 * We assume that the kernel driver may reset us
	 * at any time, even in the middle of a DMA, so
	 * clear DFCNTRL too.
	 */
	clr	DFCNTRL;
	or	SXFRCTL0, CLRSTCNT|CLRCHN;

	/*
	 * We don't know the target we will connect to,
	 * so default to narrow transfers to avoid
	 * parity problems.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, ALLZEROS, 2;
	} else {
		clr	SCSIRATE;
		if ((ahc->features & AHC_ULTRA) != 0) {
			and	SXFRCTL0, ~(FAST20);
		}
	}
	mvi	LASTPHASE, P_BUSFREE;
	/* clear target specific flags */
	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;

sg_advance:
	clr	A;			/* add sizeof(struct scatter) */
	add	SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
	adc	SCB_RESIDUAL_SGPTR[1],A;
	adc	SCB_RESIDUAL_SGPTR[2],A;
	adc	SCB_RESIDUAL_SGPTR[3],A ret;

if ((ahc->features & AHC_CMD_CHAN) != 0) {
disable_ccsgen:
	test	CCSGCTL, CCSGEN jz return;
	test	CCSGCTL, CCSGDONE jz .;
disable_ccsgen_fetch_done:
	clr	CCSGCTL;
	test	CCSGCTL, CCSGEN jnz .;
	ret;
idle_loop:
	/*
	 * Do we need any more segments for this transfer?
	 */
	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

	/* Did we just finish fetching segs? */
	cmp	CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

	/* Are we actively fetching segments? */
	test	CCSGCTL, CCSGEN jnz return;

	/*
	 * Do we have any prefetch left???
	 */
	cmp	CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

	/*
	 * Need to fetch segments, but we can only do that
	 * if the command channel is completely idle.  Make
	 * sure we don't have an SCB prefetch going on.
	 */
	test	CCSCBCTL, CCSCBEN jnz return;

	/*
	 * We fetch a "cacheline aligned" and sized amount of data
	 * so we don't end up referencing a non-existent page.
	 * Cacheline aligned is in quotes because the kernel will
	 * set the prefetch amount to a reasonable level if the
	 * cacheline size is unknown.
	 */
	mvi	CCHCNT, SG_PREFETCH_CNT;
	and	CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
	bmov	CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
	mvi	CCSGCTL, CCSGEN|CCSGRESET ret;
idle_sgfetch_complete:
	call	disable_ccsgen_fetch_done;
	and	CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
idle_sg_avail:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		/* Does the hardware have space for another SG entry? */
		test	DFSTATUS, PRELOAD_AVAIL jz return;
		bmov 	HADDR, CCSGRAM, 7;
		bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
		}
		call	sg_advance;
		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
		or	SINDEX, LAST_SEG;
		mov	SG_CACHE_PRE, SINDEX;
		/* Load the segment */
		or	DFCNTRL, PRELOADEN;
	}
	ret;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Calculate the trailing portion of this S/G segment that cannot
 * be transferred using memory write and invalidate PCI transactions.  
 * XXX Can we optimize this for PCI writes only???
 */
calc_mwi_residual:
	/*
	 * If the ending address is on a cacheline boundary,
	 * there is no need for an extra segment.
	 */
	mov	A, HCNT[0];
	add	A, A, HADDR[0];
	and	A, CACHESIZE_MASK;
	test	A, 0xFF jz return;

	/*
	 * If the transfer is less than a cachline,
	 * there is no need for an extra segment.
	 */
	test	HCNT[1], 0xFF	jnz calc_mwi_residual_final;
	test	HCNT[2], 0xFF	jnz calc_mwi_residual_final;
	add	NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
	jnc	return;

calc_mwi_residual_final:
	mov	MWI_RESIDUAL, A;
	not	A;
	inc	A;
	add	HCNT[0], A;
	adc	HCNT[1], -1;
	adc	HCNT[2], -1 ret;
}

p_data:
	test	SEQ_FLAGS,NOT_IDENTIFIED|NO_CDB_SENT jz p_data_allowed;
	mvi	PROTO_VIOLATION call set_seqint;
p_data_allowed:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mvi	DMAPARAMS, PRELOADEN|SCSIEN|HDMAEN;
	} else {
		mvi	DMAPARAMS, WIDEODD|SCSIEN|SDMAEN|HDMAEN|FIFORESET;
	}
	test	LASTPHASE, IOI jnz . + 2;
	or	DMAPARAMS, DIRECTION;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* We don't have any valid S/G elements */
		mvi	CCSGADDR, SG_PREFETCH_CNT;
	}
	test	SEQ_FLAGS, DPHASE	jz data_phase_initialize;

	/*
	 * If we re-enter the data phase after going through another
	 * phase, our transfer location has almost certainly been
	 * corrupted by the interveining, non-data, transfers.  Ask
	 * the host driver to fix us up based on the transfer residual.
	 */
	mvi	PDATA_REINIT	call set_seqint;
	jmp	data_phase_loop;

data_phase_initialize:
	/* We have seen a data phase for the first time */
	or	SEQ_FLAGS, DPHASE;

	/*
	 * Initialize the DMA address and counter from the SCB.
	 * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
	 * flag in the highest byte of the data count.  We cannot
	 * modify the saved values in the SCB until we see a save
	 * data pointers message.
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		/* The lowest address byte must be loaded last. */
		mov	SCB_DATACNT[3] call set_hhaddr;
	}
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	HADDR, SCB_DATAPTR, 7;
		bmov	SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_DATAPTR	call bcopy_7;
		mvi	DINDEX, SCB_RESIDUAL_DATACNT + 3;
		mvi	SCB_DATACNT + 3 call bcopy_5;
	}
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
		call	calc_mwi_residual;
	}
	and	SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} else {
			call	set_stcnt_from_hcnt;
		}
	}

data_phase_loop:
	/* Guard against overruns */
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;

	/*
	 * Turn on `Bit Bucket' mode, wait until the target takes
	 * us to another phase, and then notify the host.
	 */
	and	DMAPARAMS, DIRECTION;
	mov	DFCNTRL, DMAPARAMS;
	or	SXFRCTL1,BITBUCKET;
	if ((ahc->features & AHC_DT) == 0) {
		test	SSTAT1,PHASEMIS	jz .;
	} else {
		test	SCSIPHASE, DATA_PHASE_MASK jnz .;
	}
	and	SXFRCTL1, ~BITBUCKET;
	mvi	DATA_OVERRUN call set_seqint;
	jmp	ITloop;

data_phase_inbounds:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
		or	SINDEX, LAST_SEG;
		mov	SG_CACHE_PRE, SINDEX;
		mov	DFCNTRL, DMAPARAMS;
ultra2_dma_loop:
		call	idle_loop;
		/*
		 * The transfer is complete if either the last segment
		 * completes or the target changes phase.
		 */
		test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
		if ((ahc->features & AHC_DT) == 0) {
			if ((ahc->flags & AHC_TARGETROLE) != 0) {
				 /*
				  * As a target, we control the phases,
				  * so ignore PHASEMIS.
				  */
				test	SSTAT0, TARGET jnz ultra2_dma_loop;
			}
			if ((ahc->flags & AHC_INITIATORROLE) != 0) {
				test	SSTAT1,PHASEMIS	jz ultra2_dma_loop;
			}
		} else {
			test	DFCNTRL, SCSIEN jnz ultra2_dma_loop;
		}

ultra2_dmafinish:
		/*
		 * The transfer has terminated either due to a phase
		 * change, and/or the completion of the last segment.
		 * We have two goals here.  Do as much other work
		 * as possible while the data fifo drains on a read
		 * and respond as quickly as possible to the standard
		 * messages (save data pointers/disconnect and command
		 * complete) that usually follow a data phase.
		 */
		if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
			/*
			 * On chips with broken auto-flush, start
			 * the flushing process now.  We'll poke
			 * the chip from time to time to keep the
			 * flush process going as we complete the
			 * data phase.
			 */
			or	DFCNTRL, FIFOFLUSH;
		}
		/*
		 * We assume that, even though data may still be
		 * transferring to the host, that the SCSI side of
		 * the DMA engine is now in a static state.  This
		 * allows us to update our notion of where we are
		 * in this transfer.
		 *
		 * If, by chance, we stopped before being able
		 * to fetch additional segments for this transfer,
		 * yet the last S/G was completely exhausted,
		 * call our idle loop until it is able to load
		 * another segment.  This will allow us to immediately
		 * pickup on the next segment on the next data phase.
		 *
		 * If we happened to stop on the last segment, then
		 * our residual information is still correct from
		 * the idle loop and there is no need to perform
		 * any fixups.
		 */
ultra2_ensure_sg:
		test	SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
		/* Record if we've consumed all S/G entries */
		test	SSTAT2, SHVALID	jnz residuals_correct;
		or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
		jmp	residuals_correct;

ultra2_shvalid:
		test	SSTAT2, SHVALID	jnz sgptr_fixup;
		call	idle_loop;
		jmp	ultra2_ensure_sg;

sgptr_fixup:
		/*
		 * Fixup the residual next S/G pointer.  The S/G preload
		 * feature of the chip allows us to load two elements
		 * in addition to the currently active element.  We
		 * store the bottom byte of the next S/G pointer in
		 * the SG_CACEPTR register so we can restore the
		 * correct value when the DMA completes.  If the next
		 * sg ptr value has advanced to the point where higher
		 * bytes in the address have been affected, fix them
		 * too.
		 */
		test	SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
		test	SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
		add	SCB_RESIDUAL_SGPTR[1], -1;
		adc	SCB_RESIDUAL_SGPTR[2], -1; 
		adc	SCB_RESIDUAL_SGPTR[3], -1;
sgptr_fixup_done:
		and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
		/* We are not the last seg */
		and	SCB_RESIDUAL_DATACNT[3], ~SG_LAST_SEG;
residuals_correct:
		/*
		 * Go ahead and shut down the DMA engine now.
		 * In the future, we'll want to handle end of
		 * transfer messages prior to doing this, but this
		 * requires similar restructuring for pre-ULTRA2
		 * controllers.
		 */
		test	DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
ultra2_fifoflush:
		if ((ahc->features & AHC_DT) == 0) {
			if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
				/*
				 * On Rev A of the aic7890, the autoflush
				 * feature doesn't function correctly.
				 * Perform an explicit manual flush.  During
				 * a manual flush, the FIFOEMP bit becomes
				 * true every time the PCI FIFO empties
				 * regardless of the state of the SCSI FIFO.
				 * It can take up to 4 clock cycles for the
				 * SCSI FIFO to get data into the PCI FIFO
				 * and for FIFOEMP to de-assert.  Here we
				 * guard against this condition by making
				 * sure the FIFOEMP bit stays on for 5 full
				 * clock cycles.
				 */
				or	DFCNTRL, FIFOFLUSH;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
			}
			test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
		} else {
			/*
			 * We enable the auto-ack feature on DT capable
			 * controllers.  This means that the controller may
			 * have already transferred some overrun bytes into
			 * the data FIFO and acked them on the bus.  The only
			 * way to detect this situation is to wait for
			 * LAST_SEG_DONE to come true on a completed transfer
			 * and then test to see if the data FIFO is non-empty.
			 */
			test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL
				jz ultra2_wait_fifoemp;
			test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
			/*
			 * FIFOEMP can lag LAST_SEG_DONE.  Wait a few
			 * clocks before calling this an overrun.
			 */
			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
			/* Overrun */
			jmp	data_phase_loop;
ultra2_wait_fifoemp:
			test	DFSTATUS, FIFOEMP jz .;
		}
ultra2_fifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_fifoempty;
ultra2_dmahalt:
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, SCSIEN|HDMAEN jnz .;
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			/*
			 * Keep HHADDR cleared for future, 32bit addressed
			 * only, DMA operations.
			 *
			 * Due to bayonette style S/G handling, our residual
			 * data must be "fixed up" once the transfer is halted.
			 * Here we fixup the HSHADDR stored in the high byte
			 * of the residual data cnt.  By postponing the fixup,
			 * we can batch the clearing of HADDR with the fixup.
			 * If we halted on the last segment, the residual is
			 * already correct.   If we are not on the last
			 * segment, copy the high address directly from HSHADDR.
			 * We don't need to worry about maintaining the
			 * SG_LAST_SEG flag as it will always be false in the
			 * case where an update is required.
			 */
			or	DSCOMMAND1, HADDLDSEL0;
			test	SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
			mov	SCB_RESIDUAL_DATACNT[3], SHADDR;
			clr	HADDR;
			and	DSCOMMAND1, ~HADDLDSEL0;
		}
	} else {
		/* If we are the last SG block, tell the hardware. */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
		}
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
		if ((ahc->flags & AHC_TARGETROLE) != 0) {
			test	SSTAT0, TARGET jz dma_last_sg;
			if ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0) {
				test	DMAPARAMS, DIRECTION jz dma_mid_sg;
			}
		}
dma_last_sg:
		and	DMAPARAMS, ~WIDEODD;
dma_mid_sg:
		/* Start DMA data transfer. */
		mov	DFCNTRL, DMAPARAMS;
dma_loop:
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			call	idle_loop;
		}
		test	SSTAT0,DMADONE	jnz dma_dmadone;
		test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
dma_phasemis:
		/*
		 * We will be "done" DMAing when the transfer count goes to
		 * zero, or the target changes the phase (in light of this,
		 * it makes sense that the DMA circuitry doesn't ACK when
		 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
		 * the data FIFO should be flushed auto-magically on STCNT=0
		 * or a phase change, so just wait for FIFO empty status.
		 */
dma_checkfifo:
		test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
dma_fifoflush:
		test	DFSTATUS,FIFOEMP	jz dma_fifoflush;
dma_fifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz dma_fifoempty;

		/*
		 * Now shut off the DMA and make sure that the DMA
		 * hardware has actually stopped.  Touching the DMA
		 * counters, etc. while a DMA is active will result
		 * in an ILLSADDR exception.
		 */
dma_dmadone:
		and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
		/*
		 * Some revisions of the aic78XX have a problem where, if the
		 * data fifo is full, but the PCI input latch is not empty, 
		 * HDMAEN cannot be cleared.  The fix used here is to drain
		 * the prefetched but unused data from the data fifo until
		 * there is space for the input latch to drain.
		 */
		if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
			mov	NONE, DFDAT;
		}
		test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

		/* See if we have completed this last segment */
		test	STCNT[0], 0xff	jnz data_phase_finish;
		test	STCNT[1], 0xff	jnz data_phase_finish;
		test	STCNT[2], 0xff	jnz data_phase_finish;

		/*
		 * Advance the scatter-gather pointers if needed 
		 */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_RESIDUAL, 0xFF jz no_mwi_resid;
			/*
			 * Reload HADDR from SHADDR and setup the
			 * count to be the size of our residual.
			 */
			if ((ahc->features & AHC_CMD_CHAN) != 0) {
				bmov	HADDR, SHADDR, 4;
				mov	HCNT, MWI_RESIDUAL;
				bmov	HCNT[1], ALLZEROS, 2;
			} else {
				mvi	DINDEX, HADDR;
				mvi	SHADDR call bcopy_4;
				mov	MWI_RESIDUAL call set_hcnt;
			}
			clr	MWI_RESIDUAL;
			jmp	sg_load_done;
no_mwi_resid:
		}
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
		or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
		jmp	data_phase_finish;
sg_load:
		/*
		 * Load the next SG element's data address and length
		 * into the DMA engine.  If we don't have hardware
		 * to perform a prefetch, we'll have to fetch the
		 * segment from host memory first.
		 */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			/* Wait for the idle loop to complete */
			test	CCSGCTL, CCSGEN jz . + 3;
			call	idle_loop;
			test	CCSGCTL, CCSGEN jnz . - 1;
			bmov 	HADDR, CCSGRAM, 7;
			/*
			 * Workaround for flaky external SCB RAM
			 * on certain aic7895 setups.  It seems
			 * unable to handle direct transfers from
			 * S/G ram to certain SCB locations.
			 */
			mov	SINDEX, CCSGRAM;
			mov	SCB_RESIDUAL_DATACNT[3], SINDEX;
		} else {
			if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
				mov	ALLZEROS call set_hhaddr;
			}
			mvi	DINDEX, HADDR;
			mvi	SCB_RESIDUAL_SGPTR	call bcopy_4;

			mvi	SG_SIZEOF	call set_hcnt;

			or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

			call	dma_finish;

			mvi	DINDEX, HADDR;
			call	dfdat_in_7;
			mov	SCB_RESIDUAL_DATACNT[3], DFDAT;
		}

		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

			/*
			 * The lowest address byte must be loaded
			 * last as it triggers the computation of
			 * some items in the PCI block.  The ULTRA2
			 * chips do this on PRELOAD.
			 */
			mov	HADDR, HADDR;
		}
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			call calc_mwi_residual;
		}

		/* Point to the new next sg in memory */
		call	sg_advance;

sg_load_done:
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} else {
			call	set_stcnt_from_hcnt;
		}

		if ((ahc->flags & AHC_TARGETROLE) != 0) {
			test	SSTAT0, TARGET jnz data_phase_loop;
		}
	}
data_phase_finish:
	/*
	 * If the target has left us in data phase, loop through
	 * the DMA code again.  In the case of ULTRA2 adapters,
	 * we should only loop if there is a data overrun.  For
	 * all other adapters, we'll loop after each S/G element
	 * is loaded as well as if there is an overrun.
	 */
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_done;
	}
	if ((ahc->flags & AHC_INITIATORROLE) != 0) {
		test	SSTAT1, REQINIT jz .;
		if ((ahc->features & AHC_DT) == 0) {
			test	SSTAT1,PHASEMIS	jz data_phase_loop;
		} else {
			test	SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
		}
	}

data_phase_done:
	/*
	 * After a DMA finishes, save the SG and STCNT residuals back into
	 * the SCB.  We use STCNT instead of HCNT, since it's a reflection
	 * of how many bytes were transferred on the SCSI (as opposed to the
	 * host) bus.
	 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Kill off any pending prefetch */
		call	disable_ccsgen;
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		/*
		 * Clear the high address byte so that all other DMA
		 * operations, which use 32bit addressing, can assume
		 * HHADDR is 0.
		 */
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	ALLZEROS call set_hhaddr;
		}
	}

	/*
	 * Update our residual information before the information is
	 * lost by some other type of SCSI I/O (e.g. PIO).  If we have
	 * transferred all data, no update is needed.
	 *
	 */
	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
	  && ahc->pci_cachesize != 0) {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			test	MWI_RESIDUAL, 0xFF jz bmov_resid;
		}
		mov	A, MWI_RESIDUAL;
		add	SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
		clr	A;
		adc	SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
		adc	SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
		clr	MWI_RESIDUAL;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			jmp	. + 2;
bmov_resid:
			bmov	SCB_RESIDUAL_DATACNT, STCNT, 3;
		}
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
		mov	SCB_RESIDUAL_DATACNT[0], STCNT[0];
		mov	SCB_RESIDUAL_DATACNT[1], STCNT[1];
		mov	SCB_RESIDUAL_DATACNT[2], STCNT[2];
	}
residual_update_done:
	/*
	 * Since we've been through a data phase, the SCB_RESID* fields
	 * are now initialized.  Clear the full residual flag.
	 */
	and	SCB_SGPTR[0], ~SG_FULL_RESID;

	if ((ahc->features & AHC_ULTRA2) != 0) {
		/* Clear the channel in case we return to data phase later */
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}

	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		test	SEQ_FLAGS, DPHASE_PENDING jz ITloop;
		and	SEQ_FLAGS, ~DPHASE_PENDING;
		/*
		 * For data-in phases, wait for any pending acks from the
		 * initiator before changing phase.  We only need to
		 * send Ignore Wide Residue messages for data-in phases.
		 */
		test	DFCNTRL, DIRECTION jz target_ITloop;
		test	SSTAT1, REQINIT	jnz .;
		test	SCB_LUN, SCB_XFERLEN_ODD jz target_ITloop;
		test	SCSIRATE, WIDEXFER jz target_ITloop;
		/*
		 * Issue an Ignore Wide Residue Message.
		 */
		mvi	P_MESGIN|BSYO call change_phase;
		mvi	MSG_IGN_WIDE_RESIDUE call target_outb;
		mvi	1 call target_outb;
		jmp	target_ITloop;
	} else {
		jmp	ITloop;
	}

if ((ahc->flags & AHC_INITIATORROLE) != 0) {
/*
 * Command phase.  Set up the DMA registers and let 'er rip.
 */
p_command:
	test	SEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;
	mvi	PROTO_VIOLATION call set_seqint;
p_command_okay:

	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT[0], SCB_CDB_LEN,  1;
		bmov	HCNT[1], ALLZEROS, 2;
		mvi	SG_CACHE_PRE, LAST_SEG;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT[0], SCB_CDB_LEN, 1;
		bmov	STCNT[1], ALLZEROS, 2;
	} else {
		mov	STCNT[0], SCB_CDB_LEN;
		clr	STCNT[1];
		clr	STCNT[2];
	}
	add	NONE, -13, SCB_CDB_LEN;
	mvi	SCB_CDB_STORE jnc p_command_embedded;
p_command_from_host:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HADDR[0], SCB_CDB_PTR, 4;
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	} else {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	HADDR[0], SCB_CDB_PTR, 4;
			bmov	HCNT, STCNT, 3;
		} else {
			mvi	DINDEX, HADDR;
			mvi	SCB_CDB_PTR call bcopy_4;
			mov	SCB_CDB_LEN call set_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	}
	jmp	p_command_xfer;
p_command_embedded:
	/*
	 * The data fifo seems to require 4 byte aligned
	 * transfers from the sequencer.  Force this to
	 * be the case by clearing HADDR[0] even though
	 * we aren't going to touch host memory.
	 */
	clr	HADDR[0];
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
		bmov	DFDAT, SCB_CDB_STORE, 12; 
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			/*
			 * On the 7895 the data FIFO will
			 * get corrupted if you try to dump
			 * data from external SCB memory into
			 * the FIFO while it is enabled.  So,
			 * fill the fifo and then enable SCSI
			 * transfers.
			 */
			mvi	DFCNTRL, (DIRECTION|FIFORESET);
		} else {
			mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
		}
		bmov	DFDAT, SCB_CDB_STORE, 12; 
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
		} else {
			or	DFCNTRL, FIFOFLUSH;
		}
	} else {
		mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
		call	copy_to_fifo_6;
		call	copy_to_fifo_6;
		or	DFCNTRL, FIFOFLUSH;
	}
p_command_xfer:
	and	SEQ_FLAGS, ~NO_CDB_SENT;
	if ((ahc->features & AHC_DT) == 0) {
		test	SSTAT0, SDONE jnz . + 2;
		test    SSTAT1, PHASEMIS jz . - 1;
		/*
		 * Wait for our ACK to go-away on its own
		 * instead of being killed by SCSIEN getting cleared.
		 */
		test	SCSISIGI, ACKI jnz .;
	} else {
		test	DFCNTRL, SCSIEN jnz .;
	}
	test	SSTAT0, SDONE jnz p_command_successful;
	/*
	 * Don't allow a data phase if the command
	 * was not fully transferred.
	 */
	or	SEQ_FLAGS, NO_CDB_SENT;
p_command_successful:
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz .;
	jmp	ITloop;

/*
 * Status phase.  Wait for the data byte to appear, then read it
 * and store it into the SCB.
 */
p_status:
	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
p_status_okay:
	mov	SCB_SCSI_STATUS, SCSIDATL;
	or	SCB_CONTROL, STATUS_RCVD;
	jmp	ITloop;

/*
 * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full
 * identify message sequence and send it to the target.  The host may
 * override this behavior by setting the MK_MESSAGE bit in the SCB
 * control byte.  This will cause us to interrupt the host and allow
 * it to handle the message phase completely on its own.  If the bit
 * associated with this target is set, we will also interrupt the host,
 * thereby allowing it to send a message on the next selection regardless
 * of the transaction being sent.
 * 
 * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.
 * This is done to allow the host to send messages outside of an identify
 * sequence while protecting the sequencer from testing the MK_MESSAGE bit
 * on an SCB that might not be for the current nexus. (For example, a
 * BDR message in response to a bad reselection would leave us pointed to
 * an SCB that doesn't have anything to do with the current target).
 *
 * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
 * bus device reset).
 *
 * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,
 * in case the target decides to put us in this phase for some strange
 * reason.
 */
p_mesgout_retry:
	/* Turn on ATN for the retry */
	if ((ahc->features & AHC_DT) == 0) {
		or	SCSISIGO, ATNO, LASTPHASE;
	} else {
		mvi	SCSISIGO, ATNO;
	}
p_mesgout:
	mov	SINDEX, MSG_OUT;
	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
p_mesgout_identify:
	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SAVED_LUN;
	test	SCB_CONTROL, DISCENB jnz . + 2;
	and	SINDEX, ~DISCENB;
/*
 * Send a tag message if TAG_ENB is set in the SCB control block.
 * Use SCB_TAG (the position in the kernel's SCB array) as the tag value.
 */
p_mesgout_tag:
	test	SCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;
	mov	SCSIDATL, SINDEX;	/* Send the identify message */
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
	and	SCSIDATL,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
	mov	SCB_TAG	jmp p_mesgout_onebyte;
/*
 * Interrupt the driver, and allow it to handle this message
 * phase and any required retries.
 */
p_mesgout_from_host:
	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
	jmp	host_message_loop;

p_mesgout_onebyte:
	mvi	CLRSINT1, CLRATNO;
	mov	SCSIDATL, SINDEX;

/*
 * If the next bus phase after ATN drops is message out, it means
 * that the target is requesting that the last message(s) be resent.
 */
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	je p_mesgout_retry;

p_mesgout_done:
	mvi	CLRSINT1,CLRATNO;	/* Be sure to turn ATNO off */
	mov	LAST_MSG, MSG_OUT;
	mvi	MSG_OUT, MSG_NOOP;	/* No message left */
	jmp	ITloop;

/*
 * Message in phase.  Bytes are read using Automatic PIO mode.
 */
p_mesgin:
	mvi	ACCUM		call inb_first;	/* read the 1st message byte */

	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify;
	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs;
	cmp	ALLZEROS,A		je mesgin_complete;
	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs;
	cmp	A,MSG_IGN_WIDE_RESIDUE	je mesgin_ign_wide_residue;
	cmp	A,MSG_NOOP		je mesgin_done;

/*
 * Pushed message loop to allow the kernel to
 * run its own message state engine.  To avoid an
 * extra nop instruction after signaling the kernel,
 * we perform the phase_lock before checking to see
 * if we should exit the loop and skip the phase_lock
 * in the ITloop.  Performing back to back phase_locks
 * shouldn't hurt, but why do it twice...
 */
host_message_loop:
	mvi	HOST_MSG_LOOP call set_seqint;
	call	phase_lock;
	cmp	RETURN_1, EXIT_MSG_LOOP	je ITloop + 1;
	jmp	host_message_loop;

mesgin_ign_wide_residue:
if ((ahc->features & AHC_WIDE) != 0) {
	test	SCSIRATE, WIDEXFER jz mesgin_reject;
	/* Pull the residue byte */
	mvi	ARG_1	call inb_next;
	cmp	ARG_1, 0x01 jne mesgin_reject;
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
	test	SCB_LUN, SCB_XFERLEN_ODD jnz mesgin_done;
	mvi	IGN_WIDE_RES call set_seqint;
	jmp	mesgin_done;
}

mesgin_proto_violation:
	mvi	PROTO_VIOLATION call set_seqint;
	jmp	mesgin_done;
mesgin_reject:
	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
mesgin_done:
	mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
	jmp	ITloop;

/*
 * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
 * and trigger a completion interrupt.  Before doing so, check to see if there
 * is a residual or the status byte is something other than STATUS_GOOD (0).
 * In either of these conditions, we upload the SCB back to the host so it can
 * process this information.  In the case of a non zero status byte, we 
 * additionally interrupt the kernel driver synchronously, allowing it to
 * decide if sense should be retrieved.  If the kernel driver wishes to request
 * sense, it will fill the kernel SCB with a request sense command, requeue
 * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
 * RETURN_1 to SEND_SENSE.
 */
mesgin_complete:

	/*
	 * If ATN is raised, we still want to give the target a message.
	 * Perhaps there was a parity error on this last message byte.
	 * Either way, the target should take us to message out phase
	 * and then attempt to complete the command again.  We should use a
	 * critical section here to guard against a timeout triggering
	 * for this command and setting ATN while we are still processing
	 * the completion.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */

	/*
	 * If we are identified and have successfully sent the CDB,
	 * any status will do.  Optimize this fast path.
	 */
	test	SCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;
	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted; 

	/*
	 * If the target never sent an identify message but instead went
	 * to mesgin to give an invalid message, let the host abort us.
	 */
	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;

	/*
	 * If we received good status but never successfully sent the
	 * cdb, abort the command.
	 */
	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;

complete_accepted:
	/*
	 * See if we attempted to deliver a message but the target ingnored us.
	 */
	test	SCB_CONTROL, MK_MESSAGE jz . + 2;
	mvi	MKMSG_FAILED call set_seqint;

	/*
	 * Check for residuals
	 */
	test	SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
check_status:
	test	SCB_SCSI_STATUS,0xff	jz complete;	/* Good Status? */
upload_scb:
	or	SCB_SGPTR, SG_RESID_VALID;
	mvi	DMAPARAMS, FIFORESET;
	mov	SCB_TAG		call dma_scb;
	test	SCB_SCSI_STATUS, 0xff	jz complete;	/* Just a residual? */
	mvi	BAD_STATUS call set_seqint;		/* let driver know */
	cmp	RETURN_1, SEND_SENSE	jne complete;
	call	add_scb_to_free_list;
	jmp	await_busfree;
complete:
	mov	SCB_TAG call complete_post;
	jmp	await_busfree;
}

complete_post:
	/* Post the SCBID in SINDEX and issue an interrupt */
	call	add_scb_to_free_list;
	mov	ARG_1, SINDEX;
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		mov	A, SDSCB_QOFF;
	} else {
		mov	A, QOUTPOS;
	}
	mvi	QOUTFIFO_OFFSET call post_byte_setup;
	mov	ARG_1 call post_byte;
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		inc 	QOUTPOS;
	}
	mvi	INTSTAT,CMDCMPLT ret;

if ((ahc->flags & AHC_INITIATORROLE) != 0) {
/*
 * Is it a disconnect message?  Set a flag in the SCB to remind us
 * and await the bus going free.  If this is an untagged transaction
 * store the SCB id for it in our untagged target table for lookup on
 * a reselection.
 */
mesgin_disconnect:
	/*
	 * If ATN is raised, we still want to give the target a message.
	 * Perhaps there was a parity error on this last message byte
	 * or we want to abort this command.  Either way, the target
	 * should take us to message out phase and then attempt to
	 * disconnect again.
	 * XXX - Wait for more testing.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */
	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT
		jnz mesgin_proto_violation;
	or	SCB_CONTROL,DISCONNECTED;
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		call	add_scb_to_disc_list;
	}
	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
	mov	ARG_1, SCB_TAG;
	and	SAVED_LUN, LID, SCB_LUN;
	mov	SCB_SCSIID	call set_busy_target;
	jmp	await_busfree;

/*
 * Save data pointers message:
 * Copying RAM values back to SCB, for Save Data Pointers message, but
 * only if we've actually been into a data phase to change them.  This
 * protects against bogus data in scratch ram and the residual counts
 * since they are only initialized when we go into data_in or data_out.
 * Ack the message as soon as possible.  For chips without S/G pipelining,
 * we can only ack the message after SHADDR has been saved.  On these
 * chips, SHADDR increments with every bus transaction, even PIO.
 */
mesgin_sdptrs:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
		test	SEQ_FLAGS, DPHASE	jz ITloop;
	} else {
		test	SEQ_FLAGS, DPHASE	jz mesgin_done;
	}

	/*
	 * If we are asked to save our position at the end of the
	 * transfer, just mark us at the end rather than perform a
	 * full save.
	 */
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
	or	SCB_SGPTR, SG_LIST_NULL;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		jmp	ITloop;
	} else {
		jmp	mesgin_done;
	}

mesgin_sdptrs_full:

	/*
	 * The SCB_SGPTR becomes the next one we'll download,
	 * and the SCB_DATAPTR becomes the current SHADDR.
	 * Use the residual number since STCNT is corrupted by
	 * any message transfer.
	 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_DATAPTR, SHADDR, 4;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			mov	NONE,SCSIDATL;	/*dummy read from latch to ACK*/
		}
		bmov	SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
	} else {
		mvi	DINDEX, SCB_DATAPTR;
		mvi	SHADDR call bcopy_4;
		mov	NONE,SCSIDATL;	/*dummy read from latch to ACK*/
		mvi	SCB_RESIDUAL_DATACNT call bcopy_8;
	}
	jmp	ITloop;

/*
 * Restore pointers message?  Data pointers are recopied from the
 * SCB anytime we enter a data phase for the first time, so all
 * we need to do is clear the DPHASE flag and let the data phase
 * code do the rest.  We also reset/reallocate the FIFO to make
 * sure we have a clean start for the next data or command phase.
 */
mesgin_rdptrs:
	and	SEQ_FLAGS, ~DPHASE;		/*
						 * We'll reload them
						 * the next time through
						 * the dataphase.
						 */
	or	SXFRCTL0, CLRSTCNT|CLRCHN;
	jmp	mesgin_done;

/*
 * Index into our Busy Target table.  SINDEX and DINDEX are modified
 * upon return.  SCBPTR may be modified by this action.
 */
set_busy_target:
	shr	DINDEX, 4, SINDEX;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	SCBPTR, SAVED_LUN;
		add	DINDEX, SCB_64_BTT;
	} else {
		add	DINDEX, BUSY_TARGETS;
	}
	mov	DINDIR, ARG_1 ret;

/*
 * Identify message?  For a reconnecting target, this tells us the lun
 * that the reconnection is for - find the correct SCB and switch to it,
 * clearing the "disconnected" bit so we don't "find" it by accident later.
 */
mesgin_identify:
	/*
	 * Determine whether a target is using tagged or non-tagged
	 * transactions by first looking at the transaction stored in
	 * the busy target array.  If there is no untagged transaction
	 * for this target or the transaction is for a different lun, then
	 * this must be a tagged transaction.
	 */
	shr	SINDEX, 4, SAVED_SCSIID;
	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		add	SINDEX, SCB_64_BTT;
		mov	SCBPTR, SAVED_LUN;
		if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
			add	NONE, -SCB_64_BTT, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
			add	NONE, -(SCB_64_BTT + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
		}
	} else {
		add	SINDEX, BUSY_TARGETS;
		if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
			add	NONE, -BUSY_TARGETS, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
			add	NONE, -(BUSY_TARGETS + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
		}
	}
	mov	ARG_1, SINDIR;
	cmp	ARG_1, SCB_LIST_NULL	je snoop_tag;
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mov	ARG_1 call findSCB;
	} else {
		mov	SCBPTR, ARG_1;
	}
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		jmp setup_SCB_id_lun_okay;
	} else {
		/*
		 * We only allow one untagged command per-target
		 * at a time.  So, if the lun doesn't match, look
		 * for a tag message.
		 */
		and	A, LID, SCB_LUN;
		cmp	SAVED_LUN, A	je setup_SCB_id_lun_okay;
		if ((ahc->flags & AHC_PAGESCBS) != 0) {
			/*
			 * findSCB removes the SCB from the
			 * disconnected list, so we must replace
			 * it there should this SCB be for another
			 * lun.
			 */
			call	cleanup_scb;
		}
	}

/*
 * Here we "snoop" the bus looking for a SIMPLE QUEUE TAG message.
 * If we get one, we use the tag returned to find the proper
 * SCB.  With SCB paging, we must search for non-tagged
 * transactions since the SCB may exist in any slot.  If we're not
 * using SCB paging, we can use the tag as the direct index to the
 * SCB.
 */
snoop_tag:
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x80;
	}
	mov	NONE,SCSIDATL;		/* ACK Identify MSG */
	call	phase_lock;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x1;
	}
	cmp	LASTPHASE, P_MESGIN	jne not_found;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x2;
	}
	cmp	SCSIBUSL,MSG_SIMPLE_Q_TAG jne not_found;
get_tag:
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mvi	ARG_1	call inb_next;	/* tag value */
		mov	ARG_1	call findSCB;
	} else {
		mvi	ARG_1	call inb_next;	/* tag value */
		mov	SCBPTR, ARG_1;
	}

/*
 * Ensure that the SCB the tag points to is for
 * an SCB transaction to the reconnecting target.
 */
setup_SCB:
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x4;
	}
	mov	A, SCB_SCSIID;
	cmp	SAVED_SCSIID, A	jne not_found_cleanup_scb;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x8;
	}
setup_SCB_id_okay:
	and	A, LID, SCB_LUN;
	cmp	SAVED_LUN, A	jne not_found_cleanup_scb;
setup_SCB_id_lun_okay:
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x10;
	}
	test	SCB_CONTROL,DISCONNECTED jz not_found_cleanup_scb;
	and	SCB_CONTROL,~DISCONNECTED;
	test	SCB_CONTROL, TAG_ENB	jnz setup_SCB_tagged;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	A, SCBPTR;
	}
	mvi	ARG_1, SCB_LIST_NULL;
	mov	SAVED_SCSIID	call	set_busy_target;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	SCBPTR, A;
	}
setup_SCB_tagged:
	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
	call	set_transfer_settings;
	/* See if the host wants to send a message upon reconnection */
	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
	mvi	HOST_MSG	call mk_mesg;
	jmp	mesgin_done;

not_found_cleanup_scb:
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		call	cleanup_scb;
	}
not_found:
	mvi	NO_MATCH call set_seqint;
	jmp	mesgin_done;

mk_mesg:
	if ((ahc->features & AHC_DT) == 0) {
		or	SCSISIGO, ATNO, LASTPHASE;
	} else {
		mvi	SCSISIGO, ATNO;
	}
	mov	MSG_OUT,SINDEX ret;

/*
 * Functions to read data in Automatic PIO mode.
 *
 * According to Adaptec's documentation, an ACK is not sent on input from
 * the target until SCSIDATL is read from.  So we wait until SCSIDATL is
 * latched (the usual way), then read the data byte directly off the bus
 * using SCSIBUSL.  When we have pulled the ATN line, or we just want to
 * acknowledge the byte, then we do a dummy read from SCISDATL.  The SCSI
 * spec guarantees that the target will hold the data byte on the bus until
 * we send our ACK.
 *
 * The assumption here is that these are called in a particular sequence,
 * and that REQ is already set when inb_first is called.  inb_{first,next}
 * use the same calling convention as inb.
 */
inb_next_wait_perr:
	mvi	PERR_DETECTED call set_seqint;
	jmp	inb_next_wait;
inb_next:
	mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
inb_next_wait:
	/*
	 * If there is a parity error, wait for the kernel to
	 * see the interrupt and prepare our message response
	 * before continuing.
	 */
	test	SSTAT1, REQINIT	jz inb_next_wait;
	test	SSTAT1, SCSIPERR jnz inb_next_wait_perr;
inb_next_check_phase:
	and	LASTPHASE, PHASE_MASK, SCSISIGI;
	cmp	LASTPHASE, P_MESGIN jne mesgin_phasemis;
inb_first:
	mov	DINDEX,SINDEX;
	mov	DINDIR,SCSIBUSL	ret;		/*read byte directly from bus*/
inb_last:
	mov	NONE,SCSIDATL ret;		/*dummy read from latch to ACK*/
}

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * Change to a new phase.  If we are changing the state of the I/O signal,
 * from out to in, wait an additional data release delay before continuing.
 */
change_phase:
	/* Wait for preceding I/O session to complete. */
	test	SCSISIGI, ACKI jnz .;

	/* Change the phase */
	and	DINDEX, IOI, SCSISIGI;
	mov	SCSISIGO, SINDEX;
	and	A, IOI, SINDEX;

	/*
	 * If the data direction has changed, from
	 * out (initiator driving) to in (target driving),
	 * we must wait at least a data release delay plus
	 * the normal bus settle delay. [SCSI III SPI 10.11.0]
	 */
	cmp 	DINDEX, A je change_phase_wait;
	test	SINDEX, IOI jz change_phase_wait;
	call	change_phase_wait;
change_phase_wait:
	nop;
	nop;
	nop;
	nop ret;

/*
 * Send a byte to an initiator in Automatic PIO mode.
 */
target_outb:
	or	SXFRCTL0, SPIOEN;
	test	SSTAT0, SPIORDY	jz .;
	mov	SCSIDATL, SINDEX;
	test	SSTAT0, SPIORDY	jz .;
	and	SXFRCTL0, ~SPIOEN ret;
}
	
/*
 * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will
 * be set to the position of the SCB.  If the SCB cannot be found locally,
 * it will be paged in from host memory.  RETURN_2 stores the address of the
 * preceding SCB in the disconnected list which can be used to speed up
 * removal of the found SCB from the disconnected list.
 */
if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL;
findSCB:
	mov	A, SINDEX;			/* Tag passed in SINDEX */
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
	mov	SCBPTR, DISCONNECTED_SCBH;	/* Initialize SCBPTR */
	mvi	ARG_2, SCB_LIST_NULL;		/* Head of list */
	jmp	findSCB_loop;
findSCB_next:
	cmp	SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
	mov	ARG_2, SCBPTR;
	mov	SCBPTR,SCB_NEXT;
findSCB_loop:
	cmp	SCB_TAG, A	jne findSCB_next;
rem_scb_from_disc_list:
	cmp	ARG_2, SCB_LIST_NULL	je rHead;
	mov	DINDEX, SCB_NEXT;
	mov	SINDEX, SCBPTR;
	mov	SCBPTR, ARG_2;
	mov	SCB_NEXT, DINDEX;
	mov	SCBPTR, SINDEX ret;
rHead:
	mov	DISCONNECTED_SCBH,SCB_NEXT ret;
END_CRITICAL;
findSCB_notFound:
	/*
	 * We didn't find it.  Page in the SCB.
	 */
	mov	ARG_1, A; /* Save tag */
	mov	ALLZEROS call get_free_or_disc_scb;
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	ARG_1	jmp dma_scb;
}

/*
 * Prepare the hardware to post a byte to host memory given an
 * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.
 */
post_byte_setup:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SHARED_DATA_ADDR call	set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSCBCTL, CCSCBRESET ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SHARED_DATA_ADDR call	set_1byte_addr;
		mvi	1	call set_hcnt;
		mvi	DFCNTRL, FIFORESET ret;
	}

post_byte:
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	CCSCBRAM, SINDEX, 1;
		or	CCSCBCTL, CCSCBEN|CCSCBRESET;
		test	CCSCBCTL, CCSCBDONE jz .;
		clr	CCSCBCTL ret;
	} else {
		mov	DFDAT, SINDEX;
		or	DFCNTRL, HDMAEN|FIFOFLUSH;
		jmp	dma_finish;
	}

phase_lock_perr:
	mvi	PERR_DETECTED call set_seqint;
phase_lock:     
	/*
	 * If there is a parity error, wait for the kernel to
	 * see the interrupt and prepare our message response
	 * before continuing.
	 */
	test	SSTAT1, REQINIT jz phase_lock;
	test	SSTAT1, SCSIPERR jnz phase_lock_perr;
phase_lock_latch_phase:
	if ((ahc->features & AHC_DT) == 0) {
		and	SCSISIGO, PHASE_MASK, SCSISIGI;
	}
	and	LASTPHASE, PHASE_MASK, SCSISIGI ret;

if ((ahc->features & AHC_CMD_CHAN) == 0) {
set_hcnt:
	mov	HCNT[0], SINDEX;
clear_hcnt:
	clr	HCNT[1];
	clr	HCNT[2] ret;

set_stcnt_from_hcnt:
	mov	STCNT[0], HCNT[0];
	mov	STCNT[1], HCNT[1];
	mov	STCNT[2], HCNT[2] ret;

bcopy_8:
	mov	DINDIR, SINDIR;
bcopy_7:
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR;
bcopy_5:
	mov	DINDIR, SINDIR;
bcopy_4:
	mov	DINDIR, SINDIR;
bcopy_3:
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR ret;
}

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * Setup addr assuming that A is an index into
 * an array of 32byte objects, SINDEX contains
 * the base address of that array, and DINDEX
 * contains the base address of the location
 * to store the indexed address.
 */
set_32byte_addr:
	shr	ARG_2, 3, A;
	shl	A, 5;
	jmp	set_1byte_addr;
}

/*
 * Setup addr assuming that A is an index into
 * an array of 64byte objects, SINDEX contains
 * the base address of that array, and DINDEX
 * contains the base address of the location
 * to store the indexed address.
 */
set_64byte_addr:
	shr	ARG_2, 2, A;
	shl	A, 6;

/*
 * Setup addr assuming that A + (ARG_2 * 256) is an
 * index into an array of 1byte objects, SINDEX contains
 * the base address of that array, and DINDEX contains
 * the base address of the location to store the computed
 * address.
 */
set_1byte_addr:
	add     DINDIR, A, SINDIR;
	mov     A, ARG_2;
	adc	DINDIR, A, SINDIR;
	clr	A;
	adc	DINDIR, A, SINDIR;
	adc	DINDIR, A, SINDIR ret;

/*
 * Either post or fetch an SCB from host memory based on the
 * DIRECTION bit in DMAPARAMS. The host SCB index is in SINDEX.
 */
dma_scb:
	mov	A, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	HSCB_ADDR call set_64byte_addr;
		mov	CCSCBPTR, SCBPTR;
		test	DMAPARAMS, DIRECTION jz dma_scb_tohost;
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			mvi	CCHCNT, SCB_DOWNLOAD_SIZE_64;
		} else {
			mvi	CCHCNT, SCB_DOWNLOAD_SIZE;
		}
		mvi	CCSCBCTL, CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET;
		cmp	CCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN|CCSCBDIR jne .;
		jmp	dma_scb_finish;
dma_scb_tohost:
		mvi	CCHCNT, SCB_UPLOAD_SIZE;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			mvi	CCSCBCTL, CCSCBRESET;
			bmov	CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
			or	CCSCBCTL, CCSCBEN|CCSCBRESET;
			test	CCSCBCTL, CCSCBDONE jz .;
		} else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
			mvi	CCSCBCTL, CCARREN|CCSCBRESET;
			cmp	CCSCBCTL, ARRDONE|CCARREN jne .;
			mvi	CCHCNT, SCB_UPLOAD_SIZE;
			mvi	CCSCBCTL, CCSCBEN|CCSCBRESET;
			cmp	CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
		} else {
			mvi	CCSCBCTL, CCARREN|CCSCBEN|CCSCBRESET;
			cmp	CCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN jne .;
		}
dma_scb_finish:
		clr	CCSCBCTL;
		test	CCSCBCTL, CCARREN|CCSCBEN jnz .;
		ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	HSCB_ADDR call set_64byte_addr;
		mvi	SCB_DOWNLOAD_SIZE call set_hcnt;
		mov	DFCNTRL, DMAPARAMS;
		test	DMAPARAMS, DIRECTION	jnz dma_scb_fromhost;
		/* Fill it with the SCB data */
copy_scb_tofifo:
		mvi	SINDEX, SCB_BASE;
		add	A, SCB_DOWNLOAD_SIZE, SINDEX;
copy_scb_tofifo_loop:
		call	copy_to_fifo_8;
		cmp	SINDEX, A jne copy_scb_tofifo_loop;
		or	DFCNTRL, HDMAEN|FIFOFLUSH;
		jmp	dma_finish;
dma_scb_fromhost:
		mvi	DINDEX, SCB_BASE;
		if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
			/*
			 * The PCI module will only issue a PCI
			 * retry if the data FIFO is empty.  If the
			 * host disconnects in the middle of a
			 * transfer, we must empty the fifo of all
			 * available data to force the chip to
			 * continue the transfer.  This does not
			 * happen for SCSI transfers as the SCSI module
			 * will drain the FIFO as data are made available.
			 * When the hang occurs, we know that a multiple
			 * of 8 bytes is in the FIFO because the PCI
			 * module has an 8 byte input latch that only
			 * dumps to the FIFO when HCNT == 0 or the
			 * latch is full.
			 */
			clr	A;
			/* Wait for at least 8 bytes of data to arrive. */
dma_scb_hang_fifo:
			test	DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
			test	DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			/*
			 * The PCI module no longer intends to perform
			 * a PCI transaction.  Drain the fifo.
			 */
dma_scb_hang_dma_drain_fifo:
			not	A, HCNT;
			add	A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
			and	A, ~0x7;
			mov	DINDIR,DFDAT;
			cmp	DINDEX, A jne . - 1;
			cmp	DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
				je	dma_finish_nowait;
			/* Restore A as the lines left to transfer. */
			add	A, -SCB_BASE, DINDEX;
			shr	A, 3;
			jmp	dma_scb_hang_fifo;
dma_scb_hang_dma_done:
			and	DFCNTRL, ~HDMAEN;
			test	DFCNTRL, HDMAEN jnz .;
			add	SEQADDR0, A;
		} else {
			call	dma_finish;
		}
		call	dfdat_in_8;
		call	dfdat_in_8;
		call	dfdat_in_8;
dfdat_in_8:
		mov	DINDIR,DFDAT;
dfdat_in_7:
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
dfdat_in_2:
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT ret;
	}

copy_to_fifo_8:
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
copy_to_fifo_6:
	mov	DFDAT,SINDIR;
copy_to_fifo_5:
	mov	DFDAT,SINDIR;
copy_to_fifo_4:
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR ret;

/*
 * Wait for DMA from host memory to data FIFO to complete, then disable
 * DMA and wait for it to acknowledge that it's off.
 */
dma_finish:
	test	DFSTATUS,HDONE	jz dma_finish;
dma_finish_nowait:
	/* Turn off DMA */
	and	DFCNTRL, ~HDMAEN;
	test	DFCNTRL, HDMAEN jnz .;
	ret;

/*
 * Restore an SCB that failed to match an incoming reselection
 * to the correct/safe state.  If the SCB is for a disconnected
 * transaction, it must be returned to the disconnected list.
 * If it is not in the disconnected state, it must be free.
 */
cleanup_scb:
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		test	SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
	}
add_scb_to_free_list:
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL;
		mov	SCB_NEXT, FREE_SCBH;
		mvi	SCB_TAG, SCB_LIST_NULL;
		mov	FREE_SCBH, SCBPTR ret;
END_CRITICAL;
	} else {
		mvi	SCB_TAG, SCB_LIST_NULL ret;
	}

if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
set_hhaddr:
	or	DSCOMMAND1, HADDLDSEL0;
	and	HADDR, SG_HIGH_ADDR_BITS, SINDEX;
	and	DSCOMMAND1, ~HADDLDSEL0 ret;
}

if ((ahc->flags & AHC_PAGESCBS) != 0) {
get_free_or_disc_scb:
BEGIN_CRITICAL;
	cmp	FREE_SCBH, SCB_LIST_NULL jne dequeue_free_scb;
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL jne dequeue_disc_scb;
return_error:
	mvi	NO_FREE_SCB call set_seqint;
	mvi	SINDEX, SCB_LIST_NULL	ret;
dequeue_disc_scb:
	mov	SCBPTR, DISCONNECTED_SCBH;
	mov	DISCONNECTED_SCBH, SCB_NEXT;
END_CRITICAL;
	mvi	DMAPARAMS, FIFORESET;
	mov	SCB_TAG	jmp dma_scb;
BEGIN_CRITICAL;
dequeue_free_scb:
	mov	SCBPTR, FREE_SCBH;
	mov	FREE_SCBH, SCB_NEXT ret;
END_CRITICAL;

add_scb_to_disc_list:
/*
 * Link this SCB into the DISCONNECTED list.  This list holds the
 * candidates for paging out an SCB if one is needed for a new command.
 * Modifying the disconnected list is a critical(pause dissabled) section.
 */
BEGIN_CRITICAL;
	mov	SCB_NEXT, DISCONNECTED_SCBH;
	mov	DISCONNECTED_SCBH, SCBPTR ret;
END_CRITICAL;
}
set_seqint:
	mov	INTSTAT, SINDEX;
	nop;
return:
	ret;
@


1.21
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.20 2007/04/10 17:47:55 miod Exp $ */
d44 1
a44 1
VERSION = "$Id: aic7xxx.seq,v 1.20 2007/04/10 17:47:55 miod Exp $"
d760 1
a760 1
	 * so we don't end up referencing a non-existant page.
@


1.20
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.19 2006/12/23 21:08:01 krw Exp $ */
d44 1
a44 1
VERSION = "$Id: aic7xxx.seq,v 1.19 2006/12/23 21:08:01 krw Exp $"
d1481 1
a1481 1
 * indentify message sequence and send it to the target.  The host may
d1491 1
a1491 1
 * sequence while protecting the seqencer from testing the MK_MESSAGE bit
d1493 1
a1493 1
 * BDR message in responce to a bad reselection would leave us pointed to
d1645 1
a1645 1
	 * If we recevied good status but never successfully sent the
d1701 1
a1701 1
 * a reselction.
@


1.19
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.18 2005/10/07 00:05:01 krw Exp $ */
d44 1
a44 1
VERSION = "$Id: aic7xxx.seq,v 1.18 2005/10/07 00:05:01 krw Exp $"
d325 1
a325 1
		 * run it's own target mode message state engine.
d1450 1
a1450 1
		 * Wait for our ACK to go-away on it's own
d1572 1
a1572 1
 * run it's own message state engine.  To avoid an
@


1.18
log
@From gibbs via FreeBSD (r1.127): "Extend critical section protection
around portions of selection processing that cannot tolerate changes
to the waiting for selection queue by the host or the host cancelling
an active selection." Chuck in comment adjustment of r1.128 too, and
note we are sync'd to r1.128.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.17 2004/08/01 01:36:23 krw Exp $ */
d44 1
a44 1
VERSION = "$Id: aic7xxx.seq,v 1.17 2004/08/01 01:36:23 krw Exp $"
d2007 1
a2007 1
	/* Wait for preceeding I/O session to complete. */
@


1.17
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 2
a2 2
/* $OpenBSD: aic7xxx.seq,v 1.16 2004/02/08 00:38:09 krw Exp $ */
/*
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.126 2003/12/17 00:02:09 gibbs Exp $
d44 1
a44 1
VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#58 $"
d87 1
d89 1
a146 1
END_CRITICAL;
d153 1
d361 1
d395 1
@


1.16
log
@Pull in a few recent changes from FreeBSD, plus a couple of local
tweaks.

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.15 2003/12/24 23:27:55 krw Exp $ */
d41 1
a41 1
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.seq,v 1.123 2003/01/20 20:44:55 gibbs Exp $
d44 1
a44 1
VERSION = "$NetBSD: aic7xxx.seq,v 1.15 2003/05/03 18:11:31 wiz Exp $"
d441 1
a441 1
	mov	SAVED_LUN, SCB_LUN;
d465 1
a465 1
		or	SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
a772 2
		test	HCNT[0], 0x1 jz . + 2;
		xor	DATA_COUNT_ODD, 0x1;
a778 2
		test	DATA_COUNT_ODD, 0x1 jz . + 2;
		or	SINDEX, ODD_SEG;
a875 1
	and	DATA_COUNT_ODD, 0x1, HCNT[0];
a909 2
		test	DATA_COUNT_ODD, 0x1 jz . + 2;
		or	SINDEX, ODD_SEG;
d1004 2
a1005 4
		clr	DATA_COUNT_ODD;
		test	SG_CACHE_SHADOW, ODD_SEG jz . + 2;
		or	DATA_COUNT_ODD, 0x1;
		clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
d1049 2
a1050 1
			test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
d1052 6
d1061 1
a1249 3
		/* Track odd'ness */
		test	HCNT[0], 0x1 jz . + 2;
		xor	DATA_COUNT_ODD, 0x1;
d1351 1
a1351 1
		test	DATA_COUNT_ODD, 0x1 jz target_ITloop;
d1511 1
a1511 1
	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
d1588 1
a1588 1
	test	DATA_COUNT_ODD, 0x1	jz mesgin_done;
d1717 1
a1717 1
	mov	SAVED_LUN, SCB_LUN;
d1860 1
a1860 1
		mov	A, SCB_LUN;
d1918 1
a1918 1
	mov	A, SCB_LUN;
@


1.15
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.13 2002/07/05 05:41:03 smurph Exp $ */
d683 1
d1103 1
a1103 1
			if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
@


1.14
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@@


1.13
log
@attempt to make ahc smaller.  change PCI interrupt handler.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.12 2002/06/30 18:25:58 smurph Exp $ */
d5 2
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d15 8
a22 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $
d44 1
a44 1
VERSION = "$Id: aic7xxx.seq,v 1.12 2002/06/30 18:25:58 smurph Exp $"
d46 1
d70 6
a75 6
        /*
         * Turn off the selection hardware.  We need to reset the
         * selection request in order to perform a new selection.
         */
        and     SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
        and     SIMODE1, ~ENBUSFREE;
d79 2
a80 7
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;
        }
        test    SCSISEQ, ENSELO jnz poll_for_selection;
        if ((ahc->features & AHC_TWIN) != 0) {
                xor     SBLKCTL,SELBUSB;        /* Toggle to the other bus */
                test    SCSISEQ, ENSELO         jnz poll_for_selection;
d82 6
a87 1
        cmp     WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d91 2
a92 2
        }
        test    SSTAT0, SELDO|SELDI     jnz selection;
d99 1
a99 1
                mov     A, QINPOS;
d102 1
a102 1
        mov     ARG_1, NEXT_QUEUED_SCB;
d104 5
a108 5
        /*
         * We have at least one queued SCB now and we don't have any 
         * SCBs in the list of SCBs awaiting selection.  Allocate a
         * card SCB for the host's SCB and get to work on it.
         */
d111 1
a111 1
        } else {
d113 1
a113 1
                mov     SCBPTR, ARG_1;
d115 1
a115 1
        or      SEQ_FLAGS2, SCB_DMA;
d118 3
a120 3
        /*
         * DMA the SCB from host ram into the current SCB location.
         */
d122 8
a129 8
        mov     ARG_1   call dma_scb;
        /*
         * Check one last time to see if this SCB was canceled
         * before we completed the DMA operation.  If it was,
         * the QINFIFO next pointer will not match our saved
         * value.
         */
        mov     A, ARG_1;
d131 4
a134 4
        cmp     NEXT_QUEUED_SCB, A jne abort_qinscb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                cmp     SCB_TAG, A je . + 2;
                mvi     SCB_MISMATCH call set_seqint;
d136 1
a136 1
        mov     NEXT_QUEUED_SCB, SCB_NEXT;
d139 6
a144 6
        if ((ahc->features & AHC_QUEUE_REGS) != 0) {
                mov     NONE, SNSCB_QOFF;
        } else {
                inc     QINPOS;
        }
        and     SEQ_FLAGS2, ~SCB_DMA;
d148 1
a148 1
         * Start the first entry on the waiting SCB list.
d154 7
a160 7
        /*
         * Twin channel devices cannot handle things like SELTO
         * interrupts on the "background" channel.  So, while
         * selecting, keep polling the current channel until
         * either a selection or reselection occurs.
         */
        test    SSTAT0, SELDO|SELDI     jz poll_for_selection;
d163 15
a177 15
        /*
         * We aren't expecting a bus free, so interrupt
         * the kernel driver if it happens.
         */
        mvi     CLRSINT1,CLRBUSFREE;
        if ((ahc->features & AHC_DT) == 0) {
                or      SIMODE1, ENBUSFREE;
        }

        /*
         * Guard against a bus free after (re)selection
         * but prior to enabling the busfree interrupt.  SELDI
         * and SELDO will be cleared in that case.
         */
        test    SSTAT0, SELDI|SELDO     jz bus_free_sel;
d180 2
a181 2
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d184 1
a184 1
                mvi     CLRSINT0, CLRSELDI;
d197 1
a197 1
		or	SEQ_FLAGS, CMDPHASE_PENDING;
d202 1
a202 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d206 1
a206 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d211 1
a211 1
                and     SAVED_SCSIID, SELID_MASK, SELID;
d213 4
a216 14
                if ((ahc->features & AHC_MULTI_TID) != 0) {
                        and     A, OID, TARGIDIN;
                } else if ((ahc->features & AHC_ULTRA2) != 0) {
                        and     A, OID, SCSIID_ULTRA2;
                } else {
                        and     A, OID, SCSIID;
                }
                or      SAVED_SCSIID, A;
                if ((ahc->features & AHC_TWIN) != 0) {
                        test    SBLKCTL, SELBUSB jz . + 2;
                        or      SAVED_SCSIID, TWIN_CHNLB;
                }
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        mov     CCSCBRAM, SAVED_SCSIID;
d218 12
a229 2
                        mov     DFDAT, SAVED_SCSIID;
                }
d234 2
a235 2
                 * XXX SCSI-1 may require us to assume lun 0 if
                 * ATN is false.
d257 1
d273 1
a273 1
		jnc	ident_messages_done;
d275 2
a276 1
		jc	ident_messages_done;
d301 18
a318 4
                or      SEQ_FLAGS, TARGET_CMD_IS_TAGGED;
                test    SCSISIGI, ATNI  jz . + 2;
                /* Initiator still wants to give us messages */
                call    target_inb;
d326 1
a326 1
                mvi     HOST_MSG_LOOP call set_seqint;
d330 1
a330 26

ident_messages_done:
		/* If ring buffer is full, return busy or queue full */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			and	A, HOST_TQINPOS, HS_MAILBOX;
		} else {
                        mov     A, KERNEL_TQINPOS;
		}
		cmp	TQINPOS, A jne tqinfifo_has_space;
		mvi	P_STATUS|BSYO call change_phase;
                test    SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
		mvi	STATUS_QUEUE_FULL call target_outb;
		jmp	target_busfree_wait;
		mvi	STATUS_BUSY call target_outb;
		jmp	target_busfree_wait;
tqinfifo_has_space:	
		/* Terminate the ident list */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	CCSCBRAM, SCB_LIST_NULL;
		} else {
			mvi	DFDAT, SCB_LIST_NULL;
		}
		or	SEQ_FLAGS, TARG_CMD_PENDING|IDENTIFY_SEEN;
                test    SCSISIGI, ATNI  jnz target_mesgout_pending;
		jmp	target_ITloop;
        }
d338 15
a352 17
        /* XXX test for and handle ONE BIT condition */
	test    SELID, ONEBIT jnz await_busfree;

	or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	and     SAVED_SCSIID, SELID_MASK, SELID;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                and     A, OID, SCSIID_ULTRA2;
        } else {
                and     A, OID, SCSIID;
        }
        or      SAVED_SCSIID, A;
        if ((ahc->features & AHC_TWIN) != 0) {
                test    SBLKCTL, SELBUSB        jz . + 2;
                or      SAVED_SCSIID, TWIN_CHNLB;
        }
        mvi     CLRSINT0, CLRSELDI;
        jmp     ITloop;
d356 2
a357 2
        call    add_scb_to_free_list;
        jmp     poll_for_work_loop;
d360 16
a375 16
        /*
         * If bus reset interrupts have been disabled (from a previous
         * reset), re-enable them now.  Resets are only of interest
         * when we have outstanding transactions, so we can safely
         * defer re-enabling the interrupt until, as an initiator,
         * we start sending out transactions again.
         */
        test    SIMODE1, ENSCSIRST      jnz . + 3;
        mvi     CLRSINT1, CLRSCSIRSTI;
        or      SIMODE1, ENSCSIRST;
        if ((ahc->features & AHC_TWIN) != 0) {
                and     SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
                test    SCB_SCSIID, TWIN_CHNLB jz . + 2;
                or      SINDEX, SELBUSB;
                mov     SBLKCTL,SINDEX;         /* select channel */
        }
d377 18
a394 21
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     SCSIID_ULTRA2, SCB_SCSIID;
        } else if ((ahc->features & AHC_TWIN) != 0) {
                and     SCSIID, TWIN_TID|OID, SCB_SCSIID;
        } else {
                mov     SCSIID, SCB_SCSIID;
        }
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                mov     SINDEX, SCSISEQ_TEMPLATE;
                test    SCB_CONTROL, TARGET_SCB jz . + 2;
                or      SINDEX, TEMODE;
                mov     SCSISEQ, SINDEX ret;
        } else {
                mov     SCSISEQ, SCSISEQ_TEMPLATE ret;
        }

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
a395 2
initialize_channel:
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
d397 12
a408 12
        if ((ahc->features & AHC_ULTRA) != 0) {
                test    SCB_CONTROL, ULTRAENB jz . + 2;
                or      SXFRCTL0, FAST20;
        } 
        /*
         * Initialize SCSIRATE with the appropriate value for this target.
         */
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    SCSIRATE, SCB_SCSIRATE, 2 ret;
        } else {
                mov     SCSIRATE, SCB_SCSIRATE ret;
        }
d417 10
a426 10
        /*
         * Drive REQ on the bus by enabling SCSI PIO.
         */
        or      SXFRCTL0, SPIOEN;
        /* Wait for the byte */
        test    SSTAT0, SPIORDY jz .;
        /* Prevent our read from triggering another REQ */
        and     SXFRCTL0, ~SPIOEN;
        /* Save latched contents */
        mov     DINDEX, SCSIDATL ret;
a437 1
	mvi	CLRSINT0, CLRSELDO;
d440 4
a443 4
        mov     SAVED_SCSIID, SCB_SCSIID;
        mov     SAVED_LUN, SCB_LUN;
        call    initialize_channel;
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d446 8
d460 1
d465 1
a465 1
                or      SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d473 1
a473 1
                mov     SCB_TARGET_INFO[SCB_INITIATOR_TAG] call target_outb;
d479 1
a479 1
                mov     SEQ_FLAGS, SCB_TARGET_INFO[SCB_TARGET_PHASES];
d481 3
a483 3
                test    SCB_CONTROL, MK_MESSAGE jz target_ITloop;
                mvi     P_MESGIN|BSYO call change_phase;
                jmp     host_target_message_loop;
d499 2
a500 3
                mov     RETURN_1, ALLZEROS;
                call    complete_target_cmd;
                cmp     RETURN_1, CONT_MSG_LOOP jne .;
d504 1
d506 3
a508 1
		mov	SCB_TAG	 call dma_scb;
d516 1
d527 1
a527 1
                /* Wait for preceding I/O session to complete. */
d530 4
a533 4
                and     SIMODE1, ~ENBUSFREE;
                if ((ahc->features & AHC_ULTRA2) != 0) {
                        clr     SCSIBUSL;
                }
d540 18
d577 1
a577 1
                add     SINDEX, CMDSIZE_TABLE, A;
d581 1
a581 1
                or      SXFRCTL0, SPIOEN;
d600 8
a607 9
                 * Data phases on the bus are from the
                 * perspective of the initiator.  The dma
                 * code looks at LASTPHASE to determine the
                 * data direction of the DMA.  Toggle it for
                 * target transfers.
		 */
                xor     LASTPHASE, IOI, SCB_TARGET_INFO[SCB_TARGET_DATA_DIR];
                or      SCB_TARGET_INFO[SCB_TARGET_DATA_DIR], BSYO
                        call change_phase;
d613 1
a613 1
                mov     SCB_TARGET_INFO[SCB_TARGET_STATUS] call target_outb;
d636 1
a636 1
                        mvi     28      call set_hcnt;
d646 1
d653 2
a654 1
	or	SEQ_FLAGS, IDENTIFY_SEEN;
d673 1
a673 1
        mvi     BAD_PHASE call set_seqint;
d679 3
a681 3
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;       /* Prevent bit leakage durint SELTO */
        }
d685 1
a685 1
        mvi     MISSED_BUSFREE call set_seqint;
d695 1
a695 1
        or      SXFRCTL0, CLRSTCNT|CLRCHN;
d706 3
a708 3
                if ((ahc->features & AHC_ULTRA) != 0) {
                        and     SXFRCTL0, ~(FAST20);
                }
d712 1
a712 1
	clr	SEQ_FLAGS ret;
d715 5
a719 5
        clr     A;                      /* add sizeof(struct scatter) */
        add     SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
        adc     SCB_RESIDUAL_SGPTR[1],A;
        adc     SCB_RESIDUAL_SGPTR[2],A;
        adc     SCB_RESIDUAL_SGPTR[3],A ret;
d723 2
a724 2
        test    CCSGCTL, CCSGEN jz return;
        test    CCSGCTL, CCSGDONE jz .;
d726 3
a728 3
        clr     CCSGCTL;
        test    CCSGCTL, CCSGEN jnz .;
        ret;
d730 34
a763 34
        /*
         * Do we need any more segments for this transfer?
         */
        test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

        /* Did we just finish fetching segs? */
        cmp     CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

        /* Are we actively fetching segments? */
        test    CCSGCTL, CCSGEN jnz return;

        /*
         * Do we have any prefetch left???
         */
        cmp     CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

        /*
         * Need to fetch segments, but we can only do that
         * if the command channel is completely idle.  Make
         * sure we don't have an SCB prefetch going on.
         */
        test    CCSCBCTL, CCSCBEN jnz return;

        /*
         * We fetch a "cacheline aligned" and sized amount of data
         * so we don't end up referencing a non-existant page.
         * Cacheline aligned is in quotes because the kernel will
         * set the prefetch amount to a reasonable level if the
         * cacheline size is unknown.
         */
        mvi     CCHCNT, SG_PREFETCH_CNT;
        and     CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
        bmov    CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
        mvi     CCSGCTL, CCSGEN|CCSGRESET ret;
d765 2
a766 2
        call    disable_ccsgen_fetch_done;
        and     CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
d769 20
a788 20
                /* Does the hardware have space for another SG entry? */
                test    DFSTATUS, PRELOAD_AVAIL jz return;
                bmov    HADDR, CCSGRAM, 7;
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;
                bmov    SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
                }
                call    sg_advance;
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                /* Load the segment */
                or      DFCNTRL, PRELOADEN;
        }
        ret;
d798 17
a814 17
        /*
         * If the ending address is on a cacheline boundary,
         * there is no need for an extra segment.
         */
        mov     A, HCNT[0];
        add     A, A, HADDR[0];
        and     A, CACHESIZE_MASK;
        test    A, 0xFF jz return;

        /*
         * If the transfer is less than a cachline,
         * there is no need for an extra segment.
         */
        test    HCNT[1], 0xFF   jnz calc_mwi_residual_final;
        test    HCNT[2], 0xFF   jnz calc_mwi_residual_final;
        add     NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
        jnc     return;
d817 6
a822 6
        mov     MWI_RESIDUAL, A;
        not     A;
        inc     A;
        add     HCNT[0], A;
        adc     HCNT[1], -1;
        adc     HCNT[2], -1 ret;
d826 3
a828 3
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_data_okay;
        mvi     NO_IDENT jmp set_seqint;
p_data_okay:
d837 2
a838 2
                /* We don't have any valid S/G elements */
                mvi     CCSGADDR, SG_PREFETCH_CNT;
d840 1
a840 1
        test    SEQ_FLAGS, DPHASE       jz data_phase_initialize;
d842 8
a849 8
        /*
         * If we re-enter the data phase after going through another
         * phase, our transfer location has almost certainly been
         * corrupted by the interveining, non-data, transfers.  Ask
         * the host driver to fix us up based on the transfer residual.
         */
        mvi     PDATA_REINIT    call set_seqint;
        jmp     data_phase_loop;
d852 1
a852 1
        /* We have seen a data phase for the first time */
d857 9
a865 9
         * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
         * flag in the highest byte of the data count.  We cannot
         * modify the saved values in the SCB until we see a save
         * data pointers message.
	 */
        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                /* The lowest address byte must be loaded last. */
                mov     SCB_DATACNT[3] call set_hhaddr;
        }
d868 1
a868 1
                bmov    SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
d872 5
a876 2
                mvi     DINDEX, SCB_RESIDUAL_DATACNT + 3;
                mvi     SCB_DATACNT + 3 call bcopy_5;
d878 2
a879 5
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
                call    calc_mwi_residual;
        }
        and     SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
        and     DATA_COUNT_ODD, 0x1, HCNT[0];
d886 1
a886 1
                }
d890 2
a891 2
        /* Guard against overruns */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;
d893 6
a898 6
        /*
         * Turn on `Bit Bucket' mode, wait until the target takes
         * us to another phase, and then notify the host.
         */
        and     DMAPARAMS, DIRECTION;
        mov     DFCNTRL, DMAPARAMS;
d900 2
a901 2
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT1,PHASEMIS jz .;
d903 1
a903 1
                test    SCSIPHASE, DATA_PHASE_MASK jnz .;
d905 3
a907 3
        and     SXFRCTL1, ~BITBUCKET;
        mvi     DATA_OVERRUN call set_seqint;
        jmp     ITloop;
d911 7
a917 7
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                mov     DFCNTRL, DMAPARAMS;
d919 20
a938 20
                call    idle_loop;
                /*
                 * The transfer is complete if either the last segment
                 * completes or the target changes phase.
                 */
                test    SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                                 /*
                                  * As a target, we control the phases,
                                  * so ignore PHASEMIS.
                                  */
                                test    SSTAT0, TARGET jnz ultra2_dma_loop;
                        }
                        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                                test    SSTAT1,PHASEMIS jz ultra2_dma_loop;
                        }
                } else {
                        test    DFCNTRL, SCSIEN jnz ultra2_dma_loop;
                }
d941 38
a978 38
                /*
                 * The transfer has terminated either due to a phase
                 * change, and/or the completion of the last segment.
                 * We have two goals here.  Do as much other work
                 * as possible while the data fifo drains on a read
                 * and respond as quickly as possible to the standard
                 * messages (save data pointers/disconnect and command
                 * complete) that usually follow a data phase.
                 */
                if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                        /*
                         * On chips with broken auto-flush, start
                         * the flushing process now.  We'll poke
                         * the chip from time to time to keep the
                         * flush process going as we complete the
                         * data phase.
                         */
                        or      DFCNTRL, FIFOFLUSH;
                }
                /*
                 * We assume that, even though data may still be
                 * transferring to the host, that the SCSI side of
                 * the DMA engine is now in a static state.  This
                 * allows us to update our notion of where we are
                 * in this transfer.
                 *
                 * If, by chance, we stopped before being able
                 * to fetch additional segments for this transfer,
                 * yet the last S/G was completely exhausted,
                 * call our idle loop until it is able to load
                 * another segment.  This will allow us to immediately
                 * pickup on the next segment on the next data phase.
                 *
                 * If we happened to stop on the last segment, then
                 * our residual information is still correct from
                 * the idle loop and there is no need to perform
                 * any fixups.
                 */
d980 5
a984 5
                test    SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
                /* Record if we've consumed all S/G entries */
                test    SSTAT2, SHVALID jnz residuals_correct;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     residuals_correct;
d987 3
a989 3
                test    SSTAT2, SHVALID jnz sgptr_fixup;
                call    idle_loop;
                jmp     ultra2_ensure_sg;
d992 16
a1007 16
                /*
                 * Fixup the residual next S/G pointer.  The S/G preload
                 * feature of the chip allows us to load two elements
                 * in addition to the currently active element.  We
                 * store the bottom byte of the next S/G pointer in
                 * the SG_CACEPTR register so we can restore the
                 * correct value when the DMA completes.  If the next
                 * sg ptr value has advanced to the point where higher
                 * bytes in the address have been affected, fix them
                 * too.
                 */
                test    SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
                test    SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
                add     SCB_RESIDUAL_SGPTR[1], -1;
                adc     SCB_RESIDUAL_SGPTR[2], -1; 
                adc     SCB_RESIDUAL_SGPTR[3], -1;
d1009 5
a1013 5
                and     SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
                clr     DATA_COUNT_ODD;
                test    SG_CACHE_SHADOW, ODD_SEG jz . + 2;
                or      DATA_COUNT_ODD, 0x1;
                clr     SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
d1015 8
a1022 8
                /*
                 * Go ahead and shut down the DMA engine now.
                 * In the future, we'll want to handle end of
                 * transfer messages prior to doing this, but this
                 * requires similar restructuring for pre-ULTRA2
                 * controllers.
                 */
                test    DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
d1024 40
a1063 40
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                                /*
                                 * On Rev A of the aic7890, the autoflush
                                 * feature doesn't function correctly.
                                 * Perform an explicit manual flush.  During
                                 * a manual flush, the FIFOEMP bit becomes
                                 * true every time the PCI FIFO empties
                                 * regardless of the state of the SCSI FIFO.
                                 * It can take up to 4 clock cycles for the
                                 * SCSI FIFO to get data into the PCI FIFO
                                 * and for FIFOEMP to de-assert.  Here we
                                 * guard against this condition by making
                                 * sure the FIFOEMP bit stays on for 5 full
                                 * clock cycles.
                                 */
                                or      DFCNTRL, FIFOFLUSH;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                        }
                        test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                } else {
                        /*
                         * We enable the auto-ack feature on DT capable
                         * controllers.  This means that the controller may
                         * have already transferred some overrun bytes into
                         * the data FIFO and acked them on the bus.  The only
                         * way to detect this situation is to wait for
                         * LAST_SEG_DONE to come true on a completed transfer
                         * and then test to see if the data FIFO is non-empty.
                         */
                        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
                        test    SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
                        test    DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
                        /* Overrun */
                        jmp     data_phase_loop;
                        test    DFSTATUS, FIFOEMP jz .;
                }
d1065 2
a1066 2
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz ultra2_fifoempty;
d1068 37
a1104 37
                and     DFCNTRL, ~(SCSIEN|HDMAEN);
                test    DFCNTRL, SCSIEN|HDMAEN jnz .;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        /*
                         * Keep HHADDR cleared for future, 32bit addressed
                         * only, DMA operations.
                         *
                         * Due to bayonette style S/G handling, our residual
                         * data must be "fixed up" once the transfer is halted.
                         * Here we fixup the HSHADDR stored in the high byte
                         * of the residual data cnt.  By postponing the fixup,
                         * we can batch the clearing of HADDR with the fixup.
                         * If we halted on the last segment, the residual is
                         * already correct.   If we are not on the last
                         * segment, copy the high address directly from HSHADDR.
                         * We don't need to worry about maintaining the
                         * SG_LAST_SEG flag as it will always be false in the
                         * case where an update is required.
                         */
                        or      DSCOMMAND1, HADDLDSEL0;
                        test    SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
                        mov     SCB_RESIDUAL_DATACNT[3], SHADDR;
                        clr     HADDR;
                        and     DSCOMMAND1, ~HADDLDSEL0;
                }
	} else {
                /* If we are the last SG block, tell the hardware. */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jz dma_last_sg;
                        if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
                                test    DMAPARAMS, DIRECTION jz dma_mid_sg;
                        }
d1109 1
a1109 1
                /* Start DMA data transfer. */
d1112 5
a1116 5
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        call    idle_loop;
                }
                test    SSTAT0,DMADONE  jnz dma_dmadone;
                test    SSTAT1,PHASEMIS jz dma_loop;    /* ie. underrun */
d1118 8
a1125 8
                /*
                 * We will be "done" DMAing when the transfer count goes to
                 * zero, or the target changes the phase (in light of this,
                 * it makes sense that the DMA circuitry doesn't ACK when
                 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
                 * the data FIFO should be flushed auto-magically on STCNT=0
                 * or a phase change, so just wait for FIFO empty status.
                 */
d1127 1
a1127 1
                test    DFCNTRL,DIRECTION       jnz dma_fifoempty;
d1129 1
a1129 1
                test    DFSTATUS,FIFOEMP        jz dma_fifoflush;
d1131 2
a1132 2
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz dma_fifoempty;
d1134 6
a1139 6
                /*
                 * Now shut off the DMA and make sure that the DMA
                 * hardware has actually stopped.  Touching the DMA
                 * counters, etc. while a DMA is active will result
                 * in an ILLSADDR exception.
                 */
d1141 1
a1141 1
                and     DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
d1143 38
a1180 38
                /*
                 * Some revisions of the aic78XX have a problem where, if the
                 * data fifo is full, but the PCI input latch is not empty, 
                 * HDMAEN cannot be cleared.  The fix used here is to drain
                 * the prefetched but unused data from the data fifo until
                 * there is space for the input latch to drain.
                 */
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        mov     NONE, DFDAT;
                }
                test    DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

                /* See if we have completed this last segment */
                test    STCNT[0], 0xff  jnz data_phase_finish;
                test    STCNT[1], 0xff  jnz data_phase_finish;
                test    STCNT[2], 0xff  jnz data_phase_finish;

                /*
                 * Advance the scatter-gather pointers if needed 
                 */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jz no_mwi_resid;
                        /*
                         * Reload HADDR from SHADDR and setup the
                         * count to be the size of our residual.
                         */
                        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                                bmov    HADDR, SHADDR, 4;
                                mov     HCNT, MWI_RESIDUAL;
                                bmov    HCNT[1], ALLZEROS, 2;
                        } else {
                                mvi     DINDEX, HADDR;
                                mvi     SHADDR call bcopy_4;
                                mov     MWI_RESIDUAL call set_hcnt;
                        }
                        clr     MWI_RESIDUAL;
                        jmp     sg_load_done;
d1182 4
a1185 4
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     data_phase_finish;
d1188 52
a1239 52
                 * Load the next SG element's data address and length
                 * into the DMA engine.  If we don't have hardware
                 * to perform a prefetch, we'll have to fetch the
                 * segment from host memory first.
		 */
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        /* Wait for the idle loop to complete */
                        test    CCSGCTL, CCSGEN jz . + 3;
                        call    idle_loop;
                        test    CCSGCTL, CCSGEN jnz . - 1;
                        bmov    HADDR, CCSGRAM, 7;
                        /*
                         * Workaround for flaky external SCB RAM
                         * on certain aic7895 setups.  It seems
                         * unable to handle direct transfers from
                         * S/G ram to certain SCB locations.
                         */
                        mov     SINDEX, CCSGRAM;
                        mov     SCB_RESIDUAL_DATACNT[3], SINDEX;
                } else {
                        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                                mov     ALLZEROS call set_hhaddr;
                        }
                        mvi     DINDEX, HADDR;
                        mvi     SCB_RESIDUAL_SGPTR      call bcopy_4;

                        mvi     SG_SIZEOF       call set_hcnt;

                        or      DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

                        call    dma_finish;

                        mvi     DINDEX, HADDR;
                        call    dfdat_in_7;
                        mov     SCB_RESIDUAL_DATACNT[3], DFDAT;
                }

                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

                        /*
                         * The lowest address byte must be loaded
                         * last as it triggers the computation of
                         * some items in the PCI block.  The ULTRA2
                         * chips do this on PRELOAD.
                         */
                        mov     HADDR, HADDR;
                }
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        call calc_mwi_residual;
                }
d1241 2
a1242 2
                /* Point to the new next sg in memory */
                call    sg_advance;
d1250 7
a1256 7
                /* Track odd'ness */
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;

                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jnz data_phase_loop;
                }
d1259 18
a1276 18
        /*
         * If the target has left us in data phase, loop through
         * the dma code again.  In the case of ULTRA2 adapters,
         * we should only loop if there is a data overrun.  For
         * all other adapters, we'll loop after each S/G element
         * is loaded as well as if there is an overrun.
         */
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                test    SSTAT0, TARGET jnz data_phase_done;
        }
        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                test    SSTAT1, REQINIT jz .;
                if ((ahc->features & AHC_DT) == 0) {
                        test    SSTAT1,PHASEMIS jz data_phase_loop;
                } else {
                        test    SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
                }
        }
d1279 42
a1320 42
        /*
         * After a DMA finishes, save the SG and STCNT residuals back into
         * the SCB.  We use STCNT instead of HCNT, since it's a reflection
         * of how many bytes were transferred on the SCSI (as opposed to the
         * host) bus.
         */
        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                /* Kill off any pending prefetch */
                call    disable_ccsgen;
	}

        if ((ahc->features & AHC_ULTRA2) == 0) {
                /*
                 * Clear the high address byte so that all other DMA
                 * operations, which use 32bit addressing, can assume
                 * HHADDR is 0.
                 */
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     ALLZEROS call set_hhaddr;
                }
	}

        /*
         * Update our residual information before the information is
         * lost by some other type of SCSI I/O (e.g. PIO).  If we have
         * transferred all data, no update is needed.
         *
         */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
          && ahc->pci_cachesize != 0) {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        test    MWI_RESIDUAL, 0xFF jz bmov_resid;
                }
                mov     A, MWI_RESIDUAL;
                add     SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
                clr     A;
                adc     SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
                adc     SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
                clr     MWI_RESIDUAL;
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        jmp     . + 2;
d1322 8
a1329 8
                        bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
                }
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
                mov     SCB_RESIDUAL_DATACNT[0], STCNT[0];
                mov     SCB_RESIDUAL_DATACNT[1], STCNT[1];
                mov     SCB_RESIDUAL_DATACNT[2], STCNT[2];
d1332 5
a1336 5
        /*
         * Since we've been through a data phase, the SCB_RESID* fields
         * are now initialized.  Clear the full residual flag.
         */
        and     SCB_SGPTR[0], ~SG_FULL_RESID;
d1339 2
a1340 2
                /* Clear the channel in case we return to data phase later */
                or      SXFRCTL0, CLRSTCNT|CLRCHN;
d1344 1
a1344 1
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1349 2
a1350 1
		 * initiator before changing phase.
d1354 8
d1363 2
a1364 2
        } else {
                jmp     ITloop;
d1372 2
a1373 2
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_command_okay;
        mvi     NO_IDENT jmp set_seqint;
d1376 14
a1389 14
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HCNT[0], SCB_CDB_LEN,  1;
                bmov    HCNT[1], ALLZEROS, 2;
                mvi     SG_CACHE_PRE, LAST_SEG;
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    STCNT[0], SCB_CDB_LEN, 1;
                bmov    STCNT[1], ALLZEROS, 2;
        } else {
                mov     STCNT[0], SCB_CDB_LEN;
                clr     STCNT[1];
                clr     STCNT[2];
        }
        add     NONE, -13, SCB_CDB_LEN;
        mvi     SCB_CDB_STORE jnc p_command_embedded;
d1391 15
a1405 15
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HADDR[0], SCB_CDB_PTR, 4;
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
        } else {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        bmov    HADDR[0], SCB_CDB_PTR, 4;
                        bmov    HCNT, STCNT, 3;
                } else {
                        mvi     DINDEX, HADDR;
                        mvi     SCB_CDB_PTR call bcopy_4;
                        mov     SCB_CDB_LEN call set_hcnt;
                }
                mvi     DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
        }
        jmp     p_command_loop;
d1407 4
a1410 4
        /*
         * The data fifo seems to require 4 byte aligned
         * transfers from the sequencer.  Force this to
         * be the case by clearing HADDR[0] even though
d1412 16
a1427 16
         */
        clr     HADDR[0];
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
                bmov    DFDAT, SCB_CDB_STORE, 12; 
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        /*
                         * On the 7895 the data FIFO will
                         * get corrupted if you try to dump
                         * data from external SCB memory into
                         * the FIFO while it is enabled.  So,
                         * fill the fifo and then enable SCSI
                         * transfers.
                         */
                        mvi     DFCNTRL, (DIRECTION|FIFORESET);
d1431 32
a1462 24
                bmov    DFDAT, SCB_CDB_STORE, 12; 
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
                } else {
                        or      DFCNTRL, FIFOFLUSH;
		}
	} else {
                mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
                call    copy_to_fifo_6;
                call    copy_to_fifo_6;
                or      DFCNTRL, FIFOFLUSH;
	}
p_command_loop:
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT0, SDONE jnz . + 2;
                test    SSTAT1, PHASEMIS jz p_command_loop;
                /*
                 * Wait for our ACK to go-away on it's own
                 * instead of being killed by SCSIEN getting cleared.
                 */
                test    SCSISIGI, ACKI jnz .;
        } else {
                test    DFCNTRL, SCSIEN jnz p_command_loop;
        }
a1464 4
        if ((ahc->features & AHC_ULTRA2) != 0) {
                /* Drop any residual from the S/G Preload queue */
                or      SXFRCTL0, CLRSTCNT;
        }
d1472 1
a1472 2
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_status_okay;
        mvi     NO_IDENT jmp set_seqint;
d1474 2
a1475 1
        mov     SCB_SCSI_STATUS, SCSIDATL;
d1503 6
a1508 6
        /* Turn on ATN for the retry */
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1514 3
a1516 3
        or      SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
        test    SCB_CONTROL, DISCENB jnz . + 2;
        and     SINDEX, ~DISCENB;
d1566 1
a1566 1
        cmp     A,MSG_IGN_WIDE_RESIDUE  je mesgin_ign_wide_residue;
d1579 1
a1579 1
        mvi     HOST_MSG_LOOP call set_seqint;
d1586 8
a1593 8
        test    SCSIRATE, WIDEXFER jz mesgin_reject;
        /* Pull the residue byte */
        mvi     ARG_1   call inb_next;
        cmp     ARG_1, 0x01 jne mesgin_reject;
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
        test    DATA_COUNT_ODD, 0x1     jz mesgin_done;
        mvi     IGN_WIDE_RES call set_seqint;
        jmp     mesgin_done;
d1596 3
d1600 1
a1600 1
        mvi     MSG_MESSAGE_REJECT      call mk_mesg;
a1604 1
mesgin_complete:
d1617 25
d1643 6
a1648 10
/*
 * If ATN is raised, we still want to give the target a message.
 * Perhaps there was a parity error on this last message byte.
 * Either way, the target should take us to message out phase
 * and then attempt to complete the command again.  We should use a
 * critical section here to guard against a timeout triggering
 * for this command and setting ATN while we are still processing
 * the completion.
        test    SCSISIGI, ATNI jnz mesgin_done;
 */
d1650 6
a1655 5
/*
 * See if we attempted to deliver a message but the target ingnored us.
 */
        test    SCB_CONTROL, MK_MESSAGE jz . + 2;
        mvi     MKMSG_FAILED call set_seqint;
d1657 6
a1662 6
/*
 * Check for residuals
 */
        test    SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
        test    SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
d1664 1
a1664 1
        test    SCB_SCSI_STATUS,0xff    jz complete;    /* Good Status? */
d1666 1
a1666 1
        or      SCB_SGPTR, SG_RESID_VALID;
d1669 2
a1670 2
        test    SCB_SCSI_STATUS, 0xff   jz complete;    /* Just a residual? */
        mvi     BAD_STATUS call set_seqint;             /* let driver know */
d1672 1
a1672 1
        call    add_scb_to_free_list;
d1703 11
a1713 11
        /*
         * If ATN is raised, we still want to give the target a message.
         * Perhaps there was a parity error on this last message byte
         * or we want to abort this command.  Either way, the target
         * should take us to message out phase and then attempt to
         * disconnect again.
         * XXX - Wait for more testing.
        test    SCSISIGI, ATNI jnz mesgin_done;
         */

        test    SCSISIGI, ATNI jnz mesgin_done;
d1715 7
a1721 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    add_scb_to_disc_list;
        }
        test    SCB_CONTROL, TAG_ENB jnz await_busfree;
        mov     ARG_1, SCB_TAG;
        mov     SAVED_LUN, SCB_LUN;
        mov     SCB_SCSIID      call set_busy_target;
d1735 19
a1753 19
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     NONE,SCSIDATL;          /*dummy read from latch to ACK*/
                test    SEQ_FLAGS, DPHASE       jz ITloop;
        } else {
                test    SEQ_FLAGS, DPHASE       jz mesgin_done;
        }

	/*
         * If we are asked to save our position at the end of the
         * transfer, just mark us at the end rather than perform a
         * full save.
         */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
        or      SCB_SGPTR, SG_LIST_NULL;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                jmp     ITloop;
        } else {
                jmp     mesgin_done;
        }
d1757 3
a1759 3
        /*
         * The SCB_SGPTR becomes the next one we'll download,
         * and the SCB_DATAPTR becomes the current SHADDR.
d1765 4
a1768 4
                if ((ahc->features & AHC_ULTRA2) == 0) {
                        mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                }
                bmov    SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1771 3
a1773 3
                mvi     SHADDR call bcopy_4;
                mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                mvi     SCB_RESIDUAL_DATACNT call bcopy_8;
d1775 1
a1775 1
        jmp     ITloop;
d1781 2
a1782 1
 * code do the rest.
d1790 1
d1798 8
a1805 8
        shr     DINDEX, 4, SINDEX;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, SAVED_LUN;
                add     DINDEX, SCB_64_BTT;
        } else {
                add     DINDEX, BUSY_TARGETS;
        }
        mov     DINDIR, ARG_1 ret;
d1813 34
a1846 34
        /*
         * Determine whether a target is using tagged or non-tagged
         * transactions by first looking at the transaction stored in
         * the busy target array.  If there is no untagged transaction
         * for this target or the transaction is for a different lun, then
         * this must be an untagged transaction.
         */
        shr     SINDEX, 4, SAVED_SCSIID;
        and     SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                add     SINDEX, SCB_64_BTT;
                mov     SCBPTR, SAVED_LUN;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -SCB_64_BTT, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(SCB_64_BTT + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
	} else {
                add     SINDEX, BUSY_TARGETS;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -BUSY_TARGETS, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(BUSY_TARGETS + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
d1848 1
a1848 1
        mov     ARG_1, SINDIR;
d1851 24
a1874 24
                mov     ARG_1 call findSCB;
        } else {
                mov     SCBPTR, ARG_1;
	}
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                jmp setup_SCB_id_lun_okay;
        } else {
                /*
                 * We only allow one untagged command per-target
                 * at a time.  So, if the lun doesn't match, look
                 * for a tag message.
                 */
                mov     A, SCB_LUN;
                cmp     SAVED_LUN, A    je setup_SCB_id_lun_okay;
                if ((ahc->flags & AHC_PAGESCBS) != 0) {
                        /*
                         * findSCB removes the SCB from the
                         * disconnected list, so we must replace
                         * it there should this SCB be for another
                         * lun.
                         */
                        call    cleanup_scb;
                }
        }
d1885 3
a1887 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x80;
        }
d1890 3
a1892 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x1;
        }
d1894 3
a1896 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x2;
        }
d1899 7
a1905 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     ARG_1   call findSCB;
        } else {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     SCBPTR, ARG_1;
        }
d1912 8
a1919 8
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x4;
        }
        mov     A, SCB_SCSIID;
        cmp     SAVED_SCSIID, A jne not_found_cleanup_scb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x8;
        }
d1921 2
a1922 2
        mov     A, SCB_LUN;
        cmp     SAVED_LUN, A    jne not_found_cleanup_scb;
d1924 3
a1926 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x10;
        }
d1929 9
a1937 9
        test    SCB_CONTROL, TAG_ENB    jnz setup_SCB_tagged;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     A, SCBPTR;
        }
        mvi     ARG_1, SCB_LIST_NULL;
        mov     SAVED_SCSIID    call    set_busy_target;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, A;
        }
d1939 1
a1939 1
        mvi     SEQ_FLAGS,IDENTIFY_SEEN;        /* make note of IDENTIFY */
d1947 3
a1949 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    cleanup_scb;
        }
d1951 1
a1951 1
        mvi     NO_MATCH call set_seqint;
d1955 5
a1959 5
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1978 1
a1978 1
        mvi     PERR_DETECTED call set_seqint;
d2017 1
a2017 1
         * we must wait at least a data release delay plus
d2050 5
a2054 5
        mov     A, SINDEX;                      /* Tag passed in SINDEX */
        cmp     DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
        mov     SCBPTR, DISCONNECTED_SCBH;      /* Initialize SCBPTR */
        mvi     ARG_2, SCB_LIST_NULL;           /* Head of list */
        jmp     findSCB_loop;
d2056 1
a2056 1
        cmp     SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d2060 1
a2060 1
        cmp     SCB_TAG, A      jne findSCB_next;
d2064 1
a2064 1
        mov     SINDEX, SCBPTR;
d2072 5
a2076 5
        /*
         * We didn't find it.  Page in the SCB.
         */
        mov     ARG_1, A; /* Save tag */
        mov     ALLZEROS call get_free_or_disc_scb;
d2089 1
a2089 1
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
d2094 2
a2095 2
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
                mvi     1       call set_hcnt;
d2112 1
a2112 1
        mvi     PERR_DETECTED call set_seqint;
d2122 3
a2124 3
        if ((ahc->features & AHC_DT) == 0) {
                and     SCSISIGO, PHASE_MASK, SCSISIGI;
        }
d2129 1
a2129 1
        mov     HCNT[0], SINDEX;
d2131 2
a2132 2
        clr     HCNT[1];
        clr     HCNT[2] ret;
d2140 1
a2140 1
        mov     DINDIR, SINDIR;
d2205 5
a2209 5
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE_64;
                } else {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE;
                }
d2214 2
a2215 2
                mvi     CCHCNT, SCB_UPLOAD_SIZE;
                if ((ahc->features & AHC_ULTRA2) == 0) {
d2217 1
a2217 1
                        bmov    CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
d2220 6
a2225 6
                } else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
                        mvi     CCSCBCTL, CCARREN|CCSCBRESET;
                        cmp     CCSCBCTL, ARRDONE|CCARREN jne .;
                        mvi     CCHCNT, SCB_UPLOAD_SIZE;
                        mvi     CCSCBCTL, CCSCBEN|CCSCBRESET;
                        cmp     CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d2237 1
a2237 1
                mvi     SCB_DOWNLOAD_SIZE call set_hcnt;
d2242 2
a2243 2
                mvi     SINDEX, SCB_BASE;
                add     A, SCB_DOWNLOAD_SIZE, SINDEX;
d2245 1
a2245 1
                call    copy_to_fifo_8;
d2248 1
a2248 1
                jmp     dma_finish;
d2250 19
a2268 19
                mvi     DINDEX, SCB_BASE;
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        /*
                         * The PCI module will only issue a PCI
                         * retry if the data FIFO is empty.  If the
                         * host disconnects in the middle of a
                         * transfer, we must empty the fifo of all
                         * available data to force the chip to
                         * continue the transfer.  This does not
                         * happen for SCSI transfers as the SCSI module
                         * will drain the FIFO as data is made available.
                         * When the hang occurs, we know that a multiple
                         * of 8 bytes are in the FIFO because the PCI
                         * module has an 8 byte input latch that only
                         * dumps to the FIFO when HCNT == 0 or the
                         * latch is full.
                         */
                        clr     A;
                        /* Wait for at least 8 bytes of data to arrive. */
d2270 1
a2270 1
                        test    DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
d2272 8
a2279 8
                        test    DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        /*
                         * The PCI module no longer intends to perform
                         * a PCI transaction.  Drain the fifo.
                         */
d2281 11
a2291 11
                        not     A, HCNT;
                        add     A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
                        and     A, ~0x7;
                        mov     DINDIR,DFDAT;
                        cmp     DINDEX, A jne . - 1;
                        cmp     DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
                                je      dma_finish_nowait;
                        /* Restore A as the lines left to transfer. */
                        add     A, -SCB_BASE, DINDEX;
                        shr     A, 3;
                        jmp     dma_scb_hang_fifo;
d2293 9
a2301 10
                        and     DFCNTRL, ~HDMAEN;
                        test    DFCNTRL, HDMAEN jnz .;
                        add     SEQADDR0, A;
                } else {
                        call    dma_finish;
                }
		/* If we were putting the SCB, we are done */
                call    dfdat_in_8;
                call    dfdat_in_8;
                call    dfdat_in_8;
d2303 1
a2303 1
                mov     DINDIR,DFDAT;
d2316 2
a2317 2
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
d2319 1
a2319 1
        mov     DFDAT,SINDIR;
d2321 1
a2321 1
        mov     DFDAT,SINDIR;
d2323 4
a2326 4
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR ret;
d2347 3
a2349 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                test    SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
        }
d2363 3
a2365 3
        or      DSCOMMAND1, HADDLDSEL0;
        and     HADDR, SG_HIGH_ADDR_BITS, SINDEX;
        and     DSCOMMAND1, ~HADDLDSEL0 ret;
d2374 1
a2374 1
        mvi     NO_FREE_SCB call set_seqint;
d2378 1
a2378 1
        mov     DISCONNECTED_SCBH, SCB_NEXT;
d2381 1
a2381 1
        mov     SCB_TAG jmp dma_scb;
d2400 2
a2401 2
        mov     INTSTAT, SINDEX;
        nop;
d2403 1
a2403 1
        ret;
@


1.12
log
@New aicasm synced with FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.11 2002/06/28 00:34:55 smurph Exp $ */
d35 1
a35 1
VERSION = "$Id: aic7xxx.seq,v 1.11 2002/06/28 00:34:55 smurph Exp $"
d338 4
a341 2
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
        and     SAVED_SCSIID, SELID_MASK, SELID;
d1652 1
@


1.11
log
@Return of new ahc
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.seq,v 1.9 2002/02/16 04:36:33 smurph Exp $ */
d35 2
a36 1
VERSION = "$Id: aic7xxx.seq,v 1.9 2002/02/16 04:36:33 smurph Exp $"
d85 1
a85 1
BEGIN_CRITICAL
d106 1
a106 1
END_CRITICAL
d120 1
a120 1
BEGIN_CRITICAL
d135 1
a135 1
END_CRITICAL
d1376 1
a1376 1
         * we aren't going to touch host memeory.
d1982 1
a1982 1
BEGIN_CRITICAL
d2004 1
a2004 1
END_CRITICAL
d2129 1
a2129 1
 * Either post or fetch and SCB from host memory based on the
d2287 1
a2287 1
BEGIN_CRITICAL
d2291 1
a2291 1
END_CRITICAL
d2305 1
a2305 1
BEGIN_CRITICAL
d2314 1
a2314 1
END_CRITICAL
d2317 1
a2317 1
BEGIN_CRITICAL
d2321 1
a2321 1
END_CRITICAL
d2329 1
a2329 1
BEGIN_CRITICAL
d2332 1
a2332 1
END_CRITICAL
@


1.10
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.93 2000/01/07 23:08:20 gibbs Exp $
d35 2
a38 3
/*
#include <cam/scsi/scsi_message.h>
*/
d58 7
a64 12
reset:
	clr	SCSISIGO;		/* De-assert BSY */
	mvi	MSG_OUT, MSG_NOOP;	/* No message to send */
	and	SXFRCTL1, ~BITBUCKET;
	/* Always allow reselection */
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ_TEMPLATE;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		clr	CCSGCTL;
		clr	CCSCBCTL;
	}

d68 7
a74 2
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		mov	A, QINPOS;
d76 1
a77 5
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		and	SEQCTL, ~PAUSEDIS;
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
	test	SCSISEQ, ENSELO	jnz poll_for_work_loop;
a78 6
		/*
		 * Twin channel devices cannot handle things like SELTO
		 * interrupts on the "background" channel.  So, if we
		 * are selecting, keep polling the current channel util
		 * either a selection or reselection occurs.
		 */
d80 2
a81 5
		test	SSTAT0, SELDO|SELDI	jnz selection;
		test	SCSISEQ, ENSELO	jnz poll_for_work;
		xor	SBLKCTL,SELBUSB;	/* Toggle back */
	}
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d84 1
a86 2
		mov	NONE, SNSCB_QOFF;
		inc	QINPOS;
d88 1
a88 1
		or	SEQCTL, PAUSEDIS;
a89 2
		inc	QINPOS;
		and	SEQCTL, ~PAUSEDIS;
d91 1
d93 5
a97 6
/*
 * We have at least one queued SCB now and we don't have any 
 * SCBs in the list of SCBs awaiting selection.  If we have
 * any SCBs available for use, pull the tag from the QINFIFO
 * and get to work on it.
 */
d100 1
a100 7
	}

dequeue_scb:
	add	A, -1, QINPOS;
	mvi	QINFIFO_OFFSET call fetch_byte;

	if ((ahc->flags & AHC_PAGESCBS) == 0) {
d102 1
a102 1
		mov	SCBPTR, RETURN_2;
d104 2
d107 3
a109 3
/*
 * DMA the SCB from host ram into the current SCB location.
 */
d111 13
a123 14
	mov	RETURN_2	 call dma_scb;

/*
 * Preset the residual fields in case we never go through a data phase.
 * This isn't done by the host so we can avoid a DMA to clear these
 * fields for the normal case of I/O that completes without underrun
 * or overrun conditions.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, SCB_DATACNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],SCB_DATACNT[0];
		mov	SCB_RESID_DCNT[1],SCB_DATACNT[1];
		mov	SCB_RESID_DCNT[2],SCB_DATACNT[2];
d125 1
a125 7
	mov	SCB_RESID_SGCNT, SCB_SGCOUNT;

start_scb:
	/*
	 * Place us on the waiting list in case our selection
	 * doesn't win during bus arbitration.
	 */
d128 7
d137 1
a137 1
	 * Pull the first entry off of the waiting SCB list.
a140 1
	jmp	poll_for_work;
d142 8
a149 52
start_selection:
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		and	A,SELBUSB,SCB_TCL;	/* Get new channel bit */
		or	SINDEX,A;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
initialize_scsiid:
	mov	SINDEX, SCSISEQ_TEMPLATE;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SCB_CONTROL, TARGET_SCB jz . + 4;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mov	SCSIID_ULTRA2, SCB_CMDPTR[2];
		} else {
			mov	SCSIID, SCB_CMDPTR[2];
		}
		or	SINDEX, TEMODE;
		jmp	initialize_scsiid_fini;
	}
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID_ULTRA2, OID;	/* Clear old target */
		or	SCSIID_ULTRA2, A;
	} else {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID, OID;		/* Clear old target */
		or	SCSIID, A;
	}
initialize_scsiid_fini:
	mov	SCSISEQ, SINDEX ret;

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
	or	SXFRCTL0, CLRSTCNT|CLRCHN, SINDEX;
set_transfer_settings:
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
/*
 * Initialize SCSIRATE with the appropriate value for this target.
 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}
d152 15
a167 1
	mvi	CLRSINT0, CLRSELDI;
d169 2
a170 2
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d173 1
a180 1
		mvi	CLRSINT1, CLRBUSFREE;
d191 1
a191 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d195 1
a195 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d200 1
a200 7
		and	SAVED_TCL, SELID_MASK, SELID;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_TCL;
		} else {
			mov	DFDAT, SAVED_TCL;
		}

d202 14
a215 8
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	CCSCBRAM, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	CCSCBRAM, OID, SCSIID_ULTRA2;
			} else {
				and	CCSCBRAM, OID, SCSIID;
			}
d217 2
a218 11
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	DFDAT, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	DFDAT, OID, SCSIID_ULTRA2;
			} else {
				and	DFDAT, OID, SCSIID;
			}
		}

		/* No tag yet */
		mvi	INITIATOR_TAG, SCB_LIST_NULL;
d223 2
a238 1
		/* XXX May need to be more lax here for older initiators... */
d288 4
d299 1
a299 2
		mvi	INTSTAT, HOST_MSG_LOOP;
		nop;
d309 1
a309 1
		mov	A, KERNEL_TQINPOS;
d313 1
a313 1
		cmp	INITIATOR_TAG, SCB_LIST_NULL je . + 3;
d326 1
a326 1
		test	SCSISIGI, ATNI	jnz target_mesgout_pending_msg;
d328 86
a413 1
		
d420 10
a429 33
		/*
		 * Drive REQ on the bus by enabling SCSI PIO.
		 */
		or	SXFRCTL0, SPIOEN;
		/* Wait for the byte */
		test	SSTAT0, SPIORDY jz .;
		/* Prevent our read from triggering another REQ */
		and	SXFRCTL0, ~SPIOEN;
		/* Save latched contents */
		mov	DINDEX, SCSIDATL ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
/*
 * Reselection has been initiated by a target. Make a note that we've been
 * reselected, but haven't seen an IDENTIFY message from the target yet.
 */
initiator_reselect:
	/* XXX test for and handle ONE BIT condition */
	and	SAVED_TCL, SELID_MASK, SELID;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_TCL, SELBUSB;
	}
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;		/*
						 * We aren't expecting a
						 * bus free, so interrupt
						 * the kernel driver if it
						 * happens.
						 */
	jmp	ITloop;
a440 1
/*and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;*/
d444 4
a447 2
	mov	SAVED_TCL, SCB_TCL;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
a455 1
		mvi	CLRSINT1,CLRBUSFREE;
d460 1
a460 2
		and	A, LID, SCB_TCL;
		or	A, MSG_IDENTIFYFLAG call target_outb;
d468 1
a468 2
		mov	SCB_INITIATOR_TAG call target_outb;
		mov	INITIATOR_TAG, SCB_INITIATOR_TAG;
d474 1
a474 1
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
d476 3
a478 1

d494 3
a499 3
		mov	RETURN_1, ALLZEROS;
		call	complete_target_cmd;
		cmp	RETURN_1, CONT_MSG_LOOP jne .;
d506 1
d508 1
a509 1
target_mesgout_pending_msg:
d519 1
a519 1
		/* Wait for preceeding I/O session to complete. */
d522 4
d551 1
a551 1
		add	SINDEX, TARG_SCSIRATE, A;
d555 1
a556 1
		or	SXFRCTL0, SPIOEN;
d574 9
a582 10
		 * Data direction flags are from the
		 * perspective of the initiator.
		 */
		test	SCB_TARGET_PHASES[1], TARGET_DATA_IN jz . + 4;
		mvi	LASTPHASE, P_DATAOUT;
		mvi	P_DATAIN|BSYO call change_phase;
		jmp	. + 3;
		mvi	LASTPHASE, P_DATAIN;
		mvi	P_DATAOUT|BSYO call change_phase;
		mov	ALLZEROS call initialize_channel;
d588 1
a588 1
		mov	SCB_TARGET_STATUS call target_outb;
d611 1
a611 3
			mvi	HCNT[0], 28;
			clr	HCNT[1];
			clr	HCNT[2];
d619 1
a619 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
a620 9
	mvi	SPIOEN call	initialize_channel;

	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;

d634 1
d646 1
a646 1
	mvi	INTSTAT,BAD_PHASE;
d652 3
d658 1
a658 1
	mvi	INTSTAT, BAD_PHASE;
d668 1
d679 3
a681 1
		and	SXFRCTL0, ~(FAST20);
d687 78
d766 31
a796 20
 * If we re-enter the data phase after going through another phase, the
 * STCNT may have been cleared, so restore it from the residual field.
 */
data_phase_reinit:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		/*
		 * The preload circuitry requires us to
		 * reload the address too, so pull it from
		 * the shaddow address.
		 */
		bmov	HADDR, SHADDR, 4;
		bmov	HCNT, SCB_RESID_DCNT, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, SCB_RESID_DCNT, 3;
	} else {
		mvi	DINDEX, STCNT;
		mvi	SCB_RESID_DCNT	call bcopy_3;
	}
	and	DATA_COUNT_ODD, 0x1, SCB_RESID_DCNT[0];
	jmp	data_phase_loop;
d799 3
a808 4
	call	assert;			/*
					 * Ensure entering a data
					 * phase is okay - seen identify, etc.
					 */
d810 2
a811 1
		mvi	CCSGADDR, CCSGADDR_MAX;
d813 10
a822 1
	test	SEQ_FLAGS, DPHASE	jnz data_phase_reinit;
d824 2
a825 1
	/* We have seen a data phase */
d830 4
a833 3
	 * Also set SG_COUNT and SG_NEXT in memory since we cannot
	 * modify the values in the SCB itself until we see a
	 * save data pointers message.
d835 4
d841 1
d845 2
d848 5
a852 1
	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];
d859 1
a859 1
		}
d862 3
a864 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SG_COUNT, SCB_SGCOUNT, 5;
	} else {
		mvi	DINDEX, SG_COUNT;
		mvi	SCB_SGCOUNT	call bcopy_5;
	}
d866 6
a871 9
data_phase_loop:
/* Guard against overruns */
	test	SG_COUNT, 0xff jnz data_phase_inbounds;
/*
 * Turn on 'Bit Bucket' mode, set the transfer count to
 * 16meg and let the target run until it changes phase.
 * When the transfer completes, notify the host that we
 * had an overrun.
 */
d873 2
a874 5
	and	DMAPARAMS, ~(HDMAEN|SDMAEN);
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT, ALLONES, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, ALLONES, 3;
d876 1
a876 3
		mvi	STCNT[0], 0xFF;
		mvi	STCNT[1], 0xFF;
		mvi	STCNT[2], 0xFF;
d878 4
a882 2
/* If we are the last SG block, tell the hardware. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd;
d884 194
a1077 5
		or	SG_CACHEPTR, LAST_SEG;
	} else {
		if ((ahc->flags & AHC_TARGETMODE) != 0) {
			test	SSTAT0, TARGET jz . + 2;
			test	DMAPARAMS, DIRECTION jz data_phase_wideodd;
d1079 1
d1081 2
a1082 4
	}
data_phase_wideodd:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SINDEX, ALLONES;
d1084 22
a1105 7
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
data_phase_dma_loop:
		test	SSTAT0,	SDONE jnz data_phase_dma_done;
		test	SSTAT1,PHASEMIS	jz data_phase_dma_loop;	/* ie. underrun */
	} else {
		mov	DMAPARAMS  call dma;
	}
d1107 52
a1158 23
data_phase_dma_done:
/* Go tell the host about any overruns */
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun;

/* See if we completed this segment */
	test	STCNT[0], 0xff	jnz data_phase_finish;
	test	STCNT[1], 0xff	jnz data_phase_finish;
	test	STCNT[2], 0xff	jnz data_phase_finish;

/*
 * Advance the scatter-gather pointers if needed 
 */
sg_advance:
	dec	SG_COUNT;	/* one less segment to go */

	test	SG_COUNT, 0xff	jz data_phase_finish; /* Are we done? */
/*
 * Load a struct scatter and set up the data address and length.
 * If the working value of the SG count is nonzero, then
 * we need to load a new set of values.
 *
 * This, like all DMA's, assumes little-endian host data storage.
 */
a1159 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/*
		 * Do we have any prefetch left???
		 */
		cmp	CCSGADDR, CCSGADDR_MAX jne prefetched_segs_avail;

d1161 52
a1212 37
		 * Fetch MIN(CCSGADDR_MAX, (SG_COUNT * 8)) bytes.
		 */
		add	A, -(CCSGRAM_MAXSEGS + 1), SG_COUNT;
		mvi	A, CCSGADDR_MAX;
		jc	. + 2;
		shl	A, 3, SG_COUNT;
		mov	CCHCNT, A;
		bmov	CCHADDR, SG_NEXT, 4;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		and	CCSGCTL, ~CCSGEN;
		test	CCSGCTL, CCSGEN jnz .;
		mvi	CCSGCTL, CCSGRESET;
prefetched_segs_avail:
		bmov 	HADDR, CCSGRAM, 8;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SG_NEXT	call bcopy_4;

		mvi	HCNT[0],SG_SIZEOF;
		clr	HCNT[1];
		clr	HCNT[2];

		or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

		call	dma_finish;

		/*
		 * Copy data from FIFO into SCB data pointer and data count.
		 * This assumes that the SG segments are of the form:
		 * struct ahc_dma_seg {
		 *	u_int32_t	addr;	four bytes, little-endian order
		 *	u_int32_t	len;	four bytes, little endian order
		 * };
		 */
		mvi	HADDR	call dfdat_in_7;
	}
d1214 2
a1215 3
	/* Track odd'ness */
	test	HCNT[0], 0x1 jz . + 2;
	xor	DATA_COUNT_ODD, 0x1;
d1217 1
a1217 2
	if ((ahc->features & AHC_ULTRA2) == 0) {
		/* Load STCNT as well.  It is a mirror of HCNT */
d1223 7
a1230 18

/* Advance the SG pointer */
	clr	A;			/* add sizeof(struct scatter) */
	add	SG_NEXT[0],SG_SIZEOF;
	adc	SG_NEXT[1],A;

	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_loop;
	}
	test	SSTAT1, REQINIT jz .;
	test	SSTAT1,PHASEMIS	jz data_phase_loop;

	/* Ensure the last seg is visable at the shaddow layer */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	DFCNTRL, DMAPARAMS;
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
	}

d1232 78
a1309 16
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
	}
/*
 * After a DMA finishes, save the SG and STCNT residuals back into the SCB
 * We use STCNT instead of HCNT, since it's a reflection of how many bytes 
 * were transferred on the SCSI (as opposed to the host) bus.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, STCNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],STCNT[0];
		mov	SCB_RESID_DCNT[1],STCNT[1];
		mov	SCB_RESID_DCNT[2],STCNT[2];
	}
	mov	SCB_RESID_SGCNT, SG_COUNT;
d1312 2
d1317 1
a1317 1
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1327 2
a1329 1
	jmp	ITloop;
d1331 1
a1331 48
data_phase_overrun:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}
/*
 * Turn off BITBUCKET mode and notify the host
 */
	and	SXFRCTL1, ~BITBUCKET;
	mvi	INTSTAT,DATA_OVERRUN;
	jmp	ITloop;

ultra2_dmafinish:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		test	DFCNTRL, DIRECTION jnz ultra2_dmafifoempty;
		and	DFCNTRL, ~SCSIEN;
		test	DFCNTRL, SCSIEN jnz .;
ultra2_dmafifoflush:
		or	DFCNTRL, FIFOFLUSH;
		/*
		 * The FIFOEMP status bit on the Ultra2 class
		 * of controllers seems to be a bit flaky.
		 * It appears that if the FIFO is full and the
		 * transfer ends with some data in the REQ/ACK
		 * FIFO, FIFOEMP will fall temporarily
		 * as the data is transferred to the PCI bus.
		 * This glitch lasts for fewer than 5 clock cycles,
		 * so we work around the problem by ensuring the
		 * status bit stays false through a full glitch
		 * window.
		 */
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;

ultra2_dmafifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_dmafifoempty;

ultra2_dmahalt:
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, HDMAEN jnz .;
		ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1336 56
a1391 19
	call	assert;

	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mov	HCNT[0], SCB_CMDLEN;
		bmov	HCNT[1], ALLZEROS, 2;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			bmov	STCNT, HCNT, 3;
		}
		add	NONE, -17, SCB_CMDLEN;
		jc	dma_cmd_data;
		/*
		 * The data fifo seems to require 4 byte alligned
		 * transfers from the sequencer.  Force this to
		 * be the case by clearing HADDR[0] even though
		 * we aren't going to touch host memeory.
		 */
		bmov	HADDR[0], ALLZEROS, 1;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
d1395 24
a1418 27
		bmov   DFDAT, SCB_CMDSTORE, 16; 
		jmp	cmd_loop;
dma_cmd_data:
		bmov	HADDR, SCB_CMDPTR, 4;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_CMDPTR	call bcopy_5;
		clr	HCNT[1];
		clr	HCNT[2];
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) == 0) {
			call	set_stcnt_from_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	} else {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	}
cmd_loop:
	test	SSTAT0, SDONE jnz . + 2;
	test    SSTAT1, PHASEMIS jz cmd_loop;
	/*
	 * Wait for our ACK to go-away on it's own
	 * instead of being killed by SCSIEN getting cleared.
	 */
	test	SCSISIGI, ACKI jnz .;
d1421 4
d1432 4
a1435 3
	call	assert;

	mov	SCB_TARGET_STATUS, SCSIDATL;
d1463 6
a1468 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATN for the retry */
a1472 25
	mov	FUNCTION1, SCB_TCL;
	mov	A, FUNCTION1;
	if ((ahc->features & AHC_HS_MAILBOX) != 0) {
		/*
		 * Work around a pausing bug in at least the aic7890.
		 * If the host needs to update the TARGET_MSG_REQUEST
		 * bit field, it will set the HS_MAILBOX to 1.  In
		 * response, we pause with a specific interrupt code
		 * asking for the mask to be updated before we continue.
		 * Ugh.
		 */
		test	HS_MAILBOX, 0xF0	jz . + 2;
		mvi	INTSTAT, UPDATE_TMSG_REQ;
		nop;
	}
	mov	SINDEX, TARGET_MSG_REQUEST[0];
	if ((ahc->features & AHC_TWIN) != 0) {
		/* Second Channel uses high byte bits */
		test	SCB_TCL, SELBUSB	jz . + 2;
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	} else if ((ahc->features & AHC_WIDE) != 0) {
		test	SCB_TCL, 0x80		jz . + 2; /* target > 7 */
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	}
	test	SINDEX, A	jnz host_message_loop;
d1474 3
a1476 4
	and	SINDEX,LID,SCB_TCL;	/* lun */
	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privledge */
	or	SINDEX,A;		/* or in disconnect privledge */
	or	SINDEX,MSG_IDENTIFYFLAG;
d1526 1
d1539 1
a1539 1
	mvi	INTSTAT, HOST_MSG_LOOP;
d1544 14
a1561 1

d1564 1
a1564 1
 * We got a "command complete" message, so put the SCB_TAG into the QOUTFIFO,
d1571 18
a1588 8
 * sense, it will fill the kernel SCB with a request sense command and set
 * RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE we redownload
 * the SCB, and process it as the next command by adding it to the waiting list.
 * If the kernel driver does not wish to request sense, it need only clear
 * RETURN_1, and the command is allowed to complete normally.  We don't bother
 * to post to the QOUTFIFO in the error cases since it would require extra
 * work in the kernel driver to ensure that the entry was removed before the
 * command complete code tried processing it.
d1590 2
d1594 1
a1594 1
 * First check for residuals
d1596 5
a1600 2
	test	SCB_RESID_SGCNT,0xff	jnz upload_scb;
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Good Status? */
d1602 1
d1605 2
a1606 4
check_status:
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Just a residual? */
	mvi	INTSTAT,BAD_STATUS;			/* let driver know */
	nop;
d1608 1
a1608 11
	/* This SCB becomes the next to execute as it will retrieve sense */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	SCB_TAG		call dma_scb;
add_to_waiting_list:
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
	/*
	 * Prepare our selection hardware before the busfree so we have a
	 * high probability of winning arbitration.
	 */
	call	start_selection;
a1609 1

a1610 8
	/* If we are untagged, clear our address up in host ram */
	test	SCB_CONTROL, TAG_ENB jnz complete_queue;
	mov	A, SAVED_TCL;
	/* fvdl - let ahc_intr clear this to avoid race conditions */
	/* mvi	UNTAGGEDSCB_OFFSET call post_byte_setup; */
	/* mvi	SCB_LIST_NULL call post_byte; */

complete_queue:
d1631 1
a1631 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1634 3
a1636 1
 * and await the bus going free.
d1639 10
d1650 7
a1656 1
	call	add_scb_to_disc_list;
d1665 3
d1670 6
a1675 1
	test	SEQ_FLAGS, DPHASE	jz mesgin_done;
d1678 17
a1694 2
	 * The SCB SGPTR becomes the next one we'll download,
	 * and the SCB DATAPTR becomes the current SHADDR.
a1698 1
		bmov	SCB_SGCOUNT, SG_COUNT, 5;
d1700 4
a1703 1
		bmov	SCB_DATACNT, SCB_RESID_DCNT, 3;
a1704 3
		mvi	DINDEX, SCB_SGCOUNT;
		mvi	SG_COUNT call bcopy_5;
	
d1706 3
a1708 2
		mvi	SHADDR		call bcopy_4;
		mvi	SCB_RESID_DCNT	call bcopy_3;
d1710 1
a1710 1
	jmp	mesgin_done;
d1727 14
d1746 34
a1779 4
	if ((ahc->features & AHC_WIDE) != 0) {
		and	A,0x0f;		/* lun in lower four bits */
	} else {
		and	A,0x07;		/* lun in lower three bits */
d1781 1
a1781 4
	or      SAVED_TCL,A;		/* SAVED_TCL should be complete now */

	mvi	ARG_2, SCB_LIST_NULL;	/* SCBID of prev SCB in disc List */
	call	get_untagged_SCBID;
d1784 25
a1808 10
		test	SEQ_FLAGS, SCBPTR_VALID	jz use_retrieveSCB;
	}
	/*
	 * If the SCB was found in the disconnected list (as is
	 * always the case in non-paging scenarios), SCBPTR is already
	 * set to the correct SCB.  So, simply setup the SCB and get
	 * on with things.
	 */
	call	rem_scb_from_disc_list;
	jmp	setup_SCB;
d1812 4
a1815 4
 * SCB.  With SCB paging, this requires using search for both tagged
 * and non-tagged transactions since the SCB may exist in any slot.
 * If we're not using SCB paging, we can use the tag as the direct
 * index to the SCB.
d1818 3
a1821 1
snoop_tag_loop:
d1823 3
d1827 3
d1832 7
a1838 1
	mvi	ARG_1	call inb_next;	/* tag value */
d1840 4
a1843 6
	/*
	 * Ensure that the SCB the tag points to is for
	 * an SCB transaction to the reconnecting target.
	 */
use_retrieveSCB:
	call	retrieveSCB;
d1845 15
a1859 2
	mov	A, SAVED_TCL;
	cmp	SCB_TCL, A	jne not_found_cleanup_scb;
d1862 11
a1872 1
	or	SEQ_FLAGS,IDENTIFY_SEEN;	/* make note of IDENTIFY */
a1875 1
	and	SCB_CONTROL, ~MK_MESSAGE;
d1880 3
a1882 4
	test	SCB_CONTROL, DISCONNECTED jz . + 3;
	call	add_scb_to_disc_list;
	jmp	not_found;
	call	add_scb_to_free_list;
d1884 1
a1884 1
	mvi	INTSTAT, NO_MATCH;
a1886 8
/*
 * [ ADD MORE MESSAGE HANDLING HERE ]
 */

/*
 * Locking the driver out, build a one-byte message passed in SINDEX
 * if there is no active message already.  SINDEX is returned intact.
 */
d1888 5
a1892 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATNO */
d1911 1
a1911 1
	mvi	INTSTAT, PERR_DETECTED;
d1933 1
a1933 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1950 1
a1950 1
	 * we must waitat least a data release delay plus
a1972 1
mesgin_phasemis:
d1974 5
a1978 70
 * We expected to receive another byte, but the target changed phase
 */
	mvi	INTSTAT, MSGIN_PHASEMIS;
	jmp	ITloop;

/*
 * DMA data transfer.  HADDR and HCNT must be loaded first, and
 * SINDEX should contain the value to load DFCNTRL with - 0x3d for
 * host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
 * during initialization.
 */
dma:
	mov	DFCNTRL,SINDEX;
dma_loop:
	test	SSTAT0,DMADONE	jnz dma_dmadone;
	test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
dma_phasemis:

/*
 * We will be "done" DMAing when the transfer count goes to zero, or
 * the target changes the phase (in light of this, it makes sense that
 * the DMA circuitry doesn't ACK when PHASEMIS is active).  If we are
 * doing a SCSI->Host transfer, the data FIFO should be flushed auto-
 * magically on STCNT=0 or a phase change, so just wait for FIFO empty
 * status.
 */
dma_checkfifo:
	test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
dma_fifoflush:
	test	DFSTATUS,FIFOEMP	jz dma_fifoflush;

dma_fifoempty:
	/* Don't clobber an inprogress host data transfer */
	test	DFSTATUS, MREQPEND	jnz dma_fifoempty;
/*
 * Now shut the DMA enables off and make sure that the DMA enables are 
 * actually off first lest we get an ILLSADDR.
 */
dma_dmadone:
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
	/*
	 * Some revisions of the aic7880 have a problem where, if the
	 * data fifo is full, but the PCI input latch is not empty, 
	 * HDMAEN cannot be cleared.  The fix used here is to attempt
	 * to drain the data fifo until there is space for the input
	 * latch to drain and HDMAEN de-asserts.
	 */
	if ((ahc->features & AHC_ULTRA2) == 0) {
		mov	NONE, DFDAT;
	}
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;
return:
	ret;

/*
 * Assert that if we've been reselected, then we've seen an IDENTIFY
 * message.
 */
assert:
	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz return;	/* seen IDENTIFY? */

	mvi	INTSTAT,NO_IDENT 	ret;	/* no - tell the kernel */

/*
 * Locate a disconnected SCB either by SAVED_TCL (ARG_1 is SCB_LIST_NULL)
 * or by the SCBID ARG_1.  The search begins at the SCB index passed in
 * via SINDEX which is an SCB that must be on the disconnected list.  If
 * the SCB cannot be found, SINDEX will be SCB_LIST_NULL, otherwise, SCBPTR
 * is set to the proper SCB.
d1980 2
d1983 5
a1987 7
	mov	SCBPTR,SINDEX;			/* Initialize SCBPTR */
	cmp	ARG_1, SCB_LIST_NULL	jne findSCB_by_SCBID;
	mov	A, SAVED_TCL;
	mvi	SCB_TCL	jmp findSCB_loop;	/* &SCB_TCL -> SINDEX */
findSCB_by_SCBID:
	mov	A, ARG_1;			/* Tag passed in ARG_1 */
	mvi	SCB_TAG	jmp findSCB_loop;	/* &SCB_TAG -> SINDEX */
d1989 1
a1990 1
	cmp	SCB_NEXT, SCB_LIST_NULL je notFound;
a1991 1
	dec	SINDEX;		/* Last comparison moved us too far */
d1993 1
a1993 23
	cmp	SINDIR, A	jne findSCB_next;
	mov	SINDEX, SCBPTR 	ret;
notFound:
	mvi	SINDEX, SCB_LIST_NULL	ret;

/*
 * Retrieve an SCB by SCBID first searching the disconnected list falling
 * back to DMA'ing the SCB down from the host.  This routine assumes that
 * ARG_1 is the SCBID of interrest and that SINDEX is the position in the
 * disconnected list to start the search from.  If SINDEX is SCB_LIST_NULL,
 * we go directly to the host for the SCB.
 */
retrieveSCB:
	test	SEQ_FLAGS, SCBPTR_VALID	jz retrieve_from_host;
	mov	SCBPTR	call findSCB;	/* Continue the search */
	cmp	SINDEX, SCB_LIST_NULL	je retrieve_from_host;

/*
 * This routine expects SINDEX to contain the index of the SCB to be
 * removed, SCBPTR to be pointing to that SCB, and ARG_2 to be the
 * SCBID of the SCB just previous to this one in the list or SCB_LIST_NULL
 * if it is at the head.
 */
a1994 1
/* Remove this SCB from the disconnection list */
d1997 1
d2003 7
a2009 7

retrieve_from_host:
/*
 * We didn't find it.  Pull an SCB and DMA down the one we want.
 * We should never get here in the non-paging case.
 */
	mov	ALLZEROS	call	get_free_or_disc_scb;
a2010 1
	/* Jump instead of call as we want to return anyway */
d2012 1
a2012 44

/*
 * Determine whether a target is using tagged or non-tagged transactions
 * by first looking for a matching transaction based on the TCL and if
 * that fails, looking up this device in the host's untagged SCB array.
 * The TCL to search for is assumed to be in SAVED_TCL.  The value is
 * returned in ARG_1 (SCB_LIST_NULL for tagged, SCBID for non-tagged).
 * The SCBPTR_VALID bit is set in SEQ_FLAGS if we found the information
 * in an SCB instead of having to go to the host.
 */
get_untagged_SCBID:
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je get_SCBID_from_host;
	mvi	ARG_1, SCB_LIST_NULL;
	mov	DISCONNECTED_SCBH call findSCB;
	cmp	SINDEX, SCB_LIST_NULL	je get_SCBID_from_host;
	or	SEQ_FLAGS, SCBPTR_VALID;/* Was in disconnected list */
	test	SCB_CONTROL, TAG_ENB	jnz . + 2;
	mov	ARG_1, SCB_TAG	ret;
	mvi	ARG_1, SCB_LIST_NULL ret;

/*
 * Fetch a byte from host memory given an index of (A + (256 * SINDEX))
 * and a base address of SCBID_ADDR.  The byte is returned in RETURN_2.
 */
fetch_byte:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		mvi	CCSGCTL, CCSGRESET;
		bmov	RETURN_2, CCSGRAM, 1 ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
		mvi	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;
		call	dma_finish;
		mov	RETURN_2, DFDAT ret;
	}
d2016 1
a2016 1
 * index of (A + (256 * SINDEX)) and a base address of SCBID_ADDR.
d2022 1
a2022 1
		mvi	SCBID_ADDR call	set_1byte_addr;
d2027 2
a2028 4
		mvi	SCBID_ADDR call	set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
a2043 5
get_SCBID_from_host:
	mov	A, SAVED_TCL;
	mvi	UNTAGGEDSCB_OFFSET call fetch_byte;
	mov	RETURN_1,  RETURN_2 ret;

d2045 1
a2045 1
	mvi	INTSTAT, PERR_DETECTED;
d2055 3
a2057 1
	and	SCSISIGO, PHASE_MASK, SCSISIGI;
d2061 6
d2072 2
d2087 1
a2087 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d2113 1
a2113 1
 * Setup addr assuming that A + (ARG_1 * 256) is an
d2138 5
a2142 1
		mvi	CCHCNT, SCB_64BYTE_SIZE;
d2147 2
a2148 2
		mvi	CCHCNT, SCB_32BYTE_SIZE;
		if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
d2150 1
a2150 1
			bmov	CCSCBRAM, SCB_CONTROL, SCB_32BYTE_SIZE;
d2153 6
d2170 1
a2170 3
		mvi	HCNT[0], SCB_32BYTE_SIZE;
		clr	HCNT[1];
		clr	HCNT[2];
d2175 2
a2176 2
		mvi	SINDEX, SCB_CONTROL;
		add	A, SCB_32BYTE_SIZE, SINDEX;
d2178 1
a2178 7
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
d2181 1
d2183 49
a2231 1
		call	dma_finish;
d2233 5
a2237 5
		test	DMAPARAMS, DIRECTION	jz	return;
		mvi	SCB_CONTROL  call dfdat_in_7;
		call	dfdat_in_7_continued;
		call	dfdat_in_7_continued;
		jmp	dfdat_in_7_continued;
a2238 2
		mov     DINDEX,SINDEX;
dfdat_in_7_continued:
d2244 1
d2249 12
d2268 1
d2274 10
d2286 1
d2290 1
d2295 7
d2304 1
d2308 1
d2312 2
a2313 1
dma_up_scb:
d2315 2
a2316 3
	mov	SCB_TAG		call dma_scb;
unlink_disc_scb:
	mov	DISCONNECTED_SCBH, SCB_NEXT ret;
d2320 1
a2320 1
}
d2328 1
d2331 7
@


1.9
log
@New port of FreeBSD's ahc driver
@
text
@a0 1
/* $OpenBSD: src/sys/dev/microcode/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $ */
d4 1
a4 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d17 1
a17 1
 * GNU Public License ("GPL").
d31 1
a31 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $
a33 2
VERSION = "$Id: src/sys/dev/microcode/aic7xxx/aic7xxx.seq#32 $"

d36 3
d58 12
a69 7
bus_free_sel:
        /*
         * Turn off the selection hardware.  We need to reset the
         * selection request in order to perform a new selection.
         */
        and     SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
        and     SIMODE1, ~ENBUSFREE;
d73 2
a74 7
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;
        }
        test    SCSISEQ, ENSELO jnz poll_for_selection;
        if ((ahc->features & AHC_TWIN) != 0) {
                xor     SBLKCTL,SELBUSB;        /* Toggle to the other bus */
                test    SCSISEQ, ENSELO         jnz poll_for_selection;
a75 1
        cmp     WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d77 5
d83 6
d90 5
a94 2
        }
        test    SSTAT0, SELDO|SELDI     jnz selection;
a96 1
BEGIN_CRITICAL
d99 2
d102 1
a102 1
                mov     A, QINPOS;
d104 2
a106 1
        mov     ARG_1, NEXT_QUEUED_SCB;
d108 6
a113 5
        /*
         * We have at least one queued SCB now and we don't have any 
         * SCBs in the list of SCBs awaiting selection.  Allocate a
         * card SCB for the host's SCB and get to work on it.
         */
d116 7
a122 1
        } else {
d124 1
a124 1
                mov     SCBPTR, ARG_1;
a125 2
        or      SEQ_FLAGS2, SCB_DMA;
END_CRITICAL
d127 3
a129 3
        /*
         * DMA the SCB from host ram into the current SCB location.
         */
d131 14
a144 13
        mov     ARG_1   call dma_scb;
        /*
         * Check one last time to see if this SCB was canceled
         * before we completed the DMA operation.  If it was,
         * the QINFIFO next pointer will not match our saved
         * value.
         */
        mov     A, ARG_1;
BEGIN_CRITICAL
        cmp     NEXT_QUEUED_SCB, A jne abort_qinscb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                cmp     SCB_TAG, A je . + 2;
                mvi     SCB_MISMATCH call set_seqint;
d146 7
a152 1
        mov     NEXT_QUEUED_SCB, SCB_NEXT;
a154 7
        if ((ahc->features & AHC_QUEUE_REGS) != 0) {
                mov     NONE, SNSCB_QOFF;
        } else {
                inc     QINPOS;
        }
        and     SEQ_FLAGS2, ~SCB_DMA;
END_CRITICAL
d157 1
a157 1
         * Start the first entry on the waiting SCB list.
d161 1
d163 52
a214 8
poll_for_selection:
        /*
         * Twin channel devices cannot handle things like SELTO
         * interrupts on the "background" channel.  So, while
         * selecting, keep polling the current channel until
         * either a selection or reselection occurs.
         */
        test    SSTAT0, SELDO|SELDI     jz poll_for_selection;
a216 15
        /*
         * We aren't expecting a bus free, so interrupt
         * the kernel driver if it happens.
         */
        mvi     CLRSINT1,CLRBUSFREE;
        if ((ahc->features & AHC_DT) == 0) {
                or      SIMODE1, ENBUSFREE;
        }

        /*
         * Guard against a bus free after (re)selection
         * but prior to enabling the busfree interrupt.  SELDI
         * and SELDO will be cleared in that case.
         */
        test    SSTAT0, SELDI|SELDO     jz bus_free_sel;
d218 1
d220 2
a221 2
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                if ((ahc->flags & AHC_INITIATORROLE) != 0) {
a223 1
                mvi     CLRSINT0, CLRSELDI;
d231 1
d242 1
a242 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d246 1
a246 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d251 7
a257 1
                and     SAVED_SCSIID, SELID_MASK, SELID;
d259 8
a266 14
                if ((ahc->features & AHC_MULTI_TID) != 0) {
                        and     A, OID, TARGIDIN;
                } else if ((ahc->features & AHC_ULTRA2) != 0) {
                        and     A, OID, SCSIID_ULTRA2;
                } else {
                        and     A, OID, SCSIID;
                }
                or      SAVED_SCSIID, A;
                if ((ahc->features & AHC_TWIN) != 0) {
                        test    SBLKCTL, SELBUSB jz . + 2;
                        or      SAVED_SCSIID, TWIN_CHNLB;
                }
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        mov     CCSCBRAM, SAVED_SCSIID;
d268 11
a278 2
                        mov     DFDAT, SAVED_SCSIID;
                }
a282 2
                 * XXX SCSI-1 may require us to assume lun 0 if
                 * ATN is false.
d297 1
a346 4
                or      SEQ_FLAGS, TARGET_CMD_IS_TAGGED;
                test    SCSISIGI, ATNI  jz . + 2;
                /* Initiator still wants to give us messages */
                call    target_inb;
d354 2
a355 1
                mvi     HOST_MSG_LOOP call set_seqint;
d365 1
a365 1
                        mov     A, KERNEL_TQINPOS;
d369 1
a369 1
                test    SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
d382 1
a382 1
                test    SCSISIGI, ATNI  jnz target_mesgout_pending;
d384 18
a401 1
        }
d403 1
a403 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d409 15
a423 94
        /* XXX test for and handle ONE BIT condition */
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
        and     SAVED_SCSIID, SELID_MASK, SELID;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                and     A, OID, SCSIID_ULTRA2;
        } else {
                and     A, OID, SCSIID;
        }
        or      SAVED_SCSIID, A;
        if ((ahc->features & AHC_TWIN) != 0) {
                test    SBLKCTL, SELBUSB        jz . + 2;
                or      SAVED_SCSIID, TWIN_CHNLB;
        }
        mvi     CLRSINT0, CLRSELDI;
        jmp     ITloop;
}

abort_qinscb:
        call    add_scb_to_free_list;
        jmp     poll_for_work_loop;

start_selection:
        /*
         * If bus reset interrupts have been disabled (from a previous
         * reset), re-enable them now.  Resets are only of interest
         * when we have outstanding transactions, so we can safely
         * defer re-enabling the interrupt until, as an initiator,
         * we start sending out transactions again.
         */
        test    SIMODE1, ENSCSIRST      jnz . + 3;
        mvi     CLRSINT1, CLRSCSIRSTI;
        or      SIMODE1, ENSCSIRST;
        if ((ahc->features & AHC_TWIN) != 0) {
                and     SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
                test    SCB_SCSIID, TWIN_CHNLB jz . + 2;
                or      SINDEX, SELBUSB;
                mov     SBLKCTL,SINDEX;         /* select channel */
        }
initialize_scsiid:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     SCSIID_ULTRA2, SCB_SCSIID;
        } else if ((ahc->features & AHC_TWIN) != 0) {
                and     SCSIID, TWIN_TID|OID, SCB_SCSIID;
        } else {
                mov     SCSIID, SCB_SCSIID;
        }
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                mov     SINDEX, SCSISEQ_TEMPLATE;
                test    SCB_CONTROL, TARGET_SCB jz . + 2;
                or      SINDEX, TEMODE;
                mov     SCSISEQ, SINDEX ret;
        } else {
                mov     SCSISEQ, SCSISEQ_TEMPLATE ret;
        }

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
set_transfer_settings:
        if ((ahc->features & AHC_ULTRA) != 0) {
                test    SCB_CONTROL, ULTRAENB jz . + 2;
                or      SXFRCTL0, FAST20;
        } 
        /*
         * Initialize SCSIRATE with the appropriate value for this target.
         */
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    SCSIRATE, SCB_SCSIRATE, 2 ret;
        } else {
                mov     SCSIRATE, SCB_SCSIRATE ret;
        }

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
        /*
         * Drive REQ on the bus by enabling SCSI PIO.
         */
        or      SXFRCTL0, SPIOEN;
        /* Wait for the byte */
        test    SSTAT0, SPIORDY jz .;
        /* Prevent our read from triggering another REQ */
        and     SXFRCTL0, ~SPIOEN;
        /* Save latched contents */
        mov     DINDEX, SCSIDATL ret;
d435 1
d439 2
a440 4
        mov     SAVED_SCSIID, SCB_SCSIID;
        mov     SAVED_LUN, SCB_LUN;
        call    initialize_channel;
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d449 1
d454 2
a455 1
                or      SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d463 2
a464 1
                mov     SCB_TARGET_INFO[SCB_INITIATOR_TAG] call target_outb;
d470 1
a470 1
                mov     SEQ_FLAGS, SCB_TARGET_INFO[SCB_TARGET_PHASES];
d472 1
a472 3
                test    SCB_CONTROL, MK_MESSAGE jz target_ITloop;
                mvi     P_MESGIN|BSYO call change_phase;
                jmp     host_target_message_loop;
a487 3
                mov     RETURN_1, ALLZEROS;
                call    complete_target_cmd;
                cmp     RETURN_1, CONT_MSG_LOOP jne .;
d491 3
a499 1
target_mesgout_continue:
a500 1
target_mesgout_pending:
d502 1
d512 1
a512 1
                /* Wait for preceding I/O session to complete. */
a514 4
                and     SIMODE1, ~ENBUSFREE;
                if ((ahc->features & AHC_ULTRA2) != 0) {
                        clr     SCSIBUSL;
                }
d540 1
a540 1
                add     SINDEX, CMDSIZE_TABLE, A;
a543 1
                or      SXFRCTL0, SPIOEN;
d545 1
d563 10
a572 9
                 * Data phases on the bus are from the
                 * perspective of the initiator.  The dma
                 * code looks at LASTPHASE to determine the
                 * data direction of the DMA.  Toggle it for
                 * target transfers.
		 */
                xor     LASTPHASE, IOI, SCB_TARGET_INFO[SCB_TARGET_DATA_DIR];
                or      SCB_TARGET_INFO[SCB_TARGET_DATA_DIR], BSYO
                        call change_phase;
d578 1
a578 1
                mov     SCB_TARGET_INFO[SCB_TARGET_STATUS] call target_outb;
d601 3
a603 1
                        mvi     28      call set_hcnt;
d611 1
a611 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d613 9
a634 1
mesgin_phasemis:
d646 1
a646 1
        mvi     BAD_PHASE call set_seqint;
a651 3
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;       /* Prevent bit leakage durint SELTO */
        }
d655 1
a655 1
        mvi     MISSED_BUSFREE call set_seqint;
a664 1
        or      SXFRCTL0, CLRSTCNT|CLRCHN;
d675 1
a675 3
                if ((ahc->features & AHC_ULTRA) != 0) {
                        and     SXFRCTL0, ~(FAST20);
                }
d681 5
a685 54
sg_advance:
        clr     A;                      /* add sizeof(struct scatter) */
        add     SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
        adc     SCB_RESIDUAL_SGPTR[1],A;
        adc     SCB_RESIDUAL_SGPTR[2],A;
        adc     SCB_RESIDUAL_SGPTR[3],A ret;

if ((ahc->features & AHC_CMD_CHAN) != 0) {
disable_ccsgen:
        test    CCSGCTL, CCSGEN jz return;
        test    CCSGCTL, CCSGDONE jz .;
disable_ccsgen_fetch_done:
        clr     CCSGCTL;
        test    CCSGCTL, CCSGEN jnz .;
        ret;
idle_loop:
        /*
         * Do we need any more segments for this transfer?
         */
        test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

        /* Did we just finish fetching segs? */
        cmp     CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

        /* Are we actively fetching segments? */
        test    CCSGCTL, CCSGEN jnz return;

        /*
         * Do we have any prefetch left???
         */
        cmp     CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

        /*
         * Need to fetch segments, but we can only do that
         * if the command channel is completely idle.  Make
         * sure we don't have an SCB prefetch going on.
         */
        test    CCSCBCTL, CCSCBEN jnz return;

        /*
         * We fetch a "cacheline aligned" and sized amount of data
         * so we don't end up referencing a non-existant page.
         * Cacheline aligned is in quotes because the kernel will
         * set the prefetch amount to a reasonable level if the
         * cacheline size is unknown.
         */
        mvi     CCHCNT, SG_PREFETCH_CNT;
        and     CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
        bmov    CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
        mvi     CCSGCTL, CCSGEN|CCSGRESET ret;
idle_sgfetch_complete:
        call    disable_ccsgen_fetch_done;
        and     CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
idle_sg_avail:
d687 15
a701 55
                /* Does the hardware have space for another SG entry? */
                test    DFSTATUS, PRELOAD_AVAIL jz return;
                bmov    HADDR, CCSGRAM, 7;
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;
                bmov    SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
                }
                call    sg_advance;
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                /* Load the segment */
                or      DFCNTRL, PRELOADEN;
        }
        ret;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Calculate the trailing portion of this S/G segment that cannot
 * be transferred using memory write and invalidate PCI transactions.  
 * XXX Can we optimize this for PCI writes only???
 */
calc_mwi_residual:
        /*
         * If the ending address is on a cacheline boundary,
         * there is no need for an extra segment.
         */
        mov     A, HCNT[0];
        add     A, A, HADDR[0];
        and     A, CACHESIZE_MASK;
        test    A, 0xFF jz return;

        /*
         * If the transfer is less than a cachline,
         * there is no need for an extra segment.
         */
        test    HCNT[1], 0xFF   jnz calc_mwi_residual_final;
        test    HCNT[2], 0xFF   jnz calc_mwi_residual_final;
        add     NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
        jnc     return;

calc_mwi_residual_final:
        mov     MWI_RESIDUAL, A;
        not     A;
        inc     A;
        add     HCNT[0], A;
        adc     HCNT[1], -1;
        adc     HCNT[2], -1 ret;
}
a703 3
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_data_okay;
        mvi     NO_IDENT jmp set_seqint;
p_data_okay:
d711 4
d716 1
a716 2
                /* We don't have any valid S/G elements */
                mvi     CCSGADDR, SG_PREFETCH_CNT;
d718 1
a718 10
        test    SEQ_FLAGS, DPHASE       jz data_phase_initialize;

        /*
         * If we re-enter the data phase after going through another
         * phase, our transfer location has almost certainly been
         * corrupted by the interveining, non-data, transfers.  Ask
         * the host driver to fix us up based on the transfer residual.
         */
        mvi     PDATA_REINIT    call set_seqint;
        jmp     data_phase_loop;
d720 1
a720 2
data_phase_initialize:
        /* We have seen a data phase for the first time */
d725 3
a727 4
         * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
         * flag in the highest byte of the data count.  We cannot
         * modify the saved values in the SCB until we see a save
         * data pointers message.
a728 4
        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                /* The lowest address byte must be loaded last. */
                mov     SCB_DATACNT[3] call set_hhaddr;
        }
a730 1
                bmov    SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
a733 2
                mvi     DINDEX, SCB_RESIDUAL_DATACNT + 3;
                mvi     SCB_DATACNT + 3 call bcopy_5;
d735 1
a735 5
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
                call    calc_mwi_residual;
        }
        and     SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
        and     DATA_COUNT_ODD, 0x1, HCNT[0];
d742 8
a749 1
                }
d753 8
a760 9
        /* Guard against overruns */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;

        /*
         * Turn on `Bit Bucket' mode, wait until the target takes
         * us to another phase, and then notify the host.
         */
        and     DMAPARAMS, DIRECTION;
        mov     DFCNTRL, DMAPARAMS;
d762 5
a766 2
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT1,PHASEMIS jz .;
d768 3
a770 1
                test    SCSIPHASE, DATA_PHASE_MASK jnz .;
a771 4
        and     SXFRCTL1, ~BITBUCKET;
        mvi     DATA_OVERRUN call set_seqint;
        jmp     ITloop;

d773 2
d776 5
a780 194
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                mov     DFCNTRL, DMAPARAMS;
ultra2_dma_loop:
                call    idle_loop;
                /*
                 * The transfer is complete if either the last segment
                 * completes or the target changes phase.
                 */
                test    SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                                 /*
                                  * As a target, we control the phases,
                                  * so ignore PHASEMIS.
                                  */
                                test    SSTAT0, TARGET jnz ultra2_dma_loop;
                        }
                        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                                test    SSTAT1,PHASEMIS jz ultra2_dma_loop;
                        }
                } else {
                        test    DFCNTRL, SCSIEN jnz ultra2_dma_loop;
                }

ultra2_dmafinish:
                /*
                 * The transfer has terminated either due to a phase
                 * change, and/or the completion of the last segment.
                 * We have two goals here.  Do as much other work
                 * as possible while the data fifo drains on a read
                 * and respond as quickly as possible to the standard
                 * messages (save data pointers/disconnect and command
                 * complete) that usually follow a data phase.
                 */
                if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                        /*
                         * On chips with broken auto-flush, start
                         * the flushing process now.  We'll poke
                         * the chip from time to time to keep the
                         * flush process going as we complete the
                         * data phase.
                         */
                        or      DFCNTRL, FIFOFLUSH;
                }
                /*
                 * We assume that, even though data may still be
                 * transferring to the host, that the SCSI side of
                 * the DMA engine is now in a static state.  This
                 * allows us to update our notion of where we are
                 * in this transfer.
                 *
                 * If, by chance, we stopped before being able
                 * to fetch additional segments for this transfer,
                 * yet the last S/G was completely exhausted,
                 * call our idle loop until it is able to load
                 * another segment.  This will allow us to immediately
                 * pickup on the next segment on the next data phase.
                 *
                 * If we happened to stop on the last segment, then
                 * our residual information is still correct from
                 * the idle loop and there is no need to perform
                 * any fixups.
                 */
ultra2_ensure_sg:
                test    SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
                /* Record if we've consumed all S/G entries */
                test    SSTAT2, SHVALID jnz residuals_correct;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     residuals_correct;

ultra2_shvalid:
                test    SSTAT2, SHVALID jnz sgptr_fixup;
                call    idle_loop;
                jmp     ultra2_ensure_sg;

sgptr_fixup:
                /*
                 * Fixup the residual next S/G pointer.  The S/G preload
                 * feature of the chip allows us to load two elements
                 * in addition to the currently active element.  We
                 * store the bottom byte of the next S/G pointer in
                 * the SG_CACEPTR register so we can restore the
                 * correct value when the DMA completes.  If the next
                 * sg ptr value has advanced to the point where higher
                 * bytes in the address have been affected, fix them
                 * too.
                 */
                test    SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
                test    SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
                add     SCB_RESIDUAL_SGPTR[1], -1;
                adc     SCB_RESIDUAL_SGPTR[2], -1; 
                adc     SCB_RESIDUAL_SGPTR[3], -1;
sgptr_fixup_done:
                and     SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
                clr     DATA_COUNT_ODD;
                test    SG_CACHE_SHADOW, ODD_SEG jz . + 2;
                or      DATA_COUNT_ODD, 0x1;
                clr     SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
residuals_correct:
                /*
                 * Go ahead and shut down the DMA engine now.
                 * In the future, we'll want to handle end of
                 * transfer messages prior to doing this, but this
                 * requires similar restructuring for pre-ULTRA2
                 * controllers.
                 */
                test    DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
ultra2_fifoflush:
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                                /*
                                 * On Rev A of the aic7890, the autoflush
                                 * feature doesn't function correctly.
                                 * Perform an explicit manual flush.  During
                                 * a manual flush, the FIFOEMP bit becomes
                                 * true every time the PCI FIFO empties
                                 * regardless of the state of the SCSI FIFO.
                                 * It can take up to 4 clock cycles for the
                                 * SCSI FIFO to get data into the PCI FIFO
                                 * and for FIFOEMP to de-assert.  Here we
                                 * guard against this condition by making
                                 * sure the FIFOEMP bit stays on for 5 full
                                 * clock cycles.
                                 */
                                or      DFCNTRL, FIFOFLUSH;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                        }
                        test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                } else {
                        /*
                         * We enable the auto-ack feature on DT capable
                         * controllers.  This means that the controller may
                         * have already transferred some overrun bytes into
                         * the data FIFO and acked them on the bus.  The only
                         * way to detect this situation is to wait for
                         * LAST_SEG_DONE to come true on a completed transfer
                         * and then test to see if the data FIFO is non-empty.
                         */
                        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
                        test    SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
                        test    DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
                        /* Overrun */
                        jmp     data_phase_loop;
                        test    DFSTATUS, FIFOEMP jz .;
                }
ultra2_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz ultra2_fifoempty;
ultra2_dmahalt:
                and     DFCNTRL, ~(SCSIEN|HDMAEN);
                test    DFCNTRL, SCSIEN|HDMAEN jnz .;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        /*
                         * Keep HHADDR cleared for future, 32bit addressed
                         * only, DMA operations.
                         *
                         * Due to bayonette style S/G handling, our residual
                         * data must be "fixed up" once the transfer is halted.
                         * Here we fixup the HSHADDR stored in the high byte
                         * of the residual data cnt.  By postponing the fixup,
                         * we can batch the clearing of HADDR with the fixup.
                         * If we halted on the last segment, the residual is
                         * already correct.   If we are not on the last
                         * segment, copy the high address directly from HSHADDR.
                         * We don't need to worry about maintaining the
                         * SG_LAST_SEG flag as it will always be false in the
                         * case where an update is required.
                         */
                        or      DSCOMMAND1, HADDLDSEL0;
                        test    SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
                        mov     SCB_RESIDUAL_DATACNT[3], SHADDR;
                        clr     HADDR;
                        and     DSCOMMAND1, ~HADDLDSEL0;
                }
	} else {
                /* If we are the last SG block, tell the hardware. */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jz dma_last_sg;
                        if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
                                test    DMAPARAMS, DIRECTION jz dma_mid_sg;
                        }
a781 1
dma_last_sg:
d783 4
a786 2
dma_mid_sg:
                /* Start DMA data transfer. */
d788 22
a809 22
dma_loop:
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        call    idle_loop;
                }
                test    SSTAT0,DMADONE  jnz dma_dmadone;
                test    SSTAT1,PHASEMIS jz dma_loop;    /* ie. underrun */
dma_phasemis:
                /*
                 * We will be "done" DMAing when the transfer count goes to
                 * zero, or the target changes the phase (in light of this,
                 * it makes sense that the DMA circuitry doesn't ACK when
                 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
                 * the data FIFO should be flushed auto-magically on STCNT=0
                 * or a phase change, so just wait for FIFO empty status.
                 */
dma_checkfifo:
                test    DFCNTRL,DIRECTION       jnz dma_fifoempty;
dma_fifoflush:
                test    DFSTATUS,FIFOEMP        jz dma_fifoflush;
dma_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz dma_fifoempty;
d811 8
a818 52
                /*
                 * Now shut off the DMA and make sure that the DMA
                 * hardware has actually stopped.  Touching the DMA
                 * counters, etc. while a DMA is active will result
                 * in an ILLSADDR exception.
                 */
dma_dmadone:
                and     DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
                /*
                 * Some revisions of the aic78XX have a problem where, if the
                 * data fifo is full, but the PCI input latch is not empty, 
                 * HDMAEN cannot be cleared.  The fix used here is to drain
                 * the prefetched but unused data from the data fifo until
                 * there is space for the input latch to drain.
                 */
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        mov     NONE, DFDAT;
                }
                test    DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

                /* See if we have completed this last segment */
                test    STCNT[0], 0xff  jnz data_phase_finish;
                test    STCNT[1], 0xff  jnz data_phase_finish;
                test    STCNT[2], 0xff  jnz data_phase_finish;

                /*
                 * Advance the scatter-gather pointers if needed 
                 */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jz no_mwi_resid;
                        /*
                         * Reload HADDR from SHADDR and setup the
                         * count to be the size of our residual.
                         */
                        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                                bmov    HADDR, SHADDR, 4;
                                mov     HCNT, MWI_RESIDUAL;
                                bmov    HCNT[1], ALLZEROS, 2;
                        } else {
                                mvi     DINDEX, HADDR;
                                mvi     SHADDR call bcopy_4;
                                mov     MWI_RESIDUAL call set_hcnt;
                        }
                        clr     MWI_RESIDUAL;
                        jmp     sg_load_done;
no_mwi_resid:
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     data_phase_finish;
d820 6
d827 37
a863 52
                 * Load the next SG element's data address and length
                 * into the DMA engine.  If we don't have hardware
                 * to perform a prefetch, we'll have to fetch the
                 * segment from host memory first.
		 */
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        /* Wait for the idle loop to complete */
                        test    CCSGCTL, CCSGEN jz . + 3;
                        call    idle_loop;
                        test    CCSGCTL, CCSGEN jnz . - 1;
                        bmov    HADDR, CCSGRAM, 7;
                        /*
                         * Workaround for flaky external SCB RAM
                         * on certain aic7895 setups.  It seems
                         * unable to handle direct transfers from
                         * S/G ram to certain SCB locations.
                         */
                        mov     SINDEX, CCSGRAM;
                        mov     SCB_RESIDUAL_DATACNT[3], SINDEX;
                } else {
                        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                                mov     ALLZEROS call set_hhaddr;
                        }
                        mvi     DINDEX, HADDR;
                        mvi     SCB_RESIDUAL_SGPTR      call bcopy_4;

                        mvi     SG_SIZEOF       call set_hcnt;

                        or      DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

                        call    dma_finish;

                        mvi     DINDEX, HADDR;
                        call    dfdat_in_7;
                        mov     SCB_RESIDUAL_DATACNT[3], DFDAT;
                }

                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

                        /*
                         * The lowest address byte must be loaded
                         * last as it triggers the computation of
                         * some items in the PCI block.  The ULTRA2
                         * chips do this on PRELOAD.
                         */
                        mov     HADDR, HADDR;
                }
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        call calc_mwi_residual;
                }
d865 3
a867 2
                /* Point to the new next sg in memory */
                call    sg_advance;
d869 2
a870 1
sg_load_done:
a875 7
                /* Track odd'ness */
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;

                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jnz data_phase_loop;
                }
d877 18
d896 16
a911 78
        /*
         * If the target has left us in data phase, loop through
         * the dma code again.  In the case of ULTRA2 adapters,
         * we should only loop if there is a data overrun.  For
         * all other adapters, we'll loop after each S/G element
         * is loaded as well as if there is an overrun.
         */
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                test    SSTAT0, TARGET jnz data_phase_done;
        }
        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                test    SSTAT1, REQINIT jz .;
                if ((ahc->features & AHC_DT) == 0) {
                        test    SSTAT1,PHASEMIS jz data_phase_loop;
                } else {
                        test    SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
                }
        }

data_phase_done:
        /*
         * After a DMA finishes, save the SG and STCNT residuals back into
         * the SCB.  We use STCNT instead of HCNT, since it's a reflection
         * of how many bytes were transferred on the SCSI (as opposed to the
         * host) bus.
         */
        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                /* Kill off any pending prefetch */
                call    disable_ccsgen;
	}

        if ((ahc->features & AHC_ULTRA2) == 0) {
                /*
                 * Clear the high address byte so that all other DMA
                 * operations, which use 32bit addressing, can assume
                 * HHADDR is 0.
                 */
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     ALLZEROS call set_hhaddr;
                }
	}

        /*
         * Update our residual information before the information is
         * lost by some other type of SCSI I/O (e.g. PIO).  If we have
         * transferred all data, no update is needed.
         *
         */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
          && ahc->pci_cachesize != 0) {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        test    MWI_RESIDUAL, 0xFF jz bmov_resid;
                }
                mov     A, MWI_RESIDUAL;
                add     SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
                clr     A;
                adc     SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
                adc     SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
                clr     MWI_RESIDUAL;
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        jmp     . + 2;
bmov_resid:
                        bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
                }
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
                mov     SCB_RESIDUAL_DATACNT[0], STCNT[0];
                mov     SCB_RESIDUAL_DATACNT[1], STCNT[1];
                mov     SCB_RESIDUAL_DATACNT[2], STCNT[2];
	}
residual_update_done:
        /*
         * Since we've been through a data phase, the SCB_RESID* fields
         * are now initialized.  Clear the full residual flag.
         */
        and     SCB_SGPTR[0], ~SG_FULL_RESID;
a913 2
                /* Clear the channel in case we return to data phase later */
                or      SXFRCTL0, CLRSTCNT|CLRCHN;
d917 1
a917 1
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
a926 2
        } else {
                jmp     ITloop;
d928 1
d930 48
a977 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d982 19
a1000 56
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_command_okay;
        mvi     NO_IDENT jmp set_seqint;
p_command_okay:

        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HCNT[0], SCB_CDB_LEN,  1;
                bmov    HCNT[1], ALLZEROS, 2;
                mvi     SG_CACHE_PRE, LAST_SEG;
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    STCNT[0], SCB_CDB_LEN, 1;
                bmov    STCNT[1], ALLZEROS, 2;
        } else {
                mov     STCNT[0], SCB_CDB_LEN;
                clr     STCNT[1];
                clr     STCNT[2];
        }
        add     NONE, -13, SCB_CDB_LEN;
        mvi     SCB_CDB_STORE jnc p_command_embedded;
p_command_from_host:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HADDR[0], SCB_CDB_PTR, 4;
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
        } else {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        bmov    HADDR[0], SCB_CDB_PTR, 4;
                        bmov    HCNT, STCNT, 3;
                } else {
                        mvi     DINDEX, HADDR;
                        mvi     SCB_CDB_PTR call bcopy_4;
                        mov     SCB_CDB_LEN call set_hcnt;
                }
                mvi     DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
        }
        jmp     p_command_loop;
p_command_embedded:
        /*
         * The data fifo seems to require 4 byte aligned
         * transfers from the sequencer.  Force this to
         * be the case by clearing HADDR[0] even though
         * we aren't going to touch host memeory.
         */
        clr     HADDR[0];
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
                bmov    DFDAT, SCB_CDB_STORE, 12; 
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        /*
                         * On the 7895 the data FIFO will
                         * get corrupted if you try to dump
                         * data from external SCB memory into
                         * the FIFO while it is enabled.  So,
                         * fill the fifo and then enable SCSI
                         * transfers.
                         */
                        mvi     DFCNTRL, (DIRECTION|FIFORESET);
d1004 27
a1030 24
                bmov    DFDAT, SCB_CDB_STORE, 12; 
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
                } else {
                        or      DFCNTRL, FIFOFLUSH;
		}
	} else {
                mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
                call    copy_to_fifo_6;
                call    copy_to_fifo_6;
                or      DFCNTRL, FIFOFLUSH;
	}
p_command_loop:
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT0, SDONE jnz . + 2;
                test    SSTAT1, PHASEMIS jz p_command_loop;
                /*
                 * Wait for our ACK to go-away on it's own
                 * instead of being killed by SCSIEN getting cleared.
                 */
                test    SCSISIGI, ACKI jnz .;
        } else {
                test    DFCNTRL, SCSIEN jnz p_command_loop;
        }
a1032 4
        if ((ahc->features & AHC_ULTRA2) != 0) {
                /* Drop any residual from the S/G Preload queue */
                or      SXFRCTL0, CLRSTCNT;
        }
d1040 3
a1042 4
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_status_okay;
        mvi     NO_IDENT jmp set_seqint;
p_status_okay:
        mov     SCB_SCSI_STATUS, SCSIDATL;
d1070 1
a1070 6
        /* Turn on ATN for the retry */
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1075 25
d1101 4
a1104 3
        or      SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
        test    SCB_CONTROL, DISCENB jnz . + 2;
        and     SINDEX, ~DISCENB;
a1153 1
        cmp     A,MSG_IGN_WIDE_RESIDUE  je mesgin_ign_wide_residue;
d1166 1
a1166 1
        mvi     HOST_MSG_LOOP call set_seqint;
a1170 14
mesgin_ign_wide_residue:
if ((ahc->features & AHC_WIDE) != 0) {
        test    SCSIRATE, WIDEXFER jz mesgin_reject;
        /* Pull the residue byte */
        mvi     ARG_1   call inb_next;
        cmp     ARG_1, 0x01 jne mesgin_reject;
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
        test    DATA_COUNT_ODD, 0x1     jz mesgin_done;
        mvi     IGN_WIDE_RES call set_seqint;
        jmp     mesgin_done;
}

mesgin_reject:
        mvi     MSG_MESSAGE_REJECT      call mk_mesg;
d1175 1
d1178 1
a1178 1
 * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
d1185 8
a1192 18
 * sense, it will fill the kernel SCB with a request sense command, requeue
 * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
 * RETURN_1 to SEND_SENSE.
 */

/*
 * If ATN is raised, we still want to give the target a message.
 * Perhaps there was a parity error on this last message byte.
 * Either way, the target should take us to message out phase
 * and then attempt to complete the command again.  We should use a
 * critical section here to guard against a timeout triggering
 * for this command and setting ATN while we are still processing
 * the completion.
        test    SCSISIGI, ATNI jnz mesgin_done;
 */

/*
 * See if we attempted to deliver a message but the target ingnored us.
a1193 2
        test    SCB_CONTROL, MK_MESSAGE jz . + 2;
        mvi     MKMSG_FAILED call set_seqint;
d1196 1
a1196 1
 * Check for residuals
d1198 2
a1199 5
        test    SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
        test    SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
check_status:
        test    SCB_SCSI_STATUS,0xff    jz complete;    /* Good Status? */
a1200 1
        or      SCB_SGPTR, SG_RESID_VALID;
d1203 4
a1206 2
        test    SCB_SCSI_STATUS, 0xff   jz complete;    /* Just a residual? */
        mvi     BAD_STATUS call set_seqint;             /* let driver know */
d1208 11
a1218 1
        call    add_scb_to_free_list;
d1220 1
d1222 8
d1250 1
a1250 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d1253 1
a1253 3
 * and await the bus going free.  If this is an untagged transaction
 * store the SCB id for it in our untagged target table for lookup on
 * a reselction.
a1255 10
        /*
         * If ATN is raised, we still want to give the target a message.
         * Perhaps there was a parity error on this last message byte
         * or we want to abort this command.  Either way, the target
         * should take us to message out phase and then attempt to
         * disconnect again.
         * XXX - Wait for more testing.
        test    SCSISIGI, ATNI jnz mesgin_done;
         */

d1257 1
a1257 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    add_scb_to_disc_list;
        }
        test    SCB_CONTROL, TAG_ENB jnz await_busfree;
        mov     ARG_1, SCB_TAG;
        mov     SAVED_LUN, SCB_LUN;
        mov     SCB_SCSIID      call set_busy_target;
a1265 3
 * Ack the message as soon as possible.  For chips without S/G pipelining,
 * we can only ack the message after SHADDR has been saved.  On these
 * chips, SHADDR increments with every bus transaction, even PIO.
d1268 1
a1268 6
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     NONE,SCSIDATL;          /*dummy read from latch to ACK*/
                test    SEQ_FLAGS, DPHASE       jz ITloop;
        } else {
                test    SEQ_FLAGS, DPHASE       jz mesgin_done;
        }
d1271 2
a1272 17
         * If we are asked to save our position at the end of the
         * transfer, just mark us at the end rather than perform a
         * full save.
         */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
        or      SCB_SGPTR, SG_LIST_NULL;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                jmp     ITloop;
        } else {
                jmp     mesgin_done;
        }

mesgin_sdptrs_full:

        /*
         * The SCB_SGPTR becomes the next one we'll download,
         * and the SCB_DATAPTR becomes the current SHADDR.
d1277 1
d1279 1
a1279 4
                if ((ahc->features & AHC_ULTRA2) == 0) {
                        mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                }
                bmov    SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1281 3
d1285 2
a1286 3
                mvi     SHADDR call bcopy_4;
                mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                mvi     SCB_RESIDUAL_DATACNT call bcopy_8;
d1288 1
a1288 1
        jmp     ITloop;
a1304 14
 * Index into our Busy Target table.  SINDEX and DINDEX are modified
 * upon return.  SCBPTR may be modified by this action.
 */
set_busy_target:
        shr     DINDEX, 4, SINDEX;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, SAVED_LUN;
                add     DINDEX, SCB_64_BTT;
        } else {
                add     DINDEX, BUSY_TARGETS;
        }
        mov     DINDIR, ARG_1 ret;

/*
d1310 4
a1313 34
        /*
         * Determine whether a target is using tagged or non-tagged
         * transactions by first looking at the transaction stored in
         * the busy target array.  If there is no untagged transaction
         * for this target or the transaction is for a different lun, then
         * this must be an untagged transaction.
         */
        shr     SINDEX, 4, SAVED_SCSIID;
        and     SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                add     SINDEX, SCB_64_BTT;
                mov     SCBPTR, SAVED_LUN;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -SCB_64_BTT, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(SCB_64_BTT + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
	} else {
                add     SINDEX, BUSY_TARGETS;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -BUSY_TARGETS, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(BUSY_TARGETS + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
d1315 4
a1318 1
        mov     ARG_1, SINDIR;
d1321 10
a1330 25
                mov     ARG_1 call findSCB;
        } else {
                mov     SCBPTR, ARG_1;
	}
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                jmp setup_SCB_id_lun_okay;
        } else {
                /*
                 * We only allow one untagged command per-target
                 * at a time.  So, if the lun doesn't match, look
                 * for a tag message.
                 */
                mov     A, SCB_LUN;
                cmp     SAVED_LUN, A    je setup_SCB_id_lun_okay;
                if ((ahc->flags & AHC_PAGESCBS) != 0) {
                        /*
                         * findSCB removes the SCB from the
                         * disconnected list, so we must replace
                         * it there should this SCB be for another
                         * lun.
                         */
                        call    cleanup_scb;
                }
        }

d1334 4
a1337 4
 * SCB.  With SCB paging, we must search for non-tagged
 * transactions since the SCB may exist in any slot.  If we're not
 * using SCB paging, we can use the tag as the direct index to the
 * SCB.
a1339 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x80;
        }
d1341 1
a1342 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x1;
        }
a1343 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x2;
        }
d1346 1
a1346 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     ARG_1   call findSCB;
        } else {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     SCBPTR, ARG_1;
        }
d1348 6
a1353 4
/*
 * Ensure that the SCB the tag points to is for
 * an SCB transaction to the reconnecting target.
 */
d1355 2
a1356 15
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x4;
        }
        mov     A, SCB_SCSIID;
        cmp     SAVED_SCSIID, A jne not_found_cleanup_scb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x8;
        }
setup_SCB_id_okay:
        mov     A, SCB_LUN;
        cmp     SAVED_LUN, A    jne not_found_cleanup_scb;
setup_SCB_id_lun_okay:
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x10;
        }
d1359 1
a1359 11
        test    SCB_CONTROL, TAG_ENB    jnz setup_SCB_tagged;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     A, SCBPTR;
        }
        mvi     ARG_1, SCB_LIST_NULL;
        mov     SAVED_SCSIID    call    set_busy_target;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, A;
        }
setup_SCB_tagged:
        mvi     SEQ_FLAGS,IDENTIFY_SEEN;        /* make note of IDENTIFY */
d1363 1
d1368 4
a1371 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    cleanup_scb;
        }
d1373 1
a1373 1
        mvi     NO_MATCH call set_seqint;
d1376 8
d1385 1
a1385 5
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1404 1
a1404 1
        mvi     PERR_DETECTED call set_seqint;
d1426 1
a1426 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1443 1
a1443 1
         * we must wait at least a data release delay plus
d1466 1
d1468 70
a1537 5
 * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will
 * be set to the position of the SCB.  If the SCB cannot be found locally,
 * it will be paged in from host memory.  RETURN_2 stores the address of the
 * preceding SCB in the disconnected list which can be used to speed up
 * removal of the found SCB from the disconnected list.
a1538 2
if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL
d1540 7
a1546 5
        mov     A, SINDEX;                      /* Tag passed in SINDEX */
        cmp     DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
        mov     SCBPTR, DISCONNECTED_SCBH;      /* Initialize SCBPTR */
        mvi     ARG_2, SCB_LIST_NULL;           /* Head of list */
        jmp     findSCB_loop;
a1547 1
        cmp     SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d1549 1
d1551 1
d1553 23
a1575 1
        cmp     SCB_TAG, A      jne findSCB_next;
d1577 1
a1579 1
        mov     SINDEX, SCBPTR;
d1585 7
a1591 7
END_CRITICAL
findSCB_notFound:
        /*
         * We didn't find it.  Page in the SCB.
         */
        mov     ARG_1, A; /* Save tag */
        mov     ALLZEROS call get_free_or_disc_scb;
d1593 1
d1595 44
a1638 1
}
d1642 1
a1642 1
 * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.
d1648 1
a1648 1
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
d1653 4
a1656 2
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
                mvi     1       call set_hcnt;
d1672 5
d1678 1
a1678 1
        mvi     PERR_DETECTED call set_seqint;
d1688 1
a1688 3
        if ((ahc->features & AHC_DT) == 0) {
                and     SCSISIGO, PHASE_MASK, SCSISIGI;
        }
a1691 6
set_hcnt:
        mov     HCNT[0], SINDEX;
clear_hcnt:
        clr     HCNT[1];
        clr     HCNT[2] ret;

a1696 2
bcopy_8:
        mov     DINDIR, SINDIR;
d1710 1
a1710 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1736 1
a1736 1
 * Setup addr assuming that A + (ARG_2 * 256) is an
d1761 1
a1761 5
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE_64;
                } else {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE;
                }
d1766 2
a1767 2
                mvi     CCHCNT, SCB_UPLOAD_SIZE;
                if ((ahc->features & AHC_ULTRA2) == 0) {
d1769 1
a1769 1
                        bmov    CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
a1771 6
                } else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
                        mvi     CCSCBCTL, CCARREN|CCSCBRESET;
                        cmp     CCSCBCTL, ARRDONE|CCARREN jne .;
                        mvi     CCHCNT, SCB_UPLOAD_SIZE;
                        mvi     CCSCBCTL, CCSCBEN|CCSCBRESET;
                        cmp     CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d1783 3
a1785 1
                mvi     SCB_DOWNLOAD_SIZE call set_hcnt;
d1790 2
a1791 2
                mvi     SINDEX, SCB_BASE;
                add     A, SCB_DOWNLOAD_SIZE, SINDEX;
d1793 7
a1799 1
                call    copy_to_fifo_8;
a1801 1
                jmp     dma_finish;
d1803 1
a1803 49
                mvi     DINDEX, SCB_BASE;
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        /*
                         * The PCI module will only issue a PCI
                         * retry if the data FIFO is empty.  If the
                         * host disconnects in the middle of a
                         * transfer, we must empty the fifo of all
                         * available data to force the chip to
                         * continue the transfer.  This does not
                         * happen for SCSI transfers as the SCSI module
                         * will drain the FIFO as data is made available.
                         * When the hang occurs, we know that a multiple
                         * of 8 bytes are in the FIFO because the PCI
                         * module has an 8 byte input latch that only
                         * dumps to the FIFO when HCNT == 0 or the
                         * latch is full.
                         */
                        clr     A;
                        /* Wait for at least 8 bytes of data to arrive. */
dma_scb_hang_fifo:
                        test    DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
                        test    DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        /*
                         * The PCI module no longer intends to perform
                         * a PCI transaction.  Drain the fifo.
                         */
dma_scb_hang_dma_drain_fifo:
                        not     A, HCNT;
                        add     A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
                        and     A, ~0x7;
                        mov     DINDIR,DFDAT;
                        cmp     DINDEX, A jne . - 1;
                        cmp     DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
                                je      dma_finish_nowait;
                        /* Restore A as the lines left to transfer. */
                        add     A, -SCB_BASE, DINDEX;
                        shr     A, 3;
                        jmp     dma_scb_hang_fifo;
dma_scb_hang_dma_done:
                        and     DFCNTRL, ~HDMAEN;
                        test    DFCNTRL, HDMAEN jnz .;
                        add     SEQADDR0, A;
                } else {
                        call    dma_finish;
                }
d1805 5
a1809 5
                call    dfdat_in_8;
                call    dfdat_in_8;
                call    dfdat_in_8;
dfdat_in_8:
                mov     DINDIR,DFDAT;
d1811 2
a1817 1
dfdat_in_2:
a1821 12
copy_to_fifo_8:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
copy_to_fifo_6:
        mov     DFDAT,SINDIR;
copy_to_fifo_5:
        mov     DFDAT,SINDIR;
copy_to_fifo_4:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR ret;
a1828 1
dma_finish_nowait:
a1833 10
/*
 * Restore an SCB that failed to match an incoming reselection
 * to the correct/safe state.  If the SCB is for a disconnected
 * transaction, it must be returned to the disconnected list.
 * If it is not in the disconnected state, it must be free.
 */
cleanup_scb:
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                test    SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
        }
a1835 1
BEGIN_CRITICAL
a1838 1
END_CRITICAL
a1842 7
if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
set_hhaddr:
        or      DSCOMMAND1, HADDLDSEL0;
        and     HADDR, SG_HIGH_ADDR_BITS, SINDEX;
        and     DSCOMMAND1, ~HADDLDSEL0 ret;
}

a1844 1
BEGIN_CRITICAL
a1847 1
        mvi     NO_FREE_SCB call set_seqint;
d1851 1
a1851 2
        mov     DISCONNECTED_SCBH, SCB_NEXT;
END_CRITICAL
d1853 3
a1855 2
        mov     SCB_TAG jmp dma_scb;
BEGIN_CRITICAL
d1859 1
a1859 1
END_CRITICAL
a1866 1
BEGIN_CRITICAL
a1868 7
END_CRITICAL
}
set_seqint:
        mov     INTSTAT, SINDEX;
        nop;
return:
        ret;
@


1.8
log
@Import tagging code and try to resolve locking problem.
@
text
@d1 1
d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.93 2000/01/07 23:08:20 gibbs Exp $
d35 2
a38 3
/*
#include <cam/scsi/scsi_message.h>
*/
d58 7
a64 12
reset:
	clr	SCSISIGO;		/* De-assert BSY */
	mvi	MSG_OUT, MSG_NOOP;	/* No message to send */
	and	SXFRCTL1, ~BITBUCKET;
	/* Always allow reselection */
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ_TEMPLATE;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		clr	CCSGCTL;
		clr	CCSCBCTL;
	}

d68 7
a74 2
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		mov	A, QINPOS;
d76 1
a77 5
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		and	SEQCTL, ~PAUSEDIS;
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
	test	SCSISEQ, ENSELO	jnz poll_for_work_loop;
a78 6
		/*
		 * Twin channel devices cannot handle things like SELTO
		 * interrupts on the "background" channel.  So, if we
		 * are selecting, keep polling the current channel util
		 * either a selection or reselection occurs.
		 */
d80 2
a81 5
		test	SSTAT0, SELDO|SELDI	jnz selection;
		test	SCSISEQ, ENSELO	jnz poll_for_work;
		xor	SBLKCTL,SELBUSB;	/* Toggle back */
	}
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d84 1
a86 2
		mov	NONE, SNSCB_QOFF;
		inc	QINPOS;
d88 1
a88 1
		or	SEQCTL, PAUSEDIS;
a89 2
		inc	QINPOS;
		and	SEQCTL, ~PAUSEDIS;
d91 1
d93 5
a97 6
/*
 * We have at least one queued SCB now and we don't have any 
 * SCBs in the list of SCBs awaiting selection.  If we have
 * any SCBs available for use, pull the tag from the QINFIFO
 * and get to work on it.
 */
d100 1
a100 7
	}

dequeue_scb:
	add	A, -1, QINPOS;
	mvi	QINFIFO_OFFSET call fetch_byte;

	if ((ahc->flags & AHC_PAGESCBS) == 0) {
d102 1
a102 1
		mov	SCBPTR, RETURN_2;
d104 2
d107 3
a109 3
/*
 * DMA the SCB from host ram into the current SCB location.
 */
d111 13
a123 14
	mov	RETURN_2	 call dma_scb;

/*
 * Preset the residual fields in case we never go through a data phase.
 * This isn't done by the host so we can avoid a DMA to clear these
 * fields for the normal case of I/O that completes without underrun
 * or overrun conditions.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, SCB_DATACNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],SCB_DATACNT[0];
		mov	SCB_RESID_DCNT[1],SCB_DATACNT[1];
		mov	SCB_RESID_DCNT[2],SCB_DATACNT[2];
d125 1
a125 7
	mov	SCB_RESID_SGCNT, SCB_SGCOUNT;

start_scb:
	/*
	 * Place us on the waiting list in case our selection
	 * doesn't win during bus arbitration.
	 */
d128 7
d137 1
a137 1
	 * Pull the first entry off of the waiting SCB list.
a140 1
	jmp	poll_for_work;
d142 8
a149 52
start_selection:
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		and	A,SELBUSB,SCB_TCL;	/* Get new channel bit */
		or	SINDEX,A;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
initialize_scsiid:
	mov	SINDEX, SCSISEQ_TEMPLATE;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SCB_CONTROL, TARGET_SCB jz . + 4;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mov	SCSIID_ULTRA2, SCB_CMDPTR[2];
		} else {
			mov	SCSIID, SCB_CMDPTR[2];
		}
		or	SINDEX, TEMODE;
		jmp	initialize_scsiid_fini;
	}
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID_ULTRA2, OID;	/* Clear old target */
		or	SCSIID_ULTRA2, A;
	} else {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID, OID;		/* Clear old target */
		or	SCSIID, A;
	}
initialize_scsiid_fini:
	mov	SCSISEQ, SINDEX ret;

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
	or	SXFRCTL0, CLRSTCNT|CLRCHN, SINDEX;
set_transfer_settings:
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
/*
 * Initialize SCSIRATE with the appropriate value for this target.
 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}
d152 15
a167 1
	mvi	CLRSINT0, CLRSELDI;
d169 2
a170 2
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d173 1
a180 1
		mvi	CLRSINT1, CLRBUSFREE;
d191 1
a191 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d195 1
a195 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d200 1
a200 7
		and	SAVED_TCL, SELID_MASK, SELID;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_TCL;
		} else {
			mov	DFDAT, SAVED_TCL;
		}

d202 14
a215 8
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	CCSCBRAM, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	CCSCBRAM, OID, SCSIID_ULTRA2;
			} else {
				and	CCSCBRAM, OID, SCSIID;
			}
d217 2
a218 11
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	DFDAT, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	DFDAT, OID, SCSIID_ULTRA2;
			} else {
				and	DFDAT, OID, SCSIID;
			}
		}

		/* No tag yet */
		mvi	INITIATOR_TAG, SCB_LIST_NULL;
d223 2
a238 1
		/* XXX May need to be more lax here for older initiators... */
d288 4
d299 1
a299 2
		mvi	INTSTAT, HOST_MSG_LOOP;
		nop;
d309 1
a309 1
		mov	A, KERNEL_TQINPOS;
d313 1
a313 1
		cmp	INITIATOR_TAG, SCB_LIST_NULL je . + 3;
d326 1
a326 1
		test	SCSISIGI, ATNI	jnz target_mesgout_pending_msg;
d328 86
a413 1
		
d420 10
a429 33
		/*
		 * Drive REQ on the bus by enabling SCSI PIO.
		 */
		or	SXFRCTL0, SPIOEN;
		/* Wait for the byte */
		test	SSTAT0, SPIORDY jz .;
		/* Prevent our read from triggering another REQ */
		and	SXFRCTL0, ~SPIOEN;
		/* Save latched contents */
		mov	DINDEX, SCSIDATL ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
/*
 * Reselection has been initiated by a target. Make a note that we've been
 * reselected, but haven't seen an IDENTIFY message from the target yet.
 */
initiator_reselect:
	/* XXX test for and handle ONE BIT condition */
	and	SAVED_TCL, SELID_MASK, SELID;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_TCL, SELBUSB;
	}
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;		/*
						 * We aren't expecting a
						 * bus free, so interrupt
						 * the kernel driver if it
						 * happens.
						 */
	jmp	ITloop;
a440 1
/*and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;*/
d444 4
a447 2
	mov	SAVED_TCL, SCB_TCL;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
a455 1
		mvi	CLRSINT1,CLRBUSFREE;
d460 1
a460 2
		and	A, LID, SCB_TCL;
		or	A, MSG_IDENTIFYFLAG call target_outb;
d468 1
a468 2
		mov	SCB_INITIATOR_TAG call target_outb;
		mov	INITIATOR_TAG, SCB_INITIATOR_TAG;
d474 1
a474 1
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
d476 3
a478 1

d494 3
a499 3
		mov	RETURN_1, ALLZEROS;
		call	complete_target_cmd;
		cmp	RETURN_1, CONT_MSG_LOOP jne .;
d506 1
d508 1
a509 1
target_mesgout_pending_msg:
d519 1
a519 1
		/* Wait for preceeding I/O session to complete. */
d522 4
d551 1
a551 1
		add	SINDEX, TARG_SCSIRATE, A;
d555 1
a556 1
		or	SXFRCTL0, SPIOEN;
d574 9
a582 10
		 * Data direction flags are from the
		 * perspective of the initiator.
		 */
		test	SCB_TARGET_PHASES[1], TARGET_DATA_IN jz . + 4;
		mvi	LASTPHASE, P_DATAOUT;
		mvi	P_DATAIN|BSYO call change_phase;
		jmp	. + 3;
		mvi	LASTPHASE, P_DATAIN;
		mvi	P_DATAOUT|BSYO call change_phase;
		mov	ALLZEROS call initialize_channel;
d588 1
a588 1
		mov	SCB_TARGET_STATUS call target_outb;
d611 1
a611 3
			mvi	HCNT[0], 28;
			clr	HCNT[1];
			clr	HCNT[2];
d619 1
a619 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
a620 9
	mvi	SPIOEN call	initialize_channel;

	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;

d634 1
d646 1
a646 1
	mvi	INTSTAT,BAD_PHASE;
d652 3
d658 1
a658 1
	mvi	INTSTAT, BAD_PHASE;
d668 1
d679 3
a681 1
		and	SXFRCTL0, ~(FAST20);
d687 78
d766 31
a796 20
 * If we re-enter the data phase after going through another phase, the
 * STCNT may have been cleared, so restore it from the residual field.
 */
data_phase_reinit:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		/*
		 * The preload circuitry requires us to
		 * reload the address too, so pull it from
		 * the shaddow address.
		 */
		bmov	HADDR, SHADDR, 4;
		bmov	HCNT, SCB_RESID_DCNT, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, SCB_RESID_DCNT, 3;
	} else {
		mvi	DINDEX, STCNT;
		mvi	SCB_RESID_DCNT	call bcopy_3;
	}
	and	DATA_COUNT_ODD, 0x1, SCB_RESID_DCNT[0];
	jmp	data_phase_loop;
d799 3
a808 4
	call	assert;			/*
					 * Ensure entering a data
					 * phase is okay - seen identify, etc.
					 */
d810 2
a811 1
		mvi	CCSGADDR, CCSGADDR_MAX;
d813 10
a822 1
	test	SEQ_FLAGS, DPHASE	jnz data_phase_reinit;
d824 2
a825 1
	/* We have seen a data phase */
d830 4
a833 3
	 * Also set SG_COUNT and SG_NEXT in memory since we cannot
	 * modify the values in the SCB itself until we see a
	 * save data pointers message.
d835 4
d841 1
d845 2
d848 5
a852 1
	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];
d859 1
a859 1
		}
d862 3
a864 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SG_COUNT, SCB_SGCOUNT, 5;
	} else {
		mvi	DINDEX, SG_COUNT;
		mvi	SCB_SGCOUNT	call bcopy_5;
	}
d866 6
a871 9
data_phase_loop:
/* Guard against overruns */
	test	SG_COUNT, 0xff jnz data_phase_inbounds;
/*
 * Turn on 'Bit Bucket' mode, set the transfer count to
 * 16meg and let the target run until it changes phase.
 * When the transfer completes, notify the host that we
 * had an overrun.
 */
d873 2
a874 5
	and	DMAPARAMS, ~(HDMAEN|SDMAEN);
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT, ALLONES, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, ALLONES, 3;
d876 1
a876 3
		mvi	STCNT[0], 0xFF;
		mvi	STCNT[1], 0xFF;
		mvi	STCNT[2], 0xFF;
d878 4
a882 2
/* If we are the last SG block, tell the hardware. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd;
d884 194
a1077 5
		or	SG_CACHEPTR, LAST_SEG;
	} else {
		if ((ahc->flags & AHC_TARGETMODE) != 0) {
			test	SSTAT0, TARGET jz . + 2;
			test	DMAPARAMS, DIRECTION jz data_phase_wideodd;
d1079 1
d1081 2
a1082 4
	}
data_phase_wideodd:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SINDEX, ALLONES;
d1084 22
a1105 7
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
data_phase_dma_loop:
		test	SSTAT0,	SDONE jnz data_phase_dma_done;
		test	SSTAT1,PHASEMIS	jz data_phase_dma_loop;	/* ie. underrun */
	} else {
		mov	DMAPARAMS  call dma;
	}
d1107 52
a1158 23
data_phase_dma_done:
/* Go tell the host about any overruns */
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun;

/* See if we completed this segment */
	test	STCNT[0], 0xff	jnz data_phase_finish;
	test	STCNT[1], 0xff	jnz data_phase_finish;
	test	STCNT[2], 0xff	jnz data_phase_finish;

/*
 * Advance the scatter-gather pointers if needed 
 */
sg_advance:
	dec	SG_COUNT;	/* one less segment to go */

	test	SG_COUNT, 0xff	jz data_phase_finish; /* Are we done? */
/*
 * Load a struct scatter and set up the data address and length.
 * If the working value of the SG count is nonzero, then
 * we need to load a new set of values.
 *
 * This, like all DMA's, assumes little-endian host data storage.
 */
a1159 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/*
		 * Do we have any prefetch left???
		 */
		cmp	CCSGADDR, CCSGADDR_MAX jne prefetched_segs_avail;

d1161 52
a1212 37
		 * Fetch MIN(CCSGADDR_MAX, (SG_COUNT * 8)) bytes.
		 */
		add	A, -(CCSGRAM_MAXSEGS + 1), SG_COUNT;
		mvi	A, CCSGADDR_MAX;
		jc	. + 2;
		shl	A, 3, SG_COUNT;
		mov	CCHCNT, A;
		bmov	CCHADDR, SG_NEXT, 4;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		and	CCSGCTL, ~CCSGEN;
		test	CCSGCTL, CCSGEN jnz .;
		mvi	CCSGCTL, CCSGRESET;
prefetched_segs_avail:
		bmov 	HADDR, CCSGRAM, 8;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SG_NEXT	call bcopy_4;

		mvi	HCNT[0],SG_SIZEOF;
		clr	HCNT[1];
		clr	HCNT[2];

		or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

		call	dma_finish;

		/*
		 * Copy data from FIFO into SCB data pointer and data count.
		 * This assumes that the SG segments are of the form:
		 * struct ahc_dma_seg {
		 *	u_int32_t	addr;	four bytes, little-endian order
		 *	u_int32_t	len;	four bytes, little endian order
		 * };
		 */
		mvi	HADDR	call dfdat_in_7;
	}
d1214 2
a1215 3
	/* Track odd'ness */
	test	HCNT[0], 0x1 jz . + 2;
	xor	DATA_COUNT_ODD, 0x1;
d1217 1
a1217 2
	if ((ahc->features & AHC_ULTRA2) == 0) {
		/* Load STCNT as well.  It is a mirror of HCNT */
d1223 7
a1230 18

/* Advance the SG pointer */
	clr	A;			/* add sizeof(struct scatter) */
	add	SG_NEXT[0],SG_SIZEOF;
	adc	SG_NEXT[1],A;

	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_loop;
	}
	test	SSTAT1, REQINIT jz .;
	test	SSTAT1,PHASEMIS	jz data_phase_loop;

	/* Ensure the last seg is visable at the shaddow layer */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	DFCNTRL, DMAPARAMS;
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
	}

d1232 78
a1309 16
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
	}
/*
 * After a DMA finishes, save the SG and STCNT residuals back into the SCB
 * We use STCNT instead of HCNT, since it's a reflection of how many bytes 
 * were transferred on the SCSI (as opposed to the host) bus.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, STCNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],STCNT[0];
		mov	SCB_RESID_DCNT[1],STCNT[1];
		mov	SCB_RESID_DCNT[2],STCNT[2];
	}
	mov	SCB_RESID_SGCNT, SG_COUNT;
d1312 2
d1317 1
a1317 1
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1327 2
a1329 1
	jmp	ITloop;
d1331 1
a1331 48
data_phase_overrun:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}
/*
 * Turn off BITBUCKET mode and notify the host
 */
	and	SXFRCTL1, ~BITBUCKET;
	mvi	INTSTAT,DATA_OVERRUN;
	jmp	ITloop;

ultra2_dmafinish:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		test	DFCNTRL, DIRECTION jnz ultra2_dmafifoempty;
		and	DFCNTRL, ~SCSIEN;
		test	DFCNTRL, SCSIEN jnz .;
ultra2_dmafifoflush:
		or	DFCNTRL, FIFOFLUSH;
		/*
		 * The FIFOEMP status bit on the Ultra2 class
		 * of controllers seems to be a bit flaky.
		 * It appears that if the FIFO is full and the
		 * transfer ends with some data in the REQ/ACK
		 * FIFO, FIFOEMP will fall temporarily
		 * as the data is transferred to the PCI bus.
		 * This glitch lasts for fewer than 5 clock cycles,
		 * so we work around the problem by ensuring the
		 * status bit stays false through a full glitch
		 * window.
		 */
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;

ultra2_dmafifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_dmafifoempty;

ultra2_dmahalt:
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, HDMAEN jnz .;
		ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1336 56
a1391 19
	call	assert;

	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mov	HCNT[0], SCB_CMDLEN;
		bmov	HCNT[1], ALLZEROS, 2;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			bmov	STCNT, HCNT, 3;
		}
		add	NONE, -17, SCB_CMDLEN;
		jc	dma_cmd_data;
		/*
		 * The data fifo seems to require 4 byte alligned
		 * transfers from the sequencer.  Force this to
		 * be the case by clearing HADDR[0] even though
		 * we aren't going to touch host memeory.
		 */
		bmov	HADDR[0], ALLZEROS, 1;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
d1395 24
a1418 27
		bmov   DFDAT, SCB_CMDSTORE, 16; 
		jmp	cmd_loop;
dma_cmd_data:
		bmov	HADDR, SCB_CMDPTR, 4;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_CMDPTR	call bcopy_5;
		clr	HCNT[1];
		clr	HCNT[2];
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) == 0) {
			call	set_stcnt_from_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	} else {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	}
cmd_loop:
	test	SSTAT0, SDONE jnz . + 2;
	test    SSTAT1, PHASEMIS jz cmd_loop;
	/*
	 * Wait for our ACK to go-away on it's own
	 * instead of being killed by SCSIEN getting cleared.
	 */
	test	SCSISIGI, ACKI jnz .;
d1421 4
d1432 4
a1435 3
	call	assert;

	mov	SCB_TARGET_STATUS, SCSIDATL;
d1463 6
a1468 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATN for the retry */
a1472 25
	mov	FUNCTION1, SCB_TCL;
	mov	A, FUNCTION1;
	if ((ahc->features & AHC_HS_MAILBOX) != 0) {
		/*
		 * Work around a pausing bug in at least the aic7890.
		 * If the host needs to update the TARGET_MSG_REQUEST
		 * bit field, it will set the HS_MAILBOX to 1.  In
		 * response, we pause with a specific interrupt code
		 * asking for the mask to be updated before we continue.
		 * Ugh.
		 */
		test	HS_MAILBOX, 0xF0	jz . + 2;
		mvi	INTSTAT, UPDATE_TMSG_REQ;
		nop;
	}
	mov	SINDEX, TARGET_MSG_REQUEST[0];
	if ((ahc->features & AHC_TWIN) != 0) {
		/* Second Channel uses high byte bits */
		test	SCB_TCL, SELBUSB	jz . + 2;
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	} else if ((ahc->features & AHC_WIDE) != 0) {
		test	SCB_TCL, 0x80		jz . + 2; /* target > 7 */
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	}
	test	SINDEX, A	jnz host_message_loop;
d1474 3
a1476 4
	and	SINDEX,LID,SCB_TCL;	/* lun */
	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privledge */
	or	SINDEX,A;		/* or in disconnect privledge */
	or	SINDEX,MSG_IDENTIFYFLAG;
d1526 1
d1539 1
a1539 1
	mvi	INTSTAT, HOST_MSG_LOOP;
d1544 14
a1561 1

d1564 1
a1564 1
 * We got a "command complete" message, so put the SCB_TAG into the QOUTFIFO,
d1571 18
a1588 8
 * sense, it will fill the kernel SCB with a request sense command and set
 * RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE we redownload
 * the SCB, and process it as the next command by adding it to the waiting list.
 * If the kernel driver does not wish to request sense, it need only clear
 * RETURN_1, and the command is allowed to complete normally.  We don't bother
 * to post to the QOUTFIFO in the error cases since it would require extra
 * work in the kernel driver to ensure that the entry was removed before the
 * command complete code tried processing it.
d1590 2
d1594 1
a1594 1
 * First check for residuals
d1596 5
a1600 2
	test	SCB_RESID_SGCNT,0xff	jnz upload_scb;
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Good Status? */
d1602 1
d1605 2
a1606 4
check_status:
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Just a residual? */
	mvi	INTSTAT,BAD_STATUS;			/* let driver know */
	nop;
d1608 1
a1608 11
	/* This SCB becomes the next to execute as it will retrieve sense */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	SCB_TAG		call dma_scb;
add_to_waiting_list:
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
	/*
	 * Prepare our selection hardware before the busfree so we have a
	 * high probability of winning arbitration.
	 */
	call	start_selection;
a1609 1

a1610 8
	/* If we are untagged, clear our address up in host ram */
	test	SCB_CONTROL, TAG_ENB jnz complete_queue;
	mov	A, SAVED_TCL;
	/* fvdl - let ahc_intr clear this to avoid race conditions */
	/* mvi	UNTAGGEDSCB_OFFSET call post_byte_setup; */
	/* mvi	SCB_LIST_NULL call post_byte; */

complete_queue:
d1631 1
a1631 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1634 3
a1636 1
 * and await the bus going free.
d1639 10
d1650 7
a1656 1
	call	add_scb_to_disc_list;
d1665 3
d1670 6
a1675 1
	test	SEQ_FLAGS, DPHASE	jz mesgin_done;
d1678 17
a1694 2
	 * The SCB SGPTR becomes the next one we'll download,
	 * and the SCB DATAPTR becomes the current SHADDR.
a1698 1
		bmov	SCB_SGCOUNT, SG_COUNT, 5;
d1700 4
a1703 1
		bmov	SCB_DATACNT, SCB_RESID_DCNT, 3;
a1704 3
		mvi	DINDEX, SCB_SGCOUNT;
		mvi	SG_COUNT call bcopy_5;
	
d1706 3
a1708 2
		mvi	SHADDR		call bcopy_4;
		mvi	SCB_RESID_DCNT	call bcopy_3;
d1710 1
a1710 1
	jmp	mesgin_done;
d1727 14
d1746 34
a1779 4
	if ((ahc->features & AHC_WIDE) != 0) {
		and	A,0x0f;		/* lun in lower four bits */
	} else {
		and	A,0x07;		/* lun in lower three bits */
d1781 1
a1781 4
	or      SAVED_TCL,A;		/* SAVED_TCL should be complete now */

	mvi	ARG_2, SCB_LIST_NULL;	/* SCBID of prev SCB in disc List */
	call	get_untagged_SCBID;
d1784 25
a1808 10
		test	SEQ_FLAGS, SCBPTR_VALID	jz use_retrieveSCB;
	}
	/*
	 * If the SCB was found in the disconnected list (as is
	 * always the case in non-paging scenarios), SCBPTR is already
	 * set to the correct SCB.  So, simply setup the SCB and get
	 * on with things.
	 */
	call	rem_scb_from_disc_list;
	jmp	setup_SCB;
d1812 4
a1815 4
 * SCB.  With SCB paging, this requires using search for both tagged
 * and non-tagged transactions since the SCB may exist in any slot.
 * If we're not using SCB paging, we can use the tag as the direct
 * index to the SCB.
d1818 3
a1821 1
snoop_tag_loop:
d1823 3
d1827 3
d1832 7
a1838 1
	mvi	ARG_1	call inb_next;	/* tag value */
d1840 4
a1843 6
	/*
	 * Ensure that the SCB the tag points to is for
	 * an SCB transaction to the reconnecting target.
	 */
use_retrieveSCB:
	call	retrieveSCB;
d1845 15
a1859 2
	mov	A, SAVED_TCL;
	cmp	SCB_TCL, A	jne not_found_cleanup_scb;
d1862 11
a1872 1
	or	SEQ_FLAGS,IDENTIFY_SEEN;	/* make note of IDENTIFY */
a1875 1
	and	SCB_CONTROL, ~MK_MESSAGE;
d1880 3
a1882 4
	test	SCB_CONTROL, DISCONNECTED jz . + 3;
	call	add_scb_to_disc_list;
	jmp	not_found;
	call	add_scb_to_free_list;
d1884 1
a1884 1
	mvi	INTSTAT, NO_MATCH;
a1886 8
/*
 * [ ADD MORE MESSAGE HANDLING HERE ]
 */

/*
 * Locking the driver out, build a one-byte message passed in SINDEX
 * if there is no active message already.  SINDEX is returned intact.
 */
d1888 5
a1892 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATNO */
d1911 1
a1911 1
	mvi	INTSTAT, PERR_DETECTED;
d1933 1
a1933 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1950 1
a1950 1
	 * we must waitat least a data release delay plus
a1972 1
mesgin_phasemis:
d1974 5
a1978 70
 * We expected to receive another byte, but the target changed phase
 */
	mvi	INTSTAT, MSGIN_PHASEMIS;
	jmp	ITloop;

/*
 * DMA data transfer.  HADDR and HCNT must be loaded first, and
 * SINDEX should contain the value to load DFCNTRL with - 0x3d for
 * host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
 * during initialization.
 */
dma:
	mov	DFCNTRL,SINDEX;
dma_loop:
	test	SSTAT0,DMADONE	jnz dma_dmadone;
	test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
dma_phasemis:

/*
 * We will be "done" DMAing when the transfer count goes to zero, or
 * the target changes the phase (in light of this, it makes sense that
 * the DMA circuitry doesn't ACK when PHASEMIS is active).  If we are
 * doing a SCSI->Host transfer, the data FIFO should be flushed auto-
 * magically on STCNT=0 or a phase change, so just wait for FIFO empty
 * status.
 */
dma_checkfifo:
	test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
dma_fifoflush:
	test	DFSTATUS,FIFOEMP	jz dma_fifoflush;

dma_fifoempty:
	/* Don't clobber an inprogress host data transfer */
	test	DFSTATUS, MREQPEND	jnz dma_fifoempty;
/*
 * Now shut the DMA enables off and make sure that the DMA enables are 
 * actually off first lest we get an ILLSADDR.
 */
dma_dmadone:
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
	/*
	 * Some revisions of the aic7880 have a problem where, if the
	 * data fifo is full, but the PCI input latch is not empty, 
	 * HDMAEN cannot be cleared.  The fix used here is to attempt
	 * to drain the data fifo until there is space for the input
	 * latch to drain and HDMAEN de-asserts.
	 */
	if ((ahc->features & AHC_ULTRA2) == 0) {
		mov	NONE, DFDAT;
	}
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;
return:
	ret;

/*
 * Assert that if we've been reselected, then we've seen an IDENTIFY
 * message.
 */
assert:
	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz return;	/* seen IDENTIFY? */

	mvi	INTSTAT,NO_IDENT 	ret;	/* no - tell the kernel */

/*
 * Locate a disconnected SCB either by SAVED_TCL (ARG_1 is SCB_LIST_NULL)
 * or by the SCBID ARG_1.  The search begins at the SCB index passed in
 * via SINDEX which is an SCB that must be on the disconnected list.  If
 * the SCB cannot be found, SINDEX will be SCB_LIST_NULL, otherwise, SCBPTR
 * is set to the proper SCB.
d1980 2
d1983 5
a1987 7
	mov	SCBPTR,SINDEX;			/* Initialize SCBPTR */
	cmp	ARG_1, SCB_LIST_NULL	jne findSCB_by_SCBID;
	mov	A, SAVED_TCL;
	mvi	SCB_TCL	jmp findSCB_loop;	/* &SCB_TCL -> SINDEX */
findSCB_by_SCBID:
	mov	A, ARG_1;			/* Tag passed in ARG_1 */
	mvi	SCB_TAG	jmp findSCB_loop;	/* &SCB_TAG -> SINDEX */
d1989 1
a1990 1
	cmp	SCB_NEXT, SCB_LIST_NULL je notFound;
a1991 1
	dec	SINDEX;		/* Last comparison moved us too far */
d1993 1
a1993 23
	cmp	SINDIR, A	jne findSCB_next;
	mov	SINDEX, SCBPTR 	ret;
notFound:
	mvi	SINDEX, SCB_LIST_NULL	ret;

/*
 * Retrieve an SCB by SCBID first searching the disconnected list falling
 * back to DMA'ing the SCB down from the host.  This routine assumes that
 * ARG_1 is the SCBID of interrest and that SINDEX is the position in the
 * disconnected list to start the search from.  If SINDEX is SCB_LIST_NULL,
 * we go directly to the host for the SCB.
 */
retrieveSCB:
	test	SEQ_FLAGS, SCBPTR_VALID	jz retrieve_from_host;
	mov	SCBPTR	call findSCB;	/* Continue the search */
	cmp	SINDEX, SCB_LIST_NULL	je retrieve_from_host;

/*
 * This routine expects SINDEX to contain the index of the SCB to be
 * removed, SCBPTR to be pointing to that SCB, and ARG_2 to be the
 * SCBID of the SCB just previous to this one in the list or SCB_LIST_NULL
 * if it is at the head.
 */
a1994 1
/* Remove this SCB from the disconnection list */
d1997 1
d2003 7
a2009 7

retrieve_from_host:
/*
 * We didn't find it.  Pull an SCB and DMA down the one we want.
 * We should never get here in the non-paging case.
 */
	mov	ALLZEROS	call	get_free_or_disc_scb;
a2010 1
	/* Jump instead of call as we want to return anyway */
d2012 1
a2012 44

/*
 * Determine whether a target is using tagged or non-tagged transactions
 * by first looking for a matching transaction based on the TCL and if
 * that fails, looking up this device in the host's untagged SCB array.
 * The TCL to search for is assumed to be in SAVED_TCL.  The value is
 * returned in ARG_1 (SCB_LIST_NULL for tagged, SCBID for non-tagged).
 * The SCBPTR_VALID bit is set in SEQ_FLAGS if we found the information
 * in an SCB instead of having to go to the host.
 */
get_untagged_SCBID:
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je get_SCBID_from_host;
	mvi	ARG_1, SCB_LIST_NULL;
	mov	DISCONNECTED_SCBH call findSCB;
	cmp	SINDEX, SCB_LIST_NULL	je get_SCBID_from_host;
	or	SEQ_FLAGS, SCBPTR_VALID;/* Was in disconnected list */
	test	SCB_CONTROL, TAG_ENB	jnz . + 2;
	mov	ARG_1, SCB_TAG	ret;
	mvi	ARG_1, SCB_LIST_NULL ret;

/*
 * Fetch a byte from host memory given an index of (A + (256 * SINDEX))
 * and a base address of SCBID_ADDR.  The byte is returned in RETURN_2.
 */
fetch_byte:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		mvi	CCSGCTL, CCSGRESET;
		bmov	RETURN_2, CCSGRAM, 1 ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
		mvi	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;
		call	dma_finish;
		mov	RETURN_2, DFDAT ret;
	}
d2016 1
a2016 1
 * index of (A + (256 * SINDEX)) and a base address of SCBID_ADDR.
d2022 1
a2022 1
		mvi	SCBID_ADDR call	set_1byte_addr;
d2027 2
a2028 4
		mvi	SCBID_ADDR call	set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
a2043 5
get_SCBID_from_host:
	mov	A, SAVED_TCL;
	mvi	UNTAGGEDSCB_OFFSET call fetch_byte;
	mov	RETURN_1,  RETURN_2 ret;

d2045 1
a2045 1
	mvi	INTSTAT, PERR_DETECTED;
d2055 3
a2057 1
	and	SCSISIGO, PHASE_MASK, SCSISIGI;
d2061 6
d2072 2
d2087 1
a2087 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d2113 1
a2113 1
 * Setup addr assuming that A + (ARG_1 * 256) is an
d2138 5
a2142 1
		mvi	CCHCNT, SCB_64BYTE_SIZE;
d2147 2
a2148 2
		mvi	CCHCNT, SCB_32BYTE_SIZE;
		if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
d2150 1
a2150 1
			bmov	CCSCBRAM, SCB_CONTROL, SCB_32BYTE_SIZE;
d2153 6
d2170 1
a2170 3
		mvi	HCNT[0], SCB_32BYTE_SIZE;
		clr	HCNT[1];
		clr	HCNT[2];
d2175 2
a2176 2
		mvi	SINDEX, SCB_CONTROL;
		add	A, SCB_32BYTE_SIZE, SINDEX;
d2178 1
a2178 7
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
d2181 1
d2183 49
a2231 1
		call	dma_finish;
d2233 5
a2237 5
		test	DMAPARAMS, DIRECTION	jz	return;
		mvi	SCB_CONTROL  call dfdat_in_7;
		call	dfdat_in_7_continued;
		call	dfdat_in_7_continued;
		jmp	dfdat_in_7_continued;
a2238 2
		mov     DINDEX,SINDEX;
dfdat_in_7_continued:
d2244 1
d2249 12
d2268 1
d2274 10
d2286 1
d2290 1
d2295 7
d2304 1
d2308 1
d2312 2
a2313 1
dma_up_scb:
d2315 2
a2316 3
	mov	SCB_TAG		call dma_scb;
unlink_disc_scb:
	mov	DISCONNECTED_SCBH, SCB_NEXT ret;
d2320 1
a2320 1
}
d2328 1
d2331 7
@


1.8.10.1
log
@sync to -current
@
text
@a0 1
/* $OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d17 1
a17 1
 * GNU Public License ("GPL").
d31 1
a31 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $
a33 3
VERSION = "$Id$"
PATCH_ARG_LIST = "struct ahc_softc *ahc"

d36 3
d58 12
a69 7
bus_free_sel:
        /*
         * Turn off the selection hardware.  We need to reset the
         * selection request in order to perform a new selection.
         */
        and     SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
        and     SIMODE1, ~ENBUSFREE;
d73 2
a74 7
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;
        }
        test    SCSISEQ, ENSELO jnz poll_for_selection;
        if ((ahc->features & AHC_TWIN) != 0) {
                xor     SBLKCTL,SELBUSB;        /* Toggle to the other bus */
                test    SCSISEQ, ENSELO         jnz poll_for_selection;
a75 1
        cmp     WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d77 5
d83 6
d90 5
a94 2
        }
        test    SSTAT0, SELDO|SELDI     jnz selection;
a96 1
BEGIN_CRITICAL;
d99 2
d102 1
a102 1
                mov     A, QINPOS;
d104 2
a106 1
        mov     ARG_1, NEXT_QUEUED_SCB;
d108 6
a113 5
        /*
         * We have at least one queued SCB now and we don't have any 
         * SCBs in the list of SCBs awaiting selection.  Allocate a
         * card SCB for the host's SCB and get to work on it.
         */
d116 7
a122 1
        } else {
d124 1
a124 1
                mov     SCBPTR, ARG_1;
a125 2
        or      SEQ_FLAGS2, SCB_DMA;
END_CRITICAL;
d127 3
a129 3
        /*
         * DMA the SCB from host ram into the current SCB location.
         */
d131 14
a144 13
        mov     ARG_1   call dma_scb;
        /*
         * Check one last time to see if this SCB was canceled
         * before we completed the DMA operation.  If it was,
         * the QINFIFO next pointer will not match our saved
         * value.
         */
        mov     A, ARG_1;
BEGIN_CRITICAL;
        cmp     NEXT_QUEUED_SCB, A jne abort_qinscb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                cmp     SCB_TAG, A je . + 2;
                mvi     SCB_MISMATCH call set_seqint;
d146 7
a152 1
        mov     NEXT_QUEUED_SCB, SCB_NEXT;
a154 7
        if ((ahc->features & AHC_QUEUE_REGS) != 0) {
                mov     NONE, SNSCB_QOFF;
        } else {
                inc     QINPOS;
        }
        and     SEQ_FLAGS2, ~SCB_DMA;
END_CRITICAL;
d157 1
a157 1
         * Start the first entry on the waiting SCB list.
d161 32
d194 21
a214 8
poll_for_selection:
        /*
         * Twin channel devices cannot handle things like SELTO
         * interrupts on the "background" channel.  So, while
         * selecting, keep polling the current channel until
         * either a selection or reselection occurs.
         */
        test    SSTAT0, SELDO|SELDI     jz poll_for_selection;
a216 15
        /*
         * We aren't expecting a bus free, so interrupt
         * the kernel driver if it happens.
         */
        mvi     CLRSINT1,CLRBUSFREE;
        if ((ahc->features & AHC_DT) == 0) {
                or      SIMODE1, ENBUSFREE;
        }

        /*
         * Guard against a bus free after (re)selection
         * but prior to enabling the busfree interrupt.  SELDI
         * and SELDO will be cleared in that case.
         */
        test    SSTAT0, SELDI|SELDO     jz bus_free_sel;
d218 1
d220 2
a221 2
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                if ((ahc->flags & AHC_INITIATORROLE) != 0) {
a223 1
                mvi     CLRSINT0, CLRSELDI;
d231 1
d242 1
a242 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d246 1
a246 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d251 7
a257 1
                and     SAVED_SCSIID, SELID_MASK, SELID;
d259 8
a266 14
                if ((ahc->features & AHC_MULTI_TID) != 0) {
                        and     A, OID, TARGIDIN;
                } else if ((ahc->features & AHC_ULTRA2) != 0) {
                        and     A, OID, SCSIID_ULTRA2;
                } else {
                        and     A, OID, SCSIID;
                }
                or      SAVED_SCSIID, A;
                if ((ahc->features & AHC_TWIN) != 0) {
                        test    SBLKCTL, SELBUSB jz . + 2;
                        or      SAVED_SCSIID, TWIN_CHNLB;
                }
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        mov     CCSCBRAM, SAVED_SCSIID;
d268 11
a278 2
                        mov     DFDAT, SAVED_SCSIID;
                }
a282 2
                 * XXX SCSI-1 may require us to assume lun 0 if
                 * ATN is false.
d297 1
a346 4
                or      SEQ_FLAGS, TARGET_CMD_IS_TAGGED;
                test    SCSISIGI, ATNI  jz . + 2;
                /* Initiator still wants to give us messages */
                call    target_inb;
d354 2
a355 1
                mvi     HOST_MSG_LOOP call set_seqint;
d365 1
a365 1
                        mov     A, KERNEL_TQINPOS;
d369 1
a369 1
                test    SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
d382 1
a382 1
                test    SCSISIGI, ATNI  jnz target_mesgout_pending;
d384 18
a401 1
        }
d403 1
a403 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d409 15
a423 96
        /* XXX test for and handle ONE BIT condition */
	test    SELID, ONEBIT jnz await_busfree;

	or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	and     SAVED_SCSIID, SELID_MASK, SELID;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                and     A, OID, SCSIID_ULTRA2;
        } else {
                and     A, OID, SCSIID;
        }
        or      SAVED_SCSIID, A;
        if ((ahc->features & AHC_TWIN) != 0) {
                test    SBLKCTL, SELBUSB        jz . + 2;
                or      SAVED_SCSIID, TWIN_CHNLB;
        }
        mvi     CLRSINT0, CLRSELDI;
        jmp     ITloop;
}

abort_qinscb:
        call    add_scb_to_free_list;
        jmp     poll_for_work_loop;

start_selection:
        /*
         * If bus reset interrupts have been disabled (from a previous
         * reset), re-enable them now.  Resets are only of interest
         * when we have outstanding transactions, so we can safely
         * defer re-enabling the interrupt until, as an initiator,
         * we start sending out transactions again.
         */
        test    SIMODE1, ENSCSIRST      jnz . + 3;
        mvi     CLRSINT1, CLRSCSIRSTI;
        or      SIMODE1, ENSCSIRST;
        if ((ahc->features & AHC_TWIN) != 0) {
                and     SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
                test    SCB_SCSIID, TWIN_CHNLB jz . + 2;
                or      SINDEX, SELBUSB;
                mov     SBLKCTL,SINDEX;         /* select channel */
        }
initialize_scsiid:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     SCSIID_ULTRA2, SCB_SCSIID;
        } else if ((ahc->features & AHC_TWIN) != 0) {
                and     SCSIID, TWIN_TID|OID, SCB_SCSIID;
        } else {
                mov     SCSIID, SCB_SCSIID;
        }
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                mov     SINDEX, SCSISEQ_TEMPLATE;
                test    SCB_CONTROL, TARGET_SCB jz . + 2;
                or      SINDEX, TEMODE;
                mov     SCSISEQ, SINDEX ret;
        } else {
                mov     SCSISEQ, SCSISEQ_TEMPLATE ret;
        }

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
set_transfer_settings:
        if ((ahc->features & AHC_ULTRA) != 0) {
                test    SCB_CONTROL, ULTRAENB jz . + 2;
                or      SXFRCTL0, FAST20;
        } 
        /*
         * Initialize SCSIRATE with the appropriate value for this target.
         */
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    SCSIRATE, SCB_SCSIRATE, 2 ret;
        } else {
                mov     SCSIRATE, SCB_SCSIRATE ret;
        }

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
        /*
         * Drive REQ on the bus by enabling SCSI PIO.
         */
        or      SXFRCTL0, SPIOEN;
        /* Wait for the byte */
        test    SSTAT0, SPIORDY jz .;
        /* Prevent our read from triggering another REQ */
        and     SXFRCTL0, ~SPIOEN;
        /* Save latched contents */
        mov     DINDEX, SCSIDATL ret;
d435 1
d439 2
a440 4
        mov     SAVED_SCSIID, SCB_SCSIID;
        mov     SAVED_LUN, SCB_LUN;
        call    initialize_channel;
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d449 1
d454 2
a455 1
                or      SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d463 2
a464 1
                mov     SCB_TARGET_INFO[SCB_INITIATOR_TAG] call target_outb;
d470 1
a470 1
                mov     SEQ_FLAGS, SCB_TARGET_INFO[SCB_TARGET_PHASES];
d472 1
a472 3
                test    SCB_CONTROL, MK_MESSAGE jz target_ITloop;
                mvi     P_MESGIN|BSYO call change_phase;
                jmp     host_target_message_loop;
a487 3
                mov     RETURN_1, ALLZEROS;
                call    complete_target_cmd;
                cmp     RETURN_1, CONT_MSG_LOOP jne .;
d491 3
a499 1
target_mesgout_continue:
a500 1
target_mesgout_pending:
d502 1
d512 1
a512 1
                /* Wait for preceding I/O session to complete. */
a514 4
                and     SIMODE1, ~ENBUSFREE;
                if ((ahc->features & AHC_ULTRA2) != 0) {
                        clr     SCSIBUSL;
                }
d540 1
a540 1
                add     SINDEX, CMDSIZE_TABLE, A;
a543 1
                or      SXFRCTL0, SPIOEN;
d545 1
d563 10
a572 9
                 * Data phases on the bus are from the
                 * perspective of the initiator.  The dma
                 * code looks at LASTPHASE to determine the
                 * data direction of the DMA.  Toggle it for
                 * target transfers.
		 */
                xor     LASTPHASE, IOI, SCB_TARGET_INFO[SCB_TARGET_DATA_DIR];
                or      SCB_TARGET_INFO[SCB_TARGET_DATA_DIR], BSYO
                        call change_phase;
d578 1
a578 1
                mov     SCB_TARGET_INFO[SCB_TARGET_STATUS] call target_outb;
d601 3
a603 1
                        mvi     28      call set_hcnt;
d611 1
a611 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d613 9
a634 1
mesgin_phasemis:
d646 1
a646 1
        mvi     BAD_PHASE call set_seqint;
a651 3
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;       /* Prevent bit leakage durint SELTO */
        }
d655 1
a655 1
        mvi     MISSED_BUSFREE call set_seqint;
a664 1
        or      SXFRCTL0, CLRSTCNT|CLRCHN;
d675 1
a675 3
                if ((ahc->features & AHC_ULTRA) != 0) {
                        and     SXFRCTL0, ~(FAST20);
                }
d681 5
a685 54
sg_advance:
        clr     A;                      /* add sizeof(struct scatter) */
        add     SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
        adc     SCB_RESIDUAL_SGPTR[1],A;
        adc     SCB_RESIDUAL_SGPTR[2],A;
        adc     SCB_RESIDUAL_SGPTR[3],A ret;

if ((ahc->features & AHC_CMD_CHAN) != 0) {
disable_ccsgen:
        test    CCSGCTL, CCSGEN jz return;
        test    CCSGCTL, CCSGDONE jz .;
disable_ccsgen_fetch_done:
        clr     CCSGCTL;
        test    CCSGCTL, CCSGEN jnz .;
        ret;
idle_loop:
        /*
         * Do we need any more segments for this transfer?
         */
        test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

        /* Did we just finish fetching segs? */
        cmp     CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

        /* Are we actively fetching segments? */
        test    CCSGCTL, CCSGEN jnz return;

        /*
         * Do we have any prefetch left???
         */
        cmp     CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

        /*
         * Need to fetch segments, but we can only do that
         * if the command channel is completely idle.  Make
         * sure we don't have an SCB prefetch going on.
         */
        test    CCSCBCTL, CCSCBEN jnz return;

        /*
         * We fetch a "cacheline aligned" and sized amount of data
         * so we don't end up referencing a non-existant page.
         * Cacheline aligned is in quotes because the kernel will
         * set the prefetch amount to a reasonable level if the
         * cacheline size is unknown.
         */
        mvi     CCHCNT, SG_PREFETCH_CNT;
        and     CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
        bmov    CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
        mvi     CCSGCTL, CCSGEN|CCSGRESET ret;
idle_sgfetch_complete:
        call    disable_ccsgen_fetch_done;
        and     CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
idle_sg_avail:
d687 15
a701 55
                /* Does the hardware have space for another SG entry? */
                test    DFSTATUS, PRELOAD_AVAIL jz return;
                bmov    HADDR, CCSGRAM, 7;
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;
                bmov    SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
                }
                call    sg_advance;
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                /* Load the segment */
                or      DFCNTRL, PRELOADEN;
        }
        ret;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Calculate the trailing portion of this S/G segment that cannot
 * be transferred using memory write and invalidate PCI transactions.  
 * XXX Can we optimize this for PCI writes only???
 */
calc_mwi_residual:
        /*
         * If the ending address is on a cacheline boundary,
         * there is no need for an extra segment.
         */
        mov     A, HCNT[0];
        add     A, A, HADDR[0];
        and     A, CACHESIZE_MASK;
        test    A, 0xFF jz return;

        /*
         * If the transfer is less than a cachline,
         * there is no need for an extra segment.
         */
        test    HCNT[1], 0xFF   jnz calc_mwi_residual_final;
        test    HCNT[2], 0xFF   jnz calc_mwi_residual_final;
        add     NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
        jnc     return;

calc_mwi_residual_final:
        mov     MWI_RESIDUAL, A;
        not     A;
        inc     A;
        add     HCNT[0], A;
        adc     HCNT[1], -1;
        adc     HCNT[2], -1 ret;
}
a703 3
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_data_okay;
        mvi     NO_IDENT jmp set_seqint;
p_data_okay:
d711 4
d716 1
a716 2
                /* We don't have any valid S/G elements */
                mvi     CCSGADDR, SG_PREFETCH_CNT;
d718 1
a718 10
        test    SEQ_FLAGS, DPHASE       jz data_phase_initialize;

        /*
         * If we re-enter the data phase after going through another
         * phase, our transfer location has almost certainly been
         * corrupted by the interveining, non-data, transfers.  Ask
         * the host driver to fix us up based on the transfer residual.
         */
        mvi     PDATA_REINIT    call set_seqint;
        jmp     data_phase_loop;
d720 1
a720 2
data_phase_initialize:
        /* We have seen a data phase for the first time */
d725 3
a727 4
         * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
         * flag in the highest byte of the data count.  We cannot
         * modify the saved values in the SCB until we see a save
         * data pointers message.
a728 4
        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                /* The lowest address byte must be loaded last. */
                mov     SCB_DATACNT[3] call set_hhaddr;
        }
a730 1
                bmov    SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
a733 2
                mvi     DINDEX, SCB_RESIDUAL_DATACNT + 3;
                mvi     SCB_DATACNT + 3 call bcopy_5;
d735 1
a735 5
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
                call    calc_mwi_residual;
        }
        and     SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
        and     DATA_COUNT_ODD, 0x1, HCNT[0];
d742 8
a749 1
                }
d753 8
a760 9
        /* Guard against overruns */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;

        /*
         * Turn on `Bit Bucket' mode, wait until the target takes
         * us to another phase, and then notify the host.
         */
        and     DMAPARAMS, DIRECTION;
        mov     DFCNTRL, DMAPARAMS;
d762 5
a766 2
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT1,PHASEMIS jz .;
d768 3
a770 1
                test    SCSIPHASE, DATA_PHASE_MASK jnz .;
a771 4
        and     SXFRCTL1, ~BITBUCKET;
        mvi     DATA_OVERRUN call set_seqint;
        jmp     ITloop;

d773 2
d776 5
a780 194
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                mov     DFCNTRL, DMAPARAMS;
ultra2_dma_loop:
                call    idle_loop;
                /*
                 * The transfer is complete if either the last segment
                 * completes or the target changes phase.
                 */
                test    SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                                 /*
                                  * As a target, we control the phases,
                                  * so ignore PHASEMIS.
                                  */
                                test    SSTAT0, TARGET jnz ultra2_dma_loop;
                        }
                        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                                test    SSTAT1,PHASEMIS jz ultra2_dma_loop;
                        }
                } else {
                        test    DFCNTRL, SCSIEN jnz ultra2_dma_loop;
                }

ultra2_dmafinish:
                /*
                 * The transfer has terminated either due to a phase
                 * change, and/or the completion of the last segment.
                 * We have two goals here.  Do as much other work
                 * as possible while the data fifo drains on a read
                 * and respond as quickly as possible to the standard
                 * messages (save data pointers/disconnect and command
                 * complete) that usually follow a data phase.
                 */
                if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                        /*
                         * On chips with broken auto-flush, start
                         * the flushing process now.  We'll poke
                         * the chip from time to time to keep the
                         * flush process going as we complete the
                         * data phase.
                         */
                        or      DFCNTRL, FIFOFLUSH;
                }
                /*
                 * We assume that, even though data may still be
                 * transferring to the host, that the SCSI side of
                 * the DMA engine is now in a static state.  This
                 * allows us to update our notion of where we are
                 * in this transfer.
                 *
                 * If, by chance, we stopped before being able
                 * to fetch additional segments for this transfer,
                 * yet the last S/G was completely exhausted,
                 * call our idle loop until it is able to load
                 * another segment.  This will allow us to immediately
                 * pickup on the next segment on the next data phase.
                 *
                 * If we happened to stop on the last segment, then
                 * our residual information is still correct from
                 * the idle loop and there is no need to perform
                 * any fixups.
                 */
ultra2_ensure_sg:
                test    SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
                /* Record if we've consumed all S/G entries */
                test    SSTAT2, SHVALID jnz residuals_correct;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     residuals_correct;

ultra2_shvalid:
                test    SSTAT2, SHVALID jnz sgptr_fixup;
                call    idle_loop;
                jmp     ultra2_ensure_sg;

sgptr_fixup:
                /*
                 * Fixup the residual next S/G pointer.  The S/G preload
                 * feature of the chip allows us to load two elements
                 * in addition to the currently active element.  We
                 * store the bottom byte of the next S/G pointer in
                 * the SG_CACEPTR register so we can restore the
                 * correct value when the DMA completes.  If the next
                 * sg ptr value has advanced to the point where higher
                 * bytes in the address have been affected, fix them
                 * too.
                 */
                test    SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
                test    SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
                add     SCB_RESIDUAL_SGPTR[1], -1;
                adc     SCB_RESIDUAL_SGPTR[2], -1; 
                adc     SCB_RESIDUAL_SGPTR[3], -1;
sgptr_fixup_done:
                and     SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
                clr     DATA_COUNT_ODD;
                test    SG_CACHE_SHADOW, ODD_SEG jz . + 2;
                or      DATA_COUNT_ODD, 0x1;
                clr     SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
residuals_correct:
                /*
                 * Go ahead and shut down the DMA engine now.
                 * In the future, we'll want to handle end of
                 * transfer messages prior to doing this, but this
                 * requires similar restructuring for pre-ULTRA2
                 * controllers.
                 */
                test    DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
ultra2_fifoflush:
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                                /*
                                 * On Rev A of the aic7890, the autoflush
                                 * feature doesn't function correctly.
                                 * Perform an explicit manual flush.  During
                                 * a manual flush, the FIFOEMP bit becomes
                                 * true every time the PCI FIFO empties
                                 * regardless of the state of the SCSI FIFO.
                                 * It can take up to 4 clock cycles for the
                                 * SCSI FIFO to get data into the PCI FIFO
                                 * and for FIFOEMP to de-assert.  Here we
                                 * guard against this condition by making
                                 * sure the FIFOEMP bit stays on for 5 full
                                 * clock cycles.
                                 */
                                or      DFCNTRL, FIFOFLUSH;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                        }
                        test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                } else {
                        /*
                         * We enable the auto-ack feature on DT capable
                         * controllers.  This means that the controller may
                         * have already transferred some overrun bytes into
                         * the data FIFO and acked them on the bus.  The only
                         * way to detect this situation is to wait for
                         * LAST_SEG_DONE to come true on a completed transfer
                         * and then test to see if the data FIFO is non-empty.
                         */
                        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
                        test    SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
                        test    DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
                        /* Overrun */
                        jmp     data_phase_loop;
                        test    DFSTATUS, FIFOEMP jz .;
                }
ultra2_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz ultra2_fifoempty;
ultra2_dmahalt:
                and     DFCNTRL, ~(SCSIEN|HDMAEN);
                test    DFCNTRL, SCSIEN|HDMAEN jnz .;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        /*
                         * Keep HHADDR cleared for future, 32bit addressed
                         * only, DMA operations.
                         *
                         * Due to bayonette style S/G handling, our residual
                         * data must be "fixed up" once the transfer is halted.
                         * Here we fixup the HSHADDR stored in the high byte
                         * of the residual data cnt.  By postponing the fixup,
                         * we can batch the clearing of HADDR with the fixup.
                         * If we halted on the last segment, the residual is
                         * already correct.   If we are not on the last
                         * segment, copy the high address directly from HSHADDR.
                         * We don't need to worry about maintaining the
                         * SG_LAST_SEG flag as it will always be false in the
                         * case where an update is required.
                         */
                        or      DSCOMMAND1, HADDLDSEL0;
                        test    SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
                        mov     SCB_RESIDUAL_DATACNT[3], SHADDR;
                        clr     HADDR;
                        and     DSCOMMAND1, ~HADDLDSEL0;
                }
	} else {
                /* If we are the last SG block, tell the hardware. */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jz dma_last_sg;
                        if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
                                test    DMAPARAMS, DIRECTION jz dma_mid_sg;
                        }
a781 1
dma_last_sg:
d783 4
a786 2
dma_mid_sg:
                /* Start DMA data transfer. */
d788 22
a809 22
dma_loop:
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        call    idle_loop;
                }
                test    SSTAT0,DMADONE  jnz dma_dmadone;
                test    SSTAT1,PHASEMIS jz dma_loop;    /* ie. underrun */
dma_phasemis:
                /*
                 * We will be "done" DMAing when the transfer count goes to
                 * zero, or the target changes the phase (in light of this,
                 * it makes sense that the DMA circuitry doesn't ACK when
                 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
                 * the data FIFO should be flushed auto-magically on STCNT=0
                 * or a phase change, so just wait for FIFO empty status.
                 */
dma_checkfifo:
                test    DFCNTRL,DIRECTION       jnz dma_fifoempty;
dma_fifoflush:
                test    DFSTATUS,FIFOEMP        jz dma_fifoflush;
dma_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz dma_fifoempty;
d811 8
a818 52
                /*
                 * Now shut off the DMA and make sure that the DMA
                 * hardware has actually stopped.  Touching the DMA
                 * counters, etc. while a DMA is active will result
                 * in an ILLSADDR exception.
                 */
dma_dmadone:
                and     DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
                /*
                 * Some revisions of the aic78XX have a problem where, if the
                 * data fifo is full, but the PCI input latch is not empty, 
                 * HDMAEN cannot be cleared.  The fix used here is to drain
                 * the prefetched but unused data from the data fifo until
                 * there is space for the input latch to drain.
                 */
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        mov     NONE, DFDAT;
                }
                test    DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

                /* See if we have completed this last segment */
                test    STCNT[0], 0xff  jnz data_phase_finish;
                test    STCNT[1], 0xff  jnz data_phase_finish;
                test    STCNT[2], 0xff  jnz data_phase_finish;

                /*
                 * Advance the scatter-gather pointers if needed 
                 */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jz no_mwi_resid;
                        /*
                         * Reload HADDR from SHADDR and setup the
                         * count to be the size of our residual.
                         */
                        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                                bmov    HADDR, SHADDR, 4;
                                mov     HCNT, MWI_RESIDUAL;
                                bmov    HCNT[1], ALLZEROS, 2;
                        } else {
                                mvi     DINDEX, HADDR;
                                mvi     SHADDR call bcopy_4;
                                mov     MWI_RESIDUAL call set_hcnt;
                        }
                        clr     MWI_RESIDUAL;
                        jmp     sg_load_done;
no_mwi_resid:
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     data_phase_finish;
d820 6
d827 37
a863 52
                 * Load the next SG element's data address and length
                 * into the DMA engine.  If we don't have hardware
                 * to perform a prefetch, we'll have to fetch the
                 * segment from host memory first.
		 */
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        /* Wait for the idle loop to complete */
                        test    CCSGCTL, CCSGEN jz . + 3;
                        call    idle_loop;
                        test    CCSGCTL, CCSGEN jnz . - 1;
                        bmov    HADDR, CCSGRAM, 7;
                        /*
                         * Workaround for flaky external SCB RAM
                         * on certain aic7895 setups.  It seems
                         * unable to handle direct transfers from
                         * S/G ram to certain SCB locations.
                         */
                        mov     SINDEX, CCSGRAM;
                        mov     SCB_RESIDUAL_DATACNT[3], SINDEX;
                } else {
                        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                                mov     ALLZEROS call set_hhaddr;
                        }
                        mvi     DINDEX, HADDR;
                        mvi     SCB_RESIDUAL_SGPTR      call bcopy_4;

                        mvi     SG_SIZEOF       call set_hcnt;

                        or      DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

                        call    dma_finish;

                        mvi     DINDEX, HADDR;
                        call    dfdat_in_7;
                        mov     SCB_RESIDUAL_DATACNT[3], DFDAT;
                }

                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

                        /*
                         * The lowest address byte must be loaded
                         * last as it triggers the computation of
                         * some items in the PCI block.  The ULTRA2
                         * chips do this on PRELOAD.
                         */
                        mov     HADDR, HADDR;
                }
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        call calc_mwi_residual;
                }
d865 3
a867 2
                /* Point to the new next sg in memory */
                call    sg_advance;
d869 2
a870 1
sg_load_done:
a875 7
                /* Track odd'ness */
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;

                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jnz data_phase_loop;
                }
d877 18
d896 16
a911 78
        /*
         * If the target has left us in data phase, loop through
         * the dma code again.  In the case of ULTRA2 adapters,
         * we should only loop if there is a data overrun.  For
         * all other adapters, we'll loop after each S/G element
         * is loaded as well as if there is an overrun.
         */
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                test    SSTAT0, TARGET jnz data_phase_done;
        }
        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                test    SSTAT1, REQINIT jz .;
                if ((ahc->features & AHC_DT) == 0) {
                        test    SSTAT1,PHASEMIS jz data_phase_loop;
                } else {
                        test    SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
                }
        }

data_phase_done:
        /*
         * After a DMA finishes, save the SG and STCNT residuals back into
         * the SCB.  We use STCNT instead of HCNT, since it's a reflection
         * of how many bytes were transferred on the SCSI (as opposed to the
         * host) bus.
         */
        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                /* Kill off any pending prefetch */
                call    disable_ccsgen;
	}

        if ((ahc->features & AHC_ULTRA2) == 0) {
                /*
                 * Clear the high address byte so that all other DMA
                 * operations, which use 32bit addressing, can assume
                 * HHADDR is 0.
                 */
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     ALLZEROS call set_hhaddr;
                }
	}

        /*
         * Update our residual information before the information is
         * lost by some other type of SCSI I/O (e.g. PIO).  If we have
         * transferred all data, no update is needed.
         *
         */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
          && ahc->pci_cachesize != 0) {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        test    MWI_RESIDUAL, 0xFF jz bmov_resid;
                }
                mov     A, MWI_RESIDUAL;
                add     SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
                clr     A;
                adc     SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
                adc     SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
                clr     MWI_RESIDUAL;
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        jmp     . + 2;
bmov_resid:
                        bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
                }
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
                mov     SCB_RESIDUAL_DATACNT[0], STCNT[0];
                mov     SCB_RESIDUAL_DATACNT[1], STCNT[1];
                mov     SCB_RESIDUAL_DATACNT[2], STCNT[2];
	}
residual_update_done:
        /*
         * Since we've been through a data phase, the SCB_RESID* fields
         * are now initialized.  Clear the full residual flag.
         */
        and     SCB_SGPTR[0], ~SG_FULL_RESID;
a913 2
                /* Clear the channel in case we return to data phase later */
                or      SXFRCTL0, CLRSTCNT|CLRCHN;
d917 1
a917 1
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
a926 2
        } else {
                jmp     ITloop;
d928 1
d930 48
a977 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d982 19
a1000 56
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_command_okay;
        mvi     NO_IDENT jmp set_seqint;
p_command_okay:

        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HCNT[0], SCB_CDB_LEN,  1;
                bmov    HCNT[1], ALLZEROS, 2;
                mvi     SG_CACHE_PRE, LAST_SEG;
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    STCNT[0], SCB_CDB_LEN, 1;
                bmov    STCNT[1], ALLZEROS, 2;
        } else {
                mov     STCNT[0], SCB_CDB_LEN;
                clr     STCNT[1];
                clr     STCNT[2];
        }
        add     NONE, -13, SCB_CDB_LEN;
        mvi     SCB_CDB_STORE jnc p_command_embedded;
p_command_from_host:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HADDR[0], SCB_CDB_PTR, 4;
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
        } else {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        bmov    HADDR[0], SCB_CDB_PTR, 4;
                        bmov    HCNT, STCNT, 3;
                } else {
                        mvi     DINDEX, HADDR;
                        mvi     SCB_CDB_PTR call bcopy_4;
                        mov     SCB_CDB_LEN call set_hcnt;
                }
                mvi     DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
        }
        jmp     p_command_loop;
p_command_embedded:
        /*
         * The data fifo seems to require 4 byte aligned
         * transfers from the sequencer.  Force this to
         * be the case by clearing HADDR[0] even though
	 * we aren't going to touch host memory.
         */
        clr     HADDR[0];
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
                bmov    DFDAT, SCB_CDB_STORE, 12; 
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        /*
                         * On the 7895 the data FIFO will
                         * get corrupted if you try to dump
                         * data from external SCB memory into
                         * the FIFO while it is enabled.  So,
                         * fill the fifo and then enable SCSI
                         * transfers.
                         */
                        mvi     DFCNTRL, (DIRECTION|FIFORESET);
d1004 27
a1030 24
                bmov    DFDAT, SCB_CDB_STORE, 12; 
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
                } else {
                        or      DFCNTRL, FIFOFLUSH;
		}
	} else {
                mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
                call    copy_to_fifo_6;
                call    copy_to_fifo_6;
                or      DFCNTRL, FIFOFLUSH;
	}
p_command_loop:
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT0, SDONE jnz . + 2;
                test    SSTAT1, PHASEMIS jz p_command_loop;
                /*
                 * Wait for our ACK to go-away on it's own
                 * instead of being killed by SCSIEN getting cleared.
                 */
                test    SCSISIGI, ACKI jnz .;
        } else {
                test    DFCNTRL, SCSIEN jnz p_command_loop;
        }
a1032 4
        if ((ahc->features & AHC_ULTRA2) != 0) {
                /* Drop any residual from the S/G Preload queue */
                or      SXFRCTL0, CLRSTCNT;
        }
d1040 3
a1042 4
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_status_okay;
        mvi     NO_IDENT jmp set_seqint;
p_status_okay:
        mov     SCB_SCSI_STATUS, SCSIDATL;
d1070 1
a1070 6
        /* Turn on ATN for the retry */
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1075 25
d1101 4
a1104 3
        or      SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
        test    SCB_CONTROL, DISCENB jnz . + 2;
        and     SINDEX, ~DISCENB;
a1153 1
        cmp     A,MSG_IGN_WIDE_RESIDUE  je mesgin_ign_wide_residue;
d1166 1
a1166 1
        mvi     HOST_MSG_LOOP call set_seqint;
a1170 14
mesgin_ign_wide_residue:
if ((ahc->features & AHC_WIDE) != 0) {
        test    SCSIRATE, WIDEXFER jz mesgin_reject;
        /* Pull the residue byte */
        mvi     ARG_1   call inb_next;
        cmp     ARG_1, 0x01 jne mesgin_reject;
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
        test    DATA_COUNT_ODD, 0x1     jz mesgin_done;
        mvi     IGN_WIDE_RES call set_seqint;
        jmp     mesgin_done;
}

mesgin_reject:
        mvi     MSG_MESSAGE_REJECT      call mk_mesg;
d1175 1
d1178 1
a1178 1
 * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
d1185 8
a1192 18
 * sense, it will fill the kernel SCB with a request sense command, requeue
 * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
 * RETURN_1 to SEND_SENSE.
 */

/*
 * If ATN is raised, we still want to give the target a message.
 * Perhaps there was a parity error on this last message byte.
 * Either way, the target should take us to message out phase
 * and then attempt to complete the command again.  We should use a
 * critical section here to guard against a timeout triggering
 * for this command and setting ATN while we are still processing
 * the completion.
        test    SCSISIGI, ATNI jnz mesgin_done;
 */

/*
 * See if we attempted to deliver a message but the target ingnored us.
a1193 2
        test    SCB_CONTROL, MK_MESSAGE jz . + 2;
        mvi     MKMSG_FAILED call set_seqint;
d1196 1
a1196 1
 * Check for residuals
d1198 2
a1199 5
        test    SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
        test    SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
check_status:
        test    SCB_SCSI_STATUS,0xff    jz complete;    /* Good Status? */
a1200 1
        or      SCB_SGPTR, SG_RESID_VALID;
d1203 4
a1206 2
        test    SCB_SCSI_STATUS, 0xff   jz complete;    /* Just a residual? */
        mvi     BAD_STATUS call set_seqint;             /* let driver know */
d1208 11
a1218 1
        call    add_scb_to_free_list;
d1220 1
d1222 8
d1250 1
a1250 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d1253 1
a1253 3
 * and await the bus going free.  If this is an untagged transaction
 * store the SCB id for it in our untagged target table for lookup on
 * a reselction.
a1255 11
        /*
         * If ATN is raised, we still want to give the target a message.
         * Perhaps there was a parity error on this last message byte
         * or we want to abort this command.  Either way, the target
         * should take us to message out phase and then attempt to
         * disconnect again.
         * XXX - Wait for more testing.
        test    SCSISIGI, ATNI jnz mesgin_done;
         */

        test    SCSISIGI, ATNI jnz mesgin_done;
d1257 1
a1257 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    add_scb_to_disc_list;
        }
        test    SCB_CONTROL, TAG_ENB jnz await_busfree;
        mov     ARG_1, SCB_TAG;
        mov     SAVED_LUN, SCB_LUN;
        mov     SCB_SCSIID      call set_busy_target;
a1265 3
 * Ack the message as soon as possible.  For chips without S/G pipelining,
 * we can only ack the message after SHADDR has been saved.  On these
 * chips, SHADDR increments with every bus transaction, even PIO.
d1268 1
a1268 6
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     NONE,SCSIDATL;          /*dummy read from latch to ACK*/
                test    SEQ_FLAGS, DPHASE       jz ITloop;
        } else {
                test    SEQ_FLAGS, DPHASE       jz mesgin_done;
        }
d1271 2
a1272 17
         * If we are asked to save our position at the end of the
         * transfer, just mark us at the end rather than perform a
         * full save.
         */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
        or      SCB_SGPTR, SG_LIST_NULL;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                jmp     ITloop;
        } else {
                jmp     mesgin_done;
        }

mesgin_sdptrs_full:

        /*
         * The SCB_SGPTR becomes the next one we'll download,
         * and the SCB_DATAPTR becomes the current SHADDR.
d1277 1
d1279 1
a1279 4
                if ((ahc->features & AHC_ULTRA2) == 0) {
                        mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                }
                bmov    SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1281 3
d1285 2
a1286 3
                mvi     SHADDR call bcopy_4;
                mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                mvi     SCB_RESIDUAL_DATACNT call bcopy_8;
d1288 1
a1288 1
        jmp     ITloop;
a1304 14
 * Index into our Busy Target table.  SINDEX and DINDEX are modified
 * upon return.  SCBPTR may be modified by this action.
 */
set_busy_target:
        shr     DINDEX, 4, SINDEX;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, SAVED_LUN;
                add     DINDEX, SCB_64_BTT;
        } else {
                add     DINDEX, BUSY_TARGETS;
        }
        mov     DINDIR, ARG_1 ret;

/*
d1310 4
a1313 34
        /*
         * Determine whether a target is using tagged or non-tagged
         * transactions by first looking at the transaction stored in
         * the busy target array.  If there is no untagged transaction
         * for this target or the transaction is for a different lun, then
         * this must be an untagged transaction.
         */
        shr     SINDEX, 4, SAVED_SCSIID;
        and     SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                add     SINDEX, SCB_64_BTT;
                mov     SCBPTR, SAVED_LUN;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -SCB_64_BTT, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(SCB_64_BTT + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
	} else {
                add     SINDEX, BUSY_TARGETS;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -BUSY_TARGETS, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(BUSY_TARGETS + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
d1315 4
a1318 1
        mov     ARG_1, SINDIR;
d1321 10
a1330 25
                mov     ARG_1 call findSCB;
        } else {
                mov     SCBPTR, ARG_1;
	}
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                jmp setup_SCB_id_lun_okay;
        } else {
                /*
                 * We only allow one untagged command per-target
                 * at a time.  So, if the lun doesn't match, look
                 * for a tag message.
                 */
                mov     A, SCB_LUN;
                cmp     SAVED_LUN, A    je setup_SCB_id_lun_okay;
                if ((ahc->flags & AHC_PAGESCBS) != 0) {
                        /*
                         * findSCB removes the SCB from the
                         * disconnected list, so we must replace
                         * it there should this SCB be for another
                         * lun.
                         */
                        call    cleanup_scb;
                }
        }

d1334 4
a1337 4
 * SCB.  With SCB paging, we must search for non-tagged
 * transactions since the SCB may exist in any slot.  If we're not
 * using SCB paging, we can use the tag as the direct index to the
 * SCB.
a1339 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x80;
        }
d1341 1
a1342 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x1;
        }
a1343 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x2;
        }
d1346 1
a1346 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     ARG_1   call findSCB;
        } else {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     SCBPTR, ARG_1;
        }
d1348 6
a1353 4
/*
 * Ensure that the SCB the tag points to is for
 * an SCB transaction to the reconnecting target.
 */
d1355 2
a1356 15
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x4;
        }
        mov     A, SCB_SCSIID;
        cmp     SAVED_SCSIID, A jne not_found_cleanup_scb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x8;
        }
setup_SCB_id_okay:
        mov     A, SCB_LUN;
        cmp     SAVED_LUN, A    jne not_found_cleanup_scb;
setup_SCB_id_lun_okay:
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x10;
        }
d1359 1
a1359 11
        test    SCB_CONTROL, TAG_ENB    jnz setup_SCB_tagged;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     A, SCBPTR;
        }
        mvi     ARG_1, SCB_LIST_NULL;
        mov     SAVED_SCSIID    call    set_busy_target;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, A;
        }
setup_SCB_tagged:
        mvi     SEQ_FLAGS,IDENTIFY_SEEN;        /* make note of IDENTIFY */
d1363 1
d1368 4
a1371 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    cleanup_scb;
        }
d1373 1
a1373 1
        mvi     NO_MATCH call set_seqint;
d1376 8
d1385 1
a1385 5
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1404 1
a1404 1
        mvi     PERR_DETECTED call set_seqint;
d1426 1
a1426 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1443 1
a1443 1
         * we must wait at least a data release delay plus
d1466 1
d1468 70
a1537 5
 * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will
 * be set to the position of the SCB.  If the SCB cannot be found locally,
 * it will be paged in from host memory.  RETURN_2 stores the address of the
 * preceding SCB in the disconnected list which can be used to speed up
 * removal of the found SCB from the disconnected list.
a1538 2
if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL;
d1540 7
a1546 5
        mov     A, SINDEX;                      /* Tag passed in SINDEX */
        cmp     DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
        mov     SCBPTR, DISCONNECTED_SCBH;      /* Initialize SCBPTR */
        mvi     ARG_2, SCB_LIST_NULL;           /* Head of list */
        jmp     findSCB_loop;
a1547 1
        cmp     SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d1549 1
d1551 1
d1553 23
a1575 1
        cmp     SCB_TAG, A      jne findSCB_next;
d1577 1
a1579 1
        mov     SINDEX, SCBPTR;
d1585 7
a1591 7
END_CRITICAL;
findSCB_notFound:
        /*
         * We didn't find it.  Page in the SCB.
         */
        mov     ARG_1, A; /* Save tag */
        mov     ALLZEROS call get_free_or_disc_scb;
d1593 1
d1595 44
a1638 1
}
d1642 1
a1642 1
 * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.
d1648 1
a1648 1
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
d1653 4
a1656 2
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
                mvi     1       call set_hcnt;
d1672 5
d1678 1
a1678 1
        mvi     PERR_DETECTED call set_seqint;
d1688 1
a1688 3
        if ((ahc->features & AHC_DT) == 0) {
                and     SCSISIGO, PHASE_MASK, SCSISIGI;
        }
a1691 6
set_hcnt:
        mov     HCNT[0], SINDEX;
clear_hcnt:
        clr     HCNT[1];
        clr     HCNT[2] ret;

a1696 2
bcopy_8:
        mov     DINDIR, SINDIR;
d1710 1
a1710 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1736 1
a1736 1
 * Setup addr assuming that A + (ARG_2 * 256) is an
d1751 1
a1751 1
 * Either post or fetch an SCB from host memory based on the
d1761 1
a1761 5
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE_64;
                } else {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE;
                }
d1766 2
a1767 2
                mvi     CCHCNT, SCB_UPLOAD_SIZE;
                if ((ahc->features & AHC_ULTRA2) == 0) {
d1769 1
a1769 1
                        bmov    CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
a1771 6
                } else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
                        mvi     CCSCBCTL, CCARREN|CCSCBRESET;
                        cmp     CCSCBCTL, ARRDONE|CCARREN jne .;
                        mvi     CCHCNT, SCB_UPLOAD_SIZE;
                        mvi     CCSCBCTL, CCSCBEN|CCSCBRESET;
                        cmp     CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d1783 3
a1785 1
                mvi     SCB_DOWNLOAD_SIZE call set_hcnt;
d1790 2
a1791 2
                mvi     SINDEX, SCB_BASE;
                add     A, SCB_DOWNLOAD_SIZE, SINDEX;
d1793 7
a1799 1
                call    copy_to_fifo_8;
a1801 1
                jmp     dma_finish;
d1803 1
a1803 49
                mvi     DINDEX, SCB_BASE;
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        /*
                         * The PCI module will only issue a PCI
                         * retry if the data FIFO is empty.  If the
                         * host disconnects in the middle of a
                         * transfer, we must empty the fifo of all
                         * available data to force the chip to
                         * continue the transfer.  This does not
                         * happen for SCSI transfers as the SCSI module
                         * will drain the FIFO as data is made available.
                         * When the hang occurs, we know that a multiple
                         * of 8 bytes are in the FIFO because the PCI
                         * module has an 8 byte input latch that only
                         * dumps to the FIFO when HCNT == 0 or the
                         * latch is full.
                         */
                        clr     A;
                        /* Wait for at least 8 bytes of data to arrive. */
dma_scb_hang_fifo:
                        test    DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
                        test    DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        /*
                         * The PCI module no longer intends to perform
                         * a PCI transaction.  Drain the fifo.
                         */
dma_scb_hang_dma_drain_fifo:
                        not     A, HCNT;
                        add     A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
                        and     A, ~0x7;
                        mov     DINDIR,DFDAT;
                        cmp     DINDEX, A jne . - 1;
                        cmp     DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
                                je      dma_finish_nowait;
                        /* Restore A as the lines left to transfer. */
                        add     A, -SCB_BASE, DINDEX;
                        shr     A, 3;
                        jmp     dma_scb_hang_fifo;
dma_scb_hang_dma_done:
                        and     DFCNTRL, ~HDMAEN;
                        test    DFCNTRL, HDMAEN jnz .;
                        add     SEQADDR0, A;
                } else {
                        call    dma_finish;
                }
d1805 5
a1809 5
                call    dfdat_in_8;
                call    dfdat_in_8;
                call    dfdat_in_8;
dfdat_in_8:
                mov     DINDIR,DFDAT;
d1811 2
a1817 1
dfdat_in_2:
a1821 12
copy_to_fifo_8:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
copy_to_fifo_6:
        mov     DFDAT,SINDIR;
copy_to_fifo_5:
        mov     DFDAT,SINDIR;
copy_to_fifo_4:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR ret;
a1828 1
dma_finish_nowait:
a1833 10
/*
 * Restore an SCB that failed to match an incoming reselection
 * to the correct/safe state.  If the SCB is for a disconnected
 * transaction, it must be returned to the disconnected list.
 * If it is not in the disconnected state, it must be free.
 */
cleanup_scb:
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                test    SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
        }
a1835 1
BEGIN_CRITICAL;
a1838 1
END_CRITICAL;
a1842 7
if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
set_hhaddr:
        or      DSCOMMAND1, HADDLDSEL0;
        and     HADDR, SG_HIGH_ADDR_BITS, SINDEX;
        and     DSCOMMAND1, ~HADDLDSEL0 ret;
}

a1844 1
BEGIN_CRITICAL;
a1847 1
        mvi     NO_FREE_SCB call set_seqint;
d1851 1
a1851 2
        mov     DISCONNECTED_SCBH, SCB_NEXT;
END_CRITICAL;
d1853 3
a1855 2
        mov     SCB_TAG jmp dma_scb;
BEGIN_CRITICAL;
d1859 1
a1859 1
END_CRITICAL;
a1866 1
BEGIN_CRITICAL;
a1868 7
END_CRITICAL;
}
set_seqint:
        mov     INTSTAT, SINDEX;
        nop;
return:
        ret;
@


1.7
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d81 1
a81 1
	test	SCSISEQ, ENSELO	jnz poll_for_work;
d362 3
d366 1
d434 2
a435 1
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;
@


1.6
log
@Missing OpenBSD pieces, DOH!
@
text
@d1 2
a2 5
/*	$OpenBSD: aic7xxx.seq,v 1.5 1996/11/28 23:27:59 niklas Exp $	*/
/*	$NetBSD: aic7xxx.seq,v 1.6 1996/10/08 03:04:06 gibbs Exp $	*/

/*+M***********************************************************************
 *Adaptec 274x/284x/294x device driver for Linux and FreeBSD.
d4 2
a5 3
 *Copyright (c) 1994 John Aycock
 *  The University of Calgary Department of Computer Science.
 *  All rights reserved.
d7 8
a14 3
 *FreeBSD, Twin, Wide, 2 command per target support, tagged queuing,
 *SCB paging and other optimizations:
 *Copyright (c) 1994, 1995, 1996 Justin Gibbs. All rights reserved.
d16 2
a17 15
 *Redistribution and use in source and binary forms, with or without
 *modification, are permitted provided that the following conditions
 *are met:
 *1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions, and the following disclaimer.
 *2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *3. All advertising materials mentioning features or use of this software
 *   must display the following acknowledgement:
 *     This product includes software developed by the University of Calgary
 *     Department of Computer Science and its contributors.
 *4. Neither the name of the University nor the names of its contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
d19 11
a29 11
 *THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 *ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 *FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *SUCH DAMAGE.
d31 2
a32 5
 * from	Id: aic7xxx.seq,v 1.42 1996/06/09 17:29:11 gibbs Exp
 *
 *-M************************************************************************/

VERSION AIC7XXX_SEQ_VER "$NetBSD: aic7xxx.seq,v 1.6 1996/10/08 03:04:06 gibbs Exp $"
d34 1
a34 2
#if defined(__OpenBSD__)
#include <dev/ic/aic7xxxreg.h>
d36 3
a38 15
#elif defined(__NetBSD__)
#include "../../ic/aic7xxxreg.h"
#include "../../../scsi/scsi_message.h"
#elif defined(__FreeBSD__)
#include "../../dev/aic7xxx/aic7xxx_reg.h"
#include "../../scsi/scsi_message.h"
#endif

/*
 * We can't just use ACCUM in the sequencer code because it
 * must be treated specially by the assembler, and it currently
 * looks for the symbol 'A'.  This is the only register defined in
 * the assembler's symbol space.
 */
A = ACCUM
d40 3
a42 1
/* After starting the selection hardware, we check for reconnecting targets
d51 5
a55 4
 * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB offsets, 
 * SCB_LIST_NULL is 0xff which is out of range.  The kernel driver must
 * add an entry to this list everytime a request sense occurs.  The sequencer
 * will automatically consume the entries.
a57 4
/*
 * We assume that the kernel driver may reset us at any time, even in the
 * middle of a DMA, so clear DFCNTRL too.
 */
d59 11
a69 13
	clr	DFCNTRL
	clr	SCSISIGO		/* De-assert BSY */
/*
 * We jump to start after every bus free.
 */
start:
	and	FLAGS,0x0f		/* clear target specific flags */
	mvi	SCSISEQ,ENRSELI		/* Always allow reselection */
	clr	SCSIRATE		/*
					 * We don't know the target we will
					 * connect to, so default to narrow
					 * transfers to avoid parity problems.
					 */
d71 36
a106 15
	/*
	 * Are we a twin channel device?
	 * For fairness, we check the other bus first,
	 * since we just finished a transaction on the
	 * current channel.
	 */
	test	FLAGS,TWIN_BUS	jz start2
	xor	SBLKCTL,SELBUSB			/* Toggle to the other bus */
	test	SSTAT0,SELDI	jnz reselect
	xor	SBLKCTL,SELBUSB			/* Toggle to the original bus */
start2:
	test	SSTAT0,SELDI	jnz reselect
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting
	mov	A, QCNTMASK
	test	QINCNT,A	jz poll_for_work
d110 37
a146 51
 * SCBs in the list of SCBs awaiting selection.  Set the SCB
 * pointer from the FIFO so we see the right bank of SCB 
 * registers.
 */
	mov	SCBPTR,QINFIFO

/*
 * See if there is not already an active SCB for this target.  This code
 * locks out on a per target basis instead of target/lun.  Although this
 * is not ideal for devices that have multiple luns active at the same
 * time, it is faster than looping through all SCB's looking for active
 * commands.  It may be benificial to make findscb a more general procedure
 * to see if the added cost of the search is negligible.  This code also 
 * assumes that the kernel driver will clear the active flags on board 
 * initialization, board reset, and a target SELTO.  Tagged commands
 * don't set the active bits since you can queue more than one command
 * at a time.  We do, however, look to see if there are any non-tagged
 * I/Os in progress, and requeue the command if there are.  Tagged and
 * non-tagged commands cannot be mixed to a single target.
 */

test_busy:
	mov	FUNCTION1,SCB_TCL
	mov	A,FUNCTION1
	test	SCB_TCL,0x88	jz test_a	/* Id < 8 && A channel */

	test	ACTIVE_B,A	jnz requeue
	test	SCB_CONTROL,TAG_ENB	jnz start_scb
	/* Mark the current target as busy */
	or	ACTIVE_B,A
	jmp	start_scb

/* Place the currently active SCB back on the queue for later processing */
requeue:
	mov	QINFIFO, SCBPTR
	jmp	poll_for_work

/*
 * Pull the first entry off of the waiting for selection list
 * We don't have to "test_busy" because only transactions that
 * have passed that test can be in the waiting_scb list.
 */
start_waiting:
	mov	SCBPTR,WAITING_SCBH
	jmp	start_scb2

test_a:
	test	ACTIVE_A,A jnz requeue
	test	SCB_CONTROL,TAG_ENB jnz start_scb
	/* Mark the current target as busy */
	or	ACTIVE_A,A
d149 13
a161 8
	mov	SCB_NEXT,WAITING_SCBH
	mov	WAITING_SCBH, SCBPTR
start_scb2:
	and	SINDEX,0xf7,SBLKCTL	/* Clear the channel select bit */
	and	A,0x08,SCB_TCL		/* Get new channel bit */
	or	SINDEX,A
	mov	SBLKCTL,SINDEX		/* select channel */
	mov	SCB_TCL	call initialize_scsiid
a162 6
/*
 * Enable selection phase as an initiator, and do automatic ATN
 * after the selection.  We do this now so that we can overlap the
 * rest of our work to set up this target with the arbitration and
 * selection bus phases.
 */
d164 43
a206 2
	mvi	SCSISEQ,0x58		/* ENSELO|ENAUTOATNO|ENRSELI */

d208 1
a208 6
 * As soon as we get a successful selection, the target should go
 * into the message out phase since we have ATN asserted.  Prepare
 * the message to send.
 *
 * Messages are stored in scratch RAM starting with a length byte
 * followed by the message itself.
d210 188
d399 1
a399 33
mk_identify:
	and	A,DISCENB,SCB_CONTROL	/* mask off disconnect privledge */

	and	MSG0,0x7,SCB_TCL	/* lun */
	or	MSG0,A			/* or in disconnect privledge */
	or	MSG0,MSG_IDENTIFYFLAG
	mvi	MSG_LEN, 1

/*
 * Send a tag message if TAG_ENB is set in the SCB control block.
 * Use SCB_TAG (the position in the kernel's SCB array) as the tag value.
 */
mk_tag:
	test	SCB_CONTROL,TAG_ENB jz  mk_message
	mvi	DINDEX, MSG1
	and	DINDIR,0x23,SCB_CONTROL
	mov	DINDIR,SCB_TAG

	add	MSG_LEN,COMP_MSG0,DINDEX	/* update message length */

/*
 * Interrupt the driver, and allow it to tweak the message buffer
 * if it asks.
 */
mk_message:
	test	SCB_CONTROL,MK_MESSAGE  jz wait_for_selection

	mvi     INTSTAT,AWAITING_MSG

wait_for_selection:
	test	SSTAT0,SELDO	jnz select 
	test	SSTAT0,SELDI	jz wait_for_selection

d402 1
a402 2
 * reselected, but haven't seen an IDENTIFY message from the target
 * yet.
d404 17
a420 5
reselect:
	clr	MSG_LEN		/* Don't have anything in the mesg buffer */
	mov	SELID		call initialize_scsiid
	or	FLAGS,RESELECTED
	jmp	select2
d423 1
a423 1
 * After the selection, remove this SCB from the "waiting for selection"
d428 196
a623 15
select:
	mov	WAITING_SCBH,SCB_NEXT
	or	FLAGS,SELECTED
select2:
/*
 * Set CLRCHN here before the target has entered a data transfer mode -
 * with synchronous SCSI, if you do it later, you blow away some
 * data in the SCSI FIFO that the target has already sent to you.
 */
	or	SXFRCTL0,CLRCHN
/*
 * Initialize SCSIRATE with the appropriate value for this target.
 */
	call	ndx_dtr
	mov	SCSIRATE,SINDIR
d625 5
a629 30
/*
 * Initialize Ultra mode setting.
 */
	mov	FUNCTION1,SCSIID
	mov	A,FUNCTION1
	and	SINDEX,0xdf,SXFRCTL0		/* default to Ultra disabled */
	test	SCSIID, 0x80	 jnz ultra_b	/* Target ID > 7 */
	test	SBLKCTL, SELBUSB jnz ultra_b	/* Second channel device */
	test	ULTRA_ENB,A	 jz  set_sxfrctl0
	or	SINDEX, ULTRAEN  jmp set_sxfrctl0
ultra_b:
	test	ULTRA_ENB_B,A	 jz  set_sxfrctl0
	or	SINDEX, ULTRAEN

set_sxfrctl0:
	mov	SXFRCTL0,SINDEX

	mvi	SCSISEQ,ENAUTOATNP		/*
						 * ATN on parity errors
						 * for "in" phases
						 */
	mvi	CLRSINT1,CLRBUSFREE
	mvi	CLRSINT0,0x60			/* CLRSELDI|CLRSELDO */
/*
 * Main loop for information transfer phases.  If BSY is false, then
 * we have a bus free condition, expected or not.  Otherwise, wait
 * for the target to assert REQ before checking MSG, C/D and I/O
 * for the bus phase.
 *
 */
d631 29
a659 2
	test	SSTAT1,BUSFREE	jnz p_busfree
	test	SSTAT1,REQINIT	jz ITloop
d661 14
a674 20
	and	A,PHASE_MASK,SCSISIGI
	mov	LASTPHASE,A
	mov	SCSISIGO,A

	cmp	ALLZEROS,A	je p_dataout
	cmp	A,P_DATAIN	je p_datain
	cmp	A,P_COMMAND	je p_command
	cmp	A,P_MESGOUT	je p_mesgout
	cmp	A,P_STATUS	je p_status
	cmp	A,P_MESGIN	je p_mesgin

	mvi	INTSTAT,BAD_PHASE	/* unknown phase - signal driver */
	jmp	ITloop			/* Try reading the bus again. */

p_dataout:
	mvi	DMAPARAMS,0x7d			/*
						 * WIDEODD|SCSIEN|SDMAEN|HDMAEN|
						 * DIRECTION|FIFORESET
						 */
	jmp	data_phase_init
d681 28
a708 9
	mov	STCNT0,SCB_RESID_DCNT0
	mov	STCNT1,SCB_RESID_DCNT1
	mov	STCNT2,SCB_RESID_DCNT2
	jmp	data_phase_loop

p_datain:
	mvi	DMAPARAMS,0x79		/*
					 * WIDEODD|SCSIEN|SDMAEN|HDMAEN|
					 * !DIRECTION|FIFORESET
d710 4
a713 2
data_phase_init:
	call	assert
d715 31
a745 3
	test	FLAGS, DPHASE	jnz data_phase_reinit
	call	sg_scb2ram
	or	FLAGS, DPHASE		/* We have seen a data phase */
d749 1
a749 1
	test	SG_COUNT, 0xff jnz data_phase_inbounds
d756 11
a766 5
	or	SXFRCTL1,BITBUCKET
	mvi	STCNT0,0xff
	mvi	STCNT1,0xff
	mvi	STCNT2,0xff

d768 11
a778 3
/* If we are the last SG block, don't set wideodd. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd
	and	DMAPARAMS, 0xbf		/* Turn off WIDEODD */
d780 10
a789 1
	mov	DMAPARAMS  call dma
d791 1
d793 1
a793 1
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun
d795 4
a798 2
/* Exit if we had an underrun */
	test	SSTAT0,SDONE	jz data_phase_finish /* underrun STCNT != 0 */
d804 1
a804 7
	dec	SG_COUNT	/* one less segment to go */

	test	SG_COUNT, 0xff	jz data_phase_finish /* Are we done? */

	clr	A			/* add sizeof(struct scatter) */
	add	SG_NEXT0,SG_SIZEOF,SG_NEXT0
	adc	SG_NEXT1,A,SG_NEXT1
d806 1
d815 74
a888 65
	clr	HCNT2
	clr	HCNT1
	mvi	HCNT0,SG_SIZEOF

	mov	HADDR0,SG_NEXT0
	mov	HADDR1,SG_NEXT1
	mov	HADDR2,SG_NEXT2
	mov	HADDR3,SG_NEXT3

	or	DFCNTRL,0xd			/* HDMAEN|DIRECTION|FIFORESET */

/*
 * Wait for DMA from host memory to data FIFO to complete, then disable
 * DMA and wait for it to acknowledge that it's off.
 */
dma_finish:
	test	DFSTATUS,HDONE	jz dma_finish
	/* Turn off DMA preserving WIDEODD */
	and	DFCNTRL,WIDEODD
dma_finish2:
	test	DFCNTRL,HDMAENACK jnz dma_finish2

/*
 * Copy data from FIFO into SCB data pointer and data count.  This assumes
 * that the struct scatterlist has this structure (this and sizeof(struct
 * scatterlist) == 12 are asserted in aic7xxx.c for the Linux driver):
 *
 *	struct scatterlist {
 *		char *address;		four bytes, little-endian order
 *		...			four bytes, ignored
 *		unsigned short length;	two bytes, little-endian order
 *	}
 *
 *
 * In FreeBSD, the scatter list entry is only 8 bytes.
 * 
 * struct ahc_dma_seg {
 *       physaddr addr;                  four bytes, little-endian order
 *       long    len;                    four bytes, little endian order
 * };
 */

	mov	HADDR0,DFDAT
	mov	HADDR1,DFDAT
	mov	HADDR2,DFDAT
	mov	HADDR3,DFDAT
/*
 * For Linux, we must throw away four bytes since there is a 32bit gap
 * in the middle of a struct scatterlist.
 */
#ifdef __linux__
	mov	NONE,DFDAT
	mov	NONE,DFDAT
	mov	NONE,DFDAT
	mov	NONE,DFDAT
#endif
	mov	HCNT0,DFDAT
	mov	HCNT1,DFDAT
	mov	HCNT2,DFDAT

/* Load STCNT as well.  It is a mirror of HCNT */
	mov	STCNT0,HCNT0
	mov	STCNT1,HCNT1
	mov	STCNT2,HCNT2
        test    SSTAT1,PHASEMIS  jz data_phase_loop
d891 3
d899 25
a923 5
	mov	SCB_RESID_DCNT0,STCNT0
	mov	SCB_RESID_DCNT1,STCNT1
	mov	SCB_RESID_DCNT2,STCNT2
	mov	SCB_RESID_SGCNT, SG_COUNT
	jmp	ITloop
d926 4
d933 38
a970 3
	and	SXFRCTL1,0x7f		/* ~BITBUCKET */
	mvi	INTSTAT,DATA_OVERRUN
	jmp	ITloop
d972 1
d977 1
a977 1
	call	assert
d979 50
a1028 18
/*
 * Load HADDR and HCNT.
 */
	mov	HADDR0, SCB_CMDPTR0
	mov	HADDR1, SCB_CMDPTR1
	mov	HADDR2, SCB_CMDPTR2
	mov	HADDR3, SCB_CMDPTR3
	mov	HCNT0, SCB_CMDLEN
	clr	HCNT1
	clr	HCNT2

	mov	STCNT0, HCNT0
	mov	STCNT1, HCNT1
	mov	STCNT2, HCNT2

	mvi	0x3d		call dma	# SCSIEN|SDMAEN|HDMAEN|
						#   DIRECTION|FIFORESET
	jmp	ITloop
d1035 4
a1038 2
	mvi	SCB_TARGET_STATUS	call inb_first
	jmp	mesgin_done
d1041 22
a1062 2
 * Message out phase.  If there is not an active message, but the target
 * took us into this phase anyway, build a no-op message and send it.
d1064 2
d1067 33
a1099 4
	test	MSG_LEN, 0xff	jnz  p_mesgout_start
	mvi	MSG_NOOP	call mk_mesg	/* build NOP message */

p_mesgout_start:
d1101 2
a1102 12
 * Set up automatic PIO transfer from MSG0.  Bit 3 in
 * SXFRCTL0 (SPIOEN) is already on.
 */
	mvi	SINDEX,MSG0
	mov	DINDEX,MSG_LEN

/*
 * When target asks for a byte, drop ATN if it's the last one in
 * the message.  Otherwise, keep going until the message is exhausted.
 *
 * Keep an eye out for a phase change, in case the target issues
 * a MESSAGE REJECT.
d1104 20
a1123 13
p_mesgout_loop:
	test	SSTAT1,PHASEMIS	jnz p_mesgout_phasemis
	test	SSTAT0,SPIORDY	jz p_mesgout_loop
	test	SSTAT1,PHASEMIS	jnz p_mesgout_phasemis
	cmp	DINDEX,1	jne p_mesgout_outb	/* last byte? */
	mvi	CLRSINT1,CLRATNO			/* drop ATN */
p_mesgout_outb:
	dec	DINDEX
	or	CLRSINT0, CLRSPIORDY
	mov	SCSIDATL,SINDIR
	
p_mesgout4:
	test	DINDEX,0xff	jnz p_mesgout_loop
d1126 1
a1126 1
 * If the next bus phase after ATN drops is a message out, it means
d1129 2
a1130 3
p_mesgout_snoop:
	test	SSTAT1,BUSFREE	jnz p_mesgout_done
	test	SSTAT1,REQINIT	jz p_mesgout_snoop
a1131 8
	test	SSTAT1,PHASEMIS	jnz p_mesgout_done

	or	SCSISIGO,ATNO			/* turn on ATNO */

	jmp	ITloop

p_mesgout_phasemis:
	mvi	CLRSINT1,CLRATNO	/* Be sure to turn ATNO off */
d1133 4
a1136 2
	clr	MSG_LEN			/* no active msg */
	jmp	ITloop
d1142 1
a1142 2
	mvi	A		call inb_first	/* read the 1st message byte */
	mov	REJBYTE,A			/* save it for the driver */
d1144 21
a1164 21
	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify
	cmp	A,MSG_DISCONNECT	je mesgin_disconnect
	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs
	cmp	ALLZEROS,A		je mesgin_complete
	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs
	cmp	A,MSG_EXTENDED		je mesgin_extended
	cmp	A,MSG_MESSAGE_REJECT	je mesgin_reject

rej_mesgin:
/*
 * We have no idea what this message in is, and there's no way
 * to pass it up to the kernel, so we issue a message reject and
 * hope for the best.  Since we're now using manual PIO mode to
 * read in the message, there should no longer be a race condition
 * present when we assert ATN.  In any case, rejection should be a
 * rare occurrence - signal the driver when it happens.
 */
	or	SCSISIGO,ATNO			/* turn on ATNO */
	mvi	INTSTAT,SEND_REJECT		/* let driver know */

	mvi	MSG_MESSAGE_REJECT	call mk_mesg
d1167 2
a1168 2
	call	inb_last			/*ack & turn auto PIO back on*/
	jmp	ITloop
d1173 15
a1187 16
 * We got a "command complete" message, so put the SCB_TAG into QUEUEOUT,
 * and trigger a completion interrupt.  Check status for non zero return
 * and interrupt driver if needed.  This allows the driver to interpret
 * errors only when they occur instead of always uploading the scb.  If
 * the status is SCSI_CHECK, the driver will download a new scb requesting
 * sense to replace the old one, modify the "waiting for selection" SCB list
 * and set RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE the
 * sequencer imediately jumps to main loop where it will run down the waiting
 * SCB list and process the sense request.  If the kernel driver does not
 * wish to request sense, it need only clear RETURN_1, and the command is
 * allowed to complete.  We don't bother to post to the QOUTFIFO in the
 * error case since it would require extra work in the kernel driver to
 * ensure that the entry was removed before the command complete code tried
 * processing it.
 *
 * First check for residuals
d1189 1
a1189 1
	test	SCB_RESID_SGCNT,0xff	jz check_status
d1191 1
a1191 6
 * If we have a residual count, interrupt and tell the host.  Other
 * alternatives are to pause the sequencer on all command completes (yuck),
 * dma the resid directly to the host (slick, we may have space to do it now)
 * or have the sequencer pause itself when it encounters a non-zero resid 
 * (unecessary pause just to flag the command -yuck-, but takes one instruction
 * and since it shouldn't happen that often is good enough for our purposes).  
d1193 22
a1214 2
resid:
	mvi	INTSTAT,RESIDUAL
a1215 31
check_status:
	test	SCB_TARGET_STATUS,0xff	jz status_ok	/* Good Status? */
	mvi	INTSTAT,BAD_STATUS			/* let driver know */
	cmp	RETURN_1, SEND_SENSE	jne status_ok
	jmp	mesgin_done

status_ok:
/* First, mark this target as free. */
	test	SCB_CONTROL,TAG_ENB jnz test_immediate	/*
							 * Tagged commands
							 * don't busy the
							 * target.
							 */
	mov	FUNCTION1,SCB_TCL
	mov	A,FUNCTION1
	test	SCB_TCL,0x88 jz clear_a
	xor	ACTIVE_B,A
	jmp	test_immediate

clear_a:
	xor	ACTIVE_A,A

test_immediate:
	test    SCB_CMDLEN,0xff jnz complete  /* Immediate message complete */
/*
 * Pause the sequencer until the driver gets around to handling the command
 * complete.  This is so that any action that might require carefull timing
 * with the completion of this command can occur.
 */
	mvi	INTSTAT,IMMEDDONE
	jmp	start
d1217 27
a1243 40
	mov	QOUTFIFO,SCB_TAG
	mvi	INTSTAT,CMDCMPLT
	jmp	mesgin_done


/*
 * Is it an extended message?  Copy the message to our message buffer and
 * notify the host.  The host will tell us whether to reject this message,
 * respond to it with the message that the host placed in our message buffer,
 * or simply to do nothing.
 */
mesgin_extended:
	mvi	MSGIN_EXT_LEN	 call inb_next
	mvi	MSGIN_EXT_OPCODE call inb_next
	mov	A, MSGIN_EXT_LEN
	dec	A	/* Length counts the op code */
	mvi	SINDEX, MSGIN_EXT_BYTE0
mesgin_extended_loop:
	test	A, 0xFF		jz mesgin_extended_intr
	cmp	SINDEX, MSGIN_EXT_LASTBYTE je mesgin_extended_dump
	call	inb_next
	dec	A
/*
 * We pass the arg to inb in SINDEX, but DINDEX is the one incremented
 * so update SINDEX with DINDEX's value before looping again.
 */
	mov	DINDEX		jmp mesgin_extended_loop
mesgin_extended_dump:
/* We have no more storage space, so dump the rest */
	test	A, 0xFF		jz mesgin_extended_intr
	mvi	NONE		call inb_next
	dec	A
	jmp	mesgin_extended_dump
mesgin_extended_intr:
	mvi	INTSTAT,EXTENDED_MSG		/* let driver know */
	cmp	RETURN_1,SEND_REJ je rej_mesgin
	cmp	RETURN_1,SEND_MSG jne mesgin_done
/* The kernel has setup a message to be sent */
	or	SCSISIGO,ATNO			/* turn on ATNO */
	jmp	mesgin_done
d1245 1
d1251 3
a1253 18
	or	SCB_CONTROL,DISCONNECTED
	test	FLAGS, PAGESCBS jz mesgin_done
/*
 * Link this SCB into the DISCONNECTED list.  This list holds the
 * candidates for paging out an SCB if one is needed for a new command.
 * Modifying the disconnected list is a critical(pause dissabled) section.
 */
	mvi	SCB_PREV, SCB_LIST_NULL
	mvi	SEQCTL,0x50			/* PAUSEDIS|FASTMODE */
	mov	SCB_NEXT, DISCONNECTED_SCBH
	mov	DISCONNECTED_SCBH, SCBPTR
	cmp	SCB_NEXT,SCB_LIST_NULL je linkdone
	mov	SCBPTR,SCB_NEXT
	mov	SCB_PREV,DISCONNECTED_SCBH
	mov	SCBPTR,DISCONNECTED_SCBH
linkdone:
	mvi	SEQCTL,0x10			/* !PAUSEDIS|FASTMODE */
	jmp	mesgin_done
d1256 5
a1260 2
 * Save data pointers message?  Copy working values into the SCB,
 * usually in preparation for a disconnect.
d1263 21
a1283 2
	call	sg_ram2scb
	jmp	mesgin_done
d1292 2
a1293 2
	and	FLAGS,0xef			/*
						 * !DPHASE we'll reload them
d1295 1
d1297 1
a1297 1
	jmp	mesgin_done
d1305 21
a1325 9
	test	A,0x78	jnz rej_mesgin	/*!DiscPriv|!LUNTAR|!Reserved*/

	and	A,0x07			/* lun in lower three bits */
	or      SAVED_TCL,A,SELID          
	and     SAVED_TCL,0xf7
	and     A,SELBUSB,SBLKCTL	/* B Channel?? */
	or      SAVED_TCL,A
	call	inb_last		/* ACK */

d1328 2
a1329 2
 * If we get one, we use the tag returned to switch to find the proper
 * SCB.  With SCB paging, this requires using findSCB for both tagged
d1334 2
a1335 1
	mvi	ARG_1,SCB_LIST_NULL	/* Default to no-tag */
d1337 3
a1339 5
	test	SSTAT1,BUSFREE		jnz use_findSCB
	test	SSTAT1,REQINIT		jz snoop_tag_loop
	test	SSTAT1,PHASEMIS		jnz use_findSCB
	mvi	A			call inb_first
	cmp	A,MSG_SIMPLE_Q_TAG	jne use_findSCB
d1341 1
a1341 9
	mvi	ARG_1	call inb_next	/* tag value */
/*
 * See if the tag is in range.  The tag is < SCBCOUNT if we add
 * the complement of SCBCOUNT to the incomming tag and there is
 * no carry.
 */
	mov	A,COMP_SCBCOUNT	
	add	SINDEX,A,ARG_1
	jc	abort_tag
d1343 6
a1348 8
/*
 * Ensure that the SCB the tag points to is for an SCB transaction
 * to the reconnecting target.
 */
	test	FLAGS, PAGESCBS	jz index_by_tag
	call	inb_last			/* Ack Tag */
use_findSCB:
	mov	ALLZEROS	call findSCB	  /* Have to search */
d1350 20
a1369 26
	and	SCB_CONTROL,0xfb	  /* clear disconnect bit in SCB */
	or	FLAGS,IDENTIFY_SEEN	  /* make note of IDENTIFY */
	jmp	ITloop
index_by_tag:
	mov	SCBPTR,ARG_1
	mov	A,SAVED_TCL
	cmp	SCB_TCL,A		jne abort_tag
	test	SCB_CONTROL,TAG_ENB	jz  abort_tag
	call	inb_last			/* Ack Successful tag */
	jmp	setup_SCB

abort_tag:
	or	SCSISIGO,ATNO			/* turn on ATNO */
	mvi	INTSTAT,ABORT_TAG 		/* let driver know */
	mvi	MSG_ABORT_TAG	call mk_mesg	/* ABORT TAG message */
	jmp	mesgin_done

/*
 * Message reject?  Let the kernel driver handle this.  If we have an 
 * outstanding WDTR or SDTR negotiation, assume that it's a response from 
 * the target selecting 8bit or asynchronous transfer, otherwise just ignore 
 * it since we have no clue what it pertains to.
 */
mesgin_reject:
	mvi	INTSTAT, REJECT_MSG
	jmp	mesgin_done
a1375 16
 * Bus free phase.  It might be useful to interrupt the device
 * driver if we aren't expecting this.  For now, make sure that
 * ATN isn't being asserted and look for a new command.
 */
p_busfree:
	mvi	CLRSINT1,CLRATNO
	clr	LASTPHASE

/*
 * if this is an immediate command, perform a psuedo command complete to
 * notify the driver.
 */
	test	SCB_CMDLEN,0xff	jz status_ok
	jmp	start

/*
d1380 2
a1381 16
	mvi	SEQCTL,0x50			/* PAUSEDIS|FASTMODE */
	test	MSG_LEN,0xff	jz mk_mesg1	/* Should always succeed */
	
	/*
	 * Hmmm.  For some reason the mesg buffer is in use.
	 * Tell the driver.  It should look at SINDEX to find
	 * out what we wanted to use the buffer for and resolve
	 * the conflict.
	 */
	mvi	SEQCTL,0x10			/* !PAUSEDIS|FASTMODE */
	mvi	INTSTAT,MSG_BUFFER_BUSY

mk_mesg1:
	mvi	MSG_LEN,1		/* length = 1 */
	mov	MSG0,SINDEX		/* 1-byte message */
	mvi	SEQCTL,0x10	ret	/* !PAUSEDIS|FASTMODE */
d1398 3
a1400 1

d1402 1
a1402 2
	or	CLRSINT0, CLRSPIORDY
	mov	NONE,SCSIDATL			/*dummy read from latch to ACK*/
d1404 10
a1413 2
	test	SSTAT1,PHASEMIS	jnz mesgin_phasemis
	test	SSTAT0,SPIORDY	jz inb_next_wait /* wait for next byte */
d1415 2
a1416 3
	mov	DINDEX,SINDEX
	test	SSTAT1,PHASEMIS	jnz mesgin_phasemis
	mov	DINDIR,SCSIBUSL	ret		/*read byte directly from bus*/
d1418 2
a1419 1
	mov	NONE,SCSIDATL ret		/*dummy read from latch to ACK*/
d1421 40
d1465 2
a1466 2
	mvi	INTSTAT, MSGIN_PHASEMIS
	jmp	ITloop
d1475 5
a1479 4
	mov	DFCNTRL,SINDEX
dma1:
	test	SSTAT0,DMADONE	jnz dma3
	test	SSTAT1,PHASEMIS	jz dma1		/* ie. underrun */
d1489 8
a1496 5
dma3:
	test	SINDEX,DIRECTION	jnz dma5
dma4:
	test	DFSTATUS,FIFOEMP	jz dma4

d1501 14
a1514 5
dma5:
	/* disable DMA, but maintain WIDEODD */
	and	DFCNTRL,WIDEODD
dma6:
	test	DFCNTRL,0x38	jnz dma6  /* SCSIENACK|SDMAENACK|HDMAENACK */
d1516 1
a1516 12
	ret

/*
 * Common SCSI initialization for selection and reselection.  Expects
 * the target SCSI ID to be in the upper four bits of SINDEX, and A's
 * contents are stomped on return.
 */
initialize_scsiid:
	and	SINDEX,0xf0		/* Get target ID */
	and	A,0x0f,SCSIID
	or	SINDEX,A
	mov	SCSIID,SINDEX ret
d1523 1
a1523 2
	test	FLAGS,RESELECTED	jz return	/* reselected? */
	test	FLAGS,IDENTIFY_SEEN	jnz return	/* seen IDENTIFY? */
d1525 1
a1525 1
	mvi	INTSTAT,NO_IDENT 	ret	/* no - cause a kernel panic */
d1528 5
a1532 5
 * Locate the SCB matching the target ID/channel/lun in SAVED_TCL, and the tag
 * value in ARG_1.  If ARG_1 == SCB_LIST_NULL, we're looking for a non-tagged
 * SCB.  Have the kernel print a warning message if it can't be found, and
 * generate an ABORT/ABORT_TAG message to the target.  SINDEX should be
 * cleared on call.
d1535 37
a1571 13
	mov	A,SAVED_TCL
	mov	SCBPTR,SINDEX			/* switch to next SCB */
	mvi	SEQCTL,0x50			/* PAUSEDIS|FASTMODE */
	cmp	SCB_TCL,A	jne findSCB1 /* target ID/channel/lun match? */
	test	SCB_CONTROL,DISCONNECTED jz findSCB1 /*should be disconnected*/
	test	SCB_CONTROL,TAG_ENB jnz findTaggedSCB
	cmp	ARG_1,SCB_LIST_NULL je foundSCB
	jmp	findSCB1
findTaggedSCB:
	mov	A, ARG_1			/* Tag passed in ARG_1 */
	cmp	SCB_TAG,A	jne findSCB1	/* Found it? */
foundSCB:
	test	FLAGS,PAGESCBS	jz foundSCB_ret
d1573 5
a1577 12
	cmp	SCB_NEXT,SCB_LIST_NULL je unlink_prev
	mov	SAVED_LINKPTR, SCB_PREV
	mov	SCBPTR, SCB_NEXT
	mov	SCB_PREV, SAVED_LINKPTR
	mov	SCBPTR, SINDEX
unlink_prev:
	cmp	SCB_PREV,SCB_LIST_NULL	je rHead/* At the head of the list */
	mov	SAVED_LINKPTR, SCB_NEXT
	mov	SCBPTR, SCB_PREV
	mov	SCB_NEXT, SAVED_LINKPTR
	mov	SCBPTR, SINDEX
	mvi	SEQCTL,0x10	ret		/* !PAUSEDIS|FASTMODE */
d1579 1
a1579 42
	mov	DISCONNECTED_SCBH,SCB_NEXT
foundSCB_ret:
	mvi	SEQCTL,0x10	ret		/* !PAUSEDIS|FASTMODE */

findSCB1:
	mvi	SEQCTL,0x10			/* !PAUSEDIS|FASTMODE */
	inc	SINDEX
	mov	A,SCBCOUNT
	cmp	SINDEX,A	jne findSCB

	mvi	INTSTAT,NO_MATCH		/* not found - signal kernel */
	cmp	RETURN_1,SCB_PAGEDIN je return
	or	SCSISIGO,ATNO			/* assert ATNO */
	cmp	ARG_1,SCB_LIST_NULL jne find_abort_tag
	mvi	MSG_ABORT	call mk_mesg
	jmp	ITloop
find_abort_tag:
	mvi	MSG_ABORT_TAG	call mk_mesg
	jmp	ITloop

/*
 * Make a working copy of the scatter-gather parameters from the SCB.
 */
sg_scb2ram:
	mov	HADDR0, SCB_DATAPTR0
	mov	HADDR1, SCB_DATAPTR1
	mov	HADDR2, SCB_DATAPTR2
	mov	HADDR3, SCB_DATAPTR3
	mov	HCNT0, SCB_DATACNT0
	mov	HCNT1, SCB_DATACNT1
	mov	HCNT2, SCB_DATACNT2

	mov	STCNT0, HCNT0
	mov	STCNT1, HCNT1
	mov	STCNT2, HCNT2

	mov	SG_COUNT,SCB_SGCOUNT

	mov	SG_NEXT0, SCB_SGPTR0
	mov	SG_NEXT1, SCB_SGPTR1
	mov	SG_NEXT2, SCB_SGPTR2
	mov	SG_NEXT3, SCB_SGPTR3 ret
d1581 1
d1583 2
a1584 4
 * Copying RAM values back to SCB, for Save Data Pointers message, but
 * only if we've actually been into a data phase to change them.  This
 * protects against bogus data in scratch ram and the residual counts
 * since they are only initialized when we go into data_in or data_out.
d1586 231
a1816 13
sg_ram2scb:
	test	FLAGS, DPHASE	jz return
	mov	SCB_SGCOUNT,SG_COUNT

	mov	SCB_SGPTR0,SG_NEXT0
	mov	SCB_SGPTR1,SG_NEXT1
	mov	SCB_SGPTR2,SG_NEXT2
	mov	SCB_SGPTR3,SG_NEXT3
	
	mov	SCB_DATAPTR0,SHADDR0
	mov	SCB_DATAPTR1,SHADDR1
	mov	SCB_DATAPTR2,SHADDR2
	mov	SCB_DATAPTR3,SHADDR3
d1819 2
a1820 1
 * Use the residual number since STCNT is corrupted by any message transfer
d1822 33
a1854 3
	mov	SCB_DATACNT0,SCB_RESID_DCNT0
	mov	SCB_DATACNT1,SCB_RESID_DCNT1
	mov	SCB_DATACNT2,SCB_RESID_DCNT2 ret
d1856 1
d1858 3
a1860 3
 * Add the array base TARG_SCRATCH to the target offset (the target address
 * is in SCSIID), and return the result in SINDEX.  The accumulator
 * contains the 3->8 decoding of the target ID on return.
d1862 2
a1863 6
ndx_dtr:
	shr	A,SCSIID,4
	test	SBLKCTL,SELBUSB	jz ndx_dtr_2
	or	A,0x08		/* Channel B entries add 8 */
ndx_dtr_2:
	add	SINDEX,TARG_SCRATCH,A ret
@


1.6.14.1
log
@Sync with -current
@
text
@d1 9
a9 2
/*
 * Adaptec 274x/284x/294x device driver firmware for Linux and FreeBSD.
d11 3
a13 2
 * Copyright (c) 1994-2000 Justin Gibbs.
 * All rights reserved.
d15 15
a29 8
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d31 11
a41 2
 * Alternatively, this software may be distributed under the terms of the
 * the GNU Public License ("GPL").
d43 1
a43 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d45 3
a47 2
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.93 2000/01/07 23:08:20 gibbs Exp $
 */
d49 2
a50 1
#include <dev/microcode/aic7xxx/aic7xxx.reg>
d52 15
a66 3
/*
#include <cam/scsi/scsi_message.h>
*/
d68 1
a68 3
/*
 * A few words on the waiting SCB list:
 * After starting the selection hardware, we check for reconnecting targets
d77 4
a80 5
 * of SCBs that are awaiting selection.  Since 0-0xfe are valid SCB indexes, 
 * SCB_LIST_NULL is 0xff which is out of range.  An entry is also added to
 * this list everytime a request sense occurs or after completing a non-tagged
 * command for which a second SCB has been queued.  The sequencer will
 * automatically consume the entries.
d83 4
d88 13
a100 11
	clr	SCSISIGO;		/* De-assert BSY */
	mvi	MSG_OUT, MSG_NOOP;	/* No message to send */
	and	SXFRCTL1, ~BITBUCKET;
	/* Always allow reselection */
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ_TEMPLATE;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		clr	CCSGCTL;
		clr	CCSCBCTL;
	}

d102 15
a116 36
	call	clear_target_state;
	and	SXFRCTL0, ~SPIOEN;
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		mov	A, QINPOS;
	}
poll_for_work_loop:
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		and	SEQCTL, ~PAUSEDIS;
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
	test	SCSISEQ, ENSELO	jnz poll_for_work;
	if ((ahc->features & AHC_TWIN) != 0) {
		/*
		 * Twin channel devices cannot handle things like SELTO
		 * interrupts on the "background" channel.  So, if we
		 * are selecting, keep polling the current channel util
		 * either a selection or reselection occurs.
		 */
		xor	SBLKCTL,SELBUSB;	/* Toggle to the other bus */
		test	SSTAT0, SELDO|SELDI	jnz selection;
		test	SCSISEQ, ENSELO	jnz poll_for_work;
		xor	SBLKCTL,SELBUSB;	/* Toggle back */
	}
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
test_queue:
	/* Has the driver posted any work for us? */
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		test	QOFF_CTLSTA, SCB_AVAIL jz poll_for_work_loop;
		mov	NONE, SNSCB_QOFF;
		inc	QINPOS;
	} else {
		or	SEQCTL, PAUSEDIS;
		cmp	KERNEL_QINPOS, A je poll_for_work_loop;
		inc	QINPOS;
		and	SEQCTL, ~PAUSEDIS;
	}
d120 51
a170 37
 * SCBs in the list of SCBs awaiting selection.  If we have
 * any SCBs available for use, pull the tag from the QINFIFO
 * and get to work on it.
 */
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mov	ALLZEROS	call	get_free_or_disc_scb;
	}

dequeue_scb:
	add	A, -1, QINPOS;
	mvi	QINFIFO_OFFSET call fetch_byte;

	if ((ahc->flags & AHC_PAGESCBS) == 0) {
		/* In the non-paging case, the SCBID == hardware SCB index */
		mov	SCBPTR, RETURN_2;
	}
dma_queued_scb:
/*
 * DMA the SCB from host ram into the current SCB location.
 */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	RETURN_2	 call dma_scb;

/*
 * Preset the residual fields in case we never go through a data phase.
 * This isn't done by the host so we can avoid a DMA to clear these
 * fields for the normal case of I/O that completes without underrun
 * or overrun conditions.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, SCB_DATACNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],SCB_DATACNT[0];
		mov	SCB_RESID_DCNT[1],SCB_DATACNT[1];
		mov	SCB_RESID_DCNT[2],SCB_DATACNT[2];
	}
	mov	SCB_RESID_SGCNT, SCB_SGCOUNT;
d173 8
a180 13
	/*
	 * Place us on the waiting list in case our selection
	 * doesn't win during bus arbitration.
	 */
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
start_waiting:
	/*
	 * Pull the first entry off of the waiting SCB list.
	 */
	mov	SCBPTR, WAITING_SCBH;
	call	start_selection;
	jmp	poll_for_work;
d182 6
d189 31
a219 43
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		and	A,SELBUSB,SCB_TCL;	/* Get new channel bit */
		or	SINDEX,A;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
initialize_scsiid:
	mov	SINDEX, SCSISEQ_TEMPLATE;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SCB_CONTROL, TARGET_SCB jz . + 4;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mov	SCSIID_ULTRA2, SCB_CMDPTR[2];
		} else {
			mov	SCSIID, SCB_CMDPTR[2];
		}
		or	SINDEX, TEMODE;
		jmp	initialize_scsiid_fini;
	}
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID_ULTRA2, OID;	/* Clear old target */
		or	SCSIID_ULTRA2, A;
	} else {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID, OID;		/* Clear old target */
		or	SCSIID, A;
	}
initialize_scsiid_fini:
	mov	SCSISEQ, SINDEX ret;

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
	or	SXFRCTL0, CLRSTCNT|CLRCHN, SINDEX;
set_transfer_settings:
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
d221 2
a222 1
 * Initialize SCSIRATE with the appropriate value for this target.
d224 8
a231 188
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}

selection:
	test	SSTAT0,SELDO	jnz select_out;
	mvi	CLRSINT0, CLRSELDI;
select_in:
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		if ((ahc->flags & AHC_INITIATORMODE) != 0) {
			test	SSTAT0, TARGET	jz initiator_reselect;
		}

		/*
		 * We've just been selected.  Assert BSY and
		 * setup the phase for receiving messages
		 * from the target.
		 */
		mvi	SCSISIGO, P_MESGOUT|BSYO;
		mvi	CLRSINT1, CLRBUSFREE;

		/*
		 * Setup the DMA for sending the identify and
		 * command information.
		 */
		or	SEQ_FLAGS, CMDPHASE_PENDING;

		mov     A, TQINPOS;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	DINDEX, CCHADDR;
			mvi	TMODE_CMDADDR call set_32byte_addr;
			mvi	CCSCBCTL, CCSCBRESET;
		} else {
			mvi	DINDEX, HADDR;
			mvi	TMODE_CMDADDR call set_32byte_addr;
			mvi	DFCNTRL, FIFORESET;
		}

		/* Initiator that selected us */
		and	SAVED_TCL, SELID_MASK, SELID;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_TCL;
		} else {
			mov	DFDAT, SAVED_TCL;
		}

		/* The Target ID we were selected at */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	CCSCBRAM, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	CCSCBRAM, OID, SCSIID_ULTRA2;
			} else {
				and	CCSCBRAM, OID, SCSIID;
			}
		} else {
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	DFDAT, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	DFDAT, OID, SCSIID_ULTRA2;
			} else {
				and	DFDAT, OID, SCSIID;
			}
		}

		/* No tag yet */
		mvi	INITIATOR_TAG, SCB_LIST_NULL;

		/*
		 * If ATN isn't asserted, the target isn't interested
		 * in talking to us.  Go directly to bus free.
		 */
		test	SCSISIGI, ATNI	jz	target_busfree;

		/*
		 * Watch ATN closely now as we pull in messages from the
		 * initiator.  We follow the guidlines from section 6.5
		 * of the SCSI-2 spec for what messages are allowed when.
		 */
		call	target_inb;

		/*
		 * Our first message must be one of IDENTIFY, ABORT, or
		 * BUS_DEVICE_RESET.
		 */
		/* XXX May need to be more lax here for older initiators... */
		test	DINDEX, MSG_IDENTIFYFLAG jz host_target_message_loop;
		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}

		/* Remember for disconnection decision */
		test	DINDEX, MSG_IDENTIFY_DISCFLAG jnz . + 2;
		/* XXX Honor per target settings too */
		or	SEQ_FLAGS, NO_DISCONNECT;

		test	SCSISIGI, ATNI	jz	ident_messages_done;
		call	target_inb;
		/*
		 * If this is a tagged request, the tagged message must
		 * immediately follow the identify.  We test for a valid
		 * tag message by seeing if it is >= MSG_SIMPLE_Q_TAG and
		 * < MSG_IGN_WIDE_RESIDUE.
		 */
		add	A, -MSG_SIMPLE_Q_TAG, DINDEX;
		jnc	ident_messages_done;
		add	A, -MSG_IGN_WIDE_RESIDUE, DINDEX;
		jc	ident_messages_done;
		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}
		
		/*
		 * If the initiator doesn't feel like providing a tag number,
		 * we've got a failed selection and must transition to bus
		 * free.
		 */
		test	SCSISIGI, ATNI	jz	target_busfree;

		/*
		 * Store the tag for the host.
		 */
		call	target_inb;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, DINDEX;
		} else {
			mov	DFDAT, DINDEX;
		}
		mov	INITIATOR_TAG, DINDEX;
		jmp	ident_messages_done;

		/*
		 * Pushed message loop to allow the kernel to
		 * run it's own target mode message state engine.
		 */
host_target_message_loop:
		mvi	INTSTAT, HOST_MSG_LOOP;
		nop;
		cmp	RETURN_1, EXIT_MSG_LOOP	je target_ITloop;
		test	SSTAT0, SPIORDY jz .;
		jmp	host_target_message_loop;

ident_messages_done:
		/* If ring buffer is full, return busy or queue full */
		mov	A, KERNEL_TQINPOS;
		cmp	TQINPOS, A jne tqinfifo_has_space;
		mvi	P_STATUS|BSYO call change_phase;
		cmp	INITIATOR_TAG, SCB_LIST_NULL je . + 3;
		mvi	STATUS_QUEUE_FULL call target_outb;
		jmp	target_busfree_wait;
		mvi	STATUS_BUSY call target_outb;
		jmp	target_busfree_wait;
tqinfifo_has_space:	
		/* Terminate the ident list */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	CCSCBRAM, SCB_LIST_NULL;
		} else {
			mvi	DFDAT, SCB_LIST_NULL;
		}
		or	SEQ_FLAGS, TARG_CMD_PENDING|IDENTIFY_SEEN;
		test	SCSISIGI, ATNI	jnz target_mesgout_pending_msg;
		jmp	target_ITloop;
		
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
		/*
		 * Drive REQ on the bus by enabling SCSI PIO.
		 */
		or	SXFRCTL0, SPIOEN;
		/* Wait for the byte */
		test	SSTAT0, SPIORDY jz .;
		/* Prevent our read from triggering another REQ */
		and	SXFRCTL0, ~SPIOEN;
		/* Save latched contents */
		mov	DINDEX, SCSIDATL ret;
	}
a232 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d235 2
a236 1
 * reselected, but haven't seen an IDENTIFY message from the target yet.
d238 5
a242 17
initiator_reselect:
	/* XXX test for and handle ONE BIT condition */
	and	SAVED_TCL, SELID_MASK, SELID;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_TCL, SELBUSB;
	}
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;		/*
						 * We aren't expecting a
						 * bus free, so interrupt
						 * the kernel driver if it
						 * happens.
						 */
	jmp	ITloop;
}
d245 1
a245 1
 * After the selection, remove this SCB from the "waiting SCB"
d250 15
a264 181
select_out:
	/* Turn off the selection hardware */
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;
	mvi	CLRSINT0, CLRSELDO;
	mov	SCBPTR, WAITING_SCBH;
	mov	WAITING_SCBH,SCB_NEXT;
	mov	SAVED_TCL, SCB_TCL;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SSTAT0, TARGET	jz initiator_select;

		/*
		 * We've just re-selected an initiator.
		 * Assert BSY and setup the phase for
		 * sending our identify messages.
		 */
		mvi	P_MESGIN|BSYO call change_phase;
		mvi	CLRSINT1,CLRBUSFREE;

		/*
		 * Start out with a simple identify message.
		 */
		and	A, LID, SCB_TCL;
		or	A, MSG_IDENTIFYFLAG call target_outb;

		/*
		 * If we are the result of a tagged command, send
		 * a simple Q tag and the tag id.
		 */
		test	SCB_CONTROL, TAG_ENB	jz . + 3;
		mvi	MSG_SIMPLE_Q_TAG call target_outb;
		mov	SCB_INITIATOR_TAG call target_outb;
		mov	INITIATOR_TAG, SCB_INITIATOR_TAG;
target_synccmd:
		/*
		 * Now determine what phases the host wants us
		 * to go through.
		 */
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
		

target_ITloop:
		/*
		 * Start honoring ATN signals now that
		 * we properly identified ourselves.
		 */
		test	SCSISIGI, ATNI			jnz target_mesgout;
		test	SEQ_FLAGS, CMDPHASE_PENDING	jnz target_cmdphase;
		test	SEQ_FLAGS, DPHASE_PENDING	jnz target_dphase;
		test	SEQ_FLAGS, SPHASE_PENDING	jnz target_sphase;

		/*
		 * No more work to do.  Either disconnect or not depending
		 * on the state of NO_DISCONNECT.
		 */
		test	SEQ_FLAGS, NO_DISCONNECT jz target_disconnect; 
		if ((ahc->flags & AHC_PAGESCBS) != 0) {
			mov	ALLZEROS	call	get_free_or_disc_scb;
		}
		mov	RETURN_1, ALLZEROS;
		call	complete_target_cmd;
		cmp	RETURN_1, CONT_MSG_LOOP jne .;
		mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
		mov	SCB_TAG	 call dma_scb;
		jmp	target_synccmd;

target_mesgout:
		mvi	SCSISIGO, P_MESGOUT|BSYO;
		call	target_inb;
		/* Local Processing goes here... */
target_mesgout_pending_msg:
		jmp	host_target_message_loop;
		
target_disconnect:
		mvi	P_MESGIN|BSYO call change_phase;
		test	SEQ_FLAGS, DPHASE	jz . + 2;
		mvi	MSG_SAVEDATAPOINTER call target_outb;
		mvi	MSG_DISCONNECT call target_outb;

target_busfree_wait:
		/* Wait for preceeding I/O session to complete. */
		test	SCSISIGI, ACKI jnz .;
target_busfree:
		clr	SCSISIGO;
		mvi	LASTPHASE, P_BUSFREE;
		call	complete_target_cmd;
		jmp	poll_for_work;

target_cmdphase:
		mvi	P_COMMAND|BSYO call change_phase;
		call	target_inb;
		mov	A, DINDEX;
		/* Store for host */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, A;
		} else {
			mov	DFDAT, A;
		}

		/*
		 * Determine the number of bytes to read
		 * based on the command group code via table lookup.
		 * We reuse the first 8 bytes of the TARG_SCSIRATE
		 * BIOS array for this table. Count is one less than
		 * the total for the command since we've already fetched
		 * the first byte.
		 */
		shr	A, CMD_GROUP_CODE_SHIFT;
		add	SINDEX, TARG_SCSIRATE, A;
		mov	A, SINDIR;

		test	A, 0xFF jz command_phase_done;
command_loop:
		or	SXFRCTL0, SPIOEN;
		test	SSTAT0, SPIORDY jz .;
		cmp	A, 1 jne . + 2;
		and	SXFRCTL0, ~SPIOEN;	/* Last Byte */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SCSIDATL;
		} else {
			mov	DFDAT, SCSIDATL;
		}
		dec	A;
		test	A, 0xFF jnz command_loop;

command_phase_done:
		and	SEQ_FLAGS, ~CMDPHASE_PENDING;
		jmp	target_ITloop;

target_dphase:
		/*
		 * Data direction flags are from the
		 * perspective of the initiator.
		 */
		test	SCB_TARGET_PHASES[1], TARGET_DATA_IN jz . + 4;
		mvi	LASTPHASE, P_DATAOUT;
		mvi	P_DATAIN|BSYO call change_phase;
		jmp	. + 3;
		mvi	LASTPHASE, P_DATAIN;
		mvi	P_DATAOUT|BSYO call change_phase;
		mov	ALLZEROS call initialize_channel;
		jmp	p_data;

target_sphase:
		mvi	P_STATUS|BSYO call change_phase;
		mvi	LASTPHASE, P_STATUS;
		mov	SCB_TARGET_STATUS call target_outb;
		/* XXX Watch for ATN or parity errors??? */
		mvi	SCSISIGO, P_MESGIN|BSYO;
		/* MSG_CMDCMPLT is 0, but we can't do an immediate of 0 */
		mov	ALLZEROS call target_outb;
		jmp	target_busfree_wait;
	
complete_target_cmd:
		test	SEQ_FLAGS, TARG_CMD_PENDING	jnz . + 2;
		mov	SCB_TAG jmp complete_post;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			/* Set the valid byte */
			mvi	CCSCBADDR, 24;
			mov	CCSCBRAM, ALLONES;
			mvi	CCHCNT, 28;
			or	CCSCBCTL, CCSCBEN|CCSCBRESET;
			test	CCSCBCTL, CCSCBDONE jz .;
			clr	CCSCBCTL;
		} else {
			/* Set the valid byte */
			or	DFCNTRL, FIFORESET;
			mvi	DFWADDR, 3; /* Third 64bit word or byte 24 */
			mov	DFDAT, ALLONES;
			mvi	HCNT[0], 28;
			clr	HCNT[1];
			clr	HCNT[2];
			or	DFCNTRL, HDMAEN|FIFOFLUSH;
			call	dma_finish;
		}
		inc	TQINPOS;
		mvi	INTSTAT,CMDCMPLT ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
initiator_select:
	mvi	SPIOEN call	initialize_channel;
d266 30
a295 20
	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;

	/*
	 * As soon as we get a successful selection, the target
	 * should go into the message out phase since we have ATN
	 * asserted.
	 */
	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
	or	SEQ_FLAGS, IDENTIFY_SEEN;

	/*
	 * Main loop for information transfer phases.  Wait for the
	 * target to assert REQ before checking MSG, C/D and I/O for
	 * the bus phase.
	 */
d297 2
a298 1
	call	phase_lock;
d300 20
a319 42
	mov	A, LASTPHASE;

	test	A, ~P_DATAIN	jz p_data;
	cmp	A,P_COMMAND	je p_command;
	cmp	A,P_MESGOUT	je p_mesgout;
	cmp	A,P_STATUS	je p_status;
	cmp	A,P_MESGIN	je p_mesgin;

	mvi	INTSTAT,BAD_PHASE;
	jmp	ITloop;			/* Try reading the bus again. */

await_busfree:
	and	SIMODE1, ~ENBUSFREE;
	mov	NONE, SCSIDATL;		/* Ack the last byte */
	and	SXFRCTL0, ~SPIOEN;
	test	SSTAT1,REQINIT|BUSFREE	jz .;
	test	SSTAT1, BUSFREE jnz poll_for_work;
	mvi	INTSTAT, BAD_PHASE;
}
	
clear_target_state:
	/*
	 * We assume that the kernel driver may reset us
	 * at any time, even in the middle of a DMA, so
	 * clear DFCNTRL too.
	 */
	clr	DFCNTRL;

	/*
	 * We don't know the target we will connect to,
	 * so default to narrow transfers to avoid
	 * parity problems.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, ALLZEROS, 2;
	} else {
		clr	SCSIRATE;
		and	SXFRCTL0, ~(FAST20);
	}
	mvi	LASTPHASE, P_BUSFREE;
	/* clear target specific flags */
	clr	SEQ_FLAGS ret;
d326 9
a334 28
	if ((ahc->features & AHC_ULTRA2) != 0) {
		/*
		 * The preload circuitry requires us to
		 * reload the address too, so pull it from
		 * the shaddow address.
		 */
		bmov	HADDR, SHADDR, 4;
		bmov	HCNT, SCB_RESID_DCNT, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, SCB_RESID_DCNT, 3;
	} else {
		mvi	DINDEX, STCNT;
		mvi	SCB_RESID_DCNT	call bcopy_3;
	}
	and	DATA_COUNT_ODD, 0x1, SCB_RESID_DCNT[0];
	jmp	data_phase_loop;

p_data:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mvi	DMAPARAMS, PRELOADEN|SCSIEN|HDMAEN;
	} else {
		mvi	DMAPARAMS, WIDEODD|SCSIEN|SDMAEN|HDMAEN|FIFORESET;
	}
	test	LASTPHASE, IOI jnz . + 2;
	or	DMAPARAMS, DIRECTION;
	call	assert;			/*
					 * Ensure entering a data
					 * phase is okay - seen identify, etc.
d336 2
a337 4
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	CCSGADDR, CCSGADDR_MAX;
	}
	test	SEQ_FLAGS, DPHASE	jnz data_phase_reinit;
d339 3
a341 31
	/* We have seen a data phase */
	or	SEQ_FLAGS, DPHASE;

	/*
	 * Initialize the DMA address and counter from the SCB.
	 * Also set SG_COUNT and SG_NEXT in memory since we cannot
	 * modify the values in the SCB itself until we see a
	 * save data pointers message.
	 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	HADDR, SCB_DATAPTR, 7;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_DATAPTR	call bcopy_7;
	}
	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} else {
			call	set_stcnt_from_hcnt;
		}
	}

	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SG_COUNT, SCB_SGCOUNT, 5;
	} else {
		mvi	DINDEX, SG_COUNT;
		mvi	SCB_SGCOUNT	call bcopy_5;
	}
d345 1
a345 1
	test	SG_COUNT, 0xff jnz data_phase_inbounds;
d352 5
a356 11
	or	SXFRCTL1,BITBUCKET;
	and	DMAPARAMS, ~(HDMAEN|SDMAEN);
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT, ALLONES, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, ALLONES, 3;
	} else {
		mvi	STCNT[0], 0xFF;
		mvi	STCNT[1], 0xFF;
		mvi	STCNT[2], 0xFF;
	}
d358 3
a360 11
/* If we are the last SG block, tell the hardware. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		or	SG_CACHEPTR, LAST_SEG;
	} else {
		if ((ahc->flags & AHC_TARGETMODE) != 0) {
			test	SSTAT0, TARGET jz . + 2;
			test	DMAPARAMS, DIRECTION jz data_phase_wideodd;
		}
		and	DMAPARAMS, ~WIDEODD;
	}
d362 1
a362 10
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SINDEX, ALLONES;
		mov	DFCNTRL, DMAPARAMS;
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
data_phase_dma_loop:
		test	SSTAT0,	SDONE jnz data_phase_dma_done;
		test	SSTAT1,PHASEMIS	jz data_phase_dma_loop;	/* ie. underrun */
	} else {
		mov	DMAPARAMS  call dma;
	}
a363 1
data_phase_dma_done:
d365 1
a365 1
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun;
d367 2
a368 4
/* See if we completed this segment */
	test	STCNT[0], 0xff	jnz data_phase_finish;
	test	STCNT[1], 0xff	jnz data_phase_finish;
	test	STCNT[2], 0xff	jnz data_phase_finish;
d374 7
a380 1
	dec	SG_COUNT;	/* one less segment to go */
a381 1
	test	SG_COUNT, 0xff	jz data_phase_finish; /* Are we done? */
d390 65
a454 74
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/*
		 * Do we have any prefetch left???
		 */
		cmp	CCSGADDR, CCSGADDR_MAX jne prefetched_segs_avail;

		/*
		 * Fetch MIN(CCSGADDR_MAX, (SG_COUNT * 8)) bytes.
		 */
		add	A, -(CCSGRAM_MAXSEGS + 1), SG_COUNT;
		mvi	A, CCSGADDR_MAX;
		jc	. + 2;
		shl	A, 3, SG_COUNT;
		mov	CCHCNT, A;
		bmov	CCHADDR, SG_NEXT, 4;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		and	CCSGCTL, ~CCSGEN;
		test	CCSGCTL, CCSGEN jnz .;
		mvi	CCSGCTL, CCSGRESET;
prefetched_segs_avail:
		bmov 	HADDR, CCSGRAM, 8;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SG_NEXT	call bcopy_4;

		mvi	HCNT[0],SG_SIZEOF;
		clr	HCNT[1];
		clr	HCNT[2];

		or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

		call	dma_finish;

		/*
		 * Copy data from FIFO into SCB data pointer and data count.
		 * This assumes that the SG segments are of the form:
		 * struct ahc_dma_seg {
		 *	u_int32_t	addr;	four bytes, little-endian order
		 *	u_int32_t	len;	four bytes, little endian order
		 * };
		 */
		mvi	HADDR	call dfdat_in_7;
	}

	/* Track odd'ness */
	test	HCNT[0], 0x1 jz . + 2;
	xor	DATA_COUNT_ODD, 0x1;

	if ((ahc->features & AHC_ULTRA2) == 0) {
		/* Load STCNT as well.  It is a mirror of HCNT */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	STCNT, HCNT, 3;
		} else {
			call	set_stcnt_from_hcnt;
		}
	}

/* Advance the SG pointer */
	clr	A;			/* add sizeof(struct scatter) */
	add	SG_NEXT[0],SG_SIZEOF;
	adc	SG_NEXT[1],A;

	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_loop;
	}
	test	SSTAT1, REQINIT jz .;
	test	SSTAT1,PHASEMIS	jz data_phase_loop;

	/* Ensure the last seg is visable at the shaddow layer */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	DFCNTRL, DMAPARAMS;
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
	}
a456 3
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
	}
d462 5
a466 25
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, STCNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],STCNT[0];
		mov	SCB_RESID_DCNT[1],STCNT[1];
		mov	SCB_RESID_DCNT[2],STCNT[2];
	}
	mov	SCB_RESID_SGCNT, SG_COUNT;

	if ((ahc->features & AHC_ULTRA2) != 0) {
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}

	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SEQ_FLAGS, DPHASE_PENDING jz ITloop;
		and	SEQ_FLAGS, ~DPHASE_PENDING;
		/*
		 * For data-in phases, wait for any pending acks from the
		 * initiator before changing phase.
		 */
		test	DFCNTRL, DIRECTION jz target_ITloop;
		test	SSTAT1, REQINIT	jnz .;
		jmp	target_ITloop;
	}
	jmp	ITloop;
a468 4
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}
d472 3
a474 38
	and	SXFRCTL1, ~BITBUCKET;
	mvi	INTSTAT,DATA_OVERRUN;
	jmp	ITloop;

ultra2_dmafinish:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		test	DFCNTRL, DIRECTION jnz ultra2_dmafifoempty;
		and	DFCNTRL, ~SCSIEN;
		test	DFCNTRL, SCSIEN jnz .;
ultra2_dmafifoflush:
		or	DFCNTRL, FIFOFLUSH;
		/*
		 * The FIFOEMP status bit on the Ultra2 class
		 * of controllers seems to be a bit flaky.
		 * It appears that if the FIFO is full and the
		 * transfer ends with some data in the REQ/ACK
		 * FIFO, FIFOEMP will fall temporarily
		 * as the data is transferred to the PCI bus.
		 * This glitch lasts for fewer than 5 clock cycles,
		 * so we work around the problem by ensuring the
		 * status bit stays false through a full glitch
		 * window.
		 */
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;

ultra2_dmafifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_dmafifoempty;

ultra2_dmahalt:
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, HDMAEN jnz .;
		ret;
	}
a475 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d480 1
a480 1
	call	assert;
d482 18
a499 50
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mov	HCNT[0], SCB_CMDLEN;
		bmov	HCNT[1], ALLZEROS, 2;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			bmov	STCNT, HCNT, 3;
		}
		add	NONE, -17, SCB_CMDLEN;
		jc	dma_cmd_data;
		/*
		 * The data fifo seems to require 4 byte alligned
		 * transfers from the sequencer.  Force this to
		 * be the case by clearing HADDR[0] even though
		 * we aren't going to touch host memeory.
		 */
		bmov	HADDR[0], ALLZEROS, 1;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
		} else {
			mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
		}
		bmov   DFDAT, SCB_CMDSTORE, 16; 
		jmp	cmd_loop;
dma_cmd_data:
		bmov	HADDR, SCB_CMDPTR, 4;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_CMDPTR	call bcopy_5;
		clr	HCNT[1];
		clr	HCNT[2];
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) == 0) {
			call	set_stcnt_from_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	} else {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	}
cmd_loop:
	test	SSTAT0, SDONE jnz . + 2;
	test    SSTAT1, PHASEMIS jz cmd_loop;
	/*
	 * Wait for our ACK to go-away on it's own
	 * instead of being killed by SCSIEN getting cleared.
	 */
	test	SCSISIGI, ACKI jnz .;
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz .;
	jmp	ITloop;
d506 2
a507 1
	call	assert;
d509 7
a515 2
	mov	SCB_TARGET_STATUS, SCSIDATL;
	jmp	ITloop;
d517 1
d519 2
a520 22
 * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full
 * indentify message sequence and send it to the target.  The host may
 * override this behavior by setting the MK_MESSAGE bit in the SCB
 * control byte.  This will cause us to interrupt the host and allow
 * it to handle the message phase completely on its own.  If the bit
 * associated with this target is set, we will also interrupt the host,
 * thereby allowing it to send a message on the next selection regardless
 * of the transaction being sent.
 * 
 * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.
 * This is done to allow the host to send messages outside of an identify
 * sequence while protecting the seqencer from testing the MK_MESSAGE bit
 * on an SCB that might not be for the current nexus. (For example, a
 * BDR message in responce to a bad reselection would leave us pointed to
 * an SCB that doesn't have anything to do with the current target).
 *
 * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
 * bus device reset).
 *
 * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,
 * in case the target decides to put us in this phase for some strange
 * reason.
d522 3
a524 36
p_mesgout_retry:
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATN for the retry */
p_mesgout:
	mov	SINDEX, MSG_OUT;
	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
	mov	FUNCTION1, SCB_TCL;
	mov	A, FUNCTION1;
	if ((ahc->features & AHC_HS_MAILBOX) != 0) {
		/*
		 * Work around a pausing bug in at least the aic7890.
		 * If the host needs to update the TARGET_MSG_REQUEST
		 * bit field, it will set the HS_MAILBOX to 1.  In
		 * response, we pause with a specific interrupt code
		 * asking for the mask to be updated before we continue.
		 * Ugh.
		 */
		test	HS_MAILBOX, 0xF0	jz . + 2;
		mvi	INTSTAT, UPDATE_TMSG_REQ;
		nop;
	}
	mov	SINDEX, TARGET_MSG_REQUEST[0];
	if ((ahc->features & AHC_TWIN) != 0) {
		/* Second Channel uses high byte bits */
		test	SCB_TCL, SELBUSB	jz . + 2;
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	} else if ((ahc->features & AHC_WIDE) != 0) {
		test	SCB_TCL, 0x80		jz . + 2; /* target > 7 */
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	}
	test	SINDEX, A	jnz host_message_loop;
p_mesgout_identify:
	and	SINDEX,LID,SCB_TCL;	/* lun */
	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privledge */
	or	SINDEX,A;		/* or in disconnect privledge */
	or	SINDEX,MSG_IDENTIFYFLAG;
d526 5
a530 2
 * Send a tag message if TAG_ENB is set in the SCB control block.
 * Use SCB_TAG (the position in the kernel's SCB array) as the tag value.
d532 13
a544 20
p_mesgout_tag:
	test	SCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;
	mov	SCSIDATL, SINDEX;	/* Send the identify message */
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
	and	SCSIDATL,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
	mov	SCB_TAG	jmp p_mesgout_onebyte;
/*
 * Interrupt the driver, and allow it to handle this message
 * phase and any required retries.
 */
p_mesgout_from_host:
	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
	jmp	host_message_loop;

p_mesgout_onebyte:
	mvi	CLRSINT1, CLRATNO;
	mov	SCSIDATL, SINDEX;
d547 1
a547 1
 * If the next bus phase after ATN drops is message out, it means
d550 3
a552 2
	call	phase_lock;
	cmp	LASTPHASE, P_MESGOUT	je p_mesgout_retry;
d554 8
d563 2
a564 4
	mvi	CLRSINT1,CLRATNO;	/* Be sure to turn ATNO off */
	mov	LAST_MSG, MSG_OUT;
	mvi	MSG_OUT, MSG_NOOP;	/* No message left */
	jmp	ITloop;
d570 2
a571 1
	mvi	ACCUM		call inb_first;	/* read the 1st message byte */
d573 21
a593 21
	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify;
	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs;
	cmp	ALLZEROS,A		je mesgin_complete;
	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs;
	cmp	A,MSG_NOOP		je mesgin_done;

/*
 * Pushed message loop to allow the kernel to
 * run it's own message state engine.  To avoid an
 * extra nop instruction after signaling the kernel,
 * we perform the phase_lock before checking to see
 * if we should exit the loop and skip the phase_lock
 * in the ITloop.  Performing back to back phase_locks
 * shouldn't hurt, but why do it twice...
 */
host_message_loop:
	mvi	INTSTAT, HOST_MSG_LOOP;
	call	phase_lock;
	cmp	RETURN_1, EXIT_MSG_LOOP	je ITloop + 1;
	jmp	host_message_loop;
d596 2
a597 2
	mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
	jmp	ITloop;
d602 16
a617 15
 * We got a "command complete" message, so put the SCB_TAG into the QOUTFIFO,
 * and trigger a completion interrupt.  Before doing so, check to see if there
 * is a residual or the status byte is something other than STATUS_GOOD (0).
 * In either of these conditions, we upload the SCB back to the host so it can
 * process this information.  In the case of a non zero status byte, we 
 * additionally interrupt the kernel driver synchronously, allowing it to
 * decide if sense should be retrieved.  If the kernel driver wishes to request
 * sense, it will fill the kernel SCB with a request sense command and set
 * RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE we redownload
 * the SCB, and process it as the next command by adding it to the waiting list.
 * If the kernel driver does not wish to request sense, it need only clear
 * RETURN_1, and the command is allowed to complete normally.  We don't bother
 * to post to the QOUTFIFO in the error cases since it would require extra
 * work in the kernel driver to ensure that the entry was removed before the
 * command complete code tried processing it.
d619 1
a619 1

d621 6
a626 1
 * First check for residuals
d628 3
a630 5
	test	SCB_RESID_SGCNT,0xff	jnz upload_scb;
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Good Status? */
upload_scb:
	mvi	DMAPARAMS, FIFORESET;
	mov	SCB_TAG		call dma_scb;
d632 35
a666 16
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Just a residual? */
	mvi	INTSTAT,BAD_STATUS;			/* let driver know */
	nop;
	cmp	RETURN_1, SEND_SENSE	jne complete;
	/* This SCB becomes the next to execute as it will retrieve sense */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	SCB_TAG		call dma_scb;
add_to_waiting_list:
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
	/*
	 * Prepare our selection hardware before the busfree so we have a
	 * high probability of winning arbitration.
	 */
	call	start_selection;
	jmp	await_busfree;
d668 35
a702 28
complete:
	/* If we are untagged, clear our address up in host ram */
	test	SCB_CONTROL, TAG_ENB jnz complete_queue;
	mov	A, SAVED_TCL;
	/* fvdl - let ahc_intr clear this to avoid race conditions */
	/* mvi	UNTAGGEDSCB_OFFSET call post_byte_setup; */
	/* mvi	SCB_LIST_NULL call post_byte; */

complete_queue:
	mov	SCB_TAG call complete_post;
	jmp	await_busfree;
}

complete_post:
	/* Post the SCBID in SINDEX and issue an interrupt */
	call	add_scb_to_free_list;
	mov	ARG_1, SINDEX;
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		mov	A, SDSCB_QOFF;
	} else {
		mov	A, QOUTPOS;
	}
	mvi	QOUTFIFO_OFFSET call post_byte_setup;
	mov	ARG_1 call post_byte;
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		inc 	QOUTPOS;
	}
	mvi	INTSTAT,CMDCMPLT ret;
a703 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d709 18
a726 3
	or	SCB_CONTROL,DISCONNECTED;
	call	add_scb_to_disc_list;
	jmp	await_busfree;
d729 2
a730 5
 * Save data pointers message:
 * Copying RAM values back to SCB, for Save Data Pointers message, but
 * only if we've actually been into a data phase to change them.  This
 * protects against bogus data in scratch ram and the residual counts
 * since they are only initialized when we go into data_in or data_out.
d733 2
a734 21
	test	SEQ_FLAGS, DPHASE	jz mesgin_done;

	/*
	 * The SCB SGPTR becomes the next one we'll download,
	 * and the SCB DATAPTR becomes the current SHADDR.
	 * Use the residual number since STCNT is corrupted by
	 * any message transfer.
	 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_SGCOUNT, SG_COUNT, 5;
		bmov	SCB_DATAPTR, SHADDR, 4;
		bmov	SCB_DATACNT, SCB_RESID_DCNT, 3;
	} else {
		mvi	DINDEX, SCB_SGCOUNT;
		mvi	SG_COUNT call bcopy_5;
	
		mvi	DINDEX, SCB_DATAPTR;
		mvi	SHADDR		call bcopy_4;
		mvi	SCB_RESID_DCNT	call bcopy_3;
	}
	jmp	mesgin_done;
d743 2
a744 2
	and	SEQ_FLAGS, ~DPHASE;		/*
						 * We'll reload them
a745 1
						 * the dataphase.
d747 1
a747 1
	jmp	mesgin_done;
d755 9
a763 21
	if ((ahc->features & AHC_WIDE) != 0) {
		and	A,0x0f;		/* lun in lower four bits */
	} else {
		and	A,0x07;		/* lun in lower three bits */
	}
	or      SAVED_TCL,A;		/* SAVED_TCL should be complete now */

	mvi	ARG_2, SCB_LIST_NULL;	/* SCBID of prev SCB in disc List */
	call	get_untagged_SCBID;
	cmp	ARG_1, SCB_LIST_NULL	je snoop_tag;
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		test	SEQ_FLAGS, SCBPTR_VALID	jz use_retrieveSCB;
	}
	/*
	 * If the SCB was found in the disconnected list (as is
	 * always the case in non-paging scenarios), SCBPTR is already
	 * set to the correct SCB.  So, simply setup the SCB and get
	 * on with things.
	 */
	call	rem_scb_from_disc_list;
	jmp	setup_SCB;
d766 2
a767 2
 * If we get one, we use the tag returned to find the proper
 * SCB.  With SCB paging, this requires using search for both tagged
d772 1
a772 2
snoop_tag:
	mov	NONE,SCSIDATL;		/* ACK Identify MSG */
d774 5
a778 3
	call	phase_lock;
	cmp	LASTPHASE, P_MESGIN	jne not_found;
	cmp	SCSIBUSL,MSG_SIMPLE_Q_TAG jne not_found;
d780 9
a788 1
	mvi	ARG_1	call inb_next;	/* tag value */
d790 8
a797 6
	/*
	 * Ensure that the SCB the tag points to is for
	 * an SCB transaction to the reconnecting target.
	 */
use_retrieveSCB:
	call	retrieveSCB;
d799 26
a824 20
	mov	A, SAVED_TCL;
	cmp	SCB_TCL, A	jne not_found_cleanup_scb;
	test	SCB_CONTROL,DISCONNECTED jz not_found_cleanup_scb;
	and	SCB_CONTROL,~DISCONNECTED;
	or	SEQ_FLAGS,IDENTIFY_SEEN;	/* make note of IDENTIFY */
	call	set_transfer_settings;
	/* See if the host wants to send a message upon reconnection */
	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
	and	SCB_CONTROL, ~MK_MESSAGE;
	mvi	HOST_MSG	call mk_mesg;
	jmp	mesgin_done;

not_found_cleanup_scb:
	test	SCB_CONTROL, DISCONNECTED jz . + 3;
	call	add_scb_to_disc_list;
	jmp	not_found;
	call	add_scb_to_free_list;
not_found:
	mvi	INTSTAT, NO_MATCH;
	jmp	mesgin_done;
d831 16
d851 16
a866 2
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATNO */
	mov	MSG_OUT,SINDEX ret;
d883 1
a883 3
inb_next_wait_perr:
	mvi	INTSTAT, PERR_DETECTED;
	jmp	inb_next_wait;
d885 2
a886 1
	mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
d888 2
a889 10
	/*
	 * If there is a parity error, wait for the kernel to
	 * see the interrupt and prepare our message response
	 * before continuing.
	 */
	test	SSTAT1, REQINIT	jz inb_next_wait;
	test	SSTAT1, SCSIPERR jnz inb_next_wait_perr;
inb_next_check_phase:
	and	LASTPHASE, PHASE_MASK, SCSISIGI;
	cmp	LASTPHASE, P_MESGIN jne mesgin_phasemis;
d891 3
a893 2
	mov	DINDEX,SINDEX;
	mov	DINDIR,SCSIBUSL	ret;		/*read byte directly from bus*/
d895 1
a895 2
	mov	NONE,SCSIDATL ret;		/*dummy read from latch to ACK*/
}
a896 40
if ((ahc->flags & AHC_TARGETMODE) != 0) {
/*
 * Change to a new phase.  If we are changing the state of the I/O signal,
 * from out to in, wait an additional data release delay before continuing.
 */
change_phase:
	/* Wait for preceeding I/O session to complete. */
	test	SCSISIGI, ACKI jnz .;

	/* Change the phase */
	and	DINDEX, IOI, SCSISIGI;
	mov	SCSISIGO, SINDEX;
	and	A, IOI, SINDEX;

	/*
	 * If the data direction has changed, from
	 * out (initiator driving) to in (target driving),
	 * we must waitat least a data release delay plus
	 * the normal bus settle delay. [SCSI III SPI 10.11.0]
	 */
	cmp 	DINDEX, A je change_phase_wait;
	test	SINDEX, IOI jz change_phase_wait;
	call	change_phase_wait;
change_phase_wait:
	nop;
	nop;
	nop;
	nop ret;

/*
 * Send a byte to an initiator in Automatic PIO mode.
 */
target_outb:
	or	SXFRCTL0, SPIOEN;
	test	SSTAT0, SPIORDY	jz .;
	mov	SCSIDATL, SINDEX;
	test	SSTAT0, SPIORDY	jz .;
	and	SXFRCTL0, ~SPIOEN ret;
}
	
d901 2
a902 2
	mvi	INTSTAT, MSGIN_PHASEMIS;
	jmp	ITloop;
d911 4
a914 5
	mov	DFCNTRL,SINDEX;
dma_loop:
	test	SSTAT0,DMADONE	jnz dma_dmadone;
	test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
dma_phasemis:
d924 5
a928 8
dma_checkfifo:
	test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
dma_fifoflush:
	test	DFSTATUS,FIFOEMP	jz dma_fifoflush;

dma_fifoempty:
	/* Don't clobber an inprogress host data transfer */
	test	DFSTATUS, MREQPEND	jnz dma_fifoempty;
d933 5
a937 14
dma_dmadone:
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
	/*
	 * Some revisions of the aic7880 have a problem where, if the
	 * data fifo is full, but the PCI input latch is not empty, 
	 * HDMAEN cannot be cleared.  The fix used here is to attempt
	 * to drain the data fifo until there is space for the input
	 * latch to drain and HDMAEN de-asserts.
	 */
	if ((ahc->features & AHC_ULTRA2) == 0) {
		mov	NONE, DFDAT;
	}
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;
d939 12
a950 1
	ret;
d957 2
a958 1
	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz return;	/* seen IDENTIFY? */
d960 1
a960 1
	mvi	INTSTAT,NO_IDENT 	ret;	/* no - tell the kernel */
d963 5
a967 5
 * Locate a disconnected SCB either by SAVED_TCL (ARG_1 is SCB_LIST_NULL)
 * or by the SCBID ARG_1.  The search begins at the SCB index passed in
 * via SINDEX which is an SCB that must be on the disconnected list.  If
 * the SCB cannot be found, SINDEX will be SCB_LIST_NULL, otherwise, SCBPTR
 * is set to the proper SCB.
d970 13
a982 37
	mov	SCBPTR,SINDEX;			/* Initialize SCBPTR */
	cmp	ARG_1, SCB_LIST_NULL	jne findSCB_by_SCBID;
	mov	A, SAVED_TCL;
	mvi	SCB_TCL	jmp findSCB_loop;	/* &SCB_TCL -> SINDEX */
findSCB_by_SCBID:
	mov	A, ARG_1;			/* Tag passed in ARG_1 */
	mvi	SCB_TAG	jmp findSCB_loop;	/* &SCB_TAG -> SINDEX */
findSCB_next:
	mov	ARG_2, SCBPTR;
	cmp	SCB_NEXT, SCB_LIST_NULL je notFound;
	mov	SCBPTR,SCB_NEXT;
	dec	SINDEX;		/* Last comparison moved us too far */
findSCB_loop:
	cmp	SINDIR, A	jne findSCB_next;
	mov	SINDEX, SCBPTR 	ret;
notFound:
	mvi	SINDEX, SCB_LIST_NULL	ret;

/*
 * Retrieve an SCB by SCBID first searching the disconnected list falling
 * back to DMA'ing the SCB down from the host.  This routine assumes that
 * ARG_1 is the SCBID of interrest and that SINDEX is the position in the
 * disconnected list to start the search from.  If SINDEX is SCB_LIST_NULL,
 * we go directly to the host for the SCB.
 */
retrieveSCB:
	test	SEQ_FLAGS, SCBPTR_VALID	jz retrieve_from_host;
	mov	SCBPTR	call findSCB;	/* Continue the search */
	cmp	SINDEX, SCB_LIST_NULL	je retrieve_from_host;

/*
 * This routine expects SINDEX to contain the index of the SCB to be
 * removed, SCBPTR to be pointing to that SCB, and ARG_2 to be the
 * SCBID of the SCB just previous to this one in the list or SCB_LIST_NULL
 * if it is at the head.
 */
rem_scb_from_disc_list:
d984 12
a995 5
	cmp	ARG_2, SCB_LIST_NULL	je rHead;
	mov	DINDEX, SCB_NEXT;
	mov	SCBPTR, ARG_2;
	mov	SCB_NEXT, DINDEX;
	mov	SCBPTR, SINDEX ret;
d997 42
a1038 1
	mov	DISCONNECTED_SCBH,SCB_NEXT ret;
a1039 1
retrieve_from_host:
d1041 4
a1044 2
 * We didn't find it.  Pull an SCB and DMA down the one we want.
 * We should never get here in the non-paging case.
d1046 13
a1058 231
	mov	ALLZEROS	call	get_free_or_disc_scb;
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	/* Jump instead of call as we want to return anyway */
	mov	ARG_1	jmp dma_scb;

/*
 * Determine whether a target is using tagged or non-tagged transactions
 * by first looking for a matching transaction based on the TCL and if
 * that fails, looking up this device in the host's untagged SCB array.
 * The TCL to search for is assumed to be in SAVED_TCL.  The value is
 * returned in ARG_1 (SCB_LIST_NULL for tagged, SCBID for non-tagged).
 * The SCBPTR_VALID bit is set in SEQ_FLAGS if we found the information
 * in an SCB instead of having to go to the host.
 */
get_untagged_SCBID:
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je get_SCBID_from_host;
	mvi	ARG_1, SCB_LIST_NULL;
	mov	DISCONNECTED_SCBH call findSCB;
	cmp	SINDEX, SCB_LIST_NULL	je get_SCBID_from_host;
	or	SEQ_FLAGS, SCBPTR_VALID;/* Was in disconnected list */
	test	SCB_CONTROL, TAG_ENB	jnz . + 2;
	mov	ARG_1, SCB_TAG	ret;
	mvi	ARG_1, SCB_LIST_NULL ret;

/*
 * Fetch a byte from host memory given an index of (A + (256 * SINDEX))
 * and a base address of SCBID_ADDR.  The byte is returned in RETURN_2.
 */
fetch_byte:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		mvi	CCSGCTL, CCSGRESET;
		bmov	RETURN_2, CCSGRAM, 1 ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
		mvi	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;
		call	dma_finish;
		mov	RETURN_2, DFDAT ret;
	}

/*
 * Prepare the hardware to post a byte to host memory given an
 * index of (A + (256 * SINDEX)) and a base address of SCBID_ADDR.
 */
post_byte_setup:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SCBID_ADDR call	set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSCBCTL, CCSCBRESET ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCBID_ADDR call	set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
		mvi	DFCNTRL, FIFORESET ret;
	}

post_byte:
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	CCSCBRAM, SINDEX, 1;
		or	CCSCBCTL, CCSCBEN|CCSCBRESET;
		test	CCSCBCTL, CCSCBDONE jz .;
		clr	CCSCBCTL ret;
	} else {
		mov	DFDAT, SINDEX;
		or	DFCNTRL, HDMAEN|FIFOFLUSH;
		jmp	dma_finish;
	}

get_SCBID_from_host:
	mov	A, SAVED_TCL;
	mvi	UNTAGGEDSCB_OFFSET call fetch_byte;
	mov	RETURN_1,  RETURN_2 ret;

phase_lock_perr:
	mvi	INTSTAT, PERR_DETECTED;
phase_lock:     
	/*
	 * If there is a parity error, wait for the kernel to
	 * see the interrupt and prepare our message response
	 * before continuing.
	 */
	test	SSTAT1, REQINIT jz phase_lock;
	test	SSTAT1, SCSIPERR jnz phase_lock_perr;
phase_lock_latch_phase:
	and	SCSISIGO, PHASE_MASK, SCSISIGI;
	and	LASTPHASE, PHASE_MASK, SCSISIGI ret;

if ((ahc->features & AHC_CMD_CHAN) == 0) {
set_stcnt_from_hcnt:
	mov	STCNT[0], HCNT[0];
	mov	STCNT[1], HCNT[1];
	mov	STCNT[2], HCNT[2] ret;

bcopy_7:
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR;
bcopy_5:
	mov	DINDIR, SINDIR;
bcopy_4:
	mov	DINDIR, SINDIR;
bcopy_3:
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR;
	mov	DINDIR, SINDIR ret;
}

if ((ahc->flags & AHC_TARGETMODE) != 0) {
/*
 * Setup addr assuming that A is an index into
 * an array of 32byte objects, SINDEX contains
 * the base address of that array, and DINDEX
 * contains the base address of the location
 * to store the indexed address.
 */
set_32byte_addr:
	shr	ARG_2, 3, A;
	shl	A, 5;
	jmp	set_1byte_addr;
}

/*
 * Setup addr assuming that A is an index into
 * an array of 64byte objects, SINDEX contains
 * the base address of that array, and DINDEX
 * contains the base address of the location
 * to store the indexed address.
 */
set_64byte_addr:
	shr	ARG_2, 2, A;
	shl	A, 6;

/*
 * Setup addr assuming that A + (ARG_1 * 256) is an
 * index into an array of 1byte objects, SINDEX contains
 * the base address of that array, and DINDEX contains
 * the base address of the location to store the computed
 * address.
 */
set_1byte_addr:
	add     DINDIR, A, SINDIR;
	mov     A, ARG_2;
	adc	DINDIR, A, SINDIR;
	clr	A;
	adc	DINDIR, A, SINDIR;
	adc	DINDIR, A, SINDIR ret;

/*
 * Either post or fetch and SCB from host memory based on the
 * DIRECTION bit in DMAPARAMS. The host SCB index is in SINDEX.
 */
dma_scb:
	mov	A, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	HSCB_ADDR call set_64byte_addr;
		mov	CCSCBPTR, SCBPTR;
		test	DMAPARAMS, DIRECTION jz dma_scb_tohost;
		mvi	CCHCNT, SCB_64BYTE_SIZE;
		mvi	CCSCBCTL, CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET;
		cmp	CCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN|CCSCBDIR jne .;
		jmp	dma_scb_finish;
dma_scb_tohost:
		mvi	CCHCNT, SCB_32BYTE_SIZE;
		if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
			mvi	CCSCBCTL, CCSCBRESET;
			bmov	CCSCBRAM, SCB_CONTROL, SCB_32BYTE_SIZE;
			or	CCSCBCTL, CCSCBEN|CCSCBRESET;
			test	CCSCBCTL, CCSCBDONE jz .;
		} else {
			mvi	CCSCBCTL, CCARREN|CCSCBEN|CCSCBRESET;
			cmp	CCSCBCTL, CCSCBDONE|ARRDONE|CCARREN|CCSCBEN jne .;
		}
dma_scb_finish:
		clr	CCSCBCTL;
		test	CCSCBCTL, CCARREN|CCSCBEN jnz .;
		ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	HSCB_ADDR call set_64byte_addr;
		mvi	HCNT[0], SCB_32BYTE_SIZE;
		clr	HCNT[1];
		clr	HCNT[2];
		mov	DFCNTRL, DMAPARAMS;
		test	DMAPARAMS, DIRECTION	jnz dma_scb_fromhost;
		/* Fill it with the SCB data */
copy_scb_tofifo:
		mvi	SINDEX, SCB_CONTROL;
		add	A, SCB_32BYTE_SIZE, SINDEX;
copy_scb_tofifo_loop:
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		cmp	SINDEX, A jne copy_scb_tofifo_loop;
		or	DFCNTRL, HDMAEN|FIFOFLUSH;
dma_scb_fromhost:
		call	dma_finish;
		/* If we were putting the SCB, we are done */
		test	DMAPARAMS, DIRECTION	jz	return;
		mvi	SCB_CONTROL  call dfdat_in_7;
		call	dfdat_in_7_continued;
		call	dfdat_in_7_continued;
		jmp	dfdat_in_7_continued;
dfdat_in_7:
		mov     DINDEX,SINDEX;
dfdat_in_7_continued:
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT;
		mov	DINDIR,DFDAT ret;
	}

d1061 1
a1061 2
 * Wait for DMA from host memory to data FIFO to complete, then disable
 * DMA and wait for it to acknowledge that it's off.
d1063 3
a1065 33
dma_finish:
	test	DFSTATUS,HDONE	jz dma_finish;
	/* Turn off DMA */
	and	DFCNTRL, ~HDMAEN;
	test	DFCNTRL, HDMAEN jnz .;
	ret;

add_scb_to_free_list:
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mov	SCB_NEXT, FREE_SCBH;
		mvi	SCB_TAG, SCB_LIST_NULL;
		mov	FREE_SCBH, SCBPTR ret;
	} else {
		mvi	SCB_TAG, SCB_LIST_NULL ret;
	}

if ((ahc->flags & AHC_PAGESCBS) != 0) {
get_free_or_disc_scb:
	cmp	FREE_SCBH, SCB_LIST_NULL jne dequeue_free_scb;
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL jne dequeue_disc_scb;
return_error:
	mvi	SINDEX, SCB_LIST_NULL	ret;
dequeue_disc_scb:
	mov	SCBPTR, DISCONNECTED_SCBH;
dma_up_scb:
	mvi	DMAPARAMS, FIFORESET;
	mov	SCB_TAG		call dma_scb;
unlink_disc_scb:
	mov	DISCONNECTED_SCBH, SCB_NEXT ret;
dequeue_free_scb:
	mov	SCBPTR, FREE_SCBH;
	mov	FREE_SCBH, SCB_NEXT ret;
}
a1066 1
add_scb_to_disc_list:
d1068 3
a1070 3
 * Link this SCB into the DISCONNECTED list.  This list holds the
 * candidates for paging out an SCB if one is needed for a new command.
 * Modifying the disconnected list is a critical(pause dissabled) section.
d1072 6
a1077 2
	mov	SCB_NEXT, DISCONNECTED_SCBH;
	mov	DISCONNECTED_SCBH, SCBPTR ret;
@


1.6.14.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d81 1
a81 1
	test	SCSISEQ, ENSELO	jnz poll_for_work_loop;
a361 3
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			and	A, HOST_TQINPOS, HS_MAILBOX;
		} else {
a362 1
		}
d430 1
a430 2
	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
/*and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;*/
@


1.6.14.3
log
@Merge in trunk
@
text
@a0 1
/* $OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d17 1
a17 1
 * GNU Public License ("GPL").
d31 1
a31 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $
a33 2
VERSION = "$Id$"

d36 3
d58 12
a69 7
bus_free_sel:
        /*
         * Turn off the selection hardware.  We need to reset the
         * selection request in order to perform a new selection.
         */
        and     SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
        and     SIMODE1, ~ENBUSFREE;
d73 2
a74 7
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;
        }
        test    SCSISEQ, ENSELO jnz poll_for_selection;
        if ((ahc->features & AHC_TWIN) != 0) {
                xor     SBLKCTL,SELBUSB;        /* Toggle to the other bus */
                test    SCSISEQ, ENSELO         jnz poll_for_selection;
a75 1
        cmp     WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d77 5
d83 6
d90 5
a94 2
        }
        test    SSTAT0, SELDO|SELDI     jnz selection;
a96 1
BEGIN_CRITICAL
d99 2
d102 1
a102 1
                mov     A, QINPOS;
d104 2
a106 1
        mov     ARG_1, NEXT_QUEUED_SCB;
d108 6
a113 5
        /*
         * We have at least one queued SCB now and we don't have any 
         * SCBs in the list of SCBs awaiting selection.  Allocate a
         * card SCB for the host's SCB and get to work on it.
         */
d116 7
a122 1
        } else {
d124 1
a124 1
                mov     SCBPTR, ARG_1;
a125 2
        or      SEQ_FLAGS2, SCB_DMA;
END_CRITICAL
d127 3
a129 3
        /*
         * DMA the SCB from host ram into the current SCB location.
         */
d131 14
a144 13
        mov     ARG_1   call dma_scb;
        /*
         * Check one last time to see if this SCB was canceled
         * before we completed the DMA operation.  If it was,
         * the QINFIFO next pointer will not match our saved
         * value.
         */
        mov     A, ARG_1;
BEGIN_CRITICAL
        cmp     NEXT_QUEUED_SCB, A jne abort_qinscb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                cmp     SCB_TAG, A je . + 2;
                mvi     SCB_MISMATCH call set_seqint;
d146 7
a152 1
        mov     NEXT_QUEUED_SCB, SCB_NEXT;
a154 7
        if ((ahc->features & AHC_QUEUE_REGS) != 0) {
                mov     NONE, SNSCB_QOFF;
        } else {
                inc     QINPOS;
        }
        and     SEQ_FLAGS2, ~SCB_DMA;
END_CRITICAL
d157 1
a157 1
         * Start the first entry on the waiting SCB list.
d161 1
d163 52
a214 8
poll_for_selection:
        /*
         * Twin channel devices cannot handle things like SELTO
         * interrupts on the "background" channel.  So, while
         * selecting, keep polling the current channel until
         * either a selection or reselection occurs.
         */
        test    SSTAT0, SELDO|SELDI     jz poll_for_selection;
a216 15
        /*
         * We aren't expecting a bus free, so interrupt
         * the kernel driver if it happens.
         */
        mvi     CLRSINT1,CLRBUSFREE;
        if ((ahc->features & AHC_DT) == 0) {
                or      SIMODE1, ENBUSFREE;
        }

        /*
         * Guard against a bus free after (re)selection
         * but prior to enabling the busfree interrupt.  SELDI
         * and SELDO will be cleared in that case.
         */
        test    SSTAT0, SELDI|SELDO     jz bus_free_sel;
d218 1
d220 2
a221 2
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                if ((ahc->flags & AHC_INITIATORROLE) != 0) {
a223 1
                mvi     CLRSINT0, CLRSELDI;
d231 1
d242 1
a242 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d246 1
a246 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d251 7
a257 1
                and     SAVED_SCSIID, SELID_MASK, SELID;
d259 8
a266 14
                if ((ahc->features & AHC_MULTI_TID) != 0) {
                        and     A, OID, TARGIDIN;
                } else if ((ahc->features & AHC_ULTRA2) != 0) {
                        and     A, OID, SCSIID_ULTRA2;
                } else {
                        and     A, OID, SCSIID;
                }
                or      SAVED_SCSIID, A;
                if ((ahc->features & AHC_TWIN) != 0) {
                        test    SBLKCTL, SELBUSB jz . + 2;
                        or      SAVED_SCSIID, TWIN_CHNLB;
                }
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        mov     CCSCBRAM, SAVED_SCSIID;
d268 11
a278 2
                        mov     DFDAT, SAVED_SCSIID;
                }
a282 2
                 * XXX SCSI-1 may require us to assume lun 0 if
                 * ATN is false.
d297 1
a346 4
                or      SEQ_FLAGS, TARGET_CMD_IS_TAGGED;
                test    SCSISIGI, ATNI  jz . + 2;
                /* Initiator still wants to give us messages */
                call    target_inb;
d354 2
a355 1
                mvi     HOST_MSG_LOOP call set_seqint;
d365 1
a365 1
                        mov     A, KERNEL_TQINPOS;
d369 1
a369 1
                test    SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
d382 1
a382 1
                test    SCSISIGI, ATNI  jnz target_mesgout_pending;
d384 18
a401 1
        }
d403 1
a403 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d409 15
a423 94
        /* XXX test for and handle ONE BIT condition */
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
        and     SAVED_SCSIID, SELID_MASK, SELID;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                and     A, OID, SCSIID_ULTRA2;
        } else {
                and     A, OID, SCSIID;
        }
        or      SAVED_SCSIID, A;
        if ((ahc->features & AHC_TWIN) != 0) {
                test    SBLKCTL, SELBUSB        jz . + 2;
                or      SAVED_SCSIID, TWIN_CHNLB;
        }
        mvi     CLRSINT0, CLRSELDI;
        jmp     ITloop;
}

abort_qinscb:
        call    add_scb_to_free_list;
        jmp     poll_for_work_loop;

start_selection:
        /*
         * If bus reset interrupts have been disabled (from a previous
         * reset), re-enable them now.  Resets are only of interest
         * when we have outstanding transactions, so we can safely
         * defer re-enabling the interrupt until, as an initiator,
         * we start sending out transactions again.
         */
        test    SIMODE1, ENSCSIRST      jnz . + 3;
        mvi     CLRSINT1, CLRSCSIRSTI;
        or      SIMODE1, ENSCSIRST;
        if ((ahc->features & AHC_TWIN) != 0) {
                and     SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
                test    SCB_SCSIID, TWIN_CHNLB jz . + 2;
                or      SINDEX, SELBUSB;
                mov     SBLKCTL,SINDEX;         /* select channel */
        }
initialize_scsiid:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     SCSIID_ULTRA2, SCB_SCSIID;
        } else if ((ahc->features & AHC_TWIN) != 0) {
                and     SCSIID, TWIN_TID|OID, SCB_SCSIID;
        } else {
                mov     SCSIID, SCB_SCSIID;
        }
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                mov     SINDEX, SCSISEQ_TEMPLATE;
                test    SCB_CONTROL, TARGET_SCB jz . + 2;
                or      SINDEX, TEMODE;
                mov     SCSISEQ, SINDEX ret;
        } else {
                mov     SCSISEQ, SCSISEQ_TEMPLATE ret;
        }

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
set_transfer_settings:
        if ((ahc->features & AHC_ULTRA) != 0) {
                test    SCB_CONTROL, ULTRAENB jz . + 2;
                or      SXFRCTL0, FAST20;
        } 
        /*
         * Initialize SCSIRATE with the appropriate value for this target.
         */
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    SCSIRATE, SCB_SCSIRATE, 2 ret;
        } else {
                mov     SCSIRATE, SCB_SCSIRATE ret;
        }

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
        /*
         * Drive REQ on the bus by enabling SCSI PIO.
         */
        or      SXFRCTL0, SPIOEN;
        /* Wait for the byte */
        test    SSTAT0, SPIORDY jz .;
        /* Prevent our read from triggering another REQ */
        and     SXFRCTL0, ~SPIOEN;
        /* Save latched contents */
        mov     DINDEX, SCSIDATL ret;
d435 1
d439 2
a440 4
        mov     SAVED_SCSIID, SCB_SCSIID;
        mov     SAVED_LUN, SCB_LUN;
        call    initialize_channel;
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d449 1
d454 2
a455 1
                or      SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d463 2
a464 1
                mov     SCB_TARGET_INFO[SCB_INITIATOR_TAG] call target_outb;
d470 1
a470 1
                mov     SEQ_FLAGS, SCB_TARGET_INFO[SCB_TARGET_PHASES];
d472 1
a472 3
                test    SCB_CONTROL, MK_MESSAGE jz target_ITloop;
                mvi     P_MESGIN|BSYO call change_phase;
                jmp     host_target_message_loop;
a487 3
                mov     RETURN_1, ALLZEROS;
                call    complete_target_cmd;
                cmp     RETURN_1, CONT_MSG_LOOP jne .;
d491 3
a499 1
target_mesgout_continue:
a500 1
target_mesgout_pending:
d502 1
d512 1
a512 1
                /* Wait for preceding I/O session to complete. */
a514 4
                and     SIMODE1, ~ENBUSFREE;
                if ((ahc->features & AHC_ULTRA2) != 0) {
                        clr     SCSIBUSL;
                }
d540 1
a540 1
                add     SINDEX, CMDSIZE_TABLE, A;
a543 1
                or      SXFRCTL0, SPIOEN;
d545 1
d563 10
a572 9
                 * Data phases on the bus are from the
                 * perspective of the initiator.  The dma
                 * code looks at LASTPHASE to determine the
                 * data direction of the DMA.  Toggle it for
                 * target transfers.
		 */
                xor     LASTPHASE, IOI, SCB_TARGET_INFO[SCB_TARGET_DATA_DIR];
                or      SCB_TARGET_INFO[SCB_TARGET_DATA_DIR], BSYO
                        call change_phase;
d578 1
a578 1
                mov     SCB_TARGET_INFO[SCB_TARGET_STATUS] call target_outb;
d601 3
a603 1
                        mvi     28      call set_hcnt;
d611 1
a611 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d613 9
a634 1
mesgin_phasemis:
d646 1
a646 1
        mvi     BAD_PHASE call set_seqint;
a651 3
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;       /* Prevent bit leakage durint SELTO */
        }
d655 1
a655 1
        mvi     MISSED_BUSFREE call set_seqint;
a664 1
        or      SXFRCTL0, CLRSTCNT|CLRCHN;
d675 1
a675 3
                if ((ahc->features & AHC_ULTRA) != 0) {
                        and     SXFRCTL0, ~(FAST20);
                }
d681 5
a685 54
sg_advance:
        clr     A;                      /* add sizeof(struct scatter) */
        add     SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
        adc     SCB_RESIDUAL_SGPTR[1],A;
        adc     SCB_RESIDUAL_SGPTR[2],A;
        adc     SCB_RESIDUAL_SGPTR[3],A ret;

if ((ahc->features & AHC_CMD_CHAN) != 0) {
disable_ccsgen:
        test    CCSGCTL, CCSGEN jz return;
        test    CCSGCTL, CCSGDONE jz .;
disable_ccsgen_fetch_done:
        clr     CCSGCTL;
        test    CCSGCTL, CCSGEN jnz .;
        ret;
idle_loop:
        /*
         * Do we need any more segments for this transfer?
         */
        test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

        /* Did we just finish fetching segs? */
        cmp     CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

        /* Are we actively fetching segments? */
        test    CCSGCTL, CCSGEN jnz return;

        /*
         * Do we have any prefetch left???
         */
        cmp     CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

        /*
         * Need to fetch segments, but we can only do that
         * if the command channel is completely idle.  Make
         * sure we don't have an SCB prefetch going on.
         */
        test    CCSCBCTL, CCSCBEN jnz return;

        /*
         * We fetch a "cacheline aligned" and sized amount of data
         * so we don't end up referencing a non-existant page.
         * Cacheline aligned is in quotes because the kernel will
         * set the prefetch amount to a reasonable level if the
         * cacheline size is unknown.
         */
        mvi     CCHCNT, SG_PREFETCH_CNT;
        and     CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
        bmov    CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
        mvi     CCSGCTL, CCSGEN|CCSGRESET ret;
idle_sgfetch_complete:
        call    disable_ccsgen_fetch_done;
        and     CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
idle_sg_avail:
d687 15
a701 55
                /* Does the hardware have space for another SG entry? */
                test    DFSTATUS, PRELOAD_AVAIL jz return;
                bmov    HADDR, CCSGRAM, 7;
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;
                bmov    SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
                }
                call    sg_advance;
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                /* Load the segment */
                or      DFCNTRL, PRELOADEN;
        }
        ret;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Calculate the trailing portion of this S/G segment that cannot
 * be transferred using memory write and invalidate PCI transactions.  
 * XXX Can we optimize this for PCI writes only???
 */
calc_mwi_residual:
        /*
         * If the ending address is on a cacheline boundary,
         * there is no need for an extra segment.
         */
        mov     A, HCNT[0];
        add     A, A, HADDR[0];
        and     A, CACHESIZE_MASK;
        test    A, 0xFF jz return;

        /*
         * If the transfer is less than a cachline,
         * there is no need for an extra segment.
         */
        test    HCNT[1], 0xFF   jnz calc_mwi_residual_final;
        test    HCNT[2], 0xFF   jnz calc_mwi_residual_final;
        add     NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
        jnc     return;

calc_mwi_residual_final:
        mov     MWI_RESIDUAL, A;
        not     A;
        inc     A;
        add     HCNT[0], A;
        adc     HCNT[1], -1;
        adc     HCNT[2], -1 ret;
}
a703 3
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_data_okay;
        mvi     NO_IDENT jmp set_seqint;
p_data_okay:
d711 4
d716 1
a716 2
                /* We don't have any valid S/G elements */
                mvi     CCSGADDR, SG_PREFETCH_CNT;
d718 1
a718 10
        test    SEQ_FLAGS, DPHASE       jz data_phase_initialize;

        /*
         * If we re-enter the data phase after going through another
         * phase, our transfer location has almost certainly been
         * corrupted by the interveining, non-data, transfers.  Ask
         * the host driver to fix us up based on the transfer residual.
         */
        mvi     PDATA_REINIT    call set_seqint;
        jmp     data_phase_loop;
d720 1
a720 2
data_phase_initialize:
        /* We have seen a data phase for the first time */
d725 3
a727 4
         * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
         * flag in the highest byte of the data count.  We cannot
         * modify the saved values in the SCB until we see a save
         * data pointers message.
a728 4
        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                /* The lowest address byte must be loaded last. */
                mov     SCB_DATACNT[3] call set_hhaddr;
        }
a730 1
                bmov    SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
a733 2
                mvi     DINDEX, SCB_RESIDUAL_DATACNT + 3;
                mvi     SCB_DATACNT + 3 call bcopy_5;
d735 1
a735 5
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
                call    calc_mwi_residual;
        }
        and     SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
        and     DATA_COUNT_ODD, 0x1, HCNT[0];
d742 8
a749 1
                }
d753 8
a760 9
        /* Guard against overruns */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;

        /*
         * Turn on `Bit Bucket' mode, wait until the target takes
         * us to another phase, and then notify the host.
         */
        and     DMAPARAMS, DIRECTION;
        mov     DFCNTRL, DMAPARAMS;
d762 5
a766 2
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT1,PHASEMIS jz .;
d768 3
a770 1
                test    SCSIPHASE, DATA_PHASE_MASK jnz .;
a771 4
        and     SXFRCTL1, ~BITBUCKET;
        mvi     DATA_OVERRUN call set_seqint;
        jmp     ITloop;

d773 2
d776 5
a780 194
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                mov     DFCNTRL, DMAPARAMS;
ultra2_dma_loop:
                call    idle_loop;
                /*
                 * The transfer is complete if either the last segment
                 * completes or the target changes phase.
                 */
                test    SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                                 /*
                                  * As a target, we control the phases,
                                  * so ignore PHASEMIS.
                                  */
                                test    SSTAT0, TARGET jnz ultra2_dma_loop;
                        }
                        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                                test    SSTAT1,PHASEMIS jz ultra2_dma_loop;
                        }
                } else {
                        test    DFCNTRL, SCSIEN jnz ultra2_dma_loop;
                }

ultra2_dmafinish:
                /*
                 * The transfer has terminated either due to a phase
                 * change, and/or the completion of the last segment.
                 * We have two goals here.  Do as much other work
                 * as possible while the data fifo drains on a read
                 * and respond as quickly as possible to the standard
                 * messages (save data pointers/disconnect and command
                 * complete) that usually follow a data phase.
                 */
                if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                        /*
                         * On chips with broken auto-flush, start
                         * the flushing process now.  We'll poke
                         * the chip from time to time to keep the
                         * flush process going as we complete the
                         * data phase.
                         */
                        or      DFCNTRL, FIFOFLUSH;
                }
                /*
                 * We assume that, even though data may still be
                 * transferring to the host, that the SCSI side of
                 * the DMA engine is now in a static state.  This
                 * allows us to update our notion of where we are
                 * in this transfer.
                 *
                 * If, by chance, we stopped before being able
                 * to fetch additional segments for this transfer,
                 * yet the last S/G was completely exhausted,
                 * call our idle loop until it is able to load
                 * another segment.  This will allow us to immediately
                 * pickup on the next segment on the next data phase.
                 *
                 * If we happened to stop on the last segment, then
                 * our residual information is still correct from
                 * the idle loop and there is no need to perform
                 * any fixups.
                 */
ultra2_ensure_sg:
                test    SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
                /* Record if we've consumed all S/G entries */
                test    SSTAT2, SHVALID jnz residuals_correct;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     residuals_correct;

ultra2_shvalid:
                test    SSTAT2, SHVALID jnz sgptr_fixup;
                call    idle_loop;
                jmp     ultra2_ensure_sg;

sgptr_fixup:
                /*
                 * Fixup the residual next S/G pointer.  The S/G preload
                 * feature of the chip allows us to load two elements
                 * in addition to the currently active element.  We
                 * store the bottom byte of the next S/G pointer in
                 * the SG_CACEPTR register so we can restore the
                 * correct value when the DMA completes.  If the next
                 * sg ptr value has advanced to the point where higher
                 * bytes in the address have been affected, fix them
                 * too.
                 */
                test    SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
                test    SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
                add     SCB_RESIDUAL_SGPTR[1], -1;
                adc     SCB_RESIDUAL_SGPTR[2], -1; 
                adc     SCB_RESIDUAL_SGPTR[3], -1;
sgptr_fixup_done:
                and     SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
                clr     DATA_COUNT_ODD;
                test    SG_CACHE_SHADOW, ODD_SEG jz . + 2;
                or      DATA_COUNT_ODD, 0x1;
                clr     SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
residuals_correct:
                /*
                 * Go ahead and shut down the DMA engine now.
                 * In the future, we'll want to handle end of
                 * transfer messages prior to doing this, but this
                 * requires similar restructuring for pre-ULTRA2
                 * controllers.
                 */
                test    DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
ultra2_fifoflush:
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                                /*
                                 * On Rev A of the aic7890, the autoflush
                                 * feature doesn't function correctly.
                                 * Perform an explicit manual flush.  During
                                 * a manual flush, the FIFOEMP bit becomes
                                 * true every time the PCI FIFO empties
                                 * regardless of the state of the SCSI FIFO.
                                 * It can take up to 4 clock cycles for the
                                 * SCSI FIFO to get data into the PCI FIFO
                                 * and for FIFOEMP to de-assert.  Here we
                                 * guard against this condition by making
                                 * sure the FIFOEMP bit stays on for 5 full
                                 * clock cycles.
                                 */
                                or      DFCNTRL, FIFOFLUSH;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                        }
                        test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                } else {
                        /*
                         * We enable the auto-ack feature on DT capable
                         * controllers.  This means that the controller may
                         * have already transferred some overrun bytes into
                         * the data FIFO and acked them on the bus.  The only
                         * way to detect this situation is to wait for
                         * LAST_SEG_DONE to come true on a completed transfer
                         * and then test to see if the data FIFO is non-empty.
                         */
                        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
                        test    SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
                        test    DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
                        /* Overrun */
                        jmp     data_phase_loop;
                        test    DFSTATUS, FIFOEMP jz .;
                }
ultra2_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz ultra2_fifoempty;
ultra2_dmahalt:
                and     DFCNTRL, ~(SCSIEN|HDMAEN);
                test    DFCNTRL, SCSIEN|HDMAEN jnz .;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        /*
                         * Keep HHADDR cleared for future, 32bit addressed
                         * only, DMA operations.
                         *
                         * Due to bayonette style S/G handling, our residual
                         * data must be "fixed up" once the transfer is halted.
                         * Here we fixup the HSHADDR stored in the high byte
                         * of the residual data cnt.  By postponing the fixup,
                         * we can batch the clearing of HADDR with the fixup.
                         * If we halted on the last segment, the residual is
                         * already correct.   If we are not on the last
                         * segment, copy the high address directly from HSHADDR.
                         * We don't need to worry about maintaining the
                         * SG_LAST_SEG flag as it will always be false in the
                         * case where an update is required.
                         */
                        or      DSCOMMAND1, HADDLDSEL0;
                        test    SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
                        mov     SCB_RESIDUAL_DATACNT[3], SHADDR;
                        clr     HADDR;
                        and     DSCOMMAND1, ~HADDLDSEL0;
                }
	} else {
                /* If we are the last SG block, tell the hardware. */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jz dma_last_sg;
                        if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
                                test    DMAPARAMS, DIRECTION jz dma_mid_sg;
                        }
a781 1
dma_last_sg:
d783 4
a786 2
dma_mid_sg:
                /* Start DMA data transfer. */
d788 22
a809 22
dma_loop:
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        call    idle_loop;
                }
                test    SSTAT0,DMADONE  jnz dma_dmadone;
                test    SSTAT1,PHASEMIS jz dma_loop;    /* ie. underrun */
dma_phasemis:
                /*
                 * We will be "done" DMAing when the transfer count goes to
                 * zero, or the target changes the phase (in light of this,
                 * it makes sense that the DMA circuitry doesn't ACK when
                 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
                 * the data FIFO should be flushed auto-magically on STCNT=0
                 * or a phase change, so just wait for FIFO empty status.
                 */
dma_checkfifo:
                test    DFCNTRL,DIRECTION       jnz dma_fifoempty;
dma_fifoflush:
                test    DFSTATUS,FIFOEMP        jz dma_fifoflush;
dma_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz dma_fifoempty;
d811 8
a818 52
                /*
                 * Now shut off the DMA and make sure that the DMA
                 * hardware has actually stopped.  Touching the DMA
                 * counters, etc. while a DMA is active will result
                 * in an ILLSADDR exception.
                 */
dma_dmadone:
                and     DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
                /*
                 * Some revisions of the aic78XX have a problem where, if the
                 * data fifo is full, but the PCI input latch is not empty, 
                 * HDMAEN cannot be cleared.  The fix used here is to drain
                 * the prefetched but unused data from the data fifo until
                 * there is space for the input latch to drain.
                 */
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        mov     NONE, DFDAT;
                }
                test    DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

                /* See if we have completed this last segment */
                test    STCNT[0], 0xff  jnz data_phase_finish;
                test    STCNT[1], 0xff  jnz data_phase_finish;
                test    STCNT[2], 0xff  jnz data_phase_finish;

                /*
                 * Advance the scatter-gather pointers if needed 
                 */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jz no_mwi_resid;
                        /*
                         * Reload HADDR from SHADDR and setup the
                         * count to be the size of our residual.
                         */
                        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                                bmov    HADDR, SHADDR, 4;
                                mov     HCNT, MWI_RESIDUAL;
                                bmov    HCNT[1], ALLZEROS, 2;
                        } else {
                                mvi     DINDEX, HADDR;
                                mvi     SHADDR call bcopy_4;
                                mov     MWI_RESIDUAL call set_hcnt;
                        }
                        clr     MWI_RESIDUAL;
                        jmp     sg_load_done;
no_mwi_resid:
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     data_phase_finish;
d820 6
d827 37
a863 52
                 * Load the next SG element's data address and length
                 * into the DMA engine.  If we don't have hardware
                 * to perform a prefetch, we'll have to fetch the
                 * segment from host memory first.
		 */
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        /* Wait for the idle loop to complete */
                        test    CCSGCTL, CCSGEN jz . + 3;
                        call    idle_loop;
                        test    CCSGCTL, CCSGEN jnz . - 1;
                        bmov    HADDR, CCSGRAM, 7;
                        /*
                         * Workaround for flaky external SCB RAM
                         * on certain aic7895 setups.  It seems
                         * unable to handle direct transfers from
                         * S/G ram to certain SCB locations.
                         */
                        mov     SINDEX, CCSGRAM;
                        mov     SCB_RESIDUAL_DATACNT[3], SINDEX;
                } else {
                        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                                mov     ALLZEROS call set_hhaddr;
                        }
                        mvi     DINDEX, HADDR;
                        mvi     SCB_RESIDUAL_SGPTR      call bcopy_4;

                        mvi     SG_SIZEOF       call set_hcnt;

                        or      DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

                        call    dma_finish;

                        mvi     DINDEX, HADDR;
                        call    dfdat_in_7;
                        mov     SCB_RESIDUAL_DATACNT[3], DFDAT;
                }

                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

                        /*
                         * The lowest address byte must be loaded
                         * last as it triggers the computation of
                         * some items in the PCI block.  The ULTRA2
                         * chips do this on PRELOAD.
                         */
                        mov     HADDR, HADDR;
                }
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        call calc_mwi_residual;
                }
d865 3
a867 2
                /* Point to the new next sg in memory */
                call    sg_advance;
d869 2
a870 1
sg_load_done:
a875 7
                /* Track odd'ness */
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;

                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jnz data_phase_loop;
                }
d877 18
d896 16
a911 78
        /*
         * If the target has left us in data phase, loop through
         * the dma code again.  In the case of ULTRA2 adapters,
         * we should only loop if there is a data overrun.  For
         * all other adapters, we'll loop after each S/G element
         * is loaded as well as if there is an overrun.
         */
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                test    SSTAT0, TARGET jnz data_phase_done;
        }
        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                test    SSTAT1, REQINIT jz .;
                if ((ahc->features & AHC_DT) == 0) {
                        test    SSTAT1,PHASEMIS jz data_phase_loop;
                } else {
                        test    SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
                }
        }

data_phase_done:
        /*
         * After a DMA finishes, save the SG and STCNT residuals back into
         * the SCB.  We use STCNT instead of HCNT, since it's a reflection
         * of how many bytes were transferred on the SCSI (as opposed to the
         * host) bus.
         */
        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                /* Kill off any pending prefetch */
                call    disable_ccsgen;
	}

        if ((ahc->features & AHC_ULTRA2) == 0) {
                /*
                 * Clear the high address byte so that all other DMA
                 * operations, which use 32bit addressing, can assume
                 * HHADDR is 0.
                 */
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     ALLZEROS call set_hhaddr;
                }
	}

        /*
         * Update our residual information before the information is
         * lost by some other type of SCSI I/O (e.g. PIO).  If we have
         * transferred all data, no update is needed.
         *
         */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
          && ahc->pci_cachesize != 0) {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        test    MWI_RESIDUAL, 0xFF jz bmov_resid;
                }
                mov     A, MWI_RESIDUAL;
                add     SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
                clr     A;
                adc     SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
                adc     SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
                clr     MWI_RESIDUAL;
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        jmp     . + 2;
bmov_resid:
                        bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
                }
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
                mov     SCB_RESIDUAL_DATACNT[0], STCNT[0];
                mov     SCB_RESIDUAL_DATACNT[1], STCNT[1];
                mov     SCB_RESIDUAL_DATACNT[2], STCNT[2];
	}
residual_update_done:
        /*
         * Since we've been through a data phase, the SCB_RESID* fields
         * are now initialized.  Clear the full residual flag.
         */
        and     SCB_SGPTR[0], ~SG_FULL_RESID;
a913 2
                /* Clear the channel in case we return to data phase later */
                or      SXFRCTL0, CLRSTCNT|CLRCHN;
d917 1
a917 1
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
a926 2
        } else {
                jmp     ITloop;
d928 1
d930 48
a977 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d982 19
a1000 56
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_command_okay;
        mvi     NO_IDENT jmp set_seqint;
p_command_okay:

        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HCNT[0], SCB_CDB_LEN,  1;
                bmov    HCNT[1], ALLZEROS, 2;
                mvi     SG_CACHE_PRE, LAST_SEG;
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    STCNT[0], SCB_CDB_LEN, 1;
                bmov    STCNT[1], ALLZEROS, 2;
        } else {
                mov     STCNT[0], SCB_CDB_LEN;
                clr     STCNT[1];
                clr     STCNT[2];
        }
        add     NONE, -13, SCB_CDB_LEN;
        mvi     SCB_CDB_STORE jnc p_command_embedded;
p_command_from_host:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HADDR[0], SCB_CDB_PTR, 4;
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
        } else {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        bmov    HADDR[0], SCB_CDB_PTR, 4;
                        bmov    HCNT, STCNT, 3;
                } else {
                        mvi     DINDEX, HADDR;
                        mvi     SCB_CDB_PTR call bcopy_4;
                        mov     SCB_CDB_LEN call set_hcnt;
                }
                mvi     DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
        }
        jmp     p_command_loop;
p_command_embedded:
        /*
         * The data fifo seems to require 4 byte aligned
         * transfers from the sequencer.  Force this to
         * be the case by clearing HADDR[0] even though
         * we aren't going to touch host memeory.
         */
        clr     HADDR[0];
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
                bmov    DFDAT, SCB_CDB_STORE, 12; 
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        /*
                         * On the 7895 the data FIFO will
                         * get corrupted if you try to dump
                         * data from external SCB memory into
                         * the FIFO while it is enabled.  So,
                         * fill the fifo and then enable SCSI
                         * transfers.
                         */
                        mvi     DFCNTRL, (DIRECTION|FIFORESET);
d1004 27
a1030 24
                bmov    DFDAT, SCB_CDB_STORE, 12; 
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
                } else {
                        or      DFCNTRL, FIFOFLUSH;
		}
	} else {
                mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
                call    copy_to_fifo_6;
                call    copy_to_fifo_6;
                or      DFCNTRL, FIFOFLUSH;
	}
p_command_loop:
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT0, SDONE jnz . + 2;
                test    SSTAT1, PHASEMIS jz p_command_loop;
                /*
                 * Wait for our ACK to go-away on it's own
                 * instead of being killed by SCSIEN getting cleared.
                 */
                test    SCSISIGI, ACKI jnz .;
        } else {
                test    DFCNTRL, SCSIEN jnz p_command_loop;
        }
a1032 4
        if ((ahc->features & AHC_ULTRA2) != 0) {
                /* Drop any residual from the S/G Preload queue */
                or      SXFRCTL0, CLRSTCNT;
        }
d1040 3
a1042 4
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_status_okay;
        mvi     NO_IDENT jmp set_seqint;
p_status_okay:
        mov     SCB_SCSI_STATUS, SCSIDATL;
d1070 1
a1070 6
        /* Turn on ATN for the retry */
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1075 25
d1101 4
a1104 3
        or      SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
        test    SCB_CONTROL, DISCENB jnz . + 2;
        and     SINDEX, ~DISCENB;
a1153 1
        cmp     A,MSG_IGN_WIDE_RESIDUE  je mesgin_ign_wide_residue;
d1166 1
a1166 1
        mvi     HOST_MSG_LOOP call set_seqint;
a1170 14
mesgin_ign_wide_residue:
if ((ahc->features & AHC_WIDE) != 0) {
        test    SCSIRATE, WIDEXFER jz mesgin_reject;
        /* Pull the residue byte */
        mvi     ARG_1   call inb_next;
        cmp     ARG_1, 0x01 jne mesgin_reject;
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
        test    DATA_COUNT_ODD, 0x1     jz mesgin_done;
        mvi     IGN_WIDE_RES call set_seqint;
        jmp     mesgin_done;
}

mesgin_reject:
        mvi     MSG_MESSAGE_REJECT      call mk_mesg;
d1175 1
d1178 1
a1178 1
 * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
d1185 8
a1192 18
 * sense, it will fill the kernel SCB with a request sense command, requeue
 * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
 * RETURN_1 to SEND_SENSE.
 */

/*
 * If ATN is raised, we still want to give the target a message.
 * Perhaps there was a parity error on this last message byte.
 * Either way, the target should take us to message out phase
 * and then attempt to complete the command again.  We should use a
 * critical section here to guard against a timeout triggering
 * for this command and setting ATN while we are still processing
 * the completion.
        test    SCSISIGI, ATNI jnz mesgin_done;
 */

/*
 * See if we attempted to deliver a message but the target ingnored us.
a1193 2
        test    SCB_CONTROL, MK_MESSAGE jz . + 2;
        mvi     MKMSG_FAILED call set_seqint;
d1196 1
a1196 1
 * Check for residuals
d1198 2
a1199 5
        test    SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
        test    SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
check_status:
        test    SCB_SCSI_STATUS,0xff    jz complete;    /* Good Status? */
a1200 1
        or      SCB_SGPTR, SG_RESID_VALID;
d1203 4
a1206 2
        test    SCB_SCSI_STATUS, 0xff   jz complete;    /* Just a residual? */
        mvi     BAD_STATUS call set_seqint;             /* let driver know */
d1208 11
a1218 1
        call    add_scb_to_free_list;
d1220 1
d1222 8
d1250 1
a1250 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d1253 1
a1253 3
 * and await the bus going free.  If this is an untagged transaction
 * store the SCB id for it in our untagged target table for lookup on
 * a reselction.
a1255 10
        /*
         * If ATN is raised, we still want to give the target a message.
         * Perhaps there was a parity error on this last message byte
         * or we want to abort this command.  Either way, the target
         * should take us to message out phase and then attempt to
         * disconnect again.
         * XXX - Wait for more testing.
        test    SCSISIGI, ATNI jnz mesgin_done;
         */

d1257 1
a1257 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    add_scb_to_disc_list;
        }
        test    SCB_CONTROL, TAG_ENB jnz await_busfree;
        mov     ARG_1, SCB_TAG;
        mov     SAVED_LUN, SCB_LUN;
        mov     SCB_SCSIID      call set_busy_target;
a1265 3
 * Ack the message as soon as possible.  For chips without S/G pipelining,
 * we can only ack the message after SHADDR has been saved.  On these
 * chips, SHADDR increments with every bus transaction, even PIO.
d1268 1
a1268 6
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     NONE,SCSIDATL;          /*dummy read from latch to ACK*/
                test    SEQ_FLAGS, DPHASE       jz ITloop;
        } else {
                test    SEQ_FLAGS, DPHASE       jz mesgin_done;
        }
d1271 2
a1272 17
         * If we are asked to save our position at the end of the
         * transfer, just mark us at the end rather than perform a
         * full save.
         */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
        or      SCB_SGPTR, SG_LIST_NULL;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                jmp     ITloop;
        } else {
                jmp     mesgin_done;
        }

mesgin_sdptrs_full:

        /*
         * The SCB_SGPTR becomes the next one we'll download,
         * and the SCB_DATAPTR becomes the current SHADDR.
d1277 1
d1279 1
a1279 4
                if ((ahc->features & AHC_ULTRA2) == 0) {
                        mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                }
                bmov    SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1281 3
d1285 2
a1286 3
                mvi     SHADDR call bcopy_4;
                mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                mvi     SCB_RESIDUAL_DATACNT call bcopy_8;
d1288 1
a1288 1
        jmp     ITloop;
a1304 14
 * Index into our Busy Target table.  SINDEX and DINDEX are modified
 * upon return.  SCBPTR may be modified by this action.
 */
set_busy_target:
        shr     DINDEX, 4, SINDEX;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, SAVED_LUN;
                add     DINDEX, SCB_64_BTT;
        } else {
                add     DINDEX, BUSY_TARGETS;
        }
        mov     DINDIR, ARG_1 ret;

/*
d1310 4
a1313 34
        /*
         * Determine whether a target is using tagged or non-tagged
         * transactions by first looking at the transaction stored in
         * the busy target array.  If there is no untagged transaction
         * for this target or the transaction is for a different lun, then
         * this must be an untagged transaction.
         */
        shr     SINDEX, 4, SAVED_SCSIID;
        and     SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                add     SINDEX, SCB_64_BTT;
                mov     SCBPTR, SAVED_LUN;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -SCB_64_BTT, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(SCB_64_BTT + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
	} else {
                add     SINDEX, BUSY_TARGETS;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -BUSY_TARGETS, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(BUSY_TARGETS + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
d1315 4
a1318 1
        mov     ARG_1, SINDIR;
d1321 10
a1330 25
                mov     ARG_1 call findSCB;
        } else {
                mov     SCBPTR, ARG_1;
	}
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                jmp setup_SCB_id_lun_okay;
        } else {
                /*
                 * We only allow one untagged command per-target
                 * at a time.  So, if the lun doesn't match, look
                 * for a tag message.
                 */
                mov     A, SCB_LUN;
                cmp     SAVED_LUN, A    je setup_SCB_id_lun_okay;
                if ((ahc->flags & AHC_PAGESCBS) != 0) {
                        /*
                         * findSCB removes the SCB from the
                         * disconnected list, so we must replace
                         * it there should this SCB be for another
                         * lun.
                         */
                        call    cleanup_scb;
                }
        }

d1334 4
a1337 4
 * SCB.  With SCB paging, we must search for non-tagged
 * transactions since the SCB may exist in any slot.  If we're not
 * using SCB paging, we can use the tag as the direct index to the
 * SCB.
a1339 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x80;
        }
d1341 1
a1342 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x1;
        }
a1343 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x2;
        }
d1346 1
a1346 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     ARG_1   call findSCB;
        } else {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     SCBPTR, ARG_1;
        }
d1348 6
a1353 4
/*
 * Ensure that the SCB the tag points to is for
 * an SCB transaction to the reconnecting target.
 */
d1355 2
a1356 15
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x4;
        }
        mov     A, SCB_SCSIID;
        cmp     SAVED_SCSIID, A jne not_found_cleanup_scb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x8;
        }
setup_SCB_id_okay:
        mov     A, SCB_LUN;
        cmp     SAVED_LUN, A    jne not_found_cleanup_scb;
setup_SCB_id_lun_okay:
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x10;
        }
d1359 1
a1359 11
        test    SCB_CONTROL, TAG_ENB    jnz setup_SCB_tagged;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     A, SCBPTR;
        }
        mvi     ARG_1, SCB_LIST_NULL;
        mov     SAVED_SCSIID    call    set_busy_target;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, A;
        }
setup_SCB_tagged:
        mvi     SEQ_FLAGS,IDENTIFY_SEEN;        /* make note of IDENTIFY */
d1363 1
d1368 4
a1371 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    cleanup_scb;
        }
d1373 1
a1373 1
        mvi     NO_MATCH call set_seqint;
d1376 8
d1385 1
a1385 5
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1404 1
a1404 1
        mvi     PERR_DETECTED call set_seqint;
d1426 1
a1426 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1443 1
a1443 1
         * we must wait at least a data release delay plus
d1466 1
d1468 70
a1537 5
 * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will
 * be set to the position of the SCB.  If the SCB cannot be found locally,
 * it will be paged in from host memory.  RETURN_2 stores the address of the
 * preceding SCB in the disconnected list which can be used to speed up
 * removal of the found SCB from the disconnected list.
a1538 2
if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL
d1540 7
a1546 5
        mov     A, SINDEX;                      /* Tag passed in SINDEX */
        cmp     DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
        mov     SCBPTR, DISCONNECTED_SCBH;      /* Initialize SCBPTR */
        mvi     ARG_2, SCB_LIST_NULL;           /* Head of list */
        jmp     findSCB_loop;
a1547 1
        cmp     SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d1549 1
d1551 1
d1553 23
a1575 1
        cmp     SCB_TAG, A      jne findSCB_next;
d1577 1
a1579 1
        mov     SINDEX, SCBPTR;
d1585 7
a1591 7
END_CRITICAL
findSCB_notFound:
        /*
         * We didn't find it.  Page in the SCB.
         */
        mov     ARG_1, A; /* Save tag */
        mov     ALLZEROS call get_free_or_disc_scb;
d1593 1
d1595 44
a1638 1
}
d1642 1
a1642 1
 * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.
d1648 1
a1648 1
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
d1653 4
a1656 2
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
                mvi     1       call set_hcnt;
d1672 5
d1678 1
a1678 1
        mvi     PERR_DETECTED call set_seqint;
d1688 1
a1688 3
        if ((ahc->features & AHC_DT) == 0) {
                and     SCSISIGO, PHASE_MASK, SCSISIGI;
        }
a1691 6
set_hcnt:
        mov     HCNT[0], SINDEX;
clear_hcnt:
        clr     HCNT[1];
        clr     HCNT[2] ret;

a1696 2
bcopy_8:
        mov     DINDIR, SINDIR;
d1710 1
a1710 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1736 1
a1736 1
 * Setup addr assuming that A + (ARG_2 * 256) is an
d1761 1
a1761 5
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE_64;
                } else {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE;
                }
d1766 2
a1767 2
                mvi     CCHCNT, SCB_UPLOAD_SIZE;
                if ((ahc->features & AHC_ULTRA2) == 0) {
d1769 1
a1769 1
                        bmov    CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
a1771 6
                } else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
                        mvi     CCSCBCTL, CCARREN|CCSCBRESET;
                        cmp     CCSCBCTL, ARRDONE|CCARREN jne .;
                        mvi     CCHCNT, SCB_UPLOAD_SIZE;
                        mvi     CCSCBCTL, CCSCBEN|CCSCBRESET;
                        cmp     CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d1783 3
a1785 1
                mvi     SCB_DOWNLOAD_SIZE call set_hcnt;
d1790 2
a1791 2
                mvi     SINDEX, SCB_BASE;
                add     A, SCB_DOWNLOAD_SIZE, SINDEX;
d1793 7
a1799 1
                call    copy_to_fifo_8;
a1801 1
                jmp     dma_finish;
d1803 1
a1803 49
                mvi     DINDEX, SCB_BASE;
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        /*
                         * The PCI module will only issue a PCI
                         * retry if the data FIFO is empty.  If the
                         * host disconnects in the middle of a
                         * transfer, we must empty the fifo of all
                         * available data to force the chip to
                         * continue the transfer.  This does not
                         * happen for SCSI transfers as the SCSI module
                         * will drain the FIFO as data is made available.
                         * When the hang occurs, we know that a multiple
                         * of 8 bytes are in the FIFO because the PCI
                         * module has an 8 byte input latch that only
                         * dumps to the FIFO when HCNT == 0 or the
                         * latch is full.
                         */
                        clr     A;
                        /* Wait for at least 8 bytes of data to arrive. */
dma_scb_hang_fifo:
                        test    DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
                        test    DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        /*
                         * The PCI module no longer intends to perform
                         * a PCI transaction.  Drain the fifo.
                         */
dma_scb_hang_dma_drain_fifo:
                        not     A, HCNT;
                        add     A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
                        and     A, ~0x7;
                        mov     DINDIR,DFDAT;
                        cmp     DINDEX, A jne . - 1;
                        cmp     DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
                                je      dma_finish_nowait;
                        /* Restore A as the lines left to transfer. */
                        add     A, -SCB_BASE, DINDEX;
                        shr     A, 3;
                        jmp     dma_scb_hang_fifo;
dma_scb_hang_dma_done:
                        and     DFCNTRL, ~HDMAEN;
                        test    DFCNTRL, HDMAEN jnz .;
                        add     SEQADDR0, A;
                } else {
                        call    dma_finish;
                }
d1805 5
a1809 5
                call    dfdat_in_8;
                call    dfdat_in_8;
                call    dfdat_in_8;
dfdat_in_8:
                mov     DINDIR,DFDAT;
d1811 2
a1817 1
dfdat_in_2:
a1821 12
copy_to_fifo_8:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
copy_to_fifo_6:
        mov     DFDAT,SINDIR;
copy_to_fifo_5:
        mov     DFDAT,SINDIR;
copy_to_fifo_4:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR ret;
a1828 1
dma_finish_nowait:
a1833 10
/*
 * Restore an SCB that failed to match an incoming reselection
 * to the correct/safe state.  If the SCB is for a disconnected
 * transaction, it must be returned to the disconnected list.
 * If it is not in the disconnected state, it must be free.
 */
cleanup_scb:
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                test    SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
        }
a1835 1
BEGIN_CRITICAL
a1838 1
END_CRITICAL
a1842 7
if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
set_hhaddr:
        or      DSCOMMAND1, HADDLDSEL0;
        and     HADDR, SG_HIGH_ADDR_BITS, SINDEX;
        and     DSCOMMAND1, ~HADDLDSEL0 ret;
}

a1844 1
BEGIN_CRITICAL
a1847 1
        mvi     NO_FREE_SCB call set_seqint;
d1851 1
a1851 2
        mov     DISCONNECTED_SCBH, SCB_NEXT;
END_CRITICAL
d1853 3
a1855 2
        mov     SCB_TAG jmp dma_scb;
BEGIN_CRITICAL
d1859 1
a1859 1
END_CRITICAL
a1866 1
BEGIN_CRITICAL
a1868 7
END_CRITICAL
}
set_seqint:
        mov     INTSTAT, SINDEX;
        nop;
return:
        ret;
@


1.6.14.4
log
@Merge in -current from about a week ago
@
text
@d1 1
d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.93 2000/01/07 23:08:20 gibbs Exp $
d35 2
a38 3
/*
#include <cam/scsi/scsi_message.h>
*/
d58 7
a64 12
reset:
	clr	SCSISIGO;		/* De-assert BSY */
	mvi	MSG_OUT, MSG_NOOP;	/* No message to send */
	and	SXFRCTL1, ~BITBUCKET;
	/* Always allow reselection */
	and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ_TEMPLATE;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Ensure that no DMA operations are in progress */
		clr	CCSGCTL;
		clr	CCSCBCTL;
	}

d68 7
a74 2
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		mov	A, QINPOS;
d76 1
a77 5
	if ((ahc->features & AHC_QUEUE_REGS) == 0) {
		and	SEQCTL, ~PAUSEDIS;
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
	test	SCSISEQ, ENSELO	jnz poll_for_work_loop;
a78 6
		/*
		 * Twin channel devices cannot handle things like SELTO
		 * interrupts on the "background" channel.  So, if we
		 * are selecting, keep polling the current channel util
		 * either a selection or reselection occurs.
		 */
d80 2
a81 5
		test	SSTAT0, SELDO|SELDI	jnz selection;
		test	SCSISEQ, ENSELO	jnz poll_for_work;
		xor	SBLKCTL,SELBUSB;	/* Toggle back */
	}
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d84 1
a86 2
		mov	NONE, SNSCB_QOFF;
		inc	QINPOS;
d88 1
a88 1
		or	SEQCTL, PAUSEDIS;
a89 2
		inc	QINPOS;
		and	SEQCTL, ~PAUSEDIS;
d91 1
d93 5
a97 6
/*
 * We have at least one queued SCB now and we don't have any 
 * SCBs in the list of SCBs awaiting selection.  If we have
 * any SCBs available for use, pull the tag from the QINFIFO
 * and get to work on it.
 */
d100 1
a100 7
	}

dequeue_scb:
	add	A, -1, QINPOS;
	mvi	QINFIFO_OFFSET call fetch_byte;

	if ((ahc->flags & AHC_PAGESCBS) == 0) {
d102 1
a102 1
		mov	SCBPTR, RETURN_2;
d104 2
d107 3
a109 3
/*
 * DMA the SCB from host ram into the current SCB location.
 */
d111 13
a123 14
	mov	RETURN_2	 call dma_scb;

/*
 * Preset the residual fields in case we never go through a data phase.
 * This isn't done by the host so we can avoid a DMA to clear these
 * fields for the normal case of I/O that completes without underrun
 * or overrun conditions.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, SCB_DATACNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],SCB_DATACNT[0];
		mov	SCB_RESID_DCNT[1],SCB_DATACNT[1];
		mov	SCB_RESID_DCNT[2],SCB_DATACNT[2];
d125 1
a125 7
	mov	SCB_RESID_SGCNT, SCB_SGCOUNT;

start_scb:
	/*
	 * Place us on the waiting list in case our selection
	 * doesn't win during bus arbitration.
	 */
d128 7
d137 1
a137 1
	 * Pull the first entry off of the waiting SCB list.
a140 1
	jmp	poll_for_work;
d142 8
a149 52
start_selection:
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		and	A,SELBUSB,SCB_TCL;	/* Get new channel bit */
		or	SINDEX,A;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
initialize_scsiid:
	mov	SINDEX, SCSISEQ_TEMPLATE;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SCB_CONTROL, TARGET_SCB jz . + 4;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mov	SCSIID_ULTRA2, SCB_CMDPTR[2];
		} else {
			mov	SCSIID, SCB_CMDPTR[2];
		}
		or	SINDEX, TEMODE;
		jmp	initialize_scsiid_fini;
	}
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID_ULTRA2, OID;	/* Clear old target */
		or	SCSIID_ULTRA2, A;
	} else {
		and	A, TID, SCB_TCL;	/* Get target ID */
		and	SCSIID, OID;		/* Clear old target */
		or	SCSIID, A;
	}
initialize_scsiid_fini:
	mov	SCSISEQ, SINDEX ret;

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
	or	SXFRCTL0, CLRSTCNT|CLRCHN, SINDEX;
set_transfer_settings:
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
/*
 * Initialize SCSIRATE with the appropriate value for this target.
 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}
d152 15
a167 1
	mvi	CLRSINT0, CLRSELDI;
d169 2
a170 2
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d173 1
a180 1
		mvi	CLRSINT1, CLRBUSFREE;
d191 1
a191 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d195 1
a195 1
			mvi	TMODE_CMDADDR call set_32byte_addr;
d200 1
a200 7
		and	SAVED_TCL, SELID_MASK, SELID;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_TCL;
		} else {
			mov	DFDAT, SAVED_TCL;
		}

d202 14
a215 8
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	CCSCBRAM, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	CCSCBRAM, OID, SCSIID_ULTRA2;
			} else {
				and	CCSCBRAM, OID, SCSIID;
			}
d217 2
a218 11
			if ((ahc->features & AHC_MULTI_TID) != 0) {
				and	DFDAT, OID, TARGIDIN;
			} else if ((ahc->features & AHC_ULTRA2) != 0) {
				and	DFDAT, OID, SCSIID_ULTRA2;
			} else {
				and	DFDAT, OID, SCSIID;
			}
		}

		/* No tag yet */
		mvi	INITIATOR_TAG, SCB_LIST_NULL;
d223 2
a238 1
		/* XXX May need to be more lax here for older initiators... */
d288 4
d299 1
a299 2
		mvi	INTSTAT, HOST_MSG_LOOP;
		nop;
d309 1
a309 1
		mov	A, KERNEL_TQINPOS;
d313 1
a313 1
		cmp	INITIATOR_TAG, SCB_LIST_NULL je . + 3;
d326 1
a326 1
		test	SCSISIGI, ATNI	jnz target_mesgout_pending_msg;
d328 86
a413 1
		
d420 10
a429 33
		/*
		 * Drive REQ on the bus by enabling SCSI PIO.
		 */
		or	SXFRCTL0, SPIOEN;
		/* Wait for the byte */
		test	SSTAT0, SPIORDY jz .;
		/* Prevent our read from triggering another REQ */
		and	SXFRCTL0, ~SPIOEN;
		/* Save latched contents */
		mov	DINDEX, SCSIDATL ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
/*
 * Reselection has been initiated by a target. Make a note that we've been
 * reselected, but haven't seen an IDENTIFY message from the target yet.
 */
initiator_reselect:
	/* XXX test for and handle ONE BIT condition */
	and	SAVED_TCL, SELID_MASK, SELID;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_TCL, SELBUSB;
	}
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;		/*
						 * We aren't expecting a
						 * bus free, so interrupt
						 * the kernel driver if it
						 * happens.
						 */
	jmp	ITloop;
a440 1
/*and	SCSISEQ, ENSELI|ENRSELI|ENAUTOATNP,SCSISEQ_TEMPLATE;*/
d444 4
a447 2
	mov	SAVED_TCL, SCB_TCL;
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
a455 1
		mvi	CLRSINT1,CLRBUSFREE;
d460 1
a460 2
		and	A, LID, SCB_TCL;
		or	A, MSG_IDENTIFYFLAG call target_outb;
d468 1
a468 2
		mov	SCB_INITIATOR_TAG call target_outb;
		mov	INITIATOR_TAG, SCB_INITIATOR_TAG;
d474 1
a474 1
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
d476 3
a478 1

d494 3
a499 3
		mov	RETURN_1, ALLZEROS;
		call	complete_target_cmd;
		cmp	RETURN_1, CONT_MSG_LOOP jne .;
d506 1
d508 1
a509 1
target_mesgout_pending_msg:
d519 1
a519 1
		/* Wait for preceeding I/O session to complete. */
d522 4
d551 1
a551 1
		add	SINDEX, TARG_SCSIRATE, A;
d555 1
a556 1
		or	SXFRCTL0, SPIOEN;
d574 9
a582 10
		 * Data direction flags are from the
		 * perspective of the initiator.
		 */
		test	SCB_TARGET_PHASES[1], TARGET_DATA_IN jz . + 4;
		mvi	LASTPHASE, P_DATAOUT;
		mvi	P_DATAIN|BSYO call change_phase;
		jmp	. + 3;
		mvi	LASTPHASE, P_DATAIN;
		mvi	P_DATAOUT|BSYO call change_phase;
		mov	ALLZEROS call initialize_channel;
d588 1
a588 1
		mov	SCB_TARGET_STATUS call target_outb;
d611 1
a611 3
			mvi	HCNT[0], 28;
			clr	HCNT[1];
			clr	HCNT[2];
d619 1
a619 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
a620 9
	mvi	SPIOEN call	initialize_channel;

	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	or	SIMODE1, ENBUSFREE;

d634 1
d646 1
a646 1
	mvi	INTSTAT,BAD_PHASE;
d652 3
d658 1
a658 1
	mvi	INTSTAT, BAD_PHASE;
d668 1
d679 3
a681 1
		and	SXFRCTL0, ~(FAST20);
d687 78
d766 31
a796 20
 * If we re-enter the data phase after going through another phase, the
 * STCNT may have been cleared, so restore it from the residual field.
 */
data_phase_reinit:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		/*
		 * The preload circuitry requires us to
		 * reload the address too, so pull it from
		 * the shaddow address.
		 */
		bmov	HADDR, SHADDR, 4;
		bmov	HCNT, SCB_RESID_DCNT, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, SCB_RESID_DCNT, 3;
	} else {
		mvi	DINDEX, STCNT;
		mvi	SCB_RESID_DCNT	call bcopy_3;
	}
	and	DATA_COUNT_ODD, 0x1, SCB_RESID_DCNT[0];
	jmp	data_phase_loop;
d799 3
a808 4
	call	assert;			/*
					 * Ensure entering a data
					 * phase is okay - seen identify, etc.
					 */
d810 2
a811 1
		mvi	CCSGADDR, CCSGADDR_MAX;
d813 10
a822 1
	test	SEQ_FLAGS, DPHASE	jnz data_phase_reinit;
d824 2
a825 1
	/* We have seen a data phase */
d830 4
a833 3
	 * Also set SG_COUNT and SG_NEXT in memory since we cannot
	 * modify the values in the SCB itself until we see a
	 * save data pointers message.
d835 4
d841 1
d845 2
d848 5
a852 1
	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];
d859 1
a859 1
		}
d862 3
a864 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SG_COUNT, SCB_SGCOUNT, 5;
	} else {
		mvi	DINDEX, SG_COUNT;
		mvi	SCB_SGCOUNT	call bcopy_5;
	}
d866 6
a871 9
data_phase_loop:
/* Guard against overruns */
	test	SG_COUNT, 0xff jnz data_phase_inbounds;
/*
 * Turn on 'Bit Bucket' mode, set the transfer count to
 * 16meg and let the target run until it changes phase.
 * When the transfer completes, notify the host that we
 * had an overrun.
 */
d873 2
a874 5
	and	DMAPARAMS, ~(HDMAEN|SDMAEN);
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT, ALLONES, 3;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT, ALLONES, 3;
d876 1
a876 3
		mvi	STCNT[0], 0xFF;
		mvi	STCNT[1], 0xFF;
		mvi	STCNT[2], 0xFF;
d878 4
a882 2
/* If we are the last SG block, tell the hardware. */
	cmp	SG_COUNT,0x01 jne data_phase_wideodd;
d884 194
a1077 5
		or	SG_CACHEPTR, LAST_SEG;
	} else {
		if ((ahc->flags & AHC_TARGETMODE) != 0) {
			test	SSTAT0, TARGET jz . + 2;
			test	DMAPARAMS, DIRECTION jz data_phase_wideodd;
d1079 1
d1081 2
a1082 4
	}
data_phase_wideodd:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SINDEX, ALLONES;
d1084 22
a1105 7
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
data_phase_dma_loop:
		test	SSTAT0,	SDONE jnz data_phase_dma_done;
		test	SSTAT1,PHASEMIS	jz data_phase_dma_loop;	/* ie. underrun */
	} else {
		mov	DMAPARAMS  call dma;
	}
d1107 52
a1158 23
data_phase_dma_done:
/* Go tell the host about any overruns */
	test	SXFRCTL1,BITBUCKET jnz data_phase_overrun;

/* See if we completed this segment */
	test	STCNT[0], 0xff	jnz data_phase_finish;
	test	STCNT[1], 0xff	jnz data_phase_finish;
	test	STCNT[2], 0xff	jnz data_phase_finish;

/*
 * Advance the scatter-gather pointers if needed 
 */
sg_advance:
	dec	SG_COUNT;	/* one less segment to go */

	test	SG_COUNT, 0xff	jz data_phase_finish; /* Are we done? */
/*
 * Load a struct scatter and set up the data address and length.
 * If the working value of the SG count is nonzero, then
 * we need to load a new set of values.
 *
 * This, like all DMA's, assumes little-endian host data storage.
 */
a1159 6
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/*
		 * Do we have any prefetch left???
		 */
		cmp	CCSGADDR, CCSGADDR_MAX jne prefetched_segs_avail;

d1161 52
a1212 37
		 * Fetch MIN(CCSGADDR_MAX, (SG_COUNT * 8)) bytes.
		 */
		add	A, -(CCSGRAM_MAXSEGS + 1), SG_COUNT;
		mvi	A, CCSGADDR_MAX;
		jc	. + 2;
		shl	A, 3, SG_COUNT;
		mov	CCHCNT, A;
		bmov	CCHADDR, SG_NEXT, 4;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		and	CCSGCTL, ~CCSGEN;
		test	CCSGCTL, CCSGEN jnz .;
		mvi	CCSGCTL, CCSGRESET;
prefetched_segs_avail:
		bmov 	HADDR, CCSGRAM, 8;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SG_NEXT	call bcopy_4;

		mvi	HCNT[0],SG_SIZEOF;
		clr	HCNT[1];
		clr	HCNT[2];

		or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

		call	dma_finish;

		/*
		 * Copy data from FIFO into SCB data pointer and data count.
		 * This assumes that the SG segments are of the form:
		 * struct ahc_dma_seg {
		 *	u_int32_t	addr;	four bytes, little-endian order
		 *	u_int32_t	len;	four bytes, little endian order
		 * };
		 */
		mvi	HADDR	call dfdat_in_7;
	}
d1214 2
a1215 3
	/* Track odd'ness */
	test	HCNT[0], 0x1 jz . + 2;
	xor	DATA_COUNT_ODD, 0x1;
d1217 1
a1217 2
	if ((ahc->features & AHC_ULTRA2) == 0) {
		/* Load STCNT as well.  It is a mirror of HCNT */
d1223 7
a1230 18

/* Advance the SG pointer */
	clr	A;			/* add sizeof(struct scatter) */
	add	SG_NEXT[0],SG_SIZEOF;
	adc	SG_NEXT[1],A;

	if ((ahc->flags & AHC_TARGETMODE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_loop;
	}
	test	SSTAT1, REQINIT jz .;
	test	SSTAT1,PHASEMIS	jz data_phase_loop;

	/* Ensure the last seg is visable at the shaddow layer */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	DFCNTRL, DMAPARAMS;
		test	SSTAT0, SDONE jnz .;/* Wait for preload to complete */
	}

d1232 78
a1309 16
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
	}
/*
 * After a DMA finishes, save the SG and STCNT residuals back into the SCB
 * We use STCNT instead of HCNT, since it's a reflection of how many bytes 
 * were transferred on the SCSI (as opposed to the host) bus.
 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESID_DCNT, STCNT, 3;
	} else {
		mov	SCB_RESID_DCNT[0],STCNT[0];
		mov	SCB_RESID_DCNT[1],STCNT[1];
		mov	SCB_RESID_DCNT[2],STCNT[2];
	}
	mov	SCB_RESID_SGCNT, SG_COUNT;
d1312 2
d1317 1
a1317 1
	if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1327 2
a1329 1
	jmp	ITloop;
d1331 1
a1331 48
data_phase_overrun:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		call	ultra2_dmafinish;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
	}
/*
 * Turn off BITBUCKET mode and notify the host
 */
	and	SXFRCTL1, ~BITBUCKET;
	mvi	INTSTAT,DATA_OVERRUN;
	jmp	ITloop;

ultra2_dmafinish:
	if ((ahc->features & AHC_ULTRA2) != 0) {
		test	DFCNTRL, DIRECTION jnz ultra2_dmafifoempty;
		and	DFCNTRL, ~SCSIEN;
		test	DFCNTRL, SCSIEN jnz .;
ultra2_dmafifoflush:
		or	DFCNTRL, FIFOFLUSH;
		/*
		 * The FIFOEMP status bit on the Ultra2 class
		 * of controllers seems to be a bit flaky.
		 * It appears that if the FIFO is full and the
		 * transfer ends with some data in the REQ/ACK
		 * FIFO, FIFOEMP will fall temporarily
		 * as the data is transferred to the PCI bus.
		 * This glitch lasts for fewer than 5 clock cycles,
		 * so we work around the problem by ensuring the
		 * status bit stays false through a full glitch
		 * window.
		 */
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;
		test	DFSTATUS, FIFOEMP jz ultra2_dmafifoflush;

ultra2_dmafifoempty:
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_dmafifoempty;

ultra2_dmahalt:
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, HDMAEN jnz .;
		ret;
	}

if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1336 56
a1391 19
	call	assert;

	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mov	HCNT[0], SCB_CMDLEN;
		bmov	HCNT[1], ALLZEROS, 2;
		if ((ahc->features & AHC_ULTRA2) == 0) {
			bmov	STCNT, HCNT, 3;
		}
		add	NONE, -17, SCB_CMDLEN;
		jc	dma_cmd_data;
		/*
		 * The data fifo seems to require 4 byte alligned
		 * transfers from the sequencer.  Force this to
		 * be the case by clearing HADDR[0] even though
		 * we aren't going to touch host memeory.
		 */
		bmov	HADDR[0], ALLZEROS, 1;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
d1395 24
a1418 27
		bmov   DFDAT, SCB_CMDSTORE, 16; 
		jmp	cmd_loop;
dma_cmd_data:
		bmov	HADDR, SCB_CMDPTR, 4;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCB_CMDPTR	call bcopy_5;
		clr	HCNT[1];
		clr	HCNT[2];
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		if ((ahc->features & AHC_CMD_CHAN) == 0) {
			call	set_stcnt_from_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	} else {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	}
cmd_loop:
	test	SSTAT0, SDONE jnz . + 2;
	test    SSTAT1, PHASEMIS jz cmd_loop;
	/*
	 * Wait for our ACK to go-away on it's own
	 * instead of being killed by SCSIEN getting cleared.
	 */
	test	SCSISIGI, ACKI jnz .;
d1421 4
d1432 4
a1435 3
	call	assert;

	mov	SCB_TARGET_STATUS, SCSIDATL;
d1463 6
a1468 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATN for the retry */
a1472 25
	mov	FUNCTION1, SCB_TCL;
	mov	A, FUNCTION1;
	if ((ahc->features & AHC_HS_MAILBOX) != 0) {
		/*
		 * Work around a pausing bug in at least the aic7890.
		 * If the host needs to update the TARGET_MSG_REQUEST
		 * bit field, it will set the HS_MAILBOX to 1.  In
		 * response, we pause with a specific interrupt code
		 * asking for the mask to be updated before we continue.
		 * Ugh.
		 */
		test	HS_MAILBOX, 0xF0	jz . + 2;
		mvi	INTSTAT, UPDATE_TMSG_REQ;
		nop;
	}
	mov	SINDEX, TARGET_MSG_REQUEST[0];
	if ((ahc->features & AHC_TWIN) != 0) {
		/* Second Channel uses high byte bits */
		test	SCB_TCL, SELBUSB	jz . + 2;
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	} else if ((ahc->features & AHC_WIDE) != 0) {
		test	SCB_TCL, 0x80		jz . + 2; /* target > 7 */
		mov	SINDEX, TARGET_MSG_REQUEST[1];
	}
	test	SINDEX, A	jnz host_message_loop;
d1474 3
a1476 4
	and	SINDEX,LID,SCB_TCL;	/* lun */
	and	A,DISCENB,SCB_CONTROL;	/* mask off disconnect privledge */
	or	SINDEX,A;		/* or in disconnect privledge */
	or	SINDEX,MSG_IDENTIFYFLAG;
d1526 1
d1539 1
a1539 1
	mvi	INTSTAT, HOST_MSG_LOOP;
d1544 14
a1561 1

d1564 1
a1564 1
 * We got a "command complete" message, so put the SCB_TAG into the QOUTFIFO,
d1571 18
a1588 8
 * sense, it will fill the kernel SCB with a request sense command and set
 * RETURN_1 to SEND_SENSE.  If RETURN_1 is set to SEND_SENSE we redownload
 * the SCB, and process it as the next command by adding it to the waiting list.
 * If the kernel driver does not wish to request sense, it need only clear
 * RETURN_1, and the command is allowed to complete normally.  We don't bother
 * to post to the QOUTFIFO in the error cases since it would require extra
 * work in the kernel driver to ensure that the entry was removed before the
 * command complete code tried processing it.
d1590 2
d1594 1
a1594 1
 * First check for residuals
d1596 5
a1600 2
	test	SCB_RESID_SGCNT,0xff	jnz upload_scb;
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Good Status? */
d1602 1
d1605 2
a1606 4
check_status:
	test	SCB_TARGET_STATUS,0xff	jz complete;	/* Just a residual? */
	mvi	INTSTAT,BAD_STATUS;			/* let driver know */
	nop;
d1608 1
a1608 11
	/* This SCB becomes the next to execute as it will retrieve sense */
	mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
	mov	SCB_TAG		call dma_scb;
add_to_waiting_list:
	mov	SCB_NEXT,WAITING_SCBH;
	mov	WAITING_SCBH, SCBPTR;
	/*
	 * Prepare our selection hardware before the busfree so we have a
	 * high probability of winning arbitration.
	 */
	call	start_selection;
a1609 1

a1610 8
	/* If we are untagged, clear our address up in host ram */
	test	SCB_CONTROL, TAG_ENB jnz complete_queue;
	mov	A, SAVED_TCL;
	/* fvdl - let ahc_intr clear this to avoid race conditions */
	/* mvi	UNTAGGEDSCB_OFFSET call post_byte_setup; */
	/* mvi	SCB_LIST_NULL call post_byte; */

complete_queue:
d1631 1
a1631 1
if ((ahc->flags & AHC_INITIATORMODE) != 0) {
d1634 3
a1636 1
 * and await the bus going free.
d1639 10
d1650 7
a1656 1
	call	add_scb_to_disc_list;
d1665 3
d1670 6
a1675 1
	test	SEQ_FLAGS, DPHASE	jz mesgin_done;
d1678 17
a1694 2
	 * The SCB SGPTR becomes the next one we'll download,
	 * and the SCB DATAPTR becomes the current SHADDR.
a1698 1
		bmov	SCB_SGCOUNT, SG_COUNT, 5;
d1700 4
a1703 1
		bmov	SCB_DATACNT, SCB_RESID_DCNT, 3;
a1704 3
		mvi	DINDEX, SCB_SGCOUNT;
		mvi	SG_COUNT call bcopy_5;
	
d1706 3
a1708 2
		mvi	SHADDR		call bcopy_4;
		mvi	SCB_RESID_DCNT	call bcopy_3;
d1710 1
a1710 1
	jmp	mesgin_done;
d1727 14
d1746 34
a1779 4
	if ((ahc->features & AHC_WIDE) != 0) {
		and	A,0x0f;		/* lun in lower four bits */
	} else {
		and	A,0x07;		/* lun in lower three bits */
d1781 1
a1781 4
	or      SAVED_TCL,A;		/* SAVED_TCL should be complete now */

	mvi	ARG_2, SCB_LIST_NULL;	/* SCBID of prev SCB in disc List */
	call	get_untagged_SCBID;
d1784 25
a1808 10
		test	SEQ_FLAGS, SCBPTR_VALID	jz use_retrieveSCB;
	}
	/*
	 * If the SCB was found in the disconnected list (as is
	 * always the case in non-paging scenarios), SCBPTR is already
	 * set to the correct SCB.  So, simply setup the SCB and get
	 * on with things.
	 */
	call	rem_scb_from_disc_list;
	jmp	setup_SCB;
d1812 4
a1815 4
 * SCB.  With SCB paging, this requires using search for both tagged
 * and non-tagged transactions since the SCB may exist in any slot.
 * If we're not using SCB paging, we can use the tag as the direct
 * index to the SCB.
d1818 3
a1821 1
snoop_tag_loop:
d1823 3
d1827 3
d1832 7
a1838 1
	mvi	ARG_1	call inb_next;	/* tag value */
d1840 4
a1843 6
	/*
	 * Ensure that the SCB the tag points to is for
	 * an SCB transaction to the reconnecting target.
	 */
use_retrieveSCB:
	call	retrieveSCB;
d1845 15
a1859 2
	mov	A, SAVED_TCL;
	cmp	SCB_TCL, A	jne not_found_cleanup_scb;
d1862 11
a1872 1
	or	SEQ_FLAGS,IDENTIFY_SEEN;	/* make note of IDENTIFY */
a1875 1
	and	SCB_CONTROL, ~MK_MESSAGE;
d1880 3
a1882 4
	test	SCB_CONTROL, DISCONNECTED jz . + 3;
	call	add_scb_to_disc_list;
	jmp	not_found;
	call	add_scb_to_free_list;
d1884 1
a1884 1
	mvi	INTSTAT, NO_MATCH;
a1886 8
/*
 * [ ADD MORE MESSAGE HANDLING HERE ]
 */

/*
 * Locking the driver out, build a one-byte message passed in SINDEX
 * if there is no active message already.  SINDEX is returned intact.
 */
d1888 5
a1892 1
	or	SCSISIGO,ATNO,LASTPHASE;/* turn on ATNO */
d1911 1
a1911 1
	mvi	INTSTAT, PERR_DETECTED;
d1933 1
a1933 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d1950 1
a1950 1
	 * we must waitat least a data release delay plus
a1972 1
mesgin_phasemis:
d1974 5
a1978 70
 * We expected to receive another byte, but the target changed phase
 */
	mvi	INTSTAT, MSGIN_PHASEMIS;
	jmp	ITloop;

/*
 * DMA data transfer.  HADDR and HCNT must be loaded first, and
 * SINDEX should contain the value to load DFCNTRL with - 0x3d for
 * host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
 * during initialization.
 */
dma:
	mov	DFCNTRL,SINDEX;
dma_loop:
	test	SSTAT0,DMADONE	jnz dma_dmadone;
	test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
dma_phasemis:

/*
 * We will be "done" DMAing when the transfer count goes to zero, or
 * the target changes the phase (in light of this, it makes sense that
 * the DMA circuitry doesn't ACK when PHASEMIS is active).  If we are
 * doing a SCSI->Host transfer, the data FIFO should be flushed auto-
 * magically on STCNT=0 or a phase change, so just wait for FIFO empty
 * status.
 */
dma_checkfifo:
	test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
dma_fifoflush:
	test	DFSTATUS,FIFOEMP	jz dma_fifoflush;

dma_fifoempty:
	/* Don't clobber an inprogress host data transfer */
	test	DFSTATUS, MREQPEND	jnz dma_fifoempty;
/*
 * Now shut the DMA enables off and make sure that the DMA enables are 
 * actually off first lest we get an ILLSADDR.
 */
dma_dmadone:
	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
	/*
	 * Some revisions of the aic7880 have a problem where, if the
	 * data fifo is full, but the PCI input latch is not empty, 
	 * HDMAEN cannot be cleared.  The fix used here is to attempt
	 * to drain the data fifo until there is space for the input
	 * latch to drain and HDMAEN de-asserts.
	 */
	if ((ahc->features & AHC_ULTRA2) == 0) {
		mov	NONE, DFDAT;
	}
	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;
return:
	ret;

/*
 * Assert that if we've been reselected, then we've seen an IDENTIFY
 * message.
 */
assert:
	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz return;	/* seen IDENTIFY? */

	mvi	INTSTAT,NO_IDENT 	ret;	/* no - tell the kernel */

/*
 * Locate a disconnected SCB either by SAVED_TCL (ARG_1 is SCB_LIST_NULL)
 * or by the SCBID ARG_1.  The search begins at the SCB index passed in
 * via SINDEX which is an SCB that must be on the disconnected list.  If
 * the SCB cannot be found, SINDEX will be SCB_LIST_NULL, otherwise, SCBPTR
 * is set to the proper SCB.
d1980 2
d1983 5
a1987 7
	mov	SCBPTR,SINDEX;			/* Initialize SCBPTR */
	cmp	ARG_1, SCB_LIST_NULL	jne findSCB_by_SCBID;
	mov	A, SAVED_TCL;
	mvi	SCB_TCL	jmp findSCB_loop;	/* &SCB_TCL -> SINDEX */
findSCB_by_SCBID:
	mov	A, ARG_1;			/* Tag passed in ARG_1 */
	mvi	SCB_TAG	jmp findSCB_loop;	/* &SCB_TAG -> SINDEX */
d1989 1
a1990 1
	cmp	SCB_NEXT, SCB_LIST_NULL je notFound;
a1991 1
	dec	SINDEX;		/* Last comparison moved us too far */
d1993 1
a1993 23
	cmp	SINDIR, A	jne findSCB_next;
	mov	SINDEX, SCBPTR 	ret;
notFound:
	mvi	SINDEX, SCB_LIST_NULL	ret;

/*
 * Retrieve an SCB by SCBID first searching the disconnected list falling
 * back to DMA'ing the SCB down from the host.  This routine assumes that
 * ARG_1 is the SCBID of interrest and that SINDEX is the position in the
 * disconnected list to start the search from.  If SINDEX is SCB_LIST_NULL,
 * we go directly to the host for the SCB.
 */
retrieveSCB:
	test	SEQ_FLAGS, SCBPTR_VALID	jz retrieve_from_host;
	mov	SCBPTR	call findSCB;	/* Continue the search */
	cmp	SINDEX, SCB_LIST_NULL	je retrieve_from_host;

/*
 * This routine expects SINDEX to contain the index of the SCB to be
 * removed, SCBPTR to be pointing to that SCB, and ARG_2 to be the
 * SCBID of the SCB just previous to this one in the list or SCB_LIST_NULL
 * if it is at the head.
 */
a1994 1
/* Remove this SCB from the disconnection list */
d1997 1
d2003 7
a2009 7

retrieve_from_host:
/*
 * We didn't find it.  Pull an SCB and DMA down the one we want.
 * We should never get here in the non-paging case.
 */
	mov	ALLZEROS	call	get_free_or_disc_scb;
a2010 1
	/* Jump instead of call as we want to return anyway */
d2012 1
a2012 44

/*
 * Determine whether a target is using tagged or non-tagged transactions
 * by first looking for a matching transaction based on the TCL and if
 * that fails, looking up this device in the host's untagged SCB array.
 * The TCL to search for is assumed to be in SAVED_TCL.  The value is
 * returned in ARG_1 (SCB_LIST_NULL for tagged, SCBID for non-tagged).
 * The SCBPTR_VALID bit is set in SEQ_FLAGS if we found the information
 * in an SCB instead of having to go to the host.
 */
get_untagged_SCBID:
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je get_SCBID_from_host;
	mvi	ARG_1, SCB_LIST_NULL;
	mov	DISCONNECTED_SCBH call findSCB;
	cmp	SINDEX, SCB_LIST_NULL	je get_SCBID_from_host;
	or	SEQ_FLAGS, SCBPTR_VALID;/* Was in disconnected list */
	test	SCB_CONTROL, TAG_ENB	jnz . + 2;
	mov	ARG_1, SCB_TAG	ret;
	mvi	ARG_1, SCB_LIST_NULL ret;

/*
 * Fetch a byte from host memory given an index of (A + (256 * SINDEX))
 * and a base address of SCBID_ADDR.  The byte is returned in RETURN_2.
 */
fetch_byte:
	mov	ARG_2, SINDEX;
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		mvi	DINDEX, CCHADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	CCHCNT, 1;
		mvi	CCSGCTL, CCSGEN|CCSGRESET;
		test	CCSGCTL, CCSGDONE jz .;
		mvi	CCSGCTL, CCSGRESET;
		bmov	RETURN_2, CCSGRAM, 1 ret;
	} else {
		mvi	DINDEX, HADDR;
		mvi	SCBID_ADDR call set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
		mvi	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;
		call	dma_finish;
		mov	RETURN_2, DFDAT ret;
	}
d2016 1
a2016 1
 * index of (A + (256 * SINDEX)) and a base address of SCBID_ADDR.
d2022 1
a2022 1
		mvi	SCBID_ADDR call	set_1byte_addr;
d2027 2
a2028 4
		mvi	SCBID_ADDR call	set_1byte_addr;
		mvi	HCNT[0], 1;
		clr	HCNT[1];
		clr	HCNT[2];
a2043 5
get_SCBID_from_host:
	mov	A, SAVED_TCL;
	mvi	UNTAGGEDSCB_OFFSET call fetch_byte;
	mov	RETURN_1,  RETURN_2 ret;

d2045 1
a2045 1
	mvi	INTSTAT, PERR_DETECTED;
d2055 3
a2057 1
	and	SCSISIGO, PHASE_MASK, SCSISIGI;
d2061 6
d2072 2
d2087 1
a2087 1
if ((ahc->flags & AHC_TARGETMODE) != 0) {
d2113 1
a2113 1
 * Setup addr assuming that A + (ARG_1 * 256) is an
d2138 5
a2142 1
		mvi	CCHCNT, SCB_64BYTE_SIZE;
d2147 2
a2148 2
		mvi	CCHCNT, SCB_32BYTE_SIZE;
		if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7895) {
d2150 1
a2150 1
			bmov	CCSCBRAM, SCB_CONTROL, SCB_32BYTE_SIZE;
d2153 6
d2170 1
a2170 3
		mvi	HCNT[0], SCB_32BYTE_SIZE;
		clr	HCNT[1];
		clr	HCNT[2];
d2175 2
a2176 2
		mvi	SINDEX, SCB_CONTROL;
		add	A, SCB_32BYTE_SIZE, SINDEX;
d2178 1
a2178 7
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
		mov	DFDAT,SINDIR;
d2181 1
d2183 49
a2231 1
		call	dma_finish;
d2233 5
a2237 5
		test	DMAPARAMS, DIRECTION	jz	return;
		mvi	SCB_CONTROL  call dfdat_in_7;
		call	dfdat_in_7_continued;
		call	dfdat_in_7_continued;
		jmp	dfdat_in_7_continued;
a2238 2
		mov     DINDEX,SINDEX;
dfdat_in_7_continued:
d2244 1
d2249 12
d2268 1
d2274 10
d2286 1
d2290 1
d2295 7
d2304 1
d2308 1
d2312 2
a2313 1
dma_up_scb:
d2315 2
a2316 3
	mov	SCB_TAG		call dma_scb;
unlink_disc_scb:
	mov	DISCONNECTED_SCBH, SCB_NEXT ret;
d2320 1
a2320 1
}
d2328 1
d2331 7
@


1.6.14.5
log
@Sync the SMP branch with 3.3
@
text
@a0 1
/* $OpenBSD$ */
d4 1
a4 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d17 1
a17 1
 * GNU Public License ("GPL").
d31 1
a31 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.119 2001/08/05 22:20:12 gibbs Exp $
a33 3
VERSION = "$Id$"
PATCH_ARG_LIST = "struct ahc_softc *ahc"

d36 3
d58 12
a69 7
bus_free_sel:
        /*
         * Turn off the selection hardware.  We need to reset the
         * selection request in order to perform a new selection.
         */
        and     SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
        and     SIMODE1, ~ENBUSFREE;
d73 2
a74 7
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;
        }
        test    SCSISEQ, ENSELO jnz poll_for_selection;
        if ((ahc->features & AHC_TWIN) != 0) {
                xor     SBLKCTL,SELBUSB;        /* Toggle to the other bus */
                test    SCSISEQ, ENSELO         jnz poll_for_selection;
a75 1
        cmp     WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d77 5
d83 6
d90 5
a94 2
        }
        test    SSTAT0, SELDO|SELDI     jnz selection;
a96 1
BEGIN_CRITICAL;
d99 2
d102 1
a102 1
                mov     A, QINPOS;
d104 2
a106 1
        mov     ARG_1, NEXT_QUEUED_SCB;
d108 6
a113 5
        /*
         * We have at least one queued SCB now and we don't have any 
         * SCBs in the list of SCBs awaiting selection.  Allocate a
         * card SCB for the host's SCB and get to work on it.
         */
d116 7
a122 1
        } else {
d124 1
a124 1
                mov     SCBPTR, ARG_1;
a125 2
        or      SEQ_FLAGS2, SCB_DMA;
END_CRITICAL;
d127 3
a129 3
        /*
         * DMA the SCB from host ram into the current SCB location.
         */
d131 14
a144 13
        mov     ARG_1   call dma_scb;
        /*
         * Check one last time to see if this SCB was canceled
         * before we completed the DMA operation.  If it was,
         * the QINFIFO next pointer will not match our saved
         * value.
         */
        mov     A, ARG_1;
BEGIN_CRITICAL;
        cmp     NEXT_QUEUED_SCB, A jne abort_qinscb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                cmp     SCB_TAG, A je . + 2;
                mvi     SCB_MISMATCH call set_seqint;
d146 7
a152 1
        mov     NEXT_QUEUED_SCB, SCB_NEXT;
a154 7
        if ((ahc->features & AHC_QUEUE_REGS) != 0) {
                mov     NONE, SNSCB_QOFF;
        } else {
                inc     QINPOS;
        }
        and     SEQ_FLAGS2, ~SCB_DMA;
END_CRITICAL;
d157 1
a157 1
         * Start the first entry on the waiting SCB list.
d161 32
d194 21
a214 8
poll_for_selection:
        /*
         * Twin channel devices cannot handle things like SELTO
         * interrupts on the "background" channel.  So, while
         * selecting, keep polling the current channel until
         * either a selection or reselection occurs.
         */
        test    SSTAT0, SELDO|SELDI     jz poll_for_selection;
a216 15
        /*
         * We aren't expecting a bus free, so interrupt
         * the kernel driver if it happens.
         */
        mvi     CLRSINT1,CLRBUSFREE;
        if ((ahc->features & AHC_DT) == 0) {
                or      SIMODE1, ENBUSFREE;
        }

        /*
         * Guard against a bus free after (re)selection
         * but prior to enabling the busfree interrupt.  SELDI
         * and SELDO will be cleared in that case.
         */
        test    SSTAT0, SELDI|SELDO     jz bus_free_sel;
d218 1
d220 2
a221 2
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                if ((ahc->flags & AHC_INITIATORROLE) != 0) {
a223 1
                mvi     CLRSINT0, CLRSELDI;
d231 1
d242 1
a242 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d246 1
a246 1
                        mvi     SHARED_DATA_ADDR call set_32byte_addr;
d251 7
a257 1
                and     SAVED_SCSIID, SELID_MASK, SELID;
d259 8
a266 14
                if ((ahc->features & AHC_MULTI_TID) != 0) {
                        and     A, OID, TARGIDIN;
                } else if ((ahc->features & AHC_ULTRA2) != 0) {
                        and     A, OID, SCSIID_ULTRA2;
                } else {
                        and     A, OID, SCSIID;
                }
                or      SAVED_SCSIID, A;
                if ((ahc->features & AHC_TWIN) != 0) {
                        test    SBLKCTL, SELBUSB jz . + 2;
                        or      SAVED_SCSIID, TWIN_CHNLB;
                }
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        mov     CCSCBRAM, SAVED_SCSIID;
d268 11
a278 2
                        mov     DFDAT, SAVED_SCSIID;
                }
a282 2
                 * XXX SCSI-1 may require us to assume lun 0 if
                 * ATN is false.
d297 1
a346 4
                or      SEQ_FLAGS, TARGET_CMD_IS_TAGGED;
                test    SCSISIGI, ATNI  jz . + 2;
                /* Initiator still wants to give us messages */
                call    target_inb;
d354 2
a355 1
                mvi     HOST_MSG_LOOP call set_seqint;
d365 1
a365 1
                        mov     A, KERNEL_TQINPOS;
d369 1
a369 1
                test    SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
d382 1
a382 1
                test    SCSISIGI, ATNI  jnz target_mesgout_pending;
d384 18
a401 1
        }
d403 1
a403 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d409 15
a423 96
        /* XXX test for and handle ONE BIT condition */
	test    SELID, ONEBIT jnz await_busfree;

	or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	and     SAVED_SCSIID, SELID_MASK, SELID;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                and     A, OID, SCSIID_ULTRA2;
        } else {
                and     A, OID, SCSIID;
        }
        or      SAVED_SCSIID, A;
        if ((ahc->features & AHC_TWIN) != 0) {
                test    SBLKCTL, SELBUSB        jz . + 2;
                or      SAVED_SCSIID, TWIN_CHNLB;
        }
        mvi     CLRSINT0, CLRSELDI;
        jmp     ITloop;
}

abort_qinscb:
        call    add_scb_to_free_list;
        jmp     poll_for_work_loop;

start_selection:
        /*
         * If bus reset interrupts have been disabled (from a previous
         * reset), re-enable them now.  Resets are only of interest
         * when we have outstanding transactions, so we can safely
         * defer re-enabling the interrupt until, as an initiator,
         * we start sending out transactions again.
         */
        test    SIMODE1, ENSCSIRST      jnz . + 3;
        mvi     CLRSINT1, CLRSCSIRSTI;
        or      SIMODE1, ENSCSIRST;
        if ((ahc->features & AHC_TWIN) != 0) {
                and     SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
                test    SCB_SCSIID, TWIN_CHNLB jz . + 2;
                or      SINDEX, SELBUSB;
                mov     SBLKCTL,SINDEX;         /* select channel */
        }
initialize_scsiid:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     SCSIID_ULTRA2, SCB_SCSIID;
        } else if ((ahc->features & AHC_TWIN) != 0) {
                and     SCSIID, TWIN_TID|OID, SCB_SCSIID;
        } else {
                mov     SCSIID, SCB_SCSIID;
        }
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                mov     SINDEX, SCSISEQ_TEMPLATE;
                test    SCB_CONTROL, TARGET_SCB jz . + 2;
                or      SINDEX, TEMODE;
                mov     SCSISEQ, SINDEX ret;
        } else {
                mov     SCSISEQ, SCSISEQ_TEMPLATE ret;
        }

/*
 * Initialize transfer settings and clear the SCSI channel.
 * SINDEX should contain any additional bit's the client wants
 * set in SXFRCTL0.  We also assume that the current SCB is
 * a valid SCB for the target we wish to talk to.
 */
initialize_channel:
        or      SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
set_transfer_settings:
        if ((ahc->features & AHC_ULTRA) != 0) {
                test    SCB_CONTROL, ULTRAENB jz . + 2;
                or      SXFRCTL0, FAST20;
        } 
        /*
         * Initialize SCSIRATE with the appropriate value for this target.
         */
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    SCSIRATE, SCB_SCSIRATE, 2 ret;
        } else {
                mov     SCSIRATE, SCB_SCSIRATE ret;
        }

if ((ahc->flags & AHC_TARGETROLE) != 0) {
/*
 * We carefully toggle SPIOEN to allow us to return the 
 * message byte we receive so it can be checked prior to
 * driving REQ on the bus for the next byte.
 */
target_inb:
        /*
         * Drive REQ on the bus by enabling SCSI PIO.
         */
        or      SXFRCTL0, SPIOEN;
        /* Wait for the byte */
        test    SSTAT0, SPIORDY jz .;
        /* Prevent our read from triggering another REQ */
        and     SXFRCTL0, ~SPIOEN;
        /* Save latched contents */
        mov     DINDEX, SCSIDATL ret;
d435 1
d439 2
a440 4
        mov     SAVED_SCSIID, SCB_SCSIID;
        mov     SAVED_LUN, SCB_LUN;
        call    initialize_channel;
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
d449 1
d454 2
a455 1
                or      SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d463 2
a464 1
                mov     SCB_TARGET_INFO[SCB_INITIATOR_TAG] call target_outb;
d470 1
a470 1
                mov     SEQ_FLAGS, SCB_TARGET_INFO[SCB_TARGET_PHASES];
d472 1
a472 3
                test    SCB_CONTROL, MK_MESSAGE jz target_ITloop;
                mvi     P_MESGIN|BSYO call change_phase;
                jmp     host_target_message_loop;
a487 3
                mov     RETURN_1, ALLZEROS;
                call    complete_target_cmd;
                cmp     RETURN_1, CONT_MSG_LOOP jne .;
d491 3
a499 1
target_mesgout_continue:
a500 1
target_mesgout_pending:
d502 1
d512 1
a512 1
                /* Wait for preceding I/O session to complete. */
a514 4
                and     SIMODE1, ~ENBUSFREE;
                if ((ahc->features & AHC_ULTRA2) != 0) {
                        clr     SCSIBUSL;
                }
d540 1
a540 1
                add     SINDEX, CMDSIZE_TABLE, A;
a543 1
                or      SXFRCTL0, SPIOEN;
d545 1
d563 10
a572 9
                 * Data phases on the bus are from the
                 * perspective of the initiator.  The dma
                 * code looks at LASTPHASE to determine the
                 * data direction of the DMA.  Toggle it for
                 * target transfers.
		 */
                xor     LASTPHASE, IOI, SCB_TARGET_INFO[SCB_TARGET_DATA_DIR];
                or      SCB_TARGET_INFO[SCB_TARGET_DATA_DIR], BSYO
                        call change_phase;
d578 1
a578 1
                mov     SCB_TARGET_INFO[SCB_TARGET_STATUS] call target_outb;
d601 3
a603 1
                        mvi     28      call set_hcnt;
d611 1
a611 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d613 9
a634 1
mesgin_phasemis:
d646 1
a646 1
        mvi     BAD_PHASE call set_seqint;
a651 3
        if ((ahc->features & AHC_ULTRA2) != 0) {
                clr     SCSIBUSL;       /* Prevent bit leakage durint SELTO */
        }
d655 1
a655 1
        mvi     MISSED_BUSFREE call set_seqint;
a664 1
        or      SXFRCTL0, CLRSTCNT|CLRCHN;
d675 1
a675 3
                if ((ahc->features & AHC_ULTRA) != 0) {
                        and     SXFRCTL0, ~(FAST20);
                }
d681 5
a685 54
sg_advance:
        clr     A;                      /* add sizeof(struct scatter) */
        add     SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
        adc     SCB_RESIDUAL_SGPTR[1],A;
        adc     SCB_RESIDUAL_SGPTR[2],A;
        adc     SCB_RESIDUAL_SGPTR[3],A ret;

if ((ahc->features & AHC_CMD_CHAN) != 0) {
disable_ccsgen:
        test    CCSGCTL, CCSGEN jz return;
        test    CCSGCTL, CCSGDONE jz .;
disable_ccsgen_fetch_done:
        clr     CCSGCTL;
        test    CCSGCTL, CCSGEN jnz .;
        ret;
idle_loop:
        /*
         * Do we need any more segments for this transfer?
         */
        test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

        /* Did we just finish fetching segs? */
        cmp     CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

        /* Are we actively fetching segments? */
        test    CCSGCTL, CCSGEN jnz return;

        /*
         * Do we have any prefetch left???
         */
        cmp     CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

        /*
         * Need to fetch segments, but we can only do that
         * if the command channel is completely idle.  Make
         * sure we don't have an SCB prefetch going on.
         */
        test    CCSCBCTL, CCSCBEN jnz return;

        /*
         * We fetch a "cacheline aligned" and sized amount of data
         * so we don't end up referencing a non-existant page.
         * Cacheline aligned is in quotes because the kernel will
         * set the prefetch amount to a reasonable level if the
         * cacheline size is unknown.
         */
        mvi     CCHCNT, SG_PREFETCH_CNT;
        and     CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
        bmov    CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
        mvi     CCSGCTL, CCSGEN|CCSGRESET ret;
idle_sgfetch_complete:
        call    disable_ccsgen_fetch_done;
        and     CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
idle_sg_avail:
d687 15
a701 55
                /* Does the hardware have space for another SG entry? */
                test    DFSTATUS, PRELOAD_AVAIL jz return;
                bmov    HADDR, CCSGRAM, 7;
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;
                bmov    SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
                }
                call    sg_advance;
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                /* Load the segment */
                or      DFCNTRL, PRELOADEN;
        }
        ret;
}

if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
/*
 * Calculate the trailing portion of this S/G segment that cannot
 * be transferred using memory write and invalidate PCI transactions.  
 * XXX Can we optimize this for PCI writes only???
 */
calc_mwi_residual:
        /*
         * If the ending address is on a cacheline boundary,
         * there is no need for an extra segment.
         */
        mov     A, HCNT[0];
        add     A, A, HADDR[0];
        and     A, CACHESIZE_MASK;
        test    A, 0xFF jz return;

        /*
         * If the transfer is less than a cachline,
         * there is no need for an extra segment.
         */
        test    HCNT[1], 0xFF   jnz calc_mwi_residual_final;
        test    HCNT[2], 0xFF   jnz calc_mwi_residual_final;
        add     NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
        jnc     return;

calc_mwi_residual_final:
        mov     MWI_RESIDUAL, A;
        not     A;
        inc     A;
        add     HCNT[0], A;
        adc     HCNT[1], -1;
        adc     HCNT[2], -1 ret;
}
a703 3
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_data_okay;
        mvi     NO_IDENT jmp set_seqint;
p_data_okay:
d711 4
d716 1
a716 2
                /* We don't have any valid S/G elements */
                mvi     CCSGADDR, SG_PREFETCH_CNT;
d718 1
a718 10
        test    SEQ_FLAGS, DPHASE       jz data_phase_initialize;

        /*
         * If we re-enter the data phase after going through another
         * phase, our transfer location has almost certainly been
         * corrupted by the interveining, non-data, transfers.  Ask
         * the host driver to fix us up based on the transfer residual.
         */
        mvi     PDATA_REINIT    call set_seqint;
        jmp     data_phase_loop;
d720 1
a720 2
data_phase_initialize:
        /* We have seen a data phase for the first time */
d725 3
a727 4
         * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
         * flag in the highest byte of the data count.  We cannot
         * modify the saved values in the SCB until we see a save
         * data pointers message.
a728 4
        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                /* The lowest address byte must be loaded last. */
                mov     SCB_DATACNT[3] call set_hhaddr;
        }
a730 1
                bmov    SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
a733 2
                mvi     DINDEX, SCB_RESIDUAL_DATACNT + 3;
                mvi     SCB_DATACNT + 3 call bcopy_5;
d735 1
a735 5
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
                call    calc_mwi_residual;
        }
        and     SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
        and     DATA_COUNT_ODD, 0x1, HCNT[0];
d742 8
a749 1
                }
d753 8
a760 9
        /* Guard against overruns */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;

        /*
         * Turn on `Bit Bucket' mode, wait until the target takes
         * us to another phase, and then notify the host.
         */
        and     DMAPARAMS, DIRECTION;
        mov     DFCNTRL, DMAPARAMS;
d762 5
a766 2
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT1,PHASEMIS jz .;
d768 3
a770 1
                test    SCSIPHASE, DATA_PHASE_MASK jnz .;
a771 4
        and     SXFRCTL1, ~BITBUCKET;
        mvi     DATA_OVERRUN call set_seqint;
        jmp     ITloop;

d773 2
d776 5
a780 194
                mov     SINDEX, SCB_RESIDUAL_SGPTR[0];
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
                or      SINDEX, LAST_SEG;
                test    DATA_COUNT_ODD, 0x1 jz . + 2;
                or      SINDEX, ODD_SEG;
                mov     SG_CACHE_PRE, SINDEX;
                mov     DFCNTRL, DMAPARAMS;
ultra2_dma_loop:
                call    idle_loop;
                /*
                 * The transfer is complete if either the last segment
                 * completes or the target changes phase.
                 */
                test    SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                                 /*
                                  * As a target, we control the phases,
                                  * so ignore PHASEMIS.
                                  */
                                test    SSTAT0, TARGET jnz ultra2_dma_loop;
                        }
                        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                                test    SSTAT1,PHASEMIS jz ultra2_dma_loop;
                        }
                } else {
                        test    DFCNTRL, SCSIEN jnz ultra2_dma_loop;
                }

ultra2_dmafinish:
                /*
                 * The transfer has terminated either due to a phase
                 * change, and/or the completion of the last segment.
                 * We have two goals here.  Do as much other work
                 * as possible while the data fifo drains on a read
                 * and respond as quickly as possible to the standard
                 * messages (save data pointers/disconnect and command
                 * complete) that usually follow a data phase.
                 */
                if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                        /*
                         * On chips with broken auto-flush, start
                         * the flushing process now.  We'll poke
                         * the chip from time to time to keep the
                         * flush process going as we complete the
                         * data phase.
                         */
                        or      DFCNTRL, FIFOFLUSH;
                }
                /*
                 * We assume that, even though data may still be
                 * transferring to the host, that the SCSI side of
                 * the DMA engine is now in a static state.  This
                 * allows us to update our notion of where we are
                 * in this transfer.
                 *
                 * If, by chance, we stopped before being able
                 * to fetch additional segments for this transfer,
                 * yet the last S/G was completely exhausted,
                 * call our idle loop until it is able to load
                 * another segment.  This will allow us to immediately
                 * pickup on the next segment on the next data phase.
                 *
                 * If we happened to stop on the last segment, then
                 * our residual information is still correct from
                 * the idle loop and there is no need to perform
                 * any fixups.
                 */
ultra2_ensure_sg:
                test    SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
                /* Record if we've consumed all S/G entries */
                test    SSTAT2, SHVALID jnz residuals_correct;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     residuals_correct;

ultra2_shvalid:
                test    SSTAT2, SHVALID jnz sgptr_fixup;
                call    idle_loop;
                jmp     ultra2_ensure_sg;

sgptr_fixup:
                /*
                 * Fixup the residual next S/G pointer.  The S/G preload
                 * feature of the chip allows us to load two elements
                 * in addition to the currently active element.  We
                 * store the bottom byte of the next S/G pointer in
                 * the SG_CACEPTR register so we can restore the
                 * correct value when the DMA completes.  If the next
                 * sg ptr value has advanced to the point where higher
                 * bytes in the address have been affected, fix them
                 * too.
                 */
                test    SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
                test    SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
                add     SCB_RESIDUAL_SGPTR[1], -1;
                adc     SCB_RESIDUAL_SGPTR[2], -1; 
                adc     SCB_RESIDUAL_SGPTR[3], -1;
sgptr_fixup_done:
                and     SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
                clr     DATA_COUNT_ODD;
                test    SG_CACHE_SHADOW, ODD_SEG jz . + 2;
                or      DATA_COUNT_ODD, 0x1;
                clr     SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
residuals_correct:
                /*
                 * Go ahead and shut down the DMA engine now.
                 * In the future, we'll want to handle end of
                 * transfer messages prior to doing this, but this
                 * requires similar restructuring for pre-ULTRA2
                 * controllers.
                 */
                test    DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
ultra2_fifoflush:
                if ((ahc->features & AHC_DT) == 0) {
                        if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
                                /*
                                 * On Rev A of the aic7890, the autoflush
                                 * feature doesn't function correctly.
                                 * Perform an explicit manual flush.  During
                                 * a manual flush, the FIFOEMP bit becomes
                                 * true every time the PCI FIFO empties
                                 * regardless of the state of the SCSI FIFO.
                                 * It can take up to 4 clock cycles for the
                                 * SCSI FIFO to get data into the PCI FIFO
                                 * and for FIFOEMP to de-assert.  Here we
                                 * guard against this condition by making
                                 * sure the FIFOEMP bit stays on for 5 full
                                 * clock cycles.
                                 */
                                or      DFCNTRL, FIFOFLUSH;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                                test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                        }
                        test    DFSTATUS, FIFOEMP jz ultra2_fifoflush;
                } else {
                        /*
                         * We enable the auto-ack feature on DT capable
                         * controllers.  This means that the controller may
                         * have already transferred some overrun bytes into
                         * the data FIFO and acked them on the bus.  The only
                         * way to detect this situation is to wait for
                         * LAST_SEG_DONE to come true on a completed transfer
                         * and then test to see if the data FIFO is non-empty.
                         */
                        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
                        test    SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
                        test    DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
                        /* Overrun */
                        jmp     data_phase_loop;
                        test    DFSTATUS, FIFOEMP jz .;
                }
ultra2_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz ultra2_fifoempty;
ultra2_dmahalt:
                and     DFCNTRL, ~(SCSIEN|HDMAEN);
                test    DFCNTRL, SCSIEN|HDMAEN jnz .;
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        /*
                         * Keep HHADDR cleared for future, 32bit addressed
                         * only, DMA operations.
                         *
                         * Due to bayonette style S/G handling, our residual
                         * data must be "fixed up" once the transfer is halted.
                         * Here we fixup the HSHADDR stored in the high byte
                         * of the residual data cnt.  By postponing the fixup,
                         * we can batch the clearing of HADDR with the fixup.
                         * If we halted on the last segment, the residual is
                         * already correct.   If we are not on the last
                         * segment, copy the high address directly from HSHADDR.
                         * We don't need to worry about maintaining the
                         * SG_LAST_SEG flag as it will always be false in the
                         * case where an update is required.
                         */
                        or      DSCOMMAND1, HADDLDSEL0;
                        test    SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
                        mov     SCB_RESIDUAL_DATACNT[3], SHADDR;
                        clr     HADDR;
                        and     DSCOMMAND1, ~HADDLDSEL0;
                }
	} else {
                /* If we are the last SG block, tell the hardware. */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jz dma_last_sg;
                        if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
                                test    DMAPARAMS, DIRECTION jz dma_mid_sg;
                        }
a781 1
dma_last_sg:
d783 4
a786 2
dma_mid_sg:
                /* Start DMA data transfer. */
d788 22
a809 22
dma_loop:
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        call    idle_loop;
                }
                test    SSTAT0,DMADONE  jnz dma_dmadone;
                test    SSTAT1,PHASEMIS jz dma_loop;    /* ie. underrun */
dma_phasemis:
                /*
                 * We will be "done" DMAing when the transfer count goes to
                 * zero, or the target changes the phase (in light of this,
                 * it makes sense that the DMA circuitry doesn't ACK when
                 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
                 * the data FIFO should be flushed auto-magically on STCNT=0
                 * or a phase change, so just wait for FIFO empty status.
                 */
dma_checkfifo:
                test    DFCNTRL,DIRECTION       jnz dma_fifoempty;
dma_fifoflush:
                test    DFSTATUS,FIFOEMP        jz dma_fifoflush;
dma_fifoempty:
                /* Don't clobber an inprogress host data transfer */
                test    DFSTATUS, MREQPEND      jnz dma_fifoempty;
d811 8
a818 52
                /*
                 * Now shut off the DMA and make sure that the DMA
                 * hardware has actually stopped.  Touching the DMA
                 * counters, etc. while a DMA is active will result
                 * in an ILLSADDR exception.
                 */
dma_dmadone:
                and     DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
dma_halt:
                /*
                 * Some revisions of the aic78XX have a problem where, if the
                 * data fifo is full, but the PCI input latch is not empty, 
                 * HDMAEN cannot be cleared.  The fix used here is to drain
                 * the prefetched but unused data from the data fifo until
                 * there is space for the input latch to drain.
                 */
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        mov     NONE, DFDAT;
                }
                test    DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

                /* See if we have completed this last segment */
                test    STCNT[0], 0xff  jnz data_phase_finish;
                test    STCNT[1], 0xff  jnz data_phase_finish;
                test    STCNT[2], 0xff  jnz data_phase_finish;

                /*
                 * Advance the scatter-gather pointers if needed 
                 */
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        test    MWI_RESIDUAL, 0xFF jz no_mwi_resid;
                        /*
                         * Reload HADDR from SHADDR and setup the
                         * count to be the size of our residual.
                         */
                        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                                bmov    HADDR, SHADDR, 4;
                                mov     HCNT, MWI_RESIDUAL;
                                bmov    HCNT[1], ALLZEROS, 2;
                        } else {
                                mvi     DINDEX, HADDR;
                                mvi     SHADDR call bcopy_4;
                                mov     MWI_RESIDUAL call set_hcnt;
                        }
                        clr     MWI_RESIDUAL;
                        jmp     sg_load_done;
no_mwi_resid:
                }
                test    SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
                or      SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
                jmp     data_phase_finish;
d820 6
d827 37
a863 52
                 * Load the next SG element's data address and length
                 * into the DMA engine.  If we don't have hardware
                 * to perform a prefetch, we'll have to fetch the
                 * segment from host memory first.
		 */
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        /* Wait for the idle loop to complete */
                        test    CCSGCTL, CCSGEN jz . + 3;
                        call    idle_loop;
                        test    CCSGCTL, CCSGEN jnz . - 1;
                        bmov    HADDR, CCSGRAM, 7;
                        /*
                         * Workaround for flaky external SCB RAM
                         * on certain aic7895 setups.  It seems
                         * unable to handle direct transfers from
                         * S/G ram to certain SCB locations.
                         */
                        mov     SINDEX, CCSGRAM;
                        mov     SCB_RESIDUAL_DATACNT[3], SINDEX;
                } else {
                        if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                                mov     ALLZEROS call set_hhaddr;
                        }
                        mvi     DINDEX, HADDR;
                        mvi     SCB_RESIDUAL_SGPTR      call bcopy_4;

                        mvi     SG_SIZEOF       call set_hcnt;

                        or      DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

                        call    dma_finish;

                        mvi     DINDEX, HADDR;
                        call    dfdat_in_7;
                        mov     SCB_RESIDUAL_DATACNT[3], DFDAT;
                }

                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

                        /*
                         * The lowest address byte must be loaded
                         * last as it triggers the computation of
                         * some items in the PCI block.  The ULTRA2
                         * chips do this on PRELOAD.
                         */
                        mov     HADDR, HADDR;
                }
                if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
                  && ahc->pci_cachesize != 0) {
                        call calc_mwi_residual;
                }
d865 3
a867 2
                /* Point to the new next sg in memory */
                call    sg_advance;
d869 2
a870 1
sg_load_done:
a875 7
                /* Track odd'ness */
                test    HCNT[0], 0x1 jz . + 2;
                xor     DATA_COUNT_ODD, 0x1;

                if ((ahc->flags & AHC_TARGETROLE) != 0) {
                        test    SSTAT0, TARGET jnz data_phase_loop;
                }
d877 18
d896 16
a911 78
        /*
         * If the target has left us in data phase, loop through
         * the dma code again.  In the case of ULTRA2 adapters,
         * we should only loop if there is a data overrun.  For
         * all other adapters, we'll loop after each S/G element
         * is loaded as well as if there is an overrun.
         */
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
                test    SSTAT0, TARGET jnz data_phase_done;
        }
        if ((ahc->flags & AHC_INITIATORROLE) != 0) {
                test    SSTAT1, REQINIT jz .;
                if ((ahc->features & AHC_DT) == 0) {
                        test    SSTAT1,PHASEMIS jz data_phase_loop;
                } else {
                        test    SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
                }
        }

data_phase_done:
        /*
         * After a DMA finishes, save the SG and STCNT residuals back into
         * the SCB.  We use STCNT instead of HCNT, since it's a reflection
         * of how many bytes were transferred on the SCSI (as opposed to the
         * host) bus.
         */
        if ((ahc->features & AHC_CMD_CHAN) != 0) {
                /* Kill off any pending prefetch */
                call    disable_ccsgen;
	}

        if ((ahc->features & AHC_ULTRA2) == 0) {
                /*
                 * Clear the high address byte so that all other DMA
                 * operations, which use 32bit addressing, can assume
                 * HHADDR is 0.
                 */
                if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
                        mov     ALLZEROS call set_hhaddr;
                }
	}

        /*
         * Update our residual information before the information is
         * lost by some other type of SCSI I/O (e.g. PIO).  If we have
         * transferred all data, no update is needed.
         *
         */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
        if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
          && ahc->pci_cachesize != 0) {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        test    MWI_RESIDUAL, 0xFF jz bmov_resid;
                }
                mov     A, MWI_RESIDUAL;
                add     SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
                clr     A;
                adc     SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
                adc     SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
                clr     MWI_RESIDUAL;
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        jmp     . + 2;
bmov_resid:
                        bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
                }
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
                mov     SCB_RESIDUAL_DATACNT[0], STCNT[0];
                mov     SCB_RESIDUAL_DATACNT[1], STCNT[1];
                mov     SCB_RESIDUAL_DATACNT[2], STCNT[2];
	}
residual_update_done:
        /*
         * Since we've been through a data phase, the SCB_RESID* fields
         * are now initialized.  Clear the full residual flag.
         */
        and     SCB_SGPTR[0], ~SG_FULL_RESID;
a913 2
                /* Clear the channel in case we return to data phase later */
                or      SXFRCTL0, CLRSTCNT|CLRCHN;
d917 1
a917 1
        if ((ahc->flags & AHC_TARGETROLE) != 0) {
a926 2
        } else {
                jmp     ITloop;
d928 1
d930 48
a977 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d982 19
a1000 56
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_command_okay;
        mvi     NO_IDENT jmp set_seqint;
p_command_okay:

        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HCNT[0], SCB_CDB_LEN,  1;
                bmov    HCNT[1], ALLZEROS, 2;
                mvi     SG_CACHE_PRE, LAST_SEG;
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                bmov    STCNT[0], SCB_CDB_LEN, 1;
                bmov    STCNT[1], ALLZEROS, 2;
        } else {
                mov     STCNT[0], SCB_CDB_LEN;
                clr     STCNT[1];
                clr     STCNT[2];
        }
        add     NONE, -13, SCB_CDB_LEN;
        mvi     SCB_CDB_STORE jnc p_command_embedded;
p_command_from_host:
        if ((ahc->features & AHC_ULTRA2) != 0) {
                bmov    HADDR[0], SCB_CDB_PTR, 4;
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
        } else {
                if ((ahc->features & AHC_CMD_CHAN) != 0) {
                        bmov    HADDR[0], SCB_CDB_PTR, 4;
                        bmov    HCNT, STCNT, 3;
                } else {
                        mvi     DINDEX, HADDR;
                        mvi     SCB_CDB_PTR call bcopy_4;
                        mov     SCB_CDB_LEN call set_hcnt;
                }
                mvi     DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
        }
        jmp     p_command_loop;
p_command_embedded:
        /*
         * The data fifo seems to require 4 byte aligned
         * transfers from the sequencer.  Force this to
         * be the case by clearing HADDR[0] even though
	 * we aren't going to touch host memory.
         */
        clr     HADDR[0];
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mvi     DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
                bmov    DFDAT, SCB_CDB_STORE, 12; 
        } else if ((ahc->features & AHC_CMD_CHAN) != 0) {
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        /*
                         * On the 7895 the data FIFO will
                         * get corrupted if you try to dump
                         * data from external SCB memory into
                         * the FIFO while it is enabled.  So,
                         * fill the fifo and then enable SCSI
                         * transfers.
                         */
                        mvi     DFCNTRL, (DIRECTION|FIFORESET);
d1004 27
a1030 24
                bmov    DFDAT, SCB_CDB_STORE, 12; 
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
                } else {
                        or      DFCNTRL, FIFOFLUSH;
		}
	} else {
                mvi     DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
                call    copy_to_fifo_6;
                call    copy_to_fifo_6;
                or      DFCNTRL, FIFOFLUSH;
	}
p_command_loop:
        if ((ahc->features & AHC_DT) == 0) {
                test    SSTAT0, SDONE jnz . + 2;
                test    SSTAT1, PHASEMIS jz p_command_loop;
                /*
                 * Wait for our ACK to go-away on it's own
                 * instead of being killed by SCSIEN getting cleared.
                 */
                test    SCSISIGI, ACKI jnz .;
        } else {
                test    DFCNTRL, SCSIEN jnz p_command_loop;
        }
a1032 4
        if ((ahc->features & AHC_ULTRA2) != 0) {
                /* Drop any residual from the S/G Preload queue */
                or      SXFRCTL0, CLRSTCNT;
        }
d1040 3
a1042 4
        test    SEQ_FLAGS,IDENTIFY_SEEN jnz p_status_okay;
        mvi     NO_IDENT jmp set_seqint;
p_status_okay:
        mov     SCB_SCSI_STATUS, SCSIDATL;
d1070 1
a1070 6
        /* Turn on ATN for the retry */
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1075 25
d1101 4
a1104 3
        or      SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
        test    SCB_CONTROL, DISCENB jnz . + 2;
        and     SINDEX, ~DISCENB;
a1153 1
        cmp     A,MSG_IGN_WIDE_RESIDUE  je mesgin_ign_wide_residue;
d1166 1
a1166 1
        mvi     HOST_MSG_LOOP call set_seqint;
a1170 14
mesgin_ign_wide_residue:
if ((ahc->features & AHC_WIDE) != 0) {
        test    SCSIRATE, WIDEXFER jz mesgin_reject;
        /* Pull the residue byte */
        mvi     ARG_1   call inb_next;
        cmp     ARG_1, 0x01 jne mesgin_reject;
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
        test    DATA_COUNT_ODD, 0x1     jz mesgin_done;
        mvi     IGN_WIDE_RES call set_seqint;
        jmp     mesgin_done;
}

mesgin_reject:
        mvi     MSG_MESSAGE_REJECT      call mk_mesg;
d1175 1
d1178 1
a1178 1
 * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
d1185 8
a1192 18
 * sense, it will fill the kernel SCB with a request sense command, requeue
 * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
 * RETURN_1 to SEND_SENSE.
 */

/*
 * If ATN is raised, we still want to give the target a message.
 * Perhaps there was a parity error on this last message byte.
 * Either way, the target should take us to message out phase
 * and then attempt to complete the command again.  We should use a
 * critical section here to guard against a timeout triggering
 * for this command and setting ATN while we are still processing
 * the completion.
        test    SCSISIGI, ATNI jnz mesgin_done;
 */

/*
 * See if we attempted to deliver a message but the target ingnored us.
a1193 2
        test    SCB_CONTROL, MK_MESSAGE jz . + 2;
        mvi     MKMSG_FAILED call set_seqint;
d1196 1
a1196 1
 * Check for residuals
d1198 2
a1199 5
        test    SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
        test    SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
        test    SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
check_status:
        test    SCB_SCSI_STATUS,0xff    jz complete;    /* Good Status? */
a1200 1
        or      SCB_SGPTR, SG_RESID_VALID;
d1203 4
a1206 2
        test    SCB_SCSI_STATUS, 0xff   jz complete;    /* Just a residual? */
        mvi     BAD_STATUS call set_seqint;             /* let driver know */
d1208 11
a1218 1
        call    add_scb_to_free_list;
d1220 1
d1222 8
d1250 1
a1250 1
if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d1253 1
a1253 3
 * and await the bus going free.  If this is an untagged transaction
 * store the SCB id for it in our untagged target table for lookup on
 * a reselction.
a1255 11
        /*
         * If ATN is raised, we still want to give the target a message.
         * Perhaps there was a parity error on this last message byte
         * or we want to abort this command.  Either way, the target
         * should take us to message out phase and then attempt to
         * disconnect again.
         * XXX - Wait for more testing.
        test    SCSISIGI, ATNI jnz mesgin_done;
         */

        test    SCSISIGI, ATNI jnz mesgin_done;
d1257 1
a1257 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    add_scb_to_disc_list;
        }
        test    SCB_CONTROL, TAG_ENB jnz await_busfree;
        mov     ARG_1, SCB_TAG;
        mov     SAVED_LUN, SCB_LUN;
        mov     SCB_SCSIID      call set_busy_target;
a1265 3
 * Ack the message as soon as possible.  For chips without S/G pipelining,
 * we can only ack the message after SHADDR has been saved.  On these
 * chips, SHADDR increments with every bus transaction, even PIO.
d1268 1
a1268 6
        if ((ahc->features & AHC_ULTRA2) != 0) {
                mov     NONE,SCSIDATL;          /*dummy read from latch to ACK*/
                test    SEQ_FLAGS, DPHASE       jz ITloop;
        } else {
                test    SEQ_FLAGS, DPHASE       jz mesgin_done;
        }
d1271 2
a1272 17
         * If we are asked to save our position at the end of the
         * transfer, just mark us at the end rather than perform a
         * full save.
         */
        test    SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
        or      SCB_SGPTR, SG_LIST_NULL;
        if ((ahc->features & AHC_ULTRA2) != 0) {
                jmp     ITloop;
        } else {
                jmp     mesgin_done;
        }

mesgin_sdptrs_full:

        /*
         * The SCB_SGPTR becomes the next one we'll download,
         * and the SCB_DATAPTR becomes the current SHADDR.
d1277 1
d1279 1
a1279 4
                if ((ahc->features & AHC_ULTRA2) == 0) {
                        mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                }
                bmov    SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1281 3
d1285 2
a1286 3
                mvi     SHADDR call bcopy_4;
                mov     NONE,SCSIDATL;  /*dummy read from latch to ACK*/
                mvi     SCB_RESIDUAL_DATACNT call bcopy_8;
d1288 1
a1288 1
        jmp     ITloop;
a1304 14
 * Index into our Busy Target table.  SINDEX and DINDEX are modified
 * upon return.  SCBPTR may be modified by this action.
 */
set_busy_target:
        shr     DINDEX, 4, SINDEX;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, SAVED_LUN;
                add     DINDEX, SCB_64_BTT;
        } else {
                add     DINDEX, BUSY_TARGETS;
        }
        mov     DINDIR, ARG_1 ret;

/*
d1310 4
a1313 34
        /*
         * Determine whether a target is using tagged or non-tagged
         * transactions by first looking at the transaction stored in
         * the busy target array.  If there is no untagged transaction
         * for this target or the transaction is for a different lun, then
         * this must be an untagged transaction.
         */
        shr     SINDEX, 4, SAVED_SCSIID;
        and     SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                add     SINDEX, SCB_64_BTT;
                mov     SCBPTR, SAVED_LUN;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -SCB_64_BTT, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(SCB_64_BTT + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
	} else {
                add     SINDEX, BUSY_TARGETS;
                if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                        add     NONE, -BUSY_TARGETS, SINDEX;
                        jc      . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                        add     NONE, -(BUSY_TARGETS + 16), SINDEX;
                        jnc     . + 2;
                        mvi     INTSTAT, OUT_OF_RANGE;
                        nop;
                }
d1315 4
a1318 1
        mov     ARG_1, SINDIR;
d1321 10
a1330 25
                mov     ARG_1 call findSCB;
        } else {
                mov     SCBPTR, ARG_1;
	}
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                jmp setup_SCB_id_lun_okay;
        } else {
                /*
                 * We only allow one untagged command per-target
                 * at a time.  So, if the lun doesn't match, look
                 * for a tag message.
                 */
                mov     A, SCB_LUN;
                cmp     SAVED_LUN, A    je setup_SCB_id_lun_okay;
                if ((ahc->flags & AHC_PAGESCBS) != 0) {
                        /*
                         * findSCB removes the SCB from the
                         * disconnected list, so we must replace
                         * it there should this SCB be for another
                         * lun.
                         */
                        call    cleanup_scb;
                }
        }

d1334 4
a1337 4
 * SCB.  With SCB paging, we must search for non-tagged
 * transactions since the SCB may exist in any slot.  If we're not
 * using SCB paging, we can use the tag as the direct index to the
 * SCB.
a1339 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x80;
        }
d1341 1
a1342 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x1;
        }
a1343 3
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x2;
        }
d1346 1
a1346 7
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     ARG_1   call findSCB;
        } else {
                mvi     ARG_1   call inb_next;  /* tag value */
                mov     SCBPTR, ARG_1;
        }
d1348 6
a1353 4
/*
 * Ensure that the SCB the tag points to is for
 * an SCB transaction to the reconnecting target.
 */
d1355 2
a1356 15
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x4;
        }
        mov     A, SCB_SCSIID;
        cmp     SAVED_SCSIID, A jne not_found_cleanup_scb;
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x8;
        }
setup_SCB_id_okay:
        mov     A, SCB_LUN;
        cmp     SAVED_LUN, A    jne not_found_cleanup_scb;
setup_SCB_id_lun_okay:
        if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
                or      SEQ_FLAGS, 0x10;
        }
d1359 1
a1359 11
        test    SCB_CONTROL, TAG_ENB    jnz setup_SCB_tagged;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     A, SCBPTR;
        }
        mvi     ARG_1, SCB_LIST_NULL;
        mov     SAVED_SCSIID    call    set_busy_target;
        if ((ahc->flags & AHC_SCB_BTT) != 0) {
                mov     SCBPTR, A;
        }
setup_SCB_tagged:
        mvi     SEQ_FLAGS,IDENTIFY_SEEN;        /* make note of IDENTIFY */
d1363 1
d1368 4
a1371 3
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                call    cleanup_scb;
        }
d1373 1
a1373 1
        mvi     NO_MATCH call set_seqint;
d1376 8
d1385 1
a1385 5
        if ((ahc->features & AHC_DT) == 0) {
                or      SCSISIGO, ATNO, LASTPHASE;
        } else {
                mvi     SCSISIGO, ATNO;
        }
d1404 1
a1404 1
        mvi     PERR_DETECTED call set_seqint;
d1426 1
a1426 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1443 1
a1443 1
         * we must wait at least a data release delay plus
d1466 1
d1468 70
a1537 5
 * Locate a disconnected SCB by SCBID.  Upon return, SCBPTR and SINDEX will
 * be set to the position of the SCB.  If the SCB cannot be found locally,
 * it will be paged in from host memory.  RETURN_2 stores the address of the
 * preceding SCB in the disconnected list which can be used to speed up
 * removal of the found SCB from the disconnected list.
a1538 2
if ((ahc->flags & AHC_PAGESCBS) != 0) {
BEGIN_CRITICAL;
d1540 7
a1546 5
        mov     A, SINDEX;                      /* Tag passed in SINDEX */
        cmp     DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
        mov     SCBPTR, DISCONNECTED_SCBH;      /* Initialize SCBPTR */
        mvi     ARG_2, SCB_LIST_NULL;           /* Head of list */
        jmp     findSCB_loop;
a1547 1
        cmp     SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d1549 1
d1551 1
d1553 23
a1575 1
        cmp     SCB_TAG, A      jne findSCB_next;
d1577 1
a1579 1
        mov     SINDEX, SCBPTR;
d1585 7
a1591 7
END_CRITICAL;
findSCB_notFound:
        /*
         * We didn't find it.  Page in the SCB.
         */
        mov     ARG_1, A; /* Save tag */
        mov     ALLZEROS call get_free_or_disc_scb;
d1593 1
d1595 44
a1638 1
}
d1642 1
a1642 1
 * index of (A + (256 * SINDEX)) and a base address of SHARED_DATA_ADDR.
d1648 1
a1648 1
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
d1653 4
a1656 2
                mvi     SHARED_DATA_ADDR call   set_1byte_addr;
                mvi     1       call set_hcnt;
d1672 5
d1678 1
a1678 1
        mvi     PERR_DETECTED call set_seqint;
d1688 1
a1688 3
        if ((ahc->features & AHC_DT) == 0) {
                and     SCSISIGO, PHASE_MASK, SCSISIGI;
        }
a1691 6
set_hcnt:
        mov     HCNT[0], SINDEX;
clear_hcnt:
        clr     HCNT[1];
        clr     HCNT[2] ret;

a1696 2
bcopy_8:
        mov     DINDIR, SINDIR;
d1710 1
a1710 1
if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1736 1
a1736 1
 * Setup addr assuming that A + (ARG_2 * 256) is an
d1751 1
a1751 1
 * Either post or fetch an SCB from host memory based on the
d1761 1
a1761 5
                if ((ahc->flags & AHC_SCB_BTT) != 0) {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE_64;
                } else {
                        mvi     CCHCNT, SCB_DOWNLOAD_SIZE;
                }
d1766 2
a1767 2
                mvi     CCHCNT, SCB_UPLOAD_SIZE;
                if ((ahc->features & AHC_ULTRA2) == 0) {
d1769 1
a1769 1
                        bmov    CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
a1771 6
                } else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
                        mvi     CCSCBCTL, CCARREN|CCSCBRESET;
                        cmp     CCSCBCTL, ARRDONE|CCARREN jne .;
                        mvi     CCHCNT, SCB_UPLOAD_SIZE;
                        mvi     CCSCBCTL, CCSCBEN|CCSCBRESET;
                        cmp     CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d1783 3
a1785 1
                mvi     SCB_DOWNLOAD_SIZE call set_hcnt;
d1790 2
a1791 2
                mvi     SINDEX, SCB_BASE;
                add     A, SCB_DOWNLOAD_SIZE, SINDEX;
d1793 7
a1799 1
                call    copy_to_fifo_8;
a1801 1
                jmp     dma_finish;
d1803 1
a1803 49
                mvi     DINDEX, SCB_BASE;
                if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
                        /*
                         * The PCI module will only issue a PCI
                         * retry if the data FIFO is empty.  If the
                         * host disconnects in the middle of a
                         * transfer, we must empty the fifo of all
                         * available data to force the chip to
                         * continue the transfer.  This does not
                         * happen for SCSI transfers as the SCSI module
                         * will drain the FIFO as data is made available.
                         * When the hang occurs, we know that a multiple
                         * of 8 bytes are in the FIFO because the PCI
                         * module has an 8 byte input latch that only
                         * dumps to the FIFO when HCNT == 0 or the
                         * latch is full.
                         */
                        clr     A;
                        /* Wait for at least 8 bytes of data to arrive. */
dma_scb_hang_fifo:
                        test    DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
dma_scb_hang_wait:
                        test    DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        test    DFSTATUS, HDONE jnz dma_scb_hang_dma_done;
                        /*
                         * The PCI module no longer intends to perform
                         * a PCI transaction.  Drain the fifo.
                         */
dma_scb_hang_dma_drain_fifo:
                        not     A, HCNT;
                        add     A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
                        and     A, ~0x7;
                        mov     DINDIR,DFDAT;
                        cmp     DINDEX, A jne . - 1;
                        cmp     DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
                                je      dma_finish_nowait;
                        /* Restore A as the lines left to transfer. */
                        add     A, -SCB_BASE, DINDEX;
                        shr     A, 3;
                        jmp     dma_scb_hang_fifo;
dma_scb_hang_dma_done:
                        and     DFCNTRL, ~HDMAEN;
                        test    DFCNTRL, HDMAEN jnz .;
                        add     SEQADDR0, A;
                } else {
                        call    dma_finish;
                }
d1805 5
a1809 5
                call    dfdat_in_8;
                call    dfdat_in_8;
                call    dfdat_in_8;
dfdat_in_8:
                mov     DINDIR,DFDAT;
d1811 2
a1817 1
dfdat_in_2:
a1821 12
copy_to_fifo_8:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
copy_to_fifo_6:
        mov     DFDAT,SINDIR;
copy_to_fifo_5:
        mov     DFDAT,SINDIR;
copy_to_fifo_4:
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR;
        mov     DFDAT,SINDIR ret;
a1828 1
dma_finish_nowait:
a1833 10
/*
 * Restore an SCB that failed to match an incoming reselection
 * to the correct/safe state.  If the SCB is for a disconnected
 * transaction, it must be returned to the disconnected list.
 * If it is not in the disconnected state, it must be free.
 */
cleanup_scb:
        if ((ahc->flags & AHC_PAGESCBS) != 0) {
                test    SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
        }
a1835 1
BEGIN_CRITICAL;
a1838 1
END_CRITICAL;
a1842 7
if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
set_hhaddr:
        or      DSCOMMAND1, HADDLDSEL0;
        and     HADDR, SG_HIGH_ADDR_BITS, SINDEX;
        and     DSCOMMAND1, ~HADDLDSEL0 ret;
}

a1844 1
BEGIN_CRITICAL;
a1847 1
        mvi     NO_FREE_SCB call set_seqint;
d1851 1
a1851 2
        mov     DISCONNECTED_SCBH, SCB_NEXT;
END_CRITICAL;
d1853 3
a1855 2
        mov     SCB_TAG jmp dma_scb;
BEGIN_CRITICAL;
d1859 1
a1859 1
END_CRITICAL;
a1866 1
BEGIN_CRITICAL;
a1868 7
END_CRITICAL;
}
set_seqint:
        mov     INTSTAT, SINDEX;
        nop;
return:
        ret;
@


1.6.14.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d5 1
a5 2
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d18 1
a18 2
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d20 5
a24 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d27 4
a30 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d32 1
a32 1
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.seq,v 1.123 2003/01/20 20:44:55 gibbs Exp $
d35 1
a35 1
VERSION = "$NetBSD: aic7xxx.seq,v 1.15 2003/05/03 18:11:31 wiz Exp $"
a36 1
PREFIX = "ahc_"
d60 6
a65 6
	/*
	 * Turn off the selection hardware.  We need to reset the
	 * selection request in order to perform a new selection.
	 */
	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP;
	and	SIMODE1, ~ENBUSFREE;
d69 7
a75 2
	if ((ahc->features & AHC_ULTRA2) != 0) {
		clr	SCSIBUSL;
d77 1
a77 6
	test	SCSISEQ, ENSELO	jnz poll_for_selection;
	if ((ahc->features & AHC_TWIN) != 0) {
		xor	SBLKCTL,SELBUSB;	/* Toggle to the other bus */
		test	SCSISEQ, ENSELO		jnz poll_for_selection;
	}
	cmp	WAITING_SCBH,SCB_LIST_NULL jne start_waiting;
d81 2
a82 2
	}
	test	SSTAT0, SELDO|SELDI	jnz selection;
d89 1
a89 1
		mov	A, QINPOS;
d92 1
a92 1
	mov	ARG_1, NEXT_QUEUED_SCB;
d94 5
a98 5
	/*
	 * We have at least one queued SCB now and we don't have any 
	 * SCBs in the list of SCBs awaiting selection.  Allocate a
	 * card SCB for the host's SCB and get to work on it.
	 */
d101 1
a101 1
	} else {
d103 1
a103 1
		mov	SCBPTR, ARG_1;
d105 1
a105 1
	or	SEQ_FLAGS2, SCB_DMA;
d108 3
a110 3
	/*
	 * DMA the SCB from host ram into the current SCB location.
	 */
d112 8
a119 8
	mov	ARG_1	call dma_scb;
	/*
	 * Check one last time to see if this SCB was canceled
	 * before we completed the DMA operation.  If it was,
	 * the QINFIFO next pointer will not match our saved
	 * value.
	 */
	mov	A, ARG_1;
d121 4
a124 4
	cmp	NEXT_QUEUED_SCB, A jne abort_qinscb;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		cmp	SCB_TAG, A je . + 2;
		mvi	SCB_MISMATCH call set_seqint;
d126 1
a126 1
	mov	NEXT_QUEUED_SCB, SCB_NEXT;
d129 6
a134 6
	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
		mov	NONE, SNSCB_QOFF;
	} else {
		inc	QINPOS;
	}
	and	SEQ_FLAGS2, ~SCB_DMA;
d138 1
a138 1
	 * Start the first entry on the waiting SCB list.
d144 7
a150 7
	/*
	 * Twin channel devices cannot handle things like SELTO
	 * interrupts on the "background" channel.  So, while
	 * selecting, keep polling the current channel until
	 * either a selection or reselection occurs.
	 */
	test	SSTAT0, SELDO|SELDI	jz poll_for_selection;
d153 15
a167 15
	/*
	 * We aren't expecting a bus free, so interrupt
	 * the kernel driver if it happens.
	 */
	mvi	CLRSINT1,CLRBUSFREE;
	if ((ahc->features & AHC_DT) == 0) {
		or	SIMODE1, ENBUSFREE;
	}

	/*
	 * Guard against a bus free after (re)selection
	 * but prior to enabling the busfree interrupt.  SELDI
	 * and SELDO will be cleared in that case.
	 */
	test	SSTAT0, SELDI|SELDO	jz bus_free_sel;
d170 2
a171 2
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		if ((ahc->flags & AHC_INITIATORROLE) != 0) {
d174 1
a174 1
		mvi	CLRSINT0, CLRSELDI;
d187 1
a187 1
		mvi	SEQ_FLAGS, CMDPHASE_PENDING;
d192 1
a192 1
			mvi	SHARED_DATA_ADDR call set_32byte_addr;
d196 1
a196 1
			mvi	SHARED_DATA_ADDR call set_32byte_addr;
d201 1
a201 1
		and	SAVED_SCSIID, SELID_MASK, SELID;
d203 14
a216 4
		if ((ahc->features & AHC_MULTI_TID) != 0) {
			and	A, OID, TARGIDIN;
		} else if ((ahc->features & AHC_ULTRA2) != 0) {
			and	A, OID, SCSIID_ULTRA2;
d218 2
a219 12
			and	A, OID, SCSIID;
		}
		or	SAVED_SCSIID, A;
		if ((ahc->features & AHC_TWIN) != 0) {
			test 	SBLKCTL, SELBUSB jz . + 2;
			or	SAVED_SCSIID, TWIN_CHNLB;
		}
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mov	CCSCBRAM, SAVED_SCSIID;
		} else {
			mov	DFDAT, SAVED_SCSIID;
		}
d224 2
a225 2
		 * XXX SCSI-1 may require us to assume lun 0 if
		 * ATN is false.
a246 1
		and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, DINDEX;
d262 1
a262 1
		jnc	ident_messages_done_msg_pending;
d264 1
a264 2
		jc	ident_messages_done_msg_pending;

d289 4
a292 18
		or	SEQ_FLAGS, TARGET_CMD_IS_TAGGED;

ident_messages_done:
		/* Terminate the ident list */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			mvi	CCSCBRAM, SCB_LIST_NULL;
		} else {
			mvi	DFDAT, SCB_LIST_NULL;
		}
		or	SEQ_FLAGS, TARG_CMD_PENDING;
		test	SEQ_FLAGS2, TARGET_MSG_PENDING
			jnz target_mesgout_pending;
		test	SCSISIGI, ATNI jnz target_mesgout_continue;
		jmp	target_ITloop;


ident_messages_done_msg_pending:
		or	SEQ_FLAGS2, TARGET_MSG_PENDING;
d300 1
a300 1
		mvi	HOST_MSG_LOOP call set_seqint;
d304 26
a329 1
	}
d337 17
a353 15
	/* XXX test for and handle ONE BIT condition */
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
	and	SAVED_SCSIID, SELID_MASK, SELID;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		and	A, OID, SCSIID_ULTRA2;
	} else {
		and	A, OID, SCSIID;
	}
	or	SAVED_SCSIID, A;
	if ((ahc->features & AHC_TWIN) != 0) {
		test	SBLKCTL, SELBUSB	jz . + 2;
		or	SAVED_SCSIID, TWIN_CHNLB;
	}
	mvi	CLRSINT0, CLRSELDI;
	jmp	ITloop;
d357 2
a358 2
	call	add_scb_to_free_list;
	jmp	poll_for_work_loop;
d361 16
a376 16
	/*
	 * If bus reset interrupts have been disabled (from a previous
	 * reset), re-enable them now.  Resets are only of interest
	 * when we have outstanding transactions, so we can safely
	 * defer re-enabling the interrupt until, as an initiator,
	 * we start sending out transactions again.
	 */
	test	SIMODE1, ENSCSIRST	jnz . + 3;
	mvi	CLRSINT1, CLRSCSIRSTI;
	or	SIMODE1, ENSCSIRST;
	if ((ahc->features & AHC_TWIN) != 0) {
		and	SINDEX,~SELBUSB,SBLKCTL;/* Clear channel select bit */
		test	SCB_SCSIID, TWIN_CHNLB jz . + 2;
		or	SINDEX, SELBUSB;
		mov	SBLKCTL,SINDEX;		/* select channel */
	}
d378 21
a398 18
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	SCSIID_ULTRA2, SCB_SCSIID;
	} else if ((ahc->features & AHC_TWIN) != 0) {
		and	SCSIID, TWIN_TID|OID, SCB_SCSIID;
	} else {
		mov	SCSIID, SCB_SCSIID;
	}
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		mov	SINDEX, SCSISEQ_TEMPLATE;
		test	SCB_CONTROL, TARGET_SCB jz . + 2;
		or	SINDEX, TEMODE;
		mov	SCSISEQ, SINDEX ret;
	} else {
		mov	SCSISEQ, SCSISEQ_TEMPLATE ret;
	}

/*
 * Initialize transfer settings with SCB provided settings.
d400 2
d403 12
a414 12
	if ((ahc->features & AHC_ULTRA) != 0) {
		test	SCB_CONTROL, ULTRAENB jz . + 2;
		or	SXFRCTL0, FAST20;
	} 
	/*
	 * Initialize SCSIRATE with the appropriate value for this target.
	 */
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	SCSIRATE, SCB_SCSIRATE, 2 ret;
	} else {
		mov	SCSIRATE, SCB_SCSIRATE ret;
	}
d423 10
a432 10
	/*
	 * Drive REQ on the bus by enabling SCSI PIO.
	 */
	or	SXFRCTL0, SPIOEN;
	/* Wait for the byte */
	test	SSTAT0, SPIORDY jz .;
	/* Prevent our read from triggering another REQ */
	and	SXFRCTL0, ~SPIOEN;
	/* Save latched contents */
	mov	DINDEX, SCSIDATL ret;
d444 1
d447 4
a450 4
	mov	SAVED_SCSIID, SCB_SCSIID;
	mov	SAVED_LUN, SCB_LUN;
	call	set_transfer_settings;
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
a452 8
		or	SXFRCTL0, CLRSTCNT|CLRCHN;

		/*
		 * Put tag in connonical location since not
		 * all connections have an SCB.
		 */
		mov	INITIATOR_TAG, SCB_TARGET_ITAG;

a458 1
		mvi	CLRSINT0, CLRSELDO;
d463 1
a463 1
		or	SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
d471 1
a471 1
		mov	SCB_TARGET_ITAG call target_outb;
d477 1
a477 1
		mov	SEQ_FLAGS, SCB_TARGET_PHASES;
d479 3
a481 3
		test	SCB_CONTROL, MK_MESSAGE	jz target_ITloop;
		mvi	P_MESGIN|BSYO call change_phase;
		jmp	host_target_message_loop;
d497 3
a499 2
		mvi	TARG_IMMEDIATE_SCB, SCB_LIST_NULL;
		call	complete_target_cmd;
a502 1
		cmp	TARG_IMMEDIATE_SCB, SCB_LIST_NULL je .;
d504 1
a504 3
		mov	TARG_IMMEDIATE_SCB call dma_scb;
		call	set_transfer_settings;
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
a511 1
		and	SEQ_FLAGS2, ~TARGET_MSG_PENDING;
d522 1
a522 1
		/* Wait for preceding I/O session to complete. */
d525 4
a528 4
		and	SIMODE1, ~ENBUSFREE;
		if ((ahc->features & AHC_ULTRA2) != 0) {
			clr	SCSIBUSL;
		}
a534 18
		/*
		 * The target has dropped ATN (doesn't want to abort or BDR)
		 * and we believe this selection to be valid.  If the ring
		 * buffer for new commands is full, return busy or queue full.
		 */
		if ((ahc->features & AHC_HS_MAILBOX) != 0) {
			and	A, HOST_TQINPOS, HS_MAILBOX;
		} else {
			mov	A, KERNEL_TQINPOS;
		}
		cmp	TQINPOS, A jne tqinfifo_has_space;
		mvi	P_STATUS|BSYO call change_phase;
		test	SEQ_FLAGS, TARGET_CMD_IS_TAGGED jz . + 3;
		mvi	STATUS_QUEUE_FULL call target_outb;
		jmp	target_busfree_wait;
		mvi	STATUS_BUSY call target_outb;
		jmp	target_busfree_wait;
tqinfifo_has_space:	
d554 1
a554 1
		add	SINDEX, CMDSIZE_TABLE, A;
d558 1
a558 1
		or	SXFRCTL0, SPIOEN;
d577 9
a585 8
		 * Data phases on the bus are from the
		 * perspective of the initiator.  The DMA
		 * code looks at LASTPHASE to determine the
		 * data direction of the DMA.  Toggle it for
		 * target transfers.
		 */
		xor	LASTPHASE, IOI, SCB_TARGET_DATA_DIR;
		or	SCB_TARGET_DATA_DIR, BSYO call change_phase;
d591 1
a591 1
		mov	SCB_SCSI_STATUS call target_outb;
d614 1
a614 1
			mvi	28	call set_hcnt;
a623 1
	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
d630 1
a630 2
	mvi	SEQ_FLAGS, NO_CDB_SENT;
	mvi	CLRSINT0, CLRSELDO;
d649 1
a649 1
	mvi	BAD_PHASE call set_seqint;
d655 3
a657 3
	if ((ahc->features & AHC_ULTRA2) != 0) {
		clr	SCSIBUSL;	/* Prevent bit leakage durint SELTO */
	}
d661 1
a661 1
	mvi	MISSED_BUSFREE call set_seqint;
d671 1
a671 1
	or	SXFRCTL0, CLRSTCNT|CLRCHN;
d682 3
a684 3
		if ((ahc->features & AHC_ULTRA) != 0) {
			and	SXFRCTL0, ~(FAST20);
		}
d688 1
a688 1
	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
d691 5
a695 5
	clr	A;			/* add sizeof(struct scatter) */
	add	SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
	adc	SCB_RESIDUAL_SGPTR[1],A;
	adc	SCB_RESIDUAL_SGPTR[2],A;
	adc	SCB_RESIDUAL_SGPTR[3],A ret;
d699 2
a700 2
	test	CCSGCTL, CCSGEN jz return;
	test	CCSGCTL, CCSGDONE jz .;
d702 3
a704 3
	clr	CCSGCTL;
	test	CCSGCTL, CCSGEN jnz .;
	ret;
d706 34
a739 34
	/*
	 * Do we need any more segments for this transfer?
	 */
	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz return;

	/* Did we just finish fetching segs? */
	cmp	CCSGCTL, CCSGEN|CCSGDONE je idle_sgfetch_complete;

	/* Are we actively fetching segments? */
	test	CCSGCTL, CCSGEN jnz return;

	/*
	 * Do we have any prefetch left???
	 */
	cmp	CCSGADDR, SG_PREFETCH_CNT jne idle_sg_avail;

	/*
	 * Need to fetch segments, but we can only do that
	 * if the command channel is completely idle.  Make
	 * sure we don't have an SCB prefetch going on.
	 */
	test	CCSCBCTL, CCSCBEN jnz return;

	/*
	 * We fetch a "cacheline aligned" and sized amount of data
	 * so we don't end up referencing a non-existant page.
	 * Cacheline aligned is in quotes because the kernel will
	 * set the prefetch amount to a reasonable level if the
	 * cacheline size is unknown.
	 */
	mvi	CCHCNT, SG_PREFETCH_CNT;
	and	CCHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
	bmov	CCHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
	mvi	CCSGCTL, CCSGEN|CCSGRESET ret;
d741 2
a742 2
	call	disable_ccsgen_fetch_done;
	and	CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
d745 20
a764 20
		/* Does the hardware have space for another SG entry? */
		test	DFSTATUS, PRELOAD_AVAIL jz return;
		bmov 	HADDR, CCSGRAM, 7;
		test	HCNT[0], 0x1 jz . + 2;
		xor	DATA_COUNT_ODD, 0x1;
		bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
		}
		call	sg_advance;
		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
		test	DATA_COUNT_ODD, 0x1 jz . + 2;
		or	SINDEX, ODD_SEG;
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
		or	SINDEX, LAST_SEG;
		mov	SG_CACHE_PRE, SINDEX;
		/* Load the segment */
		or	DFCNTRL, PRELOADEN;
	}
	ret;
d774 17
a790 17
	/*
	 * If the ending address is on a cacheline boundary,
	 * there is no need for an extra segment.
	 */
	mov	A, HCNT[0];
	add	A, A, HADDR[0];
	and	A, CACHESIZE_MASK;
	test	A, 0xFF jz return;

	/*
	 * If the transfer is less than a cachline,
	 * there is no need for an extra segment.
	 */
	test	HCNT[1], 0xFF	jnz calc_mwi_residual_final;
	test	HCNT[2], 0xFF	jnz calc_mwi_residual_final;
	add	NONE, INVERTED_CACHESIZE_MASK, HCNT[0];
	jnc	return;
d793 6
a798 6
	mov	MWI_RESIDUAL, A;
	not	A;
	inc	A;
	add	HCNT[0], A;
	adc	HCNT[1], -1;
	adc	HCNT[2], -1 ret;
d802 3
a804 3
	test	SEQ_FLAGS,NOT_IDENTIFIED|NO_CDB_SENT jz p_data_allowed;
	mvi	PROTO_VIOLATION call set_seqint;
p_data_allowed:
d813 2
a814 2
		/* We don't have any valid S/G elements */
		mvi	CCSGADDR, SG_PREFETCH_CNT;
d816 1
a816 1
	test	SEQ_FLAGS, DPHASE	jz data_phase_initialize;
d818 8
a825 8
	/*
	 * If we re-enter the data phase after going through another
	 * phase, our transfer location has almost certainly been
	 * corrupted by the interveining, non-data, transfers.  Ask
	 * the host driver to fix us up based on the transfer residual.
	 */
	mvi	PDATA_REINIT	call set_seqint;
	jmp	data_phase_loop;
d828 1
a828 1
	/* We have seen a data phase for the first time */
d833 9
a841 9
	 * Also set SCB_RESIDUAL_SGPTR, including the LAST_SEG
	 * flag in the highest byte of the data count.  We cannot
	 * modify the saved values in the SCB until we see a save
	 * data pointers message.
	 */
	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
		/* The lowest address byte must be loaded last. */
		mov	SCB_DATACNT[3] call set_hhaddr;
	}
d844 1
a844 1
		bmov	SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
d848 2
a849 5
		mvi	DINDEX, SCB_RESIDUAL_DATACNT + 3;
		mvi	SCB_DATACNT + 3 call bcopy_5;
	}
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0) {
		call	calc_mwi_residual;
d851 5
a855 2
	and	SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
	and	DATA_COUNT_ODD, 0x1, HCNT[0];
d862 1
a862 1
		}
d866 2
a867 2
	/* Guard against overruns */
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_inbounds;
d869 6
a874 6
	/*
	 * Turn on `Bit Bucket' mode, wait until the target takes
	 * us to another phase, and then notify the host.
	 */
	and	DMAPARAMS, DIRECTION;
	mov	DFCNTRL, DMAPARAMS;
d876 2
a877 2
	if ((ahc->features & AHC_DT) == 0) {
		test	SSTAT1,PHASEMIS	jz .;
d879 1
a879 1
		test	SCSIPHASE, DATA_PHASE_MASK jnz .;
d881 3
a883 3
	and	SXFRCTL1, ~BITBUCKET;
	mvi	DATA_OVERRUN call set_seqint;
	jmp	ITloop;
d887 7
a893 7
		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
		or	SINDEX, LAST_SEG;
		test	DATA_COUNT_ODD, 0x1 jz . + 2;
		or	SINDEX, ODD_SEG;
		mov	SG_CACHE_PRE, SINDEX;
		mov	DFCNTRL, DMAPARAMS;
d895 20
a914 20
		call	idle_loop;
		/*
		 * The transfer is complete if either the last segment
		 * completes or the target changes phase.
		 */
		test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz ultra2_dmafinish;
		if ((ahc->features & AHC_DT) == 0) {
			if ((ahc->flags & AHC_TARGETROLE) != 0) {
				 /*
				  * As a target, we control the phases,
				  * so ignore PHASEMIS.
				  */
				test	SSTAT0, TARGET jnz ultra2_dma_loop;
			}
			if ((ahc->flags & AHC_INITIATORROLE) != 0) {
				test	SSTAT1,PHASEMIS	jz ultra2_dma_loop;
			}
		} else {
			test	DFCNTRL, SCSIEN jnz ultra2_dma_loop;
		}
d917 38
a954 38
		/*
		 * The transfer has terminated either due to a phase
		 * change, and/or the completion of the last segment.
		 * We have two goals here.  Do as much other work
		 * as possible while the data fifo drains on a read
		 * and respond as quickly as possible to the standard
		 * messages (save data pointers/disconnect and command
		 * complete) that usually follow a data phase.
		 */
		if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
			/*
			 * On chips with broken auto-flush, start
			 * the flushing process now.  We'll poke
			 * the chip from time to time to keep the
			 * flush process going as we complete the
			 * data phase.
			 */
			or	DFCNTRL, FIFOFLUSH;
		}
		/*
		 * We assume that, even though data may still be
		 * transferring to the host, that the SCSI side of
		 * the DMA engine is now in a static state.  This
		 * allows us to update our notion of where we are
		 * in this transfer.
		 *
		 * If, by chance, we stopped before being able
		 * to fetch additional segments for this transfer,
		 * yet the last S/G was completely exhausted,
		 * call our idle loop until it is able to load
		 * another segment.  This will allow us to immediately
		 * pickup on the next segment on the next data phase.
		 *
		 * If we happened to stop on the last segment, then
		 * our residual information is still correct from
		 * the idle loop and there is no need to perform
		 * any fixups.
		 */
d956 5
a960 5
		test	SG_CACHE_SHADOW, LAST_SEG jz ultra2_shvalid;
		/* Record if we've consumed all S/G entries */
		test	SSTAT2, SHVALID	jnz residuals_correct;
		or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
		jmp	residuals_correct;
d963 3
a965 3
		test	SSTAT2, SHVALID	jnz sgptr_fixup;
		call	idle_loop;
		jmp	ultra2_ensure_sg;
d968 16
a983 16
		/*
		 * Fixup the residual next S/G pointer.  The S/G preload
		 * feature of the chip allows us to load two elements
		 * in addition to the currently active element.  We
		 * store the bottom byte of the next S/G pointer in
		 * the SG_CACEPTR register so we can restore the
		 * correct value when the DMA completes.  If the next
		 * sg ptr value has advanced to the point where higher
		 * bytes in the address have been affected, fix them
		 * too.
		 */
		test	SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
		test	SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
		add	SCB_RESIDUAL_SGPTR[1], -1;
		adc	SCB_RESIDUAL_SGPTR[2], -1; 
		adc	SCB_RESIDUAL_SGPTR[3], -1;
d985 5
a989 5
		and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
		clr	DATA_COUNT_ODD;
		test	SG_CACHE_SHADOW, ODD_SEG jz . + 2;
		or	DATA_COUNT_ODD, 0x1;
		clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
d991 8
a998 8
		/*
		 * Go ahead and shut down the DMA engine now.
		 * In the future, we'll want to handle end of
		 * transfer messages prior to doing this, but this
		 * requires similar restructuring for pre-ULTRA2
		 * controllers.
		 */
		test	DMAPARAMS, DIRECTION jnz ultra2_fifoempty;
d1000 40
a1039 40
		if ((ahc->features & AHC_DT) == 0) {
			if ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0) {
				/*
				 * On Rev A of the aic7890, the autoflush
				 * feature doesn't function correctly.
				 * Perform an explicit manual flush.  During
				 * a manual flush, the FIFOEMP bit becomes
				 * true every time the PCI FIFO empties
				 * regardless of the state of the SCSI FIFO.
				 * It can take up to 4 clock cycles for the
				 * SCSI FIFO to get data into the PCI FIFO
				 * and for FIFOEMP to de-assert.  Here we
				 * guard against this condition by making
				 * sure the FIFOEMP bit stays on for 5 full
				 * clock cycles.
				 */
				or	DFCNTRL, FIFOFLUSH;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
				test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
			}
			test	DFSTATUS, FIFOEMP jz ultra2_fifoflush;
		} else {
			/*
			 * We enable the auto-ack feature on DT capable
			 * controllers.  This means that the controller may
			 * have already transferred some overrun bytes into
			 * the data FIFO and acked them on the bus.  The only
			 * way to detect this situation is to wait for
			 * LAST_SEG_DONE to come true on a completed transfer
			 * and then test to see if the data FIFO is non-empty.
			 */
			test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
			test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
			/* Overrun */
			jmp	data_phase_loop;
			test	DFSTATUS, FIFOEMP jz .;
		}
d1041 2
a1042 2
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz ultra2_fifoempty;
d1044 37
a1080 37
		and     DFCNTRL, ~(SCSIEN|HDMAEN);
		test	DFCNTRL, SCSIEN|HDMAEN jnz .;
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			/*
			 * Keep HHADDR cleared for future, 32bit addressed
			 * only, DMA operations.
			 *
			 * Due to bayonette style S/G handling, our residual
			 * data must be "fixed up" once the transfer is halted.
			 * Here we fixup the HSHADDR stored in the high byte
			 * of the residual data cnt.  By postponing the fixup,
			 * we can batch the clearing of HADDR with the fixup.
			 * If we halted on the last segment, the residual is
			 * already correct.   If we are not on the last
			 * segment, copy the high address directly from HSHADDR.
			 * We don't need to worry about maintaining the
			 * SG_LAST_SEG flag as it will always be false in the
			 * case where an update is required.
			 */
			or	DSCOMMAND1, HADDLDSEL0;
			test	SG_CACHE_SHADOW, LAST_SEG jnz . + 2;
			mov	SCB_RESIDUAL_DATACNT[3], SHADDR;
			clr	HADDR;
			and	DSCOMMAND1, ~HADDLDSEL0;
		}
	} else {
		/* If we are the last SG block, tell the hardware. */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_RESIDUAL, 0xFF jnz dma_mid_sg;
		}
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz dma_mid_sg;
		if ((ahc->flags & AHC_TARGETROLE) != 0) {
			test	SSTAT0, TARGET jz dma_last_sg;
			if ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0) {
				test	DMAPARAMS, DIRECTION jz dma_mid_sg;
			}
d1085 1
a1085 1
		/* Start DMA data transfer. */
d1088 5
a1092 5
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			call	idle_loop;
		}
		test	SSTAT0,DMADONE	jnz dma_dmadone;
		test	SSTAT1,PHASEMIS	jz dma_loop;	/* ie. underrun */
d1094 8
a1101 8
		/*
		 * We will be "done" DMAing when the transfer count goes to
		 * zero, or the target changes the phase (in light of this,
		 * it makes sense that the DMA circuitry doesn't ACK when
		 * PHASEMIS is active).  If we are doing a SCSI->Host transfer,
		 * the data FIFO should be flushed auto-magically on STCNT=0
		 * or a phase change, so just wait for FIFO empty status.
		 */
d1103 1
a1103 1
		test	DFCNTRL,DIRECTION	jnz dma_fifoempty;
d1105 1
a1105 1
		test	DFSTATUS,FIFOEMP	jz dma_fifoflush;
d1107 2
a1108 2
		/* Don't clobber an inprogress host data transfer */
		test	DFSTATUS, MREQPEND	jnz dma_fifoempty;
d1110 6
a1115 6
		/*
		 * Now shut off the DMA and make sure that the DMA
		 * hardware has actually stopped.  Touching the DMA
		 * counters, etc. while a DMA is active will result
		 * in an ILLSADDR exception.
		 */
d1117 1
a1117 1
		and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
d1119 38
a1156 38
		/*
		 * Some revisions of the aic78XX have a problem where, if the
		 * data fifo is full, but the PCI input latch is not empty, 
		 * HDMAEN cannot be cleared.  The fix used here is to drain
		 * the prefetched but unused data from the data fifo until
		 * there is space for the input latch to drain.
		 */
		if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
			mov	NONE, DFDAT;
		}
		test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz dma_halt;

		/* See if we have completed this last segment */
		test	STCNT[0], 0xff	jnz data_phase_finish;
		test	STCNT[1], 0xff	jnz data_phase_finish;
		test	STCNT[2], 0xff	jnz data_phase_finish;

		/*
		 * Advance the scatter-gather pointers if needed 
		 */
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			test	MWI_RESIDUAL, 0xFF jz no_mwi_resid;
			/*
			 * Reload HADDR from SHADDR and setup the
			 * count to be the size of our residual.
			 */
			if ((ahc->features & AHC_CMD_CHAN) != 0) {
				bmov	HADDR, SHADDR, 4;
				mov	HCNT, MWI_RESIDUAL;
				bmov	HCNT[1], ALLZEROS, 2;
			} else {
				mvi	DINDEX, HADDR;
				mvi	SHADDR call bcopy_4;
				mov	MWI_RESIDUAL call set_hcnt;
			}
			clr	MWI_RESIDUAL;
			jmp	sg_load_done;
d1158 4
a1161 4
		}
		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz sg_load;
		or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL;
		jmp	data_phase_finish;
d1164 52
a1215 52
		 * Load the next SG element's data address and length
		 * into the DMA engine.  If we don't have hardware
		 * to perform a prefetch, we'll have to fetch the
		 * segment from host memory first.
		 */
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			/* Wait for the idle loop to complete */
			test	CCSGCTL, CCSGEN jz . + 3;
			call	idle_loop;
			test	CCSGCTL, CCSGEN jnz . - 1;
			bmov 	HADDR, CCSGRAM, 7;
			/*
			 * Workaround for flaky external SCB RAM
			 * on certain aic7895 setups.  It seems
			 * unable to handle direct transfers from
			 * S/G ram to certain SCB locations.
			 */
			mov	SINDEX, CCSGRAM;
			mov	SCB_RESIDUAL_DATACNT[3], SINDEX;
		} else {
			if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
				mov	ALLZEROS call set_hhaddr;
			}
			mvi	DINDEX, HADDR;
			mvi	SCB_RESIDUAL_SGPTR	call bcopy_4;

			mvi	SG_SIZEOF	call set_hcnt;

			or	DFCNTRL, HDMAEN|DIRECTION|FIFORESET;

			call	dma_finish;

			mvi	DINDEX, HADDR;
			call	dfdat_in_7;
			mov	SCB_RESIDUAL_DATACNT[3], DFDAT;
		}

		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	SCB_RESIDUAL_DATACNT[3] call set_hhaddr;

			/*
			 * The lowest address byte must be loaded
			 * last as it triggers the computation of
			 * some items in the PCI block.  The ULTRA2
			 * chips do this on PRELOAD.
			 */
			mov	HADDR, HADDR;
		}
		if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
		  && ahc->pci_cachesize != 0) {
			call calc_mwi_residual;
		}
d1217 2
a1218 2
		/* Point to the new next sg in memory */
		call	sg_advance;
d1226 7
a1232 7
		/* Track odd'ness */
		test	HCNT[0], 0x1 jz . + 2;
		xor	DATA_COUNT_ODD, 0x1;

		if ((ahc->flags & AHC_TARGETROLE) != 0) {
			test	SSTAT0, TARGET jnz data_phase_loop;
		}
d1235 18
a1252 18
	/*
	 * If the target has left us in data phase, loop through
	 * the DMA code again.  In the case of ULTRA2 adapters,
	 * we should only loop if there is a data overrun.  For
	 * all other adapters, we'll loop after each S/G element
	 * is loaded as well as if there is an overrun.
	 */
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
		test	SSTAT0, TARGET jnz data_phase_done;
	}
	if ((ahc->flags & AHC_INITIATORROLE) != 0) {
		test	SSTAT1, REQINIT jz .;
		if ((ahc->features & AHC_DT) == 0) {
			test	SSTAT1,PHASEMIS	jz data_phase_loop;
		} else {
			test	SCSIPHASE, DATA_PHASE_MASK jnz data_phase_loop;
		}
	}
d1255 42
a1296 42
	/*
	 * After a DMA finishes, save the SG and STCNT residuals back into
	 * the SCB.  We use STCNT instead of HCNT, since it's a reflection
	 * of how many bytes were transferred on the SCSI (as opposed to the
	 * host) bus.
	 */
	if ((ahc->features & AHC_CMD_CHAN) != 0) {
		/* Kill off any pending prefetch */
		call	disable_ccsgen;
	}

	if ((ahc->features & AHC_ULTRA2) == 0) {
		/*
		 * Clear the high address byte so that all other DMA
		 * operations, which use 32bit addressing, can assume
		 * HHADDR is 0.
		 */
		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
			mov	ALLZEROS call set_hhaddr;
		}
	}

	/*
	 * Update our residual information before the information is
	 * lost by some other type of SCSI I/O (e.g. PIO).  If we have
	 * transferred all data, no update is needed.
	 *
	 */
	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jnz residual_update_done;
	if ((ahc->bugs & AHC_PCI_MWI_BUG) != 0
	  && ahc->pci_cachesize != 0) {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			test	MWI_RESIDUAL, 0xFF jz bmov_resid;
		}
		mov	A, MWI_RESIDUAL;
		add	SCB_RESIDUAL_DATACNT[0], A, STCNT[0];
		clr	A;
		adc	SCB_RESIDUAL_DATACNT[1], A, STCNT[1];
		adc	SCB_RESIDUAL_DATACNT[2], A, STCNT[2];
		clr	MWI_RESIDUAL;
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			jmp	. + 2;
d1298 8
a1305 8
			bmov	SCB_RESIDUAL_DATACNT, STCNT, 3;
		}
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	SCB_RESIDUAL_DATACNT, STCNT, 3;
	} else {
		mov	SCB_RESIDUAL_DATACNT[0], STCNT[0];
		mov	SCB_RESIDUAL_DATACNT[1], STCNT[1];
		mov	SCB_RESIDUAL_DATACNT[2], STCNT[2];
d1308 5
a1312 5
	/*
	 * Since we've been through a data phase, the SCB_RESID* fields
	 * are now initialized.  Clear the full residual flag.
	 */
	and	SCB_SGPTR[0], ~SG_FULL_RESID;
d1315 2
a1316 2
		/* Clear the channel in case we return to data phase later */
		or	SXFRCTL0, CLRSTCNT|CLRCHN;
d1320 1
a1320 1
	if ((ahc->flags & AHC_TARGETROLE) != 0) {
d1325 1
a1325 2
		 * initiator before changing phase.  We only need to
		 * send Ignore Wide Residue messages for data-in phases.
a1328 8
		test	DATA_COUNT_ODD, 0x1 jz target_ITloop;
		test	SCSIRATE, WIDEXFER jz target_ITloop;
		/*
		 * Issue an Ignore Wide Residue Message.
		 */
		mvi	P_MESGIN|BSYO call change_phase;
		mvi	MSG_IGN_WIDE_RESIDUE call target_outb;
		mvi	1 call target_outb;
d1330 2
a1331 2
	} else {
		jmp	ITloop;
d1339 2
a1340 2
	test	SEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;
	mvi	PROTO_VIOLATION call set_seqint;
d1343 14
a1356 14
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HCNT[0], SCB_CDB_LEN,  1;
		bmov	HCNT[1], ALLZEROS, 2;
		mvi	SG_CACHE_PRE, LAST_SEG;
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		bmov	STCNT[0], SCB_CDB_LEN, 1;
		bmov	STCNT[1], ALLZEROS, 2;
	} else {
		mov	STCNT[0], SCB_CDB_LEN;
		clr	STCNT[1];
		clr	STCNT[2];
	}
	add	NONE, -13, SCB_CDB_LEN;
	mvi	SCB_CDB_STORE jnc p_command_embedded;
d1358 15
a1372 15
	if ((ahc->features & AHC_ULTRA2) != 0) {
		bmov	HADDR[0], SCB_CDB_PTR, 4;
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN|DIRECTION);
	} else {
		if ((ahc->features & AHC_CMD_CHAN) != 0) {
			bmov	HADDR[0], SCB_CDB_PTR, 4;
			bmov	HCNT, STCNT, 3;
		} else {
			mvi	DINDEX, HADDR;
			mvi	SCB_CDB_PTR call bcopy_4;
			mov	SCB_CDB_LEN call set_hcnt;
		}
		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
	}
	jmp	p_command_xfer;
d1374 4
a1377 4
	/*
	 * The data fifo seems to require 4 byte aligned
	 * transfers from the sequencer.  Force this to
	 * be the case by clearing HADDR[0] even though
d1379 16
a1394 16
	 */
	clr	HADDR[0];
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mvi	DFCNTRL, (PRELOADEN|SCSIEN|DIRECTION);
		bmov	DFDAT, SCB_CDB_STORE, 12; 
	} else if ((ahc->features & AHC_CMD_CHAN) != 0) {
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			/*
			 * On the 7895 the data FIFO will
			 * get corrupted if you try to dump
			 * data from external SCB memory into
			 * the FIFO while it is enabled.  So,
			 * fill the fifo and then enable SCSI
			 * transfers.
			 */
			mvi	DFCNTRL, (DIRECTION|FIFORESET);
d1398 24
a1421 32
		bmov	DFDAT, SCB_CDB_STORE, 12; 
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFOFLUSH);
		} else {
			or	DFCNTRL, FIFOFLUSH;
		}
	} else {
		mvi	DFCNTRL, (SCSIEN|SDMAEN|DIRECTION|FIFORESET);
		call	copy_to_fifo_6;
		call	copy_to_fifo_6;
		or	DFCNTRL, FIFOFLUSH;
	}
p_command_xfer:
	and	SEQ_FLAGS, ~NO_CDB_SENT;
	if ((ahc->features & AHC_DT) == 0) {
		test	SSTAT0, SDONE jnz . + 2;
		test    SSTAT1, PHASEMIS jz . - 1;
		/*
		 * Wait for our ACK to go-away on it's own
		 * instead of being killed by SCSIEN getting cleared.
		 */
		test	SCSISIGI, ACKI jnz .;
	} else {
		test	DFCNTRL, SCSIEN jnz .;
	}
	test	SSTAT0, SDONE jnz p_command_successful;
	/*
	 * Don't allow a data phase if the command
	 * was not fully transferred.
	 */
	or	SEQ_FLAGS, NO_CDB_SENT;
p_command_successful:
d1424 4
d1435 2
a1436 1
	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
d1438 1
a1438 2
	mov	SCB_SCSI_STATUS, SCSIDATL;
	or	SCB_CONTROL, STATUS_RCVD;
d1466 6
a1471 6
	/* Turn on ATN for the retry */
	if ((ahc->features & AHC_DT) == 0) {
		or	SCSISIGO, ATNO, LASTPHASE;
	} else {
		mvi	SCSISIGO, ATNO;
	}
d1477 3
a1479 3
	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
	test	SCB_CONTROL, DISCENB jnz . + 2;
	and	SINDEX, ~DISCENB;
d1529 1
a1529 1
	cmp	A,MSG_IGN_WIDE_RESIDUE	je mesgin_ign_wide_residue;
d1542 1
a1542 1
	mvi	HOST_MSG_LOOP call set_seqint;
d1549 8
a1556 8
	test	SCSIRATE, WIDEXFER jz mesgin_reject;
	/* Pull the residue byte */
	mvi	ARG_1	call inb_next;
	cmp	ARG_1, 0x01 jne mesgin_reject;
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
	test	DATA_COUNT_ODD, 0x1	jz mesgin_done;
	mvi	IGN_WIDE_RES call set_seqint;
	jmp	mesgin_done;
a1558 3
mesgin_proto_violation:
	mvi	PROTO_VIOLATION call set_seqint;
	jmp	mesgin_done;
d1560 1
a1560 1
	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
d1565 1
a1577 1
mesgin_complete:
d1579 10
a1588 10
	/*
	 * If ATN is raised, we still want to give the target a message.
	 * Perhaps there was a parity error on this last message byte.
	 * Either way, the target should take us to message out phase
	 * and then attempt to complete the command again.  We should use a
	 * critical section here to guard against a timeout triggering
	 * for this command and setting ATN while we are still processing
	 * the completion.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */
d1590 5
a1594 6
	/*
	 * If we are identified and have successfully sent the CDB,
	 * any status will do.  Optimize this fast path.
	 */
	test	SCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;
	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted; 
d1596 6
a1601 26
	/*
	 * If the target never sent an identify message but instead went
	 * to mesgin to give an invalid message, let the host abort us.
	 */
	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;

	/*
	 * If we recevied good status but never successfully sent the
	 * cdb, abort the command.
	 */
	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;

complete_accepted:
	/*
	 * See if we attempted to deliver a message but the target ingnored us.
	 */
	test	SCB_CONTROL, MK_MESSAGE jz . + 2;
	mvi	MKMSG_FAILED call set_seqint;

	/*
	 * Check for residuals
	 */
	test	SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
d1603 1
a1603 1
	test	SCB_SCSI_STATUS,0xff	jz complete;	/* Good Status? */
d1605 1
a1605 1
	or	SCB_SGPTR, SG_RESID_VALID;
d1608 2
a1609 2
	test	SCB_SCSI_STATUS, 0xff	jz complete;	/* Just a residual? */
	mvi	BAD_STATUS call set_seqint;		/* let driver know */
d1611 1
a1611 1
	call	add_scb_to_free_list;
d1642 11
a1652 11
	/*
	 * If ATN is raised, we still want to give the target a message.
	 * Perhaps there was a parity error on this last message byte
	 * or we want to abort this command.  Either way, the target
	 * should take us to message out phase and then attempt to
	 * disconnect again.
	 * XXX - Wait for more testing.
	test	SCSISIGI, ATNI jnz mesgin_done;
	 */
	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT
		jnz mesgin_proto_violation;
d1654 7
a1660 7
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		call	add_scb_to_disc_list;
	}
	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
	mov	ARG_1, SCB_TAG;
	mov	SAVED_LUN, SCB_LUN;
	mov	SCB_SCSIID	call set_busy_target;
d1674 19
a1692 19
	if ((ahc->features & AHC_ULTRA2) != 0) {
		mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
		test	SEQ_FLAGS, DPHASE	jz ITloop;
	} else {
		test	SEQ_FLAGS, DPHASE	jz mesgin_done;
	}

	/*
	 * If we are asked to save our position at the end of the
	 * transfer, just mark us at the end rather than perform a
	 * full save.
	 */
	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz mesgin_sdptrs_full;
	or	SCB_SGPTR, SG_LIST_NULL;
	if ((ahc->features & AHC_ULTRA2) != 0) {
		jmp	ITloop;
	} else {
		jmp	mesgin_done;
	}
d1696 3
a1698 3
	/*
	 * The SCB_SGPTR becomes the next one we'll download,
	 * and the SCB_DATAPTR becomes the current SHADDR.
d1704 4
a1707 4
		if ((ahc->features & AHC_ULTRA2) == 0) {
			mov	NONE,SCSIDATL;	/*dummy read from latch to ACK*/
		}
		bmov	SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8;
d1710 3
a1712 3
		mvi	SHADDR call bcopy_4;
		mov	NONE,SCSIDATL;	/*dummy read from latch to ACK*/
		mvi	SCB_RESIDUAL_DATACNT call bcopy_8;
d1714 1
a1714 1
	jmp	ITloop;
d1720 1
a1720 2
 * code do the rest.  We also reset/reallocate the FIFO to make
 * sure we have a clean start for the next data or command phase.
a1727 1
	or	SXFRCTL0, CLRSTCNT|CLRCHN;
d1735 8
a1742 8
	shr	DINDEX, 4, SINDEX;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	SCBPTR, SAVED_LUN;
		add	DINDEX, SCB_64_BTT;
	} else {
		add	DINDEX, BUSY_TARGETS;
	}
	mov	DINDIR, ARG_1 ret;
d1750 34
a1783 34
	/*
	 * Determine whether a target is using tagged or non-tagged
	 * transactions by first looking at the transaction stored in
	 * the busy target array.  If there is no untagged transaction
	 * for this target or the transaction is for a different lun, then
	 * this must be a tagged transaction.
	 */
	shr	SINDEX, 4, SAVED_SCSIID;
	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		add	SINDEX, SCB_64_BTT;
		mov	SCBPTR, SAVED_LUN;
		if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
			add	NONE, -SCB_64_BTT, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
			add	NONE, -(SCB_64_BTT + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
		}
	} else {
		add	SINDEX, BUSY_TARGETS;
		if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
			add	NONE, -BUSY_TARGETS, SINDEX;
			jc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
			add	NONE, -(BUSY_TARGETS + 16), SINDEX;
			jnc	. + 2;
			mvi	INTSTAT, OUT_OF_RANGE;
			nop;
		}
d1785 1
a1785 1
	mov	ARG_1, SINDIR;
d1788 24
a1811 24
		mov	ARG_1 call findSCB;
	} else {
		mov	SCBPTR, ARG_1;
	}
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		jmp setup_SCB_id_lun_okay;
	} else {
		/*
		 * We only allow one untagged command per-target
		 * at a time.  So, if the lun doesn't match, look
		 * for a tag message.
		 */
		mov	A, SCB_LUN;
		cmp	SAVED_LUN, A	je setup_SCB_id_lun_okay;
		if ((ahc->flags & AHC_PAGESCBS) != 0) {
			/*
			 * findSCB removes the SCB from the
			 * disconnected list, so we must replace
			 * it there should this SCB be for another
			 * lun.
			 */
			call	cleanup_scb;
		}
	}
d1822 3
a1824 3
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x80;
	}
d1827 3
a1829 3
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x1;
	}
d1831 3
a1833 3
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x2;
	}
d1836 7
a1842 7
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		mvi	ARG_1	call inb_next;	/* tag value */
		mov	ARG_1	call findSCB;
	} else {
		mvi	ARG_1	call inb_next;	/* tag value */
		mov	SCBPTR, ARG_1;
	}
d1849 8
a1856 8
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x4;
	}
	mov	A, SCB_SCSIID;
	cmp	SAVED_SCSIID, A	jne not_found_cleanup_scb;
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x8;
	}
d1858 2
a1859 2
	mov	A, SCB_LUN;
	cmp	SAVED_LUN, A	jne not_found_cleanup_scb;
d1861 3
a1863 3
	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
		or	SEQ_FLAGS, 0x10;
	}
d1866 9
a1874 9
	test	SCB_CONTROL, TAG_ENB	jnz setup_SCB_tagged;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	A, SCBPTR;
	}
	mvi	ARG_1, SCB_LIST_NULL;
	mov	SAVED_SCSIID	call	set_busy_target;
	if ((ahc->flags & AHC_SCB_BTT) != 0) {
		mov	SCBPTR, A;
	}
d1876 1
a1876 1
	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
d1884 3
a1886 3
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		call	cleanup_scb;
	}
d1888 1
a1888 1
	mvi	NO_MATCH call set_seqint;
d1892 5
a1896 5
	if ((ahc->features & AHC_DT) == 0) {
		or	SCSISIGO, ATNO, LASTPHASE;
	} else {
		mvi	SCSISIGO, ATNO;
	}
d1915 1
a1915 1
	mvi	PERR_DETECTED call set_seqint;
d1954 1
a1954 1
	 * we must wait at least a data release delay plus
d1987 5
a1991 5
	mov	A, SINDEX;			/* Tag passed in SINDEX */
	cmp	DISCONNECTED_SCBH, SCB_LIST_NULL je findSCB_notFound;
	mov	SCBPTR, DISCONNECTED_SCBH;	/* Initialize SCBPTR */
	mvi	ARG_2, SCB_LIST_NULL;		/* Head of list */
	jmp	findSCB_loop;
d1993 1
a1993 1
	cmp	SCB_NEXT, SCB_LIST_NULL je findSCB_notFound;
d1997 1
a1997 1
	cmp	SCB_TAG, A	jne findSCB_next;
d2001 1
a2001 1
	mov	SINDEX, SCBPTR;
d2009 5
a2013 5
	/*
	 * We didn't find it.  Page in the SCB.
	 */
	mov	ARG_1, A; /* Save tag */
	mov	ALLZEROS call get_free_or_disc_scb;
d2026 1
a2026 1
		mvi	SHARED_DATA_ADDR call	set_1byte_addr;
d2031 2
a2032 2
		mvi	SHARED_DATA_ADDR call	set_1byte_addr;
		mvi	1	call set_hcnt;
d2049 1
a2049 1
	mvi	PERR_DETECTED call set_seqint;
d2059 3
a2061 3
	if ((ahc->features & AHC_DT) == 0) {
		and	SCSISIGO, PHASE_MASK, SCSISIGI;
	}
d2066 1
a2066 1
	mov	HCNT[0], SINDEX;
d2068 2
a2069 2
	clr	HCNT[1];
	clr	HCNT[2] ret;
d2077 1
a2077 1
	mov	DINDIR, SINDIR;
d2142 5
a2146 5
		if ((ahc->flags & AHC_SCB_BTT) != 0) {
			mvi	CCHCNT, SCB_DOWNLOAD_SIZE_64;
		} else {
			mvi	CCHCNT, SCB_DOWNLOAD_SIZE;
		}
d2151 2
a2152 2
		mvi	CCHCNT, SCB_UPLOAD_SIZE;
		if ((ahc->features & AHC_ULTRA2) == 0) {
d2154 1
a2154 1
			bmov	CCSCBRAM, SCB_BASE, SCB_UPLOAD_SIZE;
d2157 6
a2162 6
		} else if ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0) {
			mvi	CCSCBCTL, CCARREN|CCSCBRESET;
			cmp	CCSCBCTL, ARRDONE|CCARREN jne .;
			mvi	CCHCNT, SCB_UPLOAD_SIZE;
			mvi	CCSCBCTL, CCSCBEN|CCSCBRESET;
			cmp	CCSCBCTL, CCSCBDONE|CCSCBEN jne .;
d2174 1
a2174 1
		mvi	SCB_DOWNLOAD_SIZE call set_hcnt;
d2179 2
a2180 2
		mvi	SINDEX, SCB_BASE;
		add	A, SCB_DOWNLOAD_SIZE, SINDEX;
d2182 1
a2182 1
		call	copy_to_fifo_8;
d2185 1
a2185 1
		jmp	dma_finish;
d2187 19
a2205 19
		mvi	DINDEX, SCB_BASE;
		if ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0) {
			/*
			 * The PCI module will only issue a PCI
			 * retry if the data FIFO is empty.  If the
			 * host disconnects in the middle of a
			 * transfer, we must empty the fifo of all
			 * available data to force the chip to
			 * continue the transfer.  This does not
			 * happen for SCSI transfers as the SCSI module
			 * will drain the FIFO as data are made available.
			 * When the hang occurs, we know that a multiple
			 * of 8 bytes is in the FIFO because the PCI
			 * module has an 8 byte input latch that only
			 * dumps to the FIFO when HCNT == 0 or the
			 * latch is full.
			 */
			clr	A;
			/* Wait for at least 8 bytes of data to arrive. */
d2207 1
a2207 1
			test	DFSTATUS, FIFOQWDEMP jnz dma_scb_hang_fifo;
d2209 8
a2216 8
			test	DFSTATUS, MREQPEND jnz dma_scb_hang_wait;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			test	DFSTATUS, HDONE	jnz dma_scb_hang_dma_done;
			/*
			 * The PCI module no longer intends to perform
			 * a PCI transaction.  Drain the fifo.
			 */
d2218 11
a2228 11
			not	A, HCNT;
			add	A, SCB_DOWNLOAD_SIZE+SCB_BASE+1;
			and	A, ~0x7;
			mov	DINDIR,DFDAT;
			cmp	DINDEX, A jne . - 1;
			cmp	DINDEX, SCB_DOWNLOAD_SIZE+SCB_BASE
				je	dma_finish_nowait;
			/* Restore A as the lines left to transfer. */
			add	A, -SCB_BASE, DINDEX;
			shr	A, 3;
			jmp	dma_scb_hang_fifo;
d2230 10
a2239 9
			and	DFCNTRL, ~HDMAEN;
			test	DFCNTRL, HDMAEN jnz .;
			add	SEQADDR0, A;
		} else {
			call	dma_finish;
		}
		call	dfdat_in_8;
		call	dfdat_in_8;
		call	dfdat_in_8;
d2241 1
a2241 1
		mov	DINDIR,DFDAT;
d2254 2
a2255 2
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
d2257 1
a2257 1
	mov	DFDAT,SINDIR;
d2259 1
a2259 1
	mov	DFDAT,SINDIR;
d2261 4
a2264 4
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR;
	mov	DFDAT,SINDIR ret;
d2285 3
a2287 3
	if ((ahc->flags & AHC_PAGESCBS) != 0) {
		test	SCB_CONTROL,DISCONNECTED jnz add_scb_to_disc_list;
	}
d2301 3
a2303 3
	or	DSCOMMAND1, HADDLDSEL0;
	and	HADDR, SG_HIGH_ADDR_BITS, SINDEX;
	and	DSCOMMAND1, ~HADDLDSEL0 ret;
d2312 1
a2312 1
	mvi	NO_FREE_SCB call set_seqint;
d2316 1
a2316 1
	mov	DISCONNECTED_SCBH, SCB_NEXT;
d2319 1
a2319 1
	mov	SCB_TAG	jmp dma_scb;
d2338 2
a2339 2
	mov	INTSTAT, SINDEX;
	nop;
d2341 1
a2341 1
	ret;
@


1.6.14.7
log
@Merge with the trunk
@
text
@a682 1
	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT;
d1102 1
a1102 1
			if ((ahc->bugs & AHC_TMODE_WIDEODD_BUG) != 0) {
@


1.5
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic7xxx.seq,v 1.6 1996/10/08 03:04:06 gibbs Exp $	*/
d49 4
a52 1
#if defined(__NetBSD__)
@


1.4
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d1 3
d43 2
d47 1
a47 1
VERSION AIC7XXX_SEQ_VER "$Id: aic7xxx.seq,v 1.42 1996/06/09 17:29:11 gibbs Exp $"
d50 2
a51 1
#include "../../../../dev/ic/aic7xxxreg.h"
d54 1
a195 10
	test	SCB_CMDLEN,0xff jnz mk_identify	/* 0 Length Command? */

/*
 * The kernel has sent us an SCB with no command attached.  This implies
 * that the kernel wants to send a message of some sort to this target,
 * so we interrupt the driver, allow it to fill the message buffer, and
 * then go back into the arbitration loop
 */
	mvi     INTSTAT,AWAITING_MSG
	jmp     wait_for_selection
d202 1
a202 1
	or	MSG0,MSG_IDENTIFY
a204 1
	test	SCB_CONTROL,0xb0 jz  !message	/* WDTR, SDTR or TAG?? */
a208 1

d210 1
a211 1
	test	SCB_CONTROL,TAG_ENB jz mk_tag_done
d217 6
a222 1
mk_tag_done:
d224 1
a224 2
	test	SCB_CONTROL,0x90 jz !message	/* NEEDWDTR|NEEDSDTR */
	mov	DINDEX	call mk_dtr	/* build DTR message if needed */
a225 1
!message:
d512 1
a512 1
	mvi	MSG_NOP		call mk_mesg	/* build NOP message */
d570 1
a570 1
	test	A,MSG_IDENTIFY		jnz mesgin_identify
d572 1
a572 1
	cmp	A,MSG_SDPTRS		je mesgin_sdptrs
d574 1
a574 1
	cmp	A,MSG_RDPTRS		je mesgin_rdptrs
d576 1
a576 1
	cmp	A,MSG_REJECT		je mesgin_reject
d590 1
a590 1
	mvi	MSG_REJECT	call mk_mesg
d666 4
a669 5
 * Is it an extended message?  We only support the synchronous and wide data
 * transfer request messages, which will probably be in response to
 * WDTR or SDTR message outs from us.  If it's not SDTR or WDTR, reject it -
 * apparently this can be done after any message in byte, according
 * to the SCSI-2 spec.
d672 26
a697 38
	mvi	ARG_1		call inb_next	/* extended message length */
	mvi	REJBYTE_EXT	call inb_next	/* extended message code */

	cmp	REJBYTE_EXT,MSG_SDTR	je p_mesginSDTR
	cmp	REJBYTE_EXT,MSG_WDTR	je p_mesginWDTR
	jmp	rej_mesgin

p_mesginWDTR:
	cmp	ARG_1,2		jne rej_mesgin	/* extended mesg length=2 */
	mvi	ARG_1		call inb_next	/* Width of bus */
	mvi	INTSTAT,WDTR_MSG		/* let driver know */
	test	RETURN_1,0xff jz mesgin_done	/* Do we need to send WDTR? */
	cmp	RETURN_1,SEND_REJ je rej_mesgin /*
						 * Bus width was too large 
						 * Reject it.
						 */

/* We didn't initiate the wide negotiation, so we must respond to the request */
	and	RETURN_1,0x7f			/* Clear the SEND_WDTR Flag */
	mvi	DINDEX,MSG0
	mvi	MSG0	call mk_wdtr		/* build WDTR message */
	or	SCSISIGO,ATNO			/* turn on ATNO */
	jmp	mesgin_done

p_mesginSDTR:
	cmp	ARG_1,3		jne rej_mesgin	/* extended mesg length=3 */
	mvi	ARG_1		call inb_next	/* xfer period */
	mvi	A		call inb_next	/* REQ/ACK offset */
	mvi	INTSTAT,SDTR_MSG		/* call driver to convert */

	test	RETURN_1,0xff	jz mesgin_done  /* Do we need to mk_sdtr/rej */
	cmp	RETURN_1,SEND_REJ je rej_mesgin /*
						 * Requested SDTR too small
						 * Reject it.
						 */
	clr	ARG_1				/* Use the scratch ram rate */
	mvi	DINDEX, MSG0
	mvi     MSG0     call mk_sdtr
d771 5
a775 5
	test	SSTAT1,BUSFREE	jnz use_findSCB
	test	SSTAT1,REQINIT	jz snoop_tag_loop
	test	SSTAT1,PHASEMIS	jnz use_findSCB
	mvi	A		call inb_first
	cmp	A,MSG_SIMPLE_TAG jne use_findSCB
d935 1
a935 1

a1074 65

/*
 * If we need to negotiate transfer parameters, build the WDTR or SDTR message
 * starting at the address passed in SINDEX.  DINDEX is modified on return.
 * The SCSI-II spec requires that Wide negotiation occur first and you can
 * only negotiat one or the other at a time otherwise in the event of a message
 * reject, you wouldn't be able to tell which message was the culpret.
 */
mk_dtr:
	test	SCB_CONTROL,NEEDWDTR jnz  mk_wdtr_16bit
	mvi	ARG_1, MAXOFFSET	/* Force an offset of 15 or 8 if WIDE */

mk_sdtr:
	mvi	DINDIR,1		/* extended message */
	mvi	DINDIR,3		/* extended message length = 3 */
	mvi	DINDIR,1		/* SDTR code */
	call	sdtr_to_rate
	mov	DINDIR,RETURN_1		/* REQ/ACK transfer period */
	cmp	ARG_1, MAXOFFSET je mk_sdtr_max_offset
	and	DINDIR,0x0f,SINDIR	/* Sync Offset */

mk_sdtr_done:
	add	MSG_LEN,COMP_MSG0,DINDEX ret	/* update message length */

mk_sdtr_max_offset:
/*
 * We're initiating sync negotiation, so request the max offset we can (15 or 8)
 */
	/* Talking to a WIDE device? */
	test	SCSIRATE, WIDEXFER	jnz wmax_offset	
	mvi	DINDIR, MAX_OFFSET_8BIT
	jmp	mk_sdtr_done

wmax_offset:
	mvi	DINDIR, MAX_OFFSET_16BIT
	jmp	mk_sdtr_done

mk_wdtr_16bit:
	mvi	ARG_1,BUS_16_BIT
mk_wdtr:
	mvi	DINDIR,1		/* extended message */
	mvi	DINDIR,2		/* extended message length = 2 */
	mvi	DINDIR,3		/* WDTR code */
	mov	DINDIR,ARG_1		/* bus width */

	add	MSG_LEN,COMP_MSG0,DINDEX ret	/* update message length */
	
sdtr_to_rate:
	call	ndx_dtr			/* index scratch space for target */
	shr	A,SINDIR,0x4
	dec	SINDEX			/* Preserve SINDEX */
	and	A,0x7
	clr	RETURN_1
sdtr_to_rate_loop:
	test	A,0x0f	jz sdtr_to_rate_done
	add	RETURN_1,0x19
	dec	A	
	jmp	sdtr_to_rate_loop
sdtr_to_rate_done:
	shr	RETURN_1,0x2
	add	RETURN_1,0x19
	test	SXFRCTL0,ULTRAEN jz return
	shr	RETURN_1,0x1
return:
	ret
@


1.3
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: aic7xxx.seq,v 1.3 1996/05/20 00:48:45 thorpej Exp $	*/

d42 1
a42 1
VERSION AIC7XXX_SEQ_VER "$NetBSD: aic7xxx.seq,v 1.3 1996/05/20 00:48:45 thorpej Exp $"
d86 5
d265 17
a287 1

d311 1
d343 14
d363 3
d467 8
d534 1
d904 1
@


1.2
log
@ahc/ahe driver update from freebsd; merged by soda@@sra.co.jp and
pete@@demon.net
@
text
@d1 2
d44 1
a44 1
VERSION AIC7XXX_SEQ_VER "$Id: aic7xxx.seq,v 1.33 1996/04/20 21:20:29 gibbs Exp $"
d47 1
a47 1
#include "../../../../dev/microcode/aic7xxx/aic7xxx_reg.h"
d402 1
a402 1
#ifdef linux
@


1.1
log
@Initial revision
@
text
@d1 82
a82 260
##+M#########################################################################
# Adaptec 274x/284x/294x device driver for Linux and FreeBSD.
#
# Copyright (c) 1994 John Aycock
#   The University of Calgary Department of Computer Science.
#   All rights reserved.
#
# Modifications/enhancements:
#   Copyright (c) 1994, 1995 Justin Gibbs. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions, and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed by the University of Calgary
#      Department of Computer Science and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# FreeBSD, Twin, Wide, 2 command per target support, tagged queuing and other 
# optimizations provided by Justin T. Gibbs (gibbs@@FreeBSD.org)
#
##-M#########################################################################

VERSION AIC7XXX_SEQ_VER "$Id: aic7xxx.seq,v 1.1 1995/10/09 09:49:37 mycroft Exp $"

SCBMASK		= 0x1f

SCSISEQ		= 0x00
ENRSELI		= 0x10
SXFRCTL0	= 0x01
SXFRCTL1	= 0x02
SCSISIGI	= 0x03
SCSISIGO	= 0x03
SCSIRATE	= 0x04
SCSIID		= 0x05
SCSIDATL	= 0x06
STCNT		= 0x08
STCNT+0		= 0x08
STCNT+1		= 0x09
STCNT+2		= 0x0a
CLRSINT0	= 0x0b
SSTAT0		= 0x0b
SELDO		= 0x40
SELDI		= 0x20
CLRSINT1	= 0x0c
SSTAT1		= 0x0c
SIMODE1		= 0x11
SCSIBUSL	= 0x12
SHADDR		= 0x14
SELID		= 0x19
SBLKCTL		= 0x1f
SEQCTL		= 0x60
A		= 0x64				# == ACCUM
SINDEX		= 0x65
DINDEX		= 0x66
ALLZEROS	= 0x6a
NONE		= 0x6a
SINDIR		= 0x6c
DINDIR		= 0x6d
FUNCTION1	= 0x6e
HADDR		= 0x88
HADDR+1		= 0x89
HADDR+2		= 0x8a
HADDR+3		= 0x8b
HCNT		= 0x8c
HCNT+0		= 0x8c
HCNT+1		= 0x8d
HCNT+2		= 0x8e
SCBPTR		= 0x90
INTSTAT		= 0x91
DFCNTRL		= 0x93
DFSTATUS	= 0x94
DFDAT		= 0x99
QINFIFO		= 0x9b
QINCNT		= 0x9c
QOUTFIFO	= 0x9d

SCSICONF_A	= 0x5a
SCSICONF_B	= 0x5b

#  The two reserved bytes at SCBARRAY+1[23] are expected to be set to
#  zero, and the reserved bit in SCBARRAY+0 is used as an internal flag
#  to indicate whether or not to reload scatter-gather parameters after
#  a disconnect.  We also use bits 6 & 7 to indicate whether or not to
#  initiate SDTR or WDTR repectively when starting this command.
#
SCBARRAY+0	= 0xa0

DISCONNECTED	= 0x04
NEEDDMA		= 0x08
SG_LOAD		= 0x10
TAG_ENB		= 0x20
NEEDSDTR	= 0x40
NEEDWDTR	= 0x80

SCBARRAY+1	= 0xa1
SCBARRAY+2	= 0xa2
SCBARRAY+3	= 0xa3
SCBARRAY+4	= 0xa4
SCBARRAY+5	= 0xa5
SCBARRAY+6	= 0xa6
SCBARRAY+7	= 0xa7
SCBARRAY+8	= 0xa8
SCBARRAY+9	= 0xa9
SCBARRAY+10	= 0xaa
SCBARRAY+11	= 0xab
SCBARRAY+12	= 0xac
SCBARRAY+13	= 0xad
SCBARRAY+14	= 0xae
SCBARRAY+15	= 0xaf
SCBARRAY+16	= 0xb0
SCBARRAY+17	= 0xb1
SCBARRAY+18	= 0xb2
SCBARRAY+19	= 0xb3
SCBARRAY+20	= 0xb4
SCBARRAY+21	= 0xb5
SCBARRAY+22	= 0xb6
SCBARRAY+23	= 0xb7
SCBARRAY+24	= 0xb8
SCBARRAY+25	= 0xb9
SCBARRAY+26	= 0xba
SCBARRAY+27	= 0xbb
SCBARRAY+28	= 0xbc
SCBARRAY+29	= 0xbd
SCBARRAY+30	= 0xbe

BAD_PHASE	= 0x01				# unknown scsi bus phase
CMDCMPLT	= 0x02				# Command Complete
SEND_REJECT	= 0x11				# sending a message reject
NO_IDENT	= 0x21				# no IDENTIFY after reconnect
NO_MATCH	= 0x31				# no cmd match for reconnect
MSG_SDTR	= 0x41				# SDTR message recieved
MSG_WDTR	= 0x51				# WDTR message recieved
MSG_REJECT	= 0x61				# Reject message recieved
BAD_STATUS	= 0x71				# Bad status from target
RESIDUAL	= 0x81				# Residual byte count != 0
ABORT_TAG	= 0x91				# Sent an ABORT_TAG message

#  The host adapter card (at least the BIOS) uses 20-2f for SCSI
#  device information, 32-33 and 5a-5f as well. As it turns out, the
#  BIOS trashes 20-2f, writing the synchronous negotiation results
#  on top of the BIOS values, so we re-use those for our per-target
#  scratchspace (actually a value that can be copied directly into
#  SCSIRATE).  The kernel driver will enable synchronous negotiation
#  for all targets that have a value other than 0 in the lower four
#  bits of the target scratch space.  This should work irregardless of
#  whether the bios has been installed. NEEDWDTR and NEEDSDTR are the top
#  two bits of the SCB control byte.  The kernel driver will set these
#  when a WDTR or SDTR message should be sent to the target the SCB's 
#  command references.
#
#  REJBYTE contains the first byte of a MESSAGE IN message, so the driver 
#  can report an intelligible error if a message is rejected.
#
#  FLAGS's high bit is true if we are currently handling a reselect;
#  its next-highest bit is true ONLY IF we've seen an IDENTIFY message
#  from the reselecting target.  If we haven't had IDENTIFY, then we have
#  no idea what the lun is, and we can't select the right SCB register
#  bank, so force a kernel panic if the target attempts a data in/out or
#  command phase instead of corrupting something.  FLAGS also contains
#  configuration bits so that we can optimize for TWIN and WIDE controllers
#  as well as the MAX_SYNC bit which we set when we want to negotiate for
#  10MHz irregardless of what the per target scratch space says.
#
#  Note that SG_NEXT occupies four bytes.
#
SYNCNEG		= 0x20

REJBYTE		= 0x31
DISC_DSB_A	= 0x32
DISC_DSB_B	= 0x33

MSG_LEN		= 0x34
MSG_START+0	= 0x35
MSG_START+1	= 0x36
MSG_START+2	= 0x37
MSG_START+3	= 0x38
MSG_START+4	= 0x39
MSG_START+5	= 0x3a
-MSG_START+0	= 0xcb				# 2's complement of MSG_START+0

ARG_1		= 0x4a				# sdtr conversion args & return
BUS_16_BIT	= 0x01
RETURN_1	= 0x4a

SIGSTATE	= 0x4b				# value written to SCSISIGO

# Linux users should use 0xc (12) for SG_SIZEOF
SG_SIZEOF	= 0x8 				# sizeof(struct ahc_dma)
#SG_SIZEOF	= 0xc 				# sizeof(struct scatterlist)
SCB_SIZEOF	= 0x13				# sizeof SCB to DMA (19 bytes)

SG_NOLOAD	= 0x4c				# load SG pointer/length?
SG_COUNT	= 0x4d				# working value of SG count
SG_NEXT		= 0x4e				# working value of SG pointer
SG_NEXT+0	= 0x4e
SG_NEXT+1	= 0x4f
SG_NEXT+2	= 0x50
SG_NEXT+3	= 0x51

SCBCOUNT	= 0x52				# the actual number of SCBs
FLAGS		= 0x53				# Device configuration flags
TWIN_BUS	= 0x01
WIDE_BUS	= 0x02
MAX_SYNC	= 0x08
ACTIVE_MSG	= 0x20
IDENTIFY_SEEN	= 0x40
RESELECTED	= 0x80

ACTIVE_A	= 0x54
ACTIVE_B	= 0x55
SAVED_TCL	= 0x56				# Temporary storage for the 
						# target/channel/lun of a
						# reconnecting target

# After starting the selection hardware, we return to the "poll_for_work"
# loop so that we can check for reconnecting targets as well as for our
# selection to complete just in case the reselection wins bus arbitration.
# The problem with this is that we must keep track of the SCB that we've
# already pulled from the QINFIFO and started the selection on just in case
# the reselection wins so that we can retry the selection at a later time.
# This problem cannot be resolved by holding a single entry in scratch
# ram since a reconnecting target can request sense and this will create
# yet another SCB waiting for selection.  The solution used here is to 
# use byte 31 of the SCB as a psuedo-next pointer and to thread a list
# of SCBs that are awaiting selection.  Since 0 is a valid SCB offset, 
# SCB_LIST_NULL is 0x10 which is out of range.  The kernel driver must
# add an entry to this list everytime a request sense occurs.  The sequencer
# will automatically consume the entries.

WAITING_SCBH	= 0x57				# head of list of SCBs awaiting
						# selection
WAITING_SCBT	= 0x58				# tail of list of SCBs awaiting
						# selection
SCB_LIST_NULL	= 0x10


#  Poll QINCNT for work - the lower bits contain
#  the number of entries in the Queue In FIFO.
#
d84 2
a85 1
	test	WAITING_SCBH,SCB_LIST_NULL jz start_waiting
d87 8
a94 4
	test	FLAGS,TWIN_BUS	jz start2	# Are we a twin channel device?
# For fairness, we check the other bus first, since we just finished a 
# transaction on the current channel.
	xor	SBLKCTL,0x08			# Toggle to the other bus
d96 1
a96 2
	test	SSTAT0,SELDO	jnz select
	xor	SBLKCTL,0x08			# Toggle to the original bus
d99 10
a108 10
	test	SSTAT0,SELDO	jnz select
	test	WAITING_SCBH,SCB_LIST_NULL jz start_waiting
	test	QINCNT,SCBMASK	jz poll_for_work

# We have at least one queued SCB now and we don't have any 
# SCBs in the list of SCBs awaiting selection.  Set the SCB
# pointer from the FIFO so we see the right bank of SCB 
# registers, then set SCSI options and set the initiator and
# target SCSI IDs.
#
d111 14
a124 35
# If the control byte of this SCB has the NEEDDMA flag set, we have
# yet to DMA it from host memory

test    SCBARRAY+0,NEEDDMA      jz test_busy    
	clr	HCNT+2
	clr	HCNT+1
	mvi	HCNT+0,SCB_SIZEOF

	mvi	DINDEX,HADDR      
	mvi	SCBARRAY+26     call bcopy_4
        
	mvi	DFCNTRL,0xd                     # HDMAEN|DIRECTION|FIFORESET

#  Wait for DMA from host memory to data FIFO to complete, then disable
#  DMA and wait for it to acknowledge that it's off.
#
	call	dma_finish

# Copy the SCB from the FIFO to  the SCBARRAY

	mvi	DINDEX, SCBARRAY+0
	call	bcopy_3_dfdat 
	call	bcopy_4_dfdat
	call	bcopy_4_dfdat
	call	bcopy_4_dfdat   
	call	bcopy_4_dfdat

# See if there is not already an active SCB for this target.  This code
# locks out on a per target basis instead of target/lun.  Although this
# is not ideal for devices that have multiple luns active at the same
# time, it is faster than looping through all SCB's looking for active
# commands.  It may be benificial to make findscb a more general procedure
# to see if the added cost of the search is negligible.  This code also 
# assumes that the kernel driver will clear the active flags on board 
# initialization, board reset, and a target's SELTO.
d127 1
a127 2
	test	SCBARRAY+0,0x20	jnz start_scb
	and	FUNCTION1,0x70,SCBARRAY+1
d129 1
a129 1
	test	SCBARRAY+1,0x88	jz test_a	# Id < 8 && A channel
d132 3
a134 1
	or	ACTIVE_B,A	# Mark the current target as busy
d137 1
a137 1
# Place the currently active back on the queue for later processing
d142 5
a146 1
# Pull the first entry off of the waiting for selection list
d149 1
a149 1
	jmp	start_scb
d152 4
a155 2
	test	ACTIVE_A,A	jnz requeue
	or	ACTIVE_A,A	# Mark the current target as busy
d158 1
a158 13
	and	SINDEX,0xf7,SBLKCTL  #Clear the channel select bit
	and	A,0x08,SCBARRAY+1    #Get new channel bit
	or	SINDEX,A	     
	mov	SBLKCTL,SINDEX	# select channel
	mov	SCBARRAY+1	call initialize_scsiid

# Enable selection phase as an initiator, and do automatic ATN
# after the selection.  We do this now so that we can overlap the
# rest of our work to set up this target with the arbitration and
# selection bus phases.
#
start_selection:
	or	SCSISEQ,0x48			# ENSELO|ENAUTOATNO
d160 6
a165 2
	clr	SG_NOLOAD
	and	FLAGS,0x3f	# !RESELECTING
d167 8
a174 18
#  As soon as we get a successful selection, the target should go
#  into the message out phase since we have ATN asserted.  Prepare
#  the message to send, locking out the device driver.  If the device
#  driver hasn't beaten us with an ABORT or RESET message, then tack
#  on an SDTR negotiation if required.
#
#  Messages are stored in scratch RAM starting with a flag byte (high bit
#  set means active message), one length byte, and then the message itself.
#
	mov	SCBARRAY+1	call disconnect	# disconnect ok?

	and	SINDEX,0x7,SCBARRAY+1		# lun
	or	SINDEX,A			# return value from disconnect
	or	SINDEX,0x80	call mk_mesg	# IDENTIFY message

	mov	A,SINDEX
	test	SCBARRAY+0,0xe0	jz  !message	# WDTR, SDTR or TAG??
	cmp	MSG_START+0,A	jne !message	# did driver beat us?
d176 32
a207 2
# Tag Message if Tag enabled in SCB control block.  Use SCBPTR as the tag
# value
d210 4
a213 5
	mvi	DINDEX, MSG_START+1
	test	SCBARRAY+0,TAG_ENB jz mk_tag_done
	and	A,0x23,SCBARRAY+0
	mov	DINDIR,A
	mov	DINDIR,SCBPTR
d215 1
a215 1
	add	MSG_LEN,-MSG_START+0,DINDEX	# update message length
d219 2
a220 1
	mov	DINDEX	call mk_dtr	# build DTR message if needed
d223 9
a231 6
	jmp	poll_for_work

#  Reselection has been initiated by a target. Make a note that we've been
#  reselected, but haven't seen an IDENTIFY message from the target
#  yet.
#
d233 1
d235 2
a236 2
	and	FLAGS,0x3f			# reselected, no IDENTIFY	
	or	FLAGS,RESELECTED jmp select2
d238 6
a243 5
# After the selection, remove this SCB from the "waiting for selection"
# list.  This is achieved by simply moving our "next" pointer into
# WAITING_SCBH and setting our next pointer to null so that the next
# time this SCB is used, we don't get confused.
#
d245 2
a246 3
	or	SCBARRAY+0,NEEDDMA
	mov	WAITING_SCBH,SCBARRAY+30
	mvi	SCBARRAY+30,SCB_LIST_NULL
d248 26
a273 15
	call	initialize_for_target
	mvi	SCSISEQ,ENRSELI
	mvi	CLRSINT0,0x60			# CLRSELDI|CLRSELDO
	mvi	CLRSINT1,0x8			# CLRBUSFREE

#  Main loop for information transfer phases.  If BSY is false, then
#  we have a bus free condition, expected or not.  Otherwise, wait
#  for the target to assert REQ before checking MSG, C/D and I/O
#  for the bus phase.
#
#  We can't simply look at the values of SCSISIGI here (if we want
#  to do synchronous data transfer), because the target won't assert
#  REQ if it's already sent us some data that we haven't acknowledged
#  yet.
#
d275 2
a276 2
	test	SSTAT1,0x8	jnz p_busfree	# BUSFREE
	test	SSTAT1,0x1	jz ITloop	# REQINIT
d278 3
a280 1
	and	A,0xe0,SCSISIGI			# CDI|IOI|MSGI
d283 5
a287 5
	cmp	A,0x40		je p_datain
	cmp	A,0x80		je p_command
	cmp	A,0xc0		je p_status
	cmp	A,0xa0		je p_mesgout
	cmp	A,0xe0		je p_mesgin
d289 1
a289 1
	mvi	INTSTAT,BAD_PHASE		# unknown - signal driver
d292 15
a306 40
	mvi	0		call scsisig	# !CDO|!IOO|!MSGO
	call	assert
	call	sg_load

	mvi	DINDEX,HADDR
	mvi	SCBARRAY+19	call bcopy_4

#	mvi	DINDEX,HCNT	# implicit since HCNT is next to HADDR
	mvi	SCBARRAY+23	call bcopy_3

	mvi	DINDEX,STCNT
	mvi	SCBARRAY+23	call bcopy_3

# If we are the last SG block, don't set wideodd.
	test    SCBARRAY+18,0xff jnz p_dataout_wideodd
	mvi	0x3d		call dma	# SCSIEN|SDMAEN|HDMAEN|
						#   DIRECTION|FIFORESET
	jmp	p_dataout_rest

p_dataout_wideodd:
	mvi	0xbd		call dma	# WIDEODD|SCSIEN|SDMAEN|HDMAEN|
						#   DIRECTION|FIFORESET

p_dataout_rest:
#  After a DMA finishes, save the final transfer pointer and count
#  back into the SCB, in case a device disconnects in the middle of
#  a transfer.  Use SHADDR and STCNT instead of HADDR and HCNT, since
#  it's a reflection of how many bytes were transferred on the SCSI
#  (as opposed to the host) bus.
#
	mvi	DINDEX,SCBARRAY+23
	mvi	STCNT		call bcopy_3

	mvi	DINDEX,SCBARRAY+19
	mvi	SHADDR		call bcopy_4

	call	sg_advance
	mov	SCBARRAY+18,SG_COUNT		# residual S/G count

	jmp	ITloop
d309 5
a313 1
	mvi	0x40		call scsisig	# !CDO|IOO|!MSGO
a314 1
	call	sg_load
d316 3
a318 2
	mvi	DINDEX,HADDR
	mvi	SCBARRAY+19	call bcopy_4
d320 15
a334 2
#	mvi	DINDEX,HCNT	# implicit since HCNT is next to HADDR
	mvi	SCBARRAY+23	call bcopy_3
d336 1
a336 14
	mvi	DINDEX,STCNT
	mvi	SCBARRAY+23	call bcopy_3

# If we are the last SG block, don't set wideodd.
	test	SCBARRAY+18,0xff jnz p_datain_wideodd
	mvi	0x39		call dma	# SCSIEN|SDMAEN|HDMAEN|
						#   !DIRECTION|FIFORESET
	jmp	p_datain_rest
p_datain_wideodd:
	mvi	0xb9		call dma	# WIDEODD|SCSIEN|SDMAEN|HDMAEN|
						#   !DIRECTION|FIFORESET
p_datain_rest:
	mvi	DINDEX,SCBARRAY+23
	mvi	STCNT		call bcopy_3
d338 33
a370 5
	mvi	DINDEX,SCBARRAY+19
	mvi	SHADDR		call bcopy_4

	call	sg_advance
	mov	SCBARRAY+18,SG_COUNT		# residual S/G count
d372 54
d428 3
a430 4
#  Command phase.  Set up the DMA registers and let 'er rip - the
#  two bytes after the SCB SCSI_cmd_length are zeroed by the driver,
#  so we can copy those three bytes directly into HCNT.
#
a431 1
	mvi	0x80		call scsisig	# CDO|!IOO|!MSGO
d434 14
a447 8
	mvi	DINDEX,HADDR
	mvi	SCBARRAY+7	call bcopy_4

#	mvi	DINDEX,HCNT	# implicit since HCNT is next to HADDR
	mvi	SCBARRAY+11	call bcopy_3

	mvi	DINDEX,STCNT
	mvi	SCBARRAY+11	call bcopy_3
d453 4
a456 3
#  Status phase.  Wait for the data byte to appear, then read it
#  and store it into the SCB.
#
d458 2
a459 1
	mvi	0xc0		call scsisig	# CDO|IOO|!MSGO
d461 4
a464 6
	mvi	SCBARRAY+14	call inb_first
	jmp	p_mesgin_done

#  Message out phase.  If there is no active message, but the target
#  took us into this phase anyway, build a no-op message and send it.
#
d466 2
a467 5
	mvi	0xa0		call scsisig	# CDO|!IOO|MSGO
	mvi	0x8		call mk_mesg	# build NOP message

	clr     STCNT+2
	clr     STCNT+1
d469 6
a474 4
#  Set up automatic PIO transfer from MSG_START.  Bit 3 in
#  SXFRCTL0 (SPIOEN) is already on.
#
	mvi	SINDEX,MSG_START+0
d477 15
a491 32
#  When target asks for a byte, drop ATN if it's the last one in
#  the message.  Otherwise, keep going until the message is exhausted.
#  (We can't use outb for this since it wants the input in SINDEX.)
#
#  Keep an eye out for a phase change, in case the target issues
#  a MESSAGE REJECT.
#
p_mesgout2:
	test	SSTAT0,0x2	jz p_mesgout2	# SPIORDY
	test	SSTAT1,0x10	jnz p_mesgout6	# PHASEMIS

	cmp	DINDEX,1	jne p_mesgout3	# last byte?
	mvi	CLRSINT1,0x40			# CLRATNO - drop ATN

#  Write a byte to the SCSI bus.  The AIC-7770 refuses to automatically
#  send ACKs in automatic PIO or DMA mode unless you make sure that the
#  "expected" bus phase in SCSISIGO matches the actual bus phase.  This
#  behaviour is completely undocumented and caused me several days of
#  grief.
#
#  After plugging in different drives to test with and using a longer
#  SCSI cable, I found that I/O in Automatic PIO mode ceased to function,
#  especially when transferring >1 byte.  It seems to be much more stable
#  if STCNT is set to one before the transfer, and SDONE (in SSTAT0) is
#  polled for transfer completion - for both output _and_ input.  The
#  only theory I have is that SPIORDY doesn't drop right away when SCSIDATL
#  is accessed (like the documentation says it does), and that on a longer
#  cable run, the sequencer code was fast enough to loop back and see
#  an SPIORDY that hadn't dropped yet.
#
p_mesgout3:
	mvi	STCNT+0, 0x01	
d493 11
d505 1
a505 4
p_mesgout4:
	test	SSTAT0,0x4	jz p_mesgout4	# SDONE
	dec	DINDEX
	test	DINDEX,0xff	jnz p_mesgout2
d507 1
a507 10
#  If the next bus phase after ATN drops is a message out, it means
#  that the target is requesting that the last message(s) be resent.
#
p_mesgout5:
	test	SSTAT1,0x8	jnz p_mesgout6	# BUSFREE
	test	SSTAT1,0x1	jz p_mesgout5	# REQINIT

	and	A,0xe0,SCSISIGI			# CDI|IOI|MSGI
	cmp	A,0xa0		jne p_mesgout6
	mvi	0x10		call scsisig	# ATNO - re-assert ATN
d511 4
a514 3
p_mesgout6:
	mvi	CLRSINT1,0x40			# CLRATNO - in case of PHASEMIS
	and	FLAGS,0xdf			# no active msg
d517 3
a519 8
#  Message in phase.  Bytes are read using Automatic PIO mode, but not
#  using inb.  This alleviates a race condition, namely that if ATN had
#  to be asserted under Automatic PIO mode, it had to beat the SCSI
#  circuitry sending an ACK to the target.  This showed up under heavy
#  loads and really confused things, since ABORT commands wouldn't be
#  seen by the drive after an IDENTIFY message in until it had changed
#  to a data I/O phase.
#
d521 60
a580 25
	mvi	0xe0		call scsisig	# CDO|IOO|MSGO
	mvi	A		call inb_first	# read the 1st message byte
	mvi	REJBYTE,A			# save it for the driver

	cmp	ALLZEROS,A	jne p_mesgin1

#  We got a "command complete" message, so put the SCB pointer
#  into the Queue Out, and trigger a completion interrupt.
#  Check status for non zero return and interrupt driver if needed
#  This allows the driver to interpret errors only when they occur
#  instead of always uploading the scb.  If the status is SCSI_CHECK,
#  the driver will download a new scb requesting sense to replace
#  the old one, modify the "waiting for selection" SCB list and set 
#  RETURN_1 to 0x80.  If RETURN_1 is set to 0x80 the sequencer imediately
#  jumps to main loop where it will run down the waiting SCB list.
#  If the kernel driver does not wish to request sense, it need
#  only clear RETURN_1, and the command is allowed to complete.  We don't 
#  bother to post to the QOUTFIFO in the error case since it would require 
#  extra work in the kernel driver to ensure that the entry was removed 
#  before the command complete code tried processing it.

# First check for residuals
	test	SCBARRAY+15,0xff	jnz resid
	test	SCBARRAY+16,0xff	jnz resid
	test	SCBARRAY+17,0xff	jnz resid
d583 4
a586 4
	test	SCBARRAY+14,0xff	jz status_ok	# 0 Status?
	mvi	INTSTAT,BAD_STATUS			# let driver know
	test	RETURN_1, 0x80	jz status_ok
	jmp	p_mesgin_done
d589 7
a595 3
#  First, mark this target as free.
	test	SCBARRAY+0,0x20	jnz complete		# Tagged command
	and	FUNCTION1,0x70,SCBARRAY+1
d597 1
a597 1
	test	SCBARRAY+1,0x88 jz clear_a
d599 1
a599 1
	jmp	complete
d604 9
d614 1
a614 1
	mov	QOUTFIFO,SCBPTR
d616 1
a616 12
	jmp	p_mesgin_done

# If we have a residual count, interrupt and tell the host.  Other
# alternatives are to pause the sequencer on all command completes (yuck),
# dma the resid directly to the host (slick, but a ton of instructions), or
# have the sequencer pause itself when it encounters a non-zero resid 
# (unecessary pause just to flag the command -- yuck, but takes few instructions
# and since it shouldn't happen that often is good enough for our purposes).  

resid:
	mvi	INTSTAT,RESIDUAL
	jmp	check_status
a617 11
#  Is it an extended message?  We only support the synchronous and wide data
#  transfer request messages, which will probably be in response to
#  WDTR or SDTR message outs from us.  If it's not SDTR or WDTR, reject it -
#  apparently this can be done after any message in byte, according
#  to the SCSI-2 spec.
#
p_mesgin1:
	cmp	A,1		jne p_mesgin2	# extended message code?
	
	mvi	ARG_1		call inb_next	# extended message length
	mvi	A		call inb_next	# extended message code
d619 14
a632 3
	cmp	A,1		je p_mesginSDTR	# Syncronous negotiation message
	cmp	A,3		je p_mesginWDTR # Wide negotiation message
	jmp	p_mesginN
d635 15
a649 13
	cmp	ARG_1,2		jne p_mesginN	# extended mesg length = 2
	mvi	A		call inb_next	# Width of bus
	mvi	INTSTAT,MSG_WDTR		# let driver know
	test	RETURN_1,0x80	jz p_mesgin_done# Do we need to send WDTR?

# We didn't initiate the wide negotiation, so we must respond to the request
	and	RETURN_1,0x7f			# Clear the SEND_WDTR Flag
	or	FLAGS,ACTIVE_MSG
	mvi	DINDEX,MSG_START+0
	mvi	MSG_START+0	call mk_wdtr	# build WDTR message	
	or	SINDEX,0x10,SIGSTATE		# turn on ATNO
	call	scsisig
	jmp	p_mesgin_done
d652 45
a696 29
	cmp	ARG_1,3		jne p_mesginN	# extended mesg length = 3
	mvi	ARG_1		call inb_next	# xfer period
	mvi	A		call inb_next	# REQ/ACK offset
	mvi	INTSTAT,MSG_SDTR		# call driver to convert

	test	RETURN_1,0xc0	jz p_mesgin_done# Do we need to mk_sdtr or rej?
	test	RETURN_1,0x40	jnz p_mesginN	# Requested SDTR too small - rej
	or	FLAGS,ACTIVE_MSG
	mvi	DINDEX, MSG_START+0
	mvi     MSG_START+0     call mk_sdtr
	or	SINDEX,0x10,SIGSTATE		# turn on ATNO
	call	scsisig
	jmp	p_mesgin_done

#  Is it a disconnect message?  Set a flag in the SCB to remind us
#  and await the bus going free.
#
p_mesgin2:
	cmp	A,4		jne p_mesgin3	# disconnect code?

	or	SCBARRAY+0,0x4			# set "disconnected" bit
	jmp	p_mesgin_done

#  Save data pointers message?  Copy working values into the SCB,
#  usually in preparation for a disconnect.
#
p_mesgin3:
	cmp	A,2		jne p_mesgin4	# save data pointers code?

d698 1
a698 1
	jmp	p_mesgin_done
d700 20
a719 6
#  Restore pointers message?  Data pointers are recopied from the
#  SCB anyway at the start of any DMA operation, so the only thing
#  to copy is the scatter-gather values.
#
p_mesgin4:
	cmp	A,3		jne p_mesgin5	# restore pointers code?
d721 1
a721 13
	call	sg_scb2ram
	jmp	p_mesgin_done

#  Identify message?  For a reconnecting target, this tells us the lun
#  that the reconnection is for - find the correct SCB and switch to it,
#  clearing the "disconnected" bit so we don't "find" it by accident later.
#
p_mesgin5:
	test	A,0x80		jz p_mesgin6	# identify message?

	test	A,0x78		jnz p_mesginN	# !DiscPriv|!LUNTAR|!Reserved

	and	A,0x07				# lun in lower three bits
d724 1
a724 1
	and     A,0x08,SBLKCTL			# B Channel??
d726 36
a761 2
	call	inb_last			# ACK
	mov	ALLZEROS	call findSCB    
d763 2
a764 5
	and	SCBARRAY+0,0xfb			# clear disconnect bit in SCB
	or	FLAGS,IDENTIFY_SEEN		# make note of IDENTIFY

	call	sg_scb2ram			# implied restore pointers
						#   required on reselect
d766 2
a767 7
get_tag:
	mvi	A		call inb_first
	cmp	A,0x20  	jne return	# Simple Tag message?
	mvi	A		call inb_next
	call			inb_last
	test	A,0xf0		jnz abort_tag	# Tag in range?
	mov	SCBPTR,A
d769 5
a773 3
	cmp	SCBARRAY+1,A		jne abort_tag
	test	SCBARRAY+0,TAG_ENB	jz  abort_tag
	ret
d775 27
a801 32
	or	SINDEX,0x10,SIGSTATE		# turn on ATNO
	call	scsisig
	mvi	INTSTAT,ABORT_TAG 		# let driver know
	mvi	0xd		call mk_mesg	# ABORT TAG message
	ret

#  Message reject?  Let the kernel driver handle this.  If we have an 
#  outstanding WDTR or SDTR negotiation, assume that it's a response from 
#  the target selecting 8bit or asynchronous transfer, otherwise just ignore 
#  it since we have no clue what it pertains to.
#
p_mesgin6:
	cmp	A,7		jne p_mesgin7	# message reject code?

	mvi	INTSTAT, MSG_REJECT
	jmp	p_mesgin_done

#  [ ADD MORE MESSAGE HANDLING HERE ]
#
p_mesgin7:

#  We have no idea what this message in is, and there's no way
#  to pass it up to the kernel, so we issue a message reject and
#  hope for the best.  Since we're now using manual PIO mode to
#  read in the message, there should no longer be a race condition
#  present when we assert ATN.  In any case, rejection should be a
#  rare occurrence - signal the driver when it happens.
#
p_mesginN:
	or	SINDEX,0x10,SIGSTATE		# turn on ATNO
	call	scsisig
	mvi	INTSTAT,SEND_REJECT		# let driver know
d803 5
a807 14
	mvi	0x7		call mk_mesg	# MESSAGE REJECT message

p_mesgin_done:
	call	inb_last			# ack & turn auto PIO back on
	jmp	ITloop


#  Bus free phase.  It might be useful to interrupt the device
#  driver if we aren't expecting this.  For now, make sure that
#  ATN isn't being asserted and look for a new command.
#
p_busfree:
	mvi	CLRSINT1,0x40			# CLRATNO
	clr	SIGSTATE
d810 7
a816 17
#  Instead of a generic bcopy routine that requires an argument, we unroll
#  the two cases that are actually used, and call them explicitly.  This
#  not only reduces the overhead of doing a bcopy by 2/3rds, but ends up
#  saving space in the program since you don't have to put the argument 
#  into the accumulator before the call.  Both functions expect DINDEX to
#  contain the destination address and SINDEX to contain the source 
#  address.
bcopy_3:
	mov	DINDIR,SINDIR
	mov	DINDIR,SINDIR
	mov	DINDIR,SINDIR	ret

bcopy_4:
	mov	DINDIR,SINDIR
	mov	DINDIR,SINDIR
	mov	DINDIR,SINDIR
	mov	DINDIR,SINDIR	ret
d818 8
a825 21
bcopy_3_dfdat:
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT	ret

bcopy_4_dfdat:
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT
	mov	DINDIR,DFDAT	ret

#  Locking the driver out, build a one-byte message passed in SINDEX
#  if there is no active message already.  SINDEX is returned intact.
#
mk_mesg:
	mvi	SEQCTL,0x50			# PAUSEDIS|FASTMODE
	test	FLAGS,ACTIVE_MSG jnz mk_mesg1	# active message?

	or	FLAGS,ACTIVE_MSG		# if not, there is now
	mvi	MSG_LEN,1			# length = 1
	mov	MSG_START+0,SINDEX		# 1-byte message
d828 19
a846 1
	mvi	SEQCTL,0x10	ret		# !PAUSEDIS|FASTMODE
d848 6
a853 17
#  Carefully read data in Automatic PIO mode.  I first tried this using
#  Manual PIO mode, but it gave me continual underrun errors, probably
#  indicating that I did something wrong, but I feel more secure leaving
#  Automatic PIO on all the time.
#
#  According to Adaptec's documentation, an ACK is not sent on input from
#  the target until SCSIDATL is read from.  So we wait until SCSIDATL is
#  latched (the usual way), then read the data byte directly off the bus
#  using SCSIBUSL.  When we have pulled the ATN line, or we just want to
#  acknowledge the byte, then we do a dummy read from SCISDATL.  The SCSI
#  spec guarantees that the target will hold the data byte on the bus until
#  we send our ACK.
#
#  The assumption here is that these are called in a particular sequence,
#  and that REQ is already set when inb_first is called.  inb_{first,next}
#  use the same calling convention as inb.
#
a854 2
	clr	STCNT+2
	clr	STCNT+1
d856 3
a858 1
	mov	DINDIR,SCSIBUSL	ret		# read byte directly from bus
d860 6
a865 10
inb_next:
	mov	DINDEX,SINDEX			# save SINDEX

        mvi     STCNT+0,1			# xfer one byte
	mov	NONE,SCSIDATL			# dummy read from latch to ACK
inb_next1:
	test	SSTAT0,0x4	jz inb_next1	# SDONE
inb_next2:
	test	SSTAT0,0x2	jz inb_next2	# SPIORDY - wait for next byte
	mov	DINDIR,SCSIBUSL	ret		# read byte directly from bus
d867 6
a872 12
inb_last:
	mvi	STCNT+0,1			# ACK with dummy read
	mov	NONE,SCSIDATL
inb_last1:
	test	SSTAT0,0x4	jz inb_last1	# wait for completion
	ret

#  DMA data transfer.  HADDR and HCNT must be loaded first, and
#  SINDEX should contain the value to load DFCNTRL with - 0x3d for
#  host->scsi, or 0x39 for scsi->host.  The SCSI channel is cleared
#  during initialization.
#
d876 11
a886 11
dma2:
	test	SSTAT0,0x1	jnz dma3	# DMADONE
	test	SSTAT1,0x10	jz dma1		# PHASEMIS, ie. underrun

#  We will be "done" DMAing when the transfer count goes to zero, or
#  the target changes the phase (in light of this, it makes sense that
#  the DMA circuitry doesn't ACK when PHASEMIS is active).  If we are
#  doing a SCSI->Host transfer, the data FIFO should be flushed auto-
#  magically on STCNT=0 or a phase change, so just wait for FIFO empty
#  status.
#
d888 1
a888 1
	test	SINDEX,0x4	jnz dma5	# DIRECTION
d890 1
a890 1
	test	DFSTATUS,0x1	jz dma4		# !FIFOEMP
d892 4
a895 5
#  Now shut the DMA enables off, and copy STCNT (ie. the underrun
#  amount, if any) to the SCB registers; SG_COUNT will get copied to
#  the SCB's residual S/G count field after sg_advance is called.  Make
#  sure that the DMA enables are actually off first lest we get an ILLSADDR.
#
d897 2
a898 1
	clr	DFCNTRL				# disable DMA
d900 1
a900 9
	test	DFCNTRL,0x38	jnz dma6	# SCSIENACK|SDMAENACK|HDMAENACK

	mvi	DINDEX,SCBARRAY+15
	mvi	STCNT		call bcopy_3

	ret

dma_finish:
	test	DFSTATUS,0x8	jz dma_finish	# HDONE
a901 3
	clr	DFCNTRL				# disable DMA
dma_finish2:
	test	DFCNTRL,0x8	jnz dma_finish2	# HDMAENACK
d904 5
a908 4
#  Common SCSI initialization for selection and reselection.  Expects
#  the target SCSI ID to be in the upper four bits of SINDEX, and A's
#  contents are stomped on return.
#
d910 1
a910 1
	and	SINDEX,0xf0		# Get target ID
d915 4
a918 24
initialize_for_target:
#  Turn on Automatic PIO mode now, before we expect to see a REQ
#  from the target.  It shouldn't hurt anything to leave it on.  Set
#  CLRCHN here before the target has entered a data transfer mode -
#  with synchronous SCSI, if you do it later, you blow away some
#  data in the SCSI FIFO that the target has already sent to you.
#
	clr	SIGSTATE 

	mvi	SXFRCTL0,0x8a			# DFON|SPIOEN|CLRCHN

#  Initialize scatter-gather pointers by setting up the working copy
#  in scratch RAM.
#
	call	sg_scb2ram

#  Initialize SCSIRATE with the appropriate value for this target.
#
	call	ndx_dtr
	mov	SCSIRATE,SINDIR	ret

#  Assert that if we've been reselected, then we've seen an IDENTIFY
#  message.
#
d920 2
a921 17
	test	FLAGS,RESELECTED	jz return	# reselected?
	test	FLAGS,IDENTIFY_SEEN	jnz return	# seen IDENTIFY?

	mvi	INTSTAT,NO_IDENT 	ret	# no - cause a kernel panic

#  Find out if disconnection is ok from the information the BIOS has left
#  us.  The tcl from SCBARRAY+1 should be in SINDEX; A will
#  contain either 0x40 (disconnection ok) or 0x00 (disconnection not ok)
#  on exit.
#
#  To allow for wide or twin busses, we check the upper bit of the target ID
#  and the channel ID and look at the appropriate disconnect register. 
#
disconnect:
	and	FUNCTION1,0x70,SINDEX		# strip off extra just in case
	mov	A,FUNCTION1
	test	SINDEX, 0x88	jz disconnect_a
d923 1
a923 2
	test	DISC_DSB_B,A	jz disconnect1	# bit nonzero if DISabled
	clr	A		ret
d925 7
a931 12
disconnect_a:
	test	DISC_DSB_A,A	jz disconnect1	# bit nonzero if DISabled
	clr	A		ret

disconnect1:
	mvi	A,0x40		ret

#  Locate the SCB matching the target ID/channel/lun in SAVED_TCL and switch 
#  the SCB to it.  Have the kernel print a warning message if it can't be 
#  found, and generate an ABORT message to the target.  SINDEX should be
#  cleared on call.
#
d934 29
a962 5
	mov	SCBPTR,SINDEX			# switch to new SCB
	cmp	SCBARRAY+1,A	jne findSCB1	# target ID/channel/lun match?
	test	SCBARRAY+0,0x4	jz findSCB1	# should be disconnected
	test	SCBARRAY+0,TAG_ENB jnz get_tag
	ret
d965 1
d970 9
a978 2
	mvi	INTSTAT,NO_MATCH		# not found - signal kernel
	mvi	0x6		call mk_mesg	# ABORT message
d980 3
a982 6
	or	SINDEX,0x10,SIGSTATE		# assert ATNO
	call	scsisig
	ret

#  Make a working copy of the scatter-gather parameters in the SCB.
#
d984 25
a1008 11
	mov	SG_COUNT,SCBARRAY+2

	mvi	DINDEX,SG_NEXT
	mvi	SCBARRAY+3	call bcopy_4

	mvi	SG_NOLOAD,0x80
	test	SCBARRAY+0,0x10	jnz return	# don't reload s/g?
	clr	SG_NOLOAD	 ret

#  Copying RAM values back to SCB, for Save Data Pointers message.
#
d1010 2
a1011 1
	mov	SCBARRAY+2,SG_COUNT
d1013 22
a1034 94
	mvi	DINDEX,SCBARRAY+3
	mvi	SG_NEXT		call bcopy_4

	and	SCBARRAY+0,0xef,SCBARRAY+0
	test	SG_NOLOAD,0x80	jz return	# reload s/g?
	or	SCBARRAY+0,SG_LOAD	 ret

#  Load a struct scatter if needed and set up the data address and
#  length.  If the working value of the SG count is nonzero, then
#  we need to load a new set of values.
#
#  This, like the above DMA, assumes a little-endian host data storage.
#
sg_load:
	test	SG_COUNT,0xff	jz return	# SG being used?
	test	SG_NOLOAD,0x80	jnz return	# don't reload s/g?

	clr	HCNT+2
	clr	HCNT+1
	mvi	HCNT+0,SG_SIZEOF

	mvi	DINDEX,HADDR
	mvi	SG_NEXT		call bcopy_4

	mvi	DFCNTRL,0xd			# HDMAEN|DIRECTION|FIFORESET

#  Wait for DMA from host memory to data FIFO to complete, then disable
#  DMA and wait for it to acknowledge that it's off.
#

	call	dma_finish

#  Copy data from FIFO into SCB data pointer and data count.  This assumes
#  that the struct scatterlist has this structure (this and sizeof(struct
#  scatterlist) == 12 are asserted in aic7xxx.c):
#
#	struct scatterlist {
#		char *address;		/* four bytes, little-endian order */
#		...			/* four bytes, ignored */
#		unsigned short length;	/* two bytes, little-endian order */
#	}
#

# Not in FreeBSD.  the scatter list entry is only 8 bytes.
# 
# struct ahc_dma_seg {
#       physaddr addr;                  /* four bytes, little-endian order */
#       long    len;                    /* four bytes, little endian order */   
# };
#

	mvi	DINDEX, SCBARRAY+19
	call	bcopy_4_dfdat

# For Linux, we must throw away four bytes since there is a 32bit gap
# in the middle of a struct scatterlist
#	mov	NONE,DFDAT
#	mov	NONE,DFDAT
#	mov	NONE,DFDAT
#	mov	NONE,DFDAT

	call	bcopy_3_dfdat		#Only support 24 bit length.
	ret

#  Advance the scatter-gather pointers only IF NEEDED.  If SG is enabled,
#  and the SCSI transfer count is zero (note that this should be called
#  right after a DMA finishes), then move the working copies of the SG
#  pointer/length along.  If the SCSI transfer count is not zero, then
#  presumably the target is disconnecting - do not reload the SG values
#  next time.
#
sg_advance:
	test	SG_COUNT,0xff	jz return	# s/g enabled?

	test	STCNT+0,0xff	jnz sg_advance1	# SCSI transfer count nonzero?
	test	STCNT+1,0xff	jnz sg_advance1
	test	STCNT+2,0xff	jnz sg_advance1

	clr	SG_NOLOAD			# reload s/g next time
	dec	SG_COUNT			# one less segment to go

	clr	A				# add sizeof(struct scatter)
	add	SG_NEXT+0,SG_SIZEOF,SG_NEXT+0
	adc	SG_NEXT+1,A,SG_NEXT+1
	adc	SG_NEXT+2,A,SG_NEXT+2
	adc	SG_NEXT+3,A,SG_NEXT+3	ret

sg_advance1:
	mvi	SG_NOLOAD,0x80	ret		# don't reload s/g next time

#  Add the array base SYNCNEG to the target offset (the target address
#  is in SCSIID), and return the result in SINDEX.  The accumulator
#  contains the 3->8 decoding of the target ID on return.
#
d1037 2
a1038 2
	test	SBLKCTL,0x08	jz ndx_dtr_2
	or	A,0x08		# Channel B entries add 8
d1040 1
a1040 1
	add	SINDEX,SYNCNEG,A
d1042 7
a1048 9
	and	FUNCTION1,0x70,SCSIID		# 3-bit target address decode
	mov	A,FUNCTION1	ret

#  If we need to negotiate transfer parameters, build the WDTR or SDTR message
#  starting at the address passed in SINDEX.  DINDEX is modified on return.
#  The SCSI-II spec requires that Wide negotiation occur first and you can
#  only negotiat one or the other at a time otherwise in the event of a message
#  reject, you wouldn't be able to tell which message was the culpret.
#
d1050 2
a1051 3
	test	SCBARRAY+0,0xc0 jz return	# NEEDWDTR|NEEDSDTR
	test	SCBARRAY+0,NEEDWDTR jnz  mk_wdtr_16bit
	or	FLAGS, MAX_SYNC		 # Force an offset of 15
d1054 3
a1056 3
	mvi	DINDIR,1			# extended message
	mvi	DINDIR,3			# extended message length = 3
	mvi	DINDIR,1			# SDTR code
d1058 3
a1060 3
	mov	DINDIR,RETURN_1			# REQ/ACK transfer period
	test	FLAGS, MAX_SYNC	jnz mk_sdtr_max_sync
	and	DINDIR,0xf,SINDIR		# Sync Offset
d1063 1
a1063 1
	add	MSG_LEN,-MSG_START+0,DINDEX ret	# update message length
d1065 11
a1075 4
mk_sdtr_max_sync:
# We're initiating sync negotiation, so request the max offset we can (15)
	mvi	DINDIR, 0x0f
	xor	FLAGS, MAX_SYNC
d1081 4
a1084 4
	mvi	DINDIR,1			# extended message
	mvi	DINDIR,2			# extended message length = 2
	mvi	DINDIR,3			# WDTR code
	mov	DINDIR,ARG_1			# bus width
d1086 1
a1086 1
	add	MSG_LEN,-MSG_START+0,DINDEX ret	# update message length
a1087 11
#  Set SCSI bus control signal state.  This also saves the last-written
#  value into a location where the higher-level driver can read it - if
#  it has to send an ABORT or RESET message, then it needs to know this
#  so it can assert ATN without upsetting SCSISIGO.  The new value is
#  expected in SINDEX.  Change the actual state last to avoid contention
#  from the driver.
#
scsisig:
	mov	SIGSTATE,SINDEX
	mov	SCSISIGO,SINDEX	ret

d1089 1
a1089 1
	call	ndx_dtr				# index scratch space for target
d1091 1
a1091 1
	dec	SINDEX				#Preserve SINDEX
d1096 1
a1096 1
	add	RETURN_1,0x18
d1101 3
a1103 2
	add	RETURN_1,0x18	ret

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
