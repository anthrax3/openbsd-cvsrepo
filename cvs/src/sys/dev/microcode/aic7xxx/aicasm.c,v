head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.10
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.8
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.4
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.28
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.26
	OPENBSD_5_0:1.14.0.24
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.22
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.20
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.16
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.18
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.14
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.15;
commitid	LS2TNeCue5R9L67C;

1.15
date	2012.12.05.23.20.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.04.23.46.14;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.18.19.51.53;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.12.03.37.19;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.12.20.27.02;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.28.00.34.55;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.05.06.52;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2000.03.24.09.09.14;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.06.13.08.50.13;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2003.05.19.22.16.04;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@/* $OpenBSD: aicasm.c,v 1.15 2012/12/05 23:20:19 deraadt Exp $ */
/*
 * Aic7xxx SCSI host adapter firmware asssembler
 *
 * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
 * Copyright (c) 2001, 2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id: aicasm.c,v 1.15 2012/12/05 23:20:19 deraadt Exp $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.37 2004/03/12 21:45:25 trhodes Exp $
 */
#include <sys/types.h>
#include <sys/mman.h>

#include <ctype.h>
#include <inttypes.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <unistd.h>
#include <endian.h>

#include "aicasm.h"
#include "aicasm_symbol.h"
#include "aicasm_insformat.h"

typedef struct patch {
	TAILQ_ENTRY(patch) links;
	int		patch_func;
	u_int		begin;
	u_int		skip_instr;
	u_int		skip_patch;
} patch_t;

TAILQ_HEAD(patch_list, patch) patches;

static void usage(void);
static void back_patch(void);
static void output_code(void);
static void output_listing(char *ifilename);
static void dump_scope(scope_t *scope);
static void emit_patch(scope_t *scope, int patch);
static int check_patch(patch_t **start_patch, int start_instr,
		       int *skip_addr, int *func_vals);

struct path_list search_path;
int includes_search_curdir;
char *appname;
char *stock_include_file;
FILE *ofile;
char *ofilename;
char *regfilename;
FILE *regfile;
char *listfilename;
FILE *listfile;
char *regdiagfilename;
FILE *regdiagfile;
int   src_mode;
int   dst_mode;

static TAILQ_HEAD(,instruction) seq_program;
struct cs_tailq cs_tailq;
struct scope_list scope_stack;
symlist_t patch_functions;

#if DEBUG
extern int yy_flex_debug;
extern int mm_flex_debug;
extern int yydebug;
extern int mmdebug;
#endif
extern FILE *yyin;
extern int yyparse(void);

int main(int argc, char *argv[]);

int
main(int argc, char *argv[])
{
	extern char *optarg;
	extern int optind;
	int  ch;
	int  retval;
	char *inputfilename;
	scope_t *sentinal;

	TAILQ_INIT(&patches);
	SLIST_INIT(&search_path);
	TAILQ_INIT(&seq_program);
	TAILQ_INIT(&cs_tailq);
	SLIST_INIT(&scope_stack);

	/* Set Sentinal scope node */
	sentinal = scope_alloc();
	sentinal->type = SCOPE_ROOT;
	
	includes_search_curdir = 1;
	appname = *argv;
	regfile = NULL;
	listfile = NULL;
#if DEBUG
	yy_flex_debug = 0;
	mm_flex_debug = 0;
	yydebug = 0;
	mmdebug = 0;
#endif
	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:X")) != -1) {
		switch(ch) {
		case 'd':
#if DEBUG
			if (strcmp(optarg, "s") == 0) {
				yy_flex_debug = 1;
				mm_flex_debug = 1;
			} else if (strcmp(optarg, "p") == 0) {
				yydebug = 1;
				mmdebug = 1;
			} else {
				fprintf(stderr, "%s: -d Requires either an "
					"'s' or 'p' argument\n", appname);
				usage();
			}
#else
			stop("-d: Assembler not built with debugging "
			     "information", EX_SOFTWARE);
#endif
			break;
		case 'i':
			stock_include_file = optarg;
			break;
		case 'l':
			/* Create a program listing */
			if ((listfile = fopen(optarg, "w")) == NULL) {
				perror(optarg);
				stop(NULL, EX_CANTCREAT);
			}
			listfilename = optarg;
			break;
		case 'n':
			/* Don't complain about the -nostdinc directrive */
			if (strcmp(optarg, "ostdinc")) {
				fprintf(stderr, "%s: Unknown option -%c%s\n",
					appname, ch, optarg);
				usage();
				/* NOTREACHED */
			}
			break;
		case 'o':
			if ((ofile = fopen(optarg, "w")) == NULL) {
				perror(optarg);
				stop(NULL, EX_CANTCREAT);
			}
			ofilename = optarg;
			break;
		case 'p':
			/* Create Register Diagnostic "printing" Functions */
			if ((regdiagfile = fopen(optarg, "w")) == NULL) {
				perror(optarg);
				stop(NULL, EX_CANTCREAT);
			}
			regdiagfilename = optarg;
			break;
		case 'r':
			if ((regfile = fopen(optarg, "w")) == NULL) {
				perror(optarg);
				stop(NULL, EX_CANTCREAT);
			}
			regfilename = optarg;
			break;
		case 'I':
		{
			path_entry_t include_dir;

			if (strcmp(optarg, "-") == 0) {
				if (includes_search_curdir == 0) {
					fprintf(stderr, "%s: Warning - '-I-' "
							"specified multiple "
							"times\n", appname);
				}
				includes_search_curdir = 0;
				for (include_dir = SLIST_FIRST(&search_path);
				     include_dir != NULL;
				     include_dir = SLIST_NEXT(include_dir,
							      links))
					/*
					 * All entries before a '-I-' only
					 * apply to includes specified with
					 * quotes instead of "<>".
					 */
					include_dir->quoted_includes_only = 1;
			} else {
				include_dir =
				    (path_entry_t)malloc(sizeof(*include_dir));
				if (include_dir == NULL) {
					perror(optarg);
					stop(NULL, EX_OSERR);
				}
				include_dir->directory = strdup(optarg);
				if (include_dir->directory == NULL) {
					perror(optarg);
					stop(NULL, EX_OSERR);
				}
				include_dir->quoted_includes_only = 0;
				SLIST_INSERT_HEAD(&search_path, include_dir,
						  links);
			}
			break;
		}
		case 'X':
			/* icc version of -nostdinc */
			break;
		case '?':
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 1) {
		fprintf(stderr, "%s: No input file specifiled\n", appname);
		usage();
		/* NOTREACHED */
	}

	if (regdiagfile != NULL
	 && (regfile == NULL || stock_include_file == NULL)) {
		fprintf(stderr,
			"%s: The -p option requires the -r and -i options.\n",
			appname);
		usage();
		/* NOTREACHED */
	}
	symtable_open();
	inputfilename = *argv;
	include_file(*argv, SOURCE_FILE);
	retval = yyparse();
	if (retval == 0) {
		if (SLIST_FIRST(&scope_stack) == NULL
		 || SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {
			stop("Unterminated conditional expression", EX_DATAERR);
			/* NOTREACHED */
		}

		/* Process outmost scope */
		process_scope(SLIST_FIRST(&scope_stack));
		/*
		 * Decend the tree of scopes and insert/emit
		 * patches as appropriate.  We perform a depth first
		 * tranversal, recursively handling each scope.
		 */
		/* start at the root scope */
		dump_scope(SLIST_FIRST(&scope_stack));

		/* Patch up forward jump addresses */
		back_patch();

		if (ofile != NULL)
			output_code();
		if (regfile != NULL)
			symtable_dump(regfile, regdiagfile);
		if (listfile != NULL)
			output_listing(inputfilename);
	}

	stop(NULL, 0);
	/* NOTREACHED */
	return (0);
}

static void
usage()
{

	(void)fprintf(stderr,
"usage: %-16s [-nostdinc|-X] [-I-] [-I directory] [-o output_file]\n"
"	[-r register_output_file [-p register_diag_file -i includefile]]\n"
"	[-l program_list_file]\n"
"	input_file\n", appname);
	exit(EX_USAGE);
}

static void
back_patch()
{
	struct instruction *cur_instr;

	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links)) {
		if (cur_instr->patch_label != NULL) {
			struct ins_format3 *f3_instr;
			u_int address;

			if (cur_instr->patch_label->type != LABEL) {
				char buf[255];

				snprintf(buf, sizeof(buf),
					 "Undefined label %s",
					 cur_instr->patch_label->name);
				stop(buf, EX_DATAERR);
				/* NOTREACHED */
			}
			f3_instr = &cur_instr->format.format3;
			address = f3_instr->address;
			address += cur_instr->patch_label->info.linfo->address;
			f3_instr->address = address;
		}
	}
}

static void
output_code()
{
	struct instruction *cur_instr;
	patch_t *cur_patch;
	critical_section_t *cs;
	symbol_node_t *cur_node;
	int instrcount;

	instrcount = 0;
	fprintf(ofile,
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);

	fprintf(ofile, "static const uint8_t seqprog[] = {\n");
	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links)) {

		fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
			cur_instr == TAILQ_FIRST(&seq_program) ? "" : ",\n",
#if BYTE_ORDER == LITTLE_ENDIAN
			cur_instr->format.bytes[0],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[3]);
#else
			cur_instr->format.bytes[3],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[0]);
#endif
		instrcount++;
	}
	fprintf(ofile, "\n};\n\n");

	if (patch_arg_list == NULL)
		stop("Patch argument list not defined",
		     EX_DATAERR);

	/*
	 *  Output patch information.  Patch functions first.
	 */
	fprintf(ofile,
"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);

	for (cur_node = SLIST_FIRST(&patch_functions);
	     cur_node != NULL;
	     cur_node = SLIST_NEXT(cur_node,links)) {
		fprintf(ofile,
"static %spatch_func_t %spatch%d_func;\n"
"\n"
"static int\n"
"%spatch%d_func(%s)\n"
"{\n"
"	return (%s);\n"
"}\n\n",
			prefix,
			prefix,
			cur_node->symbol->info.condinfo->func_num,
			prefix,
			cur_node->symbol->info.condinfo->func_num,
			patch_arg_list,
			cur_node->symbol->name);
	}

	fprintf(ofile,
"static const struct patch {\n"
"	%spatch_func_t		*patch_func;\n"
"	uint32_t		 begin		:10,\n"
"				 skip_instr	:10,\n"
"				 skip_patch	:12;\n"
"} patches[] = {\n", prefix);

	for (cur_patch = TAILQ_FIRST(&patches);
	     cur_patch != NULL;
	     cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
			cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
			prefix,
			cur_patch->patch_func, cur_patch->begin,
			cur_patch->skip_instr, cur_patch->skip_patch);
	}

	fprintf(ofile, "\n};\n\n");

	fprintf(ofile,
"static const struct cs {\n"
"	uint16_t	begin;\n"
"	uint16_t	end;\n"
"} critical_sections[] = {\n");

	for (cs = TAILQ_FIRST(&cs_tailq);
	     cs != NULL;
	     cs = TAILQ_NEXT(cs, links)) {
		fprintf(ofile, "%s\t{ %d, %d }",
			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
			cs->begin_addr, cs->end_addr);
	}

	fprintf(ofile, "\n};\n\n");

	fprintf(ofile,
"#define NUM_CRITICAL_SECTIONS (sizeof(critical_sections) / sizeof(*critical_sections))\n");

	fprintf(stderr, "%s: %d instructions used\n", appname, instrcount);
}

static void
dump_scope(scope_t *scope)
{
	scope_t *cur_scope;

	/*
	 * Emit the first patch for this scope
	 */
	emit_patch(scope, 0);

	/*
	 * Dump each scope within this one.
	 */
	cur_scope = TAILQ_FIRST(&scope->inner_scope);

	while (cur_scope != NULL) {

		dump_scope(cur_scope);

		cur_scope = TAILQ_NEXT(cur_scope, scope_links);
	}

	/*
	 * Emit the second, closing, patch for this scope
	 */
	emit_patch(scope, 1);
}

void
emit_patch(scope_t *scope, int patch)
{
	patch_info_t *pinfo;
	patch_t *new_patch;

	pinfo = &scope->patches[patch];

	if (pinfo->skip_instr == 0)
		/* No-Op patch */
		return;

	new_patch = (patch_t *)malloc(sizeof(*new_patch));

	if (new_patch == NULL)
		stop("Could not malloc patch structure", EX_OSERR);

	memset(new_patch, 0, sizeof(*new_patch));

	if (patch == 0) {
		new_patch->patch_func = scope->func_num;
		new_patch->begin = scope->begin_addr;
	} else {
		new_patch->patch_func = 0;
		new_patch->begin = scope->end_addr;
	}
	new_patch->skip_instr = pinfo->skip_instr;
	new_patch->skip_patch = pinfo->skip_patch;
	TAILQ_INSERT_TAIL(&patches, new_patch, links);
}

void
output_listing(char *ifilename)
{
	char buf[1024];
	FILE *ifile;
	struct instruction *cur_instr;
	patch_t *cur_patch;
	symbol_node_t *cur_func;
	int *func_values;
	int instrcount;
	int instrptr;
	int line;
	int func_count;
	int skip_addr;

	instrcount = 0;
	instrptr = 0;
	line = 1;
	skip_addr = 0;
	if ((ifile = fopen(ifilename, "r")) == NULL) {
		perror(ifilename);
		stop(NULL, EX_DATAERR);
	}

	/*
	 * Determine which options to apply to this listing.
	 */
	for (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);
	    cur_func != NULL;
	    cur_func = SLIST_NEXT(cur_func, links))
		func_count++;

	func_values = NULL;
	if (func_count != 0) {
		func_values = (int *)malloc(func_count * sizeof(int));

		if (func_values == NULL)
			stop("Could not malloc", EX_OSERR);
		
		func_values[0] = 0; /* FALSE func */
		func_count--;

		/*
		 * Ask the user to fill in the return values for
		 * the rest of the functions.
		 */
		
		
		for (cur_func = SLIST_FIRST(&patch_functions);
		     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;
		     cur_func = SLIST_NEXT(cur_func, links), func_count--) {
			int input;
			
			fprintf(stdout, "\n(%s)\n", cur_func->symbol->name);
			fprintf(stdout,
				"Enter the return value for "
				"this expression[T/F]:");

			while (1) {

				input = getchar();
				input = toupper(input);

				if (input == 'T') {
					func_values[func_count] = 1;
					break;
				} else if (input == 'F') {
					func_values[func_count] = 0;
					break;
				}
			}
			if (isatty(fileno(stdin)) == 0)
				putchar(input);
		}
		fprintf(stdout, "\nThanks!\n");
	}

	/* Now output the listing */
	cur_patch = TAILQ_FIRST(&patches);
	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {

		if (check_patch(&cur_patch, instrcount,
				&skip_addr, func_values) == 0) {
			/* Don't count this instruction as it is in a patch
			 * that was removed.
			 */
                        continue;
		}

		while (line < cur_instr->srcline) {
			fgets(buf, sizeof(buf), ifile);
				fprintf(listfile, "             \t%s", buf);
				line++;
		}
		fprintf(listfile, "%04x %02x%02x%02x%02x", instrptr,
#if BYTE_ORDER == LITTLE_ENDIAN
			cur_instr->format.bytes[0],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[3]);
#else
			cur_instr->format.bytes[3],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[0]);
#endif
		/*
		 * Macro expansions can cause several instructions
		 * to be output for a single source line.  Only
		 * advance the line once in these cases.
		 */
		if (line == cur_instr->srcline) {
			fgets(buf, sizeof(buf), ifile);
			fprintf(listfile, "\t%s", buf);
			line++;
		} else {
			fprintf(listfile, "\n");
		}
		instrptr++;
	}
	/* Dump the remainder of the file */
	while(fgets(buf, sizeof(buf), ifile) != NULL)
		fprintf(listfile, "             %s", buf);

	fclose(ifile);
}

static int
check_patch(patch_t **start_patch, int start_instr,
	    int *skip_addr, int *func_vals)
{
	patch_t *cur_patch;

	cur_patch = *start_patch;

	while (cur_patch != NULL && start_instr == cur_patch->begin) {
		if (func_vals[cur_patch->patch_func] == 0) {
			int skip;

			/* Start rejecting code */
			*skip_addr = start_instr + cur_patch->skip_instr;
			for (skip = cur_patch->skip_patch;
			     skip > 0 && cur_patch != NULL;
			     skip--)
				cur_patch = TAILQ_NEXT(cur_patch, links);
		} else {
			/* Accepted this patch.  Advance to the next
			 * one and wait for our intruction pointer to
			 * hit this point.
			 */
			cur_patch = TAILQ_NEXT(cur_patch, links);
		}
	}

	*start_patch = cur_patch;
	if (start_instr < *skip_addr)
		/* Still skipping */
		return (0);

	return (1);
}

/*
 * Print out error information if appropriate, and clean up before
 * terminating the program.
 */
void
stop(const char *string, int err_code)
{
	if (string != NULL) {
		fprintf(stderr, "%s: ", appname);
		if (yyfilename != NULL) {
			fprintf(stderr, "Stopped at file %s, line %d - ",
				yyfilename, yylineno);
		}
		fprintf(stderr, "%s\n", string);
	}

	if (ofile != NULL) {
		fclose(ofile);
		if (err_code != 0) {
			fprintf(stderr, "%s: Removing %s due to error\n",
				appname, ofilename);
			unlink(ofilename);
		}
	}

	if (regfile != NULL) {
		fclose(regfile);
		if (err_code != 0) {
			fprintf(stderr, "%s: Removing %s due to error\n",
				appname, regfilename);
			unlink(regfilename);
		}
	}

	if (listfile != NULL) {
		fclose(listfile);
		if (err_code != 0) {
			fprintf(stderr, "%s: Removing %s due to error\n",
				appname, listfilename);
			unlink(listfilename);
		}
	}

	symlist_free(&patch_functions);
	symtable_close();

	exit(err_code);
}

struct instruction *
seq_alloc()
{
	struct instruction *new_instr;

	new_instr = (struct instruction *)malloc(sizeof(struct instruction));
	if (new_instr == NULL)
		stop("Unable to malloc instruction object", EX_SOFTWARE);
	memset(new_instr, 0, sizeof(*new_instr));
	TAILQ_INSERT_TAIL(&seq_program, new_instr, links);
	new_instr->srcline = yylineno;
	return new_instr;
}

critical_section_t *
cs_alloc()
{
	critical_section_t *new_cs;

	new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
	if (new_cs == NULL)
		stop("Unable to malloc critical_section object", EX_SOFTWARE);
	memset(new_cs, 0, sizeof(*new_cs));
	
	TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
	return new_cs;
}

scope_t *
scope_alloc()
{
	scope_t *new_scope;

	new_scope = (scope_t *)malloc(sizeof(scope_t));
	if (new_scope == NULL)
		stop("Unable to malloc scope object", EX_SOFTWARE);
	memset(new_scope, 0, sizeof(*new_scope));
	TAILQ_INIT(&new_scope->inner_scope);
	
	if (SLIST_FIRST(&scope_stack) != NULL) {
		TAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,
				  new_scope, scope_links);
	}
	/* This patch is now the current scope */
	SLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);
	return new_scope;
}

void
process_scope(scope_t *scope)
{
	/*
	 * We are "leaving" this scope.  We should now have
	 * enough information to process the lists of scopes
	 * we encapsulate.
	 */
	scope_t *cur_scope;
	u_int skip_patch_count;
	u_int skip_instr_count;

	cur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);
	skip_patch_count = 0;
	skip_instr_count = 0;
	while (cur_scope != NULL) {
		u_int patch0_patch_skip;

		patch0_patch_skip = 0;
		switch (cur_scope->type) {
		case SCOPE_IF:
		case SCOPE_ELSE_IF:
			if (skip_instr_count != 0) {
				/* Create a tail patch */
				patch0_patch_skip++;
				cur_scope->patches[1].skip_patch =
				    skip_patch_count + 1;
				cur_scope->patches[1].skip_instr =
				    skip_instr_count;
			}

			/* Count Head patch */
			patch0_patch_skip++;

			/* Count any patches contained in our inner scope */
			patch0_patch_skip += cur_scope->inner_scope_patches;

			cur_scope->patches[0].skip_patch = patch0_patch_skip;
			cur_scope->patches[0].skip_instr =
			    cur_scope->end_addr - cur_scope->begin_addr;

			skip_instr_count += cur_scope->patches[0].skip_instr;

			skip_patch_count += patch0_patch_skip;
			if (cur_scope->type == SCOPE_IF) {
				scope->inner_scope_patches += skip_patch_count;
				skip_patch_count = 0;
			        skip_instr_count = 0;
			}
			break;
		case SCOPE_ELSE:
			/* Count any patches contained in our innter scope */
			skip_patch_count += cur_scope->inner_scope_patches;

			skip_instr_count += cur_scope->end_addr
					  - cur_scope->begin_addr;
			break;
		case SCOPE_ROOT:
			stop("Unexpected scope type encountered", EX_SOFTWARE);
			/* NOTREACHED */
		}

		cur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);
	}
}
@


1.15
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.14 2005/10/04 23:46:14 krw Exp $ */
d41 1
a41 1
 * $Id: aicasm.c,v 1.14 2005/10/04 23:46:14 krw Exp $
a55 2

#if linux
a56 3
#else
#include <machine/endian.h>
#endif
@


1.14
log
@Emit '#define NUM_CRIT_SECTIONS' instead of 'static const int
num_crit_sections' so that array declarations in aic7[9x]xx.c use
compile time constructs that can be parsed by Anil. No functional
change.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.13 2004/09/18 19:51:53 mickey Exp $ */
d41 1
a41 1
 * $Id: aicasm.c,v 1.13 2004/09/18 19:51:53 mickey Exp $
a44 1
#include <sys/cdefs.h>
@


1.13
log
@repair build that reused y.tab.h for two different parsers
thus failing a build every other time.
make generated arrays const and repair rcsid generation for output.
allow one-step build; from krw@@
krw@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.12 2004/06/12 03:37:19 krw Exp $ */
d41 1
a41 1
 * $Id: aicasm.c,v 1.12 2004/06/12 03:37:19 krw Exp $
d459 1
a459 2
"static const int num_critical_sections = sizeof(critical_sections)\n"
"				       / sizeof(*critical_sections);\n");
@


1.12
log
@Sync with FreeBSD aicasm. No changes to the generated reg.h or seq.h
files used by ahc or ahd result from these changes, so they are not
being sync'ed at this time.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.11 2003/12/24 23:27:55 krw Exp $ */
d41 1
a41 1
 * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#23 $
d370 1
a370 1
	fprintf(ofile, "static uint8_t seqprog[] = {\n");
d423 1
a423 1
"static struct patch {\n"
d443 1
a443 1
"static struct cs {\n"
@


1.11
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 3
/* $OpenBSD: aicasm.c,v 1.10 2003/08/12 20:27:02 mickey Exp $ */
/*	$NetBSD: aicasm.c,v 1.5 2003/07/14 15:42:39 lukem Exp $	*/

d41 3
a43 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.35 2002/08/31 06:39:40 gibbs Exp $
a44 1

a45 2
/* __RCSID("$NetBSD: aicasm.c,v 1.5 2003/07/14 15:42:39 lukem Exp $"); */

d148 1
a148 1
	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
d249 3
d317 1
a317 1
"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
d617 1
a617 1
				fprintf(listfile, "\t\t%s", buf);
d620 1
a620 1
		fprintf(listfile, "%03x %02x%02x%02x%02x", instrptr,
d632 12
a643 3
		fgets(buf, sizeof(buf), ifile);
		fprintf(listfile, "\t%s", buf);
		line++;
d648 1
a648 1
		fprintf(listfile, "\t\t%s", buf);
@


1.10
log
@constify sequencer script; krw@@ ok
@
text
@d1 3
a3 1
/* $OpenBSD: aicasm.c,v 1.9 2002/11/19 18:36:18 jason Exp $ */
d8 1
a8 1
 * Copyright (c) 2001 Adaptec Inc.
d43 1
a43 3
 * $Id: aicasm.c,v 1.9 2002/11/19 18:36:18 jason Exp $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.34 2002/06/05 22:51:54 gibbs Exp $
d45 4
d61 6
d69 1
a69 1
#include "sequencer.h"
d93 1
d100 2
d119 2
d122 1
a122 3
main(argc, argv)
	int argc;
	char *argv[];
d134 1
a134 1
        TAILQ_INIT(&cs_tailq);
d151 1
a151 1
	while ((ch = getopt(argc, argv, "d:l:n:o:r:I:O:")) != -1) {
d171 3
d198 8
d224 4
a227 2
				SLIST_FOREACH(include_dir, &search_path,
				    links) {
a233 1
				}
d267 8
d282 1
a282 2
			stop("Unterminated conditional expression",
			     EX_DATAERR);
d301 2
a302 3
		if (regfile != NULL) {
			symtable_dump(regfile);
		}
d318 3
a320 3
"			[-r register_output_file] [-l program_list_file]\n"
"			input_file\n",
			appname);
d329 3
a331 3
	for(cur_instr = seq_program.tqh_first;
	    cur_instr != NULL;
	    cur_instr = cur_instr->links.tqe_next) {
d358 1
a358 1
        critical_section_t *cs;
d370 4
a373 4
	fprintf(ofile, "static const u_int8_t seqprog[] = {\n");
	for(cur_instr = seq_program.tqh_first;
	    cur_instr != NULL;
	    cur_instr = cur_instr->links.tqe_next) {
d375 2
a376 2
                fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
                        cur_instr == seq_program.tqh_first ? "" : ",\n",
d383 4
a386 4
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
d390 1
a390 1
        fprintf(ofile, "\n};\n\n");
d399 6
a404 3
	for(cur_node = SLIST_FIRST(&patch_functions);
	    cur_node != NULL;
	    cur_node = SLIST_NEXT(cur_node,links)) {
d406 1
a406 1
"static int aic_patch%d_func(%s);\n"
d409 1
a409 1
"aic_patch%d_func(%s)\n"
d413 2
d416 1
a416 1
			patch_arg_list,
a422 1
"typedef int patch_func_t (%s);\n"
d424 12
a435 11
"	patch_func_t	*patch_func;\n"
"	uint32_t	begin	   :10,\n"
"			skip_instr :10,\n"
"			skip_patch :12;\n"
"} const patches[] = {\n", patch_arg_list);

	for(cur_patch = TAILQ_FIRST(&patches);
	    cur_patch != NULL;
            cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ aic_patch%d_func, %d, %d, %d }",
                        cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
d438 1
a438 1
        }
d442 1
a442 1
        fprintf(ofile,
d444 10
a453 10
"	u_int16_t	begin;\n"
"	u_int16_t	end;\n"
"} const critical_sections[] = {\n");

        for(cs = TAILQ_FIRST(&cs_tailq);
            cs != NULL;
            cs = TAILQ_NEXT(cs, links)) {
                fprintf(ofile, "%s\t{ %d, %d }",
                        cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
                        cs->begin_addr, cs->end_addr);
d458 1
a458 1
        fprintf(ofile,
d556 1
a556 1
        func_values = NULL;
d603 3
a605 3
	for(cur_instr = TAILQ_FIRST(&seq_program);
	    cur_instr != NULL;
	    cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {
d627 4
a630 4
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
d684 1
a684 3
stop(string, err_code)
	const char *string;
	int  err_code;
d745 1
a745 1
        critical_section_t *new_cs;
d747 7
a753 7
        new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
        if (new_cs == NULL)
                stop("Unable to malloc critical_section object", EX_SOFTWARE);
        memset(new_cs, 0, sizeof(*new_cs));
        
        TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
        return new_cs;
@


1.9
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.8 2002/06/30 18:25:58 smurph Exp $ */
d41 1
a41 1
 * $Id: aicasm.c,v 1.8 2002/06/30 18:25:58 smurph Exp $
d339 1
a339 1
	fprintf(ofile, "static u_int8_t seqprog[] = {\n");
d393 1
a393 1
"} patches[] = {\n", patch_arg_list);
d410 1
a410 1
"} critical_sections[] = {\n");
@


1.8
log
@New aicasm synced with FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.7 2002/06/28 00:34:55 smurph Exp $ */
d41 1
a41 1
 * $Id: aicasm.c,v 1.7 2002/06/28 00:34:55 smurph Exp $
d200 2
a201 3
				for (include_dir = search_path.slh_first;
				     include_dir != NULL;
				     include_dir = include_dir->links.sle_next)
d208 1
@


1.7
log
@Return of new ahc
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.6 2002/03/19 21:07:25 millert Exp $ */
d5 2
a6 1
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
d14 9
a22 3
 *    without modification, immediately at the beginning of the file.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 1
 * $Id: //depot/src/aic7xxx/aicasm/aicasm.c#8 $
d43 1
a43 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.32 2001/07/18 21:03:32 gibbs Exp $
d49 2
d73 2
a74 2
static void output_code(FILE *ofile);
static void output_listing(FILE *listfile, char *ifilename);
d89 2
d99 1
d101 1
d134 1
d136 1
d144 1
d147 1
d268 1
a268 1
			output_code(ofile);
d273 1
a273 1
			output_listing(listfile, inputfilename);
d286 3
a288 3
"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]
			[-r register_output_file] [-l program_list_file]
			input_file\n",
d323 1
a323 2
output_code(ofile)
	FILE *ofile;
d333 5
a337 5
"/*
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
d361 4
d372 7
a378 7
"static int ahc_patch%d_func(struct ahc_softc *ahc);

static int
ahc_patch%d_func(struct ahc_softc *ahc)
{
	return (%s);
}\n\n",
d380 1
d382 1
d387 7
a393 7
"typedef int patch_func_t(struct ahc_softc *);
struct patch {
	patch_func_t	*patch_func;
	u_int32_t	begin	   :10,
			skip_instr :10,
			skip_patch :12;
} patches[] = {\n");
d398 1
a398 1
                fprintf(ofile, "%s\t{ ahc_patch%d_func, %d, %d, %d }",
d404 1
a404 1
        fprintf(ofile, "\n};\n");
d407 4
a410 4
"struct cs {
        u_int16_t       begin;
        u_int16_t       end;
} critical_sections[] = {\n");
d420 1
a420 1
	fprintf(ofile, "\n};\n");
d423 2
a424 2
"const int num_critical_sections = sizeof(critical_sections)
                                 / sizeof(*critical_sections);\n");
d489 1
a489 1
output_listing(FILE *listfile, char *ifilename)
@


1.6
log
@remove __P
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.5 2002/03/19 02:49:20 millert Exp $ */
d5 1
a5 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
d17 3
d32 3
a34 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm.c,v 1.23 1999/08/28 00:41:25 peter Exp $
d80 1
d106 1
d309 1
d316 4
a319 2
 * DO NOT EDIT - This file is automatically generated.
 */\n");
d326 3
a328 1
		fprintf(ofile, "\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\n",
d333 6
d341 1
a341 1
	fprintf(ofile, "};\n\n");
d373 3
a375 2
	    cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "\t{ ahc_patch%d_func, %d, %d, %d },\n",
d378 16
d398 4
d496 1
d561 1
d566 6
d682 14
@


1.5
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.1 2000/03/22 02:50:49 smurph Exp $ */
d83 1
a83 1
extern int yyparse __P((void));
d345 1
a345 1
"typedef int patch_func_t __P((struct ahc_softc *));
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.3 2002/02/16 05:06:52 smurph Exp $ */
d5 1
a5 1
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 3
 * $Id: aicasm.c,v 1.3 2002/02/16 05:06:52 smurph Exp $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.32 2001/07/18 21:03:32 gibbs Exp $
d43 1
a43 1
#include "aicasm_insformat.h"
a74 1
struct cs_tailq cs_tailq;
d83 1
a83 1
extern int yyparse(void);
a99 1
        TAILQ_INIT(&cs_tailq);
a301 1
        critical_section_t *cs;
d308 2
a309 4
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
d316 1
a316 3
                fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
                        cur_instr == seq_program.tqh_first ? "" : ",\n",
#if BYTE_ORDER == LITTLE_ENDIAN
a320 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
d323 1
a323 1
        fprintf(ofile, "\n};\n\n");
d345 1
a345 1
"typedef int patch_func_t(struct ahc_softc *);
d355 2
a356 3
            cur_patch = TAILQ_NEXT(cur_patch,links)) {
                fprintf(ofile, "%s\t{ ahc_patch%d_func, %d, %d, %d }",
                        cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
a358 16
        }

        fprintf(ofile, "\n};\n");

        fprintf(ofile,
"struct cs {
        u_int16_t       begin;
        u_int16_t       end;
} critical_sections[] = {\n");

        for(cs = TAILQ_FIRST(&cs_tailq);
            cs != NULL;
            cs = TAILQ_NEXT(cs, links)) {
                fprintf(ofile, "%s\t{ %d, %d }",
                        cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
                        cs->begin_addr, cs->end_addr);
a362 4
        fprintf(ofile,
"const int num_critical_sections = sizeof(critical_sections)
                                 / sizeof(*critical_sections);\n");

a456 1
        func_values = NULL;
a520 1
#if BYTE_ORDER == LITTLE_ENDIAN
a524 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
a634 14
}

critical_section_t *
cs_alloc()
{
        critical_section_t *new_cs;

        new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
        if (new_cs == NULL)
                stop("Unable to malloc critical_section object", EX_SOFTWARE);
        memset(new_cs, 0, sizeof(*new_cs));
        
        TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
        return new_cs;
@


1.3
log
@change to reflect the removal of sequencer.h
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.2 2002/02/16 04:36:33 smurph Exp $ */
d32 1
a32 1
 * $Id: aicasm.c,v 1.2 2002/02/16 04:36:33 smurph Exp $
d89 1
a89 1
extern int yyparse __P((void));
d363 1
a363 1
"typedef int patch_func_t __P((struct ahc_softc *));
@


1.2
log
@New port of FreeBSD's ahc driver
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.1 2000/03/22 02:50:49 smurph Exp $ */
d32 1
a32 1
 * $Id: //depot/src/aic7xxx/aicasm/aicasm.c#8 $
d48 1
a48 1
#include "sequencer.h"
@


1.1
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d5 1
a5 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
d17 3
d32 3
a34 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm.c,v 1.23 1999/08/28 00:41:25 peter Exp $
d80 1
d106 1
d309 1
d316 4
a319 2
 * DO NOT EDIT - This file is automatically generated.
 */\n");
d326 3
a328 1
		fprintf(ofile, "\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\n",
d333 6
d341 1
a341 1
	fprintf(ofile, "};\n\n");
d373 3
a375 2
	    cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "\t{ ahc_patch%d_func, %d, %d, %d },\n",
d378 16
d398 4
d496 1
d561 1
d566 6
d682 14
@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.1 2000/03/22 02:50:49 smurph Exp $ */
d83 1
a83 1
extern int yyparse(void);
d345 1
a345 1
"typedef int patch_func_t(struct ahc_softc *);
@


1.1.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: aicasm.c,v 1.1.12.1 2002/06/11 03:42:22 art Exp $ */
d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d13 3
a15 9
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 6
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id$
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.34 2002/06/05 22:51:54 gibbs Exp $
a34 2
#include <inttypes.h>
#include <regex.h>
d57 2
a58 2
static void output_code(void);
static void output_listing(char *ifilename);
a72 2
int   src_mode;
int   dst_mode;
a74 1
struct cs_tailq cs_tailq;
a79 1
extern int mm_flex_debug;
a80 1
extern int mmdebug;
a99 1
        TAILQ_INIT(&cs_tailq);
a111 1
	mm_flex_debug = 0;
a112 1
	mmdebug = 0;
a119 1
				mm_flex_debug = 1;
a121 1
				mmdebug = 1;
d242 1
a242 1
			output_code();
d247 1
a247 1
			output_listing(inputfilename);
d260 3
a262 3
"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
"			[-r register_output_file] [-l program_list_file]\n"
"			input_file\n",
d297 2
a298 1
output_code()
a301 1
        critical_section_t *cs;
d307 3
a309 5
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);
d316 1
a316 3
                fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
                        cur_instr == seq_program.tqh_first ? "" : ",\n",
#if BYTE_ORDER == LITTLE_ENDIAN
a320 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
d323 1
a323 5
        fprintf(ofile, "\n};\n\n");

	if (patch_arg_list == NULL)
		stop("Patch argument list not defined",
		     EX_DATAERR);
d332 7
a338 7
"static int aic_patch%d_func(%s);\n"
"\n"
"static int\n"
"aic_patch%d_func(%s)\n"
"{\n"
"	return (%s);\n"
"}\n\n",
a339 1
			patch_arg_list,
a340 1
			patch_arg_list,
d345 7
a351 7
"typedef int patch_func_t (%s);\n"
"static struct patch {\n"
"	patch_func_t	*patch_func;\n"
"	uint32_t	begin	   :10,\n"
"			skip_instr :10,\n"
"			skip_patch :12;\n"
"} patches[] = {\n", patch_arg_list);
d355 2
a356 3
            cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ aic_patch%d_func, %d, %d, %d }",
                        cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
a358 16
        }

	fprintf(ofile, "\n};\n\n");

        fprintf(ofile,
"static struct cs {\n"
"	u_int16_t	begin;\n"
"	u_int16_t	end;\n"
"} critical_sections[] = {\n");

        for(cs = TAILQ_FIRST(&cs_tailq);
            cs != NULL;
            cs = TAILQ_NEXT(cs, links)) {
                fprintf(ofile, "%s\t{ %d, %d }",
                        cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
                        cs->begin_addr, cs->end_addr);
d361 1
a361 5
	fprintf(ofile, "\n};\n\n");

        fprintf(ofile,
"static const int num_critical_sections = sizeof(critical_sections)\n"
"				       / sizeof(*critical_sections);\n");
d426 1
a426 1
output_listing(char *ifilename)
a456 1
        func_values = NULL;
a520 1
#if BYTE_ORDER == LITTLE_ENDIAN
a524 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
a634 14
}

critical_section_t *
cs_alloc()
{
        critical_section_t *new_cs;

        new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
        if (new_cs == NULL)
                stop("Unable to malloc critical_section object", EX_SOFTWARE);
        memset(new_cs, 0, sizeof(*new_cs));
        
        TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
        return new_cs;
@


1.1.12.3
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d200 3
a202 2
				SLIST_FOREACH(include_dir, &search_path,
				    links) {
a208 1
				}
@


1.1.2.1
log
@Sync with -current
@
text
@@


1.1.2.2
log
@Merge in trunk
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 3
 * $Id$
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.32 2001/07/18 21:03:32 gibbs Exp $
d43 1
a43 1
#include "aicasm_insformat.h"
a74 1
struct cs_tailq cs_tailq;
a99 1
        TAILQ_INIT(&cs_tailq);
a301 1
        critical_section_t *cs;
d308 2
a309 4
 * DO NOT EDIT - This file is automatically generated
 *               from the following source files:
 *
%s */\n", versions);
d316 1
a316 3
                fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
                        cur_instr == seq_program.tqh_first ? "" : ",\n",
#if BYTE_ORDER == LITTLE_ENDIAN
a320 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
d323 1
a323 1
        fprintf(ofile, "\n};\n\n");
d355 2
a356 3
            cur_patch = TAILQ_NEXT(cur_patch,links)) {
                fprintf(ofile, "%s\t{ ahc_patch%d_func, %d, %d, %d }",
                        cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
a358 16
        }

        fprintf(ofile, "\n};\n");

        fprintf(ofile,
"struct cs {
        u_int16_t       begin;
        u_int16_t       end;
} critical_sections[] = {\n");

        for(cs = TAILQ_FIRST(&cs_tailq);
            cs != NULL;
            cs = TAILQ_NEXT(cs, links)) {
                fprintf(ofile, "%s\t{ %d, %d }",
                        cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
                        cs->begin_addr, cs->end_addr);
a362 4
        fprintf(ofile,
"const int num_critical_sections = sizeof(critical_sections)
                                 / sizeof(*critical_sections);\n");

a456 1
        func_values = NULL;
a520 1
#if BYTE_ORDER == LITTLE_ENDIAN
a524 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
a634 14
}

critical_section_t *
cs_alloc()
{
        critical_section_t *new_cs;

        new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
        if (new_cs == NULL)
                stop("Unable to malloc critical_section object", EX_SOFTWARE);
        memset(new_cs, 0, sizeof(*new_cs));
        
        TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
        return new_cs;
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
d17 3
d32 3
a34 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm.c,v 1.23 1999/08/28 00:41:25 peter Exp $
d48 1
a48 1
#include "sequencer.h"
d80 1
d89 1
a89 1
extern int yyparse(void);
d106 1
d309 1
d316 4
a319 2
 * DO NOT EDIT - This file is automatically generated.
 */\n");
d326 3
a328 1
		fprintf(ofile, "\t0x%02x, 0x%02x, 0x%02x, 0x%02x,\n",
d333 6
d341 1
a341 1
	fprintf(ofile, "};\n\n");
d363 1
a363 1
"typedef int patch_func_t(struct ahc_softc *);
d373 3
a375 2
	    cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "\t{ ahc_patch%d_func, %d, %d, %d },\n",
d378 16
d398 4
d496 1
d561 1
d566 6
d682 14
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d13 3
a15 9
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 6
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id$
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.34 2002/06/05 22:51:54 gibbs Exp $
a34 2
#include <inttypes.h>
#include <regex.h>
d57 2
a58 2
static void output_code(void);
static void output_listing(char *ifilename);
a72 2
int   src_mode;
int   dst_mode;
a74 1
struct cs_tailq cs_tailq;
a79 1
extern int mm_flex_debug;
a80 1
extern int mmdebug;
a99 1
        TAILQ_INIT(&cs_tailq);
a111 1
	mm_flex_debug = 0;
a112 1
	mmdebug = 0;
a119 1
				mm_flex_debug = 1;
a121 1
				mmdebug = 1;
d174 3
a176 2
				SLIST_FOREACH(include_dir, &search_path,
				    links) {
a182 1
				}
d242 1
a242 1
			output_code();
d247 1
a247 1
			output_listing(inputfilename);
d260 3
a262 3
"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
"			[-r register_output_file] [-l program_list_file]\n"
"			input_file\n",
d297 2
a298 1
output_code()
a301 1
        critical_section_t *cs;
d307 3
a309 5
"/*\n"
" * DO NOT EDIT - This file is automatically generated\n"
" *		 from the following source files:\n"
" *\n"
"%s */\n", versions);
d316 1
a316 3
                fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
                        cur_instr == seq_program.tqh_first ? "" : ",\n",
#if BYTE_ORDER == LITTLE_ENDIAN
a320 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
d323 1
a323 5
        fprintf(ofile, "\n};\n\n");

	if (patch_arg_list == NULL)
		stop("Patch argument list not defined",
		     EX_DATAERR);
d332 7
a338 7
"static int aic_patch%d_func(%s);\n"
"\n"
"static int\n"
"aic_patch%d_func(%s)\n"
"{\n"
"	return (%s);\n"
"}\n\n",
a339 1
			patch_arg_list,
a340 1
			patch_arg_list,
d345 7
a351 7
"typedef int patch_func_t (%s);\n"
"static struct patch {\n"
"	patch_func_t	*patch_func;\n"
"	uint32_t	begin	   :10,\n"
"			skip_instr :10,\n"
"			skip_patch :12;\n"
"} patches[] = {\n", patch_arg_list);
d355 2
a356 3
            cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ aic_patch%d_func, %d, %d, %d }",
                        cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
a358 16
        }

	fprintf(ofile, "\n};\n\n");

        fprintf(ofile,
"static struct cs {\n"
"	u_int16_t	begin;\n"
"	u_int16_t	end;\n"
"} critical_sections[] = {\n");

        for(cs = TAILQ_FIRST(&cs_tailq);
            cs != NULL;
            cs = TAILQ_NEXT(cs, links)) {
                fprintf(ofile, "%s\t{ %d, %d }",
                        cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
                        cs->begin_addr, cs->end_addr);
d361 1
a361 5
	fprintf(ofile, "\n};\n\n");

        fprintf(ofile,
"static const int num_critical_sections = sizeof(critical_sections)\n"
"				       / sizeof(*critical_sections);\n");
d426 1
a426 1
output_listing(char *ifilename)
a456 1
        func_values = NULL;
a520 1
#if BYTE_ORDER == LITTLE_ENDIAN
a524 6
#else
                        cur_instr->format.bytes[3],
                        cur_instr->format.bytes[2],
                        cur_instr->format.bytes[1],
                        cur_instr->format.bytes[0]);
#endif
a634 14
}

critical_section_t *
cs_alloc()
{
        critical_section_t *new_cs;

        new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
        if (new_cs == NULL)
                stop("Unable to malloc critical_section object", EX_SOFTWARE);
        memset(new_cs, 0, sizeof(*new_cs));
        
        TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
        return new_cs;
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a1 2
/*	$NetBSD: aicasm.c,v 1.5 2003/07/14 15:42:39 lukem Exp $	*/

d6 1
a6 1
 * Copyright (c) 2001, 2002 Adaptec Inc.
d41 3
a43 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.35 2002/08/31 06:39:40 gibbs Exp $
a44 4

#include <sys/cdefs.h>
/* __RCSID("$NetBSD: aicasm.c,v 1.5 2003/07/14 15:42:39 lukem Exp $"); */

a56 6
#if linux
#include <endian.h>
#else
#include <machine/endian.h>
#endif

d59 1
a59 1
#include "aicasm_insformat.h"
a82 1
char *stock_include_file;
a88 2
char *regdiagfilename;
FILE *regdiagfile;
a105 2
int main(int argc, char *argv[]);

d107 3
a109 1
main(int argc, char *argv[])
d121 1
a121 1
	TAILQ_INIT(&cs_tailq);
d138 1
a138 1
	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
a157 3
		case 'i':
			stock_include_file = optarg;
			break;
a181 8
		case 'p':
			/* Create Register Diagnostic "printing" Functions */
			if ((regdiagfile = fopen(optarg, "w")) == NULL) {
				perror(optarg);
				stop(NULL, EX_CANTCREAT);
			}
			regdiagfilename = optarg;
			break;
d200 2
a201 4
				for (include_dir = SLIST_FIRST(&search_path);
				     include_dir != NULL;
				     include_dir = SLIST_NEXT(include_dir,
							      links))
d208 1
a241 8
	if (regdiagfile != NULL
	 && (regfile == NULL || stock_include_file == NULL)) {
		fprintf(stderr,
			"%s: The -p option requires the -r and -i options.\n",
			appname);
		usage();
		/* NOTREACHED */
	}
d249 2
a250 1
			stop("Unterminated conditional expression", EX_DATAERR);
d269 3
a271 2
		if (regfile != NULL)
			symtable_dump(regfile, regdiagfile);
d287 3
a289 3
"	[-r register_output_file [-p register_diag_file -i includefile]]\n"
"	[-l program_list_file]\n"
"	input_file\n", appname);
d298 3
a300 3
	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links)) {
d327 1
a327 1
	critical_section_t *cs;
d339 4
a342 4
	fprintf(ofile, "static uint8_t seqprog[] = {\n");
	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links)) {
d344 2
a345 2
		fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
			cur_instr == TAILQ_FIRST(&seq_program) ? "" : ",\n",
d352 4
a355 4
			cur_instr->format.bytes[3],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[0]);
d359 1
a359 1
	fprintf(ofile, "\n};\n\n");
d368 3
a370 6
	fprintf(ofile,
"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);

	for (cur_node = SLIST_FIRST(&patch_functions);
	     cur_node != NULL;
	     cur_node = SLIST_NEXT(cur_node,links)) {
d372 1
a372 1
"static %spatch_func_t %spatch%d_func;\n"
d375 1
a375 1
"%spatch%d_func(%s)\n"
a378 2
			prefix,
			prefix,
d380 1
a380 1
			prefix,
d387 1
d389 11
a399 12
"	%spatch_func_t		*patch_func;\n"
"	uint32_t		 begin		:10,\n"
"				 skip_instr	:10,\n"
"				 skip_patch	:12;\n"
"} patches[] = {\n", prefix);

	for (cur_patch = TAILQ_FIRST(&patches);
	     cur_patch != NULL;
	     cur_patch = TAILQ_NEXT(cur_patch,links)) {
		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
			cur_patch == TAILQ_FIRST(&patches) ? "" : ",\n",
			prefix,
d402 1
a402 1
	}
d406 1
a406 1
	fprintf(ofile,
d408 2
a409 2
"	uint16_t	begin;\n"
"	uint16_t	end;\n"
d412 6
a417 6
	for (cs = TAILQ_FIRST(&cs_tailq);
	     cs != NULL;
	     cs = TAILQ_NEXT(cs, links)) {
		fprintf(ofile, "%s\t{ %d, %d }",
			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
			cs->begin_addr, cs->end_addr);
d422 1
a422 1
	fprintf(ofile,
d520 1
a520 1
	func_values = NULL;
d567 3
a569 3
	for (cur_instr = TAILQ_FIRST(&seq_program);
	     cur_instr != NULL;
	     cur_instr = TAILQ_NEXT(cur_instr, links), instrcount++) {
d591 4
a594 4
			cur_instr->format.bytes[3],
			cur_instr->format.bytes[2],
			cur_instr->format.bytes[1],
			cur_instr->format.bytes[0]);
d648 3
a650 1
stop(const char *string, int err_code)
d711 1
a711 1
	critical_section_t *new_cs;
d713 7
a719 7
	new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
	if (new_cs == NULL)
		stop("Unable to malloc critical_section object", EX_SOFTWARE);
	memset(new_cs, 0, sizeof(*new_cs));
	
	TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
	return new_cs;
@


1.1.2.6
log
@sync to HEAD
@
text
@d2 2
d43 1
a43 3
 * $Id$
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.37 2004/03/12 21:45:25 trhodes Exp $
d45 1
d47 2
d151 1
a151 1
	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:X")) != -1) {
a251 3
		case 'X':
			/* icc version of -nostdinc */
			break;
d317 1
a317 1
"usage: %-16s [-nostdinc|-X] [-I-] [-I directory] [-o output_file]\n"
d617 1
a617 1
				fprintf(listfile, "             \t%s", buf);
d620 1
a620 1
		fprintf(listfile, "%04x %02x%02x%02x%02x", instrptr,
d632 3
a634 12
		/*
		 * Macro expansions can cause several instructions
		 * to be output for a single source line.  Only
		 * advance the line once in these cases.
		 */
		if (line == cur_instr->srcline) {
			fgets(buf, sizeof(buf), ifile);
			fprintf(listfile, "\t%s", buf);
			line++;
		} else {
			fprintf(listfile, "\n");
		}
d639 1
a639 1
		fprintf(listfile, "             %s", buf);
@


