head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.38
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.28
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.36
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.34
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.32
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.30
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.26
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.24
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.22
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.20
	OPENBSD_5_0:1.10.0.18
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.16
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.14
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.10
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.5
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.10
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.18.19.51.53;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.12.03.37.20;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.28.00.34.55;	author smurph;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2000.03.24.09.09.14;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.28.00.38.17;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.06.13.08.50.13;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2003.05.19.22.16.04;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@%{
/*	$OpenBSD: aicasm_scan.l,v 1.9 2004/09/18 19:51:53 mickey Exp $	*/
/*
 * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.
 *
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001, 2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $Id: aicasm_scan.l,v 1.9 2004/09/18 19:51:53 mickey Exp $
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.22 2003/12/16 23:54:07 gibbs Exp $
 */

#include <sys/types.h>

#include <inttypes.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <string.h>
#include <sysexits.h>
#ifdef __linux__
#include "../queue.h"
#else
#include <sys/queue.h>
#endif

#include "aicasm.h"
#include "aicasm_symbol.h"
#include "aicasm_gram.h"

/* This is used for macro body capture too, so err on the large size. */
#define MAX_STR_CONST 4096
static char string_buf[MAX_STR_CONST];
static char *string_buf_ptr;
static int  parren_count;
static int  quote_count;
static char buf[255];
%}

PATH		([/]*[-A-Za-z0-9_.])+
WORD		[A-Za-z_][-A-Za-z_0-9]*
SPACE		[ \t]+
MCARG		[^(), \t]+
MBODY		((\\[^\n])*[^\n\\]*)+

%x COMMENT
%x CEXPR
%x INCLUDE
%x STRING
%x MACRODEF
%x MACROARGLIST
%x MACROCALLARGS
%x MACROBODY

%%
\n			{ ++yylineno; }
\r			;
"/*"			{ BEGIN COMMENT;  /* Enter comment eating state */ }
<COMMENT>"/*"		{ fprintf(stderr, "Warning! Comment within comment."); }
<COMMENT>\n		{ ++yylineno; }
<COMMENT>[^*/\n]*	;
<COMMENT>"*"+[^*/\n]*	;
<COMMENT>"/"+[^*/\n]*	;
<COMMENT>"*"+"/"	{ BEGIN INITIAL; }
if[ \t]*\(		{
				string_buf_ptr = string_buf;
				parren_count = 1;
				BEGIN CEXPR;
				return T_IF;
			}
<CEXPR>\(		{	*string_buf_ptr++ = '('; parren_count++; }
<CEXPR>\)		{
				parren_count--;
				if (parren_count == 0) {
					/* All done */
					BEGIN INITIAL;
					*string_buf_ptr = '\0';
					yylval.sym = symtable_get(string_buf);
					return T_CEXPR;
				} else {
					*string_buf_ptr++ = ')';
				}
			}
<CEXPR>\n		{ ++yylineno; }
<CEXPR>\r		;
<CEXPR>[^()\n]+	{
				char *yptr;

				yptr = yytext;
				while (*yptr != '\0') {
					/* Remove duplicate spaces */
					if (*yptr == '\t')
						*yptr = ' ';
					if (*yptr == ' '
					 && string_buf_ptr != string_buf
					 && string_buf_ptr[-1] == ' ')
						yptr++;
					else 
						*string_buf_ptr++ = *yptr++;
				}
			}

VERSION			{ return T_VERSION; }
PREFIX			{ return T_PREFIX; }
PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
\"			{
				string_buf_ptr = string_buf;
				BEGIN STRING;
			}
<STRING>[^"]+		{
				char *yptr;

				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
<STRING>\"		{
				/* All done */
				BEGIN INITIAL;
				*string_buf_ptr = '\0';
				yylval.str = string_buf;
				return T_STRING;
			}
{SPACE}			 ;

	/* Register/SCB/SRAM definition keywords */
export			{ return T_EXPORT; }
register		{ return T_REGISTER; }
const			{ yylval.value = FALSE; return T_CONST; }
download		{ return T_DOWNLOAD; }
address			{ return T_ADDRESS; }
access_mode		{ return T_ACCESS_MODE; }
modes			{ return T_MODES; }
RW|RO|WO		{
				 if (strcmp(yytext, "RW") == 0)
					yylval.value = RW;
				 else if (strcmp(yytext, "RO") == 0)
					yylval.value = RO;
				 else
					yylval.value = WO;
				 return T_MODE;
			}
BEGIN_CRITICAL		{ return T_BEGIN_CS; }
END_CRITICAL		{ return T_END_CS; }
SET_SRC_MODE		{ return T_SET_SRC_MODE; }
SET_DST_MODE		{ return T_SET_DST_MODE; }
field			{ return T_FIELD; }
enum			{ return T_ENUM; }
mask			{ return T_MASK; }
alias			{ return T_ALIAS; }
size			{ return T_SIZE; }
scb			{ return T_SCB; }
scratch_ram		{ return T_SRAM; }
accumulator		{ return T_ACCUM; }
mode_pointer		{ return T_MODE_PTR; }
allones			{ return T_ALLONES; }
allzeros		{ return T_ALLZEROS; }
none			{ return T_NONE; }
sindex			{ return T_SINDEX; }
A			{ return T_A; }

	/* Opcodes */
shl			{ return T_SHL; }
shr			{ return T_SHR; }
ror			{ return T_ROR; }
rol			{ return T_ROL; }
mvi			{ return T_MVI; }
mov			{ return T_MOV; }
clr			{ return T_CLR; }
jmp			{ return T_JMP; }
jc			{ return T_JC;	}
jnc			{ return T_JNC;	}
je			{ return T_JE;	}
jne			{ return T_JNE;	}
jz			{ return T_JZ;	}
jnz			{ return T_JNZ;	}
call			{ return T_CALL; }
add			{ return T_ADD; }
adc			{ return T_ADC; }
bmov			{ return T_BMOV; }
inc			{ return T_INC; }
dec			{ return T_DEC; }
stc			{ return T_STC;	}
clc			{ return T_CLC; }
cmp			{ return T_CMP;	}
not			{ return T_NOT;	}
xor			{ return T_XOR;	}
test			{ return T_TEST;}
and			{ return T_AND;	}
or			{ return T_OR;	}
ret			{ return T_RET; }
nop			{ return T_NOP; }
else			{ return T_ELSE; }

	/* Allowed Symbols */
\<\<			{ return T_EXPR_LSHIFT; }
\>\>			{ return T_EXPR_RSHIFT; }
[-+,:()~|&."{};<>[\]/*!=] { return yytext[0]; }

	/* Number processing */
0[0-7]*			{
				yylval.value = strtol(yytext, NULL, 8);
				return T_NUMBER;
			}

0[xX][0-9a-fA-F]+	{
				yylval.value = strtoul(yytext + 2, NULL, 16);
				return T_NUMBER;
			}

[1-9][0-9]*		{
				yylval.value = strtol(yytext, NULL, 10);
				return T_NUMBER;
			}
	/* Include Files */
#include{SPACE}		{
				BEGIN INCLUDE;
				quote_count = 0;
				return T_INCLUDE;
			}
<INCLUDE>[<]		{ return yytext[0]; }
<INCLUDE>[>]		{ BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]		{
				if (quote_count != 0)
					BEGIN INITIAL;
				quote_count++;
				return yytext[0];
			}
<INCLUDE>{PATH}		{
				char *yptr;

				yptr = yytext;
				string_buf_ptr = string_buf;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
				yylval.str = string_buf;
				*string_buf_ptr = '\0';
				return T_PATH;
			}
<INCLUDE>.		{ stop("Invalid include line", EX_DATAERR); }
#define{SPACE}		{
				BEGIN MACRODEF;
				return T_DEFINE;
			}
<MACRODEF>{WORD}{SPACE}	{ 
				char *yptr;

				/* Strip space and return as a normal symbol */
				yptr = yytext;
				while (*yptr != ' ' && *yptr != '\t')
					yptr++;
				*yptr = '\0';
				yylval.sym = symtable_get(yytext);
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return T_SYMBOL;
			}
<MACRODEF>{WORD}\(	{
				/*
				 * We store the symbol with its opening
				 * parren so we can differentiate macros
				 * that take args from macros with the
				 * same name that do not take args as
				 * is allowed in C.
				 */
				BEGIN MACROARGLIST;
				yylval.sym = symtable_get(yytext);
				unput('(');
				return T_SYMBOL;
			}
<MACROARGLIST>{WORD}	{
				yylval.str = yytext;
				return T_ARG;
			}
<MACROARGLIST>{SPACE}   ;
<MACROARGLIST>[(,]	{
				return yytext[0];
			}
<MACROARGLIST>[)]	{
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return ')';
			}
<MACROARGLIST>.		{
				snprintf(buf, sizeof(buf), "Invalid character "
					 "'%c' in macro argument list",
					 yytext[0]);
				stop(buf, EX_DATAERR);
			}
<MACROCALLARGS>{SPACE}  ;
<MACROCALLARGS>\(	{
				parren_count++;
				if (parren_count == 1)
					return ('(');
				*string_buf_ptr++ = '(';
			}
<MACROCALLARGS>\)	{
				parren_count--;
				if (parren_count == 0) {
					BEGIN INITIAL;
					return (')');
				}
				*string_buf_ptr++ = ')';
			}
<MACROCALLARGS>{MCARG}	{
				char *yptr;

				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
<MACROCALLARGS>\,	{
				if (string_buf_ptr != string_buf) {
					/*
					 * Return an argument and
					 * rescan this comma so we
					 * can return it as well.
					 */
					*string_buf_ptr = '\0';
					yylval.str = string_buf;
					string_buf_ptr = string_buf;
					unput(',');
					return T_ARG;
				}
				return ',';
			}
<MACROBODY>\\\n		{
				/* Eat escaped newlines. */
				++yylineno;
			}
<MACROBODY>\r		;
<MACROBODY>\n		{
				/* Macros end on the first unescaped newline. */
				BEGIN INITIAL;
				*string_buf_ptr = '\0';
				yylval.str = string_buf;
				++yylineno;
				return T_MACROBODY;
			}
<MACROBODY>{MBODY}	{
				char *yptr;
				char c;

				yptr = yytext;
				while (c = *yptr++) {
					/*
					 * Strip carriage returns.
					 */
					if (c == '\r')
						continue;
					*string_buf_ptr++ = c;
				}
			}
{WORD}\(		{
				char *yptr;
				char *ycopy;

				/* May be a symbol or a macro invocation. */
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					YY_BUFFER_STATE old_state;
					YY_BUFFER_STATE temp_state;

					ycopy = strdup(yytext);
					yptr = ycopy + yyleng;
					while (yptr > ycopy)
						unput(*--yptr);
					old_state = YY_CURRENT_BUFFER;
					temp_state =
					    yy_create_buffer(stdin,
							     YY_BUF_SIZE);
					yy_switch_to_buffer(temp_state);
					mm_switch_to_buffer(old_state);
					mmparse();
					mm_switch_to_buffer(temp_state);
					yy_switch_to_buffer(old_state);
					mm_delete_buffer(temp_state);
					expand_macro(yylval.sym);
				} else {
					if (yylval.sym->type == UNINITIALIZED) {
						/* Try without the '(' */
						symbol_delete(yylval.sym);
						yytext[yyleng-1] = '\0';
						yylval.sym =
						    symtable_get(yytext);
					}
					unput('(');
					return T_SYMBOL;
				}
			}
{WORD}			{
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					expand_macro(yylval.sym);
				} else {
					return T_SYMBOL;
				}
			}
.			{ 
				snprintf(buf, sizeof(buf), "Invalid character "
					 "'%c'", yytext[0]);
				stop(buf, EX_DATAERR);
			}
%%

typedef struct include {
        YY_BUFFER_STATE  buffer;
        int              lineno;
        char            *filename;
	SLIST_ENTRY(include) links;
}include_t;

SLIST_HEAD(, include) include_stack;

void
include_file(char *file_name, include_type type)
{
	FILE *newfile;
	include_t *include;

	newfile = NULL;
	/* Try the current directory first */
	if (includes_search_curdir != 0 || type == SOURCE_FILE)
		newfile = fopen(file_name, "r");

	if (newfile == NULL && type != SOURCE_FILE) {
                path_entry_t include_dir;
		SLIST_FOREACH(include_dir, &search_path, links) {
			char fullname[PATH_MAX];

			if ((include_dir->quoted_includes_only == TRUE)
			 && (type != QUOTED_INCLUDE))
				continue;

			snprintf(fullname, sizeof(fullname),
				 "%s/%s", include_dir->directory, file_name);

			if ((newfile = fopen(fullname, "r")) != NULL)
				break;
                }
        }

	if (newfile == NULL) {
		perror(file_name);
		stop("Unable to open input file", EX_SOFTWARE);
		/* NOTREACHED */
	}

	if (type != SOURCE_FILE) {
		include = (include_t *)malloc(sizeof(include_t));
		if (include == NULL) {
			stop("Unable to allocate include stack entry",
			     EX_SOFTWARE);
			/* NOTREACHED */
		}
		include->buffer = YY_CURRENT_BUFFER;
		include->lineno = yylineno;
		include->filename = yyfilename;
		SLIST_INSERT_HEAD(&include_stack, include, links);
	}
	yy_switch_to_buffer(yy_create_buffer(newfile, YY_BUF_SIZE));
	yylineno = 1;
	yyfilename = strdup(file_name);
}

static void next_substitution(struct symbol *mac_symbol, const char *body_pos,
			      const char **next_match,
			      struct macro_arg **match_marg, regmatch_t *match);

void
expand_macro(struct symbol *macro_symbol)
{
	struct macro_arg *marg;
	struct macro_arg *match_marg;
	const char *body_head;
	const char *body_pos;
	const char *next_match;

	/*
	 * Due to the nature of unput, we must work
	 * backwards through the macro body performing
	 * any expansions.
	 */
	body_head = macro_symbol->info.macroinfo->body;
	body_pos = body_head + strlen(body_head);
	while (body_pos > body_head) {
		regmatch_t match;

		next_match = body_head;
		match_marg = NULL;
		next_substitution(macro_symbol, body_pos, &next_match,
				  &match_marg, &match);

		/* Put back everything up until the replacement. */
		while (body_pos > next_match)
			unput(*--body_pos);

		/* Perform the replacement. */
		if (match_marg != NULL) {
			const char *strp;

			next_match = match_marg->replacement_text;
			strp = next_match + strlen(next_match);
			while (strp > next_match)
				unput(*--strp);

			/* Skip past the unexpanded macro arg. */
			body_pos -= match.rm_eo - match.rm_so;
		}
	}

	/* Cleanup replacement text. */
	TAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
		free(marg->replacement_text);
	}
}

/*
 * Find the next substitution in the macro working backwards from
 * body_pos until the beginning of the macro buffer.  next_match
 * should be initialized to the beginning of the macro buffer prior
 * to calling this routine.
 */
static void
next_substitution(struct symbol *mac_symbol, const char *body_pos,
		  const char **next_match, struct macro_arg **match_marg,
		  regmatch_t *match)
{
	regmatch_t	  matches[2];
	struct macro_arg *marg;
	const char	 *search_pos;
	int		  retval;

	do {
		search_pos = *next_match;

		TAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {

			retval = regexec(&marg->arg_regex, search_pos, 2,
					 matches, 0);
			if (retval == 0
			 && (matches[1].rm_eo + search_pos) <= body_pos
			 && (matches[1].rm_eo + search_pos) > *next_match) {
				*match = matches[1];
				*next_match = match->rm_eo + search_pos;
				*match_marg = marg;
			}
		}
	} while (search_pos != *next_match);
}

int
yywrap()
{
	include_t *include;

	yy_delete_buffer(YY_CURRENT_BUFFER);
	(void)fclose(yyin);
	if (yyfilename != NULL)
		free(yyfilename);
	yyfilename = NULL;
	include = SLIST_FIRST(&include_stack);
	if (include != NULL) {
		yy_switch_to_buffer(include->buffer);
		yylineno = include->lineno;
		yyfilename = include->filename;
		SLIST_REMOVE_HEAD(&include_stack, links);
		free(include);
		return (0);
	}
	return (1);
}
@


1.9
log
@repair build that reused y.tab.h for two different parsers
thus failing a build every other time.
make generated arrays const and repair rcsid generation for output.
allow one-step build; from krw@@
krw@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_scan.l,v 1.8 2004/06/12 03:37:20 krw Exp $	*/
d42 1
a42 1
 * $Id: aicasm_scan.l,v 1.8 2004/06/12 03:37:20 krw Exp $
d462 1
a462 3
                for (include_dir = search_path.slh_first;
                     include_dir != NULL;                
                     include_dir = include_dir->links.sle_next) {
d596 1
a596 1
	include = include_stack.slh_first;
@


1.8
log
@Sync with FreeBSD aicasm. No changes to the generated reg.h or seq.h
files used by ahc or ahd result from these changes, so they are not
being sync'ed at this time.

ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_scan.l,v 1.7 2003/12/24 23:27:55 krw Exp $	*/
d42 1
a42 1
 * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#19 $
d63 1
a63 1
#include "y.tab.h"
@


1.7
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d2 1
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: aicasm_scan.l,v 1.3 2003/04/19 19:26:11 fvdl Exp $	*/
d42 3
a44 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.21 2002/09/27 03:23:02 gibbs Exp $
d91 1
d119 1
d365 1
d376 1
d379 8
a386 2
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
@


1.6
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d2 2
d8 1
a8 1
 * Copyright (c) 2001 Adaptec Inc.
d43 1
a43 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.18 2002/06/05 22:51:54 gibbs Exp $
d48 1
d54 3
d58 1
d117 2
a118 2
<CEXPR>[^()\n]+		{
                                char *yptr;
d120 13
a132 13
                                yptr = yytext;
                                while (*yptr != '\0') {
                                        /* Remove duplicate spaces */
                                        if (*yptr == '\t')
                                                *yptr = ' ';
                                        if (*yptr == ' '
                                         && string_buf_ptr != string_buf
                                         && string_buf_ptr[-1] == ' ')
                                                yptr++;
                                        else 
					*string_buf_ptr++ = *yptr++;
                                }
                        }
d134 2
a135 1
VERSION                 { return T_VERSION; }
d137 19
a155 19
\"                      {
                                string_buf_ptr = string_buf;
                                BEGIN STRING;
			}
<STRING>[^"]+           {
                                char *yptr;

                                yptr = yytext;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                        }
<STRING>\"              {
                                /* All done */
                                BEGIN INITIAL;
                                *string_buf_ptr = '\0';
                                yylval.str = string_buf;
                                return T_STRING;
                        }
{SPACE}			;
d174 2
a175 2
BEGIN_CRITICAL          { return T_BEGIN_CS; }
END_CRITICAL            { return T_END_CS; }
d178 2
a179 1
bit			{ return T_BIT; }
d217 1
a217 1
not                     { return T_NOT; }
d247 13
a259 13
#include{SPACE}         {
                                BEGIN INCLUDE;
                                quote_count = 0;
                                return T_INCLUDE;
                        }
<INCLUDE>[<]            { return yytext[0]; }
<INCLUDE>[>]            { BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]           {
                                if (quote_count != 0)
                                        BEGIN INITIAL;
                                quote_count++;
                                return yytext[0];
                        }
d261 1
a261 1
                                char *yptr;
d263 8
a270 8
                                yptr = yytext;
                                string_buf_ptr = string_buf;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                                yylval.str = string_buf;
                                *string_buf_ptr = '\0';
                                return T_PATH;
                        }
d451 3
a453 1
		SLIST_FOREACH(include_dir, &search_path, links) {
d587 2
a588 2
	include = SLIST_FIRST(&include_stack);
	if (include != SLIST_END(&include_stack)) {
@


1.5
log
@New aicasm synced with FreeBSD.
@
text
@d442 1
a442 3
                for (include_dir = search_path.slh_first;
                     include_dir != NULL;                
                     include_dir = include_dir->links.sle_next) {
d576 2
a577 2
	include = include_stack.slh_first;
	if (include != NULL) {
@


1.4
log
@Return of new ahc
@
text
@d5 2
a6 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
d15 8
a22 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.15 1999/12/06 18:23:30 gibbs Exp $
d47 1
d57 7
a63 5
#define MAX_STR_CONST 256
char string_buf[MAX_STR_CONST];
char *string_buf_ptr;
int  parren_count;
int  quote_count;
d66 1
a66 3
%option nounput

PATH		[-/A-Za-z0-9_.]*[./][-/A-Za-z0-9_.]*
d69 2
d76 4
d128 1
d150 1
d156 1
d168 2
d177 1
d218 3
a220 1
[-+,:()~|&."{};<>[\]!=] { return yytext[0]; }
a236 1

d251 1
a251 7
<INCLUDE>.		{ stop("Invalid include line", EX_DATAERR); }

	/* For parsing C include files with #define foo */
#define			{ yylval.value = TRUE; return T_CONST; }
	/* Throw away macros */
#define[^\n]*[()]+[^\n]* ;
<INITIAL,INCLUDE>{PATH} {
d262 7
d270 59
a328 1
{WORD}			{ yylval.sym = symtable_get(yytext);  return T_SYMBOL; }
d330 83
a413 2
				char buf[255];

d430 1
a430 3
include_file(file_name, type)
	char	*file_name;
	include_type type;
d480 86
@


1.3
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d51 1
d54 2
d63 1
d95 1
a95 1
				char *yptr = yytext;
d97 10
a106 1
				while (*yptr != '\0')
d108 2
a109 1
			}
d111 19
d147 2
d186 1
d196 1
a196 1
[-+,:()~|&."{};<>[\]!]	{ return yytext[0]; }
d215 13
a227 4
#include		{ return T_INCLUDE; BEGIN INCLUDE;}
<INCLUDE>[<>\"]		{ return yytext[0]; }
<INCLUDE>{PATH}		{ yylval.str = strdup(yytext); return T_PATH; }
<INCLUDE>;		{ BEGIN INITIAL; return yytext[0]; }
d234 11
a244 1
{PATH}			{ yylval.str = strdup(yytext); return T_PATH; }
@


1.2
log
@New port of FreeBSD's ahc driver
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.15 1999/12/06 18:23:30 gibbs Exp $
a47 1
int  quote_count;
a49 2
%option nounput

a56 1
%x STRING
d88 1
a88 1
                                char *yptr;
d90 1
a90 10
                                yptr = yytext;
                                while (*yptr != '\0') {
                                        /* Remove duplicate spaces */
                                        if (*yptr == '\t')
                                                *yptr = ' ';
                                        if (*yptr == ' '
                                         && string_buf_ptr != string_buf
                                         && string_buf_ptr[-1] == ' ')
                                                yptr++;
                                        else 
d92 1
a92 2
                                }
                        }
a93 19
VERSION                 { return T_VERSION; }
\"                      {
                                string_buf_ptr = string_buf;
                                BEGIN STRING;
			}
<STRING>[^"]+           {
                                char *yptr;

                                yptr = yytext;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                        }
<STRING>\"              {
                                /* All done */
                                BEGIN INITIAL;
                                *string_buf_ptr = '\0';
                                yylval.str = string_buf;
                                return T_STRING;
                        }
a110 2
BEGIN_CRITICAL          { return T_BEGIN_CS; }
END_CRITICAL            { return T_END_CS; }
a147 1
not                     { return T_NOT; }
d157 1
a157 1
[-+,:()~|&."{};<>[\]!=] { return yytext[0]; }
d176 4
a179 13
#include{SPACE}         {
                                BEGIN INCLUDE;
                                quote_count = 0;
                                return T_INCLUDE;
                        }
<INCLUDE>[<]            { return yytext[0]; }
<INCLUDE>[>]            { BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]           {
                                if (quote_count != 0)
                                        BEGIN INITIAL;
                                quote_count++;
                                return yytext[0];
                        }
d186 1
a186 11
<INITIAL,INCLUDE>{PATH} {
                                char *yptr;

                                yptr = yytext;
                                string_buf_ptr = string_buf;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                                yylval.str = string_buf;
                                *string_buf_ptr = '\0';
                                return T_PATH;
                        }
@


1.1
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d51 1
d54 2
d63 1
d95 1
a95 1
				char *yptr = yytext;
d97 10
a106 1
				while (*yptr != '\0')
d108 2
a109 1
			}
d111 19
d147 2
d186 1
d196 1
a196 1
[-+,:()~|&."{};<>[\]!]	{ return yytext[0]; }
d215 13
a227 4
#include		{ return T_INCLUDE; BEGIN INCLUDE;}
<INCLUDE>[<>\"]		{ return yytext[0]; }
<INCLUDE>{PATH}		{ yylval.str = strdup(yytext); return T_PATH; }
<INCLUDE>;		{ BEGIN INITIAL; return yytext[0]; }
d234 11
a244 1
{PATH}			{ yylval.str = strdup(yytext); return T_PATH; }
@


1.1.12.1
log
@sync to -current
@
text
@d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.18 2002/06/05 22:51:54 gibbs Exp $
a34 1
#include <regex.h>
d44 4
a47 7
/* This is used for macro body capture too, so err on the large size. */
#define MAX_STR_CONST 4096
static char string_buf[MAX_STR_CONST];
static char *string_buf_ptr;
static int  parren_count;
static int  quote_count;
static char buf[255];
d50 1
a50 1
PATH		([/]*[-A-Za-z0-9_.])+
a52 2
MCARG		[^(), \t]+
MBODY		((\\[^\n])*[^\n\\]*)+
a56 5
%x STRING
%x MACRODEF
%x MACROARGLIST
%x MACROCALLARGS
%x MACROBODY
d88 1
a88 1
                                char *yptr;
d90 1
a90 10
                                yptr = yytext;
                                while (*yptr != '\0') {
                                        /* Remove duplicate spaces */
                                        if (*yptr == '\t')
                                                *yptr = ' ';
                                        if (*yptr == ' '
                                         && string_buf_ptr != string_buf
                                         && string_buf_ptr[-1] == ' ')
                                                yptr++;
                                        else 
a91 8
                                }
                        }

VERSION                 { return T_VERSION; }
PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
\"                      {
                                string_buf_ptr = string_buf;
                                BEGIN STRING;
a92 2
<STRING>[^"]+           {
                                char *yptr;
a93 11
                                yptr = yytext;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                        }
<STRING>\"              {
                                /* All done */
                                BEGIN INITIAL;
                                *string_buf_ptr = '\0';
                                yylval.str = string_buf;
                                return T_STRING;
                        }
a96 1
export			{ return T_EXPORT; }
a101 1
modes			{ return T_MODES; }
a110 4
BEGIN_CRITICAL          { return T_BEGIN_CS; }
END_CRITICAL            { return T_END_CS; }
SET_SRC_MODE		{ return T_SET_SRC_MODE; }
SET_DST_MODE		{ return T_SET_DST_MODE; }
a117 1
mode_pointer		{ return T_MODE_PTR; }
a147 1
not                     { return T_NOT; }
d157 1
a157 3
\<\<			{ return T_EXPR_LSHIFT; }
\>\>			{ return T_EXPR_RSHIFT; }
[-+,:()~|&."{};<>[\]/*!=] { return yytext[0]; }
d174 1
d176 4
a179 24
#include{SPACE}         {
                                BEGIN INCLUDE;
                                quote_count = 0;
                                return T_INCLUDE;
                        }
<INCLUDE>[<]            { return yytext[0]; }
<INCLUDE>[>]            { BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]           {
                                if (quote_count != 0)
                                        BEGIN INITIAL;
                                quote_count++;
                                return yytext[0];
                        }
<INCLUDE>{PATH}		{
                                char *yptr;

                                yptr = yytext;
                                string_buf_ptr = string_buf;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                                yylval.str = string_buf;
                                *string_buf_ptr = '\0';
                                return T_PATH;
                        }
a180 6
#define{SPACE}		{
				BEGIN MACRODEF;
				return T_DEFINE;
			}
<MACRODEF>{WORD}{SPACE}	{ 
				char *yptr;
d182 5
a186 59
				/* Strip space and return as a normal symbol */
				yptr = yytext;
				while (*yptr != ' ' && *yptr != '\t')
					yptr++;
				*yptr = '\0';
				yylval.sym = symtable_get(yytext);
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return T_SYMBOL;
			}
<MACRODEF>{WORD}\(	{
				/*
				 * We store the symbol with its opening
				 * parren so we can differentiate macros
				 * that take args from macros with the
				 * same name that do not take args as
				 * is allowed in C.
				 */
				BEGIN MACROARGLIST;
				yylval.sym = symtable_get(yytext);
				unput('(');
				return T_SYMBOL;
			}
<MACROARGLIST>{WORD}	{
				yylval.str = yytext;
				return T_ARG;
			}
<MACROARGLIST>{SPACE}   ;
<MACROARGLIST>[(,]	{
				return yytext[0];
			}
<MACROARGLIST>[)]	{
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return ')';
			}
<MACROARGLIST>.		{
				snprintf(buf, sizeof(buf), "Invalid character "
					 "'%c' in macro argument list",
					 yytext[0]);
				stop(buf, EX_DATAERR);
			}
<MACROCALLARGS>{SPACE}  ;
<MACROCALLARGS>\(	{
				parren_count++;
				if (parren_count == 1)
					return ('(');
				*string_buf_ptr++ = '(';
			}
<MACROCALLARGS>\)	{
				parren_count--;
				if (parren_count == 0) {
					BEGIN INITIAL;
					return (')');
				}
				*string_buf_ptr++ = ')';
			}
<MACROCALLARGS>{MCARG}	{
				char *yptr;
d188 1
a188 33
				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
<MACROCALLARGS>\,	{
				if (string_buf_ptr != string_buf) {
					/*
					 * Return an argument and
					 * rescan this comma so we
					 * can return it as well.
					 */
					*string_buf_ptr = '\0';
					yylval.str = string_buf;
					string_buf_ptr = string_buf;
					unput(',');
					return T_ARG;
				}
				return ',';
			}
<MACROBODY>\\\n		{
				/* Eat escaped newlines. */
				++yylineno;
			}
<MACROBODY>\n		{
				/* Macros end on the first unescaped newline. */
				BEGIN INITIAL;
				*string_buf_ptr = '\0';
				yylval.str = string_buf;
				++yylineno;
				return T_MACROBODY;
			}
<MACROBODY>{MBODY}	{
				char *yptr;
a189 49
				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
{WORD}\(		{
				char *yptr;
				char *ycopy;

				/* May be a symbol or a macro invocation. */
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					YY_BUFFER_STATE old_state;
					YY_BUFFER_STATE temp_state;

					ycopy = strdup(yytext);
					yptr = ycopy + yyleng;
					while (yptr > ycopy)
						unput(*--yptr);
					old_state = YY_CURRENT_BUFFER;
					temp_state =
					    yy_create_buffer(stdin,
							     YY_BUF_SIZE);
					yy_switch_to_buffer(temp_state);
					mm_switch_to_buffer(old_state);
					mmparse();
					mm_switch_to_buffer(temp_state);
					yy_switch_to_buffer(old_state);
					mm_delete_buffer(temp_state);
					expand_macro(yylval.sym);
				} else {
					if (yylval.sym->type == UNINITIALIZED) {
						/* Try without the '(' */
						symbol_delete(yylval.sym);
						yytext[yyleng-1] = '\0';
						yylval.sym =
						    symtable_get(yytext);
					}
					unput('(');
					return T_SYMBOL;
				}
			}
{WORD}			{
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					expand_macro(yylval.sym);
				} else {
					return T_SYMBOL;
				}
			}
d191 2
d209 3
a211 1
include_file(char *file_name, include_type type)
a260 86
}

static void next_substitution(struct symbol *mac_symbol, const char *body_pos,
			      const char **next_match,
			      struct macro_arg **match_marg, regmatch_t *match);

void
expand_macro(struct symbol *macro_symbol)
{
	struct macro_arg *marg;
	struct macro_arg *match_marg;
	const char *body_head;
	const char *body_pos;
	const char *next_match;

	/*
	 * Due to the nature of unput, we must work
	 * backwards through the macro body performing
	 * any expansions.
	 */
	body_head = macro_symbol->info.macroinfo->body;
	body_pos = body_head + strlen(body_head);
	while (body_pos > body_head) {
		regmatch_t match;

		next_match = body_head;
		match_marg = NULL;
		next_substitution(macro_symbol, body_pos, &next_match,
				  &match_marg, &match);

		/* Put back everything up until the replacement. */
		while (body_pos > next_match)
			unput(*--body_pos);

		/* Perform the replacement. */
		if (match_marg != NULL) {
			const char *strp;

			next_match = match_marg->replacement_text;
			strp = next_match + strlen(next_match);
			while (strp > next_match)
				unput(*--strp);

			/* Skip past the unexpanded macro arg. */
			body_pos -= match.rm_eo - match.rm_so;
		}
	}

	/* Cleanup replacement text. */
	TAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
		free(marg->replacement_text);
	}
}

/*
 * Find the next substitution in the macro working backwards from
 * body_pos until the beginning of the macro buffer.  next_match
 * should be initialized to the beginning of the macro buffer prior
 * to calling this routine.
 */
static void
next_substitution(struct symbol *mac_symbol, const char *body_pos,
		  const char **next_match, struct macro_arg **match_marg,
		  regmatch_t *match)
{
	regmatch_t	  matches[2];
	struct macro_arg *marg;
	const char	 *search_pos;
	int		  retval;

	do {
		search_pos = *next_match;

		TAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {

			retval = regexec(&marg->arg_regex, search_pos, 2,
					 matches, 0);
			if (retval == 0
			 && (matches[1].rm_eo + search_pos) <= body_pos
			 && (matches[1].rm_eo + search_pos) > *next_match) {
				*match = matches[1];
				*next_match = match->rm_eo + search_pos;
				*match_marg = marg;
			}
		}
	} while (search_pos != *next_match);
@


1.1.12.2
log
@sync
@
text
@d442 3
a444 1
		SLIST_FOREACH(include_dir, &search_path, links) {
d578 2
a579 2
	include = SLIST_FIRST(&include_stack);
	if (include != SLIST_END(&include_stack)) {
@


1.1.2.1
log
@Sync with -current
@
text
@@


1.1.2.2
log
@Merge in trunk
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.15 1999/12/06 18:23:30 gibbs Exp $
a47 1
int  quote_count;
a49 2
%option nounput

a56 1
%x STRING
d88 1
a88 1
                                char *yptr;
d90 1
a90 10
                                yptr = yytext;
                                while (*yptr != '\0') {
                                        /* Remove duplicate spaces */
                                        if (*yptr == '\t')
                                                *yptr = ' ';
                                        if (*yptr == ' '
                                         && string_buf_ptr != string_buf
                                         && string_buf_ptr[-1] == ' ')
                                                yptr++;
                                        else 
d92 1
a92 2
                                }
                        }
a93 19
VERSION                 { return T_VERSION; }
\"                      {
                                string_buf_ptr = string_buf;
                                BEGIN STRING;
			}
<STRING>[^"]+           {
                                char *yptr;

                                yptr = yytext;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                        }
<STRING>\"              {
                                /* All done */
                                BEGIN INITIAL;
                                *string_buf_ptr = '\0';
                                yylval.str = string_buf;
                                return T_STRING;
                        }
a110 2
BEGIN_CRITICAL          { return T_BEGIN_CS; }
END_CRITICAL            { return T_END_CS; }
a147 1
not                     { return T_NOT; }
d157 1
a157 1
[-+,:()~|&."{};<>[\]!=] { return yytext[0]; }
d176 4
a179 13
#include{SPACE}         {
                                BEGIN INCLUDE;
                                quote_count = 0;
                                return T_INCLUDE;
                        }
<INCLUDE>[<]            { return yytext[0]; }
<INCLUDE>[>]            { BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]           {
                                if (quote_count != 0)
                                        BEGIN INITIAL;
                                quote_count++;
                                return yytext[0];
                        }
d186 1
a186 11
<INITIAL,INCLUDE>{PATH} {
                                char *yptr;

                                yptr = yytext;
                                string_buf_ptr = string_buf;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                                yylval.str = string_buf;
                                *string_buf_ptr = '\0';
                                return T_PATH;
                        }
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_scan.l,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d51 1
d54 2
d63 1
d95 1
a95 1
				char *yptr = yytext;
d97 10
a106 1
				while (*yptr != '\0')
d108 2
a109 1
			}
d111 19
d147 2
d186 1
d196 1
a196 1
[-+,:()~|&."{};<>[\]!]	{ return yytext[0]; }
d215 13
a227 4
#include		{ return T_INCLUDE; BEGIN INCLUDE;}
<INCLUDE>[<>\"]		{ return yytext[0]; }
<INCLUDE>{PATH}		{ yylval.str = strdup(yytext); return T_PATH; }
<INCLUDE>;		{ BEGIN INITIAL; return yytext[0]; }
d234 11
a244 1
{PATH}			{ yylval.str = strdup(yytext); return T_PATH; }
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.18 2002/06/05 22:51:54 gibbs Exp $
a34 1
#include <regex.h>
d44 4
a47 7
/* This is used for macro body capture too, so err on the large size. */
#define MAX_STR_CONST 4096
static char string_buf[MAX_STR_CONST];
static char *string_buf_ptr;
static int  parren_count;
static int  quote_count;
static char buf[255];
d50 1
a50 1
PATH		([/]*[-A-Za-z0-9_.])+
a52 2
MCARG		[^(), \t]+
MBODY		((\\[^\n])*[^\n\\]*)+
a56 5
%x STRING
%x MACRODEF
%x MACROARGLIST
%x MACROCALLARGS
%x MACROBODY
d88 1
a88 1
                                char *yptr;
d90 1
a90 10
                                yptr = yytext;
                                while (*yptr != '\0') {
                                        /* Remove duplicate spaces */
                                        if (*yptr == '\t')
                                                *yptr = ' ';
                                        if (*yptr == ' '
                                         && string_buf_ptr != string_buf
                                         && string_buf_ptr[-1] == ' ')
                                                yptr++;
                                        else 
a91 8
                                }
                        }

VERSION                 { return T_VERSION; }
PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
\"                      {
                                string_buf_ptr = string_buf;
                                BEGIN STRING;
a92 2
<STRING>[^"]+           {
                                char *yptr;
a93 11
                                yptr = yytext;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                        }
<STRING>\"              {
                                /* All done */
                                BEGIN INITIAL;
                                *string_buf_ptr = '\0';
                                yylval.str = string_buf;
                                return T_STRING;
                        }
a96 1
export			{ return T_EXPORT; }
a101 1
modes			{ return T_MODES; }
a110 4
BEGIN_CRITICAL          { return T_BEGIN_CS; }
END_CRITICAL            { return T_END_CS; }
SET_SRC_MODE		{ return T_SET_SRC_MODE; }
SET_DST_MODE		{ return T_SET_DST_MODE; }
a117 1
mode_pointer		{ return T_MODE_PTR; }
a147 1
not                     { return T_NOT; }
d157 1
a157 3
\<\<			{ return T_EXPR_LSHIFT; }
\>\>			{ return T_EXPR_RSHIFT; }
[-+,:()~|&."{};<>[\]/*!=] { return yytext[0]; }
d174 1
d176 4
a179 24
#include{SPACE}         {
                                BEGIN INCLUDE;
                                quote_count = 0;
                                return T_INCLUDE;
                        }
<INCLUDE>[<]            { return yytext[0]; }
<INCLUDE>[>]            { BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]           {
                                if (quote_count != 0)
                                        BEGIN INITIAL;
                                quote_count++;
                                return yytext[0];
                        }
<INCLUDE>{PATH}		{
                                char *yptr;

                                yptr = yytext;
                                string_buf_ptr = string_buf;
                                while (*yptr)
                                        *string_buf_ptr++ = *yptr++;
                                yylval.str = string_buf;
                                *string_buf_ptr = '\0';
                                return T_PATH;
                        }
a180 6
#define{SPACE}		{
				BEGIN MACRODEF;
				return T_DEFINE;
			}
<MACRODEF>{WORD}{SPACE}	{ 
				char *yptr;
d182 5
a186 59
				/* Strip space and return as a normal symbol */
				yptr = yytext;
				while (*yptr != ' ' && *yptr != '\t')
					yptr++;
				*yptr = '\0';
				yylval.sym = symtable_get(yytext);
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return T_SYMBOL;
			}
<MACRODEF>{WORD}\(	{
				/*
				 * We store the symbol with its opening
				 * parren so we can differentiate macros
				 * that take args from macros with the
				 * same name that do not take args as
				 * is allowed in C.
				 */
				BEGIN MACROARGLIST;
				yylval.sym = symtable_get(yytext);
				unput('(');
				return T_SYMBOL;
			}
<MACROARGLIST>{WORD}	{
				yylval.str = yytext;
				return T_ARG;
			}
<MACROARGLIST>{SPACE}   ;
<MACROARGLIST>[(,]	{
				return yytext[0];
			}
<MACROARGLIST>[)]	{
				string_buf_ptr = string_buf;
				BEGIN MACROBODY;
				return ')';
			}
<MACROARGLIST>.		{
				snprintf(buf, sizeof(buf), "Invalid character "
					 "'%c' in macro argument list",
					 yytext[0]);
				stop(buf, EX_DATAERR);
			}
<MACROCALLARGS>{SPACE}  ;
<MACROCALLARGS>\(	{
				parren_count++;
				if (parren_count == 1)
					return ('(');
				*string_buf_ptr++ = '(';
			}
<MACROCALLARGS>\)	{
				parren_count--;
				if (parren_count == 0) {
					BEGIN INITIAL;
					return (')');
				}
				*string_buf_ptr++ = ')';
			}
<MACROCALLARGS>{MCARG}	{
				char *yptr;
d188 1
a188 33
				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
<MACROCALLARGS>\,	{
				if (string_buf_ptr != string_buf) {
					/*
					 * Return an argument and
					 * rescan this comma so we
					 * can return it as well.
					 */
					*string_buf_ptr = '\0';
					yylval.str = string_buf;
					string_buf_ptr = string_buf;
					unput(',');
					return T_ARG;
				}
				return ',';
			}
<MACROBODY>\\\n		{
				/* Eat escaped newlines. */
				++yylineno;
			}
<MACROBODY>\n		{
				/* Macros end on the first unescaped newline. */
				BEGIN INITIAL;
				*string_buf_ptr = '\0';
				yylval.str = string_buf;
				++yylineno;
				return T_MACROBODY;
			}
<MACROBODY>{MBODY}	{
				char *yptr;
a189 49
				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
{WORD}\(		{
				char *yptr;
				char *ycopy;

				/* May be a symbol or a macro invocation. */
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					YY_BUFFER_STATE old_state;
					YY_BUFFER_STATE temp_state;

					ycopy = strdup(yytext);
					yptr = ycopy + yyleng;
					while (yptr > ycopy)
						unput(*--yptr);
					old_state = YY_CURRENT_BUFFER;
					temp_state =
					    yy_create_buffer(stdin,
							     YY_BUF_SIZE);
					yy_switch_to_buffer(temp_state);
					mm_switch_to_buffer(old_state);
					mmparse();
					mm_switch_to_buffer(temp_state);
					yy_switch_to_buffer(old_state);
					mm_delete_buffer(temp_state);
					expand_macro(yylval.sym);
				} else {
					if (yylval.sym->type == UNINITIALIZED) {
						/* Try without the '(' */
						symbol_delete(yylval.sym);
						yytext[yyleng-1] = '\0';
						yylval.sym =
						    symtable_get(yytext);
					}
					unput('(');
					return T_SYMBOL;
				}
			}
{WORD}			{
				yylval.sym = symtable_get(yytext);
				if (yylval.sym->type == MACRO) {
					expand_macro(yylval.sym);
				} else {
					return T_SYMBOL;
				}
			}
d191 2
d209 3
a211 1
include_file(char *file_name, include_type type)
d223 3
a225 1
		SLIST_FOREACH(include_dir, &search_path, links) {
a262 86
static void next_substitution(struct symbol *mac_symbol, const char *body_pos,
			      const char **next_match,
			      struct macro_arg **match_marg, regmatch_t *match);

void
expand_macro(struct symbol *macro_symbol)
{
	struct macro_arg *marg;
	struct macro_arg *match_marg;
	const char *body_head;
	const char *body_pos;
	const char *next_match;

	/*
	 * Due to the nature of unput, we must work
	 * backwards through the macro body performing
	 * any expansions.
	 */
	body_head = macro_symbol->info.macroinfo->body;
	body_pos = body_head + strlen(body_head);
	while (body_pos > body_head) {
		regmatch_t match;

		next_match = body_head;
		match_marg = NULL;
		next_substitution(macro_symbol, body_pos, &next_match,
				  &match_marg, &match);

		/* Put back everything up until the replacement. */
		while (body_pos > next_match)
			unput(*--body_pos);

		/* Perform the replacement. */
		if (match_marg != NULL) {
			const char *strp;

			next_match = match_marg->replacement_text;
			strp = next_match + strlen(next_match);
			while (strp > next_match)
				unput(*--strp);

			/* Skip past the unexpanded macro arg. */
			body_pos -= match.rm_eo - match.rm_so;
		}
	}

	/* Cleanup replacement text. */
	TAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
		free(marg->replacement_text);
	}
}

/*
 * Find the next substitution in the macro working backwards from
 * body_pos until the beginning of the macro buffer.  next_match
 * should be initialized to the beginning of the macro buffer prior
 * to calling this routine.
 */
static void
next_substitution(struct symbol *mac_symbol, const char *body_pos,
		  const char **next_match, struct macro_arg **match_marg,
		  regmatch_t *match)
{
	regmatch_t	  matches[2];
	struct macro_arg *marg;
	const char	 *search_pos;
	int		  retval;

	do {
		search_pos = *next_match;

		TAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {

			retval = regexec(&marg->arg_regex, search_pos, 2,
					 matches, 0);
			if (retval == 0
			 && (matches[1].rm_eo + search_pos) <= body_pos
			 && (matches[1].rm_eo + search_pos) > *next_match) {
				*match = matches[1];
				*next_match = match->rm_eo + search_pos;
				*match_marg = marg;
			}
		}
	} while (search_pos != *next_match);
}

d273 2
a274 2
	include = SLIST_FIRST(&include_stack);
	if (include != SLIST_END(&include_stack)) {
@


1.1.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: aicasm_scan.l,v 1.3 2003/04/19 19:26:11 fvdl Exp $	*/
d6 1
a6 1
 * Copyright (c) 2001, 2002 Adaptec Inc.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.21 2002/09/27 03:23:02 gibbs Exp $
a45 1
#include <inttypes.h>
a50 3
#ifdef __linux__
#include "../queue.h"
#else
a51 1
#endif
d110 2
a111 2
<CEXPR>[^()\n]+	{
				char *yptr;
d113 13
a125 13
				yptr = yytext;
				while (*yptr != '\0') {
					/* Remove duplicate spaces */
					if (*yptr == '\t')
						*yptr = ' ';
					if (*yptr == ' '
					 && string_buf_ptr != string_buf
					 && string_buf_ptr[-1] == ' ')
						yptr++;
					else 
						*string_buf_ptr++ = *yptr++;
				}
			}
d127 1
a127 2
VERSION			{ return T_VERSION; }
PREFIX			{ return T_PREFIX; }
d129 19
a147 19
\"			{
				string_buf_ptr = string_buf;
				BEGIN STRING;
			}
<STRING>[^"]+		{
				char *yptr;

				yptr = yytext;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
			}
<STRING>\"		{
				/* All done */
				BEGIN INITIAL;
				*string_buf_ptr = '\0';
				yylval.str = string_buf;
				return T_STRING;
			}
{SPACE}			 ;
d166 2
a167 2
BEGIN_CRITICAL		{ return T_BEGIN_CS; }
END_CRITICAL		{ return T_END_CS; }
d170 1
a170 2
field			{ return T_FIELD; }
enum			{ return T_ENUM; }
d208 1
a208 1
not			{ return T_NOT;	}
d238 13
a250 13
#include{SPACE}		{
				BEGIN INCLUDE;
				quote_count = 0;
				return T_INCLUDE;
			}
<INCLUDE>[<]		{ return yytext[0]; }
<INCLUDE>[>]		{ BEGIN INITIAL; return yytext[0]; }
<INCLUDE>[\"]		{
				if (quote_count != 0)
					BEGIN INITIAL;
				quote_count++;
				return yytext[0];
			}
d252 1
a252 1
				char *yptr;
d254 8
a261 8
				yptr = yytext;
				string_buf_ptr = string_buf;
				while (*yptr)
					*string_buf_ptr++ = *yptr++;
				yylval.str = string_buf;
				*string_buf_ptr = '\0';
				return T_PATH;
			}
d442 1
a442 3
                for (include_dir = search_path.slh_first;
                     include_dir != NULL;                
                     include_dir = include_dir->links.sle_next) {
d576 2
a577 2
	include = include_stack.slh_first;
	if (include != NULL) {
@


1.1.2.6
log
@sync to HEAD
@
text
@d3 1
d43 1
a43 3
 * $Id$
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.22 2003/12/16 23:54:07 gibbs Exp $
a89 1
\r			;
a116 1
<CEXPR>\r		;
a361 1
<MACROBODY>\r		;
a371 1
				char c;
d374 2
a375 8
				while (c = *yptr++) {
					/*
					 * Strip carriage returns.
					 */
					if (c == '\r')
						continue;
					*string_buf_ptr++ = c;
				}
@


