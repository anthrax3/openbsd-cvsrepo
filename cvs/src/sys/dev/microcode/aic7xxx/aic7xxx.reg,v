head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.42
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.38
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.28
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.36
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.34
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.32
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.30
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.26
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.24
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.22
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.20
	OPENBSD_5_0:1.11.0.18
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.16
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.14
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.10
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.2.0.10
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.11
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.08.00.38.09;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.24.22.40.16;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.04.03.48.46;	author smurph;	state Exp;
branches
	1.2.10.1;
next	1.1;

1.1
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.03.24.09.09.13;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.24.58;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;

1.2.10.1
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@/* $OpenBSD: aic7xxx.reg,v 1.10 2004/08/01 01:36:23 krw Exp $ */
/*
 * Aic7xxx register and scratch ram definitions.
 *
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.46 2003/12/17 00:02:09 gibbs Exp $
 */
VERSION = "$Id: aic7xxx.reg,v 1.10 2004/08/01 01:36:23 krw Exp $"

/*
 * This file is processed by the aic7xxx_asm utility for use in assembling
 * firmware for the aic7xxx family of SCSI host adapters as well as to generate
 * a C header file for use in the kernel portion of the Aic7xxx driver.
 *
 * All page numbers refer to the Adaptec AIC-7770 Data Book available from
 * Adaptec's Technical Documents Department 1-800-934-2766
 */

/*
 * SCSI Sequence Control (p. 3-11).
 * Each bit, when set starts a specific SCSI sequence on the bus
 */
register SCSISEQ {
	address			0x000
	access_mode RW
	field	TEMODE		0x80
	field	ENSELO		0x40
	field	ENSELI		0x20
	field	ENRSELI		0x10
	field	ENAUTOATNO	0x08
	field	ENAUTOATNI	0x04
	field	ENAUTOATNP	0x02
	field	SCSIRSTO	0x01
}

/*
 * SCSI Transfer Control 0 Register (pp. 3-13).
 * Controls the SCSI module data path.
 */
register SXFRCTL0 {
	address			0x001
	access_mode RW
	field	DFON		0x80
	field	DFPEXP		0x40
	field	FAST20		0x20
	field	CLRSTCNT	0x10
	field	SPIOEN		0x08
	field	SCAMEN		0x04
	field	CLRCHN		0x02
}

/*
 * SCSI Transfer Control 1 Register (pp. 3-14,15).
 * Controls the SCSI module data path.
 */
register SXFRCTL1 {
	address			0x002
	access_mode RW
	field	BITBUCKET	0x80
	field	SWRAPEN		0x40
	field	ENSPCHK		0x20
	mask	STIMESEL	0x18
	field	ENSTIMER	0x04
	field	ACTNEGEN	0x02
	field	STPWEN		0x01	/* Powered Termination */
}

/*
 * SCSI Control Signal Read Register (p. 3-15).
 * Reads the actual state of the SCSI bus pins
 */
register SCSISIGI {
	address			0x003
	access_mode RO
	field	CDI		0x80
	field	IOI		0x40
	field	MSGI		0x20
	field	ATNI		0x10
	field	SELI		0x08
	field	BSYI		0x04
	field	REQI		0x02
	field	ACKI		0x01
/*
 * Possible phases in SCSISIGI
 */
	mask	PHASE_MASK	CDI|IOI|MSGI
	mask	P_DATAOUT	0x00
	mask	P_DATAIN	IOI
	mask	P_DATAOUT_DT	P_DATAOUT|MSGI
	mask	P_DATAIN_DT	P_DATAIN|MSGI
	mask	P_COMMAND	CDI
	mask	P_MESGOUT	CDI|MSGI
	mask	P_STATUS	CDI|IOI
	mask	P_MESGIN	CDI|IOI|MSGI
}

/*
 * SCSI Control Signal Write Register (p. 3-16).
 * Writing to this register modifies the control signals on the bus.  Only
 * those signals that are allowed in the current mode (Initiator/Target) are
 * asserted.
 */
register SCSISIGO {
	address			0x003
	access_mode WO
	field	CDO		0x80
	field	IOO		0x40
	field	MSGO		0x20
	field	ATNO		0x10
	field	SELO		0x08
	field	BSYO		0x04
	field	REQO		0x02
	field	ACKO		0x01
/*
 * Possible phases to write into SCSISIG0
 */
	mask	PHASE_MASK	CDI|IOI|MSGI
	mask	P_DATAOUT	0x00
	mask	P_DATAIN	IOI
	mask	P_COMMAND	CDI
	mask	P_MESGOUT	CDI|MSGI
	mask	P_STATUS	CDI|IOI
	mask	P_MESGIN	CDI|IOI|MSGI
}

/* 
 * SCSI Rate Control (p. 3-17).
 * Contents of this register determine the Synchronous SCSI data transfer
 * rate and the maximum synchronous Req/Ack offset.  An offset of 0 in the
 * SOFS (3:0) bits disables synchronous data transfers.  Any offset value
 * greater than 0 enables synchronous transfers.
 */
register SCSIRATE {
	address			0x004
	access_mode RW
	field	WIDEXFER	0x80		/* Wide transfer control */
	field	ENABLE_CRC	0x40		/* CRC for D-Phases */
	field	SINGLE_EDGE	0x10		/* Disable DT Transfers */
	mask	SXFR		0x70		/* Sync transfer rate */
	mask	SXFR_ULTRA2	0x0f		/* Sync transfer rate */
	mask	SOFS		0x0f		/* Sync offset */
}

/*
 * SCSI ID (p. 3-18).
 * Contains the ID of the board and the current target on the
 * selected channel.
 */
register SCSIID	{
	address			0x005
	access_mode RW
	mask	TID		0xf0		/* Target ID mask */
	mask	TWIN_TID	0x70
	field	TWIN_CHNLB	0x80
	mask	OID		0x0f		/* Our ID mask */
	/*
	 * SCSI Maximum Offset (p. 4-61 aic7890/91 Data Book)
	 * The aic7890/91 allow an offset of up to 127 transfers in both wide
	 * and narrow mode.
	 */
	alias	SCSIOFFSET
	mask	SOFS_ULTRA2	0x7f		/* Sync offset U2 chips */
}

/*
 * SCSI Latched Data (p. 3-19).
 * Read/Write latches used to transfer data on the SCSI bus during
 * Automatic or Manual PIO mode.  SCSIDATH can be used for the
 * upper byte of a 16bit wide asynchronouse data phase transfer.
 */
register SCSIDATL {
	address			0x006
	access_mode RW
}

register SCSIDATH {
	address			0x007
	access_mode RW
}

/*
 * SCSI Transfer Count (pp. 3-19,20)
 * These registers count down the number of bytes transferred
 * across the SCSI bus.  The counter is decremented only once
 * the data has been safely transferred.  SDONE in SSTAT0 is
 * set when STCNT goes to 0
 */ 
register STCNT {
	address			0x008
	size	3
	access_mode RW
}

/* ALT_MODE registers (Ultra2 and Ultra160 chips) */
register SXFRCTL2 {
	address			0x013
	access_mode RW
	field	AUTORSTDIS	0x10
	field	CMDDMAEN	0x08
	mask	ASYNC_SETUP	0x07
}

/* ALT_MODE register on Ultra160 chips */
register OPTIONMODE {
	address			0x008
	access_mode RW
	field	AUTORATEEN		0x80
	field	AUTOACKEN		0x40
	field	ATNMGMNTEN		0x20
	field	BUSFREEREV		0x10
	field	EXPPHASEDIS		0x08
	field	SCSIDATL_IMGEN		0x04
	field	AUTO_MSGOUT_DE		0x02
	field	DIS_MSGIN_DUALEDGE	0x01
	mask	OPTIONMODE_DEFAULTS	AUTO_MSGOUT_DE|DIS_MSGIN_DUALEDGE
}

/* ALT_MODE register on Ultra160 chips */
register TARGCRCCNT {
	address			0x00a
	size	2
	access_mode RW
}

/*
 * Clear SCSI Interrupt 0 (p. 3-20)
 * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.
 */
register CLRSINT0 {
	address			0x00b
	access_mode WO
	field	CLRSELDO	0x40
	field	CLRSELDI	0x20
	field	CLRSELINGO	0x10
	field	CLRSWRAP	0x08
	field	CLRIOERR	0x08	/* Ultra2 Only */
	field	CLRSPIORDY	0x02
}

/*
 * SCSI Status 0 (p. 3-21)
 * Contains one set of SCSI Interrupt codes
 * These are most likely of interest to the sequencer
 */
register SSTAT0	{
	address			0x00b
	access_mode RO
	field	TARGET		0x80	/* Board acting as target */
	field	SELDO		0x40	/* Selection Done */
	field	SELDI		0x20	/* Board has been selected */
	field	SELINGO		0x10	/* Selection In Progress */
	field	SWRAP		0x08	/* 24bit counter wrap */
	field	IOERR		0x08	/* LVD Tranceiver mode changed */
	field	SDONE		0x04	/* STCNT = 0x000000 */
	field	SPIORDY		0x02	/* SCSI PIO Ready */
	field	DMADONE		0x01	/* DMA transfer completed */
}

/*
 * Clear SCSI Interrupt 1 (p. 3-23)
 * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.
 */
register CLRSINT1 {
	address			0x00c
	access_mode WO
	field	CLRSELTIMEO	0x80
	field	CLRATNO		0x40
	field	CLRSCSIRSTI	0x20
	field	CLRBUSFREE	0x08
	field	CLRSCSIPERR	0x04
	field	CLRPHASECHG	0x02
	field	CLRREQINIT	0x01
}

/*
 * SCSI Status 1 (p. 3-24)
 */
register SSTAT1	{
	address			0x00c
	access_mode RO
	field	SELTO		0x80
	field	ATNTARG 	0x40
	field	SCSIRSTI	0x20
	field	PHASEMIS	0x10
	field	BUSFREE		0x08
	field	SCSIPERR	0x04
	field	PHASECHG	0x02
	field	REQINIT		0x01
}

/*
 * SCSI Status 2 (pp. 3-25,26)
 */
register SSTAT2 {
	address			0x00d
	access_mode RO
	field	OVERRUN		0x80
	field	SHVALID		0x40	/* Shadow Layer non-zero */
	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
	field	CRCVALERR	0x08	/* CRC doesn't match (U3 only) */
	field	CRCENDERR	0x04	/* No terminal CRC packet (U3 only) */
	field	CRCREQERR	0x02	/* Illegal CRC packet req (U3 only) */
	field	DUAL_EDGE_ERR	0x01	/* Incorrect data phase (U3 only) */
	mask	SFCNT		0x1f
}

/*
 * SCSI Status 3 (p. 3-26)
 */
register SSTAT3 {
	address			0x00e
	access_mode RO
	mask	SCSICNT		0xf0
	mask	OFFCNT		0x0f
	mask	U2OFFCNT	0x7f
}

/*
 * SCSI ID for the aic7890/91 chips
 */
register SCSIID_ULTRA2 {
	address			0x00f
	access_mode RW
	mask	TID		0xf0		/* Target ID mask */
	mask	OID		0x0f		/* Our ID mask */
}

/*
 * SCSI Interrupt Mode 1 (p. 3-28)
 * Setting any bit will enable the corresponding function
 * in SIMODE0 to interrupt via the IRQ pin.
 */
register SIMODE0 {
	address			0x010
	access_mode RW
	field	ENSELDO		0x40
	field	ENSELDI		0x20
	field	ENSELINGO	0x10
	field	ENSWRAP		0x08
	field	ENIOERR		0x08	/* LVD Tranceiver mode changes */
	field	ENSDONE		0x04
	field	ENSPIORDY	0x02
	field	ENDMADONE	0x01
}

/*
 * SCSI Interrupt Mode 1 (pp. 3-28,29)
 * Setting any bit will enable the corresponding function
 * in SIMODE1 to interrupt via the IRQ pin.
 */
register SIMODE1 {
	address			0x011
	access_mode RW
	field	ENSELTIMO	0x80
	field	ENATNTARG	0x40
	field	ENSCSIRST	0x20
	field	ENPHASEMIS	0x10
	field	ENBUSFREE	0x08
	field	ENSCSIPERR	0x04
	field	ENPHASECHG	0x02
	field	ENREQINIT	0x01
}

/*
 * SCSI Data Bus (High) (p. 3-29)
 * This register reads data on the SCSI Data bus directly.
 */
register SCSIBUSL {
	address			0x012
	access_mode RW
}

register SCSIBUSH {
	address			0x013
	access_mode RW
}

/*
 * SCSI/Host Address (p. 3-30)
 * These registers hold the host address for the byte about to be
 * transferred on the SCSI bus.  They are counted up in the same
 * manner as STCNT is counted down.  SHADDR should always be used
 * to determine the address of the last byte transferred since HADDR
 * can be skewed by write ahead.
 */
register SHADDR {
	address			0x014
	size	4
	access_mode RO
}

/*
 * Selection Timeout Timer (p. 3-30)
 */
register SELTIMER {
	address			0x018
	access_mode RW
	field	STAGE6		0x20
	field	STAGE5		0x10
	field	STAGE4		0x08
	field	STAGE3		0x04
	field	STAGE2		0x02
	field	STAGE1		0x01
	alias	TARGIDIN
}

/*
 * Selection/Reselection ID (p. 3-31)
 * Upper four bits are the device id.  The ONEBIT is set when the re/selecting
 * device did not set its own ID.
 */
register SELID {
	address			0x019
	access_mode RW
	mask	SELID_MASK	0xf0
	field	ONEBIT		0x08
}

register SCAMCTL {
	address			0x01a
	access_mode RW
	field	ENSCAMSELO	0x80
	field	CLRSCAMSELID	0x40
	field	ALTSTIM		0x20
	field	DFLTTID		0x10
	mask	SCAMLVL		0x03
}

/*
 * Target Mode Selecting in ID bitmask (aic7890/91/96/97)
 */
register TARGID {
	address			0x01b
	size			2
	access_mode RW
}

/*
 * Serial Port I/O Cabability register (p. 4-95 aic7860 Data Book)
 * Indicates if external logic has been attached to the chip to
 * perform the tasks of accessing a serial eeprom, testing termination
 * strength, and performing cable detection.  On the aic7860, most of
 * these features are handled on chip, but on the aic7855 an attached
 * aic3800 does the grunt work.
 */
register SPIOCAP {
	address			0x01b
	access_mode RW
	field	SOFT1		0x80
	field	SOFT0		0x40
	field	SOFTCMDEN	0x20	
	field	EXT_BRDCTL	0x10	/* External Board control */
	field	SEEPROM		0x08	/* External serial eeprom logic */
	field	EEPROM		0x04	/* Writable external BIOS ROM */
	field	ROM		0x02	/* Logic for accessing external ROM */
	field	SSPIOCPS	0x01	/* Termination and cable detection */
}

register BRDCTL	{
	address			0x01d
	field	BRDDAT7		0x80
	field	BRDDAT6		0x40
	field	BRDDAT5		0x20
	field	BRDSTB		0x10
	field	BRDCS		0x08
	field	BRDRW		0x04
	field	BRDCTL1		0x02
	field	BRDCTL0		0x01
	/* 7890 Definitions */
	field	BRDDAT4		0x10
	field	BRDDAT3		0x08
	field	BRDDAT2		0x04
	field	BRDRW_ULTRA2	0x02
	field	BRDSTB_ULTRA2	0x01
}

/*
 * Serial EEPROM Control (p. 4-92 in 7870 Databook)
 * Controls the reading and writing of an external serial 1-bit
 * EEPROM Device.  In order to access the serial EEPROM, you must
 * first set the SEEMS bit that generates a request to the memory
 * port for access to the serial EEPROM device.  When the memory
 * port is not busy servicing another request, it reconfigures
 * to allow access to the serial EEPROM.  When this happens, SEERDY
 * gets set high to verify that the memory port access has been
 * granted.  
 *
 * After successful arbitration for the memory port, the SEECS bit of 
 * the SEECTL register is connected to the chip select.  The SEECK, 
 * SEEDO, and SEEDI are connected to the clock, data out, and data in 
 * lines respectively.  The SEERDY bit of SEECTL is useful in that it 
 * gives us an 800 nsec timer.  After a write to the SEECTL register, 
 * the SEERDY goes high 800 nsec later.  The one exception to this is 
 * when we first request access to the memory port.  The SEERDY goes 
 * high to signify that access has been granted and, for this case, has 
 * no implied timing.
 *
 * See 93cx6.c for detailed information on the protocol necessary to 
 * read the serial EEPROM.
 */
register SEECTL {
	address			0x01e
	field	EXTARBACK	0x80
	field	EXTARBREQ	0x40
	field	SEEMS		0x20
	field	SEERDY		0x10
	field	SEECS		0x08
	field	SEECK		0x04
	field	SEEDO		0x02
	field	SEEDI		0x01
}
/*
 * SCSI Block Control (p. 3-32)
 * Controls Bus type and channel selection.  In a twin channel configuration
 * addresses 0x00-0x1e are gated to the appropriate channel based on this
 * register.  SELWIDE allows for the coexistence of 8bit and 16bit devices
 * on a wide bus.
 */
register SBLKCTL {
	address			0x01f
	access_mode RW
	field	DIAGLEDEN	0x80	/* Aic78X0 only */
	field	DIAGLEDON	0x40	/* Aic78X0 only */
	field	AUTOFLUSHDIS	0x20
	field	SELBUSB		0x08
	field	ENAB40		0x08	/* LVD transceiver active */
	field	ENAB20		0x04	/* SE/HVD transceiver active */
	field	SELWIDE		0x02
	field	XCVR		0x01	/* External transceiver active */
}

/*
 * Sequencer Control (p. 3-33)
 * Error detection mode and speed configuration
 */
register SEQCTL {
	address			0x060
	access_mode RW
	field	PERRORDIS	0x80
	field	PAUSEDIS	0x40
	field	FAILDIS		0x20
	field	FASTMODE	0x10
	field	BRKADRINTEN	0x08
	field	STEP		0x04
	field	SEQRESET	0x02
	field	LOADRAM		0x01
}

/*
 * Sequencer RAM Data (p. 3-34)
 * Single byte window into the Scratch Ram area starting at the address
 * specified by SEQADDR0 and SEQADDR1.  To write a full word, simply write
 * four bytes in succession.  The SEQADDRs will increment after the most
 * significant byte is written
 */
register SEQRAM {
	address			0x061
	access_mode RW
}

/*
 * Sequencer Address Registers (p. 3-35)
 * Only the first bit of SEQADDR1 holds addressing information
 */
register SEQADDR0 {
	address			0x062
	access_mode RW
}

register SEQADDR1 {
	address			0x063
	access_mode RW
	mask	SEQADDR1_MASK	0x01
}

/*
 * Accumulator
 * We cheat by passing arguments in the Accumulator up to the kernel driver
 */
register ACCUM {
	address			0x064
	access_mode RW
	accumulator
}

register SINDEX	{
	address			0x065
	access_mode RW
	sindex
}

register DINDEX {
	address			0x066
	access_mode RW
}

register ALLONES {
	address			0x069
	access_mode RO
	allones
}

register ALLZEROS {
	address			0x06a
	access_mode RO
	allzeros
}

register NONE {
	address			0x06a
	access_mode WO
	none
}

register FLAGS {
	address			0x06b
	access_mode RO
	field	ZERO		0x02
	field	CARRY		0x01
}

register SINDIR	{
	address			0x06c
	access_mode RO
}

register DINDIR	 {
	address			0x06d
	access_mode WO
}

register FUNCTION1 {
	address			0x06e
	access_mode RW
}

register STACK {
	address			0x06f
	access_mode RO
}

const	STACK_SIZE	4

/*
 * Board Control (p. 3-43)
 */
register BCTL {
	address			0x084
	access_mode RW
	field	ACE		0x08
	field	ENABLE		0x01
}

/*
 * On the aic78X0 chips, Board Control is replaced by the DSCommand
 * register (p. 4-64)
 */
register DSCOMMAND0 {
	address			0x084
	access_mode RW
	field	CACHETHEN	0x80	/* Cache Threshold enable */
	field	DPARCKEN	0x40	/* Data Parity Check Enable */
	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
	field	EXTREQLCK	0x10	/* External Request Lock */
	/* aic7890/91/96/97 only */
	field	INTSCBRAMSEL	0x08	/* Internal SCB RAM Select */
	field	RAMPS		0x04	/* External SCB RAM Present */
	field	USCBSIZE32	0x02	/* Use 32byte SCB Page Size */
	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
}

register DSCOMMAND1 {
	address			0x085
	access_mode RW
	mask	DSLATT		0xfc	/* PCI latency timer (non-ultra2) */
	field	HADDLDSEL1	0x02	/* Host Address Load Select Bits */
	field	HADDLDSEL0	0x01
}

/*
 * Bus On/Off Time (p. 3-44) aic7770 only
 */
register BUSTIME {
	address			0x085
	access_mode RW
	mask	BOFF		0xf0
	mask	BON		0x0f
}

/*
 * Bus Speed (p. 3-45) aic7770 only
 */
register BUSSPD {
	address			0x086
	access_mode RW
	mask	DFTHRSH		0xc0
	mask	STBOFF		0x38
	mask	STBON		0x07
	mask	DFTHRSH_100	0xc0
	mask	DFTHRSH_75	0x80
}

/* aic7850/55/60/70/80/95 only */
register DSPCISTATUS {
	address			0x086
	mask	DFTHRSH_100	0xc0
}

/* aic7890/91/96/97 only */
register HS_MAILBOX {
	address			0x086
	mask	HOST_MAILBOX	0xF0
	mask	SEQ_MAILBOX	0x0F
	mask	HOST_TQINPOS	0x80	/* Boundary at either 0 or 128 */
}

const	HOST_MAILBOX_SHIFT	4
const	SEQ_MAILBOX_SHIFT	0

/*
 * Host Control (p. 3-47) R/W
 * Overall host control of the device.
 */
register HCNTRL {
	address			0x087
	access_mode RW
	field	POWRDN		0x40
	field	SWINT		0x10
	field	IRQMS		0x08
	field	PAUSE		0x04
	field	INTEN		0x02
	field	CHIPRST		0x01
	field	CHIPRSTACK	0x01
}

/*
 * Host Address (p. 3-48)
 * This register contains the address of the byte about
 * to be transferred across the host bus.
 */
register HADDR {
	address			0x088
	size	4
	access_mode RW
}

register HCNT {
	address			0x08c
	size	3
	access_mode RW
}

/*
 * SCB Pointer (p. 3-49)
 * Gate one of the SCBs into the SCBARRAY window.
 */
register SCBPTR {
	address			0x090
	access_mode RW
}

/*
 * Interrupt Status (p. 3-50)
 * Status for system interrupts
 */
register INTSTAT {
	address			0x091
	access_mode RW
	field	BRKADRINT 0x08
	field	SCSIINT	  0x04
	field	CMDCMPLT  0x02
	field	SEQINT    0x01
	mask	BAD_PHASE	SEQINT		/* unknown scsi bus phase */
	mask	SEND_REJECT	0x10|SEQINT	/* sending a message reject */
	mask	PROTO_VIOLATION	0x20|SEQINT	/* SCSI protocol violation */ 
	mask	NO_MATCH	0x30|SEQINT	/* no cmd match for reconnect */
	mask	IGN_WIDE_RES	0x40|SEQINT	/* Complex IGN Wide Res Msg */
	mask	PDATA_REINIT	0x50|SEQINT	/*
						 * Returned to data phase
						 * that requires data
						 * transfer pointers to be
						 * recalculated from the
						 * transfer residual.
						 */
	mask	HOST_MSG_LOOP	0x60|SEQINT	/*
						 * The bus is ready for the
						 * host to perform another
						 * message transaction.  This
						 * mechanism is used for things
						 * like sync/wide negotiation
						 * that require a kernel based
						 * message state engine.
						 */
	mask	BAD_STATUS	0x70|SEQINT	/* Bad status from target */
	mask	PERR_DETECTED	0x80|SEQINT	/*
						 * Either the phase_lock
						 * or inb_next routine has
						 * noticed a parity error.
						 */
	mask	DATA_OVERRUN	0x90|SEQINT	/*
						 * Target attempted to write
						 * beyond the bounds of its
						 * command.
						 */
	mask	MKMSG_FAILED	0xa0|SEQINT	/*
						 * Target completed command
						 * without honoring our ATN
						 * request to issue a message. 
						 */
	mask	MISSED_BUSFREE	0xb0|SEQINT	/*
						 * The sequencer never saw
						 * the bus go free after
						 * either a command complete
						 * or disconnect message.
						 */
	mask	SCB_MISMATCH	0xc0|SEQINT	/*
						 * Downloaded SCB's tag does
						 * not match the entry we
						 * intended to download.
						 */
	mask	NO_FREE_SCB	0xd0|SEQINT	/*
						 * get_free_or_disc_scb failed.
						 */
	mask	OUT_OF_RANGE	0xe0|SEQINT

	mask	SEQINT_MASK	0xf0|SEQINT	/* SEQINT Status Codes */
	mask	INT_PEND  (BRKADRINT|SEQINT|SCSIINT|CMDCMPLT)
}

/*
 * Hard Error (p. 3-53)
 * Reporting of catastrophic errors.  You usually cannot recover from
 * these without a full board reset.
 */
register ERROR {
	address			0x092
	access_mode RO
	field	CIOPARERR	0x80	/* Ultra2 only */
	field	PCIERRSTAT	0x40	/* PCI only */
	field	MPARERR		0x20	/* PCI only */
	field	DPARERR		0x10	/* PCI only */
	field	SQPARERR	0x08
	field	ILLOPCODE	0x04
	field	ILLSADDR	0x02
	field	ILLHADDR	0x01
}

/*
 * Clear Interrupt Status (p. 3-52)
 */
register CLRINT {
	address			0x092
	access_mode WO
	field	CLRPARERR	0x10	/* PCI only */
	field	CLRBRKADRINT	0x08
	field	CLRSCSIINT      0x04
	field	CLRCMDINT 	0x02
	field	CLRSEQINT 	0x01
}

register DFCNTRL {
	address			0x093
	access_mode RW
	field	PRELOADEN	0x80	/* aic7890 only */
	field	WIDEODD		0x40
	field	SCSIEN		0x20
	field	SDMAEN		0x10
	field	SDMAENACK	0x10
	field	HDMAEN		0x08
	field	HDMAENACK	0x08
	field	DIRECTION	0x04
	field	FIFOFLUSH	0x02
	field	FIFORESET	0x01
}

register DFSTATUS {
	address			0x094
	access_mode RO
	field	PRELOAD_AVAIL	0x80
	field	DFCACHETH	0x40
	field	FIFOQWDEMP	0x20
	field	MREQPEND	0x10
	field	HDONE		0x08
	field	DFTHRESH	0x04
	field	FIFOFULL	0x02
	field	FIFOEMP		0x01
}

register DFWADDR {
	address			0x95
	access_mode RW
}

register DFRADDR {
	address			0x97
	access_mode RW
}

register DFDAT {
	address			0x099
	access_mode RW
}

/*
 * SCB Auto Increment (p. 3-59)
 * Byte offset into the SCB Array and an optional bit to allow auto
 * incrementing of the address during download and upload operations
 */
register SCBCNT {
	address			0x09a
	access_mode RW
	field	SCBAUTO		0x80
	mask	SCBCNT_MASK	0x1f
}

/*
 * Queue In FIFO (p. 3-60)
 * Input queue for queued SCBs (commands that the sequencer has yet to start)
 */
register QINFIFO {
	address			0x09b
	access_mode RW
}

/*
 * Queue In Count (p. 3-60)
 * Number of queued SCBs
 */
register QINCNT	{
	address			0x09c
	access_mode RO
}

/*
 * Queue Out FIFO (p. 3-61)
 * Queue of SCBs that have completed and await the host
 */
register QOUTFIFO {
	address			0x09d
	access_mode WO
}

register CRCCONTROL1 {
	address			0x09d
	access_mode RW
	field	CRCONSEEN		0x80
	field	CRCVALCHKEN		0x40
	field	CRCENDCHKEN		0x20
	field	CRCREQCHKEN		0x10
	field	TARGCRCENDEN		0x08
	field	TARGCRCCNTEN		0x04
}


/*
 * Queue Out Count (p. 3-61)
 * Number of queued SCBs in the Out FIFO
 */
register QOUTCNT {
	address			0x09e
	access_mode RO
}

register SCSIPHASE {
	address			0x09e
	access_mode RO
	field	STATUS_PHASE	0x20
	field	COMMAND_PHASE	0x10
	field	MSG_IN_PHASE	0x08
	field	MSG_OUT_PHASE	0x04
	field	DATA_IN_PHASE	0x02
	field	DATA_OUT_PHASE	0x01
	mask	DATA_PHASE_MASK	0x03
}

/*
 * Special Function
 */
register SFUNCT {
	address			0x09f
	access_mode RW
	field	ALT_MODE	0x80
}

/*
 * SCB Definition (p. 5-4)
 */
scb {
	address		0x0a0
	size		64

	SCB_CDB_PTR {
		size	4
		alias	SCB_RESIDUAL_DATACNT
		alias	SCB_CDB_STORE
	}
	SCB_RESIDUAL_SGPTR {
		size	4
	}
	SCB_SCSI_STATUS {
		size	1
	}
	SCB_TARGET_PHASES {
		size	1
	}
	SCB_TARGET_DATA_DIR {
		size	1
	}
	SCB_TARGET_ITAG {
		size	1
	}
	SCB_DATAPTR {
		size	4
	}
	SCB_DATACNT {
		/*
		 * The last byte is really the high address bits for
		 * the data address.
		 */
		size	4
		field	SG_LAST_SEG		0x80	/* In the fourth byte */
		mask	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
	}
	SCB_SGPTR {
		size	4
		field	SG_RESID_VALID	0x04	/* In the first byte */
		field	SG_FULL_RESID	0x02	/* In the first byte */
		field	SG_LIST_NULL	0x01	/* In the first byte */
	}
	SCB_CONTROL {
		size	1
		field	TARGET_SCB			0x80
		field	STATUS_RCVD			0x80
		field	DISCENB				0x40
		field	TAG_ENB				0x20
		field	MK_MESSAGE			0x10
		field	ULTRAENB			0x08
		field	DISCONNECTED			0x04
		mask	SCB_TAG_TYPE			0x03
	}
	SCB_SCSIID {
		size	1
		field	TWIN_CHNLB			0x80
		mask	TWIN_TID			0x70
		mask	TID				0xf0
		mask	OID				0x0f
	}
	SCB_LUN {
		field	SCB_XFERLEN_ODD			0x80
		mask	LID				0x3f
		size	1
	}
	SCB_TAG {
		size	1
	}
	SCB_CDB_LEN {
		size	1
	}
	SCB_SCSIRATE {
		size	1
	}
	SCB_SCSIOFFSET {
		size	1
	}
	SCB_NEXT {
		size	1
	}
	SCB_64_SPARE {
		size	16
	}
	SCB_64_BTT {
		size	16
	}
}

const	SCB_UPLOAD_SIZE		32
const	SCB_DOWNLOAD_SIZE	32
const	SCB_DOWNLOAD_SIZE_64	48

const	SG_SIZEOF	0x08		/* sizeof(struct ahc_dma) */

/* --------------------- AHA-2840-only definitions -------------------- */

register SEECTL_2840 {
	address			0x0c0
	access_mode RW
	field	CS_2840		0x04
	field	CK_2840		0x02
	field	DO_2840		0x01
}

register STATUS_2840 {
	address			0x0c1
	access_mode RW
	field	EEPROM_TF	0x80
	mask	BIOS_SEL	0x60
	mask	ADSEL		0x1e
	field	DI_2840		0x01
}

/* --------------------- AIC-7870-only definitions -------------------- */

register CCHADDR {
	address			0x0E0
	size 8
}

register CCHCNT {
	address			0x0E8
}

register CCSGRAM {
	address			0x0E9
}

register CCSGADDR {
	address			0x0EA
}

register CCSGCTL {
	address			0x0EB
	field	CCSGDONE	0x80
	field	CCSGEN		0x08
	field	SG_FETCH_NEEDED 0x02	/* Bit used for software state */
	field	CCSGRESET	0x01
}

register CCSCBCNT {
	address			0xEF
}

register CCSCBCTL {
	address			0x0EE
	field	CCSCBDONE	0x80
	field	ARRDONE		0x40	/* SCB Array prefetch done */
	field	CCARREN		0x10
	field	CCSCBEN		0x08
	field	CCSCBDIR	0x04
	field	CCSCBRESET	0x01
}

register CCSCBADDR {
	address			0x0ED
}

register CCSCBRAM {
	address			0xEC
}

/*
 * SCB bank address (7895/7896/97 only)
 */
register SCBBADDR {
	address			0x0F0
	access_mode RW
}

register CCSCBPTR {
	address			0x0F1
}

register HNSCB_QOFF {
	address			0x0F4
}

register SNSCB_QOFF {
	address			0x0F6
}

register SDSCB_QOFF {
	address			0x0F8
}

register QOFF_CTLSTA {
	address			0x0FA
	field	SCB_AVAIL	0x40
	field	SNSCB_ROLLOVER	0x20
	field	SDSCB_ROLLOVER	0x10
	mask	SCB_QSIZE	0x07
	mask	SCB_QSIZE_256	0x06
}

register DFF_THRSH {
	address			0x0FB
	mask	WR_DFTHRSH	0x70
	mask	RD_DFTHRSH	0x07
	mask	RD_DFTHRSH_MIN	0x00
	mask	RD_DFTHRSH_25	0x01
	mask	RD_DFTHRSH_50	0x02
	mask	RD_DFTHRSH_63	0x03
	mask	RD_DFTHRSH_75	0x04
	mask	RD_DFTHRSH_85	0x05
	mask	RD_DFTHRSH_90	0x06
	mask	RD_DFTHRSH_MAX	0x07
	mask	WR_DFTHRSH_MIN	0x00
	mask	WR_DFTHRSH_25	0x10
	mask	WR_DFTHRSH_50	0x20
	mask	WR_DFTHRSH_63	0x30
	mask	WR_DFTHRSH_75	0x40
	mask	WR_DFTHRSH_85	0x50
	mask	WR_DFTHRSH_90	0x60
	mask	WR_DFTHRSH_MAX	0x70
}

register SG_CACHE_PRE {
	access_mode WO
	address			0x0fc
	mask	SG_ADDR_MASK	0xf8
	field	LAST_SEG	0x02
	field	LAST_SEG_DONE	0x01
}

register SG_CACHE_SHADOW {
	access_mode RO
	address			0x0fc
	mask	SG_ADDR_MASK	0xf8
	field	LAST_SEG	0x02
	field	LAST_SEG_DONE	0x01
}
/* ---------------------- Scratch RAM Offsets ------------------------- */
/* These offsets are either to values that are initialized by the board's
 * BIOS or are specified by the sequencer code.
 *
 * The host adapter card (at least the BIOS) uses 20-2f for SCSI
 * device information, 32-33 and 5a-5f as well. As it turns out, the
 * BIOS trashes 20-2f, writing the synchronous negotiation results
 * on top of the BIOS values, so we re-use those for our per-target
 * scratchspace (actually a value that can be copied directly into
 * SCSIRATE).  The kernel driver will enable synchronous negotiation
 * for all targets that have a value other than 0 in the lower four
 * bits of the target scratch space.  This should work regardless of
 * whether the bios has been installed.
 */

scratch_ram {
	address		0x020
	size		58

	/*
	 * 1 byte per target starting at this address for configuration values
	 */
	BUSY_TARGETS {
		alias		TARG_SCSIRATE
		size		16
	}
	/*
	 * Bit vector of targets that have ULTRA enabled as set by
	 * the BIOS.  The Sequencer relies on a per-SCB field to
	 * control whether to enable Ultra transfers or not.  During
	 * initialization, we read this field and reuse it for 2
	 * entries in the busy target table.
	 */
	ULTRA_ENB {
		alias		CMDSIZE_TABLE
		size		2
	}
	/*
	 * Bit vector of targets that have disconnection disabled as set by
	 * the BIOS.  The Sequencer relies in a per-SCB field to control the
	 * disconnect priveldge.  During initialization, we read this field
	 * and reuse it for 2 entries in the busy target table.
	 */
	DISC_DSB {
		size		2
	}
	CMDSIZE_TABLE_TAIL {
		size		4
	}
	/*
	 * Partial transfer past cacheline end to be
	 * transferred using an extra S/G.
	 */
	MWI_RESIDUAL {
		size		1
	}
	/*
	 * SCBID of the next SCB to be started by the controller.
	 */
	NEXT_QUEUED_SCB {
		size		1
	}
	/*
	 * Single byte buffer used to designate the type or message
	 * to send to a target.
	 */
	MSG_OUT {
		size		1
	}
	/* Parameters for DMA Logic */
	DMAPARAMS {
		size		1
		field	PRELOADEN	0x80
		field	WIDEODD		0x40
		field	SCSIEN		0x20
		field	SDMAEN		0x10
		field	SDMAENACK	0x10
		field	HDMAEN		0x08
		field	HDMAENACK	0x08
		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
		field	FIFOFLUSH	0x02
		field	FIFORESET	0x01
	}
	SEQ_FLAGS {
		size		1
		field	NOT_IDENTIFIED		0x80
		field	NO_CDB_SENT		0x40
		field	TARGET_CMD_IS_TAGGED	0x40
		field	DPHASE			0x20
		/* Target flags */
		field	TARG_CMD_PENDING	0x10
		field	CMDPHASE_PENDING	0x08
		field	DPHASE_PENDING		0x04
		field	SPHASE_PENDING		0x02
		field	NO_DISCONNECT		0x01
	}
	/*
	 * Temporary storage for the
	 * target/channel/lun of a
	 * reconnecting target
	 */
	SAVED_SCSIID {
		size		1
	}
	SAVED_LUN {
		size		1
	}
	/*
	 * The last bus phase as seen by the sequencer. 
	 */
	LASTPHASE {
		size		1
		field	CDI		0x80
		field	IOI		0x40
		field	MSGI		0x20
		mask	PHASE_MASK	CDI|IOI|MSGI
		mask	P_DATAOUT	0x00
		mask	P_DATAIN	IOI
		mask	P_COMMAND	CDI
		mask	P_MESGOUT	CDI|MSGI
		mask	P_STATUS	CDI|IOI
		mask	P_MESGIN	CDI|IOI|MSGI
		mask	P_BUSFREE	0x01
	}
	/*
	 * head of list of SCBs awaiting
	 * selection
	 */
	WAITING_SCBH {
		size		1
	}
	/*
	 * head of list of SCBs that are
	 * disconnected.  Used for SCB
	 * paging.
	 */
	DISCONNECTED_SCBH {
		size		1
	}
	/*
	 * head of list of SCBs that are
	 * not in use.  Used for SCB paging.
	 */
	FREE_SCBH {
		size		1
	}
	/*
	 * head of list of SCBs that have
	 * completed but have not been
	 * put into the qoutfifo.
	 */
	COMPLETE_SCBH {
		size		1
	}
	/*
	 * Address of the hardware scb array in the host.
	 */
	HSCB_ADDR {
		size		4
	}
	/*
	 * Base address of our shared data with the kernel driver in host
	 * memory.  This includes the qoutfifo and target mode
	 * incoming command queue.
	 */
	SHARED_DATA_ADDR {
		size		4
	}
	KERNEL_QINPOS {
		size		1
	}
	QINPOS {
		size		1
	}
	QOUTPOS {
		size		1
	}
	/*
	 * Kernel and sequencer offsets into the queue of
	 * incoming target mode command descriptors.  The
	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
	 */
	KERNEL_TQINPOS {
		size		1
	}
	TQINPOS {                
		size		1
	}
	ARG_1 {
		size		1
		mask	SEND_MSG		0x80
		mask	SEND_SENSE		0x40
		mask	SEND_REJ		0x20
		mask	MSGOUT_PHASEMIS		0x10
		mask	EXIT_MSG_LOOP		0x08
		mask	CONT_MSG_LOOP		0x04
		mask	CONT_TARG_SESSION	0x02
		alias	RETURN_1
	}
	ARG_2 {
		size		1
		alias	RETURN_2
	}

	/*
	 * Snapshot of MSG_OUT taken after each message is sent.
	 */
	LAST_MSG {
		size		1
		alias	TARG_IMMEDIATE_SCB
	}

	/*
	 * Sequences the kernel driver has okayed for us.  This allows
	 * the driver to do things like prevent initiator or target
	 * operations.
	 */
	SCSISEQ_TEMPLATE {
		size		1
		field	ENSELO		0x40
		field	ENSELI		0x20
		field	ENRSELI		0x10
		field	ENAUTOATNO	0x08
		field	ENAUTOATNI	0x04
		field	ENAUTOATNP	0x02
	}
}

scratch_ram {
	address		0x056
	size		4
	/*
	 * These scratch ram locations are initialized by the 274X BIOS.
	 * We reuse them after capturing the BIOS settings during
	 * initialization.
	 */

	/*
	 * The initiator specified tag for this target mode transaction.
	 */
	HA_274_BIOSGLOBAL {
		size	1
		field	HA_274_EXTENDED_TRANS	0x01
		alias	INITIATOR_TAG
	}

	SEQ_FLAGS2 {
		size	1
		field	SCB_DMA			0x01
		field	TARGET_MSG_PENDING	0x02
	}
}

scratch_ram {
	address		0x05a
	size		6
	/*
	 * These are reserved registers in the card's scratch ram on the 2742.
	 * The EISA configuraiton chip is mapped here.  On Rev E. of the
	 * aic7770, the sequencer can use this area for scratch, but the
	 * host cannot directly access these registers.  On later chips, this
	 * area can be read and written by both the host and the sequencer.
	 * Even on later chips, many of these locations are initialized by
	 * the BIOS.
	 */
	SCSICONF {
		size		1
		field	TERM_ENB	0x80
		field	RESET_SCSI	0x40
		field	ENSPCHK		0x20
		mask	HSCSIID		0x07	/* our SCSI ID */
		mask	HWSCSIID	0x0f	/* our SCSI ID if Wide Bus */
	}
	INTDEF {
		address		0x05c
		size		1
		field	EDGE_TRIG	0x80
		mask	VECTOR		0x0f
	}
	HOSTCONF {
		address		0x05d
		size		1
	}
	HA_274_BIOSCTRL	{
		address		0x05f
		size		1
		mask	BIOSMODE		0x30
		mask	BIOSDISABLED		0x30	
		field	CHANNEL_B_PRIMARY	0x08
	}
}

scratch_ram {
	address		0x070
	size		16

	/*
	 * Per target SCSI offset values for Ultra2 controllers.
	 */
	TARG_OFFSET {
		size		16
	}
}

const TID_SHIFT		4
const SCB_LIST_NULL	0xff
const TARGET_CMD_CMPLT	0xfe

const CCSGADDR_MAX	0x80
const CCSGRAM_MAXSEGS	16

/* WDTR Message values */
const BUS_8_BIT			0x00
const BUS_16_BIT		0x01
const BUS_32_BIT		0x02

/* Offset maximums */
const MAX_OFFSET_8BIT		0x0f
const MAX_OFFSET_16BIT		0x08
const MAX_OFFSET_ULTRA2		0x7f
const MAX_OFFSET		0x7f
const HOST_MSG			0xff

/* Target mode command processing constants */
const CMD_GROUP_CODE_SHIFT	0x05

const STATUS_BUSY		0x08
const STATUS_QUEUE_FULL	0x28
const TARGET_DATA_IN		1

/*
 * Downloaded (kernel inserted) constants
 */
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET download
const QINFIFO_OFFSET download
const CACHESIZE_MASK download
const INVERTED_CACHESIZE_MASK download
const SG_PREFETCH_CNT download
const SG_PREFETCH_ALIGN_MASK download
const SG_PREFETCH_ADDR_MASK download
@


1.10
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.reg,v 1.9 2004/02/08 00:38:09 krw Exp $ */
d43 1
a43 1
VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#40 $"
d333 1
a333 1
	field	SHVALID		0x40	/* Shaddow Layer non-zero */
d953 1
a953 1
 * Input queue for queued SCBs (commands that the seqencer has yet to start)
@


1.9
log
@Pull in a few recent changes from FreeBSD, plus a couple of local
tweaks.

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.reg,v 1.8 2003/12/24 23:27:55 krw Exp $ */
d41 1
a41 1
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.reg,v 1.43 2003/01/20 20:44:55 gibbs Exp $
d43 1
a43 1
VERSION = "$NetBSD: aic7xxx.reg,v 1.2 2003/04/19 19:26:10 fvdl Exp $"
d1084 2
a1085 1
		mask	LID				0xff
a1243 1
	field	ODD_SEG		0x04
a1251 1
	field	ODD_SEG		0x04
a1480 8

	/*
	 * Track whether the transfer byte count for
	 * the current data phase is odd.
	 */
	DATA_COUNT_ODD {
		size		1
	}
d1575 1
a1575 1
const MAX_OFFSET		0xff
@


1.8
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.reg,v 1.6 2002/06/30 18:25:58 smurph Exp $ */
a1310 1
		alias	TARG_IMMEDIATE_SCB
d1465 1
@


1.7
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@@


1.6
log
@New aicasm synced with FreeBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.reg,v 1.5 2002/06/28 00:34:54 smurph Exp $ */
d5 2
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d15 8
a22 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.39 2001/07/18 21:39:47 gibbs Exp $
d43 1
a43 2

VERSION = "$Id: aic7xxx.reg,v 1.5 2002/06/28 00:34:54 smurph Exp $"
d61 8
a68 8
	bit	TEMODE		0x80
	bit	ENSELO		0x40
	bit	ENSELI		0x20
	bit	ENRSELI		0x10
	bit	ENAUTOATNO	0x08
	bit	ENAUTOATNI	0x04
	bit	ENAUTOATNP	0x02
	bit	SCSIRSTO	0x01
d78 7
a84 7
	bit	DFON		0x80
	bit	DFPEXP		0x40
	bit	FAST20		0x20
	bit	CLRSTCNT	0x10
	bit	SPIOEN		0x08
	bit	SCAMEN		0x04
	bit	CLRCHN		0x02
d94 3
a96 3
	bit	BITBUCKET	0x80
	bit	SWRAPEN		0x40
	bit	ENSPCHK		0x20
d98 3
a100 3
	bit	ENSTIMER	0x04
	bit	ACTNEGEN	0x02
	bit	STPWEN		0x01	/* Powered Termination */
d110 8
a117 8
	bit	CDI		0x80
	bit	IOI		0x40
	bit	MSGI		0x20
	bit	ATNI		0x10
	bit	SELI		0x08
	bit	BSYI		0x04
	bit	REQI		0x02
	bit	ACKI		0x01
d124 2
a125 2
        mask    P_DATAOUT_DT    P_DATAOUT|MSGI
        mask    P_DATAIN_DT     P_DATAIN|MSGI
d141 8
a148 8
	bit	CDO		0x80
	bit	IOO		0x40
	bit	MSGO		0x20
	bit	ATNO		0x10
	bit	SELO		0x08
	bit	BSYO		0x04
	bit	REQO		0x02
	bit	ACKO		0x01
d171 3
a173 3
	bit	WIDEXFER	0x80		/* Wide transfer control */
	bit	ENABLE_CRC	0x40		/* CRC for D-Phases */
	bit	SINGLE_EDGE	0x10		/* Disable DT Transfers */
d188 2
a189 2
        mask    TWIN_TID        0x70
        bit     TWIN_CHNLB      0x80
d229 9
d242 8
a249 8
	bit	AUTORATEEN		0x80
	bit	AUTOACKEN		0x40
	bit	ATNMGMNTEN		0x20
	bit	BUSFREEREV		0x10
	bit	EXPPHASEDIS		0x08
	bit	SCSIDATL_IMGEN		0x04
	bit	AUTO_MSGOUT_DE		0x02
	bit	DIS_MSGIN_DUALEDGE	0x01
d267 6
a272 6
	bit	CLRSELDO	0x40
	bit	CLRSELDI	0x20
	bit	CLRSELINGO	0x10
	bit	CLRSWRAP	0x08
        bit     CLRIOERR        0x08    /* Ultra2 Only */
	bit	CLRSPIORDY	0x02
d283 9
a291 9
	bit	TARGET		0x80	/* Board acting as target */
	bit	SELDO		0x40	/* Selection Done */
	bit	SELDI		0x20	/* Board has been selected */
	bit	SELINGO		0x10	/* Selection In Progress */
	bit	SWRAP		0x08	/* 24bit counter wrap */
	bit	IOERR		0x08	/* LVD Tranceiver mode changed */
	bit	SDONE		0x04	/* STCNT = 0x000000 */
	bit	SPIORDY		0x02	/* SCSI PIO Ready */
	bit	DMADONE		0x01	/* DMA transfer completed */
d301 7
a307 7
	bit	CLRSELTIMEO	0x80
	bit	CLRATNO		0x40
	bit	CLRSCSIRSTI	0x20
	bit	CLRBUSFREE	0x08
	bit	CLRSCSIPERR	0x04
	bit	CLRPHASECHG	0x02
	bit	CLRREQINIT	0x01
d316 8
a323 8
	bit	SELTO		0x80
	bit	ATNTARG 	0x40
	bit	SCSIRSTI	0x20
	bit	PHASEMIS	0x10
	bit	BUSFREE		0x08
	bit	SCSIPERR	0x04
	bit	PHASECHG	0x02
	bit	REQINIT		0x01
d332 7
a338 7
	bit	OVERRUN		0x80
        bit     SHVALID         0x40    /* Shaddow Layer non-zero */
	bit	EXP_ACTIVE	0x10	/* SCSI Expander Active */
        bit     CRCVALERR       0x08    /* CRC doesn't match (U3 only) */
        bit     CRCENDERR       0x04    /* No terminal CRC packet (U3 only) */
        bit     CRCREQERR       0x02    /* Illegal CRC packet req (U3 only) */
        bit     DUAL_EDGE_ERR   0x01    /* Incorrect data phase (U3 only) */
d350 1
d371 8
a378 8
	bit	ENSELDO		0x40
	bit	ENSELDI		0x20
	bit	ENSELINGO	0x10
	bit	ENSWRAP		0x08
	bit	ENIOERR		0x08	/* LVD Tranceiver mode changes */
	bit	ENSDONE		0x04
	bit	ENSPIORDY	0x02
	bit	ENDMADONE	0x01
d389 8
a396 8
	bit	ENSELTIMO	0x80
	bit	ENATNTARG	0x40
	bit	ENSCSIRST	0x20
	bit	ENPHASEMIS	0x10
	bit	ENBUSFREE	0x08
	bit	ENSCSIPERR	0x04
	bit	ENPHASECHG	0x02
	bit	ENREQINIT	0x01
d405 1
a405 1
        access_mode RW
d410 1
a410 1
        access_mode RW
d433 6
a438 6
	bit	STAGE6		0x20
	bit	STAGE5		0x10
	bit	STAGE4		0x08
	bit	STAGE3		0x04
	bit	STAGE2		0x02
	bit	STAGE1		0x01
d451 1
a451 1
	bit	ONEBIT		0x08
d457 4
a460 4
	bit	ENSCAMSELO	0x80
	bit	CLRSCAMSELID	0x40
	bit	ALTSTIM		0x20
	bit	DFLTTID		0x10
d484 8
a491 8
	bit	SOFT1		0x80
	bit	SOFT0		0x40
	bit	SOFTCMDEN	0x20	
	bit	HAS_BRDCTL	0x10	/* External Board control */
	bit	SEEPROM		0x08	/* External serial eeprom logic */
	bit	EEPROM		0x04	/* Writable external BIOS ROM */
	bit	ROM		0x02	/* Logic for accessing external ROM */
	bit	SSPIOCPS	0x01	/* Termination and cable detection */
d496 8
a503 8
	bit	BRDDAT7		0x80
	bit	BRDDAT6		0x40
	bit	BRDDAT5		0x20
	bit	BRDSTB		0x10
	bit	BRDCS		0x08
	bit	BRDRW		0x04
	bit	BRDCTL1		0x02
	bit	BRDCTL0		0x01
d505 5
a509 5
	bit	BRDDAT4		0x10
	bit	BRDDAT3		0x08
	bit	BRDDAT2		0x04
	bit	BRDRW_ULTRA2	0x02
	bit	BRDSTB_ULTRA2	0x01
d538 8
a545 8
	bit	EXTARBACK	0x80
	bit	EXTARBREQ	0x40
	bit	SEEMS		0x20
	bit	SEERDY		0x10
	bit	SEECS		0x08
	bit	SEECK		0x04
	bit	SEEDO		0x02
	bit	SEEDI		0x01
d557 8
a564 8
	bit	DIAGLEDEN	0x80	/* Aic78X0 only */
	bit	DIAGLEDON	0x40	/* Aic78X0 only */
	bit	AUTOFLUSHDIS	0x20
	bit	SELBUSB		0x08
	bit	ENAB40		0x08	/* LVD transceiver active */
	bit	ENAB20		0x04	/* SE/HVD transceiver active */
	bit	SELWIDE		0x02
	bit	XCVR		0x01	/* External transceiver active */
d574 8
a581 8
	bit	PERRORDIS	0x80
	bit	PAUSEDIS	0x40
	bit	FAILDIS		0x20
	bit	FASTMODE	0x10
	bit	BRKADRINTEN	0x08
	bit	STEP		0x04
	bit	SEQRESET	0x02
	bit	LOADRAM		0x01
d653 2
a654 2
	bit	ZERO		0x02
	bit	CARRY		0x01
d677 2
d685 2
a686 2
	bit	ACE		0x08
	bit	ENABLE		0x01
d696 4
a699 4
	bit	CACHETHEN	0x80	/* Cache Threshold enable */
	bit	DPARCKEN	0x40	/* Data Parity Check Enable */
	bit	MPARCKEN	0x20	/* Memory Parity Check Enable */
	bit	EXTREQLCK	0x10	/* External Request Lock */
d701 4
a704 4
	bit	INTSCBRAMSEL	0x08	/* Internal SCB RAM Select */
	bit	RAMPS		0x04	/* External SCB RAM Present */
	bit	USCBSIZE32	0x02	/* Use 32byte SCB Page Size */
	bit	CIOPARCKEN	0x01	/* Internal bus parity error enable */
d708 5
a712 5
        address                 0x085
        access_mode RW
        mask    DSLATT          0xfc    /* PCI latency timer (non-ultra2) */
        bit     HADDLDSEL1      0x02    /* Host Address Load Select Bits */
        bit     HADDLDSEL0      0x01
d735 1
a735 1
        mask    DFTHRSH_75      0x80
a748 1
	mask	HOST_REQ_INT	0x10
d762 7
a768 7
	bit	POWRDN		0x40
	bit	SWINT		0x10
	bit	IRQMS		0x08
	bit	PAUSE		0x04
	bit	INTEN		0x02
	bit	CHIPRST		0x01
	bit	CHIPRSTACK	0x01
d804 4
a807 4
	bit	BRKADRINT 0x08
	bit	SCSIINT	  0x04
	bit	CMDCMPLT  0x02
	bit	SEQINT    0x01
d810 1
a810 1
	mask	NO_IDENT	0x20|SEQINT	/* no IDENTIFY after reconnect*/
d812 9
a820 9
        mask    IGN_WIDE_RES    0x40|SEQINT     /* Complex IGN Wide Res Msg */
        mask    PDATA_REINIT    0x50|SEQINT     /*
                                                 * Returned to data phase
                                                 * that requires data
                                                 * transfer pointers to be
                                                 * recalculated from the
                                                 * transfer residual.
                                                 */
        mask    HOST_MSG_LOOP   0x60|SEQINT     /*
d829 2
a830 2
        mask    BAD_STATUS      0x70|SEQINT     /* Bad status from target */
        mask    PERR_DETECTED   0x80|SEQINT     /*
d835 1
a835 1
        mask    DATA_OVERRUN    0x90|SEQINT     /*
a838 5
                                                 */
        mask    MKMSG_FAILED    0xa0|SEQINT     /*
                                                 * Target completed command
                                                 * without honoring our ATN
                                                 * request to issue a message. 
d840 20
a859 15
        mask    MISSED_BUSFREE  0xb0|SEQINT     /*
                                                 * The sequencer never saw
                                                 * the bus go free after
                                                 * either a command complete
                                                 * or disconnect message.
                                                 */
        mask    SCB_MISMATCH    0xc0|SEQINT     /*
                                                 * Downloaded SCB's tag does
                                                 * not match the entry we
                                                 * intended to download.
                                                 */
        mask    NO_FREE_SCB     0xd0|SEQINT     /*
                                                 * get_free_or_disc_scb failed.
                                                 */
        mask    OUT_OF_RANGE    0xe0|SEQINT
d873 8
a880 8
	bit	CIOPARERR	0x80	/* Ultra2 only */
	bit	PCIERRSTAT	0x40	/* PCI only */
	bit	MPARERR		0x20	/* PCI only */
	bit	DPARERR		0x10	/* PCI only */
	bit	SQPARERR	0x08
	bit	ILLOPCODE	0x04
	bit	ILLSADDR	0x02
	bit	ILLHADDR	0x01
d889 5
a893 5
	bit	CLRPARERR	0x10	/* PCI only */
	bit	CLRBRKADRINT	0x08
	bit	CLRSCSIINT      0x04
	bit	CLRCMDINT 	0x02
	bit	CLRSEQINT 	0x01
d899 10
a908 10
	bit	PRELOADEN	0x80	/* aic7890 only */
	bit	WIDEODD		0x40
	bit	SCSIEN		0x20
	bit	SDMAEN		0x10
	bit	SDMAENACK	0x10
	bit	HDMAEN		0x08
	bit	HDMAENACK	0x08
	bit	DIRECTION	0x04
	bit	FIFOFLUSH	0x02
	bit	FIFORESET	0x01
d914 8
a921 8
	bit	PRELOAD_AVAIL	0x80
        bit     DFCACHETH       0x40
        bit     FIFOQWDEMP      0x20
	bit	MREQPEND	0x10
	bit	HDONE		0x08
	bit	DFTHRESH	0x04
	bit	FIFOFULL	0x02
	bit	FIFOEMP		0x01
d947 1
a947 1
	bit	SCBAUTO		0x80
d981 6
a986 6
	bit	CRCONSEEN		0x80
	bit	CRCVALCHKEN		0x40
	bit	CRCENDCHKEN		0x20
	bit	CRCREQCHKEN		0x10
	bit	TARGCRCENDEN		0x08
	bit	TARGCRCCNTEN		0x04
d1002 7
a1008 7
	bit	STATUS_PHASE	0x20
	bit	COMMAND_PHASE	0x10
	bit	MSG_IN_PHASE	0x08
	bit	MSG_OUT_PHASE	0x04
	bit	DATA_IN_PHASE	0x02
	bit	DATA_OUT_PHASE	0x01
        mask    DATA_PHASE_MASK 0x03
d1017 1
a1017 1
	bit	ALT_MODE	0x80
d1026 5
a1030 5
        SCB_CDB_PTR {
                size    4
                alias   SCB_RESIDUAL_DATACNT
                alias   SCB_CDB_STORE
                alias   SCB_TARGET_INFO
d1032 1
a1032 1
        SCB_RESIDUAL_SGPTR {
d1035 1
a1035 1
        SCB_SCSI_STATUS {
d1038 8
a1045 2
        SCB_CDB_STORE_PAD {
		size	3
d1052 2
a1053 2
                 * The last byte is really the high address bits for
                 * the data address.
d1056 2
a1057 2
                bit     SG_LAST_SEG             0x80    /* In the fourth byte */
                mask    SG_HIGH_ADDR_BITS       0x7F    /* In the fourth byte */
d1059 1
a1059 1
        SCB_SGPTR {
d1061 24
a1084 23
                bit     SG_RESID_VALID  0x04    /* In the first byte */
                bit     SG_FULL_RESID   0x02    /* In the first byte */
                bit     SG_LIST_NULL    0x01    /* In the first byte */
        }
        SCB_CONTROL {
                size    1
                bit     TARGET_SCB                      0x80
                bit     DISCENB                         0x40
                bit     TAG_ENB                         0x20
                bit     MK_MESSAGE                      0x10
                bit     ULTRAENB                        0x08
                bit     DISCONNECTED                    0x04
                mask    SCB_TAG_TYPE                    0x03
	}
        SCB_SCSIID {
                size    1
                bit     TWIN_CHNLB                      0x80
                mask    TWIN_TID                        0x70
                mask    TID                             0xf0
                mask    OID                             0x0f
        }
        SCB_LUN {
                mask    LID                             0xff
d1090 1
a1090 1
        SCB_CDB_LEN {
d1099 2
a1100 2
        SCB_NEXT {
                size    1
d1102 1
a1102 1
        SCB_64_SPARE {
d1105 2
a1106 2
        SCB_64_BTT {
                size    16
d1110 3
a1112 3
const   SCB_UPLOAD_SIZE         32
const   SCB_DOWNLOAD_SIZE       32
const   SCB_DOWNLOAD_SIZE_64    48
d1121 3
a1123 3
	bit	CS_2840		0x04
	bit	CK_2840		0x02
	bit	DO_2840		0x01
d1129 1
a1129 1
	bit	EEPROM_TF	0x80
d1132 1
a1132 1
	bit	DI_2840		0x01
d1156 4
a1159 4
	bit	CCSGDONE	0x80
	bit	CCSGEN		0x08
        bit     SG_FETCH_NEEDED 0x02    /* Bit used for software state */
	bit	CCSGRESET	0x01
d1168 6
a1173 6
	bit	CCSCBDONE	0x80
	bit	ARRDONE		0x40	/* SCB Array prefetch done */
	bit	CCARREN		0x10
	bit	CCSCBEN		0x08
	bit	CCSCBDIR	0x04
	bit	CCSCBRESET	0x01
d1210 3
a1212 3
	bit	SCB_AVAIL	0x40
	bit	SNSCB_ROLLOVER	0x20
	bit	SDSCB_ROLLOVER	0x10
d1240 1
a1240 1
        access_mode WO
d1242 4
a1245 4
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
	bit	LAST_SEG	0x02
	bit	LAST_SEG_DONE	0x01
d1249 6
a1254 6
        access_mode RO
        address                 0x0fc
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
        bit     LAST_SEG        0x02
        bit     LAST_SEG_DONE   0x01
d1278 2
a1279 2
        BUSY_TARGETS {
                alias           TARG_SCSIRATE
d1283 5
a1287 5
         * Bit vector of targets that have ULTRA enabled as set by
         * the BIOS.  The Sequencer relies on a per-SCB field to
         * control whether to enable Ultra transfers or not.  During
         * initialization, we read this field and reuse it for 2
         * entries in the busy target table.
d1290 1
a1290 1
                alias           CMDSIZE_TABLE
d1294 4
a1297 4
         * Bit vector of targets that have disconnection disabled as set by
         * the BIOS.  The Sequencer relies in a per-SCB field to control the
         * disconnect priveldge.  During initialization, we read this field
         * and reuse it for 2 entries in the busy target table.
d1301 17
a1317 16
        }
        CMDSIZE_TABLE_TAIL {
                size            4
        }
        /*
         * Partial transfer past cacheline end to be
         * transferred using an extra S/G.
         */
        MWI_RESIDUAL {
                size            1
        }
        /*
         * SCBID of the next SCB to be started by the controller.
         */
        NEXT_QUEUED_SCB {
                size            1
d1329 10
a1338 10
		bit	PRELOADEN	0x80
		bit	WIDEODD		0x40
		bit	SCSIEN		0x20
		bit	SDMAEN		0x10
		bit	SDMAENACK	0x10
		bit	HDMAEN		0x08
		bit	HDMAENACK	0x08
		bit	DIRECTION	0x04	/* Set indicates PCI->SCSI */
		bit	FIFOFLUSH	0x02
		bit	FIFORESET	0x01
d1342 4
a1345 3
		bit	IDENTIFY_SEEN		0x80
                bit     TARGET_CMD_IS_TAGGED    0x40
		bit	DPHASE			0x20
d1347 5
a1351 5
		bit	TARG_CMD_PENDING	0x10
		bit	CMDPHASE_PENDING	0x08
		bit	DPHASE_PENDING		0x04
		bit	SPHASE_PENDING		0x02
		bit	NO_DISCONNECT		0x01
d1358 1
a1358 1
        SAVED_SCSIID {
d1361 1
a1361 1
        SAVED_LUN {
d1369 3
a1371 3
		bit	CDI		0x80
		bit	IOI		0x40
		bit	MSGI		0x20
d1404 3
a1406 3
         * head of list of SCBs that have
         * completed but have not been
         * put into the qoutfifo.
d1408 2
a1409 2
        COMPLETE_SCBH {
                size            1
d1412 1
a1412 1
         * Address of the hardware scb array in the host.
d1414 1
a1414 1
        HSCB_ADDR {
d1418 3
a1420 3
         * Base address of our shared data with the kernel driver in host
         * memory.  This includes the qoutfifo and target mode
         * incoming command queue.
d1422 1
a1422 1
        SHARED_DATA_ADDR {
d1475 6
a1480 6
		bit	ENSELO		0x40
		bit	ENSELI		0x20
		bit	ENRSELI		0x10
		bit	ENAUTOATNO	0x08
		bit	ENAUTOATNI	0x04
		bit	ENAUTOATNP	0x02
d1490 10
d1504 4
a1507 2
	INITIATOR_TAG {
		size		1
d1510 5
a1514 4
        SEQ_FLAGS2 {
                size            1
                bit     SCB_DMA         0x01
        }
d1521 7
a1527 3
	 * These are reserved registers in the card's scratch ram.  Some of
	 * the values are specified in the AHA2742 technical reference manual
	 * and are initialized by the BIOS at boot time.
d1531 3
a1533 3
		bit	TERM_ENB	0x80
		bit	RESET_SCSI	0x40
		bit	ENSPCHK		0x20
d1536 6
a1541 6
        }
        INTDEF {
                address         0x05c
                size            1
                bit     EDGE_TRIG       0x80
                mask    VECTOR          0x0f
d1552 1
a1552 1
		bit	CHANNEL_B_PRIMARY	0x08
d1568 1
a1568 1
const TID_SHIFT         4
d1584 1
d1591 2
a1592 6
const STATUS_QUEUE_FULL		0x28
const SCB_TARGET_PHASES         0
const SCB_TARGET_DATA_DIR       1
const SCB_TARGET_STATUS         2
const SCB_INITIATOR_TAG         3
const TARGET_DATA_IN            1
@


1.5
log
@Return of new ahc
@
text
@d1 1
a1 1
/* $OpenBSD: aic7xxx.reg,v 1.3 2002/02/16 04:36:33 smurph Exp $ */
d35 1
a35 1
VERSION = "$Id: aic7xxx.reg,v 1.3 2002/02/16 04:36:33 smurph Exp $"
d1005 2
a1006 1
	address			0x0a0
d1246 2
a1247 1
	address			0x020
d1309 1
a1309 1
		bit	DIRECTION	0x04
d1474 5
a1484 1
		address		0x05a
d1509 6
a1518 1
		address		0x070
@


1.4
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 2
/*	$NetBSD$	*/

d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.20 2000/02/09 21:24:59 gibbs Exp $
d35 2
d116 2
d180 2
d254 1
d316 1
d318 4
d387 1
a387 1
	access_mode RO
d392 1
a392 1
	access_mode RO
d687 8
d696 1
a696 1
 * Bus On/Off Time (p. 3-44)
d715 1
d771 1
a771 1
 * Gate one of the four SCBs into the SCBARRAY window.
d793 9
a801 5
	mask	UPDATE_TMSG_REQ	0x60|SEQINT	/* Update TMSG_REQ values */
	mask	BAD_STATUS	0x70|SEQINT	/* Bad status from target */
	mask	RESIDUAL	0x80|SEQINT	/* Residual byte count != 0 */
	mask	TRACE_POINT	0x90|SEQINT
	mask	HOST_MSG_LOOP	0xa0|SEQINT	/*
d810 2
a811 1
	mask	PERR_DETECTED	0xb0|SEQINT	/*
d816 1
a816 7
	mask	TRACEPOINT	0xd0|SEQINT
	mask	MSGIN_PHASEMIS	0xe0|SEQINT	/*
						 * Target changed phase on us
						 * when we were expecting
						 * another msgin byte.
						 */
	mask	DATA_OVERRUN	0xf0|SEQINT	/*
d820 5
d826 15
d896 2
a897 1
	bit	DWORDEMP	0x20
d989 1
d1006 5
a1010 15
	SCB_CONTROL {
		size	1
		bit	TARGET_SCB	0x80
		bit	DISCENB         0x40
		bit	TAG_ENB		0x20
		bit	MK_MESSAGE      0x10
		bit	ULTRAENB	0x08
		bit	DISCONNECTED	0x04
		mask	SCB_TAG_TYPE	0x03
	}
	SCB_TCL {
		size	1
		bit	SELBUSB		0x08
		mask	TID		0xf0
		mask	LID		0x07
d1012 1
a1012 7
	SCB_TARGET_STATUS {
		size	1
	}
	SCB_SGCOUNT {
		size	1
	}
	SCB_SGPTR {
d1015 1
a1015 1
	SCB_RESID_SGCNT {
d1018 1
a1018 1
	SCB_RESID_DCNT	{
d1026 2
a1027 2
		 * Really only 3 bytes, but padded to make
		 * the kernel's job easier.
d1030 2
d1033 1
a1033 3
	SCB_CMDPTR {
		alias	SCB_TARGET_PHASES
		bit	TARGET_DATA_IN	0x1	/* In the second byte */
d1035 23
a1057 3
	}
	SCB_CMDLEN {
		alias	SCB_INITIATOR_TAG
d1063 1
a1063 1
	SCB_NEXT {
d1072 2
a1073 2
	SCB_SPARE	{
		size	3
d1075 1
a1075 1
	SCB_CMDSTORE	{
d1078 2
a1079 5
	SCB_CMDSTORE_BUSADDR {
		size	4
	}
	SCB_64BYTE_SPARE {
		size	12
d1083 3
a1085 2
const	SCB_32BYTE_SIZE	28
const	SCB_64BYTE_SIZE	48
d1131 1
a1131 1
	bit	FLAG		0x02
d1212 2
a1213 2
register SG_CACHEPTR {
	access_mode RW
d1215 2
a1216 1
	mask	SG_USER_DATA	0xfc
d1221 8
d1250 2
a1251 2
	TARG_SCSIRATE {
		alias		CMDSIZE_TABLE
d1255 5
a1259 1
	 * Bit vector of targets that have ULTRA enabled.
d1262 1
d1266 4
a1269 1
	 * Bit vector of targets that have disconnection disabled.
d1273 16
d1314 1
a1314 1
		bit	SCBPTR_VALID		0x40
d1328 1
a1328 1
	SAVED_TCL {
d1331 1
a1331 2
	/* Working value of the number of SG segments left */
	SG_COUNT {
a1333 4
	/* Working value of SG pointer */
	SG_NEXT	{
		size		4
	}
d1374 3
a1376 1
	 * Address of the hardware scb array in the host.
d1378 2
a1379 2
	HSCB_ADDR {
		size		4
d1382 1
a1382 2
	 * Address of the 256 byte array storing the SCBID of outstanding
	 * untagged SCBs indexed by TCL.
d1384 1
a1384 1
	SCBID_ADDR {
d1388 3
a1390 2
	 * Address of the array of command descriptors used to store
	 * information about incoming selections.
d1392 1
a1392 1
	TMODE_CMDADDR {
a1438 17
	 * Number of times we have filled the CCSGRAM with prefetched
	 * SG elements.
	 */
	PREFETCH_CNT {
		size		1
	}

	/*
	 * Interrupt kernel for a message to this target on
	 * the next transaction.  This is usually used for
	 * negotiation requests.
	 */
	TARGET_MSG_REQUEST {
		size		2
	}

	/*
d1468 4
d1485 6
d1512 1
a1518 5
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET		0
const QINFIFO_OFFSET		1
const UNTAGGEDSCB_OFFSET	2

a1532 4
const TCL_TARGET_SHIFT		4
/* The update interval must be a power of 2 */
const TQINFIFO_UPDATE_CNT	32

d1535 5
d1544 8
a1551 7

/*
 * Number of command descriptors in the command descriptor array.
 * No longer used, but left here as an example for how downloaded
 * constantants can be defined.
const TMODE_NUMCMDS	download
 */
@


1.3
log
@New port of FreeBSD's ahc driver
@
text
@d1 2
a2 1
/* $OpenBSD: src/sys/dev/microcode/aic7xxx/aic7xxx.reg,v $ */
d6 1
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d19 1
a19 1
 * GNU Public License ("GPL").
d33 1
a33 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.39 2001/07/18 21:39:47 gibbs Exp $
a35 2
VERSION = "$Id: src/sys/dev/microcode/aic7xxx/aic7xxx.reg#19 $"

a114 2
        mask    P_DATAOUT_DT    P_DATAOUT|MSGI
        mask    P_DATAIN_DT     P_DATAIN|MSGI
a176 2
        mask    TWIN_TID        0x70
        bit     TWIN_CHNLB      0x80
a248 1
        bit     CLRIOERR        0x08    /* Ultra2 Only */
a309 1
        bit     SHVALID         0x40    /* Shaddow Layer non-zero */
a310 4
        bit     CRCVALERR       0x08    /* CRC doesn't match (U3 only) */
        bit     CRCENDERR       0x04    /* No terminal CRC packet (U3 only) */
        bit     CRCREQERR       0x02    /* Illegal CRC packet req (U3 only) */
        bit     DUAL_EDGE_ERR   0x01    /* Incorrect data phase (U3 only) */
d376 1
a376 1
        access_mode RW
d381 1
a381 1
        access_mode RW
a675 8
register DSCOMMAND1 {
        address                 0x085
        access_mode RW
        mask    DSLATT          0xfc    /* PCI latency timer (non-ultra2) */
        bit     HADDLDSEL1      0x02    /* Host Address Load Select Bits */
        bit     HADDLDSEL0      0x01
}

d677 1
a677 1
 * Bus On/Off Time (p. 3-44) aic7770 only
a695 1
        mask    DFTHRSH_75      0x80
d751 1
a751 1
 * Gate one of the SCBs into the SCBARRAY window.
d773 5
a777 9
        mask    IGN_WIDE_RES    0x40|SEQINT     /* Complex IGN Wide Res Msg */
        mask    PDATA_REINIT    0x50|SEQINT     /*
                                                 * Returned to data phase
                                                 * that requires data
                                                 * transfer pointers to be
                                                 * recalculated from the
                                                 * transfer residual.
                                                 */
        mask    HOST_MSG_LOOP   0x60|SEQINT     /*
d786 1
a786 2
        mask    BAD_STATUS      0x70|SEQINT     /* Bad status from target */
        mask    PERR_DETECTED   0x80|SEQINT     /*
d791 7
a797 1
        mask    DATA_OVERRUN    0x90|SEQINT     /*
a800 5
                                                 */
        mask    MKMSG_FAILED    0xa0|SEQINT     /*
                                                 * Target completed command
                                                 * without honoring our ATN
                                                 * request to issue a message. 
a801 15
        mask    MISSED_BUSFREE  0xb0|SEQINT     /*
                                                 * The sequencer never saw
                                                 * the bus go free after
                                                 * either a command complete
                                                 * or disconnect message.
                                                 */
        mask    SCB_MISMATCH    0xc0|SEQINT     /*
                                                 * Downloaded SCB's tag does
                                                 * not match the entry we
                                                 * intended to download.
                                                 */
        mask    NO_FREE_SCB     0xd0|SEQINT     /*
                                                 * get_free_or_disc_scb failed.
                                                 */
        mask    OUT_OF_RANGE    0xe0|SEQINT
d857 1
a857 2
        bit     DFCACHETH       0x40
        bit     FIFOQWDEMP      0x20
a948 1
        mask    DATA_PHASE_MASK 0x03
d965 15
a979 5
        SCB_CDB_PTR {
                size    4
                alias   SCB_RESIDUAL_DATACNT
                alias   SCB_CDB_STORE
                alias   SCB_TARGET_INFO
d981 7
a987 1
        SCB_RESIDUAL_SGPTR {
d990 1
a990 1
        SCB_SCSI_STATUS {
d993 1
a993 1
        SCB_CDB_STORE_PAD {
d1001 2
a1002 2
                 * The last byte is really the high address bits for
                 * the data address.
a1004 2
                bit     SG_LAST_SEG             0x80    /* In the fourth byte */
                mask    SG_HIGH_ADDR_BITS       0x7F    /* In the fourth byte */
d1006 3
a1008 1
        SCB_SGPTR {
d1010 3
a1012 23
                bit     SG_RESID_VALID  0x04    /* In the first byte */
                bit     SG_FULL_RESID   0x02    /* In the first byte */
                bit     SG_LIST_NULL    0x01    /* In the first byte */
        }
        SCB_CONTROL {
                size    1
                bit     TARGET_SCB                      0x80
                bit     DISCENB                         0x40
                bit     TAG_ENB                         0x20
                bit     MK_MESSAGE                      0x10
                bit     ULTRAENB                        0x08
                bit     DISCONNECTED                    0x04
                mask    SCB_TAG_TYPE                    0x03
	}
        SCB_SCSIID {
                size    1
                bit     TWIN_CHNLB                      0x80
                mask    TWIN_TID                        0x70
                mask    TID                             0xf0
                mask    OID                             0x0f
        }
        SCB_LUN {
                mask    LID                             0xff
d1018 1
a1018 1
        SCB_CDB_LEN {
d1027 2
a1028 2
        SCB_NEXT {
                size    1
d1030 1
a1030 1
        SCB_64_SPARE {
d1033 5
a1037 2
        SCB_64_BTT {
                size    16
d1041 2
a1042 3
const   SCB_UPLOAD_SIZE         32
const   SCB_DOWNLOAD_SIZE       32
const   SCB_DOWNLOAD_SIZE_64    48
d1088 1
a1088 1
        bit     SG_FETCH_NEEDED 0x02    /* Bit used for software state */
d1169 2
a1170 2
register SG_CACHE_PRE {
        access_mode WO
d1172 1
a1172 2
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
a1176 8
register SG_CACHE_SHADOW {
        access_mode RO
        address                 0x0fc
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
        bit     LAST_SEG        0x02
        bit     LAST_SEG_DONE   0x01
}
d1198 2
a1199 2
        BUSY_TARGETS {
                alias           TARG_SCSIRATE
d1203 1
a1203 5
         * Bit vector of targets that have ULTRA enabled as set by
         * the BIOS.  The Sequencer relies on a per-SCB field to
         * control whether to enable Ultra transfers or not.  During
         * initialization, we read this field and reuse it for 2
         * entries in the busy target table.
a1205 1
                alias           CMDSIZE_TABLE
d1209 1
a1209 4
         * Bit vector of targets that have disconnection disabled as set by
         * the BIOS.  The Sequencer relies in a per-SCB field to control the
         * disconnect priveldge.  During initialization, we read this field
         * and reuse it for 2 entries in the busy target table.
a1212 16
        }
        CMDSIZE_TABLE_TAIL {
                size            4
        }
        /*
         * Partial transfer past cacheline end to be
         * transferred using an extra S/G.
         */
        MWI_RESIDUAL {
                size            1
        }
        /*
         * SCBID of the next SCB to be started by the controller.
         */
        NEXT_QUEUED_SCB {
                size            1
d1238 1
a1238 1
                bit     TARGET_CMD_IS_TAGGED    0x40
d1252 1
a1252 1
        SAVED_SCSIID {
d1255 2
a1256 1
        SAVED_LUN {
d1259 4
d1303 1
a1303 3
         * head of list of SCBs that have
         * completed but have not been
         * put into the qoutfifo.
d1305 2
a1306 2
        COMPLETE_SCBH {
                size            1
d1309 2
a1310 1
         * Address of the hardware scb array in the host.
d1312 1
a1312 1
        HSCB_ADDR {
d1316 2
a1317 3
         * Base address of our shared data with the kernel driver in host
         * memory.  This includes the qoutfifo and target mode
         * incoming command queue.
d1319 1
a1319 1
        SHARED_DATA_ADDR {
d1366 17
a1411 4
        SEQ_FLAGS2 {
                size            1
                bit     SCB_DMA         0x01
        }
a1424 6
        }
        INTDEF {
                address         0x05c
                size            1
                bit     EDGE_TRIG       0x80
                mask    VECTOR          0x0f
a1445 1
const TID_SHIFT         4
d1452 5
d1471 4
a1476 5
const SCB_TARGET_PHASES         0
const SCB_TARGET_DATA_DIR       1
const SCB_TARGET_STATUS         2
const SCB_INITIATOR_TAG         3
const TARGET_DATA_IN            1
d1481 7
a1487 8
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET download
const QINFIFO_OFFSET download
const CACHESIZE_MASK download
const INVERTED_CACHESIZE_MASK download
const SG_PREFETCH_CNT download
const SG_PREFETCH_ALIGN_MASK download
const SG_PREFETCH_ADDR_MASK download
@


1.2
log
@Import tagging code and try to resolve locking problem.
@
text
@d1 1
a1 2
/*	$NetBSD$	*/

d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.20 2000/02/09 21:24:59 gibbs Exp $
d35 2
d116 2
d180 2
d254 1
d316 1
d318 4
d387 1
a387 1
	access_mode RO
d392 1
a392 1
	access_mode RO
d687 8
d696 1
a696 1
 * Bus On/Off Time (p. 3-44)
d715 1
d771 1
a771 1
 * Gate one of the four SCBs into the SCBARRAY window.
d793 9
a801 5
	mask	UPDATE_TMSG_REQ	0x60|SEQINT	/* Update TMSG_REQ values */
	mask	BAD_STATUS	0x70|SEQINT	/* Bad status from target */
	mask	RESIDUAL	0x80|SEQINT	/* Residual byte count != 0 */
	mask	TRACE_POINT	0x90|SEQINT
	mask	HOST_MSG_LOOP	0xa0|SEQINT	/*
d810 2
a811 1
	mask	PERR_DETECTED	0xb0|SEQINT	/*
d816 1
a816 7
	mask	TRACEPOINT	0xd0|SEQINT
	mask	MSGIN_PHASEMIS	0xe0|SEQINT	/*
						 * Target changed phase on us
						 * when we were expecting
						 * another msgin byte.
						 */
	mask	DATA_OVERRUN	0xf0|SEQINT	/*
d820 5
d826 15
d896 2
a897 1
	bit	DWORDEMP	0x20
d989 1
d1006 5
a1010 15
	SCB_CONTROL {
		size	1
		bit	TARGET_SCB	0x80
		bit	DISCENB         0x40
		bit	TAG_ENB		0x20
		bit	MK_MESSAGE      0x10
		bit	ULTRAENB	0x08
		bit	DISCONNECTED	0x04
		mask	SCB_TAG_TYPE	0x03
	}
	SCB_TCL {
		size	1
		bit	SELBUSB		0x08
		mask	TID		0xf0
		mask	LID		0x07
d1012 1
a1012 7
	SCB_TARGET_STATUS {
		size	1
	}
	SCB_SGCOUNT {
		size	1
	}
	SCB_SGPTR {
d1015 1
a1015 1
	SCB_RESID_SGCNT {
d1018 1
a1018 1
	SCB_RESID_DCNT	{
d1026 2
a1027 2
		 * Really only 3 bytes, but padded to make
		 * the kernel's job easier.
d1030 2
d1033 1
a1033 3
	SCB_CMDPTR {
		alias	SCB_TARGET_PHASES
		bit	TARGET_DATA_IN	0x1	/* In the second byte */
d1035 23
a1057 3
	}
	SCB_CMDLEN {
		alias	SCB_INITIATOR_TAG
d1063 1
a1063 1
	SCB_NEXT {
d1072 2
a1073 2
	SCB_SPARE	{
		size	3
d1075 1
a1075 1
	SCB_CMDSTORE	{
d1078 2
a1079 5
	SCB_CMDSTORE_BUSADDR {
		size	4
	}
	SCB_64BYTE_SPARE {
		size	12
d1083 3
a1085 2
const	SCB_32BYTE_SIZE	28
const	SCB_64BYTE_SIZE	48
d1131 1
a1131 1
	bit	FLAG		0x02
d1212 2
a1213 2
register SG_CACHEPTR {
	access_mode RW
d1215 2
a1216 1
	mask	SG_USER_DATA	0xfc
d1221 8
d1250 2
a1251 2
	TARG_SCSIRATE {
		alias		CMDSIZE_TABLE
d1255 5
a1259 1
	 * Bit vector of targets that have ULTRA enabled.
d1262 1
d1266 4
a1269 1
	 * Bit vector of targets that have disconnection disabled.
d1273 16
d1314 1
a1314 1
		bit	SCBPTR_VALID		0x40
d1328 1
a1328 1
	SAVED_TCL {
d1331 1
a1331 2
	/* Working value of the number of SG segments left */
	SG_COUNT {
a1333 4
	/* Working value of SG pointer */
	SG_NEXT	{
		size		4
	}
d1374 3
a1376 1
	 * Address of the hardware scb array in the host.
d1378 2
a1379 2
	HSCB_ADDR {
		size		4
d1382 1
a1382 2
	 * Address of the 256 byte array storing the SCBID of outstanding
	 * untagged SCBs indexed by TCL.
d1384 1
a1384 1
	SCBID_ADDR {
d1388 3
a1390 2
	 * Address of the array of command descriptors used to store
	 * information about incoming selections.
d1392 1
a1392 1
	TMODE_CMDADDR {
a1438 17
	 * Number of times we have filled the CCSGRAM with prefetched
	 * SG elements.
	 */
	PREFETCH_CNT {
		size		1
	}

	/*
	 * Interrupt kernel for a message to this target on
	 * the next transaction.  This is usually used for
	 * negotiation requests.
	 */
	TARGET_MSG_REQUEST {
		size		2
	}

	/*
d1468 4
d1485 6
d1512 1
a1518 5
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET		0
const QINFIFO_OFFSET		1
const UNTAGGEDSCB_OFFSET	2

a1532 4
const TCL_TARGET_SHIFT		4
/* The update interval must be a power of 2 */
const TQINFIFO_UPDATE_CNT	32

d1535 5
d1544 8
a1551 7

/*
 * Number of command descriptors in the command descriptor array.
 * No longer used, but left here as an example for how downloaded
 * constantants can be defined.
const TMODE_NUMCMDS	download
 */
@


1.2.10.1
log
@sync to -current
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d19 1
a19 1
 * GNU Public License ("GPL").
d33 1
a33 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.39 2001/07/18 21:39:47 gibbs Exp $
a35 2
VERSION = "$Id$"

a114 2
        mask    P_DATAOUT_DT    P_DATAOUT|MSGI
        mask    P_DATAIN_DT     P_DATAIN|MSGI
a176 2
        mask    TWIN_TID        0x70
        bit     TWIN_CHNLB      0x80
a248 1
        bit     CLRIOERR        0x08    /* Ultra2 Only */
a309 1
        bit     SHVALID         0x40    /* Shaddow Layer non-zero */
a310 4
        bit     CRCVALERR       0x08    /* CRC doesn't match (U3 only) */
        bit     CRCENDERR       0x04    /* No terminal CRC packet (U3 only) */
        bit     CRCREQERR       0x02    /* Illegal CRC packet req (U3 only) */
        bit     DUAL_EDGE_ERR   0x01    /* Incorrect data phase (U3 only) */
d376 1
a376 1
        access_mode RW
d381 1
a381 1
        access_mode RW
a675 8
register DSCOMMAND1 {
        address                 0x085
        access_mode RW
        mask    DSLATT          0xfc    /* PCI latency timer (non-ultra2) */
        bit     HADDLDSEL1      0x02    /* Host Address Load Select Bits */
        bit     HADDLDSEL0      0x01
}

d677 1
a677 1
 * Bus On/Off Time (p. 3-44) aic7770 only
a695 1
        mask    DFTHRSH_75      0x80
d751 1
a751 1
 * Gate one of the SCBs into the SCBARRAY window.
d773 5
a777 9
        mask    IGN_WIDE_RES    0x40|SEQINT     /* Complex IGN Wide Res Msg */
        mask    PDATA_REINIT    0x50|SEQINT     /*
                                                 * Returned to data phase
                                                 * that requires data
                                                 * transfer pointers to be
                                                 * recalculated from the
                                                 * transfer residual.
                                                 */
        mask    HOST_MSG_LOOP   0x60|SEQINT     /*
d786 1
a786 2
        mask    BAD_STATUS      0x70|SEQINT     /* Bad status from target */
        mask    PERR_DETECTED   0x80|SEQINT     /*
d791 7
a797 1
        mask    DATA_OVERRUN    0x90|SEQINT     /*
a800 5
                                                 */
        mask    MKMSG_FAILED    0xa0|SEQINT     /*
                                                 * Target completed command
                                                 * without honoring our ATN
                                                 * request to issue a message. 
a801 15
        mask    MISSED_BUSFREE  0xb0|SEQINT     /*
                                                 * The sequencer never saw
                                                 * the bus go free after
                                                 * either a command complete
                                                 * or disconnect message.
                                                 */
        mask    SCB_MISMATCH    0xc0|SEQINT     /*
                                                 * Downloaded SCB's tag does
                                                 * not match the entry we
                                                 * intended to download.
                                                 */
        mask    NO_FREE_SCB     0xd0|SEQINT     /*
                                                 * get_free_or_disc_scb failed.
                                                 */
        mask    OUT_OF_RANGE    0xe0|SEQINT
d857 1
a857 2
        bit     DFCACHETH       0x40
        bit     FIFOQWDEMP      0x20
a948 1
        mask    DATA_PHASE_MASK 0x03
d964 19
a982 7
	address		0x0a0
	size		64
        SCB_CDB_PTR {
                size    4
                alias   SCB_RESIDUAL_DATACNT
                alias   SCB_CDB_STORE
                alias   SCB_TARGET_INFO
d984 4
a987 1
        SCB_RESIDUAL_SGPTR {
d990 1
a990 1
        SCB_SCSI_STATUS {
d993 1
a993 1
        SCB_CDB_STORE_PAD {
d1001 2
a1002 2
                 * The last byte is really the high address bits for
                 * the data address.
a1004 2
                bit     SG_LAST_SEG             0x80    /* In the fourth byte */
                mask    SG_HIGH_ADDR_BITS       0x7F    /* In the fourth byte */
d1006 3
a1008 1
        SCB_SGPTR {
d1010 3
a1012 23
                bit     SG_RESID_VALID  0x04    /* In the first byte */
                bit     SG_FULL_RESID   0x02    /* In the first byte */
                bit     SG_LIST_NULL    0x01    /* In the first byte */
        }
        SCB_CONTROL {
                size    1
                bit     TARGET_SCB                      0x80
                bit     DISCENB                         0x40
                bit     TAG_ENB                         0x20
                bit     MK_MESSAGE                      0x10
                bit     ULTRAENB                        0x08
                bit     DISCONNECTED                    0x04
                mask    SCB_TAG_TYPE                    0x03
	}
        SCB_SCSIID {
                size    1
                bit     TWIN_CHNLB                      0x80
                mask    TWIN_TID                        0x70
                mask    TID                             0xf0
                mask    OID                             0x0f
        }
        SCB_LUN {
                mask    LID                             0xff
d1018 1
a1018 1
        SCB_CDB_LEN {
d1027 2
a1028 2
        SCB_NEXT {
                size    1
d1030 1
a1030 1
        SCB_64_SPARE {
d1033 5
a1037 2
        SCB_64_BTT {
                size    16
d1041 2
a1042 3
const   SCB_UPLOAD_SIZE         32
const   SCB_DOWNLOAD_SIZE       32
const   SCB_DOWNLOAD_SIZE_64    48
d1088 1
a1088 1
        bit     SG_FETCH_NEEDED 0x02    /* Bit used for software state */
d1169 2
a1170 2
register SG_CACHE_PRE {
        access_mode WO
d1172 1
a1172 2
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
a1176 8
register SG_CACHE_SHADOW {
        access_mode RO
        address                 0x0fc
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
        bit     LAST_SEG        0x02
        bit     LAST_SEG_DONE   0x01
}
d1193 1
a1193 2
	address		0x020
	size		58
d1198 2
a1199 2
        BUSY_TARGETS {
                alias           TARG_SCSIRATE
d1203 1
a1203 5
         * Bit vector of targets that have ULTRA enabled as set by
         * the BIOS.  The Sequencer relies on a per-SCB field to
         * control whether to enable Ultra transfers or not.  During
         * initialization, we read this field and reuse it for 2
         * entries in the busy target table.
a1205 1
                alias           CMDSIZE_TABLE
d1209 1
a1209 4
         * Bit vector of targets that have disconnection disabled as set by
         * the BIOS.  The Sequencer relies in a per-SCB field to control the
         * disconnect priveldge.  During initialization, we read this field
         * and reuse it for 2 entries in the busy target table.
a1212 16
        }
        CMDSIZE_TABLE_TAIL {
                size            4
        }
        /*
         * Partial transfer past cacheline end to be
         * transferred using an extra S/G.
         */
        MWI_RESIDUAL {
                size            1
        }
        /*
         * SCBID of the next SCB to be started by the controller.
         */
        NEXT_QUEUED_SCB {
                size            1
d1231 1
a1231 1
		bit	DIRECTION	0x04	/* Set indicates PCI->SCSI */
d1238 1
a1238 1
                bit     TARGET_CMD_IS_TAGGED    0x40
d1252 1
a1252 1
        SAVED_SCSIID {
d1255 2
a1256 1
        SAVED_LUN {
d1259 4
d1303 1
a1303 3
         * head of list of SCBs that have
         * completed but have not been
         * put into the qoutfifo.
d1305 2
a1306 2
        COMPLETE_SCBH {
                size            1
d1309 2
a1310 1
         * Address of the hardware scb array in the host.
d1312 1
a1312 1
        HSCB_ADDR {
d1316 2
a1317 3
         * Base address of our shared data with the kernel driver in host
         * memory.  This includes the qoutfifo and target mode
         * incoming command queue.
d1319 1
a1319 1
        SHARED_DATA_ADDR {
d1366 17
a1411 9
        SEQ_FLAGS2 {
                size            1
                bit     SCB_DMA         0x01
        }
}

scratch_ram {
	address		0x05a
	size		6
d1418 1
a1424 6
        }
        INTDEF {
                address         0x05c
                size            1
                bit     EDGE_TRIG       0x80
                mask    VECTOR          0x0f
a1436 6
}

scratch_ram {
	address		0x070
	size		16

d1441 1
a1445 1
const TID_SHIFT         4
d1452 5
d1471 4
a1476 5
const SCB_TARGET_PHASES         0
const SCB_TARGET_DATA_DIR       1
const SCB_TARGET_STATUS         2
const SCB_INITIATOR_TAG         3
const TARGET_DATA_IN            1
d1481 7
a1487 8
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET download
const QINFIFO_OFFSET download
const CACHESIZE_MASK download
const INVERTED_CACHESIZE_MASK download
const SG_PREFETCH_CNT download
const SG_PREFETCH_ALIGN_MASK download
const SG_PREFETCH_ADDR_MASK download
@


1.1
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d709 2
@


1.1.2.1
log
@Sync with -current
@
text
@@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a708 2
	mask	HOST_REQ_INT	0x10
	mask	HOST_TQINPOS	0x80	/* Boundary at either 0 or 128 */
@


1.1.2.3
log
@Merge in trunk
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d19 1
a19 1
 * GNU Public License ("GPL").
d33 1
a33 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.39 2001/07/18 21:39:47 gibbs Exp $
a35 2
VERSION = "$Id$"

a114 2
        mask    P_DATAOUT_DT    P_DATAOUT|MSGI
        mask    P_DATAIN_DT     P_DATAIN|MSGI
a176 2
        mask    TWIN_TID        0x70
        bit     TWIN_CHNLB      0x80
a248 1
        bit     CLRIOERR        0x08    /* Ultra2 Only */
a309 1
        bit     SHVALID         0x40    /* Shaddow Layer non-zero */
a310 4
        bit     CRCVALERR       0x08    /* CRC doesn't match (U3 only) */
        bit     CRCENDERR       0x04    /* No terminal CRC packet (U3 only) */
        bit     CRCREQERR       0x02    /* Illegal CRC packet req (U3 only) */
        bit     DUAL_EDGE_ERR   0x01    /* Incorrect data phase (U3 only) */
d376 1
a376 1
        access_mode RW
d381 1
a381 1
        access_mode RW
a675 8
register DSCOMMAND1 {
        address                 0x085
        access_mode RW
        mask    DSLATT          0xfc    /* PCI latency timer (non-ultra2) */
        bit     HADDLDSEL1      0x02    /* Host Address Load Select Bits */
        bit     HADDLDSEL0      0x01
}

d677 1
a677 1
 * Bus On/Off Time (p. 3-44) aic7770 only
a695 1
        mask    DFTHRSH_75      0x80
d751 1
a751 1
 * Gate one of the SCBs into the SCBARRAY window.
d773 5
a777 9
        mask    IGN_WIDE_RES    0x40|SEQINT     /* Complex IGN Wide Res Msg */
        mask    PDATA_REINIT    0x50|SEQINT     /*
                                                 * Returned to data phase
                                                 * that requires data
                                                 * transfer pointers to be
                                                 * recalculated from the
                                                 * transfer residual.
                                                 */
        mask    HOST_MSG_LOOP   0x60|SEQINT     /*
d786 1
a786 2
        mask    BAD_STATUS      0x70|SEQINT     /* Bad status from target */
        mask    PERR_DETECTED   0x80|SEQINT     /*
d791 7
a797 1
        mask    DATA_OVERRUN    0x90|SEQINT     /*
a800 5
                                                 */
        mask    MKMSG_FAILED    0xa0|SEQINT     /*
                                                 * Target completed command
                                                 * without honoring our ATN
                                                 * request to issue a message. 
a801 15
        mask    MISSED_BUSFREE  0xb0|SEQINT     /*
                                                 * The sequencer never saw
                                                 * the bus go free after
                                                 * either a command complete
                                                 * or disconnect message.
                                                 */
        mask    SCB_MISMATCH    0xc0|SEQINT     /*
                                                 * Downloaded SCB's tag does
                                                 * not match the entry we
                                                 * intended to download.
                                                 */
        mask    NO_FREE_SCB     0xd0|SEQINT     /*
                                                 * get_free_or_disc_scb failed.
                                                 */
        mask    OUT_OF_RANGE    0xe0|SEQINT
d857 1
a857 2
        bit     DFCACHETH       0x40
        bit     FIFOQWDEMP      0x20
a948 1
        mask    DATA_PHASE_MASK 0x03
d965 15
a979 5
        SCB_CDB_PTR {
                size    4
                alias   SCB_RESIDUAL_DATACNT
                alias   SCB_CDB_STORE
                alias   SCB_TARGET_INFO
d981 7
a987 1
        SCB_RESIDUAL_SGPTR {
d990 1
a990 1
        SCB_SCSI_STATUS {
d993 1
a993 1
        SCB_CDB_STORE_PAD {
d1001 2
a1002 2
                 * The last byte is really the high address bits for
                 * the data address.
a1004 2
                bit     SG_LAST_SEG             0x80    /* In the fourth byte */
                mask    SG_HIGH_ADDR_BITS       0x7F    /* In the fourth byte */
d1006 3
a1008 1
        SCB_SGPTR {
d1010 3
a1012 23
                bit     SG_RESID_VALID  0x04    /* In the first byte */
                bit     SG_FULL_RESID   0x02    /* In the first byte */
                bit     SG_LIST_NULL    0x01    /* In the first byte */
        }
        SCB_CONTROL {
                size    1
                bit     TARGET_SCB                      0x80
                bit     DISCENB                         0x40
                bit     TAG_ENB                         0x20
                bit     MK_MESSAGE                      0x10
                bit     ULTRAENB                        0x08
                bit     DISCONNECTED                    0x04
                mask    SCB_TAG_TYPE                    0x03
	}
        SCB_SCSIID {
                size    1
                bit     TWIN_CHNLB                      0x80
                mask    TWIN_TID                        0x70
                mask    TID                             0xf0
                mask    OID                             0x0f
        }
        SCB_LUN {
                mask    LID                             0xff
d1018 1
a1018 1
        SCB_CDB_LEN {
d1027 2
a1028 2
        SCB_NEXT {
                size    1
d1030 1
a1030 1
        SCB_64_SPARE {
d1033 5
a1037 2
        SCB_64_BTT {
                size    16
d1041 2
a1042 3
const   SCB_UPLOAD_SIZE         32
const   SCB_DOWNLOAD_SIZE       32
const   SCB_DOWNLOAD_SIZE_64    48
d1088 1
a1088 1
        bit     SG_FETCH_NEEDED 0x02    /* Bit used for software state */
d1169 2
a1170 2
register SG_CACHE_PRE {
        access_mode WO
d1172 1
a1172 2
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
a1176 8
register SG_CACHE_SHADOW {
        access_mode RO
        address                 0x0fc
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
        bit     LAST_SEG        0x02
        bit     LAST_SEG_DONE   0x01
}
d1198 2
a1199 2
        BUSY_TARGETS {
                alias           TARG_SCSIRATE
d1203 1
a1203 5
         * Bit vector of targets that have ULTRA enabled as set by
         * the BIOS.  The Sequencer relies on a per-SCB field to
         * control whether to enable Ultra transfers or not.  During
         * initialization, we read this field and reuse it for 2
         * entries in the busy target table.
a1205 1
                alias           CMDSIZE_TABLE
d1209 1
a1209 4
         * Bit vector of targets that have disconnection disabled as set by
         * the BIOS.  The Sequencer relies in a per-SCB field to control the
         * disconnect priveldge.  During initialization, we read this field
         * and reuse it for 2 entries in the busy target table.
a1212 16
        }
        CMDSIZE_TABLE_TAIL {
                size            4
        }
        /*
         * Partial transfer past cacheline end to be
         * transferred using an extra S/G.
         */
        MWI_RESIDUAL {
                size            1
        }
        /*
         * SCBID of the next SCB to be started by the controller.
         */
        NEXT_QUEUED_SCB {
                size            1
d1238 1
a1238 1
                bit     TARGET_CMD_IS_TAGGED    0x40
d1252 1
a1252 1
        SAVED_SCSIID {
d1255 2
a1256 1
        SAVED_LUN {
d1259 4
d1303 1
a1303 3
         * head of list of SCBs that have
         * completed but have not been
         * put into the qoutfifo.
d1305 2
a1306 2
        COMPLETE_SCBH {
                size            1
d1309 2
a1310 1
         * Address of the hardware scb array in the host.
d1312 1
a1312 1
        HSCB_ADDR {
d1316 2
a1317 3
         * Base address of our shared data with the kernel driver in host
         * memory.  This includes the qoutfifo and target mode
         * incoming command queue.
d1319 1
a1319 1
        SHARED_DATA_ADDR {
d1366 17
a1411 4
        SEQ_FLAGS2 {
                size            1
                bit     SCB_DMA         0x01
        }
a1424 6
        }
        INTDEF {
                address         0x05c
                size            1
                bit     EDGE_TRIG       0x80
                mask    VECTOR          0x0f
a1445 1
const TID_SHIFT         4
d1452 5
d1471 4
a1476 5
const SCB_TARGET_PHASES         0
const SCB_TARGET_DATA_DIR       1
const SCB_TARGET_STATUS         2
const SCB_INITIATOR_TAG         3
const TARGET_DATA_IN            1
d1481 7
a1487 8
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET download
const QINFIFO_OFFSET download
const CACHESIZE_MASK download
const INVERTED_CACHESIZE_MASK download
const SG_PREFETCH_CNT download
const SG_PREFETCH_ALIGN_MASK download
const SG_PREFETCH_ADDR_MASK download
@


1.1.2.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 2
/*	$NetBSD$	*/

d5 1
a5 1
 * Copyright (c) 1994-2000 Justin Gibbs.
d18 1
a18 1
 * the GNU Public License ("GPL").
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.20 2000/02/09 21:24:59 gibbs Exp $
d35 2
d116 2
d180 2
d254 1
d316 1
d318 4
d387 1
a387 1
	access_mode RO
d392 1
a392 1
	access_mode RO
d687 8
d696 1
a696 1
 * Bus On/Off Time (p. 3-44)
d715 1
d771 1
a771 1
 * Gate one of the four SCBs into the SCBARRAY window.
d793 9
a801 5
	mask	UPDATE_TMSG_REQ	0x60|SEQINT	/* Update TMSG_REQ values */
	mask	BAD_STATUS	0x70|SEQINT	/* Bad status from target */
	mask	RESIDUAL	0x80|SEQINT	/* Residual byte count != 0 */
	mask	TRACE_POINT	0x90|SEQINT
	mask	HOST_MSG_LOOP	0xa0|SEQINT	/*
d810 2
a811 1
	mask	PERR_DETECTED	0xb0|SEQINT	/*
d816 1
a816 7
	mask	TRACEPOINT	0xd0|SEQINT
	mask	MSGIN_PHASEMIS	0xe0|SEQINT	/*
						 * Target changed phase on us
						 * when we were expecting
						 * another msgin byte.
						 */
	mask	DATA_OVERRUN	0xf0|SEQINT	/*
d820 5
d826 15
d896 2
a897 1
	bit	DWORDEMP	0x20
d989 1
d1006 5
a1010 15
	SCB_CONTROL {
		size	1
		bit	TARGET_SCB	0x80
		bit	DISCENB         0x40
		bit	TAG_ENB		0x20
		bit	MK_MESSAGE      0x10
		bit	ULTRAENB	0x08
		bit	DISCONNECTED	0x04
		mask	SCB_TAG_TYPE	0x03
	}
	SCB_TCL {
		size	1
		bit	SELBUSB		0x08
		mask	TID		0xf0
		mask	LID		0x07
d1012 1
a1012 7
	SCB_TARGET_STATUS {
		size	1
	}
	SCB_SGCOUNT {
		size	1
	}
	SCB_SGPTR {
d1015 1
a1015 1
	SCB_RESID_SGCNT {
d1018 1
a1018 1
	SCB_RESID_DCNT	{
d1026 2
a1027 2
		 * Really only 3 bytes, but padded to make
		 * the kernel's job easier.
d1030 2
d1033 1
a1033 3
	SCB_CMDPTR {
		alias	SCB_TARGET_PHASES
		bit	TARGET_DATA_IN	0x1	/* In the second byte */
d1035 23
a1057 3
	}
	SCB_CMDLEN {
		alias	SCB_INITIATOR_TAG
d1063 1
a1063 1
	SCB_NEXT {
d1072 2
a1073 2
	SCB_SPARE	{
		size	3
d1075 1
a1075 1
	SCB_CMDSTORE	{
d1078 2
a1079 5
	SCB_CMDSTORE_BUSADDR {
		size	4
	}
	SCB_64BYTE_SPARE {
		size	12
d1083 3
a1085 2
const	SCB_32BYTE_SIZE	28
const	SCB_64BYTE_SIZE	48
d1131 1
a1131 1
	bit	FLAG		0x02
d1212 2
a1213 2
register SG_CACHEPTR {
	access_mode RW
d1215 2
a1216 1
	mask	SG_USER_DATA	0xfc
d1221 8
d1250 2
a1251 2
	TARG_SCSIRATE {
		alias		CMDSIZE_TABLE
d1255 5
a1259 1
	 * Bit vector of targets that have ULTRA enabled.
d1262 1
d1266 4
a1269 1
	 * Bit vector of targets that have disconnection disabled.
d1273 16
d1314 1
a1314 1
		bit	SCBPTR_VALID		0x40
d1328 1
a1328 1
	SAVED_TCL {
d1331 1
a1331 2
	/* Working value of the number of SG segments left */
	SG_COUNT {
a1333 4
	/* Working value of SG pointer */
	SG_NEXT	{
		size		4
	}
d1374 3
a1376 1
	 * Address of the hardware scb array in the host.
d1378 2
a1379 2
	HSCB_ADDR {
		size		4
d1382 1
a1382 2
	 * Address of the 256 byte array storing the SCBID of outstanding
	 * untagged SCBs indexed by TCL.
d1384 1
a1384 1
	SCBID_ADDR {
d1388 3
a1390 2
	 * Address of the array of command descriptors used to store
	 * information about incoming selections.
d1392 1
a1392 1
	TMODE_CMDADDR {
a1438 17
	 * Number of times we have filled the CCSGRAM with prefetched
	 * SG elements.
	 */
	PREFETCH_CNT {
		size		1
	}

	/*
	 * Interrupt kernel for a message to this target on
	 * the next transaction.  This is usually used for
	 * negotiation requests.
	 */
	TARGET_MSG_REQUEST {
		size		2
	}

	/*
d1468 4
d1485 6
d1512 1
a1518 5
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET		0
const QINFIFO_OFFSET		1
const UNTAGGEDSCB_OFFSET	2

a1532 4
const TCL_TARGET_SHIFT		4
/* The update interval must be a power of 2 */
const TQINFIFO_UPDATE_CNT	32

d1535 5
d1544 8
a1551 7

/*
 * Number of command descriptors in the command descriptor array.
 * No longer used, but left here as an example for how downloaded
 * constantants can be defined.
const TMODE_NUMCMDS	download
 */
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d6 1
a6 1
 * Copyright (c) 1994-2001 Justin Gibbs.
d19 1
a19 1
 * GNU Public License ("GPL").
d33 1
a33 1
 * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.39 2001/07/18 21:39:47 gibbs Exp $
a35 2
VERSION = "$Id$"

a114 2
        mask    P_DATAOUT_DT    P_DATAOUT|MSGI
        mask    P_DATAIN_DT     P_DATAIN|MSGI
a176 2
        mask    TWIN_TID        0x70
        bit     TWIN_CHNLB      0x80
a248 1
        bit     CLRIOERR        0x08    /* Ultra2 Only */
a309 1
        bit     SHVALID         0x40    /* Shaddow Layer non-zero */
a310 4
        bit     CRCVALERR       0x08    /* CRC doesn't match (U3 only) */
        bit     CRCENDERR       0x04    /* No terminal CRC packet (U3 only) */
        bit     CRCREQERR       0x02    /* Illegal CRC packet req (U3 only) */
        bit     DUAL_EDGE_ERR   0x01    /* Incorrect data phase (U3 only) */
d376 1
a376 1
        access_mode RW
d381 1
a381 1
        access_mode RW
a675 8
register DSCOMMAND1 {
        address                 0x085
        access_mode RW
        mask    DSLATT          0xfc    /* PCI latency timer (non-ultra2) */
        bit     HADDLDSEL1      0x02    /* Host Address Load Select Bits */
        bit     HADDLDSEL0      0x01
}

d677 1
a677 1
 * Bus On/Off Time (p. 3-44) aic7770 only
a695 1
        mask    DFTHRSH_75      0x80
d751 1
a751 1
 * Gate one of the SCBs into the SCBARRAY window.
d773 5
a777 9
        mask    IGN_WIDE_RES    0x40|SEQINT     /* Complex IGN Wide Res Msg */
        mask    PDATA_REINIT    0x50|SEQINT     /*
                                                 * Returned to data phase
                                                 * that requires data
                                                 * transfer pointers to be
                                                 * recalculated from the
                                                 * transfer residual.
                                                 */
        mask    HOST_MSG_LOOP   0x60|SEQINT     /*
d786 1
a786 2
        mask    BAD_STATUS      0x70|SEQINT     /* Bad status from target */
        mask    PERR_DETECTED   0x80|SEQINT     /*
d791 7
a797 1
        mask    DATA_OVERRUN    0x90|SEQINT     /*
a800 5
                                                 */
        mask    MKMSG_FAILED    0xa0|SEQINT     /*
                                                 * Target completed command
                                                 * without honoring our ATN
                                                 * request to issue a message. 
a801 15
        mask    MISSED_BUSFREE  0xb0|SEQINT     /*
                                                 * The sequencer never saw
                                                 * the bus go free after
                                                 * either a command complete
                                                 * or disconnect message.
                                                 */
        mask    SCB_MISMATCH    0xc0|SEQINT     /*
                                                 * Downloaded SCB's tag does
                                                 * not match the entry we
                                                 * intended to download.
                                                 */
        mask    NO_FREE_SCB     0xd0|SEQINT     /*
                                                 * get_free_or_disc_scb failed.
                                                 */
        mask    OUT_OF_RANGE    0xe0|SEQINT
d857 1
a857 2
        bit     DFCACHETH       0x40
        bit     FIFOQWDEMP      0x20
a948 1
        mask    DATA_PHASE_MASK 0x03
d964 19
a982 7
	address		0x0a0
	size		64
        SCB_CDB_PTR {
                size    4
                alias   SCB_RESIDUAL_DATACNT
                alias   SCB_CDB_STORE
                alias   SCB_TARGET_INFO
d984 4
a987 1
        SCB_RESIDUAL_SGPTR {
d990 1
a990 1
        SCB_SCSI_STATUS {
d993 1
a993 1
        SCB_CDB_STORE_PAD {
d1001 2
a1002 2
                 * The last byte is really the high address bits for
                 * the data address.
a1004 2
                bit     SG_LAST_SEG             0x80    /* In the fourth byte */
                mask    SG_HIGH_ADDR_BITS       0x7F    /* In the fourth byte */
d1006 3
a1008 1
        SCB_SGPTR {
d1010 3
a1012 23
                bit     SG_RESID_VALID  0x04    /* In the first byte */
                bit     SG_FULL_RESID   0x02    /* In the first byte */
                bit     SG_LIST_NULL    0x01    /* In the first byte */
        }
        SCB_CONTROL {
                size    1
                bit     TARGET_SCB                      0x80
                bit     DISCENB                         0x40
                bit     TAG_ENB                         0x20
                bit     MK_MESSAGE                      0x10
                bit     ULTRAENB                        0x08
                bit     DISCONNECTED                    0x04
                mask    SCB_TAG_TYPE                    0x03
	}
        SCB_SCSIID {
                size    1
                bit     TWIN_CHNLB                      0x80
                mask    TWIN_TID                        0x70
                mask    TID                             0xf0
                mask    OID                             0x0f
        }
        SCB_LUN {
                mask    LID                             0xff
d1018 1
a1018 1
        SCB_CDB_LEN {
d1027 2
a1028 2
        SCB_NEXT {
                size    1
d1030 1
a1030 1
        SCB_64_SPARE {
d1033 5
a1037 2
        SCB_64_BTT {
                size    16
d1041 2
a1042 3
const   SCB_UPLOAD_SIZE         32
const   SCB_DOWNLOAD_SIZE       32
const   SCB_DOWNLOAD_SIZE_64    48
d1088 1
a1088 1
        bit     SG_FETCH_NEEDED 0x02    /* Bit used for software state */
d1169 2
a1170 2
register SG_CACHE_PRE {
        access_mode WO
d1172 1
a1172 2
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
a1176 8
register SG_CACHE_SHADOW {
        access_mode RO
        address                 0x0fc
        mask    SG_ADDR_MASK    0xf8
        bit     ODD_SEG         0x04
        bit     LAST_SEG        0x02
        bit     LAST_SEG_DONE   0x01
}
d1193 1
a1193 2
	address		0x020
	size		58
d1198 2
a1199 2
        BUSY_TARGETS {
                alias           TARG_SCSIRATE
d1203 1
a1203 5
         * Bit vector of targets that have ULTRA enabled as set by
         * the BIOS.  The Sequencer relies on a per-SCB field to
         * control whether to enable Ultra transfers or not.  During
         * initialization, we read this field and reuse it for 2
         * entries in the busy target table.
a1205 1
                alias           CMDSIZE_TABLE
d1209 1
a1209 4
         * Bit vector of targets that have disconnection disabled as set by
         * the BIOS.  The Sequencer relies in a per-SCB field to control the
         * disconnect priveldge.  During initialization, we read this field
         * and reuse it for 2 entries in the busy target table.
a1212 16
        }
        CMDSIZE_TABLE_TAIL {
                size            4
        }
        /*
         * Partial transfer past cacheline end to be
         * transferred using an extra S/G.
         */
        MWI_RESIDUAL {
                size            1
        }
        /*
         * SCBID of the next SCB to be started by the controller.
         */
        NEXT_QUEUED_SCB {
                size            1
d1231 1
a1231 1
		bit	DIRECTION	0x04	/* Set indicates PCI->SCSI */
d1238 1
a1238 1
                bit     TARGET_CMD_IS_TAGGED    0x40
d1252 1
a1252 1
        SAVED_SCSIID {
d1255 2
a1256 1
        SAVED_LUN {
d1259 4
d1303 1
a1303 3
         * head of list of SCBs that have
         * completed but have not been
         * put into the qoutfifo.
d1305 2
a1306 2
        COMPLETE_SCBH {
                size            1
d1309 2
a1310 1
         * Address of the hardware scb array in the host.
d1312 1
a1312 1
        HSCB_ADDR {
d1316 2
a1317 3
         * Base address of our shared data with the kernel driver in host
         * memory.  This includes the qoutfifo and target mode
         * incoming command queue.
d1319 1
a1319 1
        SHARED_DATA_ADDR {
d1366 17
a1411 9
        SEQ_FLAGS2 {
                size            1
                bit     SCB_DMA         0x01
        }
}

scratch_ram {
	address		0x05a
	size		6
d1418 1
a1424 6
        }
        INTDEF {
                address         0x05c
                size            1
                bit     EDGE_TRIG       0x80
                mask    VECTOR          0x0f
a1436 6
}

scratch_ram {
	address		0x070
	size		16

d1441 1
a1445 1
const TID_SHIFT         4
d1452 5
d1471 4
a1476 5
const SCB_TARGET_PHASES         0
const SCB_TARGET_DATA_DIR       1
const SCB_TARGET_STATUS         2
const SCB_INITIATOR_TAG         3
const TARGET_DATA_IN            1
d1481 7
a1487 8
/* Offsets into the SCBID array where different data is stored */
const QOUTFIFO_OFFSET download
const QINFIFO_OFFSET download
const CACHESIZE_MASK download
const INVERTED_CACHESIZE_MASK download
const SG_PREFETCH_CNT download
const SG_PREFETCH_ALIGN_MASK download
const SG_PREFETCH_ADDR_MASK download
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d5 1
a5 2
 * Copyright (c) 1994-2001 Justin T. Gibbs.
 * Copyright (c) 2000-2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d18 1
a18 2
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
d20 5
a24 6
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d27 4
a30 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d32 1
a32 1
 * $FreeBSD: /repoman/r/ncvs/src/sys/dev/aic7xxx/aic7xxx.reg,v 1.43 2003/01/20 20:44:55 gibbs Exp $
d34 2
a35 1
VERSION = "$NetBSD: aic7xxx.reg,v 1.2 2003/04/19 19:26:10 fvdl Exp $"
d53 8
a60 8
	field	TEMODE		0x80
	field	ENSELO		0x40
	field	ENSELI		0x20
	field	ENRSELI		0x10
	field	ENAUTOATNO	0x08
	field	ENAUTOATNI	0x04
	field	ENAUTOATNP	0x02
	field	SCSIRSTO	0x01
d70 7
a76 7
	field	DFON		0x80
	field	DFPEXP		0x40
	field	FAST20		0x20
	field	CLRSTCNT	0x10
	field	SPIOEN		0x08
	field	SCAMEN		0x04
	field	CLRCHN		0x02
d86 3
a88 3
	field	BITBUCKET	0x80
	field	SWRAPEN		0x40
	field	ENSPCHK		0x20
d90 3
a92 3
	field	ENSTIMER	0x04
	field	ACTNEGEN	0x02
	field	STPWEN		0x01	/* Powered Termination */
d102 8
a109 8
	field	CDI		0x80
	field	IOI		0x40
	field	MSGI		0x20
	field	ATNI		0x10
	field	SELI		0x08
	field	BSYI		0x04
	field	REQI		0x02
	field	ACKI		0x01
d116 2
a117 2
	mask	P_DATAOUT_DT	P_DATAOUT|MSGI
	mask	P_DATAIN_DT	P_DATAIN|MSGI
d133 8
a140 8
	field	CDO		0x80
	field	IOO		0x40
	field	MSGO		0x20
	field	ATNO		0x10
	field	SELO		0x08
	field	BSYO		0x04
	field	REQO		0x02
	field	ACKO		0x01
d163 3
a165 3
	field	WIDEXFER	0x80		/* Wide transfer control */
	field	ENABLE_CRC	0x40		/* CRC for D-Phases */
	field	SINGLE_EDGE	0x10		/* Disable DT Transfers */
d180 2
a181 2
	mask	TWIN_TID	0x70
	field	TWIN_CHNLB	0x80
a220 9
/* ALT_MODE registers (Ultra2 and Ultra160 chips) */
register SXFRCTL2 {
	address			0x013
	access_mode RW
	field	AUTORSTDIS	0x10
	field	CMDDMAEN	0x08
	mask	ASYNC_SETUP	0x07
}

d225 8
a232 8
	field	AUTORATEEN		0x80
	field	AUTOACKEN		0x40
	field	ATNMGMNTEN		0x20
	field	BUSFREEREV		0x10
	field	EXPPHASEDIS		0x08
	field	SCSIDATL_IMGEN		0x04
	field	AUTO_MSGOUT_DE		0x02
	field	DIS_MSGIN_DUALEDGE	0x01
d250 6
a255 6
	field	CLRSELDO	0x40
	field	CLRSELDI	0x20
	field	CLRSELINGO	0x10
	field	CLRSWRAP	0x08
	field	CLRIOERR	0x08	/* Ultra2 Only */
	field	CLRSPIORDY	0x02
d266 9
a274 9
	field	TARGET		0x80	/* Board acting as target */
	field	SELDO		0x40	/* Selection Done */
	field	SELDI		0x20	/* Board has been selected */
	field	SELINGO		0x10	/* Selection In Progress */
	field	SWRAP		0x08	/* 24bit counter wrap */
	field	IOERR		0x08	/* LVD Tranceiver mode changed */
	field	SDONE		0x04	/* STCNT = 0x000000 */
	field	SPIORDY		0x02	/* SCSI PIO Ready */
	field	DMADONE		0x01	/* DMA transfer completed */
d284 7
a290 7
	field	CLRSELTIMEO	0x80
	field	CLRATNO		0x40
	field	CLRSCSIRSTI	0x20
	field	CLRBUSFREE	0x08
	field	CLRSCSIPERR	0x04
	field	CLRPHASECHG	0x02
	field	CLRREQINIT	0x01
d299 8
a306 8
	field	SELTO		0x80
	field	ATNTARG 	0x40
	field	SCSIRSTI	0x20
	field	PHASEMIS	0x10
	field	BUSFREE		0x08
	field	SCSIPERR	0x04
	field	PHASECHG	0x02
	field	REQINIT		0x01
d315 7
a321 7
	field	OVERRUN		0x80
	field	SHVALID		0x40	/* Shaddow Layer non-zero */
	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
	field	CRCVALERR	0x08	/* CRC doesn't match (U3 only) */
	field	CRCENDERR	0x04	/* No terminal CRC packet (U3 only) */
	field	CRCREQERR	0x02	/* Illegal CRC packet req (U3 only) */
	field	DUAL_EDGE_ERR	0x01	/* Incorrect data phase (U3 only) */
a332 1
	mask	U2OFFCNT	0x7f
d353 8
a360 8
	field	ENSELDO		0x40
	field	ENSELDI		0x20
	field	ENSELINGO	0x10
	field	ENSWRAP		0x08
	field	ENIOERR		0x08	/* LVD Tranceiver mode changes */
	field	ENSDONE		0x04
	field	ENSPIORDY	0x02
	field	ENDMADONE	0x01
d371 8
a378 8
	field	ENSELTIMO	0x80
	field	ENATNTARG	0x40
	field	ENSCSIRST	0x20
	field	ENPHASEMIS	0x10
	field	ENBUSFREE	0x08
	field	ENSCSIPERR	0x04
	field	ENPHASECHG	0x02
	field	ENREQINIT	0x01
d387 1
a387 1
	access_mode RW
d392 1
a392 1
	access_mode RW
d415 6
a420 6
	field	STAGE6		0x20
	field	STAGE5		0x10
	field	STAGE4		0x08
	field	STAGE3		0x04
	field	STAGE2		0x02
	field	STAGE1		0x01
d433 1
a433 1
	field	ONEBIT		0x08
d439 4
a442 4
	field	ENSCAMSELO	0x80
	field	CLRSCAMSELID	0x40
	field	ALTSTIM		0x20
	field	DFLTTID		0x10
d466 8
a473 8
	field	SOFT1		0x80
	field	SOFT0		0x40
	field	SOFTCMDEN	0x20	
	field	EXT_BRDCTL	0x10	/* External Board control */
	field	SEEPROM		0x08	/* External serial eeprom logic */
	field	EEPROM		0x04	/* Writable external BIOS ROM */
	field	ROM		0x02	/* Logic for accessing external ROM */
	field	SSPIOCPS	0x01	/* Termination and cable detection */
d478 8
a485 8
	field	BRDDAT7		0x80
	field	BRDDAT6		0x40
	field	BRDDAT5		0x20
	field	BRDSTB		0x10
	field	BRDCS		0x08
	field	BRDRW		0x04
	field	BRDCTL1		0x02
	field	BRDCTL0		0x01
d487 5
a491 5
	field	BRDDAT4		0x10
	field	BRDDAT3		0x08
	field	BRDDAT2		0x04
	field	BRDRW_ULTRA2	0x02
	field	BRDSTB_ULTRA2	0x01
d520 8
a527 8
	field	EXTARBACK	0x80
	field	EXTARBREQ	0x40
	field	SEEMS		0x20
	field	SEERDY		0x10
	field	SEECS		0x08
	field	SEECK		0x04
	field	SEEDO		0x02
	field	SEEDI		0x01
d539 8
a546 8
	field	DIAGLEDEN	0x80	/* Aic78X0 only */
	field	DIAGLEDON	0x40	/* Aic78X0 only */
	field	AUTOFLUSHDIS	0x20
	field	SELBUSB		0x08
	field	ENAB40		0x08	/* LVD transceiver active */
	field	ENAB20		0x04	/* SE/HVD transceiver active */
	field	SELWIDE		0x02
	field	XCVR		0x01	/* External transceiver active */
d556 8
a563 8
	field	PERRORDIS	0x80
	field	PAUSEDIS	0x40
	field	FAILDIS		0x20
	field	FASTMODE	0x10
	field	BRKADRINTEN	0x08
	field	STEP		0x04
	field	SEQRESET	0x02
	field	LOADRAM		0x01
d635 2
a636 2
	field	ZERO		0x02
	field	CARRY		0x01
a658 2
const	STACK_SIZE	4

d665 2
a666 2
	field	ACE		0x08
	field	ENABLE		0x01
d676 4
a679 4
	field	CACHETHEN	0x80	/* Cache Threshold enable */
	field	DPARCKEN	0x40	/* Data Parity Check Enable */
	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
	field	EXTREQLCK	0x10	/* External Request Lock */
d681 4
a684 4
	field	INTSCBRAMSEL	0x08	/* Internal SCB RAM Select */
	field	RAMPS		0x04	/* External SCB RAM Present */
	field	USCBSIZE32	0x02	/* Use 32byte SCB Page Size */
	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
d688 5
a692 5
	address			0x085
	access_mode RW
	mask	DSLATT		0xfc	/* PCI latency timer (non-ultra2) */
	field	HADDLDSEL1	0x02	/* Host Address Load Select Bits */
	field	HADDLDSEL0	0x01
d715 1
a715 1
	mask	DFTHRSH_75	0x80
d729 1
d743 7
a749 7
	field	POWRDN		0x40
	field	SWINT		0x10
	field	IRQMS		0x08
	field	PAUSE		0x04
	field	INTEN		0x02
	field	CHIPRST		0x01
	field	CHIPRSTACK	0x01
d785 4
a788 4
	field	BRKADRINT 0x08
	field	SCSIINT	  0x04
	field	CMDCMPLT  0x02
	field	SEQINT    0x01
d791 1
a791 1
	mask	PROTO_VIOLATION	0x20|SEQINT	/* SCSI protocol violation */ 
d793 9
a801 9
	mask	IGN_WIDE_RES	0x40|SEQINT	/* Complex IGN Wide Res Msg */
	mask	PDATA_REINIT	0x50|SEQINT	/*
						 * Returned to data phase
						 * that requires data
						 * transfer pointers to be
						 * recalculated from the
						 * transfer residual.
						 */
	mask	HOST_MSG_LOOP	0x60|SEQINT	/*
d810 2
a811 2
	mask	BAD_STATUS	0x70|SEQINT	/* Bad status from target */
	mask	PERR_DETECTED	0x80|SEQINT	/*
d816 1
a816 1
	mask	DATA_OVERRUN	0x90|SEQINT	/*
d820 5
d826 15
a840 20
	mask	MKMSG_FAILED	0xa0|SEQINT	/*
						 * Target completed command
						 * without honoring our ATN
						 * request to issue a message. 
						 */
	mask	MISSED_BUSFREE	0xb0|SEQINT	/*
						 * The sequencer never saw
						 * the bus go free after
						 * either a command complete
						 * or disconnect message.
						 */
	mask	SCB_MISMATCH	0xc0|SEQINT	/*
						 * Downloaded SCB's tag does
						 * not match the entry we
						 * intended to download.
						 */
	mask	NO_FREE_SCB	0xd0|SEQINT	/*
						 * get_free_or_disc_scb failed.
						 */
	mask	OUT_OF_RANGE	0xe0|SEQINT
d854 8
a861 8
	field	CIOPARERR	0x80	/* Ultra2 only */
	field	PCIERRSTAT	0x40	/* PCI only */
	field	MPARERR		0x20	/* PCI only */
	field	DPARERR		0x10	/* PCI only */
	field	SQPARERR	0x08
	field	ILLOPCODE	0x04
	field	ILLSADDR	0x02
	field	ILLHADDR	0x01
d870 5
a874 5
	field	CLRPARERR	0x10	/* PCI only */
	field	CLRBRKADRINT	0x08
	field	CLRSCSIINT      0x04
	field	CLRCMDINT 	0x02
	field	CLRSEQINT 	0x01
d880 10
a889 10
	field	PRELOADEN	0x80	/* aic7890 only */
	field	WIDEODD		0x40
	field	SCSIEN		0x20
	field	SDMAEN		0x10
	field	SDMAENACK	0x10
	field	HDMAEN		0x08
	field	HDMAENACK	0x08
	field	DIRECTION	0x04
	field	FIFOFLUSH	0x02
	field	FIFORESET	0x01
d895 8
a902 8
	field	PRELOAD_AVAIL	0x80
	field	DFCACHETH	0x40
	field	FIFOQWDEMP	0x20
	field	MREQPEND	0x10
	field	HDONE		0x08
	field	DFTHRESH	0x04
	field	FIFOFULL	0x02
	field	FIFOEMP		0x01
d928 1
a928 1
	field	SCBAUTO		0x80
d962 6
a967 6
	field	CRCONSEEN		0x80
	field	CRCVALCHKEN		0x40
	field	CRCENDCHKEN		0x20
	field	CRCREQCHKEN		0x10
	field	TARGCRCENDEN		0x08
	field	TARGCRCCNTEN		0x04
d983 7
a989 7
	field	STATUS_PHASE	0x20
	field	COMMAND_PHASE	0x10
	field	MSG_IN_PHASE	0x08
	field	MSG_OUT_PHASE	0x04
	field	DATA_IN_PHASE	0x02
	field	DATA_OUT_PHASE	0x01
	mask	DATA_PHASE_MASK	0x03
d998 1
a998 1
	field	ALT_MODE	0x80
d1007 5
a1011 5

	SCB_CDB_PTR {
		size	4
		alias	SCB_RESIDUAL_DATACNT
		alias	SCB_CDB_STORE
d1013 1
a1013 1
	SCB_RESIDUAL_SGPTR {
d1016 1
a1016 1
	SCB_SCSI_STATUS {
d1019 2
a1020 8
	SCB_TARGET_PHASES {
		size	1
	}
	SCB_TARGET_DATA_DIR {
		size	1
	}
	SCB_TARGET_ITAG {
		size	1
d1027 2
a1028 2
		 * The last byte is really the high address bits for
		 * the data address.
d1031 2
a1032 2
		field	SG_LAST_SEG		0x80	/* In the fourth byte */
		mask	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
d1034 1
a1034 1
	SCB_SGPTR {
d1036 23
a1058 24
		field	SG_RESID_VALID	0x04	/* In the first byte */
		field	SG_FULL_RESID	0x02	/* In the first byte */
		field	SG_LIST_NULL	0x01	/* In the first byte */
	}
	SCB_CONTROL {
		size	1
		field	TARGET_SCB			0x80
		field	STATUS_RCVD			0x80
		field	DISCENB				0x40
		field	TAG_ENB				0x20
		field	MK_MESSAGE			0x10
		field	ULTRAENB			0x08
		field	DISCONNECTED			0x04
		mask	SCB_TAG_TYPE			0x03
	}
	SCB_SCSIID {
		size	1
		field	TWIN_CHNLB			0x80
		mask	TWIN_TID			0x70
		mask	TID				0xf0
		mask	OID				0x0f
	}
	SCB_LUN {
		mask	LID				0xff
d1064 1
a1064 1
	SCB_CDB_LEN {
d1073 2
a1074 2
	SCB_NEXT {
		size	1
d1076 1
a1076 1
	SCB_64_SPARE {
d1079 2
a1080 2
	SCB_64_BTT {
		size	16
d1084 3
a1086 3
const	SCB_UPLOAD_SIZE		32
const	SCB_DOWNLOAD_SIZE	32
const	SCB_DOWNLOAD_SIZE_64	48
d1095 3
a1097 3
	field	CS_2840		0x04
	field	CK_2840		0x02
	field	DO_2840		0x01
d1103 1
a1103 1
	field	EEPROM_TF	0x80
d1106 1
a1106 1
	field	DI_2840		0x01
d1130 4
a1133 4
	field	CCSGDONE	0x80
	field	CCSGEN		0x08
	field	SG_FETCH_NEEDED 0x02	/* Bit used for software state */
	field	CCSGRESET	0x01
d1142 6
a1147 6
	field	CCSCBDONE	0x80
	field	ARRDONE		0x40	/* SCB Array prefetch done */
	field	CCARREN		0x10
	field	CCSCBEN		0x08
	field	CCSCBDIR	0x04
	field	CCSCBRESET	0x01
d1184 3
a1186 3
	field	SCB_AVAIL	0x40
	field	SNSCB_ROLLOVER	0x20
	field	SDSCB_ROLLOVER	0x10
d1214 1
a1214 1
	access_mode WO
d1216 4
a1219 4
	mask	SG_ADDR_MASK	0xf8
	field	ODD_SEG		0x04
	field	LAST_SEG	0x02
	field	LAST_SEG_DONE	0x01
d1223 6
a1228 6
	access_mode RO
	address			0x0fc
	mask	SG_ADDR_MASK	0xf8
	field	ODD_SEG		0x04
	field	LAST_SEG	0x02
	field	LAST_SEG_DONE	0x01
d1252 2
a1253 2
	BUSY_TARGETS {
		alias		TARG_SCSIRATE
d1257 5
a1261 5
	 * Bit vector of targets that have ULTRA enabled as set by
	 * the BIOS.  The Sequencer relies on a per-SCB field to
	 * control whether to enable Ultra transfers or not.  During
	 * initialization, we read this field and reuse it for 2
	 * entries in the busy target table.
d1264 1
a1264 1
		alias		CMDSIZE_TABLE
d1268 4
a1271 4
	 * Bit vector of targets that have disconnection disabled as set by
	 * the BIOS.  The Sequencer relies in a per-SCB field to control the
	 * disconnect priveldge.  During initialization, we read this field
	 * and reuse it for 2 entries in the busy target table.
d1275 16
a1290 17
	}
	CMDSIZE_TABLE_TAIL {
		size		4
	}
	/*
	 * Partial transfer past cacheline end to be
	 * transferred using an extra S/G.
	 */
	MWI_RESIDUAL {
		size		1
		alias	TARG_IMMEDIATE_SCB
	}
	/*
	 * SCBID of the next SCB to be started by the controller.
	 */
	NEXT_QUEUED_SCB {
		size		1
d1302 10
a1311 10
		field	PRELOADEN	0x80
		field	WIDEODD		0x40
		field	SCSIEN		0x20
		field	SDMAEN		0x10
		field	SDMAENACK	0x10
		field	HDMAEN		0x08
		field	HDMAENACK	0x08
		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
		field	FIFOFLUSH	0x02
		field	FIFORESET	0x01
d1315 3
a1317 4
		field	NOT_IDENTIFIED		0x80
		field	NO_CDB_SENT		0x40
		field	TARGET_CMD_IS_TAGGED	0x40
		field	DPHASE			0x20
d1319 5
a1323 5
		field	TARG_CMD_PENDING	0x10
		field	CMDPHASE_PENDING	0x08
		field	DPHASE_PENDING		0x04
		field	SPHASE_PENDING		0x02
		field	NO_DISCONNECT		0x01
d1330 1
a1330 1
	SAVED_SCSIID {
d1333 1
a1333 1
	SAVED_LUN {
d1341 3
a1343 3
		field	CDI		0x80
		field	IOI		0x40
		field	MSGI		0x20
d1376 3
a1378 3
	 * head of list of SCBs that have
	 * completed but have not been
	 * put into the qoutfifo.
d1380 2
a1381 2
	COMPLETE_SCBH {
		size		1
d1384 1
a1384 1
	 * Address of the hardware scb array in the host.
d1386 1
a1386 1
	HSCB_ADDR {
d1390 3
a1392 3
	 * Base address of our shared data with the kernel driver in host
	 * memory.  This includes the qoutfifo and target mode
	 * incoming command queue.
d1394 1
a1394 1
	SHARED_DATA_ADDR {
d1447 6
a1452 6
		field	ENSELO		0x40
		field	ENSELI		0x20
		field	ENRSELI		0x10
		field	ENAUTOATNO	0x08
		field	ENAUTOATNI	0x04
		field	ENAUTOATNP	0x02
a1461 10
}

scratch_ram {
	address		0x056
	size		4
	/*
	 * These scratch ram locations are initialized by the 274X BIOS.
	 * We reuse them after capturing the BIOS settings during
	 * initialization.
	 */
d1466 2
a1467 4
	HA_274_BIOSGLOBAL {
		size	1
		field	HA_274_EXTENDED_TRANS	0x01
		alias	INITIATOR_TAG
d1470 4
a1473 5
	SEQ_FLAGS2 {
		size	1
		field	SCB_DMA			0x01
		field	TARGET_MSG_PENDING	0x02
	}
d1480 3
a1482 7
	 * These are reserved registers in the card's scratch ram on the 2742.
	 * The EISA configuraiton chip is mapped here.  On Rev E. of the
	 * aic7770, the sequencer can use this area for scratch, but the
	 * host cannot directly access these registers.  On later chips, this
	 * area can be read and written by both the host and the sequencer.
	 * Even on later chips, many of these locations are initialized by
	 * the BIOS.
d1486 3
a1488 3
		field	TERM_ENB	0x80
		field	RESET_SCSI	0x40
		field	ENSPCHK		0x20
d1491 6
a1496 6
	}
	INTDEF {
		address		0x05c
		size		1
		field	EDGE_TRIG	0x80
		mask	VECTOR		0x0f
d1507 1
a1507 1
		field	CHANNEL_B_PRIMARY	0x08
d1523 1
a1523 1
const TID_SHIFT		4
a1538 1
const MAX_OFFSET		0xff
d1545 6
a1550 2
const STATUS_QUEUE_FULL	0x28
const TARGET_DATA_IN		1
@


1.1.2.7
log
@Merge with the trunk
@
text
@d1311 1
a1465 1
		alias	TARG_IMMEDIATE_SCB
@


