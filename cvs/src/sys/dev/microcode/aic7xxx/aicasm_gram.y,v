head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.40
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.42
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.38
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.28
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.36
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.34
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.32
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.30
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.26
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.24
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.22
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.20
	OPENBSD_5_0:1.16.0.18
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.16
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.14
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.10
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.12
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.8
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.6
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.16
date	2007.07.07.23.59.36;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.23.21.08.01;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.28.10.10.49;	author moritz;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.18.19.51.53;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.24.23.27.55;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.30.18.25.58;	author smurph;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.28.00.34.55;	author smurph;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.16.05.06.52;	author smurph;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.16.04.36.33;	author smurph;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.22.02.50.49;	author smurph;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2000.03.24.09.09.14;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.1.12.3;

1.1.12.3
date	2003.05.19.22.16.04;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Restore missing '(' to allow successful compilation. Bad pyr@@.
@
text
@%{
/*	$OpenBSD: aicasm_gram.y,v 1.15 2007/05/28 22:17:21 pyr Exp $	*/
/*	$NetBSD: aicasm_gram.y,v 1.3 2003/04/19 19:26:11 fvdl Exp $	*/

/*
 * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.
 *
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001, 2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 *
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.23 2003/01/20 18:02:11 gibbs Exp $
 */

#include <sys/types.h>

#include <inttypes.h>
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>

#ifdef __linux__
#include "../queue.h"
#else
#include <sys/queue.h>
#endif

#include "aicasm.h"
#include "aicasm_symbol.h"
#include "aicasm_insformat.h"

int yylineno;
char *yyfilename;
char stock_prefix[] = "aic_";
char *prefix = stock_prefix;
char *patch_arg_list;
char *versions;
static char errbuf[255];
static char regex_pattern[255];
static symbol_t *cur_symbol;
static symbol_t *field_symbol;
static symbol_t *scb_or_sram_symbol;
static symtype cur_symtype;
static symbol_ref_t accumulator;
static symbol_ref_t mode_ptr;
static symbol_ref_t allones;
static symbol_ref_t allzeros;
static symbol_ref_t none;
static symbol_ref_t sindex;
static int instruction_ptr;
static int num_srams;
static int sram_or_scb_offset;
static int download_constant_count;
static int in_critical_section;
static u_int enum_increment;
static u_int enum_next_value;

static void process_field(int field_type, symbol_t *sym, int mask);
static void initialize_symbol(symbol_t *symbol);
static void add_macro_arg(const char *argtext, int position);
static void add_macro_body(const char *bodytext);
static void process_register(symbol_t **p_symbol);
static void format_1_instr(int opcode, symbol_ref_t *dest,
			   expression_t *immed, symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest,
			   expression_t *places, symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src,
			   expression_t *immed, symbol_ref_t *address);
static void test_readable_symbol(symbol_t *symbol);
static void test_writable_symbol(symbol_t *symbol);
static void type_check(symbol_t *symbol, expression_t *expression, int and_op);
static void make_expression(expression_t *immed, int value);
static void add_conditional(symbol_t *symbol);
static void add_version(const char *verstring);
static int  is_download_const(expression_t *immed);

#define SRAM_SYMNAME "SRAM_BASE"
#define SCB_SYMNAME "SCB_BASE"
%}

%union {
	u_int		value;
	char		*str;
	symbol_t	*sym;
	symbol_ref_t	sym_ref;
	expression_t	expression;
}

%token T_REGISTER

%token <value> T_CONST

%token T_EXPORT

%token T_DOWNLOAD

%token T_SCB

%token T_SRAM

%token T_ALIAS

%token T_SIZE

%token T_EXPR_LSHIFT

%token T_EXPR_RSHIFT

%token <value> T_ADDRESS

%token T_ACCESS_MODE

%token T_MODES

%token T_DEFINE

%token T_SET_SRC_MODE

%token T_SET_DST_MODE

%token <value> T_MODE

%token T_BEGIN_CS

%token T_END_CS

%token T_FIELD

%token T_ENUM

%token T_MASK

%token <value> T_NUMBER

%token <str> T_PATH T_STRING T_ARG T_MACROBODY

%token <sym> T_CEXPR

%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST

%token <value> T_SHR T_SHL T_ROR T_ROL

%token <value> T_MVI T_MOV T_CLR T_BMOV

%token <value> T_JMP T_JC T_JNC T_JE T_JNE T_JNZ T_JZ T_CALL

%token <value> T_ADD T_ADC

%token <value> T_INC T_DEC

%token <value> T_STC T_CLC

%token <value> T_CMP T_NOT T_XOR

%token <value> T_TEST T_AND

%token <value> T_OR

%token T_RET

%token T_NOP

%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX T_MODE_PTR

%token T_A

%token <sym> T_SYMBOL

%token T_NL

%token T_IF T_ELSE T_ELSE_IF T_ENDIF

%type <sym_ref> reg_symbol address destination source opt_source

%type <expression> expression immediate immediate_or_a

%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne

%type <value> mode_value mode_list macro_arglist

%left '|'
%left '&'
%left T_EXPR_LSHIFT T_EXPR_RSHIFT
%left '+' '-'
%left '*' '/'
%right '~'
%nonassoc UMINUS
%%

program:
	include
|	program include
|	prefix
|	program prefix
|	patch_arg_list
|	program patch_arg_list
|	version
|	program version
|	register
|	program register
|	constant
|	program constant
|	macrodefn
|	program macrodefn
|	scratch_ram
|	program scratch_ram
|	scb
|	program scb
|	label
|	program label
|	set_src_mode
|	program set_src_mode
|	set_dst_mode
|	program set_dst_mode
|	critical_section_start
|	program critical_section_start
|	critical_section_end
|	program critical_section_end
|	conditional
|	program conditional
|	code
|	program code
;

include:
	T_INCLUDE '<' T_PATH '>'
	{
		include_file($3, BRACKETED_INCLUDE);
	}
|	T_INCLUDE '"' T_PATH '"'
	{
		include_file($3, QUOTED_INCLUDE);
	}
;

prefix:
	T_PREFIX '=' T_STRING
	{
		if (prefix != stock_prefix)
			stop("Prefix multiply defined",
			     EX_DATAERR);
		prefix = strdup($3);
		if (prefix == NULL)
			stop("Unable to record prefix", EX_SOFTWARE);
	}
;

patch_arg_list:
	T_PATCH_ARG_LIST '=' T_STRING
	{
		if (patch_arg_list != NULL)
			stop("Patch argument list multiply defined",
			     EX_DATAERR);
		patch_arg_list = strdup($3);
		if (patch_arg_list == NULL)
			stop("Unable to record patch arg list", EX_SOFTWARE);
	}
;

version:
	T_VERSION '=' T_STRING
	{ add_version($3); }
;

register:
	T_REGISTER { cur_symtype = REGISTER; } reg_definition
;

reg_definition:
	T_SYMBOL '{'
		{
			if ($1->type != UNINITIALIZED) {
				stop("Register multiply defined", EX_DATAERR);
				/* NOTREACHED */
			}
			cur_symbol = $1; 
			cur_symbol->type = cur_symtype;
			initialize_symbol(cur_symbol);
		}
		reg_attribute_list
	'}'
		{                    
			/*
			 * Default to allowing everything in for registers
			 * with no bit or mask definitions.
			 */
			if (cur_symbol->info.rinfo->valid_bitmask == 0)
				cur_symbol->info.rinfo->valid_bitmask = 0xFF;

			if (cur_symbol->info.rinfo->size == 0)
				cur_symbol->info.rinfo->size = 1;

			/*
			 * This might be useful for registers too.
			 */
			if (cur_symbol->type != REGISTER) {
				if (cur_symbol->info.rinfo->address == 0)
					cur_symbol->info.rinfo->address =
					    sram_or_scb_offset;
				sram_or_scb_offset +=
				    cur_symbol->info.rinfo->size;
			}
			cur_symbol = NULL;
		}
;

reg_attribute_list:
	reg_attribute
|	reg_attribute_list reg_attribute
;

reg_attribute:		
	reg_address
|	size
|	access_mode
|	modes
|	field_defn
|	enum_defn
|	mask_defn
|	alias
|	accumulator
|	mode_pointer
|	allones
|	allzeros
|	none
|	sindex
;

reg_address:
	T_ADDRESS T_NUMBER
	{
		cur_symbol->info.rinfo->address = $2;
	}
;

size:
	T_SIZE T_NUMBER
	{
		cur_symbol->info.rinfo->size = $2;
		if (scb_or_sram_symbol != NULL) {
			u_int max_addr;
			u_int sym_max_addr;

			max_addr = scb_or_sram_symbol->info.rinfo->address
				 + scb_or_sram_symbol->info.rinfo->size;
			sym_max_addr = cur_symbol->info.rinfo->address
				     + cur_symbol->info.rinfo->size;

			if (sym_max_addr > max_addr)
				stop("SCB or SRAM space exhausted", EX_DATAERR);
		}
	}
;

access_mode:
	T_ACCESS_MODE T_MODE
	{
		cur_symbol->info.rinfo->mode = $2;
	}
;

modes:
	T_MODES mode_list
	{
		cur_symbol->info.rinfo->modes = $2;
	}
;

mode_list:
	mode_value
	{
		$$ = $1;
	}
|	mode_list ',' mode_value
	{
		$$ = $1 | $3;
	}
;

mode_value:
	T_NUMBER
	{
		if ($1 > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}

		$$ = (0x1 << $1);
	}
|	T_SYMBOL
	{
		symbol_t *symbol;

		symbol = $1;
		if (symbol->type != CONST) {
			stop("Only \"const\" symbols allowed in "
			     "mode definitions.", EX_DATAERR);
			/* NOTREACHED */
		}
		if (symbol->info.cinfo->value > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = (0x1 << symbol->info.cinfo->value);
	}
;

field_defn:
	T_FIELD
		{
			field_symbol = NULL;
			enum_next_value = 0;
			enum_increment = 1;
		}
	'{' enum_entry_list '}'
|	T_FIELD T_SYMBOL expression
		{
			process_field(FIELD, $2, $3.value);
			field_symbol = $2;
			enum_next_value = 0;
			enum_increment = 0x01 << (ffs($3.value) - 1);
		}
	'{' enum_entry_list '}'
|	T_FIELD T_SYMBOL expression
	{
		process_field(FIELD, $2, $3.value);
	}
;

enum_defn:
	T_ENUM
		{
			field_symbol = NULL;
			enum_next_value = 0;
			enum_increment = 1;
		}
	'{' enum_entry_list '}'
|	T_ENUM T_SYMBOL expression
		{
			process_field(ENUM, $2, $3.value);
			field_symbol = $2;
			enum_next_value = 0;
			enum_increment = 0x01 << (ffs($3.value) - 1);
		}
	'{' enum_entry_list '}'
;

enum_entry_list:
	enum_entry
|	enum_entry_list ',' enum_entry
;

enum_entry:
	T_SYMBOL
	{
		process_field(ENUM_ENTRY, $1, enum_next_value);
		enum_next_value += enum_increment;
	}
|	T_SYMBOL expression
	{
		process_field(ENUM_ENTRY, $1, $2.value);
		enum_next_value = $2.value + enum_increment;
	}
;

mask_defn:
	T_MASK T_SYMBOL expression
	{
		process_field(MASK, $2, $3.value);
	}
;

alias:
	T_ALIAS	T_SYMBOL
	{
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of register alias",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$2->type = ALIAS;
		initialize_symbol($2);
		$2->info.ainfo->parent = cur_symbol;
	}
;

accumulator:
	T_ACCUM
	{
		if (accumulator.symbol != NULL) {
			stop("Only one accumulator definition allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		accumulator.symbol = cur_symbol;
	}
;

mode_pointer:
	T_MODE_PTR
	{
		if (mode_ptr.symbol != NULL) {
			stop("Only one mode pointer definition allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		mode_ptr.symbol = cur_symbol;
	}
;

allones:
	T_ALLONES
	{
		if (allones.symbol != NULL) {
			stop("Only one definition of allones allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		allones.symbol = cur_symbol;
	}
;

allzeros:
	T_ALLZEROS
	{
		if (allzeros.symbol != NULL) {
			stop("Only one definition of allzeros allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		allzeros.symbol = cur_symbol;
	}
;

none:
	T_NONE
	{
		if (none.symbol != NULL) {
			stop("Only one definition of none allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		none.symbol = cur_symbol;
	}
;

sindex:
	T_SINDEX
	{
		if (sindex.symbol != NULL) {
			stop("Only one definition of sindex allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		sindex.symbol = cur_symbol;
	}
;

expression:
	expression '|' expression
	{
		 $$.value = $1.value | $3.value;
		 symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
|	expression '&' expression
	{
		$$.value = $1.value & $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
|	expression '+' expression
	{
		$$.value = $1.value + $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
|	expression '-' expression
	{
		$$.value = $1.value - $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
|	expression '*' expression
	{
		$$.value = $1.value * $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
|	expression '/' expression
	{
		$$.value = $1.value / $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
| 	expression T_EXPR_LSHIFT expression
	{
		$$.value = $1.value << $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
| 	expression T_EXPR_RSHIFT expression
	{
		$$.value = $1.value >> $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
|	'(' expression ')'
	{
		$$ = $2;
	}
|	'~' expression
	{
		$$ = $2;
		$$.value = (~$$.value) & 0xFF;
	}
|	'-' expression %prec UMINUS
	{
		$$ = $2;
		$$.value = -$$.value;
	}
|	T_NUMBER
	{
		$$.value = $1;
		SLIST_INIT(&$$.referenced_syms);
	}
|	T_SYMBOL
	{
		symbol_t *symbol;

		symbol = $1;
		switch (symbol->type) {
		case ALIAS:
			symbol = $1->info.ainfo->parent;
		case REGISTER:
		case SCBLOC:
		case SRAMLOC:
			$$.value = symbol->info.rinfo->address;
			break;
		case MASK:
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			$$.value = symbol->info.finfo->value;
			break;
		case DOWNLOAD_CONST:
		case CONST:
			$$.value = symbol->info.cinfo->value;
			break;
		case UNINITIALIZED:
		default:
		{
			snprintf(errbuf, sizeof(errbuf),
				 "Undefined symbol %s referenced",
				 symbol->name);
			stop(errbuf, EX_DATAERR);
			/* NOTREACHED */
			break;
		}
		}
		SLIST_INIT(&$$.referenced_syms);
		symlist_add(&$$.referenced_syms, symbol, SYMLIST_INSERT_HEAD);
	}
;

constant:
	T_CONST T_SYMBOL expression 
	{
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of symbol as a constant",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$2->type = CONST;
		initialize_symbol($2);
		$2->info.cinfo->value = $3.value;
	}
|	T_CONST T_SYMBOL T_DOWNLOAD
	{
		if ($1) {
			stop("Invalid downloaded constant declaration",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of symbol as a downloaded constant",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$2->type = DOWNLOAD_CONST;
		initialize_symbol($2);
		$2->info.cinfo->value = download_constant_count++;
	}
;

macrodefn_prologue:
	T_DEFINE T_SYMBOL
	{
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of symbol as a macro",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		cur_symbol = $2;
		cur_symbol->type = MACRO;
		initialize_symbol(cur_symbol);
	}
;

macrodefn:
	macrodefn_prologue T_MACROBODY
	{
		add_macro_body($2);
	}
|	macrodefn_prologue '(' macro_arglist ')' T_MACROBODY
	{
		add_macro_body($5);
		cur_symbol->info.macroinfo->narg = $3;
	}
;

macro_arglist:
	{
		/* Macros can take no arguments */
		$$ = 0;
	}
|	T_ARG
	{
		$$ = 1;
		add_macro_arg($1, 0);
	}
|	macro_arglist ',' T_ARG
	{
		if ($1 == 0) {
			stop("Comma without preceding argument in arg list",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = $1 + 1;
		add_macro_arg($3, $1);
	}
;

scratch_ram:
	T_SRAM '{'
		{
			snprintf(errbuf, sizeof(errbuf), "%s%d", SRAM_SYMNAME,
				 num_srams);
			cur_symbol = symtable_get(SRAM_SYMNAME);
			cur_symtype = SRAMLOC;
			cur_symbol->type = SRAMLOC;
			initialize_symbol(cur_symbol);
		}
		reg_address
		{
			sram_or_scb_offset = cur_symbol->info.rinfo->address;
		}
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
	'}'
		{
			cur_symbol = NULL;
			scb_or_sram_symbol = NULL;
		}
;

scb:
	T_SCB '{'
		{
			cur_symbol = symtable_get(SCB_SYMNAME);
			cur_symtype = SCBLOC;
			if (cur_symbol->type != UNINITIALIZED) {
				stop("Only one SRAM definition allowed",
				     EX_SOFTWARE);
				/* NOTREACHED */
			}
			cur_symbol->type = SCBLOC;
			initialize_symbol(cur_symbol);
			/* 64 bytes of SCB space */
			cur_symbol->info.rinfo->size = 64;
		}
		reg_address
		{
			sram_or_scb_offset = cur_symbol->info.rinfo->address;
		}
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
	'}'
		{
			cur_symbol = NULL;
			scb_or_sram_symbol = NULL;
		}
;

scb_or_sram_attributes:
	/* NULL definition is okay */
|	modes
|	scb_or_sram_reg_list
|	modes scb_or_sram_reg_list
;

scb_or_sram_reg_list:
	reg_definition
|	scb_or_sram_reg_list reg_definition
;

reg_symbol:
	T_SYMBOL
	{
		process_register(&$1);
		$$.symbol = $1;
		$$.offset = 0;
	}
|	T_SYMBOL '[' T_SYMBOL ']'
	{
		process_register(&$1);
		if ($3->type != CONST) {
			stop("register offset must be a constant", EX_DATAERR);
			/* NOTREACHED */
		}
		if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
			stop("Accessing offset beyond range of register",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$.symbol = $1;
		$$.offset = $3->info.cinfo->value;
	}
|	T_SYMBOL '[' T_NUMBER ']'
	{
		process_register(&$1);
		if (($3 + 1) > $1->info.rinfo->size) {
			stop("Accessing offset beyond range of register",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$.symbol = $1;
		$$.offset = $3;
	}
|	T_A
	{
		if (accumulator.symbol == NULL) {
			stop("No accumulator has been defined", EX_DATAERR);
			/* NOTREACHED */
		}
		$$.symbol = accumulator.symbol;
		$$.offset = 0;
	}
;

destination:
	reg_symbol
	{
		test_writable_symbol($1.symbol);
		$$ = $1;
	}
;

immediate:
	expression
	{ $$ = $1; }
;

immediate_or_a:
	expression
	{
		if ($1.value == 0 && is_download_const(&$1) == 0) {
			snprintf(errbuf, sizeof(errbuf),
				 "\nExpression evaluates to 0 and thus "
				 "references the accumulator.\n "
				 "If this is the desired effect, use 'A' "
				 "instead.\n");
			stop(errbuf, EX_DATAERR);
		}
		$$ = $1;
	}
|	T_A
	{
		SLIST_INIT(&$$.referenced_syms);
		symlist_add(&$$.referenced_syms, accumulator.symbol,
			    SYMLIST_INSERT_HEAD);
		$$.value = 0;
	}
;

source:
	reg_symbol
	{
		test_readable_symbol($1.symbol);
		$$ = $1;
	}
;

opt_source:
	{
		$$.symbol = NULL;
		$$.offset = 0;
	}
|	',' source
	{ $$ = $2; }
;

ret:
	{ $$ = 0; }
|	T_RET
	{ $$ = 1; }
;

set_src_mode:
	T_SET_SRC_MODE T_NUMBER ';'
	{
		src_mode = $2;
	}
;

set_dst_mode:
	T_SET_DST_MODE T_NUMBER ';'
	{
		dst_mode = $2;
	}
;

critical_section_start:
	T_BEGIN_CS ';'
	{
		critical_section_t *cs;

		if (in_critical_section != FALSE) {
			stop("Critical Section within Critical Section",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		cs = cs_alloc();
		cs->begin_addr = instruction_ptr;
		in_critical_section = TRUE;
	}
;

critical_section_end:
	T_END_CS ';'
	{
		critical_section_t *cs;

		if (in_critical_section == FALSE) {
			stop("Unballanced 'end_cs'", EX_DATAERR);
			/* NOTREACHED */
		}
		cs = TAILQ_LAST(&cs_tailq, cs_tailq);
		cs->end_addr = instruction_ptr;
		in_critical_section = FALSE;
	}
;

export:
	{ $$ = 0; }
|	T_EXPORT
	{ $$ = 1; }
;

label:
	export T_SYMBOL ':'
	{
		if ($2->type != UNINITIALIZED) {
			stop("Program label multiply defined", EX_DATAERR);
			/* NOTREACHED */
		}
		$2->type = LABEL;
		initialize_symbol($2);
		$2->info.linfo->address = instruction_ptr;
		$2->info.linfo->exported = $1;
	}
;

address:
	T_SYMBOL
	{
		$$.symbol = $1;
		$$.offset = 0;
	}
|	T_SYMBOL '+' T_NUMBER
	{
		$$.symbol = $1;
		$$.offset = $3;
	}
|	T_SYMBOL '-' T_NUMBER
	{
		$$.symbol = $1;
		$$.offset = -$3;
	}
|	'.'
	{
		$$.symbol = NULL;
		$$.offset = 0;
	}
|	'.' '+' T_NUMBER
	{
		$$.symbol = NULL;
		$$.offset = $3;
	}
|	'.' '-' T_NUMBER
	{
		$$.symbol = NULL;
		$$.offset = -$3;
	}
;

conditional:
	T_IF T_CEXPR '{'
	{
		scope_t *new_scope;

		add_conditional($2);
		new_scope = scope_alloc();
		new_scope->type = SCOPE_IF;
		new_scope->begin_addr = instruction_ptr;
		new_scope->func_num = $2->info.condinfo->func_num;
	}
|	T_ELSE T_IF T_CEXPR '{'
	{
		scope_t *new_scope;
		scope_t *scope_context;
		scope_t *last_scope;

		/*
		 * Ensure that the previous scope is either an
		 * if or and else if.
		 */
		scope_context = SLIST_FIRST(&scope_stack);
		last_scope = TAILQ_LAST(&scope_context->inner_scope,
					scope_tailq);
		if (last_scope == NULL
		 || last_scope->type == T_ELSE) {

			stop("'else if' without leading 'if'", EX_DATAERR);
			/* NOTREACHED */
		}
		add_conditional($3);
		new_scope = scope_alloc();
		new_scope->type = SCOPE_ELSE_IF;
		new_scope->begin_addr = instruction_ptr;
		new_scope->func_num = $3->info.condinfo->func_num;
	}
|	T_ELSE '{'
	{
		scope_t *new_scope;
		scope_t *scope_context;
		scope_t *last_scope;

		/*
		 * Ensure that the previous scope is either an
		 * if or and else if.
		 */
		scope_context = SLIST_FIRST(&scope_stack);
		last_scope = TAILQ_LAST(&scope_context->inner_scope,
					scope_tailq);
		if (last_scope == NULL
		 || last_scope->type == SCOPE_ELSE) {

			stop("'else' without leading 'if'", EX_DATAERR);
			/* NOTREACHED */
		}
		new_scope = scope_alloc();
		new_scope->type = SCOPE_ELSE;
		new_scope->begin_addr = instruction_ptr;
	}
;

conditional:
	'}'
	{
		scope_t *scope_context;

		scope_context = SLIST_FIRST(&scope_stack);
		if (scope_context->type == SCOPE_ROOT) {
			stop("Unexpected '}' encountered", EX_DATAERR);
			/* NOTREACHED */
		}

		scope_context->end_addr = instruction_ptr;

		/* Pop the scope */
		SLIST_REMOVE_HEAD(&scope_stack, scope_stack_links);

		process_scope(scope_context);

		if (SLIST_FIRST(&scope_stack) == NULL) {
			stop("Unexpected '}' encountered", EX_DATAERR);
			/* NOTREACHED */
		}
	}
;

f1_opcode:
	T_AND { $$ = AIC_OP_AND; }
|	T_XOR { $$ = AIC_OP_XOR; }
|	T_ADD { $$ = AIC_OP_ADD; }
|	T_ADC { $$ = AIC_OP_ADC; }
;

code:
	f1_opcode destination ',' immediate_or_a opt_source ret ';'
	{
		format_1_instr($1, &$2, &$4, &$5, $6);
	}
;

code:
	T_OR reg_symbol ',' immediate_or_a opt_source ret ';'
	{
		format_1_instr(AIC_OP_OR, &$2, &$4, &$5, $6);
	}
;

code:
	T_INC destination opt_source ret ';'
	{
		expression_t immed;

		make_expression(&immed, 1);
		format_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);
	}
;

code:
	T_DEC destination opt_source ret ';'
	{
		expression_t immed;

		make_expression(&immed, -1);
		format_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);
	}
;

code:
	T_CLC ret ';'
	{
		expression_t immed;

		make_expression(&immed, -1);
		format_1_instr(AIC_OP_ADD, &none, &immed, &allzeros, $2);
	}
|	T_CLC T_MVI destination ',' immediate_or_a ret ';'
	{
		format_1_instr(AIC_OP_ADD, &$3, &$5, &allzeros, $6);
	}
;

code:
	T_STC ret ';'
	{
		expression_t immed;

		make_expression(&immed, 1);
		format_1_instr(AIC_OP_ADD, &none, &immed, &allones, $2);
	}
|	T_STC destination ret ';'
	{
		expression_t immed;

		make_expression(&immed, 1);
		format_1_instr(AIC_OP_ADD, &$2, &immed, &allones, $3);
	}
;

code:
	T_BMOV destination ',' source ',' immediate ret ';'
	{
		format_1_instr(AIC_OP_BMOV, &$2, &$6, &$4, $7);
	}
;

code:
	T_MOV destination ',' source ret ';'
	{
		expression_t immed;

		make_expression(&immed, 1);
		format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
	}
;

code:
	T_MVI destination ',' immediate ret ';'
	{
		if ($4.value == 0
		 && is_download_const(&$4) == 0) {
			expression_t immed;

			/*
			 * Allow move immediates of 0 so that macros,
			 * that can't know the immediate's value and
			 * otherwise compensate, still work.
			 */
			make_expression(&immed, 1);
			format_1_instr(AIC_OP_BMOV, &$2, &immed, &allzeros, $5);
		} else {
			format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
		}
	}
;

code:
	T_NOT destination opt_source ret ';'
	{
		expression_t immed;

		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
	}
;

code:
	T_CLR destination ret ';'
	{
		expression_t immed;

		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &$2, &immed, &allzeros, $3);
	}
;

code:
	T_NOP ret ';'
	{
		expression_t immed;

		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, $2);
	}
;

code:
	T_RET ';'
	{
		expression_t immed;

		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, TRUE);
	}
;

	/*
	 * This grammer differs from the one in the aic7xxx
	 * reference manual since the grammer listed there is
	 * ambiguous and causes a shift/reduce conflict.
	 * It also seems more logical as the "immediate"
	 * argument is listed as the second arg like the
	 * other formats.
	 */

f2_opcode:
	T_SHL { $$ = AIC_OP_SHL; }
|	T_SHR { $$ = AIC_OP_SHR; }
|	T_ROL { $$ = AIC_OP_ROL; }
|	T_ROR { $$ = AIC_OP_ROR; }
;

code:
	f2_opcode destination ',' expression opt_source ret ';'
	{
		format_2_instr($1, &$2, &$4, &$5, $6);
	}
;

jmp_jc_jnc_call:
	T_JMP	{ $$ = AIC_OP_JMP; }
|	T_JC	{ $$ = AIC_OP_JC; }
|	T_JNC	{ $$ = AIC_OP_JNC; }
|	T_CALL	{ $$ = AIC_OP_CALL; }
;

jz_jnz:
	T_JZ	{ $$ = AIC_OP_JZ; }
|	T_JNZ	{ $$ = AIC_OP_JNZ; }
;

je_jne:
	T_JE	{ $$ = AIC_OP_JE; }
|	T_JNE	{ $$ = AIC_OP_JNE; }
;

code:
	jmp_jc_jnc_call address ';'
	{
		expression_t immed;

		make_expression(&immed, 0);
		format_3_instr($1, &sindex, &immed, &$2);
	}
;

code:
	T_OR reg_symbol ',' immediate jmp_jc_jnc_call address ';'
	{
		format_3_instr($5, &$2, &$4, &$6);
	}
;

code:
	T_TEST source ',' immediate_or_a jz_jnz address ';'
	{
		format_3_instr($5, &$2, &$4, &$6);
	}
;

code:
	T_CMP source ',' immediate_or_a je_jne address ';'
	{
		format_3_instr($5, &$2, &$4, &$6);
	}
;

code:
	T_MOV source jmp_jc_jnc_call address ';'
	{
		expression_t immed;

		make_expression(&immed, 0);
		format_3_instr($3, &$2, &immed, &$4);
	}
;

code:
	T_MVI immediate jmp_jc_jnc_call address ';'
	{
		format_3_instr($3, &allzeros, &$2, &$4);
	}
;

%%

static void
process_field(int field_type, symbol_t *sym, int value)
{
	/*
	 * Add the current register to its
	 * symbol list, if it already exists,
	 * warn if we are setting it to a
	 * different value, or in the bit to
	 * the "allowed bits" of this register.
	 */
	if (sym->type == UNINITIALIZED) {
		sym->type = field_type;
		initialize_symbol(sym);
		sym->info.finfo->value = value;
		if (field_type != ENUM_ENTRY) {
			if (field_type != MASK && value == 0) {
				stop("Empty Field, or Enum", EX_DATAERR);
				/* NOTREACHED */
			}
			sym->info.finfo->value = value;
			sym->info.finfo->mask = value;
		} else if (field_symbol != NULL) {
			sym->info.finfo->mask = field_symbol->info.finfo->value;
		} else {
			sym->info.finfo->mask = 0xFF;
		}
	} else if (sym->type != field_type) {
		stop("Field definition mirrors a definition of the same "
		     " name, but a different type", EX_DATAERR);
		/* NOTREACHED */
	} else if (value != sym->info.finfo->value) {
		stop("Field redefined with a conflicting value", EX_DATAERR);
		/* NOTREACHED */
	}
	/* Fail if this symbol is already listed */
	if (symlist_search(&(sym->info.finfo->symrefs),
			   cur_symbol->name) != NULL) {
		stop("Field defined multiple times for register", EX_DATAERR);
		/* NOTREACHED */
	}
	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
		    SYMLIST_INSERT_HEAD);
	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
	cur_symbol->info.rinfo->typecheck_masks = TRUE;
	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
}

static void
initialize_symbol(symbol_t *symbol)
{
	switch (symbol->type) {
	case UNINITIALIZED:
		stop("Call to initialize_symbol with type field unset",
		     EX_SOFTWARE);
		/* NOTREACHED */
		break;
	case REGISTER:
	case SRAMLOC:
	case SCBLOC:
		symbol->info.rinfo =
		    (struct reg_info *)malloc(sizeof(struct reg_info));
		if (symbol->info.rinfo == NULL) {
			stop("Can't create register info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.rinfo, 0,
		       sizeof(struct reg_info));
		SLIST_INIT(&(symbol->info.rinfo->fields));
		/*
		 * Default to allowing access in all register modes
		 * or to the mode specified by the SCB or SRAM space
		 * we are in.
		 */
		if (scb_or_sram_symbol != NULL)
			symbol->info.rinfo->modes =
			    scb_or_sram_symbol->info.rinfo->modes;
		else
			symbol->info.rinfo->modes = ~0;
		break;
	case ALIAS:
		symbol->info.ainfo =
		    (struct alias_info *)malloc(sizeof(struct alias_info));
		if (symbol->info.ainfo == NULL) {
			stop("Can't create alias info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.ainfo, 0,
		       sizeof(struct alias_info));
		break;
	case MASK:
	case FIELD:
	case ENUM:
	case ENUM_ENTRY:
		symbol->info.finfo =
		    (struct field_info *)malloc(sizeof(struct field_info));
		if (symbol->info.finfo == NULL) {
			stop("Can't create field info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.finfo, 0, sizeof(struct field_info));
		SLIST_INIT(&(symbol->info.finfo->symrefs));
		break;
	case CONST:
	case DOWNLOAD_CONST:
		symbol->info.cinfo =
		    (struct const_info *)malloc(sizeof(struct const_info));
		if (symbol->info.cinfo == NULL) {
			stop("Can't create alias info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.cinfo, 0,
		       sizeof(struct const_info));
		break;
	case LABEL:
		symbol->info.linfo =
		    (struct label_info *)malloc(sizeof(struct label_info));
		if (symbol->info.linfo == NULL) {
			stop("Can't create label info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.linfo, 0,
		       sizeof(struct label_info));
		break;
	case CONDITIONAL:
		symbol->info.condinfo =
		    (struct cond_info *)malloc(sizeof(struct cond_info));
		if (symbol->info.condinfo == NULL) {
			stop("Can't create conditional info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.condinfo, 0,
		       sizeof(struct cond_info));
		break;
	case MACRO:
		symbol->info.macroinfo = 
		    (struct macro_info *)malloc(sizeof(struct macro_info));
		if (symbol->info.macroinfo == NULL) {
			stop("Can't create macro info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.macroinfo, 0,
		       sizeof(struct macro_info));
		TAILQ_INIT(&symbol->info.macroinfo->args);
		break;
	default:
		stop("Call to initialize_symbol with invalid symbol type",
		     EX_SOFTWARE);
		/* NOTREACHED */
		break;
	}
}

static void
add_macro_arg(const char *argtext, int argnum)
{
	struct macro_arg *marg;
	int i;
	int retval;
		

	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}

	marg = (struct macro_arg *)malloc(sizeof(*marg));
	if (marg == NULL) {
		stop("Can't create macro_arg structure", EX_SOFTWARE);
		/* NOTREACHED */
	}
	marg->replacement_text = NULL;
	retval = snprintf(regex_pattern, sizeof(regex_pattern),
			  "[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)",
			  argtext);
	if (retval == -1 || retval >= sizeof(regex_pattern)) {
		stop("Regex text buffer too small for arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	retval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);
	if (retval != 0) {
		stop("Regex compilation failed", EX_SOFTWARE);
		/* NOTREACHED */
	}
	TAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);
}

static void
add_macro_body(const char *bodytext)
{
	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	cur_symbol->info.macroinfo->body = strdup(bodytext);
	if (cur_symbol->info.macroinfo->body == NULL) {
		stop("Can't duplicate macro body text", EX_SOFTWARE);
		/* NOTREACHED */
	}
}

static void
process_register(symbol_t **p_symbol)
{
	symbol_t *symbol = *p_symbol;

	if (symbol->type == UNINITIALIZED) {
		snprintf(errbuf, sizeof(errbuf), "Undefined register %s",
			 symbol->name);
		stop(errbuf, EX_DATAERR);
		/* NOTREACHED */
	} else if (symbol->type == ALIAS) {
		*p_symbol = symbol->info.ainfo->parent;
	} else if ((symbol->type != REGISTER)
		&& (symbol->type != SCBLOC)
		&& (symbol->type != SRAMLOC)) {
		snprintf(errbuf, sizeof(errbuf),
			 "Specified symbol %s is not a register",
			 symbol->name);
		stop(errbuf, EX_DATAERR);
	}
}

static void
format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
	       symbol_ref_t *src, int ret)
{
	struct instruction *instr;
	struct ins_format1 *f1_instr;

	if (src->symbol == NULL)
		src = dest;

	/* Test register permissions */
	test_writable_symbol(dest->symbol);
	test_readable_symbol(src->symbol);

	/* Ensure that immediate makes sense for this destination */
	type_check(dest->symbol, immed, opcode);

	/* Allocate sequencer space for the instruction and fill it out */
	instr = seq_alloc();
	f1_instr = &instr->format.format1;
	f1_instr->ret = ret ? 1 : 0;
	f1_instr->opcode = opcode;
	f1_instr->destination = dest->symbol->info.rinfo->address
			      + dest->offset;
	f1_instr->source = src->symbol->info.rinfo->address
			 + src->offset;
	f1_instr->immediate = immed->value;

	if (is_download_const(immed))
		f1_instr->parity = 1;
	else if (dest->symbol == mode_ptr.symbol) {
		u_int src_value;
		u_int dst_value;

		/*
		 * Attempt to update mode information if
		 * we are operating on the mode register.
		 */
		if (src->symbol == allones.symbol)
			src_value = 0xFF;
		else if (src->symbol == allzeros.symbol)
			src_value = 0;
		else if (src->symbol == mode_ptr.symbol)
			src_value = (dst_mode << 4) | src_mode;
		else
			goto cant_update;

		switch (opcode) {
		case AIC_OP_AND:
			dst_value = src_value & immed->value;
			break;
		case AIC_OP_XOR:
			dst_value = src_value ^ immed->value;
			break;
		case AIC_OP_ADD:
			dst_value = (src_value + immed->value) & 0xFF;
			break;
		case AIC_OP_OR:
			dst_value = src_value | immed->value;
			break;
		case AIC_OP_BMOV:
			dst_value = src_value;
			break;
		default:
			goto cant_update;
		}
		src_mode = dst_value & 0xF;
		dst_mode = (dst_value >> 4) & 0xF;
	}

cant_update:
	symlist_free(&immed->referenced_syms);
	instruction_ptr++;
}

static void
format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
	       symbol_ref_t *src, int ret)
{
	struct instruction *instr;
	struct ins_format2 *f2_instr;
	uint8_t shift_control;

	if (src->symbol == NULL)
		src = dest;

	/* Test register permissions */
	test_writable_symbol(dest->symbol);
	test_readable_symbol(src->symbol);

	/* Allocate sequencer space for the instruction and fill it out */
	instr = seq_alloc();
	f2_instr = &instr->format.format2;
	f2_instr->ret = ret ? 1 : 0;
	f2_instr->opcode = AIC_OP_ROL;
	f2_instr->destination = dest->symbol->info.rinfo->address
			      + dest->offset;
	f2_instr->source = src->symbol->info.rinfo->address
			 + src->offset;
	if (places->value > 8 || places->value <= 0) {
		stop("illegal shift value", EX_DATAERR);
		/* NOTREACHED */
	}
	switch (opcode) {
	case AIC_OP_SHL:
		if (places->value == 8)
			shift_control = 0xf0;
		else
			shift_control = (places->value << 4) | places->value;
		break;
	case AIC_OP_SHR:
		if (places->value == 8) {
			shift_control = 0xf8;
		} else {
			shift_control = (places->value << 4)
				      | (8 - places->value)
				      | 0x08;
		}
		break;
	case AIC_OP_ROL:
		shift_control = places->value & 0x7;
		break;
	case AIC_OP_ROR:
		shift_control = (8 - places->value) | 0x08;
		break;
	default:
		shift_control = 0; /* Quiet Compiler */
		stop("Invalid shift operation specified", EX_SOFTWARE);
		/* NOTREACHED */
		break;
	};
	f2_instr->shift_control = shift_control;
	symlist_free(&places->referenced_syms);
	instruction_ptr++;
}

static void
format_3_instr(int opcode, symbol_ref_t *src,
	       expression_t *immed, symbol_ref_t *address)
{
	struct instruction *instr;
	struct ins_format3 *f3_instr;
	int addr;

	/* Test register permissions */
	test_readable_symbol(src->symbol);

	/* Ensure that immediate makes sense for this source */
	type_check(src->symbol, immed, opcode);

	/* Allocate sequencer space for the instruction and fill it out */
	instr = seq_alloc();
	f3_instr = &instr->format.format3;
	if (address->symbol == NULL) {
		/* 'dot' referrence.  Use the current instruction pointer */
		addr = instruction_ptr + address->offset;
	} else if (address->symbol->type == UNINITIALIZED) {
		/* forward reference */
		addr = address->offset;
		instr->patch_label = address->symbol;
	} else
		addr = address->symbol->info.linfo->address + address->offset;
	f3_instr->opcode = opcode;
	f3_instr->address = addr;
	f3_instr->source = src->symbol->info.rinfo->address
			 + src->offset;
	f3_instr->immediate = immed->value;

	if (is_download_const(immed))
		f3_instr->parity = 1;

	symlist_free(&immed->referenced_syms);
	instruction_ptr++;
}

static void
test_readable_symbol(symbol_t *symbol)
{
	
	if ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in source reg mode %d",
			symbol->name, src_mode);
		stop(errbuf, EX_DATAERR);
	}

	if (symbol->info.rinfo->mode == WO) {
		stop("Write Only register specified as source",
		     EX_DATAERR);
		/* NOTREACHED */
	}
}

static void
test_writable_symbol(symbol_t *symbol)
{
	
	if ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in destination reg mode %d",
			symbol->name, dst_mode);
		stop(errbuf, EX_DATAERR);
	}

	if (symbol->info.rinfo->mode == RO) {
		stop("Read Only register specified as destination",
		     EX_DATAERR);
		/* NOTREACHED */
	}
}

static void
type_check(symbol_t *symbol, expression_t *expression, int opcode)
{
	symbol_node_t *node;
	int and_op;

	and_op = FALSE;
	if (opcode == AIC_OP_AND || opcode == AIC_OP_JNZ || AIC_OP_JZ)
		and_op = TRUE;

	/*
	 * Make sure that we aren't attempting to write something
	 * that hasn't been defined.  If this is an and operation,
	 * this is a mask, so "undefined" bits are okay.
	 */
	if (and_op == FALSE
	 && (expression->value & ~symbol->info.rinfo->valid_bitmask) != 0) {
		snprintf(errbuf, sizeof(errbuf),
			 "Invalid bit(s) 0x%x in immediate written to %s",
			 expression->value & ~symbol->info.rinfo->valid_bitmask,
			 symbol->name);
		stop(errbuf, EX_DATAERR);
		/* NOTREACHED */
	}

	/*
	 * Now make sure that all of the symbols referenced by the
	 * expression are defined for this register.
	 */
	if (symbol->info.rinfo->typecheck_masks != FALSE) {
		SLIST_FOREACH(node, &expression->referenced_syms, links) {
			if ((node->symbol->type == MASK
			  || node->symbol->type == FIELD
			  || node->symbol->type == ENUM
			  || node->symbol->type == ENUM_ENTRY)
			 && symlist_search(&node->symbol->info.finfo->symrefs,
					   symbol->name) == NULL) {
				snprintf(errbuf, sizeof(errbuf),
					 "Invalid field or mask %s "
					 "for register %s",
					 node->symbol->name, symbol->name);
				stop(errbuf, EX_DATAERR);
				/* NOTREACHED */
			}
		}
	}
}

static void
make_expression(expression_t *immed, int value)
{
	SLIST_INIT(&immed->referenced_syms);
	immed->value = value & 0xff;
}

static void
add_conditional(symbol_t *symbol)
{
	static int numfuncs;

	if (numfuncs == 0) {
		/* add a special conditional, "0" */
		symbol_t *false_func;

		false_func = symtable_get("0");
		if (false_func->type != UNINITIALIZED) {
			stop("Conditional expression '0' "
			     "conflicts with a symbol", EX_DATAERR);
			/* NOTREACHED */
		}
		false_func->type = CONDITIONAL;
		initialize_symbol(false_func);
		false_func->info.condinfo->func_num = numfuncs++;
		symlist_add(&patch_functions, false_func, SYMLIST_INSERT_HEAD);
	}

	/* This condition has occurred before */
	if (symbol->type == CONDITIONAL)
		return;

	if (symbol->type != UNINITIALIZED) {
		stop("Conditional expression conflicts with a symbol",
		     EX_DATAERR);
		/* NOTREACHED */
	}

	symbol->type = CONDITIONAL;
	initialize_symbol(symbol);
	symbol->info.condinfo->func_num = numfuncs++;
	symlist_add(&patch_functions, symbol, SYMLIST_INSERT_HEAD);
}

static void
add_version(const char *verstring)
{
	const char *q, prefix[] = " * ";
	char *p;
	int newlen;
	int oldlen;

	newlen = strlen(verstring) + strlen(prefix);
	oldlen = 0;
	if (versions != NULL)
		oldlen = strlen(versions);
	versions = realloc(versions, newlen + oldlen + 2);
	if (versions == NULL)
		stop("Can't allocate version string", EX_SOFTWARE);
	strcpy(&versions[oldlen], prefix);
	for (p = &versions[oldlen + strlen(prefix)], q = verstring; *q; q++) {
		if (*q == '$')
			continue;
		*p++ = *q;
	}
	*p++ = '\n';
	*p = '\0';
}

void
yyerror(const char *string)
{
	stop(string, EX_DATAERR);
}

static int
is_download_const(expression_t *immed)
{
	if ((!SLIST_EMPTY(&immed->referenced_syms))
	 && (SLIST_FIRST(&immed->referenced_syms)->symbol->type == DOWNLOAD_CONST))
		return (TRUE);

	return (FALSE);
}
@


1.15
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_gram.y,v 1.14 2006/12/23 21:08:01 krw Exp $	*/
d1944 1
a1944 1
	if (!SLIST_EMPTY(&immed->referenced_syms))
@


1.14
log
@Spelling.

'preceeding' -> 'preceding'
'preceeds' -> 'precedes'
'preceeded' -> 'preceded'
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_gram.y,v 1.13 2005/04/28 10:10:49 moritz Exp $	*/
d1848 1
a1848 3
		for(node = expression->referenced_syms.slh_first;
		    node != NULL;
		    node = node->links.sle_next) {
d1944 2
a1945 2
	if ((immed->referenced_syms.slh_first != NULL)
	 && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))
@


1.13
log
@more snprintf checking. ok krw@@
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_gram.y,v 1.12 2004/09/18 19:51:53 mickey Exp $	*/
d779 1
a779 1
			stop("Comma without preceeding argument in arg list",
@


1.12
log
@repair build that reused y.tab.h for two different parsers
thus failing a build every other time.
make generated arrays const and repair rcsid generation for output.
allow one-step build; from krw@@
krw@@ ok
@
text
@d2 1
a2 1
/*	$OpenBSD: aicasm_gram.y,v 1.11 2003/12/24 23:27:55 krw Exp $	*/
d1557 1
a1557 1
	if (retval >= sizeof(regex_pattern)) {
@


1.11
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d1915 2
a1916 1
	const char prefix[] = " * ";
d1928 7
a1934 3
	strcpy(&versions[oldlen + strlen(prefix)], verstring);
	versions[newlen + oldlen] = '\n';
	versions[newlen + oldlen + 1] = '\0';
@


1.10
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d2 3
d9 1
a9 1
 * Copyright (c) 2001 Adaptec Inc.
d44 1
a44 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.17 2002/06/05 22:51:54 gibbs Exp $
d56 3
d60 1
d64 1
a64 1
#include "sequencer.h"
d68 2
d75 1
d89 2
d92 1
a92 1
static void process_bitmask(int mask_type, symbol_t *sym, int mask);
d161 3
a163 1
%token T_BIT
d173 1
a173 1
%token T_EOF T_INCLUDE T_VERSION T_PATCH_ARG_LIST
d213 1
a213 1
%type <value> numerical_value mode_value mode_list macro_arglist
d227 2
d231 2
a232 2
|       version
|       program version
d249 4
a252 4
|       critical_section_start
|       program critical_section_start
|       critical_section_end
|       program critical_section_end
d261 3
a263 3
        {
                include_file($3, BRACKETED_INCLUDE);
        }
d265 15
a279 3
        {
                include_file($3, QUOTED_INCLUDE);
        }
d295 2
a296 2
        T_VERSION '=' T_STRING
        { add_version($3); }
d351 2
a352 1
|	bit_defn
d444 17
a460 2
bit_defn:
	T_BIT T_SYMBOL T_NUMBER
d462 37
a498 1
		process_bitmask(BIT, $2, $3);
d505 1
a505 1
		process_bitmask(MASK, $2, $3.value);
d685 4
a688 2
		case BIT:
			$$.value = symbol->info.minfo->mask;
d711 1
a711 1
	T_CONST T_SYMBOL numerical_value
d720 1
a720 1
		$2->info.cinfo->value = $3;
a787 11
numerical_value:
	T_NUMBER
	{
		$$ = $1;
	}
|	'-' T_NUMBER
	{
		$$ = -$2;
	}
;

d826 2
a827 2
                        /* 64 bytes of SCB space */
                        cur_symbol->info.rinfo->size = 64;
d864 15
a878 15
|       T_SYMBOL '[' T_SYMBOL ']'
        {
                process_register(&$1);
                if ($3->type != CONST) {
                        stop("register offset must be a constant", EX_DATAERR);
                        /* NOTREACHED */
                }
                if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
                        stop("Accessing offset beyond range of register",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                $$.symbol = $1;
                $$.offset = $3->info.cinfo->value;
        }
d930 2
d976 1
a976 1
                critical_section_t *cs;
d978 10
a987 9
                if (in_critical_section != FALSE) {
                        stop("Critical Section within Critical Section",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = cs_alloc();
                cs->begin_addr = instruction_ptr;
                in_critical_section = TRUE;
        }
d992 1
a992 1
                critical_section_t *cs;
d994 9
a1002 8
                if (in_critical_section == FALSE) {
                        stop("Unballanced 'end_cs'", EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = TAILQ_LAST(&cs_tailq, cs_tailq);
                cs->end_addr = instruction_ptr;
                in_critical_section = FALSE;
        }
d1227 2
a1228 2
                make_expression(&immed, 1);
                format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
d1233 1
a1233 1
	T_MVI destination ',' immediate_or_a ret ';'
d1235 15
a1249 2
		format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
        }
d1253 3
a1255 3
        T_NOT destination opt_source ret ';'
        {
                expression_t immed;
d1257 2
a1258 2
                make_expression(&immed, 0xff);
                format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
d1383 1
a1383 1
process_bitmask(int mask_type, symbol_t *sym, int mask)
d1393 1
a1393 1
		sym->type = mask_type;
d1395 4
a1398 8
		if (mask_type == BIT) {
			if (mask == 0) {
				stop("Bitmask with no bits set", EX_DATAERR);
				/* NOTREACHED */
			}
			if ((mask & ~(0x01 << (ffs(mask) - 1))) != 0) {
				stop("Bitmask with more than one bit set",
				     EX_DATAERR);
d1401 6
d1408 2
a1409 3
		sym->info.minfo->mask = mask;
	} else if (sym->type != mask_type) {
		stop("Bit definition mirrors a definition of the same "
d1412 2
a1413 2
	} else if (mask != sym->info.minfo->mask) {
		stop("Bitmask redefined with a conflicting value", EX_DATAERR);
d1417 1
a1417 1
	if (symlist_search(&(sym->info.minfo->symrefs),
d1419 1
a1419 1
		stop("Bitmask defined multiple times for register", EX_DATAERR);
d1422 1
a1422 1
	symlist_add(&(sym->info.minfo->symrefs), cur_symbol,
d1424 1
a1424 1
	cur_symbol->info.rinfo->valid_bitmask |= mask;
d1426 1
d1433 1
a1433 1
        case UNINITIALIZED:
d1438 3
a1440 3
        case REGISTER:
        case SRAMLOC:
        case SCBLOC:
d1449 1
d1461 1
a1461 1
        case ALIAS:
d1471 8
a1478 6
        case MASK:
        case BIT:
		symbol->info.minfo =
		    (struct mask_info *)malloc(sizeof(struct mask_info));
		if (symbol->info.minfo == NULL) {
			stop("Can't create bitmask info", EX_SOFTWARE);
d1481 2
a1482 2
		memset(symbol->info.minfo, 0, sizeof(struct mask_info));
		SLIST_INIT(&(symbol->info.minfo->symrefs));
d1484 2
a1485 2
        case CONST:
        case DOWNLOAD_CONST:
a1666 1
			break;
a1674 1
cant_update:
d1677 1
d1847 4
a1850 2
	if(symbol->info.rinfo->typecheck_masks != FALSE) {
		SLIST_FOREACH(node, &expression->referenced_syms, links) {
d1852 4
a1855 2
			  || node->symbol->type == BIT)
			 && symlist_search(&node->symbol->info.minfo->symrefs,
d1858 1
a1858 1
					 "Invalid bit or mask %s "
d1915 15
a1929 12
        const char prefix[] = " * ";
        int newlen;
        int oldlen;

        newlen = strlen(verstring) + strlen(prefix);
        oldlen = 0;
        if (versions != NULL)
                oldlen = strlen(versions);
        versions = realloc(versions, newlen + oldlen + 2);
        if (versions == NULL)
                stop("Can't allocate version string", EX_SOFTWARE);
	snprintf(&versions[oldlen], newlen + 2, "%s%s\n", prefix, verstring);
d1941 2
a1942 4
	if (SLIST_EMPTY(&immed->referenced_syms))
		return (FALSE);
	if (SLIST_FIRST(&immed->referenced_syms)->symbol->type ==
	    DOWNLOAD_CONST)
d1944 1
@


1.9
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1830 1
a1830 4
        strcpy(&versions[oldlen], prefix);
        strcpy(&versions[oldlen + strlen(prefix)], verstring);
        versions[newlen + oldlen] = '\n';
        versions[newlen + oldlen + 1] = '\0';
@


1.8
log
@New aicasm synced with FreeBSD.
@
text
@d1756 1
a1756 3
		for(node = expression->referenced_syms.slh_first;
		    node != NULL;
		    node = node->links.sle_next) {
d1845 4
a1848 2
	if ((immed->referenced_syms.slh_first != NULL)
	 && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))
a1849 1

@


1.7
log
@Return of new ahc
@
text
@d6 1
d15 8
a22 2
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d25 2
a26 1
 * GNU Public License ("GPL").
d28 6
a33 5
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d36 4
a39 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.15 2001/07/18 21:03:32 gibbs Exp $
d44 4
a52 1
#include <sys/types.h>
d61 1
d63 2
d66 1
d68 2
a69 1
static symbol_t *accumulator;
d75 1
d82 2
d85 6
a90 6
static void format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
			   symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
			   symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src, expression_t *immed,
			   symbol_ref_t *address);
d96 1
a96 1
static void add_version(const char *);
a98 1
#define YYDEBUG 1
d104 1
a104 1
	int		value;
d115 2
d127 4
d135 8
d155 1
a155 1
%token <str> T_PATH T_STRING
d159 1
a159 1
%token T_EOF T_INCLUDE T_VERSION
d183 1
a183 1
%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX
d197 1
a197 1
%type <value> ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
d199 1
a199 1
%type <value> numerical_value
d203 1
d205 1
d213 2
d221 2
d229 4
d254 12
d322 1
d327 1
d345 12
d367 48
d446 1
a446 1
		if (accumulator != NULL) {
d451 13
a463 1
		accumulator = cur_symbol;
d544 28
d615 1
a615 3
			char buf[255];

			snprintf(buf, sizeof(buf),
d618 1
a618 1
			stop(buf, EX_DATAERR);
a638 1
		$2->info.cinfo->define = $1;
d655 48
a702 1
		$2->info.cinfo->define = FALSE;
d720 2
a723 5
			if (cur_symbol->type != UNINITIALIZED) {
				stop("Only one SRAM definition allowed",
				     EX_DATAERR);
				/* NOTREACHED */
			}
d731 5
a735 1
		scb_or_sram_reg_list
d739 1
d762 5
a766 1
		scb_or_sram_reg_list
d770 1
d774 7
d821 1
a821 1
		if (accumulator == NULL) {
d825 1
a825 1
		$$.symbol = accumulator;
d846 8
d886 14
d901 2
a902 2
        T_BEGIN_CS
        {
d916 2
a917 2
        T_END_CS
        {
d929 6
d936 1
a936 1
	T_SYMBOL ':'
d938 1
a938 1
		if ($1->type != UNINITIALIZED) {
d942 4
a945 3
		$1->type = LABEL;
		initialize_symbol($1);
		$1->info.linfo->address = instruction_ptr;
d1295 1
a1295 4
process_bitmask(mask_type, sym, mask)
	int		mask_type;
	symbol_t	*sym;
	int		mask;
d1340 1
a1340 2
initialize_symbol(symbol)
	symbol_t *symbol;
d1359 10
d1422 11
d1442 52
a1493 2
process_register(p_symbol)
	symbol_t **p_symbol;
a1494 1
	char buf[255];
d1498 1
a1498 1
		snprintf(buf, sizeof(buf), "Undefined register %s",
d1500 1
a1500 1
		stop(buf, EX_DATAERR);
d1507 1
a1507 1
		snprintf(buf, sizeof(buf),
d1510 1
a1510 1
		stop(buf, EX_DATAERR);
d1515 2
a1516 6
format_1_instr(opcode, dest, immed, src, ret)
	int	     opcode;
	symbol_ref_t *dest;
	expression_t *immed;
	symbol_ref_t *src;
	int	     ret;
d1544 41
d1591 2
a1592 6
format_2_instr(opcode, dest, places, src, ret)
	int	     opcode;
	symbol_ref_t *dest;
	expression_t *places;
	symbol_ref_t *src;
	int	     ret;
d1596 1
a1596 1
	u_int8_t shift_control;
d1652 2
a1653 5
format_3_instr(opcode, src, immed, address)
	int	     opcode;
	symbol_ref_t *src;
	expression_t *immed;
	symbol_ref_t *address;
d1691 1
a1691 2
test_readable_symbol(symbol)
	symbol_t *symbol;
d1693 8
d1709 1
a1709 2
test_writable_symbol(symbol)
	symbol_t *symbol;
d1711 8
d1727 1
a1727 4
type_check(symbol, expression, opcode)
	symbol_t     *symbol;
	expression_t *expression;
	int	     opcode;
a1730 1
	char buf[255];
d1743 1
a1743 1
		snprintf(buf, sizeof(buf),
d1747 1
a1747 1
		stop(buf, EX_DATAERR);
d1763 1
a1763 1
				snprintf(buf, sizeof(buf),
d1767 1
a1767 1
				stop(buf, EX_DATAERR);
d1775 1
a1775 3
make_expression(immed, value)
	expression_t *immed;
	int	     value;
d1782 1
a1782 2
add_conditional(symbol)
	symbol_t *symbol;
d1819 1
a1819 2
add_version(verstring)
const char *verstring;
d1839 1
a1839 2
yyerror(string)
	const char *string;
d1845 1
a1845 2
is_download_const(immed)
	expression_t *immed;
@


1.6
log
@remove __P
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_gram.y,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d49 1
d60 1
d76 1
d112 4
d122 1
a122 1
%token <str> T_PATH
d126 1
a126 1
%token T_EOF T_INCLUDE 
d140 1
a140 1
%token <value> T_CMP T_XOR
d178 2
d190 4
d202 3
a204 1
	{ include_file($3, BRACKETED_INCLUDE); }
d206 8
a213 1
	{ include_file($3, QUOTED_INCLUDE); }
d552 2
d578 15
d663 29
a802 1
		scope_t *last_scope;
d908 2
a909 2
		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &$2, &immed, &$4, $5);
d917 10
d1469 21
@


1.5
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d57 15
a71 18
static void process_bitmask __P((int mask_type, symbol_t *sym, int mask));
static void initialize_symbol __P((symbol_t *symbol));
static void process_register __P((symbol_t **p_symbol));
static void format_1_instr __P((int opcode, symbol_ref_t *dest,
				expression_t *immed, symbol_ref_t *src,
				int ret));
static void format_2_instr __P((int opcode, symbol_ref_t *dest,
				expression_t *places, symbol_ref_t *src,
				int ret));
static void format_3_instr __P((int opcode, symbol_ref_t *src,
				expression_t *immed, symbol_ref_t *address));
static void test_readable_symbol __P((symbol_t *symbol));
static void test_writable_symbol __P((symbol_t *symbol));
static void type_check __P((symbol_t *symbol, expression_t *expression,
			    int and_op));
static void make_expression __P((expression_t *immed, int value));
static void add_conditional __P((symbol_t *symbol));
static int  is_download_const __P((expression_t *immed));
@


1.4
log
@First round of __P removal in sys
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.15 2001/07/18 21:03:32 gibbs Exp $
d42 1
a42 1
#include "aicasm_insformat.h"
a45 1
char *versions;
a55 1
static int in_critical_section;
d57 4
a60 4
static void process_bitmask(int mask_type, symbol_t *sym, int mask);
static void initialize_symbol(symbol_t *symbol);
static void process_register(symbol_t **p_symbol);
static void format_1_instr(int opcode, symbol_ref_t *dest,
d62 2
a63 2
				int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest,
d65 10
a74 11
				int ret);
static void format_3_instr(int opcode, symbol_ref_t *src,
				expression_t *immed, symbol_ref_t *address);
static void test_readable_symbol(symbol_t *symbol);
static void test_writable_symbol(symbol_t *symbol);
static void type_check(symbol_t *symbol, expression_t *expression,
			    int and_op);
static void make_expression(expression_t *immed, int value);
static void add_conditional(symbol_t *symbol);
static void add_version(const char *);
static int  is_download_const(expression_t *immed);
a108 4
%token T_BEGIN_CS

%token T_END_CS

d115 1
a115 1
%token <str> T_PATH T_STRING
d119 1
a119 1
%token T_EOF T_INCLUDE T_VERSION
d133 1
a133 1
%token <value> T_CMP T_NOT T_XOR
a170 2
|       version
|       program version
a180 4
|       critical_section_start
|       program critical_section_start
|       critical_section_end
|       program critical_section_end
d189 1
a189 3
        {
                include_file($3, BRACKETED_INCLUDE);
        }
d191 1
a191 8
        {
                include_file($3, QUOTED_INCLUDE);
        }
;

version:
        T_VERSION '=' T_STRING
        { add_version($3); }
a529 2
                        /* 64 bytes of SCB space */
                        cur_symbol->info.rinfo->size = 64;
a553 15
|       T_SYMBOL '[' T_SYMBOL ']'
        {
                process_register(&$1);
                if ($3->type != CONST) {
                        stop("register offset must be a constant", EX_DATAERR);
                        /* NOTREACHED */
                }
                if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
                        stop("Accessing offset beyond range of register",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                $$.symbol = $1;
                $$.offset = $3->info.cinfo->value;
        }
a623 29
critical_section_start:
        T_BEGIN_CS
        {
                critical_section_t *cs;

                if (in_critical_section != FALSE) {
                        stop("Critical Section within Critical Section",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = cs_alloc();
                cs->begin_addr = instruction_ptr;
                in_critical_section = TRUE;
        }

critical_section_end:
        T_END_CS
        {
                critical_section_t *cs;

                if (in_critical_section == FALSE) {
                        stop("Unballanced 'end_cs'", EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = TAILQ_LAST(&cs_tailq, cs_tailq);
                cs->end_addr = instruction_ptr;
                in_critical_section = FALSE;
        }

d735 1
d841 2
a842 2
                make_expression(&immed, 1);
                format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
a849 10
        }
;

code:
        T_NOT destination opt_source ret ';'
        {
                expression_t immed;

                make_expression(&immed, 0xff);
                format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
a1391 21
}

static void
add_version(verstring)
const char *verstring;
{
        const char prefix[] = " * ";
        int newlen;
        int oldlen;

        newlen = strlen(verstring) + strlen(prefix);
        oldlen = 0;
        if (versions != NULL)
                oldlen = strlen(versions);
        versions = realloc(versions, newlen + oldlen + 2);
        if (versions == NULL)
                stop("Can't allocate version string", EX_SOFTWARE);
        strcpy(&versions[oldlen], prefix);
        strcpy(&versions[oldlen + strlen(prefix)], verstring);
        versions[newlen + oldlen] = '\n';
        versions[newlen + oldlen + 1] = '\0';
@


1.3
log
@change to reflect the removal of sequencer.h
@
text
@d62 4
a65 4
static void process_bitmask __P((int mask_type, symbol_t *sym, int mask));
static void initialize_symbol __P((symbol_t *symbol));
static void process_register __P((symbol_t **p_symbol));
static void format_1_instr __P((int opcode, symbol_ref_t *dest,
d67 2
a68 2
				int ret));
static void format_2_instr __P((int opcode, symbol_ref_t *dest,
d70 11
a80 11
				int ret));
static void format_3_instr __P((int opcode, symbol_ref_t *src,
				expression_t *immed, symbol_ref_t *address));
static void test_readable_symbol __P((symbol_t *symbol));
static void test_writable_symbol __P((symbol_t *symbol));
static void type_check __P((symbol_t *symbol, expression_t *expression,
			    int and_op));
static void make_expression __P((expression_t *immed, int value));
static void add_conditional __P((symbol_t *symbol));
static void add_version __P((const char *));
static int  is_download_const __P((expression_t *immed));
@


1.2
log
@New port of FreeBSD's ahc driver
@
text
@d45 1
a45 1
#include "sequencer.h"
@


1.1
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_gram.y,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d49 1
d60 1
d79 1
d115 4
d125 1
a125 1
%token <str> T_PATH
d129 1
a129 1
%token T_EOF T_INCLUDE 
d143 1
a143 1
%token <value> T_CMP T_XOR
d181 2
d193 4
d205 3
a207 1
	{ include_file($3, BRACKETED_INCLUDE); }
d209 8
a216 1
	{ include_file($3, QUOTED_INCLUDE); }
d555 2
d581 15
d666 29
a805 1
		scope_t *last_scope;
d911 2
a912 2
		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &$2, &immed, &$4, $5);
d920 10
d1472 21
@


1.1.12.1
log
@Sync UBC branch to -current
@
text
@d57 18
a74 15
static void process_bitmask(int mask_type, symbol_t *sym, int mask);
static void initialize_symbol(symbol_t *symbol);
static void process_register(symbol_t **p_symbol);
static void format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
			   symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
			   symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src, expression_t *immed,
			   symbol_ref_t *address);
static void test_readable_symbol(symbol_t *symbol);
static void test_writable_symbol(symbol_t *symbol);
static void type_check(symbol_t *symbol, expression_t *expression, int and_op);
static void make_expression(expression_t *immed, int value);
static void add_conditional(symbol_t *symbol);
static int  is_download_const(expression_t *immed);
@


1.1.12.2
log
@sync to -current
@
text
@d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.17 2002/06/05 22:51:54 gibbs Exp $
a31 4
#include <sys/types.h>

#include <inttypes.h>
#include <regex.h>
d37 1
a45 4
char *patch_arg_list;
char *versions;
static char errbuf[255];
static char regex_pattern[255];
a46 1
static symbol_t *scb_or_sram_symbol;
d48 1
a48 2
static symbol_ref_t accumulator;
static symbol_ref_t mode_ptr;
a53 1
static int num_srams;
a55 1
static int in_critical_section;
a58 2
static void add_macro_arg(const char *argtext, int position);
static void add_macro_body(const char *bodytext);
d60 6
a65 6
static void format_1_instr(int opcode, symbol_ref_t *dest,
			   expression_t *immed, symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest,
			   expression_t *places, symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src,
			   expression_t *immed, symbol_ref_t *address);
a70 1
static void add_version(const char *verstring);
d73 1
d79 1
a79 1
	u_int		value;
a89 2
%token T_EXPORT

a99 4
%token T_EXPR_LSHIFT

%token T_EXPR_RSHIFT

a103 8
%token T_MODES

%token T_DEFINE

%token T_SET_SRC_MODE

%token T_SET_DST_MODE

a105 4
%token T_BEGIN_CS

%token T_END_CS

d112 1
a112 1
%token <str> T_PATH T_STRING T_ARG T_MACROBODY
d116 1
a116 1
%token T_EOF T_INCLUDE T_VERSION T_PATCH_ARG_LIST
d130 1
a130 1
%token <value> T_CMP T_NOT T_XOR
d140 1
a140 1
%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX T_MODE_PTR
d154 1
a154 1
%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
d156 1
a156 1
%type <value> numerical_value mode_value mode_list macro_arglist
a159 1
%left T_EXPR_LSHIFT T_EXPR_RSHIFT
a160 1
%left '*' '/'
a167 4
|	patch_arg_list
|	program patch_arg_list
|       version
|       program version
a171 2
|	macrodefn
|	program macrodefn
a177 8
|	set_src_mode
|	program set_src_mode
|	set_dst_mode
|	program set_dst_mode
|       critical_section_start
|       program critical_section_start
|       critical_section_end
|       program critical_section_end
d186 1
a186 3
        {
                include_file($3, BRACKETED_INCLUDE);
        }
d188 1
a188 20
        {
                include_file($3, QUOTED_INCLUDE);
        }
;

patch_arg_list:
	T_PATCH_ARG_LIST '=' T_STRING
	{
		if (patch_arg_list != NULL)
			stop("Patch argument list multiply defined",
			     EX_DATAERR);
		patch_arg_list = strdup($3);
		if (patch_arg_list == NULL)
			stop("Unable to record patch arg list", EX_SOFTWARE);
	}
;

version:
        T_VERSION '=' T_STRING
        { add_version($3); }
a241 1
|	modes
a245 1
|	mode_pointer
a262 12
		if (scb_or_sram_symbol != NULL) {
			u_int max_addr;
			u_int sym_max_addr;

			max_addr = scb_or_sram_symbol->info.rinfo->address
				 + scb_or_sram_symbol->info.rinfo->size;
			sym_max_addr = cur_symbol->info.rinfo->address
				     + cur_symbol->info.rinfo->size;

			if (sym_max_addr > max_addr)
				stop("SCB or SRAM space exhausted", EX_DATAERR);
		}
a272 48
modes:
	T_MODES mode_list
	{
		cur_symbol->info.rinfo->modes = $2;
	}
;

mode_list:
	mode_value
	{
		$$ = $1;
	}
|	mode_list ',' mode_value
	{
		$$ = $1 | $3;
	}
;

mode_value:
	T_NUMBER
	{
		if ($1 > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}

		$$ = (0x1 << $1);
	}
|	T_SYMBOL
	{
		symbol_t *symbol;

		symbol = $1;
		if (symbol->type != CONST) {
			stop("Only \"const\" symbols allowed in "
			     "mode definitions.", EX_DATAERR);
			/* NOTREACHED */
		}
		if (symbol->info.cinfo->value > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = (0x1 << symbol->info.cinfo->value);
	}
;

d304 1
a304 1
		if (accumulator.symbol != NULL) {
d309 1
a309 13
		accumulator.symbol = cur_symbol;
	}
;

mode_pointer:
	T_MODE_PTR
	{
		if (mode_ptr.symbol != NULL) {
			stop("Only one mode pointer definition allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		mode_ptr.symbol = cur_symbol;
a389 28
|	expression '*' expression
	{
		$$.value = $1.value * $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
|	expression '/' expression
	{
		$$.value = $1.value / $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
| 	expression T_EXPR_LSHIFT expression
	{
		$$.value = $1.value << $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
| 	expression T_EXPR_RSHIFT expression
	{
		$$.value = $1.value >> $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
d433 3
a435 1
			snprintf(errbuf, sizeof(errbuf),
d438 1
a438 1
			stop(errbuf, EX_DATAERR);
d459 1
d476 1
a476 48
	}
;

macrodefn_prologue:
	T_DEFINE T_SYMBOL
	{
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of symbol as a macro",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		cur_symbol = $2;
		cur_symbol->type = MACRO;
		initialize_symbol(cur_symbol);
	}
;

macrodefn:
	macrodefn_prologue T_MACROBODY
	{
		add_macro_body($2);
	}
|	macrodefn_prologue '(' macro_arglist ')' T_MACROBODY
	{
		add_macro_body($5);
		cur_symbol->info.macroinfo->narg = $3;
	}
;

macro_arglist:
	{
		/* Macros can take no arguments */
		$$ = 0;
	}
|	T_ARG
	{
		$$ = 1;
		add_macro_arg($1, 0);
	}
|	macro_arglist ',' T_ARG
	{
		if ($1 == 0) {
			stop("Comma without preceeding argument in arg list",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = $1 + 1;
		add_macro_arg($3, $1);
a493 2
			snprintf(errbuf, sizeof(errbuf), "%s%d", SRAM_SYMNAME,
				 num_srams);
d496 5
d508 1
a508 5
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
a511 1
			scb_or_sram_symbol = NULL;
a526 2
                        /* 64 bytes of SCB space */
                        cur_symbol->info.rinfo->size = 64;
d532 1
a532 5
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
a535 1
			scb_or_sram_symbol = NULL;
a538 7
scb_or_sram_attributes:
	/* NULL definition is okay */
|	modes
|	scb_or_sram_reg_list
|	modes scb_or_sram_reg_list
;

a550 15
|       T_SYMBOL '[' T_SYMBOL ']'
        {
                process_register(&$1);
                if ($3->type != CONST) {
                        stop("register offset must be a constant", EX_DATAERR);
                        /* NOTREACHED */
                }
                if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
                        stop("Accessing offset beyond range of register",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                $$.symbol = $1;
                $$.offset = $3->info.cinfo->value;
        }
d564 1
a564 1
		if (accumulator.symbol == NULL) {
d568 1
a568 1
		$$.symbol = accumulator.symbol;
a588 8
		if ($1.value == 0 && is_download_const(&$1) == 0) {
			snprintf(errbuf, sizeof(errbuf),
				 "\nExpression evaluates to 0 and thus "
				 "references the accumulator.\n "
				 "If this is the desired effect, use 'A' "
				 "instead.\n");
			stop(errbuf, EX_DATAERR);
		}
a620 49
set_src_mode:
	T_SET_SRC_MODE T_NUMBER ';'
	{
		src_mode = $2;
	}
;

set_dst_mode:
	T_SET_DST_MODE T_NUMBER ';'
	{
		dst_mode = $2;
	}
;

critical_section_start:
	T_BEGIN_CS ';'
	{
                critical_section_t *cs;

                if (in_critical_section != FALSE) {
                        stop("Critical Section within Critical Section",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = cs_alloc();
                cs->begin_addr = instruction_ptr;
                in_critical_section = TRUE;
        }

critical_section_end:
	T_END_CS ';'
	{
                critical_section_t *cs;

                if (in_critical_section == FALSE) {
                        stop("Unballanced 'end_cs'", EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = TAILQ_LAST(&cs_tailq, cs_tailq);
                cs->end_addr = instruction_ptr;
                in_critical_section = FALSE;
        }

export:
	{ $$ = 0; }
|	T_EXPORT
	{ $$ = 1; }
;

d622 1
a622 1
	export T_SYMBOL ':'
d624 1
a624 1
		if ($2->type != UNINITIALIZED) {
d628 3
a630 4
		$2->type = LABEL;
		initialize_symbol($2);
		$2->info.linfo->address = instruction_ptr;
		$2->info.linfo->exported = $1;
d732 1
d838 2
a839 2
                make_expression(&immed, 1);
                format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
a846 10
        }
;

code:
        T_NOT destination opt_source ret ';'
        {
                expression_t immed;

                make_expression(&immed, 0xff);
                format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
d971 4
a974 1
process_bitmask(int mask_type, symbol_t *sym, int mask)
d1019 2
a1020 1
initialize_symbol(symbol_t *symbol)
a1038 10
		/*
		 * Default to allowing access in all register modes
		 * or to the mode specified by the SCB or SRAM space
		 * we are in.
		 */
		if (scb_or_sram_symbol != NULL)
			symbol->info.rinfo->modes =
			    scb_or_sram_symbol->info.rinfo->modes;
		else
			symbol->info.rinfo->modes = ~0;
a1091 11
	case MACRO:
		symbol->info.macroinfo = 
		    (struct macro_info *)malloc(sizeof(struct macro_info));
		if (symbol->info.macroinfo == NULL) {
			stop("Can't create macro info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.macroinfo, 0,
		       sizeof(struct macro_info));
		TAILQ_INIT(&symbol->info.macroinfo->args);
		break;
d1101 2
a1102 52
add_macro_arg(const char *argtext, int argnum)
{
	struct macro_arg *marg;
	int i;
	int retval;
		

	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}

	marg = (struct macro_arg *)malloc(sizeof(*marg));
	if (marg == NULL) {
		stop("Can't create macro_arg structure", EX_SOFTWARE);
		/* NOTREACHED */
	}
	marg->replacement_text = NULL;
	retval = snprintf(regex_pattern, sizeof(regex_pattern),
			  "[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)",
			  argtext);
	if (retval >= sizeof(regex_pattern)) {
		stop("Regex text buffer too small for arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	retval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);
	if (retval != 0) {
		stop("Regex compilation failed", EX_SOFTWARE);
		/* NOTREACHED */
	}
	TAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);
}

static void
add_macro_body(const char *bodytext)
{
	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	cur_symbol->info.macroinfo->body = strdup(bodytext);
	if (cur_symbol->info.macroinfo->body == NULL) {
		stop("Can't duplicate macro body text", EX_SOFTWARE);
		/* NOTREACHED */
	}
}

static void
process_register(symbol_t **p_symbol)
d1104 1
d1108 1
a1108 1
		snprintf(errbuf, sizeof(errbuf), "Undefined register %s",
d1110 1
a1110 1
		stop(errbuf, EX_DATAERR);
d1117 1
a1117 1
		snprintf(errbuf, sizeof(errbuf),
d1120 1
a1120 1
		stop(errbuf, EX_DATAERR);
d1125 6
a1130 2
format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
	       symbol_ref_t *src, int ret)
a1157 41
	else if (dest->symbol == mode_ptr.symbol) {
		u_int src_value;
		u_int dst_value;

		/*
		 * Attempt to update mode information if
		 * we are operating on the mode register.
		 */
		if (src->symbol == allones.symbol)
			src_value = 0xFF;
		else if (src->symbol == allzeros.symbol)
			src_value = 0;
		else if (src->symbol == mode_ptr.symbol)
			src_value = (dst_mode << 4) | src_mode;
		else
			goto cant_update;

		switch (opcode) {
		case AIC_OP_AND:
			dst_value = src_value & immed->value;
			break;
		case AIC_OP_XOR:
			dst_value = src_value ^ immed->value;
			break;
		case AIC_OP_ADD:
			dst_value = (src_value + immed->value) & 0xFF;
			break;
		case AIC_OP_OR:
			dst_value = src_value | immed->value;
			break;
			break;
		case AIC_OP_BMOV:
			dst_value = src_value;
			break;
		default:
			goto cant_update;
		}
		src_mode = dst_value & 0xF;
		dst_mode = (dst_value >> 4) & 0xF;
cant_update:
	}
d1164 6
a1169 2
format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
	       symbol_ref_t *src, int ret)
d1173 1
a1173 1
	uint8_t shift_control;
d1229 5
a1233 2
format_3_instr(int opcode, symbol_ref_t *src,
	       expression_t *immed, symbol_ref_t *address)
d1271 2
a1272 1
test_readable_symbol(symbol_t *symbol)
a1273 8
	
	if ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in source reg mode %d",
			symbol->name, src_mode);
		stop(errbuf, EX_DATAERR);
	}

d1282 2
a1283 1
test_writable_symbol(symbol_t *symbol)
a1284 8
	
	if ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in destination reg mode %d",
			symbol->name, dst_mode);
		stop(errbuf, EX_DATAERR);
	}

d1293 4
a1296 1
type_check(symbol_t *symbol, expression_t *expression, int opcode)
d1300 1
d1313 1
a1313 1
		snprintf(errbuf, sizeof(errbuf),
d1317 1
a1317 1
		stop(errbuf, EX_DATAERR);
d1333 1
a1333 1
				snprintf(errbuf, sizeof(errbuf),
d1337 1
a1337 1
				stop(errbuf, EX_DATAERR);
d1345 3
a1347 1
make_expression(expression_t *immed, int value)
d1354 2
a1355 1
add_conditional(symbol_t *symbol)
a1390 20
static void
add_version(const char *verstring)
{
        const char prefix[] = " * ";
        int newlen;
        int oldlen;

        newlen = strlen(verstring) + strlen(prefix);
        oldlen = 0;
        if (versions != NULL)
                oldlen = strlen(versions);
        versions = realloc(versions, newlen + oldlen + 2);
        if (versions == NULL)
                stop("Can't allocate version string", EX_SOFTWARE);
        strcpy(&versions[oldlen], prefix);
        strcpy(&versions[oldlen + strlen(prefix)], verstring);
        versions[newlen + oldlen] = '\n';
        versions[newlen + oldlen + 1] = '\0';
}

d1392 2
a1393 1
yyerror(const char *string)
d1399 2
a1400 1
is_download_const(expression_t *immed)
@


1.1.12.3
log
@sync
@
text
@d1756 3
a1758 1
		SLIST_FOREACH(node, &expression->referenced_syms, links) {
d1832 4
a1835 1
	snprintf(&versions[oldlen], newlen + 2, "%s%s\n", prefix, verstring);
d1847 2
a1848 4
	if (SLIST_EMPTY(&immed->referenced_syms))
		return (FALSE);
	if (SLIST_FIRST(&immed->referenced_syms)->symbol->type ==
	    DOWNLOAD_CONST)
d1850 1
@


1.1.2.1
log
@Sync with -current
@
text
@@


1.1.2.2
log
@Merge in trunk
@
text
@d5 1
a5 1
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
a16 3
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.15 2001/07/18 21:03:32 gibbs Exp $
d42 1
a42 1
#include "aicasm_insformat.h"
a45 1
char *versions;
a55 1
static int in_critical_section;
a73 1
static void add_version __P((const char *));
a108 4
%token T_BEGIN_CS

%token T_END_CS

d115 1
a115 1
%token <str> T_PATH T_STRING
d119 1
a119 1
%token T_EOF T_INCLUDE T_VERSION
d133 1
a133 1
%token <value> T_CMP T_NOT T_XOR
a170 2
|       version
|       program version
a180 4
|       critical_section_start
|       program critical_section_start
|       critical_section_end
|       program critical_section_end
d189 1
a189 3
        {
                include_file($3, BRACKETED_INCLUDE);
        }
d191 1
a191 8
        {
                include_file($3, QUOTED_INCLUDE);
        }
;

version:
        T_VERSION '=' T_STRING
        { add_version($3); }
a529 2
                        /* 64 bytes of SCB space */
                        cur_symbol->info.rinfo->size = 64;
a553 15
|       T_SYMBOL '[' T_SYMBOL ']'
        {
                process_register(&$1);
                if ($3->type != CONST) {
                        stop("register offset must be a constant", EX_DATAERR);
                        /* NOTREACHED */
                }
                if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
                        stop("Accessing offset beyond range of register",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                $$.symbol = $1;
                $$.offset = $3->info.cinfo->value;
        }
a623 29
critical_section_start:
        T_BEGIN_CS
        {
                critical_section_t *cs;

                if (in_critical_section != FALSE) {
                        stop("Critical Section within Critical Section",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = cs_alloc();
                cs->begin_addr = instruction_ptr;
                in_critical_section = TRUE;
        }

critical_section_end:
        T_END_CS
        {
                critical_section_t *cs;

                if (in_critical_section == FALSE) {
                        stop("Unballanced 'end_cs'", EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = TAILQ_LAST(&cs_tailq, cs_tailq);
                cs->end_addr = instruction_ptr;
                in_critical_section = FALSE;
        }

d735 1
d841 2
a842 2
                make_expression(&immed, 1);
                format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
a849 10
        }
;

code:
        T_NOT destination opt_source ret ';'
        {
                expression_t immed;

                make_expression(&immed, 0xff);
                format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
a1391 21
}

static void
add_version(verstring)
const char *verstring;
{
        const char prefix[] = " * ";
        int newlen;
        int oldlen;

        newlen = strlen(verstring) + strlen(prefix);
        oldlen = 0;
        if (versions != NULL)
                oldlen = strlen(versions);
        versions = realloc(versions, newlen + oldlen + 2);
        if (versions == NULL)
                stop("Can't allocate version string", EX_SOFTWARE);
        strcpy(&versions[oldlen], prefix);
        strcpy(&versions[oldlen + strlen(prefix)], verstring);
        versions[newlen + oldlen] = '\n';
        versions[newlen + oldlen + 1] = '\0';
@


1.1.2.3
log
@Merge in -current from about a week ago
@
text
@d5 1
a5 1
 * Copyright (c) 1997-1998 Justin T. Gibbs.
d17 3
d32 1
a32 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm_gram.y,v 1.8 1999/12/06 18:23:30 gibbs Exp $
d45 1
a45 1
#include "sequencer.h"
d49 1
d60 1
d62 19
a80 15
static void process_bitmask(int mask_type, symbol_t *sym, int mask);
static void initialize_symbol(symbol_t *symbol);
static void process_register(symbol_t **p_symbol);
static void format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
			   symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
			   symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src, expression_t *immed,
			   symbol_ref_t *address);
static void test_readable_symbol(symbol_t *symbol);
static void test_writable_symbol(symbol_t *symbol);
static void type_check(symbol_t *symbol, expression_t *expression, int and_op);
static void make_expression(expression_t *immed, int value);
static void add_conditional(symbol_t *symbol);
static int  is_download_const(expression_t *immed);
d115 4
d125 1
a125 1
%token <str> T_PATH
d129 1
a129 1
%token T_EOF T_INCLUDE 
d143 1
a143 1
%token <value> T_CMP T_XOR
d181 2
d193 4
d205 3
a207 1
	{ include_file($3, BRACKETED_INCLUDE); }
d209 8
a216 1
	{ include_file($3, QUOTED_INCLUDE); }
d555 2
d581 15
d666 29
a805 1
		scope_t *last_scope;
d911 2
a912 2
		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_AND, &$2, &immed, &$4, $5);
d920 10
d1472 21
@


1.1.2.4
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a5 2
 * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
 * Copyright (c) 2001 Adaptec Inc.
d14 2
a15 8
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    substantially similar to the "NO WARRANTY" disclaimer below
 *    ("Disclaimer") and any redistribution must be conditioned upon
 *    including a substantially similar Disclaimer requirement for further
 *    binary redistribution.
 * 3. Neither the names of the above-listed copyright holders nor the names
 *    of any contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d17 5
a21 10
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
d24 4
a27 4
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
d29 1
a29 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.17 2002/06/05 22:51:54 gibbs Exp $
a31 4
#include <sys/types.h>

#include <inttypes.h>
#include <regex.h>
d37 1
a45 4
char *patch_arg_list;
char *versions;
static char errbuf[255];
static char regex_pattern[255];
a46 1
static symbol_t *scb_or_sram_symbol;
d48 1
a48 2
static symbol_ref_t accumulator;
static symbol_ref_t mode_ptr;
a53 1
static int num_srams;
a55 1
static int in_critical_section;
a58 2
static void add_macro_arg(const char *argtext, int position);
static void add_macro_body(const char *bodytext);
d60 6
a65 6
static void format_1_instr(int opcode, symbol_ref_t *dest,
			   expression_t *immed, symbol_ref_t *src, int ret);
static void format_2_instr(int opcode, symbol_ref_t *dest,
			   expression_t *places, symbol_ref_t *src, int ret);
static void format_3_instr(int opcode, symbol_ref_t *src,
			   expression_t *immed, symbol_ref_t *address);
a70 1
static void add_version(const char *verstring);
d73 1
d79 1
a79 1
	u_int		value;
a89 2
%token T_EXPORT

a99 4
%token T_EXPR_LSHIFT

%token T_EXPR_RSHIFT

a103 8
%token T_MODES

%token T_DEFINE

%token T_SET_SRC_MODE

%token T_SET_DST_MODE

a105 4
%token T_BEGIN_CS

%token T_END_CS

d112 1
a112 1
%token <str> T_PATH T_STRING T_ARG T_MACROBODY
d116 1
a116 1
%token T_EOF T_INCLUDE T_VERSION T_PATCH_ARG_LIST
d130 1
a130 1
%token <value> T_CMP T_NOT T_XOR
d140 1
a140 1
%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX T_MODE_PTR
d154 1
a154 1
%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
d156 1
a156 1
%type <value> numerical_value mode_value mode_list macro_arglist
a159 1
%left T_EXPR_LSHIFT T_EXPR_RSHIFT
a160 1
%left '*' '/'
a167 4
|	patch_arg_list
|	program patch_arg_list
|       version
|       program version
a171 2
|	macrodefn
|	program macrodefn
a177 8
|	set_src_mode
|	program set_src_mode
|	set_dst_mode
|	program set_dst_mode
|       critical_section_start
|       program critical_section_start
|       critical_section_end
|       program critical_section_end
d186 1
a186 3
        {
                include_file($3, BRACKETED_INCLUDE);
        }
d188 1
a188 20
        {
                include_file($3, QUOTED_INCLUDE);
        }
;

patch_arg_list:
	T_PATCH_ARG_LIST '=' T_STRING
	{
		if (patch_arg_list != NULL)
			stop("Patch argument list multiply defined",
			     EX_DATAERR);
		patch_arg_list = strdup($3);
		if (patch_arg_list == NULL)
			stop("Unable to record patch arg list", EX_SOFTWARE);
	}
;

version:
        T_VERSION '=' T_STRING
        { add_version($3); }
a241 1
|	modes
a245 1
|	mode_pointer
a262 12
		if (scb_or_sram_symbol != NULL) {
			u_int max_addr;
			u_int sym_max_addr;

			max_addr = scb_or_sram_symbol->info.rinfo->address
				 + scb_or_sram_symbol->info.rinfo->size;
			sym_max_addr = cur_symbol->info.rinfo->address
				     + cur_symbol->info.rinfo->size;

			if (sym_max_addr > max_addr)
				stop("SCB or SRAM space exhausted", EX_DATAERR);
		}
a272 48
modes:
	T_MODES mode_list
	{
		cur_symbol->info.rinfo->modes = $2;
	}
;

mode_list:
	mode_value
	{
		$$ = $1;
	}
|	mode_list ',' mode_value
	{
		$$ = $1 | $3;
	}
;

mode_value:
	T_NUMBER
	{
		if ($1 > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}

		$$ = (0x1 << $1);
	}
|	T_SYMBOL
	{
		symbol_t *symbol;

		symbol = $1;
		if (symbol->type != CONST) {
			stop("Only \"const\" symbols allowed in "
			     "mode definitions.", EX_DATAERR);
			/* NOTREACHED */
		}
		if (symbol->info.cinfo->value > 4) {
			stop("Valid register modes range between 0 and 4.",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = (0x1 << symbol->info.cinfo->value);
	}
;

d304 1
a304 1
		if (accumulator.symbol != NULL) {
d309 1
a309 13
		accumulator.symbol = cur_symbol;
	}
;

mode_pointer:
	T_MODE_PTR
	{
		if (mode_ptr.symbol != NULL) {
			stop("Only one mode pointer definition allowed",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		mode_ptr.symbol = cur_symbol;
a389 28
|	expression '*' expression
	{
		$$.value = $1.value * $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
|	expression '/' expression
	{
		$$.value = $1.value / $3.value;
		symlist_merge(&($$.referenced_syms),
			       &($1.referenced_syms),
			       &($3.referenced_syms));
	}
| 	expression T_EXPR_LSHIFT expression
	{
		$$.value = $1.value << $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
| 	expression T_EXPR_RSHIFT expression
	{
		$$.value = $1.value >> $3.value;
		symlist_merge(&$$.referenced_syms,
			       &$1.referenced_syms,
			       &$3.referenced_syms);
	}
d433 3
a435 1
			snprintf(errbuf, sizeof(errbuf),
d438 1
a438 1
			stop(errbuf, EX_DATAERR);
d459 1
d476 1
a476 48
	}
;

macrodefn_prologue:
	T_DEFINE T_SYMBOL
	{
		if ($2->type != UNINITIALIZED) {
			stop("Re-definition of symbol as a macro",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		cur_symbol = $2;
		cur_symbol->type = MACRO;
		initialize_symbol(cur_symbol);
	}
;

macrodefn:
	macrodefn_prologue T_MACROBODY
	{
		add_macro_body($2);
	}
|	macrodefn_prologue '(' macro_arglist ')' T_MACROBODY
	{
		add_macro_body($5);
		cur_symbol->info.macroinfo->narg = $3;
	}
;

macro_arglist:
	{
		/* Macros can take no arguments */
		$$ = 0;
	}
|	T_ARG
	{
		$$ = 1;
		add_macro_arg($1, 0);
	}
|	macro_arglist ',' T_ARG
	{
		if ($1 == 0) {
			stop("Comma without preceeding argument in arg list",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$ = $1 + 1;
		add_macro_arg($3, $1);
a493 2
			snprintf(errbuf, sizeof(errbuf), "%s%d", SRAM_SYMNAME,
				 num_srams);
d496 5
d508 1
a508 5
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
a511 1
			scb_or_sram_symbol = NULL;
a526 2
                        /* 64 bytes of SCB space */
                        cur_symbol->info.rinfo->size = 64;
d532 1
a532 5
		size
		{
			scb_or_sram_symbol = cur_symbol;
		}
		scb_or_sram_attributes
a535 1
			scb_or_sram_symbol = NULL;
a538 7
scb_or_sram_attributes:
	/* NULL definition is okay */
|	modes
|	scb_or_sram_reg_list
|	modes scb_or_sram_reg_list
;

a550 15
|       T_SYMBOL '[' T_SYMBOL ']'
        {
                process_register(&$1);
                if ($3->type != CONST) {
                        stop("register offset must be a constant", EX_DATAERR);
                        /* NOTREACHED */
                }
                if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
                        stop("Accessing offset beyond range of register",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                $$.symbol = $1;
                $$.offset = $3->info.cinfo->value;
        }
d564 1
a564 1
		if (accumulator.symbol == NULL) {
d568 1
a568 1
		$$.symbol = accumulator.symbol;
a588 8
		if ($1.value == 0 && is_download_const(&$1) == 0) {
			snprintf(errbuf, sizeof(errbuf),
				 "\nExpression evaluates to 0 and thus "
				 "references the accumulator.\n "
				 "If this is the desired effect, use 'A' "
				 "instead.\n");
			stop(errbuf, EX_DATAERR);
		}
a620 49
set_src_mode:
	T_SET_SRC_MODE T_NUMBER ';'
	{
		src_mode = $2;
	}
;

set_dst_mode:
	T_SET_DST_MODE T_NUMBER ';'
	{
		dst_mode = $2;
	}
;

critical_section_start:
	T_BEGIN_CS ';'
	{
                critical_section_t *cs;

                if (in_critical_section != FALSE) {
                        stop("Critical Section within Critical Section",
                             EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = cs_alloc();
                cs->begin_addr = instruction_ptr;
                in_critical_section = TRUE;
        }

critical_section_end:
	T_END_CS ';'
	{
                critical_section_t *cs;

                if (in_critical_section == FALSE) {
                        stop("Unballanced 'end_cs'", EX_DATAERR);
                        /* NOTREACHED */
                }
                cs = TAILQ_LAST(&cs_tailq, cs_tailq);
                cs->end_addr = instruction_ptr;
                in_critical_section = FALSE;
        }

export:
	{ $$ = 0; }
|	T_EXPORT
	{ $$ = 1; }
;

d622 1
a622 1
	export T_SYMBOL ':'
d624 1
a624 1
		if ($2->type != UNINITIALIZED) {
d628 3
a630 4
		$2->type = LABEL;
		initialize_symbol($2);
		$2->info.linfo->address = instruction_ptr;
		$2->info.linfo->exported = $1;
d732 1
d838 2
a839 2
                make_expression(&immed, 1);
                format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
a846 10
        }
;

code:
        T_NOT destination opt_source ret ';'
        {
                expression_t immed;

                make_expression(&immed, 0xff);
                format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
d971 4
a974 1
process_bitmask(int mask_type, symbol_t *sym, int mask)
d1019 2
a1020 1
initialize_symbol(symbol_t *symbol)
a1038 10
		/*
		 * Default to allowing access in all register modes
		 * or to the mode specified by the SCB or SRAM space
		 * we are in.
		 */
		if (scb_or_sram_symbol != NULL)
			symbol->info.rinfo->modes =
			    scb_or_sram_symbol->info.rinfo->modes;
		else
			symbol->info.rinfo->modes = ~0;
a1091 11
	case MACRO:
		symbol->info.macroinfo = 
		    (struct macro_info *)malloc(sizeof(struct macro_info));
		if (symbol->info.macroinfo == NULL) {
			stop("Can't create macro info", EX_SOFTWARE);
			/* NOTREACHED */
		}
		memset(symbol->info.macroinfo, 0,
		       sizeof(struct macro_info));
		TAILQ_INIT(&symbol->info.macroinfo->args);
		break;
d1101 2
a1102 52
add_macro_arg(const char *argtext, int argnum)
{
	struct macro_arg *marg;
	int i;
	int retval;
		

	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}

	marg = (struct macro_arg *)malloc(sizeof(*marg));
	if (marg == NULL) {
		stop("Can't create macro_arg structure", EX_SOFTWARE);
		/* NOTREACHED */
	}
	marg->replacement_text = NULL;
	retval = snprintf(regex_pattern, sizeof(regex_pattern),
			  "[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)",
			  argtext);
	if (retval >= sizeof(regex_pattern)) {
		stop("Regex text buffer too small for arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	retval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);
	if (retval != 0) {
		stop("Regex compilation failed", EX_SOFTWARE);
		/* NOTREACHED */
	}
	TAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);
}

static void
add_macro_body(const char *bodytext)
{
	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
		stop("Invalid current symbol for adding macro arg",
		     EX_SOFTWARE);
		/* NOTREACHED */
	}
	cur_symbol->info.macroinfo->body = strdup(bodytext);
	if (cur_symbol->info.macroinfo->body == NULL) {
		stop("Can't duplicate macro body text", EX_SOFTWARE);
		/* NOTREACHED */
	}
}

static void
process_register(symbol_t **p_symbol)
d1104 1
d1108 1
a1108 1
		snprintf(errbuf, sizeof(errbuf), "Undefined register %s",
d1110 1
a1110 1
		stop(errbuf, EX_DATAERR);
d1117 1
a1117 1
		snprintf(errbuf, sizeof(errbuf),
d1120 1
a1120 1
		stop(errbuf, EX_DATAERR);
d1125 6
a1130 2
format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
	       symbol_ref_t *src, int ret)
a1157 41
	else if (dest->symbol == mode_ptr.symbol) {
		u_int src_value;
		u_int dst_value;

		/*
		 * Attempt to update mode information if
		 * we are operating on the mode register.
		 */
		if (src->symbol == allones.symbol)
			src_value = 0xFF;
		else if (src->symbol == allzeros.symbol)
			src_value = 0;
		else if (src->symbol == mode_ptr.symbol)
			src_value = (dst_mode << 4) | src_mode;
		else
			goto cant_update;

		switch (opcode) {
		case AIC_OP_AND:
			dst_value = src_value & immed->value;
			break;
		case AIC_OP_XOR:
			dst_value = src_value ^ immed->value;
			break;
		case AIC_OP_ADD:
			dst_value = (src_value + immed->value) & 0xFF;
			break;
		case AIC_OP_OR:
			dst_value = src_value | immed->value;
			break;
			break;
		case AIC_OP_BMOV:
			dst_value = src_value;
			break;
		default:
			goto cant_update;
		}
		src_mode = dst_value & 0xF;
		dst_mode = (dst_value >> 4) & 0xF;
cant_update:
	}
d1164 6
a1169 2
format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
	       symbol_ref_t *src, int ret)
d1173 1
a1173 1
	uint8_t shift_control;
d1229 5
a1233 2
format_3_instr(int opcode, symbol_ref_t *src,
	       expression_t *immed, symbol_ref_t *address)
d1271 2
a1272 1
test_readable_symbol(symbol_t *symbol)
a1273 8
	
	if ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in source reg mode %d",
			symbol->name, src_mode);
		stop(errbuf, EX_DATAERR);
	}

d1282 2
a1283 1
test_writable_symbol(symbol_t *symbol)
a1284 8
	
	if ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {
		snprintf(errbuf, sizeof(errbuf),
			"Register %s unavailable in destination reg mode %d",
			symbol->name, dst_mode);
		stop(errbuf, EX_DATAERR);
	}

d1293 4
a1296 1
type_check(symbol_t *symbol, expression_t *expression, int opcode)
d1300 1
d1313 1
a1313 1
		snprintf(errbuf, sizeof(errbuf),
d1317 1
a1317 1
		stop(errbuf, EX_DATAERR);
d1326 3
a1328 1
		SLIST_FOREACH(node, &expression->referenced_syms, links) {
d1333 1
a1333 1
				snprintf(errbuf, sizeof(errbuf),
d1337 1
a1337 1
				stop(errbuf, EX_DATAERR);
d1345 3
a1347 1
make_expression(expression_t *immed, int value)
d1354 2
a1355 1
add_conditional(symbol_t *symbol)
a1390 20
static void
add_version(const char *verstring)
{
        const char prefix[] = " * ";
        int newlen;
        int oldlen;

        newlen = strlen(verstring) + strlen(prefix);
        oldlen = 0;
        if (versions != NULL)
                oldlen = strlen(versions);
        versions = realloc(versions, newlen + oldlen + 2);
        if (versions == NULL)
                stop("Can't allocate version string", EX_SOFTWARE);
        strcpy(&versions[oldlen], prefix);
        strcpy(&versions[oldlen + strlen(prefix)], verstring);
        versions[newlen + oldlen] = '\n';
        versions[newlen + oldlen + 1] = '\0';
}

d1392 2
a1393 1
yyerror(const char *string)
d1399 2
a1400 1
is_download_const(expression_t *immed)
d1402 2
a1403 4
	if (SLIST_EMPTY(&immed->referenced_syms))
		return (FALSE);
	if (SLIST_FIRST(&immed->referenced_syms)->symbol->type ==
	    DOWNLOAD_CONST)
d1405 1
@


1.1.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1830 4
a1833 1
	snprintf(&versions[oldlen], newlen + 2, "%s%s\n", prefix, verstring);
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a1 3
/*	$OpenBSD$	*/
/*	$NetBSD: aicasm_gram.y,v 1.3 2003/04/19 19:26:11 fvdl Exp $	*/

d6 1
a6 1
 * Copyright (c) 2001, 2002 Adaptec Inc.
d41 1
a41 1
 * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.23 2003/01/20 18:02:11 gibbs Exp $
a52 3
#ifdef __linux__
#include "../queue.h"
#else
a53 1
#endif
d57 1
a57 1
#include "aicasm_insformat.h"
a60 2
char stock_prefix[] = "aic_";
char *prefix = stock_prefix;
a65 1
static symbol_t *field_symbol;
a78 2
static u_int enum_increment;
static u_int enum_next_value;
d80 1
a80 1
static void process_field(int field_type, symbol_t *sym, int mask);
d149 1
a149 3
%token T_FIELD

%token T_ENUM
d159 1
a159 1
%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST
d199 1
a199 1
%type <value> mode_value mode_list macro_arglist
a212 2
|	prefix
|	program prefix
d215 2
a216 2
|	version
|	program version
d233 4
a236 4
|	critical_section_start
|	program critical_section_start
|	critical_section_end
|	program critical_section_end
d245 3
a247 3
	{
		include_file($3, BRACKETED_INCLUDE);
	}
d249 3
a251 15
	{
		include_file($3, QUOTED_INCLUDE);
	}
;

prefix:
	T_PREFIX '=' T_STRING
	{
		if (prefix != stock_prefix)
			stop("Prefix multiply defined",
			     EX_DATAERR);
		prefix = strdup($3);
		if (prefix == NULL)
			stop("Unable to record prefix", EX_SOFTWARE);
	}
d267 2
a268 2
	T_VERSION '=' T_STRING
	{ add_version($3); }
d323 1
a323 2
|	field_defn
|	enum_defn
d415 2
a416 17
field_defn:
	T_FIELD
		{
			field_symbol = NULL;
			enum_next_value = 0;
			enum_increment = 1;
		}
	'{' enum_entry_list '}'
|	T_FIELD T_SYMBOL expression
		{
			process_field(FIELD, $2, $3.value);
			field_symbol = $2;
			enum_next_value = 0;
			enum_increment = 0x01 << (ffs($3.value) - 1);
		}
	'{' enum_entry_list '}'
|	T_FIELD T_SYMBOL expression
d418 1
a418 37
		process_field(FIELD, $2, $3.value);
	}
;

enum_defn:
	T_ENUM
		{
			field_symbol = NULL;
			enum_next_value = 0;
			enum_increment = 1;
		}
	'{' enum_entry_list '}'
|	T_ENUM T_SYMBOL expression
		{
			process_field(ENUM, $2, $3.value);
			field_symbol = $2;
			enum_next_value = 0;
			enum_increment = 0x01 << (ffs($3.value) - 1);
		}
	'{' enum_entry_list '}'
;

enum_entry_list:
	enum_entry
|	enum_entry_list ',' enum_entry
;

enum_entry:
	T_SYMBOL
	{
		process_field(ENUM_ENTRY, $1, enum_next_value);
		enum_next_value += enum_increment;
	}
|	T_SYMBOL expression
	{
		process_field(ENUM_ENTRY, $1, $2.value);
		enum_next_value = $2.value + enum_increment;
d425 1
a425 1
		process_field(MASK, $2, $3.value);
d605 2
a606 4
		case FIELD:
		case ENUM:
		case ENUM_ENTRY:
			$$.value = symbol->info.finfo->value;
d629 1
a629 1
	T_CONST T_SYMBOL expression 
d638 1
a638 1
		$2->info.cinfo->value = $3.value;
d706 11
d755 2
a756 2
			/* 64 bytes of SCB space */
			cur_symbol->info.rinfo->size = 64;
d793 15
a807 15
|	T_SYMBOL '[' T_SYMBOL ']'
	{
		process_register(&$1);
		if ($3->type != CONST) {
			stop("register offset must be a constant", EX_DATAERR);
			/* NOTREACHED */
		}
		if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
			stop("Accessing offset beyond range of register",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		$$.symbol = $1;
		$$.offset = $3->info.cinfo->value;
	}
a858 2
		symlist_add(&$$.referenced_syms, accumulator.symbol,
			    SYMLIST_INSERT_HEAD);
d903 1
a903 1
		critical_section_t *cs;
d905 9
a913 10
		if (in_critical_section != FALSE) {
			stop("Critical Section within Critical Section",
			     EX_DATAERR);
			/* NOTREACHED */
		}
		cs = cs_alloc();
		cs->begin_addr = instruction_ptr;
		in_critical_section = TRUE;
	}
;
d918 1
a918 1
		critical_section_t *cs;
d920 8
a927 9
		if (in_critical_section == FALSE) {
			stop("Unballanced 'end_cs'", EX_DATAERR);
			/* NOTREACHED */
		}
		cs = TAILQ_LAST(&cs_tailq, cs_tailq);
		cs->end_addr = instruction_ptr;
		in_critical_section = FALSE;
	}
;
d1152 2
a1153 2
		make_expression(&immed, 1);
		format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
d1158 1
a1158 1
	T_MVI destination ',' immediate ret ';'
d1160 2
a1161 15
		if ($4.value == 0
		 && is_download_const(&$4) == 0) {
			expression_t immed;

			/*
			 * Allow move immediates of 0 so that macros,
			 * that can't know the immediate's value and
			 * otherwise compensate, still work.
			 */
			make_expression(&immed, 1);
			format_1_instr(AIC_OP_BMOV, &$2, &immed, &allzeros, $5);
		} else {
			format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
		}
	}
d1165 3
a1167 3
	T_NOT destination opt_source ret ';'
	{
		expression_t immed;
d1169 2
a1170 2
		make_expression(&immed, 0xff);
		format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
d1295 1
a1295 1
process_field(int field_type, symbol_t *sym, int value)
d1305 1
a1305 1
		sym->type = field_type;
d1307 8
a1314 4
		sym->info.finfo->value = value;
		if (field_type != ENUM_ENTRY) {
			if (field_type != MASK && value == 0) {
				stop("Empty Field, or Enum", EX_DATAERR);
a1316 6
			sym->info.finfo->value = value;
			sym->info.finfo->mask = value;
		} else if (field_symbol != NULL) {
			sym->info.finfo->mask = field_symbol->info.finfo->value;
		} else {
			sym->info.finfo->mask = 0xFF;
d1318 3
a1320 2
	} else if (sym->type != field_type) {
		stop("Field definition mirrors a definition of the same "
d1323 2
a1324 2
	} else if (value != sym->info.finfo->value) {
		stop("Field redefined with a conflicting value", EX_DATAERR);
d1328 1
a1328 1
	if (symlist_search(&(sym->info.finfo->symrefs),
d1330 1
a1330 1
		stop("Field defined multiple times for register", EX_DATAERR);
d1333 1
a1333 1
	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
d1335 1
a1335 1
	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
a1336 1
	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
d1343 1
a1343 1
	case UNINITIALIZED:
d1348 3
a1350 3
	case REGISTER:
	case SRAMLOC:
	case SCBLOC:
a1358 1
		SLIST_INIT(&(symbol->info.rinfo->fields));
d1370 1
a1370 1
	case ALIAS:
d1380 6
a1385 8
	case MASK:
	case FIELD:
	case ENUM:
	case ENUM_ENTRY:
		symbol->info.finfo =
		    (struct field_info *)malloc(sizeof(struct field_info));
		if (symbol->info.finfo == NULL) {
			stop("Can't create field info", EX_SOFTWARE);
d1388 2
a1389 2
		memset(symbol->info.finfo, 0, sizeof(struct field_info));
		SLIST_INIT(&(symbol->info.finfo->symrefs));
d1391 2
a1392 2
	case CONST:
	case DOWNLOAD_CONST:
d1574 1
d1583 1
a1585 1
cant_update:
d1755 2
a1756 4
	if (symbol->info.rinfo->typecheck_masks != FALSE) {
		for(node = expression->referenced_syms.slh_first;
		    node != NULL;
		    node = node->links.sle_next) {
d1758 2
a1759 4
			  || node->symbol->type == FIELD
			  || node->symbol->type == ENUM
			  || node->symbol->type == ENUM_ENTRY)
			 && symlist_search(&node->symbol->info.finfo->symrefs,
d1762 1
a1762 1
					 "Invalid field or mask %s "
d1819 12
a1830 15
	const char prefix[] = " * ";
	int newlen;
	int oldlen;

	newlen = strlen(verstring) + strlen(prefix);
	oldlen = 0;
	if (versions != NULL)
		oldlen = strlen(versions);
	versions = realloc(versions, newlen + oldlen + 2);
	if (versions == NULL)
		stop("Can't allocate version string", EX_SOFTWARE);
	strcpy(&versions[oldlen], prefix);
	strcpy(&versions[oldlen + strlen(prefix)], verstring);
	versions[newlen + oldlen] = '\n';
	versions[newlen + oldlen + 1] = '\0';
d1842 4
a1845 2
	if ((immed->referenced_syms.slh_first != NULL)
	 && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))
a1846 1

@


