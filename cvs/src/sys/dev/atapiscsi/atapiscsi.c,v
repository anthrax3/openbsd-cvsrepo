head	1.105;
access;
symbols
	OPENBSD_6_2_BASE:1.105
	OPENBSD_6_1:1.103.0.12
	OPENBSD_6_1_BASE:1.103
	OPENBSD_6_0:1.103.0.8
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.103.0.6
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.103.0.4
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.102.0.6
	OPENBSD_5_6_BASE:1.102
	OPENBSD_5_5:1.102.0.4
	OPENBSD_5_5_BASE:1.102
	OPENBSD_5_4:1.100.0.4
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.100.0.2
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.99.0.6
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.4
	OPENBSD_5_0:1.99.0.2
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.96.0.2
	OPENBSD_4_9_BASE:1.96
	OPENBSD_4_8:1.94.0.2
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.82.0.6
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.80.0.2
	OPENBSD_4_4_BASE:1.80
	OPENBSD_4_3:1.79.0.2
	OPENBSD_4_3_BASE:1.79
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.73.0.4
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.73.0.2
	OPENBSD_3_9_BASE:1.73
	OPENBSD_3_8:1.72.0.8
	OPENBSD_3_8_BASE:1.72
	OPENBSD_3_7:1.72.0.6
	OPENBSD_3_7_BASE:1.72
	OPENBSD_3_6:1.72.0.4
	OPENBSD_3_6_BASE:1.72
	SMP_SYNC_A:1.72
	SMP_SYNC_B:1.72
	OPENBSD_3_5:1.72.0.2
	OPENBSD_3_5_BASE:1.72
	OPENBSD_3_4:1.63.0.4
	OPENBSD_3_4_BASE:1.63
	UBC_SYNC_A:1.63
	OPENBSD_3_3:1.63.0.2
	OPENBSD_3_3_BASE:1.63
	OPENBSD_3_2:1.61.0.2
	OPENBSD_3_2_BASE:1.61
	OPENBSD_3_1:1.58.0.2
	OPENBSD_3_1_BASE:1.58
	UBC_SYNC_B:1.61
	UBC:1.54.0.2
	UBC_BASE:1.54
	OPENBSD_3_0:1.53.0.2
	OPENBSD_3_0_BASE:1.53
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	SMP:1.24.0.2
	SMP_BASE:1.24
	kame_19991208:1.19
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18;
locks; strict;
comment	@ * @;


1.105
date	2017.08.11.17.25.09;	author mpi;	state Exp;
branches;
next	1.104;
commitid	aZZnRuwzj4yuC2ws;

1.104
date	2017.08.11.14.59.43;	author mestre;	state Exp;
branches;
next	1.103;
commitid	EPKBw6juxY28elSM;

1.103
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.102;
commitid	uzzBR7hz9ncd4O6G;

1.102
date	2014.01.19.00.03.13;	author dlg;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.18.20.50.24;	author dlg;	state Exp;
branches;
next	1.100;

1.100
date	2012.08.08.02.32.11;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	2011.04.15.20.53.28;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2010.08.04.19.43.52;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.23.07.47.13;	author jsg;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.01.03.20.38;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2010.01.11.00.00.53;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2010.01.05.12.17.54;	author dlg;	state Exp;
branches;
next	1.85;

1.85
date	2010.01.05.00.16.30;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.27.09.18.01;	author sobrado;	state Exp;
branches;
next	1.83;

1.83
date	2009.09.05.11.20.24;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.22.20.11.03;	author drahn;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.06.01.05.35;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.06.08.28.09;	author tom;	state Exp;
branches;
next	1.77;

1.77
date	2007.02.14.00.53.47;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2006.10.22.22.43.21;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.22.22.39.57;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2006.01.13.19.23.55;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.21.09.34.56;	author grange;	state Exp;
branches;
next	1.71;

1.71
date	2004.02.13.23.47.29;	author grange;	state Exp;
branches;
next	1.70;

1.70
date	2004.02.07.19.59.43;	author grange;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.21.10.00.28;	author jmc;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.16.11.30.00;	author grange;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.28.21.01.43;	author grange;	state Exp;
branches;
next	1.63;

1.63
date	2003.02.13.20.54.59;	author grange;	state Exp;
branches;
next	1.62;

1.62
date	2002.12.19.16.32.59;	author grange;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.21.08.42.03;	author espie;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.10.16.26.28;	author csapuntz;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.08.21.50.48;	author csapuntz;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.16.17.13.22;	author csapuntz;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.01.10.10.03;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2001.08.25.19.29.16;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.18.20.37.21;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.31.07.07.00;	author csapuntz;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.31.06.14.05;	author csapuntz;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.21.09.08.49;	author csapuntz;	state Exp;
branches;
next	1.48;

1.48
date	2001.07.10.01.08.02;	author csapuntz;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.03.01.42.20;	author niklas;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.02.04.58.52;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.25.22.31.29;	author csapuntz;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.25.22.29.20;	author csapuntz;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.25.19.31.51;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.27.18.45.29;	author csapuntz;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.17.18.26.22;	author csapuntz;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.17.18.06.36;	author csapuntz;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.25.13.11.56;	author csapuntz;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.15.23.08.16;	author csapuntz;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.05.16.04.12;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.30.03.16.09;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.29.02.18.33;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.19.05.10.06;	author csapuntz;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.16.08.05.57;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.29.18.42.50;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.28.18.08.45;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.11.03.59.47;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.09.07.43.14;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.20.07.40.33;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.30.06.56.24;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.30.01.03.40;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.10.07.06.17;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.12.17.14.02;	author csapuntz;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	99.12.19.22.57.52;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	99.12.14.08.23.35;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	99.12.11.20.53.03;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	99.12.11.10.15.02;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	99.11.17.01.22.55;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	99.11.02.01.43.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.10.29.22.00.31;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	99.10.29.17.12.23;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	99.10.29.01.15.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.10.09.03.42.03;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	99.10.06.04.57.32;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	99.10.06.04.56.23;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	99.09.24.05.31.51;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	99.09.05.21.45.23;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.08.12.13.01.13;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	99.07.23.16.23.39;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	99.07.23.04.24.31;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	99.07.22.07.45.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.22.03.10.47;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	99.07.20.06.21.58;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	99.07.19.00.32.44;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.18;	author csapuntz;	state Exp;
branches;
next	;

1.24.2.1
date	2001.05.14.22.23.07;	author niklas;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2001.07.04.10.40.18;	author niklas;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2001.07.14.23.23.40;	author niklas;	state Exp;
branches;
next	1.24.2.4;

1.24.2.4
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.24.2.5;

1.24.2.5
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.24.2.6;

1.24.2.6
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.24.2.7;

1.24.2.7
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.24.2.8;

1.24.2.8
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.24.2.9;

1.24.2.9
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.24.2.10;

1.24.2.10
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.54.2.1
date	2002.01.31.22.55.30;	author niklas;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.54.2.3;

1.54.2.3
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.105
log
@Fix previous by calling wdc_atapi_intr_complete() before rerturning.

Suggested by and ok millert@@
@
text
@/*      $OpenBSD: atapiscsi.c,v 1.104 2017/08/11 14:59:43 mestre Exp $     */

/*
 * This code is derived from code with the copyright below.
 */

/*
 * Copyright (c) 1996, 1998 Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/disklabel.h>
#include <sys/malloc.h>
#include <sys/reboot.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/timeout.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsi_tape.h>
#include <scsi/scsiconf.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/ata/atareg.h>
#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>
#include <dev/ic/wdcevent.h>

/* drive states stored in ata_drive_datas */
enum atapi_drive_states {
	ATAPI_RESET_BASE_STATE = 0,
	ATAPI_DEVICE_RESET_WAIT_STATE = 1,
	ATAPI_IDENTIFY_STATE = 2,
	ATAPI_IDENTIFY_WAIT_STATE = 3,
	ATAPI_PIOMODE_STATE = 4,
	ATAPI_PIOMODE_WAIT_STATE = 5,
	ATAPI_DMAMODE_STATE = 6,
	ATAPI_DMAMODE_WAIT_STATE = 7,
	ATAPI_READY_STATE = 8
};

#define DEBUG_INTR   0x01
#define DEBUG_XFERS  0x02
#define DEBUG_STATUS 0x04
#define DEBUG_FUNCS  0x08
#define DEBUG_PROBE  0x10
#define DEBUG_DSC    0x20
#define DEBUG_POLL   0x40
#define DEBUG_ERRORS 0x80   /* Debug error handling code */

#if defined(WDCDEBUG)
#ifndef WDCDEBUG_ATAPI_MASK
#define WDCDEBUG_ATAPI_MASK 0x00
#endif
int wdcdebug_atapi_mask = WDCDEBUG_ATAPI_MASK;
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_atapi_mask & (level)) != 0)	\
		printf args;				\
} while (0)
#else
#define WDCDEBUG_PRINT(args, level)
#endif

/* 10 ms, this is used only before sending a cmd.  */
#define ATAPI_DELAY 10
#define ATAPI_RESET_DELAY 1000
#define ATAPI_RESET_WAIT 2000
#define ATAPI_CTRL_WAIT 4000

/* When polling, let the exponential backoff max out at 1 second's interval. */
#define ATAPI_POLL_MAXTIC (hz)

void  wdc_atapi_start(struct channel_softc *,struct wdc_xfer *);

void  wdc_atapi_timer_handler(void *);

void  wdc_atapi_real_start(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_real_start_2(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_command(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_data(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_complete(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_pio_intr(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_send_packet(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_ctrl(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);

char  *wdc_atapi_in_data_phase(struct wdc_xfer *, int, int);

int   wdc_atapi_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_atapi_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset_2(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);

void  wdc_atapi_tape_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
#define MAX_SIZE MAXPHYS

struct atapiscsi_softc;
struct atapiscsi_xfer;

int	atapiscsi_match(struct device *, void *, void *);
void	atapiscsi_attach(struct device *, struct device *, void *);
int	atapiscsi_activate(struct device *, int);
int	atapiscsi_detach(struct device *, int);
int     atapi_to_scsi_sense(struct scsi_xfer *, u_int8_t);

enum atapi_state { as_none, as_data, as_completed };

struct atapiscsi_softc {
	struct device  sc_dev;
	struct  scsi_link  sc_adapterlink;
	struct channel_softc *chp;
	enum atapi_state protocol_phase;

	int drive;
};

void  wdc_atapi_minphys(struct buf *bp, struct scsi_link *sl);
int   wdc_atapi_ioctl(struct scsi_link *, u_long, caddr_t, int);
void  wdc_atapi_send_cmd(struct scsi_xfer *sc_xfer);

static struct scsi_adapter atapiscsi_switch =
{
	wdc_atapi_send_cmd,
	wdc_atapi_minphys,
	NULL,
	NULL,
	wdc_atapi_ioctl
};

/* Inital version shares bus_link structure so it can easily
   be "attached to current" wdc driver */

struct cfattach atapiscsi_ca = {
	sizeof(struct atapiscsi_softc), atapiscsi_match, atapiscsi_attach,
	    atapiscsi_detach, atapiscsi_activate
};

struct cfdriver atapiscsi_cd = {
	NULL, "atapiscsi", DV_DULL
};


int
atapiscsi_match(struct device *parent, void *match, void *aux)
{
	struct ata_atapi_attach *aa_link = aux;
	struct cfdata *cf = match;

	if (aa_link == NULL)
		return (0);

	if (aa_link->aa_type != T_ATAPI)
		return (0);

	if (cf->cf_loc[0] != aa_link->aa_channel &&
	    cf->cf_loc[0] != -1)
		return (0);

	return (1);
}

void
atapiscsi_attach(struct device *parent, struct device *self, void *aux)
{
	struct atapiscsi_softc *as = (struct atapiscsi_softc *)self;
	struct ata_atapi_attach *aa_link = aux;
	struct scsibus_attach_args saa;
	struct ata_drive_datas *drvp = aa_link->aa_drv_data;
	struct channel_softc *chp = drvp->chnl_softc;
	struct ataparams *id = &drvp->id;
	struct device *child;

	extern struct scsi_iopool wdc_xfer_iopool;

	printf("\n");

	/* Initialize shared data. */
	scsi_init();

#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_atapi_mask |= DEBUG_PROBE;
#endif

	as->chp = chp;
	as->drive = drvp->drive;
	as->sc_adapterlink.adapter_softc = as;
	as->sc_adapterlink.adapter_target = 7;
	as->sc_adapterlink.adapter_buswidth = 2;
	as->sc_adapterlink.adapter = &atapiscsi_switch;
	as->sc_adapterlink.luns = 1;
	as->sc_adapterlink.openings = 1;
	as->sc_adapterlink.flags = SDEV_ATAPI;
	as->sc_adapterlink.pool = &wdc_xfer_iopool;

	strlcpy(drvp->drive_name, as->sc_dev.dv_xname,
	    sizeof(drvp->drive_name));
	drvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;

	wdc_probe_caps(drvp, id);

	WDCDEBUG_PRINT(
		("general config %04x capabilities %04x ",
		    id->atap_config, id->atap_capabilities1),
		    DEBUG_PROBE);

	if ((NERRS_MAX - 2) > 0)
		drvp->n_dmaerrs = NERRS_MAX - 2;
	else
		drvp->n_dmaerrs = 0;
	drvp->drive_flags |= DRIVE_DEVICE_RESET;

	/* Tape drives do funny DSC stuff */
	if (ATAPI_CFG_TYPE(id->atap_config) ==
	    ATAPI_CFG_TYPE_SEQUENTIAL)
		drvp->atapi_cap |= ACAP_DSC;

	if ((id->atap_config & ATAPI_CFG_CMD_MASK) ==
	    ATAPI_CFG_CMD_16)
		drvp->atapi_cap |= ACAP_LEN;

	drvp->atapi_cap |=
	    (id->atap_config & ATAPI_CFG_DRQ_MASK);

	WDCDEBUG_PRINT(("driver caps %04x\n", drvp->atapi_cap),
	    DEBUG_PROBE);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &as->sc_adapterlink;

	child = config_found((struct device *)as, &saa, scsiprint);

	if (child != NULL) {
		struct scsibus_softc *scsi = (struct scsibus_softc *)child;
		struct scsi_link *link = scsi_get_link(scsi, 0, 0);

		if (link) {
			strlcpy(drvp->drive_name,
			    ((struct device *)(link->device_softc))->dv_xname,
			    sizeof(drvp->drive_name));

			wdc_print_caps(drvp);
		}
	}

#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_atapi_mask &= ~DEBUG_PROBE;
#endif
}

int
atapiscsi_activate(struct device *self, int act)
{
	struct atapiscsi_softc *as = (void *)self;
 	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[as->drive];

	switch (act) {
	case DVACT_SUSPEND:
		break;
	case DVACT_RESUME:
		/*
		 * Do two resets separated by a small delay. The
		 * first wakes the controller, the second resets
		 * the channel
		 */
		wdc_disable_intr(chp);
		wdc_reset_channel(drvp, 1);
		delay(10000);
		wdc_reset_channel(drvp, 0);
		wdc_enable_intr(chp);
		break;
	}
	return (0);
}

int
atapiscsi_detach(struct device *dev, int flags)
{
	return (config_detach_children(dev, flags));
}

void
wdc_atapi_send_cmd(struct scsi_xfer *sc_xfer)
{
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
 	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[as->drive];
	struct wdc_xfer *xfer;
	int s;
	int idx;

	WDCDEBUG_PRINT(("wdc_atapi_send_cmd %s:%d:%d start\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive), DEBUG_XFERS);

	if (sc_xfer->sc_link->target != 0) {
		sc_xfer->error = XS_DRIVER_STUFFUP;
		scsi_done(sc_xfer);
		return;
	}

	xfer = sc_xfer->io;
	wdc_scrub_xfer(xfer);
	if (sc_xfer->flags & SCSI_POLL)
		xfer->c_flags |= C_POLL;
	xfer->drive = as->drive;
	xfer->c_flags |= C_ATAPI;
	xfer->cmd = sc_xfer;
	xfer->databuf = sc_xfer->data;
	xfer->c_bcount = sc_xfer->datalen;
	xfer->c_start = wdc_atapi_start;
	xfer->c_intr = wdc_atapi_intr;

	timeout_set(&xfer->atapi_poll_to, wdc_atapi_timer_handler, chp);

	WDCDEBUG_PRINT(("wdc_atapi_send_cmd %s:%d:%d ",
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive),
	    DEBUG_XFERS | DEBUG_ERRORS);

	for (idx = 0; idx < sc_xfer->cmdlen; idx++) {
		WDCDEBUG_PRINT((" %02x",
				   ((unsigned char *)sc_xfer->cmd)[idx]),
		    DEBUG_XFERS | DEBUG_ERRORS);
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_XFERS | DEBUG_ERRORS);

	s = splbio();

	if (drvp->atapi_cap & ACAP_DSC) {
		WDCDEBUG_PRINT(("about to send cmd 0x%x ",
		    sc_xfer->cmd->opcode), DEBUG_DSC);
		switch (sc_xfer->cmd->opcode) {
		case READ:
		case WRITE:
			xfer->c_flags |= C_MEDIA_ACCESS;

			/* If we are not in buffer availability mode,
			   we limit the first request to 0 bytes, which
			   gets us into buffer availability mode without
			   holding the bus.  */
			if (!(drvp->drive_flags & DRIVE_DSCBA)) {
				xfer->c_bcount = 0;
				xfer->transfer_len =
				  _3btol(((struct scsi_rw_tape *)
					  sc_xfer->cmd)->len);
				_lto3b(0,
				    ((struct scsi_rw_tape *)
				    sc_xfer->cmd)->len);
				xfer->c_done = wdc_atapi_tape_done;
				WDCDEBUG_PRINT(
				    ("R/W in completion mode, do 0 blocks\n"),
				    DEBUG_DSC);
			} else
				WDCDEBUG_PRINT(("R/W %d blocks %d bytes\n",
				    _3btol(((struct scsi_rw_tape *)
					sc_xfer->cmd)->len),
				    sc_xfer->datalen),
				    DEBUG_DSC);

			/* DSC will change to buffer availability mode.
			   We reflect this in wdc_atapi_intr.  */
			break;

		case ERASE:		/* Media access commands */
		case LOAD:
		case REWIND:
		case SPACE:
		case WRITE_FILEMARKS:
#if 0
		case LOCATE:
		case READ_POSITION:
#endif

			xfer->c_flags |= C_MEDIA_ACCESS;
			break;

		default:
			WDCDEBUG_PRINT(("no media access\n"), DEBUG_DSC);
		}
	}

	wdc_exec_xfer(chp, xfer);
	splx(s);
}

void
wdc_atapi_minphys (struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > MAX_SIZE)
		bp->b_bcount = MAX_SIZE;
	minphys(bp);
}

int
wdc_atapi_ioctl (struct scsi_link *sc_link, u_long cmd, caddr_t addr, int flag)
{
	struct atapiscsi_softc *as = sc_link->adapter_softc;
	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[as->drive];

	if (sc_link->target != 0)
		return ENOTTY;

	return (wdc_ioctl(drvp, cmd, addr, flag, curproc));
}


/*
 * Returns 1 if we experienced an ATA-level abort command
 *           (ABRT bit set but no additional sense)
 *         0 if normal command processing
 */
int
atapi_to_scsi_sense(struct scsi_xfer *xfer, u_int8_t flags)
{
	struct scsi_sense_data *sense = &xfer->sense;
	int ret = 0;

	xfer->error = XS_SHORTSENSE;

	sense->error_code = SSD_ERRCODE_VALID | SSD_ERRCODE_CURRENT;
	sense->flags = (flags >> 4);

	WDCDEBUG_PRINT(("Atapi error: %d ", (flags >> 4)), DEBUG_ERRORS);

	if ((flags & 4) && (sense->flags == 0)) {
		sense->flags = SKEY_ABORTED_COMMAND;
		WDCDEBUG_PRINT(("ABRT "), DEBUG_ERRORS);
		ret = 1;
	}

	if (flags & 0x1) {
		sense->flags |= SSD_ILI;
		WDCDEBUG_PRINT(("ILI "), DEBUG_ERRORS);
	}

	if (flags & 0x2) {
		sense->flags |= SSD_EOM;
		WDCDEBUG_PRINT(("EOM "), DEBUG_ERRORS);
	}

	/* Media change requested */
	/* Let's ignore these in version 1 */
	if (flags & 0x8) {
		WDCDEBUG_PRINT(("MCR "), DEBUG_ERRORS);
		if (sense->flags == 0)
			xfer->error = XS_NOERROR;
	}

	WDCDEBUG_PRINT(("\n"), DEBUG_ERRORS);
	return (ret);
}

int wdc_atapi_drive_selected(struct channel_softc *, int);

int
wdc_atapi_drive_selected(struct channel_softc *chp, int drive)
{
	u_int8_t reg = CHP_READ_REG(chp, wdr_sdh);

	WDC_LOG_REG(chp, wdr_sdh, reg);

	return ((reg & 0x10) == (drive << 4));
}

enum atapi_context {
	ctxt_process = 0,
	ctxt_timer = 1,
	ctxt_interrupt = 2
};

void wdc_atapi_the_machine(struct channel_softc *, struct wdc_xfer *,
    enum atapi_context);

void wdc_atapi_the_poll_machine(struct channel_softc *, struct wdc_xfer *);

void
wdc_atapi_start(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	xfer->next = wdc_atapi_real_start;

	wdc_atapi_the_machine(chp, xfer, ctxt_process);
}


void
wdc_atapi_timer_handler(void *arg)
{
	struct channel_softc *chp = arg;
	struct wdc_xfer *xfer;
	int s;

	s = splbio();
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	if (xfer == NULL ||
	    !timeout_triggered(&xfer->atapi_poll_to)) {
		splx(s);
		return;
	}
	xfer->c_flags &= ~C_POLL_MACHINE;
	timeout_del(&xfer->atapi_poll_to);
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
	wdc_atapi_the_machine(chp, xfer, ctxt_timer);
	splx(s);
}


int
wdc_atapi_intr(struct channel_softc *chp, struct wdc_xfer *xfer, int irq)
{
	timeout_del(&chp->ch_timo);

	/* XXX we should consider an alternate signaling regime here */
	if (xfer->c_flags & C_TIMEOU) {
		xfer->c_flags &= ~C_TIMEOU;
		wdc_atapi_the_machine(chp, xfer, ctxt_timer);
		return (0);
	}

	wdc_atapi_the_machine(chp, xfer, ctxt_interrupt);

	return (-1);
}

struct atapi_return_args {
	int timeout;
	int delay;
	int expect_irq;
};

#define ARGS_INIT {-1, 0, 0}

void
wdc_atapi_the_poll_machine(struct channel_softc *chp, struct wdc_xfer *xfer)
{
	int  idx = 0;
	int  current_timeout = 10;


	while (1) {
		struct atapi_return_args retargs = ARGS_INIT;
		idx++;

		(xfer->next)(chp, xfer, (current_timeout * 1000 <= idx),
		    &retargs);

		if (xfer->next == NULL) {
			wdc_free_xfer(chp, xfer);
			wdcstart(chp);
			return;
		}

		if (retargs.timeout != -1) {
			current_timeout = retargs.timeout;
			idx = 0;
		}

		if (retargs.delay != 0) {
			delay (1000 * retargs.delay);
			idx += 1000 * retargs.delay;
		}

		DELAY(1);
	}
}


void
wdc_atapi_the_machine(struct channel_softc *chp, struct wdc_xfer *xfer,
    enum atapi_context ctxt)
{
	int idx = 0;
	extern int ticks;
	int timeout_delay = hz / 10;

	if (xfer->c_flags & C_POLL) {
		wdc_disable_intr(chp);

		if (ctxt != ctxt_process) {
			if (ctxt == ctxt_interrupt)
				xfer->endticks = 1;

			return;
		}

		wdc_atapi_the_poll_machine(chp, xfer);
		return;
	}

	/* Don't go through more than 50 state machine steps
	   before yielding. This tries to limit the amount of time
	   spent at high SPL */
	for (idx = 0; idx < 50; idx++) {
		struct atapi_return_args retargs = ARGS_INIT;

		(xfer->next)(chp, xfer,
		    xfer->endticks && (ticks - xfer->endticks >= 0),
		    &retargs);

		if (retargs.timeout != -1)
			/*
			 * Add 1 tick to compensate for the fact that we
			 * can be just microseconds before the tick changes.
			 */
			xfer->endticks =
			    max((retargs.timeout * hz) / 1000, 1) + 1 + ticks;

		if (xfer->next == NULL) {
			if (xfer->c_flags & C_POLL_MACHINE)
				timeout_del(&xfer->atapi_poll_to);

			wdc_free_xfer(chp, xfer);
			wdcstart(chp);

			return;
		}

		if (retargs.expect_irq) {
			int timeout_period;
			chp->ch_flags |= WDCF_IRQ_WAIT;
			timeout_period =  xfer->endticks - ticks;
			if (timeout_period < 1)
				timeout_period = 1;
			timeout_add(&chp->ch_timo, timeout_period);
			return;
		}

		if (retargs.delay != 0) {
			timeout_delay = max(retargs.delay * hz / 1000, 1);
			break;
		}

		DELAY(1);
	}

	timeout_add(&xfer->atapi_poll_to, timeout_delay);
	xfer->c_flags |= C_POLL_MACHINE;

	return;
}


void wdc_atapi_update_status(struct channel_softc *);

void
wdc_atapi_update_status(struct channel_softc *chp)
{
	chp->ch_status = CHP_READ_REG(chp, wdr_status);

	WDC_LOG_STATUS(chp, chp->ch_status);

	if (chp->ch_status == 0xff && (chp->ch_flags & WDCF_ONESLAVE)) {
		wdc_set_drive(chp, 1);

		chp->ch_status = CHP_READ_REG(chp, wdr_status);
		WDC_LOG_STATUS(chp, chp->ch_status);
	}

	if ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR) {
		chp->ch_error = CHP_READ_REG(chp, wdr_error);
		WDC_LOG_ERROR(chp, chp->ch_error);
	}
}

void
wdc_atapi_real_start(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
#ifdef WDCDEBUG
	struct scsi_xfer *sc_xfer = xfer->cmd;
#endif
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];

	/*
	 * Only set the DMA flag if the transfer is reasonably large.
	 * At least one older drive failed to complete a 4 byte DMA transfer.
	 */

	/* Turn off DMA flag on REQUEST SENSE */

	if (!(xfer->c_flags & (C_POLL | C_SENSE | C_MEDIA_ACCESS)) &&
	    (drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&
	    (xfer->c_bcount > 100))
		xfer->c_flags |= C_DMA;
	else
		xfer->c_flags &= ~C_DMA;


	wdc_set_drive(chp, xfer->drive);

	DELAY(1);

	xfer->next = wdc_atapi_real_start_2;
	ret->timeout = ATAPI_DELAY;

	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x, "
	    "ATA flags 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,
	    sc_xfer->flags, xfer->c_flags), DEBUG_XFERS);


	return;
}


void
wdc_atapi_real_start_2(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];

	if (timeout) {
		printf("wdc_atapi_start: not ready, st = %02x\n",
		    chp->ch_status);

		sc_xfer->error = XS_TIMEOUT;
		xfer->next = wdc_atapi_reset;
		return;
	} else {
		wdc_atapi_update_status(chp);

		if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
			return;
	}

	/* Do control operations specially. */
	if (drvp->state < ATAPI_READY_STATE) {
		xfer->next = wdc_atapi_ctrl;
		return;
	}

	xfer->next = wdc_atapi_send_packet;
	return;
}


void
wdc_atapi_send_packet(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];

	/*
	 * Even with WDCS_ERR, the device should accept a command packet.
	 * Limit length to what can be stuffed into the cylinder register
	 * (16 bits).  Some CD-ROMs seem to interpret '0' as 65536,
	 * but not all devices do that and it's not obvious from the
	 * ATAPI spec that this behaviour should be expected.  If more
	 * data is necessary, multiple data transfer phases will be done.
	 */

	wdccommand(chp, xfer->drive, ATAPI_PKT_CMD,
	    xfer->c_bcount <= 0xfffe ? xfer->c_bcount : 0xfffe,
	    0, 0, 0,
	    (xfer->c_flags & C_DMA) ? ATAPI_PKT_CMD_FTRE_DMA : 0);

	if (xfer->c_flags & C_DMA)
		drvp->n_xfers++;

	DELAY(1);

	xfer->next = wdc_atapi_intr_command;
	ret->timeout = sc_xfer->timeout;

	if ((drvp->atapi_cap & ATAPI_CFG_DRQ_MASK) == ATAPI_CFG_IRQ_DRQ) {
		/* We expect an IRQ to tell us of the next state */
		ret->expect_irq = 1;
	}

	WDCDEBUG_PRINT(("wdc_atapi_send_packet %s:%d:%d command sent\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive
	    ), DEBUG_XFERS);
	return;
}

void
wdc_atapi_intr_command(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
	int i;
	u_int8_t cmd[16];
	struct scsi_sense *cmd_reqsense;
	int cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;
	int dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
	    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;

	wdc_atapi_update_status(chp);

	if ((chp->ch_status & WDCS_BSY) || !(chp->ch_status & WDCS_DRQ)) {
		if (timeout)
			goto timeout;

		return;
	}

	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);

	bzero(cmd, sizeof(cmd));

	if (xfer->c_flags & C_SENSE) {
		cmd_reqsense = (struct scsi_sense *)&cmd[0];
		cmd_reqsense->opcode = REQUEST_SENSE;
		cmd_reqsense->length = xfer->c_bcount;
	} else
		bcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);

	WDC_LOG_ATAPI_CMD(chp, xfer->drive, xfer->c_flags,
	    cmdlen, cmd);

	for (i = 0; i < 12; i++)
		WDCDEBUG_PRINT(("%02x ", cmd[i]), DEBUG_INTR);
	WDCDEBUG_PRINT((": PHASE_CMDOUT\n"), DEBUG_INTR);

	/* Init the DMA channel if necessary */
	if (xfer->c_flags & C_DMA) {
		if ((*chp->wdc->dma_init)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, xfer->databuf,
		    xfer->c_bcount, dma_flags) != 0) {
			sc_xfer->error = XS_DRIVER_STUFFUP;

			xfer->next = wdc_atapi_reset;
			return;
		}
	}

	wdc_output_bytes(drvp, cmd, cmdlen);

	/* Start the DMA channel if necessary */
	if (xfer->c_flags & C_DMA) {
		(*chp->wdc->dma_start)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive);
		xfer->next = wdc_atapi_intr_complete;
	} else {
		if (xfer->c_bcount == 0)
			as->protocol_phase = as_completed;
		else
			as->protocol_phase = as_data;

		xfer->next = wdc_atapi_pio_intr;
	}

	ret->expect_irq = 1;

	/* If we read/write to a tape we will get into buffer
	   availability mode.  */
	if (drvp->atapi_cap & ACAP_DSC) {
		if ((sc_xfer->cmd->opcode == READ ||
		       sc_xfer->cmd->opcode == WRITE)) {
			drvp->drive_flags |= DRIVE_DSCBA;
			WDCDEBUG_PRINT(("set DSCBA\n"), DEBUG_DSC);
		} else if ((xfer->c_flags & C_MEDIA_ACCESS) &&
		    (drvp->drive_flags & DRIVE_DSCBA)) {
			/* Clause 3.2.4 of QIC-157 D.

			   Any media access command other than read or
			   write will switch DSC back to completion
			   mode */
			drvp->drive_flags &= ~DRIVE_DSCBA;
			WDCDEBUG_PRINT(("clear DCSBA\n"), DEBUG_DSC);
		}
	}

	return;

 timeout:
	printf ("%s:%d:%d: device timeout waiting to send SCSI packet\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive);

	sc_xfer->error = XS_TIMEOUT;
	xfer->next = wdc_atapi_reset;
	return;
}


char *
wdc_atapi_in_data_phase(struct wdc_xfer *xfer, int len, int ire)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
	char *message;

	if (as->protocol_phase != as_data) {
		message = "unexpected data phase";
		goto unexpected_state;
	}

	if (ire & WDCI_CMD) {
		message = "unexpectedly in command phase";
		goto unexpected_state;
	}

	if (!(xfer->c_flags & C_SENSE)) {
		if (!(sc_xfer->flags & (SCSI_DATA_IN | SCSI_DATA_OUT))) {
			message = "data phase where none expected";
			goto unexpected_state;
		}

		/* Make sure polarities match */
		if (((ire & WDCI_IN) == WDCI_IN) ==
		    ((sc_xfer->flags & SCSI_DATA_OUT) == SCSI_DATA_OUT)) {
			message = "data transfer direction disagreement";
			goto unexpected_state;
		}
	} else {
		if (!(ire & WDCI_IN)) {
			message = "data transfer direction disagreement during sense";
			goto unexpected_state;
		}
	}

	if (len == 0) {
		message = "zero length transfer requested in data phase";
		goto unexpected_state;
	}


	return (0);

 unexpected_state:

	return (message);
}

void
wdc_atapi_intr_data(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	int len, ire;
	char *message;
	int tohost;

	len = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |
	    CHP_READ_REG(chp, wdr_cyl_lo);
	WDC_LOG_REG(chp, wdr_cyl_lo, len);

	ire = CHP_READ_REG(chp, wdr_ireason);
	WDC_LOG_REG(chp, wdr_ireason, ire);

	if ((message = wdc_atapi_in_data_phase(xfer, len, ire))) {
		/* The drive has dropped BSY before setting up the
		   registers correctly for DATA phase. This drive is
		   not compliant with ATA/ATAPI-4.

		   Give the drive 100ms to get its house in order
		   before we try again.  */
		WDCDEBUG_PRINT(("wdc_atapi_intr: %s\n", message),
		    DEBUG_ERRORS);

		if (!timeout) {
			ret->delay = 100;
			return;
		}
	}

	tohost = ((sc_xfer->flags & SCSI_DATA_IN) != 0 ||
	    (xfer->c_flags & C_SENSE) != 0);

	if (xfer->c_bcount >= len) {
		WDCDEBUG_PRINT(("wdc_atapi_intr: c_bcount %d len %d "
		    "st 0x%b err 0x%x "
		    "ire 0x%x\n", xfer->c_bcount,
		    len, chp->ch_status, WDCS_BITS, chp->ch_error, ire),
		    DEBUG_INTR);

		/* Common case */
		if (!tohost)
			wdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +
			    xfer->c_skip, len);
		else
			wdc_input_bytes(drvp, (u_int8_t *)xfer->databuf +
			    xfer->c_skip, len);

		xfer->c_skip += len;
		xfer->c_bcount -= len;
	} else {
		/* Exceptional case - drive want to transfer more
		   data than we have buffer for */
		if (!tohost) {
			/* Wouldn't it be better to just abort here rather
			   than to write random stuff to drive? */
			printf("wdc_atapi_intr: warning: device requesting "
			    "%d bytes, only %d left in buffer\n", len, xfer->c_bcount);

			wdc_output_bytes(drvp, (u_int8_t *)xfer->databuf +
			    xfer->c_skip, xfer->c_bcount);

			CHP_WRITE_RAW_MULTI_2(chp, NULL,
			    len - xfer->c_bcount);
		} else {
			printf("wdc_atapi_intr: warning: reading only "
			    "%d of %d bytes\n", xfer->c_bcount, len);

			wdc_input_bytes(drvp,
			    (char *)xfer->databuf + xfer->c_skip,
			    xfer->c_bcount);
			wdcbit_bucket(chp, len - xfer->c_bcount);
		}

		xfer->c_skip += xfer->c_bcount;
		xfer->c_bcount = 0;
	}

	ret->expect_irq = 1;
	xfer->next = wdc_atapi_pio_intr;

	return;
}

void
wdc_atapi_intr_complete(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;

	WDCDEBUG_PRINT(("PHASE_COMPLETED\n"), DEBUG_INTR);

	if (xfer->c_flags & C_DMA) {
		int retry;

		if (timeout) {
			sc_xfer->error = XS_TIMEOUT;
			ata_dmaerr(drvp);

			xfer->next = wdc_atapi_reset;
			return;
		}

		for (retry = 5; retry > 0; retry--) {
			wdc_atapi_update_status(chp);
			if ((chp->ch_status & (WDCS_BSY | WDCS_DRQ)) == 0)
				break;
			DELAY(5);
		}
		if (retry == 0) {
			ret->expect_irq = 1;
			return;
		}

		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)
		    (chp->wdc->dma_arg, chp->channel,
			xfer->drive, 1);

		if (chp->wdc->dma_status & WDC_DMAST_UNDER)
			xfer->c_bcount = 1;
		else
			xfer->c_bcount = 0;
	}

	as->protocol_phase = as_none;

	if (xfer->c_flags & C_SENSE) {
		if (chp->ch_status & WDCS_ERR) {
			if (chp->ch_error & WDCE_ABRT) {
				WDCDEBUG_PRINT(("wdc_atapi_intr: request_sense aborted, "
						"calling wdc_atapi_done()"
					), DEBUG_INTR);
				xfer->next = wdc_atapi_done;
				return;
			}

			/*
			 * request sense failed ! it's not supposed
 			 * to be possible
			 */
			sc_xfer->error = XS_SHORTSENSE;
		} else if (xfer->c_bcount < sizeof(sc_xfer->sense)) {
			/* use the sense we just read */
			sc_xfer->error = XS_SENSE;
		} else {
			/*
			 * command completed, but no data was read.
			 * use the short sense we saved previously.
			 */
			sc_xfer->error = XS_SHORTSENSE;
		}
	} else {
		sc_xfer->resid = xfer->c_bcount;
		if (chp->ch_status & WDCS_ERR) {
			if (!atapi_to_scsi_sense(sc_xfer, chp->ch_error) &&
			    (sc_xfer->sc_link->quirks &
			     ADEV_NOSENSE) == 0) {
				/*
				 * let the driver issue a
				 * 'request sense'
				 */
				xfer->databuf = &sc_xfer->sense;
				xfer->c_bcount = sizeof(sc_xfer->sense);
				xfer->c_skip = 0;
				xfer->c_done = NULL;
				xfer->c_flags |= C_SENSE;
				xfer->next = wdc_atapi_real_start;
				return;
			}
		}
	}

        if ((xfer->c_flags & C_DMA) &&
	    (chp->wdc->dma_status & ~WDC_DMAST_UNDER)) {
		ata_dmaerr(drvp);
		sc_xfer->error = XS_RESET;

		xfer->next = wdc_atapi_reset;
		return;
	}


	if (xfer->c_bcount != 0) {
		WDCDEBUG_PRINT(("wdc_atapi_intr: bcount value is "
				"%d after io\n", xfer->c_bcount), DEBUG_XFERS);
	}
#ifdef DIAGNOSTIC
	if (xfer->c_bcount < 0) {
		printf("wdc_atapi_intr warning: bcount value "
		       "is %d after io\n", xfer->c_bcount);
	}
#endif

	WDCDEBUG_PRINT(("wdc_atapi_intr: wdc_atapi_done() (end), error 0x%x "
			"\n", sc_xfer->error),
		       DEBUG_INTR);


	if (xfer->c_done)
		xfer->next = xfer->c_done;
	else
		xfer->next = wdc_atapi_done;

	return;
}

void
wdc_atapi_pio_intr(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
	u_int8_t ireason;

	wdc_atapi_update_status(chp);

	if (chp->ch_status & WDCS_BSY) {
		if (timeout)
			goto timeout;

		return;
	}

	if (!wdc_atapi_drive_selected(chp, xfer->drive)) {
		WDCDEBUG_PRINT(("wdc_atapi_intr_for_us: wrong drive selected\n"), DEBUG_INTR);
		wdc_set_drive(chp, xfer->drive);
		delay (1);

		if (!timeout)
			return;
	}

	if ((xfer->c_flags & C_MEDIA_ACCESS) &&
	    !(chp->ch_status & (WDCS_DSC | WDCS_DRQ))) {
		if (timeout)
			goto timeout;

		ret->delay = 100;
		return;
	}

	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);

	ireason = CHP_READ_REG(chp, wdr_ireason);
	WDC_LOG_REG(chp, wdr_ireason, ireason);

	WDCDEBUG_PRINT(("Phase %d, (0x%b, 0x%x) ", as->protocol_phase,
	    chp->ch_status, WDCS_BITS, ireason), DEBUG_INTR );

	switch (as->protocol_phase) {
	case as_data:
		if ((chp->ch_status & WDCS_DRQ) ||
		    (ireason & 3) != 3) {
			if (timeout)
				goto timeout;

			wdc_atapi_intr_data(chp, xfer, timeout, ret);
			return;
		}

		wdc_atapi_intr_complete(chp, xfer, timeout, ret);
		return;

	case as_completed:
		if ((chp->ch_status & WDCS_DRQ) ||
		    (ireason & 3) != 3) {
			if (timeout)
				goto timeout;

			ret->delay = 100;
			return;
		}

		wdc_atapi_intr_complete(chp, xfer, timeout, ret);
		return;

	default:
		printf ("atapiscsi: Shouldn't get here\n");
		sc_xfer->error = XS_DRIVER_STUFFUP;
		xfer->next = wdc_atapi_reset;
		return;
	}

	return;
timeout:
	ireason = CHP_READ_REG(chp, wdr_ireason);
	WDC_LOG_REG(chp, wdr_ireason, ireason);

	printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d, "
	    "status=0x%b, ireason=0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    xfer->c_bcount, xfer->c_skip, chp->ch_status, WDCS_BITS, ireason);

	sc_xfer->error = XS_TIMEOUT;
	xfer->next = wdc_atapi_reset;
	return;
}

void
wdc_atapi_ctrl(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	char *errstring = NULL;

 	wdc_atapi_update_status(chp);

	if (!timeout) {
		switch (drvp->state) {
		case ATAPI_IDENTIFY_WAIT_STATE:
			if (chp->ch_status & WDCS_BSY)
				return;
			break;
		default:
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
				return;
			break;
		}
	}

	if (!wdc_atapi_drive_selected(chp, xfer->drive))
	{
		wdc_set_drive(chp, xfer->drive);
		delay (1);
	}

	if (timeout) {
		int trigger_timeout = 1;

		switch (drvp->state) {
		case ATAPI_DEVICE_RESET_WAIT_STATE:
			errstring = "Device Reset Wait";
			drvp->drive_flags &= ~DRIVE_DEVICE_RESET;
			break;

		case ATAPI_IDENTIFY_WAIT_STATE:
			errstring = "Identify";
			if (!(chp->ch_status & WDCS_BSY) &&
			    (chp->ch_status & (WDCS_DRQ | WDCS_ERR)))
				trigger_timeout = 0;

			break;

		case ATAPI_PIOMODE_STATE:
			errstring = "Post-Identify";
			if (!(chp->ch_status & (WDCS_BSY | WDCS_DRQ)))
				trigger_timeout = 0;
			break;

		case ATAPI_PIOMODE_WAIT_STATE:
			errstring = "PIOMODE";
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
				drvp->drive_flags &= ~DRIVE_MODE;
			else
				trigger_timeout = 0;
			break;
		case ATAPI_DMAMODE_WAIT_STATE:
			errstring = "dmamode";
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
				drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
			else
				trigger_timeout = 0;
			break;

		default:
			errstring = "unknown state";
			break;
		}

		if (trigger_timeout)
			goto timeout;
	}

	WDCDEBUG_PRINT(("wdc_atapi_ctrl %s:%d:%d state %d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive, drvp->state),
	    DEBUG_INTR | DEBUG_FUNCS);

	switch (drvp->state) {
		/* My ATAPI slave device likes to assert DASP-/PDIAG- until
		   it is DEVICE RESET. This causes the LED to stay on.

		   There is a trade-off here. This drive will cause any
		   play-back or seeks happening to be interrupted.

		   Note that the bus reset that triggered this state
		   (which may have been caused by the other drive on
		   the chain) need not interrupt this playback. It happens
		   to on my Smart & Friendly CD burner.

		   - csapuntz@@
		*/
	case ATAPI_RESET_BASE_STATE:
		if ((drvp->drive_flags & DRIVE_DEVICE_RESET) == 0) {
			drvp->state = ATAPI_IDENTIFY_STATE;
			break;
		}

		wdccommandshort(chp, drvp->drive, ATAPI_DEVICE_RESET);
		drvp->state = ATAPI_DEVICE_RESET_WAIT_STATE;
		ret->delay = ATAPI_RESET_DELAY;
		ret->timeout = ATAPI_RESET_WAIT;
		break;

	case ATAPI_DEVICE_RESET_WAIT_STATE:
		/* FALLTHROUGH */

	case ATAPI_IDENTIFY_STATE:
		wdccommandshort(chp, drvp->drive, ATAPI_IDENTIFY_DEVICE);
		drvp->state = ATAPI_IDENTIFY_WAIT_STATE;
		ret->delay = 10;
		ret->timeout = ATAPI_RESET_WAIT;
		break;

	case ATAPI_IDENTIFY_WAIT_STATE: {
		int idx = 0;

		while ((chp->ch_status & WDCS_DRQ) &&
		    idx++ < 20) {
			wdcbit_bucket(chp, 512);

			DELAY(1);
			wdc_atapi_update_status(chp);
		}

		drvp->state = ATAPI_PIOMODE_STATE;
		/*
		 * Note, we can't go directly to set PIO mode
		 * because the drive is free to assert BSY
		 * after the transfer
		 */
		break;
	}

	case ATAPI_PIOMODE_STATE:
		/* Don't try to set mode if controller can't be adjusted */
		if ((chp->wdc->cap & WDC_CAPABILITY_MODE) == 0)
			goto ready;
		/* Also don't try if the drive didn't report its mode */
		if ((drvp->drive_flags & DRIVE_MODE) == 0)
			goto ready;
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
			goto ready;
		wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
		    0x08 | drvp->PIO_mode, WDSF_SET_MODE);
		drvp->state = ATAPI_PIOMODE_WAIT_STATE;
		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
		break;
	case ATAPI_PIOMODE_WAIT_STATE:
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & WDCS_ERR) {
			/* Downgrade straight to PIO mode 3 */
			drvp->PIO_mode = 3;
			chp->wdc->set_modes(chp);
		}
	/* FALLTHROUGH */

	case ATAPI_DMAMODE_STATE:
		if (drvp->drive_flags & DRIVE_UDMA) {
			wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
			    0x40 | drvp->UDMA_mode, WDSF_SET_MODE);
		} else if (drvp->drive_flags & DRIVE_DMA) {
			wdccommand(chp, drvp->drive, SET_FEATURES, 0, 0, 0,
			    0x20 | drvp->DMA_mode, WDSF_SET_MODE);
		} else {
			goto ready;
		}
		drvp->state = ATAPI_DMAMODE_WAIT_STATE;

		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
		break;

	case ATAPI_DMAMODE_WAIT_STATE:
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		if (chp->ch_status & WDCS_ERR)
			drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
	/* FALLTHROUGH */

	case ATAPI_READY_STATE:
	ready:
		drvp->state = ATAPI_READY_STATE;
		xfer->next = wdc_atapi_real_start;
		break;
	}
	return;

timeout:
	printf("%s:%d:%d: %s timed out\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive, errstring);
	sc_xfer->error = XS_TIMEOUT;
	xfer->next = wdc_atapi_reset;
	return;

}

void
wdc_atapi_tape_done(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;

	if (sc_xfer->error != XS_NOERROR) {
		xfer->next = wdc_atapi_done;
		return;
	}

	_lto3b(xfer->transfer_len,
	    ((struct scsi_rw_tape *)
		sc_xfer->cmd)->len);

	xfer->c_bcount = sc_xfer->datalen;
	xfer->c_done = NULL;
	xfer->c_skip = 0;

	xfer->next = wdc_atapi_real_start;
	return;
}


void
wdc_atapi_done(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct scsi_xfer *sc_xfer = xfer->cmd;

	WDCDEBUG_PRINT(("wdc_atapi_done %s:%d:%d: flags 0x%x error 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    (u_int)xfer->c_flags, sc_xfer->error), DEBUG_XFERS);
	WDC_LOG_ATAPI_DONE(chp, xfer->drive, xfer->c_flags, sc_xfer->error);

	if (xfer->c_flags & C_POLL)
		wdc_enable_intr(chp);

	scsi_done(sc_xfer);

	xfer->next = NULL;
	return;
}


void
wdc_atapi_reset(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];

	if (drvp->state == 0) {
		xfer->next = wdc_atapi_done;
		return;
	}

	WDCDEBUG_PRINT(("wdc_atapi_reset\n"), DEBUG_XFERS);
	wdccommandshort(chp, xfer->drive, ATAPI_SOFT_RESET);
	drvp->state = ATAPI_IDENTIFY_STATE;

	drvp->n_resets++;
	/* Some ATAPI devices need extra time to find their
	   brains after a reset
	 */
	xfer->next = wdc_atapi_reset_2;
	ret->delay = ATAPI_RESET_DELAY;
	ret->timeout = ATAPI_RESET_WAIT;
	return;
}

void
wdc_atapi_reset_2(struct channel_softc *chp, struct wdc_xfer *xfer,
    int timeout, struct atapi_return_args *ret)
{
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct scsi_xfer *sc_xfer = xfer->cmd;

	if (timeout) {
		printf("%s:%d:%d: soft reset failed\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel,
		    xfer->drive);
		sc_xfer->error = XS_SELTIMEOUT;
		wdc_reset_channel(drvp, 0);

		xfer->next = wdc_atapi_done;
		return;
	}

	wdc_atapi_update_status(chp);

	if (chp->ch_status & (WDCS_BSY | WDCS_DRQ)) {
		return;
	}

	xfer->next = wdc_atapi_done;
	return;
}
@


1.104
log
@Missing break/return statement on switch case

Coverity CID 1453394

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.103 2014/09/14 14:17:24 jsg Exp $     */
d1240 1
@


1.103
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.102 2014/01/19 00:03:13 dlg Exp $     */
d1239 2
@


1.102
log
@scsi has to scrub the ata xfer before using it so its set for the rest
of the ata stuff to properly handle.

found by dtucker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.101 2014/01/18 20:50:24 dlg Exp $     */
a40 1
#include <sys/proc.h>
@


1.101
log
@move atapiscsi to iopools by making the entire ata layer use them too.

this would have been difficult before because the ata completion
paths try to be helfpul by freeing xfers on the adapters behalf,
whch doesn't work in the new world scsi model where the layer that
allocated the thing is responsible for freeing it, and expects to
get it back and maybe use it again. however, deraadt@@ added magic
flags for hibernate that im now using to keep ata xfers for the
scsi layers.

committing this now so itll be tested. i cant think of a better time
to handle fallout from diffs like this than hackathons.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.100 2012/08/08 02:32:11 matthew Exp $     */
d347 1
@


1.100
log
@Convert from K&R to ISO function signatures.

From Brad; no binary change on amd64.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.99 2011/07/17 22:46:48 matthew Exp $     */
d216 2
d237 1
d346 1
a346 7
	xfer = wdc_get_xfer(sc_xfer->flags & SCSI_NOSLEEP
	    ? WDC_NOSLEEP : WDC_CANSLEEP);
	if (xfer == NULL) {
		sc_xfer->error = XS_NO_CCB;
		scsi_done(sc_xfer);
		return;
	}
@


1.99
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.98 2011/07/08 22:09:27 matthew Exp $     */
d187 1
a187 4
atapiscsi_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;

d206 1
a206 3
atapiscsi_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d319 1
a319 3
atapiscsi_detach(dev, flags)
	struct device *dev;
	int flags;
d325 1
a325 2
wdc_atapi_send_cmd(sc_xfer)
	struct scsi_xfer *sc_xfer;
d441 1
a441 5
wdc_atapi_ioctl (sc_link, cmd, addr, flag)
	struct   scsi_link *sc_link;
	u_long   cmd;
	caddr_t  addr;
	int      flag;
d460 1
a460 3
atapi_to_scsi_sense(xfer, flags)
	struct scsi_xfer *xfer;
	u_int8_t flags;
d503 1
a503 3
wdc_atapi_drive_selected(chp, drive)
	struct channel_softc *chp;
	int drive;
d524 1
a524 3
wdc_atapi_start(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d533 1
a533 2
wdc_atapi_timer_handler(arg)
	void *arg;
d555 1
a555 4
wdc_atapi_intr(chp, xfer, irq)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int irq;
d580 1
a580 3
wdc_atapi_the_poll_machine(chp, xfer)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
d615 2
a616 4
wdc_atapi_the_machine(chp, xfer, ctxt)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	enum atapi_context ctxt;
d692 1
a692 2
wdc_atapi_update_status(chp)
	struct channel_softc *chp;
d712 2
a713 5
wdc_atapi_real_start(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d753 2
a754 5
wdc_atapi_real_start_2(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d785 2
a786 5
wdc_atapi_send_packet(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d825 2
a826 5
wdc_atapi_intr_command(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d928 1
a928 3
wdc_atapi_in_data_phase(xfer, len, ire)
	struct wdc_xfer *xfer;
	int len, ire;
d977 2
a978 5
wdc_atapi_intr_data(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1064 2
a1065 5
wdc_atapi_intr_complete(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1189 2
a1190 5
wdc_atapi_pio_intr(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
a1277 2


d1279 2
a1280 5
wdc_atapi_ctrl(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1481 2
a1482 5
wdc_atapi_tape_done(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1505 2
a1506 5
wdc_atapi_done(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1526 2
a1527 5
wdc_atapi_reset(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
d1551 2
a1552 5
wdc_atapi_reset_2(chp, xfer, timeout, ret)
	struct channel_softc *chp;
	struct wdc_xfer *xfer;
	int timeout;
	struct atapi_return_args *ret;
@


1.98
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.97 2011/04/15 20:53:28 miod Exp $     */
d235 1
d237 1
a274 2
	saa.saa_targets = 2;
	saa.saa_luns = 1;
@


1.97
log
@Change wdc_reset_channel() to take a `no wait' argument. Pass in turn this
argument to wdcreset(), to have it skip waiting until active channels see
their BUSY bit clear in the status register.

Use this feature in the resume path, during the first reset operation. The
first reset is supposed to only wake up the controller, and the disks don't
come back until the second reset is issued, therefore waiting for them to
report themselves as ready after the first reset, but before the second, is
moot - and as a matter of fact some controllers, such as the AMD 754 and
clones/offspring (e.g. Geode) keep the BUSY bit asserted after the first
reset.

Last, but not least, make sure wd@@ata invokes wd_get_params() again before
returning from the resume code, as we will still be using polled transfers
for a short while.

This causes the Lemote Yeelong to resume within less than one second, instead
of the lousy 30 seconds wait between the two resets; and the wd_get_params()
voodoo prevents it from getting spurious ide interrupts afterwards.

wd_get_params() magic from dlg; rest of the work by yours truly after enough
prodding by dlg@@ and pirofti@@, among others. ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.96 2010/11/18 21:13:19 miod Exp $     */
a234 1
	as->sc_adapterlink.adapter_buswidth = 2;
a235 1
	as->sc_adapterlink.luns = 1;
d273 2
@


1.96
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.95 2010/09/20 06:17:49 krw Exp $     */
d314 1
a314 1
		wdc_reset_channel(drvp);
d316 1
a316 1
		wdc_reset_channel(drvp);
d1629 1
a1629 1
		wdc_reset_channel(drvp);
@


1.95
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.94 2010/08/04 19:43:52 deraadt Exp $     */
a38 1
#include <sys/dkstat.h>
a39 1
#include <sys/dkstat.h>
@


1.94
log
@Wake up cdroms attached to pciide; same as in wd.c 1.86
tested by phessler
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.93 2010/07/23 07:47:13 jsg Exp $     */
d483 1
a483 1
	sense->error_code = SSD_ERRCODE_VALID | 0x70;
@


1.93
log
@Manuel Bouyer rescinded clauses 3 and 4 of his license text.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.92 2010/07/01 03:20:38 matthew Exp $     */
d147 1
d180 1
a180 1
	    atapiscsi_detach
d297 26
@


1.92
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.91 2010/06/28 18:31:01 krw Exp $     */
a17 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Manuel Bouyer.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.91
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.90 2010/06/15 04:11:34 dlg Exp $     */
d287 1
a287 1
		struct scsi_link *link = scsi->sc_link[0][0];
@


1.90
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.89 2010/05/20 00:55:17 krw Exp $     */
a179 8
static struct scsi_device atapiscsi_dev =
{
	NULL,
	NULL,
	NULL,
	NULL,
};

a243 1
	as->sc_adapterlink.device = &atapiscsi_dev;
@


1.89
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.88 2010/03/23 01:57:19 krw Exp $     */
d168 1
a168 2
int   wdc_atapi_ioctl(struct scsi_link *,
	u_long, caddr_t, int, struct proc *);
d439 1
a439 1
wdc_atapi_ioctl (sc_link, cmd, addr, flag, p)
a443 1
	struct proc *p;
d452 1
a452 1
	return (wdc_ioctl(drvp, cmd, addr, flag, p));
@


1.88
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.87 2010/01/11 00:00:53 krw Exp $     */
a337 1
		s = splbio();
a338 1
		splx(s);
a345 1
		s = splbio();
a346 1
		splx(s);
a1561 1
	int s;
a1570 1
	s = splbio();
a1571 1
	splx(s);
@


1.87
log
@Don't check ITSDONE since we know it is set in scsi_done(). Eliminates
possible references to xs which has been recycled. Slight tweak to
dlg's previous fix for atapiscsi.

ok dlg@@ 'looks safe' miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.86 2010/01/05 12:17:54 dlg Exp $     */
d170 1
a170 1
int   wdc_atapi_send_cmd(struct scsi_xfer *sc_xfer);
d322 1
a322 1
int
d341 1
a341 1
		return (COMPLETE);
d347 5
a351 1
		return (NO_CCB);
a432 5

	if (xfer->c_flags & C_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
@


1.86
log
@dont need to end statements with two semicolons. one is enough.

pointed out by miod@@ and claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.85 2010/01/05 00:16:30 dlg Exp $     */
d330 1
a330 1
	int s, ret = SUCCESSFULLY_QUEUED;
a427 8
	if (xfer->c_flags & C_POLL) {
#ifdef DIAGNOSTIC
		if ((sc_xfer->flags & ITSDONE) == 0)
			panic("wdc_atapi_send_cmd: polled command not done");
#endif
		scsi_done(sc_xfer);
		ret = COMPLETE;
	}
d429 5
a433 1
	return (ret);
d1574 2
a1575 1
	sc_xfer->flags |= ITSDONE;
d1577 3
a1579 8
	if (xfer->c_flags & C_POLL) {
		wdc_enable_intr(chp);
	} else {
		WDCDEBUG_PRINT(("wdc_atapi_done: scsi_done\n"), DEBUG_XFERS);
		s = splbio();
		scsi_done(sc_xfer);
		splx(s);
	}
@


1.85
log
@atapiscsi didnt call scsi_done when the xfer had SCSI_POLL set. this is
Bad.

this sort of worked before because the midlayer would sleep on the
ITSDONE flag in the scsi_xfer, which atapiscsi does set. however, with
the introduction of scsi_xs_sync, it now sleeps on a condition that is
only cleared if the adapter properly and correctly calls scsi_done when
it is in fact done with the xfer.

sorry guys.

ok krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.84 2009/11/27 09:18:01 sobrado Exp $     */
d330 1
a330 1
	int s, ret = SUCCESSFULLY_QUEUED;;
@


1.84
log
@typo in documentation; missing full stop.

from Dawe.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.83 2009/09/05 11:20:24 dlg Exp $     */
d330 1
a330 1
	int s, ret;
d428 1
d430 2
a431 3
	if ((xfer->c_flags & C_POLL) != 0 &&
	    (sc_xfer->flags & ITSDONE) == 0)
		panic("wdc_atapi_send_cmd: polled command not done");
d433 3
a435 1
	ret = (sc_xfer->flags & ITSDONE) ? COMPLETE : SUCCESSFULLY_QUEUED;
@


1.83
log
@call scsi_done before returning COMPLETE in the stuffup case.

pointed out by miod
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.82 2009/02/16 21:19:06 miod Exp $     */
d827 1
a827 1
	 * Even with WDCS_ERR, the device should accept a command packet
@


1.82
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.81 2008/11/25 17:52:02 krw Exp $     */
d338 3
@


1.81
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.80 2008/05/22 20:11:03 drahn Exp $     */
d167 1
a167 1
void  wdc_atapi_minphys(struct buf *bp);
d436 1
a436 1
wdc_atapi_minphys (struct buf *bp)
d438 1
a438 1
	if(bp->b_bcount > MAX_SIZE)
@


1.80
log
@never schedule a timer for a negative time, if in the past schedule short delay.
please commit deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.79 2007/11/06 01:05:35 krw Exp $     */
d344 1
a344 1
		return (TRY_AGAIN_LATER);
@


1.79
log
@More scsi_done() at SPLBIO.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.78 2007/08/06 08:28:09 tom Exp $     */
d687 1
d689 4
a692 1
			timeout_add(&chp->ch_timo, xfer->endticks - ticks);
@


1.78
log
@Fix some "that that"s.

ok miod@@ jmc@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.77 2007/02/14 00:53:47 jsg Exp $     */
d1562 1
d1575 1
d1577 1
@


1.77
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.76 2006/11/28 23:59:45 dlg Exp $     */
d824 1
a824 1
	 * ATAPI spec that that behaviour should be expected.  If more
@


1.76
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.75 2006/10/22 22:43:21 dlg Exp $     */
d1432 1
a1432 1
		/* fall through */
d1485 1
a1485 1
	/* fall through */
d1508 1
a1508 1
	/* fall through */
@


1.75
log
@fetch the name of the cd device attached to the atapiscsi scsibus by
following the child device that attaches to us. this is cleaner than using
the scsibus member of the adapters sc_link to look up the correct unit.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.73 2006/01/13 19:23:55 miod Exp $     */
d231 1
d290 4
a293 2
	child = config_found((struct device *)as, &as->sc_adapterlink,
	    scsiprint);
@


1.74
log
@strncpy -> strlcpy
@
text
@a227 1

d234 1
d289 2
d292 2
a293 9
	as->sc_adapterlink.scsibus = (u_int8_t)-1;

	config_found((struct device *)as,
		     &as->sc_adapterlink, scsiprint);

	if (as->sc_adapterlink.scsibus != (u_int8_t)-1) {
		int bus = as->sc_adapterlink.scsibus;
		extern struct cfdriver scsibus_cd;
		struct scsibus_softc *scsi = scsibus_cd.cd_devs[bus];
@


1.73
log
@Enable detaching atapiscsi devices.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.72 2004/02/21 09:34:56 grange Exp $     */
d257 2
a258 2
	strncpy(drvp->drive_name, as->sc_dev.dv_xname,
	    sizeof(drvp->drive_name) - 1);
d302 1
a302 1
			strncpy(drvp->drive_name,
d304 1
a304 1
			    sizeof(drvp->drive_name) - 1);
@


1.72
log
@SCSI_DATA_OUT doesn't mean transfer from host in all cases, when
requesting sense we reuse the same scsi xfer so flags lie and we should
check for C_SENSE too.
Eliminates pciide timeouts at the end of every burning with cdrecord.

Bug introduced, found and then fixed by costa@@.

ok costa@@ krw@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.71 2004/02/13 23:47:29 grange Exp $     */
d153 1
d193 2
a194 1
	sizeof(struct atapiscsi_softc), atapiscsi_match, atapiscsi_attach
d316 7
@


1.71
log
@Cleanup debug messages: use %b for status, %x -> 0x%x, wrap lines.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.70 2004/02/07 19:59:43 grange Exp $     */
d1013 1
d1038 2
d1049 1
a1049 1
		if (sc_xfer->flags & SCSI_DATA_OUT)
d1061 1
a1061 1
		if (sc_xfer->flags & SCSI_DATA_OUT) {
@


1.70
log
@Always disable interrupts on a controller for polled commands.
This solves a long standing problem with hangs during attaching
scsibus at atapiscsi on some i386 machines.

Help in debugging the problem pval@@.
Testing pval@@, deraadt@@, david@@ and me on several machines.
ok costa@@ tdeval@@ pb@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.69 2004/01/14 02:00:41 krw Exp $     */
d365 2
a366 2
		WDCDEBUG_PRINT(("about to send cmd %x ", sc_xfer->cmd->opcode),
		    DEBUG_DSC);
d757 2
a758 1
	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x, ATA flags 0x%x\n",
d1040 1
a1040 1
		    "st 0x%x err 0x%x "
d1042 2
a1043 1
		    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);
d1261 2
a1262 1
	WDCDEBUG_PRINT(("Phase %d, (%x, %x) ", as->protocol_phase, chp->ch_status, ireason), DEBUG_INTR );
d1301 1
a1301 1
	    "status=%02x, ireason=%02x\n",
d1303 1
a1303 1
	    xfer->c_bcount, xfer->c_skip, chp->ch_status, ireason);
@


1.69
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.68 2004/01/09 21:32:23 brad Exp $     */
d638 2
d1557 3
a1559 1
	if (!(xfer->c_flags & C_POLL)) {
@


1.68
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.67 2003/10/21 10:00:28 jmc Exp $     */
d251 1
a253 1
	as->sc_adapterlink.quirks = SDEV_NOLUNS;
@


1.67
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.66 2003/10/17 08:14:09 grange Exp $     */
a57 2

#include <uvm/uvm_extern.h>
@


1.66
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.65 2003/10/16 11:30:00 grange Exp $     */
d1146 1
a1146 1
			 * request sense failed ! it's not suppossed
d1156 1
a1156 1
			 * use the short sense we saved previsouly.
@


1.65
log
@Allow setting of wdcdebug*_mask variables via preprocessor defines.
This makes creating debug kernels be much more easy.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.64 2003/09/28 21:01:43 grange Exp $     */
a1103 5
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)
			    (chp->wdc->dma_arg, chp->channel,
				xfer->drive);

d1125 1
a1125 1
			xfer->drive);
@


1.64
log
@kill trailing spaces, no functional changes
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.63 2003/02/13 20:54:59 grange Exp $     */
d94 4
a97 1
int wdcdebug_atapi_mask = 0;
@


1.63
log
@Don't force all ATAPI devices to PIO mode 3, there are
devices which only support PIO mode 2 or less. Use
atap_oldpiotiming to obtain supported mode for such devices.
Also use SET FEATURES only for PIO mode > 2.

Work by Alec Skelly <alec@@dtkco.com> with my little help.

ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.62 2002/12/19 16:32:59 grange Exp $     */
d130 1
a130 1
void  wdc_atapi_ctrl(struct channel_softc *, struct wdc_xfer *, 
d170 1
a170 1
static struct scsi_adapter atapiscsi_switch = 
d179 1
a179 1
static struct scsi_device atapiscsi_dev = 
d258 2
a259 2
	wdc_probe_caps(drvp, id); 
	
d270 1
a270 1
	
d272 1
a272 1
	if (ATAPI_CFG_TYPE(id->atap_config) == 
d275 1
a275 1
	
d279 1
a279 1
	
d282 1
a282 1
	
d286 1
a286 1
	
d289 1
a289 1
	config_found((struct device *)as, 
d297 1
a297 1
		
d299 2
a300 2
			strncpy(drvp->drive_name, 
			    ((struct device *)(link->device_softc))->dv_xname, 
d302 1
a302 1
			
d306 1
a306 1
	
d333 1
a333 1
	xfer = wdc_get_xfer(sc_xfer->flags & SCSI_NOSLEEP 
d351 1
a351 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive), 
d355 1
a355 1
		WDCDEBUG_PRINT((" %02x", 
d377 1
a377 1
				xfer->transfer_len = 
d389 2
a390 2
				    _3btol(((struct scsi_rw_tape *)	
					sc_xfer->cmd)->len), 
d548 1
a548 1
	if (xfer == NULL || 
d583 1
a583 1
	int delay; 
d592 1
a592 1
	struct wdc_xfer *xfer;	
d629 1
a629 1
	struct wdc_xfer *xfer;	
d635 1
a635 1
	
d654 1
a654 1
		(xfer->next)(chp, xfer, 
d657 2
a658 2
		
		if (retargs.timeout != -1) 
d660 1
a660 1
			 * Add 1 tick to compensate for the fact that we 
d672 1
a672 1
			
d681 1
a681 1
		
d732 1
a732 1
	/* 
d739 1
a739 1
	if (!(xfer->c_flags & (C_POLL | C_SENSE | C_MEDIA_ACCESS)) && 
d782 1
a782 1
		
d786 1
a786 1
    
d817 1
a817 1
	wdccommand(chp, xfer->drive, ATAPI_PKT_CMD, 
d819 1
a819 1
	    0, 0, 0, 
d857 1
a857 1
	
d876 1
a876 1
	} else 
d881 1
a881 1
	
d889 1
a889 1
		    chp->channel, xfer->drive, xfer->databuf, 
d971 1
a971 1
		
d984 1
a984 1
	
d1029 1
a1029 1
			return;	
d1033 1
a1033 1
	
d1039 1
a1039 1
		
d1061 2
a1062 2
			 
			CHP_WRITE_RAW_MULTI_2(chp, NULL, 
d1067 1
a1067 1
			 
d1123 1
a1123 1
		
d1129 1
a1129 1
		if (chp->wdc->dma_status & WDC_DMAST_UNDER) 
d1132 1
a1132 1
			xfer->c_bcount = 0;		
d1180 1
a1180 1
		}		
d1191 1
a1191 1
			
d1211 1
a1211 1
	else 
d1303 1
a1303 1
	
d1377 1
a1377 1
			else 
d1395 1
a1395 1
		/* My ATAPI slave device likes to assert DASP-/PDIAG- until 
d1442 1
a1442 1
		/* 
d1542 1
a1542 1
	
d1577 1
a1577 1
	
d1606 1
a1606 1
	
d1613 1
a1613 1
		
@


1.62
log
@Protect WDCDEBUG_PRINT macro with do {} while (0)
ok costa@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.61 2002/05/21 08:42:03 espie Exp $     */
a1450 1
piomode:
d1457 3
d1470 1
a1470 8
			if (drvp->PIO_mode < 3) {
				drvp->PIO_mode = 3;
				goto piomode;
			}
			/* 
			 * All ATAPI drives are supposed to support
			 * PIO mode 3 or greater. 
			 */
@


1.61
log
@Move enum definitions to global scope. Local scope is meaningless, and
interferes with C99's anonymous stuff.

ok millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.60 2002/05/10 16:26:28 csapuntz Exp $     */
d95 4
a98 3
#define WDCDEBUG_PRINT(args, level) \
	if (wdcdebug_atapi_mask & (level)) \
		printf args
@


1.60
log
@Dump the actual command to be sent
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.59 2002/05/08 21:50:48 csapuntz Exp $     */
d153 2
a158 1
	enum atapi_state { as_none, as_data, as_completed };
@


1.59
log
@Drives can go busy after IDENTIFY. Make sure drive is not busy before issuing
SET PIO mode. Heh, this might have been the cause of all those old
PIO mode aborts.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.58 2002/03/16 17:13:22 csapuntz Exp $     */
d878 2
a879 2
	    sc_xfer->cmdlen, sc_xfer->cmd);

@


1.58
log
@Log extra info for ATAPI devices
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.57 2002/03/14 01:26:52 millert Exp $     */
d1358 6
d1440 6
a1446 1
		/* fall through */
@


1.57
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.56 2002/02/01 10:10:03 art Exp $     */
d69 1
d509 2
d703 2
d706 1
a706 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | 0x10);
d709 1
d712 1
a712 1
	if ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR)
d714 2
d745 1
a745 1
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
d877 3
d1010 2
d1013 1
d1235 1
a1235 2
	if (!wdc_atapi_drive_selected(chp, xfer->drive))
	{
d1237 1
a1237 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
d1257 2
d1295 1
d1337 1
a1337 1
		CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
d1547 1
a1618 2


@


1.56
log
@duplicate include
Noted by Jacob Meuser <jakemsr@@jakemsr.com>
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.55 2002/01/07 19:04:46 mickey Exp $     */
d110 1
a110 1
void  wdc_atapi_start __P((struct channel_softc *,struct wdc_xfer *));
d112 1
a112 1
void  wdc_atapi_timer_handler __P((void *));
d114 26
a139 26
void  wdc_atapi_real_start __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_real_start_2 __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_command __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_data __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_complete __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_pio_intr __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_send_packet __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_ctrl __P((struct channel_softc *, struct wdc_xfer *, 
    int, struct atapi_return_args *));

char  *wdc_atapi_in_data_phase __P((struct wdc_xfer *, int, int));

int   wdc_atapi_intr __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdc_atapi_done __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
void  wdc_atapi_reset __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
void  wdc_atapi_reset_2 __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
d141 2
a142 2
void  wdc_atapi_tape_done __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
d148 3
a150 3
int	atapiscsi_match __P((struct device *, void *, void *));
void	atapiscsi_attach __P((struct device *, struct device *, void *));
int     atapi_to_scsi_sense __P((struct scsi_xfer *, u_int8_t));
d162 4
a165 4
void  wdc_atapi_minphys __P((struct buf *bp));
int   wdc_atapi_ioctl __P((struct scsi_link *,
	u_long, caddr_t, int, struct proc *));
int   wdc_atapi_send_cmd __P((struct scsi_xfer *sc_xfer));
d499 1
a499 1
int wdc_atapi_drive_selected __P((struct channel_softc *, int));
d517 2
a518 2
void wdc_atapi_the_machine __P((struct channel_softc *, struct wdc_xfer *,
    enum atapi_context));
d520 1
a520 1
void wdc_atapi_the_poll_machine __P((struct channel_softc *, struct wdc_xfer *));
d692 1
a692 1
void wdc_atapi_update_status __P((struct channel_softc *));
@


1.55
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.54 2001/11/06 19:53:18 miod Exp $     */
a68 2

#include <scsi/scsiconf.h>
@


1.54
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.53 2001/08/25 19:29:16 fgsch Exp $     */
d165 2
a166 1
int   wdc_atapi_ioctl __P((struct scsi_link *, u_long, caddr_t, int));
d435 1
a435 1
wdc_atapi_ioctl (sc_link, cmd, addr, flag)
d440 1
d449 1
a449 1
	return (wdc_ioctl(drvp, cmd, addr, flag));
@


1.54.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.55 2002/01/07 19:04:46 mickey Exp $     */
d165 1
a165 2
int   wdc_atapi_ioctl __P((struct scsi_link *,
	u_long, caddr_t, int, struct proc *));
d434 1
a434 1
wdc_atapi_ioctl (sc_link, cmd, addr, flag, p)
a438 1
	struct proc *p;
d447 1
a447 1
	return (wdc_ioctl(drvp, cmd, addr, flag, p));
@


1.54.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.54.2.1 2002/01/31 22:55:30 niklas Exp $     */
d69 2
a70 1
#include <dev/ic/wdcevent.h>
d112 1
a112 1
void  wdc_atapi_start(struct channel_softc *,struct wdc_xfer *);
d114 1
a114 1
void  wdc_atapi_timer_handler(void *);
d116 26
a141 26
void  wdc_atapi_real_start(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_real_start_2(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_command(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_data(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_complete(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_pio_intr(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_send_packet(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_ctrl(struct channel_softc *, struct wdc_xfer *, 
    int, struct atapi_return_args *);

char  *wdc_atapi_in_data_phase(struct wdc_xfer *, int, int);

int   wdc_atapi_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_atapi_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset_2(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
d143 2
a144 2
void  wdc_atapi_tape_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
d150 3
a152 5
int	atapiscsi_match(struct device *, void *, void *);
void	atapiscsi_attach(struct device *, struct device *, void *);
int     atapi_to_scsi_sense(struct scsi_xfer *, u_int8_t);

enum atapi_state { as_none, as_data, as_completed };
d158 1
d164 4
a167 4
void  wdc_atapi_minphys(struct buf *bp);
int   wdc_atapi_ioctl(struct scsi_link *,
	u_long, caddr_t, int, struct proc *);
int   wdc_atapi_send_cmd(struct scsi_xfer *sc_xfer);
d501 1
a501 1
int wdc_atapi_drive_selected(struct channel_softc *, int);
a509 2
	WDC_LOG_REG(chp, wdr_sdh, reg);

d519 2
a520 2
void wdc_atapi_the_machine(struct channel_softc *, struct wdc_xfer *,
    enum atapi_context);
d522 1
a522 1
void wdc_atapi_the_poll_machine(struct channel_softc *, struct wdc_xfer *);
d694 1
a694 1
void wdc_atapi_update_status(struct channel_softc *);
a701 2
	WDC_LOG_STATUS(chp, chp->ch_status);

d703 1
a703 1
		wdc_set_drive(chp, 1);
a705 1
		WDC_LOG_STATUS(chp, chp->ch_status);
d708 1
a708 1
	if ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR) {
a709 2
		WDC_LOG_ERROR(chp, chp->ch_error);
	}
d739 1
a739 1
	wdc_set_drive(chp, xfer->drive);
a870 3
	WDC_LOG_ATAPI_CMD(chp, xfer->drive, xfer->c_flags,
	    cmdlen, cmd);
	
a1000 2
	WDC_LOG_REG(chp, wdr_cyl_lo, len);

a1001 1
	WDC_LOG_REG(chp, wdr_ireason, ire);
d1223 2
a1224 1
	if (!wdc_atapi_drive_selected(chp, xfer->drive)) {
d1226 1
a1226 1
		wdc_set_drive(chp, xfer->drive);
a1245 2
	WDC_LOG_REG(chp, wdr_ireason, ireason);

a1281 1
	WDC_LOG_REG(chp, wdr_ireason, ireason);
d1323 1
a1323 1
		wdc_set_drive(chp, xfer->drive);
a1343 6
		case ATAPI_PIOMODE_STATE:
			errstring = "Post-Identify";
			if (!(chp->ch_status & (WDCS_BSY | WDCS_DRQ)))
				trigger_timeout = 0;
			break;

a1419 6
		/* 
		 * Note, we can't go directly to set PIO mode
		 * because the drive is free to assert BSY
		 * after the transfer
		 */
		break;
d1421 1
a1532 1
	WDC_LOG_ATAPI_DONE(chp, xfer->drive, xfer->c_flags, sc_xfer->error);
d1604 2
@


1.54.2.3
log
@sync
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d95 3
a97 4
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_atapi_mask & (level)) != 0)	\
		printf args;				\
} while (0)
d1450 1
a1456 3
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
			goto ready;
d1467 8
a1474 1
			/* Downgrade straight to PIO mode 3 */
@


1.53
log
@Change scsi_[free|get]_xs to use pool(9); art@@ krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.52 2001/08/18 20:37:21 deraadt Exp $     */
d59 1
a59 1
#include <vm/vm.h>
@


1.52
log
@typo from 1.50; biorn@@chips.chalmers.se
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.51 2001/07/31 07:07:00 csapuntz Exp $     */
d232 3
@


1.51
log
@
Go down only one Ultra DMA mode at a time. Thanks to Matt Evans for
suggesting this fix.

Update atapiscsi Ultra DMA downgrade logic.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.50 2001/07/31 06:14:05 csapuntz Exp $     */
d98 1
a98 1
		lprintf args
@


1.50
log
@

On DMA timeouts, stop busmaster PCIIDE and reset channel. Avoid reading
device registers as this may cause lock-ups on some chipsets

Clean-up in atapiscsi. Get rid of claim_irq. Instead, atapiscsi always
returns -1 (maybe) from the interrupt handler.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.49 2001/07/21 09:08:49 csapuntz Exp $     */
a161 4
	int retries;
	int diagnostics_printed;
#define ATAPI_DIAG_UNEXP_CMD  0x01
#define ATAPI_DIAG_POLARITY   0x02
d259 5
a263 1
	
a793 3
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;

	wdc_enable_intr(chp);
d809 2
a810 1
	as->retries = 0;
d1088 1
a1088 1
			drvp->n_dmaerrs++;
d1166 1
a1166 1
		drvp->n_dmaerrs++;
a1523 2
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	int doing_dma = xfer->c_flags & C_DMA;
a1529 9
	if (drvp->n_dmaerrs ||
	    (sc_xfer->error != XS_NOERROR && sc_xfer->error != XS_SENSE &&
	    sc_xfer->error != XS_SHORTSENSE)) {
		drvp->n_dmaerrs = 0;
		if (doing_dma)
			wdc_downgrade_mode(drvp);
	} else {
		drvp->n_resets = 0;
	}
d1549 5
@


1.49
log
@Undo last fix to ata_wdc.c. Don't deregister timeout in generic code
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.48 2001/07/10 01:08:02 csapuntz Exp $     */
d95 1
a95 1
int wdcdebug_atapi_mask = 0x0;
d98 1
a98 1
		printf args
d126 1
a126 1
void  wdc_atapi_intr_for_us __P((struct channel_softc *, struct wdc_xfer *,
d158 1
a158 1
	enum atapi_state { as_none, as_cmdout, as_data, as_completed };
d318 1
d320 1
a320 1
	WDCDEBUG_PRINT(("wdc_atapi_send_cmd %s:%d:%d\n",
d345 11
d514 1
a514 1
int wdc_atapi_the_machine __P((struct channel_softc *, struct wdc_xfer *,
d517 1
a517 1
int wdc_atapi_the_poll_machine __P((struct channel_softc *, struct wdc_xfer *));
d564 2
a565 1
		return (wdc_atapi_the_machine(chp, xfer, ctxt_timer));
d568 3
a570 1
	return (wdc_atapi_the_machine(chp, xfer, ctxt_interrupt));
a576 1
	int claim_irq;
d579 1
a579 1
#define ARGS_INIT {-1, 0, 0, -1}
d581 1
a581 1
int
d600 1
a600 1
			return (0);
d618 1
a618 1
int
a624 1
	int claim_irq = 0;
d633 1
a633 1
			return (0);
d637 1
a637 1
		return (0);
a657 6
		if (retargs.claim_irq) {
			claim_irq = retargs.claim_irq;
			if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
				chp->wdc->irqack(chp);		
		}

d665 1
a665 1
			return (claim_irq);
d671 1
a671 1
			return (claim_irq);
d685 1
a685 1
	return (claim_irq);
a718 4
	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,
	    sc_xfer->flags), DEBUG_XFERS);

d726 1
a726 1
	if (!(xfer->c_flags & (C_POLL | C_SENSE)) && 
d741 5
d796 2
a811 1
	as->protocol_phase = as_cmdout;
d816 1
a816 1
	xfer->next = wdc_atapi_intr_for_us;
d823 4
d846 12
d879 1
a879 1
			xfer->next = wdc_atapi_done;
d890 8
a899 5
	if (xfer->c_bcount == 0 || (xfer->c_flags & C_DMA))
		as->protocol_phase = as_completed;
	else
		as->protocol_phase = as_data;

d922 8
d1007 3
d1062 1
a1062 1
	xfer->next = wdc_atapi_intr_for_us;
a1066 1

d1081 26
d1108 2
a1109 1
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
d1115 1
a1115 1
			xfer->c_bcount = 0;
d1136 1
a1136 1
				/* use the sense we just read */
d1201 1
a1201 1
wdc_atapi_intr_for_us(chp, xfer, timeout, ret)
a1207 1
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
d1210 1
a1210 3
#if 0
	WDCDEBUG_PRINT(("ATAPI_INTR\n"), DEBUG_INTR);
#endif
d1222 1
d1230 1
a1230 2
	if (as->protocol_phase != as_cmdout &&
	    (xfer->c_flags & C_MEDIA_ACCESS) &&
d1239 2
a1240 1
	ret->claim_irq = -1;
d1243 1
a1243 1
	WDCDEBUG_PRINT(("(%x, %x) ", chp->ch_status, ireason), DEBUG_INTR );
a1245 11
	case as_cmdout:
		if (timeout)
			goto timeout;

		if (!(chp->ch_status & WDCS_DRQ)) {
			return;
		}

		wdc_atapi_intr_command(chp, xfer, timeout, ret);
		return;

d1278 4
a1281 1
	printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
d1283 1
a1283 15
	    xfer->c_bcount, xfer->c_skip);
	
	if (xfer->c_flags & C_DMA) {
		ireason = CHP_READ_REG(chp, wdr_ireason);

		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
			chp->channel, xfer->drive);
		
		WDCDEBUG_PRINT(("Drive status: %02x %02x %02x\n", 
		    chp->ch_status, chp->ch_error, ireason),
		    DEBUG_ERRORS);
		
		drvp->n_dmaerrs++;
	}
a1367 2

	ret->claim_irq = -1;
@


1.48
log
@

Wait 1 second after soft reset.
Add back IDENTIFY after soft reset.
Fix ch_flags -> ch_status in a couple places
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.47 2001/07/03 01:42:20 niklas Exp $     */
d547 2
@


1.47
log
@obvious typo in condition; csapuntz@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.46 2001/07/02 04:58:52 ho Exp $     */
d76 7
a82 5
	ATAPI_PIOMODE_STATE = 2,
	ATAPI_PIOMODE_WAIT_STATE = 3,
	ATAPI_DMAMODE_STATE = 4,
	ATAPI_DMAMODE_WAIT_STATE = 5,
	ATAPI_READY_STATE = 6
d105 1
d1260 1
a1260 1
	wdc_atapi_update_status(chp);
d1262 12
a1273 2
	if ((chp->ch_flags & (WDCS_BSY | WDCS_DRQ)) && !timeout)
		return;
d1290 8
d1300 1
a1300 1
			if (chp->ch_flags & (WDCS_BSY | WDCS_DRQ))
d1307 1
a1307 1
			if (chp->ch_flags & (WDCS_BSY | WDCS_DRQ))
d1344 1
a1344 1
			drvp->state = ATAPI_PIOMODE_STATE;
d1350 1
a1350 1
		ret->delay = 500;
d1355 6
a1360 2
		drvp->state = ATAPI_PIOMODE_STATE;
		ret->delay = 500;
d1364 15
d1524 1
a1524 1
	drvp->state = ATAPI_PIOMODE_STATE;
d1531 1
a1531 1
	ret->delay = 150;
@


1.46
log
@Compile with WDCDEBUG.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.45 2001/06/25 22:31:29 csapuntz Exp $     */
d290 1
a290 1
		if (!link) {
@


1.45
log
@

Undo premature commit
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.44 2001/06/25 22:29:20 csapuntz Exp $     */
d317 1
a317 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, drive), DEBUG_XFERS);
@


1.44
log
@

Whoops, there's nothing at sc_link[1] any more
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.43 2001/06/25 19:31:51 csapuntz Exp $     */
a586 12
		}

		if (cold && retargs.expect_irq == 1) {
			xfer->endticks = 0;
			chp->ch_flags |= WDCF_IRQ_WAIT;
			while (xfer->endticks == 0 && 
			    (current_timeout * 1000) <= idx) {
				delay(1000);
				idx += 1000;
			}
			chp->ch_flags &= ~WDCF_IRQ_WAIT;
			continue;
@


1.43
log
@

Fix excessive resets and device probes by storing IDENTIFY results in the
drvp structure
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.42 2001/05/27 18:45:29 csapuntz Exp $     */
a286 1

d288 1
a288 2
		struct scsi_link *link = scsi->sc_link[drvp->drive][0];
		struct ata_drive_datas *drvp = &chp->ch_drive[drvp->drive];
d589 12
d623 4
a626 1
		if (ctxt != ctxt_process) 
d628 1
a667 3
		if (retargs.delay) 
			timeout_delay = max(retargs.delay * hz / 1000, 1);

d674 2
a675 1
		if (retargs.delay != 0)
d677 1
@


1.42
log
@

Cleanup of defines

Fix around the logic in the reset code to be more tolerant of weird devices.

Pause a long time after reset to allow device to reboot itself
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.41 2001/04/17 18:26:22 csapuntz Exp $     */
a148 3

int	wdc_atapi_get_params __P((struct channel_softc *, u_int8_t, 
				     struct ataparams *)); 
d158 1
d228 3
a230 4
	struct channel_softc *chp = aa_link->aa_bus_private;
	struct ataparams ids;
	struct ataparams *id = &ids;
	int drive;
d240 1
d250 3
a252 10
	for (drive = 0; drive < 2 ; drive++ ) {
		struct ata_drive_datas *drvp = &chp->ch_drive[drive];
			
		if ((drvp->drive_flags & DRIVE_ATAPI) &&
		    (wdc_atapi_get_params(chp, drive, id) == COMPLETE)) {
			/* Temporarily, the device will be called
			   atapiscsi. */
			strncpy(drvp->drive_name, as->sc_dev.dv_xname,
			    sizeof(drvp->drive_name) - 1);
			drvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;
d254 23
a276 26
			wdc_probe_caps(drvp, id); 

			WDCDEBUG_PRINT(
			    ("general config %04x capabilities %04x ",
			    id->atap_config, id->atap_capabilities1),
			    DEBUG_PROBE);

			drvp->drive_flags |= DRIVE_DEVICE_RESET;

			/* Tape drives do funny DSC stuff */
			if (ATAPI_CFG_TYPE(id->atap_config) == 
			    ATAPI_CFG_TYPE_SEQUENTIAL)
				drvp->atapi_cap |= ACAP_DSC;

			if ((id->atap_config & ATAPI_CFG_CMD_MASK) ==
			    ATAPI_CFG_CMD_16)
				drvp->atapi_cap |= ACAP_LEN;

			drvp->atapi_cap |=
			    (id->atap_config & ATAPI_CFG_DRQ_MASK);

			WDCDEBUG_PRINT(("driver caps %04x\n", drvp->atapi_cap),
			    DEBUG_PROBE);
		} else
			drvp->drive_flags &= ~DRIVE_ATAPI;
	}
d286 1
d288 5
a292 9
		for (drive = 0; drive < 2; drive++) {
			extern struct cfdriver scsibus_cd;

			struct scsibus_softc *scsi = scsibus_cd.cd_devs[bus];
			struct scsi_link *link = scsi->sc_link[drive][0];
			struct ata_drive_datas *drvp = &chp->ch_drive[drive];

			if (!link) continue;

d294 2
a295 2
				((struct device *)(link->device_softc))->dv_xname, 
				sizeof(drvp->drive_name) - 1);
d300 1
a300 1

a306 84
void
wdc_atapibus_attach(chp)
	struct channel_softc *chp;
{
	struct wdc_softc *wdc = chp->wdc;
	int channel = chp->channel;
	struct ata_atapi_attach aa_link;

	/*
	 * Fill in the adapter.
	 */
	bzero(&aa_link, sizeof(struct ata_atapi_attach));
	aa_link.aa_type = T_ATAPI;
	aa_link.aa_channel = channel;
	aa_link.aa_openings = 1;
	aa_link.aa_drv_data = NULL; 
	aa_link.aa_bus_private = chp;

	(void)config_found(&wdc->sc_dev, (void *)&aa_link, atapi_print);
}

int
wdc_atapi_get_params(chp, drive, id)
	struct channel_softc *chp;
	u_int8_t drive;
	struct ataparams *id;
{
	struct ata_drive_datas *drvp = &chp->ch_drive[drive];
	struct wdc_command wdc_c;
	int retries = 3;

	/* if no ATAPI device detected at wdc attach time, skip */
	/*
	 * XXX this will break scsireprobe if this is of any interest for
	 * ATAPI devices one day.
	 */
	if ((drvp->drive_flags & DRIVE_ATAPI) == 0) {
		WDCDEBUG_PRINT(("wdc_atapi_get_params: drive %d not present\n",
		    drive), DEBUG_PROBE);
		return (-1);
	}
	bzero(&wdc_c, sizeof(struct wdc_command));
	wdc_c.r_command = ATAPI_SOFT_RESET;
	wdc_c.r_st_bmask = 0;
	wdc_c.r_st_pmask = 0;
	wdc_c.flags = at_poll;
	wdc_c.timeout = ATAPI_RESET_WAIT;
	if (wdc_exec_command(drvp, &wdc_c) != WDC_COMPLETE) {
		printf("wdc_atapi_get_params: ATAPI_SOFT_RESET failed for"
		    " drive %s:%d:%d: driver failed\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive);
		panic("wdc_atapi_get_params");
	}
	if (wdc_c.flags & (AT_ERROR | AT_TIMEOU | AT_DF)) {
		WDCDEBUG_PRINT(("wdc_atapi_get_params: ATAPI_SOFT_RESET "
		    "failed for drive %s:%d:%d: error 0x%x\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive, 
		    wdc_c.r_error), DEBUG_PROBE);
		return (-1);
	}
	drvp->state = 0;

	CHP_READ_REG(chp, wdr_status);
	
	/* Some ATAPI devices need a bit more time after software reset. */
	delay(5000);

 retry:
	if (ata_get_params(drvp, at_poll, id) != 0) {
		WDCDEBUG_PRINT(("wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE "
		    "failed for drive %s:%d:%d\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive), 
		    DEBUG_PROBE);

		if (retries--) {
			delay(100000);
			goto retry;
		}

		return (-1);
	}

	return (COMPLETE);
}
d313 2
a314 3
	int drive = sc_xfer->sc_link->target;
	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[drive];
a315 1
	int flags = sc_xfer->flags;
d321 1
a321 1
	if (drive > 1 || !(drvp->drive_flags & DRIVE_ATAPI)) {
d326 2
a327 1
	xfer = wdc_get_xfer(flags & SCSI_NOSLEEP ? WDC_NOSLEEP : WDC_CANSLEEP);
d333 1
a333 1
	xfer->drive = drive;
a424 1
	int drive = sc_link->target;
d426 1
a426 1
	struct ata_drive_datas *drvp = &chp->ch_drive[drive];
d428 1
a428 1
	if (drive > 1)
@


1.41
log
@

Turn off DMA on REQUEST SENSE
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.40 2001/04/17 18:06:36 csapuntz Exp $     */
d73 9
a81 7
#define IDENTIFY        0
#define IDENTIFY_WAIT   1
#define PIOMODE		2
#define PIOMODE_WAIT	3
#define DMAMODE		4
#define DMAMODE_WAIT	5
#define READY		6
d93 1
a93 1
int wdcdebug_atapi_mask = 0;
a108 1
void  wdc_atapi_minphys __P((struct buf *bp));
a138 1
int   wdc_atapi_send_cmd __P((struct scsi_xfer *sc_xfer));
d167 4
d177 1
d270 2
a342 8
void
wdc_atapi_minphys (struct buf *bp)
{
	if(bp->b_bcount > MAX_SIZE)
		bp->b_bcount = MAX_SIZE;
	minphys(bp);
}

d509 26
d857 1
a857 1
		if (chp->ch_status & WDCS_BSY)
d862 1
a862 8
	if (drvp->state < READY) {
		if (drvp->state != IDENTIFY) {
			printf("%s:%d:%d: bad state %d in wdc_atapi_start\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel,
			    xfer->drive, drvp->state);
			panic("wdc_atapi_start: bad state");
		}

d1164 1
a1164 5

			sc_xfer->error = XS_RESET;
			xfer->next = wdc_atapi_reset;
			return;

d1326 2
d1332 4
d1344 2
a1356 35
	switch (drvp->state) {
	case IDENTIFY:
	case IDENTIFY_WAIT:
		errstring = "IDENTIFY";
		break;
		
	case PIOMODE:
		errstring = "Post IDENTIFY";
		break;

	case PIOMODE_WAIT:
		errstring = "PIOMODE";
		break;
	case DMAMODE_WAIT:
		errstring = "dmamode";
		break;
	default:
		errstring = "unknown state";
		break;
	}

	if (timeout) {
		if (drvp->state != IDENTIFY)
			goto timeout;
		else {
#ifdef DIAGNOSTIC
			printf ("wdc_atapi_ctrl: timeout before IDENTIFY."
			    "Should not happen\n");
#endif
			sc_xfer->error = XS_DRIVER_STUFFUP;
			xfer->next = wdc_atapi_done;
			return;
		}
	}

d1359 1
a1359 1
	if (chp->ch_status & WDCS_BSY)
d1366 4
d1371 5
a1375 2
		return;
	}
d1377 14
d1392 8
a1399 1
	ret->claim_irq = -1;
d1405 2
d1408 16
a1423 21
		/* You need to send an ATAPI drive an ATAPI-specific
		   command to revive it after a hard reset. Identify
		   is about the most innocuous thing you can do
		   that's guaranteed to be there */
	case IDENTIFY:
		wdccommandshort(chp, drvp->drive, ATAPI_IDENTIFY_DEVICE);
		drvp->state = IDENTIFY_WAIT;
		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
		break;
	
	case IDENTIFY_WAIT:
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
		/* We don't really care if this operation failed.
		   It's just there to wake the drive from its stupor. */
		if (!(chp->ch_status & WDCS_ERR)) {
			wdcbit_bucket(chp, 512);
	
			ret->timeout = 100;
			drvp->state = PIOMODE;
d1427 5
a1431 1
		drvp->state = PIOMODE;
d1433 7
a1439 1
	case PIOMODE:
d1449 1
a1449 1
		drvp->state = PIOMODE_WAIT;
d1453 1
a1453 1
	case PIOMODE_WAIT:
a1463 9
			 *
			 * If the drive fails the set PIO mode command,
			 * assume it just doesn't support the set PIO mode
			 * command.
			 *
			 * Ideally, we would program the channel controller
			 * to run at PIO mode 3. However, the channel
			 * controller is only running faster than PIO mode 3
			 * if the drive said it supported that. 
d1466 1
d1470 1
a1470 1
	case DMAMODE:
d1480 1
a1480 1
		drvp->state = DMAMODE_WAIT;
d1486 1
a1486 1
	case DMAMODE_WAIT:
d1493 1
a1493 1
	case READY:
d1495 1
a1495 1
		drvp->state = READY;
d1559 2
d1584 1
a1584 1
	drvp->state = 0;
d1586 1
d1591 1
a1591 1
	ret->delay = 10;
d1626 1
@


1.40
log
@

dma_status variable check is only valid for DMA transfers.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.39 2001/03/25 13:11:56 csapuntz Exp $     */
d793 1
a793 1
	if (!(xfer->c_flags & C_POLL) && 
d795 1
a795 1
	    (xfer->c_bcount > 100 || (xfer->c_flags & C_SENSE)))
@


1.39
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.38 2001/03/15 23:08:16 csapuntz Exp $     */
d1182 2
a1183 1
        if (chp->wdc->dma_status & ~WDC_DMAST_UNDER) {
d1534 1
a1534 1
	WDCDEBUG_PRINT(("wdc_atapi_done %s:%d:%d: flags 0x%x\n",
d1536 1
a1536 1
	    (u_int)xfer->c_flags), DEBUG_XFERS);
a1541 3
#if 0
		printf("wdc_atapi_done: sc_xfer->error %d\n", sc_xfer->error);
#endif
d1566 1
@


1.38
log
@Fix races between timeouts and interrupts.

Cleanup atapiscsi driver a bit by moving fields out of xfer.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.37 2001/03/05 16:04:12 ho Exp $     */
a125 1
int   wdc_atapi_dma_flags __P((struct wdc_xfer *));
d714 6
a719 2
		if (retargs.claim_irq) claim_irq = retargs.claim_irq;
		
d723 1
a723 1
			
d747 1
a893 14
int
wdc_atapi_dma_flags(xfer)
	struct wdc_xfer *xfer;
{
	struct scsi_xfer *sc_xfer = xfer->cmd;
	int dma_flags;

	dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
	    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;
	dma_flags |= (xfer->c_flags & C_POLL) ? WDC_DMA_POLL : 0;

	return (dma_flags);
}

d908 2
a909 3
	int  dma_flags;

	dma_flags = wdc_atapi_dma_flags(xfer);
d941 1
a941 2
		    chp->channel, xfer->drive, 
		    dma_flags);
a1053 8
	if (timeout) {
		printf ("wdc_atapi_intr_data: error: %s\n", message);
		
		sc_xfer->error = XS_RESET;
		xfer->next = wdc_atapi_reset;
		return;
	}

a1115 2
	int dma_err = 0;
	int dma_flags = wdc_atapi_dma_flags(xfer);
a1118 1
	/* turn off DMA channel */
d1120 3
a1122 2
		dma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		     chp->channel, xfer->drive, dma_flags);
d1124 4
a1127 2
		/* Assume everything was transferred */
		xfer->c_bcount = 0;
d1182 1
a1182 1
        if (dma_err < 0) { 
d1231 3
a1233 4
	if (timeout) {
		printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		    xfer->c_bcount, xfer->c_skip);
a1234 5
		if (xfer->c_flags & C_DMA)
			drvp->n_dmaerrs++;
		
		sc_xfer->error = XS_TIMEOUT;
		xfer->next = wdc_atapi_reset;
a1237 4

	if (chp->ch_status & WDCS_BSY)
		return;

d1242 3
a1244 2
		
		return;
d1250 3
d1264 4
a1267 1
		if (!(chp->ch_status & WDCS_DRQ))
d1269 1
d1277 3
d1287 3
d1303 18
d1402 2
d1431 2
d1472 2
@


1.37
log
@Convert to new timeout API. costa@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.36 2001/01/30 03:16:09 csapuntz Exp $     */
d112 14
a125 17
int   wdc_atapi_real_start __P((struct channel_softc *, struct wdc_xfer *,
    int));
int   wdc_atapi_real_start_2 __P((struct channel_softc *, struct wdc_xfer *,
    int));
int   wdc_atapi_intr_command __P((struct channel_softc *, struct wdc_xfer *,
    int));

int   wdc_atapi_intr_data __P((struct channel_softc *, struct wdc_xfer *,
    int));
int   wdc_atapi_intr_complete __P((struct channel_softc *, struct wdc_xfer *,
    int));

int   wdc_atapi_intr_for_us __P((struct channel_softc *, struct wdc_xfer *,
    int));

int   wdc_atapi_send_packet __P((struct channel_softc *, struct wdc_xfer *,
    int));
d127 2
a129 1
int   wdc_atapi_ctrl __P((struct channel_softc *, struct wdc_xfer *, int));
d133 6
a138 4

int   wdc_atapi_done __P((struct channel_softc *, struct wdc_xfer *, int));
int   wdc_atapi_reset __P((struct channel_softc *, struct wdc_xfer *, int));
int   wdc_atapi_reset_2 __P((struct channel_softc *, struct wdc_xfer *, int));
d141 2
a142 1
int   wdc_atapi_tape_done __P((struct channel_softc *, struct wdc_xfer *, int));
d151 2
a152 7
int	wdc_atapi_get_params __P((struct channel_softc *, u_int8_t, struct ataparams *)); 

int	atapi_dsc_wait __P((struct ata_drive_datas *, int));
int	atapi_dsc_ready __P((void *));
void    atapi_dsc_check __P((void *));
int	atapi_dsc_semiready __P((void *));
int	atapi_poll_wait __P((int (*) __P((void *)), void *, int, int, char *));
d443 1
a443 1
	timeout_set(&xfer->atapi_poll_to, wdc_atapi_timer_handler, xfer);
d598 2
a599 2
	struct wdc_xfer *xfer = arg;
	struct channel_softc *chp = xfer->chp;
d602 7
d610 1
a610 3

	/* There is a race here between us and the interrupt */
	s = splbio();
d632 8
a639 3
#define CONTINUE_POLL 0
#define GOTO_NEXT 1
#define DONE 2
d646 1
a646 1
	int  idx = 0, ret;
a648 1
	xfer->timeout = -1;
d651 1
d654 2
a655 3
		xfer->timeout = -1;
		xfer->delay = 0;
		xfer->expect_irq = 0;
d657 5
a661 1
		ret = (xfer->next)(chp, xfer, (current_timeout * 1000 <= idx));
d663 2
a664 2
		if (xfer->timeout != -1) {
			current_timeout = xfer->timeout;
d668 3
a670 3
		if (xfer->delay != 0) {
			delay (1000 * xfer->delay);
			idx += 1000 * xfer->delay;
d673 1
a673 13
		switch (ret) {
		case GOTO_NEXT:
			break;
			
	        case CONTINUE_POLL:
			DELAY(1);
			break;

		case DONE:
			wdc_free_xfer(chp, xfer);
			wdcstart(chp);
			return (0);
		}
d677 1
d684 1
a684 1
	int idx = 0, ret;
d688 1
a688 1

d697 17
a713 2
 do_op:
	idx++;
d715 16
a730 22
	xfer->timeout = -1;
	xfer->claim_irq = 0;
	xfer->delay = 0;

	ret = (xfer->next)(chp, xfer, 
			   xfer->endticks && (ticks - xfer->endticks >= 0));

	if (xfer->timeout != -1) 
		/*
		 * Add 1 tick to compensate for the fact that we can be just
		 * microseconds before the tick changes.
		 */
		xfer->endticks =
		    max((xfer->timeout * hz) / 1000, 1) + 1 + ticks;

	if (xfer->claim_irq) claim_irq = xfer->claim_irq;

	if (xfer->delay) timeout_delay = max(xfer->delay * hz / 1000, 1);

	switch (ret) {
	case GOTO_NEXT:
		if (xfer->expect_irq) {
a731 1
			xfer->expect_irq = 0;
d735 2
a736 2

		if (xfer->delay)
a738 6
		goto do_op;

	case CONTINUE_POLL:
		if (xfer->delay) break;
		if (idx >= 50) break;

a739 10
		goto do_op;

	case DONE:
		if (xfer->c_flags & C_POLL_MACHINE)
			timeout_del(&xfer->atapi_poll_to);

		wdc_free_xfer(chp, xfer);
		wdcstart(chp);

		return (claim_irq);
d766 2
a767 2
int
wdc_atapi_real_start(chp, xfer, timeout)
d771 1
d802 1
a802 1
	xfer->timeout = ATAPI_DELAY;
d804 1
a804 1
	return (GOTO_NEXT);
d808 2
a809 2
int
wdc_atapi_real_start_2(chp, xfer, timeout)
d813 1
d824 1
a824 1
		return (GOTO_NEXT);
d829 1
a829 1
			return (CONTINUE_POLL);
d842 1
a842 1
		return (GOTO_NEXT);
d846 1
a846 1
	return (GOTO_NEXT);
d850 2
a851 2
int
wdc_atapi_send_packet(chp, xfer, timeout)
d855 1
d881 1
a881 1
	xfer->timeout = sc_xfer->timeout;
d885 1
a885 1
		xfer->expect_irq = 1;
d887 1
a887 1
	return (GOTO_NEXT);
d904 2
a905 2
int
wdc_atapi_intr_command(chp, xfer, timeout)
d909 1
d943 1
a943 1
			return (GOTO_NEXT);
d961 1
a961 1
	xfer->expect_irq = 1;
d982 1
a982 1
	return (GOTO_NEXT);
d1037 2
a1038 2
int
wdc_atapi_intr_data(chp, xfer, timeout)
d1042 1
d1061 2
a1062 2
			xfer->delay = 100;
			return (CONTINUE_POLL);	
d1071 1
a1071 1
		return (GOTO_NEXT);
d1119 1
a1119 1
	xfer->expect_irq = 1;
d1122 1
a1122 1
	return (GOTO_NEXT);
d1126 2
a1127 2
int
wdc_atapi_intr_complete(chp, xfer, timeout)
d1131 1
a1131 1

d1159 1
a1159 1
				return (GOTO_NEXT);
d1169 1
a1169 1
			return (GOTO_NEXT);
d1197 1
a1197 1
				return (GOTO_NEXT);
d1207 1
a1207 1
		return (GOTO_NEXT);
d1227 1
a1227 1
	if (xfer->c_done) 
d1232 1
a1232 1
	return (GOTO_NEXT);
d1235 2
a1236 2
int
wdc_atapi_intr_for_us(chp, xfer, timeout)
d1240 1
a1240 1

d1261 1
a1261 1
		return (GOTO_NEXT);
d1266 1
a1266 1
		return (CONTINUE_POLL);
d1273 1
a1273 1
		return (CONTINUE_POLL);
d1279 2
a1280 2
		xfer->delay = 100;
		return (CONTINUE_POLL);
d1283 1
a1283 1
	xfer->claim_irq = 1;
d1291 1
a1291 1
			return (CONTINUE_POLL);
d1293 2
a1294 1
		return (wdc_atapi_intr_command(chp, xfer, timeout));
d1298 4
a1301 2
		    (ireason & 3) != 3)
			return (wdc_atapi_intr_data(chp, xfer, timeout));
d1306 2
a1307 2
			xfer->delay = 100;
			return (CONTINUE_POLL);
d1310 2
a1311 1
		return (wdc_atapi_intr_complete(chp, xfer, timeout));
d1317 1
a1317 1
		return (GOTO_NEXT);
d1321 2
a1322 2
int
wdc_atapi_ctrl(chp, xfer, timeout)
d1326 1
d1363 1
a1363 1
			return (GOTO_NEXT);
d1370 1
a1370 1
		return (CONTINUE_POLL);
d1377 1
a1377 1
		return (CONTINUE_POLL);
d1381 1
a1381 1
	xfer->claim_irq = 1;
d1395 2
a1396 2
		xfer->timeout = ATAPI_CTRL_WAIT;
		xfer->expect_irq = 1;
d1405 1
a1405 1
			xfer->timeout = 100;
d1423 2
a1424 2
		xfer->timeout = ATAPI_CTRL_WAIT;
		xfer->expect_irq = 1;
d1461 2
a1462 2
		xfer->timeout = ATAPI_CTRL_WAIT;
		xfer->expect_irq = 1;
d1476 1
a1476 1
	return (GOTO_NEXT);
d1483 1
a1483 1
	return (GOTO_NEXT);
d1487 2
a1488 2
int
wdc_atapi_tape_done(chp, xfer, timeout)
d1492 1
d1498 1
a1498 1
		return (GOTO_NEXT);
d1510 1
a1510 1
	return (GOTO_NEXT);
d1514 2
a1515 2
int
wdc_atapi_done(chp, xfer, timeout)
d1519 1
d1546 2
a1547 1
	return (DONE);
d1551 2
a1552 2
int
wdc_atapi_reset(chp, xfer, timeout)
d1556 1
d1567 3
a1569 3
	xfer->delay = 10;
	xfer->timeout = ATAPI_RESET_WAIT;
	return (GOTO_NEXT);
d1572 2
a1573 2
int
wdc_atapi_reset_2(chp, xfer, timeout)
d1577 1
d1590 1
a1590 1
		return (GOTO_NEXT);
d1596 1
a1596 1
		return (CONTINUE_POLL);
d1600 1
a1600 1
	return (GOTO_NEXT);
@


1.36
log
@

Ignore PIOMODE(0x4) errors
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.35 2001/01/29 02:18:33 niklas Exp $     */
d53 1
d447 2
d744 1
a744 1
			untimeout(wdc_atapi_timer_handler, xfer);
d752 1
a752 1
	timeout(wdc_atapi_timer_handler, xfer, timeout_delay);
@


1.35
log
@Fix bug where timeouts triggered too early, caused panic on ATAPI tapes.
Removed hardcoded WDCDEBUG definitions.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.34 2000/12/19 05:10:06 csapuntz Exp $     */
a79 1

a1427 2
			} else {
				goto error;
d1429 14
a1481 10
error:
	printf("%s:%d:%d: %s ",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    errstring);
	printf("error (0x%x)\n", chp->ch_error);

	sc_xfer->error = XS_DRIVER_STUFFUP;

	xfer->next = wdc_atapi_reset;
	return (GOTO_NEXT);
@


1.34
log
@

A DMA transfer of 4 bytes was failing to complete correctly
on a combination of VIA South Bridge and old Toshiba drive.

DMA transfers of 4 bytes  work for my old Mitsumi FX600 drive.

Assume Toshiba drive is in error.

Avoid situation by only invoking DMA transfers on transfers over 100 bytes.

Thanks to Tim Howe for the hardware for testing
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.33 2000/11/16 08:05:57 niklas Exp $     */
a80 2
#define WDCDEBUG

d608 1
d708 6
a713 1
		xfer->endticks = max((xfer->timeout * hz) / 1000, 1) + ticks;
@


1.33
log
@Fix timeout computation; ok csapuntz@@
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.32 2000/10/29 18:42:50 deraadt Exp $     */
d785 7
a791 1
	/* Adjust C_DMA, it may have changed if we are requesting sense */
d794 1
a794 1
	    (xfer->c_bcount > 0 || (xfer->c_flags & C_SENSE)))
d1570 1
a1570 1
		printf("%s:%d:%d: reset failed\n",
@


1.32
log
@undo this; adds files, unacceptable at this point in release
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.30 2000/08/11 03:59:47 csapuntz Exp $     */
d709 1
a709 1
		xfer->endticks = max((xfer->timeout * 1000) / hz, 1) + ticks;
@


1.31
log
@

Reduce footprint of ATA driver by only having PROBE debug messages compiled
in by default.
@
text
@d81 1
a81 1
#define WDCDEBUG_PROBE
d92 1
a93 2

#if defined(WDCDEBUG)
a100 6
#if defined(WDCDEBUG) || defined(WDCDEBUG_PROBE)
#define WDCDEBUG_PRINT_PROBE(args)  if (wdcdebug_atapi_mask & DEBUG_PROBE) printf args
#else
#define WDCDEBUG_PRINT_PROBE(args)
#endif

d239 1
d242 1
d267 4
a270 3
			WDCDEBUG_PRINT_PROBE(
				("general config %04x capabilities %04x ",
				id->atap_config, id->atap_capabilities1));
d284 2
a285 2
			WDCDEBUG_PRINT_PROBE(
				("driver caps %04x\n", drvp->atapi_cap));
d316 1
d319 1
d367 2
a368 2
		WDCDEBUG_PRINT_PROBE(("wdc_atapi_get_params: drive %d not present\n",
		    drive));
d384 1
a384 1
		WDCDEBUG_PRINT_PROBE(("wdc_atapi_get_params: ATAPI_SOFT_RESET "
d387 1
a387 1
		    wdc_c.r_error));
d399 1
a399 1
		WDCDEBUG_PRINT_PROBE(("wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE "
d401 2
a402 1
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive));
@


1.30
log
@

DMA transfers should transition to completed state directly too
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.29 2000/08/09 07:43:14 csapuntz Exp $     */
d81 1
a81 1
#define WDCDEBUG
d92 2
a94 1
int wdcdebug_atapi_mask = 0;
d102 6
a245 1
#ifdef WDCDEBUG
a247 1
#endif
d272 3
a274 4
			WDCDEBUG_PRINT(
			    ("general config %04x capabilities %04x ",
			    id->atap_config, id->atap_capabilities1),
			    DEBUG_PROBE);
d288 2
a289 2
			WDCDEBUG_PRINT(("driver caps %04x\n", drvp->atapi_cap),
			    DEBUG_PROBE);
a319 1
#ifdef WDCDEBUG
a321 1
#endif
d369 2
a370 2
		WDCDEBUG_PRINT(("wdc_atapi_get_params: drive %d not present\n",
		    drive), DEBUG_PROBE);
d386 1
a386 1
		WDCDEBUG_PRINT(("wdc_atapi_get_params: ATAPI_SOFT_RESET "
d389 1
a389 1
		    wdc_c.r_error), DEBUG_PROBE);
d401 1
a401 1
		WDCDEBUG_PRINT(("wdc_atapi_get_params: ATAPI_IDENTIFY_DEVICE "
d403 1
a403 2
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive), 
		    DEBUG_PROBE);
@


1.29
log
@

Fixes for the BCD 48SB CD-ROM C2.4, which seems to like to drop
both DRQ and BSY.

The driver has been adjusted to ignore invalid/unexpected phases
while traversing the state machine.

This may break drives that do no set ireason correctly.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.28 2000/07/20 07:40:33 csapuntz Exp $     */
d950 1
a950 1
	if (xfer->c_bcount == 0)
@


1.28
log
@

Fix to ATA detect. Some devices seem to be comatose after reset
(return 0x00 status persistently). Send them identify to wake them up.

Flag value 0x10000 will enable probe messages for a channel/controller.
When UKC supports setting flags, this will be useful debugging
failing IDE detects without kernel recompiles.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.27 2000/06/30 06:56:24 art Exp $     */
d69 11
a79 1
#include <dev/atapiscsi/atapiconf.h>
a942 5
	if (xfer->c_bcount == 0)
		as->protocol_phase = as_completed;
	else
		as->protocol_phase = as_data;

d950 5
d1085 2
a1086 1
		/* Exceptional case */
d1088 4
a1091 2
			printf("wdc_atapi_intr: warning: write only "
			    "%d of %d requested bytes\n", xfer->c_bcount, len);
d1135 1
a1135 2
	if (as->protocol_phase == as_data &&
	    xfer->c_flags & C_DMA) {
d1238 2
a1239 1

d1241 1
a1241 1

d1265 1
a1265 1

d1271 1
a1271 1
	    !(chp->ch_status & WDCS_DSC)) {
d1278 23
a1300 3
	if (chp->ch_status & WDCS_DRQ) {
		if (as->protocol_phase == as_cmdout)
			return (wdc_atapi_intr_command(chp, xfer, timeout));
d1302 5
a1306 1
		return (wdc_atapi_intr_data(chp, xfer, timeout));
a1307 2
	
	return (wdc_atapi_intr_complete(chp, xfer, timeout));
@


1.27
log
@Convert to new timeout API.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.26 2000/06/30 01:03:40 art Exp $     */
d71 2
d82 1
a82 1
#ifdef WDCDEBUG
d229 5
d305 5
@


1.26
log
@Convert some parts to new timeouts.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.25 2000/04/10 07:06:17 csapuntz Exp $     */
d716 1
a716 1
			untimeout (wdc_atapi_timer_handler, xfer);
@


1.25
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.24 2000/01/12 17:14:02 csapuntz Exp $     */
d698 1
a698 2
			timeout(wdctimeout, chp, xfer->endticks - ticks);

@


1.24
log
@

For reasons beyond my comprehension, touching the sdh register too much
during probe causes the devices pain.

So, I don't do that any more. :-)

Also, try ATAPI_IDENTIFY_DEVICE a couple times. Seems to help with an
old NEC drive.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.23 1999/12/19 22:57:52 csapuntz Exp $     */
d244 5
a248 2
			drvp->drv_softc = (struct device*)as;
			wdc_probe_caps(drvp, id);
d289 7
a295 4
			if (drvp->drv_softc == (struct device *)as && link) {
				drvp->drv_softc = link->device_softc;
				wdc_print_caps(drvp);
			}
d353 1
a353 1
	wdc_c.flags = AT_POLL;
d376 1
a376 1
	if (ata_get_params(drvp, AT_POLL, id) != 0) {
a1459 1
	int need_done = xfer->c_flags & C_NEEDDONE;
d1479 1
a1479 1
	if (need_done) {
@


1.24.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.41 2001/04/17 18:26:22 csapuntz Exp $     */
a52 1
#include <sys/timeout.h>
d69 1
a69 10
#include <scsi/scsiconf.h>

/* drive states stored in ata_drive_datas */
#define IDENTIFY        0
#define IDENTIFY_WAIT   1
#define PIOMODE		2
#define PIOMODE_WAIT	3
#define DMAMODE		4
#define DMAMODE_WAIT	5
#define READY		6
d80 1
a80 1
#if defined(WDCDEBUG)
d102 18
a119 16
void  wdc_atapi_real_start __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_real_start_2 __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_command __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_data __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_complete __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_intr_for_us __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_send_packet __P((struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *));
void  wdc_atapi_ctrl __P((struct channel_softc *, struct wdc_xfer *, 
    int, struct atapi_return_args *));
d121 1
d125 4
a128 6
void  wdc_atapi_done __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
void  wdc_atapi_reset __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
void  wdc_atapi_reset_2 __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
d131 1
a131 2
void  wdc_atapi_tape_done __P((struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *));
d140 7
a146 2
int	wdc_atapi_get_params __P((struct channel_softc *, u_int8_t, 
				     struct ataparams *)); 
a226 5
#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_atapi_mask |= DEBUG_PROBE;
#endif

d244 2
a245 5
			strncpy(drvp->drive_name, as->sc_dev.dv_xname,
			    sizeof(drvp->drive_name) - 1);
			drvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;

			wdc_probe_caps(drvp, id); 
d286 4
a289 7
			if (!link) continue;

			strncpy(drvp->drive_name, 
				((struct device *)(link->device_softc))->dv_xname, 
				sizeof(drvp->drive_name) - 1);
			
			wdc_print_caps(drvp);
a291 5

#ifdef WDCDEBUG
	if (chp->wdc->sc_dev.dv_cfdata->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		wdcdebug_atapi_mask &= ~DEBUG_PROBE;
#endif
d347 1
a347 1
	wdc_c.flags = at_poll;
d370 1
a370 1
	if (ata_get_params(drvp, at_poll, id) != 0) {
a420 2
	timeout_set(&xfer->atapi_poll_to, wdc_atapi_timer_handler, chp);

d574 2
a575 2
	struct channel_softc *chp = arg;
	struct wdc_xfer *xfer;
d578 3
a581 9
	xfer = TAILQ_FIRST(&chp->ch_queue->sc_xfer);
	if (xfer == NULL || 
	    !timeout_triggered(&xfer->atapi_poll_to)) {
		splx(s);
		return;
	}
	xfer->c_flags &= ~C_POLL_MACHINE;
	timeout_del(&xfer->atapi_poll_to);
	chp->ch_flags &= ~WDCF_IRQ_WAIT;
d602 3
a604 8
struct atapi_return_args {
	int timeout;
	int delay; 
	int expect_irq;
	int claim_irq;
};

#define ARGS_INIT {-1, 0, 0, -1}
d611 1
a611 1
	int  idx = 0;
d614 1
a616 1
		struct atapi_return_args retargs = ARGS_INIT;
d619 3
a621 2
		(xfer->next)(chp, xfer, (current_timeout * 1000 <= idx),
		    &retargs);
d623 1
a623 5
		if (xfer->next == NULL) {
			wdc_free_xfer(chp, xfer);
			wdcstart(chp);
			return (0);
		}
d625 2
a626 2
		if (retargs.timeout != -1) {
			current_timeout = retargs.timeout;
d630 3
a632 3
		if (retargs.delay != 0) {
			delay (1000 * retargs.delay);
			idx += 1000 * retargs.delay;
d635 13
a647 1
		DELAY(1);
a650 1

d657 1
a657 1
	int idx = 0;
d661 1
a661 1
	
d670 6
a675 17
	/* Don't go through more than 50 state machine steps
	   before yielding. This tries to limit the amount of time
	   spent at high SPL */
	for (idx = 0; idx < 50; idx++) {
		struct atapi_return_args retargs = ARGS_INIT;

		(xfer->next)(chp, xfer, 
		    xfer->endticks && (ticks - xfer->endticks >= 0),
		    &retargs);
		
		if (retargs.timeout != -1) 
			/*
			 * Add 1 tick to compensate for the fact that we 
			 * can be just microseconds before the tick changes.
			 */
			xfer->endticks =
			    max((retargs.timeout * hz) / 1000, 1) + 1 + ticks;
d677 2
a678 5
		if (retargs.claim_irq) {
			claim_irq = retargs.claim_irq;
			if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
				chp->wdc->irqack(chp);		
		}
d680 2
a681 3
		if (xfer->next == NULL) {
			if (xfer->c_flags & C_POLL_MACHINE)
				timeout_del(&xfer->atapi_poll_to);
d683 1
a683 5
			wdc_free_xfer(chp, xfer);
			wdcstart(chp);
			
			return (claim_irq);
		}
d685 1
a685 2
		if (retargs.delay) 
			timeout_delay = max(retargs.delay * hz / 1000, 1);
d687 3
a689 1
		if (retargs.expect_irq) {
d691 3
a693 1
			timeout_add(&chp->ch_timo, xfer->endticks - ticks);
d696 2
a697 2
		
		if (retargs.delay != 0)
d700 6
d707 10
d719 1
a719 1
	timeout_add(&xfer->atapi_poll_to, timeout_delay);
a720 1

d743 2
a744 2
void
wdc_atapi_real_start(chp, xfer, timeout, ret)
a747 1
	struct atapi_return_args *ret;
d758 2
a759 8
	/* 
	 * Only set the DMA flag if the transfer is reasonably large.
	 * At least one older drive failed to complete a 4 byte DMA transfer.
	 */

	/* Turn off DMA flag on REQUEST SENSE */

	if (!(xfer->c_flags & (C_POLL | C_SENSE)) && 
d761 1
a761 1
	    (xfer->c_bcount > 100))
d772 1
a772 1
	ret->timeout = ATAPI_DELAY;
d774 1
a774 1
	return;
d778 2
a779 2
void
wdc_atapi_real_start_2(chp, xfer, timeout, ret)
a782 1
	struct atapi_return_args *ret;
d793 1
a793 1
		return;
d798 1
a798 1
			return;
d811 1
a811 1
		return;
d815 1
a815 1
	return;
d819 2
a820 2
void
wdc_atapi_send_packet(chp, xfer, timeout, ret)
a823 1
	struct atapi_return_args *ret;
d849 1
a849 1
	ret->timeout = sc_xfer->timeout;
d853 1
a853 1
		ret->expect_irq = 1;
d855 15
a869 1
	return;
d872 2
a873 2
void
wdc_atapi_intr_command(chp, xfer, timeout, ret)
a876 1
	struct atapi_return_args *ret;
d885 3
a887 2
	int dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
	    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;
d910 1
a910 1
			return;
d916 5
d924 2
a925 1
		    chp->channel, xfer->drive);
d928 1
a928 6
	if (xfer->c_bcount == 0 || (xfer->c_flags & C_DMA))
		as->protocol_phase = as_completed;
	else
		as->protocol_phase = as_data;

	ret->expect_irq = 1;
d949 1
a949 1
	return;
d1004 2
a1005 2
void
wdc_atapi_intr_data(chp, xfer, timeout, ret)
a1008 1
	struct atapi_return_args *ret;
d1027 2
a1028 2
			ret->delay = 100;
			return;	
d1032 8
d1058 1
a1058 2
		/* Exceptional case - drive want to transfer more
		   data than we have buffer for */
d1060 2
a1061 4
			/* Wouldn't it be better to just abort here rather
			   than to write random stuff to drive? */
			printf("wdc_atapi_intr: warning: device requesting "
			    "%d bytes, only %d left in buffer\n", len, xfer->c_bcount);
d1082 1
a1082 1
	ret->expect_irq = 1;
d1085 1
a1085 1
	return;
d1089 2
a1090 2
void
wdc_atapi_intr_complete(chp, xfer, timeout, ret)
d1094 1
a1094 1
	struct atapi_return_args *ret;
d1099 2
d1104 5
a1108 4
	if (xfer->c_flags & C_DMA) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, chp->channel,
			xfer->drive);
d1110 2
a1111 4
		if (chp->wdc->dma_status & WDC_DMAST_UNDER) 
			xfer->c_bcount = 1;
		else
			xfer->c_bcount = 0;
d1123 1
a1123 1
				return;
d1133 1
a1133 1
			return;
d1161 1
a1161 1
				return;
d1166 1
a1166 2
        if ((xfer->c_flags & C_DMA) &&
	    (chp->wdc->dma_status & ~WDC_DMAST_UNDER)) {
d1171 1
a1171 1
		return;
d1191 1
a1191 1
	if (xfer->c_done)
d1196 1
a1196 1
	return;
d1199 2
a1200 2
void
wdc_atapi_intr_for_us(chp, xfer, timeout, ret)
d1204 1
a1204 1
	struct atapi_return_args *ret;
d1209 1
a1209 2
	u_int8_t ireason;
#if 0
d1211 1
a1211 1
#endif
d1214 4
a1217 3
	if (chp->ch_status & WDCS_BSY) {
		if (timeout)
			goto timeout;
d1219 6
a1224 1
		return;
d1227 4
d1236 1
a1236 2
		if (!timeout)
			return;
d1241 3
a1243 6
	    !(chp->ch_status & (WDCS_DSC | WDCS_DRQ))) {
		if (timeout)
			goto timeout;

		ret->delay = 100;
		return;
d1246 1
a1246 1
	ret->claim_irq = -1;
d1248 3
a1250 7
	ireason = CHP_READ_REG(chp, wdr_ireason);
	WDCDEBUG_PRINT(("(%x, %x) ", chp->ch_status, ireason), DEBUG_INTR );

	switch (as->protocol_phase) {
	case as_cmdout:
		if (timeout)
			goto timeout;
d1252 1
a1252 49
		if (!(chp->ch_status & WDCS_DRQ)) {
			return;
		}

		wdc_atapi_intr_command(chp, xfer, timeout, ret);
		return;

	case as_data:
		if ((chp->ch_status & WDCS_DRQ) ||
		    (ireason & 3) != 3) {
			if (timeout)
				goto timeout;

			wdc_atapi_intr_data(chp, xfer, timeout, ret);
			return;
		}

	case as_completed:
		if ((chp->ch_status & WDCS_DRQ) ||
		    (ireason & 3) != 3) {
			if (timeout)
				goto timeout;

			ret->delay = 100;
			return;
		}

		wdc_atapi_intr_complete(chp, xfer, timeout, ret);
		return;

	default:
		printf ("atapiscsi: Shouldn't get here\n");
		sc_xfer->error = XS_DRIVER_STUFFUP;
		xfer->next = wdc_atapi_reset;
		return;
	}

	return;
timeout:
	printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    xfer->c_bcount, xfer->c_skip);
	
	if (xfer->c_flags & C_DMA) {
		chp->wdc->dma_status =
		    (*chp->wdc->dma_finish)(chp->wdc->dma_arg, 
			chp->channel, xfer->drive);
		
		drvp->n_dmaerrs++;
d1255 1
a1255 3
	sc_xfer->error = XS_TIMEOUT;
	xfer->next = wdc_atapi_reset;
	return;
d1258 2
a1259 2
void
wdc_atapi_ctrl(chp, xfer, timeout, ret)
a1262 1
	struct atapi_return_args *ret;
d1299 1
a1299 1
			return;
d1306 1
a1306 1
		return;
d1313 1
a1313 1
		return;
d1317 1
a1317 1
	ret->claim_irq = -1;
d1331 2
a1332 2
		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
a1335 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
d1341 1
a1341 1
			ret->timeout = 100;
d1359 2
a1360 2
		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
a1362 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
d1367 2
a1369 14
			/* 
			 * All ATAPI drives are supposed to support
			 * PIO mode 3 or greater. 
			 *
			 * If the drive fails the set PIO mode command,
			 * assume it just doesn't support the set PIO mode
			 * command.
			 *
			 * Ideally, we would program the channel controller
			 * to run at PIO mode 3. However, the channel
			 * controller is only running faster than PIO mode 3
			 * if the drive said it supported that. 
			 */
			drvp->PIO_mode = 3;
d1385 2
a1386 2
		ret->timeout = ATAPI_CTRL_WAIT;
		ret->expect_irq = 1;
a1389 2
		if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
			chp->wdc->irqack(chp);
d1400 1
a1400 1
	return;
d1407 7
a1413 1
	return;
d1415 4
d1421 2
a1422 2
void
wdc_atapi_tape_done(chp, xfer, timeout, ret)
a1425 1
	struct atapi_return_args *ret;
d1431 1
a1431 1
		return;
d1443 1
a1443 1
	return;
d1447 2
a1448 2
void
wdc_atapi_done(chp, xfer, timeout, ret)
a1451 1
	struct atapi_return_args *ret;
d1454 1
d1458 1
a1458 1
	WDCDEBUG_PRINT(("wdc_atapi_done %s:%d:%d: flags 0x%x error 0x%x\n",
d1460 1
a1460 1
	    (u_int)xfer->c_flags, sc_xfer->error), DEBUG_XFERS);
d1466 3
d1474 1
a1474 1
	if (!(xfer->c_flags & C_POLL)) {
d1479 1
a1479 2
	xfer->next = NULL;
	return;
d1483 2
a1484 2
void
wdc_atapi_reset(chp, xfer, timeout, ret)
a1487 1
	struct atapi_return_args *ret;
a1490 1
	WDCDEBUG_PRINT(("wdc_atapi_reset\n"), DEBUG_XFERS);
d1498 3
a1500 3
	ret->delay = 10;
	ret->timeout = ATAPI_RESET_WAIT;
	return;
d1503 2
a1504 2
void
wdc_atapi_reset_2(chp, xfer, timeout, ret)
a1507 1
	struct atapi_return_args *ret;
d1513 1
a1513 1
		printf("%s:%d:%d: soft reset failed\n",
d1520 1
a1520 1
		return;
d1526 1
a1526 1
		return;
d1530 1
a1530 1
	return;
@


1.24.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.24.2.1 2001/05/14 22:23:07 niklas Exp $     */
d73 7
a79 9
enum atapi_drive_states {
	ATAPI_RESET_BASE_STATE = 0,
	ATAPI_DEVICE_RESET_WAIT_STATE = 1,
	ATAPI_PIOMODE_STATE = 2,
	ATAPI_PIOMODE_WAIT_STATE = 3,
	ATAPI_DMAMODE_STATE = 4,
	ATAPI_DMAMODE_WAIT_STATE = 5,
	ATAPI_READY_STATE = 6
};
d91 1
a91 1
int wdcdebug_atapi_mask = 0x0;
d107 1
d138 1
d149 3
a160 1
	int drive;
a166 4
void  wdc_atapi_minphys __P((struct buf *bp));
int   wdc_atapi_ioctl __P((struct scsi_link *, u_long, caddr_t, int));
int   wdc_atapi_send_cmd __P((struct scsi_xfer *sc_xfer));

a172 1
	wdc_atapi_ioctl
d225 4
a228 3
	struct ata_drive_datas *drvp = aa_link->aa_drv_data;
	struct channel_softc *chp = drvp->chnl_softc;
	struct ataparams *id = &drvp->id;
a237 1
	as->drive = drvp->drive;
d247 12
a258 3
	strncpy(drvp->drive_name, as->sc_dev.dv_xname,
	    sizeof(drvp->drive_name) - 1);
	drvp->cf_flags = as->sc_dev.dv_cfdata->cf_flags;
d260 22
a281 23
	wdc_probe_caps(drvp, id); 
	
	WDCDEBUG_PRINT(
		("general config %04x capabilities %04x ",
		    id->atap_config, id->atap_capabilities1),
		    DEBUG_PROBE);
	
	drvp->drive_flags |= DRIVE_DEVICE_RESET;
	
	/* Tape drives do funny DSC stuff */
	if (ATAPI_CFG_TYPE(id->atap_config) == 
	    ATAPI_CFG_TYPE_SEQUENTIAL)
		drvp->atapi_cap |= ACAP_DSC;
	
	if ((id->atap_config & ATAPI_CFG_CMD_MASK) ==
	    ATAPI_CFG_CMD_16)
		drvp->atapi_cap |= ACAP_LEN;
	
	drvp->atapi_cap |=
	    (id->atap_config & ATAPI_CFG_DRQ_MASK);
	
	WDCDEBUG_PRINT(("driver caps %04x\n", drvp->atapi_cap),
	    DEBUG_PROBE);
d291 10
a300 5
		extern struct cfdriver scsibus_cd;
		struct scsibus_softc *scsi = scsibus_cd.cd_devs[bus];
		struct scsi_link *link = scsi->sc_link[0][0];
		
		if (!link) {
d302 2
a303 2
			    ((struct device *)(link->device_softc))->dv_xname, 
			    sizeof(drvp->drive_name) - 1);
d308 1
a308 1
	
d315 92
d413 3
a415 2
 	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[as->drive];
d417 1
d421 1
a421 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive), DEBUG_XFERS);
d423 1
a423 1
	if (sc_xfer->sc_link->target != 0) {
d428 1
a428 2
	xfer = wdc_get_xfer(sc_xfer->flags & SCSI_NOSLEEP 
	    ? WDC_NOSLEEP : WDC_CANSLEEP);
d434 1
a434 1
	xfer->drive = as->drive;
a509 25
void
wdc_atapi_minphys (struct buf *bp)
{
	if(bp->b_bcount > MAX_SIZE)
		bp->b_bcount = MAX_SIZE;
	minphys(bp);
}

int
wdc_atapi_ioctl (sc_link, cmd, addr, flag)
	struct   scsi_link *sc_link;
	u_long   cmd;
	caddr_t  addr;
	int      flag;
{
	struct atapiscsi_softc *as = sc_link->adapter_softc;
	struct channel_softc *chp = as->chp;
	struct ata_drive_datas *drvp = &chp->ch_drive[as->drive];

	if (sc_link->target != 0)
		return ENOTTY;

	return (wdc_ioctl(drvp, cmd, addr, flag));
}

d689 1
a689 4
		if (ctxt != ctxt_process) {
			if (ctxt == ctxt_interrupt)
				xfer->endticks = 1;

a690 1
		}
d730 3
d739 1
a739 2
		if (retargs.delay != 0) {
			timeout_delay = max(retargs.delay * hz / 1000, 1);
a740 1
		}
d832 1
a832 1
		if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
d837 8
a844 1
	if (drvp->state < ATAPI_READY_STATE) {
d1146 5
a1150 1
			sc_xfer->error = XS_SHORTSENSE;
a1311 2
		ireason = CHP_READ_REG(chp, wdr_ireason);

a1315 4
		WDCDEBUG_PRINT(("Drive status: %02x %02x %02x\n", 
		    chp->ch_status, chp->ch_error, ireason),
		    DEBUG_ERRORS);
		
a1323 2


d1335 35
d1372 1
a1372 1
	if ((chp->ch_flags & (WDCS_BSY | WDCS_DRQ)) && !timeout)
d1379 2
a1382 2
	if (timeout) {
		int trigger_timeout = 1;
d1384 1
a1384 29
		switch (drvp->state) {
		case ATAPI_DEVICE_RESET_WAIT_STATE:
			errstring = "Device Reset Wait";
			drvp->drive_flags &= ~DRIVE_DEVICE_RESET;
			break;

		case ATAPI_PIOMODE_WAIT_STATE:
			errstring = "PIOMODE";
			if (chp->ch_flags & (WDCS_BSY | WDCS_DRQ))
				drvp->drive_flags &= ~DRIVE_MODE;
			else
				trigger_timeout = 0;
			break;
		case ATAPI_DMAMODE_WAIT_STATE:
			errstring = "dmamode";
			if (chp->ch_flags & (WDCS_BSY | WDCS_DRQ))
				drvp->drive_flags &= ~(DRIVE_DMA | DRIVE_UDMA);
			else 
				trigger_timeout = 0;
			break;

		default:
			errstring = "unknown state";
			break;
		}

		if (trigger_timeout)
			goto timeout;
	}
a1389 2
	ret->claim_irq = -1;

d1391 21
a1411 16
		/* My ATAPI slave device likes to assert DASP-/PDIAG- until 
		   it is DEVICE RESET. This causes the LED to stay on.

		   There is a trade-off here. This drive will cause any
		   play-back or seeks happening to be interrupted.

		   Note that the bus reset that triggered this state
		   (which may have been caused by the other drive on
		   the chain) need not interrupt this playback. It happens
		   to on my Smart & Friendly CD burner.

		   - csapuntz@@
		*/
	case ATAPI_RESET_BASE_STATE:
		if ((drvp->drive_flags & DRIVE_DEVICE_RESET) == 0) {
			drvp->state = ATAPI_PIOMODE_STATE;
d1415 1
a1415 5
		wdccommandshort(chp, drvp->drive, ATAPI_DEVICE_RESET);
		drvp->state = ATAPI_DEVICE_RESET_WAIT_STATE;
		ret->delay = 500;
		ret->timeout = ATAPI_RESET_WAIT;
		break;
d1417 1
a1417 7
	case ATAPI_DEVICE_RESET_WAIT_STATE:
		drvp->state = ATAPI_PIOMODE_STATE;
		ret->delay = 500;
		ret->timeout = ATAPI_RESET_WAIT;
		break;

	case ATAPI_PIOMODE_STATE:
d1427 1
a1427 1
		drvp->state = ATAPI_PIOMODE_WAIT_STATE;
d1431 1
a1431 1
	case ATAPI_PIOMODE_WAIT_STATE:
d1442 9
a1452 1
			chp->wdc->set_modes(chp);
d1456 1
a1456 1
	case ATAPI_DMAMODE_STATE:
d1466 1
a1466 1
		drvp->state = ATAPI_DMAMODE_WAIT_STATE;
d1472 1
a1472 1
	case ATAPI_DMAMODE_WAIT_STATE:
d1479 1
a1479 1
	case ATAPI_READY_STATE:
d1481 1
a1481 1
		drvp->state = ATAPI_READY_STATE;
a1544 2
	} else {
		drvp->n_resets = 0;
d1568 1
a1568 1
	drvp->state = ATAPI_PIOMODE_STATE;
a1569 1
	drvp->n_resets++;
d1574 1
a1574 1
	ret->delay = 150;
a1608 1

@


1.24.2.3
log
@I must have this fix from current:
revision 1.47
date: 2001/07/03 01:42:20;  author: niklas;  state: Exp;  lines: +2 -2
obvious typo in condition; csapuntz@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d290 1
a290 1
		if (link) {
@


1.24.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.24.2.3 2001/07/14 23:23:40 niklas Exp $     */
d76 5
a80 7
	ATAPI_IDENTIFY_STATE = 2,
	ATAPI_IDENTIFY_WAIT_STATE = 3,
	ATAPI_PIOMODE_STATE = 4,
	ATAPI_PIOMODE_WAIT_STATE = 5,
	ATAPI_DMAMODE_STATE = 6,
	ATAPI_DMAMODE_WAIT_STATE = 7,
	ATAPI_READY_STATE = 8
d93 1
a93 1
int wdcdebug_atapi_mask = 0;
a102 1
#define ATAPI_RESET_DELAY 1000
d123 1
a123 1
void  wdc_atapi_pio_intr __P((struct channel_softc *, struct wdc_xfer *,
d155 1
a155 1
	enum atapi_state { as_none, as_data, as_completed };
d159 4
a233 3
	/* Initialize shared data. */
	scsi_init();

d260 1
a260 5

	if ((NERRS_MAX - 2) > 0)
		drvp->n_dmaerrs = NERRS_MAX - 2;
	else
		drvp->n_dmaerrs = 0;
a314 1
	int idx;
d316 1
a316 1
	WDCDEBUG_PRINT(("wdc_atapi_send_cmd %s:%d:%d start\n",
a340 11
	WDCDEBUG_PRINT(("wdc_atapi_send_cmd %s:%d:%d ",
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive), 
	    DEBUG_XFERS | DEBUG_ERRORS);

	for (idx = 0; idx < sc_xfer->cmdlen; idx++) {
		WDCDEBUG_PRINT((" %02x", 
				   ((unsigned char *)sc_xfer->cmd)[idx]),
		    DEBUG_XFERS | DEBUG_ERRORS);
	}
	WDCDEBUG_PRINT(("\n"), DEBUG_XFERS | DEBUG_ERRORS);

d499 1
a499 1
void wdc_atapi_the_machine __P((struct channel_softc *, struct wdc_xfer *,
d502 1
a502 1
void wdc_atapi_the_poll_machine __P((struct channel_softc *, struct wdc_xfer *));
a543 2
	timeout_del(&chp->ch_timo);

d547 1
a547 2
		wdc_atapi_the_machine(chp, xfer, ctxt_timer);
		return (0);
d550 1
a550 3
	wdc_atapi_the_machine(chp, xfer, ctxt_interrupt);

	return (-1);
d557 1
d560 1
a560 1
#define ARGS_INIT {-1, 0, 0}
d562 1
a562 1
void
d581 1
a581 1
			return;
d599 1
a599 1
void
d606 1
d615 1
a615 1
			return;
d619 1
a619 1
		return;
d640 6
d653 1
a653 1
			return;
d659 1
a659 1
			return;
d673 1
a673 1
	return;
d707 4
d718 1
a718 1
	if (!(xfer->c_flags & (C_POLL | C_SENSE | C_MEDIA_ACCESS)) && 
a732 5
	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x, ATA flags 0x%x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive,
	    sc_xfer->flags, xfer->c_flags), DEBUG_XFERS);


d781 1
d797 2
a798 2
	if (xfer->c_flags & C_DMA)
		drvp->n_xfers++;
d802 1
a802 1
	xfer->next = wdc_atapi_intr_command;
a808 4

	WDCDEBUG_PRINT(("wdc_atapi_send_packet %s:%d:%d command sent\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive
	    ), DEBUG_XFERS);
a827 12
	
	wdc_atapi_update_status(chp);

	if ((chp->ch_status & WDCS_BSY) || !(chp->ch_status & WDCS_DRQ)) {
		if (timeout)
			goto timeout;

		return;
	}

	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
d849 1
a849 1
			xfer->next = wdc_atapi_reset;
d860 1
a860 6
		xfer->next = wdc_atapi_intr_complete;
	} else {
		if (xfer->c_bcount == 0)
			as->protocol_phase = as_completed;
		else
			as->protocol_phase = as_data;
d862 4
a865 2
		xfer->next = wdc_atapi_pio_intr;
	}
a888 8

 timeout:
	printf ("%s:%d:%d: device timeout waiting to send SCSI packet\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive);

	sc_xfer->error = XS_TIMEOUT;
	xfer->next = wdc_atapi_reset;
	return;
a965 3
		WDCDEBUG_PRINT(("wdc_atapi_intr: %s\n", message),
		    DEBUG_ERRORS);

d1018 1
a1018 1
	xfer->next = wdc_atapi_pio_intr;
d1023 1
a1037 26
		int retry;

		if (timeout) {
			chp->wdc->dma_status =
			    (*chp->wdc->dma_finish)
			    (chp->wdc->dma_arg, chp->channel,
				xfer->drive);

			sc_xfer->error = XS_TIMEOUT;
			ata_dmaerr(drvp);

			xfer->next = wdc_atapi_reset;
			return;
		}

		for (retry = 5; retry > 0; retry--) {
			wdc_atapi_update_status(chp);
			if ((chp->ch_status & (WDCS_BSY | WDCS_DRQ)) == 0)
				break;
			DELAY(5);
		}
		if (retry == 0) {
			ret->expect_irq = 1;
			return;
		}
		
d1039 1
a1039 2
		    (*chp->wdc->dma_finish)
		    (chp->wdc->dma_arg, chp->channel,
d1045 1
a1045 1
			xfer->c_bcount = 0;		
d1066 1
a1066 1
			/* use the sense we just read */
d1098 1
a1098 1
		ata_dmaerr(drvp);
d1131 1
a1131 1
wdc_atapi_pio_intr(chp, xfer, timeout, ret)
d1138 1
d1141 3
a1143 1

a1154 1
		WDCDEBUG_PRINT(("wdc_atapi_intr_for_us: wrong drive selected\n"), DEBUG_INTR);
d1162 2
a1163 1
	if ((xfer->c_flags & C_MEDIA_ACCESS) &&
d1172 1
a1172 2
	if (chp->wdc->cap & WDC_CAPABILITY_IRQACK)
		chp->wdc->irqack(chp);
d1175 1
a1175 1
	WDCDEBUG_PRINT(("Phase %d, (%x, %x) ", as->protocol_phase, chp->ch_status, ireason), DEBUG_INTR );
d1178 11
d1221 6
a1226 1
	ireason = CHP_READ_REG(chp, wdr_ireason);
d1228 10
a1237 4
	printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d, "
	    "status=%02x, ireason=%02x\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
	    xfer->c_bcount, xfer->c_skip, chp->ch_status, ireason);
d1257 1
a1257 1
 	wdc_atapi_update_status(chp);
d1259 2
a1260 12
	if (!timeout) {
		switch (drvp->state) {
		case ATAPI_IDENTIFY_WAIT_STATE:
			if (chp->ch_status & WDCS_BSY)
				return;
			break;
		default:
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
				return;
			break;
		}
	}
a1276 8
		case ATAPI_IDENTIFY_WAIT_STATE:
			errstring = "Identify";
			if (!(chp->ch_status & WDCS_BSY) &&
			    (chp->ch_status & (WDCS_DRQ | WDCS_ERR)))
				trigger_timeout = 0;

			break;

d1279 1
a1279 1
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
d1286 1
a1286 1
			if (chp->ch_status & (WDCS_BSY | WDCS_DRQ))
d1305 2
d1323 1
a1323 1
			drvp->state = ATAPI_IDENTIFY_STATE;
d1329 1
a1329 1
		ret->delay = ATAPI_RESET_DELAY;
d1334 2
a1335 6
		/* fall through */

	case ATAPI_IDENTIFY_STATE:
		wdccommandshort(chp, drvp->drive, ATAPI_IDENTIFY_DEVICE);
		drvp->state = ATAPI_IDENTIFY_WAIT_STATE;
		ret->delay = 10;
a1338 15
	case ATAPI_IDENTIFY_WAIT_STATE: {
		int idx = 0;

		while ((chp->ch_status & WDCS_DRQ) &&
		    idx++ < 20) {
			wdcbit_bucket(chp, 512);

			DELAY(1);
			wdc_atapi_update_status(chp);
		}

		drvp->state = ATAPI_PIOMODE_STATE;
	}
		/* fall through */

d1445 2
d1453 9
a1480 5
	
	if (drvp->state == 0) {
		xfer->next = wdc_atapi_done;
		return;
	}
d1484 1
a1484 1
	drvp->state = ATAPI_IDENTIFY_STATE;
d1491 1
a1491 1
	ret->delay = ATAPI_RESET_DELAY;
@


1.24.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d59 1
a59 1
#include <uvm/uvm_extern.h>
@


1.24.2.6
log
@Merge in trunk
@
text
@d70 2
d165 1
a165 2
int   wdc_atapi_ioctl __P((struct scsi_link *,
	u_long, caddr_t, int, struct proc *));
d434 1
a434 1
wdc_atapi_ioctl (sc_link, cmd, addr, flag, p)
a438 1
	struct proc *p;
d447 1
a447 1
	return (wdc_ioctl(drvp, cmd, addr, flag, p));
@


1.24.2.7
log
@Merge in -current from about a week ago
@
text
@a68 1
#include <dev/ic/wdcevent.h>
d110 1
a110 1
void  wdc_atapi_start(struct channel_softc *,struct wdc_xfer *);
d112 1
a112 1
void  wdc_atapi_timer_handler(void *);
d114 26
a139 26
void  wdc_atapi_real_start(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_real_start_2(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_command(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_data(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_intr_complete(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_pio_intr(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_send_packet(struct channel_softc *, struct wdc_xfer *,
    int, struct atapi_return_args *);
void  wdc_atapi_ctrl(struct channel_softc *, struct wdc_xfer *, 
    int, struct atapi_return_args *);

char  *wdc_atapi_in_data_phase(struct wdc_xfer *, int, int);

int   wdc_atapi_intr(struct channel_softc *, struct wdc_xfer *, int);
void  wdc_atapi_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
void  wdc_atapi_reset_2(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
d141 2
a142 2
void  wdc_atapi_tape_done(struct channel_softc *, struct wdc_xfer *,
	int, struct atapi_return_args *);
d148 3
a150 3
int	atapiscsi_match(struct device *, void *, void *);
void	atapiscsi_attach(struct device *, struct device *, void *);
int     atapi_to_scsi_sense(struct scsi_xfer *, u_int8_t);
d162 4
a165 4
void  wdc_atapi_minphys(struct buf *bp);
int   wdc_atapi_ioctl(struct scsi_link *,
	u_long, caddr_t, int, struct proc *);
int   wdc_atapi_send_cmd(struct scsi_xfer *sc_xfer);
d499 1
a499 1
int wdc_atapi_drive_selected(struct channel_softc *, int);
a507 2
	WDC_LOG_REG(chp, wdr_sdh, reg);

d517 2
a518 2
void wdc_atapi_the_machine(struct channel_softc *, struct wdc_xfer *,
    enum atapi_context);
d520 1
a520 1
void wdc_atapi_the_poll_machine(struct channel_softc *, struct wdc_xfer *);
d692 1
a692 1
void wdc_atapi_update_status(struct channel_softc *);
a699 2
	WDC_LOG_STATUS(chp, chp->ch_status);

d701 1
a701 1
		wdc_set_drive(chp, 1);
a703 1
		WDC_LOG_STATUS(chp, chp->ch_status);
d706 1
a706 1
	if ((chp->ch_status & (WDCS_BSY | WDCS_ERR)) == WDCS_ERR) {
a707 2
		WDC_LOG_ERROR(chp, chp->ch_error);
	}
d737 1
a737 1
	wdc_set_drive(chp, xfer->drive);
a868 3
	WDC_LOG_ATAPI_CMD(chp, xfer->drive, xfer->c_flags,
	    sc_xfer->cmdlen, sc_xfer->cmd);

a998 2
	WDC_LOG_REG(chp, wdr_cyl_lo, len);

a999 1
	WDC_LOG_REG(chp, wdr_ireason, ire);
d1221 2
a1222 1
	if (!wdc_atapi_drive_selected(chp, xfer->drive)) {
d1224 1
a1224 1
		wdc_set_drive(chp, xfer->drive);
a1243 2
	WDC_LOG_REG(chp, wdr_ireason, ireason);

a1279 1
	WDC_LOG_REG(chp, wdr_ireason, ireason);
d1321 1
a1321 1
		wdc_set_drive(chp, xfer->drive);
a1530 1
	WDC_LOG_ATAPI_DONE(chp, xfer->drive, xfer->c_flags, sc_xfer->error);
d1602 2
@


1.24.2.8
log
@Sync the SMP branch with 3.3
@
text
@d95 3
a97 4
#define WDCDEBUG_PRINT(args, level) do {		\
	if ((wdcdebug_atapi_mask & (level)) != 0)	\
		printf args;				\
} while (0)
a152 2
enum atapi_state { as_none, as_data, as_completed };

d157 1
d878 2
a879 2
	    cmdlen, cmd);
	
a1357 6
		case ATAPI_PIOMODE_STATE:
			errstring = "Post-Identify";
			if (!(chp->ch_status & (WDCS_BSY | WDCS_DRQ)))
				trigger_timeout = 0;
			break;

a1433 6
		/* 
		 * Note, we can't go directly to set PIO mode
		 * because the drive is free to assert BSY
		 * after the transfer
		 */
		break;
d1435 1
d1438 1
a1444 3
		/* SET FEATURES 0x08 is only for PIO mode > 2 */
		if (drvp->PIO_mode <= 2)
			goto ready;
d1455 8
a1462 1
			/* Downgrade straight to PIO mode 3 */
@


1.24.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d59 2
d94 1
a94 4
#ifndef WDCDEBUG_ATAPI_MASK
#define WDCDEBUG_ATAPI_MASK 0x00
#endif
int wdcdebug_atapi_mask = WDCDEBUG_ATAPI_MASK;
d130 1
a130 1
void  wdc_atapi_ctrl(struct channel_softc *, struct wdc_xfer *,
d170 1
a170 1
static struct scsi_adapter atapiscsi_switch =
d179 1
a179 1
static struct scsi_device atapiscsi_dev =
a249 1
	as->sc_adapterlink.luns = 1;
d252 1
d258 2
a259 2
	wdc_probe_caps(drvp, id);

d270 1
a270 1

d272 1
a272 1
	if (ATAPI_CFG_TYPE(id->atap_config) ==
d275 1
a275 1

d279 1
a279 1

d282 1
a282 1

d286 1
a286 1

d289 1
a289 1
	config_found((struct device *)as,
d297 1
a297 1

d299 2
a300 2
			strncpy(drvp->drive_name,
			    ((struct device *)(link->device_softc))->dv_xname,
d302 1
a302 1

d306 1
a306 1

d333 1
a333 1
	xfer = wdc_get_xfer(sc_xfer->flags & SCSI_NOSLEEP
d351 1
a351 1
	    chp->wdc->sc_dev.dv_xname, chp->channel, as->drive),
d355 1
a355 1
		WDCDEBUG_PRINT((" %02x",
d377 1
a377 1
				xfer->transfer_len =
d389 2
a390 2
				    _3btol(((struct scsi_rw_tape *)
					sc_xfer->cmd)->len),
d548 1
a548 1
	if (xfer == NULL ||
d583 1
a583 1
	int delay;
d592 1
a592 1
	struct wdc_xfer *xfer;
d629 1
a629 1
	struct wdc_xfer *xfer;
d635 1
a635 1

d654 1
a654 1
		(xfer->next)(chp, xfer,
d657 2
a658 2

		if (retargs.timeout != -1)
d660 1
a660 1
			 * Add 1 tick to compensate for the fact that we
d672 1
a672 1

d681 1
a681 1

d732 1
a732 1
	/*
d739 1
a739 1
	if (!(xfer->c_flags & (C_POLL | C_SENSE | C_MEDIA_ACCESS)) &&
d782 1
a782 1

d786 1
a786 1

d817 1
a817 1
	wdccommand(chp, xfer->drive, ATAPI_PKT_CMD,
d819 1
a819 1
	    0, 0, 0,
d857 1
a857 1

d876 1
a876 1
	} else
d881 1
a881 1

d889 1
a889 1
		    chp->channel, xfer->drive, xfer->databuf,
d971 1
a971 1

d984 1
a984 1

d1029 1
a1029 1
			return;
d1033 1
a1033 1

d1039 1
a1039 1

d1061 2
a1062 2

			CHP_WRITE_RAW_MULTI_2(chp, NULL,
d1067 1
a1067 1

d1101 5
d1123 1
a1123 1

d1127 1
a1127 1
			xfer->drive, 1);
d1129 1
a1129 1
		if (chp->wdc->dma_status & WDC_DMAST_UNDER)
d1132 1
a1132 1
			xfer->c_bcount = 0;
d1148 1
a1148 1
			 * request sense failed ! it's not supposed
d1158 1
a1158 1
			 * use the short sense we saved previously.
d1180 1
a1180 1
		}
d1191 1
a1191 1

d1211 1
a1211 1
	else
d1303 1
a1303 1

d1377 1
a1377 1
			else
d1395 1
a1395 1
		/* My ATAPI slave device likes to assert DASP-/PDIAG- until
d1442 1
a1442 1
		/*
d1542 1
a1542 1

d1577 1
a1577 1

d1606 1
a1606 1

d1613 1
a1613 1

@


1.24.2.10
log
@Merge with the trunk
@
text
@d365 2
a366 2
		WDCDEBUG_PRINT(("about to send cmd 0x%x ",
		    sc_xfer->cmd->opcode), DEBUG_DSC);
a637 2
		wdc_disable_intr(chp);

d755 1
a755 2
	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x, "
	    "ATA flags 0x%x\n",
a1009 1
	int tohost;
a1033 2
	tohost = ((sc_xfer->flags & SCSI_DATA_IN) != 0 ||
	    (xfer->c_flags & C_SENSE) != 0);
d1037 1
a1037 1
		    "st 0x%b err 0x%x "
d1039 1
a1039 2
		    len, chp->ch_status, WDCS_BITS, chp->ch_error, ire),
		    DEBUG_INTR);
d1042 1
a1042 1
		if (!tohost)
d1054 1
a1054 1
		if (!tohost) {
d1257 1
a1257 2
	WDCDEBUG_PRINT(("Phase %d, (0x%b, 0x%x) ", as->protocol_phase,
	    chp->ch_status, WDCS_BITS, ireason), DEBUG_INTR );
d1296 1
a1296 1
	    "status=0x%b, ireason=0x%x\n",
d1298 1
a1298 1
	    xfer->c_bcount, xfer->c_skip, chp->ch_status, WDCS_BITS, ireason);
d1555 1
a1555 3
	if (xfer->c_flags & C_POLL) {
		wdc_enable_intr(chp);
	} else {
@


1.23
log
@

Improve timeout handling in poll machine

Fix for some non-ATAPI-4 compliant drives
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.22 1999/12/14 08:23:35 csapuntz Exp $     */
d270 1
a322 6

/*
 *  The scsi_cmd interface works as follows:
 *
 */

d331 1
d368 2
d372 9
a380 3
		    "failed for drive %s:%d:%d: error 0x%x\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, drive, 
		    wdc_c.r_error), DEBUG_PROBE);
d383 1
d536 11
a1211 3
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
	DELAY (1);

d1231 8
d1303 1
a1303 2
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
	delay (1);
a1304 2
	wdc_atapi_update_status(chp);
	
d1307 9
@


1.22
log
@

Various fixes:

Use ticks not time. Ticks is monotonically increasing.

Fix error output in wdc_atapi_ctrl

ATAPI errors -> SCSI errors conversion now works better

Other minor cleanup
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.21 1999/12/11 20:53:03 csapuntz Exp $     */
d614 4
a617 1
		if (xfer->delay != 0) delay (1000 * xfer->delay);
a624 1

d1004 8
a1011 1
		if (!timeout)
d1013 1
d1019 1
@


1.21
log
@

Cleanup.

Better timeout logic
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.20 1999/12/11 10:15:02 csapuntz Exp $     */
d147 1
a147 1
void    atapi_to_scsi_sense __P((struct scsi_xfer *, u_int8_t));
d482 7
a488 1
void    
d494 4
a497 1
	
d503 1
a503 1
	if ((flags & 0x4) && (sense->flags == 0)) {
d506 1
d523 2
d528 1
d614 1
a614 4
		if (xfer->delay != 0) {
			while (xfer->delay--)
				delay(1000);
		}
d641 1
a641 1
	u_int64_t now = (u_int64_t)time.tv_sec * 1000 + time.tv_usec / 1000;
d659 2
a660 1
	ret = (xfer->next)(chp, xfer, xfer->endtime && (now >= xfer->endtime));
d662 2
a663 7
	if (xfer->timeout != -1) {
		now = (u_int64_t)time.tv_sec * 1000 + 
		    time.tv_usec / 1000;

		xfer->endtime = (u_int64_t)xfer->timeout + now;

	}
d674 1
a674 2
			timeout(wdctimeout, chp, 
			    (xfer->endtime - now) * hz / 1000);
d1013 1
a1013 1

d1015 5
a1019 4
	  WDCDEBUG_PRINT(("wdc_atapi_intr: c_bcount %d len %d st 0x%x err 0x%x "
			  "ire 0x%x\n", xfer->c_bcount,
			  len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);

d1121 2
a1122 4
		        /* save the short sense */
			sc_xfer->error = XS_SHORTSENSE;
			atapi_to_scsi_sense(sc_xfer, chp->ch_error);
			if ((sc_xfer->sc_link->quirks &
d1185 5
a1203 5
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (xfer->drive << 4));
	DELAY (1);

	wdc_atapi_update_status(chp);

d1236 21
d1261 2
a1262 1
			printf ("wdc_atapi_ctrl: timeout during IDENTIFY."
d1264 1
a1264 1

a1297 2
		errstring = "IDENTIFY";
		
a1302 2
			errstring = "Post IDENTIFY";

a1324 1
		errstring = "piomode";
a1351 1
		errstring = "dmamode";
d1353 1
a1353 1
			goto error;
d1376 3
a1378 2
	sc_xfer->error = XS_SHORTSENSE;
	atapi_to_scsi_sense(sc_xfer, chp->ch_error);
@


1.20
log
@

ATAPI Tape drive support. Should be considered experimental.

Major restructuring of the code path that sends ATAPI packet commands.
One set of functions works in polling, process, and interrupt contexts.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.19 1999/11/17 01:22:55 csapuntz Exp $     */
a79 1
#define WDCDEBUG
d100 1
a100 1
void  timer_handler __P((void *));
d122 1
a122 1
int   wdc_atapi_in_data_phase __P((struct wdc_xfer *, int, int));
d153 2
a154 1
	enum atapi_state { as_none, as_cmdout, as_data } protocol_phase;
d542 1
a542 1
timer_handler(arg)
d583 1
a583 1
	int  current_timeout;
d649 1
a649 1
	ret = (xfer->next)(chp, xfer, now >= xfer->endtime);
d688 1
a688 1
			untimeout (timer_handler, xfer);
d696 1
a696 1
	timeout(timer_handler, xfer, timeout_delay);
d726 1
d728 1
d734 1
a863 1
	xfer->claim_irq = 1;
d893 4
a896 1
	as->protocol_phase = as_data;
d930 1
a930 1
int
d936 1
d939 5
d974 1
a974 1
	return (1);
d978 1
a978 1
	return (0);
d990 1
d996 13
a1008 3
	if (!wdc_atapi_in_data_phase(xfer, len, ire))
		return (CONTINUE_POLL);
	
d1181 13
a1193 1
	/* If we missed an IRQ and were using DMA, flag it as a DMA error */
a1194 2
	/* We should really wait_for_unbusy here too before 
	   switching drives. */
d1200 2
a1201 16
	if (chp->ch_status & WDCS_BSY) {
		if (timeout) {
			printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
			    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
			    xfer->c_bcount, xfer->c_skip);

			if (xfer->c_flags & C_DMA)
				drvp->n_dmaerrs++;

			sc_xfer->error = XS_TIMEOUT;
			xfer->next = wdc_atapi_reset;
			return (GOTO_NEXT);
		} else {
			return (CONTINUE_POLL);
		}
	}
a1211 3
	if ((xfer->c_flags & C_TIMEOU) && (xfer->c_flags & C_DMA))
		drvp->n_dmaerrs++;

d1215 2
a1216 5
	       
		if (!(xfer->c_flags & C_DMA))
			return (wdc_atapi_intr_data(chp, xfer, timeout));
		else
			return (CONTINUE_POLL);
d1232 13
a1244 1
	/* Ack interrupt done in wait_for_unbusy */
d1248 1
a1248 8
	if (timeout) {
		if (drvp->state == IDENTIFY_WAIT ||
		    drvp->state == PIOMODE ||
		    drvp->state == PIOMODE_WAIT ||
		    drvp->state == DMAMODE_WAIT)
			goto timeout;
	} else {
		wdc_atapi_update_status(chp);
d1250 2
a1251 3
		if (chp->ch_status & WDCS_BSY)
			return (CONTINUE_POLL);
	}
a1257 3

	/* Don't timeout during configuration */
	xfer->c_flags &= ~C_TIMEOU;
@


1.19
log
@

New interface to ATA registers that goes through the lower-level device
driver (pciide, wdc, etc.)

Remove #define WDCDEBUG from top of files

More fixes to ATAPISCSI logic:

Not all devices transition correctly between phases. Devices are supposed
to keep BSY high until they've set the registers to the next sensible
state. Some devices drop BSY and leave the registers in an old or
nonsense state. Our polling code is extremely sensitive to this
(though an early itnerrupt could also observe this). So, if the device is
in an unexpected state, the new polling code waits for a while in the hope
that it enters a better state.

This seems to fix many of the problems reported.

Also, there was a horrible bug which would cause sense to fail on a ATAPI
command that sent data to the drive
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.18 1999/11/02 01:43:40 deraadt Exp $     */
d80 1
d93 1
d100 25
d126 4
a129 3
int   wdc_atapi_ctrl __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdc_atapi_done __P((struct channel_softc *, struct wdc_xfer *));
void  wdc_atapi_reset __P((struct channel_softc *, struct wdc_xfer *));
d132 1
d145 1
d392 1
a392 5
	int s, ret, saved_datalen;
	char saved_len_bytes[3];

restart:
	saved_datalen = 0;
a420 1
		xfer->c_flags |= C_NEEDDONE;
d424 2
d431 4
a434 6
				saved_datalen = sc_xfer->datalen;
				xfer->c_flags &= ~C_NEEDDONE;
				sc_xfer->datalen = xfer->c_bcount = 0;
				bcopy(
				    ((struct scsi_rw_tape *)sc_xfer->cmd)->len,
				    saved_len_bytes, 3);
d438 1
d444 3
a446 2
				    _3btol(((struct scsi_rw_tape *)
				    sc_xfer->cmd)->len), sc_xfer->datalen),
d457 1
a460 1
		case WRITE_FILEMARK:
d462 2
a463 4
			/* DSC will change to command completion mode.
			   We can reflect this early.  */
			drvp->drive_flags &= ~DRIVE_DSCBA;
			WDCDEBUG_PRINT(("clear DCSBA\n"), DEBUG_DSC);
d473 1
a473 2
	if (((sc_xfer->flags & SCSI_POLL) != 0 ||
	     (drvp->atapi_cap & ACAP_DSC) != 0) &&
a476 8
	if ((drvp->atapi_cap & ACAP_DSC) && saved_datalen != 0) {
		sc_xfer->datalen = saved_datalen;
		bcopy(saved_len_bytes,
		    ((struct scsi_rw_tape *)sc_xfer->cmd)->len, 3);
		sc_xfer->flags &= ~ITSDONE;
		splx(s);
		goto restart;
	}
d519 11
d535 191
a727 1
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
d735 1
a735 1
	    (sc_xfer->datalen > 0 || (xfer->c_flags & C_SENSE)))
d740 22
a761 1
	if (wdc_select_drive(chp, xfer->drive, ATAPI_DELAY) < 0) {
d764 1
d766 7
a772 2
		wdc_atapi_reset(chp, xfer);
		return;
d783 3
a785 14
		wdc_atapi_ctrl(chp, xfer, 0);
		return;
	}
	
	if (drvp->atapi_cap & ACAP_DSC) {
		if (atapi_dsc_wait(drvp, sc_xfer->timeout)) {
			sc_xfer->error = XS_TIMEOUT;
			wdc_atapi_reset(chp, xfer);
			return;
		}
		WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, DSC asserted\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive),
		    DEBUG_DSC);
		drvp->drive_flags &= ~DRIVE_DSCWAIT;
d787 15
d820 4
a823 32
	/*
	 * If there is no interrupt for CMD input, busy-wait for it (done in 
	 * the interrupt routine. If it is a polled command, call the interrupt
	 * routine until command is done.
	 */
	if (((drvp->atapi_cap & ATAPI_CFG_DRQ_MASK) != ATAPI_CFG_IRQ_DRQ) ||
	    (sc_xfer->flags & SCSI_POLL) || (drvp->atapi_cap & ACAP_DSC)) {
		/* Wait for at last 400ns for status bit to be valid */
		DELAY(1);
		wdc_atapi_intr(chp, xfer, 0);
	} else {
		chp->ch_flags |= WDCF_IRQ_WAIT;
		timeout(wdctimeout, chp, hz);
		return;
	}

	if ((sc_xfer->flags & SCSI_POLL) || (drvp->atapi_cap & ACAP_DSC)) {
		while ((sc_xfer->flags & ITSDONE) == 0) {
			if (drvp->atapi_cap & ACAP_DSC) {
				if (atapi_poll_wait(
					(drvp->drive_flags & DRIVE_DSCWAIT) ?
					    atapi_dsc_ready : atapi_dsc_semiready,
					    drvp, sc_xfer->timeout, PZERO + PCATCH,
					    "atapist")) {
					sc_xfer->error = XS_TIMEOUT;
					wdc_atapi_reset(chp, xfer);
					return;
				}
			} else
				/* Wait for at last 400ns for status bit to
				   be valid */
				DELAY(1);
d825 3
a827 2
			wdc_atapi_intr(chp, xfer, 0);
		}
d829 1
d833 2
a834 2
atapi_dsc_semiready(arg)
	void *arg;
d836 2
a837 2
	struct ata_drive_datas *drvp = arg;
	struct channel_softc *chp = drvp->chnl_softc;
d839 3
a841 3
	/* We should really wait_for_unbusy here too before 
	   switching drives. */
	CHP_WRITE_REG(chp, wdr_sdh, WDSD_IBM | (drvp->drive << 4));
d843 1
a843 1
	return (wait_for_unbusy(chp, 0) == 0);
a845 6

int wdc_atapi_intr_command __P((struct channel_softc *, struct wdc_xfer *, int));
int wdc_atapi_intr_data __P((struct channel_softc *, struct wdc_xfer *, int));
int wdc_atapi_intr_complete __P((struct channel_softc *, struct wdc_xfer *, int));


d847 1
a847 1
wdc_atapi_intr_command(chp, xfer, dma_flags)
d850 1
a850 1
	int dma_flags;
d859 4
d883 3
a885 2
			wdc_atapi_done(chp, xfer);
			return (1);
d900 1
a900 5
	if ((sc_xfer->flags & SCSI_POLL) == 0 &&
	    (drvp->atapi_cap & ACAP_DSC) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT;
		timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
	}
d905 2
a906 3
		if (!(drvp->drive_flags & DRIVE_DSCBA) &&
		    (sc_xfer->cmd->opcode == READ ||
			sc_xfer->cmd->opcode == WRITE)) {
d909 9
a918 2
		if (sc_xfer->cmd->opcode == READ)
			drvp->drive_flags |= DRIVE_DSCWAIT;
a919 1
	return (1);
d921 1
d924 1
d926 1
a926 2
wdc_atapi_intr_data(chp, xfer, dma_flags)
	struct channel_softc *chp;
d928 1
a928 2
	int dma_flags;

d931 1
a931 21
	struct ata_drive_datas *drvp = &chp->ch_drive[xfer->drive];
	struct atapiscsi_softc *as = sc_xfer->sc_link->adapter_softc;
	int len, ire;
	char *message = 0;

	len = (CHP_READ_REG(chp, wdr_cyl_hi) << 8) |
	    CHP_READ_REG(chp, wdr_cyl_lo);
	ire = CHP_READ_REG(chp, wdr_ireason);

	WDCDEBUG_PRINT(("wdc_atapi_intr: c_bcount %d len %d st 0x%x err 0x%x "
	    "ire 0x%x :", xfer->c_bcount,
	    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);

	/* Possibility to explore; what if we get an interrupt
	   during DMA ? */
	if ((xfer->c_flags & C_DMA) != 0) {
		if ((xfer->c_flags & C_TIMEOU) == 0)
			message = "unexpected interrupt during DMA mode";

		goto unexpected_state;
	}
d943 1
a943 1
	
d962 25
d988 4
d1027 2
a1028 9
	if ((sc_xfer->flags & SCSI_POLL) == 0 &&
	    (drvp->atapi_cap & ACAP_DSC) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT;
		timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
	} else if (drvp->atapi_cap & ACAP_DSC)
		drvp->drive_flags |= DRIVE_DSCWAIT;
	return (1);

 unexpected_state:
d1030 1
a1030 30
	/* If we're in polling mode, then it's possible we caught
	   a drive in some awkward, intermediate state. Of course,
	   the drive should have BSY set while it's transitioning
           through awkward states, but this may not always
           be the case. */

	/* Spurious interrupts can cause us pain too and we don't deal
	   with those nearly as well. We assume the spurious
	   interrupts are random and won't affect us on retry */
	if (xfer->c_flags & C_POLL) {
		DELAY(1000);
		as->retries++;
		/* Give the drive up to 2 seconds to fix itself */
		if (as->retries <= 2000)
			return (1);
	}

	if (message) 
		printf ("wdc_atapi_intr_drq: %s\n", message);

	if (xfer->c_flags & C_DMA) {
		(*chp->wdc->dma_finish)(chp->wdc->dma_arg,
		    chp->channel, xfer->drive, dma_flags);
		drvp->n_dmaerrs++;
	}

	sc_xfer->error = XS_RESET;
	wdc_atapi_reset(chp, xfer);

	return (1);
d1035 1
a1035 1
wdc_atapi_intr_complete(chp, xfer, dma_flags)
d1038 1
a1038 1
	int dma_flags;
d1045 1
d1055 2
a1056 6
		/* Assume everything was transferred 
		   XXX - maybe we want to check the error register here */
		if (xfer->c_flags & C_SENSE)
			xfer->c_bcount -= sizeof(sc_xfer->sense);
		else
			xfer->c_bcount -= sc_xfer->datalen;
d1067 2
a1068 2
				wdc_atapi_done(chp, xfer);
				return (1);
d1077 3
a1079 2
			wdc_atapi_reset(chp, xfer);
			return (1);
d1103 1
a1103 2
				xfer->c_bcount =
					sizeof(sc_xfer->sense);
d1105 1
d1107 2
a1108 2
				wdc_atapi_start(chp, xfer);
				return (1);
d1110 1
a1110 1
		} 
d1116 3
a1118 2
		wdc_atapi_reset(chp, xfer);
		return (1);
d1136 8
a1143 2
	wdc_atapi_done(chp, xfer);
	return (1);
d1147 1
a1147 1
wdc_atapi_intr(chp, xfer, irq)
d1150 2
a1151 1
	int irq;
a1155 1
	int dma_flags = 0;
d1157 1
a1157 3
	WDCDEBUG_PRINT(("wdc_atapi_intr %s:%d:%d\n",
			chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive), 
		       DEBUG_INTR);
d1159 1
a1159 7
	/* Is it not a transfer, but a control operation? */
	if (drvp->state < READY) {
		printf("%s:%d:%d: bad state %d in wdc_atapi_intr\n",
		       chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		       drvp->state);
		panic("wdc_atapi_intr: bad state\n");
	}
d1164 9
d1174 16
a1189 13
	/* Ack interrupt done in wait_for_unbusy */
	if (wait_for_unbusy(chp,
			    (irq == 0) ? sc_xfer->timeout : 0) != 0) {
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
			return (0); /* IRQ was not for us */
		printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
		       chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		       xfer->c_bcount, xfer->c_skip);
		if (xfer->c_flags & C_DMA)
			drvp->n_dmaerrs++;
		sc_xfer->error = XS_TIMEOUT;
		wdc_atapi_reset(chp, xfer);
		return (1);
d1191 3
a1193 1
	/* If we missed an IRQ and were using DMA, flag it as a DMA error */
a1196 9
	/* DRQ was dropped. This means the command is over.
	   Do cleanup, check for errors, etc. */
	if (xfer->c_flags & C_DMA) {
		dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
			     (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;
		dma_flags |= ((sc_xfer->flags & SCSI_POLL) ||
			      (drvp->atapi_cap & ACAP_DSC)) ? WDC_DMA_POLL : 0;
	}

d1199 4
a1202 1
			return (wdc_atapi_intr_command(chp, xfer, dma_flags));
d1204 4
a1207 3
			return (wdc_atapi_intr_data(chp, xfer, dma_flags));
	} else
		return (wdc_atapi_intr_complete(chp, xfer, dma_flags));	
d1211 1
a1211 1
wdc_atapi_ctrl(chp, xfer, irq)
d1214 1
a1214 1
	int irq;
a1218 1
	int delay;
d1221 18
a1238 2
again:
	delay = (xfer->c_flags & C_POLL) ? 4000 : ((irq == 0) ? ATAPI_DELAY : 1);
a1242 7
	/* We shouldn't have to select the drive in these states.
	   If we do, there are other, more serious problems */
	if (drvp->state != IDENTIFY_WAIT &&
	    drvp->state != PIOMODE_WAIT &&
	    drvp->state != DMAMODE_WAIT)
		wdc_select_drive(chp, xfer->drive, delay);

d1254 2
a1260 6
		/* Some ATAPI devices need to try to read the media
		   before responding. Well, let's hope resets while
		   polling are few and far between */
		if (wdcwait(chp, 0, 0, delay))
			goto timeout;

d1268 3
a1270 2
			if (wdcwait(chp, WDCS_DRQ, 0, 100))
				goto timeout;
d1274 1
d1286 2
a1290 2
		if (wait_for_unbusy(chp, delay))
			goto timeout;
d1312 3
d1316 1
a1318 2
		if (wait_for_unbusy(chp, delay))
			goto timeout;
d1326 2
a1327 11
		xfer->c_intr = wdc_atapi_intr;
		wdc_atapi_start(chp, xfer);
		return (1);
	}
	if ((sc_xfer->flags & SCSI_POLL) == 0 &&
	    (drvp->atapi_cap & ACAP_DSC) == 0) {
		chp->ch_flags |= WDCF_IRQ_WAIT;
		xfer->c_intr = wdc_atapi_ctrl;
		timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
	} else {
		goto again;
d1329 1
a1329 1
	return (1);
a1331 3
	if (irq && (xfer->c_flags & C_TIMEOU) == 0) {
		return (0); /* IRQ was not for us */
	}
d1335 3
a1337 2
	wdc_atapi_reset(chp, xfer);
	return (1);
d1345 27
a1371 2
	wdc_atapi_reset(chp, xfer);
	return (1);
d1374 3
a1376 2
void
wdc_atapi_done(chp, xfer)
d1379 1
d1389 1
a1389 2
	/* remove this command from xfer queue */
	wdc_free_xfer(chp, xfer);
d1401 1
a1401 1
	    
a1405 12
	WDCDEBUG_PRINT(("wdcstart from wdc_atapi_done, flags 0x%x\n",
	    chp->ch_flags), DEBUG_XFERS);
	wdcstart(chp);
}

/* Wait until DSC gets asserted.  */
int
atapi_dsc_wait(drvp, timo)
	struct ata_drive_datas *drvp;
	int timo;
{
	struct channel_softc *chp = drvp->chnl_softc;
d1407 1
a1407 9
	chp->ch_flags &= ~WDCF_ACTIVE;
#if 0
	/* XXX Something like this may be needed I have not investigated
	   close enough yet.  If so we may need to put it back after
	   the poll wait.  */
	TAILQ_REMOVE(&chp->ch_queue->sc_xfer, xfer, c_xferchain);
#endif
	return (atapi_poll_wait(atapi_dsc_ready, drvp, timo, PZERO + PCATCH,
	    "atapidsc"));
a1409 13
int
atapi_dsc_ready(arg)
	void *arg;
{
	struct ata_drive_datas *drvp = arg;
	struct channel_softc *chp = drvp->chnl_softc;

	if (chp->ch_flags & WDCF_ACTIVE)
		return (0);
	wdc_select_drive(chp, drvp->drive, 0);
	chp->ch_status = CHP_READ_REG(chp, wdr_status);
	return ((chp->ch_status & (WDCS_BSY | WDCS_DSC)) == WDCS_DSC);
}
d1412 1
a1412 39
atapi_poll_wait(ready, arg, timo, pri, msg)
	int (*ready) __P((void *));
	void *arg;
	int timo;
	int pri;
	char *msg;
{
	int maxtic, tic = 0, error;
	u_int64_t starttime = time.tv_sec * 1000 + time.tv_usec / 1000;
	u_int64_t endtime = starttime + timo;

	while (1) {
		WDCDEBUG_PRINT(("atapi_poll_wait: msg=%s tic=%d\n", msg, tic),
		    DEBUG_POLL);
		if (ready(arg))
			return (0);

#if 0
		/* Exponential backoff.  */
		tic = tic + tic + 1;
#else
		tic = min(hz / 100, 1);
#endif
		maxtic = (int)
		    (endtime - (time.tv_sec * 1000 + time.tv_usec / 1000));
		if (maxtic <= 0)
			return (EWOULDBLOCK);
		if (tic > maxtic)
			tic = maxtic;
		if (tic > ATAPI_POLL_MAXTIC)
			tic = ATAPI_POLL_MAXTIC;
		error = tsleep(arg, pri, msg, tic);
		if (error != EWOULDBLOCK)
			return (error);
	}
}

void
wdc_atapi_reset(chp, xfer)
d1415 1
a1417 1
	struct scsi_xfer *sc_xfer = xfer->cmd;
d1420 1
d1425 5
a1429 1
	delay(5000);
d1431 10
a1440 2
	drvp->state = 0;
	if (wdcwait(chp, WDCS_DRQ, 0, ATAPI_RESET_WAIT) != 0) {
d1446 3
d1451 8
a1458 2
	wdc_atapi_done(chp, xfer);
	return;
d1460 1
@


1.18
log
@re-enable IDENTIFY, reset delay each time
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.17 1999/10/29 22:00:31 csapuntz Exp $     */
a70 1
#define WDCDEBUG
d126 1
d338 1
a338 1
	bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
a359 1
	struct wdc_softc *wdc = chp->wdc;
d369 1
a369 1
	    wdc->sc_dev.dv_xname, chp->channel, drive), DEBUG_XFERS);
d570 1
d619 1
a619 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (drvp->drive << 4));
d625 4
a628 1
int wdc_atapi_intr_drq __P((struct channel_softc *, struct wdc_xfer *, int));
d631 1
a631 1
wdc_atapi_intr_drq(chp, xfer, irq)
d634 1
a634 2
	int irq;

d639 1
a639 3
	int len, phase, i;
	int ire;
	int dma_flags = 0;
d644 14
d659 7
a665 4
		dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
		    (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;
		dma_flags |= ((sc_xfer->flags & SCSI_POLL) ||
		    (drvp->atapi_cap & ACAP_DSC)) ? WDC_DMA_POLL : 0;
d668 1
d670 1
a670 2
	if (as->protocol_phase == as_cmdout) {
		bzero(cmd, sizeof(cmd));
d672 6
a677 21
		if (xfer->c_flags & C_SENSE) {
			cmd_reqsense = (struct scsi_sense *)&cmd[0];
			cmd_reqsense->opcode = REQUEST_SENSE;
			cmd_reqsense->length = xfer->c_bcount;
		} else 
			bcopy(sc_xfer->cmd, cmd, sc_xfer->cmdlen);

		for (i = 0; i < 12; i++)
			WDCDEBUG_PRINT(("%02x ", cmd[i]), DEBUG_INTR);
		WDCDEBUG_PRINT((": PHASE_CMDOUT\n"), DEBUG_INTR);

		/* Init the DMA channel if necessary */
		if (xfer->c_flags & C_DMA) {
			if ((*chp->wdc->dma_init)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, xfer->databuf, 
			    xfer->c_bcount, dma_flags) != 0) {
				sc_xfer->error = XS_DRIVER_STUFFUP;
				wdc_atapi_done(chp, xfer);
				return (1);
			}
		}
d679 5
d685 13
a697 1
		wdc_output_bytes(drvp, cmd, cmdlen);
d699 1
a699 1
		as->protocol_phase = as_data;
d701 5
a705 6
		/* Start the DMA channel if necessary */
		if (xfer->c_flags & C_DMA) {
			(*chp->wdc->dma_start)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, 
			    dma_flags);
		}
d707 6
a712 5
		if ((sc_xfer->flags & SCSI_POLL) == 0 &&
		    (drvp->atapi_cap & ACAP_DSC) == 0) {
			chp->ch_flags |= WDCF_IRQ_WAIT;
			timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
		}
d714 3
a716 14
		/* If we read/write to a tape we will get into buffer
		   availability mode.  */
		if (drvp->atapi_cap & ACAP_DSC) {
			if (!(drvp->drive_flags & DRIVE_DSCBA) &&
			    (sc_xfer->cmd->opcode == READ ||
				sc_xfer->cmd->opcode == WRITE)) {
				drvp->drive_flags |= DRIVE_DSCBA;
				WDCDEBUG_PRINT(("set DSCBA\n"), DEBUG_DSC);
			}
			if (sc_xfer->cmd->opcode == READ)
				drvp->drive_flags |= DRIVE_DSCWAIT;
		}
 		return (1);
	}
a717 8
	if (as->protocol_phase != as_data) {
		panic ("wdc_atapi_intr_drq: bad protocol phase");
	}

	len = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_lo) +
		256 * bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_hi);
	ire = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_ireason);
	phase = (ire & (WDCI_CMD | WDCI_IN)) | (chp->ch_status & WDCS_DRQ);
d725 2
a726 2
		printf("wdc_atapi_intr_drq: Unexpected "
		    "interrupt during DMA mode");
d728 1
a728 1
		goto abort_data;
d731 4
d736 4
a739 6
	if (ire & WDCI_CMD) {
		/* Something messed up */
		if (!(as->diagnostics_printed & ATAPI_DIAG_UNEXP_CMD)) {
			printf ("wdc_atapi_intr_drq: Unexpectedly "
			    "in the command phase. Please report this.\n");
			as->diagnostics_printed |= ATAPI_DIAG_UNEXP_CMD;
a740 2
		goto abort_data;
	}
d742 10
a751 7
	/* Make sure polarities match */
	if (((ire & WDCI_IN) == WDCI_IN) ==
	    ((sc_xfer->flags & SCSI_DATA_OUT) == SCSI_DATA_OUT)) {
		if (!(as->diagnostics_printed & ATAPI_DIAG_POLARITY)) {
			printf ("wdc_atapi_intr_drq: Polarity problem "
			    "in transfer. Please report this.\n");
			as->diagnostics_printed |= ATAPI_DIAG_POLARITY;
a752 1
		goto abort_data;
a754 2
	WDCDEBUG_PRINT(("PHASE_DATA\n"), DEBUG_INTR);
	
d756 2
a757 3
		printf("wdc_atapi_intr_drq: length 0 transfer in "
		    "data phase\n");
	        goto abort_data;
d759 1
a759 1
	  
d780 2
a781 3
			for (i = xfer->c_bcount; i < len; i += 2)
				bus_space_write_2(chp->cmd_iot, chp->cmd_ioh,
				    wd_data, 0);
d804 22
a825 1
 abort_data:
d840 1
a840 1
wdc_atapi_intr(chp, xfer, irq)
d843 2
a844 1
	int irq;
a849 48
	int dma_flags = 0;

	WDCDEBUG_PRINT(("wdc_atapi_intr %s:%d:%d\n",
			chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive), 
		       DEBUG_INTR);

	/* Is it not a transfer, but a control operation? */
	if (drvp->state < READY) {
		printf("%s:%d:%d: bad state %d in wdc_atapi_intr\n",
		       chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		       drvp->state);
		panic("wdc_atapi_intr: bad state\n");
	}

	/* We should really wait_for_unbusy here too before 
	   switching drives. */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
			  WDSD_IBM | (xfer->drive << 4));

	/* Ack interrupt done in wait_for_unbusy */
	if (wait_for_unbusy(chp,
			    (irq == 0) ? sc_xfer->timeout : 0) != 0) {
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
			return (0); /* IRQ was not for us */
		printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
		       chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		       xfer->c_bcount, xfer->c_skip);
		if (xfer->c_flags & C_DMA)
			drvp->n_dmaerrs++;
		sc_xfer->error = XS_TIMEOUT;
		wdc_atapi_reset(chp, xfer);
		return (1);
	}
	/* If we missed an IRQ and were using DMA, flag it as a DMA error */
	if ((xfer->c_flags & C_TIMEOU) && (xfer->c_flags & C_DMA))
		drvp->n_dmaerrs++;

	if (chp->ch_status & WDCS_DRQ) 
		return (wdc_atapi_intr_drq(chp, xfer, irq));
	
	/* DRQ was dropped. This means the command is over.
	   Do cleanup, check for errors, etc. */
	if (xfer->c_flags & C_DMA) {
		dma_flags = ((sc_xfer->flags & SCSI_DATA_IN) ||
			     (xfer->c_flags & C_SENSE)) ?  WDC_DMA_READ : 0;
		dma_flags |= ((sc_xfer->flags & SCSI_POLL) ||
			      (drvp->atapi_cap & ACAP_DSC)) ? WDC_DMA_POLL : 0;
	}
d859 2
a860 1
		/* Assume everything was transferred */
d947 63
a1042 1
#if 1
d1063 2
a1064 1
			delay = ATAPI_DELAY;
a1067 4
		goto again;
#else
		drvp->state = PIOMODE;
#endif
d1216 1
a1216 2
	chp->ch_status =
	    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);
@


1.17
log
@

NetBSD take note:

Use xfer->c_bcount and not sc_xfer->datalen when passing our buffer limit
to the device. In the case of SENSE, we were sending 0 as our buffer limit,
potentially confusing some devices.

Cap the bytes/interrupt at 65534, which prevents odd size transfers. Odd
size transfers, while not inherently evil, are kind of weird through a 16-bit
wide interface.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.16 1999/10/29 17:12:23 csapuntz Exp $     */
d983 1
a983 1
	int delay = (irq == 0) ? ATAPI_DELAY : 1;
d987 1
d1008 1
a1008 1
#if 0
@


1.16
log
@

Added diagnostic: "length 0 transfer in data phase"

Changed SCSI XS_TIMEOUT error to SCSI XS_RESET error to better reflect
that we had to reset the bus

Don't downgrade DMA modes if the transfer that failed wasn't using DMA
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.15 1999/10/29 01:15:16 deraadt Exp $     */
d566 1
a566 1
	    sc_xfer->datalen <= 0xffff ? sc_xfer->datalen : 0xffff,
@


1.15
log
@Introduce wdc_output_bytes and wdc_input_bytes to remove replicated PIO logic
Fix wdc_select_drive to no longer wait for free channel (not strictly correct
but we couldn't handle a non-free channel anyway)
Major changes to the ATAPI interrupt logic to reduce reliance on the drive
setting the bits correctly. Deal with situation that we get length = 0 back
from the drive on transfer (instead of potentially looping forever).

Timeout in drive setup should not cause the drive to downgrade modes.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.14 1999/10/09 03:42:03 csapuntz Exp $     */
d756 3
a758 1
	if (len == 0) 
d760 1
d814 1
a814 1
	sc_xfer->error = XS_TIMEOUT;
d1127 1
d1138 1
d1140 1
d1142 2
a1143 1
		wdc_downgrade_mode(drvp);
@


1.14
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.13 1999/10/06 04:57:32 csapuntz Exp $     */
a63 8
/* XXX OpenBSD actually has the "raw" API for "stream" functionality.  */
#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define    bus_space_write_multi_stream_2    bus_space_write_multi_2
#define    bus_space_write_multi_stream_4    bus_space_write_multi_4
#define    bus_space_read_multi_stream_2    bus_space_read_multi_2
#define    bus_space_read_multi_stream_4    bus_space_read_multi_4
#endif /* __BUS_SPACE_HAS_STREAM_METHODS */

d92 1
d113 1
a113 2
int	wdc_atapi_get_params __P((struct channel_softc *, u_int8_t, int,
	    struct ataparams *)); 
d125 5
d160 2
a161 1
int atapiscsi_match(parent, match, aux)
d211 1
a211 2
		    (wdc_atapi_get_params(chp, drive,
		    SCSI_POLL|SCSI_NOSLEEP, id) == COMPLETE)) {
d299 1
a299 1
wdc_atapi_get_params(chp, drive, flags, id)
a301 1
	int flags;
d304 1
d312 1
a312 1
	if ((chp->ch_drive[drive].drive_flags & DRIVE_ATAPI) == 0) {
d322 2
a323 2
	wdc_c.timeout = WDC_RESET_WAIT;
	if (wdc_exec_command(&chp->ch_drive[drive], &wdc_c) != WDC_COMPLETE) {
d336 1
a336 1
	chp->ch_drive[drive].state = 0;
d342 1
a342 1
	if (ata_get_params(&chp->ch_drive[drive], AT_POLL, id) != 0) {
d511 1
d523 9
a543 8
	if (wdc_select_drive(chp, xfer->drive, ATAPI_DELAY) < 0) {
		printf("wdc_atapi_start: not ready, st = %02x\n",
		    chp->ch_status);
		sc_xfer->error = XS_TIMEOUT;
		wdc_atapi_reset(chp, xfer);
		return;
	}

d570 2
d592 4
a595 4
				    (drvp->drive_flags & DRIVE_DSCWAIT) ?
				    atapi_dsc_ready : atapi_dsc_semiready,
				    drvp, sc_xfer->timeout, PZERO + PCATCH,
				    "atapist")) {
d604 1
d625 3
d629 1
a629 1
wdc_atapi_intr(chp, xfer, irq)
d633 1
d637 3
a639 2
	int len, phase, i, retries=0;
	int ire, dma_err = 0;
d641 2
a642 4
	struct scsi_generic _cmd_reqsense;
	struct scsi_sense *cmd_reqsense =
	    (struct scsi_sense *)&_cmd_reqsense;
	u_int32_t cmd[4];
a644 50
	bzero(cmd, sizeof(cmd));

	WDCDEBUG_PRINT(("wdc_atapi_intr %s:%d:%d\n",
	    chp->wdc->sc_dev.dv_xname, chp->channel, drvp->drive), DEBUG_INTR);

	/* Is it not a transfer, but a control operation? */
	if (drvp->state < READY) {
		printf("%s:%d:%d: bad state %d in wdc_atapi_intr\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		    drvp->state);
		panic("wdc_atapi_intr: bad state\n");
	}

	/* We should really wait_for_unbusy here too before 
	   switching drives. */
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (xfer->drive << 4));

	/* Ack interrupt done in wait_for_unbusy */
	if (wait_for_unbusy(chp,
	    (irq == 0) ? sc_xfer->timeout : 0) != 0) {
		if (irq && (xfer->c_flags & C_TIMEOU) == 0)
			return (0); /* IRQ was not for us */
		printf("%s:%d:%d: device timeout, c_bcount=%d, c_skip=%d\n",
		    chp->wdc->sc_dev.dv_xname, chp->channel, xfer->drive,
		    xfer->c_bcount, xfer->c_skip);
		if (xfer->c_flags & C_DMA)
			drvp->n_dmaerrs++;
		sc_xfer->error = XS_TIMEOUT;
		wdc_atapi_reset(chp, xfer);
		return (1);
	}
	/* If we missed an IRQ and were using DMA, flag it as a DMA error */
	if ((xfer->c_flags & C_TIMEOU) && (xfer->c_flags & C_DMA))
		drvp->n_dmaerrs++;
	/* 
	 * if the request sense command was aborted, report the short sense
	 * previously recorded, else continue normal processing
	 */

	if ((xfer->c_flags & C_SENSE) != 0 &&
	    (chp->ch_status & WDCS_ERR) != 0 &&
	    (chp->ch_error & WDCE_ABRT) != 0) {
		WDCDEBUG_PRINT(("wdc_atapi_intr: request_sense aborted, "
		    "calling wdc_atapi_done()"
		    ), DEBUG_INTR);
		wdc_atapi_done(chp, xfer);
		return (1);
	}

d649 1
a649 1
		   (drvp->atapi_cap & ACAP_DSC)) ? WDC_DMA_POLL : 0;
a650 8
again:
	len = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_lo) +
	    256 * bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_cyl_hi);
	ire = bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_ireason);
	phase = (ire & (WDCI_CMD | WDCI_IN)) | (chp->ch_status & WDCS_DRQ);
	WDCDEBUG_PRINT(("wdc_atapi_intr: c_bcount %d len %d st 0x%x err 0x%x "
	    "ire 0x%x :", xfer->c_bcount,
	    len, chp->ch_status, chp->ch_error, ire), DEBUG_INTR);
d652 4
a655 2
	switch (phase) {
	case PHASE_CMDOUT:
d657 1
a657 1
			bzero(cmd_reqsense, sizeof(struct scsi_generic));
d660 1
a660 2
			bcopy(cmd_reqsense, cmd, sizeof(struct scsi_generic));
		} else {
d662 5
a666 2
		}
		WDCDEBUG_PRINT(("PHASE_CMDOUT\n"), DEBUG_INTR);
d670 2
a671 2
			    chp->channel, xfer->drive,
			    xfer->databuf, xfer->c_bcount, dma_flags) != 0) {
d673 2
a674 1
				break;
d678 5
a682 27
		/* send packet command */
		/* Commands are 12 or 16 bytes long. It's 32-bit aligned */
		if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM)) {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_write_multi_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)cmd,
				    cmdlen >> 2);
			} else {
				bus_space_write_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)cmd,
				    cmdlen >> 1);
			}
		} else {
			if (drvp->drive_flags & DRIVE_CAP32) {
				bus_space_write_multi_stream_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)cmd,
				    cmdlen >> 2);
			} else {
				bus_space_write_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)cmd,
				    cmdlen >> 1);
			}
		}
d686 2
a687 1
			    chp->channel, xfer->drive, dma_flags);
d701 1
a701 1
			    sc_xfer->cmd->opcode == WRITE)) {
d709 23
d733 17
a749 14
	 case PHASE_DATAOUT:
		/* write data */
		WDCDEBUG_PRINT(("PHASE_DATAOUT\n"), DEBUG_INTR);
		if ((sc_xfer->flags & SCSI_DATA_OUT) == 0 ||
		    (xfer->c_flags & C_DMA) != 0) {
			printf("wdc_atapi_intr: bad data phase DATAOUT\n");
			if (xfer->c_flags & C_DMA) {
				(*chp->wdc->dma_finish)(chp->wdc->dma_arg,
				    chp->channel, xfer->drive, dma_flags);
				drvp->n_dmaerrs++;
			}
			sc_xfer->error = XS_TIMEOUT;
			wdc_atapi_reset(chp, xfer);
			return (1);
d751 22
a772 1
		if (xfer->c_bcount < len) {
d775 4
a778 13
			if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM)) {
				bus_space_write_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)
				    ((char *)xfer->databuf + xfer->c_skip),
				    xfer->c_bcount >> 1);
			} else {
				bus_space_write_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)
				    ((char *)xfer->databuf + xfer->c_skip),
				    xfer->c_bcount >> 1);
			}
a781 2
			xfer->c_skip += xfer->c_bcount;
			xfer->c_bcount = 0;
d783 7
a789 42
			if (drvp->drive_flags & DRIVE_CAP32) {
				if ((chp->wdc->cap &
				    WDC_CAPABILITY_ATAPI_NOSTREAM))
					bus_space_write_multi_4(chp->data32iot,
					    chp->data32ioh, 0,
					    (u_int32_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 2);
				else
					bus_space_write_multi_stream_4(
					    chp->data32iot, chp->data32ioh,
					    wd_data,
					    (u_int32_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 2);

				xfer->c_skip += len & 0xfffffffc;
				xfer->c_bcount -= len & 0xfffffffc;
				len = len & 0x03;
			}
			if (len > 0) {
				if ((chp->wdc->cap &
				    WDC_CAPABILITY_ATAPI_NOSTREAM))
					bus_space_write_multi_2(chp->cmd_iot,
					    chp->cmd_ioh, wd_data,
					    (u_int16_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 1);
				else
					bus_space_write_multi_stream_2(
					    chp->cmd_iot, chp->cmd_ioh,
					    wd_data,
					    (u_int16_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 1);
				xfer->c_skip += len;
				xfer->c_bcount -= len;
			}
d792 67
a858 6
		if ((sc_xfer->flags & SCSI_POLL) == 0 &&
		    (drvp->atapi_cap & ACAP_DSC) == 0) {
			chp->ch_flags |= WDCF_IRQ_WAIT;
			timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
		} else if (drvp->atapi_cap & ACAP_DSC)
			drvp->drive_flags |= DRIVE_DSCWAIT;
d860 16
d877 25
a901 11
	case PHASE_DATAIN:
		/* Read data */
		WDCDEBUG_PRINT(("PHASE_DATAIN\n"), DEBUG_INTR);
		if (((sc_xfer->flags & SCSI_DATA_IN) == 0 &&
		    (xfer->c_flags & C_SENSE) == 0) || 
		    (xfer->c_flags & C_DMA) != 0) {
			printf("wdc_atapi_intr: bad data phase DATAIN\n");
			if (xfer->c_flags & C_DMA) {
				(*chp->wdc->dma_finish)(chp->wdc->dma_arg,
				    chp->channel, xfer->drive, dma_flags);
				drvp->n_dmaerrs++;
d903 7
a909 1
			sc_xfer->error = XS_TIMEOUT;
d912 3
a914 20
		}
		if (xfer->c_bcount < len) {
			printf("wdc_atapi_intr: warning: reading only "
			    "%d of %d bytes\n", xfer->c_bcount, len);
			if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM)) {
				bus_space_read_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)
				    ((char *)xfer->databuf + xfer->c_skip),
				    xfer->c_bcount >> 1);
			} else {
				bus_space_read_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)
				    ((char *)xfer->databuf + xfer->c_skip),
				    xfer->c_bcount >> 1);
			}
			wdcbit_bucket(chp, len - xfer->c_bcount);
			xfer->c_skip += xfer->c_bcount;
			xfer->c_bcount = 0;
d916 5
a920 42
			if (drvp->drive_flags & DRIVE_CAP32) {
				if ((chp->wdc->cap &
				    WDC_CAPABILITY_ATAPI_NOSTREAM))
					bus_space_read_multi_4(chp->data32iot,
					    chp->data32ioh, 0,
					    (u_int32_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 2);
				else
					bus_space_read_multi_stream_4(
					    chp->data32iot, chp->data32ioh,
					    wd_data,
					    (u_int32_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip),
					    len >> 2);
				
				xfer->c_skip += len & 0xfffffffc;
				xfer->c_bcount -= len & 0xfffffffc;
				len = len & 0x03;
			}
			if (len > 0) {
				if ((chp->wdc->cap &
				    WDC_CAPABILITY_ATAPI_NOSTREAM))
					bus_space_read_multi_2(chp->cmd_iot,
					    chp->cmd_ioh, wd_data,
					    (u_int16_t *)
					    ((char *)xfer->databuf +
				            xfer->c_skip), 
					    len >> 1);
				else
					bus_space_read_multi_stream_2(
					    chp->cmd_iot, chp->cmd_ioh,
					    wd_data,
					    (u_int16_t *)
					    ((char *)xfer->databuf +
					    xfer->c_skip), 
					    len >> 1);
				xfer->c_skip += len;
				xfer->c_bcount -=len;
			}
d922 8
a929 23

		if ((sc_xfer->flags & SCSI_POLL) == 0 &&
		    (drvp->atapi_cap & ACAP_DSC) == 0) {
			chp->ch_flags |= WDCF_IRQ_WAIT;
			timeout(wdctimeout, chp, sc_xfer->timeout * hz / 1000);
		}
		return (1);

	case PHASE_ABORTED:
	case PHASE_COMPLETED:
		WDCDEBUG_PRINT(("PHASE_COMPLETED\n"), DEBUG_INTR);
		/* turn off DMA channel */
		if (xfer->c_flags & C_DMA) {
			dma_err = (*chp->wdc->dma_finish)(chp->wdc->dma_arg,
			    chp->channel, xfer->drive, dma_flags);
			if (xfer->c_flags & C_SENSE)
				xfer->c_bcount -=
				    sizeof(sc_xfer->sense);
			else
				xfer->c_bcount -= sc_xfer->datalen;
		}
		if (xfer->c_flags & C_SENSE) {
			if ((chp->ch_status & WDCS_ERR) || dma_err < 0) {
d931 2
a932 2
				 * request sense failed ! it's not suppossed
				 * to be possible
d934 6
a939 4
				if (dma_err < 0)
					drvp->n_dmaerrs++;
				sc_xfer->error = XS_RESET;
				wdc_atapi_reset(chp, xfer);
a940 10
			} else if (xfer->c_bcount <
			    sizeof(sc_xfer->sense)) {
				/* use the sense we just read */
				sc_xfer->error = XS_SENSE;
			} else {
				/*
				 * command completed, but no data was read.
				 * use the short sense we saved previsouly.
				 */
				sc_xfer->error = XS_SHORTSENSE;
d942 15
a956 31
		} else {
			sc_xfer->resid = xfer->c_bcount;
			if (chp->ch_status & WDCS_ERR) {
				/* save the short sense */
				sc_xfer->error = XS_SHORTSENSE;
				atapi_to_scsi_sense(sc_xfer, chp->ch_error);
				if ((sc_xfer->sc_link->quirks &
				    ADEV_NOSENSE) == 0) {
					/*
					 * let the driver issue a
					 * 'request sense'
					 */
					xfer->databuf = &sc_xfer->sense;
					xfer->c_bcount =
					    sizeof(sc_xfer->sense);
					xfer->c_skip = 0;
					xfer->c_flags |= C_SENSE;
					wdc_atapi_start(chp, xfer);
					return (1);
				}
			} else if (dma_err < 0) {
				drvp->n_dmaerrs++;
				sc_xfer->error = XS_RESET;
				wdc_atapi_reset(chp, xfer);
				return (1);
			}
		}
		if (xfer->c_bcount != 0) {
			WDCDEBUG_PRINT(("wdc_atapi_intr: bcount value is "
			    "%d after io\n", xfer->c_bcount), DEBUG_XFERS);
		}
d958 4
a961 4
		if (xfer->c_bcount < 0) {
			printf("wdc_atapi_intr warning: bcount value "
			    "is %d after io\n", xfer->c_bcount);
		}
a962 1
		break;
a963 19
	default:
		if (++retries<500) {
			DELAY(100);
			chp->ch_status = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wd_status);
			chp->ch_error = bus_space_read_1(chp->cmd_iot,
			    chp->cmd_ioh, wd_error);
			goto again;
		}
		printf("wdc_atapi_intr: unknown phase 0x%x\n", phase);
		if (chp->ch_status & WDCS_ERR) {
			sc_xfer->error = XS_SHORTSENSE;
			atapi_to_scsi_sense(sc_xfer, chp->ch_error);
		} else {
			sc_xfer->error = XS_RESET;
			wdc_atapi_reset(chp, xfer);
			return (1);
		}
	}
d965 2
a966 2
	    "\n", sc_xfer->error),
	    DEBUG_INTR);
d980 1
a980 1
	int delay = (irq == 0) ? ATAPI_DELAY : 0;
d995 3
d1004 1
d1015 1
a1015 1
		if (wdcwait(chp, 0, 0, (irq == 0) ? 10000 : 0)) 
d1024 2
a1025 4
			/* Wait for the drive to become unbusy before shoving
			   the PIOMODE command down its throat */
			if (wdcwait(chp, 0, 0, 10000))
				goto timeout;
d1030 3
a1032 1

a1227 9
	chp->ch_status =
	    bus_space_read_1(chp->cmd_iot, chp->cmd_ioh, wd_status);

	if (chp->ch_status & WDCS_DRQ) {
		printf ("wdc_atapi_reset: "
		    "DRQ is asserted. We've really messed up\n");
		wdc_reset_channel(drvp);
	}

d1236 1
a1236 1
	if (wait_for_unbusy(chp, WDC_RESET_WAIT) != 0) {
d1241 1
@


1.13
log
@

Turn of debugging diagnostics
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.12 1999/10/06 04:56:23 csapuntz Exp $     */
d120 1
a120 1
int	wdc_atapi_get_params __P((struct atapiscsi_softc *, u_int8_t, int,
d132 1
a132 4
	struct  wdc_softc  *sc_wdc;
	u_int8_t sc_channel;  
	int  valid[2];
	struct ata_drive_datas *sc_drvs;
d173 1
d192 1
d199 1
a199 6
	/* Ouch */
	as->valid[0] = as->valid[1] = 0;

	as->sc_wdc = (struct wdc_softc *)parent;
	as->sc_drvs = aa_link->aa_drv_data;
	as->sc_channel = aa_link->aa_channel;
a207 1
	as->sc_wdc->channels[as->sc_channel]->ch_as = as;
d210 1
a210 1
		struct ata_drive_datas *drvp = &as->sc_drvs[drive];
d213 1
a213 1
		    (wdc_atapi_get_params(as, drive,
d215 4
a218 8

			as->valid[drive] = 1;

			/* This is wrong. All the devices on the ATAPI bus
			   will be called atapibus by the IDE side of the
			   driver. */
			drvp->drv_softc = (struct device *)as;
			wdc_probe_caps(drvp);
d239 2
a240 1
		}
d243 2
d248 2
a249 1
}
d251 2
d254 10
a263 5
void
wdc_atapibus_final_attach(chp)
	struct channel_softc *chp;
{
	/* Get rid of this eventually */
d281 3
a283 4
	aa_link.aa_drv_data = chp->ch_drive; /* pass the whole array */
#if 0
	aa_link.aa_bus_private = &wdc->sc_atapi_adapter;
#endif
d302 2
a303 2
wdc_atapi_get_params(as, drive, flags, id)
	struct atapiscsi_softc *as;
a307 3
	struct wdc_softc *wdc = as->sc_wdc;
	struct channel_softc *chp =
	    wdc->channels[as->sc_channel];
d360 4
a363 1
	struct wdc_softc *wdc = as->sc_wdc;
a365 3
	int channel = as->sc_channel;
	int drive = sc_xfer->sc_link->target;
	struct ata_drive_datas *drvp = &as->sc_drvs[drive];
d373 1
a373 1
	    wdc->sc_dev.dv_xname, channel, drive), DEBUG_XFERS);
d375 1
a375 1
	if (drive > 1 || !as->valid[drive]) {
d450 1
a450 1
	wdc_exec_xfer(wdc->channels[channel], xfer);
d1098 10
a1107 6
		if (!(chp->ch_status & WDCS_DRQ) &&
		    chp->ch_status & WDCS_ERR) {
			chp->ch_error = bus_space_read_1(chp->cmd_iot,
							 chp->cmd_ioh, 
							 wd_error);
			goto error;
a1108 8

		wdcbit_bucket(chp, 512);
		
		errstring = "Post IDENTIFY";
		/* Wait for the drive to become unbusy before shoving
		   the PIOMODE command down its throat */
		if (wdcwait(chp, 0, 0, 10000))
			goto timeout;
@


1.12
log
@

Fix piomode(0x4) errors.
Fix Sense Error 6 errors.

Better atapi to scsi sense conversion.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.11 1999/09/24 05:31:51 csapuntz Exp $     */
d90 1
a90 1
int wdcdebug_atapi_mask = DEBUG_ERRORS;
@


1.11
log
@

Fix a bug that was causing timeouts every time an ATAPI device was reset.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.10 1999/09/05 21:45:23 niklas Exp $     */
d86 3
a88 1
#define DEBUG_POLL    0x40
d90 1
a90 1
int wdcdebug_atapi_mask = 0x0;
d127 1
a127 3

#define ATAPI_TO_SCSI_SENSE(sc, atapi_error) \
   (sc)->error_code = XS_SHORTSENSE; (sc)->flags = (atapi_error) >> 4; 
d252 4
d263 1
a263 3
	if (chp->ch_as)
		config_found((struct device *)chp->ch_as, 
			     &chp->ch_as->sc_adapterlink, scsiprint);
d474 37
d523 2
a524 1
	if ((drvp->drive_flags & (DRIVE_DMA | DRIVE_UDMA)) &&
d999 1
a999 2
				ATAPI_TO_SCSI_SENSE(&sc_xfer->sense,
				    chp->ch_error);
d1045 1
a1045 1
			ATAPI_TO_SCSI_SENSE(&sc_xfer->sense, chp->ch_error);
d1111 6
d1119 1
a1119 1
	/* fall through */
d1199 1
a1199 1
	ATAPI_TO_SCSI_SENSE(&sc_xfer->sense, chp->ch_error);
@


1.10
log
@Support for ATAPI tapes, works but still has some rough edges.  Some style.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.9 1999/08/12 13:01:13 niklas Exp $     */
d1074 1
a1074 1
		break;
@


1.9
log
@use bzero in the kernel (I thought I had done this already?)
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.8 1999/07/25 07:09:19 csapuntz Exp $     */
d55 1
d64 1
d85 2
d96 2
a97 1
#define ATAPI_DELAY 10	/* 10 ms, this is used only before sending a cmd */
d99 9
a107 6
void  wdc_atapi_minphys  __P((struct buf *bp));
void  wdc_atapi_start	__P((struct channel_softc *,struct wdc_xfer *));
int   wdc_atapi_intr	 __P((struct channel_softc *, struct wdc_xfer *, int));
int   wdc_atapi_ctrl	 __P((struct channel_softc *, struct wdc_xfer *, int));
void  wdc_atapi_done	 __P((struct channel_softc *, struct wdc_xfer *));
void  wdc_atapi_reset	 __P((struct channel_softc *, struct wdc_xfer *));
d115 2
a116 2
static int atapiscsi_match __P((struct device *, void *, void *));
static void atapiscsi_attach __P((struct device *, struct device *, void *));
d121 5
d231 12
a242 2
			if ((id->atap_config & ATAPI_CFG_CMD_MASK) 
			    == ATAPI_CFG_CMD_16)
d245 5
a249 1
			drvp->atapi_cap |= (id->atap_config & ATAPI_CFG_DRQ_MASK);
d320 1
a320 1
		return -1;
d339 1
a339 1
		return -1;
d352 1
a352 1
		return -1;
d354 1
a354 1
	return COMPLETE;
d367 6
a372 1
	int s, ret;
d379 1
a379 1
		return COMPLETE;
d384 1
a384 1
		return TRY_AGAIN_LATER;
d395 1
d397 55
d454 2
a455 1
	if ((sc_xfer->flags & SCSI_POLL) != 0 &&
d459 8
d469 1
a469 1
	return ret;
d480 1
a480 1
	WDCDEBUG_PRINT(("wdc_atapi_start %s:%d:%d, scsi flags 0x%x \n",
d509 12
d540 2
a541 2
	if (((drvp->atapi_cap & ATAPI_CFG_DRQ_MASK) != ATAPI_CFG_IRQ_DRQ)
	    || (sc_xfer->flags & SCSI_POLL)) {
d548 1
d551 1
a551 1
	if (sc_xfer->flags & SCSI_POLL) {
d553 14
a566 2
			/* Wait for at last 400ns for status bit to be valid */
			DELAY(1);
d573 15
d602 1
a602 1
	int  cmdlen = (drvp->atapi_cap & ACAP_LEN) ? 16 : 12;
d626 1
a626 1
			return 0; /* IRQ was not for us */
d634 1
a634 1
		return 1;
d651 1
a651 1
		return 1;
d657 2
a658 1
		dma_flags |= sc_xfer->flags & SCSI_POLL ? WDC_DMA_POLL : 0;
d723 2
a724 1
		if ((sc_xfer->flags & SCSI_POLL) == 0) {
d728 14
a741 1
		return 1;
d756 1
a756 1
			return 1;
d764 2
a765 2
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
d770 2
a771 2
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
d781 20
a800 16
			    if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM))
				bus_space_write_multi_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 2);
			    else
				bus_space_write_multi_stream_4(chp->data32iot,
				    chp->data32ioh, wd_data,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 2);

			    xfer->c_skip += len & 0xfffffffc;
			    xfer->c_bcount -= len & 0xfffffffc;
			    len = len & 0x03;
d803 18
a820 14
			    if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM))
				bus_space_write_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 1);
			    else
				bus_space_write_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 1);
			    xfer->c_skip += len;
			    xfer->c_bcount -= len;
d824 2
a825 1
		if ((sc_xfer->flags & SCSI_POLL) == 0) {
d828 3
a830 2
		}
		return 1;
d846 1
a846 1
			return 1;
d852 5
a856 5
			    bus_space_read_multi_2(chp->cmd_iot,
			    chp->cmd_ioh, wd_data,
			    (u_int16_t *)((char *)xfer->databuf +
			                  xfer->c_skip),
			    xfer->c_bcount >> 1);
d858 5
a862 5
			    bus_space_read_multi_stream_2(chp->cmd_iot,
			    chp->cmd_ioh, wd_data,
			    (u_int16_t *)((char *)xfer->databuf +
			                  xfer->c_skip),
			    xfer->c_bcount >> 1);
d869 16
a884 12
			    if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM))
				bus_space_read_multi_4(chp->data32iot,
				    chp->data32ioh, 0,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 2);
			    else
				bus_space_read_multi_stream_4(chp->data32iot,
				    chp->data32ioh, wd_data,
				    (u_int32_t *)((char *)xfer->databuf +
				                  xfer->c_skip),
				    len >> 2);
d886 3
a888 3
			    xfer->c_skip += len & 0xfffffffc;
			    xfer->c_bcount -= len & 0xfffffffc;
			    len = len & 0x03;
d891 18
a908 14
			    if ((chp->wdc->cap & WDC_CAPABILITY_ATAPI_NOSTREAM))
				bus_space_read_multi_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip), 
				    len >> 1);
			    else
				bus_space_read_multi_stream_2(chp->cmd_iot,
				    chp->cmd_ioh, wd_data,
				    (u_int16_t *)((char *)xfer->databuf +
				                  xfer->c_skip), 
				    len >> 1);
			    xfer->c_skip += len;
			    xfer->c_bcount -=len;
d912 2
a913 1
		if ((sc_xfer->flags & SCSI_POLL) == 0) {
d917 1
a917 1
		return 1;
d959 2
a960 1
				ATAPI_TO_SCSI_SENSE(&sc_xfer->sense, chp->ch_error);
d973 1
a973 1
					return 1;
d1083 1
a1083 1
			goto ready;;
d1127 1
a1127 1
		return 1;
d1129 2
a1130 1
	if ((sc_xfer->flags & SCSI_POLL) == 0) {
d1137 1
a1137 1
	return 1;
d1141 1
a1141 1
		return 0; /* IRQ was not for us */
d1147 1
a1147 1
	return 1;
d1156 1
a1156 1
	return 1;
d1165 1
a1165 1
	int need_done =  xfer->c_flags & C_NEEDDONE;
d1175 3
a1177 2
	  (sc_xfer->error != XS_NOERROR && sc_xfer->error != XS_SENSE &&
	  sc_xfer->error != XS_SHORTSENSE)) {
d1191 72
d1271 2
a1272 3
	chp->ch_status = bus_space_read_1(chp->cmd_iot,
					 chp->cmd_ioh, 
					 wd_status);
d1275 2
a1276 1
		printf ("wdc_atapi_reset: DRQ is asserted. We've really messed up\n");
a1297 1

@


1.8
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.7 1999/07/23 16:23:39 csapuntz Exp $     */
d248 1
a248 1
	memset(&aa_link, 0, sizeof(struct ata_atapi_attach));
d295 1
a295 1
	memset(&wdc_c, 0, sizeof(struct wdc_command));
d467 1
a467 1
	memset (cmd, 0, sizeof(cmd));
d534 1
a534 1
			memset(cmd_reqsense, 0, sizeof(struct scsi_generic));
@


1.7
log
@

Don't even try wdc_get_params on a drive that didn't show up as ATAPI
during probe. This has a slight chance of breaking the detection of some
ATAPI devices (which don't show during initial probe).

Thanks to deraadt for pointing this out.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.6 1999/07/23 04:24:31 csapuntz Exp $     */
a112 2
#define XS_SHORTSENSE XS_SENSE
#define XS_RESET XS_DRIVER_STUFFUP
@


1.6
log
@


Identify Drive may have to access media. So, wait up to 10s (in polling mode)
for Identify Drive to do its thing. This should fix the "IDENTIFY timeout"
some people are seeing.

ATAPI SCSI buses only have 2 targets.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.5 1999/07/22 07:45:48 deraadt Exp $     */
d206 5
a210 3
		if (wdc_atapi_get_params(as, drive,
		    SCSI_POLL|SCSI_NOSLEEP, id) == COMPLETE) {
			struct ata_drive_datas *drvp = &as->sc_drvs[drive];
@


1.5
log
@need a blank line here... for now
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.4 1999/07/22 03:10:47 csapuntz Exp $     */
d197 1
d885 4
a888 1
		if (wdcwait(chp, 0, 0, delay)) 
d891 2
a892 11
		if (chp->ch_status & WDCS_ERR) {
			chp->ch_error = bus_space_read_1(chp->cmd_iot,
							 chp->cmd_ioh, 
							 wd_error);
			goto error;
		}

		if (wdcwait(chp, WDCS_DRQ, WDCS_DRQ, 1000)) 
			goto timeout;

		if (chp->ch_status & WDCS_ERR) {
@


1.4
log
@

Use wdc_select_drive if we're starting in the IDLE bus state.

Modify the ATAPI reset state machine. Added two states, IDENTIFY and
IDENTIFY_WAIT. These will revive ATAPI drives after a hard ATA reset.

I don't think ATAPI devices have LUNs, so flag SDEV_NOLUNS as quirk
of the SCSI adapter. The SCSI devices will "inherit" this setting from
the parent.

Correctly deal with 16-byte command packet devices (not that any
exists, AFAIK).

Optimization - don't poll devices that assert an interrupt on after
sending PACKET cmd.
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.3 1999/07/20 06:21:58 csapuntz Exp $     */
d186 2
@


1.3
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.2 1999/07/19 00:32:44 csapuntz Exp $     */
d122 1
a122 3

	u_int8_t sc_channel;  /* Channel we represent */
	struct   scsi_link  sc_link[2];
d124 1
a124 1
	struct ata_drive_datas *sc_drvs;	/* array supplied by adapter */
d199 1
d213 7
a219 1
			wdc_probe_caps(drvp);		
a221 4

#if 0
	config_found(self, &as->sc_adapterlink, scsiprint);
#endif
d391 1
a391 1
		if (drvp->state != PIOMODE) {
d400 2
a401 3
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (xfer->drive << 4));
	if (wait_for_unbusy(chp, ATAPI_DELAY) < 0) {
d422 1
a422 1
	
d428 2
a429 8
	if (
#ifndef __OpenBSD__
	    (sc_xfer->sc_link->scsi_atapi.cap  & ATAPI_CFG_DRQ_MASK) !=
	    ATAPI_CFG_IRQ_DRQ || (sc_xfer->flags & SCSI_POLL)
#else
	    1
#endif
	) {
d462 1
a462 1
	int  cmdlen =12;  /* XXX - Not true for all ATAPI devices */
d476 3
a478 1
	/* Ack interrupt done in wait_for_unbusy */
d481 2
d548 1
d660 1
d738 1
d861 8
a868 2
	bus_space_write_1(chp->cmd_iot, chp->cmd_ioh, wd_sdh,
	    WDSD_IBM | (xfer->drive << 4));
d870 37
d1028 9
d1038 6
d1051 1
@


1.2
log
@

Lower chatiness
@
text
@d1 1
a1 1
/*      $OpenBSD: atapiscsi.c,v 1.1 1999/07/18 21:25:18 csapuntz Exp $     */
d200 1
d786 1
a786 1
				    SDEV_NOSENSE) == 0) {
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
d84 1
a84 1
int wdcdebug_atapi_mask = 0xFF;
@

