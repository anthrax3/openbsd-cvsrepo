head	1.234;
access;
symbols
	OPENBSD_6_2:1.234.0.4
	OPENBSD_6_2_BASE:1.234
	OPENBSD_6_1:1.231.0.4
	OPENBSD_6_1_BASE:1.231
	OPENBSD_6_0:1.223.0.2
	OPENBSD_6_0_BASE:1.223
	OPENBSD_5_9:1.219.0.2
	OPENBSD_5_9_BASE:1.219
	OPENBSD_5_8:1.217.0.4
	OPENBSD_5_8_BASE:1.217
	OPENBSD_5_7:1.214.0.4
	OPENBSD_5_7_BASE:1.214
	OPENBSD_5_6:1.213.0.4
	OPENBSD_5_6_BASE:1.213
	OPENBSD_5_5:1.205.0.4
	OPENBSD_5_5_BASE:1.205
	OPENBSD_5_4:1.203.0.2
	OPENBSD_5_4_BASE:1.203
	OPENBSD_5_3:1.199.0.2
	OPENBSD_5_3_BASE:1.199
	OPENBSD_5_2:1.197.0.2
	OPENBSD_5_2_BASE:1.197
	OPENBSD_5_1_BASE:1.191
	OPENBSD_5_1:1.191.0.4
	OPENBSD_5_0:1.191.0.2
	OPENBSD_5_0_BASE:1.191
	OPENBSD_4_9:1.181.0.2
	OPENBSD_4_9_BASE:1.181
	OPENBSD_4_8:1.178.0.2
	OPENBSD_4_8_BASE:1.178
	OPENBSD_4_7:1.157.0.2
	OPENBSD_4_7_BASE:1.157
	OPENBSD_4_6:1.150.0.4
	OPENBSD_4_6_BASE:1.150
	OPENBSD_4_5:1.136.0.2
	OPENBSD_4_5_BASE:1.136
	OPENBSD_4_4:1.130.0.2
	OPENBSD_4_4_BASE:1.130
	OPENBSD_4_3:1.109.0.2
	OPENBSD_4_3_BASE:1.109
	OPENBSD_4_2:1.87.0.2
	OPENBSD_4_2_BASE:1.87
	OPENBSD_4_1:1.85.0.2
	OPENBSD_4_1_BASE:1.85
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31;
locks; strict;
comment	@ * @;


1.234
date	2017.05.28.15.36.45;	author anton;	state Exp;
branches;
next	1.233;
commitid	CtXM2TEyXoCJDcob;

1.233
date	2017.04.15.04.54.04;	author guenther;	state Exp;
branches;
next	1.232;
commitid	RfOghIamLBgraUT0;

1.232
date	2017.04.08.01.20.10;	author deraadt;	state Exp;
branches;
next	1.231;
commitid	MZ9TNujEim7YgwTY;

1.231
date	2017.02.16.18.02.22;	author jcs;	state Exp;
branches;
next	1.230;
commitid	s3FLhrva8UpJEuLS;

1.230
date	2017.01.14.11.32.00;	author kettenis;	state Exp;
branches;
next	1.229;
commitid	Y1ZrlN3vWltWSUxD;

1.229
date	2017.01.08.12.39.16;	author kettenis;	state Exp;
branches;
next	1.228;
commitid	abkKJhrEtiLE3iU9;

1.228
date	2016.12.18.15.59.22;	author kettenis;	state Exp;
branches;
next	1.227;
commitid	IqzpteXoYXiqh7Wk;

1.227
date	2016.10.25.06.48.58;	author pirofti;	state Exp;
branches;
next	1.226;
commitid	Z8xhqpkgqCmi8yVl;

1.226
date	2016.10.21.21.47.03;	author joris;	state Exp;
branches;
next	1.225;
commitid	EsjY5PBly8Sdaxtn;

1.225
date	2016.09.27.10.04.19;	author mlarkin;	state Exp;
branches;
next	1.224;
commitid	cnMetJ9x6DBWx0kL;

1.224
date	2016.09.02.13.59.51;	author pirofti;	state Exp;
branches;
next	1.223;
commitid	QA6Gb7VSg6HVRahN;

1.223
date	2016.05.08.11.08.01;	author kettenis;	state Exp;
branches;
next	1.222;
commitid	SBTJg3diM8lXHXRE;

1.222
date	2016.05.07.18.08.27;	author kettenis;	state Exp;
branches;
next	1.221;
commitid	NDD6SI0wvygQBRAK;

1.221
date	2016.03.14.06.37.31;	author guenther;	state Exp;
branches;
next	1.220;
commitid	uE59hV3t3wI6I7pN;

1.220
date	2016.03.02.05.14.34;	author jsg;	state Exp;
branches;
next	1.219;
commitid	wwR0w5RAQuQFVfav;

1.219
date	2016.01.13.23.11.22;	author kettenis;	state Exp;
branches;
next	1.218;
commitid	qiuZZwVp5JJiWr2w;

1.218
date	2015.08.20.20.50.10;	author kettenis;	state Exp;
branches;
next	1.217;
commitid	12oRjsDuFxOUanBv;

1.217
date	2015.05.04.10.42.06;	author jmatthew;	state Exp;
branches;
next	1.216;
commitid	sk0eeHdIQqGgl3N6;

1.216
date	2015.03.16.20.31.46;	author deraadt;	state Exp;
branches;
next	1.215;
commitid	UF5MXB4OGf08laCK;

1.215
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.214;
commitid	p4LJxGKbi0BU2cG6;

1.214
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.213;
commitid	uzzBR7hz9ncd4O6G;

1.213
date	2014.07.20.12.20.38;	author kettenis;	state Exp;
branches;
next	1.212;
commitid	2Bvec2CgH5tbEEro;

1.212
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.211;
commitid	I19imNlAX05zJOED;

1.211
date	2014.06.25.18.56.22;	author kettenis;	state Exp;
branches;
next	1.210;
commitid	v3RTyEvXGSr9TjZr;

1.210
date	2014.06.23.18.47.41;	author kettenis;	state Exp;
branches;
next	1.209;
commitid	95Z2UROzA7lVmywt;

1.209
date	2014.05.21.02.14.07;	author mlarkin;	state Exp;
branches;
next	1.208;

1.208
date	2014.05.02.14.04.50;	author kettenis;	state Exp;
branches;
next	1.207;

1.207
date	2014.04.26.21.45.50;	author kettenis;	state Exp;
branches;
next	1.206;

1.206
date	2014.03.13.18.52.38;	author brynet;	state Exp;
branches;
next	1.205;

1.205
date	2013.12.12.20.56.01;	author guenther;	state Exp;
branches;
next	1.204;

1.204
date	2013.11.04.22.32.31;	author kettenis;	state Exp;
branches;
next	1.203;

1.203
date	2013.06.02.17.21.38;	author jcs;	state Exp;
branches;
next	1.202;

1.202
date	2013.06.02.01.22.00;	author kettenis;	state Exp;
branches;
next	1.201;

1.201
date	2013.05.23.10.27.43;	author kettenis;	state Exp;
branches;
next	1.200;

1.200
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.199;

1.199
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.198;

1.198
date	2013.01.18.04.07.06;	author pirofti;	state Exp;
branches;
next	1.197;

1.197
date	2012.07.16.15.27.11;	author deraadt;	state Exp;
branches;
next	1.196;

1.196
date	2012.07.10.15.57.41;	author pirofti;	state Exp;
branches;
next	1.195;

1.195
date	2012.07.10.15.49.25;	author pirofti;	state Exp;
branches;
next	1.194;

1.194
date	2012.07.10.15.04.34;	author pirofti;	state Exp;
branches;
next	1.193;

1.193
date	2012.03.15.18.36.53;	author kettenis;	state Exp;
branches;
next	1.192;

1.192
date	2012.03.10.21.18.59;	author kettenis;	state Exp;
branches;
next	1.191;

1.191
date	2011.06.15.08.11.51;	author pirofti;	state Exp;
branches;
next	1.190;

1.190
date	2011.06.08.05.38.28;	author jordan;	state Exp;
branches;
next	1.189;

1.189
date	2011.06.03.16.44.16;	author jordan;	state Exp;
branches;
next	1.188;

1.188
date	2011.06.03.03.56.15;	author jordan;	state Exp;
branches;
next	1.187;

1.187
date	2011.06.02.19.26.35;	author jordan;	state Exp;
branches;
next	1.186;

1.186
date	2011.06.02.17.15.53;	author jordan;	state Exp;
branches;
next	1.185;

1.185
date	2011.04.22.18.22.01;	author jordan;	state Exp;
branches;
next	1.184;

1.184
date	2011.04.19.23.56.10;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2011.04.18.00.40.26;	author jordan;	state Exp;
branches;
next	1.182;

1.182
date	2011.03.20.00.09.14;	author jordan;	state Exp;
branches;
next	1.181;

1.181
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.180;

1.180
date	2010.10.31.21.52.46;	author guenther;	state Exp;
branches;
next	1.179;

1.179
date	2010.10.26.20.51.35;	author jordan;	state Exp;
branches;
next	1.178;

1.178
date	2010.08.05.15.46.20;	author deraadt;	state Exp;
branches;
next	1.177;

1.177
date	2010.08.04.18.11.55;	author jordan;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.28.16.00.29;	author deraadt;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.27.23.36.35;	author deraadt;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.27.02.00.36;	author krw;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.23.18.38.46;	author jordan;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.22.14.19.47;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.170;

1.170
date	2010.07.21.15.07.40;	author deraadt;	state Exp;
branches;
next	1.169;

1.169
date	2010.07.20.12.14.10;	author deraadt;	state Exp;
branches;
next	1.168;

1.168
date	2010.07.20.12.12.20;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.19.16.57.27;	author deraadt;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.13.21.01.05;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.164;

1.164
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.163;

1.163
date	2010.07.01.01.39.39;	author jordan;	state Exp;
branches;
next	1.162;

1.162
date	2010.06.30.19.23.09;	author jordan;	state Exp;
branches;
next	1.161;

1.161
date	2010.06.29.22.08.29;	author jordan;	state Exp;
branches;
next	1.160;

1.160
date	2010.06.27.21.04.22;	author jordan;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.27.07.26.31;	author jordan;	state Exp;
branches;
next	1.158;

1.158
date	2010.06.19.19.43.06;	author jordan;	state Exp;
branches;
next	1.157;

1.157
date	2009.12.05.02.38.11;	author jordan;	state Exp;
branches;
next	1.156;

1.156
date	2009.11.13.11.39.56;	author jordan;	state Exp;
branches;
next	1.155;

1.155
date	2009.10.16.15.49.25;	author jordan;	state Exp;
branches;
next	1.154;

1.154
date	2009.09.04.22.50.11;	author jordan;	state Exp;
branches;
next	1.153;

1.153
date	2009.07.20.05.13.30;	author jordan;	state Exp;
branches;
next	1.152;

1.152
date	2009.07.17.21.44.48;	author jordan;	state Exp;
branches;
next	1.151;

1.151
date	2009.07.15.21.06.25;	author martynas;	state Exp;
branches;
next	1.150;

1.150
date	2009.06.01.22.36.12;	author jordan;	state Exp;
branches;
next	1.149;

1.149
date	2009.05.30.22.49.56;	author jordan;	state Exp;
branches;
next	1.148;

1.148
date	2009.05.30.22.42.02;	author jordan;	state Exp;
branches;
next	1.147;

1.147
date	2009.04.27.23.39.14;	author jordan;	state Exp;
branches;
next	1.146;

1.146
date	2009.04.10.16.05.10;	author jordan;	state Exp;
branches;
next	1.145;

1.145
date	2009.04.10.03.32.24;	author marco;	state Exp;
branches;
next	1.144;

1.144
date	2009.04.09.16.52.32;	author jordan;	state Exp;
branches;
next	1.143;

1.143
date	2009.03.13.19.01.03;	author marco;	state Exp;
branches;
next	1.142;

1.142
date	2009.03.13.18.41.57;	author jordan;	state Exp;
branches;
next	1.141;

1.141
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.140;

1.140
date	2009.03.10.20.36.10;	author jordan;	state Exp;
branches;
next	1.139;

1.139
date	2009.03.07.07.04.38;	author jordan;	state Exp;
branches;
next	1.138;

1.138
date	2009.03.05.04.59.58;	author jordan;	state Exp;
branches;
next	1.137;

1.137
date	2009.03.05.04.48.11;	author jordan;	state Exp;
branches;
next	1.136;

1.136
date	2008.10.07.18.02.20;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2008.10.04.18.48.04;	author kettenis;	state Exp;
branches;
next	1.134;

1.134
date	2008.09.29.18.29.43;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2008.09.25.19.12.28;	author jordan;	state Exp;
branches;
next	1.132;

1.132
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.131;

1.131
date	2008.08.14.17.41.20;	author jsing;	state Exp;
branches;
next	1.130;

1.130
date	2008.06.14.21.40.16;	author jordan;	state Exp;
branches;
next	1.129;

1.129
date	2008.06.13.05.53.56;	author canacar;	state Exp;
branches;
next	1.128;

1.128
date	2008.06.13.01.10.41;	author jordan;	state Exp;
branches;
next	1.127;

1.127
date	2008.06.13.00.04.33;	author jordan;	state Exp;
branches;
next	1.126;

1.126
date	2008.06.12.20.36.50;	author jordan;	state Exp;
branches;
next	1.125;

1.125
date	2008.06.12.20.30.09;	author jordan;	state Exp;
branches;
next	1.124;

1.124
date	2008.06.12.19.05.42;	author jordan;	state Exp;
branches;
next	1.123;

1.123
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.122;

1.122
date	2008.06.08.17.20.52;	author art;	state Exp;
branches;
next	1.121;

1.121
date	2008.06.08.15.36.57;	author canacar;	state Exp;
branches;
next	1.120;

1.120
date	2008.06.08.02.52.40;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2008.06.07.17.30.50;	author marco;	state Exp;
branches;
next	1.118;

1.118
date	2008.06.06.09.15.32;	author marco;	state Exp;
branches;
next	1.117;

1.117
date	2008.06.04.18.20.09;	author marco;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.115;

1.115
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.114;

1.114
date	2008.05.15.23.23.09;	author jordan;	state Exp;
branches;
next	1.113;

1.113
date	2008.05.15.22.15.54;	author jordan;	state Exp;
branches;
next	1.112;

1.112
date	2008.05.14.21.47.00;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2008.05.14.21.13.40;	author miod;	state Exp;
branches;
next	1.110;

1.110
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.109;

1.109
date	2008.02.07.17.48.59;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2008.02.05.21.15.26;	author jordan;	state Exp;
branches;
next	1.107;

1.107
date	2008.01.22.19.28.57;	author jordan;	state Exp;
branches;
next	1.106;

1.106
date	2007.12.02.22.24.54;	author jordan;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.17.21.52.25;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2007.11.17.16.41.47;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2007.11.15.16.02.18;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2007.11.14.20.31.31;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2007.11.14.20.22.11;	author canacar;	state Exp;
branches;
next	1.100;

1.100
date	2007.11.10.17.53.16;	author chl;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.08.22.41.48;	author canacar;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.08.20.27.20;	author canacar;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.05.03.15.22;	author weingart;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.03.21.13.48;	author ckuethe;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.03.19.17.47;	author canacar;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.03.19.06.07;	author canacar;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.03.17.48.10;	author ckuethe;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.03.17.33.50;	author ckuethe;	state Exp;
branches;
next	1.91;

1.91
date	2007.11.03.17.23.25;	author jordan;	state Exp;
branches;
next	1.90;

1.90
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.13.03.43.22;	author weingart;	state Exp;
branches;
next	1.88;

1.88
date	2007.09.08.21.19.52;	author gwk;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.11.02.51.11;	author jordan;	state Exp;
branches;
next	1.86;

1.86
date	2007.03.23.05.43.46;	author jordan;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.27.20.22.23;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.27.19.53.32;	author jordan;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.22.06.22.31;	author jordan;	state Exp;
branches;
next	1.82;

1.82
date	2007.02.21.03.36.25;	author jordan;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.20.16.52.40;	author marco;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.18.02.25.05;	author jordan;	state Exp;
branches;
next	1.79;

1.79
date	2007.02.13.04.40.00;	author jordan;	state Exp;
branches;
next	1.78;

1.78
date	2007.02.06.18.56.31;	author jordan;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.23.04.05.58;	author jordan;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.18.19.01.02;	author jordan;	state Exp;
branches;
next	1.75;

1.75
date	2007.01.16.21.21.28;	author marco;	state Exp;
branches;
next	1.74;

1.74
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.23.17.19.06;	author canacar;	state Exp;
branches;
next	1.72;

1.72
date	2006.12.20.22.45.26;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2006.12.20.18.27.49;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.12.20.17.28.04;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.18.18.36.05;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.12.16.59.52;	author tom;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.29.22.17.07;	author marco;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.27.23.43.47;	author jordan;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.27.15.17.37;	author jordan;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.25.18.24.54;	author marco;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.11.19.26.01;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.31.13.49.44;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.30.18.37.07;	author jordan;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.25.21.23.19;	author jordan;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.25.20.55.47;	author jordan;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.24.19.01.48;	author jordan;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.23.20.23.26;	author jordan;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.19.07.02.20;	author jordan;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.19.03.24.45;	author jordan;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.19.01.06.54;	author jordan;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.15.16.47.12;	author jordan;	state Exp;
branches;
next	1.52;

1.52
date	2006.10.15.15.28.32;	author jordan;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.15.07.30.01;	author canacar;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.12.23.16.11;	author jordan;	state Exp;
branches;
next	1.49;

1.49
date	2006.10.12.16.54.01;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.14.16.30.07;	author canacar;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.31.14.02.12;	author canacar;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.31.03.25.29;	author canacar;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.29.21.27.59;	author canacar;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.29.02.39.49;	author gwk;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.29.00.43.56;	author canacar;	state Exp;
branches;
next	1.41;

1.41
date	2006.04.21.23.03.04;	author joris;	state Exp;
branches;
next	1.40;

1.40
date	2006.04.16.22.23.37;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.21.21.11.10;	author jordan;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.09.05.38.12;	author jordan;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.09.05.24.03;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.09.05.17.24;	author jordan;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.08.21.03.18;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.08.04.05.01;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.07.23.13.28;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.05.14.46.46;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.26.07.57.47;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.23.19.56.44;	author jordan;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.22.19.29.24;	author jordan;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.20.22.03.58;	author jordan;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.20.21.58.49;	author jordan;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.20.21.55.42;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.19.21.32.30;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.19.04.50.47;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2006.02.17.17.35.59;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2006.02.17.00.46.54;	author jordan;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.16.22.42.11;	author jordan;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.16.21.11.13;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.03.23.55.47;	author jordan;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.20.20.20.28;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.18.22.25.44;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.17.23.42.14;	author jordan;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.06.08.37.32;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.05.22.30.27;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.30.05.59.40;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.28.03.04.56;	author jordan;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.16.00.08.53;	author jordan;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.14.03.46.38;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.13.07.23.34;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.13.04.16.56;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.09.02.27.28;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.08.00.01.13;	author jordan;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.07.22.34.20;	author jordan;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.07.08.09.05;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.07.07.46.51;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.07.04.28.29;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.07.04.24.31;	author jordan;	state Exp;
branches;
next	;


desc
@@


1.234
log
@
Remove a redundant assignment introduced in revision 1.219 but favor the
assignment outside of the conditional.

ok stsp@@
@
text
@/* $OpenBSD: dsdt.c,v 1.233 2017/04/15 04:54:04 guenther Exp $ */
/*
 * Copyright (c) 2005 Jordan Hargrave <jordan@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/time.h>

#include <machine/bus.h>

#ifdef DDB
#include <machine/db_machdep.h>
#endif

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#ifdef SMALL_KERNEL
#undef ACPI_DEBUG
#endif

#define opsize(opcode) (((opcode) & 0xFF00) ? 2 : 1)

#define AML_FIELD_RESERVED	0x00
#define AML_FIELD_ATTRIB	0x01

#define AML_REVISION		0x01
#define AML_INTSTRLEN		16
#define AML_NAMESEG_LEN		4

struct aml_scope	*aml_load(struct acpi_softc *, struct aml_scope *,
			    struct aml_value *, struct aml_value *);

void			aml_copyvalue(struct aml_value *, struct aml_value *);

void			aml_setvalue(struct aml_scope *, struct aml_value *,
			    struct aml_value *, int64_t);
void			aml_freevalue(struct aml_value *);
struct aml_value	*aml_allocvalue(int, int64_t, const void *);
struct aml_value	*_aml_setvalue(struct aml_value *, int, int64_t,
			    const void *);

u_int64_t		aml_convradix(u_int64_t, int, int);
u_int64_t		aml_evalexpr(u_int64_t, u_int64_t, int);
int			aml_lsb(u_int64_t);
int			aml_msb(u_int64_t);

int			aml_tstbit(const u_int8_t *, int);
void			aml_setbit(u_int8_t *, int, int);

void			aml_addref(struct aml_value *, const char *);
void			aml_delref(struct aml_value **, const char *);

void			aml_bufcpy(void *, int, const void *, int, int);

int			aml_pc(uint8_t *);

struct aml_value	*aml_parseop(struct aml_scope *, struct aml_value *,int);
struct aml_value	*aml_parsetarget(struct aml_scope *, struct aml_value *,
			    struct aml_value **);
struct aml_value	*aml_parseterm(struct aml_scope *, struct aml_value *);

struct aml_value	*aml_evaltarget(struct aml_scope *scope,
			    struct aml_value *res);
int			aml_evalterm(struct aml_scope *scope,
			    struct aml_value *raw, struct aml_value *dst);

struct aml_opcode	*aml_findopcode(int);

#define acpi_os_malloc(sz) _acpi_os_malloc(sz, __FUNCTION__, __LINE__)
#define acpi_os_free(ptr)  _acpi_os_free(ptr, __FUNCTION__, __LINE__)

void			*_acpi_os_malloc(size_t, const char *, int);
void			_acpi_os_free(void *, const char *, int);
void			acpi_stall(int);

struct aml_value	*aml_callosi(struct aml_scope *, struct aml_value *);

const char		*aml_getname(const char *);
int64_t			aml_hextoint(const char *);
void			aml_dump(int, u_int8_t *);
void			_aml_die(const char *fn, int line, const char *fmt, ...);
#define aml_die(x...)	_aml_die(__FUNCTION__, __LINE__, x)

void aml_notify_task(void *, int);
void acpi_poll_notify_task(void *, int);

extern char		*hw_vendor;

/*
 * @@@@@@: Global variables
 */
int			aml_intlen = 64;
struct aml_node		aml_root;
struct aml_value	*aml_global_lock;

/* Perfect Hash key */
#define HASH_OFF		6904
#define HASH_SIZE		179
#define HASH_KEY(k)		(((k) ^ HASH_OFF) % HASH_SIZE)

/*
 * XXX this array should be sorted, and then aml_findopcode() should
 * do a binary search
 */
struct aml_opcode **aml_ophash;
struct aml_opcode aml_table[] = {
	/* Simple types */
	{ AMLOP_ZERO,		"Zero",		"c",	},
	{ AMLOP_ONE,		"One",		"c",	},
	{ AMLOP_ONES,		"Ones",		"c",	},
	{ AMLOP_REVISION,	"Revision",	"R",	},
	{ AMLOP_BYTEPREFIX,	".Byte",	"b",	},
	{ AMLOP_WORDPREFIX,	".Word",	"w",	},
	{ AMLOP_DWORDPREFIX,	".DWord",	"d",	},
	{ AMLOP_QWORDPREFIX,	".QWord",	"q",	},
	{ AMLOP_STRINGPREFIX,	".String",	"a",	},
	{ AMLOP_DEBUG,		"DebugOp",	"D",	},
	{ AMLOP_BUFFER,		"Buffer",	"piB",	},
	{ AMLOP_PACKAGE,	"Package",	"pbT",	},
	{ AMLOP_VARPACKAGE,	"VarPackage",	"piT",	},

	/* Simple objects */
	{ AMLOP_LOCAL0,		"Local0",	"L",	},
	{ AMLOP_LOCAL1,		"Local1",	"L",	},
	{ AMLOP_LOCAL2,		"Local2",	"L",	},
	{ AMLOP_LOCAL3,		"Local3",	"L",	},
	{ AMLOP_LOCAL4,		"Local4",	"L",	},
	{ AMLOP_LOCAL5,		"Local5",	"L",	},
	{ AMLOP_LOCAL6,		"Local6",	"L",	},
	{ AMLOP_LOCAL7,		"Local7",	"L",	},
	{ AMLOP_ARG0,		"Arg0",		"A",	},
	{ AMLOP_ARG1,		"Arg1",		"A",	},
	{ AMLOP_ARG2,		"Arg2",		"A",	},
	{ AMLOP_ARG3,		"Arg3",		"A",	},
	{ AMLOP_ARG4,		"Arg4",		"A",	},
	{ AMLOP_ARG5,		"Arg5",		"A",	},
	{ AMLOP_ARG6,		"Arg6",		"A",	},

	/* Control flow */
	{ AMLOP_IF,		"If",		"piI",	},
	{ AMLOP_ELSE,		"Else",		"pT" },
	{ AMLOP_WHILE,		"While",	"piT",	},
	{ AMLOP_BREAK,		"Break",	"" },
	{ AMLOP_CONTINUE,	"Continue",	"" },
	{ AMLOP_RETURN,		"Return",	"t",	},
	{ AMLOP_FATAL,		"Fatal",	"bdi",	},
	{ AMLOP_NOP,		"Nop",		"",	},
	{ AMLOP_BREAKPOINT,	"BreakPoint",	"",     },

	/* Arithmetic operations */
	{ AMLOP_INCREMENT,	"Increment",	"S",	},
	{ AMLOP_DECREMENT,	"Decrement",	"S",	},
	{ AMLOP_ADD,		"Add",		"iir",	},
	{ AMLOP_SUBTRACT,	"Subtract",	"iir",	},
	{ AMLOP_MULTIPLY,	"Multiply",	"iir",	},
	{ AMLOP_DIVIDE,		"Divide",	"iirr",	},
	{ AMLOP_SHL,		"ShiftLeft",	"iir",	},
	{ AMLOP_SHR,		"ShiftRight",	"iir",	},
	{ AMLOP_AND,		"And",		"iir",	},
	{ AMLOP_NAND,		"Nand",		"iir",	},
	{ AMLOP_OR,		"Or",		"iir",	},
	{ AMLOP_NOR,		"Nor",		"iir",	},
	{ AMLOP_XOR,		"Xor",		"iir",	},
	{ AMLOP_NOT,		"Not",		"ir",	},
	{ AMLOP_MOD,		"Mod",		"iir",	},
	{ AMLOP_FINDSETLEFTBIT,	"FindSetLeftBit", "ir",	},
	{ AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",},

	/* Logical test operations */
	{ AMLOP_LAND,		"LAnd",		"ii",	},
	{ AMLOP_LOR,		"LOr",		"ii",	},
	{ AMLOP_LNOT,		"LNot",		"i",	},
	{ AMLOP_LNOTEQUAL,	"LNotEqual",	"tt",	},
	{ AMLOP_LLESSEQUAL,	"LLessEqual",	"tt",	},
	{ AMLOP_LGREATEREQUAL,	"LGreaterEqual", "tt",	},
	{ AMLOP_LEQUAL,		"LEqual",	"tt",	},
	{ AMLOP_LGREATER,	"LGreater",	"tt",	},
	{ AMLOP_LLESS,		"LLess",	"tt",	},

	/* Named objects */
	{ AMLOP_NAMECHAR,	".NameRef",	"n",	},
	{ AMLOP_ALIAS,		"Alias",	"nN",	},
	{ AMLOP_NAME,		"Name",	"Nt",	},
	{ AMLOP_EVENT,		"Event",	"N",	},
	{ AMLOP_MUTEX,		"Mutex",	"Nb",	},
	{ AMLOP_DATAREGION,	"DataRegion",	"Nttt",	},
	{ AMLOP_OPREGION,	"OpRegion",	"Nbii",	},
	{ AMLOP_SCOPE,		"Scope",	"pnT",	},
	{ AMLOP_DEVICE,		"Device",	"pNT",	},
	{ AMLOP_POWERRSRC,	"Power Resource", "pNbwT",},
	{ AMLOP_THERMALZONE,	"ThermalZone",	"pNT",	},
	{ AMLOP_PROCESSOR,	"Processor",	"pNbdbT", },
	{ AMLOP_METHOD,		"Method",	"pNbM",	},

	/* Field operations */
	{ AMLOP_FIELD,		"Field",	"pnbF",	},
	{ AMLOP_INDEXFIELD,	"IndexField",	"pnnbF",},
	{ AMLOP_BANKFIELD,	"BankField",	"pnnibF",},
	{ AMLOP_CREATEFIELD,	"CreateField",	"tiiN",		},
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",},
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",},
	{ AMLOP_CREATEWORDFIELD, "CreateWordField", "tiN",},
	{ AMLOP_CREATEBYTEFIELD, "CreateByteField", "tiN",},
	{ AMLOP_CREATEBITFIELD,	"CreateBitField", "tiN",	},

	/* Conversion operations */
	{ AMLOP_TOINTEGER,	"ToInteger",	"tr",	},
	{ AMLOP_TOBUFFER,	"ToBuffer",	"tr",	},
	{ AMLOP_TODECSTRING,	"ToDecString",	"ir",	},
	{ AMLOP_TOHEXSTRING,	"ToHexString",	"ir",	},
	{ AMLOP_TOSTRING,	"ToString",	"tir",	},
	{ AMLOP_MID,		"Mid",		"tiir",	},
	{ AMLOP_FROMBCD,	"FromBCD",	"ir",	},
	{ AMLOP_TOBCD,		"ToBCD",	"ir",	},

	/* Mutex/Signal operations */
	{ AMLOP_ACQUIRE,	"Acquire",	"Sw",	},
	{ AMLOP_RELEASE,	"Release",	"S",	},
	{ AMLOP_SIGNAL,		"Signal",	"S",	},
	{ AMLOP_WAIT,		"Wait",		"Si",	},
	{ AMLOP_RESET,		"Reset",	"S",	},

	{ AMLOP_INDEX,		"Index",	"tir",	},
	{ AMLOP_DEREFOF,	"DerefOf",	"t",	},
	{ AMLOP_REFOF,		"RefOf",	"S",	},
	{ AMLOP_CONDREFOF,	"CondRef",	"Sr",	},

	{ AMLOP_LOADTABLE,	"LoadTable",	"tttttt" },
	{ AMLOP_STALL,		"Stall",	"i",	},
	{ AMLOP_SLEEP,		"Sleep",	"i",	},
	{ AMLOP_TIMER,		"Timer",	"",	},
	{ AMLOP_LOAD,		"Load",		"nS",	},
	{ AMLOP_UNLOAD,		"Unload",	"t" },
	{ AMLOP_STORE,		"Store",	"tS",	},
	{ AMLOP_CONCAT,		"Concat",	"ttr",	},
	{ AMLOP_CONCATRES,	"ConcatRes",	"ttt" },
	{ AMLOP_NOTIFY,		"Notify",	"Si",	},
	{ AMLOP_SIZEOF,		"Sizeof",	"S",	},
	{ AMLOP_MATCH,		"Match",	"tbibii", },
	{ AMLOP_OBJECTTYPE,	"ObjectType",	"S",	},
	{ AMLOP_COPYOBJECT,	"CopyObject",	"tS",	},
};

int aml_pc(uint8_t *src)
{
	return src - aml_root.start;
}

struct aml_scope *aml_lastscope;

void
_aml_die(const char *fn, int line, const char *fmt, ...)
{
#ifndef SMALL_KERNEL
	struct aml_scope *root;
	struct aml_value *sp;
	int idx;
#endif /* SMALL_KERNEL */
	va_list ap;

	va_start(ap, fmt);
	vprintf(fmt, ap);
	printf("\n");
	va_end(ap);

#ifndef SMALL_KERNEL
	for (root = aml_lastscope; root && root->pos; root = root->parent) {
		printf("%.4x Called: %s\n", aml_pc(root->pos),
		    aml_nodename(root->node));
		for (idx = 0; idx < AML_MAX_ARG; idx++) {
			sp = aml_getstack(root, AMLOP_ARG0+idx);
			if (sp && sp->type) {
				printf("  arg%d: ", idx);
				aml_showvalue(sp);
			}
		}
		for (idx = 0; idx < AML_MAX_LOCAL; idx++) {
			sp = aml_getstack(root, AMLOP_LOCAL0+idx);
			if (sp && sp->type) {
				printf("  local%d: ", idx);
				aml_showvalue(sp);
			}
		}
	}
#endif /* SMALL_KERNEL */

	/* XXX: don't panic */
	panic("aml_die %s:%d", fn, line);
}

void
aml_hashopcodes(void)
{
	int i;

	/* Dynamically allocate hash table */
	aml_ophash = (struct aml_opcode **)acpi_os_malloc(HASH_SIZE *
	    sizeof(struct aml_opcode *));
	for (i = 0; i < sizeof(aml_table) / sizeof(aml_table[0]); i++)
		aml_ophash[HASH_KEY(aml_table[i].opcode)] = &aml_table[i];
}

struct aml_opcode *
aml_findopcode(int opcode)
{
	struct aml_opcode *hop;

	hop = aml_ophash[HASH_KEY(opcode)];
	if (hop && hop->opcode == opcode)
		return hop;
	return NULL;
}

#if defined(DDB) || !defined(SMALL_KERNEL)
const char *
aml_mnem(int opcode, uint8_t *pos)
{
	struct aml_opcode *tab;
	static char mnemstr[32];

	if ((tab = aml_findopcode(opcode)) != NULL) {
		strlcpy(mnemstr, tab->mnem, sizeof(mnemstr));
		if (pos != NULL) {
			switch (opcode) {
			case AMLOP_STRINGPREFIX:
				snprintf(mnemstr, sizeof(mnemstr), "\"%s\"", pos);
				break;
			case AMLOP_BYTEPREFIX:
				snprintf(mnemstr, sizeof(mnemstr), "0x%.2x",
					 *(uint8_t *)pos);
				break;
			case AMLOP_WORDPREFIX:
				snprintf(mnemstr, sizeof(mnemstr), "0x%.4x",
					 *(uint16_t *)pos);
				break;
			case AMLOP_DWORDPREFIX:
				snprintf(mnemstr, sizeof(mnemstr), "0x%.4x",
					 *(uint16_t *)pos);
				break;
			case AMLOP_NAMECHAR:
				strlcpy(mnemstr, aml_getname(pos), sizeof(mnemstr));
				break;
			}
		}
		return mnemstr;
	}
	return ("xxx");
}
#endif /* defined(DDB) || !defined(SMALL_KERNEL) */

struct aml_notify_data {
	struct aml_node		*node;
	char			pnpid[20];
	void			*cbarg;
	int			(*cbproc)(struct aml_node *, int, void *);
	int			poll;

	SLIST_ENTRY(aml_notify_data) link;
};

SLIST_HEAD(aml_notify_head, aml_notify_data);
struct aml_notify_head aml_notify_list =
    SLIST_HEAD_INITIALIZER(aml_notify_list);

/*
 *  @@@@@@: Memory management functions
 */

long acpi_nalloc;

struct acpi_memblock {
	size_t size;
#ifdef ACPI_MEMDEBUG
	const char *fn;
	int         line;
	int         sig;
	LIST_ENTRY(acpi_memblock) link;
#endif
};

#ifdef ACPI_MEMDEBUG
LIST_HEAD(, acpi_memblock)	acpi_memhead;
int				acpi_memsig;

int
acpi_walkmem(int sig, const char *lbl)
{
	struct acpi_memblock *sptr;

	printf("--- walkmem:%s %x --- %lx bytes alloced\n", lbl, sig,
	    acpi_nalloc);
	LIST_FOREACH(sptr, &acpi_memhead, link) {
		if (sptr->sig < sig)
			break;
		printf("%.4x Alloc %.8lx bytes @@ %s:%d\n",
			sptr->sig, sptr->size, sptr->fn, sptr->line);
	}
	return acpi_memsig;
}
#endif /* ACPI_MEMDEBUG */

void *
_acpi_os_malloc(size_t size, const char *fn, int line)
{
	struct acpi_memblock *sptr;

	sptr = malloc(size+sizeof(*sptr), M_ACPI, M_WAITOK | M_ZERO);
	dnprintf(99, "alloc: %p %s:%d\n", sptr, fn, line);
	acpi_nalloc += size;
	sptr->size = size;
#ifdef ACPI_MEMDEBUG
	sptr->line = line;
	sptr->fn = fn;
	sptr->sig = ++acpi_memsig;

	LIST_INSERT_HEAD(&acpi_memhead, sptr, link);
#endif

	return &sptr[1];
}

void
_acpi_os_free(void *ptr, const char *fn, int line)
{
	struct acpi_memblock *sptr;

	if (ptr != NULL) {
		sptr = &(((struct acpi_memblock *)ptr)[-1]);
		acpi_nalloc -= sptr->size;

#ifdef ACPI_MEMDEBUG
		LIST_REMOVE(sptr, link);
#endif

		dnprintf(99, "free: %p %s:%d\n", sptr, fn, line);
		free(sptr, M_ACPI, 0);
	}
}

void
acpi_sleep(int ms, char *reason)
{
	static int acpinowait;
	int to = ms * hz / 1000;

	if (cold)
		delay(ms * 1000);
	else {
		if (to <= 0)
			to = 1;
		tsleep(&acpinowait, PWAIT, reason, to);
	}
}

void
acpi_stall(int us)
{
	delay(us);
}

/*
 * @@@@@@: Misc utility functions
 */

#ifdef ACPI_DEBUG
void
aml_dump(int len, u_int8_t *buf)
{
	int		idx;

	dnprintf(50, "{ ");
	for (idx = 0; idx < len; idx++) {
		dnprintf(50, "%s0x%.2x", idx ? ", " : "", buf[idx]);
	}
	dnprintf(50, " }\n");
}
#endif

/* Bit mangling code */
int
aml_tstbit(const u_int8_t *pb, int bit)
{
	pb += aml_bytepos(bit);

	return (*pb & aml_bitmask(bit));
}

void
aml_setbit(u_int8_t *pb, int bit, int val)
{
	pb += aml_bytepos(bit);

	if (val)
		*pb |= aml_bitmask(bit);
	else
		*pb &= ~aml_bitmask(bit);
}

/*
 * @@@@@@: Notify functions
 */
void
acpi_poll(void *arg)
{
	int s;

	s = spltty();
	acpi_addtask(acpi_softc, acpi_poll_notify_task, NULL, 0);
	acpi_softc->sc_threadwaiting = 0;
	wakeup(acpi_softc);
	splx(s);

	timeout_add_sec(&acpi_softc->sc_dev_timeout, 10);
}

void
aml_notify_task(void *node, int notify_value)
{
	struct aml_notify_data	*pdata = NULL;

	dnprintf(10,"run notify: %s %x\n", aml_nodename(node), notify_value);
	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (pdata->node == node)
			pdata->cbproc(pdata->node, notify_value, pdata->cbarg);
}

void
aml_register_notify(struct aml_node *node, const char *pnpid,
    int (*proc)(struct aml_node *, int, void *), void *arg, int poll)
{
	struct aml_notify_data	*pdata;
	extern int acpi_poll_enabled;

	dnprintf(10, "aml_register_notify: %s %s %p\n",
	    node->name, pnpid ? pnpid : "", proc);

	pdata = acpi_os_malloc(sizeof(struct aml_notify_data));
	pdata->node = node;
	pdata->cbarg = arg;
	pdata->cbproc = proc;
	pdata->poll = poll;

	if (pnpid)
		strlcpy(pdata->pnpid, pnpid, sizeof(pdata->pnpid));

	SLIST_INSERT_HEAD(&aml_notify_list, pdata, link);

	if (poll && !acpi_poll_enabled)
		timeout_add_sec(&acpi_softc->sc_dev_timeout, 10);
}

void
aml_notify(struct aml_node *node, int notify_value)
{
	if (node == NULL)
		return;

	dnprintf(10,"queue notify: %s %x\n", aml_nodename(node), notify_value);
	acpi_addtask(acpi_softc, aml_notify_task, node, notify_value);
}

void
aml_notify_dev(const char *pnpid, int notify_value)
{
	struct aml_notify_data	*pdata = NULL;

	if (pnpid == NULL)
		return;

	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (strcmp(pdata->pnpid, pnpid) == 0)
			pdata->cbproc(pdata->node, notify_value, pdata->cbarg);
}

void
acpi_poll_notify_task(void *arg0, int arg1)
{
	struct aml_notify_data	*pdata = NULL;

	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (pdata->cbproc && pdata->poll)
			pdata->cbproc(pdata->node, 0, pdata->cbarg);
}

/*
 * @@@@@@: Namespace functions
 */

struct aml_node *__aml_search(struct aml_node *, uint8_t *, int);
struct aml_node *__aml_searchname(struct aml_node *, const void *, int);
void aml_delchildren(struct aml_node *);


/* Search for a name in children nodes */
struct aml_node *
__aml_search(struct aml_node *root, uint8_t *nameseg, int create)
{
	struct aml_node *node;

	/* XXX: Replace with SLIST/SIMPLEQ routines */
	if (root == NULL)
		return NULL;
	SIMPLEQ_FOREACH(node, &root->son, sib) {
		if (!strncmp(node->name, nameseg, AML_NAMESEG_LEN))
			return node;
	}
	if (create) {
		node = acpi_os_malloc(sizeof(struct aml_node));
		memcpy((void *)node->name, nameseg, AML_NAMESEG_LEN);
		node->value = aml_allocvalue(0,0,NULL);
		node->value->node = node;
		node->parent = root;

		SIMPLEQ_INIT(&node->son);
		SIMPLEQ_INSERT_TAIL(&root->son, node, sib);
	}
	return node;
}

/* Get absolute pathname of AML node */
const char *
aml_nodename(struct aml_node *node)
{
	static char namebuf[128];

	namebuf[0] = 0;
	if (node) {
		aml_nodename(node->parent);
		if (node->parent != &aml_root)
			strlcat(namebuf, ".", sizeof(namebuf));
		strlcat(namebuf, node->name, sizeof(namebuf));
		return namebuf+1;
	}
	return namebuf;
}

const char *
aml_getname(const char *name)
{
	static char namebuf[128], *p;
	int count;

	p = namebuf;
	while (*name == AMLOP_ROOTCHAR || *name == AMLOP_PARENTPREFIX)
		*(p++) = *(name++);
	switch (*name) {
	case 0x00:
		count = 0;
		break;
	case AMLOP_MULTINAMEPREFIX:
		count = name[1];
		name += 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		name += 1;
		break;
	default:
		count = 1;
	}
	while (count--) {
		memcpy(p, name, 4);
		p[4] = '.';
		p += 5;
		name += 4;
		if (*name == '.') name++;
	}
	*(--p) = 0;
	return namebuf;
}

/* Free all children nodes/values */
void
aml_delchildren(struct aml_node *node)
{
	struct aml_node *onode;

	if (node == NULL)
		return;
	while ((onode = SIMPLEQ_FIRST(&node->son)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&node->son, sib);

		aml_delchildren(onode);

		/* Don't delete values that have references */
		if (onode->value && onode->value->refcnt > 1)
			onode->value->node = NULL;

		/* Decrease reference count */
		aml_delref(&onode->value, "");

		/* Delete node */
		acpi_os_free(onode);
	}
}

/*
 * @@@@@@: Value functions
 */

/*
 * Field I/O code
 */
void aml_unlockfield(struct aml_scope *, struct aml_value *);
void aml_lockfield(struct aml_scope *, struct aml_value *);

static long global_lock_count = 0;

void
acpi_glk_enter(void)
{
	int st = 0;

	/* If lock is already ours, just continue. */
	if (global_lock_count++)
		return;

	/* Spin to acquire the lock. */
	while (!st) {
		st = acpi_acquire_glk(&acpi_softc->sc_facs->global_lock);
		/* XXX - yield/delay? */
	}
}

void
acpi_glk_leave(void)
{
	int st, x;

	/* If we are the last one, turn out the lights. */
	if (--global_lock_count)
		return;

	st = acpi_release_glk(&acpi_softc->sc_facs->global_lock);
	if (!st)
		return;

	/*
	 * If pending, notify the BIOS that the lock was released by
	 * OSPM.  No locking is needed because nobody outside the ACPI
	 * thread is supposed to touch this register.
	 */
	x = acpi_read_pmreg(acpi_softc, ACPIREG_PM1_CNT, 0);
	x |= ACPI_PM1_GBL_RLS;
	acpi_write_pmreg(acpi_softc, ACPIREG_PM1_CNT, 0, x);
}

void
aml_lockfield(struct aml_scope *scope, struct aml_value *field)
{
	if (AML_FIELD_LOCK(field->v_field.flags) != AML_FIELD_LOCK_ON)
		return;

	acpi_glk_enter();
}

void
aml_unlockfield(struct aml_scope *scope, struct aml_value *field)
{
	if (AML_FIELD_LOCK(field->v_field.flags) != AML_FIELD_LOCK_ON)
		return;

	acpi_glk_leave();
}

/*
 * @@@@@@: Value set/compare/alloc/free routines
 */

#ifndef SMALL_KERNEL
void
aml_showvalue(struct aml_value *val)
{
	int idx;

	if (val == NULL)
		return;

	if (val->node)
		printf(" [%s]", aml_nodename(val->node));
	printf(" %p cnt:%.2x stk:%.2x", val, val->refcnt, val->stack);
	switch (val->type) {
	case AML_OBJTYPE_INTEGER:
		printf(" integer: %llx\n", val->v_integer);
		break;
	case AML_OBJTYPE_STRING:
		printf(" string: %s\n", val->v_string);
		break;
	case AML_OBJTYPE_METHOD:
		printf(" method: %.2x\n", val->v_method.flags);
		break;
	case AML_OBJTYPE_PACKAGE:
		printf(" package: %.2x\n", val->length);
		for (idx = 0; idx < val->length; idx++)
			aml_showvalue(val->v_package[idx]);
		break;
	case AML_OBJTYPE_BUFFER:
		printf(" buffer: %.2x {", val->length);
		for (idx = 0; idx < val->length; idx++)
			printf("%s%.2x", idx ? ", " : "", val->v_buffer[idx]);
		printf("}\n");
		break;
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		printf(" field: bitpos=%.4x bitlen=%.4x ref1:%p ref2:%p [%s]\n",
		    val->v_field.bitpos, val->v_field.bitlen,
		    val->v_field.ref1, val->v_field.ref2,
		    aml_mnem(val->v_field.type, NULL));
		if (val->v_field.ref1)
			printf("  ref1: %s\n", aml_nodename(val->v_field.ref1->node));
		if (val->v_field.ref2)
			printf("  ref2: %s\n", aml_nodename(val->v_field.ref2->node));
		break;
	case AML_OBJTYPE_MUTEX:
		printf(" mutex: %s ref: %d\n",
		    val->v_mutex ?  val->v_mutex->amt_name : "",
		    val->v_mutex ?  val->v_mutex->amt_ref_count : 0);
		break;
	case AML_OBJTYPE_EVENT:
		printf(" event:\n");
		break;
	case AML_OBJTYPE_OPREGION:
		printf(" opregion: %.2x,%.8llx,%x\n",
		    val->v_opregion.iospace, val->v_opregion.iobase,
		    val->v_opregion.iolen);
		break;
	case AML_OBJTYPE_NAMEREF:
		printf(" nameref: %s\n", aml_getname(val->v_nameref));
		break;
	case AML_OBJTYPE_DEVICE:
		printf(" device:\n");
		break;
	case AML_OBJTYPE_PROCESSOR:
		printf(" cpu: %.2x,%.4x,%.2x\n",
		    val->v_processor.proc_id, val->v_processor.proc_addr,
		    val->v_processor.proc_len);
		break;
	case AML_OBJTYPE_THERMZONE:
		printf(" thermzone:\n");
		break;
	case AML_OBJTYPE_POWERRSRC:
		printf(" pwrrsrc: %.2x,%.2x\n",
		    val->v_powerrsrc.pwr_level, val->v_powerrsrc.pwr_order);
		break;
	case AML_OBJTYPE_OBJREF:
		printf(" objref: %p index:%x opcode:%s\n", val->v_objref.ref,
		    val->v_objref.index, aml_mnem(val->v_objref.type, 0));
		aml_showvalue(val->v_objref.ref);
		break;
	default:
		printf(" !!type: %x\n", val->type);
	}
}
#endif /* SMALL_KERNEL */

int64_t
aml_val2int(struct aml_value *rval)
{
	int64_t ival = 0;

	if (rval == NULL) {
		dnprintf(50, "null val2int\n");
		return (0);
	}
	switch (rval->type) {
	case AML_OBJTYPE_INTEGER:
		ival = rval->v_integer;
		break;
	case AML_OBJTYPE_BUFFER:
		aml_bufcpy(&ival, 0, rval->v_buffer, 0,
		    min(aml_intlen, rval->length*8));
		break;
	case AML_OBJTYPE_STRING:
		ival = aml_hextoint(rval->v_string);
		break;
	}
	return (ival);
}

/* Sets value into LHS: lhs must already be cleared */
struct aml_value *
_aml_setvalue(struct aml_value *lhs, int type, int64_t ival, const void *bval)
{
	memset(&lhs->_, 0x0, sizeof(lhs->_));

	lhs->type = type;
	switch (lhs->type) {
	case AML_OBJTYPE_INTEGER:
		lhs->length = aml_intlen>>3;
		lhs->v_integer = ival;
		break;
	case AML_OBJTYPE_METHOD:
		lhs->v_method.flags = ival;
		lhs->v_method.fneval = bval;
		break;
	case AML_OBJTYPE_NAMEREF:
		lhs->v_nameref = (uint8_t *)bval;
		break;
	case AML_OBJTYPE_OBJREF:
		lhs->v_objref.type = ival;
		lhs->v_objref.ref = (struct aml_value *)bval;
		break;
	case AML_OBJTYPE_BUFFER:
		lhs->length = ival;
		lhs->v_buffer = (uint8_t *)acpi_os_malloc(ival);
		if (bval)
			memcpy(lhs->v_buffer, bval, ival);
		break;
	case AML_OBJTYPE_STRING:
		if (ival == -1)
			ival = strlen((const char *)bval);
		lhs->length = ival;
		lhs->v_string = (char *)acpi_os_malloc(ival+1);
		if (bval)
			strncpy(lhs->v_string, (const char *)bval, ival);
		break;
	case AML_OBJTYPE_PACKAGE:
		lhs->length = ival;
		lhs->v_package = (struct aml_value **)acpi_os_malloc(ival *
		    sizeof(struct aml_value *));
		for (ival = 0; ival < lhs->length; ival++)
			lhs->v_package[ival] = aml_allocvalue(
			    AML_OBJTYPE_UNINITIALIZED, 0, NULL);
		break;
	}
	return lhs;
}

/* Copy object to another value: lhs must already be cleared */
void
aml_copyvalue(struct aml_value *lhs, struct aml_value *rhs)
{
	int idx;

	lhs->type = rhs->type;
	switch (lhs->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		break;
	case AML_OBJTYPE_INTEGER:
		lhs->length = aml_intlen>>3;
		lhs->v_integer = rhs->v_integer;
		break;
	case AML_OBJTYPE_MUTEX:
		lhs->v_mutex = rhs->v_mutex;
		break;
	case AML_OBJTYPE_POWERRSRC:
		lhs->v_powerrsrc = rhs->v_powerrsrc;
		break;
	case AML_OBJTYPE_METHOD:
		lhs->v_method = rhs->v_method;
		break;
	case AML_OBJTYPE_BUFFER:
		_aml_setvalue(lhs, rhs->type, rhs->length, rhs->v_buffer);
		break;
	case AML_OBJTYPE_STRING:
		_aml_setvalue(lhs, rhs->type, rhs->length, rhs->v_string);
		break;
	case AML_OBJTYPE_OPREGION:
		lhs->v_opregion = rhs->v_opregion;
		break;
	case AML_OBJTYPE_PROCESSOR:
		lhs->v_processor = rhs->v_processor;
		break;
	case AML_OBJTYPE_NAMEREF:
		lhs->v_nameref = rhs->v_nameref;
		break;
	case AML_OBJTYPE_PACKAGE:
		_aml_setvalue(lhs, rhs->type, rhs->length, NULL);
		for (idx = 0; idx < rhs->length; idx++)
			aml_copyvalue(lhs->v_package[idx], rhs->v_package[idx]);
		break;
	case AML_OBJTYPE_OBJREF:
		lhs->v_objref = rhs->v_objref;
		aml_addref(lhs->v_objref.ref, "");
		break;
	default:
		printf("copyvalue: %x", rhs->type);
		break;
	}
}

/* Allocate dynamic AML value
 *   type : Type of object to allocate (AML_OBJTYPE_XXXX)
 *   ival : Integer value (action depends on type)
 *   bval : Buffer value (action depends on type)
 */
struct aml_value *
aml_allocvalue(int type, int64_t ival, const void *bval)
{
	struct aml_value *rv;

	rv = (struct aml_value *)acpi_os_malloc(sizeof(struct aml_value));
	if (rv != NULL) {
		aml_addref(rv, "");
		return _aml_setvalue(rv, type, ival, bval);
	}
	return NULL;
}

void
aml_freevalue(struct aml_value *val)
{
	int idx;

	if (val == NULL)
		return;
	switch (val->type) {
	case AML_OBJTYPE_STRING:
		acpi_os_free(val->v_string);
		break;
	case AML_OBJTYPE_BUFFER:
		acpi_os_free(val->v_buffer);
		break;
	case AML_OBJTYPE_PACKAGE:
		for (idx = 0; idx < val->length; idx++) {
			aml_freevalue(val->v_package[idx]);
			acpi_os_free(val->v_package[idx]);
		}
		acpi_os_free(val->v_package);
		break;
	case AML_OBJTYPE_OBJREF:
		aml_delref(&val->v_objref.ref, "");
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_delref(&val->v_field.ref1, "");
		aml_delref(&val->v_field.ref2, "");
		break;
	}
	val->type = 0;
	memset(&val->_, 0, sizeof(val->_));
}

/*
 * @@@@@@: Math eval routines
 */

/* Convert number from one radix to another
 * Used in BCD conversion routines */
u_int64_t
aml_convradix(u_int64_t val, int iradix, int oradix)
{
	u_int64_t rv = 0, pwr;

	rv = 0;
	pwr = 1;
	while (val) {
		rv += (val % iradix) * pwr;
		val /= iradix;
		pwr *= oradix;
	}
	return rv;
}

/* Calculate LSB */
int
aml_lsb(u_int64_t val)
{
	int		lsb;

	if (val == 0)
		return (0);

	for (lsb = 1; !(val & 0x1); lsb++)
		val >>= 1;

	return (lsb);
}

/* Calculate MSB */
int
aml_msb(u_int64_t val)
{
	int		msb;

	if (val == 0)
		return (0);

	for (msb = 1; val != 0x1; msb++)
		val >>= 1;

	return (msb);
}

/* Evaluate Math operands */
u_int64_t
aml_evalexpr(u_int64_t lhs, u_int64_t rhs, int opcode)
{
	u_int64_t res = 0;

	switch (opcode) {
		/* Math operations */
	case AMLOP_INCREMENT:
	case AMLOP_ADD:
		res = (lhs + rhs);
		break;
	case AMLOP_DECREMENT:
	case AMLOP_SUBTRACT:
		res = (lhs - rhs);
		break;
	case AMLOP_MULTIPLY:
		res = (lhs * rhs);
		break;
	case AMLOP_DIVIDE:
		res = (lhs / rhs);
		break;
	case AMLOP_MOD:
		res = (lhs % rhs);
		break;
	case AMLOP_SHL:
		res = (lhs << rhs);
		break;
	case AMLOP_SHR:
		res = (lhs >> rhs);
		break;
	case AMLOP_AND:
		res = (lhs & rhs);
		break;
	case AMLOP_NAND:
		res = ~(lhs & rhs);
		break;
	case AMLOP_OR:
		res = (lhs | rhs);
		break;
	case AMLOP_NOR:
		res = ~(lhs | rhs);
		break;
	case AMLOP_XOR:
		res = (lhs ^ rhs);
		break;
	case AMLOP_NOT:
		res = ~(lhs);
		break;

		/* Conversion/misc */
	case AMLOP_FINDSETLEFTBIT:
		res = aml_msb(lhs);
		break;
	case AMLOP_FINDSETRIGHTBIT:
		res = aml_lsb(lhs);
		break;
	case AMLOP_TOINTEGER:
		res = (lhs);
		break;
	case AMLOP_FROMBCD:
		res = aml_convradix(lhs, 16, 10);
		break;
	case AMLOP_TOBCD:
		res = aml_convradix(lhs, 10, 16);
		break;

		/* Logical/Comparison */
	case AMLOP_LAND:
		res = -(lhs && rhs);
		break;
	case AMLOP_LOR:
		res = -(lhs || rhs);
		break;
	case AMLOP_LNOT:
		res = -(!lhs);
		break;
	case AMLOP_LNOTEQUAL:
		res = -(lhs != rhs);
		break;
	case AMLOP_LLESSEQUAL:
		res = -(lhs <= rhs);
		break;
	case AMLOP_LGREATEREQUAL:
		res = -(lhs >= rhs);
		break;
	case AMLOP_LEQUAL:
		res = -(lhs == rhs);
		break;
	case AMLOP_LGREATER:
		res = -(lhs > rhs);
		break;
	case AMLOP_LLESS:
		res = -(lhs < rhs);
		break;
	}

	dnprintf(15,"aml_evalexpr: %s %llx %llx = %llx\n",
		 aml_mnem(opcode, NULL), lhs, rhs, res);

	return res;
}

/*
 * aml_bufcpy copies/shifts buffer data, special case for aligned transfers
 * dstPos/srcPos are bit positions within destination/source buffers
 */
void
aml_bufcpy(void *pvDst, int dstPos, const void *pvSrc, int srcPos, int len)
{
	const u_int8_t *pSrc = pvSrc;
	u_int8_t *pDst = pvDst;
	int		idx;

	if (aml_bytealigned(dstPos|srcPos|len)) {
		/* Aligned transfer: use memcpy */
		memcpy(pDst+aml_bytepos(dstPos), pSrc+aml_bytepos(srcPos),
		    aml_bytelen(len));
		return;
	}

	/* Misaligned transfer: perform bitwise copy (slow) */
	for (idx = 0; idx < len; idx++)
		aml_setbit(pDst, idx + dstPos, aml_tstbit(pSrc, idx + srcPos));
}

/*
 * @@@@@@: External API
 *
 * evaluate an AML node
 * Returns a copy of the value in res  (must be freed by user)
 */

void
aml_walknodes(struct aml_node *node, int mode,
    int (*nodecb)(struct aml_node *, void *), void *arg)
{
	struct aml_node *child;

	if (node == NULL)
		return;
	if (mode == AML_WALK_PRE)
		if (nodecb(node, arg))
			return;
	SIMPLEQ_FOREACH(child, &node->son, sib)
		aml_walknodes(child, mode, nodecb, arg);
	if (mode == AML_WALK_POST)
		nodecb(node, arg);
}

void
aml_find_node(struct aml_node *node, const char *name,
    int (*cbproc)(struct aml_node *, void *arg), void *arg)
{
	struct aml_node *child;
	const char *nn;

	SIMPLEQ_FOREACH(child, &node->son, sib) {
		nn = child->name;
		if (nn != NULL) {
			if (*nn == AMLOP_ROOTCHAR) nn++;
			while (*nn == AMLOP_PARENTPREFIX) nn++;
			if (strcmp(name, nn) == 0) {
				/* Only recurse if cbproc() wants us to */
				if (cbproc(child, arg) == 0)
					continue;
			}
		}
		aml_find_node(child, name, cbproc, arg);
	}
}

/*
 * @@@@@@: Parser functions
 */
uint8_t *aml_parsename(struct aml_node *, uint8_t *, struct aml_value **, int);
uint8_t *aml_parseend(struct aml_scope *scope);
int	aml_parselength(struct aml_scope *);
int	aml_parseopcode(struct aml_scope *);

/* Get AML Opcode */
int
aml_parseopcode(struct aml_scope *scope)
{
	int opcode = (scope->pos[0]);
	int twocode = (scope->pos[0]<<8) + scope->pos[1];

	/* Check if this is an embedded name */
	switch (opcode) {
	case AMLOP_ROOTCHAR:
	case AMLOP_PARENTPREFIX:
	case AMLOP_MULTINAMEPREFIX:
	case AMLOP_DUALNAMEPREFIX:
	case AMLOP_NAMECHAR:
		return AMLOP_NAMECHAR;
	}
	if (opcode >= 'A' && opcode <= 'Z')
		return AMLOP_NAMECHAR;
	if (twocode == AMLOP_LNOTEQUAL || twocode == AMLOP_LLESSEQUAL ||
	    twocode == AMLOP_LGREATEREQUAL || opcode == AMLOP_EXTPREFIX) {
		scope->pos += 2;
		return twocode;
	}
	scope->pos += 1;
	return opcode;
}

/* Decode embedded AML Namestring */
uint8_t *
aml_parsename(struct aml_node *inode, uint8_t *pos, struct aml_value **rval, int create)
{
	struct aml_node *relnode, *node = inode;
	uint8_t	*start = pos;
	int i;

	if (*pos == AMLOP_ROOTCHAR) {
		pos++;
		node = &aml_root;
	}
	while (*pos == AMLOP_PARENTPREFIX) {
		pos++;
		if ((node = node->parent) == NULL)
			node = &aml_root;
	}
	switch (*pos) {
	case 0x00:
		pos++;
		break;
	case AMLOP_MULTINAMEPREFIX:
		for (i=0; i<pos[1]; i++)
			node = __aml_search(node, pos+2+i*AML_NAMESEG_LEN,
			    create);
		pos += 2+i*AML_NAMESEG_LEN;
		break;
	case AMLOP_DUALNAMEPREFIX:
		node = __aml_search(node, pos+1, create);
		node = __aml_search(node, pos+1+AML_NAMESEG_LEN, create);
		pos += 1+2*AML_NAMESEG_LEN;
		break;
	default:
		/* If Relative Search (pos == start), recursively go up root */
		relnode = node;
		do {
			node = __aml_search(relnode, pos, create);
			relnode = relnode->parent;
		} while (!node && pos == start && relnode);
		pos += AML_NAMESEG_LEN;
		break;
	}
	if (node) {
		*rval = node->value;

		/* Dereference ALIAS here */
		if ((*rval)->type == AML_OBJTYPE_OBJREF &&
		    (*rval)->v_objref.type == AMLOP_ALIAS) {
			dnprintf(10, "deref alias: %s\n", aml_nodename(node));
			*rval = (*rval)->v_objref.ref;
		}
		aml_addref(*rval, 0);

		dnprintf(10, "parsename: %s %x\n", aml_nodename(node),
		    (*rval)->type);
	} else {
		*rval = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, start);

		dnprintf(10, "%s:%s not found\n", aml_nodename(inode),
		    aml_getname(start));
	}

	return pos;
}

/* Decode AML Length field
 *  AML Length field is encoded:
 *    byte0    byte1    byte2    byte3
 *    00xxxxxx                             : if upper bits == 00, length = xxxxxx
 *    01--xxxx yyyyyyyy                    : if upper bits == 01, length = yyyyyyyyxxxx
 *    10--xxxx yyyyyyyy zzzzzzzz           : if upper bits == 10, length = zzzzzzzzyyyyyyyyxxxx
 *    11--xxxx yyyyyyyy zzzzzzzz wwwwwwww  : if upper bits == 11, length = wwwwwwwwzzzzzzzzyyyyyyyyxxxx
 */
int
aml_parselength(struct aml_scope *scope)
{
	int len;
	uint8_t lcode;

	lcode = *(scope->pos++);
	if (lcode <= 0x3F)
		return lcode;

	/* lcode >= 0x40, multibyte length, get first byte of extended length */
	len = lcode & 0xF;
	len += *(scope->pos++) << 4L;
	if (lcode >= 0x80)
		len += *(scope->pos++) << 12L;
	if (lcode >= 0xC0)
		len += *(scope->pos++) << 20L;
	return len;
}

/* Get address of end of scope; based on current address */
uint8_t *
aml_parseend(struct aml_scope *scope)
{
	uint8_t *pos = scope->pos;
	int len;

	len = aml_parselength(scope);
	if (pos+len > scope->end) {
		dnprintf(10,
		    "Bad scope... runover pos:%.4x new end:%.4x scope "
		    "end:%.4x\n", aml_pc(pos), aml_pc(pos+len),
		    aml_pc(scope->end));
		pos = scope->end;
	}
	return pos+len;
}

/*
 * @@@@@@: Opcode utility functions
 */

/*
 * @@@@@@: Opcode functions
 */

int odp;

const char hext[] = "0123456789ABCDEF";

const char *
aml_eisaid(u_int32_t pid)
{
	static char id[8];

	id[0] = '@@' + ((pid >> 2) & 0x1F);
	id[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
	id[2] = '@@' + ((pid >> 8) & 0x1F);
	id[3] = hext[(pid >> 20) & 0xF];
	id[4] = hext[(pid >> 16) & 0xF];
	id[5] = hext[(pid >> 28) & 0xF];
	id[6] = hext[(pid >> 24) & 0xF];
	id[7] = 0;
	return id;
}

/*
 * @@@@@@: Default Object creation
 */
static char osstring[] = "Macrosift Windogs MT";
struct aml_defval {
	const char		*name;
	int			type;
	int64_t			ival;
	const void		*bval;
	struct aml_value	**gval;
} aml_defobj[] = {
	{ "_OS_", AML_OBJTYPE_STRING, -1, osstring },
	{ "_REV", AML_OBJTYPE_INTEGER, 2, NULL },
	{ "_GL", AML_OBJTYPE_MUTEX, 1, NULL, &aml_global_lock },
	{ "_OSI", AML_OBJTYPE_METHOD, 1, aml_callosi },

	/* Create default scopes */
	{ "_GPE" },
	{ "_PR_" },
	{ "_SB_" },
	{ "_TZ_" },
	{ "_SI_" },

	{ NULL }
};

/* _OSI Default Method:
 * Returns True if string argument matches list of known OS strings
 * We return True for Windows to fake out nasty bad AML
 */
char *aml_valid_osi[] = {
	"Windows 2000",
	"Windows 2001",
	"Windows 2001.1",
	"Windows 2001.1 SP1",
	"Windows 2001 SP0",
	"Windows 2001 SP1",
	"Windows 2001 SP2",
	"Windows 2001 SP3",
	"Windows 2001 SP4",
	"Windows 2006",
	"Windows 2006.1",
	"Windows 2006 SP1",
	"Windows 2006 SP2",
	"Windows 2009",
	"Windows 2012",
	"Windows 2013",
	"Windows 2015",
	NULL
};

struct aml_value *
aml_callosi(struct aml_scope *scope, struct aml_value *val)
{
	int idx, result=0;
	struct aml_value *fa;

	fa = aml_getstack(scope, AMLOP_ARG0);

	if (hw_vendor != NULL &&
	    (strcmp(hw_vendor, "Apple Inc.") == 0 ||
	    strcmp(hw_vendor, "Apple Computer, Inc.") == 0)) {
		if (strcmp(fa->v_string, "Darwin") == 0) {
			dnprintf(10,"osi: returning 1 for %s on %s hardware\n",
			    fa->v_string, hw_vendor);
			result = 1;
		} else
			dnprintf(10,"osi: on %s hardware, but ignoring %s\n",
			    hw_vendor, fa->v_string);

		return aml_allocvalue(AML_OBJTYPE_INTEGER, result, NULL);
	}

	for (idx=0; !result && aml_valid_osi[idx] != NULL; idx++) {
		dnprintf(10,"osi: %s,%s\n", fa->v_string, aml_valid_osi[idx]);
		result = !strcmp(fa->v_string, aml_valid_osi[idx]);
	}
	dnprintf(10,"@@@@ OSI found: %x\n", result);
	return aml_allocvalue(AML_OBJTYPE_INTEGER, result, NULL);
}

void
aml_create_defaultobjects(void)
{
	struct aml_value *tmp;
	struct aml_defval *def;

#ifdef ACPI_MEMDEBUG
	LIST_INIT(&acpi_memhead);
#endif

	osstring[1] = 'i';
	osstring[6] = 'o';
	osstring[15] = 'w';
	osstring[18] = 'N';

	SIMPLEQ_INIT(&aml_root.son);
	strlcpy(aml_root.name, "\\", sizeof(aml_root.name));
	aml_root.value = aml_allocvalue(0, 0, NULL);
	aml_root.value->node = &aml_root;

	for (def = aml_defobj; def->name; def++) {
		/* Allocate object value + add to namespace */
		aml_parsename(&aml_root, (uint8_t *)def->name, &tmp, 1);
		_aml_setvalue(tmp, def->type, def->ival, def->bval);
		if (def->gval) {
			/* Set root object pointer */
			*def->gval = tmp;
		}
		aml_delref(&tmp, 0);
	}
}

#ifdef ACPI_DEBUG
int
aml_print_resource(union acpi_resource *crs, void *arg)
{
	int typ = AML_CRSTYPE(crs);

	switch (typ) {
	case LR_EXTIRQ:
		printf("extirq\tflags:%.2x len:%.2x irq:%.4x\n",
		    crs->lr_extirq.flags, crs->lr_extirq.irq_count,
		    letoh32(crs->lr_extirq.irq[0]));
		break;
	case SR_IRQ:
		printf("irq\t%.4x %.2x\n", letoh16(crs->sr_irq.irq_mask),
		    crs->sr_irq.irq_flags);
		break;
	case SR_DMA:
		printf("dma\t%.2x %.2x\n", crs->sr_dma.channel,
		    crs->sr_dma.flags);
		break;
	case SR_IOPORT:
		printf("ioport\tflags:%.2x _min:%.4x _max:%.4x _aln:%.2x _len:%.2x\n",
		    crs->sr_ioport.flags, crs->sr_ioport._min,
		    crs->sr_ioport._max, crs->sr_ioport._aln,
		    crs->sr_ioport._len);
		break;
	case SR_STARTDEP:
		printf("startdep\n");
		break;
	case SR_ENDDEP:
		printf("enddep\n");
		break;
	case LR_WORD:
		printf("word\ttype:%.2x flags:%.2x tflag:%.2x gra:%.4x min:%.4x max:%.4x tra:%.4x len:%.4x\n",
			crs->lr_word.type, crs->lr_word.flags, crs->lr_word.tflags,
			crs->lr_word._gra, crs->lr_word._min, crs->lr_word._max,
			crs->lr_word._tra, crs->lr_word._len);
		break;
	case LR_DWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.8x min:%.8x max:%.8x tra:%.8x len:%.8x\n",
			crs->lr_dword.type, crs->lr_dword.flags, crs->lr_dword.tflags,
			crs->lr_dword._gra, crs->lr_dword._min, crs->lr_dword._max,
			crs->lr_dword._tra, crs->lr_dword._len);
		break;
	case LR_QWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.16llx min:%.16llx max:%.16llx tra:%.16llx len:%.16llx\n",
			crs->lr_qword.type, crs->lr_qword.flags, crs->lr_qword.tflags,
			crs->lr_qword._gra, crs->lr_qword._min, crs->lr_qword._max,
			crs->lr_qword._tra, crs->lr_qword._len);
		break;
	default:
		printf("unknown type: %x\n", typ);
		break;
	}
	return (0);
}
#endif /* ACPI_DEBUG */

union acpi_resource *aml_mapresource(union acpi_resource *);

union acpi_resource *
aml_mapresource(union acpi_resource *crs)
{
	static union acpi_resource map;
	int rlen;

	rlen = AML_CRSLEN(crs);
	if (rlen >= sizeof(map))
		return crs;

	memset(&map, 0, sizeof(map));
	memcpy(&map, crs, rlen);

	return &map;
}

int
aml_parse_resource(struct aml_value *res,
    int (*crs_enum)(int, union acpi_resource *, void *), void *arg)
{
	int off, rlen, crsidx;
	union acpi_resource *crs;

	if (res->type != AML_OBJTYPE_BUFFER || res->length < 5)
		return (-1);
	for (off = 0, crsidx = 0; off < res->length; off += rlen, crsidx++) {
		crs = (union acpi_resource *)(res->v_buffer+off);

		rlen = AML_CRSLEN(crs);
		if (crs->hdr.typecode == SRT_ENDTAG || !rlen)
			break;

		crs = aml_mapresource(crs);
#ifdef ACPI_DEBUG
		aml_print_resource(crs, NULL);
#endif
		crs_enum(crsidx, crs, arg);
	}

	return (0);
}

void
aml_foreachpkg(struct aml_value *pkg, int start,
    void (*fn)(struct aml_value *, void *), void *arg)
{
	int idx;

	if (pkg->type != AML_OBJTYPE_PACKAGE)
		return;
	for (idx=start; idx<pkg->length; idx++)
		fn(pkg->v_package[idx], arg);
}

/*
 * Walk nodes and perform fixups for nameref
 */
int aml_fixup_node(struct aml_node *, void *);

int aml_fixup_node(struct aml_node *node, void *arg)
{
	struct aml_value *val = arg;
	int i;

	if (node->value == NULL)
		return (0);
	if (arg == NULL)
		aml_fixup_node(node, node->value);
	else if (val->type == AML_OBJTYPE_NAMEREF) {
		node = aml_searchname(node, val->v_nameref);
		if (node && node->value) {
			_aml_setvalue(val, AML_OBJTYPE_OBJREF, AMLOP_NAMECHAR,
			    node->value);
		}
	} else if (val->type == AML_OBJTYPE_PACKAGE) {
		for (i = 0; i < val->length; i++)
			aml_fixup_node(node, val->v_package[i]);
	}
	return (0);
}

void
aml_postparse(void)
{
	aml_walknodes(&aml_root, AML_WALK_PRE, aml_fixup_node, NULL);
}

#ifndef SMALL_KERNEL
const char *
aml_val_to_string(const struct aml_value *val)
{
	static char buffer[256];

	int len;

	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		len = val->length;
		if (len >= sizeof(buffer))
			len = sizeof(buffer) - 1;
		memcpy(buffer, val->v_buffer, len);
		buffer[len] = 0;
		break;
	case AML_OBJTYPE_STRING:
		strlcpy(buffer, val->v_string, sizeof(buffer));
		break;
	case AML_OBJTYPE_INTEGER:
		snprintf(buffer, sizeof(buffer), "%llx", val->v_integer);
		break;
	default:
		snprintf(buffer, sizeof(buffer),
		    "Failed to convert type %d to string!", val->type);
	};

	return (buffer);
}
#endif /* SMALL_KERNEL */

int aml_error;

struct aml_value *aml_gettgt(struct aml_value *, int);
struct aml_value *aml_eval(struct aml_scope *, struct aml_value *, int, int,
    struct aml_value *);
struct aml_value *aml_parsesimple(struct aml_scope *, char,
    struct aml_value *);
struct aml_value *aml_parse(struct aml_scope *, int, const char *);
struct aml_value *aml_seterror(struct aml_scope *, const char *, ...);

struct aml_scope *aml_findscope(struct aml_scope *, int, int);
struct aml_scope *aml_pushscope(struct aml_scope *, struct aml_value *,
    struct aml_node *, int);
struct aml_scope *aml_popscope(struct aml_scope *);

void		aml_showstack(struct aml_scope *);
struct aml_value *aml_convert(struct aml_value *, int, int);

int		aml_matchtest(int64_t, int64_t, int);
int		aml_match(struct aml_value *, int, int, int, int, int);

int		aml_compare(struct aml_value *, struct aml_value *, int);
struct aml_value *aml_concat(struct aml_value *, struct aml_value *);
struct aml_value *aml_concatres(struct aml_value *, struct aml_value *);
struct aml_value *aml_mid(struct aml_value *, int, int);
int		aml_ccrlen(int, union acpi_resource *, void *);

void		aml_store(struct aml_scope *, struct aml_value *, int64_t,
    struct aml_value *);

/*
 * Reference Count functions
 */
void
aml_addref(struct aml_value *val, const char *lbl)
{
	if (val == NULL)
		return;
	dnprintf(50, "XAddRef: %p %s:[%s] %d\n",
	    val, lbl,
	    val->node ? aml_nodename(val->node) : "INTERNAL",
	    val->refcnt);
	val->refcnt++;
}

/* Decrease reference counter */
void
aml_delref(struct aml_value **pv, const char *lbl)
{
	struct aml_value *val;

	if (pv == NULL || *pv == NULL)
		return;
	val = *pv;
	val->refcnt--;
	if (val->refcnt == 0) {
		dnprintf(50, "XDelRef: %p %s %2d [%s] %s\n",
		    val, lbl,
		    val->refcnt,
		    val->node ? aml_nodename(val->node) : "INTERNAL",
		    val->refcnt ? "" : "---------------- FREEING");

		aml_freevalue(val);
		acpi_os_free(val);
		*pv = NULL;
	}
}

/* Walk list of parent scopes until we find one of 'type'
 * If endscope is set, mark all intermediate scopes as invalid (used for Method/While) */
struct aml_scope *
aml_findscope(struct aml_scope *scope, int type, int endscope)
{
	while (scope) {
		switch (endscope) {
		case AMLOP_RETURN:
			scope->pos = scope->end;
			if (scope->type == AMLOP_WHILE)
				scope->pos = NULL;
			break;
		case AMLOP_CONTINUE:
			scope->pos = scope->end;
			break;
		case AMLOP_BREAK:
			scope->pos = scope->end;
			if (scope->type == type)
				scope->parent->pos = scope->end;
			break;
		}
		if (scope->type == type)
			break;
		scope = scope->parent;
	}
	return scope;
}

struct aml_value *
aml_getstack(struct aml_scope *scope, int opcode)
{
	struct aml_value *sp;

	sp = NULL;
	scope = aml_findscope(scope, AMLOP_METHOD, 0);
	if (scope == NULL)
		return NULL;
	if (opcode >= AMLOP_LOCAL0 && opcode <= AMLOP_LOCAL7) {
		if (scope->locals == NULL)
			scope->locals = aml_allocvalue(AML_OBJTYPE_PACKAGE, 8, NULL);
		sp = scope->locals->v_package[opcode - AMLOP_LOCAL0];
		sp->stack = opcode;
	} else if (opcode >= AMLOP_ARG0 && opcode <= AMLOP_ARG6) {
		if (scope->args == NULL)
			scope->args = aml_allocvalue(AML_OBJTYPE_PACKAGE, 7, NULL);
		sp = scope->args->v_package[opcode - AMLOP_ARG0];
		if (sp->type == AML_OBJTYPE_OBJREF)
			sp = sp->v_objref.ref;
	}
	return sp;
}

#ifdef ACPI_DEBUG
/* Dump AML Stack */
void
aml_showstack(struct aml_scope *scope)
{
	struct aml_value *sp;
	int idx;

	dnprintf(10, "===== Stack %s:%s\n", aml_nodename(scope->node),
	    aml_mnem(scope->type, 0));
	for (idx=0; scope->args && idx<7; idx++) {
		sp = aml_getstack(scope, AMLOP_ARG0+idx);
		if (sp && sp->type) {
			dnprintf(10," Arg%d: ", idx);
			aml_showvalue(sp);
		}
	}
	for (idx=0; scope->locals && idx<8; idx++) {
		sp = aml_getstack(scope, AMLOP_LOCAL0+idx);
		if (sp && sp->type) {
			dnprintf(10," Local%d: ", idx);
			aml_showvalue(sp);
		}
	}
}
#endif

/* Create a new scope object */
struct aml_scope *
aml_pushscope(struct aml_scope *parent, struct aml_value *range,
    struct aml_node *node, int type)
{
	struct aml_scope *scope;
	uint8_t *start, *end;

	if (range->type == AML_OBJTYPE_METHOD) {
		start = range->v_method.start;
		end = range->v_method.end;
	} else {
		start = range->v_buffer;
		end = start + range->length;
		if (start == end)
			return NULL;
	}
	scope = acpi_os_malloc(sizeof(struct aml_scope));
	if (scope == NULL)
		return NULL;

	scope->node = node;
	scope->start = start;
	scope->end = end;
	scope->pos = scope->start;
	scope->parent = parent;
	scope->type = type;
	scope->sc = acpi_softc;

	if (parent)
		scope->depth = parent->depth+1;

	aml_lastscope = scope;

	return scope;
}

/* Free a scope object and any children */
struct aml_scope *
aml_popscope(struct aml_scope *scope)
{
	struct aml_scope *nscope;

	if (scope == NULL)
		return NULL;

	nscope = scope->parent;

	if (scope->type == AMLOP_METHOD)
		aml_delchildren(scope->node);
	if (scope->locals) {
		aml_freevalue(scope->locals);
		acpi_os_free(scope->locals);
		scope->locals = NULL;
	}
	if (scope->args) {
		aml_freevalue(scope->args);
		acpi_os_free(scope->args);
		scope->args = NULL;
	}
	acpi_os_free(scope);
	aml_lastscope = nscope;

	return nscope;
}

/* Test AMLOP_MATCH codes */
int
aml_matchtest(int64_t a, int64_t b, int op)
{
	switch (op) {
	case AML_MATCH_TR:
		return (1);
	case AML_MATCH_EQ:
		return (a == b);
	case AML_MATCH_LT:
		return (a < b);
	case AML_MATCH_LE:
		return (a <= b);
	case AML_MATCH_GE:
		return (a >= b);
	case AML_MATCH_GT:
		return (a > b);
	}
	return (0);
}

/* Search a package for a matching value */
int
aml_match(struct aml_value *pkg, int index,
	   int op1, int v1,
	   int op2, int v2)
{
	struct aml_value *tmp;
	int flag;

	while (index < pkg->length) {
		/* Convert package value to integer */
		tmp = aml_convert(pkg->v_package[index],
		    AML_OBJTYPE_INTEGER, -1);

		/* Perform test */
		flag = aml_matchtest(tmp->v_integer, v1, op1) &&
		    aml_matchtest(tmp->v_integer, v2, op2);
		aml_delref(&tmp, "xmatch");

		if (flag)
			return index;
		index++;
	}
	return -1;
}

/*
 * Conversion routines
 */
int64_t
aml_hextoint(const char *str)
{
	int64_t v = 0;
	char c;

	while (*str) {
		if (*str >= '0' && *str <= '9')
			c = *(str++) - '0';
		else if (*str >= 'a' && *str <= 'f')
			c = *(str++) - 'a' + 10;
		else if (*str >= 'A' && *str <= 'F')
			c = *(str++) - 'A' + 10;
		else
			break;
		v = (v << 4) + c;
	}
	return v;

}

struct aml_value *
aml_convert(struct aml_value *a, int ctype, int clen)
{
	struct aml_value *c = NULL;

	/* Object is already this type */
	if (clen == -1)
		clen = a->length;
	if (a->type == ctype) {
		aml_addref(a, "XConvert");
		return a;
	}
	switch (ctype) {
	case AML_OBJTYPE_BUFFER:
		dnprintf(10,"convert to buffer\n");
		switch (a->type) {
		case AML_OBJTYPE_INTEGER:
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length,
			    &a->v_integer);
			break;
		case AML_OBJTYPE_STRING:
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length,
			    a->v_string);
			break;
		}
		break;
	case AML_OBJTYPE_INTEGER:
		dnprintf(10,"convert to integer : %x\n", a->type);
		switch (a->type) {
		case AML_OBJTYPE_BUFFER:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			memcpy(&c->v_integer, a->v_buffer,
			    min(a->length, c->length));
			break;
		case AML_OBJTYPE_STRING:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			c->v_integer = aml_hextoint(a->v_string);
			break;
		case AML_OBJTYPE_UNINITIALIZED:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			break;
		}
		break;
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_HEXSTRING:
	case AML_OBJTYPE_DECSTRING:
		dnprintf(10,"convert to string\n");
		switch (a->type) {
		case AML_OBJTYPE_INTEGER:
			c = aml_allocvalue(AML_OBJTYPE_STRING, 20, NULL);
			snprintf(c->v_string, c->length, (ctype == AML_OBJTYPE_HEXSTRING) ?
			    "0x%llx" : "%lld", a->v_integer);
			break;
		case AML_OBJTYPE_BUFFER:
			c = aml_allocvalue(AML_OBJTYPE_STRING, a->length,
			    a->v_buffer);
			break;
		case AML_OBJTYPE_STRING:
			aml_addref(a, "XConvert");
			return a;
		}
		break;
	}
	if (c == NULL) {
#ifndef SMALL_KERNEL
		aml_showvalue(a);
#endif
		aml_die("Could not convert %x to %x\n", a->type, ctype);
	}
	return c;
}

int
aml_compare(struct aml_value *a1, struct aml_value *a2, int opcode)
{
	int rc = 0;

	/* Convert A2 to type of A1 */
	a2 = aml_convert(a2, a1->type, -1);
	if (a1->type == AML_OBJTYPE_INTEGER)
		rc = aml_evalexpr(a1->v_integer, a2->v_integer, opcode);
	else {
		/* Perform String/Buffer comparison */
		rc = memcmp(a1->v_buffer, a2->v_buffer,
		    min(a1->length, a2->length));
		if (rc == 0) {
			/* If buffers match, which one is longer */
			rc = a1->length - a2->length;
		}
		/* Perform comparison against zero */
		rc = aml_evalexpr(rc, 0, opcode);
	}
	/* Either deletes temp buffer, or decrease refcnt on original A2 */
	aml_delref(&a2, "xcompare");
	return rc;
}

/* Concatenate two objects, returning pointer to new object */
struct aml_value *
aml_concat(struct aml_value *a1, struct aml_value *a2)
{
	struct aml_value *c = NULL;

	/* Convert arg2 to type of arg1 */
	a2 = aml_convert(a2, a1->type, -1);
	switch (a1->type) {
	case AML_OBJTYPE_INTEGER:
		c = aml_allocvalue(AML_OBJTYPE_BUFFER,
		    a1->length + a2->length, NULL);
		memcpy(c->v_buffer, &a1->v_integer, a1->length);
		memcpy(c->v_buffer+a1->length, &a2->v_integer, a2->length);
		break;
	case AML_OBJTYPE_BUFFER:
		c = aml_allocvalue(AML_OBJTYPE_BUFFER,
		    a1->length + a2->length, NULL);
		memcpy(c->v_buffer, a1->v_buffer, a1->length);
		memcpy(c->v_buffer+a1->length, a2->v_buffer, a2->length);
		break;
	case AML_OBJTYPE_STRING:
		c = aml_allocvalue(AML_OBJTYPE_STRING,
		    a1->length + a2->length, NULL);
		memcpy(c->v_string, a1->v_string, a1->length);
		memcpy(c->v_string+a1->length, a2->v_string, a2->length);
		break;
	default:
		aml_die("concat type mismatch %d != %d\n", a1->type, a2->type);
		break;
	}
	/* Either deletes temp buffer, or decrease refcnt on original A2 */
	aml_delref(&a2, "xconcat");
	return c;
}

/* Calculate length of Resource Template */
int
aml_ccrlen(int crsidx, union acpi_resource *rs, void *arg)
{
	int *plen = arg;

	*plen += AML_CRSLEN(rs);
	return (0);
}

/* Concatenate resource templates, returning pointer to new object */
struct aml_value *
aml_concatres(struct aml_value *a1, struct aml_value *a2)
{
	struct aml_value *c;
	int l1 = 0, l2 = 0, l3 = 2;
	uint8_t a3[] = { SRT_ENDTAG, 0x00 };

	if (a1->type != AML_OBJTYPE_BUFFER || a2->type != AML_OBJTYPE_BUFFER)
		aml_die("concatres: not buffers\n");

	/* Walk a1, a2, get length minus end tags, concatenate buffers, add end tag */
	aml_parse_resource(a1, aml_ccrlen, &l1);
	aml_parse_resource(a2, aml_ccrlen, &l2);

	/* Concatenate buffers, add end tag */
	c = aml_allocvalue(AML_OBJTYPE_BUFFER, l1+l2+l3, NULL);
	memcpy(c->v_buffer,    a1->v_buffer, l1);
	memcpy(c->v_buffer+l1, a2->v_buffer, l2);
	memcpy(c->v_buffer+l1+l2, a3,        l3);

	return c;
}

/* Extract substring from string or buffer */
struct aml_value *
aml_mid(struct aml_value *src, int index, int length)
{
	if (index > src->length)
		index = src->length;
	if ((index + length) > src->length)
		length = src->length - index;
	return aml_allocvalue(src->type, length, src->v_buffer + index);
}

/*
 * Field I/O utility functions
 */
void aml_createfield(struct aml_value *, int, struct aml_value *, int, int,
    struct aml_value *, int, int);
void aml_parsefieldlist(struct aml_scope *, int, int,
    struct aml_value *, struct aml_value *, int);

#define GAS_PCI_CFG_SPACE_UNEVAL  0xCC

int
aml_evalhid(struct aml_node *node, struct aml_value *val)
{
	if (aml_evalname(acpi_softc, node, "_HID", 0, NULL, val))
		return (-1);

	/* Integer _HID: convert to EISA ID */
	if (val->type == AML_OBJTYPE_INTEGER)
		_aml_setvalue(val, AML_OBJTYPE_STRING, -1, aml_eisaid(val->v_integer));
	return (0);
}

void aml_rwgas(struct aml_value *, int, int, struct aml_value *, int, int);
void aml_rwgpio(struct aml_value *, int, int, struct aml_value *, int, int);
void aml_rwindexfield(struct aml_value *, struct aml_value *val, int);
void aml_rwfield(struct aml_value *, int, int, struct aml_value *, int);

/* Get PCI address for opregion objects */
int
aml_rdpciaddr(struct aml_node *pcidev, union amlpci_t *addr)
{
	int64_t res;

	if (aml_evalinteger(acpi_softc, pcidev, "_ADR", 0, NULL, &res) == 0) {
		addr->fun = res & 0xFFFF;
		addr->dev = res >> 16;
	}
	while (pcidev != NULL) {
		/* HID device (PCI or PCIE root): eval _BBN */
		if (__aml_search(pcidev, "_HID", 0)) {
			if (aml_evalinteger(acpi_softc, pcidev, "_BBN", 0, NULL, &res) == 0) {
				addr->bus = res;
				break;
			}
		}
		pcidev = pcidev->parent;
	}
	return (0);
}

/* Read/Write from opregion object */
void
aml_rwgas(struct aml_value *rgn, int bpos, int blen, struct aml_value *val,
    int mode, int flag)
{
	struct aml_value tmp;
	union amlpci_t pi;
	void *tbit, *vbit;
	int tlen, type, sz;

	dnprintf(10," %5s %.2x %.8llx %.4x [%s]\n",
		mode == ACPI_IOREAD ? "read" : "write",
		rgn->v_opregion.iospace,
		rgn->v_opregion.iobase + (bpos >> 3),
		blen, aml_nodename(rgn->node));
	memset(&tmp, 0, sizeof(tmp));

	/* Get field access size */
	switch (AML_FIELD_ACCESS(flag)) {
	case AML_FIELD_WORDACC:
		sz = 2;
		break;
	case AML_FIELD_DWORDACC:
		sz = 4;
		break;
	case AML_FIELD_QWORDACC:
		sz = 8;
		break;
	default:
		sz = 1;
		break;
	}

	pi.addr = (rgn->v_opregion.iobase + (bpos >> 3)) & ~(sz - 1);
	bpos += ((rgn->v_opregion.iobase & (sz - 1)) << 3);
	bpos &= ((sz << 3) - 1);

	if (rgn->v_opregion.iospace == GAS_PCI_CFG_SPACE) {
		/* Get PCI Root Address for this opregion */
		aml_rdpciaddr(rgn->node->parent, &pi);
	}

	tbit = &tmp.v_integer;
	vbit = &val->v_integer;
	tlen = roundup(bpos + blen, sz << 3);
	type = rgn->v_opregion.iospace;

	/* Allocate temporary storage */
	if (tlen > aml_intlen) {
		_aml_setvalue(&tmp, AML_OBJTYPE_BUFFER, tlen >> 3, 0);
		tbit = tmp.v_buffer;
	}

	if (blen > aml_intlen) {
		if (mode == ACPI_IOREAD) {
			/* Read from a large field:  create buffer */
			_aml_setvalue(val, AML_OBJTYPE_BUFFER, (blen + 7) >> 3, 0);
		} else {
			/* Write to a large field.. create or convert buffer */
			val = aml_convert(val, AML_OBJTYPE_BUFFER, -1);

			if (blen > (val->length << 3))
				blen = val->length << 3;
		}
		vbit = val->v_buffer;
	} else {
		if (mode == ACPI_IOREAD) {
			/* Read from a short field.. initialize integer */
			_aml_setvalue(val, AML_OBJTYPE_INTEGER, 0, 0);
		} else {
			/* Write to a short field.. convert to integer */
			val = aml_convert(val, AML_OBJTYPE_INTEGER, -1);
		}
	}

	if (mode == ACPI_IOREAD) {
		/* Read bits from opregion */
		acpi_gasio(acpi_softc, ACPI_IOREAD, type, pi.addr,
		    sz, tlen >> 3, tbit);
		aml_bufcpy(vbit, 0, tbit, bpos, blen);
	} else {
		/* Write bits to opregion */
		if (AML_FIELD_UPDATE(flag) == AML_FIELD_PRESERVE &&
		    (bpos != 0 || blen != tlen)) {
			acpi_gasio(acpi_softc, ACPI_IOREAD, type, pi.addr,
			    sz, tlen >> 3, tbit);
		} else if (AML_FIELD_UPDATE(flag) == AML_FIELD_WRITEASONES) {
			memset(tbit, 0xff, tmp.length);
		}
		/* Copy target bits, then write to region */
		aml_bufcpy(tbit, bpos, vbit, 0, blen);
		acpi_gasio(acpi_softc, ACPI_IOWRITE, type, pi.addr,
		    sz, tlen >> 3, tbit);

		aml_delref(&val, "fld.write");
	}
	aml_freevalue(&tmp);
}

void
aml_rwgpio(struct aml_value *conn, int bpos, int blen, struct aml_value *val,
    int mode, int flag)
{
	union acpi_resource *crs = (union acpi_resource *)conn->v_buffer;
	struct aml_node *node;
	uint16_t pin;
	int v = 0;

	if (conn->type != AML_OBJTYPE_BUFFER || conn->length < 5 ||
	    AML_CRSTYPE(crs) != LR_GPIO || AML_CRSLEN(crs) > conn->length)
		aml_die("Invalid GpioIo");
	if (bpos != 0 || blen != 1)
		aml_die("Invalid GpioIo access");

	node = aml_searchname(conn->node,
	    (char *)&crs->pad[crs->lr_gpio.res_off]);
	pin = *(uint16_t *)&crs->pad[crs->lr_gpio.pin_off];

	if (node == NULL || node->gpio == NULL)
		aml_die("Could not find GpioIo pin");

	if (mode == ACPI_IOWRITE) {
		v = aml_val2int(val);
		node->gpio->write_pin(node->gpio->cookie, pin, v);
	} else {
		v = node->gpio->read_pin(node->gpio->cookie, pin);
		_aml_setvalue(val, AML_OBJTYPE_INTEGER, v, NULL);
	}
}

void
aml_rwindexfield(struct aml_value *fld, struct aml_value *val, int mode)
{
	struct aml_value tmp, *ref1, *ref2;
	void *tbit, *vbit;
	int vpos, bpos, blen;
	int indexval;
	int sz, len;

	ref2 = fld->v_field.ref2;
	ref1 = fld->v_field.ref1;
	bpos = fld->v_field.bitpos;
	blen = fld->v_field.bitlen;

	memset(&tmp, 0, sizeof(tmp));
	tmp.refcnt = 99;

	/* Get field access size */
	switch (AML_FIELD_ACCESS(fld->v_field.flags)) {
	case AML_FIELD_WORDACC:
		sz = 2;
		break;
	case AML_FIELD_DWORDACC:
		sz = 4;
		break;
	case AML_FIELD_QWORDACC:
		sz = 8;
		break;
	default:
		sz = 1;
		break;
	}

	if (blen > aml_intlen) {
		if (mode == ACPI_IOREAD) {
			/* Read from a large field: create buffer */
			_aml_setvalue(val, AML_OBJTYPE_BUFFER,
			    (blen + 7) >> 3, 0);
		}
		vbit = val->v_buffer;
	} else {
		if (mode == ACPI_IOREAD) {
			/* Read from a short field: initialize integer */
			_aml_setvalue(val, AML_OBJTYPE_INTEGER, 0, 0);
		}
		vbit = &val->v_integer;
	}
	tbit = &tmp.v_integer;
	vpos = 0;

	indexval = (bpos >> 3) & ~(sz - 1);
	bpos = bpos - (indexval << 3);

	while (blen > 0) {
		len = min(blen, (sz << 3) - bpos);

		/* Write index register */
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, indexval, 0);
		aml_rwfield(ref2, 0, aml_intlen, &tmp, ACPI_IOWRITE);
		indexval += sz;

		/* Read/write data register */
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, 0, 0);
		if (mode == ACPI_IOWRITE)
			aml_bufcpy(tbit, 0, vbit, vpos, len);
		aml_rwfield(ref1, bpos, len, &tmp, mode);
		if (mode == ACPI_IOREAD)
			aml_bufcpy(vbit, vpos, tbit, 0, len);
		vpos += len;
		blen -= len;
		bpos = 0;
	}
}

void
aml_rwfield(struct aml_value *fld, int bpos, int blen, struct aml_value *val,
    int mode)
{
	struct aml_value tmp, *ref1, *ref2;

	ref2 = fld->v_field.ref2;
	ref1 = fld->v_field.ref1;
	if (blen > fld->v_field.bitlen)
		blen = fld->v_field.bitlen;

	aml_lockfield(NULL, fld);
	memset(&tmp, 0, sizeof(tmp));
	aml_addref(&tmp, "fld.write");
	if (fld->v_field.type == AMLOP_INDEXFIELD) {
		aml_rwindexfield(fld, val, mode);
	} else if (fld->v_field.type == AMLOP_BANKFIELD) {
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, fld->v_field.ref3, 0);
		aml_rwfield(ref2, 0, aml_intlen, &tmp, ACPI_IOWRITE);
		aml_rwgas(ref1, fld->v_field.bitpos, fld->v_field.bitlen,
		    val, mode, fld->v_field.flags);
	} else if (fld->v_field.type == AMLOP_FIELD) {
		switch (ref1->v_opregion.iospace) {
		case ACPI_OPREG_GPIO:
			aml_rwgpio(ref2, bpos, blen, val, mode,
			    fld->v_field.flags);
			break;
		case ACPI_OPREG_SYSMEM:
		case ACPI_OPREG_SYSIO:
		case ACPI_OPREG_PCICFG:
		case ACPI_OPREG_EC:
			aml_rwgas(ref1, fld->v_field.bitpos + bpos, blen,
			    val, mode, fld->v_field.flags);
			break;
		default:
			aml_die("Unsupported RegionSpace 0x%x",
			    ref1->v_opregion.iospace);
			break;
		}
	} else if (mode == ACPI_IOREAD) {
		/* bufferfield:read */
		_aml_setvalue(val, AML_OBJTYPE_INTEGER, 0, 0);
		aml_bufcpy(&val->v_integer, 0, ref1->v_buffer,
		    fld->v_field.bitpos, fld->v_field.bitlen);
	} else {
		/* bufferfield:write */
		val = aml_convert(val, AML_OBJTYPE_INTEGER, -1);
		aml_bufcpy(ref1->v_buffer, fld->v_field.bitpos, &val->v_integer,
		    0, fld->v_field.bitlen);
		aml_delref(&val, "wrbuffld");
	}
	aml_unlockfield(NULL, fld);
}

/* Create Field Object          data		index
 *   AMLOP_FIELD		n:OpRegion	NULL
 *   AMLOP_INDEXFIELD		n:Field		n:Field
 *   AMLOP_BANKFIELD		n:OpRegion	n:Field
 *   AMLOP_CREATEFIELD		t:Buffer	NULL
 *   AMLOP_CREATEBITFIELD	t:Buffer	NULL
 *   AMLOP_CREATEBYTEFIELD	t:Buffer	NULL
 *   AMLOP_CREATEWORDFIELD	t:Buffer	NULL
 *   AMLOP_CREATEDWORDFIELD	t:Buffer	NULL
 *   AMLOP_CREATEQWORDFIELD	t:Buffer	NULL
 *   AMLOP_INDEX		t:Buffer	NULL
 */
void
aml_createfield(struct aml_value *field, int opcode,
		struct aml_value *data, int bpos, int blen,
		struct aml_value *index, int indexval, int flags)
{
	dnprintf(10, "## %s(%s): %s %.4x-%.4x\n",
	    aml_mnem(opcode, 0),
	    blen > aml_intlen ? "BUF" : "INT",
	    aml_nodename(field->node), bpos, blen);
	if (index) {
		dnprintf(10, "  index:%s:%.2x\n", aml_nodename(index->node),
		    indexval);
	}
	dnprintf(10, "  data:%s\n", aml_nodename(data->node));
	field->type = (opcode == AMLOP_FIELD ||
	    opcode == AMLOP_INDEXFIELD ||
	    opcode == AMLOP_BANKFIELD) ?
	    AML_OBJTYPE_FIELDUNIT :
	    AML_OBJTYPE_BUFFERFIELD;

	if (field->type == AML_OBJTYPE_BUFFERFIELD &&
	    data->type != AML_OBJTYPE_BUFFER)
		data = aml_convert(data, AML_OBJTYPE_BUFFER, -1);

	field->v_field.type = opcode;
	field->v_field.bitpos = bpos;
	field->v_field.bitlen = blen;
	field->v_field.ref3 = indexval;
	field->v_field.ref2 = index;
	field->v_field.ref1 = data;
	field->v_field.flags = flags;

	/* Increase reference count */
	aml_addref(data, "Field.Data");
	aml_addref(index, "Field.Index");
}

/* Parse Field/IndexField/BankField scope */
void
aml_parsefieldlist(struct aml_scope *mscope, int opcode, int flags,
    struct aml_value *data, struct aml_value *index, int indexval)
{
	struct aml_value *conn = NULL;
	struct aml_value *rv;
	int bpos, blen;

	if (mscope == NULL)
		return;
	bpos = 0;
	while (mscope->pos < mscope->end) {
		switch (*mscope->pos) {
		case 0x00: /* reserved, length */
			mscope->pos++;
			blen = aml_parselength(mscope);
			break;
		case 0x01: /* flags */
			mscope->pos += 3;
			blen = 0;
			break;
		case 0x02: /* connection */
			mscope->pos++;
			blen = 0;
			conn = aml_parse(mscope, 'o', "Connection");
			if (conn == NULL)
				aml_die("Could not parse connection");
			conn->node = mscope->node;
			break;
		default: /* 4-byte name, length */
			mscope->pos = aml_parsename(mscope->node, mscope->pos,
			    &rv, 1);
			blen = aml_parselength(mscope);
			aml_createfield(rv, opcode, data, bpos, blen,
			    conn ? conn : index, indexval, flags);
			aml_delref(&rv, 0);
			break;
		}
		bpos += blen;
	}
	aml_popscope(mscope);
}

/*
 * Mutex/Event utility functions
 */
int	acpi_mutex_acquire(struct aml_scope *, struct aml_value *, int);
void	acpi_mutex_release(struct aml_scope *, struct aml_value *);
int	acpi_event_wait(struct aml_scope *, struct aml_value *, int);
void	acpi_event_signal(struct aml_scope *, struct aml_value *);
void	acpi_event_reset(struct aml_scope *, struct aml_value *);

int
acpi_mutex_acquire(struct aml_scope *scope, struct aml_value *mtx,
    int timeout)
{
	if (mtx->v_mtx.owner == NULL || scope == mtx->v_mtx.owner) {
		/* We are now the owner */
		mtx->v_mtx.owner = scope;
		if (mtx == aml_global_lock) {
			dnprintf(10,"LOCKING GLOBAL\n");
			acpi_glk_enter();
		}
		dnprintf(5,"%s acquires mutex %s\n", scope->node->name,
		    mtx->node->name);
		return (0);
	} else if (timeout == 0) {
		return (-1);
	}
	/* Wait for mutex */
	return (0);
}

void
acpi_mutex_release(struct aml_scope *scope, struct aml_value *mtx)
{
	if (mtx == aml_global_lock) {
		dnprintf(10,"UNLOCKING GLOBAL\n");
		acpi_glk_leave();
	}
	dnprintf(5, "%s releases mutex %s\n", scope->node->name,
	    mtx->node->name);
	mtx->v_mtx.owner = NULL;
	/* Wakeup waiters */
}

int
acpi_event_wait(struct aml_scope *scope, struct aml_value *evt, int timeout)
{
	/* Wait for event to occur; do work in meantime */
	evt->v_evt.state = 0;
	while (!evt->v_evt.state) {
		if (!acpi_dotask(acpi_softc) && !cold)
			tsleep(evt, PWAIT, "acpievt", 1);
		else
			delay(100);
	}
	if (evt->v_evt.state == 1) {
		/* Object is signaled */
		return (0);
	} else if (timeout == 0) {
		/* Zero timeout */
		return (-1);
	}
	/* Wait for timeout or signal */
	return (0);
}

void
acpi_event_signal(struct aml_scope *scope, struct aml_value *evt)
{
	evt->v_evt.state = 1;
	/* Wakeup waiters */
}

void
acpi_event_reset(struct aml_scope *scope, struct aml_value *evt)
{
	evt->v_evt.state = 0;
}

/* Store result value into an object */
void
aml_store(struct aml_scope *scope, struct aml_value *lhs , int64_t ival,
    struct aml_value *rhs)
{
	struct aml_value tmp;
	struct aml_node *node;
	int mlen;

	/* Already set */
	if (lhs == rhs || lhs == NULL || lhs->type == AML_OBJTYPE_NOTARGET) {
		return;
	}
	memset(&tmp, 0, sizeof(tmp));
	tmp.refcnt=99;
	if (rhs == NULL) {
		rhs = _aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, ival, NULL);
	}
	if (rhs->type == AML_OBJTYPE_BUFFERFIELD ||
	    rhs->type == AML_OBJTYPE_FIELDUNIT) {
		aml_rwfield(rhs, 0, rhs->v_field.bitlen, &tmp, ACPI_IOREAD);
		rhs = &tmp;
	}
	/* Store to LocalX: free value */
	if (lhs->stack >= AMLOP_LOCAL0 && lhs->stack <= AMLOP_LOCAL7)
		aml_freevalue(lhs);

	lhs = aml_gettgt(lhs, AMLOP_STORE);
	switch (lhs->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		aml_copyvalue(lhs, rhs);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_rwfield(lhs, 0, lhs->v_field.bitlen, rhs, ACPI_IOWRITE);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		break;
	case AML_OBJTYPE_INTEGER:
		rhs = aml_convert(rhs, lhs->type, -1);
		lhs->v_integer = rhs->v_integer;
		aml_delref(&rhs, "store.int");
		break;
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_STRING:
		rhs = aml_convert(rhs, lhs->type, -1);
		if (lhs->length < rhs->length) {
			dnprintf(10, "Overrun! %d,%d\n",
			    lhs->length, rhs->length);
			aml_freevalue(lhs);
			_aml_setvalue(lhs, rhs->type, rhs->length, NULL);
		}
		mlen = min(lhs->length, rhs->length);
		memset(lhs->v_buffer, 0x00, lhs->length);
		memcpy(lhs->v_buffer, rhs->v_buffer, mlen);
		aml_delref(&rhs, "store.bufstr");
		break;
	case AML_OBJTYPE_PACKAGE:
		/* Convert to LHS type, copy into LHS */
		if (rhs->type != AML_OBJTYPE_PACKAGE) {
			aml_die("Copy non-package into package?");
		}
		aml_freevalue(lhs);
		aml_copyvalue(lhs, rhs);
		break;
	case AML_OBJTYPE_NAMEREF:
		node = __aml_searchname(scope->node, lhs->v_nameref, 1);
		if (node == NULL) {
			aml_die("Could not create node %s", lhs->v_nameref);
		}
		aml_copyvalue(node->value, rhs);
		break;
	case AML_OBJTYPE_METHOD:
		/* Method override */
		if (rhs->type != AML_OBJTYPE_INTEGER) {
			aml_die("Overriding a method with a non-int?");
		}
		aml_freevalue(lhs);
		aml_copyvalue(lhs, rhs);
		break;
	default:
		aml_die("Store to default type!	 %x\n", lhs->type);
		break;
	}
	aml_freevalue(&tmp);
}

#ifdef DDB
/* Disassembler routines */
void aml_disprintf(void *arg, const char *fmt, ...);

void
aml_disprintf(void *arg, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
}

void
aml_disasm(struct aml_scope *scope, int lvl,
    void (*dbprintf)(void *, const char *, ...)
	    __attribute__((__format__(__kprintf__,2,3))),
    void *arg)
{
	int pc, opcode;
	struct aml_opcode *htab;
	uint64_t ival;
	struct aml_value *rv, tmp;
	uint8_t *end = NULL;
	struct aml_scope ms;
	char *ch;
	char  mch[64];

	if (dbprintf == NULL)
		dbprintf = aml_disprintf;

	pc = aml_pc(scope->pos);
	opcode = aml_parseopcode(scope);
	htab = aml_findopcode(opcode);

	/* Display address + indent */
	if (lvl <= 0x7FFF) {
		dbprintf(arg, "%.4x ", pc);
		for (pc=0; pc<lvl; pc++) {
			dbprintf(arg, "	 ");
		}
	}
	ch = NULL;
	switch (opcode) {
	case AMLOP_NAMECHAR:
		scope->pos = aml_parsename(scope->node, scope->pos, &rv, 0);
		if (rv->type == AML_OBJTYPE_NAMEREF) {
			ch = "@@@@@@";
			aml_delref(&rv, "disasm");
			break;
		}
		/* if this is a method, get arguments */
		strlcpy(mch, aml_nodename(rv->node), sizeof(mch));
		if (rv->type == AML_OBJTYPE_METHOD) {
			strlcat(mch, "(", sizeof(mch));
			for (ival=0; 
			    ival < AML_METHOD_ARGCOUNT(rv->v_method.flags);
			    ival++) {
				strlcat(mch, ival ? ", %z" : "%z",
				    sizeof(mch));
			}
			strlcat(mch, ")", sizeof(mch));
		}
		aml_delref(&rv, "");
		ch = mch;
		break;

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
	case AMLOP_NOP:
	case AMLOP_REVISION:
	case AMLOP_DEBUG:
	case AMLOP_CONTINUE:
	case AMLOP_BREAKPOINT:
	case AMLOP_BREAK:
		ch="%m";
		break;
	case AMLOP_BYTEPREFIX:
		ch="%b";
		break;
	case AMLOP_WORDPREFIX:
		ch="%w";
		break;
	case AMLOP_DWORDPREFIX:
		ch="%d";
		break;
	case AMLOP_QWORDPREFIX:
		ch="%q";
		break;
	case AMLOP_STRINGPREFIX:
		ch="%a";
		break;

	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
	case AMLOP_LNOT:
	case AMLOP_SIZEOF:
	case AMLOP_DEREFOF:
	case AMLOP_REFOF:
	case AMLOP_OBJECTTYPE:
	case AMLOP_UNLOAD:
	case AMLOP_RELEASE:
	case AMLOP_SIGNAL:
	case AMLOP_RESET:
	case AMLOP_STALL:
	case AMLOP_SLEEP:
	case AMLOP_RETURN:
		ch="%m(%n)";
		break;
	case AMLOP_OR:
	case AMLOP_ADD:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_XOR:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_NOR:
	case AMLOP_MOD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_INDEX:
	case AMLOP_CONCAT:
	case AMLOP_CONCATRES:
	case AMLOP_TOSTRING:
		ch="%m(%n, %n, %n)";
		break;
	case AMLOP_CREATEBYTEFIELD:
	case AMLOP_CREATEWORDFIELD:
	case AMLOP_CREATEDWORDFIELD:
	case AMLOP_CREATEQWORDFIELD:
	case AMLOP_CREATEBITFIELD:
		ch="%m(%n, %n, %N)";
		break;
	case AMLOP_CREATEFIELD:
		ch="%m(%n, %n, %n, %N)";
		break;
	case AMLOP_DIVIDE:
	case AMLOP_MID:
		ch="%m(%n, %n, %n, %n)";
		break;
	case AMLOP_LAND:
	case AMLOP_LOR:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LLESS:
	case AMLOP_LEQUAL:
	case AMLOP_LGREATEREQUAL:
	case AMLOP_LGREATER:
	case AMLOP_NOT:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
	case AMLOP_TOINTEGER:
	case AMLOP_TOBUFFER:
	case AMLOP_TOHEXSTRING:
	case AMLOP_TODECSTRING:
	case AMLOP_FROMBCD:
	case AMLOP_TOBCD:
	case AMLOP_WAIT:
	case AMLOP_LOAD:
	case AMLOP_STORE:
	case AMLOP_NOTIFY:
	case AMLOP_COPYOBJECT:
		ch="%m(%n, %n)";
		break;
	case AMLOP_ACQUIRE:
		ch = "%m(%n, %w)";
		break;
	case AMLOP_CONDREFOF:
		ch="%m(%R, %n)";
		break;
	case AMLOP_ALIAS:
		ch="%m(%n, %N)";
		break;
	case AMLOP_NAME:
		ch="%m(%N, %n)";
		break;
	case AMLOP_EVENT:
		ch="%m(%N)";
		break;
	case AMLOP_MUTEX:
		ch = "%m(%N, %b)";
		break;
	case AMLOP_OPREGION:
		ch = "%m(%N, %b, %n, %n)";
		break;
	case AMLOP_DATAREGION:
		ch="%m(%N, %n, %n, %n)";
		break;
	case AMLOP_FATAL:
		ch = "%m(%b, %d, %n)";
		break;
	case AMLOP_IF:
	case AMLOP_WHILE:
	case AMLOP_SCOPE:
	case AMLOP_THERMALZONE:
	case AMLOP_VARPACKAGE:
		end = aml_parseend(scope);
		ch = "%m(%n) {\n%T}";
		break;
	case AMLOP_DEVICE:
		end = aml_parseend(scope);
		ch = "%m(%N) {\n%T}";
		break;
	case AMLOP_POWERRSRC:
		end = aml_parseend(scope);
		ch = "%m(%N, %b, %w) {\n%T}";
		break;
	case AMLOP_PROCESSOR:
		end = aml_parseend(scope);
		ch = "%m(%N, %b, %d, %b) {\n%T}";
		break;
	case AMLOP_METHOD:
		end = aml_parseend(scope);
		ch = "%m(%N, %b) {\n%T}";
		break;
	case AMLOP_PACKAGE:
		end = aml_parseend(scope);
		ch = "%m(%b) {\n%T}";
		break;
	case AMLOP_ELSE:
		end = aml_parseend(scope);
		ch = "%m {\n%T}";
		break;
	case AMLOP_BUFFER:
		end = aml_parseend(scope);
		ch = "%m(%n) { %B }";
		break;
	case AMLOP_INDEXFIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %n, %b) {\n%F}";
		break;
	case AMLOP_BANKFIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %n, %n, %b) {\n%F}";
		break;
	case AMLOP_FIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %b) {\n%F}";
		break;
	case AMLOP_MATCH:
		ch = "%m(%n, %b, %n, %b, %n, %n)";
		break;
	case AMLOP_LOADTABLE:
		ch = "%m(%n, %n, %n, %n, %n, %n)";
		break;
	default:
		aml_die("opcode = %x\n", opcode);
		break;
	}

	/* Parse printable buffer args */
	while (ch && *ch) {
		char c;

		if (*ch != '%') {
			dbprintf(arg,"%c", *(ch++));
			continue;
		}
		c = *(++ch);
		switch (c) {
		case 'b':
		case 'w':
		case 'd':
		case 'q':
			/* Parse simple object: don't allocate */
			aml_parsesimple(scope, c, &tmp);
			dbprintf(arg,"0x%llx", tmp.v_integer);
			break;
		case 'a':
			dbprintf(arg, "\'%s\'", scope->pos);
			scope->pos += strlen(scope->pos)+1;
			break;
		case 'N':
			/* Create Name */
			rv = aml_parsesimple(scope, c, NULL);
			dbprintf(arg, "%s", aml_nodename(rv->node));
			break;
		case 'm':
			/* display mnemonic */
			dbprintf(arg, "%s", htab->mnem);
			break;
		case 'R':
			/* Search name */
			printf("%s", aml_getname(scope->pos));
			scope->pos = aml_parsename(scope->node, scope->pos,
			    &rv, 0);
			aml_delref(&rv, 0);
			break;
		case 'z':
		case 'n':
			/* generic arg: recurse */
			aml_disasm(scope, lvl | 0x8000, dbprintf, arg);
			break;
		case 'B':
			/* Buffer */
			scope->pos = end;
			break;
		case 'F':
			/* Scope: Field List */
			memset(&ms, 0, sizeof(ms));
			ms.node = scope->node;
			ms.start = scope->pos;
			ms.end = end;
			ms.pos = ms.start;
			ms.type = AMLOP_FIELD;

			while (ms.pos < ms.end) {
				if (*ms.pos == 0x00) {
					ms.pos++;
					aml_parselength(&ms);
				} else if (*ms.pos == 0x01) {
					ms.pos+=3;
				} else {
					ms.pos = aml_parsename(ms.node,
					     ms.pos, &rv, 1);
					aml_parselength(&ms);
					dbprintf(arg,"	%s\n",
					    aml_nodename(rv->node));
					aml_delref(&rv, 0);
				}
			}

			/* Display address and closing bracket */
			dbprintf(arg,"%.4x ", aml_pc(scope->pos));
			for (pc=0; pc<(lvl & 0x7FFF); pc++) {
				dbprintf(arg,"  ");
			}
			scope->pos = end;
			break;
		case 'T':
			/* Scope: Termlist */
			memset(&ms, 0, sizeof(ms));
			ms.node = scope->node;
			ms.start = scope->pos;
			ms.end = end;
			ms.pos = ms.start;
			ms.type = AMLOP_SCOPE;

			while (ms.pos < ms.end) {
				aml_disasm(&ms, (lvl + 1) & 0x7FFF,
				    dbprintf, arg);
			}

			/* Display address and closing bracket */
			dbprintf(arg,"%.4x ", aml_pc(scope->pos));
			for (pc=0; pc<(lvl & 0x7FFF); pc++) {
				dbprintf(arg,"  ");
			}
			scope->pos = end;
			break;
		}
		ch++;
	}
	if (lvl <= 0x7FFF) {
		dbprintf(arg,"\n");
	}
}
#endif /* DDB */

int aml_busy;

/* Evaluate method or buffervalue objects */
struct aml_value *
aml_eval(struct aml_scope *scope, struct aml_value *my_ret, int ret_type,
    int argc, struct aml_value *argv)
{
	struct aml_value *tmp = my_ret;
	struct aml_scope *ms;
	int idx;

	switch (tmp->type) {
	case AML_OBJTYPE_NAMEREF:
		my_ret = aml_seterror(scope, "Undefined name: %s",
		    aml_getname(my_ret->v_nameref));
		break;
	case AML_OBJTYPE_METHOD:
		dnprintf(10,"\n--== Eval Method [%s, %d args] to %c ==--\n",
		    aml_nodename(tmp->node),
		    AML_METHOD_ARGCOUNT(tmp->v_method.flags),
		    ret_type);
		ms = aml_pushscope(scope, tmp, tmp->node, AMLOP_METHOD);

		/* Parse method arguments */
		for (idx=0; idx<AML_METHOD_ARGCOUNT(tmp->v_method.flags); idx++) {
			struct aml_value *sp;

			sp = aml_getstack(ms, AMLOP_ARG0+idx);
			if (argv) {
				aml_copyvalue(sp, &argv[idx]);
			} else {
				_aml_setvalue(sp, AML_OBJTYPE_OBJREF, AMLOP_ARG0 + idx, 0);
				sp->v_objref.ref = aml_parse(scope, 't', "ARGX");
			}
		}
#ifdef ACPI_DEBUG
		aml_showstack(ms);
#endif

		/* Evaluate method scope */
		aml_root.start = tmp->v_method.base;
		if (tmp->v_method.fneval != NULL) {
			my_ret = tmp->v_method.fneval(ms, NULL);
		} else {
			aml_parse(ms, 'T', "METHEVAL");
			my_ret = ms->retv;
		}
		dnprintf(10,"\n--==Finished evaluating method: %s %c\n",
		    aml_nodename(tmp->node), ret_type);
#ifdef ACPI_DEBUG
		aml_showvalue(my_ret);
		aml_showstack(ms);
#endif
		aml_popscope(ms);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		my_ret = aml_allocvalue(0,0,NULL);
		dnprintf(20,"quick: Convert Bufferfield to %c %p\n",
		    ret_type, my_ret);
		aml_rwfield(tmp, 0, tmp->v_field.bitlen, my_ret, ACPI_IOREAD);
		break;
	}
	if (ret_type == 'i' && my_ret && my_ret->type != AML_OBJTYPE_INTEGER) {
#ifndef SMALL_KERNEL
		aml_showvalue(my_ret);
#endif
		aml_die("Not Integer");
	}
	return my_ret;
}

/*
 * The following opcodes produce return values
 *   TOSTRING	-> Str
 *   TOHEXSTR	-> Str
 *   TODECSTR	-> Str
 *   STRINGPFX	-> Str
 *   BUFFER	-> Buf
 *   CONCATRES	-> Buf
 *   TOBUFFER	-> Buf
 *   MID	-> Buf|Str
 *   CONCAT	-> Buf|Str
 *   PACKAGE	-> Pkg
 *   VARPACKAGE -> Pkg
 *   LOCALx	-> Obj
 *   ARGx	-> Obj
 *   NAMECHAR	-> Obj
 *   REFOF	-> ObjRef
 *   INDEX	-> ObjRef
 *   DEREFOF	-> DataRefObj
 *   COPYOBJECT -> DataRefObj
 *   STORE	-> DataRefObj

 *   ZERO	-> Int
 *   ONE	-> Int
 *   ONES	-> Int
 *   REVISION	-> Int
 *   B/W/D/Q	-> Int
 *   OR		-> Int
 *   AND	-> Int
 *   ADD	-> Int
 *   NAND	-> Int
 *   XOR	-> Int
 *   SHL	-> Int
 *   SHR	-> Int
 *   NOR	-> Int
 *   MOD	-> Int
 *   SUBTRACT	-> Int
 *   MULTIPLY	-> Int
 *   DIVIDE	-> Int
 *   NOT	-> Int
 *   TOBCD	-> Int
 *   FROMBCD	-> Int
 *   FSLEFTBIT	-> Int
 *   FSRIGHTBIT -> Int
 *   INCREMENT	-> Int
 *   DECREMENT	-> Int
 *   TOINTEGER	-> Int
 *   MATCH	-> Int
 *   SIZEOF	-> Int
 *   OBJECTTYPE -> Int
 *   TIMER	-> Int

 *   CONDREFOF	-> Bool
 *   ACQUIRE	-> Bool
 *   WAIT	-> Bool
 *   LNOT	-> Bool
 *   LAND	-> Bool
 *   LOR	-> Bool
 *   LLESS	-> Bool
 *   LEQUAL	-> Bool
 *   LGREATER	-> Bool
 *   LNOTEQUAL	-> Bool
 *   LLESSEQUAL -> Bool
 *   LGREATEREQ -> Bool

 *   LOADTABLE	-> DDB
 *   DEBUG	-> Debug

 *   The following opcodes do not generate a return value:
 *   NOP
 *   BREAKPOINT
 *   RELEASE
 *   RESET
 *   SIGNAL
 *   NAME
 *   ALIAS
 *   OPREGION
 *   DATAREGION
 *   EVENT
 *   MUTEX
 *   SCOPE
 *   DEVICE
 *   THERMALZONE
 *   POWERRSRC
 *   PROCESSOR
 *   METHOD
 *   CREATEFIELD
 *   CREATEBITFIELD
 *   CREATEBYTEFIELD
 *   CREATEWORDFIELD
 *   CREATEDWORDFIELD
 *   CREATEQWORDFIELD
 *   FIELD
 *   INDEXFIELD
 *   BANKFIELD
 *   STALL
 *   SLEEP
 *   NOTIFY
 *   FATAL
 *   LOAD
 *   UNLOAD
 *   IF
 *   ELSE
 *   WHILE
 *   BREAK
 *   CONTINUE
 */

/* Parse a simple object from AML Bytestream */
struct aml_value *
aml_parsesimple(struct aml_scope *scope, char ch, struct aml_value *rv)
{
	if (rv == NULL)
		rv = aml_allocvalue(0,0,NULL);
	switch (ch) {
	case AML_ARG_REVISION:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, AML_REVISION, NULL);
		break;
	case AML_ARG_DEBUG:
		_aml_setvalue(rv, AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		break;
	case AML_ARG_BYTE:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER,
		    aml_get8(scope->pos), NULL);
		scope->pos += 1;
		break;
	case AML_ARG_WORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER,
		    aml_get16(scope->pos), NULL);
		scope->pos += 2;
		break;
	case AML_ARG_DWORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER,
		    aml_get32(scope->pos), NULL);
		scope->pos += 4;
		break;
	case AML_ARG_QWORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER,
		    aml_get64(scope->pos), NULL);
		scope->pos += 8;
		break;
	case AML_ARG_STRING:
		_aml_setvalue(rv, AML_OBJTYPE_STRING, -1, scope->pos);
		scope->pos += rv->length+1;
		break;
	}
	return rv;
}

/*
 * Main Opcode Parser/Evaluator
 *
 * ret_type is expected type for return value
 *   'o' = Data Object (Int/Str/Buf/Pkg/Name)
 *   'i' = Integer
 *   't' = TermArg     (Int/Str/Buf/Pkg)
 *   'r' = Target      (NamedObj/Local/Arg/Null)
 *   'S' = SuperName   (NamedObj/Local/Arg)
 *   'T' = TermList
 */
#define aml_debugger(x)

int maxdp;

struct aml_value *
aml_gettgt(struct aml_value *val, int opcode)
{
	while (val && val->type == AML_OBJTYPE_OBJREF) {
		val = val->v_objref.ref;
	}
	return val;
}

struct aml_value *
aml_seterror(struct aml_scope *scope, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	printf("### AML PARSE ERROR (0x%x): ", aml_pc(scope->pos));
	vprintf(fmt, ap);
	printf("\n");
	va_end(ap);

	while (scope) {
		scope->pos = scope->end;
		scope = scope->parent;
	}
	aml_error++;
	return aml_allocvalue(AML_OBJTYPE_INTEGER, 0, 0);
}

/* Load new SSDT scope from memory address */
struct aml_scope *
aml_load(struct acpi_softc *sc, struct aml_scope *scope,
    struct aml_value *rgn, struct aml_value *ddb)
{
	struct acpi_q *entry;
	struct acpi_dsdt *p_ssdt;
	struct aml_value tmp;

	ddb->type = AML_OBJTYPE_DDBHANDLE;
	ddb->v_integer = 0;

	memset(&tmp, 0, sizeof(tmp));
	if (rgn->type != AML_OBJTYPE_OPREGION ||
	    rgn->v_opregion.iospace != GAS_SYSTEM_MEMORY)
		goto fail;

	/* Load SSDT from memory */
	entry = acpi_maptable(sc, rgn->v_opregion.iobase, "SSDT", NULL, NULL, 1);
	if (entry == NULL)
		goto fail;

	dnprintf(10, "%s: loaded SSDT %s @@ %llx\n", sc->sc_dev.dv_xname,
	    aml_nodename(rgn->node), rgn->v_opregion.iobase);
	ddb->v_integer = entry->q_id;

	p_ssdt = entry->q_table;
	tmp.v_buffer = p_ssdt->aml;
	tmp.length   = p_ssdt->hdr_length - sizeof(p_ssdt->hdr);

	return aml_pushscope(scope, &tmp, scope->node,
	    AMLOP_LOAD);
fail:
	printf("%s: unable to load %s\n", sc->sc_dev.dv_xname,
	    aml_nodename(rgn->node));
	return NULL;
}

struct aml_value *
aml_parse(struct aml_scope *scope, int ret_type, const char *stype)
{
	int    opcode, idx, pc;
	struct aml_opcode *htab;
	struct aml_value *opargs[8], *my_ret, *rv;
	struct aml_scope *mscope, *iscope;
	uint8_t *start, *end;
	const char *ch;
	int64_t ival;
	struct timespec ts;

	my_ret = NULL;
	if (scope == NULL || scope->pos >= scope->end) {
		return NULL;
	}
	if (odp++ > 125)
		panic("depth");
	if (odp > maxdp) {
		maxdp = odp;
		dnprintf(10, "max depth: %d\n", maxdp);
	}
	end = NULL;
	iscope = scope;
 start:
	/* --== Stage 0: Get Opcode ==-- */
	start = scope->pos;
	pc = aml_pc(scope->pos);
	aml_debugger(scope);

	opcode = aml_parseopcode(scope);
	htab = aml_findopcode(opcode);
	if (htab == NULL) {
		/* No opcode handler */
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode, pc);
	}
	dnprintf(18,"%.4x %s\n", pc, aml_mnem(opcode, scope->pos));

	/* --== Stage 1: Process opcode arguments ==-- */
	memset(opargs, 0, sizeof(opargs));
	idx = 0;
	for (ch = htab->args; *ch; ch++) {
		rv = NULL;
		switch (*ch) {
		case AML_ARG_OBJLEN:
			end = aml_parseend(scope);
			break;
		case AML_ARG_IFELSE:
                        /* Special Case: IF-ELSE:piTbpT or IF:piT */
			ch = (*end == AMLOP_ELSE && end < scope->end) ?
			    "-TbpT" : "-T";
			break;

			/* Complex arguments */
		case 's':
		case 'S':
		case AML_ARG_TARGET:
		case AML_ARG_TERMOBJ:
		case AML_ARG_INTEGER:
			if (*ch == 'r' && *scope->pos == AMLOP_ZERO) {
				/* Special case: NULL Target */
				rv = aml_allocvalue(AML_OBJTYPE_NOTARGET, 0, NULL);
				scope->pos++;
			}
			else {
				rv = aml_parse(scope, *ch, htab->mnem);
				if (rv == NULL || aml_error)
					goto parse_error;
			}
			break;

			/* Simple arguments */
		case AML_ARG_BUFFER:
		case AML_ARG_METHOD:
		case AML_ARG_FIELDLIST:
		case AML_ARG_TERMOBJLIST:
			rv = aml_allocvalue(AML_OBJTYPE_SCOPE, 0, NULL);
			rv->v_buffer = scope->pos;
			rv->length = end - scope->pos;
			scope->pos = end;
			break;
		case AML_ARG_CONST:
			rv = aml_allocvalue(AML_OBJTYPE_INTEGER,
			    (char)opcode, NULL);
			break;
		case AML_ARG_CREATENAME:
			scope->pos = aml_parsename(scope->node, scope->pos,
			    &rv, 1);
			break;
		case AML_ARG_SEARCHNAME:
			scope->pos = aml_parsename(scope->node, scope->pos,
			    &rv, 0);
			break;
		case AML_ARG_BYTE:
		case AML_ARG_WORD:
		case AML_ARG_DWORD:
		case AML_ARG_QWORD:
		case AML_ARG_DEBUG:
		case AML_ARG_STRING:
		case AML_ARG_REVISION:
			rv = aml_parsesimple(scope, *ch, NULL);
			break;
		case AML_ARG_STKLOCAL:
		case AML_ARG_STKARG:
			rv = aml_getstack(scope, opcode);
			break;
		default:
			aml_die("Unknown arg type: %c\n", *ch);
			break;
		}
		if (rv != NULL)
			opargs[idx++] = rv;
		}

	/* --== Stage 2: Process opcode ==-- */
	ival = 0;
	my_ret = NULL;
	mscope = NULL;
	switch (opcode) {
	case AMLOP_NOP:
	case AMLOP_BREAKPOINT:
		break;
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		my_ret = opargs[0];
		aml_addref(my_ret, htab->mnem);
		break;
	case AMLOP_NAMECHAR:
		/* opargs[0] = named object (node != NULL), or nameref */
		my_ret = opargs[0];
		if (scope->type == AMLOP_PACKAGE) {
			/* Special case for package */
			if (my_ret->type == AML_OBJTYPE_NAMEREF)
				my_ret = aml_allocvalue(AML_OBJTYPE_STRING, -1,
				    aml_getname(my_ret->v_nameref));
			else if (my_ret->node)
				my_ret = aml_allocvalue(AML_OBJTYPE_STRING, -1,
				    aml_nodename(my_ret->node));
			break;
		}
		if (my_ret->type == AML_OBJTYPE_OBJREF) {
			my_ret = my_ret->v_objref.ref;
			aml_addref(my_ret, "de-alias");
		}
		if (ret_type == 'i' || ret_type == 't' || ret_type == 'T') {
			/* Return TermArg or Integer: Evaluate object */
			my_ret = aml_eval(scope, my_ret, ret_type, 0, NULL);
		} else if (my_ret->type == AML_OBJTYPE_METHOD) {
			/* This should only happen with CondRef */
			dnprintf(12,"non-termarg method : %s\n", stype);
			aml_addref(my_ret, "zoom");
		}
		break;

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_DEBUG:
	case AMLOP_REVISION:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
		my_ret = opargs[0];
		break;

	case AMLOP_BUFFER:
		/* Buffer: iB => Buffer */
		my_ret = aml_allocvalue(AML_OBJTYPE_BUFFER,
		    opargs[0]->v_integer, NULL);
		memcpy(my_ret->v_buffer, opargs[1]->v_buffer,
		    opargs[1]->length);
		break;
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		/* Package/VarPackage: bT/iT => Package */
		my_ret = aml_allocvalue(AML_OBJTYPE_PACKAGE,
		    opargs[0]->v_integer, 0);
		mscope = aml_pushscope(scope, opargs[1], scope->node,
		    AMLOP_PACKAGE);

		/* Recursively parse package contents */
		for (idx=0; idx<my_ret->length; idx++) {
			rv = aml_parse(mscope, 'o', "Package");
			if (rv != NULL) {
				aml_delref(&my_ret->v_package[idx], "pkginit");
				my_ret->v_package[idx] = rv;
			}
		}
		aml_popscope(mscope);
		mscope = NULL;
		break;

		/* Math/Logical operations */
	case AMLOP_OR:
	case AMLOP_ADD:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_XOR:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_NOR:
	case AMLOP_MOD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
		/* XXX: iir => I */
		ival = aml_evalexpr(opargs[0]->v_integer,
		    opargs[1]->v_integer, opcode);
		aml_store(scope, opargs[2], ival, NULL);
		break;
	case AMLOP_DIVIDE:
		/* Divide: iirr => I */
		if (opargs[1]->v_integer == 0) {
			my_ret = aml_seterror(scope, "Divide by Zero!");
			break;
		}
		ival = aml_evalexpr(opargs[0]->v_integer,
		    opargs[1]->v_integer, AMLOP_MOD);
		aml_store(scope, opargs[2], ival, NULL);

		ival = aml_evalexpr(opargs[0]->v_integer,
		    opargs[1]->v_integer, AMLOP_DIVIDE);
		aml_store(scope, opargs[3], ival, NULL);
		break;
	case AMLOP_NOT:
	case AMLOP_TOBCD:
	case AMLOP_FROMBCD:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		/* XXX: ir => I */
		ival = aml_evalexpr(opargs[0]->v_integer, 0, opcode);
		aml_store(scope, opargs[1], ival, NULL);
		break;
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		/* Inc/Dec: S => I */
		my_ret = aml_eval(scope, opargs[0], AML_ARG_INTEGER, 0, NULL);
		ival = aml_evalexpr(my_ret->v_integer, 1, opcode);
		aml_store(scope, opargs[0], ival, NULL);
		break;
	case AMLOP_LNOT:
		/* LNot: i => Bool */
		ival = aml_evalexpr(opargs[0]->v_integer, 0, opcode);
		break;
	case AMLOP_LOR:
	case AMLOP_LAND:
		/* XXX: ii => Bool */
		ival = aml_evalexpr(opargs[0]->v_integer,
		    opargs[1]->v_integer, opcode);
		break;
	case AMLOP_LLESS:
	case AMLOP_LEQUAL:
	case AMLOP_LGREATER:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LGREATEREQUAL:
		/* XXX: tt => Bool */
		ival = aml_compare(opargs[0], opargs[1], opcode);
		break;

		/* Reference/Store operations */
	case AMLOP_CONDREFOF:
		/* CondRef: rr => I */
		ival = 0;
		if (opargs[0]->node != NULL) {
			/* Create Object Reference */
			rv = aml_allocvalue(AML_OBJTYPE_OBJREF, opcode,
				opargs[0]);
			aml_addref(opargs[0], "CondRef");
			aml_store(scope, opargs[1], 0, rv);
			aml_delref(&rv, 0);

			/* Mark that we found it */
			ival = -1;
		}
		break;
	case AMLOP_REFOF:
		/* RefOf: r => ObjRef */
		my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, opcode, opargs[0]);
		aml_addref(my_ret->v_objref.ref, "RefOf");
		break;
	case AMLOP_INDEX:
		/* Index: tir => ObjRef */
		idx = opargs[1]->v_integer;
		if (idx >= opargs[0]->length || idx < 0) {
#ifndef SMALL_KERNEL
			aml_showvalue(opargs[0]);
#endif
			aml_die("Index out of bounds %d/%d\n", idx,
			    opargs[0]->length);
		}
		switch (opargs[0]->type) {
		case AML_OBJTYPE_PACKAGE:
			/* Don't set opargs[0] to NULL */
			if (ret_type == 't' || ret_type == 'i' || ret_type == 'T') {
				my_ret = opargs[0]->v_package[idx];
				aml_addref(my_ret, "Index.Package");
			} else {
				my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, AMLOP_PACKAGE,
				    opargs[0]->v_package[idx]);
				aml_addref(my_ret->v_objref.ref,
				    "Index.Package");
			}
			break;
		case AML_OBJTYPE_BUFFER:
		case AML_OBJTYPE_STRING:
		case AML_OBJTYPE_INTEGER:
			rv = aml_convert(opargs[0], AML_OBJTYPE_BUFFER, -1);
			if (ret_type == 't' || ret_type == 'i' || ret_type == 'T') {
				dnprintf(12,"Index.Buf Term: %d = %x\n",
				    idx, rv->v_buffer[idx]);
				ival = rv->v_buffer[idx];
			} else {
				dnprintf(12, "Index.Buf Targ\n");
				my_ret = aml_allocvalue(0,0,NULL);
				aml_createfield(my_ret, AMLOP_INDEX, rv,
				    8 * idx, 8, NULL, 0, AML_FIELD_BYTEACC);
			}
			aml_delref(&rv, "Index.BufStr");
			break;
		default:
			aml_die("Unknown index : %x\n", opargs[0]->type);
			break;
		}
		aml_store(scope, opargs[2], ival, my_ret);
		break;
	case AMLOP_DEREFOF:
		/* DerefOf: t:ObjRef => DataRefObj */
		if (opargs[0]->type == AML_OBJTYPE_OBJREF) {
			my_ret = opargs[0]->v_objref.ref;
			aml_addref(my_ret, "DerefOf");
		} else {
			my_ret = opargs[0];
			//aml_addref(my_ret, "DerefOf");
		}
		break;
	case AMLOP_COPYOBJECT:
		/* CopyObject: t:DataRefObj, s:implename => DataRefObj */
		my_ret = opargs[0];
		aml_freevalue(opargs[1]);
		aml_copyvalue(opargs[1], opargs[0]);
		break;
	case AMLOP_STORE:
		/* Store: t:DataRefObj, S:upername => DataRefObj */
		my_ret = opargs[0];
		aml_store(scope, opargs[1], 0, opargs[0]);
		break;

		/* Conversion */
	case AMLOP_TOINTEGER:
		/* Source:CData, Result => Integer */
		my_ret = aml_convert(opargs[0], AML_OBJTYPE_INTEGER, -1);
		aml_store(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOBUFFER:
		/* Source:CData, Result => Buffer */
		my_ret = aml_convert(opargs[0], AML_OBJTYPE_BUFFER, -1);
		aml_store(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOHEXSTRING:
		/* Source:CData, Result => String */
		my_ret = aml_convert(opargs[0], AML_OBJTYPE_HEXSTRING, -1);
		aml_store(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TODECSTRING:
		/* Source:CData, Result => String */
		my_ret = aml_convert(opargs[0], AML_OBJTYPE_DECSTRING, -1);
		aml_store(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOSTRING:
		/* Source:B, Length:I, Result => String */
		my_ret = aml_convert(opargs[0], AML_OBJTYPE_STRING,
		    opargs[1]->v_integer);
		aml_store(scope, opargs[2], 0, my_ret);
		break;
	case AMLOP_CONCAT:
		/* Source1:CData, Source2:CData, Result => CData */
		my_ret = aml_concat(opargs[0], opargs[1]);
		aml_store(scope, opargs[2], 0, my_ret);
		break;
	case AMLOP_CONCATRES:
		/* Concat two resource buffers: buf1, buf2, result => Buffer */
		my_ret = aml_concatres(opargs[0], opargs[1]);
		aml_store(scope, opargs[2], 0, my_ret);
		break;
	case AMLOP_MID:
		/* Source:BS, Index:I, Length:I, Result => BS */
		my_ret = aml_mid(opargs[0], opargs[1]->v_integer,
		    opargs[2]->v_integer);
		aml_store(scope, opargs[3], 0, my_ret);
		break;
	case AMLOP_MATCH:
		/* Match: Pkg, Op1, Val1, Op2, Val2, Index */
		ival = aml_match(opargs[0], opargs[5]->v_integer,
		    opargs[1]->v_integer, opargs[2]->v_integer,
		    opargs[3]->v_integer, opargs[4]->v_integer);
		break;
	case AMLOP_SIZEOF:
		/* Sizeof: S => i */
		rv = aml_gettgt(opargs[0], opcode);
		ival = rv->length;
		break;
	case AMLOP_OBJECTTYPE:
		/* ObjectType: S => i */
		rv = aml_gettgt(opargs[0], opcode);
		ival = rv->type;
		break;

		/* Mutex/Event handlers */
	case AMLOP_ACQUIRE:
		/* Acquire: Sw => Bool */
		rv = aml_gettgt(opargs[0], opcode);
		ival = acpi_mutex_acquire(scope, rv,
		    opargs[1]->v_integer);
		break;
	case AMLOP_RELEASE:
		/* Release: S */
		rv = aml_gettgt(opargs[0], opcode);
		acpi_mutex_release(scope, rv);
		break;
	case AMLOP_WAIT:
		/* Wait: Si => Bool */
		rv = aml_gettgt(opargs[0], opcode);
		ival = acpi_event_wait(scope, rv,
		    opargs[1]->v_integer);
		break;
	case AMLOP_RESET:
		/* Reset: S */
		rv = aml_gettgt(opargs[0], opcode);
		acpi_event_reset(scope, rv);
		break;
	case AMLOP_SIGNAL:
		/* Signal: S */
		rv = aml_gettgt(opargs[0], opcode);
		acpi_event_signal(scope, rv);
		break;

		/* Named objects */
	case AMLOP_NAME:
		/* Name: Nt */
		rv = opargs[0];
		aml_freevalue(rv);
			aml_copyvalue(rv, opargs[1]);
		break;
	case AMLOP_ALIAS:
		/* Alias: nN */
		rv = _aml_setvalue(opargs[1], AML_OBJTYPE_OBJREF, opcode, 0);
		rv->v_objref.ref = aml_gettgt(opargs[0], opcode);
		aml_addref(rv->v_objref.ref, "Alias");
		break;
	case AMLOP_OPREGION:
		/* OpRegion: Nbii */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_OPREGION, 0, 0);
		rv->v_opregion.iospace = opargs[1]->v_integer;
		rv->v_opregion.iobase = opargs[2]->v_integer;
		rv->v_opregion.iolen = opargs[3]->v_integer;
		rv->v_opregion.flag = 0;
		break;
	case AMLOP_DATAREGION:
		/* DataTableRegion: N,t:SigStr,t:OemIDStr,t:OemTableIDStr */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_OPREGION, 0, 0);
		rv->v_opregion.iospace = GAS_SYSTEM_MEMORY;
		rv->v_opregion.iobase = 0;
		rv->v_opregion.iolen = 0;
		aml_die("AML-DataTableRegion\n");
		break;
	case AMLOP_EVENT:
		/* Event: N */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_EVENT, 0, 0);
		rv->v_integer = 0;
		break;
	case AMLOP_MUTEX:
		/* Mutex: Nw */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_MUTEX, 0, 0);
		rv->v_mtx.synclvl = opargs[1]->v_integer;
		break;
	case AMLOP_SCOPE:
		/* Scope: NT */
		rv = opargs[0];
		if (rv->type == AML_OBJTYPE_NAMEREF) {
			printf("Undefined scope: %s\n", aml_getname(rv->v_nameref));
			break;
		}
		mscope = aml_pushscope(scope, opargs[1], rv->node, opcode);
		break;
	case AMLOP_DEVICE:
		/* Device: NT */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_DEVICE, 0, 0);
		mscope = aml_pushscope(scope, opargs[1], rv->node, opcode);
		break;
	case AMLOP_THERMALZONE:
		/* ThermalZone: NT */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_THERMZONE, 0, 0);
		mscope = aml_pushscope(scope, opargs[1], rv->node, opcode);
		break;
	case AMLOP_POWERRSRC:
		/* PowerRsrc: NbwT */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_POWERRSRC, 0, 0);
		rv->v_powerrsrc.pwr_level = opargs[1]->v_integer;
		rv->v_powerrsrc.pwr_order = opargs[2]->v_integer;
		mscope = aml_pushscope(scope, opargs[3], rv->node, opcode);
		break;
	case AMLOP_PROCESSOR:
		/* Processor: NbdbT */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_PROCESSOR, 0, 0);
		rv->v_processor.proc_id = opargs[1]->v_integer;
		rv->v_processor.proc_addr = opargs[2]->v_integer;
		rv->v_processor.proc_len = opargs[3]->v_integer;
		mscope = aml_pushscope(scope, opargs[4], rv->node, opcode);
		break;
	case AMLOP_METHOD:
		/* Method: NbM */
		rv = _aml_setvalue(opargs[0], AML_OBJTYPE_METHOD, 0, 0);
		rv->v_method.flags = opargs[1]->v_integer;
		rv->v_method.start = opargs[2]->v_buffer;
		rv->v_method.end = rv->v_method.start + opargs[2]->length;
		rv->v_method.base = aml_root.start;
		break;

		/* Field objects */
	case AMLOP_CREATEFIELD:
		/* Source:B, BitIndex:I, NumBits:I, FieldName */
		rv = _aml_setvalue(opargs[3], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer,
		    opargs[2]->v_integer, NULL, 0, 0);
		break;
	case AMLOP_CREATEBITFIELD:
		/* Source:B, BitIndex:I, FieldName */
		rv = _aml_setvalue(opargs[2], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer,
		    1, NULL, 0, 0);
		break;
	case AMLOP_CREATEBYTEFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		rv = _aml_setvalue(opargs[2], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
		    8, NULL, 0, AML_FIELD_BYTEACC);
		break;
	case AMLOP_CREATEWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		rv = _aml_setvalue(opargs[2], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
		    16, NULL, 0, AML_FIELD_WORDACC);
		break;
	case AMLOP_CREATEDWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		rv = _aml_setvalue(opargs[2], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
		    32, NULL, 0, AML_FIELD_DWORDACC);
		break;
	case AMLOP_CREATEQWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		rv = _aml_setvalue(opargs[2], AML_OBJTYPE_BUFFERFIELD, 0, 0);
		aml_createfield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
		    64, NULL, 0, AML_FIELD_QWORDACC);
		break;
	case AMLOP_FIELD:
		/* Field: n:OpRegion, b:Flags, F:ieldlist */
		mscope = aml_pushscope(scope, opargs[2], scope->node, opcode);
		aml_parsefieldlist(mscope, opcode, opargs[1]->v_integer,
		    opargs[0], NULL, 0);
		mscope = NULL;
		break;
	case AMLOP_INDEXFIELD:
		/* IndexField: n:Index, n:Data, b:Flags, F:ieldlist */
		mscope = aml_pushscope(scope, opargs[3], scope->node, opcode);
		aml_parsefieldlist(mscope, opcode, opargs[2]->v_integer,
		    opargs[1], opargs[0], 0);
		mscope = NULL;
		break;
	case AMLOP_BANKFIELD:
		/* BankField: n:OpRegion, n:Field, i:Bank, b:Flags, F:ieldlist */
		mscope = aml_pushscope(scope, opargs[4], scope->node, opcode);
		aml_parsefieldlist(mscope, opcode, opargs[3]->v_integer,
		    opargs[0], opargs[1], opargs[2]->v_integer);
		mscope = NULL;
		break;

		/* Misc functions */
	case AMLOP_STALL:
		/* Stall: i */
		acpi_stall(opargs[0]->v_integer);
		break;
	case AMLOP_SLEEP:
		/* Sleep: i */
		acpi_sleep(opargs[0]->v_integer, "amlsleep");
		break;
	case AMLOP_NOTIFY:
		/* Notify: Si */
		rv = aml_gettgt(opargs[0], opcode);
		dnprintf(50,"Notifying: %s %llx\n",
		    aml_nodename(rv->node),
		    opargs[1]->v_integer);
		aml_notify(rv->node, opargs[1]->v_integer);
		break;
	case AMLOP_TIMER:
		/* Timer: => i */
		nanouptime(&ts);
		ival = ts.tv_sec * 10000000 + ts.tv_nsec / 100;
		break;
	case AMLOP_FATAL:
		/* Fatal: bdi */
		aml_die("AML FATAL ERROR: %x,%x,%x\n",
		    opargs[0]->v_integer, opargs[1]->v_integer,
		    opargs[2]->v_integer);
		break;
	case AMLOP_LOADTABLE:
		/* LoadTable(Sig:Str, OEMID:Str, OEMTable:Str, [RootPath:Str], [ParmPath:Str],
		   [ParmData:DataRefObj]) => DDBHandle */
		aml_die("LoadTable");
		break;
	case AMLOP_LOAD:
		/* Load(Object:NameString, DDBHandle:SuperName) */
		mscope = aml_load(acpi_softc, scope, opargs[0], opargs[1]);
		break;
	case AMLOP_UNLOAD:
		/* DDBHandle */
		aml_die("Unload");
		break;

		/* Control Flow */
	case AMLOP_IF:
		/* Arguments: iT or iTbT */
		if (opargs[0]->v_integer) {
			dnprintf(10,"parse-if @@ %.4x\n", pc);
			mscope = aml_pushscope(scope, opargs[1], scope->node,
			    AMLOP_IF);
		} else if (opargs[3] != NULL) {
			dnprintf(10,"parse-else @@ %.4x\n", pc);
			mscope = aml_pushscope(scope, opargs[3], scope->node,
			    AMLOP_ELSE);
		}
		break;
	case AMLOP_WHILE:
		if (opargs[0]->v_integer) {
			/* Set parent position to start of WHILE */
			scope->pos = start;
			mscope = aml_pushscope(scope, opargs[1], scope->node,
			    AMLOP_WHILE);
		}
		break;
	case AMLOP_BREAK:
		/* Break: Find While Scope parent, mark type as null */
		aml_findscope(scope, AMLOP_WHILE, AMLOP_BREAK);
		break;
	case AMLOP_CONTINUE:
		/* Find Scope.. mark all objects as invalid on way to root */
		aml_findscope(scope, AMLOP_WHILE, AMLOP_CONTINUE);
		break;
	case AMLOP_RETURN:
		mscope = aml_findscope(scope, AMLOP_METHOD, AMLOP_RETURN);
		if (mscope->retv) {
			aml_die("already allocated\n");
		}
		mscope->retv = aml_allocvalue(0,0,NULL);
		aml_copyvalue(mscope->retv, opargs[0]);
		mscope = NULL;
		break;
	default:
		/* may be set direct result */
		aml_die("Unknown opcode: %x:%s\n", opcode, htab->mnem);
		break;
	}
	if (mscope != NULL) {
		/* Change our scope to new scope */
		scope = mscope;
	}
	if ((ret_type == 'i' || ret_type == 't') && my_ret == NULL) {
		dnprintf(10,"quick: %.4x [%s] alloc return integer = 0x%llx\n",
		    pc, htab->mnem, ival);
		my_ret = aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL);
	}
	if (ret_type == 'i' && my_ret && my_ret->type != AML_OBJTYPE_INTEGER) {
		dnprintf(10,"quick: %.4x convert to integer %s -> %s\n",
		    pc, htab->mnem, stype);
		my_ret = aml_convert(my_ret, AML_OBJTYPE_INTEGER, -1);
	}
	if (my_ret != NULL) {
		/* Display result */
		dnprintf(20,"quick: %.4x %18s %c %.4x\n", pc, stype,
		    ret_type, my_ret->stack);
	}

	/* End opcode: display/free arguments */
parse_error:
	for (idx=0; idx<8; idx++) {
		if (opargs[idx] == my_ret)
			opargs[idx] = NULL;
		aml_delref(&opargs[idx], "oparg");
	}

	/* If parsing whole scope and not done, start again */
	if (ret_type == 'T') {
		aml_delref(&my_ret, "scope.loop");
		while (scope->pos >= scope->end && scope != iscope) {
			/* Pop intermediate scope */
			scope = aml_popscope(scope);
		}
		if (scope->pos && scope->pos < scope->end)
			goto start;
	}

	odp--;
	dnprintf(50, ">>return [%s] %s %c %p\n", aml_nodename(scope->node),
	    stype, ret_type, my_ret);

	return my_ret;
}

int
acpi_parse_aml(struct acpi_softc *sc, u_int8_t *start, u_int32_t length)
{
	struct aml_scope *scope;
	struct aml_value res;

	aml_root.start = start;
	memset(&res, 0, sizeof(res));
	res.type = AML_OBJTYPE_SCOPE;
	res.length = length;
	res.v_buffer = start;

	/* Push toplevel scope, parse AML */
	aml_error = 0;
	scope = aml_pushscope(NULL, &res, &aml_root, AMLOP_SCOPE);
	aml_busy++;
	aml_parse(scope, 'T', "TopLevel");
	aml_busy--;
	aml_popscope(scope);

	if (aml_error) {
		printf("error in acpi_parse_aml\n");
		return -1;
	}
	return (0);
}

/*
 * @@@@@@: External API
 *
 * evaluate an AML node
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	struct aml_value *xres;

	if (res)
		memset(res, 0, sizeof(*res));
	if (node == NULL || node->value == NULL)
		return (ACPI_E_BADVALUE);
	dnprintf(12,"EVALNODE: %s %lx\n", aml_nodename(node), acpi_nalloc);

	aml_error = 0;
	xres = aml_eval(NULL, node->value, 't', argc, argv);
	if (xres) {
		if (res)
			aml_copyvalue(res, xres);
		if (xres != node->value)
			aml_delref(&xres, "evalnode");
	}
	if (aml_error) {
		printf("error evaluating: %s\n", aml_nodename(node));
		return (-1);
	}
	return (0);
}

int
aml_node_setval(struct acpi_softc *sc, struct aml_node *node, int64_t val)
{
	struct aml_value env;

	if (!node)
		return (0);

	memset(&env, 0, sizeof(env));
	env.type = AML_OBJTYPE_INTEGER;
	env.v_integer = val;

	return aml_evalnode(sc, node, 1, &env, NULL);
}

/*
 * evaluate an AML name
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalname(struct acpi_softc *sc, struct aml_node *parent, const char *name,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	parent = aml_searchname(parent, name);
	return aml_evalnode(sc, parent, argc, argv, res);
}

/*
 * evaluate an AML integer object
 */
int
aml_evalinteger(struct acpi_softc *sc, struct aml_node *parent,
    const char *name, int argc, struct aml_value *argv, int64_t *ival)
{
	struct aml_value res;
	int rc;

	parent = aml_searchname(parent, name);
	rc = aml_evalnode(sc, parent, argc, argv, &res);
	if (rc == 0) {
		*ival = aml_val2int(&res);
		aml_freevalue(&res);
	}
	return rc;
}

/*
 * Search for an AML name in namespace.. root only
 */
struct aml_node *
__aml_searchname(struct aml_node *root, const void *vname, int create)
{
	char *name = (char *)vname;
	char  nseg[AML_NAMESEG_LEN + 1];
	int   i;

	dnprintf(25,"Searchname: %s:%s = ", aml_nodename(root), name);
	while (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name != 0) {
		/* Ugh.. we can have short names here: append '_' */
		strlcpy(nseg, "____", sizeof(nseg));
		for (i=0; i < AML_NAMESEG_LEN && *name && *name != '.'; i++)
			nseg[i] = *name++;
		if (*name == '.')
			name++;
		root = __aml_search(root, nseg, create);
	}
	dnprintf(25,"%p %s\n", root, aml_nodename(root));
	return root;
}

struct aml_node *
aml_searchname(struct aml_node *root, const void *vname)
{
	return __aml_searchname(root, vname, 0);
}

/*
 * Search for relative name
 */
struct aml_node *
aml_searchrel(struct aml_node *root, const void *vname)
{
	struct aml_node *res;

	while (root) {
		res = aml_searchname(root, vname);
		if (res != NULL)
			return res;
		root = root->parent;
	}
	return NULL;
}

#ifndef SMALL_KERNEL

void
acpi_getdevlist(struct acpi_devlist_head *list, struct aml_node *root,
    struct aml_value *pkg, int off)
{
	struct acpi_devlist *dl;
	struct aml_node *node;
	int idx;

	for (idx=off; idx<pkg->length; idx++) {
		node = aml_searchname(root, pkg->v_package[idx]->v_string);
		if (node) {
			dl = acpi_os_malloc(sizeof(*dl));
			if (dl) {
				dl->dev_node = node;
				TAILQ_INSERT_TAIL(list, dl, dev_link);
			}
		}
	}
}

void
acpi_freedevlist(struct acpi_devlist_head *list)
{
	struct acpi_devlist *dl;

	while ((dl = TAILQ_FIRST(list)) != NULL) {
		TAILQ_REMOVE(list, dl, dev_link);
		acpi_os_free(dl);
	}
}
#endif /* SMALL_KERNEL */
@


1.233
log
@Fix format string in ACPI_MEMDEBUG block

From Anton Lindqvist (anton.lindqvist(at)gmail.com)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.232 2017/04/08 01:20:10 deraadt Exp $ */
d1263 1
a1263 1
		if ((nn = child->name) != NULL) {
@


1.232
log
@Two prototypes for acpi_maptable; merge to one place
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.231 2017/02/16 18:02:22 jcs Exp $ */
d409 2
a410 1
	printf("--- walkmem:%s %x --- %x bytes alloced\n", lbl, sig, acpi_nalloc);
@


1.231
log
@On Apple hardware, claim an OSI of Darwin and no other OSes

The DSDT on at MacBooks takes many different and beneficial code
paths when the OS reports to be Darwin, but due to the way it checks
OSI, we can't just add Darwin to the aml_valid_osi array since later
checks for Windows variants will supersede the Darwin check.

Fixes suspend and keeps Thunderbolt ports powered up after resume.
One regression is that the acpibat driver no longer attaches and
will require an ACPI Smart Battery driver, which is in the works.

Adapted from a similar change in the Linux kernel from 2014.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.230 2017/01/14 11:32:00 kettenis Exp $ */
a48 3
struct acpi_q		*acpi_maptable(struct acpi_softc *sc, paddr_t,
			    const char *, const char *,
			    const char *, int);
@


1.230
log
@Revert aml_rdpciaddr changes; breaks several machines that were working
before.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.229 2017/01/08 12:39:16 kettenis Exp $ */
d109 2
d1510 15
@


1.229
log
@Make aml_rdpciaddr() work for for devices behind bridges.  The code now
uses the mapping between AML nodes and PCI devices that we establish.
Because _INIT methods may end up calling aml_rdpciaddr(), make sure we
create that mapping early.  Also handle devices that aren't actually present.
These devices are now included in the mapping and reads will return an
all-ones patterm whereas writes are a no-op..

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.228 2016/12/18 15:59:22 kettenis Exp $ */
d2221 15
a2235 10
	if (pcidev->pci == NULL)
		return -1;

	if (aml_evalinteger(acpi_softc, pcidev, "_ADR", 0, NULL, &res))
		return -1;

	addr->fun = res & 0xffff;
	addr->dev = res >> 16;
	addr->bus = pcidev->pci->bus;
	return 0;
d2277 1
a2277 6
		if (aml_rdpciaddr(rgn->node->parent, &pi)) {
			if (mode == ACPI_IOREAD)
				pi.fun = 0xffff;
			else
				return;
		}
@


1.228
log
@Remove comparison of array which is always non-NULL.  Fixes clang warning.

ok jca@@ (a while back)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.227 2016/10/25 06:48:58 pirofti Exp $ */
d2221 10
a2230 15
	if (aml_evalinteger(acpi_softc, pcidev, "_ADR", 0, NULL, &res) == 0) {
		addr->fun = res & 0xFFFF;
		addr->dev = res >> 16;
	}
	while (pcidev != NULL) {
		/* HID device (PCI or PCIE root): eval _BBN */
		if (__aml_search(pcidev, "_HID", 0)) {
			if (aml_evalinteger(acpi_softc, pcidev, "_BBN", 0, NULL, &res) == 0) {
				addr->bus = res;
				break;
			}
		}
		pcidev = pcidev->parent;
	}
	return (0);
d2272 6
a2277 1
		aml_rdpciaddr(rgn->node->parent, &pi);
@


1.227
log
@Add the resource index to aml_parse_resource() callback function.

This is needed by an upcoming acpiec commit that handles machines breaking
the current ACPI specifications.

Change suggested by and ok kettenis@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.226 2016/10/21 21:47:03 joris Exp $ */
d590 1
a590 1
		if (pdata->pnpid && !strcmp(pdata->pnpid, pnpid))
@


1.226
log
@Add support for the ACPI timer opcode.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.225 2016/09/27 10:04:19 mlarkin Exp $ */
d1626 1
a1626 1
    int (*crs_enum)(union acpi_resource *, void *), void *arg)
d1628 1
a1628 1
	int off, rlen;
d1633 1
a1633 1
	for (off = 0; off < res->length; off += rlen) {
d1644 1
a1644 1
		crs_enum(crs, arg);
d1751 1
a1751 1
int		aml_ccrlen(union acpi_resource *, void *);
d2145 1
a2145 1
aml_ccrlen(union acpi_resource *rs, void *arg)
@


1.225
log
@
Print the type of operation space that failed as there seem to be more of
these occurring recently.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.224 2016/09/02 13:59:51 pirofti Exp $ */
d23 1
d251 1
d3442 1
d4043 2
a4044 1
		ival = 0xDEADBEEF;
@


1.224
log
@Remove unused argument in aml_showvalue().


The second argument of aml_showvalue() was probably supposed to set
the verbosity level through dnprintf() but in fact it does nothing.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.223 2016/05/08 11:08:01 kettenis Exp $ */
d2475 2
a2476 1
			aml_die("Unsupported RegionSpace");
@


1.223
log
@Add support for writing gpio pins.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.222 2016/05/07 18:08:27 kettenis Exp $ */
d292 1
a292 1
				aml_showvalue(sp, 0);
d299 1
a299 1
				aml_showvalue(sp, 0);
d789 1
a789 1
aml_showvalue(struct aml_value *val, int lvl)
d812 1
a812 1
			aml_showvalue(val->v_package[idx], lvl);
d865 1
a865 1
		aml_showvalue(val->v_objref.ref, lvl);
d1858 1
a1858 1
			aml_showvalue(sp, 10);
d1865 1
a1865 1
			aml_showvalue(sp, 10);
d2073 1
a2073 1
		aml_showvalue(a, 0);
d3177 1
a3177 1
		aml_showvalue(my_ret, 0);
d3192 1
a3192 1
		aml_showvalue(my_ret, 8-100);
d3728 1
a3728 1
			aml_showvalue(opargs[0], 0);
@


1.222
log
@Implement ACPI 5.0 GeneralPurposeIo OpRegion support.  This basically allows
AML to peek and poke at GPIO pins as if it were reading and writing
registers.  For now this only implements peeking at pins.  It will print
a message if AML attempt to poke at a pin.  And it will panic if the
assumptions made in the code are violated.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.221 2016/03/14 06:37:31 guenther Exp $ */
d2358 5
a2362 2
		printf("GpioIO write unimplemented\n");
		return;
a2363 3

	v = node->gpio->read_pin(node->gpio->cookie, pin);
	_aml_setvalue(val, AML_OBJTYPE_INTEGER, v, NULL);
@


1.221
log
@Correct the value of SRT_ENDTAG: it was documented incorrectly in early
ACPI specs.  With the correct value, it can now be used in a few places
instead of hardcoding 0x79.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.220 2016/03/02 05:14:34 jsg Exp $ */
d2209 1
d2336 31
d2462 16
a2477 2
		aml_rwgas(ref1, fld->v_field.bitpos + bpos, blen, val, mode,
		    fld->v_field.flags);
d2547 1
d2556 1
a2556 1
		case 0x00: // reserved, length
d2560 1
a2560 1
		case 0x01: // flags
d2564 9
a2572 1
		default: // 4-byte name, length
d2576 2
a2577 2
			aml_createfield(rv, opcode, data, bpos, blen, index,
				indexval, flags);
@


1.220
log
@Claim to be more versions of windows for _OSI checks.

2001.1 SP1	Windows Server 2003 SP1
2006.1		Windows Server 2008
2006 SP1	Windows Vista SP1
2006 SP2	Windows Vista SP2
2015		Windows 10

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.219 2016/01/13 23:11:22 kettenis Exp $ */
d1635 1
a1635 1
		if (crs->hdr.typecode == 0x79 || !rlen)
d2157 1
a2157 1
	uint8_t a3[] = { 0x79, 0x00 };
@


1.219
log
@Change aml_find_node() such that it only walks down the tree and doesn't
traverse sideways.  This seems to be what all callersexpect it to do, and
fixes a bug in dwiic(4) where it would try to access i2c devices on busses
they're not attached to.

If there is any fallout from this change, the right thing to do is probably
to make sure callers pass the right node.

While there, change the return type to void, as the return value was useless
and none of the callers looked at it.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.218 2015/08/20 20:50:10 kettenis Exp $ */
d1482 1
d1489 3
d1495 1
@


1.218
log
@Respect the access size when reading or writing to pci config space.
This version also makes sure writes are properly aligned, preventing
the panics seen with the previous incarnation of this change.

Fixes battery status passthrough in vmware, brightness keys on my x220
and who knows what else.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.217 2015/05/04 10:42:06 jmatthew Exp $ */
d1252 1
a1252 1
int
d1256 1
a1257 1
	int st = 0;
d1259 3
a1261 2
	while (node) {
		if ((nn = node->name) != NULL) {
d1264 5
a1268 2
			if (!strcmp(name, nn))
				st = cbproc(node, arg);
d1270 1
a1270 4
		/* Only recurse if cbproc() wants us to */
		if (!st)
			aml_find_node(SIMPLEQ_FIRST(&node->son), name, cbproc, arg);
		node = SIMPLEQ_NEXT(node, sib);
a1271 1
	return st;
@


1.217
log
@When writing a value to a field, don't read past the end of the source value
if the field is bigger.  Fixes crashes seen on HP bc2500 blades with MP
kernels.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.216 2015/03/16 20:31:46 deraadt Exp $ */
d2263 2
a2264 1
	pi.addr = rgn->v_opregion.iobase + ((bpos >> 3) & ~(sz - 1));
@


1.216
log
@Reduce use of SMALL_KERNEL in acpi, bringing acpiec driver and more gpe
handling into RAMDISK.  This is now possible because the install media
has ample room.  The goal is to reduce special cases where we may be
skipping (unknown) important operations...
ok mlarkin kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.215 2015/03/14 03:38:47 jsg Exp $ */
d2289 3
@


1.215
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.214 2014/09/14 14:17:24 jsg Exp $ */
a518 1
#ifndef SMALL_KERNEL
a531 1
#endif
a578 1
#ifndef SMALL_KERNEL
a600 1
#endif
@


1.214
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.213 2014/07/20 12:20:38 kettenis Exp $ */
a27 1
#include <ddb/db_command.h>
@


1.213
log
@Skip reading bits from a region marked as "Preserve" if all bits will be
modified.  Some Sony and Asus laptops don't like this; the read seems to
trigger an unwanted SMI that makes the machine hang.  Diagnosed by mpi@@

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.212 2014/07/12 18:48:17 tedu Exp $ */
a22 1
#include <sys/proc.h>
@


1.212
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.211 2014/06/25 18:56:22 kettenis Exp $ */
d2314 2
a2315 1
		if (AML_FIELD_UPDATE(flag) == AML_FIELD_PRESERVE) {
@


1.211
log
@So it turns out that there is AML out there that asks for an access
width that isn't compatible with the alignment of the region:

    OperationRegion (SATC, SystemMemory, 0xE008800A, 0x04)
    Field (SATC, DWordAcc, NoLock, Preserve)
    {
         STCL,   16
    }

DWordAcc means 4-byte access, but 0xE008800A is only 2-byte aligned.
Moreover, the region itself is 4 bytes long.  From this I conclude
that 4-byte wide access to a 2-byte aligned address is really wanted
in cases like this.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.210 2014/06/23 18:47:41 kettenis Exp $ */
d455 1
a455 1
		free(sptr, M_ACPI);
@


1.210
log
@SystemMemory is used to access memory mapped registers on some machines, so we
must use the bus_space(9) API to access it instead of memcpy(9).  Also make
sure we properly align access to fields that need more than byte alignment.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.209 2014/05/21 02:14:07 mlarkin Exp $ */
d2269 1
a2269 4
	KASSERT(rgn->v_opregion.iobase % sz == 0);

	pi.addr = rgn->v_opregion.iobase + (bpos >> 3);
	pi.addr &= ~(sz - 1);
@


1.209
log
@Fix invalid / missing format specifiers in several dnprintf statements
(used only when ACPI_DEBUG is enabled)

From a diff on tech@@ by Fabian Raetz, with a minor change by me, tested
on i386 and amd64 with ACPI_DEBUG enabled and disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.208 2014/05/02 14:04:50 kettenis Exp $ */
d2244 1
a2244 1
	int slen, type, sz;
a2251 6
	pi.addr = rgn->v_opregion.iobase + (bpos >> 3);
	if (rgn->v_opregion.iospace == GAS_PCI_CFG_SPACE)
	{
		/* Get PCI Root Address for this opregion */
		aml_rdpciaddr(rgn->node->parent, &pi);
	}
d2269 11
d2282 1
a2282 1
	slen = (blen + 7) >> 3;
d2286 5
d2294 1
a2294 1
			_aml_setvalue(val, AML_OBJTYPE_BUFFER, slen, 0);
a2298 2
		_aml_setvalue(&tmp, AML_OBJTYPE_BUFFER, slen, 0);
		tbit = tmp.v_buffer;
a2299 3
	} else if (mode == ACPI_IOREAD) {
		/* Read from a short field.. initialize integer */
		_aml_setvalue(val, AML_OBJTYPE_INTEGER, 0, 0);
d2301 7
a2307 2
		/* Write to a short field.. convert to integer */
		val = aml_convert(val, AML_OBJTYPE_INTEGER, -1);
d2313 2
a2314 2
		    sz, slen, tbit);
		aml_bufcpy(vbit, 0, tbit, bpos & 7, blen);
d2317 1
a2317 8
		if (val->length < slen) {
			dnprintf(0,"writetooshort: %d %d %s\n",
			    val->length, slen, aml_nodename(rgn->node));
			slen = val->length;
		}
		if (AML_FIELD_UPDATE(flag) == AML_FIELD_PRESERVE && 
		    ((bpos | blen) & 7)) {
			/* If not aligned and preserve, read existing value */
d2319 1
a2319 1
			    sz, slen, tbit);
d2321 1
a2321 1
			memset(tbit, 0xFF, tmp.length);
d2324 1
a2324 1
		aml_bufcpy(tbit, bpos & 7, vbit, 0, blen);
d2326 1
a2326 1
		    sz, slen, tbit);
a2331 1

@


1.208
log
@Make acpi_mutex_acquire/release actually grab the global lock if it should.
Get rid of the fake global lock code that these functions were using before.

ok pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.207 2014/04/26 21:45:50 kettenis Exp $ */
d427 1
a427 1
	dnprintf(99, "alloc: %x %s:%d\n", sptr, fn, line);
d454 1
a454 1
		dnprintf(99, "free: %x %s:%d\n", sptr, fn, line);
d555 1
a555 1
	dnprintf(10, "aml_register_notify: %s %s %x\n",
d3127 1
a3127 1
		dnprintf(20,"quick: Convert Bufferfield to %c 0x%x\n",
d3974 1
a3974 1
		dnprintf(50,"Notifying: %s %x\n",
d4135 1
a4135 1
	dnprintf(12,"EVALNODE: %s %d\n", aml_nodename(node), acpi_nalloc);
d4208 1
a4208 1
	dnprintf(25,"Searchname: %s:%s = ", aml_nodename(root), vname);
@


1.207
log
@Get rid of duplication of the global lock code.  Allow recursion in all
code paths.

ok pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.206 2014/03/13 18:52:38 brynet Exp $ */
a729 2
long acpi_acquire_global_lock(void*);
long acpi_release_global_lock(void*);
a730 2
#define acpi_acquire_global_lock(x) 1
#define acpi_release_global_lock(x) 0
a2540 2
	int err;

d2546 1
a2546 1
			err = acpi_acquire_global_lock(&acpi_softc->sc_facs->global_lock);
a2560 2
	int err;

d2563 1
a2563 1
		err=acpi_release_global_lock(&acpi_softc->sc_facs->global_lock);
@


1.206
log
@Update the _OSI list to include newer Redmond products which may be requested
by newer firmware. May cause problems with brightness control on some systems.

"lets see what happens" kettenis@@, and.. deraadt@@ agrees (..hopefully).
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.205 2013/12/12 20:56:01 guenther Exp $ */
a738 23
	acpi_acquire_glk(&acpi_softc->sc_facs->global_lock);
}

void
acpi_glk_leave(void)
{
	int x;

	if (acpi_release_glk(&acpi_softc->sc_facs->global_lock)) {
		/*
		 * If pending, notify the BIOS that the lock was released
		 * by the OSPM. No locking is needed because nobody outside
		 * the ACPI thread is touching this register.
		 */
		x = acpi_read_pmreg(acpi_softc, ACPIREG_PM1_CNT, 0);
		x |= ACPI_PM1_GBL_RLS;
		acpi_write_pmreg(acpi_softc, ACPIREG_PM1_CNT, 0, x);
	}
}

void
aml_lockfield(struct aml_scope *scope, struct aml_value *field)
{
d741 1
a741 4
	if (AML_FIELD_LOCK(field->v_field.flags) != AML_FIELD_LOCK_ON)
		return;

	/* If lock is already ours, just continue */
d745 1
a745 1
	/* Spin to acquire lock */
a749 2

	return;
d753 1
a753 1
aml_unlockfield(struct aml_scope *scope, struct aml_value *field)
d755 1
a755 4
	int st, x, s;

	if (AML_FIELD_LOCK(field->v_field.flags) != AML_FIELD_LOCK_ON)
		return;
d757 1
a757 1
	/* If we are the last ones, turn out the lights */
a760 1
	/* Release lock */
d765 5
a769 2
	/* Signal others if someone waiting */
	s = spltty();
d773 16
a788 1
	splx(s);
d790 1
a790 1
	return;
@


1.205
log
@printf(variable) --> printf("%s", variable)

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.204 2013/11/04 22:32:31 kettenis Exp $ */
d1513 2
@


1.204
log
@Enable locking of fields using the acpi global lock if required.  Seems to fix
a couple of machines and so far caused no regressions.  Pt this in the tree
now to get wider testing.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.203 2013/06/02 17:21:38 jcs Exp $ */
d3005 1
a3005 1
			dbprintf(arg,aml_nodename(rv->node));
d3009 1
a3009 1
			dbprintf(arg,htab->mnem);
@


1.203
log
@support aml_store to a method object to override it
resolves a problem parsing the AML on an ASUS UX21A

originally from armani@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.202 2013/06/02 01:22:00 kettenis Exp $ */
d773 1
a773 1
		st = acpi_acquire_global_lock(&acpi_softc->sc_facs->global_lock);
d793 1
a793 1
	st = acpi_release_global_lock(&acpi_softc->sc_facs->global_lock);
@


1.202
log
@The AML on the Lanner FW-8758 does a Store() to a named object that's never
actually defined.  The ACPI standard isn't clear wether this is allowed,
but it makes some sense to just initialize the object with the source of
the Store().  Fixes the resulting panic on that particular machine.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.201 2013/05/23 10:27:43 kettenis Exp $ */
d2697 8
@


1.201
log
@Properly implement access to IndexField() field units.  The origional code
only worked for field units that were 8 bits or less in size on fields
using byte access.  Fixes issues origionally reported by jcs@@ and armani@@.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.200 2013/04/10 01:35:55 guenther Exp $ */
d613 1
d2632 1
d2691 7
d4214 1
a4214 1
aml_searchname(struct aml_node *root, const void *vname)
d4232 1
a4232 1
		root = __aml_search(root, nseg, 0);
d4236 6
@


1.200
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.199 2013/02/09 20:56:35 miod Exp $ */
d2224 2
a2226 1
void aml_rwgas(struct aml_value *, int, int, struct aml_value *, int, int);
d2345 75
d2435 1
a2435 4
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, fld->v_field.ref3, 0);
		aml_rwfield(ref2, 0, aml_intlen, &tmp, ACPI_IOWRITE);
		aml_rwfield(ref1, fld->v_field.bitpos, fld->v_field.bitlen,
		    val, mode);
a2489 4
	if (opcode == AMLOP_INDEXFIELD) {
		indexval = bpos >> 3;
		bpos &= 7;
	}
@


1.199
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.198 2013/01/18 04:07:06 pirofti Exp $ */
d383 1
a383 1
    LIST_HEAD_INITIALIZER(&aml_notify_list);
@


1.198
log
@acpi: Add global lock enter and leave routines.

I think this diff is the way to go if we want to have proper locking in
our acpi drivers. This doesn't hook onto anything from the kernel and
is just building framework towards locking.

Okay mlarkin@@, kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.197 2012/07/16 15:27:11 deraadt Exp $ */
d2643 2
a2644 1
    void (*dbprintf)(void *, const char *, ...),
@


1.197
log
@Add shorter form function aml_node_setval() for setting an int
on an AML node. Shortens the tricky code in a lot of callers.
Earlier version seen by pirofti and kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.196 2012/07/10 15:57:41 pirofti Exp $ */
d734 24
@


1.196
log
@Ooops. A debug printf sneaked in. Sorry about that.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.195 2012/07/10 15:49:25 pirofti Exp $ */
d4059 15
@


1.195
log
@More wraping and style.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.194 2012/07/10 15:04:34 pirofti Exp $ */
a2339 1
		printf("BANKFIELD\n");
@


1.194
log
@Wrap
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.193 2012/03/15 18:36:53 kettenis Exp $ */
d2228 2
a2229 1
aml_rwgas(struct aml_value *rgn, int bpos, int blen, struct aml_value *val, int mode, int flag)
d2292 2
a2293 1
		acpi_gasio(acpi_softc, ACPI_IOREAD, type, pi.addr, sz, slen, tbit);
d2298 2
a2299 1
			dnprintf(0,"writetooshort: %d %d %s\n", val->length, slen, aml_nodename(rgn->node));
d2302 2
a2303 1
		if (AML_FIELD_UPDATE(flag) == AML_FIELD_PRESERVE && ((bpos|blen) & 7)) {
d2305 2
a2306 1
			acpi_gasio(acpi_softc, ACPI_IOREAD, type, pi.addr, sz, slen, tbit);
d2312 2
a2313 1
		acpi_gasio(acpi_softc, ACPI_IOWRITE, type, pi.addr, sz, slen, tbit);
d2321 2
a2322 1
aml_rwfield(struct aml_value *fld, int bpos, int blen, struct aml_value *val, int mode)
d2340 1
d2346 1
a2346 1
		aml_rwgas(ref1, fld->v_field.bitpos+bpos, blen, val, mode,
d2579 2
a2580 1
			dnprintf(10,"Overrun! %d,%d\n", lhs->length, rhs->length);
d2659 3
a2661 1
			for (ival=0; ival<AML_METHOD_ARGCOUNT(rv->v_method.flags); ival++) {
@


1.193
log
@Allow multiple backslashes at the start of a namespace path.  It is pretty
clear this is not supposed to happen, but unfortunately the description of
the ECDT table in the standard document has a path that starts with two
backslashes so that's what some vendors used.

From Christophe Staiesse.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.192 2012/03/10 21:18:59 kettenis Exp $ */
d2330 2
a2331 1
		aml_rwfield(ref1, fld->v_field.bitpos, fld->v_field.bitlen, val, mode);
d2335 2
a2336 1
		aml_rwgas(ref1, fld->v_field.bitpos, fld->v_field.bitlen, val, mode, fld->v_field.flags);
d2338 2
a2339 1
		aml_rwgas(ref1, fld->v_field.bitpos+bpos, blen, val, mode, fld->v_field.flags);
d2343 2
a2344 1
		aml_bufcpy(&val->v_integer, 0, ref1->v_buffer, fld->v_field.bitpos, fld->v_field.bitlen);
d2348 2
a2349 1
		aml_bufcpy(ref1->v_buffer, fld->v_field.bitpos, &val->v_integer, 0, fld->v_field.bitlen);
@


1.192
log
@AML integers are supposed to be 64-bit unsigned, but huge parts of our code
use signed integers.  Partially fix issues by at least doing math operations
on unsigned integers.  From Christophe Staiesse.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.191 2011/06/15 08:11:51 pirofti Exp $ */
d4088 1
a4088 1
	if (*name == AMLOP_ROOTCHAR) {
@


1.191
log
@Silence unneeded conversion warning. Okay jordan@@.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.190 2011/06/08 05:38:28 jordan Exp $ */
d66 1
a66 1
int64_t			aml_evalexpr(int64_t, int64_t, int);
d1102 2
a1103 2
int64_t
aml_evalexpr(int64_t lhs, int64_t rhs, int opcode)
d1105 1
a1105 1
	int64_t res = 0;
@


1.190
log
@Use static scope during AML disassembly, fixes splassert error
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.189 2011/06/03 16:44:16 jordan Exp $ */
a2387 3
	{
		printf("WARN: %s not buffer\n",
		    aml_nodename(data->node));
d2389 1
a2389 1
	}
@


1.189
log
@Change acpi_xfoo to acpi_foo names.
Fix return value for Acquire/Wait (TRUE = -1)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.188 2011/06/03 03:56:15 jordan Exp $ */
d2617 1
a2617 1
	struct aml_scope *ms;
d2905 14
a2918 11
			/* Field List */
			tmp.v_buffer = scope->pos;
			tmp.length   = end - scope->pos;

			ms = aml_pushscope(scope, &tmp, scope->node, 0);
			while (ms && ms->pos < ms->end) {
				if (*ms->pos == 0x00) {
					ms->pos++;
					aml_parselength(ms);
				} else if (*ms->pos == 0x01) {
					ms->pos+=3;
d2920 3
a2922 3
					ms->pos = aml_parsename(ms->node,
					     ms->pos, &rv, 1);
					aml_parselength(ms);
a2927 1
			aml_popscope(ms);
d2932 1
a2932 1
				dbprintf(arg,"	");
d2938 6
a2943 2
			tmp.v_buffer = scope->pos;
			tmp.length   = end - scope->pos;
d2945 2
a2946 3
			ms = aml_pushscope(scope, &tmp, scope->node, 0);
			while (ms && ms->pos < ms->end) {
				aml_disasm(ms, (lvl + 1) & 0x7FFF,
a2948 1
			aml_popscope(ms);
d2953 1
a2953 1
				dbprintf(arg,"	");
@


1.188
log
@Track depth of scope stack
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.187 2011/06/02 19:26:35 jordan Exp $ */
d2444 5
a2448 5
int	acpi_xmutex_acquire(struct aml_scope *, struct aml_value *, int);
void	acpi_xmutex_release(struct aml_scope *, struct aml_value *);
int	acpi_xevent_wait(struct aml_scope *, struct aml_value *, int);
void	acpi_xevent_signal(struct aml_scope *, struct aml_value *);
void	acpi_xevent_reset(struct aml_scope *, struct aml_value *);
d2451 1
a2451 1
acpi_xmutex_acquire(struct aml_scope *scope, struct aml_value *mtx,
d2467 1
a2467 1
		return (1);
d2474 1
a2474 1
acpi_xmutex_release(struct aml_scope *scope, struct aml_value *mtx)
d2489 1
a2489 1
acpi_xevent_wait(struct aml_scope *scope, struct aml_value *evt, int timeout)
d2504 1
a2504 1
		return (1);
d2511 1
a2511 1
acpi_xevent_signal(struct aml_scope *scope, struct aml_value *evt)
d2518 1
a2518 1
acpi_xevent_reset(struct aml_scope *scope, struct aml_value *evt)
d3689 1
a3689 1
		ival = acpi_xmutex_acquire(scope, rv,
d3695 1
a3695 1
		acpi_xmutex_release(scope, rv);
d3700 1
a3700 1
		ival = acpi_xevent_wait(scope, rv,
d3706 1
a3706 1
		acpi_xevent_reset(scope, rv);
d3711 1
a3711 1
		acpi_xevent_signal(scope, rv);
@


1.187
log
@Fix index for Mid() opcode
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.186 2011/06/02 17:15:53 jordan Exp $ */
d1891 3
@


1.186
log
@Fix CondRef definition to support optional target.  Fixes docking on Dell E4310
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.185 2011/04/22 18:22:01 jordan Exp $ */
d2169 1
a2169 1
		index = 0;
@


1.185
log
@Fix uninitialzied variables and formatting strings (-Wxxx errors)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.184 2011/04/19 23:56:10 deraadt Exp $ */
d247 1
a247 1
	{ AMLOP_CONDREFOF,	"CondRef",	"SS",	},
d3540 1
a3540 1
			opargs[2] = aml_allocvalue(AML_OBJTYPE_OBJREF, opcode,
d3543 2
a3544 1
			aml_store(scope, opargs[1], 0, opargs[2]);
@


1.184
log
@clean out some tiny nits
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.183 2011/04/18 00:40:26 jordan Exp $ */
d821 1
a821 1
		printf(" field: bitpos=%.4x bitlen=%.4x ref1:%x ref2:%x [%s]\n",
d1105 1
a1105 1
	int64_t res;
d2098 1
a2098 1
	struct aml_value *c;
d2613 1
a2613 1
	uint8_t *end;
@


1.183
log
@Change all aml_xfoo to aml_foo names now that parser is stable
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.182 2011/03/20 00:09:14 jordan Exp $ */
d1507 1
a1507 1
aml_create_defaultobjects()
d1680 1
a1680 1
aml_postparse()
d2159 1
a2159 1
	memcpy(c->v_buffer+l1+l2, a3,           l3);
@


1.182
log
@changes the values of boolean comparisons from 0:1 to 0:-1 (from ACPI Spec) in order to fix an AML issue on some Asus machines.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.181 2011/01/02 04:56:57 jordan Exp $ */
d73 2
a74 2
void			aml_xaddref(struct aml_value *, const char *);
void			aml_xdelref(struct aml_value **, const char *);
d712 1
a712 1
		aml_xdelref(&onode->value, "");
d990 1
a990 1
		aml_xaddref(lhs->v_objref.ref, "");
d1010 1
a1010 1
		aml_xaddref(rv, "");
d1038 1
a1038 1
		aml_xdelref(&val->v_objref.ref, "");
d1042 2
a1043 2
		aml_xdelref(&val->v_field.ref1, "");
		aml_xdelref(&val->v_field.ref2, "");
d1359 1
a1359 1
		aml_xaddref(*rval, 0);
d1534 1
a1534 1
		aml_xdelref(&tmp, 0);
d1719 1
a1719 1
struct aml_value *aml_xeval(struct aml_scope *, struct aml_value *, int, int,
d1721 1
a1721 1
struct aml_value *aml_xparsesimple(struct aml_scope *, char,
d1723 1
a1723 1
struct aml_value *aml_xparse(struct aml_scope *, int, const char *);
d1726 2
a1727 2
struct aml_scope *aml_xfindscope(struct aml_scope *, int, int);
struct aml_scope *aml_xpushscope(struct aml_scope *, struct aml_value *,
d1729 1
a1729 1
struct aml_scope *aml_xpopscope(struct aml_scope *);
d1732 1
a1732 1
struct aml_value *aml_xconvert(struct aml_value *, int, int);
d1734 2
a1735 2
int		aml_xmatchtest(int64_t, int64_t, int);
int		aml_xmatch(struct aml_value *, int, int, int, int, int);
d1737 4
a1740 4
int		aml_xcompare(struct aml_value *, struct aml_value *, int);
struct aml_value *aml_xconcat(struct aml_value *, struct aml_value *);
struct aml_value *aml_xconcatres(struct aml_value *, struct aml_value *);
struct aml_value *aml_xmid(struct aml_value *, int, int);
d1743 1
a1743 1
void		aml_xstore(struct aml_scope *, struct aml_value *, int64_t,
d1750 1
a1750 1
aml_xaddref(struct aml_value *val, const char *lbl)
d1763 1
a1763 1
aml_xdelref(struct aml_value **pv, const char *lbl)
d1787 1
a1787 1
aml_xfindscope(struct aml_scope *scope, int type, int endscope)
d1818 1
a1818 1
	scope = aml_xfindscope(scope, AMLOP_METHOD, 0);
d1865 1
a1865 1
aml_xpushscope(struct aml_scope *parent, struct aml_value *range,
d1899 1
a1899 1
aml_xpopscope(struct aml_scope *scope)
d1928 1
a1928 1
aml_xmatchtest(int64_t a, int64_t b, int op)
d1949 1
a1949 1
aml_xmatch(struct aml_value *pkg, int index,
d1958 1
a1958 1
		tmp = aml_xconvert(pkg->v_package[index],
d1962 3
a1964 3
		flag = aml_xmatchtest(tmp->v_integer, v1, op1) &&
		    aml_xmatchtest(tmp->v_integer, v2, op2);
		aml_xdelref(&tmp, "xmatch");
d1998 1
a1998 1
aml_xconvert(struct aml_value *a, int ctype, int clen)
d2006 1
a2006 1
		aml_xaddref(a, "XConvert");
d2055 1
a2055 1
			aml_xaddref(a, "XConvert");
d2070 1
a2070 1
aml_xcompare(struct aml_value *a1, struct aml_value *a2, int opcode)
d2075 1
a2075 1
	a2 = aml_xconvert(a2, a1->type, -1);
d2090 1
a2090 1
	aml_xdelref(&a2, "xcompare");
d2096 1
a2096 1
aml_xconcat(struct aml_value *a1, struct aml_value *a2)
d2101 1
a2101 1
	a2 = aml_xconvert(a2, a1->type, -1);
d2126 1
a2126 1
	aml_xdelref(&a2, "xconcat");
d2142 1
a2142 1
aml_xconcatres(struct aml_value *a1, struct aml_value *a2)
d2166 1
a2166 1
aml_xmid(struct aml_value *src, int index, int length)
d2178 1
a2178 1
void aml_xcreatefield(struct aml_value *, int, struct aml_value *, int, int,
d2180 1
a2180 1
void aml_xparsefieldlist(struct aml_scope *, int, int,
d2273 1
a2273 1
			val = aml_xconvert(val, AML_OBJTYPE_BUFFER, -1);
d2283 1
a2283 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER, -1);
d2306 1
a2306 1
		aml_xdelref(&val, "fld.write");
d2323 1
a2323 1
	aml_xaddref(&tmp, "fld.write");
d2340 1
a2340 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER, -1);
d2342 1
a2342 1
		aml_xdelref(&val, "wrbuffld");
d2360 1
a2360 1
aml_xcreatefield(struct aml_value *field, int opcode,
d2388 1
a2388 1
		data = aml_xconvert(data, AML_OBJTYPE_BUFFER, -1);
d2399 2
a2400 2
	aml_xaddref(data, "Field.Data");
	aml_xaddref(index, "Field.Index");
d2405 1
a2405 1
aml_xparsefieldlist(struct aml_scope *mscope, int opcode, int flags,
d2428 1
a2428 1
			aml_xcreatefield(rv, opcode, data, bpos, blen, index,
d2430 1
a2430 1
			aml_xdelref(&rv, 0);
d2435 1
a2435 1
	aml_xpopscope(mscope);
d2522 1
a2522 1
aml_xstore(struct aml_scope *scope, struct aml_value *lhs , int64_t ival,
d2558 1
a2558 1
		rhs = aml_xconvert(rhs, lhs->type, -1);
d2560 1
a2560 1
		aml_xdelref(&rhs, "store.int");
d2564 1
a2564 1
		rhs = aml_xconvert(rhs, lhs->type, -1);
d2573 1
a2573 1
		aml_xdelref(&rhs, "store.bufstr");
d2638 1
a2638 1
			aml_xdelref(&rv, "disasm");
d2651 1
a2651 1
		aml_xdelref(&rv, "");
d2869 1
a2869 1
			aml_xparsesimple(scope, c, &tmp);
d2878 1
a2878 1
			rv = aml_xparsesimple(scope, c, NULL);
d2890 1
a2890 1
			aml_xdelref(&rv, 0);
d2906 1
a2906 1
			ms = aml_xpushscope(scope, &tmp, scope->node, 0);
d2919 1
a2919 1
					aml_xdelref(&rv, 0);
d2922 1
a2922 1
			aml_xpopscope(ms);
d2936 1
a2936 1
			ms = aml_xpushscope(scope, &tmp, scope->node, 0);
d2941 1
a2941 1
			aml_xpopscope(ms);
d2963 1
a2963 1
aml_xeval(struct aml_scope *scope, struct aml_value *my_ret, int ret_type,
d2980 1
a2980 1
		ms = aml_xpushscope(scope, tmp, tmp->node, AMLOP_METHOD);
d2991 1
a2991 1
				sp->v_objref.ref = aml_xparse(scope, 't', "ARGX");
d3003 1
a3003 1
			aml_xparse(ms, 'T', "METHEVAL");
d3012 1
a3012 1
		aml_xpopscope(ms);
d3141 1
a3141 1
aml_xparsesimple(struct aml_scope *scope, char ch, struct aml_value *rv)
d3253 1
a3253 1
	return aml_xpushscope(scope, &tmp, scope->node,
d3262 1
a3262 1
aml_xparse(struct aml_scope *scope, int ret_type, const char *stype)
d3325 1
a3325 1
				rv = aml_xparse(scope, *ch, htab->mnem);
d3360 1
a3360 1
			rv = aml_xparsesimple(scope, *ch, NULL);
d3398 1
a3398 1
		aml_xaddref(my_ret, htab->mnem);
d3415 1
a3415 1
			aml_xaddref(my_ret, "de-alias");
d3419 1
a3419 1
			my_ret = aml_xeval(scope, my_ret, ret_type, 0, NULL);
d3423 1
a3423 1
			aml_xaddref(my_ret, "zoom");
d3452 1
a3452 1
		mscope = aml_xpushscope(scope, opargs[1], scope->node,
d3457 1
a3457 1
			rv = aml_xparse(mscope, 'o', "Package");
d3459 1
a3459 1
				aml_xdelref(&my_ret->v_package[idx], "pkginit");
d3463 1
a3463 1
		aml_xpopscope(mscope);
d3482 1
a3482 1
		aml_xstore(scope, opargs[2], ival, NULL);
d3492 1
a3492 1
		aml_xstore(scope, opargs[2], ival, NULL);
d3496 1
a3496 1
		aml_xstore(scope, opargs[3], ival, NULL);
d3505 1
a3505 1
		aml_xstore(scope, opargs[1], ival, NULL);
d3510 1
a3510 1
		my_ret = aml_xeval(scope, opargs[0], AML_ARG_INTEGER, 0, NULL);
d3512 1
a3512 1
		aml_xstore(scope, opargs[0], ival, NULL);
d3531 1
a3531 1
		ival = aml_xcompare(opargs[0], opargs[1], opcode);
d3542 2
a3543 2
			aml_xaddref(opargs[0], "CondRef");
			aml_xstore(scope, opargs[1], 0, opargs[2]);
d3552 1
a3552 1
		aml_xaddref(my_ret->v_objref.ref, "RefOf");
d3569 1
a3569 1
				aml_xaddref(my_ret, "Index.Package");
d3573 1
a3573 1
				aml_xaddref(my_ret->v_objref.ref,
d3580 1
a3580 1
			rv = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER, -1);
d3588 1
a3588 1
				aml_xcreatefield(my_ret, AMLOP_INDEX, rv,
d3591 1
a3591 1
			aml_xdelref(&rv, "Index.BufStr");
d3597 1
a3597 1
		aml_xstore(scope, opargs[2], ival, my_ret);
d3603 1
a3603 1
			aml_xaddref(my_ret, "DerefOf");
d3606 1
a3606 1
			//aml_xaddref(my_ret, "DerefOf");
d3618 1
a3618 1
		aml_xstore(scope, opargs[1], 0, opargs[0]);
d3624 2
a3625 2
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_INTEGER, -1);
		aml_xstore(scope, opargs[1], 0, my_ret);
d3629 2
a3630 2
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER, -1);
		aml_xstore(scope, opargs[1], 0, my_ret);
d3634 2
a3635 2
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_HEXSTRING, -1);
		aml_xstore(scope, opargs[1], 0, my_ret);
d3639 2
a3640 2
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_DECSTRING, -1);
		aml_xstore(scope, opargs[1], 0, my_ret);
d3644 1
a3644 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING,
d3646 1
a3646 1
		aml_xstore(scope, opargs[2], 0, my_ret);
d3650 2
a3651 2
		my_ret = aml_xconcat(opargs[0], opargs[1]);
		aml_xstore(scope, opargs[2], 0, my_ret);
d3655 2
a3656 2
		my_ret = aml_xconcatres(opargs[0], opargs[1]);
		aml_xstore(scope, opargs[2], 0, my_ret);
d3660 1
a3660 1
		my_ret = aml_xmid(opargs[0], opargs[1]->v_integer,
d3662 1
a3662 1
		aml_xstore(scope, opargs[3], 0, my_ret);
d3666 1
a3666 1
		ival = aml_xmatch(opargs[0], opargs[5]->v_integer,
d3721 1
a3721 1
		aml_xaddref(rv->v_objref.ref, "Alias");
d3756 1
a3756 1
		mscope = aml_xpushscope(scope, opargs[1], rv->node, opcode);
d3761 1
a3761 1
		mscope = aml_xpushscope(scope, opargs[1], rv->node, opcode);
d3766 1
a3766 1
		mscope = aml_xpushscope(scope, opargs[1], rv->node, opcode);
d3773 1
a3773 1
		mscope = aml_xpushscope(scope, opargs[3], rv->node, opcode);
d3781 1
a3781 1
		mscope = aml_xpushscope(scope, opargs[4], rv->node, opcode);
d3796 1
a3796 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer,
d3802 1
a3802 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer,
d3808 1
a3808 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
d3814 1
a3814 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
d3820 1
a3820 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
d3826 1
a3826 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8,
d3831 2
a3832 2
		mscope = aml_xpushscope(scope, opargs[2], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[1]->v_integer,
d3838 2
a3839 2
		mscope = aml_xpushscope(scope, opargs[3], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[2]->v_integer,
d3845 2
a3846 2
		mscope = aml_xpushscope(scope, opargs[4], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[3]->v_integer,
d3897 1
a3897 1
			mscope = aml_xpushscope(scope, opargs[1], scope->node,
d3901 1
a3901 1
			mscope = aml_xpushscope(scope, opargs[3], scope->node,
d3909 1
a3909 1
			mscope = aml_xpushscope(scope, opargs[1], scope->node,
d3915 1
a3915 1
		aml_xfindscope(scope, AMLOP_WHILE, AMLOP_BREAK);
d3919 1
a3919 1
		aml_xfindscope(scope, AMLOP_WHILE, AMLOP_CONTINUE);
d3922 1
a3922 1
		mscope = aml_xfindscope(scope, AMLOP_METHOD, AMLOP_RETURN);
d3947 1
a3947 1
		my_ret = aml_xconvert(my_ret, AML_OBJTYPE_INTEGER, -1);
d3960 1
a3960 1
		aml_xdelref(&opargs[idx], "oparg");
d3965 1
a3965 1
		aml_xdelref(&my_ret, "scope.loop");
d3968 1
a3968 1
			scope = aml_xpopscope(scope);
d3995 1
a3995 1
	scope = aml_xpushscope(NULL, &res, &aml_root, AMLOP_SCOPE);
d3997 1
a3997 1
	aml_xparse(scope, 'T', "TopLevel");
d3999 1
a3999 1
	aml_xpopscope(scope);
d4027 1
a4027 1
	xres = aml_xeval(NULL, node->value, 't', argc, argv);
d4032 1
a4032 1
			aml_xdelref(&xres, "evalnode");
@


1.181
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.180 2010/10/31 21:52:46 guenther Exp $ */
d1170 1
a1170 1
		res = (lhs && rhs);
d1173 1
a1173 1
		res = (lhs || rhs);
d1176 1
a1176 1
		res = (!lhs);
d1179 1
a1179 1
		res = (lhs != rhs);
d1182 1
a1182 1
		res = (lhs <= rhs);
d1185 1
a1185 1
		res = (lhs >= rhs);
d1188 1
a1188 1
		res = (lhs == rhs);
d1191 1
a1191 1
		res = (lhs > rhs);
d1194 1
a1194 1
		res = (lhs < rhs);
@


1.180
log
@Revert last commit: it breaks resume on Thinkpads
"then please back it out" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.178 2010/08/05 15:46:20 deraadt Exp $ */
d107 3
d521 1
d528 1
a528 1
	acpi_softc->sc_poll = 1;
d535 12
a575 2
	struct aml_notify_data	*pdata = NULL;

d579 2
a580 3
	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (pdata->node == node)
			pdata->cbproc(pdata->node, notify_value, pdata->cbarg);
d598 1
a598 1
acpi_poll_notify(void)
d2488 8
@


1.179
log
@Add task queue for ACPI gpe and notify handlers
This fixes eject on Dell Latitude dock and an issue on the Dell Mini
battery update.
ok deraadt
@
text
@a106 2
void aml_notify_task(void *, int);

a532 11
aml_notify_task(void *node, int notify_value)
{
	struct aml_notify_data	*pdata = NULL;

	dnprintf(10,"run notify: %s %x\n", aml_nodename(node), notify_value);
	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (pdata->node == node)
			pdata->cbproc(pdata->node, notify_value, pdata->cbarg);
}

void
d560 2
d565 3
a567 2
	dnprintf(10,"queue notify: %s %x\n", aml_nodename(node), notify_value);
	acpi_addtask(acpi_softc, aml_notify_task, node, notify_value);
a2474 8
	/* Wait for event to occur; do work in meantime */
	evt->v_evt.state = 0;
	while (!evt->v_evt.state) {
		if (!acpi_dotask(acpi_softc) && !cold)
			tsleep(evt, PWAIT, "acpievt", 1);
		else
			delay(100);
	}
@


1.178
log
@Add Windows2009 to the valid osi table; from marco, suggested as a trial
by kettenis a while back, lots of you have been running this.
If you have new problems try without this and report.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.177 2010/08/04 18:11:55 jordan Exp $ */
d107 2
d535 11
a572 2
	struct aml_notify_data	*pdata = NULL;

d576 2
a577 3
	SLIST_FOREACH(pdata, &aml_notify_list, link)
		if (pdata->node == node)
			pdata->cbproc(pdata->node, notify_value, pdata->cbarg);
d2485 8
@


1.177
log
@Remove unused code, conditional in fixup node was never true
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.176 2010/07/28 16:00:29 deraadt Exp $ */
d1474 1
@


1.176
log
@remove stub code for rw locks we will never need; ok kettenis marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.175 2010/07/27 23:36:35 deraadt Exp $ */
a1409 27
u_int64_t
aml_getpciaddr(struct acpi_softc *sc, struct aml_node *root)
{
	int64_t tmpres;
	u_int64_t pciaddr;

	/* PCI */
	pciaddr = 0;
	if (!aml_evalinteger(acpi_softc, root, "_ADR", 0, NULL, &tmpres)) {
		/* Device:Function are bits 16-31,32-47 */
		pciaddr += (tmpres << 16L);
		dnprintf(20, "got _adr [%s]\n", aml_nodename(root));
	} else {
		/* Mark invalid */
		pciaddr += (0xFFFF << 16L);
		return pciaddr;
	}

	if (!aml_evalinteger(acpi_softc, root, "_BBN", 0, NULL, &tmpres)) {
		/* PCI bus is in bits 48-63 */
		pciaddr += (tmpres << 48L);
		dnprintf(20, "got _bbn [%s]\n", aml_nodename(root));
	}
	dnprintf(20, "got pciaddr: %s:%llx\n", aml_nodename(root), pciaddr);
	return pciaddr;
}

a1660 10
	} else if (val->type == AML_OBJTYPE_OPREGION) {
		if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE)
			return (0);
		if (ACPI_PCI_FN(val->v_opregion.iobase) != 0xFFFF)
			return (0);
		val->v_opregion.iobase =
		    ACPI_PCI_REG(val->v_opregion.iobase) +
		    aml_getpciaddr(acpi_softc, node);
		dnprintf(20, "late ioaddr : %s:%llx\n",
		    aml_nodename(node), val->v_opregion.iobase);
@


1.175
log
@remove an ancient XXX
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.174 2010/07/27 02:00:36 krw Exp $ */
a611 1
	//rw_enter_read(&aml_nslock);
d613 1
a613 2
		if (!strncmp(node->name, nameseg, AML_NAMESEG_LEN)) {
			//rw_exit_read(&aml_nslock);
a614 1
		}
a615 1
	//rw_exit_read(&aml_nslock);
a624 3

		//rw_enter_write(&aml_nslock);
		//rw_exit_write(&aml_nslock);
@


1.174
log
@Fix #ifdef DDB/#ifdef SMALL_KERNEL uses so all four combinations
(DDB/SMALL_KERNEL, DDB/!SMALL_KERNEL, !DDB/!SMALL_KERNEL,
!DDB/SMALL_KERNEL) can compile. A DDB bsd.rd is thus possible again.

Correction to my original diff from miod@@

"If it compiles, commit" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.173 2010/07/23 18:38:46 jordan Exp $ */
a1745 3
/*
 * XXX: NEW PARSER CODE GOES HERE
 */
@


1.173
log
@Fix searchname to handle short name segments, remove hack in acpidock.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.172 2010/07/22 14:19:47 deraadt Exp $ */
d331 1
a331 1
#ifndef SMALL_KERNEL
d366 1
a366 1
#endif /* SMALL_KERNEL */
d2615 1
a2615 1
#ifndef SMALL_KERNEL
d2982 1
a2982 1
#endif /* SMALL_KERNEL */
@


1.172
log
@pretty large cleanup of SMALL_KERNEL
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.171 2010/07/21 19:35:15 deraadt Exp $ */
d4104 2
d4113 7
a4119 2
		root = __aml_search(root, name, 0);
		name += (name[4] == '.') ? 5 : 4;
@


1.171
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.170 2010/07/21 15:07:40 deraadt Exp $ */
d397 1
d399 2
a400 2
LIST_HEAD(, acpi_memblock) acpi_memhead;
#endif
d402 15
a416 1
int acpi_memsig;
a455 17
int
acpi_walkmem(int sig, const char *lbl)
{
#ifdef ACPI_MEMDEBUG
	struct acpi_memblock *sptr;

	printf("--- walkmem:%s %x --- %x bytes alloced\n", lbl, sig, acpi_nalloc);
	LIST_FOREACH(sptr, &acpi_memhead, link) {
		if (sptr->sig < sig)
			break;
		printf("%.4x Alloc %.8lx bytes @@ %s:%d\n",
			sptr->sig, sptr->size, sptr->fn, sptr->line);
	}
#endif
	return acpi_memsig;
}

d570 1
d593 1
a1416 2
int amlop_delay;

d1715 1
d1744 1
a1778 14
int
valid_acpihdr(void *buf, int len, const char *sig)
{
	struct acpi_table_header *hdr = buf;

	if (sig && strncmp(hdr->signature, sig, 4))
		return (0);
	if (len < hdr->length)
		return (0);
	if (acpi_checksum(hdr, hdr->length) != 0)
		return (0);
	return (1);
}

d4135 4
a4138 1
void acpi_getdevlist(struct acpi_devlist_head *list, struct aml_node *root,
d4167 1
@


1.170
log
@clean up a pile of prototypes and shred some macros which were just covering
for ones everyone knows better
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.169 2010/07/20 12:14:10 deraadt Exp $ */
d50 5
a54 5
struct acpi_q 		*acpi_maptable(struct acpi_softc *sc, paddr_t,
			    const char *, const char *, 
    			    const char *, int);
struct aml_scope 	*aml_load(struct acpi_softc *, struct aml_scope *,
    			    struct aml_value *, struct aml_value *);
a273 1

d314 2
a315 1
	aml_ophash = (struct aml_opcode **)acpi_os_malloc(HASH_SIZE*sizeof(struct aml_opcode *));
d432 1
a432 1
#ifdef ACPI_MEMDEBUG	
d726 1
a726 1
#define acpi_acquire_global_lock(x) 1 
d1325 1
a1325 1
			node = __aml_search(node, pos+2+i*AML_NAMESEG_LEN, 
d1355 1
a1355 1
		dnprintf(10, "parsename: %s %x\n", aml_nodename(node), 
d1360 1
a1360 1
		dnprintf(10, "%s:%s not found\n", aml_nodename(inode), 
d1485 1
a1485 1
	
d1747 1
a1747 1
 * XXX: NEW PARSER CODE GOES HERE 
d1754 1
a1754 1
struct aml_value *aml_xparsesimple(struct aml_scope *, char, 
d1760 1
a1760 1
struct aml_scope *aml_xpushscope(struct aml_scope *, struct aml_value *, 
d1776 1
a1776 1
void		aml_xstore(struct aml_scope *, struct aml_value *, int64_t, 
d1790 1
a1790 1
	return (1); 
d1801 1
a1801 1
	dnprintf(50, "XAddRef: %p %s:[%s] %d\n", 
d1819 1
a1819 1
		dnprintf(50, "XDelRef: %p %s %2d [%s] %s\n", 
d1836 1
a1836 1
	while (scope) { 
d1862 1
a1862 1
  	struct aml_value *sp;
d1874 1
a1874 1
	  	if (scope->args == NULL)
d1885 1
a1885 1
void 
d1891 1
a1891 1
	dnprintf(10, "===== Stack %s:%s\n", aml_nodename(scope->node), 
d2005 1
a2005 1
		tmp = aml_xconvert(pkg->v_package[index], 
d2009 1
a2009 1
		flag = aml_xmatchtest(tmp->v_integer, v1, op1) && 
d2061 1
a2061 1
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length, 
d2065 1
a2065 1
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length, 
d2075 1
a2075 1
			memcpy(&c->v_integer, a->v_buffer, 
d2094 1
a2094 1
			snprintf(c->v_string, c->length, (ctype == AML_OBJTYPE_HEXSTRING) ? 
d2127 1
a2127 1
		rc = memcmp(a1->v_buffer, a2->v_buffer, 
d2151 1
a2151 1
		c = aml_allocvalue(AML_OBJTYPE_BUFFER, 
d2157 1
a2157 1
		c = aml_allocvalue(AML_OBJTYPE_BUFFER, 
d2163 1
a2163 1
		c = aml_allocvalue(AML_OBJTYPE_STRING, 
d2182 1
a2182 1
	
d2195 1
a2195 1
	if (a1->type != AML_OBJTYPE_BUFFER || a2->type != AML_OBJTYPE_BUFFER) 
d2220 1
a2220 1
}		
d2223 1
a2223 1
 * Field I/O utility functions 
d2239 1
a2239 1
	if (val->type == AML_OBJTYPE_INTEGER) 
d2307 1
a2307 1
	
d2411 1
a2411 1
	dnprintf(10, "## %s(%s): %s %.4x-%.4x\n", 
d2416 1
a2416 1
		dnprintf(10, "  index:%s:%.2x\n", aml_nodename(index->node), 
d2420 2
a2421 2
	field->type = (opcode == AMLOP_FIELD || 
	    opcode == AMLOP_INDEXFIELD || 
d2423 1
a2423 1
	    AML_OBJTYPE_FIELDUNIT : 
d2430 2
a2431 2
	if (field->type == AML_OBJTYPE_BUFFERFIELD && 
	    data->type != AML_OBJTYPE_BUFFER) 
d2452 1
a2452 1
aml_xparsefieldlist(struct aml_scope *mscope, int opcode, int flags, 
d2475 1
a2475 1
			aml_xcreatefield(rv, opcode, data, bpos, blen, index, 
d2486 1
a2486 1
 * Mutex/Event utility functions 
d2495 1
a2495 1
acpi_xmutex_acquire(struct aml_scope *scope, struct aml_value *mtx, 
d2523 1
a2523 1
	  	dnprintf(10,"UNLOCKING GLOBAL\n");
d2561 1
a2561 1
aml_xstore(struct aml_scope *scope, struct aml_value *lhs , int64_t ival, 
d2576 1
a2576 1
	if (rhs->type == AML_OBJTYPE_BUFFERFIELD || 
d2644 2
a2645 2
aml_disasm(struct aml_scope *scope, int lvl, 
    void (*dbprintf)(void *, const char *, ...), 
d2685 1
a2685 1
				strlcat(mch, ival ? ", %z" : "%z", 
d2733 1
a2733 1
	  	ch="%a";
d2914 1
a2914 1
			break;			
d2927 1
a2927 1
			scope->pos = aml_parsename(scope->node, scope->pos, 
d2953 1
a2953 1
					ms->pos = aml_parsename(ms->node, 
d2956 1
a2956 1
					dbprintf(arg,"	%s\n", 
d2977 1
a2977 1
				aml_disasm(ms, (lvl + 1) & 0x7FFF, 
d3015 2
a3016 2
		dnprintf(10,"\n--== Eval Method [%s, %d args] to %c ==--\n", 
		    aml_nodename(tmp->node), 
d3020 1
a3020 1
		
d3036 1
a3036 1
		
d3045 1
a3045 1
		dnprintf(10,"\n--==Finished evaluating method: %s %c\n", 
d3056 1
a3056 1
		dnprintf(20,"quick: Convert Bufferfield to %c 0x%x\n", 
d3192 1
a3192 1
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
d3197 1
a3197 1
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
d3202 1
a3202 1
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
d3207 1
a3207 1
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
d3220 1
a3220 1
 * Main Opcode Parser/Evaluator 
d3346 1
a3346 1
		case AML_ARG_IFELSE: 
d3348 1
a3348 1
			ch = (*end == AMLOP_ELSE && end < scope->end) ? 
d3354 2
a3355 2
		case 'S': 
		case AML_ARG_TARGET: 
d3381 1
a3381 1
			rv = aml_allocvalue(AML_OBJTYPE_INTEGER, 
d3445 1
a3445 1
				my_ret = aml_allocvalue(AML_OBJTYPE_STRING, -1, 
d3448 1
a3448 1
				my_ret = aml_allocvalue(AML_OBJTYPE_STRING, -1, 
d3481 1
a3481 1
		my_ret = aml_allocvalue(AML_OBJTYPE_BUFFER, 
d3483 1
a3483 1
		memcpy(my_ret->v_buffer, opargs[1]->v_buffer, 
d3489 1
a3489 1
		my_ret = aml_allocvalue(AML_OBJTYPE_PACKAGE, 
d3491 1
a3491 1
		mscope = aml_xpushscope(scope, opargs[1], scope->node, 
d3519 1
a3519 1
		ival = aml_evalexpr(opargs[0]->v_integer, 
d3526 1
a3526 1
			my_ret = aml_seterror(scope, "Divide by Zero!");		
d3529 1
a3529 1
		ival = aml_evalexpr(opargs[0]->v_integer, 
d3533 1
a3533 1
		ival = aml_evalexpr(opargs[0]->v_integer, 
d3560 1
a3560 1
		ival = aml_evalexpr(opargs[0]->v_integer, 
d3600 1
a3600 1
			aml_die("Index out of bounds %d/%d\n", idx, 
d3612 1
a3612 1
				aml_xaddref(my_ret->v_objref.ref, 
d3621 1
a3621 1
				dnprintf(12,"Index.Buf Term: %d = %x\n", 
d3627 1
a3627 1
				aml_xcreatefield(my_ret, AMLOP_INDEX, rv, 
d3683 1
a3683 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING, 
d3699 1
a3699 1
		my_ret = aml_xmid(opargs[0], opargs[1]->v_integer, 
d3841 2
a3842 2
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer,    
		    1, NULL, 0, 0);	
d3847 1
a3847 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8,  
d3853 1
a3853 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8, 
d3859 1
a3859 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8, 
d3865 1
a3865 1
		aml_xcreatefield(rv, opcode, opargs[0], opargs[1]->v_integer*8, 
d3871 1
a3871 1
		aml_xparsefieldlist(mscope, opcode, opargs[1]->v_integer, 
d3878 1
a3878 1
		aml_xparsefieldlist(mscope, opcode, opargs[2]->v_integer, 
d3885 1
a3885 1
		aml_xparsefieldlist(mscope, opcode, opargs[3]->v_integer, 
d3902 2
a3903 2
		dnprintf(50,"Notifying: %s %x\n", 
		    aml_nodename(rv->node), 
d3914 1
a3914 1
		    opargs[0]->v_integer, opargs[1]->v_integer, 
d3918 1
a3918 1
		/* LoadTable(Sig:Str, OEMID:Str, OEMTable:Str, [RootPath:Str], [ParmPath:Str], 
d3984 1
a3984 1
		dnprintf(10,"quick: %.4x convert to integer %s -> %s\n", 
d3990 1
a3990 1
		dnprintf(20,"quick: %.4x %18s %c %.4x\n", pc, stype, 
d4014 1
a4014 1
	dnprintf(50, ">>return [%s] %s %c %p\n", aml_nodename(scope->node), 
d4031 1
a4031 1
	
d4058 1
a4058 1
	
d4112 1
a4112 1
 * Search for an AML name in namespace.. root only 
@


1.169
log
@Handle the acpi interrupt controller with proper edge/level handling,
wrapped in spltty to avoid racing against the interrupt controller.
Repair the gpe bit masking code while there, and do operations in the
right order
ok kettenis mlarkin, help from jordan at figuring out the order of
operations.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.166 2010/07/13 21:01:05 deraadt Exp $ */
d50 2
a51 1
struct acpi_q 		*acpi_maptable(struct acpi_softc *sc, paddr_t, const char *, const char *, 
d73 2
a74 2
void		aml_xaddref(struct aml_value *, const char *);
void		aml_xdelref(struct aml_value **, const char *);
d585 2
a586 1
void acpi_poll_notify(void)
d1570 1
a1570 1
		    aml_letohost32(crs->lr_extirq.irq[0]));
d1573 1
a1573 1
		printf("irq\t%.4x %.2x\n", aml_letohost16(crs->sr_irq.irq_mask),
@


1.168
log
@tsleep() and EWOULDBLOCK was being used incorrectly for fixed minumum
delays.  tsleep() on an unknown wait channel, to ensure the minimum is
met, and that wakeup()'s don't make the delay get restarted over and
over..
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.167 2010/07/19 16:57:27 deraadt Exp $ */
d522 3
d528 1
d750 1
a750 1
	int st, x;
d765 1
d769 1
@


1.167
log
@there is no need for a seperate dsdt_softc pointer; dsdt does not have a
softc but is just a part of the single acpi driver.
ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.166 2010/07/13 21:01:05 deraadt Exp $ */
a95 1
void			acpi_sleep(int);
d458 1
a458 1
acpi_sleep(int ms)
d460 1
d468 1
a468 2
		while (tsleep(acpi_softc, PWAIT, "asleep", to) !=
		    EWOULDBLOCK);
d3889 1
a3889 1
		acpi_sleep(opargs[0]->v_integer);
@


1.166
log
@rename some thread related interfaces so they are logical
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.165 2010/07/08 20:56:31 jordan Exp $ */
a112 1
struct acpi_softc	*dsdt_softc;
d468 1
a468 1
		while (tsleep(dsdt_softc, PWAIT, "asleep", to) !=
d523 3
a525 3
	dsdt_softc->sc_poll = 1;
	dsdt_softc->sc_threadwaiting = 0;
	wakeup(dsdt_softc);
d527 1
a527 1
	timeout_add_sec(&dsdt_softc->sc_dev_timeout, 10);
d552 1
a552 1
		timeout_add_sec(&dsdt_softc->sc_dev_timeout, 10);
d737 1
a737 1
		st = acpi_acquire_global_lock(&dsdt_softc->sc_facs->global_lock);
d757 1
a757 1
	st = acpi_release_global_lock(&dsdt_softc->sc_facs->global_lock);
d762 1
a762 1
	x = acpi_read_pmreg(dsdt_softc, ACPIREG_PM1_CNT, 0);
d764 1
a764 1
	acpi_write_pmreg(dsdt_softc, ACPIREG_PM1_CNT, 0, x);
d1420 1
a1420 1
	if (!aml_evalinteger(dsdt_softc, root, "_ADR", 0, NULL, &tmpres)) {
d1430 1
a1430 1
	if (!aml_evalinteger(dsdt_softc, root, "_BBN", 0, NULL, &tmpres)) {
d1697 1
a1697 1
		    aml_getpciaddr(dsdt_softc, node);
d1930 1
a1930 1
	scope->sc = dsdt_softc;
d2228 1
a2228 1
	if (aml_evalname(dsdt_softc, node, "_HID", 0, NULL, val))
d2246 1
a2246 1
	if (aml_evalinteger(dsdt_softc, pcidev, "_ADR", 0, NULL, &res) == 0) {
d2253 1
a2253 1
			if (aml_evalinteger(dsdt_softc, pcidev, "_BBN", 0, NULL, &res) == 0) {
d2328 1
a2328 1
		acpi_gasio(dsdt_softc, ACPI_IOREAD, type, pi.addr, sz, slen, tbit);
d2338 1
a2338 1
			acpi_gasio(dsdt_softc, ACPI_IOREAD, type, pi.addr, sz, slen, tbit);
d2344 1
a2344 1
		acpi_gasio(dsdt_softc, ACPI_IOWRITE, type, pi.addr, sz, slen, tbit);
d2498 1
a2498 1
			err = acpi_acquire_global_lock(&dsdt_softc->sc_facs->global_lock);
d2517 1
a2517 1
		err=acpi_release_global_lock(&dsdt_softc->sc_facs->global_lock);
d3917 1
a3917 1
		mscope = aml_load(dsdt_softc, scope, opargs[0], opargs[1]);
a4017 2

	dsdt_softc = sc;
@


1.165
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.163 2010/07/01 01:39:39 jordan Exp $ */
d525 1
a525 1
	dsdt_softc->sc_wakeup = 0;
@


1.164
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.159 2010/06/27 07:26:31 jordan Exp $ */
a98 6
uint8_t *aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg);
void ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg);

d603 1
a603 1
	struct aml_node **sp, *node;
d609 2
a610 2
	for (sp = &root->child; *sp; sp = &(*sp)->sibling) {
		if (!strncmp((*sp)->name, nameseg, AML_NAMESEG_LEN)) {
d612 1
a612 1
			return *sp;
d622 3
a624 1
		node->sibling = NULL;
a626 1
		*sp = node;
d629 1
a629 1
	return *sp;
d692 2
a693 2
	while ((onode = node->child) != NULL) {
		node->child = onode->sibling;
d1231 3
a1233 2
		nodecb(node, arg);
	for (child = node->child; child; child = child->sibling)
d1255 2
a1256 2
			aml_find_node(node->child, name, cbproc, arg);
		node = node->sibling;
d1264 1
a1264 1
uint8_t *aml_parsename(struct aml_scope *);
d1298 1
a1298 1
aml_parsename(struct aml_scope *scope)
d1300 3
a1302 1
	uint8_t *name = scope->pos;
d1304 10
a1313 4
	while (*scope->pos == AMLOP_ROOTCHAR || *scope->pos == AMLOP_PARENTPREFIX)
		scope->pos++;

	switch (*scope->pos) {
d1315 1
d1318 4
a1321 1
		scope->pos += 2+AML_NAMESEG_LEN*scope->pos[1];
d1324 3
a1326 1
		scope->pos += 1+AML_NAMESEG_LEN*2;
d1329 7
a1335 1
		scope->pos += AML_NAMESEG_LEN;
d1338 21
a1358 1
	return name;
d1537 1
d1544 1
a1544 2
		aml_xparsename((uint8_t *)def->name, &aml_root,
		    ns_xcreate, &tmp);
d1550 1
d1631 1
a1631 1
aml_parse_resource(int length, uint8_t *buffer,
d1637 4
a1640 2
	for (off = 0; off < length; off += rlen) {
		crs = (union acpi_resource *)(buffer+off);
d1643 1
a1643 1
		if (crs->hdr.typecode == 0x79 || rlen <= 3)
a2014 86
 * Namespace functions
 */

/* Search for name in namespace */
void
ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	struct aml_value **rv = arg;
	struct aml_node *rnode;

	/* If name search is relative, check up parent nodes */
	for (rnode=node; n == 1 && rnode; rnode=rnode->parent) {
		if (__aml_search(rnode, pos, 0) != NULL)
			break;
	}
	while (n--) {
		rnode = __aml_search(rnode, pos, 0);
		pos += 4;
	}
	if (rnode != NULL) {
		*rv = rnode->value;
		return;
	}
	*rv = NULL;
}

/* Create name in namespace */
void
ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	struct aml_value **rv = arg;

	while (n--) {
		node = __aml_search(node, pos, 1);
		pos += 4;
	}
	*rv = node->value;
}

void
ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	printf(aml_nodename(node));
	while (n--) {
		printf("%s%c%c%c%c", n ? "." : "", 
		    pos[0], pos[1], pos[2], pos[3]);
		pos+=4;
	}
}

uint8_t *
aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg)
{
	uint8_t *rpos = pos;
	struct aml_value **rv = arg;

	if (*pos == AMLOP_ROOTCHAR) {
		node = &aml_root;
		pos++;
	}
	while (*pos == AMLOP_PARENTPREFIX) {
		node = node ? node->parent : &aml_root;
		pos++;
	}
	if (*pos == 0) {
		fn(node, 0, pos, arg);
		pos++;
	} else if (*pos == AMLOP_MULTINAMEPREFIX) {
		fn(node, pos[1], pos+2, arg);
		pos += 2 + 4 * pos[1];
	} else if (*pos == AMLOP_DUALNAMEPREFIX) {
		fn(node, 2, pos+1, arg);
		pos += 9;
	} else if (*pos == '_' || (*pos >= 'A' && *pos <= 'Z')) {
		fn(node, 1, pos, arg);
		pos += 4;
	} else {
		printf("Invalid name!!!\n");
	}
	if (rv && *rv == NULL)
		*rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, rpos);
	return pos;
}

/*
d2193 2
a2194 2
	aml_parse_resource(a1->length, a1->v_buffer, aml_ccrlen, &l1);
	aml_parse_resource(a2->length, a2->v_buffer, aml_ccrlen, &l2);
d2466 2
a2467 2
			mscope->pos = aml_xparsename(mscope->pos, mscope->node,
			    ns_xcreate, &rv);
d2471 1
d2668 1
a2668 2
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
d2684 1
d2920 4
a2923 2
			scope->pos = aml_xparsename(scope->pos, scope->node, 
			    ns_xdis, &rv);
d2947 2
a2948 2
					ms->pos = aml_xparsename(ms->pos, 
					    ms->node, ns_xcreate, &rv);
d2952 1
a3175 10
	if (ch == AML_ARG_CREATENAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xcreate, &rv);
		return rv;
	}
	else if (ch == AML_ARG_SEARCHNAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
		return rv;
	}
d3379 2
a3380 6
			rv = aml_xparsesimple(scope, *ch, NULL);
			if (rv->type != 0 && opcode != AMLOP_SCOPE)
				dnprintf(10, "%s value already exists %s\n",
				    aml_nodename(rv->node),
				    htab->mnem);
			aml_xaddref(rv, "Create Name");
d3383 2
a3384 3
			rv = aml_xparsesimple(scope, *ch, NULL);
			if (rv->type != AML_OBJTYPE_NAMEREF)
				aml_xaddref(rv, "Search Name");
a3747 4
		if (!strcmp(rv->node->name, "_HID") && opargs[1]->type == AML_OBJTYPE_INTEGER) {
			/* Shortcut for _HID: autoconvert to string */
			_aml_setvalue(rv, AML_OBJTYPE_STRING, -1, aml_eisaid(opargs[1]->v_integer));
		} else {
a3748 1
		}
@


1.163
log
@Simplified aml_parse_resource call, cleanup code
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.162 2010/06/30 19:23:09 jordan Exp $ */
d99 6
d609 1
a609 1
	struct aml_node *node;
d615 2
a616 2
	SIMPLEQ_FOREACH(node, &root->son, sib) {
		if (!strncmp(node->name, nameseg, AML_NAMESEG_LEN)) {
d618 1
a618 1
			return node;
d628 1
a628 3

		SIMPLEQ_INIT(&node->son);
		SIMPLEQ_INSERT_TAIL(&root->son, node, sib);
d631 1
d634 1
a634 1
	return node;
d697 2
a698 2
	while ((onode = SIMPLEQ_FIRST(&node->son)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&node->son, sib);
d1236 2
a1237 3
		if (nodecb(node, arg))
			return;
	SIMPLEQ_FOREACH(child, &node->son, sib)
d1259 2
a1260 2
			aml_find_node(SIMPLEQ_FIRST(&node->son), name, cbproc, arg);
		node = SIMPLEQ_NEXT(node, sib);
d1268 1
a1268 1
uint8_t *aml_parsename(struct aml_node *, uint8_t *, struct aml_value **, int);
d1302 1
a1302 1
aml_parsename(struct aml_node *inode, uint8_t *pos, struct aml_value **rval, int create)
d1304 4
a1307 3
	struct aml_node *relnode, *node = inode;
	uint8_t	*start = pos;
	int i;
d1309 1
a1309 10
	if (*pos == AMLOP_ROOTCHAR) {
		pos++;
		node = &aml_root;
	}
	while (*pos == AMLOP_PARENTPREFIX) {
		pos++;
		if ((node = node->parent) == NULL)
			node = &aml_root;
	}
	switch (*pos) {
a1310 1
		pos++;
d1313 1
a1313 4
		for (i=0; i<pos[1]; i++)
			node = __aml_search(node, pos+2+i*AML_NAMESEG_LEN, 
			    create);
		pos += 2+i*AML_NAMESEG_LEN;
d1316 1
a1316 3
		node = __aml_search(node, pos+1, create);
		node = __aml_search(node, pos+1+AML_NAMESEG_LEN, create);
		pos += 1+2*AML_NAMESEG_LEN;
d1319 1
a1319 7
		/* If Relative Search (pos == start), recursively go up root */
		relnode = node;
		do {
			node = __aml_search(relnode, pos, create);
			relnode = relnode->parent;
		} while (!node && pos == start && relnode);
		pos += AML_NAMESEG_LEN;
d1322 1
a1322 21
	if (node) {
		*rval = node->value;

		/* Dereference ALIAS here */
		if ((*rval)->type == AML_OBJTYPE_OBJREF &&
		    (*rval)->v_objref.type == AMLOP_ALIAS) {
			dnprintf(10, "deref alias: %s\n", aml_nodename(node));
			*rval = (*rval)->v_objref.ref;
		}
		aml_xaddref(*rval, 0);

		dnprintf(10, "parsename: %s %x\n", aml_nodename(node), 
		    (*rval)->type);
	} else {
		*rval = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, start);

		dnprintf(10, "%s:%s not found\n", aml_nodename(inode), 
		    aml_getname(start));
	}

	return pos;
a1500 1
	SIMPLEQ_INIT(&aml_root.son);
d1507 2
a1508 1
		aml_parsename(&aml_root, (uint8_t *)def->name, &tmp, 1);
a1513 1
		aml_xdelref(&tmp, 0);
d1594 1
a1594 1
aml_parse_resource(struct aml_value *res,
d1600 2
a1601 4
	if (res->type != AML_OBJTYPE_BUFFER || res->length < 5)
		return (-1);
	for (off = 0; off < res->length; off += rlen) {
		crs = (union acpi_resource *)(res->v_buffer+off);
d1976 86
d2240 2
a2241 2
	aml_parse_resource(a1, aml_ccrlen, &l1);
	aml_parse_resource(a2, aml_ccrlen, &l2);
d2513 2
a2514 2
			mscope->pos = aml_parsename(mscope->node, mscope->pos,
			    &rv, 1);
a2517 1
			aml_xdelref(&rv, 0);
d2714 2
a2715 1
		scope->pos = aml_parsename(scope->node, scope->pos, &rv, 0);
a2730 1
		aml_xdelref(&rv, "");
d2966 2
a2967 4
			printf("%s", aml_getname(scope->pos));
			scope->pos = aml_parsename(scope->node, scope->pos, 
			    &rv, 0);
			aml_xdelref(&rv, 0);
d2991 2
a2992 2
					ms->pos = aml_parsename(ms->node, 
					     ms->pos, &rv, 1);
a2995 1
					aml_xdelref(&rv, 0);
d3219 10
d3432 6
a3437 2
			scope->pos = aml_parsename(scope->node, scope->pos,
			    &rv, 1);
d3440 3
a3442 2
			scope->pos = aml_parsename(scope->node, scope->pos,
			    &rv, 0);
@


1.162
log
@Cleaned up aml name parser, delete unused code
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.161 2010/06/29 22:08:29 jordan Exp $ */
d1631 1
a1631 1
aml_parse_resource(int length, uint8_t *buffer,
d1637 4
a1640 2
	for (off = 0; off < length; off += rlen) {
		crs = (union acpi_resource *)(buffer+off);
d2193 2
a2194 2
	aml_parse_resource(a1->length, a1->v_buffer, aml_ccrlen, &l1);
	aml_parse_resource(a2->length, a2->v_buffer, aml_ccrlen, &l2);
@


1.161
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.160 2010/06/27 21:04:22 jordan Exp $ */
a98 6
uint8_t *aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg);
void ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg);

d1264 1
a1264 1
uint8_t *aml_parsename(struct aml_scope *);
d1298 1
a1298 1
aml_parsename(struct aml_scope *scope)
d1300 3
a1302 1
	uint8_t *name = scope->pos;
d1304 10
a1313 4
	while (*scope->pos == AMLOP_ROOTCHAR || *scope->pos == AMLOP_PARENTPREFIX)
		scope->pos++;

	switch (*scope->pos) {
d1315 1
d1318 4
a1321 1
		scope->pos += 2+AML_NAMESEG_LEN*scope->pos[1];
d1324 3
a1326 1
		scope->pos += 1+AML_NAMESEG_LEN*2;
d1329 7
a1335 1
		scope->pos += AML_NAMESEG_LEN;
d1338 21
a1358 1
	return name;
d1544 1
a1544 2
		aml_xparsename((uint8_t *)def->name, &aml_root,
		    ns_xcreate, &tmp);
d1550 1
a2012 86
 * Namespace functions
 */

/* Search for name in namespace */
void
ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	struct aml_value **rv = arg;
	struct aml_node *rnode;

	/* If name search is relative, check up parent nodes */
	for (rnode=node; n == 1 && rnode; rnode=rnode->parent) {
		if (__aml_search(rnode, pos, 0) != NULL)
			break;
	}
	while (n--) {
		rnode = __aml_search(rnode, pos, 0);
		pos += 4;
	}
	if (rnode != NULL) {
		*rv = rnode->value;
		return;
	}
	*rv = NULL;
}

/* Create name in namespace */
void
ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	struct aml_value **rv = arg;

	while (n--) {
		node = __aml_search(node, pos, 1);
		pos += 4;
	}
	*rv = node->value;
}

void
ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	printf(aml_nodename(node));
	while (n--) {
		printf("%s%c%c%c%c", n ? "." : "", 
		    pos[0], pos[1], pos[2], pos[3]);
		pos+=4;
	}
}

uint8_t *
aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg)
{
	uint8_t *rpos = pos;
	struct aml_value **rv = arg;

	if (*pos == AMLOP_ROOTCHAR) {
		node = &aml_root;
		pos++;
	}
	while (*pos == AMLOP_PARENTPREFIX) {
		node = node ? node->parent : &aml_root;
		pos++;
	}
	if (*pos == 0) {
		fn(node, 0, pos, arg);
		pos++;
	} else if (*pos == AMLOP_MULTINAMEPREFIX) {
		fn(node, pos[1], pos+2, arg);
		pos += 2 + 4 * pos[1];
	} else if (*pos == AMLOP_DUALNAMEPREFIX) {
		fn(node, 2, pos+1, arg);
		pos += 9;
	} else if (*pos == '_' || (*pos >= 'A' && *pos <= 'Z')) {
		fn(node, 1, pos, arg);
		pos += 4;
	} else {
		printf("Invalid name!!!\n");
	}
	if (rv && *rv == NULL)
		*rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, rpos);
	return pos;
}

/*
d2464 2
a2465 2
			mscope->pos = aml_xparsename(mscope->pos, mscope->node,
			    ns_xcreate, &rv);
d2469 1
d2666 1
a2666 2
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
d2682 1
d2918 4
a2921 2
			scope->pos = aml_xparsename(scope->pos, scope->node, 
			    ns_xdis, &rv);
d2945 2
a2946 2
					ms->pos = aml_xparsename(ms->pos, 
					    ms->node, ns_xcreate, &rv);
d2950 1
a3173 10
	if (ch == AML_ARG_CREATENAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xcreate, &rv);
		return rv;
	}
	else if (ch == AML_ARG_SEARCHNAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
		return rv;
	}
d3377 2
a3378 6
			rv = aml_xparsesimple(scope, *ch, NULL);
			if (rv->type != 0 && opcode != AMLOP_SCOPE)
				dnprintf(10, "%s value already exists %s\n",
				    aml_nodename(rv->node),
				    htab->mnem);
			aml_xaddref(rv, "Create Name");
d3381 2
a3382 3
			rv = aml_xparsesimple(scope, *ch, NULL);
			if (rv->type != AML_OBJTYPE_NAMEREF)
				aml_xaddref(rv, "Search Name");
@


1.160
log
@Change ACPI namespace to use SIMPLEQ macros
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.159 2010/06/27 07:26:31 jordan Exp $ */
d1237 2
a1238 1
		nodecb(node, arg);
@


1.159
log
@Cleaned up acpi_maptable, adds to table list directly
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.158 2010/06/19 19:43:06 jordan Exp $ */
d609 1
a609 1
	struct aml_node **sp, *node;
d615 2
a616 2
	for (sp = &root->child; *sp; sp = &(*sp)->sibling) {
		if (!strncmp((*sp)->name, nameseg, AML_NAMESEG_LEN)) {
d618 1
a618 1
			return *sp;
d628 3
a630 1
		node->sibling = NULL;
a632 1
		*sp = node;
d635 1
a635 1
	return *sp;
d698 2
a699 2
	while ((onode = node->child) != NULL) {
		node->child = onode->sibling;
d1238 1
a1238 1
	for (child = node->child; child; child = child->sibling)
d1260 2
a1261 2
			aml_find_node(node->child, name, cbproc, arg);
		node = node->sibling;
d1502 1
@


1.158
log
@Fix reference counting panic for CondRef
Various HP laptops now boot correctly, fixes PR 6276
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.157 2009/12/05 02:38:11 jordan Exp $ */
d50 2
a51 2
struct acpi_q 		*acpi_maptable(paddr_t, const char *, const char *, 
    			    const char *);
d3327 1
a3327 1
	entry = acpi_maptable(rgn->v_opregion.iobase, "SSDT", NULL, NULL);
a3332 4
 
	/* Add SSDT to parent list */
	SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry,
	    q_next);
@


1.157
log
@Use new acpi_maptable on AMLOP_LOAD operations; do not panic if bad checksum
fixes Thinkpad SL300, maybe others
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.156 2009/11/13 11:39:56 jordan Exp $ */
d702 4
d983 1
d3634 5
a3638 1
			aml_freevalue(opargs[1]);
a3639 4
			/* Create Object Reference */
			_aml_setvalue(opargs[1], AML_OBJTYPE_OBJREF, opcode, opargs[0]);
			aml_xaddref(opargs[1], "CondRef");
			
@


1.156
log
@Initialize uninititialized variable.
Not an issue as it does get initialized correctly before use, but reduces warning.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.155 2009/10/16 15:49:25 jordan Exp $ */
d50 5
a2260 1
void aml_xgasio(int, uint64_t, int, void *, int, int, const char *);
a2429 27
/* Perform IO to address space
 *    type = GAS_XXXX
 *    base = base address
 *    rlen = length in bytes to read/write
 *    buf  = buffer
 *    mode = ACPI_IOREAD/ACPI_IOWRITE
 *    sz   = access_size (bits)
 */
void
aml_xgasio(int type, uint64_t base, int rlen, void *buf, int mode, int sz,
    const char *lbl)
{
	sz >>= 3;
	acpi_gasio(dsdt_softc, mode, type, base, sz, rlen, buf);
#ifdef ACPI_DEBUG
	{
		int idx;
		printf("%sio: [%s]  ty:%x bs=%.8llx sz=%.4x rlen=%.4x ",
		    mode == ACPI_IOREAD ? "rd" : "wr", lbl,
		    type, base, sz, rlen);
		for (idx=0; idx<rlen; idx++)
			printf("%.2x ", ((uint8_t *)buf)[idx]);
	}
	printf("\n");
#endif
}

d3304 42
d3980 1
a3980 23
		rv = opargs[0];
		if (rv->type != AML_OBJTYPE_OPREGION || 
		    rv->v_opregion.iospace != GAS_SYSTEM_MEMORY) {
			aml_die("LOAD: not a memory region!\n");
		}

		/* Create buffer and read from memory */
		_aml_setvalue(opargs[1], AML_OBJTYPE_BUFFER,
		    rv->v_opregion.iolen, NULL);
		aml_xgasio(rv->v_opregion.iospace, rv->v_opregion.iobase, 
		    rv->v_opregion.iolen, 
		    opargs[1]->v_buffer, ACPI_IOREAD, 8, "");
		
		/* Validate that this is a SSDT */
		if (!valid_acpihdr(opargs[1]->v_buffer, opargs[1]->length, 
			"SSDT")) {
			aml_die("LOAD: Not a SSDT!\n");
		}

		/* Parse block: set header bytes to NOP */
		memset(opargs[1]->v_buffer, AMLOP_NOP, sizeof(struct acpi_table_header));
		mscope = aml_xpushscope(scope, opargs[1], scope->node, 
		    AMLOP_SCOPE);
@


1.155
log
@Added argument for xconvert for length conversion
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.154 2009/09/04 22:50:11 jordan Exp $ */
d3348 1
@


1.154
log
@Add common framework for storing device lists
Useful for acpitz, acpipwrres, etc.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.153 2009/07/20 05:13:30 jordan Exp $ */
d1710 1
a1710 1
struct aml_value *aml_xconvert(struct aml_value *, int);
d1951 1
a1951 1
		    AML_OBJTYPE_INTEGER);
d2076 1
a2076 1
aml_xconvert(struct aml_value *a, int ctype)
d2081 2
d2153 1
a2153 1
	a2 = aml_xconvert(a2, a1->type);
d2179 1
a2179 1
	a2 = aml_xconvert(a2, a1->type);
d2352 1
a2352 1
			val = aml_xconvert(val, AML_OBJTYPE_BUFFER);
d2362 1
a2362 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER);
d2419 1
a2419 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER);
d2494 1
a2494 1
		data = aml_xconvert(data, AML_OBJTYPE_BUFFER);
d2655 1
a2655 1
		rhs = aml_xconvert(rhs, lhs->type);
d2661 1
a2661 1
		rhs = aml_xconvert(rhs, lhs->type);
d3530 2
a3531 2
			my_ret->v_package[idx] = rv;
		}
d3650 1
a3650 1
			rv = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER);
d3694 1
a3694 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_INTEGER);
d3699 1
a3699 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER);
d3704 1
a3704 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_HEXSTRING);
d3709 1
a3709 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_DECSTRING);
d3714 2
a3715 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING);
d4044 1
a4044 1
		my_ret = aml_xconvert(my_ret, AML_OBJTYPE_INTEGER);
d4126 1
a4126 1
		xres = aml_xeval(NULL, node->value, 't', argc, argv);
@


1.153
log
@KNF fixes
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.152 2009/07/17 21:44:48 jordan Exp $ */
d4204 30
@


1.152
log
@Cleaned up parsing of While loops; iterative If statement
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.151 2009/07/15 21:06:25 martynas Exp $ */
d293 1
a293 1
			printf("  arg%d: ", idx);
d614 1
a614 1
	}
d656 1
a656 1
	while (*name == AMLOP_ROOTCHAR || *name == AMLOP_PARENTPREFIX) {
a657 1
	}
d1279 1
a1279 1
	if (opcode >= 'A' && opcode <= 'Z') {
a1280 1
	}
d1330 1
a1330 1
	if (lcode <= 0x3F) {
a1331 1
	}
d1336 1
a1336 1
	if (lcode >= 0x80) {
d1338 1
a1338 2
	}
	if (lcode >= 0xC0) {
a1339 1
	}
d1604 1
a1604 1
	return 0;
d1729 7
a1735 10
	if (sig && strncmp(hdr->signature, sig, 4)) {
		return 0;
	}
	if (len < hdr->length) {
		return 0;
	}
	if (acpi_checksum(hdr, hdr->length) != 0) {
		return 0;
	}
	return 1; 
d1818 1
a1818 2
	}
	else if (opcode >= AMLOP_ARG0 && opcode <= AMLOP_ARG6) {
d1866 1
a1866 2
	}
	else {
d1869 1
a1869 1
		if (start == end) {
a1870 1
		}
d1900 1
a1900 1
	if (scope->type == AMLOP_METHOD) {
a1901 1
	}
d1936 1
a1936 1
	return 0;
d1978 1
a1978 1
		if (__aml_search(rnode, pos, 0) != NULL) {
a1979 1
		}
d2034 1
a2034 2
	}
	else if (*pos == AMLOP_MULTINAMEPREFIX) {
d2037 1
a2037 2
	}
	else if (*pos == AMLOP_DUALNAMEPREFIX) {
d2040 1
a2040 2
	}
	else if (*pos == '_' || (*pos >= 'A' && *pos <= 'Z')) {
d2043 1
a2043 2
	}
	else {
d2046 1
a2046 1
	if (rv && *rv == NULL) {
a2047 1
	}
d2061 1
a2061 1
		if (*str >= '0' && *str <= '9') {
d2063 1
a2063 2
		}
		else if (*str >= 'a' && *str <= 'f') {
d2065 1
a2065 2
		}
		else if (*str >= 'A' && *str <= 'F') {
d2067 1
a2067 2
		}
		else {
a2068 1
		}
d2152 1
a2152 1
	if (a1->type == AML_OBJTYPE_INTEGER) {
a2153 1
	}
d2213 1
a2213 1
	return 0;
d2224 1
a2224 1
	if (a1->type != AML_OBJTYPE_BUFFER || a2->type != AML_OBJTYPE_BUFFER) {
a2225 1
	}
d2348 1
a2348 2
		}
		else {
d2355 1
a2355 2
	}
	else if (mode == ACPI_IOREAD) {
d2358 1
a2358 2
	}
	else {
d2367 1
a2367 2
	}
	else {
d2376 1
a2376 2
		}
		else if (AML_FIELD_UPDATE(flag) == AML_FIELD_WRITEASONES) {
d2405 1
a2405 2
	}
	else if (fld->v_field.type == AMLOP_BANKFIELD) {
d2409 1
a2409 2
	}
	else if (fld->v_field.type == AMLOP_FIELD) {
d2411 1
a2411 2
	}
	else if (mode == ACPI_IOREAD) {
d2415 1
a2415 2
	}
	else {
d2444 1
a2444 1
		for (idx=0; idx<rlen; idx++) {
a2445 1
		}
d2565 3
a2567 4
		return 0;
	}
	else if (timeout == 0) {
		return 1;
d2570 1
a2570 1
	return 0;
d2593 2
a2594 3
		return 0;
	}
	else if (timeout == 0) {
d2596 1
a2596 1
		return 1;
d2599 1
a2599 1
	return 0;
d3004 1
a3004 2
				}
				else if (*ms->pos == 0x01) {
d3006 1
a3006 2
				}
				else {
d3081 1
a3081 2
			}
			else {
d3094 1
a3094 2
		}
		else {
d3488 1
a3488 2
		}
		else if (my_ret->type == AML_OBJTYPE_METHOD) {
d3638 1
a3638 2
			}
			else {
d3653 1
a3653 2
			}
			else {
d3672 1
a3672 2
		}
		else {
d3785 1
a3785 2
		}
		else {
d3993 1
a3993 2
		}
		else if (opargs[3] != NULL) {
d4101 1
a4101 1
	return 0;
@


1.151
log
@missing va_end in aml_seterror;  ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.150 2009/06/01 22:36:12 jordan Exp $ */
d162 1
a162 1
	{ AMLOP_WHILE,		"While",	"pW",	},
a1797 2
			if (scope->type == type)
			  	scope->pos = scope->start;
d1802 1
a1802 1
				scope->pos = NULL;
d3130 1
d3372 1
d3389 1
a3404 2
		uint8_t *end;

a3434 1
		case AML_ARG_WHILE:
d4046 5
a4050 14
		mscope = aml_xpushscope(scope, opargs[0], scope->node,
		    AMLOP_WHILE);
		while (mscope->pos != NULL) {
			/* At beginning of scope.. reset and perform test */
			mscope->pos = mscope->start;
			rv = aml_xparse(mscope, AML_ARG_INTEGER, "While-Test");
			ival = rv->v_integer;
			aml_xdelref(&rv, "while");

			dnprintf(10,"@@@@@@@@@@@@ WHILE: %llx @@ %x\n", ival, pc);
			if (ival == 0) {
				break;
			}
			aml_xparse(mscope, 'T', "While");
a4051 2
		aml_xpopscope(mscope);
		mscope = NULL;
@


1.150
log
@Remove dead/unused code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.149 2009/05/30 22:49:56 jordan Exp $ */
d3356 1
@


1.149
log
@Added error handler for missing AML nameref; fixes PR6103
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.148 2009/05/30 22:42:02 jordan Exp $ */
a2279 1
void  aml_xresolve(struct aml_scope *, struct aml_value *);
a2284 1
int aml_evalhid(struct aml_node *, struct aml_value *);
a2299 50
int
aml_xgetpci(struct aml_node *node, int64_t *base)
{
	struct aml_node *pci_root;
	struct aml_value hid;
	int64_t v;

	*base = 0;
	dnprintf(10,"RESOLVE PCI: %s\n", aml_nodename(node));
	for (pci_root=node->parent; pci_root; pci_root=pci_root->parent) {
		/* PCI Root object will have _HID value */
		if (aml_evalhid(pci_root, &hid) == 0) {
			aml_freevalue(&hid);
			break;
		}
	}
	if (!aml_evalinteger(NULL, node->parent, "_ADR", 0, NULL, &v))
		*base += (v << 16L);
	if (!aml_evalinteger(NULL, pci_root, "_BBN", 0, NULL, &v))
		*base += (v << 48L);
	return 0;
}

void
aml_xresolve(struct aml_scope *scope, struct aml_value *val)
{
	int64_t base;

	if (val->type != AML_OBJTYPE_OPREGION || val->v_opregion.flag)
		return;
	if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE)
		return;

	/* Evaluate PCI Address */
	aml_xgetpci(val->node, &base);
	val->v_opregion.iobase += base;
	val->v_opregion.flag = 1;
}

union amlpci_t
{
	uint64_t addr;
	struct {
		uint16_t reg;
		uint16_t fun;
		uint16_t dev;
		uint16_t bus;
	};
};

a2301 1
int  aml_rdpciaddr(struct aml_node *pcidev, union amlpci_t *);
@


1.148
log
@Fixed parsing rules for Scope opcode, fixes panic on some HP systems
Create default scope names
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.147 2009/04/27 23:39:14 jordan Exp $ */
a783 1
	case AML_OBJTYPE_STATICINT:
a867 1
	case AML_OBJTYPE_STATICINT:
a889 1
	case AML_OBJTYPE_STATICINT:
d936 1
a936 1
	lhs->type = rhs->type  & ~AML_STATIC;
a939 1
	case AML_OBJTYPE_STATICINT:
d1699 2
d1707 1
d3156 4
d3401 18
d3421 1
a3421 1
	int    opcode, idx, pc, optype[8];
a3453 1
	memset(optype, 0, sizeof(optype));
d3482 2
a3483 2
				if (rv == NULL)
					aml_die("NULL RESULT");
d3508 1
d3532 1
a3532 2
		if (rv != NULL) {
			optype[idx] = *ch;
a3534 1
	}
d3565 10
d3618 1
a3619 2
			const char *nn;

d3621 2
a3622 18
			if (rv == NULL) {
				continue;
			}
			nn = NULL;
			if (rv->node)
				/* Object is a named node: store as string */
				nn = aml_nodename(rv->node);
			else if (rv->type == AML_OBJTYPE_NAMEREF)
				/* Object is nameref: store as string */
				nn = aml_getname(rv->v_nameref);
			if (nn != NULL) {
				aml_xdelref(&rv, "pkg.node");
				rv = aml_allocvalue(AML_OBJTYPE_STRING, 
				    -1, nn);
			}
			/* Package value already allocated; delete it
			 * and replace with pointer to return value */
			aml_xdelref(&my_ret->v_package[idx], "pkg/init");
d3625 1
d3649 4
d4161 3
a4163 2
	for (idx=0; optype[idx] != 0; idx++) {
		if (opargs[idx] == my_ret || optype[idx] == 'N')
d4201 1
d4208 4
a4225 3
#ifdef ACPI_MEMDEBUG
	static int wmstate;
#endif
d4232 4
a4235 8
	switch (node->value->type) {
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_PACKAGE:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PROCESSOR:
	case AML_OBJTYPE_THERMZONE:
	case AML_OBJTYPE_POWERRSRC:
a4236 12
			aml_copyvalue(res, node->value);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_METHOD:
		aml_busy++;
#ifdef ACPI_MEMDEBUG
		wmstate = acpi_walkmem(wmstate, aml_nodename(node));	
#endif
		xres = aml_xeval(NULL, node->value, 't', argc, argv);
		aml_busy--;
		if (res && xres)
d4239 4
a4242 3
			aml_xdelref(&xres, "EvalNode");
		break;
	default:
@


1.147
log
@Remove unnecessary aml_xconvert arg, code cleanup
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.146 2009/04/10 16:05:10 jordan Exp $ */
d208 1
a208 1
	{ AMLOP_SCOPE,		"Scope",	"pNT",	},
d1442 8
d3906 4
@


1.146
log
@Fix for PR6099, read/write of non-byte aligned IndexField
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.145 2009/04/10 03:32:24 marco Exp $ */
d1708 1
a1708 1
struct aml_value *aml_xconvert(struct aml_value *, int, int);
d1958 1
a1958 1
		    AML_OBJTYPE_INTEGER, 0);
d2093 1
a2093 1
aml_xconvert(struct aml_value *a, int ctype, int mode)
d2134 2
d2140 1
a2140 1
			snprintf(c->v_string, c->length, (mode == 'x') ? 
d2147 3
d2157 1
a2157 1
		aml_die("Could not convert!!!\n");
d2168 1
a2168 1
	a2 = aml_xconvert(a2, a1->type, 0);
d2195 1
a2195 1
	a2 = aml_xconvert(a2, a1->type, 0);
d2423 1
a2423 1
			val = aml_xconvert(val, AML_OBJTYPE_BUFFER, 0);
d2435 1
a2435 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER, 0);
d2498 1
a2498 1
		val = aml_xconvert(val, AML_OBJTYPE_INTEGER, 0);
d2574 1
a2574 1
		data = aml_xconvert(data, AML_OBJTYPE_BUFFER, 0);
d2737 1
a2737 1
		rhs = aml_xconvert(rhs, lhs->type, 0);
d2743 1
a2743 1
		rhs = aml_xconvert(rhs, lhs->type, 0);
d3719 1
a3719 1
			rv = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER, 0);
d3765 1
a3765 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_INTEGER, 0);
d3770 1
a3770 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_BUFFER, 0);
d3775 1
a3775 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING, 'x');
d3780 1
a3780 1
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING, 'd');
d3785 2
a3786 2
		my_ret = aml_xconvert(opargs[0], AML_OBJTYPE_STRING, 0);
		aml_die("tostring\n");
d4123 1
a4123 1
		my_ret = aml_xconvert(my_ret, AML_OBJTYPE_INTEGER, 0);
@


1.145
log
@gasio was killed so kill proto
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.144 2009/04/09 16:52:32 jordan Exp $ */
d2484 1
a2484 1
		aml_rwgas(ref1, fld->v_field.bitpos, fld->v_field.bitlen, val, mode, fld->v_field.flags);
@


1.144
log
@Fixed argtype for Increment/Decrement.  Field args were being evaluated as
integers instead remaining a reference.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.143 2009/03/13 19:01:03 marco Exp $ */
a82 2
void			aml_gasio(struct acpi_softc *, int, uint64_t, uint64_t,
			    int, int, int, void *, int);
@


1.143
log
@tabs; stupid emacs
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.142 2009/03/13 18:41:57 jordan Exp $ */
d173 2
a174 2
	{ AMLOP_INCREMENT,	"Increment",	"t",	},
	{ AMLOP_DECREMENT,	"Decrement",	"t",	},
@


1.142
log
@Fixed potential aml_freevalue on uninitialized stack , reported by krw
Fixup in acpidock for aml_evalinteger
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.141 2009/03/11 20:37:46 jordan Exp $ */
d4253 2
a4254 2
	*ival = aml_val2int(&res);
	aml_freevalue(&res);
@


1.141
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.140 2009/03/10 20:36:10 jordan Exp $ */
d4192 2
a4195 2
	if (res)
		memset(res, 0, sizeof(*res));
d4252 1
d4255 1
a4255 1

@


1.140
log
@Added sensor devices for Thinkpad (temp+fan)
Exported aml_evalinteger method
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.139 2009/03/07 07:04:38 jordan Exp $ */
d1381 1
a1381 1
	struct aml_value tmpres;
d1386 1
a1386 1
	if (!aml_evalname(dsdt_softc, root, "_ADR", 0, NULL, &tmpres)) {
d1388 1
a1388 2
		pciaddr += (aml_val2int(&tmpres) << 16L);
		aml_freevalue(&tmpres);
d1396 1
a1396 1
	if (!aml_evalname(dsdt_softc, root, "_BBN", 0, NULL, &tmpres)) {
d1398 1
a1398 2
		pciaddr += (aml_val2int(&tmpres) << 48L);
		aml_freevalue(&tmpres);
@


1.139
log
@Misc cleanups, remove dead code
Normalized api for conversion/concatenation
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.138 2009/03/05 04:59:58 jordan Exp $ */
a70 2
int			aml_evalinteger(struct acpi_softc *, struct aml_node *,
			    const char *, int, struct aml_value *, int64_t *);
@


1.138
log
@Rip out old fieldio code (no longer used)
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.137 2009/03/05 04:48:11 jordan Exp $ */
d908 1
a908 1
		lhs->v_objref.index = ival;
a1408 19
/* Fixup references for BufferFields/FieldUnits */
#if 0
void		aml_fixref(struct aml_value **);

void
aml_fixref(struct aml_value **res)
{
	struct aml_value *oldres;

	while (*res && (*res)->type == AML_OBJTYPE_OBJREF &&
	    (*res)->v_objref.index == -1) {
		oldres = (*res)->v_objref.ref;
		aml_delref(res);
		aml_addref(oldres);
		*res = oldres;
	}
}
#endif

a1432 43
#if 0
/*
 * @@@@@@: Fixup DSDT code
 */
struct aml_fixup {
	int		offset;
	u_int8_t	oldv, newv;
} __ibm300gl[] = {
	{ 0x19, 0x3a, 0x3b },
	{ -1 }
};

struct aml_blacklist {
	const char	*oem, *oemtbl;
	struct aml_fixup *fixtab;
	u_int8_t	cksum;
} amlfix_list[] = {
	{ "IBM   ", "CDTPWSNH", __ibm300gl, 0x41 },
	{ NULL },
};

void
aml_fixup_dsdt(u_int8_t *acpi_hdr, u_int8_t *base, int len)
{
	struct acpi_table_header *hdr = (struct acpi_table_header *)acpi_hdr;
	struct aml_blacklist *fixlist;
	struct aml_fixup *fixtab;

	for (fixlist = amlfix_list; fixlist->oem; fixlist++) {
		if (!memcmp(fixlist->oem, hdr->oemid, 6) &&
		    !memcmp(fixlist->oemtbl, hdr->oemtableid, 8) &&
		    fixlist->cksum == hdr->checksum) {
			/* Found a potential fixup entry */
			for (fixtab = fixlist->fixtab; fixtab->offset != -1;
			    fixtab++) {
				if (base[fixtab->offset] == fixtab->oldv)
					base[fixtab->offset] = fixtab->newv;
			}
		}
	}
}
#endif

a1625 21
#if 0
int
acpi_parse_aml(struct acpi_softc *sc, u_int8_t *start, u_int32_t length)
{
	u_int8_t *end;

	dsdt_softc = sc;

	strlcpy(aml_root.name, "\\", sizeof(aml_root.name));
	if (aml_root.start == NULL) {
		aml_root.start = start;
		aml_root.end = start+length;
	}
	end = start+length;
	aml_parsenode(NULL, &aml_root, start, &end, NULL);
	dnprintf(50, " : parsed %d AML bytes\n", length);

	return (0);
}
#endif

d1643 1
a1643 1
			_aml_setvalue(val, AML_OBJTYPE_OBJREF, -1,
d1701 1
d1714 1
a1714 1
void		aml_xconvert(struct aml_value *, struct aml_value **, int, int);
d1720 3
a1722 4
void		aml_xconcat(struct aml_value *, struct aml_value *, 
    struct aml_value **);
void		aml_xconcatres(struct aml_value *, struct aml_value *, 
    struct aml_value **);
a1723 1
void		aml_xmid(struct aml_value *, int, int, struct aml_value **);
d1963 1
a1963 1
		aml_xconvert(pkg->v_package[index], &tmp, 
d2098 2
a2099 2
void
aml_xconvert(struct aml_value *a, struct aml_value **b, int ctype, int mode)
d2106 1
a2106 2
		*b = a;
		return;
d2160 1
a2160 1
	*b = c;
d2169 1
a2169 1
	aml_xconvert(a2, &a2, a1->type, 0);
d2190 2
a2191 2
void
aml_xconcat(struct aml_value *a1, struct aml_value *a2, struct aml_value **res)
d2196 1
a2196 1
	aml_xconvert(a2, &a2, a1->type, 0);
d2222 1
a2222 1
	*res = c;
d2236 2
a2237 2
void
aml_xconcatres(struct aml_value *a1, struct aml_value *a2, struct aml_value **res)
d2240 2
a2241 1
	int l1 = 0, l2 = 0;
d2252 1
a2252 1
	c = aml_allocvalue(AML_OBJTYPE_BUFFER, l1+l2+2, NULL);
d2255 1
a2255 2
	c->v_buffer[l1+l2+0] = 0x79;
	c->v_buffer[l1+l2+1] = 0x00;
d2257 1
a2257 1
	*res = c;
d2261 2
a2262 2
void
aml_xmid(struct aml_value *src, int index, int length, struct aml_value **res)
d2264 5
a2268 9
	int idx;

	for (idx=index; idx<index+length; idx++) {
		if (idx >= src->length)
			break;
		if (src->v_buffer[idx] == 0)
			break;
	}
	aml_die("mid\n");
d2424 1
a2424 1
			aml_xconvert(val, &val, AML_OBJTYPE_BUFFER, 0);
d2436 1
a2436 1
		aml_xconvert(val, &val, AML_OBJTYPE_INTEGER, 0);
d2499 1
a2499 1
		aml_xconvert(val, &val, AML_OBJTYPE_INTEGER, 0);
d2575 1
a2575 1
		aml_xconvert(data, &data, AML_OBJTYPE_BUFFER, 0);
d2726 1
a2726 3
	while (lhs->type == AML_OBJTYPE_OBJREF) {
		lhs = lhs->v_objref.ref;
	}
d2738 1
a2738 1
		aml_xconvert(rhs, &rhs, lhs->type, 0);
d2744 1
a2744 1
		aml_xconvert(rhs, &rhs, lhs->type, 0);
d3166 1
a3166 2
				sp->type = AML_OBJTYPE_OBJREF;
				sp->v_objref.type = AMLOP_ARG0 + idx;
d3382 9
d3395 1
a3395 1
	struct aml_value *opargs[8], *my_ret, *tmp, *cname;
a3424 1
	cname = NULL;
a3428 1
		struct aml_value *rv;
d3477 1
a3477 2
			cname = rv;
			if (cname->type != 0 && opcode != AMLOP_SCOPE)
d3479 1
a3479 1
				    aml_nodename(cname->node),
d3585 2
a3586 2
			tmp = aml_xparse(mscope, 'o', "Package");
			if (tmp == NULL) {
d3590 1
a3590 1
			if (tmp->node)
d3592 2
a3593 2
				nn = aml_nodename(tmp->node);
			else if (tmp->type == AML_OBJTYPE_NAMEREF)
d3595 1
a3595 1
				nn = aml_getname(tmp->v_nameref);
d3597 2
a3598 2
				aml_xdelref(&tmp, "pkg.node");
				tmp = aml_allocvalue(AML_OBJTYPE_STRING, 
d3604 1
a3604 1
			my_ret->v_package[idx] = tmp;
d3681 1
a3681 2
			_aml_setvalue(opargs[1], AML_OBJTYPE_OBJREF, 0, opargs[0]);
			opargs[1]->v_objref.type = AMLOP_REFOF;
d3690 1
a3690 2
		my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, 0, opargs[0]);
		my_ret->v_objref.type = AMLOP_REFOF;
d3711 1
a3711 1
				my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, 0,
a3712 1
				my_ret->v_objref.type = AMLOP_PACKAGE;
d3720 1
a3720 1
			aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
d3723 2
a3724 2
				    idx, tmp->v_buffer[idx]);
				ival = tmp->v_buffer[idx];
d3729 1
a3729 1
				aml_xcreatefield(my_ret, AMLOP_INDEX, tmp, 
d3732 1
a3732 1
			aml_xdelref(&tmp, "Index.BufStr");
d3766 1
a3766 1
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_INTEGER, 0);
d3771 1
a3771 1
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_BUFFER, 0);
d3776 1
a3776 1
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 'x');
d3781 1
a3781 1
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 'd');
d3786 1
a3786 1
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 0);
d3791 1
a3791 1
		aml_xconcat(opargs[0], opargs[1], &my_ret);
d3796 1
a3796 1
		aml_xconcatres(opargs[0], opargs[1], &my_ret);
d3801 2
a3802 2
		aml_xmid(opargs[0], opargs[1]->v_integer, 
		    opargs[2]->v_integer, &my_ret);
d3813 2
a3814 4
		if (opargs[0]->type == AML_OBJTYPE_OBJREF)
			ival = opargs[0]->v_objref.ref->length;
		else
			ival = opargs[0]->length;
d3818 2
a3819 1
		ival = opargs[0]->type;
d3825 2
a3826 1
		ival = acpi_xmutex_acquire(scope, opargs[0], 
d3831 2
a3832 1
		acpi_xmutex_release(scope, opargs[0]);
d3836 2
a3837 1
		ival = acpi_xevent_wait(scope, opargs[0], 
d3842 2
a3843 1
		acpi_xevent_reset(scope, opargs[0]);
d3847 2
a3848 1
		acpi_xevent_signal(scope, opargs[0]);
d3854 9
a3862 2
		aml_freevalue(cname);
		aml_copyvalue(cname, opargs[1]);
d3866 3
a3868 8
		cname->type = AML_OBJTYPE_OBJREF;
		cname->v_objref.type = AMLOP_ALIAS;
		cname->v_objref.ref = opargs[0];
		while (cname->v_objref.ref->type == AML_OBJTYPE_OBJREF) {
			/* Single indirection level */
			cname->v_objref.ref = cname->v_objref.ref->v_objref.ref;
		}
		aml_xaddref(cname->v_objref.ref, "Alias");
d3872 5
a3876 5
		cname->type = AML_OBJTYPE_OPREGION;
		cname->v_opregion.iospace = opargs[1]->v_integer;
		cname->v_opregion.iobase = opargs[2]->v_integer;
		cname->v_opregion.iolen = opargs[3]->v_integer;
		cname->v_opregion.flag = 0;
d3880 4
a3883 4
		cname->type = AML_OBJTYPE_OPREGION;
		cname->v_opregion.iospace = GAS_SYSTEM_MEMORY;
		cname->v_opregion.iobase = 0;
		cname->v_opregion.iolen = 0;
d3888 2
a3889 2
		cname->type = AML_OBJTYPE_EVENT;
		cname->v_integer = 0;
d3893 2
a3894 2
		cname->type = AML_OBJTYPE_MUTEX;
		cname->v_mtx.synclvl = opargs[1]->v_integer;
d3898 2
a3899 1
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
d3903 2
a3904 2
		cname->type = AML_OBJTYPE_DEVICE;
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
d3908 2
a3909 2
		cname->type = AML_OBJTYPE_THERMZONE;
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
d3913 4
a3916 4
		cname->type = AML_OBJTYPE_POWERRSRC;
		cname->v_powerrsrc.pwr_level = opargs[1]->v_integer;
		cname->v_powerrsrc.pwr_order = opargs[2]->v_integer;
		mscope = aml_xpushscope(scope, opargs[3], cname->node, opcode);
d3920 5
a3924 5
		cname->type = AML_OBJTYPE_PROCESSOR;
		cname->v_processor.proc_id = opargs[1]->v_integer;
		cname->v_processor.proc_addr = opargs[2]->v_integer;
		cname->v_processor.proc_len = opargs[3]->v_integer;
		mscope = aml_xpushscope(scope, opargs[4], cname->node, opcode);
d3928 5
a3932 5
		cname->type = AML_OBJTYPE_METHOD;
		cname->v_method.flags = opargs[1]->v_integer;
		cname->v_method.start = opargs[2]->v_buffer;
		cname->v_method.end = cname->v_method.start + opargs[2]->length;
		cname->v_method.base = aml_root.start;
d3938 2
a3939 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer,
d3944 2
a3945 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer,    
d3950 2
a3951 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer*8,  
d3956 2
a3957 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer*8, 
d3962 2
a3963 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer*8, 
d3968 2
a3969 1
		aml_xcreatefield(cname, opcode, opargs[0], opargs[1]->v_integer*8, 
d4005 1
d4007 1
a4007 1
		    aml_nodename(opargs[0]->node), 
d4009 1
a4009 1
		aml_notify(opargs[0]->node, opargs[1]->v_integer);
d4028 3
a4030 3
		tmp = opargs[0];
		if (tmp->type != AML_OBJTYPE_OPREGION || 
		    tmp->v_opregion.iospace != GAS_SYSTEM_MEMORY) {
d4036 3
a4038 3
		    tmp->v_opregion.iolen, NULL);
		aml_xgasio(tmp->v_opregion.iospace, tmp->v_opregion.iobase, 
		    tmp->v_opregion.iolen, 
d4077 3
a4079 3
			tmp = aml_xparse(mscope, AML_ARG_INTEGER, "While-Test");
			ival = tmp->v_integer;
			aml_xdelref(&tmp, "while");
d4124 1
a4124 1
		aml_xconvert(my_ret, &my_ret, AML_OBJTYPE_INTEGER, 0);
d4153 1
@


1.137
log
@New ACPI fieldio routines
Fix for PR6017, tested extensively on @@tech
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.136 2008/10/07 18:02:20 kettenis Exp $ */
a2363 1
void *aml_xgetptr(struct aml_value *, int);
a2364 2
void aml_xfldio(struct aml_scope *, struct aml_value *, 
    struct aml_value *, int);
a2620 174
}

void *
aml_xgetptr(struct aml_value *tmp, int blen)
{
	if (blen > aml_intlen) {
		_aml_setvalue(tmp, AML_OBJTYPE_BUFFER, aml_bytelen(blen), 0);
		return tmp->v_buffer;
	}
	_aml_setvalue(tmp, AML_OBJTYPE_INTEGER, 0, NULL);
	return &tmp->v_integer;
}

/* Read and Write BufferField and FieldUnit objects */
void
aml_xfldio(struct aml_scope *scope, struct aml_value *fld, 
	   struct aml_value *buf, int mode)
{
	struct aml_value tmp, *data;
	int bpos, blen, preserve=1, mask, aligned, rlen, slen;
	void *sptr, *dptr;
		
 	switch (AML_FIELD_ACCESS(fld->v_field.flags)) {
	case AML_FIELD_WORDACC:
		mask=15;
		break;
	case AML_FIELD_DWORDACC:
		mask=31;
		break;
	case AML_FIELD_QWORDACC:
		mask=63;
		break;
	default:
		mask=7;
		break;
	}
	data = fld->v_field.ref1;
	bpos = fld->v_field.bitpos;
	blen = fld->v_field.bitlen;
	rlen = aml_bytelen((bpos & 7) + blen);
	aligned = !((bpos|blen)&mask);
	preserve = AML_FIELD_UPDATE(fld->v_field.flags);

	dnprintf(30,"\nquick: %s: [%s] %.4x-%.4x msk=%.2x algn=%d prsrv=%d [%s]\n",
	    mode == ACPI_IOREAD ? "read from" : "write to",
	    aml_nodename(fld->node),
	    bpos, blen, mask, aligned, preserve,
	    aml_mnem(fld->v_field.type, 0));

	memset(&tmp, 0, sizeof(tmp));
	if (fld->v_field.ref2 != NULL) {
		/* Write index */
		dnprintf(30,"writing index fldio: %d\n", fld->v_field.ref3);
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, 
		    fld->v_field.ref3, NULL);
		aml_xfldio(scope, fld->v_field.ref2, &tmp, ACPI_IOWRITE);
	}

	/* Get pointer to Data Object */
	switch (data->type) {
	case AML_OBJTYPE_BUFFER:
		dptr = data->v_buffer;
		break;
	case AML_OBJTYPE_STRING:
		dptr = data->v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dptr = &data->v_integer;
		break;
	case AML_OBJTYPE_OPREGION:
		/* Depending on size, allocate buffer or integer */
		aml_xresolve(scope, data);
		dptr = aml_xgetptr(&tmp, rlen << 3);
		break;
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		/* Set to integer for now.. */
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, 0x0, NULL);
		dptr = &tmp.v_integer;
		break;
	default:
		aml_die("jk XREAD/WRITE: unknown type: %x\n", data->type);
		break;
	}

	aml_lockfield(scope, fld);
	if (mode == ACPI_IOREAD) {
		sptr = aml_xgetptr(buf, blen);
		switch (data->type) {
		case AML_OBJTYPE_OPREGION:
			/* Do GASIO into temp buffer, bitcopy into result */
			aml_xgasio(data->v_opregion.iospace,
			    data->v_opregion.iobase+(bpos>>3),
			    rlen, dptr, ACPI_IOREAD, mask+1,
			    aml_nodename(fld->node));
			aml_bufcpy(sptr, 0, dptr, bpos & 7, blen);
			break;
		case AML_OBJTYPE_FIELDUNIT:
		case AML_OBJTYPE_BUFFERFIELD:
			/* Do FieldIO into temp buffer, bitcopy into result */
			aml_xfldio(scope, data, &tmp, ACPI_IOREAD);
			aml_bufcpy(sptr, 0, dptr, bpos & 7, blen);
			break;
		default:
			/* bitcopy into result */
			aml_bufcpy(sptr, 0, dptr, bpos, blen);
			break;
		}
	}
	else {
		switch (buf->type) {
		case AML_OBJTYPE_INTEGER:
			slen = aml_intlen;
			break;
		default:
			slen = buf->length<<3;
			break;
		}
		if (slen < blen) {
#ifndef SMALL_KERNEL
			aml_showvalue(fld, 0);
			aml_showvalue(buf, 0);
#endif
			aml_die("BIG SOURCE %d %d %s", buf->length, blen>>3, "");
		}
		if (buf->type != AML_OBJTYPE_INTEGER)
			aml_die("writefield: not integer\n");
		sptr = &buf->v_integer;

		switch (data->type) {
		case AML_OBJTYPE_OPREGION:
			if (!aligned && preserve == AML_FIELD_PRESERVE) {
				/* Preserve contents: read current value */
				aml_xgasio(data->v_opregion.iospace,
				    data->v_opregion.iobase+(bpos>>3),
				    rlen, dptr, ACPI_IOREAD, mask+1,
				    aml_nodename(fld->node));
			}
			/* Bitcopy data into temp buffer, write GAS */
			if (preserve == AML_FIELD_WRITEASONES)
				memset(dptr, 0xFF, tmp.length);
			aml_bufcpy(dptr, bpos & 7, sptr, 0, blen);
			aml_xgasio(data->v_opregion.iospace,
			    data->v_opregion.iobase+(bpos>>3),
			    rlen, dptr, ACPI_IOWRITE, mask+1,
			    aml_nodename(fld->node));
			break;
		case AML_OBJTYPE_FIELDUNIT:
		case AML_OBJTYPE_BUFFERFIELD:
			if (!aligned && preserve == AML_FIELD_PRESERVE) {
				/* Preserve contents: read current value */
				aml_xfldio(scope, data, &tmp, ACPI_IOREAD);
				if (tmp.type != AML_OBJTYPE_INTEGER)
					dptr = tmp.v_buffer;
			}
			else {
				dptr = aml_xgetptr(&tmp, rlen<<3);
			}
			/* Bitcopy data into temp buffer, write field */
			if (preserve == AML_FIELD_WRITEASONES)
				memset(dptr, 0xFF, tmp.length);
			aml_bufcpy(dptr, bpos & 7, sptr, 0, blen);
			aml_xfldio(scope, data, &tmp, ACPI_IOWRITE);
			break;
		default:
			if (blen > aml_intlen) {
				aml_die("jk Big Buffer other!\n");
			}
			aml_bufcpy(dptr, bpos, sptr, 0, blen);
			break;
		}
	}
	aml_freevalue(&tmp);
	aml_unlockfield(scope, fld);
@


1.136
log
@Fix memory leak bug during scope evaluation (now without introducing a bug
in evaluation of the Return() operator).  Based jordan@@'s diff from rev. 1.133.

ok jordan@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.135 2008/10/04 18:48:04 kettenis Exp $ */
d2427 171
d2831 4
d2881 2
a2882 17
			switch (opcode) {
			case AMLOP_FIELD:
				/* nbF */
				aml_xcreatefield(rv, opcode, data, bpos, 
				    blen, NULL, 0, flags);
				break;
			case AMLOP_INDEXFIELD:
				/* nnbF */
				aml_xcreatefield(rv, opcode, data, bpos & 7, 
				    blen, index, bpos>>3, flags);
				break;
			case AMLOP_BANKFIELD:
				/* nnibF */
				aml_xcreatefield(rv, opcode, data, bpos, 
				    blen, index, indexval, flags);
				break;
			}
d2985 1
a2985 1
		aml_xfldio(scope, rhs, &tmp, ACPI_IOREAD);
d3001 1
a3001 1
		aml_xfldio(scope, lhs, rhs, ACPI_IOWRITE);
d3464 1
a3464 1
		aml_xfldio(scope, tmp, my_ret, ACPI_IOREAD);
@


1.135
log
@Commit cleanup part of the diff that was backed out in the previous commit
(removal of unused functions).

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.134 2008/09/29 18:29:43 deraadt Exp $ */
d396 6
d403 5
d418 8
d438 4
d447 17
d1551 4
d1873 17
a1889 2
		if (endscope)
			scope->pos = NULL;
d2727 1
d4184 1
a4184 3
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = NULL;
		mscope = NULL;
d4188 1
a4188 3
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = mscope->start;
		mscope = NULL;
d4191 1
a4191 1
		mscope = aml_xfindscope(scope, AMLOP_METHOD, 1);
d4283 3
d4307 3
@


1.134
log
@back out previous commit, since it is breaking a variety of machines
(Supermicro X5DLR, and seperately, see pr 5941)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.132 2008/09/10 14:01:22 blambert Exp $ */
a373 10
const char *
aml_args(int opcode)
{
	struct aml_opcode *tab;

	if ((tab = aml_findopcode(opcode)) != NULL)
		return tab->args;
	return ("");
}

a672 54

struct aml_scope	*aml_pushscope(struct aml_scope *, uint8_t *,
			    uint8_t *, struct aml_node *);
struct aml_scope	*aml_popscope(struct aml_scope *);

#define AML_LHS		0
#define AML_RHS		1
#define AML_DST		2
#define AML_DST2	3

/* Allocate+push parser scope */
struct aml_scope *
aml_pushscope(struct aml_scope *parent, uint8_t *start, uint8_t  *end,
    struct aml_node *node)
{
	struct aml_scope *scope;

	scope = acpi_os_malloc(sizeof(struct aml_scope));
	scope->pos = start;
	scope->end = end;
	scope->node = node;
	scope->parent = parent;
	scope->sc = dsdt_softc;

	aml_lastscope = scope;

	return scope;
}

struct aml_scope *
aml_popscope(struct aml_scope *scope)
{
	struct aml_scope *nscope;
	struct aml_vallist *ol;
	int idx;

	if (scope == NULL)
		return NULL;
	nscope = scope->parent;

	/* Free temporary values */
	while ((ol = scope->tmpvals) != NULL) {
		scope->tmpvals = ol->next;
		for (idx = 0; idx < ol->nobj; idx++) {
			aml_freevalue(&ol->obj[idx]);
		}
		acpi_os_free(ol);
	}
	acpi_os_free(scope);

	aml_lastscope = nscope;

	return nscope;
}
@


1.133
log
@Fixed memory leak bug during scope evaluation
Removed unused functions
ok marco@@
@
text
@d374 10
a405 6
#ifdef ACPI_MEMDEBUG
	const char *fn;
	int         line;
	int         sig;
	LIST_ENTRY(acpi_memblock) link;
#endif
a406 5
#ifdef ACPI_MEMDEBUG
LIST_HEAD(, acpi_memblock) acpi_memhead;
#endif

int acpi_memsig;
a416 8
#ifdef ACPI_MEMDEBUG
	sptr->line = line;
	sptr->fn = fn;
	sptr->sig = ++acpi_memsig;

	LIST_INSERT_HEAD(&acpi_memhead, sptr, link);
#endif

a428 4
#ifdef ACPI_MEMDEBUG	
		LIST_REMOVE(sptr, link);
#endif

a433 17
int
acpi_walkmem(int sig, const char *lbl)
{
#ifdef ACPI_MEMDEBUG
	struct acpi_memblock *sptr;

	printf("--- walkmem:%s %x --- %x bytes alloced\n", lbl, sig, acpi_nalloc);
	LIST_FOREACH(sptr, &acpi_memhead, link) {
		if (sptr->sig < sig)
			break;
		printf("%.4x Alloc %.8lx bytes @@ %s:%d\n",
			sptr->sig, sptr->size, sptr->fn, sptr->line);
	}
#endif
	return acpi_memsig;
}

d684 54
a1574 4
#ifdef ACPI_MEMDEBUG
	LIST_INIT(&acpi_memhead);
#endif

d1893 1
a1893 12
		switch (endscope) {
		case AMLOP_RETURN:
			scope->pos = scope->end;
			break;
		case AMLOP_CONTINUE:
			scope->pos = scope->end;
			if (scope->type == type)
			  	scope->pos = scope->start;
			break;
		case AMLOP_BREAK:
			scope->pos = scope->end;
			if (scope->type == type)
a1894 2
			break;
		}
d2377 1
a2731 1
	aml_xpopscope(mscope);
d4188 3
a4190 1
		aml_xfindscope(scope, AMLOP_WHILE, AMLOP_BREAK);
d4194 3
a4196 1
		aml_xfindscope(scope, AMLOP_WHILE, AMLOP_CONTINUE);
d4199 1
a4199 1
		mscope = aml_xfindscope(scope, AMLOP_METHOD, AMLOP_RETURN);
a4290 3
#ifdef ACPI_MEMDEBUG
	static int wmstate;
#endif
a4311 3
#ifdef ACPI_MEMDEBUG
		wmstate = acpi_walkmem(wmstate, aml_nodename(node));	
#endif
@


1.132
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.131 2008/08/14 17:41:20 jsing Exp $ */
a373 10
const char *
aml_args(int opcode)
{
	struct aml_opcode *tab;

	if ((tab = aml_findopcode(opcode)) != NULL)
		return tab->args;
	return ("");
}

d396 6
d403 5
d418 8
d438 4
d447 17
a713 54
struct aml_scope	*aml_pushscope(struct aml_scope *, uint8_t *,
			    uint8_t *, struct aml_node *);
struct aml_scope	*aml_popscope(struct aml_scope *);

#define AML_LHS		0
#define AML_RHS		1
#define AML_DST		2
#define AML_DST2	3

/* Allocate+push parser scope */
struct aml_scope *
aml_pushscope(struct aml_scope *parent, uint8_t *start, uint8_t  *end,
    struct aml_node *node)
{
	struct aml_scope *scope;

	scope = acpi_os_malloc(sizeof(struct aml_scope));
	scope->pos = start;
	scope->end = end;
	scope->node = node;
	scope->parent = parent;
	scope->sc = dsdt_softc;

	aml_lastscope = scope;

	return scope;
}

struct aml_scope *
aml_popscope(struct aml_scope *scope)
{
	struct aml_scope *nscope;
	struct aml_vallist *ol;
	int idx;

	if (scope == NULL)
		return NULL;
	nscope = scope->parent;

	/* Free temporary values */
	while ((ol = scope->tmpvals) != NULL) {
		scope->tmpvals = ol->next;
		for (idx = 0; idx < ol->nobj; idx++) {
			aml_freevalue(&ol->obj[idx]);
		}
		acpi_os_free(ol);
	}
	acpi_os_free(scope);

	aml_lastscope = nscope;

	return nscope;
}

d1551 4
d1873 12
a1884 1
		if (endscope)
d1886 2
a2369 1
int aml_evalhid(struct aml_node *, struct aml_value *);
d2724 1
d4181 1
a4181 3
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = NULL;
		mscope = NULL;
d4185 1
a4185 3
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = mscope->start;
		mscope = NULL;
d4188 1
a4188 1
		mscope = aml_xfindscope(scope, AMLOP_METHOD, 1);
d4280 3
d4304 3
@


1.131
log
@If the AML SizeOf() method is called with an object reference it should
return the size of the referenced object. This fixes a panic on the ASUS
eeePC 1000H when attaching the acpiasus(4) driver.

Issue reported and fix tested by robert@@

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.130 2008/06/14 21:40:16 jordan Exp $ */
d503 1
a503 1
	timeout_add(&dsdt_softc->sc_dev_timeout, 10 * hz);
d528 1
a528 1
		timeout_add(&dsdt_softc->sc_dev_timeout, 10 * hz);
@


1.130
log
@Fixed evil recursion depth for ASUS EEEPC, uses less memory too
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.129 2008/06/13 05:53:56 canacar Exp $ */
d3923 4
a3926 1
		ival = opargs[0]->length;
@


1.129
log
@Remove duplicate function for string to integer conversion. ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.128 2008/06/13 01:10:41 jordan Exp $ */
d3492 2
d3500 1
a3500 1
	struct aml_scope *mscope;
a3507 1
 start:
d3510 6
a3515 1

d3524 1
a3524 2
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode,
		    aml_pc(scope->pos - opsize(opcode)));
d3690 2
d3696 2
a3697 1
			if (tmp->node) {
d3699 5
a3703 7
				const char *nn = aml_nodename(tmp->node);
				aml_xdelref(&tmp, "pkg.node");
				tmp = aml_allocvalue(AML_OBJTYPE_STRING, 
				    -1, nn);
			}
			else if (tmp->type == AML_OBJTYPE_NAMEREF) {
				const char *nn = aml_getname(tmp->v_nameref);
d4071 1
d4078 1
d4085 1
d4210 2
a4211 2
		aml_xparse(mscope, 'T', htab->mnem);
		aml_xpopscope(mscope);
d4214 1
a4214 1
		dnprintf(10,"quick: %.4x [%s] allocating return integer = 0x%llx\n",
a4234 1
	odp--;
d4239 4
d4246 2
@


1.128
log
@Cleanup for aml_xcreatefield, added flags argument
ok @@canacar
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.127 2008/06/13 00:04:33 jordan Exp $ */
d107 1
a797 1
int64_t aml_str2int(const char *);
a886 22
aml_str2int(const char *str)
{
	int64_t val = 0;
	int n;

	/* process max 64 bit [0-9a-zA-Z] */
	for (n = 0; n < 16; n++) {
		int ch = str[n];
		if (ch >= '0' && ch <= '9')
			val = (val << 4) + ch - '0';
		else if (ch >= 'a' && ch <= 'f')
			val = (val << 4) + ch - 'a' + 10;
		else if (ch >= 'A' && ch <= 'F')
			val = (val << 4) + ch - 'A' + 10;
		else	/* first non-digit ends conversion */
			break;
	}

	return val;
}

int64_t
d905 1
a905 1
		aml_str2int(rval->v_string);
a1816 1
int64_t		aml_hextoint(const char *);
@


1.127
log
@Cleanup, remove old/unused functions
ok @@canacaR
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.126 2008/06/12 20:36:50 jordan Exp $ */
d2397 1
a2397 1
    struct aml_value *, int);
d2672 1
a2672 1
		struct aml_value *index, int indexval)
d2688 8
d2702 1
a2733 1
			rv->v_field.flags = flags;
d2738 1
a2738 1
				    blen, NULL, 0);
d2743 1
a2743 1
				    blen, index, bpos>>3);
d2748 1
a2748 1
				    blen, index, indexval);
d3857 1
a3857 1
				    8 * idx, 8, NULL, 0);
d4055 2
a4056 4
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer,
		    opargs[2]->v_integer, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
d4060 2
a4061 4
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer,    
		    1, NULL, 0);	
		aml_xdelref(&tmp, htab->mnem);
d4065 2
a4066 5
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8,  
		    8, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_BYTEACC;
d4070 2
a4071 5
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    16, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_WORDACC;
d4075 2
a4076 5
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    32, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_DWORDACC;
d4080 2
a4081 5
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    64, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_QWORDACC;
@


1.126
log
@Removed old AML disassembler code
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.125 2008/06/12 20:30:09 jordan Exp $ */
a49 3
#if 0
int			aml_cmpvalue(struct aml_value *, struct aml_value *, int);
#endif
d98 6
a104 3
struct aml_value	*aml_callmethod(struct aml_scope *, struct aml_value *);
struct aml_value	*aml_evalmethod(struct aml_scope *, struct aml_node *,
			    int, struct aml_value *, struct aml_value *);
a657 55
/* Create name/value pair in namespace */
struct aml_node *
aml_createname(struct aml_node *root, const void *vname, struct aml_value *value)
{
	struct aml_node *node, **pp;
	uint8_t *name = (uint8_t *)vname;
	int count;

	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name == AMLOP_PARENTPREFIX && root) {
		root = root->parent;
		name++;
	}
	switch (*name) {
	case 0x00:
		return root;
	case AMLOP_MULTINAMEPREFIX:
		count = name[1];
		name += 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		name += 1;
		break;
	default:
		count = 1;
		break;
	}
	node = NULL;
	while (count-- && root) {
		/* Create new name if it does not exist */
		if ((node = __aml_search(root, name, 0)) == NULL) {
			node = acpi_os_malloc(sizeof(struct aml_node));

			memcpy((void *)node->name, name, AML_NAMESEG_LEN);
			for (pp = &root->child; *pp; pp = &(*pp)->sibling)
				;
			node->parent = root;
			node->sibling = NULL;
			*pp = node;
		}
		root = node;
		name += AML_NAMESEG_LEN;
	}
	/* If node created, set value pointer */
	if (node && value) {
		node->value = value;
		value->node = node;
	}
	return node;
}

a1241 39
#if 0
int
aml_cmpvalue(struct aml_value *lhs, struct aml_value *rhs, int opcode)
{
	int rc, lt, rt;

	rc = 0;
	lt = lhs->type & ~AML_STATIC;
	rt = rhs->type & ~AML_STATIC;
	if (lt == rt) {
		switch (lt) {
		case AML_OBJTYPE_STATICINT:
		case AML_OBJTYPE_INTEGER:
			rc = (lhs->v_integer - rhs->v_integer);
			break;
		case AML_OBJTYPE_STRING:
			rc = strncmp(lhs->v_string, rhs->v_string,
			    min(lhs->length, rhs->length));
			if (rc == 0)
				rc = lhs->length - rhs->length;
			break;
		case AML_OBJTYPE_BUFFER:
			rc = memcmp(lhs->v_buffer, rhs->v_buffer,
			    min(lhs->length, rhs->length));
			if (rc == 0)
				rc = lhs->length - rhs->length;
			break;
		}
	} else if (lt == AML_OBJTYPE_INTEGER) {
		rc = lhs->v_integer - aml_val2int(rhs);
	} else if (rt == AML_OBJTYPE_INTEGER) {
		rc = aml_val2int(lhs) - rhs->v_integer;
	} else {
		aml_die("mismatched compare\n");
	}
	return aml_evalexpr(rc, 0, opcode);
}
#endif

d1608 3
a1610 2
		tmp = aml_allocvalue(def->type, def->ival, def->bval);
		aml_createname(&aml_root, def->name, tmp);
a2092 5
void ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg);
uint8_t *aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg);
@


1.125
log
@Fixed AMLOP_LOAD for _PSS on Thinkpad
ok @@gwk
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.124 2008/06/12 19:05:42 jordan Exp $ */
a60 1
struct aml_value 	*aml_getstack(struct aml_scope *, int);
@


1.124
log
@Fixed memory leaks for AML parser
added new stack handling interface
removed delay during parsing
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.123 2008/06/11 04:42:09 marco Exp $ */
d4247 1
a4247 1
#if 0
d4249 2
d4252 2
a4253 2
		    tmp->v_opregion.iolen,
		    opargs[1], ACPI_IOREAD);
d4261 2
a4262 1
		/* Parse block */
a4264 1
#endif
@


1.123
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.122 2008/06/08 17:20:52 art Exp $ */
d61 1
d71 3
a77 3
void			_aml_delref(struct aml_value **val, const char *, int);
void			aml_delref(struct aml_value **);
void			aml_addref(struct aml_value *);
a79 2
#define aml_delref(x) _aml_delref(x, __FUNCTION__, __LINE__)

d279 2
d294 3
a296 1
		for (idx = 0; idx < root->nargs; idx++) {
d298 2
a299 1
			aml_showvalue(&root->args[idx], 0);
d301 3
a303 2
		for (idx = 0; root->locals && idx < AML_MAX_LOCAL; idx++) {
			if (root->locals[idx].type) {
d305 1
a305 1
				aml_showvalue(&root->locals[idx], 0);
d728 1
a728 1
		aml_delref(&onode->value);
d1104 1
a1104 1
		aml_addref(rv);
d1131 3
d1136 2
a1137 2
		aml_delref(&val->v_field.ref1);
		aml_delref(&val->v_field.ref2);
a1143 28
/* Increase reference count */
void
aml_addref(struct aml_value *val)
{
	if (val)
		val->refcnt++;
}

/* Decrease reference count + delete value */

void
_aml_delref(struct aml_value **val, const char *fn, int line)
{
	if (val == NULL || *val == NULL)
		return;
	if ((*val)->stack > 0) {
		/* Don't delete locals */
		return;
	}
	if ((*val)->refcnt & ~0xFF)
		printf("-- invalid ref: %x:%s:%d\n", (*val)->refcnt, fn, line);
	if (--(*val)->refcnt == 0) {
		aml_freevalue(*val);
		acpi_os_free(*val);
		*val = NULL;
	}
}

d1677 1
a1677 1
	fa = scope->args[0].v_objref.ref;
a1931 2
void		aml_xaddref(struct aml_value *, const char *);
void		aml_xdelref(struct aml_value **, const char *);
d2019 25
d2049 1
a2053 3
	scope = aml_xfindscope(scope, AMLOP_METHOD, 0);
	if (scope == NULL)
		return;
d2055 2
a2056 1
		if (scope->args[idx].type) {
d2058 1
a2058 1
			aml_showvalue(scope->args[idx].v_objref.ref, 10);
d2062 2
a2063 1
		if (scope->locals[idx].type) {
d2065 1
a2065 1
			aml_showvalue(&scope->locals[idx], 10);
a2111 1
	int idx;
d2122 1
a2122 3
		for (idx=0; idx<8; idx++) {
			aml_freevalue(&scope->locals[idx]);
		}
d2127 1
a2127 3
		for (idx=0; idx<7; idx++) {
			aml_freevalue(&scope->args[idx]);
		}
a3381 1
		ms->args = acpi_os_malloc(7 * sizeof(struct aml_value));
d3385 3
a3387 2
			ms->args[idx].type = AML_OBJTYPE_OBJREF;
			ms->args[idx].v_objref.type = AMLOP_ARG0 + idx;
d3389 1
a3389 2
				ms->args[idx].v_objref.ref = &argv[idx];
				argv[idx].refcnt = 99;
d3392 3
a3394 2
				ms->args[idx].v_objref.ref = 
				    aml_xparse(scope, 't', "ARGX");
a3628 2
	delay(amlop_delay);

a3712 11
			mscope = aml_xfindscope(scope, AMLOP_METHOD, 0);
			if (mscope->locals == NULL) {
				mscope->locals = acpi_os_malloc(8 * sizeof(struct aml_value));
			}
			rv = &mscope->locals[opcode - AMLOP_LOCAL0];
			if (rv->refcnt == 0) {
				rv->refcnt++;
			}
			rv->stack = opcode;
			rv->node  = mscope->node;
			break;
d3714 1
a3714 2
			mscope = aml_xfindscope(scope, AMLOP_METHOD, 0);
			rv = mscope->args[opcode - AMLOP_ARG0].v_objref.ref;
a3725 12
	/* Check for Op(Src1,Src2,Src1) type operations */
	for (idx=0; optype[idx]; idx++) {
		int jdx;
		for (jdx=idx+1; optype[jdx]; jdx++) {
			if (opargs[idx] == opargs[jdx]) {
				dnprintf(12,"STORE SAME %s %d,%d -> [%s] ", 
				    htab->mnem, idx, jdx, 
				    aml_nodename(scope->node));
			}
		}
	}

a3741 3
		my_ret = opargs[0];
		aml_xaddref(my_ret, htab->mnem);
		break;
a3748 1
		/* These are not allocated dynamically but do not have node */
a4343 1
		my_ret->stack = opcode;
@


1.122
log
@Add a malloc type for ACPI and use it for _acpi_os_malloc and free.

kettenis@@ ok
@
text
@d1 1
a1 2

/* $OpenBSD: dsdt.c,v 1.121 2008/06/08 15:36:57 canacar Exp $ */
@


1.121
log
@Implement aml_str2val() ok marco@@
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.120 2008/06/08 02:52:40 deraadt Exp $ */
d409 1
a409 1
	sptr = malloc(size+sizeof(*sptr), M_DEVBUF, M_WAITOK | M_ZERO);
d426 1
a426 1
		free(sptr, M_DEVBUF);
@


1.120
log
@unused globals and defines; ok toby
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.119 2008/06/07 17:30:50 marco Exp $ */
d849 1
a849 1
int64_t aml_str2int(const char *, int);
d939 1
a939 1
aml_str2int(const char *str, int radix)
d941 17
a957 3
	/* XXX: fixme */
	aml_die("aml_str2int not implemented\n");
	return 0;
d979 1
a979 3
		ival = (strncmp(rval->v_string, "0x", 2) == 0) ?
		    aml_str2int(rval->v_string+2, 16) :
		    aml_str2int(rval->v_string, 10);
@


1.119
log
@Move #if 0 up to include currently unused fixup tables.
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.118 2008/06/06 09:15:32 marco Exp $ */
d21 1
a43 2
#define AML_CHECKSTACK()

a50 7
#define aml_valid(pv)	 ((pv) != NULL)

#define aml_ipaddr(n) ((n)-aml_root.start)

extern int hz;

struct aml_scope;
d109 1
a109 1
const char *aml_getname(const char *);
@


1.118
log
@Shrink acpi some more for floppies and while here re-enable acpi on the
floppies.  Fixes crazy sony vaio kettenis has.

tested by deraadt
ok deraadt jordan kettenis
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.117 2008/06/04 18:20:09 marco Exp $ */
d1610 1
a1630 1
#if 0
@


1.117
log
@Fix panic on my i386 box when local variable isnt handled properly.

code from jordan
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.116 2008/06/01 17:59:55 marco Exp $ */
d341 1
d376 1
d2995 1
d3361 1
@


1.116
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.114 2008/05/15 23:23:09 jordan Exp $ */
d2943 4
a3764 11
		if (ret_type == AML_ARG_INTEGER) {
			/* Return copy of integer value */
			aml_xconvert(my_ret, &my_ret, AML_OBJTYPE_INTEGER, 0);
			ival = my_ret->v_integer;
			aml_xdelref(&my_ret, "local.int");
			my_ret = NULL;
		}
		else if (ret_type == AML_ARG_TARGET) {
			/* Store to LocalX: free object */
			aml_freevalue(my_ret);
		}
d4365 1
@


1.115
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.109 2008/02/07 17:48:59 henning Exp $ */
d37 4
d59 1
a59 1

d61 1
a129 18
struct aml_value *aml_parsenamed(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsenamedscope(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemath(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsecompare(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseif(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsewhile(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufpkg(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemethod(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsesimple(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsefieldunit(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufferfield(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc3(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemuxaction(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc2(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsematch(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseref(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsestring(struct aml_scope *, int, struct aml_value *);

d142 13
a154 13
	{ AMLOP_ZERO,		"Zero",		"c",	aml_parsesimple },
	{ AMLOP_ONE,		"One",		"c",	aml_parsesimple },
	{ AMLOP_ONES,		"Ones",		"c",	aml_parsesimple },
	{ AMLOP_REVISION,	"Revision",	"R",	aml_parsesimple },
	{ AMLOP_BYTEPREFIX,	".Byte",	"b",	aml_parsesimple },
	{ AMLOP_WORDPREFIX,	".Word",	"w",	aml_parsesimple },
	{ AMLOP_DWORDPREFIX,	".DWord",	"d",	aml_parsesimple },
	{ AMLOP_QWORDPREFIX,	".QWord",	"q",	aml_parsesimple },
	{ AMLOP_STRINGPREFIX,	".String",	"a",	aml_parsesimple },
	{ AMLOP_DEBUG,		"DebugOp",	"D",	aml_parsesimple },
	{ AMLOP_BUFFER,		"Buffer",	"piB",	aml_parsebufpkg },
	{ AMLOP_PACKAGE,	"Package",	"pbT",	aml_parsebufpkg },
	{ AMLOP_VARPACKAGE,	"VarPackage",	"piT",	aml_parsebufpkg },
d157 15
a171 15
	{ AMLOP_LOCAL0,		"Local0",	"L",	aml_parseref },
	{ AMLOP_LOCAL1,		"Local1",	"L",	aml_parseref },
	{ AMLOP_LOCAL2,		"Local2",	"L",	aml_parseref },
	{ AMLOP_LOCAL3,		"Local3",	"L",	aml_parseref },
	{ AMLOP_LOCAL4,		"Local4",	"L",	aml_parseref },
	{ AMLOP_LOCAL5,		"Local5",	"L",	aml_parseref },
	{ AMLOP_LOCAL6,		"Local6",	"L",	aml_parseref },
	{ AMLOP_LOCAL7,		"Local7",	"L",	aml_parseref },
	{ AMLOP_ARG0,		"Arg0",		"A",	aml_parseref },
	{ AMLOP_ARG1,		"Arg1",		"A",	aml_parseref },
	{ AMLOP_ARG2,		"Arg2",		"A",	aml_parseref },
	{ AMLOP_ARG3,		"Arg3",		"A",	aml_parseref },
	{ AMLOP_ARG4,		"Arg4",		"A",	aml_parseref },
	{ AMLOP_ARG5,		"Arg5",		"A",	aml_parseref },
	{ AMLOP_ARG6,		"Arg6",		"A",	aml_parseref },
d174 1
a174 1
	{ AMLOP_IF,		"If",		"pI",	aml_parseif },
d176 1
a176 1
	{ AMLOP_WHILE,		"While",	"piT",	aml_parsewhile },
d179 4
a182 4
	{ AMLOP_RETURN,		"Return",	"t",	aml_parseref },
	{ AMLOP_FATAL,		"Fatal",	"bdi",	aml_parsemisc2 },
	{ AMLOP_NOP,		"Nop",		"",	aml_parsesimple },
	{ AMLOP_BREAKPOINT,	"BreakPoint",	"",     aml_parsesimple },
d185 17
a201 17
	{ AMLOP_INCREMENT,	"Increment",	"t",	aml_parsemath },
	{ AMLOP_DECREMENT,	"Decrement",	"t",	aml_parsemath },
	{ AMLOP_ADD,		"Add",		"iir",	aml_parsemath },
	{ AMLOP_SUBTRACT,	"Subtract",	"iir",	aml_parsemath },
	{ AMLOP_MULTIPLY,	"Multiply",	"iir",	aml_parsemath },
	{ AMLOP_DIVIDE,		"Divide",	"iirr",	aml_parsemath },
	{ AMLOP_SHL,		"ShiftLeft",	"iir",	aml_parsemath },
	{ AMLOP_SHR,		"ShiftRight",	"iir",	aml_parsemath },
	{ AMLOP_AND,		"And",		"iir",	aml_parsemath },
	{ AMLOP_NAND,		"Nand",		"iir",	aml_parsemath },
	{ AMLOP_OR,		"Or",		"iir",	aml_parsemath },
	{ AMLOP_NOR,		"Nor",		"iir",	aml_parsemath },
	{ AMLOP_XOR,		"Xor",		"iir",	aml_parsemath },
	{ AMLOP_NOT,		"Not",		"ir",	aml_parsemath },
	{ AMLOP_MOD,		"Mod",		"iir",	aml_parsemath },
	{ AMLOP_FINDSETLEFTBIT,	"FindSetLeftBit", "ir",	aml_parsemath },
	{ AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",aml_parsemath },
d204 9
a212 9
	{ AMLOP_LAND,		"LAnd",		"ii",	aml_parsemath },
	{ AMLOP_LOR,		"LOr",		"ii",	aml_parsemath },
	{ AMLOP_LNOT,		"LNot",		"i",	aml_parsemath },
	{ AMLOP_LNOTEQUAL,	"LNotEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LLESSEQUAL,	"LLessEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LGREATEREQUAL,	"LGreaterEqual", "tt",	aml_parsecompare },
	{ AMLOP_LEQUAL,		"LEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LGREATER,	"LGreater",	"tt",	aml_parsecompare },
	{ AMLOP_LLESS,		"LLess",	"tt",	aml_parsecompare },
d215 13
a227 13
	{ AMLOP_NAMECHAR,	".NameRef",	"n",	aml_parsesimple	},
	{ AMLOP_ALIAS,		"Alias",	"nN",	aml_parsenamed },
	{ AMLOP_NAME,		"Name",	"Nt",	aml_parsenamed },
	{ AMLOP_EVENT,		"Event",	"N",	aml_parsenamed },
	{ AMLOP_MUTEX,		"Mutex",	"Nb",	aml_parsenamed },
	{ AMLOP_DATAREGION,	"DataRegion",	"Nttt",	aml_parsenamed },
	{ AMLOP_OPREGION,	"OpRegion",	"Nbii",	aml_parsenamed },
	{ AMLOP_SCOPE,		"Scope",	"pNT",	aml_parsenamedscope },
	{ AMLOP_DEVICE,		"Device",	"pNT",	aml_parsenamedscope },
	{ AMLOP_POWERRSRC,	"Power Resource", "pNbwT", aml_parsenamedscope },
	{ AMLOP_THERMALZONE,	"ThermalZone",	"pNT",	aml_parsenamedscope },
	{ AMLOP_PROCESSOR,	"Processor",	"pNbdbT", aml_parsenamedscope },
	{ AMLOP_METHOD,		"Method",	"pNfM",	aml_parsemethod },
d230 9
a238 9
	{ AMLOP_FIELD,		"Field",	"pnfF",		aml_parsefieldunit },
	{ AMLOP_INDEXFIELD,	"IndexField",	"pntfF",	aml_parsefieldunit },
	{ AMLOP_BANKFIELD,	"BankField",	"pnnifF",	aml_parsefieldunit },
	{ AMLOP_CREATEFIELD,	"CreateField",	"tiiN",		aml_parsebufferfield },
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEWORDFIELD, "CreateWordField", "tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEBYTEFIELD, "CreateByteField", "tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEBITFIELD,	"CreateBitField", "tiN",	aml_parsebufferfield },
d241 1
a241 1
	{ AMLOP_TOINTEGER,	"ToInteger",	"tr",	aml_parsemath },
d243 6
a248 6
	{ AMLOP_TODECSTRING,	"ToDecString",	"ir",	aml_parsestring },
	{ AMLOP_TOHEXSTRING,	"ToHexString",	"ir",	aml_parsestring },
	{ AMLOP_TOSTRING,	"ToString",	"t",	aml_parsestring },
	{ AMLOP_MID,		"Mid",		"tiir",	aml_parsestring },
	{ AMLOP_FROMBCD,	"FromBCD",	"ir",	aml_parsemath },
	{ AMLOP_TOBCD,		"ToBCD",	"ir",	aml_parsemath },
d251 10
a260 10
	{ AMLOP_ACQUIRE,	"Acquire",	"tw",	aml_parsemuxaction },
	{ AMLOP_RELEASE,	"Release",	"t",	aml_parsemuxaction },
	{ AMLOP_SIGNAL,		"Signal",	"t",	aml_parsemuxaction },
	{ AMLOP_WAIT,		"Wait",		"ti",	aml_parsemuxaction },
	{ AMLOP_RESET,		"Reset",	"t",	aml_parsemuxaction },

	{ AMLOP_INDEX,		"Index",	"tir",	aml_parseref },
	{ AMLOP_DEREFOF,	"DerefOf",	"t",	aml_parseref },
	{ AMLOP_REFOF,		"RefOf",	"t",	aml_parseref },
	{ AMLOP_CONDREFOF,	"CondRef",	"nr",	aml_parseref },
d263 3
a265 3
	{ AMLOP_STALL,		"Stall",	"i",	aml_parsemisc2 },
	{ AMLOP_SLEEP,		"Sleep",	"i",	aml_parsemisc2 },
	{ AMLOP_LOAD,		"Load",		"nt",	aml_parseref },
d267 2
a268 2
	{ AMLOP_STORE,		"Store",	"tr",	aml_parseref },
	{ AMLOP_CONCAT,		"Concat",	"ttr",	aml_parsestring },
d270 5
a274 5
	{ AMLOP_NOTIFY,		"Notify",	"ti",	aml_parsemisc2 },
	{ AMLOP_SIZEOF,		"Sizeof",	"t",	aml_parsemisc3 },
	{ AMLOP_MATCH,		"Match",	"tbibii", aml_parsematch },
	{ AMLOP_OBJECTTYPE,	"ObjectType",	"t",	aml_parsemisc3 },
	{ AMLOP_COPYOBJECT,	"CopyObject",	"tr",	aml_parseref },
a456 67
int
acpi_mutex_acquire(struct aml_value *val, int timeout)
{
	/* XXX we currently do not have concurrency so assume mutex succeeds */
	dnprintf(50, "acpi_mutex_acquire\n");

	return (0);
#if 0
	struct acpi_mutex *mtx = val->v_mutex;
	int rv = 0, ts, tries = 0;

	if (val->type != AML_OBJTYPE_MUTEX) {
		printf("acpi_mutex_acquire: invalid mutex\n");
		return (1);
	}

	if (timeout == 0xffff)
		timeout = 0;

	/* lock recursion be damned, panic if that happens */
	rw_enter_write(&mtx->amt_lock);
	while (mtx->amt_ref_count) {
		rw_exit_write(&mtx->amt_lock);
		/* block access */
		ts = tsleep(mtx, PWAIT, mtx->amt_name, timeout / hz);
		if (ts == EWOULDBLOCK) {
			rv = 1; /* mutex not acquired */
			goto done;
		}
		tries++;
		rw_enter_write(&mtx->amt_lock);
	}

	mtx->amt_ref_count++;
	rw_exit_write(&mtx->amt_lock);
done:
	return (rv);
#endif
}

void
acpi_mutex_release(struct aml_value *val)
{
	dnprintf(50, "acpi_mutex_release\n");
#if 0
	struct acpi_mutex *mtx = val->v_mutex;

	/* sanity */
	if (val->type != AML_OBJTYPE_MUTEX) {
		printf("acpi_mutex_acquire: invalid mutex\n");
		return;
	}

	rw_enter_write(&mtx->amt_lock);

	if (mtx->amt_ref_count == 0) {
		printf("acpi_mutex_release underflow %s\n", mtx->amt_name);
		goto done;
	}

	mtx->amt_ref_count--;
	wakeup(mtx); /* wake all of them up */
done:
	rw_exit_write(&mtx->amt_lock);
#endif
}

d461 1
d473 1
a494 21
/* Read/Write to hardware I/O fields */
void
aml_gasio(struct acpi_softc *sc, int type, uint64_t base, uint64_t length,
    int bitpos, int bitlen, int size, void *buf, int mode)
{
	dnprintf(10, "-- aml_gasio: %.2x"
	    " base:%llx len:%llx bpos:%.4x blen:%.4x sz:%.2x mode=%s\n",
	    type, base, length, bitpos, bitlen, size,
	    mode==ACPI_IOREAD?"read":"write");
	acpi_gasio(sc, mode, type, base+(bitpos>>3),
	    (size>>3), (bitlen>>3), buf);
#ifdef ACPI_DEBUG
	while (bitlen > 0) {
		dnprintf(10, "%.2x ", *(uint8_t *)buf);
		buf++;
		bitlen -=8;
	}
	dnprintf(10, "\n");
#endif
}

d572 1
a572 1
struct aml_node *__aml_search(struct aml_node *, uint8_t *);
d578 1
a578 1
__aml_search(struct aml_node *root, uint8_t *nameseg)
d580 3
d585 19
a603 3
	for (root = root->child; root; root = root->sibling) {
		if (!memcmp(root->name, nameseg, AML_NAMESEG_LEN))
			return root;
d605 1
a605 1
	return NULL;
d695 1
a695 1
		if ((node = __aml_search(root, name)) == NULL) {
a715 51
/* Search namespace for a named node */
struct aml_node *
aml_searchname(struct aml_node *root, const void *vname)
{
	struct aml_node *node;
	uint8_t *name = (uint8_t *)vname;
	int count;

	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name == AMLOP_PARENTPREFIX && root) {
		root = root->parent;
		name++;
	}
	if (strlen(name) < AML_NAMESEG_LEN) {
		aml_die("bad name");
	}
	switch (*name) {
	case 0x00:
		return root;
	case AMLOP_MULTINAMEPREFIX:
		count = name[1];
		name += 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		name += 1;
		break;
	default:
		if (name[4] == '.') {
			/* Called from user code */
			while (*name && (root = __aml_search(root, name)) != NULL) {
				name += AML_NAMESEG_LEN+1;
			}
			return root;
		}
		/* Special case.. search relative for name */
		while (root && (node = __aml_search(root, name)) == NULL) {
			root = root->parent;
		}
		return node;
	}
	/* Search absolute for name*/
	while (count-- && (root = __aml_search(root, name)) != NULL) {
		name += AML_NAMESEG_LEN;
	}
	return root;
}

a740 1
struct aml_value	*aml_alloctmp(struct aml_scope *, int);
a743 2
int			aml_parsenode(struct aml_scope *, struct aml_node *,
			    uint8_t *, uint8_t **, struct aml_value *);
a749 21
/* Allocate temporary storage in this scope */
struct aml_value *
aml_alloctmp(struct aml_scope *scope, int narg)
{
	struct aml_vallist *tmp;

	/* Allocate array of temp values */
	tmp = (struct aml_vallist *)acpi_os_malloc(sizeof(struct aml_vallist) +
	    narg * sizeof(struct aml_value));

	tmp->obj = (struct aml_value *)&tmp[1];
	tmp->nobj = narg;

	/* Link into scope */
	tmp->next = scope->tmpvals;
	scope->tmpvals = tmp;

	/* Return array of values */
	return tmp->obj;
}

a794 20
int
aml_parsenode(struct aml_scope *parent, struct aml_node *node, uint8_t *start,
    uint8_t **end, struct aml_value *res)
{
	struct aml_scope *scope;

	/* Don't parse zero-length scope */
	if (start == *end)
		return 0;
	scope = aml_pushscope(parent, start, *end, node);
	if (res == NULL)
		res = aml_alloctmp(scope, 1);
	while (scope != parent) {
		while (scope->pos < scope->end)
			aml_parseop(scope, res, 't');
		scope = aml_popscope(scope);
	}
	return 0;
}

a797 3
void aml_setbufint(struct aml_value *, int, int, struct aml_value *);
void aml_getbufint(struct aml_value *, int, int, struct aml_value *);
void aml_fieldio(struct aml_scope *, struct aml_value *, struct aml_value *, int);
a800 55
/* Copy from a bufferfield to an integer/buffer */
void
aml_setbufint(struct aml_value *dst, int bitpos, int bitlen,
    struct aml_value *src)
{
	if (src->type != AML_OBJTYPE_BUFFER) {
#ifndef SMALL_KERNEL
		aml_showvalue(src, 0);
#endif
		aml_die("wrong setbufint type %d\n", src->type);
	}
#if 1
	/* Return buffer type */
	_aml_setvalue(dst, AML_OBJTYPE_BUFFER, (bitlen+7)>>3, NULL);
	aml_bufcpy(dst->v_buffer, 0, src->v_buffer, bitpos, bitlen);
#else
	if (bitlen < aml_intlen) {
		/* XXX: Endian issues?? */
		/* Return integer type */
		_aml_setvalue(dst, AML_OBJTYPE_INTEGER, 0, NULL);
		aml_bufcpy(&dst->v_integer, 0, src->v_buffer, bitpos, bitlen);
	} else {
		/* Return buffer type */
		_aml_setvalue(dst, AML_OBJTYPE_BUFFER, (bitlen+7)>>3, NULL);
		aml_bufcpy(dst->v_buffer, 0, src->v_buffer, bitpos, bitlen);
	}
#endif
}

/* Copy from a string/integer/buffer to a bufferfield */
void
aml_getbufint(struct aml_value *src, int bitpos, int bitlen,
    struct aml_value *dst)
{
	if (dst->type != AML_OBJTYPE_BUFFER)
		aml_die("wrong getbufint type %d\n", src->type);
	switch (src->type) {
	case AML_OBJTYPE_INTEGER:
		if (bitlen >= aml_intlen)
			bitlen = aml_intlen;
		aml_bufcpy(dst->v_buffer, bitpos, &src->v_integer, 0, bitlen);
		break;
	case AML_OBJTYPE_BUFFER:
		if (bitlen >= 8*src->length)
			bitlen = 8*src->length;
		aml_bufcpy(dst->v_buffer, bitpos, src->v_buffer, 0, bitlen);
		break;
	case AML_OBJTYPE_STRING:
		if (bitlen >= 8*src->length)
			bitlen = 8*src->length;
		aml_bufcpy(dst->v_buffer, bitpos, src->v_string, 0, bitlen);
		break;
	}
}

d804 2
a805 1

a851 206
void *aml_getbuffer(struct aml_value *, int *);

void *
aml_getbuffer(struct aml_value *val, int *bitlen)
{
	switch (val->type) {
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STATICINT:
		*bitlen = aml_intlen;
		return (&val->v_integer);

	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_STRING:
		*bitlen = val->length<<3;
		return (val->v_buffer);

	default:
		aml_die("getvbi");
	}

	return (NULL);
}

/*
 * Buffer/Region: read/write to bitfields
 */
void
aml_fieldio(struct aml_scope *scope, struct aml_value *field,
    struct aml_value *res, int mode)
{
	struct aml_value *pop, tf;
	int bpos, blen, aligned, mask;
	void    *iobuf, *iobuf2;
	uint64_t iobase;

	pop = field->v_field.ref1;
	bpos = field->v_field.bitpos;
	blen = field->v_field.bitlen;

	dnprintf(55,"--fieldio: %s [%s] bp:%.4x bl:%.4x\n",
	    mode == ACPI_IOREAD ? "rd" : "wr",
	    aml_nodename(field->node), bpos, blen);

	aml_lockfield(scope, field);
	switch (field->v_field.type) {
	case AMLOP_INDEXFIELD:
		/* Set Index */
		memcpy(&tf, field->v_field.ref2, sizeof(struct aml_value));
		tf.v_field.bitpos += (bpos & 7);
		tf.v_field.bitlen  = blen;

		aml_setvalue(scope, pop, NULL, bpos>>3);
		aml_fieldio(scope, &tf, res, mode);
#ifdef ACPI_DEBUG
		dnprintf(55, "-- post indexfield %x,%x @@ %x,%x\n",
		    bpos & 3, blen,
		    field->v_field.ref2->v_field.bitpos,
		    field->v_field.ref2->v_field.bitlen);

		iobuf = aml_getbuffer(res, &aligned);
		aml_dump(aligned >> 3, iobuf);
#endif
		break;
	case AMLOP_BANKFIELD:
		/* Set Bank */
		memcpy(&tf, field->v_field.ref2, sizeof(struct aml_value));
		tf.v_field.bitpos += (bpos & 7);
		tf.v_field.bitlen  = blen;

		aml_setvalue(scope, pop, NULL, field->v_field.ref3);
		aml_fieldio(scope, &tf, res, mode);
#ifdef ACPI_DEBUG
		dnprintf(55, "-- post bankfield %x,%x @@ %x,%x\n",
		    bpos & 3, blen,
		    field->v_field.ref2->v_field.bitpos,
		    field->v_field.ref2->v_field.bitlen);

		iobuf = aml_getbuffer(res, &aligned);
		aml_dump(aligned >> 3, iobuf);
#endif
		break;
	case AMLOP_FIELD:
		/* This is an I/O field */
		if (pop->type != AML_OBJTYPE_OPREGION)
			aml_die("Not an opregion\n");

		/* Get field access size */
		switch (AML_FIELD_ACCESS(field->v_field.flags)) {
		case AML_FIELD_ANYACC:
		case AML_FIELD_BYTEACC:
			mask = 7;
			break;
		case AML_FIELD_WORDACC:
			mask = 15;
			break;
		case AML_FIELD_DWORDACC:
			mask = 31;
			break;
		case AML_FIELD_QWORDACC:
			mask = 63;
			break;
		}

		/* Pre-allocate return value for reads */
		if (mode == ACPI_IOREAD)
			_aml_setvalue(res, AML_OBJTYPE_BUFFER,
			    (field->v_field.bitlen+7)>>3, NULL);

		/* Get aligned bitpos/bitlength */
		blen = ((bpos & mask) + blen + mask) & ~mask;
		bpos = bpos & ~mask;
		aligned = (bpos == field->v_field.bitpos &&
		    blen == field->v_field.bitlen);
		iobase = pop->v_opregion.iobase;

		/* Check for aligned reads/writes */
		if (aligned) {
			iobuf = aml_getbuffer(res, &aligned);
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);
#ifdef ACPI_DEBUG
			dnprintf(55, "aligned: %s @@ %.4x:%.4x + %.4x\n",
			    mode == ACPI_IOREAD ? "rd" : "wr",
			    bpos, blen, aligned);

			aml_dump(blen >> 3, iobuf);
#endif
		}
		else if (mode == ACPI_IOREAD) {
			iobuf = acpi_os_malloc(blen>>3);
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);

			/* ASSERT: res is buffer type as it was set above */
			aml_bufcpy(res->v_buffer, 0, iobuf,
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

#ifdef ACPI_DEBUG
			dnprintf(55,"non-aligned read: %.4x:%.4x : ",
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

			aml_dump(blen >> 3, iobuf);
			dnprintf(55,"post-read: ");
			aml_dump((field->v_field.bitlen+7)>>3, res->v_buffer);
#endif
			acpi_os_free(iobuf);
		}
		else {
			iobuf = acpi_os_malloc(blen >> 3);
			switch (AML_FIELD_UPDATE(field->v_field.flags)) {
			case AML_FIELD_WRITEASONES:
				memset(iobuf, 0xFF, blen >> 3);
				break;
			case AML_FIELD_PRESERVE:
				aml_gasio(scope->sc, pop->v_opregion.iospace,
				    iobase, pop->v_opregion.iolen, bpos, blen,
				    mask + 1, iobuf, ACPI_IOREAD);
				break;
			}
			/* Copy into IOBUF */
			iobuf2 = aml_getbuffer(res, &aligned);
			aml_bufcpy(iobuf, field->v_field.bitpos & mask,
			    iobuf2, 0, field->v_field.bitlen);

#ifdef ACPI_DEBUG
			dnprintf(55,"non-aligned write: %.4x:%.4x : ",
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

			aml_dump(blen >> 3, iobuf);
#endif
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);

			acpi_os_free(iobuf);
		}
		/* Verify that I/O is in range */
#if 0
		/*
		 * XXX: some I/O ranges are on dword boundaries, but their
		 * length is incorrect eg. dword access, but length of
		 * opregion is 2 bytes.
		 */
		if ((bpos+blen) >= (pop->v_opregion.iolen * 8)) {
			aml_die("Out of bounds I/O!!! region:%x:%llx:%x %x\n",
			    pop->v_opregion.iospace, pop->v_opregion.iobase,
			    pop->v_opregion.iolen, bpos+blen);
		}
#endif
		break;
	default:
		/* This is a buffer field */
		if (mode == ACPI_IOREAD)
			aml_setbufint(res, bpos, blen, pop);
		else
			aml_getbufint(res, bpos, blen, pop);
		break;
	}
	aml_unlockfield(scope, field);
}

a855 3
struct aml_value *aml_derefvalue(struct aml_scope *, struct aml_value *, int);
#define aml_dereftarget(s, v)	aml_derefvalue(s, v, ACPI_IOWRITE)
#define aml_derefterm(s, v, m)	aml_derefvalue(s, v, ACPI_IOREAD)
d897 4
a900 2
		aml_showvalue(val->v_field.ref1, lvl);
		aml_showvalue(val->v_field.ref2, lvl);
d934 2
a935 2
		printf(" objref: %p index:%x\n", val->v_objref.ref,
		    val->v_objref.index);
a943 95
/* Perform DeRef on value. If ACPI_IOREAD, will perform buffer/IO field read */
struct aml_value *
aml_derefvalue(struct aml_scope *scope, struct aml_value *ref, int mode)
{
	struct aml_node *node;
	struct aml_value *tmp;
	int64_t tmpint;
	int argc, index;

	for (;;) {
		switch (ref->type) {
		case AML_OBJTYPE_NAMEREF:
			node = aml_searchname(scope->node, ref->v_nameref);
			if (node == NULL || node->value == NULL)
				return ref;
			ref = node->value;
			break;

		case AML_OBJTYPE_OBJREF:
			index = ref->v_objref.index;
			ref = aml_dereftarget(scope, ref->v_objref.ref);
			if (index != -1) {
				if (index >= ref->length)
					aml_die("index.buf out of bounds: "
					    "%d/%d\n", index, ref->length);
				switch (ref->type) {
				case AML_OBJTYPE_PACKAGE:
					ref = ref->v_package[index];
					break;
				case AML_OBJTYPE_STATICINT:
				case AML_OBJTYPE_INTEGER:
					/* Convert to temporary buffer */
					if (ref->node)
						aml_die("named integer index\n");
					tmpint = ref->v_integer;
					_aml_setvalue(ref, AML_OBJTYPE_BUFFER,
					    aml_intlen>>3, &tmpint);
					/* FALLTHROUGH */
				case AML_OBJTYPE_BUFFER:
				case AML_OBJTYPE_STRING:
					/* Return contents at this index */
					tmp = aml_alloctmp(scope, 1);
					if (mode == ACPI_IOREAD) {
						/* Shortcut: return integer
						 * contents of buffer at index */
						_aml_setvalue(tmp,
						    AML_OBJTYPE_INTEGER,
						    ref->v_buffer[index], NULL);
					} else {
						_aml_setvalue(tmp,
						    AML_OBJTYPE_BUFFERFIELD,
						    0, NULL);
						tmp->v_field.type =
						    AMLOP_CREATEBYTEFIELD;
						tmp->v_field.bitpos = index * 8;
						tmp->v_field.bitlen = 8;
						tmp->v_field.ref1 = ref;
						aml_addref(ref);
					}
					return tmp;
				default:
					aml_die("unknown index type: %d", ref->type);
					break;
				}
			}
			break;

		case AML_OBJTYPE_METHOD:
			/* Read arguments from current scope */
			argc = AML_METHOD_ARGCOUNT(ref->v_method.flags);
			tmp = aml_alloctmp(scope, argc+1);
			for (index = 0; index < argc; index++) {
				aml_parseop(scope, &tmp[index], 't');
				aml_addref(&tmp[index]);
			}
			ref = aml_evalmethod(scope, ref->node, argc, tmp, &tmp[argc]);
			break;

		case AML_OBJTYPE_BUFFERFIELD:
		case AML_OBJTYPE_FIELDUNIT:
			if (mode == ACPI_IOREAD) {
				/* Read I/O field into temporary storage */
				tmp = aml_alloctmp(scope, 1);
				aml_fieldio(scope, ref, tmp, ACPI_IOREAD);
				return tmp;
			}
			return ref;

		default:
			return ref;
		}

	}
}

d948 1
d1082 7
a1088 4
int is_local(struct aml_scope *, struct aml_value *);

int
is_local(struct aml_scope *scope, struct aml_value *val)
d1090 1
a1090 1
	int idx;
d1092 6
a1097 8
	if (val->stack == 0 || scope->locals == NULL)
		return (0);
	
	idx = val->stack - AMLOP_LOCAL0;
	if (idx < 0 || idx >= AML_MAX_LOCAL)
		aml_die("Invalid stack value!");

	return (val == &scope->locals[idx]);
a1099 1
/* Guts of the code: Assign one value to another.  LHS may contain a previous value */
d1101 1
a1101 2
aml_setvalue(struct aml_scope *scope, struct aml_value *lhs,
    struct aml_value *rhs, int64_t ival)
d1103 1
a1103 1
	struct aml_value tmpint;
d1105 15
a1119 23
	/* Use integer as result */
	memset(&tmpint, 0, sizeof(tmpint));
	if (rhs == NULL) {
		rhs = _aml_setvalue(&tmpint, AML_OBJTYPE_INTEGER, ival, NULL);
	}
	else if (rhs->type == AML_OBJTYPE_BUFFERFIELD ||
		 rhs->type == AML_OBJTYPE_FIELDUNIT)
	{
		aml_fieldio(scope, rhs, &tmpint, ACPI_IOREAD);
		rhs = &tmpint;
	}

	if (!is_local(scope, lhs))
		lhs = aml_dereftarget(scope, lhs);

	if (is_local(scope, lhs)) {
		/* ACPI: Overwrite writing to LocalX */
		aml_freevalue(lhs);
	}

	switch (lhs->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		aml_copyvalue(lhs, rhs);
d1123 2
a1124 119
		aml_fieldio(scope, lhs, rhs, ACPI_IOWRITE);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
#ifdef ACPI_DEBUG
		printf("-- debug --\n");
		aml_showvalue(rhs, 50);
#endif
		break;
	case AML_OBJTYPE_STATICINT:
		if (lhs->node) {
			lhs->v_integer = aml_val2int(rhs);
		}
		break;
	case AML_OBJTYPE_INTEGER:
		lhs->v_integer = aml_val2int(rhs);
		break;
	case AML_OBJTYPE_BUFFER:
	{
		char *buf;
		int len;

		if (lhs->node)
			dnprintf(40, "named.buffer\n");

		if (rhs->type == AML_OBJTYPE_BUFFER) {
			buf = rhs->v_buffer;
			len = rhs->length;
		} else if (rhs->type == AML_OBJTYPE_INTEGER ||
			   rhs->type == AML_OBJTYPE_STATICINT) {
			buf = (char *)&rhs->v_integer;
			len = sizeof(rhs->v_integer);
		} else if (rhs->type == AML_OBJTYPE_STRING) {
			len = rhs->length + 1;
			buf = rhs->v_string;
		} else {
			/* aml_showvalue(rhs); */
			aml_die("setvalue.buf : %x", aml_pc(scope->pos));
		}
		if (lhs->length < len)
			len = lhs->length;
		else
			memset(lhs->v_buffer, 0, lhs->length);
		memcpy(lhs->v_buffer, buf, len);
		/* XXX ACPI v30b 17.2.5.7 says truncate string "before
		   copying", so make sure the string is terminated */
		if (rhs->type == AML_OBJTYPE_STRING)
			lhs->v_buffer[lhs->length - 1] = '\0';
		break;
	}
	case AML_OBJTYPE_STRING:
		if (lhs->node)
			dnprintf(40, "named string\n");
		aml_freevalue(lhs);
		if (rhs->type == AML_OBJTYPE_STRING)
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length,
			    rhs->v_string);
		else if (rhs->type == AML_OBJTYPE_BUFFER)
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length,
			    rhs->v_buffer);
		else if (rhs->type == AML_OBJTYPE_INTEGER || rhs->type == AML_OBJTYPE_STATICINT) {
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, 10, NULL);
			snprintf(lhs->v_string, lhs->length, "%lld",
			    rhs->v_integer);
		} else {
			/* aml_showvalue(rhs); */
			aml_die("setvalue.str");
		}
		break;
	default:
		/* XXX: */
		dnprintf(10, "setvalue.unknown: %x", lhs->type);
		break;
	}
	aml_freevalue(&tmpint);
}

/* Allocate dynamic AML value
 *   type : Type of object to allocate (AML_OBJTYPE_XXXX)
 *   ival : Integer value (action depends on type)
 *   bval : Buffer value (action depends on type)
 */
struct aml_value *
aml_allocvalue(int type, int64_t ival, const void *bval)
{
	struct aml_value *rv;

	rv = (struct aml_value *)acpi_os_malloc(sizeof(struct aml_value));
	if (rv != NULL) {
		aml_addref(rv);
		return _aml_setvalue(rv, type, ival, bval);
	}
	return NULL;
}

void
aml_freevalue(struct aml_value *val)
{
	int idx;

	if (val == NULL)
		return;
	switch (val->type) {
	case AML_OBJTYPE_STRING:
		acpi_os_free(val->v_string);
		break;
	case AML_OBJTYPE_BUFFER:
		acpi_os_free(val->v_buffer);
		break;
	case AML_OBJTYPE_PACKAGE:
		for (idx = 0; idx < val->length; idx++) {
			aml_freevalue(val->v_package[idx]);
			acpi_os_free(val->v_package[idx]);
		}
		acpi_os_free(val->v_package);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_delref(&val->v_field.ref1);
		aml_delref(&val->v_field.ref2);
d1307 1
a1307 1
	dnprintf(50,"aml_evalexpr: %s %llx %llx = %llx\n",
d1313 1
d1350 1
a1374 47
struct aml_value *
aml_callmethod(struct aml_scope *scope, struct aml_value *val)
{
	while (scope->pos < scope->end)
		aml_parseterm(scope, val);
	return val;
}

/*
 * Evaluate an AML method
 *
 * Returns a copy of the result in res (must be freed by user)
 */
struct aml_value *
aml_evalmethod(struct aml_scope *parent, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	struct aml_scope *scope;

	scope = aml_pushscope(parent, node->value->v_method.start,
	    node->value->v_method.end, node);
	scope->args = argv;
	scope->nargs = argc;

	if (res == NULL)
		res = aml_alloctmp(scope, 1);

#ifdef ACPI_DEBUG
	dnprintf(10, "calling [%s] (%d args)\n",
	    aml_nodename(node), scope->nargs);
	for (argc = 0; argc < scope->nargs; argc++) {
		dnprintf(10, "  arg%d: ", argc);
		aml_showvalue(&scope->args[argc], 10);
	}
	node->value->v_method.fneval(scope, res);
	dnprintf(10, "[%s] returns: ", aml_nodename(node));
	aml_showvalue(res, 10);
#else
	node->value->v_method.fneval(scope, res);
#endif
	/* Free any temporary children nodes */
	aml_delchildren(node);
	aml_popscope(scope);

	return res;
}

a1380 78
int
aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	static int lastck;
	struct aml_node *ref;

	if (res)
		memset(res, 0, sizeof(struct aml_value));
	if (node == NULL || node->value == NULL)
		return (ACPI_E_BADVALUE);

	switch (node->value->type) {
	case AML_OBJTYPE_METHOD:
		aml_evalmethod(NULL, node, argc, argv, res);
		if (acpi_nalloc > lastck) {
			/* Check if our memory usage has increased */
			dnprintf(10, "Leaked: [%s] %d\n",
			    aml_nodename(node), acpi_nalloc);
			lastck = acpi_nalloc;
		}
		break;
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PACKAGE:
	case AML_OBJTYPE_EVENT:
	case AML_OBJTYPE_DEVICE:
	case AML_OBJTYPE_MUTEX:
	case AML_OBJTYPE_OPREGION:
	case AML_OBJTYPE_POWERRSRC:
	case AML_OBJTYPE_PROCESSOR:
	case AML_OBJTYPE_THERMZONE:
	case AML_OBJTYPE_DEBUGOBJ:
		if (res)
			aml_copyvalue(res, node->value);
		break;
	case AML_OBJTYPE_NAMEREF:
		if (res == NULL)
			break;
		if ((ref = aml_searchname(node, node->value->v_nameref)) != NULL)
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, ref);
		else
			aml_copyvalue(res, node->value);
		break;
	default:
		break;
	}
	return (0);
}

/*
 * evaluate an AML name
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalname(struct acpi_softc *sc, struct aml_node *parent, const char *name,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	return aml_evalnode(sc, aml_searchname(parent, name), argc, argv, res);
}

int
aml_evalinteger(struct acpi_softc *sc, struct aml_node *parent,
    const char *name, int argc, struct aml_value *argv, int64_t *ival)
{
	struct aml_value res;

	if (name != NULL)
		parent = aml_searchname(parent, name);
	if (aml_evalnode(sc, parent, argc, argv, &res) == 0) {
		*ival = aml_val2int(&res);
		aml_freevalue(&res);
		return 0;
	}
	return 1;
}
a1532 52
int		aml_match(int, int64_t, struct aml_value *);
void		aml_fixref(struct aml_value **);
int64_t		aml_parseint(struct aml_scope *, int);
void		aml_resize(struct aml_value *val, int newsize);

void
aml_resize(struct aml_value *val, int newsize)
{
	void *oldptr;
	int oldsize;

	if (val->length >= newsize)
		return;
	oldsize = val->length;
	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		oldptr = val->v_buffer;
		_aml_setvalue(val, val->type, newsize, NULL);
		memcpy(val->v_buffer, oldptr, oldsize);
		acpi_os_free(oldptr);
		break;
	case AML_OBJTYPE_STRING:
		oldptr = val->v_string;
		_aml_setvalue(val, val->type, newsize+1, NULL);
		memcpy(val->v_string, oldptr, oldsize);
		acpi_os_free(oldptr);
		break;
	}
}


int
aml_match(int op, int64_t mv1, struct aml_value *mv2)
{
	struct aml_value tmpint;

	memset(&tmpint, 0, sizeof(tmpint));
	_aml_setvalue(&tmpint, AML_OBJTYPE_INTEGER, mv1, NULL);
	switch (op) {
	case AML_MATCH_EQ:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LEQUAL);
	case AML_MATCH_LT:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LLESS);
	case AML_MATCH_LE:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LLESSEQUAL);
	case AML_MATCH_GE:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LGREATEREQUAL);
	case AML_MATCH_GT:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LGREATER);
	}
	return (1);
}
d1566 3
d1582 1
d1584 3
a1586 6
int64_t
aml_parseint(struct aml_scope *scope, int opcode)
{
	uint8_t *np = scope->pos;
	struct aml_value *tmpval;
	int64_t rval;
d1588 1
a1588 45
	if (opcode == AML_ANYINT)
		opcode = aml_parseopcode(scope);
	switch (opcode) {
	case AMLOP_ZERO:
		rval = 0;
		break;
	case AMLOP_ONE:
		rval = 1;
		break;
	case AMLOP_ONES:
		rval = -1;
		break;
	case AMLOP_REVISION:
		rval = AML_REVISION;
		break;
	case AMLOP_BYTEPREFIX:
		np = scope->pos;
		rval = *(uint8_t *)scope->pos;
		scope->pos += 1;
		break;
	case AMLOP_WORDPREFIX:
		np = scope->pos;
		rval = aml_letohost16(*(uint16_t *)scope->pos);
		scope->pos += 2;
		break;
	case AMLOP_DWORDPREFIX:
		np = scope->pos;
		rval = aml_letohost32(*(uint32_t *)scope->pos);
		scope->pos += 4;
		break;
	case AMLOP_QWORDPREFIX:
		np = scope->pos;
		rval = aml_letohost64(*(uint64_t *)scope->pos);
		scope->pos += 8;
		break;
	default:
		scope->pos = np;
		tmpval = aml_alloctmp(scope, 1);
		aml_parseop(scope, tmpval, 'i');
		return aml_val2int(tmpval);
	}
	dnprintf(15, "%.4x: [%s] %s\n", aml_pc(scope->pos-opsize(opcode)),
	    aml_nodename(scope->node), aml_mnem(opcode, np));
	return rval;
}
d1590 1
a1590 5
struct aml_value *
aml_evaltarget(struct aml_scope *scope, struct aml_value *res)
{
	return res;
}
d1592 2
a1593 3
int
aml_evalterm(struct aml_scope *scope, struct aml_value *raw,
    struct aml_value *dst)
d1595 1
a1595 1
	struct aml_value *deref;
d1597 9
a1605 4
	aml_freevalue(dst);
	deref = aml_derefterm(scope, raw, 0);
	aml_copyvalue(dst, deref);
	return 0;
a1607 1

d1609 1
a1609 1
 * @@@@@@: Opcode functions
d1611 16
d1628 3
a1630 3
/* Parse named objects */
struct aml_value *
aml_parsenamed(struct aml_scope *scope, int opcode, struct aml_value *res)
d1632 3
a1634 2
	uint8_t *name;
	int s, offs = 0;
d1636 10
a1645 40
	AML_CHECKSTACK();
	name = aml_parsename(scope);

	res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	switch (opcode) {
	case AMLOP_NAME:
		aml_parseop(scope, res, 't');
		break;
	case AMLOP_ALIAS:
		_aml_setvalue(res, AML_OBJTYPE_NAMEREF, 0, name);
		name = aml_parsename(scope);
		break;
	case AMLOP_EVENT:
		_aml_setvalue(res, AML_OBJTYPE_EVENT, 0, NULL);
		break;
	case AMLOP_MUTEX:
		/* XXX mutex is unused since we don't have concurrency */
		_aml_setvalue(res, AML_OBJTYPE_MUTEX, 0, NULL);
		res->v_mutex = (struct acpi_mutex *)acpi_os_malloc(
		    sizeof(struct acpi_mutex));
		res->v_mutex->amt_synclevel = aml_parseint(scope,
		    AMLOP_BYTEPREFIX);
		s = strlen(aml_getname(name));
		if (s > 4)
			offs = s - 4;
		strlcpy(res->v_mutex->amt_name, aml_getname(name) + offs,
		    ACPI_MTX_MAXNAME);
		rw_init(&res->v_mutex->amt_lock, res->v_mutex->amt_name);
		break;
	case AMLOP_OPREGION:
		_aml_setvalue(res, AML_OBJTYPE_OPREGION, 0, NULL);
		res->v_opregion.iospace = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_opregion.iobase = aml_parseint(scope, AML_ANYINT);
		res->v_opregion.iolen = aml_parseint(scope, AML_ANYINT);
		if (res->v_opregion.iospace == GAS_PCI_CFG_SPACE) {
			res->v_opregion.iobase += aml_getpciaddr(dsdt_softc,
			    scope->node);
			dnprintf(20, "got ioaddr: %s.%s:%llx\n",
			    aml_nodename(scope->node), aml_getname(name),
			    res->v_opregion.iobase);
a1646 1
		break;
d1648 43
a1690 1
	aml_createname(scope->node, name, res);
d1692 7
a1698 1
	return res;
d1701 2
a1702 3
/* Parse Named objects with scope */
struct aml_value *
aml_parsenamedscope(struct aml_scope *scope, int opcode, struct aml_value *res)
d1704 7
a1710 2
	uint8_t *end, *name;
	struct aml_node *node;
d1712 3
a1714 3
	AML_CHECKSTACK();
	end = aml_parseend(scope);
	name = aml_parsename(scope);
d1716 8
a1723 21
	switch (opcode) {
	case AMLOP_DEVICE:
		res = aml_allocvalue(AML_OBJTYPE_DEVICE, 0, NULL);
		break;
	case AMLOP_SCOPE:
		res = NULL;
		break;
	case AMLOP_PROCESSOR:
		res = aml_allocvalue(AML_OBJTYPE_PROCESSOR, 0, NULL);
		res->v_processor.proc_id = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_processor.proc_addr = aml_parseint(scope, AMLOP_DWORDPREFIX);
		res->v_processor.proc_len = aml_parseint(scope, AMLOP_BYTEPREFIX);
		break;
	case AMLOP_POWERRSRC:
		res = aml_allocvalue(AML_OBJTYPE_POWERRSRC, 0, NULL);
		res->v_powerrsrc.pwr_level = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_powerrsrc.pwr_order = aml_parseint(scope, AMLOP_BYTEPREFIX);
		break;
	case AMLOP_THERMALZONE:
		res = aml_allocvalue(AML_OBJTYPE_THERMZONE, 0, NULL);
		break;
a1724 5
	node = aml_createname(scope->node, name, res);
	aml_parsenode(scope, node, scope->pos, &end, NULL);
	scope->pos = end;

	return res;
d1727 3
a1729 3
/* Parse math opcodes */
struct aml_value *
aml_parsemath(struct aml_scope *scope, int opcode, struct aml_value *res)
d1731 1
a1731 2
	struct aml_value *tmparg;
	int64_t i1, i2, i3;
d1733 22
a1754 6
	tmparg = aml_alloctmp(scope, 1);
	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_LNOT:
		i2 = 0;
		i1 = aml_parseint(scope, AML_ANYINT);
d1756 2
a1757 4
	case AMLOP_LAND:
	case AMLOP_LOR:
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);
d1759 5
a1763 9
	case AMLOP_NOT:
	case AMLOP_TOBCD:
	case AMLOP_FROMBCD:
	case AMLOP_TOINTEGER:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		i2 = 0;
		i1 = aml_parseint(scope, AML_ANYINT);
		aml_parsetarget(scope, tmparg, NULL);
d1765 5
a1769 5
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		aml_parsetarget(scope, tmparg, NULL);
		i1 = aml_val2int(aml_derefterm(scope, tmparg, 0));
		i2 = 1;
d1771 5
a1775 8
	case AMLOP_DIVIDE:
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);

		aml_parsetarget(scope, tmparg, NULL);	// remainder
		aml_setvalue(scope, tmparg, NULL, (i1 % i2));

		aml_parsetarget(scope, tmparg, NULL);	// quotient
d1778 1
a1778 3
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);
		aml_parsetarget(scope, tmparg, NULL);
d1781 1
a1781 4
	i3 = aml_evalexpr(i1, i2, opcode);
	aml_setvalue(scope, res, NULL, i3);
	aml_setvalue(scope, tmparg, NULL, i3);
	return (res);
d1783 1
d1785 4
a1788 3
/* Parse logical comparison opcodes */
struct aml_value *
aml_parsecompare(struct aml_scope *scope, int opcode, struct aml_value *res)
d1790 6
a1795 2
	struct aml_value *tmparg;
	int rc;
d1797 2
a1798 8
	AML_CHECKSTACK();
	tmparg = aml_alloctmp(scope, 2);
	aml_parseterm(scope, &tmparg[AML_LHS]);
	aml_parseterm(scope, &tmparg[AML_RHS]);

	/* Compare both values */
	rc = aml_cmpvalue(&tmparg[AML_LHS], &tmparg[AML_RHS], opcode);
	aml_setvalue(scope, res, NULL, rc);
d1800 1
a1800 1
	return res;
d1803 3
a1805 3
/* Parse IF/ELSE opcodes */
struct aml_value *
aml_parseif(struct aml_scope *scope, int opcode, struct aml_value *res)
d1807 9
a1815 2
	int64_t test;
	uint8_t *end;
d1817 5
a1821 8
	AML_CHECKSTACK();
	end = aml_parseend(scope);
	test = aml_parseint(scope, AML_ANYINT);

	dnprintf(40, "@@ iftest: %llx\n", test);
	while (test && scope->pos < end) {
		/* Parse if scope */
		aml_parseterm(scope, res);
a1822 2
	if (scope->pos >= scope->end)
		return res;
d1824 1
a1824 11
	if (*end == AMLOP_ELSE) {
		scope->pos = ++end;
		end = aml_parseend(scope);
		while (!test && scope->pos < end) {
			/* Parse ELSE scope */
			aml_parseterm(scope, res);
		}
	}
	if (scope->pos < end)
		scope->pos = end;
	return res;
d1827 3
a1829 2
struct aml_value *
aml_parsewhile(struct aml_scope *scope, int opcode, struct aml_value *res)
d1831 1
a1831 2
	uint8_t *end, *start;
	int test, cnt;
d1833 4
a1836 25
	AML_CHECKSTACK();
	end = aml_parseend(scope);
	start = scope->pos;
	cnt = 0;
	do {
		test = 1;
		if (scope->pos == start || scope->pos == end) {
			scope->pos = start;
			test = aml_parseint(scope, AML_ANYINT);
			dnprintf(40, "@@whiletest = %d %x\n", test, cnt++);
		} else if (*scope->pos == AMLOP_BREAK) {
			scope->pos++;
			test = 0;
		} else if (*scope->pos == AMLOP_CONTINUE) {
			scope->pos = start;
		} else {
			aml_parseterm(scope, res);
		}
	} while (test && scope->pos <= end && cnt < 0x199);
	/* XXX: shouldn't need breakout counter */

	dnprintf(40, "Set While end : %x\n", cnt);
	if (scope->pos < end)
		scope->pos = end;
	return res;
d1839 3
a1841 3
/* Parse Buffer/Package opcodes */
struct aml_value *
aml_parsebufpkg(struct aml_scope *scope, int opcode, struct aml_value *res)
d1843 1
a1843 2
	uint8_t *end;
	int len;
d1845 1
a1845 4
	AML_CHECKSTACK();
	end = aml_parseend(scope);
	len = aml_parseint(scope, (opcode == AMLOP_PACKAGE) ?
	    AMLOP_BYTEPREFIX : AML_ANYINT);
d1847 4
a1850 21
	switch (opcode) {
	case AMLOP_BUFFER:
		_aml_setvalue(res, AML_OBJTYPE_BUFFER, len, NULL);
		if (scope->pos < end) {
			memcpy(res->v_buffer, scope->pos, end-scope->pos);
		}
		if (len != end-scope->pos) {
			dnprintf(99, "buffer: %.4x %.4x\n", len, end-scope->pos);
		}
		break;
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		_aml_setvalue(res, AML_OBJTYPE_PACKAGE, len, NULL);
		for (len = 0; len < res->length && scope->pos < end; len++) {
			aml_parseop(scope, res->v_package[len], 't');
		}
		if (scope->pos != end) {
			dnprintf(99, "Package not equiv!! %.4x %.4x %d of %d\n",
			    aml_pc(scope->pos), aml_pc(end), len, res->length);
		}
		break;
d1852 5
a1856 2
	scope->pos = end;
	return res;
d1858 1
d1860 4
a1863 4
struct aml_value *
aml_parsemethod(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end, *name;
d1865 1
a1865 19
	AML_CHECKSTACK();
	end = aml_parseend(scope);
	name = aml_parsename(scope);

	res = aml_allocvalue(AML_OBJTYPE_METHOD, 0, NULL);
	res->v_method.flags = aml_parseint(scope, AMLOP_BYTEPREFIX);
	res->v_method.start = scope->pos;
	res->v_method.end = end;
	res->v_method.fneval = aml_callmethod;
	aml_createname(scope->node, name, res);

	scope->pos = end;

	return res;
}

/* Parse simple type opcodes */
struct aml_value *
aml_parsesimple(struct aml_scope *scope, int opcode, struct aml_value *res)
d1867 2
a1868 1
	struct aml_node *node;
d1870 23
a1892 30
	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_ZERO:
		_aml_setvalue(res, AML_OBJTYPE_INTEGER+AML_STATIC,
		    aml_parseint(scope, opcode), NULL);
		break;
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_REVISION:
		_aml_setvalue(res, AML_OBJTYPE_INTEGER,
		    aml_parseint(scope, opcode), NULL);
		break;
	case AMLOP_DEBUG:
		_aml_setvalue(res, AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		break;
	case AMLOP_STRINGPREFIX:
		_aml_setvalue(res, AML_OBJTYPE_STRING, -1, scope->pos);
		scope->pos += res->length+1;
		break;
	case AMLOP_NAMECHAR:
		_aml_setvalue(res, AML_OBJTYPE_NAMEREF, 0, NULL);
		res->v_nameref = aml_parsename(scope);
		node = aml_searchname(scope->node, res->v_nameref);
		if (node && node->value)
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, node->value);
		break;
d1894 1
a1894 1
	return res;
d1897 2
a1898 3
/* Parse field unit opcodes */
struct aml_value *
aml_parsefieldunit(struct aml_scope *scope, int opcode, struct aml_value *res)
d1900 1
a1900 60
	uint8_t *end, *name;
	struct aml_value *fld;

	AML_CHECKSTACK();
	end = aml_parseend(scope);

	switch (opcode) {
	case AMLOP_FIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		break;
	case AMLOP_INDEXFIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		aml_parsetarget(scope, NULL, &res->v_field.ref2);
		break;
	case AMLOP_BANKFIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		aml_parsetarget(scope, NULL, &res->v_field.ref2);
		res->v_field.ref3 = aml_parseint(scope, AML_ANYINT);
		break;
	}
	res->v_field.flags = aml_parseint(scope, AMLOP_BYTEPREFIX);
	res->v_field.type = opcode;

	aml_fixref(&res->v_field.ref1);
	aml_fixref(&res->v_field.ref2);

	while (scope->pos < end) {
		switch (*scope->pos) {
		case 0x00: // reserved
			scope->pos++;
			res->v_field.bitlen = aml_parselength(scope);
			break;
		case 0x01: // attrib
			scope->pos++;
			/* XXX: do something with this */
			aml_parseint(scope, AMLOP_BYTEPREFIX);
			aml_parseint(scope, AMLOP_BYTEPREFIX);
			res->v_field.bitlen = 0;
			break;
		default:
			name = aml_parsename(scope);
			res->v_field.bitlen = aml_parselength(scope);

			/* Allocate new fieldunit */
			fld = aml_allocvalue(AML_OBJTYPE_FIELDUNIT, 0, NULL);

			/* Increase reference count on field */
			fld->v_field = res->v_field;
			aml_addref(fld->v_field.ref1);
			aml_addref(fld->v_field.ref2);

			aml_createname(scope->node, name, fld);
			break;
		}
		res->v_field.bitpos += res->v_field.bitlen;
	}
	/* Delete redundant reference */
	aml_delref(&res->v_field.ref1);
	aml_delref(&res->v_field.ref2);
	return res;
d1903 2
a1904 4
/* Parse CreateXXXField opcodes */
struct aml_value *
aml_parsebufferfield(struct aml_scope *scope, int opcode,
    struct aml_value *res)
d1906 1
a1906 1
	uint8_t *name;
d1908 1
a1908 5
	AML_CHECKSTACK();
	res = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL);
	res->v_field.type = opcode;
	aml_parsetarget(scope, NULL, &res->v_field.ref1);
	res->v_field.bitpos = aml_parseint(scope, AML_ANYINT);
d1910 7
a1916 5
	aml_fixref(&res->v_field.ref1);

	switch (opcode) {
	case AMLOP_CREATEFIELD:
		res->v_field.bitlen = aml_parseint(scope, AML_ANYINT);
d1918 2
a1919 2
	case AMLOP_CREATEBITFIELD:
		res->v_field.bitlen = 1;
d1921 2
a1922 3
	case AMLOP_CREATEBYTEFIELD:
		res->v_field.bitlen = 8;
		res->v_field.bitpos *= 8;
d1924 4
a1927 15
	case AMLOP_CREATEWORDFIELD:
		res->v_field.bitlen = 16;
		res->v_field.bitpos *= 8;
		break;
	case AMLOP_CREATEDWORDFIELD:
		res->v_field.bitlen = 32;
		res->v_field.bitpos *= 8;
		break;
	case AMLOP_CREATEQWORDFIELD:
		res->v_field.bitlen = 64;
		res->v_field.bitpos *= 8;
		break;
	}
	name = aml_parsename(scope);
	aml_createname(scope->node, name, res);
d1929 1
a1929 1
	return res;
d1932 30
a1961 7
/* Parse Mutex/Event action */
struct aml_value *
aml_parsemuxaction(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;
	int64_t i1;
	int rv;
d1963 2
a1964 1
	AML_CHECKSTACK();
d1966 4
a1969 13
	tmparg = aml_alloctmp(scope, 1);
	aml_parsetarget(scope, tmparg, NULL);
	switch (opcode) {
	case AMLOP_ACQUIRE:
		/* Assert: tmparg is AML_OBJTYPE_MUTEX */
		i1 = aml_parseint(scope, AMLOP_WORDPREFIX);
		rv = acpi_mutex_acquire(tmparg->v_objref.ref, i1);
		/* Return true if timed out */
		aml_setvalue(scope, res, NULL, rv);
		break;
	case AMLOP_RELEASE:
		acpi_mutex_release(tmparg->v_objref.ref);
		break;
d1971 8
a1978 11
	case AMLOP_WAIT:
		/* Assert: tmparg is AML_OBJTYPE_EVENT */
		i1 = aml_parseint(scope, AML_ANYINT);

		/* Return true if timed out */
		aml_setvalue(scope, res, NULL, 0);
		break;
	case AMLOP_SIGNAL:
		break;
	case AMLOP_RESET:
		break;
d1980 2
d1983 13
a1995 1
	return res;
d1998 3
a2000 3
/* Parse Miscellaneous opcodes */
struct aml_value *
aml_parsemisc2(struct aml_scope *scope, int opcode, struct aml_value *res)
d2002 1
a2002 2
	struct aml_value *tmparg, *dev;
	int i1, i2, i3;
d2004 14
a2017 40
	AML_CHECKSTACK();

	switch (opcode) {
	case AMLOP_NOTIFY:
		/* Assert: tmparg is nameref or objref */
		tmparg = aml_alloctmp(scope, 1);
		aml_parseop(scope, tmparg, 'r');
		dev = aml_dereftarget(scope, tmparg);

		i1 = aml_parseint(scope, AML_ANYINT);
		if (dev && dev->node) {
			dnprintf(10, "Notify: [%s] %.2x\n",
			    aml_nodename(dev->node), i1);
			aml_notify(dev->node, i1);
		}
		break;
	case AMLOP_SLEEP:
		i1 = aml_parseint(scope, AML_ANYINT);
		dnprintf(50, "SLEEP: %x\n", i1);
		if (i1)
			acpi_sleep(i1);
		else {
			dnprintf(10, "acpi_sleep(0)\n");
		}
		break;
	case AMLOP_STALL:
		i1 = aml_parseint(scope, AML_ANYINT);
		dnprintf(50, "STALL: %x\n", i1);
		if (i1)
			acpi_stall(i1);
		else {
			dnprintf(10, "acpi_stall(0)\n");
		}
		break;
	case AMLOP_FATAL:
		i1 = aml_parseint(scope, AMLOP_BYTEPREFIX);
		i2 = aml_parseint(scope, AMLOP_DWORDPREFIX);
		i3 = aml_parseint(scope, AML_ANYINT);
		aml_die("FATAL: %x %x %x\n", i1, i2, i3);
		break;
a2018 1
	return res;
d2021 4
a2024 3
/* Parse Miscellaneous opcodes */
struct aml_value *
aml_parsemisc3(struct aml_scope *scope, int opcode, struct aml_value *res)
d2026 6
a2031 12
	struct aml_value *tmparg;

	AML_CHECKSTACK();
	tmparg = aml_alloctmp(scope, 1);
	aml_parseterm(scope, tmparg);
	switch (opcode) {
	case AMLOP_SIZEOF:
		aml_setvalue(scope, res, NULL, tmparg->length);
		break;
	case AMLOP_OBJECTTYPE:
		aml_setvalue(scope, res, NULL, tmparg->type);
		break;
d2033 1
a2033 2

	return res;
d2036 4
a2039 3
/* Parse AMLOP_MATCH */
struct aml_value *
aml_parsematch(struct aml_scope *scope, int opcode, struct aml_value *res)
d2041 1
a2041 2
	struct aml_value *pkg;
	int op1, op2, idx, mv1, mv2;
d2043 15
a2057 14
	AML_CHECKSTACK();
	pkg = aml_parseterm(scope, NULL);
	op1 = aml_parseint(scope, AMLOP_BYTEPREFIX);
	mv1 = aml_parseint(scope, AML_ANYINT);
	op2 = aml_parseint(scope, AMLOP_BYTEPREFIX);
	mv2 = aml_parseint(scope, AML_ANYINT);
	idx = aml_parseint(scope, AML_ANYINT);

	aml_setvalue(scope, res, NULL, -1);
	while (idx < pkg->length) {
		if (aml_match(op1, mv1, pkg->v_package[idx]) ||
		    aml_match(op2, mv2, pkg->v_package[idx])) {
			aml_setvalue(scope, res, NULL, idx);
			break;
a2058 1
		idx++;
a2059 2
	aml_delref(&pkg);
	return res;
d2061 1
d2063 4
a2066 3
/* Parse referenced objects */
struct aml_value *
aml_parseref(struct aml_scope *scope, int opcode, struct aml_value *res)
d2068 17
a2084 1
	struct aml_value *tmparg;
d2086 7
a2092 1
	AML_CHECKSTACK();
d2094 1
a2094 5
	switch (opcode) {
	case AMLOP_INDEX:
		tmparg = aml_alloctmp(scope, 1);
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, NULL);
		aml_parsetarget(scope, tmparg, NULL);
d2096 2
a2097 2
		res->v_objref.index = aml_parseint(scope, AML_ANYINT);
		res->v_objref.ref = aml_dereftarget(scope, tmparg);
d2099 6
a2104 36
		aml_parsetarget(scope, tmparg, NULL);
		aml_setvalue(scope, tmparg, res, 0);
		break;
	case AMLOP_DEREFOF:
		aml_parseop(scope, res, 't');
		break;
	case AMLOP_RETURN:
		tmparg = aml_alloctmp(scope, 1);
		aml_parseterm(scope, tmparg);
		aml_setvalue(scope, res, tmparg, 0);
		scope->pos = scope->end;
		break;
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		opcode -= AMLOP_ARG0;
		if (scope->args == NULL || opcode >= scope->nargs)
			aml_die("arg %d out of range", opcode);

		/* Create OBJREF to stack variable */
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1,
		    &scope->args[opcode]);
		break;
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		opcode -= AMLOP_LOCAL0;
d2106 2
a2107 5
		/* No locals exist.. lazy allocate */
		if (scope->locals == NULL) {
			dnprintf(10, "Lazy alloc locals\n");
			scope->locals = aml_alloctmp(scope, AML_MAX_LOCAL);
		}
d2109 1
a2109 14
		/* Create OBJREF to stack variable */
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1,
		    &scope->locals[opcode]);
		res->v_objref.ref->stack = opcode+AMLOP_LOCAL0;
		break;
	case AMLOP_LOAD:
		tmparg = aml_alloctmp(scope, 2);
		aml_parseop(scope, &tmparg[0], 't');
		aml_parseop(scope, &tmparg[1], 't');
		break;
	case AMLOP_STORE:
		tmparg = aml_alloctmp(scope, 1);
		aml_parseterm(scope, res);
		aml_parsetarget(scope, tmparg, NULL);
d2111 6
a2116 4
		while (tmparg->type == AML_OBJTYPE_OBJREF) {
			if (tmparg->v_objref.index != -1)
				break;
			tmparg = tmparg->v_objref.ref;
d2118 6
a2123 19
		aml_setvalue(scope, tmparg, res, 0);
		break;
	case AMLOP_REFOF:
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, NULL);
		aml_parsetarget(scope, NULL, &res->v_objref.ref);
		break;
	case AMLOP_CONDREFOF:
		/* Returns true if object exists */
		tmparg = aml_alloctmp(scope, 2);
		aml_parsetarget(scope, &tmparg[0], NULL);
		aml_parsetarget(scope, &tmparg[1], NULL);
		if (tmparg[0].type != AML_OBJTYPE_NAMEREF) {
			/* Object exists */
			aml_freevalue(&tmparg[1]);
			aml_setvalue(scope, &tmparg[1], &tmparg[0], 0);
			aml_setvalue(scope, res, NULL, 1);
		} else {
			/* Object doesn't exist */
			aml_setvalue(scope, res, NULL, 0);
d2125 2
a2126 1
		break;
d2128 2
d2131 1
a2131 1
	return res;
d2134 3
a2136 2
struct aml_value *
aml_parsestring(struct aml_scope *scope, int opcode, struct aml_value *res)
d2138 13
a2150 50
	struct aml_value *tmpval;
	int i1, i2;

	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_CONCAT:
		tmpval = aml_alloctmp(scope, 4);
		aml_parseterm(scope, &tmpval[AML_LHS]);
		aml_parseterm(scope, &tmpval[AML_RHS]);
		aml_parsetarget(scope, &tmpval[AML_DST], NULL);
		if (tmpval[AML_LHS].type == AML_OBJTYPE_BUFFER &&
		    tmpval[AML_RHS].type == AML_OBJTYPE_BUFFER) {
			aml_resize(&tmpval[AML_LHS],
			    tmpval[AML_LHS].length+tmpval[AML_RHS].length);
			memcpy(tmpval[AML_LHS].v_buffer+tmpval[AML_LHS].length,
			    tmpval[AML_RHS].v_buffer, tmpval[AML_RHS].length);
			aml_setvalue(scope, &tmpval[AML_DST], &tmpval[AML_LHS], 0);
		} else if (tmpval[AML_LHS].type == AML_OBJTYPE_STRING &&
		    tmpval[AML_RHS].type == AML_OBJTYPE_STRING) {
			aml_resize(&tmpval[AML_LHS],
			    tmpval[AML_LHS].length+tmpval[AML_RHS].length);
			memcpy(tmpval[AML_LHS].v_string+tmpval[AML_LHS].length,
			    tmpval[AML_RHS].v_buffer, tmpval[AML_RHS].length);
			aml_setvalue(scope, &tmpval[AML_DST], &tmpval[AML_LHS], 0);
		} else {
			aml_die("concat");
		}
		break;
	case AMLOP_MID:
		tmpval = aml_alloctmp(scope, 2);
		aml_parseterm(scope, &tmpval[0]);
		i1 = aml_parseint(scope, AML_ANYINT); // start
		i2 = aml_parseint(scope, AML_ANYINT); // length
		aml_parsetarget(scope, &tmpval[1], NULL);
		if (i1 > tmpval[0].length)
			i1 = tmpval[0].length;
		if (i1+i2 > tmpval[0].length)
			i2 = tmpval[0].length-i1;
		_aml_setvalue(res, AML_OBJTYPE_STRING, i2, tmpval[0].v_string+i1);
		break;
	case AMLOP_TODECSTRING:
	case AMLOP_TOHEXSTRING:
		i1 = aml_parseint(scope, AML_ANYINT);
		_aml_setvalue(res, AML_OBJTYPE_STRING, 20, NULL);
		snprintf(res->v_string, res->length,
		    ((opcode == AMLOP_TODECSTRING) ? "%d" : "%x"), i1);
		break;
	default:
		aml_die("to_string");
		break;
d2152 1
a2152 2

	return res;
d2155 5
a2159 2
struct aml_value *
aml_parseterm(struct aml_scope *scope, struct aml_value *res)
d2161 2
a2162 1
	struct aml_value *tmpres;
d2164 15
a2178 7
	/* If no value specified, allocate dynamic */
	if (res == NULL)
		res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	tmpres = aml_alloctmp(scope, 1);
	aml_parseop(scope, tmpres, 't');
	aml_evalterm(scope, tmpres, res);
	return res;
d2181 12
a2192 3
struct aml_value *
aml_parsetarget(struct aml_scope *scope, struct aml_value *res,
    struct aml_value **opt)
d2194 19
a2212 1
	struct aml_value *dummy;
d2214 5
a2218 6
	/* If no value specified, allocate dynamic */
	if (res == NULL)
		res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	aml_parseop(scope, res, 'r');
	if (opt == NULL)
		opt = &dummy;
d2220 6
a2225 1
	*opt = aml_evaltarget(scope, res);
d2227 9
a2235 1
	return res;
d2238 39
a2276 1
int odp;
d2278 5
a2282 3
/* Main Opcode Parser/Evaluator */
struct aml_value *
aml_parseop(struct aml_scope *scope, struct aml_value *res, int ctype)
d2284 19
a2302 3
	int opcode;
	struct aml_opcode *htab;
	struct aml_value *rv = NULL;
d2304 1
a2304 2
	if (odp++ > 25)
		panic("depth");
d2306 4
a2309 5
	aml_freevalue(res);
	opcode = aml_parseopcode(scope);
	dnprintf(15, "%.4x: [%s] %s\n", aml_pc(scope->pos-opsize(opcode)),
	    aml_nodename(scope->node), aml_mnem(opcode, scope->pos));
	delay(amlop_delay);
d2311 51
a2361 7
	htab = aml_findopcode(opcode);
	if (htab && htab->handler) {
		rv = htab->handler(scope, opcode, res);
	} else {
		/* No opcode handler */
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode,
		    aml_pc(scope->pos - opsize(opcode)));
d2363 5
a2367 4
	if (ctype == 'i' && res->type != AML_OBJTYPE_INTEGER) {
		rv = aml_derefterm(scope, res, 0);
		aml_freevalue(res);
		aml_copyvalue(res, rv);
d2369 1
a2369 2
	odp--;
	return rv;
d2372 25
a2396 1
const char hext[] = "0123456789ABCDEF";
d2398 3
a2400 2
const char *
aml_eisaid(u_int32_t pid)
d2402 31
a2432 1
	static char id[8];
d2434 8
a2441 9
	id[0] = '@@' + ((pid >> 2) & 0x1F);
	id[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
	id[2] = '@@' + ((pid >> 8) & 0x1F);
	id[3] = hext[(pid >> 20) & 0xF];
	id[4] = hext[(pid >> 16) & 0xF];
	id[5] = hext[(pid >> 28) & 0xF];
	id[6] = hext[(pid >> 24) & 0xF];
	id[7] = 0;
	return id;
d2444 21
a2464 10
/*
 * @@@@@@: Fixup DSDT code
 */
struct aml_fixup {
	int		offset;
	u_int8_t	oldv, newv;
} __ibm300gl[] = {
	{ 0x19, 0x3a, 0x3b },
	{ -1 }
};
d2466 2
a2467 8
struct aml_blacklist {
	const char	*oem, *oemtbl;
	struct aml_fixup *fixtab;
	u_int8_t	cksum;
} amlfix_list[] = {
	{ "IBM   ", "CDTPWSNH", __ibm300gl, 0x41 },
	{ NULL },
};
d2469 1
d2471 1
a2471 1
aml_fixup_dsdt(u_int8_t *acpi_hdr, u_int8_t *base, int len)
d2473 1
a2473 3
	struct acpi_table_header *hdr = (struct acpi_table_header *)acpi_hdr;
	struct aml_blacklist *fixlist;
	struct aml_fixup *fixtab;
d2475 5
a2479 11
	for (fixlist = amlfix_list; fixlist->oem; fixlist++) {
		if (!memcmp(fixlist->oem, hdr->oemid, 6) &&
		    !memcmp(fixlist->oemtbl, hdr->oemtableid, 8) &&
		    fixlist->cksum == hdr->checksum) {
			/* Found a potential fixup entry */
			for (fixtab = fixlist->fixtab; fixtab->offset != -1;
			    fixtab++) {
				if (base[fixtab->offset] == fixtab->oldv)
					base[fixtab->offset] = fixtab->newv;
			}
		}
d2481 2
a2482 1
}
d2485 1
a2485 1
 * @@@@@@: Default Object creation
d2487 10
a2496 14
static char osstring[] = "Macrosift Windogs MT";
struct aml_defval {
	const char		*name;
	int			type;
	int64_t			ival;
	const void		*bval;
	struct aml_value	**gval;
} aml_defobj[] = {
	{ "_OS_", AML_OBJTYPE_STRING, -1, osstring },
	{ "_REV", AML_OBJTYPE_INTEGER, 2, NULL },
	{ "_GL", AML_OBJTYPE_MUTEX, 1, NULL, &aml_global_lock },
	{ "_OSI", AML_OBJTYPE_METHOD, 1, aml_callosi },
	{ NULL }
};
d2498 1
a2498 16
/* _OSI Default Method:
 * Returns True if string argument matches list of known OS strings
 * We return True for Windows to fake out nasty bad AML
 */
char *aml_valid_osi[] = {
	"Windows 2000",
	"Windows 2001",
	"Windows 2001.1",
	"Windows 2001 SP0",
	"Windows 2001 SP1",
	"Windows 2001 SP2",
	"Windows 2001 SP3",
	"Windows 2001 SP4",
	"Windows 2006",
	NULL
};
d2500 2
a2501 2
struct aml_value *
aml_callosi(struct aml_scope *scope, struct aml_value *val)
d2503 2
a2504 2
	struct aml_value tmpstr, *arg;
	int idx, result;
d2506 5
a2510 5
	/* Perform comparison with valid strings */
	result = 0;
	memset(&tmpstr, 0, sizeof(tmpstr));
	tmpstr.type = AML_OBJTYPE_STRING;
	arg = aml_derefvalue(scope, &scope->args[0], ACPI_IOREAD);
d2512 15
a2526 5
	for (idx=0; !result && aml_valid_osi[idx] != NULL; idx++) {
		tmpstr.v_string = aml_valid_osi[idx];
		tmpstr.length = strlen(tmpstr.v_string);

		result = aml_cmpvalue(arg, &tmpstr, AMLOP_LEQUAL);
d2528 5
a2532 2
	aml_setvalue(scope, val, NULL, result);
	return val;
d2536 1
a2536 1
aml_create_defaultobjects()
d2538 6
a2543 2
	struct aml_value *tmp;
	struct aml_defval *def;
d2545 5
a2549 4
	osstring[1] = 'i';
	osstring[6] = 'o';
	osstring[15] = 'w';
	osstring[18] = 'N';
d2551 22
a2572 7
	for (def = aml_defobj; def->name; def++) {
		/* Allocate object value + add to namespace */
		tmp = aml_allocvalue(def->type, def->ival, def->bval);
		aml_createname(&aml_root, def->name, tmp);
		if (def->gval) {
			/* Set root object pointer */
			*def->gval = tmp;
d2575 2
d2579 2
a2580 3
#ifdef ACPI_DEBUG
int
aml_print_resource(union acpi_resource *crs, void *arg)
d2582 7
a2588 1
	int typ = AML_CRSTYPE(crs);
d2590 15
a2604 5
	switch (typ) {
	case LR_EXTIRQ:
		printf("extirq\tflags:%.2x len:%.2x irq:%.4x\n",
		    crs->lr_extirq.flags, crs->lr_extirq.irq_count,
		    aml_letohost32(crs->lr_extirq.irq[0]));
d2606 2
a2607 3
	case SR_IRQ:
		printf("irq\t%.4x %.2x\n", aml_letohost16(crs->sr_irq.irq_mask),
		    crs->sr_irq.irq_flags);
d2609 2
a2610 3
	case SR_DMA:
		printf("dma\t%.2x %.2x\n", crs->sr_dma.channel,
		    crs->sr_dma.flags);
d2612 27
a2638 5
	case SR_IOPORT:
		printf("ioport\tflags:%.2x _min:%.4x _max:%.4x _aln:%.2x _len:%.2x\n",
		    crs->sr_ioport.flags, crs->sr_ioport._min,
		    crs->sr_ioport._max, crs->sr_ioport._aln,
		    crs->sr_ioport._len);
d2640 2
a2641 2
	case SR_STARTDEP:
		printf("startdep\n");
d2643 2
a2644 2
	case SR_ENDDEP:
		printf("enddep\n");
d2646 4
a2649 5
	case LR_WORD:
		printf("word\ttype:%.2x flags:%.2x tflag:%.2x gra:%.4x min:%.4x max:%.4x tra:%.4x len:%.4x\n",
			crs->lr_word.type, crs->lr_word.flags, crs->lr_word.tflags,
			crs->lr_word._gra, crs->lr_word._min, crs->lr_word._max,
			crs->lr_word._tra, crs->lr_word._len);
d2651 5
a2655 11
	case LR_DWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.8x min:%.8x max:%.8x tra:%.8x len:%.8x\n",
			crs->lr_dword.type, crs->lr_dword.flags, crs->lr_dword.tflags,
			crs->lr_dword._gra, crs->lr_dword._min, crs->lr_dword._max,
			crs->lr_dword._tra, crs->lr_dword._len);
		break;
	case LR_QWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.16llx min:%.16llx max:%.16llx tra:%.16llx len:%.16llx\n",
			crs->lr_qword.type, crs->lr_qword.flags, crs->lr_qword.tflags,
			crs->lr_qword._gra, crs->lr_qword._min, crs->lr_qword._max,
			crs->lr_qword._tra, crs->lr_qword._len);
d2658 1
a2658 1
		printf("unknown type: %x\n", typ);
d2661 90
a2750 1
	return (0);
a2751 1
#endif /* ACPI_DEBUG */
d2753 42
a2794 1
union acpi_resource *aml_mapresource(union acpi_resource *);
d2796 4
a2799 2
union acpi_resource *
aml_mapresource(union acpi_resource *crs)
d2801 2
a2802 2
	static union acpi_resource map;
	int rlen;
d2804 40
a2843 3
	rlen = AML_CRSLEN(crs);
	if (rlen >= sizeof(map))
		return crs;
d2845 8
a2852 5
	memset(&map, 0, sizeof(map));
	memcpy(&map, crs, rlen);

	return &map;
}
d2855 2
a2856 2
aml_parse_resource(int length, uint8_t *buffer,
    int (*crs_enum)(union acpi_resource *, void *), void *arg)
d2858 1
a2858 2
	int off, rlen;
	union acpi_resource *crs;
d2860 13
a2872 12
	for (off = 0; off < length; off += rlen) {
		crs = (union acpi_resource *)(buffer+off);

		rlen = AML_CRSLEN(crs);
		if (crs->hdr.typecode == 0x79 || rlen <= 3)
			break;

		crs = aml_mapresource(crs);
#ifdef ACPI_DEBUG
		aml_print_resource(crs, NULL);
#endif
		crs_enum(crs, arg);
d2874 1
a2874 1

d2879 1
a2879 2
aml_foreachpkg(struct aml_value *pkg, int start,
    void (*fn)(struct aml_value *, void *), void *arg)
d2881 1
a2881 1
	int idx;
d2883 8
a2890 4
	if (pkg->type != AML_OBJTYPE_PACKAGE)
		return;
	for (idx=start; idx<pkg->length; idx++)
		fn(pkg->v_package[idx], arg);
d2894 1
a2894 1
acpi_parse_aml(struct acpi_softc *sc, u_int8_t *start, u_int32_t length)
d2896 7
a2902 8
	u_int8_t *end;

	dsdt_softc = sc;

	strlcpy(aml_root.name, "\\", sizeof(aml_root.name));
	if (aml_root.start == NULL) {
		aml_root.start = start;
		aml_root.end = start+length;
d2904 3
a2906 3
	end = start+length;
	aml_parsenode(NULL, &aml_root, start, &end, NULL);
	dnprintf(50, " : parsed %d AML bytes\n", length);
d2908 5
a2912 1
	return (0);
d2915 5
a2919 4
/*
 * Walk nodes and perform fixups for nameref
 */
int aml_fixup_node(struct aml_node *, void *);
d2921 4
a2924 1
int aml_fixup_node(struct aml_node *node, void *arg)
d2926 2
a2927 2
	struct aml_value *val = arg;
	int i;
d2929 49
a2977 9
	if (node->value == NULL)
		return (0);
	if (arg == NULL)
		aml_fixup_node(node, node->value);
	else if (val->type == AML_OBJTYPE_NAMEREF) {
		node = aml_searchname(node, val->v_nameref);
		if (node && node->value) {
			_aml_setvalue(val, AML_OBJTYPE_OBJREF, -1,
			    node->value);
d2979 6
a2984 13
	} else if (val->type == AML_OBJTYPE_PACKAGE) {
		for (i = 0; i < val->length; i++)
			aml_fixup_node(node, val->v_package[i]);
	} else if (val->type == AML_OBJTYPE_OPREGION) {
		if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE)
			return (0);
		if (ACPI_PCI_FN(val->v_opregion.iobase) != 0xFFFF)
			return (0);
		val->v_opregion.iobase =
		    ACPI_PCI_REG(val->v_opregion.iobase) +
		    aml_getpciaddr(dsdt_softc, node);
		dnprintf(20, "late ioaddr : %s:%llx\n",
		    aml_nodename(node), val->v_opregion.iobase);
d2986 1
a2986 1
	return (0);
d2989 3
d2993 1
a2993 1
aml_postparse()
d2995 5
a2999 1
	aml_walknodes(&aml_root, AML_WALK_PRE, aml_fixup_node, NULL);
d3002 4
a3005 2
const char *
aml_val_to_string(const struct aml_value *val)
d3007 11
a3017 1
	static char buffer[256];
d3019 3
a3021 1
	int len;
d3023 28
a3050 7
	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		len = val->length;
		if (len >= sizeof(buffer))
			len = sizeof(buffer) - 1;
		memcpy(buffer, val->v_buffer, len);
		buffer[len] = 0;
a3051 10
	case AML_OBJTYPE_STRING:
		strlcpy(buffer, val->v_string, sizeof(buffer));
		break;
	case AML_OBJTYPE_INTEGER:
		snprintf(buffer, sizeof(buffer), "%llx", val->v_integer);
		break;
	default:
		snprintf(buffer, sizeof(buffer),
		    "Failed to convert type %d to string!", val->type);
	};
d3053 1481
a4533 1
	return (buffer);
@


1.114
log
@Ripped out old parser guts
ok loki@@
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.113 2008/05/15 22:15:54 jordan Exp $ */
a36 4
#ifdef SMALL_KERNEL
#undef ACPI_DEBUG
#endif

d125 18
d155 13
a167 13
	{ AMLOP_ZERO,		"Zero",		"c",	},
	{ AMLOP_ONE,		"One",		"c",	},
	{ AMLOP_ONES,		"Ones",		"c",	},
	{ AMLOP_REVISION,	"Revision",	"R",	},
	{ AMLOP_BYTEPREFIX,	".Byte",	"b",	},
	{ AMLOP_WORDPREFIX,	".Word",	"w",	},
	{ AMLOP_DWORDPREFIX,	".DWord",	"d",	},
	{ AMLOP_QWORDPREFIX,	".QWord",	"q",	},
	{ AMLOP_STRINGPREFIX,	".String",	"a",	},
	{ AMLOP_DEBUG,		"DebugOp",	"D",	},
	{ AMLOP_BUFFER,		"Buffer",	"piB",	},
	{ AMLOP_PACKAGE,	"Package",	"pbT",	},
	{ AMLOP_VARPACKAGE,	"VarPackage",	"piT",	},
d170 15
a184 15
	{ AMLOP_LOCAL0,		"Local0",	"L",	},
	{ AMLOP_LOCAL1,		"Local1",	"L",	},
	{ AMLOP_LOCAL2,		"Local2",	"L",	},
	{ AMLOP_LOCAL3,		"Local3",	"L",	},
	{ AMLOP_LOCAL4,		"Local4",	"L",	},
	{ AMLOP_LOCAL5,		"Local5",	"L",	},
	{ AMLOP_LOCAL6,		"Local6",	"L",	},
	{ AMLOP_LOCAL7,		"Local7",	"L",	},
	{ AMLOP_ARG0,		"Arg0",		"A",	},
	{ AMLOP_ARG1,		"Arg1",		"A",	},
	{ AMLOP_ARG2,		"Arg2",		"A",	},
	{ AMLOP_ARG3,		"Arg3",		"A",	},
	{ AMLOP_ARG4,		"Arg4",		"A",	},
	{ AMLOP_ARG5,		"Arg5",		"A",	},
	{ AMLOP_ARG6,		"Arg6",		"A",	},
d187 1
a187 1
	{ AMLOP_IF,		"If",		"piI",	},
d189 1
a189 1
	{ AMLOP_WHILE,		"While",	"pW",	},
d192 4
a195 4
	{ AMLOP_RETURN,		"Return",	"t",	},
	{ AMLOP_FATAL,		"Fatal",	"bdi",	},
	{ AMLOP_NOP,		"Nop",		"",	},
	{ AMLOP_BREAKPOINT,	"BreakPoint",	"",     },
d198 17
a214 17
	{ AMLOP_INCREMENT,	"Increment",	"t",	},
	{ AMLOP_DECREMENT,	"Decrement",	"t",	},
	{ AMLOP_ADD,		"Add",		"iir",	},
	{ AMLOP_SUBTRACT,	"Subtract",	"iir",	},
	{ AMLOP_MULTIPLY,	"Multiply",	"iir",	},
	{ AMLOP_DIVIDE,		"Divide",	"iirr",	},
	{ AMLOP_SHL,		"ShiftLeft",	"iir",	},
	{ AMLOP_SHR,		"ShiftRight",	"iir",	},
	{ AMLOP_AND,		"And",		"iir",	},
	{ AMLOP_NAND,		"Nand",		"iir",	},
	{ AMLOP_OR,		"Or",		"iir",	},
	{ AMLOP_NOR,		"Nor",		"iir",	},
	{ AMLOP_XOR,		"Xor",		"iir",	},
	{ AMLOP_NOT,		"Not",		"ir",	},
	{ AMLOP_MOD,		"Mod",		"iir",	},
	{ AMLOP_FINDSETLEFTBIT,	"FindSetLeftBit", "ir",	},
	{ AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",},
d217 9
a225 9
	{ AMLOP_LAND,		"LAnd",		"ii",	},
	{ AMLOP_LOR,		"LOr",		"ii",	},
	{ AMLOP_LNOT,		"LNot",		"i",	},
	{ AMLOP_LNOTEQUAL,	"LNotEqual",	"tt",	},
	{ AMLOP_LLESSEQUAL,	"LLessEqual",	"tt",	},
	{ AMLOP_LGREATEREQUAL,	"LGreaterEqual", "tt",	},
	{ AMLOP_LEQUAL,		"LEqual",	"tt",	},
	{ AMLOP_LGREATER,	"LGreater",	"tt",	},
	{ AMLOP_LLESS,		"LLess",	"tt",	},
d228 13
a240 13
	{ AMLOP_NAMECHAR,	".NameRef",	"n",	},
	{ AMLOP_ALIAS,		"Alias",	"nN",	},
	{ AMLOP_NAME,		"Name",	"Nt",	},
	{ AMLOP_EVENT,		"Event",	"N",	},
	{ AMLOP_MUTEX,		"Mutex",	"Nb",	},
	{ AMLOP_DATAREGION,	"DataRegion",	"Nttt",	},
	{ AMLOP_OPREGION,	"OpRegion",	"Nbii",	},
	{ AMLOP_SCOPE,		"Scope",	"pNT",	},
	{ AMLOP_DEVICE,		"Device",	"pNT",	},
	{ AMLOP_POWERRSRC,	"Power Resource", "pNbwT",},
	{ AMLOP_THERMALZONE,	"ThermalZone",	"pNT",	},
	{ AMLOP_PROCESSOR,	"Processor",	"pNbdbT", },
	{ AMLOP_METHOD,		"Method",	"pNbM",	},
d243 9
a251 9
	{ AMLOP_FIELD,		"Field",	"pnbF",	},
	{ AMLOP_INDEXFIELD,	"IndexField",	"pnnbF",},
	{ AMLOP_BANKFIELD,	"BankField",	"pnnibF",},
	{ AMLOP_CREATEFIELD,	"CreateField",	"tiiN",		},
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",},
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",},
	{ AMLOP_CREATEWORDFIELD, "CreateWordField", "tiN",},
	{ AMLOP_CREATEBYTEFIELD, "CreateByteField", "tiN",},
	{ AMLOP_CREATEBITFIELD,	"CreateBitField", "tiN",	},
d254 1
a254 1
	{ AMLOP_TOINTEGER,	"ToInteger",	"tr",	},
d256 6
a261 6
	{ AMLOP_TODECSTRING,	"ToDecString",	"ir",	},
	{ AMLOP_TOHEXSTRING,	"ToHexString",	"ir",	},
	{ AMLOP_TOSTRING,	"ToString",	"tir",	},
	{ AMLOP_MID,		"Mid",		"tiir",	},
	{ AMLOP_FROMBCD,	"FromBCD",	"ir",	},
	{ AMLOP_TOBCD,		"ToBCD",	"ir",	},
d264 10
a273 10
	{ AMLOP_ACQUIRE,	"Acquire",	"Sw",	},
	{ AMLOP_RELEASE,	"Release",	"S",	},
	{ AMLOP_SIGNAL,		"Signal",	"S",	},
	{ AMLOP_WAIT,		"Wait",		"Si",	},
	{ AMLOP_RESET,		"Reset",	"S",	},

	{ AMLOP_INDEX,		"Index",	"tir",	},
	{ AMLOP_DEREFOF,	"DerefOf",	"t",	},
	{ AMLOP_REFOF,		"RefOf",	"S",	},
	{ AMLOP_CONDREFOF,	"CondRef",	"SS",	},
d276 3
a278 3
	{ AMLOP_STALL,		"Stall",	"i",	},
	{ AMLOP_SLEEP,		"Sleep",	"i",	},
	{ AMLOP_LOAD,		"Load",		"nS",	},
d280 2
a281 2
	{ AMLOP_STORE,		"Store",	"tS",	},
	{ AMLOP_CONCAT,		"Concat",	"ttr",	},
d283 5
a287 5
	{ AMLOP_NOTIFY,		"Notify",	"Si",	},
	{ AMLOP_SIZEOF,		"Sizeof",	"S",	},
	{ AMLOP_MATCH,		"Match",	"tbibii", },
	{ AMLOP_OBJECTTYPE,	"ObjectType",	"S",	},
	{ AMLOP_COPYOBJECT,	"CopyObject",	"tS",	},
d470 67
a540 1
#ifdef ACPI_DEBUG
a551 1
#endif
d573 21
d671 1
a671 1
struct aml_node *__aml_search(struct aml_node *, uint8_t *, int);
d677 1
a677 1
__aml_search(struct aml_node *root, uint8_t *nameseg, int create)
a678 3
	struct aml_node **sp, *node;

	/* XXX: Replace with SLIST/SIMPLEQ routines */
d681 3
a683 19
	//rw_enter_read(&aml_nslock);
	for (sp = &root->child; *sp; sp = &(*sp)->sibling) {
		if (!strncmp((*sp)->name, nameseg, AML_NAMESEG_LEN)) {
			//rw_exit_read(&aml_nslock);
			return *sp;
	}
	}
	//rw_exit_read(&aml_nslock);
	if (create) {
		node = acpi_os_malloc(sizeof(struct aml_node));
		memcpy((void *)node->name, nameseg, AML_NAMESEG_LEN);
		node->value = aml_allocvalue(0,0,NULL);
		node->value->node = node;
		node->parent = root;
		node->sibling = NULL;

		//rw_enter_write(&aml_nslock);
		*sp = node;
		//rw_exit_write(&aml_nslock);
d685 1
a685 1
	return *sp;
d775 1
a775 1
		if ((node = __aml_search(root, name, 0)) == NULL) {
d796 51
d872 1
d876 2
d884 21
d950 20
d973 3
d979 55
d1037 1
a1037 2
#define acpi_acquire_global_lock(x) 1 
#define acpi_release_global_lock(x) 0
d1084 206
d1294 3
d1338 2
a1339 4
		if (val->v_field.ref1)
			printf("  ref1: %s\n", aml_nodename(val->v_field.ref1->node));
		if (val->v_field.ref2)
			printf("  ref2: %s\n", aml_nodename(val->v_field.ref2->node));
d1373 2
a1374 2
		printf(" objref: %p index:%x opcode:%s\n", val->v_objref.ref,
		    val->v_objref.index, aml_mnem(val->v_objref.type, 0));
d1383 95
d1615 126
d1966 1
a1966 1
	dnprintf(15,"aml_evalexpr: %s %llx %llx = %llx\n",
d2032 47
d2085 78
d2315 1
d2317 50
d2414 6
a2419 3
/*
 * @@@@@@: Opcode functions
 */
d2421 45
a2465 1
int odp;
d2467 5
a2471 1
const char hext[] = "0123456789ABCDEF";
d2473 3
a2475 2
const char *
aml_eisaid(u_int32_t pid)
d2477 1
a2477 1
	static char id[8];
d2479 4
a2482 9
	id[0] = '@@' + ((pid >> 2) & 0x1F);
	id[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
	id[2] = '@@' + ((pid >> 8) & 0x1F);
	id[3] = hext[(pid >> 20) & 0xF];
	id[4] = hext[(pid >> 16) & 0xF];
	id[5] = hext[(pid >> 28) & 0xF];
	id[6] = hext[(pid >> 24) & 0xF];
	id[7] = 0;
	return id;
d2485 1
d2487 1
a2487 1
 * @@@@@@: Fixup DSDT code
a2488 7
struct aml_fixup {
	int		offset;
	u_int8_t	oldv, newv;
} __ibm300gl[] = {
	{ 0x19, 0x3a, 0x3b },
	{ -1 }
};
d2490 6
a2495 8
struct aml_blacklist {
	const char	*oem, *oemtbl;
	struct aml_fixup *fixtab;
	u_int8_t	cksum;
} amlfix_list[] = {
	{ "IBM   ", "CDTPWSNH", __ibm300gl, 0x41 },
	{ NULL },
};
d2497 2
a2498 6
void
aml_fixup_dsdt(u_int8_t *acpi_hdr, u_int8_t *base, int len)
{
	struct acpi_table_header *hdr = (struct acpi_table_header *)acpi_hdr;
	struct aml_blacklist *fixlist;
	struct aml_fixup *fixtab;
d2500 37
a2536 10
	for (fixlist = amlfix_list; fixlist->oem; fixlist++) {
		if (!memcmp(fixlist->oem, hdr->oemid, 6) &&
		    !memcmp(fixlist->oemtbl, hdr->oemtableid, 8) &&
		    fixlist->cksum == hdr->checksum) {
			/* Found a potential fixup entry */
			for (fixtab = fixlist->fixtab; fixtab->offset != -1;
			    fixtab++) {
				if (base[fixtab->offset] == fixtab->oldv)
					base[fixtab->offset] = fixtab->newv;
			}
d2538 1
d2540 3
d2545 1
a2545 35
/*
 * @@@@@@: Default Object creation
 */
static char osstring[] = "Macrosift Windogs MT";
struct aml_defval {
	const char		*name;
	int			type;
	int64_t			ival;
	const void		*bval;
	struct aml_value	**gval;
} aml_defobj[] = {
	{ "_OS_", AML_OBJTYPE_STRING, -1, osstring },
	{ "_REV", AML_OBJTYPE_INTEGER, 2, NULL },
	{ "_GL", AML_OBJTYPE_MUTEX, 1, NULL, &aml_global_lock },
	{ "_OSI", AML_OBJTYPE_METHOD, 1, aml_callosi },
	{ NULL }
};

/* _OSI Default Method:
 * Returns True if string argument matches list of known OS strings
 * We return True for Windows to fake out nasty bad AML
 */
char *aml_valid_osi[] = {
	"Windows 2000",
	"Windows 2001",
	"Windows 2001.1",
	"Windows 2001 SP0",
	"Windows 2001 SP1",
	"Windows 2001 SP2",
	"Windows 2001 SP3",
	"Windows 2001 SP4",
	"Windows 2006",
	NULL
};

d2547 1
a2547 1
aml_callosi(struct aml_scope *scope, struct aml_value *val)
d2549 6
a2554 2
	int idx, result=0;
	struct aml_value *fa;
d2556 21
a2576 4
	fa = scope->args[0].v_objref.ref;
	for (idx=0; !result && aml_valid_osi[idx] != NULL; idx++) {
		dnprintf(10,"osi: %s,%s\n", fa->v_string, aml_valid_osi[idx]);
		result = !strcmp(fa->v_string, aml_valid_osi[idx]);
d2578 5
a2582 2
	dnprintf(10,"@@@@ OSI found: %x\n", result);
	return aml_allocvalue(AML_OBJTYPE_INTEGER, result, NULL);
d2585 3
a2587 2
void
aml_create_defaultobjects()
d2589 2
a2590 2
	struct aml_value *tmp;
	struct aml_defval *def;
d2592 6
a2597 31
	osstring[1] = 'i';
	osstring[6] = 'o';
	osstring[15] = 'w';
	osstring[18] = 'N';

	strlcpy(aml_root.name, "\\", sizeof(aml_root.name));
	aml_root.value = aml_allocvalue(0, 0, NULL);
	aml_root.value->node = &aml_root;

	for (def = aml_defobj; def->name; def++) {
		/* Allocate object value + add to namespace */
		tmp = aml_allocvalue(def->type, def->ival, def->bval);
		aml_createname(&aml_root, def->name, tmp);
		if (def->gval) {
			/* Set root object pointer */
			*def->gval = tmp;
		}
	}
}

#ifdef ACPI_DEBUG
int
aml_print_resource(union acpi_resource *crs, void *arg)
{
	int typ = AML_CRSTYPE(crs);

	switch (typ) {
	case LR_EXTIRQ:
		printf("extirq\tflags:%.2x len:%.2x irq:%.4x\n",
		    crs->lr_extirq.flags, crs->lr_extirq.irq_count,
		    aml_letohost32(crs->lr_extirq.irq[0]));
d2599 4
a2602 3
	case SR_IRQ:
		printf("irq\t%.4x %.2x\n", aml_letohost16(crs->sr_irq.irq_mask),
		    crs->sr_irq.irq_flags);
d2604 9
a2612 3
	case SR_DMA:
		printf("dma\t%.2x %.2x\n", crs->sr_dma.channel,
		    crs->sr_dma.flags);
d2614 5
a2618 5
	case SR_IOPORT:
		printf("ioport\tflags:%.2x _min:%.4x _max:%.4x _aln:%.2x _len:%.2x\n",
		    crs->sr_ioport.flags, crs->sr_ioport._min,
		    crs->sr_ioport._max, crs->sr_ioport._aln,
		    crs->sr_ioport._len);
d2620 8
a2627 23
	case SR_STARTDEP:
		printf("startdep\n");
		break;
	case SR_ENDDEP:
		printf("enddep\n");
		break;
	case LR_WORD:
		printf("word\ttype:%.2x flags:%.2x tflag:%.2x gra:%.4x min:%.4x max:%.4x tra:%.4x len:%.4x\n",
			crs->lr_word.type, crs->lr_word.flags, crs->lr_word.tflags,
			crs->lr_word._gra, crs->lr_word._min, crs->lr_word._max,
			crs->lr_word._tra, crs->lr_word._len);
		break;
	case LR_DWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.8x min:%.8x max:%.8x tra:%.8x len:%.8x\n",
			crs->lr_dword.type, crs->lr_dword.flags, crs->lr_dword.tflags,
			crs->lr_dword._gra, crs->lr_dword._min, crs->lr_dword._max,
			crs->lr_dword._tra, crs->lr_dword._len);
		break;
	case LR_QWORD:
		printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.16llx min:%.16llx max:%.16llx tra:%.16llx len:%.16llx\n",
			crs->lr_qword.type, crs->lr_qword.flags, crs->lr_qword.tflags,
			crs->lr_qword._gra, crs->lr_qword._min, crs->lr_qword._max,
			crs->lr_qword._tra, crs->lr_qword._len);
d2630 3
a2632 1
		printf("unknown type: %x\n", typ);
d2635 4
a2638 1
	return (0);
a2639 1
#endif /* ACPI_DEBUG */
d2641 3
a2643 4
union acpi_resource *aml_mapresource(union acpi_resource *);

union acpi_resource *
aml_mapresource(union acpi_resource *crs)
d2645 2
a2646 2
	static union acpi_resource map;
	int rlen;
d2648 8
a2655 3
	rlen = AML_CRSLEN(crs);
	if (rlen >= sizeof(map))
		return crs;
d2657 1
a2657 4
	memset(&map, 0, sizeof(map));
	memcpy(&map, crs, rlen);

	return &map;
d2660 3
a2662 3
int
aml_parse_resource(int length, uint8_t *buffer,
    int (*crs_enum)(union acpi_resource *, void *), void *arg)
d2664 2
a2665 2
	int off, rlen;
	union acpi_resource *crs;
d2667 11
a2677 2
	for (off = 0; off < length; off += rlen) {
		crs = (union acpi_resource *)(buffer+off);
d2679 7
a2685 9
		rlen = AML_CRSLEN(crs);
		if (crs->hdr.typecode == 0x79 || rlen <= 3)
			break;

		crs = aml_mapresource(crs);
#ifdef ACPI_DEBUG
		aml_print_resource(crs, NULL);
#endif
		crs_enum(crs, arg);
d2687 3
a2689 2

	return 0;
d2692 2
a2693 3
void
aml_foreachpkg(struct aml_value *pkg, int start,
    void (*fn)(struct aml_value *, void *), void *arg)
d2695 2
a2696 1
	int idx;
d2698 25
a2722 4
	if (pkg->type != AML_OBJTYPE_PACKAGE)
		return;
	for (idx=start; idx<pkg->length; idx++)
		fn(pkg->v_package[idx], arg);
d2725 3
a2727 3
#if 0
int
acpi_parse_aml(struct acpi_softc *sc, u_int8_t *start, u_int32_t length)
d2729 2
a2730 1
	u_int8_t *end;
d2732 4
a2735 1
	dsdt_softc = sc;
d2737 21
a2757 4
	strlcpy(aml_root.name, "\\", sizeof(aml_root.name));
	if (aml_root.start == NULL) {
		aml_root.start = start;
		aml_root.end = start+length;
d2759 3
a2761 3
	end = start+length;
	aml_parsenode(NULL, &aml_root, start, &end, NULL);
	dnprintf(50, " : parsed %d AML bytes\n", length);
d2763 4
a2766 3
	return (0);
}
#endif
d2768 10
a2777 4
/*
 * Walk nodes and perform fixups for nameref
 */
int aml_fixup_node(struct aml_node *, void *);
d2779 1
a2779 4
int aml_fixup_node(struct aml_node *node, void *arg)
{
	struct aml_value *val = arg;
	int i;
d2781 1
a2781 25
	if (node->value == NULL)
		return (0);
	if (arg == NULL)
		aml_fixup_node(node, node->value);
	else if (val->type == AML_OBJTYPE_NAMEREF) {
		node = aml_searchname(node, val->v_nameref);
		if (node && node->value) {
			_aml_setvalue(val, AML_OBJTYPE_OBJREF, -1,
			    node->value);
		}
	} else if (val->type == AML_OBJTYPE_PACKAGE) {
		for (i = 0; i < val->length; i++)
			aml_fixup_node(node, val->v_package[i]);
	} else if (val->type == AML_OBJTYPE_OPREGION) {
		if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE)
			return (0);
		if (ACPI_PCI_FN(val->v_opregion.iobase) != 0xFFFF)
			return (0);
		val->v_opregion.iobase =
		    ACPI_PCI_REG(val->v_opregion.iobase) +
		    aml_getpciaddr(dsdt_softc, node);
		dnprintf(20, "late ioaddr : %s:%llx\n",
		    aml_nodename(node), val->v_opregion.iobase);
	}
	return (0);
d2784 3
a2786 2
void
aml_postparse()
d2788 34
a2821 1
	aml_walknodes(&aml_root, AML_WALK_PRE, aml_fixup_node, NULL);
d2824 3
a2826 2
const char *
aml_val_to_string(const struct aml_value *val)
d2828 2
a2829 1
	static char buffer[256];
d2831 2
a2832 1
	int len;
d2834 3
a2836 7
	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		len = val->length;
		if (len >= sizeof(buffer))
			len = sizeof(buffer) - 1;
		memcpy(buffer, val->v_buffer, len);
		buffer[len] = 0;
d2838 3
a2840 2
	case AML_OBJTYPE_STRING:
		strlcpy(buffer, val->v_string, sizeof(buffer));
d2842 28
a2869 7
	case AML_OBJTYPE_INTEGER:
		snprintf(buffer, sizeof(buffer), "%llx", val->v_integer);
		break;
	default:
		snprintf(buffer, sizeof(buffer),
		    "Failed to convert type %d to string!", val->type);
	};
d2871 2
a2872 2
	return (buffer);
}
d2874 4
a2877 30
/*
 * XXX: NEW PARSER CODE GOES HERE 
 */
struct aml_value *aml_xeval(struct aml_scope *, struct aml_value *, int, int,
    struct aml_value *);
struct aml_value *aml_xparsesimple(struct aml_scope *, char, 
    struct aml_value *);
struct aml_value *aml_xparse(struct aml_scope *, int, const char *);

struct aml_scope *aml_xfindscope(struct aml_scope *, int, int);
struct aml_scope *aml_xpushscope(struct aml_scope *, struct aml_value *, 
    struct aml_node *, int);
struct aml_scope *aml_xpopscope(struct aml_scope *);

void		aml_showstack(struct aml_scope *);
void		aml_xaddref(struct aml_value *, const char *);
void		aml_xdelref(struct aml_value **, const char *);
void		aml_xconvert(struct aml_value *, struct aml_value **, int, int);
int64_t		aml_hextoint(const char *);

int		aml_xmatchtest(int64_t, int64_t, int);
int		aml_xmatch(struct aml_value *, int, int, int, int, int);

int		aml_xcompare(struct aml_value *, struct aml_value *, int);
void		aml_xconcat(struct aml_value *, struct aml_value *, 
    struct aml_value **);
void		aml_xconcatres(struct aml_value *, struct aml_value *, 
    struct aml_value **);
int		aml_ccrlen(union acpi_resource *, void *);
void		aml_xmid(struct aml_value *, int, int, struct aml_value **);
d2879 10
a2888 2
void		aml_xstore(struct aml_scope *, struct aml_value *, int64_t, 
    struct aml_value *);
d2890 4
a2893 2
int
valid_acpihdr(void *buf, int len, const char *sig)
d2895 1
a2895 1
	struct acpi_table_header *hdr = buf;
d2897 5
a2901 11
	if (sig && strncmp(hdr->signature, sig, 4)) {
		return 0;
	}
	if (len < hdr->length) {
		return 0;
	}
	if (acpi_checksum(hdr, hdr->length) != 0) {
		return 0;
	}
	return 1; 
}
d2903 1
a2903 14
/*
 * Reference Count functions
 */
void
aml_xaddref(struct aml_value *val, const char *lbl)
{
	if (val == NULL)
		return;
	dnprintf(50, "XAddRef: %p %s:[%s] %d\n", 
	    val, lbl,
	    val->node ? aml_nodename(val->node) : "INTERNAL",
	    val->refcnt);
	val->refcnt++;
}
d2905 26
a2930 5
/* Decrease reference counter */
void
aml_xdelref(struct aml_value **pv, const char *lbl)
{
	struct aml_value *val;
d2932 1
a2932 15
	if (pv == NULL || *pv == NULL)
		return;
	val = *pv;
	val->refcnt--;
	if (val->refcnt == 0) {
		dnprintf(50, "XDelRef: %p %s %2d [%s] %s\n", 
		    val, lbl,
		    val->refcnt,
		    val->node ? aml_nodename(val->node) : "INTERNAL",
		    val->refcnt ? "" : "---------------- FREEING");

		aml_freevalue(val);
		acpi_os_free(val);
		*pv = NULL;
	}
d2935 3
a2937 4
/* Walk list of parent scopes until we find one of 'type'
 * If endscope is set, mark all intermediate scopes as invalid (used for Method/While) */
struct aml_scope *
aml_xfindscope(struct aml_scope *scope, int type, int endscope)
d2939 3
a2941 9
	while (scope) { 
		if (endscope)
			scope->pos = NULL;
		if (scope->type == type)
			break;
		scope = scope->parent;
	}
	return scope;
}
d2943 1
a2943 6
#ifdef ACPI_DEBUG
/* Dump AML Stack */
void 
aml_showstack(struct aml_scope *scope)
{
	int idx;
d2945 13
a2957 19
	dnprintf(10, "===== Stack %s:%s\n", aml_nodename(scope->node), 
	    aml_mnem(scope->type, 0));
	scope = aml_xfindscope(scope, AMLOP_METHOD, 0);
	if (scope == NULL)
		return;
	for (idx=0; scope->args && idx<7; idx++) {
		if (scope->args[idx].type) {
			dnprintf(10," Arg%d: ", idx);
			aml_showvalue(scope->args[idx].v_objref.ref, 10);
		}
	}
	for (idx=0; scope->locals && idx<8; idx++) {
		if (scope->locals[idx].type) {
			dnprintf(10," Local%d: ", idx);
			aml_showvalue(&scope->locals[idx], 10);
		}
	}
}
#endif
d2959 3
a2961 7
/* Create a new scope object */
struct aml_scope *
aml_xpushscope(struct aml_scope *parent, struct aml_value *range,
    struct aml_node *node, int type)
{
	struct aml_scope *scope;
	uint8_t *start, *end;
d2963 7
a2969 10
	if (range->type == AML_OBJTYPE_METHOD) {
		start = range->v_method.start;
		end = range->v_method.end;
	}
	else {
		start = range->v_buffer;
		end = start + range->length;
		if (start == end) {
			return NULL;
		}
a2970 3
	scope = acpi_os_malloc(sizeof(struct aml_scope));
	if (scope == NULL)
		return NULL;
d2972 1
a2972 11
	scope->node = node;
	scope->start = start;
	scope->end = end;
	scope->pos = scope->start;
	scope->parent = parent;
	scope->type = type;
	scope->sc = dsdt_softc;

	aml_lastscope = scope;

	return scope;
d2975 3
a2977 3
/* Free a scope object and any children */
struct aml_scope *
aml_xpopscope(struct aml_scope *scope)
d2979 2
a2980 2
	struct aml_scope *nscope;
	int idx;
d2982 1
a2982 2
	if (scope == NULL)
		return NULL;
d2984 21
a3004 8
	nscope = scope->parent;

	if (scope->type == AMLOP_METHOD) {
		aml_delchildren(scope->node);
	}
	if (scope->locals) {
		for (idx=0; idx<8; idx++) {
			aml_freevalue(&scope->locals[idx]);
d3006 8
a3013 6
		acpi_os_free(scope->locals);
		scope->locals = NULL;
	}
	if (scope->args) {
		for (idx=0; idx<7; idx++) {
			aml_freevalue(&scope->args[idx]);
d3015 7
a3021 2
		acpi_os_free(scope->args);
		scope->args = NULL;
d3023 1
a3023 4
	acpi_os_free(scope);
	aml_lastscope = nscope;

	return nscope;
d3026 3
a3028 3
/* Test AMLOP_MATCH codes */
int
aml_xmatchtest(int64_t a, int64_t b, int op)
d3030 12
a3041 13
	switch (op) {
	case AML_MATCH_TR:
		return (1);
	case AML_MATCH_EQ:
		return (a == b);
	case AML_MATCH_LT:
		return (a < b);
	case AML_MATCH_LE:
		return (a <= b);
	case AML_MATCH_GE:
		return (a >= b);
	case AML_MATCH_GT:
		return (a > b);
d3043 2
a3044 1
	return 0;
d3047 3
a3049 5
/* Search a package for a matching value */
int
aml_xmatch(struct aml_value *pkg, int index,
	   int op1, int v1,
	   int op2, int v2)
d3051 2
a3052 19
	struct aml_value *tmp;
	int flag;

	while (index < pkg->length) {
		/* Convert package value to integer */
		aml_xconvert(pkg->v_package[index], &tmp, 
		    AML_OBJTYPE_INTEGER, 0);

		/* Perform test */
		flag = aml_xmatchtest(tmp->v_integer, v1, op1) && 
		    aml_xmatchtest(tmp->v_integer, v2, op2);
		aml_xdelref(&tmp, "xmatch");

		if (flag)
			return index;
		index++;
	}
	return -1;
}
d3054 7
a3060 15
/*
 * Namespace functions
 */
void ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg);
void ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg);
uint8_t *aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg);

/* Search for name in namespace */
void
ns_xsearch(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	struct aml_value **rv = arg;
	struct aml_node *rnode;
d3062 5
a3066 3
	/* If name search is relative, check up parent nodes */
	for (rnode=node; n == 1 && rnode; rnode=rnode->parent) {
		if (__aml_search(rnode, pos, 0) != NULL) {
d3069 1
d3071 2
a3072 9
	while (n--) {
		rnode = __aml_search(rnode, pos, 0);
		pos += 4;
	}
	if (rnode != NULL) {
		*rv = rnode->value;
		return;
	}
	*rv = NULL;
d3075 3
a3077 3
/* Create name in namespace */
void
ns_xcreate(struct aml_node *node, int n, uint8_t *pos, void *arg)
d3079 1
a3079 1
	struct aml_value **rv = arg;
d3081 1
a3081 6
	while (n--) {
		node = __aml_search(node, pos, 1);
		pos += 4;
	}
	*rv = node->value;
}
d3083 5
a3087 10
void
ns_xdis(struct aml_node *node, int n, uint8_t *pos, void *arg)
{
	printf(aml_nodename(node));
	while (n--) {
		printf("%s%c%c%c%c", n ? "." : "", 
		    pos[0], pos[1], pos[2], pos[3]);
		pos+=4;
	}
}
d3089 2
a3090 6
uint8_t *
aml_xparsename(uint8_t *pos, struct aml_node *node, 
    void (*fn)(struct aml_node *, int, uint8_t *, void *), void *arg)
{
	uint8_t *rpos = pos;
	struct aml_value **rv = arg;
d3092 36
a3127 41
	if (*pos == AMLOP_ROOTCHAR) {
		node = &aml_root;
		pos++;
	}
	while (*pos == AMLOP_PARENTPREFIX) {
		node = node ? node->parent : &aml_root;
		pos++;
	}
	if (*pos == 0) {
		fn(node, 0, pos, arg);
		pos++;
	}
	else if (*pos == AMLOP_MULTINAMEPREFIX) {
		fn(node, pos[1], pos+2, arg);
		pos += 2 + 4 * pos[1];
	}
	else if (*pos == AMLOP_DUALNAMEPREFIX) {
		fn(node, 2, pos+1, arg);
		pos += 9;
	}
	else if (*pos == '_' || (*pos >= 'A' && *pos <= 'Z')) {
		fn(node, 1, pos, arg);
		pos += 4;
	}
	else {
		printf("Invalid name!!!\n");
	}
	if (rv && *rv == NULL) {
		*rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, rpos);
	}
	return pos;
}

/*
 * Conversion routines
 */
int64_t
aml_hextoint(const char *str)
{
	int64_t v = 0;
	char c;
d3129 4
a3132 3
	while (*str) {
		if (*str >= '0' && *str <= '9') {
			c = *(str++) - '0';
a3133 12
		else if (*str >= 'a' && *str <= 'f') {
			c = *(str++) - 'a' + 10;
		}
		else if (*str >= 'A' && *str <= 'F') {
			c = *(str++) - 'A' + 10;
		}
		else {
			break;
		}
		v = (v << 4) + c;
	}
	return v;
d3135 14
a3148 1
}
d3150 4
a3153 23
void
aml_xconvert(struct aml_value *a, struct aml_value **b, int ctype, int mode)
{
	struct aml_value *c = NULL;

	/* Object is already this type */
	if (a->type == ctype) {
		aml_xaddref(a, "XConvert");
		*b = a;
		return;
	}
	switch (ctype) {
	case AML_OBJTYPE_BUFFER:
		dnprintf(10,"convert to buffer\n");
		switch (a->type) {
		case AML_OBJTYPE_INTEGER:
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length, 
			    &a->v_integer);
			break;
		case AML_OBJTYPE_STRING:
			c = aml_allocvalue(AML_OBJTYPE_BUFFER, a->length, 
			    a->v_string);
			break;
d3155 1
d3157 3
a3159 16
	case AML_OBJTYPE_INTEGER:
		dnprintf(10,"convert to integer : %x\n", a->type);
		switch (a->type) {
		case AML_OBJTYPE_BUFFER:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			memcpy(&c->v_integer, a->v_buffer, 
			    min(a->length, c->length));
			break;
		case AML_OBJTYPE_STRING:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			c->v_integer = aml_hextoint(a->v_string);
			break;
		case AML_OBJTYPE_UNINITIALIZED:
			c = aml_allocvalue(AML_OBJTYPE_INTEGER, 0, NULL);
			break;
		}
d3161 13
a3173 12
	case AML_OBJTYPE_STRING:
		dnprintf(10,"convert to string\n");
		switch (a->type) {
		case AML_OBJTYPE_INTEGER:
			c = aml_allocvalue(AML_OBJTYPE_STRING, 20, NULL);
			snprintf(c->v_string, c->length, (mode == 'x') ? 
			    "0x%llx" : "%lld", a->v_integer);
			break;
		case AML_OBJTYPE_BUFFER:
			c = aml_allocvalue(AML_OBJTYPE_STRING, a->length,
			    a->v_buffer);
			break;
d3177 2
a3178 7
	if (c == NULL) {
#ifndef SMALL_KERNEL
		aml_showvalue(a, 0);
#endif
		aml_die("Could not convert!!!\n");
	}
	*b = c;
d3181 2
a3182 2
int
aml_xcompare(struct aml_value *a1, struct aml_value *a2, int opcode)
d3184 2
a3185 1
	int rc = 0;
d3187 23
a3209 12
	/* Convert A2 to type of A1 */
	aml_xconvert(a2, &a2, a1->type, 0);
	if (a1->type == AML_OBJTYPE_INTEGER) {
		rc = aml_evalexpr(a1->v_integer, a2->v_integer, opcode);
	}
	else {
		/* Perform String/Buffer comparison */
		rc = memcmp(a1->v_buffer, a2->v_buffer, 
		    min(a1->length, a2->length));
		if (rc == 0) {
			/* If buffers match, which one is longer */
			rc = a1->length - a2->length;
a3210 22
		/* Perform comparison against zero */
		rc = aml_evalexpr(rc, 0, opcode);
	}
	/* Either deletes temp buffer, or decrease refcnt on original A2 */
	aml_xdelref(&a2, "xcompare");
	return rc;
}

/* Concatenate two objects, returning pointer to new object */
void
aml_xconcat(struct aml_value *a1, struct aml_value *a2, struct aml_value **res)
{
	struct aml_value *c;

	/* Convert arg2 to type of arg1 */
	aml_xconvert(a2, &a2, a1->type, 0);
	switch (a1->type) {
	case AML_OBJTYPE_INTEGER:
		c = aml_allocvalue(AML_OBJTYPE_BUFFER, 
		    a1->length + a2->length, NULL);
		memcpy(c->v_buffer, &a1->v_integer, a1->length);
		memcpy(c->v_buffer+a1->length, &a2->v_integer, a2->length);
d3212 11
a3222 5
	case AML_OBJTYPE_BUFFER:
		c = aml_allocvalue(AML_OBJTYPE_BUFFER, 
		    a1->length + a2->length, NULL);
		memcpy(c->v_buffer, a1->v_buffer, a1->length);
		memcpy(c->v_buffer+a1->length, a2->v_buffer, a2->length);
d3224 6
a3229 5
	case AML_OBJTYPE_STRING:
		c = aml_allocvalue(AML_OBJTYPE_STRING, 
		    a1->length + a2->length, NULL);
		memcpy(c->v_string, a1->v_string, a1->length);
		memcpy(c->v_string+a1->length, a2->v_string, a2->length);
d3232 1
a3232 1
		aml_die("concat type mismatch %d != %d\n", a1->type, a2->type);
d3235 2
a3236 3
	/* Either deletes temp buffer, or decrease refcnt on original A2 */
	aml_xdelref(&a2, "xconcat");
	*res = c;
d3239 2
a3240 3
/* Calculate length of Resource Template */
int
aml_ccrlen(union acpi_resource *rs, void *arg)
d3242 9
a3250 4
	int *plen = arg;
	
	*plen += AML_CRSLEN(rs);
	return 0;
d3253 3
a3255 3
/* Concatenate resource templates, returning pointer to new object */
void
aml_xconcatres(struct aml_value *a1, struct aml_value *a2, struct aml_value **res)
d3257 1
a3257 6
	struct aml_value *c;
	int l1 = 0, l2 = 0;

	if (a1->type != AML_OBJTYPE_BUFFER || a2->type != AML_OBJTYPE_BUFFER) {
		aml_die("concatres: not buffers\n");
	}
d3259 6
a3264 3
	/* Walk a1, a2, get length minus end tags, concatenate buffers, add end tag */
	aml_parse_resource(a1->length, a1->v_buffer, aml_ccrlen, &l1);
	aml_parse_resource(a2->length, a2->v_buffer, aml_ccrlen, &l2);
d3266 1
a3266 6
	/* Concatenate buffers, add end tag */
	c = aml_allocvalue(AML_OBJTYPE_BUFFER, l1+l2+2, NULL);
	memcpy(c->v_buffer,    a1->v_buffer, l1);
	memcpy(c->v_buffer+l1, a2->v_buffer, l2);
	c->v_buffer[l1+l2+0] = 0x79;
	c->v_buffer[l1+l2+1] = 0x00;
d3268 1
a3268 1
	*res = c;
d3271 5
a3275 3
/* Extract substring from string or buffer */
void
aml_xmid(struct aml_value *src, int index, int length, struct aml_value **res)
d3277 12
a3288 1
	int idx;
d3290 12
a3301 5
	for (idx=index; idx<index+length; idx++) {
		if (idx >= src->length)
			break;
		if (src->v_buffer[idx] == 0)
			break;
d3303 21
a3323 2
	aml_die("mid\n");
}		
d3326 1
a3326 1
 * Field I/O utility functions 
d3328 7
a3334 10
void  aml_xresolve(struct aml_scope *, struct aml_value *);
void *aml_xgetptr(struct aml_value *, int);
void aml_xgasio(int, uint64_t, int, void *, int, int, const char *);
void aml_xfldio(struct aml_scope *, struct aml_value *, 
    struct aml_value *, int);
void aml_xcreatefield(struct aml_value *, int, struct aml_value *, int, int,
    struct aml_value *, int);
void aml_xparsefieldlist(struct aml_scope *, int, int,
    struct aml_value *, struct aml_value *, int);
int aml_evalhid(struct aml_node *, struct aml_value *);
d3336 8
a3343 1
#define GAS_PCI_CFG_SPACE_UNEVAL  0xCC
d3345 2
a3346 2
int
aml_evalhid(struct aml_node *node, struct aml_value *val)
d3348 3
a3350 2
	if (aml_evalname(dsdt_softc, node, "_HID", 0, NULL, val))
		return (-1);
d3352 10
a3361 20
	/* Integer _HID: convert to EISA ID */
	if (val->type == AML_OBJTYPE_INTEGER) 
		_aml_setvalue(val, AML_OBJTYPE_STRING, -1, aml_eisaid(val->v_integer));
	return (0);
}

int
aml_xgetpci(struct aml_node *node, int64_t *base)
{
	struct aml_node *pci_root;
	struct aml_value hid;
	int64_t v;

	*base = 0;
	dnprintf(10,"RESOLVE PCI: %s\n", aml_nodename(node));
	for (pci_root=node->parent; pci_root; pci_root=pci_root->parent) {
		/* PCI Root object will have _HID value */
		if (aml_evalhid(pci_root, &hid) == 0) {
			aml_freevalue(&hid);
			break;
a3363 5
	if (!aml_evalinteger(NULL, node->parent, "_ADR", 0, NULL, &v))
		*base += (v << 16L);
	if (!aml_evalinteger(NULL, pci_root, "_BBN", 0, NULL, &v))
		*base += (v << 48L);
	return 0;
d3366 37
a3402 2
void
aml_xresolve(struct aml_scope *scope, struct aml_value *val)
d3404 8
a3411 1
	int64_t base;
d3413 3
a3415 4
	if (val->type != AML_OBJTYPE_OPREGION || val->v_opregion.flag)
		return;
	if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE)
		return;
d3417 4
a3420 4
	/* Evaluate PCI Address */
	aml_xgetpci(val->node, &base);
	val->v_opregion.iobase += base;
	val->v_opregion.flag = 1;
a3422 8
/* Perform IO to address space
 *    type = GAS_XXXX
 *    base = base address
 *    rlen = length in bytes to read/write
 *    buf  = buffer
 *    mode = ACPI_IOREAD/ACPI_IOWRITE
 *    sz   = access_size (bits)
 */
d3424 1
a3424 2
aml_xgasio(int type, uint64_t base, int rlen, void *buf, int mode, int sz,
    const char *lbl)
d3426 15
a3440 10
	sz >>= 3;
	acpi_gasio(dsdt_softc, mode, type, base, sz, rlen, buf);
#ifdef ACPI_DEBUG
	{
		int idx;
		printf("%sio: [%s]  ty:%x bs=%.8llx sz=%.4x rlen=%.4x ",
		    mode == ACPI_IOREAD ? "rd" : "wr", lbl,
		    type, base, sz, rlen);
		for (idx=0; idx<rlen; idx++) {
			printf("%.2x ", ((uint8_t *)buf)[idx]);
a3442 2
	printf("\n");
#endif
d3445 3
a3447 2
void *
aml_xgetptr(struct aml_value *tmp, int blen)
d3449 1
a3449 7
	if (blen > aml_intlen) {
		_aml_setvalue(tmp, AML_OBJTYPE_BUFFER, aml_bytelen(blen), 0);
		return tmp->v_buffer;
	}
	_aml_setvalue(tmp, AML_OBJTYPE_INTEGER, 0, NULL);
	return &tmp->v_integer;
}
d3451 5
a3455 12
/* Read and Write BufferField and FieldUnit objects */
void
aml_xfldio(struct aml_scope *scope, struct aml_value *fld, 
	   struct aml_value *buf, int mode)
{
	struct aml_value tmp, *data;
	int bpos, blen, preserve=1, mask, aligned, rlen, slen;
	void *sptr, *dptr;
		
 	switch (AML_FIELD_ACCESS(fld->v_field.flags)) {
	case AML_FIELD_WORDACC:
		mask=15;
d3457 3
a3459 2
	case AML_FIELD_DWORDACC:
		mask=31;
d3461 3
a3463 2
	case AML_FIELD_QWORDACC:
		mask=63;
d3465 5
a3469 2
	default:
		mask=7;
d3471 2
a3472 27
	}
	data = fld->v_field.ref1;
	bpos = fld->v_field.bitpos;
	blen = fld->v_field.bitlen;
	rlen = aml_bytelen((bpos & 7) + blen);
	aligned = !((bpos|blen)&mask);
	preserve = AML_FIELD_UPDATE(fld->v_field.flags);

	dnprintf(30,"\nquick: %s: [%s] %.4x-%.4x msk=%.2x algn=%d prsrv=%d [%s]\n",
	    mode == ACPI_IOREAD ? "read from" : "write to",
	    aml_nodename(fld->node),
	    bpos, blen, mask, aligned, preserve,
	    aml_mnem(fld->v_field.type, 0));

	memset(&tmp, 0, sizeof(tmp));
	if (fld->v_field.ref2 != NULL) {
		/* Write index */
		dnprintf(30,"writing index fldio: %d\n", fld->v_field.ref3);
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, 
		    fld->v_field.ref3, NULL);
		aml_xfldio(scope, fld->v_field.ref2, &tmp, ACPI_IOWRITE);
	}

	/* Get pointer to Data Object */
	switch (data->type) {
	case AML_OBJTYPE_BUFFER:
		dptr = data->v_buffer;
d3474 2
a3475 2
	case AML_OBJTYPE_STRING:
		dptr = data->v_string;
d3477 5
a3481 2
	case AML_OBJTYPE_INTEGER:
		dptr = &data->v_integer;
d3483 5
a3487 4
	case AML_OBJTYPE_OPREGION:
		/* Depending on size, allocate buffer or integer */
		aml_xresolve(scope, data);
		dptr = aml_xgetptr(&tmp, rlen << 3);
d3489 5
a3493 5
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		/* Set to integer for now.. */
		_aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, 0x0, NULL);
		dptr = &tmp.v_integer;
d3496 1
a3496 1
		aml_die("jk XREAD/WRITE: unknown type: %x\n", data->type);
d3499 15
d3515 2
a3516 90
	aml_lockfield(scope, fld);
	if (mode == ACPI_IOREAD) {
		sptr = aml_xgetptr(buf, blen);
		switch (data->type) {
		case AML_OBJTYPE_OPREGION:
			/* Do GASIO into temp buffer, bitcopy into result */
			aml_xgasio(data->v_opregion.iospace,
			    data->v_opregion.iobase+(bpos>>3),
			    rlen, dptr, ACPI_IOREAD, mask+1,
			    aml_nodename(fld->node));
			aml_bufcpy(sptr, 0, dptr, bpos & 7, blen);
			break;
		case AML_OBJTYPE_FIELDUNIT:
		case AML_OBJTYPE_BUFFERFIELD:
			/* Do FieldIO into temp buffer, bitcopy into result */
			aml_xfldio(scope, data, &tmp, ACPI_IOREAD);
			aml_bufcpy(sptr, 0, dptr, bpos & 7, blen);
			break;
		default:
			/* bitcopy into result */
			aml_bufcpy(sptr, 0, dptr, bpos, blen);
			break;
		}
	}
	else {
		switch (buf->type) {
		case AML_OBJTYPE_INTEGER:
			slen = aml_intlen;
			break;
		default:
			slen = buf->length<<3;
			break;
		}
		if (slen < blen) {
#ifndef SMALL_KERNEL
			aml_showvalue(fld, 0);
			aml_showvalue(buf, 0);
#endif
			aml_die("BIG SOURCE %d %d %s", buf->length, blen>>3, "");
		}
		if (buf->type != AML_OBJTYPE_INTEGER)
			aml_die("writefield: not integer\n");
		sptr = &buf->v_integer;

		switch (data->type) {
		case AML_OBJTYPE_OPREGION:
			if (!aligned && preserve == AML_FIELD_PRESERVE) {
				/* Preserve contents: read current value */
				aml_xgasio(data->v_opregion.iospace,
				    data->v_opregion.iobase+(bpos>>3),
				    rlen, dptr, ACPI_IOREAD, mask+1,
				    aml_nodename(fld->node));
			}
			/* Bitcopy data into temp buffer, write GAS */
			if (preserve == AML_FIELD_WRITEASONES)
				memset(dptr, 0xFF, tmp.length);
			aml_bufcpy(dptr, bpos & 7, sptr, 0, blen);
			aml_xgasio(data->v_opregion.iospace,
			    data->v_opregion.iobase+(bpos>>3),
			    rlen, dptr, ACPI_IOWRITE, mask+1,
			    aml_nodename(fld->node));
			break;
		case AML_OBJTYPE_FIELDUNIT:
		case AML_OBJTYPE_BUFFERFIELD:
			if (!aligned && preserve == AML_FIELD_PRESERVE) {
				/* Preserve contents: read current value */
				aml_xfldio(scope, data, &tmp, ACPI_IOREAD);
				if (tmp.type != AML_OBJTYPE_INTEGER)
					dptr = tmp.v_buffer;
			}
			else {
				dptr = aml_xgetptr(&tmp, rlen<<3);
			}
			/* Bitcopy data into temp buffer, write field */
			if (preserve == AML_FIELD_WRITEASONES)
				memset(dptr, 0xFF, tmp.length);
			aml_bufcpy(dptr, bpos & 7, sptr, 0, blen);
			aml_xfldio(scope, data, &tmp, ACPI_IOWRITE);
			break;
		default:
			if (blen > aml_intlen) {
				aml_die("jk Big Buffer other!\n");
			}
			aml_bufcpy(dptr, bpos, sptr, 0, blen);
			break;
		}
	}
	aml_freevalue(&tmp);
	aml_unlockfield(scope, fld);
}
d3518 1
a3518 41
/* Create Field Object          data		index
 *   AMLOP_FIELD		n:OpRegion	NULL
 *   AMLOP_INDEXFIELD		n:Field		n:Field
 *   AMLOP_BANKFIELD		n:OpRegion	n:Field
 *   AMLOP_CREATEFIELD		t:Buffer	NULL
 *   AMLOP_CREATEBITFIELD	t:Buffer	NULL
 *   AMLOP_CREATEBYTEFIELD	t:Buffer	NULL
 *   AMLOP_CREATEWORDFIELD	t:Buffer	NULL
 *   AMLOP_CREATEDWORDFIELD	t:Buffer	NULL
 *   AMLOP_CREATEQWORDFIELD	t:Buffer	NULL
 *   AMLOP_INDEX		t:Buffer	NULL
 */
void
aml_xcreatefield(struct aml_value *field, int opcode,
		struct aml_value *data, int bpos, int blen,
		struct aml_value *index, int indexval)
{
	dnprintf(10, "## %s(%s): %s %.4x-%.4x\n", 
	    aml_mnem(opcode, 0),
	    blen > aml_intlen ? "BUF" : "INT",
	    aml_nodename(field->node), bpos, blen);
	if (index) {
		dnprintf(10, "  index:%s:%.2x\n", aml_nodename(index->node), 
		    indexval);
	}
	dnprintf(10, "  data:%s\n", aml_nodename(data->node));
	field->type = (opcode == AMLOP_FIELD || 
	    opcode == AMLOP_INDEXFIELD || 
	    opcode == AMLOP_BANKFIELD) ?
	    AML_OBJTYPE_FIELDUNIT : 
	    AML_OBJTYPE_BUFFERFIELD;
	field->v_field.type = opcode;
	field->v_field.bitpos = bpos;
	field->v_field.bitlen = blen;
	field->v_field.ref3 = indexval;
	field->v_field.ref2 = index;
	field->v_field.ref1 = data;

	/* Increase reference count */
	aml_xaddref(data, "Field.Data");
	aml_xaddref(index, "Field.Index");
d3521 3
a3523 4
/* Parse Field/IndexField/BankField scope */
void
aml_xparsefieldlist(struct aml_scope *mscope, int opcode, int flags, 
    struct aml_value *data, struct aml_value *index, int indexval)
d3525 2
a3526 2
	struct aml_value *rv;
	int bpos, blen;
d3528 5
a3532 8
	if (mscope == NULL)
		return;
	bpos = 0;
	while (mscope->pos < mscope->end) {
		switch (*mscope->pos) {
		case 0x00: // reserved, length
			mscope->pos++;
			blen = aml_parselength(mscope);
d3534 6
a3539 29
		case 0x01: // flags
			mscope->pos += 3;
			blen = 0;
			break;
		default: // 4-byte name, length
			mscope->pos = aml_xparsename(mscope->pos, mscope->node,
			    ns_xcreate, &rv);
			blen = aml_parselength(mscope);
			rv->v_field.flags = flags;
			switch (opcode) {
			case AMLOP_FIELD:
				/* nbF */
				aml_xcreatefield(rv, opcode, data, bpos, 
				    blen, NULL, 0);
				break;
			case AMLOP_INDEXFIELD:
				/* nnbF */
				aml_xcreatefield(rv, opcode, data, bpos & 7, 
				    blen, index, bpos>>3);
				break;
			case AMLOP_BANKFIELD:
				/* nnibF */
				aml_xcreatefield(rv, opcode, data, bpos, 
				    blen, index, indexval);
				break;
			}
			break;
		}
		bpos += blen;
a3540 10
}

/*
 * Mutex/Event utility functions 
 */
int	acpi_xmutex_acquire(struct aml_scope *, struct aml_value *, int);
void	acpi_xmutex_release(struct aml_scope *, struct aml_value *);
int	acpi_xevent_wait(struct aml_scope *, struct aml_value *, int);
void	acpi_xevent_signal(struct aml_scope *, struct aml_value *);
void	acpi_xevent_reset(struct aml_scope *, struct aml_value *);
a3541 21
int
acpi_xmutex_acquire(struct aml_scope *scope, struct aml_value *mtx, 
    int timeout)
{
	int err;

	if (mtx->v_mtx.owner == NULL || scope == mtx->v_mtx.owner) {
		/* We are now the owner */
		mtx->v_mtx.owner = scope;
		if (mtx == aml_global_lock) {
			dnprintf(10,"LOCKING GLOBAL\n");
			err = acpi_acquire_global_lock(&dsdt_softc->sc_facs->global_lock);
		}
		dnprintf(5,"%s acquires mutex %s\n", scope->node->name,
		    mtx->node->name);
		return 0;
	}
	else if (timeout == 0) {
		return 1;
	}
	/* Wait for mutex */
d3546 2
a3547 1
acpi_xmutex_release(struct aml_scope *scope, struct aml_value *mtx)
d3549 1
a3549 1
	int err;
d3551 4
a3554 8
	if (mtx == aml_global_lock) {
	  	dnprintf(10,"UNLOCKING GLOBAL\n");
		err=acpi_release_global_lock(&dsdt_softc->sc_facs->global_lock);
	}
	dnprintf(5, "%s releases mutex %s\n", scope->node->name,
	    mtx->node->name);
	mtx->v_mtx.owner = NULL;
	/* Wakeup waiters */
d3558 1
a3558 1
acpi_xevent_wait(struct aml_scope *scope, struct aml_value *evt, int timeout)
d3560 8
a3567 3
	if (evt->v_evt.state == 1) {
		/* Object is signaled */
		return 0;
d3569 3
a3571 7
	else if (timeout == 0) {
		/* Zero timeout */
		return 1;
	}
	/* Wait for timeout or signal */
	return 0;
}
d3573 1
a3573 5
void
acpi_xevent_signal(struct aml_scope *scope, struct aml_value *evt)
{
	evt->v_evt.state = 1;
	/* Wakeup waiters */
d3576 4
a3579 5
void
acpi_xevent_reset(struct aml_scope *scope, struct aml_value *evt)
{
	evt->v_evt.state = 0;
}
d3581 1
a3581 4
/* Store result value into an object */
void
aml_xstore(struct aml_scope *scope, struct aml_value *lhs , int64_t ival, 
    struct aml_value *rhs)
d3583 2
a3584 2
	struct aml_value tmp;
	int mlen;
d3586 9
a3594 39
	/* Already set */
	if (lhs == rhs || lhs == NULL || lhs->type == AML_OBJTYPE_NOTARGET) {
		return;
	}
	memset(&tmp, 0, sizeof(tmp));
	tmp.refcnt=99;
	if (rhs == NULL) {
		rhs = _aml_setvalue(&tmp, AML_OBJTYPE_INTEGER, ival, NULL);
	}
	if (rhs->type == AML_OBJTYPE_BUFFERFIELD || 
	    rhs->type == AML_OBJTYPE_FIELDUNIT) {
		aml_xfldio(scope, rhs, &tmp, ACPI_IOREAD);
		rhs = &tmp;
	}
	while (lhs->type == AML_OBJTYPE_OBJREF) {
		lhs = lhs->v_objref.ref;
	}
	switch (lhs->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		aml_copyvalue(lhs, rhs);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_xfldio(scope, lhs, rhs, ACPI_IOWRITE);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		break;
	case AML_OBJTYPE_INTEGER:
		aml_xconvert(rhs, &rhs, lhs->type, 0);
		lhs->v_integer = rhs->v_integer;
		aml_xdelref(&rhs, "store.int");
		break;
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_STRING:
		aml_xconvert(rhs, &rhs, lhs->type, 0);
		if (lhs->length < rhs->length) {
			dnprintf(10,"Overrun! %d,%d\n", lhs->length, rhs->length);
			aml_freevalue(lhs);
			_aml_setvalue(lhs, rhs->type, rhs->length, NULL);
d3596 13
a3608 16
		mlen = min(lhs->length, rhs->length);
		memset(lhs->v_buffer, 0x00, lhs->length);
		memcpy(lhs->v_buffer, rhs->v_buffer, mlen);
		aml_xdelref(&rhs, "store.bufstr");
		break;
	case AML_OBJTYPE_PACKAGE:
		/* Convert to LHS type, copy into LHS */
		if (rhs->type != AML_OBJTYPE_PACKAGE) {
			aml_die("Copy non-package into package?");
		}
		aml_freevalue(lhs);
		aml_copyvalue(lhs, rhs);
		break;
	default:
		aml_die("Store to default type!	 %x\n", lhs->type);
		break;
d3610 1
a3610 1
	aml_freevalue(&tmp);
a3612 3
/* Disassembler routines */
void aml_disprintf(void *arg, const char *fmt, ...);

d3614 1
a3614 1
aml_disprintf(void *arg, const char *fmt, ...)
d3616 1
a3616 5
	va_list ap;

	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
d3619 2
a3620 4
void
aml_disasm(struct aml_scope *scope, int lvl, 
    void (*dbprintf)(void *, const char *, ...), 
    void *arg)
d3622 1
a3622 8
	int pc, opcode;
	struct aml_opcode *htab;
	uint64_t ival;
	struct aml_value *rv, tmp;
	uint8_t *end;
	struct aml_scope *ms;
	char *ch;
	char  mch[64];
d3624 1
a3624 2
	if (dbprintf == NULL)
		dbprintf = aml_disprintf;
d3626 7
a3632 32
	pc = aml_pc(scope->pos);
	opcode = aml_parseopcode(scope);
	htab = aml_findopcode(opcode);

	/* Display address + indent */
	if (lvl <= 0x7FFF) {
		dbprintf(arg, "%.4x ", pc);
		for (pc=0; pc<lvl; pc++) {
			dbprintf(arg, "	 ");
		}
	}
	ch = NULL;
	switch (opcode) {
	case AMLOP_NAMECHAR:
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
		if (rv->type == AML_OBJTYPE_NAMEREF) {
			ch = "@@@@@@";
			aml_xdelref(&rv, "disasm");
			break;
		}
		/* if this is a method, get arguments */
		strlcpy(mch, aml_nodename(rv->node), sizeof(mch));
		if (rv->type == AML_OBJTYPE_METHOD) {
			strlcat(mch, "(", sizeof(mch));
			for (ival=0; ival<AML_METHOD_ARGCOUNT(rv->v_method.flags); ival++) {
				strlcat(mch, ival ? ", %z" : "%z", 
				    sizeof(mch));
			}
			strlcat(mch, ")", sizeof(mch));
		}
		ch = mch;
d3634 2
a3635 26

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
	case AMLOP_NOP:
	case AMLOP_REVISION:
	case AMLOP_DEBUG:
	case AMLOP_CONTINUE:
	case AMLOP_BREAKPOINT:
	case AMLOP_BREAK:
		ch="%m";
d3637 2
a3638 14
	case AMLOP_BYTEPREFIX:
		ch="%b";
		break;
	case AMLOP_WORDPREFIX:
		ch="%w";
		break;
	case AMLOP_DWORDPREFIX:
		ch="%d";
		break;
	case AMLOP_QWORDPREFIX:
		ch="%q";
		break;
	case AMLOP_STRINGPREFIX:
	  	ch="%a";
d3640 4
d3645 1
a3645 1439
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
	case AMLOP_LNOT:
	case AMLOP_SIZEOF:
	case AMLOP_DEREFOF:
	case AMLOP_REFOF:
	case AMLOP_OBJECTTYPE:
	case AMLOP_UNLOAD:
	case AMLOP_RELEASE:
	case AMLOP_SIGNAL:
	case AMLOP_RESET:
	case AMLOP_STALL:
	case AMLOP_SLEEP:
	case AMLOP_RETURN:
		ch="%m(%n)";
		break;
	case AMLOP_OR:
	case AMLOP_ADD:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_XOR:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_NOR:
	case AMLOP_MOD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_INDEX:
	case AMLOP_CONCAT:
	case AMLOP_CONCATRES:
	case AMLOP_TOSTRING:
		ch="%m(%n, %n, %n)";
		break;
	case AMLOP_CREATEBYTEFIELD:
	case AMLOP_CREATEWORDFIELD:
	case AMLOP_CREATEDWORDFIELD:
	case AMLOP_CREATEQWORDFIELD:
	case AMLOP_CREATEBITFIELD:
		ch="%m(%n, %n, %N)";
		break;
	case AMLOP_CREATEFIELD:
		ch="%m(%n, %n, %n, %N)";
		break;
	case AMLOP_DIVIDE:
	case AMLOP_MID:
		ch="%m(%n, %n, %n, %n)";
		break;
	case AMLOP_LAND:
	case AMLOP_LOR:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LLESS:
	case AMLOP_LEQUAL:
	case AMLOP_LGREATEREQUAL:
	case AMLOP_LGREATER:
	case AMLOP_NOT:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
	case AMLOP_TOINTEGER:
	case AMLOP_TOBUFFER:
	case AMLOP_TOHEXSTRING:
	case AMLOP_TODECSTRING:
	case AMLOP_FROMBCD:
	case AMLOP_TOBCD:
	case AMLOP_WAIT:
	case AMLOP_LOAD:
	case AMLOP_STORE:
	case AMLOP_NOTIFY:
	case AMLOP_COPYOBJECT:
		ch="%m(%n, %n)";
		break;
	case AMLOP_ACQUIRE:
		ch = "%m(%n, %w)";
		break;
	case AMLOP_CONDREFOF:
		ch="%m(%R, %n)";
		break;
	case AMLOP_ALIAS:
		ch="%m(%n, %N)";
		break;
	case AMLOP_NAME:
		ch="%m(%N, %n)";
		break;
	case AMLOP_EVENT:
		ch="%m(%N)";
		break;
	case AMLOP_MUTEX:
		ch = "%m(%N, %b)";
		break;
	case AMLOP_OPREGION:
		ch = "%m(%N, %b, %n, %n)";
		break;
	case AMLOP_DATAREGION:
		ch="%m(%N, %n, %n, %n)";
		break;
	case AMLOP_FATAL:
		ch = "%m(%b, %d, %n)";
		break;
	case AMLOP_IF:
	case AMLOP_WHILE:
	case AMLOP_SCOPE:
	case AMLOP_THERMALZONE:
	case AMLOP_VARPACKAGE:
		end = aml_parseend(scope);
		ch = "%m(%n) {\n%T}";
		break;
	case AMLOP_DEVICE:
		end = aml_parseend(scope);
		ch = "%m(%N) {\n%T}";
		break;
	case AMLOP_POWERRSRC:
		end = aml_parseend(scope);
		ch = "%m(%N, %b, %w) {\n%T}";
		break;
	case AMLOP_PROCESSOR:
		end = aml_parseend(scope);
		ch = "%m(%N, %b, %d, %b) {\n%T}";
		break;
	case AMLOP_METHOD:
		end = aml_parseend(scope);
		ch = "%m(%N, %b) {\n%T}";
		break;
	case AMLOP_PACKAGE:
		end = aml_parseend(scope);
		ch = "%m(%b) {\n%T}";
		break;
	case AMLOP_ELSE:
		end = aml_parseend(scope);
		ch = "%m {\n%T}";
		break;
	case AMLOP_BUFFER:
		end = aml_parseend(scope);
		ch = "%m(%n) { %B }";
		break;
	case AMLOP_INDEXFIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %n, %b) {\n%F}";
		break;
	case AMLOP_BANKFIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %n, %n, %b) {\n%F}";
		break;
	case AMLOP_FIELD:
		end = aml_parseend(scope);
		ch = "%m(%n, %b) {\n%F}";
		break;
	case AMLOP_MATCH:
		ch = "%m(%n, %b, %n, %b, %n, %n)";
		break;
	case AMLOP_LOADTABLE:
		ch = "%m(%n, %n, %n, %n, %n, %n)";
		break;
	default:
		aml_die("opcode = %x\n", opcode);
		break;
	}

	/* Parse printable buffer args */
	while (ch && *ch) {
		char c;

		if (*ch != '%') {
			dbprintf(arg,"%c", *(ch++));
			continue;
		}
		c = *(++ch);
		switch (c) {
		case 'b':
		case 'w':
		case 'd':
		case 'q':
			/* Parse simple object: don't allocate */
			aml_xparsesimple(scope, c, &tmp);
			dbprintf(arg,"0x%llx", tmp.v_integer);
			break;
		case 'a':
			dbprintf(arg, "\'%s\'", scope->pos);
			scope->pos += strlen(scope->pos)+1;
			break;			
		case 'N':
			/* Create Name */
			rv = aml_xparsesimple(scope, c, NULL);
			dbprintf(arg,aml_nodename(rv->node));
			break;
		case 'm':
			/* display mnemonic */
			dbprintf(arg,htab->mnem);
			break;
		case 'R':
			/* Search name */
			scope->pos = aml_xparsename(scope->pos, scope->node, 
			    ns_xdis, &rv);
			break;
		case 'z':
		case 'n':
			/* generic arg: recurse */
			aml_disasm(scope, lvl | 0x8000, dbprintf, arg);
			break;
		case 'B':
			/* Buffer */
			scope->pos = end;
			break;
		case 'F':
			/* Field List */
			tmp.v_buffer = scope->pos;
			tmp.length   = end - scope->pos;

			ms = aml_xpushscope(scope, &tmp, scope->node, 0);
			while (ms && ms->pos < ms->end) {
				if (*ms->pos == 0x00) {
					ms->pos++;
					aml_parselength(ms);
				}
				else if (*ms->pos == 0x01) {
					ms->pos+=3;
				}
				else {
					ms->pos = aml_xparsename(ms->pos, 
					    ms->node, ns_xcreate, &rv);
					aml_parselength(ms);
					dbprintf(arg,"	%s\n", 
					    aml_nodename(rv->node));
				}
			}
			aml_xpopscope(ms);

			/* Display address and closing bracket */
			dbprintf(arg,"%.4x ", aml_pc(scope->pos));
			for (pc=0; pc<(lvl & 0x7FFF); pc++) {
				dbprintf(arg,"	");
			}
			scope->pos = end;
			break;
		case 'T':
			/* Scope: Termlist */
			tmp.v_buffer = scope->pos;
			tmp.length   = end - scope->pos;

			ms = aml_xpushscope(scope, &tmp, scope->node, 0);
			while (ms && ms->pos < ms->end) {
				aml_disasm(ms, (lvl + 1) & 0x7FFF, 
				    dbprintf, arg);
			}
			aml_xpopscope(ms);

			/* Display address and closing bracket */
			dbprintf(arg,"%.4x ", aml_pc(scope->pos));
			for (pc=0; pc<(lvl & 0x7FFF); pc++) {
				dbprintf(arg,"	");
			}
			scope->pos = end;
			break;
		}
		ch++;
	}
	if (lvl <= 0x7FFF) {
		dbprintf(arg,"\n");
	}
}

int aml_busy;

/* Evaluate method or buffervalue objects */
struct aml_value *
aml_xeval(struct aml_scope *scope, struct aml_value *my_ret, int ret_type,
    int argc, struct aml_value *argv)
{
	struct aml_value *tmp = my_ret;
	struct aml_scope *ms;
	int idx;

	switch (tmp->type) {
	case AML_OBJTYPE_METHOD:
		dnprintf(10,"\n--== Eval Method [%s, %d args] to %c ==--\n", 
		    aml_nodename(tmp->node), 
		    AML_METHOD_ARGCOUNT(tmp->v_method.flags),
		    ret_type);
		ms = aml_xpushscope(scope, tmp, tmp->node, AMLOP_METHOD);
		ms->args = acpi_os_malloc(7 * sizeof(struct aml_value));
		
		/* Parse method arguments */
		for (idx=0; idx<AML_METHOD_ARGCOUNT(tmp->v_method.flags); idx++) {
			ms->args[idx].type = AML_OBJTYPE_OBJREF;
			ms->args[idx].v_objref.type = AMLOP_ARG0 + idx;
			if (argv) {
				ms->args[idx].v_objref.ref = &argv[idx];
				argv[idx].refcnt = 99;
			}
			else {
				ms->args[idx].v_objref.ref = 
				    aml_xparse(scope, 't', "ARGX");
			}
		}
#ifdef ACPI_DEBUG
		aml_showstack(ms);
#endif
		
		/* Evaluate method scope */
		if (tmp->v_method.fneval != NULL) {
			my_ret = tmp->v_method.fneval(ms, NULL);
		}
		else {
			aml_xparse(ms, 'T', "METHEVAL");
			my_ret = ms->retv;
		}
		dnprintf(10,"\n--==Finished evaluating method: %s %c\n", 
		    aml_nodename(tmp->node), ret_type);
#ifdef ACPI_DEBUG
		aml_showvalue(my_ret, 0);
		aml_showstack(ms);
#endif
		aml_xpopscope(ms);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		my_ret = aml_allocvalue(0,0,NULL);
		dnprintf(20,"quick: Convert Bufferfield to %c 0x%x\n", 
		    ret_type, my_ret);
		aml_xfldio(scope, tmp, my_ret, ACPI_IOREAD);
		break;
	}
	if (ret_type == 'i' && my_ret && my_ret->type != AML_OBJTYPE_INTEGER) {
#ifndef SMALL_KERNEL
		aml_showvalue(my_ret, 8-100);
#endif
		aml_die("Not Integer");
	}
	return my_ret;
}

/*
 * The following opcodes produce return values
 *   TOSTRING	-> Str
 *   TOHEXSTR	-> Str
 *   TODECSTR	-> Str
 *   STRINGPFX	-> Str
 *   BUFFER	-> Buf
 *   CONCATRES	-> Buf
 *   TOBUFFER	-> Buf
 *   MID	-> Buf|Str
 *   CONCAT	-> Buf|Str
 *   PACKAGE	-> Pkg
 *   VARPACKAGE -> Pkg
 *   LOCALx	-> Obj
 *   ARGx	-> Obj
 *   NAMECHAR	-> Obj
 *   REFOF	-> ObjRef
 *   INDEX	-> ObjRef
 *   DEREFOF	-> DataRefObj
 *   COPYOBJECT -> DataRefObj
 *   STORE	-> DataRefObj

 *   ZERO	-> Int
 *   ONE	-> Int
 *   ONES	-> Int
 *   REVISION	-> Int
 *   B/W/D/Q	-> Int
 *   OR		-> Int
 *   AND	-> Int
 *   ADD	-> Int
 *   NAND	-> Int
 *   XOR	-> Int
 *   SHL	-> Int
 *   SHR	-> Int
 *   NOR	-> Int
 *   MOD	-> Int
 *   SUBTRACT	-> Int
 *   MULTIPLY	-> Int
 *   DIVIDE	-> Int
 *   NOT	-> Int
 *   TOBCD	-> Int
 *   FROMBCD	-> Int
 *   FSLEFTBIT	-> Int
 *   FSRIGHTBIT -> Int
 *   INCREMENT	-> Int
 *   DECREMENT	-> Int
 *   TOINTEGER	-> Int
 *   MATCH	-> Int
 *   SIZEOF	-> Int
 *   OBJECTTYPE -> Int
 *   TIMER	-> Int

 *   CONDREFOF	-> Bool
 *   ACQUIRE	-> Bool
 *   WAIT	-> Bool
 *   LNOT	-> Bool
 *   LAND	-> Bool
 *   LOR	-> Bool
 *   LLESS	-> Bool
 *   LEQUAL	-> Bool
 *   LGREATER	-> Bool
 *   LNOTEQUAL	-> Bool
 *   LLESSEQUAL -> Bool
 *   LGREATEREQ -> Bool

 *   LOADTABLE	-> DDB
 *   DEBUG	-> Debug

 *   The following opcodes do not generate a return value:
 *   NOP
 *   BREAKPOINT
 *   RELEASE
 *   RESET
 *   SIGNAL
 *   NAME
 *   ALIAS
 *   OPREGION
 *   DATAREGION
 *   EVENT
 *   MUTEX
 *   SCOPE
 *   DEVICE
 *   THERMALZONE
 *   POWERRSRC
 *   PROCESSOR
 *   METHOD
 *   CREATEFIELD
 *   CREATEBITFIELD
 *   CREATEBYTEFIELD
 *   CREATEWORDFIELD
 *   CREATEDWORDFIELD
 *   CREATEQWORDFIELD
 *   FIELD
 *   INDEXFIELD
 *   BANKFIELD
 *   STALL
 *   SLEEP
 *   NOTIFY
 *   FATAL
 *   LOAD
 *   UNLOAD
 *   IF
 *   ELSE
 *   WHILE
 *   BREAK
 *   CONTINUE
 */

/* Parse a simple object from AML Bytestream */
struct aml_value *
aml_xparsesimple(struct aml_scope *scope, char ch, struct aml_value *rv)
{
	if (ch == AML_ARG_CREATENAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xcreate, &rv);
		return rv;
	}
	else if (ch == AML_ARG_SEARCHNAME) {
		scope->pos = aml_xparsename(scope->pos, scope->node, 
		    ns_xsearch, &rv);
		return rv;
	}
	if (rv == NULL)
		rv = aml_allocvalue(0,0,NULL);
	switch (ch) {
	case AML_ARG_REVISION:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, AML_REVISION, NULL);
		break;
	case AML_ARG_DEBUG:
		_aml_setvalue(rv, AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		break;
	case AML_ARG_BYTE:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
		    aml_get8(scope->pos), NULL);
		scope->pos += 1;
		break;
	case AML_ARG_WORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
		    aml_get16(scope->pos), NULL);
		scope->pos += 2;
		break;
	case AML_ARG_DWORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
		    aml_get32(scope->pos), NULL);
		scope->pos += 4;
		break;
	case AML_ARG_QWORD:
		_aml_setvalue(rv, AML_OBJTYPE_INTEGER, 
		    aml_get64(scope->pos), NULL);
		scope->pos += 8;
		break;
	case AML_ARG_STRING:
		_aml_setvalue(rv, AML_OBJTYPE_STRING, -1, scope->pos);
		scope->pos += rv->length+1;
		break;
	}
	return rv;
}

/*
 * Main Opcode Parser/Evaluator 
 *
 * ret_type is expected type for return value
 *   'o' = Data Object (Int/Str/Buf/Pkg/Name)
 *   'i' = Integer
 *   't' = TermArg     (Int/Str/Buf/Pkg)
 *   'r' = Target      (NamedObj/Local/Arg/Null)
 *   'S' = SuperName   (NamedObj/Local/Arg)
 *   'T' = TermList
 */
#define aml_debugger(x)

struct aml_value *
aml_xparse(struct aml_scope *scope, int ret_type, const char *stype)
{
	int    opcode, idx, pc, optype[8];
	struct aml_opcode *htab;
	struct aml_value *opargs[8], *my_ret, *tmp, *cname;
	struct aml_scope *mscope;
	const char *ch;
	int64_t ival;

	my_ret = NULL;
	if (scope == NULL || scope->pos >= scope->end) {
		return NULL;
	}
 start:
	if (odp++ > 125)
		panic("depth");

	/* --== Stage 0: Get Opcode ==-- */
	pc = aml_pc(scope->pos);
	aml_debugger(scope);

	opcode = aml_parseopcode(scope);
	delay(amlop_delay);

	htab = aml_findopcode(opcode);
	if (htab == NULL) {
		/* No opcode handler */
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode,
		    aml_pc(scope->pos - opsize(opcode)));
	}
	dnprintf(18,"%.4x %s\n", pc, aml_mnem(opcode, scope->pos));

	/* --== Stage 1: Process opcode arguments ==-- */
	cname = NULL;
	memset(opargs, 0, sizeof(opargs));
	memset(optype, 0, sizeof(optype));
	idx = 0;
	for (ch = htab->args; *ch; ch++) {
		struct aml_value *rv;
		uint8_t *end;

		rv = NULL;
		switch (*ch) {
		case AML_ARG_OBJLEN:
			end = aml_parseend(scope);
			break;
		case AML_ARG_IFELSE: 
                        /* Special Case: IF-ELSE:piTbpT or IF:piT */
			ch = (*end == AMLOP_ELSE && end < scope->end) ? 
			    "-TbpT" : "-T";
			break;

			/* Complex arguments */
		case 's':
		case 'S': 
		case AML_ARG_TARGET: 
		case AML_ARG_TERMOBJ:
		case AML_ARG_INTEGER:
			if (*ch == 'r' && *scope->pos == AMLOP_ZERO) {
				/* Special case: NULL Target */
				rv = aml_allocvalue(AML_OBJTYPE_NOTARGET, 0, NULL);
				scope->pos++;
			}
			else {
				rv = aml_xparse(scope, *ch, htab->mnem);
				if (rv == NULL)
					aml_die("NULL RESULT");
			}
			break;

			/* Simple arguments */
		case AML_ARG_WHILE:
		case AML_ARG_BUFFER:
		case AML_ARG_METHOD:
		case AML_ARG_FIELDLIST:
		case AML_ARG_TERMOBJLIST:
			rv = aml_allocvalue(AML_OBJTYPE_SCOPE, 0, NULL);
			rv->v_buffer = scope->pos;
			rv->length = end - scope->pos;
			scope->pos = end;
			break;
		case AML_ARG_CONST:
			rv = aml_allocvalue(AML_OBJTYPE_INTEGER, 
			    (char)opcode, NULL);
			break;
		case AML_ARG_CREATENAME:
			rv = aml_xparsesimple(scope, *ch, NULL);
			cname = rv;
			if (cname->type != 0 && opcode != AMLOP_SCOPE)
				dnprintf(10, "%s value already exists %s\n",
				    aml_nodename(cname->node),
				    htab->mnem);
			break;
		case AML_ARG_SEARCHNAME:
			rv = aml_xparsesimple(scope, *ch, NULL);
			if (rv->type != AML_OBJTYPE_NAMEREF)
				aml_xaddref(rv, "Search Name");
			break;
		case AML_ARG_BYTE:
		case AML_ARG_WORD:
		case AML_ARG_DWORD:
		case AML_ARG_QWORD:
		case AML_ARG_DEBUG:
		case AML_ARG_STRING:
		case AML_ARG_REVISION:
			rv = aml_xparsesimple(scope, *ch, NULL);
			break;
		case AML_ARG_STKLOCAL:
			mscope = aml_xfindscope(scope, AMLOP_METHOD, 0);
			if (mscope->locals == NULL) {
				mscope->locals = acpi_os_malloc(8 * sizeof(struct aml_value));
			}
			rv = &mscope->locals[opcode - AMLOP_LOCAL0];
			if (rv->refcnt == 0) {
				rv->refcnt++;
			}
			rv->stack = opcode;
			rv->node  = mscope->node;
			break;
		case AML_ARG_STKARG:
			mscope = aml_xfindscope(scope, AMLOP_METHOD, 0);
			rv = mscope->args[opcode - AMLOP_ARG0].v_objref.ref;
			break;
		default:
			aml_die("Unknown arg type: %c\n", *ch);
			break;
		}
		if (rv != NULL) {
			optype[idx] = *ch;
			opargs[idx++] = rv;
		}
	}

	/* Check for Op(Src1,Src2,Src1) type operations */
	for (idx=0; optype[idx]; idx++) {
		int jdx;
		for (jdx=idx+1; optype[jdx]; jdx++) {
			if (opargs[idx] == opargs[jdx]) {
				dnprintf(12,"STORE SAME %s %d,%d -> [%s] ", 
				    htab->mnem, idx, jdx, 
				    aml_nodename(scope->node));
			}
		}
	}

	/* --== Stage 2: Process opcode ==-- */
	ival = 0;
	my_ret = NULL;
	mscope = NULL;
	switch (opcode) {
	case AMLOP_NOP:
	case AMLOP_BREAKPOINT:
		break;
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		my_ret = opargs[0];
		aml_xaddref(my_ret, htab->mnem);
		if (ret_type == AML_ARG_INTEGER) {
			/* Return copy of integer value */
			aml_xconvert(my_ret, &my_ret, AML_OBJTYPE_INTEGER, 0);
			ival = my_ret->v_integer;
			aml_xdelref(&my_ret, "local.int");
			my_ret = NULL;
		}
		else if (ret_type == AML_ARG_TARGET) {
			/* Store to LocalX: free object */
			aml_freevalue(my_ret);
		}
		break;
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		/* These are not allocated dynamically but do not have node */
		my_ret = opargs[0];
		aml_xaddref(my_ret, htab->mnem);
		break;
	case AMLOP_NAMECHAR:
		/* opargs[0] = named object (node != NULL), or nameref */
		my_ret = opargs[0];
		if (my_ret->type == AML_OBJTYPE_OBJREF) {
			my_ret = my_ret->v_objref.ref;
			aml_xaddref(my_ret, "de-alias");
		}
		if (ret_type == 'i' || ret_type == 't' || ret_type == 'T') {
			/* Return TermArg or Integer: Evaluate object */
			my_ret = aml_xeval(scope, my_ret, ret_type, 0, NULL);
		}
		else if (my_ret->type == AML_OBJTYPE_METHOD) {
			/* This should only happen with CondRef */
			dnprintf(12,"non-termarg method : %s\n", stype);
			aml_xaddref(my_ret, "zoom");
		}
		break;

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_DEBUG:
	case AMLOP_REVISION:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
		my_ret = opargs[0];
		break;

	case AMLOP_BUFFER:
		/* Buffer: iB => Buffer */
		my_ret = aml_allocvalue(AML_OBJTYPE_BUFFER, 
		    opargs[0]->v_integer, NULL);
		memcpy(my_ret->v_buffer, opargs[1]->v_buffer, 
		    opargs[1]->length);
		break;
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		/* Package/VarPackage: bT/iT => Package */
		my_ret = aml_allocvalue(AML_OBJTYPE_PACKAGE, 
		    opargs[0]->v_integer, 0);
		mscope = aml_xpushscope(scope, opargs[1], scope->node, 
		    AMLOP_PACKAGE);

		for (idx=0; idx<my_ret->length; idx++) {
			tmp = aml_xparse(mscope, 'o', "Package");
			if (tmp == NULL) {
				continue;
			}
			if (tmp->node) {
				/* Object is a named node: store as string */
				const char *nn = aml_nodename(tmp->node);
				aml_xdelref(&tmp, "pkg.node");
				tmp = aml_allocvalue(AML_OBJTYPE_STRING, 
				    -1, nn);
			}
			else if (tmp->type == AML_OBJTYPE_NAMEREF) {
				const char *nn = aml_getname(tmp->v_nameref);
				aml_xdelref(&tmp, "pkg.node");
				tmp = aml_allocvalue(AML_OBJTYPE_STRING, 
				    -1, nn);
			}
			/* Package value already allocated; delete it
			 * and replace with pointer to return value */
			aml_xdelref(&my_ret->v_package[idx], "pkg/init");
			my_ret->v_package[idx] = tmp;
		}
		aml_xpopscope(mscope);
		mscope = NULL;
		break;

		/* Math/Logical operations */
	case AMLOP_OR:
	case AMLOP_ADD:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_XOR:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_NOR:
	case AMLOP_MOD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
		/* XXX: iir => I */
		ival = aml_evalexpr(opargs[0]->v_integer, 
		    opargs[1]->v_integer, opcode);
		aml_xstore(scope, opargs[2], ival, NULL);
		break;
	case AMLOP_DIVIDE:
		/* Divide: iirr => I */
		ival = aml_evalexpr(opargs[0]->v_integer, 
		    opargs[1]->v_integer, AMLOP_MOD);
		aml_xstore(scope, opargs[2], ival, NULL);

		ival = aml_evalexpr(opargs[0]->v_integer, 
		    opargs[1]->v_integer, AMLOP_DIVIDE);
		aml_xstore(scope, opargs[3], ival, NULL);
		break;
	case AMLOP_NOT:
	case AMLOP_TOBCD:
	case AMLOP_FROMBCD:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		/* XXX: ir => I */
		ival = aml_evalexpr(opargs[0]->v_integer, 0, opcode);
		aml_xstore(scope, opargs[1], ival, NULL);
		break;
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		/* Inc/Dec: S => I */
		my_ret = aml_xeval(scope, opargs[0], AML_ARG_INTEGER, 0, NULL);
		ival = aml_evalexpr(my_ret->v_integer, 1, opcode);
		aml_xstore(scope, opargs[0], ival, NULL);
		break;
	case AMLOP_LNOT:
		/* LNot: i => Bool */
		ival = aml_evalexpr(opargs[0]->v_integer, 0, opcode);
		break;
	case AMLOP_LOR:
	case AMLOP_LAND:
		/* XXX: ii => Bool */
		ival = aml_evalexpr(opargs[0]->v_integer, 
		    opargs[1]->v_integer, opcode);
		break;
	case AMLOP_LLESS:
	case AMLOP_LEQUAL:
	case AMLOP_LGREATER:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LGREATEREQUAL:
		/* XXX: tt => Bool */
		ival = aml_xcompare(opargs[0], opargs[1], opcode);
		break;

		/* Reference/Store operations */
	case AMLOP_CONDREFOF:
		/* CondRef: rr => I */
		ival = 0;
		if (opargs[0]->node != NULL) {
			aml_freevalue(opargs[1]);

			/* Create Object Reference */
			_aml_setvalue(opargs[1], AML_OBJTYPE_OBJREF, 0, opargs[0]);
			opargs[1]->v_objref.type = AMLOP_REFOF;
			aml_xaddref(opargs[1], "CondRef");
			
			/* Mark that we found it */
			ival = -1;
		}
		break;
	case AMLOP_REFOF:
		/* RefOf: r => ObjRef */
		my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, 0, opargs[0]);
		my_ret->v_objref.type = AMLOP_REFOF;
		aml_xaddref(my_ret->v_objref.ref, "RefOf");
		break;
	case AMLOP_INDEX:
		/* Index: tir => ObjRef */
		idx = opargs[1]->v_integer;
		if (idx >= opargs[0]->length || idx < 0) {
#ifndef SMALL_KERNEL
			aml_showvalue(opargs[0], 0);
#endif
			aml_die("Index out of bounds %d/%d\n", idx, 
			    opargs[0]->length);
		}
		switch (opargs[0]->type) {
		case AML_OBJTYPE_PACKAGE:
			/* Don't set opargs[0] to NULL */
			if (ret_type == 't' || ret_type == 'i' || ret_type == 'T') {
				my_ret = opargs[0]->v_package[idx];
				aml_xaddref(my_ret, "Index.Package");
			}
			else {
				my_ret = aml_allocvalue(AML_OBJTYPE_OBJREF, 0,
				    opargs[0]->v_package[idx]);
				my_ret->v_objref.type = AMLOP_PACKAGE;
				aml_xaddref(my_ret->v_objref.ref, 
				    "Index.Package");
			}
			break;
		case AML_OBJTYPE_BUFFER:
		case AML_OBJTYPE_STRING:
		case AML_OBJTYPE_INTEGER:
			aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
			if (ret_type == 't' || ret_type == 'i' || ret_type == 'T') {
				dnprintf(12,"Index.Buf Term: %d = %x\n", 
				    idx, tmp->v_buffer[idx]);
				ival = tmp->v_buffer[idx];
			}
			else {
				dnprintf(12, "Index.Buf Targ\n");
				my_ret = aml_allocvalue(0,0,NULL);
				aml_xcreatefield(my_ret, AMLOP_INDEX, tmp, 
				    8 * idx, 8, NULL, 0);
			}
			aml_xdelref(&tmp, "Index.BufStr");
			break;
		default:
			aml_die("Unknown index : %x\n", opargs[0]->type);
			break;
		}
		aml_xstore(scope, opargs[2], ival, my_ret);
		break;
	case AMLOP_DEREFOF:
		/* DerefOf: t:ObjRef => DataRefObj */
		if (opargs[0]->type == AML_OBJTYPE_OBJREF) {
			my_ret = opargs[0]->v_objref.ref;
			aml_xaddref(my_ret, "DerefOf");
		}
		else {
			my_ret = opargs[0];
			//aml_xaddref(my_ret, "DerefOf");
		}
		break;
	case AMLOP_COPYOBJECT:
		/* CopyObject: t:DataRefObj, s:implename => DataRefObj */
		my_ret = opargs[0];
		aml_freevalue(opargs[1]);
		aml_copyvalue(opargs[1], opargs[0]);
		break;
	case AMLOP_STORE:
		/* Store: t:DataRefObj, S:upername => DataRefObj */
		my_ret = opargs[0];
		aml_xstore(scope, opargs[1], 0, opargs[0]);
		break;

		/* Conversion */
	case AMLOP_TOINTEGER:
		/* Source:CData, Result => Integer */
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_INTEGER, 0);
		aml_xstore(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOBUFFER:
		/* Source:CData, Result => Buffer */
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_BUFFER, 0);
		aml_xstore(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOHEXSTRING:
		/* Source:CData, Result => String */
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 'x');
		aml_xstore(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TODECSTRING:
		/* Source:CData, Result => String */
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 'd');
		aml_xstore(scope, opargs[1], 0, my_ret);
		break;
	case AMLOP_TOSTRING:
		/* Source:B, Length:I, Result => String */
		aml_xconvert(opargs[0], &my_ret, AML_OBJTYPE_STRING, 0);
		aml_die("tostring\n");
		break;
	case AMLOP_CONCAT:
		/* Source1:CData, Source2:CData, Result => CData */
		aml_xconcat(opargs[0], opargs[1], &my_ret);
		aml_xstore(scope, opargs[2], 0, my_ret);
		break;
	case AMLOP_CONCATRES:
		/* Concat two resource buffers: buf1, buf2, result => Buffer */
		aml_xconcatres(opargs[0], opargs[1], &my_ret);
		aml_xstore(scope, opargs[2], 0, my_ret);
		break;
	case AMLOP_MID:
		/* Source:BS, Index:I, Length:I, Result => BS */
		aml_xmid(opargs[0], opargs[1]->v_integer, 
		    opargs[2]->v_integer, &my_ret);
		aml_xstore(scope, opargs[3], 0, my_ret);
		break;
	case AMLOP_MATCH:
		/* Match: Pkg, Op1, Val1, Op2, Val2, Index */
		ival = aml_xmatch(opargs[0], opargs[5]->v_integer,
		    opargs[1]->v_integer, opargs[2]->v_integer,
		    opargs[3]->v_integer, opargs[4]->v_integer);
		break;
	case AMLOP_SIZEOF:
		/* Sizeof: S => i */
		ival = opargs[0]->length;
		break;
	case AMLOP_OBJECTTYPE:
		/* ObjectType: S => i */
		ival = opargs[0]->type;
		break;

		/* Mutex/Event handlers */
	case AMLOP_ACQUIRE:
		/* Acquire: Sw => Bool */
		ival = acpi_xmutex_acquire(scope, opargs[0], 
		    opargs[1]->v_integer);
		break;
	case AMLOP_RELEASE:
		/* Release: S */
		acpi_xmutex_release(scope, opargs[0]);
		break;
	case AMLOP_WAIT:
		/* Wait: Si => Bool */
		ival = acpi_xevent_wait(scope, opargs[0], 
		    opargs[1]->v_integer);
		break;
	case AMLOP_RESET:
		/* Reset: S */
		acpi_xevent_reset(scope, opargs[0]);
		break;
	case AMLOP_SIGNAL:
		/* Signal: S */
		acpi_xevent_signal(scope, opargs[0]);
		break;

		/* Named objects */
	case AMLOP_NAME:
		/* Name: Nt */
		aml_freevalue(cname);
		aml_copyvalue(cname, opargs[1]);
		break;
	case AMLOP_ALIAS:
		/* Alias: nN */
		cname->type = AML_OBJTYPE_OBJREF;
		cname->v_objref.type = AMLOP_ALIAS;
		cname->v_objref.ref = opargs[0];
		while (cname->v_objref.ref->type == AML_OBJTYPE_OBJREF) {
			/* Single indirection level */
			cname->v_objref.ref = cname->v_objref.ref->v_objref.ref;
		}
		aml_xaddref(cname->v_objref.ref, "Alias");
		break;
	case AMLOP_OPREGION:
		/* OpRegion: Nbii */
		cname->type = AML_OBJTYPE_OPREGION;
		cname->v_opregion.iospace = opargs[1]->v_integer;
		cname->v_opregion.iobase = opargs[2]->v_integer;
		cname->v_opregion.iolen = opargs[3]->v_integer;
		cname->v_opregion.flag = 0;
		break;
	case AMLOP_DATAREGION:
		/* DataTableRegion: N,t:SigStr,t:OemIDStr,t:OemTableIDStr */
		cname->type = AML_OBJTYPE_OPREGION;
		cname->v_opregion.iospace = GAS_SYSTEM_MEMORY;
		cname->v_opregion.iobase = 0;
		cname->v_opregion.iolen = 0;
		aml_die("AML-DataTableRegion\n");
		break;
	case AMLOP_EVENT:
		/* Event: N */
		cname->type = AML_OBJTYPE_EVENT;
		cname->v_integer = 0;
		break;
	case AMLOP_MUTEX:
		/* Mutex: Nw */
		cname->type = AML_OBJTYPE_MUTEX;
		cname->v_mtx.synclvl = opargs[1]->v_integer;
		break;
	case AMLOP_SCOPE:
		/* Scope: NT */
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
		break;
	case AMLOP_DEVICE:
		/* Device: NT */
		cname->type = AML_OBJTYPE_DEVICE;
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
		break;
	case AMLOP_THERMALZONE:
		/* ThermalZone: NT */
		cname->type = AML_OBJTYPE_THERMZONE;
		mscope = aml_xpushscope(scope, opargs[1], cname->node, opcode);
		break;
	case AMLOP_POWERRSRC:
		/* PowerRsrc: NbwT */
		cname->type = AML_OBJTYPE_POWERRSRC;
		cname->v_powerrsrc.pwr_level = opargs[1]->v_integer;
		cname->v_powerrsrc.pwr_order = opargs[2]->v_integer;
		mscope = aml_xpushscope(scope, opargs[3], cname->node, opcode);
		break;
	case AMLOP_PROCESSOR:
		/* Processor: NbdbT */
		cname->type = AML_OBJTYPE_PROCESSOR;
		cname->v_processor.proc_id = opargs[1]->v_integer;
		cname->v_processor.proc_addr = opargs[2]->v_integer;
		cname->v_processor.proc_len = opargs[3]->v_integer;
		mscope = aml_xpushscope(scope, opargs[4], cname->node, opcode);
		break;
	case AMLOP_METHOD:
		/* Method: NbM */
		cname->type = AML_OBJTYPE_METHOD;
		cname->v_method.flags = opargs[1]->v_integer;
		cname->v_method.start = opargs[2]->v_buffer;
		cname->v_method.end = cname->v_method.start + opargs[2]->length;
		cname->v_method.base = aml_root.start;
		break;

		/* Field objects */
	case AMLOP_CREATEFIELD:
		/* Source:B, BitIndex:I, NumBits:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer,
		    opargs[2]->v_integer, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		break;
	case AMLOP_CREATEBITFIELD:
		/* Source:B, BitIndex:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer,    
		    1, NULL, 0);	
		aml_xdelref(&tmp, htab->mnem);
		break;
	case AMLOP_CREATEBYTEFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8,  
		    8, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_BYTEACC;
		break;
	case AMLOP_CREATEWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    16, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_WORDACC;
		break;
	case AMLOP_CREATEDWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    32, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_DWORDACC;
		break;
	case AMLOP_CREATEQWORDFIELD:
		/* Source:B, ByteIndex:I, FieldName */
		aml_xconvert(opargs[0], &tmp, AML_OBJTYPE_BUFFER, 0);
		aml_xcreatefield(cname, opcode, tmp, opargs[1]->v_integer*8, 
		    64, NULL, 0);
		aml_xdelref(&tmp, htab->mnem);
		cname->v_field.flags = AML_FIELD_QWORDACC;
		break;
	case AMLOP_FIELD:
		/* Field: n:OpRegion, b:Flags, F:ieldlist */
		mscope = aml_xpushscope(scope, opargs[2], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[1]->v_integer, 
		    opargs[0], NULL, 0);
		break;
	case AMLOP_INDEXFIELD:
		/* IndexField: n:Index, n:Data, b:Flags, F:ieldlist */
		mscope = aml_xpushscope(scope, opargs[3], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[2]->v_integer, 
		    opargs[1], opargs[0], 0);
		break;
	case AMLOP_BANKFIELD:
		/* BankField: n:OpRegion, n:Field, i:Bank, b:Flags, F:ieldlist */
		mscope = aml_xpushscope(scope, opargs[4], scope->node, opcode);
		aml_xparsefieldlist(mscope, opcode, opargs[3]->v_integer, 
		    opargs[0], opargs[1], opargs[2]->v_integer);
		break;

		/* Misc functions */
	case AMLOP_STALL:
		/* Stall: i */
		acpi_stall(opargs[0]->v_integer);
		break;
	case AMLOP_SLEEP:
		/* Sleep: i */
		acpi_sleep(opargs[0]->v_integer);
		break;
	case AMLOP_NOTIFY:
		/* Notify: Si */
		dnprintf(50,"Notifying: %s %x\n", 
		    aml_nodename(opargs[0]->node), 
		    opargs[1]->v_integer);
		aml_notify(opargs[0]->node, opargs[1]->v_integer);
		break;
	case AMLOP_TIMER:
		/* Timer: => i */
		ival = 0xDEADBEEF;
		break;
	case AMLOP_FATAL:
		/* Fatal: bdi */
		aml_die("AML FATAL ERROR: %x,%x,%x\n",
		    opargs[0]->v_integer, opargs[1]->v_integer, 
		    opargs[2]->v_integer);
		break;
	case AMLOP_LOADTABLE:
		/* LoadTable(Sig:Str, OEMID:Str, OEMTable:Str, [RootPath:Str], [ParmPath:Str], 
		   [ParmData:DataRefObj]) => DDBHandle */
		aml_die("LoadTable");
		break;
	case AMLOP_LOAD:
		/* Load(Object:NameString, DDBHandle:SuperName) */
		tmp = opargs[0];
		if (tmp->type != AML_OBJTYPE_OPREGION || 
		    tmp->v_opregion.iospace != GAS_SYSTEM_MEMORY) {
			aml_die("LOAD: not a memory region!\n");
		}
#if 0
		/* Create buffer and read from memory */
		aml_xgasio(tmp->v_opregion.iospace, tmp->v_opregion.iobase, 
		    tmp->v_opregion.iolen,
		    opargs[1], ACPI_IOREAD);
		
		/* Validate that this is a SSDT */
		if (!valid_acpihdr(opargs[1]->v_buffer, opargs[1]->length, 
			"SSDT")) {
			aml_die("LOAD: Not a SSDT!\n");
		}

		/* Parse block */
		mscope = aml_xpushscope(scope, opargs[1], scope->node, 
		    AMLOP_SCOPE);
#endif
		break;
	case AMLOP_UNLOAD:
		/* DDBHandle */
		aml_die("Unload");
		break;

		/* Control Flow */
	case AMLOP_IF:
		/* Arguments: iT or iTbT */
		if (opargs[0]->v_integer) {
			dnprintf(10,"parse-if @@ %.4x\n", pc);
			mscope = aml_xpushscope(scope, opargs[1], scope->node,
			    AMLOP_IF);
		}
		else if (opargs[3] != NULL) {
			dnprintf(10,"parse-else @@ %.4x\n", pc);
			mscope = aml_xpushscope(scope, opargs[3], scope->node,
			    AMLOP_ELSE);
		}
		break;
	case AMLOP_WHILE:
		mscope = aml_xpushscope(scope, opargs[0], scope->node,
		    AMLOP_WHILE);
		while (mscope->pos != NULL) {
			/* At beginning of scope.. reset and perform test */
			mscope->pos = mscope->start;
			tmp = aml_xparse(mscope, AML_ARG_INTEGER, "While-Test");
			ival = tmp->v_integer;
			aml_xdelref(&tmp, "while");

			dnprintf(10,"@@@@@@@@@@@@ WHILE: %llx @@ %x\n", ival, pc);
			if (ival == 0) {
				break;
			}
			aml_xparse(mscope, 'T', "While");
		}
		aml_xpopscope(mscope);
		mscope = NULL;
		break;
	case AMLOP_BREAK:
		/* Break: Find While Scope parent, mark type as null */
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = NULL;
		mscope = NULL;
		break;
	case AMLOP_CONTINUE:
		/* Find Scope.. mark all objects as invalid on way to root */
		mscope = aml_xfindscope(scope, AMLOP_WHILE, 1);
		mscope->pos = mscope->start;
		mscope = NULL;
		break;
	case AMLOP_RETURN:
		mscope = aml_xfindscope(scope, AMLOP_METHOD, 1);
		if (mscope->retv) {
			aml_die("already allocated\n");
		}
		mscope->retv = aml_allocvalue(0,0,NULL);
		aml_copyvalue(mscope->retv, opargs[0]);
		mscope = NULL;
		break;
	default:
		/* may be set direct result */
		aml_die("Unknown opcode: %x:%s\n", opcode, htab->mnem);
		break;
	}
	if (mscope != NULL) {
		aml_xparse(mscope, 'T', htab->mnem);
		aml_xpopscope(mscope);
	}
	if ((ret_type == 'i' || ret_type == 't') && my_ret == NULL) {
		dnprintf(10,"quick: %.4x [%s] allocating return integer = 0x%llx\n",
		    pc, htab->mnem, ival);
		my_ret = aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL);
	}
	if (ret_type == 'i' && my_ret && my_ret->type != AML_OBJTYPE_INTEGER) {
		dnprintf(10,"quick: %.4x convert to integer %s -> %s\n", 
		    pc, htab->mnem, stype);
	}
	if (my_ret != NULL) {
		/* Display result */
		my_ret->stack = opcode;
		dnprintf(20,"quick: %.4x %18s %c %.4x\n", pc, stype, 
		    ret_type, my_ret->stack);
	}

	/* End opcode: display/free arguments */
	for (idx=0; optype[idx] != 0; idx++) {
		if (opargs[idx] == my_ret || optype[idx] == 'N')
			opargs[idx] = NULL;
		aml_xdelref(&opargs[idx], "oparg");
	}
	odp--;

	/* If parsing whole scope and not done, start again */
	if (ret_type == 'T') {
		aml_xdelref(&my_ret, "scope.loop");
		if (scope->pos && scope->pos < scope->end)
			goto start;
	}
	dnprintf(50, ">>return [%s] %s %c %p\n", aml_nodename(scope->node), 
	    stype, ret_type, my_ret);
	return my_ret;
}

int
acpi_parse_aml(struct acpi_softc *sc, u_int8_t *start, u_int32_t length)
{
	struct aml_scope *scope;
	struct aml_value res;

	dsdt_softc = sc;

	aml_root.start = start;
	memset(&res, 0, sizeof(res));
	res.type = AML_OBJTYPE_SCOPE;
	res.length = length;
	res.v_buffer = start;
	
	/* Push toplevel scope, parse AML */
	scope = aml_xpushscope(NULL, &res, &aml_root, AMLOP_SCOPE);
	aml_busy++;
	aml_xparse(scope, 'T', "TopLevel");
	aml_busy--;
	aml_xpopscope(scope);

	return 0;
}

/*
 * @@@@@@: External API
 *
 * evaluate an AML node
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	struct aml_value *xres;
	
	if (node == NULL || node->value == NULL)
		return (ACPI_E_BADVALUE);
	if (res)
		memset(res, 0, sizeof(*res));
	dnprintf(12,"EVALNODE: %s %d\n", aml_nodename(node), acpi_nalloc);
	switch (node->value->type) {
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_PACKAGE:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PROCESSOR:
	case AML_OBJTYPE_THERMZONE:
	case AML_OBJTYPE_POWERRSRC:
		if (res)
			aml_copyvalue(res, node->value);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_METHOD:
		aml_busy++;
		xres = aml_xeval(NULL, node->value, 't', argc, argv);
		aml_busy--;
		if (res && xres)
			aml_copyvalue(res, xres);
		if (xres != node->value)
			aml_xdelref(&xres, "EvalNode");
		break;
	default:
		return (-1);
	}
	return (0);
}

/*
 * evaluate an AML name
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalname(struct acpi_softc *sc, struct aml_node *parent, const char *name,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	parent = aml_searchname(parent, name);
	return aml_evalnode(sc, parent, argc, argv, res);
}

/*
 * evaluate an AML integer object
 */
int
aml_evalinteger(struct acpi_softc *sc, struct aml_node *parent,
    const char *name, int argc, struct aml_value *argv, int64_t *ival)
{
	struct aml_value res;
	int rc;

	parent = aml_searchname(parent, name);
	rc = aml_evalnode(sc, parent, argc, argv, &res);
	*ival = aml_val2int(&res);
	aml_freevalue(&res);

	return rc;
}

/*
 * Search for an AML name in namespace.. root only 
 */
struct aml_node *
aml_searchname(struct aml_node *root, const void *vname)
{
	char *name = (char *)vname;

	dnprintf(25,"Searchname: %s:%s = ", aml_nodename(root), vname);
	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name != 0) {
		root = __aml_search(root, name, 0);
		name += (name[4] == '.') ? 5 : 4;
	}
	dnprintf(25,"%p %s\n", root, aml_nodename(root));
	return root;
}

/*
 * Search for relative name
 */
struct aml_node *
aml_searchrel(struct aml_node *root, const void *vname)
{
	struct aml_node *res;

	while (root) {
		res = aml_searchname(root, vname);
		if (res != NULL)
			return res;
		root = root->parent;
	}
	return NULL;
@


1.113
log
@Handle Alias named objects, return original object
Clear out result before evaluating
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.112 2008/05/14 21:47:00 miod Exp $ */
a128 18
struct aml_value *aml_parsenamed(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsenamedscope(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemath(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsecompare(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseif(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsewhile(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufpkg(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemethod(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsesimple(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsefieldunit(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufferfield(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc3(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemuxaction(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc2(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsematch(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseref(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsestring(struct aml_scope *, int, struct aml_value *);

d141 13
a153 13
	{ AMLOP_ZERO,		"Zero",		"c",	aml_parsesimple },
	{ AMLOP_ONE,		"One",		"c",	aml_parsesimple },
	{ AMLOP_ONES,		"Ones",		"c",	aml_parsesimple },
	{ AMLOP_REVISION,	"Revision",	"R",	aml_parsesimple },
	{ AMLOP_BYTEPREFIX,	".Byte",	"b",	aml_parsesimple },
	{ AMLOP_WORDPREFIX,	".Word",	"w",	aml_parsesimple },
	{ AMLOP_DWORDPREFIX,	".DWord",	"d",	aml_parsesimple },
	{ AMLOP_QWORDPREFIX,	".QWord",	"q",	aml_parsesimple },
	{ AMLOP_STRINGPREFIX,	".String",	"a",	aml_parsesimple },
	{ AMLOP_DEBUG,		"DebugOp",	"D",	aml_parsesimple },
	{ AMLOP_BUFFER,		"Buffer",	"piB",	aml_parsebufpkg },
	{ AMLOP_PACKAGE,	"Package",	"pbT",	aml_parsebufpkg },
	{ AMLOP_VARPACKAGE,	"VarPackage",	"piT",	aml_parsebufpkg },
d156 15
a170 15
	{ AMLOP_LOCAL0,		"Local0",	"L",	aml_parseref },
	{ AMLOP_LOCAL1,		"Local1",	"L",	aml_parseref },
	{ AMLOP_LOCAL2,		"Local2",	"L",	aml_parseref },
	{ AMLOP_LOCAL3,		"Local3",	"L",	aml_parseref },
	{ AMLOP_LOCAL4,		"Local4",	"L",	aml_parseref },
	{ AMLOP_LOCAL5,		"Local5",	"L",	aml_parseref },
	{ AMLOP_LOCAL6,		"Local6",	"L",	aml_parseref },
	{ AMLOP_LOCAL7,		"Local7",	"L",	aml_parseref },
	{ AMLOP_ARG0,		"Arg0",		"A",	aml_parseref },
	{ AMLOP_ARG1,		"Arg1",		"A",	aml_parseref },
	{ AMLOP_ARG2,		"Arg2",		"A",	aml_parseref },
	{ AMLOP_ARG3,		"Arg3",		"A",	aml_parseref },
	{ AMLOP_ARG4,		"Arg4",		"A",	aml_parseref },
	{ AMLOP_ARG5,		"Arg5",		"A",	aml_parseref },
	{ AMLOP_ARG6,		"Arg6",		"A",	aml_parseref },
d173 1
a173 1
	{ AMLOP_IF,		"If",		"piI",	aml_parseif },
d175 1
a175 1
	{ AMLOP_WHILE,		"While",	"pW",	aml_parsewhile },
d178 4
a181 4
	{ AMLOP_RETURN,		"Return",	"t",	aml_parseref },
	{ AMLOP_FATAL,		"Fatal",	"bdi",	aml_parsemisc2 },
	{ AMLOP_NOP,		"Nop",		"",	aml_parsesimple },
	{ AMLOP_BREAKPOINT,	"BreakPoint",	"",     aml_parsesimple },
d184 17
a200 17
	{ AMLOP_INCREMENT,	"Increment",	"t",	aml_parsemath },
	{ AMLOP_DECREMENT,	"Decrement",	"t",	aml_parsemath },
	{ AMLOP_ADD,		"Add",		"iir",	aml_parsemath },
	{ AMLOP_SUBTRACT,	"Subtract",	"iir",	aml_parsemath },
	{ AMLOP_MULTIPLY,	"Multiply",	"iir",	aml_parsemath },
	{ AMLOP_DIVIDE,		"Divide",	"iirr",	aml_parsemath },
	{ AMLOP_SHL,		"ShiftLeft",	"iir",	aml_parsemath },
	{ AMLOP_SHR,		"ShiftRight",	"iir",	aml_parsemath },
	{ AMLOP_AND,		"And",		"iir",	aml_parsemath },
	{ AMLOP_NAND,		"Nand",		"iir",	aml_parsemath },
	{ AMLOP_OR,		"Or",		"iir",	aml_parsemath },
	{ AMLOP_NOR,		"Nor",		"iir",	aml_parsemath },
	{ AMLOP_XOR,		"Xor",		"iir",	aml_parsemath },
	{ AMLOP_NOT,		"Not",		"ir",	aml_parsemath },
	{ AMLOP_MOD,		"Mod",		"iir",	aml_parsemath },
	{ AMLOP_FINDSETLEFTBIT,	"FindSetLeftBit", "ir",	aml_parsemath },
	{ AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",aml_parsemath },
d203 9
a211 9
	{ AMLOP_LAND,		"LAnd",		"ii",	aml_parsemath },
	{ AMLOP_LOR,		"LOr",		"ii",	aml_parsemath },
	{ AMLOP_LNOT,		"LNot",		"i",	aml_parsemath },
	{ AMLOP_LNOTEQUAL,	"LNotEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LLESSEQUAL,	"LLessEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LGREATEREQUAL,	"LGreaterEqual", "tt",	aml_parsecompare },
	{ AMLOP_LEQUAL,		"LEqual",	"tt",	aml_parsecompare },
	{ AMLOP_LGREATER,	"LGreater",	"tt",	aml_parsecompare },
	{ AMLOP_LLESS,		"LLess",	"tt",	aml_parsecompare },
d214 13
a226 13
	{ AMLOP_NAMECHAR,	".NameRef",	"n",	aml_parsesimple	},
	{ AMLOP_ALIAS,		"Alias",	"nN",	aml_parsenamed },
	{ AMLOP_NAME,		"Name",	"Nt",	aml_parsenamed },
	{ AMLOP_EVENT,		"Event",	"N",	aml_parsenamed },
	{ AMLOP_MUTEX,		"Mutex",	"Nb",	aml_parsenamed },
	{ AMLOP_DATAREGION,	"DataRegion",	"Nttt",	aml_parsenamed },
	{ AMLOP_OPREGION,	"OpRegion",	"Nbii",	aml_parsenamed },
	{ AMLOP_SCOPE,		"Scope",	"pNT",	aml_parsenamedscope },
	{ AMLOP_DEVICE,		"Device",	"pNT",	aml_parsenamedscope },
	{ AMLOP_POWERRSRC,	"Power Resource", "pNbwT",aml_parsenamedscope },
	{ AMLOP_THERMALZONE,	"ThermalZone",	"pNT",	aml_parsenamedscope },
	{ AMLOP_PROCESSOR,	"Processor",	"pNbdbT", aml_parsenamedscope },
	{ AMLOP_METHOD,		"Method",	"pNbM",	aml_parsemethod },
d229 9
a237 9
	{ AMLOP_FIELD,		"Field",	"pnbF",	aml_parsefieldunit },
	{ AMLOP_INDEXFIELD,	"IndexField",	"pnnbF",aml_parsefieldunit },
	{ AMLOP_BANKFIELD,	"BankField",	"pnnibF",aml_parsefieldunit },
	{ AMLOP_CREATEFIELD,	"CreateField",	"tiiN",		aml_parsebufferfield },
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",aml_parsebufferfield },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",aml_parsebufferfield },
	{ AMLOP_CREATEWORDFIELD, "CreateWordField", "tiN",aml_parsebufferfield },
	{ AMLOP_CREATEBYTEFIELD, "CreateByteField", "tiN",aml_parsebufferfield },
	{ AMLOP_CREATEBITFIELD,	"CreateBitField", "tiN",	aml_parsebufferfield },
d240 1
a240 1
	{ AMLOP_TOINTEGER,	"ToInteger",	"tr",	aml_parsemath },
d242 6
a247 6
	{ AMLOP_TODECSTRING,	"ToDecString",	"ir",	aml_parsestring },
	{ AMLOP_TOHEXSTRING,	"ToHexString",	"ir",	aml_parsestring },
	{ AMLOP_TOSTRING,	"ToString",	"tir",	aml_parsestring },
	{ AMLOP_MID,		"Mid",		"tiir",	aml_parsestring },
	{ AMLOP_FROMBCD,	"FromBCD",	"ir",	aml_parsemath },
	{ AMLOP_TOBCD,		"ToBCD",	"ir",	aml_parsemath },
d250 10
a259 10
	{ AMLOP_ACQUIRE,	"Acquire",	"Sw",	aml_parsemuxaction },
	{ AMLOP_RELEASE,	"Release",	"S",	aml_parsemuxaction },
	{ AMLOP_SIGNAL,		"Signal",	"S",	aml_parsemuxaction },
	{ AMLOP_WAIT,		"Wait",		"Si",	aml_parsemuxaction },
	{ AMLOP_RESET,		"Reset",	"S",	aml_parsemuxaction },

	{ AMLOP_INDEX,		"Index",	"tir",	aml_parseref },
	{ AMLOP_DEREFOF,	"DerefOf",	"t",	aml_parseref },
	{ AMLOP_REFOF,		"RefOf",	"S",	aml_parseref },
	{ AMLOP_CONDREFOF,	"CondRef",	"SS",	aml_parseref },
d262 3
a264 3
	{ AMLOP_STALL,		"Stall",	"i",	aml_parsemisc2 },
	{ AMLOP_SLEEP,		"Sleep",	"i",	aml_parsemisc2 },
	{ AMLOP_LOAD,		"Load",		"nS",	aml_parseref },
d266 2
a267 2
	{ AMLOP_STORE,		"Store",	"tS",	aml_parseref },
	{ AMLOP_CONCAT,		"Concat",	"ttr",	aml_parsestring },
d269 5
a273 5
	{ AMLOP_NOTIFY,		"Notify",	"Si",	aml_parsemisc2 },
	{ AMLOP_SIZEOF,		"Sizeof",	"S",	aml_parsemisc3 },
	{ AMLOP_MATCH,		"Match",	"tbibii", aml_parsematch },
	{ AMLOP_OBJECTTYPE,	"ObjectType",	"S",	aml_parsemisc3 },
	{ AMLOP_COPYOBJECT,	"CopyObject",	"tS",	aml_parseref },
a455 67
int
acpi_mutex_acquire(struct aml_value *val, int timeout)
{
	/* XXX we currently do not have concurrency so assume mutex succeeds */
	dnprintf(50, "acpi_mutex_acquire\n");

	return (0);
#if 0
	struct acpi_mutex *mtx = val->v_mutex;
	int rv = 0, ts, tries = 0;

	if (val->type != AML_OBJTYPE_MUTEX) {
		printf("acpi_mutex_acquire: invalid mutex\n");
		return (1);
	}

	if (timeout == 0xffff)
		timeout = 0;

	/* lock recursion be damned, panic if that happens */
	rw_enter_write(&mtx->amt_lock);
	while (mtx->amt_ref_count) {
		rw_exit_write(&mtx->amt_lock);
		/* block access */
		ts = tsleep(mtx, PWAIT, mtx->amt_name, timeout / hz);
		if (ts == EWOULDBLOCK) {
			rv = 1; /* mutex not acquired */
			goto done;
		}
		tries++;
		rw_enter_write(&mtx->amt_lock);
	}

	mtx->amt_ref_count++;
	rw_exit_write(&mtx->amt_lock);
done:
	return (rv);
#endif
}

void
acpi_mutex_release(struct aml_value *val)
{
	dnprintf(50, "acpi_mutex_release\n");
#if 0
	struct acpi_mutex *mtx = val->v_mutex;

	/* sanity */
	if (val->type != AML_OBJTYPE_MUTEX) {
		printf("acpi_mutex_acquire: invalid mutex\n");
		return;
	}

	rw_enter_write(&mtx->amt_lock);

	if (mtx->amt_ref_count == 0) {
		printf("acpi_mutex_release underflow %s\n", mtx->amt_name);
		goto done;
	}

	mtx->amt_ref_count--;
	wakeup(mtx); /* wake all of them up */
done:
	rw_exit_write(&mtx->amt_lock);
#endif
}

a493 21
/* Read/Write to hardware I/O fields */
void
aml_gasio(struct acpi_softc *sc, int type, uint64_t base, uint64_t length,
    int bitpos, int bitlen, int size, void *buf, int mode)
{
	dnprintf(10, "-- aml_gasio: %.2x"
	    " base:%llx len:%llx bpos:%.4x blen:%.4x sz:%.2x mode=%s\n",
	    type, base, length, bitpos, bitlen, size,
	    mode==ACPI_IOREAD?"read":"write");
	acpi_gasio(sc, mode, type, base+(bitpos>>3),
	    (size>>3), (bitlen>>3), buf);
#ifdef ACPI_DEBUG
	while (bitlen > 0) {
		dnprintf(10, "%.2x ", *(uint8_t *)buf);
		buf++;
		bitlen -=8;
	}
	dnprintf(10, "\n");
#endif
}

a714 53
/* Search namespace for a named node */
#if 0
struct aml_node *
aml_searchname(struct aml_node *root, const void *vname)
{
	struct aml_node *node;
	uint8_t *name = (uint8_t *)vname;
	int count;

	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name == AMLOP_PARENTPREFIX && root) {
		root = root->parent;
		name++;
	}
	if (strlen(name) < AML_NAMESEG_LEN) {
		aml_die("bad name");
	}
	switch (*name) {
	case 0x00:
		return root;
	case AMLOP_MULTINAMEPREFIX:
		count = name[1];
		name += 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		name += 1;
		break;
	default:
		if (name[4] == '.') {
			/* Called from user code */
			while (*name && (root = __aml_search(root, name, 0)) != NULL) {
				name += AML_NAMESEG_LEN+1;
			}
			return root;
		}
		/* Special case.. search relative for name */
		while (root && (node = __aml_search(root, name, 0)) == NULL) {
			root = root->parent;
		}
		return node;
	}
	/* Search absolute for name*/
	while (count-- && (root = __aml_search(root, name, 0)) != NULL) {
		name += AML_NAMESEG_LEN;
	}
	return root;
}
#endif

a739 1
struct aml_value	*aml_alloctmp(struct aml_scope *, int);
a742 2
int			aml_parsenode(struct aml_scope *, struct aml_node *,
			    uint8_t *, uint8_t **, struct aml_value *);
a748 21
/* Allocate temporary storage in this scope */
struct aml_value *
aml_alloctmp(struct aml_scope *scope, int narg)
{
	struct aml_vallist *tmp;

	/* Allocate array of temp values */
	tmp = (struct aml_vallist *)acpi_os_malloc(sizeof(struct aml_vallist) +
	    narg * sizeof(struct aml_value));

	tmp->obj = (struct aml_value *)&tmp[1];
	tmp->nobj = narg;

	/* Link into scope */
	tmp->next = scope->tmpvals;
	scope->tmpvals = tmp;

	/* Return array of values */
	return tmp->obj;
}

a793 20
int
aml_parsenode(struct aml_scope *parent, struct aml_node *node, uint8_t *start,
    uint8_t **end, struct aml_value *res)
{
	struct aml_scope *scope;

	/* Don't parse zero-length scope */
	if (start == *end)
		return 0;
	scope = aml_pushscope(parent, start, *end, node);
	if (res == NULL)
		res = aml_alloctmp(scope, 1);
	while (scope != parent) {
		while (scope->pos < scope->end)
			aml_parseop(scope, res, 't');
		scope = aml_popscope(scope);
	}
	return 0;
}

a796 3
void aml_setbufint(struct aml_value *, int, int, struct aml_value *);
void aml_getbufint(struct aml_value *, int, int, struct aml_value *);
void aml_fieldio(struct aml_scope *, struct aml_value *, struct aml_value *, int);
a799 55
/* Copy from a bufferfield to an integer/buffer */
void
aml_setbufint(struct aml_value *dst, int bitpos, int bitlen,
    struct aml_value *src)
{
	if (src->type != AML_OBJTYPE_BUFFER) {
#ifndef SMALL_KERNEL
		aml_showvalue(src, 0);
#endif
		aml_die("wrong setbufint type %d\n", src->type);
	}
#if 1
	/* Return buffer type */
	_aml_setvalue(dst, AML_OBJTYPE_BUFFER, (bitlen+7)>>3, NULL);
	aml_bufcpy(dst->v_buffer, 0, src->v_buffer, bitpos, bitlen);
#else
	if (bitlen < aml_intlen) {
		/* XXX: Endian issues?? */
		/* Return integer type */
		_aml_setvalue(dst, AML_OBJTYPE_INTEGER, 0, NULL);
		aml_bufcpy(&dst->v_integer, 0, src->v_buffer, bitpos, bitlen);
	} else {
		/* Return buffer type */
		_aml_setvalue(dst, AML_OBJTYPE_BUFFER, (bitlen+7)>>3, NULL);
		aml_bufcpy(dst->v_buffer, 0, src->v_buffer, bitpos, bitlen);
	}
#endif
}

/* Copy from a string/integer/buffer to a bufferfield */
void
aml_getbufint(struct aml_value *src, int bitpos, int bitlen,
    struct aml_value *dst)
{
	if (dst->type != AML_OBJTYPE_BUFFER)
		aml_die("wrong getbufint type %d\n", src->type);
	switch (src->type) {
	case AML_OBJTYPE_INTEGER:
		if (bitlen >= aml_intlen)
			bitlen = aml_intlen;
		aml_bufcpy(dst->v_buffer, bitpos, &src->v_integer, 0, bitlen);
		break;
	case AML_OBJTYPE_BUFFER:
		if (bitlen >= 8*src->length)
			bitlen = 8*src->length;
		aml_bufcpy(dst->v_buffer, bitpos, src->v_buffer, 0, bitlen);
		break;
	case AML_OBJTYPE_STRING:
		if (bitlen >= 8*src->length)
			bitlen = 8*src->length;
		aml_bufcpy(dst->v_buffer, bitpos, src->v_string, 0, bitlen);
		break;
	}
}

a850 206
void *aml_getbuffer(struct aml_value *, int *);

void *
aml_getbuffer(struct aml_value *val, int *bitlen)
{
	switch (val->type) {
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STATICINT:
		*bitlen = aml_intlen;
		return (&val->v_integer);

	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_STRING:
		*bitlen = val->length<<3;
		return (val->v_buffer);

	default:
		aml_die("getvbi");
	}

	return (NULL);
}

/*
 * Buffer/Region: read/write to bitfields
 */
void
aml_fieldio(struct aml_scope *scope, struct aml_value *field,
    struct aml_value *res, int mode)
{
	struct aml_value *pop, tf;
	int bpos, blen, aligned, mask;
	void    *iobuf, *iobuf2;
	uint64_t iobase;

	pop = field->v_field.ref1;
	bpos = field->v_field.bitpos;
	blen = field->v_field.bitlen;

	dnprintf(55,"--fieldio: %s [%s] bp:%.4x bl:%.4x\n",
	    mode == ACPI_IOREAD ? "rd" : "wr",
	    aml_nodename(field->node), bpos, blen);

	aml_lockfield(scope, field);
	switch (field->v_field.type) {
	case AMLOP_INDEXFIELD:
		/* Set Index */
		memcpy(&tf, field->v_field.ref2, sizeof(struct aml_value));
		tf.v_field.bitpos += (bpos & 7);
		tf.v_field.bitlen  = blen;

		aml_setvalue(scope, pop, NULL, bpos>>3);
		aml_fieldio(scope, &tf, res, mode);
#ifdef ACPI_DEBUG
		dnprintf(55, "-- post indexfield %x,%x @@ %x,%x\n",
		    bpos & 3, blen,
		    field->v_field.ref2->v_field.bitpos,
		    field->v_field.ref2->v_field.bitlen);

		iobuf = aml_getbuffer(res, &aligned);
		aml_dump(aligned >> 3, iobuf);
#endif
		break;
	case AMLOP_BANKFIELD:
		/* Set Bank */
		memcpy(&tf, field->v_field.ref2, sizeof(struct aml_value));
		tf.v_field.bitpos += (bpos & 7);
		tf.v_field.bitlen  = blen;

		aml_setvalue(scope, pop, NULL, field->v_field.ref3);
		aml_fieldio(scope, &tf, res, mode);
#ifdef ACPI_DEBUG
		dnprintf(55, "-- post bankfield %x,%x @@ %x,%x\n",
		    bpos & 3, blen,
		    field->v_field.ref2->v_field.bitpos,
		    field->v_field.ref2->v_field.bitlen);

		iobuf = aml_getbuffer(res, &aligned);
		aml_dump(aligned >> 3, iobuf);
#endif
		break;
	case AMLOP_FIELD:
		/* This is an I/O field */
		if (pop->type != AML_OBJTYPE_OPREGION)
			aml_die("Not an opregion\n");

		/* Get field access size */
		switch (AML_FIELD_ACCESS(field->v_field.flags)) {
		case AML_FIELD_ANYACC:
		case AML_FIELD_BYTEACC:
			mask = 7;
			break;
		case AML_FIELD_WORDACC:
			mask = 15;
			break;
		case AML_FIELD_DWORDACC:
			mask = 31;
			break;
		case AML_FIELD_QWORDACC:
			mask = 63;
			break;
		}

		/* Pre-allocate return value for reads */
		if (mode == ACPI_IOREAD)
			_aml_setvalue(res, AML_OBJTYPE_BUFFER,
			    (field->v_field.bitlen+7)>>3, NULL);

		/* Get aligned bitpos/bitlength */
		blen = ((bpos & mask) + blen + mask) & ~mask;
		bpos = bpos & ~mask;
		aligned = (bpos == field->v_field.bitpos &&
		    blen == field->v_field.bitlen);
		iobase = pop->v_opregion.iobase;

		/* Check for aligned reads/writes */
		if (aligned) {
			iobuf = aml_getbuffer(res, &aligned);
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);
#ifdef ACPI_DEBUG
			dnprintf(55, "aligned: %s @@ %.4x:%.4x + %.4x\n",
			    mode == ACPI_IOREAD ? "rd" : "wr",
			    bpos, blen, aligned);

			aml_dump(blen >> 3, iobuf);
#endif
		}
		else if (mode == ACPI_IOREAD) {
			iobuf = acpi_os_malloc(blen>>3);
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);

			/* ASSERT: res is buffer type as it was set above */
			aml_bufcpy(res->v_buffer, 0, iobuf,
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

#ifdef ACPI_DEBUG
			dnprintf(55,"non-aligned read: %.4x:%.4x : ",
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

			aml_dump(blen >> 3, iobuf);
			dnprintf(55,"post-read: ");
			aml_dump((field->v_field.bitlen+7)>>3, res->v_buffer);
#endif
			acpi_os_free(iobuf);
		}
		else {
			iobuf = acpi_os_malloc(blen >> 3);
			switch (AML_FIELD_UPDATE(field->v_field.flags)) {
			case AML_FIELD_WRITEASONES:
				memset(iobuf, 0xFF, blen >> 3);
				break;
			case AML_FIELD_PRESERVE:
				aml_gasio(scope->sc, pop->v_opregion.iospace,
				    iobase, pop->v_opregion.iolen, bpos, blen,
				    mask + 1, iobuf, ACPI_IOREAD);
				break;
			}
			/* Copy into IOBUF */
			iobuf2 = aml_getbuffer(res, &aligned);
			aml_bufcpy(iobuf, field->v_field.bitpos & mask,
			    iobuf2, 0, field->v_field.bitlen);

#ifdef ACPI_DEBUG
			dnprintf(55,"non-aligned write: %.4x:%.4x : ",
			    field->v_field.bitpos & mask,
			    field->v_field.bitlen);

			aml_dump(blen >> 3, iobuf);
#endif
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen,
			    mask + 1, iobuf, mode);

			acpi_os_free(iobuf);
		}
		/* Verify that I/O is in range */
#if 0
		/*
		 * XXX: some I/O ranges are on dword boundaries, but their
		 * length is incorrect eg. dword access, but length of
		 * opregion is 2 bytes.
		 */
		if ((bpos+blen) >= (pop->v_opregion.iolen * 8)) {
			aml_die("Out of bounds I/O!!! region:%x:%llx:%x %x\n",
			    pop->v_opregion.iospace, pop->v_opregion.iobase,
			    pop->v_opregion.iolen, bpos+blen);
		}
#endif
		break;
	default:
		/* This is a buffer field */
		if (mode == ACPI_IOREAD)
			aml_setbufint(res, bpos, blen, pop);
		else
			aml_getbufint(res, bpos, blen, pop);
		break;
	}
	aml_unlockfield(scope, field);
}

a854 3
struct aml_value *aml_derefvalue(struct aml_scope *, struct aml_value *, int);
#define aml_dereftarget(s, v)	aml_derefvalue(s, v, ACPI_IOWRITE)
#define aml_derefterm(s, v, m)	aml_derefvalue(s, v, ACPI_IOREAD)
d896 4
a899 2
		aml_showvalue(val->v_field.ref1, lvl);
		aml_showvalue(val->v_field.ref2, lvl);
d933 2
a934 2
		printf(" objref: %p index:%x\n", val->v_objref.ref,
		    val->v_objref.index);
a942 95
/* Perform DeRef on value. If ACPI_IOREAD, will perform buffer/IO field read */
struct aml_value *
aml_derefvalue(struct aml_scope *scope, struct aml_value *ref, int mode)
{
	struct aml_node *node;
	struct aml_value *tmp;
	int64_t tmpint;
	int argc, index;

	for (;;) {
		switch (ref->type) {
		case AML_OBJTYPE_NAMEREF:
			node = aml_searchname(scope->node, ref->v_nameref);
			if (node == NULL || node->value == NULL)
				return ref;
			ref = node->value;
			break;

		case AML_OBJTYPE_OBJREF:
			index = ref->v_objref.index;
			ref = aml_dereftarget(scope, ref->v_objref.ref);
			if (index != -1) {
				if (index >= ref->length)
					aml_die("index.buf out of bounds: "
					    "%d/%d\n", index, ref->length);
				switch (ref->type) {
				case AML_OBJTYPE_PACKAGE:
					ref = ref->v_package[index];
					break;
				case AML_OBJTYPE_STATICINT:
				case AML_OBJTYPE_INTEGER:
					/* Convert to temporary buffer */
					if (ref->node)
						aml_die("named integer index\n");
					tmpint = ref->v_integer;
					_aml_setvalue(ref, AML_OBJTYPE_BUFFER,
					    aml_intlen>>3, &tmpint);
					/* FALLTHROUGH */
				case AML_OBJTYPE_BUFFER:
				case AML_OBJTYPE_STRING:
					/* Return contents at this index */
					tmp = aml_alloctmp(scope, 1);
					if (mode == ACPI_IOREAD) {
						/* Shortcut: return integer
						 * contents of buffer at index */
						_aml_setvalue(tmp,
						    AML_OBJTYPE_INTEGER,
						    ref->v_buffer[index], NULL);
					} else {
						_aml_setvalue(tmp,
						    AML_OBJTYPE_BUFFERFIELD,
						    0, NULL);
						tmp->v_field.type =
						    AMLOP_CREATEBYTEFIELD;
						tmp->v_field.bitpos = index * 8;
						tmp->v_field.bitlen = 8;
						tmp->v_field.ref1 = ref;
						aml_addref(ref);
					}
					return tmp;
				default:
					aml_die("unknown index type: %d", ref->type);
					break;
				}
			}
			break;

		case AML_OBJTYPE_METHOD:
			/* Read arguments from current scope */
			argc = AML_METHOD_ARGCOUNT(ref->v_method.flags);
			tmp = aml_alloctmp(scope, argc+1);
			for (index = 0; index < argc; index++) {
				aml_parseop(scope, &tmp[index], 't');
				aml_addref(&tmp[index]);
			}
			ref = aml_evalmethod(scope, ref->node, argc, tmp, &tmp[argc]);
			break;

		case AML_OBJTYPE_BUFFERFIELD:
		case AML_OBJTYPE_FIELDUNIT:
			if (mode == ACPI_IOREAD) {
				/* Read I/O field into temporary storage */
				tmp = aml_alloctmp(scope, 1);
				aml_fieldio(scope, ref, tmp, ACPI_IOREAD);
				return tmp;
			}
			return ref;

		default:
			return ref;
		}

	}
}

a1079 126
int is_local(struct aml_scope *, struct aml_value *);

int
is_local(struct aml_scope *scope, struct aml_value *val)
{
	int idx;

	if (val->stack == 0 || scope->locals == NULL)
		return (0);
	
	idx = val->stack - AMLOP_LOCAL0;
	if (idx < 0 || idx >= AML_MAX_LOCAL)
		aml_die("Invalid stack value!");

	return (val == &scope->locals[idx]);
}

/* Guts of the code: Assign one value to another.  LHS may contain a previous value */
void
aml_setvalue(struct aml_scope *scope, struct aml_value *lhs,
    struct aml_value *rhs, int64_t ival)
{
	struct aml_value tmpint;

	/* Use integer as result */
	memset(&tmpint, 0, sizeof(tmpint));
	if (rhs == NULL) {
		rhs = _aml_setvalue(&tmpint, AML_OBJTYPE_INTEGER, ival, NULL);
	}
	else if (rhs->type == AML_OBJTYPE_BUFFERFIELD ||
		 rhs->type == AML_OBJTYPE_FIELDUNIT)
	{
		aml_fieldio(scope, rhs, &tmpint, ACPI_IOREAD);
		rhs = &tmpint;
	}

	if (!is_local(scope, lhs))
		lhs = aml_dereftarget(scope, lhs);

	if (is_local(scope, lhs)) {
		/* ACPI: Overwrite writing to LocalX */
		aml_freevalue(lhs);
	}

	switch (lhs->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		aml_copyvalue(lhs, rhs);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_fieldio(scope, lhs, rhs, ACPI_IOWRITE);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
#ifdef ACPI_DEBUG
		printf("-- debug --\n");
		aml_showvalue(rhs, 50);
#endif
		break;
	case AML_OBJTYPE_STATICINT:
		if (lhs->node) {
			lhs->v_integer = aml_val2int(rhs);
		}
		break;
	case AML_OBJTYPE_INTEGER:
		lhs->v_integer = aml_val2int(rhs);
		break;
	case AML_OBJTYPE_BUFFER:
	{
		char *buf;
		int len;

		if (lhs->node)
			dnprintf(40, "named.buffer\n");

		if (rhs->type == AML_OBJTYPE_BUFFER) {
			buf = rhs->v_buffer;
			len = rhs->length;
		} else if (rhs->type == AML_OBJTYPE_INTEGER ||
			   rhs->type == AML_OBJTYPE_STATICINT) {
			buf = (char *)&rhs->v_integer;
			len = sizeof(rhs->v_integer);
		} else if (rhs->type == AML_OBJTYPE_STRING) {
			len = rhs->length + 1;
			buf = rhs->v_string;
		} else {
			/* aml_showvalue(rhs); */
			aml_die("setvalue.buf : %x", aml_pc(scope->pos));
		}
		if (lhs->length < len)
			len = lhs->length;
		else
			memset(lhs->v_buffer, 0, lhs->length);
		memcpy(lhs->v_buffer, buf, len);
		/* XXX ACPI v30b 17.2.5.7 says truncate string "before
		   copying", so make sure the string is terminated */
		if (rhs->type == AML_OBJTYPE_STRING)
			lhs->v_buffer[lhs->length - 1] = '\0';
		break;
	}
	case AML_OBJTYPE_STRING:
		if (lhs->node)
			dnprintf(40, "named string\n");
		aml_freevalue(lhs);
		if (rhs->type == AML_OBJTYPE_STRING)
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length,
			    rhs->v_string);
		else if (rhs->type == AML_OBJTYPE_BUFFER)
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length,
			    rhs->v_buffer);
		else if (rhs->type == AML_OBJTYPE_INTEGER || rhs->type == AML_OBJTYPE_STATICINT) {
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, 10, NULL);
			snprintf(lhs->v_string, lhs->length, "%lld",
			    rhs->v_integer);
		} else {
			/* aml_showvalue(rhs); */
			aml_die("setvalue.str");
		}
		break;
	default:
		/* XXX: */
		dnprintf(10, "setvalue.unknown: %x", lhs->type);
		break;
	}
	aml_freevalue(&tmpint);
}

a1370 47
struct aml_value *
aml_callmethod(struct aml_scope *scope, struct aml_value *val)
{
	while (scope->pos < scope->end)
		aml_parseterm(scope, val);
	return val;
}

/*
 * Evaluate an AML method
 *
 * Returns a copy of the result in res (must be freed by user)
 */
struct aml_value *
aml_evalmethod(struct aml_scope *parent, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	struct aml_scope *scope;

	scope = aml_pushscope(parent, node->value->v_method.start,
	    node->value->v_method.end, node);
	scope->args = argv;
	scope->nargs = argc;

	if (res == NULL)
		res = aml_alloctmp(scope, 1);

#ifdef ACPI_DEBUG
	dnprintf(10, "calling [%s] (%d args)\n",
	    aml_nodename(node), scope->nargs);
	for (argc = 0; argc < scope->nargs; argc++) {
		dnprintf(10, "  arg%d: ", argc);
		aml_showvalue(&scope->args[argc], 10);
	}
	node->value->v_method.fneval(scope, res);
	dnprintf(10, "[%s] returns: ", aml_nodename(node));
	aml_showvalue(res, 10);
#else
	node->value->v_method.fneval(scope, res);
#endif
	/* Free any temporary children nodes */
	aml_delchildren(node);
	aml_popscope(scope);

	return res;
}

d1377 4
a1380 4
#if 0
int
aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
    int argc, struct aml_value *argv, struct aml_value *res)
d1382 1
a1382 2
	static int lastck;
	struct aml_node *ref;
d1384 9
a1392 4
	if (res)
		memset(res, 0, sizeof(struct aml_value));
	if (node == NULL || node->value == NULL)
		return (ACPI_E_BADVALUE);
d1394 1
a1394 85
	switch (node->value->type) {
	case AML_OBJTYPE_METHOD:
		aml_evalmethod(NULL, node, argc, argv, res);
		if (acpi_nalloc > lastck) {
			/* Check if our memory usage has increased */
			dnprintf(10, "Leaked: [%s] %d\n",
			    aml_nodename(node), acpi_nalloc);
			lastck = acpi_nalloc;
		}
		break;
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PACKAGE:
	case AML_OBJTYPE_EVENT:
	case AML_OBJTYPE_DEVICE:
	case AML_OBJTYPE_MUTEX:
	case AML_OBJTYPE_OPREGION:
	case AML_OBJTYPE_POWERRSRC:
	case AML_OBJTYPE_PROCESSOR:
	case AML_OBJTYPE_THERMZONE:
	case AML_OBJTYPE_DEBUGOBJ:
		if (res)
			aml_copyvalue(res, node->value);
		break;
	case AML_OBJTYPE_NAMEREF:
		if (res == NULL)
			break;
		if ((ref = aml_searchname(node, node->value->v_nameref)) != NULL)
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, ref);
		else
			aml_copyvalue(res, node->value);
		break;
	default:
		break;
	}
	return (0);
}

/*
 * evaluate an AML name
 * Returns a copy of the value in res  (must be freed by user)
 */
int
aml_evalname(struct acpi_softc *sc, struct aml_node *parent, const char *name,
    int argc, struct aml_value *argv, struct aml_value *res)
{
	return aml_evalnode(sc, aml_searchname(parent, name), argc, argv, res);
}

int
aml_evalinteger(struct acpi_softc *sc, struct aml_node *parent,
    const char *name, int argc, struct aml_value *argv, int64_t *ival)
{
	struct aml_value res;

	if (name != NULL)
		parent = aml_searchname(parent, name);
	if (aml_evalnode(sc, parent, argc, argv, &res) == 0) {
		*ival = aml_val2int(&res);
		aml_freevalue(&res);
		return 0;
	}
	return 1;
}
#endif

void
aml_walknodes(struct aml_node *node, int mode,
    int (*nodecb)(struct aml_node *, void *), void *arg)
{
	struct aml_node *child;

	if (node == NULL)
		return;
	if (mode == AML_WALK_PRE)
		nodecb(node, arg);
	for (child = node->child; child; child = child->sibling)
		aml_walknodes(child, mode, nodecb, arg);
	if (mode == AML_WALK_POST)
		nodecb(node, arg);
}

int
a1528 1
int		aml_match(int, int64_t, struct aml_value *);
a1529 50
int64_t		aml_parseint(struct aml_scope *, int);
void		aml_resize(struct aml_value *val, int newsize);

void
aml_resize(struct aml_value *val, int newsize)
{
	void *oldptr;
	int oldsize;

	if (val->length >= newsize)
		return;
	oldsize = val->length;
	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		oldptr = val->v_buffer;
		_aml_setvalue(val, val->type, newsize, NULL);
		memcpy(val->v_buffer, oldptr, oldsize);
		acpi_os_free(oldptr);
		break;
	case AML_OBJTYPE_STRING:
		oldptr = val->v_string;
		_aml_setvalue(val, val->type, newsize+1, NULL);
		memcpy(val->v_string, oldptr, oldsize);
		acpi_os_free(oldptr);
		break;
	}
}


int
aml_match(int op, int64_t mv1, struct aml_value *mv2)
{
	struct aml_value tmpint;

	memset(&tmpint, 0, sizeof(tmpint));
	_aml_setvalue(&tmpint, AML_OBJTYPE_INTEGER, mv1, NULL);
	switch (op) {
	case AML_MATCH_EQ:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LEQUAL);
	case AML_MATCH_LT:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LLESS);
	case AML_MATCH_LE:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LLESSEQUAL);
	case AML_MATCH_GE:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LGREATEREQUAL);
	case AML_MATCH_GT:
		return aml_cmpvalue(&tmpint, mv2, AMLOP_LGREATER);
	}
	return (1);
}
a1576 72
int64_t
aml_parseint(struct aml_scope *scope, int opcode)
{
	uint8_t *np = scope->pos;
	struct aml_value *tmpval;
	int64_t rval;

	if (opcode == AML_ANYINT)
		opcode = aml_parseopcode(scope);
	switch (opcode) {
	case AMLOP_ZERO:
		rval = 0;
		break;
	case AMLOP_ONE:
		rval = 1;
		break;
	case AMLOP_ONES:
		rval = -1;
		break;
	case AMLOP_REVISION:
		rval = AML_REVISION;
		break;
	case AMLOP_BYTEPREFIX:
		np = scope->pos;
		rval = *(uint8_t *)scope->pos;
		scope->pos += 1;
		break;
	case AMLOP_WORDPREFIX:
		np = scope->pos;
		rval = aml_letohost16(*(uint16_t *)scope->pos);
		scope->pos += 2;
		break;
	case AMLOP_DWORDPREFIX:
		np = scope->pos;
		rval = aml_letohost32(*(uint32_t *)scope->pos);
		scope->pos += 4;
		break;
	case AMLOP_QWORDPREFIX:
		np = scope->pos;
		rval = aml_letohost64(*(uint64_t *)scope->pos);
		scope->pos += 8;
		break;
	default:
		scope->pos = np;
		tmpval = aml_alloctmp(scope, 1);
		aml_parseop(scope, tmpval, 'i');
		return aml_val2int(tmpval);
	}
	dnprintf(15, "%.4x: [%s] %s\n", aml_pc(scope->pos-opsize(opcode)),
	    aml_nodename(scope->node), aml_mnem(opcode, np));
	return rval;
}

struct aml_value *
aml_evaltarget(struct aml_scope *scope, struct aml_value *res)
{
	return res;
}

int
aml_evalterm(struct aml_scope *scope, struct aml_value *raw,
    struct aml_value *dst)
{
	struct aml_value *deref;

	aml_freevalue(dst);
	deref = aml_derefterm(scope, raw, 0);
	aml_copyvalue(dst, deref);
	return 0;
}


a1580 781
/* Parse named objects */
struct aml_value *
aml_parsenamed(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *name;
	int s, offs = 0;

	AML_CHECKSTACK();
	name = aml_parsename(scope);

	res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	switch (opcode) {
	case AMLOP_NAME:
		aml_parseop(scope, res, 't');
		break;
	case AMLOP_ALIAS:
		_aml_setvalue(res, AML_OBJTYPE_NAMEREF, 0, name);
		name = aml_parsename(scope);
		break;
	case AMLOP_EVENT:
		_aml_setvalue(res, AML_OBJTYPE_EVENT, 0, NULL);
		break;
	case AMLOP_MUTEX:
		/* XXX mutex is unused since we don't have concurrency */
		_aml_setvalue(res, AML_OBJTYPE_MUTEX, 0, NULL);
		res->v_mutex = (struct acpi_mutex *)acpi_os_malloc(
		    sizeof(struct acpi_mutex));
		res->v_mutex->amt_synclevel = aml_parseint(scope,
		    AMLOP_BYTEPREFIX);
		s = strlen(aml_getname(name));
		if (s > 4)
			offs = s - 4;
		strlcpy(res->v_mutex->amt_name, aml_getname(name) + offs,
		    ACPI_MTX_MAXNAME);
		rw_init(&res->v_mutex->amt_lock, res->v_mutex->amt_name);
		break;
	case AMLOP_OPREGION:
		_aml_setvalue(res, AML_OBJTYPE_OPREGION, 0, NULL);
		res->v_opregion.iospace = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_opregion.iobase = aml_parseint(scope, AML_ANYINT);
		res->v_opregion.iolen = aml_parseint(scope, AML_ANYINT);
		if (res->v_opregion.iospace == GAS_PCI_CFG_SPACE) {
			res->v_opregion.iobase += aml_getpciaddr(dsdt_softc,
			    scope->node);
			dnprintf(20, "got ioaddr: %s.%s:%llx\n",
			    aml_nodename(scope->node), aml_getname(name),
			    res->v_opregion.iobase);
		}
		break;
	}
	aml_createname(scope->node, name, res);

	return res;
}

/* Parse Named objects with scope */
struct aml_value *
aml_parsenamedscope(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end, *name;
	struct aml_node *node;

	AML_CHECKSTACK();
	end = aml_parseend(scope);
	name = aml_parsename(scope);

	switch (opcode) {
	case AMLOP_DEVICE:
		res = aml_allocvalue(AML_OBJTYPE_DEVICE, 0, NULL);
		break;
	case AMLOP_SCOPE:
		res = NULL;
		break;
	case AMLOP_PROCESSOR:
		res = aml_allocvalue(AML_OBJTYPE_PROCESSOR, 0, NULL);
		res->v_processor.proc_id = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_processor.proc_addr = aml_parseint(scope, AMLOP_DWORDPREFIX);
		res->v_processor.proc_len = aml_parseint(scope, AMLOP_BYTEPREFIX);
		break;
	case AMLOP_POWERRSRC:
		res = aml_allocvalue(AML_OBJTYPE_POWERRSRC, 0, NULL);
		res->v_powerrsrc.pwr_level = aml_parseint(scope, AMLOP_BYTEPREFIX);
		res->v_powerrsrc.pwr_order = aml_parseint(scope, AMLOP_BYTEPREFIX);
		break;
	case AMLOP_THERMALZONE:
		res = aml_allocvalue(AML_OBJTYPE_THERMZONE, 0, NULL);
		break;
	}
	node = aml_createname(scope->node, name, res);
	aml_parsenode(scope, node, scope->pos, &end, NULL);
	scope->pos = end;

	return res;
}

/* Parse math opcodes */
struct aml_value *
aml_parsemath(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;
	int64_t i1, i2, i3;

	tmparg = aml_alloctmp(scope, 1);
	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_LNOT:
		i2 = 0;
		i1 = aml_parseint(scope, AML_ANYINT);
		break;
	case AMLOP_LAND:
	case AMLOP_LOR:
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);
		break;
	case AMLOP_NOT:
	case AMLOP_TOBCD:
	case AMLOP_FROMBCD:
	case AMLOP_TOINTEGER:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		i2 = 0;
		i1 = aml_parseint(scope, AML_ANYINT);
		aml_parsetarget(scope, tmparg, NULL);
		break;
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		aml_parsetarget(scope, tmparg, NULL);
		i1 = aml_val2int(aml_derefterm(scope, tmparg, 0));
		i2 = 1;
		break;
	case AMLOP_DIVIDE:
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);

		aml_parsetarget(scope, tmparg, NULL);	// remainder
		aml_setvalue(scope, tmparg, NULL, (i1 % i2));

		aml_parsetarget(scope, tmparg, NULL);	// quotient
		break;
	default:
		i1 = aml_parseint(scope, AML_ANYINT);
		i2 = aml_parseint(scope, AML_ANYINT);
		aml_parsetarget(scope, tmparg, NULL);
		break;
	}
	i3 = aml_evalexpr(i1, i2, opcode);
	aml_setvalue(scope, res, NULL, i3);
	aml_setvalue(scope, tmparg, NULL, i3);
	return (res);
}

/* Parse logical comparison opcodes */
struct aml_value *
aml_parsecompare(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;
	int rc;

	AML_CHECKSTACK();
	tmparg = aml_alloctmp(scope, 2);
	aml_parseterm(scope, &tmparg[AML_LHS]);
	aml_parseterm(scope, &tmparg[AML_RHS]);

	/* Compare both values */
	rc = aml_cmpvalue(&tmparg[AML_LHS], &tmparg[AML_RHS], opcode);
	aml_setvalue(scope, res, NULL, rc);

	return res;
}

/* Parse IF/ELSE opcodes */
struct aml_value *
aml_parseif(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	int64_t test;
	uint8_t *end;

	AML_CHECKSTACK();
	end = aml_parseend(scope);
	test = aml_parseint(scope, AML_ANYINT);

	dnprintf(40, "@@ iftest: %llx\n", test);
	while (test && scope->pos < end) {
		/* Parse if scope */
		aml_parseterm(scope, res);
	}
	if (scope->pos >= scope->end)
		return res;

	if (*end == AMLOP_ELSE) {
		scope->pos = ++end;
		end = aml_parseend(scope);
		while (!test && scope->pos < end) {
			/* Parse ELSE scope */
			aml_parseterm(scope, res);
		}
	}
	if (scope->pos < end)
		scope->pos = end;
	return res;
}

struct aml_value *
aml_parsewhile(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end, *start;
	int test, cnt;

	AML_CHECKSTACK();
	end = aml_parseend(scope);
	start = scope->pos;
	cnt = 0;
	do {
		test = 1;
		if (scope->pos == start || scope->pos == end) {
			scope->pos = start;
			test = aml_parseint(scope, AML_ANYINT);
			dnprintf(40, "@@whiletest = %d %x\n", test, cnt++);
		} else if (*scope->pos == AMLOP_BREAK) {
			scope->pos++;
			test = 0;
		} else if (*scope->pos == AMLOP_CONTINUE) {
			scope->pos = start;
		} else {
			aml_parseterm(scope, res);
		}
	} while (test && scope->pos <= end && cnt < 0x199);
	/* XXX: shouldn't need breakout counter */

	dnprintf(40, "Set While end : %x\n", cnt);
	if (scope->pos < end)
		scope->pos = end;
	return res;
}

/* Parse Buffer/Package opcodes */
struct aml_value *
aml_parsebufpkg(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end;
	int len;

	AML_CHECKSTACK();
	end = aml_parseend(scope);
	len = aml_parseint(scope, (opcode == AMLOP_PACKAGE) ?
	    AMLOP_BYTEPREFIX : AML_ANYINT);

	switch (opcode) {
	case AMLOP_BUFFER:
		_aml_setvalue(res, AML_OBJTYPE_BUFFER, len, NULL);
		if (scope->pos < end) {
			memcpy(res->v_buffer, scope->pos, end-scope->pos);
		}
		if (len != end-scope->pos) {
			dnprintf(99, "buffer: %.4x %.4x\n", len, end-scope->pos);
		}
		break;
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		_aml_setvalue(res, AML_OBJTYPE_PACKAGE, len, NULL);
		for (len = 0; len < res->length && scope->pos < end; len++) {
			aml_parseop(scope, res->v_package[len], 't');
		}
		if (scope->pos != end) {
			dnprintf(99, "Package not equiv!! %.4x %.4x %d of %d\n",
			    aml_pc(scope->pos), aml_pc(end), len, res->length);
		}
		break;
	}
	scope->pos = end;
	return res;
}

struct aml_value *
aml_parsemethod(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end, *name;

	AML_CHECKSTACK();
	end = aml_parseend(scope);
	name = aml_parsename(scope);

	res = aml_allocvalue(AML_OBJTYPE_METHOD, 0, NULL);
	res->v_method.flags = aml_parseint(scope, AMLOP_BYTEPREFIX);
	res->v_method.start = scope->pos;
	res->v_method.end = end;
	res->v_method.fneval = aml_callmethod;
	aml_createname(scope->node, name, res);

	scope->pos = end;

	return res;
}

/* Parse simple type opcodes */
struct aml_value *
aml_parsesimple(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_node *node;

	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_ZERO:
		_aml_setvalue(res, AML_OBJTYPE_INTEGER+AML_STATIC,
		    aml_parseint(scope, opcode), NULL);
		break;
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_REVISION:
		_aml_setvalue(res, AML_OBJTYPE_INTEGER,
		    aml_parseint(scope, opcode), NULL);
		break;
	case AMLOP_DEBUG:
		_aml_setvalue(res, AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		break;
	case AMLOP_STRINGPREFIX:
		_aml_setvalue(res, AML_OBJTYPE_STRING, -1, scope->pos);
		scope->pos += res->length+1;
		break;
	case AMLOP_NAMECHAR:
		_aml_setvalue(res, AML_OBJTYPE_NAMEREF, 0, NULL);
		res->v_nameref = aml_parsename(scope);
		node = aml_searchname(scope->node, res->v_nameref);
		if (node && node->value)
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, node->value);
		break;
	}
	return res;
}

/* Parse field unit opcodes */
struct aml_value *
aml_parsefieldunit(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	uint8_t *end, *name;
	struct aml_value *fld;

	AML_CHECKSTACK();
	end = aml_parseend(scope);

	switch (opcode) {
	case AMLOP_FIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		break;
	case AMLOP_INDEXFIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		aml_parsetarget(scope, NULL, &res->v_field.ref2);
		break;
	case AMLOP_BANKFIELD:
		aml_parsetarget(scope, NULL, &res->v_field.ref1);
		aml_parsetarget(scope, NULL, &res->v_field.ref2);
		res->v_field.ref3 = aml_parseint(scope, AML_ANYINT);
		break;
	}
	res->v_field.flags = aml_parseint(scope, AMLOP_BYTEPREFIX);
	res->v_field.type = opcode;

	aml_fixref(&res->v_field.ref1);
	aml_fixref(&res->v_field.ref2);

	while (scope->pos < end) {
		switch (*scope->pos) {
		case 0x00: // reserved
			scope->pos++;
			res->v_field.bitlen = aml_parselength(scope);
			break;
		case 0x01: // attrib
			scope->pos++;
			/* XXX: do something with this */
			aml_parseint(scope, AMLOP_BYTEPREFIX);
			aml_parseint(scope, AMLOP_BYTEPREFIX);
			res->v_field.bitlen = 0;
			break;
		default:
			name = aml_parsename(scope);
			res->v_field.bitlen = aml_parselength(scope);

			/* Allocate new fieldunit */
			fld = aml_allocvalue(AML_OBJTYPE_FIELDUNIT, 0, NULL);

			/* Increase reference count on field */
			fld->v_field = res->v_field;
			aml_addref(fld->v_field.ref1);
			aml_addref(fld->v_field.ref2);

			aml_createname(scope->node, name, fld);
			break;
		}
		res->v_field.bitpos += res->v_field.bitlen;
	}
	/* Delete redundant reference */
	aml_delref(&res->v_field.ref1);
	aml_delref(&res->v_field.ref2);
	return res;
}

/* Parse CreateXXXField opcodes */
struct aml_value *
aml_parsebufferfield(struct aml_scope *scope, int opcode,
    struct aml_value *res)
{
	uint8_t *name;

	AML_CHECKSTACK();
	res = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL);
	res->v_field.type = opcode;
	aml_parsetarget(scope, NULL, &res->v_field.ref1);
	res->v_field.bitpos = aml_parseint(scope, AML_ANYINT);

	aml_fixref(&res->v_field.ref1);

	switch (opcode) {
	case AMLOP_CREATEFIELD:
		res->v_field.bitlen = aml_parseint(scope, AML_ANYINT);
		break;
	case AMLOP_CREATEBITFIELD:
		res->v_field.bitlen = 1;
		break;
	case AMLOP_CREATEBYTEFIELD:
		res->v_field.bitlen = 8;
		res->v_field.bitpos *= 8;
		break;
	case AMLOP_CREATEWORDFIELD:
		res->v_field.bitlen = 16;
		res->v_field.bitpos *= 8;
		break;
	case AMLOP_CREATEDWORDFIELD:
		res->v_field.bitlen = 32;
		res->v_field.bitpos *= 8;
		break;
	case AMLOP_CREATEQWORDFIELD:
		res->v_field.bitlen = 64;
		res->v_field.bitpos *= 8;
		break;
	}
	name = aml_parsename(scope);
	aml_createname(scope->node, name, res);

	return res;
}

/* Parse Mutex/Event action */
struct aml_value *
aml_parsemuxaction(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;
	int64_t i1;
	int rv;

	AML_CHECKSTACK();

	tmparg = aml_alloctmp(scope, 1);
	aml_parsetarget(scope, tmparg, NULL);
	switch (opcode) {
	case AMLOP_ACQUIRE:
		/* Assert: tmparg is AML_OBJTYPE_MUTEX */
		i1 = aml_parseint(scope, AMLOP_WORDPREFIX);
		rv = acpi_mutex_acquire(tmparg->v_objref.ref, i1);
		/* Return true if timed out */
		aml_setvalue(scope, res, NULL, rv);
		break;
	case AMLOP_RELEASE:
		acpi_mutex_release(tmparg->v_objref.ref);
		break;

	case AMLOP_WAIT:
		/* Assert: tmparg is AML_OBJTYPE_EVENT */
		i1 = aml_parseint(scope, AML_ANYINT);

		/* Return true if timed out */
		aml_setvalue(scope, res, NULL, 0);
		break;
	case AMLOP_SIGNAL:
		break;
	case AMLOP_RESET:
		break;
	}

	return res;
}

/* Parse Miscellaneous opcodes */
struct aml_value *
aml_parsemisc2(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg, *dev;
	int i1, i2, i3;

	AML_CHECKSTACK();

	switch (opcode) {
	case AMLOP_NOTIFY:
		/* Assert: tmparg is nameref or objref */
		tmparg = aml_alloctmp(scope, 1);
		aml_parseop(scope, tmparg, 'r');
		dev = aml_dereftarget(scope, tmparg);

		i1 = aml_parseint(scope, AML_ANYINT);
		if (dev && dev->node) {
			dnprintf(10, "Notify: [%s] %.2x\n",
			    aml_nodename(dev->node), i1);
			aml_notify(dev->node, i1);
		}
		break;
	case AMLOP_SLEEP:
		i1 = aml_parseint(scope, AML_ANYINT);
		dnprintf(50, "SLEEP: %x\n", i1);
		if (i1)
			acpi_sleep(i1);
		else {
			dnprintf(10, "acpi_sleep(0)\n");
		}
		break;
	case AMLOP_STALL:
		i1 = aml_parseint(scope, AML_ANYINT);
		dnprintf(50, "STALL: %x\n", i1);
		if (i1)
			acpi_stall(i1);
		else {
			dnprintf(10, "acpi_stall(0)\n");
		}
		break;
	case AMLOP_FATAL:
		i1 = aml_parseint(scope, AMLOP_BYTEPREFIX);
		i2 = aml_parseint(scope, AMLOP_DWORDPREFIX);
		i3 = aml_parseint(scope, AML_ANYINT);
		aml_die("FATAL: %x %x %x\n", i1, i2, i3);
		break;
	}
	return res;
}

/* Parse Miscellaneous opcodes */
struct aml_value *
aml_parsemisc3(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;

	AML_CHECKSTACK();
	tmparg = aml_alloctmp(scope, 1);
	aml_parseterm(scope, tmparg);
	switch (opcode) {
	case AMLOP_SIZEOF:
		aml_setvalue(scope, res, NULL, tmparg->length);
		break;
	case AMLOP_OBJECTTYPE:
		aml_setvalue(scope, res, NULL, tmparg->type);
		break;
	}

	return res;
}

/* Parse AMLOP_MATCH */
struct aml_value *
aml_parsematch(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *pkg;
	int op1, op2, idx, mv1, mv2;

	AML_CHECKSTACK();
	pkg = aml_parseterm(scope, NULL);
	op1 = aml_parseint(scope, AMLOP_BYTEPREFIX);
	mv1 = aml_parseint(scope, AML_ANYINT);
	op2 = aml_parseint(scope, AMLOP_BYTEPREFIX);
	mv2 = aml_parseint(scope, AML_ANYINT);
	idx = aml_parseint(scope, AML_ANYINT);

	aml_setvalue(scope, res, NULL, -1);
	while (idx < pkg->length) {
		if (aml_match(op1, mv1, pkg->v_package[idx]) ||
		    aml_match(op2, mv2, pkg->v_package[idx])) {
			aml_setvalue(scope, res, NULL, idx);
			break;
		}
		idx++;
	}
	aml_delref(&pkg);
	return res;
}

/* Parse referenced objects */
struct aml_value *
aml_parseref(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmparg;

	AML_CHECKSTACK();

	switch (opcode) {
	case AMLOP_INDEX:
		tmparg = aml_alloctmp(scope, 1);
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, NULL);
		aml_parsetarget(scope, tmparg, NULL);

		res->v_objref.index = aml_parseint(scope, AML_ANYINT);
		res->v_objref.ref = aml_dereftarget(scope, tmparg);

		aml_parsetarget(scope, tmparg, NULL);
		aml_setvalue(scope, tmparg, res, 0);
		break;
	case AMLOP_DEREFOF:
		aml_parseop(scope, res, 't');
		break;
	case AMLOP_RETURN:
		tmparg = aml_alloctmp(scope, 1);
		aml_parseterm(scope, tmparg);
		aml_setvalue(scope, res, tmparg, 0);
		scope->pos = scope->end;
		break;
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		opcode -= AMLOP_ARG0;
		if (scope->args == NULL || opcode >= scope->nargs)
			aml_die("arg %d out of range", opcode);

		/* Create OBJREF to stack variable */
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1,
		    &scope->args[opcode]);
		break;
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		opcode -= AMLOP_LOCAL0;

		/* No locals exist.. lazy allocate */
		if (scope->locals == NULL) {
			dnprintf(10, "Lazy alloc locals\n");
			scope->locals = aml_alloctmp(scope, AML_MAX_LOCAL);
		}

		/* Create OBJREF to stack variable */
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1,
		    &scope->locals[opcode]);
		res->v_objref.ref->stack = opcode+AMLOP_LOCAL0;
		break;
	case AMLOP_LOAD:
		tmparg = aml_alloctmp(scope, 2);
		aml_parseop(scope, &tmparg[0], 't');
		aml_parseop(scope, &tmparg[1], 't');
		break;
	case AMLOP_STORE:
		tmparg = aml_alloctmp(scope, 1);
		aml_parseterm(scope, res);
		aml_parsetarget(scope, tmparg, NULL);

		while (tmparg->type == AML_OBJTYPE_OBJREF) {
			if (tmparg->v_objref.index != -1)
				break;
			tmparg = tmparg->v_objref.ref;
		}
		aml_setvalue(scope, tmparg, res, 0);
		break;
	case AMLOP_REFOF:
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, NULL);
		aml_parsetarget(scope, NULL, &res->v_objref.ref);
		break;
	case AMLOP_CONDREFOF:
		/* Returns true if object exists */
		tmparg = aml_alloctmp(scope, 2);
		aml_parsetarget(scope, &tmparg[0], NULL);
		aml_parsetarget(scope, &tmparg[1], NULL);
		if (tmparg[0].type != AML_OBJTYPE_NAMEREF) {
			/* Object exists */
			aml_freevalue(&tmparg[1]);
			aml_setvalue(scope, &tmparg[1], &tmparg[0], 0);
			aml_setvalue(scope, res, NULL, 1);
		} else {
			/* Object doesn't exist */
			aml_setvalue(scope, res, NULL, 0);
		}
		break;
	}

	return res;
}

struct aml_value *
aml_parsestring(struct aml_scope *scope, int opcode, struct aml_value *res)
{
	struct aml_value *tmpval;
	int i1, i2;

	AML_CHECKSTACK();
	switch (opcode) {
	case AMLOP_CONCAT:
		tmpval = aml_alloctmp(scope, 4);
		aml_parseterm(scope, &tmpval[AML_LHS]);
		aml_parseterm(scope, &tmpval[AML_RHS]);
		aml_parsetarget(scope, &tmpval[AML_DST], NULL);
		if (tmpval[AML_LHS].type == AML_OBJTYPE_BUFFER &&
		    tmpval[AML_RHS].type == AML_OBJTYPE_BUFFER) {
			aml_resize(&tmpval[AML_LHS],
			    tmpval[AML_LHS].length+tmpval[AML_RHS].length);
			memcpy(tmpval[AML_LHS].v_buffer+tmpval[AML_LHS].length,
			    tmpval[AML_RHS].v_buffer, tmpval[AML_RHS].length);
			aml_setvalue(scope, &tmpval[AML_DST], &tmpval[AML_LHS], 0);
		} else if (tmpval[AML_LHS].type == AML_OBJTYPE_STRING &&
		    tmpval[AML_RHS].type == AML_OBJTYPE_STRING) {
			aml_resize(&tmpval[AML_LHS],
			    tmpval[AML_LHS].length+tmpval[AML_RHS].length);
			memcpy(tmpval[AML_LHS].v_string+tmpval[AML_LHS].length,
			    tmpval[AML_RHS].v_buffer, tmpval[AML_RHS].length);
			aml_setvalue(scope, &tmpval[AML_DST], &tmpval[AML_LHS], 0);
		} else {
			aml_die("concat");
		}
		break;
	case AMLOP_MID:
		tmpval = aml_alloctmp(scope, 2);
		aml_parseterm(scope, &tmpval[0]);
		i1 = aml_parseint(scope, AML_ANYINT); // start
		i2 = aml_parseint(scope, AML_ANYINT); // length
		aml_parsetarget(scope, &tmpval[1], NULL);
		if (i1 > tmpval[0].length)
			i1 = tmpval[0].length;
		if (i1+i2 > tmpval[0].length)
			i2 = tmpval[0].length-i1;
		_aml_setvalue(res, AML_OBJTYPE_STRING, i2, tmpval[0].v_string+i1);
		break;
	case AMLOP_TODECSTRING:
	case AMLOP_TOHEXSTRING:
		i1 = aml_parseint(scope, AML_ANYINT);
		_aml_setvalue(res, AML_OBJTYPE_STRING, 20, NULL);
		snprintf(res->v_string, res->length,
		    ((opcode == AMLOP_TODECSTRING) ? "%d" : "%x"), i1);
		break;
	default:
		aml_die("to_string");
		break;
	}

	return res;
}

struct aml_value *
aml_parseterm(struct aml_scope *scope, struct aml_value *res)
{
	struct aml_value *tmpres;

	/* If no value specified, allocate dynamic */
	if (res == NULL)
		res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	tmpres = aml_alloctmp(scope, 1);
	aml_parseop(scope, tmpres, 't');
	aml_evalterm(scope, tmpres, res);
	return res;
}

struct aml_value *
aml_parsetarget(struct aml_scope *scope, struct aml_value *res,
    struct aml_value **opt)
{
	struct aml_value *dummy;

	/* If no value specified, allocate dynamic */
	if (res == NULL)
		res = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
	aml_parseop(scope, res, 'r');
	if (opt == NULL)
		opt = &dummy;

	*opt = aml_evaltarget(scope, res);

	return res;
}

a1581 34

/* Main Opcode Parser/Evaluator */
struct aml_value *
aml_parseop(struct aml_scope *scope, struct aml_value *res, int ctype)
{
	int opcode;
	struct aml_opcode *htab;
	struct aml_value *rv = NULL;

	if (odp++ > 25)
		panic("depth");

	aml_freevalue(res);
	opcode = aml_parseopcode(scope);
	dnprintf(15, "%.4x: [%s] %s\n", aml_pc(scope->pos-opsize(opcode)),
	    aml_nodename(scope->node), aml_mnem(opcode, scope->pos));
	delay(amlop_delay);

	htab = aml_findopcode(opcode);
	if (htab && htab->handler) {
		rv = htab->handler(scope, opcode, res);
	} else {
		/* No opcode handler */
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode,
		    aml_pc(scope->pos - opsize(opcode)));
	}
	if (ctype == 'i' && res->type != AML_OBJTYPE_INTEGER) {
		rv = aml_derefterm(scope, res, 0);
		aml_freevalue(res);
		aml_copyvalue(res, rv);
	}
	odp--;
	return rv;
}
@


1.112
log
@only compile aml_dump() if option ACPI_DEBUG.
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.111 2008/05/14 21:13:40 miod Exp $ */
d5532 4
d6182 2
a6209 8
	return (0);

	/* Pass object off to Eval Function */
	xres = aml_xeval(NULL, node->value, 't', argc, argv);
	aml_copyvalue(res, xres);
	if (xres != node->value)
		aml_xdelref(&xres, "EvalNode");

@


1.111
log
@Let this build and link if SMALL_KERNEL.
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.110 2008/05/14 05:24:36 jordan Exp $ */
d545 1
d557 1
@


1.110
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.109 2008/02/07 17:48:59 henning Exp $ */
d37 4
d3779 1
d3804 1
d4107 1
d4109 1
d4439 1
d4442 1
d5160 1
d5162 1
d5685 1
d5687 1
@


1.109
log
@unbreak SMALL_KERNEL kernels, with miod
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.108 2008/02/05 21:15:26 jordan Exp $ */
d187 1
a187 1
	{ AMLOP_IF,		"If",		"pI",	aml_parseif },
d189 1
a189 1
	{ AMLOP_WHILE,		"While",	"piT",	aml_parsewhile },
d237 1
a237 1
	{ AMLOP_POWERRSRC,	"Power Resource", "pNbwT", aml_parsenamedscope },
d240 1
a240 1
	{ AMLOP_METHOD,		"Method",	"pNfM",	aml_parsemethod },
d243 3
a245 3
	{ AMLOP_FIELD,		"Field",	"pnfF",		aml_parsefieldunit },
	{ AMLOP_INDEXFIELD,	"IndexField",	"pntfF",	aml_parsefieldunit },
	{ AMLOP_BANKFIELD,	"BankField",	"pnnifF",	aml_parsefieldunit },
d247 4
a250 4
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEWORDFIELD, "CreateWordField", "tiN",	aml_parsebufferfield },
	{ AMLOP_CREATEBYTEFIELD, "CreateByteField", "tiN",	aml_parsebufferfield },
d258 1
a258 1
	{ AMLOP_TOSTRING,	"ToString",	"t",	aml_parsestring },
d264 5
a268 5
	{ AMLOP_ACQUIRE,	"Acquire",	"tw",	aml_parsemuxaction },
	{ AMLOP_RELEASE,	"Release",	"t",	aml_parsemuxaction },
	{ AMLOP_SIGNAL,		"Signal",	"t",	aml_parsemuxaction },
	{ AMLOP_WAIT,		"Wait",		"ti",	aml_parsemuxaction },
	{ AMLOP_RESET,		"Reset",	"t",	aml_parsemuxaction },
d272 2
a273 2
	{ AMLOP_REFOF,		"RefOf",	"t",	aml_parseref },
	{ AMLOP_CONDREFOF,	"CondRef",	"nr",	aml_parseref },
d278 1
a278 1
	{ AMLOP_LOAD,		"Load",		"nt",	aml_parseref },
d280 1
a280 1
	{ AMLOP_STORE,		"Store",	"tr",	aml_parseref },
d283 2
a284 2
	{ AMLOP_NOTIFY,		"Notify",	"ti",	aml_parsemisc2 },
	{ AMLOP_SIZEOF,		"Sizeof",	"t",	aml_parsemisc3 },
d286 2
a287 2
	{ AMLOP_OBJECTTYPE,	"ObjectType",	"t",	aml_parsemisc3 },
	{ AMLOP_COPYOBJECT,	"CopyObject",	"tr",	aml_parseref },
d671 1
a671 1
struct aml_node *__aml_search(struct aml_node *, uint8_t *);
d677 1
a677 1
__aml_search(struct aml_node *root, uint8_t *nameseg)
d679 3
d684 19
a702 3
	for (root = root->child; root; root = root->sibling) {
		if (!memcmp(root->name, nameseg, AML_NAMESEG_LEN))
			return root;
d704 1
a704 1
	return NULL;
d794 1
a794 1
		if ((node = __aml_search(root, name)) == NULL) {
d816 1
d849 1
a849 1
			while (*name && (root = __aml_search(root, name)) != NULL) {
d855 1
a855 1
		while (root && (node = __aml_search(root, name)) == NULL) {
d861 1
a861 1
	while (count-- && (root = __aml_search(root, name)) != NULL) {
d866 1
d1058 2
a1059 1

d1988 1
a1988 1
	dnprintf(50,"aml_evalexpr: %s %llx %llx = %llx\n",
d2107 1
d2186 1
d3428 2
a3429 8
	struct aml_value tmpstr, *arg;
	int idx, result;

	/* Perform comparison with valid strings */
	result = 0;
	memset(&tmpstr, 0, sizeof(tmpstr));
	tmpstr.type = AML_OBJTYPE_STRING;
	arg = aml_derefvalue(scope, &scope->args[0], ACPI_IOREAD);
d3431 1
d3433 2
a3434 4
		tmpstr.v_string = aml_valid_osi[idx];
		tmpstr.length = strlen(tmpstr.v_string);

		result = aml_cmpvalue(arg, &tmpstr, AMLOP_LEQUAL);
d3436 2
a3437 2
	aml_setvalue(scope, val, NULL, result);
	return val;
d3451 4
d3578 1
d3597 1
d3669 2596
@


1.108
log
@Added change for debugging setbufint
ok marco@@
@
text
@d2 1
a2 1
/* $OpenBSD: dsdt.c,v 1.107 2008/01/22 19:28:57 jordan Exp $ */
d985 1
d987 1
d1729 1
a1729 1
			//aml_showvalue(rhs);
@


1.107
log
@Added change to parseop to support return value; removes 1/2 stack depth for
parseint
ok marco@@
@
text
@d1 2
a2 1
/* $OpenBSD: dsdt.c,v 1.106 2007/12/02 22:24:54 jordan Exp $ */
d984 2
a985 1
	if (src->type != AML_OBJTYPE_BUFFER)
d987 1
a987 1

d1638 1
a1639 1
		memset(&tmpint, 0, sizeof(tmpint));
d1642 6
d1736 1
@


1.106
log
@Added AMLOP_BREAKOPINT function handler for X40 systems
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.105 2007/11/17 21:52:25 kettenis Exp $ */
d84 1
a84 1
struct aml_value	*aml_parseop(struct aml_scope *, struct aml_value *);
d963 1
a963 1
			aml_parseop(scope, res);
d1451 1
a1451 1
				aml_parseop(scope, &tmp[index]);
d2448 1
a2448 1
		aml_parseterm(scope, tmpval);
d2492 1
a2492 1
		aml_parseop(scope, res);
d2740 1
a2740 1
			aml_parseop(scope, res->v_package[len]);
d2977 1
a2977 1
		aml_parseop(scope, tmparg);
d3085 1
a3085 1
		aml_parseop(scope, res);
d3131 2
a3132 2
		aml_parseop(scope, &tmparg[0]);
		aml_parseop(scope, &tmparg[1]);
d3237 1
a3237 1
	aml_parseop(scope, tmpres);
d3251 1
a3251 1
	aml_parseop(scope, res);
d3264 1
a3264 1
aml_parseop(struct aml_scope *scope, struct aml_value *res)
d3286 5
@


1.105
log
@Print the type that's wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.104 2007/11/17 16:41:47 kettenis Exp $ */
d194 1
a194 1
	{ AMLOP_BREAKPOINT,	"BreakPoint",	"" },
@


1.104
log
@Buffers are not necessarily NUL-terminated, so use memcpy instead of strlcpy
to convert a buffer into a string.
ok canacar@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.103 2007/11/15 16:02:18 deraadt Exp $ */
d984 1
a984 1
		aml_die("wrong setbufint type\n");
d1010 1
a1010 1
		aml_die("wrong getbufint type\n");
@


1.103
log
@don't waste our time telling the aml that we are OpenBSD; it will never
make a good decision based on that; ok kettenis canacar
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.102 2007/11/14 20:31:31 deraadt Exp $ */
d3612 5
a3616 4
		len = val->length + 1;
		if (len > sizeof(buffer))
			len = sizeof(buffer);
		strlcpy(buffer, val->v_buffer, len);
@


1.102
log
@shrink floppy build by knocking out some unused bits of code; seen by canacar
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.101 2007/11/14 20:22:11 canacar Exp $ */
a3372 1
	"OpenBSD",
@


1.101
log
@Fix handling of local AML variables for type conversion:
Check whether a variable is local before and after dereferencing.
Improve the check to make sure that the variable is in
local in current scope.
Tested by many, thanks a lot. ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.100 2007/11/10 17:53:16 chl Exp $ */
d296 2
a297 1
void _aml_die(const char *fn, int line, const char *fmt, ...)
d299 1
d301 2
a303 1
	int idx;
d310 1
d325 1
d1164 1
a1164 1
			aml_die("Not an opregion!\n");
d1216 1
a1216 1
			aml_bufcpy(res->v_buffer, 0, iobuf, 
d1221 1
a1221 1
			dnprintf(55,"non-aligned read: %.4x:%.4x : ", 
d1249 1
a1249 1
			dnprintf(55,"non-aligned write: %.4x:%.4x : ", 
d1294 1
d1377 1
a2168 16
void
aml_walktree(struct aml_node *node)
{
	while (node) {
		aml_showvalue(node->value, 0);
		aml_walktree(node->child);
		node = node->sibling;
	}
}

void
aml_walkroot(void)
{
	aml_walktree(aml_root.child);
}

d2252 1
a2252 1
/* Decode AML Length field 
d2270 1
a2270 1
	
d3430 1
d3486 1
d3532 1
a3532 2
	       void (*fn)(struct aml_value *, void *),
	       void *arg)
d3611 1
a3611 1
	switch(val->type) {
@


1.100
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.99 2007/11/08 22:41:48 canacar Exp $ */
d1606 2
a1607 1
int is_local(struct aml_scope *scope, struct aml_value *val)
d1609 10
a1618 1
	return val->stack;
d1634 3
a1639 3
	}
	else {
		lhs = aml_dereftarget(scope, lhs);
@


1.99
log
@Pass correct pointers to memcpy when concatanating strings/buffers
ok weingart@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.98 2007/11/08 20:27:20 canacar Exp $ */
d424 3
a426 6
	if (sptr) {
		acpi_nalloc += size;
		sptr->size = size;
		return &sptr[1];
	}
	return NULL;
@


1.98
log
@convert the value to a string instead of using aml_val2str()
which returns invalid pointers if the value is not a string, causing
acpibat to panic, as reported by mbalmer@@ and Alexey Suslikov.
tested by Alexey Suslikov, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.97 2007/11/05 03:15:22 weingart Exp $ */
d3189 1
a3189 1
			memcpy(&tmpval[AML_LHS].v_buffer+tmpval[AML_LHS].length,
d3196 1
a3196 1
			memcpy(&tmpval[AML_LHS].v_string+tmpval[AML_LHS].length,
@


1.97
log
@Use the acpi_{acquire,release}_global_lock() to implement the global
functionality for ACPI.  Has not shown any regressions, and may solve
some EC race conditions.

Ok gwk@@, canacar@@, ckuethe@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.96 2007/11/03 21:13:48 ckuethe Exp $ */
d3603 28
@


1.96
log
@ACPI allows the OS to identify itself in a couple of ways and may behave
differently based on what OS is running. This diff causes us to run the
RedmondOS code path in hopes that it is "better" AML, or has better settings
for machine that do not support _OSI. This is the same method used by
other non-Redmond operating sytems.

suggestions/ok deraadt, agonized whimpers from the others.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.95 2007/11/03 19:17:47 canacar Exp $ */
d1028 4
d1035 13
a1047 2
	if (AML_FIELD_LOCK(field->v_field.flags) == AML_FIELD_LOCK_ON) {
		/* XXX: do locking here */
d1049 2
d1056 20
a1075 3
	if (AML_FIELD_LOCK(field->v_field.flags) == AML_FIELD_LOCK_ON) {
		/* XXX: do unlocking here */
	}
@


1.95
log
@Add missing else so that Concatanation of two buffers work.
Noticed by  robert@@ while diagnosing a problem report by
Johan Lindman. ok weingart@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.94 2007/11/03 19:06:07 canacar Exp $ */
d3321 1
d3329 1
a3329 1
	{ "_OS_", AML_OBJTYPE_STRING, -1, "OpenBSD" },
d3381 5
@


1.94
log
@Fix setting values to buffers by obeying the conversion rules.
The values are truncated or zero extended as required. The spec
is somewhat ambigious on strings and integers requiring truncation
"before copy" so we try to be safe and zero terminate the buffer
in case the source is string.

Reported by ckuethe@@, diagnosis, initial diff and feedback by kettenis@@
ok kettenis@@, beck@@, weingart@@, robert@@, gwk@@, ckuethe@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.93 2007/11/03 17:48:10 ckuethe Exp $ */
d3158 1
a3158 2
		}
		if (tmpval[AML_LHS].type == AML_OBJTYPE_STRING &&
@


1.93
log
@Remove those words...
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.92 2007/11/03 17:33:50 ckuethe Exp $ */
d1624 4
d1630 12
a1641 12
		aml_freevalue(lhs);
		if (rhs->type == AML_OBJTYPE_BUFFER)
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, rhs->length,
			    rhs->v_buffer);
		else if (rhs->type == AML_OBJTYPE_INTEGER ||
			    rhs->type == AML_OBJTYPE_STATICINT)
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER,
			    sizeof(rhs->v_integer), &rhs->v_integer);
		else if (rhs->type == AML_OBJTYPE_STRING)
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, rhs->length+1,
			    rhs->v_string);
		else {
d1645 9
d1655 1
@


1.92
log
@ACPI allows the OS to identify itself in a couple of ways and may behave
differently based on what OS is running. This diff causes us to run the
WinNT code path in hopes that it is "better" AML, or has better settings
for machine that do not support _OSI. This is the same method used by
other non-windows operating sytems.

ok gwk, beck, jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.91 2007/11/03 17:23:25 jordan Exp $ */
d3315 1
a3315 1
	{ "_OS_", AML_OBJTYPE_STRING, -1, "Microsoft Windows NT\0(TM)" },
@


1.91
log
@Changed aml_parselength to use incremental length calc
ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.90 2007/10/08 04:15:15 krw Exp $ */
d3315 1
a3315 1
	{ "_OS_", AML_OBJTYPE_STRING, -1, "OpenBSD" },
@


1.90
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.89 2007/09/13 03:43:22 weingart Exp $ */
d2206 8
a2213 1
/* Decode AML Length field */
d2217 2
a2218 1
	int len = (*scope->pos & 0xF);
d2220 13
a2232 18
	switch (*scope->pos >> 6) {
	case 0x00:
		len = scope->pos[0] & 0x3F;
		scope->pos += 1;
		break;
	case 0x01:
		len += (scope->pos[1]<<4L);
		scope->pos += 2;
		break;
	case 0x02:
		len += (scope->pos[1]<<4L) + (scope->pos[2]<<12L);
		scope->pos += 3;
		break;
	case 0x03:
		len += (scope->pos[1]<<4L) + (scope->pos[2]<<12L) +
		    (scope->pos[3]<<20L);
		scope->pos += 4;
		break;
@


1.89
log
@Implement ACPI 6.5.1 spec tree walk for _STA and _INI.
Fixes mk's laptop.  No regressions so far (thank you to the
testers).

ok gwk@@, mk@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.88 2007/09/08 21:19:52 gwk Exp $ */
d422 1
a422 1
	sptr = malloc(size+sizeof(*sptr), M_DEVBUF, M_WAITOK);
a426 1
		memset(&sptr[1], 0, size);
@


1.88
log
@Case ranges e.g. case 'A' ... 'Z': are a gcc-ism not valid C. Fix these, and
a bit of whitespace cleanup while here.

ok otto, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.87 2007/04/11 02:51:11 jordan Exp $ */
d2126 1
a2126 1
    void (*cbproc)(struct aml_node *, void *arg), void *arg)
d2129 1
d2136 1
a2136 1
				cbproc(node, arg);
d2138 3
a2140 1
		aml_find_node(node->child, name, cbproc, arg);
d2143 1
a2143 1
	return (0);
@


1.87
log
@Added changes for C-State
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.86 2007/03/23 05:43:46 jordan Exp $ */
d1099 3
a1101 3
		dnprintf(55, "-- post indexfield %x,%x @@ %x,%x\n", 
		    bpos & 3, blen, 
		    field->v_field.ref2->v_field.bitpos, 
d1117 3
a1119 3
		dnprintf(55, "-- post bankfield %x,%x @@ %x,%x\n", 
		    bpos & 3, blen, 
		    field->v_field.ref2->v_field.bitpos, 
d1152 1
a1152 1
		
d1165 1
a1165 1
			    mask + 1, iobuf, mode); 
d1168 1
a1168 1
			    mode == ACPI_IOREAD ? "rd" : "wr", 
d2165 3
a2167 1
	case 'A' ... 'Z':
d3042 7
a3048 1
	case AMLOP_ARG0 ... AMLOP_ARG6:
d3057 8
a3064 1
	case AMLOP_LOCAL0 ... AMLOP_LOCAL7:
d3090 1
a3090 1
		    		break;
d3222 1
a3222 1
	
d3321 1
a3321 1
char *aml_valid_osi[] = { 
d3350 1
a3350 1
		
d3406 1
a3406 1
	  	printf("word\ttype:%.2x flags:%.2x tflag:%.2x gra:%.4x min:%.4x max:%.4x tra:%.4x len:%.4x\n",
d3412 1
a3412 1
	  	printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.8x min:%.8x max:%.8x tra:%.8x len:%.8x\n",
d3418 1
a3418 1
	  	printf("dword\ttype:%.2x flags:%.2x tflag:%.2x gra:%.16llx min:%.16llx max:%.16llx tra:%.16llx len:%.16llx\n",
d3457 1
a3457 1
	
d3473 2
a3474 2
aml_foreachpkg(struct aml_value *pkg, int start, 
	       void (*fn)(struct aml_value *, void *), 
d3478 1
a3478 1
	
d3481 1
a3481 1
	for (idx=start; idx<pkg->length; idx++) 
@


1.86
log
@Fix set to already set local
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.85 2007/02/27 20:22:23 deraadt Exp $ */
a3455 3

void	aml_foreachpkg(struct aml_value *, int,
	    void (*fn)(struct aml_value *, void *), void *);
@


1.85
log
@please, check it compiles before you commit
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.84 2007/02/27 19:53:32 jordan Exp $ */
d3073 5
@


1.84
log
@Added fix for condref, free storing into value
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.83 2007/02/22 06:22:31 jordan Exp $ */
d3451 3
@


1.83
log
@New resource mapper interface and structures
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.82 2007/02/21 03:36:25 jordan Exp $ */
d1527 2
a1528 2
	lhs->type = rhs->type;
	switch (lhs->type & ~AML_STATIC) {
d1533 3
d1537 7
a1543 1
		_aml_setvalue(lhs, rhs->type, rhs->v_integer, NULL);
d1558 1
a1558 1
		_aml_setvalue(lhs, rhs->type, 0, rhs->v_nameref);
d1566 1
a1566 1
		_aml_setvalue(lhs, rhs->type, rhs->v_objref.index, rhs->v_objref.ref);
a3072 7
		/* hack - keep from calling method in Locals */
		while (tmparg->type == AML_OBJTYPE_OBJREF &&
		    tmparg->v_objref.index == -1) {
			if (tmparg->stack)
				break;
			tmparg = tmparg->v_objref.ref;
		}
d3086 1
d3450 13
@


1.82
log
@Fixed deref for storing to local after CondRef op
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.81 2007/02/20 16:52:40 marco Exp $ */
d3358 1
a3358 1
		printf("extirq: flags:%x len:%x irq:%x\n",
d3363 2
a3364 2
		printf("irq %.4x %.2x", aml_letohost16(crs->sr_irq.irq_mask),
		    crs->sr_irq.irq_info);
d3367 2
a3368 2
		printf("dma %.2x %.2x", crs->sr_dma.dma_chan,
		    crs->sr_dma.dma_info);
d3371 4
a3374 4
		printf("io %.2x _min:%.4x _max:%.4x _aln:%.2x _len:%.2x\n",
		    crs->sr_ioport.io_info, crs->sr_ioport.io_min,
		    crs->sr_ioport.io_max, crs->sr_ioport.io_aln,
		    crs->sr_ioport.io_len);
d3377 1
a3377 1
		printf("startdep");
d3380 19
a3398 1
		printf("enddep");
d3407 18
d3429 1
a3429 1
	int off, rlen, mlen;
a3430 1
	uint8_t *tmprsrc;
d3432 1
a3432 2
	for (off = 0; off < length; off += rlen+1) {
		tmprsrc = NULL;
d3434 1
d3436 1
a3436 7

		switch (AML_CRSTYPE(crs)) {
		case LR_EXTIRQ:
			mlen = 6;
			break;
		case LR_WORD:
			mlen = 13;
a3437 14
		case LR_DWORD:
			mlen = 23;
			break;
		case LR_QWORD:
			mlen = 43;
			break;
		default:
			mlen = 99;
			break;
		}
		if (rlen == 0 || crs->hdr.typecode == 0x79)
			break;
		if (rlen < mlen) {
			tmprsrc = acpi_os_malloc(mlen+64);
d3439 4
a3442 9
			rlen = mlen;
			if (off+mlen >= length)
				mlen = length-off;
			dnprintf(20,"Bad resource length: %x/%d bytes\n", 
			    mlen, rlen);
			memcpy(tmprsrc, buffer+off, mlen);
			crs = (union acpi_resource *)tmprsrc;
		}
		/* aml_print_resource(crs, NULL); */
a3443 3

		if (tmprsrc)
			acpi_os_free(tmprsrc);
@


1.81
log
@Move AML_OBJDEBUG into ACPI_DEBUG.
KNF while in here too.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.80 2007/02/18 02:25:05 jordan Exp $ */
d1269 1
a1269 1
	printf(" %p cnt:%.2x", val, val->refcnt);
d1565 7
d1585 1
a1585 2
	lhs = aml_dereftarget(scope, lhs);
	if (lhs->stack) {
d1589 4
d2364 1
d2369 1
d2374 1
d2379 1
d2390 1
a2390 1
	    aml_nodename(scope->node), aml_mnem(opcode, NULL));
d3063 8
d3199 1
a3199 1

@


1.80
log
@Added dynamic perfect hash for opcodes
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.79 2007/02/13 04:40:00 jordan Exp $ */
d1054 2
a1055 1
		return &val->v_integer;
d1059 2
a1060 1
		return val->v_buffer;
d1064 2
a1065 1
	return NULL;
d1085 2
a1086 3
		 mode == ACPI_IOREAD ? "rd" : "wr",
		 aml_nodename(field->node),
		 bpos, blen);
d1100 4
a1103 3
		       bpos & 3, blen, 
		       field->v_field.ref2->v_field.bitpos, 
		       field->v_field.ref2->v_field.bitlen);
d1105 1
a1105 1
		aml_dump(aligned>>3, iobuf);
d1118 4
a1121 3
		       bpos & 3, blen, 
		       field->v_field.ref2->v_field.bitpos, 
		       field->v_field.ref2->v_field.bitlen);
d1123 1
a1123 1
		aml_dump(aligned>>3, iobuf);
d1150 2
a1151 2
			_aml_setvalue(res, AML_OBJTYPE_BUFFER, 
				      (field->v_field.bitlen+7)>>3, NULL);
d1164 2
a1165 2
				  iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
				  iobuf, mode); 
d1168 4
a1171 3
			       mode == ACPI_IOREAD ? "rd" : "wr", 
			       bpos, blen, aligned);
			aml_dump(blen>>3, iobuf);
d1177 2
a1178 2
				  iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
				  iobuf, mode);
d1182 2
a1183 2
				   field->v_field.bitpos & mask,
				   field->v_field.bitlen);
d1189 2
a1190 1
			aml_dump(blen>>3, iobuf);
d1197 1
a1197 1
			iobuf = acpi_os_malloc(blen>>3);
d1200 1
a1200 1
				memset(iobuf, 0xFF, blen>>3);
d1204 2
a1205 2
					  iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
					  iobuf, ACPI_IOREAD);
d1210 2
a1211 3
			aml_bufcpy(iobuf, field->v_field.bitpos & mask, 
				   iobuf2, 0,
				   field->v_field.bitlen);
d1215 4
a1218 3
				 field->v_field.bitpos & mask,
				 field->v_field.bitlen);
			aml_dump(blen>>3, iobuf);
d1221 2
a1222 2
				  iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
				  iobuf, mode);
d1592 1
d1595 1
d1612 2
a1613 1
		else if (rhs->type == AML_OBJTYPE_INTEGER || rhs->type == AML_OBJTYPE_STATICINT)
d1620 1
a1620 1
			//aml_showvalue(rhs);
@


1.79
log
@Fixed stupid bit mangling on index fields
Changed field read/write code for special case aligned, non-aligned read/write
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.78 2007/02/06 18:56:31 jordan Exp $ */
d98 3
d142 5
d151 1
d326 11
d340 1
a340 1
	int i;
d342 3
a344 3
	for (i = 0; i < sizeof(aml_table) / sizeof(aml_table[0]); i++)
		if (aml_table[i].opcode == opcode)
			return &aml_table[i];
a409 3

#define acpi_os_malloc(sz) _acpi_os_malloc(sz, __FUNCTION__, __LINE__)
#define acpi_os_free(ptr)  _acpi_os_free(ptr, __FUNCTION__, __LINE__)
@


1.78
log
@Added support for calling _OSI method
Display byte/word/string/nameref for aml_mnem function
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.77 2007/01/23 04:05:58 jordan Exp $ */
d1028 20
d1055 1
a1055 1
	struct aml_value *pop, *tmp;
d1057 1
d1064 5
d1073 4
d1078 9
a1086 1
		aml_fieldio(scope, field->v_field.ref2, res, mode);
d1090 4
d1095 9
a1103 1
		aml_fieldio(scope, field->v_field.ref2, res, mode);
d1127 5
d1139 64
a1215 40

		/* Allocate temporary space for field read
		 * XXX: not needed if aligned??
		 */
		tmp = aml_alloctmp(scope, 1);
		_aml_setvalue(tmp, AML_OBJTYPE_BUFFER, blen>>3, NULL);
		if (mode == ACPI_IOREAD) {
			/* Read from GAS space */
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
			    tmp->v_buffer, ACPI_IOREAD);
			aml_setbufint(res, field->v_field.bitpos & mask,
			    field->v_field.bitlen, tmp);
		} else {
			switch (AML_FIELD_UPDATE(field->v_field.flags)) {
			case AML_FIELD_WRITEASONES:
				if (!aligned) {
					dnprintf(50, "fpr:WriteOnes\n");
					memset(tmp->v_buffer, 0xff, tmp->length);
				}
				break;
			case AML_FIELD_PRESERVE:
				if (!aligned) {
					/* Non-aligned I/O: need to read current value */
					/* XXX: only need to read 1st/last mask chunk */
					dnprintf(50, "fpr:Preserve\n");
					aml_gasio(scope->sc,
					    pop->v_opregion.iospace, iobase,
					    pop->v_opregion.iolen, bpos, blen,
					    mask+1, tmp->v_buffer, ACPI_IOREAD);
				}
				break;
			}
			/* Copy Bits into destination buffer */
			aml_getbufint(res, field->v_field.bitpos & mask,
			    field->v_field.bitlen, tmp);
			aml_gasio(scope->sc, pop->v_opregion.iospace,
			    iobase, pop->v_opregion.iolen, bpos, blen, mask+1,
			    tmp->v_buffer, ACPI_IOWRITE);
		}
d1941 1
d3260 1
@


1.77
log
@Fixes for static integer setting
thanks to giovanni
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.76 2007/01/18 19:01:02 jordan Exp $ */
d103 2
d108 1
d329 1
a329 1
aml_mnem(int opcode)
d332 1
d334 26
a359 2
	if ((tab = aml_findopcode(opcode)) != NULL)
		return tab->mnem;
d560 1
a560 1
	    " base:%llx len:%llx bitpos:%.4x bitlen:%.4x sz:%.2x mode=%s\n",
a653 1
const char *aml_getname(const char *);
d1195 1
a1195 1
		    aml_mnem(val->v_field.type));
d1384 1
d1494 3
d1771 1
a1771 1
		 aml_mnem(opcode), lhs, rhs, res);
d1836 8
d1869 1
a1869 2
	while (scope->pos < scope->end)
		aml_parseterm(scope, res);
d1873 1
a1873 2
	while (scope->pos < scope->end)
		aml_parseterm(scope, res);
d2270 1
a2270 1
	    aml_nodename(scope->node), aml_mnem(opcode));
d2583 1
d2952 1
a2952 1
		aml_parseterm(scope, &tmparg[0]);
d3075 1
a3075 2
	    aml_nodename(scope->node), aml_mnem(opcode));

d3162 1
d3165 39
@


1.76
log
@Added fix for static integer
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.75 2007/01/16 21:21:28 marco Exp $ */
d1142 1
d1242 1
d1324 1
a1324 1
	switch (rval->type & ~AML_STATIC) {
d1326 1
d1349 1
a1349 1
	switch (lhs->type & ~AML_STATIC) {
d1351 1
d1401 1
d1465 1
a1465 1
	case AML_OBJTYPE_INTEGER+AML_STATIC:
d1477 1
a1477 1
		else if (rhs->type == AML_OBJTYPE_INTEGER)
d1498 1
a1498 1
		else if (rhs->type == AML_OBJTYPE_INTEGER) {
d1755 1
d1873 1
@


1.75
log
@Fix invalid _CRS length.  Some aml implementations lie about how long a
_CRS buffer is and this compensates for it by fixing up the minimum value.
This fixes several machines that end up with invalid irq/ioapic values.

KNF nit as well

Code from jordan, tested on Intel SHG2 board (he committed this agains my
local tree)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.74 2006/12/26 23:58:08 marco Exp $ */
d1749 1
a1749 1
		switch (lhs->type) {
@


1.74
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 2
/* $OpenBSD: dsdt.c,v 1.73 2006/12/23 17:19:06 canacar Exp $ */

d1641 1
a1641 1
	dnprintf(50, "evalexpr: %s %lld %lld\n", aml_mnem(opcode), lhs, rhs);
d1647 2
a1648 1
		return (lhs + rhs);
d1651 2
a1652 1
		return (lhs - rhs);
d1654 2
a1655 1
		return (lhs * rhs);
d1657 2
a1658 1
		return (lhs / rhs);
d1660 2
a1661 1
		return (lhs % rhs);
d1663 2
a1664 1
		return (lhs << rhs);
d1666 2
a1667 1
		return (lhs >> rhs);
d1669 2
a1670 1
		return (lhs & rhs);
d1672 2
a1673 1
		return ~(lhs & rhs);
d1675 2
a1676 1
		return (lhs | rhs);
d1678 2
a1679 1
		return ~(lhs | rhs);
d1681 2
a1682 1
		return (lhs ^ rhs);
d1684 2
a1685 1
		return ~(lhs);
d1689 2
a1690 1
		return aml_msb(lhs);
d1692 2
a1693 1
		return aml_lsb(lhs);
d1695 2
a1696 1
		return (lhs);
d1698 2
a1699 1
		return aml_convradix(lhs, 16, 10);
d1701 2
a1702 1
		return aml_convradix(lhs, 10, 16);
d1706 2
a1707 1
		return (lhs && rhs);
d1709 2
a1710 1
		return (lhs || rhs);
d1712 2
a1713 1
		return (!lhs);
d1715 2
a1716 1
		return (lhs != rhs);
d1718 2
a1719 1
		return (lhs <= rhs);
d1721 2
a1722 1
		return (lhs >= rhs);
d1724 2
a1725 1
		return (lhs == rhs);
d1727 2
a1728 1
		return (lhs > rhs);
d1730 2
a1731 1
		return (lhs < rhs);
d1734 4
a1737 1
	return (0);
d2071 3
a2073 2
		    "Bad scope... runover pos:%.4x new end:%.4x scope end:%.4x\n",
		    aml_pc(pos), aml_pc(pos+len), aml_pc(scope->end));
d3154 2
a3155 1
		printf("dma %.2x %.2x", crs->sr_dma.dma_chan, crs->sr_dma.dma_info);
d3180 1
a3180 1
	int off, rlen;
d3182 1
d3185 1
d3188 18
d3208 12
a3219 1
		//aml_print_resource(crs, NULL);
d3221 3
d3225 1
@


1.73
log
@Correctly compute timeout value in acpi_sleep.
Also make sure it is non zero. ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.72 2006/12/20 22:45:26 deraadt Exp $ */
d351 1
d551 9
d563 1
a563 1
		    int (*proc)(struct aml_node *, int, void *), void *arg)
d566 1
d575 1
d581 3
d610 9
@


1.72
log
@nearly complete knf
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.71 2006/12/20 18:27:49 deraadt Exp $ */
d405 2
d409 4
a412 2
	else
		while (tsleep(dsdt_softc, PWAIT, "asleep", ms / hz) !=
d414 1
@


1.71
log
@first steps of knf (trying not to step on jordan's feet too much); ok marco
@
text
@d1 2
a2 1
/* $OpenBSD: dsdt.c,v 1.70 2006/12/20 17:28:04 deraadt Exp $ */
d37 1
a37 1
#define opsize(opcode) (((opcode) &  0xFF00) ? 2 : 1)
d41 2
a42 2
#define AML_FIELD_RESERVED  0x00
#define AML_FIELD_ATTRIB    0x01
d44 3
a46 3
#define AML_REVISION	 0x01
#define AML_INTSTRLEN	 16
#define AML_NAMESEG_LEN	 4
a70 1
void			aml_dump(int, u_int8_t *);
d83 1
a83 1
#define aml_delref(x) _aml_delref(x,__FUNCTION__,__LINE__)
d104 1
a104 1
struct aml_value	*aml_evalmethod(struct aml_scope *,struct aml_node *,
d107 4
d112 1
a112 1
 * @@@@@@: Global variables 
d114 1
a114 1
int                     aml_intlen=64;
d116 2
a117 5
struct aml_value       *aml_global_lock;
struct acpi_softc      *dsdt_softc;

/* Perfect hash function for valid AML bytecodes */
#define HTE(v,a,b...)	{ v,a,b }
d137 4
d143 13
a155 13
	HTE(AMLOP_ZERO,		  "Zero",	     "c",      aml_parsesimple ),
	HTE(AMLOP_ONE,		  "One",	     "c",      aml_parsesimple ),
	HTE(AMLOP_ONES,		  "Ones",	     "c",      aml_parsesimple ),
	HTE(AMLOP_REVISION,	  "Revision",	     "R",      aml_parsesimple ),
	HTE(AMLOP_BYTEPREFIX,	  ".Byte",	     "b",      aml_parsesimple ),
	HTE(AMLOP_WORDPREFIX,	  ".Word",	     "w",      aml_parsesimple ),
	HTE(AMLOP_DWORDPREFIX,	  ".DWord",	     "d",      aml_parsesimple ),
	HTE(AMLOP_QWORDPREFIX,	  ".QWord",	     "q",      aml_parsesimple ),
	HTE(AMLOP_STRINGPREFIX,	  ".String",	     "a",      aml_parsesimple ),
	HTE(AMLOP_DEBUG,	  "DebugOp",	     "D",      aml_parsesimple ),
	HTE(AMLOP_BUFFER,	  "Buffer",	     "piB",    aml_parsebufpkg ),
	HTE(AMLOP_PACKAGE,	  "Package",	     "pbT",    aml_parsebufpkg ),
	HTE(AMLOP_VARPACKAGE,	  "VarPackage",	     "piT",    aml_parsebufpkg ),
d158 15
a172 15
	HTE(AMLOP_LOCAL0,	  "Local0",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL1,	  "Local1",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL2,	  "Local2",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL3,	  "Local3",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL4,	  "Local4",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL5,	  "Local5",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL6,	  "Local6",	     "L",      aml_parseref ),
	HTE(AMLOP_LOCAL7,	  "Local7",	     "L",      aml_parseref ),
	HTE(AMLOP_ARG0,		  "Arg0",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG1,		  "Arg1",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG2,		  "Arg2",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG3,		  "Arg3",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG4,		  "Arg4",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG5,		  "Arg5",	     "A",      aml_parseref ),
	HTE(AMLOP_ARG6,		  "Arg6",	     "A",      aml_parseref ),
d175 9
a183 9
	HTE(AMLOP_IF,		  "If",		     "pI",     aml_parseif ),
	HTE(AMLOP_ELSE,		  "Else",	     "pT" ),
	HTE(AMLOP_WHILE,	  "While",	     "piT",    aml_parsewhile ),
	HTE(AMLOP_BREAK,	  "Break",	     "" ),
	HTE(AMLOP_CONTINUE,	  "Continue",	     "" ),
	HTE(AMLOP_RETURN,	  "Return",	     "t",      aml_parseref ),
	HTE(AMLOP_FATAL,	  "Fatal",	     "bdi",    aml_parsemisc2 ),
	HTE(AMLOP_NOP,		  "Nop",	     "",       aml_parsesimple ),
	HTE(AMLOP_BREAKPOINT,	  "BreakPoint",	     "" ),
d186 17
a202 17
	HTE(AMLOP_INCREMENT,	  "Increment",	     "t",      aml_parsemath ),
	HTE(AMLOP_DECREMENT,	  "Decrement",	     "t",      aml_parsemath ),
	HTE(AMLOP_ADD,		  "Add",	     "iir",    aml_parsemath ),
	HTE(AMLOP_SUBTRACT,	  "Subtract",	     "iir",    aml_parsemath ),
	HTE(AMLOP_MULTIPLY,	  "Multiply",	     "iir",    aml_parsemath ),
	HTE(AMLOP_DIVIDE,	  "Divide",	     "iirr",   aml_parsemath ),
	HTE(AMLOP_SHL,		  "ShiftLeft",	     "iir",    aml_parsemath ),
	HTE(AMLOP_SHR,		  "ShiftRight",	     "iir",    aml_parsemath ),
	HTE(AMLOP_AND,		  "And",	     "iir",    aml_parsemath ),
	HTE(AMLOP_NAND,		  "Nand",	     "iir",    aml_parsemath ),
	HTE(AMLOP_OR,		  "Or",		     "iir",    aml_parsemath ),
	HTE(AMLOP_NOR,		  "Nor",	     "iir",    aml_parsemath ),
	HTE(AMLOP_XOR,		  "Xor",	     "iir",    aml_parsemath ),
	HTE(AMLOP_NOT,		  "Not",	     "ir",     aml_parsemath ),
	HTE(AMLOP_MOD,		  "Mod",	     "iir",    aml_parsemath ),
	HTE(AMLOP_FINDSETLEFTBIT, "FindSetLeftBit",  "ir",     aml_parsemath ),
	HTE(AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",     aml_parsemath ),
d205 9
a213 9
	HTE(AMLOP_LAND,		  "LAnd",	     "ii",     aml_parsemath ),
	HTE(AMLOP_LOR,		  "LOr",	     "ii",     aml_parsemath ),
	HTE(AMLOP_LNOT,		  "LNot",	     "i",      aml_parsemath ),
	HTE(AMLOP_LNOTEQUAL,	  "LNotEqual",	     "tt",     aml_parsecompare ),
	HTE(AMLOP_LLESSEQUAL,	  "LLessEqual",	     "tt",     aml_parsecompare ),
	HTE(AMLOP_LGREATEREQUAL,  "LGreaterEqual",   "tt",     aml_parsecompare ),
	HTE(AMLOP_LEQUAL,	  "LEqual",	     "tt",     aml_parsecompare ),
	HTE(AMLOP_LGREATER,	  "LGreater",	     "tt",     aml_parsecompare ),
	HTE(AMLOP_LLESS,	  "LLess",	     "tt",     aml_parsecompare ),
d216 13
a228 13
	HTE(AMLOP_NAMECHAR,	  ".NameRef",	     "n",      aml_parsesimple  ),
	HTE(AMLOP_ALIAS,	  "Alias",	     "nN",     aml_parsenamed ),
	HTE(AMLOP_NAME,		  "Name",	     "Nt",     aml_parsenamed ),
	HTE(AMLOP_EVENT,	  "Event",	     "N",      aml_parsenamed ),
	HTE(AMLOP_MUTEX,	  "Mutex",	     "Nb",     aml_parsenamed ),
	HTE(AMLOP_DATAREGION,	  "DataRegion",	     "Nttt",   aml_parsenamed ),
	HTE(AMLOP_OPREGION,	  "OpRegion",	     "Nbii",   aml_parsenamed ),
	HTE(AMLOP_SCOPE,	  "Scope",	     "pNT",    aml_parsenamedscope ),
	HTE(AMLOP_DEVICE,	  "Device",	     "pNT",    aml_parsenamedscope ),
	HTE(AMLOP_POWERRSRC,	  "Power Resource",  "pNbwT",  aml_parsenamedscope ),
	HTE(AMLOP_THERMALZONE,	  "ThermalZone",     "pNT",    aml_parsenamedscope ),
	HTE(AMLOP_PROCESSOR,	  "Processor",	     "pNbdbT", aml_parsenamedscope ),
	HTE(AMLOP_METHOD,	  "Method",	     "pNfM",   aml_parsemethod ),
d231 9
a239 9
	HTE(AMLOP_FIELD,	    "Field",	       "pnfF", aml_parsefieldunit ),
	HTE(AMLOP_INDEXFIELD,	    "IndexField",      "pntfF",aml_parsefieldunit ),
	HTE(AMLOP_BANKFIELD,	    "BankField",       "pnnifF",aml_parsefieldunit ),
	HTE(AMLOP_CREATEFIELD,	    "CreateField",     "tiiN", aml_parsebufferfield ),
	HTE(AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",  aml_parsebufferfield ),
	HTE(AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",  aml_parsebufferfield ),
	HTE(AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",  aml_parsebufferfield ),
	HTE(AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",  aml_parsebufferfield ),
	HTE(AMLOP_CREATEBITFIELD,   "CreateBitField",  "tiN",  aml_parsebufferfield ),
d242 8
a249 8
	HTE(AMLOP_TOINTEGER,	  "ToInteger",	     "tr",     aml_parsemath ),
	HTE(AMLOP_TOBUFFER,	  "ToBuffer",	     "tr",     ),
	HTE(AMLOP_TODECSTRING,	  "ToDecString",     "ir",     aml_parsestring ),
	HTE(AMLOP_TOHEXSTRING,	  "ToHexString",     "ir",     aml_parsestring ), 
	HTE(AMLOP_TOSTRING,	  "ToString",	     "t",      aml_parsestring ),
	HTE(AMLOP_MID,		  "Mid",	     "tiir",   aml_parsestring ),
	HTE(AMLOP_FROMBCD,	  "FromBCD",	     "ir",     aml_parsemath ),
	HTE(AMLOP_TOBCD,	  "ToBCD",	     "ir",     aml_parsemath ),
d252 24
a275 24
	HTE(AMLOP_ACQUIRE,	  "Acquire",	     "tw",     aml_parsemuxaction ),
	HTE(AMLOP_RELEASE,	  "Release",	     "t",      aml_parsemuxaction ),
	HTE(AMLOP_SIGNAL,	  "Signal",	     "t",      aml_parsemuxaction ),
	HTE(AMLOP_WAIT,		  "Wait",	     "ti",     aml_parsemuxaction ),
	HTE(AMLOP_RESET,	  "Reset",	     "t",      aml_parsemuxaction ),
 
	HTE(AMLOP_INDEX,	  "Index",	     "tir",    aml_parseref ),
	HTE(AMLOP_DEREFOF,	  "DerefOf",	     "t",      aml_parseref ),
	HTE(AMLOP_REFOF,	  "RefOf",	     "t",      aml_parseref ),
	HTE(AMLOP_CONDREFOF,	  "CondRef",	     "nr",     aml_parseref ),

	HTE(AMLOP_LOADTABLE,	  "LoadTable",	     "tttttt" ),
	HTE(AMLOP_STALL,	  "Stall",	     "i",      aml_parsemisc2 ),
	HTE(AMLOP_SLEEP,	  "Sleep",	     "i",      aml_parsemisc2 ),
	HTE(AMLOP_LOAD,		  "Load",	     "nt",     aml_parseref ),
	HTE(AMLOP_UNLOAD,	  "Unload",	     "t" ), 
	HTE(AMLOP_STORE,	  "Store",	     "tr",     aml_parseref ),
	HTE(AMLOP_CONCAT,	  "Concat",	     "ttr",    aml_parsestring ),
	HTE(AMLOP_CONCATRES,	  "ConcatRes",	     "ttt" ),
	HTE(AMLOP_NOTIFY,	  "Notify",	     "ti",     aml_parsemisc2 ),
	HTE(AMLOP_SIZEOF,	  "Sizeof",	     "t",      aml_parsemisc3 ),
	HTE(AMLOP_MATCH,	  "Match",	     "tbibii", aml_parsematch ),
	HTE(AMLOP_OBJECTTYPE,	  "ObjectType",	     "t",      aml_parsemisc3 ),
	HTE(AMLOP_COPYOBJECT,	  "CopyObject",	     "tr",     aml_parseref ),
a277 2
void _aml_die(const char *fn, int line, const char *fmt, ...);

d296 4
a299 3
	for (root=aml_lastscope; root && root->pos; root=root->parent) {
		printf("%.4x Called: %s\n", aml_pc(root->pos), aml_nodename(root->node));
		for (idx=0; idx<root->nargs; idx++) {
d303 1
a303 1
		for (idx=0; root->locals && idx < AML_MAX_LOCAL; idx++) {
a313 1
#define aml_die(x...) _aml_die(__FUNCTION__,__LINE__,x)
d371 1
a371 1
	
d378 1
a378 1
	dnprintf(99,"alloc: %x %s:%d\n", sptr, fn, line);
d397 1
a397 1
		dnprintf(99,"free: %x %s:%d\n", sptr, fn, line);
d407 1
a407 1
	else 
d493 1
a493 1
	
d524 1
a524 1
	  int bitpos, int bitlen, int size, void *buf, int mode)
d526 6
a531 4
  	dnprintf(10,"-- aml_gasio: %.2x base:%llx len:%llx bitpos:%.4x bitlen:%.4x sz:%.2x mode=%s\n",
		 type, base, length, bitpos, bitlen, size, mode==ACPI_IOREAD?"read":"write");
	acpi_gasio(sc, mode, type, base+(bitpos>>3), 
		   (size>>3), (bitlen>>3), buf);
d534 1
a534 1
		dnprintf(10,"%.2x ", *(uint8_t *)buf);
d538 1
a538 1
	dnprintf(10,"\n");
d553 1
a553 1
		 node->name, pnpid ? pnpid : "", proc);
d560 1
a560 1
	if (pnpid) 
d593 1
a593 1
 * @@@@@@: Namespace functions 
d607 1
a607 1
	for (root=root->child; root; root=root->sibling) {
d705 1
a705 1
			for (pp = &root->child; *pp; pp=&(*pp)->sibling)
d711 1
a711 1
		root  = node;
d798 11
a808 9
struct aml_value *aml_alloctmp(struct aml_scope *, int);
struct aml_scope *aml_pushscope(struct aml_scope *, uint8_t *, uint8_t *, struct aml_node *);
struct aml_scope *aml_popscope(struct aml_scope *);
int aml_parsenode(struct aml_scope *,struct aml_node *, uint8_t *, uint8_t **, struct aml_value *);

#define AML_LHS  0
#define AML_RHS  1
#define AML_DST  2
#define AML_DST2 3
d817 2
a818 2
	tmp = (struct aml_vallist *)acpi_os_malloc(sizeof(struct aml_vallist) + 
						   narg * sizeof(struct aml_value));
d833 2
a834 2
aml_pushscope(struct aml_scope *parent, uint8_t *start, uint8_t  *end, 
	      struct aml_node *node)
d864 1
a864 1
		for (idx=0; idx<ol->nobj; idx++) {
d877 2
a878 2
aml_parsenode(struct aml_scope *parent, struct aml_node *node, uint8_t *start, uint8_t **end, 
	      struct aml_value *res)
d907 2
a908 2
aml_setbufint(struct aml_value *dst, int bitpos, int bitlen, 
	      struct aml_value *src)
d912 1
a912 1
	
d933 2
a934 2
aml_getbufint(struct aml_value *src, int bitpos, int bitlen, 
	      struct aml_value *dst)
d940 1
a940 1
	  	if (bitlen >= aml_intlen)
d950 1
a950 1
		if (bitlen >= 8*src->length) 
d973 1
a973 1
/* 
d977 2
a978 2
aml_fieldio(struct aml_scope *scope, struct aml_value *field, 
	    struct aml_value *res, int mode)
d1025 2
a1026 2
		aligned = (bpos == field->v_field.bitpos && 
			   blen == field->v_field.bitlen);
d1031 5
a1035 2
		/* XXX: some I/O ranges are on dword boundaries, but their length is incorrect
		 * eg. dword access, but length of opregion is 2 bytes. */
d1038 2
a1039 4
				pop->v_opregion.iospace,
				pop->v_opregion.iobase,
				pop->v_opregion.iolen,
				bpos+blen);
d1051 2
a1052 4
				  iobase, pop->v_opregion.iolen,
				  bpos, blen, mask+1,
				  tmp->v_buffer,
				  ACPI_IOREAD);
d1054 1
a1054 1
				      field->v_field.bitlen, tmp);
d1059 1
a1059 1
					dnprintf(50,"fpr:WriteOnes\n");
d1067 5
a1071 7
					dnprintf(50,"fpr:Preserve\n");
					aml_gasio(scope->sc, pop->v_opregion.iospace,
						  iobase, 
						  pop->v_opregion.iolen,
						  bpos, blen, mask+1,
						  tmp->v_buffer,
						  ACPI_IOREAD);
d1077 1
a1077 2
				      field->v_field.bitlen,
				      tmp);
d1079 2
a1080 5
				  iobase,
				  pop->v_opregion.iolen,
				  bpos, blen, mask+1,
				  tmp->v_buffer,
				  ACPI_IOWRITE);
d1099 2
a1100 2
#define aml_dereftarget(s,v)  aml_derefvalue(s,v,ACPI_IOWRITE)
#define aml_derefterm(s,v,m)  aml_derefvalue(s,v,ACPI_IOREAD)
d1109 2
a1110 2
  
	if (val->node) {
a1111 1
	}
d1125 1
a1125 1
		for (idx=0; idx<val->length; idx++)
d1130 1
a1130 1
		for (idx=0; idx<val->length; idx++)
d1136 4
a1139 4
		printf(" field: bitpos=%.4x bitlen=%.4x ref1:%x ref2:%x [%s]\n", 
			 val->v_field.bitpos, val->v_field.bitlen,
			 val->v_field.ref1, val->v_field.ref2, 
			 aml_mnem(val->v_field.type));
d1153 2
a1154 3
			 val->v_opregion.iospace,
			 val->v_opregion.iobase,
			 val->v_opregion.iolen);
d1163 3
a1165 3
		printf(" cpu: %.2x,%.4x,%.2x\n", 
			 val->v_processor.proc_id, val->v_processor.proc_addr,
			 val->v_processor.proc_len);
d1171 2
a1172 3
		printf(" pwrrsrc: %.2x,%.2x\n", 
			 val->v_powerrsrc.pwr_level, 
			 val->v_powerrsrc.pwr_order);
d1175 2
a1176 1
		printf(" objref: %p index:%x\n", val->v_objref.ref, val->v_objref.index);
d1201 1
a1201 1
			
d1207 2
a1208 1
					aml_die("index.buf out of bounds: %d/%d\n", index, ref->length);
d1218 2
a1219 1
					_aml_setvalue(ref, AML_OBJTYPE_BUFFER, aml_intlen>>3, &tmpint);
d1226 5
a1230 2
						/* Shortcut: return integer contents of buffer at index */
						_aml_setvalue(tmp, AML_OBJTYPE_INTEGER, ref->v_buffer[index], NULL);
d1232 5
a1236 2
						_aml_setvalue(tmp, AML_OBJTYPE_BUFFERFIELD, 0, NULL);
						tmp->v_field.type = AMLOP_CREATEBYTEFIELD;
d1249 1
a1249 1
			
d1254 1
a1254 1
			for (index=0; index<argc; index++) {
d1260 1
a1260 1
			
d1270 1
a1270 1
			
d1274 1
a1274 1
	
d1291 1
a1291 1
		dnprintf(50,"null val2int\n");
d1299 2
a1300 2
		aml_bufcpy(&ival, 0, rval->v_buffer, 0, 
			   min(aml_intlen, rval->length*8));
d1304 2
a1305 2
			aml_str2int(rval->v_string+2, 16) :
			aml_str2int(rval->v_string, 10);
d1349 5
a1353 3
		lhs->v_package = (struct aml_value **)acpi_os_malloc(ival * sizeof(struct aml_value *));
		for (ival=0; ival<lhs->length; ival++)
			lhs->v_package[ival] = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
d1390 1
a1390 1
		for (idx=0; idx<rhs->length; idx++)
d1404 2
a1405 2
aml_setvalue(struct aml_scope *scope, struct aml_value *lhs, 
	     struct aml_value *rhs, int64_t ival)
d1429 2
a1430 2
	  	printf("-- debug --\n");
	        aml_showvalue(rhs, 50);
d1439 1
a1439 1
			dnprintf(40,"named.buffer\n");
d1453 1
a1453 1
		}	
d1457 1
a1457 1
			dnprintf(40,"named string\n");
d1476 1
a1476 1
		dnprintf(10,"setvalue.unknown: %x", lhs->type);
d1487 1
a1487 1
aml_allocvalue(int type, int64_t ival, const void *bval) 
d1503 1
a1503 1
	
d1514 1
a1514 1
		for (idx=0; idx<val->length; idx++) {
d1534 1
a1534 1
	if (val) 
d1543 1
a1543 1
  	if (val == NULL || *val == NULL)
d1549 2
a1550 3
	if ((*val)->refcnt & ~0xFF) {
	  printf("-- invalid ref: %x:%s:%d\n", (*val)->refcnt, fn, line);
	}
d1559 1
a1559 1
 * @@@@@@: Math eval routines 
d1564 1
a1564 1
u_int64_t 
d1585 1
a1585 1
	if (val == 0) 
d1600 1
a1600 1
	if (val == 0) 
d1638 1
a1638 1
		return (lhs | rhs); 
d1640 1
a1640 1
		return ~(lhs | rhs); 
d1690 1
a1690 1
	if (lt == rt ) {
d1696 2
a1697 1
			rc = strncmp(lhs->v_string, rhs->v_string, min(lhs->length, rhs->length));
d1702 2
a1703 1
			rc = memcmp(lhs->v_buffer, rhs->v_buffer, min(lhs->length, rhs->length));
d1723 1
a1723 2
aml_bufcpy(void *pvDst, int dstPos, const void *pvSrc, int srcPos,
	   int len)
d1731 2
a1732 1
		memcpy(pDst+aml_bytepos(dstPos), pSrc+aml_bytepos(srcPos), aml_bytelen(len));
d1748 1
a1748 2
	       int argc, struct aml_value *argv,
	       struct aml_value *res)
d1752 2
a1753 2
	scope = aml_pushscope(parent, node->value->v_method.start, 
			      node->value->v_method.end, node);
d1760 3
a1762 4
	dnprintf(10,"calling [%s] (%d args)\n",
		 aml_nodename(node),
		 scope->nargs);
	for (argc=0; argc<scope->nargs; argc++) {
d1781 1
a1781 1
/* 
d1789 1
a1789 2
	     int argc, struct aml_value *argv,
	     struct aml_value *res)
d1804 2
a1805 2
			dnprintf(10,"Leaked: [%s] %d\n", 
				 aml_nodename(node), acpi_nalloc);
d1844 1
a1844 2
	     int argc, struct aml_value *argv,
	     struct aml_value *res)
d1850 2
a1851 3
aml_evalinteger(struct acpi_softc *sc, struct aml_node *parent, const char *name,
		int argc, struct aml_value *argv,
		int64_t *ival)
d1854 2
a1855 2
	
	if (name != NULL) {
a1856 1
	}
d1867 1
a1867 2
	      int (*nodecb)(struct aml_node *, void *),
	      void *arg)
d1875 1
a1875 1
	for (child=node->child; child; child=child->sibling)
d1884 1
a1884 1
	while(node) {
d1899 1
a1899 2
	      void (*cbproc)(struct aml_node *, void *arg),
	      void *arg)
d1921 2
a1922 2
int      aml_parselength(struct aml_scope *);
int      aml_parseopcode(struct aml_scope *);
d1928 1
a1928 1
	int opcode =  (scope->pos[0]);
d1941 2
a1942 5
	if (twocode == AMLOP_LNOTEQUAL ||
	    twocode == AMLOP_LLESSEQUAL ||
	    twocode == AMLOP_LGREATEREQUAL ||
	    opcode == AMLOP_EXTPREFIX)
	{
d1995 2
a1996 1
		len += (scope->pos[1]<<4L) + (scope->pos[2]<<12L) + (scope->pos[3]<<20L);
d2012 3
a2014 2
		dnprintf(10,"Bad scope... runover pos:%.4x new end:%.4x scope end:%.4x\n", 
		       aml_pc(pos), aml_pc(pos+len), aml_pc(scope->end));
d2023 4
a2026 4
int  aml_match(int, int64_t, struct aml_value *);
void aml_fixref(struct aml_value **);
int64_t aml_parseint(struct aml_scope *, int);
void aml_resize(struct aml_value *val, int newsize);
d2090 1
a2090 2
		dnprintf(20,"got _adr [%s]\n", 
			 aml_nodename(root));
d2092 2
a2093 2
	  /* Mark invalid */
	  	pciaddr += (0xFFFF << 16L);
d2101 1
a2101 2
		dnprintf(20,"got _bbn [%s]\n", 
		       aml_nodename(root));
d2103 1
a2103 1
	dnprintf(20,"got pciaddr: %s:%llx\n", aml_nodename(root), pciaddr);
d2113 2
a2114 4
	while (*res && 
	       (*res)->type == AML_OBJTYPE_OBJREF && 
	       (*res)->v_objref.index == -1) 
	{
d2128 1
a2128 1
	
d2166 2
a2167 5
	dnprintf(15,"%.4x: [%s] %s\n", 
		 aml_pc(scope->pos-opsize(opcode)), 
		 aml_nodename(scope->node),
		 aml_mnem(opcode));

d2178 2
a2179 2
aml_evalterm(struct aml_scope *scope, struct aml_value *raw, 
	     struct aml_value *dst)
d2236 5
a2240 6
			res->v_opregion.iobase += aml_getpciaddr(dsdt_softc, 
								 scope->node);
			dnprintf(20,"got ioaddr: %s.%s:%llx\n",
				 aml_nodename(scope->node),
				 aml_getname(name),
				 res->v_opregion.iobase);
d2328 1
a2328 1
		aml_parsetarget(scope, tmparg, NULL);  // remainder
d2331 1
a2331 1
		aml_parsetarget(scope, tmparg, NULL);   // quotient
d2423 1
a2423 1
	dnprintf(40,"Set While end : %x\n", cnt);
d2438 1
a2438 1
	len = aml_parseint(scope, (opcode == AMLOP_PACKAGE) ? 
d2448 1
a2448 1
			dnprintf(99,"buffer: %.4x %.4x\n", len, end-scope->pos);
d2454 1
a2454 1
		for (len=0; len < res->length && scope->pos < end; len++) {
d2458 1
a2458 1
			dnprintf(99,"Package not equiv!! %.4x %.4x %d of %d\n", 
d2496 1
a2496 1
		_aml_setvalue(res, AML_OBJTYPE_INTEGER+AML_STATIC, 
d2506 1
a2506 1
		_aml_setvalue(res, AML_OBJTYPE_INTEGER, 
d2523 1
a2523 1
	}  
d2595 2
a2596 2
aml_parsebufferfield(struct aml_scope *scope, int opcode, 
		     struct aml_value *res)
d2696 1
a2696 1
			dnprintf(10,"Notify: [%s] %.2x\n", 
d2703 1
a2703 1
		dnprintf(50,"SLEEP: %x\n", i1);
d2712 1
a2712 1
		dnprintf(50,"STALL: %x\n", i1);
d2767 1
a2767 1
		if (aml_match(op1, mv1, pkg->v_package[idx]) || 
d2791 1
a2791 1
	
d2811 1
a2811 1
		
d2813 1
a2813 1
		_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, 
d2890 1
a2890 1
			       tmpval[AML_RHS].v_buffer, tmpval[AML_RHS].length);
d2912 2
a2913 2
		snprintf(res->v_string, res->length, ((opcode == AMLOP_TODECSTRING) ? 
						      "%d" : "%x"), i1);
d2938 2
a2939 1
aml_parsetarget(struct aml_scope *scope, struct aml_value *res, struct aml_value **opt)
d2970 1
a2970 1
	dnprintf(15,"%.4x: [%s] %s\n",  aml_pc(scope->pos-opsize(opcode)), 
d2980 1
a2980 1
		aml_die("Unknown opcode: %.4x @@ %.4x", opcode, 
a3001 1

d3009 2
a3010 3
	int      offset;
	u_int8_t oldv;
	u_int8_t newv;
d3017 1
a3017 3
	const char       *oem;
	const char       *oemtbl;
	u_int8_t          cksum;
d3019 1
d3021 1
a3021 1
	{ "IBM   ", "CDTPWSNH", 0x41, __ibm300gl },
d3032 1
a3032 1
	for (fixlist=amlfix_list; fixlist->oem; fixlist++) {
d3037 2
a3038 1
			for (fixtab = fixlist->fixtab; fixtab->offset != -1; fixtab++) {
d3050 5
a3054 5
	const char        *name;
	int                type;
	int64_t            ival;
	const void        *bval;
	struct aml_value **gval;
d3058 1
a3058 1
	{ "_GL",  AML_OBJTYPE_MUTEX,   1, NULL, &aml_global_lock },
d3083 1
a3083 1
  
d3123 1
a3123 1
	for (off=0; off<length; off += rlen+1) {
d3154 1
a3154 1
 * Walk nodes and perform fixups for nameref 
d3170 1
a3170 1
			_aml_setvalue(val, AML_OBJTYPE_OBJREF, -1, 
d3177 1
a3177 1
		if (val->v_opregion.iospace != GAS_PCI_CFG_SPACE) 
d3181 1
a3181 1
		val->v_opregion.iobase = 
d3184 1
a3184 1
		dnprintf(20,"late ioaddr : %s:%llx\n",
@


1.70
log
@skip the perfect hash for now since it wastes a lot of kernel memory,
and fails to fit onto the floppies.  for now, do a linear search, but
someone should sort the instructions and use bsearch; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.69 2006/12/18 18:36:05 deraadt Exp $ */
d55 9
a63 8
/* New jordan code */
int                     aml_cmpvalue(struct aml_value *, struct aml_value *, int);
void                    aml_copyvalue(struct aml_value *, struct aml_value *);

void                    aml_setvalue(struct aml_scope *, struct aml_value *, struct aml_value *, int64_t);
void                    aml_freevalue(struct aml_value *);
struct aml_value       *aml_allocvalue(int, int64_t, const void *);
struct aml_value       *_aml_setvalue(struct aml_value *, int, int64_t, const void *);
d67 1
a67 1
int     		aml_lsb(u_int64_t);
d70 12
a81 13
void                    aml_dump(int, u_int8_t *);
int                     aml_tstbit(const u_int8_t *, int);
void                    aml_setbit(u_int8_t *, int, int);

void                    aml_bufcpy(void *, int, const void *, int, int);
int aml_evalinteger(struct acpi_softc *, struct aml_node *, const char *,
		    int, struct aml_value *, int64_t *);

void _aml_delref(struct aml_value **val, const char *, int);

void aml_delref(struct aml_value **);
void aml_addref(struct aml_value *);
int aml_pc(uint8_t *);
d85 18
a102 9
struct aml_value *aml_parseop(struct aml_scope *, struct aml_value *);
struct aml_value *aml_parsetarget(struct aml_scope *, struct aml_value *, struct aml_value **);
struct aml_value *aml_parseterm(struct aml_scope *, struct aml_value *);

struct aml_value *aml_evaltarget(struct aml_scope *scope, struct aml_value *res);
int aml_evalterm(struct aml_scope *scope, struct aml_value *raw, struct aml_value *dst);

void aml_gasio(struct acpi_softc *, int, uint64_t, uint64_t,
	       int, int, int, void *, int);
d104 2
a105 8
struct aml_opcode      *aml_findopcode(int);

void *_acpi_os_malloc(size_t, const char *, int);
void  _acpi_os_free(void *, const char *, int);
void acpi_sleep(int);
void acpi_stall(int);

struct aml_value *aml_evalmethod(struct aml_scope *,struct aml_node *, int, struct aml_value *, struct aml_value *);
d343 1
a343 2
struct aml_notify_data
{
d353 2
a354 2
struct aml_notify_head		aml_notify_list =
SLIST_HEAD_INITIALIZER(&aml_notify_list);
d365 1
a365 2
struct acpi_memblock
{
d916 1
a916 2
	}
	else {
d1049 1
a1049 2
		}
		else {
d1228 1
a1228 2
					}
					else {
d1434 2
a1435 1
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, rhs->length, rhs->v_buffer);
d1437 2
a1438 2
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, sizeof(rhs->v_integer),
				      &rhs->v_integer);
d1440 2
a1441 1
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, rhs->length+1, rhs->v_string);
d1452 2
a1453 1
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length, rhs->v_string);
d1455 2
a1456 1
			_aml_setvalue(lhs, AML_OBJTYPE_STRING, rhs->length, rhs->v_buffer);
d1459 3
a1461 3
			snprintf(lhs->v_string, lhs->length, "%lld", rhs->v_integer);
		}
		else {
d1699 1
a1699 2
	}
	else if (lt == AML_OBJTYPE_INTEGER) {
d1701 1
a1701 2
	}
	else if (rt == AML_OBJTYPE_INTEGER) {
d1703 1
a1703 2
	}
	else {
d2092 1
a2092 2
	}
	else {
d2420 1
a2420 2
		}
		else if (*scope->pos == AMLOP_BREAK) {
d2423 1
a2423 2
		}
		else if (*scope->pos == AMLOP_CONTINUE) {
d2425 1
a2425 2
		}
		else {
d2447 1
a2447 1
			   AMLOP_BYTEPREFIX : AML_ANYINT);
d2467 1
a2467 1
				 aml_pc(scope->pos), aml_pc(end), len, res->length);
d2505 1
a2505 2
			      aml_parseint(scope, opcode), 
			      NULL);
d2515 1
a2515 2
			      aml_parseint(scope, opcode), 
			      NULL);
d2528 1
a2528 1
		if (node && node->value) {
a2529 1
		}
d2705 1
a2705 1
				 aml_nodename(dev->node), i1);
d2776 1
a2776 2
		    aml_match(op2, mv2, pkg->v_package[idx])) 
		{
d2822 1
a2822 1
			      &scope->args[opcode]);
d2835 1
a2835 1
			      &scope->locals[opcode]);
d2862 1
a2862 2
		}
		else {
d2887 2
a2888 1
			aml_resize(&tmpval[AML_LHS], tmpval[AML_LHS].length+tmpval[AML_RHS].length);
d2895 2
a2896 1
			aml_resize(&tmpval[AML_LHS], tmpval[AML_LHS].length+tmpval[AML_RHS].length);
d2900 1
a2900 2
		}
		else {
d2973 1
a2973 1
	  panic("depth");
d2977 2
a2978 4
	dnprintf(15,"%.4x: [%s] %s\n", 
		 aml_pc(scope->pos-opsize(opcode)), 
		 aml_nodename(scope->node),
		 aml_mnem(opcode));
d2985 1
a2985 2
	}
	else {
d2988 1
a2988 1
			 aml_pc(scope->pos - opsize(opcode)));
d3016 1
a3016 2
struct aml_fixup
{
d3020 3
d3025 1
a3025 2
struct aml_blacklist
{
d3030 1
a3030 8
};

struct aml_fixup __ibm300gl[] = {
	{ 0x19, 0x3a, 0x3b },
	{ -1 }
};

struct aml_blacklist amlfix_list[] = {
d3045 1
a3045 2
		    fixlist->cksum == hdr->checksum)
		{
d3058 1
a3058 2
struct aml_defval
{
d3064 1
a3064 3
};

struct aml_defval aml_defobj[] = {
d3096 2
a3097 3
		       crs->lr_extirq.flags,
		       crs->lr_extirq.irq_count,
		       aml_letohost32(crs->lr_extirq.irq[0]));
d3100 2
a3101 3
		printf("irq %.4x %.2x",
		       aml_letohost16(crs->sr_irq.irq_mask),
		       crs->sr_irq.irq_info);
d3108 3
a3110 5
		       crs->sr_ioport.io_info,
		       crs->sr_ioport.io_min,
		       crs->sr_ioport.io_max,
		       crs->sr_ioport.io_aln,
		       crs->sr_ioport.io_len);
d3127 1
a3127 2
		   int (*crs_enum)(union acpi_resource *, void *),
		   void *arg)
d3180 1
a3180 1
				      node->value);
d3182 2
a3183 3
	}
	else if (val->type == AML_OBJTYPE_PACKAGE) {
		for (i=0; i<val->length; i++)
d3185 1
a3185 2
	}
	else if (val->type == AML_OBJTYPE_OPREGION) {
d3191 4
a3194 5
			ACPI_PCI_REG(val->v_opregion.iobase) +
			aml_getpciaddr(dsdt_softc, node);
			dnprintf(20,"late ioaddr : %s:%llx\n",
				 aml_nodename(node),
				 val->v_opregion.iobase);
a3203 1

@


1.69
log
@our panic() can take stdarg arguments
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.68 2006/12/12 16:59:52 tom Exp $ */
d113 1
a113 6
#define HASH_OFF         6904
#define HASH_SIZE        179
#define HASH_KEY(k)      (((k) ^ HASH_OFF) % HASH_SIZE)

#define HASH_MAGIC(v)   (0xC0DE0000L + (v))
#define HTE(v,f...)     [ HASH_KEY(v) ] { HASH_MAGIC(v), f }
d312 1
a312 1
	struct aml_opcode *tab;
d314 3
a316 3
	tab = &aml_table[HASH_KEY(opcode)];
	if (tab->opcode == HASH_MAGIC(opcode))
		return tab;
@


1.68
log
@- include <sys/proc.h> for tsleep();
- change the defs of LHS, RHS, DST and DST2 to be AML_*.

Noted by Marco S Hyman on misc@@, these allow ACPI to be compiled into
RAMDISK kernels.  Suggestion for AML_ rename (to avoid name clash with
TIMEZONE's DST, which was noted by someone else a while ago, but I
forget who) from jordan@@.

ok marco@@, jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.67 2006/11/29 22:17:07 marco Exp $ */
a286 1
	char tmpbuf[256];
d310 1
a310 2
	snprintf(tmpbuf,sizeof(tmpbuf),"aml_die %s:%d ", fn, line);
	panic(tmpbuf);
@


1.67
log
@After a long debate at the hackathon it was decided that the acpi implementation
is not concurrent if the sensors thread goes away.  This makes acpi completly
lockless.

help and ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.66 2006/11/27 23:43:47 jordan Exp $ */
d22 1
d804 4
a807 4
#define LHS  0
#define RHS  1
#define DST  2
#define DST2 3
d2371 2
a2372 2
	aml_parseterm(scope, &tmparg[LHS]);
	aml_parseterm(scope, &tmparg[RHS]);
d2375 1
a2375 1
	rc = aml_cmpvalue(&tmparg[LHS], &tmparg[RHS], opcode);
d2899 16
a2914 16
		aml_parseterm(scope, &tmpval[LHS]);
		aml_parseterm(scope, &tmpval[RHS]);
		aml_parsetarget(scope, &tmpval[DST], NULL);
		if (tmpval[LHS].type == AML_OBJTYPE_BUFFER &&
		    tmpval[RHS].type == AML_OBJTYPE_BUFFER) {
			aml_resize(&tmpval[LHS], tmpval[LHS].length+tmpval[RHS].length);
			memcpy(&tmpval[LHS].v_buffer+tmpval[LHS].length,
			    tmpval[RHS].v_buffer, tmpval[RHS].length);
			aml_setvalue(scope, &tmpval[DST], &tmpval[LHS], 0);
		}
		if (tmpval[LHS].type == AML_OBJTYPE_STRING &&
		    tmpval[RHS].type == AML_OBJTYPE_STRING) {
			aml_resize(&tmpval[LHS], tmpval[LHS].length+tmpval[RHS].length);
			memcpy(&tmpval[LHS].v_string+tmpval[LHS].length,
			       tmpval[RHS].v_buffer, tmpval[RHS].length);
			aml_setvalue(scope, &tmpval[DST], &tmpval[LHS], 0);
@


1.66
log
@Post-process PCI config space opregions
Fixed acpiprt for stinky presario v3000
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.65 2006/11/27 15:17:37 jordan Exp $ */
d423 5
d457 1
d463 2
d484 1
d2232 1
a2676 1

@


1.65
log
@Added support for parsing _CRS resources
Post-parsing fixup for forward name references
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.64 2006/11/25 18:24:54 marco Exp $ */
d2091 5
d2243 4
d3159 1
a3159 1
		if (rlen == 0)
d3210 12
@


1.64
log
@Add mutex.

prodded dlg, ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.63 2006/11/11 19:26:01 marco Exp $ */
a34 5
/* XXX: endian macros */
#define aml_letohost16(x) x
#define aml_letohost32(x) x
#define aml_letohost64(x) x

a89 1
const char *aml_nodename(struct aml_node *);
a93 1

d519 1
a519 1
  	dnprintf(15,"-- aml_gasio: %.2x base:%llx len:%llx bitpos:%.4x bitlen:%.4x sz:%.2x mode=%s\n",
d617 1
d619 1
a619 1
	return namebuf+1;
d930 2
d935 2
d940 2
d972 1
d1017 1
d1040 1
a1040 2
				  pop->v_opregion.iobase,
				  pop->v_opregion.iolen,
d1061 1
a1061 1
						  pop->v_opregion.iobase,
d1074 1
a1074 1
				  pop->v_opregion.iobase,
a1104 5
#if ACPI_DEBUG
	if (lvl < acpi_debug)
		return;
#endif

d1293 1
a1293 1
			   min(aml_intlen*8, rval->length*8));
a1410 1

d1420 2
a1421 1
		aml_showvalue(rhs, 50);
d1861 17
d2074 2
d2091 1
d2099 1
a2099 1
	dnprintf(20,"got pciaddr: %llx\n", pciaddr);
a2199 1
	u_int64_t pci_addr;
d2236 2
a2237 4
			pci_addr = aml_getpciaddr(dsdt_softc,
						  scope->node);
			
			res->v_opregion.iobase += pci_addr;
d2959 2
d2967 4
d2979 2
d2982 10
a2991 6
	if (htab && htab->handler)
		return htab->handler(scope, opcode, res);

	/* No opcode handler */
	aml_die("Unknown opcode: %.4x @@ %.4x", opcode, aml_pc(scope->pos - opsize(opcode)));
	return NULL;
d3099 60
d3175 34
@


1.63
log
@Add acpi_sleep and acpi_stall functions.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.62 2006/10/31 13:49:44 thib Exp $ */
d53 1
a53 2
#define acpi_mutex_acquire(ctx,lock,iv)	 dnprintf(60,"ACQUIRE: %x" #lock "\n", (short)iv)
#define acpi_mutex_release(ctx,lock)	 dnprintf(60,"RELEASE: " #lock "\n")
d55 1
a55 1
#define aml_ipaddr(n) ((n)-aml_root.start)
a413 2
	extern int hz;

d427 58
d1147 3
a1149 1
		printf(" mutex: %llx\n", val->v_integer);
d2185 1
d2204 10
a2213 1
		res->v_integer = aml_parseint(scope, AMLOP_BYTEPREFIX);
d2634 1
d2644 1
d2647 1
a2647 1
		aml_setvalue(scope, res, NULL, 0);
d2650 1
@


1.62
log
@add missing prototype for aml_evalinteger()
ok macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.61 2006/10/30 18:37:07 jordan Exp $ */
d106 2
d412 18
d2607 1
d2624 6
a2629 1
		dnprintf(10,"SLEEP: %x\n", i1);
d2633 6
a2638 1
		dnprintf(10,"STALL: %x\n", i1);
@


1.61
log
@Fix nameref -> objref for forward definition evaluator
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.60 2006/10/25 21:23:19 jordan Exp $ */
d79 2
@


1.60
log
@Don't convert buffer/field output to integer
Caused problems with strings/index on some systems
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.59 2006/10/25 20:55:47 jordan Exp $ */
d1709 1
d1741 8
d1765 18
@


1.59
log
@added deref/index for integer types
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.58 2006/10/24 19:01:48 jordan Exp $ */
d830 6
d847 1
@


1.58
log
@Added stack trace to aml_die+acpidebug
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.57 2006/10/23 20:23:26 jordan Exp $ */
d1108 1
d1130 7
d1231 1
d1280 1
a1280 1
		lhs->v_integer = rhs->v_integer;
d1295 1
a1295 1
		lhs->v_nameref = rhs->v_nameref;
@


1.57
log
@Reduced memory allocations for temporary values
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.56 2006/10/19 07:02:20 jordan Exp $ */
a50 3
#define AML_MAX_ARG	 8
#define AML_MAX_LOCAL	 8

d94 1
a94 1

d105 1
a105 1
struct aml_value *aml_evalmethod(struct aml_node *, int, struct aml_value *, struct aml_value *);
d285 2
d289 2
d292 1
a292 1
	char tmpbuf[256];
a294 1
	snprintf(tmpbuf,sizeof(tmpbuf),"aml_die %s:%d ", fn, line);
d299 14
d314 1
a519 1
const char *aml_nodename(struct aml_node *);
d721 1
a721 1
int aml_parsenode(struct aml_node *, uint8_t *, uint8_t **, struct aml_value *);
d763 2
d789 2
d795 1
a795 1
aml_parsenode(struct aml_node *node, uint8_t *start, uint8_t **end, 
d803 1
a803 1
	scope = aml_pushscope(NULL, start, *end, node);
d806 1
a806 1
	while (scope != NULL) {
d1020 5
d1029 1
a1029 1
		dnprintf(lvl," [%s]", aml_nodename(val->node));
d1031 1
a1031 1
	dnprintf(lvl," %p cnt:%.2x", val, val->refcnt);
d1034 1
a1034 1
		dnprintf(lvl," integer: %llx\n", val->v_integer);
d1037 1
a1037 1
		dnprintf(lvl," string: %s\n", val->v_string);
d1040 1
a1040 1
		dnprintf(lvl," method: %.2x\n", val->v_method.flags);
d1043 1
a1043 1
		dnprintf(lvl," package: %.2x\n", val->length);
d1048 1
a1048 1
		dnprintf(lvl," buffer: %.2x {", val->length);
d1050 2
a1051 2
			dnprintf(lvl,"%s%.2x", idx ? ", " : "", val->v_buffer[idx]);
		dnprintf(lvl,"}\n");
d1055 1
a1055 1
		dnprintf(lvl," field: bitpos=%.4x bitlen=%.4x ref1:%x ref2:%x [%s]\n", 
d1063 1
a1063 1
		dnprintf(lvl," mutex: %llx\n", val->v_integer);
d1066 1
a1066 1
		dnprintf(lvl," event:\n");
d1069 1
a1069 1
		dnprintf(lvl," opregion: %.2x,%.8llx,%x\n",
d1075 1
a1075 1
		dnprintf(lvl," nameref: %s\n", aml_getname(val->v_nameref));
d1078 1
a1078 1
		dnprintf(lvl," device:\n");
d1081 1
a1081 1
		dnprintf(lvl," cpu: %.2x,%.4x,%.2x\n", 
d1086 1
a1086 1
		dnprintf(lvl," thermzone:\n");
d1089 1
a1089 1
		dnprintf(lvl," pwrrsrc: %.2x,%.2x\n", 
d1094 1
a1094 1
		dnprintf(lvl," objref: %p index:%x\n", val->v_objref.ref, val->v_objref.index);
d1098 1
a1098 1
		dnprintf(lvl," !!type: %x\n", val->type);
d1161 1
a1161 1
			ref = aml_evalmethod(ref->node, argc, tmp, &tmp[argc]);
d1645 1
a1645 1
aml_evalmethod(struct aml_node *node,
d1651 1
a1651 1
	scope = aml_pushscope(NULL, node->value->v_method.start, 
d1701 1
a1701 1
		aml_evalmethod(node, argc, argv, res);
d2135 1
a2135 1
	aml_parsenode(node, scope->pos, &end, NULL);
d2651 1
a2651 4
		while (scope) {
			scope->pos = scope->end;
			scope = scope->parent;
		}
d2940 1
a2940 1
	aml_parsenode(&aml_root, start, &end, NULL);
@


1.56
log
@Fixed AML debugger code to use new interface
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.55 2006/10/19 03:24:45 jordan Exp $ */
d2125 1
a2126 2
	tmparg = aml_alloctmp(scope, 4);

d2145 1
a2145 1
		aml_parsetarget(scope, &tmparg[DST], NULL);
d2149 2
a2150 3
		aml_parsetarget(scope, &tmparg[DST], NULL);
		aml_evalterm(scope, &tmparg[DST], &tmparg[LHS]);
		i1 = aml_val2int(&tmparg[LHS]);
a2155 2
		aml_parsetarget(scope, &tmparg[DST2], NULL);  // remainder
		aml_parsetarget(scope, &tmparg[DST], NULL);   // quotient
d2157 4
a2160 1
		aml_setvalue(scope, &tmparg[DST2], NULL, (i1 % i2));
d2165 1
a2165 1
		aml_parsetarget(scope, &tmparg[DST], NULL);
d2170 1
a2170 2
	aml_setvalue(scope, &tmparg[DST], NULL, i3);

a2608 1
	tmparg = aml_alloctmp(scope, 4);
d2611 3
a2613 2
	  	_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, NULL);
		aml_parsetarget(scope, &tmparg[LHS], NULL);
d2616 1
a2616 1
		res->v_objref.ref = aml_dereftarget(scope, &tmparg[LHS]);
d2618 2
a2619 2
		aml_parsetarget(scope, &tmparg[DST], NULL);
		aml_setvalue(scope, &tmparg[DST], res, 0);
d2625 3
a2627 2
		aml_parseterm(scope, &tmparg[DST]);
		aml_setvalue(scope, res, &tmparg[DST], 0);
d2657 3
a2659 2
		aml_parseop(scope, &tmparg[LHS]);
		aml_parseop(scope, &tmparg[RHS]);
d2662 1
d2664 2
a2665 2
		aml_parsetarget(scope, &tmparg[DST], NULL);
		aml_setvalue(scope, &tmparg[DST], res, 0);
d2673 4
a2676 3
		aml_parseterm(scope, &tmparg[LHS]);
		aml_parsetarget(scope, &tmparg[DST], NULL);
		if (tmparg[LHS].type != AML_OBJTYPE_NAMEREF) {
d2678 1
a2678 1
			aml_setvalue(scope, &tmparg[DST], &tmparg[LHS], 0);
a2697 1
	tmpval = aml_alloctmp(scope, 4);
d2700 1
d2711 7
d2723 1
@


1.55
log
@Fixed GPE debug levels
Fixed ref counter on temporary bufferfields
DSDT parsing fully working on IBM Thinkpad
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.54 2006/10/19 01:06:54 jordan Exp $ */
a53 6
#define AML_BYTE	 'b'
#define AML_WORD	 'w'
#define AML_DWORD	 'd'
#define AML_QWORD	 'q'
#define AML_ANYINT	 'i'

a291 1
	//int len;
d325 10
a702 19
struct aml_vallist
{
	struct aml_value *obj;
	int nobj;
	struct aml_vallist *next;
};

struct aml_scope
{
	struct acpi_softc  *sc;
	uint8_t            *pos;
	uint8_t            *end;
	struct aml_node    *node;
	struct aml_vallist *tmpvals;
	struct aml_scope   *parent;
	struct aml_value   *locals;
	struct aml_value   *args;
	int                 nargs;
};
d998 1
a998 1
aml_showvalue(struct aml_value *val)
d1006 1
a1006 1
		dnprintf(0," [%s]", aml_nodename(val->node));
d1008 1
a1008 1
	dnprintf(0," %p cnt:%.2x", val, val->refcnt);
d1011 1
a1011 1
		dnprintf(0," integer: %llx\n", val->v_integer);
d1014 1
a1014 1
		dnprintf(0," string: %s\n", val->v_string);
d1017 1
a1017 1
		dnprintf(0," method: %.2x\n", val->v_method.flags);
d1020 1
a1020 1
		dnprintf(0," package: %.2x\n", val->length);
d1022 1
a1022 1
			aml_showvalue(val->v_package[idx]);
d1025 1
a1025 1
		dnprintf(0," buffer: %.2x {", val->length);
d1027 2
a1028 2
			dnprintf(0,"%s%.2x", idx ? ", " : "", val->v_buffer[idx]);
		dnprintf(0,"}\n");
d1032 1
a1032 1
		dnprintf(0," field: bitpos=%.4x bitlen=%.4x ref1:%x ref2:%x [%s]\n", 
d1036 2
a1037 2
		aml_showvalue(val->v_field.ref1);
		aml_showvalue(val->v_field.ref2);
d1040 1
a1040 1
		dnprintf(0," mutex: %llx\n", val->v_integer);
d1043 1
a1043 1
		dnprintf(0," event:\n");
d1046 1
a1046 1
		dnprintf(0," opregion: %.2x,%.8llx,%x\n",
d1052 1
a1052 1
		dnprintf(0," nameref: %s\n", aml_getname(val->v_nameref));
d1055 1
a1055 1
		dnprintf(0," device:\n");
d1058 1
a1058 1
		dnprintf(0," cpu: %.2x,%.4x,%.2x\n", 
d1063 1
a1063 1
		dnprintf(0," thermzone:\n");
d1066 1
a1066 1
		dnprintf(0," pwrrsrc: %.2x,%.2x\n", 
d1071 2
a1072 2
		dnprintf(0," objref: %p index:%x\n", val->v_objref.ref, val->v_objref.index);
		aml_showvalue(val->v_objref.ref);
d1075 1
a1075 1
		dnprintf(0," !!type: %x\n", val->type);
d1307 1
a1307 1
		aml_showvalue(rhs);
d1559 1
a1559 1
	int rc;
d1562 3
a1564 1
	if (lhs->type == rhs->type) {
d1581 1
a1581 1
	else if (lhs->type == AML_OBJTYPE_INTEGER) {
d1584 1
a1584 1
	else if (rhs->type == AML_OBJTYPE_INTEGER) {
d1641 1
a1641 1
		aml_showvalue(&scope->args[argc]);
d1646 1
a1646 1
	aml_showvalue(res);
d1723 1
a1723 1
		aml_showvalue(node->value);
d1979 1
a1979 1
		rval = 0x101;
a2915 20
/* XXX: kill me */
int aml_parse_length(struct acpi_context *ctx)
{
	return (0);
}
int64_t			aml_eparseint(struct acpi_context * ctx, int style)
{
	return (0);
}
struct aml_opcode	*aml_getopcode(struct acpi_context *ctx)
{
	return NULL;
}
void			acpi_freecontext(struct acpi_context *ctx)
{
}
const char		*aml_parse_name(struct acpi_context *ctx)
{
	return "";
}
@


1.54
log
@Merged target/terminal handling code
Added function call pointer to opcode table
_BIF working on Dell, IBM
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.53 2006/10/15 16:47:12 jordan Exp $ */
d1136 1
@


1.53
log
@fix broken scope braces
added debug print to gasio
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.52 2006/10/15 15:28:32 jordan Exp $ */
d89 2
d95 2
d132 18
d152 13
a164 13
	HTE(AMLOP_ZERO,		  "Zero",	     "c"  ),
	HTE(AMLOP_ONE,		  "One",	     "c"  ),
	HTE(AMLOP_ONES,		  "Ones",	     "c"  ),
	HTE(AMLOP_REVISION,	  "Revision",	     "R"  ),
	HTE(AMLOP_BYTEPREFIX,	  ".Byte",	     "b"  ),
	HTE(AMLOP_WORDPREFIX,	  ".Word",	     "w"  ),
	HTE(AMLOP_DWORDPREFIX,	  ".DWord",	     "d"  ),
	HTE(AMLOP_QWORDPREFIX,	  ".QWord",	     "q"  ),
	HTE(AMLOP_STRINGPREFIX,	  ".String",	     "a"  ),
	HTE(AMLOP_DEBUG,	  "DebugOp",	     "D", ),
	HTE(AMLOP_BUFFER,	  "Buffer",	     "piB" ),
	HTE(AMLOP_PACKAGE,	  "Package",	     "pbT" ),
	HTE(AMLOP_VARPACKAGE,	  "VarPackage",	     "piT" ),
d167 15
a181 15
	HTE(AMLOP_LOCAL0,	  "Local0",	     "L",    ),
	HTE(AMLOP_LOCAL1,	  "Local1",	     "L",    ),
	HTE(AMLOP_LOCAL2,	  "Local2",	     "L",    ),
	HTE(AMLOP_LOCAL3,	  "Local3",	     "L",    ),
	HTE(AMLOP_LOCAL4,	  "Local4",	     "L",    ),
	HTE(AMLOP_LOCAL5,	  "Local5",	     "L",    ),
	HTE(AMLOP_LOCAL6,	  "Local6",	     "L",    ),
	HTE(AMLOP_LOCAL7,	  "Local7",	     "L",    ),
	HTE(AMLOP_ARG0,		  "Arg0",	     "A",    ),
	HTE(AMLOP_ARG1,		  "Arg1",	     "A",    ),
	HTE(AMLOP_ARG2,		  "Arg2",	     "A",    ),
	HTE(AMLOP_ARG3,		  "Arg3",	     "A",    ),
	HTE(AMLOP_ARG4,		  "Arg4",	     "A",    ),
	HTE(AMLOP_ARG5,		  "Arg5",	     "A",    ),
	HTE(AMLOP_ARG6,		  "Arg6",	     "A",    ),
d184 9
a192 9
	HTE(AMLOP_IF,		  "If",		     "pI",   ),
	HTE(AMLOP_ELSE,		  "Else",	     "pT",   ),
	HTE(AMLOP_WHILE,	  "While",	     "piT",  ),
	HTE(AMLOP_BREAK,	  "Break",	     "",     ),
	HTE(AMLOP_CONTINUE,	  "Continue",	     "",     ),
	HTE(AMLOP_RETURN,	  "Return",	     "t",     ),
	HTE(AMLOP_FATAL,	  "Fatal",	     "bdi", ),
	HTE(AMLOP_NOP,		  "Nop",	     "",    ),
	HTE(AMLOP_BREAKPOINT,	  "BreakPoint",	     "",    ),
d195 17
a211 17
	HTE(AMLOP_INCREMENT,	  "Increment",	     "t",     ),
	HTE(AMLOP_DECREMENT,	  "Decrement",	     "t",     ),
	HTE(AMLOP_ADD,		  "Add",	     "iir",   ),
	HTE(AMLOP_SUBTRACT,	  "Subtract",	     "iir",   ),
	HTE(AMLOP_MULTIPLY,	  "Multiply",	     "iir",   ),
	HTE(AMLOP_DIVIDE,	  "Divide",	     "iirr",  ),
	HTE(AMLOP_SHL,		  "ShiftLeft",	     "iir",   ),
	HTE(AMLOP_SHR,		  "ShiftRight",	     "iir",   ),
	HTE(AMLOP_AND,		  "And",	     "iir",   ),
	HTE(AMLOP_NAND,		  "Nand",	     "iir",   ),
	HTE(AMLOP_OR,		  "Or",		     "iir",   ),
	HTE(AMLOP_NOR,		  "Nor",	     "iir",   ),
	HTE(AMLOP_XOR,		  "Xor",	     "iir",   ),
	HTE(AMLOP_NOT,		  "Not",	     "ir",    ),
	HTE(AMLOP_MOD,		  "Mod",	     "iir",   ),
	HTE(AMLOP_FINDSETLEFTBIT, "FindSetLeftBit",  "ir",    ),
	HTE(AMLOP_FINDSETRIGHTBIT,"FindSetRightBit", "ir",    ),
d214 9
a222 9
	HTE(AMLOP_LAND,		  "LAnd",	     "ii",    ),
	HTE(AMLOP_LOR,		  "LOr",	     "ii",    ),
	HTE(AMLOP_LNOT,		  "LNot",	     "i",     ),
	HTE(AMLOP_LNOTEQUAL,	  "LNotEqual",	     "tt",    ),
	HTE(AMLOP_LLESSEQUAL,	  "LLessEqual",	     "tt",    ),
	HTE(AMLOP_LGREATEREQUAL,  "LGreaterEqual",   "tt",    ),
	HTE(AMLOP_LEQUAL,	  "LEqual",	     "tt",    ),
	HTE(AMLOP_LGREATER,	  "LGreater",	     "tt",    ),
	HTE(AMLOP_LLESS,	  "LLess",	     "tt",    ),
d225 13
a237 13
	HTE(AMLOP_NAMECHAR,	  ".NameRef",	     "n" ),
	HTE(AMLOP_ALIAS,	  "Alias",	     "nN",  ),
	HTE(AMLOP_NAME,		  "Name",	     "Nt",  ),
	HTE(AMLOP_EVENT,	  "Event",	     "N",   ),
	HTE(AMLOP_MUTEX,	  "Mutex",	     "Nb",  ),
	HTE(AMLOP_DATAREGION,	  "DataRegion",	     "Nttt" ),
	HTE(AMLOP_OPREGION,	  "OpRegion",	     "Nbii" ),
	HTE(AMLOP_SCOPE,	  "Scope",	     "pNT"  ),
	HTE(AMLOP_DEVICE,	  "Device",	     "pNT"  ),
	HTE(AMLOP_POWERRSRC,	  "Power Resource",  "pNbwT" ),
	HTE(AMLOP_THERMALZONE,	  "ThermalZone",     "pNT" ),
	HTE(AMLOP_PROCESSOR,	  "Processor",	     "pNbdbT", ),
	HTE(AMLOP_METHOD,	  "Method",	     "pNfM",  ),
d240 9
a248 9
	HTE(AMLOP_FIELD,	    "Field",	       "pnfF" ),
	HTE(AMLOP_INDEXFIELD,	    "IndexField",      "pntfF" ),
	HTE(AMLOP_BANKFIELD,	    "BankField",       "pnnifF" ),
	HTE(AMLOP_CREATEFIELD,	    "CreateField",     "tiiN",   ),
	HTE(AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",    ),
	HTE(AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",    ),
	HTE(AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",    ),
	HTE(AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",    ),
	HTE(AMLOP_CREATEBITFIELD,   "CreateBitField",  "tiN",    ),
d251 1
a251 1
	HTE(AMLOP_TOINTEGER,	  "ToInteger",	     "tr",     ),
d253 6
a258 6
	HTE(AMLOP_TODECSTRING,	  "ToDecString",     "ir",     ),
	HTE(AMLOP_TOHEXSTRING,	  "ToHexString",     "ir",     ), 
	HTE(AMLOP_TOSTRING,	  "ToString",	     "t",      ),
	HTE(AMLOP_FROMBCD,	  "FromBCD",	     "ir",     ),
	HTE(AMLOP_TOBCD,	  "ToBCD",	     "ir",     ),
	HTE(AMLOP_MID,		  "Mid",	     "tiir",   ),
d261 5
a265 5
	HTE(AMLOP_ACQUIRE,	  "Acquire",	     "tw",     ),
	HTE(AMLOP_RELEASE,	  "Release",	     "t",      ),
	HTE(AMLOP_SIGNAL,	  "Signal",	     "t",      ),
	HTE(AMLOP_WAIT,		  "Wait",	     "ti",     ),
	HTE(AMLOP_RESET,	  "Reset",	     "t",      ),
d267 4
a270 4
	HTE(AMLOP_INDEX,	  "Index",	     "tir",    ),
	HTE(AMLOP_DEREFOF,	  "DerefOf",	     "t",      ),
	HTE(AMLOP_REFOF,	  "RefOf",	     "t",      ),
	HTE(AMLOP_CONDREFOF,	  "CondRef",	     "nr",     ),
d273 3
a275 3
	HTE(AMLOP_STALL,	  "Stall",	     "i",      ),
	HTE(AMLOP_SLEEP,	  "Sleep",	     "i",      ),
	HTE(AMLOP_LOAD,		  "Load",	     "nt" ),
d277 2
a278 2
	HTE(AMLOP_STORE,	  "Store",	     "tr",     ),
	HTE(AMLOP_CONCAT,	  "Concat",	     "ttr" ),
d280 5
a284 5
	HTE(AMLOP_NOTIFY,	  "Notify",	     "ti" ),
	HTE(AMLOP_SIZEOF,	  "Sizeof",	     "t",      ),
	HTE(AMLOP_MATCH,	  "Match",	     "tbibii", ),
	HTE(AMLOP_OBJECTTYPE,	  "ObjectType",	     "t" ),
	HTE(AMLOP_COPYOBJECT,	  "CopyObject",	     "tr" ),
d298 1
d437 1
a437 1
		dnprintf(0,"%.2x ", *(uint8_t *)buf);
d441 1
a441 1
	dnprintf(0,"\n");
d818 2
d861 16
d884 1
a884 1
	struct aml_value opr, *pop;
d891 1
a891 1
	memset(&opr, 0x0, sizeof(opr));
a923 1
		mask++;
d944 5
a948 1
		_aml_setvalue(&opr, AML_OBJTYPE_BUFFER, blen>>3, NULL);
d954 2
a955 2
				  bpos, blen, mask,
				  opr.v_buffer,
d958 1
a958 1
				      field->v_field.bitlen, &opr);
d965 1
a965 1
					memset(opr.v_buffer, 0xff, opr.length);
d971 1
d976 2
a977 2
						  bpos, blen, mask,
						  opr.v_buffer,
d985 1
a985 1
				      &opr);
d989 2
a990 2
				  bpos, blen, mask,
				  opr.v_buffer,
a992 1
		aml_freevalue(&opr);
d1002 1
d1009 3
a1011 2
struct aml_value *aml_dereftarget(struct aml_scope *, struct aml_value *);
struct aml_value *aml_derefterm(struct aml_scope *, struct aml_value *, int);
d1095 1
a1095 1
/* Returns dereferenced target value */
d1097 1
a1097 1
aml_dereftarget(struct aml_scope *scope, struct aml_value *ref)
d1100 2
a1101 2
	struct aml_value *cbuf;
	int index;
d1103 1
a1103 1
	for(;;) {
d1107 3
a1109 2
			if (node && node->value)
				ref = node->value;
d1111 1
d1116 2
a1117 2
			  	if (index >= ref->length)
			    		aml_die("index.buf out of bounds: %d/%d\n", index, ref->length);
d1124 14
a1137 8
					/* Create a temporary BufferField into the string/buffer */
				  	cbuf = aml_alloctmp(scope, 1);
					_aml_setvalue(cbuf, AML_OBJTYPE_BUFFERFIELD, 0, NULL);
					cbuf->v_field.type = AMLOP_CREATEBYTEFIELD;
					cbuf->v_field.bitpos = index * 8;
					cbuf->v_field.bitlen = 8;
					cbuf->v_field.ref1 = ref;
					return cbuf;
d1144 22
d1169 1
a1171 22
/* Perform DeRef on terminal
 * Returns expected type if required
 */
struct aml_value *
aml_derefterm(struct aml_scope *scope, struct aml_value *ref, int expect)
{
	struct aml_value *tmp;

	ref = aml_dereftarget(scope, ref);
	switch (ref->type) {
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		/* Read I/O field into temporary storage */
		tmp = aml_alloctmp(scope, 1);
		aml_fieldio(scope, ref, tmp, ACPI_IOREAD);
		return tmp;
	}
	if (expect != ref->type) {
		dnprintf(50,"convert in derefterm\n");
	}
	return ref;
}
d1274 3
d1289 1
a1289 1
		aml_die("copyvalue: %x", rhs->type);
d1322 2
d1339 1
a1339 1
			_aml_setvalue(lhs, AML_OBJTYPE_BUFFER, rhs->length, rhs->v_string);
d1342 1
a1342 1
			aml_die("setvalue.buf");
d1364 1
a1364 1
		dnprintf(0,"setvalue.unknown: %x", lhs->type);
d1427 1
d1429 1
a1429 1
aml_delref(struct aml_value **val)
d1431 10
a1440 1
	if (val && *val && --(*val)->refcnt == 0) {
d1467 1
a1644 1
	scope->locals = aml_alloctmp(scope, AML_MAX_LOCAL);
d1668 1
a1668 1
	return NULL;
d1694 1
a1694 1
			dnprintf(0,"Leaked: [%s] %d\n", 
d1866 1
a1866 1
		dnprintf(0,"Bad scope... runover pos:%.4x new end:%.4x scope end:%.4x\n", 
d1879 27
d2034 1
a2034 3
	int index, argc;
	struct aml_node *deref;
	struct aml_value *tmparg = NULL;
d2036 4
a2039 61
 loop:
	switch (raw->type) {
	case AML_OBJTYPE_NAMEREF:
		deref = aml_searchname(scope->node, raw->v_nameref);
		if (deref && deref->value) {
			raw = deref->value;
			goto loop;
		}
		aml_setvalue(scope, dst, raw, 0);
		break;
	case AML_OBJTYPE_OBJREF:
		while (raw->type == AML_OBJTYPE_OBJREF && raw->v_objref.index == -1) {
			raw = raw->v_objref.ref;
		}
		if (raw->type != AML_OBJTYPE_OBJREF)
			goto loop;

		index = raw->v_objref.index;
		raw = raw->v_objref.ref;
		switch (raw->type) {
		case AML_OBJTYPE_PACKAGE:
			if (index >= raw->length) {
				aml_setvalue(scope, dst, NULL, 0);
			}
			else {
				aml_setvalue(scope, dst, raw->v_package[index], 0);
			}
			goto loop;
			break;
		case AML_OBJTYPE_BUFFER:
			aml_setvalue(scope, dst, NULL, raw->v_buffer[index]);
			break;
		case AML_OBJTYPE_STRING:
			aml_setvalue(scope, dst, NULL, raw->v_string[index]);
			break;
		default:
			aml_die("evalterm");
			break;
		}
		break;

	case AML_OBJTYPE_METHOD:
		/* Read arguments from current scope */
		argc = AML_METHOD_ARGCOUNT(raw->v_method.flags);
		tmparg = aml_alloctmp(scope, argc);
		for (index=0; index<argc; index++) {
			aml_parseop(scope, &tmparg[index]);
			aml_addref(&tmparg[index]);
		}
		aml_evalmethod(raw->node, argc, tmparg, dst);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		aml_fieldio(scope, raw, dst, ACPI_IOREAD);
		break;
	default:
		aml_freevalue(dst);
		aml_setvalue(scope, dst, raw, 0);
		break;
	}
	return (0);
a2045 17
struct aml_value *aml_parsenamed(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsenamedscope(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemath(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsecompare(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseif(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsewhile(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufpkg(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemethod(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsesimple(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsefieldunit(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsebufferfield(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc3(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemuxaction(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsemisc2(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsematch(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parseref(struct aml_scope *, int, struct aml_value *);
struct aml_value *aml_parsestring(struct aml_scope *, int, struct aml_value *);
d2543 1
a2543 1
			dnprintf(0,"Notify: [%s] %.2x\n", 
a2634 12
#if 0
		aml_parsetarget(scope, res, NULL);
		opcode = aml_parseint(scope, AML_ANYINT);
		aml_parsetarget(scope, &tmparg[DST], NULL);
    
		if (res->type == AML_OBJTYPE_OBJREF && res->v_objref.index == -1)
		{
			dnprintf(10,"fixup index\n");
			res->v_objref.index = opcode;
			aml_setvalue(scope, &tmparg[DST], res, 0);
		}
#endif
d2661 1
a2661 1
			dnprintf(0, "Lazy alloc locals\n");
d2711 15
d2740 1
a2740 1
		_aml_setvalue(res, AML_OBJTYPE_STRING, 10, NULL);
d2775 5
a2779 3
	dummy = aml_evaltarget(scope, res);
	if (opt != NULL)
		*opt = dummy;
d2788 1
a2788 1
	struct aml_value *rval;
d2790 1
a2795 1
	aml_freevalue(res);
d2797 7
a2803 131
	switch (opcode) {
	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_REVISION:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
	case AMLOP_DEBUG:
	case AMLOP_NAMECHAR:
	case AMLOP_NOP:
		rval = aml_parsesimple(scope, opcode, res);
		break;
	case AMLOP_LNOT:
	case AMLOP_LAND:
	case AMLOP_LOR:
	case AMLOP_NOT:
	case AMLOP_TOBCD:
	case AMLOP_FROMBCD:
	case AMLOP_TOINTEGER:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
	case AMLOP_DIVIDE:
	case AMLOP_ADD: 
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_OR:
	case AMLOP_NOR:
	case AMLOP_XOR:
	case AMLOP_MOD:
		rval = aml_parsemath(scope, opcode, res);
		break;
	case AMLOP_MATCH:
		rval = aml_parsematch(scope, opcode, res);
		break;
	case AMLOP_LLESS:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LEQUAL:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LGREATEREQUAL:
	case AMLOP_LGREATER:
		rval = aml_parsecompare(scope, opcode, res);
		break;
	case AMLOP_NAME:
	case AMLOP_ALIAS:
	case AMLOP_EVENT:
	case AMLOP_MUTEX:
	case AMLOP_OPREGION:
		rval = aml_parsenamed(scope, opcode, res);
		break;
	case AMLOP_DEVICE:
	case AMLOP_SCOPE:
	case AMLOP_PROCESSOR:
	case AMLOP_POWERRSRC:
	case AMLOP_THERMALZONE:
		rval = aml_parsenamedscope(scope, opcode, res);
		break;
	case AMLOP_ACQUIRE:
	case AMLOP_RELEASE:
	case AMLOP_WAIT:
	case AMLOP_SIGNAL:
	case AMLOP_RESET:
		rval = aml_parsemuxaction(scope, opcode, res);
		break;
	case AMLOP_SLEEP:
	case AMLOP_STALL:
	case AMLOP_FATAL:
	case AMLOP_NOTIFY:
		rval = aml_parsemisc2(scope, opcode, res);
		break;
	case AMLOP_SIZEOF:
	case AMLOP_OBJECTTYPE:
		rval = aml_parsemisc3(scope, opcode, res);
		break;
	case AMLOP_CREATEFIELD:
	case AMLOP_CREATEBITFIELD:
	case AMLOP_CREATEBYTEFIELD:
	case AMLOP_CREATEWORDFIELD:
	case AMLOP_CREATEDWORDFIELD:
	case AMLOP_CREATEQWORDFIELD:
		rval = aml_parsebufferfield(scope, opcode, res);
		break;
	case AMLOP_FIELD:
	case AMLOP_INDEXFIELD:
	case AMLOP_BANKFIELD:
		rval = aml_parsefieldunit(scope, opcode, res);
		break;
	case AMLOP_BUFFER:
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		rval = aml_parsebufpkg(scope, opcode, res);
		break;
	case AMLOP_IF:
		rval = aml_parseif(scope, opcode, res);
		break;
	case AMLOP_WHILE:
		rval = aml_parsewhile(scope, opcode, res);
		break;
	case AMLOP_MID:
	case AMLOP_TOSTRING:
	case AMLOP_TODECSTRING:
	case AMLOP_TOHEXSTRING:
		rval = aml_parsestring(scope, opcode, res);
		break;
	case AMLOP_INDEX:
	case AMLOP_REFOF:
	case AMLOP_DEREFOF:
	case AMLOP_CONDREFOF:
	case AMLOP_STORE:
	case AMLOP_RETURN:
	case AMLOP_LOAD:
	case AMLOP_ARG0 ... AMLOP_ARG6:
	case AMLOP_LOCAL0 ... AMLOP_LOCAL7:
		rval = aml_parseref(scope, opcode, res);
		break;
	case AMLOP_METHOD:
		rval = aml_parsemethod(scope, opcode, res);
		break;
	default:
		aml_die("Unknown opcode: %.4x", opcode);
		break;
	}
	return rval;
@


1.52
log
@Fixed buggy if-else end scope
Fixed multi-level deref/index for thinkpads
Some KNF
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.51 2006/10/15 07:30:01 canacar Exp $ */
d412 8
d883 1
d1293 1
a1293 1
		else if (rhs->type == AML_OBJTYPE_INTEGER)
d1296 1
@


1.51
log
@Remove extra increment of bitmask. ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.50 2006/10/12 23:16:11 jordan Exp $ */
d403 1
a403 3
#if 0
#define aml_gasio(sc,tt,bb,ll,bp,bl,sz,buf,mode) acpi_gasio(sc,mode,tt,(bb)+((bp)>>3),(sz)>>3,(bl)>>3,buf)
#else
d408 4
a411 1
	acpi_gasio(sc, mode, type, base+(bitpos>>3), (size>>3), (bitlen>>3), buf);
a412 1
#endif
d768 1
a768 1
	if (start == *end) {
a769 1
	}
d771 1
a771 1
	if (res == NULL) {
a772 1
	}
d793 1
a793 1
	if (src->type != AML_OBJTYPE_BUFFER) {
a794 1
	}
d813 1
a813 1
	if (dst->type != AML_OBJTYPE_BUFFER) {
a814 1
	}
d838 4
d846 1
a846 1
		aml_setvalue(scope, field->v_field.ref1, NULL, field->v_field.bitpos>>3);
d851 1
a851 1
		aml_setvalue(scope, field->v_field.ref1, NULL, field->v_field.ref3);
d856 1
a856 2
		pop = field->v_field.ref1;
		if (pop->type != AML_OBJTYPE_OPREGION) {
a857 1
		}
d877 2
a878 3
		bpos = field->v_field.bitpos & ~mask;
		blen = ((field->v_field.bitpos & mask) +
			field->v_field.bitlen + mask) & ~mask;
d884 2
d901 1
a901 1
				  bpos, blen, mask+1,
d922 1
a922 1
						  bpos, blen, mask+1,
d935 1
a935 1
				  bpos, blen, mask+1,
d943 1
a943 4
		bpos = field->v_field.bitpos;
		blen = field->v_field.bitlen;
		pop = field->v_field.ref1;
		if (mode == ACPI_IOREAD) {
d945 1
a945 2
		}
		else {
a946 1
		}
d982 1
a982 1
		for (idx=0; idx<val->length; idx++) {
a983 1
		}
d987 1
a987 1
		for (idx=0; idx<val->length; idx++) {
a988 1
		}
d1045 1
d1059 2
d1065 10
d1076 1
a1076 1
					aml_die("Index");
d1142 1
d1154 1
a1154 1
		lhs->v_integer = ival;
d1180 1
a1180 1
		for (ival=0; ival<lhs->length; ival++) {
a1181 1
		}
d1187 1
d1193 2
a1194 2
	lhs->type = rhs->type & ~AML_STATIC;
	switch (lhs->type) {
d1215 1
a1215 1
		for (idx=0; idx<rhs->length; idx++) {
a1216 1
		}
d1227 1
a1227 1
/* Guts of the code: Assign one value to another */
a1232 1
	struct aml_value *olhs;
a1239 1
	olhs = lhs;
d1241 4
d1261 1
a1261 1
		if (lhs->node) {
a1262 1
		}
d1264 3
a1266 4
		if (rhs->type == AML_OBJTYPE_BUFFER) {
			_aml_setvalue(lhs, rhs->type, rhs->length, rhs->v_buffer);
		}
		else if (rhs->type == AML_OBJTYPE_INTEGER) {
d1269 1
a1269 2
		}
		else if (rhs->type == AML_OBJTYPE_STRING) {
a1270 1
		}
d1274 1
a1274 1
		}
d1277 1
a1277 1
		if (lhs->node) {
a1278 1
		}
d1280 3
a1282 4
		if (rhs->type == AML_OBJTYPE_STRING) {
			_aml_setvalue(lhs, rhs->type, rhs->length, rhs->v_string);
		}
		else if (rhs->type == AML_OBJTYPE_BUFFER) {
d1284 1
a1284 2
		}
		else if (rhs->type == AML_OBJTYPE_INTEGER) {
a1286 1
		}
d1559 1
a1559 3
#ifdef ACPI_DEBUG
	int idx;
#endif
d1572 3
a1574 3
	for (idx=0; idx<scope->nargs; idx++) {
		dnprintf(10, "  arg%d: ", idx);
		aml_showvalue(&scope->args[idx]);
d2189 1
a2189 1
	while (test && scope->pos && scope->pos < end) {
d2193 3
d2199 1
a2199 1
		while (!test && scope->pos && scope->pos < end) {
d2596 9
d2615 1
d2629 7
a2635 9
		if (scope && scope->args) {
			opcode -= AMLOP_ARG0;
			if (opcode >= scope->nargs) {
				aml_die("arg out of range: %x\n", opcode);
			}

			/* Create OBJREF to stack variable */
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, &scope->args[opcode]);
		}
d2638 6
a2643 4
		if (scope && scope->locals) {
			/* Create OBJREF to stack variable */
			_aml_setvalue(res, AML_OBJTYPE_OBJREF, -1, 
				      &scope->locals[opcode - AMLOP_LOCAL0]);
d2645 5
@


1.50
log
@Added exportable aml_getpciaddr
Added printing args for called functions
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.49 2006/10/12 16:54:01 marco Exp $ */
a883 1
		mask++;
d1560 3
a1562 1

@


1.49
log
@fix rcsid
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1574 4
d1580 1
a1580 1
	printf("[%s] returns: ", aml_nodename(node));
a1798 1
void aml_getpciaddr(struct aml_scope *, struct aml_value *);
d1824 2
a1825 2
void
aml_getpciaddr(struct aml_scope *scope, struct aml_value *res)
d1827 2
a1828 2
	struct aml_node *node;
	struct aml_value *tmpres;
d1831 14
a1844 10
	tmpres = aml_alloctmp(scope, 1);
	node = aml_searchname(scope->node, "_ADR");
	if (node != NULL) {
		aml_evalterm(scope, node->value, tmpres);
		res->v_opregion.iobase += (aml_val2int(tmpres) << 16L);
	}
	node = aml_searchname(scope->node, "_BBN");
	if (node != NULL) {
		aml_evalterm(scope, node->value, tmpres);
		res->v_opregion.iobase += (aml_val2int(tmpres) << 48L);
d1846 2
d1911 1
a1911 1
	dnprintf(60,"%.4x: [%s] %s\n", 
d2023 1
d2049 6
a2054 2
		if (res->v_opregion.iospace == GAS_PCI_CFG_SPACE)
			aml_getpciaddr(scope, res);
d2173 1
a2173 1
	rc = aml_cmpvalue(&tmparg[LHS], &tmparg[RHS], opcode);  
d2501 1
d2731 1
d2739 1
a2739 1
	dnprintf(60,"%.4x: [%s] %s\n", 
@


1.48
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $openbsd: dsdt.c,v 1.47 2006/06/14 16:30:07 canacar Exp $ */
@


1.47
log
@Allow changes to a Name initialized with a 'static' value.
Problem report (PR5149), and debugging by jj.roh at thurnherr dot ch
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.46 2006/05/31 14:02:12 canacar Exp $ */
d35 9
d67 37
a103 2
#ifdef ACPI_DEBUG
const char		*opregion(int);
d105 1
a105 22
const char *
opregion(int id)
{
	switch(id) {
	case 0:
		return "SystemMemory";
	case 1:
		return "SystemIO";
	case 2:
		return "PCIConfig";
	case 3:
		return "Embedded";
	case 4:
		return "SMBus";
	case 5:
		return "CMOS";
	case 6:
		return "PCIBAR";
	}
	return "";
}
#endif
d107 2
a108 72
const char		*aml_parse_string(struct acpi_context *);
int			_aml_freevalue(struct aml_value *);
int			aml_isnamedop(u_int16_t);
int			aml_logicalcmp(u_int16_t, int64_t, int64_t);
int			aml_lsb(u_int64_t);
int			aml_match(int64_t, int, int64_t);
int			aml_msb(u_int64_t);
int			aml_parse_length(struct acpi_context *);
int			aml_strcmp(u_int16_t, const char *, const char *);
int 			aml_tstbit(const u_int8_t *, int);
int64_t			aml_evalmath(u_int16_t, int64_t, int64_t);
int64_t			aml_str2int(const char *, int, int);
int64_t			aml_val2int(struct acpi_context *, struct aml_value *);
struct aml_opcode	*aml_getopcode(struct acpi_context *);
struct aml_node		*_aml_searchname(struct aml_node *, const char *);
struct aml_node		*aml_createname(struct aml_node *, const char *);
struct aml_node		*aml_doname(struct aml_node *, const char *, int);
struct aml_value	*aml_doconcat(struct acpi_context *);
struct aml_value	*aml_parse_bufferfield(struct acpi_context *, int, int, int);
struct aml_value	*aml_parse_fieldunit(struct acpi_context *, int);
struct aml_value	*aml_doif(struct acpi_context *);
struct aml_value	*aml_doloadtable(struct acpi_context *);
struct aml_value	*aml_domatch(struct acpi_context *);
struct aml_value	*aml_dowhile(struct acpi_context *);
struct aml_value	*aml_domid(struct acpi_context *);
struct aml_value	*aml_ederef(struct acpi_context *, struct aml_value *);
struct aml_value	*aml_eparselist(struct acpi_context *, u_int8_t *, int);
struct aml_value	*aml_eparseval(struct acpi_context *, int);
struct aml_value	*aml_evalnode(struct acpi_softc *, struct aml_node *,
				      int, struct aml_value **);
struct aml_value	*aml_evalname(struct acpi_softc *, struct aml_node *, const char *,
				      int, struct aml_value **);
struct aml_value	*aml_evalmethod(struct acpi_context *, struct aml_value *);
u_int64_t		aml_bcd2dec(u_int64_t);
u_int64_t		aml_dec2bcd(u_int64_t);
u_int64_t		aml_parse_int(struct acpi_context *, int);
void			*acpi_os_allocmem(size_t);
void			acpi_os_freemem(void *);
void			aml_addchildnode(struct aml_node *, struct aml_node *);
void			aml_bufcpy(u_int8_t *, int, const u_int8_t *, int, int);
void			aml_dump(int, u_int8_t *);
void			aml_resizevalue(struct aml_value *, int);
void			aml_setbit(u_int8_t *, int, int);
void			aml_shownode(struct aml_node *);

struct aml_node		*aml_addvname(struct acpi_context *, const char *, int,
			    struct aml_value *);
int			aml_bufcmp(const u_int8_t *, int, const u_int8_t *,
			    int);
struct aml_node		*aml_create_node(struct aml_node *, int, const char *,
			    u_int8_t *);
struct aml_node		*aml_find_name(struct acpi_softc *, struct aml_node *,
			    const char *);
struct aml_value	*aml_domethod(struct acpi_context *, struct aml_value *,
			    int, struct aml_value **);
struct aml_value	*aml_efield(struct acpi_context *, struct aml_value *,
			    struct aml_value *);
struct aml_value	*aml_eparsenode(struct acpi_context *,
			    struct aml_node *);
struct aml_value	*aml_eparsescope(struct acpi_context *, const char *,
			    u_int8_t *, struct aml_opcode *,
			    struct aml_value *);
struct aml_value	*aml_esetnodevalue(struct acpi_context *,
			    struct aml_value *, struct aml_value *, int64_t);
struct aml_value	*aml_getnodevalue(struct acpi_context *,
			    struct aml_node *);
struct aml_value	*aml_val2buf(struct acpi_context *, struct aml_value *,
			    int);
uint64_t		aml_get_pciaddr(struct acpi_context *,
			    struct aml_node *);
void			aml_delchildren(struct acpi_context *,
			    struct aml_node *);
d110 1
d112 4
d117 10
a126 2
struct aml_value	aml_os;
struct aml_value	*aml_global_lock;
d130 13
a142 13
	{ AMLOP_ZERO,		  "Zero",	     "!"  },
	{ AMLOP_ONE,		  "One",	     "!"  },
	{ AMLOP_ONES,		  "Ones",	     "!"  },
	{ AMLOP_BYTEPREFIX,	  ".Byte",	     "b"  },
	{ AMLOP_WORDPREFIX,	  ".Word",	     "w"  },
	{ AMLOP_DWORDPREFIX,	  ".DWord",	     "d"  },
	{ AMLOP_QWORDPREFIX,	  ".QWord",	     "q"  },
	{ AMLOP_REVISION,	  "Revision",	     ""	  },
	{ AMLOP_STRINGPREFIX,	  ".String",	     "a"  },
	{ AMLOP_DEBUG,		  "DebugOp",	     "",  },
	{ AMLOP_BUFFER,		  "Buffer",	     "piB" },
	{ AMLOP_PACKAGE,	  "Package",	     "pbT" },
	{ AMLOP_VARPACKAGE,	  "VarPackage",	     "piT" },
d145 15
a159 15
	{ AMLOP_LOCAL0,		  "Local0",	     "",    },
	{ AMLOP_LOCAL1,		  "Local1",	     "",    },
	{ AMLOP_LOCAL2,		  "Local2",	     "",    },
	{ AMLOP_LOCAL3,		  "Local3",	     "",    },
	{ AMLOP_LOCAL4,		  "Local4",	     "",    },
	{ AMLOP_LOCAL5,		  "Local5",	     "",    },
	{ AMLOP_LOCAL6,		  "Local6",	     "",    },
	{ AMLOP_LOCAL7,		  "Local7",	     "",    },
	{ AMLOP_ARG0,		  "Arg0",	     "",    },
	{ AMLOP_ARG1,		  "Arg1",	     "",    },
	{ AMLOP_ARG2,		  "Arg2",	     "",    },
	{ AMLOP_ARG3,		  "Arg3",	     "",    },
	{ AMLOP_ARG4,		  "Arg4",	     "",    },
	{ AMLOP_ARG5,		  "Arg5",	     "",    },
	{ AMLOP_ARG6,		  "Arg6",	     "",    },
d162 9
a170 9
	{ AMLOP_IF,		  "If",		     "piT",  },
	{ AMLOP_ELSE,		  "Else",	     "pT",   },
	{ AMLOP_WHILE,		  "While",	     "piT",  },
	{ AMLOP_BREAK,		  "Break",	     "",     },
	{ AMLOP_CONTINUE,	  "Continue",	     "",     },
	{ AMLOP_RETURN,		  "Return",	     "t",     },
	{ AMLOP_FATAL,		  "Fatal",	     "bdi", },
	{ AMLOP_NOP,		  "Nop",	     "",    },
	{ AMLOP_BREAKPOINT,	  "BreakPoint",	     "",    },
d173 17
a189 17
	{ AMLOP_INCREMENT,	  "Increment",	     "t",     },
	{ AMLOP_DECREMENT,	  "Decrement",	     "t",     },
	{ AMLOP_ADD,		  "Add",	     "iit",   },
	{ AMLOP_SUBTRACT,	  "Subtract",	     "iit",   },
	{ AMLOP_MULTIPLY,	  "Multiply",	     "iit",   },
	{ AMLOP_DIVIDE,		  "Divide",	     "iitt",  },
	{ AMLOP_SHL,		  "ShiftLeft",	     "iit",   },
	{ AMLOP_SHR,		  "ShiftRight",	     "iit",   },
	{ AMLOP_AND,		  "And",	     "iit",   },
	{ AMLOP_NAND,		  "Nand",	     "iit",   },
	{ AMLOP_OR,		  "Or",		     "iit",   },
	{ AMLOP_NOR,		  "Nor",	     "iit",   },
	{ AMLOP_XOR,		  "Xor",	     "iit",   },
	{ AMLOP_NOT,		  "Not",	     "it",    },
	{ AMLOP_MOD,		  "Mod",	     "iit",   },
	{ AMLOP_FINDSETLEFTBIT,	  "FindSetLeftBit",  "it",    },
	{ AMLOP_FINDSETRIGHTBIT,  "FindSetRightBit", "it",    },
d192 9
a200 9
	{ AMLOP_LAND,		  "LAnd",	     "ii",    },
	{ AMLOP_LOR,		  "LOr",	     "ii",    },
	{ AMLOP_LNOT,		  "LNot",	     "i",     },
	{ AMLOP_LNOTEQUAL,	  "LNotEqual",	     "tt",    },
	{ AMLOP_LLESSEQUAL,	  "LLessEqual",	     "tt",    },
	{ AMLOP_LGREATEREQUAL,	  "LGreaterEqual",   "tt",    },
	{ AMLOP_LEQUAL,		  "LEqual",	     "tt",    },
	{ AMLOP_LGREATER,	  "LGreater",	     "tt",    },
	{ AMLOP_LLESS,		  "LLess",	     "tt",    },
d203 13
a215 13
	{ AMLOP_NAMECHAR,	  ".NameRef",	     "n" },
	{ AMLOP_ALIAS,		  "Alias",	     "nN",  },
	{ AMLOP_NAME,		  "Name",	     "Nt",  },
	{ AMLOP_EVENT,		  "Event",	     "N",   },
	{ AMLOP_MUTEX,		  "Mutex",	     "Nb",  },
	{ AMLOP_DATAREGION,	  "DataRegion",	     "Nttt" },
	{ AMLOP_OPREGION,	  "OpRegion",	     "Nbii" },
	{ AMLOP_SCOPE,		  "Scope",	     "pNT"  },
	{ AMLOP_DEVICE,		  "Device",	     "pNT"  },
	{ AMLOP_POWERRSRC,	  "Power Resource",  "pNbwT" },
	{ AMLOP_THERMALZONE,	  "ThermalZone",     "pNT" },
	{ AMLOP_PROCESSOR,	  "Processor",	     "pNbdbT", },
	{ AMLOP_METHOD,		  "Method",	     "pNfM",  },
d218 9
a226 9
	{ AMLOP_FIELD,		  "Field",	     "pnfF" },
	{ AMLOP_INDEXFIELD,	  "IndexField",	     "pntfF" },
	{ AMLOP_BANKFIELD,	  "BankField",	     "pnnifF" },
	{ AMLOP_CREATEFIELD,	  "CreateField",     "tiiN",   },
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",    },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",    },
	{ AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",    },
	{ AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",    },
	{ AMLOP_CREATEBITFIELD,	  "CreateBitField",  "tiN",    },
d229 8
a236 8
	{ AMLOP_TOINTEGER,	  "ToInteger",	     "tt",     },
	{ AMLOP_TOBUFFER,	  "ToBuffer",	     "tt",     },
	{ AMLOP_TODECSTRING,	  "ToDecString",     "it",     },
	{ AMLOP_TOHEXSTRING,	  "ToHexString",     "it",     }, 
	{ AMLOP_TOSTRING,	  "ToString",	     "t",      },
	{ AMLOP_FROMBCD,	  "FromBCD",	     "it",     },
	{ AMLOP_TOBCD,		  "ToBCD",	     "it",     },
	{ AMLOP_MID,		  "Mid",	     "tiit",   },
d239 5
a243 5
	{ AMLOP_ACQUIRE,	  "Acquire",	     "tw",     },
	{ AMLOP_RELEASE,	  "Release",	     "t",      },
	{ AMLOP_SIGNAL,		  "Signal",	     "t",      },
	{ AMLOP_WAIT,		  "Wait",	     "ti",     },
	{ AMLOP_RESET,		  "Reset",	     "t",      },
d245 18
a262 19
	{ AMLOP_INDEX,		  "Index",	     "tit",    },
	{ AMLOP_DEREFOF,	  "DerefOf",	     "t",      },
	{ AMLOP_REFOF,		  "RefOf",	     "t",      },
	{ AMLOP_CONDREFOF,	  "CondRef",	     "tt",     },

	{ AMLOP_LOADTABLE,	  "LoadTable",	     "tttttt" },
	{ AMLOP_STALL,		  "Stall",	     "i",      },
	{ AMLOP_SLEEP,		  "Sleep",	     "i",      },
	{ AMLOP_LOAD,		  "Load",	     "nt" },
	{ AMLOP_UNLOAD,		  "Unload",	     "t" }, 
	{ AMLOP_STORE,		  "Store",	     "tt",     },
	{ AMLOP_CONCAT,		  "Concat",	     "ttt" },
	{ AMLOP_CONCATRES,	  "ConcatRes",	     "ttt" },
	{ AMLOP_NOTIFY,		  "Notify",	     "ti" },
	{ AMLOP_SIZEOF,		  "Sizeof",	     "t",      },
	{ AMLOP_MATCH,		  "Match",	     "tbibii", },
	{ AMLOP_OBJECTTYPE,	  "ObjectType",	     "t", },
	{ AMLOP_COPYOBJECT,	  "CopyObject",	     "tt" },
	{ 0xFFFF }
d265 44
d321 8
a328 1
				    SLIST_HEAD_INITIALIZER(&aml_notify_list);
d330 7
d338 1
a338 1
acpi_os_allocmem(size_t size)
d340 1
a340 1
	void		*ptr;
d342 9
a350 5
	ptr =  malloc(size, M_DEVBUF, M_WAITOK);
	if (ptr) 
		memset(ptr, 0, size);

	return (ptr);
d354 1
a354 1
acpi_os_freemem(void *ptr)
d356 9
a364 1
	/* free(ptr, M_DEVBUF); */
d367 4
d403 15
d420 1
a420 1
    int (*proc)(struct aml_node *, int, void *), void *arg)
d427 1
a427 1
	pdata = acpi_os_allocmem(sizeof(struct aml_notify_data));
d464 3
a466 4
void
aml_addchildnode(struct aml_node *parent, struct aml_node *child)
{
	struct aml_node	**tmp;
d468 4
a471 2
	for (tmp = &parent->child; *tmp; tmp = &((*tmp)->sibling))
		;
a472 4
	child->sibling = NULL;
	child->parent = parent;
	*tmp = child;
}
d474 1
d476 1
a476 2
aml_create_node(struct aml_node *parent, int opcode, const char *mnem,
    u_int8_t *start)
d478 1
a478 4
	struct aml_node	*node;

	node = (struct aml_node *)acpi_os_allocmem(sizeof(struct aml_node));
	if (node == NULL)
d480 6
d487 5
a491 8
	node->opcode = opcode;
	node->mnem   = mnem;
	node->depth  = parent->depth+1;
	node->start  = start;
	node->end    = parent->end;
	node->child  = NULL;
	
	aml_addchildnode(parent, node);
d493 8
a500 1
	return (node);
d503 2
a504 7
/* Allocate dynamic AML value
 *   type : Type of object to allocate (AML_OBJTYPE_XXXX)
 *   ival : Integer value (action depends on type)
 *   bval : Buffer value (action depends on type)
 */
struct aml_value *
aml_allocvalue(int type, int64_t ival, void *bval) 
d506 2
a507 3
	struct aml_value	*rv;
	struct aml_value	**pv;
	int64_t			idx;
d509 7
a515 5
	rv = (struct aml_value *)acpi_os_allocmem(sizeof(struct aml_value));
	rv->type = type;

	switch (type) {
	case AML_OBJTYPE_UNINITIALIZED:
d517 3
a519 3
	case AML_OBJTYPE_NAMEREF:
		rv->name = bval;
		rv->v_objref.index = -1;
d521 3
a523 54
	case AML_OBJTYPE_OBJREF:
		rv->v_objref.index = ival;
		rv->v_objref.ref = (struct aml_value *)bval;
		break;
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
		rv->v_integer = ival;
		break;
	case AML_OBJTYPE_STRING:
		/* Allocate string: if pointer valid, copy data */
		if (ival < 0)
			ival = strlen((const char *)bval);
		rv->length = ival;
		if (ival) {
			rv->v_string = acpi_os_allocmem(ival + 1);
			if (bval) 
				strncpy(rv->v_string, bval, ival);
		}
		break;
	case AML_OBJTYPE_BUFFER:
		/* Allocate buffer: if pointer valid, copy data */
		rv->length = ival;
		if (ival) {
			rv->v_buffer = acpi_os_allocmem(ival);
			if (bval)
				memcpy(rv->v_buffer, bval, ival);
		}
		break;
	case AML_OBJTYPE_PACKAGE:
		/* Allocate package pointers */
		rv->length = ival;
		rv->v_package = (struct aml_value **)acpi_os_allocmem(
		    rv->length * sizeof(struct aml_value *));
		if (bval != NULL) {
			pv = (struct aml_value **)bval;
			dnprintf(40, "alloc package.. %lld\n", ival);
			for (idx = 0; idx < ival; idx++)
				rv->v_package[idx] = aml_copyvalue(pv[idx]);
		}
		break;
	case AML_OBJTYPE_METHOD:
		rv->v_method.flags = ival;
		break;
	case AML_OBJTYPE_MUTEX:
		rv->v_integer = ival;
		break;
	case AML_OBJTYPE_OPREGION:
	case AML_OBJTYPE_DEVICE:
	case AML_OBJTYPE_EVENT:
	case AML_OBJTYPE_POWERRSRC:
	case AML_OBJTYPE_PROCESSOR:
	case AML_OBJTYPE_THERMZONE:
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
d526 1
a526 1
		dnprintf(40, "Unknown aml_allocvalue: %.2x\n", type);
d528 9
a536 2

	return (rv);
d539 3
a541 2
struct aml_value *
aml_allocint(u_int64_t ival)
d543 3
a545 2
	return aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL);
}
d547 45
a591 4
struct aml_value *
aml_allocstr(const char *str)
{
	return aml_allocvalue(AML_OBJTYPE_STRING, -1, (void *)str);
d594 3
a596 2
int 
_aml_freevalue(struct aml_value *v)
d598 3
a600 1
	int		idx;
d602 29
a630 18
	/* Don't free static values */
	if (v == NULL) 
		return (-1);

	if (v->node || v->refcnt)
		return (-1);

	dnprintf(50, "freeing value : %4x %s\n", v->type,
	    v->node ? "attached" : "freeable");

	/* XXX */
	return (-1);

	switch (v->type) {
	case AML_OBJTYPE_STRING:
		if (v->v_string) {
			acpi_os_freemem((void *)v->v_string);
			v->v_string = NULL;
d632 3
a634 5
		break;
	case AML_OBJTYPE_BUFFER:
		if (v->v_buffer) {
			acpi_os_freemem(v->v_buffer);
			v->v_buffer = NULL;
d636 1
a636 10
		break;
	case AML_OBJTYPE_PACKAGE:
		for (idx = 0; idx < v->length; idx++)
			aml_freevalue(&v->v_package[idx]);
		acpi_os_freemem(v->v_package);
		v->v_package = NULL;
		break;
	case AML_OBJTYPE_METHOD:
		acpi_os_freemem(v->v_method.start);
		break;
d638 3
a640 12
	v->length = 0;
	v->type = 0;

	return (0);
}

void
aml_freevalue(struct aml_value **pv)
{
	if (_aml_freevalue(*pv) == 0) {
		acpi_os_freemem(*pv);
		*pv = NULL;
d642 1
d645 1
d647 1
a647 1
aml_showvalue(struct aml_value *value)
d649 1
a649 1
	int idx;
d651 1
a651 1
	if (value == NULL)
d653 2
d656 1
a656 2
	if (value->node)
		dnprintf(50, "node:%.8x ", value->node);
d658 2
a659 2
	if (value->name)
		dnprintf(50, "name:%s ", value->name);
d661 2
a662 87
	switch (value->type) {
	case AML_OBJTYPE_OBJREF:
		dnprintf(50, "refof: %x {\n", value->v_objref.index);
		aml_showvalue(value->v_objref.ref);
		dnprintf(50, "}\n");
		break;
	case AML_OBJTYPE_NAMEREF:
		dnprintf(50, "nameref: %s %.8x\n", value->name,
			 value->v_objref.ref);
		break;
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
		dnprintf(50, "integer: %llx %s\n", value->v_integer,
		    (value->type == AML_OBJTYPE_STATICINT) ? "(static)" : "");
		break;
	case AML_OBJTYPE_STRING:
		dnprintf(50, "string: %s\n", value->v_string);
		break;
	case AML_OBJTYPE_PACKAGE:
		dnprintf(50, "package: %d {\n", value->length);
		for (idx = 0; idx < value->length; idx++)
			aml_showvalue(value->v_package[idx]);
		dnprintf(50, "}\n");
		break;
	case AML_OBJTYPE_BUFFER:
		dnprintf(50, "buffer: %d ", value->length);
		aml_dump(value->length, value->v_buffer);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		dnprintf(50, "debug");
		break;
	case AML_OBJTYPE_MUTEX:
		dnprintf(50, "mutex : %llx\n", value->v_integer);
		break;
	case AML_OBJTYPE_DEVICE:
		dnprintf(50, "device\n");
		break;
	case AML_OBJTYPE_EVENT:
		dnprintf(50, "event\n");
		break;
	case AML_OBJTYPE_PROCESSOR:
		dnprintf(50, "cpu: %x,%x,%x\n",
		    value->v_processor.proc_id,
		    value->v_processor.proc_addr,
		    value->v_processor.proc_len);
		break;
	case AML_OBJTYPE_METHOD:
		dnprintf(50, "method: args=%d, serialized=%d, synclevel=%d\n",
		    AML_METHOD_ARGCOUNT(value->v_method.flags),
		    AML_METHOD_SERIALIZED(value->v_method.flags),
		    AML_METHOD_SYNCLEVEL(value->v_method.flags));
		break;
	case AML_OBJTYPE_FIELDUNIT:
		dnprintf(50, "%s: access=%x,lock=%x,update=%x pos=%.4x "
		    "len=%.4x\n",
		    aml_opname(value->v_field.type),
		    AML_FIELD_ACCESS(value->v_field.flags),
		    AML_FIELD_LOCK(value->v_field.flags),
		    AML_FIELD_UPDATE(value->v_field.flags),
		    value->v_field.bitpos,
		    value->v_field.bitlen);

		aml_showvalue(value->v_field.ref1);
		aml_showvalue(value->v_field.ref2);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
		dnprintf(50, "%s: pos=%.4x len=%.4x ", 
		    aml_opname(value->v_field.type),
		    value->v_field.bitpos,
		    value->v_field.bitlen);

		if (value->v_field.ref1)
			aml_dump(aml_bytelen(value->v_field.bitlen), 
			    value->v_field.ref1->v_buffer + 
			    aml_bytepos(value->v_field.bitpos));

		aml_showvalue(value->v_field.ref1);
		break;
	case AML_OBJTYPE_OPREGION:
		dnprintf(50, "opregion: %s,0x%llx,0x%x\n",
		    opregion(value->v_opregion.iospace),
		    value->v_opregion.iobase,
		    value->v_opregion.iolen);
		break;
	default:
		dnprintf(50, "unknown: %d\n", value->type);
		break;
d666 4
a669 3
int
aml_comparevalue(struct acpi_context *ctx, int opcode, struct aml_value *lhs, 
    struct aml_value *rhs)
d671 4
a674 2
	struct aml_value	*tmp;
	int			rc;
d676 12
a687 12
	if (lhs->type == AML_OBJTYPE_INTEGER)
		return aml_logicalcmp(opcode, lhs->v_integer,
		    aml_val2int(ctx, rhs));

	if (rhs->type == AML_OBJTYPE_INTEGER)
		return aml_logicalcmp(opcode,
		    aml_val2int(ctx, lhs), rhs->v_integer);

	if (lhs->type == AML_OBJTYPE_BUFFER) {
		tmp = aml_val2buf(ctx, rhs, 0);
		rc  = aml_bufcmp(lhs->v_buffer, lhs->length,
		    tmp->v_buffer, tmp->length);
d689 4
a692 5
		return (opcode == AMLOP_LNOTEQUAL) ?
		    (rc != AMLOP_LEQUAL) : (rc == opcode);
	}
	/* XXX: fix this.. non integer comparisons */
	dnprintf(40,"comparevalue: %.2x %.2x\n", lhs->type, rhs->type);
d694 4
a697 2
	return (0);
}
d699 1
d701 1
a701 1
aml_copyvalue(const struct aml_value *rhs)
d703 5
a707 1
	struct aml_value	*rv;
d709 6
a714 19
	switch (rhs->type) {
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
		return aml_allocvalue(rhs->type, rhs->v_integer, NULL);
	case AML_OBJTYPE_STRING:
		return aml_allocvalue(rhs->type, rhs->length, rhs->v_string);
	case AML_OBJTYPE_BUFFER:
		return aml_allocvalue(rhs->type, rhs->length, rhs->v_buffer);
	case AML_OBJTYPE_PACKAGE:
		return aml_allocvalue(rhs->type, rhs->length, rhs->v_package);
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		rv = aml_allocvalue(rhs->type, 0, NULL);
		if (rv != NULL) {
			rv->name = rhs->name;
			rv->length = rhs->length;
			rv->v_field = rhs->v_field;
		}
		return (rv);
d716 2
a717 7
	default:
		dnprintf(40,"copy unknown : %x\n", rhs->type);
		rv = aml_allocvalue(rhs->type, 0, NULL);
		*rv = *rhs;
		break;
	}
	return (rv);
d720 4
a723 3
/* Resize buffer/string/package if out-of-bounds access */
void
aml_resizevalue(struct aml_value *pv, int newlen)
d725 1
a725 3
	struct aml_value	**newpkg;
	u_int8_t		*newbuf;
	int			i1;
d727 6
a732 6
	++newlen;
	dnprintf(40, "supersizeme\n");
	switch (pv->type) {
	case AML_OBJTYPE_BUFFER:
		newbuf = (u_int8_t *)acpi_os_allocmem(newlen);
		memcpy(newbuf, pv->v_buffer, pv->length);
d734 2
a735 2
		/* Free old buffer */
		acpi_os_freemem(pv->v_buffer);
d737 6
a742 3
		pv->v_buffer = newbuf;
		pv->length = newlen;
		break;
d744 3
a746 3
	case AML_OBJTYPE_PACKAGE:
		newpkg = (struct aml_value **)acpi_os_allocmem(newlen *
		    sizeof(struct aml_value *));
d748 7
a754 12
		/* Assign old package values */
		for (i1 = 0; i1 < pv->length; i1++)
			newpkg[i1] = pv->v_package[i1];

		/* Free old package */
		acpi_os_freemem(pv->v_package);

		/* Set new length */
		pv->v_package = newpkg;
		pv->length = newlen-1;

		break;
d756 1
a756 7
}

/* * AML Parsing routines */
const char *
aml_parse_string(struct acpi_context *ctx)
{
	const char	*str = ctx->pos;
d758 1
a758 3
	ctx->pos += strlen(str) + 1;

	return (str);
a760 31
/* Read value from AML bytestream */
u_int64_t
aml_parse_int(struct acpi_context *ctx, int size)
{
	u_int8_t	*pc = ctx->pos;

	switch (size) {
	case AML_BYTE:
		ctx->pos += 1;
		return *(u_int8_t *)pc;
	case AML_WORD:
		ctx->pos += 2;
		return *(u_int16_t *)pc;
	case AML_DWORD:
		ctx->pos += 4;
		return *(u_int32_t *)pc;
	case AML_QWORD:
		ctx->pos += 8;
		return *(u_int64_t *)pc;
	}

	return (0);
}

/* Decode AML Package length
 * Upper two bits of first byte denote length
 *   0x00 = length is in lower 6 bits
 *   0x40 = length is lower 4 bits + 1 byte
 *   0x80 = length is lower 4 bits + 2 bytes
 *   0xC0 = length is lower 4 bits + 3 bytes
 */
d762 2
a763 1
aml_parse_length(struct acpi_context *ctx)
d765 1
a765 2
	u_int8_t	lcode;
	int		ival;
d767 3
a769 47
	lcode = aml_parse_int(ctx, AML_BYTE);
	if (lcode <= 0x3f)
		return (lcode);

	ival = lcode & 0xf;
	if (lcode >= 0x40)
		ival |= aml_parse_int(ctx, AML_BYTE) << 4;
	if (lcode >= 0x80)
		ival |= aml_parse_int(ctx, AML_BYTE) << 12;
	if (lcode >= 0xc0)
		ival |= aml_parse_int(ctx, AML_BYTE) << 20;

	return (ival);
}

/* Decode AML Namestring from stream */
const char *
aml_parse_name(struct acpi_context *ctx)
{
	int		count, pfxlen;
	char		*name, *pn;
	u_int8_t	*base;

	pfxlen = 0;
	if (ctx->pos[pfxlen] == AMLOP_ROOTCHAR)
		pfxlen++;

	while (ctx->pos[pfxlen] == AMLOP_PARENTPREFIX)
		pfxlen++;

	switch (ctx->pos[pfxlen]) {
	case 0x00:
		count = 0;
		base  = ctx->pos + pfxlen + 1;
		break;
	case AMLOP_MULTINAMEPREFIX:
		count = ctx->pos[pfxlen + 1];
		base = ctx->pos + pfxlen + 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		base  = ctx->pos + pfxlen + 1;
		break;
	default:
		count = 1;
		base  = ctx->pos + pfxlen;
		break;
d771 8
a778 16

	name = acpi_os_allocmem(pfxlen + count * 5);
	pn = name;

	while (pfxlen--) 
		*(pn++) = *(ctx->pos++);
			    
	/* Copy name segments in chunks of 4 bytes */
	while (count--) {
		memcpy(pn, base, 4);
		if (count) {
			*(pn + 4) = '.';
			pn++;
		}
		pn += 4;
		base += 4;
d780 1
a780 5
	*pn = 0;

	ctx->pos = base;

	return (name);
d783 6
a788 13
/* Is this opcode an encoded name? */
int
aml_isnamedop(u_int16_t opcode)
{
	switch (opcode) {
	case AMLOP_ROOTCHAR:
	case AMLOP_PARENTPREFIX:
	case AMLOP_MULTINAMEPREFIX:
	case AMLOP_DUALNAMEPREFIX:
	case AMLOP_NAMECHAR:
	case 'A'...'Z':
		return (1);
	}
d790 4
a793 6
	return (0);
}

/* * Math eval routines */
u_int64_t
aml_bcd2dec(u_int64_t val)
d795 2
a796 11
	u_int64_t	rval;
	int		n, pos;

	pos = 1;
	for (rval = 0; val; val >>= 4) {
		n = (val & 0xf);
		if (n > 9)
			return (0);

		rval += (n * pos);
		pos *= 10;
d798 5
a802 16

	return (rval);
}

u_int64_t
aml_dec2bcd(u_int64_t val)
{
	u_int64_t	rval;
	int		n, pos;

	pos = 0;
	for (rval = 0; val; val /= 10) {
		n = (val % 10);

		rval += (n << pos);
		pos += 4;
d804 4
a807 79

	return (rval);
}

/* Calculate LSB */
int
aml_lsb(u_int64_t val)
{
	int		lsb;

	if (val == 0) 
		return (0);

	for (lsb = 1; !(val & 0x1); lsb++)
		val >>= 1;

	return (lsb);
}

/* Calculate MSB */
int
aml_msb(u_int64_t val)
{
	int		msb;

	if (val == 0) 
		return (0);

	for (msb = 1; val != 0x1; msb++)
		val >>= 1;

	return (msb);
}

/* Evaluate Math operands */
int64_t
aml_evalmath(u_int16_t opcode, int64_t lhs, int64_t rhs)
{
	dnprintf(50, "evalmath: %s %lld %lld\n", aml_opname(opcode), lhs, rhs);

	switch (opcode) {
	case AMLOP_INCREMENT:
	case AMLOP_ADD:
		return (lhs + rhs);
	case AMLOP_DECREMENT:
	case AMLOP_SUBTRACT:
		return (lhs - rhs);
	case AMLOP_MULTIPLY:
		return (lhs * rhs);
	case AMLOP_DIVIDE:
		return (lhs / rhs);
	case AMLOP_MOD:
		return (lhs % rhs);
	case AMLOP_SHL:
		return (lhs << rhs);
	case AMLOP_SHR:
		return (lhs >> rhs);
	case AMLOP_AND:
		return (lhs & rhs);
	case AMLOP_NAND:
		return ~(lhs & rhs);
	case AMLOP_OR:
		return (lhs | rhs); 
	case AMLOP_NOR:
		return ~(lhs | rhs); 
	case AMLOP_XOR:
		return (lhs ^ rhs);
	case AMLOP_FINDSETLEFTBIT:
		return aml_msb(lhs);
	case AMLOP_FINDSETRIGHTBIT:
		return aml_lsb(lhs);
	case AMLOP_NOT:
		return ~(lhs);
	case AMLOP_TOINTEGER:
		return (lhs);
	case AMLOP_FROMBCD:
		return aml_bcd2dec(lhs);
	case AMLOP_TOBCD:
		return aml_dec2bcd(lhs);
a808 2

	return (0);
d811 4
a814 3
/* Evaluate logical test operands */
int
aml_logicalcmp(u_int16_t opcode, int64_t lhs, int64_t rhs)
d816 2
a817 22
	dnprintf(50, "logicalcmp: %s %lld %lld\n",
	    aml_opname(opcode), lhs, rhs);

	switch(opcode) {
	case AMLOP_LAND:
		return (lhs && rhs);
	case AMLOP_LOR:
		return (lhs || rhs);
	case AMLOP_LNOT:
		return (!lhs);
	case AMLOP_LNOTEQUAL:
		return (lhs != rhs);
	case AMLOP_LLESSEQUAL:
		return (lhs <= rhs);
	case AMLOP_LGREATEREQUAL:
		return (lhs >= rhs);
	case AMLOP_LEQUAL:
		return (lhs == rhs);
	case AMLOP_LGREATER:
		return (lhs > rhs);
	case AMLOP_LLESS:
		return (lhs < rhs);
d819 10
a828 13

	return (0);
}

const char *
aml_opname(int opcode)
{
	struct aml_opcode	*ptab = aml_table;

	while (ptab->opcode != 0xffff) {
		if (ptab->opcode == opcode)
			return ptab->mnem;
		ptab++;
a829 1
	return ("");
d832 2
a833 4
/* Extract opcode from AML bytestream 
 *
 * Some opcodes are multibyte
 * Name strings can also be embedded within the stream
d835 3
a837 2
struct aml_opcode
*aml_getopcode(struct acpi_context *ctx)
d839 2
a840 2
	struct aml_opcode	*ptab;
	u_int16_t		twocode, opcode;
d842 18
a859 6
	/* Check if this is a name object */
	if (aml_isnamedop(*ctx->pos))
		opcode = AMLOP_NAMECHAR;
	else {
		opcode = aml_parse_int(ctx, AML_BYTE);
		twocode = (opcode << 8L) + *ctx->pos;
d861 15
a875 7
		/* Check multi-byte opcodes */
		if (twocode == AMLOP_LNOTEQUAL ||
		    twocode == AMLOP_LLESSEQUAL ||
		    twocode == AMLOP_LGREATEREQUAL ||
		    opcode == AMLOP_EXTPREFIX) {
			opcode = twocode;
			ctx->pos++;
a876 1
	}
d878 7
a884 3
	for (ptab = aml_table; ptab->opcode != 0xffff; ptab++)
		if (ptab->opcode == opcode)
			return (ptab);
d886 10
a895 1
	dnprintf(40, "aml_getopcode: Unknown opcode %.4x\n", opcode);
d897 59
a955 1
	return (NULL);
d958 6
a963 18
/* Test AML_MATCH operation */
int
aml_match(int64_t lhs, int mtype, int64_t rhs)
{
	switch (mtype) {
	case AML_MATCH_TR:
		return (1);
	case AML_MATCH_EQ:
		return (lhs == rhs);
	case AML_MATCH_LT:
		return (lhs < rhs);
	case AML_MATCH_LE:
		return (lhs <= rhs);
	case AML_MATCH_GE:
		return (lhs >= rhs);
	case AML_MATCH_GT:
		return (lhs > rhs);
	}
d965 2
a966 5
	return (0);
}

struct aml_node *
aml_find_name(struct acpi_softc *sc, struct aml_node *root, const char *name)
d968 1
a968 2
	struct aml_node	*ret;
	const char	*sname;
d970 5
a974 3
	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
d976 21
a996 20

	while (*name == AMLOP_PARENTPREFIX) {
		if (root)
			root = root->parent;
		name++;
	}

	if (root == NULL)
		root = &aml_root;

	for (ret = NULL; root && !ret; root = root->sibling) {
		if ((sname = root->name) != NULL) {
			if (*sname == AMLOP_ROOTCHAR)
				sname++;

			while (*sname == AMLOP_PARENTPREFIX)
				sname++;

			if (!strcmp(name, sname))
				return (root);
d998 48
a1045 2
		if (root->child)
			ret = aml_find_name(sc, root->child, name);
a1046 2

	return (ret);
d1049 3
a1051 3
int
aml_eval_name(struct acpi_softc *sc, struct aml_node *root, const char *name,
    struct aml_value *result, struct aml_value *env)
d1053 2
a1054 1
	root = aml_find_name(sc, root, name);
d1056 20
a1075 26
	if (root != NULL) {
		dnprintf(50, "found eval object : %s, %.4x\n",
		    root->name, root->opcode);

		return aml_eval_object(sc, root, result, 0, env);
	}

	return (1);
}

int64_t
aml_str2int(const char *str, int len, int radix)
{
	int64_t		rval, cb;

	rval = 0;
	while (*str && len--) {
		cb = *(str++);
		rval *= radix;
		if (cb >= 'A' && cb <= 'F' && radix == 16)
			rval += (cb - 'A');
		else if (cb >= 'a' && cb <= 'f' && radix == 16)
			rval += (cb - 'a');
		else if (cb >= '0' && cb <= '9')
			rval += (cb - '0');
		else
d1077 3
a1080 2

	return rval;
d1082 2
a1083 5


/*
 * aml_bufcpy copies/shifts buffer data, special case for aligned transfers
 * dstPos/srcPos are bit positions within destination/source buffers
d1085 2
a1086 3
void
aml_bufcpy(u_int8_t *pDst, int dstPos, const u_int8_t *pSrc, int srcPos,
    int len)
d1088 1
a1088 1
	int		idx;
d1090 8
a1097 4
	if (aml_bytealigned(dstPos|srcPos|len)) {
		/* Aligned transfer: use memcpy */
		memcpy(pDst+aml_bytepos(dstPos), pSrc+aml_bytepos(srcPos), aml_bytelen(len));
		return;
d1099 2
a1100 18

	/* Misaligned transfer: perform bitwise copy */
	for (idx = 0; idx < len; idx++)
		aml_setbit(pDst, idx + dstPos, aml_tstbit(pSrc, idx + srcPos));
}

/* Compare two buffers; return comparison type */
int
aml_bufcmp(const u_int8_t *abuf, int alen, const u_int8_t *bbuf, int blen)
{
	int		rc;

	while (alen && blen) {
		rc = *(abuf++) - *(bbuf++);
		if (rc != 0)
			return (rc < 0) ? AMLOP_LLESS : AMLOP_LGREATER;
		alen--;
		blen--;
d1102 1
a1102 2
	return (alen ? AMLOP_LGREATEREQUAL :
	    (blen ?  AMLOP_LLESSEQUAL : AMLOP_LEQUAL));
d1105 2
a1106 6
/*
 * Search list of objects for a name match 
 * Special case for fields: search children only
 */
struct aml_node *
_aml_searchname(struct aml_node *list, const char *name)
d1108 2
a1109 20
	struct aml_node	*child;

	if (list == NULL)
		return (NULL);

	while (list) {
		if (list->opcode == AMLOP_FIELD ||
		    list->opcode == AMLOP_BANKFIELD ||
		    list->opcode == AMLOP_INDEXFIELD)
			if ((child = _aml_searchname(list->child, name)) !=
			    NULL)
				return child;

		if (list->name && !strncmp(list->name, name, AML_NAMESEG_LEN))
			return (list);

		list = list->sibling;
	}

	return (NULL);
d1112 2
a1113 3
/* Create name references in tree, even if not initialized */
struct aml_node *
aml_doname(struct aml_node *root, const char *name, int create)
d1115 1
a1115 1
	struct aml_node	*tmp;
d1117 3
a1119 3
	if (*name == AMLOP_ROOTCHAR) {
		name++;
		root = &aml_root;
d1121 13
a1133 5

	while (*name == AMLOP_PARENTPREFIX) {
		name++;
		if ((root = root->parent) == NULL)
			return (NULL);
d1135 1
a1135 45

	if (root == NULL)
		root = &aml_root;

	if (*name && name[AML_NAMESEG_LEN] == '\0' && !create) {
		do {
			tmp = _aml_searchname(root->child, name);
			root = root->parent;
		} while (tmp == NULL && root != NULL);
		return tmp;
	}

	for (tmp = root; tmp && *name; name += AML_NAMESEG_LEN) {
		if (*name == '.')
			name++;

		tmp = _aml_searchname(root->child, name);

		/* Create name if queried */
		if (tmp == NULL && create) {
			tmp = aml_create_node(root, -1, "DUMMY", root->start);
			if (tmp != NULL) {
				tmp->name = acpi_os_allocmem(
				    AML_NAMESEG_LEN + 1);
				if (tmp->name)
					memcpy((char *)tmp->name, name,
					    AML_NAMESEG_LEN);
			}
		}
		root = tmp;
	}

	return (tmp);
}

struct aml_node *
aml_createname(struct aml_node *root, const char *name)
{
	return aml_doname(root, name, 1);
}

struct aml_node *
aml_searchname(struct aml_node *root, const char *name)
{
	return aml_doname(root, name, 0);
d1139 1
a1139 1
aml_ederef(struct acpi_context *ctx, struct aml_value *val)
d1141 1
a1141 3
	struct aml_node		*pn;
	struct aml_value	*ref;
	int64_t			i1;
d1143 8
a1150 4
	if (val == NULL)
		return NULL;

	switch (val->type) {
d1152 2
a1153 9
		if (val->v_objref.ref == NULL)
			if ((pn = aml_searchname(ctx->scope, val->name)) !=
			    NULL)
				val->v_objref.ref = pn->value;

		if (val->v_objref.ref != NULL)
			return aml_ederef(ctx, val->v_objref.ref);

		return (NULL);
d1155 22
a1176 26
		i1 = val->v_objref.index;
		ref = aml_ederef(ctx, val->v_objref.ref);
		if (ref == NULL)
			return (NULL);

		if (i1 == -1)
			return aml_ederef(ctx, ref);

		if (i1 > ref->length)
			aml_resizevalue(ref, i1);

		switch (ref->type) {
		case AML_OBJTYPE_PACKAGE:
			if (ref->v_package[i1] == NULL) {
				/* Lazy allocate package */
				dnprintf(40, "LazyPkg: %lld/%d\n", i1,
				    ref->length);
				ref->v_package[i1] = aml_allocvalue(
				    AML_OBJTYPE_UNINITIALIZED, 0, NULL);
			}
			return (ref->v_package[i1]);
		case AML_OBJTYPE_BUFFER:
			return aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 8,
			    ref->v_buffer+i1);
		default:
			dnprintf(50,"Unknown refof\n");
a1177 1

d1180 1
a1180 2

	return (val);
d1183 2
a1184 2
uint64_t
aml_get_pciaddr(struct acpi_context *ctx, struct aml_node *node)
d1186 1
a1186 3
	struct aml_node	*pn;
	uint8_t		bus, dev, fn;
	uint64_t	ioaddr;
d1188 33
a1220 13
	if ((pn = aml_searchname(node, "_ADR")) == NULL) 
		return (0xffff);

	/* _ADR holds <dev>:<fn> */
	ioaddr = aml_val2int(ctx, pn->value);
	fn  = ioaddr & 0xffff;
	dev = ioaddr >> 16;
	bus = 0;

	if ((pn = aml_searchname(node, "_BBN")) != NULL) /* _BBN holds <bus> */
		bus = aml_val2int(ctx, pn->value);

	return ACPI_PCI_ADDR(bus, dev, fn, 0);
d1223 4
a1226 3
struct aml_value *
aml_efield(struct acpi_context *ctx, struct aml_value *e_fld,
    struct aml_value *rhs)
d1228 2
a1229 6
	struct aml_value	*e_rgn;
	struct aml_value	*rv;
	struct aml_value	tmp;
	uint8_t			*pb;
	uint64_t		ioaddr;
	int			blen;
d1231 5
a1235 3
	dnprintf(80, "efield %s: ", rhs ? "set" : "get");
	aml_showvalue(e_fld);
	aml_showvalue(rhs);
d1237 2
a1238 14
	tmp.type = AML_OBJTYPE_INTEGER;
	switch (e_fld->v_field.type) {
	case AMLOP_INDEXFIELD:
		/*
		 * Set INDEX value to FIELD position byte,
		 * then write RHS to DATA
		 */
		if (!aml_bytealigned(e_fld->v_field.bitpos)) {
			dnprintf(40, "aml_efield: INDEXFIELD not "
			    "byte-aligned..\n");
		}
		tmp.v_integer = aml_bytepos(e_fld->v_field.bitpos);
		aml_efield(ctx, e_fld->v_field.ref1, &tmp);
		return aml_efield(ctx, e_fld->v_field.ref2, rhs);
d1240 17
a1256 48
	case AMLOP_BANKFIELD:
		/* Set bank value */
		tmp.v_integer = e_fld->v_field.ref3;
		aml_efield(ctx, e_fld->v_field.ref2, &tmp);
		return aml_efield(ctx, e_fld->v_field.ref2, rhs);

	case AMLOP_FIELD:
		/* e_rgn should be OPREGION */
		e_rgn = aml_ederef(ctx, e_fld->v_field.ref1);
		if (e_rgn == NULL)
			return NULL;
		if (e_rgn->type != AML_OBJTYPE_OPREGION) {
			dnprintf(40, "aml_efield: Wrong FIELD type!\n");
			return (NULL);
		}

		ioaddr = e_rgn->v_opregion.iobase +
		    aml_bytepos(e_fld->v_field.bitpos);

		blen = aml_bytelen(e_fld->v_field.bitlen);
		pb = acpi_os_allocmem(blen+8); /* padded space */
		if (rhs == NULL) {
			rv = aml_allocvalue(AML_OBJTYPE_BUFFER, blen, NULL);

			/* Read field XXX don't need pb if aligned */
			if (aml_valid(rv)) {
				if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
					acpi_mutex_acquire(ctx,
					    aml_global_lock, -1);
				}
				acpi_gasio(ctx->sc, ACPI_IOREAD,
				   e_rgn->v_opregion.iospace, ioaddr,
				   AML_FIELD_ACCESS(e_fld->v_field.flags),
				   blen, pb);

				if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
					acpi_mutex_release(ctx,
					    aml_global_lock);
				}
			}
			if (pb != rv->v_buffer) {
				aml_bufcpy(rv->v_buffer, 0, pb,
				    aml_bitpos(e_fld->v_field.bitpos),
				    e_fld->v_field.bitlen);

				acpi_os_freemem(pb);
			}
			return (rv);
d1258 7
a1264 4
    
		/* Write field */
		if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
			acpi_mutex_acquire(ctx, aml_global_lock, -1);
d1266 2
a1267 24

		switch (AML_FIELD_UPDATE(e_fld->v_field.flags)) {
		case AML_FIELD_PRESERVE:
#if 0
			/* XXX: fix length, don't read if whole length */
			dnprintf(40, "old iobase = %llx,%lx\n", 
			    e_rgn->v_opregion.iobase,
			    aml_bytepos(e_fld->v_field.bitpos));
			    
			acpi_gasio(ctx->sc, ACPI_IOREAD,
			    e_rgn->v_opregion.iospace, ioaddr,
			    AML_FIELD_ACCESS(e_fld->v_field.flags),
			    blen, pb);
#if 0
			aml_showvalue(rv);
#endif
#endif
			break;
		case AML_FIELD_WRITEASONES:
			memset(pb, 0xff, blen + 8);
			break;
		case AML_FIELD_WRITEASZEROES:
			memset(pb, 0x00, blen + 8);
			break;
d1269 3
a1271 18

		rv = aml_val2buf(ctx, rhs, blen);

		aml_bufcpy(pb, aml_bitpos(e_fld->v_field.bitpos),
		    rv->v_buffer, 0, e_fld->v_field.bitlen);

		if (rv != rhs)
			aml_freevalue(&rv);

		acpi_gasio(ctx->sc, ACPI_IOWRITE,
		   e_rgn->v_opregion.iospace,
		   e_rgn->v_opregion.iobase +
		   aml_bytepos(e_fld->v_field.bitpos),
		   AML_FIELD_ACCESS(e_fld->v_field.flags),
		   blen, pb);

		if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
			acpi_mutex_release(ctx, aml_global_lock);
a1272 2

		acpi_os_freemem(pb);
d1274 14
a1287 9
	default:
		/* This is a buffer field */
		e_rgn = aml_ederef(ctx, e_fld->v_field.ref1);
		if (e_rgn == NULL)
			return (NULL);

		if (e_rgn->type != AML_OBJTYPE_BUFFER) {
			dnprintf(40, "aml_efield: Wrong type!\n");
			return (NULL);
d1289 3
a1291 10

		blen = aml_bytelen(e_fld->v_field.bitlen);
		if (rhs == NULL) {
			/* Read buffer */
			rv = aml_allocvalue(AML_OBJTYPE_BUFFER, blen, NULL);
			if (aml_valid(rv))
				aml_bufcpy(rv->v_buffer, 0, 
				    e_rgn->v_buffer, e_fld->v_field.bitpos, 
				    e_fld->v_field.bitlen);
			return (rv);
d1293 4
a1296 9

		/* Write buffer */
		rv = aml_val2buf(ctx, rhs, blen);
		aml_bufcpy(e_rgn->v_buffer, e_fld->v_field.bitpos, 
		    rv->v_buffer, 0, 
		    e_fld->v_field.bitlen);

		if (rv != rhs)
			aml_freevalue(&rv);
a1298 2

	return (NULL);
d1301 5
d1307 1
a1307 1
aml_val2buf(struct acpi_context *ctx, struct aml_value *oval, int mlen)
d1309 1
a1309 1
	struct aml_value	*pb, *val;
d1311 7
a1317 2
	if (val == NULL)
		return (NULL);
d1319 5
a1323 1
	val = aml_ederef(ctx, oval);
d1325 1
a1325 1
		return (NULL);
d1327 3
d1331 9
a1339 9
		if (mlen < val->length)
			mlen = val->length;

		pb = aml_allocvalue(AML_OBJTYPE_BUFFER, mlen, NULL);
		if (val->v_buffer && val->length)
			memcpy(pb->v_buffer, val->v_buffer, val->length);

		return (pb);

d1342 3
a1344 13
		return aml_efield(ctx, val, NULL);

	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
		return aml_allocvalue(AML_OBJTYPE_BUFFER, 8, &val->v_integer);

	case AML_OBJTYPE_STRING:
		return aml_allocvalue(AML_OBJTYPE_BUFFER, val->length,
		    val->v_string);

	default:
		dnprintf(40, "Unknown val2buf : %d\n", val->type);
		return (NULL);
d1346 2
d1350 3
a1352 2
int64_t
aml_val2int(struct acpi_context *ctx, struct aml_value *val)
d1354 3
a1356 2
	struct aml_value	*pb;
	int64_t			rval;
d1358 8
a1365 4
	pb = NULL;
	if (val == NULL) {
		dnprintf(40, "null val2int\n");
		return 0;
d1367 1
a1367 6
	rval = 0;
	switch (val->type) {
	case AML_OBJTYPE_BUFFER:
		if (val->length < 8)
			memcpy(&rval, val->v_buffer, val->length);
		return (rval);
d1369 3
a1371 3
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_INTEGER:
		return (val->v_integer);
d1373 21
a1393 10
	case AML_OBJTYPE_STRING:
		if (val->v_string != NULL) {
			if (!strncmp(val->v_string, "0x", 2))
				rval = aml_str2int(val->v_string + 2,
				    val->length, 16);
			else
				rval = aml_str2int(val->v_string,
				    val->length, 10);
		}
		return (rval);
d1395 2
a1396 21
	case AML_OBJTYPE_NAMEREF:
	case AML_OBJTYPE_OBJREF:
		if (ctx == NULL)
			return (0);
		pb = aml_ederef(ctx, val);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		if (ctx == NULL)
			return (0);
		pb = aml_efield(ctx, val, NULL);
		break;
	case AML_OBJTYPE_METHOD:
		if (ctx == NULL)
			return 0;
		pb = aml_domethod(ctx, val, -1, NULL);
		break;
	default:
		dnprintf(40, "Unknown val2int: %x\n", val->type);
		break;
	}
d1398 2
a1399 2
	if (pb != NULL)
		return aml_val2int(ctx, pb);
d1401 1
a1401 1
	return (0);
d1404 3
a1406 3
struct aml_node *
aml_addvname(struct acpi_context *ctx, const char *name, int opcode,
	     struct aml_value *val)
d1408 4
a1411 1
	struct aml_node *pn;
d1413 4
a1416 19
	pn = aml_createname(ctx->scope, name);
	pn->opcode = opcode;
	pn->mnem   = aml_opname(opcode);
	if (val != NULL) {
		if (val->type == AML_OBJTYPE_STATICINT)
			val = aml_allocvalue(AML_OBJTYPE_INTEGER, val->v_integer, NULL);
		val->name = name;
		val->node = pn;
	}
	if (pn->value) {
		dnprintf(40, "addvname: error, already set!\n");
		aml_freevalue(&pn->value);
	}
	pn->value = val;
#if 0
	aml_showvalue(val);
	dnprintf(40, "\n");
#endif
	return pn;
d1419 3
a1421 3
/* Parse package length & return pointer to end of package */
u_int8_t *
aml_eparselen(struct acpi_context *ctx)
d1423 65
a1487 1
	u_int8_t *pos = ctx->pos;
d1489 1
a1489 1
	return pos + aml_parse_length(ctx);
d1492 2
a1493 3
/* Parse integer value */
int64_t
aml_eparseint(struct acpi_context *ctx, int type)
d1495 1
a1495 2
	struct aml_value *rv;
	int64_t rval;
d1497 5
a1501 9
	if (type == AML_ANYINT) {
		/* special case: parse integers directly from bytestream
		 * this saves an additional alloc/free 
		 */
		switch (*ctx->pos) {
		case AMLOP_ZERO:
		case AMLOP_ONE:
		case AMLOP_ONES:
			type = AML_BYTE;
d1503 4
a1506 3
		case AMLOP_BYTEPREFIX:
			ctx->pos++;
			type = AML_BYTE;
d1508 4
a1511 16
		case AMLOP_WORDPREFIX:
			ctx->pos++;
			type = AML_WORD;
			break;
		case AMLOP_DWORDPREFIX:
			ctx->pos++;
			type = AML_DWORD;
			break;
		case AMLOP_QWORDPREFIX:
			ctx->pos++;
			type = AML_QWORD;
			break;
		default:
			rv = aml_eparseval(ctx, 1);
			rval = aml_val2int(ctx, rv);
			aml_freevalue(&rv);
d1515 5
a1519 3
	if (type != AML_ANYINT) {
		/* Type may have changed here parse byte directly */
		rval = aml_parse_int(ctx, type);
d1521 4
a1524 1
	return rval;
d1527 3
a1529 4
/* Create field unit 
 *   AMLOP_FIELD
 *   AMLOP_INDEXFIELD
 *   AMLOP_BANKFIELD
d1531 3
a1533 3

struct aml_value *
aml_parse_fieldunit(struct acpi_context *ctx, int opcode)
d1535 3
a1537 3
	u_int8_t *end;
	int attr, access;
	struct aml_value *rv, tmp;
d1539 4
a1542 19
	/* Create field template */
	memset(&tmp, 0, sizeof(tmp));
	tmp.type = AML_OBJTYPE_FIELDUNIT;
	tmp.v_field.type = opcode;

	end = aml_eparselen(ctx);
	switch (opcode) {
	case AMLOP_FIELD:
		tmp.v_field.ref1 = aml_eparseval(ctx, 1);
		break;
	case AMLOP_INDEXFIELD:
		tmp.v_field.ref1 = aml_eparseval(ctx, 0);
		tmp.v_field.ref2 = aml_eparseval(ctx, 0);
		break;
	case AMLOP_BANKFIELD:
		tmp.v_field.ref1 = aml_eparseval(ctx, 0);
		tmp.v_field.ref2 = aml_eparseval(ctx, 0);
		tmp.v_field.ref3 = aml_eparseint(ctx, AML_ANYINT);
		break;
a1543 12
	tmp.v_field.flags = aml_parse_int(ctx, AML_BYTE);

	while (ctx->pos < end) {
		switch (*ctx->pos) {
		case AML_FIELD_RESERVED:
			ctx->pos++;
			tmp.v_field.bitlen = aml_parse_length(ctx);
			break;
		case AML_FIELD_ATTRIB:
			ctx->pos++;
			access = aml_parse_int(ctx, AML_BYTE);
			attr   = aml_parse_int(ctx, AML_BYTE);
d1545 3
a1547 13
			tmp.v_field.flags &= ~AML_FIELD_ACCESSMASK;
			tmp.v_field.flags |= (access & AML_FIELD_ACCESSMASK);
			break;
		default:
			tmp.name = aml_parse_name(ctx);
			tmp.v_field.bitlen = aml_parse_length(ctx);
			rv = aml_copyvalue(&tmp);
			aml_addvname(ctx, tmp.name, opcode, rv);
			break;
		}
		tmp.v_field.bitpos += tmp.v_field.bitlen;
	}
	return NULL;
d1550 4
a1553 7
/* Create buffer field object
 *   AMLOP_CREATEFIELD
 *   AMLOP_CREATEBITFIELD
 *   AMLOP_CREATEBYTEFIELD
 *   AMLOP_CREATEWORDFIELD
 *   AMLOP_CREATEDWORDFIELD
 *   AMLOP_CREATEQWORDFIELD
d1556 11
a1566 3
aml_parse_bufferfield(struct acpi_context *ctx, int size, int bitlen, int opcode)
{
	struct aml_value *rv;
d1568 17
a1584 7
	rv = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL);
	if (aml_valid(rv)) {
		rv->v_field.type = opcode;
		rv->v_field.ref1 = aml_eparseval(ctx, 1);
		rv->v_field.bitpos = aml_eparseint(ctx, AML_ANYINT) * size;
		rv->v_field.bitlen = (opcode == AMLOP_CREATEFIELD) ?
			aml_eparseint(ctx, AML_ANYINT) : bitlen;
d1586 1
a1586 3
		aml_addvname(ctx, aml_parse_name(ctx), opcode, rv);
	}
	return rv;
d1589 10
a1598 4
/* Set node value */
struct aml_value *
aml_esetnodevalue(struct acpi_context *ctx,  struct aml_value *lhs,
		  struct aml_value *rhs, int64_t rval)
d1600 1
a1600 1
	struct aml_value *tmp;
d1602 4
a1605 3
	if (rhs == NULL) {
		rhs = aml_allocint(rval);
	}
d1607 9
a1615 13
	dnprintf(50, "------------ SET NODE VALUE -------------\n");
	dnprintf(50, "new    : ");
	aml_showvalue(rhs);
	dnprintf(50, "current: ");
	aml_showvalue(lhs);

	tmp = aml_ederef(ctx, lhs);
	if (tmp == NULL)
		return (NULL);
	switch (tmp->type) {
	case AML_OBJTYPE_UNINITIALIZED:
		/* Object is not initialized */
		*tmp = *rhs;
d1617 14
a1630 7
        case AML_OBJTYPE_DEBUGOBJ:
		dnprintf(1, "debug object: ");
		aml_showvalue(rhs);
		break;
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		aml_efield(ctx, tmp, rhs);
d1632 1
a1632 2
	case AML_OBJTYPE_STATICINT:
		/* Read-only */
a1633 4
	default:
		/* Object is already initialized, free old value */
		_aml_freevalue(tmp);
		*tmp = *rhs;
d1635 1
a1635 6
	aml_showvalue(tmp);
	if (tmp != lhs) {
		aml_freevalue(&tmp);
	}
	dnprintf(50, "--------- post set ----------\n");
	return rhs;
d1638 3
a1640 6
/* Parse scoped object
 *   AMLOP_SCOPE
 *   AMLOP_DEVICE
 *   AMLOP_POWERRSRC
 *   AMLOP_PROCESSOR
 *   AMLOP_THERMALZONE
d1642 4
a1645 4
struct aml_value *
aml_eparsescope(struct acpi_context *ctx, const char *name, u_int8_t *end,
		struct aml_opcode *opc,
		struct aml_value *val)
d1647 1
a1647 10
	struct aml_node *oldscope;
	struct aml_value *rv;

	oldscope = ctx->scope;
	ctx->scope = aml_addvname(ctx, name, opc->opcode, val);

	rv = aml_eparselist(ctx, end, 0);

	ctx->scope = oldscope;
	return rv;
d1650 2
a1651 3
/* Parse list of objects */
struct aml_value *
aml_eparselist(struct acpi_context *ctx, u_int8_t *end, int deref)
d1653 4
a1656 6
	struct aml_value *rv;
  
	rv = NULL;
	while (ctx->pos && ctx->pos < end) {
		aml_freevalue(&rv);
		rv = aml_eparseval(ctx, deref);
a1657 1
	return rv;
d1660 2
a1661 3
/* Parse AMLOP_CONCAT */
struct aml_value *
aml_doconcat(struct acpi_context *ctx)
d1663 1
a1663 32
	struct aml_value  *lhs, *rhs, *set, *tmp;

	lhs = aml_eparseval(ctx, 1);
	rhs = aml_eparseval(ctx, 1);
	set = aml_eparseval(ctx, 1);
	if (lhs == NULL || rhs == NULL || lhs->type != rhs->type) {
		return NULL;
	}
	switch (lhs->type) {
	case AML_OBJTYPE_STRING:
		tmp = aml_allocvalue(AML_OBJTYPE_STRING,
				     lhs->length+rhs->length, NULL);
		if (tmp != NULL) {
			strlcpy(tmp->v_string, lhs->v_string, lhs->length);
			strlcat(tmp->v_string, rhs->v_string, rhs->length);
			return aml_esetnodevalue(ctx, set, tmp, 0);
		}
		break;
	case AML_OBJTYPE_BUFFER:
		tmp = aml_allocvalue(AML_OBJTYPE_BUFFER,
				     lhs->length+rhs->length, NULL);
		if (tmp != NULL) {
			memcpy(tmp->v_buffer, lhs->v_buffer, lhs->length);
			memcpy(tmp->v_buffer+lhs->length, rhs->v_buffer, rhs->length);
			return aml_esetnodevalue(ctx, set, tmp, 0);
		}
		break;
	default:
		dnprintf(50, "aml_doconcat: wrong type %.4x\n", lhs->type);
		break;
	}
	return NULL;
d1666 4
a1669 3
/* Parse AMLOP_IF/AMLOP_ELSE block */
struct aml_value *
aml_doif(struct acpi_context *ctx)
d1671 1
a1671 3
	struct aml_value *rv;
	u_int8_t *end;
	int64_t	 i1;
d1673 6
a1678 15
	rv  = NULL;
	end = aml_eparselen(ctx);
	i1  = aml_eparseint(ctx, AML_ANYINT);
	dnprintf(40, "evalif: %lld\n", i1);

	if (i1 != 0) {
		/* Parse IF block */
		rv = aml_eparselist(ctx, end, 1);
	}
	if (ctx->pos != NULL && *end == AMLOP_ELSE) {
		/* Parse ELSE block */
		ctx->pos = ++end;
		end = aml_eparselen(ctx);
		if (i1 == 0) {
			rv = aml_eparselist(ctx, end, 1);
d1680 2
d1683 1
a1683 4
	if (ctx->pos != NULL) {
		ctx->pos = end;
	}
	return rv;
d1686 11
a1696 3
/* Parse AMLOP_WHILE/AMLOP_BREAK/AMLOP_CONTINUE block */
struct aml_value *
aml_dowhile(struct acpi_context *ctx)
d1698 2
a1699 3
	u_int8_t *start, *end;
	struct aml_value *rv;
	int64_t i1;
d1701 9
a1709 28
	end   = aml_eparselen(ctx);
	start = ctx->pos;

	rv = NULL;
	for(;;) {
		if (ctx->pos == end) {
			ctx->pos = start;
		}
		/* Perform test condition */
		if (ctx->pos == start) {
			i1 = aml_eparseint(ctx, AML_ANYINT);
			dnprintf(40, "whiletest: %lld\n", i1);
			if (i1 == 0) {
				break;
			}
		}
		if (ctx->pos == NULL || *ctx->pos == AMLOP_BREAK) {
			dnprintf(40, "break\n");
			break;
		}
		else if (*ctx->pos == AMLOP_CONTINUE) {
			dnprintf(40, "continue\n");
			ctx->pos = start;
		}
		else {
			aml_freevalue(&rv);
			rv = aml_eparseval(ctx, 1);
		}
d1711 7
a1717 2
	if (ctx->pos != NULL) {
		ctx->pos = end;
d1719 2
a1720 1
	return rv;
d1723 3
a1725 4
/* Call AML Method */
struct aml_value *
aml_domethod(struct acpi_context *ctx, struct aml_value *val,
	     int argc, struct aml_value **argv)
d1727 1
a1727 6
	int64_t i1, i2;
	struct aml_value **newarg, **oldarg;
	struct aml_value **newloc, **oldloc;
	struct aml_node *oldscope;
	struct aml_value *rv;
	u_int8_t *oldpos;
d1729 2
a1730 3
	if (val->type != AML_OBJTYPE_METHOD) {
		dnprintf(40, "aml_domethod: Invalid type\n");
	}
d1732 12
a1743 8
	i2 = AML_METHOD_ARGCOUNT(val->v_method.flags);
	newarg = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *) * AML_MAX_ARG);
	newloc = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *) * AML_MAX_LOCAL);

	/* Parse arguments */
	dnprintf(40, "Get %lld arguments for %s\n", i2, val->name);
	for (i1 = 0; i1<i2; i1++) {
		newarg[i1] = aml_eparseval(ctx, 0);
d1745 2
d1748 5
a1752 5
	/* Save old parse position, call method */
	oldscope = ctx->scope;
	oldarg = ctx->args;
	oldloc = ctx->locals;
	oldpos = ctx->pos;
d1754 17
a1770 10
	ctx->pos = val->v_method.start;
	ctx->args = newarg;
	ctx->locals = newloc;
	ctx->scope = val->node;

#if 0
	dnprintf(40,"\nCall %s: (%lld args)\n", val->name, i2);
	for (i1 = 0; i1<i2; i1++) {
		dnprintf(40,"  arg%lld: ", i1);
		aml_showvalue(newarg[i1]);
d1772 2
a1773 1
#endif
d1775 6
a1780 13
	rv = aml_eparselist(ctx, val->v_method.end, 1);

	ctx->pos = oldpos;
	ctx->args = oldarg;
	ctx->locals = oldloc;
	ctx->scope = oldscope;

#if 0
	dnprintf(40, "Returned from %s\n", val->name);
	aml_showvalue(rv);
#endif

	aml_delchildren(ctx, val->node);
d1782 5
a1786 2
	for (i1=0; i1<8; i1++) {
		aml_freevalue(&newloc[i1]);
d1788 1
a1788 5
	for (i1=0; i1<i2; i1++) {
		aml_freevalue(&newarg[i1]);
	}
	return rv;
  
d1791 2
a1792 2
/* Handle AMLOP_LOAD
 * XXX: Implement this
d1794 7
a1800 2
struct aml_value *
aml_doloadtable(struct acpi_context *ctx)
d1802 17
a1818 8
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	aml_eparseval(ctx, 1);
	return NULL;
d1821 2
a1822 3
/* Handle AMLOP_MID */
struct aml_value *
aml_domid(struct acpi_context *ctx)
d1824 2
a1825 2
	struct aml_value *rhs, *lhs, *rv;
	int64_t i1, i2;
d1827 11
a1837 24
	rhs = aml_eparseval(ctx, 1);
	i1  = aml_eparseint(ctx, AML_ANYINT);  // index
	i2  = aml_eparseint(ctx, AML_ANYINT);  // length
	lhs = aml_eparseval(ctx, 1);
	if (aml_valid(rhs)) {
		switch (rhs->type) {
		case AML_OBJTYPE_STRING:
			/* Validate index is within range */
			if (i1 >= rhs->length) 
				i1 = i2 = 0;
			if (i1+i2 >= rhs->length) 
				i2 = rhs->length - i1;
			rv = aml_allocvalue(AML_OBJTYPE_STRING, i2, rhs->v_string + i1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
			break;
		case AML_OBJTYPE_BUFFER:
			if (i1 >= rhs->length) 
				i1 = i2 = 0;
			if (i1+i2 >= rhs->length) 
				i2 = rhs->length - i1;
			rv = aml_allocvalue(AML_OBJTYPE_BUFFER, i2, rhs->v_buffer + i1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
			break;
		}
a1838 3
	aml_freevalue(&lhs);
	aml_freevalue(&rhs);
	return rv;
d1841 3
a1843 6
/* Handle AMLOP_MATCH 
 *
 * AMLOP_MATCH searches a package for an integer match
 */
struct aml_value *
aml_domatch(struct acpi_context *ctx)
d1845 1
a1845 2
	struct aml_value *lhs, *rv;
	int64_t op1, op2, mv1, mv2, idx, mval;
d1847 8
a1854 18
	lhs = aml_eparseval(ctx, 1);
	op1 = aml_eparseint(ctx, AML_BYTE);
	mv1 = aml_eparseint(ctx, AML_ANYINT);
	op2 = aml_eparseint(ctx, AML_BYTE);
	mv2 = aml_eparseint(ctx, AML_ANYINT);
	idx = aml_eparseint(ctx, AML_ANYINT);

	/* ASSERT: lhs is package */
	rv = aml_allocint(-1);
	if (lhs->type == AML_OBJTYPE_PACKAGE) {
		for (; idx < lhs->length; idx++) {
			mval = aml_val2int(ctx, lhs->v_package[idx]);
			if (aml_match(mval, op1, mv1) && aml_match(mval, op2, mv2)) {
				/* Found match.. set index into result */
				rv->v_integer = idx;
				break;
			}
		}
a1855 2
	aml_freevalue(&lhs);
	return rv;
d1858 2
a1859 7

/* Parse AMLOP_XXXX
 *
 * This is the guts of the evaluator
 */
struct aml_value *
aml_eparseval(struct acpi_context *ctx, int deref)
d1861 7
a1867 38
	struct aml_opcode *opc;
	struct aml_node   *node;
	struct aml_value  *lhs, *rhs, *tmp, *rv;
	u_int8_t *end, *start;
	const char *name;
	int64_t i1, i2;

	rhs = NULL;
	lhs = NULL;
	tmp = NULL;
	rv  = NULL;

	/* Allocate a new instruction, get opcode, etc */
	start = ctx->pos;
	opc = aml_getopcode(ctx);

	dnprintf(40, "### %2d %.4x %s\n",
		 ctx->depth, opc->opcode, opc->mnem);

	ctx->depth++;
	end = NULL;
	switch (opc->opcode) {
	case AMLOP_NAMECHAR:
		name = aml_parse_name(ctx);
		rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, (char *)name);
		if ((rhs = aml_ederef(ctx, rv)) != NULL) {
			if (rhs->type == AML_OBJTYPE_METHOD) {
				lhs = rhs;
				rv = aml_domethod(ctx, rhs, -1, NULL);
			}
			else {
				rv = rhs;
				rhs = NULL;
			}
		}
		break;
	case AMLOP_NOP:
		break;
d1869 1
a1869 1
		rv = aml_allocvalue(AML_OBJTYPE_STATICINT, 0, NULL);
d1872 1
a1872 1
		rv = aml_allocvalue(AML_OBJTYPE_STATICINT, 1, NULL);
d1875 1
a1875 1
		rv = aml_allocvalue(AML_OBJTYPE_STATICINT, -1, NULL);
d1878 1
a1878 1
		rv = aml_allocvalue(AML_OBJTYPE_STATICINT, AML_REVISION, NULL);
d1881 2
a1882 1
		rv = aml_allocint(aml_eparseint(ctx, AML_BYTE));
d1885 2
a1886 1
		rv = aml_allocint(aml_eparseint(ctx, AML_WORD));
d1889 2
a1890 1
		rv = aml_allocint(aml_eparseint(ctx, AML_DWORD));
d1893 2
a1894 1
		rv = aml_allocint(aml_eparseint(ctx, AML_QWORD));
d1896 27
a1922 43
	case AMLOP_STRINGPREFIX:
		rv = aml_allocstr(aml_parse_string(ctx));
		break;
	case AMLOP_FIELD:
	case AMLOP_INDEXFIELD:
	case AMLOP_BANKFIELD:
		rv = aml_parse_fieldunit(ctx, opc->opcode);
		break;
	case AMLOP_CREATEFIELD:
		rv = aml_parse_bufferfield(ctx, 1, -1, opc->opcode);
		break;
	case AMLOP_CREATEBITFIELD:
		rv = aml_parse_bufferfield(ctx, 1,  1, opc->opcode);
		break;
	case AMLOP_CREATEBYTEFIELD:
		rv = aml_parse_bufferfield(ctx, 8,  8, opc->opcode);
		break;
	case AMLOP_CREATEWORDFIELD:
		rv = aml_parse_bufferfield(ctx, 8, 16, opc->opcode);
		break;
	case AMLOP_CREATEDWORDFIELD:
		rv = aml_parse_bufferfield(ctx, 8, 32, opc->opcode);
		break;
	case AMLOP_CREATEQWORDFIELD:
		rv = aml_parse_bufferfield(ctx, 8, 64, opc->opcode);
		break;
	case AMLOP_DEBUG:
		rv = aml_allocvalue(AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		break;
	case AMLOP_BUFFER:
		end = aml_eparselen(ctx);
		i2  = aml_eparseint(ctx, AML_ANYINT);  // requested length
		i1  = end - ctx->pos;		       // supplied length
		dnprintf(40, "buffer: %lld of %lld\n", i1, i2);
		if (i2 < i1)
			i2 = i1;
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, i2, NULL);
		if (i1 > 0)
			memcpy(rv->v_buffer, ctx->pos, i1);
		break;
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		end = aml_eparselen(ctx);
d1924 7
a1930 37
		/* AMLOP_PACKAGE has fixed length, AMLOP_VARPACKAGE is variable */
		i2 = aml_eparseint(ctx, (opc->opcode == AMLOP_PACKAGE) ?
				   AML_BYTE : AML_ANYINT);

		rv = aml_allocvalue(AML_OBJTYPE_PACKAGE, i2, NULL);
		for (i1=0; i1 < i2 && ctx->pos < end; i1++)
			rv->v_package[i1] = aml_eparseval(ctx, 0);
		dnprintf(40, "package: %lld of %lld parsed\n", i1, i2);
		break;
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		i1 = opc->opcode - AMLOP_LOCAL0;
		if (ctx->locals[i1] == NULL) {
			/* Lazy allocate LocalX */
			dnprintf(40, "LazyLocal%lld\n", i1);
			ctx->locals[i1] = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
		}
		rv = ctx->locals[i1];
		break;
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		i1 = opc->opcode - AMLOP_ARG0;
		if (ctx->args[i1] == NULL) {
			/* Lazy allocate ArgX - shouldn't happen? */
			dnprintf(40, "LazyArg%lld\n", i1);
			ctx->args[i1] = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
d1932 1
a1932 1
		rv = ctx->args[i1];
d1934 6
d1941 21
a1961 75
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		lhs = aml_eparseval(ctx, 1);
		i1  = aml_val2int(ctx, lhs);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_evalmath(opc->opcode, i1, 1));
		break;
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
	case AMLOP_TOINTEGER:
	case AMLOP_FROMBCD:
	case AMLOP_TOBCD:
	case AMLOP_NOT:
		i1  = aml_eparseint(ctx, AML_ANYINT);
		lhs = aml_eparseval(ctx, 1);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_evalmath(opc->opcode, i1, 0));
		break;
	case AMLOP_DIVIDE:
		i1  = aml_eparseint(ctx, AML_ANYINT);
		i2  = aml_eparseint(ctx, AML_ANYINT);

		/* Set remainder */
		tmp = aml_eparseval(ctx, 1);
		rhs = aml_esetnodevalue(ctx, tmp, NULL, aml_evalmath(AMLOP_MOD, i1, i2));

		/* Set quotient */
		lhs = aml_eparseval(ctx, 1);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_evalmath(AMLOP_DIVIDE, i1, i2));
		break;
	case AMLOP_ADD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_OR:
	case AMLOP_XOR:
	case AMLOP_NOR:
	case AMLOP_MOD:
		i1  = aml_eparseint(ctx, AML_ANYINT);
		i2  = aml_eparseint(ctx, AML_ANYINT);
		lhs = aml_eparseval(ctx, 1);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_evalmath(opc->opcode, i1, i2));
		break;
	case AMLOP_LAND:
	case AMLOP_LOR:
		i1 = aml_eparseint(ctx, AML_ANYINT);
		i2 = aml_eparseint(ctx, AML_ANYINT);
		rv = aml_allocint(aml_logicalcmp(opc->opcode, i1, i2));
		break;
	case AMLOP_LNOT:
		i1 = aml_eparseint(ctx, AML_ANYINT);
		rv = aml_allocint(aml_logicalcmp(opc->opcode, i1, 0));
		break;
	case AMLOP_LLESS:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LEQUAL:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LGREATEREQUAL:
	case AMLOP_LGREATER:
		lhs = aml_eparseval(ctx, 1);
		rhs = aml_eparseval(ctx, 1);
		rv  = aml_allocint(aml_comparevalue(ctx, opc->opcode, lhs, rhs));
		break;
	case AMLOP_TOSTRING:
		rhs = aml_eparseval(ctx, 1);
		i1  = aml_eparseint(ctx, AML_ANYINT);  // maximum length
		lhs = aml_eparseval(ctx, 1);

		tmp = aml_val2buf(ctx, rhs, 0);
		if (i1 > tmp->length)
			i1 = tmp->length;
		for(i2=0; i2<i1; i1++) {
			if (tmp->v_buffer[i2] == 0)
				break;
a1962 2
		rv  = aml_allocvalue(AML_OBJTYPE_STRING, i2, tmp->v_buffer);
		aml_esetnodevalue(ctx, lhs, rv, 0);
d1964 8
a1971 15
	case AMLOP_TOBUFFER:
		rhs = aml_eparseval(ctx, 1);
		lhs = aml_eparseval(ctx, 1);
		rv  = aml_val2buf(ctx, lhs, 0);
		aml_esetnodevalue(ctx, lhs, rv, 0);
		break;
	case AMLOP_TODECSTRING:
	case AMLOP_TOHEXSTRING:
		i1  = aml_eparseint(ctx, AML_ANYINT);
		lhs = aml_eparseval(ctx, 1);
		rv = aml_allocvalue(AML_OBJTYPE_STRING, AML_INTSTRLEN, NULL);
		if (aml_valid(rv)) {
			snprintf(rv->v_string, AML_INTSTRLEN, 
				 (opc->opcode == AMLOP_TODECSTRING) ? "%lld" : "0x%llx" , i1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
d1973 1
d1975 3
a1977 4
	case AMLOP_STALL:
		i1 = aml_eparseint(ctx, AML_ANYINT);
		dnprintf(40, "stall %lld usecs\n", i1);
		acpi_delay(ctx->sc, i1);
d1979 3
a1981 4
	case AMLOP_SLEEP:
		i1 = aml_eparseint(ctx, AML_ANYINT);
		dnprintf(40, "sleep %lld msecs\n", i1);
		acpi_delay(ctx->sc, i1 * 1000);
d1983 34
a2016 11
	case AMLOP_MUTEX:
		name = aml_parse_name(ctx);
		i1 = aml_eparseint(ctx, AML_BYTE);
		rv = aml_allocvalue(AML_OBJTYPE_MUTEX, i1, NULL);
		aml_addvname(ctx, name, opc->opcode, rv);
		break;
	case AMLOP_ACQUIRE:
		i2  = 0;
		lhs = aml_eparseval(ctx, 1);
		i1  = aml_eparseint(ctx, AML_WORD);  // timeout (0xffff = infinite)
		acpi_mutex_acquire(ctx, &lhs->v_mutex, i1);
d2018 4
a2021 2
		/* Returns true for timeout */
		rv  = aml_allocint(i2);
d2023 3
a2025 3
	case AMLOP_RELEASE:
		lhs = aml_eparseval(ctx, 1);
		acpi_mutex_release(ctx, &lhs->v_mutex);
d2028 13
a2040 3
		name = aml_parse_name(ctx);
		rv = aml_allocvalue(AML_OBJTYPE_EVENT, 0, NULL);
		aml_addvname(ctx, name, opc->opcode, rv);
d2042 20
a2061 3
	case AMLOP_SIGNAL:
		lhs = aml_eparseval(ctx, 1);
		dnprintf(40, "signal: %s\n", lhs->v_string);
d2063 2
a2064 4
	case AMLOP_WAIT:
		lhs = aml_eparseval(ctx, 1);
		i1  = aml_eparseint(ctx, AML_ANYINT);
		dnprintf(40, "wait: %s %llx\n", lhs->v_string, i1);
d2066 5
a2070 3
	case AMLOP_RESET:
		lhs = aml_eparseval(ctx, 1);
		dnprintf(40, "reset: %s\n", lhs->v_string);
d2072 4
a2075 8
	case AMLOP_NOTIFY:
		lhs = aml_eparseval(ctx, 1);
		i1  = aml_eparseint(ctx, AML_ANYINT);
		/* XXX: Fix me when we deref properly */
		if ((node = lhs->node) == NULL)
			node = aml_searchname(ctx->scope, lhs->name);
		dnprintf(10, "NOTIFY: %llx %s\n", i1, lhs->name);
		aml_notify(node, i1);
d2077 2
a2078 12
	case AMLOP_LOAD:
	case AMLOP_STORE:
		rhs = aml_eparseval(ctx, 1);
		lhs = aml_eparseval(ctx, 0);
		rv  = aml_esetnodevalue(ctx, lhs, rhs, 0);
		
		break;
	case AMLOP_COPYOBJECT:
		rhs = aml_eparseval(ctx, 1);
		lhs = aml_eparseval(ctx, 1);
		rv = aml_copyvalue(rhs);
		aml_esetnodevalue(ctx, lhs, rv, 0);
d2080 22
a2101 21
	case AMLOP_OPREGION:
		name = aml_parse_name(ctx);
		rv = aml_allocvalue(AML_OBJTYPE_OPREGION, 0, NULL);
		if (aml_valid(rv)) {
			rv->v_opregion.iospace = aml_eparseint(ctx, AML_BYTE);
			rv->v_opregion.iobase  = aml_eparseint(ctx, AML_ANYINT);
			rv->v_opregion.iolen   = aml_eparseint(ctx, AML_ANYINT);

			/* Special case: get PCI address */
			if (rv->v_opregion.iospace == GAS_PCI_CFG_SPACE) {
				i1 = aml_get_pciaddr(ctx, ctx->scope);
				if (i1 == 0xFFFF)
					dnprintf(50, "aml_pciregion: no _ADR for %s!\n",
						 name);
				else {
					rv->v_opregion.iobase += i1;
					dnprintf(50, "aml_pciregion: %llx\n", rv->v_opregion.iobase);
				}
			}
			aml_addvname(ctx, name, opc->opcode, rv);
		}
d2103 4
a2106 8
	case AMLOP_ALIAS:
		name = aml_parse_name(ctx);  // alias
		dnprintf(50, "alias0: %s\n", name);
		rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, (void *)name);

		name = aml_parse_name(ctx);  // new name
		dnprintf(50, "alias1: %s\n", name);
		aml_addvname(ctx, name, opc->opcode, rv);
d2108 9
a2116 4
	case AMLOP_NAME:
		name = aml_parse_name(ctx);
		rv = aml_eparseval(ctx, 0);
		aml_addvname(ctx, name, opc->opcode, rv);
d2118 6
a2123 5
	case AMLOP_RETURN:
		rv = aml_eparseval(ctx, 1);
		dnprintf(40, "RETURNING: ");
		aml_showvalue(rv);
		ctx->pos = NULL;
d2125 7
a2131 2
	case AMLOP_MID:
		rv = aml_domid(ctx);
d2133 4
a2136 2
	case AMLOP_CONCAT:
		rv = aml_doconcat(ctx);
d2138 19
d2158 6
a2163 3
	case AMLOP_SCOPE:
		end = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
d2165 6
a2170 6
		/* Save old scope, create new scope */
		rv = aml_eparsescope(ctx, name, end, opc, NULL);
		break;
	case AMLOP_DEVICE:
		end  = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
d2172 3
a2174 7
		/* Save old scope, create new scope */
		rv = aml_allocvalue(AML_OBJTYPE_DEVICE, 0, NULL);
		lhs  = aml_eparsescope(ctx, name, end, opc, rv);
		break;
	case AMLOP_POWERRSRC:
		end  = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
d2176 11
a2186 4
		rv = aml_allocvalue(AML_OBJTYPE_POWERRSRC, 0, NULL);
		if (aml_valid(rv)) {
			rv->v_powerrsrc.pwr_level = aml_eparseint(ctx, AML_BYTE);
			rv->v_powerrsrc.pwr_order = aml_eparseint(ctx, AML_WORD);
d2188 11
a2198 5
		lhs = aml_eparsescope(ctx, name, end, opc, rv);
		break;
	case AMLOP_PROCESSOR:
		end  = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
d2200 14
a2213 5
		rv = aml_allocvalue(AML_OBJTYPE_PROCESSOR, 0, NULL);
		if (aml_valid(rv)) {
			rv->v_processor.proc_id = aml_eparseint(ctx, AML_BYTE);
			rv->v_processor.proc_addr = aml_eparseint(ctx, AML_DWORD);
			rv->v_processor.proc_len = aml_eparseint(ctx, AML_BYTE);
d2215 14
d2230 6
a2235 5
		lhs = aml_eparsescope(ctx, name, end, opc, rv);
		break;
	case AMLOP_THERMALZONE:
		end  = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
d2237 4
a2240 24
		rv = aml_allocvalue(AML_OBJTYPE_THERMZONE, 0, NULL);
		lhs = aml_eparsescope(ctx, name, end, opc, rv);
		break;
	case AMLOP_OBJECTTYPE:
		lhs = aml_eparseval(ctx, 1);
		i1 = (lhs->type == AML_OBJTYPE_STATICINT) ?
			AML_OBJTYPE_INTEGER : lhs->type;
		rv  = aml_allocint(i1);
		break;
	case AMLOP_SIZEOF:
		lhs = aml_eparseval(ctx, 1);
		if (aml_valid(lhs))
			rv = aml_allocint(lhs->length);
		break;
	case AMLOP_METHOD:
		end  = aml_eparselen(ctx);
		name = aml_parse_name(ctx);
		i1   = aml_eparseint(ctx, AML_BYTE);
		rv = aml_allocvalue(AML_OBJTYPE_METHOD, i1, NULL);
		if (aml_valid(rv)) {
			/* Allocate method block */
			rv->length = end - ctx->pos;
			rv->v_method.start = acpi_os_allocmem(rv->length);
			rv->v_method.end   = rv->v_method.start + rv->length;
d2242 8
a2249 2
			memcpy(rv->v_method.start, ctx->pos, rv->length);
			aml_addvname(ctx, name, opc->opcode, rv);
d2252 9
a2260 8
	case AMLOP_CONDREFOF:
		rhs = aml_eparseval(ctx, 0);
		lhs = aml_eparseval(ctx, 1);
		rv  = aml_allocint(0);
		if (aml_ederef(ctx, rhs) != NULL) {
			tmp = aml_allocvalue(AML_OBJTYPE_OBJREF, -1, rhs);
			aml_esetnodevalue(ctx, lhs, tmp, 0);
			rv->v_integer = 1;
a2261 1
		dnprintf(40,"condrefof: %lld\n", rv->v_integer);
d2263 24
a2286 5
	case AMLOP_REFOF:
		rv  = aml_allocvalue(AML_OBJTYPE_OBJREF, 0, NULL);
		if (aml_valid(rv)) {
			rv->v_objref.ref = aml_eparseval(ctx, 0);
			rv->v_objref.index = -1;
d2288 5
a2292 9
			lhs = aml_eparseval(ctx, 1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
		}
		break;
	case AMLOP_INDEX:
		rv  = aml_allocvalue(AML_OBJTYPE_OBJREF, 0, NULL);
		if (aml_valid(rv)) {
			rv->v_objref.ref = aml_eparseval(ctx, 0);
			rv->v_objref.index = aml_eparseint(ctx, AML_ANYINT);
d2294 6
a2299 3
			lhs = aml_eparseval(ctx, 1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
		}
d2301 10
a2310 2
	case AMLOP_DEREFOF:
		rv = aml_eparseval(ctx, 1);
d2312 2
a2313 2
	case AMLOP_LOADTABLE:
		rv = aml_doloadtable(ctx);
d2315 3
a2317 2
	case AMLOP_MATCH:
		rv = aml_domatch(ctx);
d2319 7
a2325 2
	case AMLOP_WHILE:
		rv  = aml_dowhile(ctx);
d2327 17
a2343 2
	case AMLOP_IF:
		rv  = aml_doif(ctx);
d2345 3
a2347 3

	default:
		dnprintf(40,"Unknown opcode: %.4x %s\n", opc->opcode, opc->mnem);
d2349 17
a2365 8
	}
	if (deref && rv) {
		switch (rv->type) {
		case AML_OBJTYPE_FIELDUNIT:
		case AML_OBJTYPE_BUFFERFIELD:
			rhs = rv;
			rv  = aml_efield(ctx, rhs, NULL);
			aml_freevalue(&rhs);
d2367 6
a2372 1
		case AML_OBJTYPE_OBJREF:
d2374 3
a2376 2
		}
	}
d2378 2
a2379 4
	/* Free temp variables */
	if (rv != lhs) aml_freevalue(&lhs);
	if (rv != rhs) aml_freevalue(&rhs);
	if (rv != tmp) aml_freevalue(&tmp);
d2381 4
a2384 2
	if (end > ctx->pos)
		ctx->pos = end;
d2386 9
a2394 2
	--ctx->depth;
	return rv;
d2397 4
a2400 3
/* Remove all children nodes */
void
aml_delchildren(struct acpi_context *ctx, struct aml_node *node)
d2402 1
a2402 1
	struct aml_node *pn;
d2404 31
a2434 9
	if (node == NULL)
		return;
	while ((pn = node->child) != NULL) {
		dnprintf(40, "deleting node..\n");
		if (pn->value)
			pn->value->node = NULL;
		node->child = node->child->sibling;
		aml_delchildren(ctx, pn);
		acpi_os_freemem(pn);
d2436 4
d2442 1
a2442 1
/* Ok.. we have a node and hopefully its value.. call value */
d2444 1
a2444 1
aml_eparsenode(struct acpi_context *ctx, struct aml_node *node)
d2446 17
a2462 2
	struct aml_node *oldscope;
	struct aml_value *rv;
d2464 3
a2466 16
	if (node->value == NULL)
		return NULL;
	switch (node->value->type) {
	case AML_OBJTYPE_NAMEREF:
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PACKAGE:
		return node->value;
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		return aml_efield(ctx, node->value, NULL);
	case AML_OBJTYPE_METHOD:
		/* Setup method call */
		oldscope = ctx->scope;
		ctx->scope = node->parent;
d2468 8
a2475 1
		dnprintf(40, "Call function: %s\n", node->name);
d2477 2
a2478 2
		ctx->pos = node->value->v_method.start;
		rv = aml_eparselist(ctx, node->value->v_method.end, 1);
d2480 6
a2485 2
		/* Delete dynamic names */
		aml_delchildren(ctx, node);
d2487 28
a2514 4
		ctx->scope = oldscope;
		return rv;
	default:
		dnprintf(40, "Unknown node value: %d\n", node->value->type);
d2516 1
a2516 1
	return NULL;
d2519 3
a2521 3
int
aml_eval_object(struct acpi_softc *sc, struct aml_node *node,
		struct aml_value *ret, int argc, struct aml_value *argv)
d2523 1
a2523 2
	struct acpi_context *ctx;
	struct aml_value *rv;
d2525 11
a2535 7
	ret->type = 0;
	ctx = acpi_alloccontext(sc, node, argc, argv);
	rv = aml_eparsenode(ctx, node);
	dnprintf(40, "###### RETURNING #####\n");
	aml_showvalue(rv);
	if (rv != NULL)
		*ret = *rv;
d2537 1
a2537 4
	/* XXX: must free rv */
	acpi_freecontext(ctx);

	return 0;
d2540 1
d2542 1
a2542 1
aml_evalmethod(struct acpi_context *ctx, struct aml_value *method)
d2544 2
a2545 2
	struct aml_value **argv, *rv;
	int64_t idx, size, argc;
d2547 7
a2553 3
	/* Decode method arguments from bytestream */
	size = sizeof(struct aml_value *) * AML_MAX_ARG;
	argv = (struct aml_value **)acpi_os_allocmem(size);
d2555 12
a2566 14
	argc = AML_METHOD_ARGCOUNT(method->v_method.flags);
	for (idx = 0; idx < argc; idx++)
		argv[idx] = aml_eparseval(ctx, 0);

	/* Evaluate method */
	rv = aml_evalnode(ctx->sc, method->node, argc, argv);

	/* Free arguments */
	for(idx = 0; idx < AML_MAX_ARG; idx++)
		aml_freevalue(&argv[idx]);

	acpi_os_freemem(argv);

	return (rv);
d2569 1
d2571 1
a2571 2
aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
	     int argc, struct aml_value **argv)
d2573 1
a2573 2
	struct acpi_context *ctx;
	struct aml_value *rv, **tmparg;
d2575 33
a2607 3
	/* This shouldn't happen... */
	if (node->value == NULL)
		return NULL;
d2609 38
a2646 10
	/* Simple objects: return node value */
	dnprintf(10, "--- eval: (%s)\n", node->name);
	switch (node->value->type) {
	case AML_OBJTYPE_NAMEREF:
	case AML_OBJTYPE_INTEGER:
	case AML_OBJTYPE_STATICINT:
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
	case AML_OBJTYPE_PACKAGE:
		return node->value;
d2649 2
a2650 3
	/* Method or field context required */
	if ((ctx = acpi_alloccontext(sc, node, 0, NULL)) == NULL)
		return NULL;
d2652 5
a2656 4
	/* XXX: ugh, fix this, set method argument pointer */
	tmparg = ctx->args;
	if (argv != NULL)
		ctx->args = argv;
d2658 13
a2670 5
	rv = NULL;
	switch (node->value->type) {
	case AML_OBJTYPE_BUFFERFIELD:
	case AML_OBJTYPE_FIELDUNIT:
		rv = aml_efield(ctx, node->value, NULL);
d2672 6
a2677 3
	case AML_OBJTYPE_METHOD:
		ctx->pos = node->value->v_method.start;
		rv = aml_eparselist(ctx, node->value->v_method.end, 0);
d2680 1
a2680 3
		dnprintf(1, "aml_evalnode: Unknown type (%d) for %s\n",
			 node->value->type,
			 node->name);
a2682 3
	ctx->args = tmparg;
	aml_delchildren(ctx, node);
	acpi_freecontext(ctx);
d2684 1
a2684 1
	return rv;
d2688 1
a2688 2
aml_evalname(struct acpi_softc *sc, struct aml_node *parent, const char *name,
	     int argc, struct aml_value **argv)
d2690 10
a2699 1
	struct aml_node *node;
d2701 4
a2704 2
	if ((node = aml_searchname(parent, name)) != NULL)
		return aml_evalnode(sc, node, argc, argv);
d2706 8
a2713 1
	return NULL;
d2716 2
a2717 2
void
aml_shownode(struct aml_node *node)
d2719 91
a2809 4
	dnprintf(50, " opcode:%.4x  mnem:%s %s ",
		 node->opcode, node->mnem, node->name ? node->name : "");
	switch(node->opcode) {
	case AMLOP_METHOD:
d2811 7
a2817 3
		
	case AMLOP_NAMECHAR:
		dnprintf(50, "%s", node->value->name);
a2818 1

d2820 1
d2822 12
a2833 1
	case AMLOP_INDEXFIELD:
d2835 5
a2839 3
		
	case AMLOP_BYTEPREFIX:
		dnprintf(50, "byte: %.2x", node->value->v_integer);
d2841 10
a2850 2
	case AMLOP_WORDPREFIX:
		dnprintf(50, "word: %.4x", node->value->v_integer);
d2852 2
a2853 2
	case AMLOP_DWORDPREFIX:
		dnprintf(50, "dword: %.8x", node->value->v_integer);
d2855 2
a2856 2
	case AMLOP_STRINGPREFIX:
		dnprintf(50, "string: %s", node->value->v_string);
d2859 1
a2859 42
	dnprintf(50, "\n");
}

void
aml_walktree(struct aml_node *node)
{
	int idx;

	while(node) {
		dnprintf(50, " %d ", node->depth);
		for(idx=0; idx<node->depth; idx++)
			dnprintf(50, "..");
		aml_shownode(node);
		aml_walktree(node->child);
		node = node->sibling;
	}
}

void
aml_walkroot(void)
{
	aml_walktree(aml_root.child);
}

int
aml_find_node(struct aml_node *node, const char *name,
	      void (*cbproc)(struct aml_node *, void *arg),
	      void *arg)
{
	const char *nn;

	while (node) {
		if ((nn = node->name) != NULL) {
			if (*nn == AMLOP_ROOTCHAR) nn++;
			while (*nn == AMLOP_PARENTPREFIX) nn++;
			if (!strcmp(name, nn))
				cbproc(node, arg);
		}
		aml_find_node(node->child, name, cbproc, arg);
		node = node->sibling;
	}
	return (0);
d2881 11
a2891 4
struct acpi_context *acpi_alloccontext(struct acpi_softc *sc,
				       struct aml_node *node,
				       int argc,
				       struct aml_value *argv)
d2893 15
a2907 2
	struct acpi_context *ctx;
	int idx;
d2909 17
a2925 10
	if ((ctx = acpi_os_allocmem(sizeof(struct acpi_context))) != NULL) {
		ctx->sc = sc;
		ctx->depth = 0;
		ctx->start = node->start;
		ctx->pos   = node->start;
		ctx->scope = node;
		ctx->locals = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *) * 8);
		ctx->args   = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *) * 8);
		for (idx=0; idx<argc; idx++) {
			ctx->args[idx] = aml_copyvalue(&argv[idx]);
a2927 1
	return ctx;
d2930 21
a2950 1
void acpi_freecontext(struct acpi_context *ctx)
d2952 2
a2953 1
	int idx;
d2955 8
a2962 8
	if (ctx) {
		for (idx=0; idx<8; idx++) {
			aml_freevalue(&ctx->args[idx]);
			aml_freevalue(&ctx->locals[idx]);
		}
		acpi_os_freemem(ctx->args);
		acpi_os_freemem(ctx->locals);
		acpi_os_freemem(ctx);
d2969 1
a2969 2
	struct acpi_context *ctx;
	struct aml_value *rv;
d2971 1
a2971 16
	aml_root.depth = -1;
	aml_root.mnem  = "ROOT";
	aml_root.start = start;
	aml_root.end   = start + length;

	/* Add \_OS_ string */
	aml_os.type = AML_OBJTYPE_STRING;
	aml_os.v_string = "OpenBSD";
	aml_os.length = strlen(aml_os.v_string) + 1;
	ctx = acpi_alloccontext(sc, &aml_root, 0, NULL);
	aml_addvname(ctx, "\\_OS_", AMLOP_NAME, &aml_os);

	rv  = aml_eparselist(ctx, aml_root.end, 0);
	aml_freevalue(&rv);

	acpi_freecontext(ctx);
d2973 7
d2982 2
a2983 1
	aml_walktree(&aml_root);
d2985 7
d2993 11
@


1.46
log
@Do not put _OS_ value on the stack.
excellent bug report and testing by
Berk Demir < bdd at mindcast dot org >
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.45 2006/05/31 03:25:29 canacar Exp $ */
d1725 2
@


1.45
log
@When allocating a buffer, use the supplied length if the requested
length is smaller. Tested by joris@@, ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.44 2006/05/29 21:27:59 canacar Exp $ */
d159 1
a3062 1
	struct aml_value  aml_os;
d3072 1
d3074 1
a3074 1
	aml_addvname(ctx, "\\_OS_", 0, &aml_os);
@


1.44
log
@Check for possible NULL dereference in aml_showvalue
tested & ok gwk@@ dim@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.43 2006/05/29 02:39:49 gwk Exp $ */
d2339 3
a2341 1

a2344 1
		dnprintf(40, "buffer: %lld of %lld\n", i1, i2);
@


1.43
log
@Check the return value of aml_ederef isnt NULL before use.
Fixes a few panics.
ok canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.42 2006/05/29 00:43:56 canacar Exp $ */
d681 4
a684 3
		aml_dump(aml_bytelen(value->v_field.bitlen), 
		    value->v_field.ref1->v_buffer + 
		    aml_bytepos(value->v_field.bitpos));
@


1.42
log
@Fix a memory overrun in the aml parser code.
ok deraadt@@, gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.41 2006/04/21 23:03:04 joris Exp $ */
d1391 2
d1484 2
d1579 3
d1621 2
d1899 2
@


1.41
log
@remove some trailing spaces found while reading this code.
okay marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.40 2006/04/16 22:23:37 kettenis Exp $ */
d1552 3
a1554 2
		aml_bufcpy(pb, e_fld->v_field.bitpos, rv->v_buffer, 0,
		    e_fld->v_field.bitlen);
@


1.40
log
@Use aml_bitpos() when copying a field into a buffer.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.39 2006/03/21 21:11:10 jordan Exp $ */
d1182 1
a1182 1
			if (*sname == AMLOP_ROOTCHAR) 
d1185 1
a1185 1
			while (*sname == AMLOP_PARENTPREFIX) 
d1199 1
a1199 1
aml_eval_name(struct acpi_softc *sc, struct aml_node *root, const char *name, 
d1223 1
a1223 1
		if (cb >= 'A' && cb <= 'F' && radix == 16) 
d1242 1
a1242 1
aml_bufcpy(u_int8_t *pDst, int dstPos, const u_int8_t *pSrc, int srcPos, 
d1266 1
a1266 1
		if (rc != 0) 
d1863 1
a1863 1
		rv->v_field.bitlen = (opcode == AMLOP_CREATEFIELD) ? 
d1873 1
a1873 1
aml_esetnodevalue(struct acpi_context *ctx,  struct aml_value *lhs, 
d2224 1
a2224 1
/* Parse AMLOP_XXXX 
d2967 1
a2967 1
aml_find_node(struct aml_node *node, const char *name, 
d3005 1
a3005 1
struct acpi_context *acpi_alloccontext(struct acpi_softc *sc, 
d3007 1
a3007 1
				       int argc, 
@


1.39
log
@Disassembler now pretty prints AML code (like acpidump)
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.38 2006/03/09 05:38:12 jordan Exp $ */
d1513 1
a1513 1
				    e_fld->v_field.bitpos,
@


1.38
log
@Used common aml_opname for debugger
Removed redundant code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.37 2006/03/09 05:24:03 marco Exp $ */
d166 4
a169 4
	{ AMLOP_BYTEPREFIX,	  "Byte",	     "b"  },
	{ AMLOP_WORDPREFIX,	  "Word",	     "w"  },
	{ AMLOP_DWORDPREFIX,	  "DWord",	     "d"  },
	{ AMLOP_QWORDPREFIX,	  "QWord",	     "q"  },
d171 1
a171 1
	{ AMLOP_STRINGPREFIX,	  "String",	     "a"  },
d236 1
a236 1
	{ AMLOP_NAMECHAR,	  "NameRef",	     "n" },
@


1.37
log
@Remove bad XXX

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.36 2006/03/09 05:17:24 jordan Exp $ */
a83 1
const char		*aml_opname(int);
@


1.36
log
@Removed unused prototypes
Fixed aml_notify to use known node
Added new method/node evaluator
Renamed some functions for easier naming
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.35 2006/03/08 21:03:18 marco Exp $ */
d483 1
a483 1
				strncpy(rv->v_string, bval, ival); /* XXX */
@


1.35
log
@Fix proto.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.34 2006/03/08 04:05:01 marco Exp $ */
a94 1
int64_t			_aml_evalint(struct acpi_context *, struct aml_node *);
a101 1
struct aml_value	*_aml_evalref(struct acpi_context *, struct aml_node *);
d103 2
a104 2
struct aml_value	*aml_ebufferfield(struct acpi_context *, int, int, int);
struct aml_value	*aml_efieldunit(struct acpi_context *, int);
d113 5
a117 1
struct aml_value	*aml_evalnode(struct acpi_context *, struct aml_node *);
a120 1
void			_aml_notify(struct aml_node *, void *);
a137 2
struct aml_value	*_aml_setnodevalue(struct acpi_context *,
			    struct aml_node *, struct aml_value *, u_int64_t);
a410 6
_aml_notify(struct aml_node *node, void *arg)
{
	aml_notify(node, *(int64_t *)arg);
}

void
d1792 1
a1792 1
aml_efieldunit(struct acpi_context *ctx, int opcode)
d1855 1
a1855 1
aml_ebufferfield(struct acpi_context *ctx, int size, int bitlen, int opcode)
d2233 1
d2300 1
a2300 1
		rv = aml_efieldunit(ctx, opc->opcode);
d2303 1
a2303 1
		rv = aml_ebufferfield(ctx, 1, -1, opc->opcode);
d2306 1
a2306 1
		rv = aml_ebufferfield(ctx, 1,  1, opc->opcode);
d2309 1
a2309 1
		rv = aml_ebufferfield(ctx, 8,  8, opc->opcode);
d2312 1
a2312 1
		rv = aml_ebufferfield(ctx, 8, 16, opc->opcode);
d2315 1
a2315 1
		rv = aml_ebufferfield(ctx, 8, 32, opc->opcode);
d2318 1
a2318 1
		rv = aml_ebufferfield(ctx, 8, 64, opc->opcode);
d2524 3
d2528 1
a2528 3
		aml_find_node(aml_root.child, lhs->name,
			      _aml_notify,
			      &i1);
d2819 26
a2844 1
#if 0
d2885 1
a2885 1
		rv = aml_eparselist(ctx, node->value->v_method.end);
d2894 1
a2894 1
	aml_delchildren(node->value);
d2904 1
a2904 1
	struct aml_value *node;
a2910 1
#endif
@


1.34
log
@KNF.
Undo emacsisms/jordanisms.
Rearange protos and globals.
This file needs more cleanup but this is a start.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.33 2006/03/07 23:13:28 marco Exp $ */
d59 1
a59 1
const char		*opregion(int id);
@


1.33
log
@Add "disasm" code for ddb.  With this one can disassemble AML code from DDB.
example : "machine acpi disasm \\_SB_.BIF_" dumps the battery AML on my laptop.

Disasm code was written by jordan.  Help from miod on ddb lexer magic.
ok jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.32 2006/03/05 14:46:46 marco Exp $ */
d59 1
a59 1
const char *opregion(int id);
d65 14
a78 7
	case 0: return "SystemMemory";
	case 1: return "SystemIO";
	case 2: return "PCIConfig";
	case 3: return "Embedded";
	case 4: return "SMBus";
	case 5: return "CMOS";
	case 6: return "PCIBAR";
d84 74
a157 75
int	    aml_parse_length(struct acpi_context *);
u_int64_t   aml_parse_int(struct acpi_context *, int);
const char *aml_parse_string(struct acpi_context *);

int aml_isnamedop(u_int16_t);

void aml_shownode(struct aml_node *);

u_int64_t  aml_bcd2dec(u_int64_t);
u_int64_t  aml_dec2bcd(u_int64_t);
int	   aml_lsb(u_int64_t);
int	   aml_msb(u_int64_t);

int _aml_freevalue(struct aml_value *);

struct aml_node *aml_find_name(struct acpi_softc *, struct aml_node *, const char *);

int64_t aml_str2int(const char *, int, int);
int64_t aml_evalmath(u_int16_t, int64_t, int64_t);
int  aml_logicalcmp(u_int16_t, int64_t, int64_t);
int  aml_strcmp(u_int16_t opcode, const char *lhs, const char *rhs);

int64_t _aml_evalint(struct acpi_context *, struct aml_node *);
struct aml_value *aml_getnodevalue(struct acpi_context *, struct aml_node *);
struct aml_value *_aml_evalref(struct acpi_context *, struct aml_node *);
struct aml_value *aml_evalnode(struct acpi_context *, struct aml_node *);
struct aml_value *_aml_setnodevalue(struct acpi_context *, struct aml_node *, struct aml_value *, u_int64_t);

struct aml_node *aml_create_node(struct aml_node *, 
				 int, const char *,
				 u_int8_t *);

int aml_match(int64_t, int, int64_t);

int  aml_tstbit(const u_int8_t *, int);
void aml_setbit(u_int8_t *, int, int);
void aml_bufcpy(u_int8_t *, int, const u_int8_t *, int, int);
int  aml_bufcmp(const u_int8_t *, int, const u_int8_t *, int);

struct aml_value *aml_ederef(struct acpi_context *ctx, struct aml_value *val);
void aml_resizevalue(struct aml_value *, int);
struct aml_value *aml_eparseval(struct acpi_context *, int deref);
struct aml_opcode *aml_getopcode(struct acpi_context *);
struct aml_value *aml_esetnodevalue(struct acpi_context *,  struct aml_value *lhs, 
				    struct aml_value *rhs, int64_t rval);
struct aml_value *aml_eparselist(struct acpi_context *, u_int8_t *end, int);

struct aml_node *_aml_searchname(struct aml_node *, const char *);
struct aml_node *aml_doname(struct aml_node *, const char *, int);
struct aml_node *aml_createname(struct aml_node *, const char *);
struct aml_value *aml_eparsescope(struct acpi_context *, const char *, u_int8_t *,
				  struct aml_opcode *, struct aml_value *);
struct aml_value *aml_efieldunit(struct acpi_context *, int opcode);
struct aml_value *aml_ebufferfield(struct acpi_context *, int bitlen, int size, int opcode);
struct aml_value *aml_efield(struct acpi_context *, struct aml_value *e_fld,
			     struct aml_value *rhs);
struct aml_node *aml_addvname(struct acpi_context *, const char *name, int opcode,
			      struct aml_value *val);
struct aml_value *aml_eparsenode(struct acpi_context *, struct aml_node *node);
void aml_delchildren(struct acpi_context *, struct aml_node *node);

int64_t aml_val2int(struct acpi_context *, struct aml_value *);
struct aml_value *aml_val2buf(struct acpi_context *, struct aml_value *, int);

struct aml_value *aml_domethod(struct acpi_context *, struct aml_value *,
			       int, struct aml_value **);
struct aml_value *aml_dowhile(struct acpi_context *);
struct aml_value *aml_doif(struct acpi_context *);
struct aml_value *aml_doloadtable(struct acpi_context *);
struct aml_value *aml_domatch(struct acpi_context *);
struct aml_value *aml_doconcat(struct acpi_context *);
struct aml_value *aml_domid(struct acpi_context *);

void *acpi_os_allocmem(size_t);
void  acpi_os_freemem(void *);
a158 1
void aml_addchildnode(struct aml_node *, struct aml_node *);
d160 2
a161 2
const char *aml_opname(int);
void aml_dump(int, u_int8_t *);
d163 151
a313 2
struct aml_node	  aml_root;
struct aml_value *aml_global_lock;
d318 1
a318 1
	void *ptr;
d323 2
a324 1
	return ptr;
d330 1
a330 1
	//free(ptr, M_DEVBUF);
d336 1
a336 1
	int idx;
d339 1
a339 1
	for (idx=0; idx<len; idx++) {
d350 1
d358 2
a359 1
	if (val) {
d361 1
a361 2
	}
	else {
a362 1
	}
a364 17
/*=====================================
 * This code handles AML notifications
 *=====================================*/
struct aml_notify_data
{
	struct aml_node 	*node;
	char                     pnpid[20];
	void            	*cbarg;
	int			(*cbproc)(struct aml_node *, int, void *);

	SLIST_ENTRY(aml_notify_data) link;
};

SLIST_HEAD(aml_notify_head, aml_notify_data);
struct aml_notify_head aml_notify_list =
	SLIST_HEAD_INITIALIZER(&aml_notify_list);

d367 1
a367 2
		    int (*proc)(struct aml_node *, int, void *),
		    void *arg)
d369 1
a369 1
	struct aml_notify_data *pdata;
d373 1
d378 1
d381 1
d388 1
a388 1
	struct aml_notify_data *pdata = NULL;
d392 1
d401 1
a401 1
	struct aml_notify_data *pdata = NULL;
d405 2
a406 1
	SLIST_FOREACH(pdata, &aml_notify_list, link) {
a408 1
	}
a410 2
void _aml_notify(struct aml_node *, void *);

d418 1
a418 2
aml_addchildnode(struct aml_node *parent,
		 struct aml_node *child)
d420 1
a420 1
	struct aml_node **tmp;
d431 2
a432 2
aml_create_node(struct aml_node *parent, int opcode,
		const char *mnem, u_int8_t *start)
d434 1
a434 1
	struct aml_node *node;
d437 1
a437 1
	if (node == NULL) {
d439 1
a439 1
	}
d449 1
a449 1
	return node;
d460 3
a462 3
	struct aml_value *rv;
	struct aml_value **pv;
	int64_t idx;
d475 2
a476 2
		rv->v_objref.index  = ival;
		rv->v_objref.ref    = (struct aml_value *)bval;
d488 1
a488 1
			rv->v_string = acpi_os_allocmem(ival+1);
d490 1
a490 1
				strncpy(rv->v_string, bval, ival);
d505 2
a506 1
		rv->v_package = (struct aml_value **)acpi_os_allocmem(rv->length * sizeof(struct aml_value *));
d510 1
a510 1
			for (idx=0; idx<ival; idx++) {
a511 1
			}
d532 2
a533 1
	return rv;
d551 1
a551 1
	int idx;
d556 1
d560 5
a564 3
	dnprintf(50, "freeing value : %4x %s\n", v->type, 
		 v->node ? "attached" : "freeable");
	return -1;
d580 1
a580 1
		for (idx=0; idx<v->length; idx++) {
a581 1
		}
d591 1
d611 1
d614 1
d617 1
d631 1
a631 1
			 (value->type == AML_OBJTYPE_STATICINT) ? "(static)" : "");
d638 1
a638 1
		for (idx=0; idx<value->length; idx++)
d660 3
a662 3
			 value->v_processor.proc_id,
			 value->v_processor.proc_addr,
			 value->v_processor.proc_len);
d666 3
a668 3
			 AML_METHOD_ARGCOUNT(value->v_method.flags),
			 AML_METHOD_SERIALIZED(value->v_method.flags),
			 AML_METHOD_SYNCLEVEL(value->v_method.flags));
d671 9
a679 7
		dnprintf(50, "%s: access=%x,lock=%x,update=%x pos=%.4x len=%.4x\n",
			 aml_opname(value->v_field.type),
			 AML_FIELD_ACCESS(value->v_field.flags),
			 AML_FIELD_LOCK(value->v_field.flags),
			 AML_FIELD_UPDATE(value->v_field.flags),
			 value->v_field.bitpos,
			 value->v_field.bitlen);
d685 4
a688 3
			 aml_opname(value->v_field.type),
			 value->v_field.bitpos,
			 value->v_field.bitlen);
d690 3
a692 1
			 value->v_field.ref1->v_buffer+aml_bytepos(value->v_field.bitpos));
d697 3
a699 3
			 opregion(value->v_opregion.iospace),
			 value->v_opregion.iobase,
			 value->v_opregion.iolen);
d709 1
a709 1
		 struct aml_value *rhs)
d711 10
a720 2
	struct aml_value *tmp;
	int rc;
a721 6
	if (lhs->type == AML_OBJTYPE_INTEGER) {
		return aml_logicalcmp(opcode, lhs->v_integer, aml_val2int(ctx, rhs));
	}
	if (rhs->type == AML_OBJTYPE_INTEGER) {
		return aml_logicalcmp(opcode, aml_val2int(ctx, lhs), rhs->v_integer);
	}
d725 2
a726 1
				 tmp->v_buffer, tmp->length);
d728 1
a728 2
			(rc != AMLOP_LEQUAL) :
			(rc == opcode);
d732 2
a733 1
	return 0;
d739 1
a739 1
	struct aml_value *rv;
d744 1
a744 3
		return aml_allocvalue(rhs->type,
				      rhs->v_integer,
				      NULL);
d746 1
a746 3
		return aml_allocvalue(rhs->type,
				      rhs->length,
				      rhs->v_string);
d748 1
a748 3
		return aml_allocvalue(rhs->type,
				      rhs->length,
				      rhs->v_buffer);
d750 1
a750 4
		return aml_allocvalue(rhs->type,
				      rhs->length,
				      rhs->v_package);

d759 1
a759 1
		return rv;
d767 1
a767 1
	return rv;
d774 3
a776 3
	struct aml_value **newpkg;
	u_int8_t *newbuf;
	int i1;
d793 2
a794 1
		newpkg = (struct aml_value **)acpi_os_allocmem(newlen * sizeof(struct aml_value *));
d797 1
a797 1
		for (i1 = 0; i1 < pv->length; i1++) {
a798 1
		}
d811 1
a811 3
/* 
 * AML Parsing routines
 */
d815 3
a817 1
	const char *str = ctx->pos;
d819 1
a819 2
	ctx->pos += strlen(str)+1;
	return str;
d826 1
a826 1
	u_int8_t *pc = ctx->pos;
d856 2
a857 2
	u_int8_t lcode;
	int ival;
d860 2
a861 3
	if (lcode <= 0x3F) {
		return lcode;
	}
d863 7
a869 4
	ival = lcode & 0xF;
	if (lcode >= 0x40)  ival |= aml_parse_int(ctx, AML_BYTE) << 4;
	if (lcode >= 0x80)  ival |= aml_parse_int(ctx, AML_BYTE) << 12;
	if (lcode >= 0xC0)  ival |= aml_parse_int(ctx, AML_BYTE) << 20;
d871 1
a871 1
	return ival;
d878 3
a880 3
	int count, pfxlen;
	char *name, *pn;
	u_int8_t *base;
d883 1
a883 1
	if (ctx->pos[pfxlen] == AMLOP_ROOTCHAR) {
d885 2
a886 2
	}
	while (ctx->pos[pfxlen] == AMLOP_PARENTPREFIX) {
a887 1
	}
d895 1
a895 1
		count = ctx->pos[pfxlen+1];
d928 1
a928 1
	return name;
d941 1
a941 1
	case 'A' ... 'Z':
d948 1
a948 3
/*
 * Math eval routines
 */
d952 2
a953 2
	u_int64_t rval;
	int n, pos;
d957 1
a957 1
		n = (val & 0xF);
d964 2
a965 1
	return rval;
d971 2
a972 2
	u_int64_t rval;
	int n, pos;
d981 2
a982 1
	return rval;
d989 1
a989 1
	int lsb;
d996 2
a997 1
	return lsb;
d1004 1
a1004 1
	int msb;
d1011 2
a1012 1
	return msb;
d1020 1
d1069 3
a1071 1
	dnprintf(50, "logicalcmp: %s %lld %lld\n", aml_opname(opcode), lhs, rhs);
d1092 2
a1093 1
	return 0;
a1095 138
struct aml_opcode aml_table[] = {
	/* Simple types */
	{ AMLOP_ZERO,		  "Zero",	     "!"  },
	{ AMLOP_ONE,		  "One",	     "!"  },
	{ AMLOP_ONES,		  "Ones",	     "!"  },
	{ AMLOP_BYTEPREFIX,	  "Byte",	     "b"  },
	{ AMLOP_WORDPREFIX,	  "Word",	     "w"  },
	{ AMLOP_DWORDPREFIX,	  "DWord",	     "d"  },
	{ AMLOP_QWORDPREFIX,	  "QWord",	     "q"  },
	{ AMLOP_REVISION,	  "Revision",	     ""	  },
	{ AMLOP_STRINGPREFIX,	  "String",	     "a"  },
	{ AMLOP_DEBUG,		  "DebugOp",	     "",  },
	{ AMLOP_BUFFER,		  "Buffer",	     "piB" },
	{ AMLOP_PACKAGE,	  "Package",	     "pbT" },
	{ AMLOP_VARPACKAGE,	  "VarPackage",	     "piT" },

	/* Simple objects */
	{ AMLOP_LOCAL0,		  "Local0",	     "",    },
	{ AMLOP_LOCAL1,		  "Local1",	     "",    },
	{ AMLOP_LOCAL2,		  "Local2",	     "",    },
	{ AMLOP_LOCAL3,		  "Local3",	     "",    },
	{ AMLOP_LOCAL4,		  "Local4",	     "",    },
	{ AMLOP_LOCAL5,		  "Local5",	     "",    },
	{ AMLOP_LOCAL6,		  "Local6",	     "",    },
	{ AMLOP_LOCAL7,		  "Local7",	     "",    },
	{ AMLOP_ARG0,		  "Arg0",	     "",    },
	{ AMLOP_ARG1,		  "Arg1",	     "",    },
	{ AMLOP_ARG2,		  "Arg2",	     "",    },
	{ AMLOP_ARG3,		  "Arg3",	     "",    },
	{ AMLOP_ARG4,		  "Arg4",	     "",    },
	{ AMLOP_ARG5,		  "Arg5",	     "",    },
	{ AMLOP_ARG6,		  "Arg6",	     "",    },

	/* Control flow */
	{ AMLOP_IF,		  "If",		     "piT",  },
	{ AMLOP_ELSE,		  "Else",	     "pT",   },
	{ AMLOP_WHILE,		  "While",	     "piT",  },
	{ AMLOP_BREAK,		  "Break",	     "",     },
	{ AMLOP_CONTINUE,	  "Continue",	     "",     },
	{ AMLOP_RETURN,		  "Return",	     "t",     },
	{ AMLOP_FATAL,		  "Fatal",	     "bdi", },
	{ AMLOP_NOP,		  "Nop",	     "",    },
	{ AMLOP_BREAKPOINT,	  "BreakPoint",	     "",    },

	/* Arithmetic operations */
	{ AMLOP_INCREMENT,	  "Increment",	     "t",     },
	{ AMLOP_DECREMENT,	  "Decrement",	     "t",     },
	{ AMLOP_ADD,		  "Add",	     "iit",   },
	{ AMLOP_SUBTRACT,	  "Subtract",	     "iit",   },
	{ AMLOP_MULTIPLY,	  "Multiply",	     "iit",   },
	{ AMLOP_DIVIDE,		  "Divide",	     "iitt",  },
	{ AMLOP_SHL,		  "ShiftLeft",	     "iit",   },
	{ AMLOP_SHR,		  "ShiftRight",	     "iit",   },
	{ AMLOP_AND,		  "And",	     "iit",   },
	{ AMLOP_NAND,		  "Nand",	     "iit",   },
	{ AMLOP_OR,		  "Or",		     "iit",   },
	{ AMLOP_NOR,		  "Nor",	     "iit",   },
	{ AMLOP_XOR,		  "Xor",	     "iit",   },
	{ AMLOP_NOT,		  "Not",	     "it",    },
	{ AMLOP_MOD,		  "Mod",	     "iit",   },
	{ AMLOP_FINDSETLEFTBIT,	  "FindSetLeftBit",  "it",    },
	{ AMLOP_FINDSETRIGHTBIT,  "FindSetRightBit", "it",    },

	/* Logical test operations */
	{ AMLOP_LAND,		  "LAnd",	     "ii",    },
	{ AMLOP_LOR,		  "LOr",	     "ii",    },
	{ AMLOP_LNOT,		  "LNot",	     "i",     },
	{ AMLOP_LNOTEQUAL,	  "LNotEqual",	     "tt",    },
	{ AMLOP_LLESSEQUAL,	  "LLessEqual",	     "tt",    },
	{ AMLOP_LGREATEREQUAL,	  "LGreaterEqual",   "tt",    },
	{ AMLOP_LEQUAL,		  "LEqual",	     "tt",    },
	{ AMLOP_LGREATER,	  "LGreater",	     "tt",    },
	{ AMLOP_LLESS,		  "LLess",	     "tt",    },

	/* Named objects */
	{ AMLOP_NAMECHAR,	  "NameRef",	     "n" },
	{ AMLOP_ALIAS,		  "Alias",	     "nN",  },
	{ AMLOP_NAME,		  "Name",	     "Nt",  },
	{ AMLOP_EVENT,		  "Event",	     "N",   },
	{ AMLOP_MUTEX,		  "Mutex",	     "Nb",  },
	{ AMLOP_DATAREGION,	  "DataRegion",	     "Nttt" },
	{ AMLOP_OPREGION,	  "OpRegion",	     "Nbii" },
	{ AMLOP_SCOPE,		  "Scope",	     "pNT"  },
	{ AMLOP_DEVICE,		  "Device",	     "pNT"  },
	{ AMLOP_POWERRSRC,	  "Power Resource",  "pNbwT" },
	{ AMLOP_THERMALZONE,	  "ThermalZone",     "pNT" },
	{ AMLOP_PROCESSOR,	  "Processor",	     "pNbdbT", },
	{ AMLOP_METHOD,		  "Method",	     "pNfM",  },

	/* Field operations */
	{ AMLOP_FIELD,		  "Field",	     "pnfF" },
	{ AMLOP_INDEXFIELD,	  "IndexField",	     "pntfF" },
	{ AMLOP_BANKFIELD,	  "BankField",	     "pnnifF" },
	{ AMLOP_CREATEFIELD,	  "CreateField",     "tiiN",   },
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",    },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",    },
	{ AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",    },
	{ AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",    },
	{ AMLOP_CREATEBITFIELD,	  "CreateBitField",  "tiN",    },

	/* Conversion operations */
	{ AMLOP_TOINTEGER,	  "ToInteger",	     "tt",     },
	{ AMLOP_TOBUFFER,	  "ToBuffer",	     "tt",     },
	{ AMLOP_TODECSTRING,	  "ToDecString",     "it",     },
	{ AMLOP_TOHEXSTRING,	  "ToHexString",     "it",     }, 
	{ AMLOP_TOSTRING,	  "ToString",	     "t",      },
	{ AMLOP_FROMBCD,	  "FromBCD",	     "it",     },
	{ AMLOP_TOBCD,		  "ToBCD",	     "it",     },
	{ AMLOP_MID,		  "Mid",	     "tiit",   },

	/* Mutex/Signal operations */
	{ AMLOP_ACQUIRE,	  "Acquire",	     "tw",     },
	{ AMLOP_RELEASE,	  "Release",	     "t",      },
	{ AMLOP_SIGNAL,		  "Signal",	     "t",      },
	{ AMLOP_WAIT,		  "Wait",	     "ti",     },
	{ AMLOP_RESET,		  "Reset",	     "t",      },
 
	{ AMLOP_INDEX,		  "Index",	     "tit",    },
	{ AMLOP_DEREFOF,	  "DerefOf",	     "t",      },
	{ AMLOP_REFOF,		  "RefOf",	     "t",      },
	{ AMLOP_CONDREFOF,	  "CondRef",	     "tt",     },

	{ AMLOP_LOADTABLE,	  "LoadTable",	     "tttttt" },
	{ AMLOP_STALL,		  "Stall",	     "i",      },
	{ AMLOP_SLEEP,		  "Sleep",	     "i",      },
	{ AMLOP_LOAD,		  "Load",	     "nt" },
	{ AMLOP_UNLOAD,		  "Unload",	     "t" }, 
	{ AMLOP_STORE,		  "Store",	     "tt",     },
	{ AMLOP_CONCAT,		  "Concat",	     "ttt" },
	{ AMLOP_CONCATRES,	  "ConcatRes",	     "ttt" },
	{ AMLOP_NOTIFY,		  "Notify",	     "ti" },
	{ AMLOP_SIZEOF,		  "Sizeof",	     "t",      },
	{ AMLOP_MATCH,		  "Match",	     "tbibii", },
	{ AMLOP_OBJECTTYPE,	  "ObjectType",	     "t", },
	{ AMLOP_COPYOBJECT,	  "CopyObject",	     "tt" },
	{ 0xFFFF }
};

d1099 1
a1099 1
	struct aml_opcode *ptab = aml_table;
d1101 3
a1103 2
	while (ptab->opcode != 0xFFFF) {
		if (ptab->opcode == opcode) return ptab->mnem;
d1106 1
a1106 1
	return "";
d1114 2
a1115 1
struct aml_opcode *aml_getopcode(struct acpi_context *ctx)
d1117 2
a1118 2
	struct aml_opcode *ptab;
	u_int16_t twocode, opcode;
d1136 2
a1137 1
	for (ptab = aml_table; ptab->opcode != 0xFFFF; ptab++) {
d1139 2
a1140 2
			return ptab;
	}
d1142 2
a1143 1
	return NULL;
d1151 12
a1162 6
	case AML_MATCH_TR: return (1);
	case AML_MATCH_EQ: return (lhs == rhs);
	case AML_MATCH_LT: return (lhs < rhs);
	case AML_MATCH_LE: return (lhs <= rhs);
	case AML_MATCH_GE: return (lhs >= rhs);
	case AML_MATCH_GT: return (lhs > rhs);
d1164 1
d1171 2
a1172 2
	struct aml_node *ret;
	const char *sname;
d1178 1
d1180 2
a1181 1
		if (root) root = root->parent;
d1184 1
d1188 1
a1188 1
	for (ret=NULL; root && !ret; root = root->sibling) {
d1192 1
d1195 3
a1197 3
			if (!strcmp(name, sname)) {
				return root;
			}
d1202 2
a1203 1
	return ret;
d1208 1
a1208 1
	      struct aml_value *result, struct aml_value *env)
d1213 3
a1215 1
		dnprintf(50, "found eval object : %s, %.4x\n", root->name, root->opcode);
d1218 1
d1225 1
a1225 1
	int64_t rval, cb;
d1237 1
a1237 1
		else {
a1238 1
		}
d1240 1
d1245 3
a1247 2
/* aml_bufcpy copies/shifts buffer data, special case for aligned transfers
 *   dstPos/srcPos are bit positions within destination/source buffers
d1251 1
a1251 1
	   int len)
d1253 1
a1253 1
	int idx;
d1260 1
d1270 1
a1270 1
	int rc;
d1279 2
a1280 1
	return (alen ? AMLOP_LGREATEREQUAL : (blen ? AMLOP_LLESSEQUAL : AMLOP_LEQUAL));
d1283 3
a1285 2
/* Search list of objects for a name match 
 *  Special case for fields: search children only
d1287 2
a1288 1
struct aml_node *_aml_searchname(struct aml_node *list, const char *name)
d1290 4
a1293 1
	struct aml_node *child;
a1294 3
	if (list == NULL) {
		return NULL;
	}
d1298 3
a1300 2
		    list->opcode == AMLOP_INDEXFIELD) {
			if ((child = _aml_searchname(list->child, name)) != NULL) {
d1302 4
a1305 5
			}
		}
		if (list->name && !strncmp(list->name, name, AML_NAMESEG_LEN)) {
			return list;
		}
d1308 2
a1309 1
	return NULL;
d1313 2
a1314 1
struct aml_node *aml_doname(struct aml_node *root, const char *name, int create)
d1316 1
a1316 1
	struct aml_node *tmp;
d1322 1
d1325 2
a1326 3
		if ((root = root->parent) == NULL) {
			return NULL;
		}
d1328 2
a1329 1
	if (root == NULL) {
d1331 1
a1331 1
	}
d1341 2
a1342 1
		if (*name == '.') name++;
d1350 5
a1354 4
				tmp->name = acpi_os_allocmem(AML_NAMESEG_LEN+1);
				if (tmp->name) {
					memcpy((char *)tmp->name, name, AML_NAMESEG_LEN);
				}
d1359 2
a1360 1
	return tmp;
d1363 2
a1364 1
struct aml_node *aml_createname(struct aml_node *root, const char *name)
d1369 2
a1370 1
struct aml_node *aml_searchname(struct aml_node *root, const char *name)
d1375 2
a1376 1
struct aml_value *aml_ederef(struct acpi_context *ctx, struct aml_value *val)
d1378 3
a1380 3
	struct aml_node	 *pn;
	struct aml_value *ref;
	int64_t i1;
d1382 1
a1382 1
	if (val == NULL) {
d1384 1
a1384 1
	}
d1387 3
a1389 2
		if (val->v_objref.ref == NULL) {
			if ((pn = aml_searchname(ctx->scope, val->name)) != NULL) {
d1391 2
a1392 3
			}
		}
		if (val->v_objref.ref != NULL) {
d1394 2
a1395 2
		}
		return NULL;
d1400 1
a1400 1
		if (i1 == -1) {
d1402 2
a1403 2
		}
		if (i1 > ref->length) {
d1405 1
a1405 1
		}
d1410 4
a1413 2
				dnprintf(40, "LazyPkg: %lld/%d\n", i1, ref->length);
				ref->v_package[i1] = aml_allocvalue(AML_OBJTYPE_UNINITIALIZED, 0, NULL);
d1415 1
a1415 1
			return ref->v_package[i1];
d1417 2
a1418 1
			return aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 8, ref->v_buffer+i1);
d1422 1
d1425 2
a1426 1
	return val;
a1429 3
aml_get_pciaddr(struct acpi_context *, struct aml_node *);

uint64_t
d1432 3
a1434 3
	struct aml_node *pn;
	uint8_t  bus, dev, fn;
	uint64_t ioaddr;
d1437 1
a1437 1
		return (0xFFFF);
d1441 1
a1441 1
	fn  = ioaddr & 0xFFFF;
d1445 1
a1445 2
	if ((pn = aml_searchname(node, "_BBN")) != NULL) {
		/* _BBN holds <bus> */
d1447 1
a1447 1
	}
d1453 1
a1453 1
	   struct aml_value *rhs)
d1455 6
a1460 6
	struct aml_value *e_rgn;
	struct aml_value *rv;
	struct aml_value  tmp;
	uint8_t *pb;
	uint64_t ioaddr;
	int blen;
d1469 4
a1472 1
		/* Set INDEX value to FIELD position byte, then write RHS to DATA */
d1474 2
a1475 1
			dnprintf(40, "aml_efield: INDEXFIELD not byte-aligned..\n");
d1492 1
a1492 1
			return NULL;
d1495 2
a1496 1
		ioaddr = e_rgn->v_opregion.iobase + aml_bytepos(e_fld->v_field.bitpos);
d1499 1
a1499 1
		pb = acpi_os_allocmem(blen+8);   // padded space
d1503 1
a1503 3
			/* Read field 
			 *  XXX: don't need pb if aligned
			 */
d1506 2
a1507 1
					acpi_mutex_acquire(ctx, aml_global_lock, -1);
d1510 4
a1513 3
					   e_rgn->v_opregion.iospace, ioaddr,
					   AML_FIELD_ACCESS(e_fld->v_field.flags),
					   blen, pb);
d1515 2
a1516 1
					acpi_mutex_release(ctx, aml_global_lock);
d1520 4
a1523 3
				aml_bufcpy(rv->v_buffer, 0,
					   pb, e_fld->v_field.bitpos,
					   e_fld->v_field.bitlen);
d1526 1
a1526 1
			return rv;
d1533 1
d1539 3
a1541 1
				 e_rgn->v_opregion.iobase, aml_bytepos(e_fld->v_field.bitpos));
d1543 3
a1545 3
				   e_rgn->v_opregion.iospace, ioaddr,
				   AML_FIELD_ACCESS(e_fld->v_field.flags),
				   blen, pb);
d1552 1
a1552 1
			memset(pb, 0xFF, blen+8);
d1555 1
a1555 1
			memset(pb, 0x00, blen+8);
d1558 1
d1560 4
a1563 4
		aml_bufcpy(pb, e_fld->v_field.bitpos, 
			   rv->v_buffer, 0, 
			   e_fld->v_field.bitlen);
		if (rv != rhs) {
d1565 1
a1565 1
		}
d1567 6
a1572 4
			   e_rgn->v_opregion.iospace,
			   e_rgn->v_opregion.iobase + aml_bytepos(e_fld->v_field.bitpos),
			   AML_FIELD_ACCESS(e_fld->v_field.flags),
			   blen, pb);
d1576 1
d1584 1
a1584 1
			return NULL;
d1586 1
d1591 1
a1591 1
			if (aml_valid(rv)) {
d1593 3
a1595 4
					   e_rgn->v_buffer, e_fld->v_field.bitpos, 
					   e_fld->v_field.bitlen);
			}
			return rv;
d1601 4
a1604 3
			   rv->v_buffer, 0, 
			   e_fld->v_field.bitlen);
		if (rv != rhs) {
a1605 1
		}
d1608 2
a1609 1
	return NULL;
d1615 1
a1615 1
	struct aml_value *pb, *val;
d1618 1
a1618 1
		return NULL;
d1623 1
a1623 1
		if (mlen < val->length) {
d1625 1
a1625 1
		}
d1627 1
a1627 1
		if (val->v_buffer && val->length) {
d1629 3
a1631 2
		}
		return pb;
d1635 1
d1639 1
d1641 3
a1643 1
		return aml_allocvalue(AML_OBJTYPE_BUFFER, val->length, val->v_string);
d1646 1
a1646 1
		return NULL;
d1653 2
a1654 2
	struct aml_value *pb;
	int64_t rval;
d1664 1
a1664 1
		if (val->length < 8) {
d1666 2
a1667 2
		}
		return rval;
d1670 2
a1671 1
		return val->v_integer;
d1675 2
a1676 1
				rval = aml_str2int(val->v_string+2, val->length, 16);
d1678 2
a1679 1
				rval = aml_str2int(val->v_string, val->length, 10);
d1681 2
a1682 1
		return rval;
d1685 2
a1686 1
		if (ctx == NULL) return 0;
d1691 2
a1692 1
		if (ctx == NULL) return 0;
d1696 2
a1697 1
		if (ctx == NULL) return 0;
d1704 2
a1705 1
	if (pb != NULL) {
d1707 2
a1708 2
	}
	return 0x00;
@


1.32
log
@Hook acpi to ddb since we need to be able to do some live debugging.

Lots and lots of help from miod@@ and deraadt@@
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.31 2006/02/26 07:57:47 marco Exp $ */
a57 18
struct aml_opcode
{
	u_int16_t    opcode;
	const char  *mnem;
	const char  *args;
};

struct acpi_context
{
	int depth;
	uint8_t *pos;
	uint8_t *start;
	struct acpi_softc  *sc;
	struct aml_value  **locals;
	struct aml_value  **args;
	struct aml_node	   *scope;
};

a79 1
const char *aml_parse_name(struct acpi_context *);
a81 1
struct aml_opcode *aml_getopcode(struct acpi_context *ctx);
a91 6
void acpi_freecontext(struct acpi_context *ctx);
struct acpi_context *acpi_alloccontext(struct acpi_softc *sc, 
				       struct aml_node *node,
				       int argc, 
				       struct aml_value *argv);

a117 1
int aml_parse_length(struct acpi_context *ctx);
a125 1
struct aml_node *aml_searchname(struct aml_node *, const char *);
a128 1
int64_t aml_eparseint(struct acpi_context *, int type);
a130 1
u_int8_t *aml_eparselen(struct acpi_context *);
d956 1
a956 1
	{ AMLOP_STRINGPREFIX,	  "String",	     "s"  },
@


1.31
log
@Delete some debug printing that wasn't compiling.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.30 2006/02/23 19:56:44 jordan Exp $ */
d25 5
a117 1
void aml_walkroot(void);
d2899 1
a2899 1
aml_walkroot()
@


1.30
log
@Pre-parsing PCI address for opregion
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.29 2006/02/22 19:29:24 jordan Exp $ */
d2848 2
a2849 2
	dnprintf(50, " opcode:%.4x  flag:%.2x  mnem:%s %s ",
		 node->opcode, node->flag, node->mnem, node->name ? node->name : "");
a2851 4
		dnprintf(50, "argcount:%d serialized:%d synclevel:%d",
			 AML_METHOD_ARGCOUNT(node->flag),
			 AML_METHOD_SERIALIZED(node->flag),
			 AML_METHOD_SYNCLEVEL(node->flag));
a2860 4
		dnprintf(50, "access:%d lock:%d update:%d",
			 AML_FIELD_ACCESS(node->flag),
			 AML_FIELD_LOCK(node->flag),
			 AML_FIELD_UPDATE(node->flag));
@


1.29
log
@Added new aml_register_notify to handle call-by-ID
Moved powerdown code to button device
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.28 2006/02/20 22:03:58 jordan Exp $ */
d1406 2
a1407 2
aml_get_pciaddr(struct acpi_context *, struct aml_node *,
		uint64_t);
d1409 1
a1409 2
aml_get_pciaddr(struct acpi_context *ctx, struct aml_node *node,
		uint64_t ioaddr)
d1411 6
a1416 2
	struct aml_node *val;
	uint8_t reg, bus, dev, fn;
d1418 7
a1424 10
	/* ioaddr on input = <reg> */
	bus = dev = fn = 0;
	reg = ioaddr;
	if ((val = aml_searchname(node, "_ADR")) != NULL) {
		/* _ADR holds <dev>:<fn> */
	  	ioaddr = aml_eparseint(ctx, AML_ANYINT);
		fn  = ioaddr & 0xFFFF;
		dev = ioaddr >> 16;
	}
	if ((val = aml_searchname(node, "_BBN")) != NULL) {
d1426 1
a1426 2
		ioaddr = aml_eparseint(ctx, AML_ANYINT);
		bus = ioaddr;
d1428 1
a1428 1
	return ACPI_PCI_ADDR(bus, dev, fn, reg);
a1471 3
		if (e_rgn->v_opregion.iospace == GAS_PCI_CFG_SPACE) {
			ioaddr = aml_get_pciaddr(ctx, ctx->scope, ioaddr);
		}
d2508 11
d2775 69
@


1.28
log
@Calling parseint instead of parseval for getpciaddr
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.27 2006/02/20 21:58:49 jordan Exp $ */
d242 1
d253 4
a256 3
void aml_register_notify(struct aml_node *node,
			 int (*proc)(struct aml_node *, int, void *),
			 void *arg)
d260 2
a261 2
	dnprintf(10, "aml_register_notify: %s %x\n",
		 node->name, proc);
d266 2
a267 1

d271 2
a272 1
void aml_notify(struct aml_node *node, int notify_value)
d276 2
d279 15
a293 3
		if (pdata->node == node) {
			pdata->cbproc(node, notify_value, pdata->cbarg);
		}
@


1.27
log
@Added aml_bufcmp buffer comparisons
Added getpciaddr for pci opregions
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.26 2006/02/20 21:55:42 marco Exp $ */
a1394 1
	struct aml_value *rv;
d1402 1
a1402 3
		rv = aml_eparsenode(ctx, val);
		ioaddr = aml_val2int(ctx, rv);
		aml_freevalue(&rv);
d1408 1
a1408 3
		rv = aml_eparsenode(ctx, val);
		ioaddr = aml_val2int(ctx, rv);
		aml_freevalue(&rv);
@


1.26
log
@Fix a typo cbproc -> proc.  Found by drahn@@

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.25 2006/02/19 21:32:30 jordan Exp $ */
d136 1
a185 1
struct aml_value *aml_edebugobj;
d569 3
d578 8
d1241 16
d1387 32
d1427 1
d1459 5
d1477 1
a1477 2
					   e_rgn->v_opregion.iospace,
					   e_rgn->v_opregion.iobase + aml_bytepos(e_fld->v_field.bitpos),
d1504 1
a1504 2
				   e_rgn->v_opregion.iospace,
				   e_rgn->v_opregion.iobase + aml_bytepos(e_fld->v_field.bitpos),
d1845 4
d2270 1
a2270 4
		if (aml_edebugobj == NULL) {
			aml_edebugobj = aml_allocvalue(AML_OBJTYPE_DEBUGOBJ, 0, NULL);
		}
		rv = aml_edebugobj;
d2278 1
a2278 1
		if (i1 > 0) {
a2279 1
		}
d2291 1
a2291 1
		for (i1=0; i1 < i2 && ctx->pos < end; i1++) {
a2292 1
		}
d2397 1
a2397 1
		if (i1 > tmp->length) {
a2398 1
		}
d2400 1
a2400 1
			if (tmp->v_buffer[i2] == 0) {
a2401 1
			}
d2583 1
a2583 1
		if (aml_valid(lhs)) {
a2584 1
		}
d2670 1
a2670 1
	if (end > ctx->pos) {
a2671 1
	}
d2683 1
a2683 1
	if (node == NULL) {
a2684 1
	}
d2687 1
a2687 1
		if (pn->value) {
a2688 1
		}
d2702 1
a2702 1
	if (node->value == NULL) {
a2703 1
	}
d2747 2
a2748 3
	if (rv != NULL) {
	  *ret = *rv;
	}
d2805 1
a2805 1
		for(idx=0; idx<node->depth; idx++) {
a2806 1
		}
@


1.25
log
@Added code for aml_notify GPE notification callback
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.24 2006/02/19 04:50:47 marco Exp $ */
d259 1
a259 1
		 node->name, cbproc);
@


1.24
log
@jordan:
Enable interrupts.
Added peripheral code to make this work.

marco:
Replace softintr and other types of interrupts with a handler with context.
Fixed interrupt magic for GPEs.
Some KNF

This is work done by jordan and I but has to be a single commit.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.23 2006/02/17 17:35:59 marco Exp $ */
d236 50
d2414 3
d2423 1
@


1.23
log
@Add a generic delay function as per the ACPI spec.

from jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.22 2006/02/17 00:46:54 jordan Exp $ */
d236 3
a238 2
void aml_addchildnode(struct aml_node *parent,
		      struct aml_node *child)
d250 3
a252 2
struct aml_node *aml_create_node(struct aml_node *parent, int opcode,
				 const char *mnem, u_int8_t *start)
d304 2
d364 1
a364 1
	return aml_allocvalue(AML_OBJTYPE_STRING, strlen(str), (void *)str);
d525 1
d744 1
a747 3
	if (opcode >= 'A' && opcode <= 'Z')
		return (1);

d822 1
d825 1
a847 4
	case AMLOP_INCREMENT:
		return (lhs + 1);
	case AMLOP_DECREMENT:
		return (lhs - 1);
d1054 1
a1054 1
	if (aml_isnamedop(*ctx->pos)) {
a1055 1
	}
d1173 1
d1175 3
a1177 6
	else {
		/* Misaligned transfer: perform bitwise copy */
		for (idx=0; idx<len; idx++) {
			aml_setbit(pDst, idx+dstPos, aml_tstbit(pSrc, idx+srcPos));
		}
	}
d1714 2
d1726 2
a1727 5
	while (lhs->type == AML_OBJTYPE_OBJREF) {
		lhs = aml_ederef(ctx, lhs);
	}

	switch (lhs->type) {
d1730 1
a1730 1
		*lhs = *rhs;
d1734 1
a1734 1
		aml_efield(ctx, lhs, rhs);
d1741 6
a1746 2
		_aml_freevalue(lhs);
		*lhs = *rhs;
a1747 1
	aml_showvalue(lhs);
d2363 1
a2363 1
		dnprintf(40, "NOTIFY: %llx %s\n", i1, lhs->name);
@


1.22
log
@Fixed code for handling _INI
Rearranged debug statements
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.21 2006/02/16 22:42:11 jordan Exp $ */
d2057 1
d2316 1
d2321 1
d2463 3
a2465 1
		rv  = aml_allocint(lhs->type);
@


1.21
log
@Added stub for calling _INI
Fixed aml_dowhile for NULL return
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.20 2006/02/16 21:11:13 jordan Exp $ */
a373 1
#if 0
a375 1
#endif
d1322 1
a1322 2
#if 0
	dnprintf(40, "efield %s: ", rhs ? "set" : "get");
a1324 1
#endif
a1719 1
#if 0
a1724 1
#endif
a1746 2
#if 0
	dnprintf(50, "post   : ");
d1748 1
a1748 1
#endif
d1845 1
a1845 1
	if (*end == AMLOP_ELSE) {
a2078 1
#if 0
a2080 1
#endif
a2400 1
#if 0
a2402 1
#endif
d2628 1
d2633 3
a2635 1
	*ret = *rv;
@


1.20
log
@Fixed parser/evaluator to retrieve battery info+state
Cleanup of parser
Dell laptops return battery status
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.19 2006/02/03 23:55:47 jordan Exp $ */
d1891 1
a1891 1
		if (*ctx->pos == AMLOP_BREAK) {
d2798 1
d2805 3
d2809 2
d2813 1
@


1.19
log
@Rewrote aml parser yet again...
Fixed bus_space_map for i386/amd64
Added _BST and _BIF to acpibat to get status/info
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.18 2006/01/20 20:20:28 jordan Exp $ */
d30 22
a51 1
void *stacktop;
d90 1
a90 2

int aml_parse_length(struct acpi_context *);
d102 2
d105 1
a105 2
int aml_lsb(u_int64_t val);
int aml_msb(u_int64_t val);
d118 1
a118 1
int  aml_testlogical(u_int16_t, long, long);
d125 1
a125 1
struct aml_value *_aml_setnodevalue(struct acpi_context *, struct aml_node *, struct aml_value *, uint64_t);
d127 3
a129 3
struct aml_node *aml_create_node(struct aml_node *parent, 
				 int opc, const char *mnem,
				 uint8_t *start);
a132 2
struct aml_node *childOf(struct aml_node *, int);

d137 37
a173 4
void aml_create_bufferunit(struct acpi_context *, struct aml_node *, int, int);
void aml_create_fieldunit(struct acpi_context *, struct aml_node *, const char *, int, int, int);
struct aml_value *aml_bufferio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs);
struct aml_value *aml_fieldio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs);
d180 3
d185 1
a185 3

#define acpi_mutex_acquire(ctx,lock,iv)	 dnprintf(10,"ACQUIRE: %x" #lock "\n", (short)iv)
#define acpi_mutex_release(ctx,lock)	 dnprintf(10,"RELEASE: " #lock "\n")
d204 12
a235 7
#define aml_ipaddr(n) ((n)-aml_root.start)

#define AML_REVISION   0x01
#define AML_NUM_LOCALS 8
#define AML_INTSTRLEN 16
#define AML_NAMESEG_LEN 4

d250 1
a250 1
				 const char *mnem, uint8_t *start)
a273 1
 *   lbl  : Debugging label
d276 1
a276 2
aml_allocvalue(int type, int64_t ival, void *bval, 
	       const char *lbl)
a283 1
	rv->refcnt = 1;
d286 6
d296 1
a302 1
		rv->v_string = NULL;
d305 1
a305 1
			if (bval) {
a306 1
			}
a311 1
		rv->v_buffer = NULL;
d314 1
a314 1
			if (bval) {
a315 1
			}
d324 1
a324 1
			dnprintf(10, "alloc package..\n");
a330 1
		rv->name = bval;
a333 1
		rv->name = bval;
a335 1
	case AML_OBJTYPE_NAMEREF:
a341 2
		rv->name = bval;
		break;
d346 1
a346 1
		dnprintf(10, "Unknown aml_allocvalue: %.2x\n", type);
d352 1
a352 1
aml_allocint(uint64_t ival, int sc)
d354 1
a354 1
	return aml_allocvalue(AML_OBJTYPE_INTEGER, ival, &sc, "integer");
d360 1
a360 1
	return aml_allocvalue(AML_OBJTYPE_STRING, strlen(str), (void *)str, "string");
d364 1
a364 1
aml_freevalue(struct aml_value **pv)
a365 1
	struct aml_value *v = *pv;
d370 9
a378 5
		return (0);
	if (v->refcnt < 0)
		return (0);
	if (--v->refcnt > 0)
		return (0);
a379 1
	//dnprintf(50, "freeing value : %x\n", v->type);
d401 1
d404 1
d406 1
a406 4
	acpi_os_freemem(v);
	*pv = NULL;

	return (1);
a408 2
void aml_dump(int len, u_int8_t *buf);

d410 1
a410 1
aml_dump(int len, u_int8_t *buf)
d412 3
a414 5
	int idx;
	
	dnprintf(50, "{ ");
	for (idx=0; idx<len; idx++) {
		dnprintf(50, "%s0x%.2x", idx ? ", " : "", buf[idx]);
a415 1
	dnprintf(50, " }\n");
d425 2
d430 10
d441 2
a442 1
		dnprintf(50, "integer: %x\n", value->v_integer);
a446 4
	case AML_OBJTYPE_BUFFER:
		dnprintf(50, "buffer: %d ", value->length);
		aml_dump(value->length, value->v_buffer);
		break;
d453 4
d461 1
a461 1
		dnprintf(50, "mutex : %x\n", value->v_integer);
d482 2
a483 1
		dnprintf(50, "field: access=%x,lock=%x,update=%x type=%6s pos=%.4x len=%.4x\n",
a486 1
			 value->v_field.ftyp,
d493 2
a494 2
		dnprintf(50, "bufferfield: type=%.4x pos=%.4x len=%.4x ", 
			 value->v_field.type,
d514 2
a515 1
aml_comparevalue(int opcode, const struct aml_value *lhs, const struct aml_value *rhs)
d517 2
a518 4
	if (lhs->type != rhs->type) {
		dnprintf(50, "aml_compare: type mismatch: %x,%x\n",
			 lhs->type, rhs->type);
		return (0);
d520 2
a521 7
	switch (lhs->type) {
	case AML_OBJTYPE_INTEGER:
		return aml_testlogical(opcode, lhs->v_integer, rhs->v_integer);
	case AML_OBJTYPE_STRING:
	case AML_OBJTYPE_BUFFER:
		/* XXX: implement buffer/string compare */
		break;
d523 2
a524 1
	return (0);
d533 1
d535 3
a537 1
		return aml_allocint(rhs->v_integer, rhs->length);
d539 1
a539 1
		return aml_allocvalue(AML_OBJTYPE_STRING,
d541 1
a541 2
				      rhs->v_string,
				      "copystr");
d543 1
a543 1
		return aml_allocvalue(AML_OBJTYPE_BUFFER,
d545 1
a545 2
				      rhs->v_buffer,
				      "copybuf");
d547 1
a547 1
		return aml_allocvalue(AML_OBJTYPE_PACKAGE,
d549 1
a549 2
				      rhs->v_package,
				      "copypkg");
d553 1
a553 1
		rv = aml_allocvalue(rhs->type, 0, NULL, "field");
d562 2
a563 2
		dnprintf(10,"copy unknown : %x\n", rhs->type);
		rv = aml_allocvalue(rhs->type, 0, NULL, "any");
d570 41
d624 1
a624 1
uint64_t
a628 1
	ctx->pos += size;
d630 2
a631 1
	case 1:
d633 2
a634 1
	case 2:
d636 2
a637 1
	case 4:
d639 2
a640 1
	case 8:
d660 1
a660 1
	lcode = aml_parse_int(ctx, 1);
d666 3
a668 3
	if (lcode >= 0x40)  ival |= aml_parse_int(ctx, 1) << 4;
	if (lcode >= 0x80)  ival |= aml_parse_int(ctx, 1) << 12;
	if (lcode >= 0xC0)  ival |= aml_parse_int(ctx, 1) << 20;
d819 1
d855 6
d868 1
a868 1
aml_testlogical(u_int16_t opcode, long lhs, long rhs)
d870 1
d976 2
a977 2
	{ AMLOP_SCOPE,		  "Scope",	     "pNT" },
	{ AMLOP_DEVICE,		  "Device",	     "pNT" },
d1032 12
a1050 1
	uint8_t *pc;
d1052 1
a1052 1
	uint16_t twocode, opcode;
d1055 1
a1055 2
	pc = ctx->pos;
	if (aml_isnamedop(*pc)) {
d1059 1
a1059 1
		opcode = aml_parse_int(ctx, 1);
d1075 1
a1078 13
struct aml_node *
childOf(struct aml_node *parent, int child)
{
	struct aml_node *node = parent->child;

	while(node && child--) {
		node = node->sibling;
	}
	return node;
}

struct aml_value aml_debugobj;

a1183 36
struct aml_value *aml_econcat(struct acpi_context *ctx);
struct aml_value *aml_ederef(struct acpi_context *ctx, struct aml_value *val);
void aml_resizeval(struct aml_value *pv, int newlen);
int aml_parse_length(struct acpi_context *ctx);
struct aml_value *aml_edebugobj;
struct aml_value *aml_eparseval(struct acpi_context *ctx);
struct aml_opcode *aml_getopcode(struct acpi_context *ctx);
struct aml_value *aml_domethod(struct acpi_context *ctx, struct aml_value *val);
struct aml_value *aml_esetnodevalue(struct acpi_context *ctx,  struct aml_value *lhs, 
				    struct aml_value *rhs, int64_t rval);
struct aml_value *aml_eparselist(struct acpi_context *ctx, uint8_t *end);

struct aml_node *_aml_searchname(struct aml_node *, const char *);
struct aml_node *aml_doname(struct aml_node *, const char *, int);
struct aml_node *aml_searchname(struct aml_node *, const char *);
struct aml_node *aml_createname(struct aml_node *, const char *);
struct aml_value *aml_doif(struct acpi_context *ctx);
struct aml_value *aml_eparsescope(struct acpi_context *ctx, const char *name, uint8_t *end,
				  struct aml_opcode *opc);
struct aml_value *aml_dowhile(struct acpi_context *ctx);
int64_t aml_eparseint(struct acpi_context *ctx);
struct aml_value *aml_efieldunit(struct acpi_context *ctx, int opcode);
struct aml_value *aml_ebufferfield(struct acpi_context *ctx, int bitlen, int size, int opcode);
uint8_t *aml_eparselen(struct acpi_context *ctx);
struct aml_value *aml_eparseref(struct acpi_context *ctx);
int64_t aml_val2int(struct acpi_context *ctx, struct aml_value *val);
struct aml_value *aml_efield(struct acpi_context *ctx, struct aml_value *e_fld,
			     struct aml_value *rhs);
struct aml_value *aml_val2buf(struct acpi_context *ctx, struct aml_value *val);
void aml_addvname(struct acpi_context *ctx, const char *name, int opcode,
		  struct aml_value *val);
struct aml_value *aml_eparsenode(struct acpi_context *ctx, struct aml_node *node);
void aml_delchildren(struct acpi_context *ctx, struct aml_node *node);
struct aml_value *aml_doloadtable(struct acpi_context *ctx);
struct aml_value *aml_domatch(struct acpi_context *ctx);

d1294 1
a1294 1
			aml_resizeval(ref, i1);
a1297 1
#if 1
d1300 2
a1301 2
				dnprintf(10, "LazyPkg: %lld/%d\n", i1, ref->length);
				ref->v_package[i1] = aml_allocint(0, 0);
a1302 1
#endif
d1305 1
a1305 1
			return aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 8, ref->v_buffer+i1, "test");
a1313 12
struct aml_value *aml_eparseref(struct acpi_context *ctx)
{
	struct aml_value *lhs, *rhs;

	lhs = aml_eparseval(ctx);
	rhs = aml_ederef(ctx, lhs);
	if (lhs != rhs) {
		aml_freevalue(&lhs);
	}
	return rhs;
}

d1321 2
d1324 2
a1325 1
	dnprintf(10, "efield %s: ", rhs ? "set" : "get");
d1328 1
d1334 2
a1335 2
		if (e_fld->v_field.bitpos & 7) {
			dnprintf(10, "aml_efield: INDEXFIELD not byte-aligned..\n");
d1337 1
a1337 1
		tmp.v_integer = e_fld->v_field.bitpos >> 3;
d1351 1
a1351 1
			dnprintf(10, "aml_efield: Wrong FIELD type!\n");
d1354 3
a1356 4
		if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
			acpi_mutex_acquire(ctx, aml_global_lock, -1);
		}
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, aml_bytelen(e_fld->v_field.bitlen), NULL, 0);
d1358 9
a1366 2
			/* Read field */
			if (rv != NULL) {
d1371 4
a1374 1
					   aml_bytelen(e_fld->v_field.bitlen), rv->v_buffer);
d1376 5
a1380 2
			if (AML_FIELD_LOCK(e_fld->v_field.flags)) {
				acpi_mutex_release(ctx, aml_global_lock);
d1386 3
a1388 3
		rhs = aml_val2buf(ctx, rhs);
		aml_showvalue(rhs);

d1391 1
d1393 2
a1394 1
			dnprintf(10, "old iobase = %llx,%lx\n", e_rgn->v_opregion.iobase, aml_bytepos(e_fld->v_field.bitpos));
d1399 2
a1400 1
				   aml_bytelen(e_fld->v_field.bitlen), rv->v_buffer);
d1402 2
d1406 1
a1406 1
			memset(rv->v_buffer, 0xFF, rv->length);
d1409 1
a1409 1
			memset(rv->v_buffer, 0x00, rv->length);
d1412 3
a1414 2
		aml_bufcpy(rv->v_buffer, e_fld->v_field.bitpos, 
			   rhs->v_buffer, 0, 
d1416 3
d1423 1
a1423 1
			   aml_bytelen(e_fld->v_field.bitlen), rv->v_buffer);
d1427 1
d1433 1
a1433 1
			dnprintf(10, "aml_efield: Wrong type!\n");
d1436 1
d1439 2
a1440 3
			rv = aml_allocvalue(AML_OBJTYPE_BUFFER, aml_bytelen(e_fld->v_field.bitlen), 
					    NULL, 0);
			if (rv != NULL) {
d1449 1
a1449 1
		rhs = aml_val2buf(ctx, rhs);
d1451 1
a1451 1
			   rhs->v_buffer, 0, 
d1453 3
d1462 1
a1462 1
aml_val2buf(struct acpi_context *ctx, struct aml_value *val)
d1464 2
d1468 2
d1472 8
a1479 1
		return val;
d1483 1
a1483 2
	case AML_OBJTYPE_NAMEREF:
		return aml_val2buf(ctx, aml_ederef(ctx, val));
d1485 1
a1485 1
		return aml_allocvalue(AML_OBJTYPE_BUFFER, 8, &val->v_integer, "");
d1487 1
a1487 1
		return aml_allocvalue(AML_OBJTYPE_BUFFER, val->length, val->v_string, "");
d1489 1
a1489 1
		dnprintf(10, "Unknown val2buf : %d\n", val->type);
d1491 1
a1491 1
	}    
d1497 1
d1500 1
d1502 1
a1502 1
		dnprintf(10, "null val2int\n");
d1505 1
a1507 1
		rval = 0;
d1512 1
d1516 6
a1521 12
/* XXX: fix me

if (val->v_string == NULL) {
rval = 0;
}
else if (!strncmp(val->v_string, "0x", 2)) {
sscanf(val->v_string+2, "%Lx", &rval);
}
else {
rval = strtol(val->v_string);
}
*/
d1525 2
a1526 1
		val = aml_ederef(ctx, val);
d1530 2
a1531 1
		val = aml_efield(ctx, val, NULL);
d1534 2
a1535 1
		val = aml_domethod(ctx, val);
d1538 5
a1542 2
		dnprintf(10, "Unknown val2int: %x\n", val->type);
		return 0x0;
d1544 1
a1544 1
	return aml_val2int(ctx, val);
d1547 1
a1547 1
void
a1552 2
	val->name   = name;
	val->refcnt = -1;
d1554 9
a1562 6
	if (pn != NULL) {
		pn->opcode = opcode;
		if (!pn->value) {
			pn->value  = val;
		}
		aml_showvalue(val);
d1564 6
a1569 1
	dnprintf(10, "\n");
d1573 1
a1573 1
uint8_t *
d1576 1
a1576 1
	uint8_t *pos = ctx->pos;
d1581 1
a1581 1
/* Return integer value */
d1583 1
a1583 1
aml_eparseint(struct acpi_context *ctx)
d1588 37
a1624 4
	rv = aml_eparseval(ctx);
	rval = aml_val2int(ctx, rv);
	aml_freevalue(&rv);

a1632 2
#define AML_FIELD_RESERVED  0x00
#define AML_FIELD_ATTRIB    0x01
d1637 1
a1637 1
	uint8_t *end;
d1649 1
a1649 2
		tmp.v_field.ftyp = "field";
		tmp.v_field.ref1 = aml_eparseval(ctx);
d1652 2
a1653 3
		tmp.v_field.ftyp = "index";
		tmp.v_field.ref1 = aml_eparseval(ctx);
		tmp.v_field.ref2 = aml_eparseval(ctx);
d1656 3
a1658 4
		tmp.v_field.ftyp = "bank";
		tmp.v_field.ref1 = aml_eparseval(ctx);
		tmp.v_field.ref2 = aml_eparseval(ctx);
		tmp.v_field.ref3 = aml_eparseint(ctx);
d1661 1
a1661 1
	tmp.v_field.flags = aml_parse_int(ctx, 1);
d1671 2
a1672 2
			access = aml_parse_int(ctx, 1);
			attr   = aml_parse_int(ctx, 1);
d1681 1
a1681 3
			if (rv != NULL) {
				aml_addvname(ctx, tmp.name, opcode, rv);
			}
d1689 7
a1695 9
/*
 * Create buffer field object
 *
 *  AMLOP_CREATEFIELD
 *  AMLOP_CREATEBITFIELD
 *  AMLOP_CREATEBYTEFIELD
 *  AMLOP_CREATEWORDFIELD
 *  AMLOP_CREATEDWORDFIELD
 *  AMLOP_CREATEQWORDFIELD
d1698 1
a1698 1
aml_ebufferfield(struct acpi_context *ctx, int bitlen, int size, int opcode)
d1702 2
a1703 2
	rv = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL, "createbf");
	if (rv != NULL) {
d1705 4
a1708 7
		rv->v_field.ref1 = aml_eparseval(ctx);
		rv->v_field.bitpos = aml_eparseint(ctx) * size;
		if (opcode == AMLOP_CREATEFIELD) {
			bitlen = aml_eparseint(ctx);
		}
		rv->name = aml_parse_name(ctx);
		rv->v_field.bitlen = bitlen;
d1710 1
a1710 1
		aml_addvname(ctx, rv->name, opcode, rv);
a1719 2
	struct aml_value *tmp;

d1721 1
a1721 1
		rhs = aml_allocint(rval, 0);
d1724 10
a1733 14
	/* Eval RHS */
	switch (rhs->type) {
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		rhs = aml_efield(ctx, rhs, NULL);
		break;
	case AML_OBJTYPE_NAMEREF:
	case AML_OBJTYPE_OBJREF:
		tmp = aml_ederef(ctx, rhs);
		if (tmp == rhs) {
			dnprintf(10, "No deref!\n");
		}
		rhs = tmp;
		break;
a1735 1
	/* Eval LHS */
d1737 3
a1739 18
	case AML_OBJTYPE_INTEGER:
		if (lhs->length == 0) {
			lhs->v_integer = aml_val2int(ctx, rhs);
		}
		break;
	case AML_OBJTYPE_STRING:
		if (rhs->type != AML_OBJTYPE_STRING) {
			dnprintf(10, "no string...\n");
		}
		else {
			lhs->length   = rhs->length;
			lhs->v_string = rhs->v_string;
		}
		break;
	case AML_OBJTYPE_BUFFER:
		rhs = aml_val2buf(ctx, rhs);
		lhs->length = rhs->length;
		lhs->v_buffer = rhs->v_buffer;
d1741 1
a1742 1
	case AML_OBJTYPE_FIELDUNIT:
d1745 2
a1746 9
	case AML_OBJTYPE_UNINITIALIZED:
		*lhs = *rhs;
		break;
	case AML_OBJTYPE_OBJREF:
		rhs = aml_esetnodevalue(ctx, aml_ederef(ctx, lhs), rhs, 0);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		//aml_freevalue(&lhs->v_debug);
		//lhs->v_debug = aml_copyvalue(rhs);
d1749 3
a1751 1
		dnprintf(10, "Unknown set value: %x\n", lhs->type);
d1753 21
d1775 7
a1781 1
	return rhs;
d1785 2
a1786 1
struct aml_value *aml_eparselist(struct acpi_context *ctx, uint8_t *end)
d1793 1
a1793 1
		rv = aml_eparseval(ctx);
d1798 3
a1800 2
/* Concatenate results */
struct aml_value *aml_econcat(struct acpi_context *ctx)
d1804 3
a1806 3
	lhs = aml_eparseval(ctx);
	rhs = aml_eparseval(ctx);
	set = aml_eparseval(ctx);
d1813 1
a1813 1
				     lhs->length+rhs->length, NULL, "concat");
d1822 1
a1822 1
				     lhs->length+rhs->length, NULL, "concat");
d1829 3
a1835 15
struct aml_value *aml_eparsescope(struct acpi_context *ctx, const char *name, uint8_t *end,
				  struct aml_opcode *opc)
{
	struct aml_node *oldscope;
	struct aml_value *rv;

	oldscope = ctx->scope;
	ctx->scope = aml_createname(ctx->scope, name);
	ctx->scope->mnem = opc->mnem;
	ctx->scope->opcode = opc->opcode;
	rv = aml_eparselist(ctx, end);
	ctx->scope = oldscope;
	return rv;
}

d1837 2
a1838 1
struct aml_value *aml_doif(struct acpi_context *ctx)
d1841 1
a1841 1
	uint8_t *end;
d1846 3
a1848 2
	i1  = aml_eparseint(ctx);
	dnprintf(10,"evalif: %lld\n", i1);
d1851 1
a1851 1
		rv = aml_eparselist(ctx, end);
d1858 1
a1858 1
			rv = aml_eparselist(ctx, end);
d1861 3
a1863 1
	ctx->pos = end;
d1868 2
a1869 1
struct aml_value *aml_dowhile(struct acpi_context *ctx)
d1871 1
a1871 1
	uint8_t *start, *end;
d1873 1
a1873 1
	int64_t i1, iw=0;
d1885 2
a1886 2
			i1 = aml_eparseint(ctx);
			dnprintf(10, "whiletest: %lld\n", i1);
d1892 1
a1892 1
			dnprintf(10,"break\n");
d1896 1
a1896 1
			dnprintf(10,"continue\n");
d1901 1
a1901 1
			rv = aml_eparseval(ctx);
d1903 3
a1905 1
		if (iw++ > 10) break;
d1910 4
a1913 1
struct aml_value *aml_domethod(struct acpi_context *ctx, struct aml_value *val)
d1918 1
d1920 1
a1920 4
	uint8_t *oldpos;

	oldarg = ctx->args;
	oldloc = ctx->locals;
d1923 1
a1923 1
		dnprintf(10, "aml_domethod: Invalid type\n");
d1927 2
a1928 2
	newarg = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *)*8);
	newloc = (struct aml_value **)acpi_os_allocmem(sizeof(struct aml_value *)*8);
d1931 1
d1933 1
a1933 6
		newarg[i1] = aml_eparseval(ctx);
	}
	dnprintf(10,"\nCall %s: (%lld args)\n", val->name, i2);
	for (i1 = 0; i1<i2; i1++) {
		dnprintf(10,"  arg%lld: ", i1);
		aml_showvalue(newarg[i1]);
d1937 3
d1941 1
d1945 12
a1956 1
	rv = aml_eparselist(ctx, val->v_method.end);
d1960 8
d1979 5
a1983 2
/* Resize buffer/string/package if out-of-bounds access */
void aml_resizeval(struct aml_value *pv, int newlen)
d1985 9
a1993 2
	struct aml_value **oldpkg;
	int i1;
d1995 6
a2000 6
	++newlen;
	dnprintf(10, "supersizeme\n");
	switch (pv->type) {
	case AML_OBJTYPE_PACKAGE:
		oldpkg = pv->v_package;
		pv->v_package = (struct aml_value **)acpi_os_allocmem(newlen * sizeof(struct aml_value *));
d2002 23
a2024 3
		/* Assign old package values */
		for (i1 = 0; i1 < pv->length; i1++) {
			pv->v_package[i1] = oldpkg[i1];
a2025 8

		/* Free old package */
		acpi_os_freemem(oldpkg);

		/* Set new length */
		pv->length = newlen-1;

		break;
d2027 3
d2032 6
a2037 13
struct aml_value *aml_doloadtable(struct acpi_context *ctx)
{
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	aml_eparseval(ctx);
	return NULL;
}

struct aml_value *aml_domatch(struct acpi_context *ctx)
d2042 6
a2047 6
	lhs = aml_eparseval(ctx);
	op1 = aml_parse_int(ctx,1);
	mv1 = aml_eparseint(ctx);
	op2 = aml_parse_int(ctx,1);
	mv2 = aml_eparseint(ctx);
	idx = aml_eparseint(ctx);
d2050 1
a2050 1
	rv = aml_allocint(-1, 0);
d2053 1
a2053 1
			mval = aml_val2int(ctx,lhs->v_package[idx]);
d2055 1
d2065 4
d2070 1
a2070 1
aml_eparseval(struct acpi_context *ctx)
d2074 1
a2074 1
	uint8_t *end, *start;
d2087 2
a2088 1
	dnprintf(10, "### %2d %.4x %s\n",
d2090 1
d2097 1
a2097 1
		rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, (char *)name, "nameref");
d2100 2
a2101 1
				rv = aml_domethod(ctx, rhs);
d2112 1
a2112 2
		rv = aml_allocint(0,1);
		aml_showvalue(rv);
d2115 1
a2115 2
		rv = aml_allocint(1,1);
		aml_showvalue(rv);
d2118 1
a2118 2
		rv = aml_allocint(-1LL, 1);
		aml_showvalue(rv);
d2121 1
a2121 2
		rv = aml_allocint(AML_REVISION, 1);
		aml_showvalue(rv);
d2124 1
a2124 2
		rv = aml_allocint(aml_parse_int(ctx, 1), 0);
		aml_showvalue(rv);
d2127 1
a2127 2
		rv = aml_allocint(aml_parse_int(ctx, 2), 0);
		aml_showvalue(rv);
d2130 1
a2130 2
		rv = aml_allocint(aml_parse_int(ctx, 4), 0);
		aml_showvalue(rv);
d2133 1
a2133 2
		rv = aml_allocint(aml_parse_int(ctx, 8), 0);
		aml_showvalue(rv);
d2136 1
a2136 5
		rv = aml_allocstr(ctx->pos);
		if (rv != NULL){
			ctx->pos += rv->length+1;
		}
		aml_showvalue(rv);
d2144 1
a2144 1
		rv = aml_ebufferfield(ctx, -1, 1, opc->opcode);
d2163 1
a2163 1
			aml_edebugobj = aml_allocvalue(AML_OBJTYPE_DEBUGOBJ, 0, NULL, "debug");
d2169 2
a2170 2
		i2  = aml_eparseint(ctx);     // requested length
		i1  = end - ctx->pos;	      // supplied length
d2172 1
a2172 1
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, i2, NULL, "buffer");
d2176 1
d2182 3
a2184 4
		/* Packages have fixed length, varpkg is variable */
		i2 = (opc->opcode == AMLOP_PACKAGE) ?
			aml_parse_int(ctx, 1) :
			aml_eparseint(ctx);
d2186 1
a2186 1
		rv = aml_allocvalue(AML_OBJTYPE_PACKAGE, i2, NULL, "package");
d2188 1
a2188 5
			rv->v_package[i1] = aml_eparseval(ctx);
		}
#if 0
		for (; i1 < rv->length; i1++) {
			rv->v_package[i1] = aml_allocint(0,0);
d2190 1
a2190 2
#endif
		dnprintf(10, "package: %lld of %lld parsed\n", i1, i2);
d2203 2
a2204 5
			dnprintf(10, "LazyLocal%lld\n", i1);
			ctx->locals[i1] = aml_allocint(0, 0);
		}
		else {
			ctx->locals[i1]->refcnt++;
d2218 2
a2219 2
			dnprintf(10, "LazyArg%lld\n", i1);
			ctx->args[i1] = aml_allocint(0, 0);
d2226 1
a2226 1
		lhs = aml_eparseval(ctx);
d2232 3
d2236 2
a2237 2
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
d2241 2
a2242 2
		i1  = aml_eparseint(ctx);
		i2  = aml_eparseint(ctx);
d2244 3
a2246 3
		lhs = aml_eparseval(ctx);
		rhs = aml_esetnodevalue(ctx, lhs, NULL, aml_evalmath(AMLOP_MOD, i1, i2));
		aml_freevalue(&lhs);
d2248 2
a2249 1
		lhs = aml_eparseval(ctx);
d2263 3
a2265 3
		i1  = aml_eparseint(ctx);
		i2  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
d2270 3
a2272 3
		i1 = aml_eparseint(ctx);
		i2 = aml_eparseint(ctx);
		rv = aml_allocint(aml_testlogical(opc->opcode, i1, i2),0);
d2275 2
a2276 2
		i1 = aml_eparseint(ctx);
		rv = aml_allocint(!i1, 1);
d2284 3
a2286 45
		lhs = aml_eparseval(ctx);
		rhs = aml_eparseval(ctx);
		i1  = aml_comparevalue(opc->opcode, lhs, rhs);
		rv  = aml_allocint(i1, 0);
		break;
	case AMLOP_TOINTEGER:
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, i1);
		break;
	case AMLOP_FROMBCD:
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_bcd2dec(i1));
		break;
	case AMLOP_TOBCD:
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_esetnodevalue(ctx, lhs, NULL, aml_dec2bcd(i1));
		break;
	case AMLOP_MID:
		rhs = aml_eparseval(ctx);
		i1  = aml_eparseint(ctx);  // index
		i2  = aml_eparseint(ctx);  // length
		if (rhs != NULL) {
			switch (rhs->type) {
			case AML_OBJTYPE_STRING:
				/* Validate index is within range */
				if (i1 >= lhs->length) 
					i1 = i2 = 0;
				if (i1+i2 >= lhs->length) 
					i2 = lhs->length - i1;
				rv = aml_allocvalue(AML_OBJTYPE_STRING, i2, lhs->v_string + i1, "mid");
				aml_esetnodevalue(ctx, lhs, rv, 0);
				break;
			case AML_OBJTYPE_BUFFER:
				if (i1 >= lhs->length) 
					i1 = i2 = 0;
				if (i1+i2 >= lhs->length) 
					i2 = lhs->length - i1;
				rv = aml_allocvalue(AML_OBJTYPE_BUFFER, i2, lhs->v_buffer + i1, "mid");
				aml_esetnodevalue(ctx, lhs, rv, 0);
				break;
			}
		}
d2289 3
a2291 3
		rhs = aml_eparseval(ctx);
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
d2293 1
a2293 1
		tmp = aml_val2buf(ctx, rhs);
d2302 1
a2302 1
		rv  = aml_allocvalue(AML_OBJTYPE_STRING, i2, tmp->v_buffer, "");
d2306 3
a2308 3
		rhs = aml_eparseval(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_val2buf(ctx, lhs);
a2311 8
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv = aml_allocvalue(AML_OBJTYPE_STRING, AML_INTSTRLEN, NULL, "todec");
		if (rhs != NULL) {
			snprintf(rhs->v_string, AML_INTSTRLEN, "%lld", i1);
			aml_esetnodevalue(ctx, lhs, rv, 0);
		}
		break;
d2313 6
a2318 5
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_allocvalue(AML_OBJTYPE_STRING, AML_INTSTRLEN, NULL, "todec");
		if (rhs != NULL) {
			snprintf(rhs->v_string, AML_INTSTRLEN, "0x%Lx", i1);
d2323 2
a2324 2
		i1 = aml_eparseint(ctx);
		dnprintf(10, "stall %lld usecs\n", i1);
d2327 2
a2328 2
		i1 = aml_eparseint(ctx);
		dnprintf(10, "sleep %lld msecs\n", i1);
d2332 3
a2334 5
		i1 = aml_parse_int(ctx, 1);
		rv = aml_allocvalue(AML_OBJTYPE_MUTEX, i1, (char *)name, "mutex");
		if (rv != NULL) {
			aml_addvname(ctx, name, opc->opcode, rv);
		}
d2337 3
a2339 2
		lhs = aml_eparseref(ctx);
		i1  = aml_parse_int(ctx, 2);
d2341 3
a2343 1
		rv = aml_allocint(0,0);
d2346 1
a2346 1
		lhs = aml_eparseref(ctx);
d2351 2
a2352 4
		rv = aml_allocvalue(AML_OBJTYPE_EVENT, 0, (char *)name, "event");
		if (rv != NULL) {
			aml_addvname(ctx, name, opc->opcode, rv);
		}
d2355 2
a2356 2
		lhs = aml_eparseref(ctx);
		dnprintf(10,"signal: %s\n", lhs->v_string);
d2359 3
a2361 3
		lhs = aml_eparseref(ctx);
		i1  = aml_eparseint(ctx);
		dnprintf(10, "wait: %s %Lx\n", lhs->v_string, i1);
d2364 2
a2365 2
		lhs = aml_eparseref(ctx);
		dnprintf(10, "reset: %s\n", lhs->v_string);
d2368 3
a2370 3
		lhs = aml_eparseval(ctx);
		i1  = aml_eparseint(ctx);
		dnprintf(10,"NOTIFY: %Lx %s\n", i1, lhs->name);
d2374 2
a2375 2
		rhs = aml_eparseval(ctx);
		lhs = aml_eparseval(ctx);
d2379 2
a2380 2
		rhs = aml_eparseval(ctx);
		lhs = aml_eparseval(ctx);
d2386 6
a2391 15
		rv = aml_allocvalue(AML_OBJTYPE_OPREGION, 0, (char *)name, "opregion");
		if (rv != NULL) {
			rv->v_opregion.iospace = aml_parse_int(ctx, 1);
			rv->v_opregion.iobase  = aml_eparseint(ctx);
			rv->v_opregion.iolen   = aml_eparseint(ctx);
#if 0
			rv->v_opregion.buf = acpi_os_allocmem(rv->v_opregion.iolen);
			memset(rv->v_opregion.buf, 0xFF, rv->v_opregion.iolen);
			acpi_gasio(ctx->sc, ACPI_IOREAD,
				   rv->v_opregion.iospace,
				   rv->v_opregion.iobase,
				   1,
				   rv->v_opregion.iolen,
				   rv->v_opregion.buf);
#endif
d2396 7
a2402 6
		name = aml_parse_name(ctx);
		rv = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, (void *)name, "alias");
		if (rv != NULL) {
			name = aml_parse_name(ctx);
			aml_addvname(ctx, name, opc->opcode, rv);
		}
d2406 2
a2407 4
		rv = aml_eparseval(ctx);
		if (rv != NULL) {
			aml_addvname(ctx, name, opc->opcode, rv);
		}
d2410 5
a2414 1
		rv = aml_eparseref(ctx);
d2417 3
d2421 1
a2421 1
		rv = aml_econcat(ctx);
d2429 1
a2429 1
		rv = aml_eparsescope(ctx, name, end, opc);
a2434 2
		rv   = aml_allocvalue(AML_OBJTYPE_DEVICE, 0, (char *)name, "device");

d2436 2
a2437 1
		lhs  = aml_eparsescope(ctx, name, end, opc);
d2443 4
a2446 6
		rv = aml_allocvalue(AML_OBJTYPE_POWERRSRC, 0, (char *)name, "power");
		if (rv != NULL) {
			rv->v_powerrsrc.pwr_level = aml_parse_int(ctx, 1);
			rv->v_powerrsrc.pwr_order = aml_parse_int(ctx, 2);

			lhs = aml_eparsescope(ctx, name, end, opc);
d2448 1
d2454 6
a2459 5
		rv = aml_allocvalue(AML_OBJTYPE_PROCESSOR, 0, (char *)name, "processor");
		if (rv != NULL) {
			rv->v_processor.proc_id = aml_parse_int(ctx, 1);
			rv->v_processor.proc_addr = aml_parse_int(ctx, 4);
			rv->v_processor.proc_len = aml_parse_int(ctx, 1);
d2461 1
a2461 2
			lhs = aml_eparsescope(ctx, name, end, opc);
		}
d2467 2
a2468 4
		rv = aml_allocvalue(AML_OBJTYPE_THERMZONE, 0, (char *)name, "tzone");
		if (rv != NULL) {
			lhs = aml_eparsescope(ctx, name, end, opc);
		}
d2471 2
a2472 2
		lhs = aml_eparseval(ctx);
		rv  = aml_allocint(lhs->type,1);
d2475 3
a2477 3
		lhs = aml_eparseval(ctx);
		if (lhs != NULL) {
			rv = aml_allocint(lhs->length, 1);
d2483 3
a2485 3
		i1   = aml_parse_int(ctx, 1);
		rv = aml_allocvalue(AML_OBJTYPE_METHOD, i1, (char *)name, "method");
		if (rv != NULL) {
d2496 3
a2498 3
		rhs = aml_eparseval(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_allocint(0, 1);
d2500 1
a2500 1
			tmp = aml_allocvalue(AML_OBJTYPE_OBJREF, -1, rhs, "condref");
d2504 1
a2504 1
		dnprintf(10,"condrefof: %lld\n", rv->v_integer);
d2507 8
a2514 4
		rhs = aml_eparseval(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_allocvalue(AML_OBJTYPE_OBJREF, -1, rhs, "refof");
		aml_esetnodevalue(ctx, lhs, rv, 0);
d2517 8
a2524 5
		rhs = aml_eparseval(ctx);
		i1  = aml_eparseint(ctx);
		lhs = aml_eparseval(ctx);
		rv  = aml_allocvalue(AML_OBJTYPE_OBJREF, i1, rhs, "index");
		aml_esetnodevalue(ctx, lhs, rv, 0);
d2527 1
a2527 1
		rv = aml_eparseref(ctx);
d2543 1
a2543 1
		dnprintf(10,"Unknown opcode: %.4x %s\n", opc->opcode, opc->mnem);
d2546 18
d2573 2
a2574 1
void aml_delchildren(struct acpi_context *ctx, struct aml_node *node)
d2582 4
d2593 2
a2594 1
struct aml_value *aml_eparsenode(struct acpi_context *ctx, struct aml_node *node)
d2617 1
a2617 1
		dnprintf(10, "Call function: %s\n", node->name);
d2620 1
a2620 1
		rv = aml_eparselist(ctx, node->value->v_method.end);
d2628 1
a2628 1
		dnprintf(10, "Unknown node value: %d\n", node->value->type);
d2633 3
a2635 2
int aml_eval_object(struct acpi_softc *sc, struct aml_node *node,
		    struct aml_value *ret, int argc, struct aml_value *argv)
d2642 1
d2649 1
a2649 1
	return -1;
a2798 2
	stacktop = &sc;
	
d2805 1
a2805 1
	rv  = aml_eparselist(ctx, aml_root.end);
d2811 1
a2811 1
	//aml_walktree(&aml_root);
@


1.18
log
@More evaluator changes
Removed old evaluator code
Fixed _HID value
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.17 2006/01/18 22:25:44 jordan Exp $ */
d30 3
a32 1
struct aml_optable
a38 8
struct acpi_stack
{
	struct aml_value   *locals;
	struct aml_value   *args;
	struct aml_value    result;
	struct acpi_stack  *next;
};

d41 7
a47 4
	struct acpi_softc *sc;
	struct acpi_stack *stack;

	u_int8_t   *pos;
a70 3
int aml_parse_fieldlist(struct acpi_context *, struct aml_node *);
int aml_parse_objlist(struct acpi_context *, struct aml_node *);
int aml_parse_args(struct acpi_context *, struct aml_node *, const char *);
d73 1
a73 3
const char *aml_parse_name(struct acpi_context *, const char *);
struct aml_node *aml_parse_object(struct acpi_context *, struct aml_node *);
struct aml_node *aml_preparse(struct acpi_context *, struct aml_node *, struct aml_optable *);
d76 1
a76 1
u_int16_t aml_getopcode(struct acpi_context *);
d86 6
a92 2
void aml_addchildnode(struct aml_node *, struct aml_node *);
struct aml_node *aml_create_node(struct acpi_context *, struct aml_node *, int opcode, const char *mnem);
a99 2
int  aml_eval_object(struct acpi_softc *, struct aml_node *, struct aml_value *, struct aml_value *);

d106 4
d128 5
a132 1
struct aml_node aml_root;
d137 6
a142 1
	return malloc(size, M_DEVBUF, M_WAITOK);
d148 1
a148 1
	free(ptr, M_DEVBUF);
d173 1
d178 7
a184 2
struct aml_node *_aml_searchname(struct aml_node *list, const char *name);
struct aml_node *_aml_findname(struct aml_node *root, const char *name);
d186 3
a188 14
struct aml_node *_aml_searchname(struct aml_node *list, const char *name)
{
	if (list->opcode == AMLOP_FIELD ||
	    list->opcode == AMLOP_INDEXFIELD ||
	    list->opcode == AMLOP_BANKFIELD) {
		dnprintf(50, "search field objects\n");
		list = list->child;
	}
	while (list != NULL) {
		if (list->name && !strncmp(list->name, name, AML_NAMESEG_LEN)) {
			return list;
		}
	}
	return NULL;
d191 2
a192 1
struct aml_node *_aml_findname(struct aml_node *root, const char *name)
d196 3
a198 14
	if (root == NULL) {
		root = &aml_root;
	}
	if (*name == AMLOP_ROOTCHAR) {
		name++;
		root = &aml_root;
	}
	while (*name == AMLOP_PARENTPREFIX) {
		name++;
		root = root->parent;
		if (root == NULL) {
			dnprintf(50, "_aml_find_node: Bad parent!!\n");
			return NULL;
		}
d200 6
d207 2
a208 16
	/* Ok... name is parsed.. now search all siblings of parent */
	for (node=NULL; *name && root && !node;) {
		if (*name == '.') name++;
		if ((node = _aml_searchname(root->child, name)) == NULL) {
			/* search parent */
			root = root->parent;
		}
		else if (name[AML_NAMESEG_LEN] == '\0') {
			/* found it */
			return node;
		}
		else {
			root = node;
			name += AML_NAMESEG_LEN;
		}
	}
d219 1
a219 1
aml_allocvalue(int type, int64_t ival, const void *bval, 
d223 2
a226 4
	if (rv == NULL)
		return NULL;

	memset(rv, 0, sizeof(struct aml_value));
a227 1
	rv->dynamic = 1;
d231 4
a237 3
	case AML_OBJTYPE_NAMEREF:
		rv->v_nameref.name = bval;
		break;
a243 1
			memset(rv->v_string, 0, ival+1);
a254 1
			memset(rv->v_buffer, 0, ival);
d264 7
a270 1
		memset(rv->v_package, 0, rv->length * sizeof(struct aml_value *));
d273 2
a274 9
		/* Allocate method stack */
		rv->v_method.locals = (struct aml_value *)acpi_os_allocmem(8 * sizeof(struct aml_value));
		rv->v_method.args   = (struct aml_value *)acpi_os_allocmem(ival * sizeof(struct aml_value));
		memset(rv->v_method.locals, 0, 8 * sizeof(struct aml_value));
		memset(rv->v_method.args, 0, ival * sizeof(struct aml_value));
		break;
	case AML_OBJTYPE_OBJREF:
		rv->v_objref.index = ival;
		rv->v_objref.ref = (struct aml_node *)bval;
d277 1
d280 14
d299 1
a299 1
aml_allocint(uint64_t ival)
d301 1
a301 1
	return aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL, "integer");
d307 1
a307 1
	return aml_allocvalue(AML_OBJTYPE_STRING, strlen(str), str, "string");
d311 1
a311 1
aml_freevalue(struct aml_value *v)
d313 1
a315 3
	/* XXX: fix this ref count */
	return (0);

d317 5
a321 1
	if (v == NULL || !v->dynamic)
d324 1
a324 1
	dnprintf(50, "freeing value : %x\n", v->type);
d340 1
a340 1
			aml_freevalue(v->v_package[idx]);
d350 1
d355 13
d376 2
d386 2
a387 5
		dnprintf(50, "buffer: %d {\n", value->length);
		for (idx=0; idx<value->length; idx++) {
			dnprintf(50, "%s0x%.2x", (idx ? "," : ""), value->v_buffer[idx]);
		}
		dnprintf(50, "}\n");
d398 3
d402 4
a405 4
#if 0 
		xxx
			dnprintf(50, "device: %s", val->v_device->name);
#endif
d413 6
d420 5
a424 2
		dnprintf(50, "field: %.4x %x,%x\n",
			 value->v_field.ftype,
d427 2
d431 2
a432 2
		dnprintf(50, "bufferfield: %.4x %x,%x\n", 
			 value->v_field.ftype,
d435 3
d440 1
a440 1
		dnprintf(50, "opregion: %s,0x%x,0x%x\n",
d446 1
a446 1
		printf("unknown: %d\n", value->type);
a473 1
	int idx;
d477 1
a477 1
		return aml_allocint(rhs->v_integer);
d479 4
a482 1
		return aml_allocstr(rhs->v_string);
d484 4
a487 1
		return aml_allocvalue(rhs->type, rhs->length, rhs->v_buffer, "");
d489 12
a500 3
		rv = aml_allocvalue(rhs->type, rhs->length, NULL, "");
		for (idx=0; idx<rv->length; idx++) {
			rv->v_package[idx] = aml_copyvalue(rhs->v_package[idx]);
d502 6
d510 1
a510 1
	return NULL;
a571 45
int
aml_parse_fieldlist(struct acpi_context *ctx, struct aml_node *parent)
{
	u_int16_t flag, type, attr;
	int bitpos, bitlen;
	const char *name;

	bitpos = 0;
	flag = parent->flag;

	/* Format of flag:
	 *   bits 00 - 03 : access mode
	 *   bits 04 - 04 : lock mode
	 *   bits 05 - 08 : update mode
	 *   bits 08 - 15 : attribute
	 */
	dnprintf(50, "-- parse_fieldlist\n");
	while (ctx->pos < parent->end) {
		bitlen = 0;
		switch (aml_parse_int(ctx, 1)) {
		case 0x00: /* reserved */
			bitlen = aml_parse_length(ctx);
			break;
		case 0x01: /* access field */
			type = aml_parse_int(ctx, 1);
			attr = aml_parse_int(ctx, 1);
			dnprintf(50, "  type=%.2x  attr=%.2x\n", type, attr);
			flag = AML_FIELD_SETATTR(flag, type, attr);
			break;
		default: /* named field */
			--ctx->pos;
			name = aml_parse_name(ctx, "field");
			bitlen = aml_parse_length(ctx);
			aml_create_fieldunit(ctx, parent, name, bitpos, bitlen, flag);
		}
		bitpos += bitlen;
	}
	if (ctx->pos != parent->end) {
		dnprintf(50, "parse_fieldlist: invalid end!\n");
		ctx->pos = parent->end;
		return (1);
	}
	return (0);
}

d574 1
a574 1
aml_parse_name(struct acpi_context *ctx, const char *lbl)
a624 2
	dnprintf(50, " acpi_name (%s): %s\n", lbl, name);

d785 1
a785 1
struct aml_optable aml_table[] = {
d787 13
a799 13
	{ AMLOP_ZERO,             "Zero",            "!"  },
	{ AMLOP_ONE,              "One",             "!"  },
	{ AMLOP_ONES,             "Ones",            "!"  },
	{ AMLOP_BYTEPREFIX,       "Byte",            "b"  },
	{ AMLOP_WORDPREFIX,       "Word",            "w"  },
	{ AMLOP_DWORDPREFIX,      "DWord",           "d"  },
	{ AMLOP_QWORDPREFIX,      "QWord",           "q"  },
	{ AMLOP_REVISION,         "Revision",        ""   },
	{ AMLOP_STRINGPREFIX,     "String",          "s"  },
	{ AMLOP_DEBUG,            "DebugOp",         "",  },
	{ AMLOP_BUFFER,           "Buffer",          "piB" },
	{ AMLOP_PACKAGE,          "Package",         "pbT" },
	{ AMLOP_VARPACKAGE,       "VarPackage",      "piT" },
d802 15
a816 15
	{ AMLOP_LOCAL0,           "Local0",          "",    },
	{ AMLOP_LOCAL1,           "Local1",          "",    },
	{ AMLOP_LOCAL2,           "Local2",          "",    },
	{ AMLOP_LOCAL3,           "Local3",          "",    },
	{ AMLOP_LOCAL4,           "Local4",          "",    },
	{ AMLOP_LOCAL5,           "Local5",          "",    },
	{ AMLOP_LOCAL6,           "Local6",          "",    },
	{ AMLOP_LOCAL7,           "Local7",          "",    },
	{ AMLOP_ARG0,             "Arg0",            "",    },
	{ AMLOP_ARG1,             "Arg1",            "",    },
	{ AMLOP_ARG2,             "Arg2",            "",    },
	{ AMLOP_ARG3,             "Arg3",            "",    },
	{ AMLOP_ARG4,             "Arg4",            "",    },
	{ AMLOP_ARG5,             "Arg5",            "",    },
	{ AMLOP_ARG6,             "Arg6",            "",    },
d819 9
a827 9
	{ AMLOP_IF,               "If",              "piT",  },
	{ AMLOP_ELSE,             "Else",            "pT",   },
	{ AMLOP_WHILE,            "While",           "piT",  },
	{ AMLOP_BREAK,            "Break",           "",     },
	{ AMLOP_CONTINUE,         "Continue",        "",     },
	{ AMLOP_RETURN,           "Return",          "t",     },
	{ AMLOP_FATAL,            "Fatal",           "bdi", },
	{ AMLOP_NOP,              "Nop",             "",    },
	{ AMLOP_BREAKPOINT,       "BreakPoint",      "",    },
d830 16
a845 16
	{ AMLOP_INCREMENT,        "Increment",       "t",     },
	{ AMLOP_DECREMENT,        "Decrement",       "t",     },
	{ AMLOP_ADD,              "Add",             "iit",   },
	{ AMLOP_SUBTRACT,         "Subtract",        "iit",   },
	{ AMLOP_MULTIPLY,         "Multiply",        "iit",   },
	{ AMLOP_DIVIDE,           "Divide",          "iitt",  },
	{ AMLOP_SHL,              "ShiftLeft",       "iit",   },
	{ AMLOP_SHR,              "ShiftRight",      "iit",   },
	{ AMLOP_AND,              "And",             "iit",   },
	{ AMLOP_NAND,             "Nand",            "iit",   },
	{ AMLOP_OR,               "Or",              "iit",   },
	{ AMLOP_NOR,              "Nor",             "iit",   },
	{ AMLOP_XOR,              "Xor",             "iit",   },
	{ AMLOP_NOT,              "Not",             "it",    },
	{ AMLOP_MOD,              "Mod",             "iit",   },
	{ AMLOP_FINDSETLEFTBIT,   "FindSetLeftBit",  "it",    },
d849 9
a857 9
	{ AMLOP_LAND,             "LAnd",            "ii",    },
	{ AMLOP_LOR,              "LOr",             "ii",    },
	{ AMLOP_LNOT,             "LNot",            "i",     },
	{ AMLOP_LNOTEQUAL,        "LNotEqual",       "tt",    },
	{ AMLOP_LLESSEQUAL,       "LLessEqual",      "tt",    },
	{ AMLOP_LGREATEREQUAL,    "LGreaterEqual",   "tt",    },
	{ AMLOP_LEQUAL,           "LEqual",          "tt",    },
	{ AMLOP_LGREATER,         "LGreater",        "tt",    },
	{ AMLOP_LLESS,            "LLess",           "tt",    },
d860 13
a872 13
	{ AMLOP_NAMECHAR,         "NameRef",         "n" },
	{ AMLOP_ALIAS,            "Alias",           "nN",  },
	{ AMLOP_NAME,             "Name",            "Nt",  },
	{ AMLOP_EVENT,            "Event",           "N",   },
	{ AMLOP_MUTEX,            "Mutex",           "Nb",  },
	{ AMLOP_DATAREGION,       "DataRegion",      "Nttt" },
	{ AMLOP_OPREGION,         "OpRegion",        "Nbii" },
	{ AMLOP_SCOPE,            "Scope",           "pNT" },
	{ AMLOP_DEVICE,           "Device",          "pNT" },
	{ AMLOP_POWERRSRC,        "Power Resource",  "pNbwT" },
	{ AMLOP_THERMALZONE,      "ThermalZone",     "pNT" },
	{ AMLOP_PROCESSOR,        "Processor",       "pNbdbT", },
	{ AMLOP_METHOD,           "Method",          "pNfM",  },
d875 4
a878 4
	{ AMLOP_FIELD,            "Field",           "pnfF" },
	{ AMLOP_INDEXFIELD,       "IndexField",      "pntfF" },
	{ AMLOP_BANKFIELD,        "BankField",       "pnnifF" },
	{ AMLOP_CREATEFIELD,      "CreateField",     "tiiN",   },
d883 1
a883 1
	{ AMLOP_CREATEBITFIELD,   "CreateBitField",  "tiN",    },
d886 8
a893 8
	{ AMLOP_TOINTEGER,        "ToInteger",       "tt",     },
	{ AMLOP_TOBUFFER,         "ToBuffer",        "tt",     },
	{ AMLOP_TODECSTRING,      "ToDecString",     "it",     },
	{ AMLOP_TOHEXSTRING,      "ToHexString",     "it",     }, 
	{ AMLOP_TOSTRING,         "ToString",        "t",      },
	{ AMLOP_FROMBCD,          "FromBCD",         "it",     },
	{ AMLOP_TOBCD,            "ToBCD",           "it",     },
	{ AMLOP_MID,              "Mid",             "tiit",   },
d896 5
a900 5
	{ AMLOP_ACQUIRE,          "Acquire",         "tw",     },
	{ AMLOP_RELEASE,          "Release",         "t",      },
	{ AMLOP_SIGNAL,           "Signal",          "t",      },
	{ AMLOP_WAIT,             "Wait",            "ti",     },
	{ AMLOP_RESET,            "Reset",           "t",      },
d902 18
a919 18
	{ AMLOP_INDEX,            "Index",           "tit",    },
	{ AMLOP_DEREFOF,          "DerefOf",         "t",      },
	{ AMLOP_REFOF,            "RefOf",           "t",      },
	{ AMLOP_CONDREFOF,        "CondRef",         "tt",     },

	{ AMLOP_LOADTABLE,        "LoadTable",       "tttttt" },
	{ AMLOP_STALL,            "Stall",           "i",      },
	{ AMLOP_SLEEP,            "Sleep",           "i",      },
	{ AMLOP_LOAD,             "Load",            "nt" },
	{ AMLOP_UNLOAD,           "Unload",          "t" }, 
	{ AMLOP_STORE,            "Store",           "tt",     },
	{ AMLOP_CONCAT,           "Concat",          "ttt" },
	{ AMLOP_CONCATRES,        "ConcatRes",       "ttt" },
	{ AMLOP_NOTIFY,           "Notify",          "ti" },
	{ AMLOP_SIZEOF,           "Sizeof",          "t",      },
	{ AMLOP_MATCH,            "Match",           "tbibii", },
	{ AMLOP_OBJECTTYPE,       "ObjectType",      "t", },
	{ AMLOP_COPYOBJECT,       "CopyObject",      "tt" },
d928 1
a928 2
u_int16_t
aml_getopcode(struct acpi_context *ctx)
d930 12
a941 2
	u_int16_t twocode;
	u_int16_t opcode;
d943 8
a950 3
	/* Check for encoded name */
	if (aml_isnamedop(*ctx->pos)) {
		return AMLOP_NAMECHAR;
d952 3
a954 11

	opcode  = aml_parse_int(ctx, 1);
	twocode = (opcode << 8L) + *ctx->pos;

	/* Check multi-byte opcodes */
	if (twocode == AMLOP_LNOTEQUAL ||
	    twocode == AMLOP_LLESSEQUAL ||
	    twocode == AMLOP_LGREATEREQUAL ||
	    opcode == AMLOP_EXTPREFIX) {
		ctx->pos++;
		return twocode;
d956 1
a956 2

	return opcode;
a986 33
void
aml_addchildnode(struct aml_node *parent, struct aml_node *child)
{
	struct aml_node *psib;

	child->parent = parent;
	child->sibling = NULL;
	for (psib = parent->child; psib; psib = psib->sibling) {
		if (psib->sibling == NULL) {
			psib->sibling = child;
			return;
		}
	}
	parent->child = child;
}

struct aml_node *
aml_create_node(struct acpi_context *ctx, struct aml_node *parent, int opcode, const char *mnem)
{
	struct aml_node *node;

	node = acpi_os_allocmem(sizeof(struct aml_node));
	memset(node, 0, sizeof(struct aml_node));

	node->depth  = parent->depth+1;
	node->start  = ctx->pos;
	node->opcode = opcode;
	node->mnem   = mnem;
	aml_addchildnode(parent, node);

	return node;
}

d1028 1
a1028 1
		return aml_eval_object(sc, root, result, env);
d1077 64
a1140 2
void
aml_create_fieldunit(struct acpi_context *ctx, struct aml_node *parent, const char *name, int bitpos, int bitlen, int flags)
d1142 1
a1142 1
	struct aml_node *pfield;
d1144 20
a1163 1
	dnprintf(50, "create_fieldunit: name=%s bitpos=%.8x bitlen=%.8x\n", name, bitpos, bitlen);
d1165 2
a1166 3
	pfield = aml_create_node(ctx, parent, AMLOP_FIELDUNIT, "fieldunit");
	if (pfield == NULL)
		return;
d1168 1
a1168 1
	pfield->name = name;
d1170 9
a1178 25
	/* Setup Field Unit object: point to OpRegion NameRef in parent field */
	pfield->value = aml_allocvalue(AML_OBJTYPE_FIELDUNIT, 0, NULL, "FieldUnit");
	if (pfield->value != NULL) {
		pfield->value->length = aml_bytelen(bitlen);
		pfield->value->v_field.flags  = flags;
		pfield->value->v_field.ftype  = parent->opcode;
		pfield->value->v_field.bitpos = bitpos;
		pfield->value->v_field.bitlen = bitlen;
		pfield->value->v_field.ref    = childOf(parent, 0);

		switch (AML_FIELD_ACCESS(flags)) {
		case AML_FIELD_ANYACC:
		case AML_FIELD_BYTEACC:
			pfield->value->v_field.acc_size = 1;
			break;
		case AML_FIELD_WORDACC:
			pfield->value->v_field.acc_size = 2;
			break;
		case AML_FIELD_DWORDACC:
			pfield->value->v_field.acc_size = 4;
			break;
		default:
			dnprintf(50, "aml_createfieldunit: invalid field access size: %x\n", 
				 AML_FIELD_ACCESS(flags));
			break;
d1180 1
d1182 6
d1190 1
a1190 2
void
aml_create_bufferunit(struct acpi_context *ctx, struct aml_node *node, int bitlen, int size)
d1192 1
a1192 19
	/* ASSERT: node->value is NULL */
	node->value = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL, "bufferunit");
	if (node->value != NULL) {
		if (bitlen == -1) {
			/* AMLOP_CREATEFIELD: decode bitlength */
			bitlen = _aml_evalint(ctx, childOf(node, 2));
		}
		node->value->length = aml_bytelen(bitlen);
		node->value->v_field.flags = 0;
		node->value->v_field.ftype  = node->opcode;
		node->value->v_field.bitpos = _aml_evalint(ctx, childOf(node, 1)) * size;
		node->value->v_field.bitlen = bitlen;
		node->value->v_field.ref = childOf(node, 0);  
		node->value->v_field.acc_size = 1;

		dnprintf(50, "create_bufferunit: name=%s pos=%.8x len=%.8x\n", 
			 node->name, node->value->v_field.bitpos,
			 node->value->v_field.bitlen);
	}
d1195 1
a1195 3
/* Copy to/from a buffer object */
struct aml_value *
aml_bufferio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs)
d1197 3
a1199 1
	struct aml_value *pbuf, *rv;
d1201 1
a1201 4
	/* ASSERT: pfield is AML_OBJTYPE_BUFFERFIELD */
	pbuf = aml_evalnode(ctx, pfield->v_field.ref);
	if (pbuf->type != AML_OBJTYPE_BUFFERFIELD) {
		dnprintf(50, "Invalid bufferio!\n");
d1204 35
a1238 7
	if (rhs == NULL) {
		/* Return buffer object */
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, pfield->length, NULL, "bufferio");
		if (rv != NULL) {
			aml_bufcpy(rv->v_buffer, 0, pbuf->v_buffer, 
				   pfield->v_field.bitpos, 
				   pfield->v_field.bitlen);
d1240 1
a1240 2
		aml_freevalue(pbuf);
		return rv;
d1242 6
d1249 4
a1252 11
	switch (rhs->type) {
	case AML_OBJTYPE_INTEGER:
		aml_bufcpy(pbuf->v_buffer, pfield->v_field.bitpos, (u_int8_t *)&rhs->v_integer, 0, 
			   pfield->v_field.bitlen);
		break;
	case AML_OBJTYPE_BUFFER:
		aml_bufcpy(pbuf->v_buffer, pfield->v_field.bitpos, rhs->v_buffer, 0, 
			   pfield->v_field.bitlen);
		break;
	default:
		dnprintf(50, "invalid type to bufferio\n");
d1254 1
a1254 1
	return NULL;
a1256 1
/* Copy to/from a field object */
d1258 2
a1259 1
aml_fieldio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs)
d1261 7
a1267 1
	struct aml_value *pbuf, *rv;
d1269 2
a1270 1
	switch (pfield->v_field.ftype) {
d1272 7
a1278 9
		/* Write bit offset to INDEX register 
		   INDEX is childOf(pfield->v_field.ref, 0)
		   DATA  is childOf(pfield->v_field.ref, 1)
		*/
		_aml_setnodevalue(ctx, childOf(pfield->v_field.ref, 0), 0, pfield->v_field.bitpos);
		if (rhs == NULL) {
			return aml_evalnode(ctx, childOf(pfield->v_field.ref, 1));
		}
		return _aml_setnodevalue(ctx, childOf(pfield->v_field.ref, 1), rhs, 0);
d1281 4
a1284 1
		return NULL;
d1287 58
d1346 18
d1365 5
a1369 39
	}
	/* ASSERT: pfield is AML_OBJTYPE_FIELDUNIT */
	pbuf = aml_evalnode(ctx, pfield->v_field.ref);
	if (pbuf->type != AML_OBJTYPE_OPREGION) {
		dnprintf(50, "Invalid fieldio!\n");
		return NULL;
	}
	
	/* Allocate large enough buffer to hold size bytes */
	rv = aml_allocvalue(AML_OBJTYPE_BUFFER, pfield->length, NULL, "bufferio");
	if (rhs == NULL) {
		/* Return buffer object */
		if (rv != NULL) {
			/* Copy data from field object */
			acpi_gasio(ctx->sc, ACPI_IOREAD, 
				   pbuf->v_opregion.iospace,
				   pbuf->v_opregion.iobase + aml_bytepos(pfield->v_field.bitpos),
				   pfield->v_field.acc_size, rv->length, 
				   rv->v_buffer);
		}
		aml_freevalue(pbuf);
		return rv;
	}
	
	/* Check how we should write nonaligned bits */
	switch (AML_FIELD_UPDATE(pfield->v_field.flags)) {
	case AML_FIELD_PRESERVE:
		/* XXX: don't need to read old bits if new bits == length */
		acpi_gasio(ctx->sc, ACPI_IOREAD,
			   pbuf->v_opregion.iospace,
			   pbuf->v_opregion.iobase + aml_bytepos(pfield->v_field.bitpos),
			   pfield->v_field.acc_size, rv->length,
			   rv->v_buffer);
		break;
	case AML_FIELD_WRITEASONES:
		memset(rv->v_buffer, 0xFF, rv->length);
		break;
	case AML_FIELD_WRITEASZEROES:
		memset(rv->v_buffer, 0x00, rv->length);
d1372 1
a1372 1
	return pbuf;
d1376 1
a1376 1
_aml_setnodevalue(struct acpi_context *ctx, struct aml_node *node, struct aml_value *rhs, uint64_t ival)
d1378 16
a1393 2
	if (node == NULL) {
		dnprintf(50, "aml_setnodevalue: invalid node!\n");
d1395 11
d1407 11
d1419 34
a1452 3
	/* Integer value passed in */
	if (rhs == NULL)
		rhs = aml_allocint(ival);
d1454 32
a1485 3
	dnprintf(50, "aml_setnodevalue: ");
	aml_shownode(node);
	aml_showvalue(rhs);
d1487 1
a1487 1
	return rhs;
d1490 8
d1499 1
a1499 1
aml_getnodevalue(struct acpi_context *ctx, struct aml_node *node)
d1501 39
a1539 1
	u_int64_t i1, i2;
d1541 13
a1553 3
	if (node->value != NULL) {
		node->value->refcnt++;
		return node->value;
d1555 17
d1573 7
a1579 12
	switch (node->opcode) {
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		i1 = node->opcode - AMLOP_LOCAL0;
		if (ctx->stack) {
			node->value = &ctx->stack->locals[i1];
d1581 24
d1606 5
a1610 11

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		i1 = node->opcode - AMLOP_ARG0;
		if (ctx->stack) {
			node->value = &ctx->stack->args[i1];
d1612 1
d1614 1
d1616 6
a1621 2
	case AMLOP_CREATEFIELD:
		aml_create_bufferunit(ctx, node, -1, 1);
d1623 8
a1630 2
	case AMLOP_CREATEBITFIELD:
		aml_create_bufferunit(ctx, node, 1, 1);
d1632 4
a1635 2
	case AMLOP_CREATEBYTEFIELD:
		aml_create_bufferunit(ctx, node, 8, 8);
d1637 3
a1639 2
	case AMLOP_CREATEWORDFIELD:
		aml_create_bufferunit(ctx, node, 16, 8);
d1641 2
a1642 2
	case AMLOP_CREATEDWORDFIELD:
		aml_create_bufferunit(ctx, node, 32, 8);
d1644 2
a1645 2
	case AMLOP_CREATEQWORDFIELD:
		aml_create_bufferunit(ctx, node, 64, 8);
d1647 3
a1649 3
		
	case AMLOP_DEBUG:
		node->value = aml_allocvalue(AML_OBJTYPE_DEBUGOBJ, 0, NULL, "debugobj");
d1651 6
d1658 32
a1689 9
	case AMLOP_BUFFER:
		/* Requested length of buffer can be greater than supplied bytes */
		i1 = _aml_evalint(ctx, childOf(node, 0));
		i2 = node->end - node->start;
		
		dnprintf(50, "allocate buffer: %d/%d\n", i2, i1);
		node->value = aml_allocvalue(AML_OBJTYPE_BUFFER, i1, NULL, "buffer");
		if (node->value && i2 > 0) {
			memcpy(node->value->v_buffer, node->start, i2);
d1692 7
a1698 8

	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "allocate package: %d\n", i1);
		node->value = aml_allocvalue(AML_OBJTYPE_PACKAGE, i1, NULL, "package");
		for (i2=0; node->value && i2 < i1; i2++) {
			node->value->v_package[i2] = aml_evalnode(ctx, childOf(node, 1+i2));
d1701 3
d1705 36
a1740 10
	case AMLOP_OPREGION:
		node->value = aml_allocvalue(AML_OBJTYPE_OPREGION, 0, NULL, "opregion");
		if (node->value != NULL) {
			node->value->v_opregion.iospace = _aml_evalint(ctx, childOf(node, 0));
			node->value->v_opregion.iobase = _aml_evalint(ctx, childOf(node, 1));
			node->value->v_opregion.iolen = _aml_evalint(ctx, childOf(node, 2));
			dnprintf(50, "allocate opregion; %x %llx %x\n",
				 node->value->v_opregion.iospace,
				 node->value->v_opregion.iobase,
				 node->value->v_opregion.iolen);
d1742 14
a1755 1
		break;
d1757 24
a1780 10
	case AMLOP_PROCESSOR:
		node->value = aml_allocvalue(AML_OBJTYPE_PROCESSOR, 0, NULL, "processor");
		if (node->value != NULL) {
			node->value->v_processor.proc_id = _aml_evalint(ctx, childOf(node, 0));
			node->value->v_processor.proc_addr = _aml_evalint(ctx, childOf(node, 1));
			node->value->v_processor.proc_len = _aml_evalint(ctx, childOf(node, 2));
			dnprintf(50, "allocate processor; %x %x %x\n",
				 node->value->v_processor.proc_id,
				 node->value->v_processor.proc_addr,
				 node->value->v_processor.proc_len);
d1782 12
a1793 1
		break;
d1795 2
a1796 3
	case AMLOP_THERMALZONE:
		node->value = aml_allocvalue(AML_OBJTYPE_THERMZONE, 0, NULL, "thermzone");
		break;
d1798 3
a1800 3
	case AMLOP_EVENT:
		node->value = aml_allocvalue(AML_OBJTYPE_EVENT, 0, NULL, "event");
		break;
d1802 3
a1804 3
	case AMLOP_DEVICE:
		node->value = aml_allocvalue(AML_OBJTYPE_DEVICE, 0, NULL, "device");
		break;
d1806 9
a1814 4
	case AMLOP_MUTEX:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		node->value = aml_allocvalue(AML_OBJTYPE_MUTEX, i1, NULL, "mutex");
		break;
d1816 9
a1824 7
	case AMLOP_POWERRSRC:
		node->value = aml_allocvalue(AML_OBJTYPE_POWERRSRC, 0, NULL, "powerrsrc");
		if (node->value != NULL) {
			node->value->v_powerrsrc.pwr_level = _aml_evalint(ctx, childOf(node, 0));
			node->value->v_powerrsrc.pwr_order = _aml_evalint(ctx, childOf(node, 1));
		}
		break;
d1826 5
a1830 2
	default:
		return NULL;
d1832 2
a1833 3
	if (node->value)
		node->value->refcnt++;
	return node->value;
d1836 2
a1837 5
/*
 * Evaluate integer object
 */
int64_t
_aml_evalint(struct acpi_context *ctx, struct aml_node *node)
d1839 2
a1840 2
	struct aml_value *rhs;
	int64_t rval = 0;
d1842 10
a1851 19
	rhs = aml_evalnode(ctx, node);
	if (rhs != NULL) {
		switch (rhs->type) {
		case AML_OBJTYPE_INTEGER:
			rval = rhs->v_integer;
			break;
		case AML_OBJTYPE_STRING:
			/* Convert hex/decimal string to integer */
			if (!strncmp(rhs->v_string, "0x", 2)) 
				rval = aml_str2int(rhs->v_string+2, rhs->length, 16);
			else
				rval = aml_str2int(rhs->v_string, rhs->length, 10);
			break;
		case AML_OBJTYPE_BUFFER:
			rval = *rhs->v_buffer;
			break;
		default:
			dnprintf(50, "aml_evalint: invalid type: %x\n", rhs->type);
			break;
d1853 8
a1860 1
		aml_freevalue(rhs);
a1861 1
	return rval;
d1864 1
a1864 2
struct aml_value *
_aml_evalref(struct acpi_context *ctx, struct aml_node *node)
d1866 8
a1873 5
	if (node->value->v_nameref.ref == NULL) {
		dnprintf(50,"deref: %s\n", node->value->v_nameref.name);
		node->value->v_nameref.ref = aml_find_name(ctx->sc, NULL, node->value->v_nameref.name);
	} 
	return aml_evalnode(ctx, node->value->v_nameref.ref);
d1876 1
a1876 4
struct aml_value *aml_deref(struct acpi_context *ctx, struct aml_value *rv);

struct aml_value *
aml_deref(struct acpi_context *ctx, struct aml_value *rv)
d1878 2
a1879 1
	struct aml_value *lhs = NULL;
d1881 16
a1896 12
	if (rv != NULL) {
		switch (rv->type) {
		case AML_OBJTYPE_BUFFERFIELD:
			lhs = rv;
			rv = aml_bufferio(ctx, rv, NULL);
			break;
		case AML_OBJTYPE_FIELDUNIT:
			lhs = rv;
			rv = aml_fieldio(ctx, rv, NULL);
			break;
		case AML_OBJTYPE_OBJREF:
			break;
d1899 1
a1899 1
	aml_freevalue(lhs);
a1902 1

d1904 1
a1904 1
aml_evalnode(struct acpi_context *ctx, struct aml_node *node)
d1906 5
a1910 3
	struct aml_value *rv, *lhs, *rhs;
	struct aml_node  *cflow;
	int64_t i1, i2, i3, i4, i5, i6;
d1912 1
a1912 17
	if (node == NULL) {
		dnprintf(50, "aml_evalnode: invalid node\n");
		return NULL;
	}

#ifdef ACPI_DEBUG
	dnprintf(50, " %d ", node->depth);
	for(i1=0; i1<node->depth; i1++) {
		dnprintf(50, "..");
	}
	printf("evalnode: addr:%.8x %.4x %s\n", 
	       aml_ipaddr(node->start),
	       node->opcode, 
	       node->mnem);
#endif

	/* Initialize helper variables */
d1914 2
a1915 2
	rhs = NULL;
	cflow = NULL;
d1917 16
a1932 23
	/* Check if node already contains value */
	if ((rv = aml_getnodevalue(ctx, node)) != NULL) {
		/* Dereference object if necessary */
		return aml_deref(ctx, rv);
	}

	switch (node->opcode) {
	case AMLOP_NOP:
	case AMLOP_ELSE:
	case AMLOP_BREAK:
	case AMLOP_BREAKPOINT:
	case AMLOP_CONTINUE:
		break;

	case AMLOP_WHILE:
		for (;;) {
			if (cflow == NULL) {
				/* Test while condition */
				cflow = childOf(node, 1);
				i1 = _aml_evalint(ctx, childOf(node, 0));
				dnprintf(50, "aml_while: %d\n", i1);
				if (i1 == 0)
					break;
a1933 5
			else if (cflow->opcode == AMLOP_BREAK)
				break;
			else if (cflow->opcode == AMLOP_CONTINUE)
				/* Reset cflow to NULL; restart block */
				cflow = NULL;
d1935 2
a1936 4
				/* Execute next node in block */
				aml_freevalue(lhs);
				lhs = aml_evalnode(ctx, cflow);
				cflow = cflow->sibling;
d1940 38
a1977 16

	case AMLOP_IF:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "aml_if: %d\n", i1);
		if (i1 != 0) {
			/* Test true, select 'If' block */
			cflow = childOf(node, 1);
		}
		else if (node->sibling && node->sibling->opcode == AMLOP_ELSE) {
			/* Test false, select 'Else' block */
			cflow = childOf(node->sibling, 0);
		}
		while (cflow) {
			/* Execute all instructions in scope block */
			rv = aml_evalnode(ctx, cflow);
			cflow = cflow->sibling;
d1979 12
d1992 15
a2006 4

	case AMLOP_METHOD:
		if (node->child == NULL) {
			/* Parse method object */
d2008 10
a2017 4
		dnprintf(50, "Evaluating method: %s\n", node->name);
		for (cflow = node->child; cflow; cflow = cflow->sibling) {
			aml_freevalue(rv);
			rv = aml_evalnode(ctx, cflow);
d2020 3
d2024 34
a2057 3
	case AMLOP_NAMECHAR:
		/* Return dereferenced object */
		rv = _aml_evalref(ctx, node);
d2059 14
a2072 6

	case AMLOP_NAME:
	case AMLOP_ALIAS:
	case AMLOP_RETURN:
		/* Return child value */
		rv = aml_evalnode(ctx, childOf(node, 0));
d2077 3
a2079 3
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 0), NULL, 
				       aml_evalmath(node->opcode, i1, 1));
a2080 2
		
	case AMLOP_NOT:
d2083 4
a2086 3
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, 
				       aml_evalmath(node->opcode, i1, 0));
d2088 7
d2096 2
a2097 8
	case AMLOP_DIVIDE:
		/* Divide: Return quotient and remainder */
		i1 = _aml_evalint(ctx, childOf(node, 0));
		i2 = _aml_evalint(ctx, childOf(node, 1));
		_aml_setnodevalue(ctx, childOf(node, 2), NULL, 
				  aml_evalmath(AMLOP_MOD, i1, i2));
		rv = _aml_setnodevalue(ctx, childOf(node, 3), NULL,
				       aml_evalmath(AMLOP_DIVIDE, i1, i2));
a2098 1

d2110 10
a2119 4
		i1 = _aml_evalint(ctx, childOf(node, 0));
		i2 = _aml_evalint(ctx, childOf(node, 1));
		rv = _aml_setnodevalue(ctx, childOf(node, 2), NULL, 
				       aml_evalmath(node->opcode, i1, i2));
a2120 1

d2122 2
a2123 2
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = aml_allocint(!i1);
d2125 2
a2126 3

	case AMLOP_LAND:
	case AMLOP_LOR:
a2128 1
	case AMLOP_LLESSEQUAL:
d2131 68
a2198 6
	case AMLOP_LLESS:
		lhs = aml_evalnode(ctx, childOf(node, 0));
		rhs = aml_evalnode(ctx, childOf(node, 1));

		i1 = aml_comparevalue(node->opcode, lhs, rhs);
		rv = aml_allocint(i1);
a2199 1

d2201 3
a2203 2
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rhs = aml_allocvalue(AML_OBJTYPE_STRING, AML_INTSTRLEN, NULL, "");
d2205 2
a2206 2
			snprintf(rhs->v_string, AML_INTSTRLEN, "%d", i1);
			rv = _aml_setnodevalue(ctx, childOf(node, 1), rhs, 0);
a2208 1

d2210 3
a2212 2
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rhs = aml_allocvalue(AML_OBJTYPE_STRING, AML_INTSTRLEN, NULL, "");
d2214 2
a2215 2
			snprintf(rhs->v_string, AML_INTSTRLEN, "%x", i1);
			rv = _aml_setnodevalue(ctx, childOf(node, 1), rhs, 0);
d2218 15
a2232 4

	case AMLOP_TOINTEGER:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, i1);
d2234 5
a2238 4

	case AMLOP_FROMBCD:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, aml_bcd2dec(i1));
d2240 3
a2242 4

	case AMLOP_TOBCD:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, aml_dec2bcd(i1));
d2244 5
a2248 29

	case AMLOP_MATCH:
		/* Perform match operation  */
		lhs = aml_evalnode(ctx, childOf(node, 0));  /* package */

		/* Allocate default return value */
		rv = aml_allocint(-1);
		if (lhs->type == AML_OBJTYPE_PACKAGE && rv != NULL) {
			i1 = _aml_evalint(ctx, childOf(node, 1));    /* op1 */
			i2 = _aml_evalint(ctx, childOf(node, 2));    /* match1 */
			i3 = _aml_evalint(ctx, childOf(node, 3));    /* op2 */
			i4 = _aml_evalint(ctx, childOf(node, 4));    /* match2 */
			i5 = _aml_evalint(ctx, childOf(node, 5));    /* index */

			while (i5 < lhs->length) {
				if (lhs->v_package[i5]->type == AML_OBJTYPE_INTEGER) {
					i6 = lhs->v_package[i5]->v_integer;
				}
				else {
					dnprintf(50, "aml_match: invalid index: %d:%x\n",
						 i5, lhs->v_package[i5]->type);
					break;
				}
				if (aml_match(i6, i1, i2) && aml_match(i6, i3, i4)) {
					rv->v_integer = i5;
					break;
				}
				i5++;
			}
d2251 24
a2274 1

d2276 46
a2321 4
		/* Return copy of an object */
		lhs = aml_evalnode(ctx, childOf(node, 0));
		rhs = aml_copyvalue(lhs);
		rv = _aml_setnodevalue(ctx, childOf(node, 1), rhs, 0);
d2324 6
a2329 4
	case AMLOP_STORE:
		/* Store value into another */
		rhs = aml_evalnode(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), rhs, 0);
d2331 3
d2335 4
a2338 4
	case AMLOP_OBJECTTYPE:
		/* Return object type */
		lhs = aml_evalnode(ctx, childOf(node, 0));
		rv = aml_allocint(lhs->type);
d2340 3
d2344 4
a2347 3
	case AMLOP_SIZEOF:
		/* Return sizeof object (string/buffer/package) */
		lhs = aml_evalnode(ctx, childOf(node, 0));
d2349 1
a2349 10
		switch (lhs->type) {
		case AML_OBJTYPE_STRING:
		case AML_OBJTYPE_BUFFER:
		case AML_OBJTYPE_PACKAGE:
			i1 = lhs->length;
			break;
		default:
			i1 = 0;
			dnprintf(50,"aml_sizeof: incorrect type: %x\n", lhs->type);
			break;
a2350 1
		rv = aml_allocint(i1);
d2352 3
d2356 5
a2360 3
	case AMLOP_REFOF:
		rv = aml_allocvalue(AML_OBJTYPE_OBJREF, -1, childOf(node, 0), "refof");
		break;
d2362 1
a2362 8
	case AMLOP_CONDREFOF:
		rv  = aml_allocint(AML_FALSE);
		lhs = aml_evalnode(ctx, childOf(node, 0));
		if (lhs != NULL) {
			/* Conditional reference */
			rv->v_integer = AML_TRUE;
			rhs = aml_allocvalue(AML_OBJTYPE_OBJREF, -1, childOf(node, 0), "condref");
			_aml_setnodevalue(ctx, childOf(node, 1), rhs, 0);
d2365 3
d2369 3
a2371 9
	case AMLOP_DEREFOF:
		lhs = aml_evalnode(ctx, childOf(node, 0));
		if (lhs->type == AML_OBJTYPE_OBJREF) {
			rv = aml_evalnode(ctx, lhs->v_objref.ref);
		}
		else if (lhs->type == AML_OBJTYPE_STRING) {
			/* XXX: fix me
			   rv = aml_evalname(ctx, node, lhs->v_string);
			*/
d2374 9
a2382 5

	case AMLOP_INDEX:
		i1 = _aml_evalint(ctx, childOf(node, 1));
		rv = aml_allocvalue(AML_OBJTYPE_OBJREF, i1, childOf(node, 0), "index");

d2384 10
d2395 2
a2396 31
	case AMLOP_MID:
		/* Return substring (actual contents) */
		lhs = aml_evalnode(ctx, childOf(node, 0));
		i1 = _aml_evalint(ctx, childOf(node, 1));  /* length */
		i2 = _aml_evalint(ctx, childOf(node, 2));  /* index */

		/* check bounds against source object */
		if (i1 >= lhs->length)
			i1 = i2 = 0;
		if (i1+i2 >= lhs->length)
			i2 = lhs->length - i1;
		switch (lhs->type) {
		case AML_OBJTYPE_STRING:
			rhs = aml_allocvalue(AML_OBJTYPE_STRING, 0, NULL, "");
			if (rhs != NULL) {
				rhs->length = i1;
				rhs->v_string = lhs->v_string + i2;
				rv = _aml_setnodevalue(ctx, childOf(node, 3), rhs, 0);
			}
			break;
		case AML_OBJTYPE_BUFFER:
			rhs = aml_allocvalue(AML_OBJTYPE_BUFFER, 0, NULL, "");
			if (rhs != NULL) {
				rhs->length = i1;
				rhs->v_buffer = lhs->v_buffer + i2;
				rv = _aml_setnodevalue(ctx, childOf(node, 3), rhs, 0);
			}
			break;
		default:
			dnprintf(50, "aml_mid: invalid type: %x\n", lhs->type);
			break;
d2399 8
a2406 22

	case AMLOP_CONCAT:
		/* Concatenate result values */
		lhs = aml_evalnode(ctx, childOf(node, 0));
		rhs = aml_evalnode(ctx, childOf(node, 1));
		if (lhs->type == rhs->type) {
			switch (lhs->type) {
			case AML_OBJTYPE_STRING:
				rv = aml_allocvalue(AML_OBJTYPE_STRING, lhs->length+rhs->length, NULL, "");
				if (rv != NULL) {
					strncpy(rv->v_string, lhs->v_string, lhs->length);
					strncpy(rv->v_string+lhs->length, rhs->v_string, rhs->length);
				}
				break;
			case AML_OBJTYPE_BUFFER:
				rv = aml_allocvalue(AML_OBJTYPE_BUFFER, lhs->length+rhs->length, NULL, "");
				if (rv != NULL) {
					memcpy(rv->v_buffer, lhs->v_buffer, lhs->length);
					memcpy(rv->v_buffer+lhs->length, rhs->v_buffer, rhs->length);
				}
				break;
			}
d2408 1
d2410 5
a2414 4

	case AMLOP_NOTIFY:
		i1 = _aml_evalint(ctx, childOf(node, 1));
		dnprintf(50,"NOTIFY: %s %x\n", "", i1);
d2416 6
a2421 4

	case AMLOP_WAIT:
		lhs = aml_evalnode(ctx, childOf(node, 0));
		i1 = _aml_evalint(ctx, childOf(node, 1));
d2423 2
a2424 3

	case AMLOP_SIGNAL:
		lhs = aml_evalnode(ctx, childOf(node, 0));
d2426 2
a2427 3

	case AMLOP_RESET:
		lhs = aml_evalnode(ctx, childOf(node, 0));
d2429 2
a2430 4

	case AMLOP_ACQUIRE:
		lhs = aml_evalnode(ctx, childOf(node, 0));
		i1 = _aml_evalint(ctx, childOf(node, 1));
d2432 2
a2433 3

	case AMLOP_RELEASE:
		lhs = aml_evalnode(ctx, childOf(node, 0));
d2435 2
a2436 4

	case AMLOP_STALL:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "stall %d usecs\n", i1);
d2439 2
a2440 3
	case AMLOP_SLEEP:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "sleep %d msecs\n", i1);
d2443 3
d2447 2
a2448 7
	/* Free temporary objects */
	aml_freevalue(lhs);
	aml_freevalue(rhs);

	aml_showvalue(rv);

	return aml_deref(ctx, rv);
d2451 2
a2452 3
int
aml_eval_object(struct acpi_softc *sc, struct aml_node *node, struct aml_value *result, 
		struct aml_value *env)
d2454 1
a2454 2
	struct acpi_context ctx;
	struct aml_value *rv;
d2456 8
a2463 8
	memset(&ctx, 0, sizeof(ctx));
	ctx.pos = node->start;

	memset(result, 0, sizeof(struct aml_value));
	rv = aml_evalnode(&ctx, node);
	*result = *rv;

	return (0);
d2466 2
a2467 2
int
aml_parse_args(struct acpi_context *ctx, struct aml_node *node, const char *arg)
d2469 2
a2470 1
	struct aml_node *pnode;
d2472 17
a2488 98
	while (*arg) {
		pnode = node;
		switch (*arg) {
		case AML_ARG_FLAG:
			node->flag = aml_parse_int(ctx, 1);
			if (node->opcode == AMLOP_METHOD) {
				dnprintf(50, " method %s %.2x argcount:%d serialized:%d synclevel:%d\n",
					 node->name, node->flag,
					 AML_METHOD_ARGCOUNT(node->flag),
					 AML_METHOD_SERIALIZED(node->flag),
					 AML_METHOD_SYNCLEVEL(node->flag));
			}
			else {
				dnprintf(50, " field %.2x access:%d lock:%d update:%d\n",
					 node->flag,
					 AML_FIELD_ACCESS(node->flag),
					 AML_FIELD_LOCK(node->flag),
					 AML_FIELD_UPDATE(node->flag));
			}
			break;
		case AML_ARG_IMPBYTE:
			/* Implied byte: same as opcode */
			node->value = aml_allocint((char)node->opcode);
			dnprintf(50, " ibyte: %x\n", (int8_t)node->opcode);
			break;
		case AML_ARG_BYTE:
			if (node->opcode != AMLOP_BYTEPREFIX) {
				pnode = aml_create_node(ctx, node, AMLOP_BYTEPREFIX, "byte");
			}
			pnode->value = aml_allocint(aml_parse_int(ctx, 1));
			dnprintf(50, " byte: %x\n", pnode->value->v_integer);
			break;
		case AML_ARG_WORD:
			if (node->opcode != AMLOP_WORDPREFIX) {
				pnode = aml_create_node(ctx, node, AMLOP_WORDPREFIX, "word");
			}
			pnode->value = aml_allocint(aml_parse_int(ctx, 2));
			dnprintf(50, " word: %x\n", pnode->value->v_integer);
			break;
		case AML_ARG_DWORD:
			if (node->opcode != AMLOP_DWORDPREFIX) {
				pnode = aml_create_node(ctx, node, AMLOP_DWORDPREFIX, "dword");
			}
			pnode->value = aml_allocint(aml_parse_int(ctx, 4));
			dnprintf(50, " dword: %x\n", pnode->value->v_integer);
			break;
		case AML_ARG_QWORD:
			if (node->opcode == AMLOP_QWORDPREFIX) {
				pnode = aml_create_node(ctx, node, AMLOP_QWORDPREFIX, "qword");
			}
			pnode->value = aml_allocint(aml_parse_int(ctx, 8));
			dnprintf(50, " qword: %x\n", pnode->value->v_integer);	
			break;
		case AML_ARG_FIELDLIST:
			aml_parse_fieldlist(ctx, node);
			break;
		case AML_ARG_BYTELIST:
			dnprintf(50, " bytelist\n");
			node->start = ctx->pos;
			ctx->pos    = node->end;
			break;
		case AML_ARG_STRING:
			node->value = aml_allocstr(aml_parse_string(ctx));
			dnprintf(50, " string: %s\n", node->value->v_string);
			break;
		case AML_ARG_NAMESTRING:
			node->name = aml_parse_name(ctx, "name");
			break;
		case AML_ARG_NAMEREF:
			if (node->opcode != AMLOP_NAMECHAR) {
				pnode = aml_create_node(ctx, node, AMLOP_NAMECHAR, "nameref");
			}
			pnode->value = aml_allocvalue(AML_OBJTYPE_NAMEREF, 0, aml_parse_name(ctx, "nameref"), "");
			break;
		case AML_ARG_OBJLEN:
			dnprintf(50, " pkglen\n");
			node->end = ctx->pos;
			node->end += aml_parse_length(ctx);
			break;
		case AML_ARG_METHOD:
			dnprintf(50, " method\n");
			node->start = ctx->pos;
			ctx->pos = node->end;
			break;
		case AML_ARG_INTEGER:
		case AML_ARG_TERMOBJ:
			/* Recursively parse children */
			aml_parse_object(ctx, node);
			break;
		case AML_ARG_TERMOBJLIST:
			/* Recursively parse children */
			aml_parse_objlist(ctx, node);
			break;

		default:
			printf("Unknown arg: %c\n", *arg);
			break;
		}
d2490 1
a2490 2
		arg++;
	}
d2492 2
a2493 2
	return (0);
}
d2495 2
a2496 4
struct aml_node *
aml_preparse(struct acpi_context *ctx, struct aml_node *parent, struct aml_optable *optab)
{
	const char *arg;
d2498 4
a2501 5
	/* Check for named object */
	for (arg=optab->args; arg && *arg; arg++) {
		if (*arg == AML_ARG_NAMESTRING) {
			/* XXX: check for duplicate name */
		}
d2503 1
a2503 1
	return aml_create_node(ctx, parent, optab->opcode, optab->mnem);
d2506 2
a2507 3
/* Parse a single object */
struct aml_node *
aml_parse_object(struct acpi_context *ctx, struct aml_node *parent)
d2509 2
a2510 3
	struct aml_optable *optab;
	struct aml_node *node;
	u_int16_t opcode;
d2512 4
a2515 11
	/* Get AML Opcode; if it is an embedded name, extract name */
	opcode = aml_getopcode(ctx);
	for (optab = aml_table; optab->opcode != 0xFFFF; optab++) {
		if  (optab->opcode == opcode) {
			/* Found an opcode in the table */
			node = aml_preparse(ctx, parent, optab);
			aml_parse_args(ctx, node, optab->args);
			return node;
		}
	}
	printf("Invalid AML Opcode : @@ %.4x %.4x\n", aml_ipaddr(ctx->pos), opcode);
d2517 2
a2518 2
	return NULL;
}
d2520 1
a2520 13
/* Parse list of objects; stop at end of parent */
int
aml_parse_objlist(struct acpi_context *ctx, struct aml_node *parent)
{
	while (ctx->pos < parent->end) {
		aml_parse_object(ctx, parent);
	}
	if (ctx->pos != parent->end) {
		dnprintf(50, "aml_parse_objlist: invalid end! %x\n", parent->end - ctx->pos);
		ctx->pos = parent->end;
		return (1);
	}
	return (0);
a2522 1

d2537 1
a2537 1
		dnprintf(50, "%s", node->value->v_nameref.name);
d2626 38
d2667 2
a2668 4
	struct acpi_context ctx;

	memset(&ctx, 0, sizeof(ctx));
	ctx.pos = start;
d2670 4
d2677 4
a2680 5
	aml_parse_objlist(&ctx, &aml_root);
	if (length != aml_ipaddr(ctx.pos)) {
		dnprintf(50, " : error parsing AML @@ 0x%x\n", aml_ipaddr(ctx.pos));
		return (-1);
	}
d2684 1
a2684 1
	aml_walktree(&aml_root);
@


1.17
log
@Added new evaluation routines
Added helper methods for buffer/field evaluation
Fixed broken indentation on dsdt.c

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.16 2006/01/17 23:42:14 jordan Exp $ */
a36 7
struct aml_stream
{
	u_int8_t *start;
	u_int8_t *end;
	u_int8_t *pos;
};

a49 2
	u_int8_t   *start;
	u_int8_t   *end;
d72 10
a81 1
void aml_addname(const char *);
a83 1
int aml_parselength(struct acpi_context *);
a84 1
int aml_parseargs(struct acpi_context *, struct aml_node *, const char *);
a85 4
const char *aml_parsename(struct acpi_context *, const char *);
int aml_parse_fieldlist(struct acpi_context *, struct aml_node *);
int aml_parse_objlist(struct acpi_context *, struct aml_node *);
struct aml_node *aml_parse_object(struct acpi_context *, struct aml_node *);
d91 2
a92 2
int aml_lsb(u_int32_t val);
int aml_msb(u_int32_t val);
d96 1
a96 1
struct aml_node *aml_create_node(struct acpi_context *, struct aml_node *, int opcode);
d99 1
a103 1
int  aml_evalint(struct acpi_softc *, struct aml_node *, struct aml_value *);
a104 24
#if 0
void aml_copyvalue(struct aml_value *, const struct aml_value *);
#endif
void aml_setinteger(struct aml_value *, int64_t);
void aml_setstring(struct aml_value *, const char *);
void aml_setbuffer(struct aml_value *, int, u_int8_t *);
void aml_setfield(struct aml_value *, int, int, struct aml_node *, struct aml_node *);
void aml_setopregion(struct aml_value *, int, int, u_int64_t);
void aml_setpackage(struct aml_value *, struct aml_node *);
void aml_setprocessor(struct aml_value *, u_int8_t, u_int32_t, u_int8_t);

struct aml_value *aml_getnodevalue(struct acpi_softc *, struct aml_node *, struct aml_value *);
void aml_setnodevalue(struct acpi_softc *, struct aml_node *, const struct aml_value *, struct aml_value *);
void aml_setnodeinteger(struct acpi_softc *, struct aml_node *, int64_t, struct aml_value *);

int aml_match(struct acpi_softc *, int, const struct aml_value *, const struct aml_value *);
int aml_cmpobj(struct acpi_softc *, const struct aml_value *, const struct aml_value *);

const char *aml_parsestr(struct acpi_context *);
u_int64_t   aml_parseint(struct acpi_context *, int);

struct aml_value *aml_allocvalue(int, int64_t, const void *, const char *);
struct aml_value *aml_copyvalue(const struct aml_value *);
void aml_freevalue(struct aml_value *);
d106 7
a112 2
struct aml_value *aml_allocint(uint64_t);
struct aml_value *aml_allocstr(const char *);
a115 5
#define aml_bitpos(n)      ((n)&0x7)
#define aml_bytepos(n)     ((n)>>3)
#define aml_bytelen(n)     (((n)+7)>>3)
#define aml_bytealigned(x) !((x)&0x7)

d120 2
a124 16
void aml_addname(const char *name)
{
}

struct aml_value *
aml_allocint(uint64_t ival)
{
	return aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL, "integer");
}

struct aml_value *
aml_allocstr(const char *str)
{
	return aml_allocvalue(AML_OBJTYPE_STRING, strlen(str), str, "string");
}

d128 2
d144 24
d240 3
a242 1
	//printf("alloc value: %.2x : %s (%llx)\n", type, lbl, ival);
a243 1
	rv = (struct aml_value *)acpi_os_allocmem(sizeof(struct aml_value));
d247 1
a249 11
#if 0 
		xxx
			case AML_OBJTYPE_REFOF:
			rv->v_index.index  = ival;
		rv->v_index.refobj = bval;
		break;
	case AML_OBJTYPE_ERROR:
		rv->v_error.error = ival;
		rv->v_error.errobj = bval;
		break;
#endif
d253 3
d293 3
a295 5
#if 0 
		xxx
			case AML_OBJTYPE_DEVICE:
	case AML_OBJTYPE_EVENT:
			rv->v_device = bval;
a296 1
#endif
d304 14
a317 1
void aml_freevalue(struct aml_value *v)
d321 3
d326 1
a326 1
		return;
d353 112
d467 3
d471 1
a471 1
aml_parsestr(struct acpi_context *ctx)
d481 1
a481 1
aml_parseint(struct acpi_context *ctx, int size)
a499 89
void
aml_setinteger(struct aml_value *val, int64_t value)
{
	val->type = AML_OBJTYPE_INTEGER;
	val->v_integer = value;
	val->length = 0;
}

void
aml_setstring(struct aml_value *val, const char *str)
{
	val->type = AML_OBJTYPE_STRING;
	val->length = strlen(str);
	val->v_string = (char *)str;
}

void
aml_setbuffer(struct aml_value *val, int size, u_int8_t *ptr)
{
	val->type = AML_OBJTYPE_STRING;
	val->length = size;
	val->v_buffer = ptr;
}

void
aml_setfield(struct aml_value *val, int bitpos, int bitlen, struct aml_node *ref, struct aml_node *node)
{
	dnprintf(50, "setfield: pos=%.8x len=%.8x ref=%s name=%s\n", bitpos, bitlen, ref->name, node->name);
	val->type = AML_OBJTYPE_FIELDUNIT;
	val->length = (bitlen + 7) / 8;
	val->v_field.bitpos = bitpos;
	val->v_field.bitlen = bitlen;
	val->v_field.ref = ref;
}

void aml_create_bufferunit(struct acpi_context *, struct aml_node *, int, int);
void aml_create_fieldunit(struct acpi_context *, struct aml_node *, const char *, int, int, int);

void
aml_create_fieldunit(struct acpi_context *ctx, struct aml_node *parent, const char *name, int bitpos, int bitlen, int flags)
{
	struct aml_node *pfield;

	dnprintf(50, "create_fieldunit: name=%s pos=%.8x len=%.8x\n", name, bitpos, bitlen);

	pfield = aml_create_node(ctx, parent, AMLOP_FIELDUNIT);
	pfield->name = name;

	/* Setup Field Unit object: point to OpRegion NameRef in parent field */
	pfield->value = aml_allocvalue(AML_OBJTYPE_FIELDUNIT, 0, NULL, "FieldUnit");
	if (pfield->value != NULL) {
		pfield->value->v_field.flags  = flags;
		pfield->value->v_field.ftype  = parent->opcode;
		pfield->value->v_field.bitpos = bitpos;
		pfield->value->v_field.bitlen = bitlen;
		pfield->value->v_field.ref    = childOf(parent, 0);
	}
}

void
aml_setpackage(struct aml_value *val, struct aml_node *node)
{
}

void
aml_setprocessor(struct aml_value *val, u_int8_t id, u_int32_t addr, u_int8_t len)
{
	val->type = AML_OBJTYPE_PROCESSOR;
	val->v_processor.proc_id = id;
	val->v_processor.proc_addr = addr;
	val->v_processor.proc_len = len;
}

/* SetOpRegion addresses
 *  0 = SystemMem
 *  1 = SystemIO
 *  2 = PCIConfSpace
 *     dw offset,fn,dev,reserved
 */
void
aml_setopregion(struct aml_value *val, int addrtype, int size, u_int64_t addr)
{
	dnprintf(50, "setopregion: %.2x %.4x %.8x\n", addrtype, size, addr);
	val->type = AML_OBJTYPE_OPREGION;
	val->v_opregion.iospace = addrtype;
	val->v_opregion.iobase  = addr;
	val->v_opregion.iolen   = size;
}

d508 1
a508 1
aml_parselength(struct acpi_context *ctx)
d513 1
a513 1
	lcode = aml_parseint(ctx, 1);
d519 3
a521 3
	if (lcode >= 0x40)  ival |= aml_parseint(ctx, 1) << 4;
	if (lcode >= 0x80)  ival |= aml_parseint(ctx, 1) << 12;
	if (lcode >= 0xC0)  ival |= aml_parseint(ctx, 1) << 20;
d529 1
a529 1
	u_int8_t type, attr;
d534 1
a534 2
	attr = 0;
	type = AML_FIELD_ACCESS(parent->flag);
d536 6
d545 1
a545 1
		switch (aml_parseint(ctx, 1)) {
d547 1
a547 1
			bitlen = aml_parselength(ctx);
d550 2
a551 2
			type = aml_parseint(ctx, 1);
			attr = aml_parseint(ctx, 1);
d553 1
d557 3
a559 3
			name = aml_parsename(ctx, "field");
			bitlen = aml_parselength(ctx);
			aml_create_fieldunit(ctx, parent, name, bitpos, bitlen, (attr<<8) | type);
d573 1
a573 1
aml_parsename(struct acpi_context *ctx, const char *lbl)
d650 3
d657 1
a657 1
	int n,pos;
d659 2
a660 2
	pos=1;
	for (rval=0; val; val >>= 4) {
d675 1
a675 1
	int n,pos;
d677 2
a678 2
	pos=0;
	for (rval=0; val; val /= 10) {
d689 1
a689 1
aml_lsb(u_int32_t val)
d691 1
a691 1
	int n = 31;
d693 6
a698 6
	if (!val) return -1;
	if (val & 0x0000FFFF) { val <<= 16; n -= 16; };
	if (val & 0x00FF0000) { val <<= 8;  n -= 8; };
	if (val & 0x0F000000) { val <<= 4;  n -= 4; };
	if (val & 0x30000000) { val <<= 2;  n -= 2; };
	return (val & 0x40000000) ? n-1 : n;
d703 1
a703 1
aml_msb(u_int32_t val)
d705 4
a708 1
	int n=0;
d710 3
a712 6
	if (!val) return -1;
	if (val & 0xFFFF0000) { val >>= 16; n += 16; };
	if (val & 0x0000FF00) { val >>= 8;  n += 8; };
	if (val & 0x000000F0) { val >>= 4;  n += 4; };
	if (val & 0x0000000C) { val >>= 2;  n += 2; };
	return (val & 0x00000002) ? n+1 : n;
a758 6
int
aml_strcmp(u_int16_t opcode, const char *lhs, const char *rhs)
{
	return (0);
}

d786 15
a800 46
/* Extract opcode from AML bytestream 
 *
 * Some opcodes are multibyte
 * Strings can also be embedded within the stream
 */
u_int16_t
aml_getopcode(struct acpi_context *ctx)
{
	u_int16_t twocode;
	u_int16_t opcode;

	/* Check for encoded name */
	if (aml_isnamedop(*ctx->pos)) {
		return AMLOP_NAMECHAR;
	}

	opcode  = aml_parseint(ctx, 1);
	twocode = (opcode << 8L) + *ctx->pos;

	/* Check multi-byte opcodes */
	if (twocode == AMLOP_LNOTEQUAL ||
	    twocode == AMLOP_LLESSEQUAL ||
	    twocode == AMLOP_LGREATEREQUAL ||
	    opcode == AMLOP_EXTPREFIX) {
		ctx->pos++;
		return twocode;
	}

	return opcode;
}

struct aml_optable aml_table[] = {
	/* Simple types */
	{ AMLOP_ZERO,             "Zero",            "!"  },
	{ AMLOP_ONE,              "One",             "!"  },
	{ AMLOP_ONES,             "Ones",            "!"  },
	{ AMLOP_BYTEPREFIX,       "Byte",            "b"  },
	{ AMLOP_WORDPREFIX,       "Word",            "w"  },
	{ AMLOP_DWORDPREFIX,      "DWord",           "d"  },
	{ AMLOP_QWORDPREFIX,      "QWord",           "q"  },
	{ AMLOP_REVISION,         "Revision",        ""   },
	{ AMLOP_STRINGPREFIX,     "String",          "s"  },
	{ AMLOP_DEBUG,            "DebugOp",         "",  },
	{ AMLOP_BUFFER,           "Buffer",          "piB" },
	{ AMLOP_PACKAGE,          "Package",         "pbT" },
	{ AMLOP_VARPACKAGE,       "VarPackage",      "piT" },
d924 7
a930 4
#if 0 
xxx
/* Copy an AML value object */
void aml_copyvalue(struct aml_value *dst, const struct aml_value *src)
d932 7
a938 2
	dst->type   = src->type;
	dst->length = src->length;
d940 10
a949 13
	switch (dst->type) {
	case AML_OBJTYPE_INTEGER:
		dst->v_integer = src->v_integer;
		break;
	case AML_OBJTYPE_STRING:
		dst->v_string = src->v_string;
		break;
	case AML_OBJTYPE_BUFFER:
		dst->v_buffer = src->v_buffer;
		break;
	case AML_OBJTYPE_PACKAGE:
		dst->v_package = src->v_package;
		break;
d951 2
a953 1
#endif
a965 3
#define AML_NUM_LOCALS 8
#define AML_INTSTRLEN 16

d968 3
a970 3
struct aml_value *
aml_getnodevalue(struct acpi_softc *sc, struct aml_node *node,
		 struct aml_value *env)
d972 7
a978 5
	int id;

	if (node == NULL) {
		printf("aml_getnodevalue: null\n");
		return NULL;
d980 1
a980 40
	switch (node->opcode) {
	case AMLOP_DEBUG:
		return &aml_debugobj;

	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
		return &env->v_method.locals[id];

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
		return &env->v_method.args[id];

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
		return node->value;

	default:
		printf("aml_getnodevalue: no type: %.4x\n", node->opcode);
		break;
	}
	return NULL;
d984 1
a984 2
aml_setnodevalue(struct acpi_softc *sc, struct aml_node *node, const struct aml_value *val,
		 struct aml_value *env)
d986 1
a986 3
	struct aml_value *dest = NULL;
	struct aml_value  lhs;
	int id;
d988 7
a994 3
	if (node == NULL) {
		printf("aml_setnodevalue: null\n");
		return;
d996 1
a996 120
	dnprintf(50, "--- setnodevalue:\n");
	aml_shownode(node);
	aml_showvalue((struct aml_value *)val);
	switch (node->opcode) {
	case AMLOP_DEBUG:
		dest = &aml_debugobj;
		break;

	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
		dest = &env->v_method.locals[id];
		break;

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
		dest = &env->v_method.args[id];
		break;

	case AMLOP_NAMECHAR:
		return aml_setnodevalue(sc, aml_find_name(sc, NULL, node->name), val, env);

	case AMLOP_CREATEFIELD:
	case AMLOP_CREATEBITFIELD:
	case AMLOP_CREATEBYTEFIELD:
	case AMLOP_CREATEWORDFIELD:
	case AMLOP_CREATEDWORDFIELD:
	case AMLOP_CREATEQWORDFIELD:
		aml_eval_object(sc, node, &lhs, env);
		aml_showvalue(&lhs);
		for(;;);
		break;

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_REVISION:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	default:
		printf("aml_setnodeval: read-only %.4x\n", node->opcode);
		break;
	}
	if (dest) {
		dnprintf(50, "aml_setnodeval: %.4x\n", node->opcode);
#if 0 
		xxx
			aml_copyvalue(dest, val);
#endif
	}
}

void
aml_setnodeinteger(struct acpi_softc *sc, struct aml_node *node, int64_t value,
		   struct aml_value *env)
{
	struct aml_value ival;

	aml_setinteger(&ival, value);
	aml_setnodevalue(sc, node, &ival, env);
}

int aml_cmpobj(struct acpi_softc *sc, const struct aml_value *lhs,
	       const struct aml_value *rhs)
{
	/* ASSERT: lhs and rhs are of same type */
	switch (lhs->type) {
	case AML_OBJTYPE_INTEGER:
		return (lhs->v_integer - rhs->v_integer);
	case AML_OBJTYPE_STRING:
		return strcmp(lhs->v_string, rhs->v_string);
	default:
		printf("Unknown compare type for cmpobj\n");
		break;
	}

	return (0);
}

int
aml_match(struct acpi_softc *sc, int mtype, const struct aml_value *lhs, 
	  const struct aml_value *rhs)
{
	int rc;

	if (mtype == AML_MATCH_TR)
		return (1);

	if (lhs->type != rhs->type)
		return (0);

	rc = aml_cmpobj(sc, lhs, rhs);
	switch (mtype) {
	case AML_MATCH_EQ:
		return (rc == 0);
	case AML_MATCH_LT:
		return (rc < 0);
	case AML_MATCH_LE:
		return (rc <= 0);
	case AML_MATCH_GE:
		return (rc >= 0);
	case AML_MATCH_GT:
		return (rc > 0);
	}

	return (0);
d1000 1
a1000 1
aml_create_node(struct acpi_context *ctx, struct aml_node *parent, int opcode)
d1007 1
d1009 2
a1010 1
	node->opcode = (opcode == -1) ? aml_getopcode(ctx) : opcode;
a1015 12
int
aml_evalint(struct acpi_softc *sc, struct aml_node *node, struct aml_value *env)
{
	struct  aml_value ival;

	aml_eval_object(sc, node, &ival, env);
	if (ival.type == AML_OBJTYPE_INTEGER)
		return ival.v_integer;

	return (0);
}

d1062 22
a1083 4
int64_t _aml_evalint(struct acpi_context *, struct aml_node *);
struct aml_value *_aml_getnodevalue(struct acpi_context *, struct aml_node *);
struct aml_value *_aml_evalnode(struct acpi_context *, struct aml_node *);
struct aml_value *_aml_setnodevalue(struct acpi_context *, struct aml_node *, struct aml_value *, uint64_t);
d1085 6
a1090 2
int64_t
_aml_evalint(struct acpi_context *ctx, struct aml_node *node)
d1092 12
a1103 1
	return 0;
d1106 2
a1107 2
struct aml_value *
_aml_evalnode(struct acpi_context *ctx, struct aml_node *node)
d1109 19
a1127 2
	struct aml_value *rv;
	uint64_t i1, i2;
d1129 16
a1144 2
	if ((rv = _aml_getnodevalue(ctx, node)) != NULL) {
		return rv;
d1146 1
d1148 17
a1164 5
	switch (node->opcode) {
	case AMLOP_ELSE:
	case AMLOP_BREAK:
	case AMLOP_CONTINUE:
		break;
d1166 5
a1170 14
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 0), NULL, 
				       aml_evalmath(node->opcode, i1, 1));
		break;
		
	case AMLOP_NOT:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, 
				       aml_evalmath(node->opcode, i1, 0));
		break;
d1172 5
a1176 8
	case AMLOP_DIVIDE:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		i2 = _aml_evalint(ctx, childOf(node, 1));
		_aml_setnodevalue(ctx, childOf(node, 2), NULL, 
				  aml_evalmath(AMLOP_MOD, i1, i2));
		rv = _aml_setnodevalue(ctx, childOf(node, 3), NULL,
				       aml_evalmath(AMLOP_DIVIDE, i1, i2));
		break;
d1178 17
a1194 16
	case AMLOP_ADD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_OR:
	case AMLOP_XOR:
	case AMLOP_NOR:
	case AMLOP_MOD:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		i2 = _aml_evalint(ctx, childOf(node, 1));
		rv = _aml_setnodevalue(ctx, childOf(node, 2), NULL, 
				       aml_evalmath(node->opcode, i1, i2));
		break;
d1196 4
a1199 3
	case AMLOP_LNOT:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = aml_allocint(!i1);
d1201 3
a1203 4

	case AMLOP_TOINTEGER:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, i1);
d1205 5
d1211 5
a1215 4
	case AMLOP_FROMBCD:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, aml_bcd2dec(i1));
		break;
d1217 11
a1227 4
	case AMLOP_TOBCD:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		rv = _aml_setnodevalue(ctx, childOf(node, 1), NULL, aml_dec2bcd(i1));
		break;
d1229 2
a1230 4
	case AMLOP_STALL:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "stall %d usecs\n", i1);
		break;
d1232 1
a1232 3
	case AMLOP_SLEEP:
		i1 = _aml_evalint(ctx, childOf(node, 0));
		dnprintf(50, "sleep %d msecs\n", i1);
d1236 18
a1253 20
	return rv;
}

void
aml_create_bufferunit(struct acpi_context *ctx, struct aml_node *node, int bitlen, int size)
{
	/* ASSERT: node->value is NULL */
	node->value = aml_allocvalue(AML_OBJTYPE_BUFFERFIELD, 0, NULL, "bufferunit");
	if (node->value != NULL) {
		node->value->length = aml_bytelen(bitlen);
		node->value->v_field.ftype  = node->opcode;
		node->value->v_field.bitpos = _aml_evalint(ctx, childOf(node, 1)) * size;
		node->value->v_field.ref = childOf(node, 0);  
		
		dnprintf(50, "create_bufferunit: name=%s pos=%.8x len=%.8x size=%.8x\n", 
			 node->name, node->value->v_field.bitpos,
			 bitlen, size);
		if (bitlen == -1) {
			/* AMLOP_CREATEFIELD: decode bitlength */
			bitlen = _aml_evalint(ctx, childOf(node, 2));
d1255 20
a1274 1
		node->value->v_field.bitlen = bitlen;
d1276 1
d1282 14
a1295 1
	return NULL;
d1299 1
a1299 1
_aml_getnodevalue(struct acpi_context *ctx, struct aml_node *node)
d1304 1
a1304 1
		dnprintf(50, "returning cached object value: %.4x %s\n", node->opcode, node->mnem);
d1377 1
a1377 1
			node->value->v_package[i2] = _aml_evalnode(ctx, childOf(node, 1+i2));
d1387 4
d1400 4
d1435 2
d1440 5
a1444 3
int
aml_eval_object(struct acpi_softc *sc, struct aml_node *node, struct aml_value *result, 
		struct aml_value *env)
d1446 27
a1472 9
	memset(result, 0, sizeof(struct aml_value));
#if 0 
	xxx
		struct  aml_value lhs, rhs, tmp, pkg;
	struct aml_value *px;
	int64_t iresult, id, idx;
	struct  aml_node *cflow = NULL;
	int     i1, i2, i3;
	char   *tmpstr;
d1474 9
a1482 2
	if (node == NULL) 
		return (-1);
d1484 1
a1484 2
	dnprintf(50, "--- Evaluating object:\n"); 
	aml_shownode(node);
d1486 4
a1489 14
	switch (node->opcode) {
	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
	case AMLOP_REVISION:
#if 0
		aml_copyvalue(result, &node->value);
#endif
		break;
d1491 17
a1507 4
	case AMLOP_BUFFER:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@ buffer: %.4x %.4x\n", i1, node->value->length);
		break;
a1508 4
	case AMLOP_STORE:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_setnodevalue(sc, childOf(node, 1), &lhs, env);
		break;
d1510 6
a1515 5
	case AMLOP_DEBUG:
#if 0
		aml_copyvalue(result, &aml_debugobj);
#endif
		break;
d1517 4
a1520 3
	case AMLOP_NAME:
	case AMLOP_ALIAS:
		return aml_eval_object(sc, childOf(node, 0), result, env);
d1522 10
a1531 6
	case AMLOP_PROCESSOR:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		i3 = aml_evalint(sc, childOf(node, 2), env);
		aml_setprocessor(result, i1, i2, i3);
		break;
d1533 10
a1542 5
	case AMLOP_OPREGION:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		aml_setopregion(result, node->flag, i1, i2);
		break;
d1544 6
a1549 15
	case AMLOP_IF:
		i1 = aml_evalint(sc, childOf(node,0), env);
		if (i1 != 0) {
			/* Test true, select 'If' block */
			cflow = childOf(node, 1);
		}
		else if (node->sibling->opcode == AMLOP_ELSE) {
			/* Test false, select 'Else' block */
			cflow = node->sibling->child;
		}
		while (cflow) {
			/* Execute all instructions in scope block */
			aml_eval_object(sc, cflow, result, env);
			cflow = cflow->sibling;
		}
d1555 1
a1555 1
				/* Perform While test */
d1557 3
a1559 2
				i1 = aml_evalint(sc, childOf(node, 0), env);
				if (i1 == 0) 
d1562 1
a1562 1
			else if (cflow->opcode == AMLOP_BREAK) 
d1568 3
a1570 2
				/* Execute all instructions in scope block */
				aml_eval_object(sc, cflow, result, env);
d1575 17
a1591 3
		
	case AMLOP_RETURN:
		aml_eval_object(sc, childOf(node, 0), result, env);
d1594 9
a1602 12
	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
#if 0
		if (id < env->length)
			aml_copyvalue(result, &node->value->v_method.locals[id]);
#endif
d1605 3
a1607 12
	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
#if 0
		aml_copyvalue(result, &env->v_method.locals[id]);
#endif
d1610 5
a1614 11
	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "package = %d\n", i1);
		result->type = AML_OBJTYPE_PACKAGE;
		result->length = i1;

		result->v_package = acpi_os_allocmem(i1 * sizeof(struct aml_value));
		for (i2=0; i2<i1; i2++) {
			aml_eval_object(sc, childOf(node, i2+1), result->v_package[i2], env);
		}
d1616 1
a1616 1
	
d1619 3
a1621 3
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_evalmath(node->opcode, i1, 0);
		aml_setnodeinteger(sc, childOf(node, 0), iresult, env);
d1623 1
a1623 1

d1627 3
a1629 3
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_evalmath(node->opcode, i1, 0);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
d1633 7
a1639 10
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);

		/* Set remainder */
		iresult = aml_evalmath(AMLOP_MOD,    i1, i2);
		aml_setnodeinteger(sc, childOf(node, 2), iresult, env);

		/* Set quotient */
		iresult = aml_evalmath(node->opcode, i1, i2);
		aml_setnodeinteger(sc, childOf(node, 3), iresult, env);
d1650 1
a1651 1
	case AMLOP_XOR:
d1653 4
a1656 5
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);

		iresult = aml_evalmath(node->opcode, i1, i2);
		aml_setnodeinteger(sc, childOf(node, 2), iresult, env);
d1660 2
a1661 3
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_testlogical(node->opcode, i1, 0);
		aml_setinteger(result, iresult);
a1665 6
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		iresult = aml_testlogical(node->opcode, i1, i2);
		aml_setinteger(result, iresult);
		break;

d1672 22
a1693 4
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_eval_object(sc, childOf(node, 1), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_testlogical(node->opcode, lhs.v_integer, rhs.v_integer);
d1695 45
a1739 2
		else if (lhs.type == AML_OBJTYPE_STRING && rhs.type == AML_OBJTYPE_STRING) {
			iresult = aml_strcmp(node->opcode, lhs.v_string, rhs.v_string);
a1740 1
		aml_setinteger(result, iresult);
d1743 5
a1747 5
	case AMLOP_CREATEFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		i2 = aml_evalint(sc, childOf(node, 2), env);
		aml_setfield(&lhs, i1, i2, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 3), &lhs, env);
d1749 5
a1753 4
	case AMLOP_CREATEBITFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1, 1, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
d1755 5
a1759 4
	case AMLOP_CREATEBYTEFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 8, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
d1761 17
a1777 4
	case AMLOP_CREATEWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 16, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
d1779 3
a1781 4
	case AMLOP_CREATEDWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 32, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
d1783 10
a1792 4
	case AMLOP_CREATEQWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 64, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
d1794 11
a1804 5
		
	case AMLOP_TOBCD:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_dec2bcd(i1);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
d1806 5
a1810 4
	case AMLOP_FROMBCD:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_bcd2dec(i1);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
d1812 32
a1843 6
	case AMLOP_TODECSTRING:
		tmpstr = acpi_os_allocmem(AML_INTSTRLEN+1);
		if (tmpstr != NULL) {
			aml_eval_object(sc, childOf(node, 0), &lhs, env);
			if (lhs.type == AML_OBJTYPE_INTEGER) 
				snprintf(tmpstr, AML_INTSTRLEN, "%d", lhs.v_integer);
d1846 22
a1867 6
	case AMLOP_TOHEXSTRING:
		tmpstr = acpi_os_allocmem(AML_INTSTRLEN+1);
		if (tmpstr != NULL) {
			aml_eval_object(sc, childOf(node, 0), &lhs, env);
			if (lhs.type == AML_OBJTYPE_INTEGER) 
				snprintf(tmpstr, AML_INTSTRLEN, "%x", lhs.v_integer);
d1871 3
a1873 11
	case AMLOP_MID:
		aml_eval_object(sc, childOf(node, 0), &tmp, env);
		aml_eval_object(sc, childOf(node, 1), &lhs, env);
		aml_eval_object(sc, childOf(node, 2), &rhs, env);
		if (tmp.type != AML_OBJTYPE_STRING) 
			return (-1);

		tmpstr = acpi_os_allocmem(rhs.v_integer+1);
		if (tmpstr != NULL) {
			strncpy(tmpstr, tmp.v_string + lhs.v_integer, rhs.v_integer);
		}
d1876 3
a1878 3
	case AMLOP_STALL:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "aml_stall: %d\n", i1);
d1880 3
a1882 3
	case AMLOP_SLEEP:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "aml_sleep: %d\n", i1);
d1884 3
a1886 3
	case AMLOP_OBJECTTYPE:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_setinteger(result, lhs.type);
d1889 3
a1891 2
	case AMLOP_NAMECHAR: /* Inline method call */
		aml_eval_name(sc, NULL, node->name, result, env);
d1894 3
a1896 3
	case AMLOP_METHOD:
		dnprintf(50, "eval-method : %s  argcount:%d\n", 
			 node->name, AML_METHOD_ARGCOUNT(node->flag));
d1898 3
a1900 16
		lhs.type = AML_OBJTYPE_METHOD;
		lhs.length = AML_METHOD_ARGCOUNT(node->flag);
		if (lhs.length > 0) {
			lhs.v_method.args = acpi_os_allocmem(lhs.length * sizeof(struct aml_value));
			memset(lhs.v_method.args, 0, lhs.length * sizeof(struct aml_value));
		}
		lhs.v_method.locals = acpi_os_allocmem(8 * sizeof(struct aml_value));

		for (i1=0; i1<lhs.length; i1++) {
			dnprintf(50, " evalmeth: %s:%d\n", node->name, i1);
			aml_eval_object(sc, childOf(node, i1), &lhs.v_method.args[i1], env);
			aml_showvalue(&lhs.v_method.args[i1]);
		}
		while (childOf(node, i1)) {
			aml_eval_object(sc, childOf(node, i1++), result, &lhs);
		}
d1903 3
a1905 3
	case AMLOP_CONCAT:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_eval_object(sc, childOf(node, 1), &rhs, env);
d1907 10
d1918 6
a1923 2
	case AMLOP_NOP:
		break;
d1925 2
a1926 6
	case AMLOP_SIZEOF:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		px = aml_getnodevalue(sc, childOf(node, 0), env);
		aml_showvalue(px);
		for(;;);
		break;
d1928 3
a1930 20
	case AMLOP_MATCH:
		aml_eval_object(sc, childOf(node, 0), &pkg, env);
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_eval_object(sc, childOf(node, 2), &lhs, env);
		i2 = aml_evalint(sc, childOf(node, 3), env);
		aml_eval_object(sc, childOf(node, 4), &lhs, env);
		idx = aml_evalint(sc, childOf(node, 5), env);
		if (pkg.type == AML_OBJTYPE_PACKAGE) {
			iresult = -1;
			while (idx < pkg.length) {
				if (aml_match(sc, i1, &pkg.v_package[idx], &lhs) ||
				    aml_match(sc, i2, &pkg.v_package[idx], &rhs)) {
					iresult = idx;
					break;
				}
				idx++;
			}
			aml_setinteger(result, iresult);
		}
		break;
a1931 5
	default:
		printf("Unknown eval: %.4x %s\n", node->opcode, node->mnem);
		break;
	}
#endif
d1936 1
a1936 1
aml_parseargs(struct acpi_context *ctx, struct aml_node *node, const char *arg)
d1944 1
a1944 1
			node->flag = aml_parseint(ctx, 1);
d1953 2
a1954 2
				dnprintf(50, " field %s %.2x access:%d lock:%d update:%d\n",
					 node->name, node->flag,
d1967 1
a1967 1
				pnode = aml_create_node(ctx, node, AMLOP_BYTEPREFIX);
d1969 1
a1969 1
			pnode->value = aml_allocint(aml_parseint(ctx, 1));
d1974 1
a1974 1
				pnode = aml_create_node(ctx, node, AMLOP_WORDPREFIX);
d1976 1
a1976 1
			pnode->value = aml_allocint(aml_parseint(ctx, 2));
d1981 1
a1981 1
				pnode = aml_create_node(ctx, node, AMLOP_DWORDPREFIX);
d1983 1
a1983 1
			pnode->value = aml_allocint(aml_parseint(ctx, 4));
d1988 1
a1988 1
				pnode = aml_create_node(ctx, node, AMLOP_QWORDPREFIX);
d1990 1
a1990 1
			pnode->value = aml_allocint(aml_parseint(ctx, 8));
a1993 1
			dnprintf(50, " fieldlist\n");
d2002 1
a2002 1
			node->value = aml_allocstr(aml_parsestr(ctx));
d2006 1
a2006 1
			node->name = aml_parsename(ctx, "name");
d2009 4
a2012 2
			pnode = aml_create_node(ctx, node, AMLOP_NAMECHAR);
			pnode->name = aml_parsename(ctx, "nameref");
d2017 1
a2017 1
			node->end += aml_parselength(ctx);
d2045 2
a2046 2
void
aml_addchildnode(struct aml_node *parent, struct aml_node *child)
d2048 1
a2048 1
	struct aml_node *psib;
d2050 4
a2053 6
	child->parent = parent;
	child->sibling = NULL;
	for (psib = parent->child; psib; psib = psib->sibling) {
		if (psib->sibling == NULL) {
			psib->sibling = child;
			return;
d2056 1
a2056 1
	parent->child = child;
d2059 3
a2061 2
int
aml_tstbit(const u_int8_t *pb, int bit)
d2063 3
a2065 3
	pb += aml_bytepos(bit);
	return (*pb & (1L << aml_bitpos(bit)));
}
d2067 8
a2074 54
void
aml_setbit(u_int8_t *pb, int bit, int val)
{
	pb += aml_bytepos(bit);
	if (val) {
		*pb |= (1L << aml_bitpos(bit));
	}
	else {
		*pb &= ~(1L << aml_bitpos(bit));
	}
}


/* aml_bufcpy copies/shifts buffer data, special case for aligned transfers
 *   dstPos/srcPos are bit positions within destination/source buffers
 */
void
aml_bufcpy(u_int8_t *pDst, int dstPos, const u_int8_t *pSrc, int srcPos, 
	   int len)
{
	int idx;

	if (aml_bytealigned(dstPos|srcPos|len)) {
		/* Aligned transfer: use memcpy */
		memcpy(pDst+aml_bytepos(dstPos), pSrc+aml_bytepos(srcPos), aml_bytelen(len));
	}
	else {
		/* Misaligned transfer: perform bitwise copy */
		for (idx=0; idx<len; idx++) {
			aml_setbit(pDst, idx+dstPos, aml_tstbit(pSrc, idx+srcPos));
		}
	}
}

/* Copy to/from a buffer object */
struct aml_value *
aml_bufferio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs)
{
	struct aml_value *pbuf, *rv;

	pbuf = _aml_evalnode(ctx, pfield->v_field.ref);
	if (pbuf->type != AML_OBJTYPE_BUFFERFIELD) {
		dnprintf(50, "Invalid bufferio!\n");
		return NULL;
	}
	if (rhs == NULL) {
		/* Return buffer object */
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, pfield->length, NULL, "bufferio");
		if (rv != NULL) {
			aml_bufcpy(rv->v_buffer, 0, pbuf->v_buffer, 
				   pfield->v_field.bitpos, 
				   pfield->v_field.bitlen);
			aml_showvalue(rv);
			aml_freevalue(pbuf);
a2075 1
		return rv;
d2077 1
a2078 10
	switch (rhs->type) {
	case AML_OBJTYPE_INTEGER:
		aml_bufcpy(pbuf->v_buffer, pfield->v_field.bitpos, (u_int8_t *)&rhs->v_integer, 0, pfield->v_field.bitlen);
		break;
	case AML_OBJTYPE_BUFFER:
		aml_bufcpy(pbuf->v_buffer, pfield->v_field.bitpos, rhs->v_buffer, 0, pfield->v_field.bitlen);
		break;
	default:
		dnprintf(50, "invalid type to bufferio\n");
	}
d2082 3
a2084 3
/* Copy to/from a field object */
struct aml_value *
aml_fieldio(struct acpi_context *ctx, struct aml_value *pfield, struct aml_value *rhs)
d2086 2
a2087 6
	struct aml_value *pbuf, *rv;

	pbuf = _aml_evalnode(ctx, pfield->v_field.ref);
	if (pbuf->type != AML_OBJTYPE_OPREGION) {
		dnprintf(50, "Invalid fieldio!\n");
		return NULL;
d2089 4
a2092 7
	if (rhs == NULL) {
		/* Return buffer object */
		rv = aml_allocvalue(AML_OBJTYPE_BUFFER, pfield->length, NULL, "bufferio");
		if (rv != NULL) {
			aml_showvalue(rv);
		}
		return rv;
d2094 1
a2094 1
	return pbuf;
a2096 65
void
aml_showvalue(struct aml_value *value)
{
	int idx;

	if (value == NULL)
		return;
	switch (value->type) {
	case AML_OBJTYPE_INTEGER:
		dnprintf(50, "integer: %x\n", value->v_integer);
		break;
	case AML_OBJTYPE_STRING:
		dnprintf(50, "string: %s\n", value->v_string);
		break;
	case AML_OBJTYPE_BUFFER:
		dnprintf(50, "buffer: %d {\n", value->length);
		for (idx=0; idx<value->length; idx++) {
			dnprintf(50, "%s0x%.2x", (idx ? "," : ""), value->v_buffer[idx]);
		}
		dnprintf(50, "}\n");
		break;
	case AML_OBJTYPE_PACKAGE:
		dnprintf(50, "package: %d {\n", value->length);
		for (idx=0; idx<value->length; idx++)
			aml_showvalue(value->v_package[idx]);
		dnprintf(50, "}\n");
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		dnprintf(50, "debug");
		break;
	case AML_OBJTYPE_DEVICE:
#if 0 
		xxx
			dnprintf(50, "device: %s", val->v_device->name);
#endif
		break;
	case AML_OBJTYPE_PROCESSOR:
		dnprintf(50, "cpu: %x,%x,%x\n",
			 value->v_processor.proc_id,
			 value->v_processor.proc_addr,
			 value->v_processor.proc_len);
		break;
	case AML_OBJTYPE_FIELDUNIT:
		dnprintf(50, "field: %.4x %x,%x\n",
			 value->v_field.ftype,
			 value->v_field.bitpos,
			 value->v_field.bitlen);
		break;
	case AML_OBJTYPE_BUFFERFIELD:
		dnprintf(50, "bufferfield: %.4x %x,%x\n", 
			 value->v_field.ftype,
			 value->v_field.bitpos,
			 value->v_field.bitlen);
		break;
	case AML_OBJTYPE_OPREGION:
		dnprintf(50, "opregion: %s,0x%x,0x%x\n",
			 opregion(value->v_opregion.iospace),
			 value->v_opregion.iobase,
			 value->v_opregion.iolen);
		break;
	default:
		printf("unknown: %d\n", value->type);
		break;
	}
}
d2101 2
a2102 4
	dnprintf(50, " opcode:%.4x  mnem:%s %s %.2x ",
		 node->opcode, node->mnem ? node->mnem : "", 
		 node->name ? node->name : "",
		 node->flag);
d2110 5
d2118 1
a2118 1
		dnprintf(50, "access:%d lock:%d update:%d\n",
a2139 22
struct aml_node *
aml_parse_object(struct acpi_context *ctx, struct aml_node *parent)
{
	struct aml_optable *optab = aml_table;
	struct aml_node *node;

	/* Get AML Opcode; if it is an embedded name, extract name */
	node = aml_create_node(ctx, parent, -1);
	while (optab->opcode != 0xFFFF) {
		if  (optab->opcode == node->opcode) {
			node->mnem = optab->mnem;
			aml_parseargs(ctx, node, optab->args);
			return node;
		}
		optab++;
	}
	printf("Invalid AML Opcode : @@ %.4x %.4x\n", ctx->pos - ctx->start, node->opcode);
	acpi_os_freemem(node);

	return NULL;
}

d2141 1
a2141 1
aml_walktree(struct aml_node *node, int depth)
d2146 2
a2147 2
		dnprintf(50, " %d ", depth);
		for(idx=0; idx<depth; idx++) {
d2151 1
a2151 1
		aml_walktree(node->child, depth+1);
d2159 1
a2159 1
	aml_walktree(aml_root.child, 0);
a2200 30
void ex5(struct aml_node *, void *);

void
ex5(struct aml_node *node, void *arg)
{
	struct acpi_softc *sc = arg;
	struct aml_value res, env;

	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));
	
	dnprintf(50, "Value is: %s\n", node->name);
	aml_eval_object(sc, node->child, &res, &env);
	aml_showvalue(&res);
}

int
aml_parse_objlist(struct acpi_context *ctx, struct aml_node *parent)
{
	while (ctx->pos < parent->end) {
		aml_parse_object(ctx, parent);
	}
	if (ctx->pos != parent->end) {
		dnprintf(50, "parseobjlist: invalid end!\n");
		ctx->pos = parent->end;
		return (1);
	}
	return (0);
}

d2207 1
a2207 3
	ctx.pos   = start;
	ctx.start = start;
	ctx.end   = ctx.start + length;
d2213 5
d2219 2
@


1.16
log
@Major overhaul of the aml parser.  Evaluater temporarily disabled.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.15 2006/01/06 08:37:32 grange Exp $ */
d32 3
a34 3
  u_int16_t    opcode;
  const char  *mnem;
  const char  *args;
d39 3
a41 3
  u_int8_t *start;
  u_int8_t *end;
  u_int8_t *pos;
d46 4
a49 4
  struct aml_value   *locals;
  struct aml_value   *args;
  struct aml_value    result;
  struct acpi_stack  *next;
d54 2
a55 2
  struct acpi_softc *sc;
  struct acpi_stack *stack;
d57 3
a59 3
  u_int8_t   *start;
  u_int8_t   *end;
  u_int8_t   *pos;
d68 10
a77 10
  switch(id) {
  case 0: return "SystemMemory";
  case 1: return "SystemIO";
  case 2: return "PCIConfig";
  case 3: return "Embedded";
  case 4: return "SMBus";
  case 5: return "CMOS";
  case 6: return "PCIBAR";
  }
  return "";
d81 2
a83 1
void aml_parsefieldlist(struct acpi_context *, struct aml_node *parent);
a84 1
const char *aml_parsename(struct acpi_context *, const char *);
d88 2
d134 1
a134 1
void aml_freevalue(struct aml_value **);
d139 18
d160 1
a160 1
  return aml_allocvalue(AML_OBJTYPE_INTEGER, ival, NULL, "integer");
d166 1
a166 1
  return aml_allocvalue(AML_OBJTYPE_STRING, strlen(str), str, "string");
d177 1
a177 1
  return malloc(size, M_DEVBUF, M_WAITOK);
d183 1
a183 1
  free(ptr, M_DEVBUF);
d186 59
d256 1
a256 1
  struct aml_value *rv;
d258 1
a258 1
  //printf("alloc value: %.2x : %s (%llx)\n", type, lbl, ival);
d260 4
a263 4
  rv = (struct aml_value *)acpi_os_allocmem(sizeof(struct aml_value));
  memset(rv, 0, sizeof(struct aml_value));
  rv->type = type;
  rv->dynamic = 1;
d265 1
a265 1
  switch (type) {
d267 9
a275 9
    xxx
      case AML_OBJTYPE_REFOF:
      rv->v_index.index  = ival;
    rv->v_index.refobj = bval;
    break;
  case AML_OBJTYPE_ERROR:
    rv->v_error.error = ival;
    rv->v_error.errobj = bval;
    break;
d277 40
a316 40
  case AML_OBJTYPE_INTEGER:
    rv->v_integer = ival;
    break;
  case AML_OBJTYPE_STRING:
    /* Allocate string: if pointer valid, copy data */
    rv->length = ival;
    rv->v_string = NULL;
    if (ival) {
      rv->v_string = acpi_os_allocmem(ival+1);
      memset(rv->v_string, 0, ival+1);
      if (bval) {
	strncpy(rv->v_string, bval, ival);
      }
    }
    break;
  case AML_OBJTYPE_BUFFER:
    /* Allocate buffer: if pointer valid, copy data */
    rv->length = ival;
    rv->v_buffer = NULL;
    if (ival) {
      rv->v_buffer = acpi_os_allocmem(ival);
      memset(rv->v_buffer, 0, ival);
      if (bval) {
	memcpy(rv->v_buffer, bval, ival);
      }
    }
    break;
  case AML_OBJTYPE_PACKAGE:
    /* Allocate package pointers */
    rv->length = ival;
    rv->v_package = (struct aml_value **)acpi_os_allocmem(rv->length * sizeof(struct aml_value *));
    memset(rv->v_package, 0, rv->length * sizeof(struct aml_value *));
    break;
  case AML_OBJTYPE_METHOD:
    /* Allocate method stack */
    rv->v_method.locals = (struct aml_value *)acpi_os_allocmem(8 * sizeof(struct aml_value));
    rv->v_method.args   = (struct aml_value *)acpi_os_allocmem(ival * sizeof(struct aml_value));
    memset(rv->v_method.locals, 0, 8 * sizeof(struct aml_value));
    memset(rv->v_method.args, 0, ival * sizeof(struct aml_value));
    break;
d318 5
a322 6
    xxx
      case AML_OBJTYPE_MUTEX:
  case AML_OBJTYPE_DEVICE:
  case AML_OBJTYPE_EVENT:
      rv->v_device = bval;
    break;
d324 5
a328 2
  }
  return rv;
d331 1
a331 1
void aml_freevalue(struct aml_value **pv)
d333 1
a333 2
  int idx;
  struct aml_value *v = *pv;
d335 29
a363 38
  /* Don't free static values */
  if (v == NULL || !v->dynamic)
    return;

  printf("freeing value : %x\n", v->type);
  switch (v->type) {
  case AML_OBJTYPE_STRING:
    if (v->v_string) {
      acpi_os_freemem((void *)v->v_string);
      v->v_string = NULL;
    }
    break;
  case AML_OBJTYPE_BUFFER:
    if (v->v_buffer) {
      acpi_os_freemem(v->v_buffer);
      v->v_buffer = NULL;
    }
    break;
  case AML_OBJTYPE_PACKAGE:
    for (idx=0; idx<v->length; idx++) {
      aml_freevalue(&v->v_package[idx]);
    }
    acpi_os_freemem(v->v_package);
    break;
  case AML_OBJTYPE_METHOD:
    for (idx=0; idx<8; idx++) {
#if 0 
      xxx
	aml_freevalue(v->v_method.locals[idx]);
      aml_freevalue(v->v_method.args[idx]);
#endif
    }
    acpi_os_freemem(v->v_method.locals);
    acpi_os_freemem(v->v_method.args);
  }
  v->type = 0;
  acpi_os_freemem(v);
  *pv = 0;
a365 38
#if 0 
xxx
void
aml_showvalue(struct aml_value *val)
{
  int idx;

  if (val == NULL)
    return;
  switch(val->type) {
  case AML_OBJTYPE_INTEGER:
    dnprintf("integer: 0x%x", val->v_integer);
    break;
  case AML_OBJTYPE_STRING:
    dnprintf("string:  %s", val->v_string);
    break;
  case AML_OBJTYPE_PACKAGE:
    printf("package: len = %ld {\n", (unsigned long)val->length);
    for(idx=0; idx<val->length; idx++) {
      aml_showvalue(val->v_package[idx]);
    }
    printf("}\n");
    break;
  case AML_OBJTYPE_BUFFER:
    printf("buffer: len = %ld { ", (unsigned long)val->length);
    for(idx=0; idx<val->length; idx++) {
      printf("%s0x%.2x", (idx ? ", " : ""), val->v_buffer[idx]);
    }
    printf(" }\n");
    break;
  default:
    printf("xxx");
    break;
  }
  printf("\n");
}
#endif

d369 1
a369 1
  const char *str = ctx->pos;
d371 2
a372 2
  ctx->pos += strlen(str)+1;
  return str;
d379 1
a379 1
  u_int8_t *pc = ctx->pos;
d381 11
a391 11
  ctx->pos += size;
  switch (size) {
  case 1:
    return *(u_int8_t *)pc;
  case 2:
    return *(u_int16_t *)pc;
  case 4:
    return *(u_int32_t *)pc;
  case 8:
    return *(u_int64_t *)pc;
  }
d393 1
a393 1
  return (0);
d399 3
a401 3
  val->type = AML_OBJTYPE_INTEGER;
  val->v_integer = value;
  val->length = 0;
d407 3
a409 3
  val->type = AML_OBJTYPE_STRING;
  val->length = strlen(str);
  val->v_string = (char *)str;
d415 3
a417 3
  val->type = AML_OBJTYPE_STRING;
  val->length = size;
  val->v_buffer = ptr;
d423 30
a452 6
  dnprintf(50, "setfield: pos=%.8x len=%.8x ref=%s name=%s\n", bitpos, bitlen, ref->name, node->name);
  val->type = AML_OBJTYPE_FIELDUNIT;
  val->length = (bitlen + 7) / 8;
  val->v_field.bitpos = bitpos;
  val->v_field.bitlen = bitlen;
  val->v_field.ref = ref;
d463 4
a466 4
  val->type = AML_OBJTYPE_PROCESSOR;
  val->v_processor.proc_id = id;
  val->v_processor.proc_addr = addr;
  val->v_processor.proc_len = len;
d478 5
a482 5
  dnprintf(50, "setopregion: %.2x %.4x %.8x\n", addrtype, size, addr);
  val->type = AML_OBJTYPE_OPREGION;
  val->v_opregion.iospace = addrtype;
  val->v_opregion.iobase  = addr;
  val->v_opregion.iolen   = size;
d495 2
a496 2
  u_int8_t lcode;
  int ival;
d498 9
a506 9
  lcode = aml_parseint(ctx, 1);
  if (lcode <= 0x3F) {
    return lcode;
  }

  ival = lcode & 0xF;
  if (lcode >= 0x40)  ival |= aml_parseint(ctx, 1) << 4;
  if (lcode >= 0x80)  ival |= aml_parseint(ctx, 1) << 12;
  if (lcode >= 0xC0)  ival |= aml_parseint(ctx, 1) << 20;
d508 1
a508 1
  return ival;
d511 2
a512 2
void
aml_parsefieldlist(struct acpi_context *ctx, struct aml_node *node)
d514 34
a547 27
  u_int8_t type, attr;
  int len, start;
  struct aml_node *pf;

  start = 0;
  dnprintf(50, "-- parsefield\n");
  while (ctx->pos < node->end) {
    switch (aml_parseint(ctx, 1)) {
    case 0x00: /* reserved */
      len = aml_parselength(ctx);
      start += len;
      break;
    case 0x01: /* access field */
      type = aml_parseint(ctx, 1);
      attr = aml_parseint(ctx, 1);
      dnprintf(50, "  type=%.2x  attr=%.2x\n", type, attr);
      break;
    default: /* named field */
      --ctx->pos;
      pf = aml_create_node(ctx, node, AMLOP_CREATEFIELD);
      pf->name = aml_parsename(ctx, "field");
      len = aml_parselength(ctx);

      //aml_setfield(pf->value, start, len, node, pf);
      start += len;
    }
  }
d554 30
a583 30
  int count, pfxlen;
  char *name, *pn;
  u_int8_t *base;

  pfxlen = 0;
  if (ctx->pos[pfxlen] == AMLOP_ROOTCHAR) {
    pfxlen++;
  }
  while (ctx->pos[pfxlen] == AMLOP_PARENTPREFIX) {
    pfxlen++;
  }

  switch (ctx->pos[pfxlen]) {
  case 0x00:
    count = 0;
    base  = ctx->pos + pfxlen + 1;
    break;
  case AMLOP_MULTINAMEPREFIX:
    count = ctx->pos[pfxlen+1];
    base = ctx->pos + pfxlen + 2;
    break;
  case AMLOP_DUALNAMEPREFIX:
    count = 2;
    base  = ctx->pos + pfxlen + 1;
    break;
  default:
    count = 1;
    base  = ctx->pos + pfxlen;
    break;
  }
d585 2
a586 2
  name = acpi_os_allocmem(pfxlen + count * 5);
  pn = name;
d588 2
a589 2
  while (pfxlen--) 
    *(pn++) = *(ctx->pos++);
d591 11
a601 11
  /* Copy name segments in chunks of 4 bytes */
  while (count--) {
    memcpy(pn, base, 4);
    if (count) {
      *(pn + 4) = '.';
      pn++;
    }
    pn += 4;
    base += 4;
  }
  *pn = 0;
d603 1
a603 1
  dnprintf(50, " acpi_name (%s): %s\n", lbl, name);
d605 1
a605 1
  ctx->pos = base;
d607 1
a607 1
  return name;
d614 8
a621 8
  switch (opcode) {
  case AMLOP_ROOTCHAR:
  case AMLOP_PARENTPREFIX:
  case AMLOP_MULTINAMEPREFIX:
  case AMLOP_DUALNAMEPREFIX:
  case AMLOP_NAMECHAR:
    return (1);
  }
d623 2
a624 2
  if (opcode >= 'A' && opcode <= 'Z')
    return (1);
d626 1
a626 1
  return (0);
d632 8
a639 2
  u_int64_t rval;
  int n,pos;
d641 4
a644 10
  pos=1;
  for (rval=0; val; val >>= 4) {
    n = (val & 0xF);
    if (n > 9)
      return (0);

    rval += (n * pos);
    pos *= 10;
  }
  return rval;
d650 6
a655 2
  u_int64_t rval;
  int n,pos;
d657 4
a660 8
  pos=0;
  for (rval=0; val; val /= 10) {
    n = (val % 10);

    rval += (n << pos);
    pos += 4;
  }
  return rval;
d667 1
a667 1
  int n = 31;
d669 6
a674 6
  if (!val) return -1;
  if (val & 0x0000FFFF) { val <<= 16; n -= 16; };
  if (val & 0x00FF0000) { val <<= 8;  n -= 8; };
  if (val & 0x0F000000) { val <<= 4;  n -= 4; };
  if (val & 0x30000000) { val <<= 2;  n -= 2; };
  return (val & 0x40000000) ? n-1 : n;
d681 1
a681 1
  int n=0;
d683 6
a688 6
  if (!val) return -1;
  if (val & 0xFFFF0000) { val >>= 16; n += 16; };
  if (val & 0x0000FF00) { val >>= 8;  n += 8; };
  if (val & 0x000000F0) { val >>= 4;  n += 4; };
  if (val & 0x0000000C) { val >>= 2;  n += 2; };
  return (val & 0x00000002) ? n+1 : n;
d695 36
a730 36
  switch (opcode) {
  case AMLOP_ADD:
    return (lhs + rhs);
  case AMLOP_SUBTRACT:
    return (lhs - rhs);
  case AMLOP_MULTIPLY:
    return (lhs * rhs);
  case AMLOP_DIVIDE:
    return (lhs / rhs);
  case AMLOP_MOD:
    return (lhs % rhs);
  case AMLOP_SHL:
    return (lhs << rhs);
  case AMLOP_SHR:
    return (lhs >> rhs);
  case AMLOP_AND:
    return (lhs & rhs);
  case AMLOP_NAND:
    return ~(lhs & rhs);
  case AMLOP_OR:
    return (lhs | rhs); 
  case AMLOP_NOR:
    return ~(lhs | rhs); 
  case AMLOP_XOR:
    return (lhs ^ rhs);
  case AMLOP_INCREMENT:
    return (lhs + 1);
  case AMLOP_DECREMENT:
    return (lhs - 1);
  case AMLOP_FINDSETLEFTBIT:
    return aml_msb(lhs);
  case AMLOP_FINDSETRIGHTBIT:
    return aml_lsb(lhs);
  case AMLOP_NOT:
    return ~(lhs);
  }
d732 1
a732 1
  return (0);
d738 1
a738 1
  return (0);
d745 21
a765 21
  switch(opcode) {
  case AMLOP_LAND:
    return (lhs && rhs);
  case AMLOP_LOR:
    return (lhs || rhs);
  case AMLOP_LNOT:
    return (!lhs);
  case AMLOP_LNOTEQUAL:
    return (lhs != rhs);
  case AMLOP_LLESSEQUAL:
    return (lhs <= rhs);
  case AMLOP_LGREATEREQUAL:
    return (lhs >= rhs);
  case AMLOP_LEQUAL:
    return (lhs == rhs);
  case AMLOP_LGREATER:
    return (lhs > rhs);
  case AMLOP_LLESS:
    return (lhs < rhs);
  }
  return 0;
d776 2
a777 2
  u_int16_t twocode;
  u_int16_t opcode;
d779 7
a785 16
  /* Check for encoded name */
  if (aml_isnamedop(*ctx->pos)) {
    return AMLOP_NAMECHAR;
  }

  opcode  = aml_parseint(ctx, 1);
  twocode = (opcode << 8L) + *ctx->pos;

  /* Check multi-byte opcodes */
  if (twocode == AMLOP_LNOTEQUAL ||
      twocode == AMLOP_LLESSEQUAL ||
      twocode == AMLOP_LGREATEREQUAL ||
      opcode == AMLOP_EXTPREFIX) {
    ctx->pos++;
    return twocode;
  }
d787 10
a796 1
  return opcode;
d800 115
a914 115
  /* Simple types */
  { AMLOP_ZERO,             "Zero",            "!"  },
  { AMLOP_ONE,              "One",             "!"  },
  { AMLOP_ONES,             "Ones",            "!"  },
  { AMLOP_BYTEPREFIX,       "Byte",            "b"  },
  { AMLOP_WORDPREFIX,       "Word",            "w"  },
  { AMLOP_DWORDPREFIX,      "DWord",           "d"  },
  { AMLOP_QWORDPREFIX,      "QWord",           "q"  },
  { AMLOP_REVISION,         "Revision",        ""   },
  { AMLOP_STRINGPREFIX,     "String",          "s"  },
  { AMLOP_DEBUG,            "DebugOp",         "",  },
  { AMLOP_BUFFER,           "Buffer",          "piB" },
  { AMLOP_PACKAGE,          "Package",         "pbT" },
  { AMLOP_VARPACKAGE,       "VarPackage",      "piT" },

  /* Simple objects */
  { AMLOP_LOCAL0,           "Local0",          "",    },
  { AMLOP_LOCAL1,           "Local1",          "",    },
  { AMLOP_LOCAL2,           "Local2",          "",    },
  { AMLOP_LOCAL3,           "Local3",          "",    },
  { AMLOP_LOCAL4,           "Local4",          "",    },
  { AMLOP_LOCAL5,           "Local5",          "",    },
  { AMLOP_LOCAL6,           "Local6",          "",    },
  { AMLOP_LOCAL7,           "Local7",          "",    },
  { AMLOP_ARG0,             "Arg0",            "",    },
  { AMLOP_ARG1,             "Arg1",            "",    },
  { AMLOP_ARG2,             "Arg2",            "",    },
  { AMLOP_ARG3,             "Arg3",            "",    },
  { AMLOP_ARG4,             "Arg4",            "",    },
  { AMLOP_ARG5,             "Arg5",            "",    },
  { AMLOP_ARG6,             "Arg6",            "",    },

  /* Control flow */
  { AMLOP_IF,               "If",              "piT",  },
  { AMLOP_ELSE,             "Else",            "pT",   },
  { AMLOP_WHILE,            "While",           "piT",  },
  { AMLOP_BREAK,            "Break",           "",     },
  { AMLOP_CONTINUE,         "Continue",        "",     },
  { AMLOP_RETURN,           "Return",          "t",     },
  { AMLOP_FATAL,            "Fatal",           "bdi", },
  { AMLOP_NOP,              "Nop",             "",    },
  { AMLOP_BREAKPOINT,       "BreakPoint",      "",    },

  /* Arithmetic operations */
  { AMLOP_INCREMENT,        "Increment",       "t",     },
  { AMLOP_DECREMENT,        "Decrement",       "t",     },
  { AMLOP_ADD,              "Add",             "iit",   },
  { AMLOP_SUBTRACT,         "Subtract",        "iit",   },
  { AMLOP_MULTIPLY,         "Multiply",        "iit",   },
  { AMLOP_DIVIDE,           "Divide",          "iitt",  },
  { AMLOP_SHL,              "ShiftLeft",       "iit",   },
  { AMLOP_SHR,              "ShiftRight",      "iit",   },
  { AMLOP_AND,              "And",             "iit",   },
  { AMLOP_NAND,             "Nand",            "iit",   },
  { AMLOP_OR,               "Or",              "iit",   },
  { AMLOP_NOR,              "Nor",             "iit",   },
  { AMLOP_XOR,              "Xor",             "iit",   },
  { AMLOP_NOT,              "Not",             "it",    },
  { AMLOP_MOD,              "Mod",             "iit",   },
  { AMLOP_FINDSETLEFTBIT,   "FindSetLeftBit",  "it",    },
  { AMLOP_FINDSETRIGHTBIT,  "FindSetRightBit", "it",    },

  /* Logical test operations */
  { AMLOP_LAND,             "LAnd",            "ii",    },
  { AMLOP_LOR,              "LOr",             "ii",    },
  { AMLOP_LNOT,             "LNot",            "i",     },
  { AMLOP_LNOTEQUAL,        "LNotEqual",       "tt",    },
  { AMLOP_LLESSEQUAL,       "LLessEqual",      "tt",    },
  { AMLOP_LGREATEREQUAL,    "LGreaterEqual",   "tt",    },
  { AMLOP_LEQUAL,           "LEqual",          "tt",    },
  { AMLOP_LGREATER,         "LGreater",        "tt",    },
  { AMLOP_LLESS,            "LLess",           "tt",    },

  /* Named objects */
  { AMLOP_NAMECHAR,         "NameRef",         "n" },
  { AMLOP_ALIAS,            "Alias",           "nN",  },
  { AMLOP_NAME,             "Name",            "Nt",  },
  { AMLOP_EVENT,            "Event",           "N",   },
  { AMLOP_MUTEX,            "Mutex",           "Nb",  },
  { AMLOP_DATAREGION,       "DataRegion",      "Nttt" },
  { AMLOP_OPREGION,         "OpRegion",        "Nbii" },
  { AMLOP_SCOPE,            "Scope",           "pNT" },
  { AMLOP_DEVICE,           "Device",          "pNT" },
  { AMLOP_POWERRSRC,        "Power Resource",  "pNbwT" },
  { AMLOP_THERMALZONE,      "ThermalZone",     "pNT" },
  { AMLOP_PROCESSOR,        "Processor",       "pNbdbT", },
  { AMLOP_METHOD,           "Method",          "pNfM",  },

  /* Field operations */
  { AMLOP_FIELD,            "Field",           "pnfF" },
  { AMLOP_INDEXFIELD,       "IndexField",      "pntfF" },
  { AMLOP_BANKFIELD,        "BankField",       "pnnifF" },
  { AMLOP_CREATEFIELD,      "CreateField",     "tiiN",   },
  { AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",    },
  { AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",    },
  { AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",    },
  { AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",    },
  { AMLOP_CREATEBITFIELD,   "CreateBitField",  "tiN",    },

  /* Conversion operations */
  { AMLOP_TOINTEGER,        "ToInteger",       "tt",     },
  { AMLOP_TOBUFFER,         "ToBuffer",        "tt",     },
  { AMLOP_TODECSTRING,      "ToDecString",     "it",     },
  { AMLOP_TOHEXSTRING,      "ToHexString",     "it",     }, 
  { AMLOP_TOSTRING,         "ToString",        "t",      },
  { AMLOP_FROMBCD,          "FromBCD",         "it",     },
  { AMLOP_TOBCD,            "ToBCD",           "it",     },
  { AMLOP_MID,              "Mid",             "tiit",   },

  /* Mutex/Signal operations */
  { AMLOP_ACQUIRE,          "Acquire",         "tw",     },
  { AMLOP_RELEASE,          "Release",         "t",      },
  { AMLOP_SIGNAL,           "Signal",          "t",      },
  { AMLOP_WAIT,             "Wait",            "ti",     },
  { AMLOP_RESET,            "Reset",           "t",      },
d916 19
a934 19
  { AMLOP_INDEX,            "Index",           "tit",    },
  { AMLOP_DEREFOF,          "DerefOf",         "t",      },
  { AMLOP_REFOF,            "RefOf",           "t",      },
  { AMLOP_CONDREFOF,        "CondRef",         "tt",     },

  { AMLOP_LOADTABLE,        "LoadTable",       "tttttt" },
  { AMLOP_STALL,            "Stall",           "i",      },
  { AMLOP_SLEEP,            "Sleep",           "i",      },
  { AMLOP_LOAD,             "Load",            "nt" },
  { AMLOP_UNLOAD,           "Unload",          "t" }, 
  { AMLOP_STORE,            "Store",           "tt",     },
  { AMLOP_CONCAT,           "Concat",          "ttt" },
  { AMLOP_CONCATRES,        "ConcatRes",       "ttt" },
  { AMLOP_NOTIFY,           "Notify",          "ti" },
  { AMLOP_SIZEOF,           "Sizeof",          "t",      },
  { AMLOP_MATCH,            "Match",           "tbibii", },
  { AMLOP_OBJECTTYPE,       "ObjectType",      "t", },
  { AMLOP_COPYOBJECT,       "CopyObject",      "tt" },
  { 0xFFFF }
d942 2
a943 2
  dst->type   = src->type;
  dst->length = src->length;
d945 14
a958 14
  switch (dst->type) {
  case AML_OBJTYPE_INTEGER:
    dst->v_integer = src->v_integer;
    break;
  case AML_OBJTYPE_STRING:
    dst->v_string = src->v_string;
    break;
  case AML_OBJTYPE_BUFFER:
    dst->v_buffer = src->v_buffer;
    break;
  case AML_OBJTYPE_PACKAGE:
    dst->v_package = src->v_package;
    break;
  }
a961 2
struct aml_node *childOf(struct aml_node *, int);

d965 1
a965 1
  struct aml_node *node = parent->child;
d967 4
a970 4
  while(node && child--) {
    node = node->sibling;
  }
  return node;
d982 1
a982 1
  int id;
d984 44
a1027 44
  if (node == NULL) {
    printf("aml_getnodevalue: null\n");
    return NULL;
  }
  switch (node->opcode) {
  case AMLOP_DEBUG:
    return &aml_debugobj;

  case AMLOP_LOCAL0:
  case AMLOP_LOCAL1:
  case AMLOP_LOCAL2:
  case AMLOP_LOCAL3:
  case AMLOP_LOCAL4:
  case AMLOP_LOCAL5:
  case AMLOP_LOCAL6:
  case AMLOP_LOCAL7:
    id = node->opcode - AMLOP_LOCAL0;
    return &env->v_method.locals[id];

  case AMLOP_ARG0:
  case AMLOP_ARG1:
  case AMLOP_ARG2:
  case AMLOP_ARG3:
  case AMLOP_ARG4:
  case AMLOP_ARG5:
  case AMLOP_ARG6:
    id = node->opcode - AMLOP_ARG0;
    return &env->v_method.args[id];

  case AMLOP_ZERO:
  case AMLOP_ONE:
  case AMLOP_ONES:
  case AMLOP_BYTEPREFIX:
  case AMLOP_WORDPREFIX:
  case AMLOP_DWORDPREFIX:
  case AMLOP_QWORDPREFIX:
  case AMLOP_STRINGPREFIX:
    return node->value;

  default:
    printf("aml_getnodevalue: no type: %.4x\n", node->opcode);
    break;
  }
  return NULL;
d1034 67
a1100 67
  struct aml_value *dest = NULL;
  struct aml_value  lhs;
  int id;

  if (node == NULL) {
    printf("aml_setnodevalue: null\n");
    return;
  }
  dnprintf(50, "--- setnodevalue:\n");
  aml_shownode(node);
  aml_showvalue((struct aml_value *)val);
  switch (node->opcode) {
  case AMLOP_DEBUG:
    dest = &aml_debugobj;
    break;

  case AMLOP_LOCAL0:
  case AMLOP_LOCAL1:
  case AMLOP_LOCAL2:
  case AMLOP_LOCAL3:
  case AMLOP_LOCAL4:
  case AMLOP_LOCAL5:
  case AMLOP_LOCAL6:
  case AMLOP_LOCAL7:
    id = node->opcode - AMLOP_LOCAL0;
    dest = &env->v_method.locals[id];
    break;

  case AMLOP_ARG0:
  case AMLOP_ARG1:
  case AMLOP_ARG2:
  case AMLOP_ARG3:
  case AMLOP_ARG4:
  case AMLOP_ARG5:
  case AMLOP_ARG6:
    id = node->opcode - AMLOP_ARG0;
    dest = &env->v_method.args[id];
    break;

  case AMLOP_NAMECHAR:
    return aml_setnodevalue(sc, aml_find_name(sc, NULL, node->name), val, env);

  case AMLOP_CREATEFIELD:
  case AMLOP_CREATEBITFIELD:
  case AMLOP_CREATEBYTEFIELD:
  case AMLOP_CREATEWORDFIELD:
  case AMLOP_CREATEDWORDFIELD:
  case AMLOP_CREATEQWORDFIELD:
    aml_eval_object(sc, node, &lhs, env);
    aml_showvalue(&lhs);
    for(;;);
    break;

  case AMLOP_ZERO:
  case AMLOP_ONE:
  case AMLOP_ONES:
  case AMLOP_REVISION:
  case AMLOP_BYTEPREFIX:
  case AMLOP_WORDPREFIX:
  case AMLOP_DWORDPREFIX:
  case AMLOP_QWORDPREFIX:
  default:
    printf("aml_setnodeval: read-only %.4x\n", node->opcode);
    break;
  }
  if (dest) {
    dnprintf(50, "aml_setnodeval: %.4x\n", node->opcode);
d1102 2
a1103 2
    xxx
      aml_copyvalue(dest, val);
d1105 1
a1105 1
  }
d1112 1
a1112 1
  struct aml_value ival;
d1114 2
a1115 2
  aml_setinteger(&ival, value);
  aml_setnodevalue(sc, node, &ival, env);
d1121 10
a1130 10
  /* ASSERT: lhs and rhs are of same type */
  switch (lhs->type) {
  case AML_OBJTYPE_INTEGER:
    return (lhs->v_integer - rhs->v_integer);
  case AML_OBJTYPE_STRING:
    return strcmp(lhs->v_string, rhs->v_string);
  default:
    printf("Unknown compare type for cmpobj\n");
    break;
  }
d1132 1
a1132 1
  return (0);
d1139 1
a1139 1
  int rc;
d1141 2
a1142 2
  if (mtype == AML_MATCH_TR)
    return (1);
d1144 2
a1145 2
  if (lhs->type != rhs->type)
    return (0);
d1147 13
a1159 13
  rc = aml_cmpobj(sc, lhs, rhs);
  switch (mtype) {
  case AML_MATCH_EQ:
    return (rc == 0);
  case AML_MATCH_LT:
    return (rc < 0);
  case AML_MATCH_LE:
    return (rc <= 0);
  case AML_MATCH_GE:
    return (rc >= 0);
  case AML_MATCH_GT:
    return (rc > 0);
  }
d1161 1
a1161 1
  return (0);
d1167 1
a1167 1
  struct aml_node *node;
d1169 2
a1170 2
  node = acpi_os_allocmem(sizeof(struct aml_node));
  memset(node, 0, sizeof(struct aml_node));
d1172 3
a1174 3
  node->start  = ctx->pos;
  node->opcode = (opcode == -1) ? aml_getopcode(ctx) : opcode;
  aml_addchildnode(parent, node);
d1176 1
a1176 1
  return node;
d1182 1
a1182 1
  struct  aml_value ival;
d1184 3
a1186 3
  aml_eval_object(sc, node, &ival, env);
  if (ival.type == AML_OBJTYPE_INTEGER)
    return ival.v_integer;
d1188 1
a1188 1
  return (0);
d1194 13
a1206 2
  struct aml_node *ret;
  const char *sname;
d1208 14
a1221 25
  if (*name == AMLOP_ROOTCHAR) {
    root = &aml_root;
    name++;
  }
  while (*name == AMLOP_PARENTPREFIX) {
    if (root) root = root->parent;
    name++;
  }
  if (root == NULL)
    root = &aml_root;

  for (ret=NULL; root && !ret; root = root->sibling) {
    if ((sname = root->name) != NULL) {
      if (*sname == AMLOP_ROOTCHAR) 
	sname++;
      while (*sname == AMLOP_PARENTPREFIX) 
	sname++;
      if (!strcmp(name, sname)) {
	return root;
      }
    }
    if (root->child)
      ret = aml_find_name(sc, root->child, name);
  }
  return ret;
d1228 132
a1359 1
  root = aml_find_name(sc, root, name);
d1361 136
a1496 5
  if (root != NULL) {
    dnprintf(50, "found eval object : %s, %.4x\n", root->name, root->opcode);
    return aml_eval_object(sc, root, result, env);
  }
  return (1);
d1503 1
a1503 1
  memset(result, 0, sizeof(struct aml_value));
d1505 24
a1528 24
  xxx
    struct  aml_value lhs, rhs, tmp, pkg;
  struct aml_value *px;
  int64_t iresult, id, idx;
  struct  aml_node *cflow = NULL;
  int     i1, i2, i3;
  char   *tmpstr;

  if (node == NULL) 
    return (-1);

  dnprintf(50, "--- Evaluating object:\n"); 
  aml_shownode(node);

  switch (node->opcode) {
  case AMLOP_ZERO:
  case AMLOP_ONE:
  case AMLOP_ONES:
  case AMLOP_BYTEPREFIX:
  case AMLOP_WORDPREFIX:
  case AMLOP_DWORDPREFIX:
  case AMLOP_QWORDPREFIX:
  case AMLOP_STRINGPREFIX:
  case AMLOP_REVISION:
d1530 1
a1530 1
    aml_copyvalue(result, &node->value);
d1532 1
a1532 1
    break;
d1534 9
a1542 9
  case AMLOP_BUFFER:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    dnprintf(50, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@ buffer: %.4x %.4x\n", i1, node->value->length);
    break;

  case AMLOP_STORE:
    aml_eval_object(sc, childOf(node, 0), &lhs, env);
    aml_setnodevalue(sc, childOf(node, 1), &lhs, env);
    break;
d1544 1
a1544 1
  case AMLOP_DEBUG:
d1546 1
a1546 1
    aml_copyvalue(result, &aml_debugobj);
d1548 1
a1548 1
    break;
d1550 55
a1604 55
  case AMLOP_NAME:
  case AMLOP_ALIAS:
    return aml_eval_object(sc, childOf(node, 0), result, env);

  case AMLOP_PROCESSOR:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    i2 = aml_evalint(sc, childOf(node, 1), env);
    i3 = aml_evalint(sc, childOf(node, 2), env);
    aml_setprocessor(result, i1, i2, i3);
    break;

  case AMLOP_OPREGION:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    i2 = aml_evalint(sc, childOf(node, 1), env);
    aml_setopregion(result, node->flag, i1, i2);
    break;

  case AMLOP_IF:
    i1 = aml_evalint(sc, childOf(node,0), env);
    if (i1 != 0) {
      /* Test true, select 'If' block */
      cflow = childOf(node, 1);
    }
    else if (node->sibling->opcode == AMLOP_ELSE) {
      /* Test false, select 'Else' block */
      cflow = node->sibling->child;
    }
    while (cflow) {
      /* Execute all instructions in scope block */
      aml_eval_object(sc, cflow, result, env);
      cflow = cflow->sibling;
    }
    break;

  case AMLOP_WHILE:
    for (;;) {
      if (cflow == NULL) {
	/* Perform While test */
	cflow = childOf(node, 1);
	i1 = aml_evalint(sc, childOf(node, 0), env);
	if (i1 == 0) 
	  break;
      }
      else if (cflow->opcode == AMLOP_BREAK) 
	break;
      else if (cflow->opcode == AMLOP_CONTINUE)
	/* Reset cflow to NULL; restart block */
	cflow = NULL;
      else {
	/* Execute all instructions in scope block */
	aml_eval_object(sc, cflow, result, env);
	cflow = cflow->sibling;
      }
    }
    break;
d1606 12
a1617 12
  case AMLOP_RETURN:
    aml_eval_object(sc, childOf(node, 0), result, env);
    break;

  case AMLOP_ARG0:
  case AMLOP_ARG1:
  case AMLOP_ARG2:
  case AMLOP_ARG3:
  case AMLOP_ARG4:
  case AMLOP_ARG5:
  case AMLOP_ARG6:
    id = node->opcode - AMLOP_ARG0;
d1619 2
a1620 2
    if (id < env->length)
      aml_copyvalue(result, &node->value->v_method.locals[id]);
d1622 1
a1622 1
    break;
d1624 9
a1632 9
  case AMLOP_LOCAL0:
  case AMLOP_LOCAL1:
  case AMLOP_LOCAL2:
  case AMLOP_LOCAL3:
  case AMLOP_LOCAL4:
  case AMLOP_LOCAL5:
  case AMLOP_LOCAL6:
  case AMLOP_LOCAL7:
    id = node->opcode - AMLOP_LOCAL0;
d1634 1
a1634 1
    aml_copyvalue(result, &env->v_method.locals[id]);
d1636 1
a1636 1
    break;
d1638 12
a1649 12
  case AMLOP_PACKAGE:
  case AMLOP_VARPACKAGE:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    dnprintf(50, "package = %d\n", i1);
    result->type = AML_OBJTYPE_PACKAGE;
    result->length = i1;

    result->v_package = acpi_os_allocmem(i1 * sizeof(struct aml_value));
    for (i2=0; i2<i1; i2++) {
      aml_eval_object(sc, childOf(node, i2+1), result->v_package[i2], env);
    }
    break;
d1651 108
a1758 108
  case AMLOP_INCREMENT:
  case AMLOP_DECREMENT:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    iresult = aml_evalmath(node->opcode, i1, 0);
    aml_setnodeinteger(sc, childOf(node, 0), iresult, env);
    break;

  case AMLOP_NOT:
  case AMLOP_FINDSETLEFTBIT:
  case AMLOP_FINDSETRIGHTBIT:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    iresult = aml_evalmath(node->opcode, i1, 0);
    aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
    break;

  case AMLOP_DIVIDE:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    i2 = aml_evalint(sc, childOf(node, 1), env);

    /* Set remainder */
    iresult = aml_evalmath(AMLOP_MOD,    i1, i2);
    aml_setnodeinteger(sc, childOf(node, 2), iresult, env);

    /* Set quotient */
    iresult = aml_evalmath(node->opcode, i1, i2);
    aml_setnodeinteger(sc, childOf(node, 3), iresult, env);
    break;

  case AMLOP_ADD:
  case AMLOP_SUBTRACT:
  case AMLOP_MULTIPLY:
  case AMLOP_SHL:
  case AMLOP_SHR:
  case AMLOP_AND:
  case AMLOP_NAND:
  case AMLOP_OR:
  case AMLOP_NOR:
  case AMLOP_XOR:
  case AMLOP_MOD:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    i2 = aml_evalint(sc, childOf(node, 1), env);

    iresult = aml_evalmath(node->opcode, i1, i2);
    aml_setnodeinteger(sc, childOf(node, 2), iresult, env);
    break;

  case AMLOP_LNOT:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    iresult = aml_testlogical(node->opcode, i1, 0);
    aml_setinteger(result, iresult);
    break;

  case AMLOP_LAND:
  case AMLOP_LOR:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    i2 = aml_evalint(sc, childOf(node, 1), env);
    iresult = aml_testlogical(node->opcode, i1, i2);
    aml_setinteger(result, iresult);
    break;

  case AMLOP_LEQUAL:
  case AMLOP_LNOTEQUAL:
  case AMLOP_LLESSEQUAL:
  case AMLOP_LGREATEREQUAL:
  case AMLOP_LGREATER:
  case AMLOP_LLESS:
    aml_eval_object(sc, childOf(node, 0), &lhs, env);
    aml_eval_object(sc, childOf(node, 1), &rhs, env);
    if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
      iresult = aml_testlogical(node->opcode, lhs.v_integer, rhs.v_integer);
    }
    else if (lhs.type == AML_OBJTYPE_STRING && rhs.type == AML_OBJTYPE_STRING) {
      iresult = aml_strcmp(node->opcode, lhs.v_string, rhs.v_string);
    }
    aml_setinteger(result, iresult);
    break;

  case AMLOP_CREATEFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    i2 = aml_evalint(sc, childOf(node, 2), env);
    aml_setfield(&lhs, i1, i2, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 3), &lhs, env);
    break;
  case AMLOP_CREATEBITFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_setfield(&lhs, i1, 1, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
    break;
  case AMLOP_CREATEBYTEFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_setfield(&lhs, i1 * 8, 8, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
    break;
  case AMLOP_CREATEWORDFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_setfield(&lhs, i1 * 8, 16, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
    break;
  case AMLOP_CREATEDWORDFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_setfield(&lhs, i1 * 8, 32, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
    break;
  case AMLOP_CREATEQWORDFIELD:
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_setfield(&lhs, i1 * 8, 64, childOf(node, 0), node);
    aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
    break;
d1760 119
a1878 119
  case AMLOP_TOBCD:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    iresult = aml_dec2bcd(i1);
    aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
    break;
  case AMLOP_FROMBCD:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    iresult = aml_bcd2dec(i1);
    aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
    break;
  case AMLOP_TODECSTRING:
    tmpstr = acpi_os_allocmem(AML_INTSTRLEN+1);
    if (tmpstr != NULL) {
      aml_eval_object(sc, childOf(node, 0), &lhs, env);
      if (lhs.type == AML_OBJTYPE_INTEGER) 
	snprintf(tmpstr, AML_INTSTRLEN, "%d", lhs.v_integer);
    }
    break;
  case AMLOP_TOHEXSTRING:
    tmpstr = acpi_os_allocmem(AML_INTSTRLEN+1);
    if (tmpstr != NULL) {
      aml_eval_object(sc, childOf(node, 0), &lhs, env);
      if (lhs.type == AML_OBJTYPE_INTEGER) 
	snprintf(tmpstr, AML_INTSTRLEN, "%x", lhs.v_integer);
    }
    break;

  case AMLOP_MID:
    aml_eval_object(sc, childOf(node, 0), &tmp, env);
    aml_eval_object(sc, childOf(node, 1), &lhs, env);
    aml_eval_object(sc, childOf(node, 2), &rhs, env);
    if (tmp.type != AML_OBJTYPE_STRING) 
      return (-1);

    tmpstr = acpi_os_allocmem(rhs.v_integer+1);
    if (tmpstr != NULL) {
      strncpy(tmpstr, tmp.v_string + lhs.v_integer, rhs.v_integer);
    }
    break;

  case AMLOP_STALL:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    dnprintf(50, "aml_stall: %d\n", i1);
    break;
  case AMLOP_SLEEP:
    i1 = aml_evalint(sc, childOf(node, 0), env);
    dnprintf(50, "aml_sleep: %d\n", i1);
    break;
  case AMLOP_OBJECTTYPE:
    aml_eval_object(sc, childOf(node, 0), &lhs, env);
    aml_setinteger(result, lhs.type);
    break;

  case AMLOP_NAMECHAR: /* Inline method call */
    aml_eval_name(sc, NULL, node->name, result, env);
    break;

  case AMLOP_METHOD:
    dnprintf(50, "eval-method : %s  argcount:%d\n", 
	     node->name, AML_METHOD_ARGCOUNT(node->flag));

    lhs.type = AML_OBJTYPE_METHOD;
    lhs.length = AML_METHOD_ARGCOUNT(node->flag);
    if (lhs.length > 0) {
      lhs.v_method.args = acpi_os_allocmem(lhs.length * sizeof(struct aml_value));
      memset(lhs.v_method.args, 0, lhs.length * sizeof(struct aml_value));
    }
    lhs.v_method.locals = acpi_os_allocmem(8 * sizeof(struct aml_value));

    for (i1=0; i1<lhs.length; i1++) {
      dnprintf(50, " evalmeth: %s:%d\n", node->name, i1);
      aml_eval_object(sc, childOf(node, i1), &lhs.v_method.args[i1], env);
      aml_showvalue(&lhs.v_method.args[i1]);
    }
    while (childOf(node, i1)) {
      aml_eval_object(sc, childOf(node, i1++), result, &lhs);
    }
    break;

  case AMLOP_CONCAT:
    aml_eval_object(sc, childOf(node, 0), &lhs, env);
    aml_eval_object(sc, childOf(node, 1), &rhs, env);
    break;

  case AMLOP_NOP:
    break;

  case AMLOP_SIZEOF:
    aml_eval_object(sc, childOf(node, 0), &lhs, env);
    px = aml_getnodevalue(sc, childOf(node, 0), env);
    aml_showvalue(px);
    for(;;);
    break;

  case AMLOP_MATCH:
    aml_eval_object(sc, childOf(node, 0), &pkg, env);
    i1 = aml_evalint(sc, childOf(node, 1), env);
    aml_eval_object(sc, childOf(node, 2), &lhs, env);
    i2 = aml_evalint(sc, childOf(node, 3), env);
    aml_eval_object(sc, childOf(node, 4), &lhs, env);
    idx = aml_evalint(sc, childOf(node, 5), env);
    if (pkg.type == AML_OBJTYPE_PACKAGE) {
      iresult = -1;
      while (idx < pkg.length) {
	if (aml_match(sc, i1, &pkg.v_package[idx], &lhs) ||
	    aml_match(sc, i2, &pkg.v_package[idx], &rhs)) {
	  iresult = idx;
	  break;
	}
	idx++;
      }
      aml_setinteger(result, iresult);
    }
    break;

  default:
    printf("Unknown eval: %.4x %s\n", node->opcode, node->mnem);
    break;
  }
d1880 1
a1880 1
  return (0);
d1886 1
a1886 1
  struct aml_node *pnode;
d1888 97
a1984 97
  while (*arg) {
    pnode = node;
    switch (*arg) {
    case AML_ARG_FLAG:
      node->flag = aml_parseint(ctx, 1);
      if (node->opcode == AMLOP_METHOD) {
	dnprintf(50, " method %s %.2x argcount:%d serialized:%d synclevel:%d\n",
		 node->name, node->flag,
		 AML_METHOD_ARGCOUNT(node->flag),
		 AML_METHOD_SERIALIZED(node->flag),
		 AML_METHOD_SYNCLEVEL(node->flag));
      }
      else {
	dnprintf(50, " field %s %.2x access:%d lock:%d update:%d\n",
		 node->name, node->flag,
		 AML_FIELD_ACCESS(node->flag),
		 AML_FIELD_LOCK(node->flag),
		 AML_FIELD_UPDATE(node->flag));
      }
      break;
    case AML_ARG_IMPBYTE:
      /* Implied byte: same as opcode */
      node->value = aml_allocint((char)node->opcode);
      dnprintf(50, " ibyte: %x\n", (int8_t)node->opcode);
      break;
    case AML_ARG_BYTE:
      if (node->opcode != AMLOP_BYTEPREFIX) {
	pnode = aml_create_node(ctx, node, AMLOP_BYTEPREFIX);
      }
      pnode->value = aml_allocint(aml_parseint(ctx, 1));
      dnprintf(50, " byte: %x\n", pnode->value->v_integer);
      break;
    case AML_ARG_WORD:
      if (node->opcode != AMLOP_WORDPREFIX) {
	pnode = aml_create_node(ctx, node, AMLOP_WORDPREFIX);
      }
      pnode->value = aml_allocint(aml_parseint(ctx, 2));
      dnprintf(50, " word: %x\n", pnode->value->v_integer);
      break;
    case AML_ARG_DWORD:
      if (node->opcode != AMLOP_DWORDPREFIX) {
	pnode = aml_create_node(ctx, node, AMLOP_DWORDPREFIX);
      }
      pnode->value = aml_allocint(aml_parseint(ctx, 4));
      dnprintf(50, " dword: %x\n", pnode->value->v_integer);
      break;
    case AML_ARG_QWORD:
      if (node->opcode == AMLOP_QWORDPREFIX) {
	pnode = aml_create_node(ctx, node, AMLOP_QWORDPREFIX);
      }
      pnode->value = aml_allocint(aml_parseint(ctx, 8));
      dnprintf(50, " qword: %x\n", pnode->value->v_integer);	
      break;
    case AML_ARG_FIELDLIST:
      dnprintf(50, " fieldlist\n");
      aml_parsefieldlist(ctx, node);
      break;
    case AML_ARG_BYTELIST:
      dnprintf(50, " bytelist\n");
      node->start = ctx->pos;
      ctx->pos    = node->end;
      break;
    case AML_ARG_STRING:
      node->value = aml_allocstr(aml_parsestr(ctx));
      dnprintf(50, " string: %s\n", node->value->v_string);
      break;
    case AML_ARG_NAMESTRING:
      node->name = aml_parsename(ctx, "name");
      break;
    case AML_ARG_NAMEREF:
      pnode = aml_create_node(ctx, node, AMLOP_NAMECHAR);
      pnode->name = aml_parsename(ctx, "nameref");
      break;
    case AML_ARG_OBJLEN:
      dnprintf(50, " pkglen\n");
      node->end = ctx->pos;
      node->end += aml_parselength(ctx);
      break;
    case AML_ARG_METHOD:
      dnprintf(50, " method\n");
      node->start = ctx->pos;
      ctx->pos = node->end;
      break;
    case AML_ARG_INTEGER:
    case AML_ARG_TERMOBJ:
      /* Recursively parse children */
      aml_parse_object(ctx, node);
      break;
    case AML_ARG_TERMOBJLIST:
      /* Recursively parse children */
      aml_parse_objlist(ctx, node);
      break;

    default:
      printf("Unknown arg: %c\n", *arg);
      break;
    }
d1986 2
a1987 2
    arg++;
  }
d1989 1
a1989 1
  return (0);
d1995 1
a1995 1
  struct aml_node *psib;
d1997 109
a2105 9
  child->parent = parent;
  child->sibling = NULL;
  for (psib = parent->child; psib; psib = psib->sibling) {
    if (psib->sibling == NULL) {
      psib->sibling = child;
      return;
    }
  }
  parent->child = child;
d2111 1
a2111 1
  int idx;
d2113 26
a2138 26
  if (value == NULL)
    return;
  switch (value->type) {
  case AML_OBJTYPE_INTEGER:
    dnprintf(50, "integer: %x\n", value->v_integer);
    break;
  case AML_OBJTYPE_STRING:
    dnprintf(50, "string: %s\n", value->v_string);
    break;
  case AML_OBJTYPE_BUFFER:
    dnprintf(50, "buffer: %d {\n", value->length);
    for (idx=0; idx<value->length; idx++) {
      dnprintf(50, "%s0x%.2x", (idx ? "," : ""), value->v_buffer[idx]);
    }
    dnprintf(50, "}\n");
    break;
  case AML_OBJTYPE_PACKAGE:
    dnprintf(50, "package: %d {\n", value->length);
    for (idx=0; idx<value->length; idx++)
      aml_showvalue(value->v_package[idx]);
    dnprintf(50, "}\n");
    break;
  case AML_OBJTYPE_DEBUGOBJ:
    dnprintf(50, "debug");
    break;
  case AML_OBJTYPE_DEVICE:
d2140 2
a2141 2
    xxx
      dnprintf(50, "device: %s", val->v_device->name);
d2143 29
a2171 29
    break;
  case AML_OBJTYPE_PROCESSOR:
    dnprintf(50, "cpu: %x,%x,%x\n",
	     value->v_processor.proc_id,
	     value->v_processor.proc_addr,
	     value->v_processor.proc_len);
    break;
  case AML_OBJTYPE_FIELDUNIT:
    dnprintf(50, "field: %.4x %x,%x\n",
	     value->v_field.ftype,
	     value->v_field.bitpos,
	     value->v_field.bitlen);
    break;
  case AML_OBJTYPE_BUFFERFIELD:
    dnprintf(50, "bufferfield: %.4x %x,%x\n", 
	     value->v_field.ftype,
	     value->v_field.bitpos,
	     value->v_field.bitlen);
    break;
  case AML_OBJTYPE_OPREGION:
    dnprintf(50, "opregion: %s,0x%x,0x%x\n",
	     opregion(value->v_opregion.iospace),
	     value->v_opregion.iobase,
	     value->v_opregion.iolen);
    break;
  default:
    printf("unknown: %d\n", value->type);
    break;
  }
d2177 19
a2195 19
  dnprintf(50, " opcode:%.4x  mnem:%s %s %.2x ",
	   node->opcode, node->mnem ? node->mnem : "", 
	   node->name ? node->name : "",
	   node->flag);
  switch(node->opcode) {
  case AMLOP_METHOD:
    dnprintf(50, "argcount:%d serialized:%d synclevel:%d",
	     AML_METHOD_ARGCOUNT(node->flag),
	     AML_METHOD_SERIALIZED(node->flag),
	     AML_METHOD_SYNCLEVEL(node->flag));
    break;
  case AMLOP_FIELD:
  case AMLOP_BANKFIELD:
  case AMLOP_INDEXFIELD:
    dnprintf(50, "access:%d lock:%d update:%d\n",
	     AML_FIELD_ACCESS(node->flag),
	     AML_FIELD_LOCK(node->flag),
	     AML_FIELD_UPDATE(node->flag));
    break;
d2197 14
a2210 14
  case AMLOP_BYTEPREFIX:
    dnprintf(50, "byte: %.2x", node->value->v_integer);
    break;
  case AMLOP_WORDPREFIX:
    dnprintf(50, "word: %.4x", node->value->v_integer);
    break;
  case AMLOP_DWORDPREFIX:
    dnprintf(50, "dword: %.8x", node->value->v_integer);
    break;
  case AMLOP_STRINGPREFIX:
    dnprintf(50, "string: %s", node->value->v_string);
    break;
  }
  dnprintf(50, "\n");
d2216 2
a2217 2
  struct aml_optable *optab = aml_table;
  struct aml_node *node;
d2219 12
a2230 12
  /* Get AML Opcode; if it is an embedded name, extract name */
  node = aml_create_node(ctx, parent, -1);
  while (optab->opcode != 0xFFFF) {
    if  (optab->opcode == node->opcode) {
      node->mnem = optab->mnem;
      aml_parseargs(ctx, node, optab->args);
      return node;
    }
    optab++;
  }
  printf("Invalid AML Opcode : @@ %.4x %.4x\n", ctx->pos - ctx->start, node->opcode);
  acpi_os_freemem(node);
d2232 1
a2232 1
  return NULL;
d2238 1
a2238 1
  int idx;
d2240 9
a2248 9
  while(node) {
    dnprintf(50, " %d ", depth);
    for(idx=0; idx<depth; idx++) {
      dnprintf(50, "..");
    }
    aml_shownode(node);
    aml_walktree(node->child, depth+1);
    node = node->sibling;
  }
d2254 1
a2254 1
  aml_walktree(aml_root.child, 0);
d2262 1
a2262 1
  const char *nn;
d2264 11
a2274 11
  while (node) {
    if ((nn = node->name) != NULL) {
      if (*nn == AMLOP_ROOTCHAR) nn++;
      while (*nn == AMLOP_PARENTPREFIX) nn++;
      if (!strcmp(name, nn))
	cbproc(node, arg);
    }
    aml_find_node(node->child, name, cbproc, arg);
    node = node->sibling;
  }
  return (0);
d2282 1
a2282 1
  static char id[8];
d2284 8
a2291 8
  id[0] = '@@' + ((pid >> 2) & 0x1F);
  id[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
  id[2] = '@@' + ((pid >> 8) & 0x1F);
  id[3] = hext[(pid >> 20) & 0xF];
  id[4] = hext[(pid >> 16) & 0xF];
  id[5] = hext[(pid >> 28) & 0xF];
  id[6] = hext[(pid >> 24) & 0xF];
  id[7] = 0;
d2293 1
a2293 1
  return id;
d2301 2
a2302 2
  struct acpi_softc *sc = arg;
  struct aml_value res, env;
d2304 2
a2305 2
  memset(&res, 0, sizeof(res));
  memset(&env, 0, sizeof(env));
d2307 3
a2309 3
  dnprintf(50, "Value is: %s\n", node->name);
  aml_eval_object(sc, node->child, &res, &env);
  aml_showvalue(&res);
d2315 9
a2323 9
  while (ctx->pos < parent->end) {
    aml_parse_object(ctx, parent);
  }
  if (ctx->pos != parent->end) {
    dnprintf(50, "parseobjlist: invalid end!\n");
    ctx->pos = parent->end;
    return (1);
  }
  return (0);
d2329 1
a2329 1
  struct acpi_context ctx;
d2331 4
a2334 4
  memset(&ctx, 0, sizeof(ctx));
  ctx.pos   = start;
  ctx.start = start;
  ctx.end   = ctx.start + length;
d2336 2
a2337 2
  aml_root.start = start;
  aml_root.end   = start + length;
d2339 2
a2340 2
  aml_parse_objlist(&ctx, &aml_root);
  dnprintf(50, " : parsed %d AML bytes\n", length);
d2342 1
a2342 1
  return (0);
@


1.15
log
@printf -> dnprintf conversion for debug messages.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.14 2006/01/05 22:30:27 grange Exp $ */
d32 3
a34 3
	u_int16_t    opcode;
	const char  *mnem;
	const char  *args;
d39 3
a41 3
	u_int8_t *start;
	u_int8_t *end;
	u_int8_t *pos;
d46 4
a49 4
	struct aml_value   *locals;
	struct aml_value   *args;
	struct aml_value    result;
	struct acpi_stack  *next;
d54 6
a59 2
	struct acpi_softc *sc;
	struct acpi_stack *stack;
d62 19
d82 8
a89 6
void aml_parsefieldlist(struct acpi_softc *sc, struct aml_node *parent);
int aml_parselength(struct acpi_softc *sc);
const char *aml_parsename(struct acpi_softc *sc, const char *);
u_int16_t aml_getopcode(struct acpi_softc *sc);
int aml_parseargs(struct acpi_softc *, struct aml_node *, const char *);
struct aml_node *aml_parse_object(struct acpi_softc *, struct aml_node *);
d100 1
a100 1
struct aml_node *aml_create_node(struct acpi_softc *, struct aml_node *, int opcode);
d109 1
d111 1
d127 24
a150 2
const char *aml_parsestr(struct acpi_softc *);
u_int64_t   aml_parseint(struct acpi_softc *, int);
d154 179
d334 1
a334 1
aml_parsestr(struct acpi_softc *sc)
d336 1
a336 1
	const char *str = sc->amlpc.pos;
d338 2
a339 2
	sc->amlpc.pos += strlen(str)+1;
	return str;
d344 1
a344 1
aml_parseint(struct acpi_softc *sc, int size)
d346 1
a346 1
	u_int8_t *pc = sc->amlpc.pos;
d348 11
a358 11
	sc->amlpc.pos += size;
	switch (size) {
	case 1:
		return *(u_int8_t *)pc;
	case 2:
		return *(u_int16_t *)pc;
	case 4:
		return *(u_int32_t *)pc;
	case 8:
		return *(u_int64_t *)pc;
	}
d360 1
a360 1
	return (0);
d366 3
a368 3
	val->type = AML_OBJTYPE_INTEGER;
	val->v_integer = value;
	val->length = 0;
d374 3
a376 3
	val->type = AML_OBJTYPE_STRING;
	val->length = strlen(str);
	val->v_string = str;
d382 3
a384 3
	val->type = AML_OBJTYPE_STRING;
	val->length = size;
	val->v_buffer = ptr;
d390 6
a395 6
	dnprintf(50, "setfield: pos=%.8x len=%.8x ref=%s name=%s\n", bitpos, bitlen, ref->name, node->name);
	val->type = AML_OBJTYPE_FIELDUNIT;
	val->length = (bitlen + 7) / 8;
	val->v_field.bitpos = bitpos;
	val->v_field.bitlen = bitlen;
	val->v_field.ref = ref;
d406 4
a409 4
	val->type = AML_OBJTYPE_PROCESSOR;
	val->v_processor.proc_id = id;
	val->v_processor.proc_addr = addr;
	val->v_processor.proc_len = len;
d421 5
a425 7
	dnprintf(50, "setopregion: %.2x %.4x %.8x\n", addrtype, size, addr);
	val->type = AML_OBJTYPE_OPREGION;
	val->v_opregion.address_space_id = addrtype;
	val->v_opregion.register_bit_width = 0;
	val->v_opregion.register_bit_offset = 0;
	val->v_opregion.access_size = size;
	val->v_opregion.address = addr;
d436 1
a436 1
aml_parselength(struct acpi_softc *sc)
d438 2
a439 2
	u_int8_t lcode;
	int ival;
d441 9
a449 4
	lcode = aml_parseint(sc, 1);
	if (lcode <= 0x3F) {
		return lcode;
	}
d451 1
a451 6
	ival = lcode & 0xF;
	if (lcode >= 0x40)  ival |= aml_parseint(sc, 1) << 4;
	if (lcode >= 0x80)  ival |= aml_parseint(sc, 1) << 12;
	if (lcode >= 0xC0)  ival |= aml_parseint(sc, 1) << 20;

	return ival;
d455 1
a455 1
aml_parsefieldlist(struct acpi_softc *sc, struct aml_node *node)
d457 27
a483 27
	u_int8_t type, attr;
	int len, start;
	struct aml_node *pf;

	start = 0;
	dnprintf(50, "-- parsefield\n");
	while (sc->amlpc.pos < node->end) {
		switch (aml_parseint(sc, 1)) {
		case 0x00: /* reserved */
			len = aml_parselength(sc);
			start += len;
			break;
		case 0x01: /* access field */
			type = aml_parseint(sc, 1);
			attr = aml_parseint(sc, 1);
			dnprintf(50, "  type=%.2x  attr=%.2x\n", type, attr);
			break;
		default: /* named field */
			--sc->amlpc.pos;
			pf = aml_create_node(sc, node, AMLOP_CREATEFIELD);
			pf->name = aml_parsename(sc, "field");
			len = aml_parselength(sc);

			aml_setfield(&pf->value, start, len, node, pf);
			start += len;
		}
	}
d488 1
a488 1
aml_parsename(struct acpi_softc *sc, const char *lbl)
d490 30
a519 11
	int count, pfxlen;
	char *name, *pn;
	u_int8_t *base;

	pfxlen = 0;
	if (sc->amlpc.pos[pfxlen] == AMLOP_ROOTCHAR) {
		pfxlen++;
	}
	while (sc->amlpc.pos[pfxlen] == AMLOP_PARENTPREFIX) {
		pfxlen++;
	}
d521 2
a522 18
	switch (sc->amlpc.pos[pfxlen]) {
	case 0x00:
		count = 0;
		base  = sc->amlpc.pos + pfxlen + 1;
		break;
	case AMLOP_MULTINAMEPREFIX:
		count = sc->amlpc.pos[pfxlen+1];
		base = sc->amlpc.pos + pfxlen + 2;
		break;
	case AMLOP_DUALNAMEPREFIX:
		count = 2;
		base  = sc->amlpc.pos + pfxlen + 1;
		break;
	default:
		count = 1;
		base  = sc->amlpc.pos + pfxlen;
		break;
	}
d524 2
a525 5
	name = malloc(pfxlen + count * 5, M_DEVBUF, M_WAITOK);
	pn = name;

	while (pfxlen--) 
		*(pn++) = *(sc->amlpc.pos++);
d527 11
a537 11
	/* Copy name segments in chunks of 4 bytes */
	while (count--) {
		memcpy(pn, base, 4);
		if (count) {
			*(pn + 4) = '.';
			pn++;
		}
		pn += 4;
		base += 4;
	}
	*pn = 0;
d539 1
a539 1
	dnprintf(50, " acpi_name (%s): %s\n", lbl, name);
d541 1
a541 1
	sc->amlpc.pos = base;
d543 1
a543 1
	return name;
d550 8
a557 8
	switch (opcode) {
	case AMLOP_ROOTCHAR:
        case AMLOP_PARENTPREFIX:
        case AMLOP_MULTINAMEPREFIX:
        case AMLOP_DUALNAMEPREFIX:
        case AMLOP_NAMECHAR:
		return (1);
	}
d559 2
a560 2
	if (opcode >= 'A' && opcode <= 'Z')
		return (1);
d562 1
a562 1
	return (0);
d568 2
a569 2
	u_int64_t rval;
	int n,pos;
d571 10
a580 10
	pos=1;
	for (rval=0; val; val >>= 4) {
		n = (val & 0xF);
		if (n > 9)
			return (0);

		rval += (n * pos);
		pos *= 10;
	}
	return rval;
d586 2
a587 6
	u_int64_t rval;
	int n,pos;

	pos=0;
	for (rval=0; val; val /= 10) {
		n = (val % 10);
d589 8
a596 4
		rval += (n << pos);
		pos += 4;
	}
	return rval;
d603 1
a603 1
	int n = 31;
d605 6
a610 6
	if (!val) return -1;
	if (val & 0x0000FFFF) { val <<= 16; n -= 16; };
	if (val & 0x00FF0000) { val <<= 8;  n -= 8; };
	if (val & 0x0F000000) { val <<= 4;  n -= 4; };
	if (val & 0x30000000) { val <<= 2;  n -= 2; };
	return (val & 0x40000000) ? n-1 : n;
d617 1
a617 1
	int n=0;
d619 6
a624 6
	if (!val) return -1;
	if (val & 0xFFFF0000) { val >>= 16; n += 16; };
	if (val & 0x0000FF00) { val >>= 8;  n += 8; };
	if (val & 0x000000F0) { val >>= 4;  n += 4; };
	if (val & 0x0000000C) { val >>= 2;  n += 2; };
	return (val & 0x00000002) ? n+1 : n;
d631 36
a666 36
	switch (opcode) {
	case AMLOP_ADD:
		return (lhs + rhs);
	case AMLOP_SUBTRACT:
		return (lhs - rhs);
	case AMLOP_MULTIPLY:
		return (lhs * rhs);
	case AMLOP_DIVIDE:
		return (lhs / rhs);
	case AMLOP_MOD:
		return (lhs % rhs);
	case AMLOP_SHL:
		return (lhs << rhs);
	case AMLOP_SHR:
		return (lhs >> rhs);
	case AMLOP_AND:
		return (lhs & rhs);
	case AMLOP_NAND:
		return ~(lhs & rhs);
	case AMLOP_OR:
		return (lhs | rhs); 
	case AMLOP_NOR:
		return ~(lhs | rhs); 
	case AMLOP_XOR:
		return (lhs ^ rhs);
	case AMLOP_INCREMENT:
		return (lhs + 1);
	case AMLOP_DECREMENT:
		return (lhs - 1);
	case AMLOP_FINDSETLEFTBIT:
		return aml_msb(lhs);
	case AMLOP_FINDSETRIGHTBIT:
		return aml_lsb(lhs);
	case AMLOP_NOT:
		return ~(lhs);
	}
d668 1
a668 1
	return (0);
d674 1
a674 1
	return (0);
d681 21
a701 21
	switch(opcode) {
	case AMLOP_LAND:
		return (lhs && rhs);
	case AMLOP_LOR:
		return (lhs || rhs);
	case AMLOP_LNOT:
		return (!lhs);
	case AMLOP_LNOTEQUAL:
		return (lhs != rhs);
	case AMLOP_LLESSEQUAL:
		return (lhs <= rhs);
	case AMLOP_LGREATEREQUAL:
		return (lhs >= rhs);
	case AMLOP_LEQUAL:
		return (lhs == rhs);
	case AMLOP_LGREATER:
		return (lhs > rhs);
	case AMLOP_LLESS:
		return (lhs < rhs);
	}
	return 0;
d710 1
a710 1
aml_getopcode(struct acpi_softc *sc)
d712 2
a713 7
	u_int16_t twocode;
	u_int16_t opcode;

	/* Check for encoded name */
	if (aml_isnamedop(*sc->amlpc.pos)) {
		return AMLOP_NAMECHAR;
	}
d715 16
a730 2
	opcode  = aml_parseint(sc, 1);
	twocode = (opcode << 8L) + *sc->amlpc.pos;
d732 1
a732 10
	/* Check multi-byte opcodes */
	if (twocode == AMLOP_LNOTEQUAL ||
	    twocode == AMLOP_LLESSEQUAL ||
	    twocode == AMLOP_LGREATEREQUAL ||
	    opcode == AMLOP_EXTPREFIX) {
		sc->amlpc.pos++;
		return twocode;
	}

	return opcode;
d736 115
a850 112
	/* Simple types */
	{ AMLOP_ZERO,             "Zero",            "!", },
	{ AMLOP_ONE,              "One",             "!",  },
	{ AMLOP_ONES,             "Ones",            "!",   },
	{ AMLOP_BYTEPREFIX,       "Byte",            "b",  },
	{ AMLOP_WORDPREFIX,       "Word",            "w",  },
	{ AMLOP_DWORDPREFIX,      "DWord",           "d",  },
	{ AMLOP_QWORDPREFIX,      "QWord",           "q",  },
	{ AMLOP_REVISION,         "Revision",        "",   },
	{ AMLOP_STRINGPREFIX,     "String",          "s",  },
	{ AMLOP_BUFFER,           "Buffer",          "piB", },

	/* Simple objects */
	{ AMLOP_DEBUG,            "DebugOp",         "",    },
	{ AMLOP_LOCAL0,           "Local0",          "",    },
	{ AMLOP_LOCAL1,           "Local1",          "",    },
	{ AMLOP_LOCAL2,           "Local2",          "",    },
	{ AMLOP_LOCAL3,           "Local3",          "",    },
	{ AMLOP_LOCAL4,           "Local4",          "",    },
	{ AMLOP_LOCAL5,           "Local5",          "",    },
	{ AMLOP_LOCAL6,           "Local6",          "",    },
	{ AMLOP_LOCAL7,           "Local7",          "",    },
	{ AMLOP_ARG0,             "Arg0",            "",    },
	{ AMLOP_ARG1,             "Arg1",            "",    },
	{ AMLOP_ARG2,             "Arg2",            "",    },
	{ AMLOP_ARG3,             "Arg3",            "",    },
	{ AMLOP_ARG4,             "Arg4",            "",    },
	{ AMLOP_ARG5,             "Arg5",            "",    },
	{ AMLOP_ARG6,             "Arg6",            "",    },

	/* Control flow */
	{ AMLOP_IF,               "If",              "piT",  },
	{ AMLOP_ELSE,             "Else",            "pT",   },
	{ AMLOP_WHILE,            "While",           "piT",  },
	{ AMLOP_BREAK,            "Break",           "",     },
	{ AMLOP_CONTINUE,         "Continue",        "",     },
	{ AMLOP_RETURN,           "Return",          "t",     },
	{ AMLOP_FATAL,            "Fatal",           "bdi", },
	{ AMLOP_NOP,              "Nop",             "",    },
	{ AMLOP_BREAKPOINT,       "BreakPoint",      "",    },

	/* Arithmetic operations */
	{ AMLOP_INCREMENT,        "Increment",       "t",     },
	{ AMLOP_DECREMENT,        "Decrement",       "t",     },
	{ AMLOP_ADD,              "Add",             "iit",   },
	{ AMLOP_SUBTRACT,         "Subtract",        "iit",   },
	{ AMLOP_MULTIPLY,         "Multiply",        "iit",   },
	{ AMLOP_DIVIDE,           "Divide",          "iitt",  },
	{ AMLOP_SHL,              "ShiftLeft",       "iit",   },
	{ AMLOP_SHR,              "ShiftRight",      "iit",   },
	{ AMLOP_AND,              "And",             "iit",   },
	{ AMLOP_NAND,             "Nand",            "iit",   },
	{ AMLOP_OR,               "Or",              "iit",   },
	{ AMLOP_NOR,              "Nor",             "iit",   },
	{ AMLOP_XOR,              "Xor",             "iit",   },
	{ AMLOP_NOT,              "Not",             "it",    },
	{ AMLOP_MOD,              "Mod",             "iit",   },
	{ AMLOP_FINDSETLEFTBIT,   "FindSetLeftBit",  "it",    },
	{ AMLOP_FINDSETRIGHTBIT,  "FindSetRightBit", "it",    },

	/* Logical test operations */
	{ AMLOP_LAND,             "LAnd",            "ii",    },
	{ AMLOP_LOR,              "LOr",             "ii",    },
	{ AMLOP_LNOT,             "LNot",            "i",     },
	{ AMLOP_LNOTEQUAL,        "LNotEqual",       "tt",    },
	{ AMLOP_LLESSEQUAL,       "LLessEqual",      "tt",    },
	{ AMLOP_LGREATEREQUAL,    "LGreaterEqual",   "tt",    },
	{ AMLOP_LEQUAL,           "LEqual",          "tt",    },
	{ AMLOP_LGREATER,         "LGreater",        "tt",    },
	{ AMLOP_LLESS,            "LLess",           "tt",    },

	/* Named objects */
	{ AMLOP_EVENT,            "Event",           "N",   },
	{ AMLOP_NAME,             "Name",            "Nt",  },
	{ AMLOP_MUTEX,            "Mutex",           "Nb",  },
	{ AMLOP_ALIAS,            "Alias",           "Nt",  },
	{ AMLOP_DATAREGION,       "DataRegion",      "Nttt" },
	{ AMLOP_OPREGION,         "OpRegion",        "Nbii" },
	{ AMLOP_SCOPE,            "Scope",           "pNT" },
	{ AMLOP_DEVICE,           "Device",          "pNT" },
	{ AMLOP_POWERRSRC,        "Power Resource",  "pNbwT" },
	{ AMLOP_THERMALZONE,      "ThermalZone",     "pNT" },
	{ AMLOP_METHOD,           "Method",          "pNfM",  },
	{ AMLOP_PROCESSOR,        "Processor",       "pNbdbT", },
	{ AMLOP_FIELD,            "Field",           "pNfF" },
	{ AMLOP_INDEXFIELD,       "IndexField",      "pNtfF" },
	{ AMLOP_BANKFIELD,        "BankField",       "pNtifF" },

	/* Field operations */
	{ AMLOP_CREATEFIELD,      "CreateField",     "tiiN",   },
	{ AMLOP_CREATEQWORDFIELD, "CreateQWordField","tiN",    },
	{ AMLOP_CREATEDWORDFIELD, "CreateDWordField","tiN",    },
	{ AMLOP_CREATEWORDFIELD,  "CreateWordField", "tiN",    },
	{ AMLOP_CREATEBYTEFIELD,  "CreateByteField", "tiN",    },
	{ AMLOP_CREATEBITFIELD,   "CreateBitField",  "tiN",    },

	/* Conversion operations */
	{ AMLOP_TOINTEGER,        "ToInteger",       "tt",     },
	{ AMLOP_TOBUFFER,         "ToBuffer",        "tt",     },
	{ AMLOP_TODECSTRING,      "ToDecString",     "it",     },
	{ AMLOP_TOHEXSTRING,      "ToHexString",     "it",     }, 
	{ AMLOP_TOSTRING,         "ToString",        "t",      },
	{ AMLOP_FROMBCD,          "FromBCD",         "it",     },
	{ AMLOP_TOBCD,            "ToBCD",           "it",     },
	{ AMLOP_MID,              "Mid",             "tiit",   },

	/* Mutex/Signal operations */
	{ AMLOP_ACQUIRE,          "Acquire",         "tw",     },
	{ AMLOP_RELEASE,          "Release",         "t",      },
	{ AMLOP_SIGNAL,           "Signal",          "t",      },
	{ AMLOP_WAIT,             "Wait",            "ti",     },
	{ AMLOP_RESET,            "Reset",           "t",      },
d852 19
a870 21
	{ AMLOP_INDEX,            "Index",           "ttt",    },
	{ AMLOP_PACKAGE,          "Package",         "pbT",    },
	{ AMLOP_VARPACKAGE,       "VarPackage",      "piT",    },
	{ AMLOP_DEREFOF,          "DerefOf",         "t",      },
	{ AMLOP_REFOF,            "RefOf",           "t",      },
	{ AMLOP_CONDREFOF,        "CondRef",         "tt",     },

	{ AMLOP_LOADTABLE,        "LoadTable",       "tttttt" },
	{ AMLOP_STALL,            "Stall",           "i",      },
	{ AMLOP_SLEEP,            "Sleep",           "i",      },
	{ AMLOP_LOAD,             "Load",            "tt" },
	{ AMLOP_UNLOAD,           "Unload",          "t" }, 
	{ AMLOP_STORE,            "Store",           "tt",     },
	{ AMLOP_CONCAT,           "Concat",          "ttt" },
	{ AMLOP_CONCATRES,        "ConcatRes",       "ttt" },
	{ AMLOP_NOTIFY,           "Notify",          "ti" },
	{ AMLOP_SIZEOF,           "Sizeof",          "t",      },
	{ AMLOP_MATCH,            "Match",           "tbibii", },
	{ AMLOP_OBJECTTYPE,       "ObjectType",      "t", },
	{ AMLOP_COPYOBJECT,       "CopyObject",      "tt" },
	{ 0xFFFF }
d873 2
d878 2
a879 2
	dst->type   = src->type;
	dst->length = src->length;
d881 14
a894 14
	switch (dst->type) {
	case AML_OBJTYPE_INTEGER:
		dst->v_integer = src->v_integer;
		break;
	case AML_OBJTYPE_STRING:
		dst->v_string = src->v_string;
		break;
	case AML_OBJTYPE_BUFFER:
		dst->v_buffer = src->v_buffer;
		break;
	case AML_OBJTYPE_PACKAGE:
		dst->v_package = src->v_package;
		break;
	}
d896 1
d903 1
a903 1
	struct aml_node *node = parent->child;
d905 4
a908 4
	while(node && child--) {
		node = node->sibling;
	}
	return node;
d920 1
a920 1
	int id;
d922 44
a965 44
	if (node == NULL) {
		printf("aml_getnodevalue: null\n");
		return NULL;
	}
	switch (node->opcode) {
	case AMLOP_DEBUG:
		return &aml_debugobj;

	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
		return &env->v_method.locals[id];

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
		return &env->v_method.args[id];

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
		return &node->value;

	default:
		printf("aml_getnodevalue: no type: %.4x\n", node->opcode);
		break;
	}
	return NULL;
d972 72
a1043 69
	struct aml_value *dest = NULL;
	struct aml_value  lhs;
	int id;

	if (node == NULL) {
		printf("aml_setnodevalue: null\n");
		return;
	}
	dnprintf(50, "--- setnodevalue:\n");
	aml_shownode(node);
	aml_showvalue((struct aml_value *)val);
	switch (node->opcode) {
	case AMLOP_DEBUG:
		dest = &aml_debugobj;
		break;

	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
		dest = &env->v_method.locals[id];
		break;

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
		dest = &env->v_method.args[id];
		break;

	case AMLOP_NAMECHAR:
		return aml_setnodevalue(sc, aml_find_name(sc, NULL, node->name), val, env);

	case AMLOP_CREATEFIELD:
	case AMLOP_CREATEBITFIELD:
	case AMLOP_CREATEBYTEFIELD:
	case AMLOP_CREATEWORDFIELD:
	case AMLOP_CREATEDWORDFIELD:
	case AMLOP_CREATEQWORDFIELD:
		aml_eval_object(sc, node, &lhs, env);
		aml_showvalue(&lhs);
		for(;;);
		break;

	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_REVISION:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	default:
		printf("aml_setnodeval: read-only %.4x\n", node->opcode);
		break;
	}
	if (dest) {
		dnprintf(50, "aml_setnodeval: %.4x\n", node->opcode);
		aml_copyvalue(dest, val);
	}
d1050 1
a1050 1
	struct aml_value ival;
d1052 2
a1053 2
	aml_setinteger(&ival, value);
	aml_setnodevalue(sc, node, &ival, env);
d1059 10
a1068 10
	/* ASSERT: lhs and rhs are of same type */
	switch (lhs->type) {
	case AML_OBJTYPE_INTEGER:
		return (lhs->v_integer - rhs->v_integer);
	case AML_OBJTYPE_STRING:
		return strcmp(lhs->v_string, rhs->v_string);
	default:
		printf("Unknown compare type for cmpobj\n");
		break;
	}
d1070 1
a1070 1
	return (0);
d1077 1
a1077 1
	int rc;
d1079 2
a1080 2
	if (mtype == AML_MATCH_TR)
		return (1);
d1082 2
a1083 2
	if (lhs->type != rhs->type)
		return (0);
d1085 13
a1097 13
	rc = aml_cmpobj(sc, lhs, rhs);
	switch (mtype) {
	case AML_MATCH_EQ:
		return (rc == 0);
	case AML_MATCH_LT:
		return (rc < 0);
	case AML_MATCH_LE:
		return (rc <= 0);
	case AML_MATCH_GE:
		return (rc >= 0);
	case AML_MATCH_GT:
		return (rc > 0);
	}
d1099 1
a1099 1
	return (0);
d1103 1
a1103 1
aml_create_node(struct acpi_softc *sc, struct aml_node *parent, int opcode)
d1105 1
a1105 1
	struct aml_node *node;
d1107 2
a1108 2
	node = malloc(sizeof(struct aml_node), M_DEVBUF, M_WAITOK);
	memset(node, 0, sizeof(struct aml_node));
d1110 3
a1112 3
	node->start  = sc->amlpc.pos;
	node->opcode = (opcode == -1) ? aml_getopcode(sc) : opcode;
	aml_addchildnode(parent, node);
d1114 1
a1114 1
	return node;
d1120 1
a1120 1
	struct  aml_value ival;
d1122 3
a1124 3
	aml_eval_object(sc, node, &ival, env);
	if (ival.type == AML_OBJTYPE_INTEGER)
		return ival.v_integer;
d1126 1
a1126 1
	return (0);
d1132 2
a1133 2
	struct aml_node *ret;
	const char *sname;
d1135 25
a1159 25
	if (*name == AMLOP_ROOTCHAR) {
		root = &aml_root;
		name++;
	}
	while (*name == AMLOP_PARENTPREFIX) {
		if (root) root = root->parent;
		name++;
	}
	if (root == NULL)
		root = &aml_root;

	for (ret=NULL; root && !ret; root = root->sibling) {
		if ((sname = root->name) != NULL) {
			if (*sname == AMLOP_ROOTCHAR) 
				sname++;
			while (*sname == AMLOP_PARENTPREFIX) 
				sname++;
			if (!strcmp(name, sname)) {
				return root;
			}
		}
		if (root->child)
			ret = aml_find_name(sc, root->child, name);
	}
	return ret;
d1166 1
a1166 1
	root = aml_find_name(sc, root, name);
d1168 5
a1172 5
	if (root != NULL) {
		dnprintf(50, "found eval object : %s, %.4x\n", root->name, root->opcode);
		return aml_eval_object(sc, root, result, env);
	}
	return (1);
d1177 1
a1177 1
	     struct aml_value *env)
d1179 102
a1280 95
	struct  aml_value lhs, rhs, tmp, pkg;
	struct aml_value *px;
	int64_t iresult, id, idx;
	struct  aml_node *cflow = NULL;
	int     i1, i2, i3;
	char   *tmpstr;

	if (node == NULL) 
		return (-1);

	dnprintf(50, "--- Evaluating object:\n"); 
	aml_shownode(node);

	switch (node->opcode) {
	case AMLOP_ZERO:
	case AMLOP_ONE:
	case AMLOP_ONES:
	case AMLOP_BYTEPREFIX:
	case AMLOP_WORDPREFIX:
	case AMLOP_DWORDPREFIX:
	case AMLOP_QWORDPREFIX:
	case AMLOP_STRINGPREFIX:
	case AMLOP_REVISION:
		aml_copyvalue(result, &node->value);
		break;

	case AMLOP_BUFFER:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@ buffer: %.4x %.4x\n", i1, node->value.length);
		break;

	case AMLOP_STORE:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_setnodevalue(sc, childOf(node, 1), &lhs, env);
		break;

	case AMLOP_DEBUG:
		aml_copyvalue(result, &aml_debugobj);
		break;

	case AMLOP_NAME:
	case AMLOP_ALIAS:
		return aml_eval_object(sc, childOf(node, 0), result, env);

	case AMLOP_PROCESSOR:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		i3 = aml_evalint(sc, childOf(node, 2), env);
		aml_setprocessor(result, i1, i2, i3);
		break;

	case AMLOP_OPREGION:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		aml_setopregion(result, node->flag, i1, i2);
		break;

	case AMLOP_IF:
		i1 = aml_evalint(sc, childOf(node,0), env);
		if (i1 != 0) {
			/* Test true, select 'If' block */
			cflow = childOf(node, 1);
		}
		else if (node->sibling->opcode == AMLOP_ELSE) {
			/* Test false, select 'Else' block */
			cflow = node->sibling->child;
		}
		while (cflow) {
			/* Execute all instructions in scope block */
			aml_eval_object(sc, cflow, result, env);
			cflow = cflow->sibling;
		}
		break;

	case AMLOP_WHILE:
		for (;;) {
			if (cflow == NULL) {
				/* Perform While test */
				cflow = childOf(node, 1);
				i1 = aml_evalint(sc, childOf(node, 0), env);
				if (i1 == 0) 
					break;
			}
			else if (cflow->opcode == AMLOP_BREAK) 
				break;
			else if (cflow->opcode == AMLOP_CONTINUE)
				/* Reset cflow to NULL; restart block */
				cflow = NULL;
			else {
				/* Execute all instructions in scope block */
				aml_eval_object(sc, cflow, result, env);
				cflow = cflow->sibling;
			}
		}
		break;
d1282 44
a1325 40
	case AMLOP_RETURN:
		aml_eval_object(sc, childOf(node, 0), result, env);
		break;

	case AMLOP_ARG0:
	case AMLOP_ARG1:
	case AMLOP_ARG2:
	case AMLOP_ARG3:
	case AMLOP_ARG4:
	case AMLOP_ARG5:
	case AMLOP_ARG6:
		id = node->opcode - AMLOP_ARG0;
		if (id < env->length)
			aml_copyvalue(result, &node->value.v_method.locals[id]);
		break;

	case AMLOP_LOCAL0:
	case AMLOP_LOCAL1:
	case AMLOP_LOCAL2:
	case AMLOP_LOCAL3:
	case AMLOP_LOCAL4:
	case AMLOP_LOCAL5:
	case AMLOP_LOCAL6:
	case AMLOP_LOCAL7:
		id = node->opcode - AMLOP_LOCAL0;
		aml_copyvalue(result, &env->v_method.locals[id]);
		break;

	case AMLOP_PACKAGE:
	case AMLOP_VARPACKAGE:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "package = %d\n", i1);
		result->type = AML_OBJTYPE_PACKAGE;
		result->length = i1;

		result->v_package = malloc(i1 * sizeof(struct aml_value), M_DEVBUF, M_WAITOK);
		for (i2=0; i2<i1; i2++) {
			aml_eval_object(sc, childOf(node, i2+1), &result->v_package[i2], env);
		}
		break;
d1327 108
a1434 108
	case AMLOP_INCREMENT:
	case AMLOP_DECREMENT:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_evalmath(node->opcode, i1, 0);
		aml_setnodeinteger(sc, childOf(node, 0), iresult, env);
		break;

	case AMLOP_NOT:
	case AMLOP_FINDSETLEFTBIT:
	case AMLOP_FINDSETRIGHTBIT:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_evalmath(node->opcode, i1, 0);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
		break;

	case AMLOP_DIVIDE:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);

		/* Set remainder */
		iresult = aml_evalmath(AMLOP_MOD,    i1, i2);
		aml_setnodeinteger(sc, childOf(node, 2), iresult, env);

		/* Set quotient */
		iresult = aml_evalmath(node->opcode, i1, i2);
		aml_setnodeinteger(sc, childOf(node, 3), iresult, env);
		break;

	case AMLOP_ADD:
	case AMLOP_SUBTRACT:
	case AMLOP_MULTIPLY:
	case AMLOP_SHL:
	case AMLOP_SHR:
	case AMLOP_AND:
	case AMLOP_NAND:
	case AMLOP_OR:
	case AMLOP_NOR:
	case AMLOP_XOR:
	case AMLOP_MOD:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);

		iresult = aml_evalmath(node->opcode, i1, i2);
		aml_setnodeinteger(sc, childOf(node, 2), iresult, env);
		break;

	case AMLOP_LNOT:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_testlogical(node->opcode, i1, 0);
		aml_setinteger(result, iresult);
		break;

	case AMLOP_LAND:
	case AMLOP_LOR:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		i2 = aml_evalint(sc, childOf(node, 1), env);
		iresult = aml_testlogical(node->opcode, i1, i2);
		aml_setinteger(result, iresult);
		break;

	case AMLOP_LEQUAL:
	case AMLOP_LNOTEQUAL:
	case AMLOP_LLESSEQUAL:
	case AMLOP_LGREATEREQUAL:
	case AMLOP_LGREATER:
	case AMLOP_LLESS:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_eval_object(sc, childOf(node, 1), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_testlogical(node->opcode, lhs.v_integer, rhs.v_integer);
		}
		else if (lhs.type == AML_OBJTYPE_STRING && rhs.type == AML_OBJTYPE_STRING) {
			iresult = aml_strcmp(node->opcode, lhs.v_string, rhs.v_string);
		}
		aml_setinteger(result, iresult);
		break;

	case AMLOP_CREATEFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		i2 = aml_evalint(sc, childOf(node, 2), env);
		aml_setfield(&lhs, i1, i2, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 3), &lhs, env);
		break;
	case AMLOP_CREATEBITFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1, 1, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
		break;
	case AMLOP_CREATEBYTEFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 8, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
		break;
	case AMLOP_CREATEWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 16, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
		break;
	case AMLOP_CREATEDWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 32, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
		break;
	case AMLOP_CREATEQWORDFIELD:
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_setfield(&lhs, i1 * 8, 64, childOf(node, 0), node);
		aml_setnodevalue(sc, childOf(node, 2), &lhs, env);
		break;
d1436 121
a1556 120
	case AMLOP_TOBCD:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_dec2bcd(i1);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
		break;
	case AMLOP_FROMBCD:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		iresult = aml_bcd2dec(i1);
		aml_setnodeinteger(sc, childOf(node, 1), iresult, env);
		break;
	case AMLOP_TODECSTRING:
		tmpstr = malloc(AML_INTSTRLEN+1, M_DEVBUF, M_WAITOK);
		if (tmpstr != NULL) {
			aml_eval_object(sc, childOf(node, 0), &lhs, env);
			if (lhs.type == AML_OBJTYPE_INTEGER) 
				snprintf(tmpstr, AML_INTSTRLEN, "%d", lhs.v_integer);
		}
		break;
	case AMLOP_TOHEXSTRING:
		tmpstr = malloc(AML_INTSTRLEN+1, M_DEVBUF, M_WAITOK);
		if (tmpstr != NULL) {
			aml_eval_object(sc, childOf(node, 0), &lhs, env);
			if (lhs.type == AML_OBJTYPE_INTEGER) 
				snprintf(tmpstr, AML_INTSTRLEN, "%x", lhs.v_integer);
		}
		break;

	case AMLOP_MID:
		aml_eval_object(sc, childOf(node, 0), &tmp, env);
		aml_eval_object(sc, childOf(node, 1), &lhs, env);
		aml_eval_object(sc, childOf(node, 2), &rhs, env);
		if (tmp.type != AML_OBJTYPE_STRING) 
			return (-1);

		tmpstr = malloc(rhs.v_integer+1, M_DEVBUF, M_WAITOK);
		if (tmpstr != NULL) {
			strncpy(tmpstr, tmp.v_string + lhs.v_integer, rhs.v_integer);
		}
		break;

	case AMLOP_STALL:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "aml_stall: %d\n", i1);
		break;
	case AMLOP_SLEEP:
		i1 = aml_evalint(sc, childOf(node, 0), env);
		dnprintf(50, "aml_sleep: %d\n", i1);
		break;
	case AMLOP_OBJECTTYPE:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_setinteger(result, lhs.type);
		break;

	case AMLOP_NAMECHAR: /* Inline method call */
		aml_eval_name(sc, NULL, node->name, result, env);
		break;

	case AMLOP_METHOD:
		dnprintf(50, "eval-method : %s  argcount:%d\n", 
		       node->name, AML_METHOD_ARGCOUNT(node->flag));

		lhs.type = AML_OBJTYPE_METHOD;
		lhs.length = AML_METHOD_ARGCOUNT(node->flag);
		if (lhs.length > 0) {
			lhs.v_method.args = malloc(lhs.length * sizeof(struct aml_value), M_DEVBUF, M_WAITOK);
			memset(lhs.v_method.args, 0, lhs.length * sizeof(struct aml_value));
		}
		lhs.v_method.locals = malloc(8 * sizeof(struct aml_value), M_DEVBUF, M_WAITOK);

		for (i1=0; i1<lhs.length; i1++) {
			dnprintf(50, " evalmeth: %s:%d\n", node->name, i1);
			aml_eval_object(sc, childOf(node, i1), &lhs.v_method.args[i1], env);
			aml_showvalue(&lhs.v_method.args[i1]);
		}
		while (childOf(node, i1)) {
			aml_eval_object(sc, childOf(node, i1++), result, &lhs);
		}
		break;

	case AMLOP_CONCAT:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		aml_eval_object(sc, childOf(node, 1), &rhs, env);
		break;

	case AMLOP_NOP:
		break;

	case AMLOP_SIZEOF:
		aml_eval_object(sc, childOf(node, 0), &lhs, env);
		px = aml_getnodevalue(sc, childOf(node, 0), env);
		aml_showvalue(px);
		for(;;);
		break;

	case AMLOP_MATCH:
		aml_eval_object(sc, childOf(node, 0), &pkg, env);
		i1 = aml_evalint(sc, childOf(node, 1), env);
		aml_eval_object(sc, childOf(node, 2), &lhs, env);
		i2 = aml_evalint(sc, childOf(node, 3), env);
		aml_eval_object(sc, childOf(node, 4), &lhs, env);
		idx = aml_evalint(sc, childOf(node, 5), env);
		if (pkg.type == AML_OBJTYPE_PACKAGE) {
			iresult = -1;
			while (idx < pkg.length) {
				if (aml_match(sc, i1, &pkg.v_package[idx], &lhs) ||
				    aml_match(sc, i2, &pkg.v_package[idx], &rhs)) {
					iresult = idx;
					break;
				}
				idx++;
			}
			aml_setinteger(result, iresult);
		}
		break;

	default:
		printf("Unknown eval: %.4x %s\n", node->opcode, node->mnem);
		break;
	}
	return (0);
d1560 1
a1560 1
aml_parseargs(struct acpi_softc *sc, struct aml_node *node, const char *arg)
d1562 1
a1562 2
	struct aml_node *pnode;
	//struct aml_value *i1, *i2;
d1564 97
a1660 95
	while (*arg) {
		pnode = node;
		switch (*arg) {
		case AML_ARG_FLAG:
			node->flag = aml_parseint(sc, 1);
			if (node->opcode == AMLOP_METHOD) {
				dnprintf(50, " method %s %.2x argcount:%d serialized:%d synclevel:%d\n",
					node->name, node->flag,
					AML_METHOD_ARGCOUNT(node->flag),
					AML_METHOD_SERIALIZED(node->flag),
					AML_METHOD_SYNCLEVEL(node->flag));
			}
			else {
				dnprintf(50, " field %s %.2x access:%d lock:%d update:%d\n",
					node->name, node->flag,
					AML_FIELD_ACCESS(node->flag),
					AML_FIELD_LOCK(node->flag),
					AML_FIELD_UPDATE(node->flag));
			}
			break;
		case AML_ARG_IMPBYTE:
			/* Implied byte: same as opcode */
			aml_setinteger(&node->value, (int8_t)node->opcode);
			dnprintf(50, " ibyte: %x\n", (int8_t)node->opcode);
			break;
		case AML_ARG_BYTE:
			if (node->opcode != AMLOP_BYTEPREFIX) {
				pnode = aml_create_node(sc, node, AMLOP_BYTEPREFIX);
			}
			aml_setinteger(&pnode->value, (int8_t)aml_parseint(sc, 1));
			dnprintf(50, " byte: %x\n", pnode->value.v_integer);
			break;
		case AML_ARG_WORD:
			if (node->opcode != AMLOP_WORDPREFIX) {
				pnode = aml_create_node(sc, node, AMLOP_WORDPREFIX);
			}
			aml_setinteger(&pnode->value, (int16_t)aml_parseint(sc, 2));
			dnprintf(50, " word: %x\n", pnode->value.v_integer);
			break;
                case AML_ARG_DWORD:
			if (node->opcode != AMLOP_DWORDPREFIX) {
				pnode = aml_create_node(sc, node, AMLOP_DWORDPREFIX);
			}
			aml_setinteger(&pnode->value, (int32_t)aml_parseint(sc, 4));
			dnprintf(50, " dword: %x\n", pnode->value.v_integer);
			break;
		case AML_ARG_QWORD:
			if (node->opcode == AMLOP_QWORDPREFIX) {
				pnode = aml_create_node(sc, node, AMLOP_QWORDPREFIX);
			}
			aml_setinteger(&pnode->value, aml_parseint(sc, 8));
			dnprintf(50, " qword: %x\n", pnode->value.v_integer);	
			break;
		case AML_ARG_FIELDLIST:
			dnprintf(50, " fieldlist\n");
			aml_parsefieldlist(sc, node);
			break;
		case AML_ARG_BYTELIST:
			dnprintf(50, " bytelist\n");
			aml_setbuffer(&node->value, node->end - sc->amlpc.pos, sc->amlpc.pos);
			sc->amlpc.pos = node->end;
			break;
		case AML_ARG_STRING:
			aml_setstring(&node->value, aml_parsestr(sc));
			dnprintf(50, " string: %s\n", node->value.v_string);
			break;
		case AML_ARG_NAMESTRING:
			node->name = aml_parsename(sc, "name");
			break;
		case AML_ARG_NAMEREF:
			pnode = aml_create_node(sc, node, AMLOP_NAMECHAR);
			pnode->name = aml_parsename(sc, "nameref");
			break;
		case AML_ARG_OBJLEN:
			node->end = sc->amlpc.pos;
			node->end += aml_parselength(sc);
			break;
		case AML_ARG_INTEGER:
		case AML_ARG_TERMOBJ:
			/* Recursively parse children */
			aml_parse_object(sc, node);
			break;
		case AML_ARG_TERMOBJLIST:
		case AML_ARG_METHOD:
			/* Recursively parse children */
			while (sc->amlpc.pos < node->end) {
				aml_parse_object(sc, node);
			}
			sc->amlpc.pos = node->end;
			break;

		default:
			printf("Unknown arg: %c\n", *arg);
			break;
		}
d1662 2
a1663 2
		arg++;
	}
d1665 1
a1665 1
	return (0);
d1671 1
a1671 1
	struct aml_node *psib;
d1673 9
a1681 9
	child->parent = parent;
	child->sibling = NULL;
	for (psib = parent->child; psib; psib = psib->sibling) {
		if (psib->sibling == NULL) {
			psib->sibling = child;
			return;
		}
	}
	parent->child = child;
d1687 1
a1687 1
	int idx;
d1689 59
a1747 24
	switch (value->type) {
	case AML_OBJTYPE_INTEGER:
		dnprintf(50, "integer: %x\n", value->v_integer);
		break;
	case AML_OBJTYPE_STRING:
		dnprintf(50, "string: %s\n", value->v_string);
		break;
	case AML_OBJTYPE_BUFFER:
		dnprintf(50, "buffer: %d {\n", value->length);
		for (idx=0; idx<value->length; idx++) {
			dnprintf(50, "%s0x%.2x", (idx ? "," : ""), value->v_buffer[idx]);
		}
		dnprintf(50, "}\n");
		break;
	case AML_OBJTYPE_PACKAGE:
		dnprintf(50, "package: %d {\n", value->length);
		for (idx=0; idx<value->length; idx++)
			aml_showvalue(&value->v_package[idx]);
		dnprintf(50, "}\n");
		break;
	default:
		printf("unknown: %d\n", value->type);
		break;
	}
d1753 19
a1771 19
	dnprintf(50, " opcode:%.4x  mnem:%s %s %.2x ",
	       node->opcode, node->mnem ? node->mnem : "", 
	       node->name ? node->name : "",
	       node->flag);
	switch(node->opcode) {
	case AMLOP_METHOD:
		dnprintf(50, "argcount:%d serialized:%d synclevel:%d",
		       AML_METHOD_ARGCOUNT(node->flag),
		       AML_METHOD_SERIALIZED(node->flag),
		       AML_METHOD_SYNCLEVEL(node->flag));
		break;
	case AMLOP_FIELD:
	case AMLOP_BANKFIELD:
	case AMLOP_INDEXFIELD:
		dnprintf(50, "access:%d lock:%d update:%d\n",
		       AML_FIELD_ACCESS(node->flag),
		       AML_FIELD_LOCK(node->flag),
		       AML_FIELD_UPDATE(node->flag));
		break;
d1773 14
a1786 14
	case AMLOP_BYTEPREFIX:
		dnprintf(50, "byte: %.2x", node->value.v_integer);
		break;
	case AMLOP_WORDPREFIX:
		dnprintf(50, "word: %.4x", node->value.v_integer);
		break;
	case AMLOP_DWORDPREFIX:
		dnprintf(50, "dword: %.8x", node->value.v_integer);
		break;
	case AMLOP_STRINGPREFIX:
		dnprintf(50, "string: %s", node->value.v_string);
		break;
	}
	dnprintf(50, "\n");
d1790 1
a1790 1
aml_parse_object(struct acpi_softc *sc, struct aml_node *parent)
d1792 15
a1806 30
	struct aml_optable *optab = aml_table;
	struct aml_node *node, *pr;
	int idx;

	/* Get AML Opcode; if it is an embedded name, extract name */
	node = aml_create_node(sc, parent, -1);
	if (node->opcode == AMLOP_NAMECHAR) {
		node->name = aml_parsename(sc, "embed");
		node->mnem = "embed";

		pr = aml_find_name(sc, NULL, node->name);
		if (pr != NULL && pr->opcode == AMLOP_METHOD) {
			/* Parse method arguments as siblings */
			for (idx=0; idx<AML_METHOD_ARGCOUNT(pr->flag); idx++) {
				dnprintf(50, " parsing method %s:%d\n", pr->name, idx);
				aml_parse_object(sc, node);
			}
		}
		return (node);
	}
	while (optab->opcode != 0xFFFF) {
		if  (optab->opcode == node->opcode) {
			node->mnem = optab->mnem;
			aml_parseargs(sc, node, optab->args);
			return node;
		}
		optab++;
	}
	printf("Invalid AML Opcode : @@ %.4x %.4x\n", sc->amlpc.pos - sc->amlpc.start, node->opcode);
	free(node, M_DEVBUF);
d1808 1
a1808 1
	return NULL;
d1814 1
a1814 1
	int idx;
d1816 9
a1824 9
	while(node) {
		dnprintf(50, " %d ", depth);
		for(idx=0; idx<depth; idx++) {
			dnprintf(50, "..");
		}
		aml_shownode(node);
		aml_walktree(node->child, depth+1);
		node = node->sibling;
	}
d1830 1
a1830 1
	aml_walktree(aml_root.child, 0);
d1838 1
a1838 1
	const char *nn;
d1840 11
a1850 11
	while (node) {
		if ((nn = node->name) != NULL) {
			if (*nn == AMLOP_ROOTCHAR) nn++;
			while (*nn == AMLOP_PARENTPREFIX) nn++;
			if (!strcmp(name, nn))
				cbproc(node, arg);
		}
		aml_find_node(node->child, name, cbproc, arg);
		node = node->sibling;
	}
	return (0);
d1858 1
a1858 1
	static char id[8];
d1860 8
a1867 8
	id[0] = '@@' + ((pid >> 2) & 0x1F);
	id[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
	id[2] = '@@' + ((pid >> 8) & 0x1F);
	id[3] = hext[(pid >> 20) & 0xF];
	id[4] = hext[(pid >> 16) & 0xF];
	id[5] = hext[(pid >> 28) & 0xF];
	id[6] = hext[(pid >> 24) & 0xF];
	id[7] = 0;
d1869 1
a1869 1
	return id;
d1877 2
a1878 2
	struct acpi_softc *sc = arg;
	struct aml_value res, env;
d1880 2
a1881 2
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));
d1883 17
a1899 3
	dnprintf(50, "Value is: %s\n", node->name);
	aml_eval_object(sc, node->child, &res, &env);
	aml_showvalue(&res);
d1905 6
a1910 1
	struct aml_value rv, env;
d1912 5
a1916 10
	sc->amlpc.pos   = start;
	sc->amlpc.start = start;
	sc->amlpc.end   = start+length;

	memset(&rv, 0, sizeof(rv));
	memset(&env, 0, sizeof(env));
	while (sc->amlpc.pos < sc->amlpc.end) {
		aml_parse_object(sc, &aml_root);
	}
	dnprintf(50, " : parsed %d AML bytes\n", length);
d1918 1
a1918 1
	return (0);
@


1.14
log
@In aml_eval_name() don't return success if no object found.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.13 2005/12/30 05:59:40 tedu Exp $ */
d162 1
a162 1
	printf("setfield: pos=%.8x len=%.8x ref=%s name=%s\n", bitpos, bitlen, ref->name, node->name);
d193 1
a193 1
	printf("setopregion: %.2x %.4x %.8x\n", addrtype, size, addr);
d236 1
a236 1
	printf("-- parsefield\n");
d246 1
a246 1
			printf("  type=%.2x  attr=%.2x\n", type, attr);
d750 1
a750 1
	printf("--- setnodevalue:\n");
d808 1
a808 1
		printf("aml_setnodeval: %.4x\n", node->opcode);
d936 1
a936 1
		printf("found eval object : %s, %.4x\n", root->name, root->opcode);
d956 1
a956 1
	printf("--- Evaluating object:\n"); 
d974 1
a974 1
		printf("@@@@@@@@@@@@@@@@@@@@@@@@@@@@ buffer: %.4x %.4x\n", i1, node->value.length);
d1073 1
a1073 1
		printf("package = %d\n", i1);
d1250 1
a1250 1
		printf("eval-method : %s  argcount:%d\n", 
d1262 1
a1262 1
			printf(" evalmeth: %s:%d\n", node->name, i1);
d1445 1
a1445 1
		printf("integer: %x\n", value->v_integer);
d1448 1
a1448 1
		printf("string: %s\n", value->v_string);
d1451 1
a1451 1
		printf("buffer: %d {\n", value->length);
d1453 1
a1453 1
			printf("%s0x%.2x", (idx ? "," : ""), value->v_buffer[idx]);
d1455 1
a1455 1
		printf("}\n");
d1458 1
a1458 1
		printf("package: %d {\n", value->length);
d1461 1
a1461 1
		printf("}\n");
d1472 1
a1472 1
	printf(" opcode:%.4x  mnem:%s %s %.2x ",
d1478 1
a1478 1
		printf("argcount:%d serialized:%d synclevel:%d",
d1486 1
a1486 1
		printf("access:%d lock:%d update:%d\n",
d1493 1
a1493 1
		printf("byte: %.2x", node->value.v_integer);
d1496 1
a1496 1
		printf("word: %.4x", node->value.v_integer);
d1499 1
a1499 1
		printf("dword: %.8x", node->value.v_integer);
d1502 1
a1502 1
		printf("string: %s", node->value.v_string);
d1505 1
a1505 1
	printf("\n");
d1525 1
a1525 1
				//printf(" parsing method %s:%d\n", pr->name, idx);
d1551 1
a1551 1
		printf(" %d ", depth);
d1553 1
a1553 1
			printf("..");
d1617 1
a1617 1
	printf("Value is: %s\n", node->name);
d1636 1
a1636 1
	printf(" : parsed %d AML bytes\n", length);
@


1.13
log
@make ACPI_DEBUG compile
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.12 2005/12/28 03:04:56 jordan Exp $ */
d939 1
a939 1
	return (0);
@


1.12
log
@Added new method evaluation code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.11 2005/12/16 00:08:53 jordan Exp $ */
a28 2

extern int acpi_debug;
@


1.11
log
@Moved DSDT AML parsing into parent ACPI driver
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.10 2005/12/14 03:46:38 marco Exp $ */
d46 14
d61 7
a67 5
u_int8_t *aml_decodelength(u_int8_t *, int *);
u_int8_t *aml_decodename(u_int8_t *, const char **, const char *);
u_int8_t *aml_getopcode(u_int8_t *, u_int16_t *);
u_int8_t *aml_parseargs(struct acpi_softc *, struct aml_node *, u_int8_t *, const char *);
u_int8_t *aml_parse_object(struct acpi_softc *, struct aml_node *, u_int8_t *);
d74 2
d77 2
a78 2
void aml_walktree(struct aml_node *, int);
void aml_walkroot(void);
d84 4
a87 1
void aml_setinteger(struct aml_value *, int, int64_t);
d90 1
a90 1
void aml_setfield(struct aml_value *, int, int, struct aml_node *);
d95 3
a97 2
void aml_setnodevalue(struct acpi_softc *, struct aml_node *, const struct aml_value *);
void aml_setnodeinteger(struct acpi_softc *, struct aml_node *, int64_t);
d102 35
d138 1
a138 1
aml_setinteger(struct aml_value *val, int size, int64_t value)
d142 1
a142 1
	val->length = size;
d162 1
a162 1
aml_setfield(struct aml_value *val, int bitpos, int bitlen, struct aml_node *ref)
d164 1
d195 1
d211 2
a212 2
u_int8_t *
aml_decodelength(u_int8_t *pos, int *length)
d215 6
d222 4
a225 1
	lcode = *(pos++);
d227 32
a258 14
	*length = (lcode & 0xF);
	switch(lcode >> 6) {
	case 0x01:
		*length += (pos[0] << 4L);
		return pos+1;
	case 0x02:
		*length += (pos[0] << 4L) + (pos[1] << 12L);
		return pos+2;
	case 0x03:
		*length += (pos[0] << 4L) + (pos[1] << 12L) + (pos[2] << 20L);
		return pos+3;
	default:
		*length = (lcode & 0x3F);
		return pos;
d263 2
a264 2
u_int8_t *
aml_decodename(u_int8_t *pos, const char **ref, const char *lbl)
d266 2
a267 2
	int count, pfxlen, idx;
	char *name;
d270 3
a272 3
	base = pos;
	if (*pos == AMLOP_ROOTCHAR) {
		pos++;
d274 2
a275 2
	while (*pos == AMLOP_PARENTPREFIX) {
		pos++;
a276 1
	pfxlen = pos - base;
d278 10
a287 6
	count = 1;
	if (*pos == AMLOP_MULTINAMEPREFIX) {
		count = *(++pos);
		pos++;
	}
	else if (*pos == AMLOP_DUALNAMEPREFIX) {
d289 6
a294 5
		pos++;
	}
	else if (*pos == 0) {
		count = 0;
		pos++;
d298 1
a298 2
	if (name == NULL) 
		return pos;
d300 3
a302 3
	if (pfxlen > 0) {
		memcpy(name, base, pfxlen);
	}
d304 7
a310 5
	base = name+pfxlen;
	for(idx=0; idx<count; idx++) {
		if (idx) *(base++) = '.';
		memcpy(base, pos, 4);
		pos += 4;
d313 1
a313 1
	*base = 0;
a315 6
	if (ref != NULL) {
		*ref = name;
	}
	else {
		free(name, M_DEVBUF);
	}
d317 3
a319 1
	return pos;
d485 2
a486 2
u_int8_t *
aml_getopcode(u_int8_t *pos, u_int16_t *opcode)
d489 1
d492 2
a493 3
	if (aml_isnamedop(*pos)) {
		*opcode = AMLOP_NAMECHAR;
		return pos;
d496 2
a497 2
	*opcode = *(pos++);
	twocode = (*opcode << 8L) + *pos;
d503 3
a505 3
	    *opcode == AMLOP_EXTPREFIX) {
		pos++;
		*opcode = twocode;
d508 1
a508 1
	return pos;
d548 1
a548 1
	{ AMLOP_RETURN,           "Return",          "o",     },
d554 17
a570 17
	{ AMLOP_INCREMENT,        "Increment",       "S",     },
	{ AMLOP_DECREMENT,        "Decrement",       "S",     },
	{ AMLOP_ADD,              "Add",             "iir",   },
	{ AMLOP_SUBTRACT,         "Subtract",        "iir",   },
	{ AMLOP_MULTIPLY,         "Multiply",        "iir",   },
	{ AMLOP_DIVIDE,           "Divide",          "iirr",  },
	{ AMLOP_SHL,              "ShiftLeft",       "iir",   },
	{ AMLOP_SHR,              "ShiftRight",      "iir",   },
	{ AMLOP_AND,              "And",             "iir",   },
	{ AMLOP_NAND,             "Nand",            "iir",   },
	{ AMLOP_OR,               "Or",              "iir",   },
	{ AMLOP_NOR,              "Nor",             "iir",   },
	{ AMLOP_XOR,              "Xor",             "iir",   },
	{ AMLOP_NOT,              "Not",             "ir",    },
	{ AMLOP_MOD,              "Mod",             "iir",   },
	{ AMLOP_FINDSETLEFTBIT,   "FindSetLeftBit",  "ir",    },
	{ AMLOP_FINDSETRIGHTBIT,  "FindSetRightBit", "ir",    },
d585 1
a585 1
	{ AMLOP_NAME,             "Name",            "No",  },
d587 1
a587 1
	{ AMLOP_ALIAS,            "Alias",           "Nn",  },
d589 1
a589 1
	{ AMLOP_OPREGION,         "OpRegion",        "Nfii" },
d591 2
a592 2
	{ AMLOP_DEVICE,           "Device",          "pNO" },
	{ AMLOP_POWERRSRC,        "Power Resource",  "pNbwO" },
d594 2
a595 2
	{ AMLOP_METHOD,           "Method",          "pNfT",  },
	{ AMLOP_PROCESSOR,        "Processor",       "pNbdbO", },
d597 2
a598 2
	{ AMLOP_INDEXFIELD,       "IndexField",      "pNnfF" },
	{ AMLOP_BANKFIELD,        "BankField",       "pNnifF" },
d609 4
a612 4
	{ AMLOP_TOINTEGER,        "ToInteger",       "tr",     },
	{ AMLOP_TOBUFFER,         "ToBuffer",        "tr",     },
	{ AMLOP_TODECSTRING,      "ToDecString",     "ir",     },
	{ AMLOP_TOHEXSTRING,      "ToHexString",     "ir",     }, 
d614 3
a616 3
	{ AMLOP_FROMBCD,          "FromBCD",         "ir",     },
	{ AMLOP_TOBCD,            "ToBCD",           "ir",     },
	{ AMLOP_MID,              "Mid",             "tiir",   },
d619 5
a623 5
	{ AMLOP_ACQUIRE,          "Acquire",         "Sw",     },
	{ AMLOP_RELEASE,          "Release",         "S",      },
	{ AMLOP_SIGNAL,           "Signal",          "S",      },
	{ AMLOP_WAIT,             "Wait",            "Si",     },
	{ AMLOP_RESET,            "Reset",           "S",      },
d625 1
a625 1
	{ AMLOP_INDEX,            "Index",           "ttr",    },
d629 2
a630 2
	{ AMLOP_REFOF,            "RefOf",           "S",      },
	{ AMLOP_CONDREFOF,        "CondRef",         "SS",     },
d635 7
a641 7
	{ AMLOP_LOAD,             "Load",            "NS" },
	{ AMLOP_UNLOAD,           "Unload",          "S" }, 
	{ AMLOP_STORE,            "Store",           "oS",     },
	{ AMLOP_CONCAT,           "Concat",          "ttr" },
	{ AMLOP_CONCATRES,        "ConcatRes",       "ttr" },
	{ AMLOP_NOTIFY,           "Notify",          "Si" },
	{ AMLOP_SIZEOF,           "Sizeof",          "S",      },
d643 2
a644 2
	{ AMLOP_OBJECTTYPE,       "ObjectType",      "S", },
	{ AMLOP_COPYOBJECT,       "CopyObject",      "tS" },
a647 4
int aml_evalnode(struct acpi_softc *, struct aml_node *, struct aml_value *, 
		 struct aml_value *);
void aml_copyvalue(struct aml_value *, const struct aml_value *);

d651 1
a651 1
	dst->type = src->type;
d664 3
d686 1
a686 1
struct aml_value aml_debug;
d688 3
a690 2
void
aml_setnodevalue(struct acpi_softc *sc, struct aml_node *node, const struct aml_value *val)
d692 6
d700 22
a721 2
		aml_copyvalue(&aml_debug, val);
		break;
a725 1
	case AMLOP_REVISION:
d730 2
a731 2
		printf("read-only\n");
		break;
d734 1
a734 1
		aml_copyvalue(&node->value, val);
d737 1
d741 2
a742 1
aml_setnodeinteger(struct acpi_softc *sc, struct aml_node *node, int64_t value)
d744 15
a758 1
	struct aml_value ival;
d760 11
a770 3
	aml_setinteger(&ival, 0, value);
	aml_setnodevalue(sc, node, &ival);
}
d772 10
a781 7
#if 0
int
aml_callmethod(struct acpi_softc *sc, struct aml_node *parent, const char *method, 
	       int nargs, struct aml_value *args, struct aml_value *result)
{
	struct aml_node *pnode;
	struct aml_value env;
d783 2
a784 3
	pnode = aml_findnode(sc, parent, method);
	if (pnode == NULL || pnode->type != AML_METHOD) 
		return (-1);
d786 10
a795 2
	if (nargs != AML_METHOD_ARGCOUNT(pnode->flag)) 
		return (-1);
d797 16
a812 6
	env.type = AML_OBJTYPE_METHOD;
	env.v_method.argcount = nargs;
	env.v_method.args     = args;
	env.v_method.locals   = malloc(sizeof(struct aml_value) * AML_NUM_LOCALS,
				       M_DEVBUF, M_WAITOK);
	aml_evalnode(sc, pnode, result, &env);
d815 3
a817 2
int
aml_readfield(struct acpi_softc *sc, const struct aml_value *field, struct aml_value *dest)
d819 1
a819 1
}
d821 2
a822 3
int
aml_writefield(struct acpi_softc *sc, const struct aml_value *field, const struct aml_value *src)
{
a823 1
#endif
d871 73
d945 1
a945 1
aml_evalnode(struct acpi_softc *sc, struct aml_node *node, struct aml_value *result, 
d948 2
a949 1
	struct  aml_value lhs, rhs, tmp, pkg, op1, op2;
d951 2
a952 1
	struct  aml_node *cflow;
d958 3
a960 1
	cflow = NULL;
d971 3
d975 7
a981 1
		aml_copyvalue(result, &node->value);
d985 1
a985 1
		aml_copyvalue(result, &aml_debug);
d988 4
d993 4
a996 4
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
		aml_evalnode(sc, childOf(node, 2), &tmp, env);
		aml_setprocessor(result, lhs.v_integer, rhs.v_integer, tmp.v_integer);
d1000 3
a1002 3
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
		aml_setopregion(result, node->flag, rhs.v_integer, lhs.v_integer);
d1006 2
a1007 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);		
		if (lhs.v_integer) {
d1017 1
a1017 1
			aml_evalnode(sc, cflow, result, env);
d1027 2
a1028 2
				aml_evalnode(sc, childOf(node, 0), &lhs, env);
				if (lhs.v_integer == 0) 
d1038 1
a1038 1
				aml_evalnode(sc, cflow, result, env);
d1045 1
a1045 1
		aml_evalnode(sc, childOf(node, 0), result, env);
d1056 2
a1057 3
		if (id < env->v_method.argcount) {
			aml_copyvalue(result, &env->v_method.args[id]);
		}
d1074 9
d1084 1
a1084 1
		
d1087 3
a1089 6
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		/* ASSERT: lhs.type == AML_OBJTYPE_INTEGER */
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_evalmath(node->opcode, lhs.v_integer, 0);
			aml_setnodeinteger(sc, childOf(node, 0), iresult);
		}
d1095 3
a1097 6
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		/* ASSERT: lhs.type == AML_OBJTYPE_INTEGER */
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_evalmath(node->opcode, lhs.v_integer, 0);
			aml_setnodeinteger(sc, childOf(node, 1), iresult);
		}
d1101 10
a1110 11
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
			/* Set remainder */
			iresult = aml_evalmath(AMLOP_MOD,    lhs.v_integer, rhs.v_integer);
			aml_setnodeinteger(sc, childOf(node, 2), iresult);

			/* Set quotient */
			iresult = aml_evalmath(node->opcode, lhs.v_integer, rhs.v_integer);
			aml_setnodeinteger(sc, childOf(node, 3), iresult);
		}
d1124 5
a1128 6
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_evalmath(node->opcode, lhs.v_integer, rhs.v_integer);
			aml_setnodeinteger(sc, childOf(node, 2), iresult);
		}
d1132 3
a1134 5
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_testlogical(node->opcode, lhs.v_integer, 0);
			aml_setinteger(result, 0, iresult);
		}
d1139 4
a1142 6
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER && rhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_testlogical(node->opcode, lhs.v_integer, rhs.v_integer);
			aml_setinteger(result, 0, iresult);
		}
d1151 2
a1152 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
d1159 1
a1159 1
		aml_setinteger(result, 0, iresult);
d1163 4
a1166 5
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		aml_evalnode(sc, childOf(node, 2), &rhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer, rhs.v_integer, childOf(node, 0));
		}
d1169 3
a1171 4
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer, 1, childOf(node, 0));
		}
d1174 3
a1176 4
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer * 8, 8, childOf(node, 0));
		}
d1179 3
a1181 4
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer * 8, 16, childOf(node, 0));
		}
d1184 3
a1186 4
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer * 8, 32, childOf(node, 0));
		}
d1189 3
a1191 4
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			aml_setfield(result, lhs.v_integer * 8, 64, childOf(node, 0));
		}
d1193 1
a1193 1

d1195 3
a1197 5
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_dec2bcd(lhs.v_integer);
			aml_setnodeinteger(sc, childOf(node, 1), iresult);
		}
d1200 3
a1202 5
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		if (lhs.type == AML_OBJTYPE_INTEGER) {
			iresult = aml_bcd2dec(lhs.v_integer);
			aml_setnodeinteger(sc, childOf(node, 1), iresult);
		}
d1207 1
a1207 1
			aml_evalnode(sc, childOf(node, 0), &lhs, env);
d1215 1
a1215 1
			aml_evalnode(sc, childOf(node, 0), &lhs, env);
d1222 3
a1224 3
		aml_evalnode(sc, childOf(node, 0), &tmp, env);
		aml_evalnode(sc, childOf(node, 1), &lhs, env);
		aml_evalnode(sc, childOf(node, 2), &rhs, env);
d1235 2
a1236 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		dnprintf(50, "aml_stall: %d\n", lhs.v_integer);
d1239 2
a1240 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		dnprintf(50, "aml_sleep: %d\n", lhs.v_integer);
d1243 2
a1244 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_setinteger(result, 1, lhs.type);
d1248 2
a1249 1
		cflow = node->sibling;
d1251 3
a1253 12
		/* node = aml_findnode(sc, node->mnem); */
		if (node->opcode == AMLOP_METHOD) {
			/* Arguments are following in the stream */
			lhs.v_method.argcount = AML_METHOD_ARGCOUNT(node->flag);
			lhs.v_method.args = malloc(sizeof(struct aml_value) * lhs.v_method.argcount, 
						   M_DEVBUF, M_WAITOK);
			lhs.v_method.locals = malloc(sizeof(struct aml_value) * AML_NUM_LOCALS,
						     M_DEVBUF, M_WAITOK);
			for (id=0; id<lhs.v_method.argcount; id++) {
				aml_evalnode(sc, cflow, &lhs.v_method.args[id], env);
				cflow = cflow->sibling;
			}
d1255 12
a1266 4
			/* Evaluate method itself */
			aml_evalnode(sc, node, result, &lhs);
			free(lhs.v_method.args, M_DEVBUF);
			free(lhs.v_method.locals, M_DEVBUF);
d1268 2
a1269 5
		break;

	case AMLOP_METHOD:
		for (cflow=childOf(node, 0); cflow; cflow=cflow->sibling) {
			aml_evalnode(sc, cflow, result, env);
d1274 2
a1275 2
		aml_evalnode(sc, childOf(node, 0), &lhs, env);
		aml_evalnode(sc, childOf(node, 1), &rhs, env);
d1281 7
d1289 6
a1294 6
		aml_evalnode(sc, childOf(node, 0), &pkg, env);
		aml_evalnode(sc, childOf(node, 1), &op1, env);
		aml_evalnode(sc, childOf(node, 2), &lhs, env);
		aml_evalnode(sc, childOf(node, 3), &op2, env);
		aml_evalnode(sc, childOf(node, 4), &lhs, env);
		aml_evalnode(sc, childOf(node, 5), &tmp, env);
d1297 3
a1299 3
			for (idx=tmp.v_integer; idx < pkg.length; idx++) {
				if (aml_match(sc, op1.v_integer, &pkg.v_package[idx], &lhs) ||
				    aml_match(sc, op2.v_integer, &pkg.v_package[idx], &rhs)) {
d1303 1
d1305 1
a1305 1
			aml_setinteger(result, 0, iresult);
d1316 2
a1317 3
u_int8_t *
aml_parseargs(struct acpi_softc *sc, struct aml_node *node, u_int8_t *pos, 
	      const char *arg)
d1319 2
a1320 2
	int len;
	u_int8_t *nxtpos;
a1321 1
	nxtpos = pos;
d1323 1
d1326 1
a1326 1
			node->flag = *(u_int8_t *)pos;
a1340 1
			nxtpos = pos+1;
d1344 1
a1345 1
			aml_setinteger(&node->value, 1, (int8_t)node->opcode);
d1348 2
a1349 3
			dnprintf(50, " byte: %x\n", *(u_int8_t *)pos);
			if (node->opcode == AMLOP_BYTEPREFIX) {
				aml_setinteger(&node->value, 1, *(int8_t *)pos);
d1351 2
a1352 1
			nxtpos = pos+1;
d1355 2
a1356 3
			dnprintf(50, " word: %x\n", *(u_int16_t *)pos);
			if (node->opcode == AMLOP_WORDPREFIX) {
				aml_setinteger(&node->value, 2, (int16_t)letoh16(*(u_int16_t *)pos));
d1358 2
a1359 1
			nxtpos = pos+2;
d1362 2
a1363 3
			dnprintf(50, " dword: %x\n", *(u_int32_t *)pos);
			if (node->opcode == AMLOP_DWORDPREFIX) {
				aml_setinteger(&node->value, 4, (int32_t)letoh32(*(u_int32_t *)pos));
d1365 2
a1366 1
			nxtpos = pos+4;
a1368 1
			dnprintf(50, " qword: %x\n", *(u_int32_t *)pos);
d1370 1
a1370 1
				aml_setinteger(&node->value, 8, (int64_t)letoh64(*(u_int64_t *)pos));
d1372 2
a1373 1
			nxtpos = pos+8;
d1377 1
a1377 1
			nxtpos = node->end;
d1381 2
a1382 2
			aml_setbuffer(&node->value, node->end - pos, pos);
			nxtpos = node->end;
d1385 2
a1386 4
			dnprintf(50, " string: %s\n", pos);
			len = strlen((const char *)pos);
			aml_setstring(&node->value, (const char *)pos);
			nxtpos = pos + len + 1;
d1389 1
a1389 1
			nxtpos = aml_decodename(pos, &node->name, "name");
d1392 2
a1393 1
			nxtpos = aml_decodename(pos, NULL, "ref");
d1396 2
a1397 2
			nxtpos = aml_decodelength(pos, &len);
			node->end = pos + len;
a1399 1
		case AML_ARG_DATAOBJ:
d1401 2
a1402 3
		case AML_ARG_RESULT:
		case AML_ARG_SUPERNAME:
			nxtpos = aml_parse_object(sc, node, pos);
d1405 4
a1408 3
		case AML_ARG_DATAOBJLIST:
			while (nxtpos && nxtpos < node->end) {
				nxtpos = aml_parse_object(sc, node, nxtpos);
d1410 1
d1412 1
a1416 1
		pos = nxtpos;
d1421 1
a1421 1
	return pos;
d1440 72
a1511 2
u_int8_t *
aml_parse_object(struct acpi_softc *sc, struct aml_node *parent, u_int8_t *pos)
d1514 2
a1515 7
	u_int8_t  *nxtpos;
	struct aml_node *node;

	node = malloc(sizeof(struct aml_node), M_DEVBUF, M_WAITOK);
	if (node == NULL) 
		return pos;
	memset(node, 0, sizeof(struct aml_node));
d1518 1
a1518 2
	node->start = pos;
	nxtpos = aml_getopcode(pos, &node->opcode);
d1520 12
a1531 3
		aml_addchildnode(parent, node);
		dnprintf(50, "opcode: xxxx <name>\n");
		return aml_decodename(pos, &node->mnem, "embed");
a1534 2
			dnprintf(50, "opcode: %.4x = %s\n", node->opcode, optab->mnem);
			aml_addchildnode(parent, node);
d1536 2
a1537 1
			return aml_parseargs(sc, node, nxtpos, optab->args);
d1541 1
a1541 1
	printf("Invalid AML Opcode : %.4x\n", node->opcode);
d1557 1
a1557 32
		printf(" opcode:%.4x  mnem:%s %s ",
		       node->opcode, node->mnem, node->name ? node->name : "");
		switch(node->opcode) {
		case AMLOP_METHOD:
			printf(" argcount:%d serialized:%d synclevel:%d",
			       AML_METHOD_ARGCOUNT(node->flag),
			       AML_METHOD_SERIALIZED(node->flag),
			       AML_METHOD_SYNCLEVEL(node->flag));
			break;
		case AMLOP_FIELD:
		case AMLOP_BANKFIELD:
		case AMLOP_INDEXFIELD:
			dnprintf(50, " access:%d lock:%d update:%d\n",
				AML_FIELD_ACCESS(node->flag),
				AML_FIELD_LOCK(node->flag),
				AML_FIELD_UPDATE(node->flag));
			break;

		case AMLOP_BYTEPREFIX:
			printf("byte: %.2x", node->value.v_integer);
			break;
		case AMLOP_WORDPREFIX:
			printf("word: %.4x", node->value.v_integer);
			break;
		case AMLOP_DWORDPREFIX:
			printf("dword: %.8x", node->value.v_integer);
			break;
		case AMLOP_STRINGPREFIX:
			printf("string: %s", node->value.v_string);
			break;
		}
		printf("\n");
a1558 1

a1562 2
struct aml_node aml_root;

d1574 2
d1577 6
a1582 2
		if (node->name && !strcmp(name, node->name)) 
			cbproc(node, arg);
d1608 16
d1627 1
a1627 1
	u_int8_t  *pos, *nxtpos;
d1629 8
a1636 2
	for (pos = start; pos && pos < start+length; pos=nxtpos) {
		nxtpos = aml_parse_object(sc, &aml_root, pos);
@


1.10
log
@Adjust debug printing levels to something more sane.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.9 2005/12/13 07:23:34 marco Exp $ */
a29 19
struct dsdt_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
};

int	dsdtmatch(struct device *, void *, void *);
void	dsdtattach(struct device *, struct device *, void *);
int	dsdt_parse_aml(struct dsdt_softc *, u_int8_t *, u_int32_t);

struct cfattach dsdt_ca = {
	sizeof(struct dsdt_softc), dsdtmatch, dsdtattach
};

struct cfdriver dsdt_cd = {
	NULL, "dsdt", DV_DULL
};

a31 32
int
dsdtmatch(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args		*aaa = aux;
	struct acpi_table_header	*hdr;

	/* if we do not have a table, it is not us */
	if (aaa->aaa_table == NULL)
		return (0);

	/* if it is an DSDT table, we can attach */
	hdr = (struct acpi_table_header *)aaa->aaa_table;
	if (memcmp(hdr->signature, DSDT_SIG, sizeof(DSDT_SIG) - 1) == 0)
		return (1);

	/* Attach SSDT tables */
	if (memcmp(hdr->signature, SSDT_SIG, sizeof(SSDT_SIG) - 1) == 0)
		return (1);

	return (0);
}

void
dsdtattach(struct device *parent, struct device *self, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct dsdt_softc	*sc = (struct dsdt_softc *) self;
	struct acpi_dsdt	*dsdt = (struct acpi_dsdt *)aa->aaa_table;

	dsdt_parse_aml(sc, dsdt->aml, dsdt->hdr_length - sizeof(dsdt->hdr));
}

d50 2
a51 2
u_int8_t *aml_parseargs(struct dsdt_softc *, struct aml_node *, u_int8_t *, const char *);
u_int8_t *aml_parse_object(struct dsdt_softc *, struct aml_node *, u_int8_t *);
d74 2
a75 2
void aml_setnodevalue(struct dsdt_softc *, struct aml_node *, const struct aml_value *);
void aml_setnodeinteger(struct dsdt_softc *, struct aml_node *, int64_t);
d77 2
a78 2
int aml_match(struct dsdt_softc *, int, const struct aml_value *, const struct aml_value *);
int aml_cmpobj(struct dsdt_softc *, const struct aml_value *, const struct aml_value *);
d561 1
a561 1
int aml_evalnode(struct dsdt_softc *, struct aml_node *, struct aml_value *, 
d603 1
a603 1
aml_setnodevalue(struct dsdt_softc *sc, struct aml_node *node, const struct aml_value *val)
d628 1
a628 1
aml_setnodeinteger(struct dsdt_softc *sc, struct aml_node *node, int64_t value)
d638 1
a638 1
aml_callmethod(struct dsdt_softc *sc, struct aml_node *parent, const char *method, 
d660 1
a660 1
aml_readfield(struct dsdt_softc *sc, const struct aml_value *field, struct aml_value *dest)
d665 1
a665 1
aml_writefield(struct dsdt_softc *sc, const struct aml_value *field, const struct aml_value *src)
d670 1
a670 1
int aml_cmpobj(struct dsdt_softc *sc, const struct aml_value *lhs,
d688 1
a688 1
aml_match(struct dsdt_softc *sc, int mtype, const struct aml_value *lhs, 
d717 1
a717 1
aml_evalnode(struct dsdt_softc *sc, struct aml_node *node, struct aml_value *result, 
d1081 1
a1081 1
aml_parseargs(struct dsdt_softc *sc, struct aml_node *node, u_int8_t *pos, 
d1208 1
a1208 1
aml_parse_object(struct dsdt_softc *sc, struct aml_node *parent, u_int8_t *pos)
d1332 1
a1332 1
dsdt_parse_aml(struct dsdt_softc *sc, u_int8_t *start, u_int32_t length)
@


1.9
log
@Add glue to attach devices to apci.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.8 2005/12/13 04:16:56 jordan Exp $ */
d275 1
a275 1
	dprintf(" acpi_name (%s): %s\n", lbl, name);
d1056 1
a1056 1
		dprintf("aml_stall: %d\n", lhs.v_integer);
d1060 1
a1060 1
		dprintf("aml_sleep: %d\n", lhs.v_integer);
d1144 1
a1144 1
				dprintf(" method %s %.2x argcount:%d serialized:%d synclevel:%d\n",
d1151 1
a1151 1
				dprintf(" field %s %.2x access:%d lock:%d update:%d\n",
d1161 1
a1161 1
			dprintf(" ibyte: %x\n", (int8_t)node->opcode);
d1165 1
a1165 1
			dprintf(" byte: %x\n", *(u_int8_t *)pos);
d1172 1
a1172 1
			dprintf(" word: %x\n", *(u_int16_t *)pos);
d1179 1
a1179 1
			dprintf(" dword: %x\n", *(u_int32_t *)pos);
d1186 1
a1186 1
			dprintf(" qword: %x\n", *(u_int32_t *)pos);
d1193 1
a1193 1
			dprintf(" fieldlist\n");
d1197 1
a1197 1
			dprintf(" bytelist\n");
d1202 1
a1202 1
			dprintf(" string: %s\n", pos);
d1275 1
a1275 1
		dprintf("opcode: xxxx <name>\n");
d1280 1
a1280 1
			dprintf("opcode: %.4x = %s\n", node->opcode, optab->mnem);
d1315 1
a1315 1
			dprintf(" access:%d lock:%d update:%d\n",
@


1.8
log
@Added new objtype values to amltypes
Added evaluation for match object, logical operations, conversions
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.7 2005/12/09 02:27:28 jordan Exp $ */
d28 1
d49 1
a49 8
#ifdef AML_DEBUG
int amldebug=3;
#define dprintf(x...)     do { if (amldebug) printf(x); } while(0)
#define dnprintf(n,x...)  do { if (amldebug > (n)) printf(x); } while(0)
#else
#define dprintf(x...)
#define dnprintf(n,x...)
#endif
a111 3
int aml_find_node(struct aml_node *, const char *, 
		  void (*)(struct aml_node *, void *),
		  void *);
a1362 3
void foundhid(struct aml_node *, void *);
const char *aml_eisaid(u_int32_t pid);

a1381 20
void
foundhid(struct aml_node *node, void *arg)
{
	const char *dev;

	printf("found hid device: %s ", node->parent->name);
	switch(node->child->value.type) {
	case AML_OBJTYPE_STRING:
		dev = node->child->value.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(node->child->value.v_integer);
		break;
	default:
		dev = "unknown";
		break;
	}
	printf("  device: %s\n", dev);
}

a1390 2

	/* aml_find_node(aml_root.child, "_HID", foundhid, NULL); */
@


1.7
log
@Added aml_values for nodes
Started adding code for aml interpreter
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.6 2005/12/08 00:01:13 jordan Exp $ */
d122 1
a122 1
long aml_evalmath(u_int16_t, long, long);
d132 1
d135 4
d144 1
a145 1
	val->v_integer = value;
d179 9
a196 1
	
d198 5
a202 5
	val->v_gas.address_space_id = addrtype;
	val->v_gas.register_bit_width = 0;
	val->v_gas.register_bit_offset = 0;
	val->v_gas.access_size = size;
	val->v_gas.address = addr;
d377 2
a378 2
long
aml_evalmath(u_int16_t opcode, long lhs, long rhs)
d657 1
d687 89
d780 2
a781 2
	struct  aml_value lhs, rhs, tmp;
	long    iresult, id;
d785 3
d807 7
d823 1
d827 1
d831 1
d838 9
a846 3
		do {
			aml_evalnode(sc, childOf(node, 0), &lhs, env);
			if (lhs.v_integer == 0) 
d848 6
a853 11
			cflow = childOf(node, 1);
			while (cflow) {
				if (cflow->opcode == AMLOP_BREAK) {
					cflow = NULL;
				}
				else if (cflow->opcode == AMLOP_CONTINUE) {
					break;
				}
				else {
					aml_evalnode(sc, cflow, result, env);
				}
d856 1
a856 1
		} while (cflow);
d898 1
d902 1
d909 1
d916 9
a924 2
		iresult = aml_evalmath(AMLOP_MOD,    lhs.v_integer, rhs.v_integer);
		iresult = aml_evalmath(node->opcode, lhs.v_integer, rhs.v_integer);
a936 1
	case AMLOP_NOT:
d940 12
a951 1
		iresult = aml_evalmath(node->opcode, lhs.v_integer, rhs.v_integer);
d956 9
a967 1
	case AMLOP_LEQUAL:
d978 1
a980 1

d1021 4
a1024 1
		iresult = aml_dec2bcd(lhs.v_integer);
d1028 4
a1031 1
		iresult = aml_bcd2dec(lhs.v_integer);
d1037 2
a1038 1
			snprintf(tmpstr, AML_INTSTRLEN, "%d", lhs.v_integer);
d1045 2
a1046 1
			snprintf(tmpstr, AML_INTSTRLEN, "%x", lhs.v_integer);
d1054 3
d1077 54
a1130 5
		/*
		  pnode = aml_findnode(sc, node->mnem);
		  if (pnode->opcode == AMLOP_METHOD) {
		  }
		*/
d1153 1
a1153 1
				dprintf(" method %s %x argcount:%d serialized:%d synclevel:%d\n",
d1160 1
a1160 1
				dprintf(" field %s %x access:%d lock:%d update:%d\n",
d1337 1
a1337 1
			printf("dword: %.4x", node->value.v_integer);
@


1.6
log
@Fixed name parsing for zero strings
Added _HID device detection and PNP device decoding
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.5 2005/12/07 22:34:20 jordan Exp $ */
a88 14
struct aml_node
{
	struct aml_node *parent;
	struct aml_node *child;
	struct aml_node *sibling;

	u_int16_t   opcode;
	u_int8_t   *start;
	u_int8_t   *end;
	u_int8_t    flag;
	const char *name;
	const char *mnem;
};

d96 10
a105 2
int aml_isnamedop(uint16_t);u_int8_t *aml_decodelength(u_int8_t *, int *);
u_int8_t *aml_decodename(u_int8_t *, const char **);
d109 6
a114 2
int aml_lsb(uint32_t val);
int aml_msb(uint32_t val);
d123 9
a131 1
int  aml_evallogical(u_int16_t, long, long);
d133 57
a189 10
#if 0
void aml_eval_opregion(struct dsdt_softc *sc, struct aml_value *result, 
		       struct aml_node *node)
{
	result->type = AML_TYPE_GAS;
	result->v_gas.address_space_id = node->flag;
	result->v_gas.register_bit_width = ..;
	result->v_gas.register_bit_offset = ..;
	result->v_gas.access_size = aml_eval_integer(result, node->child[0]);
	result->v_gas.address = aml_eval_integer(result, node->child[1]);
a190 1
#endif
d223 1
d225 1
a225 1
aml_decodename(u_int8_t *pos, const char **ref)
d271 1
a271 1
	dprintf("acpi_name: %s\n", name);
d284 1
a284 1
aml_isnamedop(uint16_t opcode)
d301 34
d336 2
a337 1
int aml_lsb(uint32_t val)
d350 2
a351 1
int aml_msb(uint32_t val)
d407 6
d415 1
a415 1
aml_evallogical(u_int16_t opcode, long lhs, long rhs)
d446 1
a446 1
aml_getopcode(u_int8_t *pos, uint16_t *opcode)
d473 3
a475 3
	{ AMLOP_ONES,             "Ones",            "",   },
	{ AMLOP_ZERO,             "Zero",            "", },
	{ AMLOP_ONE,              "One",             "",  },
d508 1
a508 2
	{ AMLOP_RETURN,           "Return",          "t",     },

d544 1
d546 2
a547 1
	{ AMLOP_SCOPE,            "Scope",           "pNT" },
d550 1
d557 2
a558 5
	{ AMLOP_INDEXFIELD,       "IndexField",      "pNnbF" },
	{ AMLOP_BANKFIELD,        "BankField",       "pNnibF" },
	{ AMLOP_MUTEX,            "Mutex",           "Nf",  },
	{ AMLOP_EVENT,            "Event",           "N",   },
	{ AMLOP_ALIAS,            "Alias",           "Nn",  },
d597 1
a597 1
	{ AMLOP_STORE,            "Store",           "tS",     },
d604 1
a604 1
	{ AMLOP_COPYOBJECT,       "CopyObject",      "tn" },
d608 327
d936 2
a937 1
aml_parseargs(struct dsdt_softc *sc, struct aml_node *node, u_int8_t *pos, const char *arg)
a945 1
			dprintf("flag: %x\n", *(u_int8_t *)pos);
d947 14
d963 5
d969 4
a972 1
			dprintf("byte: %x\n", *(u_int8_t *)pos);
d976 4
a979 1
			dprintf("word: %x\n", *(u_int16_t *)pos);
d983 4
a986 1
			dprintf("dword: %x\n", *(u_int32_t *)pos);
d990 4
a993 1
			dprintf("qword: %x\n", *(u_int32_t *)pos);
d997 1
a997 1
			dprintf("fieldlist\n");
d1001 2
a1002 1
			dprintf("bytelist\n");
d1006 1
a1006 1
			dprintf("string: %s\n", pos);
d1008 1
d1012 4
a1015 1
			nxtpos = aml_decodename(pos, &node->name);
d1042 1
d1079 2
a1080 1
		return aml_decodename(pos, &node->mnem);
d1110 15
d1126 1
a1126 1
			printf("byte: %.2x", *(u_int8_t *)(node->start+1));
d1129 1
a1129 1
			printf("word: %.4x", *(u_int16_t *)(node->start+1));
d1132 1
a1132 1
			printf("dword: %.4x", *(u_int32_t *)(node->start+1));
d1135 1
a1135 1
			printf("string: %s", (const char *)(node->start+1));
d1168 1
a1168 1
const char *aml_pnpid(uint32_t pid);
d1173 1
a1173 1
aml_pnpid(uint32_t pid)
d1175 1
a1175 1
	static char pnpid[8];
d1177 8
a1184 8
	pnpid[0] = '@@' + ((pid >> 2) & 0x1F);
	pnpid[1] = '@@' + ((pid << 3) & 0x18) + ((pid >> 13) & 0x7);
	pnpid[2] = '@@' + ((pid >> 8) & 0x1F);
	pnpid[3] = hext[(pid >> 20) & 0xF];
	pnpid[4] = hext[(pid >> 16) & 0xF];
	pnpid[5] = hext[(pid >> 28) & 0xF];
	pnpid[6] = hext[(pid >> 24) & 0xF];
	pnpid[7] = 0;
d1186 1
a1186 1
	return pnpid;
d1195 3
a1197 3
	switch(node->child->opcode) {
	case AMLOP_STRINGPREFIX:
		dev = (const char *)node->child->start+1;
d1199 2
a1200 2
	case AMLOP_BYTEPREFIX:
		dev = aml_pnpid(*(u_int8_t *)(node->child->start+1));
d1202 2
a1203 5
	case AMLOP_WORDPREFIX:
		dev = aml_pnpid(*(u_int16_t *)(node->child->start+1));
		break;
	case AMLOP_DWORDPREFIX:
		dev = aml_pnpid(*(u_int32_t *)(node->child->start+1));
d1218 2
@


1.5
log
@Fixed name parse errors
Added nodes for tree structure of AML
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.4 2005/12/07 08:09:05 jordan Exp $ */
d100 1
d118 5
d187 1
a187 1
	count = 0;
d196 3
a198 2
	else if (*pos == AMLOP_NAMECHAR || (*pos >= 'A' && *pos <= 'Z')) {
		count = 1;
d202 22
a223 20
	if (name != NULL) {
		if (pfxlen > 0) {
			memcpy(name, base, pfxlen);
		}
		/* Copy name segments in chunks of 4 bytes */
		base = name+pfxlen;
		for(idx=0; idx<count; idx++) {
			if (idx) *(base++) = '.';
			memcpy(base, pos, 4);
			pos += 4;
			base += 4;
		}
		*base = 0;
		dprintf("acpi_name: %s\n", name);
		if (ref != NULL) {
			*ref = name;
		}
		else {
			free(name, M_DEVBUF);
		}
d410 1
a410 1
	{ AMLOP_WHILE,            "While",           "ptT",  },
d492 1
a492 1
	{ AMLOP_PACKAGE,          "Package",         "pfT",    },
d558 1
a558 1
			nxtpos = aml_decodename(pos, NULL);
d620 2
a621 1
		return aml_decodename(pos, &node->name);
d627 1
a627 1

d638 100
a741 1
	struct aml_node root;
a742 1
	memset(&root, 0, sizeof(root));
d744 1
a744 1
		nxtpos = aml_parse_object(sc, &root, pos);
d747 1
@


1.4
log
@Parsing fieldlist and varobject
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.3 2005/12/07 07:46:51 jordan Exp $ */
a71 1
#if 1
a74 1
#endif
d89 13
d109 2
a110 3
int aml_isnamedop(uint16_t);
u_int8_t *aml_decodelength(u_int8_t *, int *);
u_int8_t *aml_decodename(u_int8_t *);
d112 21
a132 2
u_int8_t *aml_parseargs(struct dsdt_softc *, u_int8_t *, const char *);
u_int8_t *aml_parse_object(struct dsdt_softc *, u_int8_t *);
d166 1
a166 1
aml_decodename(u_int8_t *pos)
d168 1
a168 1
	int count;
d170 1
d172 1
a173 1
		dprintf(" root ");
a176 1
		dprintf(" parent ");
d179 1
d181 1
a181 1
	count = 1;
a182 1
		dprintf(" multi ");
d186 1
a186 2
	if (*pos == AMLOP_DUALNAMEPREFIX) {
		dprintf(" dual ");
d190 3
d194 1
a194 1
	name = malloc(count * 4 + 1, M_DEVBUF, M_WAITOK);
d196 12
a207 2
		memset(name, 0, count * 4 + 1);
		memcpy(name, pos, count * 4);
d209 6
a214 1
		free(name, M_DEVBUF);
a215 1
	pos += count*4;
d239 97
d411 2
a412 2
	{ AMLOP_INCREMENT,        "Increment",       "v",     },
	{ AMLOP_DECREMENT,        "Decrement",       "v",     },
d448 1
a448 1
	{ AMLOP_METHOD,           "Method",          "pNmT",  },
d476 5
a480 5
	{ AMLOP_ACQUIRE,          "Acquire",         "vw",     },
	{ AMLOP_RELEASE,          "Release",         "v",      },
	{ AMLOP_SIGNAL,           "Signal",          "v",      },
	{ AMLOP_WAIT,             "Wait",            "vi",     },
	{ AMLOP_RESET,            "Reset",           "v",      },
d486 2
a487 2
	{ AMLOP_REFOF,            "RefOf",           "v",      },
	{ AMLOP_CONDREFOF,        "CondRef",         "vv",     },
d492 3
a494 3
	{ AMLOP_LOAD,             "Load",            "Nv" },
	{ AMLOP_UNLOAD,           "Unload",          "v" }, 
	{ AMLOP_STORE,            "Store",           "tv",     },
d497 2
a498 2
	{ AMLOP_NOTIFY,           "Notify",          "vi" },
	{ AMLOP_SIZEOF,           "Sizeof",          "v",      },
d500 1
a500 1
	{ AMLOP_OBJECTTYPE,       "ObjectType",      "v", },
a504 7
#if 0
u_int8_t *aml_createinteger(uint8_t *pos, int len)
{
	return pos+len;
}
#endif

d506 1
a506 1
aml_parseargs(struct dsdt_softc *sc, u_int8_t *pos, const char *arg)
d509 1
a509 1
	u_int8_t *nxtpos, *endpos;
a510 1
	endpos = NULL;
d514 5
a519 2
		case AML_ARG_FIELDFLAG:
		case AML_ARG_METHODFLAG:
d537 1
a537 1
			nxtpos = endpos;
d541 1
a541 1
			nxtpos = endpos;
d549 1
a549 2
			dprintf("getting name..\n");
			nxtpos = aml_decodename(pos);
d553 1
a553 1
			endpos = pos + len;
d555 1
a556 1
		case AML_ARG_INTEGER:
d559 2
a560 2
		case AML_ARG_VAROBJ:
			nxtpos = aml_parse_object(sc, pos);
d564 2
a565 2
			while (nxtpos && nxtpos < endpos) {
				nxtpos = aml_parse_object(sc, nxtpos);
d579 16
d596 1
a596 1
aml_parse_object(struct dsdt_softc *sc, u_int8_t *pos)
d600 6
a605 1
	u_int16_t  opcode;
d608 4
a611 3
	nxtpos = aml_getopcode(pos, &opcode);
	if (opcode == AMLOP_NAMECHAR) {
		return aml_decodename(pos);
d614 5
a618 3
		if  (optab->opcode == opcode) {
			dprintf("opcode: %.4x = %s\n", opcode, optab->mnem);
			return aml_parseargs(sc, nxtpos, optab->args);
d622 3
a624 1
	printf("Invalid AML Opcode : %.4x\n", opcode);
d632 1
d634 1
d636 1
a636 1
		nxtpos = aml_parse_object(sc, pos);
@


1.3
log
@Parses DSDT table
some cleanup
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.2 2005/12/07 04:28:29 marco Exp $ */
d49 1
a49 1
int amldebug=0;
d72 1
a72 1
#if 0
d398 4
d423 1
d433 1
a433 1
			dprintf("Unknown arg: %c\n", *arg);
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.c,v 1.1 2005/12/07 04:24:31 jordan Exp $ */
d27 1
d48 9
d69 8
a76 2
	if (memcmp(hdr->signature, DSDT_SIG, sizeof(DSDT_SIG) - 1) != 0)
		return (0);
d78 1
a78 1
	return (1);
d84 1
a85 1
	struct acpi_attach_args	*aa = aux;
d91 370
d464 6
@


1.1
log
@Add DSDT table for AML Parser
DO NOT USE YET
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d35 3
a37 3
int dsdtmatch(struct device *, void *, void *);
void dsdtattach(struct device *, struct device *, void *);
int dsdt_parse_aml(struct dsdt_softc *, u_int8_t *, u_int32_t);
d50 2
a51 2
	struct acpi_attach_args *aaa = aux;
	struct acpi_table_header *hdr;
d53 1
a53 3
	/*
	 * If we do not have a table, it is not us
	 */
d57 1
a57 3
	/*
	 * If it is an DSDT table, we can attach
	 */
d68 3
a70 3
	struct dsdt_softc *sc = (struct dsdt_softc *) self;
	struct acpi_attach_args *aa = aux;
	struct acpi_dsdt *dsdt = (struct acpi_dsdt *)aa->aaa_table;
@

