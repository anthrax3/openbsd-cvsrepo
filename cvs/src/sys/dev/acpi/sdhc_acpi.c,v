head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.2
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.2
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.1.0.2
	OPENBSD_5_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.10.25.06.48.58;	author pirofti;	state Exp;
branches;
next	1.8;
commitid	Z8xhqpkgqCmi8yVl;

1.8
date	2016.04.30.11.32.23;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	idV1JJlqFozdGODX;

1.7
date	2016.04.26.19.10.10;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	tr9NFwN9cFfwe6BG;

1.6
date	2016.04.02.00.34.47;	author jsg;	state Exp;
branches;
next	1.5;
commitid	8QnXtI2isFC8GIbE;

1.5
date	2016.03.30.10.00.08;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	ty7V44jaxh4Ldnz5;

1.4
date	2016.03.29.18.04.09;	author kettenis;	state Exp;
branches;
next	1.3;
commitid	fsGdBUJ2kkD10xJo;

1.3
date	2016.03.28.19.15.43;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	gaFjLVc1gZ45AZhi;

1.2
date	2016.03.28.17.53.26;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	mJwbNJZlVJcJuCJQ;

1.1
date	2016.01.11.07.36.10;	author kettenis;	state Exp;
branches;
next	;
commitid	Jxj5zO1Gs9vOWUOW;


desc
@@


1.9
log
@Add the resource index to aml_parse_resource() callback function.

This is needed by an upcoming acpiec commit that handles machines breaking
the current ACPI specifications.

Change suggested by and ok kettenis@@, guenther@@
@
text
@/*	$OpenBSD: sdhc_acpi.c,v 1.8 2016/04/30 11:32:23 kettenis Exp $	*/
/*
 * Copyright (c) 2016 Mark Kettenis
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>
#undef DEVNAME
#include <dev/sdmmc/sdhcreg.h>
#include <dev/sdmmc/sdhcvar.h>
#include <dev/sdmmc/sdmmcvar.h>

extern struct bus_dma_tag pci_bus_dma_tag;

struct sdhc_acpi_softc {
	struct sdhc_softc sc;
	struct acpi_softc *sc_acpi;
	struct aml_node *sc_node;

	bus_space_tag_t sc_memt;
	bus_space_handle_t sc_memh;
	bus_addr_t sc_addr;
	bus_size_t sc_size;

	int sc_irq;
	int sc_irq_flags;
	void *sc_ih;

	struct aml_node *sc_gpio_int_node;
	struct aml_node *sc_gpio_io_node;
	uint16_t sc_gpio_int_pin;
	uint16_t sc_gpio_int_flags;
	uint16_t sc_gpio_io_pin;

	struct sdhc_host *sc_host;
};

int	sdhc_acpi_match(struct device *, void *, void *);
void	sdhc_acpi_attach(struct device *, struct device *, void *);

struct cfattach sdhc_acpi_ca = {
	sizeof(struct sdhc_acpi_softc), sdhc_acpi_match, sdhc_acpi_attach
};

const char *sdhc_hids[] = {
	"PNP0D40",
	"INT33BB",
	"80860F14",
	"PNP0FFF",
	NULL
};

int	sdhc_acpi_parse_resources(int, union acpi_resource *, void *);
int	sdhc_acpi_card_detect(struct sdhc_softc *);
int	sdhc_acpi_card_detect_intr(void *);

int
sdhc_acpi_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args *aaa = aux;
	struct cfdata *cf = match;

	return acpi_matchhids(aaa, sdhc_hids, cf->cf_driver->cd_name);
}

void
sdhc_acpi_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpi_attach_args *aaa = aux;
	struct sdhc_acpi_softc *sc = (struct sdhc_acpi_softc *)self;
	struct aml_value res;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_node = aaa->aaa_node;
	printf(": %s", sc->sc_node->name);

	if (aml_evalname(sc->sc_acpi, sc->sc_node, "_CRS", 0, NULL, &res)) {
		printf(", can't find registers\n");
		return;
	}

	aml_parse_resource(&res, sdhc_acpi_parse_resources, sc);
	printf(" addr 0x%lx/0x%lx", sc->sc_addr, sc->sc_size);
	if (sc->sc_addr == 0 || sc->sc_size == 0) {
		printf("\n");
		return;
	}

	printf(" irq %d", sc->sc_irq);

	sc->sc_memt = aaa->aaa_memt;
	if (bus_space_map(sc->sc_memt, sc->sc_addr, sc->sc_size, 0,
	    &sc->sc_memh)) {
		printf(", can't map registers\n");
		return;
	}

	sc->sc_ih = acpi_intr_establish(sc->sc_irq, sc->sc_irq_flags, IPL_BIO,
	    sdhc_intr, sc, sc->sc.sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(", can't establish interrupt\n");
		return;
	}

	if (sc->sc_gpio_io_node && sc->sc_gpio_io_node->gpio) {
		sc->sc.sc_card_detect = sdhc_acpi_card_detect;
		printf(", gpio");
	}

	if (sc->sc_gpio_int_node && sc->sc_gpio_int_node->gpio) {
		struct acpi_gpio *gpio = sc->sc_gpio_int_node->gpio;

		gpio->intr_establish(gpio->cookie, sc->sc_gpio_int_pin,
		    sc->sc_gpio_int_flags, sdhc_acpi_card_detect_intr, sc);
	}

	printf("\n");

	sc->sc.sc_host = &sc->sc_host;
	sc->sc.sc_dmat = &pci_bus_dma_tag;
	sdhc_host_found(&sc->sc, sc->sc_memt, sc->sc_memh, sc->sc_size, 1, 0);
}

int
sdhc_acpi_parse_resources(int crsidx, union acpi_resource *crs, void *arg)
{
	struct sdhc_acpi_softc *sc = arg;
	int type = AML_CRSTYPE(crs);
	struct aml_node *node;
	uint16_t pin;

	switch (type) {
	case LR_MEM32FIXED:
		sc->sc_addr = crs->lr_m32fixed._bas;
		sc->sc_size = crs->lr_m32fixed._len;
		break;
	case LR_EXTIRQ:
		sc->sc_irq = crs->lr_extirq.irq[0];
		sc->sc_irq_flags = crs->lr_extirq.flags;
		break;
	case LR_GPIO:
		node = aml_searchname(sc->sc_node, (char *)&crs->pad[crs->lr_gpio.res_off]);
		pin = *(uint16_t *)&crs->pad[crs->lr_gpio.pin_off];
		if (crs->lr_gpio.type == LR_GPIO_INT) {
			sc->sc_gpio_int_node = node;
			sc->sc_gpio_int_pin = pin;
			sc->sc_gpio_int_flags = crs->lr_gpio.tflags;
		} else if (crs->lr_gpio.type == LR_GPIO_IO) {
			sc->sc_gpio_io_node = node;
			sc->sc_gpio_io_pin = pin;
		}
		break;
	}

	return 0;
}

int
sdhc_acpi_card_detect(struct sdhc_softc *ssc)
{
	struct sdhc_acpi_softc *sc = (struct sdhc_acpi_softc *)ssc;
	struct acpi_gpio *gpio = sc->sc_gpio_io_node->gpio;
	uint16_t pin = sc->sc_gpio_io_pin;

	/* Card detect GPIO signal is active-low. */
	return !gpio->read_pin(gpio->cookie, pin);
}

int
sdhc_acpi_card_detect_intr(void *arg)
{
	struct sdhc_acpi_softc *sc = arg;

	sdhc_needs_discover(&sc->sc);

	return (1);
}
@


1.8
log
@Implement DMA support.  Bits and pieces taken from NetBSD, but we only
support ADMA2.  The older SDMA mode has too many limitations to be really
usable.  Gives us only moderate speed improvements, bus reduces the CPU load
considerably.  We will reap the full benefits once we implement wider bus
widths and high speed modes.

There is a remining issue with simultanious use of eMMC and external SD card
on (some) Intel Bay Trail hardware.  Still under investigation.

ok patrick@@, stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.7 2016/04/26 19:10:10 kettenis Exp $	*/
d72 1
a72 1
int	sdhc_acpi_parse_resources(union acpi_resource *, void *);
d144 1
a144 1
sdhc_acpi_parse_resources(union acpi_resource *crs, void *arg)
@


1.7
log
@Remove debug printfs, but do print "gpio" to indicate that card detection is
done through a gpio pin instead of the standard register.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.6 2016/04/02 00:34:47 jsg Exp $	*/
d32 2
d139 2
a140 1
	sdhc_host_found(&sc->sc, sc->sc_memt, sc->sc_memh, sc->sc_size, 0, 0);
@


1.6
log
@Make the gpio intr_establish callback return an int so the same function
pointer can be used with gpio and acpi intr_establish.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.5 2016/03/30 10:00:08 kettenis Exp $	*/
d122 1
a122 1
	if (sc->sc_gpio_io_node && sc->sc_gpio_io_node->gpio)
d124 2
a159 1
		printf(" %s pin %d\n", node->name, pin);
a167 7
		printf(" tflags 0x%x\n", crs->lr_gpio.tflags);
		printf(" ppi 0x%x\n", crs->lr_gpio._ppi);
		printf(" drs 0x%x\n", crs->lr_gpio._drs);
		printf(" dbt 0x%x\n", crs->lr_gpio._dbt);
		break;
	default:
		printf(" type 0x%x\n", type);
@


1.5
log
@Hook up the gpio interrupt on devices that use it for card detection.
Makes the SD card slot on machines based on Intel's Bay Trail SoC fully
functional.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.4 2016/03/29 18:04:09 kettenis Exp $	*/
d72 1
a72 1
void	sdhc_acpi_card_detect_intr(void *);
d191 1
a191 1
void
d197 2
@


1.4
log
@Check if a device is present (using _STA) in acpi_foundhid.  This prevents
us from reporting devices as "not configured" that aren't actually present,
and allows us to remove duplicated code from several drivers.

ok deraadt@@, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.3 2016/03/28 19:15:43 kettenis Exp $	*/
d49 1
d72 1
d125 7
d162 1
d189 8
@


1.3
log
@Replace 0 with NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.2 2016/03/28 17:53:26 kettenis Exp $	*/
a76 1
	int64_t sta;
d78 1
a78 11
	if (!acpi_matchhids(aaa, sdhc_hids, cf->cf_driver->cd_name))
		return 0;

	if (aml_evalinteger((struct acpi_softc *)parent, aaa->aaa_node,
	    "_STA", 0, NULL, &sta))
		sta = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	if ((sta & STA_PRESENT) == 0)
		return 0;

	return 1;
@


1.2
log
@Add support for card detect through a GPIO signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc_acpi.c,v 1.1 2016/01/11 07:36:10 kettenis Exp $	*/
d66 1
a66 1
	0
@


1.1
log
@Add glue to make sdhc(4) attach to acpi(4).  Needed to support the SD host
controllers integrated on Intel's Bay Trail SoCs.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 5
d70 1
d131 3
d145 2
d157 15
a171 2
	case 0x8c:
		/* XXX GPIO; use for card detect. */
d179 11
@

