head	1.65;
access;
symbols
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.62.0.6
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.62.0.4
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.61.0.4
	OPENBSD_5_7_BASE:1.61
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.59.0.12
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.59.0.8
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.6
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.4
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.4
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19;
locks; strict;
comment	@ * @;


1.65
date	2017.07.25.21.32.07;	author jcs;	state Exp;
branches;
next	1.64;
commitid	BnJa4KCIpbRnhST3;

1.64
date	2017.07.22.21.06.17;	author jcs;	state Exp;
branches;
next	1.63;
commitid	YGlQlzvK6dlvGkl6;

1.63
date	2017.03.12.21.30.44;	author jcs;	state Exp;
branches;
next	1.62;
commitid	LbtljK30ETSd9Z21;

1.62
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.61;
commitid	p4LJxGKbi0BU2cG6;

1.61
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.60;
commitid	uzzBR7hz9ncd4O6G;

1.60
date	2014.05.23.19.17.39;	author landry;	state Exp;
branches;
next	1.59;

1.59
date	2011.10.16.11.59.21;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2010.11.10.21.40.55;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2010.08.07.16.55.38;	author canacar;	state Exp;
branches;
next	1.56;

1.56
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.24.21.37.42;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.11.21.54.15;	author jordan;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.14.14.31.31;	author robert;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.05.17.01.06;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.13.05.50.21;	author jordan;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.16.13.58.18;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.12.21.58.13;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.12.19.55.37;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.12.04.32.37;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.11.08.20.27.20;	author canacar;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.03.17.46.41;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.20.15.17.21;	author mk;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.17.18.53.28;	author deanna;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.25.07.27.36;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2006.12.21.13.10.57;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.21.04.54.27;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.21.04.18.48;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.29.22.17.07;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.19.18.02.19;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.19.17.57.17;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.19.08.56.46;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.19.04.00.53;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2006.09.19.18.01.36;	author mk;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.06.22.14.30;	author jolan;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.19.09.10.50;	author canacar;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.30.05.22.27;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.05.04.47.25;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.22.19.28.17;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.22.15.29.23;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.21.20.25.26;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.21.01.12.40;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.17.07.25.51;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.17.07.09.25;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.17.00.45.27;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.16.22.14.32;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.16.21.07.16;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.03.23.55.47;	author jordan;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.17.23.42.14;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.06.09.06.21;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.30.05.59.40;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.28.03.25.15;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.28.03.18.56;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.28.03.08.33;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.16.04.16.59;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.13.23.19.48;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.13.07.21.47;	author marco;	state Exp;
branches;
next	;


desc
@@


1.65
log
@fallback on _BIF properly when _BIX exists and returns a package
successfully but has an unexpected length, as on the X1C gen 5

tested by naddy
@
text
@/* $OpenBSD: acpibat.c,v 1.64 2017/07/22 21:06:17 jcs Exp $ */
/*
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/sensors.h>

#include <machine/apmvar.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

int	acpibat_match(struct device *, void *, void *);
void	acpibat_attach(struct device *, struct device *, void *);

struct cfattach acpibat_ca = {
	sizeof(struct acpibat_softc), acpibat_match, acpibat_attach
};

struct cfdriver acpibat_cd = {
	NULL, "acpibat", DV_DULL
};

const char *acpibat_hids[] = { ACPI_DEV_CMB, 0 };

void	acpibat_monitor(struct acpibat_softc *);
void	acpibat_refresh(void *);
int	acpibat_getbix(struct acpibat_softc *);
int	acpibat_getbst(struct acpibat_softc *);
int	acpibat_notify(struct aml_node *, int, void *);

int
acpibat_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;

	if (((struct acpi_softc *)parent)->sc_havesbs)
		return (0);

	/* sanity */
	return (acpi_matchhids(aa, acpibat_hids, cf->cf_driver->cd_name));
}

void
acpibat_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpibat_softc	*sc = (struct acpibat_softc *)self;
	struct acpi_attach_args	*aa = aux;
	int64_t			sta;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &sta)) {
		dnprintf(10, "%s: no _STA\n", DEVNAME(sc));
		return;
	}

	if ((sta & STA_BATTERY) != 0) {
		sc->sc_bat_present = 1;
		acpibat_getbix(sc);
		acpibat_getbst(sc);

		printf(": %s", sc->sc_devnode->name);
		if (sc->sc_bix.bix_model[0])
			printf(" model \"%s\"", sc->sc_bix.bix_model);
		if (sc->sc_bix.bix_serial[0])
			printf(" serial %s", sc->sc_bix.bix_serial);
		if (sc->sc_bix.bix_type[0])
			printf(" type %s", sc->sc_bix.bix_type);
		if (sc->sc_bix.bix_oem[0])
			printf(" oem \"%s\"", sc->sc_bix.bix_oem);

		printf("\n");
	} else {
		sc->sc_bat_present = 0;
		printf(": %s not present\n", sc->sc_devnode->name);
	}

	/* create sensors */
	acpibat_monitor(sc);

	/* populate sensors */
	acpibat_refresh(sc);

	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
	    acpibat_notify, sc, ACPIDEV_POLL);
}

void
acpibat_monitor(struct acpibat_softc *sc)
{
	int			type;

	/* assume _BIF/_BIX and _BST have been called */
	strlcpy(sc->sc_sensdev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensdev.xname));

	type = sc->sc_bix.bix_power_unit ? SENSOR_AMPHOUR : SENSOR_WATTHOUR;

	strlcpy(sc->sc_sens[0].desc, "last full capacity",
	    sizeof(sc->sc_sens[0].desc));
	sc->sc_sens[0].type = type;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[0]);
	sc->sc_sens[0].value = sc->sc_bix.bix_last_capacity * 1000;

	strlcpy(sc->sc_sens[1].desc, "warning capacity",
	    sizeof(sc->sc_sens[1].desc));
	sc->sc_sens[1].type = type;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[1]);
	sc->sc_sens[1].value = sc->sc_bix.bix_warning * 1000;

	strlcpy(sc->sc_sens[2].desc, "low capacity",
	    sizeof(sc->sc_sens[2].desc));
	sc->sc_sens[2].type = type;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[2]);
	sc->sc_sens[2].value = sc->sc_bix.bix_low * 1000;

	strlcpy(sc->sc_sens[3].desc, "voltage", sizeof(sc->sc_sens[3].desc));
	sc->sc_sens[3].type = SENSOR_VOLTS_DC;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[3]);
	sc->sc_sens[3].value = sc->sc_bix.bix_voltage * 1000;

	strlcpy(sc->sc_sens[4].desc, "battery unknown",
	    sizeof(sc->sc_sens[4].desc));
	sc->sc_sens[4].type = SENSOR_INTEGER;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[4]);
	sc->sc_sens[4].value = sc->sc_bst.bst_state;

	strlcpy(sc->sc_sens[5].desc, "rate", sizeof(sc->sc_sens[5].desc));
	sc->sc_sens[5].type =
		sc->sc_bix.bix_power_unit ? SENSOR_AMPS : SENSOR_WATTS;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[5]);
	sc->sc_sens[5].value = sc->sc_bst.bst_rate * 1000;

	strlcpy(sc->sc_sens[6].desc, "remaining capacity",
	    sizeof(sc->sc_sens[6].desc));
	sc->sc_sens[6].type = type;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[6]);
	sc->sc_sens[6].value = sc->sc_bix.bix_capacity * 1000;

	strlcpy(sc->sc_sens[7].desc, "current voltage",
	    sizeof(sc->sc_sens[7].desc));
	sc->sc_sens[7].type = SENSOR_VOLTS_DC;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[7]);
	sc->sc_sens[7].value = sc->sc_bix.bix_voltage * 1000;

	strlcpy(sc->sc_sens[8].desc, "design capacity",
	    sizeof(sc->sc_sens[8].desc));
	sc->sc_sens[8].type = type;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[8]);
	sc->sc_sens[8].value = sc->sc_bix.bix_capacity * 1000;

	if (!sc->sc_use_bif) {
		strlcpy(sc->sc_sens[9].desc, "discharge cycles",
		    sizeof(sc->sc_sens[9].desc));
		sc->sc_sens[9].type = SENSOR_INTEGER;
		sensor_attach(&sc->sc_sensdev, &sc->sc_sens[9]);
		sc->sc_sens[9].value = sc->sc_bix.bix_cycle_count;
	}

	sensordev_install(&sc->sc_sensdev);
}

void
acpibat_refresh(void *arg)
{
	struct acpibat_softc	*sc = arg;
	int			i;

	dnprintf(30, "%s: %s: refresh\n", DEVNAME(sc),
	    sc->sc_devnode->name);

	if (!sc->sc_bat_present) {
		for (i = 0; i < nitems(sc->sc_sens); i++) {
			sc->sc_sens[i].value = 0;
			sc->sc_sens[i].status = SENSOR_S_UNSPEC;
			sc->sc_sens[i].flags = SENSOR_FINVALID;
		}
		/* override state */
		strlcpy(sc->sc_sens[4].desc, "battery removed",
		    sizeof(sc->sc_sens[4].desc));
		return;
	}

	/* _BIF/_BIX values are static, sensor 0..3 */
	if (sc->sc_bix.bix_last_capacity == BIX_UNKNOWN) {
		sc->sc_sens[0].value = 0;
		sc->sc_sens[0].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[0].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[0].value = sc->sc_bix.bix_last_capacity * 1000;
		sc->sc_sens[0].status = SENSOR_S_UNSPEC;
		sc->sc_sens[0].flags = 0;
	}
	sc->sc_sens[1].value = sc->sc_bix.bix_warning * 1000;
	sc->sc_sens[1].flags = 0;
	sc->sc_sens[2].value = sc->sc_bix.bix_low * 1000;
	sc->sc_sens[2].flags = 0;
	if (sc->sc_bix.bix_voltage == BIX_UNKNOWN) {
		sc->sc_sens[3].value = 0;
		sc->sc_sens[3].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[3].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[3].value = sc->sc_bix.bix_voltage * 1000;
		sc->sc_sens[3].status = SENSOR_S_UNSPEC;
		sc->sc_sens[3].flags = 0;
	}

	/* _BST values are dynamic, sensor 4..7 */
	sc->sc_sens[4].status = SENSOR_S_OK;
	sc->sc_sens[4].flags = 0;
	if (sc->sc_bix.bix_last_capacity == BIX_UNKNOWN ||
	    sc->sc_bst.bst_capacity == BST_UNKNOWN) {
		sc->sc_sens[4].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[4].flags = SENSOR_FUNKNOWN;
		strlcpy(sc->sc_sens[4].desc, "battery unknown",
		    sizeof(sc->sc_sens[4].desc));
	} else if (sc->sc_bst.bst_capacity >= sc->sc_bix.bix_last_capacity)
		strlcpy(sc->sc_sens[4].desc, "battery full",
		    sizeof(sc->sc_sens[4].desc));
	else if (sc->sc_bst.bst_state & BST_DISCHARGE)
		strlcpy(sc->sc_sens[4].desc, "battery discharging",
		    sizeof(sc->sc_sens[4].desc));
	else if (sc->sc_bst.bst_state & BST_CHARGE)
		strlcpy(sc->sc_sens[4].desc, "battery charging",
		    sizeof(sc->sc_sens[4].desc));
	else if (sc->sc_bst.bst_state & BST_CRITICAL) {
		strlcpy(sc->sc_sens[4].desc, "battery critical",
		    sizeof(sc->sc_sens[4].desc));
		sc->sc_sens[4].status = SENSOR_S_CRIT;
	} else
		strlcpy(sc->sc_sens[4].desc, "battery idle",
		    sizeof(sc->sc_sens[4].desc));
	sc->sc_sens[4].value = sc->sc_bst.bst_state;

	if (sc->sc_bst.bst_rate == BST_UNKNOWN) {
		sc->sc_sens[5].value = 0;
		sc->sc_sens[5].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[5].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[5].value = sc->sc_bst.bst_rate * 1000;
		sc->sc_sens[5].status = SENSOR_S_UNSPEC;
		sc->sc_sens[5].flags = 0;
	}

	if (sc->sc_bst.bst_capacity == BST_UNKNOWN) {
		sc->sc_sens[6].value = 0;
		sc->sc_sens[6].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[6].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[6].value = sc->sc_bst.bst_capacity * 1000;
		sc->sc_sens[6].flags = 0;

		if (sc->sc_bst.bst_capacity < sc->sc_bix.bix_low)
			/* XXX we should shutdown the system */
			sc->sc_sens[6].status = SENSOR_S_CRIT;
		else if (sc->sc_bst.bst_capacity < sc->sc_bix.bix_warning)
			sc->sc_sens[6].status = SENSOR_S_WARN;
		else
			sc->sc_sens[6].status = SENSOR_S_OK;
	}

	if (sc->sc_bst.bst_voltage == BST_UNKNOWN) {
		sc->sc_sens[7].value = 0;
		sc->sc_sens[7].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[7].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[7].value = sc->sc_bst.bst_voltage * 1000;
		sc->sc_sens[7].status = SENSOR_S_UNSPEC;
		sc->sc_sens[7].flags = 0;
	}

	if (sc->sc_bix.bix_capacity == BIX_UNKNOWN) {
		sc->sc_sens[8].value = 0;
		sc->sc_sens[8].status = SENSOR_S_UNKNOWN;
		sc->sc_sens[8].flags = SENSOR_FUNKNOWN;
	} else {
		sc->sc_sens[8].value = sc->sc_bix.bix_capacity * 1000;
		sc->sc_sens[8].status = SENSOR_S_UNSPEC;
		sc->sc_sens[8].flags = 0;
	}

	if (!sc->sc_use_bif) {
		if (sc->sc_bix.bix_capacity == BIX_UNKNOWN) {
			sc->sc_sens[9].value = 0;
			sc->sc_sens[9].status = SENSOR_S_UNKNOWN;
			sc->sc_sens[9].flags = SENSOR_FUNKNOWN;
		} else {
			sc->sc_sens[9].value = sc->sc_bix.bix_cycle_count;
			sc->sc_sens[9].status = SENSOR_S_UNSPEC;
			sc->sc_sens[9].flags = 0;
		}
	}

	acpi_record_event(sc->sc_acpi, APM_POWER_CHANGE);
}

int
acpibat_getbix(struct acpibat_softc *sc)
{
	struct aml_value	res;
	int			rv = EINVAL;
	int			n = 0;

	if (!sc->sc_bat_present) {
		memset(&sc->sc_bix, 0, sizeof(sc->sc_bix));
		return (0);
	}

	sc->sc_use_bif = 1;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BIX", 0, NULL,
	    &res) == 0) {
		if (res.length == 20)
			sc->sc_use_bif = 0;
		else
			dnprintf(10, "%s: invalid _BIX (%d != 20)\n",
			    DEVNAME(sc), res.length);
	}

	if (sc->sc_use_bif) {
		if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BIF", 0, NULL,
		    &res)) {
			dnprintf(10, "%s: no _BIX or _BIF\n", DEVNAME(sc));
			goto out;
		}

		if (res.length != 13) {
			dnprintf(10, "%s: invalid _BIF (%d != 13)\n",
			    DEVNAME(sc), res.length);
			goto out;
		}
	}

	if (!sc->sc_use_bif)
		sc->sc_bix.bix_revision = aml_val2int(res.v_package[n++]);

	sc->sc_bix.bix_power_unit = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_capacity = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_last_capacity = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_technology = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_voltage = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_warning = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_low = aml_val2int(res.v_package[n++]);

	if (!sc->sc_use_bif) {
		sc->sc_bix.bix_cycle_count = aml_val2int(res.v_package[n++]);
		sc->sc_bix.bix_accuracy = aml_val2int(res.v_package[n++]);
		sc->sc_bix.bix_max_sample = aml_val2int(res.v_package[n++]);
		sc->sc_bix.bix_min_sample = aml_val2int(res.v_package[n++]);
		sc->sc_bix.bix_max_avg = aml_val2int(res.v_package[n++]);
		sc->sc_bix.bix_min_avg = aml_val2int(res.v_package[n++]);
	}

	sc->sc_bix.bix_cap_granu1 = aml_val2int(res.v_package[n++]);
	sc->sc_bix.bix_cap_granu2 = aml_val2int(res.v_package[n++]);

	strlcpy(sc->sc_bix.bix_model, aml_val_to_string(res.v_package[n++]),
		sizeof(sc->sc_bix.bix_model));
	strlcpy(sc->sc_bix.bix_serial, aml_val_to_string(res.v_package[n++]),
		sizeof(sc->sc_bix.bix_serial));
	strlcpy(sc->sc_bix.bix_type, aml_val_to_string(res.v_package[n++]),
		sizeof(sc->sc_bix.bix_type));
	strlcpy(sc->sc_bix.bix_oem, aml_val_to_string(res.v_package[n++]),
		sizeof(sc->sc_bix.bix_oem));

	if (!sc->sc_use_bif)
		dnprintf(60, "revision: %u ", sc->sc_bix.bix_revision);

	dnprintf(60, "power_unit: %u capacity: %u last_cap: %u "
	    "tech: %u volt: %u warn: %u low: %u ",
	    sc->sc_bix.bix_power_unit,
	    sc->sc_bix.bix_capacity,
	    sc->sc_bix.bix_last_capacity,
	    sc->sc_bix.bix_technology,
	    sc->sc_bix.bix_voltage,
	    sc->sc_bix.bix_warning,
	    sc->sc_bix.bix_low);

	if (!sc->sc_use_bif)
		dnprintf(60, "cycles: %u accuracy: %u max_sample: %u "
		    "min_sample: %u max_avg: %u min_avg: %u ",
		    sc->sc_bix.bix_cycle_count,
		    sc->sc_bix.bix_accuracy,
		    sc->sc_bix.bix_max_sample,
		    sc->sc_bix.bix_min_sample,
		    sc->sc_bix.bix_max_avg,
		    sc->sc_bix.bix_min_avg);

	dnprintf(60, "gran1: %u gran2: %d model: %s serial: %s type: %s "
	    "oem: %s\n",
	    sc->sc_bix.bix_cap_granu1,
	    sc->sc_bix.bix_cap_granu2,
	    sc->sc_bix.bix_model,
	    sc->sc_bix.bix_serial,
	    sc->sc_bix.bix_type,
	    sc->sc_bix.bix_oem);

	rv = 0;
out:
	aml_freevalue(&res);
	return (rv);
}

int
acpibat_getbst(struct acpibat_softc *sc)
{
	struct aml_value	res;
	int			rv = EINVAL;

	if (!sc->sc_bat_present) {
		memset(&sc->sc_bst, 0, sizeof(sc->sc_bst));
		return (0);
	}

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BST", 0, NULL, &res)) {
		dnprintf(10, "%s: no _BST\n", DEVNAME(sc));
		goto out;
	}

	if (res.length != 4) {
		dnprintf(10, "%s: invalid _BST, battery status not saved\n",
		    DEVNAME(sc));
		goto out;
	}

	sc->sc_bst.bst_state = aml_val2int(res.v_package[0]);
	sc->sc_bst.bst_rate = aml_val2int(res.v_package[1]);
	sc->sc_bst.bst_capacity = aml_val2int(res.v_package[2]);
	sc->sc_bst.bst_voltage = aml_val2int(res.v_package[3]);

	dnprintf(60, "state: %u rate: %u cap: %u volt: %u ",
	    sc->sc_bst.bst_state,
	    sc->sc_bst.bst_rate,
	    sc->sc_bst.bst_capacity,
	    sc->sc_bst.bst_voltage);

	rv = 0;
out:
	aml_freevalue(&res);
	return (rv);
}

/*
 * XXX it has been observed that some systems do not propagate battery
 * insertion events up to the driver.  What seems to happen is that DSDT
 * does receive an interrupt however the originator bit is not set.
 * This seems to happen when one inserts a 100% full battery.  Removal
 * of the power cord or insertion of a not 100% full battery breaks this
 * behavior and all events will then be sent upwards.  Currently there
 * is no known work-around for it.
 */

int
acpibat_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct acpibat_softc	*sc = arg;
	int64_t			sta;

	dnprintf(10, "acpibat_notify: %.2x %s\n", notify_type,
	    sc->sc_devnode->name);

	/* Check if installed state of battery has changed */
	if (aml_evalinteger(sc->sc_acpi, node, "_STA", 0, NULL, &sta) == 0) {
		if (sta & STA_BATTERY)
			sc->sc_bat_present = 1;
		else
			sc->sc_bat_present = 0;
	}

	switch (notify_type) {
	case 0x00:	/* Poll sensors */
	case 0x80:	/* _BST changed */
		acpibat_getbst(sc);
		break;
	case 0x81:	/* _BIF/_BIX changed */
		acpibat_getbix(sc);
		break;
	default:
		break;
	}

	acpibat_refresh(sc);

	return (0);
}
@


1.64
log
@acpibat: look for _BIX first before falling back on _BIF

ACPI 4.0 deprecated _BIF for battery status so some newer machines
are exporting _BIX which extends _BIF's package with a few extra
fields.  When using _BIX, export the new discharge cycle count as a
sensor.

feedback from kettenis and anton
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.63 2017/03/12 21:30:44 jcs Exp $ */
d331 12
a342 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BIX", 0, NULL, &res)) {
		/* no _BIX, fallback on _BIF */
a353 10

		sc->sc_use_bif = 1;
	} else {
		if (res.length != 20) {
			dnprintf(10, "%s: invalid _BIX (%d != 20)\n",
			    DEVNAME(sc), res.length);
			goto out;
		}

		sc->sc_use_bif = 0;
@


1.63
log
@try to attach acpisbs first and if successful, don't attach acpibat
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.62 2015/03/14 03:38:46 jsg Exp $ */
d47 1
a47 1
int	acpibat_getbif(struct acpibat_softc *);
d81 1
a81 1
		acpibat_getbif(sc);
d85 9
a93 8
		if (sc->sc_bif.bif_model[0])
			printf(" model \"%s\"", sc->sc_bif.bif_model);
		if (sc->sc_bif.bif_serial[0])
			printf(" serial %s", sc->sc_bif.bif_serial);
		if (sc->sc_bif.bif_type[0])
			printf(" type %s", sc->sc_bif.bif_type);
		if (sc->sc_bif.bif_oem[0])
			printf(" oem \"%s\"", sc->sc_bif.bif_oem);
d115 1
a115 1
	/* assume _BIF and _BST have been called */
d119 1
a119 1
	type = sc->sc_bif.bif_power_unit ? SENSOR_AMPHOUR : SENSOR_WATTHOUR;
d125 1
a125 1
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity * 1000;
d131 1
a131 1
	sc->sc_sens[1].value = sc->sc_bif.bif_warning * 1000;
d137 1
a137 1
	sc->sc_sens[2].value = sc->sc_bif.bif_low * 1000;
d142 1
a142 1
	sc->sc_sens[3].value = sc->sc_bif.bif_voltage * 1000;
d152 1
a152 1
		sc->sc_bif.bif_power_unit ? SENSOR_AMPS : SENSOR_WATTS;
d160 1
a160 1
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity * 1000;
d166 1
a166 1
	sc->sc_sens[7].value = sc->sc_bst.bst_voltage * 1000;
d172 9
a180 1
	sc->sc_sens[8].value = sc->sc_bif.bif_capacity * 1000;
d195 1
a195 1
		for (i = 0; i < 9; i++) {
d206 2
a207 2
	/* _BIF values are static, sensor 0..3 */
	if (sc->sc_bif.bif_last_capacity == BIF_UNKNOWN) {
d212 1
a212 1
		sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity * 1000;
d216 1
a216 1
	sc->sc_sens[1].value = sc->sc_bif.bif_warning * 1000;
d218 1
a218 1
	sc->sc_sens[2].value = sc->sc_bif.bif_low * 1000;
d220 1
a220 1
	if (sc->sc_bif.bif_voltage == BIF_UNKNOWN) {
d225 1
a225 1
		sc->sc_sens[3].value = sc->sc_bif.bif_voltage * 1000;
d233 1
a233 1
	if (sc->sc_bif.bif_last_capacity == BIF_UNKNOWN ||
d239 1
a239 1
	} else if (sc->sc_bst.bst_capacity >= sc->sc_bif.bif_last_capacity)
d275 1
a275 1
		if (sc->sc_bst.bst_capacity < sc->sc_bif.bif_low)
d278 1
a278 1
		else if (sc->sc_bst.bst_capacity < sc->sc_bif.bif_warning)
d294 1
a294 1
	if (sc->sc_bif.bif_capacity == BIF_UNKNOWN) {
d299 1
a299 1
		sc->sc_sens[8].value = sc->sc_bif.bif_capacity * 1000;
d303 13
d320 1
a320 1
acpibat_getbif(struct acpibat_softc *sc)
d324 1
d327 1
a327 1
		memset(&sc->sc_bif, 0, sizeof(sc->sc_bif));
d331 23
a353 3
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BIF", 0, NULL, &res)) {
		dnprintf(10, "%s: no _BIF\n", DEVNAME(sc));
		goto out;
d356 2
a357 5
	if (res.length != 13) {
		dnprintf(10, "%s: invalid _BIF, battery info not saved\n",
		    DEVNAME(sc));
		goto out;
	}
d359 60
a418 35
	sc->sc_bif.bif_power_unit = aml_val2int(res.v_package[0]);
	sc->sc_bif.bif_capacity = aml_val2int(res.v_package[1]);
	sc->sc_bif.bif_last_capacity = aml_val2int(res.v_package[2]);
	sc->sc_bif.bif_technology = aml_val2int(res.v_package[3]);
	sc->sc_bif.bif_voltage = aml_val2int(res.v_package[4]);
	sc->sc_bif.bif_warning = aml_val2int(res.v_package[5]);
	sc->sc_bif.bif_low = aml_val2int(res.v_package[6]);
	sc->sc_bif.bif_cap_granu1 = aml_val2int(res.v_package[7]);
	sc->sc_bif.bif_cap_granu2 = aml_val2int(res.v_package[8]);

	strlcpy(sc->sc_bif.bif_model, aml_val_to_string(res.v_package[9]),
		sizeof(sc->sc_bif.bif_model));
	strlcpy(sc->sc_bif.bif_serial, aml_val_to_string(res.v_package[10]),
		sizeof(sc->sc_bif.bif_serial));
	strlcpy(sc->sc_bif.bif_type, aml_val_to_string(res.v_package[11]),
		sizeof(sc->sc_bif.bif_type));
	strlcpy(sc->sc_bif.bif_oem, aml_val_to_string(res.v_package[12]),
		sizeof(sc->sc_bif.bif_oem));

	dnprintf(60, "power_unit: %u capacity: %u last_cap: %u tech: %u "
	    "volt: %u warn: %u low: %u gran1: %u gran2: %d model: %s "
	    "serial: %s type: %s oem: %s\n",
	    sc->sc_bif.bif_power_unit,
	    sc->sc_bif.bif_capacity,
	    sc->sc_bif.bif_last_capacity,
	    sc->sc_bif.bif_technology,
	    sc->sc_bif.bif_voltage,
	    sc->sc_bif.bif_warning,
	    sc->sc_bif.bif_low,
	    sc->sc_bif.bif_cap_granu1,
	    sc->sc_bif.bif_cap_granu2,
	    sc->sc_bif.bif_model,
	    sc->sc_bif.bif_serial,
	    sc->sc_bif.bif_type,
	    sc->sc_bif.bif_oem);
d497 2
a498 2
	case 0x81:	/* _BIF changed */
		acpibat_getbif(sc);
@


1.62
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.61 2014/09/14 14:17:24 jsg Exp $ */
d56 3
@


1.61
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.60 2014/05/23 19:17:39 landry Exp $ */
a23 1
#include <machine/bus.h>
@


1.60
log
@Expose bif_capacity as the 'design capacity' through an acpibat sensor,
giving you the original capacity of the battery:

hw.sensors.acpibat0.watthour0=64.07 Wh (last full capacity)
hw.sensors.acpibat0.watthour4=84.24 Wh (design capacity)

hw.sensors.acpibat0.amphour0=2.03 Ah (last full capacity)
hw.sensors.acpibat0.amphour4=4.40 Ah (design capacity)

Diff from Fabian Raetz on tech@@, thanks!

ok mlarkin@@ zhuk@@ armani@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.59 2011/10/16 11:59:21 kettenis Exp $ */
a18 1
#include <sys/proc.h>
@


1.59
log
@Provide battery charge/discharge rate in proper units.

Based on a diff from Vladimir Kirrillov.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.58 2010/11/10 21:40:55 kettenis Exp $ */
d166 6
d185 1
a185 1
		for (i = 0; i < 8; i++) {
d282 10
@


1.58
log
@The acpibat(4) notify function should not unconditionally call both _BIF
and _BST.  Some machines (like the Toshiba Satellite Pro U550 18F mentioned
in PR 6508) have AML that does a Notify(0x81) from the _BST method, which leads
to infinite recursion.  Instead call _BIF when the argument is 0x81 and call
_BST when the argument is 0x80 or 0x00 (the latter indicates we're polling).
Simplify the battery detection logic while there.

ok mikeb@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.57 2010/08/07 16:55:38 canacar Exp $ */
d149 2
a150 1
	sc->sc_sens[5].type = SENSOR_INTEGER;
d152 1
a152 1
	sc->sc_sens[5].value = sc->sc_bst.bst_rate;
d246 1
a246 1
		sc->sc_sens[5].value = sc->sc_bst.bst_rate;
@


1.57
log
@Generate power change events for APM. Makes powerup and powerdown scripts
work with ACPI.
ok deraadt@@, phessler@@, feedback kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.56 2010/07/21 19:35:15 deraadt Exp $ */
a188 7
	/*
	 * XXX don't really need _BIF but keep it here in case we
	 * miss an insertion/removal event
	 */
	acpibat_getbif(sc);
	acpibat_getbst(sc);

d382 2
a383 1
/* XXX it has been observed that some systems do not propagate battery
a396 1
	int			present;
d403 1
a403 2
		present = sta & STA_BATTERY;
		if (!sc->sc_bat_present && present)
d405 1
a405 1
		else if (sc->sc_bat_present && !present)
d408 1
d410 1
d412 1
d415 1
@


1.56
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.55 2009/11/24 21:37:42 deraadt Exp $ */
d26 1
d283 1
@


1.55
log
@Reporting battery insert/removal was debug code.  dmesg is not
a place to spam informational messages about unimportant events.
That is what the sensor framework is for (and that is already
done)
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.54 2009/03/11 21:54:15 jordan Exp $ */
d408 1
a408 1
 		present = sta & STA_BATTERY;
@


1.54
log
@More aml_evalinteger fixup
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.53 2008/11/06 23:41:28 marco Exp $ */
d409 1
a409 3
		if (!sc->sc_bat_present && present) {
			printf("%s: %s inserted\n", DEVNAME(sc),
			    sc->sc_devnode->name);
d411 1
a411 4
		}
		else if (sc->sc_bat_present && !present) {
			printf("%s: %s removed\n", DEVNAME(sc),
			    sc->sc_devnode->name);
a412 1
		}
@


1.53
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.52 2008/08/14 14:31:31 robert Exp $ */
d67 1
a67 1
	struct aml_value	res;
d72 1
a72 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res)) {
d77 1
a77 1
	if ((res.v_integer & STA_BATTERY) != 0) {
a96 2
	aml_freevalue(&res);

d400 1
a400 1
	struct aml_value	res;
d407 2
a408 3
	memset(&res, 0, sizeof(res));
	if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res) == 0) {
 		present = res.v_integer & STA_BATTERY;
@


1.52
log
@add missing semicolon; ok mbalmer@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.51 2008/08/05 17:01:06 marco Exp $ */
d44 2
d59 1
a59 6
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	return (1);
@


1.51
log
@Fix spurious 0 values on batteries seen on laptopts that have an embedded
controller.

Found, diagnosed and patch from Stefan Sperling <stsp@@stsp.name>
Minor KNF changes while here.

Tested by many on a variaty of IBM laptops and others with and without
acpiec.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.50 2008/06/13 05:50:21 jordan Exp $ */
d406 1
a406 1
	int			present
@


1.50
log
@Properly handle battery insertion/removal
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.49 2008/06/01 17:59:55 marco Exp $ */
d295 4
a298 3
	memset(&sc->sc_bif, 0, sizeof(sc->sc_bif));
	if (!sc->sc_bat_present)
		return 0;
d359 4
a362 3
	memset(&sc->sc_bst, 0, sizeof(sc->sc_bst));
	if (!sc->sc_bat_present)
		return 0;
d405 2
a406 1
	struct aml_value res;
d414 1
a414 2
		int present = (res.v_integer & STA_BATTERY);

@


1.49
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.47 2008/05/14 05:24:36 jordan Exp $ */
d80 2
a81 1
	if ((sc->sc_bat_present = aml_val2int(&res) & STA_BATTERY) != 0) {
d95 2
a96 1
	} else
d98 1
d295 3
a297 5
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res)) {
		dnprintf(10, "%s: no _STA\n", DEVNAME(sc));
		goto out;
	}
	aml_freevalue(&res);
a309 1
	memset(&sc->sc_bif, 0, sizeof sc->sc_bif);
d358 4
d403 1
d408 7
a414 4
	switch (notify_type) {
	case 0x80:	/* _BST changed */
		if (!sc->sc_bat_present) {
			printf("%s: %s: inserted\n", DEVNAME(sc),
d418 2
a419 5
		break;
	case 0x81:	/* _BIF changed */
		/* XXX consider this a device removal */
		if (sc->sc_bat_present) {
			printf("%s: %s: removed\n", DEVNAME(sc),
d423 5
@


1.48
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.46 2007/11/16 13:58:18 deraadt Exp $ */
d73 1
a73 1
	sc->sc_devnode = aa->aaa_node->child;
d84 1
a84 1
		printf(": %s", sc->sc_devnode->parent->name);
d95 1
a95 1
		printf(": %s not present\n", sc->sc_devnode->parent->name);
d105 1
a105 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
d176 1
a176 1
	    sc->sc_devnode->parent->name);
d401 1
a401 1
	    sc->sc_devnode->parent->name);
d407 1
a407 1
			    sc->sc_devnode->parent->name);
d415 1
a415 1
			    sc->sc_devnode->parent->name);
@


1.47
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d73 1
a73 1
	sc->sc_devnode = aa->aaa_node;
d84 1
a84 1
		printf(": %s", sc->sc_devnode->name);
d95 1
a95 1
		printf(": %s not present\n", sc->sc_devnode->name);
d105 1
a105 1
	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
d176 1
a176 1
	    sc->sc_devnode->name);
d401 1
a401 1
	    sc->sc_devnode->name);
d407 1
a407 1
			    sc->sc_devnode->name);
d415 1
a415 1
			    sc->sc_devnode->name);
@


1.46
log
@quotes around model name too
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.45 2007/11/12 21:58:13 deraadt Exp $ */
d73 1
a73 1
	sc->sc_devnode = aa->aaa_node->child;
d84 1
a84 1
		printf(": %s", sc->sc_devnode->parent->name);
d95 1
a95 1
		printf(": %s not present\n", sc->sc_devnode->parent->name);
d105 1
a105 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
d176 1
a176 1
	    sc->sc_devnode->parent->name);
d401 1
a401 1
	    sc->sc_devnode->parent->name);
d407 1
a407 1
			    sc->sc_devnode->parent->name);
d415 1
a415 1
			    sc->sc_devnode->parent->name);
@


1.45
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.44 2007/11/12 19:55:37 deraadt Exp $ */
d86 1
a86 1
			printf(" model %s", sc->sc_bif.bif_model);
@


1.44
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.43 2007/11/12 04:32:37 deraadt Exp $ */
d275 1
a275 1
	if(sc->sc_bst.bst_voltage == BST_UNKNOWN) {
@


1.43
log
@only print bif info that is complete
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.42 2007/11/08 20:27:20 canacar Exp $ */
d225 1
a225 1
	    sc->sc_bst.bst_capacity == BST_UNKNOWN) { 
d233 1
a233 1
        else if (sc->sc_bst.bst_state & BST_DISCHARGE)
d289 1
a289 1
	struct aml_value        res;
@


1.42
log
@convert the value to a string instead of using aml_val2str()
which returns invalid pointers if the value is not a string, causing
acpibat to panic, as reported by mbalmer@@ and Alexey Suslikov.
tested by Alexey Suslikov, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.41 2007/11/03 17:46:41 deraadt Exp $ */
d83 11
a93 6
		printf(": %s model %s serial %s type %s oem %s\n",
		    sc->sc_devnode->parent->name,
		    sc->sc_bif.bif_model,
		    sc->sc_bif.bif_serial,
		    sc->sc_bif.bif_type,
		    sc->sc_bif.bif_oem);
@


1.41
log
@repair attach messages; ok gwk canacar
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.40 2007/03/20 15:17:21 mk Exp $ */
d315 1
a315 1
	strlcpy(sc->sc_bif.bif_model, aml_strval(res.v_package[9]),
d317 1
a317 1
	strlcpy(sc->sc_bif.bif_serial, aml_strval(res.v_package[10]),
d319 1
a319 1
	strlcpy(sc->sc_bif.bif_type, aml_strval(res.v_package[11]),
d321 1
a321 1
	strlcpy(sc->sc_bif.bif_oem, aml_strval(res.v_package[12]),
@


1.40
log
@Use aml_val2int() instead of accessing v_integer directly.

`sort of ok' marco (before lock)
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.39 2007/02/17 18:53:28 deanna Exp $ */
d83 1
a83 1
		printf(": %s: model: %s serial: %s type: %s oem: %s\n",
d90 1
a90 1
		printf(": %s: not present\n", sc->sc_devnode->parent->name);
@


1.39
log
@Since a full battery can still have state BST_CHARGE ("charging"),
fullness needs to be checked first.  Otherwise, full batteries are
always described as "charging."

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.38 2007/01/25 07:27:36 marco Exp $ */
d80 1
a80 1
	if ((sc->sc_bat_present = res.v_integer & STA_BATTERY) != 0) {
@


1.38
log
@Do the sensor magic correctly.  Found by Constantine Murenin.
help from mickey
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.37 2006/12/26 23:58:08 marco Exp $ */
d225 4
a228 1
	} else if (sc->sc_bst.bst_state & BST_DISCHARGE)
d238 1
a238 4
	} else if (sc->sc_bst.bst_capacity >= sc->sc_bif.bif_last_capacity)
		strlcpy(sc->sc_sens[4].desc, "battery full",
		    sizeof(sc->sc_sens[4].desc));
	else
@


1.37
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.36 2006/12/23 17:46:39 deraadt Exp $ */
a135 1
	sc->sc_sens[3].status = SENSOR_S_OK;
a141 1
	sc->sc_sens[4].status = SENSOR_S_UNKNOWN;
a158 1
	sc->sc_sens[7].status = SENSOR_S_OK;
d174 1
a174 1
		for (i = 0; i < 8; i++)
d176 4
a181 1
		sc->sc_sens[4].status = SENSOR_S_OK;
d185 4
d192 10
a201 1
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity * 1000;
d203 1
d205 10
a214 1
	sc->sc_sens[3].value = sc->sc_bif.bif_voltage * 1000;
d216 1
d218 8
a225 1
	if (sc->sc_bst.bst_state & BST_DISCHARGE)
d235 1
a235 1
	} else /* whenever there is no status the battery is full */
d238 31
d270 9
a278 4
	sc->sc_sens[4].value = sc->sc_bst.bst_state;
	sc->sc_sens[5].value = sc->sc_bst.bst_rate;
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity * 1000;
	sc->sc_sens[7].value = sc->sc_bst.bst_voltage * 1000;
@


1.36
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.35 2006/12/21 19:59:02 deraadt Exp $ */
d101 1
a101 1
	    acpibat_notify, sc);
a347 2
		printf("%s: unhandled battery event %x\n", DEVNAME(sc),
		    notify_type);
@


1.35
log
@even more knf love
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.34 2006/12/21 13:10:57 marco Exp $ */
d107 1
a107 1
	int			i, type;
d110 2
a111 4
	memset(sc->sc_sens, 0, sizeof(sc->sc_sens));
	for (i = 0; i < 8; i++)
		strlcpy(sc->sc_sens[i].device, DEVNAME(sc),
		    sizeof(sc->sc_sens[i].device));
d118 1
a118 1
	sensor_add(&sc->sc_sens[0]);
d124 1
a124 1
	sensor_add(&sc->sc_sens[1]);
d130 1
a130 1
	sensor_add(&sc->sc_sens[2]);
d135 1
a135 1
	sensor_add(&sc->sc_sens[3]);
d142 1
a142 1
	sensor_add(&sc->sc_sens[4]);
d148 1
a148 1
	sensor_add(&sc->sc_sens[5]);
d154 1
a154 1
	sensor_add(&sc->sc_sens[6]);
d160 1
a160 1
	sensor_add(&sc->sc_sens[7]);
d163 2
@


1.34
log
@Tweak to report full battery.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.33 2006/12/21 11:23:41 deraadt Exp $ */
d91 1
a91 1
	
@


1.33
log
@more minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.32 2006/12/21 04:54:27 marco Exp $ */
d75 1
a75 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res))
d77 2
d91 2
d94 1
d97 2
a98 1
	aml_freevalue(&res);
d204 2
a205 2
	} else {
		strlcpy(sc->sc_sens[4].desc, "battery unknown",
a206 2
		sc->sc_sens[4].status = SENSOR_S_UNKNOWN;
	}
@


1.32
log
@Fix silly logic errors.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.31 2006/12/21 04:18:48 marco Exp $ */
d77 1
a77 1
	
d80 1
a80 1
		acpibat_getbst(sc); 
d89 1
a89 1
	
d91 1
a91 1
	
d180 1
a180 1
	acpibat_getbst(sc); 
@


1.31
log
@Silence acpibat significantly and shave off about 1k.  Also add some smarts
for battery removal and insertion.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.30 2006/11/29 22:17:07 marco Exp $ */
d170 1
a170 1
	if (sc->sc_bat_present == 0) {
d175 1
d329 1
a329 1
		if (sc->sc_bat_present == 0) {
d337 1
a337 1
		if (sc->sc_bat_present == 1) {
@


1.30
log
@After a long debate at the hackathon it was decided that the acpi implementation
is not concurrent if the sensors thread goes away.  This makes acpi completly
lockless.

help and ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.29 2006/10/19 18:02:19 marco Exp $ */
d76 1
a76 2
		dnprintf(10, "%s: no _STA\n",
		    DEVNAME(sc));
d78 1
a78 7
	if (!(res.v_integer & STA_BATTERY)) {
		sc->sc_bat_present = 0;
		printf(": %s: not present\n", sc->sc_devnode->parent->name);
		acpibat_monitor(sc);
	} else {
		sc->sc_bat_present = 1;

d80 1
a80 2
		acpibat_getbst(sc);

d87 5
a91 4

		acpibat_monitor(sc);

	}
a103 1

d135 2
a136 1
	strlcpy(sc->sc_sens[4].desc, "state", sizeof(sc->sc_sens[4].desc));
d139 1
a139 1
	sc->sc_sens[4].status = SENSOR_S_OK;
d165 1
d170 8
d197 4
d202 1
d213 1
a213 1
	int			rv = 1;
d216 1
a216 2
		dnprintf(10, "%s: no _STA\n",
		    DEVNAME(sc));
d222 1
a222 3
		dnprintf(10, "%s: no _BIF\n",
		    DEVNAME(sc));
		printf("bif fails\n");
d227 1
a227 1
		printf("%s: invalid _BIF, battery information not saved\n",
d269 1
d279 1
a279 1
	int			rv = 0;
d282 1
a282 4
		dnprintf(10, "%s: no _BST\n",
		    DEVNAME(sc));
		printf("_bst fails\n");
		rv = EINVAL;
d287 1
a287 1
		printf("%s: invalid _BST, battery status not saved\n",
a288 1
		rv = EINVAL;
a295 1
	aml_freevalue(&res);
d302 2
d305 1
a330 4

			if (sensor_task_register(sc, acpibat_refresh, 10))
				printf(", unable to register update task\n");

a332 1

d336 1
a336 5
		if (sc->sc_bat_present != 0) {
			sensor_task_unregister(sc);

			strlcpy(sc->sc_sens[4].desc, "battery removed",
			    sizeof(sc->sc_sens[4].desc));
a338 1

a347 2
	acpibat_getbif(sc);
	acpibat_getbst(sc);
@


1.29
log
@Reduce the scope of the locks.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.28 2006/10/19 17:57:17 marco Exp $ */
a21 1
#include <sys/rwlock.h>
a74 2
	rw_init(&sc->sc_lock, "acpibat");

a95 3
		if (sensor_task_register(sc, acpibat_refresh, 10))
			printf(", unable to register update task\n");

a104 1
/* XXX this is for debug only, remove later */
a178 2
	rw_enter_write(&sc->sc_lock);

a199 2

	rw_exit_write(&sc->sc_lock);
a227 2
	rw_enter_write(&sc->sc_lock);

a247 2
	rw_exit_write(&sc->sc_lock);

a290 2
	rw_enter_write(&sc->sc_lock);

a295 2

	rw_exit_write(&sc->sc_lock);
@


1.28
log
@KNF and some cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.27 2006/10/19 08:56:46 marco Exp $ */
a218 2
	rw_enter_write(&sc->sc_lock);

d239 2
d261 2
a281 1
	rw_exit_write(&sc->sc_lock);
a290 2
	rw_enter_write(&sc->sc_lock);

d306 2
d314 2
a321 1
	rw_exit_write(&sc->sc_lock);
@


1.27
log
@Replace ACPI ioctls with APM ioctls.  This makes ACPI talk the same protocol
as APM therefore userspace can now retrieve power information in the same
fashion as all other apm arches (zaurus, macppc, i386 etc).

To use force the use of acpi device like so: apmd -f /dev/acpi

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.26 2006/10/19 04:00:53 marco Exp $ */
d78 1
a78 2
	/* XXX this trick seems to only work during boot */
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res) != 0)
a187 4
	/* XXX ugh but make sure */
	if (!sc->sc_bif.bif_cap_granu1)
		sc->sc_bif.bif_cap_granu1 = 1;

d221 1
a221 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res) != 0) {
d228 1
a228 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BIF", 0, NULL, &res) != 0) {
d292 1
a292 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_BST", 0, NULL, &res) != 0) {
@


1.26
log
@Fix capacity calculations.  Tested on Dell C610, D810, Lenovo X60s.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.25 2006/10/12 16:38:21 jordan Exp $ */
d24 1
a33 2
#include <sys/sensors.h>

a36 17
struct acpibat_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	struct rwlock		sc_lock;
	struct acpibat_bif	sc_bif;
	struct acpibat_bst	sc_bst;
	volatile int		sc_bat_present;

	struct sensor		sc_sens[8]; /* XXX debug only */
};

a230 10

	/* XXX this is broken, it seems to only work during boot */
	/*
	if (!(res.v_integer & STA_BATTERY)) {
		sc->sc_bat_present = 0;
		aml_freevalue(&res);
		return (1);
	} else
		sc->sc_bat_present = 1;
	*/
@


1.25
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.24 2006/09/19 18:01:36 mk Exp $ */
d134 1
a134 1
	int			i;
d143 1
a143 3
	/* XXX ugh but make sure */
	if (!sc->sc_bif.bif_cap_granu1)
		sc->sc_bif.bif_cap_granu1 = 1;
d147 1
a147 1
	sc->sc_sens[0].type = SENSOR_PERCENT;
d149 1
a149 2
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity /
	    sc->sc_bif.bif_cap_granu1 * 1000;
d153 1
a153 1
	sc->sc_sens[1].type = SENSOR_PERCENT;
d155 1
a155 2
	sc->sc_sens[1].value = sc->sc_bif.bif_warning /
	    sc->sc_bif.bif_cap_granu1 * 1000;
d159 1
a159 1
	sc->sc_sens[2].type = SENSOR_PERCENT;
d161 1
a161 2
	sc->sc_sens[2].value = sc->sc_bif.bif_warning /
	    sc->sc_bif.bif_cap_granu1 * 1000;
d182 1
a182 1
	sc->sc_sens[6].type = SENSOR_PERCENT;
d184 1
a184 2
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity /
	    sc->sc_bif.bif_cap_granu1 * 1000;
d211 3
a213 6
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity /
	    sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sc_sens[1].value = sc->sc_bif.bif_warning /
	    sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sc_sens[2].value = sc->sc_bif.bif_warning /
	    sc->sc_bif.bif_cap_granu1 * 1000;
d230 1
a230 2
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity /
	    sc->sc_bif.bif_cap_granu1 * 1000;
@


1.24
log
@Typo fixes.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.23 2006/06/06 22:14:30 jolan Exp $ */
d89 1
a89 2
	struct aml_value	res, env;
	struct acpi_context	*ctx;
a95 3
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

d97 1
a97 2
	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env))
d100 1
a100 1

d124 1
d249 1
a249 2
	struct aml_value	res, env;
	struct acpi_context	*ctx;
d254 1
a254 5
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env)) {
d264 1
d269 1
d271 1
a271 1
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_BIF", &res, &env)) {
d285 18
a302 13
	sc->sc_bif.bif_power_unit = aml_val2int(ctx, res.v_package[0]);
	sc->sc_bif.bif_capacity = aml_val2int(ctx, res.v_package[1]);
	sc->sc_bif.bif_last_capacity = aml_val2int(ctx, res.v_package[2]);
	sc->sc_bif.bif_technology = aml_val2int(ctx, res.v_package[3]);
	sc->sc_bif.bif_voltage = aml_val2int(ctx, res.v_package[4]);
	sc->sc_bif.bif_warning = aml_val2int(ctx, res.v_package[5]);
	sc->sc_bif.bif_low = aml_val2int(ctx, res.v_package[6]);
	sc->sc_bif.bif_cap_granu1 = aml_val2int(ctx, res.v_package[7]);
	sc->sc_bif.bif_cap_granu2 = aml_val2int(ctx, res.v_package[8]);
	sc->sc_bif.bif_model = aml_strval(res.v_package[9]);
	sc->sc_bif.bif_serial = aml_strval(res.v_package[10]);
	sc->sc_bif.bif_type = aml_strval(res.v_package[11]);
	sc->sc_bif.bif_oem = aml_strval(res.v_package[12]);
d322 1
d330 1
a330 2
	struct aml_value	res, env;
	struct acpi_context	*ctx;
d335 1
a335 5
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_BST", &res, &env)) {
d350 5
a354 4
	sc->sc_bst.bst_state = aml_val2int(ctx, res.v_package[0]);
	sc->sc_bst.bst_rate = aml_val2int(ctx, res.v_package[1]);
	sc->sc_bst.bst_capacity = aml_val2int(ctx, res.v_package[2]);
	sc->sc_bst.bst_voltage = aml_val2int(ctx, res.v_package[3]);
@


1.23
log
@fix a bad strlcpy, from ben lovett
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.22 2006/05/19 09:10:50 canacar Exp $ */
d371 2
a372 2
/* XXX it has been observed that some systemts do not propagate battery
 * inserion events up to the driver.  What seems to happen is that DSDT
@


1.22
log
@Use rwlock instead of lockmgr locks.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.21 2006/04/30 05:22:27 marco Exp $ */
d152 1
a152 1
	    sizeof(sc->sc_sens[2].desc));
@


1.21
log
@rv not set.  Sloppy but didn't matter.
pointed out by joris@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.20 2006/03/05 04:47:25 marco Exp $ */
d22 1
a22 1
#include <sys/lock.h>
d47 1
a47 1
	struct lock		sc_lock;
d95 1
a95 1
	lockinit(&sc->sc_lock, PZERO, DEVNAME(sc), 0, 0);
d215 1
a215 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d247 1
a247 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d257 1
a257 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d324 1
a324 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d335 1
a335 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d367 1
a367 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.20
log
@KNF nit.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.19 2006/02/22 19:28:17 marco Exp $ */
d333 1
a333 1
	int			rv;
d345 1
d352 1
@


1.19
log
@Rework notify handler.
Use jordan's new notify register function.
ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.18 2006/02/22 15:29:23 marco Exp $ */
d130 2
a131 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpibat_notify, sc);
@


1.18
log
@Add insertion and removal events for batteries.
Some cleanup & KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.17 2006/02/21 20:25:26 marco Exp $ */
d130 1
a130 1
	aml_register_notify(sc->sc_devnode->parent, acpibat_notify, sc);
d393 2
a396 4
		sc->sc_bat_present = 1;
		acpibat_getbif(sc);
		acpibat_getbst(sc);

d400 7
a406 6
		sensor_task_unregister(sc);
		sc->sc_bat_present = 0;
		strlcpy(sc->sc_sens[4].desc, "battery removed",
		    sizeof(sc->sc_sens[4].desc));
		printf("%s: %s: removed\n", DEVNAME(sc),
		    sc->sc_devnode->parent->name);
d408 2
d416 4
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.16 2006/02/21 01:12:40 marco Exp $ */
d19 1
d22 1
d47 1
d50 1
d63 1
d67 1
d89 2
a90 1
	int			i;
d95 30
a124 2
	if (acpibat_getbif(sc))
		return;
d126 12
a137 1
	acpibat_getbst(sc); 
d139 1
a139 5
	printf(": model: %s serial: %s type: %s oem: %s\n",
	    sc->sc_bif.bif_model,
	    sc->sc_bif.bif_serial,
	    sc->sc_bif.bif_type,
	    sc->sc_bif.bif_oem);
d142 7
d150 2
a151 5
	/* XXX this is for debug only, remove later */
	for (i = 0; i < 13; i++)
		strlcpy(sc->sc_sens[i].device, DEVNAME(sc), sizeof(sc->sc_sens[i].device));

	strlcpy(sc->sc_sens[0].desc, "last full capacity", sizeof(sc->sc_sens[2].desc));
d154 2
a155 1
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
d157 2
a158 1
	strlcpy(sc->sc_sens[1].desc, "warning capacity", sizeof(sc->sc_sens[1].desc));
d161 2
a162 1
	sc->sc_sens[1].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
d164 2
a165 1
	strlcpy(sc->sc_sens[2].desc, "low capacity", sizeof(sc->sc_sens[2].desc));
d168 2
a169 1
	sc->sc_sens[2].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
d188 2
a189 1
	strlcpy(sc->sc_sens[6].desc, "remaining capacity", sizeof(sc->sc_sens[6].desc));
d192 2
a193 1
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
d195 2
a196 1
	strlcpy(sc->sc_sens[7].desc, "current voltage", sizeof(sc->sc_sens[7].desc));
a200 3

	if (sensor_task_register(sc, acpibat_refresh, 10))
		printf(", unable to register update task\n");
a202 1
/* XXX this is for debug only, remove later */
d208 3
d214 12
a225 3
	sc->sc_sens[0].value = sc->sc_bif.bif_last_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sc_sens[1].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sc_sens[2].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
d230 2
a231 1
		strlcpy(sc->sc_sens[4].desc, "battery discharging", sizeof(sc->sc_sens[4].desc));
d233 2
a234 1
		strlcpy(sc->sc_sens[4].desc, "battery charging", sizeof(sc->sc_sens[4].desc));
d236 2
a237 1
		strlcpy(sc->sc_sens[4].desc, "battery critical", sizeof(sc->sc_sens[4].desc));
d242 5
a246 1
	sc->sc_sens[6].value = sc->sc_bst.bst_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
d254 3
d265 1
a265 1
		return (1);
d268 2
d271 1
a271 1
		printf(": battery not present\n");
d273 3
a275 1
	}
d280 2
a281 1
		return (1);
d287 1
a287 1
		return (1);
d290 1
d322 3
a324 1
	return (0);
d332 3
d343 2
a344 1
		return (1);
d350 1
a350 1
		return (1);
d363 52
@


1.16
log
@Adjust debugging levels to something more reasonable.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.15 2006/02/17 07:25:51 marco Exp $ */
d33 2
a34 2
int acpibat_match(struct device *, void *, void *);
void acpibat_attach(struct device *, struct device *, void *);
d48 1
a48 1
	struct sensor sens[13];	/* XXX debug only */
d59 3
a61 3
void acpibat_refresh(void *);
int acpibat_getbif(struct acpibat_softc *);
int acpibat_getbst(struct acpibat_softc *);
d66 2
a67 2
	struct acpi_attach_args *aa = aux;
	struct cfdata *cf = match;
d81 3
a83 3
	struct acpibat_softc *sc = (struct acpibat_softc *) self;
	struct acpi_attach_args *aa = aux;
	int i;
d99 1
a99 1
	memset(sc->sens, 0, sizeof(sc->sens));
d103 1
a103 1
		strlcpy(sc->sens[i].device, DEVNAME(sc), sizeof(sc->sens[i].device));
d105 42
a146 42
	strlcpy(sc->sens[0].desc, "last full capacity", sizeof(sc->sens[2].desc));
	sc->sens[0].type = SENSOR_PERCENT;
	sensor_add(&sc->sens[0]);
	sc->sens[0].value = sc->sc_bif.bif_last_capacity / sc->sc_bif.bif_cap_granu1 * 1000;

	strlcpy(sc->sens[1].desc, "warning capacity", sizeof(sc->sens[1].desc));
	sc->sens[1].type = SENSOR_PERCENT;
	sensor_add(&sc->sens[1]);
	sc->sens[1].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;

	strlcpy(sc->sens[2].desc, "low capacity", sizeof(sc->sens[2].desc));
	sc->sens[2].type = SENSOR_PERCENT;
	sensor_add(&sc->sens[2]);
	sc->sens[2].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;

	strlcpy(sc->sens[3].desc, "voltage", sizeof(sc->sens[3].desc));
	sc->sens[3].type = SENSOR_VOLTS_DC;
	sensor_add(&sc->sens[3]);
	sc->sens[3].status = SENSOR_S_OK;
	sc->sens[3].value = sc->sc_bif.bif_voltage * 1000;

	strlcpy(sc->sens[4].desc, "state", sizeof(sc->sens[4].desc));
	sc->sens[4].type = SENSOR_INTEGER;
	sensor_add(&sc->sens[4]);
	sc->sens[4].status = SENSOR_S_OK;
	sc->sens[4].value = sc->sc_bst.bst_state;

	strlcpy(sc->sens[5].desc, "rate", sizeof(sc->sens[5].desc));
	sc->sens[5].type = SENSOR_INTEGER;
	sensor_add(&sc->sens[5]);
	sc->sens[5].value = sc->sc_bst.bst_rate;

	strlcpy(sc->sens[6].desc, "remaining capacity", sizeof(sc->sens[6].desc));
	sc->sens[6].type = SENSOR_PERCENT;
	sensor_add(&sc->sens[6]);
	sc->sens[6].value = sc->sc_bst.bst_capacity / sc->sc_bif.bif_cap_granu1 * 1000;

	strlcpy(sc->sens[7].desc, "current voltage", sizeof(sc->sens[7].desc));
	sc->sens[7].type = SENSOR_VOLTS_DC;
	sensor_add(&sc->sens[7]);
	sc->sens[7].status = SENSOR_S_OK;
	sc->sens[7].value = sc->sc_bst.bst_voltage * 1000;
d156 1
a156 1
	struct acpibat_softc *sc = arg;
d161 4
a164 4
	sc->sens[0].value = sc->sc_bif.bif_last_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sens[1].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sens[2].value = sc->sc_bif.bif_warning / sc->sc_bif.bif_cap_granu1 * 1000;
	sc->sens[3].value = sc->sc_bif.bif_voltage * 1000;
d166 1
a166 1
	sc->sens[4].status = SENSOR_S_OK;
d168 1
a168 1
		strlcpy(sc->sens[4].desc, "battery discharging", sizeof(sc->sens[4].desc));
d170 1
a170 1
		strlcpy(sc->sens[4].desc, "battery charging", sizeof(sc->sens[4].desc));
d172 2
a173 2
		strlcpy(sc->sens[4].desc, "battery critical", sizeof(sc->sens[4].desc));
		sc->sens[4].status = SENSOR_S_CRIT;
d175 3
a177 3
	sc->sens[4].value = sc->sc_bst.bst_state;
	sc->sens[5].value = sc->sc_bst.bst_rate;
	sc->sens[6].value = sc->sc_bst.bst_capacity / sc->sc_bif.bif_cap_granu1 * 1000;
d183 2
a184 2
	struct aml_value res, env;
	struct acpi_context *ctx;
d250 2
a251 2
	struct aml_value res, env;
	struct acpi_context *ctx;
@


1.15
log
@Better comments.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.14 2006/02/17 07:09:25 marco Exp $ */
d202 1
a202 1
		dnprintf(50, "%s: no _BIF\n",
d227 1
a227 1
	dnprintf(10, "power_unit: %u capacity: %u last_cap: %u tech: %u "
d258 1
a258 1
		dnprintf(50, "%s: no _BST\n",
d274 1
a274 1
	dnprintf(10, "state: %u rate: %u cap: %u volt: %u ",
@


1.14
log
@Propogate some values through the sysctl hw.sesnsors interface for debug
purposes.  This will be removed later and replaced with something better.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.13 2006/02/17 00:45:27 marco Exp $ */
a77 1
/* XXX this is for debug only, remove later */
d101 1
d152 1
@


1.13
log
@Detect if battery slot is available but without a battery in it.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.12 2006/02/16 22:14:32 marco Exp $ */
d31 2
d47 2
d59 1
d78 1
d84 1
d99 78
@


1.12
log
@Print useful information during boot about the battery and power supply.

ok jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.11 2006/02/16 21:07:16 marco Exp $ */
d81 4
a84 1
	acpibat_getbif(sc); 
a86 11
/*
	printf(": max cap: %u last max cap: %u current cap: %u model: %s "
	    "serial: %s type: %s oem: %s\n",
	    sc->sc_bif.bif_capacity,
	    sc->sc_bif.bif_last_capacity,
	    sc->sc_bst.bst_capacity,
	    sc->sc_bif.bif_model,
	    sc->sc_bif.bif_serial,
	    sc->sc_bif.bif_type,
	    sc->sc_bif.bif_oem);
*/
d110 4
a113 1
	dnprintf(40, "_STA value: %x\n", res.v_integer);
@


1.11
log
@Adjust debug levels to something sane.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.10 2006/02/03 23:55:47 jordan Exp $ */
d84 16
a99 1
	printf("\n");
d112 8
@


1.10
log
@Rewrote aml parser yet again...
Fixed bus_space_map for i386/amd64
Added _BST and _BIF to acpibat to get status/info
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.9 2006/01/17 23:42:14 jordan Exp $ */
d91 1
d96 1
d109 9
a117 9
	sc->sc_bif.bif_power_unit = aml_intval(res.v_package[0]);
	sc->sc_bif.bif_capacity = aml_intval(res.v_package[1]);
	sc->sc_bif.bif_last_capacity = aml_intval(res.v_package[2]);
	sc->sc_bif.bif_technology = aml_intval(res.v_package[3]);
	sc->sc_bif.bif_voltage = aml_intval(res.v_package[4]);
	sc->sc_bif.bif_warning = aml_intval(res.v_package[5]);
	sc->sc_bif.bif_low = aml_intval(res.v_package[6]);
	sc->sc_bif.bif_cap_granu1 = aml_intval(res.v_package[7]);
	sc->sc_bif.bif_cap_granu2 = aml_intval(res.v_package[8]);
d123 1
a123 1
	dnprintf(20, "power_unit: %u capacity: %u last_cap: %u tech: %u "
d147 1
d152 1
d165 4
a168 4
	sc->sc_bst.bst_state = aml_intval(res.v_package[0]);
	sc->sc_bst.bst_rate = aml_intval(res.v_package[1]);
	sc->sc_bst.bst_capacity = aml_intval(res.v_package[2]);
	sc->sc_bst.bst_voltage = aml_intval(res.v_package[3]);
d170 1
a170 1
	dnprintf(20, "state: %u rate: %u cap: %u volt: %u ",
@


1.9
log
@Major overhaul of the aml parser.  Evaluater temporarily disabled.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.8 2006/01/06 09:06:21 grange Exp $ */
d81 2
a82 1
	/* acpibat_getbif(sc); */
@


1.8
log
@Sudden newline
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.7 2005/12/30 05:59:40 tedu Exp $ */
d106 13
a118 13
	sc->sc_bif.bif_power_unit = aml_intval(&res.v_package[0]);
	sc->sc_bif.bif_capacity = aml_intval(&res.v_package[1]);
	sc->sc_bif.bif_last_capacity = aml_intval(&res.v_package[2]);
	sc->sc_bif.bif_technology = aml_intval(&res.v_package[3]);
	sc->sc_bif.bif_voltage = aml_intval(&res.v_package[4]);
	sc->sc_bif.bif_warning = aml_intval(&res.v_package[5]);
	sc->sc_bif.bif_low = aml_intval(&res.v_package[6]);
	sc->sc_bif.bif_cap_granu1 = aml_intval(&res.v_package[7]);
	sc->sc_bif.bif_cap_granu2 = aml_intval(&res.v_package[8]);
	sc->sc_bif.bif_model = aml_strval(&res.v_package[9]);
	sc->sc_bif.bif_serial = aml_strval(&res.v_package[10]);
	sc->sc_bif.bif_type = aml_strval(&res.v_package[11]);
	sc->sc_bif.bif_oem = aml_strval(&res.v_package[12]);
d160 4
a163 4
	sc->sc_bst.bst_state = aml_intval(&res.v_package[0]);
	sc->sc_bst.bst_rate = aml_intval(&res.v_package[1]);
	sc->sc_bst.bst_capacity = aml_intval(&res.v_package[2]);
	sc->sc_bst.bst_voltage = aml_intval(&res.v_package[3]);
@


1.7
log
@make ACPI_DEBUG compile
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.6 2005/12/28 03:25:15 marco Exp $ */
a77 2

	printf("\n");
@


1.6
log
@oops enabled a method that doesnt work yet so disabled getbif for now.
ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.5 2005/12/28 03:18:56 marco Exp $ */
d97 1
a97 1
		dprintf(50, "%s: no _BIF\n",
d122 1
a122 1
	dprintf(20, "power_unit: %u capacity: %u last_cap: %u tech: %u "
d151 1
a151 1
		dprintf(50, "%s: no _BST\n",
d167 1
a167 1
	dprintf(20, "state: %u rate: %u cap: %u volt: %u ",
@


1.5
log
@Add some return values to getbst and getbif.
ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.4 2005/12/28 03:08:33 marco Exp $ */
d83 1
a83 1
	acpibat_getbif(sc);
@


1.4
log
@Add 2 methods (Battery Info and Battery Status)
ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.3 2005/12/16 04:16:59 marco Exp $ */
d55 2
a56 2
void acpibat_getbif(struct acpibat_softc *);
void acpibat_getbst(struct acpibat_softc *);
d83 1
a83 1
	/* acpibat_getbif(sc); */
d88 1
a88 1
void
d99 1
a99 1
		return;
d105 1
a105 1
		return;
d138 2
d142 1
a142 1
void
d153 1
a153 1
		return;
d159 1
a159 1
		return;
d172 2
@


1.3
log
@Use new unified header.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.2 2005/12/13 23:19:48 marco Exp $ */
d28 2
d39 6
d55 3
a75 1
/*
a76 1
	struct acpi_softc *psc = (struct acpi_softc *) parent;
a77 3
	bus_addr_t address;
	bus_size_t size;
*/
d80 90
@


1.2
log
@Use shiny new acpibat.h
@
text
@d1 1
a1 1
/* $OpenBSD: acpibat.c,v 1.1 2005/12/13 07:21:47 marco Exp $ */
d27 1
a27 1
#include <dev/acpi/acpibat.h>
@


1.1
log
@Add battery device.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d27 1
@

