head	1.78;
access;
symbols
	OPENBSD_6_1_BASE:1.78
	OPENBSD_6_0:1.74.0.2
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.68.0.4
	OPENBSD_5_8_BASE:1.68
	OPENBSD_5_7:1.62.0.4
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.57.0.18
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.14
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.12
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.10
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.8
	OPENBSD_5_0:1.57.0.6
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.57.0.4
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.57.0.2
	OPENBSD_4_8_BASE:1.57
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.55.0.4
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.45.0.2
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5;
locks; strict;
comment	@ * @;


1.78
date	2016.09.18.23.56.45;	author guenther;	state Exp;
branches;
next	1.77;
commitid	3z1ANZSruW1t207J;

1.77
date	2016.09.16.20.16.06;	author guenther;	state Exp;
branches;
next	1.76;
commitid	7h0ALN4WqOZRPRDT;

1.76
date	2016.09.02.13.59.51;	author pirofti;	state Exp;
branches;
next	1.75;
commitid	QA6Gb7VSg6HVRahN;

1.75
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.74;
commitid	h0GHFDGWnEdswfbK;

1.74
date	2016.03.17.13.18.47;	author mpi;	state Exp;
branches;
next	1.73;
commitid	YYXwHgvcvZhstSh4;

1.73
date	2016.03.14.06.37.31;	author guenther;	state Exp;
branches;
next	1.72;
commitid	uE59hV3t3wI6I7pN;

1.72
date	2015.12.29.04.46.28;	author mmcc;	state Exp;
branches;
next	1.71;
commitid	QKSTqnEw1KIrhSLM;

1.71
date	2015.12.23.17.07.09;	author jcs;	state Exp;
branches;
next	1.70;
commitid	gVzo2sWsobA9B9YG;

1.70
date	2015.09.12.07.52.27;	author guenther;	state Exp;
branches;
next	1.69;
commitid	0UvjHC4auk8kKRQV;

1.69
date	2015.09.11.22.44.30;	author guenther;	state Exp;
branches;
next	1.68;
commitid	FarsQCl6KKdbskpu;

1.68
date	2015.08.04.22.25.54;	author guenther;	state Exp;
branches;
next	1.67;
commitid	Frhk4878929JzgfM;

1.67
date	2015.08.04.15.21.59;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	P73HnACOOxY50UlR;

1.66
date	2015.08.04.05.15.02;	author guenther;	state Exp;
branches;
next	1.65;
commitid	nq4iO3tdFZwUYGiI;

1.65
date	2015.07.18.15.20.13;	author guenther;	state Exp;
branches;
next	1.64;
commitid	sYTEclVTagJmjRpK;

1.64
date	2015.06.13.21.41.42;	author guenther;	state Exp;
branches;
next	1.63;
commitid	niRu91s4TwItA66c;

1.63
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.62;
commitid	p4LJxGKbi0BU2cG6;

1.62
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.61;
commitid	yWAxzpQP2PPpYlfT;

1.61
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.60;
commitid	uzzBR7hz9ncd4O6G;

1.60
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.59;
commitid	I19imNlAX05zJOED;

1.59
date	2014.07.11.14.33.45;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	FjTyQFNScgMxTvQf;

1.58
date	2014.05.21.02.14.07;	author mlarkin;	state Exp;
branches;
next	1.57;

1.57
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.29.11.01.15;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.23.13.21.48;	author gwk;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.10.03.42.20;	author gwk;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.24.13.20.02;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.24.06.25.32;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.18.03.13.49;	author marco;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.22.07.19.09;	author gwk;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.22.06.37.36;	author gwk;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.22.16.03.31;	author gwk;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.11.20.31.50;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.08.01.05.20;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.06.05.24.44;	author gwk;	state Exp;
branches;
next	1.44;

1.44
date	2008.06.15.05.24.07;	author gwk;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.07.19.53.49;	author pvalchev;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.06.18.01.31;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2007.12.29.02.55.44;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2007.12.27.22.32.37;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2007.12.27.19.04.06;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.27.01.18.50;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.05.21.42.14;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.03.00.25.24;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.16.16.55.27;	author mikeb;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.16.16.16.04;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.11.15.19.05.58;	author mikeb;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.12.21.58.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.12.19.55.46;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.12.04.31.16;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.03.20.53.02;	author gwk;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.15.22.37.40;	author gwk;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.17.49.16;	author gwk;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.28.20.22.24;	author robert;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.28.03.38.32;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.06.04.09.43;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.23.04.34.30;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.11.02.51.11;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.31.23.30.51;	author gwk;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.29.04.28.44;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.20.22.48.29;	author gwk;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.20.17.50.40;	author gwk;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.19.20.28.11;	author gwk;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.19.16.48.16;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.19.16.20.01;	author gwk;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.09.05.16.27;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.05.04.48.55;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.04.18.24.34;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.04.05.36.42;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.26.17.28.26;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.26.07.59.20;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.26.05.17.25;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.26.04.38.38;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.26.02.49.28;	author marco;	state Exp;
branches;
next	;


desc
@@


1.78
log
@If the APIC table (MADT) isn't present then ci_acpi_proc_id won't be set
when acpicpu tries to attach, leading to a NULL dereference.  The ACPI
processor object on the Dells where this was reported is bogus and useless
anyway so apply the same test when deciding whether to attach to processor
objects as acpicpu would when matching them to cpus.

Problem reported by Eivind Eide (xenofil (at) gmail.com) and
Johan Huldtgren (johan+openbsd-bugs (at) huldtgren.com).
Testing by Eivind Eide.
ok kettenis@@ mlarkin@@
@
text
@/* $OpenBSD: acpicpu.c,v 1.77 2016/09/16 20:16:06 guenther Exp $ */
/*
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 * Copyright (c) 2015 Philip Guenther <guenther@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/kernel.h>		/* for tick */
#include <sys/signalvar.h>
#include <sys/sysctl.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/atomic.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/cpufunc.h>
#include <machine/specialreg.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <sys/sensors.h>

int	acpicpu_match(struct device *, void *, void *);
void	acpicpu_attach(struct device *, struct device *, void *);
int	acpicpu_notify(struct aml_node *, int, void *);
void	acpicpu_setperf(int);
void	acpicpu_setperf_ppc_change(struct acpicpu_pss *, int);

#define ACPI_STATE_C0		0x00
#define ACPI_STATE_C1		0x01
#define ACPI_STATE_C2		0x02
#define ACPI_STATE_C3		0x03

#define ACPI_PDC_REVID		0x1
#define ACPI_PDC_SMP		0xa
#define ACPI_PDC_MSR		0x1

/* _PDC/_OSC Intel capabilities flags */
#define ACPI_PDC_P_FFH		0x0001
#define ACPI_PDC_C_C1_HALT	0x0002
#define ACPI_PDC_T_FFH		0x0004
#define ACPI_PDC_SMP_C1PT	0x0008
#define ACPI_PDC_SMP_C2C3	0x0010
#define ACPI_PDC_SMP_P_SWCOORD	0x0020
#define ACPI_PDC_SMP_C_SWCOORD	0x0040
#define ACPI_PDC_SMP_T_SWCOORD	0x0080
#define ACPI_PDC_C_C1_FFH	0x0100
#define ACPI_PDC_C_C2C3_FFH	0x0200
/* reserved			0x0400 */
#define ACPI_PDC_P_HWCOORD	0x0800
#define ACPI_PDC_PPC_NOTIFY	0x1000

#define CST_METH_HALT		0
#define CST_METH_IO_HALT	1
#define CST_METH_MWAIT		2
#define CST_METH_GAS_IO		3

/* flags on Intel's FFH mwait method */
#define CST_FLAG_MWAIT_HW_COORD		0x1
#define CST_FLAG_MWAIT_BM_AVOIDANCE	0x2
#define CST_FLAG_FALLBACK		0x4000	/* fallback for broken _CST */
#define CST_FLAG_SKIP			0x8000	/* state is worse choice */

#define FLAGS_MWAIT_ONLY	0x02
#define FLAGS_BMCHECK		0x04
#define FLAGS_NOTHROTTLE	0x08
#define FLAGS_NOPSS		0x10
#define FLAGS_NOPCT		0x20

#define CPU_THT_EN		(1L << 4)
#define CPU_MAXSTATE(sc)	(1L << (sc)->sc_duty_wid)
#define CPU_STATE(sc,pct)	((pct * CPU_MAXSTATE(sc) / 100) << (sc)->sc_duty_off)
#define CPU_STATEMASK(sc)	((CPU_MAXSTATE(sc) - 1) << (sc)->sc_duty_off)

#define ACPI_MAX_C2_LATENCY	100
#define ACPI_MAX_C3_LATENCY	1000

#define CSD_COORD_SW_ALL	0xFC
#define CSD_COORD_SW_ANY	0xFD
#define CSD_COORD_HW_ALL	0xFE

/* Make sure throttling bits are valid,a=addr,o=offset,w=width */
#define valid_throttle(o,w,a)	(a && w && (o+w)<=31 && (o>4 || (o+w)<=4))

struct acpi_cstate
{
	SLIST_ENTRY(acpi_cstate) link;

	u_short		state;
	short		method;		/* CST_METH_* */
	u_short		flags;		/* CST_FLAG_* */
	u_short		latency;
	int		power;
	u_int64_t	address;	/* or mwait hint */
};

unsigned long cst_stats[4] = { 0 };

struct acpicpu_softc {
	struct device		sc_dev;
	int			sc_cpu;

	int			sc_duty_wid;
	int			sc_duty_off;
	u_int32_t		sc_pblk_addr;
	int			sc_pblk_len;
	int			sc_flags;
	unsigned long		sc_prev_sleep;
	unsigned long		sc_last_itime;

	struct cpu_info		*sc_ci;
	SLIST_HEAD(,acpi_cstate) sc_cstates;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	int			sc_pss_len;
	int			sc_ppc;
	int			sc_level;
	struct acpicpu_pss	*sc_pss;

	struct acpicpu_pct	sc_pct;
	/* save compensation for pct access for lying bios' */
	u_int32_t		sc_pct_stat_as;
	u_int32_t		sc_pct_ctrl_as;
	u_int32_t		sc_pct_stat_len;
	u_int32_t		sc_pct_ctrl_len;
	/*
	 * XXX: _PPC Change listener
	 * PPC changes can occur when for example a machine is disconnected
	 * from AC power and can no loger support the highest frequency or
	 * voltage when driven from the battery.
	 * Should probably be reimplemented as a list for now we assume only
	 * one listener
	 */
	void			(*sc_notify)(struct acpicpu_pss *, int);
};

void	acpicpu_add_cstatepkg(struct aml_value *, void *);
void	acpicpu_add_cdeppkg(struct aml_value *, void *);
int	acpicpu_getppc(struct acpicpu_softc *);
int	acpicpu_getpct(struct acpicpu_softc *);
int	acpicpu_getpss(struct acpicpu_softc *);
int	acpicpu_getcst(struct acpicpu_softc *);
void	acpicpu_getcst_from_fadt(struct acpicpu_softc *);
void	acpicpu_print_one_cst(struct acpi_cstate *_cx);
void	acpicpu_print_cst(struct acpicpu_softc *_sc);
void	acpicpu_add_cstate(struct acpicpu_softc *_sc, int _state, int _method,
	    int _flags, int _latency, int _power, u_int64_t _address);
void	acpicpu_set_pdc(struct acpicpu_softc *);
void	acpicpu_idle(void);

#if 0
void    acpicpu_set_throttle(struct acpicpu_softc *, int);
struct acpi_cstate *acpicpu_find_cstate(struct acpicpu_softc *, int);
#endif

struct cfattach acpicpu_ca = {
	sizeof(struct acpicpu_softc), acpicpu_match, acpicpu_attach
};

struct cfdriver acpicpu_cd = {
	NULL, "acpicpu", DV_DULL
};

extern int setperf_prio;

struct acpicpu_softc *acpicpu_sc[MAXCPUS];

#if 0
void
acpicpu_set_throttle(struct acpicpu_softc *sc, int level)
{
	uint32_t pbval;

	if (sc->sc_flags & FLAGS_NOTHROTTLE)
		return;

	/* Disable throttling control */
	pbval = inl(sc->sc_pblk_addr);
	outl(sc->sc_pblk_addr, pbval & ~CPU_THT_EN);
	if (level < 100) {
		pbval &= ~CPU_STATEMASK(sc);
		pbval |= CPU_STATE(sc, level);
		outl(sc->sc_pblk_addr, pbval & ~CPU_THT_EN);
		outl(sc->sc_pblk_addr, pbval | CPU_THT_EN);
	}
}

struct acpi_cstate *
acpicpu_find_cstate(struct acpicpu_softc *sc, int state)
{
	struct acpi_cstate	*cx;

	SLIST_FOREACH(cx, &sc->sc_cstates, link)
		if (cx->state == state)
			return cx;
	return (NULL);
}
#endif


void
acpicpu_set_pdc(struct acpicpu_softc *sc)
{
	struct aml_value cmd, osc_cmd[4];
	struct aml_value res;
	uint32_t cap;
	uint32_t buf[3];

	/* 4077A616-290C-47BE-9EBD-D87058713953 */
	static uint8_t cpu_oscuuid[16] = { 0x16, 0xA6, 0x77, 0x40, 0x0C, 0x29,
					   0xBE, 0x47, 0x9E, 0xBD, 0xD8, 0x70,
					   0x58, 0x71, 0x39, 0x53 };
	cap = ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH | ACPI_PDC_C_C1_FFH
	    | ACPI_PDC_C_C2C3_FFH | ACPI_PDC_SMP_P_SWCOORD | ACPI_PDC_SMP_C2C3
	    | ACPI_PDC_SMP_C1PT;

	if (aml_searchname(sc->sc_devnode, "_OSC")) {
		/* Query _OSC */
		memset(&osc_cmd, 0, sizeof(cmd) * 4);
		osc_cmd[0].type = AML_OBJTYPE_BUFFER;
		osc_cmd[0].v_buffer = (uint8_t *)&cpu_oscuuid;
		osc_cmd[0].length = sizeof(cpu_oscuuid);

		osc_cmd[1].type = AML_OBJTYPE_INTEGER;
		osc_cmd[1].v_integer = 1;
		osc_cmd[1].length = 1;

		osc_cmd[2].type = AML_OBJTYPE_INTEGER;
		osc_cmd[2].v_integer = 2;
		osc_cmd[2].length = 1;

		buf[0] = 1;
		buf[1] = cap;
		osc_cmd[3].type = AML_OBJTYPE_BUFFER;
		osc_cmd[3].v_buffer = (int8_t *)&buf;
		osc_cmd[3].length = sizeof(buf);

		aml_evalname(sc->sc_acpi, sc->sc_devnode, "_OSC",
		    4, osc_cmd, &res);

		if (res.type != AML_OBJTYPE_BUFFER || res.length < 8) {
			printf(": unable to query capabilities\n");
			aml_freevalue(&res);
			return;
		}

		/* Evaluate _OSC */
		memset(&osc_cmd, 0, sizeof(cmd) * 4);
		osc_cmd[0].type = AML_OBJTYPE_BUFFER;
		osc_cmd[0].v_buffer = (uint8_t *)&cpu_oscuuid;
		osc_cmd[0].length = sizeof(cpu_oscuuid);

		osc_cmd[1].type = AML_OBJTYPE_INTEGER;
		osc_cmd[1].v_integer = 1;
		osc_cmd[1].length = 1;

		osc_cmd[2].type = AML_OBJTYPE_INTEGER;
		osc_cmd[2].v_integer = 2;
		osc_cmd[2].length = 1;

		buf[0] = 0;
		buf[1] = (*(uint32_t *)&res.v_buffer[4]) & cap;
		osc_cmd[3].type = AML_OBJTYPE_BUFFER;
		osc_cmd[3].v_buffer = (int8_t *)&buf;
		osc_cmd[3].length = sizeof(buf);

		aml_freevalue(&res);

		aml_evalname(sc->sc_acpi, sc->sc_devnode, "_OSC",
		    4, osc_cmd, NULL);
	} else {
		/* Evaluate _PDC */
		memset(&cmd, 0, sizeof(cmd));
		cmd.type = AML_OBJTYPE_BUFFER;
		cmd.v_buffer = (uint8_t *)&buf;
		cmd.length = sizeof(buf);

		buf[0] = ACPI_PDC_REVID;
		buf[1] = 1;
		buf[2] = cap;

		aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PDC",
		    1, &cmd, NULL);
	}
}

/*
 * sanity check mwait hints against what cpuid told us
 */
static int
check_mwait_hints(int state, int hints)
{
	int cstate;
	int substate;
	int num_substates;

	if (cpu_mwait_size == 0)
		return (0);
	cstate = ((hints >> 4) & 0xf) + 1;
	if (cstate == 16)
		cstate = 0;
	else if (cstate > 7) {
		/* out of range of test against CPUID; just trust'em */
		return (1);
	}
	substate = hints & 0xf;
	num_substates = (cpu_mwait_states >> (4 * cstate)) & 0xf;
	if (substate >= num_substates) {
		printf("\nC%d: state %d: substate %d >= num %d",
		    state, cstate, substate, num_substates);
		return (0);
	}
	return (1);
}

void
acpicpu_add_cstate(struct acpicpu_softc *sc, int state, int method,
    int flags, int latency, int power, u_int64_t address)
{
	struct acpi_cstate	*cx;

	dnprintf(10," C%d: latency:.%4x power:%.4x addr:%.16llx\n",
	    state, latency, power, address);

	/* add a new state, or overwrite the fallback C1 state? */
	if (state != ACPI_STATE_C1 ||
	    (cx = SLIST_FIRST(&sc->sc_cstates)) == NULL ||
	    (cx->flags & CST_FLAG_FALLBACK) == 0) {
		cx = malloc(sizeof(*cx), M_DEVBUF, M_WAITOK);
		SLIST_INSERT_HEAD(&sc->sc_cstates, cx, link);
	}

	cx->state = state;
	cx->method = method;
	cx->flags = flags;
	cx->latency = latency;
	cx->power = power;
	cx->address = address;
}

/* Found a _CST object, add new cstate for each entry */
void
acpicpu_add_cstatepkg(struct aml_value *val, void *arg)
{
	struct acpicpu_softc	*sc = arg;
	u_int64_t addr;
	struct acpi_grd *grd;
	int state, method, flags;

#if defined(ACPI_DEBUG) && !defined(SMALL_KERNEL)
	aml_showvalue(val);
#endif
	if (val->type != AML_OBJTYPE_PACKAGE || val->length != 4)
		return;

	/* range and sanity checks */
	state = val->v_package[1]->v_integer;
	if (state < 0 || state > 4)
		return;
	if (val->v_package[0]->type != AML_OBJTYPE_BUFFER) {
		printf("\nC%d: unexpected ACPI object type %d",
		    state, val->v_package[0]->type);
		return;
	}
	grd = (struct acpi_grd *)val->v_package[0]->v_buffer;
	if (val->v_package[0]->length != sizeof(*grd) + 2 ||
	    grd->grd_descriptor != LR_GENREGISTER ||
	    grd->grd_length != sizeof(grd->grd_gas) ||
	    val->v_package[0]->v_buffer[sizeof(*grd)] != SRT_ENDTAG) {
		printf("\nC%d: bogo buffer", state);
		return;
	}

	flags = 0;
	switch (grd->grd_gas.address_space_id) {
	case GAS_FUNCTIONAL_FIXED:
		if (grd->grd_gas.register_bit_width == 0) {
			method = CST_METH_HALT;
			addr = 0;
		} else if (grd->grd_gas.register_bit_width == 1 ||
		           grd->grd_gas.register_bit_width == 8) {
			/*
			 * vendor 1 == Intel
			 * vendor 8 == "AML author used the bitwidth"
			 */
			switch (grd->grd_gas.register_bit_offset) {
			case 0x1:
				method = CST_METH_IO_HALT;
				addr = grd->grd_gas.address;

				/* i386 and amd64 I/O space is 16bits */
				if (addr > 0xffff) {
					printf("\nC%d: bogo I/O addr %llx",
					    state, addr);
					return;
				}
				break;
			case 0x2:
				addr = grd->grd_gas.address;
				if (!check_mwait_hints(state, addr))
					return;
				method = CST_METH_MWAIT;
				flags = grd->grd_gas.access_size;
				break;
			default:
				printf("\nC%d: unknown FFH class %d",
				    state, grd->grd_gas.register_bit_offset);
				return;
			}
		} else {
			printf("\nC%d: unknown FFH vendor %d",
			    state, grd->grd_gas.register_bit_width);
			return;
		}
		break;

	case GAS_SYSTEM_IOSPACE:
		addr = grd->grd_gas.address;
		if (grd->grd_gas.register_bit_width != 8 ||
		    grd->grd_gas.register_bit_offset != 0) {
			printf("\nC%d: unhandled %s spec: %d/%d", state,
			    "I/O", grd->grd_gas.register_bit_width,
			    grd->grd_gas.register_bit_offset);
			return;
		}
		method = CST_METH_GAS_IO;
		break;

	default:
		/* dump the GAS for analysis */
		{
			int i;
			printf("\nC%d: unhandled GAS:", state);
			for (i = 0; i < sizeof(grd->grd_gas); i++)
				printf(" %#x", ((u_char *)&grd->grd_gas)[i]);

		}
		return;
	}

	acpicpu_add_cstate(sc, state, method, flags,
	    val->v_package[2]->v_integer, val->v_package[3]->v_integer, addr);
}


/* Found a _CSD object, print the dependency  */
void
acpicpu_add_cdeppkg(struct aml_value *val, void *arg)
{
	int64_t	num_proc, coord_type, domain, cindex;

	/*
	 * errors: unexpected object type, bad length, mismatched length,
	 * and bad CSD revision 
	 */
	if (val->type != AML_OBJTYPE_PACKAGE || val->length < 6 ||
	    val->length != val->v_package[0]->v_integer ||
	    val->v_package[1]->v_integer != 0) {
#if 1 || defined(ACPI_DEBUG) && !defined(SMALL_KERNEL)
		aml_showvalue(val);
#endif
		printf("bogus CSD\n");
		return;
	}

	/* coordinating 'among' one CPU is trivial, ignore */
	num_proc = val->v_package[4]->v_integer;
	if (num_proc == 1)
		return;

	/* we practically assume the hardware will coordinate, so ignore */
	coord_type = val->v_package[3]->v_integer;
	if (coord_type == CSD_COORD_HW_ALL)
		return;

	domain = val->v_package[2]->v_integer;
	cindex = val->v_package[5]->v_integer;
	printf("\nCSD c=%#llx d=%lld n=%lld i=%lli\n",
	    coord_type, domain, num_proc, cindex);
}

int
acpicpu_getcst(struct acpicpu_softc *sc)
{
	struct aml_value	res;
	struct acpi_cstate	*cx, *next_cx;
	int			use_nonmwait;

	/* delete the existing list */
	while ((cx = SLIST_FIRST(&sc->sc_cstates)) != NULL) {
		SLIST_REMOVE_HEAD(&sc->sc_cstates, link);
		free(cx, M_DEVBUF, sizeof(*cx));
	}

	/* provide a fallback C1-via-halt in case _CST's C1 is bogus */
	acpicpu_add_cstate(sc, ACPI_STATE_C1, CST_METH_HALT,
	    CST_FLAG_FALLBACK, 1, -1, 0);

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CST", 0, NULL, &res))
		return (1);

	aml_foreachpkg(&res, 1, acpicpu_add_cstatepkg, sc);
	aml_freevalue(&res);

	/* only have fallback state?  then no _CST objects were understood */
	cx = SLIST_FIRST(&sc->sc_cstates);
	if (cx->flags & CST_FLAG_FALLBACK)
		return (1);

	/*
	 * Skip states >= C2 if the CPU's LAPIC timer stops in deep
	 * states (i.e., it doesn't have the 'ARAT' bit set).
	 * Also keep track if all the states we'll use use mwait.
	 */
	use_nonmwait = 0;
	while ((next_cx = SLIST_NEXT(cx, link)) != NULL) {
		if (cx->state > 1 &&
		    (sc->sc_ci->ci_feature_tpmflags & TPM_ARAT) == 0)
			cx->flags |= CST_FLAG_SKIP;
		else if (cx->method != CST_METH_MWAIT)
			use_nonmwait = 1;
		cx = next_cx;
	}
	if (use_nonmwait)
		sc->sc_flags &= ~FLAGS_MWAIT_ONLY;
	else
		sc->sc_flags |= FLAGS_MWAIT_ONLY;

	if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CSD", 0, NULL, &res)) {
		aml_foreachpkg(&res, 1, acpicpu_add_cdeppkg, sc);
		aml_freevalue(&res);
	}

	return (0);
}

/*
 * old-style fixed C-state info in the FADT.
 * Note that this has extra restrictions on values and flags.
 */
void
acpicpu_getcst_from_fadt(struct acpicpu_softc *sc)
{
	struct acpi_fadt	*fadt = sc->sc_acpi->sc_fadt;
	int flags;

	/* FADT has to set flag to do C2 and higher on MP */
	if ((fadt->flags & FADT_P_LVL2_UP) == 0 && ncpus > 1)
		return;

	/* skip these C2 and C3 states if the CPU doesn't have ARAT */
	flags = (sc->sc_ci->ci_feature_tpmflags & TPM_ARAT)
	    ? 0 : CST_FLAG_SKIP;

	/* Some systems don't export a full PBLK; reduce functionality */
	if (sc->sc_pblk_len >= 5 && fadt->p_lvl2_lat <= ACPI_MAX_C2_LATENCY) {
		acpicpu_add_cstate(sc, ACPI_STATE_C2, CST_METH_GAS_IO, flags,
		    fadt->p_lvl2_lat, -1, sc->sc_pblk_addr + 4);
	}
	if (sc->sc_pblk_len >= 6 && fadt->p_lvl3_lat <= ACPI_MAX_C3_LATENCY)
		acpicpu_add_cstate(sc, ACPI_STATE_C3, CST_METH_GAS_IO, flags,
		    fadt->p_lvl3_lat, -1, sc->sc_pblk_addr + 5);
}


void
acpicpu_print_one_cst(struct acpi_cstate *cx)
{
	const char *meth = "";
	int show_addr = 0;

	switch (cx->method) {
	case CST_METH_IO_HALT:
		show_addr = 1;
		/* fallthrough */
	case CST_METH_HALT:
		meth = " halt";
		break;

	case CST_METH_MWAIT:
		meth = " mwait";
		show_addr = cx->address != 0;
		break;

	case CST_METH_GAS_IO:
		meth = " io";
		show_addr = 1;
		break;

	}

	printf(" %sC%d(", (cx->flags & CST_FLAG_SKIP ? "!" : ""), cx->state);
	if (cx->power != -1)
		printf("%d", cx->power);
	printf("@@%d%s", cx->latency, meth);
	if (cx->flags & ~CST_FLAG_SKIP) {
		if (cx->flags & CST_FLAG_FALLBACK)
			printf("!");
		else
			printf(".%x", (cx->flags & ~CST_FLAG_SKIP));
	}
	if (show_addr)
		printf("@@0x%llx", cx->address);
	printf(")");
}

void
acpicpu_print_cst(struct acpicpu_softc *sc)
{
	struct acpi_cstate	*cx;
	int i;

	if (!SLIST_EMPTY(&sc->sc_cstates)) {
		printf(":");

		i = 0;
		SLIST_FOREACH(cx, &sc->sc_cstates, link) {
			if (i++)
				printf(",");
			acpicpu_print_one_cst(cx);
		}
	}
}


int
acpicpu_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;

	/* sanity */
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	return (1);
}

void
acpicpu_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpicpu_softc	*sc = (struct acpicpu_softc *)self;
	struct acpi_attach_args *aa = aux;
	struct aml_value	res;
	int			i;
	u_int32_t		status = 0;
	CPU_INFO_ITERATOR	cii;
	struct cpu_info		*ci;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;
	acpicpu_sc[sc->sc_dev.dv_unit] = sc;

	SLIST_INIT(&sc->sc_cstates);

	sc->sc_pss = NULL;

	if (aml_evalnode(sc->sc_acpi, sc->sc_devnode, 0, NULL, &res) == 0) {
		if (res.type == AML_OBJTYPE_PROCESSOR) {
			sc->sc_cpu = res.v_processor.proc_id;
			sc->sc_pblk_addr = res.v_processor.proc_addr;
			sc->sc_pblk_len = res.v_processor.proc_len;
		}
		aml_freevalue(&res);
	}
	sc->sc_duty_off = sc->sc_acpi->sc_fadt->duty_offset;
	sc->sc_duty_wid = sc->sc_acpi->sc_fadt->duty_width;

	/* link in the matching cpu_info */
	CPU_INFO_FOREACH(cii, ci)
		if (ci->ci_acpi_proc_id == sc->sc_cpu) {
			ci->ci_acpicpudev = self;
			sc->sc_ci = ci;
			break;
		}
	if (ci == NULL) {
		printf(": no cpu matching ACPI ID %d\n", sc->sc_cpu);
		return;
	}

	sc->sc_prev_sleep = 1000000;

	acpicpu_set_pdc(sc);

	if (!valid_throttle(sc->sc_duty_off, sc->sc_duty_wid, sc->sc_pblk_addr))
		sc->sc_flags |= FLAGS_NOTHROTTLE;
#ifdef ACPI_DEBUG
	printf(": %s: ", sc->sc_devnode->name);
	printf("\n: hdr:%x pblk:%x,%x duty:%x,%x pstate:%x "
	       "(%ld throttling states)\n", sc->sc_acpi->sc_fadt->hdr_revision,
		sc->sc_pblk_addr, sc->sc_pblk_len, sc->sc_duty_off,
		sc->sc_duty_wid, sc->sc_acpi->sc_fadt->pstate_cnt,
		CPU_MAXSTATE(sc));
#endif

	/* Get C-States from _CST or FADT */
	if (acpicpu_getcst(sc) || SLIST_EMPTY(&sc->sc_cstates))
		acpicpu_getcst_from_fadt(sc);
	else {
		/* Notify BIOS we use _CST objects */
		if (sc->sc_acpi->sc_fadt->cst_cnt) {
			acpi_write_pmreg(sc->sc_acpi, ACPIREG_SMICMD, 0,
			    sc->sc_acpi->sc_fadt->cst_cnt);
		}
	}
	if (!SLIST_EMPTY(&sc->sc_cstates)) {
		extern u_int32_t acpi_force_bm;

		cpu_idle_cycle_fcn = &acpicpu_idle;

		/*
		 * C3 (and maybe C2?) needs BM_RLD to be set to
		 * wake the system
		 */
		if (SLIST_FIRST(&sc->sc_cstates)->state > 1 && acpi_force_bm == 0) {
			uint16_t en = acpi_read_pmreg(sc->sc_acpi,
			    ACPIREG_PM1_CNT, 0);
			if ((en & ACPI_PM1_BM_RLD) == 0) {
				acpi_write_pmreg(sc->sc_acpi, ACPIREG_PM1_CNT,
				    0, en | ACPI_PM1_BM_RLD);
				acpi_force_bm = ACPI_PM1_BM_RLD;
			}
		}
	}

	if (acpicpu_getpss(sc)) {
		sc->sc_flags |= FLAGS_NOPSS;
	} else {
#ifdef ACPI_DEBUG
		for (i = 0; i < sc->sc_pss_len; i++) {
			dnprintf(20, "%d %d %d %d %d %d\n",
			    sc->sc_pss[i].pss_core_freq,
			    sc->sc_pss[i].pss_power,
			    sc->sc_pss[i].pss_trans_latency,
			    sc->sc_pss[i].pss_bus_latency,
			    sc->sc_pss[i].pss_ctrl,
			    sc->sc_pss[i].pss_status);
		}
		dnprintf(20, "\n");
#endif
		if (sc->sc_pss_len == 0) {
			/* this should never happen */
			printf("%s: invalid _PSS length\n", DEVNAME(sc));
			sc->sc_flags |= FLAGS_NOPSS;
		}

		acpicpu_getppc(sc);
		if (acpicpu_getpct(sc))
			sc->sc_flags |= FLAGS_NOPCT;
		else if (sc->sc_pss_len > 0) {
			/* Notify BIOS we are handling p-states */
			if (sc->sc_acpi->sc_fadt->pstate_cnt) {
				acpi_write_pmreg(sc->sc_acpi, ACPIREG_SMICMD,
				    0, sc->sc_acpi->sc_fadt->pstate_cnt);
			}

			aml_register_notify(sc->sc_devnode, NULL,
			    acpicpu_notify, sc, ACPIDEV_NOPOLL);

			acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
			    sc->sc_pct.pct_status.grd_gas.address_space_id,
			    sc->sc_pct.pct_status.grd_gas.address,
			    sc->sc_pct_stat_as, sc->sc_pct_stat_as, &status);
			sc->sc_level = (100 / sc->sc_pss_len) *
			    (sc->sc_pss_len - status);
			dnprintf(20, "%s: cpu index %d, percentage %d\n",
			    DEVNAME(sc), status, sc->sc_level);
			if (setperf_prio < 30) {
				cpu_setperf = acpicpu_setperf;
				acpicpu_set_notify(acpicpu_setperf_ppc_change);
				setperf_prio = 30;
				acpi_hasprocfvs = 1;
			}
		}
	}

	/*
	 * Nicely enumerate what power management capabilities
	 * ACPI CPU provides.
	 */
	acpicpu_print_cst(sc);
	if (!(sc->sc_flags & (FLAGS_NOPSS | FLAGS_NOPCT)) ||
	    !(sc->sc_flags & FLAGS_NOPSS)) {
		printf("%c ", SLIST_EMPTY(&sc->sc_cstates) ? ':' : ',');

		/*
		 * If acpicpu is itself providing the capability to transition
		 * states, enumerate them in the fashion that est and powernow
		 * would.
		 */
		if (!(sc->sc_flags & (FLAGS_NOPSS | FLAGS_NOPCT))) {
			printf("FVS, ");
			for (i = 0; i < sc->sc_pss_len - 1; i++)
				printf("%d, ", sc->sc_pss[i].pss_core_freq);
			printf("%d MHz", sc->sc_pss[i].pss_core_freq);
		} else
			printf("PSS");
	}

	printf("\n");
}

int
acpicpu_getppc(struct acpicpu_softc *sc)
{
	struct aml_value	res;

	sc->sc_ppc = 0;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PPC", 0, NULL, &res)) {
		dnprintf(10, "%s: no _PPC\n", DEVNAME(sc));
		return (1);
	}

	sc->sc_ppc = aml_val2int(&res);
	dnprintf(10, "%s: _PPC: %d\n", DEVNAME(sc), sc->sc_ppc);
	aml_freevalue(&res);

	return (0);
}

int
acpicpu_getpct(struct acpicpu_softc *sc)
{
	struct aml_value	res;
	int			rv = 1;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PCT", 0, NULL, &res)) {
		dnprintf(20, "%s: no _PCT\n", DEVNAME(sc));
		return (1);
	}

	if (res.length != 2) {
		dnprintf(20, "%s: %s: invalid _PCT length\n", DEVNAME(sc),
		    sc->sc_devnode->name);
		return (1);
	}

	memcpy(&sc->sc_pct.pct_ctrl, res.v_package[0]->v_buffer,
	    sizeof sc->sc_pct.pct_ctrl);
	if (sc->sc_pct.pct_ctrl.grd_gas.address_space_id ==
	    GAS_FUNCTIONAL_FIXED) {
		dnprintf(20, "CTRL GASIO is functional fixed hardware.\n");
		goto ffh;
	}

	memcpy(&sc->sc_pct.pct_status, res.v_package[1]->v_buffer,
	    sizeof sc->sc_pct.pct_status);
	if (sc->sc_pct.pct_status.grd_gas.address_space_id ==
	    GAS_FUNCTIONAL_FIXED) {
		dnprintf(20, "CTRL GASIO is functional fixed hardware.\n");
		goto ffh;
	}

	dnprintf(10, "_PCT(ctrl)  : %02x %04x %02x %02x %02x %02x %016llx\n",
	    sc->sc_pct.pct_ctrl.grd_descriptor,
	    sc->sc_pct.pct_ctrl.grd_length,
	    sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	    sc->sc_pct.pct_ctrl.grd_gas.register_bit_width,
	    sc->sc_pct.pct_ctrl.grd_gas.register_bit_offset,
	    sc->sc_pct.pct_ctrl.grd_gas.access_size,
	    sc->sc_pct.pct_ctrl.grd_gas.address);

	dnprintf(10, "_PCT(status): %02x %04x %02x %02x %02x %02x %016llx\n",
	    sc->sc_pct.pct_status.grd_descriptor,
	    sc->sc_pct.pct_status.grd_length,
	    sc->sc_pct.pct_status.grd_gas.address_space_id,
	    sc->sc_pct.pct_status.grd_gas.register_bit_width,
	    sc->sc_pct.pct_status.grd_gas.register_bit_offset,
	    sc->sc_pct.pct_status.grd_gas.access_size,
	    sc->sc_pct.pct_status.grd_gas.address);

	/* if not set assume single 32 bit access */
	sc->sc_pct_stat_as = sc->sc_pct.pct_status.grd_gas.register_bit_width
	    / 8;
	if (sc->sc_pct_stat_as == 0)
		sc->sc_pct_stat_as = 4;
	sc->sc_pct_ctrl_as = sc->sc_pct.pct_ctrl.grd_gas.register_bit_width / 8;
	if (sc->sc_pct_ctrl_as == 0)
		sc->sc_pct_ctrl_as = 4;
	sc->sc_pct_stat_len = sc->sc_pct.pct_status.grd_gas.access_size;
	if (sc->sc_pct_stat_len == 0)
		sc->sc_pct_stat_len = sc->sc_pct_stat_as;
	sc->sc_pct_ctrl_len = sc->sc_pct.pct_ctrl.grd_gas.access_size;
	if (sc->sc_pct_ctrl_len == 0)
		sc->sc_pct_ctrl_len = sc->sc_pct_ctrl_as;

	rv = 0;
ffh:
	aml_freevalue(&res);
	return (rv);
}

int
acpicpu_getpss(struct acpicpu_softc *sc)
{
	struct aml_value	res;
	int			i, c, cf;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSS", 0, NULL, &res)) {
		dprintf("%s: no _PSS\n", DEVNAME(sc));
		return (1);
	}

	free(sc->sc_pss, M_DEVBUF, 0);

	sc->sc_pss = mallocarray(res.length, sizeof(*sc->sc_pss), M_DEVBUF,
	    M_WAITOK | M_ZERO);

	c = 0;
	for (i = 0; i < res.length; i++) {
		cf = aml_val2int(res.v_package[i]->v_package[0]);

		/* This heuristic comes from FreeBSDs
		 * dev/acpica/acpi_perf.c to weed out invalid PSS entries.
		 */
		if (cf == sc->sc_pss[c].pss_core_freq) {
			printf("%s: struck PSS entry, core frequency equals "
			    " last\n", sc->sc_dev.dv_xname);
			continue;
		}

		if (cf == 0xFFFF || cf == 0x9999 || cf == 99999 || cf == 0) {
			printf("%s: struck PSS entry, inappropriate core "
			    "frequency value\n", sc->sc_dev.dv_xname);
			continue;
		}

		sc->sc_pss[c].pss_core_freq = cf;
		sc->sc_pss[c].pss_power = aml_val2int(
		    res.v_package[i]->v_package[1]);
		sc->sc_pss[c].pss_trans_latency = aml_val2int(
		    res.v_package[i]->v_package[2]);
		sc->sc_pss[c].pss_bus_latency = aml_val2int(
		    res.v_package[i]->v_package[3]);
		sc->sc_pss[c].pss_ctrl = aml_val2int(
		    res.v_package[i]->v_package[4]);
		sc->sc_pss[c].pss_status = aml_val2int(
		    res.v_package[i]->v_package[5]);
		c++;
	}
	sc->sc_pss_len = c;

	aml_freevalue(&res);

	return (0);
}

int
acpicpu_fetch_pss(struct acpicpu_pss **pss)
{
	struct acpicpu_softc	*sc;

	/*
	 * XXX: According to the ACPI spec in an SMP system all processors
	 * are supposed to support the same states. For now we pray
	 * the bios ensures this...
	 */

	sc = acpicpu_sc[0];
	if (!sc)
		return 0;
	*pss = sc->sc_pss;

	return (sc->sc_pss_len);
}

int
acpicpu_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct acpicpu_softc	*sc = arg;

	dnprintf(10, "acpicpu_notify: %.2x %s\n", notify_type,
	    sc->sc_devnode->name);

	switch (notify_type) {
	case 0x80:	/* _PPC changed, retrieve new values */
		acpicpu_getppc(sc);
		acpicpu_getpss(sc);
		if (sc->sc_notify)
			sc->sc_notify(sc->sc_pss, sc->sc_pss_len);
		break;

	case 0x81:	/* _CST changed, retrieve new values */
		acpicpu_getcst(sc);
		printf("%s: notify", DEVNAME(sc));
		acpicpu_print_cst(sc);
		printf("\n");
		break;

	default:
		printf("%s: unhandled cpu event %x\n", DEVNAME(sc),
		    notify_type);
		break;
	}

	return (0);
}

void
acpicpu_set_notify(void (*func)(struct acpicpu_pss *, int))
{
	struct acpicpu_softc    *sc;

	sc = acpicpu_sc[0];
	if (sc != NULL)
		sc->sc_notify = func;
}

void
acpicpu_setperf_ppc_change(struct acpicpu_pss *pss, int npss)
{
	struct acpicpu_softc    *sc;

	sc = acpicpu_sc[0];

	if (sc != NULL)
		cpu_setperf(sc->sc_level);
}

void
acpicpu_setperf(int level)
{
	struct acpicpu_softc	*sc;
	struct acpicpu_pss	*pss = NULL;
	int			idx, len;
	u_int32_t		status = 0;

	sc = acpicpu_sc[cpu_number()];

	dnprintf(10, "%s: acpicpu setperf level %d\n",
	    sc->sc_devnode->name, level);

	if (level < 0 || level > 100) {
		dnprintf(10, "%s: acpicpu setperf illegal percentage\n",
		    sc->sc_devnode->name);
		return;
	}

	/*
	 * XXX this should be handled more gracefully and it needs to also do
	 * the duty cycle method instead of pss exclusively
	 */
	if (sc->sc_flags & FLAGS_NOPSS || sc->sc_flags & FLAGS_NOPCT) {
		dnprintf(10, "%s: acpicpu no _PSS or _PCT\n",
		    sc->sc_devnode->name);
		return;
	}

	if (sc->sc_ppc)
		len = sc->sc_ppc;
	else
		len = sc->sc_pss_len;
	idx = (len - 1) - (level / (100 / len));
	if (idx < 0)
		idx = 0;

	if (sc->sc_ppc)
		idx += sc->sc_pss_len - sc->sc_ppc;

	if (idx > sc->sc_pss_len)
		idx = sc->sc_pss_len - 1;

	dnprintf(10, "%s: acpicpu setperf index %d pss_len %d ppc %d\n",
	    sc->sc_devnode->name, idx, sc->sc_pss_len, sc->sc_ppc);

	pss = &sc->sc_pss[idx];

#ifdef ACPI_DEBUG
	/* keep this for now since we will need this for debug in the field */
	printf("0 status: %x %llx %u %u ctrl: %x %llx %u %u\n",
	    sc->sc_pct.pct_status.grd_gas.address_space_id,
	    sc->sc_pct.pct_status.grd_gas.address,
	    sc->sc_pct_stat_as, sc->sc_pct_stat_len,
	    sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	    sc->sc_pct.pct_ctrl.grd_gas.address,
	    sc->sc_pct_ctrl_as, sc->sc_pct_ctrl_len);
#endif
	acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
	    sc->sc_pct.pct_status.grd_gas.address_space_id,
	    sc->sc_pct.pct_status.grd_gas.address, sc->sc_pct_stat_as,
	    sc->sc_pct_stat_len, &status);
	dnprintf(20, "1 status: %u <- %u\n", status, pss->pss_status);

	/* Are we already at the requested frequency? */
	if (status == pss->pss_status)
		return;

	acpi_gasio(sc->sc_acpi, ACPI_IOWRITE,
	    sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	    sc->sc_pct.pct_ctrl.grd_gas.address, sc->sc_pct_ctrl_as,
	    sc->sc_pct_ctrl_len, &pss->pss_ctrl);
	dnprintf(20, "pss_ctrl: %x\n", pss->pss_ctrl);

	acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
	    sc->sc_pct.pct_status.grd_gas.address_space_id,
	    sc->sc_pct.pct_status.grd_gas.address, sc->sc_pct_stat_as,
	    sc->sc_pct_stat_as, &status);
	dnprintf(20, "2 status: %d\n", status);

	/* Did the transition succeed? */
	 if (status == pss->pss_status) {
		cpuspeed = pss->pss_core_freq;
		sc->sc_level = level;
	} else
		printf("%s: acpicpu setperf failed to alter frequency\n",
		    sc->sc_devnode->name);
}

void
acpicpu_idle(void)
{
	struct cpu_info *ci = curcpu();
	struct acpicpu_softc *sc = (struct acpicpu_softc *)ci->ci_acpicpudev;
	struct acpi_cstate *best, *cx;
	unsigned long itime;

	if (sc == NULL) {
		__asm volatile("sti");
		panic("null acpicpu");
	}

	/* possibly update the MWAIT_ONLY flag in cpu_info */
	if (sc->sc_flags & FLAGS_MWAIT_ONLY) {
		if ((ci->ci_mwait & MWAIT_ONLY) == 0)
			atomic_setbits_int(&ci->ci_mwait, MWAIT_ONLY);
	} else if (ci->ci_mwait & MWAIT_ONLY)
		atomic_clearbits_int(&ci->ci_mwait, MWAIT_ONLY);

	/*
	 * Find the first state with a latency we'll accept, ignoring
	 * states marked skippable
	 */
	best = cx = SLIST_FIRST(&sc->sc_cstates);
	while ((cx->flags & CST_FLAG_SKIP) ||
	    cx->latency * 3 > sc->sc_prev_sleep) {
		if ((cx = SLIST_NEXT(cx, link)) == NULL)
			break;
		best = cx;
	}

	if (best->state >= 3 &&
	    (best->flags & CST_FLAG_MWAIT_BM_AVOIDANCE) &&
	    acpi_read_pmreg(acpi_softc, ACPIREG_PM1_STS, 0) & ACPI_PM1_BM_STS) {
		/* clear it and back off */
		acpi_write_pmreg(acpi_softc, ACPIREG_PM1_STS, 0,
		    ACPI_PM1_BM_STS);
		while ((cx = SLIST_NEXT(cx, link)) != NULL) {
			if (cx->flags & CST_FLAG_SKIP)
				continue;
			if (cx->state < 3 ||
			    (cx->flags & CST_FLAG_MWAIT_BM_AVOIDANCE) == 0)
				break;
		}
		best = cx;
	}


	atomic_inc_long(&cst_stats[best->state]);

	itime = tick / 2;
	switch (best->method) {
	default:
	case CST_METH_HALT:
		__asm volatile("sti; hlt");
		break;

	case CST_METH_IO_HALT:
		inb((u_short)best->address);
		__asm volatile("sti; hlt");
		break;

	case CST_METH_MWAIT:
		{
		struct timeval start, stop;
		unsigned int hints;

#ifdef __LP64__
		if ((read_rflags() & PSL_I) == 0)
			panic("idle with interrupts blocked!");
#else
		if ((read_eflags() & PSL_I) == 0)
			panic("idle with interrupts blocked!");
#endif

		/* something already queued? */
		if (!cpu_is_idle(ci))
			return;

		/*
		 * About to idle; setting the MWAIT_IN_IDLE bit tells
		 * cpu_unidle() that it can't be a no-op and tells cpu_kick()
		 * that it doesn't need to use an IPI.  We also set the
		 * MWAIT_KEEP_IDLING bit: those routines clear it to stop
		 * the mwait.  Once they're set, we do a final check of the
		 * queue, in case another cpu called setrunqueue() and added
		 * something to the queue and called cpu_unidle() between
		 * the check in sched_idle() and here.
		 */
		hints = (unsigned)best->address;
		microuptime(&start);
		atomic_setbits_int(&ci->ci_mwait, MWAIT_IDLING);
		if (cpu_is_idle(ci)) {
			/* intel errata AAI65: cflush before monitor */
			if (ci->ci_cflushsz != 0) {
				membar_sync();
				clflush((unsigned long)&ci->ci_mwait);
				membar_sync();
			}

			monitor(&ci->ci_mwait, 0, 0);
			if ((ci->ci_mwait & MWAIT_IDLING) == MWAIT_IDLING)
				mwait(0, hints);
		}

		microuptime(&stop);
		timersub(&stop, &start, &stop);
		itime = stop.tv_sec * 1000000 + stop.tv_usec;

		/* done idling; let cpu_kick() know that an IPI is required */
		atomic_clearbits_int(&ci->ci_mwait, MWAIT_IDLING);
		break;
		}

	case CST_METH_GAS_IO:
		inb((u_short)best->address);
		/* something harmless to give system time to change state */
		acpi_read_pmreg(acpi_softc, ACPIREG_PM1_STS, 0);
		break;

	}

	sc->sc_last_itime = itime;
	itime >>= 1;
	sc->sc_prev_sleep = (sc->sc_prev_sleep + (sc->sc_prev_sleep >> 1)
	    + itime) >> 1;
}
@


1.77
log
@Suppress debugging output about CSD entries that say nothing we care about
and improve the output for those we might.

output examples from mikeb@@
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.76 2016/09/02 13:59:51 pirofti Exp $ */
d702 5
a706 2
	if (ci == NULL)
		printf("unable to find cpu %d\n", sc->sc_dev.dv_unit);
@


1.76
log
@Remove unused argument in aml_showvalue().


The second argument of aml_showvalue() was probably supposed to set
the verbosity level through dnprintf() but in fact it does nothing.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.75 2016/07/28 21:57:56 kettenis Exp $ */
d97 4
d474 9
d484 1
a484 1
	aml_showvalue(val);
a485 2
	if (val->type != AML_OBJTYPE_PACKAGE || val->length < 6 ||
	    val->length != val->v_package[0]->v_integer) {
d490 14
a503 6
	printf("\nCSD r=%lld d=%lld c=%llx n=%lld i=%lli\n",
	    val->v_package[1]->v_integer,
	    val->v_package[2]->v_integer,
	    val->v_package[3]->v_integer,
	    val->v_package[4]->v_integer,
	    val->v_package[5]->v_integer);
@


1.75
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.74 2016/03/17 13:18:47 mpi Exp $ */
d371 1
a371 1
	aml_showvalue(val, 0);
d471 1
a471 1
	aml_showvalue(val, 0);
@


1.74
log
@Replace curcpu_is_idle() by cpu_is_idle() and use it instead of rolling
our own.

From Michal Mazurek, ok mmcc@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.73 2016/03/14 06:37:31 guenther Exp $ */
d678 1
a678 1
		if (ci->ci_cpuid == sc->sc_dev.dv_unit) {
@


1.73
log
@Correct the value of SRT_ENDTAG: it was documented incorrectly in early
ACPI specs.  With the correct value, it can now be used in a few places
instead of hardcoding 0x79.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.72 2015/12/29 04:46:28 mmcc Exp $ */
d1191 1
a1191 1
		if (ci->ci_schedstate.spc_whichqs != 0)
d1207 1
a1207 1
		if (ci->ci_schedstate.spc_whichqs == 0) {
@


1.72
log
@Remove NULL-checks before free().

ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.71 2015/12/23 17:07:09 jcs Exp $ */
d389 1
a389 1
	    val->v_package[0]->v_buffer[sizeof(*grd)] != SR_TAG(SR_ENDTAG,1)) {
@


1.71
log
@add aml_freevalue in a couple places, avoid storing a result that
would need to be freed in a couple other places

with deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.70 2015/09/12 07:52:27 guenther Exp $ */
d909 1
a909 2
	if (sc->sc_pss)
		free(sc->sc_pss, M_DEVBUF, 0);
@


1.70
log
@Intel docs suggest that cpus in C3 may go into deeper states automatically
when all cores are in C3, so treat the latency+power values from ACPI as
advisory and stop skipping states based on them.

ok mlarkin@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.69 2015/09/11 22:44:30 guenther Exp $ */
d263 1
d287 2
d290 1
a290 1
		    4, osc_cmd, &res);
d303 1
a303 1
		    1, &cmd, &res);
@


1.69
log
@Workaround broken AML by treating FFH vendor 8 the same as vendor 1 (== intel)

ok millert@@ kettenis@@ and something like an ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.68 2015/08/04 22:25:54 guenther Exp $ */
d513 1
a513 3
	 * Scan the list for states that are neither lower power nor
	 * lower latency than the next state; mark them to be skipped.
	 * Also skip states >=C2 if the CPU's LAPIC timer stops in deep
d519 2
a520 5
		if ((next_cx->power != -1 &&
		    cx->power >= next_cx->power &&
		    cx->latency >= next_cx->latency) ||
		    (cx->state > 1 &&
		    (sc->sc_ci->ci_feature_tpmflags & TPM_ARAT) == 0))
@


1.68
log
@Skip C2 and C3 states from the FADT if the cpu doesn't have ARAT.

problem reported by patrick keshishian (pkeshish (at) gmail.com)
based on diff from mlarkin@@, ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.67 2015/08/04 15:21:59 deraadt Exp $ */
d397 6
a402 2
		} else if (grd->grd_gas.register_bit_width == 1) {
			/* vendor == Intel */
@


1.67
log
@If we are setting ACPI_PM1_BM_RLD do it only once, and remember to
repeat this action at resume time.
ok mlarkin guenther
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.66 2015/08/04 05:15:02 guenther Exp $ */
d548 1
d554 4
d560 1
a560 1
		acpicpu_add_cstate(sc, ACPI_STATE_C2, CST_METH_GAS_IO, 0,
d564 1
a564 1
		acpicpu_add_cstate(sc, ACPI_STATE_C3, CST_METH_GAS_IO, 0,
@


1.66
log
@Provide the fallback C1-via-halt even when _CST can't be evaluated.
Fixed systems that only provide _CST for a subset of the CPUs.

Problem reported by <david.a.baer (at) gmail.com>
ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.65 2015/07/18 15:20:13 guenther Exp $ */
d704 2
a710 1
		 * XXX need to save and restore this in suspend/resume?
d712 1
a712 1
		if (SLIST_FIRST(&sc->sc_cstates)->state > 1) {
d718 1
@


1.65
log
@If _CST provides a C2 or C3 but lacks a C1 that we understand, provide a
fallback C1 state using 'halt'

tested in snaps for a bit
problem laptops noted by and oks okan@@ and kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.64 2015/06/13 21:41:42 guenther Exp $ */
a492 3
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CST", 0, NULL, &res))
		return (1);

d496 3
@


1.64
log
@Parse _CST objects and use the C-states they describe when they're sane.

testing by many, particularly krw@@ and jcs@@
tweaks by kettenis@@
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.63 2015/03/14 03:38:46 jsg Exp $ */
d80 1
a80 1
#define CST_FLAG_UP_ONLY		0x4000	/* ignore if MP */
d342 7
a348 1
	cx = malloc(sizeof(*cx), M_DEVBUF, M_WAITOK);
a355 2

	SLIST_INSERT_HEAD(&sc->sc_cstates, cx, link);
d496 4
d503 5
d511 1
a511 1
	 * Also skip states >=C2 if the CPU's LAPIC timer stop in deep
d516 10
a525 13
	if ((cx = SLIST_FIRST(&sc->sc_cstates)) == NULL)
		use_nonmwait = 1;
	else {
		while ((next_cx = SLIST_NEXT(cx, link)) != NULL) {
			if ((cx->power >= next_cx->power &&
			    cx->latency >= next_cx->latency) ||
			    (cx->state > 1 &&
			    (sc->sc_ci->ci_feature_tpmflags & TPM_ARAT) == 0))
				cx->flags |= CST_FLAG_SKIP;
			else if (cx->method != CST_METH_MWAIT)
				use_nonmwait = 1;
			cx = next_cx;
		}
d594 6
a599 2
	if (cx->flags & ~CST_FLAG_SKIP)
		printf(".%x", (cx->flags & ~CST_FLAG_SKIP));
a1130 6
	if (cx == NULL) {
halt:
		__asm volatile("sti; hlt");
		return;
	}

a1150 2
		if (cx == NULL)
			goto halt;
@


1.63
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.62 2014/12/09 06:58:29 doug Exp $ */
d4 1
d20 1
d27 1
d31 1
d57 1
a57 1
/* _PDC Intel capabilities flags from linux */
d68 14
d83 1
a83 2
#define FLAGS_NO_C2		0x01
#define FLAGS_NO_C3		0x02
d102 1
a102 4
	int	 type;
	int	 latency;
	int	 power;
	int	 address;
d104 6
a109 1
	SLIST_ENTRY(acpi_cstate) link;
d112 2
d120 1
a120 1
	int			sc_pblk_addr;
d123 2
d126 1
d157 2
a158 1
void    acpicpu_add_cstatepkg(struct aml_value *, void *);
d162 6
a167 2
struct acpi_cstate *acpicpu_add_cstate(struct acpicpu_softc *, int, int, int,
    int);
d169 1
d209 1
a209 1
acpicpu_find_cstate(struct acpicpu_softc *sc, int type)
d214 1
a214 1
		if (cx->type == type)
d304 9
d314 22
a335 3
struct acpi_cstate *
acpicpu_add_cstate(struct acpicpu_softc *sc, int type, int latency, int power,
    int address)
d339 2
a340 15
	dnprintf(10," C%d: latency:.%4x power:%.4x addr:%.8x\n",
	    type, latency, power, address);

	switch (type) {
	case ACPI_STATE_C2:
		if (latency > ACPI_MAX_C2_LATENCY || !address ||
		    (sc->sc_flags & FLAGS_NO_C2))
			goto bad;
		break;
	case ACPI_STATE_C3:
		if (latency > ACPI_MAX_C3_LATENCY || !address ||
		    (sc->sc_flags & FLAGS_NO_C3))
			goto bad;
		break;
	}
d342 1
a342 1
	cx = malloc(sizeof(*cx), M_DEVBUF, M_WAITOK | M_ZERO);
d344 4
a347 1
	cx->type = type;
a348 1
	cx->latency = latency;
a351 5

	return (cx);
 bad:
	dprintf("acpicpu%d: C%d not supported", sc->sc_cpu, type);
	return (NULL);
d359 3
d369 101
a469 1
	acpicpu_add_cstate(sc, val->v_package[1]->v_integer,
d471 136
a606 1
	    val->v_package[3]->v_integer, -1);
a631 1
	struct acpi_cstate	*cx;
d633 2
d655 11
d680 8
a687 3
	if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CST", 0, NULL, &res)) {
		aml_foreachpkg(&res, 1, acpicpu_add_cstatepkg, sc);
		aml_freevalue(&res);
d689 16
a704 12
	else {
		/* Some systems don't export a full PBLK reduce functionality */
		if (sc->sc_pblk_len < 5)
			sc->sc_flags |= FLAGS_NO_C2;
		if (sc->sc_pblk_len < 6)
			sc->sc_flags |= FLAGS_NO_C3;
		acpicpu_add_cstate(sc, ACPI_STATE_C2,
		    sc->sc_acpi->sc_fadt->p_lvl2_lat, -1,
		    sc->sc_pblk_addr + 4);
		acpicpu_add_cstate(sc, ACPI_STATE_C3,
		    sc->sc_acpi->sc_fadt->p_lvl3_lat, -1,
		    sc->sc_pblk_addr + 5);
d706 1
d732 5
a736 4
			/* Notify BIOS we are handing p-states */
			if (sc->sc_acpi->sc_fadt->pstate_cnt)
				acpi_write_pmreg(sc->sc_acpi, ACPIREG_SMICMD, 0,
				sc->sc_acpi->sc_fadt->pstate_cnt);
d762 1
a762 24
	if (!SLIST_EMPTY(&sc->sc_cstates)) {
		printf(":");

		i = 0;
		SLIST_FOREACH(cx, &sc->sc_cstates, link) {
			if (i++)
				printf(",");
			switch (cx->type) {
			case ACPI_STATE_C0:
				printf(" C0");
				break;
			case ACPI_STATE_C1:
				printf(" C1");
				break;
			case ACPI_STATE_C2:
				printf(" C2");
				break;
			case ACPI_STATE_C3:
				printf(" C3");
				break;
			}
		}
	}

d964 1
d966 5
d972 1
d1090 137
@


1.62
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.61 2014/09/14 14:17:24 jsg Exp $ */
a27 1
#include <machine/cpufunc.h>
@


1.61
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.60 2014/07/12 18:48:17 tedu Exp $ */
d610 1
a610 1
	sc->sc_pss = malloc(res.length * sizeof *sc->sc_pss, M_DEVBUF,
@


1.60
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.59 2014/07/11 14:33:45 kettenis Exp $ */
a18 1
#include <sys/proc.h>
@


1.59
log
@Fix invocation of _OSC.  We were passing the capabilities in the wrong DWORD
and specifyig the wrong DWORD count.  Moreover we should not evaluate _PDC
if _OSC is present.  Might not be perfect yet, but what we had previously
was uterrly and totally wrong.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.58 2014/05/21 02:14:07 mlarkin Exp $ */
d609 1
a609 1
		free(sc->sc_pss, M_DEVBUF);
@


1.58
log
@Fix invalid / missing format specifiers in several dnprintf statements
(used only when ACPI_DEBUG is enabled)

From a diff on tech@@ by Fabian Raetz, with a minor change by me, tested
on i386 and amd64 with ACPI_DEBUG enabled and disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.57 2010/07/21 19:35:15 deraadt Exp $ */
d198 1
d205 1
a205 9
	/* Evaluate _PDC */
	memset(&cmd, 0, sizeof(cmd));
	cmd.type = AML_OBJTYPE_BUFFER;
	cmd.v_buffer = (uint8_t *)&buf;
	cmd.length = sizeof(buf);

	buf[0] = ACPI_PDC_REVID;
	buf[1] = 1;
	buf[2] = ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH | ACPI_PDC_C_C1_FFH
d209 61
a269 1
	aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PDC", 1, &cmd, &res);
d271 3
a273 20
	/* Evaluate _OSC */
	memset(&osc_cmd, 0, sizeof(cmd) * 4);
	osc_cmd[0].type = AML_OBJTYPE_BUFFER;
	osc_cmd[0].v_buffer = (uint8_t *)&cpu_oscuuid;
	osc_cmd[0].length = sizeof(cpu_oscuuid);

	osc_cmd[1].type = AML_OBJTYPE_INTEGER;
	osc_cmd[1].v_integer = 1;
	osc_cmd[1].length = 1;

	osc_cmd[2].type = AML_OBJTYPE_INTEGER;
	osc_cmd[2].v_integer = 1;
	osc_cmd[2].length = 1;

	buf[0] = 0;
	osc_cmd[3].type = AML_OBJTYPE_BUFFER;
	osc_cmd[3].v_buffer = (int8_t *)&buf;
	osc_cmd[3].length = sizeof(buf);

	aml_evalname(sc->sc_acpi, sc->sc_devnode, "_OSC", 4, osc_cmd, &res);
@


1.57
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.56 2009/08/29 11:01:15 miod Exp $ */
d347 1
a347 1
	       "(%d throttling states)\n", sc->sc_acpi->sc_fadt->hdr_revision,
d522 1
a522 1
	dnprintf(10, "_PCT(ctrl)  : %02x %04x %02x %02x %02x %02x %016x\n",
d531 1
a531 1
	dnprintf(10, "_PCT(status): %02x %04x %02x %02x %02x %02x %016x\n",
@


1.56
log
@typos in comments
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.55 2009/06/23 13:21:48 gwk Exp $ */
d582 1
a582 1
		/* This heuristic comes from FreeBSDs 
@


1.55
log
@Ignore the PCT if the PSS has zero entries, only became
a problem after we started striking entires for containing
junk and /* should never happen */ happened.

Fixes PR 6175 confirmed by submiter: nick templeton nick @@ nicktempleton.com

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.54 2009/06/10 03:42:20 gwk Exp $ */
d218 1
a218 1
	/* Evalualte _OSC */
@


1.54
log
@Re introduce the _PDC code backed out before 4.5, in addition to evaluating the
PDC (which tells the ACPI code what we as OSPM are capable of) we also evaluate
the OSC method on the acpicpu device. Original cause of problems that resulted
in this getting backed out appear to be fixed by the mp_setperf change, so
hopefully the third time is the charm. Tested by many.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.53 2009/02/24 13:20:02 deraadt Exp $ */
d395 1
a395 2
		else {

@


1.53
log
@back out est.c 1.8 and bring acpicpu.c all the way back to 1.47 because of
hanging machines.  backed out correctly this time, as pointed out by tedu.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.47 2008/10/11 20:31:50 miod Exp $ */
d44 1
d51 16
d141 2
d192 49
d339 3
d346 4
a349 5
	printf("\n: hdr:%x pblk:%x,%x duty:%x,%x pstate:%x (%d throttling states)\n",
		sc->sc_acpi->sc_fadt->hdr_revision,
		sc->sc_pblk_addr, sc->sc_pblk_len,
		sc->sc_duty_off, sc->sc_duty_wid,
		sc->sc_acpi->sc_fadt->pstate_cnt,
d415 1
d566 1
a566 1
	int			i;
d579 1
d581 19
a599 3
		sc->sc_pss[i].pss_core_freq = aml_val2int(
		    res.v_package[i]->v_package[0]);
		sc->sc_pss[i].pss_power = aml_val2int(
d601 1
a601 1
		sc->sc_pss[i].pss_trans_latency = aml_val2int(
d603 1
a603 1
		sc->sc_pss[i].pss_bus_latency = aml_val2int(
d605 1
a605 1
		sc->sc_pss[i].pss_ctrl = aml_val2int(
d607 1
a607 1
		sc->sc_pss[i].pss_status = aml_val2int(
d609 1
d611 1
a611 1
	sc->sc_pss_len = res.length;
a626 2
	 * XXX part deux: this needs to account for _PPC as well
	 * when AC is removed the nr of _PSS entries can go down
a651 3
		/* reset performance to current percentage */
		/* XXX will fail for amd64 for now */
		cpu_setperf(sc->sc_level);
d663 2
a664 1
acpicpu_set_notify(void (*func)(struct acpicpu_pss *, int)) {
d673 11
d707 2
a708 1
		dnprintf(10, "%s: acpicpu no _PSS or _PCT\n", sc->sc_devnode->name);
@


1.52
log
@Backout a backout because noone knows what the hell the backout is a
backout of.   COME ON.  Be exact in your commit messages.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.50 2008/12/22 07:19:09 gwk Exp $ */
a43 1
void	acpicpu_setperf_ppc_change(struct acpicpu_pss *, int);
a49 16
#define ACPI_PDC_REVID		0x1
#define ACPI_PDC_SMP		0xa
#define ACPI_PDC_MSR		0x1

/* _PDC Intel capabilities flags from linux */
#define ACPI_PDC_P_FFH		0x0001
#define ACPI_PDC_C_C1_HALT	0x0002
#define ACPI_PDC_T_FFH		0x0004
#define ACPI_PDC_SMP_C1PT	0x0008
#define ACPI_PDC_SMP_C2C3	0x0010
#define ACPI_PDC_SMP_P_SWCOORD	0x0020
#define ACPI_PDC_SMP_C_SWCOORD	0x0040
#define ACPI_PDC_SMP_T_SWCOORD	0x0080
#define ACPI_PDC_C_C1_FFH	0x0100
#define ACPI_PDC_C_C2C3_FFH	0x0200

a123 2
void	acpicpu_set_pdc(struct acpicpu_softc *);

a172 22

void
acpicpu_set_pdc(struct acpicpu_softc *sc) {
	struct aml_value cmd;
	struct aml_value res;
	uint32_t buf[3];

	memset(&cmd, 0, sizeof(cmd));
	cmd.type = AML_OBJTYPE_BUFFER;
	cmd.v_buffer = (uint8_t *)&buf;
	cmd.length = sizeof(buf);

	buf[0] = ACPI_PDC_REVID;
	buf[1] = 1;
	buf[2] = ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH | ACPI_PDC_C_C1_FFH
	    | ACPI_PDC_C_C2C3_FFH | ACPI_PDC_SMP_P_SWCOORD | ACPI_PDC_SMP_C2C3
	    | ACPI_PDC_SMP_C1PT;

	aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PDC", 1, &cmd, &res);
}


a270 7

#if defined(amd64)
	if (strcmp(cpu_vendor, "GenuineIntel") == 0)
		if (cpu_ecxfeature & CPUIDECX_EST)
			acpicpu_set_pdc(sc);
#endif

a300 1

a344 1
				acpicpu_set_notify(acpicpu_setperf_ppc_change);
d538 2
d565 3
a584 10
}

void
acpicpu_setperf_ppc_change(struct acpicpu_pss *pss, int npss) {
	struct acpicpu_softc    *sc;

	sc = acpicpu_sc[0];

	if (sc != NULL)
		cpu_setperf(sc->sc_level);
@


1.51
log
@Backout PDC & PPC changes because it hangs several laptops.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.47 2008/10/11 20:31:50 miod Exp $ */
d44 1
d51 16
d141 2
d192 22
d312 7
d349 1
d394 1
a587 2
	 * XXX part deux: this needs to account for _PPC as well
	 * when AC is removed the nr of _PSS entries can go down
a612 3
		/* reset performance to current percentage */
		/* XXX will fail for amd64 for now */
		cpu_setperf(sc->sc_level);
d630 10
@


1.50
log
@With respect to the previous diff we cannot just call acpicpu_setperf
directly, we must call the global function pointer cpu_setperf because
we might be on an MP system and if we don't, we only attempt to change
the frequency on a single core.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.49 2008/12/22 06:37:36 gwk Exp $ */
a43 1
void	acpicpu_setperf_ppc_change(struct acpicpu_pss *, int);
a49 16
#define ACPI_PDC_REVID		0x1
#define ACPI_PDC_SMP		0xa
#define ACPI_PDC_MSR		0x1

/* _PDC Intel capabilities flags from linux */
#define ACPI_PDC_P_FFH		0x0001
#define ACPI_PDC_C_C1_HALT	0x0002
#define ACPI_PDC_T_FFH		0x0004
#define ACPI_PDC_SMP_C1PT	0x0008
#define ACPI_PDC_SMP_C2C3	0x0010
#define ACPI_PDC_SMP_P_SWCOORD	0x0020
#define ACPI_PDC_SMP_C_SWCOORD	0x0040
#define ACPI_PDC_SMP_T_SWCOORD	0x0080
#define ACPI_PDC_C_C1_FFH	0x0100
#define ACPI_PDC_C_C2C3_FFH	0x0200

a123 2
void	acpicpu_set_pdc(struct acpicpu_softc *);

a172 22

void
acpicpu_set_pdc(struct acpicpu_softc *sc) {
	struct aml_value cmd;
	struct aml_value res;
	uint32_t buf[3];

	memset(&cmd, 0, sizeof(cmd));
	cmd.type = AML_OBJTYPE_BUFFER;
	cmd.v_buffer = (uint8_t *)&buf;
	cmd.length = sizeof(buf);

	buf[0] = ACPI_PDC_REVID;
	buf[1] = 1;
	buf[2] = ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH | ACPI_PDC_C_C1_FFH
	    | ACPI_PDC_C_C2C3_FFH | ACPI_PDC_SMP_P_SWCOORD | ACPI_PDC_SMP_C2C3
	    | ACPI_PDC_SMP_C1PT;

	aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PDC", 1, &cmd, &res);
}


a270 7

#if defined(amd64)
	if (strcmp(cpu_vendor, "GenuineIntel") == 0)
		if (cpu_ecxfeature & CPUIDECX_EST)
			acpicpu_set_pdc(sc);
#endif

a300 1

a344 1
				acpicpu_set_notify(acpicpu_setperf_ppc_change);
d538 2
d565 3
a584 10
}

void
acpicpu_setperf_ppc_change(struct acpicpu_pss *pss, int npss) {
	struct acpicpu_softc    *sc;

	sc = acpicpu_sc[0];

	if (sc != NULL)
		cpu_setperf(sc->sc_level);
@


1.49
log
@Make acpicpu_setperf behave the same as the ACPI aware EST and
powernow drivers if the _PPC is evaluated because an external
change has occured such as being disconnected from wall power
and the available states in _PSS change.  Have the acpicpu setperf
driver register a listner for _PPC changes, that way we are not
calling the setperf method twice on powernow machines when an
change occurs.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.48 2008/11/22 16:03:31 gwk Exp $ */
d639 1
a639 1
		acpicpu_setperf(sc->sc_level);
@


1.48
log
@Re-enable ACPI PDC support and fetching cpu performance states
from ACPI for est on amd64. This incorporates a few changes from krw@@
to fix minor nits, its unlikely to fix the problems with some machines
from acer and dell but lots of machines benefit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.44 2008/06/15 05:24:07 gwk Exp $ */
d44 1
d394 1
a587 2
	 * XXX part deux: this needs to account for _PPC as well
	 * when AC is removed the nr of _PSS entries can go down
a612 3
		/* reset performance to current percentage */
		/* XXX will fail for amd64 for now */
		cpu_setperf(sc->sc_level);
d630 10
@


1.47
log
@Fix various printf constructs either missing arguments or format specifiers.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.46 2008/08/08 01:05:20 krw Exp $ */
d50 16
d140 2
d191 22
d311 7
d348 1
@


1.46
log
@'prey' -> 'pray' in comment as prayer rather than predation seems
the intended meaning.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.45 2008/08/06 05:24:44 gwk Exp $ */
d318 1
a318 1
			printf("%s: invalid _PSS length\n");
@


1.45
log
@Backout the acpicpu_setpdc code and the code to allow est to use acpicpu
on amd64.
Evaluating the _PDC seems to lead to instability (PR5878 and a report by
jmc@@) on lower end machines its too close to release and I don't have
enough nickels.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.43 2008/06/01 17:59:55 marco Exp $ */
d536 1
a536 1
	 * are supposed to support the same states. For now we prey
@


1.44
log
@On AMD64 running on Intel processors with EST add support for retreiving
operating points from ACPI. In support of this add evaluation of the _PDC
object and give it the capability flags asserting OSPM management of CPU
power states.

ok marco@@, canacar@@
@
text
@a49 16
#define ACPI_PDC_REVID		0x1
#define ACPI_PDC_SMP		0xa
#define ACPI_PDC_MSR		0x1

/* _PDC Intel capabilities flags from linux */
#define ACPI_PDC_P_FFH		0x0001
#define ACPI_PDC_C_C1_HALT	0x0002
#define ACPI_PDC_T_FFH		0x0004
#define ACPI_PDC_SMP_C1PT	0x0008
#define ACPI_PDC_SMP_C2C3	0x0010
#define ACPI_PDC_SMP_P_SWCOORD	0x0020
#define ACPI_PDC_SMP_C_SWCOORD	0x0040
#define ACPI_PDC_SMP_T_SWCOORD	0x0080
#define ACPI_PDC_C_C1_FFH	0x0100
#define ACPI_PDC_C_C2C3_FFH	0x0200

a123 2
void	acpicpu_set_pdc(struct acpicpu_softc *);

a172 22

void
acpicpu_set_pdc(struct acpicpu_softc *sc) {
	struct aml_value cmd;
	struct aml_value res;
	uint32_t buf[3];

	memset(&cmd, 0, sizeof(buf));
	cmd.type = AML_OBJTYPE_BUFFER;
	cmd.v_buffer = (uint8_t *)&buf;
	cmd.length = sizeof(buf);

	buf[0] = ACPI_PDC_REVID;
	buf[1] = 1;
	buf[2] = ACPI_PDC_C_C1_HALT | ACPI_PDC_P_FFH | ACPI_PDC_C_C1_FFH
	    | ACPI_PDC_C_C2C3_FFH | ACPI_PDC_SMP_P_SWCOORD | ACPI_PDC_SMP_C2C3
	    | ACPI_PDC_SMP_C1PT;

	aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PDC", 1, &cmd, &res);
}


a270 7

#if defined(amd64)
	if (strcmp(cpu_vendor, "GenuineIntel") == 0)
		if (cpu_ecxfeature & CPUIDECX_EST)
			acpicpu_set_pdc(sc);
#endif

a300 1

@


1.43
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.42 2008/02/07 19:53:49 pvalchev Exp $ */
d50 16
d140 2
d191 22
d311 7
d348 1
@


1.42
log
@unbreak build: aml_showvalue() is only available on !SMALL_KERNEL
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.41 2008/01/06 18:01:31 marco Exp $ */
a117 1
void    acpicpu_set_throttle(struct acpicpu_softc *, int);
d124 2
d127 1
d141 1
d171 1
@


1.41
log
@re-add _PPC.

ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.40 2007/12/29 02:55:44 marco Exp $ */
d212 1
a212 1
#ifdef ACPI_DEBUG
@


1.40
log
@Remove debug message.  Found by Mike Belopuhov, tsk tsk deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.39 2007/12/27 22:32:37 marco Exp $ */
d97 2
d102 5
d120 1
d247 1
a297 1
		/* XXX not the right test but has to do for now */
d312 7
d331 8
d397 1
a397 1
acpicpu_getpct(struct acpicpu_softc *sc)
d400 2
a401 1
	int			rv = 1;
d408 2
a409 1
	dnprintf(10, "_PPC: %d\n", aml_val2int(&res));
d412 9
d466 15
d556 1
a556 1
		acpicpu_getpct(sc);
d560 4
d588 1
a588 2
	int			idx;
	u_int32_t		stat_as, ctrl_as, stat_len, ctrl_len;
d606 2
a607 2
	if (sc->sc_pss_len == 0) {
		dnprintf(10, "%s: acpicpu no _PSS\n", sc->sc_devnode->name);
d611 5
a615 1
	idx = (sc->sc_pss_len - 1) - (level / (100 / sc->sc_pss_len));
d617 7
a623 7
		idx = 0; /* compensate */
	if (idx > sc->sc_pss_len) {
		/* XXX should never happen */
		printf("%s: acpicpu setperf index out of range\n",
		    sc->sc_devnode->name);
		return;
	}
d625 2
a626 2
	dnprintf(10, "%s: acpicpu setperf index %d\n",
	    sc->sc_devnode->name, idx);
a629 14
	/* if not set assume single 32 bit access */
	stat_as = sc->sc_pct.pct_status.grd_gas.register_bit_width / 8;
	if (stat_as == 0)
		stat_as = 4;
	ctrl_as = sc->sc_pct.pct_ctrl.grd_gas.register_bit_width / 8;
	if (ctrl_as == 0)
		ctrl_as = 4;
	stat_len = sc->sc_pct.pct_status.grd_gas.access_size;
	if (stat_len == 0)
		stat_len = stat_as;
	ctrl_len = sc->sc_pct.pct_ctrl.grd_gas.access_size;
	if (ctrl_len == 0)
		ctrl_len = ctrl_as;

d635 1
a635 1
	    stat_as, stat_len,
d638 1
a638 1
	    ctrl_as, ctrl_len);
d642 2
a643 2
	    sc->sc_pct.pct_status.grd_gas.address, stat_as, stat_len,
	    &status);
d652 2
a653 2
	    sc->sc_pct.pct_ctrl.grd_gas.address, ctrl_as, ctrl_len,
	    &pss->pss_ctrl);
d658 2
a659 2
	    sc->sc_pct.pct_status.grd_gas.address, stat_as, stat_as,
	    &status);
d663 1
a663 1
	 if (status == pss->pss_status)
d665 2
a666 1
	else
@


1.39
log
@Undo previous commit after debating a few corner cases with gwk.  This
needs to be redone in another way.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.37 2007/12/27 01:18:50 marco Exp $ */
a316 1
				printf("acpi does throttle\n");
@


1.38
log
@Add _PPC support.  Tested by several people.
@
text
@a96 2
	int			sc_ppc;
	int			sc_level;
a99 5
	/* save compensation for pct access for lying bios' */
	u_int32_t		sc_pct_stat_as;
	u_int32_t		sc_pct_ctrl_as;
	u_int32_t		sc_pct_stat_len;
	u_int32_t		sc_pct_ctrl_len;
a112 1
int	acpicpu_getppc(struct acpicpu_softc *);
a238 1
	u_int32_t		status = 0;
d289 1
a303 8
		if (sc->sc_pss_len == 0) {
			/* this should never happen */
			printf("%s: invalid _PSS length\n");
			sc->sc_flags |= FLAGS_NOPSS;
			goto bypass;
		}

		acpicpu_getppc(sc);
a315 8
			acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
			    sc->sc_pct.pct_status.grd_gas.address_space_id,
			    sc->sc_pct.pct_status.grd_gas.address,
			    sc->sc_pct_stat_as, sc->sc_pct_stat_as, &status);
			sc->sc_level = (100 / sc->sc_pss_len) *
			    (sc->sc_pss_len - status);
			dnprintf(20, "%s: cpu index %d, percentage %d\n",
			    DEVNAME(sc), status, sc->sc_level);
d317 1
d324 1
a324 1
bypass:
d375 1
a375 1
acpicpu_getppc(struct acpicpu_softc *sc)
d378 1
a378 2

	sc->sc_ppc = 0;
d385 1
a385 2
	sc->sc_ppc = aml_val2int(&res);
	dnprintf(10, "%s: _PPC: %d\n", DEVNAME(sc), sc->sc_ppc);
a387 9
	return (0);
}

int
acpicpu_getpct(struct acpicpu_softc *sc)
{
	struct aml_value	res;
	int			rv = 1;

a432 15
	/* if not set assume single 32 bit access */
	sc->sc_pct_stat_as = sc->sc_pct.pct_status.grd_gas.register_bit_width
	    / 8;
	if (sc->sc_pct_stat_as == 0)
		sc->sc_pct_stat_as = 4;
	sc->sc_pct_ctrl_as = sc->sc_pct.pct_ctrl.grd_gas.register_bit_width / 8;
	if (sc->sc_pct_ctrl_as == 0)
		sc->sc_pct_ctrl_as = 4;
	sc->sc_pct_stat_len = sc->sc_pct.pct_status.grd_gas.access_size;
	if (sc->sc_pct_stat_len == 0)
		sc->sc_pct_stat_len = sc->sc_pct_stat_as;
	sc->sc_pct_ctrl_len = sc->sc_pct.pct_ctrl.grd_gas.access_size;
	if (sc->sc_pct_ctrl_len == 0)
		sc->sc_pct_ctrl_len = sc->sc_pct_ctrl_as;

d508 4
a511 3
		acpicpu_getppc(sc);
		/* reset performance to current percentage */
		acpicpu_setperf(sc->sc_level);
d536 2
a537 1
	int			idx, len;
d555 1
a555 1
	if (sc->sc_flags & FLAGS_NOPSS) {
d560 1
a560 5
	if (sc->sc_ppc)
		len = sc->sc_ppc;
	else
		len = sc->sc_pss_len;
	idx = (len - 1) - (level / (100 / len));
d562 7
a568 1
		idx = 0;
d570 2
a571 2
	if (sc->sc_ppc)
		idx += sc->sc_pss_len - sc->sc_ppc;
d573 1
a573 2
	if (idx > sc->sc_pss_len)
		idx = sc->sc_pss_len - 1;
d575 13
a587 4
	dnprintf(10, "%s: acpicpu setperf index %d pss_len %d ppc %d\n",
	    sc->sc_devnode->name, idx, sc->sc_pss_len, sc->sc_ppc);

	pss = &sc->sc_pss[idx];
d594 1
a594 1
	    sc->sc_pct_stat_as, sc->sc_pct_stat_len,
d597 1
a597 1
	    sc->sc_pct_ctrl_as, sc->sc_pct_ctrl_len);
d601 2
a602 2
	    sc->sc_pct.pct_status.grd_gas.address, sc->sc_pct_stat_as,
	    sc->sc_pct_stat_len, &status);
d611 2
a612 2
	    sc->sc_pct.pct_ctrl.grd_gas.address, sc->sc_pct_ctrl_as,
	    sc->sc_pct_ctrl_len, &pss->pss_ctrl);
d617 2
a618 2
	    sc->sc_pct.pct_status.grd_gas.address, sc->sc_pct_stat_as,
	    sc->sc_pct_stat_as, &status);
d622 1
a622 1
	 if (status == pss->pss_status) {
d624 1
a624 2
		sc->sc_level = level;
	} else
@


1.37
log
@KNF, no functional change
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.36 2007/12/05 21:42:14 marco Exp $ */
d97 2
d102 5
d120 1
d247 1
a297 1
		/* XXX not the right test but has to do for now */
d312 8
d332 8
a340 1
				printf("acpi does throttle\n");
d347 1
a347 1

d398 1
a398 1
acpicpu_getpct(struct acpicpu_softc *sc)
d401 2
a402 1
	int			rv = 1;
d409 2
a410 1
	dnprintf(10, "_PPC: %d\n", aml_val2int(&res));
d413 9
d467 15
d557 3
a559 4
		acpicpu_getpct(sc);
		acpicpu_getpss(sc);
		if (sc->sc_notify)
			sc->sc_notify(sc->sc_pss, sc->sc_pss_len);
d584 1
a584 2
	int			idx;
	u_int32_t		stat_as, ctrl_as, stat_len, ctrl_len;
d602 1
a602 1
	if (sc->sc_pss_len == 0) {
d607 5
a611 1
	idx = (sc->sc_pss_len - 1) - (level / (100 / sc->sc_pss_len));
d613 7
a619 7
		idx = 0; /* compensate */
	if (idx > sc->sc_pss_len) {
		/* XXX should never happen */
		printf("%s: acpicpu setperf index out of range\n",
		    sc->sc_devnode->name);
		return;
	}
d621 2
a622 2
	dnprintf(10, "%s: acpicpu setperf index %d\n",
	    sc->sc_devnode->name, idx);
a625 14
	/* if not set assume single 32 bit access */
	stat_as = sc->sc_pct.pct_status.grd_gas.register_bit_width / 8;
	if (stat_as == 0)
		stat_as = 4;
	ctrl_as = sc->sc_pct.pct_ctrl.grd_gas.register_bit_width / 8;
	if (ctrl_as == 0)
		ctrl_as = 4;
	stat_len = sc->sc_pct.pct_status.grd_gas.access_size;
	if (stat_len == 0)
		stat_len = stat_as;
	ctrl_len = sc->sc_pct.pct_ctrl.grd_gas.access_size;
	if (ctrl_len == 0)
		ctrl_len = ctrl_as;

d631 1
a631 1
	    stat_as, stat_len,
d634 1
a634 1
	    ctrl_as, ctrl_len);
d638 2
a639 2
	    sc->sc_pct.pct_status.grd_gas.address, stat_as, stat_len,
	    &status);
d648 2
a649 2
	    sc->sc_pct.pct_ctrl.grd_gas.address, ctrl_as, ctrl_len,
	    &pss->pss_ctrl);
d654 2
a655 2
	    sc->sc_pct.pct_status.grd_gas.address, stat_as, stat_as,
	    &status);
d659 1
a659 1
	 if (status == pss->pss_status)
d661 2
a662 1
	else
@


1.36
log
@Add a check for pss len == 0.  This is a temporary work around for when
there is no pss available.  The real fix will include using both pss and
duty cycle methods.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.35 2007/12/03 00:25:24 fgsch Exp $ */
d66 1
a66 1
#define valid_throttle(o,w,a) (a && w && (o+w)<=31 && (o>4 || (o+w)<=4))
d100 2
a101 1
	/* XXX: _PPC Change listener
d106 2
a107 1
	 * one listener */
d115 2
a116 1
struct acpi_cstate *acpicpu_add_cstate(struct acpicpu_softc *, int, int, int, int);
d153 1
a153 1
	struct acpi_cstate *cx;
d158 1
a158 1
	return NULL;
d162 2
a163 2
acpicpu_add_cstate(struct acpicpu_softc *sc, int type,
		   int latency, int power, int address)
d165 1
a165 1
	struct acpi_cstate *cx;
d192 1
a192 1
	return cx;
d195 1
a195 1
	return NULL;
d202 1
a202 1
	struct acpicpu_softc *sc = arg;
d209 1
d211 2
a212 3
			   val->v_package[2]->v_integer,
			   val->v_package[3]->v_integer,
			   -1);
a259 1

d271 1
a271 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CST", 0, NULL, &res) == 0) {
d276 1
a276 1
		/* Some systems don't export a full PBLK, reduce functionality */
d282 2
a283 2
				   sc->sc_acpi->sc_fadt->p_lvl2_lat, -1,
				   sc->sc_pblk_addr + 4);
d285 2
a286 2
				   sc->sc_acpi->sc_fadt->p_lvl3_lat, -1,
				   sc->sc_pblk_addr + 5);
a291 1

a303 1
		/* XXX this needs to be moved to probe routine */
d317 1
a380 1
		dnprintf(20, "%s: no _PPC\n", DEVNAME(sc));
d478 6
a483 2
acpicpu_fetch_pss(struct acpicpu_pss **pss) {
	/*XXX: According to the ACPI spec in an SMP system all processors
d486 2
a488 1
	struct acpicpu_softc *sc;
d491 1
a491 1
	if (!sc) {
a492 1
	}
d495 1
a495 1
	return sc->sc_pss_len;
d532 2
a533 1
acpicpu_setperf(int level) {
d603 1
a603 1
	dnprintf(20, "status: %u <- %u\n", status, pss->pss_status);
d619 1
a619 1
	dnprintf(20, "3 status: %d\n", status);
@


1.35
log
@set the value before freeing the result; marco@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.34 2007/11/16 16:55:27 mikeb Exp $ */
d543 9
@


1.34
log
@Fix dmesg output. From form@@.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.33 2007/11/16 16:16:04 deraadt Exp $ */
d470 2
a472 2

	sc->sc_pss_len = res.length;
@


1.33
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.32 2007/11/15 19:05:58 mikeb Exp $ */
d352 2
a353 1
	if (!(sc->sc_flags & (FLAGS_NOPSS | FLAGS_NOPCT | FLAGS_NOPSS)))
d356 13
a368 12
	/*
	 * If acpicpu is itself providing the capability to transition
	 * states, enumerate them in the fashion that est and powernow
	 * would.
	 */
	if (!(sc->sc_flags & FLAGS_NOPSS) && !(sc->sc_flags & FLAGS_NOPCT)) {
		printf("FVS, ");
		for (i = 0; i < sc->sc_pss_len - 1; i++)
			printf("%d, ", sc->sc_pss[i].pss_core_freq);
		printf("%d MHz", sc->sc_pss[i].pss_core_freq);
	} else if (!(sc->sc_flags & FLAGS_NOPSS))
		printf("PSS");
@


1.32
log
@Nicer dmesg output.

From Oleg Safiullin (form@@)

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.31 2007/11/12 21:58:14 deraadt Exp $ */
d126 1
a126 5
#ifdef __i386__
struct acpicpu_softc *acpicpu_sc[I386_MAXPROCS];
#elif __amd64__
struct acpicpu_softc *acpicpu_sc[X86_MAXPROCS];
#endif
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.30 2007/11/12 19:55:46 deraadt Exp $ */
d237 1
a237 1
	struct			aml_value res;
d332 21
a352 18
	i = 0;
	printf(":");
	SLIST_FOREACH(cx, &sc->sc_cstates, link) {
		if (i)
			printf(",");
		switch (cx->type) {
		case ACPI_STATE_C0:
			printf(" C0");
			break;
		case ACPI_STATE_C1:
			printf(" C1");
			break;
		case ACPI_STATE_C2:
			printf(" C2");
			break;
		case ACPI_STATE_C3:
			printf(" C3");
			break;
a353 1
		i++;
d355 3
a357 10
	if (!(sc->sc_flags & FLAGS_NOPSS) && !(sc->sc_flags & FLAGS_NOPCT)) {
		if (i)
			printf(",");
		printf(" FVS");
	} else if (!(sc->sc_flags & FLAGS_NOPSS)) {
		if (i)
			printf(",");
		printf(" PSS");
	}
	printf("\n");
d365 8
a372 5
		printf("%s: ", sc->sc_dev.dv_xname);
		for (i = 0; i < sc->sc_pss_len; i++)
			printf("%d%s", sc->sc_pss[i].pss_core_freq,
			    i < sc->sc_pss_len - 1 ? ", " : " MHz\n");
	}
@


1.30
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.29 2007/11/12 04:31:16 deraadt Exp $ */
d104 1
a104 1
	 * Should probably be reimplemented as a list for now we assume only 
d106 1
a106 1
	void 			(*sc_notify)(struct acpicpu_pss *, int);
d266 1
a266 1
		sc->sc_pblk_addr, sc->sc_pblk_len, 
d328 1
a328 1
	/* 
d337 1
a337 1
		switch(cx->type) {
@


1.29
log
@missing :
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.28 2007/11/03 20:53:02 gwk Exp $ */
d45 10
a54 10
#define ACPI_STATE_C0     	0x00
#define ACPI_STATE_C1     	0x01
#define ACPI_STATE_C2     	0x02
#define ACPI_STATE_C3     	0x03

#define FLAGS_NO_C2       	0x01
#define FLAGS_NO_C3       	0x02
#define FLAGS_BMCHECK     	0x04
#define FLAGS_NOTHROTTLE  	0x08
#define FLAGS_NOPSS       	0x10
d58 1
a58 1
#define CPU_MAXSTATE(sc)  	(1L << (sc)->sc_duty_wid)
d60 1
a60 1
#define CPU_STATEMASK(sc)       ((CPU_MAXSTATE(sc) - 1) << (sc)->sc_duty_off)
d62 2
a63 2
#define ACPI_MAX_C2_LATENCY     100
#define ACPI_MAX_C3_LATENCY     1000
d70 4
a73 4
	int      type;
	int      latency;
	int      power;
	int      address;
d169 1
a169 1
	       type, latency, power, address);
@


1.28
log
@Remove a useless printf, hit if acpicpu is disabled.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.27 2007/10/08 04:15:15 krw Exp $ */
d331 1
a331 1
	 * */
d333 1
@


1.27
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.26 2007/06/15 22:37:40 gwk Exp $ */
a489 1
		printf("couldnt fetch acpicpu_softc\n");
@


1.26
log
@Check that sc_notify actually points to something before attempting to call
it. Fixes marco@@'s post c2k7 panics.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.25 2007/05/31 17:49:16 gwk Exp $ */
d184 1
a184 2
	cx = malloc(sizeof(struct acpi_cstate), M_DEVBUF, M_WAITOK);
	memset(cx, 0, sizeof(struct acpi_cstate));
d457 1
a457 3
	    M_WAITOK);

	memset(sc->sc_pss, 0, res.length * sizeof *sc->sc_pss);
@


1.25
log
@Make powernow-k8 on amd64 and i386 use the _PSS object from acpi to
retreive p_state data as spelled out in the amd64 bios and kernel
developers guide. This code is still a little rough around the edges but
has been tested by myself on a tyan machine and by phessler at theapt
dot org on an HP DL145. This diff also takes a first stab and cleaning up
the acpicpu dmesg spam.

ok tedu, marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.24 2007/05/28 20:22:24 robert Exp $ */
d513 2
a514 1
		sc->sc_notify(sc->sc_pss, sc->sc_pss_len);
@


1.24
log
@fix build when ACPI_DEBUG is defined
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.23 2007/05/28 03:38:32 krw Exp $ */
d55 1
d100 7
d196 1
a196 1
	printf("acpicpu%d: C%d not supported", sc->sc_cpu, type);
d240 1
d244 1
a249 1
	printf(": %s: ", sc->sc_devnode->name);
d294 1
a294 2
		goto nopss;
	}
d297 30
a326 8
	for (i = 0; i < sc->sc_pss_len; i++) {
		dnprintf(20, "%d %d %d %d %d %d\n",
		    sc->sc_pss[i].pss_core_freq,
		    sc->sc_pss[i].pss_power,
		    sc->sc_pss[i].pss_trans_latency,
		    sc->sc_pss[i].pss_bus_latency,
		    sc->sc_pss[i].pss_ctrl,
		    sc->sc_pss[i].pss_status);
a327 5
	dnprintf(20, "\n");
#endif
	/* XXX this needs to be moved to probe routine */
	if (acpicpu_getpct(sc))
		return;
d329 32
a360 16
	/* Notify BIOS we are handing p-states */
	if (sc->sc_acpi->sc_fadt->pstate_cnt)
		acpi_write_pmreg(sc->sc_acpi, ACPIREG_SMICMD, 0,
		    sc->sc_acpi->sc_fadt->pstate_cnt);

	for (i = 0; i < sc->sc_pss_len; i++)
		printf("%d%s", sc->sc_pss[i].pss_core_freq,
		    i < sc->sc_pss_len - 1 ? ", " : " MHz\n");

	aml_register_notify(sc->sc_devnode, NULL,
	    acpicpu_notify, sc, ACPIDEV_NOPOLL);

	if (setperf_prio < 30) {
		cpu_setperf = acpicpu_setperf;
		setperf_prio = 30;
		acpi_hasprocfvs = 1;
d362 1
a362 2
	acpicpu_sc[sc->sc_dev.dv_unit] = sc;
	return;
d364 11
a374 5
nopss:
	if (sc->sc_flags & FLAGS_NOTHROTTLE)
		printf("no performance/throttling supported");

	printf("\n");
d385 1
a385 1
		printf("%s: no _PPC\n", DEVNAME(sc));
d393 1
a393 1
		printf("%s: no _PCT\n", DEVNAME(sc));
d398 1
a398 1
		printf("%s: %s: invalid _PCT length\n", DEVNAME(sc),
d407 2
a408 2
		printf("CTRL GASIO is CPU manufacturer overridden\n");
		goto bad;
d415 2
a416 2
		printf("STATUS GASIO is CPU manufacturer overridden\n");
		goto bad;
d438 1
a438 1
bad:
d450 1
a450 1
		dnprintf(20, "%s: no _PSS\n", DEVNAME(sc));
d484 18
d513 1
d522 9
@


1.23
log
@Eliminate unsightly blank lines in dmesg.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.22 2007/05/06 04:09:43 tedu Exp $ */
d470 1
a470 1
	    sc->sc_devnode->>name, level);
@


1.22
log
@at least always print a new line, even if NOPSS
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.21 2007/04/23 04:34:30 gwk Exp $ */
d188 1
a188 1
	printf("acpicpu%d: C%d not supported\n", sc->sc_cpu, type);
d326 3
a328 3
		printf("no performance/throttling supported\n");
	else
		printf("\n");
@


1.21
log
@spacing and some really long lines
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.20 2007/04/11 02:51:11 jordan Exp $ */
d327 2
@


1.20
log
@Added changes for C-State
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.19 2007/01/31 23:30:51 gwk Exp $ */
d45 10
a54 10
#define ACPI_STATE_C0     0x00
#define ACPI_STATE_C1     0x01
#define ACPI_STATE_C2     0x02
#define ACPI_STATE_C3     0x03

#define FLAGS_NO_C2       0x01
#define FLAGS_NO_C3       0x02
#define FLAGS_BMCHECK     0x04
#define FLAGS_NOTHROTTLE  0x08
#define FLAGS_NOPSS       0x10
d56 1
a56 1
#define CPU_THT_EN              (1L << 4)
d85 1
a85 1
	int                     sc_flags;
d148 1
a148 1
	SLIST_FOREACH(cx, &sc->sc_cstates, link) 
d155 1
a155 1
acpicpu_add_cstate(struct acpicpu_softc *sc, int type, 
d165 2
a166 1
		if (latency > ACPI_MAX_C2_LATENCY || !address || (sc->sc_flags & FLAGS_NO_C2))
d170 2
a171 1
		if (latency > ACPI_MAX_C3_LATENCY || !address || (sc->sc_flags & FLAGS_NO_C3))
d230 1
a230 1
	struct                  aml_value res;
d251 1
a251 1
	if (!valid_throttle(sc->sc_duty_off, sc->sc_duty_wid, sc->sc_pblk_addr)) 
d275 6
a280 4
		acpicpu_add_cstate(sc, ACPI_STATE_C2, sc->sc_acpi->sc_fadt->p_lvl2_lat, 
				   -1, sc->sc_pblk_addr + 4);
		acpicpu_add_cstate(sc, ACPI_STATE_C3, sc->sc_acpi->sc_fadt->p_lvl3_lat, 
				   -1, sc->sc_pblk_addr + 5);
d284 1
a284 1
	  	sc->sc_flags |= FLAGS_NOPSS;
d306 1
a306 1
		acpi_write_pmreg(sc->sc_acpi, ACPIREG_SMICMD, 0, 
@


1.19
log
@Introduce acpi_hasprocfvs thats "ACPI Has Processor Frequency and Voltage
Scalling" a global flag set by acicpu attach to indicate that ACPI is
handling fvs through the _PSS objects. This will fix disappearing
EST/powernow when booting kernels with acpi enabled, as acpicpu isnt
compiled into GENERIC yet. Also in cases where acpicpu is built in and
legacy EST/powernow work but acpi is missing the _PSS object, the legacy
routines will be used.

tested by dim@@, and Nick Nauwelaerts <nick AT nauwelaerts.net>
ok marco@@, dim@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.18 2006/12/29 04:28:44 marco Exp $ */
d25 1
d45 32
d79 9
d101 2
d105 2
d124 84
d228 1
d232 3
a234 1
	sc->sc_devnode = aa->aaa_node->child;
d238 40
a277 1
	printf(": %s: ", sc->sc_devnode->parent->name);
d280 2
a281 2
		printf("can't attach, no _PSS\n");
		return;
d300 5
d309 1
a309 1
	aml_register_notify(sc->sc_devnode->parent, NULL,
d318 5
d347 1
a347 1
		    sc->sc_devnode->parent->name);
d437 1
a437 1
	    sc->sc_devnode->parent->name);
d464 1
a464 1
	    sc->sc_devnode->parent->name, level);
d468 1
a468 1
		    sc->sc_devnode->parent->name);
d478 1
a478 1
		    sc->sc_devnode->parent->name);
d483 1
a483 1
	    sc->sc_devnode->parent->name, idx);
d538 1
a538 1
		    sc->sc_devnode->parent->name);
@


1.18
log
@Replace setperf algorithm with a linear version.  Also use the aml provided
gasio structure when appropriate instead of always assuming 32 bit access.
Fixes my Dell laptop and works on others tested.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.17 2006/12/26 23:58:08 marco Exp $ */
d138 1
d281 1
a281 1
	dnprintf(10, "%s: acpicpu setperf level %d\n", 
d285 1
a285 1
		dnprintf(10, "%s: acpicpu setperf illegal percentage\n", 
d295 1
a295 1
		printf("%s: acpicpu setperf index out of range\n", 
d300 1
a300 1
	dnprintf(10, "%s: acpicpu setperf index %d\n", 
d355 1
a355 1
		printf("%s: acpicpu setperf failed to alter frequency\n", 
@


1.17
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.16 2006/12/21 11:23:41 deraadt Exp $ */
a123 1

a139 1

d272 5
a276 4
	struct acpicpu_softc *sc;
	struct acpicpu_pss *pss = NULL;
	int high, low, freq, i;
	u_int32_t status;
a278 3
	high = sc->sc_pss[0].pss_core_freq;
	low = sc->sc_pss[sc->sc_pss_len - 1].pss_core_freq;
	freq = low + (high - low) * level / 100;
d280 7
a286 5
	for (i = 0; i < sc->sc_pss_len; i++) {
		if (sc->sc_pss[i].pss_core_freq <= freq) {
			pss = &sc->sc_pss[i];
			break;
		}
d289 7
a295 1
	if (pss == NULL)
d297 4
d302 26
d330 1
a330 1
	    sc->sc_pct.pct_status.grd_gas.address, 1, 4,
d332 1
d340 1
a340 1
	    sc->sc_pct.pct_ctrl.grd_gas.address, 1, 4,
d342 1
d346 1
a346 1
	    sc->sc_pct.pct_status.grd_gas.address, 1, 4,
d348 1
d353 3
a355 2

	return;
@


1.16
log
@more minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.15 2006/12/20 22:48:29 gwk Exp $ */
d134 1
a134 1
	    acpicpu_notify, sc);
@


1.15
log
@Decalre extern int cpuspeed in sys/arch/amd64/include/cpu.h like cpuspeed
is declared in the equivalent file on i386 and delete the repeticious
declarations already scattered in a few places.
Thanks to Will Backman for letting me test this on his machine,
ok mk@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.14 2006/12/20 17:50:40 gwk Exp $ */
d72 1
a72 1
#ifdef __i386__ 
@


1.14
log
@"#ifdef is a tool of the weak!"
Rename pentium_mhz to cpuspeed which is consistant with amd64 making
shared ACPI code less nasty.
ok marco, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.13 2006/12/19 20:28:11 gwk Exp $ */
a74 1
extern int cpuspeed;
@


1.13
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.12 2006/12/19 16:48:16 marco Exp $ */
a315 3
#ifdef __i386__
		pentium_mhz = pss->pss_core_freq;
#elif __amd64__
d317 1
a317 1
#endif
@


1.12
log
@Add sanity to check for mfg overriden gasio field.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.11 2006/12/19 16:20:01 gwk Exp $ */
d84 1
a84 1
	
d134 1
a134 1
	aml_register_notify(sc->sc_devnode->parent, NULL, 
d136 1
a136 1
	
d141 2
a142 2
	acpicpu_sc[sc->sc_dev.dv_unit] = sc; 
	  
d221 1
a221 1
	
d279 1
a279 1
	
d303 1
a303 1
	
d306 1
a306 1
	    sc->sc_pct.pct_ctrl.grd_gas.address, 1, 4, 
d308 1
a308 1
	
d315 1
a315 1
	 if (status == pss->pss_status) 	
d320 1
a320 1
#endif	
@


1.11
log
@Hook up acpicpu to the hw.setperf mechanism, this allows people running
ACPI kernels built with the acpicpu diff to scale processor and frequency
voltage, various incarnations tested by brad, thib, johan m:son lindman.
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.10 2006/10/12 16:38:21 jordan Exp $ */
d125 5
a133 2
	acpicpu_getpct(sc);

d149 1
d151 1
a151 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PPC", 0, NULL, &res) != 0) {
d160 1
a160 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PCT", 0, NULL, &res) != 0) {
		dnprintf(20, "%s: no _PCT\n", DEVNAME(sc));
d173 6
d181 5
a185 1
	aml_freevalue(&res);
d205 4
a208 1
	return (0);
d217 1
a217 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSS", 0, NULL, &res) != 0) {
@


1.10
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.9 2006/03/09 05:16:27 jordan Exp $ */
d21 1
d42 1
d70 9
d133 7
a191 29
#if 0
	char			pb[8];

	acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
	   sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	   sc->sc_pct.pct_ctrl.grd_gas.address,
	   1,
	   4,
	   //sc->sc_pct.pct_ctrl.grd_gas.register_bit_width >> 3,
	   pb);

	acpi_gasio(sc->sc_acpi, ACPI_IOWRITE,
	   sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	   sc->sc_pct.pct_ctrl.grd_gas.address,
	   1,
	   4,
	   //sc->sc_pct.pct_ctrl.grd_gas.register_bit_width >> 3,
	   &sc->sc_pss[3].pss_ctrl);

	acpi_gasio(sc->sc_acpi, ACPI_IOREAD,
	   sc->sc_pct.pct_ctrl.grd_gas.address_space_id,
	   sc->sc_pct.pct_ctrl.grd_gas.address,
	   1,
	   4,
	   //sc->sc_pct.pct_ctrl.grd_gas.register_bit_width >> 3,
	   pb);
	printf("acpicpu: %02x %02x %02x %02x\n", pb[0], pb[1], pb[2], pb[3]);
#endif

d254 14
d269 37
a305 1
	return (0);
@


1.9
log
@Fixed free before malloc. bad marco
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.8 2006/03/05 04:48:55 marco Exp $ */
d127 1
a127 2
	struct aml_value	res, env;
	struct acpi_context	*ctx;
d129 1
a129 5
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_PPC", &res, &env)) {
d135 2
a136 1
	dnprintf(10, "_PPC: %d\n", aml_val2int(NULL, &res));
d138 1
a138 1
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_PCT", &res, &env)) {
d154 1
d209 1
a209 2
	struct aml_value	res, env;
	struct acpi_context	*ctx;
d212 1
a212 5
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_PSS", &res, &env)) {
d226 1
a226 1
		sc->sc_pss[i].pss_core_freq = aml_val2int(ctx,
d228 1
a228 1
		sc->sc_pss[i].pss_power = aml_val2int(ctx,
d230 1
a230 1
		sc->sc_pss[i].pss_trans_latency = aml_val2int(ctx,
d232 1
a232 1
		sc->sc_pss[i].pss_bus_latency = aml_val2int(ctx,
d234 1
a234 1
		sc->sc_pss[i].pss_ctrl = aml_val2int(ctx,
d236 1
a236 1
		sc->sc_pss[i].pss_status = aml_val2int(ctx,
d239 1
@


1.8
log
@Update tables after event.
Free memory while at it.
Register notify handler and use NULL for PNP id.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.7 2006/03/04 18:24:34 marco Exp $ */
d225 1
a225 4
	if (!sc->sc_pss)
		sc->sc_pss = malloc(res.length * sizeof *sc->sc_pss, M_DEVBUF,
		    M_WAITOK);
	else
d227 3
@


1.7
log
@oops some debug code was enabled.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.6 2006/03/04 05:36:42 marco Exp $ */
d120 2
a121 1
	/* aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpicpu_notify, sc); */
d228 3
d261 11
a271 2
	printf("acpicpu_notify: %.2x %s\n", notify_type,
	    sc->sc_devnode->parent->name);
@


1.6
log
@Add the gasio magic to slow/speed cpu.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.5 2006/02/26 17:28:26 marco Exp $ */
a73 3
	printf("acpicpu_match: %s %s\n", 
		aa->aaa_name, cf->cf_driver->cd_name);

a127 1
	char			pb[8];
d176 3
a178 1
	acpi_debug = 111;
d203 1
a203 1
	acpi_debug = 21;
@


1.5
log
@Print _PCT & _PPC.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.4 2006/02/26 07:59:20 marco Exp $ */
d73 3
d131 1
d165 5
a169 5
	    sc->sc_pct.pct_ctrl.grd_access_type,
	    sc->sc_pct.pct_ctrl.grd_reg_width,
	    sc->sc_pct.pct_ctrl.grd_reg_bit_offset,
	    sc->sc_pct.pct_ctrl.grd_address_size,
	    sc->sc_pct.pct_ctrl.grd_address);
d174 32
a205 5
	    sc->sc_pct.pct_status.grd_access_type,
	    sc->sc_pct.pct_status.grd_reg_width,
	    sc->sc_pct.pct_status.grd_reg_bit_offset,
	    sc->sc_pct.pct_status.grd_address_size,
	    sc->sc_pct.pct_status.grd_address);
@


1.4
log
@Print only MHz.  Idea from jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.3 2006/02/26 05:17:25 marco Exp $ */
d53 2
d57 1
d118 2
d121 56
@


1.3
log
@Print ACPI cpu name during dmesg as well.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.2 2006/02/26 04:38:38 marco Exp $ */
d26 3
d99 12
d112 2
a113 3
		printf("%d MHz %d mW  ", sc->sc_pss[i].pss_core_freq,
		    sc->sc_pss[i].pss_power);
	printf("\n");
@


1.2
log
@Print core frequency and power usage during dmesg.
@
text
@d1 1
a1 1
/* $OpenBSD: acpicpu.c,v 1.1 2006/02/26 02:49:28 marco Exp $ */
d89 1
a89 1
	printf(": ");
@


1.1
log
@Add acpicpu device.  Remains disabled.

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 3
d52 1
a52 1
int	acpicpu_getsta(struct acpicpu_softc *);
d82 1
d87 8
a94 1
	acpicpu_getsta(sc); 
d96 4
a99 1
	printf(":\n");
d101 1
a101 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpicpu_notify, sc);
d105 1
a105 1
acpicpu_getsta(struct acpicpu_softc *sc)
d109 1
d115 3
a117 3
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env)) {
		dnprintf(20, "%s: no _STA\n", DEVNAME(sc));
		/* XXX not all buttons have _STA so FALLTROUGH */
d119 22
@

