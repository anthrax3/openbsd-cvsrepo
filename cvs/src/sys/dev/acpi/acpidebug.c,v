head	1.30;
access;
symbols
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.29.0.8
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.14
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.30
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.29;
commitid	p4LJxGKbi0BU2cG6;

1.29
date	2013.12.12.21.00.09;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.18.23.44.57;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.27.21.04.22;	author jordan;	state Exp;
branches;
next	1.23;

1.23
date	2009.05.30.22.49.56;	author jordan;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.12.20.36.50;	author jordan;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.06.20.10.21;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.06.09.15.32;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.12.21.58.14;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.06.18.56.31;	author jordan;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.21.11.29.58;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.22.39.04;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.24.19.01.48;	author jordan;	state Exp;
branches;
next	1.10;

1.10
date	2006.10.19.07.02.20;	author jordan;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.21.21.11.10;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.09.05.38.12;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.09.04.41.11;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.09.03.52.19;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.09.03.40.31;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.08.21.04.18;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.03.07.23.13.28;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.05.14.46.46;	author marco;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/* $OpenBSD: acpidebug.c,v 1.29 2013/12/12 21:00:09 guenther Exp $ */
/*
 * Copyright (c) 2006 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <machine/db_machdep.h>
#include <ddb/db_output.h>
#include <ddb/db_extern.h>
#include <ddb/db_lex.h>

#include <machine/bus.h>
#include <sys/malloc.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/acpidebug.h>
#include <dev/acpi/dsdt.h>

#ifdef DDB

extern int aml_pc(uint8_t *);

extern const char *aml_mnem(int opcode, uint8_t *);
extern const char *aml_nodename(struct aml_node *);
extern void aml_disasm(struct aml_scope *scope, int lvl,
    void (*dbprintf)(void *, const char *, ...),
    void *arg);

const char		*db_aml_objtype(struct aml_value *);
const char		*db_opregion(int);
int			db_parse_name(void);
void			db_aml_dump(int, u_int8_t *);
void			db_aml_showvalue(struct aml_value *);
void			db_aml_walktree(struct aml_node *);
void			db_disprint(void *, const char *, ...);

const char		*db_aml_fieldacc(int);
const char		*db_aml_fieldlock(int);
const char		*db_aml_fieldupdate(int);

extern struct aml_node	aml_root;

/* name of scope for lexer */
char			scope[80];

const char *
db_opregion(int id)
{
	switch (id) {
	case 0:
		return "SystemMemory";
	case 1:
		return "SystemIO";
	case 2:
		return "PCIConfig";
	case 3:
		return "Embedded";
	case 4:
		return "SMBus";
	case 5:
		return "CMOS";
	case 6:
		return "PCIBAR";
	}
	return "";
}
void
db_aml_dump(int len, u_int8_t *buf)
{
	int		idx;

	db_printf("{ ");
	for (idx = 0; idx < len; idx++)
		db_printf("%s0x%.2x", idx ? ", " : "", buf[idx]);
	db_printf(" }\n");
}

void
db_aml_showvalue(struct aml_value *value)
{
	int		idx;

	if (value == NULL)
		return;

	if (value->node)
		db_printf("[%s] ", aml_nodename(value->node));

	switch (value->type) {
	case AML_OBJTYPE_OBJREF:
		db_printf("refof: %x {\n", value->v_objref.index);
		db_aml_showvalue(value->v_objref.ref);
		db_printf("}\n");
		break;
	case AML_OBJTYPE_NAMEREF:
		db_printf("nameref: %s\n", value->v_nameref);
		break;
	case AML_OBJTYPE_INTEGER:
		db_printf("integer: %llx\n", value->v_integer);
		break;
	case AML_OBJTYPE_STRING:
		db_printf("string: %s\n", value->v_string);
		break;
	case AML_OBJTYPE_PACKAGE:
		db_printf("package: %d {\n", value->length);
		for (idx = 0; idx < value->length; idx++)
			db_aml_showvalue(value->v_package[idx]);
		db_printf("}\n");
		break;
	case AML_OBJTYPE_BUFFER:
		db_printf("buffer: %d ", value->length);
		db_aml_dump(value->length, value->v_buffer);
		break;
	case AML_OBJTYPE_DEBUGOBJ:
		db_printf("debug");
		break;
	case AML_OBJTYPE_MUTEX:
		db_printf("mutex : %llx\n", value->v_integer);
		break;
	case AML_OBJTYPE_DEVICE:
		db_printf("device\n");
		break;
	case AML_OBJTYPE_EVENT:
		db_printf("event\n");
		break;
	case AML_OBJTYPE_PROCESSOR:
		db_printf("cpu: %x,%x,%x\n",
		    value->v_processor.proc_id,
		    value->v_processor.proc_addr,
		    value->v_processor.proc_len);
		break;
	case AML_OBJTYPE_METHOD:
		db_printf("method: args=%d, serialized=%d, synclevel=%d\n",
		    AML_METHOD_ARGCOUNT(value->v_method.flags),
		    AML_METHOD_SERIALIZED(value->v_method.flags),
		    AML_METHOD_SYNCLEVEL(value->v_method.flags));
		break;
	case AML_OBJTYPE_FIELDUNIT:
		db_printf("%s: access=%x,lock=%x,update=%x pos=%.4x "
		    "len=%.4x\n",
		    aml_mnem(value->v_field.type, NULL),
		    AML_FIELD_ACCESS(value->v_field.flags),
		    AML_FIELD_LOCK(value->v_field.flags),
		    AML_FIELD_UPDATE(value->v_field.flags),
		    value->v_field.bitpos,
		    value->v_field.bitlen);
		if (value->v_field.ref2)
			db_printf("  index: %.3x %s\n",
			    value->v_field.ref3,
			    aml_nodename(value->v_field.ref2->node));
		if (value->v_field.ref1)
			db_printf("  data: %s\n",
			    aml_nodename(value->v_field.ref1->node));
		break;
	case AML_OBJTYPE_BUFFERFIELD:
		db_printf("%s: pos=%.4x len=%.4x\n",
		    aml_mnem(value->v_field.type, NULL),
		    value->v_field.bitpos,
		    value->v_field.bitlen);
		db_printf("  buffer: %s\n",
		    aml_nodename(value->v_field.ref1->node));
		break;
	case AML_OBJTYPE_OPREGION:
		db_printf("opregion: %s,0x%llx,0x%x\n",
		    db_opregion(value->v_opregion.iospace),
		    value->v_opregion.iobase,
		    value->v_opregion.iolen);
		break;
	default:
		db_printf("unknown: %d\n", value->type);
		break;
	}
}

const char *
db_aml_objtype(struct aml_value *val)
{
	if (val == NULL)
		return "nil";

	switch (val->type) {
	case AML_OBJTYPE_INTEGER:
		return "integer";
	case AML_OBJTYPE_STRING:
		return "string";
	case AML_OBJTYPE_BUFFER:
		return "buffer";
	case AML_OBJTYPE_PACKAGE:
		return "package";
	case AML_OBJTYPE_DEVICE:
		return "device";
	case AML_OBJTYPE_EVENT:
		return "event";
	case AML_OBJTYPE_METHOD:
		return "method";
	case AML_OBJTYPE_MUTEX:
		return "mutex";
	case AML_OBJTYPE_OPREGION:
		return "opregion";
	case AML_OBJTYPE_POWERRSRC:
		return "powerrsrc";
	case AML_OBJTYPE_PROCESSOR:
		return "processor";
	case AML_OBJTYPE_THERMZONE:
		return "thermzone";
	case AML_OBJTYPE_DDBHANDLE:
		return "ddbhandle";
	case AML_OBJTYPE_DEBUGOBJ:
		return "debugobj";
	case AML_OBJTYPE_NAMEREF:
		return "nameref";
	case AML_OBJTYPE_OBJREF:
		return "refof";
	case AML_OBJTYPE_FIELDUNIT:
	case AML_OBJTYPE_BUFFERFIELD:
		return aml_mnem(val->v_field.type, NULL);
	}

	return ("");
}

void
db_aml_walktree(struct aml_node *node)
{
	while (node) {
		db_aml_showvalue(node->value);
		db_aml_walktree(SIMPLEQ_FIRST(&node->son));
		node = SIMPLEQ_NEXT(node, sib);
	}
}

int
db_parse_name(void)
{
	int		t, rv = 1;

	memset(scope, 0, sizeof scope);
	do {
		t = db_read_token();
		if (t == tIDENT) {
			if (strlcat(scope, db_tok_string, sizeof scope) >=
			    sizeof scope) {
				printf("Input too long\n");
				goto error;
			}
			t = db_read_token();
			if (t == tDOT)
				if (strlcat(scope, ".", sizeof scope) >=
				    sizeof scope) {
					printf("Input too long 2\n");
					goto error;
				}
		}
	} while (t != tEOL);

	if (!strlen(scope)) {
		db_printf("Invalid input\n");
		goto error;
	}

	rv = 0;
error:
	/* get rid of the rest of input */
	db_flush_lex();
	return (rv);
}

/* ddb interface */
void
db_acpi_showval(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	struct aml_node *node;

	if (db_parse_name())
		return;

	node = aml_searchname(&aml_root, scope);
	if (node)
		db_aml_showvalue(node->value);
	else
		db_printf("Not a valid value\n");
}

void db_disprint(void *arg, const char *fmt, ...)
{
	va_list ap;

	va_start(ap,fmt);
	db_vprintf(fmt, ap);
	va_end(ap);
}

void
db_acpi_disasm(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	struct aml_node *node;

	if (db_parse_name())
		return;

	node = aml_searchname(&aml_root, scope);
	if (node && node->value && node->value->type == AML_OBJTYPE_METHOD) {
		struct aml_scope ns;

		memset(&ns, 0, sizeof(ns));
		ns.pos   = node->value->v_method.start;
		ns.end   = node->value->v_method.end;
		ns.node  = node;
		while (ns.pos < ns.end)
			aml_disasm(&ns, 0, db_disprint, 0);
	}
	else
		db_printf("Not a valid method\n");
}

void
db_acpi_tree(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	db_aml_walktree(&aml_root);
}

void
db_acpi_trace(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	struct aml_scope *root;
	struct aml_value *sp;
	int idx;
	extern struct aml_scope *aml_lastscope;

	for (root=aml_lastscope; root && root->pos; root=root->parent) {
		db_printf("%.4x Called: %s\n", aml_pc(root->pos),
		    aml_nodename(root->node));
		for (idx = 0; idx< AML_MAX_ARG; idx++) {
			sp = aml_getstack(root, AMLOP_ARG0 + idx);
			if (sp && sp->type) {
				db_printf("  arg%d: ", idx);
				db_aml_showvalue(sp);
		}
			}
		for (idx = 0; idx < AML_MAX_LOCAL; idx++) {
			sp = aml_getstack(root, AMLOP_LOCAL0 + idx);
			if (sp && sp->type) {
				db_printf("  local%d: ", idx);
				db_aml_showvalue(sp);
		}
	}
	}
}

#endif /* DDB */
@


1.29
log
@Add db_vprintf(), and then use it in ACPI's db_disprint() instead of
formatting into a local buffer.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.28 2013/11/18 23:44:57 deraadt Exp $ */
a18 1
#include <ddb/db_command.h>
@


1.28
log
@format string cleanup
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.27 2010/07/21 19:35:15 deraadt Exp $ */
a300 1
	char    stre[64];
d303 1
a303 1
	vsnprintf(stre, sizeof(stre), fmt, ap);
a304 2

	db_printf("%s", stre);
@


1.27
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.26 2010/07/08 20:56:31 jordan Exp $ */
d307 1
a307 1
	db_printf(stre);
@


1.26
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.24 2010/06/27 21:04:22 jordan Exp $ */
d39 2
a40 2
extern void aml_disasm(struct aml_scope *scope, int lvl, 
    void (*dbprintf)(void *, const char *, ...), 
d49 1
a49 1
void 			db_disprint(void *, const char *, ...);
d174 1
a174 1
		db_printf("  buffer: %s\n", 
d302 1
a302 1
	
@


1.25
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.23 2009/05/30 22:49:56 jordan Exp $ */
d241 2
a242 3
		db_aml_walktree(node->child);

		node = node->sibling;
d336 1
a336 1
	db_aml_walktree(aml_root.child);
@


1.24
log
@Change ACPI namespace to use SIMPLEQ macros
ok mlarkin
@
text
@d241 3
a243 2
		db_aml_walktree(SIMPLEQ_FIRST(&node->son));
		node = SIMPLEQ_NEXT(node, sib);
d337 1
a337 1
	db_aml_walktree(&aml_root);
@


1.23
log
@Added error handler for missing AML nameref; fixes PR6103
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.22 2008/06/12 20:36:50 jordan Exp $ */
d241 2
a242 3
		db_aml_walktree(node->child);

		node = node->sibling;
d336 1
a336 1
	db_aml_walktree(aml_root.child);
@


1.22
log
@Removed old AML disassembler code
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.21 2008/06/06 20:10:21 marco Exp $ */
d103 1
a103 1
	switch (value->type & ~AML_STATIC) {
d113 1
a113 2
		db_printf("integer: %llx %s\n", value->v_integer,
		    (value->type & AML_STATIC) ? "(static)" : "");
a195 2
	case AML_OBJTYPE_INTEGER+AML_STATIC:
		return "staticint";
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.20 2008/06/06 09:15:32 marco Exp $ */
a33 3
void db_aml_disline(uint8_t *, int, const char *, ...);
void db_aml_disint(struct aml_scope *, int, int);
uint8_t *db_aml_disasm(struct aml_node *, uint8_t *, uint8_t *, int, int);
a35 6
extern struct aml_scope *aml_pushscope(struct aml_scope *, uint8_t *, uint8_t *, struct aml_node *);
extern struct aml_scope *aml_popscope(struct aml_scope *);
extern uint8_t *aml_parsename(struct aml_scope *);
extern uint8_t *aml_parseend(struct aml_scope *);
extern int aml_parselength(struct aml_scope *);
extern int aml_parseopcode(struct aml_scope *);
a37 2
extern const char *aml_args(int opcode);
extern const char *aml_getname(uint8_t *);
d39 3
d49 1
a301 6
void
aml_disasm(struct aml_scope *scope, int lvl, 
    void (*dbprintf)(void *, const char *, ...), 
    void *arg);
void db_disprint(void *, const char *, ...);

a334 7
#if 0
	if (node && node->value && node->value->type == AML_OBJTYPE_METHOD) {
		db_aml_disasm(node, node->value->v_method.start,
		    node->value->v_method.end, -1, 0);
	} else
		db_printf("Not a valid method\n");
#endif
d347 1
d354 5
a358 3
		for (idx = 0; idx<root->nargs; idx++) {
			db_printf("  arg%d: ", idx);
			db_aml_showvalue(&root->args[idx]);
d360 4
a363 2
		for (idx = 0; root->locals && idx < AML_MAX_LOCAL; idx++) {
			if (root->locals[idx].type) {
d365 1
a365 2
				db_aml_showvalue(&root->locals[idx]);
			}
a367 45
}

void
db_aml_disline(uint8_t *pos, int depth, const char *fmt, ...)
{
	va_list ap;
	char line[128];

	db_printf("%.6x: ", aml_pc(pos));
	while (depth--)
		db_printf("  ");

	va_start(ap, fmt);
	vsnprintf(line, sizeof(line), fmt, ap);
	db_printf(line);
	va_end(ap);
}

void
db_aml_disint(struct aml_scope *scope, int opcode, int depth)
{
	switch (opcode) {
	case AML_ANYINT:
		db_aml_disasm(scope->node, scope->pos, scope->end, -1, depth);
		break;
	case AMLOP_BYTEPREFIX:
		db_aml_disline(scope->pos, depth, "0x%.2x\n",
		    *(uint8_t *)(scope->pos));
		scope->pos += 1;
		break;
	case AMLOP_WORDPREFIX:
		db_aml_disline(scope->pos, depth, "0x%.4x\n",
		    *(uint16_t *)(scope->pos));
		scope->pos += 2;
		break;
	case AMLOP_DWORDPREFIX:
		db_aml_disline(scope->pos, depth, "0x%.8x\n",
		    *(uint32_t *)(scope->pos));
		scope->pos += 4;
		break;
	case AMLOP_QWORDPREFIX:
		db_aml_disline(scope->pos, depth, "0x%.4llx\n",
		    *(uint64_t *)(scope->pos));
		scope->pos += 8;
		break;
a370 160
uint8_t *
db_aml_disasm(struct aml_node *root, uint8_t *start, uint8_t *end,
    int count, int depth)
{
	int idx, opcode, len, off=0;
	struct aml_scope *scope;
	uint8_t *name, *pos;
	const char *mnem, *args;
	struct aml_node *node;
	char *tmpstr;

	if (start == end)
		return end;

	scope = aml_pushscope(NULL, start, end, root);
	while (scope->pos < scope->end && count--) {
		pos = scope->pos;
		start = scope->pos;
		opcode = aml_parseopcode(scope);

		mnem = aml_mnem(opcode, scope->pos);
		args = aml_args(opcode);

		if (*args == 'p') {
			end = aml_parseend(scope);
			args++;
		}
		node = scope->node;
		if (*args == 'N') {
			name = aml_parsename(scope);
			node = aml_searchname(scope->node, name);
			db_aml_disline(pos, depth, "%s %s (%s)\n",
			    mnem, aml_getname(name), aml_nodename(node));
			args++;
		} else if (mnem[0] != '.') {
			db_aml_disline(pos, depth, "%s\n", mnem);
		}
		while (*args) {
			pos = scope->pos;
			switch (*args) {
			case 'k':
			case 'c':
			case 'D':
			case 'L':
			case 'A':
				break;
			case 'i':
			case 't':
			case 'S':
			case 'r':
				scope->pos = db_aml_disasm(node, scope->pos,
				    scope->end, 1, depth+1);
				break;
			case 'T':
			case 'M':
				scope->pos = db_aml_disasm(node, scope->pos,
				    end, -1, depth+1);
				break;
			case 'I':
				/* Special case: if */
				scope->pos = db_aml_disasm(node, scope->pos,
				    end, -1, depth+1);
				if (scope->pos >= scope->end)
					break;
				if (*scope->pos == AMLOP_ELSE) {
					++scope->pos;
					end = aml_parseend(scope);
					db_aml_disline(scope->pos, depth, "Else\n");
					scope->pos = db_aml_disasm(node, scope->pos,
					    end, -1, depth+1);
				}
				break;
			case 'N':
				name = aml_parsename(scope);
				db_aml_disline(pos, depth+1, "%s\n", aml_getname(name));
				break;
			case 'n':
				off = (opcode != AMLOP_NAMECHAR);
				name = aml_parsename(scope);
				node = aml_searchname(scope->node, name);
				db_aml_disline(pos, depth+off, "%s <%s>\n",
				    aml_getname(name), aml_nodename(node));

				if (!node || !node->value ||
				    node->value->type != AML_OBJTYPE_METHOD)
					break;

				/* Method calls */
				for (idx = 0;
				    idx < AML_METHOD_ARGCOUNT(node->value->v_method.flags);
				    idx++) {
					scope->pos = db_aml_disasm(node, scope->pos,
					    scope->end, 1, depth+1);
				}
				break;
			case 'b':
				off = (opcode != AMLOP_BYTEPREFIX);
				db_aml_disint(scope, AMLOP_BYTEPREFIX, depth+off);
				break;
			case 'w':
				off = (opcode != AMLOP_WORDPREFIX);
				db_aml_disint(scope, AMLOP_WORDPREFIX, depth+off);
				break;
			case 'd':
				off = (opcode != AMLOP_DWORDPREFIX);
				db_aml_disint(scope, AMLOP_DWORDPREFIX, depth+off);
				break;
			case 's':
				db_aml_disline(pos, depth, "\"%s\"\n", scope->pos);
				scope->pos += strlen(scope->pos)+1;
				break;
			case 'B':
				tmpstr = malloc(16 * 6 + 1, M_DEVBUF, M_WAITOK);
				for (idx = 0; idx < min(end-scope->pos, 8); idx++)
					snprintf(tmpstr+idx*6, 7, "0x%.2x, ",
					    scope->pos[idx]);
				db_aml_disline(pos, depth+1, "ByteList <%s>\n", tmpstr);
				free(tmpstr, M_DEVBUF);
				scope->pos = end;
				break;
			case 'F':
				off = 0;
				while (scope->pos < end) {
					len = 0;
					pos = scope->pos;
					switch (*scope->pos) {
					case 0x00: // reserved
						scope->pos++;
						len = aml_parselength(scope);
						db_aml_disline(pos, depth+1,
						    "Reserved\t%.4x,%.4x\n",
						    off, len);
						break;
					case 0x01: // attr
						db_aml_disline(pos, depth+1,
						    "Attr:%.2x,%.2x\n",
						    scope->pos[1], scope->pos[2]);
						scope->pos += 3;
						break;
					default:
						name = aml_parsename(scope);
						len = aml_parselength(scope);
						db_aml_disline(pos, depth+1,
						    "NamedField\t%.4x,%.4x %s\n",
						    off, len, aml_getname(name));
					}
					off += len;
				}
				scope->pos = end;
				break;
			default:
				db_printf("remaining args: '%s'\n", args);
			}
			args++;
		}
	}
	pos = scope->pos;
	aml_popscope(scope);
	return pos;
}
@


1.20
log
@Shrink acpi some more for floppies and while here re-enable acpi on the
floppies.  Fixes crazy sony vaio kettenis has.

tested by deraadt
ok deraadt jordan kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.19 2008/06/01 17:59:55 marco Exp $ */
d592 1
a592 1
#endif
@


1.19
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.17 2008/05/14 05:24:36 jordan Exp $ */
d33 1
d592 1
@


1.18
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.16 2007/11/12 21:58:14 deraadt Exp $ */
d168 7
a174 3

		db_aml_showvalue(value->v_field.ref1);
		db_aml_showvalue(value->v_field.ref2);
d177 1
a177 1
		db_printf("%s: pos=%.4x len=%.4x ",
d181 2
a182 6

		db_aml_dump(aml_bytelen(value->v_field.bitlen),
		    value->v_field.ref1->v_buffer +
		    aml_bytepos(value->v_field.bitpos));

		db_aml_showvalue(value->v_field.ref1);
d309 18
d336 13
d353 1
@


1.17
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d168 3
a170 7
		if (value->v_field.ref2)
			db_printf("  index: %.3x %s\n",
			    value->v_field.ref3,
			    aml_nodename(value->v_field.ref2->node));
		if (value->v_field.ref1)
			db_printf("  data: %s\n",
			    aml_nodename(value->v_field.ref1->node));
d173 1
a173 1
		db_printf("%s: pos=%.4x len=%.4x\n",
d177 6
a182 2
		db_printf("  buffer: %s\n", 
		    aml_nodename(value->v_field.ref1->node));
a308 18
aml_disasm(struct aml_scope *scope, int lvl, 
    void (*dbprintf)(void *, const char *, ...), 
    void *arg);
void db_disprint(void *, const char *, ...);

void db_disprint(void *arg, const char *fmt, ...)
{
	va_list ap;
	char    stre[64];
	
	va_start(ap,fmt);
	vsnprintf(stre, sizeof(stre), fmt, ap);
	va_end(ap);

	db_printf(stre);
}

void
a317 13
		struct aml_scope ns;

		memset(&ns, 0, sizeof(ns));
		ns.pos   = node->value->v_method.start;
		ns.end   = node->value->v_method.end;
		ns.node  = node;
		while (ns.pos < ns.end)
			aml_disasm(&ns, 0, db_disprint, 0);
	}
	else
		db_printf("Not a valid method\n");
#if 0
	if (node && node->value && node->value->type == AML_OBJTYPE_METHOD) {
a321 1
#endif
@


1.16
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.15 2007/02/06 18:56:31 jordan Exp $ */
d168 7
a174 3

		db_aml_showvalue(value->v_field.ref1);
		db_aml_showvalue(value->v_field.ref2);
d177 1
a177 1
		db_printf("%s: pos=%.4x len=%.4x ",
d181 2
a182 6

		db_aml_dump(aml_bytelen(value->v_field.bitlen),
		    value->v_field.ref1->v_buffer +
		    aml_bytepos(value->v_field.bitpos));

		db_aml_showvalue(value->v_field.ref1);
d309 18
d336 13
d353 1
@


1.15
log
@Added support for calling _OSI method
Display byte/word/string/nameref for aml_mnem function
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.14 2006/12/21 19:59:02 deraadt Exp $ */
d480 1
a480 2
					       aml_getname(name),
					       aml_nodename(node));
d488 2
a489 2
				     idx < AML_METHOD_ARGCOUNT(node->value->v_method.flags);
				     idx++) {
d516 1
a516 1
			        free(tmpstr, M_DEVBUF);
d530 1
a530 1
						     off, len);
d535 1
a535 1
						     scope->pos[1], scope->pos[2]);
@


1.14
log
@even more knf love
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.13 2006/12/21 11:29:58 deraadt Exp $ */
d45 1
a45 1
extern const char *aml_mnem(int opcode);
d162 1
a162 1
		    aml_mnem(value->v_field.type),
d174 1
a174 1
		    aml_mnem(value->v_field.type),
d239 1
a239 1
		return aml_mnem(val->v_field.type);
d419 1
a419 1
		mnem = aml_mnem(opcode);
@


1.13
log
@more knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.12 2006/11/29 22:39:04 miod Exp $ */
d488 2
a489 2
				for (idx=0;
				     idx<AML_METHOD_ARGCOUNT(node->value->v_method.flags);
d513 1
a513 1
				for (idx=0; idx<min(end-scope->pos, 8); idx++)
@


1.12
log
@Unused global variable.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.11 2006/10/24 19:01:48 jordan Exp $ */
d69 1
a69 1
	switch(id) {
d91 1
a91 1
	
a94 1

d173 1
a173 1
		db_printf("%s: pos=%.4x len=%.4x ", 
d178 2
a179 2
		db_aml_dump(aml_bytelen(value->v_field.bitlen), 
		    value->v_field.ref1->v_buffer + 
d238 1
a238 1
	case AML_OBJTYPE_BUFFERFIELD: 
d240 1
a240 1
	};
d248 1
a248 1
	while(node) {
d278 1
a278 2
	}
	while (t != tEOL);
d311 1
a311 1
	struct aml_node 		*node;
d318 2
a319 1
		db_aml_disasm(node, node->value->v_method.start, node->value->v_method.end, -1, 0);
d358 1
a358 1
	
d372 1
a372 1
	switch(opcode) {
d377 2
a378 1
		db_aml_disline(scope->pos, depth, "0x%.2x\n", *(uint8_t *)(scope->pos));
d382 2
a383 1
		db_aml_disline(scope->pos, depth, "0x%.4x\n", *(uint16_t *)(scope->pos));
d387 2
a388 2
		
					    db_aml_disline(scope->pos, depth, "0x%.8x\n", *(uint32_t *)(scope->pos));
d392 2
a393 1
		db_aml_disline(scope->pos, depth, "0x%.4llx\n", *(uint64_t *)(scope->pos));
d400 2
a401 2
db_aml_disasm(struct aml_node *root, uint8_t *start, uint8_t *end, 
	       int count, int depth)
d431 1
a431 3
				       mnem,
				       aml_getname(name),
				       aml_nodename(node));
d433 1
a433 2
		}
		else if (mnem[0] != '.') {
d449 2
a450 1
				scope->pos = db_aml_disasm(node, scope->pos, scope->end, 1, depth+1);
d454 2
a455 1
				scope->pos = db_aml_disasm(node, scope->pos, end, -1, depth+1);
d459 2
a460 1
				scope->pos = db_aml_disasm(node, scope->pos, end, -1, depth+1);
d467 2
a468 1
					scope->pos = db_aml_disasm(node, scope->pos, end, -1, depth+1);
d479 2
a480 2
				db_aml_disline(pos, depth+off, "%s <%s>\n", 
					       aml_getname(name), 
d483 2
a484 1
				if (!node || !node->value || node->value->type != AML_OBJTYPE_METHOD)
d488 1
a488 1
				for (idx=0; 
d491 2
a492 1
					scope->pos = db_aml_disasm(node, scope->pos, scope->end, 1, depth+1);
d514 2
a515 1
					snprintf(tmpstr+idx*6, 7, "0x%.2x, ", scope->pos[idx]);
d529 3
a531 2
						db_aml_disline(pos, depth+1, "Reserved\t%.4x,%.4x\n", 
							       off, len);
d534 3
a536 2
						db_aml_disline(pos, depth+1, "Attr:%.2x,%.2x\n", 
							       scope->pos[1], scope->pos[2]);
d542 3
a544 2
						db_aml_disline(pos, depth+1, "NamedField\t%.4x,%.4x %s\n",
							       off, len, aml_getname(name));
a559 1

@


1.11
log
@Added stack trace to aml_die+acpidebug
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.10 2006/10/19 07:02:20 jordan Exp $ */
a61 3

/* line buffer */
char			buf[128];
@


1.10
log
@Fixed AML debugger code to use new interface
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.9 2006/10/12 16:38:21 jordan Exp $ */
d334 23
a356 1
/* New Disasm Code */
d389 2
a390 1
		db_aml_disline(scope->pos, depth, "0x%.8x\n", *(uint32_t *)(scope->pos));
d554 1
@


1.9
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.8 2006/03/21 21:11:10 jordan Exp $ */
d25 1
d33 17
a51 1
int			db_aml_nodetype(struct aml_node *);
a52 3
void			db_aml_disasm(struct acpi_context *, int);
void			db_aml_disint(struct acpi_context *, int);
void			db_aml_disline(int, const char *, ...);
a53 1
void			db_aml_shownode(struct aml_node *);
a55 2
void			db_spaceit(int);
int 			db_aml_issimplearg(char);
a69 31
db_aml_fieldacc(int key)
{
	switch (key) {	
	case AML_FIELD_ANYACC: return "any";
	case AML_FIELD_BYTEACC: return "byte";
	case AML_FIELD_WORDACC: return "word";
	case AML_FIELD_DWORDACC: return "dword";
	case AML_FIELD_QWORDACC: return "qword";
	case AML_FIELD_BUFFERACC: return "buffer";
	}
	return "";
}

const char *
db_aml_fieldlock(int key)
{
	return (key ? "lock" : "nolock");
}

const char *
db_aml_fieldupdate(int key)
{
	switch (key) {
	case AML_FIELD_PRESERVE: return "preserve";
	case AML_FIELD_WRITEASONES: return "writeasones";
	case AML_FIELD_WRITEASZEROES: return "writeaszeroes";
	}
	return "";
}

const char *
d111 1
a111 1
		db_printf("node:%.8x name:%s ", value->node, value->node->name);
d113 1
a113 1
	switch (value->type) {
a121 1
	case AML_OBJTYPE_INTEGER+AML_STATIC:
a199 14
/* Output disassembled line */
void
db_spaceit(int len)
{
	while (len--)
		db_printf("..");
}

int
db_aml_nodetype(struct aml_node *node)
{
	return (node && node->value) ? node->value->type : -1;
}

a249 209
db_aml_disline(int level, const char *fmt, ...)
{
	va_list		ap;

	db_spaceit(level);

	va_start(ap, fmt);
	vsnprintf(buf, sizeof buf, fmt, ap);
	db_printf(buf);
	va_end(ap);
}

/* Output disassembled integer */
void
db_aml_disint(struct acpi_context *ctx, int type)
{
	int64_t		i1;

	i1 = aml_eparseint(ctx, type);
	db_aml_disline(0, "0x%.8llx", i1);
}

int
db_aml_issimplearg(char arg)
{
	switch (arg) {
	case AML_ARG_DATAOBJLIST:
	case AML_ARG_TERMOBJLIST:
	case AML_ARG_METHOD:
	case AML_ARG_BYTELIST:
	case AML_ARG_FIELDLIST:
	case '\0': // end of list
		return (0);
	}
	return (1);
}

/* Disassemble AML Opcode */
void
db_aml_disasm(struct acpi_context *ctx, int level)
{
	struct aml_opcode	*opc;
	uint8_t			*end;
	const char		*arg, *fname, *pfx;
	struct aml_node		*node;
	int			idx, len, narg;

	narg = 0;
	opc = aml_getopcode(ctx);
	arg = opc->args;
	pfx = "";
	if (opc->mnem[0] != '.') {
		/* Don't display implied opcodes */
		db_aml_disline(0, opc->mnem);
		pfx = "(";
		narg++;
	}
	if (*arg == AML_ARG_OBJLEN) {
		++arg;
		end = aml_eparselen(ctx);
	}
	if (*arg == AML_ARG_IMPBYTE)
		++arg;
	while (db_aml_issimplearg(*arg)) {
		narg++;
		db_aml_disline(0, pfx);
		switch (*arg) {
		case AML_ARG_BYTE: 
		case AML_ARG_WORD:
		case AML_ARG_DWORD:
		case AML_ARG_QWORD: 
			db_aml_disint(ctx, *arg);
			break;
		case AML_ARG_STRING: 
			db_aml_disline(0, ctx->pos);
			ctx->pos += strlen(ctx->pos) + 1;
			break;
		case AML_ARG_NAMESTRING:
			fname = aml_parse_name(ctx);
			db_aml_disline(0, fname);
			break;
		case AML_ARG_NAMEREF:
			fname = aml_parse_name(ctx);
			node = aml_searchname(ctx->scope, fname);
			db_aml_disline(0, fname);
			if (db_aml_nodetype(node) == AML_OBJTYPE_METHOD) {
				/* Parse method arguments */
				db_aml_disline(0, "(");
				for (idx = 0; idx < AML_METHOD_ARGCOUNT(node->value->v_method.flags); idx++) {
					db_aml_disline(0, idx ? ", " : "");
					db_aml_disasm(ctx, level + 1);
				}
				db_aml_disline(0, ")");
			}
			break;
		case AML_ARG_INTEGER:
		case AML_ARG_TERMOBJ:
		case AML_ARG_DATAOBJ:
		case AML_ARG_SIMPLENAME:
		case AML_ARG_SUPERNAME:
			db_aml_disasm(ctx, level + 1);
			break;
		case AML_ARG_FLAG:
			/* Flags */
			if (opc->opcode == AMLOP_METHOD) 
				db_aml_disint(ctx, AML_ARG_BYTE);
			else {
				idx = aml_eparseint(ctx, AML_ARG_BYTE);
				db_aml_disline(0,
				    "%s, %s, %s",
				    db_aml_fieldacc(AML_FIELD_ACCESS(idx)),
				    db_aml_fieldlock(AML_FIELD_LOCK(idx)),
				    db_aml_fieldupdate(AML_FIELD_UPDATE(idx)));
			}
			break;
		}
		pfx = ", ";
		arg++;
	}
	if (narg > 1)
		db_aml_disline(0, ")");

	/* Parse remaining argument */
	switch (*arg) {
	case AML_ARG_DATAOBJLIST:
	case AML_ARG_TERMOBJLIST:
	case AML_ARG_METHOD:
		db_aml_disline(0, " {\n");
		while (ctx->pos < end) {
			db_aml_disline(level + 1, "");
			db_aml_disasm(ctx, level + 1);
			db_aml_disline(0, "\n");
		}
		db_aml_disline(level, "}");
		break;
	case AML_ARG_BYTELIST:
		db_aml_disline(0, " { ");
		for (idx = 0; idx < end - ctx->pos; idx++)
			db_aml_disline(0, "%s0x%.2x", (idx ? ", " : ""),
			    ctx->pos[idx]);
		db_aml_disline(0, " }");
		ctx->pos = end;
		break;
	case AML_ARG_FIELDLIST:
		db_aml_disline(0, " {\n");
		for (idx = 0; ctx->pos < end; idx += len) {
			switch (*ctx->pos) {
			case AML_FIELD_RESERVED:
				ctx->pos++;
				len = aml_parse_length(ctx);
				db_aml_disline(level + 1, "Offset(%x),\n", (idx+len)>>3);
				break;
			case AML_FIELD_ATTR__:
				db_aml_disline(level + 1,
				    "-- attr %.2x %.2x", 
				    ctx->pos[1], ctx->pos[2]);
				ctx->pos += 3;
				len = 0;
				break;
			default:
				fname = aml_parse_name(ctx);
				len = aml_parse_length(ctx);
				db_aml_disline(level + 1, "%s, %d,\n", fname, len);
				break;
			}
		}
		db_aml_disline(level, "}");
		break;
	}
	if (level == 0)
		db_aml_disline(0, "\n");
}

void
db_aml_shownode(struct aml_node *node)
{
	db_printf(" opcode:%.4x  mnem:%s %s ",
	    node->opcode, aml_mnem(node->opcode), node->name ? node->name : "");

	switch(node->opcode) {
	case AMLOP_METHOD:
		break;
		
	case AMLOP_NAMECHAR:
		db_printf("%s", node->name);
		break;

	case AMLOP_FIELD:
	case AMLOP_BANKFIELD:
	case AMLOP_INDEXFIELD:
		break;
		
	case AMLOP_BYTEPREFIX:
		db_printf("byte: %.2x", node->value->v_integer);
		break;
	case AMLOP_WORDPREFIX:
		db_printf("word: %.4x", node->value->v_integer);
		break;
	case AMLOP_DWORDPREFIX:
		db_printf("dword: %.8x", node->value->v_integer);
		break;
	case AMLOP_STRINGPREFIX:
		db_printf("string: %s", node->value->v_string);
		break;
	}
	db_printf("\n");
}

void
a251 2
	int		i;

d253 2
a254 3
		db_printf(" %d ", node->depth);
		for(i = 0; i < node->depth; i++)
			db_printf("..");
a255 2
		db_aml_shownode(node);
		db_aml_walktree(node->child);
a315 3
	extern struct acpi_softc	*acpi_softc;
	struct acpi_softc 		*sc = acpi_softc;
	struct acpi_context 		*ctx;
a320 1
	ctx = acpi_alloccontext(sc, &aml_root, 0, NULL);
d323 1
a323 3
		ctx->pos = node->value->v_method.start;
		while (ctx->pos < node->value->v_method.end)
			db_aml_disasm(ctx, 0);
a325 2

	acpi_freecontext(ctx);
d333 20
a352 1
u_int8_t		*aml_eparselen(struct acpi_context *ctx)
d354 21
a374 1
	return 0;
d376 4
a379 2
struct acpi_context	*acpi_alloccontext(struct acpi_softc *s,
			    struct aml_node *n, int c, struct aml_value *v)
d381 149
a529 1
	return NULL;
@


1.8
log
@Disassembler now pretty prints AML code (like acpidump)
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.7 2006/03/09 05:38:12 jordan Exp $ */
d131 1
a131 4
		db_printf("node:%.8x ", value->node);

	if (value->name)
		db_printf("name:%s ", value->name);
d140 1
a140 2
		db_printf("nameref: %s %.8x\n", value->name,
			 value->v_objref.ref);
d142 1
a142 1
	case AML_OBJTYPE_STATICINT:
d145 1
a145 1
		    (value->type == AML_OBJTYPE_STATICINT) ? "(static)" : "");
d187 1
a187 1
		    aml_opname(value->v_field.type),
d199 1
a199 1
		    aml_opname(value->v_field.type),
d242 1
a242 1
	case AML_OBJTYPE_STATICINT:
d278 1
a278 1
		return aml_opname(val->v_field.type);
d462 1
a462 1
	    node->opcode, node->mnem, node->name ? node->name : "");
d469 1
a469 1
		db_printf("%s", node->value->name);
d589 9
@


1.7
log
@Used common aml_opname for debugger
Removed redundant code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.6 2006/03/09 04:41:11 marco Exp $ */
d37 2
a38 2
void			db_aml_disint(struct acpi_context *, int, int);
void			db_aml_disline(uint8_t *, int, const char *, ...);
d44 5
d59 31
d289 1
a289 1
db_aml_disline(uint8_t *pos, int level, const char *fmt, ...)
a292 1
	db_printf("%.4x %.2x ", pos - aml_root.start, level);
a298 2

	db_printf("\n");
d303 1
a303 1
db_aml_disint(struct acpi_context *ctx, int level, int type)
a304 1
	u_int8_t	*pos;
a306 1
	pos = ctx->pos;
d308 16
a323 1
	db_aml_disline(pos, level, "%c:0x%.8llx (%lld)", type, i1, i1);
d331 2
a332 2
	uint8_t			*end, *np;
	const char		*arg, *fname;
d334 1
a334 1
	int			idx, len;
d336 1
a336 6
#if 0
	/* if we want separators */
	if (level == 0) 
		db_printf("<<<<<<<<<<<<<<\n");
#endif
	np = ctx->pos;
d338 17
a354 3
	db_aml_disline(np, level, opc->mnem);
	for (arg = opc->args; *arg; arg++) {
		np = ctx->pos;
d360 1
a360 1
			db_aml_disint(ctx, level + 1, *arg);
d363 1
a363 1
			db_aml_disline(np, level + 1, ctx->pos);
d368 1
a368 1
			db_aml_disline(np, level + 1, fname);
d373 2
a374 3
			db_aml_disline(np, level + 1, "%s:%s", fname, 
			    node ? db_aml_objtype(node->value) : "none");
			if (db_aml_nodetype(node) == AML_OBJTYPE_METHOD)
d376 3
a378 1
				for (idx = 0; idx < AML_METHOD_ARGCOUNT(node->value->v_method.flags); idx++)
d380 3
a390 18
		case AML_ARG_DATAOBJLIST:
		case AML_ARG_TERMOBJLIST:
		case AML_ARG_METHOD:
			while (ctx->pos < end)
				db_aml_disasm(ctx, level + 1);
			break;
		case AML_ARG_BYTELIST:
			for (idx = 0; idx < end - ctx->pos - 7; idx += 8)
				db_aml_disline(np, level + 1, "buf %.4x: %.2x "
				    "%.2x %.2x %.2x %.2x %.2x %.2x %.2x", 
				    idx, ctx->pos[idx],
				    ctx->pos[idx + 1], 
				    ctx->pos[idx + 2], ctx->pos[idx + 3],
				    ctx->pos[idx + 4], ctx->pos[idx + 5], 
				    ctx->pos[idx + 6], ctx->pos[idx + 7]);

			ctx->pos = end;
			break;
d393 10
a402 13
			idx = aml_eparseint(ctx, AML_ARG_BYTE);
			if (opc->opcode == AMLOP_METHOD)
				db_aml_disline(np, level + 1,
				    "args:%d serialized:%d synclevel:%d",
				    AML_METHOD_ARGCOUNT(idx),
				    AML_METHOD_SERIALIZED(idx),
				    AML_METHOD_SYNCLEVEL(idx));
			else
				db_aml_disline(np, level + 1,
				    "acc:%d lock:%d update:%d",
				    AML_FIELD_ACCESS(idx),
				    AML_FIELD_LOCK(idx),
				    AML_FIELD_UPDATE(idx));
d404 49
a452 23
		case AML_ARG_FIELDLIST:
			for (idx = 0; ctx->pos < end; idx += len) {
				np = ctx->pos;
				switch (*ctx->pos) {
				case AML_FIELD_RESERVED:
					ctx->pos++;
					len = aml_parse_length(ctx);
					break;
				case AML_FIELD_ATTR__:
					db_aml_disline(np, level + 1,
					    "-- attr %.2x %.2x", 
					    ctx->pos[1], ctx->pos[2]);
					ctx->pos += 3;
					len = 0;
					break;
				default:
					fname = aml_parse_name(ctx);
					len = aml_parse_length(ctx);
					db_aml_disline(np, level + 1,
					    "pos:%.4x len:%.4x name:%s", 
					    idx, len, fname);
					break;
				}
a453 4
			break;
		case AML_ARG_OBJLEN:
			end = aml_eparselen(ctx);
			break;
d455 2
d458 2
a459 5
#if 0
	/* if we want separators */
	if (level == 0) 
		db_printf(">>>>>>>>>>>>>>\n");
#endif
@


1.6
log
@One more KNF nit.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.5 2006/03/09 03:52:19 marco Exp $ */
a32 1
const char		*db_aml_opname(int);
a35 1
struct aml_opcode	*db_findem(int);
a46 7
/* Perfect hash values for AML opcodes */
#define HASH_VAL     11
#define HASH_SIZE    204
#define HASH_KEY(v)  (((v) * HASH_VAL) % HASH_SIZE)

struct aml_opcode	*htab[HASH_SIZE];

d155 1
a155 1
		    db_aml_opname(value->v_field.type),
d167 1
a167 1
		    db_aml_opname(value->v_field.type),
a196 16
struct aml_opcode
*db_findem(int opcode)
{
	int		key, cnt;

	cnt = 0;
	key = HASH_KEY(opcode);

	while (htab[key] != NULL && htab[key]->opcode != opcode) {
		key = (key + 1) % HASH_SIZE;
		cnt++;
	}

	return (htab[key]);
}

a203 10
db_aml_opname(int opcode)
{
	struct aml_opcode	*opc;

	opc = db_findem(opcode);

	return (opc ? opc->mnem : "");
}

const char *
d246 1
a246 1
		return db_aml_opname(val->v_field.type);
@


1.5
log
@Pretty.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.4 2006/03/09 03:40:31 marco Exp $ */
d32 6
a41 1
void			db_aml_walktree(struct aml_node *);
d44 1
a45 6
const char		*db_aml_objtype(struct aml_value *);
const char		*db_aml_opname(int);
const char		*db_opregion(int);
struct aml_opcode	*db_findem(int);
int			db_aml_nodetype(struct aml_node *);
int			db_parse_name(void);
@


1.4
log
@Create separate function to parse name + scope.  Should shave some bytes of
and makes code more readable.

ok jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.3 2006/03/08 21:04:18 marco Exp $ */
d89 1
a89 1
	for (idx = 0; idx < len; idx++) {
d91 1
a91 1
	}
d98 1
a98 1
	int idx;
d202 1
a202 1
	while(len--) {
a203 1
	}
d209 1
a209 1
	int			key, cnt;
d290 1
a290 1
	va_list			ap;
d307 2
a308 2
	u_int8_t		*pos;
	int64_t			i1;
d374 1
a374 1
			for (idx = 0; idx < end - ctx->pos - 7; idx += 8) {
d382 1
a382 1
			}
d476 1
a476 1
	int			i;
d492 1
a492 1
	int				t, rv = 1;
d530 1
a530 1
	struct aml_node 		*node;
@


1.3
log
@Add showval to ddb interface.  Now we can pretty much debug anything AML
from ddb.  Very useful.

Help jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.2 2006/03/07 23:13:28 marco Exp $ */
d45 1
d490 2
a491 3
/* ddb interface */
void
db_acpi_showval(db_expr_t addr, int haddr, db_expr_t count, char *modif)
d493 1
a493 2
	struct aml_node 		*node;
	int				t;
d520 2
d524 11
a540 3

error:
	db_flush_lex();
a549 1
	int				t;
d551 2
a552 27
	memset(scope, 0, sizeof scope);
	do {
		t = db_read_token();
		if (t == tIDENT) {
			if (strlcat(scope, db_tok_string, sizeof scope) >=
			    sizeof scope) {
				printf("Input too long\n");
				goto error;
			}
			t = db_read_token();
			if (t == tDOT)
				if (strlcat(scope, ".", sizeof scope) >=
				    sizeof scope) {
					printf("Input too long 2\n");
					goto error;
				}
		}
	}
	while (t != tEOL);

	if (!strlen(scope)) {
		db_printf("Invalid input\n");
		goto error;
	}

	/* get rid of the rest of input */
	db_flush_lex();
a563 3

error:
	db_flush_lex();
a569 1

@


1.2
log
@Add "disasm" code for ddb.  With this one can disassemble AML code from DDB.
example : "machine acpi disasm \\_SB_.BIF_" dumps the battery AML on my laptop.

Disasm code was written by jordan.  Help from miod on ddb lexer magic.
ok jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidebug.c,v 1.1 2006/03/05 14:46:46 marco Exp $ */
d32 4
d38 1
a38 3
void			db_aml_disline(uint8_t *, int, const char *, ...);
void			db_aml_disint(struct acpi_context *, int, int);
void			db_aml_disasm(struct acpi_context *, int);
d42 1
d61 136
d491 44
d577 3
a579 1
	}
@


1.1
log
@Hook acpi to ddb since we need to be able to do some live debugging.

Lots and lots of help from miod@@ and deraadt@@
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d21 2
d32 266
a297 2
void db_aml_walktree(struct aml_node *);
void db_aml_shownode(struct aml_node *);
d337 1
a337 1
	int i;
d352 50
d404 1
a404 1
	extern struct aml_node	aml_root;
a405 1
	db_aml_walktree(aml_root.child);
@

