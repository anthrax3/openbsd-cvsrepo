head	1.73;
access;
symbols
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.71.0.2
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.62.0.6
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.8
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.61.0.4
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.60.0.2
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.4
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.57.0.2
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.73
date	2016.10.25.06.48.58;	author pirofti;	state Exp;
branches;
next	1.72;
commitid	Z8xhqpkgqCmi8yVl;

1.72
date	2016.09.02.13.59.51;	author pirofti;	state Exp;
branches;
next	1.71;
commitid	QA6Gb7VSg6HVRahN;

1.71
date	2016.05.08.00.03.12;	author kettenis;	state Exp;
branches;
next	1.70;
commitid	4qnWyJaV1V5yKgSM;

1.70
date	2016.03.30.09.56.10;	author kettenis;	state Exp;
branches;
next	1.69;
commitid	m1mxeGggcTdEuQ2L;

1.69
date	2016.03.28.17.22.41;	author kettenis;	state Exp;
branches;
next	1.68;
commitid	ajXxurppeMVED21n;

1.68
date	2016.03.14.06.37.31;	author guenther;	state Exp;
branches;
next	1.67;
commitid	uE59hV3t3wI6I7pN;

1.67
date	2016.01.13.23.11.22;	author kettenis;	state Exp;
branches;
next	1.66;
commitid	qiuZZwVp5JJiWr2w;

1.66
date	2016.01.13.10.11.43;	author kettenis;	state Exp;
branches;
next	1.65;
commitid	pxfnafrxfvmKaTyi;

1.65
date	2016.01.09.10.50.43;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	tiW3SsgGkaJX0ni9;

1.64
date	2015.06.13.21.41.42;	author guenther;	state Exp;
branches;
next	1.63;
commitid	niRu91s4TwItA66c;

1.63
date	2015.03.16.20.31.46;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	UF5MXB4OGf08laCK;

1.62
date	2014.05.02.14.10.15;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.18.04.07.06;	author pirofti;	state Exp;
branches;
next	1.60;

1.60
date	2012.07.16.15.27.11;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.03.03.54.19;	author jordan;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.18.00.40.26;	author jordan;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.08.05.05.09;	author jordan;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.55;

1.55
date	2010.08.04.18.11.56;	author jordan;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.22.14.19.47;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.22.13.46.42;	author jordan;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.21.15.07.40;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.20.05.49.53;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.01.01.39.39;	author jordan;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.04.22.50.11;	author jordan;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.21.22.05.01;	author jordan;	state Exp;
branches;
next	1.44;

1.44
date	2009.06.01.22.36.12;	author jordan;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.10.20.36.10;	author jordan;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.07.18.02.20;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.04.18.48.04;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.29.18.29.43;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.25.19.12.28;	author jordan;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.13.00.04.33;	author jordan;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.12.20.36.50;	author jordan;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.06.09.15.32;	author marco;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.32;

1.32
date	2008.05.13.09.05.06;	author jordan;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.14.20.31.31;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.08.20.27.20;	author canacar;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.13.03.43.22;	author weingart;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.11.02.51.11;	author jordan;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.22.06.22.31;	author jordan;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.18.02.25.05;	author jordan;	state Exp;
branches;
next	1.25;

1.25
date	2007.02.06.18.56.31;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.27.18.30.38;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.27.15.17.37;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.25.18.24.54;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.24.19.01.48;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.19.07.02.20;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.19.01.06.54;	author jordan;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.12.23.16.11;	author jordan;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.09.05.38.12;	author jordan;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.08.04.03.21;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.07.23.13.28;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.05.14.46.46;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.22.19.29.24;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.19.21.32.30;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.19.04.50.47;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.16.21.11.13;	author jordan;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.03.23.55.47;	author jordan;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.20.20.20.28;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.28.03.04.56;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.16.00.08.53;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.13.07.22.18;	author marco;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Add the resource index to aml_parse_resource() callback function.

This is needed by an upcoming acpiec commit that handles machines breaking
the current ACPI specifications.

Change suggested by and ok kettenis@@, guenther@@
@
text
@/* $OpenBSD: dsdt.h,v 1.72 2016/09/02 13:59:51 pirofti Exp $ */
/*
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef __DEV_ACPI_DSDT_H__
#define __DEV_ACPI_DSDT_H__

struct aml_scope {
	struct acpi_softc	*sc;
	uint8_t			*pos;
	uint8_t			*start;
	uint8_t			*end;
	struct aml_node		*node;
	struct aml_scope	*parent;
	struct aml_value	*locals;
	struct aml_value	*args;
	struct aml_value	*retv;
	int			type;
	int			depth;
};


struct aml_opcode {
	u_int32_t		opcode;
	const char		*mnem;
	const char		*args;
};

const char		*aml_eisaid(u_int32_t);
const char		*aml_mnem(int, uint8_t *);
int64_t			aml_val2int(struct aml_value *);
struct aml_node		*aml_searchname(struct aml_node *, const void *);
struct aml_node		*aml_searchrel(struct aml_node *, const void *);

struct aml_value	*aml_getstack(struct aml_scope *, int);
struct aml_value	*aml_allocvalue(int, int64_t, const void *);
void			aml_freevalue(struct aml_value *);
void			aml_notify(struct aml_node *, int);
void			aml_showvalue(struct aml_value *);
void			aml_walkroot(void);
void			aml_walktree(struct aml_node *);

void			aml_find_node(struct aml_node *, const char *,
			    int (*)(struct aml_node *, void *), void *);
int			acpi_parse_aml(struct acpi_softc *, u_int8_t *,
			    u_int32_t);
void			aml_register_notify(struct aml_node *, const char *,
			    int (*)(struct aml_node *, int, void *), void *,
			    int);

int			aml_evalnode(struct acpi_softc *, struct aml_node *,
			    int, struct aml_value *, struct aml_value *);
int			aml_node_setval(struct acpi_softc *, struct aml_node *,
			    int64_t);
int			aml_evalname(struct acpi_softc *, struct aml_node *,
			    const char *, int, struct aml_value *,
			    struct aml_value *);
int			aml_evalinteger(struct acpi_softc *, struct aml_node *,
                            const char *, int, struct aml_value *, int64_t *);

void			aml_create_defaultobjects(void);

const char		*aml_nodename(struct aml_node *);

#define SRT_IRQ2		0x22
#define SRT_IRQ3		0x23
#define SRT_DMA			0x2A
#define SRT_STARTDEP0		0x30
#define SRT_STARTDEP1		0x31
#define SRT_ENDDEP		0x38
#define SRT_IOPORT		0x47
#define SRT_FIXEDPORT		0x4B
#define SRT_ENDTAG		0x79

#define SR_IRQ			0x04
#define SR_DMA			0x05
#define SR_STARTDEP		0x06
#define SR_ENDDEP		0x07
#define SR_IOPORT		0x08
#define SR_FIXEDPORT		0x09
#define SR_ENDTAG		0x0F
/* byte zero of small resources combines the tag above a length [1..7] */
#define	SR_TAG(tag,len)		((tag << 3) + (len))

#define LR_MEM24		0x81
#define LR_GENREGISTER		0x82
#define LR_MEM32		0x85
#define LR_MEM32FIXED		0x86
#define LR_DWORD		0x87
#define LR_WORD			0x88
#define LR_EXTIRQ		0x89
#define LR_QWORD		0x8A
#define LR_GPIO			0x8C
#define LR_SERBUS		0x8E

#define __amlflagbit(v,s,l)
union acpi_resource {
	struct {
		uint8_t  typecode;
		uint16_t length;
	}  __packed hdr;

	/* Small resource structures
	 * format of typecode is: tttttlll, t = type, l = length
	 */
	struct {
		uint8_t  typecode;
		uint16_t irq_mask;
		uint8_t  irq_flags;
#define SR_IRQ_SHR		(1L << 4)
#define SR_IRQ_POLARITY		(1L << 3)
#define SR_IRQ_MODE		(1L << 0)
	}  __packed sr_irq;
	struct {
		uint8_t  typecode;
		uint8_t  channel;
		uint8_t  flags;
#define SR_DMA_TYP_MASK		0x3
#define SR_DMA_TYP_SHIFT 	5
#define SR_DMA_BM		(1L << 2)
#define SR_DMA_SIZE_MASK	0x3
#define SR_DMA_SIZE_SHIFT	0
	}  __packed sr_dma;
	struct {
		uint8_t  typecode;
		uint8_t  flags;
#define SR_IOPORT_DEC		(1L << 0)
		uint16_t _min;
		uint16_t _max;
		uint8_t  _aln;
		uint8_t  _len;
	}  __packed sr_ioport;
	struct {
		uint8_t  typecode;
		uint16_t _bas;
		uint8_t  _len;
	}  __packed sr_fioport;

	/* Large resource structures */
	struct {
		uint8_t  typecode;
		uint16_t length;
		uint8_t  _info;
		uint16_t _min;
		uint16_t _max;
		uint16_t _aln;
		uint16_t _len;
	}  __packed lr_m24;
	struct {
		uint8_t  typecode;
		uint16_t length;
		uint8_t  _info;
		uint32_t _min;
		uint32_t _max;
		uint32_t _aln;
		uint32_t _len;
	}  __packed lr_m32;
	struct {
		uint8_t  typecode;
		uint16_t length;
		uint8_t  _info;
		uint32_t _bas;
		uint32_t _len;
	}  __packed lr_m32fixed;
	struct {
		uint8_t  typecode;
		uint16_t length;
		uint8_t  flags;
#define LR_EXTIRQ_SHR		(1L << 3)
#define LR_EXTIRQ_POLARITY	(1L << 2)
#define LR_EXTIRQ_MODE		(1L << 1)
		uint8_t  irq_count;
		uint32_t irq[1];
	} __packed lr_extirq;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		type;
		uint8_t		flags;
		uint8_t		tflags;
		uint16_t	_gra;
		uint16_t	_min;
		uint16_t	_max;
		uint16_t	_tra;
		uint16_t	_len;
		uint8_t		src_index;
		char		src[1];
	} __packed lr_word;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		type;
		uint8_t		flags;
		uint8_t		tflags;
		uint32_t	_gra;
		uint32_t	_min;
		uint32_t	_max;
		uint32_t	_tra;
		uint32_t	_len;
		uint8_t		src_index;
		char		src[1];
	} __packed lr_dword;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		type;
		uint8_t		flags;
		uint8_t		tflags;
		uint64_t	_gra;
		uint64_t	_min;
		uint64_t	_max;
		uint64_t	_tra;
		uint64_t	_len;
		uint8_t		src_index;
		char		src[1];
	} __packed lr_qword;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		revid;
		uint8_t		type;
#define LR_GPIO_INT	0x00
#define LR_GPIO_IO	0x01
		uint16_t	flags;
		uint16_t	tflags;
#define LR_GPIO_SHR		(3L << 3)
#define LR_GPIO_POLARITY	(3L << 1)
#define  LR_GPIO_ACTHI		(0L << 1)
#define  LR_GPIO_ACTLO		(1L << 1)
#define  LR_GPIO_ACTBOTH	(2L << 1)
#define LR_GPIO_MODE		(1L << 0)
#define  LR_GPIO_LEVEL		(0L << 0)
#define  LR_GPIO_EDGE		(1L << 0)
		uint8_t		_ppi;
		uint16_t	_drs;
		uint16_t	_dbt;
		uint16_t	pin_off;
		uint8_t		residx;
		uint16_t	res_off;
		uint16_t	vd_off;
		uint16_t	vd_len;
	} __packed lr_gpio;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		revid;
		uint8_t		residx;
		uint8_t		type;
#define LR_SERBUS_I2C	1
		uint8_t		flags;
		uint16_t	tflags;
		uint8_t		trevid;
		uint16_t	tlength;
		uint8_t		tdata[1];
	} __packed lr_serbus;
	struct {
		uint8_t		typecode;
		uint16_t	length;
		uint8_t		revid;
		uint8_t		residx;
		uint8_t		type;
		uint8_t		flags;
		uint16_t	tflags;
		uint8_t		trevid;
		uint16_t	tlength;
		uint32_t	_spe;
		uint16_t	_adr;
		uint8_t		vdata[1];
	} __packed lr_i2cbus;
	uint8_t		pad[64];
} __packed;

#define AML_CRSTYPE(x)	((x)->hdr.typecode & 0x80 ? \
			    (x)->hdr.typecode : (x)->hdr.typecode >> 3)
#define AML_CRSLEN(x)	((x)->hdr.typecode & 0x80 ? \
			    3+(x)->hdr.length : 1+((x)->hdr.typecode & 0x7))

int			aml_print_resource(union acpi_resource *, void *);
int			aml_parse_resource(struct aml_value *,
			    int (*)(int, union acpi_resource *, void *),
			    void *);

#define ACPI_E_NOERROR   0x00
#define ACPI_E_BADVALUE  0x01

#define AML_MAX_ARG	 7
#define AML_MAX_LOCAL	 8

#define AML_WALK_PRE 0x00
#define AML_WALK_POST 0x01

void			aml_walknodes(struct aml_node *, int,
			    int (*)(struct aml_node *, void *), void *);

void			aml_postparse(void);

void			aml_hashopcodes(void);

void			aml_foreachpkg(struct aml_value *, int,
			    void (*fn)(struct aml_value *, void *), void *);

const char		*aml_val_to_string(const struct aml_value *);

void			aml_disasm(struct aml_scope *scope, int lvl,
			    void (*dbprintf)(void *, const char *, ...),
			    void *arg);
int			aml_getpci(struct aml_node *, int64_t *);
int			aml_evalhid(struct aml_node *, struct aml_value *);

int			acpi_walkmem(int, const char *);

#define aml_get8(p)    *(uint8_t *)(p)
#define aml_get16(p)   *(uint16_t *)(p)
#define aml_get32(p)   *(uint32_t *)(p)
#define aml_get64(p)   *(uint64_t *)(p)

union amlpci_t {
	uint64_t addr;
	struct {
		uint16_t reg;
		uint16_t fun;
		uint16_t dev;
		uint16_t bus;
	};
};
int			aml_rdpciaddr(struct aml_node *pcidev,
			    union amlpci_t *);

#ifndef SMALL_KERNEL
void			acpi_getdevlist(struct acpi_devlist_head *,
			    struct aml_node *, struct aml_value *, int);
#endif
void			aml_notify_dev(const char *, int);

void			acpi_freedevlist(struct acpi_devlist_head *);

void			acpi_glk_enter(void);
void			acpi_glk_leave(void);

#endif /* __DEV_ACPI_DSDT_H__ */
@


1.72
log
@Remove unused argument in aml_showvalue().


The second argument of aml_showvalue() was probably supposed to set
the verbosity level through dnprintf() but in fact it does nothing.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.71 2016/05/08 00:03:12 kettenis Exp $ */
d293 2
a294 1
			    int (*)(union acpi_resource *, void *), void *);
@


1.71
log
@Add macros for interrupt trigger mode as encoded in GPIO resources.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.70 2016/03/30 09:56:10 kettenis Exp $ */
d52 1
a52 1
void			aml_showvalue(struct aml_value *, int);
@


1.70
log
@Add support for gpio-based interrupts.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.69 2016/03/28 17:22:41 kettenis Exp $ */
d245 2
@


1.69
log
@Add definitions for GPIO resources.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.68 2016/03/14 06:37:31 guenther Exp $ */
d239 6
@


1.68
log
@Correct the value of SRT_ENDTAG: it was documented incorrectly in early
ACPI specs.  With the correct value, it can now be used in a few places
instead of hardcoding 0x79.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.67 2016/01/13 23:11:22 kettenis Exp $ */
d106 1
d230 18
@


1.67
log
@Change aml_find_node() such that it only walks down the tree and doesn't
traverse sideways.  This seems to be what all callersexpect it to do, and
fixes a bug in dwiic(4) where it would try to access i2c devices on busses
they're not attached to.

If there is any fallout from this change, the right thing to do is probably
to make sure callers pass the right node.

While there, change the return type to void, as the return value was useless
and none of the callers looked at it.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.66 2016/01/13 10:11:43 kettenis Exp $ */
d86 1
a86 1
#define SRT_ENDTAG		0x78
@


1.66
log
@Add data structures and defines for Generic and I2C Serial Bus Connection
descriptors.

ok jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.65 2016/01/09 10:50:43 kettenis Exp $ */
d56 1
a56 1
int			aml_find_node(struct aml_node *, const char *,
@


1.65
log
@Rename LR_24BIT, LR_32BIT and LR_32BITFIXED to LR_MEM24, LR_MEM32 and
LR_MEM32FIXED to better match the names used in the specification.
Add lr_m32fixed to union acpi_resource.

ok jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.64 2015/06/13 21:41:42 guenther Exp $ */
d106 1
d229 27
@


1.64
log
@Parse _CST objects and use the C-states they describe when they're sane.

testing by many, particularly krw@@ and jcs@@
tweaks by kettenis@@
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.63 2015/03/16 20:31:46 deraadt Exp $ */
d98 1
a98 1
#define LR_24BIT		0x81
d100 2
a101 2
#define LR_32BIT		0x85
#define LR_32BITFIXED		0x86
d169 7
@


1.63
log
@Reduce use of SMALL_KERNEL in acpi, bringing acpiec driver and more gpe
handling into RAMDISK.  This is now possible because the install media
has ample room.  The goal is to reduce special cases where we may be
skipping (unknown) important operations...
ok mlarkin kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.62 2014/05/02 14:10:15 kettenis Exp $ */
d95 2
@


1.62
log
@Make acpiprt(4) handle interrupts with non-standard polarity and trigger mode
correctly.

Tested by nobody.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.61 2013/01/18 04:07:06 pirofti Exp $ */
d280 1
a281 1
#endif
@


1.61
log
@acpi: Add global lock enter and leave routines.

I think this diff is the way to go if we want to have proper locking in
our acpi drivers. This doesn't hook onto anything from the kernel and
is just building framework towards locking.

Okay mlarkin@@, kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.60 2012/07/16 15:27:11 deraadt Exp $ */
d171 3
@


1.60
log
@Add shorter form function aml_node_setval() for setting an int
on an AML node. Shortens the tricky code in a lot of callers.
Earlier version seen by pirofti and kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.59 2011/06/03 03:54:19 jordan Exp $ */
d281 3
@


1.59
log
@Remove unused structure members. Add depth field.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.58 2011/04/18 00:40:26 jordan Exp $ */
d65 3
a67 1
			    int , struct aml_value *, struct aml_value *);
@


1.58
log
@Change all aml_xfoo to aml_foo names now that parser is stable
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.57 2011/01/08 05:05:09 jordan Exp $ */
d24 1
a29 2
	int			nargs;
	int			flags;
a30 1
	uint8_t			*start;
d32 1
@


1.57
log
@Removed unused structure member
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.56 2011/01/02 04:56:57 jordan Exp $ */
d251 1
a251 1
int			aml_xgetpci(struct aml_node *, int64_t *);
@


1.56
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.55 2010/08/04 18:11:56 jordan Exp $ */
a33 1
	int			rep;
@


1.55
log
@Remove unused code, conditional in fixup node was never true
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.54 2010/07/22 14:19:47 deraadt Exp $ */
a276 1
void			acpi_poll_notify(void);
@


1.54
log
@pretty large cleanup of SMALL_KERNEL
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.53 2010/07/22 13:46:42 jordan Exp $ */
a64 2

u_int64_t		aml_getpciaddr(struct acpi_softc *, struct aml_node *);
@


1.53
log
@Remove unused function prototypes
Add flags and type codes for AML resources
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.52 2010/07/21 19:35:15 deraadt Exp $ */
a53 1
void			aml_notify_dev(const char *, int);
a242 1
void			acpi_poll_notify(void);
a250 1
int			valid_acpihdr(void *, int, const char *);
d276 1
d279 4
@


1.52
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.51 2010/07/21 15:07:40 deraadt Exp $ */
d34 1
a50 2
struct aml_value	*aml_allocint(uint64_t);
struct aml_value	*aml_allocstr(const char *);
d81 10
d122 3
d130 5
d139 1
@


1.51
log
@clean up a pile of prototypes and shred some macros which were just covering
for ones everyone knows better
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.50 2010/07/20 05:49:53 deraadt Exp $ */
d49 1
a49 1
struct aml_value 	*aml_getstack(struct aml_scope *, int);
d236 2
a237 2
void			aml_disasm(struct aml_scope *scope, int lvl, 
			    void (*dbprintf)(void *, const char *, ...), 
@


1.50
log
@remove prototypes for functions that do not exist; ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.49 2010/07/08 20:56:31 jordan Exp $ */
a218 5
/* XXX: endian macros */
#define aml_letohost16(x) letoh16(x)
#define aml_letohost32(x) letoh32(x)
#define aml_letohost64(x) letoh64(x)

d230 2
a231 2
void	aml_foreachpkg(struct aml_value *, int,
	    void (*fn)(struct aml_value *, void *), void *);
d233 1
a233 1
const char *aml_val_to_string(const struct aml_value *);
d235 6
a240 6
int valid_acpihdr(void *, int, const char *);
void aml_disasm(struct aml_scope *scope, int lvl, 
        void (*dbprintf)(void *, const char *, ...), 
    	void *arg);
int aml_xgetpci(struct aml_node *, int64_t *);
int aml_evalhid(struct aml_node *, struct aml_value *);
d242 1
a242 1
int acpi_walkmem(int, const char *);
d249 1
a249 2
union amlpci_t
{
d258 2
a259 1
int aml_rdpciaddr(struct aml_node *pcidev, union amlpci_t *);
d261 3
a263 3
void acpi_getdevlist(struct acpi_devlist_head *, struct aml_node *,
	struct aml_value *, int);
void acpi_freedevlist(struct acpi_devlist_head *);
@


1.49
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.47 2010/07/01 01:39:39 jordan Exp $ */
a63 2
int			aml_eval_object(struct acpi_softc *, struct aml_node *,
			    struct aml_value *, int, struct aml_value *);
a77 1
void			aml_fixup_dsdt(u_int8_t *, u_int8_t *, int);
a78 3

int			acpi_mutex_acquire(struct aml_value *, int);
void			acpi_mutex_release(struct aml_value *);
@


1.48
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.46 2009/09/04 22:50:11 jordan Exp $ */
d216 1
a216 1
int			aml_parse_resource(int, uint8_t *,
@


1.47
log
@Simplified aml_parse_resource call, cleanup code
ok marco
@
text
@d216 1
a216 1
int			aml_parse_resource(struct aml_value *,
@


1.46
log
@Add common framework for storing device lists
Useful for acpitz, acpipwrres, etc.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.45 2009/08/21 22:05:01 jordan Exp $ */
d216 1
a216 1
int			aml_parse_resource(int, uint8_t *,
@


1.45
log
@Remove unused code
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.44 2009/06/01 22:36:12 jordan Exp $ */
d271 4
@


1.44
log
@Remove dead/unused code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.43 2009/03/10 20:36:10 jordan Exp $ */
a20 6
struct aml_vallist {
	struct aml_value *obj;
	int nobj;
	struct aml_vallist *next;
};

a25 1
	struct aml_vallist	*tmpvals;
@


1.43
log
@Added sensor devices for Thinkpad (temp+fan)
Exported aml_evalinteger method
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.42 2008/10/07 18:02:20 kettenis Exp $ */
d258 1
d266 12
@


1.42
log
@Fix memory leak bug during scope evaluation (now without introducing a bug
in evaluation of the Return() operator).  Based jordan@@'s diff from rev. 1.133.

ok jordan@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.41 2008/10/04 18:48:04 kettenis Exp $ */
d84 2
@


1.41
log
@Commit cleanup part of the diff that was backed out in the previous commit
(removal of unused functions).

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.40 2008/09/29 18:29:43 deraadt Exp $ */
d256 2
@


1.40
log
@back out previous commit, since it is breaking a variety of machines
(Supermicro X5DLR, and seperately, see pr 5941)
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.38 2008/06/13 00:04:33 jordan Exp $ */
a50 1
const char		*aml_args(int);
@


1.39
log
@Fixed memory leak bug during scope evaluation
Removed unused functions
ok marco@@
@
text
@d51 1
a92 1
int aml_evalhid(struct aml_node *, struct aml_value *);
a256 2

int acpi_walkmem(int, const char *);
@


1.38
log
@Cleanup, remove old/unused functions
ok @@canacaR
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.37 2008/06/12 20:36:50 jordan Exp $ */
a50 1
const char		*aml_args(int);
d92 1
d257 2
@


1.37
log
@Removed old AML disassembler code
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.36 2008/06/06 09:15:32 marco Exp $ */
a55 2
struct aml_node		*aml_createname(struct aml_node *, const void *,
			    struct aml_value *);
@


1.36
log
@Shrink acpi some more for floppies and while here re-enable acpi on the
floppies.  Fixes crazy sony vaio kettenis has.

tested by deraadt
ok deraadt jordan kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.35 2008/06/01 17:59:55 marco Exp $ */
d59 1
@


1.35
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.33 2008/05/14 05:24:36 jordan Exp $ */
a47 2
	struct aml_value	*(*handler)(struct aml_scope *, int,
				    struct aml_value*);
@


1.34
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.32 2008/05/13 09:05:06 jordan Exp $ */
d57 1
@


1.33
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@a56 1
struct aml_node		*aml_searchrel(struct aml_node *, const void *);
@


1.32
log
@Adding changes for new parser
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.31 2007/11/14 20:31:31 deraadt Exp $ */
d57 1
@


1.31
log
@shrink floppy build by knocking out some unused bits of code; seen by canacar
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.30 2007/11/08 20:27:20 canacar Exp $ */
d37 4
d67 2
d253 11
@


1.30
log
@convert the value to a string instead of using aml_val2str()
which returns invalid pointers if the value is not a string, causing
acpibat to panic, as reported by mbalmer@@ and Alexey Suslikov.
tested by Alexey Suslikov, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.29 2007/09/13 03:43:22 weingart Exp $ */
d28 9
a36 9
	struct acpi_softc  *sc;
	uint8_t		   *pos;
	uint8_t            *end;
	struct aml_node    *node;
	struct aml_vallist *tmpvals;
	struct aml_scope   *parent;
	struct aml_value   *locals;
	struct aml_value   *args;
	int                 nargs;
d49 1
a49 1
const char              *aml_args(int);
d53 1
a53 1
struct aml_node         *aml_createname(struct aml_node *, const void *,
a62 2
void			aml_walkroot(void);
void			aml_walktree(struct aml_node *);
d90 16
a105 16
#define SR_IRQ                  0x04
#define SR_DMA                  0x05
#define SR_STARTDEP             0x06
#define SR_ENDDEP               0x07
#define SR_IOPORT               0x08
#define SR_FIXEDPORT            0x09
#define SR_ENDTAG               0x0F

#define LR_24BIT                0x81
#define LR_GENREGISTER          0x82
#define LR_32BIT                0x85
#define LR_32BITFIXED           0x86
#define LR_DWORD                0x87
#define LR_WORD                 0x88
#define LR_EXTIRQ               0x89
#define LR_QWORD                0x8A
d167 1
a167 1
  	struct {
d181 1
a181 1
  	struct {
d195 1
a195 1
  	struct {
d209 1
a209 1
	uint8_t          pad[64];
@


1.29
log
@Implement ACPI 6.5.1 spec tree walk for _STA and _INI.
Fixes mk's laptop.  No regressions so far (thank you to the
testers).

ok gwk@@, mk@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.28 2007/04/11 02:51:11 jordan Exp $ */
d247 2
@


1.28
log
@Added changes for C-State
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.27 2007/02/22 06:22:31 jordan Exp $ */
d67 1
a67 1
			    void (*)(struct aml_node *, void *), void *);
@


1.27
log
@New resource mapper interface and structures
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.26 2007/02/18 02:25:05 jordan Exp $ */
d244 3
@


1.26
log
@Added dynamic perfect hash for opcodes
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.25 2007/02/06 18:56:31 jordan Exp $ */
d109 1
d122 1
a122 1
		uint8_t  irq_info;
d126 2
a127 2
		uint8_t  dma_chan;
		uint8_t  dma_info;
d131 5
a135 5
		uint8_t  io_info;
		uint16_t io_min;
		uint16_t io_max;
		uint8_t  io_aln;
		uint8_t  io_len;
d139 2
a140 2
		uint16_t fio_bas;
		uint8_t  fio_len;
d147 5
a151 5
		uint8_t  m24_info;
		uint16_t m24_min;
		uint16_t m24_max;
		uint16_t m24_aln;
		uint16_t m24_len;
d156 5
a160 5
		uint8_t  m32_info;
		uint32_t m32_min;
		uint32_t m32_max;
		uint32_t m32_aln;
		uint32_t m32_len;
d169 43
d217 1
a217 1
			    (x)->hdr.length+2 : (x)->hdr.typecode & 0x7)
@


1.25
log
@Added support for calling _OSI method
Display byte/word/string/nameref for aml_mnem function
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.24 2006/12/26 23:58:08 marco Exp $ */
d198 2
@


1.24
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.23 2006/12/21 19:59:02 deraadt Exp $ */
d50 1
a50 1
const char		*aml_mnem(int);
@


1.23
log
@even more knf love
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.22 2006/12/21 11:23:41 deraadt Exp $ */
d73 2
a74 1
			    int (*)(struct aml_node *, int, void *), void *);
d197 1
@


1.22
log
@more minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.21 2006/11/27 18:30:38 kettenis Exp $ */
d113 1
a113 1
	
@


1.21
log
@Make AML_CRSLEN return the correct length for small resources.

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.20 2006/11/27 15:17:37 jordan Exp $ */
d21 1
a21 2
struct aml_vallist
{
d27 1
a27 2
struct aml_scope
{
d29 1
a29 1
	uint8_t            *pos;
d40 1
a40 2
struct aml_opcode
{
d44 2
a45 1
	struct aml_value      *(*handler)(struct aml_scope *,int,struct aml_value*);
d53 2
a54 1
struct aml_node         *aml_createname(struct aml_node *, const void *, struct aml_value *);
d75 1
a75 1
u_int64_t aml_getpciaddr(struct acpi_softc *, struct aml_node *);
d77 5
a81 3
int aml_evalnode(struct acpi_softc *, struct aml_node *,
		 int , struct aml_value *,
		 struct aml_value *);
d83 2
a84 3
int aml_evalname(struct acpi_softc *, struct aml_node *, 
		 const char *, int, struct aml_value *,
		 struct aml_value *);
d86 2
a87 2
void aml_fixup_dsdt(u_int8_t *, u_int8_t *, int);
void aml_create_defaultobjects(void);
d89 1
a89 4
int acpi_mutex_acquire(struct aml_value *, int);
void acpi_mutex_release(struct aml_value *);

const char *aml_nodename(struct aml_node *);
d108 1
a108 2
union acpi_resource
{
d114 2
a115 2
        /* Small resource structures
	 * format of typecode is: tttttlll, t = type, l = length 
d117 43
a159 43
        struct {
                uint8_t  typecode;
                uint16_t irq_mask;
                uint8_t  irq_info;
        }  __packed sr_irq;
        struct {
                uint8_t  typecode;
                uint8_t  dma_chan;
                uint8_t  dma_info;
        }  __packed sr_dma;
        struct {
                uint8_t  typecode;
                uint8_t  io_info;
                uint16_t io_min;
                uint16_t io_max;
                uint8_t  io_aln;
                uint8_t  io_len;
        }  __packed sr_ioport;
        struct {
                uint8_t  typecode;
                uint16_t fio_bas;
                uint8_t  fio_len;
        }  __packed sr_fioport;

        /* Large resource structures */
        struct {
                uint8_t  typecode;
                uint16_t length;
                uint8_t  m24_info;
                uint16_t m24_min;
                uint16_t m24_max;
                uint16_t m24_aln;
                uint16_t m24_len;
        }  __packed lr_m24;
        struct {
                uint8_t  typecode;
                uint16_t length;
                uint8_t  m32_info;
                uint32_t m32_min;
                uint32_t m32_max;
                uint32_t m32_aln;
                uint32_t m32_len;
        }  __packed lr_m32;
d169 8
a176 10
#define AML_CRSTYPE(x) ((x)->hdr.typecode & 0x80 ? \
			(x)->hdr.typecode : \
(x)->hdr.typecode >> 3)
#define AML_CRSLEN(x) ((x)->hdr.typecode & 0x80 ? \
		       (x)->hdr.length+2 : \
(x)->hdr.typecode & 0x7)

int aml_print_resource(union acpi_resource *, void *);
int aml_parse_resource(int, uint8_t *, int (*)(union acpi_resource *, void *),
    void *);
a190 4
void
aml_walknodes(struct aml_node *, int,
	      int (*)(struct aml_node *, void *),
	      void *);
d192 4
a195 1
void aml_postparse(void);
@


1.20
log
@Added support for parsing _CRS resources
Post-parsing fixup for forward name references
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.19 2006/11/25 18:24:54 marco Exp $ */
d178 1
a178 1
(x)->hdr.length & 0x7)
@


1.19
log
@Add mutex.

prodded dlg, ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.18 2006/10/24 19:01:48 jordan Exp $ */
d92 92
d189 14
@


1.18
log
@Added stack trace to aml_die+acpidebug
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.17 2006/10/19 07:02:20 jordan Exp $ */
d88 3
@


1.17
log
@Fixed AML debugger code to use new interface
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.16 2006/10/19 01:06:54 jordan Exp $ */
d91 3
@


1.16
log
@Merged target/terminal handling code
Added function call pointer to opcode table
_BIF working on Dell, IBM
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.15 2006/10/12 23:16:11 jordan Exp $ */
d21 1
a21 1
struct acpi_context
d23 16
a38 7
	int			depth;
	u_int8_t		*pos;
	u_int8_t		*start;
	struct acpi_softc	*sc;
	struct aml_value	**locals;
	struct aml_value	**args;
	struct aml_node		*scope;
a40 1
struct aml_scope;
d51 1
a52 3
const char		*aml_parse_name(struct acpi_context *);
int			aml_parse_length(struct acpi_context *);
int64_t			aml_eparseint(struct acpi_context *, int);
a56 1
struct aml_opcode	*aml_getopcode(struct acpi_context *);
a59 2
u_int8_t		*aml_eparselen(struct acpi_context *);
void			acpi_freecontext(struct acpi_context *);
d63 1
a63 1
void			aml_showvalue(struct aml_value *);
a66 2
int			aml_comparevalue(struct acpi_context *, int,
			    struct aml_value *, struct aml_value *);
a72 2
struct acpi_context	*acpi_alloccontext(struct acpi_softc *,
			    struct aml_node *, int, struct aml_value *);
@


1.15
log
@Added exportable aml_getpciaddr
Added printing args for called functions
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.14 2006/10/12 16:38:21 jordan Exp $ */
d32 2
d39 1
@


1.14
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.13 2006/03/09 05:38:12 jordan Exp $ */
d74 4
a77 2
int aml_evalnode(struct acpi_softc *sc, struct aml_node *node,
		 int argc, struct aml_value *argv,
d80 1
a80 1
int aml_evalname(struct acpi_softc *sc, struct aml_node *parent, 
@


1.13
log
@Used common aml_opname for debugger
Removed redundant code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.12 2006/03/08 04:03:21 marco Exp $ */
d34 1
a34 1
	u_int16_t		opcode;
d40 1
a40 1
const char		*aml_opname(int);
d44 4
a47 2
int64_t			aml_val2int(struct acpi_context *, struct aml_value *);
struct aml_node		*aml_searchname(struct aml_node *, const char *);
d51 1
a51 2
struct aml_value	*aml_allocvalue(int, int64_t, void *);
struct aml_value	*aml_copyvalue(const struct aml_value *);
d54 1
a54 1
void			aml_freevalue(struct aml_value **);
a64 3
int			aml_eval_name(struct acpi_softc *, struct aml_node *,
			    const char *, struct aml_value *,
			    struct aml_value *);
d73 14
@


1.12
log
@KNF + alignment.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.11 2006/03/07 23:13:28 marco Exp $ */
d39 2
a41 1
const char		*aml_eisaid(u_int32_t);
d45 1
a46 1
struct aml_node		*aml_searchname(struct aml_node *, const char *);
d52 1
d57 1
a58 3
void			aml_walkroot(void);
void			acpi_freecontext(struct acpi_context *);

@


1.11
log
@Add "disasm" code for ddb.  With this one can disassemble AML code from DDB.
example : "machine acpi disasm \\_SB_.BIF_" dumps the battery AML on my laptop.

Disasm code was written by jordan.  Help from miod on ddb lexer magic.
ok jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.10 2006/03/05 14:46:46 marco Exp $ */
d23 7
a29 7
	int depth;
	uint8_t *pos;
	uint8_t *start;
	struct acpi_softc  *sc;
	struct aml_value  **locals;
	struct aml_value  **args;
	struct aml_node	   *scope;
d34 3
a36 3
	u_int16_t    opcode;
	const char  *mnem;
	const char  *args;
d39 36
a74 45
const char	*aml_eisaid(u_int32_t);
int		aml_find_node(struct aml_node *, const char *,
		    void (*)(struct aml_node *, void *), void *);
int	acpi_parse_aml(struct acpi_softc *, u_int8_t *, u_int32_t);

int     aml_eval_object(struct acpi_softc *, struct aml_node *, 
			struct aml_value *, int, struct aml_value *);
int     aml_eval_name(struct acpi_softc *, struct aml_node *, const char *,
		      struct aml_value *, struct aml_value *);
void    aml_showvalue(struct aml_value *);

void    aml_walktree(struct aml_node *);
void	aml_walkroot(void);

struct aml_value *aml_allocint(uint64_t);
struct aml_value *aml_allocstr(const char *);
struct aml_value *aml_allocvalue(int, int64_t, void *);
struct aml_value *aml_copyvalue(const struct aml_value *);

struct acpi_context;

void  aml_freevalue(struct aml_value **);
int   aml_comparevalue(struct acpi_context *, int, struct aml_value *, struct aml_value *);

int64_t aml_val2int(struct acpi_context *, struct aml_value *);

struct aml_node *aml_searchname(struct aml_node *, const char *);

void aml_register_notify(struct aml_node *, const char *,
			 int (*)(struct aml_node *, int, void *),
			 void *);
void aml_notify(struct aml_node *, int);
void aml_notify_dev(const char *, int);

int64_t aml_eparseint(struct acpi_context *, int);
struct aml_opcode *aml_getopcode(struct acpi_context *);
const char *aml_parse_name(struct acpi_context *);
int aml_parse_length(struct acpi_context *);
u_int8_t *aml_eparselen(struct acpi_context *);

void acpi_freecontext(struct acpi_context *);
struct acpi_context *acpi_alloccontext(struct acpi_softc *, struct aml_node *,
    int, struct aml_value *);

struct aml_node *aml_searchname(struct aml_node *, const char *);
@


1.10
log
@Hook acpi to ddb since we need to be able to do some live debugging.

Lots and lots of help from miod@@ and deraadt@@
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.9 2006/02/22 19:29:24 jordan Exp $ */
d21 18
d72 12
@


1.9
log
@Added new aml_register_notify to handle call-by-ID
Moved powerdown code to button device
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.8 2006/02/19 21:32:30 jordan Exp $ */
d33 1
@


1.8
log
@Added code for aml_notify GPE notification callback
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.7 2006/02/19 04:50:47 marco Exp $ */
d48 1
a48 1
void aml_register_notify(struct aml_node *, 
d52 1
@


1.7
log
@jordan:
Enable interrupts.
Added peripheral code to make this work.

marco:
Replace softintr and other types of interrupts with a handler with context.
Fixed interrupt magic for GPEs.
Some KNF

This is work done by jordan and I but has to be a single commit.
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.6 2006/02/16 21:11:13 jordan Exp $ */
d47 5
@


1.6
log
@Fixed parser/evaluator to retrieve battery info+state
Cleanup of parser
Dell laptops return battery status
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.5 2006/02/03 23:55:47 jordan Exp $ */
d45 2
@


1.5
log
@Rewrote aml parser yet again...
Fixed bus_space_map for i386/amd64
Added _BST and _BIF to acpibat to get status/info
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.4 2006/01/20 20:20:28 jordan Exp $ */
d34 1
a34 1
struct aml_value *aml_allocint(uint64_t, int);
d36 1
a36 1
struct aml_value *aml_allocvalue(int, int64_t, void *, const char *);
d39 6
a44 2
int aml_freevalue(struct aml_value **);
int aml_comparevalue(int, const struct aml_value *, const struct aml_value *);
@


1.4
log
@More evaluator changes
Removed old evaluator code
Fixed _HID value
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.3 2005/12/28 03:04:56 jordan Exp $ */
d27 1
a27 1
			struct aml_value *, struct aml_value *);
d34 1
a34 1
struct aml_value *aml_allocint(uint64_t);
d36 1
a36 1
struct aml_value *aml_allocvalue(int, int64_t, const void *, const char *);
d39 1
a39 1
int aml_freevalue(struct aml_value *);
@


1.3
log
@Added new method evaluation code
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.2 2005/12/16 00:08:53 jordan Exp $ */
d32 9
a40 1
void    aml_walktree(struct aml_node *, int);
@


1.2
log
@Moved DSDT AML parsing into parent ACPI driver
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: dsdt.h,v 1.1 2005/12/13 07:22:18 marco Exp $ */
d25 8
@


1.1
log
@Need some stuff outside of dsdt.c so create a .h
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d24 1
@

