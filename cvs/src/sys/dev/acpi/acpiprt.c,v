head	1.48;
access;
symbols
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.48.0.4
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.47.0.6
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.4
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.14
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.12
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.10
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.8
	OPENBSD_5_0:1.43.0.6
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.4
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16;
locks; strict;
comment	@ * @;


1.48
date	2016.10.25.06.48.58;	author pirofti;	state Exp;
branches;
next	1.47;
commitid	Z8xhqpkgqCmi8yVl;

1.47
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.46;
commitid	p4LJxGKbi0BU2cG6;

1.46
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.45;
commitid	uzzBR7hz9ncd4O6G;

1.45
date	2014.05.02.14.10.15;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2013.12.22.18.55.25;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.03.22.54.12;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.21.15.07.40;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.10.04.59.55;	author jordan;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.01.01.39.39;	author jordan;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.29.23.44.34;	author jordan;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.31.20.59.00;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.21.15.35.33;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.11.21.54.15;	author jordan;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.27.21.32.00;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.19.18.55.47;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.17.19.35.39;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.07.14.33.26;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.06.09.13.02;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.14.16.26.44;	author jordan;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.14.07.52.52;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.12.21.58.14;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.12.21.38.31;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.07.19.48.58;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.23.00.04.40;	author jordan;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.21.19.17.23;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.21.05.31.59;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.24.20.52.18;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.18.19.49.52;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.21.11.33.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.12.18.05.47.35;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.27.23.43.47;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.27.18.41.23;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.27.16.32.43;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.27.15.20.26;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.27.12.39.04;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.15.21.39.06;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Add the resource index to aml_parse_resource() callback function.

This is needed by an upcoming acpiec commit that handles machines breaking
the current ACPI specifications.

Change suggested by and ok kettenis@@, guenther@@
@
text
@/* $OpenBSD: acpiprt.c,v 1.47 2015/03/14 03:38:46 jsg Exp $ */
/*
 * Copyright (c) 2006 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/ppbreg.h>

#include <machine/i82093reg.h>
#include <machine/i82093var.h>

#include <machine/mpbiosvar.h>

#include "ioapic.h"

struct acpiprt_irq {
	int _int;
	int _shr;
	int _ll;
	int _he;
};

struct acpiprt_map {
	int bus, dev;
	int pin;
	int irq;
	struct acpiprt_softc *sc;
	struct aml_node *node;
	SIMPLEQ_ENTRY(acpiprt_map) list;
};

SIMPLEQ_HEAD(, acpiprt_map) acpiprt_map_list =
    SIMPLEQ_HEAD_INITIALIZER(acpiprt_map_list);

int	acpiprt_match(struct device *, void *, void *);
void	acpiprt_attach(struct device *, struct device *, void *);
int	acpiprt_getirq(int, union acpi_resource *, void *);
int	acpiprt_chooseirq(int, union acpi_resource *, void *);

struct acpiprt_softc {
	struct device		sc_dev;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	int			sc_bus;
};

struct cfattach acpiprt_ca = {
	sizeof(struct acpiprt_softc), acpiprt_match, acpiprt_attach
};

struct cfdriver acpiprt_cd = {
	NULL, "acpiprt", DV_DULL
};

void	acpiprt_prt_add(struct acpiprt_softc *, struct aml_value *);
int	acpiprt_getpcibus(struct acpiprt_softc *, struct aml_node *);
void	acpiprt_route_interrupt(int bus, int dev, int pin);

int
acpiprt_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata  *cf = match;

	/* sanity */
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	return (1);
}

void
acpiprt_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpiprt_softc *sc = (struct acpiprt_softc *)self;
	struct acpi_attach_args *aa = aux;
	struct aml_value res;
	int i;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;
	sc->sc_bus = acpiprt_getpcibus(sc, sc->sc_devnode);
	printf(": bus %d (%s)", sc->sc_bus, sc->sc_devnode->parent->name);

	if (sc->sc_bus == -1) {
		printf("\n");
		return;
	}

	if (aml_evalnode(sc->sc_acpi, sc->sc_devnode, 0, NULL, &res)) {
		printf(": no PCI interrupt routing table\n");
		return;
	}

	if (res.type != AML_OBJTYPE_PACKAGE) {
		printf(": _PRT is not a package\n");
		aml_freevalue(&res);
		return;
	}

	printf("\n");

	for (i = 0; i < res.length; i++)
		acpiprt_prt_add(sc, res.v_package[i]);

	aml_freevalue(&res);
}

int
acpiprt_getirq(int crsidx, union acpi_resource *crs, void *arg)
{
	struct acpiprt_irq *irq = arg;
	int typ, len;

	irq->_shr = 0;
	irq->_ll = 0;
	irq->_he = 1;

	typ = AML_CRSTYPE(crs);
	len = AML_CRSLEN(crs);
	switch (typ) {
	case SR_IRQ:
		irq->_int= ffs(letoh16(crs->sr_irq.irq_mask)) - 1;
		if (len > 2) {
			irq->_shr = (crs->sr_irq.irq_flags & SR_IRQ_SHR);
			irq->_ll = (crs->sr_irq.irq_flags & SR_IRQ_POLARITY);
			irq->_he = (crs->sr_irq.irq_flags & SR_IRQ_MODE);
		}
		break;
	case LR_EXTIRQ:
		irq->_int = letoh32(crs->lr_extirq.irq[0]);
		irq->_shr = (crs->lr_extirq.flags & LR_EXTIRQ_SHR);
		irq->_ll = (crs->lr_extirq.flags & LR_EXTIRQ_POLARITY);
		irq->_he = (crs->lr_extirq.flags & LR_EXTIRQ_MODE);
		break;
	default:
		printf("unknown interrupt: %x\n", typ);
	}
	return (0);
}

int
acpiprt_pri[16] = {
	0,			/* 8254 Counter 0 */
	1,			/* Keyboard */
	0,			/* 8259 Slave */
	2,			/* Serial Port A */
	2,			/* Serial Port B */
	5,			/* Parallel Port / Generic */
	2,			/* Floppy Disk */
	4,			/* Parallel Port / Generic */
	1,			/* RTC */
	6,			/* Generic */
	7,			/* Generic */
	7,			/* Generic */
	1,			/* Mouse */
	0,			/* FPU */
	2,			/* Primary IDE */
	3			/* Secondary IDE */
};

int
acpiprt_chooseirq(int crsidx, union acpi_resource *crs, void *arg)
{
	struct acpiprt_irq *irq = arg;
	int typ, len, i, pri = -1;

	irq->_shr = 0;
	irq->_ll = 0;
	irq->_he = 1;

	typ = AML_CRSTYPE(crs);
	len = AML_CRSLEN(crs);
	switch (typ) {
	case SR_IRQ:
		for (i = 0; i < sizeof(crs->sr_irq.irq_mask) * 8; i++) {
			if (crs->sr_irq.irq_mask & (1 << i) &&
			    acpiprt_pri[i] > pri) {
				irq->_int = i;
				pri = acpiprt_pri[irq->_int];
			}
		}
		if (len > 2) {
			irq->_shr = (crs->sr_irq.irq_flags & SR_IRQ_SHR);
			irq->_ll = (crs->sr_irq.irq_flags & SR_IRQ_POLARITY);
			irq->_he = (crs->sr_irq.irq_flags & SR_IRQ_MODE);
		}
		break;
	case LR_EXTIRQ:
		/* First try non-8259 interrupts. */
		for (i = 0; i < crs->lr_extirq.irq_count; i++) {
			if (crs->lr_extirq.irq[i] > 15) {
				irq->_int = crs->lr_extirq.irq[i];
				return (0);
			}
		}

		for (i = 0; i < crs->lr_extirq.irq_count; i++) {
			if (acpiprt_pri[crs->lr_extirq.irq[i]] > pri) {
				irq->_int = crs->lr_extirq.irq[i];
				pri = acpiprt_pri[irq->_int];
			}
		}
		irq->_shr = (crs->lr_extirq.flags & LR_EXTIRQ_SHR);
		irq->_ll = (crs->lr_extirq.flags & LR_EXTIRQ_POLARITY);
		irq->_he = (crs->lr_extirq.flags & LR_EXTIRQ_MODE);
		break;
	default:
		printf("unknown interrupt: %x\n", typ);
	}
	return (0);
}

void
acpiprt_prt_add(struct acpiprt_softc *sc, struct aml_value *v)
{
	struct aml_node	*node;
	struct aml_value res, *pp;
	struct acpiprt_irq irq;
	u_int64_t addr;
	int pin;
	int64_t sta;
#if NIOAPIC > 0
	struct mp_intr_map *map;
	struct ioapic_softc *apic;
#endif
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	pcireg_t reg;
	int bus, dev, func, nfuncs;
	struct acpiprt_map *p;

	if (v->type != AML_OBJTYPE_PACKAGE || v->length != 4) {
		printf("invalid mapping object\n");
		return;
	}

	addr = aml_val2int(v->v_package[0]);
	pin = aml_val2int(v->v_package[1]);
	if (pin > 3) {
		return;
	}

	pp = v->v_package[2];
	if (pp->type == AML_OBJTYPE_STRING) {
		node = aml_searchrel(sc->sc_devnode, pp->v_string);
		if (node == NULL) {
			printf("Invalid device\n");
			return;
		}
		pp = node->value;
	}
	if (pp->type == AML_OBJTYPE_NAMEREF) {
		node = aml_searchrel(sc->sc_devnode, pp->v_nameref);
		if (node == NULL) {
			printf("Invalid device\n");
			return;
		}
		pp = node->value;
	}
	if (pp->type == AML_OBJTYPE_OBJREF) {
		pp = pp->v_objref.ref;
	}
	if (pp->type == AML_OBJTYPE_DEVICE) {
		node = pp->node;
		if (aml_evalinteger(sc->sc_acpi, node, "_STA", 0, NULL, &sta)) {
			printf("no _STA method\n");
			return;
		}

		if ((sta & STA_PRESENT) == 0)
			return;

		if (aml_evalname(sc->sc_acpi, node, "_CRS", 0, NULL, &res)) {
			printf("no _CRS method\n");
			return;
		}

		if (res.type != AML_OBJTYPE_BUFFER || res.length < 5) {
			printf("invalid _CRS object\n");
			aml_freevalue(&res);
			return;
		}
		aml_parse_resource(&res, acpiprt_getirq, &irq);
		aml_freevalue(&res);

		/* Pick a new IRQ if necessary. */
		if ((irq._int == 0 || irq._int == 2 || irq._int == 13) &&
		    !aml_evalname(sc->sc_acpi, node, "_PRS", 0, NULL, &res)){
			aml_parse_resource(&res, acpiprt_chooseirq, &irq);
			aml_freevalue(&res);
		}

		if ((p = malloc(sizeof(*p), M_ACPI, M_NOWAIT)) == NULL)
			return;
		p->bus = sc->sc_bus;
		p->dev = ACPI_PCI_DEV(addr << 16);
		p->pin = pin;
		p->irq = irq._int;
		p->sc = sc;
		p->node = node;
		SIMPLEQ_INSERT_TAIL(&acpiprt_map_list, p, list);
	} else {
		irq._int = aml_val2int(v->v_package[3]);
		irq._shr = 1;
		irq._ll = 1;
		irq._he = 0;
	}

#ifdef ACPI_DEBUG
	printf("%s: %s addr 0x%llx pin %d irq %d\n",
	    DEVNAME(sc), aml_nodename(pp->node), addr, pin, irq._int);
#endif

#if NIOAPIC > 0
	if (nioapics > 0) {
		apic = ioapic_find_bybase(irq._int);
		if (apic == NULL) {
			printf("%s: no apic found for irq %d\n",
			    DEVNAME(sc), irq._int);
			return;
		}

		map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (map == NULL)
			return;

		map->ioapic = apic;
		map->ioapic_pin = irq._int - apic->sc_apic_vecbase;
		map->bus_pin = ((addr >> 14) & 0x7c) | (pin & 0x3);
		if (irq._ll)
			map->flags |= (MPS_INTPO_ACTLO << MPS_INTPO_SHIFT);
		else
			map->flags |= (MPS_INTPO_ACTHI << MPS_INTPO_SHIFT);
		if (irq._he)
			map->flags |= (MPS_INTTR_EDGE << MPS_INTTR_SHIFT);
		else
			map->flags |= (MPS_INTTR_LEVEL << MPS_INTTR_SHIFT);

		map->redir = (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);
		switch ((map->flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK) {
		case MPS_INTPO_DEF:
		case MPS_INTPO_ACTLO:
			map->redir |= IOAPIC_REDLO_ACTLO;
			break;
		}
		switch ((map->flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK) {
		case MPS_INTTR_DEF:
		case MPS_INTTR_LEVEL:
			map->redir |= IOAPIC_REDLO_LEVEL;
			break;
		}

		map->ioapic_ih = APIC_INT_VIA_APIC |
		    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) |
		    (map->ioapic_pin << APIC_INT_PIN_SHIFT));

		apic->sc_pins[map->ioapic_pin].ip_map = map;

		map->next = mp_busses[sc->sc_bus].mb_intrs;
		mp_busses[sc->sc_bus].mb_intrs = map;

		return;
	}
#endif

	bus = sc->sc_bus;
	dev = ACPI_PCI_DEV(addr << 16);
	tag = pci_make_tag(pc, bus, dev, 0);

	reg = pci_conf_read(pc, tag, PCI_BHLC_REG);
	if (PCI_HDRTYPE_MULTIFN(reg))
		nfuncs = 8;
	else
		nfuncs = 1;

	for (func = 0; func < nfuncs; func++) {
		tag = pci_make_tag(pc, bus, dev, func);
		reg = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
		if (PCI_INTERRUPT_PIN(reg) == pin + 1) {
			reg &= ~(PCI_INTERRUPT_LINE_MASK << PCI_INTERRUPT_LINE_SHIFT);
			reg |= irq._int << PCI_INTERRUPT_LINE_SHIFT;
			pci_conf_write(pc, tag, PCI_INTERRUPT_REG, reg);
		}
	}
}

int
acpiprt_getpcibus(struct acpiprt_softc *sc, struct aml_node *node)
{
	/* Check if parent device has PCI mapping */
	return (node->parent && node->parent->pci) ?
		node->parent->pci->sub : -1;
}

void
acpiprt_route_interrupt(int bus, int dev, int pin)
{
	struct acpiprt_softc *sc;
	struct acpiprt_map *p;
	struct acpiprt_irq irq;
	struct aml_node *node = NULL;
	struct aml_value res, res2;
	union acpi_resource *crs;
	int newirq;
	int64_t sta;

	SIMPLEQ_FOREACH(p, &acpiprt_map_list, list) {
		if (p->bus == bus && p->dev == dev && p->pin == (pin - 1)) {
			newirq = p->irq;
			sc = p->sc;
			node = p->node;
			break;
		}
	}
	if (node == NULL)
		return;

	if (aml_evalinteger(sc->sc_acpi, node, "_STA", 0, NULL, &sta)) {
		printf("no _STA method\n");
		return;
	}

	KASSERT(sta & STA_PRESENT);

	if (aml_evalname(sc->sc_acpi, node, "_CRS", 0, NULL, &res)) {
		printf("no _CRS method\n");
		return;
	}
	if (res.type != AML_OBJTYPE_BUFFER || res.length < 5) {
		printf("invalid _CRS object\n");
		aml_freevalue(&res);
		return;
	}
	aml_parse_resource(&res, acpiprt_getirq, &irq);

	/* Only re-route interrupts when necessary. */
	if ((sta & STA_ENABLED) && irq._int == newirq) {
		aml_freevalue(&res);
		return;
	}

	crs = (union acpi_resource *)res.v_buffer;
	switch (AML_CRSTYPE(crs)) {
	case SR_IRQ:
		crs->sr_irq.irq_mask = htole16(1 << newirq);
		break;
	case LR_EXTIRQ:
		crs->lr_extirq.irq[0] = htole32(newirq);
		break;
	}

	if (aml_evalname(sc->sc_acpi, node, "_SRS", 1, &res, &res2)) {
		printf("no _SRS method\n");
		aml_freevalue(&res);
		return;
	}
	aml_freevalue(&res);
	aml_freevalue(&res2);
}
@


1.47
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.46 2014/09/14 14:17:24 jsg Exp $ */
d63 2
a64 2
int	acpiprt_getirq(union acpi_resource *crs, void *arg);
int	acpiprt_chooseirq(union acpi_resource *, void *);
d140 1
a140 1
acpiprt_getirq(union acpi_resource *crs, void *arg)
d193 1
a193 1
acpiprt_chooseirq(union acpi_resource *crs, void *arg)
@


1.46
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.45 2014/05/02 14:10:15 kettenis Exp $ */
a32 1
#include <dev/pci/pcidevs.h>
@


1.45
log
@Make acpiprt(4) handle interrupts with non-standard polarity and trigger mode
correctly.

Tested by nobody.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.44 2013/12/22 18:55:25 kettenis Exp $ */
a18 1
#include <sys/proc.h>
@


1.44
log
@Bail out early if the PCI bus number is -1.  This means the hardware isn't
there and the AML might reference stuff that isn't there.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.43 2010/08/03 22:54:12 kettenis Exp $ */
d44 7
d144 6
a149 2
	int *irq = (int *)arg;
	int typ;
d152 1
d155 6
a160 1
		*irq = ffs(letoh16(crs->sr_irq.irq_mask)) - 1;
d163 4
a166 1
		*irq = letoh32(crs->lr_extirq.irq[0]);
d197 6
a202 2
	int *irq = (int *)arg;
	int typ, i, pri = -1;
d205 1
d211 2
a212 2
				*irq = i;
				pri = acpiprt_pri[*irq];
d215 5
d225 1
a225 1
				*irq = crs->lr_extirq.irq[i];
d232 2
a233 2
				*irq = crs->lr_extirq.irq[i];
				pri = acpiprt_pri[*irq];
d236 3
d251 1
d253 1
a253 1
	int pin, irq;
d320 1
a320 1
		if ((irq == 0 || irq == 2 || irq == 13) &&
d331 1
a331 1
		p->irq = irq;
d336 4
a339 1
		irq = aml_val2int(v->v_package[3]);
d344 1
a344 1
	    DEVNAME(sc), aml_nodename(pp->node), addr, pin, irq);
d349 1
a349 1
		apic = ioapic_find_bybase(irq);
d351 2
a352 1
			printf("%s: no apic found for irq %d\n", DEVNAME(sc), irq);
d361 1
a361 1
		map->ioapic_pin = irq - apic->sc_apic_vecbase;
d363 22
a384 2
		map->redir = IOAPIC_REDLO_ACTLO | IOAPIC_REDLO_LEVEL;
		map->redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);
d414 1
a414 1
			reg |= irq << PCI_INTERRUPT_LINE_SHIFT;
d433 1
d437 1
a437 1
	int irq, newirq;
d470 1
a470 1
	if ((sta & STA_ENABLED) && irq == newirq) {
@


1.43
log
@Remove old code that figures out the PCI bus number.  The new code gets some
corner cases right that the old code messed up.  As a bonus, this noticibly
speeds up booting my Dell XPS M1330.

ok deraadt@@, marco@@, jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.42 2010/07/21 19:35:15 deraadt Exp $ */
d110 5
a126 3

	if (sc->sc_bus == -1)
		return;
@


1.42
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.41 2010/07/21 15:07:40 deraadt Exp $ */
a58 1
int	acpiprt_getminbus(union acpi_resource *, void *);
d103 1
a103 1
	int i, nbus;
a107 2
	nbus = (sc->sc_devnode->parent && sc->sc_devnode->parent->pci) ?
		sc->sc_devnode->parent->pci->sub : -1;
a109 7
	if (nbus != sc->sc_bus) {
		printf("%s: bus mismatch, new:%d old:%d\n",
			aml_nodename(sc->sc_devnode),
			nbus, sc->sc_bus);
		sc->sc_bus = nbus;
	}

a360 12
acpiprt_getminbus(union acpi_resource *crs, void *arg)
{
	int *bbn = arg;
	int typ = AML_CRSTYPE(crs);

	/* Check for embedded bus number */
	if (typ == LR_WORD && crs->lr_word.type == 2)
		*bbn = crs->lr_word._min;
	return 0;
}

int
d363 3
a365 63
	struct aml_node *parent = node->parent;
	struct aml_value res;
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	pcireg_t reg;
	int bus, dev, func, rv;
	int64_t ires;

	if (parent == NULL)
		return 0;

	/*
	 * If our parent is a a bridge, it might have an address descriptor
	 * that tells us our bus number.
	 */
	if (aml_evalname(sc->sc_acpi, parent, "_CRS.", 0, NULL, &res) == 0) {
		rv = -1;
		aml_parse_resource(&res, acpiprt_getminbus, &rv);
		aml_freevalue(&res);
		if (rv != -1)
			return rv;
	}

	/*
	 * If our parent is the root of the bus, it should specify the
	 * base bus number.
	 */
	if (aml_evalinteger(sc->sc_acpi, parent, "_BBN.", 0, NULL, &ires) == 0) {
		return (ires);
	}

	/*
	 * If our parent is a PCI-PCI bridge, get our bus number from its
	 * PCI config space.
	 */
	if (aml_evalinteger(sc->sc_acpi, parent, "_ADR.", 0, NULL, &ires) == 0) {
		bus = acpiprt_getpcibus(sc, parent);
		dev = ACPI_PCI_DEV(ires << 16);
		func = ACPI_PCI_FN(ires << 16);

		/*
		 * Some systems return 255 as the device number for
		 * devices that are not really there.
		 */
		if (dev >= pci_bus_maxdevs(pc, bus))
			return (-1);

		tag = pci_make_tag(pc, bus, dev, func);

		/* Check whether the device is really there. */
		reg = pci_conf_read(pc, tag, PCI_ID_REG);
		if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
			return (-1);

		/* Fetch bus number from PCI config space. */
		reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
		if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
		    PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI) {
			reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
			return (PPB_BUSINFO_SECONDARY(reg));
		}
	}
	return (0);
@


1.41
log
@clean up a pile of prototypes and shred some macros which were just covering
for ones everyone knows better
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.40 2010/07/10 04:59:55 jordan Exp $ */
d171 1
a171 1
	4, 			/* Parallel Port / Generic */
@


1.40
log
@Verify _ADR bdf is correct (some systems return 0xffff)
Works on Dell x9xx and Studio 1555
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.39 2010/07/08 20:56:31 jordan Exp $ */
d151 1
a151 1
		*irq = ffs(aml_letohost16(crs->sr_irq.irq_mask)) - 1;
d154 1
a154 1
		*irq = aml_letohost32(crs->lr_extirq.irq[0]);
@


1.39
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.38 2010/07/01 06:29:32 jordan Exp $ */
d117 1
a117 1
		panic("aiiiee..");
@


1.38
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.35 2009/03/31 20:59:00 kettenis Exp $ */
d104 1
a104 1
	int i;
d109 3
d113 6
a118 1
	printf(": bus %d (%s)", sc->sc_bus, sc->sc_devnode->parent->name);
d290 1
a290 2
		aml_parse_resource(res.length, res.v_buffer,
		    acpiprt_getirq, &irq);
d296 1
a296 5
			if (res.type == AML_OBJTYPE_BUFFER &&
			    res.length >= 5) {
				aml_parse_resource(res.length, res.v_buffer,
				    acpiprt_chooseirq, &irq);
			}
d402 1
a402 3
		if (res.type == AML_OBJTYPE_BUFFER)
			aml_parse_resource(res.length, res.v_buffer,
			    acpiprt_getminbus, &rv);
d488 1
a488 1
	aml_parse_resource(res.length, res.v_buffer, acpiprt_getirq, &irq);
@


1.37
log
@Simplified aml_parse_resource call, cleanup code
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.36 2010/06/29 23:44:34 jordan Exp $ */
d59 1
d282 2
a283 1
		aml_parse_resource(&res, acpiprt_getirq, &irq);
d289 5
a293 1
			aml_parse_resource(&res, acpiprt_chooseirq, &irq);
d300 1
a300 1
		p->dev = ACPI_ADR_PCIDEV(addr);
d368 12
d382 65
a446 3
	/* Check if parent device has PCI mapping */
	return (node->parent && node->parent->pci) ?
		node->parent->pci->sub : -1;
d487 1
a487 1
	aml_parse_resource(&res, acpiprt_getirq, &irq);
@


1.36
log
@Use new ACPI PCI mapping to get _PRT bus
Delete old unused code
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.35 2009/03/31 20:59:00 kettenis Exp $ */
d281 1
a281 2
		aml_parse_resource(res.length, res.v_buffer,
		    acpiprt_getirq, &irq);
d287 1
a287 5
			if (res.type == AML_OBJTYPE_BUFFER &&
			    res.length >= 5) {
				aml_parse_resource(res.length, res.v_buffer,
				    acpiprt_chooseirq, &irq);
			}
d407 1
a407 1
	aml_parse_resource(res.length, res.v_buffer, acpiprt_getirq, &irq);
@


1.35
log
@Backout previous change; it breaks more machines than it fixes.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.33 2009/03/11 21:54:15 jordan Exp $ */
a58 1
int	acpiprt_getminbus(union acpi_resource *, void *);
d299 1
a299 1
		p->dev = ACPI_PCI_DEV(addr << 16);
a366 12
acpiprt_getminbus(union acpi_resource *crs, void *arg)
{
	int *bbn = arg;
	int typ = AML_CRSTYPE(crs);

	/* Check for embedded bus number */
	if (typ == LR_WORD && crs->lr_word.type == 2)
		*bbn = crs->lr_word._min;
	return 0;
}

int
d369 3
a371 65
	struct aml_node *parent = node->parent;
	struct aml_value res;
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	pcireg_t reg;
	int bus, dev, func, rv;
	int64_t ires;

	if (parent == NULL)
		return 0;

	/*
	 * If our parent is a a bridge, it might have an address descriptor
	 * that tells us our bus number.
	 */
	if (aml_evalname(sc->sc_acpi, parent, "_CRS.", 0, NULL, &res) == 0) {
		rv = -1;
		if (res.type == AML_OBJTYPE_BUFFER)
			aml_parse_resource(res.length, res.v_buffer,
			    acpiprt_getminbus, &rv);
		aml_freevalue(&res);
		if (rv != -1)
			return rv;
	}

	/*
	 * If our parent is the root of the bus, it should specify the
	 * base bus number.
	 */
	if (aml_evalinteger(sc->sc_acpi, parent, "_BBN.", 0, NULL, &ires) == 0) {
		return (ires);
	}

	/*
	 * If our parent is a PCI-PCI bridge, get our bus number from its
	 * PCI config space.
	 */
	if (aml_evalinteger(sc->sc_acpi, parent, "_ADR.", 0, NULL, &ires) == 0) {
		bus = acpiprt_getpcibus(sc, parent);
		dev = ACPI_PCI_DEV(ires << 16);
		func = ACPI_PCI_FN(ires << 16);

		/*
		 * Some systems return 255 as the device number for
		 * devices that are not really there.
		 */
		if (dev >= pci_bus_maxdevs(pc, bus))
			return (-1);

		tag = pci_make_tag(pc, bus, dev, func);

		/* Check whether the device is really there. */
		reg = pci_conf_read(pc, tag, PCI_ID_REG);
		if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
			return (-1);

		/* Fetch bus number from PCI config space. */
		reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
		if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
		    PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI) {
			reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
			return (PPB_BUSINFO_SECONDARY(reg));
		}
	}
	return (0);
@


1.34
log
@Always re-route interrupts, even when doing so appears to be a no-op.  Some
BIOSen flat out lie to us when we ask for the current routing.

ok marco@@
@
text
@d489 6
@


1.33
log
@More aml_evalinteger fixup
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.32 2009/03/11 20:37:46 jordan Exp $ */
a487 6

	/* Only re-route interrupts when necessary. */
	if ((sta & STA_ENABLED) && irq == newirq) {
		aml_freevalue(&res);
		return;
	}
@


1.32
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.31 2009/01/27 21:32:00 kettenis Exp $ */
d388 1
d411 2
a412 4
	if (aml_evalname(sc->sc_acpi, parent, "_BBN.", 0, NULL, &res) == 0) {
		rv = aml_val2int(&res);
		aml_freevalue(&res);
		return (rv);
d419 1
a419 1
	if (aml_evalname(sc->sc_acpi, parent, "_ADR.", 0, NULL, &res) == 0) {
d421 2
a422 3
		dev = ACPI_PCI_DEV(aml_val2int(&res) << 16);
		func = ACPI_PCI_FN(aml_val2int(&res) << 16);
		aml_freevalue(&res);
d457 2
a458 1
	int irq, newirq, sta;
d471 1
a471 1
	if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res)) {
a475 2
	sta = aml_val2int(&res);
	aml_freevalue(&res);
@


1.31
log
@Turns out the IRQ Information is optional in IRQ Descriptor resources, so
allow resources that are only 5 bytes long.  Prevents dmesg spamming
on the OQO.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.30 2008/12/19 18:55:47 kettenis Exp $ */
d219 2
a220 1
	int pin, irq, sta;
d264 1
a264 1
		if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res)) {
a268 2
		sta = aml_val2int(&res);
		aml_freevalue(&res);
@


1.30
log
@On many systems the information returned by _PRT is an absolute lie, especially
in the PIC case.  So if _CRS returns a plausible value, go with that, and only
chose an interrupt from the list returned by _PRT if the value returned by
_CRS makes no sense.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.29 2008/12/17 19:35:39 kettenis Exp $ */
d278 1
a278 1
		if (res.type != AML_OBJTYPE_BUFFER || res.length < 6) {
d291 1
a291 1
			    res.length >= 6) {
d486 1
a486 1
	if (res.type != AML_OBJTYPE_BUFFER || res.length < 6) {
@


1.29
log
@Make the code that picks an IRQ from the list of possible IRQs a bit smarter
by avoiding legacy IRQs if possible.  Fixes problems (some, not all) with
machines that advertise legacy IRQs as usable even if they have ISA devices
onboard that need those IRQs.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.28 2008/12/07 14:33:26 kettenis Exp $ */
a59 1
int	acpiprt_checkprs(union acpi_resource *, void *);
a134 30
acpiprt_checkprs(union acpi_resource *crs, void *arg)
{
	int *irq = (int *)arg;
	int typ, i;

	typ = AML_CRSTYPE(crs);
	switch (typ) {
	case SR_IRQ:
		for (i = 0; i < sizeof(crs->sr_irq.irq_mask) * 8; i++) {
			if (crs->sr_irq.irq_mask & (1L << i)) {
				if (i == *irq)
					return (0);
			}
		}
		break;
	case LR_EXTIRQ:
		for (i = 0; i < crs->lr_extirq.irq_count; i++) {
			if (crs->lr_extirq.irq[i] == *irq)
				return (0);
		}
		break;
	default:
		printf("unknown interrupt: %x\n", typ);
	}

	*irq = -1;
	return (0);
}

int
d219 1
a219 1
	int pin, irq, newirq, sta;
d287 3
a289 2
		/* Check Possible IRQs */
		if (!aml_evalname(sc->sc_acpi, node, "_PRS", 0, NULL, &res)){
d293 1
a293 3
				    acpiprt_checkprs, &irq);
				aml_parse_resource(res.length, res.v_buffer,
				    acpiprt_chooseirq, &newirq);
a295 10
		}

		if (irq == -1) {
			/*
			 * Current IRQ is "impossible".  Use the first
			 * available Possible IRQ instead.  We
			 * postpone re-routeing the interrupt until we
			 * establish a handler for it.
			 */
			irq = newirq;
@


1.28
log
@Make acpiprt(4) check whether the current interrupt routing is "possible" and
pick a new one from the list of possible routings if it isn't or if a pin is
currently not routed.  Delay re-routing interrupts until we establish a
handler for it.  This prevents us from messing with unused interrupt pins
which may have fatal consequences (some machines spontaniously reboot).

The heuristics for picking an interrupt from the list of possibe ones
probably needs some tweaking still, but this makes several NVIDIA-based
boards work much better than before.

tested by many, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.27 2008/06/11 04:42:09 marco Exp $ */
d61 1
d185 59
d325 1
a325 1
				    acpiprt_getirq, &newirq);
@


1.27
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: acpiprt.c,v 1.26 2008/06/06 09:13:02 marco Exp $ */
d44 12
d60 1
a60 3
#if 0
int	acpiprt_showprs(union acpi_resource *, void *);
#endif
d81 1
a81 1
void	acpiprt_route_interrupt(struct acpiprt_softc *, struct aml_node *);
a133 1
#if 0
d135 1
a135 1
acpiprt_showprs(union acpi_resource *crs, void *arg)
d138 1
a138 1
	int typ;
d143 5
a147 4
		printf("possible irq:[ ");
		for (typ = 0; typ < sizeof(crs->sr_irq.irq_mask) * 8; typ++) {
			if (crs->sr_irq.irq_mask & (1L << typ))
				printf("%d%s ", typ, (typ == *irq) ? "*" : "");
a148 1
		printf("]\n");
d151 4
a154 5
		printf("possible irq: [ ");
		for (typ = 0; typ < crs->lr_extirq.irq_count; typ++)
			printf("%d%s ", crs->lr_extirq.irq[typ],
			       crs->lr_extirq.irq[typ] == *irq ? "*" : "");
		printf("]\n");
d157 1
a157 1
		printf("Unknown interrupt : %x\n", typ);
d159 2
a162 1
#endif
d179 1
a179 1
		printf("Unknown interrupt: %x\n", typ);
d190 1
a190 1
	int pin, irq, sta;
d199 1
d241 2
a242 12
		if ((sta & STA_ENABLED) == 0) {
			if ((sta & STA_PRESENT) == 0)
				return;

			acpiprt_route_interrupt(sc, node);

			aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res);
			sta = aml_val2int(&res);
			aml_freevalue(&res);
			if ((sta & STA_ENABLED) == 0)
				return;
		}
d258 2
a259 3
#if 0
		/* Get Possible IRQs */
		if (!aml_evalname(sc->sc_acpi, node, "_PRS.", 0, NULL, &res)){
d261 3
a263 2
			    res.length >= 6)
			{
d265 1
a265 1
				    acpiprt_showprs, &irq);
d269 20
a288 1
#endif
d435 1
a435 1
acpiprt_route_interrupt(struct acpiprt_softc *sc, struct aml_node *node)
d437 3
d442 1
a442 1
	int irq;
d444 9
a452 2
	if (aml_evalname(sc->sc_acpi, node, "_PRS", 0, NULL, &res)) {
		printf("no _PRS method\n");
a453 1
	}
d455 2
a456 3
	if (res.type != AML_OBJTYPE_BUFFER || res.length < 6) {
		printf("invalid _PRS object\n");
		aml_freevalue(&res);
d459 2
a460 1
	aml_parse_resource(res.length, res.v_buffer, acpiprt_getirq, &irq);
d462 1
d465 1
a465 1
		printf("no _PRS method\n");
a467 1

d473 7
d484 1
a484 1
		crs->sr_irq.irq_mask = htole16(1 << irq);
d487 1
a487 1
		crs->lr_extirq.irq[0] = htole32(irq);
@


1.26
log
@Add _?RS methods evaluation to obtain additional heuristics and setting
interrupt routing.  Fixes several HP & IBM machines.

ok deraadt ketennis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.25 2008/06/01 17:59:55 marco Exp $	*/
@


1.25
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.23 2008/05/14 16:26:44 jordan Exp $	*/
d71 1
d170 1
a170 1
		printf("Unknown interrupt : %x\n", typ);
d224 1
a224 1
		if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res))
d226 2
d229 1
a229 1
		sta = aml_val2int(&res) & STA_ENABLED;
d231 12
a242 2
		if (sta == 0)
			return;
d244 1
a244 1
		if (aml_evalname(sc->sc_acpi, node, "_CRS", 0, NULL, &res))
d246 2
d413 50
@


1.24
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.20 2007/11/12 21:58:14 deraadt Exp $	*/
d48 3
a50 1

d123 31
d202 8
d211 1
a211 1
		node = aml_searchname(sc->sc_devnode, pp->v_nameref);
d242 13
a396 1

@


1.23
log
@Removed debugging printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.22 2008/05/14 07:52:52 brad Exp $	*/
a47 1
int	acpiprt_showprs(union acpi_resource *, void *);
a121 29
acpiprt_showprs(union acpi_resource *crs, void *arg)
{
	int *irq = (int *)arg;
	int typ;

	typ = AML_CRSTYPE(crs);
	switch (typ) {
	case SR_IRQ:
		printf("possible irq:[ ");
		for (typ = 0; typ < sizeof(crs->sr_irq.irq_mask) * 8; typ++) {
			if (crs->sr_irq.irq_mask & (1L << typ))
				printf("%d%s ", typ, (typ == *irq) ? "*" : "");
		}
		printf("]\n");
		break;
	case LR_EXTIRQ:
		printf("possible irq: [ ");
		for (typ = 0; typ < crs->lr_extirq.irq_count; typ++)
			printf("%d%s ", crs->lr_extirq.irq[typ],
			       crs->lr_extirq.irq[typ] == *irq ? "*" : "");
		printf("]\n");
		break;
	default:
		printf("Unknown interrupt : %x\n", typ);
	}
	return (0);
}

int
a168 8
	if (pp->type == AML_OBJTYPE_STRING) {
		node = aml_searchrel(sc->sc_devnode, pp->v_string);
		if (node == NULL) {
			printf("Invalid device\n");
			return;
		}
		pp = node->value;
	}
d170 1
a170 1
		node = aml_searchrel(sc->sc_devnode, pp->v_nameref);
a200 13

#if 0
		/* Get Possible IRQs */
		if (!aml_evalname(sc->sc_acpi, node, "_PRS.", 0, NULL, &res)){
			if (res.type == AML_OBJTYPE_BUFFER &&
			    res.length >= 6)
			{
				aml_parse_resource(res.length, res.v_buffer,
				    acpiprt_showprs, &irq);
			}
			aml_freevalue(&res);
		}
#endif
d343 1
@


1.22
log
@Clean up a bit.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.21 2008/05/14 05:24:36 jordan Exp $	*/
a199 1
		printf("STRING: %s\n", pp->v_string);
d240 2
d251 1
@


1.21
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.20 2007/11/12 21:58:14 deraadt Exp $	*/
d48 1
a48 1
int     acpiprt_showprs(union acpi_resource *, void *);
d132 2
a133 2
		for (typ=0; typ<sizeof(crs->sr_irq.irq_mask)*8; typ++) {
			if (crs->sr_irq.irq_mask & (1L << typ)) {
a134 1
			}
d140 1
a140 1
		for (typ=0; typ<crs->lr_extirq.irq_count; typ++) {
a142 1
		}
@


1.20
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.19 2007/11/12 21:38:31 deraadt Exp $	*/
d48 1
d123 31
d201 9
d211 1
a211 1
		node = aml_searchname(sc->sc_devnode, pp->v_nameref);
d242 10
a393 1

@


1.19
log
@a little less excitement (every printf does not need to end in !)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.18 2007/10/08 04:15:15 krw Exp $	*/
d293 2
a294 2
	  	if (res.type == AML_OBJTYPE_BUFFER)
			aml_parse_resource(res.length, res.v_buffer, 
@


1.18
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.17 2007/09/07 19:48:58 kettenis Exp $	*/
d172 1
a172 1
			printf("Invalid device!\n");
@


1.17
log
@Fix code that figures out the PCI bus number for a _PRT configuration object.
This should get rid of the "multiple bus 0" problem seen on some machines,
and fix PCI interrupt routing on them.

ok marco@@ (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.16 2007/02/23 00:04:40 jordan Exp $	*/
d218 1
a218 1
		map = malloc(sizeof (struct mp_intr_map), M_DEVBUF, M_NOWAIT);
a221 1
		memset(map, 0, sizeof *map);
@


1.16
log
@Added support for getting host-bridge _BBN from _CRS resources
suggestions by kettenis
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.15 2007/02/21 19:17:23 kettenis Exp $	*/
d34 1
d99 1
a99 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PRT", 0, NULL, &res)) {
d288 29
a316 1
	if (aml_evalname(sc->sc_acpi, parent, "_ADR", 0, NULL, &res) == 0) {
d330 7
a342 15
	}

	if (aml_evalname(sc->sc_acpi, parent, "_CRS", 0, NULL, &res) == 0) {
		rv = -1;
	  	if (res.type == AML_OBJTYPE_BUFFER)
			aml_parse_resource(res.length, res.v_buffer, 
			    acpiprt_getminbus, &rv);
		aml_freevalue(&res);
		if (rv != -1)
			return rv;
	}
	if (aml_evalname(sc->sc_acpi, parent, "_BBN", 0, NULL, &res) == 0) {
		rv = aml_val2int(&res);
		aml_freevalue(&res);
		return (rv);
@


1.15
log
@Make an acpi-enabled GENERIC.MP work on systems that only support PIC mode.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.14 2007/02/21 05:31:59 marco Exp $	*/
d46 2
d263 12
d309 9
@


1.14
log
@Fix a few memory leaks.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.13 2007/01/24 20:52:18 kettenis Exp $	*/
d148 1
a148 1
#else
a152 1
#endif
d208 10
a217 5
	apic = ioapic_find_bybase(irq);
	if (apic == NULL) {
		printf("%s: no apic found for irq %d\n", DEVNAME(sc), irq);
		return;
	}
d219 10
a228 3
	map = malloc(sizeof (struct mp_intr_map), M_DEVBUF, M_NOWAIT);
	if (map == NULL)
		return;
d230 1
a230 6
	memset(map, 0, sizeof *map);
	map->ioapic = apic;
	map->ioapic_pin = irq - apic->sc_apic_vecbase;
	map->bus_pin = ((addr >> 14) & 0x7c) | (pin & 0x3);
	map->redir = IOAPIC_REDLO_ACTLO | IOAPIC_REDLO_LEVEL;
	map->redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);
d232 2
a233 3
	map->ioapic_ih = APIC_INT_VIA_APIC |
	    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) |
	    (map->ioapic_pin << APIC_INT_PIN_SHIFT));
d235 3
a237 1
	apic->sc_pins[map->ioapic_pin].ip_map = map;
a238 3
	map->next = mp_busses[sc->sc_bus].mb_intrs;
	mp_busses[sc->sc_bus].mb_intrs = map;
#else
a257 1
#endif
@


1.13
log
@Deal with weird systems that return bogus device numbers for stuff that's not
really there.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.12 2007/01/18 19:49:52 kettenis Exp $	*/
d103 1
d114 2
d144 1
a144 1
	int pin, irq;
d182 4
a185 1
		if ((aml_val2int(&res) & STA_ENABLED) == 0)
d193 1
d198 1
d265 1
a265 1
	int bus, dev, func;
d274 1
d281 1
a281 1
			return -1;
d288 1
a288 1
			return PPB_BUSINFO_SECONDARY(reg);
d293 3
a295 1
		return aml_val2int(&res);
d298 1
a298 1
	return 0;
@


1.12
log
@Check whether PCI interrupt link devices are enabled.
Based on a diff from marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.11 2006/12/21 19:59:02 deraadt Exp $	*/
d108 3
d266 8
a274 1

@


1.11
log
@even more knf love
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.10 2006/12/21 11:33:21 deraadt Exp $	*/
d138 1
a138 1
	int pin, irq, sta;
d176 2
a177 1
		sta = aml_val2int(&res);
d193 2
a194 2
	printf("%s: %s addr 0x%llx pin %d irq %d sta %x\n",
	    DEVNAME(sc), aml_nodename(pp->node), addr, pin, irq, sta);
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.9 2006/12/21 11:23:41 deraadt Exp $	*/
d118 1
a118 1
	typ=AML_CRSTYPE(crs);
d174 1
a174 1
		if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, &res)) {
a175 1
		}
d178 1
a178 1
		if (aml_evalname(sc->sc_acpi, node, "_CRS", 0, NULL, &res)) {
a179 1
		}
d186 1
a186 2
				   acpiprt_getirq,
				   &irq);
d193 1
a193 1
	       DEVNAME(sc), aml_nodename(pp->node), addr, pin, irq, sta);
@


1.9
log
@more minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.8 2006/12/18 05:47:35 deraadt Exp $	*/
d121 2
a122 2
    		*irq = ffs(aml_letohost16(crs->sr_irq.irq_mask)) - 1;
    		break;
d124 6
a129 6
    		*irq = aml_letohost32(crs->lr_extirq.irq[0]);
    		break;
  	default:
    		printf("Unknown interrupt : %x\n", typ);
  	}
  	return (0);
d162 5
a166 5
	  	node = aml_searchname(sc->sc_devnode, pp->v_nameref);
	  	if (node == NULL) {
	    		printf("Invalid device!\n");
	    		return;
	  	}
@


1.8
log
@move proto to the right place
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.7 2006/11/27 23:43:47 jordan Exp $	*/
d195 1
a195 1
	printf("%s: %s addr 0x%llx pin %d irq %d sta %x\n", 
@


1.7
log
@Post-process PCI config space opregions
Fixed acpiprt for stinky presario v3000
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.6 2006/11/27 18:41:23 kettenis Exp $	*/
d45 1
a110 3

int
acpiprt_getirq(union acpi_resource *crs, void *arg);
@


1.6
log
@Make normal pic interrupt routing work too.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.5 2006/11/27 16:32:43 marco Exp $	*/
d140 1
a140 1
	int pin, irq;
d175 1
a175 1
	  	node = pp->node;
d179 1
d197 2
a198 1
	printf("%s: addr 0x%llx pin %d irq %d\n", DEVNAME(sc), addr, pin, irq);
@


1.5
log
@Add check for acpi pointer.  This prevents some ugly panics.

ok ketennis.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.4 2006/11/27 15:20:26 jordan Exp $	*/
d41 2
d139 3
a141 1
	int addr, pin, irq;
d144 6
d194 6
a209 4
#ifdef ACPI_DEBUG
	printf("%s: addr 0x%x pin %d irq %d\n", DEVNAME(sc), addr, pin, irq);
#endif

d225 21
@


1.4
log
@Fixes for acpiprt routing
Post-parse fixup for namerefs
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.2 2006/11/25 16:59:31 niklas Exp $	*/
d185 4
@


1.3
log
@Handle objrefs in _PRT.

ok jordan@@
@
text
@d88 1
a88 1
	sc->sc_devnode = aa->aaa_node->child;
d109 23
d136 1
a136 1
	struct aml_value res;
d148 3
d152 15
a166 13
	if (v->v_package[2]->type == AML_OBJTYPE_NAMEREF ||
	    v->v_package[2]->type == AML_OBJTYPE_OBJREF) {
		if (v->v_package[2]->type == AML_OBJTYPE_NAMEREF)
			node = aml_searchname(sc->sc_devnode,
			    v->v_package[2]->v_nameref);
		else
			node = v->v_package[2]->v_objref.ref->node;
		if (node == NULL) {
			printf(" invalid node!\n");
			return;
		}

		if (aml_evalname(sc->sc_acpi, node, "_STA", 0, NULL, NULL)) {
d178 4
a181 9

		if ((res.v_buffer[0] >> 3) == 0x4) {
			irq = res.v_buffer[1] + (res.v_buffer[2] << 8);
			irq = ffs(irq) - 1;
		} else {
			printf("unexpected _CSR object\n");
			return;
		}
	} else
d183 1
a183 1

d190 1
a190 1
#if ACPI_DEBUG
@


1.2
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpiprt.c,v 1.1 2006/11/15 21:39:06 kettenis Exp $	*/
d127 1
a127 1
	    v->v_package[2]->type == AML_OBJTYPE_DEVICE) {
d132 1
a132 1
			node = v->v_package[2]->node;
d154 3
@


1.1
log
@dd pseudo-devices to handle acpi apic interrupt routing.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d169 2
d176 2
a177 1
	    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) | (irq << APIC_INT_PIN_SHIFT));
d179 1
a179 1
	apic->sc_pins[irq].ip_map = map;
@

