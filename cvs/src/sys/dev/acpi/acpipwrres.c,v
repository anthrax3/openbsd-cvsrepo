head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.12
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.4.0.14
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.12
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.10
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.8
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.4
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.6;
commitid	uzzBR7hz9ncd4O6G;

1.6
date	2013.12.17.15.18.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.06.10.40.36;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.27.09.13.36;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.02.04.45.20;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.03.07.13.48;	author pirofti;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/* $OpenBSD: acpipwrres.c,v 1.6 2013/12/17 15:18:28 deraadt Exp $ */

/*
 * Copyright (c) 2013 Martin Pieuchot <mpi@@openbsd.org>
 * Copyright (c) 2009 Paul Irofti <pirofti@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

int	acpipwrres_match(struct device *, void *, void *);
void	acpipwrres_attach(struct device *, struct device *, void *);

#ifdef ACPIPWRRES_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

struct acpipwrres_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	SIMPLEQ_HEAD(, acpipwrres_consumer)	sc_cons;
	int					sc_cons_ref;

	int	sc_level;
	int	sc_order;
	int	sc_state;
#define ACPIPWRRES_OFF		0
#define ACPIPWRRES_ON		1
#define ACPIPWRRES_UNK		-1
};

struct acpipwrres_consumer {
	struct aml_node				*cs_node;
	SIMPLEQ_ENTRY(acpipwrres_consumer)	cs_next;
};

struct cfattach acpipwrres_ca = {
	sizeof(struct acpipwrres_softc), acpipwrres_match, acpipwrres_attach
};

struct cfdriver acpipwrres_cd = {
	NULL, "acpipwrres", DV_DULL
};

int	acpipwrres_hascons(struct acpipwrres_softc *, struct aml_node *);
int	acpipwrres_addcons(struct acpipwrres_softc *, struct aml_node *);
int	acpipwrres_foundcons(struct aml_node *, void *);

int
acpipwrres_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args *aaa = aux;
	struct cfdata		*cf = match;

	if (aaa->aaa_name == NULL || strcmp(aaa->aaa_name,
	    cf->cf_driver->cd_name) != 0 || aaa->aaa_table != NULL)
		return (0);

	return (1);
}

void
acpipwrres_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpipwrres_softc		*sc = (struct acpipwrres_softc *)self;
	struct acpi_attach_args		*aaa = aux;
	struct aml_value		res;
	struct acpipwrres_consumer	*cons;

	extern struct aml_node	aml_root;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aaa->aaa_node;
	memset(&res, 0, sizeof res);

	printf(": %s", sc->sc_devnode->name);

	if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &res)) {
		sc->sc_state = (int)aml_val2int(&res);
		if (sc->sc_state != ACPIPWRRES_ON &&
		    sc->sc_state != ACPIPWRRES_OFF)
			sc->sc_state = ACPIPWRRES_UNK;
	} else
		sc->sc_state = ACPIPWRRES_UNK;
	DPRINTF(("\n%s: state = %d\n", DEVNAME(sc), sc->sc_state));
	if (aml_evalnode(sc->sc_acpi, aaa->aaa_node, 0, NULL, &res) == 0) {
		sc->sc_level = res.v_powerrsrc.pwr_level;
		sc->sc_order = res.v_powerrsrc.pwr_order;
		DPRINTF(("%s: level = %d, order %d\n", DEVNAME(sc),
		    sc->sc_level, sc->sc_order));
		aml_freevalue(&res);
	}

	/* Get the list of consumers */
	SIMPLEQ_INIT(&sc->sc_cons);
#if notyet
	aml_find_node(&aml_root, "_PRW", acpipwrres_foundcons, sc);
#endif
	aml_find_node(&aml_root, "_PR0", acpipwrres_foundcons, sc);
	aml_find_node(&aml_root, "_PR1", acpipwrres_foundcons, sc);
	aml_find_node(&aml_root, "_PR2", acpipwrres_foundcons, sc);
	aml_find_node(&aml_root, "_PR3", acpipwrres_foundcons, sc);

	DPRINTF(("%s", DEVNAME(sc)));
	if (!SIMPLEQ_EMPTY(&sc->sc_cons)) {
		printf(", resource for");
		SIMPLEQ_FOREACH(cons, &sc->sc_cons, cs_next)
			printf(" %s%s", cons->cs_node->name,
			   (SIMPLEQ_NEXT(cons, cs_next) == NULL) ? "" : ",");
	}
	printf("\n");
}

int
acpipwrres_ref_incr(struct acpipwrres_softc *sc, struct aml_node *node)
{
	struct aml_value		res;

	if (!acpipwrres_hascons(sc, node))
		return (1);

	DPRINTF(("%s: dev %s ON %d\n", DEVNAME(sc), node->name,
	    sc->sc_cons_ref));

	if (sc->sc_cons_ref++ == 0) {
		memset(&res, 0, sizeof(res));
		aml_evalname(sc->sc_acpi, sc->sc_devnode, "_ON", 0,
		    NULL, &res);
		aml_freevalue(&res);
	}

	return (0);
}

int
acpipwrres_ref_decr(struct acpipwrres_softc *sc, struct aml_node *node)
{
	struct aml_value		res;

	if (!acpipwrres_hascons(sc, node))
		return (1);

	DPRINTF(("%s: dev %s OFF %d\n", DEVNAME(sc), node->name,
	    sc->sc_cons_ref));

	if (--sc->sc_cons_ref == 0) {
		memset(&res, 0, sizeof(res));
		aml_evalname(sc->sc_acpi, sc->sc_devnode, "_OFF", 0,
		    NULL, &res);
		aml_freevalue(&res);
	}

	return (0);
}

int
acpipwrres_hascons(struct acpipwrres_softc *sc, struct aml_node *node)
{
	struct acpipwrres_consumer	*cons;

	SIMPLEQ_FOREACH(cons, &sc->sc_cons, cs_next) {
		if (cons->cs_node == node)
			return (1);
	}

	return (0);
}

int
acpipwrres_addcons(struct acpipwrres_softc *sc, struct aml_node *node)
{
	struct acpipwrres_consumer	*cons;
	struct acpi_pwrres		*pr;
	int				state;

	/*
	 * Add handlers to put the device into Dx states.
	 *
	 * XXX What about PRW?
	 */
	if (strcmp(node->name, "_PR0") == 0) {
		state = ACPI_STATE_D0;
	} else if (strcmp(node->name, "_PR1") == 0) {
		state = ACPI_STATE_D1;
	} else if (strcmp(node->name, "_PR2") == 0) {
		state = ACPI_STATE_D2;
	} else if (strcmp(node->name, "_PR3") == 0) {
		state = ACPI_STATE_D3;
	} else {
		return (0);
	}

	if (!acpipwrres_hascons(sc, node->parent)) {
		cons = malloc(sizeof(*cons), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (cons == NULL)
			return (ENOMEM);

		cons->cs_node = node->parent;
		SIMPLEQ_INSERT_TAIL(&sc->sc_cons, cons, cs_next);
	}

	DPRINTF(("%s: resource for %s (D%d) \n", DEVNAME(sc),
	    node->parent->name, state));

	/*
	 * Make sure we attach only once the same Power Resource for a
	 * given state.
	 */
	SIMPLEQ_FOREACH(pr, &sc->sc_acpi->sc_pwrresdevs, p_next) {
		if (pr->p_node == node->parent &&
		    pr->p_res_state == state &&
		    pr->p_res_sc == sc) {
			DPRINTF(("error: pr for %s already set\n",
			   aml_nodename(pr->p_node)));
			return (EINVAL);
		}
	}

	pr = malloc(sizeof(struct acpi_pwrres), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (pr == NULL)
		return (ENOMEM);

	pr->p_node = node->parent;
	pr->p_state = -1;
	pr->p_res_state = state;
	pr->p_res_sc = sc;

	SIMPLEQ_INSERT_TAIL(&sc->sc_acpi->sc_pwrresdevs, pr, p_next);

	return (0);
}

int
acpipwrres_foundcons(struct aml_node *node, void *arg)
{
	struct acpipwrres_softc		*sc = (struct acpipwrres_softc *)arg;
	struct aml_value		res, *ref;
	int				i = 0;

	extern struct aml_node	aml_root;

	memset(&res, 0, sizeof(res));

	if (aml_evalnode(sc->sc_acpi, node, 0, NULL, &res) == -1) {
		DPRINTF(("pwr: consumer not found\n"));
		return (1);
	}

	if (res.type != AML_OBJTYPE_PACKAGE) {
		DPRINTF(("%s: %s is not a package\n", DEVNAME(sc),
		    aml_nodename(node)));
		aml_freevalue(&res);
		return (1);
	}

	DPRINTF(("%s: node name %s\n", DEVNAME(sc), aml_nodename(node)));
	if (!strcmp(node->name, "_PRW"))
		i = 2;          /* _PRW first two values are ints */

	for (; i < res.length; i++) {
		ref = res.v_package[i];

		if (ref->type == AML_OBJTYPE_STRING) {
			struct aml_node	*pnode;

			pnode = aml_searchrel(&aml_root, ref->v_string);
			if (pnode == NULL) {
				DPRINTF(("%s: device %s not found\n",
				    DEVNAME(sc), ref->v_string));
				continue;
			}
			ref = pnode->value;
		}

		if (ref->type == AML_OBJTYPE_OBJREF)
			ref = ref->v_objref.ref;

		if (ref->type != AML_OBJTYPE_POWERRSRC) {
			DPRINTF(("%s: object reference has a wrong type (%d)\n",
			    DEVNAME(sc), ref->type));
			continue;
		}

		if (ref->node == sc->sc_devnode)
			(void)acpipwrres_addcons(sc, node);
	}
	aml_freevalue(&res);

	return (0);
}
@


1.6
log
@do not put a second : in a dmesg line, use , instead
@
text
@d1 1
a1 1
/* $OpenBSD: acpipwrres.c,v 1.5 2013/11/06 10:40:36 mpi Exp $ */
a20 1
#include <sys/proc.h>
@


1.5
log
@Add support for Power Resources for Dx states and the necessary hook
for PCI devices.  This hook should be called twice, before and after
changing the power state of a PCI device.

Before setting the device to the new state, the ACPI layer will notify
every power resources linked to the device for that state and make sure
they are turned "_ON".  After changing the state of the device, it will
decrement the reference of every power resources linked to that device
for the old state and turn them "_OFF" if they are no longer referenced.

This fixes the no-USB after resume problem seen on various ThinkPad,
problem initialy diagnosed with Alexander Polakov.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpipwrres.c,v 1.4 2010/07/21 19:35:15 deraadt Exp $ */
d138 1
a138 1
		printf(": resource for");
@


1.4
log
@spacing and indents that are driving me crazy
@
text
@d1 2
a2 1
/* $OpenBSD: acpipwrres.c,v 1.3 2010/06/27 09:13:36 jordan Exp $ */
d4 1
d19 1
a36 4
int	acpipwrres_notify(struct aml_node *, int, void *);

#define	NOTIFY_PWRRES_OFF	0
#define NOTIFY_PWRRES_ON	1
d53 2
a54 1
	TAILQ_HEAD(acpipwrres_cons_h, acpipwrres_consumer)	sc_cons;
a57 1
	int	sc_ncons;
d66 1
a66 1
	TAILQ_ENTRY(acpipwrres_consumer)	cs_link;
d77 2
d97 4
a100 3
	struct acpipwrres_softc	*sc = (struct acpipwrres_softc *)self;
	struct acpi_attach_args *aaa = aux;
	struct aml_value	res;
d108 1
a108 4
	printf(": %s\n", sc->sc_devnode->name);

	aml_register_notify(sc->sc_devnode, aaa->aaa_dev,
	    acpipwrres_notify, sc, ACPIDEV_NOPOLL);
d117 1
a117 1
	DPRINTF(("%s: state = %d\n", DEVNAME(sc), sc->sc_state));
d127 2
a128 1
	TAILQ_INIT(&sc->sc_cons);
d130 1
d134 10
d147 1
a147 1
acpipwrres_notify(struct aml_node *node, int notify, void *arg)
a148 3
	int				fmatch = 0;
	struct acpipwrres_consumer	*cons;
	struct acpipwrres_softc		*sc = arg;
d151 2
a152 1
	memset(&res, 0, sizeof res);
d154 2
a155 7
	TAILQ_FOREACH(cons, &sc->sc_cons, cs_link)
		if (cons->cs_node == node) {
			fmatch = 1;
			break;
		}
	if (!fmatch)
		return (0);
d157 4
a160 6
	switch (notify) {
	case NOTIFY_PWRRES_ON:
		DPRINTF(("pwr: on devs %d\n", sc->sc_ncons));
		if (sc->sc_ncons++ == 0)
			aml_evalname(sc->sc_acpi, sc->sc_devnode, "_ON", 0, NULL,
			    &res);
d162 20
a181 6
		break;
	case NOTIFY_PWRRES_OFF:
		DPRINTF(("pwr: off devs %d\n", sc->sc_ncons));
		if (--sc->sc_ncons == 0)
			aml_evalname(sc->sc_acpi, sc->sc_devnode, "_OFF", 0, NULL,
			    &res);
a182 4
		break;
	default:
		printf("%s: unknown event 0x%02x\n", DEVNAME(sc), notify);
		break;
d189 77
d268 2
a270 4
	struct acpipwrres_consumer	*cons;
	struct aml_node			*pnode;
	struct acpipwrres_softc		*sc = (struct acpipwrres_softc *)arg;
	struct aml_value		res;
d274 1
a274 1
	memset(&res, 0, sizeof res);
d278 25
a302 14
		return (-1);
	} else {
		DPRINTF(("%s: node name %s\n", DEVNAME(sc), aml_nodename(node)));
		if (!strcmp(node->name, "_PRW"))
			i = 2;          /* _PRW first two values are ints */
		for (; i < res.length; i++) {
			pnode = aml_searchname(&aml_root,
			    res.v_package[i]->v_string);
			if (pnode == sc->sc_devnode) {
				DPRINTF(("%s: consumer match\n", DEVNAME(sc)));
				cons = malloc(sizeof *cons, M_DEVBUF,
				    M_WAITOK | M_ZERO);
				cons->cs_node = pnode;
				TAILQ_INSERT_HEAD(&sc->sc_cons, cons, cs_link);
d304 1
d306 12
d319 1
@


1.3
log
@Cleanup aml_find_node calls
@
text
@d1 1
a1 1
/* $OpenBSD: acpipwrres.c,v 1.2 2009/09/02 04:45:20 miod Exp $ */
d86 1
a86 1
	if (aaa->aaa_name == NULL || strcmp(aaa->aaa_name, 
d113 1
a113 1
		if (sc->sc_state != ACPIPWRRES_ON && 
d116 1
a116 1
	} else 
d122 1
a122 1
		DPRINTF(("%s: level = %d, order %d\n", DEVNAME(sc), 
d139 1
a139 1
	struct acpipwrres_consumer 	*cons;
d145 1
a145 1
	TAILQ_FOREACH(cons, &sc->sc_cons, cs_link) 
d182 1
a182 1
	struct acpipwrres_softc 	*sc = (struct acpipwrres_softc *)arg;
d194 1
a194 1
		if (!strcmp(node->name, "_PRW"))  
d201 1
a201 1
				cons = malloc(sizeof *cons, M_DEVBUF, 
@


1.2
log
@Invoke malloc() with the correct sizeof value in acpipwrres_foundcons().
This was harmless but eating too much memory.

ok pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpipwrres.c,v 1.1 2009/06/03 07:13:48 pirofti Exp $ */
d129 4
a132 4
	aml_find_node(aml_root.child, "_PRW", acpipwrres_foundcons, sc);
	aml_find_node(aml_root.child, "_PR0", acpipwrres_foundcons, sc);
	aml_find_node(aml_root.child, "_PR1", acpipwrres_foundcons, sc);
	aml_find_node(aml_root.child, "_PR2", acpipwrres_foundcons, sc);
@


1.1
log
@Import acpi power resource driver. This is needed for suspend/resume logic.

Okay jordan@@ and marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d201 1
a201 1
				cons = malloc(sizeof *pnode, M_DEVBUF, 
@

