head	1.52;
access;
symbols
	OPENBSD_6_1:1.51.0.6
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.2
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.49.0.2
	OPENBSD_5_9_BASE:1.49
	OPENBSD_5_8:1.49.0.4
	OPENBSD_5_8_BASE:1.49
	OPENBSD_5_7:1.47.0.6
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.44.0.8
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.4
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.52
date	2017.04.02.00.28.56;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	9c7lXTRRyHuYNucJ;

1.51
date	2016.05.24.04.37.39;	author semarie;	state Exp;
branches;
next	1.50;
commitid	KEW21nWe40WPiDAe;

1.50
date	2016.04.26.09.42.57;	author semarie;	state Exp;
branches;
next	1.49;
commitid	ZEmGqTk6vXPvhhU5;

1.49
date	2015.05.06.01.41.55;	author jsg;	state Exp;
branches;
next	1.48;
commitid	XMsX0YscElrmwbDQ;

1.48
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.47;
commitid	p4LJxGKbi0BU2cG6;

1.47
date	2014.07.12.02.44.49;	author mlarkin;	state Exp;
branches;
next	1.46;
commitid	tXDHXP98cNHVifao;

1.46
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.45;
commitid	zJyOCNTjgsYVGLiw;

1.45
date	2014.04.13.06.32.41;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2012.10.31.16.35.36;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.15.00.15.54;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.07.20.16.19;	author jordan;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.07.20.14.38;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.07.19.36.21;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.27.04.28.36;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.20.20.21.02;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.20.12.12.19;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.13.23.31.25;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.09.04.55.00;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.04.23.49.29;	author sthen;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.15.19.00.53;	author jordan;	state Exp;
branches;
next	1.31;

1.31
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.30;

1.30
date	2009.04.19.21.50.02;	author cnst;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.11.21.54.15;	author jordan;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.12.12.35.19;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.11.12.45.20;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.12.12.49.28;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.08.20.49.59;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.06.18.06.50;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.12.21.38.31;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.03.18.41.32;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.03.17.46.41;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.26.12.30.48;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.14.01.31.12;	author deanna;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.19.18.17.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.18.20.57.45;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.29.22.17.07;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.02.04.58.20;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.02.04.56.13;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.24.20.30.00;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.24.19.58.03;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.19.01.19.15;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2006.07.30.05.30.45;	author gwk;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.19.09.24.32;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.52
log
@normalize order of arguments to if ()
@
text
@/* $OpenBSD: acpitz.c,v 1.51 2016/05/24 04:37:39 semarie Exp $ */
/*
 * Copyright (c) 2006 Can Erkin Acar <canacar@@openbsd.org>
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/kthread.h>

#include <machine/bus.h>

#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <sys/sensors.h>

#define KTOC(k)			((k - 2732) / 10)
#define ACPITZ_MAX_AC		(10)
#define ACPITZ_TMP_RETRY	(3)
#define ACPITZ_UNKNOWN		(-1)

struct acpitz_softc {
	struct device		sc_dev;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	int			sc_tmp;
	int			sc_crt;
	int			sc_hot;
	int			sc_ac[ACPITZ_MAX_AC];
	int			sc_ac_stat[ACPITZ_MAX_AC];
	int			sc_pse;
	int			sc_psv;
	int			sc_tc1;
	int			sc_tc2;
	int			sc_lasttmp;

	struct ksensor		sc_sens;
	struct ksensordev	sc_sensdev;

	struct acpi_devlist_head	sc_psl;
	struct acpi_devlist_head	sc_alx[ACPITZ_MAX_AC];
};

int	acpitz_match(struct device *, void *, void *);
void	acpitz_attach(struct device *, struct device *, void *);
int	acpitz_activate(struct device *, int);

struct cfattach acpitz_ca = {
	sizeof(struct acpitz_softc), acpitz_match, acpitz_attach,
	NULL, acpitz_activate
};

struct cfdriver acpitz_cd = {
	NULL, "acpitz", DV_DULL
};

void	acpitz_init_perf(void *);
void	acpitz_setperf(int);
void	acpitz_monitor(struct acpitz_softc *);
void	acpitz_refresh(void *);
int	acpitz_notify(struct aml_node *, int, void *);
int	acpitz_gettempreading(struct acpitz_softc *, char *);
int	acpitz_getreading(struct acpitz_softc *, char *);
int	acpitz_setfan(struct acpitz_softc *, int, char *);
void	acpitz_init(struct acpitz_softc *, int);

void		(*acpitz_cpu_setperf)(int);
int		acpitz_perflevel = -1;
extern void	(*cpu_setperf)(int);
extern int	perflevel;
#define PERFSTEP 10

#define ACPITZ_TRIPS	(1L << 0)
#define ACPITZ_DEVLIST	(1L << 1)
#define ACPITZ_INIT	(ACPITZ_TRIPS|ACPITZ_DEVLIST)

extern struct aml_node aml_root;

void
acpitz_init_perf(void *arg)
{
	if (acpitz_perflevel == -1)
		acpitz_perflevel = perflevel;

	if (cpu_setperf != acpitz_setperf) {
		acpitz_cpu_setperf = cpu_setperf;
		cpu_setperf = acpitz_setperf;
	}
}

void
acpitz_setperf(int level)
{
	extern struct acpi_softc *acpi_softc;

	if (level < 0 || level > 100)
		return;

	if (acpi_softc == NULL)
		return;
	if (acpi_softc->sc_pse && level > acpitz_perflevel)
		return;

	if (acpitz_cpu_setperf)
		acpitz_cpu_setperf(level);
}

void
acpitz_init(struct acpitz_softc *sc, int flag)
{
	int i;
	char name[5];
	struct aml_value res;

	/* Read trip points */
	if (flag & ACPITZ_TRIPS) {
		sc->sc_psv = acpitz_getreading(sc, "_PSV");
		for (i = 0; i < ACPITZ_MAX_AC; i++) {
			snprintf(name, sizeof(name), "_AC%d", i);
			sc->sc_ac[i] = acpitz_getreading(sc, name);
		}
	}

	/* Read device lists */
	if (flag & ACPITZ_DEVLIST) {
		if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSL",
		     0, NULL, &res)) {
			acpi_freedevlist(&sc->sc_psl);
			acpi_getdevlist(&sc->sc_psl, sc->sc_devnode, &res, 0);
			aml_freevalue(&res);
		}
		for (i = 0; i < ACPITZ_MAX_AC; i++) {
			snprintf(name, sizeof(name), "_AL%d", i);
			if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, name,
			    0, NULL, &res)) {
				acpi_freedevlist(&sc->sc_alx[i]);
				acpi_getdevlist(&sc->sc_alx[i],
				    sc->sc_devnode, &res, 0);
				aml_freevalue(&res);
			}
			/* initialize current state to unknown */
			sc->sc_ac_stat[i] = ACPITZ_UNKNOWN;
		}
	}
}

int
acpitz_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;

	/* sanity */
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	if (aa->aaa_node->value->type != AML_OBJTYPE_THERMZONE)
		return (0);

	return (1);
}

void
acpitz_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpitz_softc *sc = (struct acpitz_softc *)self;
	struct acpi_attach_args	*aa = aux;
	int i;
	char name[5];

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	TAILQ_INIT(&sc->sc_psl);
	for (i = 0; i < ACPITZ_MAX_AC; i++)
		TAILQ_INIT(&sc->sc_alx[i]);

	/*
	 * Preread the trip points (discard/ignore values read here as we will
	 * re-read them later)
	 */
	acpitz_gettempreading(sc, "_CRT");
	acpitz_gettempreading(sc, "_HOT");
	acpitz_gettempreading(sc, "_PSV");
	for (i = 0; i < ACPITZ_MAX_AC; i++) {
		snprintf(name, sizeof(name), "_AC%d", i);
		acpitz_getreading(sc, name);
	}
	acpitz_gettempreading(sc, "_TMP");

	sc->sc_lasttmp = -1;
	if ((sc->sc_tmp = acpitz_gettempreading(sc, "_TMP")) == -1) {
		dnprintf(10, ": failed to read _TMP\n");
		return;
	}

	if ((sc->sc_crt = acpitz_gettempreading(sc, "_CRT")) == -1)
		printf(": no critical temperature defined\n");
	else
		printf(": critical temperature is %d degC\n", KTOC(sc->sc_crt));

	sc->sc_hot = acpitz_gettempreading(sc, "_HOT");
	sc->sc_tc1 = acpitz_getreading(sc, "_TC1");
	sc->sc_tc2 = acpitz_getreading(sc, "_TC2");

	/* get _PSL, _ALx */
	acpitz_init(sc, ACPITZ_INIT);

	dnprintf(10, "%s: _HOT: %d _TC1: %d _TC2: %d _PSV: %d _TMP: %d "
	    "_CRT: %d\n", DEVNAME(sc), sc->sc_hot, sc->sc_tc1, sc->sc_tc2,
	    sc->sc_psv, sc->sc_tmp, sc->sc_crt);

	strlcpy(sc->sc_sensdev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensdev.xname));
	strlcpy(sc->sc_sens.desc, "zone temperature",
	    sizeof(sc->sc_sens.desc));
	sc->sc_sens.type = SENSOR_TEMP;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens);
	sensordev_install(&sc->sc_sensdev);

	aml_register_notify(sc->sc_devnode, NULL,
	    acpitz_notify, sc, ACPIDEV_POLL);

	/*
	 * XXX use kthread_create_deferred to ensure we are the very last
	 * piece of code that touches this pointer after all CPUs have been
	 * fully attached
	 */
	kthread_create_deferred(acpitz_init_perf, sc);
}

int
acpitz_activate(struct device *self, int act)
{
	struct acpitz_softc	*sc = (struct acpitz_softc *)self;

	switch (act) {
	case DVACT_WAKEUP:
		acpitz_init(sc, ACPITZ_INIT);
		break;
	}
	return 0;
}

int
acpitz_setfan(struct acpitz_softc *sc, int i, char *method)
{
	struct aml_node		*node;
	struct aml_value	res1, *ref;
	char			name[8];
	int			rv = 1, x, y;
	int64_t			sta;
	struct acpi_devlist    *dl;

	dnprintf(20, "%s: acpitz_setfan(%d, %s)\n", DEVNAME(sc), i, method);

	x = 0;
	snprintf(name, sizeof(name), "_AL%d", i);
	TAILQ_FOREACH(dl, &sc->sc_alx[i], dev_link) {
		if (aml_evalname(sc->sc_acpi, dl->dev_node, "_PR0",0 , NULL,
		    &res1)) {
			printf("%s: %s[%d] _PR0 failed\n", DEVNAME(sc),
			    name, x);
			aml_freevalue(&res1);
			x++;

			/*
			 * This fan lacks the right method to operate:
			 * disabling active cooling trip points.
			 */
			sc->sc_ac[i] = -1;
			continue;
		}
		if (res1.type != AML_OBJTYPE_PACKAGE) {
			printf("%s: %s[%d] _PR0 not a package\n", DEVNAME(sc),
			    name, x);
			aml_freevalue(&res1);
			x++;
			continue;
		}
		for (y = 0; y < res1.length; y++) {
			ref = res1.v_package[y];
			if (ref->type == AML_OBJTYPE_STRING) {
				node = aml_searchrel(sc->sc_devnode,
				    ref->v_string);
				if (node == NULL) {
					printf("%s: %s[%d.%d] _PRO"
					    " not a valid device\n",
					    DEVNAME(sc), name, x, y);
					continue;
				}
				ref = node->value;
			}
			if (ref->type == AML_OBJTYPE_OBJREF) {
				ref = ref->v_objref.ref;
			}
			if (ref->type != AML_OBJTYPE_DEVICE &&
			    ref->type != AML_OBJTYPE_POWERRSRC) {
				printf("%s: %s[%d.%d] _PRO not a package\n",
				    DEVNAME(sc), name, x, y);
				continue;
			}
			if (aml_evalname(sc->sc_acpi, ref->node, method, 0,
			    NULL, NULL))
				printf("%s: %s[%d.%d] %s fails\n",
				    DEVNAME(sc), name, x, y, method);

			/* save off status of fan */
			if (aml_evalinteger(sc->sc_acpi, ref->node, "_STA", 0,
			    NULL, &sta))
				printf("%s: %s[%d.%d] _STA fails\n",
				    DEVNAME(sc), name, x, y);
			else {
				sc->sc_ac_stat[i] = sta;
			}
		}
		aml_freevalue(&res1);
		x++;
	}
	rv = 0;
	return (rv);
}

void
acpitz_refresh(void *arg)
{
	struct acpitz_softc	*sc = arg;
	int			i, trend, nperf;

	dnprintf(30, "%s: %s: refresh\n", DEVNAME(sc),
	    sc->sc_devnode->name);

	/* get _TMP and debounce the value */
	if ((sc->sc_tmp = acpitz_gettempreading(sc, "_TMP")) == -1) {
		printf("%s: %s: failed to read temp\n", DEVNAME(sc),
		    sc->sc_devnode->name);
		return;
	}
	/* critical trip points */
	if (sc->sc_crt != -1 && sc->sc_crt <= sc->sc_tmp) {
		/* do critical shutdown */
		printf("%s: critical temperature exceeded %dC, shutting "
		    "down\n", DEVNAME(sc), KTOC(sc->sc_tmp));
		prsignal(initprocess, SIGUSR2);
	}
	if (sc->sc_hot != -1 && sc->sc_hot <= sc->sc_tmp) {
		printf("%s: _HOT temperature\n", DEVNAME(sc));
		/* XXX go to S4, until then cool as hard as we can */
	}

	/* passive cooling */
	if (sc->sc_lasttmp != -1 && sc->sc_tc1 != -1 && sc->sc_tc2 != -1 &&
	    sc->sc_psv != -1) {
		dnprintf(30, "%s: passive cooling: lasttmp: %d tc1: %d "
		    "tc2: %d psv: %d\n", DEVNAME(sc), sc->sc_lasttmp,
		    sc->sc_tc1, sc->sc_tc2, sc->sc_psv);

		nperf = acpitz_perflevel;
		if (sc->sc_psv <= sc->sc_tmp) {
			/* Passive cooling enabled */
			dnprintf(1, "%s: enabling passive %d %d\n",
			    DEVNAME(sc), sc->sc_tmp, sc->sc_psv);
			if (!sc->sc_pse)
				sc->sc_acpi->sc_pse++;
			sc->sc_pse = 1;

			trend = sc->sc_tc1 * (sc->sc_tmp - sc->sc_lasttmp) +
			    sc->sc_tc2 * (sc->sc_tmp - sc->sc_psv);

			/* Depending on trend, slow down/speed up */
			if (trend > 0)
				nperf -= PERFSTEP;
			else
				nperf += PERFSTEP;
		}
		else {
			/* Passive cooling disabled, increase % */
			dnprintf(1, "%s: disabling passive %d %d\n",
			    DEVNAME(sc), sc->sc_tmp, sc->sc_psv);
			if (sc->sc_pse)
				sc->sc_acpi->sc_pse--;
			sc->sc_pse = 0;
			nperf += PERFSTEP;
		}
		if (nperf < 0)
			nperf = 0;
		else if (nperf > 100)
			nperf = 100;

		/* clamp passive cooling request */
		if (nperf > perflevel)
			nperf = perflevel;

		/* Perform CPU setperf */
		if (acpitz_cpu_setperf && nperf != acpitz_perflevel) {
			acpitz_perflevel = nperf;
			acpitz_cpu_setperf(nperf);
		}
	}
	sc->sc_lasttmp = sc->sc_tmp;

	/* active cooling */
	for (i = 0; i < ACPITZ_MAX_AC; i++) {
		if (sc->sc_ac[i] != -1 && sc->sc_ac[i] <= sc->sc_tmp) {
			/* turn on fan i */
			if (sc->sc_ac_stat[i] <= 0)
				acpitz_setfan(sc, i, "_ON_");
		} else if (sc->sc_ac[i] != -1) {
			/* turn off fan i */
			if ((sc->sc_ac_stat[i] == ACPITZ_UNKNOWN) ||
			    (sc->sc_ac_stat[i] > 0))
				acpitz_setfan(sc, i, "_OFF");
		}
	}
	sc->sc_sens.value = sc->sc_tmp * 100000 - 50000;
}

int
acpitz_getreading(struct acpitz_softc *sc, char *name)
{
	u_int64_t		val;

	if (!aml_evalinteger(sc->sc_acpi, sc->sc_devnode, name, 0, NULL, &val))
		return (val);

	return (-1);
}

int
acpitz_gettempreading(struct acpitz_softc *sc, char *name)
{
	int			rv = -1, tmp = -1, i;

	for (i = 0; i < ACPITZ_TMP_RETRY; i++) {
		tmp = acpitz_getreading(sc, name);
		if (tmp == -1)
			goto out;
		if (KTOC(tmp) >= 0) {
			rv = tmp;
			break;
		} else {
			dnprintf(20, "%s: %d invalid reading on %s, "
			    "debouncing\n", DEVNAME(sc), tmp, name);
		}

		acpi_sleep(1000, "acpitz");	/* debounce: 1000 msec */
	}
	if (i >= ACPITZ_TMP_RETRY) {
		printf("%s: %s: failed to read %s\n", DEVNAME(sc),
		    sc->sc_devnode->name, name);
		goto out;
	}
 out:
	dnprintf(30, "%s: name: %s tmp: %d => %dC, rv: %d\n", DEVNAME(sc),
	    name, tmp, KTOC(tmp), rv);
	return (rv);
}

int
acpitz_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct acpitz_softc	*sc = arg;

	dnprintf(10, "%s notify: %.2x %s\n", DEVNAME(sc), notify_type,
	    sc->sc_devnode->name);

	switch (notify_type) {
	case 0x80:	/* hardware notifications */
		break;
	case 0x81:	/* operating Points changed */
		acpitz_init(sc, ACPITZ_TRIPS);
		break;
	case 0x82:	/* re-evaluate thermal device list */
		acpitz_init(sc, ACPITZ_DEVLIST);
		break;
	default:
		break;
	}

	acpitz_refresh(sc);
	return (0);
}
@


1.51
log
@Disabling active cooling trip points when we lack the right method to operate.

Problem reported by James Hastings.

ok dcoppa@@ mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.50 2016/04/26 09:42:57 semarie Exp $ */
d358 1
a358 1
	if (-1 == (sc->sc_tmp = acpitz_gettempreading(sc, "_TMP"))) {
@


1.50
log
@corrects acpitz problem with active cooling and hysterisis

"if the temperature is below the active cooling level for a tz, turn the fan off
regardless of what state it is currently in"

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.49 2015/05/06 01:41:55 jsg Exp $ */
d290 6
@


1.49
log
@Use | when combining flags not +.  Luckily in this case 1 + 2 == 1 | 2.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.48 2015/03/14 03:38:46 jsg Exp $ */
d40 1
a142 1
			sc->sc_ac_stat[i] = -1;
d163 2
d428 2
a429 1
			if (sc->sc_ac_stat[i] > 0)
@


1.48
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.47 2014/07/12 02:44:49 mlarkin Exp $ */
d96 1
a96 1
#define ACPITZ_INIT	ACPITZ_TRIPS+ACPITZ_DEVLIST
@


1.47
log
@Preread the thermal zone trip points before reading the temperature value.
This is needed on some (specifically HP) machines to avoid _TMP reporting
a bogus temperature value (temperatures > 4,000 degC), which causes acpitz
to automatically shut down the machine because it thinks it's floating in
lava.

Also ensure that we can accept a temperature reading of 0 degC - we were
previously interpreting 0 degC as "bad temperature data" and not attaching
the thermal zone device. Some machines have ephemeral temperature sensors
that come and go (eg in docks) and we want to make sure we attach those
even if they report back 0 degC on initialization. Fixes some machines
with "failed to read _TMP" errors.

ok deraadt, tested and verified by a few folks on tech@@ who were seeing
the thermal zone shutdown isue.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.46 2014/07/11 08:18:31 guenther Exp $ */
a29 1
#include <dev/acpi/acpireg.h>
@


1.46
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.45 2014/04/13 06:32:41 deraadt Exp $ */
d189 1
a189 1
	struct acpitz_softc	*sc = (struct acpitz_softc *)self;
d191 2
a192 1
	int			i;
d201 13
d454 1
a454 1
		if (KTOC(tmp) > 0) {
@


1.45
log
@perform the same ACPITZ_INIT operation as attach does, at DVACT_WAKEUP
time also.  Let's commit this idea since it is sound, and keep an eye
for reports.
discussed months ago with kettenis and mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.44 2012/10/31 16:35:36 deraadt Exp $ */
d347 1
a347 1
		psignal(initproc, SIGUSR2);
@


1.44
log
@don't show Kelvin units, and don't be off by a factor of 10 either.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.43 2011/06/15 00:15:54 marco Exp $ */
d68 1
d71 2
a72 1
	sizeof(struct acpitz_softc), acpitz_match, acpitz_attach
d239 13
@


1.43
log
@try to make critical messages make more sense.  help from sthen.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.42 2011/04/07 20:16:19 jordan Exp $ */
d330 2
a331 3
		printf("%s: critical temperature exceeded %dC (%dK), shutting "
		    "down\n",
		    DEVNAME(sc), KTOC(sc->sc_tmp), sc->sc_tmp);
d441 1
a441 1
	dnprintf(30, "%s: name: %s tmp: %dK => %dC, rv: %d\n", DEVNAME(sc),
@


1.42
log
@Fix uninitialized name and x variables in setfan
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.41 2011/04/07 20:14:38 marco Exp $ */
d207 1
a207 1
		printf(": critical temperature %d degC\n", KTOC(sc->sc_crt));
d330 2
a331 1
		printf("%s: Critical temperature %dC (%dK), shutting down\n",
@


1.41
log
@Revert prior diff that I ok because I don't know how to read.  Real fix
coming soon after this revert.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.39 2010/07/27 04:28:36 marco Exp $ */
d251 2
d259 1
d266 1
d306 1
@


1.40
log
@Fix device names in acpitz_setfan() printf messages, which got broken in
1.32. ok marco@@
@
text
@d245 1
a245 1
	int			rv = 1, y;
d255 1
a255 1
			    name, i);
d261 1
a261 1
			    name, i);
d273 1
a273 1
					    DEVNAME(sc), name, i, y);
d284 1
a284 1
				    DEVNAME(sc), name, i, y);
d290 1
a290 1
				    DEVNAME(sc), name, i, y, method);
d296 1
a296 1
				    DEVNAME(sc), name, i, y);
@


1.39
log
@replace acpitz_getreading goo with proper aml_evalinteger.

From jordan.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.38 2010/07/21 19:35:15 deraadt Exp $ */
d245 1
a245 1
	int			rv = 1, x, y;
d255 1
a255 1
			    name, x);
d261 1
a261 1
			    name, x);
d273 1
a273 1
					    DEVNAME(sc), name, x, y);
d284 1
a284 1
				    DEVNAME(sc), name, x, y);
d290 1
a290 1
				    DEVNAME(sc), name, x, y, method);
d296 1
a296 1
				    DEVNAME(sc), name, x, y);
@


1.38
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.37 2010/07/20 20:21:02 deraadt Exp $ */
d403 1
a403 2
	struct aml_value	res, *ref;
	int			rv = -1;
d405 4
a408 20
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, name, 0, NULL, &res)) {
		dnprintf(10, "%s: acpitz_getreading: no %s\n", DEVNAME(sc),
		    name);
		goto out;
	}
	if (res.type == AML_OBJTYPE_STRING) {
		struct aml_node *node;
		node = aml_searchrel(sc->sc_devnode, res.v_string);
		if (node == NULL)
			goto out;
		ref = node->value;
	} else
		ref = &res;
	if (ref->type == AML_OBJTYPE_OBJREF) {
		ref = ref->v_objref.ref;
	}
	rv = aml_val2int(ref);
out:
	aml_freevalue(&res);
	return (rv);
@


1.37
log
@print the temperature readings that make us go down; ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.36 2010/07/20 12:12:19 deraadt Exp $ */
d147 1
a147 1
		if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSL", 
d158 1
a158 1
				acpi_getdevlist(&sc->sc_alx[i], 
d337 1
a337 1
	    	dnprintf(30, "%s: passive cooling: lasttmp: %d tc1: %d "
d344 1
a344 1
			dnprintf(1, "%s: enabling passive %d %d\n", 
d356 1
a356 1
			else 
d361 1
a361 1
			dnprintf(1, "%s: disabling passive %d %d\n", 
@


1.36
log
@tsleep() and EWOULDBLOCK was being used incorrectly for fixed minumum
delays.  tsleep() on an unknown wait channel, to ensure the minimum is
met, and that wakeup()'s don't make the delay get restarted over and
over..
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.35 2010/01/13 23:31:25 marco Exp $ */
d325 2
a326 2
		printf("%s: Critical temperature, shutting down\n",
		    DEVNAME(sc));
@


1.35
log
@Make sure that acpitz is always the last one to replace the global
cpu_setperf pointer so that it is always the first to be notified of any
changes.  This fixes the reported "creeping up" of performance level when
using apmd and several overheating issues people reported.

Tested by many, ok kettenis with a large XXX on it.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.34 2009/12/09 04:55:00 marco Exp $ */
d445 1
a445 6
		/* debounce value */
		if (cold)
			delay(1000000);
		else
			while (tsleep(sc, PWAIT, "tzsleep", hz) !=
			    EWOULDBLOCK);
@


1.34
log
@disable useles print
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.33 2009/12/04 23:49:29 sthen Exp $ */
d26 1
d77 2
a85 3
#if 0
int	acpitz_setcpu(struct acpitz_softc *, int);
#endif
d87 4
a90 2
extern void (*cpu_setperf)(int);
extern int perflevel;
d100 29
a229 8
}

#if 0
int
acpitz_setcpu(struct acpitz_softc *sc, int perc)
{
	struct aml_value res0, *ref;
	int x;
d231 6
a236 21
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSL", 0, NULL, &res0)) {
		printf("%s: _PSL failed\n", DEVNAME(sc));
		goto out;
	}
	if (res0.type != AML_OBJTYPE_PACKAGE) {
		printf("%s: not a package\n", DEVNAME(sc));
		goto out;
	}
	for (x = 0; x < res0.length; x++) {
		if (res0.v_package[x]->type != AML_OBJTYPE_OBJREF) {
			printf("%s: _PSL[%d] not a object ref\n",
			    DEVNAME(sc), x);
			continue;
		}
		ref = res0.v_package[x]->v_objref.ref;
		if (ref->type != AML_OBJTYPE_PROCESSOR)
			printf("%s: _PSL[%d] not a CPU\n", DEVNAME(sc), x);
	}
 out:
	aml_freevalue(&res0);
	return (0);
a237 1
#endif
d341 1
a341 1
		nperf = perflevel;
d373 4
d378 3
a380 3
		if (cpu_setperf && nperf != perflevel) {
			perflevel = nperf;
			cpu_setperf(nperf);
@


1.33
log
@KNF whitespace, from Brad. ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.32 2009/10/15 19:00:53 jordan Exp $ */
d169 1
a169 1
		printf(": failed to read _TMP\n");
@


1.32
log
@Implement passive cooling for acpitz; works for some overheating machines
Counter in parent for disabling setperf when passive cooling enabled
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.31 2009/04/26 02:20:58 cnst Exp $ */
d107 1
a107 1
		for (i=0; i<ACPITZ_MAX_AC; i++) {
d122 1
a122 1
		for (i=0; i<ACPITZ_MAX_AC; i++) {
d164 1
a164 1
	for (i=0; i<ACPITZ_MAX_AC; i++)
@


1.31
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.30 2009/04/19 21:50:02 cnst Exp $ */
d57 1
d60 3
d82 1
d87 48
a158 1
	char			name[8];
d163 4
a177 6
	for (i = 0; i < ACPITZ_MAX_AC; i++) {
		snprintf(name, sizeof name, "_AC%d", i);
		sc->sc_ac[i] = acpitz_gettempreading(sc, name);
		sc->sc_ac_stat[0] = -1;
	}

d181 4
a184 1
	sc->sc_psv = acpitz_gettempreading(sc, "_PSV");
a188 2
	/* get _PSL */

d236 1
a236 1
	struct aml_value	res0, res1, *ref;
d240 1
d244 2
a245 31
	snprintf(name, sizeof name, "_AL%d", i);
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, name, 0, NULL, &res0)) {
		dnprintf(20, "%s: %s failed\n", DEVNAME(sc), name);
		goto out;
	}

	if (res0.type != AML_OBJTYPE_PACKAGE) {
		printf("%s: %s not a package\n", DEVNAME(sc), name);
		goto out;
	}

	for (x = 0; x < res0.length; x++) {
		ref = res0.v_package[x];
		if (ref->type == AML_OBJTYPE_STRING) {
			node = aml_searchrel(sc->sc_devnode, ref->v_string);
			if (node == NULL) {
				printf("%s: %s[%d] not a valid device\n",
				    DEVNAME(sc), name, x);
				continue;
			}
			ref = node->value;
		}
		if (ref->type == AML_OBJTYPE_OBJREF) {
			ref = ref->v_objref.ref;
		}
		if (ref->type != AML_OBJTYPE_DEVICE) {
			printf("%s: %s[%d] not a valid object\n", DEVNAME(sc),
			    name, x);
			continue;
		}
		if (aml_evalname(sc->sc_acpi, ref->node, "_PR0",0 , NULL,
a296 2
out:
	aml_freevalue(&res0);
d304 1
a304 1
	int			i, perc;
d333 2
d336 5
d342 2
a343 1
			perc = sc->sc_tc1 * (sc->sc_tmp - sc->sc_lasttmp) +
d345 13
a357 7
			perc /= 10;
			if (perc < 0)
				perc = 0;
			else if (perc > 100)
				perc = 100;
			/* printf("_TZ perc = %d\n", perc); */
		} else if (sc->sc_pse)
d359 12
a455 1
	int			crt;
d464 1
a464 6
		sc->sc_psv = acpitz_gettempreading(sc, "_PSV");
		crt = sc->sc_crt;
		sc->sc_crt = acpitz_gettempreading(sc, "_CRT");
		if (crt != sc->sc_crt)
			printf("%s: new critical temperature: %u degC",
			    DEVNAME(sc), KTOC(sc->sc_crt));
d467 1
@


1.30
log
@zero temperature in acpi refers to -273,2degC -- convert to uK appropriately;   ok deraadt marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.29 2009/03/11 21:54:15 jordan Exp $ */
a144 1
	sc->sc_sens.value = 0;
@


1.29
log
@More aml_evalinteger fixup
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.28 2008/09/12 12:35:19 miod Exp $ */
d340 1
a340 1
	sc->sc_sens.value = sc->sc_tmp * 100000;
@


1.28
log
@In acpitz_setfan(), try to send fan commands to ``power resources'' objects.
Makes a few hp laptops run cooler and quieter.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.27 2008/09/11 12:45:20 miod Exp $ */
d186 1
a186 1
	struct aml_value	res0, res1, res2, *ref;
d189 1
d264 2
a265 2
			if (aml_evalname(sc->sc_acpi, ref->node, "_STA", 0,
			    NULL, &res2))
d269 1
a269 2
				sc->sc_ac_stat[i] = aml_val2int(&res2);
				aml_freevalue(&res2);
@


1.27
log
@Thermal Zone entities might not be direct object references, but named
references. Account for this, and the hp530 laptop won't spontaneously
power down thinking internal temperature is over 500C.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.26 2008/06/01 17:59:55 marco Exp $ */
d251 2
a252 1
			if (ref->type != AML_OBJTYPE_DEVICE) {
@


1.26
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.24 2008/05/14 05:24:36 jordan Exp $ */
d185 1
d204 15
a218 2
		if (res0.v_package[x]->type != AML_OBJTYPE_OBJREF) {
			printf("%s: %s[%d] not a object ref\n", DEVNAME(sc),
a221 1
		ref = res0.v_package[x]->v_objref.ref;
d236 17
a252 2
			if (res1.v_package[y]->type != AML_OBJTYPE_OBJREF) {
				printf("%s: %s[%d.%d] _PR0 not a package\n",
a255 1
			ref = res1.v_package[y]->v_objref.ref;
d345 1
a345 1
	struct aml_value	res;
d353 12
a364 1
	rv = aml_val2int(&res);
@


1.25
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.23 2008/04/12 12:49:28 kettenis Exp $ */
d78 1
d80 1
d109 1
a109 1
	sc->sc_devnode = aa->aaa_node->child;
d147 1
a147 1
	aml_register_notify(sc->sc_devnode->parent, NULL,
d151 1
d180 1
d259 1
a259 1
	    sc->sc_devnode->parent->name);
d264 1
a264 1
		    sc->sc_devnode->parent->name);
d358 1
a358 1
		    sc->sc_devnode->parent->name, name);
d374 1
a374 1
	    sc->sc_devnode->parent->name);
@


1.24
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d107 1
a107 1
	sc->sc_devnode = aa->aaa_node;
d145 1
a145 1
	aml_register_notify(sc->sc_devnode, NULL,
d255 1
a255 1
	    sc->sc_devnode->name);
d260 1
a260 1
		    sc->sc_devnode->name);
d354 1
a354 1
		    sc->sc_devnode->name, name);
d370 1
a370 1
	    sc->sc_devnode->name);
@


1.23
log
@Get rid of acpi_s5 global variables; simply send SIGUSR2 instead of SUGUSR1
to tell init(8) to power down the machine.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.22 2008/01/08 20:49:59 marco Exp $ */
d107 1
a107 1
	sc->sc_devnode = aa->aaa_node->child;
d145 1
a145 1
	aml_register_notify(sc->sc_devnode->parent, NULL,
d255 1
a255 1
	    sc->sc_devnode->parent->name);
d260 1
a260 1
		    sc->sc_devnode->parent->name);
d354 1
a354 1
		    sc->sc_devnode->parent->name, name);
d370 1
a370 1
	    sc->sc_devnode->parent->name);
@


1.22
log
@Don't free res twice.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.21 2008/01/06 18:06:50 marco Exp $ */
a252 1
	extern int		acpi_s5;
d268 1
a268 2
		acpi_s5 = 1;
		psignal(initproc, SIGUSR1);
@


1.21
log
@Add a more robust gettempreading that debounces the value (idea from FreeBSD)
Add a macro to convert from K to C
Redo notify and sprinkle some debug

Tested on D810 T60 & Q2010 and tested by several others.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.20 2007/11/12 21:38:31 deraadt Exp $ */
d320 2
a321 2
		dnprintf(10, "%s: acpitz_getreading: no %s\n", DEVNAME(sc), name);
		aml_freevalue(&res);
@


1.20
log
@a little less excitement (every printf does not need to end in !)
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.19 2007/11/03 18:41:32 deraadt Exp $ */
d25 1
d37 3
a39 1
#define ACPITZ_MAX_AC		10
d75 1
d110 1
a110 1
	if ((sc->sc_tmp = acpitz_getreading(sc, "_TMP")) == -1) {
d115 1
a115 1
	if ((sc->sc_crt = acpitz_getreading(sc, "_CRT")) == -1) {
d117 2
a118 4
		sc->sc_crt = 0;
	} else
		printf(": critical temperature %d degC\n",
		    (sc->sc_crt - 2732) / 10);
d122 1
a122 1
		sc->sc_ac[i] = acpitz_getreading(sc, name);
d126 1
a126 1
	sc->sc_hot = acpitz_getreading(sc, "_HOT");
d129 6
a134 1
	sc->sc_psv = acpitz_getreading(sc, "_PSV");
d150 1
a150 1
acpitz_setcpu(struct acpitz_softc *sc, int trend)
d165 2
a166 1
			printf("%s: _PSL[%d] not a object ref\n", DEVNAME(sc), x);
d252 1
a252 1
	int			i, trend;
d258 3
a260 2
	if (-1 == (sc->sc_tmp = acpitz_getreading(sc, "_TMP"))) {
		dnprintf(30, "%s: %s: failed to read temp\n", DEVNAME(sc),
d262 1
a262 1
		sc->sc_tmp = 0;	/* XXX */
d264 1
a264 1

d266 1
a266 1
		/* Do critical shutdown */
d272 1
a272 1
	if (sc->sc_hot != -1 && sc->sc_hot <= sc->sc_tmp)
d274 2
d277 1
d280 3
d285 1
a285 1
			trend = sc->sc_tc1 * (sc->sc_tmp - sc->sc_lasttmp) +
d287 6
a292 1
			/* printf("_TZ trend = %d\n", trend); */
d298 1
d320 2
a321 1
		dnprintf(10, "%s: no %s\n", DEVNAME(sc), name);
d325 34
d360 2
a361 1
	aml_freevalue(&res);
d369 1
a369 1
	u_int64_t crt;
d375 4
a378 2
	case 0x81:	/* Operating Points changed */
		sc->sc_psv = acpitz_getreading(sc, "_PSV");
d380 1
a380 1
		sc->sc_crt = acpitz_getreading(sc, "_CRT");
d382 4
a385 2
			printf("%s: critical temperature: %u degC",
			    DEVNAME(sc), (sc->sc_crt - 2732) / 10);
d390 1
@


1.19
log
@less colons
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.18 2007/11/03 17:46:41 deraadt Exp $ */
d112 1
a112 1
		printf(": no critical temperature defined!\n");
d251 1
a251 1
		dnprintf(30, "%s: %s: failed to read temp!\n", DEVNAME(sc),
d258 1
a258 1
		printf("%s: Critical temperature, shutting down!\n",
@


1.18
log
@repair attach messages; ok gwk canacar
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.17 2007/03/26 12:30:48 marco Exp $ */
d115 1
a115 1
		printf(": critical temperature: %d degC\n",
@


1.17
log
@Don't leak memory.

From giovanni <qgiovanni@@gmail.com>
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.16 2007/03/22 16:55:31 deraadt Exp $ */
d107 1
a107 1
		printf(", failed to read _TMP\n");
d112 1
a112 1
		printf(", no critical temperature defined!\n");
d115 1
a115 1
		printf(", critical temperature: %d degC\n",
@


1.16
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.15 2007/02/14 01:31:12 deanna Exp $ */
d227 1
a227 1
			else
d229 2
@


1.15
log
@Quiet a noisy debug message by using dnprintf instead of printf.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.14 2006/12/26 23:58:08 marco Exp $ */
d54 2
a55 2
	struct sensor		sc_sens;
	struct sensordev	sc_sensdev;
@


1.14
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.13 2006/12/23 17:46:39 deraadt Exp $ */
d181 1
a181 1
		printf("%s: %s failed\n", DEVNAME(sc), name);
@


1.13
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.12 2006/12/21 11:23:41 deraadt Exp $ */
a128 3
	aml_register_notify(sc->sc_devnode->parent, NULL,
	    acpitz_notify, sc);

d137 3
@


1.12
log
@more minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.11 2006/12/19 18:17:15 deraadt Exp $ */
d55 1
d132 2
a133 2
	memset(&sc->sc_sens, 0, sizeof(sc->sc_sens));
	strlcpy(sc->sc_sens.device, DEVNAME(sc), sizeof(sc->sc_sens.device));
d137 2
a138 1
	sensor_add(&sc->sc_sens);
@


1.11
log
@knf + delete unused variables
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.10 2006/12/18 20:57:45 canacar Exp $ */
d130 1
a130 1
	
d216 1
a216 1
			    NULL, NULL)) 
@


1.10
log
@Remove misleading NOTREACHED comments. Sending a signal does not
stop execution. Noticed by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.9 2006/11/29 22:17:07 marco Exp $ */
d46 1
a46 1
	int                     sc_hot;
d49 1
a49 1
	int                     sc_pse;
d51 3
a53 3
	int                     sc_tc1;
	int                     sc_tc2;
	int                     sc_lasttmp;
d73 1
a73 1
int     acpitz_setcpu(struct acpitz_softc *, int);
a97 1
	struct aml_value	res, env;
a103 3
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

d105 2
a106 2
	if (-1 == (sc->sc_tmp = acpitz_getreading(sc, "_TMP"))) {
		printf(", failed to read _TMP");
d110 2
a111 2
	if (-1 == (sc->sc_crt = acpitz_getreading(sc, "_CRT"))) {
		printf(", no critical temperature defined!");
d114 1
a114 1
		printf(", critical temperature: %d degC",
d134 1
a134 1
		sizeof(sc->sc_sens.desc));
a137 2
	
	printf("\n");
d160 1
a160 1
		if (ref->type != AML_OBJTYPE_PROCESSOR) {
a161 1
		}
a164 1

d259 1
a259 1
	if (sc->sc_hot != -1 && sc->sc_hot <= sc->sc_tmp) {
d261 3
a263 2
	}
	if (sc->sc_lasttmp != -1 && sc->sc_tc1 != -1 && sc->sc_tc2 != -1 && sc->sc_psv != -1) {
d267 1
a267 1
				sc->sc_tc2 * (sc->sc_tmp - sc->sc_psv);
d269 1
a269 2
		}
		else if (sc->sc_pse) {
a270 1
		}
d277 1
a277 1
			if (sc->sc_ac_stat[i] <= 0) {
a278 1
			}
d281 1
a281 1
			if (sc->sc_ac_stat[i] > 0) {
a282 1
			}
a284 1

a297 1

a300 1

a315 1

d320 1
a320 1
		            DEVNAME(sc), (sc->sc_crt - 2732) / 10);
a324 1

a325 1

@


1.9
log
@After a long debate at the hackathon it was decided that the acpi implementation
is not concurrent if the sensors thread goes away.  This makes acpi completly
lockless.

help and ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.8 2006/11/02 04:58:20 marco Exp $ */
a265 1
		/* NOTREACHED */
@


1.8
log
@Ooops, forgot a debug printf.
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.7 2006/11/02 04:56:13 marco Exp $ */
a23 1
#include <sys/rwlock.h>
a43 1
	struct rwlock		sc_lock;
a104 2
	rw_init(&sc->sc_lock, "acpitz");

a142 3
	if (sensor_task_register(sc, acpitz_refresh, 10))
		printf(", unable to register update task");
	
a297 2
	rw_enter_write(&sc->sc_lock);

a298 2

	rw_exit_write(&sc->sc_lock);
a306 2
	rw_enter_write(&sc->sc_lock);

d315 1
a315 1
	rw_exit_write(&sc->sc_lock);
@


1.7
log
@Add active cooling support mostly by me with jordan help.
Add initial passive cooling trending formulas by jordan.

ok jordan@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.6 2006/10/24 20:30:00 marco Exp $ */
d190 1
a190 1
	printf("%s: acpitz_setfan(%d, %s)\n", DEVNAME(sc), i, method);
@


1.6
log
@Condense get functions into a single function.  This is ahead of retrieving
remaining threshold values.

ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.5 2006/10/24 19:58:03 marco Exp $ */
d37 2
d46 10
a55 2
	u_int64_t		sc_tmp;
	u_int64_t		sc_crt;
d74 2
d101 2
d112 1
a112 3
	sc->sc_tmp = -1;
	sc->sc_crt = -1;

d122 13
a134 2
		printf(", critical temperature: %u degC",
		    (unsigned)(sc->sc_crt - 2732) / 10);
d153 98
d255 1
d267 1
a267 1
	if (sc->sc_tmp != -1 && sc->sc_crt != -1 && sc->sc_crt <= sc->sc_tmp) {
d275 29
d343 2
d349 1
a349 2
		            DEVNAME(sc),
			    (unsigned)(sc->sc_crt - 2732) / 10);
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.4 2006/10/19 01:19:15 jordan Exp $ */
a50 3
void	acpitz_refresh(void *);
int	acpitz_gettmp(struct acpitz_softc *);
int	acpitz_notify(struct aml_node *, int, void *);
a61 2
int	acpitz_getbif(struct acpitz_softc *);
int	acpitz_getbst(struct acpitz_softc *);
d63 1
a63 1
int	acpitz_getcrt(struct acpitz_softc *);
d98 4
a101 1
	if (acpitz_gettmp(sc)) {
d106 1
a106 1
	if (acpitz_getcrt(sc)) {
d139 1
a139 1
	if (acpitz_gettmp(sc)) {
d145 1
a145 1
	if (sc->sc_crt && sc->sc_crt <= sc->sc_tmp) {
d162 1
a162 1
acpitz_gettmp(struct acpitz_softc *sc)
d165 1
a165 1
	int   rv = 1;
d169 2
a170 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_TMP", 0, NULL, &res)) {
		dnprintf(10, "%s: no _TMP\n", DEVNAME(sc));
d174 1
a174 2
	sc->sc_tmp = aml_val2int(&res);
	rv = 0;
a181 22
acpitz_getcrt(struct acpitz_softc *sc)
{
	struct aml_value	res;
	int   rv = 1;

	rw_enter_write(&sc->sc_lock);

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CRT", 0, NULL, &res)) {
		dnprintf(10, "%s: no _CRT\n", DEVNAME(sc));
		goto out;
	}

	sc->sc_crt = aml_val2int(&res);
	rv = 0;
 out:
	aml_freevalue(&res);
	rw_exit_write(&sc->sc_lock);
	return (rv);
}


int
d193 1
a193 1
		acpitz_getcrt(sc);
@


1.4
log
@Fixed acpitz match function
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.3 2006/10/12 16:38:21 jordan Exp $ */
d171 1
a171 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_TMP", 0, NULL, &res) != 0) {
d192 1
a192 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CRT", 0, NULL, &res) != 0) {
@


1.3
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.2 2006/07/30 05:30:45 gwk Exp $ */
d82 1
a82 1
	if (aa->aaa_node->opcode != AMLOP_THERMALZONE)
@


1.2
log
@Donot pass a uninitialized pointer to aml_register_notify(), should fix PR5153
awaiting confirmation of this from the submitter, but its wrong regardless.
ok marco@@, canacar@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpitz.c,v 1.1 2006/05/19 09:24:32 canacar Exp $ */
d166 1
a166 1
	struct aml_value	res, env;
d171 1
a171 4
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_TMP", &res, &env)) {
d176 1
a176 1
	sc->sc_tmp = aml_val2int(NULL, &res);
d179 1
d187 1
a187 1
	struct aml_value	res, env;
d192 1
a192 4
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_CRT", &res, &env)) {
d197 1
a197 1
	sc->sc_crt = aml_val2int(NULL, &res);
d200 1
@


1.1
log
@Minimal thermal zone driver. Monitors thermal zone temperature,
shuts down the system if the 'critical temperature' is reached.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d115 1
a115 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
@

