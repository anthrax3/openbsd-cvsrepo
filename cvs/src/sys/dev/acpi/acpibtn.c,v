head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.4
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.12
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.10
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.15.0.6
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.4
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9;
locks; strict;
comment	@ * @;


1.44
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.43;
commitid	EeVoCYFCx2tYicZQ;

1.43
date	2017.02.28.10.39.07;	author natano;	state Exp;
branches;
next	1.42;
commitid	7vjwd2A6pnK9Hf8n;

1.42
date	2016.01.07.12.08.18;	author mpi;	state Exp;
branches;
next	1.41;
commitid	3Z1cNlkLNPp0W60V;

1.41
date	2015.01.27.19.40.14;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	Iwxvi2WMryDqhCIo;

1.40
date	2014.11.24.03.54.06;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	P93aqYQfxUwVONPU;

1.39
date	2014.11.23.20.33.47;	author mlarkin;	state Exp;
branches;
next	1.38;
commitid	QRJMZUFrgaM56XWw;

1.38
date	2014.11.08.07.45.10;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	CGxpPhnDADMO822f;

1.37
date	2014.10.16.17.46.06;	author mlarkin;	state Exp;
branches;
next	1.36;
commitid	iVZmvUfTX0V9hXpB;

1.36
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.35;
commitid	uzzBR7hz9ncd4O6G;

1.35
date	2013.08.21.20.10.47;	author landry;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.07.16.21.20;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.06.21.12.27;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.05.21.10.06;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.05.20.11.32;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.05.19.23.06;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.05.17.26.57;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.06.20.14.17;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.31.19.21.19;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.05.04.20.58;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.25.19.41.16;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.25.16.12.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.19.21.02.05;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.12.12.49.28;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.18.20.57.45;	author canacar;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.19.21.20;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.31.10.01.56;	author canacar;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.25.21.44.45;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.22.19.30.45;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.21.20.53.31;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.02.21.17.14.42;	author jordan;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.21.16.50.50;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.02.21.04.30.45;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.21.01.10.10;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.02.20.04.59.43;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.20.00.48.10;	author marco;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@/* $OpenBSD: acpibtn.c,v 1.43 2017/02/28 10:39:07 natano Exp $ */
/*
 * Copyright (c) 2005 Marco Peereboom <marco@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/apmvar.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <sys/sensors.h>

int	acpibtn_match(struct device *, void *, void *);
void	acpibtn_attach(struct device *, struct device *, void *);
int	acpibtn_notify(struct aml_node *, int, void *);
int	acpibtn_activate(struct device *, int);

struct acpibtn_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	struct ksensor		sc_sens;
	struct ksensordev	sc_sensdev;

	int			sc_btn_type;
#define	ACPIBTN_UNKNOWN	0
#define ACPIBTN_LID	1
#define ACPIBTN_POWER	2
#define ACPIBTN_SLEEP	3
};

int	acpibtn_setpsw(struct acpibtn_softc *, int);

struct acpi_lid {
	struct acpibtn_softc	*abl_softc;
	SLIST_ENTRY(acpi_lid)	abl_link;
};
SLIST_HEAD(acpi_lid_head, acpi_lid) acpibtn_lids =
    SLIST_HEAD_INITIALIZER(acpibtn_lids);

struct cfattach acpibtn_ca = {
	sizeof(struct acpibtn_softc), acpibtn_match, acpibtn_attach, NULL,
	acpibtn_activate
};

struct cfdriver acpibtn_cd = {
	NULL, "acpibtn", DV_DULL
};

const char *acpibtn_hids[] = { ACPI_DEV_LD, ACPI_DEV_PBD, ACPI_DEV_SBD, 0 };

/*
 * acpibtn_numopenlids
 *
 * Return the number of _LID devices that are in the "open" state.
 * Used to determine if we should go back to sleep/hibernate if we
 * woke up with the all the lids still closed for some reason. If
 * the machine has no lids, returns -1.
 */
int
acpibtn_numopenlids(void)
{
	struct acpi_lid *lid;
	int64_t val;
	int ct = 0;

	/* If we have no lids ... */
	if (SLIST_EMPTY(&acpibtn_lids))
		return (-1);

	/*
	 * Determine how many lids are open. Assumes _LID evals to
	 * non-0 or 0, for on / off (which is what the spec says).
	 */
	SLIST_FOREACH(lid, &acpibtn_lids, abl_link)
		if (!aml_evalinteger(lid->abl_softc->sc_acpi,
		    lid->abl_softc->sc_devnode, "_LID", 0, NULL, &val) &&
		    val != 0)
			ct++;
	return (ct);
}

int
acpibtn_setpsw(struct acpibtn_softc *sc, int psw)
{
	struct aml_value	val;

	bzero(&val, sizeof val);
	val.type = AML_OBJTYPE_INTEGER;
	val.v_integer = psw;
	val.length = 1;

	return (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSW", 1, &val,
	    NULL));
}

void
acpibtn_disable_psw(void)
{
	struct acpi_lid *lid;

	/* disable _LID for wakeup */
	SLIST_FOREACH(lid, &acpibtn_lids, abl_link)
		acpibtn_setpsw(lid->abl_softc, 0);
}

void
acpibtn_enable_psw(void)
{
	struct acpi_lid		*lid;

	/* enable _LID for wakeup */
	SLIST_FOREACH(lid, &acpibtn_lids, abl_link)
		acpibtn_setpsw(lid->abl_softc, 1);
}

int
acpibtn_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;

	/* sanity */
	return (acpi_matchhids(aa, acpibtn_hids, cf->cf_driver->cd_name));
}

void
acpibtn_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpibtn_softc	*sc = (struct acpibtn_softc *)self;
	struct acpi_attach_args *aa = aux;
	struct acpi_lid		*lid;
	int64_t			lid_open = 1;
	int64_t			st;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	printf(": %s\n", sc->sc_devnode->name);

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &st))
		st = STA_PRESENT | STA_ENABLED | STA_DEV_OK;
	if ((st & (STA_PRESENT | STA_ENABLED | STA_DEV_OK)) !=
	    (STA_PRESENT | STA_ENABLED | STA_DEV_OK))
		return;

	if (!strcmp(aa->aaa_dev, ACPI_DEV_LD)) {
		sc->sc_btn_type = ACPIBTN_LID;

		/* Set PSW (if present) to disable wake on this LID */
		(void)acpibtn_setpsw(sc, 0);
		lid = malloc(sizeof(*lid), M_DEVBUF, M_WAITOK | M_ZERO);
		lid->abl_softc = sc;
		SLIST_INSERT_HEAD(&acpibtn_lids, lid, abl_link);
	} else if (!strcmp(aa->aaa_dev, ACPI_DEV_PBD))
		sc->sc_btn_type = ACPIBTN_POWER;
	else if (!strcmp(aa->aaa_dev, ACPI_DEV_SBD))
		sc->sc_btn_type = ACPIBTN_SLEEP;

	if (sc->sc_btn_type == ACPIBTN_LID) {
		strlcpy(sc->sc_sensdev.xname, DEVNAME(sc),
		    sizeof(sc->sc_sensdev.xname));
		strlcpy(sc->sc_sens.desc, "lid open",
		    sizeof(sc->sc_sens.desc));
		sc->sc_sens.type = SENSOR_INDICATOR;
		sensor_attach(&sc->sc_sensdev, &sc->sc_sens);
		sensordev_install(&sc->sc_sensdev);

		aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
		    "_LID", 0, NULL, &lid_open);
		sc->sc_sens.value = lid_open;
	}

	aml_register_notify(sc->sc_devnode, aa->aaa_dev, acpibtn_notify,
	    sc, ACPIDEV_NOPOLL);
}

int
acpibtn_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct acpibtn_softc	*sc = arg;
#ifndef SMALL_KERNEL
	extern int lid_action;
	int64_t lid;
#endif

	dnprintf(10, "acpibtn_notify: %.2x %s\n", notify_type,
	    sc->sc_devnode->name);

	switch (sc->sc_btn_type) {
	case ACPIBTN_LID:
#ifndef SMALL_KERNEL
		/*
		 * Notification of 0x80 for lid opens or closes.  We
		 * need to check the current status by calling the
		 * _LID method.  0 means the lid is closed and we
		 * should go to sleep.
		 */
		if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
		    "_LID", 0, NULL, &lid))
			return (0);
		sc->sc_sens.value = lid;

		if (lid != 0)
			break;

		switch (lid_action) {
		case 1:
			goto sleep;
#ifdef HIBERNATE
		case 2:
			/* Request to go to sleep */
			if (acpi_record_event(sc->sc_acpi, APM_USER_HIBERNATE_REQ))
				acpi_addtask(sc->sc_acpi, acpi_sleep_task,
				    sc->sc_acpi, ACPI_SLEEP_HIBERNATE);
			break;
#endif
		default:
			break;
		}
#endif /* SMALL_KERNEL */
		break;
	case ACPIBTN_SLEEP:
#ifndef SMALL_KERNEL
		switch (notify_type) {
		case 0x02:
			/* "something" has been taken care of by the system */
			break;
		case 0x80:
sleep:
			/* Request to go to sleep */
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ))
				acpi_addtask(sc->sc_acpi, acpi_sleep_task,
				    sc->sc_acpi, ACPI_SLEEP_SUSPEND);
			break;
		}
#endif /* SMALL_KERNEL */
		break;
	case ACPIBTN_POWER:
		if (notify_type == 0x80)
			acpi_addtask(sc->sc_acpi, acpi_powerdown_task,
			    sc->sc_acpi, 0);
		break;
	default:
		printf("%s: spurious acpi button interrupt %i\n", DEVNAME(sc),
		    sc->sc_btn_type);
		break;
	}

	return (0);
}

int
acpibtn_activate(struct device *self, int act)
{
	struct acpibtn_softc	*sc = (struct acpibtn_softc *)self;
	int64_t			lid_open = 1;

	switch (act) {
	case DVACT_WAKEUP:
		switch (sc->sc_btn_type) {
		case ACPIBTN_LID:
			aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
			    "_LID", 0, NULL, &lid_open);
			sc->sc_sens.value = lid_open;
			break;
		}
		break;
	}
	return (0);
}
@


1.43
log
@Untangle abstract sleep modes from ACPI sleep states. This paves the way
for further work in the area.

idea and ok deraadt
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.42 2016/01/07 12:08:18 mpi Exp $ */
d210 1
a210 1
	extern int lid_suspend;
d230 2
a231 1
		if (lid_suspend == 0)
d233 3
a235 1
		if (lid == 0)
d237 11
@


1.42
log
@Use a resune hook to re-evaluate the "_LID" status upon resume.

This fixes the lid sensor for machines, like the x220, that do
not generate an event when the lid opens.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.41 2015/01/27 19:40:14 kettenis Exp $ */
d247 1
a247 1
				    sc->sc_acpi, ACPI_STATE_S3);
@


1.41
log
@Ignore buttons for which _STA indicates they're not present, enabled or
functioning.  Fixes suspend/resume on a Dell PowerEdge T20.

ok mlarkin@@, sthen@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.40 2014/11/24 03:54:06 deraadt Exp $ */
d38 1
d69 2
a70 1
	sizeof(struct acpibtn_softc), acpibtn_match, acpibtn_attach
d160 1
a160 1
	int64_t			lid_open;
d263 20
@


1.40
log
@Count how many lids are open, rather than accumulating the values ACPI
gives for true (could be "1", for all we know)
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.39 2014/11/23 20:33:47 mlarkin Exp $ */
a57 1
int	acpibtn_getsta(struct acpibtn_softc *);
d159 1
d164 8
a184 4
	acpibtn_getsta(sc);

	printf(": %s\n", sc->sc_devnode->name);

a200 11
}

int
acpibtn_getsta(struct acpibtn_softc *sc)
{
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, NULL) != 0) {
		dnprintf(20, "%s: no _STA\n", DEVNAME(sc));
		/* XXX not all buttons have _STA so FALLTROUGH */
	}

	return (0);
@


1.39
log
@
If a machine has no _LIDs, then none can be open. This diff fixes a problem
where machines without any _LIDs were going back to sleep after hibernate
due to the recent suspend-if-lid-closed-on-resume diff. Noticed on qemu,
which doesn't have any _LIDs.

discussed with deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.38 2014/11/08 07:45:10 mlarkin Exp $ */
d81 4
a84 4
 * Return the number of _LID devices that are in the "open" state. Used to
 * determine if we should go back to sleep/hibernate if we woke up with the all
 * the lids still closed for some reason. If the machine has no lids, returns
 * -1.
a88 1
	int64_t val, ct;
d90 2
a96 2
	ct = 0;

d98 2
a99 2
	 * Determine how many lids are open. Assumes _LID evals to 1 or 0, for
	 * on / off (which is what the spec says).
d103 3
a105 3
		    lid->abl_softc->sc_devnode, "_LID", 0, NULL, &val))
			ct += val;

@


1.38
log
@
If resuming from sleep (zzz/ZZZ) and the lid is still closed, go back to
sleep. This prevents accidental lid flex or slight opening in a backpack
from waking the machine up and leaving it resumed (powered on).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.37 2014/10/16 17:46:06 mlarkin Exp $ */
d78 8
d87 1
a87 1
acpibtn_checklidopen(void)
d89 1
a89 1
	int64_t val, status;
d92 10
a101 3
	status = 0;

	/* Check if any of the lid(s) are open */
d105 1
a105 3
			status |= val;
		else
			return (0);
d107 1
a107 1
	return (status);
@


1.37
log
@

LID control method devices aren't required to offer _PSW, so don't skip
putting a LID into the global list of LIDs if we encounter an error writing
to _PSW for that LID. Needed for another upcoming diff.

ok deraadt, phessler
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.36 2014/09/14 14:17:24 jsg Exp $ */
d77 19
@


1.36
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.35 2013/08/21 20:10:47 landry Exp $ */
d135 6
a140 5
		if (acpibtn_setpsw(sc, 0) == 0) {
			lid = malloc(sizeof(*lid), M_DEVBUF, M_WAITOK | M_ZERO);
			lid->abl_softc = sc;
			SLIST_INSERT_HEAD(&acpibtn_lids, lid, abl_link);
		}
@


1.35
log
@Add an indicator sensor to acpibtnX reflecting lid status when available,
useful for people not using machdep.lidsuspend. sysutils/upower will make
use of this soon.
Note that on some laptops, no LID event is triggered upon resume when using
machdep.lidsuspend, so the value might be false in this case..

Tested by rpe@@ on a variety of Lenovo HW, thanks!
ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.34 2011/01/02 04:56:57 jordan Exp $ */
a18 1
#include <sys/proc.h>
@


1.34
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.33 2010/08/07 16:21:20 deraadt Exp $ */
d49 3
d129 1
d150 14
a199 2
		if (lid_suspend == 0)
			break;
d203 3
@


1.33
log
@The wakeup of the acpi thread is not needed.  This code is being called
from inside the thread context, and will unwind into the middle of
acpi_thread, where it will check these variables
ok jordan marco kettenis canacar
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.32 2010/08/06 21:12:27 marco Exp $ */
d201 2
a202 1
				sc->sc_acpi->sc_sleepmode = ACPI_STATE_S3;
d209 2
a210 1
			sc->sc_acpi->sc_powerdown = 1;
@


1.32
log
@Always call _PSW on _LID devices that support it to enable lid open to
resume the machine.  Conversely disable it when the machine wakes up.

Tested by several ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.31 2010/08/05 21:10:06 deraadt Exp $ */
d200 1
a200 1
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ)) {
a201 2
				acpi_wakeup(sc->sc_acpi);
			}
@


1.31
log
@new i386/amd64 machdep.lidsuspend sysctl which decides whether a lid
close causes a suspend.  resumes are not tied to this; they happen
unconditionally.  this is a temporary knob for the 4.8 release; afterwards
it will move to a more convenient place
much moaning discussing where to put the knob with kettenis
tested by various including phessler
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.29 2010/08/05 19:23:06 marco Exp $ */
d50 4
a53 4
#define	ACPIBTN_UNKNOWN	-1
#define ACPIBTN_LID	0
#define ACPIBTN_POWER	1
#define ACPIBTN_SLEEP	2
d57 8
d77 34
d125 1
a130 2
		struct aml_value	val;

d132 5
a136 6
		bzero(&val, sizeof val);
		val.type = AML_OBJTYPE_INTEGER;
		val.v_integer = 1;
		val.length = 1;
		(void) aml_evalname(sc->sc_acpi, sc->sc_devnode, "_PSW",
		    1, &val, NULL);
a140 2
	else
		sc->sc_btn_type = ACPIBTN_UNKNOWN;
@


1.30
log
@lid suspend logic was backwards
@
text
@a122 3
/* XXX tie this to a sysctl later */
int	acpi_lid_suspend = 0;

d128 1
d144 1
a144 1
		if (acpi_lid_suspend == 0)
@


1.29
log
@Wakeup machine when lid is opened on laptops that have acpibtn _LID.

initial diff from me, this version pruned by deraadt

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.28 2010/08/05 17:26:57 deraadt Exp $ */
d146 1
a146 1
		if (acpi_lid_suspend)
@


1.28
log
@PM1 power button events were generating 'fake events' to acpibtn PWRB,
but if there is no such device these were being tossed.  Instead, arrange
for all power button handlers to flag a softc variable which is processed
by the thread; so that one place will know to request a powerdown (psignal
to init)
ok marco mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.27 2010/07/06 20:14:17 deraadt Exp $ */
d87 3
a89 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_LD))
d91 7
a97 1
	else if (!strcmp(aa->aaa_dev, ACPI_DEV_PBD))
d146 2
d151 2
a152 6
		if (acpi_lid_suspend && lid == 0) {
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ)) {
				sc->sc_acpi->sc_sleepmode = ACPI_STATE_S3;
				acpi_wakeup(sc->sc_acpi);
			}
		}
d162 1
@


1.27
log
@Don't use a workq to do the suspend, because it races aginst the acpi
thread.  Instead, just tell the acpi thread to do the suspend for us.
This makes apmd & zzz work correctly.  While here, have acpithinkpad
attempt to post the event to apm before prompting the suspend itself.
ok kettenis marco mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.26 2010/03/31 19:21:19 kettenis Exp $ */
d167 1
a167 1
			psignal(initproc, SIGUSR2);
@


1.26
log
@Bring /dev/apm support in line with apm(4).  Make the suspend button send
a suspend request event to apmd(8) instead of suspending immediately.  Also
keep track of whether /dev/apm and /dev/apmctl are currently open, such that
we can still suspend immediately if apmd(8) isn't running.

ok deraadt@@, marco@@, pirofti@@, jsing@@, oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.25 2009/12/05 04:20:58 deraadt Exp $ */
d115 3
d131 1
d135 1
a135 1
		 * _LID method.  Zero means the lid is closed and we
a137 1
#ifndef SMALL_KERNEL
d141 5
a145 4
#if 0
		if (lid == 0) {
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ))
				acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
d147 1
a147 1
#endif
a148 1
#endif /* SMALL_KERNEL */
d157 4
a160 2
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ))
				acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
@


1.25
log
@Until we have better hooks and a proper framework, do not do the lid
suspend. It is neat but annoying without a 'button'.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.24 2009/11/25 19:41:16 kettenis Exp $ */
d26 1
d139 4
a142 2
		if (lid == 0)
			acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
d154 2
a155 1
			acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
@


1.24
log
@Suspend when the lid closes (but not when it opens again).

ok deraadt@@, mlarkin@@, pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.23 2009/11/25 16:12:40 deraadt Exp $ */
d137 1
d140 1
@


1.23
log
@Handle the notification types for LID and Sleep button a bit more
specifically.  On some thinkpads we get 0x02 for the Fn button, which
means that it is going to handle the next bit for us.  After that,
we get an suspend key event in acpithinkpad.
ok pirofti
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.22 2009/11/23 16:21:54 pirofti Exp $ */
d118 3
d129 3
a131 2
		 * need to check using other means, and if desirable,
		 * go to sleep.
d133 6
d140 1
@


1.22
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.21 2009/02/19 21:02:05 marco Exp $ */
d124 6
d132 9
a140 1
		acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
@


1.21
log
@suspend/resume bits so that we can develop this in tree.  This is disabled.
code from mlarkin and me
help from art,toby,jordan and several others
ok jordan, go for it deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.20 2008/11/06 23:41:28 marco Exp $ */
d125 1
a125 1
#ifdef ACPI_SLEEP_ENABLED
d127 1
a127 1
#endif /* ACPI_SLEEP_ENABLED */
@


1.20
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.19 2008/06/01 17:59:55 marco Exp $ */
d125 3
@


1.19
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.17 2008/05/14 05:24:36 jordan Exp $ */
d65 2
d74 1
a74 6
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	return (1);
@


1.18
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.16 2008/04/12 12:49:28 kettenis Exp $ */
d87 1
a87 1
	sc->sc_devnode = aa->aaa_node->child;
d100 1
a100 1
	printf(": %s\n", sc->sc_devnode->parent->name);
d102 1
a102 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpibtn_notify,
d123 1
a123 1
	    sc->sc_devnode->parent->name);
@


1.17
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d87 1
a87 1
	sc->sc_devnode = aa->aaa_node;
d100 1
a100 1
	printf(": %s\n", sc->sc_devnode->name);
d102 1
a102 1
	aml_register_notify(sc->sc_devnode, aa->aaa_dev, acpibtn_notify,
d123 1
a123 1
	    sc->sc_devnode->name);
@


1.16
log
@Get rid of acpi_s5 global variables; simply send SIGUSR2 instead of SUGUSR1
to tell init(8) to power down the machine.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.15 2006/12/26 23:58:08 marco Exp $ */
d87 1
a87 1
	sc->sc_devnode = aa->aaa_node->child;
d100 1
a100 1
	printf(": %s\n", sc->sc_devnode->parent->name);
d102 1
a102 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpibtn_notify,
d123 1
a123 1
	    sc->sc_devnode->parent->name);
@


1.15
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.14 2006/12/21 11:23:41 deraadt Exp $ */
a120 1
	extern int		acpi_s5;
d130 2
a131 4
		if (notify_type == 0x80) {
			acpi_s5 = 1;
			psignal(initproc, SIGUSR1);
		}
@


1.14
log
@more minor knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.13 2006/12/18 20:57:45 canacar Exp $ */
d102 2
a103 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, acpibtn_notify, sc);
@


1.13
log
@Remove misleading NOTREACHED comments. Sending a signal does not
stop execution. Noticed by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.12 2006/11/29 19:21:20 miod Exp $ */
d98 1
a98 1
	acpibtn_getsta(sc); 
@


1.12
log
@Do not consider unrecognized buttons as lid sensors. ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.11 2006/10/12 16:38:21 jordan Exp $ */
a132 1
			/* NOTREACHED */
@


1.11
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.10 2006/05/31 10:01:56 canacar Exp $ */
d49 1
d91 1
a91 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_PBD))
d93 1
a93 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_SBD))
d95 2
@


1.10
log
@Match the specs and only shut down if notify_type is 0x80
Reported and tested by todd@@, ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.9 2006/02/25 21:44:45 marco Exp $ */
d105 1
a105 8
	struct aml_value	res, env;
	struct acpi_context	*ctx;

	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	ctx = NULL;
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env)) {
@


1.9
log
@Ugh, missed some { }
Made spurrious interrupt message more useful
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.8 2006/02/22 19:30:45 jordan Exp $ */
d134 5
a138 3
		acpi_s5 = 1;
		psignal(initproc, SIGUSR1);
		/* NOTREACHED */
@


1.8
log
@Added new aml_register to notify by device id
Moved powerdown code to button device
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.7 2006/02/21 20:53:31 marco Exp $ */
d112 1
a112 1
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env))
d115 1
d139 2
a140 1
		printf("%s: spurious acpi interrupt\n", DEVNAME(sc));
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.6 2006/02/21 17:14:42 jordan Exp $ */
d90 1
a90 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_PBD)) {
d92 1
a92 3
		sc->sc_acpi->sc_pbtndev = sc->sc_devnode;
	}
	if (!strcmp(aa->aaa_dev, ACPI_DEV_SBD)) {
a93 2
		sc->sc_acpi->sc_sbtndev = sc->sc_devnode;
	}
d99 1
a99 1
	aml_register_notify(sc->sc_devnode->parent, acpibtn_notify, sc);
@


1.6
log
@Added button type field
KNF
Fixed parent notify callback for GEN interrupts
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.5 2006/02/21 16:50:50 marco Exp $ */
d35 3
a37 3
int acpibtn_match(struct device *, void *, void *);
void acpibtn_attach(struct device *, struct device *, void *);
int  acpibtn_notify(struct aml_node *, int, void *);
d54 1
a54 1
int acpibtn_getsta(struct acpibtn_softc *);
@


1.5
log
@Adjust debug levels since _STA often doesn't exist and its annoyingly loud.
KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.4 2006/02/21 04:30:45 marco Exp $ */
a51 3
#if 0
	struct sensor sens[3];	/* XXX debug only */
#endif
a53 4

#if 0
void acpibtn_refresh(void *);
#endif
d90 1
a90 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_PBD))
d92 3
a94 1
	if (!strcmp(aa->aaa_dev, ACPI_DEV_SBD))
d96 2
a100 1
	/* XXX print which buttons are available and state */
a103 26

	/* XXX: fixme */
	sc->sc_acpi->sc_pbtndev = sc->sc_devnode;
	sc->sc_acpi->sc_sbtndev = sc->sc_devnode;
#if 0
	strlcpy(sc->sens[0].device, DEVNAME(sc), sizeof(sc->sens[0].device));
	strlcpy(sc->sens[0].desc, "power supply", sizeof(sc->sens[2].desc));
	sc->sens[0].type = SENSOR_INDICATOR;
	sensor_add(&sc->sens[0]);
	sc->sens[0].value = sc->sc_ac_stat;

	if (sensor_task_register(sc, acpibtn_refresh, 10))
		printf(", unable to register update task\n");
#endif
}

#if 0
/* XXX this is for debug only, remove later */
void
acpibtn_refresh(void *arg)
{
	struct acpibtn_softc *sc = arg;

	acpibtn_getsta(sc); 

	sc->sens[0].value = sc->sc_ac_stat;
a104 1
#endif
d118 1
a118 1
		/* not all buttons have _STA so FALLTROUGH */
d134 1
a139 2
		break;
	case ACPIBTN_SLEEP:
@


1.4
log
@Rig the power button so that the machine shuts down correctly.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.3 2006/02/21 01:10:10 marco Exp $ */
d74 2
a75 2
	struct acpi_attach_args *aa = aux;
	struct cfdata *cf = match;
d89 1
a89 1
	struct acpibtn_softc *sc = (struct acpibtn_softc *)self;
d140 2
a141 2
	struct aml_value res, env;
	struct acpi_context *ctx;
d148 1
a148 1
		dnprintf(10, "%s: no _STA\n", DEVNAME(sc));
@


1.3
log
@Print the parent name which is way more useful than the node name.
E.a: _LID instead of _HID.
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.2 2006/02/20 04:59:43 jordan Exp $ */
d19 2
d48 4
a51 3
	int			sc_pwr_btn;
	int			sc_lid_btn;
	int			sc_sleep_btn;
d95 7
d157 2
a158 1
	struct acpibtn_softc *sc = arg;
d160 1
a160 1
	printf("acpibtn_notify: %.2x %s\n", notify_type,
d162 15
@


1.2
log
@Display device name for button attach
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpibtn.c,v 1.1 2006/02/20 00:48:10 marco Exp $ */
d137 3
a139 6
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_STA", &res, &env)) {
		dnprintf(10, "%s: no _STA\n",
		    DEVNAME(sc));
		/* XXX this should fall through */
		return (1);
	}
d149 3
a151 1
	printf("acpibtn_notify: %.2x %s\n", notify_type, sc->sc_devnode->name);
@


1.1
log
@Add acpibtn device.  Remains disabled for now.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d95 1
a95 1
	printf("\n");
@

