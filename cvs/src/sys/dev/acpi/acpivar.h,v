head	1.88;
access;
symbols
	OPENBSD_6_2_BASE:1.88
	OPENBSD_6_1:1.86.0.4
	OPENBSD_6_1_BASE:1.86
	OPENBSD_6_0:1.82.0.4
	OPENBSD_6_0_BASE:1.82
	OPENBSD_5_9:1.82.0.2
	OPENBSD_5_9_BASE:1.82
	OPENBSD_5_8:1.79.0.6
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.79.0.4
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.77.0.6
	OPENBSD_5_6_BASE:1.77
	OPENBSD_5_5:1.77.0.4
	OPENBSD_5_5_BASE:1.77
	OPENBSD_5_4:1.75.0.4
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.71.0.6
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.4
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.69.0.2
	OPENBSD_4_9_BASE:1.69
	OPENBSD_4_8:1.66.0.2
	OPENBSD_4_8_BASE:1.66
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.42.0.4
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.42.0.2
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.88
date	2017.08.17.05.16.27;	author stsp;	state Exp;
branches;
next	1.87;
commitid	zi9UXMvrYRtXblO4;

1.87
date	2017.04.08.01.20.10;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	MZ9TNujEim7YgwTY;

1.86
date	2017.03.12.21.30.44;	author jcs;	state Exp;
branches;
next	1.85;
commitid	LbtljK30ETSd9Z21;

1.85
date	2017.02.28.10.39.07;	author natano;	state Exp;
branches;
next	1.84;
commitid	7vjwd2A6pnK9Hf8n;

1.84
date	2017.02.22.16.39.56;	author jcs;	state Exp;
branches;
next	1.83;
commitid	8xjYWoiSUtOS1eaI;

1.83
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.82;
commitid	h0GHFDGWnEdswfbK;

1.82
date	2016.01.12.01.11.15;	author jcs;	state Exp;
branches;
next	1.81;
commitid	vNDeumNiEMwV2q08;

1.81
date	2016.01.10.16.59.41;	author kettenis;	state Exp;
branches;
next	1.80;
commitid	RY6ynEalDrvUnDAA;

1.80
date	2016.01.09.18.54.51;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	awDrkFoBayGHFV90;

1.79
date	2014.12.08.07.12.37;	author mlarkin;	state Exp;
branches;
next	1.78;
commitid	9gsjQWzKEbWkbtZI;

1.78
date	2014.11.22.18.31.46;	author mlarkin;	state Exp;
branches;
next	1.77;
commitid	OZhulzwbZ5ey9UWV;

1.77
date	2014.01.05.20.23.57;	author mlarkin;	state Exp;
branches;
next	1.76;

1.76
date	2013.11.06.10.40.36;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2012.11.27.17.38.46;	author pirofti;	state Exp;
branches;
next	1.74;

1.74
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2012.10.04.08.32.20;	author ehrhardt;	state Exp;
branches;
next	1.72;

1.72
date	2012.09.07.19.19.59;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2011.04.15.17.34.51;	author oga;	state Exp;
branches;
next	1.70;

1.70
date	2011.04.06.21.16.13;	author martynas;	state Exp;
branches;
next	1.69;

1.69
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.68;

1.68
date	2010.10.31.21.52.46;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.26.20.51.35;	author jordan;	state Exp;
branches;
next	1.66;

1.66
date	2010.08.08.20.45.18;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2010.08.07.17.15.23;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.05.17.26.57;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2010.07.20.12.14.10;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.20.12.12.19;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.19.16.57.27;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2010.07.19.16.40.14;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.13.21.01.05;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.06.20.14.17;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2010.03.31.19.21.19;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.26.23.44.38;	author mlarkin;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2009.11.23.15.08.02;	author mlarkin;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.02.19.27.46;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.26.19.56.01;	author jordan;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.15.19.00.53;	author jordan;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.04.22.50.11;	author jordan;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.03.00.36.59;	author pirofti;	state Exp;
branches;
next	1.47;

1.47
date	2009.04.17.13.20.20;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.19.21.02.05;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.20.20.21.03;	author mlarkin;	state Exp;
branches;
next	1.44;

1.44
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.15.19.25.36;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.25.09.11.12;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.19.19.09.42;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.15.22.16.31;	author mikeb;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.12.21.58.43;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.03.20.33.48;	author jordan;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.31.17.49.16;	author gwk;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.19.23.42.39;	author jordan;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.31.23.30.51;	author gwk;	state Exp;
branches;
next	1.33;

1.33
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.21.11.33.21;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.21.11.23.41;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.25.18.24.54;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.19.08.56.46;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.15.15.22.17;	author jordan;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.30.04.16.15;	author jordan;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.30.04.03.13;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.30.01.09.47;	author jordan;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.29.00.54.23;	author canacar;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.11.02.35.35;	author gwk;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.11.02.28.10;	author gwk;	state Exp;
branches;
next	1.20;

1.20
date	2006.02.22.19.29.24;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2006.02.21.04.30.45;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.20.21.39.06;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.19.21.32.30;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2006.02.19.04.50.46;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.17.17.35.59;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.03.23.55.47;	author jordan;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.18.22.25.44;	author jordan;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.17.23.42.14;	author jordan;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.06.10.57.15;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.05.22.58.42;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.30.05.59.40;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.28.03.06.30;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.16.18.59.41;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.16.18.11.55;	author jordan;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.14.03.45.38;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.07.23.34;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.10.19.39.01;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.10.17.24.18;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.02.20.09.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.88
log
@Make dwiic(4) attach its ACPI parent dependencies.
This change makes the Asus E200HA keyboard work.

Original analysis and patch by Cesare Gargano
ok kettenis@@
@
text
@/*	$OpenBSD: acpivar.h,v 1.87 2017/04/08 01:20:10 deraadt Exp $	*/
/*
 * Copyright (c) 2005 Thorsten Lockert <tholo@@sigmasoft.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _DEV_ACPI_ACPIVAR_H_
#define _DEV_ACPI_ACPIVAR_H_

#define ACPI_TRAMPOLINE		(19 * NBPG)
#define ACPI_TRAMP_DATA		(20 * NBPG)

#ifndef _ACPI_WAKECODE

#include <sys/timeout.h>
#include <sys/rwlock.h>
#include <machine/biosvar.h>

#include "acpipwrres.h"

/* #define ACPI_DEBUG */
#ifdef ACPI_DEBUG
extern int acpi_debug;
#define dprintf(x...)	  do { if (acpi_debug) printf(x); } while (0)
#define dnprintf(n,x...)  do { if (acpi_debug > (n)) printf(x); } while (0)
#else
#define dprintf(x...)
#define dnprintf(n,x...)
#endif

extern int acpi_hasprocfvs;

struct klist;
struct acpiec_softc;
struct acpipwrres_softc;

struct acpivideo_softc {
	struct device sc_dev;

	struct acpi_softc *sc_acpi;
	struct aml_node	*sc_devnode;
};

struct acpi_attach_args {
	char		*aaa_name;
	bus_space_tag_t	 aaa_iot;
	bus_space_tag_t	 aaa_memt;
	void		*aaa_table;
	struct aml_node *aaa_node;
	const char	*aaa_dev;
};

struct acpi_mem_map {
	vaddr_t		 baseva;
	u_int8_t	*va;
	size_t		 vsize;
	paddr_t		 pa;
};

struct acpi_q {
	SIMPLEQ_ENTRY(acpi_q)	 q_next;
	int			 q_id;
	void			*q_table;
	u_int8_t		 q_data[0];
};

struct acpi_taskq {
	SIMPLEQ_ENTRY(acpi_taskq)	next;
	void 				(*handler)(void *, int);
	void				*arg0;
	int				arg1;
};

struct acpi_wakeq {
	SIMPLEQ_ENTRY(acpi_wakeq)	 q_next;
	struct aml_node			*q_node;
	struct aml_value		*q_wakepkg;
	int				 q_gpe;
	int				 q_state;
};

#if NACPIPWRRES > 0
struct acpi_pwrres {
	SIMPLEQ_ENTRY(acpi_pwrres)	 p_next;
	struct aml_node			*p_node;	/* device's node */
	int				 p_state;	/* current state */

	int				 p_res_state;
	struct acpipwrres_softc		*p_res_sc;
};

typedef SIMPLEQ_HEAD(, acpi_pwrres) acpi_pwrreshead_t;
#endif /* NACPIPWRRES > 0 */

typedef SIMPLEQ_HEAD(, acpi_q) acpi_qhead_t;
typedef SIMPLEQ_HEAD(, acpi_wakeq) acpi_wakeqhead_t;

#define ACPIREG_PM1A_STS	0x00
#define ACPIREG_PM1A_EN		0x01
#define ACPIREG_PM1A_CNT	0x02
#define ACPIREG_PM1B_STS	0x03
#define ACPIREG_PM1B_EN		0x04
#define ACPIREG_PM1B_CNT	0x05
#define ACPIREG_PM2_CNT		0x06
#define ACPIREG_PM_TMR		0x07
#define ACPIREG_GPE0_STS	0x08
#define ACPIREG_GPE0_EN		0x09
#define ACPIREG_GPE1_STS	0x0A
#define ACPIREG_GPE1_EN		0x0B
#define ACPIREG_SMICMD		0x0C
#define ACPIREG_MAXREG		0x0D

/* Special registers */
#define ACPIREG_PM1_STS		0x0E
#define ACPIREG_PM1_EN		0x0F
#define ACPIREG_PM1_CNT		0x10
#define ACPIREG_GPE_STS		0x11
#define ACPIREG_GPE_EN		0x12

/* System status (_SST) codes */
#define ACPI_SST_INDICATOR_OFF	0
#define ACPI_SST_WORKING	1
#define ACPI_SST_WAKING		2
#define ACPI_SST_SLEEPING	3
#define ACPI_SST_SLEEP_CONTEXT	4

struct acpi_parsestate {
	u_int8_t		*start;
	u_int8_t		*end;
	u_int8_t		*pos;
};

struct acpi_reg_map {
	bus_space_handle_t	ioh;
	int			addr;
	int			size;
	int			access;
	const char		*name;
};

struct acpi_thread {
	struct acpi_softc   *sc;
	volatile int	    running;
};

struct acpi_mutex {
	struct rwlock		amt_lock;
#define ACPI_MTX_MAXNAME	5
	char			amt_name[ACPI_MTX_MAXNAME + 3]; /* only 4 used */
	int			amt_ref_count;
	int			amt_timeout;
	int			amt_synclevel;
};

struct gpe_block {
	int  (*handler)(struct acpi_softc *, int, void *);
	void *arg;
	int   active;
	int   edge;
};

struct acpi_devlist {
	struct aml_node			*dev_node;
	TAILQ_ENTRY(acpi_devlist)	dev_link;
};

TAILQ_HEAD(acpi_devlist_head, acpi_devlist);

struct acpi_ac {
	struct acpiac_softc	*aac_softc;
	SLIST_ENTRY(acpi_ac)	aac_link;
};

SLIST_HEAD(acpi_ac_head, acpi_ac);

struct acpi_bat {
	struct acpibat_softc	*aba_softc;
	SLIST_ENTRY(acpi_bat)	aba_link;
};

SLIST_HEAD(acpi_bat_head, acpi_bat);

struct acpi_sbs {
	struct acpisbs_softc	*asbs_softc;
	SLIST_ENTRY(acpi_sbs)	asbs_link;
};

SLIST_HEAD(acpi_sbs_head, acpi_sbs);

struct acpi_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_tag_t		sc_memt;
#if 0
	bus_space_tag_t		sc_pcit;
	bus_space_tag_t		sc_smbust;
#endif

	/*
	 * First-level ACPI tables
	 */
	struct acpi_fadt	*sc_fadt;
	acpi_qhead_t		 sc_tables;
	acpi_wakeqhead_t	 sc_wakedevs;
#if NACPIPWRRES > 0
	acpi_pwrreshead_t	 sc_pwrresdevs;
#endif /* NACPIPWRRES > 0 */
	int			 sc_hw_reduced;

	/*
	 * Second-level information from FADT
	 */
	struct acpi_facs	*sc_facs;	/* Shared with firmware! */

	struct klist		*sc_note;
	struct acpi_reg_map	sc_pmregs[ACPIREG_MAXREG];
	bus_space_handle_t	sc_ioh_pm1a_evt;

	void			*sc_interrupt;

	struct rwlock		sc_lck;

	struct {
		int slp_typa;
		int slp_typb;
	}			sc_sleeptype[6];
	int			sc_maxgpe;
	int			sc_lastgpe;

	struct gpe_block	*gpe_table;

	int			sc_threadwaiting;
	u_int32_t		sc_gpe_sts;
	u_int32_t		sc_gpe_en;
	struct acpi_thread	*sc_thread;

	struct aml_node		*sc_tts;
	struct aml_node		*sc_pts;
	struct aml_node		*sc_bfs;
	struct aml_node		*sc_gts;
	struct aml_node		*sc_sst;
	struct aml_node		*sc_wak;
	int			sc_state;
	struct acpiec_softc	*sc_ec;		/* XXX assume single EC */

	struct acpi_ac_head	sc_ac;
	struct acpi_bat_head	sc_bat;
	struct acpi_sbs_head	sc_sbs;
	int			sc_havesbs;

	struct timeout		sc_dev_timeout;

	int			sc_revision;

	int			sc_pse;		/* passive cooling enabled */

	int			sc_flags;
};

extern struct acpi_softc *acpi_softc;

#define	SCFLAG_OREAD	0x0000001
#define	SCFLAG_OWRITE	0x0000002
#define	SCFLAG_OPEN	(SCFLAG_OREAD|SCFLAG_OWRITE)

#define GPE_NONE  0x00
#define GPE_LEVEL 0x01
#define GPE_EDGE  0x02

struct acpi_table {
	int	offset;
	size_t	size;
	void	*table;
};

struct acpi_dev_rank {
	struct device	*dev;
	int		rank;
	TAILQ_ENTRY(acpi_dev_rank) link;
};

#define	ACPI_IOC_GETFACS	_IOR('A', 0, struct acpi_facs)
#define	ACPI_IOC_GETTABLE	_IOWR('A', 1, struct acpi_table)
#define ACPI_IOC_SETSLEEPSTATE	_IOW('A', 2, int)

#if defined(_KERNEL)
struct   acpi_gas;
int	 acpi_map_address(struct acpi_softc *, struct acpi_gas *, bus_addr_t, bus_size_t,
			  bus_space_handle_t *, bus_space_tag_t *);

int	 acpi_map(paddr_t, size_t, struct acpi_mem_map *);
void	 acpi_unmap(struct acpi_mem_map *);
int	 acpi_probe(struct device *, struct cfdata *, struct bios_attach_args *);
u_int	 acpi_checksum(const void *, size_t);
void	 acpi_attach_machdep(struct acpi_softc *);
int	 acpi_interrupt(void *);
void	 acpi_powerdown(void);
void	 acpi_reset(void);


#define ACPI_SLEEP_SUSPEND	0x01
#define ACPI_SLEEP_HIBERNATE	0x02

int	 acpi_sleep_state(struct acpi_softc *, int);
void	 acpi_sleep_clocks(struct acpi_softc *, int);
int	 acpi_sleep_cpu(struct acpi_softc *, int);
void	 acpi_sleep_mp(void);
void	 acpi_sleep_pm(struct acpi_softc *, int);
void	 acpi_resume_pm(struct acpi_softc *, int);
void	 acpi_resume_clocks(struct acpi_softc *);
void	 acpi_resume_cpu(struct acpi_softc *);
void	 acpi_resume_mp(void);
void	 acpi_sleep_walk(struct acpi_softc *, int);


#define ACPI_IOREAD 0
#define ACPI_IOWRITE 1

void acpi_wakeup(void *);

int acpi_gasio(struct acpi_softc *, int, int, uint64_t, int, int, void *);

int	acpi_set_gpehandler(struct acpi_softc *, int,
	    int (*)(struct acpi_softc *, int, void *), void *, int);
void	acpi_enable_gpe(struct acpi_softc *, u_int32_t);

int	acpiec_intr(struct acpiec_softc *);
void	acpiec_read(struct acpiec_softc *, u_int8_t, int, u_int8_t *);
void	acpiec_write(struct acpiec_softc *, u_int8_t, int, u_int8_t *);
void	acpiec_handle_events(struct acpiec_softc *);

#if NACPIPWRRES > 0
int	acpipwrres_ref_incr(struct acpipwrres_softc *, struct aml_node *);
int	acpipwrres_ref_decr(struct acpipwrres_softc *, struct aml_node *);
#endif /* NACPIPWRRES > 0 */

int	acpi_read_pmreg(struct acpi_softc *, int, int);
void	acpi_write_pmreg(struct acpi_softc *, int, int, int);

void	acpi_poll(void *);
void	acpi_sleep(int, char *);

int	acpi_matchhids(struct acpi_attach_args *, const char *[], const char *);
int	acpi_parsehid(struct aml_node *, void *, char *, char *, size_t);

int	acpi_record_event(struct acpi_softc *, u_int);

void	acpi_addtask(struct acpi_softc *, void (*)(void *, int), void *, int);
int	acpi_dotask(struct acpi_softc *);

void	acpi_powerdown_task(void *, int);
void	acpi_sleep_task(void *, int);

/* Section 5.2.10.1: global lock acquire/release functions */
#define	GL_BIT_PENDING	0x01
#define	GL_BIT_OWNED	0x02
int	acpi_acquire_glk(uint32_t *);
int	acpi_release_glk(uint32_t *);

void	acpi_pciroots_attach(struct device *, void *, cfprint_t);
void	acpi_attach_deps(struct acpi_softc *, struct aml_node *);

void	*acpi_intr_establish(int, int, int, int (*)(void *), void *,
	    const char *);

struct acpi_q *acpi_maptable(struct acpi_softc *sc, paddr_t,
	    const char *, const char *, const char *, int);

#endif

#endif /* !_ACPI_WAKECODE */
#endif	/* !_DEV_ACPI_ACPIVAR_H_ */
@


1.87
log
@Two prototypes for acpi_maptable; merge to one place
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.86 2017/03/12 21:30:44 jcs Exp $	*/
d373 1
@


1.86
log
@try to attach acpisbs first and if successful, don't attach acpibat
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.85 2017/02/28 10:39:07 natano Exp $	*/
d376 3
@


1.85
log
@Untangle abstract sleep modes from ACPI sleep states. This paves the way
for further work in the area.

idea and ok deraadt
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.84 2017/02/22 16:39:56 jcs Exp $	*/
d261 1
@


1.84
log
@add acpisbs, an acpi smart battery subsystem driver reading data
over smbus

currently disabled because it conflicts with acpibat

ok deraadt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.83 2016/07/28 21:57:56 kettenis Exp $	*/
d310 5
@


1.83
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.82 2016/01/12 01:11:15 jcs Exp $	*/
d194 7
d260 1
@


1.82
log
@Add dwiic, a driver for the Synopsys DesignWare i2c controller found
on the Samsung ATIV Book 9 laptop.  This initial version only
supports ACPI config/attachment.

Add ihidev, a HID-over-i2c driver largely based on uhidev.  dwiic
handles attaching ihidev devices found in ACPI.

Add ims, a HID-over-i2c mouse/trackpad driver to get basic cursor
and button functionality from HID-compliant i2c trackpads.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.81 2016/01/10 16:59:41 kettenis Exp $	*/
a42 3

#define LAPIC_MAP_SIZE	256
extern u_int8_t acpi_lapic_flags[LAPIC_MAP_SIZE];
@


1.81
log
@Introduce acpi_intr_establish(9), an API to establish interrupt handlers for
"platform" devices that attach to acpi(4).

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.80 2016/01/09 18:54:51 kettenis Exp $	*/
d344 2
a345 1
int acpi_matchhids(struct acpi_attach_args *, const char *[], const char *);
@


1.80
log
@Initial support for Hardware-Reduced ACPI.  This skips the legacy mode checks
by emulating the PM_CNT register such that SCI_EN is always enabled.  It also
skip attaching acpitimer(4) since the relevant registers are no longer there.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.79 2014/12/08 07:12:37 mlarkin Exp $	*/
d361 3
@


1.79
log
@
Split the ACPI resume trampoline into code and data, move the data page to
.rodata (kernel copies to the RW page), protect the code page with RX
permissions, protect the code page with RW permissions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.78 2014/11/22 18:31:46 mlarkin Exp $	*/
d216 1
@


1.78
log
@
Split the MP trampoline into two pages, one for code and one for data/stack
and then protect the code page as RX and the data/stack page as RW (NX).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.77 2014/01/05 20:23:57 mlarkin Exp $	*/
d22 1
@


1.77
log
@

Don't use the first 64KB for anything, including tramps. Move tramps and
hibernate goo up after 64KB to avoid posible corruption by buggy BIOS SMM
code. Diff also ensures the first 64KB doesn't get handed to UVM either.

ok deraadt@@, tested by many with no regressions reported
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.76 2013/11/06 10:40:36 mpi Exp $	*/
d21 1
a21 1
#define ACPI_TRAMPOLINE		(17 * NBPG)
@


1.76
log
@Add support for Power Resources for Dx states and the necessary hook
for PCI devices.  This hook should be called twice, before and after
changing the power state of a PCI device.

Before setting the device to the new state, the ACPI layer will notify
every power resources linked to the device for that state and make sure
they are turned "_ON".  After changing the state of the device, it will
decrement the reference of every power resources linked to that device
for the old state and turn them "_OFF" if they are no longer referenced.

This fixes the no-USB after resume problem seen on various ThinkPad,
problem initialy diagnosed with Alexander Polakov.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.75 2012/11/27 17:38:46 pirofti Exp $	*/
d21 1
a21 1
#define ACPI_TRAMPOLINE		(NBPG*4)
@


1.75
log
@Add acpi_{acquire,release}_glk locking functions.

These functions represent the basic blocks for using the ACPI global
lock that provides mutual exclusion between the OSPM and the BIOS.

No functional change. Okay kettenis@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.74 2012/10/08 21:47:50 deraadt Exp $	*/
d29 2
d48 1
d95 13
d212 3
d330 5
@


1.74
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.73 2012/10/04 08:32:20 ehrhardt Exp $	*/
d327 6
@


1.73
log
@Use information provided by ACPI to attach secondary PCI host bridges.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.72 2012/09/07 19:19:59 kettenis Exp $	*/
a230 1
	int			sc_nextstate;
a283 1
void	 acpi_cpu_flush(struct acpi_softc *, int);
d285 8
a292 4
int	 acpi_prepare_sleep_state(struct acpi_softc *, int);
int	 acpi_enter_sleep_state(struct acpi_softc *, int);
int	 acpi_sleep_machdep(struct acpi_softc *, int);
void	 acpi_resume_machdep(void);
@


1.72
log
@Add a new function called acpi_pci_min_powerstate() that returns the lowest
power state for a PCI device for the power state (currently S3 or S4) we're
transitioning into.  This function is probably too simplistic; there is a lot
of (silly) complexity in the ACPI spec.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.71 2011/04/15 17:34:51 oga Exp $	*/
d325 2
@


1.71
log
@Remove the acpi event definitions. They've not been used for over a
year.

acpi needs to use the apm definitions so that apmd speaks the same
language as it, so it uses the ones in apmvar.h these days.

``sure'' marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.70 2011/04/06 21:16:13 martynas Exp $	*/
d231 1
@


1.70
log
@Don't enumerate _DOD for attaching acpivout(4), since:
- ACPI spec. says _DOD is not required for brightness controls,
- The list returned by _DOD might be wrong,
- It's an unnecessary work to do.
Instead, decision to attach will be based on the actual methods
found, similarly like in the other ACPI drivers.
Tested by several on tech@@.
OK kettenis@@, marco@@, pirofti@@.

pirofti@@ asked me to note here that devices not supporting brightness
controls won't attach from now on.  This shouldn't be a concern for
you, since such devices weren't doing anything at all, anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.69 2011/01/02 04:56:57 jordan Exp $	*/
a269 9

#define	ACPI_EV_PWRBTN		0x0001	/* Power button was pushed */
#define	ACPI_EV_SLPBTN		0x0002	/* Sleep button was pushed */

#define	ACPI_EVENT_MASK		0x0003

#define	ACPI_EVENT_COMPOSE(t,i)	(((i) & 0x7fff) << 16 | ((t) & ACPI_EVENT_MASK))
#define	ACPI_EVENT_TYPE(e)	((e) & ACPI_EVENT_MASK)
#define	ACPI_EVENT_INDEX(e)	((e) >> 16)
@


1.69
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.68 2010/10/31 21:52:46 guenther Exp $	*/
a51 3

	int	*sc_dod;
	size_t	sc_dod_len;
a60 5
};

struct acpivideo_attach_args {
	struct acpi_attach_args	aaa;
	int dod;
@


1.68
log
@Revert last commit: it breaks resume on Thinkpads
"then please back it out" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.66 2010/08/08 20:45:18 kettenis Exp $	*/
d85 7
a215 6
	int			sc_powerbtn;
	int			sc_sleepbtn;

	int			sc_sleepmode;
	int			sc_powerdown;

a244 1
	int			sc_poll;
d335 6
@


1.67
log
@Add task queue for ACPI gpe and notify handlers
This fixes eject on Dell Latitude dock and an issue on the Dell Mini
battery update.
ok deraadt
@
text
@a84 7
struct acpi_taskq {
	SIMPLEQ_ENTRY(acpi_taskq)	next;
	void 				(*handler)(void *, int);
	void				*arg0;
	int				arg1;
};

a334 3

void	acpi_addtask(struct acpi_softc *, void (*)(void *, int), void *, int);
int	acpi_dotask(struct acpi_softc *);
@


1.66
log
@Close race between the acpi thread and wscons ioctls running in process
context.  We might rip this out post-release and replace it with a solution
that serializes things in a more obvious way.

ok deraadt@@, miod@@ and "those crazy texans who ok anything"
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.65 2010/08/07 17:15:23 kettenis Exp $	*/
d85 7
d342 3
@


1.65
log
@Enforce acpi register access rescrictions.

ok mlarkin@@, deraadt@@, tested by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.64 2010/08/05 17:26:57 deraadt Exp $	*/
d214 2
@


1.64
log
@PM1 power button events were generating 'fake events' to acpibtn PWRB,
but if there is no such device these were being tossed.  Instead, arrange
for all power button handlers to flag a softc variable which is processed
by the thread; so that one place will know to request a powerdown (psignal
to init)
ok marco mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.63 2010/07/20 12:14:10 deraadt Exp $	*/
d132 5
a136 4
	bus_space_handle_t  ioh;
	int		    addr;
	int		    size;
	const char	   *name;
@


1.63
log
@Handle the acpi interrupt controller with proper edge/level handling,
wrapped in spltty to avoid racing against the interrupt controller.
Repair the gpe bit masking code while there, and do operations in the
right order
ok kettenis mlarkin, help from jordan at figuring out the order of
operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.62 2010/07/20 12:12:19 deraadt Exp $	*/
d212 1
@


1.62
log
@tsleep() and EWOULDBLOCK was being used incorrectly for fixed minumum
delays.  tsleep() on an unknown wait channel, to ensure the minimum is
met, and that wakeup()'s don't make the delay get restarted over and
over..
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.61 2010/07/19 16:57:27 deraadt Exp $	*/
d156 1
d314 1
a314 1
	    int (*)(struct acpi_softc *, int, void *), void *, const char *);
@


1.61
log
@there is no need for a seperate dsdt_softc pointer; dsdt does not have a
softc but is just a part of the single acpi driver.
ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.59 2010/07/13 21:01:05 deraadt Exp $	*/
d325 1
@


1.60
log
@acpi_delay() is no longer needed; ok jordan
@
text
@d248 2
@


1.59
log
@rename some thread related interfaces so they are logical
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.58 2010/07/06 20:14:17 deraadt Exp $	*/
a305 1
void acpi_delay(struct acpi_softc *, int64_t);
@


1.58
log
@Don't use a workq to do the suspend, because it races aginst the acpi
thread.  Instead, just tell the acpi thread to do the suspend for us.
This makes apmd & zzz work correctly.  While here, have acpithinkpad
attempt to post the event to apm before prompting the suspend itself.
ok kettenis marco mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.57 2010/04/07 06:33:06 kettenis Exp $	*/
d221 1
a221 1
	int			sc_wakeup;
@


1.57
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.56 2010/03/31 19:21:19 kettenis Exp $	*/
d210 2
d307 2
@


1.56
log
@Bring /dev/apm support in line with apm(4).  Make the suspend button send
a suspend request event to apmd(8) instead of suspending immediately.  Also
keep track of whether /dev/apm and /dev/apmctl are currently open, such that
we can still suspend immediately if apmd(8) isn't running.

ok deraadt@@, marco@@, pirofti@@, jsing@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.55 2009/11/26 23:44:38 mlarkin Exp $	*/
d297 1
@


1.55
log
@

Visual (and on some machines, audio) feedback while the machine is
resuming via calls to aml _SST method. This also makes the "moon" LED on
thinkpads to blink during resume and cease when resume is completed.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.54 2009/11/23 16:21:54 pirofti Exp $	*/
d242 2
d246 4
d321 2
@


1.54
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.53 2009/11/23 15:08:02 mlarkin Exp $	*/
d117 7
@


1.53
log
@

Add missing acpivar.h changes from previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.52 2009/11/02 19:27:46 kettenis Exp $	*/
a37 2

/* #define ACPI_SLEEP_ENABLED */
@


1.52
log
@Remove unused member(s) of `struct acpi_softc'.

ok deraadt@@, krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.51 2009/10/26 19:56:01 jordan Exp $	*/
d223 1
a282 1
void	 acpi_resume(struct acpi_softc *);
@


1.51
log
@Verify checksum+address when loading ACPI tables.
Some systems had invalid entries in RSDT/XSDT.
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.50 2009/10/15 19:00:53 jordan Exp $	*/
a200 5
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	void			*sc_softih;
#else
	struct timeout		sc_timeout;
#endif
@


1.50
log
@Implement passive cooling for acpitz; works for some overheating machines
Counter in parent for disabling setperf when passive cooling enabled
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.49 2009/09/04 22:50:11 jordan Exp $	*/
d82 1
@


1.49
log
@Add common framework for storing device lists
Useful for acpitz, acpipwrres, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.48 2009/06/03 00:36:59 pirofti Exp $	*/
d238 2
@


1.48
log
@Add acpivideo support. This adds brightness support for all laptops
except thinkpads, they will use the acpithinkpad driver. The driver is
also hooked into wsconsole. So brightness can be adjusted via:

$ wsconsctl display.brightness=<percentage>

This is very helpfull on some laptops that have a nasty bios and get two
steps instead of one when pressing the brightness button.

Tested on various dell, fujitsu, acer, samsung and other laptops.

Okay marco@@, miod@@. Suggestions from kettenis@@.
Lots of reviews and help from miod@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.47 2009/04/17 13:20:20 pirofti Exp $	*/
d151 7
@


1.47
log
@Add device ranking support for future sleep/wake developments.

okay marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.46 2009/02/19 21:02:05 marco Exp $	*/
d49 10
d66 5
@


1.46
log
@suspend/resume bits so that we can develop this in tree.  This is disabled.
code from mlarkin and me
help from art,toby,jordan and several others
ok jordan, go for it deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.45 2009/01/20 20:21:03 mlarkin Exp $	*/
d226 6
@


1.45
log
@
Install ACPI S3 resume trampoline code in a lowmem page. First part
of ACPI S3 suspend/resume support. This is for i386.

Help/comments from art, toby, marco, jordan, kurt
ok marco@@, kurt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.44 2008/11/06 23:41:28 marco Exp $	*/
a251 1
void	 acpi_enter_sleep_state(struct acpi_softc *, int);
d253 3
d257 5
a261 1
void	 acpi_reset(void);
@


1.44
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.43 2008/09/15 19:25:36 kettenis Exp $	*/
d21 4
d39 2
d281 1
@


1.43
log
@Make this compile if !MULTIPROCESSOR.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.42 2007/12/05 19:17:13 deraadt Exp $	*/
d270 2
@


1.42
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.41 2007/11/25 09:11:12 jsg Exp $	*/
a36 1
#ifdef MULTIPROCESSOR
a38 1
#endif
@


1.41
log
@When available and ACPI is enabled use the ACPI reset method
to reboot.  This is required for some quirky sis machines
and likely others to reboot.

Tested by many. 'commit early commit often' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.40 2007/11/19 19:09:42 deraadt Exp $	*/
d23 1
a49 1
	paddr_t		 aaa_pbase; /* Physical base address of ACPI tables */
d244 1
a244 1
int	 acpi_probe(struct device *, struct cfdata *, struct acpi_attach_args *);
@


1.40
log
@supply a place to store acpi version; from jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.39 2007/11/15 22:16:31 mikeb Exp $	*/
d251 1
@


1.39
log
@Make acpicpu(4) attach to the existing CPUs only.

Problem reported by form@@.  Fix idea by kettenis@@.
Lots of help from deraadt@@.  Tested by deraadt@@, form@@ and me.

ok deraadt marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.38 2007/11/12 21:58:43 deraadt Exp $	*/
d210 2
@


1.38
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.37 2007/11/03 20:33:48 jordan Exp $	*/
d35 5
@


1.37
log
@Added support for displaying wakeup devices
ok beck@@,weingart@@,gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.36 2007/05/31 17:49:16 gwk Exp $	*/
d63 5
a67 5
	SIMPLEQ_ENTRY(acpi_wakeq)  q_next;
	struct aml_node           *q_node;
	struct aml_value          *q_wakepkg;
	int                        q_gpe;
	int                        q_state;
d73 14
a86 14
#define ACPIREG_PM1A_STS    0x00
#define ACPIREG_PM1A_EN	    0x01
#define ACPIREG_PM1A_CNT    0x02
#define ACPIREG_PM1B_STS    0x03
#define ACPIREG_PM1B_EN	    0x04
#define ACPIREG_PM1B_CNT    0x05
#define ACPIREG_PM2_CNT	    0x06
#define ACPIREG_PM_TMR	    0x07
#define ACPIREG_GPE0_STS    0x08
#define ACPIREG_GPE0_EN	    0x09
#define ACPIREG_GPE1_STS    0x0A
#define ACPIREG_GPE1_EN	    0x0B
#define ACPIREG_SMICMD	    0x0C
#define ACPIREG_MAXREG	    0x0D
d89 10
a98 11
#define ACPIREG_PM1_STS	    0x0E
#define ACPIREG_PM1_EN	    0x0F
#define ACPIREG_PM1_CNT	    0x10
#define ACPIREG_GPE_STS     0x11
#define ACPIREG_GPE_EN      0x12

struct acpi_parsestate
{
	u_int8_t           *start;
	u_int8_t           *end;
	u_int8_t           *pos;
d156 2
a157 2
	acpi_qhead_t		sc_tables;
	acpi_wakeqhead_t        sc_wakedevs;
d183 1
a183 1
        int                     sc_lastgpe;
d185 1
a185 1
	struct gpe_block       *gpe_table;
d251 2
a252 1
int     acpi_set_gpehandler(struct acpi_softc *, int, int (*)(struct acpi_softc *, int, void *), void *, const char *);
@


1.36
log
@Make powernow-k8 on amd64 and i386 use the _PSS object from acpi to
retreive p_state data as spelled out in the amd64 bios and kernel
developers guide. This code is still a little rough around the edges but
has been tested by myself on a tyan machine and by phessler at theapt
dot org on an HP DL145. This diff also takes a first stab and cleaning up
the acpicpu dmesg spam.

ok tedu, marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.35 2007/02/19 23:42:39 jordan Exp $	*/
d62 8
d71 1
d158 1
@


1.35
log
@Added acpi_map_address function for mapping GAS/IO registers
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.34 2007/01/31 23:30:51 gwk Exp $	*/
d254 1
@


1.34
log
@Introduce acpi_hasprocfvs thats "ACPI Has Processor Frequency and Voltage
Scalling" a global flag set by acicpu attach to indicate that ACPI is
handling fvs through the _PSS objects. This will fix disappearing
EST/powernow when booting kernels with acpi enabled, as acpicpu isnt
compiled into GENERIC yet. Also in cases where acpicpu is built in and
legacy EST/powernow work but acpi is missing the _PSS object, the legacy
routines will be used.

tested by dim@@, and Nick Nauwelaerts <nick AT nauwelaerts.net>
ok marco@@, dim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.33 2006/12/26 23:58:08 marco Exp $	*/
d222 4
@


1.33
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.32 2006/12/21 19:59:02 deraadt Exp $	*/
d33 2
@


1.32
log
@even more knf love
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.31 2006/12/21 11:33:21 deraadt Exp $	*/
d191 3
d246 2
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.30 2006/12/21 11:23:41 deraadt Exp $	*/
d27 2
a28 2
#define dprintf(x...)	  do { if (acpi_debug) printf(x); } while(0)
#define dnprintf(n,x...)  do { if (acpi_debug > (n)) printf(x); } while(0)
@


1.30
log
@more minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.29 2006/11/25 18:24:54 marco Exp $	*/
d186 1
a186 1
	int 			sc_state;
@


1.29
log
@Add mutex.

prodded dlg, ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.28 2006/10/19 08:56:46 marco Exp $	*/
d156 1
a156 1
  
d180 1
a180 1
	
@


1.28
log
@Replace ACPI ioctls with APM ioctls.  This makes ACPI talk the same protocol
as APM therefore userspace can now retrieve power information in the same
fashion as all other apm arches (zaurus, macppc, i386 etc).

To use force the use of acpi device like so: apmd -f /dev/acpi

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.27 2006/10/15 15:22:17 jordan Exp $	*/
d22 1
d101 9
@


1.27
log
@Removed old GPE handler code remnants
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.26 2006/06/30 04:16:15 jordan Exp $	*/
d108 14
d178 3
@


1.26
log
@Support for calling Embedded Controller via new GPE interface
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.25 2006/06/30 04:03:13 jordan Exp $	*/
a141 1
  	u_int32_t		sc_gpemask;
a146 6

  	struct {
		int             gpe_type;
	  	int		gpe_number;
		struct aml_node *gpe_handler;
	}			sc_gpes[256];
a163 1
	u_int32_t		sc_ec_gpemask;
@


1.25
log
@Added new code for GPE handling
Also works with ACPIEC; need to fixup acpiec.c to remove original interrupt handler
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.24 2006/06/30 01:09:47 jordan Exp $	*/
d221 3
@


1.24
log
@Added offset argument for acpi read/write pmreg routines (new GPE code)
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.23 2006/05/29 00:54:23 canacar Exp $	*/
d102 6
d155 3
d214 1
@


1.23
log
@Add embedded controller support.
ok marco@@ deraadt@@ testing & ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.22 2006/04/11 02:35:35 gwk Exp $	*/
d80 2
@


1.22
log
@Add acpi_resume(struct acpi_softc *sc), which calls some AML methods,
detected at attach time, currently unused.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.22 2006/04/06 00:22:59 gwk Exp $	*/
d34 1
d159 2
d203 6
@


1.21
log
@Discover some ACPI sleep related methods, and call them at the
appropriate time in acpi_enter_sleep_state().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.20 2006/02/22 19:29:24 jordan Exp $	*/
d192 1
@


1.20
log
@Added new aml_register_notify to handle call-by-ID
Moved powerdown code to button device
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.19 2006/02/21 04:30:45 marco Exp $	*/
d151 7
a157 1

@


1.19
log
@Rig the power button so that the machine shuts down correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.18 2006/02/20 21:39:06 jordan Exp $	*/
a151 2
	struct aml_node *sc_pbtndev;
	struct aml_node *sc_sbtndev;
@


1.18
log
@Fixed structure size for sleep states (bad grange!)
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.17 2006/02/19 21:32:30 jordan Exp $	*/
d42 1
@


1.17
log
@Added code for aml_notify GPE notification callback
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.16 2006/02/19 04:50:46 marco Exp $	*/
d137 1
a137 1
	}			sc_sleeptype[5];
@


1.16
log
@jordan:
Enable interrupts.
Added peripheral code to make this work.

marco:
Replace softintr and other types of interrupts with a handler with context.
Fixed interrupt magic for GPEs.
Some KNF

This is work done by jordan and I but has to be a single commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.15 2006/02/17 17:35:59 marco Exp $	*/
d150 3
@


1.15
log
@Add a generic delay function as per the ACPI spec.

from jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.14 2006/02/03 23:55:47 jordan Exp $	*/
d93 5
d99 1
a99 1
	struct device		 sc_dev;
d101 2
a102 2
	bus_space_tag_t		 sc_iot;
	bus_space_tag_t		 sc_memt;
d104 2
a105 2
	bus_space_tag_t		 sc_pcit;
	bus_space_tag_t		 sc_smbust;
d112 1
a112 1
	acpi_qhead_t		 sc_tables;
d120 2
a121 2
	struct acpi_reg_map	 sc_pmregs[ACPIREG_MAXREG];
	bus_space_handle_t	 sc_ioh_pm1a_evt;
d127 1
a127 1
	struct timeout		 sc_timeout;
d130 3
a132 2
	int			 sc_powerbtn;
	int			 sc_sleepbtn;
d137 18
a154 2
	}			 sc_sleeptype[5];
};
@


1.14
log
@Rewrote aml parser yet again...
Fixed bus_space_map for i386/amd64
Added _BST and _BIF to acpibat to get status/info
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.13 2006/01/18 22:25:44 jordan Exp $	*/
d166 1
@


1.13
log
@Added new evaluation routines
Added helper methods for buffer/field evaluation
Fixed broken indentation on dsdt.c

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.12 2006/01/17 23:42:14 jordan Exp $	*/
d166 1
a166 1
void acpi_gasio(struct acpi_softc *, int, int, uint64_t, int, int, void *);
@


1.12
log
@Major overhaul of the aml parser.  Evaluater temporarily disabled.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.11 2006/01/06 10:57:15 grange Exp $	*/
d162 6
@


1.11
log
@One definition for sleeping states in acpireg.h is enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.10 2006/01/05 22:58:42 grange Exp $	*/
d23 1
a126 2

	struct acpi_parsestate   amlpc;
@


1.10
log
@Find SLP_TYPx values and store them for future use in
acpi_enter_sleep_state().
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.9 2005/12/30 05:59:40 tedu Exp $	*/
a152 5

/*
 * Sleep states
 */
#define	ACPI_STATE_S5		5
@


1.9
log
@make ACPI_DEBUG compile
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.8 2005/12/28 03:06:30 jordan Exp $	*/
d128 5
@


1.8
log
@oops. forgot this. part of dsdt parsing changes
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.7 2005/12/16 18:59:41 jordan Exp $	*/
d24 1
@


1.7
log
@Added hooks for powerdown/power button press
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.6 2005/12/16 18:11:55 jordan Exp $	*/
a22 1
/* #define ACPI_DEBUG */
d39 1
d77 7
d125 2
@


1.6
log
@Cleaned up common power management register i/o
Added enter sleep state ioctl
Hooked power button interrupt
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.5 2005/12/14 03:45:38 marco Exp $	*/
d25 1
a25 1
#define dprintf(x...)     do { if (acpi_debug) printf(x); } while(0)
d58 1
a58 1
#define ACPIREG_PM1A_EN     0x01
d61 1
a61 1
#define ACPIREG_PM1B_EN     0x04
d63 2
a64 2
#define ACPIREG_PM2_CNT     0x06
#define ACPIREG_PM_TMR      0x07
d66 1
a66 1
#define ACPIREG_GPE0_EN     0x09
d68 3
a70 3
#define ACPIREG_GPE1_EN     0x0B
#define ACPIREG_SMICMD      0x0C
#define ACPIREG_MAXREG      0x0D
d73 3
a75 3
#define ACPIREG_PM1_STS     0x0E
#define ACPIREG_PM1_EN      0x0F
#define ACPIREG_PM1_CNT     0x10
d79 3
a81 3
	int                 addr;
	int                 size;
	const char         *name;
d106 2
a107 2
	struct acpi_reg_map      sc_pmregs[ACPIREG_MAXREG];
	bus_space_handle_t       sc_ioh_pm1a_evt;
d128 1
a128 1
#define ACPI_IOC_SETSLEEPSTATE  _IOW('A', 2, int)
d152 1
@


1.5
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.4 2005/12/13 07:23:34 marco Exp $	*/
d57 27
d106 3
a108 2
	bus_space_handle_t	 sc_ioh_pm1a_evt;

d128 1
@


1.4
log
@Add glue to attach devices to apci.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.3 2005/07/10 19:39:01 grange Exp $	*/
d39 1
a39 1
	paddr_t		 aaa_pbase;	/* Physical base address of ACPI tables */
@


1.3
log
@Spacing cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.2 2005/07/10 17:24:18 grange Exp $	*/
d22 9
@


1.2
log
@Protect from multiple inclusion.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpivar.h,v 1.1 2005/06/02 20:09:39 tholo Exp $	*/
d86 1
a86 1
	void	*table;	
@


1.1
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d18 3
d115 2
@

