head	1.332;
access;
symbols
	OPENBSD_6_2_BASE:1.332
	OPENBSD_6_1:1.326.0.4
	OPENBSD_6_1_BASE:1.326
	OPENBSD_6_0:1.312.0.2
	OPENBSD_6_0_BASE:1.312
	OPENBSD_5_9:1.305.0.2
	OPENBSD_5_9_BASE:1.305
	OPENBSD_5_8:1.291.0.4
	OPENBSD_5_8_BASE:1.291
	OPENBSD_5_7:1.283.0.4
	OPENBSD_5_7_BASE:1.283
	OPENBSD_5_6:1.267.0.4
	OPENBSD_5_6_BASE:1.267
	OPENBSD_5_5:1.253.0.4
	OPENBSD_5_5_BASE:1.253
	OPENBSD_5_4:1.246.0.2
	OPENBSD_5_4_BASE:1.246
	OPENBSD_5_3:1.242.0.2
	OPENBSD_5_3_BASE:1.242
	OPENBSD_5_2:1.238.0.2
	OPENBSD_5_2_BASE:1.238
	OPENBSD_5_1_BASE:1.228
	OPENBSD_5_1:1.228.0.2
	OPENBSD_5_0:1.227.0.2
	OPENBSD_5_0_BASE:1.227
	OPENBSD_4_9:1.222.0.2
	OPENBSD_4_9_BASE:1.222
	OPENBSD_4_8:1.209.0.2
	OPENBSD_4_8_BASE:1.209
	OPENBSD_4_7:1.152.0.2
	OPENBSD_4_7_BASE:1.152
	OPENBSD_4_6:1.140.0.4
	OPENBSD_4_6_BASE:1.140
	OPENBSD_4_5:1.132.0.2
	OPENBSD_4_5_BASE:1.132
	OPENBSD_4_4:1.125.0.2
	OPENBSD_4_4_BASE:1.125
	OPENBSD_4_3:1.113.0.2
	OPENBSD_4_3_BASE:1.113
	OPENBSD_4_2:1.88.0.2
	OPENBSD_4_2_BASE:1.88
	OPENBSD_4_1:1.85.0.2
	OPENBSD_4_1_BASE:1.85
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.332
date	2017.08.17.05.16.27;	author stsp;	state Exp;
branches;
next	1.331;
commitid	zi9UXMvrYRtXblO4;

1.331
date	2017.08.09.10.15.31;	author dcoppa;	state Exp;
branches;
next	1.330;
commitid	2ksOaxnmjrv2s7BF;

1.330
date	2017.07.22.21.06.17;	author jcs;	state Exp;
branches;
next	1.329;
commitid	YGlQlzvK6dlvGkl6;

1.329
date	2017.07.20.18.34.24;	author kettenis;	state Exp;
branches;
next	1.328;
commitid	N4yDelTT6LxFwDcx;

1.328
date	2017.04.08.04.06.01;	author deraadt;	state Exp;
branches;
next	1.327;
commitid	Y9YNKWu5EX2Z4WOG;

1.327
date	2017.04.08.01.20.10;	author deraadt;	state Exp;
branches;
next	1.326;
commitid	MZ9TNujEim7YgwTY;

1.326
date	2017.03.27.20.27.38;	author deraadt;	state Exp;
branches;
next	1.325;
commitid	XuBe4yyJF80LNb3q;

1.325
date	2017.03.13.01.50.49;	author deraadt;	state Exp;
branches;
next	1.324;
commitid	G0EFsxNxRpVCdQy5;

1.324
date	2017.03.12.21.30.44;	author jcs;	state Exp;
branches;
next	1.323;
commitid	LbtljK30ETSd9Z21;

1.323
date	2017.03.02.10.38.10;	author natano;	state Exp;
branches;
next	1.322;
commitid	EeVoCYFCx2tYicZQ;

1.322
date	2017.02.28.10.39.07;	author natano;	state Exp;
branches;
next	1.321;
commitid	7vjwd2A6pnK9Hf8n;

1.321
date	2017.02.22.16.39.56;	author jcs;	state Exp;
branches;
next	1.320;
commitid	8xjYWoiSUtOS1eaI;

1.320
date	2017.01.14.11.32.00;	author kettenis;	state Exp;
branches;
next	1.319;
commitid	Y1ZrlN3vWltWSUxD;

1.319
date	2017.01.11.09.39.39;	author jsg;	state Exp;
branches;
next	1.318;
commitid	esBsEmdMCboEZA90;

1.318
date	2017.01.08.12.39.16;	author kettenis;	state Exp;
branches;
next	1.317;
commitid	abkKJhrEtiLE3iU9;

1.317
date	2016.10.25.06.48.58;	author pirofti;	state Exp;
branches;
next	1.316;
commitid	Z8xhqpkgqCmi8yVl;

1.316
date	2016.09.18.23.56.45;	author guenther;	state Exp;
branches;
next	1.315;
commitid	3z1ANZSruW1t207J;

1.315
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.314;
commitid	RpNaiU9Lz1B3rhqT;

1.314
date	2016.08.31.15.40.42;	author mlarkin;	state Exp;
branches;
next	1.313;
commitid	rGvnFYn6p58ObNPE;

1.313
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.312;
commitid	h0GHFDGWnEdswfbK;

1.312
date	2016.06.10.20.03.46;	author kettenis;	state Exp;
branches;
next	1.311;
commitid	cdIQVrfq8dfEzon4;

1.311
date	2016.05.08.10.09.25;	author kettenis;	state Exp;
branches;
next	1.310;
commitid	uJrpYfaaMO9KnwtE;

1.310
date	2016.04.25.15.43.30;	author pirofti;	state Exp;
branches;
next	1.309;
commitid	LzJgpZqLMYqXSXnZ;

1.309
date	2016.04.02.13.54.29;	author kettenis;	state Exp;
branches;
next	1.308;
commitid	Cuxcd3fMXGIrcdAX;

1.308
date	2016.03.29.18.04.09;	author kettenis;	state Exp;
branches;
next	1.307;
commitid	fsGdBUJ2kkD10xJo;

1.307
date	2016.03.29.17.52.04;	author kettenis;	state Exp;
branches;
next	1.306;
commitid	RJrTJ7Ytf8qwI0Bn;

1.306
date	2016.03.28.19.12.17;	author kettenis;	state Exp;
branches;
next	1.305;
commitid	lzWjykdx5VrKI2oq;

1.305
date	2016.01.17.09.04.18;	author jsg;	state Exp;
branches;
next	1.304;
commitid	6DkUsFyZV9I21oDN;

1.304
date	2016.01.17.08.40.09;	author jsg;	state Exp;
branches;
next	1.303;
commitid	z7ieHlgZiTkss7yW;

1.303
date	2016.01.14.21.37.18;	author kettenis;	state Exp;
branches;
next	1.302;
commitid	p32tx6SYZLQHvaPh;

1.302
date	2016.01.12.07.42.39;	author kettenis;	state Exp;
branches;
next	1.301;
commitid	3dyMp3MCtw11Jda9;

1.301
date	2016.01.12.01.11.15;	author jcs;	state Exp;
branches;
next	1.300;
commitid	vNDeumNiEMwV2q08;

1.300
date	2016.01.11.22.06.00;	author kettenis;	state Exp;
branches;
next	1.299;
commitid	3yUDYqp3sGmYdr2a;

1.299
date	2016.01.09.18.54.51;	author kettenis;	state Exp;
branches;
next	1.298;
commitid	awDrkFoBayGHFV90;

1.298
date	2016.01.06.09.14.09;	author kettenis;	state Exp;
branches;
next	1.297;
commitid	V6RUSMlBUpEfw4lt;

1.297
date	2015.11.23.00.10.53;	author reyk;	state Exp;
branches;
next	1.296;
commitid	mDZbjCRll3EpAuwy;

1.296
date	2015.11.22.09.40.07;	author reyk;	state Exp;
branches;
next	1.295;
commitid	d2oeoWs8TqjUSkVJ;

1.295
date	2015.09.28.18.36.36;	author deraadt;	state Exp;
branches;
next	1.294;
commitid	sjQx9dlBaND52EhB;

1.294
date	2015.09.06.16.47.48;	author deraadt;	state Exp;
branches;
next	1.293;
commitid	q86ugfpoaAUvFTuo;

1.293
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.292;
commitid	NdgfPIGUgJxQPnT7;

1.292
date	2015.08.20.20.50.10;	author kettenis;	state Exp;
branches;
next	1.291;
commitid	12oRjsDuFxOUanBv;

1.291
date	2015.08.04.15.21.59;	author deraadt;	state Exp;
branches;
next	1.290;
commitid	P73HnACOOxY50UlR;

1.290
date	2015.07.29.18.33.17;	author deraadt;	state Exp;
branches;
next	1.289;
commitid	K8NqegzUt4FDc5eF;

1.289
date	2015.07.21.15.44.04;	author kettenis;	state Exp;
branches;
next	1.288;
commitid	GRSWxhkd2hPPmPk3;

1.288
date	2015.07.17.22.34.00;	author mlarkin;	state Exp;
branches;
next	1.287;
commitid	k5I2gvd6GYcepvzO;

1.287
date	2015.03.26.01.30.22;	author jsg;	state Exp;
branches;
next	1.286;
commitid	DfGw11wytDIaNGqm;

1.286
date	2015.03.20.20.25.10;	author kettenis;	state Exp;
branches;
next	1.285;
commitid	XY3hBhKTL1ipy861;

1.285
date	2015.03.16.20.31.46;	author deraadt;	state Exp;
branches;
next	1.284;
commitid	UF5MXB4OGf08laCK;

1.284
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.283;
commitid	p4LJxGKbi0BU2cG6;

1.283
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.282;
commitid	J7ySI1ZREP62T8hM;

1.282
date	2015.02.06.05.17.48;	author mlarkin;	state Exp;
branches;
next	1.281;
commitid	6FJl8jQDXxYzHcqC;

1.281
date	2015.01.17.04.18.49;	author deraadt;	state Exp;
branches;
next	1.280;
commitid	NiWAPCyS9Bh9RSPF;

1.280
date	2015.01.15.01.19.28;	author jsg;	state Exp;
branches;
next	1.279;
commitid	PSdMLDHj2pHrUoMH;

1.279
date	2015.01.11.19.59.56;	author kettenis;	state Exp;
branches;
next	1.278;
commitid	CW6VTJ3Dmgq6BHSd;

1.278
date	2014.12.18.16.31.50;	author deraadt;	state Exp;
branches;
next	1.277;
commitid	QLXWJOgFJecdBMin;

1.277
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.276;
commitid	yWAxzpQP2PPpYlfT;

1.276
date	2014.12.06.11.10.56;	author mpi;	state Exp;
branches;
next	1.275;
commitid	kbe5920VR3UiLn4I;

1.275
date	2014.11.23.20.33.47;	author mlarkin;	state Exp;
branches;
next	1.274;
commitid	QRJMZUFrgaM56XWw;

1.274
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.273;
commitid	Qb045HZ5OhQfU69H;

1.273
date	2014.11.08.07.45.10;	author mlarkin;	state Exp;
branches;
next	1.272;
commitid	CGxpPhnDADMO822f;

1.272
date	2014.09.26.09.25.38;	author kettenis;	state Exp;
branches;
next	1.271;
commitid	UmzZe6RDH5pRTdO3;

1.271
date	2014.09.25.21.45.54;	author kettenis;	state Exp;
branches;
next	1.270;
commitid	lrnXFdZTaoN18nKy;

1.270
date	2014.09.23.18.33.34;	author kettenis;	state Exp;
branches;
next	1.269;
commitid	b73HTvgW9D1Bbn91;

1.269
date	2014.09.19.20.02.25;	author kettenis;	state Exp;
branches;
next	1.268;
commitid	lZNawJpIJwhgF8VB;

1.268
date	2014.09.08.20.25.03;	author kettenis;	state Exp;
branches;
next	1.267;
commitid	fJU8liEHjqY35MUp;

1.267
date	2014.07.20.18.05.21;	author mlarkin;	state Exp;
branches;
next	1.266;
commitid	F1K1yInguabWnn54;

1.266
date	2014.07.16.07.42.50;	author mlarkin;	state Exp;
branches;
next	1.265;
commitid	BhZaVf1oRCQi7Ocn;

1.265
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.264;
commitid	I19imNlAX05zJOED;

1.264
date	2014.07.12.09.02.24;	author kettenis;	state Exp;
branches;
next	1.263;
commitid	PNB6VkI4aO2bcc3c;

1.263
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.262;
commitid	zJyOCNTjgsYVGLiw;

1.262
date	2014.07.11.03.06.08;	author mlarkin;	state Exp;
branches;
next	1.261;
commitid	85Nfk4jewp1BRfpK;

1.261
date	2014.07.10.13.52.15;	author blambert;	state Exp;
branches;
next	1.260;
commitid	ymEUEJ4KAfLCwd6l;

1.260
date	2014.07.01.19.13.19;	author kettenis;	state Exp;
branches;
next	1.259;
commitid	YiL4PmmhmdZAgFgJ;

1.259
date	2014.06.23.18.47.41;	author kettenis;	state Exp;
branches;
next	1.258;
commitid	95Z2UROzA7lVmywt;

1.258
date	2014.05.21.02.14.07;	author mlarkin;	state Exp;
branches;
next	1.257;

1.257
date	2014.04.25.14.37.06;	author mlarkin;	state Exp;
branches;
next	1.256;

1.256
date	2014.04.13.14.43.01;	author mlarkin;	state Exp;
branches;
next	1.255;

1.255
date	2014.03.31.12.11.42;	author mpi;	state Exp;
branches;
next	1.254;

1.254
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.253;

1.253
date	2014.02.21.23.48.38;	author deraadt;	state Exp;
branches;
next	1.252;

1.252
date	2014.01.20.00.47.21;	author claudio;	state Exp;
branches;
next	1.251;

1.251
date	2013.12.24.13.23.21;	author kettenis;	state Exp;
branches;
next	1.250;

1.250
date	2013.12.23.10.48.43;	author kettenis;	state Exp;
branches;
next	1.249;

1.249
date	2013.12.16.19.11.52;	author kettenis;	state Exp;
branches;
next	1.248;

1.248
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.247;

1.247
date	2013.11.06.10.40.36;	author mpi;	state Exp;
branches;
next	1.246;

1.246
date	2013.06.01.23.00.16;	author mlarkin;	state Exp;
branches;
next	1.245;

1.245
date	2013.05.31.22.43.43;	author bluhm;	state Exp;
branches;
next	1.244;

1.244
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.243;

1.243
date	2013.04.18.18.30.41;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2012.12.24.19.41.14;	author guenther;	state Exp;
branches;
next	1.241;

1.241
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.240;

1.240
date	2012.10.04.08.32.20;	author ehrhardt;	state Exp;
branches;
next	1.239;

1.239
date	2012.09.07.19.19.59;	author kettenis;	state Exp;
branches;
next	1.238;

1.238
date	2012.07.13.11.51.41;	author pirofti;	state Exp;
branches;
next	1.237;

1.237
date	2012.07.11.10.57.38;	author mlarkin;	state Exp;
branches;
next	1.236;

1.236
date	2012.07.09.15.29.24;	author deraadt;	state Exp;
branches;
next	1.235;

1.235
date	2012.07.09.15.19.15;	author deraadt;	state Exp;
branches;
next	1.234;

1.234
date	2012.07.09.15.04.12;	author deraadt;	state Exp;
branches;
next	1.233;

1.233
date	2012.05.24.19.59.22;	author kettenis;	state Exp;
branches;
next	1.232;

1.232
date	2012.03.29.06.58.10;	author mlarkin;	state Exp;
branches;
next	1.231;

1.231
date	2012.03.29.06.57.02;	author mlarkin;	state Exp;
branches;
next	1.230;

1.230
date	2012.03.26.20.32.50;	author deraadt;	state Exp;
branches;
next	1.229;

1.229
date	2012.03.26.20.18.14;	author deraadt;	state Exp;
branches;
next	1.228;

1.228
date	2011.09.20.14.06.26;	author deraadt;	state Exp;
branches;
next	1.227;

1.227
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.226;

1.226
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.225;

1.225
date	2011.06.16.23.02.11;	author pirofti;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.27.20.55.42;	author jcs;	state Exp;
branches;
next	1.223;

1.223
date	2011.04.22.18.22.01;	author jordan;	state Exp;
branches;
next	1.222;

1.222
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.221;

1.221
date	2010.10.31.21.52.46;	author guenther;	state Exp;
branches;
next	1.220;

1.220
date	2010.10.26.20.51.35;	author jordan;	state Exp;
branches;
next	1.219;

1.219
date	2010.10.07.21.17.11;	author jordan;	state Exp;
branches;
next	1.218;

1.218
date	2010.10.05.17.04.48;	author jordan;	state Exp;
branches;
next	1.217;

1.217
date	2010.10.05.16.59.02;	author jordan;	state Exp;
branches;
next	1.216;

1.216
date	2010.10.05.16.17.55;	author deraadt;	state Exp;
branches;
next	1.215;

1.215
date	2010.10.05.16.14.59;	author deraadt;	state Exp;
branches;
next	1.214;

1.214
date	2010.10.05.16.14.37;	author deraadt;	state Exp;
branches;
next	1.213;

1.213
date	2010.09.29.19.45.34;	author deraadt;	state Exp;
branches;
next	1.212;

1.212
date	2010.08.31.17.13.46;	author deraadt;	state Exp;
branches;
next	1.211;

1.211
date	2010.08.29.18.41.12;	author jasper;	state Exp;
branches;
next	1.210;

1.210
date	2010.08.27.20.31.55;	author kettenis;	state Exp;
branches;
next	1.209;

1.209
date	2010.08.08.20.45.18;	author kettenis;	state Exp;
branches;
next	1.208;

1.208
date	2010.08.08.02.23.20;	author deraadt;	state Exp;
branches;
next	1.207;

1.207
date	2010.08.07.17.12.16;	author kettenis;	state Exp;
branches;
next	1.206;

1.206
date	2010.08.07.15.48.26;	author deraadt;	state Exp;
branches;
next	1.205;

1.205
date	2010.08.06.21.12.27;	author marco;	state Exp;
branches;
next	1.204;

1.204
date	2010.08.06.14.20.14;	author deraadt;	state Exp;
branches;
next	1.203;

1.203
date	2010.08.05.17.26.57;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2010.08.05.17.00.50;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2010.08.05.16.57.03;	author mlarkin;	state Exp;
branches;
next	1.200;

1.200
date	2010.08.05.16.13.03;	author deraadt;	state Exp;
branches;
next	1.199;

1.199
date	2010.08.04.17.35.39;	author kettenis;	state Exp;
branches;
next	1.198;

1.198
date	2010.08.03.16.32.40;	author mlarkin;	state Exp;
branches;
next	1.197;

1.197
date	2010.07.28.14.39.43;	author marco;	state Exp;
branches;
next	1.196;

1.196
date	2010.07.28.07.32.16;	author mlarkin;	state Exp;
branches;
next	1.195;

1.195
date	2010.07.27.23.33.21;	author deraadt;	state Exp;
branches;
next	1.194;

1.194
date	2010.07.27.22.58.48;	author deraadt;	state Exp;
branches;
next	1.193;

1.193
date	2010.07.27.22.57.48;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2010.07.27.22.11.44;	author deraadt;	state Exp;
branches;
next	1.191;

1.191
date	2010.07.27.16.20.17;	author mlarkin;	state Exp;
branches;
next	1.190;

1.190
date	2010.07.27.05.17.36;	author jordan;	state Exp;
branches;
next	1.189;

1.189
date	2010.07.26.17.25.44;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2010.07.26.11.29.23;	author pirofti;	state Exp;
branches;
next	1.187;

1.187
date	2010.07.22.14.19.47;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2010.07.21.19.42.05;	author deraadt;	state Exp;
branches;
next	1.185;

1.185
date	2010.07.21.15.01.52;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2010.07.21.05.03.19;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2010.07.20.21.37.33;	author deraadt;	state Exp;
branches;
next	1.182;

1.182
date	2010.07.20.12.14.10;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2010.07.20.04.04.00;	author matthew;	state Exp;
branches;
next	1.180;

1.180
date	2010.07.19.16.58.12;	author deraadt;	state Exp;
branches;
next	1.179;

1.179
date	2010.07.19.16.57.27;	author deraadt;	state Exp;
branches;
next	1.178;

1.178
date	2010.07.19.16.40.14;	author deraadt;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.18.19.49.35;	author mlarkin;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.13.21.01.05;	author deraadt;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.10.04.59.56;	author jordan;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.09.12.27.02;	author jordan;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.08.20.56.31;	author jordan;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.06.20.15.31;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2010.07.06.20.14.17;	author deraadt;	state Exp;
branches;
next	1.170;

1.170
date	2010.07.05.05.59.01;	author mlarkin;	state Exp;
branches;
next	1.169;

1.169
date	2010.07.01.16.23.46;	author thib;	state Exp;
branches;
next	1.168;

1.168
date	2010.07.01.06.29.32;	author jordan;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.01.01.39.39;	author jordan;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.01.01.14.36;	author jordan;	state Exp;
branches;
next	1.165;

1.165
date	2010.06.30.22.41.43;	author thib;	state Exp;
branches;
next	1.164;

1.164
date	2010.06.29.23.03.22;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2010.06.29.22.08.29;	author jordan;	state Exp;
branches;
next	1.162;

1.162
date	2010.06.29.18.54.35;	author kettenis;	state Exp;
branches;
next	1.161;

1.161
date	2010.06.29.04.05.23;	author tedu;	state Exp;
branches;
next	1.160;

1.160
date	2010.06.27.19.42.57;	author jordan;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.27.17.04.27;	author mlarkin;	state Exp;
branches;
next	1.158;

1.158
date	2010.06.27.07.26.31;	author jordan;	state Exp;
branches;
next	1.157;

1.157
date	2010.04.07.17.46.30;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2010.04.07.06.33.06;	author kettenis;	state Exp;
branches;
next	1.155;

1.155
date	2010.03.31.19.21.19;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.153;

1.153
date	2010.03.25.23.00.20;	author oga;	state Exp;
branches;
next	1.152;

1.152
date	2009.11.26.23.44.38;	author mlarkin;	state Exp;
branches;
next	1.151;

1.151
date	2009.11.26.13.20.39;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.24.23.01.41;	author jsg;	state Exp;
branches;
next	1.149;

1.149
date	2009.11.24.16.12.37;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2009.11.23.22.34.23;	author mlarkin;	state Exp;
branches;
next	1.147;

1.147
date	2009.11.23.18.01.56;	author mlarkin;	state Exp;
branches;
next	1.146;

1.146
date	2009.11.23.16.21.54;	author pirofti;	state Exp;
branches;
next	1.145;

1.145
date	2009.11.23.15.18.05;	author deraadt;	state Exp;
branches;
next	1.144;

1.144
date	2009.11.23.15.04.41;	author mlarkin;	state Exp;
branches;
next	1.143;

1.143
date	2009.10.26.20.17.26;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2009.10.26.19.56.01;	author jordan;	state Exp;
branches;
next	1.141;

1.141
date	2009.07.23.01.38.16;	author cnst;	state Exp;
branches;
next	1.140;

1.140
date	2009.06.03.07.13.48;	author pirofti;	state Exp;
branches;
next	1.139;

1.139
date	2009.06.03.00.36.59;	author pirofti;	state Exp;
branches;
next	1.138;

1.138
date	2009.06.03.00.13.35;	author jordan;	state Exp;
branches;
next	1.137;

1.137
date	2009.04.30.20.42.14;	author marco;	state Exp;
branches;
next	1.136;

1.136
date	2009.04.19.21.33.43;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2009.04.17.13.20.20;	author pirofti;	state Exp;
branches;
next	1.134;

1.134
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.133;

1.133
date	2009.03.10.19.35.03;	author jordan;	state Exp;
branches;
next	1.132;

1.132
date	2009.02.21.13.09.20;	author marco;	state Exp;
branches;
next	1.131;

1.131
date	2009.02.20.20.08.26;	author marco;	state Exp;
branches;
next	1.130;

1.130
date	2009.02.19.21.02.05;	author marco;	state Exp;
branches;
next	1.129;

1.129
date	2009.02.10.02.13.19;	author jordan;	state Exp;
branches;
next	1.128;

1.128
date	2009.02.04.20.09.03;	author kettenis;	state Exp;
branches;
next	1.127;

1.127
date	2009.01.17.17.17.11;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.125;

1.125
date	2008.07.02.03.14.54;	author fgsch;	state Exp;
branches;
next	1.124;

1.124
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.123;

1.123
date	2008.06.08.02.53.14;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2008.06.07.17.00.38;	author marco;	state Exp;
branches;
next	1.121;

1.121
date	2008.06.06.09.15.32;	author marco;	state Exp;
branches;
next	1.120;

1.120
date	2008.06.01.18.14.25;	author marco;	state Exp;
branches;
next	1.119;

1.119
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.118;

1.118
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.116;

1.116
date	2008.04.27.16.23.16;	author jcs;	state Exp;
branches;
next	1.115;

1.115
date	2008.04.24.13.57.49;	author jsing;	state Exp;
branches;
next	1.114;

1.114
date	2008.04.12.12.49.28;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2008.01.21.12.43.09;	author jsg;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.05.18.26.30;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2007.12.05.16.14.14;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2007.12.02.22.18.06;	author fgsch;	state Exp;
branches;
next	1.108;

1.108
date	2007.12.02.20.44.33;	author fgsch;	state Exp;
branches;
next	1.107;

1.107
date	2007.11.27.18.45.45;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2007.11.25.09.11.12;	author jsg;	state Exp;
branches;
next	1.105;

1.105
date	2007.11.19.19.17.30;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2007.11.19.19.13.11;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2007.11.19.19.10.58;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2007.11.19.18.56.41;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2007.11.16.16.16.04;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2007.11.15.22.19.14;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2007.11.15.22.16.31;	author mikeb;	state Exp;
branches;
next	1.98;

1.98
date	2007.11.14.20.29.06;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.12.21.38.00;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.06.22.12.34;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.06.01.05.28;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.05.17.32.20;	author canacar;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.03.20.33.48;	author jordan;	state Exp;
branches;
next	1.92;

1.92
date	2007.10.11.16.48.21;	author kettenis;	state Exp;
branches;
next	1.91;

1.91
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2007.09.13.20.35.47;	author mk;	state Exp;
branches;
next	1.89;

1.89
date	2007.09.13.03.43.22;	author weingart;	state Exp;
branches;
next	1.88;

1.88
date	2007.04.17.16.07.45;	author mk;	state Exp;
branches;
next	1.87;

1.87
date	2007.04.11.02.51.11;	author jordan;	state Exp;
branches;
next	1.86;

1.86
date	2007.03.26.03.52.49;	author marco;	state Exp;
branches;
next	1.85;

1.85
date	2007.03.03.15.27.35;	author mk;	state Exp;
branches;
next	1.84;

1.84
date	2007.02.22.07.40.47;	author marco;	state Exp;
branches;
next	1.83;

1.83
date	2007.02.21.19.17.22;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2007.02.19.23.42.39;	author jordan;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.18.02.25.05;	author jordan;	state Exp;
branches;
next	1.80;

1.80
date	2007.02.18.01.37.49;	author marco;	state Exp;
branches;
next	1.79;

1.79
date	2007.02.17.23.59.03;	author marco;	state Exp;
branches;
next	1.78;

1.78
date	2007.02.13.04.39.43;	author marco;	state Exp;
branches;
next	1.77;

1.77
date	2007.01.31.23.30.51;	author gwk;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.22.19.47.11;	author mk;	state Exp;
branches;
next	1.75;

1.75
date	2007.01.02.00.51.15;	author marco;	state Exp;
branches;
next	1.74;

1.74
date	2006.12.26.23.58.08;	author marco;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2006.12.21.05.57.17;	author marco;	state Exp;
branches;
next	1.71;

1.71
date	2006.12.20.17.33.38;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.12.20.17.25.26;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.20.17.04.00;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.19.04.09.11;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.06.17.45.57;	author mk;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.28.20.25.59;	author jordan;	state Exp;
branches;
next	1.65;

1.65
date	2006.11.27.19.32.18;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2006.11.27.15.20.26;	author jordan;	state Exp;
branches;
next	1.63;

1.63
date	2006.11.25.16.26.08;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2006.11.15.21.41.51;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2006.11.02.05.58.49;	author marco;	state Exp;
branches;
next	1.60;

1.60
date	2006.11.02.05.52.24;	author marco;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.19.08.56.46;	author marco;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.19.03.24.45;	author jordan;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.15.15.22.17;	author jordan;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.30.23.09.41;	author gwk;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.30.04.16.15;	author jordan;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.30.04.03.13;	author jordan;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.30.01.09.47;	author jordan;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.31.10.34.54;	author todd;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.29.00.54.23;	author canacar;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.19.09.24.32;	author canacar;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.11.02.36.49;	author marco;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.11.02.35.35;	author gwk;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.11.02.28.10;	author gwk;	state Exp;
branches;
next	1.45;

1.45
date	2006.02.26.04.39.09;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.23.18.53.21;	author marco;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.22.23.53.09;	author marco;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.22.20.15.03;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2006.02.22.19.38.01;	author jordan;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.22.19.30.45;	author jordan;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.21.16.51.30;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.21.04.30.44;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.20.00.48.10;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.19.21.32.30;	author jordan;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.19.19.03.49;	author grange;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.19.04.50.46;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.17.17.42.52;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.17.17.35.59;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.17.06.57.58;	author marco;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.17.05.10.39;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.17.00.46.54;	author jordan;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.16.22.42.11;	author jordan;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.16.21.11.13;	author jordan;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.06.23.12.09;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.02.04.00.18.27;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.03.23.55.47;	author jordan;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.20.20.20.28;	author jordan;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.19.00.08.46;	author jordan;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.18.22.25.44;	author jordan;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.17.23.42.14;	author jordan;	state Exp;
branches;
next	1.19;

1.19
date	2006.01.06.08.59.58;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.06.08.58.20;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.06.08.37.32;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.05.22.58.42;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.05.21.49.09;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.05.21.22.21;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.28.03.09.21;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.18.15.53.00;	author sturm;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.16.19.09.31;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.16.18.59.41;	author jordan;	state Exp;
branches;
next	1.9;

1.9
date	2005.12.16.18.11.55;	author jordan;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.16.04.00.35;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2005.12.16.00.08.53;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.14.04.16.25;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.14.03.46.38;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.13.07.23.33;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.07.03.44.36;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.10.19.39.01;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2005.06.02.20.09.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.332
log
@Make dwiic(4) attach its ACPI parent dependencies.
This change makes the Asus E200HA keyboard work.

Original analysis and patch by Cesare Gargano
ok kettenis@@
@
text
@/* $OpenBSD: acpi.c,v 1.331 2017/08/09 10:15:31 dcoppa Exp $ */
/*
 * Copyright (c) 2005 Thorsten Lockert <tholo@@sigmasoft.com>
 * Copyright (c) 2005 Jordan Hargrave <jordan@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/ioccom.h>
#include <sys/event.h>
#include <sys/signalvar.h>
#include <sys/proc.h>
#include <sys/kthread.h>
#include <sys/sched.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>

#ifdef HIBERNATE
#include <sys/hibernate.h>
#endif

#include <machine/conf.h>
#include <machine/cpufunc.h>
#include <machine/bus.h>

#include <dev/rndvar.h>
#include <dev/pci/pcivar.h>
#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/dsdt.h>
#include <dev/wscons/wsdisplayvar.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

#include <dev/pci/pciidevar.h>

#include <machine/apmvar.h>
#define APMUNIT(dev)	(minor(dev)&0xf0)
#define APMDEV(dev)	(minor(dev)&0x0f)
#define APMDEV_NORMAL	0
#define APMDEV_CTL	8

#include "wd.h"
#include "wsdisplay.h"

#ifdef ACPI_DEBUG
int	acpi_debug = 16;
#endif

int	acpi_poll_enabled;
int	acpi_hasprocfvs;

#define ACPIEN_RETRIES 15

void 	acpi_pci_match(struct device *, struct pci_attach_args *);
pcireg_t acpi_pci_min_powerstate(pci_chipset_tag_t, pcitag_t);
void	 acpi_pci_set_powerstate(pci_chipset_tag_t, pcitag_t, int, int);
int	acpi_pci_notify(struct aml_node *, int, void *);

int	acpi_match(struct device *, void *, void *);
void	acpi_attach(struct device *, struct device *, void *);
int	acpi_submatch(struct device *, void *, void *);
int	acpi_print(void *, const char *);

void	acpi_map_pmregs(struct acpi_softc *);
void	acpi_unmap_pmregs(struct acpi_softc *);

int	acpi_loadtables(struct acpi_softc *, struct acpi_rsdp *);

int	_acpi_matchhids(const char *, const char *[]);

int	acpi_inidev(struct aml_node *, void *);
int	acpi_foundprt(struct aml_node *, void *);

int	acpi_enable(struct acpi_softc *);
void	acpi_init_states(struct acpi_softc *);

void 	acpi_gpe_task(void *, int);
void	acpi_sbtn_task(void *, int);
void	acpi_pbtn_task(void *, int);

int	acpi_enabled;

void	acpi_init_gpes(struct acpi_softc *);
void	acpi_disable_allgpes(struct acpi_softc *);
struct gpe_block *acpi_find_gpe(struct acpi_softc *, int);
void	acpi_enable_onegpe(struct acpi_softc *, int);
int	acpi_gpe(struct acpi_softc *, int, void *);

void	acpi_enable_rungpes(struct acpi_softc *);
void	acpi_enable_wakegpes(struct acpi_softc *, int);


int	acpi_foundec(struct aml_node *, void *);
int	acpi_foundsony(struct aml_node *node, void *arg);
int	acpi_foundhid(struct aml_node *, void *);
int	acpi_add_device(struct aml_node *node, void *arg);

void	acpi_thread(void *);
void	acpi_create_thread(void *);

#ifndef SMALL_KERNEL

void	acpi_indicator(struct acpi_softc *, int);

int	acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
	    const char *driver);

void	acpi_init_pm(struct acpi_softc *);

int	acpi_founddock(struct aml_node *, void *);
int	acpi_foundpss(struct aml_node *, void *);
int	acpi_foundtmp(struct aml_node *, void *);
int	acpi_foundprw(struct aml_node *, void *);
int	acpi_foundvideo(struct aml_node *, void *);
int	acpi_foundsbs(struct aml_node *node, void *);

int	acpi_foundide(struct aml_node *node, void *arg);
int	acpiide_notify(struct aml_node *, int, void *);
void	wdcattach(struct channel_softc *);
int	wdcdetach(struct channel_softc *, int);
int	is_ejectable_bay(struct aml_node *node);
int	is_ata(struct aml_node *node);
int	is_ejectable(struct aml_node *node);

struct idechnl {
	struct acpi_softc *sc;
	int64_t		addr;
	int64_t		chnl;
	int64_t		sta;
};

/*
 * This is a list of Synaptics devices with a 'top button area'
 * based on the list in Linux supplied by Synaptics
 * Synaptics clickpads with the following pnp ids will get a unique
 * wscons mouse type that is used to define trackpad regions that will
 * emulate mouse buttons
 */
static const char *sbtn_pnp[] = {
	"LEN0017",
	"LEN0018",
	"LEN0019",
	"LEN0023",
	"LEN002A",
	"LEN002B",
	"LEN002C",
	"LEN002D",
	"LEN002E",
	"LEN0033",
	"LEN0034",
	"LEN0035",
	"LEN0036",
	"LEN0037",
	"LEN0038",
	"LEN0039",
	"LEN0041",
	"LEN0042",
	"LEN0045",
	"LEN0047",
	"LEN0049",
	"LEN2000",
	"LEN2001",
	"LEN2002",
	"LEN2003",
	"LEN2004",
	"LEN2005",
	"LEN2006",
	"LEN2007",
	"LEN2008",
	"LEN2009",
	"LEN200A",
	"LEN200B",
};

int	mouse_has_softbtn;
#endif /* SMALL_KERNEL */

/* XXX move this into dsdt softc at some point */
extern struct aml_node aml_root;

struct cfattach acpi_ca = {
	sizeof(struct acpi_softc), acpi_match, acpi_attach
};

struct cfdriver acpi_cd = {
	NULL, "acpi", DV_DULL
};

struct acpi_softc *acpi_softc;

#define acpi_bus_space_map	_bus_space_map
#define acpi_bus_space_unmap	_bus_space_unmap

uint8_t
acpi_pci_conf_read_1(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	uint32_t val = pci_conf_read(pc, tag, reg & ~0x3);
	return (val >> ((reg & 0x3) << 3));
}

uint16_t
acpi_pci_conf_read_2(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	uint32_t val = pci_conf_read(pc, tag, reg & ~0x2);
	return (val >> ((reg & 0x2) << 3));
}

uint32_t
acpi_pci_conf_read_4(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	return pci_conf_read(pc, tag, reg);
}

void
acpi_pci_conf_write_1(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint8_t val)
{
	uint32_t tmp = pci_conf_read(pc, tag, reg & ~0x3);
	tmp &= ~(0xff << ((reg & 0x3) << 3));
	tmp |= (val << ((reg & 0x3) << 3));
	pci_conf_write(pc, tag, reg & ~0x3, tmp);
}

void
acpi_pci_conf_write_2(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint16_t val)
{
	uint32_t tmp = pci_conf_read(pc, tag, reg & ~0x2);
	tmp &= ~(0xffff << ((reg & 0x2) << 3));
	tmp |= (val << ((reg & 0x2) << 3));
	pci_conf_write(pc, tag, reg & ~0x2, tmp);
}

void
acpi_pci_conf_write_4(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint32_t val)
{
	pci_conf_write(pc, tag, reg, val);
}

int
acpi_gasio(struct acpi_softc *sc, int iodir, int iospace, uint64_t address,
    int access_size, int len, void *buffer)
{
	u_int8_t *pb;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	pci_chipset_tag_t pc;
	pcitag_t tag;
	int reg, idx;

	dnprintf(50, "gasio: %.2x 0x%.8llx %s\n",
	    iospace, address, (iodir == ACPI_IOWRITE) ? "write" : "read");

	KASSERT((len % access_size) == 0);

	pb = (u_int8_t *)buffer;
	switch (iospace) {
	case GAS_SYSTEM_MEMORY:
	case GAS_SYSTEM_IOSPACE:
		if (iospace == GAS_SYSTEM_MEMORY)
			iot = sc->sc_memt;
		else
			iot = sc->sc_iot;

		if (acpi_bus_space_map(iot, address, len, 0, &ioh) != 0) {
			printf("%s: unable to map iospace\n", DEVNAME(sc));
			return (-1);
		}
		for (reg = 0; reg < len; reg += access_size) {
			if (iodir == ACPI_IOREAD) {
				switch (access_size) {
				case 1:
					*(uint8_t *)(pb + reg) = 
					    bus_space_read_1(iot, ioh, reg);
					dnprintf(80, "os_in8(%llx) = %x\n",
					    reg+address, *(uint8_t *)(pb+reg));
					break;
				case 2:
					*(uint16_t *)(pb + reg) =
					    bus_space_read_2(iot, ioh, reg);
					dnprintf(80, "os_in16(%llx) = %x\n",
					    reg+address, *(uint16_t *)(pb+reg));
					break;
				case 4:
					*(uint32_t *)(pb + reg) =
					    bus_space_read_4(iot, ioh, reg);
					break;
				default:
					printf("%s: rdio: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
			} else {
				switch (access_size) {
				case 1:
					bus_space_write_1(iot, ioh, reg,
					    *(uint8_t *)(pb + reg));
					dnprintf(80, "os_out8(%llx,%x)\n",
					    reg+address, *(uint8_t *)(pb+reg));
					break;
				case 2:
					bus_space_write_2(iot, ioh, reg,
					    *(uint16_t *)(pb + reg));
					dnprintf(80, "os_out16(%llx,%x)\n",
					    reg+address, *(uint16_t *)(pb+reg));
					break;
				case 4:
					bus_space_write_4(iot, ioh, reg,
					    *(uint32_t *)(pb + reg));
					break;
				default:
					printf("%s: wrio: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
			}
		}
		acpi_bus_space_unmap(iot, ioh, len, NULL);
		break;

	case GAS_PCI_CFG_SPACE:
		/* format of address:
		 *    bits 00..15 = register
		 *    bits 16..31 = function
		 *    bits 32..47 = device
		 *    bits 48..63 = bus
		 */

		/*
		 * The ACPI standard says that a function number of
		 * FFFF can be used to refer to all functions on a
		 * device.  This makes no sense though in the context
		 * of accessing PCI config space.  Yet there is AML
		 * out there that does this.  We simulate a read from
		 * a nonexistent device here.  Writes will panic when
		 * we try to construct the tag below.
		 */
		if (ACPI_PCI_FN(address) == 0xffff && iodir == ACPI_IOREAD) {
			memset(buffer, 0xff, len);
			return (0);
		}

		pc = NULL;
		tag = pci_make_tag(pc,
		    ACPI_PCI_BUS(address), ACPI_PCI_DEV(address),
		    ACPI_PCI_FN(address));

		reg = ACPI_PCI_REG(address);
		for (idx = 0; idx < len; idx += access_size) {
			if (iodir == ACPI_IOREAD) {
				switch (access_size) {
				case 1:
					*(uint8_t *)(pb + idx) = 
					    acpi_pci_conf_read_1(pc, tag, reg + idx);
					break;
				case 2:
					*(uint16_t *)(pb + idx) =
					    acpi_pci_conf_read_2(pc, tag, reg + idx);
					break;
				case 4:
					*(uint32_t *)(pb + idx) =
					    acpi_pci_conf_read_4(pc, tag, reg + idx);
					break;
				default:
					printf("%s: rdcfg: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
			} else {
				switch (access_size) {
				case 1:
					acpi_pci_conf_write_1(pc, tag, reg + idx,
					    *(uint8_t *)(pb + idx));
					break;
				case 2:
					acpi_pci_conf_write_2(pc, tag, reg + idx,
					    *(uint16_t *)(pb + idx));
					break;
				case 4:
					acpi_pci_conf_write_4(pc, tag, reg + idx,
					    *(uint32_t *)(pb + idx));
					break;
				default:
					printf("%s: wrcfg: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
			}
		}
		break;

	case GAS_EMBEDDED:
		if (sc->sc_ec == NULL) {
			printf("%s: WARNING EC not initialized\n", DEVNAME(sc));
			return (-1);
		}
		if (iodir == ACPI_IOREAD)
			acpiec_read(sc->sc_ec, (u_int8_t)address, len, buffer);
		else
			acpiec_write(sc->sc_ec, (u_int8_t)address, len, buffer);
		break;
	}
	return (0);
}

int
acpi_inidev(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	int64_t st;

	/*
	 * Per the ACPI spec 6.5.1, only run _INI when device is there or
	 * when there is no _STA.  We terminate the tree walk (with return 1)
	 * early if necessary.
	 */

	/* Evaluate _STA to decide _INI fate and walk fate */
	if (aml_evalinteger(sc, node->parent, "_STA", 0, NULL, &st))
		st = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	/* Evaluate _INI if we are present */
	if (st & STA_PRESENT)
		aml_evalnode(sc, node, 0, NULL, NULL);

	/* If we are functioning, we walk/search our children */
	if (st & STA_DEV_OK)
		return 0;

	/* If we are not enabled, or not present, terminate search */
	if (!(st & (STA_PRESENT|STA_ENABLED)))
		return 1;

	/* Default just continue search */
	return 0;
}

int
acpi_foundprt(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	struct acpi_attach_args	aaa;
	int64_t st = 0;

	dnprintf(10, "found prt entry: %s\n", node->parent->name);

	/* Evaluate _STA to decide _PRT fate and walk fate */
	if (aml_evalinteger(sc, node->parent, "_STA", 0, NULL, &st))
		st = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	if (st & STA_PRESENT) {
		memset(&aaa, 0, sizeof(aaa));
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
		aaa.aaa_node = node;
		aaa.aaa_name = "acpiprt";

		config_found(self, &aaa, acpi_print);
	}

	/* If we are functioning, we walk/search our children */
	if (st & STA_DEV_OK)
		return 0;

	/* If we are not enabled, or not present, terminate search */
	if (!(st & (STA_PRESENT|STA_ENABLED)))
		return 1;

	/* Default just continue search */
	return 0;
}

int
acpi_match(struct device *parent, void *match, void *aux)
{
	struct bios_attach_args	*ba = aux;
	struct cfdata		*cf = match;

	/* sanity */
	if (strcmp(ba->ba_name, cf->cf_driver->cd_name))
		return (0);

	if (!acpi_probe(parent, cf, ba))
		return (0);

	return (1);
}

TAILQ_HEAD(, acpi_pci) acpi_pcidevs =
    TAILQ_HEAD_INITIALIZER(acpi_pcidevs);
TAILQ_HEAD(, acpi_pci) acpi_pcirootdevs = 
    TAILQ_HEAD_INITIALIZER(acpi_pcirootdevs);

int acpi_getpci(struct aml_node *node, void *arg);
int acpi_getminbus(int crsidx, union acpi_resource *crs, void *arg);

int
acpi_getminbus(int crsidx, union acpi_resource *crs, void *arg)
{
	int *bbn = arg;
	int typ = AML_CRSTYPE(crs);

	/* Check for embedded bus number */
	if (typ == LR_WORD && crs->lr_word.type == 2) {
		/* If _MIN > _MAX, the resource is considered to be invalid. */
		if (crs->lr_word._min > crs->lr_word._max)
			return -1;
		*bbn = crs->lr_word._min;
	}
	return 0;
}

int
_acpi_matchhids(const char *hid, const char *hids[])
{
	int i;

	for (i = 0; hids[i]; i++) 
		if (!strcmp(hid, hids[i]))
			return (1);
	return (0);
}

int
acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
    const char *driver)
{
	if (aa->aaa_dev == NULL || aa->aaa_node == NULL)
		return (0);
	if (_acpi_matchhids(aa->aaa_dev, hids)) {
		dnprintf(5, "driver %s matches at least one hid\n", driver);
		return (1);
	}

	return (0);
}

/* Map ACPI device node to PCI */
int
acpi_getpci(struct aml_node *node, void *arg)
{
	const char *pcihid[] = { ACPI_DEV_PCIB, ACPI_DEV_PCIEB, "HWP0002", 0 };
	struct acpi_pci *pci, *ppci;
	struct aml_value res;
	struct acpi_softc *sc = arg;
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	uint64_t val;
	uint32_t reg;

	if (!node->value || node->value->type != AML_OBJTYPE_DEVICE)
		return 0;
	if (!aml_evalhid(node, &res)) {
		/* Check if this is a PCI Root node */
		if (_acpi_matchhids(res.v_string, pcihid)) {
			aml_freevalue(&res);

			pci = malloc(sizeof(*pci), M_DEVBUF, M_WAITOK|M_ZERO);

			pci->bus = -1;
			if (!aml_evalinteger(sc, node, "_SEG", 0, NULL, &val))
				pci->seg = val;
			if (!aml_evalname(sc, node, "_CRS", 0, NULL, &res)) {
				aml_parse_resource(&res, acpi_getminbus,
				    &pci->bus);
				dnprintf(10, "%s post-crs: %d\n", aml_nodename(node), 
				    pci->bus);
			}
			if (!aml_evalinteger(sc, node, "_BBN", 0, NULL, &val)) {
				dnprintf(10, "%s post-bbn: %d, %lld\n", aml_nodename(node), 
				    pci->bus, val);
				if (pci->bus == -1)
					pci->bus = val;
			}
			pci->sub = pci->bus;
			node->pci = pci;
			dnprintf(10, "found PCI root: %s %d\n",
			    aml_nodename(node), pci->bus);
			TAILQ_INSERT_TAIL(&acpi_pcirootdevs, pci, next);
		}
		aml_freevalue(&res);
		return 0;
	}

	/* If parent is not PCI, or device does not have _ADR, return */
	if (!node->parent || (ppci = node->parent->pci) == NULL)
		return 0;
	if (aml_evalinteger(sc, node, "_ADR", 0, NULL, &val))
		return 0;

	pci = malloc(sizeof(*pci), M_DEVBUF, M_WAITOK|M_ZERO);
	pci->bus = ppci->sub;
	pci->dev = ACPI_ADR_PCIDEV(val);
	pci->fun = ACPI_ADR_PCIFUN(val);
	pci->node = node;
	pci->sub = -1;

	dnprintf(10, "%.2x:%.2x.%x -> %s\n", 
		pci->bus, pci->dev, pci->fun,
		aml_nodename(node));

	/* Collect device power state information. */
	if (aml_evalinteger(sc, node, "_S3D", 0, NULL, &val) == 0)
		pci->_s3d = val;
	else
		pci->_s3d = -1;
	if (aml_evalinteger(sc, node, "_S3W", 0, NULL, &val) == 0)
		pci->_s3w = val;
	else
		pci->_s3w = -1;
	if (aml_evalinteger(sc, node, "_S4D", 0, NULL, &val) == 0)
		pci->_s4d = val;
	else
		pci->_s4d = -1;
	if (aml_evalinteger(sc, node, "_S4W", 0, NULL, &val) == 0)
		pci->_s4w = val;
	else
		pci->_s4w = -1;

	/* Check if PCI device exists */
	if (pci->dev > 0x1F || pci->fun > 7) {
		free(pci, M_DEVBUF, sizeof(*pci));
		return (1);
	}
	tag = pci_make_tag(pc, pci->bus, pci->dev, pci->fun);
	reg = pci_conf_read(pc, tag, PCI_ID_REG);
	if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID) {
		free(pci, M_DEVBUF, sizeof(*pci));
		return (1);
	}
	node->pci = pci;

	TAILQ_INSERT_TAIL(&acpi_pcidevs, pci, next);

	/* Check if this is a PCI bridge */
	reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
	if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI) {
		reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
		pci->sub = PPB_BUSINFO_SECONDARY(reg);

		dnprintf(10, "found PCI bridge: %s %d\n", 
		    aml_nodename(node), pci->sub);

		/* Continue scanning */
		return (0);
	}

	/* Device does not have children, stop scanning */
	return (1);
}

void
acpi_pci_match(struct device *dev, struct pci_attach_args *pa)
{
	struct acpi_pci *pdev;
	int state;

	TAILQ_FOREACH(pdev, &acpi_pcidevs, next) {
		if (pdev->bus != pa->pa_bus ||
		    pdev->dev != pa->pa_device ||
		    pdev->fun != pa->pa_function)
			continue;

		dnprintf(10,"%s at acpi0 %s\n", dev->dv_xname,
		    aml_nodename(pdev->node));

		pdev->device = dev;

		/*
		 * If some Power Resources are dependent on this device
		 * initialize them.
		 */
		state = pci_get_powerstate(pa->pa_pc, pa->pa_tag);
		acpi_pci_set_powerstate(pa->pa_pc, pa->pa_tag, state, 1);
		acpi_pci_set_powerstate(pa->pa_pc, pa->pa_tag, state, 0);

		aml_register_notify(pdev->node, NULL, acpi_pci_notify, pdev, 0);
	}
}

pcireg_t
acpi_pci_min_powerstate(pci_chipset_tag_t pc, pcitag_t tag)
{
	struct acpi_pci *pdev;
	int bus, dev, fun;
	int state = -1, defaultstate = pci_get_powerstate(pc, tag);

	pci_decompose_tag(pc, tag, &bus, &dev, &fun);
	TAILQ_FOREACH(pdev, &acpi_pcidevs, next) {
		if (pdev->bus == bus && pdev->dev == dev && pdev->fun == fun) {
			switch (acpi_softc->sc_state) {
			case ACPI_STATE_S3:
				defaultstate = PCI_PMCSR_STATE_D3;
				state = MAX(pdev->_s3d, pdev->_s3w);
				break;
			case ACPI_STATE_S4:
				state = MAX(pdev->_s4d, pdev->_s4w);
				break;
			case ACPI_STATE_S5:
			default:
				break;
			}

			if (state >= PCI_PMCSR_STATE_D0 &&
			    state <= PCI_PMCSR_STATE_D3)
				return state;
		}
	}

	return defaultstate;
}

void
acpi_pci_set_powerstate(pci_chipset_tag_t pc, pcitag_t tag, int state, int pre)
{
#if NACPIPWRRES > 0
	struct acpi_softc *sc = acpi_softc;
	struct acpi_pwrres *pr;
	struct acpi_pci *pdev;
	int bus, dev, fun;
	char name[5];

	pci_decompose_tag(pc, tag, &bus, &dev, &fun);
	TAILQ_FOREACH(pdev, &acpi_pcidevs, next) {
		if (pdev->bus == bus && pdev->dev == dev && pdev->fun == fun)
			break;
	}

	/* XXX Add a check to discard nodes without Power Resources? */
	if (pdev == NULL)
		return;

	SIMPLEQ_FOREACH(pr, &sc->sc_pwrresdevs, p_next) {
		if (pr->p_node != pdev->node)
			continue;

		/*
		 * If the firmware is already aware that the device
		 * is in the given state, there's nothing to do.
		 */
		if (pr->p_state == state)
			continue;

		if (pre) {
			/*
			 * If a Resource is dependent on this device for
			 * the given state, make sure it is turned "_ON".
			 */
			if (pr->p_res_state == state)
				acpipwrres_ref_incr(pr->p_res_sc, pr->p_node);
		} else {
			/*
			 * If a Resource was referenced for the state we
			 * left, drop a reference and turn it "_OFF" if
			 * it was the last one.
			 */
			if (pr->p_res_state == pr->p_state)
				acpipwrres_ref_decr(pr->p_res_sc, pr->p_node);

			if (pr->p_res_state == state) {
				snprintf(name, sizeof(name), "_PS%d", state);
				aml_evalname(sc, pr->p_node, name, 0,
				    NULL, NULL);
			}

			pr->p_state = state;
		}

	}
#endif /* NACPIPWRRES > 0 */
}

int
acpi_pci_notify(struct aml_node *node, int ntype, void *arg)
{
	struct acpi_pci *pdev = arg;
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	pcireg_t reg;
	int offset;

	/* We're only interested in Device Wake notifications. */
	if (ntype != 2)
		return (0);

	tag = pci_make_tag(pc, pdev->bus, pdev->dev, pdev->fun);
	if (pci_get_capability(pc, tag, PCI_CAP_PWRMGMT, &offset, 0)) {
		/* Clear the PME Status bit if it is set. */
		reg = pci_conf_read(pc, tag, offset + PCI_PMCSR);
		pci_conf_write(pc, tag, offset + PCI_PMCSR, reg);
	}

	return (0);
}

void
acpi_pciroots_attach(struct device *dev, void *aux, cfprint_t pr)
{
	struct acpi_pci			*pdev;
	struct pcibus_attach_args	*pba = aux;

	KASSERT(pba->pba_busex != NULL);

	TAILQ_FOREACH(pdev, &acpi_pcirootdevs, next) {
		if (extent_alloc_region(pba->pba_busex, pdev->bus,
		    1, EX_NOWAIT) != 0)
			continue;
		pba->pba_bus = pdev->bus;
		config_found(dev, pba, pr);
	}
}

void
acpi_attach(struct device *parent, struct device *self, void *aux)
{
	struct bios_attach_args *ba = aux;
	struct acpi_softc *sc = (struct acpi_softc *)self;
	struct acpi_mem_map handle;
	struct acpi_rsdp *rsdp;
	struct acpi_q *entry;
	struct acpi_dsdt *p_dsdt;
#ifndef SMALL_KERNEL
	int wakeup_dev_ct;
	struct acpi_wakeq *wentry;
	struct device *dev;
#endif /* SMALL_KERNEL */
	paddr_t facspa;
	uint16_t pm1;
	int s;

	sc->sc_iot = ba->ba_iot;
	sc->sc_memt = ba->ba_memt;

	rw_init(&sc->sc_lck, "acpilk");

	acpi_softc = sc;

	if (acpi_map(ba->ba_acpipbase, sizeof(struct acpi_rsdp), &handle)) {
		printf(": can't map memory\n");
		return;
	}

	rsdp = (struct acpi_rsdp *)handle.va;
	sc->sc_revision = (int)rsdp->rsdp_revision;
	printf(": rev %d", sc->sc_revision);

	SIMPLEQ_INIT(&sc->sc_tables);
	SIMPLEQ_INIT(&sc->sc_wakedevs);
#if NACPIPWRRES > 0
	SIMPLEQ_INIT(&sc->sc_pwrresdevs);
#endif /* NACPIPWRRES > 0 */


#ifndef SMALL_KERNEL
	sc->sc_note = malloc(sizeof(struct klist), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_note == NULL) {
		printf(", can't allocate memory\n");
		acpi_unmap(&handle);
		return;
	}
#endif /* SMALL_KERNEL */

	if (acpi_loadtables(sc, rsdp)) {
		printf(", can't load tables\n");
		acpi_unmap(&handle);
		return;
	}

	acpi_unmap(&handle);

	/*
	 * Find the FADT
	 */
	SIMPLEQ_FOREACH(entry, &sc->sc_tables, q_next) {
		if (memcmp(entry->q_table, FADT_SIG,
		    sizeof(FADT_SIG) - 1) == 0) {
			sc->sc_fadt = entry->q_table;
			break;
		}
	}
	if (sc->sc_fadt == NULL) {
		printf(", no FADT\n");
		return;
	}

	/*
	 * A bunch of things need to be done differently for
	 * Hardware-reduced ACPI.
	 */
	if (sc->sc_fadt->hdr_revision >= 5 &&
	    sc->sc_fadt->flags & FADT_HW_REDUCED_ACPI)
		sc->sc_hw_reduced = 1;

	/* Map Power Management registers */
	acpi_map_pmregs(sc);

	/*
	 * Check if we can and need to enable ACPI control.
	 */
	pm1 = acpi_read_pmreg(sc, ACPIREG_PM1_CNT, 0);
	if ((pm1 & ACPI_PM1_SCI_EN) == 0 && sc->sc_fadt->smi_cmd &&
	    (!sc->sc_fadt->acpi_enable && !sc->sc_fadt->acpi_disable)) {
		printf(", ACPI control unavailable\n");
		acpi_unmap_pmregs(sc);
		return;
	}

	/*
	 * Set up a pointer to the firmware control structure
	 */
	if (sc->sc_fadt->hdr_revision < 3 || sc->sc_fadt->x_firmware_ctl == 0)
		facspa = sc->sc_fadt->firmware_ctl;
	else
		facspa = sc->sc_fadt->x_firmware_ctl;

	if (acpi_map(facspa, sizeof(struct acpi_facs), &handle))
		printf(" !FACS");
	else
		sc->sc_facs = (struct acpi_facs *)handle.va;

	/* Create opcode hashtable */
	aml_hashopcodes();

	/* Create Default AML objects */
	aml_create_defaultobjects();

	/*
	 * Load the DSDT from the FADT pointer -- use the
	 * extended (64-bit) pointer if it exists
	 */
	if (sc->sc_fadt->hdr_revision < 3 || sc->sc_fadt->x_dsdt == 0)
		entry = acpi_maptable(sc, sc->sc_fadt->dsdt, NULL, NULL, NULL, -1);
	else
		entry = acpi_maptable(sc, sc->sc_fadt->x_dsdt, NULL, NULL, NULL, -1);

	if (entry == NULL)
		printf(" !DSDT");

	p_dsdt = entry->q_table;
	acpi_parse_aml(sc, p_dsdt->aml, p_dsdt->hdr_length -
	    sizeof(p_dsdt->hdr));

	/* Load SSDT's */
	SIMPLEQ_FOREACH(entry, &sc->sc_tables, q_next) {
		if (memcmp(entry->q_table, SSDT_SIG,
		    sizeof(SSDT_SIG) - 1) == 0) {
			p_dsdt = entry->q_table;
			acpi_parse_aml(sc, p_dsdt->aml, p_dsdt->hdr_length -
			    sizeof(p_dsdt->hdr));
		}
	}

	/* Perform post-parsing fixups */
	aml_postparse();


#ifndef SMALL_KERNEL
	/* Find available sleeping states */
	acpi_init_states(sc);

	/* Find available sleep/resume related methods. */
	acpi_init_pm(sc);
#endif /* SMALL_KERNEL */

	/* Initialize GPE handlers */
	s = spltty();
	acpi_init_gpes(sc);
	splx(s);

	/* some devices require periodic polling */
	timeout_set(&sc->sc_dev_timeout, acpi_poll, sc);

	acpi_enabled = 1;

	/*
	 * Take over ACPI control.  Note that once we do this, we
	 * effectively tell the system that we have ownership of
	 * the ACPI hardware registers, and that SMI should leave
	 * them alone
	 *
	 * This may prevent thermal control on some systems where
	 * that actually does work
	 */
	if ((pm1 & ACPI_PM1_SCI_EN) == 0 && sc->sc_fadt->smi_cmd) {
		if (acpi_enable(sc)) {
			printf(", can't enable ACPI\n");
			return;
		}
	}

	printf("\n%s: tables", DEVNAME(sc));
	SIMPLEQ_FOREACH(entry, &sc->sc_tables, q_next) {
		printf(" %.4s", (char *)entry->q_table);
	}
	printf("\n");

#ifndef SMALL_KERNEL
	/* Display wakeup devices and lowest S-state */
	wakeup_dev_ct = 0;
	printf("%s: wakeup devices", DEVNAME(sc));
	SIMPLEQ_FOREACH(wentry, &sc->sc_wakedevs, q_next) {
		if (wakeup_dev_ct < 16)
			printf(" %.4s(S%d)", wentry->q_node->name,
			    wentry->q_state);
		else if (wakeup_dev_ct == 16)
			printf(" [...]");
		wakeup_dev_ct ++;
	}
	printf("\n");

	/*
	 * ACPI is enabled now -- attach timer
	 */
	if (!sc->sc_hw_reduced &&
	    (sc->sc_fadt->pm_tmr_blk || sc->sc_fadt->x_pm_tmr_blk.address)) {
		struct acpi_attach_args aaa;

		memset(&aaa, 0, sizeof(aaa));
		aaa.aaa_name = "acpitimer";
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
#if 0
		aaa.aaa_pcit = sc->sc_pcit;
		aaa.aaa_smbust = sc->sc_smbust;
#endif
		config_found(self, &aaa, acpi_print);
	}
#endif /* SMALL_KERNEL */

	/*
	 * Attach table-defined devices
	 */
	SIMPLEQ_FOREACH(entry, &sc->sc_tables, q_next) {
		struct acpi_attach_args aaa;

		memset(&aaa, 0, sizeof(aaa));
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
	#if 0
		aaa.aaa_pcit = sc->sc_pcit;
		aaa.aaa_smbust = sc->sc_smbust;
	#endif
		aaa.aaa_table = entry->q_table;
		config_found_sm(self, &aaa, acpi_print, acpi_submatch);
	}

	/* initialize runtime environment */
	aml_find_node(&aml_root, "_INI", acpi_inidev, sc);

	/* Get PCI mapping */
	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_getpci, sc);

	/* attach pci interrupt routing tables */
	aml_find_node(&aml_root, "_PRT", acpi_foundprt, sc);

	aml_find_node(&aml_root, "_HID", acpi_foundec, sc);

	/* check if we're running on a sony */
	aml_find_node(&aml_root, "GBRT", acpi_foundsony, sc);

	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_add_device, sc);

#ifndef SMALL_KERNEL
	/* try to find smart battery first */
	aml_find_node(&aml_root, "_HID", acpi_foundsbs, sc);
#endif /* SMALL_KERNEL */

	/* attach battery, power supply and button devices */
	aml_find_node(&aml_root, "_HID", acpi_foundhid, sc);

#ifndef SMALL_KERNEL
#if NWD > 0
	/* Attach IDE bay */
	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_foundide, sc);
#endif

	/* attach docks */
	aml_find_node(&aml_root, "_DCK", acpi_founddock, sc);

	/* attach video */
	aml_find_node(&aml_root, "_DOS", acpi_foundvideo, sc);

	/* create list of devices we want to query when APM comes in */
	SLIST_INIT(&sc->sc_ac);
	SLIST_INIT(&sc->sc_bat);
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (!strcmp(dev->dv_cfdata->cf_driver->cd_name, "acpiac")) {
			struct acpi_ac *ac;

			ac = malloc(sizeof(*ac), M_DEVBUF, M_WAITOK | M_ZERO);
			ac->aac_softc = (struct acpiac_softc *)dev;
			SLIST_INSERT_HEAD(&sc->sc_ac, ac, aac_link);
		} else if (!strcmp(dev->dv_cfdata->cf_driver->cd_name, "acpibat")) {
			struct acpi_bat *bat;

			bat = malloc(sizeof(*bat), M_DEVBUF, M_WAITOK | M_ZERO);
			bat->aba_softc = (struct acpibat_softc *)dev;
			SLIST_INSERT_HEAD(&sc->sc_bat, bat, aba_link);
		} else if (!strcmp(dev->dv_cfdata->cf_driver->cd_name, "acpisbs")) {
			struct acpi_sbs *sbs;

			sbs = malloc(sizeof(*sbs), M_DEVBUF, M_WAITOK | M_ZERO);
			sbs->asbs_softc = (struct acpisbs_softc *)dev;
			SLIST_INSERT_HEAD(&sc->sc_sbs, sbs, asbs_link);
		}
	}

#endif /* SMALL_KERNEL */

	/* Setup threads */
	sc->sc_thread = malloc(sizeof(struct acpi_thread), M_DEVBUF, M_WAITOK);
	sc->sc_thread->sc = sc;
	sc->sc_thread->running = 1;

	/* Enable PCI Power Management. */
	pci_dopm = 1;

	acpi_attach_machdep(sc);

	kthread_create_deferred(acpi_create_thread, sc);
}

int
acpi_submatch(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args *aaa = (struct acpi_attach_args *)aux;
	struct cfdata *cf = match;

	if (aaa->aaa_table == NULL)
		return (0);
	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

int
acpi_print(void *aux, const char *pnp)
{
	struct acpi_attach_args *aa = aux;

	if (pnp) {
		if (aa->aaa_name)
			printf("%s at %s", aa->aaa_name, pnp);
		else if (aa->aaa_dev)
			printf("\"%s\" at %s", aa->aaa_dev, pnp);
		else
			return (QUIET);
	}

	return (UNCONF);
}

struct acpi_q *
acpi_maptable(struct acpi_softc *sc, paddr_t addr, const char *sig,
    const char *oem, const char *tbl, int flag)
{
	static int tblid;
	struct acpi_mem_map handle;
	struct acpi_table_header *hdr;
	struct acpi_q *entry;
	size_t len;

	/* Check if we can map address */
	if (addr == 0)
		return NULL;
	if (acpi_map(addr, sizeof(*hdr), &handle))
		return NULL;
	hdr = (struct acpi_table_header *)handle.va;
	len = hdr->length;
	acpi_unmap(&handle);

	/* Validate length/checksum */
	if (acpi_map(addr, len, &handle))
		return NULL;
	hdr = (struct acpi_table_header *)handle.va;
	if (acpi_checksum(hdr, len))
		printf("\n%s: %.4s checksum error",
		    DEVNAME(sc), hdr->signature);

	if ((sig && memcmp(sig, hdr->signature, 4)) ||
	    (oem && memcmp(oem, hdr->oemid, 6)) ||
	    (tbl && memcmp(tbl, hdr->oemtableid, 8))) {
		acpi_unmap(&handle);
		return NULL;
	}

	/* Allocate copy */
	entry = malloc(sizeof(*entry) + len, M_DEVBUF, M_NOWAIT);
	if (entry != NULL) {
		memcpy(entry->q_data, handle.va, len);
		entry->q_table = entry->q_data;
		entry->q_id = ++tblid;

		if (flag < 0)
			SIMPLEQ_INSERT_HEAD(&sc->sc_tables, entry,
			    q_next);
		else if (flag > 0)
			SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry,
			    q_next);
	}
	acpi_unmap(&handle);
	return entry;
}

int
acpi_loadtables(struct acpi_softc *sc, struct acpi_rsdp *rsdp)
{
	struct acpi_q *sdt;
	int i, ntables;
	size_t len;

	if (rsdp->rsdp_revision == 2 && rsdp->rsdp_xsdt) {
		struct acpi_xsdt *xsdt;

		sdt = acpi_maptable(sc, rsdp->rsdp_xsdt, NULL, NULL, NULL, 0);
		if (sdt == NULL) {
			printf("couldn't map rsdt\n");
			return (ENOMEM);
		}

		xsdt = (struct acpi_xsdt *)sdt->q_data;
		len  = xsdt->hdr.length;
		ntables = (len - sizeof(struct acpi_table_header)) /
		    sizeof(xsdt->table_offsets[0]);

		for (i = 0; i < ntables; i++)
			acpi_maptable(sc, xsdt->table_offsets[i], NULL, NULL,
			    NULL, 1);

		free(sdt, M_DEVBUF, 0);
	} else {
		struct acpi_rsdt *rsdt;

		sdt = acpi_maptable(sc, rsdp->rsdp_rsdt, NULL, NULL, NULL, 0);
		if (sdt == NULL) {
			printf("couldn't map rsdt\n");
			return (ENOMEM);
		}

		rsdt = (struct acpi_rsdt *)sdt->q_data;
		len  = rsdt->hdr.length;
		ntables = (len - sizeof(struct acpi_table_header)) /
		    sizeof(rsdt->table_offsets[0]);

		for (i = 0; i < ntables; i++)
			acpi_maptable(sc, rsdt->table_offsets[i], NULL, NULL,
			    NULL, 1);

		free(sdt, M_DEVBUF, 0);
	}

	return (0);
}

/* Read from power management register */
int
acpi_read_pmreg(struct acpi_softc *sc, int reg, int offset)
{
	bus_space_handle_t ioh;
	bus_size_t size;
	int regval;

	/*
	 * For Hardware-reduced ACPI we emulate PM1B_CNT to reflect
	 * that the system is always in ACPI mode.
	 */
	if (sc->sc_hw_reduced && reg == ACPIREG_PM1B_CNT) {
		KASSERT(offset == 0);
		return ACPI_PM1_SCI_EN;
	}

	/*
	 * For Hardware-reduced ACPI we also emulate PM1A_STS using
	 * SLEEP_STATUS_REG.
	 */
	if (sc->sc_hw_reduced && reg == ACPIREG_PM1A_STS) {
		uint8_t value;

		KASSERT(offset == 0);
		acpi_gasio(sc, ACPI_IOREAD,
		    sc->sc_fadt->sleep_status_reg.address_space_id,
		    sc->sc_fadt->sleep_status_reg.address,
		    sc->sc_fadt->sleep_status_reg.register_bit_width / 8,
		    sc->sc_fadt->sleep_status_reg.access_size, &value);
		return ((int)value << 8);
	}

	/* Special cases: 1A/1B blocks can be OR'ed together */
	switch (reg) {
	case ACPIREG_PM1_EN:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_EN, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_EN, offset));
	case ACPIREG_PM1_STS:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_STS, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_STS, offset));
	case ACPIREG_PM1_CNT:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, offset));
	case ACPIREG_GPE_STS:
		dnprintf(50, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset,
		    sc->sc_fadt->gpe0_blk_len>>1, sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		dnprintf(50, "read GPE_EN   offset: %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	if (reg >= ACPIREG_MAXREG || sc->sc_pmregs[reg].size == 0)
		return (0);

	regval = 0;
	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (size > sc->sc_pmregs[reg].access)
		size = sc->sc_pmregs[reg].access;

	switch (size) {
	case 1:
		regval = bus_space_read_1(sc->sc_iot, ioh, offset);
		break;
	case 2:
		regval = bus_space_read_2(sc->sc_iot, ioh, offset);
		break;
	case 4:
		regval = bus_space_read_4(sc->sc_iot, ioh, offset);
		break;
	}

	dnprintf(30, "acpi_readpm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name,
	    sc->sc_pmregs[reg].addr, offset, regval);
	return (regval);
}

/* Write to power management register */
void
acpi_write_pmreg(struct acpi_softc *sc, int reg, int offset, int regval)
{
	bus_space_handle_t ioh;
	bus_size_t size;

	/*
	 * For Hardware-reduced ACPI we also emulate PM1A_STS using
	 * SLEEP_STATUS_REG.
	 */
	if (sc->sc_hw_reduced && reg == ACPIREG_PM1A_STS) {
		uint8_t value = (regval >> 8);

		KASSERT(offset == 0);
		acpi_gasio(sc, ACPI_IOWRITE,
		    sc->sc_fadt->sleep_status_reg.address_space_id,
		    sc->sc_fadt->sleep_status_reg.address,
		    sc->sc_fadt->sleep_status_reg.register_bit_width / 8,
		    sc->sc_fadt->sleep_status_reg.access_size, &value);
		return;
	}

	/*
	 * For Hardware-reduced ACPI we also emulate PM1A_CNT using
	 * SLEEP_CONTROL_REG.
	 */
	if (sc->sc_hw_reduced && reg == ACPIREG_PM1A_CNT) {
		uint8_t value = (regval >> 8);

		KASSERT(offset == 0);
		acpi_gasio(sc, ACPI_IOWRITE,
		    sc->sc_fadt->sleep_control_reg.address_space_id,
		    sc->sc_fadt->sleep_control_reg.address,
		    sc->sc_fadt->sleep_control_reg.register_bit_width / 8,
		    sc->sc_fadt->sleep_control_reg.access_size, &value);
		return;
	}

	/* Special cases: 1A/1B blocks can be written with same value */
	switch (reg) {
	case ACPIREG_PM1_EN:
		acpi_write_pmreg(sc, ACPIREG_PM1A_EN, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_EN, offset, regval);
		break;
	case ACPIREG_PM1_STS:
		acpi_write_pmreg(sc, ACPIREG_PM1A_STS, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_STS, offset, regval);
		break;
	case ACPIREG_PM1_CNT:
		acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, offset, regval);
		break;
	case ACPIREG_GPE_STS:
		dnprintf(50, "write GPE_STS offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		dnprintf(50, "write GPE_EN  offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	/* All special case return here */
	if (reg >= ACPIREG_MAXREG)
		return;

	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (size > sc->sc_pmregs[reg].access)
		size = sc->sc_pmregs[reg].access;

	switch (size) {
	case 1:
		bus_space_write_1(sc->sc_iot, ioh, offset, regval);
		break;
	case 2:
		bus_space_write_2(sc->sc_iot, ioh, offset, regval);
		break;
	case 4:
		bus_space_write_4(sc->sc_iot, ioh, offset, regval);
		break;
	}

	dnprintf(30, "acpi_writepm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name, sc->sc_pmregs[reg].addr, offset, regval);
}

/* Map Power Management registers */
void
acpi_map_pmregs(struct acpi_softc *sc)
{
	bus_addr_t addr;
	bus_size_t size, access;
	const char *name;
	int reg;

	/* Registers don't exist on Hardware-reduced ACPI. */
	if (sc->sc_hw_reduced)
		return;

	for (reg = 0; reg < ACPIREG_MAXREG; reg++) {
		size = 0;
		access = 0;
		switch (reg) {
		case ACPIREG_SMICMD:
			name = "smi";
			size = access = 1;
			addr = sc->sc_fadt->smi_cmd;
			break;
		case ACPIREG_PM1A_STS:
		case ACPIREG_PM1A_EN:
			name = "pm1a_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1a_evt_blk;
			access = 2;
			if (reg == ACPIREG_PM1A_EN && addr) {
				addr += size;
				name = "pm1a_en";
			}
			break;
		case ACPIREG_PM1A_CNT:
			name = "pm1a_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1a_cnt_blk;
			access = 2;
			break;
		case ACPIREG_PM1B_STS:
		case ACPIREG_PM1B_EN:
			name = "pm1b_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1b_evt_blk;
			access = 2;
			if (reg == ACPIREG_PM1B_EN && addr) {
				addr += size;
				name = "pm1b_en";
			}
			break;
		case ACPIREG_PM1B_CNT:
			name = "pm1b_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1b_cnt_blk;
			access = 2;
			break;
		case ACPIREG_PM2_CNT:
			name = "pm2_cnt";
			size = sc->sc_fadt->pm2_cnt_len;
			addr = sc->sc_fadt->pm2_cnt_blk;
			access = size;
			break;
#if 0
		case ACPIREG_PM_TMR:
			/* Allocated in acpitimer */
			name = "pm_tmr";
			size = sc->sc_fadt->pm_tmr_len;
			addr = sc->sc_fadt->pm_tmr_blk;
			access = 4;
			break;
#endif
		case ACPIREG_GPE0_STS:
		case ACPIREG_GPE0_EN:
			name = "gpe0_sts";
			size = sc->sc_fadt->gpe0_blk_len >> 1;
			addr = sc->sc_fadt->gpe0_blk;
			access = 1;

			dnprintf(20, "gpe0 block len : %x\n",
			    sc->sc_fadt->gpe0_blk_len >> 1);
			dnprintf(20, "gpe0 block addr: %x\n",
			    sc->sc_fadt->gpe0_blk);
			if (reg == ACPIREG_GPE0_EN && addr) {
				addr += size;
				name = "gpe0_en";
			}
			break;
		case ACPIREG_GPE1_STS:
		case ACPIREG_GPE1_EN:
			name = "gpe1_sts";
			size = sc->sc_fadt->gpe1_blk_len >> 1;
			addr = sc->sc_fadt->gpe1_blk;
			access = 1;

			dnprintf(20, "gpe1 block len : %x\n",
			    sc->sc_fadt->gpe1_blk_len >> 1);
			dnprintf(20, "gpe1 block addr: %x\n",
			    sc->sc_fadt->gpe1_blk);
			if (reg == ACPIREG_GPE1_EN && addr) {
				addr += size;
				name = "gpe1_en";
			}
			break;
		}
		if (size && addr) {
			dnprintf(50, "mapping: %.4lx %.4lx %s\n",
			    addr, size, name);

			/* Size and address exist; map register space */
			bus_space_map(sc->sc_iot, addr, size, 0,
			    &sc->sc_pmregs[reg].ioh);

			sc->sc_pmregs[reg].name = name;
			sc->sc_pmregs[reg].size = size;
			sc->sc_pmregs[reg].addr = addr;
			sc->sc_pmregs[reg].access = min(access, 4);
		}
	}
}

void
acpi_unmap_pmregs(struct acpi_softc *sc)
{
	int reg;

	for (reg = 0; reg < ACPIREG_MAXREG; reg++) {
		if (sc->sc_pmregs[reg].size && sc->sc_pmregs[reg].addr)
			bus_space_unmap(sc->sc_iot, sc->sc_pmregs[reg].ioh,
			    sc->sc_pmregs[reg].size);
	}
}

int
acpi_enable(struct acpi_softc *sc)
{
	int idx;

	acpi_write_pmreg(sc, ACPIREG_SMICMD, 0, sc->sc_fadt->acpi_enable);
	idx = 0;
	do {
		if (idx++ > ACPIEN_RETRIES) {
			return ETIMEDOUT;
		}
	} while (!(acpi_read_pmreg(sc, ACPIREG_PM1_CNT, 0) & ACPI_PM1_SCI_EN));

	return 0;
}

/* ACPI Workqueue support */
SIMPLEQ_HEAD(,acpi_taskq) acpi_taskq =
    SIMPLEQ_HEAD_INITIALIZER(acpi_taskq);

void
acpi_addtask(struct acpi_softc *sc, void (*handler)(void *, int), 
    void *arg0, int arg1)
{
	struct acpi_taskq *wq;
	int s;

	wq = malloc(sizeof(*wq), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (wq == NULL)
		return;
	wq->handler = handler;
	wq->arg0 = arg0;
	wq->arg1 = arg1;
	
	s = spltty();
	SIMPLEQ_INSERT_TAIL(&acpi_taskq, wq, next);
	splx(s);
}

int
acpi_dotask(struct acpi_softc *sc)
{
	struct acpi_taskq *wq;
	int s;

	s = spltty();
	if (SIMPLEQ_EMPTY(&acpi_taskq)) {
		splx(s);

		/* we don't have anything to do */
		return (0);
	}
	wq = SIMPLEQ_FIRST(&acpi_taskq);
	SIMPLEQ_REMOVE_HEAD(&acpi_taskq, next);
	splx(s);

	wq->handler(wq->arg0, wq->arg1);

	free(wq, M_DEVBUF, sizeof(*wq));

	/* We did something */
	return (1);	
}

#ifndef SMALL_KERNEL

int
is_ata(struct aml_node *node)
{
	return (aml_searchname(node, "_GTM") != NULL ||
	    aml_searchname(node, "_GTF") != NULL ||
	    aml_searchname(node, "_STM") != NULL ||
	    aml_searchname(node, "_SDD") != NULL);
}

int
is_ejectable(struct aml_node *node)
{
	return (aml_searchname(node, "_EJ0") != NULL);
}

int
is_ejectable_bay(struct aml_node *node)
{
	return ((is_ata(node) || is_ata(node->parent)) && is_ejectable(node));
}

#if NWD > 0
int
acpiide_notify(struct aml_node *node, int ntype, void *arg)
{
	struct idechnl 		*ide = arg;
	struct acpi_softc 	*sc = ide->sc;
	struct pciide_softc 	*wsc;
	struct device 		*dev;
	int 			b,d,f;
	int64_t 		sta;

	if (aml_evalinteger(sc, node, "_STA", 0, NULL, &sta) != 0)
		return (0);

	dnprintf(10, "IDE notify! %s %d status:%llx\n", aml_nodename(node),
	    ntype, sta);

	/* Walk device list looking for IDE device match */
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (strcmp(dev->dv_cfdata->cf_driver->cd_name, "pciide"))
			continue;

		wsc = (struct pciide_softc *)dev;
		pci_decompose_tag(NULL, wsc->sc_tag, &b, &d, &f);
		if (b != ACPI_PCI_BUS(ide->addr) ||
		    d != ACPI_PCI_DEV(ide->addr) ||
		    f != ACPI_PCI_FN(ide->addr))
			continue;
		dnprintf(10, "Found pciide: %s %x.%x.%x channel:%llx\n",
		    dev->dv_xname, b,d,f, ide->chnl);

		if (sta == 0 && ide->sta)
			wdcdetach(
			    &wsc->pciide_channels[ide->chnl].wdc_channel, 0);
		else if (sta && !ide->sta)
			wdcattach(
			    &wsc->pciide_channels[ide->chnl].wdc_channel);
		ide->sta = sta;
	}
	return (0);
}

int
acpi_foundide(struct aml_node *node, void *arg)
{
	struct acpi_softc 	*sc = arg;
	struct aml_node 	*pp;
	struct idechnl 		*ide;
	union amlpci_t 		pi;
	int 			lvl;

	/* Check if this is an ejectable bay */
	if (!is_ejectable_bay(node))
		return (0);

	ide = malloc(sizeof(struct idechnl), M_DEVBUF, M_NOWAIT | M_ZERO);
	ide->sc = sc;

	/* GTM/GTF can be at 2/3 levels:  pciX.ideX.channelX[.driveX] */
	lvl = 0;
	for (pp=node->parent; pp; pp=pp->parent) {
		lvl++;
		if (aml_searchname(pp, "_HID"))
			break;
	}

	/* Get PCI address and channel */
	if (lvl == 3) {
		aml_evalinteger(sc, node->parent, "_ADR", 0, NULL,
		    &ide->chnl);
		aml_rdpciaddr(node->parent->parent, &pi);
		ide->addr = pi.addr;
	} else if (lvl == 4) {
		aml_evalinteger(sc, node->parent->parent, "_ADR", 0, NULL,
		    &ide->chnl);
		aml_rdpciaddr(node->parent->parent->parent, &pi);
		ide->addr = pi.addr;
	}
	dnprintf(10, "%s %llx channel:%llx\n",
	    aml_nodename(node), ide->addr, ide->chnl);

	aml_evalinteger(sc, node, "_STA", 0, NULL, &ide->sta);
	dnprintf(10, "Got Initial STA: %llx\n", ide->sta);

	aml_register_notify(node, "acpiide", acpiide_notify, ide, 0);
	return (0);
}
#endif /* NWD > 0 */

void
acpi_sleep_task(void *arg0, int sleepmode)
{
	struct acpi_softc *sc = arg0;
	struct acpi_ac *ac;
	struct acpi_bat *bat;
	struct acpi_sbs *sbs;

	/* System goes to sleep here.. */
	acpi_sleep_state(sc, sleepmode);

	/* AC and battery information needs refreshing */
	SLIST_FOREACH(ac, &sc->sc_ac, aac_link)
		aml_notify(ac->aac_softc->sc_devnode, 0x80);
	SLIST_FOREACH(bat, &sc->sc_bat, aba_link)
		aml_notify(bat->aba_softc->sc_devnode, 0x80);
	SLIST_FOREACH(sbs, &sc->sc_sbs, asbs_link)
		aml_notify(sbs->asbs_softc->sc_devnode, 0x80);
}

#endif /* SMALL_KERNEL */

void
acpi_reset(void)
{
	u_int32_t		 reset_as, reset_len;
	u_int32_t		 value;
	struct acpi_softc	*sc = acpi_softc;
	struct acpi_fadt	*fadt = sc->sc_fadt;

	if (acpi_enabled == 0)
		return;

	/*
	 * RESET_REG_SUP is not properly set in some implementations,
	 * but not testing against it breaks more machines than it fixes
	 */
	if (fadt->hdr_revision <= 1 ||
	    !(fadt->flags & FADT_RESET_REG_SUP) || fadt->reset_reg.address == 0)
		return;

	value = fadt->reset_value;

	reset_as = fadt->reset_reg.register_bit_width / 8;
	if (reset_as == 0)
		reset_as = 1;

	reset_len = fadt->reset_reg.access_size;
	if (reset_len == 0)
		reset_len = reset_as;

	acpi_gasio(sc, ACPI_IOWRITE,
	    fadt->reset_reg.address_space_id,
	    fadt->reset_reg.address, reset_as, reset_len, &value);

	delay(100000);
}

void
acpi_gpe_task(void *arg0, int gpe)
{
	struct acpi_softc *sc = acpi_softc;
	struct gpe_block *pgpe = &sc->gpe_table[gpe];

	dnprintf(10, "handle gpe: %x\n", gpe);
	if (pgpe->handler && pgpe->active) {
		pgpe->active = 0;
		pgpe->handler(sc, gpe, pgpe->arg);
	}
}

void
acpi_pbtn_task(void *arg0, int dummy)
{
	struct acpi_softc *sc = arg0;
	uint16_t en;
	int s;

	dnprintf(1,"power button pressed\n");

	/* Reset the latch and re-enable the GPE */
	s = spltty();
	en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	acpi_write_pmreg(sc, ACPIREG_PM1_EN,  0,
	    en | ACPI_PM1_PWRBTN_EN);
	splx(s);

	acpi_addtask(sc, acpi_powerdown_task, sc, 0);
}

void
acpi_sbtn_task(void *arg0, int dummy)
{
	struct acpi_softc *sc = arg0;
	uint16_t en;
	int s;

	dnprintf(1,"sleep button pressed\n");
	aml_notify_dev(ACPI_DEV_SBD, 0x80);

	/* Reset the latch and re-enable the GPE */
	s = spltty();
	en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	acpi_write_pmreg(sc, ACPIREG_PM1_EN,  0,
	    en | ACPI_PM1_SLPBTN_EN);
	splx(s);
}

void
acpi_powerdown_task(void *arg0, int dummy)
{
	extern int allowpowerdown;

	if (allowpowerdown == 1) {
		allowpowerdown = 0;
		prsignal(initprocess, SIGUSR2);
	}
}

int
acpi_interrupt(void *arg)
{
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	u_int32_t processed = 0, idx, jdx;
	u_int16_t sts, en;

	dnprintf(40, "ACPI Interrupt\n");
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		sts = acpi_read_pmreg(sc, ACPIREG_GPE_STS, idx>>3);
		en  = acpi_read_pmreg(sc, ACPIREG_GPE_EN,  idx>>3);
		if (en & sts) {
			dnprintf(10, "GPE block: %.2x %.2x %.2x\n", idx, sts,
			    en);
			/* Mask the GPE until it is serviced */
			acpi_write_pmreg(sc, ACPIREG_GPE_EN, idx>>3, en & ~sts);
			for (jdx = 0; jdx < 8; jdx++) {
				if (en & sts & (1L << jdx)) {
					/* Signal this GPE */
					sc->gpe_table[idx+jdx].active = 1;
					dnprintf(10, "queue gpe: %x\n", idx+jdx);
					acpi_addtask(sc, acpi_gpe_task, NULL, idx+jdx);

					/*
					 * Edge interrupts need their STS bits
					 * cleared now.  Level interrupts will
					 * have their STS bits cleared just
					 * before they are re-enabled.
					 */
					if (sc->gpe_table[idx+jdx].edge)
						acpi_write_pmreg(sc,
						    ACPIREG_GPE_STS, idx>>3,
						    1L << jdx);
					processed = 1;
				}
			}
		}
	}

	sts = acpi_read_pmreg(sc, ACPIREG_PM1_STS, 0);
	en  = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	if (sts & en) {
		dnprintf(10,"GEN interrupt: %.4x\n", sts & en);
		sts &= en;
		if (sts & ACPI_PM1_PWRBTN_STS) {
			/* Mask and acknowledge */
			en &= ~ACPI_PM1_PWRBTN_EN;
			acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);
			acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0,
			    ACPI_PM1_PWRBTN_STS);
			sts &= ~ACPI_PM1_PWRBTN_STS;

			acpi_addtask(sc, acpi_pbtn_task, sc, 0);
		}
		if (sts & ACPI_PM1_SLPBTN_STS) {
			/* Mask and acknowledge */
			en &= ~ACPI_PM1_SLPBTN_EN;
			acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);
			acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0,
			    ACPI_PM1_SLPBTN_STS);
			sts &= ~ACPI_PM1_SLPBTN_STS;

			acpi_addtask(sc, acpi_sbtn_task, sc, 0);
		}
		if (sts) {
			printf("%s: PM1 stuck (en 0x%x st 0x%x), clearing\n",
			    sc->sc_dev.dv_xname, en, sts);
			acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en & ~sts);
			acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, sts);
		}
		processed = 1;
	}

	if (processed) {
		acpi_wakeup(sc);
	}

	return (processed);
}

int
acpi_add_device(struct aml_node *node, void *arg)
{
	static int nacpicpus = 0;
	struct device *self = arg;
	struct acpi_softc *sc = arg;
	struct acpi_attach_args aaa;
	struct aml_value res;
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	int proc_id = -1;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_node = node;
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	if (node == NULL || node->value == NULL)
		return 0;

	switch (node->value->type) {
	case AML_OBJTYPE_PROCESSOR:
		if (nacpicpus >= ncpus)
			return 0;
		if (aml_evalnode(sc, aaa.aaa_node, 0, NULL, &res) == 0) {
			if (res.type == AML_OBJTYPE_PROCESSOR)
				proc_id = res.v_processor.proc_id;
			aml_freevalue(&res);
		}
		CPU_INFO_FOREACH(cii, ci) {
			if (ci->ci_acpi_proc_id == proc_id)
				break;
		}
		if (ci == NULL)
			return 0;
		nacpicpus++;

		aaa.aaa_name = "acpicpu";
		break;
	case AML_OBJTYPE_THERMZONE:
		aaa.aaa_name = "acpitz";
		break;
	case AML_OBJTYPE_POWERRSRC:
		aaa.aaa_name = "acpipwrres";
		break;
	default:
		return 0;
	}
	config_found(self, &aaa, acpi_print);
	return 0;
}

void
acpi_enable_onegpe(struct acpi_softc *sc, int gpe)
{
	uint8_t mask, en;

	/* Read enabled register */
	mask = (1L << (gpe & 7));
	en = acpi_read_pmreg(sc, ACPIREG_GPE_EN, gpe>>3);
	dnprintf(50, "enabling GPE %.2x (current: %sabled) %.2x\n",
	    gpe, (en & mask) ? "en" : "dis", en);
	acpi_write_pmreg(sc, ACPIREG_GPE_EN, gpe>>3, en | mask);
}

/* Clear all GPEs */
void
acpi_disable_allgpes(struct acpi_softc *sc)
{
	int idx;

	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		acpi_write_pmreg(sc, ACPIREG_GPE_EN, idx >> 3, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE_STS, idx >> 3, -1);
	}
}

/* Enable runtime GPEs */
void
acpi_enable_rungpes(struct acpi_softc *sc)
{
	int idx;

	for (idx = 0; idx < sc->sc_lastgpe; idx++)
		if (sc->gpe_table[idx].handler)
			acpi_enable_onegpe(sc, idx);
}

/* Enable wakeup GPEs */
void
acpi_enable_wakegpes(struct acpi_softc *sc, int state)
{
	struct acpi_wakeq *wentry;

	SIMPLEQ_FOREACH(wentry, &sc->sc_wakedevs, q_next) {
		dnprintf(10, "%.4s(S%d) gpe %.2x\n", wentry->q_node->name,
		    wentry->q_state,
		    wentry->q_gpe);
		if (state <= wentry->q_state)
			acpi_enable_onegpe(sc, wentry->q_gpe);
	}
}

int
acpi_set_gpehandler(struct acpi_softc *sc, int gpe, int (*handler)
    (struct acpi_softc *, int, void *), void *arg, int edge)
{
	struct gpe_block *ptbl;

	ptbl = acpi_find_gpe(sc, gpe);
	if (ptbl == NULL || handler == NULL)
		return -EINVAL;
	if (ptbl->handler != NULL) {
		dnprintf(10, "error: GPE %.2x already enabled\n", gpe);
		return -EBUSY;
	}
	dnprintf(50, "Adding GPE handler %.2x (%s)\n", gpe, edge ? "edge" : "level");
	ptbl->handler = handler;
	ptbl->arg = arg;
	ptbl->edge = edge;

	return (0);
}

int
acpi_gpe(struct acpi_softc *sc, int gpe, void *arg)
{
	struct aml_node *node = arg;
	uint8_t mask, en;

	dnprintf(10, "handling GPE %.2x\n", gpe);
	aml_evalnode(sc, node, 0, NULL, NULL);

	mask = (1L << (gpe & 7));
	if (!sc->gpe_table[gpe].edge)
		acpi_write_pmreg(sc, ACPIREG_GPE_STS, gpe>>3, mask);
	en = acpi_read_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3);
	acpi_write_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3, en | mask);
	return (0);
}

/* Discover Devices that can wakeup the system
 * _PRW returns a package
 *  pkg[0] = integer (FADT gpe bit) or package (gpe block,gpe bit)
 *  pkg[1] = lowest sleep state
 *  pkg[2+] = power resource devices (optional)
 *
 * To enable wakeup devices:
 *    Evaluate _ON method in each power resource device
 *    Evaluate _PSW method
 */
int
acpi_foundprw(struct aml_node *node, void *arg)
{
	struct acpi_softc *sc = arg;
	struct acpi_wakeq *wq;
	int64_t sta;

	if (aml_evalinteger(sc, node->parent, "_STA", 0, NULL, &sta))
		sta = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	if ((sta & STA_PRESENT) == 0)
		return 0;

	wq = malloc(sizeof(struct acpi_wakeq), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (wq == NULL)
		return 0;

	wq->q_wakepkg = malloc(sizeof(struct aml_value), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (wq->q_wakepkg == NULL) {
		free(wq, M_DEVBUF, sizeof(*wq));
		return 0;
	}
	dnprintf(10, "Found _PRW (%s)\n", node->parent->name);
	aml_evalnode(sc, node, 0, NULL, wq->q_wakepkg);
	wq->q_node = node->parent;
	wq->q_gpe = -1;

	/* Get GPE of wakeup device, and lowest sleep level */
	if (wq->q_wakepkg->type == AML_OBJTYPE_PACKAGE &&
	    wq->q_wakepkg->length >= 2) {
		if (wq->q_wakepkg->v_package[0]->type == AML_OBJTYPE_INTEGER)
			wq->q_gpe = wq->q_wakepkg->v_package[0]->v_integer;
		if (wq->q_wakepkg->v_package[1]->type == AML_OBJTYPE_INTEGER)
			wq->q_state = wq->q_wakepkg->v_package[1]->v_integer;
	}
	SIMPLEQ_INSERT_TAIL(&sc->sc_wakedevs, wq, q_next);
	return 0;
}

struct gpe_block *
acpi_find_gpe(struct acpi_softc *sc, int gpe)
{
	if (gpe >= sc->sc_lastgpe)
		return NULL;
	return &sc->gpe_table[gpe];
}

void
acpi_init_gpes(struct acpi_softc *sc)
{
	struct aml_node *gpe;
	char name[12];
	int  idx, ngpe;

	sc->sc_lastgpe = sc->sc_fadt->gpe0_blk_len << 2;
	if (sc->sc_fadt->gpe1_blk_len) {
	}
	dnprintf(50, "Last GPE: %.2x\n", sc->sc_lastgpe);

	/* Allocate GPE table */
	sc->gpe_table = mallocarray(sc->sc_lastgpe, sizeof(struct gpe_block),
	    M_DEVBUF, M_WAITOK | M_ZERO);

	ngpe = 0;

	/* Clear GPE status */
	acpi_disable_allgpes(sc);
	for (idx = 0; idx < sc->sc_lastgpe; idx++) {
		/* Search Level-sensitive GPES */
		snprintf(name, sizeof(name), "\\_GPE._L%.2X", idx);
		gpe = aml_searchname(&aml_root, name);
		if (gpe != NULL)
			acpi_set_gpehandler(sc, idx, acpi_gpe, gpe, 0);
		if (gpe == NULL) {
			/* Search Edge-sensitive GPES */
			snprintf(name, sizeof(name), "\\_GPE._E%.2X", idx);
			gpe = aml_searchname(&aml_root, name);
			if (gpe != NULL)
				acpi_set_gpehandler(sc, idx, acpi_gpe, gpe, 1);
		}
	}
	aml_find_node(&aml_root, "_PRW", acpi_foundprw, sc);
	sc->sc_maxgpe = ngpe;
}

void
acpi_init_pm(struct acpi_softc *sc)
{
	sc->sc_tts = aml_searchname(&aml_root, "_TTS");
	sc->sc_pts = aml_searchname(&aml_root, "_PTS");
	sc->sc_wak = aml_searchname(&aml_root, "_WAK");
	sc->sc_bfs = aml_searchname(&aml_root, "_BFS");
	sc->sc_gts = aml_searchname(&aml_root, "_GTS");
	sc->sc_sst = aml_searchname(&aml_root, "_SI_._SST");
}

#ifndef SMALL_KERNEL

void
acpi_init_states(struct acpi_softc *sc)
{
	struct aml_value res;
	char name[8];
	int i;

	printf("\n%s: sleep states", DEVNAME(sc));
	for (i = ACPI_STATE_S0; i <= ACPI_STATE_S5; i++) {
		snprintf(name, sizeof(name), "_S%d_", i);
		sc->sc_sleeptype[i].slp_typa = -1;
		sc->sc_sleeptype[i].slp_typb = -1;
		if (aml_evalname(sc, &aml_root, name, 0, NULL, &res) == 0) {
			if (res.type == AML_OBJTYPE_PACKAGE) {
				sc->sc_sleeptype[i].slp_typa = aml_val2int(res.v_package[0]);
				sc->sc_sleeptype[i].slp_typb = aml_val2int(res.v_package[1]);
				printf(" S%d", i);
			}
			aml_freevalue(&res);
		}
	}
}

void
acpi_sleep_pm(struct acpi_softc *sc, int state)
{
	uint16_t rega, regb, regra, regrb;
	int retry = 0;

	disable_intr();

	/* Clear WAK_STS bit */
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, ACPI_PM1_WAK_STS);

	/* Disable BM arbitration at deep sleep and beyond */
	if (state >= ACPI_STATE_S3 &&
	    sc->sc_fadt->pm2_cnt_blk && sc->sc_fadt->pm2_cnt_len)
		acpi_write_pmreg(sc, ACPIREG_PM2_CNT, 0, ACPI_PM2_ARB_DIS);

	/* Write SLP_TYPx values */
	rega = acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, 0);
	regb = acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, 0);
	rega &= ~(ACPI_PM1_SLP_TYPX_MASK | ACPI_PM1_SLP_EN);
	regb &= ~(ACPI_PM1_SLP_TYPX_MASK | ACPI_PM1_SLP_EN);
	rega |= ACPI_PM1_SLP_TYPX(sc->sc_sleeptype[state].slp_typa);
	regb |= ACPI_PM1_SLP_TYPX(sc->sc_sleeptype[state].slp_typb);
	acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, 0, rega);
	acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, 0, regb);

	/* Loop on WAK_STS, setting the SLP_EN bits once in a while */
	rega |= ACPI_PM1_SLP_EN;
	regb |= ACPI_PM1_SLP_EN;
	while (1) {
		if (retry == 0) {
			acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, 0, rega);
			acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, 0, regb);
		}
		retry = (retry + 1) % 100000;

		regra = acpi_read_pmreg(sc, ACPIREG_PM1A_STS, 0);
		regrb = acpi_read_pmreg(sc, ACPIREG_PM1B_STS, 0);
		if ((regra & ACPI_PM1_WAK_STS) ||
		    (regrb & ACPI_PM1_WAK_STS))
			break;
	}
}

u_int32_t acpi_force_bm;

void
acpi_resume_pm(struct acpi_softc *sc, int fromstate)
{
	uint16_t rega, regb, en;

	/* Write SLP_TYPx values */
	rega = acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, 0);
	regb = acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, 0);
	rega &= ~(ACPI_PM1_SLP_TYPX_MASK | ACPI_PM1_SLP_EN);
	regb &= ~(ACPI_PM1_SLP_TYPX_MASK | ACPI_PM1_SLP_EN);
	rega |= ACPI_PM1_SLP_TYPX(sc->sc_sleeptype[ACPI_STATE_S0].slp_typa);
	regb |= ACPI_PM1_SLP_TYPX(sc->sc_sleeptype[ACPI_STATE_S0].slp_typb);
	acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, 0, rega);
	acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, 0, regb);

	/* Force SCI_EN on resume to fix horribly broken machines */
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT, 0,
	    ACPI_PM1_SCI_EN | acpi_force_bm);

	/* Clear fixed event status */
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, ACPI_PM1_ALL_STS);

	/* acpica-reference.pdf page 148 says do not call _BFS */
	/* 1st resume AML step: _BFS(fromstate) */
	aml_node_setval(sc, sc->sc_bfs, fromstate);

	/* Enable runtime GPEs */
	acpi_disable_allgpes(sc);
	acpi_enable_rungpes(sc);

	acpi_indicator(sc, ACPI_SST_WAKING);

	/* 2nd resume AML step: _WAK(fromstate) */
	aml_node_setval(sc, sc->sc_wak, fromstate);

	/* Clear WAK_STS bit */
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, ACPI_PM1_WAK_STS);

	en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	if (!(sc->sc_fadt->flags & FADT_PWR_BUTTON))
		en |= ACPI_PM1_PWRBTN_EN;
	if (!(sc->sc_fadt->flags & FADT_SLP_BUTTON))
		en |= ACPI_PM1_SLPBTN_EN;
	acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);

	/*
	 * If PM2 exists, re-enable BM arbitration (reportedly some
	 * BIOS forget to)
	 */
	if (sc->sc_fadt->pm2_cnt_blk && sc->sc_fadt->pm2_cnt_len) {
		rega = acpi_read_pmreg(sc, ACPIREG_PM2_CNT, 0);
		rega &= ~ACPI_PM2_ARB_DIS;
		acpi_write_pmreg(sc, ACPIREG_PM2_CNT, 0, rega);
	}
}

/* Set the indicator light to some state */
void
acpi_indicator(struct acpi_softc *sc, int led_state)
{
	static int save_led_state = -1;

	if (save_led_state != led_state) {
		aml_node_setval(sc, sc->sc_sst, led_state);
		save_led_state = led_state;
	}
}


int
acpi_sleep_state(struct acpi_softc *sc, int sleepmode)
{
	extern int perflevel;
	extern int lid_action;
	int error = ENXIO;
	size_t rndbuflen = 0;
	char *rndbuf = NULL;
	int state, s;

	switch (sleepmode) {
	case ACPI_SLEEP_SUSPEND:
		state = ACPI_STATE_S3;
		break;
	case ACPI_SLEEP_HIBERNATE:
		state = ACPI_STATE_S4;
		break;
	default:
		return (EOPNOTSUPP);
	}

	if (sc->sc_sleeptype[state].slp_typa == -1 ||
	    sc->sc_sleeptype[state].slp_typb == -1) {
		printf("%s: state S%d unavailable\n",
		    sc->sc_dev.dv_xname, state);
		return (EOPNOTSUPP);
	}

	/* 1st suspend AML step: _TTS(tostate) */
	if (aml_node_setval(sc, sc->sc_tts, state) != 0)
		goto fail_tts;
	acpi_indicator(sc, ACPI_SST_WAKING);	/* blink */

#if NWSDISPLAY > 0
	/*
	 * Temporarily release the lock to prevent the X server from
	 * blocking on setting the display brightness.
	 */
	rw_exit_write(&sc->sc_lck);
	wsdisplay_suspend();
	rw_enter_write(&sc->sc_lck);
#endif /* NWSDISPLAY > 0 */

	stop_periodic_resettodr();

#ifdef HIBERNATE
	if (sleepmode == ACPI_SLEEP_HIBERNATE) {
		uvmpd_hibernate();
		hibernate_suspend_bufcache();
		if (hibernate_alloc()) {
			printf("%s: failed to allocate hibernate memory\n",
			    sc->sc_dev.dv_xname);
			goto fail_alloc;
		}
	}
#endif /* HIBERNATE */

	sensor_quiesce();
	if (config_suspend_all(DVACT_QUIESCE))
		goto fail_quiesce;

	bufq_quiesce();

#ifdef MULTIPROCESSOR
	acpi_sleep_mp();
#endif

	resettodr();

	s = splhigh();
	disable_intr();	/* PSL_I for resume; PIC/APIC broken until repair */
	cold = 2;	/* Force other code to delay() instead of tsleep() */

	if (config_suspend_all(DVACT_SUSPEND) != 0)
		goto fail_suspend;
	acpi_sleep_clocks(sc, state);

	suspend_randomness();

	/* 2nd suspend AML step: _PTS(tostate) */
	if (aml_node_setval(sc, sc->sc_pts, state) != 0)
		goto fail_pts;

	acpibtn_enable_psw();	/* enable _LID for wakeup */
	acpi_indicator(sc, ACPI_SST_SLEEPING);

	/* 3rd suspend AML step: _GTS(tostate) */
	aml_node_setval(sc, sc->sc_gts, state);

	/* Clear fixed event status */
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, ACPI_PM1_ALL_STS);

	/* Enable wake GPEs */
	acpi_disable_allgpes(sc);
	acpi_enable_wakegpes(sc, state);

	/* Sleep */
	sc->sc_state = state;
	error = acpi_sleep_cpu(sc, state);
	sc->sc_state = ACPI_STATE_S0;
	/* Resume */

#ifdef HIBERNATE
	if (sleepmode == ACPI_SLEEP_HIBERNATE) {
		uvm_pmr_dirty_everything();
		hib_getentropy(&rndbuf, &rndbuflen);
	}
#endif /* HIBERNATE */

	acpi_resume_clocks(sc);		/* AML may need clocks */
	acpi_resume_pm(sc, state);
	acpi_resume_cpu(sc);

fail_pts:
	config_suspend_all(DVACT_RESUME);

fail_suspend:
	cold = 0;
	enable_intr();
	splx(s);

	acpibtn_disable_psw();		/* disable _LID for wakeup */
	inittodr(time_second);

	/* 3rd resume AML step: _TTS(runstate) */
	aml_node_setval(sc, sc->sc_tts, sc->sc_state);

	resume_randomness(rndbuf, rndbuflen);	/* force RNG upper level reseed */

#ifdef MULTIPROCESSOR
	acpi_resume_mp();
#endif

	bufq_restart();

fail_quiesce:
	config_suspend_all(DVACT_WAKEUP);
	sensor_restart();

#ifdef HIBERNATE
	if (sleepmode == ACPI_SLEEP_HIBERNATE) {
		hibernate_free();
fail_alloc:
		hibernate_resume_bufcache();
	}
#endif /* HIBERNATE */

	start_periodic_resettodr();

#if NWSDISPLAY > 0
	rw_exit_write(&sc->sc_lck);
	wsdisplay_resume();
	rw_enter_write(&sc->sc_lck);
#endif /* NWSDISPLAY > 0 */

	/* Restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);

	acpi_record_event(sc, APM_NORMAL_RESUME);
	acpi_indicator(sc, ACPI_SST_WORKING);

	/* If we woke up but all the lids are closed, go back to sleep */
	if (acpibtn_numopenlids() == 0 && lid_action != 0)
		acpi_addtask(sc, acpi_sleep_task, sc, sleepmode);

fail_tts:
	return (error);
}

/* XXX
 * We are going to do AML execution but are not in the acpi thread.
 * We do not know if the acpi thread is sleeping on acpiec in some
 * intermediate context.  Wish us luck.
 */
void
acpi_powerdown(void)
{
	int state = ACPI_STATE_S5, s;
	struct acpi_softc *sc = acpi_softc;

	if (acpi_enabled == 0)
		return;

	s = splhigh();
	disable_intr();
	cold = 1;

	/* 1st powerdown AML step: _PTS(tostate) */
	aml_node_setval(sc, sc->sc_pts, state);
	
	acpi_disable_allgpes(sc);
	acpi_enable_wakegpes(sc, state);

	/* 2nd powerdown AML step: _GTS(tostate) */
	aml_node_setval(sc, sc->sc_gts, state);

	acpi_sleep_pm(sc, state);
	panic("acpi S5 transition did not happen");
	while (1)
		;
}

int
acpi_map_address(struct acpi_softc *sc, struct acpi_gas *gas, bus_addr_t base,
    bus_size_t size, bus_space_handle_t *pioh, bus_space_tag_t *piot)
{
	int iospace = GAS_SYSTEM_IOSPACE;

	/* No GAS structure, default to I/O space */
	if (gas != NULL) {
		base += gas->address;
		iospace = gas->address_space_id;
	}
	switch (iospace) {
	case GAS_SYSTEM_MEMORY:
		*piot = sc->sc_memt;
		break;
	case GAS_SYSTEM_IOSPACE:
		*piot = sc->sc_iot;
		break;
	default:
		return -1;
	}
	if (bus_space_map(*piot, base, size, 0, pioh))
		return -1;

	return 0;
}

#endif /* SMALL_KERNEL */

void
acpi_wakeup(void *arg)
{
	struct acpi_softc  *sc = (struct acpi_softc *)arg;

	sc->sc_threadwaiting = 0;
	wakeup(sc);
}


void
acpi_thread(void *arg)
{
	struct acpi_thread *thread = arg;
	struct acpi_softc  *sc = thread->sc;
	extern int aml_busy;
	int s;

	/* AML/SMI cannot be trusted -- only run on the BSP */
	sched_peg_curproc(&cpu_info_primary);

	rw_enter_write(&sc->sc_lck);

	/*
	 * If we have an interrupt handler, we can get notification
	 * when certain status bits changes in the ACPI registers,
	 * so let us enable some events we can forward to userland
	 */
	if (sc->sc_interrupt) {
		int16_t en;

		dnprintf(1,"slpbtn:%c  pwrbtn:%c\n",
		    sc->sc_fadt->flags & FADT_SLP_BUTTON ? 'n' : 'y',
		    sc->sc_fadt->flags & FADT_PWR_BUTTON ? 'n' : 'y');
		dnprintf(10, "Enabling acpi interrupts...\n");
		sc->sc_threadwaiting = 1;

		/* Enable Sleep/Power buttons if they exist */
		s = spltty();
		en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
		if (!(sc->sc_fadt->flags & FADT_PWR_BUTTON))
			en |= ACPI_PM1_PWRBTN_EN;
		if (!(sc->sc_fadt->flags & FADT_SLP_BUTTON))
			en |= ACPI_PM1_SLPBTN_EN;
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);

		/* Enable handled GPEs here */
		acpi_enable_rungpes(sc);
		splx(s);
	}

	while (thread->running) {
		s = spltty();
		while (sc->sc_threadwaiting) {
			dnprintf(10, "acpi thread going to sleep...\n");
			rw_exit_write(&sc->sc_lck);
			tsleep(sc, PWAIT, "acpi0", 0);
			rw_enter_write(&sc->sc_lck);
		}
		sc->sc_threadwaiting = 1;
		splx(s);
		if (aml_busy) {
			panic("thread woke up to find aml was busy");
			continue;
		}

		/* Run ACPI taskqueue */
		while(acpi_dotask(acpi_softc))
			;
	}
	free(thread, M_DEVBUF, sizeof(*thread));

	kthread_exit(0);
}

void
acpi_create_thread(void *arg)
{
	struct acpi_softc *sc = arg;

	if (kthread_create(acpi_thread, sc->sc_thread, NULL, DEVNAME(sc))
	    != 0)
		printf("%s: unable to create isr thread, GPEs disabled\n",
		    DEVNAME(sc));
}

int
acpi_foundec(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct aml_value	 res;
	struct acpi_attach_args	aaa;

	if (aml_evalnode(sc, node, 0, NULL, &res) != 0)
		return 0;

	switch (res.type) {
	case AML_OBJTYPE_STRING:
		dev = res.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(aml_val2int(&res));
		break;
	default:
		dev = "unknown";
		break;
	}

	if (strcmp(dev, ACPI_DEV_ECD))
		return 0;

	/* Check if we're already attached */
	if (sc->sc_ec && sc->sc_ec->sc_devnode == node->parent)
		return 0;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpiec";
	config_found(self, &aaa, acpi_print);
	aml_freevalue(&res);

	return 0;
}

int
acpi_foundsony(struct aml_node *node, void *arg)
{
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	struct device *self = (struct device *)arg;
	struct acpi_attach_args aaa;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_name = "acpisony";

	config_found(self, &aaa, acpi_print);

	return 0;
}

int
acpi_parsehid(struct aml_node *node, void *arg, char *outcdev, char *outdev,
    size_t devlen)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct aml_value	 res;
	const char		*dev;

	/* NB aml_eisaid returns a static buffer, this must come first */
	if (aml_evalname(acpi_softc, node->parent, "_CID", 0, NULL, &res) == 0) {
		switch (res.type) {
		case AML_OBJTYPE_STRING:
			dev = res.v_string;
			break;
		case AML_OBJTYPE_INTEGER:
			dev = aml_eisaid(aml_val2int(&res));
			break;
		default:
			dev = "unknown";
			break;
		}
		strlcpy(outcdev, dev, devlen);
		aml_freevalue(&res);

		dnprintf(10, "compatible with device: %s\n", outcdev);
	} else {
		outcdev[0] = '\0';
	}

	dnprintf(10, "found hid device: %s ", node->parent->name);
	if (aml_evalnode(sc, node, 0, NULL, &res) != 0)
		return (1);

	switch (res.type) {
	case AML_OBJTYPE_STRING:
		dev = res.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(aml_val2int(&res));
		break;
	default:
		dev = "unknown";
		break;
	}
	dnprintf(10, "	device: %s\n", dev);

	strlcpy(outdev, dev, devlen);

	aml_freevalue(&res);

	return (0);
}

/* Devices for which we don't want to attach a driver */
const char *acpi_skip_hids[] = {
	"INT0800",	/* Intel 82802Firmware Hub Device */
	"PNP0000",	/* 8259-compatible Programmable Interrupt Controller */
	"PNP0100",	/* PC-class System Timer */
	"PNP0103",	/* HPET System Timer */
	"PNP0200",	/* PC-class DMA Controller */
	"PNP0800",	/* Microsoft Sound System Compatible Device */
	"PNP0A03",	/* PCI Bus */
	"PNP0A08",	/* PCI Express Bus */
	"PNP0B00",	/* AT Real-Time Clock */
	"PNP0C01",	/* System Board */
	"PNP0C02",	/* PNP Motherboard Resources */
	"PNP0C04",	/* x87-compatible Floating Point Processing Unit */
	"PNP0C09",	/* Embedded Controller Device */
	"PNP0C0F",	/* PCI Interrupt Link Device */
	NULL
};

/* ISA devices for which we attach a driver later */
const char *acpi_isa_hids[] = {
	"PNP0303",	/* 8042 PS/2 Controller */
	"PNP0501",	/* 16550A-compatible COM Serial Port */
	NULL
};

void
acpi_attach_deps(struct acpi_softc *sc, struct aml_node *node)
{
	struct aml_value res;
	struct aml_node *dep;
	int i;

	if (aml_evalname(sc, node, "_DEP", 0, NULL, &res))
		return;

	if (res.type != AML_OBJTYPE_PACKAGE)
		return;

	for (i = 0; i < res.length; i++) {
		if (res.v_package[i]->type != AML_OBJTYPE_STRING)
			continue;
		dep = aml_searchrel(node, res.v_package[i]->v_string);
		if (dep == NULL || dep->attached)
			continue;
		dep = aml_searchname(dep, "_HID");
		if (dep)
			acpi_foundhid(dep, sc);
	}

	aml_freevalue(&res);
}

int
acpi_foundhid(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	char		 	 cdev[32];
	char		 	 dev[32];
	struct acpi_attach_args	 aaa;
	int64_t			 sta;
#ifndef SMALL_KERNEL
	int			 i;
#endif

	if (acpi_parsehid(node, arg, cdev, dev, sizeof(dev)) != 0)
		return (0);

	if (aml_evalinteger(sc, node->parent, "_STA", 0, NULL, &sta))
		sta = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	if ((sta & STA_PRESENT) == 0)
		return (0);

	acpi_attach_deps(sc, node->parent);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;

	if (acpi_matchhids(&aaa, acpi_skip_hids, "none") ||
	    acpi_matchhids(&aaa, acpi_isa_hids, "none"))
		return (0);

#ifndef SMALL_KERNEL
	if (!strcmp(cdev, ACPI_DEV_MOUSE)) {
		for (i = 0; i < nitems(sbtn_pnp); i++) {
			if (!strcmp(dev, sbtn_pnp[i])) {
				mouse_has_softbtn = 1;
				break;
			}
		}
	}
#endif

	if (!node->parent->attached) {
		node->parent->attached = 1;
		config_found(self, &aaa, acpi_print);
	}

	return (0);
}

#ifndef SMALL_KERNEL
int
acpi_founddock(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found dock entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_name = "acpidock";

	config_found(self, &aaa, acpi_print);

	return 0;
}

int
acpi_foundvideo(struct aml_node *node, void *arg)
{
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	struct device *self = (struct device *)arg;
	struct acpi_attach_args	aaa;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_name = "acpivideo";

	config_found(self, &aaa, acpi_print);

	return (0);
}

int
acpi_foundsbs(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	char		 	 cdev[32], dev[32];
	struct acpi_attach_args	 aaa;
	int64_t			 sta;

	if (acpi_parsehid(node, arg, cdev, dev, sizeof(dev)) != 0)
		return (0);

	if (aml_evalinteger(sc, node->parent, "_STA", 0, NULL, &sta))
		sta = STA_PRESENT | STA_ENABLED | STA_DEV_OK | 0x1000;

	if ((sta & STA_PRESENT) == 0)
		return (0);

	acpi_attach_deps(sc, node->parent);

	if (strcmp(dev, ACPI_DEV_SBS) != 0)
		return (0);

	if (node->parent->attached)
		return (0);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;

	config_found(self, &aaa, acpi_print);
	node->parent->attached = 1;

	return (0);
}

int
acpiopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int error = 0;
	struct acpi_softc *sc;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
		}
		sc->sc_flags |= SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	splx(s);
	return (error);
}

int
acpiclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int error = 0;
	struct acpi_softc *sc;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	splx(s);
	return (error);
}

int
acpiioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error = 0;
	struct acpi_softc *sc;
	struct acpi_ac *ac;
	struct acpi_bat *bat;
	struct acpi_sbs *sbs;
	struct apm_power_info *pi = (struct apm_power_info *)data;
	int bats;
	unsigned int remaining, rem, minutes, rate;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	/* fake APM */
	switch (cmd) {
	case APM_IOC_SUSPEND:
	case APM_IOC_STANDBY:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			break;
		}
		acpi_addtask(sc, acpi_sleep_task, sc, ACPI_SLEEP_SUSPEND);
		acpi_wakeup(sc);
		break;
#ifdef HIBERNATE
	case APM_IOC_HIBERNATE:
		if ((error = suser(p, 0)) != 0)
			break;
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			break;
		}
		if (get_hibernate_io_function(swdevt[0].sw_dev) == NULL) {
			error = EOPNOTSUPP;
			break;
		}
		acpi_addtask(sc, acpi_sleep_task, sc, ACPI_SLEEP_HIBERNATE);
		acpi_wakeup(sc);
		break;
#endif
	case APM_IOC_GETPOWER:
		/* A/C */
		pi->ac_state = APM_AC_UNKNOWN;
		SLIST_FOREACH(ac, &sc->sc_ac, aac_link) {
			if (ac->aac_softc->sc_ac_stat == PSR_ONLINE)
				pi->ac_state = APM_AC_ON;
			else if (ac->aac_softc->sc_ac_stat == PSR_OFFLINE)
				if (pi->ac_state == APM_AC_UNKNOWN)
					pi->ac_state = APM_AC_OFF;
		}

		/* battery */
		pi->battery_state = APM_BATT_UNKNOWN;
		pi->battery_life = 0;
		pi->minutes_left = 0;
		bats = 0;
		remaining = rem = 0;
		minutes = 0;
		rate = 0;
		SLIST_FOREACH(bat, &sc->sc_bat, aba_link) {
			if (bat->aba_softc->sc_bat_present == 0)
				continue;

			if (bat->aba_softc->sc_bix.bix_last_capacity == 0)
				continue;

			bats++;
			rem = (bat->aba_softc->sc_bst.bst_capacity * 100) /
			    bat->aba_softc->sc_bix.bix_last_capacity;
			if (rem > 100)
				rem = 100;
			remaining += rem;

			if (bat->aba_softc->sc_bst.bst_rate == BST_UNKNOWN)
				continue;
			else if (bat->aba_softc->sc_bst.bst_rate > 1)
				rate = bat->aba_softc->sc_bst.bst_rate;

			minutes += bat->aba_softc->sc_bst.bst_capacity;
		}

		SLIST_FOREACH(sbs, &sc->sc_sbs, asbs_link) {
			if (sbs->asbs_softc->sc_batteries_present == 0)
				continue;

			if (sbs->asbs_softc->sc_battery.rel_charge == 0)
				continue;

			bats++;
			rem = sbs->asbs_softc->sc_battery.rel_charge;
			if (rem > 100)
				rem = 100;
			remaining += rem;

			if (sbs->asbs_softc->sc_battery.run_time ==
			    ACPISBS_VALUE_UNKNOWN)
				continue;

			rate = 60; /* XXX */
			minutes += sbs->asbs_softc->sc_battery.run_time;
		}

		if (bats == 0) {
			pi->battery_state = APM_BATTERY_ABSENT;
			pi->battery_life = 0;
			pi->minutes_left = (unsigned int)-1;
			break;
		}

		if (pi->ac_state == APM_AC_ON || rate == 0)
			pi->minutes_left = (unsigned int)-1;
		else
			pi->minutes_left = 60 * minutes / rate;

		/* running on battery */
		pi->battery_life = remaining / bats;
		if (pi->battery_life > 50)
			pi->battery_state = APM_BATT_HIGH;
		else if (pi->battery_life > 25)
			pi->battery_state = APM_BATT_LOW;
		else
			pi->battery_state = APM_BATT_CRITICAL;

		break;

	default:
		error = ENOTTY;
	}

	splx(s);
	return (error);
}

void	acpi_filtdetach(struct knote *);
int	acpi_filtread(struct knote *, long);

struct filterops acpiread_filtops = {
	1, NULL, acpi_filtdetach, acpi_filtread
};

int acpi_evindex;

int
acpi_record_event(struct acpi_softc *sc, u_int type)
{
	if ((sc->sc_flags & SCFLAG_OPEN) == 0)
		return (1);

	acpi_evindex++;
	KNOTE(sc->sc_note, APM_EVENT_COMPOSE(type, acpi_evindex));
	return (0);
}

void
acpi_filtdetach(struct knote *kn)
{
	struct acpi_softc *sc = kn->kn_hook;
	int s;

	s = spltty();
	SLIST_REMOVE(sc->sc_note, kn, knote, kn_selnext);
	splx(s);
}

int
acpi_filtread(struct knote *kn, long hint)
{
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = hint;
	return (1);
}

int
acpikqfilter(dev_t dev, struct knote *kn)
{
	struct acpi_softc *sc;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &acpiread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = sc;

	s = spltty();
	SLIST_INSERT_HEAD(sc->sc_note, kn, kn_selnext);
	splx(s);

	return (0);
}

#else /* SMALL_KERNEL */

int
acpiopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return (ENXIO);
}

int
acpiclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (ENXIO);
}

int
acpiioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	return (ENXIO);
}

int
acpikqfilter(dev_t dev, struct knote *kn)
{
	return (ENXIO);
}
#endif /* SMALL_KERNEL */
@


1.331
log
@
Add "PNP0303" (8042 PS/2 Controller) to acpi_isa_hids[]

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.330 2017/07/22 21:06:17 jcs Exp $ */
d2882 1
a2883 1
		node->parent->attached = 1;
@


1.330
log
@acpibat: look for _BIX first before falling back on _BIF

ACPI 4.0 deprecated _BIF for battery status so some newer machines
are exporting _BIX which extends _BIF's package with a few extra
fields.  When using _BIX, export the new discharge cycle count as a
sensor.

feedback from kettenis and anton
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.329 2017/07/20 18:34:24 kettenis Exp $ */
d2804 1
@


1.329
log
@Start a list of isa(4) device names such that we can avoid printing them
as "not configured".

ok mikeb@@, millert@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.328 2017/04/08 04:06:01 deraadt Exp $ */
d3099 1
a3099 1
			if (bat->aba_softc->sc_bif.bif_last_capacity == 0)
d3104 1
a3104 1
			    bat->aba_softc->sc_bif.bif_last_capacity;
@


1.328
log
@Sensors are run as callbacks inside tasks.  During suspend a sensor
could be running inside a driver that will be force-detached, or due
to tsleep end up disrupting the softstate/hardstate contract.  At
suspend time, quisce all these callbacks by waiting for completion.
This issue has never been observed for real, but may be implicated in
suspend/resume failures.
ok kettenis guenther mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.327 2017/04/08 01:20:10 deraadt Exp $ */
d2802 6
d2865 2
a2866 1
	if (acpi_matchhids(&aaa, acpi_skip_hids, "none"))
@


1.327
log
@Two prototypes for acpi_maptable; merge to one place
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.326 2017/03/27 20:27:38 deraadt Exp $ */
d2408 1
d2488 1
@


1.326
log
@Now that hibernate_alloc() only has clean success/failure, don't
need to call hibernate_free() to clean up a partial mess.
ok mlarkin kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.325 2017/03/13 01:50:49 deraadt Exp $ */
a92 3

struct acpi_q *acpi_maptable(struct acpi_softc *, paddr_t, const char *,
	    const char *, const char *, int);
@


1.325
log
@allow ramdisks to build; ok jcs
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.324 2017/03/12 21:30:44 jcs Exp $ */
a2491 1
fail_alloc:
d2494 1
@


1.324
log
@try to attach acpisbs first and if successful, don't attach acpibat
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.323 2017/03/02 10:38:10 natano Exp $ */
a118 1
int	acpi_foundsbs(struct aml_node *node, void *);
d138 1
d1086 1
d1089 1
@


1.323
log
@Add a new sysctl machdep.lidaction. The sysctl works as follows:

machdep.lidaction=0	# do nothing
machdep.lidaction=1	# suspend
machdep.lidaction=2	# hibernate

lidsuspend is just an alias for lidaction, so if you change one, the
other one will have the same value. The plan is to remove
machdep.lidsuspend eventually when people have upgraded their
/ets/sysctl.conf.

discussed with deraadt, who came up with the new MIB name
no objections mlarkin
ok stsp halex jcs
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.322 2017/02/28 10:39:07 natano Exp $ */
d119 1
d1086 3
d2915 38
@


1.322
log
@Untangle abstract sleep modes from ACPI sleep states. This paves the way
for further work in the area.

idea and ok deraadt
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.321 2017/02/22 16:39:56 jcs Exp $ */
d2352 1
a2352 1
	extern int lid_suspend;
d2509 1
a2509 1
	if (acpibtn_numopenlids() == 0 && lid_suspend != 0)
@


1.321
log
@add acpisbs, an acpi smart battery subsystem driver reading data
over smbus

currently disabled because it conflicts with acpibat

ok deraadt, kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.320 2017/01/14 11:32:00 kettenis Exp $ */
d2349 1
a2349 1
acpi_sleep_state(struct acpi_softc *sc, int state)
d2356 1
a2356 1
	int s;
d2358 8
a2365 6
	switch (state) {
	case ACPI_STATE_S0:
		return (0);
	case ACPI_STATE_S1:
		return (EOPNOTSUPP);
	case ACPI_STATE_S5:	/* only sleep states handled here */
d2394 1
a2394 1
	if (state == ACPI_STATE_S4) {
d2450 1
a2450 1
	if (state == ACPI_STATE_S4) {
d2487 1
a2487 1
	if (state == ACPI_STATE_S4) {
d2510 1
a2510 1
		acpi_addtask(sc, acpi_sleep_task, sc, state);
d3007 1
a3007 1
		acpi_addtask(sc, acpi_sleep_task, sc, ACPI_STATE_S3);
d3022 1
a3022 1
		acpi_addtask(sc, acpi_sleep_task, sc, ACPI_STATE_S4);
@


1.320
log
@Revert aml_rdpciaddr changes; breaks several machines that were working
before.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.319 2017/01/11 09:39:39 jsg Exp $ */
d1116 6
d1768 1
d1775 1
a1775 2
		aml_notify(ac->aac_softc->sc_devnode,
		    0x80);
d1777 3
a1779 2
		aml_notify(bat->aba_softc->sc_devnode,
		    0x80);
d2986 1
d3063 21
@


1.319
log
@Increase the size of the buffers used for _HID and _CID strings to be
able to fit "Hyper_V_Gen_Counter_V1".

ok mlarkin@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.318 2017/01/08 12:39:16 kettenis Exp $ */
a616 1
	node->pci = pci;
d642 4
a645 2
	if (pci->dev > 31 || pci->fun > 7)
		return 1;
d648 5
a652 2
	if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID)
		return 1;
a1068 3
	/* get PCI mapping */
	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_getpci, sc);

d1071 3
@


1.318
log
@Make aml_rdpciaddr() work for for devices behind bridges.  The code now
uses the mapping between AML nodes and PCI devices that we establish.
Because _INIT methods may end up calling aml_rdpciaddr(), make sure we
create that mapping early.  Also handle devices that aren't actually present.
These devices are now included in the mapping and reads will return an
all-ones patterm whereas writes are a no-op..

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.317 2016/10/25 06:48:58 pirofti Exp $ */
d2816 2
a2817 2
	char		 	 cdev[16];
	char		 	 dev[16];
d2824 1
a2824 1
	if (acpi_parsehid(node, arg, cdev, dev, 16) != 0)
@


1.317
log
@Add the resource index to aml_parse_resource() callback function.

This is needed by an upcoming acpiec commit that handles machines breaking
the current ACPI specifications.

Change suggested by and ok kettenis@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.316 2016/09/18 23:56:45 guenther Exp $ */
d617 1
d643 2
a644 4
	if (pci->dev > 0x1F || pci->fun > 7) {
		free(pci, M_DEVBUF, sizeof(*pci));
		return (1);
	}
d647 2
a648 5
	if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID) {
		free(pci, M_DEVBUF, sizeof(*pci));
		return (1);
	}
	node->pci = pci;
d1065 3
a1069 3

	/* Get PCI mapping */
	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_getpci, sc);
@


1.316
log
@If the APIC table (MADT) isn't present then ci_acpi_proc_id won't be set
when acpicpu tries to attach, leading to a NULL dereference.  The ACPI
processor object on the Dells where this was reported is bogus and useless
anyway so apply the same test when deciding whether to attach to processor
objects as acpicpu would when matching them to cpus.

Problem reported by Eivind Eide (xenofil (at) gmail.com) and
Johan Huldtgren (johan+openbsd-bugs (at) huldtgren.com).
Testing by Eivind Eide.
ok kettenis@@ mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.315 2016/09/03 14:46:56 naddy Exp $ */
d516 1
a516 1
int acpi_getminbus(union acpi_resource *crs, void *arg);
d519 1
a519 1
acpi_getminbus(union acpi_resource *crs, void *arg)
@


1.315
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.314 2016/08/31 15:40:42 mlarkin Exp $ */
a1960 1
#ifdef MULTIPROCESSOR
a1964 1
#endif
a1976 1
#ifdef MULTIPROCESSOR
a1987 1
#endif
@


1.314
log
@
Don't put a device in the wake device list if _STA says it's not there.

Fixes at least one machine that woke up from sleep / poweroff immediately.

ok kettenis@@, tested by kettenis and martijn@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.313 2016/07/28 21:57:56 kettenis Exp $ */
d2386 2
d2487 2
@


1.313
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.312 2016/06/10 20:03:46 kettenis Exp $ */
d2113 7
@


1.312
log
@The power management timer has been made optional in ACPI 5.0A, so don't
attempt to attach acpitimer(4) if the timer isn't present.

Pointed out by jcs@@

ok jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.311 2016/05/08 10:09:25 kettenis Exp $ */
d1963 2
d1985 5
a1989 2
		if (proc_id < -1 || proc_id >= LAPIC_MAP_SIZE ||
		    (acpi_lapic_flags[proc_id] & ACPI_PROC_ENABLE) == 0)
@


1.311
log
@Make sure devices listed by a device's _DEP method are attached before
we attach the device itself.  The _DEP methode, introduced in ACPI 5.0,
is a hint that the device in question depends on OpRegion support from
the devices listed by _DEP, so we have to order them the proper way.
To prevent us from attaching those devices again when we encounter them
later walking down the device tree, keep track of our attempts to
attach a device driver to them using aflag in the aml_node structure.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.310 2016/04/25 15:43:30 pirofti Exp $ */
d1036 2
a1037 1
	if (!sc->sc_hw_reduced) {
@


1.310
log
@We attach acpihpet(4) and acpiec(4) without using the HID, so do not
report it in the dmesg.

OK deraadt@@, mlarkin@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.309 2016/04/02 13:54:29 kettenis Exp $ */
d2775 27
d2824 2
d2846 4
a2849 1
	config_found(self, &aaa, acpi_print);
@


1.309
log
@Reduce dmesg spam by knocking out some acpi hardware IDs that don't need a
driver.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.308 2016/03/29 18:04:09 kettenis Exp $ */
d2761 1
d2770 1
@


1.308
log
@Check if a device is present (using _STA) in acpi_foundhid.  This prevents
us from reporting devices as "not configured" that aren't actually present,
and allows us to remove duplicated code from several drivers.

ok deraadt@@, ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.307 2016/03/29 17:52:04 kettenis Exp $ */
d2756 17
d2793 1
a2793 1
		return 0;
d2800 3
@


1.307
log
@Implement a cleaner way to prevent acpivout(4) from attaching if we have
a platform-specific method of controlling the backlight.

ok millert@@, mlarkin@@, jung@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.306 2016/03/28 19:12:17 kettenis Exp $ */
d2764 1
d2771 6
@


1.306
log
@Adding each and every new acpi device driver to acpi_foundhid() is
gettinga bit of the burden.  And it really isn't how our autoconf
framework is supposed to work for busses that can be enumerated.  All
the drivers already check for a matching _HID in their attach
function.  So we can just drop the checks in acpi_foundhid() and let
the drivers sort themselves out.

Print a "not configured" line for devices for which we don't attach adriver.
This may be a bit much as there are devices for which we will not have a
driver.  This will be removed if it causes too much dmesg spam.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.305 2016/01/17 09:04:18 jsg Exp $ */
a123 4
int	acpi_thinkpad_enabled;
int	acpi_toshiba_enabled;
int	acpi_asus_enabled;

d1096 2
a1097 4
	/* attach video only if this is not a thinkpad or toshiba */
	if (!acpi_thinkpad_enabled && !acpi_toshiba_enabled &&
	    !acpi_asus_enabled)
		aml_find_node(&aml_root, "_DOS", acpi_foundvideo, sc);
a2775 12

	if (!strcmp(dev, ACPI_DEV_ASUS) ||
	    !strcmp(dev, ACPI_DEV_ASUS1)) {
		acpi_asus_enabled = 1;
	} else if (!strcmp(dev, ACPI_DEV_IBM) ||
	    !strcmp(dev, ACPI_DEV_LENOVO)) {
		acpi_thinkpad_enabled = 1;
	} else if (!strcmp(dev, ACPI_DEV_TOSHIBA_LIBRETTO) ||
	    !strcmp(dev, ACPI_DEV_TOSHIBA_DYNABOOK) ||
	    !strcmp(dev, ACPI_DEV_TOSHIBA_SPA40)) {
		acpi_toshiba_enabled = 1;
	}
@


1.305
log
@Take acpi_foundhid() outside of #ifndef SMALL_KERNEL so the ramdisk
kernel can find and attach dwiic(4) and sdhc(4).
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.304 2016/01/17 08:40:09 jsg Exp $ */
d1158 2
d2783 1
a2783 9
	if (!strcmp(dev, ACPI_DEV_AC)) {
		aaa.aaa_name = "acpiac";
	} else if (!strcmp(dev, ACPI_DEV_CMB)) {
		aaa.aaa_name = "acpibat";
	} else if (!strcmp(dev, ACPI_DEV_LD) ||
	    !strcmp(dev, ACPI_DEV_PBD) ||
	    !strcmp(dev, ACPI_DEV_SBD)) {
		aaa.aaa_name = "acpibtn";
	} else if (!strcmp(dev, ACPI_DEV_ASUS) ||
a2784 1
		aaa.aaa_name = "acpiasus";
a2787 1
		aaa.aaa_name = "acpithinkpad";
a2788 2
	} else if (!strcmp(dev, ACPI_DEV_ASUSAIBOOSTER)) {
		aaa.aaa_name = "aibs";
a2791 1
		aaa.aaa_name = "acpitoshiba";
a2792 8
	} else if (!strcmp(dev, "80860F14") || !strcmp(dev, "PNP0FFF")) {
		aaa.aaa_name = "sdhc";
	} else if (!strcmp(dev, ACPI_DEV_DWIIC1) ||
	    !strcmp(dev, ACPI_DEV_DWIIC2) ||
	    !strcmp(dev, ACPI_DEV_DWIIC3) ||
	    !strcmp(dev, ACPI_DEV_DWIIC4) ||
	    !strcmp(dev, ACPI_DEV_DWIIC5)) {
		aaa.aaa_name = "dwiic";
d2806 1
a2806 2
	if (aaa.aaa_name)
		config_found(self, &aaa, acpi_print);
@


1.304
log
@remove an unused global variable
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.303 2016/01/14 21:37:18 kettenis Exp $ */
d118 2
a123 2
#ifndef SMALL_KERNEL

d128 2
a138 1
int	acpi_foundhid(struct aml_node *, void *);
a157 2
int	acpi_add_device(struct aml_node *node, void *arg);

a1085 1
#ifndef SMALL_KERNEL
d1091 1
a2706 2
#ifndef SMALL_KERNEL

d2768 1
d2770 1
d2814 1
d2823 1
d2831 1
@


1.303
log
@Attach dwiic(4) on the Intel Bay Trail i2c controllers as well.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.302 2016/01/12 07:42:39 kettenis Exp $ */
a126 1
int	acpi_saved_boothowto;
@


1.302
log
@Improve emulation of PM registers on Hardware-redcued ACPI by emulating
SPL_TYPx, SLP_EN and WAK_STS using the new SLEEP_STATUS_REG and
SLEEP_CONTROL_REG registers.  Makes the transition into S5 (powerdown) work
on the ASUS X205TA.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.301 2016/01/12 01:11:15 jcs Exp $ */
d2811 2
a2812 1
	    !strcmp(dev, ACPI_DEV_DWIIC4)) {
@


1.301
log
@Add dwiic, a driver for the Synopsys DesignWare i2c controller found
on the Samsung ATIV Book 9 laptop.  This initial version only
supports ACPI config/attachment.

Add ihidev, a HID-over-i2c driver largely based on uhidev.  dwiic
handles attaching ihidev devices found in ACPI.

Add ims, a HID-over-i2c mouse/trackpad driver to get basic cursor
and button functionality from HID-compliant i2c trackpads.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.300 2016/01/11 22:06:00 kettenis Exp $ */
d916 1
a916 1
	 * Hardware-Reduced ACPI.
d1278 2
a1279 2
	 * For Hardware-Reduced ACPI we emulate PM1_CNT to reflect
	 * that the systems is always in ACPI mode.
d1281 2
a1282 1
	if (sc->sc_hw_reduced && reg == ACPIREG_PM1_CNT)
d1284 17
d1364 32
d1462 1
a1462 1
	/* Registers don't exist on Hardware-Reduced ACPI. */
@


1.300
log
@Make sdhc(4) attach to hardware IDs "80860F14" and "PNP0FFF".
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.299 2016/01/09 18:54:51 kettenis Exp $ */
d2662 2
a2663 1
acpi_foundhid(struct aml_node *node, void *arg)
d2666 1
a2666 1
	struct device		*self = (struct device *)arg;
a2667 4
	char			 cdev[16];
	struct aml_value	 res;
	struct acpi_attach_args	 aaa;
	int			 i;
d2682 1
a2682 1
		strlcpy(cdev, dev, sizeof(cdev));
d2684 2
a2685 2
		
		dnprintf(10, "compatible with device: %s\n", cdev);
d2687 1
a2687 1
		cdev[0] = '\0';
d2692 1
a2692 1
		return 0;
d2707 20
d2733 1
a2733 1
	if (!strcmp(dev, ACPI_DEV_AC))
d2735 1
a2735 1
	else if (!strcmp(dev, ACPI_DEV_CMB))
d2737 1
a2737 1
	else if (!strcmp(dev, ACPI_DEV_LD) ||
d2739 1
a2739 1
	    !strcmp(dev, ACPI_DEV_SBD))
d2741 2
a2742 1
	else if (!strcmp(dev, ACPI_DEV_ASUS) || !strcmp(dev, ACPI_DEV_ASUS1)) {
d2749 1
a2749 1
	} else if (!strcmp(dev, ACPI_DEV_ASUSAIBOOSTER))
d2751 1
a2751 1
	else if (!strcmp(dev, ACPI_DEV_TOSHIBA_LIBRETTO) ||
d2756 1
a2756 1
	} else if (!strcmp(dev, "80860F14") || !strcmp(dev, "PNP0FFF"))
d2758 6
d2777 1
a2777 3
	aml_freevalue(&res);

	return 0;
@


1.299
log
@Initial support for Hardware-Reduced ACPI.  This skips the legacy mode checks
by emulating the PM_CNT register such that SCI_EN is always enabled.  It also
skip attaching acpitimer(4) since the relevant registers are no longer there.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.298 2016/01/06 09:14:09 kettenis Exp $ */
d2738 2
a2739 1
	}
@


1.298
log
@Follow the spec and check the SCI_EN bit to see if ACPI has already
been enabled and don't bother enabling it again if it is.  This should fix
systems that don't implement legacy mode and therefore set ACPI_ENABLE and
ACPI_DISABLE to zero.

ok mlarkin@@, yasuoka@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.297 2015/11/23 00:10:53 reyk Exp $ */
d914 8
d1042 1
a1042 1
	{
d1277 7
d1411 4
@


1.297
log
@Back out the CRITICAL change, turn it back from 10% to 25%.  Some
people with old/broken batteries didn't like this change, and the
underlying heuristics are wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.296 2015/11/22 09:40:07 reyk Exp $ */
d85 1
d856 1
d914 3
d918 1
a918 1
	 * Check if we are able to enable ACPI control
d920 2
a921 1
	if (sc->sc_fadt->smi_cmd &&
d924 1
a984 3
	/* Map Power Management registers */
	acpi_map_pmregs(sc);

d1004 1
a1004 1
	if (sc->sc_fadt->smi_cmd) {
d1501 12
@


1.296
log
@The "CRITICAL" APM battery level, that is exported/faked by the ACPI
stack, is currently set to 25%.  With 25% battery left, a typical
modern laptop will have at least one hour runtime left.  It is an
arbitrary value, and other APM power layers in the kernel set CRITICAL
to something like 5% or 10%, so set it to 10% for now.

OK mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.295 2015/09/28 18:36:36 deraadt Exp $ */
d2927 1
a2927 1
		else if (pi->battery_life > 10)
@


1.295
log
@In low-level suspend routines, set cold=2.  In tsleep(), use this to
spit out a ddb trace to console.  This should allow us to find suspend
or resume routines which break the rules.  It depends on the console
output function being non-sleeping.... but that's another codepath which
should try to be safe when cold is set.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.294 2015/09/06 16:47:48 deraadt Exp $ */
d2927 1
a2927 1
		else if (pi->battery_life > 25)
@


1.294
log
@clarify malloc arguments (base + length...)
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.293 2015/08/28 00:03:53 deraadt Exp $ */
d2319 1
a2319 1
	cold = 1;	/* Force other code to delay() instead of tsleep() */
@


1.293
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.292 2015/08/20 20:50:10 kettenis Exp $ */
d1190 1
a1190 1
	entry = malloc(len + sizeof(*entry), M_DEVBUF, M_NOWAIT);
@


1.292
log
@Respect the access size when reading or writing to pci config space.
This version also makes sure writes are properly aligned, preventing
the panics seen with the previous incarnation of this change.

Fixes battery status passthrough in vmware, brightness keys on my x220
and who knows what else.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.291 2015/08/04 15:21:59 deraadt Exp $ */
d648 1
a648 1
		free(pci, M_DEVBUF, 0);
d654 1
a654 1
		free(pci, M_DEVBUF, 0);
d1558 1
a1558 1
	free(wq, M_DEVBUF, 0);
d2036 1
a2036 1
		free(wq, M_DEVBUF, 0);
d2547 1
a2547 1
	free(thread, M_DEVBUF, 0);
@


1.291
log
@If we are setting ACPI_PM1_BM_RLD do it only once, and remember to
repeat this action at resume time.
ok mlarkin guenther
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.290 2015/07/29 18:33:17 deraadt Exp $ */
d221 44
d274 1
a274 1
	int reg, idx, ival, sval;
a372 1
		/* XXX: This is ugly. read-modify-write does a byte at a time */
d374 1
a374 2
		for (idx = reg; idx < reg+len; idx++) {
			ival = pci_conf_read(pc, tag, idx & ~0x3);
d376 18
a393 1
				*pb = ival >> (8 * (idx & 0x3));
d395 18
a412 4
				sval = *pb;
				ival &= ~(0xFF << (8* (idx & 0x3)));
				ival |= sval << (8* (idx & 0x3));
				pci_conf_write(pc, tag, idx & ~0x3, ival);
a413 1
			pb++;
a2352 1
		uvm_pmr_zero_everything();
@


1.290
log
@Something subtle in previous revision is locking up suspend or booting
on some laptops.  Mailing lists threads mention x220 and Asus machines.
Reverting for now.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.288 2015/07/17 22:34:00 mlarkin Exp $ */
d2110 2
d2128 2
a2129 1
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT, 0, ACPI_PM1_SCI_EN);
@


1.289
log
@iRespect the access size when reading or writing to pci config space.
Fixes battery status passthrough in vmware and who knows what else.

Tested by many.

ok mlarkin@@, deraadt@@
@
text
@a220 44
uint8_t
acpi_pci_conf_read_1(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	uint32_t val = pci_conf_read(pc, tag, reg & ~0x3);
	return (val >> ((reg & 0x3) << 3));
}

uint16_t
acpi_pci_conf_read_2(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	uint32_t val = pci_conf_read(pc, tag, reg & ~0x2);
	return (val >> ((reg & 0x2) << 3));
}

uint32_t
acpi_pci_conf_read_4(pci_chipset_tag_t pc, pcitag_t tag, int reg)
{
	return pci_conf_read(pc, tag, reg);
}

void
acpi_pci_conf_write_1(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint8_t val)
{
	uint32_t tmp = pci_conf_read(pc, tag, reg & ~0x3);
	tmp &= ~(0xff << ((reg & 0x3) << 3));
	tmp |= (val << ((reg & 0x3) << 3));
	pci_conf_write(pc, tag, reg & ~0x3, tmp);
}

void
acpi_pci_conf_write_2(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint16_t val)
{
	uint32_t tmp = pci_conf_read(pc, tag, reg & ~0x2);
	tmp &= ~(0xffff << ((reg & 0x2) << 3));
	tmp |= (val << ((reg & 0x2) << 3));
	pci_conf_write(pc, tag, reg & ~0x2, tmp);
}

void
acpi_pci_conf_write_4(pci_chipset_tag_t pc, pcitag_t tag, int reg, uint32_t val)
{
	pci_conf_write(pc, tag, reg, val);
}

d230 1
a230 1
	int reg, idx;
d329 1
d331 2
a332 1
		for (idx = 0; idx < len; idx += access_size) {
d334 1
a334 18
				switch (access_size) {
				case 1:
					*(uint8_t *)(pb + idx) = 
					    acpi_pci_conf_read_1(pc, tag, reg + idx);
					break;
				case 2:
					*(uint16_t *)(pb + idx) =
					    acpi_pci_conf_read_2(pc, tag, reg + idx);
					break;
				case 4:
					*(uint32_t *)(pb + idx) =
					    acpi_pci_conf_read_4(pc, tag, reg + idx);
					break;
				default:
					printf("%s: rdcfg: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
d336 4
a339 18
				switch (access_size) {
				case 1:
					acpi_pci_conf_write_1(pc, tag, reg + idx,
					    *(uint8_t *)(pb + idx));
					break;
				case 2:
					acpi_pci_conf_write_2(pc, tag, reg + idx,
					    *(uint16_t *)(pb + idx));
					break;
				case 4:
					acpi_pci_conf_write_4(pc, tag, reg + idx,
					    *(uint32_t *)(pb + idx));
					break;
				default:
					printf("%s: wrcfg: invalid size %d\n",
					    DEVNAME(sc), access_size);
					return (-1);
				}
d341 1
@


1.288
log
@
fix comments
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.287 2015/03/26 01:30:22 jsg Exp $ */
d221 44
d274 1
a274 1
	int reg, idx, ival, sval;
a372 1
		/* XXX: This is ugly. read-modify-write does a byte at a time */
d374 1
a374 2
		for (idx = reg; idx < reg+len; idx++) {
			ival = pci_conf_read(pc, tag, idx & ~0x3);
d376 18
a393 1
				*pb = ival >> (8 * (idx & 0x3));
d395 18
a412 4
				sval = *pb;
				ival &= ~(0xFF << (8* (idx & 0x3)));
				ival |= sval << (8* (idx & 0x3));
				pci_conf_write(pc, tag, idx & ~0x3, ival);
a413 1
			pb++;
@


1.287
log
@Use the 0x10 extended capability to determine if the trackstick
buttons are wired to the trackpad and need to be re-routed to the
trackstick.  Without this change the buttons on 2015 thinkpads
get picked up as extended buttons that show up as scroll up/down.

Remove the X1 Carbon 2015 (LEN0048) and X250 (LEN0046) from the
top button area/soft buttons quirks list.  Also avoid using the
quirk list entirely if the capability bit is set.

Based on work from jcs@@ with feedback from mpi@@
ok mpi@@ jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.286 2015/03/20 20:25:10 kettenis Exp $ */
d1018 1
a1018 1
	/* attach video only if this is not a stinkpad or toshiba */
d1023 1
a1023 1
	/* create list of devices we want to query when APM come in */
@


1.286
log
@The ACPI standard says that a PCI function number of FFFF can be used to refer
to all functions on a device.  This makes no sense in the context of accessing
PCI config space.  Nevertheless stsp@@ has a machine with AML that tries to
do config space reads from a device where _ADR encodes function number FFFF.
This is almost certainly buggy AML, but since Linux (and presumably Windows)
boot just fine on this machine we need to work around this.  Linux effectively
treats function FFFF as function 7, which isn't present on this machine.
Instead we simulate a read from a non-existent device by returning a bit
pattern of all ones.  Writes to function FFFF will still panic.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.285 2015/03/16 20:31:46 deraadt Exp $ */
a185 1
	"LEN0046",
a186 1
	"LEN0048",
@


1.285
log
@Reduce use of SMALL_KERNEL in acpi, bringing acpiec driver and more gpe
handling into RAMDISK.  This is now possible because the install media
has ample room.  The goal is to reduce special cases where we may be
skipping (unknown) important operations...
ok mlarkin kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.284 2015/03/14 03:38:46 jsg Exp $ */
d311 15
@


1.284
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.283 2015/02/07 01:19:40 deraadt Exp $ */
d103 18
d127 2
a128 1
int	acpi_enabled;
a132 2
void	acpi_thread(void *);
void	acpi_create_thread(void *);
a133 2
void	acpi_init_gpes(struct acpi_softc *);
void	acpi_indicator(struct acpi_softc *, int);
a137 1
int	acpi_foundec(struct aml_node *, void *);
a140 1
int	acpi_foundsony(struct aml_node *node, void *arg);
a158 27
struct gpe_block *acpi_find_gpe(struct acpi_softc *, int);
void	acpi_enable_onegpe(struct acpi_softc *, int);
int	acpi_gpe(struct acpi_softc *, int, void *);

void	acpi_enable_rungpes(struct acpi_softc *);
void	acpi_enable_wakegpes(struct acpi_softc *, int);
void	acpi_disable_allgpes(struct acpi_softc *);

#endif /* SMALL_KERNEL */

/* XXX move this into dsdt softc at some point */
extern struct aml_node aml_root;

struct cfattach acpi_ca = {
	sizeof(struct acpi_softc), acpi_match, acpi_attach
};

struct cfdriver acpi_cd = {
	NULL, "acpi", DV_DULL
};

struct acpi_softc *acpi_softc;

#define acpi_bus_space_map	_bus_space_map
#define acpi_bus_space_unmap	_bus_space_unmap

#ifndef SMALL_KERNEL
d205 17
a221 1
#endif
a336 1
#ifndef SMALL_KERNEL
a340 1
#endif
a464 1
#ifndef SMALL_KERNEL
a477 1
#endif /* SMALL_KERNEL */
a767 3
	struct acpi_ac *ac;
	struct acpi_bat *bat;
	int s;
d770 1
d884 2
a888 1
#ifndef SMALL_KERNEL
a895 1
#ifndef SMALL_KERNEL
a904 1
#endif /* SMALL_KERNEL */
a985 1
#ifndef SMALL_KERNEL
d988 4
a1004 3
	/* check if we're running on a sony */
	aml_find_node(&aml_root, "GBRT", acpi_foundsony, sc);

d1015 2
d1021 2
d1029 2
a1041 1
#endif /* SMALL_KERNEL */
a1430 23
void
acpi_init_states(struct acpi_softc *sc)
{
	struct aml_value res;
	char name[8];
	int i;

	printf("\n%s: sleep states", DEVNAME(sc));
	for (i = ACPI_STATE_S0; i <= ACPI_STATE_S5; i++) {
		snprintf(name, sizeof(name), "_S%d_", i);
		sc->sc_sleeptype[i].slp_typa = -1;
		sc->sc_sleeptype[i].slp_typb = -1;
		if (aml_evalname(sc, &aml_root, name, 0, NULL, &res) == 0) {
			if (res.type == AML_OBJTYPE_PACKAGE) {
				sc->sc_sleeptype[i].slp_typa = aml_val2int(res.v_package[0]);
				sc->sc_sleeptype[i].slp_typb = aml_val2int(res.v_package[1]);
				printf(" S%d", i);
			}
			aml_freevalue(&res);
		}
	}
}

d1480 1
d1592 21
a1708 19
void
acpi_sleep_task(void *arg0, int sleepmode)
{
	struct acpi_softc *sc = arg0;
	struct acpi_ac *ac;
	struct acpi_bat *bat;

	/* System goes to sleep here.. */
	acpi_sleep_state(sc, sleepmode);

	/* AC and battery information needs refreshing */
	SLIST_FOREACH(ac, &sc->sc_ac, aac_link)
		aml_notify(ac->aac_softc->sc_devnode,
		    0x80);
	SLIST_FOREACH(bat, &sc->sc_bat, aba_link)
		aml_notify(bat->aba_softc->sc_devnode,
		    0x80);
}

d2028 25
d2164 1
a2327 9
void
acpi_wakeup(void *arg)
{
	struct acpi_softc  *sc = (struct acpi_softc *)arg;

	sc->sc_threadwaiting = 0;
	wakeup(sc);
}

d2361 39
a2476 27
acpi_map_address(struct acpi_softc *sc, struct acpi_gas *gas, bus_addr_t base,
    bus_size_t size, bus_space_handle_t *pioh, bus_space_tag_t *piot)
{
	int iospace = GAS_SYSTEM_IOSPACE;

	/* No GAS structure, default to I/O space */
	if (gas != NULL) {
		base += gas->address;
		iospace = gas->address_space_id;
	}
	switch (iospace) {
	case GAS_SYSTEM_MEMORY:
		*piot = sc->sc_memt;
		break;
	case GAS_SYSTEM_IOSPACE:
		*piot = sc->sc_iot;
		break;
	default:
		return -1;
	}
	if (bus_space_map(*piot, base, size, 0, pioh))
		return -1;

	return 0;
}

int
d2520 20
a2670 18
}

int
acpi_foundsony(struct aml_node *node, void *arg)
{
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	struct device *self = (struct device *)arg;
	struct acpi_attach_args aaa;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_name = "acpisony";

	config_found(self, &aaa, acpi_print);

	return 0;
@


1.283
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.282 2015/02/06 05:17:48 mlarkin Exp $ */
a53 1
#include <dev/pci/pciidereg.h>
@


1.282
log
@
Fix a hibernate crash on some machines due to unmapping a page that
may not have been mapped previously (in the failure to hibernate case).

Also ensure that the lowmem ptp is mapped in all cases (not just MP).

ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.281 2015/01/17 04:18:49 deraadt Exp $ */
d2166 2
d2261 1
d2283 1
a2283 1
	resume_randomness();		/* force RNG upper level reseed */
@


1.281
log
@resume_randomness() before spinning up other cpus...
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.280 2015/01/15 01:19:28 jsg Exp $ */
d2203 3
a2205 1
		if (hibernate_alloc())
d2207 1
@


1.280
log
@Define a new wscons mouse type for Synaptics clickpad devices that lack
physical buttons.  This will be used if the acpi pnpid for the mouse
matches a list provided by Synaptics found in Linux.

Combined with the xenocara changes this will remove the need for an xorg
config file for the x240/t440/t540 generation of thinkpads.

ok matthieu@@ shadchin@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.279 2015/01/11 19:59:56 kettenis Exp $ */
d2277 2
a2282 1
	resume_randomness();		/* force RNG upper level reseed */
@


1.279
log
@Tolerate checksum errors in ACPI tables (but complain about them).  Apparently
there are machines out there with broken BIOSen with such checksum errors in
thier RSDT tables.  Windows runs fine on these machines, so it probably does
not check.  Linux ignores checksum errors as well (and prints a warning).

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.278 2014/12/18 16:31:50 deraadt Exp $ */
d173 49
d2510 1
d2512 23
a2534 1
	struct acpi_attach_args	aaa;
d2583 8
@


1.278
log
@suspend and resume the RNG (at what looks like the right spots)
ok reyk djm
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.277 2014/12/09 06:58:29 doug Exp $ */
d1045 4
a1048 4
	if (acpi_checksum(hdr, len)) {
		acpi_unmap(&handle);
		return NULL;
	}
@


1.277
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.276 2014/12/06 11:10:56 mpi Exp $ */
d42 1
d2178 2
d2232 1
@


1.276
log
@If "machdep.lidsuspend" is not set, do not go back to sleep if the lid
is still closed when resuming.  This allows docked laptop to be resumed
without opening them.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.275 2014/11/23 20:33:47 mlarkin Exp $ */
d1963 1
a1963 1
	sc->gpe_table = malloc(sc->sc_lastgpe * sizeof(struct gpe_block),
@


1.275
log
@
If a machine has no _LIDs, then none can be open. This diff fixes a problem
where machines without any _LIDs were going back to sleep after hibernate
due to the recent suspend-if-lid-closed-on-resume diff. Noticed on qemu,
which doesn't have any _LIDs.

discussed with deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.274 2014/11/18 23:55:01 krw Exp $ */
d2114 1
d2256 1
a2256 1
	if (acpibtn_numopenlids() == 0)
@


1.274
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.273 2014/11/08 07:45:10 mlarkin Exp $ */
d2254 2
a2255 4
	/*
	 * If we woke up but the lid is closed, go back to sleep
	 */
	if (!acpibtn_checklidopen())
@


1.273
log
@
If resuming from sleep (zzz/ZZZ) and the lid is still closed, go back to
sleep. This prevents accidental lid flex or slight opening in a backpack
from waking the machine up and leaving it resumed (powered on).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.272 2014/09/26 09:25:38 kettenis Exp $ */
a49 1
#include <dev/pci/pcivar.h>
@


1.272
log
@Rework piglet and pig allocation.  Currently the piglet gets allocated
deep down in the suspend path, where it is really hard to recover from
allocation failure.  So allocate the piglet early on in the suspend path.
Also change the piglet and piglet allocation functions to use km_alloc(9)
instead of doing pmemrange magic.  This removes a bunch of code which, in the
case of the piglet allocation, is broken since it results in a NULL pointer
dereference.  Also switch the piglet allocation to not wait.  If we can't
allocate 16MB of phys contig memory on a halfway modern machine we're almost
certainly under a lot of memory pressure and we're better off not trying to
hibernate anyway.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.271 2014/09/25 21:45:54 kettenis Exp $ */
d2254 6
@


1.271
log
@Bring back rev 1.249.  Now that mp_setperf() has been fixed, it should be
safe to restore perflevel when resuming.  Should fix the issues people
see with the processor running at full speed heating up the machine while
the apm command reports that the CPUs are running at a low speed.

ok dcoppa@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.270 2014/09/23 18:33:34 kettenis Exp $ */
a2148 3
	if (config_suspend_all(DVACT_QUIESCE))
		goto fail_quiesce;

d2153 2
d2158 3
d2234 8
a2253 7

#ifdef HIBERNATE
	if (state == ACPI_STATE_S4) {
		hibernate_free();
		hibernate_resume_bufcache();
	}
#endif /* HIBERNATE */
@


1.270
log
@Release the acpi lock around calls to wsdisplay_suspend() and
wsdisplay_resume().  The X server may adjust the display brightness just
before/after the VT switch when suspending/resuming.  In fact, it may
already be blocked adjusting the display brightness for some reason
unrelated to the suspend request.

The VT switch request will eventually time out, but the delay is annoying
and the failed VT switch will lead to problems after resume.

Needed for a future update of the xf86-video-intel driver.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.269 2014/09/19 20:02:25 kettenis Exp $ */
d32 1
d2114 1
d2237 4
@


1.269
log
@Use config_suspend_all(9).
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.268 2014/09/08 20:25:03 kettenis Exp $ */
d2138 5
d2144 1
d2231 1
d2233 1
@


1.268
log
@Clear the PME Status bit on PCI devices in response to Device Wake events.
Fixes the interrupt storm on the 2009 Mac mini with WOL enabled on its
nfe(4) interface.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.267 2014/07/20 18:05:21 mlarkin Exp $ */
a2112 1
	struct device *mainbus = device_mainbus();
d2141 1
a2141 1
	if (config_suspend(mainbus, DVACT_QUIESCE))
d2163 1
a2163 1
	if (config_suspend(mainbus, DVACT_SUSPEND) != 0)
d2202 1
a2202 1
	config_suspend(mainbus, DVACT_RESUME);
d2222 1
a2222 1
	config_suspend(mainbus, DVACT_WAKEUP);
@


1.267
log
@
Support hibernating to softraid crypto volumes.

much help and ok from deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.266 2014/07/16 07:42:50 mlarkin Exp $ */
d77 1
d571 2
d666 23
@


1.266
log
@

Reenable hibernate RLE support and flush+zero all memory after unpack.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.265 2014/07/12 18:48:17 tedu Exp $ */
d2628 1
a2628 1
		if (get_hibernate_io_function() == NULL) {
@


1.265
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.264 2014/07/12 09:02:24 kettenis Exp $ */
d2165 7
a2208 1
		uvm_pmr_dirty_everything();
@


1.264
log
@Add a function to drop all clean pages on the page daemon queues and call
it when we hibernate.

ok mlarkin@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.263 2014/07/11 08:18:31 guenther Exp $ */
d515 1
a515 1
		free(pci, M_DEVBUF);
d521 1
a521 1
		free(pci, M_DEVBUF);
d1072 1
a1072 1
		free(sdt, M_DEVBUF);
d1091 1
a1091 1
		free(sdt, M_DEVBUF);
d1421 1
a1421 1
	free(wq, M_DEVBUF);
d1896 1
a1896 1
		free(wq, M_DEVBUF);
d2313 1
a2313 1
	free(thread, M_DEVBUF);
@


1.263
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.262 2014/07/11 03:06:08 mlarkin Exp $ */
d2120 2
a2121 1
	if (state == ACPI_STATE_S4)
d2123 1
@


1.262
log
@Flush the buffercache to 16MB on hibernate and restore its previous max
size (kern.bufcachepercent) on resume, for better hibernate performance.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.261 2014/07/10 13:52:15 blambert Exp $ */
d1631 1
a1631 1
		psignal(initproc, SIGUSR2);
@


1.261
log
@remove unneeded header

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.260 2014/07/01 19:13:19 kettenis Exp $ */
d2119 5
d2201 1
@


1.260
log
@Adding an additonal delay after each access to SystemMemory or SystemIO
during autoconf makes no sense.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.259 2014/06/23 18:47:41 kettenis Exp $ */
a29 1
#include <sys/workq.h>
@


1.259
log
@SystemMemory is used to access memory mapped registers on some machines, so we
must use the bus_space(9) API to access it instead of memcpy(9).  Also make
sure we properly align access to fields that need more than byte alignment.

ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.258 2014/05/21 02:14:07 mlarkin Exp $ */
a248 8

			/* During autoconf some devices are still gathering
			 * information.  Delay here to give them an opportunity
			 * to finish.  During runtime we simply need to ignore
			 * transient values.
			 */
			if (cold)
				delay(10000);
@


1.258
log
@Fix invalid / missing format specifiers in several dnprintf statements
(used only when ACPI_DEBUG is enabled)

From a diff on tech@@ by Fabian Raetz, with a minor change by me, tested
on i386 and amd64 with ACPI_DEBUG enabled and disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.257 2014/04/25 14:37:06 mlarkin Exp $ */
d177 1
a178 1
	struct acpi_mem_map mh;
a180 1
	bus_addr_t ioaddr;
d186 2
d191 3
a193 4
		/* copy to/from system memory */
		acpi_map(address, len, &mh);
		if (iodir == ACPI_IOREAD)
			memcpy(buffer, mh.va, len);
d195 1
a195 3
			memcpy(mh.va, buffer, len);
		acpi_unmap(&mh);
		break;
d197 1
a197 4
	case GAS_SYSTEM_IOSPACE:
		/* read/write from I/O registers */
		ioaddr = address;
		if (acpi_bus_space_map(sc->sc_iot, ioaddr, len, 0, &ioh) != 0) {
d205 2
a206 2
					*(uint8_t *)(pb+reg) = bus_space_read_1(
					    sc->sc_iot, ioh, reg);
d211 2
a212 2
					*(uint16_t *)(pb+reg) = bus_space_read_2(
					    sc->sc_iot, ioh, reg);
d217 2
a218 2
					*(uint32_t *)(pb+reg) = bus_space_read_4(
					    sc->sc_iot, ioh, reg);
d228 2
a229 2
					bus_space_write_1(sc->sc_iot, ioh, reg,
					    *(uint8_t *)(pb+reg));
d234 2
a235 2
					bus_space_write_2(sc->sc_iot, ioh, reg,
					    *(uint16_t *)(pb+reg));
d240 2
a241 2
					bus_space_write_4(sc->sc_iot, ioh, reg,
					    *(uint32_t *)(pb+reg));
d258 1
a258 1
		acpi_bus_space_unmap(sc->sc_iot, ioh, len, &ioaddr);
@


1.257
log
@

Defer the free of the hibernate structures until later, when it is safe to
do so.

Freeing the hibernate structures too early leads to inadvertent calls into
splx when we aren't ready for them yet. Found when trapping splx calls in
the resume path.

discussed with deraadt@@ at m2k14
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.256 2014/04/13 14:43:01 mlarkin Exp $ */
a433 1

d437 1
a437 1
		dnprintf(5, "driver %s matches %s\n", driver, hids);
d440 1
d1339 1
a1339 1
			dnprintf(50, "mapping: %.4x %.4x %s\n",
@


1.256
log
@Fix a badly worded debug message that implied the entire machine was going
to sleep, instead of just the acpi thread going to sleep.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.255 2014/03/31 12:11:42 mpi Exp $ */
d2205 8
@


1.255
log
@Change the order of operations during a suspend/resume cycle and
call bufq_quiesce() after executing the DVACT_QUIESCE handlers.

This should be safe since no disk nor controller drivers have such
handler but it will allow us to detach sd(4) devices attached to a
USB bus.

Another benefit pointed out by kettenis@@ is that drivers that need
to read a firmware from the disk should be able to do it at resume
time in a DVACT_WAKEUP handler.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.254 2014/03/13 03:52:56 dlg Exp $ */
d2295 1
a2295 1
			dnprintf(10, "acpi going to sleep...\n");
@


1.254
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.253 2014/02/21 23:48:38 deraadt Exp $ */
a2128 1
	bufq_quiesce();
d2133 2
a2193 1
fail_quiesce:
d2196 1
@


1.253
log
@Do the lid control further on in the resume sequence, since this is
AML, and will do WAITOK operations.  While cold, that is a bad idea.
We seem to be safe with respect to the spec, I do not see any event
debounce issues here.
ok kettenis, tested by many
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.252 2014/01/20 00:47:21 claudio Exp $ */
d2101 1
d2131 1
a2131 1
	if (config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE))
d2144 1
a2144 1
	if (config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND) != 0)
d2176 1
a2176 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d2196 1
a2196 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_WAKEUP);
@


1.252
log
@Instead of checking sc->sc_revision <= 1 check that the
fadt->hdr_revision <= 1. This is a better check since it checks
the version of the proper descriptor. This allows the alix APU
to reboot since those boards have currently a wrong sc->sc_revision.
Committing this now so that it can be tested easier.
With and OK jsg@@ also fine by derradt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.251 2013/12/24 13:23:21 kettenis Exp $ */
a2172 1
	acpibtn_disable_psw();		/* disable _LID for wakeup */
d2182 1
@


1.251
log
@If the FADT has its SMI_CMD set to zero, assume we're only ACPI-only hardware
and don't need to disable SMI ownership of the ACPI hardware registers.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.250 2013/12/23 10:48:43 kettenis Exp $ */
d1567 1
a1567 1
	if (sc->sc_revision <= 1 ||
@


1.250
log
@Revert previous commit.  It makes resume hang on some MP systems running
GENERIC.MP.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.249 2013/12/16 19:11:52 kettenis Exp $ */
d96 1
a704 1
	int idx;
d773 1
a773 1
	if (!sc->sc_fadt->smi_cmd ||
d859 2
a860 4
	acpi_write_pmreg(sc, ACPIREG_SMICMD, 0, sc->sc_fadt->acpi_enable);
	idx = 0;
	do {
		if (idx++ > ACPIEN_RETRIES) {
d864 1
a864 1
	} while (!(acpi_read_pmreg(sc, ACPIREG_PM1_CNT, 0) & ACPI_PM1_SCI_EN));
d1352 16
@


1.249
log
@Restore hw.setperf upon resume like we do for apm(4) on i386.  Seems we need
to do this fairly late in the resume to avoid hangs.

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.248 2013/12/06 21:03:02 deraadt Exp $ */
a32 1
#include <sys/sysctl.h>
a2086 1
	extern int perflevel;
a2185 4

	/* Restore hw.setperf */
	if (cpu_setperf != NULL)
		cpu_setperf(perflevel);
@


1.248
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.247 2013/11/06 10:40:36 mpi Exp $ */
d33 1
d2088 1
d2188 4
@


1.247
log
@Add support for Power Resources for Dx states and the necessary hook
for PCI devices.  This hook should be called twice, before and after
changing the power state of a PCI device.

Before setting the device to the new state, the ACPI layer will notify
every power resources linked to the device for that state and make sure
they are turned "_ON".  After changing the state of the device, it will
decrement the reference of every power resources linked to that device
for the old state and turn them "_OFF" if they are no longer referenced.

This fixes the no-USB after resume problem seen on various ThinkPad,
problem initialy diagnosed with Alexander Polakov.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.246 2013/06/01 23:00:16 mlarkin Exp $ */
d2180 3
@


1.246
log
@

Stop printing ACPI wakeup devices in dmesg after the 16th wakeup device.

Helps with VMware VMs that report hundreds of wakeup devices.

ok reyk@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.245 2013/05/31 22:43:43 bluhm Exp $ */
d77 1
d563 1
d566 17
a582 7
		if (pdev->bus == pa->pa_bus && 
		    pdev->dev == pa->pa_device && 
		    pdev->fun == pa->pa_function) {
			dnprintf(10,"%s at acpi0 %s\n", 
			    dev->dv_xname, aml_nodename(pdev->node));
			pdev->device = dev;
		}
d619 60
d733 4
@


1.245
log
@Fix the build for a kernel without wd and pciide in its config.
OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.244 2013/05/30 16:15:01 deraadt Exp $ */
d634 1
d800 1
d803 6
a808 2
		printf(" %.4s(S%d)", wentry->q_node->name,
		    wentry->q_state);
@


1.244
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.243 2013/04/18 18:30:41 deraadt Exp $ */
d63 1
d858 1
d861 1
d1367 1
d1454 1
@


1.243
log
@pin the acpi thread to the BSP, because AML and SMI cannot be trusted.  I
was certain we were doing this already, but it turns out no...
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.242 2012/12/24 19:41:14 guenther Exp $ */
d157 1
a157 2
	sizeof(struct acpi_softc), acpi_match, acpi_attach, NULL,
	config_activate_children
@


1.242
log
@In acpiioctl(), Return though the splx() path if suser() returns an error

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.241 2012/10/08 21:47:50 deraadt Exp $ */
d2153 3
@


1.241
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.240 2012/10/04 08:32:20 ehrhardt Exp $ */
d2506 2
a2507 2
		if (suser(p, 0) != 0)
			return (EPERM);
@


1.240
log
@Use information provided by ACPI to attach secondary PCI host bridges.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.239 2012/09/07 19:19:59 kettenis Exp $ */
a104 1
int	acpi_saved_spl;
a113 2

void	acpi_handle_suspend_failure(struct acpi_softc *);
d115 1
a140 1
void	acpi_resume(struct acpi_softc *, int);
d579 1
a579 1
	int state;
d584 1
a584 1
			switch (acpi_softc->sc_nextstate) {
d586 1
d592 1
a593 1
				state = -1;
d603 1
a603 1
	return PCI_PMCSR_STATE_D3;
d638 1
d763 1
d765 1
d1460 3
a1701 1
	int s;
a1703 1
	s = spltty();
a1708 1
	splx(s);
d1715 1
a1715 1
	int idx, s;
a1716 1
	s = spltty();
a1720 1
	splx(s);
d1727 1
a1727 1
	int s, idx;
a1728 1
	s = spltty();
a1731 1
	splx(s);
a1738 1
	int s;
a1739 1
	s = spltty();
a1746 1
	splx(s);
a1774 1
	int s;
a1778 1
	s = spltty();
a1783 2
	splx(s);

d1887 2
a1888 2
int
acpi_sleep_state(struct acpi_softc *sc, int state)
d1890 2
a1891 1
	int ret;
d1893 1
a1893 28
	switch (state) {
	case ACPI_STATE_S0:
	case ACPI_STATE_S1:
	case ACPI_STATE_S2:
	case ACPI_STATE_S5:
		return (0);
	}

	if (sc->sc_sleeptype[state].slp_typa == -1 ||
	    sc->sc_sleeptype[state].slp_typb == -1)
		return (EOPNOTSUPP);

	if ((ret = acpi_prepare_sleep_state(sc, state)) != 0)
		return (ret);

	ret = acpi_sleep_machdep(sc, state);

#ifndef SMALL_KERNEL
	acpi_resume(sc, state);
#endif /* !SMALL_KERNEL */
	return (ret);
}

int
acpi_enter_sleep_state(struct acpi_softc *sc, int state)
{
	uint16_t rega, regb;
	int retries;
d1898 4
a1901 2
	/* Disable BM arbitration */
	acpi_write_pmreg(sc, ACPIREG_PM2_CNT, 0, ACPI_PM2_ARB_DIS);
d1913 1
a1913 1
	/* Set SLP_EN bit */
d1916 11
a1926 19

	/*
	 * Let the machdep code flush caches and do any other necessary
	 * tasks before going away.
	 */
	acpi_cpu_flush(sc, state);

	/*
	 * XXX The following sequence is probably not right. 
	 */
	acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, 0, rega);
	acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, 0, regb);

	/* Loop on WAK_STS */
	for (retries = 1000; retries > 0; retries--) {
		rega = acpi_read_pmreg(sc, ACPIREG_PM1A_STS, 0);
		regb = acpi_read_pmreg(sc, ACPIREG_PM1B_STS, 0);
		if ((rega & ACPI_PM1_WAK_STS) ||
		    (regb & ACPI_PM1_WAK_STS))
a1927 1
		DELAY(1000);
a1928 2

	return (-1);
d1932 1
a1932 1
acpi_resume(struct acpi_softc *sc, int state)
d1934 1
a1934 1
	struct aml_value env;
d1936 9
a1944 3
	memset(&env, 0, sizeof(env));
	env.type = AML_OBJTYPE_INTEGER;
	env.v_integer = sc->sc_state;
d1950 1
a1950 8
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0,
	    ACPI_PM1_ALL_STS);

	if (sc->sc_bfs)
		if (aml_evalnode(sc, sc->sc_bfs, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _BFS failed.\n",
			    DEVNAME(sc));
		}
d1952 3
a1954 11
	if (sc->sc_wak)
		if (aml_evalnode(sc, sc->sc_wak, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _WAK failed.\n",
			    DEVNAME(sc));
		}

	/* Reset the indicator lights to "waking" */
	if (sc->sc_sst) {
		env.v_integer = ACPI_SST_WAKING;
		aml_evalnode(sc, sc->sc_sst, 1, &env, NULL);
	}
d1960 1
a1960 2
	if (state == ACPI_STATE_S4)
		boothowto = acpi_saved_boothowto;
d1962 2
a1963 1
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME);
d1965 2
a1966 3
	cold = 0;
	enable_intr();
	splx(acpi_saved_spl);
d1968 6
a1973 1
	acpi_resume_machdep();
d1975 8
a1982 16
	sc->sc_state = ACPI_STATE_S0;
	if (sc->sc_tts) {
		env.v_integer = sc->sc_state;
		if (aml_evalnode(sc, sc->sc_tts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _TTS failed.\n",
			    DEVNAME(sc));
		}
	}

	/* disable _LID for wakeup */
	acpibtn_disable_psw();

	/* Reset the indicator lights to "working" */
	if (sc->sc_sst) {
		env.v_integer = ACPI_SST_WORKING;
		aml_evalnode(sc, sc->sc_sst, 1, &env, NULL);
a1983 12

#ifdef MULTIPROCESSOR
	sched_start_secondary_cpus();
#endif

	acpi_record_event(sc, APM_NORMAL_RESUME);

	bufq_restart();

#if NWSDISPLAY > 0
	wsdisplay_resume();
#endif /* NWSDISPLAY > 0 */
d1986 1
d1988 1
a1988 1
acpi_handle_suspend_failure(struct acpi_softc *sc)
d1990 1
a1990 6
	struct aml_value env;

	/* Undo a partial suspend. Devices will have already been resumed */
	cold = 0;
	enable_intr();
	splx(acpi_saved_spl);
d1992 3
a1994 19
	/* Tell ACPI to go back to S0 */
	memset(&env, 0, sizeof(env));
	env.type = AML_OBJTYPE_INTEGER;
	sc->sc_state = ACPI_STATE_S0;
	if (sc->sc_tts) {
		env.v_integer = sc->sc_state;
		if (aml_evalnode(sc, sc->sc_tts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _TTS failed.\n",
			    DEVNAME(sc));
		}
	}

	/* disable _LID for wakeup */
	acpibtn_disable_psw();

	/* Reset the indicator lights to "working" */
	if (sc->sc_sst) {
		env.v_integer = ACPI_SST_WORKING;
		aml_evalnode(sc, sc->sc_sst, 1, &env, NULL);
a1995 4

#ifdef MULTIPROCESSOR
	sched_start_secondary_cpus();
#endif
d1999 1
a1999 1
acpi_prepare_sleep_state(struct acpi_softc *sc, int state)
d2001 2
a2002 2
	struct aml_value env;
	int error = 0;
d2004 8
a2011 2
	if (sc == NULL || state == ACPI_STATE_S0)
		return(0);
d2017 1
a2017 1
		return (ENXIO);
d2020 13
d2034 1
a2034 2
	sched_stop_secondary_cpus();
	KASSERT(CPU_IS_PRIMARY(curcpu()));
d2037 1
a2037 12
	sc->sc_nextstate = state;

	memset(&env, 0, sizeof(env));
	env.type = AML_OBJTYPE_INTEGER;
	env.v_integer = state;
	/* _TTS(state) */
	if (sc->sc_tts)
		if (aml_evalnode(sc, sc->sc_tts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _TTS failed.\n",
			    DEVNAME(sc));
			return (ENXIO);
		}
d2039 3
a2041 2
	if (state == ACPI_STATE_S4)
		printf("%s: hibernating to disk ...\n", DEVNAME(sc));
d2043 3
a2045 4
#if NWSDISPLAY > 0
	if (state == ACPI_STATE_S3 || state == ACPI_STATE_S4)
		wsdisplay_suspend();
#endif /* NWSDISPLAY > 0 */
d2047 3
a2049 5
	if (state == ACPI_STATE_S3)
		resettodr();

	bufq_quiesce();
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_QUIESCE);
d2051 2
a2052 32
	acpi_saved_spl = splhigh();
	disable_intr();
	cold = 1;
	if (state == ACPI_STATE_S4) {
		acpi_saved_boothowto = boothowto;
		boothowto = RB_RDONLY;
	}
	if (state == ACPI_STATE_S3 || state == ACPI_STATE_S4)
		if (config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND) != 0) {
			acpi_handle_suspend_failure(sc);
			error = ENXIO;
			goto fail;
		}

	/* _PTS(state) */
	if (sc->sc_pts)
		if (aml_evalnode(sc, sc->sc_pts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _PTS failed.\n",
			    DEVNAME(sc));
			error = ENXIO;
			goto fail;
		}

	/* enable _LID for wakeup */
	acpibtn_enable_psw();

	/* Reset the indicator lights to "sleeping" */
	if (sc->sc_sst) {
		env.v_integer = ACPI_SST_SLEEPING;
		aml_evalnode(sc, sc->sc_sst, 1, &env, NULL);
	}
	env.v_integer = state;
d2054 2
a2055 9
	sc->sc_state = state;
	/* _GTS(state) */
	if (sc->sc_gts)
		if (aml_evalnode(sc, sc->sc_gts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _GTS failed.\n",
			    DEVNAME(sc));
			error = ENXIO;
			goto fail;
		}
d2058 1
a2058 2
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0,
	    ACPI_PM1_ALL_STS);
d2064 20
a2083 3
fail:
	if (error) {
		bufq_restart();
d2085 9
d2095 1
a2095 1
		wsdisplay_resume();
a2096 1
	}
d2098 3
d2113 5
d2121 23
a2143 8
	/*
	 * In case acpi_prepare_sleep fails, we shouldn't try to enter
	 * the sleep state. It might cost us the battery.
	 */
	acpi_disable_allgpes(acpi_softc);
	acpi_enable_wakegpes(acpi_softc, ACPI_STATE_S5);
	if (acpi_prepare_sleep_state(acpi_softc, ACPI_STATE_S5) == 0)
		acpi_enter_sleep_state(acpi_softc, ACPI_STATE_S5);
a2177 1
		splx(s);
d2181 1
@


1.239
log
@Add a new function called acpi_pci_min_powerstate() that returns the lowest
power state for a PCI device for the power state (currently S3 or S4) we're
transitioning into.  This function is probably too simplistic; there is a lot
of (silly) complexity in the ACPI spec.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.238 2012/07/13 11:51:41 pirofti Exp $ */
d397 2
d487 1
d606 17
@


1.238
log
@Disable acpivideo(4) on ASUS laptops.

There are some models that panic whenever an event is received.
Some cope, some don't. In order to get this right acpiec(4) requires
major rework. Until then let machines boot.

Discussed with deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.237 2012/07/11 10:57:38 mlarkin Exp $ */
d75 2
d507 18
d574 31
d2092 2
@


1.237
log
@

for now, restrict hibernate to root in the acpi ioctl kernel interface.
normal rules for controlling this interface through apmd still apply.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.236 2012/07/09 15:29:24 deraadt Exp $ */
d102 1
d796 2
a797 1
	if (!acpi_thinkpad_enabled && !acpi_toshiba_enabled)
d2335 1
a2335 1
	else if (!strcmp(dev, ACPI_DEV_ASUS))
d2337 2
a2338 1
	else if (!strcmp(dev, ACPI_DEV_IBM) ||
@


1.236
log
@tiny little oops in untested hibernate block
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.235 2012/07/09 15:19:15 deraadt Exp $ */
d2509 2
@


1.235
log
@clean up ioctl() case statements
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.234 2012/07/09 15:04:12 deraadt Exp $ */
a2518 1
		}
@


1.234
log
@acpi_disable_onegpe() is not used; ok pirofti
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.233 2012/05/24 19:59:22 kettenis Exp $ */
d2502 1
a2502 3
		} else {
			acpi_addtask(sc, acpi_sleep_task, sc, ACPI_STATE_S3);
			acpi_wakeup(sc);
d2504 2
d2511 8
a2518 8
		} else {
			if (get_hibernate_io_function() == NULL) {
				error = EOPNOTSUPP;
			} else {
				acpi_addtask(sc, acpi_sleep_task, sc,
					ACPI_STATE_S4);
				acpi_wakeup(sc);
			}
@


1.233
log
@If _MIN > _MAX consider a WordBus resource to be invalid.  Fixes a panic on
the IBM x3550-M4.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.232 2012/03/29 06:58:10 mlarkin Exp $ */
a144 1
void	acpi_disable_onegpe(struct acpi_softc *, int);
a1633 16
	splx(s);
}

void
acpi_disable_onegpe(struct acpi_softc *sc, int gpe)
{
	uint8_t mask, en;
	int s;

	/* Read enabled register */
	s = spltty();
	mask = (1L << (gpe & 7));
	en = acpi_read_pmreg(sc, ACPIREG_GPE_EN, gpe>>3);
	dnprintf(50, "disabling GPE %.2x (current: %sabled) %.2x\n",
	    gpe, (en & mask) ? "en" : "dis", en);
	acpi_write_pmreg(sc, ACPIREG_GPE_EN, gpe>>3, en & ~mask);
@


1.232
log
@

Missing #ifdef in previous diff
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.231 2012/03/29 06:57:02 mlarkin Exp $ */
d406 4
a409 1
	if (typ == LR_WORD && crs->lr_word.type == 2)
d411 1
@


1.231
log
@

Prevent hibernation attempts on machines with unsupported disk controllers.
The same check is also performed later in the hibernate sequence, but by
then it's too late to cleanly unwind (presently).

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.230 2012/03/26 20:32:50 deraadt Exp $ */
d33 2
d36 1
@


1.230
log
@simplify conditionals in acpi_sleep_state()
ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.228 2011/09/20 14:06:26 deraadt Exp $ */
d33 1
d2522 7
a2528 2
			acpi_addtask(sc, acpi_sleep_task, sc, ACPI_STATE_S4);
			acpi_wakeup(sc);
@


1.229
log
@hook in the hibernate request code; half of this diff is from mlarkin
ok mlarkin
@
text
@a1839 3
		return (0);
	case ACPI_STATE_S5:
		break;
d1842 2
a1843 5
	case ACPI_STATE_S3:
	case ACPI_STATE_S4:
		if (sc->sc_sleeptype[state].slp_typa == -1 ||
		    sc->sc_sleeptype[state].slp_typb == -1)
			return (EOPNOTSUPP);
d1846 4
d1853 1
a1853 4
	if (state != ACPI_STATE_S1)
		ret = acpi_sleep_machdep(sc, state);
	else
		ret = acpi_enter_sleep_state(sc, state);
d1856 1
a1856 2
	if (state == ACPI_STATE_S3 || state == ACPI_STATE_S4)
		acpi_resume(sc, state);
@


1.228
log
@Very early in suspend while the clock is still ticking realtime,
save the clock back to the rtc.  The zaurus already did this.
ok phessler miod kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.227 2011/07/02 22:20:07 nicm Exp $ */
d32 1
d99 1
a1840 2
	case ACPI_STATE_S4:
		return (EOPNOTSUPP);
d1846 1
d1861 1
a1861 1
	if (state == ACPI_STATE_S3)
d1956 3
d2066 3
d2070 1
a2070 1
	if (state == ACPI_STATE_S3)
d2074 2
a2075 1
	resettodr();
d2083 5
a2087 1
	if (state == ACPI_STATE_S3)
d2522 10
@


1.227
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.226 2011/06/24 19:47:49 naddy Exp $ */
d2066 2
@


1.226
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.225 2011/06/16 23:02:11 pirofti Exp $ */
d2635 1
a2635 1
		return (1);
d2670 1
a2670 1
	return (1);
@


1.225
log
@Import acpitoshiba driver.

This is originally written by Hiroyuki Aizu, ported and integrated
in our tree by Javier Vazquez <javama4 AT gmail> with tweaks and
suggestions by me.

Import prodded by deraadt@@ and the lack of testers on tech@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.224 2011/04/27 20:55:42 jcs Exp $ */
d1455 6
a1460 2
	/* XXX put a knob in front of this */
	psignal(initproc, SIGUSR2);
@


1.224
log
@attach acpithinkpad to newer lenovo models like the x120e

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.223 2011/04/22 18:22:01 jordan Exp $ */
d96 1
d785 2
a786 2
	/* attach video only if this is not a stinkpad */
	if (!acpi_thinkpad_enabled)
d2338 7
@


1.223
log
@Fix uninitialzied variables and formatting strings (-Wxxx errors)
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.222 2011/01/02 04:56:57 jordan Exp $ */
d2331 2
a2332 1
	else if (!strcmp(dev, ACPI_DEV_THINKPAD)) {
@


1.222
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.221 2010/10/31 21:52:46 guenther Exp $ */
d710 1
a710 1
		printf(" %.4s", entry->q_table);
@


1.221
log
@Revert last commit: it breaks resume on Thinkpads
"then please back it out" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.219 2010/10/07 21:17:11 jordan Exp $ */
d89 4
d1211 48
d1401 76
d1497 2
d1528 2
a1529 1
			sc->sc_powerbtn = 1;
d1538 2
a1539 1
			sc->sc_sleepbtn = 1;
a2151 1
	u_int32_t gpe;
d2199 3
a2201 71
		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			struct gpe_block *pgpe = &sc->gpe_table[gpe];

			if (pgpe->active) {
				pgpe->active = 0;
				dnprintf(50, "softgpe: %.2x\n", gpe);
				if (pgpe->handler)
					pgpe->handler(sc, gpe, pgpe->arg);
			}
		}
		if (sc->sc_powerbtn) {
			uint16_t en;

			sc->sc_powerbtn = 0;
			dnprintf(1,"power button pressed\n");
			sc->sc_powerdown = 1;

			/* Reset the latch and re-enable the GPE */
			s = spltty();
			en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
			acpi_write_pmreg(sc, ACPIREG_PM1_EN,  0,
			    en | ACPI_PM1_PWRBTN_EN);
			splx(s);

		}
		if (sc->sc_sleepbtn) {
			uint16_t en;

			sc->sc_sleepbtn = 0;
			dnprintf(1,"sleep button pressed\n");
			aml_notify_dev(ACPI_DEV_SBD, 0x80);

			/* Reset the latch and re-enable the GPE */
			s = spltty();
			en = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
			acpi_write_pmreg(sc, ACPIREG_PM1_EN,  0,
			    en | ACPI_PM1_SLPBTN_EN);
			splx(s);
		}

		/* handle polling here to keep code non-concurrent*/
		if (sc->sc_poll) {
			sc->sc_poll = 0;
			acpi_poll_notify();
		}

		if (sc->sc_powerdown) {
			sc->sc_powerdown = 0;

			/* XXX put a knob in front of this */
			psignal(initproc, SIGUSR2);
		}

		if (sc->sc_sleepmode) {
			struct acpi_ac *ac;
			struct acpi_bat *bat;
			int sleepmode = sc->sc_sleepmode;

			sc->sc_sleepmode = 0;
			acpi_sleep_state(sc, sleepmode);

			/* AC and battery information needs refreshing */
			SLIST_FOREACH(ac, &sc->sc_ac, aac_link)
				aml_notify(ac->aac_softc->sc_devnode,
				    0x80);
			SLIST_FOREACH(bat, &sc->sc_bat, aba_link)
				aml_notify(bat->aba_softc->sc_devnode,
				    0x80);

			continue;
		}
d2491 1
a2491 1
			sc->sc_sleepmode = ACPI_STATE_S3;
@


1.220
log
@Add task queue for ACPI gpe and notify handlers
This fixes eject on Dell Latitude dock and an issue on the Dell Mini
battery update.
ok deraadt
@
text
@a88 2
void 	acpi_gpe_task(void *, int);

a1206 48
/* ACPI Workqueue support */
SIMPLEQ_HEAD(,acpi_taskq) acpi_taskq =
    SIMPLEQ_HEAD_INITIALIZER(acpi_taskq);

void
acpi_addtask(struct acpi_softc *sc, void (*handler)(void *, int), 
    void *arg0, int arg1)
{
	struct acpi_taskq *wq;
	int s;

	wq = malloc(sizeof(*wq), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (wq == NULL)
		return;
	wq->handler = handler;
	wq->arg0 = arg0;
	wq->arg1 = arg1;
	
	s = spltty();
	SIMPLEQ_INSERT_TAIL(&acpi_taskq, wq, next);
	splx(s);
}

int
acpi_dotask(struct acpi_softc *sc)
{
	struct acpi_taskq *wq;
	int s;

	s = spltty();
	if (SIMPLEQ_EMPTY(&acpi_taskq)) {
		splx(s);

		/* we don't have anything to do */
		return (0);
	}
	wq = SIMPLEQ_FIRST(&acpi_taskq);
	SIMPLEQ_REMOVE_HEAD(&acpi_taskq, next);
	splx(s);

	wq->handler(wq->arg0, wq->arg1);

	free(wq, M_DEVBUF);

	/* We did something */
	return (1);	
}

a1348 13
void
acpi_gpe_task(void *arg0, int gpe)
{
	struct acpi_softc *sc = acpi_softc;
	struct gpe_block *pgpe = &sc->gpe_table[gpe];

	dnprintf(10, "handle gpe: %x\n", gpe);
	if (pgpe->handler && pgpe->active) {
		pgpe->active = 0;
		pgpe->handler(sc, gpe, pgpe->arg);
	}
}

a1368 2
					dnprintf(10, "queue gpe: %x\n", idx+jdx);
					acpi_addtask(sc, acpi_gpe_task, NULL, idx+jdx);
d2020 1
d2068 2
a2069 3
		/* Run ACPI taskqueue */
		while(acpi_dotask(acpi_softc))
			;
d2071 7
@


1.219
log
@Create separate functions for enabling wake and runtime gpes.
Remove old suspend/resume gpewalk function
ok deraadt, mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.216 2010/10/05 16:17:55 deraadt Exp $ */
d89 2
d1209 48
d1399 13
d1432 2
a2084 1
	u_int32_t gpe;
d2132 3
a2134 2
		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			struct gpe_block *pgpe = &sc->gpe_table[gpe];
a2135 7
			if (pgpe->active) {
				pgpe->active = 0;
				dnprintf(50, "softgpe: %.2x\n", gpe);
				if (pgpe->handler)
					pgpe->handler(sc, gpe, pgpe->arg);
			}
		}
@


1.218
log
@split acpi_enable_onegpe to separate enable/disable functions
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.217 2010/10/05 16:59:02 jordan Exp $ */
a129 1
void	acpi_susp_resume_gpewalk(struct acpi_softc *, int, int);
d137 2
d1507 45
a1693 46
void
acpi_susp_resume_gpewalk(struct acpi_softc *sc, int state,
    int wake_gpe_state)
{
	struct acpi_wakeq *wentry;
	u_int32_t gpe;

	/* Clear GPE status */
	acpi_disable_allgpes(sc);
	SIMPLEQ_FOREACH(wentry, &sc->sc_wakedevs, q_next) {
		dnprintf(10, "%.4s(S%d) gpe %.2x\n", wentry->q_node->name,
		    wentry->q_state,
		    wentry->q_gpe);

		if (state <= wentry->q_state) {
			if (wake_gpe_state)
				acpi_enable_onegpe(sc, wentry->q_gpe);
			else
				acpi_disable_onegpe(sc, wentry->q_gpe);
		}
	}

	/* If we are resuming (disabling wake GPEs), enable other GPEs */

	if (wake_gpe_state == 0) {
		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			if (sc->gpe_table[gpe].handler)
				acpi_enable_onegpe(sc, gpe);
		}
	}
}

void
acpi_disable_allgpes(struct acpi_softc *sc)
{
	int idx, s;

	/* Clear GPE status */
	s = spltty();
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		acpi_write_pmreg(sc, ACPIREG_GPE_EN, idx >> 3, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE_STS, idx >> 3, -1);
	}
	splx(s);
}

d1814 3
a1816 2
	/* Disable wake GPEs */
	acpi_susp_resume_gpewalk(sc, state, 0);
d1977 2
a1978 1
	acpi_susp_resume_gpewalk(sc, state, 1);
d2008 2
a2009 1
	acpi_susp_resume_gpewalk(acpi_softc, ACPI_STATE_S5, 1);
d2050 1
a2050 4
		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			if (sc->gpe_table[gpe].handler)
				acpi_enable_onegpe(sc, gpe);
		}
@


1.217
log
@Added acpi_disable_allgpes function to clear GPE status
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.216 2010/10/05 16:17:55 deraadt Exp $ */
d134 2
a135 1
void	acpi_enable_onegpe(struct acpi_softc *, int, int);
d1475 1
a1475 1
acpi_enable_onegpe(struct acpi_softc *sc, int gpe, int enable)
d1484 19
a1502 7
	dnprintf(50, "%sabling GPE %.2x (current: %sabled) %.2x\n",
	    enable ? "en" : "dis", gpe, (en & mask) ? "en" : "dis", en);
	if (enable)
		en |= mask;
	else
		en &= ~mask;
	acpi_write_pmreg(sc, ACPIREG_GPE_EN, gpe>>3, en);
d1662 6
a1667 3
		if (state <= wentry->q_state)
			acpi_enable_onegpe(sc, wentry->q_gpe,
			    wake_gpe_state);
d1675 1
a1675 1
				acpi_enable_onegpe(sc, gpe, 1);
d2049 1
a2049 1
				acpi_enable_onegpe(sc, gpe, 1);
@


1.216
log
@clean up acpi_softc use more
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.215 2010/10/05 16:14:59 deraadt Exp $ */
d137 2
d1605 1
a1605 4
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		acpi_write_pmreg(sc, ACPIREG_GPE_EN,  idx>>3, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE_STS, idx>>3, -1);
	}
a1639 1
	int idx;
d1643 1
a1643 5
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		acpi_write_pmreg(sc, ACPIREG_GPE_EN,  idx>>3, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE_STS, idx>>3, -1);
	}

d1662 14
@


1.215
log
@delete a bit of #if 0 code
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.214 2010/10/05 16:14:37 deraadt Exp $ */
a1314 1
	struct acpi_fadt	*fadt;
d1318 1
a1318 2

	fadt = sc->sc_fadt;
@


1.214
log
@hide use of our global acpi_softc pointer a bit better
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.213 2010/09/29 19:45:34 deraadt Exp $ */
a1580 1
#if 1
a1583 7
#else
	SIMPLEQ_FOREACH(pgpe, &sc->sc_gpes, gpe_link) {
		if (gpe >= pgpe->start && gpe <= (pgpe->start+7))
			return &pgpe->table[gpe & 7];
	}
	return NULL;
#endif
@


1.213
log
@grab the acpi thread lock very early in acpi thread startup; not that it
is likely that anyone will race us... but why be careless.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.212 2010/08/31 17:13:46 deraadt Exp $ */
d1318 1
d1320 1
a1320 1
	fadt = acpi_softc->sc_fadt;
d1326 1
a1326 1
	if (acpi_softc->sc_revision <= 1 ||
d1340 1
a1340 1
	acpi_gasio(acpi_softc, ACPI_IOWRITE,
@


1.212
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.211 2010/08/29 18:41:12 jasper Exp $ */
d2005 2
a2036 2

	rw_enter_write(&sc->sc_lck);
@


1.211
log
@- add a check for FWRITE here too.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.210 2010/08/27 20:31:55 kettenis Exp $ */
d1915 1
@


1.210
log
@Make PCI Power Management optional, and only enable it when acpi(4) attaches.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.209 2010/08/08 20:45:18 kettenis Exp $ */
d2409 6
a2414 2
		sc->sc_sleepmode = ACPI_STATE_S3;
		acpi_wakeup(sc);
@


1.209
log
@Close race between the acpi thread and wscons ioctls running in process
context.  We might rip this out post-release and replace it with a solution
that serializes things in a more obvious way.

ok deraadt@@, miod@@ and "those crazy texans who ok anything"
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.208 2010/08/08 02:23:20 deraadt Exp $ */
d799 3
@


1.208
log
@Report the acpi sleep states when on a RAMDISK; ok krw
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.207 2010/08/07 17:12:16 kettenis Exp $ */
d556 2
d2032 2
d2038 1
d2040 1
@


1.207
log
@Enforce acpi register access rescrictions.

ok mlarkin@@, deraadt@@, tested by marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.206 2010/08/07 15:48:26 deraadt Exp $ */
d87 2
a100 1
void	acpi_init_states(struct acpi_softc *);
a658 1
#ifndef SMALL_KERNEL
d662 1
d1175 23
a1626 23
}

void
acpi_init_states(struct acpi_softc *sc)
{
	struct aml_value res;
	char name[8];
	int i;

	printf("\n%s: sleep states", DEVNAME(sc));
	for (i = ACPI_STATE_S0; i <= ACPI_STATE_S5; i++) {
		snprintf(name, sizeof(name), "_S%d_", i);
		sc->sc_sleeptype[i].slp_typa = -1;
		sc->sc_sleeptype[i].slp_typb = -1;
		if (aml_evalname(sc, &aml_root, name, 0, NULL, &res) == 0) {
			if (res.type == AML_OBJTYPE_PACKAGE) {
				sc->sc_sleeptype[i].slp_typa = aml_val2int(res.v_package[0]);
				sc->sc_sleeptype[i].slp_typb = aml_val2int(res.v_package[1]);
				printf(" S%d", i);
			}
			aml_freevalue(&res);
		}
	}
@


1.206
log
@upon resume, notify all the acpiac and acpibat drivers to update
their status.  some laptops do not do this automatically.
ok kettenis canacar
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.205 2010/08/06 21:12:27 marco Exp $ */
d936 1
a936 1
	bus_size_t size, __size;
a938 1
	__size = 0;
a950 1
		__size = 1;
a957 1
		__size = 1;
d973 2
a974 4
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;
d999 1
a999 1
	bus_size_t size, __size;
a1000 1
	__size = 0;
a1015 1
		__size = 1;
a1023 1
		__size = 1;
d1039 3
a1041 4
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;
d1063 1
a1063 1
	bus_size_t size;
d1069 1
d1073 1
a1073 1
			size = 1;
d1081 1
d1091 1
d1098 1
d1108 1
d1114 1
d1122 1
d1130 1
d1146 1
d1169 1
@


1.205
log
@Always call _PSW on _LID devices that support it to enable lid open to
resume the machine.  Conversely disable it when the machine wakes up.

Tested by several ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.204 2010/08/06 14:20:14 deraadt Exp $ */
d2095 2
d2101 9
@


1.204
log
@As part of a revamp of the PM1/GPE code, I write this diff to look for
unmanaged EN & STS bits in the PM1 register at interrupt time and report
them.  As a side effect this splits the STS acknowledgement into two writes
(for power, and sleep) instead of one. The printf that is added (to spot
unmanaged STS bits) has not yet been triggered as far as we know.

Before the "write to PM1 registers at the right offset" diff went in, this
was not neccessary.  But newer thinkpads do not have a working soft power
button without this diff.

We have no idea why.
ok mlarkin kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.203 2010/08/05 17:26:57 deraadt Exp $ */
d1812 3
d1856 3
d1927 3
@


1.203
log
@PM1 power button events were generating 'fake events' to acpibtn PWRB,
but if there is no such device these were being tossed.  Instead, arrange
for all power button handlers to flag a softc variable which is processed
by the thread; so that one place will know to request a powerdown (psignal
to init)
ok marco mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.202 2010/08/05 17:00:50 deraadt Exp $ */
d1357 1
a1357 1
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en & ~sts);
d1359 3
d1364 1
d1368 3
d1373 1
d1375 6
@


1.202
log
@rename a variable which is annoyingly poorly named
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.201 2010/08/05 16:57:03 mlarkin Exp $ */
d2033 1
a2033 1
			aml_notify_dev(ACPI_DEV_PBD, 0x80);
d2062 7
@


1.201
log
@

Write to the correct offset for various ACPI pmreg registers. Writing to
the correct register does properly clear the wake status bits and fixed
event bits, which allows some machines to have more than 1 suspend cycle.

bug spotted by deraadt@@

tested by deraadt@@ and myself on a half-dozen machines and others on
hackers@@

ok deraadt@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.200 2010/08/05 16:13:03 deraadt Exp $ */
d1980 1
a1980 1
		int16_t flag;
d1990 6
a1995 8
		flag = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
		if (!(sc->sc_fadt->flags & FADT_PWR_BUTTON)) {
			flag |= ACPI_PM1_PWRBTN_EN;
		}
		if (!(sc->sc_fadt->flags & FADT_SLP_BUTTON)) {
			flag |= ACPI_PM1_SLPBTN_EN;
		}
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, flag);
@


1.200
log
@Fix the power button.  The pm1 register is 16 bits in size.
My mistake, a while back.
tested by krw
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.199 2010/08/04 17:35:39 kettenis Exp $ */
d1700 1
a1700 1
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 1, ACPI_PM1_WAK_STS);
d1703 1
a1703 1
	acpi_write_pmreg(sc, ACPIREG_PM2_CNT, 1, ACPI_PM2_ARB_DIS);
d1757 1
a1757 1
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 1,
d1926 1
a1926 1
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 1,
@


1.199
log
@Print supported sleep states.

ok marco@@, phessler@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.198 2010/08/03 16:32:40 mlarkin Exp $ */
d1321 1
a1321 1
	u_int8_t sts, en;
d2031 1
a2031 1
			uint8_t en;
d2046 1
a2046 1
			uint8_t en;
@


1.198
log
@

Use the proper flag for re-enabling certain hardware events (power btn,
sleep btn). The (incorrect) flag prevoiously used coincidentally had the
same value, so this shouldn't cause any different behavior than before.

tested on a variety of machines (i386, amd64, sp, mp) - no behavioral
change seen

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.197 2010/07/28 14:39:43 marco Exp $ */
d1597 1
d1606 1
@


1.197
log
@Make all gasio failures look and behave the same.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.196 2010/07/28 07:32:16 mlarkin Exp $ */
d2039 1
a2039 1
			    en | ACPI_PM1_PWRBTN_STS);
d2054 1
a2054 1
			    en | ACPI_PM1_SLPBTN_STS);
@


1.196
log
@

Delay a little longer on suspend before giving up. Fixes machines that
sometimes don't suspend because the sleep transition takes too long
(symptoms like failing to sleep but the backlight stays on).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.195 2010/07/27 23:33:21 deraadt Exp $ */
d186 1
a186 1
			printf("unable to map iospace\n");
d209 3
a211 2
					printf("rdio: invalid size %d\n", access_size);
					break;
d232 3
a234 2
					printf("wrio: invalid size %d\n", access_size);
					break;
d276 1
d278 4
a281 2
		if (sc->sc_ec == NULL)
			break;
@


1.195
log
@remove XXX; EC can now be attached early when needed; ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.194 2010/07/27 22:58:48 deraadt Exp $ */
d1731 1
a1731 1
		DELAY(10);
@


1.194
log
@more brackets feels good
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.193 2010/07/27 22:57:48 deraadt Exp $ */
a751 1
	 /* XXX EC needs to be attached first on some systems */
@


1.193
log
@XXX annotate a block in acpi_enter_sleep_state() that is pretty worrying
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.192 2010/07/27 22:11:44 deraadt Exp $ */
d1729 2
a1730 2
		if (rega & ACPI_PM1_WAK_STS ||
		    regb & ACPI_PM1_WAK_STS)
@


1.192
log
@horrific indentation that nearly made me puke
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.191 2010/07/27 16:20:17 mlarkin Exp $ */
d1719 3
@


1.191
log
@

Set the sleeping indicator light on machines that support it, in case SMI
doesn't do it for us. Shows the 'moon' LED on older Thinkpads when
sleeping.

Tested on T43p, W500, T510 by me and on X61s by deraadt@@.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.190 2010/07/27 05:17:36 jordan Exp $ */
d1503 1
a1503 1
	if (wq == NULL) {
a1504 1
	}
d1518 6
a1523 7
	if (wq->q_wakepkg->type == AML_OBJTYPE_PACKAGE && wq->q_wakepkg->length >= 2) {
	  if (wq->q_wakepkg->v_package[0]->type == AML_OBJTYPE_INTEGER) {
	    wq->q_gpe = wq->q_wakepkg->v_package[0]->v_integer;
	  }
	  if (wq->q_wakepkg->v_package[1]->type == AML_OBJTYPE_INTEGER) {
	    wq->q_state = wq->q_wakepkg->v_package[1]->v_integer;
	  }
@


1.190
log
@Early initialization of acpiec if ECDT table exists
Fixes hang when booting thinkpads while docked
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.189 2010/07/26 17:25:44 deraadt Exp $ */
d1900 7
@


1.189
log
@remove merge error which was commited
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.188 2010/07/26 11:29:23 pirofti Exp $ */
d2128 4
@


1.188
log
@Add support for Sony ACPI hotkeys via a new driver: acpisony(4).

Currently it only works for the suspend button and tries to do right for
the brightness events, but I haven't found a Sony laptop that like to do
right so far.

In the future I want to make the brightness keys work on all Sony's and
also add support for the zoom hotkeys and whatever other funky keys I can
find on those things.

Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.187 2010/07/22 14:19:47 deraadt Exp $ */
a2507 2

>>>>>>> 1.187
@


1.187
log
@pretty large cleanup of SMALL_KERNEL
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.186 2010/07/21 19:42:05 deraadt Exp $ */
d111 1
d766 3
d2237 18
d2509 1
@


1.186
log
@in the acpi GPE handler, late ack level interrupts not edge interrupts.
Duh.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.185 2010/07/21 15:01:52 deraadt Exp $ */
d61 1
a61 1
int acpi_debug = 16;
d63 3
a65 5
int acpi_enabled;
int acpi_poll_enabled;
int acpi_hasprocfvs;
int acpi_thinkpad_enabled;
int acpi_saved_spl;
a68 3
void	acpi_thread(void *);
void	acpi_create_thread(void *);

a69 1

a73 1
void	acpi_handle_suspend_failure(struct acpi_softc *);
d77 5
a81 5
int	acpi_founddock(struct aml_node *, void *);
int	acpi_foundpss(struct aml_node *, void *);
int	acpi_foundhid(struct aml_node *, void *);
int	acpi_foundec(struct aml_node *, void *);
int	acpi_foundtmp(struct aml_node *, void *);
a82 3
int	acpi_foundprw(struct aml_node *, void *);
int	acpi_foundvideo(struct aml_node *, void *);
int	acpi_inidev(struct aml_node *, void *);
d84 2
a85 1
int	acpi_loadtables(struct acpi_softc *, struct acpi_rsdp *);
d87 1
a87 3
void	acpi_init_states(struct acpi_softc *);
void	acpi_init_gpes(struct acpi_softc *);
void	acpi_init_pm(struct acpi_softc *);
d89 3
a91 2
int acpi_foundide(struct aml_node *node, void *arg);
int acpiide_notify(struct aml_node *, int, void *);
a92 1
int	_acpi_matchhids(const char *, const char *[]);
d96 15
a110 2
struct acpi_q *acpi_maptable(struct acpi_softc *, paddr_t, const char *,
	    const char *, const char *, int);
d112 7
a118 2
void  wdcattach(struct channel_softc *);
int   wdcdetach(struct channel_softc *, int);
d120 1
a120 2
struct idechnl
{
d122 3
a124 3
	int64_t 	addr;
	int64_t 	chnl;
	int64_t 	sta;
a126 5
int is_ejectable_bay(struct aml_node *node);
int is_ata(struct aml_node *node);
int is_ejectable(struct aml_node *node);

#ifndef SMALL_KERNEL
d129 1
a129 5
#endif /* SMALL_KERNEL */

#ifndef SMALL_KERNEL
int acpi_add_device(struct aml_node *node, void *arg);
#endif /* SMALL_KERNEL */
d131 1
d135 1
a135 1
struct gpe_block *acpi_find_gpe(struct acpi_softc *, int);
a139 8
/* XXX do we need this? */
void	acpi_filtdetach(struct knote *);
int	acpi_filtread(struct knote *, long);

struct filterops acpiread_filtops = {
	1, NULL, acpi_filtdetach, acpi_filtread
};

a149 1
int acpi_evindex;
a153 2
#define pch(x) (((x)>=' ' && (x)<='z') ? (x) : ' ')

a355 108
is_ata(struct aml_node *node)
{
	return (aml_searchname(node, "_GTM") != NULL ||
	    aml_searchname(node, "_GTF") != NULL ||
	    aml_searchname(node, "_STM") != NULL ||
	    aml_searchname(node, "_SDD") != NULL);
}

int
is_ejectable(struct aml_node *node)
{
	return (aml_searchname(node, "_EJ0") != NULL);
}

int
is_ejectable_bay(struct aml_node *node)
{
	return ((is_ata(node) || is_ata(node->parent)) && is_ejectable(node));
}

int
acpiide_notify(struct aml_node *node, int ntype, void *arg)
{
	struct idechnl 		*ide = arg;
	struct acpi_softc 	*sc = ide->sc;
	struct pciide_softc 	*wsc;
	struct device 		*dev;
	int 			b,d,f;
	int64_t 		sta;

	if (aml_evalinteger(sc, node, "_STA", 0, NULL, &sta) != 0)
		return (0);

	dnprintf(10, "IDE notify! %s %d status:%llx\n", aml_nodename(node),
	    ntype, sta);

	/* Walk device list looking for IDE device match */
	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		if (strcmp(dev->dv_cfdata->cf_driver->cd_name, "pciide"))
			continue;

		wsc = (struct pciide_softc *)dev;
		pci_decompose_tag(NULL, wsc->sc_tag, &b, &d, &f);
		if (b != ACPI_PCI_BUS(ide->addr) ||
		    d != ACPI_PCI_DEV(ide->addr) ||
		    f != ACPI_PCI_FN(ide->addr))
			continue;
		dnprintf(10, "Found pciide: %s %x.%x.%x channel:%llx\n",
		    dev->dv_xname, b,d,f, ide->chnl);

		if (sta == 0 && ide->sta)
			wdcdetach(
			    &wsc->pciide_channels[ide->chnl].wdc_channel, 0);
		else if (sta && !ide->sta)
			wdcattach(
			    &wsc->pciide_channels[ide->chnl].wdc_channel);
		ide->sta = sta;
	}
	return (0);
}

int
acpi_foundide(struct aml_node *node, void *arg)
{
	struct acpi_softc 	*sc = arg;
	struct aml_node 	*pp;
	struct idechnl 		*ide;
	union amlpci_t 		pi;
	int 			lvl;

	/* Check if this is an ejectable bay */
	if (!is_ejectable_bay(node))
		return (0);

	ide = malloc(sizeof(struct idechnl), M_DEVBUF, M_NOWAIT | M_ZERO);
	ide->sc = sc;

	/* GTM/GTF can be at 2/3 levels:  pciX.ideX.channelX[.driveX] */
	lvl = 0;
	for (pp=node->parent; pp; pp=pp->parent) {
		lvl++;
		if (aml_searchname(pp, "_HID"))
			break;
	}

	/* Get PCI address and channel */
	if (lvl == 3) {
		aml_evalinteger(sc, node->parent, "_ADR", 0, NULL,
		    &ide->chnl);
		aml_rdpciaddr(node->parent->parent, &pi);
		ide->addr = pi.addr;
	} else if (lvl == 4) {
		aml_evalinteger(sc, node->parent->parent, "_ADR", 0, NULL,
		    &ide->chnl);
		aml_rdpciaddr(node->parent->parent->parent, &pi);
		ide->addr = pi.addr;
	}
	dnprintf(10, "%s %llx channel:%llx\n",
	    aml_nodename(node), ide->addr, ide->chnl);

	aml_evalinteger(sc, node, "_STA", 0, NULL, &ide->sta);
	dnprintf(10, "Got Initial STA: %llx\n", ide->sta);

	aml_register_notify(node, "acpiide", acpiide_notify, ide, 0);
	return (0);
}

int
d400 1
d414 1
a616 2
	acpi_enabled = 1;

d669 2
a705 1

d822 2
a823 1
acpi_maptable(struct acpi_softc *sc, paddr_t addr, const char *sig, const char *oem, const char *tbl, int flag)
d897 1
a897 1
		
d923 1
d925 1
a925 1
acpiopen(dev_t dev, int flag, int mode, struct proc *p)
d927 3
a929 4
	int error = 0;
#ifndef SMALL_KERNEL
	struct acpi_softc *sc;
	int s;
d931 18
a948 14
	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		if (!(flag & FWRITE)) {
			error = EINVAL;
			break;
		}
		if (sc->sc_flags & SCFLAG_OWRITE) {
			error = EBUSY;
			break;
a949 1
		sc->sc_flags |= SCFLAG_OWRITE;
d951 7
a957 4
	case APMDEV_NORMAL:
		if (!(flag & FREAD) || (flag & FWRITE)) {
			error = EINVAL;
			break;
a958 4
		sc->sc_flags |= SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
a960 6
	splx(s);
#else
	error = ENXIO;
#endif
	return (error);
}
d962 2
a963 7
int
acpiclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int error = 0;
#ifndef SMALL_KERNEL
	struct acpi_softc *sc;
	int s;
d965 5
a969 225
	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	switch (APMDEV(dev)) {
	case APMDEV_CTL:
		sc->sc_flags &= ~SCFLAG_OWRITE;
		break;
	case APMDEV_NORMAL:
		sc->sc_flags &= ~SCFLAG_OREAD;
		break;
	default:
		error = ENXIO;
		break;
	}
	splx(s);
#else
	error = ENXIO;
#endif
	return (error);
}

int
acpiioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error = 0;
#ifndef SMALL_KERNEL
	struct acpi_softc *sc;
	struct acpi_ac *ac;
	struct acpi_bat *bat;
	struct apm_power_info *pi = (struct apm_power_info *)data;
	int bats;
	unsigned int remaining, rem, minutes, rate;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	s = spltty();
	/* fake APM */
	switch (cmd) {
	case APM_IOC_SUSPEND:
	case APM_IOC_STANDBY:
		sc->sc_sleepmode = ACPI_STATE_S3;
		acpi_wakeup(sc);
		break;
	case APM_IOC_GETPOWER:
		/* A/C */
		pi->ac_state = APM_AC_UNKNOWN;
		SLIST_FOREACH(ac, &sc->sc_ac, aac_link) {
			if (ac->aac_softc->sc_ac_stat == PSR_ONLINE)
				pi->ac_state = APM_AC_ON;
			else if (ac->aac_softc->sc_ac_stat == PSR_OFFLINE)
				if (pi->ac_state == APM_AC_UNKNOWN)
					pi->ac_state = APM_AC_OFF;
		}

		/* battery */
		pi->battery_state = APM_BATT_UNKNOWN;
		pi->battery_life = 0;
		pi->minutes_left = 0;
		bats = 0;
		remaining = rem = 0;
		minutes = 0;
		rate = 0;
		SLIST_FOREACH(bat, &sc->sc_bat, aba_link) {
			if (bat->aba_softc->sc_bat_present == 0)
				continue;

			if (bat->aba_softc->sc_bif.bif_last_capacity == 0)
				continue;

			bats++;
			rem = (bat->aba_softc->sc_bst.bst_capacity * 100) /
			    bat->aba_softc->sc_bif.bif_last_capacity;
			if (rem > 100)
				rem = 100;
			remaining += rem;

			if (bat->aba_softc->sc_bst.bst_rate == BST_UNKNOWN)
				continue;
			else if (bat->aba_softc->sc_bst.bst_rate > 1)
				rate = bat->aba_softc->sc_bst.bst_rate;

			minutes += bat->aba_softc->sc_bst.bst_capacity;
		}

		if (bats == 0) {
			pi->battery_state = APM_BATTERY_ABSENT;
			pi->battery_life = 0;
			pi->minutes_left = (unsigned int)-1;
			break;
		}

		if (pi->ac_state == APM_AC_ON || rate == 0)
			pi->minutes_left = (unsigned int)-1;
		else
			pi->minutes_left = 60 * minutes / rate;

		/* running on battery */
		pi->battery_life = remaining / bats;
		if (pi->battery_life > 50)
			pi->battery_state = APM_BATT_HIGH;
		else if (pi->battery_life > 25)
			pi->battery_state = APM_BATT_LOW;
		else
			pi->battery_state = APM_BATT_CRITICAL;

		break;

	default:
		error = ENOTTY;
	}

	splx(s);
#else
	error = ENXIO;
#endif /* SMALL_KERNEL */
	return (error);
}

void
acpi_filtdetach(struct knote *kn)
{
#ifndef SMALL_KERNEL
	struct acpi_softc *sc = kn->kn_hook;
	int s;

	s = spltty();
	SLIST_REMOVE(sc->sc_note, kn, knote, kn_selnext);
	splx(s);
#endif
}

int
acpi_filtread(struct knote *kn, long hint)
{
#ifndef SMALL_KERNEL
	/* XXX weird kqueue_scan() semantics */
	if (hint && !kn->kn_data)
		kn->kn_data = hint;
#endif
	return (1);
}

int
acpikqfilter(dev_t dev, struct knote *kn)
{
#ifndef SMALL_KERNEL
	struct acpi_softc *sc;
	int s;

	if (!acpi_cd.cd_ndevs || APMUNIT(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[APMUNIT(dev)]))
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &acpiread_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = sc;

	s = spltty();
	SLIST_INSERT_HEAD(sc->sc_note, kn, kn_selnext);
	splx(s);

	return (0);
#else
	return (1);
#endif
}

/* Read from power management register */
int
acpi_read_pmreg(struct acpi_softc *sc, int reg, int offset)
{
	bus_space_handle_t ioh;
	bus_size_t size, __size;
	int regval;

	__size = 0;
	/* Special cases: 1A/1B blocks can be OR'ed together */
	switch (reg) {
	case ACPIREG_PM1_EN:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_EN, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_EN, offset));
	case ACPIREG_PM1_STS:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_STS, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_STS, offset));
	case ACPIREG_PM1_CNT:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, offset));
	case ACPIREG_GPE_STS:
		__size = 1;
		dnprintf(50, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset,
		    sc->sc_fadt->gpe0_blk_len>>1, sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		__size = 1;
		dnprintf(50, "read GPE_EN   offset: %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	if (reg >= ACPIREG_MAXREG || sc->sc_pmregs[reg].size == 0)
		return (0);

	regval = 0;
	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (__size)
		size = __size;
a1164 1
/* move all stuff that doesn't go on the boot media in here */
d1166 108
a1615 1
#ifndef SMALL_KERNEL
a1648 1
#endif /* ! SMALL_KERNEL */
a1732 1
#ifndef SMALL_KERNEL
a1804 12
#endif /* ! SMALL_KERNEL */

int
acpi_record_event(struct acpi_softc *sc, u_int type)
{
	if ((sc->sc_flags & SCFLAG_OPEN) == 0)
		return (1);

	acpi_evindex++;
	KNOTE(sc->sc_note, APM_EVENT_COMPOSE(type, acpi_evindex));
	return (0);
}
a1815 1

a1880 1
#ifndef SMALL_KERNEL
a1886 1
#endif /* ! SMALL_KERNEL */
a1946 3

extern int aml_busy;

d1952 1
d1998 1
a1998 1
			printf("skipping %d\n", aml_busy);
a2047 1
#ifndef SMALL_KERNEL
a2054 1
#endif /* SMALL_KERNEL */
d2067 1
a2067 1
	    != 0) {
a2069 2
		return;
	}
d2231 256
@


1.185
log
@Merge the edge and level gpe handlers into one (now possible since the
gpe structure tells us whether the gpe is edge or level)
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.184 2010/07/21 05:03:19 deraadt Exp $ */
d1714 1
a1714 1
	if (sc->gpe_table[gpe].edge)
@


1.184
log
@delete #if 0 code we are not going to use; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.183 2010/07/20 21:37:33 deraadt Exp $ */
d135 1
a135 2
int	acpi_gpe_level(struct acpi_softc *, int, void *);
int	acpi_gpe_edge(struct acpi_softc *, int, void *);
d1703 1
a1703 1
acpi_gpe_level(struct acpi_softc *sc, int gpe, void *arg)
d1709 1
a1709 22
	dnprintf(10, "handling Level-sensitive GPE %.2x\n", gpe);
	aml_evalnode(sc, node, 0, NULL, NULL);

	s = spltty();
	mask = (1L << (gpe & 7));
	acpi_write_pmreg(sc, ACPIREG_GPE_STS, gpe>>3, mask);
	en = acpi_read_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3);
	acpi_write_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3, en | mask);
	splx(s);

	return (0);
}

int
acpi_gpe_edge(struct acpi_softc *sc, int gpe, void *arg)
{

	struct aml_node *node = arg;
	uint8_t mask, en;
	int s;

	dnprintf(10, "handling Edge-sensitive GPE %.2x\n", gpe);
d1714 2
d1812 1
a1812 1
			acpi_set_gpehandler(sc, idx, acpi_gpe_level, gpe, 0);
d1818 1
a1818 1
				acpi_set_gpehandler(sc, idx, acpi_gpe_edge, gpe, 1);
@


1.183
log
@make the mask code for acpi_enable_onegpe() match other similar code
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.182 2010/07/20 12:14:10 deraadt Exp $ */
a1556 6
#if 0
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe0_blk, sc->sc_fadt->gpe0_blk_len>>1, 0);
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1,
	    sc->sc_fadt->gpe1_base);
#endif

a1803 92
#if 0
/* New GPE handling code: Create GPE block */
void
acpi_init_gpeblock(struct acpi_softc *sc, int reg, int len, int base)
{
	int i, j;

	if (!reg || !len)
		return;
	for (i = 0; i < len; i++) {
		pgpe = acpi_os_malloc(sizeof(gpeblock));
		if (pgpe == NULL)
			return;

		/* Allocate GPE Handler Block */
		pgpe->start = base + i;
		acpi_bus_space_map(sc->sc_iot, reg+i,     1, 0, &pgpe->sts_ioh);
		acpi_bus_space_map(sc->sc_iot, reg+i+len, 1, 0, &pgpe->en_ioh);
		SIMPLEQ_INSERT_TAIL(&sc->sc_gpes, gpe, gpe_link);

		/* Clear pending GPEs */
		bus_space_write_1(sc->sc_iot, pgpe->sts_ioh, 0, 0xFF);
		bus_space_write_1(sc->sc_iot, pgpe->en_ioh,  0, 0x00);
	}

	/* Search for GPE handlers */
	for (i = 0; i < len*8; i++) {
		char gpestr[32];
		struct aml_node *h;

		snprintf(gpestr, sizeof(gpestr), "\\_GPE._L%.2X", base+i);
		h = aml_searchnode(&aml_root, gpestr);
		if (acpi_set_gpehandler(sc, base+i, acpi_gpe_level, h, 0) != 0) {
			snprintf(gpestr, sizeof(gpestr), "\\_GPE._E%.2X", base+i);
			h = aml_searchnode(&aml_root, gpestr);
			acpi_set_gpehandler(sc, base+i, acpi_gpe_edge, h, 1);
		}
	}
}

/* Process GPE interrupts */
int
acpi_handle_gpes(struct acpi_softc *sc)
{
	uint8_t en, sts;
	int processed, i;

	processed = 0;
	SIMPLEQ_FOREACH(pgpe, &sc->sc_gpes, gpe_link) {
		sts = bus_space_read_1(sc->sc_iot, pgpe->sts_ioh, 0);
		en = bus_space_read_1(sc->sc_iot, pgpe->en_ioh, 0);
		for (i = 0; i< 8 ; i++) {
			if (en & sts & (1L << i)) {
				pgpe->table[i].active = 1;
				processed = 1;
			}
		}
	}
	return processed;
}
#endif

#if 0
void
acpi_add_gpeblock(struct acpi_softc *sc, int reg, int len, int gpe)
{
	int idx, jdx;
	u_int8_t en, sts;

	if (!reg || !len)
		return;
	for (idx = 0; idx < len; idx++) {
		sts = inb(reg + idx);
		en  = inb(reg + len + idx);
		printf("-- gpe %.2x-%.2x : en:%.2x sts:%.2x  %.2x\n",
		    gpe+idx*8, gpe+idx*8+7, en, sts, en&sts);
		for (jdx = 0; jdx < 8; jdx++) {
			char gpestr[32];
			struct aml_node *l, *e;

			if (en & sts & (1L << jdx)) {
				snprintf(gpestr,sizeof(gpestr), "\\_GPE._L%.2X", gpe+idx*8+jdx);
				l = aml_searchname(&aml_root, gpestr);
				snprintf(gpestr,sizeof(gpestr), "\\_GPE._E%.2X", gpe+idx*8+jdx);
				e = aml_searchname(&aml_root, gpestr);
				printf("  GPE %.2x active L%x E%x\n", gpe+idx*8+jdx, l, e);
			}
		}
	}
}
#endif

a1809 6

#if 0
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe0_blk, sc->sc_fadt->gpe0_blk_len>>1, 0);
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1,
	    sc->sc_fadt->gpe1_base);
#endif
@


1.182
log
@Handle the acpi interrupt controller with proper edge/level handling,
wrapped in spltty to avoid racing against the interrupt controller.
Repair the gpe bit masking code while there, and do operations in the
right order
ok kettenis mlarkin, help from jordan at figuring out the order of
operations.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.181 2010/07/20 04:04:00 matthew Exp $ */
d1671 1
a1671 2
	uint8_t mask = (1L << (gpe & 7));
	uint8_t en;
d1676 1
@


1.181
log
@When we're preparing to go to sleep, only call bufq_restart() if other
preparations failed.

ok kettenis@@, thib@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.180 2010/07/19 16:58:12 deraadt Exp $ */
d1554 2
a1555 3
	u_int32_t processed, sts, en, idx, jdx;

	processed = 0;
d1570 1
d1576 11
d1598 3
a1600 3
		acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);
		if (sts & ACPI_PM1_PWRBTN_STS)
d1602 4
a1605 1
		if (sts & ACPI_PM1_SLPBTN_STS)
d1607 1
d1612 1
a1612 2
		sc->sc_threadwaiting = 0;
		wakeup(sc);
d1673 1
d1676 1
d1685 1
d1690 1
a1690 1
    (struct acpi_softc *, int, void *), void *arg, const char *label)
d1701 1
a1701 1
	dnprintf(50, "Adding GPE handler %.2x (%s)\n", gpe, label);
d1704 1
d1713 2
a1714 1
	uint8_t mask;
d1717 3
a1720 2

	aml_evalnode(sc, node, 0, NULL, NULL);
d1722 3
a1724 1
	acpi_write_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3, mask);
d1734 2
a1735 1
	uint8_t mask;
d1738 3
d1742 3
a1744 4

	aml_evalnode(sc, node, 0, NULL, NULL);
	acpi_write_pmreg(sc, ACPIREG_GPE_STS, gpe>>3, mask);
	acpi_write_pmreg(sc, ACPIREG_GPE_EN,  gpe>>3, mask);
d1842 1
a1842 1
		if (acpi_set_gpehandler(sc, base+i, acpi_gpe_level, h, "level") != 0) {
d1845 1
a1845 1
			acpi_set_gpehandler(sc, base+i, acpi_gpe_edge, h, "edge");
d1936 1
a1936 2
			acpi_set_gpehandler(sc, idx, acpi_gpe_level, gpe,
			    "level");
d1942 1
a1942 2
				acpi_set_gpehandler(sc, idx, acpi_gpe_edge, gpe,
				    "edge");
d2339 1
d2356 1
d2365 1
d2375 5
a2379 3
		dnprintf(10, "sleep... %d\n", sc->sc_threadwaiting);
		while (sc->sc_threadwaiting)
			tsleep(sc, PWAIT, "acpi_idle", 0);
d2381 3
a2383 2
		dnprintf(10, "wakeup..\n");
		if (aml_busy)
d2385 1
d2398 2
d2401 2
d2404 6
a2409 1
			aml_notify_dev(ACPI_DEV_PBD, 0x80);
a2410 1
			dnprintf(1,"power button pressed\n");
d2413 2
d2416 1
a2416 1

d2419 6
a2424 1
			dnprintf(1,"sleep button pressed\n");
@


1.180
log
@permit compilation with ACPI_DEBUG
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.179 2010/07/19 16:57:27 deraadt Exp $ */
d2275 2
a2276 1
	bufq_restart();
a2278 1
	if (error)
d2281 2
@


1.179
log
@there is no need for a seperate dsdt_softc pointer; dsdt does not have a
softc but is just a part of the single acpi driver.
ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.177 2010/07/18 19:49:35 mlarkin Exp $ */
d530 1
a530 1
		dnprintf(5, "driver %s matches %s\n", driver, hids[i]);
@


1.178
log
@acpi_delay() is no longer needed; ok jordan
@
text
@d669 2
a860 2

	acpi_softc = sc;
@


1.177
log
@

Clear event status on resume, to avoid going back to sleep/reboot/shutdown
immediately after resume. Tested by a bunch of people on hackers@@ on
various hardware. Fixes at least Toshiba NB200 and Gateway LT3103u.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.176 2010/07/13 21:01:05 deraadt Exp $ */
a166 9

#if 0
void
acpi_delay(struct acpi_softc *sc, int64_t uSecs)
{
	/* XXX this needs to become a tsleep later */
	delay(uSecs);
}
#endif
@


1.176
log
@rename some thread related interfaces so they are logical
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.175 2010/07/10 04:59:56 jordan Exp $ */
d2098 4
@


1.175
log
@Verify _ADR bdf is correct (some systems return 0xffff)
Works on Dell x9xx and Studio 1555
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.174 2010/07/09 12:27:02 jordan Exp $ */
d71 1
a71 1
void	acpi_isr_thread(void *);
d1606 1
a1606 1
		sc->sc_wakeup = 0;
d2294 1
a2294 1
	sc->sc_wakeup = 0;
d2314 1
a2314 1
acpi_isr_thread(void *arg)
d2332 1
a2332 1
		sc->sc_wakeup = 1;
d2352 2
a2353 2
		dnprintf(10, "sleep... %d\n", sc->sc_wakeup);
		while (sc->sc_wakeup)
d2355 1
a2355 1
		sc->sc_wakeup = 1;
d2411 1
a2411 1
	if (kthread_create(acpi_isr_thread, sc->sc_thread, NULL, DEVNAME(sc))
@


1.174
log
@Clear the noise
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.173 2010/07/08 20:56:31 jordan Exp $ */
d609 4
@


1.173
log
@Add mapping for ACPI device to PCI bdf (match autoconf tree)
Simplify resource parsing function to use buffer argument
Convert namespace linked lists to use queue macros
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.167 2010/07/01 01:39:39 jordan Exp $ */
d573 1
a573 1
				printf("%s post-crs: %d\n", aml_nodename(node), 
d577 1
a577 1
				printf("%s post-bbn: %d, %lld\n", aml_nodename(node), 
@


1.172
log
@Use spltty() to lock downcalls from apm against the information being
modified by the acpi thread.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.170 2010/07/05 05:59:01 mlarkin Exp $ */
d45 4
d74 2
d104 5
a112 2
struct acpi_q *acpi_maptable(struct acpi_softc *, paddr_t, const char *, const char *, const char *, int);

d502 151
d870 3
a2478 25
}

int
_acpi_matchhids(const char *hid, const char *hids[])
{
	int i;

	for (i = 0; hids[i]; i++) 
		if (!strcmp(hid, hids[i]))
			return (1);
	return (0);
}

int
acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
    const char *driver)
{

	if (aa->aaa_dev == NULL || aa->aaa_node == NULL)
		return (0);
	if (_acpi_matchhids(aa->aaa_dev, hids)) {
		dnprintf(5, "driver %s matches %s\n", driver, hids[i]);
		return (1);
	}
	return (0);
@


1.171
log
@Don't use a workq to do the suspend, because it races aginst the acpi
thread.  Instead, just tell the acpi thread to do the suspend for us.
This makes apmd & zzz work correctly.  While here, have acpithinkpad
attempt to post the event to apm before prompting the suspend itself.
ok kettenis marco mlarkin
@
text
@a130 3
#define	ACPI_LOCK(sc)
#define	ACPI_UNLOCK(sc)

d891 1
d897 1
a897 1
	ACPI_LOCK(sc);
d921 1
a921 1
	ACPI_UNLOCK(sc);
d934 1
d940 1
a940 1
	ACPI_LOCK(sc);
d952 1
a952 1
	ACPI_UNLOCK(sc);
d970 1
d976 1
a976 1
	ACPI_LOCK(sc);
d1052 1
a1052 1
	ACPI_UNLOCK(sc);
d1064 1
d1066 1
a1066 1
	ACPI_LOCK(sc);
d1068 1
a1068 1
	ACPI_UNLOCK(sc);
d1088 1
d1104 1
a1104 1
	ACPI_LOCK(sc);
d1106 1
a1106 1
	ACPI_UNLOCK(sc);
@


1.170
log
@

Reset register SCI_EN on resume. The ACPI spec clearly states we don't have
to do this, but many machines don't, or forget to, which leads to all sorts
of problems on resume (broken battery stats, overheating, failure to resume
more than once, etc).

tested by many, ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.169 2010/07/01 16:23:46 thib Exp $ */
d981 2
a982 7
		/*
		 * Must use a workq to get out of this process's address
		 * space and into a kernel thread which has the kernel
		 * address space (with the ACPI trampoline way low).
		 */
		workq_add_task(NULL, 0, (workq_fn)acpi_sleep_state,
		    acpi_softc, (void *)ACPI_STATE_S3);
d2120 4
d2125 3
d2221 10
@


1.169
log
@do bufq quiesce again, since vnd/the bufq_done call in
biodone has been fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.168 2010/07/01 06:29:32 jordan Exp $ */
d1931 3
@


1.168
log
@Backout recent AML changes, breaks on R210 and others
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.161 2010/06/29 04:05:23 tedu Exp $ */
d21 1
d1982 2
d2072 2
d2113 2
@


1.167
log
@Simplified aml_parse_resource call, cleanup code
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.166 2010/07/01 01:14:36 jordan Exp $ */
a20 1
#include <sys/buf.h>
a43 4
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ppbreg.h>

a68 2
void 	acpi_pci_match(struct device *, struct pci_attach_args *);

a96 5
int	acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
	    const char *driver);

struct acpi_q *acpi_maptable(struct acpi_softc *, paddr_t, const char *,
	    const char *, const char *, int);
d101 2
a494 144
TAILQ_HEAD(, acpi_pci) acpi_pcidevs =
    TAILQ_HEAD_INITIALIZER(acpi_pcidevs);

int acpi_getpci(struct aml_node *node, void *arg);
int acpi_getminbus(union acpi_resource *crs, void *arg);

int
acpi_getminbus(union acpi_resource *crs, void *arg)
{
	int *bbn = arg;
	int typ = AML_CRSTYPE(crs);

	/* Check for embedded bus number */
	if (typ == LR_WORD && crs->lr_word.type == 2)
		*bbn = crs->lr_word._min;
	return 0;
}

int
_acpi_matchhids(const char *hid, const char *hids[])
{
	int i;

	for (i = 0; hids[i]; i++) 
		if (!strcmp(hid, hids[i]))
			return (1);
	return (0);
}

int
acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
    const char *driver)
{

	if (aa->aaa_dev == NULL || aa->aaa_node == NULL)
		return (0);
	if (_acpi_matchhids(aa->aaa_dev, hids)) {
		dnprintf(5, "driver %s matches %s\n", driver, hids[i]);
		return (1);
	}
	return (0);
}

/* Map ACPI device node to PCI */
int
acpi_getpci(struct aml_node *node, void *arg)
{
	const char *pcihid[] = { ACPI_DEV_PCIB, ACPI_DEV_PCIEB, "HWP0002", 0 };
	struct acpi_pci *pci, *ppci;
	struct aml_value res;
	struct acpi_softc *sc = arg;
	pci_chipset_tag_t pc = NULL;
	pcitag_t tag;
	uint64_t val;
	uint32_t reg;

	if (!node->value || node->value->type != AML_OBJTYPE_DEVICE)
		return 0;
	if (!aml_evalhid(node, &res)) {
		/* Check if this is a PCI Root node */
		if (_acpi_matchhids(res.v_string, pcihid)) {
			aml_freevalue(&res);

			pci = malloc(sizeof(*pci), M_DEVBUF, M_WAITOK|M_ZERO);

			if (!aml_evalinteger(sc, node, "_SEG", 0, NULL, &val))
				pci->seg = val;
			if (!aml_evalinteger(sc, node, "_BBN", 0, NULL, &val))
				pci->bus = val;
			else if (!aml_evalname(sc, node, "_CRS", 0, NULL, &res)) {
				aml_parse_resource(&res, acpi_getminbus, 
				    &pci->bus);
			}
			pci->sub = pci->bus;
			node->pci = pci;
			dnprintf(10, "found PCI root: %s %d\n", 
			    aml_nodename(node), pci->bus);
		}
		aml_freevalue(&res);
		return 0;
	}

	/* If parent is not PCI, or device does not have _ADR, return */
	if (!node->parent || (ppci = node->parent->pci) == NULL)
		return 0;
	if (aml_evalinteger(sc, node, "_ADR", 0, NULL, &val))
		return 0;

	pci = malloc(sizeof(*pci), M_DEVBUF, M_WAITOK|M_ZERO);
	pci->bus = ppci->sub;
	pci->dev = ACPI_ADR_PCIDEV(val);
	pci->fun = ACPI_ADR_PCIFUN(val);
	pci->node = node;
	pci->sub = -1;

	dnprintf(10, "%.2x:%.2x.%x -> %s\n", 
		pci->bus, pci->dev, pci->fun,
		aml_nodename(node));

	/* Check if PCI device exists */
	tag = pci_make_tag(pc, pci->bus, pci->dev, pci->fun);
	reg = pci_conf_read(pc, tag, PCI_ID_REG);
	if (PCI_VENDOR(reg) == PCI_VENDOR_INVALID) {
		free(pci, M_DEVBUF);
		return (1);
	}
	node->pci = pci;

	TAILQ_INSERT_TAIL(&acpi_pcidevs, pci, next);

	/* Check if this is a PCI bridge */
	reg = pci_conf_read(pc, tag, PCI_CLASS_REG);
	if (PCI_CLASS(reg) == PCI_CLASS_BRIDGE &&
	    PCI_SUBCLASS(reg) == PCI_SUBCLASS_BRIDGE_PCI) {
		reg = pci_conf_read(pc, tag, PPB_REG_BUSINFO);
		pci->sub = PPB_BUSINFO_SECONDARY(reg);

		dnprintf(10, "found PCI bridge: %s %d\n", 
		    aml_nodename(node), pci->sub);

		/* Continue scanning */
		return (0);
	}

	/* Device does not have children, stop scanning */
	return (1);
}

void
acpi_pci_match(struct device *dev, struct pci_attach_args *pa)
{
	struct acpi_pci *pdev;

	TAILQ_FOREACH(pdev, &acpi_pcidevs, next) {
		if (pdev->bus == pa->pa_bus && 
		    pdev->dev == pa->pa_device && 
		    pdev->fun == pa->pa_function) {
			dnprintf(10,"%s at acpi0 %s\n", 
			    dev->dv_xname, aml_nodename(pdev->node));
			pdev->device = dev;
		}
	}
}

a711 3
	/* Get PCI mapping */
	aml_walknodes(&aml_root, AML_WALK_PRE, acpi_getpci, sc);

a2107 1

a2111 1

d2292 25
@


1.166
log
@Fix subordinate bus # for multi-root PCI buses
ok marco, kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.165 2010/06/30 22:41:43 thib Exp $ */
d575 2
a576 5
				if (res.type == AML_OBJTYPE_BUFFER &&
				    res.length > 5)
					aml_parse_resource(res.length, 
					    res.v_buffer, acpi_getminbus,
					    &pci->bus);
@


1.165
log
@Disable/partially backout the bufq quiesce changes as this
is causing havoc with vnds and release must be buildable.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.164 2010/06/29 23:03:22 deraadt Exp $ */
d581 1
@


1.164
log
@Fix ramdisks (new code was placed inside a SMALL_KERNEL chunk)
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.163 2010/06/29 22:08:29 jordan Exp $ */
a2139 2
	bufq_restart();

a2227 2
	bufq_quiesce();

a2266 1
	bufq_restart();
@


1.163
log
@Add support for mapping ACPI to PCI devices
ok kettenis, deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.162 2010/06/29 18:54:35 kettenis Exp $ */
d104 5
a112 2
struct acpi_q *acpi_maptable(struct acpi_softc *, paddr_t, const char *, const char *, const char *, int);

d523 25
a2457 25
}

int
_acpi_matchhids(const char *hid, const char *hids[])
{
	int i;

	for (i = 0; hids[i]; i++) 
		if (!strcmp(hid, hids[i]))
			return (1);
	return (0);
}

int
acpi_matchhids(struct acpi_attach_args *aa, const char *hids[],
    const char *driver)
{

	if (aa->aaa_dev == NULL || aa->aaa_node == NULL)
		return (0);
	if (_acpi_matchhids(aa->aaa_dev, hids)) {
		dnprintf(5, "driver %s matches %s\n", driver, hids[i]);
		return (1);
	}
	return (0);
@


1.162
log
@Call bufq_quiesce() on suspend to stop all I/O and bufq_restart on resume.
Makes suspend/resume work much better while doing disk I/O.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.161 2010/06/29 04:05:23 tedu Exp $ */
d45 4
d74 2
d502 121
d839 3
@


1.161
log
@60 is a more reasonable guess for number of minutes in an hour than 100.
spotted by TeXitoi.  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.160 2010/06/27 19:42:57 jordan Exp $ */
d21 1
d1982 2
d2072 2
d2113 2
d2119 1
@


1.160
log
@Add _acpi_matchhids routine, precursor to pci device match
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.159 2010/06/27 17:04:27 mlarkin Exp $ */
d1039 1
a1039 1
			pi->minutes_left = 100 * minutes / rate;
@


1.159
log
@

Clear ACPI fixed event status on resume (power buttons/etc) so that some
machines don't immediately resume after suspending to S3.

Tested by kettenis@@ and I on 5 or 6 machines, deraadt@@ "yeah, looks good"
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.158 2010/06/27 07:26:31 jordan Exp $ */
d96 2
d2295 11
a2308 1
	int i;
d2312 3
a2314 5
	for (i = 0; hids[i]; i++) {
		if (!strcmp(aa->aaa_dev, hids[i])) {
			dnprintf(5, "driver %s matches %s\n", driver, hids[i]);
			return (1);
		}
@


1.158
log
@Cleaned up acpi_maptable, adds to table list directly
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.157 2010/04/07 17:46:30 deraadt Exp $ */
d2097 4
@


1.157
log
@If we have done a wsdisplay_suspend(), and ACPI decides it does not want to
suspend, we must roll back by calling wsdisplay_resume() or the virtual
console switching will be locked forever
ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.156 2010/04/07 06:33:06 kettenis Exp $ */
d99 1
a99 1
struct acpi_q *acpi_maptable(paddr_t, const char *, const char *, const char *);
d593 1
a593 1
		entry = acpi_maptable(sc->sc_fadt->dsdt, NULL, NULL, NULL);
d595 1
a595 1
		entry = acpi_maptable(sc->sc_fadt->x_dsdt, NULL, NULL, NULL);
a598 1
	SIMPLEQ_INSERT_HEAD(&sc->sc_tables, entry, q_next);
d785 1
a785 1
acpi_maptable(paddr_t addr, const char *sig, const char *oem, const char *tbl)
d823 7
d838 1
a838 1
	struct acpi_q *entry, *sdt;
d845 1
a845 1
		sdt = acpi_maptable(rsdp->rsdp_xsdt, NULL, NULL, NULL);
d856 4
a859 7
		for (i = 0; i < ntables; i++) {
			entry = acpi_maptable(xsdt->table_offsets[i], NULL, NULL,
			    NULL);
			if (entry != NULL)
				SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry,
				    q_next);
		}
d864 1
a864 1
		sdt = acpi_maptable(rsdp->rsdp_rsdt, NULL, NULL, NULL);
d875 4
a878 7
		for (i = 0; i < ntables; i++) {
			entry = acpi_maptable(rsdt->table_offsets[i], NULL, NULL,
			    NULL);
			if (entry != NULL)
				SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry,
				    q_next);
		}
@


1.156
log
@Make suspend/resume work on MP machines (running an MP kernel).  Joint work
from mlarkin@@ and me, with some amd64 fixes thrown in by deraadt@@

ok marco@@, deraadt@@, pirofti@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.155 2010/03/31 19:21:19 kettenis Exp $ */
d2034 1
d2074 2
a2075 1
			return (1);
d2084 2
a2085 1
			return (ENXIO);
d2094 2
a2095 1
			return (ENXIO);
d2101 6
a2106 1
	return (0);
@


1.155
log
@Bring /dev/apm support in line with apm(4).  Make the suspend button send
a suspend request event to apmd(8) instead of suspending immediately.  Also
keep track of whether /dev/apm and /dev/apmctl are currently open, such that
we can still suspend immediately if apmd(8) isn't running.

ok deraadt@@, marco@@, pirofti@@, jsing@@, oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.154 2010/03/30 17:40:55 oga Exp $ */
d30 1
a1840 4
#ifdef MULTIPROCESSOR
	if (ncpus > 1)	/* cannot suspend MP yet */
		return (0);
#endif
d1956 2
d1973 4
d2024 4
d2044 5
@


1.154
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.153 2010/03/25 23:00:20 oga Exp $ */
d895 1
d902 5
d913 1
d919 1
d937 1
d940 2
d943 1
d949 1
a974 2
	case APM_IOC_STANDBY_REQ:
	case APM_IOC_SUSPEND_REQ:
d1974 2
d1982 11
a2166 1
			acpi_evindex++;
a2167 2
			KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_PWRBTN,
			    acpi_evindex));
a2173 1
			acpi_evindex++;
a2174 2
			KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_SLPBTN,
			    acpi_evindex));
@


1.153
log
@Fix & vs. && in the kqfilter code.

Based on a comparison with the apm code.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.152 2009/11/26 23:44:38 mlarkin Exp $ */
d41 1
d52 2
d1962 4
d2024 5
@


1.152
log
@

Visual (and on some machines, audio) feedback while the machine is
resuming via calls to aml _SST method. This also makes the "moon" LED on
thinkpads to blink during resume and cease when resume is completed.

ok pirofti@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.151 2009/11/26 13:20:39 deraadt Exp $ */
d1063 1
a1063 1
	if (hint & !kn->kn_data)
@


1.151
log
@Toggle into "cold" when we we disable interrupts, because tsleeping
in the AML interpreter and context switching into userland processes
tends to sometimes pop the ACPI trampoline page out of our address
space.  Makes lots more machines work.
ok kettenis mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.150 2009/11/24 23:01:41 jsg Exp $ */
d1782 1
a1782 1
	sc->sc_sst = aml_searchname(&aml_root, "_SST");
d1930 6
d1953 6
d1984 6
a2044 3

	if (sc->sc_sst)
		aml_evalnode(sc, sc->sc_sst, 1, &env, NULL);
@


1.150
log
@in the resume path evaluate _WAK before dealing with device drivers
like the spec says, not after.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.149 2009/11/24 16:12:37 deraadt Exp $ */
d963 5
d1935 1
d1956 1
d2002 1
@


1.149
log
@abort suspends on SMP systems until that gets written; ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.148 2009/11/23 22:34:23 mlarkin Exp $ */
d1919 6
a1931 6

	if (sc->sc_wak)
		if (aml_evalnode(sc, sc->sc_wak, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _WAK failed.\n",
			    DEVNAME(sc));
		}
@


1.148
log
@

pci should return the result of it's children's suspend/resume calls back
to its parent.

handle suspend failure case and unwind if devices have an activate function
that returns failure.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.147 2009/11/23 18:01:56 mlarkin Exp $ */
d1821 4
@


1.147
log
@

acpi* devices need to call their children on suspend/resume.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.146 2009/11/23 16:21:54 pirofti Exp $ */
d69 1
d1940 23
d1993 4
a1996 1
 		config_suspend(TAILQ_FIRST(&alldevs), DVACT_SUSPEND);
@


1.146
log
@Remove ACPI_SLEEP_ENABLED checks.

This enables by default the suspend/resume paths in the kernel.

Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.145 2009/11/23 15:18:05 deraadt Exp $ */
d138 2
a139 1
	sizeof(struct acpi_softc), acpi_match, acpi_attach
@


1.145
log
@knf and spacing that are super annoying
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.144 2009/11/23 15:04:41 mlarkin Exp $ */
a956 1
#ifdef ACPI_SLEEP_ENABLED
a963 1
#endif /* ACPI_SLEEP_ENABLED */
d1842 1
a1842 1
#ifdef ACPI_SLEEP_ENABLED
d1845 1
a1845 1
#endif /* ACPI_SLEEP_ENABLED */
@


1.144
log
@

Hook up Theo's new children suspend/resume function, as well as more ACPI
suspend/resume glue.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.143 2009/10/26 20:17:26 deraadt Exp $ */
d316 1
a316 1
	if(st & STA_DEV_OK)
d352 1
a352 1
	if(st & STA_DEV_OK)
d397 1
a397 1
	dnprintf(10, "IDE notify! %s %d status:%llx\n", aml_nodename(node), 
d451 1
a451 1
		aml_evalinteger(sc, node->parent, "_ADR", 0, NULL, 
d456 1
a456 1
		aml_evalinteger(sc, node->parent->parent, "_ADR", 0, NULL, 
d461 1
a461 1
	dnprintf(10, "%s %llx channel:%llx\n", 
d845 1
a845 1
			entry = acpi_maptable(xsdt->table_offsets[i], NULL, NULL, 
d848 2
a849 2
				SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry, 
				    q_next);					
d867 1
a867 1
			entry = acpi_maptable(rsdt->table_offsets[i], NULL, NULL, 
d870 2
a871 2
				SIMPLEQ_INSERT_TAIL(&sc->sc_tables, entry, 
				    q_next);					
d1382 1
a1382 1
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1, 
d1616 1
a1616 1
	for (i=0; i<len; i++) {
d1633 1
a1633 1
	for (i=0; i<len*8; i++) {
d1654 1
a1654 1
	processed=0;
d1658 1
a1658 1
		for (i=0; i<8; i++) {
d1661 1
a1661 1
				processed=1;
d1678 1
a1678 1
	for (idx=0; idx<len; idx++) {
d1683 1
a1683 1
		for (jdx=0; jdx<8; jdx++) {
d1708 1
a1708 1
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1, 
d1801 1
a1801 1
			acpi_enable_onegpe(sc, wentry->q_gpe, 
d1806 1
a1806 1
	
d1916 3
a1918 3
	acpi_susp_resume_gpewalk(sc, state, 0); 
	
	config_suspend(TAILQ_FIRST(&alldevs), DVACT_RESUME); 
@


1.143
log
@Do not do strncmp comparisons on dv_xname because longer device names which
look similar could arrive in the future.  Instead, compare directly against
dv_cfdata->cf_driver->cd_name
Issue originally spotted by miod
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.142 2009/10/26 19:56:01 jordan Exp $ */
d58 1
a87 3
void	acpi_dev_sort(void);
void	acpi_dev_free(void);

d108 4
a111 3
#ifdef ACPI_SLEEP_ENABLED
void acpi_sleep_walk(struct acpi_softc *, int);
#endif /* ACPI_SLEEP_ENABLED */
d1777 1
d1782 2
a1783 1
acpi_sleep_walk(struct acpi_softc *sc, int state)
d1787 1
d1800 12
a1811 2
	if (state <= wentry->q_state)
		acpi_enable_onegpe(sc, wentry->q_gpe, 1);
a1835 2
	acpi_sleep_walk(sc, state);

d1844 4
a1847 3
#ifndef SMALL_KERNEL
	acpi_resume(sc);
#endif /* ! SMALL_KERNEL */
d1885 1
d1901 1
a1901 1
acpi_resume(struct acpi_softc *sc)
d1915 7
a1921 2
	dopowerhooks(PWR_RESUME);
	inittodr(0);
d1966 6
a1971 11
	switch (state) {
	case ACPI_STATE_S1:
	case ACPI_STATE_S2:
		resettodr();
		dopowerhooks(PWR_SUSPEND);
		break;
	case ACPI_STATE_S3:
		resettodr();
		dopowerhooks(PWR_STANDBY);
		break;
	}
d1990 5
a1994 3
	disable_intr();
	aml_evalname(sc, &aml_root, "\\_SST", 1, &env, NULL);
	sc->sc_state = state;
d2008 1
a2008 1
	acpi_sleep_walk(acpi_softc, ACPI_STATE_S5);
a2292 45
}

TAILQ_HEAD(acpi_dv_hn, acpi_dev_rank) acpi_dv_h;
void
acpi_dev_sort(void)
{
	struct device		*dev, *idev;
	struct acpi_dev_rank	*rentry, *ientry;
	int			rank;

	TAILQ_INIT(&acpi_dv_h);

	TAILQ_FOREACH(dev, &alldevs, dv_list) {
		for (rank = -1, idev = dev; idev != NULL;
		    idev = idev->dv_parent, rank++)
			;	/* nothing */

		rentry = malloc(sizeof(*rentry), M_DEVBUF, M_WAITOK | M_ZERO);
		rentry->rank = rank;
		rentry->dev = dev;

		if (TAILQ_FIRST(&acpi_dv_h) == NULL)
			TAILQ_INSERT_HEAD(&acpi_dv_h, rentry, link);
		TAILQ_FOREACH_REVERSE(ientry, &acpi_dv_h, acpi_dv_hn, link) {
			if (rentry->rank > ientry->rank) {
				TAILQ_INSERT_AFTER(&acpi_dv_h, ientry, rentry, 
				    link);
				break;
			}
		}
	}
}

void
acpi_dev_free(void)
{
	struct acpi_dev_rank	*dvr;

	while ((dvr = TAILQ_FIRST(&acpi_dv_h)) != NULL) {
		TAILQ_REMOVE(&acpi_dv_h, dvr, link);
		if (dvr != NULL) {
			free(dvr, M_DEVBUF);
			dvr = NULL;
		}
	}
@


1.142
log
@Verify checksum+address when loading ACPI tables.
Some systems had invalid entries in RSDT/XSDT.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.141 2009/07/23 01:38:16 cnst Exp $ */
d403 1
a403 1
		if (strncmp(dev->dv_xname, "pciide", 6))
d732 1
a732 1
		if (!strncmp(dev->dv_xname, "acpiac", strlen("acpiac"))) {
d736 1
a736 2
		}
		if (!strncmp(dev->dv_xname, "acpibat", strlen("acpibat"))) {
@


1.141
log
@New aibs(4) driver for ASUSTeK AI Booster (ACPI ATK0110) hardware monitoring,
with sensor state support through limits provided by the ACPI.

Tested on several ASUS motherboards kindly networked by Sam Fourman Jr.

ok deraadt marco jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.140 2009/06/03 07:13:48 pirofti Exp $ */
a81 2
void	acpi_load_table(paddr_t, size_t, acpi_qhead_t *);
void	acpi_load_dsdt(paddr_t, struct acpi_q **);
d96 2
d588 1
a588 1
		acpi_load_dsdt(sc->sc_fadt->dsdt, &entry);
d590 1
a590 1
		acpi_load_dsdt(sc->sc_fadt->x_dsdt, &entry);
d781 44
d828 1
a828 2
	struct acpi_mem_map hrsdt, handle;
	struct acpi_table_header *hdr;
d835 2
a836 1
		if (acpi_map(rsdp->rsdp_xsdt, sizeof(*hdr), &handle)) {
d841 2
a842 8
		hdr = (struct acpi_table_header *)handle.va;
		len = hdr->length;
		acpi_unmap(&handle);
		hdr = NULL;

		acpi_map(rsdp->rsdp_xsdt, len, &hrsdt);
		xsdt = (struct acpi_xsdt *)hrsdt.va;

d847 5
a851 5
			acpi_map(xsdt->table_offsets[i], sizeof(*hdr), &handle);
			hdr = (struct acpi_table_header *)handle.va;
			acpi_load_table(xsdt->table_offsets[i], hdr->length,
			    &sc->sc_tables);
			acpi_unmap(&handle);
d853 1
a853 1
		acpi_unmap(&hrsdt);
d857 2
a858 1
		if (acpi_map(rsdp->rsdp_rsdt, sizeof(*hdr), &handle)) {
d863 2
a864 8
		hdr = (struct acpi_table_header *)handle.va;
		len = hdr->length;
		acpi_unmap(&handle);
		hdr = NULL;

		acpi_map(rsdp->rsdp_rsdt, len, &hrsdt);
		rsdt = (struct acpi_rsdt *)hrsdt.va;

d869 5
a873 5
			acpi_map(rsdt->table_offsets[i], sizeof(*hdr), &handle);
			hdr = (struct acpi_table_header *)handle.va;
			acpi_load_table(rsdt->table_offsets[i], hdr->length,
			    &sc->sc_tables);
			acpi_unmap(&handle);
d875 1
a875 1
		acpi_unmap(&hrsdt);
a878 47
}

void
acpi_load_table(paddr_t pa, size_t len, acpi_qhead_t *queue)
{
	struct acpi_mem_map handle;
	struct acpi_q *entry;

	entry = malloc(len + sizeof(struct acpi_q), M_DEVBUF, M_NOWAIT);

	if (entry != NULL) {
		if (acpi_map(pa, len, &handle)) {
			free(entry, M_DEVBUF);
			return;
		}
		memcpy(entry->q_data, handle.va, len);
		entry->q_table = entry->q_data;
		acpi_unmap(&handle);
		SIMPLEQ_INSERT_TAIL(queue, entry, q_next);
	}
}

void
acpi_load_dsdt(paddr_t pa, struct acpi_q **dsdt)
{
	struct acpi_mem_map handle;
	struct acpi_table_header *hdr;
	size_t len;

	if (acpi_map(pa, sizeof(*hdr), &handle))
		return;
	hdr = (struct acpi_table_header *)handle.va;
	len = hdr->length;
	acpi_unmap(&handle);

	*dsdt = malloc(len + sizeof(struct acpi_q), M_DEVBUF, M_NOWAIT);

	if (*dsdt != NULL) {
		if (acpi_map(pa, len, &handle)) {
			free(*dsdt, M_DEVBUF);
			*dsdt = NULL;
			return;
		}
		memcpy((*dsdt)->q_data, handle.va, len);
		(*dsdt)->q_table = (*dsdt)->q_data;
		acpi_unmap(&handle);
	}
@


1.140
log
@Import acpi power resource driver. This is needed for suspend/resume logic.

Okay jordan@@ and marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.139 2009/06/03 00:36:59 pirofti Exp $ */
d2247 2
a2248 1
	}
@


1.139
log
@Add acpivideo support. This adds brightness support for all laptops
except thinkpads, they will use the acpithinkpad driver. The driver is
also hooked into wsconsole. So brightness can be adjusted via:

$ wsconsctl display.brightness=<percentage>

This is very helpfull on some laptops that have a nasty bios and get two
steps instead of one when pressing the brightness button.

Tested on various dell, fujitsu, acer, samsung and other laptops.

Okay marco@@, miod@@. Suggestions from kettenis@@.
Lots of reviews and help from miod@@, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.138 2009/06/03 00:13:35 jordan Exp $ */
d1481 3
@


1.138
log
@Added ejectable bay for IDE cdroms
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.137 2009/04/30 20:42:14 marco Exp $ */
d57 1
d724 3
a726 2
	/* attach video */
	aml_find_node(&aml_root, "_DOS", acpi_foundvideo, sc);
d2241 1
a2241 1
	else if (!strcmp(dev, ACPI_DEV_THINKPAD))
d2243 2
@


1.137
log
@Oga changed apm ioctls and forgot to grep.  Temporary work around by hitting
the sleep button when we get any request.  This interface will chnage at
some point.
ok oga
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.136 2009/04/19 21:33:43 krw Exp $ */
d42 3
d91 18
d364 108
d716 3
@


1.136
log
@Call acpi_sleep_walk() when powering down just like when entering
any other sleep state. This tells acpi wake devices to not wake up
the box until manual powering up resets their status. Makes my Dell
GX520 stay powered off in response to 'halt -p'.

In snaps for a while.

ok marco@@ (several times) deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.135 2009/04/17 13:20:20 pirofti Exp $ */
d805 1
d840 2
d845 1
a845 1
		acpi_softc, (void *)ACPI_STATE_S3);
@


1.135
log
@Add device ranking support for future sleep/wake developments.

okay marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.134 2009/03/11 20:37:46 jordan Exp $ */
d1869 1
@


1.134
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.133 2009/03/10 19:35:03 jordan Exp $ */
d85 3
d2150 45
@


1.133
log
@Fix cut/paste error.. call _BFS not _PTS
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.132 2009/02/21 13:09:20 marco Exp $ */
d275 1
a275 7
	struct aml_value	res;
	int st = 0;

	/* Default value */
	st = STA_PRESENT|STA_ENABLED;
	st |= STA_SHOW_UI|STA_DEV_OK;
	st |= STA_BATTERY;
d284 2
a285 3
	if (!aml_evalname(sc, node->parent, "_STA", 0, NULL, &res))
		st = (int)aml_val2int(&res);
	aml_freevalue(&res);
d309 1
a309 2
	struct aml_value	res;
	int st = 0;
a312 5
	/* Default value */
	st = STA_PRESENT|STA_ENABLED;
	st |= STA_SHOW_UI|STA_DEV_OK;
	st |= STA_BATTERY;

d314 2
a315 3
	if (!aml_evalname(sc, node->parent, "_STA", 0, NULL, &res))
		st = (int)aml_val2int(&res);
	aml_freevalue(&res);
@


1.132
log
@overzealous cut/paste; found by Vladimir Kirillov <proger@@uaoug.org.ua>
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.131 2009/02/20 20:08:26 marco Exp $ */
d1784 1
a1784 1
		if (aml_evalnode(sc, sc->sc_pts, 1, &env, NULL) != 0) {
@


1.131
log
@Oops didn't mean for Debugger() to remain there.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.130 2009/02/19 21:02:05 marco Exp $ */
d1801 1
a1801 1
		if (aml_evalnode(sc, sc->sc_wak, 1, &env, NULL) != 0) {
@


1.130
log
@suspend/resume bits so that we can develop this in tree.  This is disabled.
code from mlarkin and me
help from art,toby,jordan and several others
ok jordan, go for it deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.129 2009/02/10 02:13:19 jordan Exp $ */
a1721 1
	Debugger();
@


1.129
log
@Fix null pointer for shutdown if acpi not enabled
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.128 2009/02/04 20:09:03 kettenis Exp $ */
d29 1
d85 4
d849 7
d1666 1
d1668 1
a1668 1
acpi_enter_sleep_state(struct acpi_softc *sc, int state)
d1670 2
a1671 3
	struct aml_value env;
	u_int16_t rega, regb;
	int retries;
d1673 4
a1676 7
	if (sc == NULL || state == ACPI_STATE_S0)
		return;
	if (sc->sc_sleeptype[state].slp_typa == -1 ||
	    sc->sc_sleeptype[state].slp_typb == -1) {
		printf("%s: state S%d unavailable\n",
		    sc->sc_dev.dv_xname, state);
		return;
d1679 7
a1685 10
	memset(&env, 0, sizeof(env));
	env.type = AML_OBJTYPE_INTEGER;
	env.v_integer = state;
	/* _TTS(state) */
	if (sc->sc_tts) {
		if (aml_evalnode(sc, sc->sc_tts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _TTS failed.\n",
			    DEVNAME(sc));
			return;
		}
d1687 8
d1696 6
a1703 3
		resettodr();
		dopowerhooks(PWR_SUSPEND);
		break;
d1705 3
a1707 3
		resettodr();
		dopowerhooks(PWR_STANDBY);
		break;
d1709 23
a1731 18
	/* _PTS(state) */
	if (sc->sc_pts) {
		if (aml_evalnode(sc, sc->sc_pts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _PTS failed.\n",
			    DEVNAME(sc));
			return;
		}
	}
	sc->sc_state = state;
	/* _GTS(state) */
	if (sc->sc_gts) {
		if (aml_evalnode(sc, sc->sc_gts, 1, &env, NULL) != 0) {
			dnprintf(10, "%s evaluating method _GTS failed.\n",
			    DEVNAME(sc));
			return;
		}
	}
	disable_intr();
d1734 4
a1737 1
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, ACPI_PM1_WAK_STS);
d1752 7
a1760 1

d1771 1
a1771 1
	enable_intr();
d1774 1
a1774 1
#if 0
d1784 1
a1784 1
	if (sc->sc_bfs) {
d1789 1
a1789 1
	}
d1792 2
a1793 1
	if (sc->sc_wak) {
d1798 1
a1798 1
	}
d1808 65
a1872 1
#endif
d1877 6
a1882 1
	acpi_enter_sleep_state(acpi_softc, ACPI_STATE_S5);
d1884 1
@


1.128
log
@Some systems that claim to be ACPI 2.0 apparently don't provide an XSDT
address.  Make the code fall back on the RSDT on those systems.

From Joerg Niendorf <p3y80@@internode.on.net>.  Fixes PR 5986.
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.127 2009/01/17 17:17:11 krw Exp $ */
d1661 1
a1661 1
	if (state == ACPI_STATE_S0)
@


1.127
log
@A couple of stray malloc/memset -> malloc(M_ZERO), a bit of knf and
lose a couple of unnecessary casts. No functional change.

Feedback from kettenis@@

ok kettenis@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.126 2008/11/06 23:41:28 marco Exp $ */
d661 1
a661 1
	if (rsdp->rsdp_revision == 2) {
@


1.126
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.125 2008/07/02 03:14:54 fgsch Exp $ */
d1437 1
a1437 1
	wq = (struct acpi_wakeq *)malloc(sizeof(struct acpi_wakeq), M_DEVBUF, M_NOWAIT);
a1440 1
	memset(wq, 0, sizeof(struct acpi_wakeq));
d1442 2
a1443 2
	wq->q_wakepkg = (struct aml_value *)malloc(sizeof(struct aml_value),
	    M_DEVBUF, M_NOWAIT);
a1447 1
	memset(wq->q_wakepkg, 0, sizeof(struct aml_value));
@


1.125
log
@add acpivideo. for now almost an empty skel so others can work on
suspend/resume. eventually it will also manage output switching and
brightness where supported.  prodded by marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.124 2008/06/11 04:42:09 marco Exp $ */
d1954 17
@


1.124
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: acpi.c,v 1.123 2008/06/08 02:53:14 deraadt Exp $ */
d73 1
d597 3
d2027 18
@


1.123
log
@aaa_dev was being set from an uninitialized variable; ok toby
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.122 2008/06/07 17:00:38 marco Exp $	*/
@


1.122
log
@Kill ACPIVERBOSE.  It was never used and is worthless to boot.

comments jmc
ok toby
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.121 2008/06/06 09:15:32 marco Exp $	*/
a308 1
	const char		*dev;
a329 1
		aaa.aaa_dev = dev;
a1313 1
	aaa.aaa_dev = "";
a2009 1
	const char		*dev;
a2017 1
	aaa.aaa_dev = dev;
@


1.121
log
@Shrink acpi some more for floppies and while here re-enable acpi on the
floppies.  Fixes crazy sony vaio kettenis has.

tested by deraadt
ok deraadt jordan kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.120 2008/06/01 18:14:25 marco Exp $	*/
a638 1
	/* XXX ACPIVERBOSE should be replaced with dnprintf */
a639 4
#ifdef ACPIVERBOSE
	struct acpi_table_header *hdr =
		(struct acpi_table_header *)aa->aaa_table;
#endif
a643 4
#ifdef ACPIVERBOSE
		else
			printf("acpi device at %s from", pnp);
#else
a645 1
#endif
a646 6
#ifdef ACPIVERBOSE
	if (hdr)
		printf(" table %c%c%c%c",
		    hdr->signature[0], hdr->signature[1],
		    hdr->signature[2], hdr->signature[3]);
#endif
@


1.120
log
@Fix \n nit in SMALL_KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.119 2008/06/01 17:59:55 marco Exp $	*/
d374 1
d380 1
a380 1
#endif
d398 1
d405 1
d496 1
d501 1
d507 1
a517 2
	int idx;

a525 1
#endif /* SMALL_KERNEL */
a985 90
/* move all stuff that doesn't go on the boot media in here */
#ifndef SMALL_KERNEL
void
acpi_reset(void)
{
	struct acpi_fadt	*fadt;
	u_int32_t		 reset_as, reset_len;
	u_int32_t		 value;

	fadt = acpi_softc->sc_fadt;

	/*
	 * RESET_REG_SUP is not properly set in some implementations,
	 * but not testing against it breaks more machines than it fixes
	 */
	if (acpi_softc->sc_revision <= 1 ||
	    !(fadt->flags & FADT_RESET_REG_SUP) || fadt->reset_reg.address == 0)
		return;

	value = fadt->reset_value;

	reset_as = fadt->reset_reg.register_bit_width / 8;
	if (reset_as == 0)
		reset_as = 1;

	reset_len = fadt->reset_reg.access_size;
	if (reset_len == 0)
		reset_len = reset_as;

	acpi_gasio(acpi_softc, ACPI_IOWRITE,
	    fadt->reset_reg.address_space_id,
	    fadt->reset_reg.address, reset_as, reset_len, &value);

	delay(100000);
}

int
acpi_interrupt(void *arg)
{
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	u_int32_t processed, sts, en, idx, jdx;

	processed = 0;

#if 0
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe0_blk, sc->sc_fadt->gpe0_blk_len>>1, 0);
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1, 
	    sc->sc_fadt->gpe1_base);
#endif

	dnprintf(40, "ACPI Interrupt\n");
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		sts = acpi_read_pmreg(sc, ACPIREG_GPE_STS, idx>>3);
		en  = acpi_read_pmreg(sc, ACPIREG_GPE_EN,  idx>>3);
		if (en & sts) {
			dnprintf(10, "GPE block: %.2x %.2x %.2x\n", idx, sts,
			    en);
			acpi_write_pmreg(sc, ACPIREG_GPE_EN, idx>>3, en & ~sts);
			for (jdx = 0; jdx < 8; jdx++) {
				if (en & sts & (1L << jdx)) {
					/* Signal this GPE */
					sc->gpe_table[idx+jdx].active = 1;
					processed = 1;
				}
			}
		}
	}

	sts = acpi_read_pmreg(sc, ACPIREG_PM1_STS, 0);
	en  = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	if (sts & en) {
		dnprintf(10,"GEN interrupt: %.4x\n", sts & en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en & ~sts);
		acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);
		if (sts & ACPI_PM1_PWRBTN_STS)
			sc->sc_powerbtn = 1;
		if (sts & ACPI_PM1_SLPBTN_STS)
			sc->sc_sleepbtn = 1;
		processed = 1;
	}

	if (processed) {
		sc->sc_wakeup = 0;
		wakeup(sc);
	}

	return (processed);
}

d1122 195
a1929 106
}

/* Map Power Management registers */
void
acpi_map_pmregs(struct acpi_softc *sc)
{
	bus_addr_t addr;
	bus_size_t size;
	const char *name;
	int reg;

	for (reg = 0; reg < ACPIREG_MAXREG; reg++) {
		size = 0;
		switch (reg) {
		case ACPIREG_SMICMD:
			name = "smi";
			size = 1;
			addr = sc->sc_fadt->smi_cmd;
			break;
		case ACPIREG_PM1A_STS:
		case ACPIREG_PM1A_EN:
			name = "pm1a_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1a_evt_blk;
			if (reg == ACPIREG_PM1A_EN && addr) {
				addr += size;
				name = "pm1a_en";
			}
			break;
		case ACPIREG_PM1A_CNT:
			name = "pm1a_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1a_cnt_blk;
			break;
		case ACPIREG_PM1B_STS:
		case ACPIREG_PM1B_EN:
			name = "pm1b_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1b_evt_blk;
			if (reg == ACPIREG_PM1B_EN && addr) {
				addr += size;
				name = "pm1b_en";
			}
			break;
		case ACPIREG_PM1B_CNT:
			name = "pm1b_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1b_cnt_blk;
			break;
		case ACPIREG_PM2_CNT:
			name = "pm2_cnt";
			size = sc->sc_fadt->pm2_cnt_len;
			addr = sc->sc_fadt->pm2_cnt_blk;
			break;
#if 0
		case ACPIREG_PM_TMR:
			/* Allocated in acpitimer */
			name = "pm_tmr";
			size = sc->sc_fadt->pm_tmr_len;
			addr = sc->sc_fadt->pm_tmr_blk;
			break;
#endif
		case ACPIREG_GPE0_STS:
		case ACPIREG_GPE0_EN:
			name = "gpe0_sts";
			size = sc->sc_fadt->gpe0_blk_len >> 1;
			addr = sc->sc_fadt->gpe0_blk;

			dnprintf(20, "gpe0 block len : %x\n",
			    sc->sc_fadt->gpe0_blk_len >> 1);
			dnprintf(20, "gpe0 block addr: %x\n",
			    sc->sc_fadt->gpe0_blk);
			if (reg == ACPIREG_GPE0_EN && addr) {
				addr += size;
				name = "gpe0_en";
			}
			break;
		case ACPIREG_GPE1_STS:
		case ACPIREG_GPE1_EN:
			name = "gpe1_sts";
			size = sc->sc_fadt->gpe1_blk_len >> 1;
			addr = sc->sc_fadt->gpe1_blk;

			dnprintf(20, "gpe1 block len : %x\n",
			    sc->sc_fadt->gpe1_blk_len >> 1);
			dnprintf(20, "gpe1 block addr: %x\n",
			    sc->sc_fadt->gpe1_blk);
			if (reg == ACPIREG_GPE1_EN && addr) {
				addr += size;
				name = "gpe1_en";
			}
			break;
		}
		if (size && addr) {
			dnprintf(50, "mapping: %.4x %.4x %s\n",
			    addr, size, name);

			/* Size and address exist; map register space */
			bus_space_map(sc->sc_iot, addr, size, 0,
			    &sc->sc_pmregs[reg].ioh);

			sc->sc_pmregs[reg].name = name;
			sc->sc_pmregs[reg].size = size;
			sc->sc_pmregs[reg].addr = addr;
		}
	}
@


1.119
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.117 2008/05/14 05:24:36 jordan Exp $	*/
a521 2

	printf("\n");
d524 1
a524 1
	printf("%s: tables", DEVNAME(sc));
@


1.118
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.116 2008/04/27 16:23:16 jcs Exp $	*/
d83 3
a85 2
void	acpi_filtdetach(struct knote *);
int	acpi_filtread(struct knote *, long);
d91 2
d99 4
d123 1
d130 1
d185 3
d207 3
d284 1
a284 1
	if (!aml_evalname(sc, node, "_STA", 0, NULL, &res))
d322 1
a322 1
	if (!aml_evalname(sc, node, "_STA", 0, NULL, &res))
a364 50
int acpi_add_device(struct aml_node *node, void *arg);

int
acpi_add_device(struct aml_node *node, void *arg)
{
	static int nacpicpus = 0;
	struct device *self = arg;
	struct acpi_softc *sc = arg;
	struct acpi_attach_args aaa;
#ifdef MULTIPROCESSOR
	struct aml_value res;
	int proc_id = -1;
#endif

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_node = node;
	aaa.aaa_dev = "";
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	if (node == NULL || node->value == NULL)
		return 0;

	switch (node->value->type) {
	case AML_OBJTYPE_PROCESSOR:
		if (nacpicpus >= ncpus)
			return 0;
#ifdef MULTIPROCESSOR
		if (aml_evalnode(sc, aaa.aaa_node, 0, NULL, &res) == 0) {
			if (res.type == AML_OBJTYPE_PROCESSOR)
				proc_id = res.v_processor.proc_id;
			aml_freevalue(&res);
		}
		if (proc_id < -1 || proc_id >= LAPIC_MAP_SIZE ||
		    (acpi_lapic_flags[proc_id] & ACPI_PROC_ENABLE) == 0)
			return 0;
#endif
		nacpicpus++;

		aaa.aaa_name = "acpicpu";
		break;
	case AML_OBJTYPE_THERMZONE:
		aaa.aaa_name = "acpitz";
		break;
	default:
		return 0;
	}
	config_found(self, &aaa, acpi_print);
	return 0;
}

a372 1
	struct acpi_wakeq *wentry;
d375 1
a501 1
#endif /* SMALL_KERNEL */
d524 1
d532 1
a541 1
#ifndef SMALL_KERNEL
d580 1
a580 1
	aml_find_node(aml_root.child, "_INI", acpi_inidev, sc);
d583 1
a583 1
	aml_find_node(aml_root.child, "_PRT", acpi_foundprt, sc);
d587 1
a587 1
	aml_find_node(aml_root.child, "_HID", acpi_foundec, sc);
d592 1
a592 1
	aml_find_node(aml_root.child, "_HID", acpi_foundhid, sc);
d595 1
a595 1
	aml_find_node(aml_root.child, "_DCK", acpi_founddock, sc);
d783 2
a785 1
	int error = 0;
d808 3
d817 2
a819 1
	int error = 0;
d832 3
d935 1
d941 1
d947 1
d951 1
a951 1

d958 1
d980 93
d1211 1
d1213 1
a1213 1
acpi_interrupt(void *arg)
d1215 8
a1222 2
	struct acpi_softc *sc = (struct acpi_softc *)arg;
	u_int32_t processed, sts, en, idx, jdx;
d1224 7
a1230 1
	processed = 0;
d1232 9
a1240 15
	dnprintf(40, "ACPI Interrupt\n");
	for (idx = 0; idx < sc->sc_lastgpe; idx += 8) {
		sts = acpi_read_pmreg(sc, ACPIREG_GPE_STS, idx>>3);
		en  = acpi_read_pmreg(sc, ACPIREG_GPE_EN,  idx>>3);
		if (en & sts) {
			dnprintf(10, "GPE block: %.2x %.2x %.2x\n", idx, sts,
			    en);
			acpi_write_pmreg(sc, ACPIREG_GPE_EN, idx>>3, en & ~sts);
			for (jdx = 0; jdx < 8; jdx++) {
				if (en & sts & (1L << jdx)) {
					/* Signal this GPE */
					sc->gpe_table[idx+jdx].active = 1;
					processed = 1;
				}
			}
d1242 5
a1246 1
	}
d1248 7
a1254 12
	sts = acpi_read_pmreg(sc, ACPIREG_PM1_STS, 0);
	en  = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
	if (sts & en) {
		dnprintf(10,"GEN interrupt: %.4x\n", sts & en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en & ~sts);
		acpi_write_pmreg(sc, ACPIREG_PM1_STS, 0, en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, en);
		if (sts & ACPI_PM1_PWRBTN_STS)
			sc->sc_powerbtn = 1;
		if (sts & ACPI_PM1_SLPBTN_STS)
			sc->sc_sleepbtn = 1;
		processed = 1;
d1256 2
a1257 41

	if (processed) {
		sc->sc_wakeup = 0;
		wakeup(sc);
	}

	return (processed);
}

void
acpi_reset(void)
{
	struct acpi_fadt	*fadt;
	u_int32_t		 reset_as, reset_len;
	u_int32_t		 value;

	fadt = acpi_softc->sc_fadt;

	/*
	 * RESET_REG_SUP is not properly set in some implementations,
	 * but not testing against it breaks more machines than it fixes
	 */
	if (acpi_softc->sc_revision <= 1 ||
	    !(fadt->flags & FADT_RESET_REG_SUP) || fadt->reset_reg.address == 0)
		return;

	value = fadt->reset_value;

	reset_as = fadt->reset_reg.register_bit_width / 8;
	if (reset_as == 0)
		reset_as = 1;

	reset_len = fadt->reset_reg.access_size;
	if (reset_len == 0)
		reset_len = reset_as;

	acpi_gasio(acpi_softc, ACPI_IOWRITE,
	    fadt->reset_reg.address_space_id,
	    fadt->reset_reg.address, reset_as, reset_len, &value);

	delay(100000);
a1259 3
/* move all stuff that doesn't go on the boot media in here */
#ifndef SMALL_KERNEL

d1281 4
a1284 1
	if (gpe >= sc->sc_lastgpe || handler == NULL)
d1286 1
a1286 2

	if (sc->gpe_table[gpe].handler != NULL) {
a1289 1

d1291 2
a1292 4
	sc->gpe_table[gpe].handler = handler;
	sc->gpe_table[gpe].arg = arg;

	/* Defer enabling GPEs */
d1377 108
d1492 6
d1530 1
a1530 1
	aml_find_node(aml_root.child, "_PRW", acpi_foundprw, sc);
d1545 1
a1545 1
		if (aml_evalname(sc, aml_root.child, name, 0, NULL, &res) == 0) {
d1558 5
a1562 5
	sc->sc_tts = aml_searchname(aml_root.child, "_TTS");
	sc->sc_pts = aml_searchname(aml_root.child, "_PTS");
	sc->sc_wak = aml_searchname(aml_root.child, "_WAK");
	sc->sc_bfs = aml_searchname(aml_root.child, "_BFS");
	sc->sc_gts = aml_searchname(aml_root.child, "_GTS");
d1581 1
d1654 1
d1660 1
d1687 1
d1695 2
d1741 2
@


1.117
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@a89 2
struct gpe_block *acpi_find_gpe(struct acpi_softc *, int);

a175 3
				default:
					printf("rdio: invalid size %d\n", access_size);
					break;
a194 3
				default:
					printf("wrio: invalid size %d\n", access_size);
					break;
d269 1
a269 1
	if (!aml_evalname(sc, node->parent, "_STA", 0, NULL, &res))
d307 1
a307 1
	if (!aml_evalname(sc, node->parent, "_STA", 0, NULL, &res))
d615 1
a615 1
	aml_find_node(&aml_root, "_INI", acpi_inidev, sc);
d618 1
a618 1
	aml_find_node(&aml_root, "_PRT", acpi_foundprt, sc);
d622 1
a622 1
	aml_find_node(&aml_root, "_HID", acpi_foundec, sc);
d627 1
a627 1
	aml_find_node(&aml_root, "_HID", acpi_foundhid, sc);
d630 1
a630 1
	aml_find_node(&aml_root, "_DCK", acpi_founddock, sc);
a1140 3
void
acpi_add_gpeblock(struct acpi_softc *sc, int reg, int len, int gpe);

a1148 6
#if 0
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe0_blk, sc->sc_fadt->gpe0_blk_len>>1, 0);
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1, 
	    sc->sc_fadt->gpe1_base);
#endif

d1247 2
a1248 1
	struct gpe_block *ptbl;
d1250 1
a1250 4
	ptbl = acpi_find_gpe(sc, gpe);
	if (ptbl == NULL || handler == NULL)
		return -EINVAL;
	if (ptbl->handler != NULL) {
d1254 1
d1256 4
a1259 2
	ptbl->handler = handler;
	ptbl->arg = arg;
a1343 106
struct gpe_block *
acpi_find_gpe(struct acpi_softc *sc, int gpe)
{
#if 1
	if (gpe >= sc->sc_lastgpe)
		return NULL;
	return &sc->gpe_table[gpe];
#else
	SIMPLEQ_FOREACH(pgpe, &sc->sc_gpes, gpe_link) {
		if (gpe >= pgpe->start && gpe <= (pgpe->start+7))
			return &pgpe->table[gpe & 7];
	}
	return NULL;
#endif
}

#if 0
/* New GPE handling code: Create GPE block */
void
acpi_init_gpeblock(struct acpi_softc *sc, int reg, int len, int base)
{
	int i, j;

	if (!reg || !len)
		return;
	for (i=0; i<len; i++) {
		pgpe = acpi_os_malloc(sizeof(gpeblock));
		if (pgpe == NULL)
			return;

		/* Allocate GPE Handler Block */
		pgpe->start = base + i;
		acpi_bus_space_map(sc->sc_iot, reg+i,     1, 0, &pgpe->sts_ioh);
		acpi_bus_space_map(sc->sc_iot, reg+i+len, 1, 0, &pgpe->en_ioh);
		SIMPLEQ_INSERT_TAIL(&sc->sc_gpes, gpe, gpe_link);

		/* Clear pending GPEs */
		bus_space_write_1(sc->sc_iot, pgpe->sts_ioh, 0, 0xFF);
		bus_space_write_1(sc->sc_iot, pgpe->en_ioh,  0, 0x00);
	}

	/* Search for GPE handlers */
	for (i=0; i<len*8; i++) {
		char gpestr[32];
		struct aml_node *h;

		snprintf(gpestr, sizeof(gpestr), "\\_GPE._L%.2X", base+i);
		h = aml_searchnode(&aml_root, gpestr);
		if (acpi_set_gpehandler(sc, base+i, acpi_gpe_level, h, "level") != 0) {
			snprintf(gpestr, sizeof(gpestr), "\\_GPE._E%.2X", base+i);
			h = aml_searchnode(&aml_root, gpestr);
			acpi_set_gpehandler(sc, base+i, acpi_gpe_edge, h, "edge");
		}
	}
}

/* Process GPE interrupts */
int
acpi_handle_gpes(struct acpi_softc *sc)
{
	uint8_t en, sts;
	int processed, i;

	processed=0;
	SIMPLEQ_FOREACH(pgpe, &sc->sc_gpes, gpe_link) {
		sts = bus_space_read_1(sc->sc_iot, pgpe->sts_ioh, 0);
		en = bus_space_read_1(sc->sc_iot, pgpe->en_ioh, 0);
		for (i=0; i<8; i++) {
			if (en & sts & (1L << i)) {
				pgpe->table[i].active = 1;
				processed=1;
			}
		}
	}
	return processed;
}
#endif

void
acpi_add_gpeblock(struct acpi_softc *sc, int reg, int len, int gpe)
{
	int idx, jdx;
	u_int8_t en, sts;

	if (!reg || !len)
		return;
	for (idx=0; idx<len; idx++) {
		sts = inb(reg + idx);
		en  = inb(reg + len + idx);
		printf("-- gpe %.2x-%.2x : en:%.2x sts:%.2x  %.2x\n",
		    gpe+idx*8, gpe+idx*8+7, en, sts, en&sts);
		for (jdx=0; jdx<8; jdx++) {
			char gpestr[32];
			struct aml_node *l, *e;

			if (en & sts & (1L << jdx)) {
				snprintf(gpestr,sizeof(gpestr), "\\_GPE._L%.2X", gpe+idx*8+jdx);
				l = aml_searchname(&aml_root, gpestr);
				snprintf(gpestr,sizeof(gpestr), "\\_GPE._E%.2X", gpe+idx*8+jdx);
				e = aml_searchname(&aml_root, gpestr);
				printf("  GPE %.2x active L%x E%x\n", gpe+idx*8+jdx, l, e);
			}
		}
	}
}

a1350 6
#if 0
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe0_blk, sc->sc_fadt->gpe0_blk_len>>1, 0);
	acpi_add_gpeblock(sc, sc->sc_fadt->gpe1_blk, sc->sc_fadt->gpe1_blk_len>>1, 
	    sc->sc_fadt->gpe1_base);
#endif

d1383 1
a1383 1
	aml_find_node(&aml_root, "_PRW", acpi_foundprw, sc);
d1398 1
a1398 1
		if (aml_evalname(sc, &aml_root, name, 0, NULL, &res) == 0) {
d1411 5
a1415 5
	sc->sc_tts = aml_searchname(&aml_root, "_TTS");
	sc->sc_pts = aml_searchname(&aml_root, "_PTS");
	sc->sc_wak = aml_searchname(&aml_root, "_WAK");
	sc->sc_bfs = aml_searchname(&aml_root, "_BFS");
	sc->sc_gts = aml_searchname(&aml_root, "_GTS");
a1433 1
	memset(&env, 0, sizeof(env));
a1510 1
	memset(&env, 0, sizeof(env));
a1543 2
extern int aml_busy;

a1587 2
		if (aml_busy)
			continue;
@


1.116
log
@add acpithinkpad(4), an acpi support driver for ibm/lenovo
thinkpads.

provides functionality that the bios did on older, non-acpi
thinkpads like respond to screen brightness keys and toggle the
bluetooth device on and off.

ok deraadt@@ and marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.115 2008/04/24 13:57:49 jsing Exp $	*/
d90 2
d178 3
d200 3
d277 1
a277 1
	if (!aml_evalname(sc, node, "_STA", 0, NULL, &res))
d315 1
a315 1
	if (!aml_evalname(sc, node, "_STA", 0, NULL, &res))
d623 1
a623 1
	aml_find_node(aml_root.child, "_INI", acpi_inidev, sc);
d626 1
a626 1
	aml_find_node(aml_root.child, "_PRT", acpi_foundprt, sc);
d630 1
a630 1
	aml_find_node(aml_root.child, "_HID", acpi_foundec, sc);
d635 1
a635 1
	aml_find_node(aml_root.child, "_HID", acpi_foundhid, sc);
d638 1
a638 1
	aml_find_node(aml_root.child, "_DCK", acpi_founddock, sc);
d1149 3
d1160 6
d1264 4
a1267 1
	if (gpe >= sc->sc_lastgpe || handler == NULL)
d1269 1
a1269 2

	if (sc->gpe_table[gpe].handler != NULL) {
a1272 1

d1274 2
a1275 4
	sc->gpe_table[gpe].handler = handler;
	sc->gpe_table[gpe].arg = arg;

	/* Defer enabling GPEs */
d1360 106
d1473 6
d1511 1
a1511 1
	aml_find_node(aml_root.child, "_PRW", acpi_foundprw, sc);
d1526 1
a1526 1
		if (aml_evalname(sc, aml_root.child, name, 0, NULL, &res) == 0) {
d1539 5
a1543 5
	sc->sc_tts = aml_searchname(aml_root.child, "_TTS");
	sc->sc_pts = aml_searchname(aml_root.child, "_PTS");
	sc->sc_wak = aml_searchname(aml_root.child, "_WAK");
	sc->sc_bfs = aml_searchname(aml_root.child, "_BFS");
	sc->sc_gts = aml_searchname(aml_root.child, "_GTS");
d1562 1
d1640 1
d1674 2
d1720 2
@


1.115
log
@Introduce acpiasus(4), a driver for the ACPI based hotkeys found in many
ASUS laptops (including the ASUS EeePC) - largely based on NetBSD's
asus(4) driver. On the ASUS EeePC this allows us to enable/disable
wireless, change screen brightness and use the volume keys.

ok jsg@@, weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.113 2008/01/21 12:43:09 jsg Exp $	*/
d1858 2
d1863 1
@


1.114
log
@Get rid of acpi_s5 global variables; simply send SIGUSR2 instead of SUGUSR1
to tell init(8) to power down the machine.

ok krw@@
@
text
@d1856 2
@


1.113
log
@Check against RESET_REG_SUP in FADT before doing the acpi reset dance
after all, not doing so appears to break more machines than it fixes.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.112 2008/01/05 18:26:30 kettenis Exp $	*/
d109 1
a109 1
int acpi_s5, acpi_evindex;
@


1.112
log
@Never attach more acpicpu(4) devices than cpu(4) devices.  Always attach
the first acpicpu(4) device on non-MULTIPROCESSOR kernels, regardless of its
ACPI processor ID.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.111 2007/12/05 19:17:13 deraadt Exp $	*/
d1198 6
a1203 2
	/* FADT_RESET_REG_SUP is not properly set in some implementations */
	if (acpi_softc->sc_revision <= 1 || fadt->reset_reg.address == 0)
@


1.111
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.109 2007/12/02 22:18:06 fgsch Exp $	*/
d355 1
d359 1
d361 2
a362 1
	int proc_id = 0;
d374 3
d382 3
a384 5
#ifdef MULTIPROCESSOR
		if (proc_id && (proc_id >= LAPIC_MAP_SIZE ||
		    (acpi_lapic_flags[proc_id] & ACPI_PROC_ENABLE) == 0))
#else
		if (proc_id > 0)
d386 2
a387 1
			return 0;
@


1.110
log
@repair acpiopen/acpiclose and friends to handle the /dev/apmctl interface,
so that apmd(8) can actually work correctly against acpi(4), and thus,
even do the fancy -C/-A stuff; also tested by jmc
@
text
@d337 1
a337 1
	struct acpi_attach_args	*aaa = aux;
d341 1
a341 1
	if (strcmp(aaa->aaa_name, cf->cf_driver->cd_name))
d344 1
a344 1
	if (!acpi_probe(parent, cf, aaa))
d398 1
a398 1
	struct acpi_attach_args *aaa = aux;
d412 2
a413 2
	sc->sc_iot = aaa->aaa_iot;
	sc->sc_memt = aaa->aaa_memt;
d415 1
a415 1
	if (acpi_map(aaa->aaa_pbase, sizeof(struct acpi_rsdp), &handle)) {
@


1.109
log
@fix the trailing space for real now.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.108 2007/12/02 20:44:33 fgsch Exp $	*/
d42 4
d816 2
a817 2
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
d820 17
d844 1
d846 2
a847 2
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
d849 9
a857 2

	return (0);
d872 2
a873 2
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
d979 2
a980 2
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
@


1.108
log
@avoid trailing spaces on output; marco@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.107 2007/11/27 18:45:45 kettenis Exp $	*/
d554 1
a554 1
		printf(" %.4s ", entry->q_table);
d561 1
a561 1
		printf(" %.4s(S%d) ", wentry->q_node->name,
@


1.107
log
@Fix off-by-one that made us attach acpicpu0 and acpicpu1 on GENERIC kernels.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.106 2007/11/25 09:11:12 jsg Exp $	*/
d552 1
a552 1
	printf("%s: tables ", DEVNAME(sc));
d554 1
a554 1
		printf("%.4s ", entry->q_table);
d559 1
a559 1
	printf("%s: wakeup devices ", DEVNAME(sc));
d561 1
a561 1
		printf("%.4s(S%d) ", wentry->q_node->name,
@


1.106
log
@When available and ACPI is enabled use the ACPI reset method
to reboot.  This is required for some quirky sis machines
and likely others to reboot.

Tested by many. 'commit early commit often' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.105 2007/11/19 19:17:30 deraadt Exp $	*/
d376 1
a376 1
		if (proc_id > 1)
@


1.105
log
@sigh, amd64 still uses that stupid acpi_enabled variable...
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.102 2007/11/19 18:56:41 kettenis Exp $	*/
d1153 30
@


1.104
log
@softc's come initialized to 0, you know...
@
text
@d46 1
d474 2
@


1.103
log
@store revision; from jsg
@
text
@d46 2
a47 3
int acpi_enabled = 0;
int acpi_poll_enabled = 0;
int acpi_hasprocfvs = 0;
a421 5
	sc->sc_fadt = NULL;
	sc->sc_facs = NULL;
	sc->sc_powerbtn = 0;
	sc->sc_sleepbtn = 0;

a475 2

	acpi_enabled = 1;
@


1.102
log
@Initialize sc_facs earlier.

ok deraadt@@, beck@@, canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.101 2007/11/16 16:16:04 deraadt Exp $	*/
d417 2
a418 1
	printf(": rev %d", (int)rsdp->rsdp_revision);
@


1.101
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.100 2007/11/15 22:19:14 deraadt Exp $	*/
d405 1
d407 1
a407 1
#endif
a410 1

d466 13
a522 13

	/*
	 * Set up a pointer to the firmware control structure
	 */
	if (sc->sc_fadt->hdr_revision < 3 || sc->sc_fadt->x_firmware_ctl == 0)
		facspa = sc->sc_fadt->firmware_ctl;
	else
		facspa = sc->sc_fadt->x_firmware_ctl;

	if (acpi_map(facspa, sizeof(struct acpi_facs), &handle))
		printf(" !FACS");
	else
		sc->sc_facs = (struct acpi_facs *)handle.va;
@


1.100
log
@remove the #ifdef ACPI_ENABLE.  the EC codepath is either safe enough (and
will be improved), or it is unsafe because AML assumes it must be there
ok almost everyone
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.99 2007/11/15 22:16:31 mikeb Exp $	*/
a106 1
#ifdef __i386__
a108 6
#elif defined(__amd64__)
#define acpi_bus_space_map	_x86_memio_map
#define acpi_bus_space_unmap	_x86_memio_unmap
#else
#error ACPI supported on i386/amd64 only
#endif
@


1.99
log
@Make acpicpu(4) attach to the existing CPUs only.

Problem reported by form@@.  Fix idea by kettenis@@.
Lots of help from deraadt@@.  Tested by deraadt@@, form@@ and me.

ok deraadt marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.98 2007/11/14 20:29:06 deraadt Exp $	*/
a463 1
#ifdef ACPI_ENABLE
a471 1
#endif
d476 1
a476 1
	acpi_enabled=1;
a549 1
#ifdef ACPI_ENABLE
a559 1
#endif
a1117 1
#ifdef ACPI_ENABLE
a1164 1
#endif /* ACPI_ENABLE */
a1363 1
#ifdef ACPI_ENABLE
a1446 1
#endif
@


1.98
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.97 2007/11/12 21:38:00 deraadt Exp $	*/
d361 2
d374 12
@


1.97
log
@correct : vs , in attach-time messages
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.96 2007/11/06 22:12:34 deraadt Exp $	*/
d376 1
a376 1
 		break;
@


1.96
log
@all ACPI_ENABLE kernels need acpi_interrupt()
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.95 2007/11/06 01:05:28 deraadt Exp $	*/
d157 1
a157 1
			printf("Unable to map iospace!\n");
d377 1
a377 1
        default:
d422 1
a422 1
		printf(": can't allocate memory\n");
d428 1
a428 1
		printf(": can't load tables\n");
d446 1
a446 1
		printf(": no FADT\n");
d456 1
a456 1
		printf(": ACPI control unavailable\n");
a498 3
	/* Walk AML Tree */
	/* aml_walkroot(); */

d545 1
a545 1
			printf(": can't enable ACPI\n");
d562 2
a563 3
		printf("%.4s(S%d) ", 
		       wentry->q_node->name,
		       wentry->q_state);
d1186 1
a1186 1
		dnprintf(10, "error: GPE %.2x already enabled!\n", gpe);
d1254 2
a1255 1
	wq->q_wakepkg = (struct aml_value *)malloc(sizeof(struct aml_value), M_DEVBUF, M_NOWAIT);
d1582 2
a1583 2
acpi_map_address(struct acpi_softc *sc, struct acpi_gas *gas,  bus_addr_t base, bus_size_t size, 
		 bus_space_handle_t *pioh, bus_space_tag_t *piot)
@


1.95
log
@move acpi_read_pmreg() and acpi_write_pmreg() out of SMALL_KERNEL so
that acpi ramdisks can compile (obvious solution)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.94 2007/11/05 17:32:20 canacar Exp $	*/
d1112 1
a1112 2
/* move all stuff that doesn't go on the boot media in here */
#ifndef SMALL_KERNEL
d1160 4
@


1.94
log
@Establish the acpi interrupt earlier. Fixes problems with some
GENERIC.MP kernels not getting acpi interrupts. This is a
workaround until the real issue with late establishment is fixed.
ok weingart@@, beck@@, gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.93 2007/11/03 20:33:48 jordan Exp $	*/
d976 136
a1711 136
}

/* Read from power management register */
int
acpi_read_pmreg(struct acpi_softc *sc, int reg, int offset)
{
	bus_space_handle_t ioh;
	bus_size_t size, __size;
	int regval;

	__size = 0;
	/* Special cases: 1A/1B blocks can be OR'ed together */
	switch (reg) {
	case ACPIREG_PM1_EN:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_EN, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_EN, offset));
	case ACPIREG_PM1_STS:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_STS, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_STS, offset));
	case ACPIREG_PM1_CNT:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, offset));
	case ACPIREG_GPE_STS:
		__size = 1;
		dnprintf(50, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset,
		    sc->sc_fadt->gpe0_blk_len>>1, sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		__size = 1;
		dnprintf(50, "read GPE_EN   offset: %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	if (reg >= ACPIREG_MAXREG || sc->sc_pmregs[reg].size == 0)
		return (0);

	regval = 0;
	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;

	switch (size) {
	case 1:
		regval = bus_space_read_1(sc->sc_iot, ioh, offset);
		break;
	case 2:
		regval = bus_space_read_2(sc->sc_iot, ioh, offset);
		break;
	case 4:
		regval = bus_space_read_4(sc->sc_iot, ioh, offset);
		break;
	}

	dnprintf(30, "acpi_readpm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name,
	    sc->sc_pmregs[reg].addr, offset, regval);
	return (regval);
}

/* Write to power management register */
void
acpi_write_pmreg(struct acpi_softc *sc, int reg, int offset, int regval)
{
	bus_space_handle_t ioh;
	bus_size_t size, __size;

	__size = 0;
	/* Special cases: 1A/1B blocks can be written with same value */
	switch (reg) {
	case ACPIREG_PM1_EN:
		acpi_write_pmreg(sc, ACPIREG_PM1A_EN, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_EN, offset, regval);
		break;
	case ACPIREG_PM1_STS:
		acpi_write_pmreg(sc, ACPIREG_PM1A_STS, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_STS, offset, regval);
		break;
	case ACPIREG_PM1_CNT:
		acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, offset, regval);
		break;
	case ACPIREG_GPE_STS:
		__size = 1;
		dnprintf(50, "write GPE_STS offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		__size = 1;
		dnprintf(50, "write GPE_EN  offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	/* All special case return here */
	if (reg >= ACPIREG_MAXREG)
		return;

	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;
	switch (size) {
	case 1:
		bus_space_write_1(sc->sc_iot, ioh, offset, regval);
		break;
	case 2:
		bus_space_write_2(sc->sc_iot, ioh, offset, regval);
		break;
	case 4:
		bus_space_write_4(sc->sc_iot, ioh, offset, regval);
		break;
	}

	dnprintf(30, "acpi_writepm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name, sc->sc_pmregs[reg].addr, offset, regval);
@


1.93
log
@Added support for displaying wakeup devices
ok beck@@,weingart@@,gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.92 2007/10/11 16:48:21 kettenis Exp $	*/
d649 2
a1350 2

	acpi_attach_machdep(sc);
@


1.92
log
@When walking the tree yo find _PRT methods, check whether the device is
actually enabled and functioning.  Similar to what we do for _INI.

ok weingart@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.91 2007/10/08 04:15:15 krw Exp $	*/
d68 1
d392 1
d413 1
d562 10
d1095 46
d1180 1
@


1.91
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.90 2007/09/13 20:35:47 mk Exp $	*/
d298 2
d303 4
a306 6
	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpiprt";
d308 4
a311 1
	config_found(self, &aaa, acpi_print);
d313 20
@


1.90
log
@Remove unnecessary memset() (see aml_evalnode(9)) and a bit of KNF.

ok toby
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.89 2007/09/13 03:43:22 weingart Exp $	*/
d394 1
a394 1
	sc->sc_note = malloc(sizeof(struct klist), M_DEVBUF, M_NOWAIT);
a399 1
	memset(sc->sc_note, 0, sizeof(struct klist));
d597 1
a597 2
			ac = malloc(sizeof(struct acpi_ac), M_DEVBUF, M_WAITOK);
			memset(ac, 0, sizeof(struct acpi_ac));
d602 1
a602 3
			bat = malloc(sizeof(struct acpi_bat), M_DEVBUF,
			    M_WAITOK);
			memset(bat, 0, sizeof(struct acpi_bat));
d1073 1
a1073 2
	    M_DEVBUF, M_WAITOK);
	memset(sc->gpe_table, 0, sc->sc_lastgpe * sizeof(struct gpe_block));
@


1.89
log
@Implement ACPI 6.5.1 spec tree walk for _STA and _INI.
Fixes mk's laptop.  No regressions so far (thank you to the
testers).

ok gwk@@, mk@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.88 2007/04/17 16:07:45 mk Exp $	*/
d271 1
a271 2
	memset(&res, 0, sizeof res);
	if (! aml_evalname(sc, node, "_STA", 0, NULL, &res))
@


1.88
log
@Now that acpidock no longer hangs machines during boot (at least
according to the reports I've been getting) it should be safe to enable
it again, so remove the #if 0 stuff around it.

ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.87 2007/04/11 02:51:11 jordan Exp $	*/
d62 7
a68 6
void	acpi_founddock(struct aml_node *, void *);
void	acpi_foundpss(struct aml_node *, void *);
void	acpi_foundhid(struct aml_node *, void *);
void	acpi_foundec(struct aml_node *, void *);
void	acpi_foundtmp(struct aml_node *, void *);
void	acpi_inidev(struct aml_node *, void *);
a77 2
void	acpi_foundprt(struct aml_node *, void *);

d252 1
a252 1
void
d257 6
d265 3
a267 5
	 * XXX per the ACPI spec 6.5.1 only run _INI when device is there
	 * or when there is no _STA.
	 * The tricky bit is that the parent can have a _STA that is disabled
	 * and the children do not have a _STA.  In that case the _INI will
	 * execute!  This needs to be fixed.
d270 1
d272 3
a274 2
	if (aml_evalname(sc, node, "_STA", 0, NULL, &res)) 
		res.v_integer = STA_PRESENT; /* no _STA, fake it */
d276 2
a277 1
	if (res.v_integer & STA_PRESENT)
d279 11
a289 1
	aml_freevalue(&res);
d292 1
a292 1
void
d310 2
d1637 1
a1637 1
void
d1647 1
a1647 1
		return;
d1662 1
a1662 1
		return;
d1672 2
d1676 1
a1676 1
void
d1687 1
a1687 1
		return;
d1720 2
d1724 1
a1724 1
void
d1742 2
@


1.87
log
@Added changes for C-State
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.86 2007/03/26 03:52:49 marco Exp $	*/
a572 1
#if 0
a574 1
#endif
@


1.86
log
@Calculate minutes left more accurately.

From giovanni <qgiovanni@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.85 2007/03/03 15:27:35 mk Exp $	*/
d312 31
d568 2
a572 3
	/* attach cpu devices */
	aml_find_node(aml_root.child, "_PSS", acpi_foundpss, sc);

a577 3
	/* attach thermal zone devices, XXX MUST be last entry */
	aml_find_node(aml_root.child, "_TMP", acpi_foundtmp, sc);

a1618 40
}

void
acpi_foundtmp(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found thermal zone entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpitz";

	config_found(self, &aaa, acpi_print);
}

void
acpi_foundpss(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found pss entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpicpu";

	config_found(self, &aaa, acpi_print);
@


1.85
log
@Stop looking for acpidock until we fix that stuff that breaks all pre-60
series ThinkPads with acpidock(4) enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.84 2007/02/22 07:40:47 marco Exp $	*/
d830 1
a830 1
			pi->minutes_left = minutes / rate * 100;
@


1.84
log
@We were getting no interrupts in .MP.  There are 2 fixes; one in
acpi_machdep.c and move the interrupt establishment down after ioapic
has been initialized.

ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.83 2007/02/21 19:17:22 kettenis Exp $	*/
d543 1
d546 1
@


1.83
log
@Make an acpi-enabled GENERIC.MP work on systems that only support PIC mode.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.82 2007/02/19 23:42:39 jordan Exp $	*/
a480 2
	acpi_attach_machdep(sc);

d1227 2
@


1.82
log
@Added acpi_map_address function for mapping GAS/IO registers
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.81 2007/02/18 02:25:05 jordan Exp $	*/
a40 2
#include "ioapic.h"

a76 1
void	acpi_init_pic(struct acpi_softc *);
a276 20
acpi_init_pic(struct acpi_softc *sc)
{
	struct aml_node		*node;
	struct aml_value	arg;

	node = aml_searchname(&aml_root, "\\_PIC");
	if (node == 0)
		return;

	memset(&arg, 0, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
#if NIOAPIC > 0
	arg.v_integer = 1;
#else
	arg.v_integer = 0;
#endif
	aml_evalnode(sc, node, 1, &arg, NULL);
}

void
a479 2

	acpi_init_pic(sc);
@


1.81
log
@Added dynamic perfect hash for opcodes
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.80 2007/02/18 01:37:49 marco Exp $	*/
d1346 27
@


1.80
log
@Shave off another K pre compression.
Shuffle SMALL_KERNEL functions around so that we only have a single #ifndef
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.79 2007/02/17 23:59:03 marco Exp $	*/
d353 1
d410 3
@


1.79
log
@Add SMALL_KERNEL throught acpi to make it fit on boot media.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.78 2007/02/13 04:39:43 marco Exp $	*/
a255 343
/* Map Power Management registers */
void
acpi_map_pmregs(struct acpi_softc *sc)
{
	bus_addr_t addr;
	bus_size_t size;
	const char *name;
	int reg;

	for (reg = 0; reg < ACPIREG_MAXREG; reg++) {
		size = 0;
		switch (reg) {
		case ACPIREG_SMICMD:
			name = "smi";
			size = 1;
			addr = sc->sc_fadt->smi_cmd;
			break;
		case ACPIREG_PM1A_STS:
		case ACPIREG_PM1A_EN:
			name = "pm1a_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1a_evt_blk;
			if (reg == ACPIREG_PM1A_EN && addr) {
				addr += size;
				name = "pm1a_en";
			}
			break;
		case ACPIREG_PM1A_CNT:
			name = "pm1a_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1a_cnt_blk;
			break;
		case ACPIREG_PM1B_STS:
		case ACPIREG_PM1B_EN:
			name = "pm1b_sts";
			size = sc->sc_fadt->pm1_evt_len >> 1;
			addr = sc->sc_fadt->pm1b_evt_blk;
			if (reg == ACPIREG_PM1B_EN && addr) {
				addr += size;
				name = "pm1b_en";
			}
			break;
		case ACPIREG_PM1B_CNT:
			name = "pm1b_cnt";
			size = sc->sc_fadt->pm1_cnt_len;
			addr = sc->sc_fadt->pm1b_cnt_blk;
			break;
		case ACPIREG_PM2_CNT:
			name = "pm2_cnt";
			size = sc->sc_fadt->pm2_cnt_len;
			addr = sc->sc_fadt->pm2_cnt_blk;
			break;
#if 0
		case ACPIREG_PM_TMR:
			/* Allocated in acpitimer */
			name = "pm_tmr";
			size = sc->sc_fadt->pm_tmr_len;
			addr = sc->sc_fadt->pm_tmr_blk;
			break;
#endif
		case ACPIREG_GPE0_STS:
		case ACPIREG_GPE0_EN:
			name = "gpe0_sts";
			size = sc->sc_fadt->gpe0_blk_len >> 1;
			addr = sc->sc_fadt->gpe0_blk;

			dnprintf(20, "gpe0 block len : %x\n",
			    sc->sc_fadt->gpe0_blk_len >> 1);
			dnprintf(20, "gpe0 block addr: %x\n",
			    sc->sc_fadt->gpe0_blk);
			if (reg == ACPIREG_GPE0_EN && addr) {
				addr += size;
				name = "gpe0_en";
			}
			break;
		case ACPIREG_GPE1_STS:
		case ACPIREG_GPE1_EN:
			name = "gpe1_sts";
			size = sc->sc_fadt->gpe1_blk_len >> 1;
			addr = sc->sc_fadt->gpe1_blk;

			dnprintf(20, "gpe1 block len : %x\n",
			    sc->sc_fadt->gpe1_blk_len >> 1);
			dnprintf(20, "gpe1 block addr: %x\n",
			    sc->sc_fadt->gpe1_blk);
			if (reg == ACPIREG_GPE1_EN && addr) {
				addr += size;
				name = "gpe1_en";
			}
			break;
		}
		if (size && addr) {
			dnprintf(50, "mapping: %.4x %.4x %s\n",
			    addr, size, name);

			/* Size and address exist; map register space */
			bus_space_map(sc->sc_iot, addr, size, 0,
			    &sc->sc_pmregs[reg].ioh);

			sc->sc_pmregs[reg].name = name;
			sc->sc_pmregs[reg].size = size;
			sc->sc_pmregs[reg].addr = addr;
		}
	}
}

/* Read from power management register */
int
acpi_read_pmreg(struct acpi_softc *sc, int reg, int offset)
{
	bus_space_handle_t ioh;
	bus_size_t size, __size;
	int regval;

	__size = 0;
	/* Special cases: 1A/1B blocks can be OR'ed together */
	switch (reg) {
	case ACPIREG_PM1_EN:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_EN, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_EN, offset));
	case ACPIREG_PM1_STS:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_STS, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_STS, offset));
	case ACPIREG_PM1_CNT:
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_CNT, offset) |
		    acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, offset));
	case ACPIREG_GPE_STS:
		__size = 1;
		dnprintf(50, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset,
		    sc->sc_fadt->gpe0_blk_len>>1, sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		__size = 1;
		dnprintf(50, "read GPE_EN   offset: %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	if (reg >= ACPIREG_MAXREG || sc->sc_pmregs[reg].size == 0)
		return (0);

	regval = 0;
	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;

	switch (size) {
	case 1:
		regval = bus_space_read_1(sc->sc_iot, ioh, offset);
		break;
	case 2:
		regval = bus_space_read_2(sc->sc_iot, ioh, offset);
		break;
	case 4:
		regval = bus_space_read_4(sc->sc_iot, ioh, offset);
		break;
	}

	dnprintf(30, "acpi_readpm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name,
	    sc->sc_pmregs[reg].addr, offset, regval);
	return (regval);
}

/* Write to power management register */
void
acpi_write_pmreg(struct acpi_softc *sc, int reg, int offset, int regval)
{
	bus_space_handle_t ioh;
	bus_size_t size, __size;

	__size = 0;
	/* Special cases: 1A/1B blocks can be written with same value */
	switch (reg) {
	case ACPIREG_PM1_EN:
		acpi_write_pmreg(sc, ACPIREG_PM1A_EN, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_EN, offset, regval);
		break;
	case ACPIREG_PM1_STS:
		acpi_write_pmreg(sc, ACPIREG_PM1A_STS, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_STS, offset, regval);
		break;
	case ACPIREG_PM1_CNT:
		acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, offset, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, offset, regval);
		break;
	case ACPIREG_GPE_STS:
		__size = 1;
		dnprintf(50, "write GPE_STS offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_STS;
		}
		break;
	case ACPIREG_GPE_EN:
		__size = 1;
		dnprintf(50, "write GPE_EN  offset: %.2x %.2x %.2x %.2x\n",
		    offset, sc->sc_fadt->gpe0_blk_len>>1,
		    sc->sc_fadt->gpe1_blk_len>>1, regval);
		if (offset < (sc->sc_fadt->gpe0_blk_len >> 1)) {
			reg = ACPIREG_GPE0_EN;
		}
		break;
	}

	/* All special case return here */
	if (reg >= ACPIREG_MAXREG)
		return;

	ioh = sc->sc_pmregs[reg].ioh;
	size = sc->sc_pmregs[reg].size;
	if (__size)
		size = __size;
	if (size > 4)
		size = 4;
	switch (size) {
	case 1:
		bus_space_write_1(sc->sc_iot, ioh, offset, regval);
		break;
	case 2:
		bus_space_write_2(sc->sc_iot, ioh, offset, regval);
		break;
	case 4:
		bus_space_write_4(sc->sc_iot, ioh, offset, regval);
		break;
	}

	dnprintf(30, "acpi_writepm: %s = %.4x:%.4x %x\n",
	    sc->sc_pmregs[reg].name, sc->sc_pmregs[reg].addr, offset, regval);
}

void
acpi_inidev(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct aml_value	res;

	/*
	 * XXX per the ACPI spec 6.5.1 only run _INI when device is there
	 * or when there is no _STA.
	 * The tricky bit is that the parent can have a _STA that is disabled
	 * and the children do not have a _STA.  In that case the _INI will
	 * execute!  This needs to be fixed.
	 */

	memset(&res, 0, sizeof res);
	if (aml_evalname(sc, node, "_STA", 0, NULL, &res)) 
		res.v_integer = STA_PRESENT; /* no _STA, fake it */

	if (res.v_integer & STA_PRESENT)
		aml_evalnode(sc, node, 0, NULL, NULL);
	aml_freevalue(&res);
}

#ifndef SMALL_KERNEL
void
acpi_foundtmp(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found thermal zone entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpitz";

	config_found(self, &aaa, acpi_print);
}

void
acpi_foundpss(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found pss entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpicpu";

	config_found(self, &aaa, acpi_print);
}

void
acpi_foundec(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct aml_value	 res;
	struct acpi_attach_args	aaa;

	if (aml_evalnode(sc, node, 0, NULL, &res) != 0)
		return;

	switch (res.type) {
	case AML_OBJTYPE_STRING:
		dev = res.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(aml_val2int(&res));
		break;
	default:
		dev = "unknown";
		break;
	}

	if (strcmp(dev, ACPI_DEV_ECD))
		return;

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpiec";
	config_found(self, &aaa, acpi_print);
	aml_freevalue(&res);
}

d257 1
a257 1
acpi_foundhid(struct aml_node *node, void *arg)
d260 1
a260 4
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct aml_value	 res;
	struct acpi_attach_args	aaa;
d262 7
a268 3
	dnprintf(10, "found hid device: %s ", node->parent->name);
	if (aml_evalnode(sc, node, 0, NULL, &res) != 0)
		return;
d270 3
a272 12
	switch (res.type) {
	case AML_OBJTYPE_STRING:
		dev = res.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(aml_val2int(&res));
		break;
	default:
		dev = "unknown";
		break;
	}
	dnprintf(10, "	device: %s\n", dev);
d274 2
a275 17
	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;

	if (!strcmp(dev, ACPI_DEV_AC))
		aaa.aaa_name = "acpiac";
	else if (!strcmp(dev, ACPI_DEV_CMB))
		aaa.aaa_name = "acpibat";
	else if (!strcmp(dev, ACPI_DEV_LD) ||
	    !strcmp(dev, ACPI_DEV_PBD) ||
	    !strcmp(dev, ACPI_DEV_SBD))
		aaa.aaa_name = "acpibtn";

	if (aaa.aaa_name)
		config_found(self, &aaa, acpi_print);
a279 21
acpi_founddock(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct acpi_attach_args	aaa;

	dnprintf(10, "found dock entry: %s\n", node->parent->name);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;
	aaa.aaa_name = "acpidock";

	config_found(self, &aaa, acpi_print);
}
#endif /* SMALL_KERNEL */

void
d476 1
a476 2

#endif
d756 166
d1328 256
a1583 1
	kthread_exit(0);
d1587 1
a1587 1
acpi_create_thread(void *arg)
d1589 4
a1592 1
	struct acpi_softc *sc = arg;
d1594 1
a1594 8
	if (kthread_create(acpi_isr_thread, sc->sc_thread, NULL, DEVNAME(sc))
	    != 0) {
		printf("%s: unable to create isr thread, GPEs disabled\n",
		    DEVNAME(sc));
		return;
	}
}
#endif /* SMALL_KERNEL */
d1596 6
a1601 5
int
acpiopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct acpi_softc *sc;
	int error = 0;
d1603 1
a1603 5
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
		return (ENXIO);

	return (error);
d1606 2
a1607 2
int
acpiclose(dev_t dev, int flag, int mode, struct proc *p)
d1609 6
a1614 1
	struct acpi_softc *sc;
d1616 6
a1621 3
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
		return (ENXIO);
d1623 1
a1623 1
	return (0);
d1626 2
a1627 2
int
acpiioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d1629 5
a1633 8
	int error = 0;
#ifndef SMALL_KERNEL
	struct acpi_softc *sc;
	struct acpi_ac *ac;
	struct acpi_bat *bat;
	struct apm_power_info *pi = (struct apm_power_info *)data;
	int bats;
	unsigned int remaining, rem, minutes, rate;
d1635 2
a1636 3
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
		return (ENXIO);
d1638 11
a1648 13
	ACPI_LOCK(sc);
	/* fake APM */
	switch (cmd) {
	case APM_IOC_GETPOWER:
		/* A/C */
		pi->ac_state = APM_AC_UNKNOWN;
		SLIST_FOREACH(ac, &sc->sc_ac, aac_link) {
			if (ac->aac_softc->sc_ac_stat == PSR_ONLINE)
				pi->ac_state = APM_AC_ON;
			else if (ac->aac_softc->sc_ac_stat == PSR_OFFLINE)
				if (pi->ac_state == APM_AC_UNKNOWN)
					pi->ac_state = APM_AC_OFF;
		}
d1650 2
a1651 11
		/* battery */
		pi->battery_state = APM_BATT_UNKNOWN;
		pi->battery_life = 0;
		pi->minutes_left = 0;
		bats = 0;
		remaining = rem = 0;
		minutes = 0;
		rate = 0;
		SLIST_FOREACH(bat, &sc->sc_bat, aba_link) {
			if (bat->aba_softc->sc_bat_present == 0)
				continue;
d1653 9
a1661 2
			if (bat->aba_softc->sc_bif.bif_last_capacity == 0)
				continue;
d1663 8
a1670 6
			bats++;
			rem = (bat->aba_softc->sc_bst.bst_capacity * 100) /
			    bat->aba_softc->sc_bif.bif_last_capacity;
			if (rem > 100)
				rem = 100;
			remaining += rem;
d1672 3
a1674 28
			if (bat->aba_softc->sc_bst.bst_rate == BST_UNKNOWN)
				continue;
			else if (bat->aba_softc->sc_bst.bst_rate > 1)
				rate = bat->aba_softc->sc_bst.bst_rate;

			minutes += bat->aba_softc->sc_bst.bst_capacity;
		}

		if (bats == 0) {
			pi->battery_state = APM_BATTERY_ABSENT;
			pi->battery_life = 0;
			pi->minutes_left = (unsigned int)-1;
			break;
		}

		if (pi->ac_state == APM_AC_ON || rate == 0)
			pi->minutes_left = (unsigned int)-1;
		else
			pi->minutes_left = minutes / rate * 100;

		/* running on battery */
		pi->battery_life = remaining / bats;
		if (pi->battery_life > 50)
			pi->battery_state = APM_BATT_HIGH;
		else if (pi->battery_life > 25)
			pi->battery_state = APM_BATT_LOW;
		else
			pi->battery_state = APM_BATT_CRITICAL;
d1676 6
a1682 1

d1684 2
a1685 1
		error = ENOTTY;
d1687 1
d1689 5
a1693 6
	ACPI_UNLOCK(sc);
#else
	error = ENXIO;
#endif /* SMALL_KERNEL */
	return (error);
}
d1695 8
a1702 4
void
acpi_filtdetach(struct knote *kn)
{
	struct acpi_softc *sc = kn->kn_hook;
d1704 3
a1706 3
	ACPI_LOCK(sc);
	SLIST_REMOVE(sc->sc_note, kn, knote, kn_selnext);
	ACPI_UNLOCK(sc);
d1709 2
a1710 2
int
acpi_filtread(struct knote *kn, long hint)
d1712 4
a1715 3
	/* XXX weird kqueue_scan() semantics */
	if (hint & !kn->kn_data)
		kn->kn_data = hint;
d1717 1
a1717 2
	return (1);
}
d1719 6
a1724 4
int
acpikqfilter(dev_t dev, struct knote *kn)
{
	struct acpi_softc *sc;
d1726 1
a1726 19
	if (!acpi_cd.cd_ndevs || minor(dev) != 0 ||
	    !(sc = acpi_cd.cd_devs[minor(dev)]))
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &acpiread_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = sc;

	ACPI_LOCK(sc);
	SLIST_INSERT_HEAD(sc->sc_note, kn, kn_selnext);
	ACPI_UNLOCK(sc);

	return (0);
d1728 1
@


1.78
log
@Add smarter _INI code.  This helps with some dissapearing devices.

ok kettenis jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.77 2007/01/31 23:30:51 gwk Exp $	*/
d245 1
d250 1
d521 1
d664 1
d731 1
d736 1
a736 1

d833 1
a833 1
	//aml_walkroot();
d835 1
d864 2
d900 1
d917 1
d944 1
d985 1
d1144 1
d1466 101
d1595 2
d1601 1
a1601 1
	int error = 0, bats;
d1680 3
a1729 100
}

void
acpi_isr_thread(void *arg)
{
	struct acpi_thread *thread = arg;
	struct acpi_softc  *sc = thread->sc;
	u_int32_t gpe;

	/*
	 * If we have an interrupt handler, we can get notification
	 * when certain status bits changes in the ACPI registers,
	 * so let us enable some events we can forward to userland
	 */
	if (sc->sc_interrupt) {
		int16_t flag;

		dnprintf(1,"slpbtn:%c  pwrbtn:%c\n",
		    sc->sc_fadt->flags & FADT_SLP_BUTTON ? 'n' : 'y',
		    sc->sc_fadt->flags & FADT_PWR_BUTTON ? 'n' : 'y');
		dnprintf(10, "Enabling acpi interrupts...\n");
		sc->sc_wakeup = 1;

		/* Enable Sleep/Power buttons if they exist */
		flag = acpi_read_pmreg(sc, ACPIREG_PM1_EN, 0);
		if (!(sc->sc_fadt->flags & FADT_PWR_BUTTON)) {
			flag |= ACPI_PM1_PWRBTN_EN;
		}
		if (!(sc->sc_fadt->flags & FADT_SLP_BUTTON)) {
			flag |= ACPI_PM1_SLPBTN_EN;
		}
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, 0, flag);

		/* Enable handled GPEs here */
		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			if (sc->gpe_table[gpe].handler)
				acpi_enable_onegpe(sc, gpe, 1);
		}
	}

	while (thread->running) {
		dnprintf(10, "sleep... %d\n", sc->sc_wakeup);
		while (sc->sc_wakeup)
			tsleep(sc, PWAIT, "acpi_idle", 0);
		sc->sc_wakeup = 1;
		dnprintf(10, "wakeup..\n");

		for (gpe = 0; gpe < sc->sc_lastgpe; gpe++) {
			struct gpe_block *pgpe = &sc->gpe_table[gpe];

			if (pgpe->active) {
				pgpe->active = 0;
				dnprintf(50, "softgpe: %.2x\n", gpe);
				if (pgpe->handler)
					pgpe->handler(sc, gpe, pgpe->arg);
			}
		}
		if (sc->sc_powerbtn) {
			sc->sc_powerbtn = 0;

			aml_notify_dev(ACPI_DEV_PBD, 0x80);

			acpi_evindex++;
			dnprintf(1,"power button pressed\n");
			KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_PWRBTN,
			    acpi_evindex));
		}
		if (sc->sc_sleepbtn) {
			sc->sc_sleepbtn = 0;

			aml_notify_dev(ACPI_DEV_SBD, 0x80);

			acpi_evindex++;
			dnprintf(1,"sleep button pressed\n");
			KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_SLPBTN,
			    acpi_evindex));
		}

		/* handle polling here to keep code non-concurrent*/
		if (sc->sc_poll) {
			sc->sc_poll = 0;
			acpi_poll_notify();
		}
	}
	free(thread, M_DEVBUF);

	kthread_exit(0);
}

void
acpi_create_thread(void *arg)
{
	struct acpi_softc *sc = arg;

	if (kthread_create(acpi_isr_thread, sc->sc_thread, NULL, DEVNAME(sc))
	    != 0) {
		printf("%s: unable to create isr thread, GPEs disabled\n",
		    DEVNAME(sc));
		return;
	}
@


1.77
log
@Introduce acpi_hasprocfvs thats "ACPI Has Processor Frequency and Voltage
Scalling" a global flag set by acicpu attach to indicate that ACPI is
handling fvs through the _PSS objects. This will fix disappearing
EST/powernow when booting kernels with acpi enabled, as acpicpu isnt
compiled into GENERIC yet. Also in cases where acpicpu is built in and
legacy EST/powernow work but acpi is missing the _PSS object, the legacy
routines will be used.

tested by dim@@, and Nick Nauwelaerts <nick AT nauwelaerts.net>
ok marco@@, dim@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.76 2007/01/22 19:47:11 mk Exp $	*/
d500 1
d502 15
a516 1
	aml_evalnode(sc, node, 0, NULL, NULL);
@


1.76
log
@Actually look for docking stations by looking for _DCK nodes.

ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.75 2007/01/02 00:51:15 marco Exp $	*/
d50 1
@


1.75
log
@On some systems EC must be attached as the first device.  Move EC from
generic _HID devices to its own routine to force first attach.  Bug found
and debugged by joris@@

Code mostly written by joris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.74 2006/12/26 23:58:08 marco Exp $	*/
d63 1
d627 20
d926 3
@


1.74
log
@Add polling to devices that require it such as acpibat and acpitz.
Use the same tsleep/wakeup mechanism as the interrupt code to keep it non-
concurrent.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.73 2006/12/21 19:59:02 deraadt Exp $	*/
d65 1
d543 37
a618 2
	else if (!strcmp(dev, ACPI_DEV_ECD))
		aaa.aaa_name = "acpiec";
d897 4
a900 4
	/*
	 * attach embedded controller, battery, power supply and button
	 * devices
	 */
@


1.73
log
@even more knf love
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.72 2006/12/21 05:57:17 marco Exp $	*/
d49 1
d782 3
d1611 6
@


1.72
log
@Remove some leftover acpiec gpe/interrupt code.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.71 2006/12/20 17:33:38 deraadt Exp $	*/
d159 1
a159 1
		for (reg=0; reg < len; reg += access_size) {
d225 1
a225 1
		for (idx=reg; idx<reg+len; idx++) {
d1061 1
a1061 1
	for (idx=0; idx<sc->sc_lastgpe; idx+=8) {
d1068 1
a1068 1
			for (jdx=0; jdx<8; jdx++) {
d1191 1
a1191 1
	for (idx=0; idx<sc->sc_lastgpe; idx+=8) {
d1195 1
a1195 1
	for (idx=0; idx<sc->sc_lastgpe; idx++) {
d1201 1
a1201 1
					    "level");
d1208 1
a1208 1
						    "edge");
d1565 1
a1565 1
		for (gpe=0; gpe<sc->sc_lastgpe; gpe++) {
d1578 1
a1578 1
		for (gpe=0; gpe < sc->sc_lastgpe; gpe++) {
@


1.71
log
@oops, name already used
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.70 2006/12/20 17:25:26 deraadt Exp $	*/
d1056 1
a1056 1
	u_int32_t ec, processed, sts, en, idx, jdx;
a1057 1
	ec = 0;
a1090 13
#if 0
	if (ec) {
		if (acpiec_intr(sc->sc_ec))
			processed = 1;

		sts = sc->sc_ec_gpemask;
		en  = acpi_read_pmreg(sc, ACPIREG_GPE0_EN, 0);

		/* enable SCI once again */
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS, 0, sts);
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 0, en | sts);
	}
#endif
d1097 1
a1097 1
	return (processed | ec);
a1568 5
#if 0
		/* Enable EC interrupt */
		if (sc->sc_ec != NULL)
			acpi_enable_gpe(sc, sc->sc_ec_gpemask);
#endif
@


1.70
log
@rename __acpi_enable_gpe(); ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.69 2006/12/20 17:04:00 deraadt Exp $	*/
d81 1
a81 1
void	acpi_enable_gpe(struct acpi_softc *, int, int);
d1115 1
a1115 1
acpi_enable_gpe(struct acpi_softc *sc, int gpe, int enable)
d1581 1
a1581 1
				acpi_enable_gpe(sc, gpe, 1);
@


1.69
log
@acpi_unmap_pmregs() is not used, ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.68 2006/12/19 04:09:11 deraadt Exp $	*/
d81 1
a81 1
void    __acpi_enable_gpe(struct acpi_softc *, int, int);
d1115 1
a1115 1
__acpi_enable_gpe(struct acpi_softc *sc, int gpe, int enable)
d1581 1
a1581 1
				__acpi_enable_gpe(sc, gpe, 1);
@


1.68
log
@simplify some low-level methods substantially (shrinking code); ok marco jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.67 2006/12/06 17:45:57 mk Exp $	*/
a60 1
void	acpi_unmap_pmregs(struct acpi_softc *);
a351 13
		}
	}
}

void
acpi_unmap_pmregs(struct acpi_softc *sc)
{
	int idx;

	for (idx = 0; idx < ACPIREG_MAXREG; idx++) {
		if (sc->sc_pmregs[idx].size) {
			bus_space_unmap(sc->sc_iot, sc->sc_pmregs[idx].ioh,
			    sc->sc_pmregs[idx].size);
@


1.67
log
@malloc(..., M_NOWAIT) with no NULL check is bad.  If allocation fails,
complain, clean up, and bail out of attach.

input and ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.66 2006/11/28 20:25:59 jordan Exp $	*/
d83 2
a84 2
int     acpi_gpe_level(struct acpi_softc *, int, void *);
int     acpi_gpe_edge(struct acpi_softc *, int, void *);
d105 1
a105 1
int acpi_s5, acpi_evindex, icount;
d108 2
a109 2
#define acpi_bus_space_map     _bus_space_map
#define acpi_bus_space_unmap   _bus_space_unmap
d111 2
a112 2
#define acpi_bus_space_map     _x86_memio_map
#define acpi_bus_space_unmap   _x86_memio_unmap
d127 2
a128 2
acpi_gasio(struct acpi_softc *sc, int iodir, int iospace, uint64_t address, 
	   int access_size, int len, void *buffer)
d139 1
a139 1
		 iospace, address, (iodir == ACPI_IOWRITE) ? "write" : "read");
d146 1
a146 1
		if (iodir == ACPI_IOREAD) 
d166 2
a167 2
					dnprintf(80, "os_in8(%llx) = %x\n", reg+
					    address, *(uint8_t *)(pb+reg));
d170 4
a173 3
					*(uint16_t *)(pb+reg) = bus_space_read_2
					    (sc->sc_iot, ioh, reg);
					dnprintf(80, "os_in16(%llx) = %x\n", reg					    +address, *(uint16_t *)(pb+reg));
d176 2
a177 1
					*(uint32_t *)(pb+reg) = bus_space_read_4					    (sc->sc_iot, ioh, reg);
d180 1
a180 2
			}
			else {
d183 4
a186 3
					bus_space_write_1(sc->sc_iot, ioh, reg, 					    *(uint8_t *)(pb+reg));
					dnprintf(80, "os_out8(%llx,%x)\n", reg+
					    address, *(uint8_t *)(pb+reg));
d189 1
a189 1
					bus_space_write_2(sc->sc_iot, ioh, reg, 
d191 2
a192 1
					dnprintf(80, "os_out16(%llx,%x)\n", reg+					    address, *(uint16_t *)(pb+reg));
d195 1
a195 1
					bus_space_write_4(sc->sc_iot, ioh, reg, 
d213 1
a213 1
		/* format of address: 
d220 1
a220 1
		tag = pci_make_tag(pc, 
d229 2
a230 16
				switch (idx & 0x3) {
				case 0:
					*pb = ival;
					break;
				case 1:
					*pb = (ival >> 8);
					break;
				case 2:
					*pb = (ival >> 16);
					break;
				case 3:
					*pb = (ival >> 24);
					break;
				}
			}
			else {
d232 2
a233 18
				switch (idx & 0x3) {
				case 0:
					ival &= ~0xFF;
					ival |= sval;
					break;
				case 1:
					ival &= ~0xFF00;
					ival |= (sval << 8L);
					break;
				case 2:
					ival &= ~0xFF0000;
					ival |= (sval << 16L);
					break;
				case 3:
					ival &= ~0xFF000000L;
					ival |= (sval << 24L);
					break;
				}
d334 1
a334 1
			dnprintf(20, "gpe1 block addr: %x\n",	
d392 1
a392 1
		dnprintf(50, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset, 
d400 1
a400 1
		dnprintf(50, "read GPE_EN   offset: %.2x %.2x %.2x\n", 
d406 1
a406 1
		break;	
d408 1
a408 1
	
d462 1
a462 1
		dnprintf(50, "write GPE_STS offset: %.2x %.2x %.2x %.2x\n", 
d471 1
a471 1
		dnprintf(50, "write GPE_EN  offset: %.2x %.2x %.2x %.2x\n", 
d477 1
a477 1
		break;	
d560 1
a560 1
	struct aml_value        res;
d564 1
a564 1
	if (aml_evalnode(sc, node, 0, NULL, &res) != 0) 
d775 1
a775 1
	
d822 1
a822 1
	
d945 2
a946 2
		       hdr->signature[0], hdr->signature[1],
		       hdr->signature[2], hdr->signature[3]);
d1136 1
a1136 1
	dnprintf(50, "%sabling GPE %.2x (current: %sabled) %.2x\n", 
d1367 1
a1367 1
	
d1370 1
a1370 1
	
d1617 1
a1617 1
				if (pgpe->handler) {
a1618 1
				}
@


1.66
log
@Fixed clearing arg for acpi_init_pic
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.65 2006/11/27 19:32:18 kettenis Exp $	*/
d718 5
@


1.65
log
@Don't spam dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.64 2006/11/27 15:20:26 jordan Exp $	*/
d639 1
@


1.64
log
@Fixes for acpiprt routing
Post-parse fixup for namerefs
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.63 2006/11/25 16:26:08 marco Exp $	*/
d958 3
@


1.63
log
@Don't handle acpiev events inside the gpe handler since this causes deadlocks.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.62 2006/11/15 21:41:51 kettenis Exp $	*/
d661 1
a661 1
	aaa.aaa_node = node->parent;
d784 3
@


1.62
log
@Hook up acpi apic interrupt routing support to generic acpi code.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.61 2006/11/02 05:58:49 marco Exp $	*/
a1656 2
		if (sc->sc_ec)
			acpiec_handle_events(sc->sc_ec);
@


1.61
log
@Kill acpiec attach function and add its functionality to the generic _HID
device attach

prodded and ok jordan
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.60 2006/11/02 05:52:24 marco Exp $	*/
d41 2
d76 3
d629 39
d835 2
d868 5
a872 7
		if (memcmp(entry->q_table, HPET_SIG,
		    sizeof(HPET_SIG) - 1) == 0) {
			struct acpi_attach_args aaa;

			memset(&aaa, 0, sizeof(aaa));
			aaa.aaa_iot = sc->sc_iot;
			aaa.aaa_memt = sc->sc_memt;
d874 2
a875 2
			aaa.aaa_pcit = sc->sc_pcit;
			aaa.aaa_smbust = sc->sc_smbust;
d877 2
a878 3
			aaa.aaa_table = entry->q_table;
			config_found_sm(self, &aaa, acpi_print, acpi_submatch);
		}
d885 3
@


1.60
log
@Fix comments to reflect reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.59 2006/10/19 08:56:46 marco Exp $	*/
a62 1
void	acpi_foundec(struct aml_node *, void *);
d616 1
a616 40

	if (aaa.aaa_name)
		config_found(self, &aaa, acpi_print);
	aml_freevalue(&res);
}


void
acpi_foundec(struct aml_node *node, void *arg)
{
	struct acpi_softc	*sc = (struct acpi_softc *)arg;
	struct device		*self = (struct device *)arg;
	const char		*dev;
	struct aml_value	 res;
	struct acpi_attach_args	 aaa;

	dnprintf(10, "found hid device: %s ", node->parent->name);
	if (aml_evalnode(sc, node, 0, NULL, &res) != 0)
		return;

	switch (res.type) {
	case AML_OBJTYPE_STRING:
		dev = res.v_string;
		break;
	case AML_OBJTYPE_INTEGER:
		dev = aml_eisaid(aml_val2int(&res));
		break;
	default:
		dev = "unknown";
		break;
	}
	dnprintf(10, "	device: %s\n", dev);

	memset(&aaa, 0, sizeof(aaa));
	aaa.aaa_iot = sc->sc_iot;
	aaa.aaa_memt = sc->sc_memt;
	aaa.aaa_node = node->parent;
	aaa.aaa_dev = dev;

	if (!strcmp(dev, ACPI_DEV_ECD))
a620 1

d843 4
a846 4
	/* attach embedded controller devices */
	aml_find_node(aml_root.child, "_HID", acpi_foundec, sc);

	/* attach battery, power supply and button devices */
@


1.59
log
@Replace ACPI ioctls with APM ioctls.  This makes ACPI talk the same protocol
as APM therefore userspace can now retrieve power information in the same
fashion as all other apm arches (zaurus, macppc, i386 etc).

To use force the use of acpi device like so: apmd -f /dev/acpi

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.58 2006/10/19 03:24:45 jordan Exp $	*/
d881 1
a881 1
	/* attach devices found in dsdt */
d884 1
a884 1
	/* attach devices found in dsdt */
d886 2
d890 1
a890 1
	/* attach devices found in dsdt */
d893 1
a893 1
	/* attach devices found in dsdt */
@


1.58
log
@Fixed GPE debug levels
Fixed ref counter on temporary bufferfields
DSDT parsing fully working on IBM Thinkpad
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.57 2006/10/15 15:22:17 jordan Exp $	*/
d41 2
d690 3
d894 19
a1418 3
	if (!(flag & FREAD) || (flag & FWRITE))
		error = EINVAL;

d1438 5
a1442 1
	int error = 0;
d1449 1
d1451 46
a1496 5
	case ACPI_IOC_SETSLEEPSTATE:
		if (suser(p, 0) != 0)
			error = EPERM;
		else {
			acpi_enter_sleep_state(sc, *(int *)data);
a1497 1
		break;
d1499 13
a1511 9
	case ACPI_IOC_GETFACS:
		if (suser(p, 0) != 0)
			error = EPERM;
		else {
			struct acpi_facs *facs = (struct acpi_facs *)data;

			bcopy(sc->sc_facs, facs, sc->sc_facs->length);
		}
		break;
a1512 25
	case ACPI_IOC_GETTABLE:
		if (suser(p, 0) != 0)
			error = EPERM;
		else {
			struct acpi_table *table = (struct acpi_table *)data;
			struct acpi_table_header *hdr;
			struct acpi_q *entry;

			error = ENOENT;
			SIMPLEQ_FOREACH(entry, &sc->sc_tables, q_next) {
				if (table->offset-- == 0) {
					hdr = (struct acpi_table_header *)
					    entry->q_table;
					if (table->table == NULL) {
						table->size = hdr->length;
						error = 0;
					} else if (hdr->length > table->size)
						error = ENOSPC;
					else
						error = copyout(hdr,
						    table->table, hdr->length);
					break;
				}
			}
		}
@


1.57
log
@Removed old GPE handler code remnants
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.56 2006/10/12 16:38:21 jordan Exp $	*/
d413 1
a413 1
		dnprintf(0, "read GPE_STS  offset: %.2x %.2x %.2x\n", offset, 
d421 1
a421 1
		dnprintf(0, "read GPE_EN   offset: %.2x %.2x %.2x\n", 
d483 1
a483 1
		dnprintf(0, "write GPE_STS offset: %.2x %.2x %.2x %.2x\n", 
d492 1
a492 1
		dnprintf(0, "write GPE_EN  offset: %.2x %.2x %.2x %.2x\n", 
d1120 1
a1120 1
	dnprintf(0, "%sabling GPE %.2x (current: %sabled) %.2x\n", 
d1141 1
a1141 1
	dnprintf(0, "Adding GPE handler %.2x (%s)\n", gpe, label);
d1193 1
a1193 1
	dnprintf(0, "Last GPE: %.2x\n", sc->sc_lastgpe);
d1579 1
a1579 1
				dnprintf(0, "softgpe: %.2x\n", gpe);
@


1.56
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.55 2006/06/30 23:09:41 gwk Exp $	*/
d42 1
a42 1
int acpi_debug = 11;
a1200 1
	memset(sc->sc_gpes, 0, sizeof(sc->sc_gpes));
a1208 1
		sc->sc_gpes[ngpe].gpe_type = GPE_LEVEL;
a1215 1
			sc->sc_gpes[ngpe].gpe_type = GPE_EDGE;
a1221 6
		if (gpe != NULL) {
			sc->sc_gpes[ngpe].gpe_number  = idx;
			sc->sc_gpes[ngpe].gpe_handler = gpe;
			dnprintf(20, "%s exists\n", name);
			ngpe++;
		}
a1226 10
acpi_enable_gpe(struct acpi_softc *sc, u_int32_t gpemask)
{
	u_int32_t mask;
	dnprintf(10, "acpi_enable_gpe: mask 0x%08x\n", gpemask);
	mask = acpi_read_pmreg(sc, ACPIREG_GPE0_EN, 0);
	acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 0, mask | gpemask);
	dnprintf(10, "acpi_enable_gpe: GPE 0x%08x\n", mask | gpemask);
}

void
d1560 1
a1560 1

d1564 1
@


1.55
log
@KNF, No functional change,
"go at it" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.54 2006/06/30 04:16:15 jordan Exp $	*/
d132 1
a132 1
	dnprintf(30, "gasio: %.2x 0x%.8llx %s\n",
a530 1
	struct aml_value	res;
d532 1
a532 1
	aml_eval_object(sc, node, &res, 0, NULL);
d581 1
a581 1
	struct aml_value	res;
d585 2
a586 1
	aml_eval_object(sc, node, &res, 0, NULL);
d590 1
a590 1
		dev = aml_strval(&res);
d593 1
a593 1
		dev = aml_eisaid(aml_val2int(NULL, &res));
d618 1
d628 2
a629 2
	struct aml_value	res;
	struct acpi_attach_args	aaa;
d632 2
a633 1
	aml_eval_object(sc, node, &res, 0, NULL);
d637 1
a637 1
		dev = aml_strval(&res);
d640 1
a640 1
		dev = aml_eisaid(aml_val2int(NULL, &res));
d659 2
d747 3
d777 2
a1153 1
	struct aml_value res;
d1158 2
a1159 2
	if (node != NULL)
		aml_eval_object(sc, node, &res, 0, NULL);
a1170 1
	struct aml_value res;
d1175 2
a1176 2
	if (node != NULL)
		aml_eval_object(sc, node, &res, 0, NULL);
d1215 1
a1215 1
			    "level");
d1223 1
a1223 1
				    "edge");
d1248 1
a1248 2
	struct acpi_context *ctx;
	struct aml_value res, env;
a1251 1
	ctx = NULL;
d1256 6
a1261 7
		if (aml_eval_name(sc, aml_root.child, name, &res, &env))
			continue;
		if (res.type == AML_OBJTYPE_PACKAGE) {
			sc->sc_sleeptype[i].slp_typa = aml_val2int(ctx,
			    res.v_package[0]);
			sc->sc_sleeptype[i].slp_typb = aml_val2int(ctx,
			    res.v_package[1]);
d1280 1
a1280 1
	struct aml_value res, env;
d1297 1
a1297 1
		if (aml_eval_object(sc, sc->sc_tts, &res, 1, &env)) {
d1316 1
a1316 1
		if (aml_eval_object(sc, sc->sc_pts, &res, 1, &env)) {
d1325 1
a1325 1
		if (aml_eval_object(sc, sc->sc_gts, &res, 1, &env)) {
d1369 1
a1369 1
	struct aml_value res, env;
d1375 1
a1375 1
		if (aml_eval_object(sc, sc->sc_pts, &res, 1, &env)) {
d1383 1
a1383 1
		if (aml_eval_object(sc, sc->sc_wak, &res, 1, &env)) {
d1391 1
a1391 1
		if (aml_eval_object(sc, sc->sc_wak, &res, 1, &env)) {
@


1.54
log
@Support for calling Embedded Controller via new GPE interface
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.53 2006/06/30 04:03:13 jordan Exp $	*/
d158 4
a161 2
					*(uint8_t *)(pb+reg) = bus_space_read_1(sc->sc_iot, ioh, reg);
					dnprintf(80, "os_in8(%llx) = %x\n", reg+address, *(uint8_t *)(pb+reg));
d164 3
a166 2
					*(uint16_t *)(pb+reg) = bus_space_read_2(sc->sc_iot, ioh, reg);
					dnprintf(80, "os_in16(%llx) = %x\n", reg+address, *(uint16_t *)(pb+reg));
d169 1
a169 1
					*(uint32_t *)(pb+reg) = bus_space_read_4(sc->sc_iot, ioh, reg);
d176 3
a178 2
					bus_space_write_1(sc->sc_iot, ioh, reg, *(uint8_t *)(pb+reg));
					dnprintf(80, "os_out8(%llx,%x)\n", reg+address, *(uint8_t *)(pb+reg));
d181 3
a183 2
					bus_space_write_2(sc->sc_iot, ioh, reg, *(uint16_t *)(pb+reg));
					dnprintf(80, "os_out16(%llx,%x)\n", reg+address, *(uint16_t *)(pb+reg));
d186 2
a187 1
					bus_space_write_4(sc->sc_iot, ioh, reg, *(uint32_t *)(pb+reg));
d212 2
a213 3
				   ACPI_PCI_BUS(address),
				   ACPI_PCI_DEV(address),
				   ACPI_PCI_FN(address));
d215 1
a215 1
		/* XXX: This is ugly.. read-modify-write does a byte at a time */
d338 4
a341 2
			dnprintf(20, "gpe0 block len : %x\n", sc->sc_fadt->gpe0_blk_len >> 1);
			dnprintf(20, "gpe0 block addr: %x\n", sc->sc_fadt->gpe0_blk);
d353 4
a356 2
			dnprintf(20, "gpe1 block len : %x\n", sc->sc_fadt->gpe1_blk_len >> 1);
			dnprintf(20, "gpe1 block addr: %x\n", sc->sc_fadt->gpe1_blk);
d365 1
a365 1
			       addr, size, name);
d369 1
a369 1
				      &sc->sc_pmregs[reg].ioh);
d386 1
a386 1
					sc->sc_pmregs[idx].size);
d404 1
a404 1
			acpi_read_pmreg(sc, ACPIREG_PM1B_EN, offset));
d407 1
a407 1
			acpi_read_pmreg(sc, ACPIREG_PM1B_STS, offset));
d410 1
a410 1
			acpi_read_pmreg(sc, ACPIREG_PM1B_CNT, offset));
d413 2
a414 4
		dnprintf(0, "read GPE_STS  offset: %.2x %.2x %.2x\n", 
			 offset, 
			 sc->sc_fadt->gpe0_blk_len>>1,
			 sc->sc_fadt->gpe1_blk_len>>1);
d422 2
a423 3
			 offset, 
			 sc->sc_fadt->gpe0_blk_len>>1,
			 sc->sc_fadt->gpe1_blk_len>>1);
d454 2
a455 2
		 sc->sc_pmregs[reg].name,
		 sc->sc_pmregs[reg].addr, offset, regval);
d484 2
a485 3
			 offset, 
			 sc->sc_fadt->gpe0_blk_len>>1,
			 sc->sc_fadt->gpe1_blk_len>>1, regval);
d493 2
a494 3
			 offset, 
			 sc->sc_fadt->gpe0_blk_len>>1,
			 sc->sc_fadt->gpe1_blk_len>>1, regval);
d524 1
a524 4
		 sc->sc_pmregs[reg].name,
		 sc->sc_pmregs[reg].addr,
		 offset,
		 regval);
d766 1
a766 1
				       sizeof(p_dsdt->hdr));
d955 1
a955 2
			acpi_map(xsdt->table_offsets[i], sizeof(*hdr),
				 &handle);
d958 1
a958 1
					&sc->sc_tables);
d982 1
a982 2
			acpi_map(rsdt->table_offsets[i], sizeof(*hdr),
				 &handle);
d985 1
a985 1
					&sc->sc_tables);
d1055 3
a1057 2
			dnprintf(10, "GPE block: %.2x %.2x %.2x\n", idx, sts, en);
			acpi_write_pmreg(sc,  ACPIREG_GPE_EN, idx>>3, en & ~sts);
d1112 1
a1112 2
		 enable ? "en" : "dis", gpe,
		 (en & mask) ? "en" : "dis", en);
d1121 2
a1122 2
acpi_set_gpehandler(struct acpi_softc *sc, int gpe, int (*handler)(struct acpi_softc *, int, void *), void *arg,
		    const char *label)
d1189 2
a1190 1
	sc->gpe_table = malloc(sc->sc_lastgpe * sizeof(struct gpe_block), M_DEVBUF, M_WAITOK);
d1207 2
a1208 1
			acpi_set_gpehandler(sc, idx, acpi_gpe_level, gpe, "level");
d1215 2
a1216 1
				acpi_set_gpehandler(sc, idx, acpi_gpe_edge, gpe, "edge");
d1254 4
a1257 2
			sc->sc_sleeptype[i].slp_typa = aml_val2int(ctx, res.v_package[0]);
			sc->sc_sleeptype[i].slp_typb = aml_val2int(ctx, res.v_package[1]);
d1555 2
a1556 2
			 sc->sc_fadt->flags & FADT_SLP_BUTTON ? 'n' : 'y',
			 sc->sc_fadt->flags & FADT_PWR_BUTTON ? 'n' : 'y');
d1607 1
a1607 1
							      acpi_evindex));
d1617 1
a1617 1
							      acpi_evindex));
d1632 2
a1633 2
	if (kthread_create(acpi_isr_thread, sc->sc_thread, NULL,
			   DEVNAME(sc)) != 0) {
d1635 1
a1635 1
		       DEVNAME(sc));
@


1.53
log
@Added new code for GPE handling
Also works with ACPIEC; need to fixup acpiec.c to remove original interrupt handler
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.52 2006/06/30 01:09:47 jordan Exp $	*/
a57 2
int	acpi_read_pmreg(struct acpi_softc *, int, int);
void	acpi_write_pmreg(struct acpi_softc *, int, int, int);
d1081 1
a1081 1

d1093 1
@


1.52
log
@Added offset argument for acpi read/write pmreg routines (new GPE code)
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.51 2006/05/31 10:34:54 todd Exp $	*/
d78 4
a84 3
#define GPE0_LEN(sc) (sc->sc_pmregs[ACPIREG_GPE0_EN].size >> 3)
#define GPE1_LEN(sc) (sc->sc_pmregs[ACPIREG_GPE1_EN].size >> 3)

d389 1
a389 1
	bus_size_t size;
d392 1
d405 9
d415 9
a423 1
		break;
d432 2
d460 1
a460 1
	bus_size_t size;
d462 1
d477 20
d505 2
a774 3
	/* Initialize GPE handlers */
	acpi_init_gpes(sc);

d794 3
d1048 1
a1048 1
	u_int32_t ec, processed, sts, en;
d1053 14
a1066 15
	sts = acpi_read_pmreg(sc, ACPIREG_GPE0_STS, 0);
	en  = acpi_read_pmreg(sc, ACPIREG_GPE0_EN, 0);
	if (sts & en) {
		dnprintf(10, "GPE interrupt: %.8x %.8x %.8x\n",
		   sts, en, sts & en);
		/* disable interrupts until handled */
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 0, en & ~sts);

		sc->sc_gpe_sts = sts;
		sc->sc_gpe_en = en;
		processed = 1;
		if ((sc->sc_ec != NULL) && (sts & sc->sc_ec_gpemask)) {
			ec = 1;
			if ((sts & en) == sc->sc_ec_gpemask)
				processed = 0;
d1105 74
d1185 9
a1195 1
	for (idx=0; idx<256; idx++) {
d1197 6
d1207 2
d1214 2
d1541 1
a1541 3
	u_int32_t gpemask, gpe;
	struct aml_value res;
	u_int32_t sts, en;
d1567 4
a1570 9
		/* Clear GPE interrupts */
#if 0
		for (idx=0; idx<GPE0_LEN(sc); idx++) {
		  acpi_write_pmreg(sc, ACPIREG_GPE0_EN, idx, 0);
		  acpi_write_pmreg(sc, ACPIREG_GPE0_STS, idx, -1);
		}
		for (idx=0; idx<GPE1_LEN(sc); idx++) {
		  acpi_write_pmreg(sc, ACPIREG_GPE1_EN, idx, 0);
		  acpi_write_pmreg(sc, ACPIREG_GPE1_STS, idx, -1);
a1571 4
#else
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN,  0, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS, 0, -1);
#endif
d1579 1
a1579 1
		dnprintf(10, "sleep...\n");
d1585 8
a1592 12
		sts = sc->sc_gpe_sts;
		en  = sc->sc_gpe_en;
		if (en & sts) {
			sc->sc_gpe_en = 0;
			sc->sc_gpe_sts = 0;
		
			gpemask = en & sts;	
			dnprintf(10, "softgpe: %x\n", en & sts);
			for (gpe=0; gpe<sc->sc_maxgpe; gpe++) {
				if (gpemask & (1L << sc->sc_gpes[gpe].gpe_number)) {
					dnprintf(10, "Got GPE: %x %x\n", gpe, sc->sc_gpes[gpe].gpe_number);
					aml_eval_object(sc, sc->sc_gpes[gpe].gpe_handler, &res, 0, NULL);
a1594 2
			acpi_write_pmreg(sc, ACPIREG_GPE0_STS, 0, en & sts);
			acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 0, en);
a1595 1
			
@


1.51
log
@do not call acpi_powerdown() unless acpi has successfully initialized
ok gwk@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.50 2006/05/29 00:54:23 canacar Exp $	*/
d58 2
a59 2
int	acpi_read_pmreg(struct acpi_softc *, int);
void	acpi_write_pmreg(struct acpi_softc *, int, int);
d81 3
d385 1
a385 1
acpi_read_pmreg(struct acpi_softc *sc, int reg)
d392 13
a404 11
	if (reg == ACPIREG_PM1_EN) {
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_EN) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_EN));
	}
	else if (reg == ACPIREG_PM1_STS) {
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_STS) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_STS));
	}
	else if (reg == ACPIREG_PM1_CNT) {
		return (acpi_read_pmreg(sc, ACPIREG_PM1A_CNT) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_CNT));
d406 1
a406 1

d418 1
a418 1
		regval = bus_space_read_1(sc->sc_iot, ioh, 0);
d421 1
a421 1
		regval = bus_space_read_2(sc->sc_iot, ioh, 0);
d424 1
a424 1
		regval = bus_space_read_4(sc->sc_iot, ioh, 0);
d428 1
a428 1
	dnprintf(30, "acpi_readpm: %s = %.4x %x\n",
d430 1
a430 1
		 sc->sc_pmregs[reg].addr, regval);
d436 1
a436 1
acpi_write_pmreg(struct acpi_softc *sc, int reg, int regval)
d442 13
a454 11
	if (reg == ACPIREG_PM1_EN) {
		acpi_write_pmreg(sc, ACPIREG_PM1A_EN, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_EN, regval);
	}
	else if (reg == ACPIREG_PM1_STS) {
		acpi_write_pmreg(sc, ACPIREG_PM1A_STS, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_STS, regval);
	}
	else if (reg == ACPIREG_PM1_CNT) {
		acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, regval);
		acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, regval);
d467 1
a467 1
		bus_space_write_1(sc->sc_iot, ioh, 0, regval);
d470 1
a470 1
		bus_space_write_2(sc->sc_iot, ioh, 0, regval);
d473 1
a473 1
		bus_space_write_4(sc->sc_iot, ioh, 0, regval);
d477 1
a477 1
	dnprintf(30, "acpi_writepm: %s = %.4x %x\n",
d480 1
d765 1
a765 1
	acpi_write_pmreg(sc, ACPIREG_SMICMD, sc->sc_fadt->acpi_enable);
d772 1
a772 1
	} while (!(acpi_read_pmreg(sc, ACPIREG_PM1_CNT) & ACPI_PM1_SCI_EN));
d1009 2
a1010 2
	sts = acpi_read_pmreg(sc, ACPIREG_GPE0_STS);
	en  = acpi_read_pmreg(sc, ACPIREG_GPE0_EN);
d1015 1
a1015 1
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, en & ~sts);
d1027 2
a1028 2
	sts = acpi_read_pmreg(sc, ACPIREG_PM1_STS);
	en  = acpi_read_pmreg(sc, ACPIREG_PM1_EN);
d1031 3
a1033 3
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, en & ~sts);
		acpi_write_pmreg(sc, ACPIREG_PM1_STS, en);
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, en);
d1046 1
a1046 1
		en  = acpi_read_pmreg(sc, ACPIREG_GPE0_EN);
d1049 2
a1050 2
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS, sts);
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, en | sts);
d1097 2
a1098 2
	mask = acpi_read_pmreg(sc, ACPIREG_GPE0_EN);
	acpi_write_pmreg(sc, ACPIREG_GPE0_EN, mask | gpemask);
d1192 1
a1192 1
	acpi_write_pmreg(sc, ACPIREG_PM1_STS, ACPI_PM1_WAK_STS);
d1195 2
a1196 2
	rega = acpi_read_pmreg(sc, ACPIREG_PM1A_CNT);
	regb = acpi_read_pmreg(sc, ACPIREG_PM1B_CNT);
d1201 2
a1202 2
	acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, rega);
	acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, regb);
d1207 2
a1208 2
	acpi_write_pmreg(sc, ACPIREG_PM1A_CNT, rega);
	acpi_write_pmreg(sc, ACPIREG_PM1B_CNT, regb);
d1212 2
a1213 2
		rega = acpi_read_pmreg(sc, ACPIREG_PM1A_STS);
		regb = acpi_read_pmreg(sc, ACPIREG_PM1B_STS);
d1425 1
a1425 1
		flag = acpi_read_pmreg(sc, ACPIREG_PM1_EN);
d1432 1
a1432 1
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, flag);
d1435 13
a1447 2
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN,	0);
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS, -1);
d1475 2
a1476 2
			acpi_write_pmreg(sc, ACPIREG_GPE0_STS, en & sts);
			acpi_write_pmreg(sc, ACPIREG_GPE0_EN, en);
@


1.50
log
@Add embedded controller support.
ok marco@@ deraadt@@ testing & ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.49 2006/05/19 09:24:32 canacar Exp $	*/
d44 1
d689 2
@


1.49
log
@Minimal thermal zone driver. Monitors thermal zone temperature,
shuts down the system if the 'critical temperature' is reached.
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.48 2006/04/11 02:36:49 marco Exp $	*/
d62 1
d252 8
d568 39
d817 1
d993 1
a993 1
	u_int32_t processed, sts, en;
d995 1
d1009 5
d1021 1
a1021 1
		acpi_write_pmreg(sc, ACPIREG_PM1_STS,en);
d1029 13
d1047 1
a1047 1
	return (processed);
d1082 10
d1427 3
a1429 2
		/* XXX: Enable GPEs _L1D */
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN,  (1L << 0x1D));
d1477 2
@


1.48
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.47 2006/04/11 02:35:35 gwk Exp $	*/
d62 1
d476 20
d773 3
@


1.47
log
@Add acpi_resume(struct acpi_softc *sc), which calls some AML methods,
detected at attach time, currently unused.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.47 2006/04/06 00:22:59 gwk Exp $	*/
d47 2
a48 2
void acpi_isr_thread(void *);
void acpi_create_thread(void *);
@


1.46
log
@Discover some ACPI sleep related methods, and call them at the
appropriate time in acpi_enter_sleep_state().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.45 2006/02/26 04:39:09 marco Exp $	*/
d1109 32
@


1.45
log
@Add acpicpu as a device.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.44 2006/02/23 18:53:21 marco Exp $	*/
d70 1
d654 3
d1012 10
d1025 1
d1038 38
@


1.44
log
@remove dead function.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.43 2006/02/22 23:53:09 marco Exp $	*/
d60 1
d474 20
d745 3
@


1.43
log
@Print out all tables it found during autoconf.  We'll need this data in
the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.42 2006/02/22 20:15:03 marco Exp $	*/
a59 1
void	acpi_gpe(struct aml_node *, void *);
a460 15
}

void
acpi_gpe(struct aml_node *node, void *arg)
{
	struct aml_node *child;
	struct acpi_softc *sc = arg;
	uint32_t flag;

	flag = acpi_read_pmreg(sc, ACPIREG_GPE0_EN);
	for (child = node->child; child; child = child->sibling) {
		dnprintf(30, "gpe: %s\n", child->name);
	}
	flag = -1;
	flag &= ~(1L << 0x1C);
@


1.42
log
@Make dmesg less verbose.

ok jordan.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.41 2006/02/22 19:38:01 jordan Exp $	*/
d688 6
@


1.41
log
@Added parsing of SSDT tables
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.40 2006/02/22 19:30:45 jordan Exp $	*/
d711 14
a724 12
		struct acpi_attach_args aaa;

		memset(&aaa, 0, sizeof(aaa));
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
#if 0
		aaa.aaa_pcit = sc->sc_pcit;
		aaa.aaa_smbust = sc->sc_smbust;
#endif
		aaa.aaa_table = entry->q_table;

		config_found_sm(self, &aaa, acpi_print, acpi_submatch);
@


1.40
log
@Added new aml_register to notify by device id
Moved powerdown code to button device
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.39 2006/02/21 16:51:30 marco Exp $	*/
d630 11
@


1.39
log
@Readjust debug levels that crept in too low over the last few days.
KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.38 2006/02/21 04:30:44 marco Exp $	*/
d1245 2
a1246 2
			if (sc->sc_pbtndev)
				aml_notify(sc->sc_pbtndev, 0x80);
a1250 4
		  
			/* power down */
			acpi_s5 = 1;
			psignal(initproc, SIGUSR1);
d1255 2
a1256 2
			if (sc->sc_sbtndev)
				aml_notify(sc->sc_sbtndev, 0x80);
@


1.38
log
@Rig the power button so that the machine shuts down correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.37 2006/02/20 00:48:10 marco Exp $	*/
d319 2
a320 2
			dnprintf(10, "gpe0 block len : %x\n", sc->sc_fadt->gpe0_blk_len >> 1);
			dnprintf(10, "gpe0 block addr: %x\n", sc->sc_fadt->gpe0_blk);
d332 2
a333 2
			dnprintf(10, "gpe1 block len : %x\n", sc->sc_fadt->gpe1_blk_len >> 1);
			dnprintf(10, "gpe1 block addr: %x\n", sc->sc_fadt->gpe1_blk);
d483 1
a483 1
	struct aml_value res;
d497 1
a497 1
	dnprintf(20, "found hid device: %s ", node->parent->name);
d511 1
a511 1
	dnprintf(20, "	device: %s\n", dev);
d535 2
a536 2
	struct acpi_attach_args *aaa = aux;
	struct cfdata *cf = match;
d951 1
a951 1
			dnprintf(10, "%s exists\n", name);
@


1.37
log
@Add acpibtn device.  Remains disabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.36 2006/02/19 21:32:30 jordan Exp $	*/
d495 1
d513 5
a517 2
	if (!strcmp(dev, ACPI_DEV_AC)) {
		struct acpi_attach_args aaa;
d519 1
a519 1
		memset(&aaa, 0, sizeof(aaa));
d521 1
a521 8
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
		aaa.aaa_node = node->parent;
		config_found(self, &aaa, acpi_print);
	} else if (!strcmp(dev, ACPI_DEV_CMB)) {
		struct acpi_attach_args aaa;

		memset(&aaa, 0, sizeof(aaa));
d523 4
a526 7
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
		aaa.aaa_node = node->parent;
		config_found(self, &aaa, acpi_print);
	} else if (!strcmp(dev, ACPI_DEV_LD) || !strcmp(dev, ACPI_DEV_PBD) ||
	    !strcmp(dev, ACPI_DEV_SBD)) {
		struct acpi_attach_args aaa; 
d528 1
a528 5
		memset(&aaa, 0, sizeof(aaa));
		aaa.aaa_name = "acpibtn";
		aaa.aaa_iot = sc->sc_iot;
		aaa.aaa_memt = sc->sc_memt;
		aaa.aaa_node = node->parent;
a529 1
	}
@


1.36
log
@Added code for aml_notify GPE notification callback
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.35 2006/02/19 19:03:49 grange Exp $	*/
d530 2
a531 4
	} else if (!strcmp(dev, ACPI_DEV_LD) ||
		   !strcmp(dev, ACPI_DEV_PBD) ||
		   !strcmp(dev, ACPI_DEV_SBD)) {
#if 0
a539 1
#endif
@


1.35
log
@Fix acpi_enter_sleep_state() by replacing current ugly hack
with mostly correct sleeping state transition code.

ok brad@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.34 2006/02/19 04:50:46 marco Exp $	*/
d530 13
d1258 3
d1272 3
@


1.34
log
@jordan:
Enable interrupts.
Added peripheral code to make this work.

marco:
Replace softintr and other types of interrupts with a handler with context.
Fixed interrupt magic for GPEs.
Some KNF

This is work done by jordan and I but has to be a single commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.33 2006/02/17 17:42:52 marco Exp $	*/
d31 1
d985 2
a986 1
	u_int16_t flag;
d988 41
a1028 4
	flag = acpi_read_pmreg(sc, ACPIREG_PM1_CNT);
	/* XXX This is sick and wrong and illegal! */
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT,  flag |= (state << 10));
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT,  flag |= ACPI_PM1_SLP_EN);
@


1.33
log
@Remove earlier introduced delays.  We really only need them during autconf.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.32 2006/02/17 17:35:59 marco Exp $	*/
d28 1
d37 1
d46 3
d61 1
a61 1
void    acpi_inidev(struct aml_node *, void *);
a66 1
void	acpi_softintr(void *);
d68 1
d317 3
d330 3
d341 1
a341 1
				 addr, size, name);
d411 2
a412 2
	       sc->sc_pmregs[reg].name,
	       sc->sc_pmregs[reg].addr, regval);
d503 1
a503 1
		dev = aml_eisaid(res.v_integer);
d509 1
a509 1
	dnprintf(20, "  device: %s\n", dev);
d634 3
a674 5
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	sc->sc_softih = softintr_establish(IPL_TTY, acpi_softintr, sc);
#else
	timeout_set(&sc->sc_timeout, acpi_softintr, sc);
#endif
a676 30
	/*
	 * If we have an interrupt handler, we can get notification
	 * when certain status bits changes in the ACPI registers,
	 * so let us enable some events we can forward to userland
	 */
	if (sc->sc_interrupt) {
		int16_t flag;

		dnprintf(1,"slpbtn:%c  pwrbtn:%c\n",
			 sc->sc_fadt->flags & FADT_SLP_BUTTON ? 'n' : 'y',
			 sc->sc_fadt->flags & FADT_PWR_BUTTON ? 'n' : 'y');

		/* Enable Sleep/Power buttons if they exist */
		flag = acpi_read_pmreg(sc, ACPIREG_PM1_EN);
		if (!(sc->sc_fadt->flags & FADT_PWR_BUTTON)) {
			flag |= ACPI_PM1_PWRBTN_EN;
		}
		if (!(sc->sc_fadt->flags & FADT_SLP_BUTTON)) {
			flag |= ACPI_PM1_SLPBTN_EN;
		}
		acpi_write_pmreg(sc, ACPIREG_PM1_EN, flag);

#if 0
		flag = acpi_read_pmreg(sc, ACPIREG_GPE0_STS);
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS, flag);
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 0);
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, (1L << 0x1D));
#endif
	}

a715 1
#if 1
a717 1
#endif
d721 7
d794 1
a794 1
			sizeof(xsdt->table_offsets[0]);
d798 1
a798 1
			    &handle);
d822 1
a822 1
			sizeof(rsdt->table_offsets[0]);
d826 1
a826 1
			    &handle);
d897 2
a898 1
		    sts, en, sts & en);
d900 3
a902 2
		acpi_write_pmreg(sc, ACPIREG_GPE0_STS,en);
		acpi_write_pmreg(sc, ACPIREG_GPE0_EN, en);
a903 4
		for (en = 0; en < icount; en++) {
			icount = (icount << 1) | 1;
		}
		icount++;
d920 2
a921 6
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
		softintr_schedule(sc->sc_softih);
#else
		if (!timeout_pending(&sc->sc_timeout))
			timeout_add(&sc->sc_timeout, 0);
#endif
d928 1
a928 1
acpi_softintr(void *arg)
d930 24
a953 19
	struct acpi_softc *sc = arg;

	if (sc->sc_powerbtn) {
		sc->sc_powerbtn = 0;
		acpi_evindex++;
		dnprintf(1,"power button pressed\n");
		KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_PWRBTN,
						      acpi_evindex));

		/* power down */
		acpi_s5 = 1;
		psignal(initproc, SIGUSR1);
	}
	if (sc->sc_sleepbtn) {
		sc->sc_sleepbtn = 0;
		acpi_evindex++;
		dnprintf(1,"sleep button pressed\n");
		KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_SLPBTN,
						      acpi_evindex));
d955 1
d1136 103
@


1.32
log
@Add a generic delay function as per the ACPI spec.

from jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.31 2006/02/17 06:57:58 marco Exp $	*/
d174 5
a178 1
			/* XXX bah! blame ACPI spec for this, cleanup later */
a180 2
			else
				tsleep(sc, PWAIT, "acpiwait", 1);
@


1.31
log
@Use tsleep instead of delay when !cold.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.30 2006/02/17 05:10:39 marco Exp $	*/
d100 7
@


1.30
log
@Argh, we need delays between reads/writes.  The backend reads (i2c most likely)
are so slow that values come back as 0 sometimes.  We have to do this
despite the spec saying we shouldnt have to.  Guess having a faster
parser than others can hurt sometimes.

Idea from jordan.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.29 2006/02/17 00:46:54 jordan Exp $	*/
d167 5
a171 3
			/* XXX bah! blame ACPI spec for this */
			/* make this a tsleep after !cold */
			delay(10000);
@


1.29
log
@Fixed code for handling _INI
Rearranged debug statements
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.28 2006/02/16 22:42:11 jordan Exp $	*/
d140 1
d144 1
d155 1
d159 1
d166 4
@


1.28
log
@Added stub for calling _INI
Fixed aml_dowhile for NULL return
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.27 2006/02/16 21:11:13 jordan Exp $	*/
d718 1
a718 1
#if 0
@


1.27
log
@Fixed parser/evaluator to retrieve battery info+state
Cleanup of parser
Dell laptops return battery status
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.26 2006/02/06 23:12:09 brad Exp $	*/
d56 1
d449 9
d717 5
@


1.26
log
@fix a typo so this will compile on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.25 2006/02/04 00:18:27 marco Exp $	*/
d39 1
a39 1
int acpi_debug = 60;
d98 2
d112 2
a113 1
	dnprintf(10, "gasio: %x %llx %x %x %p\n", iospace, address, access_size, len, buffer);
d455 1
a455 1
	dnprintf(10, "found hid device: %s ", node->parent->name);
d460 1
a460 1
		dev = res.v_string;
d469 1
a469 1
	dnprintf(10, "  device: %s\n", dev);
d943 1
d948 1
d956 2
a957 2
			sc->sc_sleeptype[i].slp_typa = aml_intval(res.v_package[0]);
			sc->sc_sleeptype[i].slp_typb = aml_intval(res.v_package[1]);
@


1.25
log
@When ACPI_ENABLED wasn't set  but the devices were it had an unknown variable.

Pointed out by ian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.24 2006/02/03 23:55:47 jordan Exp $	*/
d93 1
a93 1
#define acpi_bus_space_unmap   _x86_memiu_unmap
@


1.24
log
@Rewrote aml parser yet again...
Fixed bus_space_map for i386/amd64
Added _BST and _BIF to acpibat to get status/info
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.23 2006/01/20 20:20:28 jordan Exp $	*/
a514 1
	int idx;
d617 2
@


1.23
log
@More evaluator changes
Removed old evaluator code
Fixed _HID value
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.22 2006/01/19 00:08:46 jordan Exp $	*/
d88 11
a98 1
void
d102 1
a102 1
	void *pb;
d107 1
d110 3
d117 1
a117 1
		if (iodir == ACPI_IOREAD) {
d119 1
a119 2
		}
		else {
a120 1
		}
d126 6
a131 3
		pb = buffer;
		bus_space_map(sc->sc_iot, address, len, 0, &ioh); 
		while (pb < buffer+len) {
d135 1
a135 1
					*(uint8_t *)pb = bus_space_read_1(sc->sc_iot, ioh, 0);
d138 1
a138 1
					*(uint16_t *)pb = bus_space_read_2(sc->sc_iot, ioh, 0);
d141 1
a141 1
					*(uint32_t *)pb = bus_space_read_4(sc->sc_iot, ioh, 0);
d148 1
a148 1
					bus_space_write_1(sc->sc_iot, ioh, 0, *(uint8_t *)pb);
d151 1
a151 1
					bus_space_write_2(sc->sc_iot, ioh, 0, *(uint16_t *)pb);
d154 1
a154 1
					bus_space_write_4(sc->sc_iot, ioh, 0, *(uint32_t *)pb);
a157 1
			pb += access_size;
d159 1
a159 1
		bus_space_unmap(sc->sc_iot, ioh, len);
a169 1
		pb = buffer;
d182 1
a182 1
					*(u_int8_t *)pb = ival;
d185 1
a185 1
					*(u_int8_t *)pb = (ival >> 8);
d188 1
a188 1
					*(u_int8_t *)pb = (ival >> 16);
d191 1
a191 1
					*(u_int8_t *)pb = (ival >> 24);
d196 1
a196 1
				sval = *(uint8_t *)pb;
d221 1
d453 1
a453 1
	aml_eval_object(sc, node, &res, NULL);
a633 8

	for (idx = 0; idx < ACPIREG_MAXREG; idx++) {
		if (sc->sc_pmregs[idx].name) {
			dnprintf(30, "%8s = %.8x\n",
			       sc->sc_pmregs[idx].name,
			       acpi_read_pmreg(sc, idx));
		}
	}
@


1.22
log
@Added support for read/write of PCI Config space
Help jason@@
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.21 2006/01/18 22:25:44 jordan Exp $	*/
d202 1
d439 1
a439 1
	aml_eval_object(sc, node->child, &res, NULL);
@


1.21
log
@Added new evaluation routines
Added helper methods for buffer/field evaluation
Fixed broken indentation on dsdt.c

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.20 2006/01/17 23:42:14 jordan Exp $	*/
d32 1
d95 3
d149 56
@


1.20
log
@Major overhaul of the aml parser.  Evaluater temporarily disabled.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.19 2006/01/06 08:59:58 grange Exp $	*/
d86 62
@


1.19
log
@Check for ACPI control availability only if ACPI_ENABLE defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.18 2006/01/06 08:58:20 grange Exp $	*/
d820 4
a823 2
		sc->sc_sleeptype[i].slp_typa = aml_intval(&res.v_package[0]);
		sc->sc_sleeptype[i].slp_typb = aml_intval(&res.v_package[1]);
@


1.18
log
@Informative error messages on attach, prettier dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.17 2006/01/06 08:37:32 grange Exp $	*/
d424 1
d433 1
@


1.17
log
@printf -> dnprintf conversion for debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.16 2006/01/05 22:58:42 grange Exp $	*/
d383 4
a386 3
	printf(": ");
	if (acpi_map(aaa->aaa_pbase, sizeof(struct acpi_rsdp), &handle))
		goto fail;
d389 1
a389 1
	printf("revision %d ", (int)rsdp->rsdp_revision);
d402 1
d419 4
a422 2
	if (sc->sc_fadt == NULL)
		goto fail;
d428 4
a431 2
	    (!sc->sc_fadt->acpi_enable && !sc->sc_fadt->acpi_disable))
		goto fail;
d443 1
a443 1
		printf("!DSDT ");
d462 1
a462 1
		printf("!FACS ");
d482 4
a485 2
		if (idx++ > ACPIEN_RETRIES)
			goto fail;
d534 2
a574 5

	return;

 fail:
	printf(" failed attach\n");
@


1.16
log
@Find SLP_TYPx values and store them for future use in
acpi_enter_sleep_state().
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.15 2006/01/05 21:49:09 grange Exp $	*/
d301 1
a301 1
		printf("gpe: %s\n", child->name);
d490 1
a490 1
			printf("%8s = %.8x\n",
@


1.15
log
@Random KNF and cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.14 2006/01/05 21:22:21 grange Exp $	*/
d61 1
d444 3
d797 18
@


1.14
log
@Provide symbolic names for the acpi sleeping states and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.13 2005/12/28 03:09:21 marco Exp $	*/
d42 3
a44 2
int	acpimatch(struct device *, void *, void *);
void	acpiattach(struct device *, struct device *, void *);
d47 9
d59 1
d61 1
a63 5
void	acpi_foundhid(struct aml_node *, void *);
void    acpi_map_pmregs(struct acpi_softc *);
void    acpi_unmap_pmregs(struct acpi_softc *);
int     acpi_read_pmreg(struct acpi_softc *, int);
void    acpi_write_pmreg(struct acpi_softc *, int, int);
d69 1
a69 1
extern struct	aml_node aml_root;
d76 1
a76 1
	sizeof(struct acpi_softc), acpimatch, acpiattach
a82 2
int acpi_s5;
int acpi_evindex;
d84 1
d95 1
a95 1
	for (reg=0; reg<ACPIREG_MAXREG; reg++) {
a102 1
			
a117 1

a132 1

a137 1

a145 1

a155 1

d168 1
a168 1
			dnprintf(50, "mapping: %.4x %.4x %s\n", 
d172 1
a172 1
			bus_space_map(sc->sc_iot, addr, size, 0, 
d174 1
a174 1
			
d179 1
a179 1
	}		
d187 1
a187 1
	for (idx=0; idx<ACPIREG_MAXREG; idx++) {
d205 2
a206 2
		return acpi_read_pmreg(sc, ACPIREG_PM1A_EN) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_EN);
d209 2
a210 2
		return acpi_read_pmreg(sc, ACPIREG_PM1A_STS) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_STS);
d213 2
a214 2
		return acpi_read_pmreg(sc, ACPIREG_PM1A_CNT) |
			acpi_read_pmreg(sc, ACPIREG_PM1B_CNT);
d225 1
a225 1
	
d228 1
a228 1
		regval=bus_space_read_1(sc->sc_iot, ioh, 0);
d231 1
a231 1
		regval=bus_space_read_2(sc->sc_iot, ioh, 0);
d234 1
a234 1
		regval=bus_space_read_4(sc->sc_iot, ioh, 0);
d238 1
a238 1
	dnprintf(30, "acpi_readpm: %s = %.4x %x\n", 
d241 1
a241 1
	return regval;
d264 1
a264 1
  
d285 2
a286 2
	dnprintf(30, "acpi_writepm: %s = %.4x %x\n", 
		 sc->sc_pmregs[reg].name, 
a290 2
void acpi_gpe(struct aml_node *, void *);

d299 1
a299 1
	for (child=node->child; child; child=child->sibling) {
a300 1
		
d312 1
a312 1
	struct aml_value         res;
d317 1
a317 1
	switch(res.type) {
d352 1
a352 1
acpimatch(struct device *parent, void *match, void *aux)
d368 1
a368 1
acpiattach(struct device *parent, struct device *self, void *aux)
d410 2
a411 1
		if (memcmp(entry->q_table, FADT_SIG, sizeof(FADT_SIG) - 1) == 0) {
d440 2
a441 1
	acpi_parse_aml(sc, p_dsdt->aml, p_dsdt->hdr_length - sizeof(p_dsdt->hdr));
d472 1
a472 1
		if (idx++ > ACPIEN_RETRIES) 
d484 1
a484 1
	for (idx=0; idx<ACPIREG_MAXREG; idx++) {
d500 1
a500 1
		dnprintf(1,"slpbtn:%c  pwrbtn:%c\n", 
d503 1
a503 1
	    
d558 1
a558 1
	
d561 1
a561 1
	
d563 1
a563 1
	
d635 2
a636 1
			acpi_map(xsdt->table_offsets[i], sizeof(*hdr), &handle);
d663 2
a664 1
			acpi_map(rsdt->table_offsets[i], sizeof(*hdr), &handle);
a722 2
int icount;

d727 1
a727 1
	u_int32_t processed, sts,en;
d734 2
a735 1
		dnprintf(10, "GPE interrupt: %.8x %.8x %.8x\n", sts, en, sts & en);
d740 2
a741 2
		for(en=0; en<icount; en++) {
		  icount = (icount << 1) | 1;
d753 1
a753 1
		if (sts & ACPI_PM1_PWRBTN_STS) 
d768 1
a768 1
	return processed;
d775 1
a775 1
	
a795 1

d884 2
a885 1
					hdr = (struct acpi_table_header *)entry->q_table;
d893 1
a893 1
								table->table, hdr->length);
d925 1
a925 1
	return(1);
@


1.13
log
@Moved DEVNAME to a acpidev.h

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.12 2005/12/18 15:53:00 sturm Exp $	*/
d813 1
a813 1
	acpi_enter_sleep_state(acpi_softc, 5);
@


1.12
log
@add back comment about wrong code

ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.11 2005/12/16 19:09:31 marco Exp $	*/
d4 1
d38 1
a38 1
int acpi_debug = 20;
d41 1
a41 2
#define DEVNAME(s)  ((s)->sc_dev.dv_xname)

d217 1
a217 1
	if (reg >= ACPIREG_MAXREG)
d291 18
d315 1
d318 3
a320 1
	switch(node->child->value.type) {
d322 1
a322 1
		dev = node->child->value.v_string;
d325 1
a325 1
		dev = aml_eisaid(node->child->value.v_integer);
d340 1
d349 1
d380 1
d471 5
d485 8
d515 6
a520 1
		//acpi_write_pmreg(sc, ACPIREG_GPE0_EN, 1L << 0x1D);
d722 2
d728 1
a728 1
	u_int16_t processed, sts,en;
d735 1
a735 1
		dnprintf(10,"GPE interrupt: %.4x\n", sts & en);
d740 4
@


1.11
log
@Remove test for kbd_reset.  Prompted deraadt@@, ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.10 2005/12/16 18:59:41 jordan Exp $	*/
d756 1
@


1.10
log
@Added hooks for powerdown/power button press
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.9 2005/12/16 18:11:55 jordan Exp $	*/
d25 2
a35 3
#include <sys/signalvar.h>
#include <sys/proc.h>

a726 1
	extern int kbd_reset;
d734 2
d737 1
a737 4
		if (kbd_reset == 1) {
			kbd_reset = 0;
			psignal(initproc, SIGUSR1);
		}
@


1.9
log
@Cleaned up common power management register i/o
Added enter sleep state ioctl
Hooked power button interrupt
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.8 2005/12/16 04:00:35 marco Exp $	*/
d34 3
d77 1
d728 2
a729 1

d736 5
d751 19
a783 12
}

void
acpi_enter_sleep_state(struct acpi_softc *sc, int state)
{
#ifdef ACPI_ENABLE
	u_int16_t flag;

	flag = acpi_read_pmreg(sc, ACPIREG_PM1_CNT);
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT,  flag |= (state << 10));
	acpi_write_pmreg(sc, ACPIREG_PM1_CNT,  flag |= ACPI_PM1_SLP_EN);
#endif
@


1.8
log
@Remove autoconf chatter
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.7 2005/12/16 00:08:53 jordan Exp $	*/
d38 2
d51 4
d77 3
a79 3
#if 0
int
acpi_mapregister(struct acpi_softc *sc, int reg, bus_space_handle_t *ioh)
d83 2
d86 24
a109 6
	size = 0;
	switch (reg) {
	case ACPIREG_SMICMD:
		size = 1;
		addr = sc->sc_fadt->smi_cmd;
		break;
d111 15
a125 11
	case ACPIREG_PM1A_STS:
	case ACPIREG_PM1A_EN:
		size = sc->sc_fadt->pm1_evt_len >> 1;
		addr = sc->sc_fadt->pm1a_evt_blk;
		if (reg == ACPIREG_PM1A_EN)
			addr += size;
		break;
	case ACPIREG_PM1A_CNT:
		size = sc->sc_fadt->pm1_cnt_len;
		addr = sc->sc_fadt->pm1a_cnt_blk;
		break;
d127 5
a131 11
	case ACPIREG_PM1B_STS:
	case ACPIREG_PM1B_EN:
		size = sc->sc_fadt->pm1_evt_len >> 1;
		addr = sc->sc_fadt->pm1b_evt_blk;
		if (reg == ACPIREG_PM1B_EN)
			addr += size;
		break;
	case ACPIREG_PM1B_CNT:
		size = sc->sc_fadt->pm1_cnt_len;
		addr = sc->sc_fadt->pm1b_cnt_blk;
		break;
d133 8
a140 4
	case ACPIREG_PM2_CNT:
		size = sc->sc_fadt->pm2_cnt_len;
		addr = sc->sc_fadt->pm2_cnt_blk;
		break;
d142 10
a151 4
	case ACPIREG_PM_TMR:
		size = sc->sc_fadt->pm_tmr_len;
		addr = sc->sc_fadt->pm_tmr_blk;
		break;
d153 24
a176 21
	case ACPIREG_GPE0_STS:
	case ACPIREG_GPE0_EN:
		size = sc->sc_fadt->gpe0_len >> 1;
		addr = sc->sc_fadt->gpe0_blk;
		if (reg == ACPIREG_GPE0_EN)
			addr += size;
		break;

	case ACPIREG_GPE1_STS:
	case ACPIREG_GPE1_EN:
		size = sc->sc_fadt->gpe1_len >> 1;
		addr = sc->sc_fadt->gpe1_blk;
		if (reg == ACPIREG_GPE1_EN)
			addr += size;
		break;
	}
	if (size && addr) {
		bus_space_map(sc->sc_iot, addr, size, 0, ioh);
		return size;
	}
	return (0);
d180 1
a180 2
acpi_unmapregister(struct acpi_softc *sc, int reg, bus_space_handle_t ioh,
		   int size)
d182 8
a189 2
	if (size)
		bus_space_unmap(sc->sc_iot, ioh, size);
d192 3
a194 2
uint32_t
acpi_read_pm_reg(struct acpi_softc *sc, int reg)
d197 19
a215 2
	int size;
	uint32_t rval;
d217 6
a222 1
	size = acpi_mapregister(sc, reg, &ioh);
d225 1
a225 1
		rval = bus_space_read_1(sc->sc_ioh, ioh, 0);
d228 1
a228 1
		rval = bus_space_read_2(sc->sc_ioh, ioh, 0);
d231 1
a231 4
		rval = bus_space_read_4(sc->sc_ioh, ioh, 0);
		break;
	default:
		rval = 0;
a233 1
	acpi_unmapregister(sc, reg, ioh, size);
d235 4
a238 1
	return rval;
d240 2
d243 1
a243 1
acpi_write_pm_reg(struct acpi_softc *sc, int reg, uint32_t regval)
d246 1
a246 1
	int size, offset;
d248 22
a269 1
	size = acpi_mapregister(sc, &ioh);
d281 5
a285 1
	acpi_unmapregister(sc, reg, ioh);
a286 1
#endif
a346 3
#ifdef ACPI_ENABLE
	bus_space_handle_t ioh;
#endif
d430 3
d443 1
a443 3
	bus_space_map(sc->sc_iot, sc->sc_fadt->smi_cmd, 1, 0, &ioh);
	bus_space_write_1(sc->sc_iot, ioh, 0, sc->sc_fadt->acpi_enable);
	bus_space_unmap(sc->sc_iot, ioh, 1);
a445 4
	bus_space_map(sc->sc_iot,
		      sc->sc_fadt->pm1a_evt_blk, sc->sc_fadt->pm1_evt_len,
		      0, &sc->sc_ioh_pm1a_evt);

d459 15
a473 1
		int16_t flags;
d475 1
a475 12
#if 0
		acpi_read_pm1_enable(sc, &ena, &enb);
		ena |= (ACPI_PM1_PWRBTN_EN|ACPI_PM1_SLPBTN_EN);
		enb |= (ACPI_PM1_PWRBTN_EN|ACPI_PM1_SLPBTN_EN);
		acpi_write_pm1_enable(sc, ena, enb);
#else
		flags = bus_space_read_2(sc->sc_iot, sc->sc_ioh_pm1a_evt,
					 sc->sc_fadt->pm1_evt_len / 2);
		flags |= ACPI_PM1_PWRBTN_EN | ACPI_PM1_SLPBTN_EN;
		bus_space_write_2(sc->sc_iot, sc->sc_ioh_pm1a_evt,
				  sc->sc_fadt->pm1_evt_len / 2, flags);
#endif
d514 1
a514 1

d517 1
a517 1

d519 2
a520 2

fail:
d542 1
a542 1
	    (struct acpi_table_header *)aa->aaa_table;
d556 2
a557 2
		    hdr->signature[0], hdr->signature[1],
		    hdr->signature[2], hdr->signature[3]);
d588 1
a588 1
			  sizeof(xsdt->table_offsets[0]);
d594 1
a594 1
			    &sc->sc_tables);
d615 1
a615 1
		    sizeof(rsdt->table_offsets[0]);
d621 1
a621 1
			    &sc->sc_tables);
d681 3
a683 1
	u_int16_t flags;
d685 18
a702 9
	flags = bus_space_read_2(sc->sc_iot, sc->sc_ioh_pm1a_evt,
	    ACPI_PM1_STATUS);
	if (flags & (ACPI_PM1_PWRBTN_STS | ACPI_PM1_SLPBTN_STS)) {
		if (flags & ACPI_PM1_PWRBTN_STS) {
			bus_space_write_2(sc->sc_iot, sc->sc_ioh_pm1a_evt,
			    ACPI_PM1_STATUS, ACPI_PM1_PWRBTN_STS);
			/*
			 * Power-button has been pressed, do something!
			 */
d704 1
a704 7
		}
		if (flags & ACPI_PM1_SLPBTN_STS) {
			bus_space_write_2(sc->sc_iot, sc->sc_ioh_pm1a_evt,
			    ACPI_PM1_STATUS, ACPI_PM1_SLPBTN_STS);
			/*
			 * Sleep-button has been pressed, do something!
			 */
d706 3
a708 1
		}
a714 1
		return (1);
d716 2
a717 1
	return (0);
d728 1
d730 1
a730 1
		    acpi_evindex));
d735 1
d737 1
a737 1
		    acpi_evindex));
d761 1
a761 2
	bus_space_handle_t ioh;
	u_int16_t bits;
d763 3
a765 9
	bus_space_map(sc->sc_iot,
		      sc->sc_fadt->pm1a_cnt_blk, sc->sc_fadt->pm1_cnt_len,
		      0, &ioh);
	bits = bus_space_read_2(sc->sc_iot, ioh, 0);
	bits |= state << 10;	/* XXX This is sick and wrong and illegal! */
	bus_space_write_2(sc->sc_iot, ioh, 0, bits);
	bits |= ACPI_PM1_SLP_EN;
	bus_space_write_2(sc->sc_iot, ioh, 0, bits);
	bus_space_unmap(sc->sc_iot, ioh, sc->sc_fadt->pm1_cnt_len);
d793 8
d830 1
a830 1
						    table->table, hdr->length);
@


1.7
log
@Moved DSDT AML parsing into parent ACPI driver
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.6 2005/12/14 04:16:25 marco Exp $	*/
d135 1
a135 1
	if (size) {
d137 4
d142 6
a147 1
	return (size);
a156 1
	rval = 0;
d168 3
d172 1
a172 2
	if (size) 
		bus_space_unmap(sc->sc_iot, ioh, size);
a389 2

	printf("attached\n");
@


1.6
log
@Add AC device glue.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.5 2005/12/14 03:46:38 marco Exp $	*/
d72 2
a73 2
void
acpi_read_pm1_status(struct acpi_softc *sc, uint32_t *status_a, uint32_t *status_b)
d75 64
a138 2
  *status_a = bus_space_read_2(sc->sc_iot, sc->sc_ioh_pm1a_evt, ACPI_PM1_STATUS);
  *status_b = 0;
d140 3
a142 2
void
acpi_write_pm1_status(struct acpi_softc *sc, uint32_t status_a, uint32_t status_b)
d144 21
a164 1
  bus_space_write_2(sc->sc_iot, sc->sc_ioh_pm1a_evt, ACPI_PM1_STATUS, status_a);
d167 1
a167 1
acpi_read_pm1_enable(struct acpi_softc *sc, uint32_t *enable_a, uint32_t *enable_b)
d169 2
a170 8
  *status_a = bus_space_read_2(sc->sc_iot, sc->sc_ioh_pm1a_evt, ACPI_PM1_STATUS);
  *status_b = 0;
}
void
acpi_write_pm1_enable(struct acpi_softc *sc, uint32_t enable_a, uint32_t enable_b)
{
  bus_space_write_2(sc->sc_iot, sc->sc_ioh_pm1a_evt, ACPI_PM1_STATUS, status_a);
}
d172 13
a184 15
void
acpi_read_gpe_status(struct acpi_softc *sc, uint32_t *status_0, uint32_t *status_1)
{
}
void
acpi_write_gpe_status(struct acpi_softc *sc, uint32_t status_0, uint32_t status_1)
{
}
void
acpi_read_gpe_enable(struct acpi_softc *sc, uint32_t *enable_0, uint32_t *enable_1)
{
}
void
acpi_write_gpe_enable(struct acpi_softc *sc, uint32_t enable_0, uint32_t enable_1)
{
d255 1
d317 3
a587 5
#if 0
	acpi_read_pm1_status(sc, &sts_a, &sts_b);
	if ((sts_a & ACPI_PM1_PWRBTN_STS) && (sts_b & ACPI_PM1_PWRBTN_STS) {
		acpi_write_pm1_status(sc, 
#else
a614 1
#endif
@


1.5
log
@Adjust debug printing levels to something more sane.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.4 2005/12/13 07:23:33 marco Exp $	*/
d134 9
a142 2
	if (!strcmp(dev, ACPI_DEV_CMB))
	{
a150 1

@


1.4
log
@Add glue to attach devices to apci.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.3 2005/12/07 03:44:36 marco Exp $	*/
d35 1
a35 1
int acpi_debug = 3;
d120 1
a120 1
	dnprintf(1, "found hid device: %s ", node->parent->name);
d132 1
a132 1
	dnprintf(1, "  device: %s\n", dev);
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.2 2005/07/10 19:39:01 grange Exp $	*/
d31 6
d48 1
d53 3
d71 76
d282 6
d293 1
d335 3
d358 1
d361 2
a362 1
	struct acpi_table_header *hdr = (struct acpi_table_header *)aa->aaa_table;
d413 2
a414 1
			acpi_load_table(xsdt->table_offsets[i], hdr->length, &sc->sc_tables);
d435 1
a435 1
			  sizeof(rsdt->table_offsets[0]);
d440 2
a441 1
			acpi_load_table(rsdt->table_offsets[i], hdr->length, &sc->sc_tables);
d503 7
a509 1
	flags = bus_space_read_2(sc->sc_iot, sc->sc_ioh_pm1a_evt, ACPI_PM1_STATUS);
d513 1
a513 1
					  ACPI_PM1_STATUS, ACPI_PM1_PWRBTN_STS);
d521 1
a521 1
					  ACPI_PM1_STATUS, ACPI_PM1_SLPBTN_STS);
d535 1
d547 2
a548 1
		KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_PWRBTN, acpi_evindex));
d553 2
a554 1
		KNOTE(sc->sc_note, ACPI_EVENT_COMPOSE(ACPI_EV_SLPBTN, acpi_evindex));
d645 2
a646 1
						error = copyout(hdr, table->table, hdr->length);
@


1.2
log
@Spacing cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpi.c,v 1.1 2005/06/02 20:09:39 tholo Exp $	*/
d319 1
a319 2
	}
	else {
d533 1
a533 2
					}
					else if (hdr->length > table->size)
@


1.1
log
@Start on a basic ACPI framework -- does not do much more than read out the
ACPI tables into kernel memory and attach ACPI and HPET timers currently.

In order to test this code, enabling the devices in GENERIC as well as
the ACPI_ENABLE option is needed.  This code does not do any thermal
control yet, so this should be done with care depending on the platform.

In the tree so more people can contribute to making this more fully
featured.

Ok niklas@@ grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 1
	bus_space_map(sc->sc_iot, sc->sc_fadt->smi_cmd, 1, 0, &ioh); 
d251 1
a251 1
	struct acpi_attach_args *aaa = (struct acpi_attach_args *)aux; 
d379 1
a379 1
	    return;
@

