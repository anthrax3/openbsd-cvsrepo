head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.2
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.14
date	2017.02.25.20.09.20;	author jcs;	state Exp;
branches;
next	1.13;
commitid	qLBNvmeyHMMfKdYf;

1.13
date	2015.08.25.07.00.11;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	pssrhXjvKLUCEzWE;

1.12
date	2014.12.19.07.42.49;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	f7AvbFEf3VY2HbZr;

1.11
date	2014.10.16.03.42.03;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	2a2UaV2DwmugmT0u;

1.10
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.9;
commitid	I19imNlAX05zJOED;

1.9
date	2014.05.21.02.14.07;	author mlarkin;	state Exp;
branches;
next	1.8;

1.8
date	2014.02.21.16.25.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.19.17.55.37;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.21.01.10.24;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.19.22.46.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.17.21.59.45;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.26.17.24.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.04.17.30.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.07.23.01.38.16;	author cnst;	state Exp;
branches;
next	;


desc
@@


1.14
log
@move vendor HIDs into their drivers, clean up some unused defines

ok kettenis
@
text
@/*	$OpenBSD: atk0110.c,v 1.13 2015/08/25 07:00:11 deraadt Exp $	*/

/*
 * Copyright (c) 2009 Constantine A. Murenin <cnst+openbsd@@bugmail.mojo.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/sensors.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

/*
 * ASUSTeK AI Booster (ACPI ATK0110).
 *
 * The driver was inspired by Takanori Watanabe's acpi_aiboost driver.
 * http://cvsweb.freebsd.org/src/sys/dev/acpi_support/acpi_aiboost.c
 *
 * Special thanks goes to Sam Fourman Jr. for providing access to several
 * ASUS boxes where the driver could be tested.
 *
 *							-- cnst.su.
 */

#define ATK_ID_MUX_HWMON	0x00000006

#define ATK_CLASS(x)		(((x) >> 24) & 0xff)
#define ATK_CLASS_FREQ_CTL	3
#define ATK_CLASS_FAN_CTL	4
#define ATK_CLASS_HWMON		6
#define ATK_CLASS_MGMT		17

#define ATK_TYPE(x)		(((x) >> 16) & 0xff)
#define ATK_TYPE_VOLT		2
#define ATK_TYPE_TEMP		3
#define ATK_TYPE_FAN		4

#define AIBS_MORE_SENSORS
/* #define AIBS_VERBOSE */

struct aibs_sensor {
	struct ksensor	s;
	int64_t		i;
	int64_t		l;
	int64_t		h;
	SIMPLEQ_ENTRY(aibs_sensor)	entry;
};

struct aibs_softc {
	struct device		sc_dev;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	struct aml_node		*sc_ggrpnode;
	struct aml_node		*sc_gitmnode;
	struct aml_node		*sc_sitmnode;
	struct aml_node		*sc_rtmpnode;
	struct aml_node		*sc_rvltnode;
	struct aml_node		*sc_rfannode;

	SIMPLEQ_HEAD(, aibs_sensor)	sc_sensorlist;
	struct ksensordev	sc_sensordev;

	int			sc_mode;	/* 1 = new, 0 = old */
};

/* Command buffer used for GITM and SITM methods */
struct aibs_cmd_buffer {
	u_int32_t	id;
	u_int32_t	param1;
	u_int32_t	param2;
};

/* Return buffer used by the GITM and SITM mehtods */
struct aibs_ret_buffer {
	u_int32_t	flags;
	u_int32_t	value;
	/* there is more stuff that is unknown */
};

int	aibs_match(struct device *, void *, void *);
void	aibs_attach(struct device *, struct device *, void *);
int	aibs_notify(struct aml_node *, int, void *);
void	aibs_refresh(void *);

void	aibs_attach_sif(struct aibs_softc *, enum sensor_type);
void	aibs_attach_new(struct aibs_softc *);
void	aibs_add_sensor(struct aibs_softc *, char *);
void	aibs_refresh_r(struct aibs_softc *, struct aibs_sensor *);
int	aibs_getvalue(struct aibs_softc *, int64_t, int64_t *);
int	aibs_getpack(struct aibs_softc *, struct aml_node *, int64_t,
	    struct aml_value *);
void	aibs_probe(struct aibs_softc *);
int	aibs_find_cb(struct aml_node *, void *);


struct cfattach aibs_ca = {
	sizeof(struct aibs_softc), aibs_match, aibs_attach
};

struct cfdriver aibs_cd = {
	NULL, "aibs", DV_DULL
};

static const char* aibs_hids[] = {
	"ATK0110",
	NULL
};

int
aibs_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;

	return acpi_matchhids(aa, aibs_hids, cf->cf_driver->cd_name);
}

void
aibs_attach(struct device *parent, struct device *self, void *aux)
{
	struct aibs_softc	*sc = (struct aibs_softc *)self;
	struct acpi_attach_args	*aa = aux;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	SIMPLEQ_INIT(&sc->sc_sensorlist);

	aibs_probe(sc);
	printf("\n");

	if (sc->sc_mode)
		aibs_attach_new(sc);
	else {
		aibs_attach_sif(sc, SENSOR_TEMP);
		aibs_attach_sif(sc, SENSOR_FANRPM);
		aibs_attach_sif(sc, SENSOR_VOLTS_DC);
	}

	if (sc->sc_sensordev.sensors_count == 0) {
		printf("%s: no sensors found\n", DEVNAME(sc));
		return;
	}

	sensordev_install(&sc->sc_sensordev);

	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
	    aibs_notify, sc, ACPIDEV_POLL);
}

void
aibs_attach_sif(struct aibs_softc *sc, enum sensor_type st)
{
	struct aml_value	res;
	struct aml_value	**v;
	int			i, n;
	char			name[] = "?SIF";

	switch (st) {
	case SENSOR_TEMP:
		name[0] = 'T';
		break;
	case SENSOR_FANRPM:
		name[0] = 'F';
		break;
	case SENSOR_VOLTS_DC:
		name[0] = 'V';
		break;
	default:
		return;
	}

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, name, 0, NULL, &res)) {
		printf("%s: %s not found\n", DEVNAME(sc), name);
		aml_freevalue(&res);
		return;
	}
	if (res.type != AML_OBJTYPE_PACKAGE) {
		printf("%s: %s: not a package\n", DEVNAME(sc), name);
		aml_freevalue(&res);
		return;
	}
	v = res.v_package;
	if (v[0]->type != AML_OBJTYPE_INTEGER) {
		printf("%s: %s[0]: invalid type\n", DEVNAME(sc), name);
		aml_freevalue(&res);
		return;
	}

	n = v[0]->v_integer;
	if (res.length - 1 < n) {
		printf("%s: %s: invalid package\n", DEVNAME(sc), name);
		aml_freevalue(&res);
		return;
	} else if (res.length - 1 > n) {
		printf("%s: %s: misformed package: %i/%i",
		    DEVNAME(sc), name, n, res.length - 1);
#ifdef AIBS_MORE_SENSORS
		n = res.length - 1;
#endif
		printf(", assume %i\n", n);
	}
	if (n < 1) {
		printf("%s: %s: no members in the package\n",
		    DEVNAME(sc), name);
		aml_freevalue(&res);
		return;
	}

	for (i = 0, v++; i < n; i++, v++) {
		if(v[0]->type != AML_OBJTYPE_STRING) {
			printf("%s: %s: %i: not a string: %i type\n",
			    DEVNAME(sc), name, i, v[0]->type);
			continue;
		}
		aibs_add_sensor(sc, v[0]->v_string);
	}

	aml_freevalue(&res);
}

void
aibs_attach_new(struct aibs_softc *sc)
{
	struct aml_value	res;
	int			i;

	if (aibs_getpack(sc, sc->sc_ggrpnode, ATK_ID_MUX_HWMON, &res)) {
		printf("%s: GGRP: sensor enumeration failed\n", DEVNAME(sc));
		return;
	}

	for (i = 0; i < res.length; i++) {
		struct aml_value	*r;
		r = res.v_package[i];
		if (r->type != AML_OBJTYPE_STRING) {
			printf("%s: %s: %i: not a string (type %i)\n",
			    DEVNAME(sc), "GGRP", i, r->type);
			continue;
		}
		aibs_add_sensor(sc, r->v_string);
	}
	aml_freevalue(&res);
}

void
aibs_add_sensor(struct aibs_softc *sc, char *name)
{
	struct aml_value	 ri;
	struct aibs_sensor	*as;
	int			 len, lim1, lim2, ena;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, name,
	    0, NULL, &ri)) {
		printf("%s: aibs_add_sensor: %s not found\n",
		    DEVNAME(sc), name);
		aml_freevalue(&ri);
		return;
	}
	if (ri.type != AML_OBJTYPE_PACKAGE) {
		printf("%s: aibs_add_sensor: %s: not a package\n",
		    DEVNAME(sc), name);
		aml_freevalue(&ri);
		return;
	}
	if (sc->sc_mode) {
		len = 7;
		lim1 = 4;
		lim2 = 5;
		ena = 6;
	} else {
		len = 5;
		lim1 = 2;
		lim2 = 3;
		ena = 4;
	}

	if (ri.length != len ||
	    ri.v_package[0]->type != AML_OBJTYPE_INTEGER ||
	    ri.v_package[1]->type != AML_OBJTYPE_STRING ||
	    ri.v_package[lim1]->type != AML_OBJTYPE_INTEGER ||
	    ri.v_package[lim2]->type != AML_OBJTYPE_INTEGER ||
	    ri.v_package[ena]->type != AML_OBJTYPE_INTEGER) {
		printf("%s: aibs_add_sensor: %s: invalid package\n",
		    DEVNAME(sc), name);
		aml_freevalue(&ri);
		return;
	}
	as = malloc(sizeof(*as), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!as) {
		printf("%s: aibs_add_sensor: %s: failed to allocate sensor\n",
		    DEVNAME(sc), name);
		aml_freevalue(&ri);
		return;
	}
	as->i = ri.v_package[0]->v_integer;
	switch (ATK_TYPE(as->i)) {
	case ATK_TYPE_VOLT:
		as->s.type = SENSOR_VOLTS_DC;
		break;
	case ATK_TYPE_TEMP:
		as->s.type = SENSOR_TEMP;
		break;
	case ATK_TYPE_FAN:
		as->s.type = SENSOR_FANRPM;
		break;
	default:
		printf("%s: aibs_add_sensor: %s: unknown sensor type %llx\n",
		    DEVNAME(sc), name, ri.v_package[0]->v_integer);
		aml_freevalue(&ri);
		free(as, M_DEVBUF, sizeof(*as));
		return;
	}
	strlcpy(as->s.desc, ri.v_package[1]->v_string,
	    sizeof(as->s.desc));
	as->l = ri.v_package[lim1]->v_integer;
	if (sc->sc_mode)
		/* the second limit is a actually a range */
		as->h = as->l + ri.v_package[lim2]->v_integer;
	else
		as->h = ri.v_package[lim2]->v_integer;
#ifdef AIBS_VERBOSE
	printf("%s: %4s: %s 0x%08llx %5lli / %5lli  0x%llx\n",
	    DEVNAME(sc), name, as->s.desc, as->i, as->l, as->h,
	    ri.v_package[ena]->v_integer);
#endif
	SIMPLEQ_INSERT_TAIL(&sc->sc_sensorlist, as, entry);
	sensor_attach(&sc->sc_sensordev, &as->s);
	aml_freevalue(&ri);
	return;
}

void
aibs_refresh(void *arg)
{
	struct aibs_softc	*sc = arg;
	struct aibs_sensor	*as;

	SIMPLEQ_FOREACH(as, &sc->sc_sensorlist, entry)
		aibs_refresh_r(sc, as);
}

void
aibs_refresh_r(struct aibs_softc *sc, struct aibs_sensor *as)
{
	struct ksensor		*s = &as->s;
	int64_t			v;
	const int64_t		l = as->l, h = as->h;

	if (aibs_getvalue(sc, as->i, &v)) {
		s->flags |= SENSOR_FINVALID;
		return;
	}
	switch (s->type) {
	case SENSOR_TEMP:
		s->value = v * 100 * 1000 + 273150000;
		if (v == 0) {
			s->status = SENSOR_S_UNKNOWN;
			s->flags |= SENSOR_FINVALID;
		} else {
			if (v > h)
				s->status = SENSOR_S_CRIT;
			else if (v > l)
				s->status = SENSOR_S_WARN;
			else
				s->status = SENSOR_S_OK;
			s->flags &= ~SENSOR_FINVALID;
		}
		break;
	case SENSOR_FANRPM:
		s->value = v;
		/* some boards have strange limits for fans */
		if ((l != 0 && l < v && v < h) ||
		    (l == 0 && v > h))
			s->status = SENSOR_S_OK;
		else
			s->status = SENSOR_S_WARN;
		s->flags &= ~SENSOR_FINVALID;
		break;
	case SENSOR_VOLTS_DC:
		s->value = v * 1000;
		if (l < v && v < h)
			s->status = SENSOR_S_OK;
		else
			s->status = SENSOR_S_WARN;
		s->flags &= ~SENSOR_FINVALID;
		break;
	default:
		/* NOTREACHED */
		break;
	}
}

int
aibs_getvalue(struct aibs_softc *sc, int64_t i, int64_t *v)
{
	struct aml_node		*n = sc->sc_gitmnode;
	struct aml_value	req, res;
	struct aibs_cmd_buffer	cmd;
	struct aibs_ret_buffer	ret;
	enum aml_objecttype	type;

	if (sc->sc_mode) {
		cmd.id = i;
		cmd.param1 = 0;
		cmd.param2 = 0;
		type = req.type = AML_OBJTYPE_BUFFER;
		req.v_buffer = (uint8_t *)&cmd;
		req.length = sizeof(cmd);
	} else {
		switch (ATK_TYPE(i)) {
		case ATK_TYPE_TEMP:
			n = sc->sc_rtmpnode;
			break;
		case ATK_TYPE_FAN:
			n = sc->sc_rfannode;
			break;
		case ATK_TYPE_VOLT:
			n = sc->sc_rvltnode;
			break;
		default:
			return (-1);
		}
		type = req.type = AML_OBJTYPE_INTEGER;
		req.v_integer = i;
	}

	if (aml_evalnode(sc->sc_acpi, n, 1, &req, &res)) {
		dprintf("%s: %s: %lld: evaluation failed\n",
		    DEVNAME(sc), n->name, i);
		aml_freevalue(&res);
		return (-1);
	}
	if (res.type != type) {
		dprintf("%s: %s: %lld: not an integer: type %i\n",
		    DEVNAME(sc), n->name, i, res.type);
		aml_freevalue(&res);
		return (-1);
	}

	if (sc->sc_mode) {
		if (res.length < sizeof(ret)) {
			dprintf("%s: %s: %lld: result buffer too small\n",
			    DEVNAME(sc), n->name, i);
			aml_freevalue(&res);
			return (-1);
		}
		memcpy(&ret, res.v_buffer, sizeof(ret));
		if (ret.flags == 0) {
			dprintf("%s: %s: %lld: bad flags in result\n",
			    DEVNAME(sc), n->name, i);
			aml_freevalue(&res);
			return (-1);
		}
		*v = ret.value;
	} else {
		*v = res.v_integer;
	}
	aml_freevalue(&res);

	return (0);
}

int
aibs_getpack(struct aibs_softc *sc, struct aml_node *n, int64_t i,
    struct aml_value *res)
{
	struct aml_value	req;

	req.type = AML_OBJTYPE_INTEGER;
	req.v_integer = i;

	if (aml_evalnode(sc->sc_acpi, n, 1, &req, res)) {
		dprintf("%s: %s: %lld: evaluation failed\n",
		    DEVNAME(sc), n->name, i);
		aml_freevalue(res);
		return (-1);
	}
	if (res->type != AML_OBJTYPE_PACKAGE) {
		dprintf("%s: %s: %lld: not a package: type %i\n",
		    DEVNAME(sc), n->name, i, res->type);
		aml_freevalue(res);
		return (-1);
	}

	return (0);
}

void
aibs_probe(struct aibs_softc *sc)
{
	/*
	 * Old mode uses TSIF, VSIF, and FSIF to enumerate sensors and
	 * RTMP, RVLT, and RFAN are used to get the values.
	 * New mode uses GGRP for enumeration and GITM and SITM as accessor.
	 * If the new methods are available use them else default to old mode.
	 */
	aml_find_node(sc->sc_devnode, "RTMP", aibs_find_cb, &sc->sc_rtmpnode);
	aml_find_node(sc->sc_devnode, "RVLT", aibs_find_cb, &sc->sc_rvltnode);
	aml_find_node(sc->sc_devnode, "RFAN", aibs_find_cb, &sc->sc_rfannode);

	aml_find_node(sc->sc_devnode, "GGRP", aibs_find_cb, &sc->sc_ggrpnode);
	aml_find_node(sc->sc_devnode, "GITM", aibs_find_cb, &sc->sc_gitmnode);
	aml_find_node(sc->sc_devnode, "SITM", aibs_find_cb, &sc->sc_sitmnode);

	if (sc->sc_ggrpnode && sc->sc_gitmnode && sc->sc_sitmnode &&
	    !sc->sc_rtmpnode && !sc->sc_rvltnode && !sc->sc_rfannode)
		sc->sc_mode = 1;
}

int
aibs_find_cb(struct aml_node *node, void *arg)
{
	struct aml_node	**np = arg;

	printf(" %s", node->name);
	*np = node;
	return (1);
}

int
aibs_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct aibs_softc *sc = arg;

	if (notify_type == 0x00) {
		/* Poll sensors */
		aibs_refresh(sc);
	}
	return (0);
}
@


1.13
log
@sizes for simple free() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.12 2014/12/19 07:42:49 deraadt Exp $	*/
d125 1
a125 1
	ACPI_DEV_ASUSAIBOOSTER,
@


1.12
log
@lonely bcopy called me by name
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.11 2014/10/16 03:42:03 deraadt Exp $	*/
d333 1
a333 1
		free(as, M_DEVBUF, 0);
@


1.11
log
@missing \n in printf; Daniel Wade
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.10 2014/07/12 18:48:17 tedu Exp $	*/
d470 1
a470 1
		bcopy(res.v_buffer, &ret, sizeof(ret));
@


1.10
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.9 2014/05/21 02:14:07 mlarkin Exp $	*/
d251 1
a251 1
		printf("%s: GGRP: sensor enumeration failed", DEVNAME(sc));
@


1.9
log
@Fix invalid / missing format specifiers in several dnprintf statements
(used only when ACPI_DEBUG is enabled)

From a diff on tech@@ by Fabian Raetz, with a minor change by me, tested
on i386 and amd64 with ACPI_DEBUG enabled and disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.8 2014/02/21 16:25:57 deraadt Exp $	*/
d333 1
a333 1
		free(as, M_DEVBUF);
@


1.8
log
@remove stray printf; ok pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.7 2011/06/19 17:55:37 jsg Exp $	*/
d451 1
a451 1
		dprintf("%s: %s: %i: evaluation failed\n",
d457 1
a457 1
		dprintf("%s: %s: %i: not an integer: type %i\n",
d465 1
a465 1
			dprintf("%s: %s: %i: result buffer too small\n",
d472 1
a472 1
			dprintf("%s: %s: %i: bad flags in result\n",
d496 1
a496 1
		dprintf("%s: %s: %i: evaluation failed\n",
d502 1
a502 1
		dprintf("%s: %s: %i: not a package: type %i\n",
@


1.7
log
@fix up unbalanced format strings
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.6 2010/09/21 01:10:24 claudio Exp $	*/
a519 1
	printf(":");
@


1.6
log
@Add support for newer asus boards that use a different method to poll
and enumerate the sensors. When available aibs is using the RTMP, RVLT,
and RFAN nodes else in new mode GGRP, GITM, and SITM are used.
Tested by me and japser@@ on old HW and me and Mattieu Baptiste on new HW.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.5 2010/09/19 22:46:16 deraadt Exp $	*/
d278 1
a278 1
		    DEVNAME(sc), name, name);
@


1.5
log
@acpi sub-drivers may not use sensordev_install(); all acpi/acpiec/dsdt
operations must currently operate under the acpi thread.  So use
aml_register_notify with ACPI_POLL for now -- it is a horrific hack of
an interface, but now that all drivers are unified to use it, we can
consider improving it.
tested by jasper and claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.4 2010/05/17 21:59:45 nicm Exp $	*/
d43 13
d64 1
d73 6
a78 3
	struct aibs_sensor	*sc_asens_volt;
	struct aibs_sensor	*sc_asens_temp;
	struct aibs_sensor	*sc_asens_fan;
d80 1
d82 9
d93 6
d106 8
a113 1
void	aibs_refresh_r(struct aibs_softc *, enum sensor_type);
a146 2
	printf("\n");

d149 1
d151 10
a160 3
	aibs_attach_sif(sc, SENSOR_TEMP);
	aibs_attach_sif(sc, SENSOR_FANRPM);
	aibs_attach_sif(sc, SENSOR_VOLTS_DC);
a179 1
	struct aibs_sensor	*as;
a199 1

a204 1

d232 20
a251 4
	as = malloc(sizeof(*as) * n, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (as == NULL) {
		printf("%s: %s: malloc fail\n", DEVNAME(sc), name);
		aml_freevalue(&res);
d255 67
a321 3
	switch (st) {
	case SENSOR_TEMP:
		sc->sc_asens_temp = as;
d323 2
a324 2
	case SENSOR_FANRPM:
		sc->sc_asens_fan = as;
d326 2
a327 2
	case SENSOR_VOLTS_DC:
		sc->sc_asens_volt = as;
d330 4
a333 1
		/* NOTREACHED */
d336 8
a343 39

	for (i = 0, v++; i < n; i++, v++) {
		struct aml_value	ri;

		if(v[0]->type != AML_OBJTYPE_STRING) {
			printf("%s: %s: %i: not a string: %i type\n",
			    DEVNAME(sc), name, i, v[0]->type);
			continue;
		}
		if (aml_evalname(sc->sc_acpi, sc->sc_devnode, v[0]->v_string,
		    0, NULL, &ri)) {
			printf("%s: %s: %i: %s not found\n",
			    DEVNAME(sc), name, i, v[0]->v_string);
			aml_freevalue(&ri);
			continue;
		}
		if (ri.type != AML_OBJTYPE_PACKAGE) {
			printf("%s: %s: %i: %s: not a package\n",
			    DEVNAME(sc), name, i, v[0]->v_string);
			aml_freevalue(&ri);
			continue;
		}
		if (ri.length != 5 ||
		    ri.v_package[0]->type != AML_OBJTYPE_INTEGER ||
		    ri.v_package[1]->type != AML_OBJTYPE_STRING ||
		    ri.v_package[2]->type != AML_OBJTYPE_INTEGER ||
		    ri.v_package[3]->type != AML_OBJTYPE_INTEGER ||
		    ri.v_package[4]->type != AML_OBJTYPE_INTEGER) {
			printf("%s: %s: %i: %s: invalid package\n",
			    DEVNAME(sc), name, i, v[0]->v_string);
			aml_freevalue(&ri);
			continue;
		}
		as[i].i = ri.v_package[0]->v_integer;
		strlcpy(as[i].s.desc, ri.v_package[1]->v_string,
		    sizeof(as[i].s.desc));
		as[i].l = ri.v_package[2]->v_integer;
		as[i].h = ri.v_package[3]->v_integer;
		as[i].s.type = st;
d345 3
a347 5
		printf("%s: %s %2i: %4s: "
		    "0x%08llx %20s %5lli / %5lli  0x%llx\n",
		    DEVNAME(sc), name, i, v[0]->v_string,
		    as[i].i, as[i].s.desc, as[i].l, as[i].h,
		    ri.v_package[4]->v_integer);
d349 3
a351 5
		sensor_attach(&sc->sc_sensordev, &as[i].s);
		aml_freevalue(&ri);
	}

	aml_freevalue(&res);
d358 2
a359 1
	struct aibs_softc *sc = arg;
d361 2
a362 3
	aibs_refresh_r(sc, SENSOR_TEMP);
	aibs_refresh_r(sc, SENSOR_FANRPM);
	aibs_refresh_r(sc, SENSOR_VOLTS_DC);
d366 1
a366 1
aibs_refresh_r(struct aibs_softc *sc, enum sensor_type st)
d368 3
a370 4
	struct aml_node		*node;
	int			i, n = sc->sc_sensordev.maxnumt[st];
	char			*name;
	struct aibs_sensor	*as;
d372 5
a376 1
	switch (st) {
d378 13
a390 2
		name = "RTMP";
		as = sc->sc_asens_temp;
d393 8
a400 2
		name = "RFAN";
		as = sc->sc_asens_fan;
d403 6
a408 2
		name = "RVLT";
		as = sc->sc_asens_volt;
d411 2
a412 1
		return;
d414 1
d416 33
a448 2
	if (as == NULL)
		return;
d450 11
a460 8
	node = aml_searchname(sc->sc_devnode, name);
	if (node == NULL || node->value == NULL ||
	    node->value->type != AML_OBJTYPE_METHOD) {
		dprintf("%s: %s: method node not found\n",
		    DEVNAME(sc), name);
		for (i = 0; i < n; i++)
			as[i].s.flags |= SENSOR_FINVALID;
		return;
d463 4
a466 11
	for (i = 0; i < n; i++) {
		struct aml_value	req, res;
		int64_t			v;
		struct ksensor		*s = &as[i].s;
		const int64_t		l = as[i].l, h = as[i].h;

		req.type = AML_OBJTYPE_INTEGER;
		req.v_integer = as[i].i;
		if (aml_evalnode(sc->sc_acpi, node, 1, &req, &res)) {
			dprintf("%s: %s: %i: evaluation failed\n",
			    DEVNAME(sc), name, i);
d468 1
a468 2
			s->flags |= SENSOR_FINVALID;
			continue;
d470 4
a473 3
		if (res.type != AML_OBJTYPE_INTEGER) {
			dprintf("%s: %s: %i: not an integer: type %i\n",
			    DEVNAME(sc), name, i, res.type);
d475 1
a475 2
			s->flags |= SENSOR_FINVALID;
			continue;
d477 17
a493 2
		v = res.v_integer;
		aml_freevalue(&res);
d495 11
a505 38
		switch (st) {
		case SENSOR_TEMP:
			s->value = v * 100 * 1000 + 273150000;
			if (v == 0) {
				s->status = SENSOR_S_UNKNOWN;
				s->flags |= SENSOR_FINVALID;
			} else {
				if (v > h)
					s->status = SENSOR_S_CRIT;
				else if (v > l)
					s->status = SENSOR_S_WARN;
				else
					s->status = SENSOR_S_OK;
				s->flags &= ~SENSOR_FINVALID;
			}
			break;
		case SENSOR_FANRPM:
			s->value = v;
			/* some boards have strange limits for fans */
			if ((l != 0 && l < v && v < h) ||
			    (l == 0 && v > h))
				s->status = SENSOR_S_OK;
			else
				s->status = SENSOR_S_WARN;
			s->flags &= ~SENSOR_FINVALID;
			break;
		case SENSOR_VOLTS_DC:
			s->value = v * 1000;
			if (l < v && v < h)
				s->status = SENSOR_S_OK;
			else
				s->status = SENSOR_S_WARN;
			s->flags &= ~SENSOR_FINVALID;
			break;
		default:
			/* NOTREACHED */
			break;
		}
d508 34
a541 1
	return;
@


1.4
log
@Put the name string on the stack.

Fixes build with gcc4 which otherwise optimises away the modifications
to it, discovered by jakemsr@@.

ok marco jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.3 2010/02/26 17:24:11 deraadt Exp $	*/
d69 1
d121 1
a121 4
	if (sensor_task_register(sc, aibs_refresh, 5) == NULL) {
		printf("%s: unable to register update task\n", DEVNAME(sc));
		return;
	}
d123 2
a124 1
	sensordev_install(&sc->sc_sensordev);
d378 12
@


1.3
log
@initialise 's' before first use in the unlikely error path; from cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.2 2010/01/04 17:30:23 deraadt Exp $	*/
d134 1
a134 1
	char			*name = "?SIF";
@


1.2
log
@turn off verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: atk0110.c,v 1.1 2009/07/23 01:38:16 cnst Exp $	*/
d315 3
a317 2
		struct ksensor		*s;
		int64_t			v, l, h;
a334 1

d336 1
a336 3
		s = &as[i].s;
		l = as[i].l;
		h = as[i].h;
a375 1
		aml_freevalue(&res);
@


1.1
log
@New aibs(4) driver for ASUSTeK AI Booster (ACPI ATK0110) hardware monitoring,
with sensor state support through limits provided by the ACPI.

Tested on several ASUS motherboards kindly networked by Sam Fourman Jr.

ok deraadt marco jordan
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#define AIBS_VERBOSE
@

