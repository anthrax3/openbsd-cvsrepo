head	1.36;
access;
symbols
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.34.0.2
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.4
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.26.0.12
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.8
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.8
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.6
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10;
locks; strict;
comment	@ * @;


1.36
date	2016.09.17.20.20.25;	author guenther;	state Exp;
branches;
next	1.35;
commitid	um6jFPJ40iApTIs1;

1.35
date	2016.07.28.21.57.56;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	h0GHFDGWnEdswfbK;

1.34
date	2016.07.10.20.41.19;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	U9zrrrYaMeiaN06k;

1.33
date	2015.08.25.07.00.11;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	pssrhXjvKLUCEzWE;

1.32
date	2015.06.26.18.12.23;	author guenther;	state Exp;
branches;
next	1.31;
commitid	8mIrohS4jspbJWUi;

1.31
date	2015.02.09.08.15.19;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	cntTMS1KwNGvT3WJ;

1.30
date	2014.12.09.06.58.29;	author doug;	state Exp;
branches;
next	1.29;
commitid	yWAxzpQP2PPpYlfT;

1.29
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.28;
commitid	I19imNlAX05zJOED;

1.28
date	2014.07.06.21.36.55;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	eeDaJZdY7x0eB842;

1.27
date	2014.05.18.20.16.29;	author mlarkin;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.07.20.13.16;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2011.10.21.20.49.39;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.06.22.40.05;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.16.20.11.06;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.15.19.25.36;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.10.09.59.55;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.06.21.28.26;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.07.19.06.02;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.05.19.17.13;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.18.21.52.03;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.16.16.21.05;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.16.16.16.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.15.22.16.31;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.08.04.15.15;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.21.19.17.23;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.14.22.45.37;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.28.19.56.23;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.28.18.24.21;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.11.22.01.05;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2006.12.21.19.59.02;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.12.21.11.33.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.25.16.59.31;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.20.21.55.23;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.15.21.39.06;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Report a LAPIC address override entry in the dmesg if it doesn't match
the normal one

ok kettenis@@ mlarkin@@
@
text
@/* $OpenBSD: acpimadt.c,v 1.35 2016/07/28 21:57:56 kettenis Exp $ */
/*
 * Copyright (c) 2006 Mark Kettenis <kettenis@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/apicvar.h>
#include <machine/cpuvar.h>
#include <machine/bus.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <machine/i8259.h>
#include <machine/i82093reg.h>
#include <machine/i82093var.h>
#include <machine/i82489reg.h>
#include <machine/i82489var.h>

#include <machine/mpbiosvar.h>

#include "ioapic.h"

int acpimadt_match(struct device *, void *, void *);
void acpimadt_attach(struct device *, struct device *, void *);

struct cfattach acpimadt_ca = {
	sizeof(struct device), acpimadt_match, acpimadt_attach
};

struct cfdriver acpimadt_cd = {
	NULL, "acpimadt", DV_DULL
};

int acpimadt_validate(struct acpi_madt *);
int acpimadt_cfg_intr(int, u_int32_t *);
int acpimadt_print(void *, const char *);

int
acpimadt_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args *aaa = aux;
	struct acpi_table_header *hdr;

	/*
	 * If we do not have a table, it is not us
	 */
	if (aaa->aaa_table == NULL)
		return (0);

	/*
	 * If it is an MADT table, we can attach
	 */
	hdr = (struct acpi_table_header *)aaa->aaa_table;
	if (memcmp(hdr->signature, MADT_SIG, sizeof(MADT_SIG) - 1) != 0)
		return (0);

	return (1);
}

int
acpimadt_validate(struct acpi_madt *madt)
{
	caddr_t addr = (caddr_t)(madt + 1);

	while (addr < (caddr_t)madt + madt->hdr.length) {
		union acpi_madt_entry *entry = (union acpi_madt_entry *)addr;
		u_int8_t length = entry->madt_lapic.length;

		if (length < 2)
			return (0);

		if (addr + length > (caddr_t)madt + madt->hdr.length)
			return (0);

		switch (entry->madt_lapic.apic_type) {
		case ACPI_MADT_LAPIC:
			if (length != sizeof(entry->madt_lapic))
				return (0);
			break;
		case ACPI_MADT_IOAPIC:
			if (length != sizeof(entry->madt_ioapic))
				return (0);
			break;
		case ACPI_MADT_OVERRIDE:
			if (length != sizeof(entry->madt_override))
				return (0);
			break;
		case ACPI_MADT_NMI:
			if (length != sizeof(entry->madt_nmi))
				return (0);
			break;
		case ACPI_MADT_LAPIC_NMI:
			if (length != sizeof(entry->madt_lapic_nmi))
				return (0);
			break;
		case ACPI_MADT_LAPIC_OVERRIDE:
			if (length != sizeof(entry->madt_lapic_override))
				return (0);
			break;
		case ACPI_MADT_IO_SAPIC:
			if (length != sizeof(entry->madt_io_sapic))
				return (0);
			break;
		case ACPI_MADT_LOCAL_SAPIC:
			if (length != sizeof(entry->madt_local_sapic))
				return (0);
			break;
		case ACPI_MADT_PLATFORM_INT:
			if (length != sizeof(entry->madt_platform_int))
				return (0);
			break;
		case ACPI_MADT_X2APIC:
			if (length != sizeof(entry->madt_x2apic))
				return (0);
			break;
		case ACPI_MADT_X2APIC_NMI:
			if (length != sizeof(entry->madt_x2apic_nmi))
				return (0);
			break;
		}

		addr += length;
	}

	return (1);
}

struct mp_bus acpimadt_busses[256];
struct mp_bus acpimadt_isa_bus;

int
acpimadt_cfg_intr(int flags, u_int32_t *redir)
{
	int mpspo = (flags >> MPS_INTPO_SHIFT) & MPS_INTPO_MASK;
	int mpstrig = (flags >> MPS_INTTR_SHIFT) & MPS_INTTR_MASK;

	*redir &= ~IOAPIC_REDLO_DEL_MASK;
	switch (mpspo) {
	case MPS_INTPO_DEF:
	case MPS_INTPO_ACTHI:
		*redir &= ~IOAPIC_REDLO_ACTLO;
		break;
	case MPS_INTPO_ACTLO:
		*redir |= IOAPIC_REDLO_ACTLO;
		break;
	default:
		return (0);
	}

	*redir |= (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);

	switch (mpstrig) {
	case MPS_INTTR_LEVEL:
		*redir |= IOAPIC_REDLO_LEVEL;
		break;
	case MPS_INTTR_DEF:
	case MPS_INTTR_EDGE:
		*redir &= ~IOAPIC_REDLO_LEVEL;
		break;
	default:
		return (0);
	}

	return (1);
}

static u_int8_t lapic_map[256];

void
acpimadt_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpi_softc *acpi_sc = (struct acpi_softc *)parent;
	struct device *mainbus = parent->dv_parent->dv_parent;
	struct acpi_attach_args *aaa = aux;
	struct acpi_madt *madt = (struct acpi_madt *)aaa->aaa_table;
	caddr_t addr = (caddr_t)(madt + 1);
	struct aml_value arg;
	struct mp_intr_map *map;
	struct ioapic_softc *apic;
	int nlapic_nmis = 0;
	int pin;

	/* Do some sanity checks before committing to run in APIC mode. */
	if (!acpimadt_validate(madt)) {
		printf(": invalid, skipping\n");
		return;
	}

	printf(" addr 0x%x", madt->local_apic_address);
	if (madt->flags & ACPI_APIC_PCAT_COMPAT)
		printf(": PC-AT compat");
	printf("\n");

	/* Tell the BIOS we will be using APIC mode. */
	memset(&arg, 0, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = 1;

	aml_evalname(acpi_sc, NULL, "\\_PIC", 1, &arg, NULL);

	mp_busses = acpimadt_busses;
	mp_nbusses = nitems(acpimadt_busses);
	mp_isa_bus = &acpimadt_isa_bus;

	lapic_boot_init(madt->local_apic_address);

	/* 1st pass, get CPUs and IOAPICs */
	while (addr < (caddr_t)madt + madt->hdr.length) {
		union acpi_madt_entry *entry = (union acpi_madt_entry *)addr;
		struct cpu_attach_args caa;
		struct apic_attach_args aaa;

		switch (entry->madt_lapic.apic_type) {
		case ACPI_MADT_LAPIC_OVERRIDE:
			if (entry->madt_lapic_override.lapic_address !=
			    madt->local_apic_address) {
				printf("%s: ignored LAPIC override 0x%llx\n",
				    self->dv_xname,
				    entry->madt_lapic_override.lapic_address);
			}
			break;
		case ACPI_MADT_LAPIC:
			dprintf("%s: LAPIC: acpi_proc_id %x, apic_id %x, flags 0x%x\n",
			    self->dv_xname, entry->madt_lapic.acpi_proc_id,
			    entry->madt_lapic.apic_id,
			    entry->madt_lapic.flags);

			if ((entry->madt_lapic.flags & ACPI_PROC_ENABLE) == 0)
				break;

			lapic_map[entry->madt_lapic.acpi_proc_id] =
			    entry->madt_lapic.apic_id;

			memset(&caa, 0, sizeof(struct cpu_attach_args));
			if (lapic_cpu_number() == entry->madt_lapic.apic_id)
				caa.cpu_role = CPU_ROLE_BP;
			else {
				caa.cpu_role = CPU_ROLE_AP;
				ncpusfound++;
			}
			caa.caa_name = "cpu";
			caa.cpu_apicid = entry->madt_lapic.apic_id;
			caa.cpu_acpi_proc_id = entry->madt_lapic.acpi_proc_id;
#ifdef MULTIPROCESSOR
			caa.cpu_func = &mp_cpu_funcs;
#endif
#ifdef __i386__
			/*
			 * XXX utterly wrong.  These are the
			 * cpu_feature/cpu_id from the BSP cpu, now
			 * being given to another cpu.  This is
			 * bullshit.
			 */
			extern int cpu_id, cpu_feature;
			caa.cpu_signature = cpu_id;
			caa.feature_flags = cpu_feature;
#endif

			config_found(mainbus, &caa, acpimadt_print);
			break;
		case ACPI_MADT_IOAPIC:
			dprintf("%s: IOAPIC: acpi_ioapic_id %x, address 0x%x, global_int_base 0x%x\n",
			    self->dv_xname, entry->madt_ioapic.acpi_ioapic_id,
			    entry->madt_ioapic.address,
			    entry->madt_ioapic.global_int_base);

			memset(&aaa, 0, sizeof(struct apic_attach_args));
			aaa.aaa_name = "ioapic";
			aaa.apic_id = entry->madt_ioapic.acpi_ioapic_id;
			aaa.apic_address = entry->madt_ioapic.address;
			aaa.apic_vecbase = entry->madt_ioapic.global_int_base;

			config_found(mainbus, &aaa, acpimadt_print);
			break;
		case ACPI_MADT_LAPIC_NMI:
			nlapic_nmis++;
			break;
		case ACPI_MADT_X2APIC:
			dprintf("%s: X2APIC: acpi_proc_uid %x, apic_id %x, flags 0x%x\n",
			    self->dv_xname, entry->madt_x2apic.acpi_proc_uid,
			    entry->madt_x2apic.apic_id,
			    entry->madt_x2apic.flags);

			if (entry->madt_x2apic.apic_id > 255 ||
			    (entry->madt_x2apic.flags & ACPI_PROC_ENABLE) == 0)
				break;

			memset(&caa, 0, sizeof(struct cpu_attach_args));
			if (lapic_cpu_number() == entry->madt_x2apic.apic_id)
				caa.cpu_role = CPU_ROLE_BP;
			else {
				caa.cpu_role = CPU_ROLE_AP;
				ncpusfound++;
			}
			caa.caa_name = "cpu";
			caa.cpu_apicid = entry->madt_x2apic.apic_id;
			caa.cpu_acpi_proc_id = entry->madt_x2apic.acpi_proc_uid;
#ifdef MULTIPROCESSOR
			caa.cpu_func = &mp_cpu_funcs;
#endif
#ifdef __i386__
			/*
			 * XXX utterly wrong.  These are the
			 * cpu_feature/cpu_id from the BSP cpu, now
			 * being given to another cpu.  This is
			 * bullshit.
			 */
			extern int cpu_id, cpu_feature;
			caa.cpu_signature = cpu_id;
			caa.feature_flags = cpu_feature;
#endif

			config_found(mainbus, &caa, acpimadt_print);
			break;
		}
		addr += entry->madt_lapic.length;
	}

	mp_intrs = mallocarray(nlapic_nmis, sizeof(struct mp_intr_map),
	    M_DEVBUF, M_NOWAIT);
	if (mp_intrs == NULL)
		return;

	/* 2nd pass, get interrupt overrides */
	addr = (caddr_t)(madt + 1);
	while (addr < (caddr_t)madt + madt->hdr.length) {
		union acpi_madt_entry *entry = (union acpi_madt_entry *)addr;

		switch (entry->madt_lapic.apic_type) {
		case ACPI_MADT_LAPIC:
		case ACPI_MADT_IOAPIC:
			break;

		case ACPI_MADT_OVERRIDE:
			dprintf("%s: OVERRIDE: bus %x, source %x, global_int %x, flags %x\n",
			    self->dv_xname, entry->madt_override.bus,
			    entry->madt_override.source,
			    entry->madt_override.global_int,
			    entry->madt_override.flags);

			pin = entry->madt_override.global_int;
			apic = ioapic_find_bybase(pin);

			map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT | M_ZERO);
			if (map == NULL)
				return;

			map->ioapic = apic;
			map->ioapic_pin = pin - apic->sc_apic_vecbase;
			map->bus_pin = entry->madt_override.source;
			map->flags = entry->madt_override.flags;

			if (!acpimadt_cfg_intr(entry->madt_override.flags, &map->redir)) {
				printf("%s: bogus override for pin %d\n",
				    self->dv_xname, pin);
				free(map, M_DEVBUF, sizeof(*map));
				break;
			}

			map->ioapic_ih = APIC_INT_VIA_APIC |
			    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) |
			    (pin << APIC_INT_PIN_SHIFT));

			apic->sc_pins[pin].ip_map = map;

			map->next = mp_isa_bus->mb_intrs;
			mp_isa_bus->mb_intrs = map;
			break;

		case ACPI_MADT_LAPIC_NMI:
			dprintf("%s: LAPIC_NMI: acpi_proc_id %x, local_apic_lint %x, flags %x\n",
			    self->dv_xname, entry->madt_lapic_nmi.acpi_proc_id,
			    entry->madt_lapic_nmi.local_apic_lint,
			    entry->madt_lapic_nmi.flags);

			pin = entry->madt_lapic_nmi.local_apic_lint;

			map = &mp_intrs[mp_nintrs++];
			memset(map, 0, sizeof *map);
			map->cpu_id = lapic_map[entry->madt_lapic_nmi.acpi_proc_id];
			map->ioapic_pin = pin;
			map->flags = entry->madt_lapic_nmi.flags;

			if ((pin != 0 && pin != 1) ||
			    !acpimadt_cfg_intr(entry->madt_lapic_nmi.flags, &map->redir)) {
				printf("%s: bogus nmi for apid %d\n",
				    self->dv_xname, map->cpu_id);
				mp_nintrs--;
				break;
			}

			map->redir &= ~IOAPIC_REDLO_DEL_MASK;
			map->redir |= (IOAPIC_REDLO_DEL_NMI << IOAPIC_REDLO_DEL_SHIFT);
			break;

		case ACPI_MADT_X2APIC:
		case ACPI_MADT_X2APIC_NMI:
			break;

		default:
			printf("%s: unknown apic structure type %x\n",
			    self->dv_xname, entry->madt_lapic.apic_type);
		}

		addr += entry->madt_lapic.length;
	}

	/*
	 * ISA interrupts are supposed to be identity mapped unless
	 * there is an override, in which case we will already have a
	 * mapping for the interrupt.
	 */
	for (pin = 0; pin < ICU_LEN; pin++) {
		/* Skip if we already have a mapping for this interrupt. */
		for (map = mp_isa_bus->mb_intrs; map != NULL; map = map->next)
			if (map->bus_pin == pin)
				break;
		if (map != NULL)
			continue;

		apic = ioapic_find_bybase(pin);

		map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT | M_ZERO);
		if (map == NULL)
			return;

		map->ioapic = apic;
		map->ioapic_pin = pin;
		map->bus_pin = pin;
		map->redir = (IOAPIC_REDLO_DEL_LOPRI << IOAPIC_REDLO_DEL_SHIFT);

		map->ioapic_ih = APIC_INT_VIA_APIC |
		    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) |
		    (pin << APIC_INT_PIN_SHIFT));

		apic->sc_pins[pin].ip_map = map;

		map->next = mp_isa_bus->mb_intrs;
		mp_isa_bus->mb_intrs = map;
	}
}

int
acpimadt_print(void *aux, const char *pnp)
{
	struct apic_attach_args *aaa = aux;

	if (pnp)
		printf("%s at %s:", aaa->aaa_name, pnp);

	return (UNCONF);
}
@


1.35
log
@Store the acpi processor ID/UID in struct cpu_info, and use it to attach
acpicpu(4) drivers to the right cpu(4).

ok mlarkin@@, guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.34 2016/07/10 20:41:19 kettenis Exp $ */
d234 8
@


1.34
log
@Pay attention to Processor Local X2APIC structures.  ACPI 6.0 allows these
even for APIC ID values less than 255.  Makes secondary CPUs attach on the
HP DL360 gen 9.

tested by jung@@
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.33 2015/08/25 07:00:11 deraadt Exp $ */
a42 2
u_int8_t acpi_lapic_flags[LAPIC_MAP_SIZE];

a244 2
			acpi_lapic_flags[entry->madt_lapic.acpi_proc_id] =
			    entry->madt_lapic.flags;
d254 2
a255 1
			caa.cpu_number = entry->madt_lapic.apic_id;
d308 2
a309 1
			caa.cpu_number = entry->madt_x2apic.apic_id;
@


1.33
log
@sizes for simple free() calls
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.32 2015/06/26 18:12:23 guenther Exp $ */
d292 36
@


1.32
log
@Completely skip entries for disabled LAPICs so they don't overwrite
legit enabled ones

problem reported by Pedro Caetano (pedrocaetano (at) binaryflows.com)
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.31 2015/02/09 08:15:19 kettenis Exp $ */
d334 1
a334 1
				free(map, M_DEVBUF, 0);
@


1.31
log
@More sanity checking for Local APIC NMI entries.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.30 2014/12/09 06:58:29 doug Exp $ */
d242 3
a248 3

			if ((entry->madt_lapic.flags & ACPI_PROC_ENABLE) == 0)
				break;
@


1.30
log
@Replace some malloc(n*size,...) calls with mallocarray().

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.29 2014/07/12 18:48:17 tedu Exp $ */
d362 2
a363 1
			if (!acpimadt_cfg_intr(entry->madt_lapic_nmi.flags, &map->redir)) {
@


1.29
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.28 2014/07/06 21:36:55 kettenis Exp $ */
d297 2
a298 1
	mp_intrs = malloc(nlapic_nmis * sizeof (struct mp_intr_map), M_DEVBUF, M_NOWAIT);
@


1.28
log
@If we find a bogus interrupt (undefined polarity or trigger) don't panic but
print a message and ignore the interrupt.  There are BIOSen out there with
random garbage in NMI entries for the non-BP CPUs.
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.27 2014/05/18 20:16:29 mlarkin Exp $ */
d333 1
a333 1
				free(map, M_DEVBUF);
@


1.27
log
@_PIC is an optional method, so we shouldn't be aborting the rest of the
MADT processing if it is missing. This, combined with an earlier diff
from kettenis@@ to fix MADT interrupt polarity processing, should resolve
the issues reported with QEMU/KVM ACPI power button presses when using
OpenBSD guests.

ok kettenis@@, pirofti@@
tested by myself and kettenis for the past few weeks
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.26 2012/01/07 20:13:16 kettenis Exp $ */
d57 1
a57 1
void acpimadt_cfg_intr(int, u_int32_t *);
d153 1
a153 1
void
d169 1
a169 1
		panic("unknown MPS interrupt polarity %d", mpspo);
d183 1
a183 1
		panic("unknown MPS interrupt trigger %d", mpstrig);
d185 2
d330 6
a335 1
			acpimadt_cfg_intr(entry->madt_override.flags, &map->redir);
d361 7
a367 1
			acpimadt_cfg_intr(entry->madt_lapic_nmi.flags, &map->redir);
@


1.26
log
@Add X2APIC-related definitions for the MADT and silently skip them instead
of printing a warning.
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.25 2011/10/21 20:49:39 kettenis Exp $ */
d219 1
a219 2
	if (aml_evalname(acpi_sc, NULL, "\\_PIC", 1, &arg, NULL) != 0)
		return;
@


1.25
log
@Set mp_nbusses such that the newly added bounds checks on i386 and amd64
don't fail unconditionally.
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.24 2011/03/06 22:40:05 deraadt Exp $ */
d134 8
d358 4
@


1.24
log
@The global_int information acpi collects is not used by amd64.
ok ketttenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.23 2009/04/19 17:53:39 deraadt Exp $ */
d215 1
@


1.23
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.22 2009/02/16 20:11:06 kettenis Exp $ */
d319 1
a319 3
#ifdef __amd64__ /* XXX	*/
			map->global_int = entry->madt_override.global_int;
#endif
a380 3
#ifdef __amd64__ /* XXX */
		map->global_int = -1;
#endif
@


1.22
log
@Be a litte bit more paranoid and validate the APIC table before committing
to APIC mode.

tested by many
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.21 2008/09/15 19:25:36 kettenis Exp $ */
d243 1
a243 1
			else
d245 2
@


1.21
log
@Make this compile if !MULTIPROCESSOR.

ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.20 2008/08/10 09:59:55 kettenis Exp $ */
d56 1
d82 60
d194 6
@


1.20
log
@Don't assume the first LAPIC in the table corresponds to the boot processor.
Mark the processor we're running on as the boot processor instead.

ok marco@@, art@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.19 2008/06/11 04:42:09 marco Exp $ */
d36 2
d180 1
d182 1
@


1.19
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: acpimadt.c,v 1.18 2008/02/06 21:28:26 kettenis Exp $ */
a128 1
	int cpu_role = CPU_ROLE_BP;
d153 2
d168 2
a169 2
			{
				struct cpu_attach_args caa;
d171 8
a178 8
				if ((entry->madt_lapic.flags & ACPI_PROC_ENABLE) == 0)
					break;

				memset(&caa, 0, sizeof(struct cpu_attach_args));
				caa.cpu_role = cpu_role;
				caa.caa_name = "cpu";
				caa.cpu_number = entry->madt_lapic.apic_id;
				caa.cpu_func = &mp_cpu_funcs;
d180 9
a188 9
				/*
				 * XXX utterly wrong.  These are the
				 * cpu_feature/cpu_id from the BSP cpu,
				 * now being given to another cpu.
				 * This is bullshit.
				 */
				extern int cpu_id, cpu_feature;
				caa.cpu_signature = cpu_id;
				caa.feature_flags = cpu_feature;
d191 1
a191 4
				config_found(mainbus, &caa, acpimadt_print);

				cpu_role = CPU_ROLE_AP;
			}
d199 5
a203 8
			{
				struct apic_attach_args aaa;

				memset(&aaa, 0, sizeof(struct apic_attach_args));
				aaa.aaa_name = "ioapic";
				aaa.apic_id = entry->madt_ioapic.acpi_ioapic_id;
				aaa.apic_address = entry->madt_ioapic.address;
				aaa.apic_vecbase = entry->madt_ioapic.global_int_base;
d205 1
a205 2
				config_found(mainbus, &aaa, acpimadt_print);
			}
@


1.18
log
@Replace magic values with appropriate symbolic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.17 2007/12/07 19:06:02 fgsch Exp $	*/
@


1.17
log
@do not call aml_searchname and aml_evalnode afterwards, just use
aml_evalname. marco@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.16 2007/12/05 19:17:13 deraadt Exp $	*/
d85 2
a86 2
	int mpspo = flags & 0x03; /* XXX magic */
	int mpstrig = (flags >> 2) & 0x03; /* XXX magic */
@


1.16
log
@Hang acpi(4) below bios(4) instead of mainbus(4).  This lets us move acpi(4)
before pcibios(4), and then.... if acpi(4) attaches, skip pcibios(4) since
it messes the machines up.  Fixes claudio's HP dl320 G5, and almost assuredly
others.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.15 2007/11/18 21:52:03 kettenis Exp $	*/
a125 1
	struct aml_node *node;
a138 3
	node = aml_searchname(NULL, "\\_PIC");
	if (node == 0)
		return;
d142 3
a144 1
	aml_evalnode(acpi_sc, node, 1, &arg, NULL);
@


1.15
log
@Don't add identity mappings for ISA interrupts for which we have an override.
Tested by many; seems to fix ian@@'s evil Compaq, at least with GENERIC.MP.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.14 2007/11/16 16:21:05 deraadt Exp $	*/
d122 1
a122 1
	struct device *mainbus = parent->dv_parent;
@


1.14
log
@the cpu_feature/cpu_id stuff here is bullshit, XXX it so that it gets fixed one day soon
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.13 2007/11/16 16:16:04 deraadt Exp $	*/
d296 5
d302 7
a309 2
		if (apic->sc_pins[pin].ip_map != NULL)
			continue;
@


1.13
log
@fix the bus_space #define nightmare, so that amd64 and i386 are much more
uniform. as a result shared code like acpi needs less #ifdef's
ok marco kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.12 2007/11/15 22:16:31 mikeb Exp $	*/
d181 6
@


1.12
log
@Make acpicpu(4) attach to the existing CPUs only.

Problem reported by form@@.  Fix idea by kettenis@@.
Lots of help from deraadt@@.  Tested by deraadt@@, form@@ and me.

ok deraadt marco
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.11 2007/10/08 04:15:15 krw Exp $	*/
a39 4

#ifdef __amd64__ /* XXX */
#define mp_nintrs mp_nintr
#endif
@


1.11
log
@More simple memset(,0,) -> M_ZERO changes. In this batch move to
size(*p) as the first malloc() parameter where p is declared locally
and thus easy to check. Add M_ZERO to gpe_table allocation in acpi.c
even though there is no obvious bzero or memset nearby.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.10 2007/02/21 19:17:23 kettenis Exp $	*/
d45 2
d170 2
@


1.10
log
@Make an acpi-enabled GENERIC.MP work on systems that only support PIC mode.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.9 2007/02/14 22:45:37 kettenis Exp $	*/
d240 1
a240 1
			map = malloc(sizeof (struct mp_intr_map), M_DEVBUF, M_NOWAIT);
a243 1
			memset(map, 0, sizeof *map);
d295 1
a295 1
		map = malloc(sizeof (struct mp_intr_map), M_DEVBUF, M_NOWAIT);
a298 1
		memset(map, 0, sizeof *map);
@


1.9
log
@Cleanup and hide debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.8 2007/01/28 19:56:23 kettenis Exp $	*/
d30 2
d123 1
d128 2
d140 9
@


1.8
log
@Fix pasto.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.7 2007/01/28 18:24:21 kettenis Exp $	*/
d147 2
a148 2
			printf("LAPIC: acpi_proc_id %x, apic_id %x, flags 0x%x\n",
			    entry->madt_lapic.acpi_proc_id,
d178 2
a179 2
			printf("IOAPIC: acpi_ioapic_id %x, address 0x%x, global_int_base 0x%x\n",
			    entry->madt_ioapic.acpi_ioapic_id,
d217 2
a218 2
			printf("OVERRIDE: bus %x, source %x, global_int %x, flags %x\n",
			    entry->madt_override.bus,
d251 2
a252 2
			printf("LAPIC_NMI: acpi_proc_id %x, local_apic_lint %x, flags %x\n",
			    entry->madt_lapic_nmi.acpi_proc_id,
d270 2
a271 1
			printf("apic_type %x\n", entry->madt_lapic.apic_type);
@


1.7
log
@Properly route lapic NMIs.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.6 2007/01/11 22:01:05 kettenis Exp $	*/
d264 1
a264 1
			acpimadt_cfg_intr(entry->madt_override.flags, &map->redir);
@


1.6
log
@Assume that the first cpu in the table is the boot processor, instead of
the cpu with apic id 0.

tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.5 2006/12/21 19:59:02 deraadt Exp $	*/
d39 4
d116 2
d128 1
d151 4
d195 3
d202 4
d248 19
@


1.5
log
@even more knf love
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.4 2006/12/21 11:33:21 deraadt Exp $	*/
d121 1
d151 1
a151 4
				if (entry->madt_lapic.apic_id == 0)
					caa.cpu_role = CPU_ROLE_BP;
				else
					caa.cpu_role = CPU_ROLE_AP;
d162 2
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.3 2006/11/25 16:59:31 niklas Exp $	*/
d137 1
a137 1
		switch(entry->madt_lapic.apic_type) {
d140 3
a142 3
			       entry->madt_lapic.acpi_proc_id,
			       entry->madt_lapic.apic_id,
			       entry->madt_lapic.flags);
d168 3
a170 3
			       entry->madt_ioapic.acpi_ioapic_id,
			       entry->madt_ioapic.address,
			       entry->madt_ioapic.global_int_base);
d193 1
a193 1
		switch(entry->madt_lapic.apic_type) {
d200 4
a203 4
			       entry->madt_override.bus,
			       entry->madt_override.source,
			       entry->madt_override.global_int,
			       entry->madt_override.flags);
d223 2
a224 1
			    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) | (pin << APIC_INT_PIN_SHIFT));
d258 2
a259 1
		    ((apic->sc_apicid << APIC_INT_APIC_SHIFT) | (pin << APIC_INT_PIN_SHIFT));
@


1.3
log
@sync amd64 to i386 w.r.t. acpi support. Also fix interrupt routing for multi-ioapic systems.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.2 2006/11/20 21:55:23 jordan Exp $	*/
d196 1
a196 1
		  	break;
@


1.2
log
@Added 2nd pass for interrupt override scanning
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpimadt.c,v 1.1 2006/11/15 21:39:06 kettenis Exp $	*/
d157 1
d161 1
d213 2
d217 3
d248 2
d251 3
@


1.1
log
@dd pseudo-devices to handle acpi apic interrupt routing.

ok jordan@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
d182 13
@

