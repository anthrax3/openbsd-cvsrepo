head	1.22;
access;
symbols
	OPENBSD_6_2:1.21.0.10
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.17.0.6
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.10.06.13.33.53;	author mikeb;	state Exp;
branches;
next	1.21;
commitid	o1tBclPB4WgTdx2n;

1.21
date	2015.10.06.20.49.32;	author matthew;	state Exp;
branches;
next	1.20;
commitid	oTz5xREXNVHVouc2;

1.20
date	2015.08.12.05.59.54;	author mlarkin;	state Exp;
branches;
next	1.19;
commitid	yJ9YfqrdiR5zt4wo;

1.19
date	2015.08.04.22.22.28;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	Cv3s8NwynFAjveQp;

1.18
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.17;
commitid	p4LJxGKbi0BU2cG6;

1.17
date	2014.03.05.23.47.00;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.21.16.41.01;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.19.03.27.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2012.08.16.18.41.17;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.10.13.36.57;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.23.15.17.45;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.23.01.33.08;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.12.22.25.27;	author pirofti;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.20.20.23.57;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.18.17.27.50;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.20.23.54.46;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.20.22.25.45;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.19.23.42.39;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.06.03.13.42;	author marco;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Recalibrate TSC timecounter with HPET and PM timer

If frequency of an invariant (non-stop) time stamp counter is measured
using an independent working timecounter that has a known frequency, we
can assume that the measured TSC frequency is as good as the resolution
of the timecounter that we use to perform the measurement. This lets us
switch from this high quality but expensive source to the cheaper TSC
without sacrificing precision on a wide range of modern CPUs.

From Adam Steen <adam@@adamsteen.com.au> with tweaks from reyk@@ and myself.

Tested by brynet@@, sthen@@ and others, OK mlarkin, sthen
@
text
@/* $OpenBSD: acpihpet.c,v 1.21 2015/10/06 20:49:32 matthew Exp $ */
/*
 * Copyright (c) 2005 Thorsten Lockert <tholo@@sigmasoft.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timetc.h>

#include <machine/bus.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>

int acpihpet_attached;

int acpihpet_match(struct device *, void *, void *);
void acpihpet_attach(struct device *, struct device *, void *);
int acpihpet_activate(struct device *, int);

u_int acpihpet_gettime(struct timecounter *tc);

u_int64_t	acpihpet_r(bus_space_tag_t _iot, bus_space_handle_t _ioh,
		    bus_size_t _ioa);
void		acpihpet_w(bus_space_tag_t _iot, bus_space_handle_t _ioh,
		    bus_size_t _ioa, u_int64_t _val);

static struct timecounter hpet_timecounter = {
	acpihpet_gettime,	/* get_timecount */
	0,			/* no poll_pps */
	0xffffffff,		/* counter_mask (32 bits) */
	0,			/* frequency */
	0,			/* name */
	1000			/* quality */
};

#define HPET_TIMERS	3
struct hpet_regs {
	u_int64_t	configuration;
	u_int64_t	interrupt_status;
	u_int64_t	main_counter;
	struct {	/* timers */
		u_int64_t config;
		u_int64_t compare;
		u_int64_t interrupt;
	} timers[HPET_TIMERS];
};

struct acpihpet_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	u_int32_t		sc_conf;
	struct hpet_regs	sc_save;
};

struct cfattach acpihpet_ca = {
	sizeof(struct acpihpet_softc), acpihpet_match, acpihpet_attach,
	NULL, acpihpet_activate
};

struct cfdriver acpihpet_cd = {
	NULL, "acpihpet", DV_DULL
};

u_int64_t
acpihpet_r(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t ioa)
{
	u_int64_t val;

	val = bus_space_read_4(iot, ioh, ioa + 4);
	val = val << 32;
	val |= bus_space_read_4(iot, ioh, ioa);
	return (val);
}

void
acpihpet_w(bus_space_tag_t iot, bus_space_handle_t ioh, bus_size_t ioa,
    u_int64_t val)
{
	bus_space_write_4(iot, ioh, ioa + 4, val >> 32);
	bus_space_write_4(iot, ioh, ioa, val & 0xffffffff);
}

int
acpihpet_activate(struct device *self, int act)
{
	struct acpihpet_softc *sc = (struct acpihpet_softc *) self;

	switch (act) {
	case DVACT_SUSPEND:
		/* stop, then save */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_conf);

		sc->sc_save.configuration = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_CONFIGURATION);
		sc->sc_save.interrupt_status = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_INTERRUPT_STATUS);
		sc->sc_save.main_counter = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_MAIN_COUNTER);
		sc->sc_save.timers[0].config = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER0_CONFIG);
		sc->sc_save.timers[0].interrupt = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER0_INTERRUPT);
		sc->sc_save.timers[0].compare = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER0_COMPARE);
		sc->sc_save.timers[1].config = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER1_CONFIG);
		sc->sc_save.timers[1].interrupt = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER1_INTERRUPT);
		sc->sc_save.timers[1].compare = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER1_COMPARE);
		sc->sc_save.timers[2].config = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER2_CONFIG);
		sc->sc_save.timers[2].interrupt = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER2_INTERRUPT);
		sc->sc_save.timers[2].compare = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_TIMER2_COMPARE);
		break;
	case DVACT_RESUME:
		/* stop, restore, then restart */
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_conf);

		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_save.configuration);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_INTERRUPT_STATUS, sc->sc_save.interrupt_status);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_MAIN_COUNTER, sc->sc_save.main_counter);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER0_CONFIG, sc->sc_save.timers[0].config);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER0_INTERRUPT, sc->sc_save.timers[0].interrupt);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER0_COMPARE, sc->sc_save.timers[0].compare);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER1_CONFIG, sc->sc_save.timers[1].config);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER1_INTERRUPT, sc->sc_save.timers[1].interrupt);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER1_COMPARE, sc->sc_save.timers[1].compare);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER2_CONFIG, sc->sc_save.timers[2].config);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER2_INTERRUPT, sc->sc_save.timers[2].interrupt);
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_TIMER2_COMPARE, sc->sc_save.timers[2].compare);
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_conf | 1);
		break;
	}

	return 0;
}

int
acpihpet_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args *aaa = aux;
	struct acpi_table_header *hdr;

	/*
	 * If we do not have a table, it is not us; attach only once
	 */
	if (acpihpet_attached || aaa->aaa_table == NULL)
		return (0);

	/*
	 * If it is an HPET table, we can attach
	 */
	hdr = (struct acpi_table_header *)aaa->aaa_table;
	if (memcmp(hdr->signature, HPET_SIG, sizeof(HPET_SIG) - 1) != 0)
		return (0);

	return (1);
}

void
acpihpet_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpihpet_softc *sc = (struct acpihpet_softc *) self;
	struct acpi_softc *psc = (struct acpi_softc *)parent;
	struct acpi_attach_args *aaa = aux;
	struct acpi_hpet *hpet = (struct acpi_hpet *)aaa->aaa_table;
	u_int64_t period, freq;	/* timer period in femtoseconds (10^-15) */
	u_int32_t v1, v2;
	int timeout;

	if (acpi_map_address(psc, &hpet->base_address, 0, HPET_REG_SIZE,
	    &sc->sc_ioh, &sc->sc_iot))	{
		printf(": can't map i/o space\n");
		return;
	}

	/*
	 * Revisions 0x30 through 0x3a of the AMD SB700, with spread
	 * spectrum enabled, have an SMM based HPET emulation that's
	 * subtly broken.  The hardware is initialized upon first
	 * access of the configuration register.  Initialization takes
	 * some time during which the configuration register returns
	 * 0xffffffff.
	 */
	timeout = 1000;
	do {
		if (bus_space_read_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION) != 0xffffffff)
			break;
	} while(--timeout > 0);

	if (timeout == 0) {
		printf(": disabled\n");
		return;
	}

	/* enable hpet */
	sc->sc_conf = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	    HPET_CONFIGURATION) & ~1;
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, HPET_CONFIGURATION,
	    sc->sc_conf | 1);

	/* make sure hpet is working */
	v1 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, HPET_MAIN_COUNTER);
	delay(1);
	v2 = bus_space_read_4(sc->sc_iot, sc->sc_ioh, HPET_MAIN_COUNTER);
	if (v1 == v2) {
		printf(": counter not incrementing\n");
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_conf);
		return;
	}

	period = bus_space_read_4(sc->sc_iot, sc->sc_ioh,
	    HPET_CAPABILITIES + sizeof(u_int32_t));

	/* Period must be > 0 and less than 100ns (10^8 fs) */
	if (period == 0 || period > HPET_MAX_PERIOD) {
		printf(": invalid period\n");
		bus_space_write_4(sc->sc_iot, sc->sc_ioh,
		    HPET_CONFIGURATION, sc->sc_conf);
		return;
	}
	freq = 1000000000000000ull / period;
	printf(": %lld Hz\n", freq);

	hpet_timecounter.tc_frequency = (u_int32_t)freq;
	hpet_timecounter.tc_priv = sc;
	hpet_timecounter.tc_name = sc->sc_dev.dv_xname;
	tc_init(&hpet_timecounter);
#if defined(__amd64__)
	extern void cpu_recalibrate_tsc(struct timecounter *);
	cpu_recalibrate_tsc(&hpet_timecounter);
#endif
	acpihpet_attached++;
}

u_int
acpihpet_gettime(struct timecounter *tc)
{
	struct acpihpet_softc *sc = tc->tc_priv;

	return (bus_space_read_4(sc->sc_iot, sc->sc_ioh, HPET_MAIN_COUNTER));
}
@


1.21
log
@0xffffffff is 32 bits, not 24 bits

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.20 2015/08/12 05:59:54 mlarkin Exp $ */
d267 4
@


1.20
log
@
Check proper HPET period value during attach.

Pointed out by patrick keshishian <pkeshish at gmail.com>, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.19 2015/08/04 22:22:28 deraadt Exp $ */
d45 1
a45 1
	0xffffffff,		/* counter_mask (24 bits) */
@


1.19
log
@do not save & restore a capability register, it is RO.
issue noticed by patrick kehishian, ok mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.18 2015/03/14 03:38:46 jsg Exp $ */
d252 3
a254 1
	if (period == 0) {
d260 1
a260 1
	freq =  1000000000000000ull / period;
@


1.18
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.17 2014/03/05 23:47:00 deraadt Exp $ */
a52 1
	u_int64_t	capability;
a111 2
		sc->sc_save.capability = acpihpet_r(sc->sc_iot,
		    sc->sc_ioh, HPET_CAPABILITIES);
a141 2
		acpihpet_w(sc->sc_iot, sc->sc_ioh,
		    HPET_CAPABILITIES, sc->sc_save.capability);
@


1.17
log
@force cfattach decl to same form as others
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.16 2013/12/21 16:41:01 deraadt Exp $ */
a20 1
#include <sys/malloc.h>
@


1.16
log
@save/restore hpet configuration.  Perhaps a little more than we
need to do, since we do not use many hpet features.
ok kettenis millert
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.15 2013/12/19 03:27:10 deraadt Exp $ */
d76 2
a77 5
	sizeof(struct acpihpet_softc),
	acpihpet_match,
	acpihpet_attach,
	NULL,
	acpihpet_activate
@


1.15
log
@be more careful during suspend/resume cycles, as roughly detailed in the
spec.  More might be required.
ok jordan matthew mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.15 2013/12/19 03:19:51 deraadt Exp $ */
d38 5
d52 13
d70 1
d72 1
d87 19
d113 1
d116 27
d145 30
@


1.14
log
@we are past the point where timecounters may disappear
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.13 2011/01/10 13:36:57 mikeb Exp $ */
d52 1
d73 4
d79 1
a79 1
		    HPET_CONFIGURATION, 1);
d146 4
a149 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, HPET_CONFIGURATION, 1);
d158 1
a158 1
		    HPET_CONFIGURATION, 0);
d167 1
a167 1
		    HPET_CONFIGURATION, 0);
@


1.13
log
@Attach acpihpet only once.  The matching code is changed because acpi bus
can be enumerated which means match routine should do the right thing and
prevent further attachments.

With input from kettenis, deraadt, miod;  ok deraadt, kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.12 2010/07/21 19:35:15 deraadt Exp $ */
a21 1
#ifdef __HAVE_TIMECOUNTER
a22 1
#endif
a35 1
#ifdef __HAVE_TIMECOUNTER
a45 1
#endif
a164 1
#ifdef __HAVE_TIMECOUNTER
a168 1
#endif
a171 1
#ifdef __HAVE_TIMECOUNTER
a178 1
#endif
@


1.12
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.11 2009/11/23 15:17:45 deraadt Exp $ */
d32 2
d92 1
a92 1
	 * If we do not have a table, it is not us
d94 1
a94 1
	if (aaa->aaa_table == NULL)
d175 1
@


1.11
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.10 2009/11/23 01:33:08 pirofti Exp $ */
d57 4
a60 4
	sizeof(struct acpihpet_softc), 
	acpihpet_match, 
	acpihpet_attach, 
	NULL, 
d81 2
a82 2
}		
			
@


1.10
log
@Fix pckbd and acpihpet suspend/resume cases to fit with the future framework
that's going to get in really soon.

Okay mlarkin@@, deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.9 2009/10/13 19:33:16 pirofti Exp $ */
d73 1
a73 1
	switch(act) {
@


1.9
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.8 2009/08/12 22:25:27 pirofti Exp $ */
d74 3
a76 6
	case DVACT_ACTIVATE:
		if (!cold) 
			bus_space_write_4(sc->sc_iot, sc->sc_ioh,
			    HPET_CONFIGURATION, 1);
		break;
	case DVACT_DEACTIVATE:
@


1.8
log
@Add wake support to acpihpet(4).

Patch initially from mlarkin@@. KNF and refactoring by me. Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.7 2009/01/20 20:23:57 kettenis Exp $ */
d34 1
a34 1
int acpihpet_activate(struct device *, enum devact);
d69 1
a69 1
acpihpet_activate(struct device *self, enum devact act)
@


1.7
log
@Add workaround for broken ATI southbridges; inspired by how Linux handles this.
Fixes PR 5916 & 5959.

ok toby@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.6 2008/06/11 04:42:09 marco Exp $ */
d34 1
d57 5
a61 1
	sizeof(struct acpihpet_softc), acpihpet_match, acpihpet_attach
d68 18
@


1.6
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: acpihpet.c,v 1.5 2007/11/18 17:27:50 marco Exp $ */
d94 1
d99 20
@


1.5
log
@Fix for PR 5642 & 5643.  Report and testing Martijn Rijkeboer
<martijn at bunix dot org>

ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpihpet.c,v 1.4 2007/02/20 23:54:46 marco Exp $	*/
@


1.4
log
@It helps to enable hpet...  This fixes bnx not working on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpihpet.c,v 1.3 2007/02/20 22:25:45 marco Exp $	*/
d93 1
d101 14
d117 6
a129 1
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, HPET_CONFIGURATION, 1);
@


1.3
log
@KNF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpihpet.c,v 1.2 2007/02/19 23:42:39 jordan Exp $	*/
d109 1
@


1.2
log
@Added acpi_map_address function for mapping GAS/IO registers
ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpihpet.c,v 1.1 2006/03/06 03:13:42 marco Exp $	*/
d95 1
a95 1
			     &sc->sc_ioh, &sc->sc_iot))	{
d101 1
a101 1
				  HPET_CAPABILITIES + sizeof(u_int32_t));
@


1.1
log
@Rename hpet to acpihpet so that all devices use the same naming convention.

discussed with jordan.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpet.c,v 1.3 2005/12/16 21:11:51 marco Exp $	*/
d89 3
a91 2
	struct acpi_attach_args *aa = aux;
	struct acpi_hpet *hpet = (struct acpi_hpet *)aa->aaa_table;
d94 2
a95 26
	switch (hpet->base_address.address_space_id) {
	case GAS_SYSTEM_MEMORY:
		sc->sc_iot = aa->aaa_memt;
		break;

	case GAS_SYSTEM_IOSPACE:
		sc->sc_iot = aa->aaa_iot;
		break;

#if 0
	case GAS_SYSTEM_PCI_CFG_SPACE:
		sc->sc_iot = aa->aaa_pcit;
		break;

	case GAS_SYSTEM_SMBUS:
		sc->sc_iot = aa->aaa_smbust;
		break;
#endif

	default:
		printf(": can't identify bus\n");
		return;
	}

	if (bus_space_map(sc->sc_iot, hpet->base_address.address,
	    HPET_REG_SIZE, 0, &sc->sc_ioh)) {
@

