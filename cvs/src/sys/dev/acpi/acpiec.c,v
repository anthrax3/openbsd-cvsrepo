head	1.56;
access;
symbols
	OPENBSD_6_1:1.56.0.4
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.53.0.2
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.51.0.4
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.48.0.6
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.47.0.2
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.6
	OPENBSD_5_0:1.44.0.4
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.44.0.2
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.43.0.2
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.26.0.2
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.56
date	2017.03.11.21.46.32;	author jcs;	state Exp;
branches;
next	1.55;
commitid	rY2gxfaAbqFDM52f;

1.55
date	2016.10.25.06.55.59;	author pirofti;	state Exp;
branches;
next	1.54;
commitid	T6wBjmhxTtwwvjJL;

1.54
date	2016.08.23.18.26.21;	author jcs;	state Exp;
branches;
next	1.53;
commitid	I82k83geIv3kSRWH;

1.53
date	2016.05.07.18.03.36;	author kettenis;	state Exp;
branches;
next	1.52;
commitid	vdhqVprlycKG3PQB;

1.52
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.51;
commitid	p4LJxGKbi0BU2cG6;

1.51
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.50;
commitid	uzzBR7hz9ncd4O6G;

1.50
date	2014.06.25.07.46.14;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	K1FV3hcREmCzNGnc;

1.49
date	2014.05.21.02.14.07;	author mlarkin;	state Exp;
branches;
next	1.48;

1.48
date	2013.07.02.18.37.47;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.18.06.02.51;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2012.07.13.10.37.40;	author pirofti;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.10.21.27.07;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.09.22.27.21;	author jordan;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.08.17.25.41;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2010.08.03.16.55.06;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.02.17.13.57;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.29.18.32.26;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.27.22.57.22;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.27.22.32.51;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.27.21.55.54;	author marco;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.27.06.12.50;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.27.05.17.36;	author jordan;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.23.20.21.58;	author jordan;	state Exp;
branches;
next	1.33;

1.33
date	2010.07.23.20.19.21;	author jordan;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.20.12.15.24;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.20.12.14.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.20.12.10.51;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.26.18.15.24;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.10.20.36.10;	author jordan;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.13.09.13.56;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.07.19.06.02;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.12.21.41.03;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.12.21.38.31;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.21.20.46.57;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.21.04.12.47;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.17.23.59.03;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.23.17.24.40;	author canacar;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.21.11.33.21;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.21.05.53.35;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.21.05.24.25;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.21.01.42.49;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.12.17.59.09;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.29.22.17.07;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.25.16.25.53;	author jordan;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.15.15.28.32;	author jordan;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.14.19.59.51;	author canacar;	state Exp;
branches;
next	1.5;

1.5
date	2006.10.12.18.20.39;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.10.12.16.38.21;	author jordan;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.30.04.16.15;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.30.04.03.13;	author jordan;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.29.00.54.23;	author canacar;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Revert 1.54, go back to always trying to enable burst mode

Selectively enabling burst mode seems to have broken more machines
than it helped.  On MacBooks, EC_STAT_OBF occasionally won't show up
when trying to read a byte of data when bursting hasn't been
enabled, so acpiec_wait can spin forever.

This again breaks on ECs that don't do burst at all, like the Chrome
EC, but those are much more scarce than MacBooks at this time.  A
machine/bios-dependent check could be added later to disable
bursting on certain machines.

Discussed with deraadt
@
text
@/* $OpenBSD: acpiec.c,v 1.55 2016/10/25 06:55:59 pirofti Exp $ */
/*
 * Copyright (c) 2006 Can Erkin Acar <canacar@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

#include <sys/sensors.h>

int		acpiec_match(struct device *, void *, void *);
void		acpiec_attach(struct device *, struct device *, void *);

u_int8_t	acpiec_status(struct acpiec_softc *);
u_int8_t	acpiec_read_data(struct acpiec_softc *);
void		acpiec_write_cmd(struct acpiec_softc *, u_int8_t);
void		acpiec_write_data(struct acpiec_softc *, u_int8_t);
void		acpiec_burst_enable(struct acpiec_softc *sc);
void		acpiec_burst_disable(struct acpiec_softc *sc);

u_int8_t	acpiec_read_1(struct acpiec_softc *, u_int8_t);
void		acpiec_write_1(struct acpiec_softc *, u_int8_t, u_int8_t);

void		acpiec_read(struct acpiec_softc *, u_int8_t, int, u_int8_t *);
void		acpiec_write(struct acpiec_softc *, u_int8_t, int, u_int8_t *);

int		acpiec_getcrs(struct acpiec_softc *,
		    struct acpi_attach_args *);
int		acpiec_parse_resources(int, union acpi_resource *, void *);

void		acpiec_wait(struct acpiec_softc *, u_int8_t, u_int8_t);
void		acpiec_sci_event(struct acpiec_softc *);

void		acpiec_get_events(struct acpiec_softc *);

int		acpiec_gpehandler(struct acpi_softc *, int, void *);

void		acpiec_lock(struct acpiec_softc *);
void		acpiec_unlock(struct acpiec_softc *);

/* EC Status bits */
#define		EC_STAT_SMI_EVT	0x40	/* SMI event pending */
#define		EC_STAT_SCI_EVT	0x20	/* SCI event pending */
#define		EC_STAT_BURST	0x10	/* Controller in burst mode */
#define		EC_STAT_CMD	0x08	/* data is command */
#define		EC_STAT_IBF	0x02	/* input buffer full */
#define		EC_STAT_OBF	0x01	/* output buffer full */

/* EC Commands */
#define		EC_CMD_RD	0x80	/* Read */
#define		EC_CMD_WR	0x81	/* Write */
#define		EC_CMD_BE	0x82	/* Burst Enable */
#define		EC_CMD_BD	0x83	/* Burst Disable */
#define		EC_CMD_QR	0x84	/* Query */

int	acpiec_reg(struct acpiec_softc *);

struct cfattach acpiec_ca = {
	sizeof(struct acpiec_softc), acpiec_match, acpiec_attach
};

struct cfdriver acpiec_cd = {
	NULL, "acpiec", DV_DULL
};

const char *acpiec_hids[] = { ACPI_DEV_ECD, 0 };

void
acpiec_wait(struct acpiec_softc *sc, u_int8_t mask, u_int8_t val)
{
	static int acpiecnowait;
	u_int8_t		stat;

	dnprintf(40, "%s: EC wait_ns for: %b == %02x\n",
	    DEVNAME(sc), (int)mask,
	    "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF", (int)val);

	while (((stat = acpiec_status(sc)) & mask) != val) {
		if (stat & EC_STAT_SCI_EVT)
			sc->sc_gotsci = 1;
		if (cold || (stat & EC_STAT_BURST))
			delay(1);
		else
			tsleep(&acpiecnowait, PWAIT, "acpiec", 1);
	}

	dnprintf(40, "%s: EC wait_ns, stat: %b\n", DEVNAME(sc), (int)stat,
	    "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");
}

u_int8_t
acpiec_status(struct acpiec_softc *sc)
{
	return (bus_space_read_1(sc->sc_cmd_bt, sc->sc_cmd_bh, 0));
}

void
acpiec_write_data(struct acpiec_softc *sc, u_int8_t val)
{
	acpiec_wait(sc, EC_STAT_IBF, 0);
	dnprintf(40, "acpiec: write_data -- %d\n", (int)val);
	bus_space_write_1(sc->sc_data_bt, sc->sc_data_bh, 0, val);
}

void
acpiec_write_cmd(struct acpiec_softc *sc, u_int8_t val)
{
	acpiec_wait(sc, EC_STAT_IBF, 0);
	dnprintf(40, "acpiec: write_cmd -- %d\n", (int)val);
	bus_space_write_1(sc->sc_cmd_bt, sc->sc_cmd_bh, 0, val);
}

u_int8_t
acpiec_read_data(struct acpiec_softc *sc)
{
	u_int8_t		val;

	acpiec_wait(sc, EC_STAT_OBF, EC_STAT_OBF);
	val = bus_space_read_1(sc->sc_data_bt, sc->sc_data_bh, 0);

	dnprintf(40, "acpiec: read_data %d\n", (int)val);

	return (val);
}

void
acpiec_sci_event(struct acpiec_softc *sc)
{
	u_int8_t		evt;

	sc->sc_gotsci = 0;

	acpiec_wait(sc, EC_STAT_IBF, 0);
	bus_space_write_1(sc->sc_cmd_bt, sc->sc_cmd_bh, 0, EC_CMD_QR);

	acpiec_wait(sc, EC_STAT_OBF, EC_STAT_OBF);
	evt = bus_space_read_1(sc->sc_data_bt, sc->sc_data_bh, 0);

	if (evt) {
		dnprintf(10, "%s: sci_event: 0x%02x\n", DEVNAME(sc), (int)evt);
		aml_evalnode(sc->sc_acpi, sc->sc_events[evt].event, 0, NULL,
		    NULL);
	}
}

u_int8_t
acpiec_read_1(struct acpiec_softc *sc, u_int8_t addr)
{
	u_int8_t		val;

	if ((acpiec_status(sc) & EC_STAT_SCI_EVT) == EC_STAT_SCI_EVT)
		sc->sc_gotsci = 1;

	acpiec_write_cmd(sc, EC_CMD_RD);
	acpiec_write_data(sc, addr);

	val = acpiec_read_data(sc);

	return (val);
}

void
acpiec_write_1(struct acpiec_softc *sc, u_int8_t addr, u_int8_t data)
{
	if ((acpiec_status(sc) & EC_STAT_SCI_EVT) == EC_STAT_SCI_EVT)
		sc->sc_gotsci = 1;

	acpiec_write_cmd(sc, EC_CMD_WR);
	acpiec_write_data(sc, addr);
	acpiec_write_data(sc, data);
}

void
acpiec_burst_enable(struct acpiec_softc *sc)
{
	acpiec_write_cmd(sc, EC_CMD_BE);
	acpiec_read_data(sc);
}

void
acpiec_burst_disable(struct acpiec_softc *sc)
{
	if ((acpiec_status(sc) & EC_STAT_BURST) == EC_STAT_BURST)
		acpiec_write_cmd(sc, EC_CMD_BD);
}

void
acpiec_read(struct acpiec_softc *sc, u_int8_t addr, int len, u_int8_t *buffer)
{
	int			reg;

	/*
	 * this works because everything runs in the acpi thread context.
	 * at some point add a lock to deal with concurrency so that a
	 * transaction does not get interrupted.
	 */
	dnprintf(20, "%s: read %d, %d\n", DEVNAME(sc), (int)addr, len);
	sc->sc_ecbusy = 1;
	acpiec_burst_enable(sc);
	for (reg = 0; reg < len; reg++)
		buffer[reg] = acpiec_read_1(sc, addr + reg);
	acpiec_burst_disable(sc);
	sc->sc_ecbusy = 0;
}

void
acpiec_write(struct acpiec_softc *sc, u_int8_t addr, int len, u_int8_t *buffer)
{
	int			reg;

	/*
	 * this works because everything runs in the acpi thread context.
	 * at some point add a lock to deal with concurrency so that a
	 * transaction does not get interrupted.
	 */
	dnprintf(20, "%s: write %d, %d\n", DEVNAME(sc), (int)addr, len);
	sc->sc_ecbusy = 1;
	acpiec_burst_enable(sc);
	for (reg = 0; reg < len; reg++)
		acpiec_write_1(sc, addr + reg, buffer[reg]);
	acpiec_burst_disable(sc);
	sc->sc_ecbusy = 0;
}

int
acpiec_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata		*cf = match;
	struct acpi_ecdt	*ecdt = aa->aaa_table;
	struct acpi_softc	*acpisc = (struct acpi_softc *)parent;

	/* Check for early ECDT table attach */
	if (ecdt && 
	    !memcmp(ecdt->hdr.signature, ECDT_SIG, sizeof(ECDT_SIG) - 1))
		return (1);
	if (acpisc->sc_ec)
		return (0);

	/* sanity */
	return (acpi_matchhids(aa, acpiec_hids, cf->cf_driver->cd_name));
}

void
acpiec_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpiec_softc	*sc = (struct acpiec_softc *)self;
	struct acpi_attach_args *aa = aux;
	struct aml_value res;
	int64_t st;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL, &st))
		st = STA_PRESENT | STA_ENABLED | STA_DEV_OK;
	if ((st & STA_PRESENT) == 0) {
		printf(": not present\n");
		return;
	}

	printf("\n");
	if (acpiec_getcrs(sc, aa)) {
		printf("%s: Failed to read resource settings\n", DEVNAME(sc));
		return;
	}

	sc->sc_acpi->sc_ec = sc;

	if (acpiec_reg(sc)) {
		printf("%s: Failed to register address space\n", DEVNAME(sc));
		return;
	}

	acpiec_get_events(sc);

	dnprintf(10, "%s: GPE: %d\n", DEVNAME(sc), sc->sc_gpe);

#ifndef SMALL_KERNEL
	acpi_set_gpehandler(sc->sc_acpi, sc->sc_gpe, acpiec_gpehandler,
	    sc, 1);
#endif

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_GLK", 0, NULL, &res))
		sc->sc_glk = 0;
	else if (res.type != AML_OBJTYPE_INTEGER)
		sc->sc_glk = 0;
	else
		sc->sc_glk = res.v_integer ? 1 : 0;
}

void
acpiec_get_events(struct acpiec_softc *sc)
{
	int			idx;
	char			name[16];

	memset(sc->sc_events, 0, sizeof(sc->sc_events));
	for (idx = 0; idx < ACPIEC_MAX_EVENTS; idx++) {
		snprintf(name, sizeof(name), "_Q%02X", idx);
		sc->sc_events[idx].event = aml_searchname(sc->sc_devnode, name);
		if (sc->sc_events[idx].event != NULL)
			dnprintf(10, "%s: Found event %s\n", DEVNAME(sc), name);
	}
}

int
acpiec_gpehandler(struct acpi_softc *acpi_sc, int gpe, void *arg)
{
	struct acpiec_softc	*sc = arg;
	u_int8_t		mask, stat, en;
	int			s;

	KASSERT(sc->sc_ecbusy == 0);
	dnprintf(10, "ACPIEC: got gpe\n");

	do {
		if (sc->sc_gotsci)
			acpiec_sci_event(sc);

		stat = acpiec_status(sc);
		dnprintf(40, "%s: EC interrupt, stat: %b\n",
		    DEVNAME(sc), (int)stat,
		    "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");

		if (stat & EC_STAT_SCI_EVT)
			sc->sc_gotsci = 1;
		else
			sc->sc_gotsci = 0;
	} while (sc->sc_gotsci);

	/* Unmask the GPE which was blocked at interrupt time */
	s = spltty();
	mask = (1L << (gpe & 7));
	en = acpi_read_pmreg(acpi_sc, ACPIREG_GPE_EN, gpe>>3);
	acpi_write_pmreg(acpi_sc, ACPIREG_GPE_EN, gpe>>3, en | mask);
	splx(s);

	return (0);
}

int
acpiec_parse_resources(int crsidx, union acpi_resource *crs, void *arg)
{
	struct acpiec_softc *sc = arg;
	int type = AML_CRSTYPE(crs);

	switch (crsidx) {
	case 0:
		if (type != SR_IOPORT) {
			printf("%s: Unexpected resource #%d type %d\n",
			    DEVNAME(sc), crsidx, type);
			break;
		}
		sc->sc_data_bt = sc->sc_acpi->sc_iot;
		sc->sc_ec_data = crs->sr_ioport._max;
		break;
	case 1:
		if (type != SR_IOPORT) {
			printf("%s: Unexpected resource #%d type %d\n",
			    DEVNAME(sc), crsidx, type);
			break;
		}
		sc->sc_cmd_bt = sc->sc_acpi->sc_iot;
		sc->sc_ec_sc = crs->sr_ioport._max;
		break;
	case 2:
		if (!sc->sc_acpi->sc_hw_reduced) {
			printf("%s: Not running on HW-Reduced ACPI type %d\n",
			    DEVNAME(sc), type);
			break;
		}
		/* XXX: handle SCI GPIO  */
		break;
	default:
		printf("%s: invalid resource #%d type %d\n",
		    DEVNAME(sc), crsidx, type);
	}

	return 0;
}

int
acpiec_getcrs(struct acpiec_softc *sc, struct acpi_attach_args *aa)
{
	struct aml_value	res;
	int64_t			gpe;
	struct acpi_ecdt	*ecdt = aa->aaa_table;
	extern struct aml_node	aml_root;
	int			rc;

	/* Check if this is ECDT initialization */
	if (ecdt) {
		/* Get GPE, Data and Control segments */
		sc->sc_gpe = ecdt->gpe_bit;

		if (ecdt->ec_control.address_space_id == GAS_SYSTEM_IOSPACE)
			sc->sc_cmd_bt = sc->sc_acpi->sc_iot;
		else
			sc->sc_cmd_bt = sc->sc_acpi->sc_memt;
		sc->sc_ec_sc = ecdt->ec_control.address;

		if (ecdt->ec_data.address_space_id == GAS_SYSTEM_IOSPACE)
			sc->sc_data_bt = sc->sc_acpi->sc_iot;
		else
			sc->sc_data_bt = sc->sc_acpi->sc_memt;
		sc->sc_ec_data = ecdt->ec_data.address;

		/* Get devnode from header */
		sc->sc_devnode = aml_searchname(&aml_root, ecdt->ec_id);

		goto ecdtdone;
	}

	rc = aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
	    "_GPE", 0, NULL, &gpe);
	if (rc) {
		dnprintf(10, "%s: no _GPE\n", DEVNAME(sc));
		return (1);
	}

	sc->sc_gpe = gpe;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CRS", 0, NULL, &res)) {
		dnprintf(10, "%s: no _CRS\n", DEVNAME(sc));
		return (1);
	}

	/* Parse CRS to get control and data registers */

	if (res.type != AML_OBJTYPE_BUFFER) {
		dnprintf(10, "%s: unknown _CRS type %d\n",
		    DEVNAME(sc), res.type);
		aml_freevalue(&res);
		return (1);
	}

	aml_parse_resource(&res, acpiec_parse_resources, sc);
	aml_freevalue(&res);
	if (sc->sc_ec_data == 0 || sc->sc_ec_sc == 0) {
		printf("%s: failed to read from _CRS\n", DEVNAME(sc));
		return (1);
	}

ecdtdone:

	dnprintf(10, "%s: Data: 0x%lx, S/C: 0x%lx\n",
	    DEVNAME(sc), sc->sc_ec_data, sc->sc_ec_sc);

	if (bus_space_map(sc->sc_cmd_bt, sc->sc_ec_sc, 1, 0, &sc->sc_cmd_bh)) {
		dnprintf(10, "%s: failed to map S/C reg.\n", DEVNAME(sc));
		return (1);
	}

	rc = bus_space_map(sc->sc_data_bt, sc->sc_ec_data, 1, 0,
	    &sc->sc_data_bh);
	if (rc) {
		dnprintf(10, "%s: failed to map DATA reg.\n", DEVNAME(sc));
		bus_space_unmap(sc->sc_cmd_bt, sc->sc_cmd_bh, 1);
		return (1);
	}

	return (0);
}

int
acpiec_reg(struct acpiec_softc *sc)
{
	struct aml_value arg[2];
	struct aml_node *node;

	memset(&arg, 0, sizeof(arg));
	arg[0].type = AML_OBJTYPE_INTEGER;
	arg[0].v_integer = ACPI_OPREG_EC;
	arg[1].type = AML_OBJTYPE_INTEGER;
	arg[1].v_integer = 1;

	node = aml_searchname(sc->sc_devnode, "_REG");
	if (node && aml_evalnode(sc->sc_acpi, node, 2, arg, NULL)) {
		dnprintf(10, "%s: eval method _REG failed\n", DEVNAME(sc));
		printf("acpiec _REG failed, broken BIOS\n");
	}

	return (0);
}

void
acpiec_lock(struct acpiec_softc *sc)
{
	KASSERT(sc->sc_ecbusy == 0);

	sc->sc_ecbusy = 1;

	if (sc->sc_glk) {
		acpi_glk_enter();
	}
}

void
acpiec_unlock(struct acpiec_softc *sc)
{
	KASSERT(sc->sc_ecbusy == 1);

	if (sc->sc_glk) {
		acpi_glk_leave();
	}

	sc->sc_ecbusy = 0;
}
@


1.55
log
@Deduplicate the CRS parsing code and handle broken ACPI implementations.

This change was prompted by a report from Ilya Kaliman where acpiec(4)
failed to initialize on his Acer Aspire S7.

Further investigations showed that the machine had 4 instead of 2 resources
defined inside the EC device which is a violation of all existing ACPI
revisions.


We now handle such machines by using the aml resource parser directly, which
lead to the removal of the existing one from acpiec.c, and ignoring extra
resources (although they are reported in the dmesg).

In the process I also done a couple of more style(9) fixes.


Suggested by and ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.54 2016/08/23 18:26:21 jcs Exp $ */
d221 1
a221 2
	if (len > 1)
		acpiec_burst_enable(sc);
d224 1
a224 2
	if (len > 1)
		acpiec_burst_disable(sc);
d240 1
a240 2
	if (len > 1)
		acpiec_burst_enable(sc);
d243 1
a243 2
	if (len > 1)
		acpiec_burst_disable(sc);
@


1.54
log
@don't enter burst mode for single-byte reads and writes.

avoids problems on hardware with broken or unimplemented burst mode
and isn't really necessary for such small transactions anyway.
matches what linux and freebsd have done for a long time.

tested in snaps
ok deraadt kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.53 2016/05/07 18:03:36 kettenis Exp $ */
d51 1
a51 1
int		acpiec_getregister(const u_int8_t *, int, int *, bus_size_t *);
d288 1
d290 1
a290 1
		printf(": Failed to read resource settings\n");
d297 1
a297 1
		printf(": Failed to register address space\n");
d309 1
a309 1
	
a315 2

	printf("\n");
a367 1
/* parse the resource buffer to get a 'register' value */
d369 1
a369 1
acpiec_getregister(const u_int8_t *buf, int size, int *type, bus_size_t *addr)
d371 2
a372 1
	int			len, hlen;
d374 30
a403 18
#define RES_TYPE_MASK 0x80
#define RES_LENGTH_MASK 0x07
#define RES_TYPE_IOPORT	0x47
#define RES_TYPE_ENDTAG	0x79

	if (size <= 0)
		return (0);

	if (*buf & RES_TYPE_MASK) {
		/* large resource */
		if (size < 3)
			return (1);
		len = (int)buf[1] + 256 * (int)buf[2];
		hlen = 3;
	} else {
		/* small resource */
		len = buf[0] & RES_LENGTH_MASK;
		hlen = 1;
d406 1
a406 12
	/* XXX todo: decode other types */
	if (*buf != RES_TYPE_IOPORT)
		return (0);

	if (size < hlen + len)
		return (0);

	/* XXX validate? */
	*type = GAS_SYSTEM_IOSPACE;
	*addr = (int)buf[2] + 256 * (int)buf[3];

	return (hlen + len);
a412 4
	bus_size_t		ec_sc, ec_data;
	int			dtype, ctype;
	char			*buf;
	int			size, ret;
d416 1
d423 5
a427 2
		ctype = ecdt->ec_control.address_space_id;
		ec_sc = ecdt->ec_control.address;
d429 5
a433 2
		dtype = ecdt->ec_data.address_space_id;
		ec_data = ecdt->ec_data.address;
d441 3
a443 1
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "_GPE", 0, NULL, &gpe)) {
d464 4
a467 28
	size = res.length;
	buf = res.v_buffer;

	ret = acpiec_getregister(buf, size, &dtype, &ec_data);
	if (ret <= 0) {
		dnprintf(10, "%s: failed to read DATA from _CRS\n",
		    DEVNAME(sc));
		aml_freevalue(&res);
		return (1);
	}

	buf += ret;
	size -= ret;

	ret = acpiec_getregister(buf, size, &ctype, &ec_sc);
	if (ret <= 0) {
		dnprintf(10, "%s: failed to read S/C from _CRS\n",
		    DEVNAME(sc));
		aml_freevalue(&res);
		return (1);
	}

	buf += ret;
	size -= ret;

	if (size != 2 || *buf != RES_TYPE_ENDTAG) {
		dnprintf(10, "%s: no _CRS end tag\n", DEVNAME(sc));
		aml_freevalue(&res);
a469 1
	aml_freevalue(&res);
a470 1
	/* XXX: todo - validate _CRS checksum? */
d474 1
a474 1
	    DEVNAME(sc), ec_data, ec_sc);
d476 1
a476 6
	if (ctype == GAS_SYSTEM_IOSPACE)
		sc->sc_cmd_bt = aa->aaa_iot;
	else
		sc->sc_cmd_bt = aa->aaa_memt;

	if (bus_space_map(sc->sc_cmd_bt, ec_sc, 1, 0, &sc->sc_cmd_bh)) {
d481 3
a483 6
	if (dtype == GAS_SYSTEM_IOSPACE)
		sc->sc_data_bt = aa->aaa_iot;
	else
		sc->sc_data_bt = aa->aaa_memt;

	if (bus_space_map(sc->sc_data_bt, ec_data, 1, 0, &sc->sc_data_bh)) {
@


1.53
log
@Add defines for Operation Region Address Space Identifiers and use them when
acpiec(4) calls the _REG method.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.52 2015/03/14 03:38:46 jsg Exp $ */
d221 2
a222 1
	acpiec_burst_enable(sc);
d225 2
a226 1
	acpiec_burst_disable(sc);
d242 2
a243 1
	acpiec_burst_enable(sc);
d246 2
a247 1
	acpiec_burst_disable(sc);
@


1.52
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.51 2014/09/14 14:17:24 jsg Exp $ */
a77 2
#define		REG_TYPE_EC	3

d525 1
a525 1
	arg[0].v_integer = REG_TYPE_EC;
@


1.51
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.50 2014/06/25 07:46:14 kettenis Exp $ */
a21 1
#include <sys/malloc.h>
@


1.50
log
@If the Embedded Contoller device has a _STA method, evaluate it and bail out
early during attach if it signals that the device isn't present.

Reduces the noise on machines where the AML provides an (incomplete)
description of the Embedded Controller but doesn't actually have one.

ok mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.49 2014/05/21 02:14:07 mlarkin Exp $ */
a18 1
#include <sys/proc.h>
@


1.49
log
@Fix invalid / missing format specifiers in several dnprintf statements
(used only when ACPI_DEBUG is enabled)

From a diff on tech@@ by Fabian Raetz, with a minor change by me, tested
on i386 and amd64 with ACPI_DEBUG enabled and disabled.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.48 2013/07/02 18:37:47 kettenis Exp $ */
d276 1
d280 7
@


1.48
log
@If after processing an SCI event the SCI_EVT is no longer sent, we're done
and shouldn't do another SCI query.  Such a spurious SCI query blocks on
certain HP laptops, which in turn blocks the acpi thread.

tested by many
ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.47 2013/01/18 06:02:51 pirofti Exp $ */
a144 1
	dnprintf(40, "acpiec: read_data\n", (int)val);
d147 2
d486 1
a486 1
	dnprintf(10, "%s: Data: 0x%x, S/C: 0x%x\n",
@


1.47
log
@acpi: add acpiec_lock and acpi_unlock routines.

The routines check if the AML requires us to acquire the global lock by
checking a flag stored in the soft state at attach and locks or unlocks
if true.

This is just building locking framework and is not hooked in any way to
the kernel.

Okay kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.46 2012/07/13 10:37:40 pirofti Exp $ */
d346 2
@


1.46
log
@Make the ACPI EC aware of the AML global lock.

Comments from kettenis@@ and matthew@@.

Okay deraadt@@, kettenis@@.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.45 2012/03/10 21:27:07 kettenis Exp $ */
d62 3
d529 24
@


1.45
log
@Seems the _REG method is optional, so only run it if it is present.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.44 2011/01/09 22:27:21 jordan Exp $ */
d256 2
a257 1
	if (ecdt && !memcmp(ecdt->hdr.signature, ECDT_SIG, sizeof(ECDT_SIG) - 1))
d271 1
d296 7
@


1.44
log
@Continue loading acpiec even if _REG fails.. allows HP G62 to work properly
Linux does the same with error message.  _REG only notifies AML that acpiec
config space is available.
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.43 2010/08/08 17:25:41 kettenis Exp $ */
d502 1
d510 2
a511 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_REG", 2,
	    arg, NULL) != 0) {
@


1.43
log
@Stop recursion introduced in rev 1.42, by reverting most of that commit.
We keep the busy diagnostic for now.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.42 2010/08/03 16:55:06 marco Exp $ */
d512 1
a512 1
		return (1);
@


1.42
log
@Add busy flag so that we don't act on a SCI until a command in progress
completes.  Written with jordan.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.41 2010/08/02 17:13:57 deraadt Exp $ */
a225 2
	if (sc->sc_gotsci)
		acpiec_sci_event(sc);
a244 2
	if (sc->sc_gotsci)
		acpiec_sci_event(sc);
d320 1
d324 1
a324 1
		if (sc->sc_gotsci && !sc->sc_ecbusy)
@


1.41
log
@The EC GPE is always edge.  edge interrupts have their STS bit reset
at interrupt reception; level interrupts have STS cleared when processing
is complete.  Since the STS has already been reset at interrupt reception
we should not reset late..
Found by marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.40 2010/07/29 18:32:26 kettenis Exp $ */
d220 1
d225 3
d241 1
d246 3
d327 1
a327 1
		if (sc->sc_gotsci)
@


1.40
log
@Don't set sc_ec until after the EC registers are mapped, but before we
execute the _REG method to make the EC available to the AML.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.39 2010/07/27 22:57:22 deraadt Exp $ */
a333 1
	acpi_write_pmreg(acpi_sc, ACPIREG_GPE_STS, gpe>>3, mask);
@


1.39
log
@do not match a 2nd EC if something horrible happens; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.38 2010/07/27 22:32:51 marco Exp $ */
a269 2
	sc->sc_acpi->sc_ec = sc;

d274 2
@


1.38
log
@Spaces vs tab
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.37 2010/07/27 21:55:54 marco Exp $ */
d187 1
a187 1
	if ((acpiec_status(sc) & EC_STAT_SCI_EVT)  == EC_STAT_SCI_EVT)
d249 1
d254 2
a269 4
	if (sc->sc_acpi->sc_ec != NULL) {
		printf(": Only single EC is supported\n");
		return;
	}
d335 2
a336 2
	en = acpi_read_pmreg(acpi_sc, ACPIREG_GPE_EN,  gpe>>3);
	acpi_write_pmreg(acpi_sc, ACPIREG_GPE_EN,  gpe>>3, en | mask);
d446 1
a446 1
	ret = acpiec_getregister(buf, size, &ctype,  &ec_sc);
@


1.37
log
@Revert 1.34 certain systems need the parent ec pointer initialized earlier.
This fixes acpi interrupts on the latitude e6500.

Tested on e6500 and x61.

debugged with, and ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.36 2010/07/27 06:12:50 deraadt Exp $ */
d393 1
a393 1
	extern struct aml_node   aml_root;
@


1.36
log
@annoying spaces getting in the way
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.35 2010/07/27 05:17:36 jordan Exp $ */
d271 1
a282 1
	sc->sc_acpi->sc_ec = sc;
@


1.35
log
@Early initialization of acpiec if ECDT table exists
Fixes hang when booting thinkpads while docked
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.34 2010/07/23 20:21:58 jordan Exp $ */
d248 1
a248 1
	struct acpi_ecdt 	*ecdt = aa->aaa_table;
@


1.34
log
@Don't initialize acpiec pointer in acpi_softc until registration succeeds
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.33 2010/07/23 20:19:21 jordan Exp $ */
d248 5
d392 19
d466 1
@


1.33
log
@Control/data registers were being mapped with swapped io space tags
Fix naming & order of tag to be clear
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.32 2010/07/20 12:15:24 deraadt Exp $ */
a265 1
	sc->sc_acpi->sc_ec = sc;
d277 1
@


1.32
log
@removed an unused proto
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.31 2010/07/20 12:14:10 deraadt Exp $ */
d383 1
a383 1
	int			type1, type2;
d412 1
a412 1
	ret = acpiec_getregister(buf, size, &type1, &ec_data);
d423 1
a423 1
	ret = acpiec_getregister(buf, size, &type2,  &ec_sc);
d446 1
a446 1
	if (type1 == GAS_SYSTEM_IOSPACE)
d456 1
a456 1
	if (type2 == GAS_SYSTEM_IOSPACE)
@


1.31
log
@Handle the acpi interrupt controller with proper edge/level handling,
wrapped in spltty to avoid racing against the interrupt controller.
Repair the gpe bit masking code while there, and do operations in the
right order
ok kettenis mlarkin, help from jordan at figuring out the order of
operations.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.30 2010/07/20 12:10:51 deraadt Exp $ */
a60 3

struct aml_node	*aml_find_name(struct acpi_softc *, struct aml_node *,
		    const char *);
@


1.30
log
@In acpiec_wait() we want to tsleep on an un-known channel, so that
we don't get woken up early by a wakeup()
ok kettenis; deeply tested on many machines by mlarkin
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.29 2009/11/26 18:15:24 deraadt Exp $ */
d287 1
a287 1
	    sc, "acpiec");
d312 2
a313 1
	u_int8_t		mask, stat;
a316 5
	/* Reset GPE event */
	mask = (1L << (gpe & 7));
	acpi_write_pmreg(acpi_sc, ACPIREG_GPE_STS, gpe>>3, mask);
	acpi_write_pmreg(acpi_sc, ACPIREG_GPE_EN,  gpe>>3, mask);

d329 8
@


1.29
log
@If the EC is in burst mode use the fast delay to meet the requirements
of the spec, instead of using tsleep and screwing up.
from canacar, ok kettenis jsing pirofti
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.28 2009/03/11 20:37:46 jordan Exp $ */
d97 1
d110 1
a110 1
			tsleep(sc, PWAIT, "ecwait", 1);
@


1.28
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.27 2009/03/10 20:36:10 jordan Exp $ */
d43 1
d106 1
a106 1
		if (cold)
d205 7
d221 1
a222 2
	dnprintf(20, "%s: read %d, %d\n", DEVNAME(sc), (int)addr, len);

d225 1
d238 1
a239 1
	dnprintf(20, "%s: write %d, %d\n", DEVNAME(sc), (int)addr, len);
d242 1
@


1.27
log
@Added sensor devices for Thinkpad (temp+fan)
Exported aml_evalinteger method
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.26 2008/11/06 23:41:28 marco Exp $ */
d375 1
d377 1
a377 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_GPE", 0, NULL, &res)) {
d382 1
a382 2
	sc->sc_gpe = aml_val2int(&res);
	aml_freevalue(&res);
@


1.26
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.25 2008/06/13 09:13:56 jordan Exp $ */
a79 25

#define ACPIEC_MAX_EVENTS	256

struct acpiec_event {
	struct aml_node *event;
};

struct acpiec_softc {
	struct device		sc_dev;

	/* command/status register */
	bus_space_tag_t		sc_cmd_bt;
	bus_space_handle_t	sc_cmd_bh;

	/* data register */
	bus_space_tag_t		sc_data_bt;
	bus_space_handle_t	sc_data_bh;

	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;
	u_int32_t		sc_gpe;
	struct acpiec_event	sc_events[ACPIEC_MAX_EVENTS];
	int			sc_gotsci;
};

@


1.25
log
@Fixed acpiec driver, _REG method required sc_ec member set before being called
ok @@marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.24 2008/06/01 17:59:55 marco Exp $ */
d116 1
d268 1
a268 6
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
		return (0);

	return (1);
@


1.24
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.22 2008/05/14 05:24:36 jordan Exp $ */
d288 1
a300 2

	sc->sc_acpi->sc_ec = sc;
@


1.23
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.21 2007/12/07 19:06:02 fgsch Exp $ */
d282 1
a282 1
	sc->sc_devnode = aa->aaa_node->child;
@


1.22
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d282 1
a282 1
	sc->sc_devnode = aa->aaa_node;
@


1.21
log
@do not call aml_searchname and aml_evalnode afterwards, just use
aml_evalname. marco@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.20 2007/11/12 21:41:03 deraadt Exp $ */
d282 1
a282 1
	sc->sc_devnode = aa->aaa_node->child;
@


1.20
log
@no need to print acpi name on attach
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.19 2007/11/12 21:38:31 deraadt Exp $ */
d492 1
a492 2
	struct aml_value	arg[2];
	struct aml_node		*root;
a494 1

d500 2
a501 7
	root = aml_searchname(sc->sc_devnode, "_REG");
	if (root == NULL) {
		dnprintf(10, "%s: no _REG method\n", DEVNAME(sc));
		return (1);
	}

	if (aml_evalnode(sc->sc_acpi, root, 2, arg, NULL) != 0) {
@


1.19
log
@a little less excitement (every printf does not need to end in !)
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.18 2007/02/21 20:46:57 marco Exp $ */
d310 1
a310 1
	printf(": %s\n", sc->sc_devnode->parent->name);
@


1.18
log
@Fix stuttering audio playback as reported by Igor Grabin.

Tested by several folks and ok canacar
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.17 2007/02/21 04:12:47 marco Exp $ */
d285 1
a285 1
		printf(": Only single EC is supported!\n");
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.16 2007/02/17 23:59:03 marco Exp $ */
d129 4
a132 1
		delay(1);
@


1.16
log
@Add SMALL_KERNEL throught acpi to make it fit on boot media.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.15 2006/12/23 17:24:40 canacar Exp $ */
d50 2
a51 1
int		acpiec_getcrs(struct acpiec_softc *, struct acpi_attach_args *);
d67 1
a67 1
#define	EC_STAT_BURST	0x10	/* Controller in burst mode */
d122 2
a123 1
	dnprintf(40, "%s: EC wait_ns for: %b == %02x\n", DEVNAME(sc), (int)mask,
d146 1
a146 1
	dnprintf(40, "acpiec: write_data -- %d\n", (int) val);
d154 1
a154 1
	dnprintf(40, "acpiec: write_cmd -- %d\n", (int) val);
d164 1
a164 1
	dnprintf(40, "acpiec: read_data\n", (int) val);
d184 1
a184 1
		dnprintf(10, "%s: sci_event: 0x%02x\n", DEVNAME(sc), (int) evt);
d235 1
a235 1
	dnprintf(20, "%s: read %d, %d\n", DEVNAME(sc), (int) addr, len);
d252 1
a252 1
	dnprintf(20, "%s: write %d, %d\n", DEVNAME(sc), (int) addr, len);
d343 4
a346 2
		dnprintf(40, "%s: EC interrupt, stat: %b\n", DEVNAME(sc), (int)stat,
			 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");
d372 1
a372 1
		len = (int) buf[1] + 256 * (int) buf[2];
d389 1
a389 1
	*addr = (int) buf[2] + 256 * (int) buf[3];
@


1.15
log
@Move the handling of SCI events to the acpiec gpe handler.
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.14 2006/12/21 11:33:21 deraadt Exp $ */
d300 1
d303 1
@


1.14
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.13 2006/12/21 05:53:35 marco Exp $ */
d101 1
a101 2
	int			sc_locked;
	int			sc_handling_events;
a114 14
int
acpiec_intr(struct acpiec_softc *sc)
{
	u_int8_t		stat;

	stat = acpiec_status(sc);
	dnprintf(40, "%s: EC interrupt, stat: %b\n", DEVNAME(sc), (int)stat,
	    "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");

	if ((stat & EC_STAT_SCI_EVT) != 0 && sc->sc_locked == 0)
		acpiec_sci_event(sc);

	return (0);
}
d124 3
a126 1
	while (((stat = acpiec_status(sc)) & mask) != val)
d128 1
d173 2
d181 2
a182 5
	dnprintf(10, "%s: sci_event: 0x%02x\n", DEVNAME(sc), (int) evt);

	/* FIXME this call is recursive, this works around that */
	if (sc->sc_handling_events == 0) {
		sc->sc_handling_events = 1;
a184 1
		sc->sc_handling_events = 0;
d194 1
a194 1
		acpiec_sci_event(sc);
d208 1
a208 1
		acpiec_sci_event(sc);
a231 2
	sc->sc_locked = 1;

a236 2

	sc->sc_locked = 0;
a248 2
	sc->sc_locked = 1;

a252 2

	sc->sc_locked = 0;
a278 2
	sc->sc_locked = 0;

d325 1
a325 1
	u_int8_t		mask;
a327 1
	acpiec_intr(sc);
d333 11
@


1.13
log
@Remove some more remnants of old acpiec_wait function.
Rename acpiec_wait_nosleep to acpiec_wait since the old sleeping function is
gone anyway.
Redo waiting loop to shave some more bytes of.
Tabing, spacing and some more KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.12 2006/12/21 05:24:25 marco Exp $ */
d58 1
a58 1
int     	acpiec_gpehandler(struct acpi_softc *, int, void *);
d66 1
a66 1
#define 	EC_STAT_BURST	0x10	/* Controller in burst mode */
d100 1
a100 1
  	struct acpiec_event	sc_events[ACPIEC_MAX_EVENTS];
d491 1
a491 1
       	return (0);
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.11 2006/12/21 01:42:49 marco Exp $ */
d35 2
a36 2
int	acpiec_match(struct device *, void *, void *);
void	acpiec_attach(struct device *, struct device *, void *);
d38 5
a42 5
u_int8_t acpiec_status(struct acpiec_softc *);
u_int8_t acpiec_read_data(struct acpiec_softc *);
void	acpiec_write_cmd(struct acpiec_softc *, u_int8_t);
void	acpiec_write_data(struct acpiec_softc *, u_int8_t);
void	acpiec_burst_enable(struct acpiec_softc *sc);
d44 2
a45 2
u_int8_t acpiec_read_1(struct acpiec_softc *, u_int8_t);
void	acpiec_write_1(struct acpiec_softc *, u_int8_t, u_int8_t);
d47 2
a48 2
void	acpiec_read(struct acpiec_softc *, u_int8_t, int, u_int8_t *);
void	acpiec_write(struct acpiec_softc *, u_int8_t, int, u_int8_t *);
d50 2
a51 2
int	acpiec_getcrs(struct acpiec_softc *, struct acpi_attach_args *);
int	acpiec_getregister(const u_int8_t *, int, int *, bus_size_t *);
d53 2
a54 2
void	acpiec_wait_nosleep(struct acpiec_softc *, u_int8_t, u_int8_t);
void	acpiec_sci_event(struct acpiec_softc *);
d56 1
a56 1
void	acpiec_get_events(struct acpiec_softc *);
d58 1
a58 1
int     acpiec_gpehandler(struct acpi_softc *, int, void *);
d78 2
d81 1
d119 1
a119 1
	u_int8_t stat;
a124 2
	if (stat & (EC_STAT_IBF | EC_STAT_OBF | EC_STAT_BURST ))
		wakeup(sc);
d132 1
a132 1
acpiec_wait_nosleep(struct acpiec_softc *sc, u_int8_t mask, u_int8_t val)
d134 1
a134 1
	u_int8_t stat;
d139 1
a139 3
	for (;;) {
		if (((stat = acpiec_status(sc)) & mask) == val)
			break;
d141 1
a141 1
	}
d149 1
a149 1
	return bus_space_read_1(sc->sc_cmd_bt, sc->sc_cmd_bh, 0);
d155 1
a155 1
	acpiec_wait_nosleep(sc, EC_STAT_IBF, 0);
d163 1
a163 1
	acpiec_wait_nosleep(sc, EC_STAT_IBF, 0);
d171 3
a173 2
	u_int8_t val;
	acpiec_wait_nosleep(sc, EC_STAT_OBF, EC_STAT_OBF);
d177 1
a177 1
	return val;
d183 1
a183 1
	u_int8_t evt;
d185 1
a185 1
	acpiec_wait_nosleep(sc, EC_STAT_IBF, 0);
d188 1
a188 1
	acpiec_wait_nosleep(sc, EC_STAT_OBF, EC_STAT_OBF);
d205 1
a205 1
	u_int8_t val;
d215 1
a215 1
	return val;
d239 1
a239 1
	int reg;
d260 1
a260 1
	int reg;
d333 2
a334 2
	int idx;
	char name[16];
d348 2
a349 2
	struct acpiec_softc *sc = arg;
	uint8_t mask;
d366 1
a366 1
	int len, hlen;
d405 5
a409 5
	struct aml_value res;
	bus_size_t ec_sc, ec_data;
	int type1, type2;
	char *buf;
	int size, ret;
d497 2
a498 2
	struct aml_value  arg[2];
	struct aml_node *root;
a500 2

#define	REG_TYPE_EC	3
@


1.11
log
@ECs are weird in that they generate many interrupts.  One for the actual
event and a bunch while doing reads and writes. Now that we have reworked
the interrupt code it is no longer workable to catch both in the same
handler.  So from now on no longer sleep but simply delay.  Removed the
sleep wait function completely to save some bytes too.  Worst meassured
delay was 160us.  These events are infrequent (pulling ac cable etc).
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.10 2006/12/12 17:59:09 mk Exp $ */
d120 1
a120 1
		 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");
d136 1
a136 1
		 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF", (int)val);
d144 1
a144 1
		 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");
d516 1
a516 1
		dnprintf(10, "%s: evaluating method _REG failed.\n", DEVNAME(sc));
@


1.10
log
@There is no acpiec_notify() function so don't supply a prototype.

While there, fix a typo.

ok gwk
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.9 2006/11/29 22:17:07 marco Exp $ */
a52 1
void	acpiec_wait(struct acpiec_softc *, u_int8_t, u_int8_t);
d131 1
a131 1
acpiec_wait(struct acpiec_softc *sc, u_int8_t mask, u_int8_t val)
a133 11
	dnprintf(40, "%s: EC wait for: %b == %02x\n", DEVNAME(sc), (int)mask,
		 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF", (int)val);

	for (;;) {
		if (((stat = acpiec_status(sc)) & mask) == val)
			break;
		tsleep(sc, PWAIT, "acpiec", 10);
	}
	dnprintf(40, "%s: EC wait, stat: %b\n", DEVNAME(sc), (int) stat,
		 "\20\x8IGN\x7SMI\x6SCI\05BURST\04CMD\03IGN\02IBF\01OBF");
}
a134 4
void
acpiec_wait_nosleep(struct acpiec_softc *sc, u_int8_t mask, u_int8_t val)
{
	u_int8_t stat;
d156 1
a156 1
	acpiec_wait(sc, EC_STAT_IBF, 0);
d164 1
a164 1
	acpiec_wait(sc, EC_STAT_IBF, 0);
d173 1
a173 1
	acpiec_wait(sc, EC_STAT_OBF, EC_STAT_OBF);
d324 2
a325 1
	acpi_set_gpehandler(sc->sc_acpi, sc->sc_gpe, acpiec_gpehandler, sc, "acpiec");
@


1.9
log
@After a long debate at the hackathon it was decided that the acpi implementation
is not concurrent if the sensors thread goes away.  This makes acpi completly
lockless.

help and ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.8 2006/11/25 16:25:53 jordan Exp $ */
a36 1
int	acpiec_notify(struct aml_node *, int, void *);
d64 1
a64 1
/* EC Staus bits */
@


1.8
log
@Fixed acpiec code for deadlock
acpiec events are handled at GPE/thread context, no longer need wakeup
cVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.7 2006/10/15 15:28:32 jordan Exp $ */
a23 1
#include <sys/rwlock.h>
a99 1
	struct rwlock		sc_lock;
d101 1
d209 8
a216 1
	aml_evalnode(sc->sc_acpi, sc->sc_events[evt].event, 0, NULL, NULL);
d257 6
a262 1
	rw_enter_write(&sc->sc_lock);
a271 1
	rw_exit_write(&sc->sc_lock);
d278 6
a283 1
	rw_enter_write(&sc->sc_lock);
a291 1
	rw_exit_write(&sc->sc_lock);
a317 1
	rw_init(&sc->sc_lock, "acpi_ec");
d374 1
@


1.7
log
@Fixed buggy if-else end scope
Fixed multi-level deref/index for thinkpads
Some KNF
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.6 2006/10/14 19:59:51 canacar Exp $ */
a83 1
	int active;
d100 1
a100 1
	struct acpiec_event	sc_events[ACPIEC_MAX_EVENTS];
a102 1
	int			sc_pending;
d130 1
a130 1
	return (sc->sc_pending);
d210 1
a210 6

	sc->sc_events[evt].active = 1;
	sc->sc_pending = 1;

	sc->sc_acpi->sc_wakeup = 0;
	wakeup(sc->sc_acpi);
a362 21

void
acpiec_handle_events(struct acpiec_softc *sc)
{
	int idx;

	if (sc->sc_pending == 0)
		return;

	sc->sc_pending = 0;

	for (idx = 0; idx < ACPIEC_MAX_EVENTS; idx++) {
		if (sc->sc_events[idx].active == 0 ||
		    sc->sc_events[idx].event == NULL)
			continue;
		dnprintf(10, "%s: handling event 0x%02x\n", DEVNAME(sc), idx);
		aml_evalnode(sc->sc_acpi, sc->sc_events[idx].event, 0, NULL, NULL);
		sc->sc_events[idx].active = 0;
	}
}

@


1.6
log
@Fix the checks broken during conversion to new code. The Embedded
Controller is now detected correctly. ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.5 2006/10/12 18:20:39 marco Exp $ */
a331 1
	sc->sc_acpi->sc_ec_gpemask = (1L << sc->sc_gpe);
d333 1
a333 2
	dnprintf(10, "%s: GPE: %d (%x)\n", DEVNAME(sc),
	    sc->sc_gpe, sc->sc_acpi->sc_ec_gpemask);
a336 5
#if 0
	/* Enable EC interrupt */
	acpi_enable_gpe(sc->sc_acpi, sc->sc_acpi->sc_ec_gpemask);
#endif

d527 1
a527 1
	struct aml_value	*res, arg[2];
a529 1
	memset(&res, 0, sizeof(res));
@


1.5
log
@Remove debug print.  Found by Peter Hessler.
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.4 2006/10/12 16:38:21 jordan Exp $ */
d448 1
a448 1
	if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_GPE", 0, NULL, &res)) {
d456 1
a456 1
	if (!aml_evalname(sc->sc_acpi, sc->sc_devnode, "_CRS", 0, NULL, &res)) {
@


1.4
log
@Massive ACPI changes
  Fixed ACPI leaks
  new ACPI API
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.3 2006/06/30 04:16:15 jordan Exp $ */
a368 1
	printf("ACPIEC: got gpe: %x\n", gpe);
@


1.3
log
@Support for calling Embedded Controller via new GPE interface
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.2 2006/06/30 04:03:13 jordan Exp $ */
a381 1
	struct aml_value res;
d394 1
a394 2
		aml_eval_object(sc->sc_acpi, sc->sc_events[idx].event,
		    &res, 0, NULL);
d443 1
a443 1
	struct aml_value res, env;
d449 1
a449 4
	memset(&res, 0, sizeof(res));
	memset(&env, 0, sizeof(env));

	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_GPE", &res, &env)) {
d454 2
a455 1
	sc->sc_gpe = aml_val2int(NULL, &res);
d457 1
a457 1
	if (aml_eval_name(sc->sc_acpi, sc->sc_devnode, "_CRS", &res, &env)) {
d467 1
d478 1
d489 1
d498 1
d501 1
d535 1
a535 1
	struct aml_value	res, arg[2];
d548 1
a548 2
	root = aml_find_name(sc->sc_acpi, sc->sc_devnode, "_REG");

d554 1
a554 1
	if (aml_eval_object(sc->sc_acpi, root, &res, 2, arg)) {
@


1.2
log
@Added new code for GPE handling
Also works with ACPIEC; need to fixup acpiec.c to remove original interrupt handler
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpiec.c,v 1.1 2006/05/29 00:54:23 canacar Exp $ */
d339 1
d342 1
d363 1
a363 1
acpiec_gpehandler(struct acpi_softc *sc, int gpe, void *arg)
d365 12
a376 2
  dnprintf(10, "ACPIEC: got gpe\n");
  return (0);
@


1.1
log
@Add embedded controller support.
ok marco@@ deraadt@@ testing & ok gwk@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d61 2
d337 2
d358 7
@

