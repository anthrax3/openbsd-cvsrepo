head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.4
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11;
locks; strict;
comment	@ * @;


1.57
date	2017.02.28.10.39.07;	author natano;	state Exp;
branches;
next	1.56;
commitid	7vjwd2A6pnK9Hf8n;

1.56
date	2017.02.25.20.09.20;	author jcs;	state Exp;
branches;
next	1.55;
commitid	qLBNvmeyHMMfKdYf;

1.55
date	2017.02.25.19.15.09;	author jcs;	state Exp;
branches;
next	1.54;
commitid	ndUkTPrPGQDT7QJJ;

1.54
date	2017.02.07.05.18.07;	author jsg;	state Exp;
branches;
next	1.53;
commitid	6p1Q4aotk7JqP7VW;

1.53
date	2016.10.04.23.02.05;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	ICCPVr3HYKMBRCBP;

1.52
date	2016.05.05.05.12.49;	author jsg;	state Exp;
branches;
next	1.51;
commitid	b6MESRAtkMjisb1p;

1.51
date	2016.01.10.16.30.43;	author stsp;	state Exp;
branches;
next	1.50;
commitid	mhynz8953r90c0bM;

1.50
date	2015.12.17.12.17.14;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	uJ1Ye9uiJKO8re8x;

1.49
date	2015.12.16.15.43.14;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	x3FdYfzUj8w6qrca;

1.48
date	2015.12.14.18.48.50;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	IPUs920ijYAankGc;

1.47
date	2015.12.13.23.12.11;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	jLfLhviA1JZWbr6k;

1.46
date	2015.12.13.21.17.42;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	bkoegodf6xS0xxQ1;

1.45
date	2015.09.11.07.25.04;	author guenther;	state Exp;
branches;
next	1.44;
commitid	TyRIZVNqJXg5CIfj;

1.44
date	2015.04.24.14.44.17;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	cSXUelbuftrUBWoQ;

1.43
date	2015.02.06.08.16.49;	author dcoppa;	state Exp;
branches;
next	1.42;
commitid	Y0BsHx9r6GXhiW4Y;

1.42
date	2014.12.13.05.29.50;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	LWwCCpAWmkUg1XNC;

1.41
date	2014.10.08.14.30.32;	author dcoppa;	state Exp;
branches;
next	1.40;
commitid	3wY232dLoy6UPaWb;

1.40
date	2014.10.07.11.28.59;	author sthen;	state Exp;
branches;
next	1.39;
commitid	vPBcCqRQhaT5vKyz;

1.39
date	2014.10.05.01.31.12;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	8so8yc9OvMrIdQf8;

1.38
date	2014.09.30.08.41.19;	author phessler;	state Exp;
branches;
next	1.37;
commitid	I0eLvfsPobRALdtu;

1.37
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.36;
commitid	uzzBR7hz9ncd4O6G;

1.36
date	2014.07.08.21.32.15;	author miod;	state Exp;
branches;
next	1.35;
commitid	ZAJDnHyc8V4MDnv1;

1.35
date	2014.03.24.23.22.54;	author jcs;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.04.11.57.26;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.30.05.03.16;	author mlarkin;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.19.15.49.35;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.03.15.34.48;	author sf;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.02.00.46.47;	author jcs;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.22.22.15.01;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.06.06.13.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.29.05.02.16;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.27.20.55.42;	author jcs;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.02.04.56.57;	author jordan;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.07.16.21.20;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.06.20.14.17;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.25.18.57.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.14.23.19.59;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.26.02.59.05;	author cnst;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.11.20.52.11;	author jordan;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.10.20.36.10;	author jordan;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.26.06.35.34;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.23.16.56.14;	author jcs;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.06.23.41.28;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.22.21.35.48;	author jcs;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.11.04.42.09;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.08.02.52.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.06.23.31.42;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.06.12.06.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.02.15.30.35;	author jcs;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.29.18.24.51;	author jcs;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.14.02.02.05;	author jcs;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.27.16.23.16;	author jcs;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Untangle abstract sleep modes from ACPI sleep states. This paves the way
for further work in the area.

idea and ok deraadt
ok mlarkin
@
text
@/*	$OpenBSD: acpithinkpad.c,v 1.56 2017/02/25 20:09:20 jcs Exp $	*/
/*
 * Copyright (c) 2008 joshua stein <jcs@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <dev/acpi/acpireg.h>
#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>
#include <dev/wscons/wsconsio.h>

#include <machine/apmvar.h>

#include "audio.h"
#include "wskbd.h"

#define	THINKPAD_HKEY_VERSION1		0x0100
#define	THINKPAD_HKEY_VERSION2		0x0200

#define	THINKPAD_CMOS_VOLUME_DOWN	0x00
#define	THINKPAD_CMOS_VOLUME_UP		0x01
#define	THINKPAD_CMOS_VOLUME_MUTE	0x02
#define	THINKPAD_CMOS_BRIGHTNESS_UP	0x04
#define	THINKPAD_CMOS_BRIGHTNESS_DOWN	0x05

#define	THINKPAD_BLUETOOTH_PRESENT	0x01
#define	THINKPAD_BLUETOOTH_ENABLED	0x02

/* wan (not wifi) card */
#define	THINKPAD_WAN_PRESENT		0x01
#define	THINKPAD_WAN_ENABLED		0x02

#define	THINKPAD_BUTTON_FN_F1		0x1001
#define	THINKPAD_BUTTON_LOCK_SCREEN	0x1002
#define	THINKPAD_BUTTON_BATTERY_INFO	0x1003
#define	THINKPAD_BUTTON_SUSPEND		0x1004
#define	THINKPAD_BUTTON_WIRELESS	0x1005
#define	THINKPAD_BUTTON_FN_F6		0x1006
#define	THINKPAD_BUTTON_EXTERNAL_SCREEN	0x1007
#define	THINKPAD_BUTTON_POINTER_SWITCH	0x1008
#define	THINKPAD_BUTTON_EJECT		0x1009
#define	THINKPAD_BUTTON_FN_F11		0x100b
#define	THINKPAD_BUTTON_HIBERNATE	0x100c
#define	THINKPAD_BUTTON_BRIGHTNESS_UP	0x1010
#define	THINKPAD_BUTTON_BRIGHTNESS_DOWN	0x1011
#define	THINKPAD_BUTTON_THINKLIGHT	0x1012
#define	THINKPAD_BUTTON_FN_SPACE	0x1014
#define	THINKPAD_BUTTON_VOLUME_UP	0x1015
#define	THINKPAD_BUTTON_VOLUME_DOWN	0x1016
#define	THINKPAD_BUTTON_VOLUME_MUTE	0x1017
#define	THINKPAD_BUTTON_THINKVANTAGE	0x1018
#define	THINKPAD_BUTTON_BLACK		0x101a
#define	THINKPAD_BUTTON_MICROPHONE_MUTE	0x101b
#define	THINKPAD_KEYLIGHT_CHANGED	0x101c
#define	THINKPAD_BUTTON_CONFIG		0x101d
#define	THINKPAD_BUTTON_FIND		0x101e
#define	THINKPAD_BUTTON_ALL_ACTIVEPROGS	0x101f
#define	THINKPAD_BUTTON_ALL_PROGS	0x1020

#define	THINKPAD_ADAPTIVE_NEXT		0x1101
#define	THINKPAD_ADAPTIVE_QUICK		0x1102
#define	THINKPAD_ADAPTIVE_SNIP		0x1105
#define	THINKPAD_ADAPTIVE_VOICE		0x1108
#define	THINKPAD_ADAPTIVE_GESTURES	0x110a
#define	THINKPAD_ADAPTIVE_SETTINGS	0x110e
#define	THINKPAD_ADAPTIVE_TAB		0x110f
#define	THINKPAD_ADAPTIVE_REFRESH	0x1110
#define	THINKPAD_ADAPTIVE_BACK		0x1111
#define THINKPAD_PORT_REPL_DOCKED	0x4010
#define THINKPAD_PORT_REPL_UNDOCKED	0x4011
#define	THINKPAD_TABLET_DOCKED		0x4012
#define	THINKPAD_TABLET_UNDOCKED	0x4013
#define	THINKPAD_LID_OPEN		0x5001
#define	THINKPAD_LID_CLOSED		0x5002
#define	THINKPAD_TABLET_SCREEN_NORMAL	0x500a
#define	THINKPAD_TABLET_SCREEN_ROTATED	0x5009
#define	THINKPAD_BRIGHTNESS_CHANGED	0x5010
#define	THINKPAD_TABLET_PEN_INSERTED	0x500b
#define	THINKPAD_TABLET_PEN_REMOVED	0x500c
#define	THINKPAD_SWITCH_NUMLOCK		0x6000
#define	THINKPAD_BUTTON_ROTATION_LOCK	0x6020
#define	THINKPAD_THERMAL_TABLE_CHANGED	0x6030
#define	THINKPAD_POWER_CHANGED		0x6040
#define	THINKPAD_BACKLIGHT_CHANGED	0x6050
#define	THINKPAD_BUTTON_FN_TOGGLE       0x6060
#define	THINKPAD_TABLET_SCREEN_CHANGED	0x60c0
#define	THINKPAD_SWITCH_WIRELESS	0x7000

#define THINKPAD_NSENSORS 9
#define THINKPAD_NTEMPSENSORS 8

#define THINKPAD_ECOFFSET_VOLUME	0x30
#define THINKPAD_ECOFFSET_VOLUME_MUTE_MASK 0x40
#define THINKPAD_ECOFFSET_FANLO		0x84
#define THINKPAD_ECOFFSET_FANHI		0x85

#define	THINKPAD_ADAPTIVE_MODE_HOME	1
#define	THINKPAD_ADAPTIVE_MODE_FUNCTION	3

struct acpithinkpad_softc {
	struct device		 sc_dev;

	struct acpiec_softc     *sc_ec;
	struct acpi_softc	*sc_acpi;
	struct aml_node		*sc_devnode;

	struct ksensor		 sc_sens[THINKPAD_NSENSORS];
	struct ksensordev	 sc_sensdev;

	uint64_t		 sc_thinklight;
	const char		*sc_thinklight_get;
	const char		*sc_thinklight_set;

	uint64_t		 sc_brightness;
};

extern void acpiec_read(struct acpiec_softc *, u_int8_t, int, u_int8_t *);

int	thinkpad_match(struct device *, void *, void *);
void	thinkpad_attach(struct device *, struct device *, void *);
int	thinkpad_hotkey(struct aml_node *, int, void *);
int	thinkpad_enable_events(struct acpithinkpad_softc *);
int	thinkpad_toggle_bluetooth(struct acpithinkpad_softc *);
int	thinkpad_toggle_wan(struct acpithinkpad_softc *);
int	thinkpad_cmos(struct acpithinkpad_softc *sc, uint8_t);
int	thinkpad_volume_down(struct acpithinkpad_softc *);
int	thinkpad_volume_up(struct acpithinkpad_softc *);
int	thinkpad_volume_mute(struct acpithinkpad_softc *);
int	thinkpad_brightness_up(struct acpithinkpad_softc *);
int	thinkpad_brightness_down(struct acpithinkpad_softc *);
int	thinkpad_adaptive_change(struct acpithinkpad_softc *);
int	thinkpad_activate(struct device *, int);

/* wscons hook functions */
void	thinkpad_get_thinklight(struct acpithinkpad_softc *);
void	thinkpad_set_thinklight(void *, int);
int	thinkpad_get_backlight(struct wskbd_backlight *);
int	thinkpad_set_backlight(struct wskbd_backlight *);
extern int (*wskbd_get_backlight)(struct wskbd_backlight *);
extern int (*wskbd_set_backlight)(struct wskbd_backlight *);
void	thinkpad_get_brightness(struct acpithinkpad_softc *);
void	thinkpad_set_brightness(void *, int);
int	thinkpad_get_param(struct wsdisplay_param *);
int	thinkpad_set_param(struct wsdisplay_param *);
extern int (*ws_get_param)(struct wsdisplay_param *);
extern int (*ws_set_param)(struct wsdisplay_param *);

void    thinkpad_sensor_attach(struct acpithinkpad_softc *sc);
void    thinkpad_sensor_refresh(void *);

#if NAUDIO > 0 && NWSKBD > 0
void thinkpad_attach_deferred(void *);
int thinkpad_get_volume_mute(struct acpithinkpad_softc *);
extern int wskbd_set_mixermute(long, long);
extern int wskbd_set_mixervolume(long, long);
#endif

struct cfattach acpithinkpad_ca = {
	sizeof(struct acpithinkpad_softc), thinkpad_match, thinkpad_attach,
	NULL, thinkpad_activate
};

struct cfdriver acpithinkpad_cd = {
	NULL, "acpithinkpad", DV_DULL
};

const char *acpithinkpad_hids[] = {
	"IBM0068",
	"LEN0068",
	"LEN0268",
	0
};

int
thinkpad_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	*aa = aux;
	struct cfdata *cf = match;
	int64_t	res;

	if (!acpi_matchhids(aa, acpithinkpad_hids, cf->cf_driver->cd_name))
		return (0);

	if (aml_evalinteger((struct acpi_softc *)parent, aa->aaa_node,
	    "MHKV", 0, NULL, &res))
		return (0);

	if (!(res == THINKPAD_HKEY_VERSION1 || res == THINKPAD_HKEY_VERSION2))
		return (0);

	return (1);
}

void
thinkpad_sensor_attach(struct acpithinkpad_softc *sc)
{
	int i;

	if (sc->sc_acpi->sc_ec == NULL)
		return;
	sc->sc_ec = sc->sc_acpi->sc_ec;

	/* Add temperature probes */
	strlcpy(sc->sc_sensdev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensdev.xname));
	for (i=0; i<THINKPAD_NTEMPSENSORS; i++) {
		sc->sc_sens[i].type = SENSOR_TEMP;
		sensor_attach(&sc->sc_sensdev, &sc->sc_sens[i]);
	}

	/* Add fan probe */
	sc->sc_sens[i].type = SENSOR_FANRPM;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[i]);

	sensordev_install(&sc->sc_sensdev);
}

void
thinkpad_sensor_refresh(void *arg)
{
	struct acpithinkpad_softc *sc = arg;
	u_int8_t lo, hi, i;
	int64_t tmp;
	char sname[5];

	/* Refresh sensor readings */
	for (i=0; i<THINKPAD_NTEMPSENSORS; i++) {
		snprintf(sname, sizeof(sname), "TMP%d", i);
		aml_evalinteger(sc->sc_acpi, sc->sc_ec->sc_devnode,
		    sname, 0, 0, &tmp);
		sc->sc_sens[i].value = (tmp * 1000000) + 273150000;
		if (tmp > 127 || tmp < -127)
			sc->sc_sens[i].flags = SENSOR_FINVALID;
	}

	/* Read fan RPM */
	acpiec_read(sc->sc_ec, THINKPAD_ECOFFSET_FANLO, 1, &lo);
	acpiec_read(sc->sc_ec, THINKPAD_ECOFFSET_FANHI, 1, &hi);
	sc->sc_sens[i].value = ((hi << 8L) + lo);
}

void
thinkpad_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpithinkpad_softc *sc = (struct acpithinkpad_softc *)self;
	struct acpi_attach_args	*aa = aux;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	printf("\n");

#if NAUDIO > 0 && NWSKBD > 0
	/* Defer speaker mute */
	if (thinkpad_get_volume_mute(sc) == 1)
		startuphook_establish(thinkpad_attach_deferred, sc);
#endif

	/* Set event mask to receive everything */
	thinkpad_enable_events(sc);
	thinkpad_sensor_attach(sc);

	/* Check for ThinkLight or keyboard backlight */
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "KLCG",
	    0, NULL, &sc->sc_thinklight) == 0) {
		sc->sc_thinklight_get = "KLCG";
		sc->sc_thinklight_set = "KLCS";
		wskbd_get_backlight = thinkpad_get_backlight;
		wskbd_set_backlight = thinkpad_set_backlight;
	} else if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "MLCG",
	    0, NULL, &sc->sc_thinklight) == 0) {
		sc->sc_thinklight_get = "MLCG";
		sc->sc_thinklight_set = "MLCS";
		wskbd_get_backlight = thinkpad_get_backlight;
		wskbd_set_backlight = thinkpad_set_backlight;
	}

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "PBLG",
	    0, NULL, &sc->sc_brightness) == 0) {
		ws_get_param = thinkpad_get_param;
		ws_set_param = thinkpad_set_param;
	}

	/* Run thinkpad_hotkey on button presses */
	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
	    thinkpad_hotkey, sc, ACPIDEV_POLL);
}

int
thinkpad_enable_events(struct acpithinkpad_softc *sc)
{
	struct aml_value arg, args[2];
	int64_t	mask;
	int i;

	/* Get the supported event mask */
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "MHKA",
	    0, NULL, &mask)) {
		printf("%s: no MHKA\n", DEVNAME(sc));
		return (1);
	}

	/* Update hotkey mask */
	bzero(args, sizeof(args));
	args[0].type = args[1].type = AML_OBJTYPE_INTEGER;
	for (i = 0; i < 32; i++) {
		args[0].v_integer = i + 1;
		args[1].v_integer = (((1 << i) & mask) != 0);

		if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKM",
		    2, args, NULL)) {
			printf("%s: couldn't toggle MHKM\n", DEVNAME(sc));
			return (1);
		}
	}

	/* Enable hotkeys */
	bzero(&arg, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = 1;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKC",
	    1, &arg, NULL)) {
		printf("%s: couldn't enable hotkeys\n", DEVNAME(sc));
		return (1);
	}

	return (0);
}

int
thinkpad_hotkey(struct aml_node *node, int notify_type, void *arg)
{
	struct acpithinkpad_softc *sc = arg;
	int handled = 0;
	int64_t	event;

	if (notify_type == 0x00) {
		/* Poll sensors */
		thinkpad_sensor_refresh(sc);
		return (0);
	}

	if (notify_type != 0x80)
		return (1);

	for (;;) {
		if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "MHKP",
		    0, NULL, &event))
			break;
		if (event == 0)
			break;

		switch (event) {
		case THINKPAD_BUTTON_BRIGHTNESS_UP:
			thinkpad_brightness_up(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_BRIGHTNESS_DOWN:
			thinkpad_brightness_down(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_WIRELESS:
			thinkpad_toggle_bluetooth(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_SUSPEND:
#ifndef SMALL_KERNEL
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ))
				acpi_addtask(sc->sc_acpi, acpi_sleep_task, 
				    sc->sc_acpi, ACPI_SLEEP_SUSPEND);
#endif
			handled = 1;
			break;
		case THINKPAD_BUTTON_VOLUME_MUTE:
			thinkpad_volume_mute(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_VOLUME_DOWN:
			thinkpad_volume_down(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_VOLUME_UP:
			thinkpad_volume_up(sc);
			handled = 1;
			break;
		case THINKPAD_BUTTON_MICROPHONE_MUTE:
#if NAUDIO > 0 && NWSKBD > 0
			wskbd_set_mixervolume(0, 0);
#endif
			handled = 1;
			break;
		case THINKPAD_BUTTON_HIBERNATE:
#if defined(HIBERNATE) && !defined(SMALL_KERNEL)
			if (acpi_record_event(sc->sc_acpi, APM_USER_HIBERNATE_REQ))
				acpi_addtask(sc->sc_acpi, acpi_sleep_task, 
				    sc->sc_acpi, ACPI_SLEEP_HIBERNATE);
#endif
			handled = 1;
			break;
		case THINKPAD_BUTTON_THINKLIGHT:
			thinkpad_get_thinklight(sc);
			break;
		case THINKPAD_ADAPTIVE_NEXT:
		case THINKPAD_ADAPTIVE_QUICK:
			thinkpad_adaptive_change(sc);
			handled = 1;
			break;
		case THINKPAD_BACKLIGHT_CHANGED:
			thinkpad_get_brightness(sc);
			break;
		case THINKPAD_ADAPTIVE_BACK:
		case THINKPAD_ADAPTIVE_GESTURES:
		case THINKPAD_ADAPTIVE_REFRESH:
		case THINKPAD_ADAPTIVE_SETTINGS:
		case THINKPAD_ADAPTIVE_SNIP:
		case THINKPAD_ADAPTIVE_TAB:
		case THINKPAD_ADAPTIVE_VOICE:
		case THINKPAD_KEYLIGHT_CHANGED:
		case THINKPAD_BRIGHTNESS_CHANGED:
		case THINKPAD_BUTTON_BATTERY_INFO:
		case THINKPAD_BUTTON_EJECT:
		case THINKPAD_BUTTON_EXTERNAL_SCREEN:
		case THINKPAD_BUTTON_FN_F11:
		case THINKPAD_BUTTON_FN_F1:
		case THINKPAD_BUTTON_FN_F6:
		case THINKPAD_BUTTON_FN_SPACE:
		case THINKPAD_BUTTON_FN_TOGGLE:
		case THINKPAD_BUTTON_LOCK_SCREEN:
		case THINKPAD_BUTTON_POINTER_SWITCH:
		case THINKPAD_BUTTON_THINKVANTAGE:
		case THINKPAD_BUTTON_BLACK:
		case THINKPAD_BUTTON_CONFIG:
		case THINKPAD_BUTTON_FIND:
		case THINKPAD_BUTTON_ALL_ACTIVEPROGS:
		case THINKPAD_BUTTON_ALL_PROGS:
		case THINKPAD_LID_CLOSED:
		case THINKPAD_LID_OPEN:
		case THINKPAD_PORT_REPL_DOCKED:
		case THINKPAD_PORT_REPL_UNDOCKED:
		case THINKPAD_TABLET_DOCKED:
		case THINKPAD_TABLET_UNDOCKED:
		case THINKPAD_POWER_CHANGED:
		case THINKPAD_SWITCH_WIRELESS:
		case THINKPAD_TABLET_PEN_INSERTED:
		case THINKPAD_TABLET_PEN_REMOVED:
		case THINKPAD_SWITCH_NUMLOCK:
		case THINKPAD_BUTTON_ROTATION_LOCK:
		case THINKPAD_TABLET_SCREEN_NORMAL:
		case THINKPAD_TABLET_SCREEN_ROTATED:
		case THINKPAD_TABLET_SCREEN_CHANGED:
		case THINKPAD_THERMAL_TABLE_CHANGED:
			handled = 1;
			break;
		default:
			printf("%s: unknown event 0x%03llx\n",
			    DEVNAME(sc), event);
		}
	}

	return (handled);
}

int
thinkpad_toggle_bluetooth(struct acpithinkpad_softc *sc)
{
	struct aml_value arg;
	int64_t	bluetooth;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GBDC",
	    0, NULL, &bluetooth))
		return (1);

	if (!(bluetooth & THINKPAD_BLUETOOTH_PRESENT))
		return (1);

	bzero(&arg, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = bluetooth ^ THINKPAD_BLUETOOTH_ENABLED;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "SBDC",
	    1, &arg, NULL)) {
		printf("%s: couldn't toggle bluetooth\n", DEVNAME(sc));
		return (1);
	}

	return (0);
}

int
thinkpad_toggle_wan(struct acpithinkpad_softc *sc)
{
	struct aml_value arg;
	int64_t wan;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GWAN",
	    0, NULL, &wan))
		return (1);

	if (!(wan & THINKPAD_WAN_PRESENT))
		return (1);

	bzero(&arg, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = wan ^ THINKPAD_WAN_ENABLED;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "SWAN",
	    1, &arg, NULL)) {
		printf("%s: couldn't toggle wan\n", DEVNAME(sc));
		return (1);
	}

	return (0);
}

int
thinkpad_cmos(struct acpithinkpad_softc *sc, uint8_t cmd)
{
	struct aml_value arg;

	bzero(&arg, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = cmd;
	aml_evalname(sc->sc_acpi, sc->sc_devnode, "\\UCMS", 1, &arg, NULL);
	return (0);
}

int
thinkpad_volume_down(struct acpithinkpad_softc *sc)
{
	return (thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_DOWN));
}

int
thinkpad_volume_up(struct acpithinkpad_softc *sc)
{
	return (thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_UP));
}

int
thinkpad_volume_mute(struct acpithinkpad_softc *sc)
{
	return (thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_MUTE));
}

int
thinkpad_brightness_up(struct acpithinkpad_softc *sc)
{
	return (thinkpad_cmos(sc, THINKPAD_CMOS_BRIGHTNESS_UP));
}

int
thinkpad_brightness_down(struct acpithinkpad_softc *sc)
{
	return (thinkpad_cmos(sc, THINKPAD_CMOS_BRIGHTNESS_DOWN));
}

int
thinkpad_adaptive_change(struct acpithinkpad_softc *sc)
{
	struct aml_value arg;
	int64_t	mode;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GTRW",
	    0, NULL, &mode)) {
		printf("%s: couldn't get adaptive keyboard mode\n", DEVNAME(sc));
		return (1);
	}

	bzero(&arg, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;

	if (mode == THINKPAD_ADAPTIVE_MODE_FUNCTION)
		arg.v_integer = THINKPAD_ADAPTIVE_MODE_HOME;
	else
		arg.v_integer = THINKPAD_ADAPTIVE_MODE_FUNCTION;

	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "STRW",
	    1, &arg, NULL)) {
		printf("%s: couldn't set adaptive keyboard mode\n", DEVNAME(sc));
		return (1);
	}

	return (0);
}

int
thinkpad_activate(struct device *self, int act)
{

	struct acpithinkpad_softc *sc = (struct acpithinkpad_softc *)self;
	int64_t res;
#if NAUDIO > 0 && NWSKBD > 0
	int mute;
#endif

	switch (act) {
	case DVACT_WAKEUP:
		if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GTRW",
		    0, NULL, &res) == 0)
			thinkpad_adaptive_change(sc);
#if NAUDIO > 0 && NWSKBD > 0
		mute = thinkpad_get_volume_mute(sc);
		if (mute != -1)
			wskbd_set_mixermute(mute, 1);
#endif
		break;
	}
	return (0);
}

void
thinkpad_get_thinklight(struct acpithinkpad_softc *sc)
{
	if (sc->sc_thinklight_get)
		aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
		    sc->sc_thinklight_get, 0, NULL, &sc->sc_thinklight);
}

void
thinkpad_set_thinklight(void *arg0, int arg1)
{
	struct acpithinkpad_softc *sc = arg0;
	struct aml_value arg;

	memset(&arg, 0, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = sc->sc_thinklight & 0x0f;
	aml_evalname(sc->sc_acpi, sc->sc_devnode,
	    sc->sc_thinklight_set, 1, &arg, NULL);
}

int
thinkpad_get_backlight(struct wskbd_backlight *kbl)
{
	struct acpithinkpad_softc *sc = acpithinkpad_cd.cd_devs[0];

	KASSERT(sc != NULL);

	kbl->min = 0;
	kbl->max = (sc->sc_thinklight >> 8) & 0x0f;
	kbl->curval = sc->sc_thinklight & 0x0f;

	if (kbl->max == 0)
		return (ENOTTY);

	return 0;
}

int
thinkpad_set_backlight(struct wskbd_backlight *kbl)
{
	struct acpithinkpad_softc *sc = acpithinkpad_cd.cd_devs[0];
	int maxval;

	KASSERT(sc != NULL);

	maxval = (sc->sc_thinklight >> 8) & 0x0f;

	if (maxval == 0)
		return (ENOTTY);

	if (kbl->curval > maxval)
		return EINVAL;

	sc->sc_thinklight &= ~0xff;
	sc->sc_thinklight |= kbl->curval;
	acpi_addtask(sc->sc_acpi, thinkpad_set_thinklight, sc, 0);
	acpi_wakeup(sc->sc_acpi);
	return 0;
}

void
thinkpad_get_brightness(struct acpithinkpad_softc *sc)
{
	aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
	    "PBLG", 0, NULL, &sc->sc_brightness);
}

void
thinkpad_set_brightness(void *arg0, int arg1)
{
	struct acpithinkpad_softc *sc = arg0;
	struct aml_value arg;

	memset(&arg, 0, sizeof(arg));
	arg.type = AML_OBJTYPE_INTEGER;
	arg.v_integer = sc->sc_brightness & 0xff;
	aml_evalname(sc->sc_acpi, sc->sc_devnode,
	    "PBLS", 1, &arg, NULL);
}

int
thinkpad_get_param(struct wsdisplay_param *dp)
{
	struct acpithinkpad_softc *sc = acpithinkpad_cd.cd_devs[0];

	if (sc == NULL)
		return -1;

	switch (dp->param) {
	case WSDISPLAYIO_PARAM_BRIGHTNESS:
		dp->min = 0;
		dp->max = (sc->sc_brightness >> 8) & 0xff;
		dp->curval = sc->sc_brightness & 0xff;
		return 0;
	default:
		return -1;
	}
}

int
thinkpad_set_param(struct wsdisplay_param *dp)
{
	struct acpithinkpad_softc *sc = acpithinkpad_cd.cd_devs[0];
	int maxval;

	if (sc == NULL)
		return -1;

	maxval = (sc->sc_brightness >> 8) & 0xff;

	switch (dp->param) {
	case WSDISPLAYIO_PARAM_BRIGHTNESS:
		if (dp->curval < 0)
			dp->curval = 0;
		if (dp->curval > maxval)
			dp->curval = maxval;
		sc->sc_brightness &= ~0xff;
		sc->sc_brightness |= dp->curval;
		acpi_addtask(sc->sc_acpi, thinkpad_set_brightness, sc, 0);
		acpi_wakeup(sc->sc_acpi);
		return 0;
	default:
		return -1;
	}
}

#if NAUDIO > 0 && NWSKBD > 0
void
thinkpad_attach_deferred(void *v __unused)
{
	wskbd_set_mixermute(1, 1);
}

int
thinkpad_get_volume_mute(struct acpithinkpad_softc *sc)
{
	u_int8_t vol = 0;

	if (sc->sc_acpi->sc_ec == NULL)
		return (-1);

	acpiec_read(sc->sc_acpi->sc_ec, THINKPAD_ECOFFSET_VOLUME, 1, &vol);
	return ((vol & THINKPAD_ECOFFSET_VOLUME_MUTE_MASK) ==
	    THINKPAD_ECOFFSET_VOLUME_MUTE_MASK);
}
#endif
@


1.56
log
@move vendor HIDs into their drivers, clean up some unused defines

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.55 2017/02/25 19:15:09 jcs Exp $	*/
d386 1
a386 1
				    sc->sc_acpi, ACPI_STATE_S3);
d412 1
a412 1
				    sc->sc_acpi, ACPI_STATE_S4);
@


1.55
log
@attach acpithinkpad to LEN0268 HID found on newer thinkpads
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.54 2017/02/07 05:18:07 jsg Exp $	*/
d184 3
a186 3
	ACPI_DEV_IBM,
	ACPI_DEV_LENOVO,
	ACPI_DEV_LENOVO2,
@


1.54
log
@Test for NULL before dereferencing a pointer not after.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.53 2016/10/04 23:02:05 deraadt Exp $	*/
d184 4
a187 1
	ACPI_DEV_IBM, ACPI_DEV_LENOVO, 0
@


1.53
log
@At acpithinkpad attach time determine the value of the mute, and defer
telling the audio subsystem about this later on in boot.  (Mute state
is maintained by the BIOS over a suspend, hibernate, reboot, etc -- this
may be last missing piece of the puzzle we tore our hair out in Brisbane)
diagnosis and code by Anton Lindqvist, ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.52 2016/05/05 05:12:49 jsg Exp $	*/
d664 1
a664 1
	int maxval = (sc->sc_thinklight >> 8) & 0x0f;
d668 2
d726 1
a726 1
	int maxval = (sc->sc_brightness >> 8) & 0xff;
d730 2
@


1.52
log
@Return ENOTTY in acpithinkpad backlight get/set ioctls if the maximum
value is 0 to match the behaviour when the callbacks are not set.

Prevents a divide by zero in wsconsctl(8) reported by Caspar Schutijser.

earlier version ok jung@@ deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.51 2016/01/10 16:30:43 stsp Exp $	*/
d108 2
d168 3
d266 6
d603 3
d607 1
a607 1
	switch(act) {
d612 5
d744 21
@


1.51
log
@Add thinkpad tablet dock/undock ACPI events.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.50 2015/12/17 12:17:14 kettenis Exp $	*/
d634 4
d648 3
@


1.50
log
@Add display brightness support.  This is available on the last few generations
of Thinkpads (x220 and later) and using means the brightness level is
coordinated properly with the firmware.  This gets rid of the surprising
brightness changes that would sometimes happen if you used the brightness
keys or if the firmware decided to reset the brightness level for some
other reason.

ok tedu@@, jung@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.49 2015/12/16 15:43:14 kettenis Exp $	*/
d87 2
d442 2
@


1.49
log
@Don't attempt to get the ThinkLight state if neither the KLCG nor the MLCG
methods are present.  Should fix the panic that occurs on older ThinkPads
(such as the x201) when you press the ThinkLight key.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.48 2015/12/14 18:48:50 kettenis Exp $	*/
d125 2
d146 1
a146 1
/* wskbd hook functions */
d153 6
d278 6
d408 3
a417 1
		case THINKPAD_BACKLIGHT_CHANGED:
d649 64
@


1.48
log
@Handle the keyboard backlight found on newer Thinkpads.  Doesn't handle the
machines that have both the keyboard backlight and the thinklight (x230, t430)
quite right yet.

ok jung@@ (for a slightly different version of this diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.47 2015/12/13 23:12:11 kettenis Exp $	*/
d586 3
a588 2
	aml_evalinteger(sc->sc_acpi, sc->sc_devnode,
	    sc->sc_thinklight_get, 0, NULL, &sc->sc_thinklight);
@


1.47
log
@Hook up the ThinkLight to the keyboard backlight support code.

For now this only supports the true ThinkLight.  Support for the keyboard
backlight found on the most recent ThinkPads will follow soon.

ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.46 2015/12/13 21:17:42 kettenis Exp $	*/
d123 2
d255 1
d258 8
d586 2
a587 2
	aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "KLCG",
	    0, NULL, &sc->sc_thinklight);
d598 3
a600 2
	arg.v_integer = sc->sc_thinklight;
	aml_evalname(sc->sc_acpi, sc->sc_devnode, "KLCS", 1, &arg, NULL);
d611 2
a612 2
	kbl->max = (sc->sc_thinklight >> 8) & 0xff;
	kbl->curval = sc->sc_thinklight & 0xff;
d620 1
a620 1
	int maxval = (sc->sc_thinklight >> 8) & 0xff;
@


1.46
log
@Sort button defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.45 2015/09/11 07:25:04 guenther Exp $	*/
d26 1
d121 2
d142 8
d253 6
d375 3
a402 1
		case THINKPAD_BUTTON_THINKLIGHT:
d570 50
@


1.45
log
@Ignore the 'rotation lock' button on my Yoga12
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.44 2015/04/24 14:44:17 deraadt Exp $	*/
d57 2
a68 2
#define	THINKPAD_BUTTON_FN_F11		0x100b
#define	THINKPAD_BUTTON_HIBERNATE	0x100c
@


1.44
log
@another thinkpad event to ignore; from mp39590@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.43 2015/02/06 08:16:49 dcoppa Exp $	*/
d94 1
d399 1
@


1.43
log
@
Handle hibernate button in the same way as suspend does: send an
APM_USER_HIBERNATE_REQ event so apmd(8) can get it if it's running.

ok mlarkin@@, deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.42 2014/12/13 05:29:50 deraadt Exp $	*/
d93 1
d397 1
@


1.42
log
@ThinkPad Edge E130, event 0x6060 is supposed to indicate toggle
between default Fn and media Fn modes.  We don't do that, so
ignore the toggle.
From Frederic Nowak
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.41 2014/10/08 14:30:32 dcoppa Exp $	*/
d350 3
a352 2
			acpi_addtask(sc->sc_acpi, acpi_sleep_task, 
			    sc->sc_acpi, ACPI_STATE_S4);
@


1.41
log
@
On ThinkPads, protect code handling the hibernate button with
"#if defined(HIBERNATE)"

ok deraadt@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.40 2014/10/07 11:28:59 sthen Exp $	*/
d96 1
d377 1
@


1.40
log
@zap duplicated line; Theo Buehler
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.39 2014/10/05 01:31:12 deraadt Exp $	*/
d348 1
a348 1
#ifndef SMALL_KERNEL
@


1.39
log
@two more events found on thinkpad yoga
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.38 2014/09/30 08:41:19 phessler Exp $	*/
a69 1
#define	THINKPAD_BUTTON_CONFIG		0x101d
@


1.38
log
@prevent dmesg spam from some new windows-only keys found on very new
thinkpads

OK mpi@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.37 2014/09/14 14:17:24 jsg Exp $	*/
d69 2
d97 1
d368 1
d396 1
@


1.37
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.36 2014/07/08 21:32:15 miod Exp $	*/
d69 5
d378 4
@


1.36
log
@Recognize (and ignore) ``black button'' presses. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.35 2014/03/24 23:22:54 jcs Exp $	*/
a19 1
#include <sys/proc.h>
@


1.35
log
@add support for aux button strip on newer thinkpads like the 2nd
generation x1 carbon that have done away with regular F1-F12 keys

from rivo nurges <rix at estpak.ee> and reportedly tested on x1
carbon, x220, and x61s
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.34 2013/11/04 11:57:26 mpi Exp $	*/
d66 1
d373 1
@


1.34
log
@Convert wskbd_set_mixervolume() to use a task internally instead of
being called in a workq.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.33 2013/10/30 05:03:16 mlarkin Exp $	*/
d33 2
a34 1
#define	THINKPAD_HKEY_VERSION		0x0100
d69 9
d98 3
d126 2
d137 2
a138 1
	sizeof(struct acpithinkpad_softc), thinkpad_match, thinkpad_attach
d163 1
a163 1
	if (res != THINKPAD_HKEY_VERSION)
d347 12
d484 46
@


1.33
log
@

Add "handling" for dock/undock events for non-ACPI docks to acpithinkpad.
The "handling" is just to consume the event so that no dmesg output is
printed. Since these docks have no bays, there isn't much to do on these
events anyway.

ok jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.32 2013/10/19 15:49:35 deraadt Exp $	*/
a20 1
#include <sys/workq.h>
d118 1
a118 1
extern int wskbd_set_mixervolume(long dir, int out);
d320 1
a320 2
			workq_add_task(NULL, 0, (workq_fn)wskbd_set_mixervolume,
			    (void *)(long)0, (void *)(int)0);
@


1.32
log
@Support the hibernate key (Fn-F12)
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.31 2013/07/03 15:34:48 sf Exp $	*/
d69 2
d348 2
@


1.31
log
@fix: cast void * to char *, fix format args for (u)int64_t,
tc_frequency is unsigned

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.30 2013/04/02 00:46:47 jcs Exp $	*/
d324 7
a339 1
		case THINKPAD_BUTTON_HIBERNATE:
@


1.30
log
@recognize and ignore power change event from newer thinkpads
group and sort ignored events

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.29 2013/03/22 22:15:01 kettenis Exp $	*/
d350 1
a350 1
			printf("%s: unknown event 0x%03x\n",
@


1.29
log
@Newer Thinkpads (x220, x230, t430) send a 0x6050 event whenever the brightness
keys are used.  Simply ignore this event.  We have no use for it and the
keys work just fine with the new inteldrm(4).

ok mpi@@, jsg@@, otto@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.28 2011/06/06 06:13:46 deraadt Exp $	*/
d76 2
a77 1
#define	THINKPAD_POWER_CHANGED		0x6030
a304 12
		case THINKPAD_BUTTON_HIBERNATE:
		case THINKPAD_BUTTON_FN_F1:
		case THINKPAD_BUTTON_LOCK_SCREEN:
		case THINKPAD_BUTTON_BATTERY_INFO:
		case THINKPAD_BUTTON_FN_F6:
		case THINKPAD_BUTTON_EXTERNAL_SCREEN:
		case THINKPAD_BUTTON_POINTER_SWITCH:
		case THINKPAD_BUTTON_EJECT:
		case THINKPAD_BUTTON_THINKLIGHT:
		case THINKPAD_BUTTON_FN_SPACE:
			handled = 1;
			break;
d324 13
d338 1
a338 3
		case THINKPAD_BUTTON_FN_F11:
			handled = 1;
			break;
d340 4
a343 1
		case THINKPAD_LID_CLOSED:
d346 1
a346 10
		case THINKPAD_BRIGHTNESS_CHANGED:
		case THINKPAD_TABLET_PEN_INSERTED:
		case THINKPAD_TABLET_PEN_REMOVED:
			handled = 1;
			break;
		case THINKPAD_POWER_CHANGED:
		case THINKPAD_BACKLIGHT_CHANGED:
			handled = 1;
			break;
		case THINKPAD_SWITCH_WIRELESS:
@


1.28
log
@Microphone mute button support from acpithinkpad (or elsewhere).
The audio side is a bit lacking; it does not yet mute all types of
devices.
from Alexander Polakov
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.27 2011/05/29 05:02:16 deraadt Exp $	*/
d77 1
d349 1
@


1.27
log
@Ignore errors from the UCMS method.  Some newer (really crappy, stay
away from them) thinkpads are returning garbage for the return value.
We never did anything special about the return value except spit out
some noise, so silence it.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.26 2011/04/27 20:55:42 jcs Exp $	*/
d21 1
d31 3
d66 1
d114 4
d325 7
@


1.26
log
@attach acpithinkpad to newer lenovo models like the x120e

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.25 2011/01/02 04:56:57 jordan Exp $	*/
d404 1
a404 6
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "\\UCMS",
	    1, &arg, NULL)) {
		printf("%s: cmos command 0x%x failed\n", DEVNAME(sc), cmd);
		return (1);
	}

@


1.25
log
@Re-add code for ACPI taskqueue, eliminates need for state vars in acpi softc
Serialize processing ACPI tasks for sleep/powerdown/GPE event
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.24 2010/08/07 16:21:20 deraadt Exp $	*/
d117 3
a119 1
const char *acpithinkpad_hids[] = { ACPI_DEV_THINKPAD, 0 };
@


1.24
log
@The wakeup of the acpi thread is not needed.  This code is being called
from inside the thread context, and will unwind into the middle of
acpi_thread, where it will check these variables
ok jordan marco kettenis canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.23 2010/07/06 20:14:17 deraadt Exp $	*/
d287 2
a288 1
				sc->sc_acpi->sc_sleepmode = ACPI_STATE_S3;
@


1.23
log
@Don't use a workq to do the suspend, because it races aginst the acpi
thread.  Instead, just tell the acpi thread to do the suspend for us.
This makes apmd & zzz work correctly.  While here, have acpithinkpad
attempt to post the event to apm before prompting the suspend itself.
ok kettenis marco mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.22 2009/11/25 18:57:02 deraadt Exp $	*/
d286 1
a286 1
			if (acpi_record_event(sc->sc_acpi, APM_USER_SUSPEND_REQ)) {
a287 2
				acpi_wakeup(sc->sc_acpi);
			}
@


1.22
log
@Thinkpad button suspends; ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.21 2009/09/14 23:19:59 fgsch Exp $	*/
d20 1
d28 2
d285 6
a291 1
			acpi_sleep_state(sc->sc_acpi, ACPI_STATE_S3);
@


1.21
log
@simplify code in preparation for other things. tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: acpithinkpad.c,v 1.20 2009/04/26 02:59:05 cnst Exp $	*/
d283 1
a283 4
			/*
			acpi_enter_sleep_state(sc->sc_acpi,
			    ACPI_STATE_S3);
			*/
@


1.20
log
@.desc field of the sensor struct shall not duplicate .type and .numt;  ok jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.19 2009/04/26 02:20:58 cnst Exp $ */
d42 28
a69 35
/* type 1 events */
#define	THINKPAD_BUTTON_FN_F1		0x001
#define	THINKPAD_BUTTON_LOCK_SCREEN	0x002
#define	THINKPAD_BUTTON_BATTERY_INFO	0x003
#define	THINKPAD_BUTTON_SUSPEND		0x004
#define	THINKPAD_BUTTON_WIRELESS	0x005
#define	THINKPAD_BUTTON_FN_F6		0x006
#define	THINKPAD_BUTTON_EXTERNAL_SCREEN	0x007
#define	THINKPAD_BUTTON_POINTER_SWITCH	0x008
#define	THINKPAD_BUTTON_EJECT		0x009
#define	THINKPAD_BUTTON_BRIGHTNESS_UP	0x010
#define	THINKPAD_BUTTON_BRIGHTNESS_DOWN	0x011
#define	THINKPAD_BUTTON_THINKLIGHT	0x012
#define	THINKPAD_BUTTON_FN_SPACE	0x014
#define	THINKPAD_BUTTON_VOLUME_UP	0x015
#define	THINKPAD_BUTTON_VOLUME_DOWN	0x016
#define	THINKPAD_BUTTON_VOLUME_MUTE	0x017
#define	THINKPAD_BUTTON_THINKVANTAGE	0x018
#define	THINKPAD_BUTTON_FN_F11		0x00b
#define	THINKPAD_BUTTON_HIBERNATE	0x00c

/* type 5 events */
#define	THINKPAD_LID_OPEN		0x001
#define	THINKPAD_LID_CLOSED		0x002
#define	THINKPAD_TABLET_SCREEN_NORMAL	0x00a
#define	THINKPAD_TABLET_SCREEN_ROTATED	0x009
#define	THINKPAD_BRIGHTNESS_CHANGED	0x010
#define	THINKPAD_TABLET_PEN_INSERTED	0x00b
#define	THINKPAD_TABLET_PEN_REMOVED	0x00c

/* type 6 events */
#define	THINKPAD_POWER_CHANGED		0x030

/* type 7 events */
#define	THINKPAD_SWITCH_WIRELESS	0x000
d78 1
a78 1
	struct device		sc_dev;
d84 2
a85 2
	struct ksensor           sc_sens[THINKPAD_NSENSORS];
	struct ksensordev        sc_sensdev;
d120 2
a121 3
	struct cfdata		*cf = match;
	int64_t			res;
	int			rv = 0;
d130 2
a131 2
	if (res == THINKPAD_HKEY_VERSION)
		rv = 1;
d133 1
a133 1
	return (rv);
d171 1
a171 1
		aml_evalinteger(sc->sc_acpi, sc->sc_ec->sc_devnode, 
d195 1
a195 1
	/* set event mask to receive everything */
d199 1
a199 1
	/* run thinkpad_hotkey on button presses */
d207 3
a209 3
	struct aml_value	arg, args[2];
	int64_t			mask;
	int			i, rv = 1;
d211 3
a213 2
	/* get the supported event mask */
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "MHKA", 0, NULL, &mask)) {
d215 1
a215 1
		goto fail;
d218 1
a218 1
	/* update hotkey mask */
d225 2
a226 2
		if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKM", 2, args,
		    NULL)) {
d228 1
a228 1
			goto fail;
d232 1
a232 1
	/* enable hotkeys */
d236 2
a237 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKC", 1, &arg, NULL)) {
d239 1
a239 1
		goto fail;
d242 1
a242 3
	rv = 0;
fail:
	return (rv);
d249 2
a250 2
	int			type, event, handled, rv = 1, tot = 0;
	int64_t			val;
d253 1
a253 1
		/* poll sensors */
d255 1
a255 1
		return 0;
d257 1
d259 1
a259 1
		goto fail;
d262 18
a279 88
		if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "MHKP", 0, NULL,
		    &val))
			goto done;
		if (val == 0)
			goto done;

		type = (val & 0xf000) >> 12;
		event = val & 0x0fff;
		handled = 0;

		switch (type) {
		case 1:
			switch (event) {
			case THINKPAD_BUTTON_BRIGHTNESS_UP:
				thinkpad_brightness_up(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_BRIGHTNESS_DOWN:
				thinkpad_brightness_down(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_WIRELESS:
				thinkpad_toggle_bluetooth(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_SUSPEND:
				handled = 1;
				/* 
				acpi_enter_sleep_state(sc->sc_acpi,
				    ACPI_STATE_S3);
				*/
				break;
			case THINKPAD_BUTTON_HIBERNATE:
			case THINKPAD_BUTTON_FN_F1:
			case THINKPAD_BUTTON_LOCK_SCREEN:
			case THINKPAD_BUTTON_BATTERY_INFO:
			case THINKPAD_BUTTON_FN_F6:
			case THINKPAD_BUTTON_EXTERNAL_SCREEN:
			case THINKPAD_BUTTON_POINTER_SWITCH:
			case THINKPAD_BUTTON_EJECT:
			case THINKPAD_BUTTON_THINKLIGHT:
			case THINKPAD_BUTTON_FN_SPACE:
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_DOWN:
				thinkpad_volume_down(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_UP:
				thinkpad_volume_up(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_MUTE:
				thinkpad_volume_mute(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_THINKVANTAGE:
			case THINKPAD_BUTTON_FN_F11:
				handled = 1;
				break;
			}
			break;
		case 5:
			switch (event) {
			case THINKPAD_LID_OPEN:
			case THINKPAD_LID_CLOSED:
			case THINKPAD_TABLET_SCREEN_NORMAL:
			case THINKPAD_TABLET_SCREEN_ROTATED:
			case THINKPAD_BRIGHTNESS_CHANGED:
			case THINKPAD_TABLET_PEN_INSERTED:
			case THINKPAD_TABLET_PEN_REMOVED:
				handled = 1;
				break;
			}
			break;
		case 6:
			switch (event) {
			case THINKPAD_POWER_CHANGED:
				handled = 1;
				break;
			}
			break;
		case 7:
			switch (event) {
			case THINKPAD_SWITCH_WIRELESS:
				handled = 1;
				break;
			}
d281 53
d335 1
d337 1
a337 11
		if (handled)
			tot++;
		else
			printf("%s: unknown type %d event 0x%03x\n",
			    DEVNAME(sc), type, event);
	}
done:
	if (tot)
		rv = 0;
fail:
	return (rv);
d343 2
a344 3
	struct aml_value	arg;
	int			rv = 1;
	int64_t			bluetooth;
d346 3
a348 2
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GBDC", 0, NULL, &bluetooth))
		goto fail;
d351 1
a351 1
		goto fail;
d355 3
a357 2
	arg.v_integer = bluetooth ^= THINKPAD_BLUETOOTH_ENABLED;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "SBDC", 1, &arg, NULL)) {
d359 1
a359 1
		goto fail;
d362 1
a362 3
	rv = 0;
fail:
	return (rv);
d368 2
a369 3
	struct aml_value	arg;
	int			rv = 1;
	int64_t			wan;
d371 3
a373 2
	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "GWAN", 0, NULL, &wan))
		goto fail;
d376 1
a376 1
		goto fail;
d380 3
a382 2
	arg.v_integer = (wan ^= THINKPAD_WAN_ENABLED);
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "SWAN", 1, &arg, NULL)) {
d384 1
a384 1
		goto fail;
d387 1
a387 3
	rv = 0;
fail:
	return (rv);
d393 1
a393 1
	struct aml_value	arg;
d398 2
a399 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "\\UCMS", 1, &arg,
	    NULL)) {
@


1.19
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.18 2009/03/11 20:52:11 jordan Exp $ */
a156 2
		snprintf(sc->sc_sens[i].desc, sizeof(sc->sc_sens[i].desc), 
		    "TMP%d", i);
a161 2
	strlcpy(sc->sc_sens[i].desc, "fan", 
	    sizeof(sc->sc_sens[i].desc));
d174 1
d178 1
d180 1
a180 1
		    sc->sc_sens[i].desc, 0, 0, &tmp);
@


1.18
log
@Remove noisy printf debug
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.17 2009/03/11 20:37:46 jordan Exp $ */
a159 1
		sc->sc_sens[i].value = 0;
a166 1
	sc->sc_sens[i].value = 0;
@


1.17
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.16 2009/03/10 20:36:10 jordan Exp $ */
a282 1
		printf("ibmkey type:%x event:%.3x\n", type, event);
@


1.16
log
@Added sensor devices for Thinkpad (temp+fan)
Exported aml_evalinteger method
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.15 2008/12/26 06:35:34 jsg Exp $ */
d128 1
a128 1
	struct aml_value	res;
d134 1
a134 1
	if (aml_evalname((struct acpi_softc *)parent, aa->aaa_node,
d138 1
a138 1
	if (aml_val2int(&res) == THINKPAD_HKEY_VERSION)
a140 1
	aml_freevalue(&res);
d219 1
a219 1
	struct aml_value	res, arg, args[2];
d224 1
a224 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKA", 0, NULL, &res)) {
a227 2
	mask = aml_val2int(&res);
	aml_freevalue(&res);
d261 2
a262 2
	struct aml_value	res;
	int			val, type, event, handled, rv = 1, tot = 0;
d273 2
a274 2
		if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "MHKP", 0, NULL,
		    &res))
a275 2
		val = aml_val2int(&res);
		aml_freevalue(&res);
d283 1
d381 3
a383 2
	struct aml_value	res, arg;
	int			bluetooth, rv = 1;
d385 1
a385 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "GBDC", 0, NULL, &res))
a387 3
	bluetooth = aml_val2int(&res);
	aml_freevalue(&res);

d407 3
a409 2
	struct aml_value	res, arg;
	int			wan, rv = 1;;
d411 1
a411 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "GWAN", 0, NULL, &res))
a412 3

	wan = aml_val2int(&res);
	aml_freevalue(&res);
@


1.15
log
@Back out rev 1.14 as it makes machines like the T30 crash on boot.
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.13 2008/11/06 23:41:28 marco Exp $ */
d78 6
d87 1
d90 3
d95 2
d110 3
d146 52
d210 1
d214 1
a214 1
	    thinkpad_hotkey, sc, ACPIDEV_NOPOLL);
d267 5
@


1.14
log
@only a small number of thinkpads need the brightness adjustments
done in this driver, so for everything other than the x61s and
t61, tell the bios to adjust brightness itself.  fixes the double
adjustment problem on newer models.

tested on quite a few different models.
@
text
@a34 3
#define	THINKPAD_EC_BRIGHTNESS_OFFSET	0x31
#define	THINKPAD_EC_BRIGHTNESS_LEVEL_MASK 0x1f

a84 11
/* from bios.c */
extern char *hw_ver;

/* models (according to smbios info version) that need a brightness helper */
const char *acpithinkpad_models_to_help[] = {
	"ThinkPad X61s",
	"ThinkPad T61",
};

int	thinkpad_need_helper = 0;

d95 1
a95 1
int	thinkpad_brightness_get(struct acpithinkpad_softc *);
a96 1
int	thinkpad_brightness_up(struct acpithinkpad_softc *);
a134 1
	int i;
d139 1
a139 11
	for (i = 0; i < nitems(acpithinkpad_models_to_help); i++)
		if (strcmp(hw_ver, acpithinkpad_models_to_help[i]) == 0) {
			printf(": activating brightness helper");
			thinkpad_need_helper = 1;
			break;
		}

	/* for models that don't need a brightness helper, tell the bios to
	 * adjust brightness it self */
	if (!thinkpad_need_helper)
		thinkpad_brightness_get(sc);
a146 2

	printf("\n");
a205 1

d218 8
d232 1
a232 1
				/*
a236 10
			case THINKPAD_BUTTON_BRIGHTNESS_UP:
				if (thinkpad_need_helper)
					thinkpad_brightness_up(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_BRIGHTNESS_DOWN:
				if (thinkpad_need_helper)
					thinkpad_brightness_down(sc);
				handled = 1;
				break;
d341 1
a341 1
	int			wan, rv = 1;
a397 12
}

int
thinkpad_brightness_get(struct acpithinkpad_softc *sc)
{
	uint8_t val;
	int level;

	acpiec_read(sc->sc_acpi->sc_ec, THINKPAD_EC_BRIGHTNESS_OFFSET, 1, &val);
	level = val & THINKPAD_EC_BRIGHTNESS_LEVEL_MASK;

	return level;
@


1.13
log
@Collapse all sanity checks of hids into one function.

Originaly from jordan
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.12 2008/09/22 21:35:48 jcs Exp $ */
d35 3
d88 11
d109 2
a111 1
int	thinkpad_brightness_down(struct acpithinkpad_softc *);
d150 1
d155 11
a165 1
	printf("\n");
d173 2
d234 1
a246 8
			case THINKPAD_BUTTON_BRIGHTNESS_UP:
				thinkpad_brightness_up(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_BRIGHTNESS_DOWN:
				thinkpad_brightness_down(sc);
				handled = 1;
				break;
d253 1
a253 1
				/* 
d258 10
d372 1
a372 1
	int			wan, rv = 1;;
d429 12
@


1.12
log
@ignore a type 6 event seen on my x200 when the ac adapter is
plugged in and removed
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.11 2008/06/11 04:42:09 marco Exp $ */
d106 2
d116 1
a116 3
	if (aa->aaa_name == NULL ||
	    strcmp(aa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aa->aaa_table != NULL)
@


1.11
log
@Fix $OpenBSD$ for once and for all
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.10 2008/06/08 02:52:11 deraadt Exp $ */
d72 3
d276 7
@


1.10
log
@simplify match function; ok toby
@
text
@d1 1
a1 2
/* $OpenBSD: acpithinkpad.c,v 1.9 2008/06/06 23:31:42 marco Exp $ */

@


1.9
log
@lots of KNF
Change many return x into goto fail idiom.
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.8 2008/06/06 12:06:45 deraadt Exp $ */
d115 1
a115 1
		goto fail;
d119 1
a119 1
		goto fail;
d121 2
a122 3
	rv = 1;
	if (aml_val2int(&res) != THINKPAD_HKEY_VERSION)
		rv = 0;
a124 1
fail:
@


1.8
log
@make this more like other code (done while digging into a problem...)
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.7 2008/06/02 15:30:35 jcs Exp $ */
d110 1
d115 1
a115 1
		return (0);
d121 1
d123 1
a123 1
		goto fail;
a125 2
	return (1);

d127 1
a127 2
	aml_freevalue(&res);
	return (0);
d133 2
a134 2
	struct acpithinkpad_softc	*sc = (struct acpithinkpad_softc *)self;
	struct acpi_attach_args		*aa = aux;
d152 3
a154 3
	struct aml_value res, arg, args[2];
	int64_t mask;
	int i;
d159 1
a159 1
		return (1);
d165 1
a165 1
	memset(&args, 0, sizeof(args));
d179 1
a179 1
	memset(&arg, 0, sizeof(arg));
d187 1
a187 7
	aml_freevalue(&res);
	aml_freevalue(&args[0]);
	aml_freevalue(&args[1]);
	aml_freevalue(&args[2]);
	aml_freevalue(&arg);
	return (0);

d189 1
a189 6
	aml_freevalue(&res);
	aml_freevalue(&args[0]);
	aml_freevalue(&args[1]);
	aml_freevalue(&args[2]);
	aml_freevalue(&arg);
	return (1);
d196 5
a200 2
	struct aml_value res;
	int val, type, event, handled;
d205 1
a205 2
			return (1);

d209 1
a209 1
			return (1);
d289 3
a291 1
		if (!handled)
d295 5
d305 2
a306 2
	struct aml_value res, arg;
	int bluetooth;
d308 2
a309 4
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "GBDC", 0, NULL, &res)) {
		/* no bluetooth, oh well */
		return (1);
	}
d315 1
a315 1
		return (1);
d317 1
a317 1
	memset(&arg, 0, sizeof(arg));
d322 1
a322 2
		aml_freevalue(&arg);
		return (1);
d325 3
a327 2
	aml_freevalue(&arg);
	return (0);
d333 2
a334 2
	struct aml_value res, arg;
	int wan;
d337 1
a337 1
		return (1);
d341 1
d343 1
a343 1
		return (1);
d345 1
a345 1
	memset(&arg, 0, sizeof(arg));
d347 1
a347 1
	arg.v_integer = wan ^= THINKPAD_WAN_ENABLED;
d350 1
a350 2
		aml_freevalue(&arg);
		return (1);
d353 3
a355 2
	aml_freevalue(&arg);
	return (0);
d361 1
a361 1
	struct aml_value arg;
d363 1
a363 1
	memset(&arg, 0, sizeof(arg));
a365 1

a368 1
		aml_freevalue(&arg);
a371 1
	aml_freevalue(&arg);
d378 1
a378 1
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_DOWN);
d384 1
a384 1
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_UP);
d390 1
a390 1
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_MUTE);
d396 1
a396 1
	return thinkpad_cmos(sc, THINKPAD_CMOS_BRIGHTNESS_UP);
d402 1
a402 1
	return thinkpad_cmos(sc, THINKPAD_CMOS_BRIGHTNESS_DOWN);
@


1.7
log
@ignore a brightness changed event
from Stefan Sperling <stsp at stsp.name>
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.6 2008/06/01 17:59:55 marco Exp $ */
d147 1
a147 3
		thinkpad_hotkey, sc, ACPIDEV_NOPOLL);

	return;
a192 1

a275 1

a286 1

a293 1
				
d301 1
a301 1
				DEVNAME(sc), type, event);
a331 1

a358 1

d372 1
a372 1
	NULL)) {
a378 1

d383 1
a383 1
thinkpad_volume_down(struct acpithinkpad_softc *sc) 
@


1.6
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.5 2008/05/29 18:24:51 jcs Exp $ */
d69 1
d283 2
d287 1
a287 2
			case THINKPAD_LID_OPEN:
			case THINKPAD_LID_CLOSED:
@


1.5
log
@dlg backed out one too many revisions, bring back 1.2

only do aml_freevalue when necessary, noted by deanna
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.2 2008/05/14 02:02:05 jcs Exp $ */
d115 1
a115 1
	if (aml_evalname((struct acpi_softc *)parent, aa->aaa_node->child,
d137 1
a137 1
	sc->sc_devnode = aa->aaa_node->child;
d145 1
a145 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
d176 1
a176 1
			return (1);
d186 1
a186 1
		return (1);
d189 6
d196 8
d331 1
d335 2
d359 1
d363 2
d380 1
d383 2
@


1.4
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.1 2008/04/27 16:23:16 jcs Exp $ */
d30 3
d57 3
d72 3
d89 3
d122 1
d134 1
a134 1
	struct acpi_attach_args *aa = aux;
a160 1
		aml_freevalue(&res);
d164 1
d201 1
a201 2
		    &res)) {
			aml_freevalue(&res);
a202 1
		}
d205 1
d245 14
a260 1
				/* TODO: notify userland */
a273 1
				/* TODO: notify userland */
d279 8
a302 1
		aml_freevalue(&res);
d308 1
d329 1
a329 2
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "GWAN", 0, NULL, &res)) {
		aml_freevalue(&res);
a330 1
	}
d364 18
@


1.3
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.2 2008/05/14 02:02:05 jcs Exp $ */
a29 3
#define	THINKPAD_CMOS_VOLUME_DOWN	0x00
#define	THINKPAD_CMOS_VOLUME_UP		0x01
#define	THINKPAD_CMOS_VOLUME_MUTE	0x02
a53 3
#define	THINKPAD_BUTTON_VOLUME_UP	0x015
#define	THINKPAD_BUTTON_VOLUME_DOWN	0x016
#define	THINKPAD_BUTTON_VOLUME_MUTE	0x017
a65 3
/* type 7 events */
#define	THINKPAD_SWITCH_WIRELESS	0x000

a79 3
int	thinkpad_volume_down(struct acpithinkpad_softc *);
int	thinkpad_volume_up(struct acpithinkpad_softc *);
int	thinkpad_volume_mute(struct acpithinkpad_softc *);
d103 1
a103 1
	if (aml_evalname((struct acpi_softc *)parent, aa->aaa_node,
a109 1
	aml_freevalue(&res);
d121 1
a121 1
	struct acpi_attach_args		*aa = aux;
d124 1
a124 1
	sc->sc_devnode = aa->aaa_node;
d132 1
a132 1
	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
d148 2
a149 1
		goto fail;
d163 1
a163 1
			goto fail;
d173 1
a173 1
		goto fail;
a175 6
	aml_freevalue(&res);
	aml_freevalue(&args[0]);
	aml_freevalue(&args[1]);
	aml_freevalue(&args[2]);
	aml_freevalue(&arg);

a176 8

fail:
	aml_freevalue(&res);
	aml_freevalue(&args[0]);
	aml_freevalue(&args[1]);
	aml_freevalue(&args[2]);
	aml_freevalue(&arg);
	return (1);
a193 1
		aml_freevalue(&res);
a232 14
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_DOWN:
				thinkpad_volume_down(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_UP:
				thinkpad_volume_up(sc);
				handled = 1;
				break;
			case THINKPAD_BUTTON_VOLUME_MUTE:
				thinkpad_volume_mute(sc);
				handled = 1;
				break;
d235 1
d249 1
a254 8
		case 7:
			switch (event) {
			case THINKPAD_SWITCH_WIRELESS:
				handled = 1;
				
				break;
			}
			break;
a284 1
		aml_freevalue(&arg);
a287 2
	aml_freevalue(&arg);

a311 1
		aml_freevalue(&arg);
a314 2
	aml_freevalue(&arg);

a329 1
		aml_freevalue(&arg);
a332 2
	aml_freevalue(&arg);

a333 18
}

int
thinkpad_volume_down(struct acpithinkpad_softc *sc) 
{
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_DOWN);
}

int
thinkpad_volume_up(struct acpithinkpad_softc *sc)
{
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_UP);
}

int
thinkpad_volume_mute(struct acpithinkpad_softc *sc)
{
	return thinkpad_cmos(sc, THINKPAD_CMOS_VOLUME_MUTE);
@


1.2
log
@recognize some more events

hook up the volume keys to actually do stuff; from Stefan Kempf

use aml_freevalue to properly free memory in all cases; prodded by
deanna
@
text
@d1 1
a1 1
/* $OpenBSD: acpithinkpad.c,v 1.1 2008/04/27 16:23:16 jcs Exp $ */
d115 1
a115 1
	if (aml_evalname((struct acpi_softc *)parent, aa->aaa_node->child,
d137 1
a137 1
	sc->sc_devnode = aa->aaa_node->child;
d145 1
a145 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
@


1.1
log
@add acpithinkpad(4), an acpi support driver for ibm/lenovo
thinkpads.

provides functionality that the bios did on older, non-acpi
thinkpads like respond to screen brightness keys and toggle the
bluetooth device on and off.

ok deraadt@@ and marco@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d30 3
d57 3
d72 3
d89 3
d122 1
d134 1
a134 1
	struct acpi_attach_args *aa = aux;
d161 1
a161 2
		aml_freevalue(&res);
		return (1);
d175 1
a175 1
			return (1);
d185 1
a185 1
		return (1);
d188 6
d195 8
d220 1
d260 14
a275 1
				/* TODO: notify userland */
a288 1
				/* TODO: notify userland */
d294 8
d332 1
d336 2
d362 1
d366 2
d383 1
d387 2
d390 18
@

