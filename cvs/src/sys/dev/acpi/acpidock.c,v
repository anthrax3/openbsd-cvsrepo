head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.4
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.20
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.42.0.18
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.42.0.14
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.12
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.10
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.8
	OPENBSD_5_0:1.42.0.6
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.4
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.30.0.4
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17;
locks; strict;
comment	@ * @;


1.44
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.08.21.21.49.37;	author kspillner;	state Exp;
branches;
next	1.42;
commitid	EzhtS8Ipiafrf5ga;

1.42
date	2010.07.27.01.21.19;	author jordan;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.23.18.38.46;	author jordan;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.21.19.35.15;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.27.09.13.36;	author jordan;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.07.13.18.04;	author mk;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.04.01.07.36;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.03.05.14.03;	author jordan;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.03.02.59.01;	author jordan;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.02.23.56.12;	author jordan;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.02.23.03.34;	author jordan;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.13.18.53.50;	author jordan;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.11.20.37.46;	author jordan;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.01.17.59.55;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2008.05.16.06.50.55;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.14.05.24.36;	author jordan;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.12.21.58.14;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.13.03.43.22;	author weingart;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.23.19.29.03;	author mk;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.23.18.34.42;	author mk;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.23.17.38.30;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2007.04.22.21.02.25;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.22.20.52.27;	author mk;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.17.16.04.00;	author mk;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.16.23.51.15;	author mk;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.06.01.12.06;	author mk;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.15.21.02.17;	author mk;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.15.20.31.18;	author mk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.15.20.20.39;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.03.17.41.39;	author mk;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.27.17.38.21;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.27.16.39.56;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.27.16.15.03;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.27.11.48.33;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.27.11.30.52;	author mk;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.27.01.26.27;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.27.01.21.14;	author mk;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.25.21.45.42;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.25.21.31.38;	author mk;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.25.21.26.06;	author mk;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.22.22.01.13;	author mk;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.22.21.11.44;	author mk;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.22.19.45.16;	author mk;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/* $OpenBSD: acpidock.c,v 1.43 2014/08/21 21:49:37 kspillner Exp $ */
/*
 * Copyright (c) 2006,2007 Michael Knudsen <mk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/sensors.h>

#include <machine/bus.h>

#include <dev/acpi/acpivar.h>
#include <dev/acpi/acpidev.h>
#include <dev/acpi/amltypes.h>
#include <dev/acpi/dsdt.h>

struct aml_nodelist {
	struct aml_node *node;
	TAILQ_ENTRY(aml_nodelist) entries;
};

int	acpidock_match(struct device *, void *, void *);
void	acpidock_attach(struct device *, struct device *, void *);

struct cfattach acpidock_ca = {
	sizeof(struct acpidock_softc), acpidock_match, acpidock_attach
};

struct cfdriver acpidock_cd = {
	NULL, "acpidock", DV_DULL
};

int	acpidock_docklock(struct acpidock_softc *, int);
int	acpidock_dockctl(struct acpidock_softc *, int);
int	acpidock_eject(struct acpidock_softc *, struct aml_node *);
int	acpidock_notify(struct aml_node *, int, void *);
int	acpidock_status(struct acpidock_softc *);
int	acpidock_walkchildren(struct aml_node *, void *);

int	acpidock_foundejd(struct aml_node *, void *);

int
acpidock_match(struct device *parent, void *match, void *aux)
{
	struct acpi_attach_args	 *aaa = aux;
	struct cfdata		 *cf = match;

	/* sanity */
	if (aaa->aaa_name == NULL ||
	    strcmp(aaa->aaa_name, cf->cf_driver->cd_name) != 0 ||
	    aaa->aaa_table != NULL)
		return (0);

	return (1);
}

void
acpidock_attach(struct device *parent, struct device *self, void *aux)
{
	struct acpidock_softc	*sc = (struct acpidock_softc *)self;
	struct acpi_attach_args *aa = aux;
	extern struct aml_node	aml_root;

	sc->sc_acpi = (struct acpi_softc *)parent;
	sc->sc_devnode = aa->aaa_node;

	printf(": %s", sc->sc_devnode->name);

	acpidock_status(sc);
	if (sc->sc_docked == ACPIDOCK_STATUS_DOCKED) {
		acpidock_docklock(sc, 1);
		acpidock_dockctl(sc, 1);
	}

	acpidock_status(sc);
	printf("%s docked (%d)\n",
	    sc->sc_docked == ACPIDOCK_STATUS_DOCKED ? "" : " not",
	    sc->sc_sta);

	strlcpy(sc->sc_sensdev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensdev.xname));
	if (sc->sc_docked)
		strlcpy(sc->sc_sens.desc, "docked",
		    sizeof(sc->sc_sens.desc));
	else
		strlcpy(sc->sc_sens.desc, "not docked",
		    sizeof(sc->sc_sens.desc));

	sc->sc_sens.type = SENSOR_INDICATOR;
	sc->sc_sens.value = sc->sc_docked == ACPIDOCK_STATUS_DOCKED;
	sc->sc_sens.status = sc->sc_docked ? SENSOR_S_OK : SENSOR_S_UNKNOWN;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens);
	sensordev_install(&sc->sc_sensdev);

	TAILQ_INIT(&sc->sc_deps_h);
	aml_find_node(&aml_root, "_EJD", acpidock_foundejd, sc);

	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
	    acpidock_notify, sc, ACPIDEV_NOPOLL);
}

int
acpidock_status(struct acpidock_softc *sc)
{
	int64_t			sta;
	int			rv;

	if (aml_evalinteger(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL,
	    &sta) != 0) {
		sta = 0;
		rv = 0;
	} else
		rv = 1;

	sc->sc_sta = sta;
	sc->sc_docked = sc->sc_sta & STA_PRESENT;

	return (rv);
}

int
acpidock_docklock(struct acpidock_softc *sc, int lock)
{
	struct aml_value	cmd;
	struct aml_value	res;
	int			rv;

	memset(&cmd, 0, sizeof cmd);
	cmd.v_integer = lock;
	cmd.type = AML_OBJTYPE_INTEGER;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_LCK", 1, &cmd,
	    &res) != 0) {
		dnprintf(20, "%s: _LCK %d failed\n", DEVNAME(sc), lock);
		rv = 0;
	} else {
		dnprintf(20, "%s: _LCK %d successful\n", DEVNAME(sc), lock);
		rv = 1;
	}

	aml_freevalue(&res);

	return (rv);
}

int
acpidock_dockctl(struct acpidock_softc *sc, int dock)
{
	struct aml_value	cmd;
	struct aml_value	res;
	int			rv;

	memset(&cmd, 0, sizeof cmd);
	cmd.v_integer = dock;
	cmd.type = AML_OBJTYPE_INTEGER;
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_DCK", 1, &cmd,
	    &res) != 0) {
		dnprintf(15, "%s: _DCK %d failed\n", DEVNAME(sc), dock);
		rv = 0;
	} else {
		dnprintf(15, "%s: _DCK %d successful\n", DEVNAME(sc), dock);
		rv = 1;
	}

	aml_freevalue(&res);

	return (rv);
}

int
acpidock_eject(struct acpidock_softc *sc, struct aml_node *node)
{
	struct aml_value	cmd;
	struct aml_value	res;
	int			rv;

	if (node != sc->sc_devnode)
		aml_notify(node, 3);

	memset(&cmd, 0, sizeof cmd);
	cmd.v_integer = 1;
	cmd.type = AML_OBJTYPE_INTEGER;
	if (aml_evalname(sc->sc_acpi, node, "_EJ0", 1, &cmd,
	    &res) != 0) {
		dnprintf(15, "%s: _EJ0 failed\n", DEVNAME(sc));
		rv = 0;
	} else {
		dnprintf(15, "%s: _EJ0 successful\n", DEVNAME(sc));
		rv = 1;
	}

	aml_freevalue(&res);

	return (rv);
}

int
acpidock_notify(struct aml_node *node, int notify_type, void *arg)
{
	struct acpidock_softc	*sc = arg;
	struct aml_nodelist	*n;

	dnprintf(5, "%s: acpidock_notify: notify %d\n", DEVNAME(sc),
	    notify_type);

	switch (notify_type) {
	case ACPIDOCK_EVENT_INSERT:
		acpidock_docklock(sc, 1);
		acpidock_dockctl(sc, 1);

		TAILQ_FOREACH_REVERSE(n, &sc->sc_deps_h, aml_nodelisth, entries)
			aml_notify(n->node, 0x00);
		break;

	case ACPIDOCK_EVENT_EJECT:
	case ACPIDOCK_EVENT_DEVCHECK:
		/* ACPI Spec says eject button press generates
		 * a Notify(Device, 1); */
		TAILQ_FOREACH(n, &sc->sc_deps_h, entries)
			acpidock_eject(sc, n->node);
		acpidock_dockctl(sc, 0);
		acpidock_docklock(sc, 0);

		/* now actually undock */
		acpidock_eject(sc, sc->sc_devnode);
		break;
	}

	acpidock_status(sc);
	sc->sc_sens.value = sc->sc_docked == ACPIDOCK_STATUS_DOCKED;
	sc->sc_sens.status = sc->sc_docked ? SENSOR_S_OK : SENSOR_S_UNKNOWN;
	if (sc->sc_docked)
		strlcpy(sc->sc_sens.desc, "docked",
		    sizeof(sc->sc_sens.desc));
	else
		strlcpy(sc->sc_sens.desc, "not docked",
		    sizeof(sc->sc_sens.desc));

	printf("%s: %s\n",
	    DEVNAME(sc), sc->sc_docked == ACPIDOCK_STATUS_DOCKED ?
	    "docked" : "undocked");

	return (0);
}

int
acpidock_walkchildren(struct aml_node *node, void *arg)
{
	struct acpidock_softc	*sc = arg;
	struct aml_nodelist	*n;

	if (node && node->value && node->value->type == AML_OBJTYPE_DEVICE) {
		n = malloc(sizeof *n, M_DEVBUF, M_WAITOK | M_ZERO);
		n->node = node;
		dnprintf(10,"%s depends on", aml_nodename(node));
		dnprintf(10,"%s\n", aml_nodename(sc->sc_devnode));
		TAILQ_INSERT_TAIL(&sc->sc_deps_h, n, entries);
	}

	return (0);
}

int
acpidock_foundejd(struct aml_node *node, void *arg)
{
	struct acpidock_softc	*sc = (struct acpidock_softc *)arg;
	struct aml_value	res;
	struct aml_node		*dock;
	extern struct aml_node	aml_root;

	dnprintf(15, "%s: %s", DEVNAME(sc), node->name);

	if (aml_evalnode(sc->sc_acpi, node, 0, NULL, &res) == -1)
		printf(": error\n");
	else {
		dock = aml_searchname(&aml_root, res.v_string);

		if (dock == sc->sc_devnode)
			/* Add all children devices of Device containing _EJD */
			aml_walknodes(node->parent, AML_WALK_POST,
			    acpidock_walkchildren, sc);
		aml_freevalue(&res);
	}

	return (0);
}
@


1.43
log
@Set the sensor's status when docking and undocking, not just its value.
With this change sensorsd(8) now correctly detects state changes when
docking and undocking.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.42 2010/07/27 01:21:19 jordan Exp $ */
a25 1
#include <dev/acpi/acpireg.h>
@


1.42
log
@Add additional Notify handler for dock devices, according to ACPI spec
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.41 2010/07/23 18:38:46 jordan Exp $ */
d106 1
d245 1
@


1.41
log
@Fix searchname to handle short name segments, remove hack in acpidock.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.40 2010/07/21 19:35:15 deraadt Exp $ */
d229 3
@


1.40
log
@spacing and indents that are driving me crazy
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.39 2010/06/27 09:13:36 jordan Exp $ */
d285 1
a285 5
		if (!memcmp(res.v_string, "_SB.", 4)) {
			dock = aml_searchname(&aml_root, "_SB_");
			dock = aml_searchname(dock, res.v_string+4);
		} else
			dock = aml_searchname(&aml_root, res.v_string);
@


1.39
log
@Cleanup aml_find_node calls
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.38 2009/06/07 13:18:04 mk Exp $ */
d249 1
a249 1
	    DEVNAME(sc), sc->sc_docked == ACPIDOCK_STATUS_DOCKED ? 
@


1.38
log
@Shave surplus space from format string.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.37 2009/06/04 01:07:36 deraadt Exp $ */
d110 1
a110 1
	aml_find_node(aml_root.child, "_EJD", acpidock_foundejd, sc);
@


1.37
log
@only one : in a line. the seperation is:
deviceX at busX reason-why-we-attached-it: device prints it's junk here
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.36 2009/06/03 05:14:03 jordan Exp $ */
d91 1
a91 1
	printf(" %s docked (%d)\n",
@


1.36
log
@Don't disable dock devices if dock isn't initially attached
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.35 2009/06/03 02:59:01 jordan Exp $ */
d91 1
a91 1
	printf(":%s docked (%d)\n",
@


1.35
log
@More KNF
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.34 2009/06/02 23:56:12 jordan Exp $ */
a87 3
	} else {
		acpidock_dockctl(sc, 0);
		acpidock_docklock(sc, 0);
@


1.34
log
@KNF cleanup and denoise
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.33 2009/06/02 23:03:34 jordan Exp $ */
d258 2
a259 1
int acpidock_walkchildren(struct aml_node *node, void *arg)
@


1.33
log
@Added changes for docking station, must eject all children devices
ok marco@@, mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.32 2009/03/13 18:53:50 jordan Exp $ */
d129 1
a129 2
	}
	else
a132 1

d143 1
a143 1
	int rv;
a150 1

a153 1

d159 1
a159 1
	return rv;
d167 1
a167 1
	int rv;
a173 1
		/* XXX */
a174 1

a177 1

d183 1
a183 1
	return rv;
d191 1
a191 1
	int rv;
d195 1
a200 1
		/* XXX */
a201 1

a204 1

d210 1
a210 1
	return rv;
d217 1
a217 1
	struct aml_nodelist *n;
a223 1
		printf("%s: dock", DEVNAME(sc));
d227 1
a227 1
		TAILQ_FOREACH_REVERSE(n, &sc->sc_deps_h, aml_nodelisth, entries) {
a228 1
		}
a229 1
	case ACPIDOCK_EVENT_EJECT: {
d231 1
a233 1

a238 3

		printf("%s: undock", DEVNAME(sc));

a239 1
		}
d251 3
a253 2
	printf(": status %s\n",
	    sc->sc_docked == ACPIDOCK_STATUS_DOCKED ? "docked" : "undocked");
d260 2
a261 2
	struct acpidock_softc *sc = arg;
	struct aml_nodelist *n;
d270 2
a271 1
	return 0;
d277 3
a279 3
	struct acpidock_softc *sc = (struct acpidock_softc *)arg;
	struct aml_value res;
	struct aml_node *dock;
d284 1
a284 1
	if (aml_evalnode(sc->sc_acpi, node, 0, NULL, &res) == -1) {
d286 1
a286 1
	} else {
d289 2
a290 3
			dock = aml_searchname(dock,   res.v_string+4);
		}
		else {
d292 2
a293 2
		}
		if (dock == sc->sc_devnode) {
d295 3
a297 3
			aml_walknodes(node->parent, AML_WALK_POST, acpidock_walkchildren, sc);
	}
	aml_freevalue(&res);
d300 1
a300 1
	return 0;
@


1.32
log
@Fixup in acpidock for aml_evalinteger
Reported by guenther
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.31 2009/03/11 20:37:46 jordan Exp $ */
d53 1
d200 2
d226 1
d237 3
a241 1
		struct aml_nodelist *n;
d273 15
d293 2
d301 10
a310 11
		struct aml_nodelist *n;

		/* XXX debug */
		dnprintf(10, "%s: %s depends on %s\n", DEVNAME(sc),
		    node->name, res.v_string);

		/* XXX more than one dock? */
		n = malloc(sizeof(struct aml_nodelist), M_DEVBUF, M_WAITOK);
		n->node = node;

		TAILQ_INSERT_TAIL(&sc->sc_deps_h, n, entries);
a311 1

d313 1
@


1.31
log
@Cleanup.. use aml_evalinteger instead of aml_evalname
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.30 2008/06/01 17:59:55 marco Exp $ */
d124 1
a124 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_STA", 0, NULL,
@


1.30
log
@Re-enable new parser.  Lots of testing by various folks.  Fits all media
now too.

ok kettenis deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.28 2008/05/14 05:24:36 jordan Exp $ */
d121 1
a121 1
	struct aml_value	res;
d125 2
a126 1
	    &res) != 0)
d128 1
d132 1
a132 1
	sc->sc_sta = aml_val2int(&res);
a134 2

	aml_freevalue(&res);
@


1.29
log
@back out jordans new parser.

it didnt have enough oks from the right people, it did break machines
that were previously working, and it bloated the RAMDISKS and install
media beyond the constraints of the media.

requested by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.27 2007/11/12 21:58:14 deraadt Exp $ */
d79 1
a79 1
	sc->sc_devnode = aa->aaa_node->child;
d81 1
a81 1
	printf(": %s", sc->sc_devnode->parent->name);
d114 1
a114 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
d273 1
a273 1
	dnprintf(15, "%s: %s", DEVNAME(sc), node->parent->name);
d282 1
a282 1
		    node->parent->name, res.v_string);
d286 1
a286 1
		n->node = node->parent;
@


1.28
log
@Adding new ACPI Parser code
Old guts of code still exists, needs to be torn out next
ok marco@@
ok brad@@
@
text
@d79 1
a79 1
	sc->sc_devnode = aa->aaa_node;
d81 1
a81 1
	printf(": %s", sc->sc_devnode->name);
d114 1
a114 1
	aml_register_notify(sc->sc_devnode, aa->aaa_dev,
d273 1
a273 1
	dnprintf(15, "%s: %s", DEVNAME(sc), node->name);
d282 1
a282 1
		    node->name, res.v_string);
d286 1
a286 1
		n->node = node;
@


1.27
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.26 2007/09/13 03:43:22 weingart Exp $ */
d79 1
a79 1
	sc->sc_devnode = aa->aaa_node->child;
d81 1
a81 1
	printf(": %s", sc->sc_devnode->parent->name);
d114 1
a114 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev,
d273 1
a273 1
	dnprintf(15, "%s: %s", DEVNAME(sc), node->parent->name);
d282 1
a282 1
		    node->parent->name, res.v_string);
d286 1
a286 1
		n->node = node->parent;
@


1.26
log
@Implement ACPI 6.5.1 spec tree walk for _STA and _INI.
Fixes mk's laptop.  No regressions so far (thank you to the
testers).

ok gwk@@, mk@@, marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.25 2007/04/23 19:29:03 mk Exp $ */
a47 1

d114 1
a114 1
	aml_register_notify(sc->sc_devnode->parent, aa->aaa_dev, 
a115 1

d129 1
a129 1
	
d247 1
a247 1
		
a284 1
		
@


1.25
log
@When receiving an undock request, walk the list of dependant devices
and pull their _EJ0 knobs before undocking.  This ejects any dependant
devices (if necessary) before actually undocking.

Without this, the usb hub in my X6 gets upset when it's suddenly kicked
off the system without warning, and upon redocking it attaches as uberry.
Now it's behaving as it should.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.23 2007/04/23 17:38:30 mk Exp $ */
d55 1
a55 1
void	acpidock_foundejd(struct aml_node *, void *);
d269 1
a269 1
void
d295 2
@


1.24
log
@When adding a device node to the list of dependant devices, don't add
the _EJD node.  Instead, add the parent actual device node instead
which makes more sense and makes sure that it doesn't matter if the _EJ0
node under a device node comes before the _EJD node.
@
text
@d236 6
a241 1
	case ACPIDOCK_EVENT_EJECT:
d251 1
@


1.23
log
@In acpidock_softc, change sc_sens from being a one element long array to
simply being a single struct ksensor.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.22 2007/04/22 21:02:25 mk Exp $ */
d283 1
a283 1
		n->node = node;
@


1.22
log
@Remove unnecessary local variable in acpidock_status() and kill an XXX
by using STA_PRESENT instead of home-brewed value.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.21 2007/04/22 20:52:27 mk Exp $ */
d101 2
a102 2
		strlcpy(sc->sc_sens[0].desc, "docked",
		    sizeof(sc->sc_sens[0].desc));
d104 2
a105 2
		strlcpy(sc->sc_sens[0].desc, "not docked",
		    sizeof(sc->sc_sens[0].desc));
d107 3
a109 3
	sc->sc_sens[0].type = SENSOR_INDICATOR;
	sc->sc_sens[0].value = sc->sc_docked == ACPIDOCK_STATUS_DOCKED;
	sensor_attach(&sc->sc_sensdev, &sc->sc_sens[0]);
d249 1
a249 1
	sc->sc_sens[0].value = sc->sc_docked == ACPIDOCK_STATUS_DOCKED;
d251 2
a252 2
		strlcpy(sc->sc_sens[0].desc, "docked",
		    sizeof(sc->sc_sens[0].desc));
d254 2
a255 2
		strlcpy(sc->sc_sens[0].desc, "not docked",
		    sizeof(sc->sc_sens[0].desc));
@


1.21
log
@Add a TAILQ, aml_nodelist, of devices depending on the dock device to
struct acpidock_softc and stuff devices into it during attach.

This list is not yet used, but I have code ready to handle the ACPI side
of this.  However, it still doesn't handle that there may in fact be
multiple dock devices in a machine (e.g. on pre-60 series ThinkPads), but
I need to figure out how to do so properly first.  In the mean time I want
this in the tree so I don't lose the code.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.20 2007/04/17 16:04:00 mk Exp $ */
d124 1
a124 1
	int			rv, sta;
d132 1
a132 2
	sta = aml_val2int(&res);
	sc->sc_sta = sta;
d134 1
a134 2
	/* XXX: _STA bit defines */
	sc->sc_docked = sta & 0x01;
@


1.20
log
@Fix a really emberrassing bug:  Do not unconditionally call _DCK with a
parameter of 1 (dock).

This was causing acpidock to attempt to dock even if the machine was not
in its dock which was causing hangs on pre-60 series ThinkPads.  It was
also causing my X60 to not see NOTIFY 0 (dock) messages which would
initiate the docking sequence.

Diff from Matthew R. Dempsky.

Tested on X60 by me, on T42/43 by brad, ckuethe, reyk, Johan M:son, and
on T21 by reyk.  I think someone also tested on X40/41 but I don't
remember who.  Thanks a lot.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.19 2007/04/16 23:51:15 mk Exp $ */
d32 5
d55 2
d77 1
d112 3
d265 27
@


1.19
log
@Fix debug info when docking/undocking so it tells users what they need
to know:

	acpidock0: undock: status undocked
	acpidock0: dock: status docked

This gets rid of all the garbage output that I used long ago.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.18 2007/04/06 01:12:06 mk Exp $ */
d166 1
a166 1
	cmd.v_integer = 1;
@


1.18
log
@Fix a strange typo and don't set sc_docked in acpidock_dockctl().  It's
being handled by acpidock_status().

From Matthew R. Dempsky who had another chunk in his diff that I didn't
include.  It's correct, but it seems to cause some strange regression on
my X60 that I need to look into first.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.17 2007/02/15 21:02:17 mk Exp $ */
d217 3
a219 1
	printf("acpidock_notify: notify %d\n", notify_type);
d222 1
a222 1
		dnprintf(10, "INSERT\n");
d225 1
a227 1
		dnprintf(10, "EJECT\n");
d233 2
d248 1
a248 1
	dnprintf(5, "acpidock_notify: status %s\n",
@


1.17
log
@Change some functions so there's only one exit point.  This should make
it harder to introduce leaks in the code.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.16 2007/02/15 20:31:18 mk Exp $ */
d144 1
a144 1
		dnprintf(20, "%s: _LCD %d failed\n", DEVNAME(sc), lock);
a180 2

	sc->sc_docked = rv;
@


1.16
log
@Let acpidock_eject take an extra argument of what node to call _EJ0 on.
Will be used when ejecting devices sitting in the dock.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.15 2007/02/15 20:20:39 mk Exp $ */
d137 1
d146 1
a146 2
		aml_freevalue(&res);
		return (0);
d150 1
a150 2
		aml_freevalue(&res);
		return (1);
d153 3
d163 1
d173 1
a173 4
		sc->sc_docked = 0;

		aml_freevalue(&res);
		return (0);
d177 1
a177 3
		sc->sc_docked = 1;
		aml_freevalue(&res);
		return (1);
d180 5
d192 1
d202 1
a202 2
		aml_freevalue(&res);
		return (0);
d206 1
a206 3
		sc->sc_docked = 0;
		aml_freevalue(&res);
		return (1);
d209 3
@


1.15
log
@Don't clear the struct aml_value res when aml_evalnode() does this
anyway.  Also clean up a bit.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.14 2007/02/03 17:41:39 mk Exp $ */
d46 1
a46 1
int	acpidock_eject(struct acpidock_softc *);
d185 1
a185 1
acpidock_eject(struct acpidock_softc *sc)
d193 1
a193 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_EJ0", 1, &cmd,
d228 1
a228 1
		acpidock_eject(sc);
@


1.14
log
@Change sensor description to `docked'/`not docked' depending on actual
state.  This is more in line with acpiac and acpibat, and it confuses me
less when I look at the sensor output.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.13 2007/01/27 17:38:21 mk Exp $ */
a114 2
	memset(&res, 0, sizeof res);
	/* XXX: wrong */
a139 1
#if 1
a140 2
#endif
	memset(&res, 0, sizeof res);
a164 2
	memset(&res, 0, sizeof res);

a192 2

	memset(&res, 0, sizeof res);
@


1.13
log
@No need to invoke _INI explicitly as this is currently done
automagically out by some acpi voodoo.  Pointed out by marco.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.12 2007/01/27 16:39:56 mk Exp $ */
d92 7
a98 2
	strlcpy(sc->sc_sens[0].desc, "docking station",
	    sizeof(sc->sc_sens[0].desc));
d100 1
a102 1
	sc->sc_sens[0].value = sc->sc_docked == ACPIDOCK_STATUS_DOCKED;
d244 7
@


1.12
log
@Don't invoke methods on the wrong devnode.  Sigh.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.9 2007/01/27 11:30:52 mk Exp $ */
a46 1
int	acpidock_init(struct acpidock_softc *);
a77 5
		if (!acpidock_init(sc)) {
			printf(": couldn't initialize\n");
			return;
		}

a101 10
}

int
acpidock_init(struct acpidock_softc *sc)
{
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode, "_INI", 0, NULL,
	    NULL) != 0)
		return (0);
	else
		return (1);
@


1.11
log
@Unbreak build with ACPI_DEBUG.
@
text
@d113 1
a113 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode->parent, "_INI", 0, NULL,
d128 1
a128 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode->parent, "_STA", 0, NULL,
d157 1
a157 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode->parent, "_LCK", 1, &cmd,
d183 1
a183 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode->parent, "_DCK", 1, &cmd,
d213 1
a213 1
	if (aml_evalname(sc->sc_acpi, sc->sc_devnode->parent, "_EJ0", 1, &cmd,
@


1.10
log
@Only set sensor to on when ACPIDOCK_STATUS_DOCKED.  Before it would also
be on if ACPIDOCK_STATUS_UNKNOWN.
@
text
@d216 1
a216 1
		dnprintf(15, "%s: _EJ0 %d failed\n", DEVNAME(sc), dock);
d221 1
a221 1
		dnprintf(15, "%s: _EJ0 %d successful\n", DEVNAME(sc), dock);
@


1.9
log
@Delay status report during attach until after invoking _DCK.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.8 2007/01/27 01:26:27 mk Exp $ */
d103 1
a103 1
	sc->sc_sens[0].value = sc->sc_docked;
d254 1
a254 1
	sc->sc_sens[0].value = sc->sc_docked;
@


1.8
log
@Say ``docking station'' instead of ``docked'' in the sensor description
because this confuses me when I read it:

	hw.sensors.acpidock0.indicator0=Off, (docked)
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.7 2007/01/27 01:21:14 mk Exp $ */
d82 1
a82 2
		} else
			printf(": docked (%d)\n", sc->sc_sta);
a86 2
		printf(": not docked (%d)\n", sc->sc_sta);

d90 5
@


1.7
log
@Reading the spec again it seems I missed that the _INI method
should be invoked only when _STA says the device is present.  Change
acpidock_attach to this.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.6 2007/01/25 21:45:42 mk Exp $ */
d96 1
a96 1
	strlcpy(sc->sc_sens[0].desc, "docked",
@


1.6
log
@Be a bit more verbose during attach even without ACPI_DEBUG for now.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.5 2007/01/25 21:31:38 mk Exp $ */
a76 7
	sc->sc_docked = ACPIDOCK_STATUS_UNKNOWN;

	if (!acpidock_init(sc)) {
		printf(": couldn't initialize\n");
		return;
	}

d78 6
a83 3
	printf(": %s (%d)\n",
	    sc->sc_docked == ACPIDOCK_STATUS_DOCKED ? "docked" : "undocked",
	    sc->sc_sta);
a84 1
	if (sc->sc_docked == ACPIDOCK_STATUS_DOCKED) {
d88 2
@


1.5
log
@Install an indicator sensor to show if we're docked or not.

Note that right now status appears to not be detected correctly on all
machines, but let's expose what we think we know.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.1 2007/01/22 19:45:16 mk Exp $ */
d85 3
a87 2
	printf(": %s\n",
	    sc->sc_docked == ACPIDOCK_STATUS_DOCKED ? "docked" : "undocked");
@


1.4
log
@Make debug output a tad more consistent.
@
text
@d22 1
d96 9
d254 1
@


1.3
log
@Fix a comment and reduce the chattyness of some debug.
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.2 2007/01/22 21:11:44 mk Exp $ */
d149 1
a149 3
		/* lock is optional, no worries  */
		dnprintf(20, "%s: unable to lock %d: %d\n", DEVNAME(sc),
		    lock, aml_val2int(&res));
d154 1
a154 2
		dnprintf(20, "%s: _LCK %d successful: %d\n", DEVNAME(sc),
		    lock, aml_val2int(&res));
d206 1
a206 2
		dnprintf(15, "%s: unable to eject %d: %d\n", DEVNAME(sc),
		    dock, aml_val2int(&res));
d211 1
a211 2
		dnprintf(15, "%s: _EJ0 %d successful: %d\n", DEVNAME(sc),
		    dock, aml_val2int(&res));
@


1.2
log
@Some nits from fkr@@, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: acpidock.c,v 1.1 2007/01/22 19:45:16 mk Exp $ */
d149 1
a149 1
		/* no mechanical lock, no worries  */
d179 1
a179 2
		dnprintf(15, "%s: unable to dock %d: %d\n", DEVNAME(sc),
		    dock, aml_val2int(&res));
d186 1
a186 2
		dnprintf(15, "%s: _DCK %d successful: %d\n", DEVNAME(sc),
		    dock, aml_val2int(&res));
@


1.1
log
@Add driver for ACPI docking stations.

Not completely functional yet, e.g. undocking doesn't work yet but put
it in the tree to be able to safely work on this.

ok marco
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d54 1
a54 2

        struct cfdata		 *cf = match;
d79 1
a79 1
		printf(": couldn't initialise\n");
@

