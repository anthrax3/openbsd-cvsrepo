head	1.49;
access;
symbols
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.39.0.4
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.6
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.4
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.2
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.7
	UBC:1.1.0.8
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.49
date	2017.08.17.20.21.53;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	7lXpZyid0vR5Zwgg;

1.48
date	2017.05.30.13.14.44;	author fcambus;	state Exp;
branches;
next	1.47;
commitid	EKf5cKi75Q65XDtQ;

1.47
date	2017.05.30.10.19.22;	author fcambus;	state Exp;
branches;
next	1.46;
commitid	xxdQoy6hy5EbMuo3;

1.46
date	2017.01.22.17.17.38;	author fcambus;	state Exp;
branches;
next	1.45;
commitid	qifH7Dph3L08oDD3;

1.45
date	2016.10.06.07.30.19;	author fcambus;	state Exp;
branches;
next	1.44;
commitid	yCfRbZeh2vMzwcSu;

1.44
date	2016.09.14.03.25.51;	author jcs;	state Exp;
branches;
next	1.43;
commitid	qYDOYa2tB4BBaTp5;

1.43
date	2016.09.04.18.20.34;	author tedu;	state Exp;
branches;
next	1.42;
commitid	5vdSYy8ueEhs20To;

1.42
date	2015.09.13.16.44.30;	author miod;	state Exp;
branches
	1.42.2.1
	1.42.4.1;
next	1.41;
commitid	BZBMj3LYodkIGJml;

1.41
date	2015.09.08.11.13.22;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	cepoHqLZxiNNy2Sr;

1.40
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.39;
commitid	p4LJxGKbi0BU2cG6;

1.39
date	2015.01.11.13.00.05;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	dzPzGNU3JbgQUj5t;

1.38
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.37;
commitid	20ZyHa9gTJxHxhwD;

1.37
date	2014.12.07.13.07.18;	author miod;	state Exp;
branches;
next	1.36;
commitid	VKmFXJSOW1jaJaKU;

1.36
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.35;
commitid	OBNa5kfxQ2UXoiIw;

1.35
date	2013.10.20.21.24.01;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.20.16.44.48;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.20.09.35.36;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2013.10.19.14.34.20;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2013.05.21.16.31.19;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.13.15.09.06;	author shadchin;	state Exp;
branches;
next	1.29;

1.29
date	2012.01.10.18.50.40;	author shadchin;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.08.14.48.56;	author shadchin;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.08.14.46.11;	author shadchin;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.06.14.55.38;	author shadchin;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.23.15.04.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.15.17.13.05;	author chl;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.06.16.00.46;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.06.13.04.33;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.02.20.10.21;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.31.18.41.17;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.24.20.32.04;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.23.23.34.29;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.15.20.23.10;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.05.23.32.48;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.30.23.13.47;	author pascoe;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.15.02.19.24;	author pascoe;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.26.15.14.04;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.10.05.35.14;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.10.18.30.21;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.12.01.09.45;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2002.08.17.20.55.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.25.18.57.50;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.09.08.59.03;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.02.19.21.48;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.18.04.30.24;	author nate;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2001.05.14.22.26.36;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.30.08.19.20;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.1.8.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2003.05.19.22.14.16;	author tedu;	state Exp;
branches;
next	;

1.42.2.1
date	2016.09.16.15.01.05;	author jcs;	state Exp;
branches;
next	;
commitid	LmmnMXsRS6RqM3I0;

1.42.4.1
date	2016.09.16.14.54.37;	author jcs;	state Exp;
branches;
next	;
commitid	AsdYHmqKmuFc5aNo;


desc
@@


1.49
log
@Implement counter-clockwise rotation.

ok bcook@@, stsp@@
@
text
@/*	$OpenBSD: wsfont.c,v 1.48 2017/05/30 13:14:44 fcambus Exp $ */
/*	$NetBSD: wsfont.c,v 1.17 2001/02/07 13:59:24 ad Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/queue.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wsfont/wsfont.h>

#include "wsfont_glue.h"	/* NRASOPS_ROTATION */

#undef HAVE_FONT

#ifdef FONT_BOLD8x16
#define HAVE_FONT 1
#include <dev/wsfont/bold8x16.h>
#endif

#ifdef FONT_GALLANT12x22
#define HAVE_FONT 1
#endif

#ifdef FONT_BOLD8x16_ISO1
#define HAVE_FONT 1
#endif

/*
 * Make sure we always have at least one font.
 * Unless otherwise configured, all platforms provide both a 8x16 font and a
 * larger 12x22 font.
 * Some platforms will however only provide the 8x16 font if option
 * SMALL_KERNEL.
 */
#ifndef HAVE_FONT
#define HAVE_FONT 1

#define	FONT_BOLD8x16_ISO1
#if defined(__alpha__) || defined(__luna88k__) || defined(__macppc__) || \
    defined(__sgi__) || defined(__sparc64__) || \
    !defined(SMALL_KERNEL)
#define	FONT_GALLANT12x22
#endif

#endif	/* HAVE_FONT */

#ifdef FONT_BOLD8x16_ISO1
#include <dev/wsfont/bold8x16-iso1.h>
#endif

#ifdef FONT_GALLANT12x22
#include <dev/wsfont/gallant12x22.h>
#endif

struct font {
	TAILQ_ENTRY(font) chain;
	struct	wsdisplay_font *font;
	u_short	lockcount;
	u_short	cookie;
	u_short	flg;
};
TAILQ_HEAD(, font) fontlist;

/* Our list of built-in fonts */
static struct font builtin_fonts[] = {
#define BUILTIN_FONT(f, c) \
	{ .font = &(f), .cookie = (c), .lockcount = 0, \
	  .flg = WSFONT_STATIC | WSFONT_BUILTIN }
#ifdef FONT_BOLD8x16
	BUILTIN_FONT(bold8x16, 1),
#endif
#ifdef FONT_BOLD8x16_ISO1
	BUILTIN_FONT(bold8x16_iso1, 2),
#endif
#ifdef FONT_GALLANT12x22
	BUILTIN_FONT(gallant12x22, 3),
#endif
#undef BUILTIN_FONT
};

#if !defined(SMALL_KERNEL) || defined(__alpha__)
#define INCLUDE_FONT_BIT_ENDIANNESS_SWAP_CODE
#endif

#ifdef INCLUDE_FONT_BIT_ENDIANNESS_SWAP_CODE

/* Reverse the bit order in a byte */
static const u_char reverse[256] = {
	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

#endif

static struct font *wsfont_find0(int);

#ifdef INCLUDE_FONT_BIT_ENDIANNESS_SWAP_CODE

/*
 * Reverse the bit order of a font
 */
static void	wsfont_revbit(struct wsdisplay_font *);
static void
wsfont_revbit(struct wsdisplay_font *font)
{
	u_char *p, *m;

	p = (u_char *)font->data;
	m = p + font->stride * font->numchars * font->fontheight;

	for (; p < m; p++)
		*p = reverse[*p];
}

#endif

#if !defined(SMALL_KERNEL)

/*
 * Reverse the byte order of a font
 */
static void	wsfont_revbyte(struct wsdisplay_font *);
static void
wsfont_revbyte(struct wsdisplay_font *font)
{
	int x, l, r, nr;
	u_char *rp;

	if (font->stride == 1)
		return;

	rp = (u_char *)font->data;
	nr = font->numchars * font->fontheight;

	while (nr--) {
		l = 0;
		r = font->stride - 1;

		while (l < r) {
			x = rp[l];
			rp[l] = rp[r];
			rp[r] = x;
			l++, r--;
		}

		rp += font->stride;
	}
}

#endif

/*
 * Enumerate the list of fonts
 */
void
wsfont_enum(int (*cb)(void *, struct wsdisplay_font *), void *cbarg)
{
	struct font *ent;
	int s;

	s = splhigh();

	TAILQ_FOREACH(ent, &fontlist, chain)
		if (cb(cbarg, ent->font) != 0)
			break;

	splx(s);
}

#if NRASOPS_ROTATION > 0

void wsfont_rotate_cw(struct wsdisplay_font *, char *, int);
void wsfont_rotate_ccw(struct wsdisplay_font *, char *, int);
struct wsdisplay_font *wsfont_rotate_internal(struct wsdisplay_font *, int);

void
wsfont_rotate_cw(struct wsdisplay_font *font, char *newbits, int newstride)
{
	int b, n, r;

	/* Rotate the font a bit at a time. */
	for (n = 0; n < font->numchars; n++) {
		char *ch = font->data + (n * font->stride * font->fontheight);

		for (r = 0; r < font->fontheight; r++) {
			for (b = 0; b < font->fontwidth; b++) {
				unsigned char *rb;

				rb = ch + (font->stride * r) + (b / 8);
				if (*rb & (0x80 >> (b % 8))) {
					unsigned char *rrb;

					rrb = newbits + newstride - 1 - (r / 8)
					    + (n * newstride * font->fontwidth)
					    + (newstride * b);
					*rrb |= (1 << (r % 8));
				}
			}
		}
	}
}

void
wsfont_rotate_ccw(struct wsdisplay_font *font, char *newbits, int newstride)
{
	int b, n, r;

	/* Rotate the font a bit at a time. */
	for (n = 0; n < font->numchars; n++) {
		char *ch = font->data + (n * font->stride * font->fontheight);

		for (r = 0; r < font->fontheight; r++) {
			for (b = 0; b < font->fontwidth; b++) {
				int bb = font->fontwidth - 1 - b;
				unsigned char *rb;

				rb = ch + (font->stride * r) + (b / 8);
				if (*rb & (0x80 >> (b % 8))) {
					unsigned char *rrb;

					rrb = newbits + (r / 8)
					    + (n * newstride * font->fontwidth)
					    + (newstride * bb);
					*rrb |= (1 << (7 - (r % 8)));
				}
			}
		}
	}
}

struct wsdisplay_font *
wsfont_rotate_internal(struct wsdisplay_font *font, int ccw)
{
	int newstride;
	struct wsdisplay_font *newfont;
	char *newbits;

	/* Duplicate the existing font... */
	newfont = malloc(sizeof *font, M_DEVBUF, M_WAITOK);

	bcopy(font, newfont, sizeof *font);
	newfont->cookie = NULL;

	/* Allocate a buffer big enough for the rotated font. */
	newstride = (font->fontheight + 7) / 8;
	newbits = mallocarray(font->numchars, newstride * font->fontwidth,
	    M_DEVBUF, M_WAITOK | M_ZERO);

	if (ccw)
		wsfont_rotate_ccw(font, newbits, newstride);
	else
		wsfont_rotate_cw(font, newbits, newstride);

	newfont->data = newbits;

	/* Update font sizes. */
	newfont->stride = newstride;
	newfont->fontwidth = font->fontheight;
	newfont->fontheight = font->fontwidth;

	if (wsfont_add(newfont, 0) != 0) {
		/*
		 * If we seem to have rotated this font already, drop the
		 * new one...
		 */
		free(newbits, M_DEVBUF,
		    font->numchars * newstride * font->fontwidth);
		free(newfont, M_DEVBUF, sizeof *font);
		newfont = NULL;
	}

	return (newfont);
}

int
wsfont_rotate(int cookie, int ccw)
{
	int s, ncookie;
	struct wsdisplay_font *font;
	struct font *origfont;

	s = splhigh();
	origfont = wsfont_find0(cookie);
	splx(s);

	font = wsfont_rotate_internal(origfont->font, ccw);
	if (font == NULL)
		return (-1);

	ncookie = wsfont_find(font->name, font->fontwidth, font->fontheight,
	    font->stride);

	return (ncookie);
}

#endif	/* NRASOPS_ROTATION */

/*
 * Initialize list with WSFONT_BUILTIN fonts
 */
void
wsfont_init(void)
{
	static int again;
	unsigned int i;

	if (again != 0)
		return;
	again = 1;

	TAILQ_INIT(&fontlist);

	for (i = 0; i < nitems(builtin_fonts); i++) {
		TAILQ_INSERT_TAIL(&fontlist, &builtin_fonts[i], chain);
	}
}

/*
 * Find a font by cookie. Called at splhigh.
 */
static struct font *
wsfont_find0(int cookie)
{
	struct font *ent;

	TAILQ_FOREACH(ent, &fontlist, chain)
		if (ent->cookie == cookie)
			return (ent);

	return (NULL);
}

/*
 * Find a font.
 */
int
wsfont_find(const char *name, int width, int height, int stride)
{
	struct font *ent;
	int s;

	s = splhigh();

	TAILQ_FOREACH(ent, &fontlist, chain) {
		if (height != 0 && ent->font->fontheight != height)
			continue;

		if (width != 0 && ent->font->fontwidth != width)
			continue;

		if (stride != 0 && ent->font->stride != stride)
			continue;

		if (name != NULL && strcmp(ent->font->name, name) != 0)
			continue;

		splx(s);
		return (ent->cookie);
	}

	splx(s);
	return (-1);
}

/*
 * Add a font to the list.
 */
int
wsfont_add(struct wsdisplay_font *font, int copy)
{
	static int cookiegen = 666;
	struct font *ent;
	int s, fontc = 0;

	s = splhigh();

	/* Don't allow exact duplicates */
	if (wsfont_find(font->name, font->fontwidth, font->fontheight,
	    font->stride) >= 0) {
		splx(s);
		return (-1);
	}

	TAILQ_FOREACH(ent, &fontlist, chain)
		fontc++;

	if (fontc >= WSDISPLAY_MAXFONTCOUNT) {
		splx(s);
		return (-1);
	}

	ent = (struct font *)malloc(sizeof *ent, M_DEVBUF, M_WAITOK);

	ent->lockcount = 0;
	ent->flg = 0;
	ent->cookie = cookiegen++;

	/*
	 * If we are coming from a WSDISPLAYIO_LDFONT ioctl, we need to
	 * make a copy of the wsdisplay_font struct, but not of font->bits.
	 */
	if (copy) {
		ent->font = (struct wsdisplay_font *)malloc(sizeof *ent->font,
		    M_DEVBUF, M_WAITOK);
		memcpy(ent->font, font, sizeof(*ent->font));
		ent->flg = 0;
	} else {
		ent->font = font;
		ent->flg = WSFONT_STATIC;
	}

	/* Now link into the list and return */
	TAILQ_INSERT_TAIL(&fontlist, ent, chain);
	splx(s);
	return (0);
}

/*
 * Remove a font.
 */
#ifdef notyet
int
wsfont_remove(int cookie)
{
	struct font *ent;
	int s;

	s = splhigh();

	if ((ent = wsfont_find0(cookie)) == NULL) {
		splx(s);
		return (-1);
	}

	if ((ent->flg & WSFONT_BUILTIN) != 0 || ent->lockcount != 0) {
		splx(s);
		return (-1);
	}

	/* Don't free statically allocated font data */
	if ((ent->flg & WSFONT_STATIC) != 0) {
		free(ent->font->data, M_DEVBUF, 0);
		free(ent->font, M_DEVBUF, 0);
	}

	/* Remove from list, free entry */
	TAILQ_REMOVE(&list, ent, chain);
	free(ent, M_DEVBUF, 0);
	splx(s);
	return (0);
}
#endif

/*
 * Lock a given font and return new lockcount. This fails if the cookie
 * is invalid, or if the font is already locked and the bit/byte order
 * requested by the caller differs.
 */
int
wsfont_lock(int cookie, struct wsdisplay_font **ptr, int bitorder,
    int byteorder)
{
	struct font *ent;
	int s, lc;

	s = splhigh();

	if ((ent = wsfont_find0(cookie)) != NULL) {
		if (bitorder && bitorder != ent->font->bitorder) {
#ifdef INCLUDE_FONT_BIT_ENDIANNESS_SWAP_CODE
			if (ent->lockcount) {
				splx(s);
				return (-1);
			}
			wsfont_revbit(ent->font);
			ent->font->bitorder = bitorder;
#else
			splx(s);
			return (-1);
#endif
		}

		if (byteorder && byteorder != ent->font->byteorder) {
#if !defined(SMALL_KERNEL)
			if (ent->lockcount) {
				splx(s);
				return (-1);
			}
			wsfont_revbyte(ent->font);
			ent->font->byteorder = byteorder;
#else
			splx(s);
			return (-1);
#endif
		}

		lc = ++ent->lockcount;
		*ptr = ent->font;
	} else
		lc = -1;

	splx(s);
	return (lc);
}

/*
 * Unlock a given font and return new lockcount.
 */
int
wsfont_unlock(int cookie)
{
	struct font *ent;
	int s, lc;

	s = splhigh();

	if ((ent = wsfont_find0(cookie)) != NULL) {
		if (ent->lockcount == 0)
			panic("wsfont_unlock: font not locked");
		lc = --ent->lockcount;
	} else
		lc = -1;

	splx(s);
	return (lc);
}

#if !defined(SMALL_KERNEL)

/*
 * Unicode to font encoding mappings
 */

/*
 * To save memory, font encoding tables use a two level lookup.
 * First the high byte of the Unicode is used to lookup the level 2
 * table, then the low byte indexes that table.  Level 2 tables that are
 * not needed are omitted (NULL), and both level 1 and level 2 tables
 * have base and size attributes to keep their size down.
 */

struct wsfont_level1_glyphmap {
	struct wsfont_level2_glyphmap **level2;
	int base;	/* High byte for first level2 entry	*/
	int size;	/* Number of level2 entries		*/
};

struct wsfont_level2_glyphmap {
	int base;	/* Low byte for first character		*/
	int size;	/* Number of characters			*/
	void *chars;	/* Pointer to character number entries  */
	int width;	/* Size of each entry in bytes (1,2,4)  */
};

/*
 * IBM 437 maps
 */

static u_int8_t
ibm437_chars_0[] = {
	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100,101,102,103,104,105,106,107,108,109,110,111,
	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	255,173,155,156, 0, 157, 0,  0,  0,  0, 166,174,170, 0,  0,  0,
	 0, 241,253, 0,  0,  0,  0, 249, 0,  0, 167,175,172,171, 0, 168,
	 0,  0,  0,  0, 142,143,146,128, 0, 144, 0,  0,  0,  0,  0,  0,
	 0, 165, 0,  0,  0,  0, 153, 0,  0,  0,  0,  0, 154, 0,  0,  0,
	133,160,131, 0, 132,134,145,135,138,130,136,137,141,161,140,139,
	 0, 164,149,162,147, 0, 148,246, 0, 151,163,150,129, 0,  0, 152
},
ibm437_chars_1[] = {
	159
},
ibm437_chars_3[] = {
	226, 0,  0,  0,  0, 233, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	228, 0,  0, 232, 0,  0, 234, 0,  0,  0,  0,  0,  0,  0, 224,225,
	 0, 235,238, 0,  0,  0,  0,  0,  0, 230, 0,  0,  0, 227, 0,  0,
	229,231
},
ibm437_chars_32[] = {
	252, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0, 158
},
ibm437_chars_34[] = {
	237, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0, 248,250,251, 0,  0,  0, 236, 0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0, 239, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0, 247, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,240,  0,  0,243,
	242
},
ibm437_chars_35[] = {
	169, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	244,245
},
ibm437_chars_37[] = {
	196,205,179,186, 0,  0,  0,  0,  0,  0,  0,  0, 218,213,214,201,
	191,184,183,187,192,212,211,200,217,190,189,188,195,198, 0,  0,
	199, 0,  0, 204,180,181, 0,  0, 182, 0,  0, 185,194, 0,  0, 209,
	210, 0,  0, 203,193, 0,  0, 207,208, 0,  0, 202,197, 0,  0, 216,
	 0,  0, 215, 0,  0,  0,  0,  0,  0,  0,  0, 206, 0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	223, 0,  0,  0, 220, 0,  0,  0, 219, 0,  0,  0, 221, 0,  0,  0,
	222,176,177,178, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	254
};

static struct wsfont_level2_glyphmap
ibm437_level2_0 = { 0, 256, ibm437_chars_0, 1 },
ibm437_level2_1 = { 146, 1, ibm437_chars_1, 1 },
ibm437_level2_3 = { 147, 50, ibm437_chars_3, 1 },
ibm437_level2_32 = { 127, 41, ibm437_chars_32, 1 },
ibm437_level2_34 = { 5, 97, ibm437_chars_34, 1 },
ibm437_level2_35 = { 16, 18, ibm437_chars_35, 1 },
ibm437_level2_37 = { 0, 161, ibm437_chars_37, 1 };

static struct wsfont_level2_glyphmap *ibm437_level1[] = {
	&ibm437_level2_0, &ibm437_level2_1, NULL, &ibm437_level2_3,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	&ibm437_level2_32, NULL, &ibm437_level2_34, &ibm437_level2_35,
	NULL, &ibm437_level2_37
};

static struct wsfont_level1_glyphmap encodings[] = {
	/* WSDISPLAY_FONTENC_ISO */
	{ NULL, 0, 0 },
	/* WSDISPLAY_FONTENC_IBM */
	{ ibm437_level1, 0, nitems(ibm437_level1) }
};

#endif	/* !SMALL_KERNEL */

/*
 * Remap Unicode character to glyph
 */
int
wsfont_map_unichar(struct wsdisplay_font *font, int c)
{
	if (font->encoding == WSDISPLAY_FONTENC_ISO)
		return (c);

#if !defined(SMALL_KERNEL)
	if (font->encoding >= 0 && font->encoding < nitems(encodings)) {
		int hi = (c >> 8), lo = c & 255;
		struct wsfont_level1_glyphmap *map1 =
		    &encodings[font->encoding];
		struct wsfont_level2_glyphmap *map2;

		hi -= map1->base;

		if (hi >= 0 && hi < map1->size &&
		    (map2 = map1->level2[hi]) != NULL) {
			lo -= map2->base;

			if (lo >= 0 && lo < map2->size) {
				switch (map2->width) {
				case 1:
					c = (((u_int8_t *)map2->chars)[lo]);
					break;
				case 2:
					c = (((u_int16_t *)map2->chars)[lo]);
					break;
				case 4:
					c = (((u_int32_t *)map2->chars)[lo]);
					break;
				}

				if (c != 0 || lo == 0)
					return (c);
			}
		}
	}
#endif	/* !SMALL_KERNEL */

	return (-1);
}
@


1.48
log
@Remove qvss8x15, vt220l8x8, and vt220l8x10 fonts.

Those fonts are not compiled in by default, and are smaller than the
smallest font (bold8x16_iso1) we currently include.

OK mpi@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.47 2017/05/30 10:19:22 fcambus Exp $ */
d234 3
a236 1
struct wsdisplay_font *wsfont_rotate_internal(struct wsdisplay_font *);
d238 2
a239 2
struct wsdisplay_font *
wsfont_rotate_internal(struct wsdisplay_font *font)
d241 9
a249 3
	int b, n, r, newstride;
	struct wsdisplay_font *newfont;
	char *newbits;
d251 3
a253 2
	/* Duplicate the existing font... */
	newfont = malloc(sizeof *font, M_DEVBUF, M_WAITOK);
d255 9
a263 2
	bcopy(font, newfont, sizeof *font);
	newfont->cookie = NULL;
d265 4
a268 4
	/* Allocate a buffer big enough for the rotated font. */
	newstride = (font->fontheight + 7) / 8;
	newbits = mallocarray(font->numchars, newstride * font->fontwidth,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d276 1
d283 1
a283 1
					rrb = newbits + newstride - 1 - (r / 8)
d285 2
a286 2
					    + (newstride * b);
					*rrb |= (1 << (r % 8));
d291 24
d338 1
a338 1
wsfont_rotate(int cookie)
d348 1
a348 1
	font = wsfont_rotate_internal(origfont->font);
@


1.47
log
@Remove lucida16x29.h and omron12x20 fonts.

- lucida16x29 is a bad conversion from a truetype font, it is too bold
which makes it unreadable.
- omron12x20 is a serif font, and is very difficult to read due to
inconsistencies in character spacing, alignement, and width.

Moreover, both fonts only have 96 glyphs.

No objection from mlarkin@@

OK mpi@@, jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.46 2017/01/22 17:17:38 fcambus Exp $ */
a46 15
#ifdef FONT_QVSS8x15
#define HAVE_FONT 1
#include <dev/wsfont/qvss8x15.h>
#endif

#ifdef FONT_VT220L8x8
#define HAVE_FONT 1
#include <dev/wsfont/vt220l8x8.h>
#endif

#ifdef FONT_VT220L8x10
#define HAVE_FONT 1
#include <dev/wsfont/vt220l8x10.h>
#endif

a108 9
#endif
#ifdef FONT_QVSS8x15
	BUILTIN_FONT(qvss8x15, 4),
#endif
#ifdef FONT_VT220L8x8
	BUILTIN_FONT(vt220l8x8, 5),
#endif
#ifdef FONT_VT220L8x10
	BUILTIN_FONT(vt220l8x10, 6),
@


1.46
log
@Remove sony8x16 and sony12x24 fonts.

They were not compiled in by default, and are Serif fonts, which doesn't
work very well for monospaced bitmap fonts intended for console use.

OK mpi@@, visa@@, jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.45 2016/10/06 07:30:19 fcambus Exp $ */
a51 5
#ifdef FONT_LUCIDA16x29
#define HAVE_FONT 1
#include <dev/wsfont/lucida16x29.h>
#endif

a61 5
#ifdef FONT_OMRON12x20
#define HAVE_FONT 1
#include <dev/wsfont/omron12x20.h>
#endif

a124 3
#ifdef FONT_LUCIDA16x29
	BUILTIN_FONT(lucida16x29, 4),
#endif
d126 1
a126 1
	BUILTIN_FONT(qvss8x15, 5),
d129 1
a129 1
	BUILTIN_FONT(vt220l8x8, 6),
d132 1
a132 4
	BUILTIN_FONT(vt220l8x10, 7),
#endif
#ifdef FONT_OMRON12x20
	BUILTIN_FONT(omron12x20, 8),
@


1.45
log
@Remove reference to non existing font.

Include file with font data (courier11x18.h) was removed from NetBSD due
to licensing concerns before wsfont was imported into OpenBSD.

Cookie values have been renumbered for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.44 2016/09/14 03:25:51 jcs Exp $ */
a66 10
#ifdef FONT_SONY8x16
#define HAVE_FONT 1
#include <dev/wsfont/sony8x16.h>
#endif

#ifdef FONT_SONY12x24
#define HAVE_FONT 1
#include <dev/wsfont/sony12x24.h>
#endif

a146 6
#ifdef FONT_SONY8x16
	BUILTIN_FONT(sony8x16, 8),
#endif
#ifdef FONT_SONY12x24
	BUILTIN_FONT(sony12x24, 9),
#endif
d148 1
a148 1
	BUILTIN_FONT(omron12x20, 10),
@


1.44
log
@limit the number of fonts that can be loaded

ok millert mlarkin deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.43 2016/09/04 18:20:34 tedu Exp $ */
a141 3
#ifdef FONT_COURIER11x18
	BUILTIN_FONT(courier11x18, 3),
#endif
d143 1
a143 1
	BUILTIN_FONT(gallant12x22, 4),
d146 1
a146 1
	BUILTIN_FONT(lucida16x29, 5),
d149 1
a149 1
	BUILTIN_FONT(qvss8x15, 6),
d152 1
a152 1
	BUILTIN_FONT(vt220l8x8, 7),
d155 1
a155 1
	BUILTIN_FONT(vt220l8x10, 8),
d158 1
a158 1
	BUILTIN_FONT(sony8x16, 9),
d161 1
a161 1
	BUILTIN_FONT(sony12x24, 10),
d164 1
a164 1
	BUILTIN_FONT(omron12x20, 11),
@


1.43
log
@remove some more sparc remnants. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.42 2015/09/13 16:44:30 miod Exp $ */
d453 1
a453 1
	int s;
d460 8
@


1.42
log
@Put the 12x22 font on alpha and macppc installation kernels, the 8x16 font
is really fugly on large displays (tga, vgafb). It's only 10KB more data
before compression, which fits in our floppies.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.41 2015/09/08 11:13:22 deraadt Exp $ */
d107 1
a107 1
    defined(__sgi__) || defined(__sparc__) || defined(__sparc64__) || \
@


1.42.2.1
log
@MFC: limit the number of fonts that can be loaded

ok millert mlarkin deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.44 2016/09/14 03:25:51 jcs Exp $ */
d453 1
a453 1
	int s, fontc = 0;
a459 8
		splx(s);
		return (-1);
	}

	TAILQ_FOREACH(ent, &fontlist, chain)
		fontc++;

	if (fontc >= WSDISPLAY_MAXFONTCOUNT) {
@


1.42.4.1
log
@MFC: limit the number of fonts that can be loaded

ok millert mlarkin deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.44 2016/09/14 03:25:51 jcs Exp $ */
d453 1
a453 1
	int s, fontc = 0;
a459 8
		splx(s);
		return (-1);
	}

	TAILQ_FOREACH(ent, &fontlist, chain)
		fontc++;

	if (fontc >= WSDISPLAY_MAXFONTCOUNT) {
@


1.41
log
@sizes for free(); checked by semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.40 2015/03/14 03:38:50 jsg Exp $ */
d97 4
a100 4
 * Some platforms (currently luna88k, sgi, sparc and sparc64) always provide
 * a 8x16 font and a larger 12x22 font.
 * Other platforms also provide both, but the 12x22 font is omitted if
 * option SMALL_KERNEL.
d106 3
a108 2
#if defined(__luna88k__) || defined(__sgi__) || defined(__sparc__) || \
    defined(__sparc64__) || !defined(SMALL_KERNEL)
d173 4
d218 1
a218 1
#if !defined(SMALL_KERNEL) || defined(__alpha__)
d542 1
a542 1
#if !defined(SMALL_KERNEL) || defined(__alpha__)
@


1.40
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.39 2015/01/11 13:00:05 deraadt Exp $ */
d341 3
a343 2
		free(newbits, M_DEVBUF, 0);
		free(newfont, M_DEVBUF, 0);
@


1.39
log
@global "list" is not the nicest variable name
seen my mlarkin, ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.38 2014/12/13 21:05:33 doug Exp $ */
a39 1
#include <dev/wscons/wsdisplayvar.h>
@


1.38
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.37 2014/12/07 13:07:18 miod Exp $ */
d129 1
a129 1
TAILQ_HEAD(, font) list;
d280 1
a280 1
	TAILQ_FOREACH(ent, &list, chain)
d386 1
a386 1
	TAILQ_INIT(&list);
d389 1
a389 1
		TAILQ_INSERT_TAIL(&list, &builtin_fonts[i], chain);
d401 1
a401 1
	TAILQ_FOREACH(ent, &list, chain)
d419 1
a419 1
	TAILQ_FOREACH(ent, &list, chain) {
d480 1
a480 1
	TAILQ_INSERT_TAIL(&list, ent, chain);
@


1.37
log
@Bring the 12x22 font in even if SMALL_KERNEL on sgi.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.36 2014/07/12 18:48:53 tedu Exp $ */
d306 1
a306 1
	newbits = malloc(newstride * font->fontwidth * font->numchars,
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.35 2013/10/20 21:24:01 miod Exp $ */
d98 2
a99 1
 * Sparc, sparc64 always provide a 8x16 font and a larger 12x22 font.
d107 2
a108 1
#if defined(__sparc__) || defined(__sparc64__) || defined(__luna88k__) || !defined(SMALL_KERNEL)
@


1.35
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.34 2013/10/20 16:44:48 miod Exp $ */
d340 2
a341 2
		free(newbits, M_DEVBUF);
		free(newfont, M_DEVBUF);
d507 2
a508 2
		free(ent->font->data, M_DEVBUF);
		free(ent->font, M_DEVBUF);
d513 1
a513 1
	free(ent, M_DEVBUF);
@


1.34
log
@Add a load_font accessop to rasops, to allow for fonts to be loaded and
selected. All rasops fonts are managed by wsfont, which allows a font to be
loaded on a rasops device and used on another.

Currently not plumbed in any driver yet. This is work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.33 2013/10/20 09:35:36 miod Exp $ */
d271 1
a271 1
wsfont_enum(void (*cb)(const char *, int, int, int))
a272 1
	struct wsdisplay_font *f;
d278 3
a280 4
	TAILQ_FOREACH(ent, &list, chain) {
		f = ent->font;
		cb(f->name, f->fontwidth, f->fontheight, f->stride);
	}
@


1.33
log
@Replace manual list handling with a TAILQ.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.32 2013/10/19 14:34:20 miod Exp $ */
d271 1
a271 1
wsfont_enum(void (*cb)(char *, int, int, int))
d412 1
a412 1
wsfont_find(char *name, int width, int height, int stride)
a447 1
	size_t size;
d465 5
a469 5
	/* Is this font statically allocated? */
	if (!copy) {
		ent->font = font;
		ent->flg = WSFONT_STATIC;
	} else {
a471 1

a472 4

		size = font->fontheight * font->numchars * font->stride;
		ent->font->data = (void *)malloc(size, M_DEVBUF, M_WAITOK);
		memcpy(ent->font->data, font->data, size);
d474 3
@


1.32
log
@Remove Unicode to ISO-8859-7 translation tables, they would only be used if
one were to use an ISO-8859-7-encoded font on a raster display, yet none of
the fonts the kernel chooses from uses this encoding.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.31 2013/05/21 16:31:19 miod Exp $ */
d38 1
a119 1
/* Placeholder struct used for linked list */
d121 1
a121 2
	struct	font *next;
	struct	font *prev;
d127 1
d130 4
a133 1
static struct font *list, builtin_fonts[] = {
d135 1
a135 1
	{ NULL, NULL, &bold8x16, 0, 1, WSFONT_STATIC | WSFONT_BUILTIN  },
d138 1
a138 1
	{ NULL, NULL, &bold8x16_iso1, 0, 2, WSFONT_STATIC | WSFONT_BUILTIN },
d141 1
a141 1
	{ NULL, NULL, &courier11x18, 0, 3, WSFONT_STATIC | WSFONT_BUILTIN },
d144 1
a144 1
	{ NULL, NULL, &gallant12x22, 0, 4, WSFONT_STATIC | WSFONT_BUILTIN },
d147 1
a147 1
	{ NULL, NULL, &lucida16x29, 0, 5, WSFONT_STATIC | WSFONT_BUILTIN },
d150 1
a150 1
	{ NULL, NULL, &qvss8x15, 0, 6, WSFONT_STATIC | WSFONT_BUILTIN },
d153 1
a153 1
	{ NULL, NULL, &vt220l8x8, 0, 7, WSFONT_STATIC | WSFONT_BUILTIN },
d156 1
a156 1
	{ NULL, NULL, &vt220l8x10, 0, 8, WSFONT_STATIC | WSFONT_BUILTIN },
d159 1
a159 1
	{ NULL, NULL, &sony8x16, 0, 9, WSFONT_STATIC | WSFONT_BUILTIN },
d162 1
a162 1
	{ NULL, NULL, &sony12x24, 0, 10, WSFONT_STATIC | WSFONT_BUILTIN },
d165 1
a165 1
	{ NULL, NULL, &omron12x20, 0, 11, WSFONT_STATIC | WSFONT_BUILTIN },
d167 1
a167 1
	{ NULL, NULL, NULL, 0 },
d279 1
a279 1
	for (ent = list; ent; ent = ent->next) {
d380 1
a380 1
	int i;
d386 4
a389 3
	for (i = 0; builtin_fonts[i].font != NULL; i++) {
		builtin_fonts[i].next = list;
		list = &builtin_fonts[i];
d401 1
a401 1
	for (ent = list; ent != NULL; ent = ent->next)
d419 1
a419 1
	for (ent = list; ent != NULL; ent = ent->next) {
a464 2
	ent->next = list;
	ent->prev = NULL;
d483 1
a483 1
	list = ent;
d517 1
a517 8
	if (ent->prev)
		ent->prev->next = ent->next;
	else
		list = ent->next;

	if (ent->next)
		ent->next->prev = ent->prev;

@


1.31
log
@Check for NULL ptr before dereferencing, not after; found the hard way by
dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.30 2012/01/13 15:09:06 shadchin Exp $ */
a715 49
/*
 * ISO-8859-7 maps
 */

static u_int8_t
iso7_chars_0[] = {
	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100,101,102,103,104,105,106,107,108,109,110,111,
	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
	160, 0,  0, 163, 0,  0, 166,167,168,169, 0, 171,172,173, 0,  0,
	176,177,178,179,180, 0,  0, 183, 0,  0,  0, 187, 0, 189
},
iso7_chars_3[] = {
	182, 0, 184,185,186, 0, 188, 0, 190,191,192,193,194,195,196,197,
	198,199,200,201,202,203,204,205,206,207,208,209, 0, 211,212,213,
	214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,
	230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,
	246,247,248,249,250,251,252,253,254, 0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 181
},
iso7_chars_32[] = {
	175, 0,  0,  0,  0, 162, 0, 161
};

static struct wsfont_level2_glyphmap
iso7_level2_0 = { 0, 190, iso7_chars_0, 1 },
iso7_level2_3 = { 134, 111, iso7_chars_3, 1 },
iso7_level2_32 = { 20, 8, iso7_chars_32, 1 };

static struct wsfont_level2_glyphmap *iso7_level1[] = {
	&iso7_level2_0, NULL, NULL, &iso7_level2_3,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	&iso7_level2_32
};

d717 4
a720 4
	{ NULL, 0, 0 },			/* WSDISPLAY_FONTENC_ISO */
	{ ibm437_level1, 0, 38 },	/* WSDISPLAY_FONTENC_IBM */
	{ NULL, 0, 0 },			/* WSDISPLAY_FONTENC_PCVT */
	{ iso7_level1, 0, 33 },		/* WSDISPLAY_FONTENC_ISO7 */
@


1.30
log
@Simplify function wsfont_map_unichar.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.29 2012/01/10 18:50:40 shadchin Exp $ */
d788 1
d792 2
a793 3
		if (hi >= 0 && hi < map1->size) {
			struct wsfont_level2_glyphmap *map2 = map1->level2[hi];

d796 1
a796 1
			if (map2 != NULL && lo >= 0 && lo < map2->size) {
@


1.29
log
@Remove unused function wsfont_getflg.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.28 2012/01/08 14:48:56 shadchin Exp $ */
a771 2
#define MAX_ENCODING (sizeof(encodings) / sizeof(encodings[0]))

d781 2
a782 2
		return c;
	else
d784 1
a784 3
	if (font->encoding < 0 || font->encoding > MAX_ENCODING)
		return (-1);
	else {
d787 1
a787 1
			&encodings[font->encoding];
d789 1
a789 3
		if (hi >= map1->base && hi < map1->base + map1->size) {
			struct wsfont_level2_glyphmap *map2 =
			  map1->level2[hi - map1->base];
d791 2
a792 2
			if (map2 != NULL &&
			    lo >= map2->base && lo < map2->base + map2->size) {
d794 1
a794 1
			  	lo -= map2->base;
d796 2
a797 1
				switch(map2->width) {
d809 1
a809 3
				if (c == 0 && lo != 0)
					return (-1);
				else
a810 3

			} else {
				return (-1);
a811 3

		} else {
			return (-1);
d813 2
a815 2
	}
#else
a816 1
#endif	/* SMALL_KERNEL */
@


1.28
log
@Ansify non-ansified function definitions. No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.27 2012/01/08 14:46:11 shadchin Exp $ */
a578 20
}

/*
 * Get font flags and lockcount.
 */
int
wsfont_getflg(int cookie, int *flg, int *lc)
{
	struct font *ent;
	int s;

	s = splhigh();

	if ((ent = wsfont_find0(cookie)) != NULL) {
		*flg = ent->flg;
		*lc = ent->lockcount;
	}

	splx(s);
	return (ent != NULL ? 0 : -1);
@


1.27
log
@Remove unused definition null16.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.26 2012/01/06 14:55:38 shadchin Exp $ */
d216 1
a216 2
wsfont_revbit(font)
	struct wsdisplay_font *font;
d236 1
a236 2
wsfont_revbyte(font)
	struct wsdisplay_font *font;
d268 1
a268 2
wsfont_enum(cb)
	void (*cb)(char *, int, int, int);
d393 1
a393 2
wsfont_find0(cookie)
	int cookie;
d408 1
a408 3
wsfont_find(name, width, height, stride)
	char *name;
	int width, height, stride;
d440 1
a440 3
wsfont_add(font, copy)
	struct wsdisplay_font *font;
	int copy;
d491 1
a491 2
wsfont_remove(cookie)
	int cookie;
d535 2
a536 4
wsfont_lock(cookie, ptr, bitorder, byteorder)
	int cookie;
	struct wsdisplay_font **ptr;
	int bitorder, byteorder;
d585 1
a585 2
wsfont_getflg(cookie, flg, lc)
	int cookie, *flg, *lc;
d605 1
a605 2
wsfont_unlock(cookie)
	int cookie;
a735 1

a784 1

d800 1
a800 3
wsfont_map_unichar(font, c)
	struct wsdisplay_font *font;
	int c;
@


1.26
log
@Remove extra and trailing spaces.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.25 2010/05/23 15:04:19 deraadt Exp $ */
a661 6

#define null16			\
	NULL, NULL, NULL, NULL,	\
	NULL, NULL, NULL, NULL,	\
	NULL, NULL, NULL, NULL,	\
	NULL, NULL, NULL, NULL
@


1.25
log
@luna88k moves to defining __luna88k__ instead
@
text
@d1 2
a2 2
/*	$OpenBSD: wsfont.c,v 1.24 2009/02/15 17:13:05 chl Exp $ */
/* 	$NetBSD: wsfont.c,v 1.17 2001/02/07 13:59:24 ad Exp $	*/
d127 1
a127 1
};	
d171 32
a202 32
	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff, 
d220 1
a220 1
	
d224 1
a224 1
	for (; p < m; p++)	
d242 1
a242 1
	
d248 1
a248 1
	
d252 1
a252 1
		
d259 1
a259 1
		
d276 1
a276 1
	
d278 1
a278 1
	
d280 1
a280 1
		f = ent->font;	
d283 1
a283 1
	
d365 1
a365 1
	ncookie = wsfont_find(font->name, font->fontwidth, font->fontheight, 
d381 1
a381 1
	
d385 1
a385 1
		
d400 1
a400 1
	
d404 1
a404 1
			
d418 1
a418 1
	
d420 1
a420 1
	
d430 1
a430 1
		
d454 1
a454 1
	
d456 1
a456 1
	
d458 1
a458 1
	if (wsfont_find(font->name, font->fontwidth, font->fontheight, 
d463 1
a463 1
	
d465 1
a465 1
	
d471 1
a471 1
	
d481 1
a481 1
		
d490 1
a490 1
	splx(s);	
d504 1
a504 1
	
d511 1
a511 1
	
d516 1
a516 1
	
d522 2
a523 2
		
	/* Remove from list, free entry */	
d528 1
a528 1
			
d530 2
a531 2
		ent->next->prev = ent->prev;	
			
d540 1
a540 1
 * is invalid, or if the font is already locked and the bit/byte order 
d551 1
a551 1
	
d553 1
a553 1
	
d582 1
a582 1
		
d587 1
a587 1
	
d601 1
a601 1
	
d603 1
a603 1
	
d608 1
a608 1
	
d622 1
a622 1
	
d624 1
a624 1
	
d629 1
a629 1
	} else	
d631 1
a631 1
	
@


1.24
log
@do not check malloc return value against NULL, as M_WAITOK is used

ok krw@@ miod@@  (some months ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.23 2008/06/26 05:42:19 ray Exp $ */
d105 1
a105 1
#if defined(__sparc__) || defined(__sparc64__) || defined(luna88k) || !defined(SMALL_KERNEL)
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.22 2007/09/17 01:33:33 krw Exp $ */
a299 2
	if (newfont == NULL)
		return (NULL);
a307 4
	if (newbits == NULL) {
		free(newfont, M_DEVBUF);
		return (NULL);
	}
@


1.22
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.21 2007/09/10 19:49:31 gilles Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.20 2006/08/06 16:00:46 miod Exp $ */
d316 1
a316 1
	    M_DEVBUF, M_WAITOK);
a320 2

	bzero(newbits, newstride * font->fontwidth * font->numchars);
@


1.20
log
@Convert the Sony wsfonts to ISO-Latin1 encoding, and drop the Sony encoding
conversion tables; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.19 2006/08/06 13:04:33 miod Exp $ */
d479 1
a479 1
	MALLOC(ent, struct font *, sizeof *ent, M_DEVBUF, M_WAITOK);
d492 1
a492 1
		MALLOC(ent->font, struct wsdisplay_font *, sizeof *ent->font, 
d494 1
d498 1
a498 1
		MALLOC(ent->font->data, void *, size, M_DEVBUF, M_WAITOK);
d534 2
a535 2
		FREE(ent->font->data, M_DEVBUF);
		FREE(ent->font, M_DEVBUF);
d547 1
a547 1
	FREE(ent, M_DEVBUF);
@


1.19
log
@Switch luna88k from rcons to rasops. Tested by aoyama@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.18 2006/08/02 20:10:21 miod Exp $ */
a819 50
/*
 * SONY maps
 */

static u_int8_t
sony_chars_0[] = {
	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
	64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
	96, 97, 98, 99, 100,101,102,103,104,105,106,107,108,109,110,111,
	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
	176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
	192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
	208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223
};
static u_int16_t
sony_chars_255[] = {
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,
	257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,
	273,274,275,276,277,278,279,280,281,282,283,284,285,286,287
};

static struct wsfont_level2_glyphmap
sony_level2_0 = { 0, 256, sony_chars_0, 1 },
sony_level2_255 = { 97, 63, sony_chars_255, 2 };

static struct wsfont_level2_glyphmap *sony_level1[] = {
	&sony_level2_0, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	null16, null16, null16, null16,
	null16, null16, null16, null16,
	null16, null16, null16, null16,
	null16, null16,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, NULL,
	NULL, NULL, NULL, &sony_level2_255
};

a824 1
	{ sony_level1, 0, 256 },	/* WSDISPLAY_FONTENC_SONY */
d827 1
a827 1
#define MAX_ENCODING WSDISPLAY_FONTENC_SONY
d855 1
a855 1
			    lo >= map2->base && hi < map2->base + map2->size) {
d860 9
a868 9
				 case 1:
				   c = (((u_int8_t *)map2->chars)[lo]);
				   break;
				 case 2:
				   c = (((u_int16_t *)map2->chars)[lo]);
				   break;
				 case 4:
				   c = (((u_int32_t *)map2->chars)[lo]);
				   break;
@


1.18
log
@Provide the usual 8x16 font, instead of the qvss 8x15 font, for low-res vax
frame buffers (and smg until it can use non-8bit wide fonts), as the latter
has too many symbols in the 8-bit range stubbed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.17 2006/07/31 18:41:17 miod Exp $ */
d112 1
a112 1
#if defined(__sparc__) || defined(__sparc64__) || !defined(SMALL_KERNEL)
@


1.17
log
@Do not compile non-iso font encoding conversion tables and {bit(*),byte} order
reversal if SMALL_KERNEL. Saves ~5KB before compression.
ok deraadt@@

(*) except on alpha because tga needs it.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.16 2006/07/24 20:32:04 miod Exp $ */
d104 3
a106 3
 * Sparc, sparc64 and vax always provide a specific set of fonts.
 * Other platforms provide a 8x16 font and a larger 12x22 fonts, which is
 * omitted if option SMALL_KERNEL.
a110 1
#if defined(__sparc__) || defined(__sparc64__)
d112 1
a113 8
#elif defined(__vax__)
#define FONT_QVSS8x15
#define	FONT_GALLANT12x22
#else
#define	FONT_BOLD8x16_ISO1
#if !defined(SMALL_KERNEL)
#define	FONT_GALLANT12x22
#endif
a123 4
#endif

#ifdef FONT_QVSS8x15
#include <dev/wsfont/qvss8x15.h>
@


1.16
log
@Add the 12x22 font to vax defaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.15 2006/07/23 23:34:29 miod Exp $ */
d186 2
d224 2
d227 2
a228 2
static void	wsfont_revbit(struct wsdisplay_font *);
static void	wsfont_revbyte(struct wsdisplay_font *);
d233 1
d247 4
d254 1
d283 2
d582 1
d589 4
d596 1
d603 4
d662 1
d892 2
d902 1
a902 2
	if (font->encoding == WSDISPLAY_FONTENC_ISO) {

d904 3
a906 3

	} else if (font->encoding < 0 || font->encoding > MAX_ENCODING) {

d908 1
a908 3

	} else {

d948 3
a950 1

@


1.15
log
@Select the 8x15 font by default on vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.14 2005/09/15 20:23:10 miod Exp $ */
d116 1
@


1.14
log
@Stop compiling the texte console rotation code #ifdef __zaurus__, but use
a flag in the rasops_info structure; drivers which may use it shall declare
a specific attribute for the config(8) machinery, so that the necessary code
is compiled in.

In addition to this, rotated font computation is now done on-demand, and a
list of unrotated-rotated font cookie pairs is kept, rather than rotating all
built-in wsfonts at initialization time.

No user-perceptible functional change.

Tested matthieu@@ uwe@@, ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.13 2005/05/05 23:32:48 miod Exp $ */
d104 1
a104 1
 * Sparc and sparc64 always provide a specific set of fonts.
d114 2
d131 4
@


1.13
log
@Provide both 8x16 and 12x22 fonts on sparc64 even if SMALL_KERNEL, as
vigra and some cgthree clones might need tho 8x16 font. Fits the floppies,
other architectures unaffected.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.12 2005/04/30 23:13:47 pascoe Exp $ */
a39 3
#include <sys/cdefs.h>
//__KERNEL_RCSID(0, "$NetBSD: wsfont.c,v 1.17 2001/02/07 13:59:24 ad Exp $");

d50 2
a130 4
#ifdef __zaurus__
void wsfont_rotate(struct wsdisplay_font *, int);
#endif

d215 1
a215 1
static struct	font *wsfont_find0(int);
d287 6
a292 2
#ifdef __zaurus__
void wsfont_rotate(struct wsdisplay_font *font, int static_orig)
d295 10
a304 1
	char *newfont;
d308 1
a308 1
	newfont = malloc(newstride * font->fontwidth * font->numchars,
d310 6
a315 3
	if (newfont == NULL)
		return;
	bzero(newfont, newstride * font->fontwidth * font->numchars);
d329 1
a329 1
					rrb = newfont + newstride - 1 - (r / 8)
d338 13
a350 8
	/*
	 * If the rotated font will fit into the memory the font originally
	 * used, copy it into there, otherwise use our new buffer.
	 */
	if ((newstride * font->fontwidth * font->numchars) <=
	    (font->stride * font->fontheight * font->numchars)) {
		memcpy(font->data, newfont, newstride *
		    font->fontwidth * font->numchars);
d352 1
a352 4
	} else {
		if (!static_orig)
			free(font->data, M_DEVBUF);
		font->data = newfont;
d355 22
a376 5
	/* Update font sizes. */
	font->stride = newstride;
	newstride = font->fontwidth;	 /* temp */
	font->fontwidth = font->fontheight;
	font->fontheight = newstride;
d378 2
a379 1
#endif
a393 5
#ifdef __zaurus__
	for (i = 0; builtin_fonts[i].font != NULL; i++)
		wsfont_rotate(builtin_fonts[i].font, 1);
#endif

a494 4
#ifdef __zaurus__
	wsfont_rotate(ent->font, 0);
#endif
	
d500 1
a500 1
			
@


1.12
log
@Temporary hack to (un)rotate the Zaurus console until a proper rasops
rotation framework is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.11 2005/04/15 02:19:24 pascoe Exp $ */
d103 6
a108 1
/* Make sure we always have at least one font. */
d111 4
a114 3
#if defined(SMALL_KERNEL) && !defined(__sparc__)
#if defined(__sparc64__)
#define FONT_GALLANT12x22
d116 3
a118 1
#define FONT_BOLD8x16_ISO1 1
a119 5
#else	/* SMALL_KERNEL */
#define FONT_BOLD8x16_ISO1 1
/* Add the gallant 12x22 font for high screen resolutions */
#if !defined(FONT_GALLANT12x22)
#define FONT_GALLANT12x22
d121 1
a121 1
#endif	/* SMALL_KERNEL */
@


1.11
log
@correct a spello

ok jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.10 2005/03/26 15:14:04 miod Exp $ */
d129 3
d289 58
d360 5
d465 4
@


1.10
log
@Enable wsfont_add(), it will be necessary on sparc.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.9 2004/05/10 05:35:14 miod Exp $ */
d266 1
a266 1
 * Enumarate the list of fonts
@


1.9
log
@Select the Latin-1 8x16 font as the default 8x16 font, instead of the
IBM 8x16 one.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.8 2003/05/10 18:30:21 miod Exp $ */
a357 1
#ifdef notyet
a404 1
#endif
@


1.8
log
@Make the HAVE_FONT logic work correctly when user requests FONT_BOLD8x16
only.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.7 2002/10/12 01:09:45 krw Exp $ */
d90 1
a90 1
#ifdef FONT_BOLD8x16_ISO1
d92 1
a92 1
#include <dev/wsfont/bold8x16-iso1.h>
d99 1
a99 1
#ifdef FONT_BOLD8x16
d110 1
a110 1
#define FONT_BOLD8x16 1
d113 1
a113 1
#define FONT_BOLD8x16 1
d121 2
a122 2
#ifdef FONT_BOLD8x16
#include <dev/wsfont/bold8x16.h>
@


1.7
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.6 2002/08/17 20:55:30 millert Exp $ */
d96 4
@


1.6
log
@The consensus was to include both FONT_GALLANT12x22 and FONT_BOLD8x16
for sparc, even when SMALL_KERNEL is defined.  That way we get a
reasonable font on the sparcbook for the install.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.5 2002/07/25 18:57:50 miod Exp $ */
d527 1
a527 1
			panic("wsfont_unlock: font not locked\n");
@


1.5
log
@When building kernels with the SMALL_KERNEL option (typically, RAMDISK),
only one wsfont will be included.
Instead of forcing it to be the 8x16 font, choose it depending on the
architecture we are compiling for - this way, sparc* will get the
PROM-like 12x22 font instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.4 2002/05/09 08:59:03 maja Exp $ */
d102 2
a103 2
#if defined(SMALL_KERNEL)
#if defined(__sparc__) || defined(__sparc64__)
@


1.4
log
@Restore the support of ISO 8859-1 fonts in macppc console. gallant12x22.h
was updated with the characters from dev/wscons/wscons_gallant19.h.
bold8x16-iso1.h is based on bold8x16.h and the missing characters added
by me. bold8x16-iso1.h isn't used by default. -moj ok @@drahn, @@miod
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.3 2002/05/02 19:21:48 matthieu Exp $ */
d102 7
d111 1
a111 1
#if !defined(SMALL_KERNEL) && !defined(FONT_GALLANT12x22)
d114 2
a115 1
#endif
@


1.3
log
@use the gallant 12x22 font by default on screens that are more
than 960 pixels wide if !SMALL_KERNEL, like rcons does.
Ok drahn@@, mickey@@, miod@@.x
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.2 2002/03/14 01:27:03 millert Exp $ */
d90 5
d133 2
a134 2
#ifdef FONT_ISO8x16
	{ NULL, NULL, &iso8x16, 0, 2, WSFONT_STATIC | WSFONT_BUILTIN },
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.1 2001/03/18 04:30:24 nate Exp $ */
a59 5
#ifdef FONT_GALLANT12x22
#define HAVE_FONT 1
#include <dev/wsfont/gallant12x22.h>
#endif

d90 4
d98 4
d107 5
@


1.1
log
@Importing wsfont stuff from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d189 3
a191 3
static struct	font *wsfont_find0 __P((int));
static void	wsfont_revbit __P((struct wsdisplay_font *));
static void	wsfont_revbyte __P((struct wsdisplay_font *));
d245 1
a245 1
	void (*cb) __P((char *, int, int, int));
@


1.1.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.1 2001/03/18 04:30:24 nate Exp $ */
d60 5
a94 9
#ifdef FONT_BOLD8x16_ISO1
#define HAVE_FONT 1
#include <dev/wsfont/bold8x16-iso1.h>
#endif

#ifdef FONT_GALLANT12x22
#define HAVE_FONT 1
#endif

a98 4
/* Add the gallant 12x22 font for high screen resolutions */
#if !defined(SMALL_KERNEL) && !defined(FONT_GALLANT12x22)
#define FONT_GALLANT12x22
#endif
a104 5
#ifdef FONT_GALLANT12x22
#include <dev/wsfont/gallant12x22.h>
#endif


d120 2
a121 2
#ifdef FONT_BOLD8x16_ISO1
	{ NULL, NULL, &bold8x16_iso1, 0, 2, WSFONT_STATIC | WSFONT_BUILTIN },
d189 3
a191 3
static struct	font *wsfont_find0(int);
static void	wsfont_revbit(struct wsdisplay_font *);
static void	wsfont_revbyte(struct wsdisplay_font *);
d245 1
a245 1
	void (*cb)(char *, int, int, int);
@


1.1.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.1.8.1 2002/06/11 03:42:32 art Exp $ */
a101 7
#if defined(SMALL_KERNEL) && !defined(__sparc__)
#if defined(__sparc64__)
#define FONT_GALLANT12x22
#else
#define FONT_BOLD8x16 1
#endif
#else	/* SMALL_KERNEL */
d104 1
a104 1
#if !defined(FONT_GALLANT12x22)
d107 1
a107 2
#endif	/* SMALL_KERNEL */
#endif	/* HAVE_FONT */
d519 1
a519 1
			panic("wsfont_unlock: font not locked");
@


1.1.8.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a95 4
#define HAVE_FONT 1
#endif

#ifdef FONT_BOLD8x16
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.1 2001/03/18 04:30:24 nate Exp $ */
@


1.1.4.2
log
@Merge unpeeing cvs missed
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d189 3
a191 3
static struct	font *wsfont_find0(int);
static void	wsfont_revbit(struct wsdisplay_font *);
static void	wsfont_revbyte(struct wsdisplay_font *);
d245 1
a245 1
	void (*cb)(char *, int, int, int);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d60 5
a94 9
#ifdef FONT_BOLD8x16_ISO1
#define HAVE_FONT 1
#include <dev/wsfont/bold8x16-iso1.h>
#endif

#ifdef FONT_GALLANT12x22
#define HAVE_FONT 1
#endif

a97 4
#if defined(SMALL_KERNEL) && !defined(__sparc__)
#if defined(__sparc64__)
#define FONT_GALLANT12x22
#else
a99 8
#else	/* SMALL_KERNEL */
#define FONT_BOLD8x16 1
/* Add the gallant 12x22 font for high screen resolutions */
#if !defined(FONT_GALLANT12x22)
#define FONT_GALLANT12x22
#endif
#endif	/* SMALL_KERNEL */
#endif	/* HAVE_FONT */
a104 5
#ifdef FONT_GALLANT12x22
#include <dev/wsfont/gallant12x22.h>
#endif


d120 2
a121 2
#ifdef FONT_BOLD8x16_ISO1
	{ NULL, NULL, &bold8x16_iso1, 0, 2, WSFONT_STATIC | WSFONT_BUILTIN },
d506 1
a506 1
			panic("wsfont_unlock: font not locked");
@


1.1.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsfont.c,v 1.1.4.3 2003/03/28 00:38:33 niklas Exp $ */
a95 4
#define HAVE_FONT 1
#endif

#ifdef FONT_BOLD8x16
@


1.1.4.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d90 1
a90 1
#ifdef FONT_BOLD8x16
d92 1
a92 1
#include <dev/wsfont/bold8x16.h>
d99 1
a99 1
#ifdef FONT_BOLD8x16_ISO1
d110 1
a110 1
#define FONT_BOLD8x16_ISO1 1
d113 1
a113 1
#define FONT_BOLD8x16_ISO1 1
d121 2
a122 2
#ifdef FONT_BOLD8x16_ISO1
#include <dev/wsfont/bold8x16-iso1.h>
@


