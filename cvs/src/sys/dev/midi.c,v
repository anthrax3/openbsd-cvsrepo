head	1.42;
access;
symbols
	OPENBSD_6_0:1.40.0.6
	OPENBSD_6_0_BASE:1.40
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.33.0.4
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.30.0.8
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.28.0.4
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.6
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.4
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.42
date	2017.01.03.06.39.44;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	4IvqvVGtiC7zMKxr;

1.41
date	2016.12.20.16.03.39;	author ratchov;	state Exp;
branches;
next	1.40;
commitid	FlX4lmtZR49bJU6E;

1.40
date	2015.05.22.12.52.00;	author jsg;	state Exp;
branches;
next	1.39;
commitid	up7QTXqVkXS9L4ez;

1.39
date	2015.05.16.09.56.10;	author ratchov;	state Exp;
branches;
next	1.38;
commitid	CPWEvqjSjLxYqATk;

1.38
date	2015.05.12.18.39.30;	author ratchov;	state Exp;
branches;
next	1.37;
commitid	4wldPiWWqlXNRB7d;

1.37
date	2015.05.12.18.32.49;	author ratchov;	state Exp;
branches;
next	1.36;
commitid	hNfAALqNJqHWR9ER;

1.36
date	2015.05.12.18.23.38;	author ratchov;	state Exp;
branches;
next	1.35;
commitid	7nAj0T8uP4hGcapP;

1.35
date	2015.05.12.18.05.43;	author ratchov;	state Exp;
branches;
next	1.34;
commitid	BUBUDsCSkbUzCYfA;

1.34
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.33;
commitid	p4LJxGKbi0BU2cG6;

1.33
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.32;
commitid	C5iGb36LQxjM60Q3;

1.32
date	2014.10.09.04.04.46;	author tedu;	state Exp;
branches;
next	1.31;
commitid	R1GtSM6pjUGUHNjk;

1.31
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.30;
commitid	uzzBR7hz9ncd4O6G;

1.30
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.15.09.10.52;	author ratchov;	state Exp;
branches;
next	1.28;

1.28
date	2012.04.17.07.58.47;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2011.01.27.20.37.19;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2011.01.01.16.34.42;	author ratchov;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.18.21.15.14;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.08.01.48.24;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.20;

1.20
date	2009.11.01.20.14.12;	author nicm;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.30.18.12.30;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.17.10.27.42;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.18.10.58.41;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.01.03.37.23;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.16.03.24.27;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.07.22.41.32;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.22.22.17.44;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.21.06.03.15;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.27.19.44.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.10.18.49.07;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.23.00.13.23;	author mickey;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2000.06.26.22.43.21;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.24.13.44.18;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.03.19.38.13;	author fgsch;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.01.02.00.59.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.02.00.02.32;	author niklas;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.23.01;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.03.28.12.29.44;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;

1.6.6.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@No need to include sys/malloc.h. From Michael W. Bombardieri. Thanks.
@
text
@/*	$OpenBSD: midi.c,v 1.41 2016/12/20 16:03:39 ratchov Exp $	*/

/*
 * Copyright (c) 2003, 2004 Alexandre Ratchov
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/fcntl.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/poll.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>
#include <sys/device.h>

#include <dev/midi_if.h>
#include <dev/audio_if.h>
#include <dev/midivar.h>


int	midiopen(dev_t, int, int, struct proc *);
int	midiclose(dev_t, int, int, struct proc *);
int	midiread(dev_t, struct uio *, int);
int	midiwrite(dev_t, struct uio *, int);
int	midipoll(dev_t, int, struct proc *);
int	midikqfilter(dev_t, struct knote *);
int	midiioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	midiprobe(struct device *, void *, void *);
void	midiattach(struct device *, struct device *, void *);
int	mididetach(struct device *, int);
int	midiprint(void *, const char *);

void	midi_iintr(void *, int);
void 	midi_ointr(void *);
void	midi_timeout(void *);
void	midi_out_start(struct midi_softc *);
void	midi_out_stop(struct midi_softc *);
void	midi_out_do(struct midi_softc *);
void	midi_attach(struct midi_softc *, struct device *);


struct cfattach midi_ca = {
	sizeof(struct midi_softc), midiprobe, midiattach, mididetach
};

struct cfdriver midi_cd = {
	NULL, "midi", DV_DULL
};


void filt_midiwdetach(struct knote *);
int filt_midiwrite(struct knote *, long);

struct filterops midiwrite_filtops = {
	1, NULL, filt_midiwdetach, filt_midiwrite
};

void filt_midirdetach(struct knote *);
int filt_midiread(struct knote *, long);

struct filterops midiread_filtops = {
	1, NULL, filt_midirdetach, filt_midiread
};

void
midi_iintr(void *addr, int data)
{
	struct midi_softc  *sc = (struct midi_softc *)addr;
	struct midi_buffer *mb = &sc->inbuf;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!(sc->dev.dv_flags & DVF_ACTIVE) || !(sc->flags & FREAD))
		return;

	if (MIDIBUF_ISFULL(mb))
		return; /* discard data */

	MIDIBUF_WRITE(mb, data);
	if (mb->used == 1) {
		if (sc->rchan) {
			sc->rchan = 0;
			wakeup(&sc->rchan);
		}
		selwakeup(&sc->rsel);
		if (sc->async)
			psignal(sc->async, SIGIO);
	}
}

int
midiread(dev_t dev, struct uio *uio, int ioflag)
{
	struct midi_softc *sc;
	struct midi_buffer *mb;
	size_t count;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;
	if (!(sc->flags & FREAD)) {
		error = ENXIO;
		goto done;
	}
	mb = &sc->inbuf;

	/* if there is no data then sleep (unless IO_NDELAY flag is set) */
	error = 0;
	mtx_enter(&audio_lock);
	while (MIDIBUF_ISEMPTY(mb)) {
		if (ioflag & IO_NDELAY) {
			error = EWOULDBLOCK;
			goto done_mtx;
		}
		sc->rchan = 1;
		error = msleep(&sc->rchan, &audio_lock, PWAIT | PCATCH, "mid_rd", 0);
		if (!(sc->dev.dv_flags & DVF_ACTIVE))
			error = EIO;
		if (error)
			goto done_mtx;
	}

	/* at this stage, there is at least 1 byte */

	while (uio->uio_resid > 0 && mb->used > 0) {
		count = MIDIBUF_SIZE - mb->start;
		if (count > mb->used)
			count = mb->used;
		if (count > uio->uio_resid)
			count = uio->uio_resid;
		mtx_leave(&audio_lock);
		error = uiomove(mb->data + mb->start, count, uio);
		if (error)
			goto done;
		mtx_enter(&audio_lock);
		MIDIBUF_REMOVE(mb, count);
	}

done_mtx:
	mtx_leave(&audio_lock);
done:
	device_unref(&sc->dev);
	return error;
}

void
midi_ointr(void *addr)
{
	struct midi_softc *sc = (struct midi_softc *)addr;
	struct midi_buffer *mb;

	MUTEX_ASSERT_LOCKED(&audio_lock);
	if (!(sc->dev.dv_flags & DVF_ACTIVE) || !(sc->flags & FWRITE))
		return;
	
	mb = &sc->outbuf;
	if (mb->used > 0) {
#ifdef MIDI_DEBUG
		if (!sc->isbusy) {
			printf("midi_ointr: output must be busy\n");
		}
#endif
		midi_out_do(sc);
	} else if (sc->isbusy)
		midi_out_stop(sc);
}

void
midi_timeout(void *addr)
{
	mtx_enter(&audio_lock);
	midi_ointr(addr);
	mtx_leave(&audio_lock);
}

void
midi_out_start(struct midi_softc *sc)
{
	if (!sc->isbusy) {
		sc->isbusy = 1;
		midi_out_do(sc);
	}
}

void
midi_out_stop(struct midi_softc *sc)
{
	sc->isbusy = 0;
	if (sc->wchan) {
		sc->wchan = 0;
		wakeup(&sc->wchan);
	}
	selwakeup(&sc->wsel);
	if (sc->async)
		psignal(sc->async, SIGIO);
}

void
midi_out_do(struct midi_softc *sc)
{
	struct midi_buffer *mb = &sc->outbuf;

	while (mb->used > 0) {
		if (!sc->hw_if->output(sc->hw_hdl, mb->data[mb->start]))
			break;
		MIDIBUF_REMOVE(mb, 1);
		if (MIDIBUF_ISEMPTY(mb)) {
			if (sc->hw_if->flush != NULL)
				sc->hw_if->flush(sc->hw_hdl);
			midi_out_stop(sc);
			return;
		}
	}

	if (!(sc->props & MIDI_PROP_OUT_INTR)) {
		if (MIDIBUF_ISEMPTY(mb))
			midi_out_stop(sc);
		else
			timeout_add(&sc->timeo, 1);
	}
}

int
midiwrite(dev_t dev, struct uio *uio, int ioflag)
{
	struct midi_softc *sc;
	struct midi_buffer *mb;
	size_t count;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;
	if (!(sc->flags & FWRITE)) {
		error = ENXIO;
		goto done;
	}
	mb = &sc->outbuf;

	/*
	 * If IO_NDELAY flag is set then check if there is enough room
	 * in the buffer to store at least one byte. If not then dont
	 * start the write process.
	 */
	error = 0;
	mtx_enter(&audio_lock);
	if ((ioflag & IO_NDELAY) && MIDIBUF_ISFULL(mb) && (uio->uio_resid > 0)) {
		error = EWOULDBLOCK;
		goto done_mtx;
	}

	while (uio->uio_resid > 0) {
		while (MIDIBUF_ISFULL(mb)) {
			if (ioflag & IO_NDELAY) {
				/*
				 * At this stage at least one byte is already
				 * moved so we do not return EWOULDBLOCK
				 */
				goto done_mtx;
			}
			sc->wchan = 1;
			error = msleep(&sc->wchan, &audio_lock,
			    PWAIT | PCATCH, "mid_wr", 0);
			if (!(sc->dev.dv_flags & DVF_ACTIVE))
				error = EIO;
			if (error)
				goto done_mtx;
		}

		count = MIDIBUF_SIZE - MIDIBUF_END(mb);
		if (count > MIDIBUF_AVAIL(mb))
			count = MIDIBUF_AVAIL(mb);
		if (count > uio->uio_resid)
			count = uio->uio_resid;
		mtx_leave(&audio_lock);
		error = uiomove(mb->data + MIDIBUF_END(mb), count, uio);
		if (error)
			goto done;
		mtx_enter(&audio_lock);
		mb->used += count;
		midi_out_start(sc);
	}

done_mtx:
	mtx_leave(&audio_lock);
done:
	device_unref(&sc->dev);
	return error;
}

int
midipoll(dev_t dev, int events, struct proc *p)
{
	struct midi_softc *sc;
	int revents;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return POLLERR;
	revents = 0;
	mtx_enter(&audio_lock);
	if (events & (POLLIN | POLLRDNORM)) {
		if (!MIDIBUF_ISEMPTY(&sc->inbuf))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (!MIDIBUF_ISFULL(&sc->outbuf))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->wsel);
	}
	mtx_leave(&audio_lock);
	device_unref(&sc->dev);
	return (revents);
}

int
midikqfilter(dev_t dev, struct knote *kn)
{
	struct midi_softc *sc;
	struct klist 	  *klist;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;
	error = 0;
	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->rsel.si_note;
		kn->kn_fop = &midiread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &sc->wsel.si_note;
		kn->kn_fop = &midiwrite_filtops;
		break;
	default:
		error = EINVAL;
		goto done;
	}
	kn->kn_hook = (void *)sc;

	mtx_enter(&audio_lock);
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	mtx_leave(&audio_lock);
done:
	device_unref(&sc->dev);
	return error;
}

void
filt_midirdetach(struct knote *kn)
{
	struct midi_softc *sc = (struct midi_softc *)kn->kn_hook;

	mtx_enter(&audio_lock);
	SLIST_REMOVE(&sc->rsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&audio_lock);
}

int
filt_midiread(struct knote *kn, long hint)
{
	struct midi_softc *sc = (struct midi_softc *)kn->kn_hook;
	int retval;

	mtx_enter(&audio_lock);
	retval = !MIDIBUF_ISEMPTY(&sc->inbuf);
	mtx_leave(&audio_lock);

	return (retval);
}

void
filt_midiwdetach(struct knote *kn)
{
	struct midi_softc *sc = (struct midi_softc *)kn->kn_hook;

	mtx_enter(&audio_lock);
	SLIST_REMOVE(&sc->wsel.si_note, kn, knote, kn_selnext);
	mtx_leave(&audio_lock);
}

int
filt_midiwrite(struct knote *kn, long hint)
{
	struct midi_softc *sc = (struct midi_softc *)kn->kn_hook;
	int		   retval;

	mtx_enter(&audio_lock);
	retval = !MIDIBUF_ISFULL(&sc->outbuf);
	mtx_leave(&audio_lock);

	return (retval);
}

int
midiioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct midi_softc *sc;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;
	error = 0;
	switch(cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer */
		break;
	case FIOASYNC:
		if (*(int *)addr) {
			if (sc->async) {
				error = EBUSY;
				goto done;
			}
			sc->async = p;
		} else
			sc->async = 0;
		break;
	default:
		error = ENOTTY;
	}
done:
	device_unref(&sc->dev);
	return error;
}

int
midiopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct midi_softc *sc;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;
	error = 0;
	if (sc->flags) {
		error = EBUSY;
		goto done;
	}
	MIDIBUF_INIT(&sc->inbuf);
	MIDIBUF_INIT(&sc->outbuf);
	sc->isbusy = 0;
	sc->rchan = sc->wchan = 0;
	sc->async = 0;
	sc->flags = flags;
	error = sc->hw_if->open(sc->hw_hdl, flags, midi_iintr, midi_ointr, sc);
	if (error)
		sc->flags = 0;
done:
	device_unref(&sc->dev);
	return error;
}

int
midiclose(dev_t dev, int fflag, int devtype, struct proc *p)
{
	struct midi_softc *sc;
	struct midi_buffer *mb;
	int error;

	sc = (struct midi_softc *)device_lookup(&midi_cd, minor(dev));
	if (sc == NULL)
		return ENXIO;

	/* start draining output buffer */
	error = 0;
	mb = &sc->outbuf;
	mtx_enter(&audio_lock);
	if (!MIDIBUF_ISEMPTY(mb))
		midi_out_start(sc);
	while (sc->isbusy) {
		sc->wchan = 1;
		error = msleep(&sc->wchan, &audio_lock,
		    PWAIT, "mid_dr", 5 * hz);
		if (!(sc->dev.dv_flags & DVF_ACTIVE))
			error = EIO;
		if (error)
			break;
	}
	mtx_leave(&audio_lock);

	/*
	 * some hw_if->close() reset immediately the midi uart
	 * which flushes the internal buffer of the uart device,
	 * so we may lose some (important) data. To avoid this,
	 * sleep 20ms (around 64 bytes) to give the time to the
	 * uart to drain its internal buffers.
	 */
	tsleep(&sc->wchan, PWAIT, "mid_cl", hz * MIDI_MAXWRITE / MIDI_RATE);
	sc->hw_if->close(sc->hw_hdl);
	sc->flags = 0;
	device_unref(&sc->dev);
	return 0;
}

int
midiprobe(struct device *parent, void *match, void *aux)
{
	struct audio_attach_args *sa = aux;

	return (sa != NULL && (sa->type == AUDIODEV_TYPE_MIDI) ? 1 : 0);
}

void
midiattach(struct device *parent, struct device *self, void *aux)
{
	struct midi_info	  mi;
	struct midi_softc        *sc = (struct midi_softc *)self;
	struct audio_attach_args *sa = (struct audio_attach_args *)aux;
	struct midi_hw_if        *hwif = sa->hwif;
	void  			 *hdl = sa->hdl;

#ifdef DIAGNOSTIC
	if (hwif == 0 ||
	    hwif->open == 0 ||
	    hwif->close == 0 ||
	    hwif->output == 0 ||
	    hwif->getinfo == 0) {
		printf("midi: missing method\n");
		return;
	}
#endif
	sc->hw_if = hwif;
	sc->hw_hdl = hdl;
	sc->hw_if->getinfo(sc->hw_hdl, &mi);
	sc->props = mi.props;
	sc->flags = 0;
	timeout_set(&sc->timeo, midi_timeout, sc);
	printf(": <%s>\n", mi.name);
}

int
mididetach(struct device *self, int flags)
{
	struct midi_softc *sc = (struct midi_softc *)self;
	int maj, mn;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++) {
		if (cdevsw[maj].d_open == midiopen) {
			/* Nuke the vnodes for any open instances (calls close). */
			mn = self->dv_unit;
			vdevgone(maj, mn, mn, VCHR);
		}
	}

	/*
	 * The close() method did nothing (device_lookup() returns
	 * NULL), so quickly halt transfers (normally parent is already
	 * gone, and code below is no-op), and wake-up user-land blocked
	 * in read/write/ioctl, which return EIO.
	 */
	if (sc->flags) {
		if (sc->flags & FREAD) {
			sc->rchan = 0;
			wakeup(&sc->rchan);
			selwakeup(&sc->rsel);
		}
		if (sc->flags & FWRITE) {
			sc->wchan = 0;
			wakeup(&sc->wchan);
			selwakeup(&sc->wsel);
		}
		sc->hw_if->close(sc->hw_hdl);
		sc->flags = 0;
	}
	return 0;
}

int
midiprint(void *aux, const char *pnp)
{
	if (pnp)
		printf("midi at %s", pnp);
	return (UNCONF);
}

struct device *
midi_attach_mi(struct midi_hw_if *hwif, void *hdl, struct device *dev)
{
	struct audio_attach_args arg;

	arg.type = AUDIODEV_TYPE_MIDI;
	arg.hwif = hwif;
	arg.hdl = hdl;
	return config_found(dev, &arg, midiprint);
}
@


1.41
log
@In midiread() and midiwrite(), add a second goto label to
factor calls to mtx_leave() before returning. From Michael
W. Bombardieri <mb at ii.net>. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.40 2015/05/22 12:52:00 jsg Exp $	*/
a28 1
#include <sys/malloc.h>
@


1.40
log
@Don't use an uninitialised softc pointer in midiread/midiwrite.
ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.39 2015/05/16 09:56:10 ratchov Exp $	*/
a127 1
			mtx_leave(&audio_lock);
d129 1
a129 1
			goto done;
d135 2
a136 4
		if (error) {
			mtx_leave(&audio_lock);
			goto done;
		}
d154 2
a263 1
		mtx_leave(&audio_lock);
d265 1
a265 1
		goto done;
d275 1
a275 2
				mtx_leave(&audio_lock);
				goto done;
d282 2
a283 4
			if (error) {
				mtx_leave(&audio_lock);
				goto done;
			}
d299 2
@


1.39
log
@Use device_lookup() instead of digging into midi_cd.cd_devs[] and
maintaining a "dying" flag which is already present in the device
structure. As a side-effect, this adds the missing refcounting
that mididetach() was missing. With from mpi@@ and dlg@@

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
a110 1
	struct midi_buffer *mb = &sc->inbuf;
d121 1
d244 1
a244 1
	struct midi_buffer *mb = &sc->outbuf;
d255 1
@


1.38
log
@remove the sc->isopen flag, as sc->flags already hold the
same information.
@
text
@d87 2
a88 1
	if (sc->isdying || !(sc->flags & FREAD))
d109 1
a109 1
	struct midi_softc  *sc = MIDI_DEV2SC(dev);
d114 2
a115 1
	if (!(sc->flags & FREAD))
d117 4
d123 1
a123 1

a125 4
		if (sc->isdying) {
			mtx_leave(&audio_lock);
			return EIO;
		}
d128 2
a129 1
			return EWOULDBLOCK;
d133 2
d137 1
a137 1
			return error;
d152 1
a152 1
			return error;
d157 3
a159 1
	return 0;
d165 1
a165 1
	struct midi_softc  *sc = (struct midi_softc *)addr;
d169 5
a173 3
	if (!(sc->flags & FWRITE) && !sc->isdying) {
		mb = &sc->outbuf;
		if (mb->used > 0) {
d175 3
a177 3
			if (!sc->isbusy) {
				printf("midi_ointr: output must be busy\n");
			}
d179 3
a181 4
			midi_out_do(sc);
		} else if (sc->isbusy)
			midi_out_stop(sc);
	}
d242 1
a242 1
	struct midi_softc  *sc = MIDI_DEV2SC(dev);
d247 2
a248 1
	if (!(sc->flags & FWRITE))
d250 4
a253 2
	if (sc->isdying)
		return EIO;
d260 1
d264 2
a265 1
		return EWOULDBLOCK;
d276 1
a276 1
				return 0;
d281 2
d285 1
a285 5
				return error;
			}
			if (sc->isdying) {
				mtx_leave(&audio_lock);
				return EIO;
d297 1
a297 1
			return error;
d303 3
a305 1
	return 0;
d311 1
a311 1
	struct midi_softc *sc = MIDI_DEV2SC(dev);
d314 2
a315 1
	if (sc->isdying)
a316 1

d334 1
d341 1
a341 1
	struct midi_softc *sc = MIDI_DEV2SC(dev);
d343 1
d345 4
d359 2
a360 1
		return (EINVAL);
d367 3
a369 2

	return (0);
d421 2
a422 4
	struct midi_softc *sc = MIDI_DEV2SC(dev);

	if (sc->isdying)
		return EIO;
d424 4
d434 4
a437 2
			if (sc->async)
				return EBUSY;
d443 1
a443 1
		return ENOTTY;
d445 3
a447 1
	return 0;
d454 1
a454 1
	int err;
d456 2
a457 1
	if (MIDI_UNIT(dev) >= midi_cd.cd_ndevs)
d459 5
a463 8
	sc = MIDI_DEV2SC(dev);
	if (sc == NULL)		/* there may be more units than devices */
		return ENXIO;
	if (sc->isdying)
		return EIO;
	if (sc->flags)
		return EBUSY;

d470 2
a471 2
	err = sc->hw_if->open(sc->hw_hdl, flags, midi_iintr, midi_ointr, sc);
	if (err) {
d473 3
a475 3
		return err;
	}
	return 0;
d481 1
a481 1
	struct midi_softc  *sc = MIDI_DEV2SC(dev);
d485 6
d492 11
a502 13
	if (!sc->isdying) {
		/* start draining output buffer */
		mtx_enter(&audio_lock);
		if (!MIDIBUF_ISEMPTY(mb))
			midi_out_start(sc);
		while (sc->isbusy) {
			sc->wchan = 1;
			error = msleep(&sc->wchan, &audio_lock,
			    PWAIT, "mid_dr", 5 * hz);
			if (error || sc->isdying)
				break;
		}
		mtx_leave(&audio_lock);
d504 1
d516 1
a548 1
	sc->isdying = 0;
a561 10
	sc->isdying = 1;
	if (sc->wchan) {
		sc->wchan = 0;
		wakeup(&sc->wchan);
	}
	if (sc->rchan) {
		sc->rchan = 0;
		wakeup(&sc->rchan);
	}

d569 21
@


1.37
log
@store byte count in a size_t and switch from uiomovei() to uiomove()
@
text
@d87 1
a87 1
	if (sc->isdying || !sc->isopen || !(sc->flags & FREAD))
d162 1
a162 1
	if (sc->isopen && !sc->isdying) {
d436 1
a436 1
	if (sc->isopen)
a444 1

d446 2
a447 1
	if (err)
d449 1
a449 1
	sc->isopen = 1;
d485 1
a485 1
	sc->isopen = 0;
d521 1
a521 1
	sc->isopen = 0;
@


1.36
log
@Remove unused code & definitions: midi_attach(), midi_unit_count(),
midi_getinfo(), midi_writebytes(). They were "used" by the sequencer
interface which we removed years ago.
@
text
@d110 1
a110 1
	unsigned int count;
d145 1
a145 1
		error = uiomovei(mb->data + mb->start, count, uio);
d236 1
a236 1
	unsigned int count;
d284 1
a284 1
		error = uiomovei(mb->data + MIDIBUF_END(mb), count, uio);
@


1.35
log
@Don't hold the audio mutex when calling uiomove(), as uiomove()
may sleep in case of a page fault
@
text
@a497 13
midi_attach(struct midi_softc *sc, struct device *parent)
{
	struct midi_info mi;

	sc->isdying = 0;
	sc->hw_if->getinfo(sc->hw_hdl, &mi);
	sc->props = mi.props;
	sc->isopen = 0;
	timeout_set(&sc->timeo, midi_timeout, sc);
	printf(": <%s>\n", mi.name);
}

void
d500 1
d518 6
a523 1
	midi_attach(sc, parent);
a560 13
void
midi_getinfo(dev_t dev, struct midi_info *mi)
{
	struct midi_softc *sc = MIDI_DEV2SC(dev);

	if (MIDI_UNIT(dev) >= midi_cd.cd_ndevs || sc == NULL || sc->isdying) {
		mi->name = "unconfigured";
		mi->props = 0;
		return;
	}
	sc->hw_if->getinfo(sc->hw_hdl, mi);
}

a570 8


int
midi_unit_count(void)
{
	return midi_cd.cd_ndevs;
}

@


1.34
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.33 2015/02/10 21:56:09 miod Exp $	*/
d144 1
d146 1
a146 2
		if (error) {
			mtx_leave(&audio_lock);
d148 1
a148 1
		}
d249 3
a251 2

	if ((ioflag & IO_NDELAY) && MIDIBUF_ISFULL(mb) && (uio->uio_resid > 0))
d253 1
a255 1
		mtx_enter(&audio_lock);
d283 1
d285 1
a285 2
		if (error) {
			mtx_leave(&audio_lock);
d287 1
a287 1
		}
a289 1
		mtx_leave(&audio_lock);
d291 1
@


1.33
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.32 2014/10/09 04:04:46 tedu Exp $	*/
a22 1
#include <sys/exec.h>
@


1.32
log
@no need for lkm
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.31 2014/09/14 14:17:24 jsg Exp $	*/
d145 1
a145 1
		error = uiomove(mb->data + mb->start, count, uio);
d283 1
a283 1
		error = uiomove(mb->data + MIDIBUF_END(mb), count, uio);
@


1.31
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.30 2013/05/15 08:29:24 ratchov Exp $	*/
a24 1
#include <sys/lkm.h>
@


1.30
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.29 2013/03/15 09:10:52 ratchov Exp $	*/
a25 1
#include <sys/proc.h>
@


1.29
log
@Delete the sequencer(4) driver, since its not used any longer. Diff
mostly from armani.
ok miod, mpi, jsg and help from sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.28 2012/04/17 07:58:47 ratchov Exp $	*/
d54 1
a83 1

a107 1

d113 2
a114 2
	unsigned 	    count;
	int		    s, error;
d121 1
a121 1
	s = splaudio();
d124 1
a124 1
			splx(s);
d128 1
a128 1
			splx(s);
d132 1
a132 1
		error = tsleep(&sc->rchan, PWAIT|PCATCH, "mid_rd", 0);
d134 1
a134 1
			splx(s);
d149 1
a149 1
			splx(s);
d154 1
a154 1
	splx(s);
a157 1

a162 1
	int 		    s;
d164 1
a166 1
		s = splaudio();
a175 1
		splx(s);
d179 7
a195 1

a208 1

a233 1

d239 2
a240 2
	unsigned 	    count;
	int		    s, error;
d257 1
a257 1
		s = splaudio();
d264 1
a264 1
				splx(s);
d268 2
a269 1
			error = tsleep(&sc->wchan, PWAIT|PCATCH, "mid_wr", 0);
d271 1
a271 1
				splx(s);
d275 1
a275 1
				splx(s);
d287 1
a287 1
			splx(s);
d292 1
a292 1
		splx(s);
a296 1

d301 1
a301 1
	int		   s, revents;
d307 1
a307 1
	s = splaudio();
d322 1
a322 1
	splx(s);
a325 1

a330 1
	int		   s;
d346 1
a346 1
	s = splaudio();
d348 1
a348 1
	splx(s);
a352 1

a356 1
	int		   s;
d358 1
a358 1
	s = splaudio();
d360 1
a360 1
	splx(s);
a362 1

d367 1
a367 1
	int		   s, retval;
d369 1
a369 1
	s = splaudio();
d371 1
a371 1
	splx(s);
a375 1

a379 1
	int 		   s;
d381 1
a381 1
	s = splaudio();
d383 1
a383 1
	splx(s);
a385 1

d390 1
a390 1
	int		   s, retval;
d392 1
a392 1
	s = splaudio();
d394 1
a394 1
	splx(s);
a398 1

a424 1

d429 1
a429 1
	int		   err;
a454 1

d460 1
a460 2
	int 		    error;
	int		    s;
d465 1
a465 1
		s = splaudio();
d470 2
a471 1
			error = tsleep(&sc->wchan, PWAIT, "mid_dr", 5 * hz);
d475 1
a475 1
		splx(s);
a490 1

a498 1

d502 1
a502 1
	struct midi_info 	  mi;
d508 1
a508 1
	timeout_set(&sc->timeo, midi_ointr, sc);
a511 1

a534 1

d539 1
a539 1
	int    maj, mn;
a561 1

a569 1

a581 1

@


1.28
log
@Output interrupts are raised when the uart is ready for output, which
obviously can occur after the transfer complete. In this case, don't
print a warning (if MIDI_DEBUG defined) and don't attempt to stop the
transfer twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.27 2012/03/30 08:18:19 ratchov Exp $	*/
a18 10
/*
 * TODO
 *	- put the sequencer stuff in sequencer.c and sequencervar.h
 *	  there is no reason to have it here. The sequencer
 *	  driver need only to open the midi hw_if thus it does not
 *	  need this driver
 */

#include "sequencer.h"

a59 7
#if NSEQUENCER > 0
int	midi_unit_count(void);
void	midi_toevent(struct midi_softc *, int);
int	midi_writebytes(int, u_char *, int);
void	midiseq_in(struct midi_dev *, u_char *, int);
#endif

a92 6
#if NSEQUENCER > 0
	if (sc->seqopen) {
		midi_toevent(sc, data);
		return;
	}
#endif
a461 5
#if NSEQUENCER > 0
	sc->seq_md = 0;
	sc->seqopen = 0;
	sc->evstatus = 0xff;
#endif
a618 71

#if NSEQUENCER > 0
#define MIDI_EVLEN(status) 	(midi_evlen[((status) >> 4) & 7])
unsigned midi_evlen[] = { 2, 2, 2, 2, 1, 1, 2 };

void
midi_toevent(struct midi_softc *sc, int data)
{
	unsigned char mesg[3];

	if (data >= 0xf8) {		/* is it a realtime message ? */
		switch(data) {
		case 0xf8:		/* midi timer tic */
		case 0xfa:		/* midi timer start */
		case 0xfb:		/* midi timer continue (after stop) */
		case 0xfc:		/* midi timer stop */
			mesg[0] = data;
			midiseq_in(sc->seq_md, mesg, 1);
			break;
		default:
			break;
		}
	} else if (data >= 0x80) {	/* is it a common or voice message ? */
		sc->evstatus = data;
		sc->evindex = 0;
	} else {			/* else it is a data byte */
		/* strip common messages and bogus data */
		if (sc->evstatus >= 0xf0 || sc->evstatus < 0x80)
			return;

		sc->evdata[sc->evindex++] = data;
		if (sc->evindex == MIDI_EVLEN(sc->evstatus)) {
			sc->evindex = 0;
			mesg[0] = sc->evstatus;
			mesg[1] = sc->evdata[0];
			mesg[2] = sc->evdata[1];
			midiseq_in(sc->seq_md, mesg, 1 + MIDI_EVLEN(sc->evstatus));
		}
	}
}


int
midi_writebytes(int unit, unsigned char *mesg, int mesglen)
{
	struct midi_softc  *sc = midi_cd.cd_devs[unit];
	struct midi_buffer *mb = &sc->outbuf;
	unsigned 	    count;
	int		    s;

	s = splaudio();
	if (mesglen > MIDIBUF_AVAIL(mb)) {
		splx(s);
		return EWOULDBLOCK;
	}

	while (mesglen > 0) {
		count = MIDIBUF_SIZE - MIDIBUF_END(mb);
		if (count > MIDIBUF_AVAIL(mb)) count = MIDIBUF_AVAIL(mb);
		if (count > mesglen) count = mesglen;
		bcopy(mesg, mb->data + MIDIBUF_END(mb), count);
		mb->used += count;
		mesg += count;
		mesglen -= count;
		midi_out_start(sc);
	}
	splx(s);
	return 0;
}

#endif /* NSEQUENCER > 0 */
@


1.27
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.26 2011/07/02 22:20:07 nicm Exp $	*/
d191 3
d195 3
a197 3
		if (!sc->isbusy) {
			printf("midi_ointr: output should be busy\n");
		}
d199 2
a200 3
		mb = &sc->outbuf;
		s = splaudio();
		if (mb->used == 0)
a201 2
		else
			midi_out_do(sc); /* restart output */
@


1.26
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.25 2011/01/27 20:37:19 ratchov Exp $	*/
a234 2
	unsigned 	    i;
	int		    error;
d236 2
a237 8
	/*
	 * If output interrupts are not supported then we write MIDI_MAXWRITE
	 * bytes instead of 1, and then we wait sc->wait
	 */

	i = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAXWRITE;
	while (i != 0) {
		if (mb->used == 0)
d239 4
a242 33
		error = sc->hw_if->output(sc->hw_hdl, mb->data[mb->start]);
		/*
		 * 0 means that data is being sent, an interrupt will
		 * be generated when the interface becomes ready again
		 *
		 * EINPROGRESS means that data has been queued, but
		 * will not be sent immediately and thus will not
		 * generate interrupt, in this case we can send
		 * another byte. The flush() method can be called
		 * to force the transfer.
		 *
		 * EAGAIN means that data cannot be queued or sent;
		 * because the interface isn't ready. An interrupt
		 * will be generated once the interface is ready again
		 *
		 * any other (fatal) error code means that data couldn't
		 * be sent and was lost, interrupt will not be generated
		 */
		if (error == EINPROGRESS) {
			MIDIBUF_REMOVE(mb, 1);
			if (MIDIBUF_ISEMPTY(mb)) {
				if (sc->hw_if->flush != NULL)
					sc->hw_if->flush(sc->hw_hdl);
				midi_out_stop(sc);
				return;
			}
		} else if (error == 0) {
			MIDIBUF_REMOVE(mb, 1);
			i--;
		} else if (error == EAGAIN) {
			break;
		} else {
			MIDIBUF_INIT(mb);
d252 1
a252 1
			timeout_add(&sc->timeo, sc->wait);
d520 3
a522 4
	 * so we may lose some (important) data. To avoid this, we sleep 2*wait,
	 * which gives the time to the uart to drain its internal buffers.
	 *
	 * Note: we'd better sleep in the corresponding hw_if->close()
d524 1
a524 2

	tsleep(&sc->wchan, PWAIT, "mid_cl", 2 * sc->wait);
a545 3
	sc->wait = (hz * MIDI_MAXWRITE) /  MIDI_RATE;
	if (sc->wait == 0)
		sc->wait = 1;
@


1.25
log
@while closing the device, don't sleep with the PCATCH flag, otherwise
a signal (like SIGALRM) may cause the output buffer to not be drained
and causing for instance stale notes.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.24 2011/01/01 16:34:42 ratchov Exp $	*/
d404 1
a404 1
		return (EPERM);
@


1.24
log
@fix spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.23 2010/11/18 21:15:14 miod Exp $	*/
d547 1
a547 1
			error = tsleep(&sc->wchan, PWAIT|PCATCH, "mid_dr", 0);
d563 1
a563 1
	tsleep(&sc->wchan, PWAIT|PCATCH, "mid_cl", 2 * sc->wait);
@


1.23
log
@Don't
  #include "foo.h"
  #if NFOO > 0
  (whole file)
  #endif
since config(8) file inclusion rules already do it for you.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.22 2010/04/08 01:48:24 fgsch Exp $	*/
d23 2
a24 2
 *	  driver need only to open the midi hw_if thus it does not 
 *	  need this driver 
d50 5
a54 5
int     midiopen(dev_t, int, int, struct proc *);
int     midiclose(dev_t, int, int, struct proc *);
int     midiread(dev_t, struct uio *, int);
int     midiwrite(dev_t, struct uio *, int);
int     midipoll(dev_t, int, struct proc *);
d71 4
a74 4
int		   midi_unit_count(void);
void		   midi_toevent(struct midi_softc *, int);
int		   midi_writebytes(int, u_char *, int);
void		   midiseq_in(struct midi_dev *, u_char *, int);
d102 1
a102 1
midi_iintr(void *addr, int data) 
d106 4
a109 3
	
	if (sc->isdying || !sc->isopen || !(sc->flags & FREAD)) return;
	
d139 1
a139 1
	
d142 1
a142 1
		
d146 1
a146 1
	while(MIDIBUF_ISEMPTY(mb)) {
d159 1
a159 1
			return error;			
d162 1
a162 1
	
d165 1
a165 1
	while (uio->uio_resid > 0  &&  mb->used > 0) {
d167 1
a167 1
		if (count > mb->used) 
d169 1
a169 1
		if (count > uio->uio_resid) 
d179 1
a179 1
	return 0;	
d183 1
a183 1
void 
d188 2
a189 2
	int 		   s;
	
d216 1
a230 4
	/*
	 * drain output buffer, must be called with
	 * interrupts disabled
	 */
d237 1
a237 1
	
d249 1
a249 1
		 * 0 means that data is being sent, an interrupt will 
d252 3
a254 3
		 * EINPROGRESS means that data has been queued, but 
		 * will not be sent immediately and thus will not 
		 * generate interrupt, in this case we can send 
d259 1
a259 1
		 * because the interface isn't ready. An interrupt 
d262 1
a262 1
		 * any other (fatal) error code means that data couldn't 
d284 1
a284 1
	
d301 1
a301 1
	
d308 2
a309 2
	 * If IO_NDELAY flag is set then check if there is enough room 
	 * in the buffer to store at least one byte. If not then dont 
d313 3
a315 4
	if ((ioflag & IO_NDELAY) &&  MIDIBUF_ISFULL(mb)  &&
	    (uio->uio_resid > 0))
	    	return EWOULDBLOCK;
	
d320 1
a320 1
				/* 
d338 1
a338 1
					
d342 1
a342 1
		if (count > uio->uio_resid) 
d362 1
a362 1
	
d473 2
a474 1
	if (sc->isdying) return EIO;
d482 2
a483 1
			if (sc->async) return EBUSY;
a489 1
		break;
d531 1
a531 1
int 
d538 1
a538 1
	
d553 2
a554 2
	
	/* 
d562 1
a562 1
	 
d574 1
d583 1
a583 1
	
d586 1
a586 1
	if (sc->wait == 0) 
d603 1
a603 1
	
d625 1
a625 1
	
d635 1
a635 1
	
d637 5
a641 5
        for (maj = 0; maj < nchrdev; maj++) {
                if (cdevsw[maj].d_open == midiopen) {
        		/* Nuke the vnodes for any open instances (calls close). */
        		mn = self->dv_unit;
        		vdevgone(maj, mn, mn, VCHR);
d661 1
d698 1
a698 1
	
d714 1
a714 1
	} else {			/* else it is a data byte */	
d738 1
a738 1
	
d744 1
a744 1
	
@


1.22
log
@remove unneeded variable. ratchov@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.21 2009/11/09 17:53:39 nicm Exp $	*/
a26 1
#include "midi.h"
a27 1
#if NMIDI > 0
a759 1
#endif /* NMIDI > 0 */
@


1.21
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.20 2009/11/01 20:14:12 nicm Exp $	*/
d239 1
a239 1
	unsigned 	    i, max;
d247 2
a248 2
	max = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAXWRITE;
	for (i = max; i != 0;) {
@


1.20
log
@kqueue support for midi(4).

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.19 2009/10/30 18:12:30 deraadt Exp $	*/
a126 1
		KNOTE(&sc->rsel.si_note, 0);
a225 1
	KNOTE(&sc->wsel.si_note, 0);
@


1.19
log
@KNOTE() after selwakeup()
ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.18 2009/08/17 10:27:42 ratchov Exp $	*/
d57 1
d88 15
d119 3
a121 1
	if (MIDIBUF_ISEMPTY(mb)) {
d125 1
a125 1
		}	
a130 1
	MIDIBUF_WRITE(mb, data);
d391 81
@


1.18
log
@remove prototype of non-existent midi_get_hwif()
suggested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.17 2009/07/18 10:58:41 ratchov Exp $	*/
d109 1
d210 1
@


1.17
log
@While detatching the device, workaround the case when a midi
entry is missing in cdevsw[], in which case vdevgone() is called
with out of bounds argument.
requested by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.16 2006/12/21 02:28:47 krw Exp $	*/
a72 1
struct midi_hw_if *midi_get_hwif(int);
@


1.16
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.15 2006/11/01 03:37:23 tedu Exp $	*/
d543 7
a549 8
        for (maj = 0; maj < nchrdev; maj++)
                if (cdevsw[maj].d_open == midiopen)
                        break;

        /* Nuke the vnodes for any open instances (calls close). */
        mn = self->dv_unit;
        vdevgone(maj, mn, mn, VCHR);

@


1.15
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.14 2006/04/16 03:24:27 jsg Exp $	*/
d244 1
a244 1
		 * to force the tranfer.
@


1.14
log
@Handle input interrupts in a better manner.
It is only necessary to notify reading processes when the buffer is
empty rather than on every input byte.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.13 2006/04/07 22:41:32 jsg Exp $	*/
d353 1
a353 1
		return EIO;
@


1.13
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.12 2004/09/22 22:17:44 deraadt Exp $	*/
a92 1
	int 		    s;
d104 9
a112 2
	
	s = splaudio();
a113 9
	splx(s);
	
	if (sc->rchan) {
		sc->rchan = 0;
		wakeup(&sc->rchan);
	}	
	selwakeup(&sc->rsel);
	if (sc->async)
		psignal(sc->async, SIGIO);
@


1.12
log
@the following patch fixes a bug preventing midi uarts that do
not support interrupts on output, from writing blocks larger than
MIDI_MAXWRITE bytes. tested on both kinds of devices
from alex-contact@@caoua.org
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.11 2004/09/21 06:03:15 brad Exp $	*/
d51 1
a226 1
	unsigned	    data;
d232 2
a233 2
	 */	
	 	
d238 1
a238 3

		MIDIBUF_READ(mb, data);
		error = sc->hw_if->output(sc->hw_hdl, data);
d240 15
a254 4
		 * EINPROGRESS means that data has been handled,
		 * but will not be sent immediately and thus will
		 * not generate interrupt, in this case we can
		 * send another byte
d257 1
d259 2
d264 2
a265 1
		} else
d267 7
@


1.11
log
@re-add RCS id after last commit
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d257 3
a259 4
		if (i < max) {
			if (MIDIBUF_ISEMPTY(mb))
				midi_out_stop(sc);
		} else
@


1.10
log
@better midi stuff from alex@@caoua.org
@
text
@d1 2
@


1.9
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@a0 3
/*	$OpenBSD: midi.c,v 1.8 2002/03/14 01:26:52 millert Exp $	*/
/*	$NetBSD: midi.c,v 1.10 1998/12/20 14:26:44 drochner Exp $	*/

d2 1
a2 2
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
d4 3
a6 2
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (augustss@@netbsd.org).
d8 15
a22 27
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a25 1
#include "audio.h"
d27 1
d30 2
d33 4
a36 3
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/select.h>
a37 4
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/syslog.h>
d39 2
d42 1
a42 3
#include <sys/conf.h>
#include <sys/audioio.h>
#include <sys/midiio.h>
d45 1
a46 1
#include <dev/midi_if.h>
d49 10
a58 1
#if NMIDI > 0
d60 6
a65 8
#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (mididebug) printf x
#define DPRINTFN(n,x)	if (mididebug >= (n)) printf x
int	mididebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
a66 1
int midi_wait;
d68 6
a73 14
void	midi_in(void *, int);
void	midi_out(void *);
int	midi_start_output(struct midi_softc *, int);
int	midi_sleep_timo(int *, char *, int);
int	midi_sleep(int *, char *);
void	midi_wakeup(int *);
void	midi_initbuf(struct midi_buffer *);
void	midi_timeout(void *);

#define __BROKEN_INDIRECT_CONFIG /* XXX */
#ifdef __BROKEN_INDIRECT_CONFIG
int	midiprobe(struct device *, void *, void *);
#else
int	midiprobe(struct device *, struct cfdata *, void *);
a74 1
void	midiattach(struct device *, struct device *, void *);
d77 1
a77 1
	sizeof(struct midi_softc), midiprobe, midiattach
a83 27
#ifdef MIDI_SAVE
#define MIDI_SAVE_SIZE 100000
int midicnt;
struct {
	int cnt;
	u_char buf[MIDI_SAVE_SIZE];
} midisave;
#define MIDI_GETSAVE		_IOWR('m', 100, int)

#endif

int
midiprobe(parent, match, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
{
	struct audio_attach_args *sa = aux;

	DPRINTFN(6,("midiprobe: type=%d sa=%p hw=%p\n", 
		 sa->type, sa, sa->hwif));
	return ((sa->type == AUDIODEV_TYPE_MIDI) ? 1 : 0);
}
d86 1
a86 3
midiattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d88 9
a96 14
	struct midi_softc *sc = (void *)self;
	struct audio_attach_args *sa = aux;
	struct midi_hw_if *hwp = sa->hwif;
	void *hdlp = sa->hdl;

	DPRINTFN(6, ("MIDI attach\n"));

#ifdef DIAGNOSTIC
	if (hwp == 0 ||
	    hwp->open == 0 ||
	    hwp->close == 0 ||
	    hwp->output == 0 ||
	    hwp->getinfo == 0) {
		printf("midi: missing method\n");
d100 14
a113 3
	sc->hw_if = hwp;
	sc->hw_hdl = hdlp;
	midi_attach(sc, parent);
d116 3
a118 4
void
midi_attach(sc, parent)
	struct midi_softc *sc;
	struct device *parent;
d120 9
a128 1
	struct midi_info mi;
d130 19
a148 1
	sc->isopen = 0;
d150 16
a165 3
	midi_wait = MIDI_WAIT * hz / 1000000;
	if (midi_wait == 0)
		midi_wait = 1;
a166 6
	sc->sc_dev = parent;
	sc->hw_if->getinfo(sc->hw_hdl, &mi);
	sc->props = mi.props;
	timeout_set(&sc->timeo, midi_timeout, sc);
	printf(": <%s>\n", mi.name);
}
d168 2
a169 2
int
midi_unit_count()
d171 1
a171 5
	return (midi_cd.cd_ndevs);
}

void
midi_initbuf(mb)
d173 3
a175 22
{
	mb->used = 0;
	mb->usedhigh = MIDI_BUFSIZE;
	mb->end = mb->start + mb->usedhigh;
	mb->inp = mb->outp = mb->start;
}

int
midi_sleep_timo(chan, label, timo)
	int *chan;
	char *label;
	int timo;
{
	int st;

	if (!label)
		label = "midi";

	DPRINTFN(5, ("midi_sleep_timo: %p %s %d\n", chan, label, timo));
	*chan = 1;
	st = tsleep(chan, PWAIT | PCATCH, label, timo);
	*chan = 0;
d177 3
a179 2
	if (st != 0)
		printf("midi_sleep: %d\n", st);
d181 8
a188 1
	return (st);
a190 7
int
midi_sleep(chan, label)
	int *chan;
	char *label;
{
	return (midi_sleep_timo(chan, label, 0));
}
d193 1
a193 2
midi_wakeup(chan)
	int *chan;
d195 3
a197 4
	if (*chan) {
		DPRINTFN(5, ("midi_wakeup: %p\n", chan));
		wakeup(chan);
		*chan = 0;
a200 4
static int midi_lengths[] = { 2,2,2,2,1,1,2,0 };
/* Number of bytes in a MIDI command */
#define MIDI_LENGTH(d) (midi_lengths[((d) >> 4) & 7])

d202 1
a202 3
midi_in(addr, data)
	void *addr;
	int data;
d204 4
a207 65
	struct midi_softc *sc = addr;
	struct midi_buffer *mb = &sc->inbuf;
	int i;

	if (!sc->isopen)
		return;
	if (data == MIDI_ACK)
		return;
	DPRINTFN(3, ("midi_in: %p 0x%02x\n", sc, data));
	if (!(sc->flags & FREAD))
		return;		/* discard data if not reading */

	switch(sc->in_state) {
	case MIDI_IN_START:
		if (MIDI_IS_STATUS(data)) {
			switch(data) {
			case 0xf0: /* Sysex */
				sc->in_state = MIDI_IN_SYSEX;
				break;
			case 0xf1: /* MTC quarter frame */
			case 0xf3: /* Song select */
				sc->in_state = MIDI_IN_DATA;
				sc->in_msg[0] = data;
				sc->in_pos = 1;
				sc->in_left = 1;
				break;
			case 0xf2: /* Song position pointer */
				sc->in_state = MIDI_IN_DATA;
				sc->in_msg[0] = data;
				sc->in_pos = 1;
				sc->in_left = 2;
				break;
			default:
				if (MIDI_IS_COMMON(data)) {
					sc->in_msg[0] = data;
					sc->in_pos = 1;
					goto deliver;
				} else {
					sc->in_state = MIDI_IN_DATA;
					sc->in_msg[0] = sc->in_status = data;
					sc->in_pos = 1;
					sc->in_left = 
						MIDI_LENGTH(sc->in_status);
				}
				break;
			}
		} else {
			if (MIDI_IS_STATUS(sc->in_status)) {
				sc->in_state = MIDI_IN_DATA;
				sc->in_msg[0] = sc->in_status;
				sc->in_msg[1] = data;
				sc->in_pos = 2;
				sc->in_left = MIDI_LENGTH(sc->in_status) - 1;
			}
		}
		return;
	case MIDI_IN_DATA:
		sc->in_msg[sc->in_pos++] = data;
		if (--sc->in_left <= 0)
			break;	/* deliver data */
		return;
	case MIDI_IN_SYSEX:
		if (data == MIDI_SYSEX_END)
			sc->in_state = MIDI_IN_START;
		return;
d209 1
a209 23
deliver:
	sc->in_state = MIDI_IN_START;
#if NSEQUENCER > 0
	if (sc->seqopen) {
		extern void midiseq_in(struct midi_dev *,u_char *,int);
		midiseq_in(sc->seq_md, sc->in_msg, sc->in_pos);
		return;
	}
#endif

	if (mb->used + sc->in_pos > mb->usedhigh) {
		DPRINTF(("midi_in: buffer full, discard data=0x%02x\n", 
			 sc->in_msg[0]));
		return;
	}
	for (i = 0; i < sc->in_pos; i++) {
		*mb->inp++ = sc->in_msg[i];
		if (mb->inp >= mb->end)
			mb->inp = mb->start;
		mb->used++;
	}
	midi_wakeup(&sc->rchan);
	selwakeup(&sc->rsel);
d214 5
d220 1
a220 2
midi_out(addr)
	void *addr;
d222 14
a235 1
	struct midi_softc *sc = addr;
d237 23
a259 45
	if (!sc->isopen)
		return;
	DPRINTFN(3, ("midi_out: %p\n", sc));
	midi_start_output(sc, 1);
}

int
midiopen(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
{
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc;
	struct midi_hw_if *hw;
	int error;

	if (unit >= midi_cd.cd_ndevs ||
	    (sc = midi_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
	DPRINTF(("midiopen %p\n", sc));

	hw = sc->hw_if;
	if (!hw)
		return (ENXIO);
	if (sc->isopen)
		return (EBUSY);
	sc->in_state = MIDI_IN_START;
	sc->in_status = 0;
	error = hw->open(sc->hw_hdl, flags, midi_in, midi_out, sc);
	if (error)
		return (error);
	sc->isopen++;
	midi_initbuf(&sc->outbuf);
	midi_initbuf(&sc->inbuf);
	sc->flags = flags;
	sc->rchan = 0;
	sc->wchan = 0;
	sc->pbus = 0;
	sc->async = 0;

#ifdef MIDI_SAVE
	if (midicnt != 0) {
		midisave.cnt = midicnt;
		midicnt = 0;
a260 3
#endif

	return (0);
a262 29
int
midiclose(dev, flags, ifmt, p)
	dev_t dev;
	int flags, ifmt;
	struct proc *p;
{
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	struct midi_hw_if *hw = sc->hw_if;
	int s, error;

	DPRINTF(("midiclose %p\n", sc));

	midi_start_output(sc, 0);
	error = 0;
	s = splaudio();
	while (sc->outbuf.used > 0 && !error) {
		DPRINTFN(2,("midiclose sleep used=%d\n", sc->outbuf.used));
		error = midi_sleep_timo(&sc->wchan, "mid_dr", 30*hz);
	}
	splx(s);
	sc->isopen = 0;
	hw->close(sc->hw_hdl);
#if NSEQUENCER > 0
	sc->seqopen = 0;
	sc->seq_md = 0;
#endif
	return (0);
}
d265 1
a265 4
midiread(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d267 21
a287 13
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	struct midi_buffer *mb = &sc->inbuf;
	int error;
	u_char *outp;
	int used, cc, n, resid;
	int s;

	DPRINTF(("midiread: %p, count=%d\n", sc, uio->uio_resid));

	error = 0;
	resid = uio->uio_resid;
	while (uio->uio_resid == resid && !error) {
d289 1
a289 1
		while (mb->used <= 0) {
d291 4
d296 1
a296 1
				return (EWOULDBLOCK);
d298 2
a299 1
			error = midi_sleep(&sc->rchan, "mid rd");
d302 5
a306 1
				return (error);
d309 13
a321 20
		used = mb->used;
		outp = mb->outp;
		splx(s);
		cc = used;	/* maximum to read */
		n = mb->end - outp;
		if (n < cc)
			cc = n;	/* don't read beyond end of buffer */
		if (uio->uio_resid < cc)
			cc = uio->uio_resid; /* and no more than we want */
		DPRINTFN(3, ("midiread: uiomove cc=%d\n", cc));
		error = uiomove(outp, cc, uio);
		if (error)
			break;
		used -= cc;
		outp += cc;
		if (outp >= mb->end)
			outp = mb->start;
		s = splaudio();
		mb->outp = outp;
		mb->used = used;
d324 1
a324 1
	return (error);
a326 9
void
midi_timeout(arg)
	void *arg;
{
	struct midi_softc *sc = arg;

	DPRINTFN(3,("midi_timeout: %p\n", sc));
	midi_start_output(sc, 1);
}
d329 1
a329 3
midi_start_output(sc, intr)
	struct midi_softc *sc;
	int intr;
d331 5
a335 5
	struct midi_buffer *mb = &sc->outbuf;
	u_char *outp;
	int error;
	int s;
	int i, mmax;
d337 1
a337 2
	error = 0;
	mmax = sc->props & MIDI_PROP_OUT_INTR ? 1 : MIDI_MAX_WRITE;
d339 7
a345 4
	if (sc->pbus && !intr) {
		DPRINTFN(4, ("midi_start_output: busy\n"));
		splx(s);
		return (0);
d347 5
a351 16
	sc->pbus = 1;
	for (i = 0; i < mmax && mb->used > 0 && !error; i++) {
		outp = mb->outp;
		splx(s);
		DPRINTFN(4, ("midi_start_output: %p i=%d, data=0x%02x\n", 
			     sc, i, *outp));
#ifdef MIDI_SAVE
		midisave.buf[midicnt] = *outp;
		midicnt = (midicnt + 1) % MIDI_SAVE_SIZE;
#endif
		error = sc->hw_if->output(sc->hw_hdl, *outp++);
		if (outp >= mb->end)
			outp = mb->start;
		s = splaudio();
		mb->outp = outp;
		mb->used--;
a352 9
	midi_wakeup(&sc->wchan);
	selwakeup(&sc->wsel);
	if (sc->async)
		psignal(sc->async, SIGIO);
	if (mb->used > 0) {
		if (!(sc->props & MIDI_PROP_OUT_INTR))
			timeout_add(&sc->timeo, midi_wait);
	} else
		sc->pbus = 0;
d354 1
a354 1
	return (error);
d357 1
d359 1
a359 4
midiwrite(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d361 1
a361 7
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	struct midi_buffer *mb = &sc->outbuf;
	int error;
	u_char *inp;
	int used, cc, n;
	int s;
d363 1
a363 2
	DPRINTFN(2, ("midiwrite: %p, unit=%d, count=%d\n", sc, unit, 
		     uio->uio_resid));
d365 14
a378 42
	error = 0;
	while (uio->uio_resid > 0 && !error) {
		s = splaudio();
		if (mb->used >= mb->usedhigh) {
			DPRINTFN(3,("midi_write: sleep used=%d hiwat=%d\n", 
				 mb->used, mb->usedhigh));
			if (ioflag & IO_NDELAY) {
				splx(s);
				return (EWOULDBLOCK);
			}
			error = midi_sleep(&sc->wchan, "mid wr");
			if (error) {
				splx(s);
				return (error);
			}
		}			
		used = mb->used;
		inp = mb->inp;
		splx(s);
		cc = mb->usedhigh - used; 	/* maximum to write */
		n = mb->end - inp;
		if (n < cc)
			cc = n;		/* don't write beyond end of buffer */
		if (uio->uio_resid < cc)
			cc = uio->uio_resid; 	/* and no more than we have */
		error = uiomove(inp, cc, uio);
#ifdef MIDI_DEBUG
		if (error)
		        printf("midi_write:(1) uiomove failed %d; "
			       "cc=%d inp=%p\n",
			       error, cc, inp);
#endif
		if (error)
			break;
		inp = mb->inp + cc;
		if (inp >= mb->end)
			inp = mb->start;
		s = splaudio();
		mb->inp = inp;
		mb->used += cc;
		splx(s);
		error = midi_start_output(sc, 0);
d380 1
a380 1
	return (error);
d383 1
a383 4
/*
 * This write routine is only called from sequencer code and expects
 * a write that is smaller than the MIDI buffer.
 */
d385 1
a385 4
midi_writebytes(unit, buf, cc)
	int unit;
	u_char *buf;
	int cc;
d387 31
a417 3
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	struct midi_buffer *mb = &sc->outbuf;
	int n, s;
a418 2
	DPRINTFN(2, ("midi_writebytes: %p, unit=%d, cc=%d\n", sc, unit, cc));
	DPRINTFN(3, ("midi_writebytes: %x %x %x\n",buf[0],buf[1],buf[2]));
d420 20
a439 2
	s = splaudio();
	if (mb->used + cc >= mb->usedhigh) {
a440 1
		return (EWOULDBLOCK);
d442 14
a455 16
	n = mb->end - mb->inp;
	if (cc < n)
		n = cc;
	mb->used += cc;
	bcopy(buf, mb->inp, n);
	mb->inp += n;
	if (mb->inp >= mb->end) {
		mb->inp = mb->start;
		cc -= n;
		if (cc > 0) {
			bcopy(buf + n, mb->inp, cc);
			mb->inp += cc;
		}
	}
	splx(s);
	return (midi_start_output(sc, 0));
d458 1
d460 5
a464 18
midiioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	struct midi_hw_if *hw = sc->hw_if;
	int error;

	DPRINTF(("midiioctl: %p cmd=0x%08lx\n", sc, cmd));
	error = 0;
	switch (cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer. */
		break;
a465 9
	case FIOASYNC:
		if (*(int *)addr) {
			if (sc->async)
				return (EBUSY);
			sc->async = p;
			DPRINTF(("midi_ioctl: FIOASYNC %p\n", p));
		} else
			sc->async = 0;
		break;
d467 15
a481 8
#if 0
	case MIDI_PRETIME:
		/* XXX OSS
		 * This should set up a read timeout, but that's
		 * why we have poll(), so there's nothing yet. */
		error = EINVAL;
		break;
#endif
a482 5
#ifdef MIDI_SAVE
	case MIDI_GETSAVE:
		error = copyout(&midisave, *(void **)addr, sizeof midisave);
  		break;
#endif
d484 16
a499 6
	default:
		if (hw->ioctl)
			error = hw->ioctl(sc->hw_hdl, cmd, addr, flag, p);
		else
			error = ENOTTY;
		break;
d501 4
a504 1
	return (error);
d507 1
d509 19
a527 8
midipoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc = midi_cd.cd_devs[unit];
	int revents = 0, s = splaudio();
d529 6
a534 1
	DPRINTF(("midipoll: %p events=0x%x\n", sc, events));
a535 14
	if (events & (POLLIN | POLLRDNORM)) {
		if (sc->inbuf.used > 0)
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (sc->outbuf.used < sc->outbuf.usedhigh)
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->wsel);
	}
d537 6
a542 2
	splx(s);
	return (revents);
d545 1
d547 1
a547 3
midi_getinfo(dev, mi)
	dev_t dev;
	struct midi_info *mi;
d549 4
a552 5
	int unit = MIDIUNIT(dev);
	struct midi_softc *sc;

	if (unit >= midi_cd.cd_ndevs ||
	    (sc = midi_cd.cd_devs[unit]) == NULL)
d554 1
a557 5
#endif /* NMIDI > 0 */

#if (NMIDI > 0 || NMIDIBUS > 0) && NAUDIO > 0

int	midiprint(void *, const char *);
d560 1
a560 4
midi_attach_mi(mhwp, hdlp, dev)
	struct midi_hw_if *mhwp;
	void *hdlp;
	struct device *dev;
a563 6
#ifdef DIAGNOSTIC
	if (mhwp == NULL) {
		printf("midi_attach_mi: NULL\n");
		return 0;
	}
#endif
d565 2
a566 2
	arg.hwif = mhwp;
	arg.hdl = hdlp;
d570 49
d620 1
a620 3
midiprint(aux, pnp)
	void *aux;
	const char *pnp;
d622 23
a644 3
	if (pnp)
		printf("midi at %s", pnp);
	return (UNCONF);
d647 2
a648 1
#endif /* NMIDI > 0 || NMIDIBUS > 0 */
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.7 2002/01/10 18:49:07 mickey Exp $	*/
d698 1
a698 1
midiselect(dev, rw, p)
d700 1
a700 1
	int rw;
d705 1
a705 1
	int s = splaudio();
d707 1
a707 1
	DPRINTF(("midiselect: %p rw=0x%x\n", sc, rw));
d709 13
a721 16
	switch (rw) {
	case FREAD:
		if (sc->inbuf.used > 0) {
			splx(s);
			return (1);
		}
		selrecord(p, &sc->rsel);
		break;

	case FWRITE:
		if (sc->outbuf.used < sc->outbuf.usedhigh) {
			splx(s);
			return (1);
		}
		selrecord(p, &sc->wsel);
		break;
d725 1
a725 1
	return (0);
@


1.7
log
@return ENOTTY not EINVAL in default: in *ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.6 2001/03/23 00:13:23 mickey Exp $	*/
d78 8
a85 8
void	midi_in __P((void *, int));
void	midi_out __P((void *));
int	midi_start_output __P((struct midi_softc *, int));
int	midi_sleep_timo __P((int *, char *, int));
int	midi_sleep __P((int *, char *));
void	midi_wakeup __P((int *));
void	midi_initbuf __P((struct midi_buffer *));
void	midi_timeout __P((void *));
d89 1
a89 1
int	midiprobe __P((struct device *, void *, void *));
d91 1
a91 1
int	midiprobe __P((struct device *, struct cfdata *, void *));
d93 1
a93 1
void	midiattach __P((struct device *, struct device *, void *));
d314 1
a314 1
		extern void midiseq_in __P((struct midi_dev *,u_char *,int));
d749 1
a749 1
int	midiprint __P((void *, const char *));
@


1.6
log
@fix compiling in audio-less configs
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.5 2000/06/26 22:43:21 art Exp $	*/
d691 1
a691 1
			error = EINVAL;
@


1.6.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.7 2002/01/10 18:49:07 mickey Exp $	*/
d691 1
a691 1
			error = ENOTTY;
@


1.6.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.6.6.1 2002/01/31 22:55:29 niklas Exp $	*/
d78 8
a85 8
void	midi_in(void *, int);
void	midi_out(void *);
int	midi_start_output(struct midi_softc *, int);
int	midi_sleep_timo(int *, char *, int);
int	midi_sleep(int *, char *);
void	midi_wakeup(int *);
void	midi_initbuf(struct midi_buffer *);
void	midi_timeout(void *);
d89 1
a89 1
int	midiprobe(struct device *, void *, void *);
d91 1
a91 1
int	midiprobe(struct device *, struct cfdata *, void *);
d93 1
a93 1
void	midiattach(struct device *, struct device *, void *);
d314 1
a314 1
		extern void midiseq_in(struct midi_dev *,u_char *,int);
d749 1
a749 1
int	midiprint(void *, const char *);
@


1.5
log
@Convert to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.4 2000/05/24 13:44:18 ho Exp $	*/
d41 1
d747 1
a747 1
#if NMIDI > 0 || NMIDIBUS > 0
@


1.4
log
@Permit detach of audio devices, such as uaudio. Selected code
from NetBSD/Lennart Augustsson. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.3 2000/01/03 19:38:13 fgsch Exp $	*/
d173 1
d531 1
a531 1
			timeout(midi_timeout, sc, midi_wait);
@


1.3
log
@Remove dependencies between midi & audio. midi now will compile on
speaker only systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.2 1999/01/02 00:59:08 niklas Exp $	*/
d749 1
a749 1
void
d760 1
a760 1
		return;
d766 1
a766 1
	(void)config_found(dev, &arg, midiprint);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.6 2001/03/23 00:13:23 mickey Exp $	*/
a40 1
#include "audio.h"
a172 1
	timeout_set(&sc->timeo, midi_timeout, sc);
d530 1
a530 1
			timeout_add(&sc->timeo, midi_wait);
d745 1
a745 1
#if (NMIDI > 0 || NMIDIBUS > 0) && NAUDIO > 0
d749 1
a749 1
struct device *
d760 1
a760 1
		return 0;
d766 1
a766 1
	return config_found(dev, &arg, midiprint);
@


1.3.2.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d691 1
a691 1
			error = ENOTTY;
@


1.3.2.3
log
@Merge in -current from about a week ago
@
text
@d78 8
a85 8
void	midi_in(void *, int);
void	midi_out(void *);
int	midi_start_output(struct midi_softc *, int);
int	midi_sleep_timo(int *, char *, int);
int	midi_sleep(int *, char *);
void	midi_wakeup(int *);
void	midi_initbuf(struct midi_buffer *);
void	midi_timeout(void *);
d89 1
a89 1
int	midiprobe(struct device *, void *, void *);
d91 1
a91 1
int	midiprobe(struct device *, struct cfdata *, void *);
d93 1
a93 1
void	midiattach(struct device *, struct device *, void *);
d314 1
a314 1
		extern void midiseq_in(struct midi_dev *,u_char *,int);
d749 1
a749 1
int	midiprint(void *, const char *);
@


1.3.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d698 1
a698 1
midipoll(dev, events, p)
d700 1
a700 1
	int events;
d705 1
a705 1
	int revents = 0, s = splaudio();
d707 1
a707 1
	DPRINTF(("midipoll: %p events=0x%x\n", sc, events));
d709 16
a724 13
	if (events & (POLLIN | POLLRDNORM)) {
		if (sc->inbuf.used > 0)
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (sc->outbuf.used < sc->outbuf.usedhigh)
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &sc->wsel);
d728 1
a728 1
	return (revents);
@


1.2
log
@Remove unnecessary extern
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.1 1999/01/02 00:02:32 niklas Exp $	*/
d747 1
a747 1
int	audioprint __P((void *, const char *));
d766 11
a776 1
	(void)config_found(dev, &arg, audioprint);
@


1.1
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: midi.c,v 1.10 1998/12/20 14:26:44 drochner Exp $	*/
a111 2

extern struct cfdriver midi_cd;
@

