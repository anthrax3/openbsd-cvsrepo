head	1.8;
access;
symbols
	OPENBSD_5_5:1.7.0.18
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.14
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.12
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.10
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.7;
commitid	0n9cIGBISFAEt4b1;

1.7
date	2010.08.05.13.13.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.31.16.04.50;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.24.21.46.19;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.01.17.06.26;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.27.16.52.24;	author gwk;	state Exp;
branches;
next	;


desc
@@


1.8
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: btkbd.c,v 1.7 2010/08/05 13:13:17 miod Exp $	*/
/*	$NetBSD: btkbd.c,v 1.10 2008/09/09 03:54:56 cube Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Written by Iain Hibbert for Itronix Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <netbt/bluetooth.h>

#include <dev/bluetooth/bthid.h>
#include <dev/bluetooth/bthidev.h>

#include <dev/usb/hid.h>
#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>

#include <dev/usb/hidkbdsc.h>
#include <dev/usb/hidkbdvar.h>

struct btkbd_softc {
	struct bthidev		 sc_hidev;	/* device */
	struct hidkbd		 sc_kbd;	/* keyboard state */
	int			(*sc_output)	/* output method */
				(struct bthidev *, uint8_t *, int, int);
	int			 sc_inintr;
};

/* autoconf(9) methods */
int	btkbd_match(struct device *, void *, void *);
void	btkbd_attach(struct device *, struct device *, void *);
int	btkbd_detach(struct device *, int);

struct cfdriver btkbd_cd = {
	NULL, "btkbd", DV_DULL
};

const struct cfattach btkbd_ca = {
	sizeof(struct btkbd_softc),
	btkbd_match,
	btkbd_attach,
	btkbd_detach,
	/* XXX activate */
};

/* wskbd(4) accessops */
int	btkbd_enable(void *, int);
void	btkbd_set_leds(void *, int);
int	btkbd_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wskbd_accessops btkbd_accessops = {
	btkbd_enable,
	btkbd_set_leds,
	btkbd_ioctl
};

/* bthid methods */
void	btkbd_input(struct bthidev *, uint8_t *, int);

int
btkbd_match(struct device *self, void *match, void *aux)
{
	struct bthidev_attach_args *ba = aux;

	if (hid_is_collection(ba->ba_desc, ba->ba_dlen, ba->ba_id,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
		return 1;

	return 0;
}

void
btkbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;
	struct bthidev_attach_args *ba = aux;
	kbd_t layout;

	sc->sc_output = ba->ba_output;
	ba->ba_input = btkbd_input;			/* XXX ugly */

	if (hidkbd_attach(self, kbd, 0, 0,
	    ba->ba_id, ba->ba_desc, ba->ba_dlen) != 0)
		return;

	printf("\n");

#if defined(BTKBD_LAYOUT)
	layout = BTKBD_LAYOUT;
#else
	layout = KB_US;
#endif
	hidkbd_attach_wskbd(kbd, layout, &btkbd_accessops);
}

int
btkbd_detach(struct device *self, int flags)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;

	return hidkbd_detach(&sc->sc_kbd, flags);
}

int
btkbd_enable(void *self, int on)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;

	return hidkbd_enable(kbd, on);
}

void
btkbd_set_leds(void *self, int leds)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;
	uint8_t report;

	if (hidkbd_set_leds(kbd, leds, &report) != 0) {
		if (sc->sc_output != NULL)
			(*sc->sc_output)(&sc->sc_hidev, &report,
			    sizeof(report), sc->sc_inintr);
	}
}

int
btkbd_ioctl(void *self, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;

	switch (cmd) {
	case WSKBDIO_GTYPE:
		*(int *)data = WSKBD_TYPE_BLUETOOTH;
		return 0;
	case WSKBDIO_SETLEDS:
		btkbd_set_leds(sc, *(int *)data);
		return 0;
	default:
		return hidkbd_ioctl(kbd, cmd, data, flag, p);
	}
}

void
btkbd_input(struct bthidev *self, uint8_t *data, int len)
{
	struct btkbd_softc *sc = (struct btkbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;

	if (kbd->sc_enabled != 0) {
		sc->sc_inintr = 1;
		hidkbd_input(kbd, data, len);
		sc->sc_inintr = 0;
	}
}
@


1.7
log
@Allow bthidev_output() to not grab the bt lock, to prevent lock
recursion when trying to send commands from input callbacks. Makes the
caps/num/scroll lock keys on btkbd correctly lit the leds instead of
panic'ing.
Noticed and fix tested by mlarkin@@, "do whatever you want in bt" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: btkbd.c,v 1.6 2010/07/31 16:04:50 miod Exp $	*/
@


1.6
log
@Factorization of the bluetooth and usb hid input driver logic, to reduce code
duplication and divergence.
Thanks to mlarkin@@ for bluetooth devices tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: btkbd.c,v 1.5 2009/01/21 21:53:59 grange Exp $	*/
d93 2
a94 1
				(struct bthidev *, uint8_t *, int);
d192 1
a192 1
			    sizeof(report));
d220 2
a221 1
	if (kbd->sc_enabled != 0)
d223 2
@


1.5
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: btkbd.c,v 1.4 2008/11/22 04:42:58 uwe Exp $	*/
a64 4
/*
 * based on dev/usb/ukbd.c
 */

d86 2
a87 13
#define	MAXKEYCODE		6
#define MAXMOD			8	/* max 32 */
#define MAXKEYS			(MAXMOD + (2 * MAXKEYCODE))

struct btkbd_data {
	uint32_t		modifiers;
	uint8_t			keycode[MAXKEYCODE];
};

struct btkbd_mod {
	uint32_t		mask;
	uint8_t			key;
};
d90 2
a91 4
	struct bthidev		 sc_hidev;	/* device+ */
	struct device		*sc_wskbd;	/* child */
	int			 sc_enabled;

a93 27

	/* stored data */
	struct btkbd_data	 sc_odata;
	struct btkbd_data	 sc_ndata;

	/* input reports */
	int			 sc_nmod;
	struct hid_location	 sc_modloc[MAXMOD];
	struct btkbd_mod	 sc_mods[MAXMOD];

	int			 sc_nkeycode;
	struct hid_location	 sc_keycodeloc;

	/* output reports */
	struct hid_location	 sc_numloc;
	struct hid_location	 sc_capsloc;
	struct hid_location	 sc_scroloc;
	int			 sc_leds;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	int			 sc_rawkbd;
#ifdef BTKBD_REPEAT
	struct timeout		 sc_repeat;
	int			 sc_nrep;
	char			 sc_rep[MAXKEYS];
#endif
#endif
d110 1
a123 14
/* wskbd(4) keymap data */
extern const struct wscons_keydesc ukbd_keydesctab[];

const struct wskbd_mapdata btkbd_keymapdata = {
	ukbd_keydesctab,
#if defined(BTKBD_LAYOUT)
	BTKBD_LAYOUT,
#elif defined(PCKBD_LAYOUT)
	PCKBD_LAYOUT,
#else
	KB_US,
#endif
};

d125 1
a125 11
void btkbd_input(struct bthidev *, uint8_t *, int);

/* internal prototypes */
const char *btkbd_parse_desc(struct btkbd_softc *, int, void *, int);

#ifdef WSDISPLAY_COMPAT_RAWKBD
#ifdef BTKBD_REPEAT
void btkbd_repeat(void *);
#endif
#endif

d143 1
d145 1
a145 2
	struct wskbddev_attach_args wska;
	const char *parserr;
d148 1
a148 1
	ba->ba_input = btkbd_input;
d150 2
a151 3
	parserr = btkbd_parse_desc(sc, ba->ba_id, ba->ba_desc, ba->ba_dlen);
	if (parserr != NULL) {
		printf("%s\n", parserr);
a152 1
	}
d156 4
a159 4
#ifdef WSDISPLAY_COMPAT_RAWKBD
#ifdef BTKBD_REPEAT
	timeout_set(&sc->sc_repeat, btkbd_repeat, sc);
#endif
d161 1
a161 7

	wska.console = 0;
	wska.keymap = &btkbd_keymapdata;
	wska.accessops = &btkbd_accessops;
	wska.accesscookie = sc;

	sc->sc_wskbd = config_found((struct device *)sc, &wska, wskbddevprint);
a167 1
	int err = 0;
d169 1
a169 73
#ifdef WSDISPLAY_COMPAT_RAWKBD
#ifdef BTKBD_REPEAT
	timeout_del(&sc->sc_repeat);
#endif
#endif

	if (sc->sc_wskbd != NULL) {
		err = config_detach(sc->sc_wskbd, flags);
		sc->sc_wskbd = NULL;
	}

	return err;
}

const char *
btkbd_parse_desc(struct btkbd_softc *sc, int id, void *desc, int dlen)
{
	struct hid_data *d;
	struct hid_item h;
	int imod;

	imod = 0;
	sc->sc_nkeycode = 0;
	d = hid_start_parse(desc, dlen, hid_input);
	while (hid_get_item(d, &h)) {
		if (h.kind != hid_input || (h.flags & HIO_CONST) ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_KEYBOARD ||
		    h.report_ID != id)
			continue;

		if (h.flags & HIO_VARIABLE) {
			if (h.loc.size != 1)
				return ("bad modifier size");

			/* Single item */
			if (imod < MAXMOD) {
				sc->sc_modloc[imod] = h.loc;
				sc->sc_mods[imod].mask = 1 << imod;
				sc->sc_mods[imod].key = HID_GET_USAGE(h.usage);
				imod++;
			} else
				return ("too many modifier keys");
		} else {
			/* Array */
			if (h.loc.size != 8)
				return ("key code size != 8");

			if (h.loc.count > MAXKEYCODE)
				return ("too many key codes");

			if (h.loc.pos % 8 != 0)
				return ("key codes not on byte boundary");

			if (sc->sc_nkeycode != 0)
				return ("multiple key code arrays\n");

			sc->sc_keycodeloc = h.loc;
			sc->sc_nkeycode = h.loc.count;
		}
	}
	sc->sc_nmod = imod;
	hid_end_parse(d);

	hid_locate(desc, dlen, HID_USAGE2(HUP_LEDS, HUD_LED_NUM_LOCK),
	    id, hid_output, &sc->sc_numloc, NULL);

	hid_locate(desc, dlen, HID_USAGE2(HUP_LEDS, HUD_LED_CAPS_LOCK),
	    id, hid_output, &sc->sc_capsloc, NULL);

	hid_locate(desc, dlen, HID_USAGE2(HUP_LEDS, HUD_LED_SCROLL_LOCK),
	    id, hid_output, &sc->sc_scroloc, NULL);

	return (NULL);
d176 1
d178 1
a178 2
	sc->sc_enabled = on;
	return 0;
d185 1
d188 5
a192 22
	if (sc->sc_leds == leds)
		return;

	sc->sc_leds = leds;

	/*
	 * This is not totally correct, since we did not check the
	 * report size from the descriptor but for keyboards it should
	 * just be a single byte with the relevant bits set.
	 */
	report = 0;
	if ((leds & WSKBD_LED_SCROLL) && sc->sc_scroloc.size == 1)
		report |= 1 << sc->sc_scroloc.pos;

	if ((leds & WSKBD_LED_NUM) && sc->sc_numloc.size == 1)
		report |= 1 << sc->sc_numloc.pos;

	if ((leds & WSKBD_LED_CAPS) && sc->sc_capsloc.size == 1)
		report |= 1 << sc->sc_capsloc.pos;

	if (sc->sc_output)
		(*sc->sc_output)(&sc->sc_hidev, &report, sizeof(report));
d199 1
a204 1

d208 2
a209 13

	case WSKBDIO_GETLEDS:
		*(int *)data = sc->sc_leds;
		return 0;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
		sc->sc_rawkbd = (*(int *)data == WSKBD_RAW);
#ifdef BTKBD_REPEAT
		timeout_del(&sc->sc_repeat);
#endif
		return 0;
#endif
a210 1
	return -1;
a212 52
#ifdef WSDISPLAY_COMPAT_RAWKBD
#define NN 0			/* no translation */
/*
 * Translate USB keycodes to US keyboard XT scancodes.
 * Scancodes >= 0x80 represent EXTENDED keycodes.
 *
 * See http://www.microsoft.com/HWDEV/TECH/input/Scancode.asp
 */
const u_int8_t btkbd_trtab[256] = {
      NN,   NN,   NN,   NN, 0x1e, 0x30, 0x2e, 0x20, /* 00 - 07 */
    0x12, 0x21, 0x22, 0x23, 0x17, 0x24, 0x25, 0x26, /* 08 - 0f */
    0x32, 0x31, 0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, /* 10 - 17 */
    0x16, 0x2f, 0x11, 0x2d, 0x15, 0x2c, 0x02, 0x03, /* 18 - 1f */
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, /* 20 - 27 */
    0x1c, 0x01, 0x0e, 0x0f, 0x39, 0x0c, 0x0d, 0x1a, /* 28 - 2f */
    0x1b, 0x2b, 0x2b, 0x27, 0x28, 0x29, 0x33, 0x34, /* 30 - 37 */
    0x35, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, /* 38 - 3f */
    0x41, 0x42, 0x43, 0x44, 0x57, 0x58, 0xaa, 0x46, /* 40 - 47 */
    0x7f, 0xd2, 0xc7, 0xc9, 0xd3, 0xcf, 0xd1, 0xcd, /* 48 - 4f */
    0xcb, 0xd0, 0xc8, 0x45, 0xb5, 0x37, 0x4a, 0x4e, /* 50 - 57 */
    0x9c, 0x4f, 0x50, 0x51, 0x4b, 0x4c, 0x4d, 0x47, /* 58 - 5f */
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd,   NN, 0x59, /* 60 - 67 */
    0x5d, 0x5e, 0x5f,   NN,   NN,   NN,   NN,   NN, /* 68 - 6f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 70 - 77 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 78 - 7f */
      NN,   NN,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
    0x70, 0x7d, 0x79, 0x7b, 0x5c,   NN,   NN,   NN, /* 88 - 8f */
      NN,   NN, 0x78, 0x77, 0x76,   NN,   NN,   NN, /* 90 - 97 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 98 - 9f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a0 - a7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a8 - af */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b0 - b7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b8 - bf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c0 - c7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c8 - cf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d0 - d7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d8 - df */
    0x1d, 0x2a, 0x38, 0xdb, 0x9d, 0x36, 0xb8, 0xdc, /* e0 - e7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* e8 - ef */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f0 - f7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f8 - ff */
};
#endif

#define KEY_ERROR	0x01
#define PRESS		0x000
#define RELEASE		0x100
#define CODEMASK	0x0ff
#define ADDKEY(c)	ibuf[nkeys++] = (c)
#define REP_DELAY1	400
#define REP_DELAYN	100

d217 1
a217 9
	struct btkbd_data *ud = &sc->sc_ndata;
	uint16_t ibuf[MAXKEYS];
	uint32_t mod, omod;
	int nkeys, i, j;
	int key;
	int s;

	if (sc->sc_wskbd == NULL || sc->sc_enabled == 0)
		return;
d219 2
a220 128
	/* extract key modifiers */
	ud->modifiers = 0;
	for (i = 0 ; i < sc->sc_nmod ; i++)
		if (hid_get_data(data, &sc->sc_modloc[i]))
			ud->modifiers |= sc->sc_mods[i].mask;

	/* extract keycodes */
	memcpy(ud->keycode, data + (sc->sc_keycodeloc.pos / 8),
	    sc->sc_nkeycode);

	if (ud->keycode[0] == KEY_ERROR)
		return;		/* ignore  */

	nkeys = 0;
	mod = ud->modifiers;
	omod = sc->sc_odata.modifiers;
	if (mod != omod)
		for (i = 0 ; i < sc->sc_nmod ; i++)
			if ((mod & sc->sc_mods[i].mask) !=
			    (omod & sc->sc_mods[i].mask))
				ADDKEY(sc->sc_mods[i].key |
				    (mod & sc->sc_mods[i].mask
				    ? PRESS : RELEASE));

	if (memcmp(ud->keycode, sc->sc_odata.keycode, sc->sc_nkeycode) != 0) {
		/* Check for released keys. */
		for (i = 0 ; i < sc->sc_nkeycode ; i++) {
			key = sc->sc_odata.keycode[i];
			if (key == 0)
				continue;

			for (j = 0 ; j < sc->sc_nkeycode ; j++)
				if (key == ud->keycode[j])
					goto rfound;

			ADDKEY(key | RELEASE);

		rfound:
			;
		}

		/* Check for pressed keys. */
		for (i = 0 ; i < sc->sc_nkeycode ; i++) {
			key = ud->keycode[i];
			if (key == 0)
				continue;

			for (j = 0; j < sc->sc_nkeycode; j++)
				if (key == sc->sc_odata.keycode[j])
					goto pfound;

			ADDKEY(key | PRESS);
		pfound:
			;
		}
	}
	sc->sc_odata = *ud;

	if (nkeys == 0)
		return;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (sc->sc_rawkbd) {
		u_char cbuf[MAXKEYS * 2];
		int c;
		int npress;

		for (npress = i = j = 0 ; i < nkeys ; i++) {
			key = ibuf[i];
			c = btkbd_trtab[key & CODEMASK];
			if (c == NN)
				continue;

			if (c & 0x80)
				cbuf[j++] = 0xe0;

			cbuf[j] = c & 0x7f;
			if (key & RELEASE)
				cbuf[j] |= 0x80;
#ifdef BTKBD_REPEAT
			else {
				/* remember pressed keys for autorepeat */
				if (c & 0x80)
					sc->sc_rep[npress++] = 0xe0;

				sc->sc_rep[npress++] = c & 0x7f;
			}
#endif

			j++;
		}

		s = spltty();
		wskbd_rawinput(sc->sc_wskbd, cbuf, j);
		splx(s);
#ifdef BTKBD_REPEAT
		timeout_del(&sc->sc_repeat);
		if (npress != 0) {
			sc->sc_nrep = npress;
			timeout_add_msec(&sc->sc_repeat, REP_DELAY1);
		}
#endif
		return;
	}
#endif

	s = spltty();
	for (i = 0 ; i < nkeys ; i++) {
		key = ibuf[i];
		wskbd_input(sc->sc_wskbd,
		    key & RELEASE ? WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN,
		    key & CODEMASK);
	}
	splx(s);
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
#ifdef BTKBD_REPEAT
void
btkbd_repeat(void *arg)
{
	struct btkbd_softc *sc = arg;
	int s;

	s = spltty();
	wskbd_rawinput(sc->sc_wskbd, sc->sc_rep, sc->sc_nrep);
	splx(s);
	timeout_add_msec(&sc->sc_repeat, REP_DELAYN);
a221 2
#endif
#endif
@


1.4
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: btkbd.c,v 1.3 2008/02/24 21:46:19 uwe Exp $	*/
d554 1
a554 1
			timeout_add(&sc->sc_repeat, hz * REP_DELAY1 / 1000);
d582 1
a582 1
	timeout_add(&sc->sc_repeat, hz * REP_DELAYN / 1000);
@


1.3
log
@Sync Bluetooth HID drivers with NetBSD and adopt to our needs, as we
don't have problib
@
text
@d1 32
a32 2
/*	$OpenBSD: btkbd.c,v 1.2 2007/09/01 17:06:26 xsa Exp $	*/
/*	$NetBSD: btkbd.c,v 1.9 2007/11/03 18:24:01 plunky Exp $	*/
@


1.2
log
@- Add bthidev(4), from NetBSD.
- Make btms(4) and btkbd(4) compile.
- Removed remaining proplib NetBSD'sim

Prodded a while ago by gwk@@. Eyeballed by miod@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: btkbd.c,v 1.1 2007/07/27 16:52:24 gwk Exp $	*/
/*	$NetBSD: btkbd.c,v 1.7 2007/07/09 21:00:31 ad Exp $	*/
d110 1
d126 1
d197 1
a197 2
	timeout_set(&sc->sc_repeat, NULL, NULL);
	/* callout_setfunc(&sc->sc_repeat, btkbd_repeat, sc); */
a523 2
			timeout_del(&sc->sc_repeat);
			timeout_set(&sc->sc_repeat, btkbd_repeat, sc);
a551 2
	timeout_del(&sc->sc_repeat);
	timeout_set(&sc->sc_repeat, btkbd_repeat, sc);
@


1.1
log
@Commiting for xsa@@ who dosent want to for some reason. He has KNFed and
de-proplibed some of the netbsd bluetooth drives for HID devices
(mice and keyboards) they will however NOT BUILD YET as they lack the
glue device bthidev and our replacement for the problib.

no objections from uwe
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d110 1
a110 1
int	btkbd_match(struct device *, struct cfdata *, void *);
d127 1
a127 1
int	btkbd_ioctl(void *, unsigned long, void *, int, struct lwp *);
d153 1
a153 1
const char *btkbd_parse_desc(struct btkbd_softc *, int, const void *, int);
d163 1
a163 1
btkbd_match(struct device *self, struct cfdata *cfdata, void *aux)
d229 1
a229 1
btkbd_parse_desc(struct btkbd_softc *sc, int id, const void *desc, int dlen)
d329 1
a329 1
btkbd_ioctl(void *self, unsigned long cmd, void *data, int flag, struct lwp *l)
d336 1
a336 1
		break;
d340 1
a340 1
		break;
d344 1
a344 1
		break;
d352 1
a352 1
		break;
a353 3

	default:
		return EPASSTHROUGH;
d355 1
a355 2

	return 0;
@

