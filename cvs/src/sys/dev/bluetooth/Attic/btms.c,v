head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.14
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.6;
commitid	0n9cIGBISFAEt4b1;

1.6
date	2011.03.04.23.57.52;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.31.16.04.50;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.24.21.46.19;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.01.17.06.26;	author xsa;	state Exp;
branches;
next	1.1;

1.1
date	2007.07.27.16.52.24;	author gwk;	state Exp;
branches;
next	;


desc
@@


1.7
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: btms.c,v 1.6 2011/03/04 23:57:52 kettenis Exp $	*/
/*	$NetBSD: btms.c,v 1.8 2008/09/09 03:54:56 cube Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Written by Iain Hibbert for Itronix Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <netbt/bluetooth.h>

#include <dev/bluetooth/bthid.h>
#include <dev/bluetooth/bthidev.h>

#include <dev/usb/hid.h>
#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#include <dev/usb/hidmsvar.h>

struct btms_softc {
	struct bthidev		sc_hidev;
	struct hidms		sc_ms;
};

/* autoconf(9) methods */
int	btms_match(struct device *, void *, void *);
void	btms_attach(struct device *, struct device *, void *);
int	btms_detach(struct device *, int);

struct cfdriver btms_cd = {
	NULL, "btms", DV_DULL
};

const struct cfattach btms_ca = {
	sizeof(struct btms_softc),
	btms_match,
	btms_attach,
	btms_detach,
	/* XXX activate */
};

/* wsmouse(4) accessops */
int	btms_wsmouse_enable(void *);
int	btms_wsmouse_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	btms_wsmouse_disable(void *);

const struct wsmouse_accessops btms_wsmouse_accessops = {
	btms_wsmouse_enable,
	btms_wsmouse_ioctl,
	btms_wsmouse_disable,
};

/* bthid methods */
void	btms_input(struct bthidev *, uint8_t *, int);


int
btms_match(struct device *parent, void *match, void *aux)
{
	struct bthidev_attach_args *ba = aux;

	if (hid_is_collection(ba->ba_desc, ba->ba_dlen, ba->ba_id,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		return 1;

	return 0;
}

void
btms_attach(struct device *parent, struct device *self, void *aux)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;
	struct bthidev_attach_args *ba = aux;

	ba->ba_input = btms_input;			/* XXX ugly */

	if (hidms_setup(self, ms, 0, ba->ba_id, ba->ba_desc, ba->ba_dlen) != 0)
		return;

	hidms_attach(ms, &btms_wsmouse_accessops);
}

int
btms_detach(struct device *self, int flags)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;

	return hidms_detach(ms, flags);
}

int
btms_wsmouse_enable(void *self)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;

	return hidms_enable(ms);
}

int
btms_wsmouse_ioctl(void *self, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;
	int rc;

	rc = hidms_ioctl(ms, cmd, data, flag, p);
	if (rc != -1)
		return rc;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_BLUETOOTH;
		return 0;
	default:
		return -1;
	}
}

void
btms_wsmouse_disable(void *self)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;

	hidms_disable(ms);
}

void
btms_input(struct bthidev *self, uint8_t *data, int len)
{
	struct btms_softc *sc = (struct btms_softc *)self;
	struct hidms *ms = &sc->sc_ms;

	if (ms->sc_enabled != 0)
		hidms_input(ms, data, len);
}
@


1.6
log
@Add TouchScreen support.  Makes newer Gunze USB TouchScreen devices work.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: btms.c,v 1.5 2010/07/31 16:04:50 miod Exp $	*/
@


1.5
log
@Factorization of the bluetooth and usb hid input driver logic, to reduce code
duplication and divergence.
Thanks to mlarkin@@ for bluetooth devices tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: btms.c,v 1.4 2008/11/22 04:42:58 uwe Exp $	*/
d173 5
d184 1
a184 1
		return hidms_ioctl(ms, cmd, data, flag, p);
@


1.4
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: btms.c,v 1.3 2008/02/24 21:46:19 uwe Exp $	*/
a64 4
/*
 * based on dev/usb/ums.c
 */

d83 1
a83 3
#define MAX_BUTTONS	31
#define BUTTON(n)	(1 << (((n) == 1 || (n) == 2) ? 3 - (n) : (n)))
#define NOTMOUSE(f)	(((f) & (HIO_CONST | HIO_RELATIVE)) != HIO_RELATIVE)
d86 2
a87 15
	struct bthidev		 sc_hidev;	/* device+ */

	struct device		*sc_wsmouse;	/* child */
	int			 sc_enabled;
	uint16_t		 sc_flags;

	/* locators */
	struct hid_location	 sc_loc_x;
	struct hid_location	 sc_loc_y;
	struct hid_location	 sc_loc_z;
	struct hid_location	 sc_loc_w;
	struct hid_location	 sc_loc_button[MAX_BUTTONS];

	int			 sc_num_buttons;
	uint32_t		 sc_buttons;
a89 5
/* sc_flags */
#define BTMS_REVZ		(1 << 0)	/* reverse Z direction */
#define BTMS_HASZ		(1 << 1)	/* has Z direction */
#define BTMS_HASW		(1 << 2)	/* has W direction */

d104 1
d138 1
a139 15
	struct wsmousedev_attach_args wsma;
	struct hid_location *zloc;
	uint32_t flags;
	int i, hl;

	ba->ba_input = btms_input;

	/* control the horizontal */
	hl = hid_locate(ba->ba_desc, ba->ba_dlen,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X), ba->ba_id, hid_input,
	    &sc->sc_loc_x, &flags);

	if (hl == 0 || NOTMOUSE(flags)) {
		printf("\n%s: X report 0x%04x not supported\n",
		    sc->sc_hidev.sc_dev.dv_xname, flags);
d141 1
a141 11
		return;
	}

	/* control the vertical */
	hl = hid_locate(ba->ba_desc, ba->ba_dlen,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y), ba->ba_id, hid_input,
	    &sc->sc_loc_y, &flags);

	if (hl == 0 || NOTMOUSE(flags)) {
		printf("\n%s: Y report 0x%04x not supported\n",
		    sc->sc_hidev.sc_dev.dv_xname, flags);
d143 1
a144 59
	}

	/* Try the wheel first as the Z activator since it's tradition. */
	hl = hid_locate(ba->ba_desc, ba->ba_dlen,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_WHEEL), ba->ba_id, hid_input,
	    &sc->sc_loc_z, &flags);

	zloc = &sc->sc_loc_z;
	if (hl) {
		if (NOTMOUSE(flags)) {
			printf("\n%s: Wheel report 0x%04x ignored\n",
			    sc->sc_hidev.sc_dev.dv_xname, flags);

			/* ignore Bad Z coord */
			sc->sc_loc_z.size = 0;
		} else {
			sc->sc_flags |= BTMS_HASZ;
			/* Wheels need the Z axis reversed. */
			sc->sc_flags ^= BTMS_REVZ;
			/* Put Z on the W coordinate */
			zloc = &sc->sc_loc_w;
		}
	}

	hl = hid_locate(ba->ba_desc, ba->ba_dlen,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z), ba->ba_id, hid_input,
	    zloc, &flags);

	/*
	 * The horizontal component of the scrollball can also be given by
	 * Application Control Pan in the Consumer page, so if we didnt see
	 * any Z then check that.
	 */
	if (!hl) {
		hl = hid_locate(ba->ba_desc, ba->ba_dlen,
		    HID_USAGE2(HUP_CONSUMER, HUC_AC_PAN), ba->ba_id, hid_input,
		    zloc, &flags);
	}

	if (hl) {
		if (NOTMOUSE(flags))
			zloc->size = 0;	/* ignore Z */
		else {
			if (sc->sc_flags & BTMS_HASZ)
				sc->sc_flags |= BTMS_HASW;
			else
				sc->sc_flags |= BTMS_HASZ;
		}
	}

	for (i = 1 ; i <= MAX_BUTTONS ; i++) {
		hl = hid_locate(ba->ba_desc, ba->ba_dlen,
		    HID_USAGE2(HUP_BUTTON, i), ba->ba_id, hid_input,
		    &sc->sc_loc_button[i - 1], NULL);

		if (hl == 0)
			break;
	}
	sc->sc_num_buttons = i - 1;
d146 1
a146 11
	printf(": %d button%s%s%s%s.\n", sc->sc_num_buttons,
	    sc->sc_num_buttons == 1 ? "" : "s",
	    sc->sc_flags & BTMS_HASW ? ", W" : "",
	    sc->sc_flags & BTMS_HASZ ? " and Z dir" : "",
	    sc->sc_flags & BTMS_HASW ? "s" : "");

	wsma.accessops = &btms_wsmouse_accessops;
	wsma.accesscookie = sc;

	sc->sc_wsmouse = config_found((struct device *)sc,
	    &wsma, wsmousedevprint);
d153 1
a153 6
	int err = 0;

	if (sc->sc_wsmouse != NULL) {
		err = config_detach(sc->sc_wsmouse, flags);
		sc->sc_wsmouse = NULL;
	}
d155 1
a155 1
	return err;
d162 1
d164 1
a164 5
	if (sc->sc_enabled)
		return EBUSY;

	sc->sc_enabled = 1;
	return 0;
d171 2
a172 1
	/* struct btms_softc *sc = (struct btms_softc *)self; */
d178 2
a180 2

	return -1;
d187 1
d189 1
a189 1
	sc->sc_enabled = 0;
d196 1
a196 3
	int dx, dy, dz, dw;
	uint32_t buttons;
	int i, s;
d198 2
a199 25
	if (sc->sc_wsmouse == NULL || sc->sc_enabled == 0)
		return;

	dx =  hid_get_data(data, &sc->sc_loc_x);
	dy = -hid_get_data(data, &sc->sc_loc_y);
	dz =  hid_get_data(data, &sc->sc_loc_z);
	dw =  hid_get_data(data, &sc->sc_loc_w);

	if (sc->sc_flags & BTMS_REVZ)
		dz = -dz;

	buttons = 0;
	for (i = 0 ; i < sc->sc_num_buttons ; i++)
		if (hid_get_data(data, &sc->sc_loc_button[i]))
			buttons |= BUTTON(i);

	if (dx != 0 || dy != 0 || dz != 0 || dw != 0 ||
	    buttons != sc->sc_buttons) {
		sc->sc_buttons = buttons;

		s = spltty();
		wsmouse_input(sc->sc_wsmouse, buttons, dx, dy, dz, dw,
		    WSMOUSE_INPUT_DELTA);
		splx(s);
	}
@


1.3
log
@Sync Bluetooth HID drivers with NetBSD and adopt to our needs, as we
don't have problib
@
text
@d1 32
a32 2
/*	$OpenBSD: btms.c,v 1.2 2007/09/01 17:06:26 xsa Exp $	*/
/*	$NetBSD: btms.c,v 1.7 2007/11/03 17:41:03 plunky Exp $	*/
@


1.2
log
@- Add bthidev(4), from NetBSD.
- Make btms(4) and btkbd(4) compile.
- Removed remaining proplib NetBSD'sim

Prodded a while ago by gwk@@. Eyeballed by miod@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: btms.c,v 1.1 2007/07/27 16:52:24 gwk Exp $	*/
/*	$NetBSD: btms.c,v 1.6 2007/03/04 06:01:45 christos Exp $	*/
d84 1
d101 8
a108 8
int	btms_enable(void *);
int	btms_ioctl(void *, u_long, caddr_t, int, struct proc *);
void	btms_disable(void *);

const struct wsmouse_accessops btms_accessops = {
	btms_enable,
	btms_ioctl,
	btms_disable,
d171 1
a171 1
			printf("\n%s: Wheel report 0x%04x not supported\n",
d227 1
a227 1
	wsma.accessops = &btms_accessops;
d249 1
a249 1
btms_enable(void *self)
d261 2
a262 1
btms_ioctl(void *self, u_long cmd, caddr_t data, int flag, struct proc *p)
d276 1
a276 1
btms_disable(void *self)
@


1.1
log
@Commiting for xsa@@ who dosent want to for some reason. He has KNFed and
de-proplibed some of the netbsd bluetooth drives for HID devices
(mice and keyboards) they will however NOT BUILD YET as they lack the
glue device bthidev and our replacement for the problib.

no objections from uwe
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
int	btms_match(struct device *, struct cfdata *, void *);
d101 1
a101 1
int	btms_ioctl(void *, unsigned long, void *, int, struct lwp *);
d111 1
a111 1
void btms_input(struct bthidev *, uint8_t *, int);
d115 1
a115 1
btms_match(struct device *parent, struct cfdata *match, void *aux)
d260 1
a260 1
btms_ioctl(void *self, unsigned long cmd, void *data, int flag, struct lwp *l)
d266 2
a267 5
		*(uint *)data = WSMOUSE_TYPE_BLUETOOTH;
		break;

	default:
		return EPASSTHROUGH;
d270 1
a270 1
	return 0;
@

