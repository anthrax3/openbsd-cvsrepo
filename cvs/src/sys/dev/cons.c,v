head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.16
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.14
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.10
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.18.0.10
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.12
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.12
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.10
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.8
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.10.0.6
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.7.0.20
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.18
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.16
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.14
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.12
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.10
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.8
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.6
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.05.17.23.43.47;	author bluhm;	state Exp;
branches;
next	1.25;
commitid	FQUHD8bvWBEOY9mu;

1.25
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.23;
commitid	uzzBR7hz9ncd4O6G;

1.23
date	2011.07.04.16.52.41;	author nicm;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.19.21.53.36;	author chl;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.09.15.44.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.17.18.50.58;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.01.03.37.23;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.31.21.22.34;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.30.18.11.25;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.16.18.44.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.17.04.30.49;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.01.20.54.32;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.09.20.48.24;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.19.48;	author deraadt;	state Exp;
branches
	1.7.16.1;
next	1.6;

1.6
date	96.04.18.04.05.39;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.30.02.03.43;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.02.00.29.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.27.09.43.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.10.16;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.7.16.1
date	2001.05.14.22.23.00;	author niklas;	state Exp;
branches;
next	1.7.16.2;

1.7.16.2
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.7.16.3;

1.7.16.3
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Allow sendsyslog(2) with LOG_CONS even when /dev/console has not
been opened during init(8).  Only log with cnwrite() if cn_devvp
exists, otherwise use cnputc() as fallback.  While there move extern
declarations to dev/cons.h.
input and OK deraadt@@
@
text
@/*	$OpenBSD: cons.c,v 1.25 2015/03/14 03:38:46 jsg Exp $	*/
/*	$NetBSD: cons.c,v 1.30 1996/04/08 19:57:30 jonathan Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: cons.c 1.7 92/01/21$
 *
 *	@@(#)cons.c	8.2 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/vnode.h>
#include <sys/poll.h>

#include <dev/cons.h>

struct	tty *constty = NULL;		/* virtual console output device */
struct	vnode *cn_devvp = NULLVP;	/* vnode for underlying device. */

int
cnopen(dev_t dev, int flag, int mode, struct proc *p)
{
	dev_t cndev;

	if (cn_tab == NULL)
		return (0);

	/*
	 * always open the 'real' console device, so we don't get nailed
	 * later.  This follows normal device semantics; they always get
	 * open() calls.
	 */
	cndev = cn_tab->cn_dev;
	if (cndev == NODEV)
		return (ENXIO);
#ifdef DIAGNOSTIC
	if (cndev == dev)
		panic("cnopen: recursive");
#endif
	if (cn_devvp == NULLVP) {
		/* try to get a reference on its vnode, but fail silently */
		cdevvp(cndev, &cn_devvp);
	}
	return ((*cdevsw[major(cndev)].d_open)(cndev, flag, mode, p));
}
 
int
cnclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct vnode *vp;

	if (cn_tab == NULL)
		return (0);

	/*
	 * If the real console isn't otherwise open, close it.
	 * If it's otherwise open, don't close it, because that'll
	 * screw up others who have it open.
	 */
	dev = cn_tab->cn_dev;
	if (cn_devvp != NULLVP) {
		/* release our reference to real dev's vnode */
		vrele(cn_devvp);
		cn_devvp = NULLVP;
	}
	if (vfinddev(dev, VCHR, &vp) && vcount(vp))
		return (0);
	return ((*cdevsw[major(dev)].d_close)(dev, flag, mode, p));
}
 
int
cnread(dev_t dev, struct uio *uio, int flag)
{

	/*
	 * If we would redirect input, punt.  This will keep strange
	 * things from happening to people who are using the real
	 * console.  Nothing should be using /dev/console for
	 * input (except a shell in single-user mode, but then,
	 * one wouldn't TIOCCONS then).
	 */
	if (constty != NULL)
		return 0;
	else if (cn_tab == NULL)
		return ENXIO;

	dev = cn_tab->cn_dev;
	return ((*cdevsw[major(dev)].d_read)(dev, uio, flag));
}
 
int
cnwrite(dev_t dev, struct uio *uio, int flag)
{

	/*
	 * Redirect output, if that's appropriate.
	 * If there's no real console, return ENXIO.
	 */
	if (constty != NULL)
		dev = constty->t_dev;
	else if (cn_tab == NULL)
		return ENXIO;
	else
		dev = cn_tab->cn_dev;
	return ((*cdevsw[major(dev)].d_write)(dev, uio, flag));
}

int
cnstop(struct tty *tp, int flag)
{
	return (0);
}
 
int
cnioctl(dev_t dev, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	int error;

	/*
	 * Superuser can always use this to wrest control of console
	 * output from the "virtual" console.
	 */
	if (cmd == TIOCCONS && constty != NULL) {
		error = suser(p, SUSER_NOACCT);
		if (error)
			return (error);
		constty = NULL;
		return (0);
	}

	/*
	 * Redirect the ioctl, if that's appropriate.
	 * Note that strange things can happen, if a program does
	 * ioctls on /dev/console, then the console is redirected
	 * out from under it.
	 */
	if (constty != NULL)
		dev = constty->t_dev;
	else if (cn_tab == NULL)
		return ENXIO;
	else
		dev = cn_tab->cn_dev;
	return ((*cdevsw[major(dev)].d_ioctl)(dev, cmd, data, flag, p));
}

/*ARGSUSED*/
int
cnpoll(dev_t dev, int rw, struct proc *p)
{

	/*
	 * Redirect the poll, if that's appropriate.
	 * I don't want to think of the possible side effects
	 * of console redirection here.
	 */
	if (constty != NULL)
		dev = constty->t_dev;
	else if (cn_tab == NULL)
		return POLLERR;
	else
		dev = cn_tab->cn_dev;
	return (ttpoll(dev, rw, p));
}


int
cnkqfilter(dev_t dev, struct knote *kn)
{

	/*
	 * Redirect output, if that's appropriate.
	 * If there's no real console, return 1.
	 */
	if (constty != NULL)
		dev = constty->t_dev;
	else if (cn_tab == NULL)
		return (ENXIO);
	else
		dev = cn_tab->cn_dev;
	if (cdevsw[major(dev)].d_kqfilter)
		return ((*cdevsw[major(dev)].d_kqfilter)(dev, kn));
	return (ENXIO);
}

int
cngetc(void)
{

	if (cn_tab == NULL)
		return (0);
	return ((*cn_tab->cn_getc)(cn_tab->cn_dev));
}

void
cnputc(int c)
{

	if (cn_tab == NULL)
		return;			

	if (c) {
		(*cn_tab->cn_putc)(cn_tab->cn_dev, c);
		if (c == '\n')
			(*cn_tab->cn_putc)(cn_tab->cn_dev, '\r');
	}
}

void
cnpollc(int on)
{
	static int refcount = 0;

	if (cn_tab == NULL)
		return;
	if (!on)
		--refcount;
	if (refcount == 0)
		(*cn_tab->cn_pollc)(cn_tab->cn_dev, on);
	if (on)
		++refcount;
}

void
nullcnpollc(dev_t dev, int on)
{

}

void
cnbell(u_int pitch, u_int period, u_int volume)
{
	if (cn_tab == NULL || cn_tab->cn_bell == NULL)
		return;

	(*cn_tab->cn_bell)(cn_tab->cn_dev, pitch, period, volume);
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.24 2014/09/14 14:17:24 jsg Exp $	*/
d53 2
a54 3
struct	tty *constty = NULL;	/* virtual console output device */
struct	vnode *cn_devvp;	/* vnode for underlying device. */
extern struct consdev *cn_tab;	/* physical console device info */
@


1.24
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.23 2011/07/04 16:52:41 nicm Exp $	*/
a43 1
#include <sys/buf.h>
@


1.23
log
@Nuke the useless D_KQFILTER flag and just check that d_kqfilter is
filled in. Move D_CLONE down to 0x0001 as suggested by thib.

ok deraadt thib
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.22 2011/07/02 22:20:07 nicm Exp $	*/
a43 1
#include <sys/proc.h>
@


1.22
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.21 2011/04/19 21:53:36 chl Exp $	*/
d220 1
a220 1
	if (cdevsw[major(dev)].d_flags & D_KQFILTER)
@


1.21
log
@Fix dead store. Instead of just remove it, use it properly.

Found by LLVM/Clang Static Analyzer.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.20 2010/06/26 23:24:44 guenther Exp $	*/
d217 1
a217 1
		return (1);
d222 1
a222 1
	return (1);
@


1.20
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.19 2010/06/09 15:44:17 miod Exp $	*/
d202 1
a202 1
	return (ttpoll(cn_tab->cn_dev, rw, p));
@


1.19
log
@Move declaration of cn_tab from dev/cons.c to dev/cninit.c, or appropriate
md files for ports which do not use dev/cninit.c. This gets rid of a common
at kernel link time.
feedback drahn@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.18 2007/06/17 18:50:58 jasper Exp $	*/
a44 1
#include <sys/user.h>
@


1.18
log
@ansify/de-register

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.17 2006/11/01 03:37:23 tedu Exp $	*/
a56 1
struct	consdev *cn_tab;	/* physical console device info */
d58 1
@


1.17
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.16 2005/12/31 21:22:34 miod Exp $	*/
d61 1
a61 4
cnopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d88 1
a88 4
cnclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d112 1
a112 4
cnread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d132 1
a132 4
cnwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d149 1
a149 3
cnstop(tp, flag)
	struct tty *tp;
	int flag;
d155 2
a156 6
cnioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d189 1
a189 4
cnpoll(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
d208 1
a208 3
cnkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
d227 1
a227 1
cngetc()
d236 1
a236 2
cnputc(c)
	register int c;
d250 1
a250 2
cnpollc(on)
	int on;
d265 1
a265 3
nullcnpollc(dev, on)
	dev_t dev;
	int on;
d271 1
a271 2
cnbell(pitch, period, volume)
	u_int pitch, period, volume;
@


1.16
log
@Split the d_type field of cdevsw entries into d_type and d_flags for clarity.
Discussed with and ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.15 2005/12/30 18:11:25 miod Exp $	*/
d52 1
d221 1
a221 1
		return ENXIO;
@


1.15
log
@Stop TIOCCONS from silently doing nothing if the console device has CN_REMOTE
priority; this might have been bright 12 years ago, but this is wrong (and
does not rely upon any decent semantic). agreed krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.14 2003/09/23 16:51:12 millert Exp $	*/
d243 1
a243 1
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
@


1.14
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.13 2003/08/15 20:32:16 tedu Exp $	*/
d130 1
a130 1
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
d150 1
a150 1
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
d195 1
a195 1
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
d217 1
a217 1
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
d237 1
a237 1
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
@


1.13
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.12 2003/06/16 18:44:11 millert Exp $	*/
d206 1
a206 1
cnselect(dev, rw, p)
d213 1
a213 1
	 * Redirect the select, if that's appropriate.
d223 1
a223 1
	return (ttselect(cn_tab->cn_dev, rw, p));
@


1.12
log
@Avoid a NULL deref in cnkqfilter() for certain cases.  Modeled after
cnwrite(); closes PR 3317.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.11 2003/06/02 23:28:01 millert Exp $	*/
d182 1
a182 1
		error = suser(p->p_ucred, (u_short *) NULL);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.10 2001/04/17 04:30:49 aaron Exp $	*/
d232 5
d238 2
a239 2
		return 0;
	if (cn_tab == NULL)
d241 2
a242 2

	dev = cn_tab->cn_dev;
a304 1

@


1.10
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.9 2001/03/01 20:54:32 provos Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.8 2001/02/09 20:48:24 mickey Exp $	*/
d294 11
@


1.8
log
@check dev in cn_tab for sanity, better than pagefaulting
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.7 1996/04/21 22:19:48 deraadt Exp $	*/
d228 17
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.6 1996/04/18 04:05:39 mickey Exp $	*/
d69 1
d79 7
a85 1
	dev = cn_tab->cn_dev;
d88 1
a88 1
		cdevvp(dev, &cn_devvp);
d90 1
a90 1
	return ((*cdevsw[major(dev)].d_open)(dev, flag, mode, p));
@


1.7.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.10 2001/04/17 04:30:49 aaron Exp $	*/
a68 1
	dev_t cndev;
d78 1
a78 7
	cndev = cn_tab->cn_dev;
	if (cndev == NODEV)
		return (ENXIO);
#ifdef DIAGNOSTIC
	if (cndev == dev)
		panic("cnopen: recursive");
#endif
d81 1
a81 1
		cdevvp(cndev, &cn_devvp);
d83 1
a83 1
	return ((*cdevsw[major(cndev)].d_open)(cndev, flag, mode, p));
a222 17

int
cnkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{
	if (constty != NULL && (cn_tab == NULL || cn_tab->cn_pri != CN_REMOTE))
		return 0;
	if (cn_tab == NULL)
		return (1);

	dev = cn_tab->cn_dev;
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
		return ((*cdevsw[major(dev)].d_kqfilter)(dev, kn));
	return (1);
}

a269 11

void
cnbell(pitch, period, volume)
	u_int pitch, period, volume;
{
	if (cn_tab == NULL || cn_tab->cn_bell == NULL)
		return;

	(*cn_tab->cn_bell)(cn_tab->cn_dev, pitch, period, volume);
}

@


1.7.16.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.7.16.1 2001/05/14 22:23:00 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.16.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d182 1
a182 1
		error = suser(p, SUSER_NOACCT);
d206 1
a206 1
cnpoll(dev, rw, p)
d213 1
a213 1
	 * Redirect the poll, if that's appropriate.
d223 1
a223 1
	return (ttpoll(cn_tab->cn_dev, rw, p));
a231 5

	/*
	 * Redirect output, if that's appropriate.
	 * If there's no real console, return 1.
	 */
d233 2
a234 2
		dev = constty->t_dev;
	else if (cn_tab == NULL)
d236 2
a237 2
	else
		dev = cn_tab->cn_dev;
d300 1
@


1.6
log
@Fix includes ordering.
@
text
@d1 2
a2 2
/*	$OpenBSD: cons.c,v 1.5 1996/03/30 02:03:43 mickey Exp $	*/
/*	$NetBSD: cons.c,v 1.29 1996/02/04 02:04:08 christos Exp $	*/
d161 1
a161 1

@


1.5
log
@Add $OpenBSD$, fix comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: cons.c,v 1.4 1996/03/02 00:29:23 niklas Exp $	*/
d47 1
a49 1
#include <sys/systm.h>
@


1.4
log
@From NetBSD: sync with 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
a210 1
	 * Redirect the ioctl, if that's appropriate.
@


1.3
log
@From NetBSD: update to 960217 sources
@
text
@@


1.2
log
@from netbsd; fix definition of nullcnpollc, and add a prototype for it
@
text
@d1 2
a2 1
/*	$NetBSD: cons.c,v 1.28 1995/11/25 00:03:35 cgd Exp $	*/
d232 1
a232 1
int
d238 2
a239 1
		return 0;			/* XXX should be void */
a244 1
	return 0;				/* XXX should be void */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cons.c,v 1.27 1995/04/11 22:08:06 pk Exp $	*/
d263 2
a264 1
nullcnpollc(on)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
