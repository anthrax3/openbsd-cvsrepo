head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14;
locks; strict;
comment	@ * @;


1.18
date	2014.10.18.08.01.34;	author armani;	state Exp;
branches;
next	1.17;
commitid	cdW1SBgN6rVYvZes;

1.17
date	2011.03.26.08.13.05;	author jakemsr;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.24.11.05.02;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.13.20.29.34;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2008.07.31.15.26.25;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.13.05.00.32;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.01.27.30;	author robert;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.10.23.39.01;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.09.20.51.31;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.09.05.49.10;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.07.22.14.57;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.07.19.26.25;	author robert;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.05.20.50.28;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.30.06.37.38;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.26.17.51.18;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.25.07.47.47;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.24.19.37.34;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.09.19.49.55;	author robert;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Add VIDIOC_G_INPUT ioctl, some ports need it (at least ffmpeg)

ok ratchov@@, sthen@@, mpi@@
@
text
@/*	$OpenBSD: video_if.h,v 1.17 2011/03/26 08:13:05 jakemsr Exp $	*/
/*
 * Copyright (c) 2008 Robert Nagy <robert@@openbsd.org>
 * Copyright (c) 2008 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SYS_DEV_VIDEO_IF_H
#define _SYS_DEV_VIDEO_IF_H

/*
 * Generic interface to hardware driver
 */

#define VIDEOUNIT(x)	(minor(x))

struct video_hw_if {
	/* open hardware */
	int	(*open)(void *, int, int *, uint8_t *, void (*)(void *),
		    void *);

	/* close hardware */
	int	(*close)(void *);

	/* ioctl's */
	int	(*querycap)(void *, struct v4l2_capability *);
	int	(*enum_fmt)(void *, struct v4l2_fmtdesc *);
	int	(*enum_fsizes)(void *, struct v4l2_frmsizeenum *);
	int	(*enum_fivals)(void *, struct v4l2_frmivalenum *);
	int	(*s_fmt)(void *, struct v4l2_format *);
	int	(*g_fmt)(void *, struct v4l2_format *);
	int	(*s_parm)(void *, struct v4l2_streamparm *);
	int	(*g_parm)(void *, struct v4l2_streamparm *);
	int	(*enum_input)(void *, struct v4l2_input *);
	int	(*s_input)(void *, int);
	int	(*g_input)(void *, int *);
	int	(*reqbufs)(void *, struct v4l2_requestbuffers *);
	int	(*querybuf)(void *, struct v4l2_buffer *);
	int	(*qbuf)(void *, struct v4l2_buffer *);
	int	(*dqbuf)(void *, struct v4l2_buffer *);
	int	(*streamon)(void *, int);
	int	(*streamoff)(void *, int);
	int	(*try_fmt)(void *, struct v4l2_format *);
	int	(*queryctrl)(void *, struct v4l2_queryctrl *);
	int	(*g_ctrl)(void *, struct v4l2_control *);
	int	(*s_ctrl)(void *, struct v4l2_control *);
	caddr_t	(*mappage)(void *, off_t, int);

	/* other functions */
	int	(*get_bufsize)(void *);
	int	(*start_read)(void *);
};

struct video_attach_args {
        void	*hwif;
        void	*hdl;
};

struct device  *video_attach_mi(struct video_hw_if *, void *, struct device *);

#endif /* _SYS_DEV_VIDEO_IF_H */
@


1.17
log
@support VIDIOC_S_PARM and VIDIOC_G_PARM.  these ioctls are used for
setting and and getting the frame interval.
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.16 2008/08/24 11:05:02 mglocker Exp $	*/
d47 1
@


1.16
log
@Add support for processing unit (e.g. brightness) controls.  New V4L2
ioctls therefore are VIDIOC_QUERYCTRL, VIDIOC_G_CTRL, and VIDIOC_S_CTRL.
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.15 2008/08/13 20:29:34 mglocker Exp $	*/
d43 2
@


1.15
log
@Add VIDIOC_ENUM_FRAMESIZES ioctl.  This permits applications to query the
available formats and resolutions of a device (e.g. "luvcview -L").
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.14 2008/07/31 15:26:25 mglocker Exp $	*/
d53 2
@


1.14
log
@- Don't relay on bFormatIndex as an internal array index, since this
field is unreliable and can start with any number.  Use an own internal
array index instead.

- If the read buffer is too small, return a propper error to the calling
functions.  Just check the buffer size if we use the read(2) method since
it doesn't affect mmap(2).

Fixes kernel crashes seen with the M$ LifeCam NX-6000 and internal
(laptop) Sonix chipsets.

Tested by jcs@@ (Sonix) and myself (NX-6000).

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.13 2008/06/13 05:00:32 mglocker Exp $	*/
d39 2
@


1.13
log
@Add myself to the copyright since i fumbled around in those files, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.12 2008/06/11 01:27:30 robert Exp $	*/
d55 1
a55 1
	void	(*start_read)(void *);
@


1.12
log
@implement the VIDIOC_STREAMOFF ioctl and remove some unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.11 2008/06/10 23:39:01 robert Exp $	*/
d4 1
@


1.11
log
@add VIDIOC_QUERYCTRL to the supported ioctls
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.10 2008/06/09 20:51:31 mglocker Exp $	*/
d47 1
@


1.10
log
@Let the driver switch between read() and mmap() depending on what
the userland application wants.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.9 2008/06/09 05:49:10 robert Exp $	*/
d48 1
@


1.9
log
@Allocate the video buffer based on the maximum frame size that's reported
by the device instead of using the statically set VIDEO_BUF_SIZE.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.8 2008/06/07 22:14:57 mglocker Exp $	*/
d52 1
@


1.8
log
@Start to queue mmap frames.  Add VIDIOC_QBUF, VIDIOC_DQBUF,
VIDIOC_STREAMON for that purpose, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.7 2008/06/07 19:26:25 robert Exp $	*/
a25 1
#define VIDEO_BUF_SIZE	131072
d49 3
@


1.7
log
@double the static video buffer size, because
the current one is not going to be enough for
some cams
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.6 2008/06/05 20:50:28 mglocker Exp $	*/
d45 1
d47 1
@


1.6
log
@Add some first mmap bits.

Help by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.5 2008/05/30 06:37:38 mglocker Exp $	*/
d26 1
a26 1
#define VIDEO_BUF_SIZE	65536
@


1.5
log
@Allocate static buffer for software frame buffer and make sure to not
overflow it.
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.4 2008/05/26 17:51:18 mglocker Exp $	*/
a40 1
	int	(*reqbufs)(void *, struct v4l2_requestbuffers *);
d43 2
a44 1
	int	(*qbuf)(void *, struct v4l2_buffer *);
d47 1
@


1.4
log
@Add more ioctl's (still unfinished);  VIDIOC_ENUM_FMT, VIDIOC_ENUMINPUT,
VIDIOC_S_INPUT, VIDIOC_TRY_FMT.  Allows me at least to use a small V4L2
compatible webcam application to capture some images.
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.3 2008/05/25 07:47:47 mglocker Exp $	*/
d26 1
@


1.3
log
@Spacing.  Comments.  strncpy() -> strlcpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.2 2008/05/24 19:37:34 mglocker Exp $	*/
d37 1
d41 2
d45 1
@


1.2
log
@- Enable userland to read(2) video stream from /dev/video.
- Prepare for mmap(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: video_if.h,v 1.1 2008/04/09 19:49:55 robert Exp $	*/
d35 1
@


1.1
log
@Initial import for uvideo(4) and video(4):

uvideo(4) is a driver for USB video device class devices including webcams,
camcorders and other cameras.

video(4) is a device-independent layer that implements the V4L2 (Video for Linux Two)
API.

These drivers are *really* work in progress so don't even try to use them just yet,
because the driver still has some issues, even if it can be used to capture simple
MJPEG videos.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d29 2
a30 1
	int	(*open)(void *, int);	
@

