head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.6
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.4
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.18
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.16
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.14
	OPENBSD_5_0:1.29.0.12
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.10
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.8
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.4
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.11.0.4
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.1.0.4
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.39
date	2017.03.11.13.40.46;	author kettenis;	state Exp;
branches;
next	1.38;
commitid	Ef2OCCQXpLcmDMsB;

1.38
date	2015.07.19.06.35.18;	author yuo;	state Exp;
branches;
next	1.37;
commitid	H8QFECvMXxRlqThI;

1.37
date	2015.01.20.03.58.04;	author brad;	state Exp;
branches;
next	1.36;
commitid	P6SoQdCs6hWbCRM0;

1.36
date	2015.01.20.03.54.26;	author brad;	state Exp;
branches;
next	1.35;
commitid	8VRNsxxADnOFbDCC;

1.35
date	2015.01.20.03.26.24;	author brad;	state Exp;
branches;
next	1.34;
commitid	jXKbYXuOc8E4cWhg;

1.34
date	2014.11.24.00.13.42;	author brad;	state Exp;
branches;
next	1.33;
commitid	dG4klX8JagOtmCjj;

1.33
date	2013.12.30.22.35.29;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2013.12.30.22.25.25;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.28.03.30.41;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.05.28.09.46.06;	author mikeb;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.17.07.19.19;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.10.21.15.14;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.24.01.08.21;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.23.23.14.21;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.10.12.14.26;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2007.01.21.22.37.56;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.31.15.04.33;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.30.23.04.39;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.30.09.38.28;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.27.19.11.09;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.22.14.12.53;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.20.22.18.05;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.07.23.44.51;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.17.19.36.54;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.28.01.54.24;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.11.19.50.48;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.23.06.40.05;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.27.05.36.58;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.22.11.48.10;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.08.04.15;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.19.06.00.04;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.29.01.52.35;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.28.23.37.11;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2004.09.20.06.05.27;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.05.05.49.29;	author pvalchev;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Add support for RTL8153 devices.  Heavily based on changes made by Kevin Lo
to the FreeBSD driver.

This driver will attach instead of cdce(4), which doesn't expose a PHY and
doesn't work with my 5c20 revision of the chip.

ok jimatthew@@, jcs@@
@
text
@/*	$OpenBSD: rgephy.c,v 1.38 2015/07/19 06:35:18 yuo Exp $	*/
/*
 * Copyright (c) 2003
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: rgephy.c,v 1.5 2004/05/30 17:57:40 phk Exp $
 */

/*
 * Driver for the Realtek 8169S/8110S internal 10/100/1000 PHY.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/rgephyreg.h>

#include <dev/ic/rtl81x9reg.h>

int	rgephymatch(struct device *, void *, void *);
void	rgephyattach(struct device *, struct device *, void *);

struct cfattach rgephy_ca = { sizeof(struct mii_softc),
	rgephymatch, rgephyattach, mii_phy_detach,
};

struct cfdriver rgephy_cd = {
	NULL, "rgephy", DV_DULL
};

int	rgephy_service(struct mii_softc *, struct mii_data *, int);
void	rgephy_status(struct mii_softc *);
int	rgephy_mii_phy_auto(struct mii_softc *);
void	rgephy_reset(struct mii_softc *);
void	rgephy_loop(struct mii_softc *);
void	rgephy_load_dspcode(struct mii_softc *);

const struct mii_phy_funcs rgephy_funcs = {
	rgephy_service, rgephy_status, rgephy_reset,
};

static const struct mii_phydesc rgephys[] = {
	{ MII_OUI_REALTEK2,		MII_MODEL_xxREALTEK_RTL8169S,
	  MII_STR_xxREALTEK_RTL8169S },
	{ MII_OUI_xxREALTEK,		MII_MODEL_xxREALTEK_RTL8169S,
	  MII_STR_xxREALTEK_RTL8169S },
	{ MII_OUI_xxREALTEK,		MII_MODEL_xxREALTEK_RTL8251,
	  MII_STR_xxREALTEK_RTL8251 },

	{ 0,			0,
	  NULL },
};

int
rgephymatch(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, rgephys) != NULL)
		return (10);

	return (0);
}

void
rgephyattach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;

	mpd = mii_phy_match(ma, rgephys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &rgephy_funcs;
	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_rev = MII_REV(ma->mii_id2);
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;
	sc->mii_anegticks = MII_ANEGTICKS_GIGE;

	sc->mii_flags |= MIIF_NOISOLATE;

	sc->mii_capabilities = PHY_READ(sc, MII_BMSR) & ma->mii_capmask;

	if (sc->mii_capabilities & BMSR_EXTSTAT)
		sc->mii_extcapabilities = PHY_READ(sc, MII_EXTSR);
	if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
	    (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
		mii_phy_add_media(sc);

	PHY_RESET(sc);
}

int
rgephy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int anar, reg, speed, gig = 0;
	char *devname;

	devname = sc->mii_dev.dv_parent->dv_cfdata->cf_driver->cd_name;

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			reg = PHY_READ(sc, MII_BMCR);
			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		PHY_RESET(sc);	/* XXX hardware bug work-around */

		anar = PHY_READ(sc, MII_ANAR);
		anar &= ~(ANAR_TX_FD | ANAR_TX | ANAR_10_FD | ANAR_10);

		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			(void) rgephy_mii_phy_auto(sc);
			break;
		case IFM_1000_T:
			speed = BMCR_S1000;
			goto setit;
		case IFM_100_TX:
			speed = BMCR_S100;
			anar |= ANAR_TX_FD | ANAR_TX;
			goto setit;
		case IFM_10_T:
			speed = BMCR_S10;
			anar |= ANAR_10_FD | ANAR_10;
setit:
			rgephy_loop(sc);
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				speed |= BMCR_FDX;
				if (IFM_SUBTYPE(ife->ifm_media) == IFM_1000_T)
					gig = GTCR_ADV_1000TFDX;
				anar &= ~(ANAR_TX | ANAR_10);
			} else {
				if (IFM_SUBTYPE(ife->ifm_media) == IFM_1000_T)
					gig = GTCR_ADV_1000THDX;
				anar &=
				    ~(ANAR_TX_FD | ANAR_10_FD);
			}

			if (IFM_SUBTYPE(ife->ifm_media) == IFM_1000_T &&
			    mii->mii_media.ifm_media & IFM_ETH_MASTER)
				gig |= GTCR_MAN_MS|GTCR_ADV_MS;

			PHY_WRITE(sc, MII_100T2CR, gig);
			PHY_WRITE(sc, MII_BMCR, speed | BMCR_AUTOEN |
			  BMCR_STARTNEG);
			PHY_WRITE(sc, MII_ANAR, anar);
			break;
#if 0
		case IFM_NONE:
			PHY_WRITE(sc, MII_BMCR, BMCR_ISO|BMCR_PDOWN);
			break;
#endif
		default:
			return (EINVAL);
		}
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;

		/*
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
		 */
		if (strcmp(devname, "re") == 0 || strcmp(devname, "ure") == 0) {
			reg = PHY_READ(sc, RL_GMEDIASTAT);
			if (reg & RL_GMEDIASTAT_LINK) {
				sc->mii_ticks = 0;
				break;
			}
		} else {
			reg = PHY_READ(sc, RGEPHY_SR);
			if (reg & RGEPHY_SR_LINK) {
				sc->mii_ticks = 0;
				break;
			}
		}

		/*
	 	 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
			break;
		
		sc->mii_ticks = 0;
		rgephy_mii_phy_auto(sc);
		break;
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/*
	 * Callback if something changed. Note that we need to poke
	 * the DSP on the Realtek PHYs if the media changes.
	 *
	 */
	if (sc->mii_media_active != mii->mii_media_active || 
	    sc->mii_media_status != mii->mii_media_status ||
	    cmd == MII_MEDIACHG)
		rgephy_load_dspcode(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);

	return (0);
}

void
rgephy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	int bmsr, bmcr, gtsr;
	char *devname;

	devname = sc->mii_dev.dv_parent->dv_cfdata->cf_driver->cd_name;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	if (strcmp(devname, "re") == 0 || strcmp(devname, "ure") == 0) {
		bmsr = PHY_READ(sc, RL_GMEDIASTAT);
		if (bmsr & RL_GMEDIASTAT_LINK)
			mii->mii_media_status |= IFM_ACTIVE;
	} else {
		bmsr = PHY_READ(sc, RGEPHY_SR);
		if (bmsr & RGEPHY_SR_LINK)
			mii->mii_media_status |= IFM_ACTIVE;
	}	

	bmsr = PHY_READ(sc, MII_BMSR);

	bmcr = PHY_READ(sc, MII_BMCR);

	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}
	}

	if (strcmp(devname, "re") == 0 || strcmp(devname, "ure") == 0) {
		bmsr = PHY_READ(sc, RL_GMEDIASTAT);
		if (bmsr & RL_GMEDIASTAT_1000MBPS)
			mii->mii_media_active |= IFM_1000_T;
		else if (bmsr & RL_GMEDIASTAT_100MBPS)
			mii->mii_media_active |= IFM_100_TX;
		else if (bmsr & RL_GMEDIASTAT_10MBPS)
			mii->mii_media_active |= IFM_10_T;

		if (bmsr & RL_GMEDIASTAT_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc) |
			    IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;
	} else {
		bmsr = PHY_READ(sc, RGEPHY_SR);
		if (RGEPHY_SR_SPEED(bmsr) == RGEPHY_SR_SPEED_1000MBPS)
			mii->mii_media_active |= IFM_1000_T;
		else if (RGEPHY_SR_SPEED(bmsr) == RGEPHY_SR_SPEED_100MBPS)
			mii->mii_media_active |= IFM_100_TX;
		else if (RGEPHY_SR_SPEED(bmsr) == RGEPHY_SR_SPEED_10MBPS)
			mii->mii_media_active |= IFM_10_T;

		if (bmsr & RGEPHY_SR_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc) |
			    IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;
	}

	gtsr = PHY_READ(sc, MII_100T2SR);
	if ((IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) &&
	    gtsr & GTSR_MS_RES)
		mii->mii_media_active |= IFM_ETH_MASTER;
}


int
rgephy_mii_phy_auto(struct mii_softc *sc)
{
	int anar;

	rgephy_loop(sc);
	PHY_RESET(sc);

	anar = BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA;
	if (sc->mii_flags & MIIF_DOPAUSE)
		anar |= ANAR_FC | ANAR_X_PAUSE_ASYM;

	PHY_WRITE(sc, MII_ANAR, anar);
	DELAY(1000);
	PHY_WRITE(sc, MII_100T2CR, GTCR_ADV_1000THDX | GTCR_ADV_1000TFDX);
	DELAY(1000);
	PHY_WRITE(sc, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);
	DELAY(100);

	return (EJUSTRETURN);
}

void
rgephy_loop(struct mii_softc *sc)
{
	u_int32_t bmsr;
	int i;

	if (sc->mii_model != MII_MODEL_xxREALTEK_RTL8251 &&
	    sc->mii_rev < 2) {
		PHY_WRITE(sc, MII_BMCR, BMCR_PDOWN);
		DELAY(1000);
	}

	for (i = 0; i < 15000; i++) {
		bmsr = PHY_READ(sc, MII_BMSR);
		if (!(bmsr & BMSR_LINK))
			break;
		DELAY(10);
	}
}

#define PHY_SETBIT(x, y, z) \
	PHY_WRITE(x, y, (PHY_READ(x, y) | (z)))
#define PHY_CLRBIT(x, y, z) \
	PHY_WRITE(x, y, (PHY_READ(x, y) & ~(z)))

/*
 * Initialize Realtek PHY per the datasheet. The DSP in the PHYs of
 * existing revisions of the 8169S/8110S chips need to be tuned in
 * order to reliably negotiate a 1000Mbps link. This is only needed
 * for rev 0 and rev 1 of the PHY. Later versions work without
 * any fixups.
 */
void
rgephy_load_dspcode(struct mii_softc *sc)
{
	int val;

	if (sc->mii_model == MII_MODEL_xxREALTEK_RTL8251 ||
	    sc->mii_rev > 1)
		return;

	PHY_WRITE(sc, 31, 0x0001);
	PHY_WRITE(sc, 21, 0x1000);
	PHY_WRITE(sc, 24, 0x65C7);
	PHY_CLRBIT(sc, 4, 0x0800);
	val = PHY_READ(sc, 4) & 0xFFF;
	PHY_WRITE(sc, 4, val);
	PHY_WRITE(sc, 3, 0x00A1);
	PHY_WRITE(sc, 2, 0x0008);
	PHY_WRITE(sc, 1, 0x1020);
	PHY_WRITE(sc, 0, 0x1000);
	PHY_SETBIT(sc, 4, 0x0800);
	PHY_CLRBIT(sc, 4, 0x0800);
	val = (PHY_READ(sc, 4) & 0xFFF) | 0x7000;
	PHY_WRITE(sc, 4, val);
	PHY_WRITE(sc, 3, 0xFF41);
	PHY_WRITE(sc, 2, 0xDE60);
	PHY_WRITE(sc, 1, 0x0140);
	PHY_WRITE(sc, 0, 0x0077);
	val = (PHY_READ(sc, 4) & 0xFFF) | 0xA000;
	PHY_WRITE(sc, 4, val);
	PHY_WRITE(sc, 3, 0xDF01);
	PHY_WRITE(sc, 2, 0xDF20);
	PHY_WRITE(sc, 1, 0xFF95);
	PHY_WRITE(sc, 0, 0xFA00);
	val = (PHY_READ(sc, 4) & 0xFFF) | 0xB000;
	PHY_WRITE(sc, 4, val);
	PHY_WRITE(sc, 3, 0xFF41);
	PHY_WRITE(sc, 2, 0xDE20);
	PHY_WRITE(sc, 1, 0x0140);
	PHY_WRITE(sc, 0, 0x00BB);
	val = (PHY_READ(sc, 4) & 0xFFF) | 0xF000;
	PHY_WRITE(sc, 4, val);
	PHY_WRITE(sc, 3, 0xDF01);
	PHY_WRITE(sc, 2, 0xDF20);
	PHY_WRITE(sc, 1, 0xFF95);
	PHY_WRITE(sc, 0, 0xBF00);
	PHY_SETBIT(sc, 4, 0x0800);
	PHY_CLRBIT(sc, 4, 0x0800);
	PHY_WRITE(sc, 31, 0x0000);
	
	DELAY(40);
}

void
rgephy_reset(struct mii_softc *sc)
{
	mii_phy_reset(sc);
	DELAY(1000);
	rgephy_load_dspcode(sc);
}
@


1.38
log
@use standardized register defintion in mii.h rather than specific
driver definetion.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.37 2015/01/20 03:58:04 brad Exp $	*/
d252 1
a252 1
		if (strcmp(devname, "re") == 0) {
d308 1
a308 1
	if (strcmp(devname, "re") == 0) {
d333 1
a333 1
	if (strcmp(devname, "re") == 0) {
@


1.37
log
@And the variable too.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.36 2015/01/20 03:54:26 brad Exp $	*/
d178 2
a179 3
		anar = PHY_READ(sc, RGEPHY_MII_ANAR);
		anar &= ~(RGEPHY_ANAR_TX_FD | RGEPHY_ANAR_TX |
		    RGEPHY_ANAR_10_FD | RGEPHY_ANAR_10);
d186 1
a186 1
			speed = RGEPHY_S1000;
d189 2
a190 2
			speed = RGEPHY_S100;
			anar |= RGEPHY_ANAR_TX_FD | RGEPHY_ANAR_TX;
d193 2
a194 2
			speed = RGEPHY_S10;
			anar |= RGEPHY_ANAR_10_FD | RGEPHY_ANAR_10;
d198 1
a198 1
				speed |= RGEPHY_BMCR_FDX;
d200 2
a201 2
					gig = RGEPHY_1000CTL_AFD;
				anar &= ~(RGEPHY_ANAR_TX | RGEPHY_ANAR_10);
d204 1
a204 1
					gig = RGEPHY_1000CTL_AHD;
d206 1
a206 1
				    ~(RGEPHY_ANAR_TX_FD | RGEPHY_ANAR_10_FD);
d211 1
a211 1
				gig |= RGEPHY_1000CTL_MSE|RGEPHY_1000CTL_MSC;
d213 4
a216 4
			PHY_WRITE(sc, RGEPHY_MII_1000CTL, gig);
			PHY_WRITE(sc, RGEPHY_MII_BMCR, speed |
			    RGEPHY_BMCR_AUTOEN | RGEPHY_BMCR_STARTNEG);
			PHY_WRITE(sc, RGEPHY_MII_ANAR, anar);
d318 1
a318 1
	bmsr = PHY_READ(sc, RGEPHY_MII_BMSR);
d320 1
a320 1
	bmcr = PHY_READ(sc, RGEPHY_MII_BMCR);
d322 1
a322 1
	if (bmcr & RGEPHY_BMCR_LOOP)
d325 2
a326 2
	if (bmcr & RGEPHY_BMCR_AUTOEN) {
		if ((bmsr & RGEPHY_BMSR_ACOMP) == 0) {
d363 1
a363 1
	gtsr = PHY_READ(sc, RGEPHY_MII_1000STS);
d365 1
a365 1
	    gtsr & RGEPHY_1000STS_MSR)
d380 1
a380 1
		anar |= RGEPHY_ANAR_PC | RGEPHY_ANAR_ASP;
d382 1
a382 1
	PHY_WRITE(sc, RGEPHY_MII_ANAR, anar);
d384 1
a384 2
	PHY_WRITE(sc, RGEPHY_MII_1000CTL,
	    RGEPHY_1000CTL_AHD | RGEPHY_1000CTL_AFD);
d386 1
a386 2
	PHY_WRITE(sc, RGEPHY_MII_BMCR,
	    RGEPHY_BMCR_AUTOEN | RGEPHY_BMCR_STARTNEG);
d400 1
a400 1
		PHY_WRITE(sc, RGEPHY_MII_BMCR, RGEPHY_BMCR_PDOWN);
d405 2
a406 2
		bmsr = PHY_READ(sc, RGEPHY_MII_BMSR);
		if (!(bmsr & RGEPHY_BMSR_LINK))
@


1.36
log
@Back out a chunk of rev 1.34 that wasn't supposed to go in with the
capitalization corrections.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.35 2015/01/20 03:26:24 brad Exp $	*/
a481 2
	uint16_t reg;

@


1.35
log
@printf wasn't supposed to go in.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.34 2014/11/24 00:13:42 brad Exp $	*/
a482 10

	if (sc->mii_model == MII_MODEL_xxREALTEK_RTL8251) {
		PHY_WRITE(sc, 31, 0x0a43);
		reg = PHY_READ(sc, RGEPHY_CR);
		if ((reg & RGEPHY_CR_ALDPS) != 0) {
			reg &= ~RGEPHY_CR_ALDPS;
			PHY_WRITE(sc, RGEPHY_CR, reg);
		}
		PHY_WRITE(sc, 31, 0x0000);
	}
@


1.34
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.33 2013/12/30 22:35:29 brad Exp $	*/
a487 1
			printf("rgephy disabling ALDPS");
@


1.33
log
@Add support for newer integrated Realtek PHY.

Tested with 8168G controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.32 2013/12/30 22:25:25 brad Exp $	*/
d37 1
a37 1
 * Driver for the RealTek 8169S/8110S internal 10/100/1000 PHY.
d283 1
a283 1
	 * the DSP on the RealTek PHYs if the media changes.
d421 1
a421 1
 * Initialize RealTek PHY per the datasheet. The DSP in the PHYs of
d482 13
@


1.32
log
@Have rgephy(4) always use RL_GMEDIASTAT to retrieve the link/media status
when attached to re(4), as was done before rev 1.25 which was intended to
fix rgephy(4) with external PHY with MACs other than re(4). This is to
fix operation with some integrated PHY on re(4) where the PHY Specific
Status register does not work properly and the link cannot be established.

From FreeBSD and matches what the Linux driver does.

Tested on a number of newer re(4) with PHYs rev 2, 4 and 5 and
newer integrated PHY with the 8168G controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.31 2013/12/28 03:30:41 deraadt Exp $	*/
d90 2
d401 2
a402 1
	if (sc->mii_rev < 2) {
d432 2
a433 1
	if (sc->mii_rev > 1)
@


1.31
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.30 2013/05/28 09:46:06 mikeb Exp $	*/
d144 3
d251 1
a251 1
		if (sc->mii_rev < 2) {
d300 3
d307 1
a307 1
	if (sc->mii_rev < 2) {
a308 1

d332 1
a332 1
	if (sc->mii_rev < 2) {
@


1.30
log
@Fix a common issue across different PHY drivers to reset the
autonegotiation timer when PHY gets the link so that if we
restart the timer the mii_ticks value would be sane.

Lifted originally from FreeBSD, tested by a few on re(4) and
bge(4), ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.29 2008/09/17 07:19:19 brad Exp $	*/
d66 2
a67 6
struct cfattach rgephy_ca = {
	sizeof(struct mii_softc),
	rgephymatch,
	rgephyattach,
	mii_phy_detach,
	mii_phy_activate
@


1.29
log
@Remove the unsupported media types explicitly listed in the switch cases
for MII_MEDIACHG. The default case will catch these media types.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.28 2008/06/10 21:15:14 brad Exp $	*/
d254 2
a255 1
			if (reg & RL_GMEDIASTAT_LINK)
d257 1
d260 2
a261 1
			if (reg & RGEPHY_SR_LINK)
d263 1
d274 1
a274 1
		return (0);
@


1.28
log
@Some header cleanup. Remove some unused headers and shuffle some around
for consistency between drivers.

"looks good" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.27 2008/05/24 01:08:21 brad Exp $	*/
a222 1
		case IFM_100_T4:
@


1.27
log
@Store the model and revision information in the appropriate softc
fields that already exist and reference those fields when necessary
instead of reading the registers everytime.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.26 2008/05/23 23:14:21 kettenis Exp $	*/
a44 1
#include <sys/timeout.h>
d47 2
a51 1
#ifdef INET
a53 3
#endif

#include <dev/pci/pcivar.h>
a59 2

#include <machine/bus.h>
@


1.26
log
@Fix detection of 10baseT on rev 2 and up.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.25 2007/10/10 12:14:26 jsg Exp $	*/
d129 2
a152 1
	uint16_t id2;
d258 1
a258 2
		id2 = PHY_READ(sc, MII_PHYIDR2);
		if (MII_REV(id2) < 2) {
a302 1
	uint16_t id2;
d307 1
a307 3
	id2 = PHY_READ(sc, MII_PHYIDR2);

	if (MII_REV(id2) < 2) {
d333 1
a333 1
	if (MII_REV(id2) < 2) {
a397 1
	uint16_t id2;
d400 1
a400 2
	id2 = PHY_READ(sc, MII_PHYIDR2);
	if (MII_REV(id2) < 2) {
a428 1
	u_int16_t id2;
d430 1
a430 2
	id2 = PHY_READ(sc, MII_PHYIDR2);
	if (MII_REV(id2) > 1)
@


1.25
log
@Add support for the RTL8211B PHY based on a patch by
Michael Eisele for FreeBSD.

This fixes nfe/rgephy for ckuethe & couderc.
Tested on re/rgephy by pyr.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.24 2007/01/21 22:37:56 kettenis Exp $	*/
d356 1
a356 1
		else if (bmsr & RL_GMEDIASTAT_10MBPS)
@


1.24
log
@Use MII_ANEGTICKS_GIGE instead of MII_ANEGTICKS.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.23 2006/12/31 15:04:33 krw Exp $	*/
d151 1
d257 10
a266 3
		reg = PHY_READ(sc, RL_GMEDIASTAT);
		if (reg & RL_GMEDIASTAT_LINK)
			break;
d303 1
d308 12
a319 1
	bmsr = PHY_READ(sc, RL_GMEDIASTAT);
a320 2
	if (bmsr & RL_GMEDIASTAT_LINK)
		mii->mii_media_status |= IFM_ACTIVE;
d336 29
a364 12
	bmsr = PHY_READ(sc, RL_GMEDIASTAT);
	if (bmsr & RL_GMEDIASTAT_1000MBPS)
		mii->mii_media_active |= IFM_1000_T;
	else if (bmsr & RL_GMEDIASTAT_100MBPS)
		mii->mii_media_active |= IFM_100_TX;
	else if (bmsr & RL_GMEDIASTAT_10MBPS)
		mii->mii_media_active |= IFM_10_T;

	if (bmsr & RL_GMEDIASTAT_FDX)
		mii->mii_media_active |= mii_phy_flowstatus(sc) | IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;
d401 1
d404 5
a408 2
	PHY_WRITE(sc, RGEPHY_MII_BMCR, RGEPHY_BMCR_PDOWN);
	DELAY(1000);
@


1.23
log
@Bring last few phys into line by calling their XXX_status() functions
through mii_phy_status() rather than directly. No functional change.

from brad@@ ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.22 2006/12/30 23:04:39 kettenis Exp $	*/
d131 1
a131 1
	sc->mii_anegticks = MII_ANEGTICKS;
@


1.22
log
@Set MASTER based on IFM_ETH_MASTER instead of LINK0.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.21 2006/12/30 09:38:28 kettenis Exp $	*/
d272 1
a272 1
	rgephy_status(sc);
@


1.21
log
@Add flow control support.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.20 2006/12/27 19:11:09 kettenis Exp $	*/
d212 3
a214 13
			/*
			 * When setting the link manually, one side must
			 * be the master and the other the slave. However
			 * ifmedia doesn't give us a good way to specify
			 * this, so we fake it by using one of the LINK
			 * flags. If LINK0 is set, we program the PHY to
			 * be a master, otherwise it's a slave.
			 */
			if (IFM_SUBTYPE(ife->ifm_media) == IFM_1000_T) {
				gig |= RGEPHY_1000CTL_MSE;
				if (mii->mii_ifp->if_flags & IFF_LINK0)
					gig |= RGEPHY_1000CTL_MSC;
			}
@


1.20
log
@Always explicitly set IFM_HDX for half-duplex.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.19 2006/12/22 14:12:53 kettenis Exp $	*/
d337 1
a337 1
		mii->mii_media_active |= IFM_FDX;
d351 2
d356 5
a360 2
	PHY_WRITE(sc, RGEPHY_MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
@


1.19
log
@Fix check for active 1000baseT media.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.18 2006/12/20 22:18:05 kettenis Exp $	*/
d335 1
d338 2
@


1.18
log
@Set IFM_ETH_MASTER if local PHY configuration resolved to MASTER.

ok deraadt@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.17 2006/10/07 23:44:51 brad Exp $	*/
d339 1
a339 1
	if ((mii->mii_media_active & IFM_1000_T) &&
@


1.17
log
@g/c unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.16 2006/09/17 19:36:54 brad Exp $	*/
d304 1
a304 1
	int bmsr, bmcr;
d337 5
@


1.16
log
@do not fill in the anar for the manual 1000baseT media setting case.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.15 2006/08/28 01:54:24 brad Exp $	*/
a185 7
#ifdef foo
			/*
			 * If we're already in auto mode, just return.
			 */
			if (PHY_READ(sc, RGEPHY_MII_BMCR) & RGEPHY_BMCR_AUTOEN)
				return (0);
#endif
d231 1
a231 1
#ifdef foo
@


1.15
log
@Fix manual media types by always leaving the PHY in autoneg mode but adjusting
the ANAR as appropriate.

Derived from a diff for FreeBSD; same technique used by the Linux r8169 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.14 2006/08/11 19:50:48 brad Exp $	*/
a196 2
			anar |= RGEPHY_ANAR_TX_FD | RGEPHY_ANAR_TX |
				RGEPHY_ANAR_10_FD | RGEPHY_ANAR_10;
@


1.14
log
@typo, settning -> setting
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.13 2006/07/23 06:40:05 brad Exp $	*/
d150 1
a150 1
	int reg, speed, gig;
d180 4
d197 2
d202 1
d206 1
d211 3
a213 1
				gig = RGEPHY_1000CTL_AFD;
d215 4
a218 1
				gig = RGEPHY_1000CTL_AHD;
a220 11
			PHY_WRITE(sc, RGEPHY_MII_1000CTL, 0);
			PHY_WRITE(sc, RGEPHY_MII_BMCR, speed);
			PHY_WRITE(sc, RGEPHY_MII_ANAR, RGEPHY_SEL_TYPE);

			if (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_T) 
				break;

			PHY_WRITE(sc, RGEPHY_MII_1000CTL, gig);
			PHY_WRITE(sc, RGEPHY_MII_BMCR,
			    speed|RGEPHY_BMCR_AUTOEN|RGEPHY_BMCR_STARTNEG);

d229 4
a232 6
			if ((mii->mii_ifp->if_flags & IFF_LINK0)) {
				PHY_WRITE(sc, RGEPHY_MII_1000CTL,
				    gig|RGEPHY_1000CTL_MSE|RGEPHY_1000CTL_MSC);
			} else {
				PHY_WRITE(sc, RGEPHY_MII_1000CTL,
				    gig|RGEPHY_1000CTL_MSE);
d234 5
d300 1
a300 1
	    cmd == MII_MEDIACHG) {
d302 2
a303 1
	}
d305 1
@


1.13
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.12 2006/06/27 05:36:58 brad Exp $	*/
d220 1
a220 1
			 * When settning the link manually, one side must
@


1.12
log
@* Correct the rgephy driver so that it only applies the DSP fixup for
  PHY revs 0 and 1. Later chips are fixed and don't need the fixup.

* Make the rgephy driver advertise both 1000_FD and 1000_HD bits in
  autoneg mode. A couple of the devices don't autoneg correctly unless
  configured this way.

From wpaul FreeBSD

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.11 2005/07/22 11:48:10 brad Exp $	*/
d45 1
@


1.11
log
@more Marvell and Realtek PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.10 2005/05/27 08:04:15 brad Exp $	*/
a133 2
	PHY_RESET(sc);

d141 2
a329 4
	if (bmsr & RL_GMEDIASTAT_10MBPS)
		mii->mii_media_active |= IFM_10_T;
	if (bmsr & RL_GMEDIASTAT_100MBPS)
		mii->mii_media_active |= IFM_100_TX;
d332 4
d350 2
a351 1
	PHY_WRITE(sc, RGEPHY_MII_1000CTL, RGEPHY_1000CTL_AFD);
d371 1
a371 4
		if (!(bmsr & RGEPHY_BMSR_LINK)) {
#if 0
			device_printf(sc->mii_dev, "looped %d\n", i);
#endif
a372 1
		}
d385 3
a387 2
 * order to reliably negotiate a 1000Mbps link. Later revs of the
 * chips may not require this software tuning.
d393 5
@


1.10
log
@some cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.9 2005/03/26 04:40:09 krw Exp $	*/
d94 2
@


1.9
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.8 2005/02/19 06:00:04 brad Exp $	*/
a87 1
int	rgephy_mii_model;
d107 1
a107 1
		return(10);
d109 1
a109 1
	return(0);
a125 2
	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_rev = MII_REV(ma->mii_id2);
@


1.8
log
@use mii_phy_match()
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.7 2005/01/28 18:27:55 brad Exp $	*/
d131 1
a131 2
	sc->mii_ticks = 0; /* XXX */
	sc->mii_anegticks = 5;
d275 1
a275 1
		 * Only retry autonegotiation every 5 seconds.
d277 1
a277 1
		if (++sc->mii_ticks <= sc->mii_anegticks /*10*/)
@


1.7
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.6 2004/10/29 01:52:35 pvalchev Exp $	*/
d94 8
d107 1
a107 2
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxREALTEK &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_xxREALTEK_RTL8169S) {
a108 1
	}
d119 1
d121 2
a122 2
	printf(": %s, rev. %d\n", MII_STR_xxREALTEK_RTL8169S,
	    MII_REV(ma->mii_id2));
@


1.6
log
@remove double "PHY" printed in dmesg; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.5 2004/10/28 23:37:11 pvalchev Exp $	*/
d123 1
a123 1
	sc->mii_flags = mii->mii_flags | MIIF_NOISOLATE;
d126 2
@


1.5
log
@fix/update FreeBSD RCSId for reference purposes
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.4 2004/09/27 18:25:48 brad Exp $	*/
d114 1
a114 1
	printf(": %s, rev. %d PHY\n", MII_STR_xxREALTEK_RTL8169S,
@


1.4
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.3 2004/09/26 00:59:58 brad Exp $	*/
d32 2
@


1.3
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.2 2004/09/20 06:05:27 brad Exp $	*/
d93 1
a93 4
rgephymatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d106 1
a106 3
rgephyattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d137 1
a137 4
rgephy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d293 1
a293 2
rgephy_status(sc)
	struct mii_softc *sc;
d333 1
a333 2
rgephy_mii_phy_auto(mii)
	struct mii_softc *mii;
d335 2
a336 2
	rgephy_loop(mii);
	PHY_RESET(mii);
d338 2
a339 2
	PHY_WRITE(mii, RGEPHY_MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
d341 1
a341 1
	PHY_WRITE(mii, RGEPHY_MII_1000CTL, RGEPHY_1000CTL_AFD);
d343 1
a343 1
	PHY_WRITE(mii, RGEPHY_MII_BMCR,
@


1.2
log
@don't include sys/malloc.h, no memory management functions are used
by any of the MII drivers.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rgephy.c,v 1.1 2004/06/05 05:49:29 pvalchev Exp $	*/
d88 4
d122 1
a124 2
	sc->mii_service = rgephy_service;
	sc->mii_status = rgephy_status;
d130 1
a130 1
	rgephy_reset(sc);
d176 1
a176 1
		rgephy_reset(sc);	/* XXX hardware bug work-around */
d346 1
a346 1
	rgephy_reset(mii);
@


1.1
log
@Driver for the RealTek 8169S/8110S internal 10/100/1000 PHY
from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 1
#include <sys/malloc.h>
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

