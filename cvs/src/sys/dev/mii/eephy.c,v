head	1.56;
access;
symbols
	OPENBSD_6_1:1.56.0.8
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.56.0.6
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.4
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.50.0.12
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.10
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.8
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.6
	OPENBSD_5_0:1.50.0.4
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.4
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.40.0.4
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.40.0.2
	OPENBSD_4_1_BASE:1.40
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.7
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.56
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.55;
commitid	p4LJxGKbi0BU2cG6;

1.55
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.54;
commitid	t9FBKDfc4VDxpEy2;

1.54
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2013.12.28.20.32.16;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2013.12.28.03.28.45;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2013.12.08.15.53.01;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.11.23.06.59.27;	author kevlo;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.24.15.54.07;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2009.06.04.05.19.38;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.22.16.37.55;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.07.20.41.05;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.09.00.25.55;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.12.05.31.14;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.18.18.10.13;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.06.12.32.09;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2007.10.05.10.26.27;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.11.21.29.24;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.05.21.40.45;	author kettenis;	state Exp;
branches;
next	1.38;

1.38
date	2006.12.30.20.37.46;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.29.11.03.46;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.28.09.26.19;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.22.13.43.00;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.28.18.23.10;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.02.04.09.20;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.02.03.44.18;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.01.15.47.03;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.01.15.17.25;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.21.03.06.06;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.28.15.50.17;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.28.15.43.42;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.08.00.27.12;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.01.05.29.09;	author pascoe;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.29.00.22.46;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.15.03.06.21;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.06.07.16.47;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.14.01.35.09;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.02.00.21.32;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.22.11.48.10;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.19.19.30.14;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.05.22.30.52;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.05.19.11.34;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.28.18.27.55;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.29.01.30.45;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.02.22.44.27;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.01.04.46.13;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.14.05.09.43;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2002.04.26.03.34.35;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.02.14.52.27;	author lebel;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.02.13.05.09;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.05.18.26.48;	author nate;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.04.14.09.36.20;	author deraadt;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.04.13.00.25.02;	author mjacob;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.25.21;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2003.03.28.00.38.19;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.05.16.00.29.41;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.02.19.10.56.24;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.42.23;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.05.19.22.20.35;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: eephy.c,v 1.55 2014/12/05 15:50:04 mpi Exp $	*/
/*
 * Principal Author: Parag Patel
 * Copyright (c) 2001
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Additonal Copyright (c) 2001 by Traakan Software under same licence.
 * Secondary Author: Matthew Jacob
 */

/*
 * driver for the Marvell 88E1000 series external 1000/100/10-BT PHY.
 */

/*
 * Support added for the Marvell 88E1011 (Alaska) 1000/100/10baseTX and
 * 1000baseSX PHY.
 * Nathan Binkert <nate@@openbsd.org>
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_media.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/eephyreg.h>

int	eephy_match(struct device *, void *, void *);
void	eephy_attach(struct device *, struct device *, void *);

struct cfattach eephy_ca = {
	sizeof (struct mii_softc), eephy_match, eephy_attach, mii_phy_detach
};

struct cfdriver eephy_cd = {
	NULL, "eephy", DV_DULL
};

int	eephy_service(struct mii_softc *, struct mii_data *, int);
void	eephy_status(struct mii_softc *);
void	eephy_reset(struct mii_softc *);

const struct mii_phy_funcs eephy_funcs = {
	eephy_service, eephy_status, eephy_reset,
};

static const struct mii_phydesc eephys[] = {
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_1,
	  MII_STR_MARVELL_E1000_1 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_2,
	  MII_STR_MARVELL_E1000_2 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_3,
	  MII_STR_MARVELL_E1000_3 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_4,
	  MII_STR_MARVELL_E1000_4 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000S,
	  MII_STR_MARVELL_E1000S },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1011,
	  MII_STR_MARVELL_E1011 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1111,
	  MII_STR_MARVELL_E1111 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1112,
	  MII_STR_MARVELL_E1112 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1116,
	  MII_STR_MARVELL_E1116 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1116R,
	  MII_STR_MARVELL_E1116R },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1118,
	  MII_STR_MARVELL_E1118 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1149,
	  MII_STR_MARVELL_E1149 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E3016,
	  MII_STR_MARVELL_E3016},
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E3082,
	  MII_STR_MARVELL_E3082 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_PHYG65G,
	  MII_STR_MARVELL_PHYG65G },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_5,
	  MII_STR_xxMARVELL_E1000_5 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_6,
	  MII_STR_xxMARVELL_E1000_6 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_7,
	  MII_STR_xxMARVELL_E1000_7 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1111,
	  MII_STR_xxMARVELL_E1111 },

	{ 0,				0,
	  NULL },
};

int
eephy_match(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, eephys) != NULL)
		return (10);

	return (0);
}

void
eephy_attach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;
	int reg, page;

	mpd = mii_phy_match(ma, eephys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_funcs = &eephy_funcs;
	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;

	/* XXX No loopback support yet, although the hardware can do it. */
	sc->mii_flags |= MIIF_NOLOOP;

	/* Make sure page 0 is selected. */
        PHY_WRITE(sc, E1000_EADR, 0);

	/* Switch to copper-only mode if necessary. */
	if (sc->mii_model == MII_MODEL_MARVELL_E1111 &&
	    (sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		/*
		 * The onboard 88E1111 PHYs on the Sun X4100 M2 come
		 * up with fiber/copper auto-selection enabled, even
		 * though the machine only has copper ports.  This
		 * makes the chip autoselect to 1000baseX, and makes
		 * it impossible to select any other media.  So
		 * disable fiber/copper autoselection.
		 */
		reg = PHY_READ(sc, E1000_ESSR);
		if ((reg & E1000_ESSR_HWCFG_MODE) == E1000_ESSR_RGMII_COPPER) {
			reg |= E1000_ESSR_DIS_FC;
			PHY_WRITE(sc, E1000_ESSR, reg);
		}
	}

	/* Switch to fiber-only mode if necessary. */
	if (sc->mii_model == MII_MODEL_MARVELL_E1112 &&
	    sc->mii_flags & MIIF_HAVEFIBER) {
		page = PHY_READ(sc, E1000_EADR);
		PHY_WRITE(sc, E1000_EADR, 2);
		reg = PHY_READ(sc, E1000_SCR);
		reg &= ~E1000_SCR_MODE_MASK;
		reg |= E1000_SCR_MODE_1000BX;
		PHY_WRITE(sc, E1000_SCR, reg);
		PHY_WRITE(sc, E1000_EADR, page);
	}

	PHY_RESET(sc);

	sc->mii_capabilities = PHY_READ(sc, E1000_SR) & ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_EXTSTAT)
		sc->mii_extcapabilities = PHY_READ(sc, E1000_ESR);

	mii_phy_add_media(sc);

}

void
eephy_reset(struct mii_softc *sc)
{
	int reg, i;

	reg = PHY_READ(sc, E1000_CR);
	reg |= E1000_CR_RESET;
	PHY_WRITE(sc, E1000_CR, reg);
	
	for (i = 0; i < 500; i++) {
		DELAY(1);
		reg = PHY_READ(sc, E1000_CR);
		if (!(reg & E1000_CR_RESET))
			break;
	}

	/*
	 * Initialize PHY Specific Control Register.
	 */
	reg = PHY_READ(sc, E1000_SCR);

	/* Assert CRS on transmit. */
	reg |= E1000_SCR_ASSERT_CRS_ON_TX;

	/* Enable auto crossover. */
	switch (sc->mii_model) {
	case MII_MODEL_MARVELL_E3016:
	case MII_MODEL_MARVELL_E3082:
		/* Bits are in a different position.  */
		reg |= (E1000_SCR_AUTO_X_MODE >> 1);
		break;
	default:
		/* Automatic crossover causes problems for 1000baseX. */
		if (sc->mii_flags & MIIF_IS_1000X)
			reg &= ~E1000_SCR_AUTO_X_MODE;
		else
			reg |= E1000_SCR_AUTO_X_MODE;
	}

	/* Disable energy detect; only available on some models. */
	switch(sc->mii_model) {
	case MII_MODEL_MARVELL_E3016:
		reg &= ~E3000_SCR_EN_DETECT_MASK;
		break;
	case MII_MODEL_MARVELL_E1011:
	case MII_MODEL_MARVELL_E1111:
	case MII_MODEL_MARVELL_E1112:
	case MII_MODEL_MARVELL_PHYG65G:
		reg &= ~E1000_SCR_EN_DETECT_MASK;
		break;
	}

	/* Enable scrambler if necessary. */
	if (sc->mii_model == MII_MODEL_MARVELL_E3016)
		reg &= ~E3000_SCR_SCRAMBLER_DISABLE;

	/*
	 * Store next page in the Link Partner Next Page register for
	 * compatibility with 802.3ab.
	 */
	if (sc->mii_model == MII_MODEL_MARVELL_E3016)
		reg |= E3000_SCR_REG8_NEXT_PAGE;

	PHY_WRITE(sc, E1000_SCR, reg);

	/* 25 MHz TX_CLK should always work. */
	reg = PHY_READ(sc, E1000_ESCR);
	reg |= E1000_ESCR_TX_CLK_25;
	PHY_WRITE(sc, E1000_ESCR, reg);

	/* Configure LEDs if they were left unconfigured. */
	if (sc->mii_model == MII_MODEL_MARVELL_E3016 &&
	    PHY_READ(sc, 0x16) == 0) {
		reg = (0x0b << 8) | (0x05 << 4) | 0x04;	/* XXX */
		PHY_WRITE(sc, 0x16, reg);
	}

	/*
	 * Do a software reset for these settings to take effect.
	 * Disable autonegotiation, such that all capabilities get
	 * advertised when it is switched back on.
	 */
	reg = PHY_READ(sc, E1000_CR);
	reg &= ~E1000_CR_AUTO_NEG_ENABLE;
	PHY_WRITE(sc, E1000_CR, reg | E1000_CR_RESET);
}

int
eephy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			bmcr = PHY_READ(sc, E1000_CR);
			PHY_WRITE(sc, E1000_CR, bmcr | E1000_CR_ISOLATE);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		mii_phy_setmedia(sc);

		/*
		 * If autonegitation is not enabled, we need a
		 * software reset for the settings to take effect.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO) {
			bmcr = PHY_READ(sc, E1000_CR);
			PHY_WRITE(sc, E1000_CR, bmcr | E1000_CR_RESET);
		}
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		if (mii_phy_tick(sc) == EJUSTRETURN)
                        return (0);
		break;

	case MII_DOWN:
		mii_phy_down(sc);
                return (0);
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
	return (0);
}

void
eephy_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	int bmcr, gsr, ssr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmcr = PHY_READ(sc, E1000_CR);
	ssr = PHY_READ(sc, E1000_SSR);

	if (ssr & E1000_SSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	if (bmcr & E1000_CR_LOOPBACK)
		mii->mii_media_active |= IFM_LOOP;

	if (!(ssr & E1000_SSR_SPD_DPLX_RESOLVED)) {
		/* Erg, still trying, I guess... */
		mii->mii_media_active |= IFM_NONE;
		return;
	}

	if (sc->mii_flags & MIIF_IS_1000X) {
		mii->mii_media_active |= IFM_1000_SX;
	} else {
		if (ssr & E1000_SSR_1000MBS)
			mii->mii_media_active |= IFM_1000_T;
		else if (ssr & E1000_SSR_100MBS)
			mii->mii_media_active |= IFM_100_TX;
		else
			mii->mii_media_active |= IFM_10_T;
	}

	if (ssr & E1000_SSR_DUPLEX)
		mii->mii_media_active |= mii_phy_flowstatus(sc) | IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;

	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
		gsr = PHY_READ(sc, E1000_1GSR) | PHY_READ(sc, E1000_1GSR);
		if (gsr & E1000_1GSR_MS_CONFIG_RES)
			mii->mii_media_active |= IFM_ETH_MASTER;
	}
}
@


1.55
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.54 2014/09/14 14:17:25 jsg Exp $	*/
a44 1
#include <sys/kernel.h>
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.53 2013/12/28 20:32:16 brad Exp $	*/
d50 1
@


1.53
log
@Always call PHY_RESET upon attaching eephy(4) so as to do PHY initialization,
to match behavior before rev 1.52.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.52 2013/12/28 03:28:45 deraadt Exp $	*/
a47 1
#include <sys/proc.h>
@


1.52
log
@Move the fairly heavy eephy_init sequence [which was only done at
attach() and activate() time] into the eephy_reset() routine.  This
means that a bit more work gets done at PHY_RESET time, but it means
also means it gets done in all scenarios.  Why?  For the next commit...
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.51 2013/12/08 15:53:01 deraadt Exp $	*/
a172 2

			PHY_RESET(sc);
d186 1
d188 1
a188 2
		PHY_RESET(sc);
	}
@


1.51
log
@remove case that does nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.50 2010/11/23 06:59:27 kevlo Exp $	*/
a60 1
int	eephy_activate(struct device *, int);
d63 1
a63 2
	sizeof (struct mii_softc), eephy_match, eephy_attach,
	mii_phy_detach, eephy_activate
a69 1
void	eephy_init(struct mii_softc *);
a197 1
	eephy_init(sc);
d200 2
a201 2
int
eephy_activate(struct device *self, int act)
d203 1
a203 1
	struct mii_softc *sc = (void *)self;
d205 9
a213 4
	switch (act) {
	case DVACT_RESUME:
		eephy_init(sc);
		break;
a215 8
	return (0);
}

void
eephy_init(struct mii_softc *sc)
{
	int reg;

a218 1

a284 17
}

void
eephy_reset(struct mii_softc *sc)
{
	int reg, i;

	reg = PHY_READ(sc, E1000_CR);
	reg |= E1000_CR_RESET;
	PHY_WRITE(sc, E1000_CR, reg);
	
	for (i = 0; i < 500; i++) {
		DELAY(1);
		reg = PHY_READ(sc, E1000_CR);
		if (!(reg & E1000_CR_RESET))
			break;
	}
@


1.50
log
@Recognize the Marvell PHYG65G Gig PHY; tested by Frans Haarman
From FreeBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.49 2009/11/24 15:54:07 kettenis Exp $	*/
a209 2
	case DVACT_SUSPEND:
		break;
@


1.49
log
@Properly re-initialise the PHY upon resume.

ok deraadt@@, claudio@@, mlarkin@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.48 2009/06/04 05:19:38 kettenis Exp $	*/
d110 2
d257 1
@


1.48
log
@Store next page in the Link Partner Next Page register for compatibility with
802.3ab on 88E3016 PHYs.  Fixes some autonegotiation problems on msk(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.47 2009/02/22 16:37:55 kettenis Exp $	*/
d59 3
a61 4
int	eephy_service(struct mii_softc *, struct mii_data *, int);
void	eephy_status(struct mii_softc *);
int	eephymatch(struct device *, void *, void *);
void	eephyattach(struct device *, struct device *, void *);
d64 2
a65 2
	sizeof (struct mii_softc), eephymatch, eephyattach,
	mii_phy_detach, mii_phy_activate
d72 3
d124 1
a124 1
eephymatch(struct device *parent, void *match, void *aux)
d135 1
a135 1
eephyattach(struct device *parent, struct device *self, void *aux)
d198 24
@


1.47
log
@Make 88E3016 actually work.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.46 2008/10/07 20:41:05 kettenis Exp $	*/
d224 1
a224 1
		reg &= ~0x4000;	/* XXX */
d235 8
a242 1
		reg &= ~E1000_SCR_SCRAMBLER_DISABLE;
@


1.46
log
@Make sure page 0 is selected when we initialize the PHY.  Fixes problems
with the eephy(4) that attaches to nfe(4) on machines like the Sun Ultra 40.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.45 2008/09/09 00:25:55 brad Exp $	*/
d223 3
a228 1
		/* Disable energy detect. */
d233 4
d243 7
@


1.45
log
@Recognize the Marvell 88E1116R Gig PHY.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.44 2008/07/12 05:31:14 brad Exp $	*/
d153 3
@


1.44
log
@Add support for the Marvell 88E8016 PHY.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.43 2007/11/18 18:10:13 krw Exp $	*/
d98 2
@


1.43
log
@eephy_mii_phy_auto() was deleted in r1.38. So delete the declaration too.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.42 2007/10/06 12:32:09 kettenis Exp $	*/
d102 2
d203 1
@


1.42
log
@Oops, committed this with a typo, which made it do not quite the right thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.41 2007/10/05 10:26:27 kettenis Exp $	*/
a72 1
int	eephy_mii_phy_auto(struct mii_softc *);
@


1.41
log
@Disable fiber/copper auto-selection on the 88E1111 if it is in RGMII mode, to
work around the fact that the onboard PHYs attached to nfe(4) on the Sun
X4100 M2 have fiber/copper auto-selection enabled even though the interfaces
are clearly copper-only.

Fixes PR system/5587.

ok jsg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.40 2007/02/11 21:29:24 kettenis Exp $	*/
d163 1
a163 1
		if ((reg & E1000_ESSR_HWCFG_MODE) == E1000_ESSR_GMII_COPPER) {
@


1.40
log
@Add support for fiber on the 88E1112 (88E8021/22 integrated PHY).
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.39 2007/01/05 21:40:45 kettenis Exp $	*/
d150 20
@


1.39
log
@Now that all ethernet drivers that support flow control set MIIF_DOPAUSE,
stop doing it here.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.38 2006/12/30 20:37:46 kettenis Exp $	*/
d136 1
a136 1
	int reg;
d151 14
d334 1
a334 2
		if (ssr & E1000_SSR_1000MBS)
			mii->mii_media_active |= IFM_1000_SX;
@


1.38
log
@Rewrite eephy(4) to take advantage of generic phy code.
Enable auto MDI/MDIX on PHY's that support it.
Disable energy detect on PHY's that need it.

tested on gem(4), msk(4), nfe(4), sk(4), stge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.37 2006/12/29 11:03:46 kettenis Exp $	*/
a146 6

	/*
	 * XXX really should be passed by the network controller
	 * driver, since the MAC might not support it.
	 */
	sc->mii_flags |= MIIF_DOPAUSE;
@


1.37
log
@No need to read ANAR and ANLPAR anymore.

From brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.36 2006/12/28 09:26:19 kettenis Exp $	*/
a117 2
static int fast_ether;

d136 1
a146 1
	sc->mii_anegticks = MII_ANEGTICKS_GIGE;
d154 30
a183 11
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1011 && 
	    (PHY_READ(sc, E1000_ESSR) & E1000_ESSR_FIBER_LINK))
		sc->mii_flags |= MIIF_HAVEFIBER;

	fast_ether = 0;
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E3082) {
		/* 88E3082 10/100 Fast Ethernet PHY. */
		sc->mii_anegticks = MII_ANEGTICKS;
		fast_ether = 1;
d186 9
a194 1
	PHY_RESET(sc);
d196 1
a196 28
#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),
	    E1000_CR_ISOLATE);

	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		if (fast_ether == 0) {
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
			    sc->mii_inst), E1000_CR_SPEED_1000 |
			    E1000_CR_FULL_DUPLEX);
			/*
			 * 1000BT-simplex not supported; driver must ignore this entry,
			 * but it must be present in order to manually set full-duplex.
			 */
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
			    sc->mii_inst), E1000_CR_SPEED_1000);
		}
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_100 | E1000_CR_FULL_DUPLEX);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),
		    E1000_CR_SPEED_100);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_10 | E1000_CR_FULL_DUPLEX);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),
		    E1000_CR_SPEED_10);
	} else {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX,sc->mii_inst),
		    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
	}
d198 4
a201 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst), 0);
d203 8
a210 1
#undef ADD
d216 1
a216 7
	u_int32_t reg;
	int i;

	/* initialize custom E1000 registers to magic values */
	reg = PHY_READ(sc, E1000_SCR);
	reg &= ~E1000_SCR_AUTO_X_MODE;
	PHY_WRITE(sc, E1000_SCR, reg);
a217 2
	/* normal PHY reset */
	/*mii_phy_reset(sc);*/
d221 1
a221 1

a227 14

	/* set more custom E1000 registers to magic values */
	reg = PHY_READ(sc, E1000_SCR);
	reg |= E1000_SCR_ASSERT_CRS_ON_TX;
	PHY_WRITE(sc, E1000_SCR, reg);

	reg = PHY_READ(sc, E1000_ESCR);
	reg |= E1000_ESCR_TX_CLK_25;
	PHY_WRITE(sc, E1000_ESCR, reg);

	/* even more magic to reset DSP? */
	PHY_WRITE(sc, 29, 0x1d);
	PHY_WRITE(sc, 30, 0xc1);
	PHY_WRITE(sc, 30, 0x00);
d234 1
a234 1
	int reg;
d254 2
a255 2
			reg = PHY_READ(sc, E1000_CR);
			PHY_WRITE(sc, E1000_CR, reg | E1000_CR_ISOLATE);
d265 1
a265 5
		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			PHY_RESET(sc);
			(void) eephy_mii_phy_auto(sc);
			break;
d267 7
a273 56
		case IFM_1000_SX:
			if (fast_ether == 1)
				return (EINVAL);

			PHY_RESET(sc);

			PHY_WRITE(sc, E1000_CR,
			    E1000_CR_FULL_DUPLEX | E1000_CR_SPEED_1000);
			PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD);
			break;

		case IFM_1000_T:
			if (fast_ether == 1)
				return (EINVAL);

			PHY_RESET(sc);

			/* TODO - any other way to force 1000BT? */
			(void) eephy_mii_phy_auto(sc);
			break;

		case IFM_100_TX:
			PHY_RESET(sc);

			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				PHY_WRITE(sc, E1000_CR,
				    E1000_CR_FULL_DUPLEX | E1000_CR_SPEED_100);
				PHY_WRITE(sc, E1000_AR, E1000_AR_100TX_FD);
			} else {
				PHY_WRITE(sc, E1000_CR, E1000_CR_SPEED_100);
				PHY_WRITE(sc, E1000_AR, E1000_AR_100TX);
			}
			break;

		case IFM_10_T:
			PHY_RESET(sc);

			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				PHY_WRITE(sc, E1000_CR,
				    E1000_CR_FULL_DUPLEX | E1000_CR_SPEED_10);
				PHY_WRITE(sc, E1000_AR, E1000_AR_10T_FD);
			} else {
				PHY_WRITE(sc, E1000_CR, E1000_CR_SPEED_10);
				PHY_WRITE(sc, E1000_AR, E1000_AR_10T);
			}

			break;

		case IFM_NONE:
			reg = PHY_READ(sc, E1000_CR);
			PHY_WRITE(sc, E1000_CR,
			    reg | E1000_CR_ISOLATE | E1000_CR_POWER_DOWN);
			break;

		default:
			return (EINVAL);
a274 1

d284 3
a286 29
		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;

		/*
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
		 */
		reg = PHY_READ(sc, E1000_SR) | PHY_READ(sc, E1000_SR);
		if (reg & E1000_SR_LINK_STATUS)
			break;

		/*
		 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
			break;

		sc->mii_ticks = 0;
		PHY_RESET(sc);
d288 3
a290 2
		eephy_mii_phy_auto(sc);
		break;
d294 1
a294 1
	eephy_status(sc);
a297 1

d305 1
a305 1
	int bmsr, bmcr, gsr, ssr;
a309 1
	bmsr = PHY_READ(sc, E1000_SR) | PHY_READ(sc, E1000_SR);
d313 1
a313 1
	if (bmsr & E1000_SR_LINK_STATUS)
d319 1
a319 2
	if ((!(bmsr & E1000_SR_AUTO_NEG_COMPLETE) || !(ssr & E1000_SSR_LINK) ||
	    !(ssr & E1000_SSR_SPD_DPLX_RESOLVED))) {
d325 4
a328 1
	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
a334 3
	} else {
		if (ssr & E1000_SSR_1000MBS)
			mii->mii_media_active |= IFM_1000_SX;
a346 20
}

int
eephy_mii_phy_auto(struct mii_softc *sc)
{
	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		PHY_WRITE(sc, E1000_AR,
			  E1000_AR_10T | E1000_AR_10T_FD |
			  E1000_AR_100TX | E1000_AR_100TX_FD |
			  E1000_AR_PAUSE | E1000_AR_ASM_DIR);
		if (fast_ether == 0)
			PHY_WRITE(sc, E1000_1GCR, E1000_1GCR_1000T_FD);
	} else {
		PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD |
			  E1000_FA_SYM_PAUSE | E1000_FA_ASYM_PAUSE);
	}
	PHY_WRITE(sc, E1000_CR,
	    E1000_CR_AUTO_NEG_ENABLE | E1000_CR_RESTART_AUTO_NEG);

	return (EJUSTRETURN);
@


1.36
log
@Use mii_phy_flowstatus() to set flow control status bits.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.35 2006/12/22 13:43:00 kettenis Exp $	*/
d399 1
a399 1
	int bmsr, bmcr, gsr, ssr, ar, lpar;
a406 2
	ar = PHY_READ(sc, E1000_AR);
	lpar = PHY_READ(sc, E1000_LPAR);
@


1.35
log
@- Add IFM_NONE.
- Don't set MIIF_NOISOLATE so eephy(4) can be used in
  configurations with multiple PHYs.
- When PHY is resolved to a master, show it with IFM_ETH_MASTER.

Based on a diff from yongari@@FreeBSD, through brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.34 2006/11/28 18:23:10 brad Exp $	*/
d150 6
d436 1
a436 1
		mii->mii_media_active |= IFM_FDX;
a443 15
	}

	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
		if ((ar & E1000_AR_PAUSE) && (lpar & E1000_LPAR_PAUSE)) {
			mii->mii_media_active |= IFM_FLAG0 | IFM_FLAG1;
		} else if (!(ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
			   (lpar & E1000_LPAR_PAUSE) &&
			   (lpar & E1000_LPAR_ASM_DIR)) {
			mii->mii_media_active |= IFM_FLAG1;
		} else if ((ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
			   !(lpar & E1000_LPAR_PAUSE) &&
			   (lpar & E1000_LPAR_ASM_DIR)) {
			mii->mii_media_active |= IFM_FLAG0;
		}
@


1.34
log
@sync with new miidevs entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.33 2006/10/02 04:09:20 brad Exp $	*/
d145 1
a149 2
	sc->mii_flags |= MIIF_NOISOLATE;

d166 2
d327 6
d393 1
a393 1
	int bmsr, bmcr, ssr, ar, lpar;
d433 6
@


1.33
log
@do not bother to read the esr and isr registers in the status routine just
to end up not using the information read.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.32 2006/10/02 03:44:18 brad Exp $	*/
a88 4
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_5,
	  MII_STR_MARVELL_E1000_5 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_6,
	  MII_STR_MARVELL_E1000_6 },
d97 4
d105 4
a110 4
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_8,
	  MII_STR_xxMARVELL_E1000_8 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_9,
	  MII_STR_xxMARVELL_E1000_9 },
@


1.32
log
@return EINVAL for the Gig manual media types when attached to a
Fast Ethernet PHY.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.31 2006/10/01 15:47:03 brad Exp $	*/
d386 1
a386 1
	int bmsr, bmcr, esr, ssr, isr, ar, lpar;
a391 1
	esr = PHY_READ(sc, E1000_ESR);
a393 1
	isr = PHY_READ(sc, E1000_ISR);
@


1.31
log
@initial pieces for the 88E3082 Fast Ethernet PHY. untested at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.30 2006/10/01 15:17:25 brad Exp $	*/
d156 1
d279 3
d290 3
@


1.30
log
@add a few new Marvell ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.29 2006/08/21 03:06:06 brad Exp $	*/
a102 1
#if 0
a104 1
#endif
d118 2
d156 7
d168 11
a178 8
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
		/*
		 * 1000BT-simplex not supported; driver must ignore this entry,
		 * but it must be present in order to manually set full-duplex.
		 */
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
		      E1000_CR_SPEED_1000);
d446 2
a447 1
		PHY_WRITE(sc, E1000_1GCR, E1000_1GCR_1000T_FD);
@


1.29
log
@another id.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.28 2006/07/28 15:50:17 brad Exp $	*/
d81 4
a84 12
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_2,
	  MII_STR_xxMARVELL_E1000_2 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_3,
	  MII_STR_xxMARVELL_E1000_3 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1000_5,
	  MII_STR_xxMARVELL_E1000_5 },
	{ MII_OUI_xxMARVELL,		MII_MODEL_xxMARVELL_E1111,
	  MII_STR_xxMARVELL_E1111 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000,
	  MII_STR_MARVELL_E1000 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1011,
	  MII_STR_MARVELL_E1011 },
d93 4
a96 4
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_7,
	  MII_STR_MARVELL_E1000_7 },
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_8,
	  MII_STR_MARVELL_E1000_8 },
d99 16
@


1.28
log
@Simplify autoneg code a bit. Tested on a few sk(4)'s and an axe(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.26 2006/06/08 00:27:12 brad Exp $	*/
d103 2
@


1.27
log
@another Marvell Gig PHY.
@
text
@d73 1
a73 1
int	eephy_mii_phy_auto(struct mii_softc *, int);
a252 6
			/*
			 * If we're already in auto mode, just return.
			 */
			if (sc->mii_flags & MIIF_DOINGAUTO)
				return (0);

d254 1
a254 1
			(void) eephy_mii_phy_auto(sc, 1);
a265 3
			if (sc->mii_flags & MIIF_DOINGAUTO)
				return (0);

d269 1
a269 1
			(void) eephy_mii_phy_auto(sc, 1);
d342 1
a342 3
		if (eephy_mii_phy_auto(sc, 0) == EJUSTRETURN)
			return (0);

d378 1
a378 2
	if ((sc->mii_flags & MIIF_DOINGAUTO) &&
	    (!(bmsr & E1000_SR_AUTO_NEG_COMPLETE) || !(ssr & E1000_SSR_LINK) ||
d419 1
a419 1
eephy_mii_phy_auto(struct mii_softc *sc, int waitfor)
d421 9
a429 47
	int bmsr, i;

	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
			PHY_WRITE(sc, E1000_AR,
				  E1000_AR_10T | E1000_AR_10T_FD |
				  E1000_AR_100TX | E1000_AR_100TX_FD |
				  E1000_AR_PAUSE | E1000_AR_ASM_DIR);
			PHY_WRITE(sc, E1000_1GCR, E1000_1GCR_1000T_FD);
		} else {
			PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD |
				  E1000_FA_SYM_PAUSE | E1000_FA_ASYM_PAUSE);
		}
		PHY_WRITE(sc, E1000_CR,
		    E1000_CR_AUTO_NEG_ENABLE | E1000_CR_RESTART_AUTO_NEG);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			bmsr = PHY_READ(sc, E1000_SR) | PHY_READ(sc, E1000_SR);
			if (bmsr & E1000_SR_AUTO_NEG_COMPLETE)
				return (0);
			DELAY(1000);
		}

		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag. [do it anyway]
		 */
		return (EIO);
	}

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if (sc->mii_flags & MIIF_AUTOTSLEEP) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		tsleep(&sc->mii_flags, PZERO, "miiaut", hz >> 1);
		mii_phy_auto_timeout(sc);
	} else if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add(&sc->mii_phy_timo, hz / 2);
d431 2
@


1.26
log
@do not set the mii_ticks field to zero in the asynchronous autonegotiation
function as this is already done in the MII tick handler just before calling
the autonegotiation function.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.25 2006/06/01 05:29:09 pascoe Exp $	*/
d101 2
@


1.25
log
@Add the MIIF_AUTOTSLEEP flag, needed by gigabit axe(4) devices.

Cloned from mii_physubr.c.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.24 2006/05/29 00:22:46 brad Exp $	*/
a475 1
		sc->mii_ticks = 0;
@


1.24
log
@formatting
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.23 2006/01/15 03:06:21 jsg Exp $	*/
d48 1
d470 5
a474 1
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
@


1.23
log
@The RCJ part of 88E1111-RCJ is the package the ic comes in which
may not be always correct for the id so don't mention it.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.22 2005/11/06 07:16:47 brad Exp $	*/
d253 1
a253 1
			if (sc->mii_flags & MIIF_DOINGAUTO) {
d255 1
a255 1
			}
d451 1
a451 2

			if (bmsr & E1000_SR_AUTO_NEG_COMPLETE) {
a452 1
			}
@


1.22
log
@- move MIIF_NOISOLATE so its set before calling PHY_RESET().
- lower wait for completion time in eephy_mii_phy_auto() from 5 secs
to 500 ms.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.21 2005/08/14 01:35:09 jsg Exp $	*/
d100 2
a101 2
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1111RCJ,
	  MII_STR_MARVELL_E1111RCJ },
@


1.21
log
@Correct one of the unknown marvell phys which is actually 88E1111-RCJ.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.20 2005/08/02 00:21:32 jsg Exp $	*/
d136 2
a144 2
	sc->mii_flags |= MIIF_NOISOLATE;

d151 4
a154 2
		  TODO - apparently 1000BT-simplex not supported?
		  ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
a155 1
		*/
d448 2
a449 2
		/* Wait 5 seconds for it to complete. */
		for (i = 0; i < 5000; i++) {
d475 1
a475 1
		timeout_add(&sc->mii_phy_timo, 5 * hz);
d477 1
@


1.20
log
@Marvell 88E1111 from Dave Huang in NetBSD PR 30556.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.19 2005/07/22 11:48:10 brad Exp $	*/
d100 2
a101 2
	{ MII_OUI_MARVELL,		MII_MODEL_MARVELL_E1000_7,
	  MII_STR_MARVELL_E1000_7 },
@


1.19
log
@more Marvell and Realtek PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.18 2005/06/19 19:30:14 brad Exp $	*/
d86 2
@


1.18
log
@- some clean up
- for consistency fix order of operations for MII_TICK switch case in eephy
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.17 2005/03/26 04:40:09 krw Exp $	*/
d80 2
@


1.17
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.16 2005/02/05 22:30:52 brad Exp $	*/
d111 1
a111 1
	return(0);
a142 1

d240 1
a240 1
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0) {
a241 1
		}
d252 1
a252 1
			(void)eephy_mii_phy_auto(sc, 1);
d270 1
a270 1
			(void)eephy_mii_phy_auto(sc, 1);
d310 1
a310 8
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			return (0);
		}

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO) {
a311 1
		}
d316 1
a316 1
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0) {
a317 1
		}
d320 1
a320 1
		 * Only retry autonegotiation every mii_anegticks seconds.
d322 2
a323 4
		if (++sc->mii_ticks <= sc->mii_anegticks) {
			return (0);
		}
		sc->mii_ticks = 0;
d331 2
d334 4
a337 1
		if (reg & E1000_SR_LINK_STATUS)
d340 1
d343 2
a344 3
		if (eephy_mii_phy_auto(sc, 0) == EJUSTRETURN) {
			return(0);
		}
@


1.16
log
@better
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.15 2005/02/05 19:11:34 brad Exp $	*/
a74 2
extern void	mii_phy_auto_timeout(void *);

d130 1
a130 1
	sc->mii_anegticks = 10;
d331 1
a331 1
		 * Only retry autonegotiation every 5 seconds.
d333 1
a333 1
		if (++(sc->mii_ticks) != sc->mii_anegticks) {
@


1.15
log
@use mii_phy_match()
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.14 2005/01/28 18:27:55 brad Exp $	*/
d110 1
a110 1
	if(mii_phy_match(ma, eephys) != NULL)
@


1.14
log
@Get flags passed down to PHY drivers correctly.  This was done on
an adhoc basis in a couple of PHY drivers, this fixes it more generally.

From NetBSD

Fixes panics with aue(4) NICs.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.13 2004/12/29 01:30:45 brad Exp $	*/
a57 1

d81 24
d110 1
a110 13
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxMARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_5 ))
		return (10);

	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1011 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_4 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_5 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_6 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_7))
d122 1
a122 1
	char *sep;
d124 2
a125 2
	sep = "";
	printf(": %s\n", MII_STR_MARVELL_E1000);
@


1.13
log
@another Marvell PHY
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.12 2004/09/26 00:59:58 brad Exp $	*/
d120 1
a120 1
	sc->mii_flags = mii->mii_flags;
@


1.12
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.11 2003/09/02 22:44:27 krw Exp $	*/
d98 2
a99 1
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_6))
@


1.11
log
@Increase autonegotiation wait to 5000ms.

This gives autonegotiation a fair chance to complete. Copper switches
can take several seconds to do autonegotiation.

Fixes sk need to be poked after reboot and allows sk to use dhcp
configuration. Problem and workaround reported by Laurence Tratt.

Also minor cleanup:

1) Remove duplicate function prototypes/
2) Remove unneeded '#include <malloc.c>'. From FreeBSD.
3) Remove some static's.

ok deraadt@@ nate@@ henning@@ henric@@. Also tested by Laurence Tratt and
Damien Couderc.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.10 2003/08/01 04:46:13 nate Exp $	*/
d78 3
d117 1
a117 2
	sc->mii_service = eephy_service;
	sc->mii_status = eephy_status;
d127 1
a127 1
	eephy_reset(sc);
d243 1
a243 1
			eephy_reset(sc);
d248 1
a248 1
			eephy_reset(sc);
d259 1
a259 1
			eephy_reset(sc);
d266 1
a266 1
			eephy_reset(sc);
d279 1
a279 1
			eephy_reset(sc);
d338 1
a338 1
		eephy_reset(sc);
@


1.10
log
@Support for new Marvell based Gigabit Ethernet adapters
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.9 2003/05/14 05:09:43 nate Exp $	*/
a46 1
#include <sys/malloc.h>
d73 3
a75 3
int eephy_service(struct mii_softc *, struct mii_data *, int);
void eephy_status(struct mii_softc *);
static int	eephy_mii_phy_auto(struct mii_softc *, int);
a76 1
static void eephy_reset(struct mii_softc *);
d158 1
a158 1
static void
d418 1
a418 1
static int
d439 2
a440 2
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
d466 1
a466 1
		timeout_add(&sc->mii_phy_timo, hz >> 1);
@


1.9
log
@use our standard way of identifying MII devices
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.8 2002/11/26 06:01:28 nate Exp $	*/
d37 6
d93 1
d122 5
d132 23
a154 30
#ifdef __OpenBSD__
#define PRINT(s)
#else
#define PRINT(s)	printf("%s%s", sep, s); sep = ", "
#endif

#ifndef __OpenBSD__
	printf("%s: ", sc->mii_dev.dv_xname);
#endif
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX, sc->mii_inst),
			E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
	PRINT("1000baseTX-FDX");
	/*
	TODO - apparently 1000BT-simplex not supported?
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
			E1000_CR_SPEED_1000);
	PRINT("1000baseTX");
	*/
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),
			E1000_CR_SPEED_100 | E1000_CR_FULL_DUPLEX);
	PRINT("100baseTX-FDX");
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),
			E1000_CR_SPEED_100);
	PRINT("100baseTX");
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),
			E1000_CR_SPEED_10 | E1000_CR_FULL_DUPLEX);
	PRINT("10baseTX-FDX");
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),
			E1000_CR_SPEED_10);
	PRINT("10baseTX");
a155 1
	PRINT("auto");
a156 3
#ifndef __OpenBSD__
	printf("\n");
#endif
a157 2
#undef PRINT

d247 8
d387 11
a397 6
	if (ssr & E1000_SSR_1000MBS)
		mii->mii_media_active |= IFM_1000_T;
	else if (ssr & E1000_SSR_100MBS)
		mii->mii_media_active |= IFM_100_TX;
	else
		mii->mii_media_active |= IFM_10_T;
d404 13
a416 9
	/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
	if ((ar & E1000_AR_PAUSE) && (lpar & E1000_LPAR_PAUSE)) {
		mii->mii_media_active |= IFM_FLAG0 | IFM_FLAG1;
	} else if (!(ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
	    (lpar & E1000_LPAR_PAUSE) && (lpar & E1000_LPAR_ASM_DIR)) {
		mii->mii_media_active |= IFM_FLAG1;
	} else if ((ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
	    !(lpar & E1000_LPAR_PAUSE) && (lpar & E1000_LPAR_ASM_DIR)) {
		mii->mii_media_active |= IFM_FLAG0;
d426 10
a435 4
		PHY_WRITE(sc, E1000_AR, E1000_AR_10T | E1000_AR_10T_FD |
		    E1000_AR_100TX | E1000_AR_100TX_FD |
		    E1000_AR_PAUSE | E1000_AR_ASM_DIR);
		PHY_WRITE(sc, E1000_1GCR, E1000_1GCR_1000T_FD);
@


1.8
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.7 2002/05/04 11:30:06 fgsch Exp $	*/
a78 6
	u_int32_t id;

	id = ((ma->mii_id1 << 16) | ma->mii_id2) & E1000_ID_MASK;
	if (id == E1000_ID_88E1000 || id == E1000_ID_88E1000S) {
		return(10);
	}
d88 2
@


1.7
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: eephy.c,v 1.6 2002/04/26 03:34:35 nate Exp $	*/
d133 1
a133 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, IFM_FDX, sc->mii_inst),
d138 1
a138 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, 0, sc->mii_inst),
d252 1
a252 1
		case IFM_1000_TX:
d385 1
a385 1
		mii->mii_media_active |= IFM_1000_TX;
@


1.6
log
@Don't prevent a media status updates just because the interface isn't up.
ok jason
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.5 2002/04/02 14:52:27 lebel Exp $ */
d415 1
a415 1
		    E1000_AR_100TX | E1000_AR_100TX_FD | 
@


1.5
log
@add support for Marvell 88E1000 Gigabit PHY, model 6;
from nate@@, with one forgotten closing ) and a typo. :)
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.4 2002/04/02 13:05:09 nate Exp $ */
a357 3

	if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
		return;
@


1.4
log
@Add some new IDs for the Marvell Gigabit PHY
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.3 2001/10/05 18:26:48 nate Exp $ */
d92 3
a94 1
	    MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_3)
@


1.3
log
@use anegticks for phys that do their own autonegotiation timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.2 2001/04/14 09:36:20 deraadt Exp $ */
d85 10
d115 1
a115 1
	sc->mii_anegticks = 5;
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 12

	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxMARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_5 ))
		return (10);

	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_6))
		return (10);

d105 1
a105 1
	sc->mii_anegticks = 10;
d347 3
d406 1
a406 1
		    E1000_AR_100TX | E1000_AR_100TX_FD |
@


1.3.4.2
log
@sync
@
text
@d79 6
a93 2
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_4 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_5 ||
d133 1
a133 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX, sc->mii_inst),
d138 1
a138 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
d252 1
a252 1
		case IFM_1000_T:
d385 1
a385 1
		mii->mii_media_active |= IFM_1000_T;
@


1.2
log
@quieten this on OpenBSD, information available in ifconfig -m is not needed in dmesg
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.1 2001/04/13 00:25:02 mjacob Exp $ */
d105 1
d308 1
a308 1
		if (++(sc->mii_ticks) != 5) {
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.2 2001/04/14 09:36:20 deraadt Exp $ */
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: eephy.c,v 1.2.4.1 2001/05/14 22:25:21 niklas Exp $ */
a104 1
	sc->mii_anegticks = 5;
d307 1
a307 1
		if (++(sc->mii_ticks) != sc->mii_anegticks) {
@


1.2.4.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 12

	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxMARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxMARVELL_E1000_5 ))
		return (10);

	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_3 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_6))
		return (10);

d105 1
a105 1
	sc->mii_anegticks = 10;
d121 1
a121 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX, sc->mii_inst),
d126 1
a126 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
d240 1
a240 1
		case IFM_1000_T:
d347 3
d376 1
a376 1
		mii->mii_media_active |= IFM_1000_T;
d406 1
a406 1
		    E1000_AR_100TX | E1000_AR_100TX_FD |
@


1.2.4.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d79 6
a93 2
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_4 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1000_5 ||
@


1.2.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a36 6
/*
 * Support added for the Marvell 88E1011 (Alaska) 1000/100/10baseTX and
 * 1000baseSX PHY.
 * Nathan Binkert <nate@@openbsd.org>
 */

d41 1
d68 3
a70 3
int	eephy_mii_phy_auto(struct mii_softc *, int);
void	eephy_reset(struct mii_softc *);

d72 1
a86 1
	     MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1011 ||
a114 5
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_MARVELL &&
	    MII_MODEL(ma->mii_id2) == MII_MODEL_MARVELL_E1011 && 
	    (PHY_READ(sc, E1000_ESSR) & E1000_ESSR_FIBER_LINK))
		sc->mii_flags |= MIIF_HAVEFIBER;

d120 30
a149 23


	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
		/*
		  TODO - apparently 1000BT-simplex not supported?
		  ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0, sc->mii_inst),
		      E1000_CR_SPEED_1000);
		*/
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_100 | E1000_CR_FULL_DUPLEX);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),
		    E1000_CR_SPEED_100);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),
		    E1000_CR_SPEED_10 | E1000_CR_FULL_DUPLEX);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),
		    E1000_CR_SPEED_10);
	} else {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX,sc->mii_inst),
		    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
	}

d151 1
d153 3
d157 2
d161 1
a161 1
void
a247 8
		case IFM_1000_SX:
			eephy_reset(sc);

			PHY_WRITE(sc, E1000_CR,
			    E1000_CR_FULL_DUPLEX | E1000_CR_SPEED_1000);
			PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD);
			break;

d380 6
a385 11
	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		if (ssr & E1000_SSR_1000MBS)
			mii->mii_media_active |= IFM_1000_T;
		else if (ssr & E1000_SSR_100MBS)
			mii->mii_media_active |= IFM_100_TX;
		else
			mii->mii_media_active |= IFM_10_T;
	} else {
		if (ssr & E1000_SSR_1000MBS)
			mii->mii_media_active |= IFM_1000_SX;
	}
d392 9
a400 13
	if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
		if ((ar & E1000_AR_PAUSE) && (lpar & E1000_LPAR_PAUSE)) {
			mii->mii_media_active |= IFM_FLAG0 | IFM_FLAG1;
		} else if (!(ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
			   (lpar & E1000_LPAR_PAUSE) &&
			   (lpar & E1000_LPAR_ASM_DIR)) {
			mii->mii_media_active |= IFM_FLAG1;
		} else if ((ar & E1000_AR_PAUSE) && (ar & E1000_AR_ASM_DIR) &&
			   !(lpar & E1000_LPAR_PAUSE) &&
			   (lpar & E1000_LPAR_ASM_DIR)) {
			mii->mii_media_active |= IFM_FLAG0;
		}
d404 1
a404 1
int
d410 4
a413 10
		if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
			PHY_WRITE(sc, E1000_AR,
				  E1000_AR_10T | E1000_AR_10T_FD |
				  E1000_AR_100TX | E1000_AR_100TX_FD |
				  E1000_AR_PAUSE | E1000_AR_ASM_DIR);
			PHY_WRITE(sc, E1000_1GCR, E1000_1GCR_1000T_FD);
		} else {
			PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD |
				  E1000_FA_SYM_PAUSE | E1000_FA_ASYM_PAUSE);
		}
d419 2
a420 2
		/* Wait 5 seconds for it to complete. */
		for (i = 0; i < 5000; i++) {
d446 1
a446 1
		timeout_add(&sc->mii_phy_timo, 5 * hz);
@


1.1
log
@Add support for the Marvell PHY that's on the Intel GigE cards.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d111 3
d115 1
d117 1
d119 1
d144 1
d146 1
@

